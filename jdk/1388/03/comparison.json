{"files":[{"patch":"@@ -65,0 +65,1 @@\n+        Objects.requireNonNull(name);\n@@ -75,0 +76,1 @@\n+        Objects.requireNonNull(name);\n@@ -85,0 +87,1 @@\n+        Objects.requireNonNull(name);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/AbstractLayout.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+import java.util.stream.Stream;\n@@ -97,0 +98,3 @@\n+ * <p> Unless otherwise specified, passing a {@code null} argument, or an array argument containing one or more {@code null}\n+ * elements to a method in this class causes a {@link NullPointerException NullPointerException} to be thrown. <\/p>\n+ *\n@@ -189,1 +193,2 @@\n-     * Returns a memory layout that is suitable to use the layout for variadic arguments.\n+     * Returns a memory layout that is suitable to use as the layout for variadic arguments in a specialized\n+     * function descriptor.\n@@ -191,1 +196,1 @@\n-     * @param ml the layout the adapt\n+     * @param layout the layout the adapt\n@@ -195,2 +200,3 @@\n-    static <T extends MemoryLayout> T asVarArg(T ml) {\n-        return (T) PlatformLayouts.asVarArg(ml);\n+    static <T extends MemoryLayout> T asVarArg(T layout) {\n+        Objects.requireNonNull(layout);\n+        return (T) PlatformLayouts.asVarArg(layout);\n@@ -210,1 +216,0 @@\n-     * @throws NullPointerException if {@code str == null}.\n@@ -229,1 +234,0 @@\n-     * @throws NullPointerException if either {@code str == null} or {@code charset == null}.\n@@ -249,1 +253,0 @@\n-     * @throws NullPointerException if either {@code str == null} or {@code scope == null}.\n@@ -270,1 +273,0 @@\n-     * @throws NullPointerException if either {@code str == null}, {@code charset == null} or {@code scope == null}.\n@@ -292,1 +294,0 @@\n-     * @throws NullPointerException if {@code addr == null}\n@@ -297,0 +298,1 @@\n+        Objects.requireNonNull(addr);\n@@ -314,1 +316,0 @@\n-     * @throws NullPointerException if {@code addr == null} or {@code charset == null}.\n@@ -333,1 +334,0 @@\n-     * @throws NullPointerException if {@code addr == null}\n@@ -353,1 +353,0 @@\n-     * @throws NullPointerException if {@code addr == null} or {@code charset == null}.\n@@ -411,1 +410,0 @@\n-     * @throws NullPointerException if {@code addr == null}.\n@@ -432,0 +430,3 @@\n+     * <p> Unless otherwise specified, passing a {@code null} argument, or an array argument containing one or more {@code null}\n+     * elements to a method in this class causes a {@link NullPointerException NullPointerException} to be thrown. <\/p>\n+     *\n@@ -517,0 +518,1 @@\n+         * in {@code layouts} is {@code null}.\n@@ -600,0 +602,1 @@\n+            Objects.requireNonNull(address);\n@@ -621,0 +624,1 @@\n+            Objects.requireNonNull(actions);\n@@ -642,0 +646,2 @@\n+            Objects.requireNonNull(actions);\n+            Objects.requireNonNull(scope);\n@@ -659,0 +665,3 @@\n+         * <p> Unless otherwise specified, passing a {@code null} argument, or an array argument containing one or more {@code null}\n+         * elements to a method in this class causes a {@link NullPointerException NullPointerException} to be thrown. <\/p>\n+         *\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/CLinker.java","additions":22,"deletions":13,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -45,0 +45,3 @@\n+ *\n+ * <p> Unless otherwise specified, passing a {@code null} argument, or an array argument containing one or more {@code null}\n+ * elements to a method in this class causes a {@link NullPointerException NullPointerException} to be thrown. <\/p>\n@@ -71,0 +74,1 @@\n+        Objects.requireNonNull(name);\n@@ -93,0 +97,1 @@\n+        Objects.requireNonNull(name);\n@@ -119,1 +124,1 @@\n-     * @throws NullPointerException if any of the argument layouts, or the return layout is null.\n+     * layouts in {@code argLayouts} is null.\n@@ -123,0 +128,1 @@\n+        Objects.requireNonNull(argLayouts);\n@@ -131,1 +137,1 @@\n-     * @throws NullPointerException if any of the argument layouts is null.\n+     * layouts in {@code argLayouts} is null.\n@@ -134,0 +140,1 @@\n+        Objects.requireNonNull(argLayouts);\n@@ -143,1 +150,1 @@\n-     * @throws NullPointerException if any of the new argument layouts is null.\n+     * layouts in {@code addedLayouts} is null.\n@@ -146,0 +153,1 @@\n+        Objects.requireNonNull(addedLayouts);\n@@ -156,1 +164,0 @@\n-     * @throws NullPointerException if the new return layout is null.\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/FunctionDescriptor.java","additions":11,"deletions":4,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -55,0 +55,3 @@\n+ * <p> Unless otherwise specified, passing a {@code null} argument, or an array argument containing one or more {@code null}\n+ * elements to a method in this class causes a {@link NullPointerException NullPointerException} to be thrown. <\/p>\n+ *\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/GroupLayout.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -59,0 +59,3 @@\n+ *\n+ * <p> Unless otherwise specified, passing a {@code null} argument, or an array argument containing one or more {@code null}\n+ * elements to a method in this class causes a {@link NullPointerException NullPointerException} to be thrown. <\/p>\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/LibraryLookup.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import java.util.Objects;\n@@ -45,0 +46,3 @@\n+ * <p> Unless otherwise specified, passing a {@code null} argument, or an array argument containing one or more {@code null}\n+ * elements to a method in this class causes a {@link NullPointerException NullPointerException} to be thrown. <\/p>\n+ *\n@@ -154,0 +158,1 @@\n+        Objects.requireNonNull(segment);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MappedMemorySegments.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import java.util.Objects;\n@@ -52,0 +53,3 @@\n+ *\n+ * <p> Unless otherwise specified, passing a {@code null} argument, or an array argument containing one or more {@code null}\n+ * elements to a method in this class causes a {@link NullPointerException NullPointerException} to be thrown. <\/p>\n@@ -95,0 +99,1 @@\n+        Objects.requireNonNull(segment);\n@@ -106,0 +111,1 @@\n+        Objects.requireNonNull(segment);\n@@ -302,0 +308,1 @@\n+        Objects.requireNonNull(segment);\n@@ -318,0 +325,2 @@\n+        Objects.requireNonNull(segment);\n+        Objects.requireNonNull(value);\n@@ -335,0 +344,2 @@\n+        Objects.requireNonNull(segment);\n+        Objects.requireNonNull(order);\n@@ -352,0 +363,2 @@\n+        Objects.requireNonNull(segment);\n+        Objects.requireNonNull(order);\n@@ -369,0 +382,2 @@\n+        Objects.requireNonNull(segment);\n+        Objects.requireNonNull(order);\n@@ -386,0 +401,2 @@\n+        Objects.requireNonNull(segment);\n+        Objects.requireNonNull(order);\n@@ -403,0 +420,2 @@\n+        Objects.requireNonNull(segment);\n+        Objects.requireNonNull(order);\n@@ -420,0 +439,2 @@\n+        Objects.requireNonNull(segment);\n+        Objects.requireNonNull(order);\n@@ -437,0 +458,2 @@\n+        Objects.requireNonNull(segment);\n+        Objects.requireNonNull(order);\n@@ -454,0 +477,2 @@\n+        Objects.requireNonNull(segment);\n+        Objects.requireNonNull(order);\n@@ -471,0 +496,2 @@\n+        Objects.requireNonNull(segment);\n+        Objects.requireNonNull(order);\n@@ -488,0 +515,2 @@\n+        Objects.requireNonNull(segment);\n+        Objects.requireNonNull(order);\n@@ -505,0 +534,2 @@\n+        Objects.requireNonNull(segment);\n+        Objects.requireNonNull(order);\n@@ -522,0 +553,2 @@\n+        Objects.requireNonNull(segment);\n+        Objects.requireNonNull(order);\n@@ -1096,1 +1129,1 @@\n-     * Reads a memory address from given segment and element index, with byte order set to {@link ByteOrder#nativeOrder()}.\n+     * Writes a double at given segment and element index, with byte order set to {@link ByteOrder#nativeOrder()}.\n@@ -1100,1 +1133,1 @@\n-    return getAddressAtOffset(segment, index * MemoryLayouts.ADDRESS.byteSize());\n+    setDoubleAtOffset(segment, 8 * index, value);\n@@ -1104,1 +1137,1 @@\n-     * @return a memory address read from {@code segment} at the element index specified by {@code index}.\n+     * @param value the double value to be written.\n@@ -1106,2 +1139,2 @@\n-    public static MemoryAddress getAddressAtIndex(MemorySegment segment, long index) {\n-        return getAddressAtOffset(segment, scale(segment, index, (int)MemoryLayouts.ADDRESS.byteSize()));\n+    public static void setDoubleAtIndex(MemorySegment segment, long index, double value) {\n+        setDoubleAtOffset(segment, scale(segment, index, 8), value);\n@@ -1111,1 +1144,1 @@\n-     * Writes a memory address at given segment and element index, with byte order set to {@link ByteOrder#nativeOrder()}.\n+     * Reads a memory address from given segment and element index, with byte order set to {@link ByteOrder#nativeOrder()}.\n@@ -1115,1 +1148,1 @@\n-    setAddressAtOffset(segment, index * MemoryLayouts.ADDRESS.byteSize(), value);\n+    return getAddressAtOffset(segment, index * MemoryLayouts.ADDRESS.byteSize());\n@@ -1119,1 +1152,1 @@\n-     * @param value the memory address to be written (expressed as an {@link Addressable} instance).\n+     * @return a memory address read from {@code segment} at the element index specified by {@code index}.\n@@ -1121,2 +1154,2 @@\n-    public static void setAddressAtIndex(MemorySegment segment, long index, Addressable value) {\n-        setAddressAtOffset(segment, scale(segment, index, (int)MemoryLayouts.ADDRESS.byteSize()), value);\n+    public static MemoryAddress getAddressAtIndex(MemorySegment segment, long index) {\n+        return getAddressAtOffset(segment, scale(segment, index, (int)MemoryLayouts.ADDRESS.byteSize()));\n@@ -1126,1 +1159,1 @@\n-     * Writes a double at given segment and element index, with byte order set to {@link ByteOrder#nativeOrder()}.\n+     * Writes a memory address at given segment and element index, with byte order set to {@link ByteOrder#nativeOrder()}.\n@@ -1130,1 +1163,1 @@\n-    setDoubleAtOffset(segment, 8 * index, value);\n+    setAddressAtOffset(segment, index * MemoryLayouts.ADDRESS.byteSize(), value);\n@@ -1134,1 +1167,1 @@\n-     * @param value the double value to be written.\n+     * @param value the memory address to be written (expressed as an {@link Addressable} instance).\n@@ -1136,2 +1169,2 @@\n-    public static void setDoubleAtIndex(MemorySegment segment, long index, double value) {\n-        setDoubleAtOffset(segment, scale(segment, index, 8), value);\n+    public static void setAddressAtIndex(MemorySegment segment, long index, Addressable value) {\n+        setAddressAtOffset(segment, scale(segment, index, (int)MemoryLayouts.ADDRESS.byteSize()), value);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemoryAccess.java","additions":48,"deletions":15,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -49,0 +49,3 @@\n+ * <p> Unless otherwise specified, passing a {@code null} argument, or an array argument containing one or more {@code null}\n+ * elements to a method in this class causes a {@link NullPointerException NullPointerException} to be thrown. <\/p>\n+ *\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemoryAddress.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -65,0 +65,3 @@\n+ * <p> Unless otherwise specified, passing a {@code null} argument, or an array argument containing one or more {@code null}\n+ * elements to a method in this class causes a {@link NullPointerException NullPointerException} to be thrown. <\/p>\n+ *\n@@ -173,1 +176,2 @@\n-        checkCarrier(carrier);\n+        Objects.requireNonNull(carrier);\n+        Objects.requireNonNull(byteOrder);\n@@ -199,0 +203,2 @@\n+        Objects.requireNonNull(carrier);\n+        Objects.requireNonNull(byteOrder);\n@@ -223,0 +229,1 @@\n+        Objects.requireNonNull(target);\n@@ -283,1 +290,0 @@\n-     * @throws NullPointerException if either of {@code target} or {@code\n@@ -334,1 +340,0 @@\n-     * @throws NullPointerException if either {@code target}, {@code filterToTarget} or {@code filterFromTarget} are {@code == null}.\n@@ -363,1 +368,0 @@\n-     * @throws NullPointerException if either {@code target}, {@code filters} are {@code == null}.\n@@ -393,1 +397,0 @@\n-     * @throws NullPointerException if either {@code target}, {@code values} are {@code == null}.\n@@ -435,1 +438,0 @@\n-     * @throws NullPointerException if either {@code target}, {@code newCoordinates} or {@code reorder} are {@code == null}.\n@@ -474,1 +476,0 @@\n-     * @throws NullPointerException if either {@code target}, {@code filter} are {@code == null}.\n@@ -502,1 +503,0 @@\n-     * @throws NullPointerException if either {@code target}, {@code valueTypes} are {@code == null}.\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemoryHandles.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+import java.util.stream.Collectors;\n@@ -85,0 +86,3 @@\n+ * <p> Unless otherwise specified, passing a {@code null} argument, or an array argument containing one or more {@code null}\n+ * elements to a method in this class causes a {@link NullPointerException NullPointerException} to be thrown. <\/p>\n+ *\n@@ -345,0 +349,1 @@\n+     * in {@code elements} is {@code null}.\n@@ -364,0 +369,1 @@\n+     * in {@code elements} is {@code null}.\n@@ -404,0 +410,1 @@\n+     * in {@code elements} is {@code null}.\n@@ -406,0 +413,1 @@\n+        Objects.requireNonNull(carrier);\n@@ -418,0 +426,1 @@\n+     * in {@code elements} is {@code null}.\n@@ -435,0 +444,1 @@\n+     * in {@code elements} is {@code null}.\n@@ -437,0 +447,1 @@\n+        Objects.requireNonNull(op);\n@@ -443,0 +454,1 @@\n+        Objects.requireNonNull(elements);\n@@ -444,1 +456,1 @@\n-            LayoutPath.PathElementImpl pathElem = (LayoutPath.PathElementImpl)e;\n+            LayoutPath.PathElementImpl pathElem = (LayoutPath.PathElementImpl)Objects.requireNonNull(e);\n@@ -470,0 +482,3 @@\n+     * <p> Unless otherwise specified, passing a {@code null} argument, or an array argument containing one or more {@code null}\n+     * elements to a method in this class causes a {@link NullPointerException NullPointerException} to be thrown. <\/p>\n+     *\n@@ -489,1 +504,0 @@\n-         * @throws NullPointerException if the specified group element name is {@code null}.\n@@ -610,0 +624,1 @@\n+        Objects.requireNonNull(order);\n@@ -625,1 +640,1 @@\n-        return new SequenceLayout(size, elementLayout);\n+        return new SequenceLayout(size, Objects.requireNonNull(elementLayout));\n@@ -635,1 +650,1 @@\n-        return new SequenceLayout(OptionalLong.empty(), elementLayout);\n+        return new SequenceLayout(OptionalLong.empty(), Objects.requireNonNull(elementLayout));\n@@ -645,1 +660,5 @@\n-        return new GroupLayout(GroupLayout.Kind.STRUCT, List.of(elements));\n+        Objects.requireNonNull(elements);\n+        return new GroupLayout(GroupLayout.Kind.STRUCT,\n+                Stream.of(elements)\n+                        .map(Objects::requireNonNull)\n+                        .collect(Collectors.toList()));\n@@ -655,1 +674,5 @@\n-        return new GroupLayout(GroupLayout.Kind.UNION, List.of(elements));\n+        Objects.requireNonNull(elements);\n+        return new GroupLayout(GroupLayout.Kind.UNION,\n+                Stream.of(elements)\n+                        .map(Objects::requireNonNull)\n+                        .collect(Collectors.toList()));\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemoryLayout.java","additions":29,"deletions":6,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -59,0 +59,3 @@\n+ * <p> Unless otherwise specified, passing a {@code null} argument, or an array argument containing one or more {@code null}\n+ * elements to a method in this class causes a {@link NullPointerException NullPointerException} to be thrown. <\/p>\n+ *\n@@ -326,1 +329,0 @@\n-     * @throws NullPointerException if {@code newBase == null}.\n@@ -370,1 +372,0 @@\n-     * @throws NullPointerException if {@code newBase == null}.\n@@ -434,1 +435,0 @@\n-     * @throws NullPointerException if {@code thread == null}\n@@ -462,1 +462,0 @@\n-     * @throws NullPointerException if {@code nativeScope == null}.\n@@ -826,0 +825,1 @@\n+        Objects.requireNonNull(layout);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemorySegment.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import java.util.Objects;\n@@ -57,0 +58,3 @@\n+ * <p> Unless otherwise specified, passing a {@code null} argument, or an array argument containing one or more {@code null}\n+ * elements to a method in this class causes a {@link NullPointerException NullPointerException} to be thrown. <\/p>\n+ *\n@@ -93,0 +97,1 @@\n+        Objects.requireNonNull(layout);\n@@ -111,0 +116,1 @@\n+        Objects.requireNonNull(layout);\n@@ -129,0 +135,1 @@\n+        Objects.requireNonNull(layout);\n@@ -147,0 +154,1 @@\n+        Objects.requireNonNull(layout);\n@@ -165,0 +173,1 @@\n+        Objects.requireNonNull(layout);\n@@ -183,0 +192,1 @@\n+        Objects.requireNonNull(layout);\n@@ -201,0 +211,1 @@\n+        Objects.requireNonNull(layout);\n@@ -221,0 +232,2 @@\n+        Objects.requireNonNull(value);\n+        Objects.requireNonNull(layout);\n@@ -347,0 +360,1 @@\n+     * in {@code array} is {@code null}.\n@@ -349,0 +363,3 @@\n+        Objects.requireNonNull(elementLayout);\n+        Objects.requireNonNull(array);\n+        Stream.of(array).forEach(Objects::requireNonNull);\n@@ -365,0 +382,2 @@\n+        Objects.requireNonNull(array);\n+        Objects.requireNonNull(elementLayout);\n@@ -384,0 +403,1 @@\n+        Objects.requireNonNull(layout);\n@@ -402,0 +422,1 @@\n+        Objects.requireNonNull(elementLayout);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/NativeScope.java","additions":21,"deletions":0,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -46,0 +46,3 @@\n+ * <p> Unless otherwise specified, passing a {@code null} argument, or an array argument containing one or more {@code null}\n+ * elements to a method in this class causes a {@link NullPointerException NullPointerException} to be thrown. <\/p>\n+ *\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/PaddingLayout.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -63,0 +63,3 @@\n+ * <p> Unless otherwise specified, passing a {@code null} argument, or an array argument containing one or more {@code null}\n+ * elements to a method in this class causes a {@link NullPointerException NullPointerException} to be thrown. <\/p>\n+ *\n@@ -140,1 +143,0 @@\n-     * @throws NullPointerException if {@code elementCounts == null}.\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/SequenceLayout.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -48,0 +48,3 @@\n+ * <p> Unless otherwise specified, passing a {@code null} argument, or an array argument containing one or more {@code null}\n+ * elements to a method in this class causes a {@link NullPointerException NullPointerException} to be thrown. <\/p>\n+ *\n@@ -80,1 +83,1 @@\n-        return new ValueLayout(order, bitSize(), alignment, attributes);\n+        return new ValueLayout(Objects.requireNonNull(order), bitSize(), alignment, attributes);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/ValueLayout.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -112,0 +112,1 @@\n+        Objects.requireNonNull(sequenceLayout);\n@@ -128,1 +129,1 @@\n-        AbstractMemorySegmentImpl that = (AbstractMemorySegmentImpl)src;\n+        AbstractMemorySegmentImpl that = (AbstractMemorySegmentImpl)Objects.requireNonNull(src);\n@@ -149,1 +150,1 @@\n-        AbstractMemorySegmentImpl that = (AbstractMemorySegmentImpl)other;\n+        AbstractMemorySegmentImpl that = (AbstractMemorySegmentImpl)Objects.requireNonNull(other);\n@@ -594,0 +595,1 @@\n+        Objects.requireNonNull(bb);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/AbstractMemorySegmentImpl.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -100,0 +100,1 @@\n+            Objects.requireNonNull(arr);\n@@ -123,0 +124,1 @@\n+            Objects.requireNonNull(arr);\n@@ -146,0 +148,1 @@\n+            Objects.requireNonNull(arr);\n@@ -169,0 +172,1 @@\n+            Objects.requireNonNull(arr);\n@@ -192,0 +196,1 @@\n+            Objects.requireNonNull(arr);\n@@ -215,0 +220,1 @@\n+            Objects.requireNonNull(arr);\n@@ -238,0 +244,1 @@\n+            Objects.requireNonNull(arr);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/HeapMemorySegmentImpl.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -38,4 +38,1 @@\n-import java.util.Arrays;\n-import java.util.IdentityHashMap;\n-import java.util.Map;\n-import java.util.Optional;\n+import java.util.*;\n@@ -120,0 +117,1 @@\n+                Objects.requireNonNull(name);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/LibrariesHelper.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+import java.util.Objects;\n@@ -112,0 +113,2 @@\n+        Objects.requireNonNull(path);\n+        Objects.requireNonNull(mapMode);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/MappedMemorySegmentImpl.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+import java.util.Objects;\n@@ -77,0 +78,3 @@\n+        Objects.requireNonNull(symbol);\n+        Objects.requireNonNull(type);\n+        Objects.requireNonNull(function);\n@@ -85,0 +89,2 @@\n+        Objects.requireNonNull(target);\n+        Objects.requireNonNull(function);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/AArch64Linker.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+import java.util.Objects;\n@@ -242,0 +243,1 @@\n+        Objects.requireNonNull(scope);\n@@ -250,0 +252,1 @@\n+        Objects.requireNonNull(layout);\n@@ -339,0 +342,1 @@\n+        Objects.requireNonNull(layouts);\n@@ -340,0 +344,1 @@\n+            Objects.requireNonNull(layout);\n@@ -380,0 +385,1 @@\n+        Objects.requireNonNull(scope);\n@@ -461,0 +467,2 @@\n+            Objects.requireNonNull(layout);\n+            Objects.requireNonNull(value);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/AArch64VaList.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+import java.util.Objects;\n@@ -219,0 +220,1 @@\n+        Objects.requireNonNull(scope);\n@@ -227,0 +229,1 @@\n+        Objects.requireNonNull(layout);\n@@ -291,0 +294,1 @@\n+        Objects.requireNonNull(layouts);\n@@ -292,0 +296,1 @@\n+            Objects.requireNonNull(layout);\n@@ -329,0 +334,1 @@\n+        Objects.requireNonNull(scope);\n@@ -396,0 +402,2 @@\n+            Objects.requireNonNull(layout);\n+            Objects.requireNonNull(value);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/SysVVaList.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+import java.util.Objects;\n@@ -88,0 +89,3 @@\n+        Objects.requireNonNull(symbol);\n+        Objects.requireNonNull(type);\n+        Objects.requireNonNull(function);\n@@ -96,0 +100,2 @@\n+        Objects.requireNonNull(target);\n+        Objects.requireNonNull(function);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/SysVx64Linker.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -36,0 +36,2 @@\n+import java.util.Objects;\n+import java.util.stream.Stream;\n@@ -103,0 +105,1 @@\n+        Objects.requireNonNull(scope);\n@@ -111,0 +114,1 @@\n+        Objects.requireNonNull(layout);\n@@ -142,0 +146,2 @@\n+        Objects.requireNonNull(layouts);\n+        Stream.of(layouts).forEach(Objects::requireNonNull);\n@@ -170,0 +176,1 @@\n+        Objects.requireNonNull(scope);\n@@ -198,0 +205,2 @@\n+            Objects.requireNonNull(layout);\n+            Objects.requireNonNull(value);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/WinVaList.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+import java.util.Objects;\n@@ -89,0 +90,3 @@\n+        Objects.requireNonNull(symbol);\n+        Objects.requireNonNull(type);\n+        Objects.requireNonNull(function);\n@@ -97,0 +101,2 @@\n+        Objects.requireNonNull(target);\n+        Objects.requireNonNull(function);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/Windowsx64Linker.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -155,15 +155,0 @@\n-    @Test(expectedExceptions = NullPointerException.class)\n-    public void testBadFilterNullTarget() {\n-        MemoryHandles.filterValue(null, S2I, I2S);\n-    }\n-\n-    @Test(expectedExceptions = NullPointerException.class)\n-    public void testBadFilterNullUnbox() {\n-        MemoryHandles.filterValue(intHandle, null, I2S);\n-    }\n-\n-    @Test(expectedExceptions = NullPointerException.class)\n-    public void testBadFilterNullBox() {\n-        MemoryHandles.filterValue(intHandle, S2I, null);\n-    }\n-\n@@ -237,10 +222,0 @@\n-    @Test(expectedExceptions = NullPointerException.class)\n-    public void testBadFilterCoordinatesNullTarget() {\n-        MemoryHandles.filterCoordinates(null, 0, S2I);\n-    }\n-\n-    @Test(expectedExceptions = NullPointerException.class)\n-    public void testBadFilterCoordinatesNullFilters() {\n-        MemoryHandles.filterCoordinates(intHandle, 0, null);\n-    }\n-\n@@ -290,10 +265,0 @@\n-    @Test(expectedExceptions = NullPointerException.class)\n-    public void testBadInsertCoordinatesNullTarget() {\n-        MemoryHandles.insertCoordinates(null, 0, 42);\n-    }\n-\n-    @Test(expectedExceptions = NullPointerException.class)\n-    public void testBadInsertCoordinatesNullValues() {\n-        MemoryHandles.insertCoordinates(intHandle, 0, null);\n-    }\n-\n@@ -339,15 +304,0 @@\n-    @Test(expectedExceptions = NullPointerException.class)\n-    public void testBadPermuteCoordinatesNullTarget() {\n-        MemoryHandles.permuteCoordinates(null, List.of());\n-    }\n-\n-    @Test(expectedExceptions = NullPointerException.class)\n-    public void testBadPermuteCoordinatesNullCoordinates() {\n-        MemoryHandles.permuteCoordinates(intHandle, null);\n-    }\n-\n-    @Test(expectedExceptions = NullPointerException.class)\n-    public void testBadPermuteCoordinatesNullReorder() {\n-        MemoryHandles.permuteCoordinates(intHandle, List.of(int.class), null);\n-    }\n-\n@@ -392,10 +342,0 @@\n-    @Test(expectedExceptions = NullPointerException.class)\n-    public void testBadCollectCoordinatesNullTarget() {\n-        MemoryHandles.collectCoordinates(null, 0, SUM_OFFSETS);\n-    }\n-\n-    @Test(expectedExceptions = NullPointerException.class)\n-    public void testBadCollectCoordinatesNullFilters() {\n-        MemoryHandles.collectCoordinates(intHandle, 0, null);\n-    }\n-\n@@ -455,10 +395,0 @@\n-    @Test(expectedExceptions = NullPointerException.class)\n-    public void testBadDropCoordinatesNullValueTypes() {\n-        MemoryHandles.dropCoordinates(intHandle, 1, null);\n-    }\n-\n-    @Test(expectedExceptions = NullPointerException.class)\n-    public void testBadDropCoordinatesNullTarget() {\n-        MemoryHandles.dropCoordinates(null, 1);\n-    }\n-\n","filename":"test\/jdk\/java\/foreign\/TestAdaptVarHandles.java","additions":0,"deletions":70,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -122,23 +122,0 @@\n-\n-    @Test(expectedExceptions = NullPointerException.class)\n-    public void testNullArgumentLayout() {\n-        FunctionDescriptor.ofVoid(C_INT, null, C_LONG_LONG);\n-    }\n-\n-    @Test(expectedExceptions = NullPointerException.class)\n-    public void testNullReturnLayout() {\n-        FunctionDescriptor.of(null, C_INT, C_LONG_LONG);\n-    }\n-\n-    @Test(expectedExceptions = NullPointerException.class)\n-    public void testNullArgumentLayoutsAppend() {\n-        FunctionDescriptor fd = FunctionDescriptor.ofVoid(C_INT, C_LONG_LONG);\n-        fd.withAppendedArgumentLayouts(C_DOUBLE, null); \/\/ should throw\n-    }\n-\n-    @Test(expectedExceptions = NullPointerException.class)\n-    public void testNullReturnLayoutChange() {\n-        FunctionDescriptor fd = FunctionDescriptor.ofVoid(C_INT, C_LONG_LONG);\n-        fd.withReturnLayout(null); \/\/ should throw\n-    }\n-\n","filename":"test\/jdk\/java\/foreign\/TestFunctionDescriptor.java","additions":0,"deletions":23,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -82,1 +82,0 @@\n-\n","filename":"test\/jdk\/java\/foreign\/TestLayoutAttributes.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -92,17 +92,0 @@\n-    @Test(expectedExceptions = NullPointerException.class)\n-    public void testNullGroupElementName() {\n-        PathElement.groupElement(null);\n-    }\n-\n-    @Test(expectedExceptions = NullPointerException.class)\n-    public void testBitNullGroupElementName() {\n-        GroupLayout g = MemoryLayout.ofStruct(MemoryLayouts.JAVA_INT);\n-        g.bitOffset(PathElement.groupElement(null));\n-    }\n-\n-    @Test(expectedExceptions = NullPointerException.class)\n-    public void testByteNullGroupElementName() {\n-        GroupLayout g = MemoryLayout.ofStruct(MemoryLayouts.JAVA_INT);\n-        g.byteOffset(PathElement.groupElement(null));\n-    }\n-\n","filename":"test\/jdk\/java\/foreign\/TestLayoutPaths.java","additions":0,"deletions":17,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -0,0 +1,364 @@\n+\/*\n+ *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @run testng TestMemoryAccessStatics\n+ *\/\n+\n+import jdk.incubator.foreign.MemoryAccess;\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.MemoryLayouts;\n+import jdk.incubator.foreign.MemorySegment;\n+\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+\n+import org.testng.annotations.*;\n+import static org.testng.Assert.*;\n+\n+public class TestMemoryAccessStatics {\n+\n+    static class Accessor<X> {\n+\n+        interface SegmentGetter<X> {\n+            X get(MemorySegment segment);\n+        }\n+\n+        interface SegmentSetter<X> {\n+            void set(MemorySegment segment, X o);\n+        }\n+\n+        interface BufferGetter<X> {\n+            X get(ByteBuffer segment);\n+        }\n+\n+        interface BufferSetter<X> {\n+            void set(ByteBuffer buffer, X o);\n+        }\n+\n+        final X value;\n+        final SegmentGetter<X> segmentGetter;\n+        final SegmentSetter<X> segmentSetter;\n+        final BufferGetter<X> bufferGetter;\n+        final BufferSetter<X> bufferSetter;\n+\n+        Accessor(X value,\n+                 SegmentGetter<X> segmentGetter, SegmentSetter<X> segmentSetter,\n+                 BufferGetter<X> bufferGetter, BufferSetter<X> bufferSetter) {\n+            this.value = value;\n+            this.segmentGetter = segmentGetter;\n+            this.segmentSetter = segmentSetter;\n+            this.bufferGetter = bufferGetter;\n+            this.bufferSetter = bufferSetter;\n+        }\n+\n+        void test() {\n+            MemorySegment segment = MemorySegment.ofArray(new byte[32]);\n+            ByteBuffer buffer = segment.asByteBuffer();\n+            segmentSetter.set(segment, value);\n+            assertEquals(bufferGetter.get(buffer), value);\n+            bufferSetter.set(buffer, value);\n+            assertEquals(value, segmentGetter.get(segment));\n+        }\n+\n+        <Z> Accessor<Z> of(Z value,\n+                           SegmentGetter<Z> segmentGetter, SegmentSetter<Z> segmentSetter,\n+                           BufferGetter<Z> bufferGetter, BufferSetter<Z> bufferSetter) {\n+            return new Accessor<>(value, segmentGetter, segmentSetter, bufferGetter, bufferSetter);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"accessors\")\n+    public void testMemoryAccess(String testName, Accessor<?> accessor) {\n+        accessor.test();\n+    }\n+\n+    static final ByteOrder BE = ByteOrder.BIG_ENDIAN;\n+    static final ByteOrder LE = ByteOrder.LITTLE_ENDIAN;\n+    static final ByteOrder NE = ByteOrder.nativeOrder();\n+\n+    @DataProvider(name = \"accessors\")\n+    static Object[][] accessors() {\n+        return new Object[][]{\n+\n+                {\"byte\", new Accessor<>((byte) 42,\n+                        MemoryAccess::getByte, MemoryAccess::setByte,\n+                        (bb) -> bb.get(0), (bb, v) -> bb.put(0, v))\n+                },\n+                {\"char\", new Accessor<>((char) 42,\n+                        MemoryAccess::getChar, MemoryAccess::setChar,\n+                        (bb) -> bb.order(NE).getChar(0), (bb, v) -> bb.order(NE).putChar(0, v))\n+                },\n+                {\"char\/LE\", new Accessor<>((char) 42,\n+                        s -> MemoryAccess.getChar(s, LE), (s, x) -> MemoryAccess.setChar(s, LE, x),\n+                        (bb) -> bb.order(LE).getChar(0), (bb, v) -> bb.order(LE).putChar(0, v))\n+                },\n+                {\"char\/BE\", new Accessor<>((char) 42,\n+                        s -> MemoryAccess.getChar(s, BE), (s, x) -> MemoryAccess.setChar(s, BE, x),\n+                        (bb) -> bb.order(BE).getChar(0), (bb, v) -> bb.order(BE).putChar(0, v))\n+                },\n+                {\"short\", new Accessor<>((short) 42,\n+                        MemoryAccess::getShort, MemoryAccess::setShort,\n+                        (bb) -> bb.order(NE).getShort(0), (bb, v) -> bb.order(NE).putShort(0, v))\n+                },\n+                {\"short\/LE\", new Accessor<>((short) 42,\n+                        s -> MemoryAccess.getShort(s, LE), (s, x) -> MemoryAccess.setShort(s, LE, x),\n+                        (bb) -> bb.order(LE).getShort(0), (bb, v) -> bb.order(LE).putShort(0, v))\n+                },\n+                {\"short\/BE\", new Accessor<>((short) 42,\n+                        s -> MemoryAccess.getShort(s, BE), (s, x) -> MemoryAccess.setShort(s, BE, x),\n+                        (bb) -> bb.order(BE).getShort(0), (bb, v) -> bb.order(BE).putShort(0, v))\n+                },\n+                {\"int\", new Accessor<>(42,\n+                        MemoryAccess::getInt, MemoryAccess::setInt,\n+                        (bb) -> bb.order(NE).getInt(0), (bb, v) -> bb.order(NE).putInt(0, v))\n+                },\n+                {\"int\/LE\", new Accessor<>(42,\n+                        s -> MemoryAccess.getInt(s, LE), (s, x) -> MemoryAccess.setInt(s, LE, x),\n+                        (bb) -> bb.order(LE).getInt(0), (bb, v) -> bb.order(LE).putInt(0, v))\n+                },\n+                {\"int\/BE\", new Accessor<>(42,\n+                        s -> MemoryAccess.getInt(s, BE), (s, x) -> MemoryAccess.setInt(s, BE, x),\n+                        (bb) -> bb.order(BE).getInt(0), (bb, v) -> bb.order(BE).putInt(0, v))\n+                },\n+                \/\/ float, no offset\n+                {\"float\", new Accessor<>(42f,\n+                        MemoryAccess::getFloat, MemoryAccess::setFloat,\n+                        (bb) -> bb.order(NE).getFloat(0), (bb, v) -> bb.order(NE).putFloat(0, v))\n+                },\n+                {\"float\/LE\", new Accessor<>(42f,\n+                        s -> MemoryAccess.getFloat(s, LE), (s, x) -> MemoryAccess.setFloat(s, LE, x),\n+                        (bb) -> bb.order(LE).getFloat(0), (bb, v) -> bb.order(LE).putFloat(0, v))\n+                },\n+                {\"float\/BE\", new Accessor<>(42f,\n+                        s -> MemoryAccess.getFloat(s, BE), (s, x) -> MemoryAccess.setFloat(s, BE, x),\n+                        (bb) -> bb.order(BE).getFloat(0), (bb, v) -> bb.order(BE).putFloat(0, v))\n+                },\n+                \/\/ double, no offset\n+                {\"double\", new Accessor<>(42d,\n+                        MemoryAccess::getDouble, MemoryAccess::setDouble,\n+                        (bb) -> bb.order(NE).getDouble(0), (bb, v) -> bb.order(NE).putDouble(0, v))\n+                },\n+                {\"double\/LE\", new Accessor<>(42d,\n+                        s -> MemoryAccess.getDouble(s, LE), (s, x) -> MemoryAccess.setDouble(s, LE, x),\n+                        (bb) -> bb.order(LE).getDouble(0), (bb, v) -> bb.order(LE).putDouble(0, v))\n+                },\n+                {\"double\/BE\", new Accessor<>(42d,\n+                        s -> MemoryAccess.getDouble(s, BE), (s, x) -> MemoryAccess.setDouble(s, BE, x),\n+                        (bb) -> bb.order(BE).getDouble(0), (bb, v) -> bb.order(BE).putDouble(0, v))\n+                },\n+\n+\n+                \/\/ byte, offset\n+                {\"byte\/offset\", new Accessor<>((byte) 42,\n+                        s -> MemoryAccess.getByteAtOffset(s, 4), (s, x) -> MemoryAccess.setByteAtOffset(s, 4, x),\n+                        (bb) -> bb.get(4), (bb, v) -> bb.put(4, v))\n+                },\n+                \/\/ char, offset\n+                {\"char\/offset\", new Accessor<>((char) 42,\n+                        s -> MemoryAccess.getCharAtOffset(s, 4), (s, x) -> MemoryAccess.setCharAtOffset(s, 4, x),\n+                        (bb) -> bb.order(NE).getChar(4), (bb, v) -> bb.order(NE).putChar(4, v))\n+                },\n+                {\"char\/offset\/LE\", new Accessor<>((char) 42,\n+                        s -> MemoryAccess.getCharAtOffset(s, 4, LE), (s, x) -> MemoryAccess.setCharAtOffset(s, 4, LE, x),\n+                        (bb) -> bb.order(LE).getChar(4), (bb, v) -> bb.order(LE).putChar(4, v))\n+                },\n+                {\"char\/offset\/BE\", new Accessor<>((char) 42,\n+                        s -> MemoryAccess.getCharAtOffset(s, 4, BE), (s, x) -> MemoryAccess.setCharAtOffset(s, 4, BE, x),\n+                        (bb) -> bb.order(BE).getChar(4), (bb, v) -> bb.order(BE).putChar(4, v))\n+                },\n+                \/\/ short, offset\n+                {\"short\/offset\", new Accessor<>((short) 42,\n+                        s -> MemoryAccess.getShortAtOffset(s, 4), (s, x) -> MemoryAccess.setShortAtOffset(s, 4, x),\n+                        (bb) -> bb.order(NE).getShort(4), (bb, v) -> bb.order(NE).putShort(4, v))\n+                },\n+                {\"short\/offset\/LE\", new Accessor<>((short) 42,\n+                        s -> MemoryAccess.getShortAtOffset(s, 4, LE), (s, x) -> MemoryAccess.setShortAtOffset(s, 4, LE, x),\n+                        (bb) -> bb.order(LE).getShort(4), (bb, v) -> bb.order(LE).putShort(4, v))\n+                },\n+                {\"short\/offset\/BE\", new Accessor<>((short) 42,\n+                        s -> MemoryAccess.getShortAtOffset(s, 4, BE), (s, x) -> MemoryAccess.setShortAtOffset(s, 4, BE, x),\n+                        (bb) -> bb.order(BE).getShort(4), (bb, v) -> bb.order(BE).putShort(4, v))\n+                },\n+                \/\/ int, offset\n+                {\"int\/offset\", new Accessor<>(42,\n+                        s -> MemoryAccess.getIntAtOffset(s, 4), (s, x) -> MemoryAccess.setIntAtOffset(s, 4, x),\n+                        (bb) -> bb.order(NE).getInt(4), (bb, v) -> bb.order(NE).putInt(4, v))\n+                },\n+                {\"int\/offset\/LE\", new Accessor<>(42,\n+                        s -> MemoryAccess.getIntAtOffset(s, 4, LE), (s, x) -> MemoryAccess.setIntAtOffset(s, 4, LE, x),\n+                        (bb) -> bb.order(LE).getInt(4), (bb, v) -> bb.order(LE).putInt(4, v))\n+                },\n+                {\"int\/offset\/BE\", new Accessor<>(42,\n+                        s -> MemoryAccess.getIntAtOffset(s, 4, BE), (s, x) -> MemoryAccess.setIntAtOffset(s, 4, BE, x),\n+                        (bb) -> bb.order(BE).getInt(4), (bb, v) -> bb.order(BE).putInt(4, v))\n+                },\n+                \/\/ float, offset\n+                {\"float\/offset\", new Accessor<>(42f,\n+                        s -> MemoryAccess.getFloatAtOffset(s, 4), (s, x) -> MemoryAccess.setFloatAtOffset(s, 4, x),\n+                        (bb) -> bb.order(NE).getFloat(4), (bb, v) -> bb.order(NE).putFloat(4, v))\n+                },\n+                {\"float\/offset\/LE\", new Accessor<>(42f,\n+                        s -> MemoryAccess.getFloatAtOffset(s, 4, LE), (s, x) -> MemoryAccess.setFloatAtOffset(s, 4, LE, x),\n+                        (bb) -> bb.order(LE).getFloat(4), (bb, v) -> bb.order(LE).putFloat(4, v))\n+                },\n+                {\"float\/offset\/BE\", new Accessor<>(42f,\n+                        s -> MemoryAccess.getFloatAtOffset(s, 4, BE), (s, x) -> MemoryAccess.setFloatAtOffset(s, 4, BE, x),\n+                        (bb) -> bb.order(BE).getFloat(4), (bb, v) -> bb.order(BE).putFloat(4, v))\n+                },\n+                \/\/ double, offset\n+                {\"double\/offset\", new Accessor<>(42d,\n+                        s -> MemoryAccess.getDoubleAtOffset(s, 4), (s, x) -> MemoryAccess.setDoubleAtOffset(s, 4, x),\n+                        (bb) -> bb.order(NE).getDouble(4), (bb, v) -> bb.order(NE).putDouble(4, v))\n+                },\n+                {\"double\/offset\/LE\", new Accessor<>(42d,\n+                        s -> MemoryAccess.getDoubleAtOffset(s, 4, LE), (s, x) -> MemoryAccess.setDoubleAtOffset(s, 4, LE, x),\n+                        (bb) -> bb.order(LE).getDouble(4), (bb, v) -> bb.order(LE).putDouble(4, v))\n+                },\n+                {\"double\/offset\/BE\", new Accessor<>(42d,\n+                        s -> MemoryAccess.getDoubleAtOffset(s, 4, BE), (s, x) -> MemoryAccess.setDoubleAtOffset(s, 4, BE, x),\n+                        (bb) -> bb.order(BE).getDouble(4), (bb, v) -> bb.order(BE).putDouble(4, v))\n+                },\n+\n+\n+                \/\/ char, index\n+                {\"char\/index\", new Accessor<>((char) 42,\n+                        s -> MemoryAccess.getCharAtIndex(s, 2), (s, x) -> MemoryAccess.setCharAtIndex(s, 2, x),\n+                        (bb) -> bb.order(NE).asCharBuffer().get(2), (bb, v) -> bb.order(NE).asCharBuffer().put(2, v))\n+                },\n+                {\"char\/index\/LE\", new Accessor<>((char) 42,\n+                        s -> MemoryAccess.getCharAtIndex(s, 2, LE), (s, x) -> MemoryAccess.setCharAtIndex(s, 2, LE, x),\n+                        (bb) -> bb.order(LE).asCharBuffer().get(2), (bb, v) -> bb.order(LE).asCharBuffer().put(2, v))\n+                },\n+                {\"char\/index\/BE\", new Accessor<>((char) 42,\n+                        s -> MemoryAccess.getCharAtIndex(s, 2, BE), (s, x) -> MemoryAccess.setCharAtIndex(s, 2, BE, x),\n+                        (bb) -> bb.order(BE).asCharBuffer().get(2), (bb, v) -> bb.order(BE).asCharBuffer().put(2, v))\n+                },\n+                \/\/ short, index\n+                {\"short\/index\", new Accessor<>((short) 42,\n+                        s -> MemoryAccess.getShortAtIndex(s, 2), (s, x) -> MemoryAccess.setShortAtIndex(s, 2, x),\n+                        (bb) -> bb.order(NE).asShortBuffer().get(2), (bb, v) -> bb.order(NE).asShortBuffer().put(2, v))\n+                },\n+                {\"short\/index\/LE\", new Accessor<>((short) 42,\n+                        s -> MemoryAccess.getShortAtIndex(s, 2, LE), (s, x) -> MemoryAccess.setShortAtIndex(s, 2, LE, x),\n+                        (bb) -> bb.order(LE).asShortBuffer().get(2), (bb, v) -> bb.order(LE).asShortBuffer().put(2, v))\n+                },\n+                {\"short\/index\/BE\", new Accessor<>((short) 42,\n+                        s -> MemoryAccess.getShortAtIndex(s, 2, BE), (s, x) -> MemoryAccess.setShortAtIndex(s, 2, BE, x),\n+                        (bb) -> bb.order(BE).asShortBuffer().get(2), (bb, v) -> bb.order(BE).asShortBuffer().put(2, v))\n+                },\n+                {\"int\/index\", new Accessor<>(42,\n+                        s -> MemoryAccess.getIntAtIndex(s, 2), (s, x) -> MemoryAccess.setIntAtIndex(s, 2, x),\n+                        (bb) -> bb.order(NE).asIntBuffer().get(2), (bb, v) -> bb.order(NE).asIntBuffer().put(2, v))\n+                },\n+                {\"int\/index\/LE\", new Accessor<>(42,\n+                        s -> MemoryAccess.getIntAtIndex(s, 2, LE), (s, x) -> MemoryAccess.setIntAtIndex(s, 2, LE, x),\n+                        (bb) -> bb.order(LE).asIntBuffer().get(2), (bb, v) -> bb.order(LE).asIntBuffer().put(2, v))\n+                },\n+                {\"int\/index\/BE\", new Accessor<>(42,\n+                        s -> MemoryAccess.getIntAtIndex(s, 2, BE), (s, x) -> MemoryAccess.setIntAtIndex(s, 2, BE, x),\n+                        (bb) -> bb.order(BE).asIntBuffer().get(2), (bb, v) -> bb.order(BE).asIntBuffer().put(2, v))\n+                },\n+                {\"float\/index\", new Accessor<>(42f,\n+                        s -> MemoryAccess.getFloatAtIndex(s, 2), (s, x) -> MemoryAccess.setFloatAtIndex(s, 2, x),\n+                        (bb) -> bb.order(NE).asFloatBuffer().get(2), (bb, v) -> bb.order(NE).asFloatBuffer().put(2, v))\n+                },\n+                {\"float\/index\/LE\", new Accessor<>(42f,\n+                        s -> MemoryAccess.getFloatAtIndex(s, 2, LE), (s, x) -> MemoryAccess.setFloatAtIndex(s, 2, LE, x),\n+                        (bb) -> bb.order(LE).asFloatBuffer().get(2), (bb, v) -> bb.order(LE).asFloatBuffer().put(2, v))\n+                },\n+                {\"float\/index\/BE\", new Accessor<>(42f,\n+                        s -> MemoryAccess.getFloatAtIndex(s, 2, BE), (s, x) -> MemoryAccess.setFloatAtIndex(s, 2, BE, x),\n+                        (bb) -> bb.order(BE).asFloatBuffer().get(2), (bb, v) -> bb.order(BE).asFloatBuffer().put(2, v))\n+                },\n+                {\"double\/index\", new Accessor<>(42d,\n+                        s -> MemoryAccess.getDoubleAtIndex(s, 2), (s, x) -> MemoryAccess.setDoubleAtIndex(s, 2, x),\n+                        (bb) -> bb.order(NE).asDoubleBuffer().get(2), (bb, v) -> bb.order(NE).asDoubleBuffer().put(2, v))\n+                },\n+                {\"double\/index\/LE\", new Accessor<>(42d,\n+                        s -> MemoryAccess.getDoubleAtIndex(s, 2, LE), (s, x) -> MemoryAccess.setDoubleAtIndex(s, 2, LE, x),\n+                        (bb) -> bb.order(LE).asDoubleBuffer().get(2), (bb, v) -> bb.order(LE).asDoubleBuffer().put(2, v))\n+                },\n+                {\"double\/index\/BE\", new Accessor<>(42d,\n+                        s -> MemoryAccess.getDoubleAtIndex(s, 2, BE), (s, x) -> MemoryAccess.setDoubleAtIndex(s, 2, BE, x),\n+                        (bb) -> bb.order(BE).asDoubleBuffer().get(2), (bb, v) -> bb.order(BE).asDoubleBuffer().put(2, v))\n+                },\n+\n+                { \"address\", new Accessor<>(MemoryAddress.ofLong(42),\n+                        MemoryAccess::getAddress, MemoryAccess::setAddress,\n+                        (bb) -> {\n+                            ByteBuffer nb = bb.order(NE);\n+                            long addr = MemoryLayouts.ADDRESS.byteSize() == 8 ?\n+                                    nb.getLong(0) : nb.getInt(0);\n+                            return MemoryAddress.ofLong(addr);\n+                        },\n+                        (bb, v) -> {\n+                            ByteBuffer nb = bb.order(NE);\n+                            if (MemoryLayouts.ADDRESS.byteSize() == 8) {\n+                                nb.putLong(0, v.toRawLongValue());\n+                            } else {\n+                                nb.putInt(0, (int)v.toRawLongValue());\n+                            }\n+                        })\n+                },\n+                { \"address\/offset\", new Accessor<>(MemoryAddress.ofLong(42),\n+                        s -> MemoryAccess.getAddressAtOffset(s, 4), (s, x) -> MemoryAccess.setAddressAtOffset(s, 4, x),\n+                        (bb) -> {\n+                            ByteBuffer nb = bb.order(NE);\n+                            long addr = MemoryLayouts.ADDRESS.byteSize() == 8 ?\n+                                    nb.getLong(4) : nb.getInt(4);\n+                            return MemoryAddress.ofLong(addr);\n+                        },\n+                        (bb, v) -> {\n+                            ByteBuffer nb = bb.order(NE);\n+                            if (MemoryLayouts.ADDRESS.byteSize() == 8) {\n+                                nb.putLong(4, v.toRawLongValue());\n+                            } else {\n+                                nb.putInt(4, (int)v.toRawLongValue());\n+                            }\n+                        })\n+                },\n+                { \"address\/index\", new Accessor<>(MemoryAddress.ofLong(42),\n+                        s -> MemoryAccess.getAddressAtIndex(s, 2), (s, x) -> MemoryAccess.setAddressAtIndex(s, 2, x),\n+                        (bb) -> {\n+                            ByteBuffer nb = bb.order(NE);\n+                            long addr = MemoryLayouts.ADDRESS.byteSize() == 8 ?\n+                                    nb.asLongBuffer().get(2) : nb.asIntBuffer().get(2);\n+                            return MemoryAddress.ofLong(addr);\n+                        },\n+                        (bb, v) -> {\n+                            ByteBuffer nb = bb.order(NE);\n+                            if (MemoryLayouts.ADDRESS.byteSize() == 8) {\n+                                nb.asLongBuffer().put(2, v.toRawLongValue());\n+                            } else {\n+                                nb.asIntBuffer().put(2, (int)v.toRawLongValue());\n+                            }\n+                        })\n+                },\n+        };\n+    }\n+}\n","filename":"test\/jdk\/java\/foreign\/TestMemoryAccessStatics.java","additions":364,"deletions":0,"binary":false,"changes":364,"status":"added"},{"patch":"@@ -172,6 +172,0 @@\n-    @Test(expectedExceptions = NullPointerException.class)\n-    public void testNull() {\n-        var segment = MemorySegment.ofArray(new byte[4]);\n-        segment.mismatch(null);\n-    }\n-\n","filename":"test\/jdk\/java\/foreign\/TestMismatch.java","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -30,6 +30,1 @@\n-import jdk.incubator.foreign.MemorySegment;\n-import jdk.incubator.foreign.NativeScope;\n-import jdk.incubator.foreign.MemoryHandles;\n-import jdk.incubator.foreign.MemoryLayouts;\n-import jdk.incubator.foreign.MemoryLayout;\n-import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.*;\n@@ -37,1 +32,0 @@\n-import jdk.incubator.foreign.ValueLayout;\n@@ -41,0 +35,4 @@\n+import java.lang.reflect.Array;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n@@ -49,0 +47,1 @@\n+import java.util.Arrays;\n@@ -52,0 +51,1 @@\n+import java.util.function.Predicate;\n@@ -169,5 +169,0 @@\n-    @Test(expectedExceptions = NullPointerException.class)\n-    public void testNullClaim() {\n-        MemorySegment.ofArray(new byte[5]).handoff((NativeScope)null);\n-    }\n-\n","filename":"test\/jdk\/java\/foreign\/TestNativeScope.java","additions":7,"deletions":12,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -0,0 +1,257 @@\n+\/*\n+ *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @modules java.base\/jdk.internal.ref\n+ *          jdk.incubator.foreign\n+ * @run testng\/othervm -Dforeign.restricted=permit TestNulls\n+ *\/\n+\n+import jdk.incubator.foreign.*;\n+import jdk.internal.ref.CleanerFactory;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.NoInjection;\n+import org.testng.annotations.Test;\n+\n+import java.lang.constant.Constable;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.lang.invoke.VarHandle;\n+import java.lang.ref.Cleaner;\n+import java.lang.reflect.Array;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import java.nio.channels.FileChannel;\n+import java.nio.charset.Charset;\n+import java.nio.file.Path;\n+import java.util.*;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Consumer;\n+import java.util.function.UnaryOperator;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import static org.testng.Assert.*;\n+import static org.testng.Assert.fail;\n+\n+\/**\n+ * This test makes sure that public API classes (listed in {@link TestNulls#CLASSES}) throws NPEs whenever\n+ * nulls are provided. The test looks at all the public methods in all the listed classes, and injects\n+ * values automatically. If an API takes a reference, the test will try to inject nulls. For APIs taking\n+ * either reference arrays, or collections, the framework will also generate additional <em>replacements<\/em>\n+ * (e.g. other than just replacing the array, or collection with null), such as an array or collection\n+ * with null elements. The test can be customized by adding\/removing classes to the {@link #CLASSES} array,\n+ * by adding\/removing default mappings for standard carrier types (see {@link #DEFAULT_VALUES} or by\n+ * adding\/removing custom replacements (see {@link #REPLACEMENT_VALUES}).\n+ *\/\n+public class TestNulls {\n+\n+    static final Class<?>[] CLASSES = new Class<?>[] {\n+            MemorySegment.class,\n+            MemoryAddress.class,\n+            MemoryLayout.class,\n+            MemoryLayout.PathElement.class,\n+            SequenceLayout.class,\n+            ValueLayout.class,\n+            GroupLayout.class,\n+            Addressable.class,\n+            MemoryAccess.class,\n+            MappedMemorySegments.class,\n+            MemoryLayouts.class,\n+            MemoryHandles.class,\n+            NativeScope.class,\n+            CLinker.class,\n+            CLinker.VaList.class,\n+            CLinker.VaList.Builder.class,\n+            FunctionDescriptor.class,\n+            LibraryLookup.class\n+    };\n+\n+    static final Set<String> EXCLUDE_LIST = Set.of(\n+            \"jdk.incubator.foreign.MemoryLayout\/withAttribute(java.lang.String,java.lang.constant.Constable)\/1\/0\",\n+            \"jdk.incubator.foreign.MemoryAddress\/asSegmentRestricted(long,java.lang.Runnable,java.lang.Object)\/1\/0\",\n+            \"jdk.incubator.foreign.MemoryAddress\/asSegmentRestricted(long,java.lang.Runnable,java.lang.Object)\/2\/0\",\n+            \"jdk.incubator.foreign.SequenceLayout\/withAttribute(java.lang.String,java.lang.constant.Constable)\/1\/0\",\n+            \"jdk.incubator.foreign.ValueLayout\/withAttribute(java.lang.String,java.lang.constant.Constable)\/1\/0\",\n+            \"jdk.incubator.foreign.GroupLayout\/withAttribute(java.lang.String,java.lang.constant.Constable)\/1\/0\",\n+            \"jdk.incubator.foreign.MemoryHandles\/insertCoordinates(java.lang.invoke.VarHandle,int,java.lang.Object[])\/2\/1\",\n+            \"jdk.incubator.foreign.FunctionDescriptor\/withAttribute(java.lang.String,java.lang.constant.Constable)\/1\/0\"\n+    );\n+\n+    static final Set<String> OBJECT_METHODS = Stream.of(Object.class.getMethods())\n+            .map(Method::getName)\n+            .collect(Collectors.toSet());\n+\n+    static final Map<Class<?>, Object> DEFAULT_VALUES = new HashMap<>();\n+\n+    static <Z> void addDefaultMapping(Class<Z> carrier, Z value) {\n+        DEFAULT_VALUES.put(carrier, value);\n+    }\n+\n+    static {\n+        addDefaultMapping(char.class, (char)0);\n+        addDefaultMapping(byte.class, (byte)0);\n+        addDefaultMapping(short.class, (short)0);\n+        addDefaultMapping(int.class, 0);\n+        addDefaultMapping(float.class, 0f);\n+        addDefaultMapping(long.class, 0L);\n+        addDefaultMapping(double.class, 0d);\n+        addDefaultMapping(ByteOrder.class, ByteOrder.nativeOrder());\n+        addDefaultMapping(Thread.class, Thread.currentThread());\n+        addDefaultMapping(Cleaner.class, CleanerFactory.cleaner());\n+        addDefaultMapping(ByteBuffer.class, ByteBuffer.wrap(new byte[10]));\n+        addDefaultMapping(Path.class, Path.of(\"nonExistent\"));\n+        addDefaultMapping(FileChannel.MapMode.class, FileChannel.MapMode.PRIVATE);\n+        addDefaultMapping(UnaryOperator.class, UnaryOperator.identity());\n+        addDefaultMapping(String.class, \"Hello!\");\n+        addDefaultMapping(Constable.class, \"Hello!\");\n+        addDefaultMapping(Class.class, String.class);\n+        addDefaultMapping(Runnable.class, () -> {});\n+        addDefaultMapping(Object.class, new Object());\n+        addDefaultMapping(VarHandle.class, MemoryHandles.varHandle(int.class, ByteOrder.nativeOrder()));\n+        addDefaultMapping(MethodHandle.class, MethodHandles.identity(int.class));\n+        addDefaultMapping(List.class, List.of());\n+        addDefaultMapping(Charset.class, Charset.defaultCharset());\n+        addDefaultMapping(Consumer.class, x -> {});\n+        addDefaultMapping(MethodType.class, MethodType.methodType(void.class));\n+        addDefaultMapping(MemoryAddress.class, MemoryAddress.NULL);\n+        addDefaultMapping(Addressable.class, MemoryAddress.NULL);\n+        addDefaultMapping(MemoryLayout.class, MemoryLayouts.JAVA_INT);\n+        addDefaultMapping(ValueLayout.class, MemoryLayouts.JAVA_INT);\n+        addDefaultMapping(GroupLayout.class, MemoryLayout.ofStruct(MemoryLayouts.JAVA_INT));\n+        addDefaultMapping(SequenceLayout.class, MemoryLayout.ofSequence(MemoryLayouts.JAVA_INT));\n+        addDefaultMapping(MemorySegment.class, MemorySegment.ofArray(new byte[10]));\n+        addDefaultMapping(NativeScope.class, NativeScope.boundedScope(10));\n+        addDefaultMapping(FunctionDescriptor.class, FunctionDescriptor.ofVoid());\n+        addDefaultMapping(CLinker.class, CLinker.getInstance());\n+        addDefaultMapping(CLinker.VaList.class, VaListHelper.vaList);\n+        addDefaultMapping(CLinker.VaList.Builder.class, VaListHelper.vaListBuilder);\n+        addDefaultMapping(LibraryLookup.class, LibraryLookup.ofDefault());\n+    }\n+\n+    static class VaListHelper {\n+        static final CLinker.VaList vaList;\n+        static final CLinker.VaList.Builder vaListBuilder;\n+\n+        static {\n+            AtomicReference<CLinker.VaList.Builder> builderRef = new AtomicReference<>();\n+            vaList = CLinker.VaList.make(b -> {\n+                builderRef.set(b);\n+                b.vargFromLong(CLinker.C_LONG_LONG, 42L);\n+            });\n+            vaListBuilder = builderRef.get();\n+        }\n+    }\n+\n+    static final Map<Class<?>, Object[]> REPLACEMENT_VALUES = new HashMap<>();\n+\n+    @SafeVarargs\n+    static <Z> void addReplacements(Class<Z> carrier, Z... value) {\n+        REPLACEMENT_VALUES.put(carrier, value);\n+    }\n+\n+    static {\n+        addReplacements(Collection.class, null, Stream.of(new Object[] { null }).collect(Collectors.toList()));\n+        addReplacements(List.class, null, Stream.of(new Object[] { null }).collect(Collectors.toList()));\n+        addReplacements(Set.class, null, Stream.of(new Object[] { null }).collect(Collectors.toSet()));\n+    }\n+\n+    @Test(dataProvider = \"cases\")\n+    public void testNulls(String testName, @NoInjection Method meth, Object receiver, Object[] args) {\n+        try {\n+            meth.invoke(receiver, args);\n+            fail(\"Method invocation completed normally\");\n+        } catch (InvocationTargetException ex) {\n+            Class<?> cause = ex.getCause().getClass();\n+            assertEquals(cause, NullPointerException.class, \"got \" + cause.getName() + \" - expected NullPointerException\");\n+        } catch (Throwable ex) {\n+            fail(\"Unexpected exception: \" + ex);\n+        }\n+    }\n+\n+    @DataProvider(name = \"cases\")\n+    static Iterator<Object[]> cases() {\n+        List<Object[]> cases = new ArrayList<>();\n+        for (Class<?> clazz : CLASSES) {\n+            for (Method m : clazz.getMethods()) {\n+                if (OBJECT_METHODS.contains(m.getName())) continue;\n+                boolean isStatic = (m.getModifiers() & Modifier.STATIC) != 0;\n+                List<Integer> refIndices = new ArrayList<>();\n+                for (int i = 0; i < m.getParameterCount(); i++) {\n+                    Class<?> param = m.getParameterTypes()[i];\n+                    if (!param.isPrimitive()) {\n+                        refIndices.add(i);\n+                    }\n+                }\n+                for (int i : refIndices) {\n+                    Object[] replacements = replacements(m.getParameterTypes()[i]);\n+                    for (int r = 0 ; r < replacements.length ; r++) {\n+                        String testName = clazz.getName() + \"\/\" + shortSig(m) + \"\/\" + i + \"\/\" + r;\n+                        if (EXCLUDE_LIST.contains(testName)) continue;\n+                        Object[] args = new Object[m.getParameterCount()];\n+                        for (int j = 0; j < args.length; j++) {\n+                            args[j] = defaultValue(m.getParameterTypes()[j]);\n+                        }\n+                        args[i] = replacements[r];\n+                        Object receiver = isStatic ? null : defaultValue(clazz);\n+                        cases.add(new Object[]{testName, m, receiver, args});\n+                    }\n+                }\n+            }\n+        }\n+        return cases.iterator();\n+    };\n+\n+    static String shortSig(Method m) {\n+        StringJoiner sj = new StringJoiner(\",\", m.getName() + \"(\", \")\");\n+        for (Class<?> parameterType : m.getParameterTypes()) {\n+            sj.add(parameterType.getTypeName());\n+        }\n+        return sj.toString();\n+    }\n+\n+    static Object defaultValue(Class<?> carrier) {\n+        if (carrier.isArray()) {\n+            return Array.newInstance(carrier.componentType(), 0);\n+        }\n+        Object value = DEFAULT_VALUES.get(carrier);\n+        if (value == null) {\n+            throw new UnsupportedOperationException(carrier.getName());\n+        }\n+        return value;\n+    }\n+\n+    static Object[] replacements(Class<?> carrier) {\n+        if (carrier.isArray() && !carrier.getComponentType().isPrimitive()) {\n+            Object arr = Array.newInstance(carrier.componentType(), 1);\n+            Array.set(arr, 0, null);\n+            return new Object[] { null, arr };\n+        }\n+        return REPLACEMENT_VALUES.getOrDefault(carrier, new Object[] { null });\n+    }\n+}\n","filename":"test\/jdk\/java\/foreign\/TestNulls.java","additions":257,"deletions":0,"binary":false,"changes":257,"status":"added"},{"patch":"@@ -55,6 +55,0 @@\n-    @Test(expectedExceptions = NullPointerException.class)\n-    public void testNullReshape() {\n-        SequenceLayout seq = MemoryLayout.ofSequence(4, MemoryLayouts.JAVA_INT);\n-        seq.reshape(null);\n-    }\n-\n","filename":"test\/jdk\/java\/foreign\/TestReshape.java","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import jdk.incubator.foreign.MappedMemorySegments;\n@@ -35,0 +36,2 @@\n+import java.io.File;\n+import java.io.IOException;\n@@ -41,0 +44,2 @@\n+import java.nio.channels.FileChannel;\n+import java.nio.file.Path;\n","filename":"test\/jdk\/java\/foreign\/TestSegments.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -49,0 +49,3 @@\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.util.Arrays;\n@@ -64,3 +67,1 @@\n-import static org.testng.Assert.assertEquals;\n-import static org.testng.Assert.assertFalse;\n-import static org.testng.Assert.assertTrue;\n+import static org.testng.Assert.*;\n@@ -806,1 +807,0 @@\n-\n","filename":"test\/jdk\/java\/foreign\/valist\/VaListTest.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"}]}