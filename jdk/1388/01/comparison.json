{"files":[{"patch":"@@ -65,0 +65,1 @@\n+        Objects.requireNonNull(name);\n@@ -75,0 +76,1 @@\n+        Objects.requireNonNull(name);\n@@ -85,0 +87,1 @@\n+        Objects.requireNonNull(name);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/AbstractLayout.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+import java.util.stream.Stream;\n@@ -132,0 +133,1 @@\n+     * @throws NullPointerException if either {@code symbol == null}, {@code type == null} or {@code function == null}.\n@@ -148,0 +150,1 @@\n+     * @throws NullPointerException if either {@code symbol == null} or {@code function == null}.\n@@ -189,1 +192,2 @@\n-     * Returns a memory layout that is suitable to use the layout for variadic arguments.\n+     * Returns a memory layout that is suitable to use as the layout for variadic arguments in a specialized\n+     * function descriptor.\n@@ -191,1 +195,1 @@\n-     * @param ml the layout the adapt\n+     * @param layout the layout the adapt\n@@ -193,0 +197,1 @@\n+     * @throws NullPointerException if {@code layout == null}.\n@@ -195,2 +200,3 @@\n-    static <T extends MemoryLayout> T asVarArg(T ml) {\n-        return (T) PlatformLayouts.asVarArg(ml);\n+    static <T extends MemoryLayout> T asVarArg(T layout) {\n+        Objects.requireNonNull(layout);\n+        return (T) PlatformLayouts.asVarArg(layout);\n@@ -292,1 +298,1 @@\n-     * @throws NullPointerException if {@code addr == null}\n+     * @throws NullPointerException if {@code addr == null}.\n@@ -297,0 +303,1 @@\n+        Objects.requireNonNull(addr);\n@@ -447,0 +454,1 @@\n+         * @throws NullPointerException if {@code layout == null}.\n@@ -458,0 +466,1 @@\n+         * @throws NullPointerException if {@code layout == null}.\n@@ -469,0 +478,1 @@\n+         * @throws NullPointerException if {@code layout == null}.\n@@ -480,0 +490,1 @@\n+         * @throws NullPointerException if {@code layout == null}.\n@@ -494,0 +505,1 @@\n+         * @throws NullPointerException if {@code layout == null}.\n@@ -508,0 +520,1 @@\n+         * @throws NullPointerException if either {@code layout == null} or {@code scope == null}.\n@@ -517,0 +530,2 @@\n+         * @throws NullPointerException if either {@code layouts == null} or or if any of the elements\n+         * in {@code layouts} is {@code null}.\n@@ -577,0 +592,1 @@\n+         * @throws NullPointerException if {@code scope == null}.\n@@ -597,0 +613,1 @@\n+         * @throws NullPointerException if {@code address == null}.\n@@ -600,0 +617,1 @@\n+            Objects.requireNonNull(address);\n@@ -619,0 +637,1 @@\n+         * @throws NullPointerException if {@code actions == null}.\n@@ -621,0 +640,1 @@\n+            Objects.requireNonNull(actions);\n@@ -640,0 +660,1 @@\n+         * @throws NullPointerException if either {@code scope == null} or {@code actions == null}.\n@@ -642,0 +663,2 @@\n+            Objects.requireNonNull(actions);\n+            Objects.requireNonNull(scope);\n@@ -673,0 +696,1 @@\n+             * @throws NullPointerException if {@code layout == null}.\n@@ -683,0 +707,1 @@\n+             * @throws NullPointerException if {@code layout == null}.\n@@ -693,0 +718,1 @@\n+             * @throws NullPointerException if {@code layout == null}.\n@@ -703,0 +729,1 @@\n+             * @throws NullPointerException if either {@code layout == null} or {@code value == null}.\n@@ -713,0 +740,1 @@\n+             * @throws NullPointerException if either {@code layout == null} or {@code value == null}.\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/CLinker.java","additions":33,"deletions":5,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -69,0 +69,1 @@\n+     * @throws NullPointerException if {@code name == null}.\n@@ -71,0 +72,1 @@\n+        Objects.requireNonNull(name);\n@@ -91,0 +93,1 @@\n+     * @throws NullPointerException if {@code name == null}.\n@@ -93,0 +96,1 @@\n+        Objects.requireNonNull(name);\n@@ -119,1 +123,2 @@\n-     * @throws NullPointerException if any of the argument layouts, or the return layout is null.\n+     * @throws NullPointerException if either {@code resLayout == null}, {@code argLayouts == null}, or any of the\n+     * layouts in {@code argLayouts} is null.\n@@ -123,0 +128,1 @@\n+        Objects.requireNonNull(argLayouts);\n@@ -131,1 +137,2 @@\n-     * @throws NullPointerException if any of the argument layouts is null.\n+     * @throws NullPointerException if either {@code argLayouts == null}, or any of the\n+     * layouts in {@code argLayouts} is null.\n@@ -134,0 +141,1 @@\n+        Objects.requireNonNull(argLayouts);\n@@ -143,1 +151,2 @@\n-     * @throws NullPointerException if any of the new argument layouts is null.\n+     * @throws NullPointerException if either {@code addedLayouts == null}, or any of the\n+     * layouts in {@code addedLayouts} is null.\n@@ -146,0 +155,1 @@\n+        Objects.requireNonNull(addedLayouts);\n@@ -156,1 +166,1 @@\n-     * @throws NullPointerException if the new return layout is null.\n+     * @throws NullPointerException if {@code newReturn == null}.\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/FunctionDescriptor.java","additions":14,"deletions":4,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import java.util.Objects;\n@@ -78,0 +79,1 @@\n+     * @throws NullPointerException if {@code segment == null}.\n@@ -97,0 +99,1 @@\n+     * @throws NullPointerException if {@code segment == null}.\n@@ -116,0 +119,1 @@\n+     * @throws NullPointerException if {@code segment == null}.\n@@ -148,0 +152,1 @@\n+     * @throws NullPointerException if {@code segment == null}.\n@@ -154,0 +159,1 @@\n+        Objects.requireNonNull(segment);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MappedMemorySegments.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import java.util.Objects;\n@@ -93,0 +94,1 @@\n+     * @throws NullPointerException if {@code segment == null}.\n@@ -95,0 +97,1 @@\n+        Objects.requireNonNull(segment);\n@@ -104,0 +107,1 @@\n+     * @throws NullPointerException if {@code segment == null}.\n@@ -106,0 +110,1 @@\n+        Objects.requireNonNull(segment);\n@@ -119,0 +124,1 @@\n+     * @throws NullPointerException if {@code segment == null}.\n@@ -134,0 +140,1 @@\n+     * @throws NullPointerException if {@code segment == null}.\n@@ -149,0 +156,1 @@\n+     * @throws NullPointerException if {@code segment == null}.\n@@ -164,0 +172,1 @@\n+     * @throws NullPointerException if {@code segment == null}.\n@@ -179,0 +188,1 @@\n+     * @throws NullPointerException if {@code segment == null}.\n@@ -194,0 +204,1 @@\n+     * @throws NullPointerException if {@code segment == null}.\n@@ -209,0 +220,1 @@\n+     * @throws NullPointerException if {@code segment == null}.\n@@ -224,0 +236,1 @@\n+     * @throws NullPointerException if {@code segment == null}.\n@@ -239,0 +252,1 @@\n+     * @throws NullPointerException if {@code segment == null}.\n@@ -254,0 +268,1 @@\n+     * @throws NullPointerException if {@code segment == null}.\n@@ -269,0 +284,1 @@\n+     * @throws NullPointerException if {@code segment == null}.\n@@ -284,0 +300,1 @@\n+     * @throws NullPointerException if {@code segment == null}.\n@@ -300,0 +317,1 @@\n+     * @throws NullPointerException if {@code segment == null}.\n@@ -302,0 +320,1 @@\n+        Objects.requireNonNull(segment);\n@@ -316,0 +335,1 @@\n+     * @throws NullPointerException if {@code segment == null}, or if {@code value == null}.\n@@ -318,0 +338,2 @@\n+        Objects.requireNonNull(segment);\n+        Objects.requireNonNull(value);\n@@ -333,0 +355,1 @@\n+     * @throws NullPointerException if {@code segment == null}, or if {@code order == null}.\n@@ -335,0 +358,2 @@\n+        Objects.requireNonNull(segment);\n+        Objects.requireNonNull(order);\n@@ -350,0 +375,1 @@\n+     * @throws NullPointerException if {@code segment == null}, or if {@code order == null}.\n@@ -352,0 +378,2 @@\n+        Objects.requireNonNull(segment);\n+        Objects.requireNonNull(order);\n@@ -367,0 +395,1 @@\n+     * @throws NullPointerException if {@code segment == null}, or if {@code order == null}.\n@@ -369,0 +398,2 @@\n+        Objects.requireNonNull(segment);\n+        Objects.requireNonNull(order);\n@@ -384,0 +415,1 @@\n+     * @throws NullPointerException if {@code segment == null}, or if {@code order == null}.\n@@ -386,0 +418,2 @@\n+        Objects.requireNonNull(segment);\n+        Objects.requireNonNull(order);\n@@ -401,0 +435,1 @@\n+     * @throws NullPointerException if {@code segment == null}, or if {@code order == null}.\n@@ -403,0 +438,2 @@\n+        Objects.requireNonNull(segment);\n+        Objects.requireNonNull(order);\n@@ -418,0 +455,1 @@\n+     * @throws NullPointerException if {@code segment == null}, or if {@code order == null}.\n@@ -420,0 +458,2 @@\n+        Objects.requireNonNull(segment);\n+        Objects.requireNonNull(order);\n@@ -435,0 +475,1 @@\n+     * @throws NullPointerException if {@code segment == null}, or if {@code order == null}.\n@@ -437,0 +478,2 @@\n+        Objects.requireNonNull(segment);\n+        Objects.requireNonNull(order);\n@@ -452,0 +495,1 @@\n+     * @throws NullPointerException if {@code segment == null}, or if {@code order == null}.\n@@ -454,0 +498,2 @@\n+        Objects.requireNonNull(segment);\n+        Objects.requireNonNull(order);\n@@ -469,0 +515,1 @@\n+     * @throws NullPointerException if {@code segment == null}, or if {@code order == null}.\n@@ -471,0 +518,2 @@\n+        Objects.requireNonNull(segment);\n+        Objects.requireNonNull(order);\n@@ -486,0 +535,1 @@\n+     * @throws NullPointerException if {@code segment == null}, or if {@code order == null}.\n@@ -488,0 +538,2 @@\n+        Objects.requireNonNull(segment);\n+        Objects.requireNonNull(order);\n@@ -503,0 +555,1 @@\n+     * @throws NullPointerException if {@code segment == null}, or if {@code order == null}.\n@@ -505,0 +558,2 @@\n+        Objects.requireNonNull(segment);\n+        Objects.requireNonNull(order);\n@@ -520,0 +575,1 @@\n+     * @throws NullPointerException if {@code segment == null}, or if {@code order == null}.\n@@ -522,0 +578,2 @@\n+        Objects.requireNonNull(segment);\n+        Objects.requireNonNull(order);\n@@ -535,0 +593,1 @@\n+     * @throws NullPointerException if {@code segment == null}.\n@@ -549,0 +608,1 @@\n+     * @throws NullPointerException if {@code segment == null}.\n@@ -563,0 +623,1 @@\n+     * @throws NullPointerException if {@code segment == null}.\n@@ -577,0 +638,1 @@\n+     * @throws NullPointerException if {@code segment == null}.\n@@ -591,0 +653,1 @@\n+     * @throws NullPointerException if {@code segment == null}.\n@@ -605,0 +668,1 @@\n+     * @throws NullPointerException if {@code segment == null}.\n@@ -619,0 +683,1 @@\n+     * @throws NullPointerException if {@code segment == null}.\n@@ -633,0 +698,1 @@\n+     * @throws NullPointerException if {@code segment == null}.\n@@ -647,0 +713,1 @@\n+     * @throws NullPointerException if {@code segment == null}.\n@@ -661,0 +728,1 @@\n+     * @throws NullPointerException if {@code segment == null}.\n@@ -675,0 +743,1 @@\n+     * @throws NullPointerException if {@code segment == null}.\n@@ -689,0 +758,1 @@\n+     * @throws NullPointerException if {@code segment == null}.\n@@ -703,0 +773,1 @@\n+     * @throws NullPointerException if {@code segment == null}.\n@@ -717,0 +788,1 @@\n+     * @throws NullPointerException if {@code segment == null}.\n@@ -731,0 +803,1 @@\n+     * @throws NullPointerException if {@code segment == null}.\n@@ -745,0 +818,1 @@\n+     * @throws NullPointerException if {@code segment == null}, or if {@code value == null}.\n@@ -760,0 +834,1 @@\n+     * @throws NullPointerException if {@code segment == null}, or if {@code order == null}.\n@@ -775,0 +850,1 @@\n+     * @throws NullPointerException if {@code segment == null}, or if {@code order == null}.\n@@ -790,0 +866,1 @@\n+     * @throws NullPointerException if {@code segment == null}, or if {@code order == null}.\n@@ -805,0 +882,1 @@\n+     * @throws NullPointerException if {@code segment == null}, or if {@code order == null}.\n@@ -820,0 +898,1 @@\n+     * @throws NullPointerException if {@code segment == null}, or if {@code order == null}.\n@@ -835,0 +914,1 @@\n+     * @throws NullPointerException if {@code segment == null}, or if {@code order == null}.\n@@ -850,0 +930,1 @@\n+     * @throws NullPointerException if {@code segment == null}, or if {@code order == null}.\n@@ -865,0 +946,1 @@\n+     * @throws NullPointerException if {@code segment == null}, or if {@code order == null}.\n@@ -880,0 +962,1 @@\n+     * @throws NullPointerException if {@code segment == null}, or if {@code order == null}.\n@@ -895,0 +978,1 @@\n+     * @throws NullPointerException if {@code segment == null}, or if {@code order == null}.\n@@ -910,0 +994,1 @@\n+     * @throws NullPointerException if {@code segment == null}, or if {@code order == null}.\n@@ -925,0 +1010,1 @@\n+     * @throws NullPointerException if {@code segment == null}, or if {@code order == null}.\n@@ -940,0 +1026,1 @@\n+     * @throws NullPointerException if {@code segment == null}.\n@@ -955,0 +1042,1 @@\n+     * @throws NullPointerException if {@code segment == null}.\n@@ -970,0 +1058,1 @@\n+     * @throws NullPointerException if {@code segment == null}.\n@@ -985,0 +1074,1 @@\n+     * @throws NullPointerException if {@code segment == null}.\n@@ -1000,0 +1090,1 @@\n+     * @throws NullPointerException if {@code segment == null}.\n@@ -1015,0 +1106,1 @@\n+     * @throws NullPointerException if {@code segment == null}.\n@@ -1030,0 +1122,1 @@\n+     * @throws NullPointerException if {@code segment == null}.\n@@ -1045,0 +1138,1 @@\n+     * @throws NullPointerException if {@code segment == null}.\n@@ -1060,0 +1154,1 @@\n+     * @throws NullPointerException if {@code segment == null}.\n@@ -1075,0 +1170,1 @@\n+     * @throws NullPointerException if {@code segment == null}.\n@@ -1090,0 +1186,1 @@\n+     * @throws NullPointerException if {@code segment == null}.\n@@ -1096,1 +1193,1 @@\n-     * Reads a memory address from given segment and element index, with byte order set to {@link ByteOrder#nativeOrder()}.\n+     * Writes a double at given segment and element index, with byte order set to {@link ByteOrder#nativeOrder()}.\n@@ -1100,1 +1197,1 @@\n-    return getAddressAtOffset(segment, index * MemoryLayouts.ADDRESS.byteSize());\n+    setDoubleAtOffset(segment, 8 * index, value);\n@@ -1104,1 +1201,2 @@\n-     * @return a memory address read from {@code segment} at the element index specified by {@code index}.\n+     * @param value the double value to be written.\n+     * @throws NullPointerException if {@code segment == null}.\n@@ -1106,2 +1204,2 @@\n-    public static MemoryAddress getAddressAtIndex(MemorySegment segment, long index) {\n-        return getAddressAtOffset(segment, scale(segment, index, (int)MemoryLayouts.ADDRESS.byteSize()));\n+    public static void setDoubleAtIndex(MemorySegment segment, long index, double value) {\n+        setDoubleAtOffset(segment, scale(segment, index, 8), value);\n@@ -1111,1 +1209,1 @@\n-     * Writes a memory address at given segment and element index, with byte order set to {@link ByteOrder#nativeOrder()}.\n+     * Reads a memory address from given segment and element index, with byte order set to {@link ByteOrder#nativeOrder()}.\n@@ -1115,1 +1213,1 @@\n-    setAddressAtOffset(segment, index * MemoryLayouts.ADDRESS.byteSize(), value);\n+    return getAddressAtOffset(segment, index * MemoryLayouts.ADDRESS.byteSize());\n@@ -1119,1 +1217,2 @@\n-     * @param value the memory address to be written (expressed as an {@link Addressable} instance).\n+     * @return a memory address read from {@code segment} at the element index specified by {@code index}.\n+     * @throws NullPointerException if {@code segment == null}.\n@@ -1121,2 +1220,2 @@\n-    public static void setAddressAtIndex(MemorySegment segment, long index, Addressable value) {\n-        setAddressAtOffset(segment, scale(segment, index, (int)MemoryLayouts.ADDRESS.byteSize()), value);\n+    public static MemoryAddress getAddressAtIndex(MemorySegment segment, long index) {\n+        return getAddressAtOffset(segment, scale(segment, index, (int)MemoryLayouts.ADDRESS.byteSize()));\n@@ -1126,1 +1225,1 @@\n-     * Writes a double at given segment and element index, with byte order set to {@link ByteOrder#nativeOrder()}.\n+     * Writes a memory address at given segment and element index, with byte order set to {@link ByteOrder#nativeOrder()}.\n@@ -1130,1 +1229,1 @@\n-    setDoubleAtOffset(segment, 8 * index, value);\n+    setAddressAtOffset(segment, index * MemoryLayouts.ADDRESS.byteSize(), value);\n@@ -1134,1 +1233,2 @@\n-     * @param value the double value to be written.\n+     * @param value the memory address to be written (expressed as an {@link Addressable} instance).\n+     * @throws NullPointerException if {@code segment == null}, or if {@code value == null}.\n@@ -1136,2 +1236,2 @@\n-    public static void setDoubleAtIndex(MemorySegment segment, long index, double value) {\n-        setDoubleAtOffset(segment, scale(segment, index, 8), value);\n+    public static void setAddressAtIndex(MemorySegment segment, long index, Addressable value) {\n+        setAddressAtOffset(segment, scale(segment, index, (int)MemoryLayouts.ADDRESS.byteSize()), value);\n@@ -1151,0 +1251,1 @@\n+     * @throws NullPointerException if {@code segment == null}, or if {@code order == null}.\n@@ -1167,0 +1268,1 @@\n+     * @throws NullPointerException if {@code segment == null}, or if {@code order == null}.\n@@ -1183,0 +1285,1 @@\n+     * @throws NullPointerException if {@code segment == null}, or if {@code order == null}.\n@@ -1199,0 +1302,1 @@\n+     * @throws NullPointerException if {@code segment == null}, or if {@code order == null}.\n@@ -1215,0 +1319,1 @@\n+     * @throws NullPointerException if {@code segment == null}, or if {@code order == null}.\n@@ -1231,0 +1336,1 @@\n+     * @throws NullPointerException if {@code segment == null}, or if {@code order == null}.\n@@ -1247,0 +1353,1 @@\n+     * @throws NullPointerException if {@code segment == null}, or if {@code order == null}.\n@@ -1263,0 +1370,1 @@\n+     * @throws NullPointerException if {@code segment == null}, or if {@code order == null}.\n@@ -1279,0 +1387,1 @@\n+     * @throws NullPointerException if {@code segment == null}, or if {@code order == null}.\n@@ -1295,0 +1404,1 @@\n+     * @throws NullPointerException if {@code segment == null}, or if {@code order == null}.\n@@ -1311,0 +1421,1 @@\n+     * @throws NullPointerException if {@code segment == null}, or if {@code order == null}.\n@@ -1327,0 +1438,1 @@\n+     * @throws NullPointerException if {@code segment == null}, or if {@code order == null}.\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemoryAccess.java","additions":127,"deletions":15,"binary":false,"changes":142,"status":"modified"},{"patch":"@@ -87,0 +87,1 @@\n+     * @throws NullPointerException if {@code segment == null}.\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemoryAddress.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -171,0 +171,1 @@\n+     * @throws NullPointerException if {@code carrier == null}, or {@code byteOrder == null}.\n@@ -173,1 +174,2 @@\n-        checkCarrier(carrier);\n+        Objects.requireNonNull(carrier);\n+        Objects.requireNonNull(byteOrder);\n@@ -197,0 +199,1 @@\n+     * @throws NullPointerException if {@code carrier == null}, or {@code byteOrder == null}.\n@@ -199,0 +202,2 @@\n+        Objects.requireNonNull(carrier);\n+        Objects.requireNonNull(byteOrder);\n@@ -221,0 +226,1 @@\n+     * @throws NullPointerException if {@code target == null}.\n@@ -223,0 +229,1 @@\n+        Objects.requireNonNull(target);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemoryHandles.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+import java.util.stream.Collectors;\n@@ -253,0 +254,1 @@\n+     * @throws NullPointerException if {@code name == null}.\n@@ -311,0 +313,1 @@\n+     * @throws NullPointerException if {@code name == null}.\n@@ -322,0 +325,1 @@\n+     * @throws NullPointerException if {@code name == null}.\n@@ -345,0 +349,2 @@\n+     * @throws NullPointerException if either {@code elements == null}, or if any of the elements\n+     * in {@code elements} is {@code null}.\n@@ -364,0 +370,2 @@\n+     * @throws NullPointerException if either {@code elements == null}, or if any of the elements\n+     * in {@code elements} is {@code null}.\n@@ -404,0 +412,2 @@\n+     * @throws NullPointerException if either {@code carrier == null}, {@code elements == null}, or if any of the elements\n+     * in {@code elements} is {@code null}.\n@@ -406,0 +416,1 @@\n+        Objects.requireNonNull(carrier);\n@@ -418,0 +429,2 @@\n+     * @throws NullPointerException if either {@code elements == null}, or if any of the elements\n+     * in {@code elements} is {@code null}.\n@@ -435,0 +448,2 @@\n+     * @throws NullPointerException if either {@code op == null}, {@code elements == null}, or if any of the elements\n+     * in {@code elements} is {@code null}.\n@@ -437,0 +452,1 @@\n+        Objects.requireNonNull(op);\n@@ -443,0 +459,1 @@\n+        Objects.requireNonNull(elements);\n@@ -444,1 +461,1 @@\n-            LayoutPath.PathElementImpl pathElem = (LayoutPath.PathElementImpl)e;\n+            LayoutPath.PathElementImpl pathElem = (LayoutPath.PathElementImpl)Objects.requireNonNull(e);\n@@ -608,0 +625,1 @@\n+     * @throws NullPointerException if {@code order == null}.\n@@ -610,0 +628,1 @@\n+        Objects.requireNonNull(order);\n@@ -621,0 +640,1 @@\n+     * @throws NullPointerException if {@code elementLayout == null}.\n@@ -625,1 +645,1 @@\n-        return new SequenceLayout(size, elementLayout);\n+        return new SequenceLayout(size, Objects.requireNonNull(elementLayout));\n@@ -633,0 +653,1 @@\n+     * @throws NullPointerException if {@code elementLayout == null}.\n@@ -635,1 +656,1 @@\n-        return new SequenceLayout(OptionalLong.empty(), elementLayout);\n+        return new SequenceLayout(OptionalLong.empty(), Objects.requireNonNull(elementLayout));\n@@ -643,0 +664,1 @@\n+     * @throws NullPointerException if {@code elements == null}, or if any of the layouts in {@code elements} is {@code null}.\n@@ -645,1 +667,5 @@\n-        return new GroupLayout(GroupLayout.Kind.STRUCT, List.of(elements));\n+        Objects.requireNonNull(elements);\n+        return new GroupLayout(GroupLayout.Kind.STRUCT,\n+                Stream.of(elements)\n+                        .map(Objects::requireNonNull)\n+                        .collect(Collectors.toList()));\n@@ -653,0 +679,1 @@\n+     * @throws NullPointerException if {@code elements == null}, or if any of the layouts in {@code elements} is {@code null}.\n@@ -655,1 +682,5 @@\n-        return new GroupLayout(GroupLayout.Kind.UNION, List.of(elements));\n+        Objects.requireNonNull(elements);\n+        return new GroupLayout(GroupLayout.Kind.UNION,\n+                Stream.of(elements)\n+                        .map(Objects::requireNonNull)\n+                        .collect(Collectors.toList()));\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemoryLayout.java","additions":36,"deletions":5,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -254,0 +254,1 @@\n+     * @throws NullPointerException if {@code layout == null}.\n@@ -506,0 +507,1 @@\n+     * @throws NullPointerException if {@code cleaner == null}.\n@@ -556,0 +558,1 @@\n+     * @throws NullPointerException if {@code src == null}.\n@@ -582,0 +585,1 @@\n+     * @throws NullPointerException if {@code src == null}.\n@@ -706,0 +710,1 @@\n+     * @throws NullPointerException if {@code bb == null}.\n@@ -720,0 +725,1 @@\n+     * @throws NullPointerException if {@code arr == null}.\n@@ -734,0 +740,1 @@\n+     * @throws NullPointerException if {@code arr == null}.\n@@ -748,0 +755,1 @@\n+     * @throws NullPointerException if {@code arr == null}.\n@@ -762,0 +770,1 @@\n+     * @throws NullPointerException if {@code arr == null}.\n@@ -776,0 +785,1 @@\n+     * @throws NullPointerException if {@code arr == null}.\n@@ -790,0 +800,1 @@\n+     * @throws NullPointerException if {@code arr == null}.\n@@ -804,0 +815,1 @@\n+     * @throws NullPointerException if {@code arr == null}.\n@@ -824,0 +836,1 @@\n+     * @throws NullPointerException if {@code layout == null}.\n@@ -826,0 +839,1 @@\n+        Objects.requireNonNull(layout);\n@@ -888,0 +902,1 @@\n+     * @throws NullPointerException if {@code path == null} or if {@code mapMode == null}.\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemorySegment.java","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import java.util.Objects;\n@@ -91,0 +92,1 @@\n+     * @throws NullPointerException if {@code layout == null}.\n@@ -93,0 +95,1 @@\n+        Objects.requireNonNull(layout);\n@@ -109,0 +112,1 @@\n+     * @throws NullPointerException if {@code layout == null}.\n@@ -111,0 +115,1 @@\n+        Objects.requireNonNull(layout);\n@@ -127,0 +132,1 @@\n+     * @throws NullPointerException if {@code layout == null}.\n@@ -129,0 +135,1 @@\n+        Objects.requireNonNull(layout);\n@@ -145,0 +152,1 @@\n+     * @throws NullPointerException if {@code layout == null}.\n@@ -147,0 +155,1 @@\n+        Objects.requireNonNull(layout);\n@@ -165,0 +174,1 @@\n+        Objects.requireNonNull(layout);\n@@ -181,0 +191,1 @@\n+     * @throws NullPointerException if {@code layout == null}.\n@@ -183,0 +194,1 @@\n+        Objects.requireNonNull(layout);\n@@ -199,0 +211,1 @@\n+     * @throws NullPointerException if {@code layout == null}.\n@@ -201,0 +214,1 @@\n+        Objects.requireNonNull(layout);\n@@ -219,0 +233,1 @@\n+     * @throws NullPointerException if either {@code layout == null}, or {@code value == null}.\n@@ -221,0 +236,2 @@\n+        Objects.requireNonNull(value);\n+        Objects.requireNonNull(layout);\n@@ -241,0 +258,1 @@\n+     * @throws NullPointerException if either {@code layout == null}, or {@code array == null}.\n@@ -256,0 +274,1 @@\n+     * @throws NullPointerException if either {@code layout == null}, or {@code array == null}.\n@@ -271,0 +290,1 @@\n+     * @throws NullPointerException if either {@code layout == null}, or {@code array == null}.\n@@ -286,0 +306,1 @@\n+     * @throws NullPointerException if either {@code layout == null}, or {@code array == null}.\n@@ -301,0 +322,1 @@\n+     * @throws NullPointerException if either {@code layout == null}, or {@code array == null}.\n@@ -316,0 +338,1 @@\n+     * @throws NullPointerException if either {@code layout == null}, or {@code array == null}.\n@@ -331,0 +354,1 @@\n+     * @throws NullPointerException if either {@code layout == null}, or {@code array == null}.\n@@ -347,0 +371,2 @@\n+     * @throws NullPointerException if either {@code layout == null}, or {@code array == null}, or if any of the elements\n+     * in {@code array} is {@code null}.\n@@ -349,0 +375,3 @@\n+        Objects.requireNonNull(elementLayout);\n+        Objects.requireNonNull(array);\n+        Stream.of(array).forEach(Objects::requireNonNull);\n@@ -365,0 +394,2 @@\n+        Objects.requireNonNull(array);\n+        Objects.requireNonNull(elementLayout);\n@@ -382,0 +413,1 @@\n+     * @throws NullPointerException if {@code layout == null}.\n@@ -384,0 +416,1 @@\n+        Objects.requireNonNull(layout);\n@@ -400,0 +433,1 @@\n+     * @throws NullPointerException if {@code elementLayout == null}.\n@@ -402,0 +436,1 @@\n+        Objects.requireNonNull(elementLayout);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/NativeScope.java","additions":35,"deletions":0,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -78,0 +78,1 @@\n+     * @throws NullPointerException if {@code order == null}.\n@@ -80,1 +81,1 @@\n-        return new ValueLayout(order, bitSize(), alignment, attributes);\n+        return new ValueLayout(Objects.requireNonNull(order), bitSize(), alignment, attributes);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/ValueLayout.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -112,0 +112,1 @@\n+        Objects.requireNonNull(sequenceLayout);\n@@ -128,1 +129,1 @@\n-        AbstractMemorySegmentImpl that = (AbstractMemorySegmentImpl)src;\n+        AbstractMemorySegmentImpl that = (AbstractMemorySegmentImpl)Objects.requireNonNull(src);\n@@ -149,1 +150,1 @@\n-        AbstractMemorySegmentImpl that = (AbstractMemorySegmentImpl)other;\n+        AbstractMemorySegmentImpl that = (AbstractMemorySegmentImpl)Objects.requireNonNull(other);\n@@ -594,0 +595,1 @@\n+        Objects.requireNonNull(bb);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/AbstractMemorySegmentImpl.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -100,0 +100,1 @@\n+            Objects.requireNonNull(arr);\n@@ -123,0 +124,1 @@\n+            Objects.requireNonNull(arr);\n@@ -146,0 +148,1 @@\n+            Objects.requireNonNull(arr);\n@@ -169,0 +172,1 @@\n+            Objects.requireNonNull(arr);\n@@ -192,0 +196,1 @@\n+            Objects.requireNonNull(arr);\n@@ -215,0 +220,1 @@\n+            Objects.requireNonNull(arr);\n@@ -238,0 +244,1 @@\n+            Objects.requireNonNull(arr);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/HeapMemorySegmentImpl.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+import java.util.Objects;\n@@ -112,0 +113,2 @@\n+        Objects.requireNonNull(path);\n+        Objects.requireNonNull(mapMode);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/MappedMemorySegmentImpl.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+import java.util.Objects;\n@@ -77,0 +78,3 @@\n+        Objects.requireNonNull(symbol);\n+        Objects.requireNonNull(type);\n+        Objects.requireNonNull(function);\n@@ -85,0 +89,2 @@\n+        Objects.requireNonNull(target);\n+        Objects.requireNonNull(function);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/AArch64Linker.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+import java.util.Objects;\n@@ -242,0 +243,1 @@\n+        Objects.requireNonNull(scope);\n@@ -250,0 +252,1 @@\n+        Objects.requireNonNull(layout);\n@@ -339,0 +342,1 @@\n+        Objects.requireNonNull(layouts);\n@@ -340,0 +344,1 @@\n+            Objects.requireNonNull(layout);\n@@ -380,0 +385,1 @@\n+        Objects.requireNonNull(scope);\n@@ -461,0 +467,2 @@\n+            Objects.requireNonNull(layout);\n+            Objects.requireNonNull(value);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/AArch64VaList.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+import java.util.Objects;\n@@ -219,0 +220,1 @@\n+        Objects.requireNonNull(scope);\n@@ -227,0 +229,1 @@\n+        Objects.requireNonNull(layout);\n@@ -291,0 +294,1 @@\n+        Objects.requireNonNull(layouts);\n@@ -292,0 +296,1 @@\n+            Objects.requireNonNull(layout);\n@@ -329,0 +334,1 @@\n+        Objects.requireNonNull(scope);\n@@ -396,0 +402,2 @@\n+            Objects.requireNonNull(layout);\n+            Objects.requireNonNull(value);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/SysVVaList.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+import java.util.Objects;\n@@ -88,0 +89,3 @@\n+        Objects.requireNonNull(symbol);\n+        Objects.requireNonNull(type);\n+        Objects.requireNonNull(function);\n@@ -96,0 +100,2 @@\n+        Objects.requireNonNull(target);\n+        Objects.requireNonNull(function);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/SysVx64Linker.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -36,0 +36,2 @@\n+import java.util.Objects;\n+import java.util.stream.Stream;\n@@ -103,0 +105,1 @@\n+        Objects.requireNonNull(scope);\n@@ -111,0 +114,1 @@\n+        Objects.requireNonNull(layout);\n@@ -142,0 +146,2 @@\n+        Objects.requireNonNull(layouts);\n+        Stream.of(layouts).forEach(Objects::requireNonNull);\n@@ -170,0 +176,1 @@\n+        Objects.requireNonNull(scope);\n@@ -198,0 +205,2 @@\n+            Objects.requireNonNull(layout);\n+            Objects.requireNonNull(value);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/WinVaList.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+import java.util.Objects;\n@@ -89,0 +90,3 @@\n+        Objects.requireNonNull(symbol);\n+        Objects.requireNonNull(type);\n+        Objects.requireNonNull(function);\n@@ -97,0 +101,2 @@\n+        Objects.requireNonNull(target);\n+        Objects.requireNonNull(function);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/Windowsx64Linker.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -155,15 +155,0 @@\n-    @Test(expectedExceptions = NullPointerException.class)\n-    public void testBadFilterNullTarget() {\n-        MemoryHandles.filterValue(null, S2I, I2S);\n-    }\n-\n-    @Test(expectedExceptions = NullPointerException.class)\n-    public void testBadFilterNullUnbox() {\n-        MemoryHandles.filterValue(intHandle, null, I2S);\n-    }\n-\n-    @Test(expectedExceptions = NullPointerException.class)\n-    public void testBadFilterNullBox() {\n-        MemoryHandles.filterValue(intHandle, S2I, null);\n-    }\n-\n@@ -237,10 +222,0 @@\n-    @Test(expectedExceptions = NullPointerException.class)\n-    public void testBadFilterCoordinatesNullTarget() {\n-        MemoryHandles.filterCoordinates(null, 0, S2I);\n-    }\n-\n-    @Test(expectedExceptions = NullPointerException.class)\n-    public void testBadFilterCoordinatesNullFilters() {\n-        MemoryHandles.filterCoordinates(intHandle, 0, null);\n-    }\n-\n@@ -290,10 +265,0 @@\n-    @Test(expectedExceptions = NullPointerException.class)\n-    public void testBadInsertCoordinatesNullTarget() {\n-        MemoryHandles.insertCoordinates(null, 0, 42);\n-    }\n-\n-    @Test(expectedExceptions = NullPointerException.class)\n-    public void testBadInsertCoordinatesNullValues() {\n-        MemoryHandles.insertCoordinates(intHandle, 0, null);\n-    }\n-\n@@ -339,15 +304,0 @@\n-    @Test(expectedExceptions = NullPointerException.class)\n-    public void testBadPermuteCoordinatesNullTarget() {\n-        MemoryHandles.permuteCoordinates(null, List.of());\n-    }\n-\n-    @Test(expectedExceptions = NullPointerException.class)\n-    public void testBadPermuteCoordinatesNullCoordinates() {\n-        MemoryHandles.permuteCoordinates(intHandle, null);\n-    }\n-\n-    @Test(expectedExceptions = NullPointerException.class)\n-    public void testBadPermuteCoordinatesNullReorder() {\n-        MemoryHandles.permuteCoordinates(intHandle, List.of(int.class), null);\n-    }\n-\n@@ -392,10 +342,0 @@\n-    @Test(expectedExceptions = NullPointerException.class)\n-    public void testBadCollectCoordinatesNullTarget() {\n-        MemoryHandles.collectCoordinates(null, 0, SUM_OFFSETS);\n-    }\n-\n-    @Test(expectedExceptions = NullPointerException.class)\n-    public void testBadCollectCoordinatesNullFilters() {\n-        MemoryHandles.collectCoordinates(intHandle, 0, null);\n-    }\n-\n@@ -455,10 +395,0 @@\n-    @Test(expectedExceptions = NullPointerException.class)\n-    public void testBadDropCoordinatesNullValueTypes() {\n-        MemoryHandles.dropCoordinates(intHandle, 1, null);\n-    }\n-\n-    @Test(expectedExceptions = NullPointerException.class)\n-    public void testBadDropCoordinatesNullTarget() {\n-        MemoryHandles.dropCoordinates(null, 1);\n-    }\n-\n","filename":"test\/jdk\/java\/foreign\/TestAdaptVarHandles.java","additions":0,"deletions":70,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -122,23 +122,0 @@\n-\n-    @Test(expectedExceptions = NullPointerException.class)\n-    public void testNullArgumentLayout() {\n-        FunctionDescriptor.ofVoid(C_INT, null, C_LONG_LONG);\n-    }\n-\n-    @Test(expectedExceptions = NullPointerException.class)\n-    public void testNullReturnLayout() {\n-        FunctionDescriptor.of(null, C_INT, C_LONG_LONG);\n-    }\n-\n-    @Test(expectedExceptions = NullPointerException.class)\n-    public void testNullArgumentLayoutsAppend() {\n-        FunctionDescriptor fd = FunctionDescriptor.ofVoid(C_INT, C_LONG_LONG);\n-        fd.withAppendedArgumentLayouts(C_DOUBLE, null); \/\/ should throw\n-    }\n-\n-    @Test(expectedExceptions = NullPointerException.class)\n-    public void testNullReturnLayoutChange() {\n-        FunctionDescriptor fd = FunctionDescriptor.ofVoid(C_INT, C_LONG_LONG);\n-        fd.withReturnLayout(null); \/\/ should throw\n-    }\n-\n","filename":"test\/jdk\/java\/foreign\/TestFunctionDescriptor.java","additions":0,"deletions":23,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -82,1 +82,0 @@\n-\n","filename":"test\/jdk\/java\/foreign\/TestLayoutAttributes.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -92,17 +92,0 @@\n-    @Test(expectedExceptions = NullPointerException.class)\n-    public void testNullGroupElementName() {\n-        PathElement.groupElement(null);\n-    }\n-\n-    @Test(expectedExceptions = NullPointerException.class)\n-    public void testBitNullGroupElementName() {\n-        GroupLayout g = MemoryLayout.ofStruct(MemoryLayouts.JAVA_INT);\n-        g.bitOffset(PathElement.groupElement(null));\n-    }\n-\n-    @Test(expectedExceptions = NullPointerException.class)\n-    public void testByteNullGroupElementName() {\n-        GroupLayout g = MemoryLayout.ofStruct(MemoryLayouts.JAVA_INT);\n-        g.byteOffset(PathElement.groupElement(null));\n-    }\n-\n","filename":"test\/jdk\/java\/foreign\/TestLayoutPaths.java","additions":0,"deletions":17,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import java.util.function.Function;\n@@ -34,0 +35,1 @@\n+import java.util.function.UnaryOperator;\n","filename":"test\/jdk\/java\/foreign\/TestLayouts.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,364 @@\n+\/*\n+ *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @run testng TestMemoryAccessStatics\n+ *\/\n+\n+import jdk.incubator.foreign.MemoryAccess;\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.MemoryLayouts;\n+import jdk.incubator.foreign.MemorySegment;\n+\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+\n+import org.testng.annotations.*;\n+import static org.testng.Assert.*;\n+\n+public class TestMemoryAccessStatics {\n+\n+    static class Accessor<X> {\n+\n+        interface SegmentGetter<X> {\n+            X get(MemorySegment segment);\n+        }\n+\n+        interface SegmentSetter<X> {\n+            void set(MemorySegment segment, X o);\n+        }\n+\n+        interface BufferGetter<X> {\n+            X get(ByteBuffer segment);\n+        }\n+\n+        interface BufferSetter<X> {\n+            void set(ByteBuffer buffer, X o);\n+        }\n+\n+        final X value;\n+        final SegmentGetter<X> segmentGetter;\n+        final SegmentSetter<X> segmentSetter;\n+        final BufferGetter<X> bufferGetter;\n+        final BufferSetter<X> bufferSetter;\n+\n+        Accessor(X value,\n+                 SegmentGetter<X> segmentGetter, SegmentSetter<X> segmentSetter,\n+                 BufferGetter<X> bufferGetter, BufferSetter<X> bufferSetter) {\n+            this.value = value;\n+            this.segmentGetter = segmentGetter;\n+            this.segmentSetter = segmentSetter;\n+            this.bufferGetter = bufferGetter;\n+            this.bufferSetter = bufferSetter;\n+        }\n+\n+        void test() {\n+            MemorySegment segment = MemorySegment.ofArray(new byte[32]);\n+            ByteBuffer buffer = segment.asByteBuffer();\n+            segmentSetter.set(segment, value);\n+            assertEquals(bufferGetter.get(buffer), value);\n+            bufferSetter.set(buffer, value);\n+            assertEquals(value, segmentGetter.get(segment));\n+        }\n+\n+        <Z> Accessor<Z> of(Z value,\n+                           SegmentGetter<Z> segmentGetter, SegmentSetter<Z> segmentSetter,\n+                           BufferGetter<Z> bufferGetter, BufferSetter<Z> bufferSetter) {\n+            return new Accessor<>(value, segmentGetter, segmentSetter, bufferGetter, bufferSetter);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"accessors\")\n+    public void testMemoryAccess(String testName, Accessor<?> accessor) {\n+        accessor.test();\n+    }\n+\n+    static final ByteOrder BE = ByteOrder.BIG_ENDIAN;\n+    static final ByteOrder LE = ByteOrder.LITTLE_ENDIAN;\n+    static final ByteOrder NE = ByteOrder.nativeOrder();\n+\n+    @DataProvider(name = \"accessors\")\n+    static Object[][] accessors() {\n+        return new Object[][]{\n+\n+                {\"byte\", new Accessor<>((byte) 42,\n+                        MemoryAccess::getByte, MemoryAccess::setByte,\n+                        (bb) -> bb.get(0), (bb, v) -> bb.put(0, v))\n+                },\n+                {\"char\", new Accessor<>((char) 42,\n+                        MemoryAccess::getChar, MemoryAccess::setChar,\n+                        (bb) -> bb.order(NE).getChar(0), (bb, v) -> bb.order(NE).putChar(0, v))\n+                },\n+                {\"char\/LE\", new Accessor<>((char) 42,\n+                        s -> MemoryAccess.getChar(s, LE), (s, x) -> MemoryAccess.setChar(s, LE, x),\n+                        (bb) -> bb.order(LE).getChar(0), (bb, v) -> bb.order(LE).putChar(0, v))\n+                },\n+                {\"char\/BE\", new Accessor<>((char) 42,\n+                        s -> MemoryAccess.getChar(s, BE), (s, x) -> MemoryAccess.setChar(s, BE, x),\n+                        (bb) -> bb.order(BE).getChar(0), (bb, v) -> bb.order(BE).putChar(0, v))\n+                },\n+                {\"short\", new Accessor<>((short) 42,\n+                        MemoryAccess::getShort, MemoryAccess::setShort,\n+                        (bb) -> bb.order(NE).getShort(0), (bb, v) -> bb.order(NE).putShort(0, v))\n+                },\n+                {\"short\/LE\", new Accessor<>((short) 42,\n+                        s -> MemoryAccess.getShort(s, LE), (s, x) -> MemoryAccess.setShort(s, LE, x),\n+                        (bb) -> bb.order(LE).getShort(0), (bb, v) -> bb.order(LE).putShort(0, v))\n+                },\n+                {\"short\/BE\", new Accessor<>((short) 42,\n+                        s -> MemoryAccess.getShort(s, BE), (s, x) -> MemoryAccess.setShort(s, BE, x),\n+                        (bb) -> bb.order(BE).getShort(0), (bb, v) -> bb.order(BE).putShort(0, v))\n+                },\n+                {\"int\", new Accessor<>(42,\n+                        MemoryAccess::getInt, MemoryAccess::setInt,\n+                        (bb) -> bb.order(NE).getInt(0), (bb, v) -> bb.order(NE).putInt(0, v))\n+                },\n+                {\"int\/LE\", new Accessor<>(42,\n+                        s -> MemoryAccess.getInt(s, LE), (s, x) -> MemoryAccess.setInt(s, LE, x),\n+                        (bb) -> bb.order(LE).getInt(0), (bb, v) -> bb.order(LE).putInt(0, v))\n+                },\n+                {\"int\/BE\", new Accessor<>(42,\n+                        s -> MemoryAccess.getInt(s, BE), (s, x) -> MemoryAccess.setInt(s, BE, x),\n+                        (bb) -> bb.order(BE).getInt(0), (bb, v) -> bb.order(BE).putInt(0, v))\n+                },\n+                \/\/ float, no offset\n+                {\"float\", new Accessor<>(42f,\n+                        MemoryAccess::getFloat, MemoryAccess::setFloat,\n+                        (bb) -> bb.order(NE).getFloat(0), (bb, v) -> bb.order(NE).putFloat(0, v))\n+                },\n+                {\"float\/LE\", new Accessor<>(42f,\n+                        s -> MemoryAccess.getFloat(s, LE), (s, x) -> MemoryAccess.setFloat(s, LE, x),\n+                        (bb) -> bb.order(LE).getFloat(0), (bb, v) -> bb.order(LE).putFloat(0, v))\n+                },\n+                {\"float\/BE\", new Accessor<>(42f,\n+                        s -> MemoryAccess.getFloat(s, BE), (s, x) -> MemoryAccess.setFloat(s, BE, x),\n+                        (bb) -> bb.order(BE).getFloat(0), (bb, v) -> bb.order(BE).putFloat(0, v))\n+                },\n+                \/\/ double, no offset\n+                {\"double\", new Accessor<>(42d,\n+                        MemoryAccess::getDouble, MemoryAccess::setDouble,\n+                        (bb) -> bb.order(NE).getDouble(0), (bb, v) -> bb.order(NE).putDouble(0, v))\n+                },\n+                {\"double\/LE\", new Accessor<>(42d,\n+                        s -> MemoryAccess.getDouble(s, LE), (s, x) -> MemoryAccess.setDouble(s, LE, x),\n+                        (bb) -> bb.order(LE).getDouble(0), (bb, v) -> bb.order(LE).putDouble(0, v))\n+                },\n+                {\"double\/BE\", new Accessor<>(42d,\n+                        s -> MemoryAccess.getDouble(s, BE), (s, x) -> MemoryAccess.setDouble(s, BE, x),\n+                        (bb) -> bb.order(BE).getDouble(0), (bb, v) -> bb.order(BE).putDouble(0, v))\n+                },\n+\n+\n+                \/\/ byte, offset\n+                {\"byte\/offset\", new Accessor<>((byte) 42,\n+                        s -> MemoryAccess.getByteAtOffset(s, 4), (s, x) -> MemoryAccess.setByteAtOffset(s, 4, x),\n+                        (bb) -> bb.get(4), (bb, v) -> bb.put(4, v))\n+                },\n+                \/\/ char, offset\n+                {\"char\/offset\", new Accessor<>((char) 42,\n+                        s -> MemoryAccess.getCharAtOffset(s, 4), (s, x) -> MemoryAccess.setCharAtOffset(s, 4, x),\n+                        (bb) -> bb.order(NE).getChar(4), (bb, v) -> bb.order(NE).putChar(4, v))\n+                },\n+                {\"char\/offset\/LE\", new Accessor<>((char) 42,\n+                        s -> MemoryAccess.getCharAtOffset(s, 4, LE), (s, x) -> MemoryAccess.setCharAtOffset(s, 4, LE, x),\n+                        (bb) -> bb.order(LE).getChar(4), (bb, v) -> bb.order(LE).putChar(4, v))\n+                },\n+                {\"char\/offset\/BE\", new Accessor<>((char) 42,\n+                        s -> MemoryAccess.getCharAtOffset(s, 4, BE), (s, x) -> MemoryAccess.setCharAtOffset(s, 4, BE, x),\n+                        (bb) -> bb.order(BE).getChar(4), (bb, v) -> bb.order(BE).putChar(4, v))\n+                },\n+                \/\/ short, offset\n+                {\"short\/offset\", new Accessor<>((short) 42,\n+                        s -> MemoryAccess.getShortAtOffset(s, 4), (s, x) -> MemoryAccess.setShortAtOffset(s, 4, x),\n+                        (bb) -> bb.order(NE).getShort(4), (bb, v) -> bb.order(NE).putShort(4, v))\n+                },\n+                {\"short\/offset\/LE\", new Accessor<>((short) 42,\n+                        s -> MemoryAccess.getShortAtOffset(s, 4, LE), (s, x) -> MemoryAccess.setShortAtOffset(s, 4, LE, x),\n+                        (bb) -> bb.order(LE).getShort(4), (bb, v) -> bb.order(LE).putShort(4, v))\n+                },\n+                {\"short\/offset\/BE\", new Accessor<>((short) 42,\n+                        s -> MemoryAccess.getShortAtOffset(s, 4, BE), (s, x) -> MemoryAccess.setShortAtOffset(s, 4, BE, x),\n+                        (bb) -> bb.order(BE).getShort(4), (bb, v) -> bb.order(BE).putShort(4, v))\n+                },\n+                \/\/ int, offset\n+                {\"int\/offset\", new Accessor<>(42,\n+                        s -> MemoryAccess.getIntAtOffset(s, 4), (s, x) -> MemoryAccess.setIntAtOffset(s, 4, x),\n+                        (bb) -> bb.order(NE).getInt(4), (bb, v) -> bb.order(NE).putInt(4, v))\n+                },\n+                {\"int\/offset\/LE\", new Accessor<>(42,\n+                        s -> MemoryAccess.getIntAtOffset(s, 4, LE), (s, x) -> MemoryAccess.setIntAtOffset(s, 4, LE, x),\n+                        (bb) -> bb.order(LE).getInt(4), (bb, v) -> bb.order(LE).putInt(4, v))\n+                },\n+                {\"int\/offset\/BE\", new Accessor<>(42,\n+                        s -> MemoryAccess.getIntAtOffset(s, 4, BE), (s, x) -> MemoryAccess.setIntAtOffset(s, 4, BE, x),\n+                        (bb) -> bb.order(BE).getInt(4), (bb, v) -> bb.order(BE).putInt(4, v))\n+                },\n+                \/\/ float, offset\n+                {\"float\/offset\", new Accessor<>(42f,\n+                        s -> MemoryAccess.getFloatAtOffset(s, 4), (s, x) -> MemoryAccess.setFloatAtOffset(s, 4, x),\n+                        (bb) -> bb.order(NE).getFloat(4), (bb, v) -> bb.order(NE).putFloat(4, v))\n+                },\n+                {\"float\/offset\/LE\", new Accessor<>(42f,\n+                        s -> MemoryAccess.getFloatAtOffset(s, 4, LE), (s, x) -> MemoryAccess.setFloatAtOffset(s, 4, LE, x),\n+                        (bb) -> bb.order(LE).getFloat(4), (bb, v) -> bb.order(LE).putFloat(4, v))\n+                },\n+                {\"float\/offset\/BE\", new Accessor<>(42f,\n+                        s -> MemoryAccess.getFloatAtOffset(s, 4, BE), (s, x) -> MemoryAccess.setFloatAtOffset(s, 4, BE, x),\n+                        (bb) -> bb.order(BE).getFloat(4), (bb, v) -> bb.order(BE).putFloat(4, v))\n+                },\n+                \/\/ double, offset\n+                {\"double\/offset\", new Accessor<>(42d,\n+                        s -> MemoryAccess.getDoubleAtOffset(s, 4), (s, x) -> MemoryAccess.setDoubleAtOffset(s, 4, x),\n+                        (bb) -> bb.order(NE).getDouble(4), (bb, v) -> bb.order(NE).putDouble(4, v))\n+                },\n+                {\"double\/offset\/LE\", new Accessor<>(42d,\n+                        s -> MemoryAccess.getDoubleAtOffset(s, 4, LE), (s, x) -> MemoryAccess.setDoubleAtOffset(s, 4, LE, x),\n+                        (bb) -> bb.order(LE).getDouble(4), (bb, v) -> bb.order(LE).putDouble(4, v))\n+                },\n+                {\"double\/offset\/BE\", new Accessor<>(42d,\n+                        s -> MemoryAccess.getDoubleAtOffset(s, 4, BE), (s, x) -> MemoryAccess.setDoubleAtOffset(s, 4, BE, x),\n+                        (bb) -> bb.order(BE).getDouble(4), (bb, v) -> bb.order(BE).putDouble(4, v))\n+                },\n+\n+\n+                \/\/ char, index\n+                {\"char\/index\", new Accessor<>((char) 42,\n+                        s -> MemoryAccess.getCharAtIndex(s, 2), (s, x) -> MemoryAccess.setCharAtIndex(s, 2, x),\n+                        (bb) -> bb.order(NE).asCharBuffer().get(2), (bb, v) -> bb.order(NE).asCharBuffer().put(2, v))\n+                },\n+                {\"char\/index\/LE\", new Accessor<>((char) 42,\n+                        s -> MemoryAccess.getCharAtIndex(s, 2, LE), (s, x) -> MemoryAccess.setCharAtIndex(s, 2, LE, x),\n+                        (bb) -> bb.order(LE).asCharBuffer().get(2), (bb, v) -> bb.order(LE).asCharBuffer().put(2, v))\n+                },\n+                {\"char\/index\/BE\", new Accessor<>((char) 42,\n+                        s -> MemoryAccess.getCharAtIndex(s, 2, BE), (s, x) -> MemoryAccess.setCharAtIndex(s, 2, BE, x),\n+                        (bb) -> bb.order(BE).asCharBuffer().get(2), (bb, v) -> bb.order(BE).asCharBuffer().put(2, v))\n+                },\n+                \/\/ short, index\n+                {\"short\/index\", new Accessor<>((short) 42,\n+                        s -> MemoryAccess.getShortAtIndex(s, 2), (s, x) -> MemoryAccess.setShortAtIndex(s, 2, x),\n+                        (bb) -> bb.order(NE).asShortBuffer().get(2), (bb, v) -> bb.order(NE).asShortBuffer().put(2, v))\n+                },\n+                {\"short\/index\/LE\", new Accessor<>((short) 42,\n+                        s -> MemoryAccess.getShortAtIndex(s, 2, LE), (s, x) -> MemoryAccess.setShortAtIndex(s, 2, LE, x),\n+                        (bb) -> bb.order(LE).asShortBuffer().get(2), (bb, v) -> bb.order(LE).asShortBuffer().put(2, v))\n+                },\n+                {\"short\/index\/BE\", new Accessor<>((short) 42,\n+                        s -> MemoryAccess.getShortAtIndex(s, 2, BE), (s, x) -> MemoryAccess.setShortAtIndex(s, 2, BE, x),\n+                        (bb) -> bb.order(BE).asShortBuffer().get(2), (bb, v) -> bb.order(BE).asShortBuffer().put(2, v))\n+                },\n+                {\"int\/index\", new Accessor<>(42,\n+                        s -> MemoryAccess.getIntAtIndex(s, 2), (s, x) -> MemoryAccess.setIntAtIndex(s, 2, x),\n+                        (bb) -> bb.order(NE).asIntBuffer().get(2), (bb, v) -> bb.order(NE).asIntBuffer().put(2, v))\n+                },\n+                {\"int\/index\/LE\", new Accessor<>(42,\n+                        s -> MemoryAccess.getIntAtIndex(s, 2, LE), (s, x) -> MemoryAccess.setIntAtIndex(s, 2, LE, x),\n+                        (bb) -> bb.order(LE).asIntBuffer().get(2), (bb, v) -> bb.order(LE).asIntBuffer().put(2, v))\n+                },\n+                {\"int\/index\/BE\", new Accessor<>(42,\n+                        s -> MemoryAccess.getIntAtIndex(s, 2, BE), (s, x) -> MemoryAccess.setIntAtIndex(s, 2, BE, x),\n+                        (bb) -> bb.order(BE).asIntBuffer().get(2), (bb, v) -> bb.order(BE).asIntBuffer().put(2, v))\n+                },\n+                {\"float\/index\", new Accessor<>(42f,\n+                        s -> MemoryAccess.getFloatAtIndex(s, 2), (s, x) -> MemoryAccess.setFloatAtIndex(s, 2, x),\n+                        (bb) -> bb.order(NE).asFloatBuffer().get(2), (bb, v) -> bb.order(NE).asFloatBuffer().put(2, v))\n+                },\n+                {\"float\/index\/LE\", new Accessor<>(42f,\n+                        s -> MemoryAccess.getFloatAtIndex(s, 2, LE), (s, x) -> MemoryAccess.setFloatAtIndex(s, 2, LE, x),\n+                        (bb) -> bb.order(LE).asFloatBuffer().get(2), (bb, v) -> bb.order(LE).asFloatBuffer().put(2, v))\n+                },\n+                {\"float\/index\/BE\", new Accessor<>(42f,\n+                        s -> MemoryAccess.getFloatAtIndex(s, 2, BE), (s, x) -> MemoryAccess.setFloatAtIndex(s, 2, BE, x),\n+                        (bb) -> bb.order(BE).asFloatBuffer().get(2), (bb, v) -> bb.order(BE).asFloatBuffer().put(2, v))\n+                },\n+                {\"double\/index\", new Accessor<>(42d,\n+                        s -> MemoryAccess.getDoubleAtIndex(s, 2), (s, x) -> MemoryAccess.setDoubleAtIndex(s, 2, x),\n+                        (bb) -> bb.order(NE).asDoubleBuffer().get(2), (bb, v) -> bb.order(NE).asDoubleBuffer().put(2, v))\n+                },\n+                {\"double\/index\/LE\", new Accessor<>(42d,\n+                        s -> MemoryAccess.getDoubleAtIndex(s, 2, LE), (s, x) -> MemoryAccess.setDoubleAtIndex(s, 2, LE, x),\n+                        (bb) -> bb.order(LE).asDoubleBuffer().get(2), (bb, v) -> bb.order(LE).asDoubleBuffer().put(2, v))\n+                },\n+                {\"double\/index\/BE\", new Accessor<>(42d,\n+                        s -> MemoryAccess.getDoubleAtIndex(s, 2, BE), (s, x) -> MemoryAccess.setDoubleAtIndex(s, 2, BE, x),\n+                        (bb) -> bb.order(BE).asDoubleBuffer().get(2), (bb, v) -> bb.order(BE).asDoubleBuffer().put(2, v))\n+                },\n+\n+                { \"address\", new Accessor<>(MemoryAddress.ofLong(42),\n+                        MemoryAccess::getAddress, MemoryAccess::setAddress,\n+                        (bb) -> {\n+                            ByteBuffer nb = bb.order(NE);\n+                            long addr = MemoryLayouts.ADDRESS.byteSize() == 8 ?\n+                                    nb.getLong(0) : nb.getInt(0);\n+                            return MemoryAddress.ofLong(addr);\n+                        },\n+                        (bb, v) -> {\n+                            ByteBuffer nb = bb.order(NE);\n+                            if (MemoryLayouts.ADDRESS.byteSize() == 8) {\n+                                nb.putLong(0, v.toRawLongValue());\n+                            } else {\n+                                nb.putInt(0, (int)v.toRawLongValue());\n+                            }\n+                        })\n+                },\n+                { \"address\/offset\", new Accessor<>(MemoryAddress.ofLong(42),\n+                        s -> MemoryAccess.getAddressAtOffset(s, 4), (s, x) -> MemoryAccess.setAddressAtOffset(s, 4, x),\n+                        (bb) -> {\n+                            ByteBuffer nb = bb.order(NE);\n+                            long addr = MemoryLayouts.ADDRESS.byteSize() == 8 ?\n+                                    nb.getLong(4) : nb.getInt(4);\n+                            return MemoryAddress.ofLong(addr);\n+                        },\n+                        (bb, v) -> {\n+                            ByteBuffer nb = bb.order(NE);\n+                            if (MemoryLayouts.ADDRESS.byteSize() == 8) {\n+                                nb.putLong(4, v.toRawLongValue());\n+                            } else {\n+                                nb.putInt(4, (int)v.toRawLongValue());\n+                            }\n+                        })\n+                },\n+                { \"address\/index\", new Accessor<>(MemoryAddress.ofLong(42),\n+                        s -> MemoryAccess.getAddressAtIndex(s, 2), (s, x) -> MemoryAccess.setAddressAtIndex(s, 2, x),\n+                        (bb) -> {\n+                            ByteBuffer nb = bb.order(NE);\n+                            long addr = MemoryLayouts.ADDRESS.byteSize() == 8 ?\n+                                    nb.asLongBuffer().get(2) : nb.asIntBuffer().get(2);\n+                            return MemoryAddress.ofLong(addr);\n+                        },\n+                        (bb, v) -> {\n+                            ByteBuffer nb = bb.order(NE);\n+                            if (MemoryLayouts.ADDRESS.byteSize() == 8) {\n+                                nb.asLongBuffer().put(2, v.toRawLongValue());\n+                            } else {\n+                                nb.asIntBuffer().put(2, (int)v.toRawLongValue());\n+                            }\n+                        })\n+                },\n+        };\n+    }\n+}\n","filename":"test\/jdk\/java\/foreign\/TestMemoryAccessStatics.java","additions":364,"deletions":0,"binary":false,"changes":364,"status":"added"},{"patch":"@@ -172,6 +172,0 @@\n-    @Test(expectedExceptions = NullPointerException.class)\n-    public void testNull() {\n-        var segment = MemorySegment.ofArray(new byte[4]);\n-        segment.mismatch(null);\n-    }\n-\n","filename":"test\/jdk\/java\/foreign\/TestMismatch.java","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -30,6 +30,1 @@\n-import jdk.incubator.foreign.MemorySegment;\n-import jdk.incubator.foreign.NativeScope;\n-import jdk.incubator.foreign.MemoryHandles;\n-import jdk.incubator.foreign.MemoryLayouts;\n-import jdk.incubator.foreign.MemoryLayout;\n-import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.*;\n@@ -37,1 +32,0 @@\n-import jdk.incubator.foreign.ValueLayout;\n@@ -41,0 +35,4 @@\n+import java.lang.reflect.Array;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n@@ -49,0 +47,1 @@\n+import java.util.Arrays;\n@@ -52,0 +51,1 @@\n+import java.util.function.Predicate;\n@@ -169,5 +169,0 @@\n-    @Test(expectedExceptions = NullPointerException.class)\n-    public void testNullClaim() {\n-        MemorySegment.ofArray(new byte[5]).handoff((NativeScope)null);\n-    }\n-\n","filename":"test\/jdk\/java\/foreign\/TestNativeScope.java","additions":7,"deletions":12,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -0,0 +1,255 @@\n+\/*\n+ *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @modules java.base\/jdk.internal.ref\n+ *          jdk.incubator.foreign\n+ * @run testng\/othervm -Dforeign.restricted=permit TestNulls\n+ *\/\n+\n+import jdk.incubator.foreign.*;\n+import jdk.internal.ref.CleanerFactory;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.NoInjection;\n+import org.testng.annotations.Test;\n+\n+import java.lang.constant.Constable;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.lang.invoke.VarHandle;\n+import java.lang.ref.Cleaner;\n+import java.lang.reflect.Array;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import java.nio.channels.FileChannel;\n+import java.nio.charset.Charset;\n+import java.nio.file.Path;\n+import java.util.*;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Consumer;\n+import java.util.function.UnaryOperator;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import static org.testng.Assert.*;\n+import static org.testng.Assert.fail;\n+\n+\/**\n+ * This test makes sure that public API classes (listed in {@link TestNulls#CLASSES}) throws NPEs whenever\n+ * nulls are provided. The test looks at all the public methods in all the listed classes, and injects\n+ * values automatically. If an API takes a reference, the test will try to inject nulls. For APIs taking\n+ * either reference arrays, or collections, the framework will also generate additional <em>replacements<\/em>\n+ * (e.g. other than just replacing the array, or collection with null), such as an array or collection\n+ * with null elements. The test can be customized by adding\/removing classes to the {@link #CLASSES} array,\n+ * by adding\/removing default mappings for standard carrier types (see {@link #DEFAULT_VALUES} or by\n+ * adding\/removing custom replacements (see {@link #REPLACEMENT_VALUES}).\n+ *\/\n+public class TestNulls {\n+\n+    static final Class<?>[] CLASSES = new Class<?>[] {\n+            MemorySegment.class,\n+            MemoryAddress.class,\n+            MemoryLayout.class,\n+            MemoryLayout.PathElement.class,\n+            SequenceLayout.class,\n+            ValueLayout.class,\n+            GroupLayout.class,\n+            Addressable.class,\n+            MemoryAccess.class,\n+            MappedMemorySegments.class,\n+            MemoryLayouts.class,\n+            MemoryHandles.class,\n+            NativeScope.class,\n+            CLinker.class,\n+            CLinker.VaList.class,\n+            CLinker.VaList.Builder.class,\n+            FunctionDescriptor.class\n+    };\n+\n+    static final Set<String> EXCLUDE_LIST = Set.of(\n+            \"jdk.incubator.foreign.MemoryLayout\/withAttribute(java.lang.String,java.lang.constant.Constable)\/1\/0\",\n+            \"jdk.incubator.foreign.MemoryAddress\/asSegmentRestricted(long,java.lang.Runnable,java.lang.Object)\/1\/0\",\n+            \"jdk.incubator.foreign.MemoryAddress\/asSegmentRestricted(long,java.lang.Runnable,java.lang.Object)\/2\/0\",\n+            \"jdk.incubator.foreign.SequenceLayout\/withAttribute(java.lang.String,java.lang.constant.Constable)\/1\/0\",\n+            \"jdk.incubator.foreign.ValueLayout\/withAttribute(java.lang.String,java.lang.constant.Constable)\/1\/0\",\n+            \"jdk.incubator.foreign.GroupLayout\/withAttribute(java.lang.String,java.lang.constant.Constable)\/1\/0\",\n+            \"jdk.incubator.foreign.MemoryHandles\/insertCoordinates(java.lang.invoke.VarHandle,int,java.lang.Object[])\/2\/1\",\n+            \"jdk.incubator.foreign.FunctionDescriptor\/withAttribute(java.lang.String,java.lang.constant.Constable)\/1\/0\"\n+    );\n+\n+    static final Set<String> OBJECT_METHODS = Stream.of(Object.class.getMethods())\n+            .map(Method::getName)\n+            .collect(Collectors.toSet());\n+\n+    static final Map<Class<?>, Object> DEFAULT_VALUES = new HashMap<>();\n+\n+    static <Z> void addDefaultMapping(Class<Z> carrier, Z value) {\n+        DEFAULT_VALUES.put(carrier, value);\n+    }\n+\n+    static {\n+        addDefaultMapping(char.class, (char)0);\n+        addDefaultMapping(byte.class, (byte)0);\n+        addDefaultMapping(short.class, (short)0);\n+        addDefaultMapping(int.class, 0);\n+        addDefaultMapping(float.class, 0f);\n+        addDefaultMapping(long.class, 0L);\n+        addDefaultMapping(double.class, 0d);\n+        addDefaultMapping(ByteOrder.class, ByteOrder.nativeOrder());\n+        addDefaultMapping(Thread.class, Thread.currentThread());\n+        addDefaultMapping(Cleaner.class, CleanerFactory.cleaner());\n+        addDefaultMapping(ByteBuffer.class, ByteBuffer.wrap(new byte[10]));\n+        addDefaultMapping(Path.class, Path.of(\"nonExistent\"));\n+        addDefaultMapping(FileChannel.MapMode.class, FileChannel.MapMode.PRIVATE);\n+        addDefaultMapping(UnaryOperator.class, UnaryOperator.identity());\n+        addDefaultMapping(String.class, \"Hello!\");\n+        addDefaultMapping(Constable.class, \"Hello!\");\n+        addDefaultMapping(Class.class, String.class);\n+        addDefaultMapping(Runnable.class, () -> {});\n+        addDefaultMapping(Object.class, new Object());\n+        addDefaultMapping(VarHandle.class, MemoryHandles.varHandle(int.class, ByteOrder.nativeOrder()));\n+        addDefaultMapping(MethodHandle.class, MethodHandles.identity(int.class));\n+        addDefaultMapping(List.class, List.of());\n+        addDefaultMapping(Charset.class, Charset.defaultCharset());\n+        addDefaultMapping(Consumer.class, x -> {});\n+        addDefaultMapping(MethodType.class, MethodType.methodType(void.class));\n+        addDefaultMapping(MemoryAddress.class, MemoryAddress.NULL);\n+        addDefaultMapping(Addressable.class, MemoryAddress.NULL);\n+        addDefaultMapping(MemoryLayout.class, MemoryLayouts.JAVA_INT);\n+        addDefaultMapping(ValueLayout.class, MemoryLayouts.JAVA_INT);\n+        addDefaultMapping(GroupLayout.class, MemoryLayout.ofStruct(MemoryLayouts.JAVA_INT));\n+        addDefaultMapping(SequenceLayout.class, MemoryLayout.ofSequence(MemoryLayouts.JAVA_INT));\n+        addDefaultMapping(MemorySegment.class, MemorySegment.ofArray(new byte[10]));\n+        addDefaultMapping(NativeScope.class, NativeScope.boundedScope(10));\n+        addDefaultMapping(FunctionDescriptor.class, FunctionDescriptor.ofVoid());\n+        addDefaultMapping(CLinker.class, CLinker.getInstance());\n+        addDefaultMapping(CLinker.VaList.class, VaListHelper.vaList);\n+        addDefaultMapping(CLinker.VaList.Builder.class, VaListHelper.vaListBuilder);\n+    }\n+\n+    static class VaListHelper {\n+        static final CLinker.VaList vaList;\n+        static final CLinker.VaList.Builder vaListBuilder;\n+\n+        static {\n+            AtomicReference<CLinker.VaList.Builder> builderRef = new AtomicReference<>();\n+            vaList = CLinker.VaList.make(b -> {\n+                builderRef.set(b);\n+                b.vargFromLong(CLinker.C_LONG_LONG, 42L);\n+            });\n+            vaListBuilder = builderRef.get();\n+        }\n+    }\n+\n+    static final Map<Class<?>, Object[]> REPLACEMENT_VALUES = new HashMap<>();\n+\n+    @SafeVarargs\n+    static <Z> void addReplacements(Class<Z> carrier, Z... value) {\n+        REPLACEMENT_VALUES.put(carrier, value);\n+    }\n+\n+    static {\n+        addReplacements(Collection.class, null, Stream.of(new Object[] { null }).collect(Collectors.toList()));\n+        addReplacements(List.class, null, Stream.of(new Object[] { null }).collect(Collectors.toList()));\n+        addReplacements(Set.class, null, Stream.of(new Object[] { null }).collect(Collectors.toSet()));\n+    }\n+\n+    @Test(dataProvider = \"cases\")\n+    public void testNulls(String testName, @NoInjection Method meth, Object receiver, Object[] args) {\n+        try {\n+            meth.invoke(receiver, args);\n+            fail(\"Method invocation completed normally\");\n+        } catch (InvocationTargetException ex) {\n+            Class<?> cause = ex.getCause().getClass();\n+            assertEquals(cause, NullPointerException.class, \"got \" + cause.getName() + \" - expected NullPointerException\");\n+        } catch (Throwable ex) {\n+            fail(\"Unexpected exception: \" + ex);\n+        }\n+    }\n+\n+    @DataProvider(name = \"cases\")\n+    static Iterator<Object[]> cases() {\n+        List<Object[]> cases = new ArrayList<>();\n+        for (Class<?> clazz : CLASSES) {\n+            for (Method m : clazz.getMethods()) {\n+                if (OBJECT_METHODS.contains(m.getName())) continue;\n+                boolean isStatic = (m.getModifiers() & Modifier.STATIC) != 0;\n+                List<Integer> refIndices = new ArrayList<>();\n+                for (int i = 0; i < m.getParameterCount(); i++) {\n+                    Class<?> param = m.getParameterTypes()[i];\n+                    if (!param.isPrimitive()) {\n+                        refIndices.add(i);\n+                    }\n+                }\n+                for (int i : refIndices) {\n+                    Object[] replacements = replacements(m.getParameterTypes()[i]);\n+                    for (int r = 0 ; r < replacements.length ; r++) {\n+                        String testName = clazz.getName() + \"\/\" + shortSig(m) + \"\/\" + i + \"\/\" + r;\n+                        if (EXCLUDE_LIST.contains(testName)) continue;\n+                        Object[] args = new Object[m.getParameterCount()];\n+                        for (int j = 0; j < args.length; j++) {\n+                            args[j] = defaultValue(m.getParameterTypes()[j]);\n+                        }\n+                        args[i] = replacements[r];\n+                        Object receiver = isStatic ? null : defaultValue(clazz);\n+                        cases.add(new Object[]{testName, m, receiver, args});\n+                    }\n+                }\n+            }\n+        }\n+        return cases.iterator();\n+    };\n+\n+    static String shortSig(Method m) {\n+        StringJoiner sj = new StringJoiner(\",\", m.getName() + \"(\", \")\");\n+        for (Class<?> parameterType : m.getParameterTypes()) {\n+            sj.add(parameterType.getTypeName());\n+        }\n+        return sj.toString();\n+    }\n+\n+    static Object defaultValue(Class<?> carrier) {\n+        if (carrier.isArray()) {\n+            return Array.newInstance(carrier.componentType(), 0);\n+        }\n+        Object value = DEFAULT_VALUES.get(carrier);\n+        if (value == null) {\n+            throw new UnsupportedOperationException(carrier.getName());\n+        }\n+        return value;\n+    }\n+\n+    static Object[] replacements(Class<?> carrier) {\n+        if (carrier.isArray() && !carrier.getComponentType().isPrimitive()) {\n+            Object arr = Array.newInstance(carrier.componentType(), 1);\n+            Array.set(arr, 0, null);\n+            return new Object[] { null, arr };\n+        }\n+        return REPLACEMENT_VALUES.getOrDefault(carrier, new Object[] { null });\n+    }\n+}\n","filename":"test\/jdk\/java\/foreign\/TestNulls.java","additions":255,"deletions":0,"binary":false,"changes":255,"status":"added"},{"patch":"@@ -55,6 +55,0 @@\n-    @Test(expectedExceptions = NullPointerException.class)\n-    public void testNullReshape() {\n-        SequenceLayout seq = MemoryLayout.ofSequence(4, MemoryLayouts.JAVA_INT);\n-        seq.reshape(null);\n-    }\n-\n","filename":"test\/jdk\/java\/foreign\/TestReshape.java","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import jdk.incubator.foreign.MappedMemorySegments;\n@@ -35,0 +36,2 @@\n+import java.io.File;\n+import java.io.IOException;\n@@ -41,0 +44,2 @@\n+import java.nio.channels.FileChannel;\n+import java.nio.file.Path;\n","filename":"test\/jdk\/java\/foreign\/TestSegments.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -49,0 +49,3 @@\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.util.Arrays;\n@@ -64,3 +67,1 @@\n-import static org.testng.Assert.assertEquals;\n-import static org.testng.Assert.assertFalse;\n-import static org.testng.Assert.assertTrue;\n+import static org.testng.Assert.*;\n@@ -806,1 +807,0 @@\n-\n","filename":"test\/jdk\/java\/foreign\/valist\/VaListTest.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"}]}