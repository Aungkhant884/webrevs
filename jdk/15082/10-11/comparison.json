{"files":[{"patch":"@@ -2427,1 +2427,1 @@\n-    ThreadTotalCPUTimeClosure tttc(_perf_parallel_worker_threads_cpu_time);\n+    ThreadTotalCPUTimeClosure tttc(_perf_parallel_worker_threads_cpu_time, _total_cpu_time_diff);\n@@ -2433,0 +2433,2 @@\n+\n+  _total_cpu_time->inc(Atomic::load(_total_cpu_time_diff));\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -470,1 +470,1 @@\n-        PerfDataManager::create_counter(SUN_THREADS, \"g1_conc_mark_thread.cpu_time\",\n+        PerfDataManager::create_counter(SUN_THREADS_GCCPU, \"g1_conc_mark\",\n@@ -2094,1 +2094,1 @@\n-  ThreadTotalCPUTimeClosure tttc(_g1_concurrent_mark_threads_cpu_time);\n+  ThreadTotalCPUTimeClosure tttc(_g1_concurrent_mark_threads_cpu_time, _total_cpu_time_diff);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -119,1 +119,1 @@\n-        PerfDataManager::create_counter(SUN_THREADS, \"g1_conc_refine_thread.cpu_time\",\n+        PerfDataManager::create_counter(SUN_THREADS_GCCPU, \"g1_conc_refine\",\n@@ -172,1 +172,1 @@\n-  ThreadTotalCPUTimeClosure tttc(_g1_concurrent_refine_threads_cpu_time);\n+  ThreadTotalCPUTimeClosure tttc(_g1_concurrent_refine_threads_cpu_time, _total_cpu_time_diff);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentRefine.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -895,1 +895,1 @@\n-  ThreadTotalCPUTimeClosure tttc(_perf_parallel_worker_threads_cpu_time);\n+  ThreadTotalCPUTimeClosure tttc(_perf_parallel_worker_threads_cpu_time, _total_cpu_time_diff);\n","filename":"src\/hotspot\/share\/gc\/parallel\/parallelScavengeHeap.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -278,0 +278,3 @@\n+    _total_cpu_time =\n+                PerfDataManager::create_counter(SUN_THREADS, \"gc_cpu_time\",\n+                                                PerfData::U_Ticks, CHECK);\n@@ -279,1 +282,1 @@\n-                PerfDataManager::create_counter(SUN_THREADS, \"par_gc_thread.cpu_time\",\n+                PerfDataManager::create_counter(SUN_THREADS_GCCPU, \"parallel_gc_workers\",\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -144,1 +144,10 @@\n-  \/\/ Perf counters for CPU time of parallel GC threads. Defined here in order to\n+  \/\/ Perf counter to track total CPU time across all threads. Defined here in\n+  \/\/ order to be reused for all collectors.\n+  PerfCounter* _total_cpu_time;\n+\n+  \/\/ A jlong to atomically track how much CPU time has been spent doing GC.\n+  \/\/ It is incremented using Atomic::add() to prevent race conditions, and\n+  \/\/ is added to `_total_cpu_time` at the end of GC.\n+  volatile jlong* _total_cpu_time_diff;\n+\n+  \/\/ Perf counter for CPU time of parallel GC threads. Defined here in order to\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.hpp","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -71,1 +71,1 @@\n-        PerfDataManager::create_counter(SUN_THREADS, \"conc_dedup_thread.cpu_time\",\n+        PerfDataManager::create_counter(SUN_THREADS_GCCPU, \"conc_dedup\",\n@@ -198,1 +198,1 @@\n-      ThreadTotalCPUTimeClosure tttc(_concurrent_dedup_thread_cpu_time);\n+      ThreadTotalCPUTimeClosure tttc(_concurrent_dedup_thread_cpu_time, _total_cpu_time_diff);\n","filename":"src\/hotspot\/share\/gc\/shared\/stringdedup\/stringDedupProcessor.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -76,0 +76,1 @@\n+  \"sun.threads.gc_cpu_time\",  \/\/ Subsystem for Sun Threads GC CPU\n@@ -536,0 +537,17 @@\n+\n+ThreadTotalCPUTimeClosure::~ThreadTotalCPUTimeClosure() {\n+    jlong net_cpu_time = _total - _counter->get_value();\n+    _counter->inc(net_cpu_time);\n+    if (_total_cpu_counter) {\n+      Atomic::add(_total_cpu_counter, net_cpu_time);\n+    }\n+}\n+\n+void ThreadTotalCPUTimeClosure::do_thread(Thread* thread) {\n+    \/\/ The default code path (fast_thread_cpu_time()) asserts that\n+    \/\/ pthread_getcpuclockid() and clock_gettime() must return 0. Thus caller\n+    \/\/ must ensure the thread exists and has not terminated.\n+    assert(os::is_thread_cpu_time_supported(), \"os must support cpu time\");\n+    _total += os::thread_cpu_time(thread);\n+}\n+\n","filename":"src\/hotspot\/share\/runtime\/perfData.cpp","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -64,0 +64,1 @@\n+  SUN_THREADS_GCCPU,    \/\/ Subsystem for Sun Threads GC CPU\n@@ -869,0 +870,20 @@\n+\/\/ Class to compute the total CPU time for a set of threads, then update an\n+\/\/ hsperfdata counter.\n+class ThreadTotalCPUTimeClosure: public ThreadClosure {\n+ private:\n+  jlong _total;\n+  PerfCounter* _counter;\n+  volatile jlong* _total_cpu_time;\n+\n+ public:\n+  ThreadTotalCPUTimeClosure(PerfCounter* counter) :\n+      _total(0), _counter(counter), _total_cpu_time(nullptr) {}\n+  \n+  ThreadTotalCPUTimeClosure(PerfCounter* counter, volatile jlong* total_cpu_counter) :\n+      _total(0), _counter(counter), _total_cpu_time(total_cpu_counter) {}\n+\n+  ~ThreadTotalCPUTimeClosure();\n+\n+  virtual void do_thread(Thread* thread);\n+};\n+\n","filename":"src\/hotspot\/share\/runtime\/perfData.hpp","additions":21,"deletions":0,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -661,24 +661,0 @@\n-\/\/ Class to compute the total CPU time for a set of threads, then update an\n-\/\/ hsperfdata counter.\n-class ThreadTotalCPUTimeClosure: public ThreadClosure {\n- private:\n-  jlong _total;\n-  PerfCounter* _counter;\n-\n- public:\n-  ThreadTotalCPUTimeClosure(PerfCounter* counter) :\n-      _total(0), _counter(counter) {}\n-\n-  ~ThreadTotalCPUTimeClosure() {\n-    _counter->inc(_total - _counter->get_value());\n-  }\n-\n-  virtual void do_thread(Thread* thread) {\n-    \/\/ The default code path (fast_thread_cpu_time()) asserts that\n-    \/\/ pthread_getcpuclockid() and clock_gettime() must return 0. Thus caller\n-    \/\/ must ensure the thread exists and has not terminated.\n-    assert(os::is_thread_cpu_time_supported(), \"os must support cpu time\");\n-    _total += os::thread_cpu_time(thread);\n-  }\n-};\n-\n","filename":"src\/hotspot\/share\/runtime\/thread.hpp","additions":0,"deletions":24,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -141,1 +141,1 @@\n-                 PerfDataManager::create_counter(SUN_THREADS, \"vm_thread.cpu_time\",\n+                 PerfDataManager::create_counter(SUN_THREADS_GCCPU, \"vm\",\n","filename":"src\/hotspot\/share\/runtime\/vmThread.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}