{"files":[{"patch":"@@ -63,0 +63,6 @@\n+        \/\/ Use a handful of threads to inflate the monitors, to eat the cost of\n+        \/\/ wait(1) calls. This can be larger than available parallelism, since threads\n+        \/\/ would be time-waiting.\n+        private static final int THREADS = 16;\n+\n+        private static Thread[] threads;\n@@ -68,10 +74,22 @@\n-            for (int i = 0; i < MONITORS; i++) {\n-                Object o = new Object();\n-                synchronized (o) {\n-                    \/\/ Object is locked. In current Hotspot, the request for hashcode\n-                    \/\/ would inflate the monitor. While this relies on implementation\n-                    \/\/ detail, this is significantly quicker than doing wait(1), which\n-                    \/\/ might stall for tens of milliseconds.\n-                    sink += o.hashCode();\n-                }\n-                monitors[i] = o;\n+            threads = new Thread[THREADS];\n+\n+            for (int t = 0; t < THREADS; t++) {\n+                int monStart = t * MONITORS \/ THREADS;\n+                int monEnd = (t + 1) * MONITORS \/ THREADS;\n+                threads[t] = new Thread(() -> {\n+                    for (int m = monStart; m < monEnd; m++) {\n+                        Object o = new Object();\n+                        synchronized (o) {\n+                            try {\n+                                o.wait(1);\n+                            } catch (InterruptedException e) {\n+                            }\n+                        }\n+                        monitors[m] = o;\n+                    }\n+                });\n+                threads[t].start();\n+            }\n+\n+            for (Thread t : threads) {\n+                t.join();\n","filename":"test\/hotspot\/jtreg\/runtime\/Monitor\/GuaranteedAsyncDeflationIntervalTest.java","additions":28,"deletions":10,"binary":false,"changes":38,"status":"modified"}]}