{"files":[{"patch":"@@ -2437,0 +2437,8 @@\n+    case Op_PopCountI:\n+    case Op_PopCountL:\n+    case Op_PopCountVI:\n+    case Op_PopCountVL:\n+      if (!UsePopCountInstruction) {\n+        ret_value = false;\n+      }\n+      break;\n@@ -2478,0 +2486,3 @@\n+    case Op_CompressV:\n+    case Op_CompressM:\n+    case Op_ExpandV:\n@@ -8651,1 +8662,0 @@\n-  predicate(UsePopCountInstruction);\n@@ -8662,0 +8672,1 @@\n+    assert(UsePopCountInstruction, \"unsupported\");\n@@ -8673,1 +8684,0 @@\n-  predicate(UsePopCountInstruction);\n@@ -8683,0 +8693,1 @@\n+    assert(UsePopCountInstruction, \"unsupported\");\n@@ -8696,1 +8707,0 @@\n-  predicate(UsePopCountInstruction);\n@@ -8706,0 +8716,1 @@\n+    assert(UsePopCountInstruction, \"unsupported\");\n@@ -8716,1 +8727,0 @@\n-  predicate(UsePopCountInstruction);\n@@ -8726,0 +8736,1 @@\n+    assert(UsePopCountInstruction, \"unsupported\");\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":15,"deletions":4,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -5686,2 +5686,2 @@\n-instruct vpopcount4I(vecX dst, vecX src) %{\n-  predicate(UsePopCountInstruction && n->as_Vector()->length() == 4);\n+instruct vpopcountID(vecD dst, vecD src) %{\n+  predicate(n->as_Vector()->length_in_bytes() < 16);\n@@ -5689,4 +5689,37 @@\n-  format %{\n-    \"cnt     $dst, $src\\t# vector (16B)\\n\\t\"\n-    \"uaddlp  $dst, $dst\\t# vector (16B)\\n\\t\"\n-    \"uaddlp  $dst, $dst\\t# vector (8H)\"\n+  ins_cost(3 * INSN_COST);\n+  format %{ \"vpopcountI  $dst, $src\\t# vector (8B\/4H\/2S)\" %}\n+  ins_encode %{\n+    assert(UsePopCountInstruction, \"unsupported\");\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ cnt(as_FloatRegister($dst$$reg), __ T8B,\n+           as_FloatRegister($src$$reg));\n+    if (bt == T_SHORT || bt == T_INT) {\n+      __ uaddlp(as_FloatRegister($dst$$reg), __ T8B,\n+                as_FloatRegister($dst$$reg));\n+      if (bt == T_INT) {\n+        __ uaddlp(as_FloatRegister($dst$$reg), __ T4H,\n+                  as_FloatRegister($dst$$reg));\n+      }\n+    }\n+  %}\n+  ins_pipe(pipe_class_default);\n+%}\n+\n+instruct vpopcountIX(vecX dst, vecX src) %{\n+  predicate(n->as_Vector()->length_in_bytes() == 16);\n+  match(Set dst (PopCountVI src));\n+  ins_cost(3 * INSN_COST);\n+  format %{ \"vpopcountI  $dst, $src\\t# vector (16B\/8H\/4S)\" %}\n+  ins_encode %{\n+    assert(UsePopCountInstruction, \"unsupported\");\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ cnt(as_FloatRegister($dst$$reg), __ T16B,\n+           as_FloatRegister($src$$reg));\n+    if (bt == T_SHORT || bt == T_INT) {\n+      __ uaddlp(as_FloatRegister($dst$$reg), __ T16B,\n+                as_FloatRegister($dst$$reg));\n+      if (bt == T_INT) {\n+        __ uaddlp(as_FloatRegister($dst$$reg), __ T8H,\n+                  as_FloatRegister($dst$$reg));\n+      }\n+    }\n@@ -5694,0 +5727,13 @@\n+  ins_pipe(pipe_class_default);\n+%}\n+\n+\/\/ If the PopCountVL is generated by auto-vectorization, the dst basic\n+\/\/ type is T_INT. And once we have unified the type definition for\n+\/\/ Vector API and auto-vectorization, this rule can be merged with\n+\/\/ \"vpopcountLX\" rule.\n+instruct vpopcountLD(vecD dst, vecX src) %{\n+  predicate(n->as_Vector()->length_in_bytes() < 16 &&\n+            n->bottom_type()->is_vect()->element_basic_type() == T_INT);\n+  match(Set dst (PopCountVL src));\n+  ins_cost(5 * INSN_COST);\n+  format %{ \"vpopcountL  $dst, $src\\t# vector (2S)\" %}\n@@ -5695,0 +5741,1 @@\n+    assert(UsePopCountInstruction, \"unsupported\");\n@@ -5701,0 +5748,4 @@\n+    __ uaddlp(as_FloatRegister($dst$$reg), __ T4S,\n+              as_FloatRegister($dst$$reg));\n+    __ xtn(as_FloatRegister($dst$$reg), __ T2S,\n+           as_FloatRegister($dst$$reg), __ T2D);\n@@ -5705,8 +5756,6 @@\n-instruct vpopcount2I(vecD dst, vecD src) %{\n-  predicate(UsePopCountInstruction && n->as_Vector()->length() == 2);\n-  match(Set dst (PopCountVI src));\n-  format %{\n-    \"cnt     $dst, $src\\t# vector (8B)\\n\\t\"\n-    \"uaddlp  $dst, $dst\\t# vector (8B)\\n\\t\"\n-    \"uaddlp  $dst, $dst\\t# vector (4H)\"\n-  %}\n+instruct vpopcountLX(vecX dst, vecX src) %{\n+  predicate(n->as_Vector()->length_in_bytes() == 16 &&\n+            n->bottom_type()->is_vect()->element_basic_type() == T_LONG);\n+  match(Set dst (PopCountVL src));\n+  ins_cost(4 * INSN_COST);\n+  format %{ \"vpopcountL  $dst, $src\\t# vector (2D)\" %}\n@@ -5714,1 +5763,2 @@\n-    __ cnt(as_FloatRegister($dst$$reg), __ T8B,\n+    assert(UsePopCountInstruction, \"unsupported\");\n+    __ cnt(as_FloatRegister($dst$$reg), __ T16B,\n@@ -5716,1 +5766,3 @@\n-    __ uaddlp(as_FloatRegister($dst$$reg), __ T8B,\n+    __ uaddlp(as_FloatRegister($dst$$reg), __ T16B,\n+              as_FloatRegister($dst$$reg));\n+    __ uaddlp(as_FloatRegister($dst$$reg), __ T8H,\n@@ -5718,1 +5770,1 @@\n-    __ uaddlp(as_FloatRegister($dst$$reg), __ T4H,\n+    __ uaddlp(as_FloatRegister($dst$$reg), __ T4S,\n@@ -5924,0 +5976,128 @@\n+\n+\/\/------------------------- CountLeadingZerosV -----------------------------\n+\n+instruct countLeadingZerosVD(vecD dst, vecD src) %{\n+  predicate(n->as_Vector()->length_in_bytes() == 8);\n+  match(Set dst (CountLeadingZerosV src));\n+  ins_cost(INSN_COST);\n+  format %{ \"countLeadingZerosV $dst, $src\\t# vector (8B\/4H\/2S)\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    Assembler::SIMD_Arrangement size = __ esize2arrangement((unsigned)type2aelembytes(bt), false);\n+    __ clz(as_FloatRegister($dst$$reg), size, as_FloatRegister($src$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct countLeadingZerosVX(vecX dst, vecX src) %{\n+  predicate(n->as_Vector()->length_in_bytes() == 16);\n+  match(Set dst (CountLeadingZerosV src));\n+  ins_cost(INSN_COST);\n+  format %{ \"countLeadingZerosV $dst, $src\\t# vector (16B\/8H\/4S\/2D)\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    Assembler::SIMD_Arrangement size = __ esize2arrangement((unsigned)type2aelembytes(bt), true);\n+    if (bt != T_LONG) {\n+      __ clz(as_FloatRegister($dst$$reg), size, as_FloatRegister($src$$reg));\n+    } else {\n+      __ umov(rscratch1, as_FloatRegister($src$$reg), __ D, 0);\n+      __ clz(rscratch1, rscratch1);\n+      __ mov(as_FloatRegister($dst$$reg), __ D, 0, rscratch1);\n+      __ umov(rscratch1, as_FloatRegister($src$$reg), __ D, 1);\n+      __ clz(rscratch1, rscratch1);\n+      __ mov(as_FloatRegister($dst$$reg), __ D, 1, rscratch1);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/------------------------- CountTrailingZerosV ----------------------------\n+\n+instruct countTrailingZerosVD(vecD dst, vecD src) %{\n+  predicate(n->as_Vector()->length_in_bytes() == 8);\n+  match(Set dst (CountTrailingZerosV src));\n+  ins_cost(3 * INSN_COST);\n+  format %{ \"countTrailingZerosV $dst, $src\\t# vector (8B\/4H\/2S)\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    Assembler::SIMD_Arrangement size = __ esize2arrangement((unsigned)type2aelembytes(bt), false);\n+    __ neon_reverse_bits(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), bt, false);\n+    __ clz(as_FloatRegister($dst$$reg), size, as_FloatRegister($dst$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct countTrailingZerosVX(vecX dst, vecX src) %{\n+  predicate(n->as_Vector()->length_in_bytes() == 16);\n+  match(Set dst (CountTrailingZerosV src));\n+  ins_cost(3 * INSN_COST);\n+  format %{ \"countTrailingZerosV $dst, $src\\t# vector (16B\/8H\/4S\/2D)\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    Assembler::SIMD_Arrangement size = __ esize2arrangement((unsigned)type2aelembytes(bt), true);\n+    __ neon_reverse_bits(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), bt, true);\n+    if (bt != T_LONG) {\n+      __ clz(as_FloatRegister($dst$$reg), size, as_FloatRegister($dst$$reg));\n+    } else {\n+      __ umov(rscratch1, as_FloatRegister($dst$$reg), __ D, 0);\n+      __ clz(rscratch1, rscratch1);\n+      __ mov(as_FloatRegister($dst$$reg), __ D, 0, rscratch1);\n+      __ umov(rscratch1, as_FloatRegister($dst$$reg), __ D, 1);\n+      __ clz(rscratch1, rscratch1);\n+      __ mov(as_FloatRegister($dst$$reg), __ D, 1, rscratch1);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/------------------------------ ReverseV -----------------------------------\n+\n+instruct vreverseD(vecD dst, vecD src) %{\n+  predicate(n->as_Vector()->length_in_bytes() == 8);\n+  match(Set dst (ReverseV src));\n+  ins_cost(2 * INSN_COST);\n+  format %{ \"ReverseV $dst, $src\\t# vector (D)\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ neon_reverse_bits(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), bt, false);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vreverseX(vecX dst, vecX src) %{\n+  predicate(n->as_Vector()->length_in_bytes() == 16);\n+  match(Set dst (ReverseV src));\n+  ins_cost(2 * INSN_COST);\n+  format %{ \"ReverseV $dst, $src\\t# vector (X)\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ neon_reverse_bits(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), bt, true);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/---------------------------- ReverseBytesV --------------------------------\n+\n+instruct vreverseBytesD(vecD dst, vecD src) %{\n+  predicate(n->as_Vector()->length_in_bytes() == 8);\n+  match(Set dst (ReverseBytesV src));\n+  ins_cost(INSN_COST);\n+  format %{ \"ReverseBytesV $dst, $src\\t# vector (D)\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ neon_reverse_bytes(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), bt, false);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vreverseBytesX(vecX dst, vecX src) %{\n+  predicate(n->as_Vector()->length_in_bytes() == 16);\n+  match(Set dst (ReverseBytesV src));\n+  ins_cost(INSN_COST);\n+  format %{ \"ReverseBytesV $dst, $src\\t# vector (X)\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ neon_reverse_bytes(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), bt, true);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_neon.ad","additions":197,"deletions":17,"binary":false,"changes":214,"status":"modified"},{"patch":"@@ -2448,13 +2448,21 @@\n-define(`VPOPCOUNT', `\n-instruct vpopcount$1$2`'(vec$5 dst, vec$5 src) %{\n-  predicate(UsePopCountInstruction && n->as_Vector()->length() == $1);\n-  match(Set dst (PopCountVI src));\n-  format %{\n-    \"cnt     $dst, $src\\t# vector ($3B)\\n\\t\"\n-    \"uaddlp  $dst, $dst\\t# vector ($3B)\\n\\t\"\n-    \"uaddlp  $dst, $dst\\t# vector ($4H)\"\n-  %}\n-  ins_encode %{\n-    __ cnt(as_FloatRegister($dst$$reg), __ T$3B,\n-           as_FloatRegister($src$$reg));\n-    __ uaddlp(as_FloatRegister($dst$$reg), __ T$3B,\n+define(`VPOPCOUNT', `dnl\n+ifelse($1$2, `LD', `\n+\/\/ If the PopCountVL is generated by auto-vectorization, the dst basic\n+\/\/ type is T_INT. And once we have unified the type definition for\n+\/\/ Vector API and auto-vectorization, this rule can be merged with\n+\/\/ \"vpopcountLX\" rule.', `')\n+instruct vpopcount$1$2`'(vec$2 dst, vec$3 src) %{\n+  predicate(n->as_Vector()->length_in_bytes() $4 16`'ifelse($1$2, `LD', ` &&\n+            n->bottom_type()->is_vect()->element_basic_type() == T_INT', $1$2, `LX', ` &&\n+            n->bottom_type()->is_vect()->element_basic_type() == T_LONG', `'));\n+  match(Set dst (PopCountV$1 src));\n+  ins_cost($5 * INSN_COST);\n+  format %{ \"vpopcount$1  $dst, $src\\t# vector ($6)\" %}\n+  ins_encode %{\n+    assert(UsePopCountInstruction, \"unsupported\");dnl\n+ifelse($1, `I', `\n+    BasicType bt = Matcher::vector_element_basic_type(this);', `')\n+    __ cnt(as_FloatRegister($dst$$reg), __ T`'ifelse($3, D, 8, 16)B,\n+           as_FloatRegister($src$$reg));dnl\n+ifelse($1, `L', `\n+    __ uaddlp(as_FloatRegister($dst$$reg), __ T16B,\n@@ -2462,1 +2470,1 @@\n-    __ uaddlp(as_FloatRegister($dst$$reg), __ T$4H,\n+    __ uaddlp(as_FloatRegister($dst$$reg), __ T8H,\n@@ -2464,0 +2472,13 @@\n+    __ uaddlp(as_FloatRegister($dst$$reg), __ T4S,\n+              as_FloatRegister($dst$$reg));', `\n+    if (bt == T_SHORT || bt == T_INT) {\n+      __ uaddlp(as_FloatRegister($dst$$reg), __ T`'ifelse($2, D, 8, 16)B,\n+                as_FloatRegister($dst$$reg));\n+      if (bt == T_INT) {\n+        __ uaddlp(as_FloatRegister($dst$$reg), __ T`'ifelse($2, D, 4, 8)H,\n+                  as_FloatRegister($dst$$reg));\n+      }\n+    }')dnl\n+ifelse($1$2, `LD', `\n+    __ xtn(as_FloatRegister($dst$$reg), __ T2S,\n+           as_FloatRegister($dst$$reg), __ T2D);', `')\n@@ -2467,3 +2488,5 @@\n-dnl       $1 $2 $3  $4 $5\n-VPOPCOUNT(4, I, 16, 8, X)\n-VPOPCOUNT(2, I, 8,  4, D)\n+dnl       $1 $2 $3 $4  $5 $6\n+VPOPCOUNT(I, D, D, <,  3, 8B\/4H\/2S)\n+VPOPCOUNT(I, X, X, ==, 3, 16B\/8H\/4S)\n+VPOPCOUNT(L, D, X, <,  5, 2S)\n+VPOPCOUNT(L, X, X, ==, 4, 2D)\n@@ -2650,0 +2673,78 @@\n+\n+dnl\n+dnl CLTZ_D($1     )\n+dnl CLTZ_D(op_name)\n+define(`CLTZ_D', `\n+instruct count$1D(vecD dst, vecD src) %{\n+  predicate(n->as_Vector()->length_in_bytes() == 8);\n+  match(Set dst (Count$1 src));\n+  ins_cost(ifelse($1, `TrailingZerosV', `3 * ', `')INSN_COST);\n+  format %{ \"count$1 $dst, $src\\t# vector (8B\/4H\/2S)\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    Assembler::SIMD_Arrangement size = __ esize2arrangement((unsigned)type2aelembytes(bt), false);dnl\n+ifelse($1, `TrailingZerosV', `\n+    __ neon_reverse_bits(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), bt, false);', `')\n+    __ clz(as_FloatRegister($dst$$reg), size, as_FloatRegister($ifelse($1, `TrailingZerosV', dst, src)$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+dnl CLTZ_X($1     )\n+dnl CLTZ_X(op_name)\n+define(`CLTZ_X', `\n+instruct count$1X(vecX dst, vecX src) %{\n+  predicate(n->as_Vector()->length_in_bytes() == 16);\n+  match(Set dst (Count$1 src));\n+  ins_cost(ifelse($1, `TrailingZerosV', `3 * ', `')INSN_COST);\n+  format %{ \"count$1 $dst, $src\\t# vector (16B\/8H\/4S\/2D)\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    Assembler::SIMD_Arrangement size = __ esize2arrangement((unsigned)type2aelembytes(bt), true);dnl\n+ifelse($1, `TrailingZerosV', `\n+    __ neon_reverse_bits(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), bt, true);', `')\n+    if (bt != T_LONG) {\n+      __ clz(as_FloatRegister($dst$$reg), size, as_FloatRegister($ifelse($1, `TrailingZerosV', dst, src)$$reg));\n+    } else {\n+      __ umov(rscratch1, as_FloatRegister($ifelse($1, `TrailingZerosV', dst, src)$$reg), __ D, 0);\n+      __ clz(rscratch1, rscratch1);\n+      __ mov(as_FloatRegister($dst$$reg), __ D, 0, rscratch1);\n+      __ umov(rscratch1, as_FloatRegister($ifelse($1, `TrailingZerosV', dst, src)$$reg), __ D, 1);\n+      __ clz(rscratch1, rscratch1);\n+      __ mov(as_FloatRegister($dst$$reg), __ D, 1, rscratch1);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+\/\/------------------------- CountLeadingZerosV -----------------------------\n+CLTZ_D(LeadingZerosV)\n+CLTZ_X(LeadingZerosV)\n+\n+\/\/------------------------- CountTrailingZerosV ----------------------------\n+CLTZ_D(TrailingZerosV)\n+CLTZ_X(TrailingZerosV)\n+\n+dnl\n+dnl REVERSE($1,        $2,      $3,   $4  )\n+dnl REVERSE(insn_name, op_name, type, insn)\n+define(`REVERSE', `\n+instruct $1(vec$3 dst, vec$3 src) %{\n+  predicate(n->as_Vector()->length_in_bytes() == ifelse($3, D, 8, 16));\n+  match(Set dst ($2 src));\n+  ins_cost(ifelse($2, `ReverseV', `2 * ', `')INSN_COST);\n+  format %{ \"$2 $dst, $src\\t# vector ($3)\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ $4(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), bt, ifelse($3, D, false, true));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+\/\/------------------------------ ReverseV -----------------------------------\n+REVERSE(vreverseD, ReverseV, D, neon_reverse_bits)\n+REVERSE(vreverseX, ReverseV, X, neon_reverse_bits)\n+\n+\/\/---------------------------- ReverseBytesV --------------------------------\n+REVERSE(vreverseBytesD, ReverseBytesV, D, neon_reverse_bytes)\n+REVERSE(vreverseBytesX, ReverseBytesV, X, neon_reverse_bytes)\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_neon_ad.m4","additions":118,"deletions":17,"binary":false,"changes":135,"status":"modified"},{"patch":"@@ -152,0 +152,2 @@\n+      case Op_ExpandV:\n+        if (UseSVE < 2 || is_subword_type(bt)) return false;\n@@ -2200,1 +2202,1 @@\n-\/\/ popcount vector\n+\/\/ vector popcount\n@@ -2203,1 +2205,2 @@\n-  predicate(UseSVE > 0);\n+  predicate(UseSVE > 0 &&\n+            !n->as_Vector()->is_predicated_vector());\n@@ -2205,1 +2208,40 @@\n-  format %{ \"sve_cnt $dst, $src\\t# vector (sve) (S)\\n\\t\" %}\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_cnt $dst, $src\\t# vector (sve) (B\/H\/S)\" %}\n+  ins_encode %{\n+    assert(UsePopCountInstruction, \"unsupported\");\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ sve_cnt(as_FloatRegister($dst$$reg), __ elemType_to_regVariant(bt),\n+         ptrue, as_FloatRegister($src$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vpopcountL(vReg dst, vReg src) %{\n+  predicate(UseSVE > 0 &&\n+            !n->as_Vector()->is_predicated_vector() &&\n+            n->bottom_type()->is_vect()->element_basic_type() == T_LONG);\n+  match(Set dst (PopCountVL src));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_cnt $dst, $src\\t# vector (sve) (D)\" %}\n+  ins_encode %{\n+    assert(UsePopCountInstruction, \"unsupported\");\n+    __ sve_cnt(as_FloatRegister($dst$$reg), __ D,\n+         ptrue, as_FloatRegister($src$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ If the PopCountVL is generated by auto-vectorization, the dst basic\n+\/\/ type is T_INT. And once we have unified the type definition for\n+\/\/ Vector API and auto-vectorization, this rule can be merged with\n+\/\/ \"vpopcountL\" rule.\n+instruct vpopcountLI(vReg dst, vReg src, vReg vtmp) %{\n+  predicate(UseSVE > 0 &&\n+            !n->as_Vector()->is_predicated_vector() &&\n+            n->bottom_type()->is_vect()->element_basic_type() == T_INT);\n+  match(Set dst (PopCountVL src));\n+  effect(TEMP_DEF dst, TEMP vtmp);\n+  ins_cost(3 * SVE_COST);\n+  format %{ \"sve_cnt $dst, $src\\n\\t\"\n+            \"sve_dup $vtmp, #0\\n\\t\"\n+            \"sve_uzp1 $dst, $dst, $vtmp\\t# vector (sve) (S)\" %}\n@@ -2207,1 +2249,35 @@\n-     __ sve_cnt(as_FloatRegister($dst$$reg), __ S, ptrue, as_FloatRegister($src$$reg));\n+    assert(UsePopCountInstruction, \"unsupported\");\n+    __ sve_cnt(as_FloatRegister($dst$$reg), __ D,\n+         ptrue, as_FloatRegister($src$$reg));\n+    __ sve_vector_narrow(as_FloatRegister($dst$$reg), __ S,\n+         as_FloatRegister($dst$$reg), __ D, as_FloatRegister($vtmp$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector popcount - predicated\n+\n+instruct vpopcountI_masked(vReg dst_src, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src (PopCountVI dst_src pg));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_cnt $dst_src, $pg, $dst_src\\t# vector (sve) (B\/H\/S)\" %}\n+  ins_encode %{\n+    assert(UsePopCountInstruction, \"unsupported\");\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ sve_cnt(as_FloatRegister($dst_src$$reg), __ elemType_to_regVariant(bt),\n+         as_PRegister($pg$$reg), as_FloatRegister($dst_src$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vpopcountL_masked(vReg dst_src, pRegGov pg) %{\n+  predicate(UseSVE > 0 &&\n+            n->bottom_type()->is_vect()->element_basic_type() == T_LONG);\n+  match(Set dst_src (PopCountVL dst_src pg));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_cnt $dst_src, $pg, $dst_src\\t# vector (sve) (D)\" %}\n+  ins_encode %{\n+    assert(UsePopCountInstruction, \"unsupported\");\n+    __ sve_cnt(as_FloatRegister($dst_src$$reg), __ D,\n+         as_PRegister($pg$$reg), as_FloatRegister($dst_src$$reg));\n@@ -5668,0 +5744,98 @@\n+\/\/ ---------------------------- Compress\/Expand Operations ---------------------------\n+\n+instruct mcompress(pReg dst, pReg pg, rFlagsReg cr) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst (CompressM pg));\n+  effect(KILL cr);\n+  ins_cost(2 * SVE_COST);\n+  format %{ \"sve_cntp rscratch1, $pg\\n\\t\"\n+            \"sve_whilelo $dst, zr, rscratch1\\t# mask compress (B\/H\/S\/D)\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n+    __ sve_cntp(rscratch1, size, ptrue, as_PRegister($pg$$reg));\n+    __ sve_whilelo(as_PRegister($dst$$reg), size, zr, rscratch1);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vcompress(vReg dst, vReg src, pRegGov pg) %{\n+  predicate(UseSVE > 0 &&\n+            (n->bottom_type()->is_vect()->element_basic_type() == T_INT ||\n+             n->bottom_type()->is_vect()->element_basic_type() == T_FLOAT ||\n+             n->bottom_type()->is_vect()->element_basic_type() == T_LONG ||\n+             n->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE));\n+  match(Set dst (CompressV src pg));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_compact $dst, $src, $pg\\t# vector compress (S\/D)\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n+    __ sve_compact(as_FloatRegister($dst$$reg), size, as_FloatRegister($src$$reg), as_PRegister($pg$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vcompressB(vReg dst, vReg src, pReg pg, vReg vtmp1, vReg vtmp2, vReg vtmp3, vReg vtmp4,\n+                    pReg ptmp, pRegGov pgtmp) %{\n+  predicate(UseSVE > 0 && n->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n+  effect(TEMP_DEF dst, TEMP vtmp1, TEMP vtmp2, TEMP vtmp3, TEMP vtmp4, TEMP ptmp, TEMP pgtmp);\n+  match(Set dst (CompressV src pg));\n+  ins_cost(13 * SVE_COST);\n+  format %{ \"sve_compact $dst, $src, $pg\\t# vector compress (B)\" %}\n+  ins_encode %{\n+    __ sve_compress_byte(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), as_PRegister($pg$$reg),\n+                         as_FloatRegister($vtmp1$$reg),as_FloatRegister($vtmp2$$reg),\n+                         as_FloatRegister($vtmp3$$reg),as_FloatRegister($vtmp4$$reg),\n+                         as_PRegister($ptmp$$reg), as_PRegister($pgtmp$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vcompressS(vReg dst, vReg src, pReg pg, vReg vtmp1, vReg vtmp2, pRegGov pgtmp) %{\n+  predicate(UseSVE > 0 && n->bottom_type()->is_vect()->element_basic_type() == T_SHORT);\n+  effect(TEMP_DEF dst, TEMP vtmp1, TEMP vtmp2, TEMP pgtmp);\n+  match(Set dst (CompressV src pg));\n+  ins_cost(38 * SVE_COST);\n+  format %{ \"sve_compact $dst, $src, $pg\\t# vector compress (H)\" %}\n+  ins_encode %{\n+    __ sve_compress_short(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), as_PRegister($pg$$reg),\n+                          as_FloatRegister($vtmp1$$reg),as_FloatRegister($vtmp2$$reg), as_PRegister($pgtmp$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vexpand(vReg dst, vReg src, pRegGov pg) %{\n+  match(Set dst (ExpandV src pg));\n+  effect(TEMP_DEF dst);\n+  ins_cost(4 * SVE_COST);\n+  format %{ \"sve_dup $dst, S\/D, 0\\n\\t\"\n+            \"sve_histcnt $dst, S\/D, $pg, $dst, $dst\\n\\t\"\n+            \"sve_sub $dst, S\/D, 1\\n\\t\"\n+            \"sve_tbl $dst, S\/D, $src, $dst\\t# vector expand (S\/D)\" %}\n+  ins_encode %{\n+    \/\/ Example input:   src   = 1 2 3 4 5 6 7 8\n+    \/\/                  pg    = 1 0 0 1 1 0 1 1\n+    \/\/ Expected result: dst   = 4 0 0 5 6 0 7 8\n+\n+    \/\/ The basic idea is to use TBL which can shuffle the elements in the given\n+    \/\/ vector flexibly. HISTCNT + SUB is used to generate the second source input\n+    \/\/ for TBL whose value is used to select the indexed element from src vector.\n+\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    assert(UseSVE == 2 && !is_subword_type(bt), \"unsupported\");\n+    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n+    \/\/ dst = 0 0 0 0 0 0 0 0\n+    __ sve_dup(as_FloatRegister($dst$$reg), size, 0);\n+    \/\/ dst = 5 0 0 4 3 0 2 1\n+    __ sve_histcnt(as_FloatRegister($dst$$reg), size, as_PRegister($pg$$reg),\n+                   as_FloatRegister($dst$$reg), as_FloatRegister($dst$$reg));\n+    \/\/ dst = 4 -1 -1 3 2 -1 1 0\n+    __ sve_sub(as_FloatRegister($dst$$reg), size, 1);\n+    \/\/ dst = 4 0 0 5 6 0 7 8\n+    __ sve_tbl(as_FloatRegister($dst$$reg), size, as_FloatRegister($src$$reg),\n+               as_FloatRegister($dst$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -5681,0 +5855,144 @@\n+\n+\/\/ ------------------------------ CountLeadingZerosV ------------------------------\n+\n+instruct vcountLeadingZeros(vReg dst, vReg src) %{\n+  predicate(UseSVE > 0 &&\n+            !n->as_Vector()->is_predicated_vector());\n+  match(Set dst (CountLeadingZerosV src));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_clz $dst, $src\\t# vector (sve)\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n+    __ sve_clz(as_FloatRegister($dst$$reg), size, ptrue, as_FloatRegister($src$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ The dst and src should use the same register to make sure the\n+\/\/ inactive lanes in dst save the same elements as src.\n+instruct vcountLeadingZeros_masked(vReg dst_src, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src (CountLeadingZerosV dst_src pg));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_clz $dst_src, $pg, $dst_src\\t# vector (sve)\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n+    __ sve_clz(as_FloatRegister($dst_src$$reg), size,\n+        as_PRegister($pg$$reg), as_FloatRegister($dst_src$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ------------------------------ CountTrailingZerosV -----------------------------\n+\n+instruct vcountTrailingZeros(vReg dst, vReg src) %{\n+  predicate(UseSVE > 0 &&\n+            !n->as_Vector()->is_predicated_vector());\n+  match(Set dst (CountTrailingZerosV src));\n+  ins_cost(2 * SVE_COST);\n+  format %{ \"sve_rbit $dst, $src\\n\\t\"\n+            \"sve_clz  $dst, $dst\\t# vector (sve)\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n+    __ sve_rbit(as_FloatRegister($dst$$reg), size, ptrue, as_FloatRegister($src$$reg));\n+    __ sve_clz(as_FloatRegister($dst$$reg), size, ptrue, as_FloatRegister($dst$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ The dst and src should use the same register to make sure the\n+\/\/ inactive lanes in dst save the same elements as src.\n+instruct vcountTrailingZeros_masked(vReg dst_src, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src (CountTrailingZerosV dst_src pg));\n+  ins_cost(2 * SVE_COST);\n+  format %{ \"sve_rbit $dst_src, $pg, $dst_src\\n\\t\"\n+            \"sve_clz  $dst_src, $pg, $dst_src\\t# vector (sve)\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n+    __ sve_rbit(as_FloatRegister($dst_src$$reg), size,\n+        as_PRegister($pg$$reg), as_FloatRegister($dst_src$$reg));\n+    __ sve_clz(as_FloatRegister($dst_src$$reg), size,\n+        as_PRegister($pg$$reg), as_FloatRegister($dst_src$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ ---------------------------------- ReverseV ------------------------------------\n+\n+instruct vreverse(vReg dst, vReg src) %{\n+  predicate(UseSVE > 0 &&\n+            !n->as_Vector()->is_predicated_vector());\n+  match(Set dst (ReverseV src));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_rbit $dst, $src\\t# vector (sve)\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n+    __ sve_rbit(as_FloatRegister($dst$$reg), size, ptrue, as_FloatRegister($src$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ The dst and src should use the same register to make sure the\n+\/\/ inactive lanes in dst save the same elements as src.\n+instruct vreverse_masked(vReg dst_src, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src (ReverseV dst_src pg));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_rbit $dst_src, $pg, $dst_src\\t# vector (sve)\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n+    __ sve_rbit(as_FloatRegister($dst_src$$reg), size,\n+        as_PRegister($pg$$reg), as_FloatRegister($dst_src$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ -------------------------------- ReverseBytesV ---------------------------------\n+\n+instruct vreverseBytes(vReg dst, vReg src) %{\n+  predicate(UseSVE > 0 &&\n+            !n->as_Vector()->is_predicated_vector());\n+  match(Set dst (ReverseBytesV src));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_revb $dst, $src\\t# vector (sve)\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n+    if (bt == T_BYTE) {\n+      if (as_FloatRegister($dst$$reg) != as_FloatRegister($src$$reg)) {\n+        __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n+      }\n+    } else {\n+      __ sve_revb(as_FloatRegister($dst$$reg), size, ptrue, as_FloatRegister($src$$reg));\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ The dst and src should use the same register to make sure the\n+\/\/ inactive lanes in dst save the same elements as src.\n+instruct vreverseBytes_masked(vReg dst_src, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src (ReverseBytesV dst_src pg));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_revb $dst_src, $pg, $dst_src\\t# vector (sve)\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n+    if (bt == T_BYTE) {\n+      \/\/ do nothing\n+    } else {\n+      __ sve_revb(as_FloatRegister($dst_src$$reg), size,\n+          as_PRegister($pg$$reg), as_FloatRegister($dst_src$$reg));\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_sve.ad","additions":322,"deletions":4,"binary":false,"changes":326,"status":"modified"},{"patch":"@@ -147,0 +147,2 @@\n+      case Op_ExpandV:\n+        if (UseSVE < 2 || is_subword_type(bt)) return false;\n@@ -1173,1 +1175,24 @@\n-\/\/ popcount vector\n+dnl\n+dnl VPOPCOUNT($1,          $2  )\n+dnl VPOPCOUNT(name_suffix, size)\n+define(`VPOPCOUNT', `\n+instruct vpopcount$1(vReg dst, vReg src) %{\n+  predicate(UseSVE > 0 &&\n+            !n->as_Vector()->is_predicated_vector()`'ifelse($1, `L', ` &&\n+            n->bottom_type()->is_vect()->element_basic_type() == T_LONG', `'));\n+  match(Set dst (PopCountV$1 src));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_cnt $dst, $src\\t# vector (sve) ($2)\" %}\n+  ins_encode %{\n+    assert(UsePopCountInstruction, \"unsupported\");dnl\n+ifelse($1, `I', `\n+    BasicType bt = Matcher::vector_element_basic_type(this);', `')\n+    __ sve_cnt(as_FloatRegister($dst$$reg), ifelse($1, `I', `__ elemType_to_regVariant(bt)', `__ D'),\n+         ptrue, as_FloatRegister($src$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+\/\/ vector popcount\n+VPOPCOUNT(I, B\/H\/S)\n+VPOPCOUNT(L, D)\n@@ -1175,4 +1200,14 @@\n-instruct vpopcountI(vReg dst, vReg src) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst (PopCountVI src));\n-  format %{ \"sve_cnt $dst, $src\\t# vector (sve) (S)\\n\\t\" %}\n+\/\/ If the PopCountVL is generated by auto-vectorization, the dst basic\n+\/\/ type is T_INT. And once we have unified the type definition for\n+\/\/ Vector API and auto-vectorization, this rule can be merged with\n+\/\/ \"vpopcountL\" rule.\n+instruct vpopcountLI(vReg dst, vReg src, vReg vtmp) %{\n+  predicate(UseSVE > 0 &&\n+            !n->as_Vector()->is_predicated_vector() &&\n+            n->bottom_type()->is_vect()->element_basic_type() == T_INT);\n+  match(Set dst (PopCountVL src));\n+  effect(TEMP_DEF dst, TEMP vtmp);\n+  ins_cost(3 * SVE_COST);\n+  format %{ \"sve_cnt $dst, $src\\n\\t\"\n+            \"sve_dup $vtmp, #0\\n\\t\"\n+            \"sve_uzp1 $dst, $dst, $vtmp\\t# vector (sve) (S)\" %}\n@@ -1180,1 +1215,5 @@\n-     __ sve_cnt(as_FloatRegister($dst$$reg), __ S, ptrue, as_FloatRegister($src$$reg));\n+    assert(UsePopCountInstruction, \"unsupported\");\n+    __ sve_cnt(as_FloatRegister($dst$$reg), __ D,\n+         ptrue, as_FloatRegister($src$$reg));\n+    __ sve_vector_narrow(as_FloatRegister($dst$$reg), __ S,\n+         as_FloatRegister($dst$$reg), __ D, as_FloatRegister($vtmp$$reg));\n@@ -1185,0 +1224,23 @@\n+dnl\n+dnl VPOPCOUNT_PREDICATE($1,          $2  )\n+dnl VPOPCOUNT_PREDICATE(name_suffix, size)\n+define(`VPOPCOUNT_PREDICATE', `\n+instruct vpopcount$1_masked(vReg dst_src, pRegGov pg) %{\n+  predicate(UseSVE > 0`'ifelse($1, `L', ` &&\n+            n->bottom_type()->is_vect()->element_basic_type() == T_LONG', `'));\n+  match(Set dst_src (PopCountV$1 dst_src pg));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_cnt $dst_src, $pg, $dst_src\\t# vector (sve) ($2)\" %}\n+  ins_encode %{\n+    assert(UsePopCountInstruction, \"unsupported\");dnl\n+ifelse($1, `I', `\n+    BasicType bt = Matcher::vector_element_basic_type(this);', `')\n+    __ sve_cnt(as_FloatRegister($dst_src$$reg), ifelse($1, `I', `__ elemType_to_regVariant(bt)', `__ D'),\n+         as_PRegister($pg$$reg), as_FloatRegister($dst_src$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+\/\/ vector popcount - predicated\n+VPOPCOUNT_PREDICATE(I, B\/H\/S)\n+VPOPCOUNT_PREDICATE(L, D)\n+\n@@ -3198,0 +3260,98 @@\n+\/\/ ---------------------------- Compress\/Expand Operations ---------------------------\n+\n+instruct mcompress(pReg dst, pReg pg, rFlagsReg cr) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst (CompressM pg));\n+  effect(KILL cr);\n+  ins_cost(2 * SVE_COST);\n+  format %{ \"sve_cntp rscratch1, $pg\\n\\t\"\n+            \"sve_whilelo $dst, zr, rscratch1\\t# mask compress (B\/H\/S\/D)\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n+    __ sve_cntp(rscratch1, size, ptrue, as_PRegister($pg$$reg));\n+    __ sve_whilelo(as_PRegister($dst$$reg), size, zr, rscratch1);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vcompress(vReg dst, vReg src, pRegGov pg) %{\n+  predicate(UseSVE > 0 &&\n+            (n->bottom_type()->is_vect()->element_basic_type() == T_INT ||\n+             n->bottom_type()->is_vect()->element_basic_type() == T_FLOAT ||\n+             n->bottom_type()->is_vect()->element_basic_type() == T_LONG ||\n+             n->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE));\n+  match(Set dst (CompressV src pg));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_compact $dst, $src, $pg\\t# vector compress (S\/D)\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n+    __ sve_compact(as_FloatRegister($dst$$reg), size, as_FloatRegister($src$$reg), as_PRegister($pg$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vcompressB(vReg dst, vReg src, pReg pg, vReg vtmp1, vReg vtmp2, vReg vtmp3, vReg vtmp4,\n+                    pReg ptmp, pRegGov pgtmp) %{\n+  predicate(UseSVE > 0 && n->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n+  effect(TEMP_DEF dst, TEMP vtmp1, TEMP vtmp2, TEMP vtmp3, TEMP vtmp4, TEMP ptmp, TEMP pgtmp);\n+  match(Set dst (CompressV src pg));\n+  ins_cost(13 * SVE_COST);\n+  format %{ \"sve_compact $dst, $src, $pg\\t# vector compress (B)\" %}\n+  ins_encode %{\n+    __ sve_compress_byte(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), as_PRegister($pg$$reg),\n+                         as_FloatRegister($vtmp1$$reg),as_FloatRegister($vtmp2$$reg),\n+                         as_FloatRegister($vtmp3$$reg),as_FloatRegister($vtmp4$$reg),\n+                         as_PRegister($ptmp$$reg), as_PRegister($pgtmp$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vcompressS(vReg dst, vReg src, pReg pg, vReg vtmp1, vReg vtmp2, pRegGov pgtmp) %{\n+  predicate(UseSVE > 0 && n->bottom_type()->is_vect()->element_basic_type() == T_SHORT);\n+  effect(TEMP_DEF dst, TEMP vtmp1, TEMP vtmp2, TEMP pgtmp);\n+  match(Set dst (CompressV src pg));\n+  ins_cost(38 * SVE_COST);\n+  format %{ \"sve_compact $dst, $src, $pg\\t# vector compress (H)\" %}\n+  ins_encode %{\n+    __ sve_compress_short(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), as_PRegister($pg$$reg),\n+                          as_FloatRegister($vtmp1$$reg),as_FloatRegister($vtmp2$$reg), as_PRegister($pgtmp$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vexpand(vReg dst, vReg src, pRegGov pg) %{\n+  match(Set dst (ExpandV src pg));\n+  effect(TEMP_DEF dst);\n+  ins_cost(4 * SVE_COST);\n+  format %{ \"sve_dup $dst, S\/D, 0\\n\\t\"\n+            \"sve_histcnt $dst, S\/D, $pg, $dst, $dst\\n\\t\"\n+            \"sve_sub $dst, S\/D, 1\\n\\t\"\n+            \"sve_tbl $dst, S\/D, $src, $dst\\t# vector expand (S\/D)\" %}\n+  ins_encode %{\n+    \/\/ Example input:   src   = 1 2 3 4 5 6 7 8\n+    \/\/                  pg    = 1 0 0 1 1 0 1 1\n+    \/\/ Expected result: dst   = 4 0 0 5 6 0 7 8\n+\n+    \/\/ The basic idea is to use TBL which can shuffle the elements in the given\n+    \/\/ vector flexibly. HISTCNT + SUB is used to generate the second source input\n+    \/\/ for TBL whose value is used to select the indexed element from src vector.\n+\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    assert(UseSVE == 2 && !is_subword_type(bt), \"unsupported\");\n+    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n+    \/\/ dst = 0 0 0 0 0 0 0 0\n+    __ sve_dup(as_FloatRegister($dst$$reg), size, 0);\n+    \/\/ dst = 5 0 0 4 3 0 2 1\n+    __ sve_histcnt(as_FloatRegister($dst$$reg), size, as_PRegister($pg$$reg),\n+                   as_FloatRegister($dst$$reg), as_FloatRegister($dst$$reg));\n+    \/\/ dst = 4 -1 -1 3 2 -1 1 0\n+    __ sve_sub(as_FloatRegister($dst$$reg), size, 1);\n+    \/\/ dst = 4 0 0 5 6 0 7 8\n+    __ sve_tbl(as_FloatRegister($dst$$reg), size, as_FloatRegister($src$$reg),\n+               as_FloatRegister($dst$$reg));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -3211,0 +3371,76 @@\n+\n+dnl\n+dnl BITWISE_UNARY($1,        $2,      $3  )\n+dnl BITWISE_UNARY(insn_name, op_name, insn)\n+define(`BITWISE_UNARY', `\n+instruct $1(vReg dst, vReg src) %{\n+  predicate(UseSVE > 0 &&\n+            !n->as_Vector()->is_predicated_vector());\n+  match(Set dst ($2 src));\n+  ins_cost(ifelse($2, `CountTrailingZerosV', `2 * ', `')SVE_COST);\n+  format %{ ifelse($2, `CountTrailingZerosV', `\"sve_rbit $dst, $src\\n\\t\"\n+            \"$3  $dst, $dst', `\"$3 $dst, $src')\\t# vector (sve)\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);dnl\n+ifelse($2, `CountTrailingZerosV', `\n+    __ sve_rbit(as_FloatRegister($dst$$reg), size, ptrue, as_FloatRegister($src$$reg));', `')dnl\n+ifelse($2, `ReverseBytesV', `\n+    if (bt == T_BYTE) {\n+      if (as_FloatRegister($dst$$reg) != as_FloatRegister($src$$reg)) {\n+        __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n+      }\n+    } else {\n+      __ $3(as_FloatRegister($dst$$reg), size, ptrue, as_FloatRegister($src$$reg));\n+    }', `\n+    __ $3(as_FloatRegister($dst$$reg), size, ptrue, as_FloatRegister($ifelse($2, `CountTrailingZerosV', dst, src)$$reg));')\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+dnl BITWISE_UNARY_PREDICATE($1,        $2,      $3  )\n+dnl BITWISE_UNARY_PREDICATE(insn_name, op_name, insn)\n+define(`BITWISE_UNARY_PREDICATE', `\n+\/\/ The dst and src should use the same register to make sure the\n+\/\/ inactive lanes in dst save the same elements as src.\n+instruct $1_masked(vReg dst_src, pRegGov pg) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src ($2 dst_src pg));\n+  ins_cost(ifelse($2, `CountTrailingZerosV', `2 * ', `')SVE_COST);\n+  format %{ ifelse($2, `CountTrailingZerosV', `\"sve_rbit $dst_src, $pg, $dst_src\\n\\t\"\n+            \"$3  $dst_src, $pg, $dst_src', `\"$3 $dst_src, $pg, $dst_src')\\t# vector (sve)\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);dnl\n+ifelse($2, `CountTrailingZerosV', `\n+    __ sve_rbit(as_FloatRegister($dst_src$$reg), size,\n+        as_PRegister($pg$$reg), as_FloatRegister($dst_src$$reg));', `')dnl\n+ifelse($2, `ReverseBytesV', `\n+    if (bt == T_BYTE) {\n+      \/\/ do nothing\n+    } else {\n+      __ $3(as_FloatRegister($dst_src$$reg), size,\n+          as_PRegister($pg$$reg), as_FloatRegister($dst_src$$reg));\n+    }', `\n+    __ $3(as_FloatRegister($dst_src$$reg), size,\n+        as_PRegister($pg$$reg), as_FloatRegister($dst_src$$reg));')\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+dnl\n+\/\/ ------------------------------ CountLeadingZerosV ------------------------------\n+BITWISE_UNARY(vcountLeadingZeros, CountLeadingZerosV, sve_clz)\n+BITWISE_UNARY_PREDICATE(vcountLeadingZeros, CountLeadingZerosV, sve_clz)\n+\n+\/\/ ------------------------------ CountTrailingZerosV -----------------------------\n+BITWISE_UNARY(vcountTrailingZeros, CountTrailingZerosV, sve_clz)\n+BITWISE_UNARY_PREDICATE(vcountTrailingZeros, CountTrailingZerosV, sve_clz)\n+\n+\/\/ ---------------------------------- ReverseV ------------------------------------\n+BITWISE_UNARY(vreverse, ReverseV, sve_rbit)\n+BITWISE_UNARY_PREDICATE(vreverse, ReverseV, sve_rbit)\n+\n+\/\/ -------------------------------- ReverseBytesV ---------------------------------\n+BITWISE_UNARY(vreverseBytes, ReverseBytesV, sve_revb)\n+BITWISE_UNARY_PREDICATE(vreverseBytes, ReverseBytesV, sve_revb)\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_sve_ad.m4","additions":242,"deletions":6,"binary":false,"changes":248,"status":"modified"},{"patch":"@@ -3137,0 +3137,1 @@\n+  INSN(sve_clz,  0b00000100, 0b011001101); \/\/ vector count leading zero bits\n@@ -3796,0 +3797,13 @@\n+\/\/ SVE reverse within elements\n+#define INSN(NAME, opc, cond)                                                        \\\n+  void NAME(FloatRegister Zd, SIMD_RegVariant T, PRegister Pg,  FloatRegister Zn) {  \\\n+    starti;                                                                          \\\n+    assert(cond, \"invalid size\");                                                    \\\n+    f(0b00000101, 31, 24), f(T, 23, 22), f(0b1001, 21, 18), f(opc, 17, 16);          \\\n+    f(0b100, 15, 13), pgrf(Pg, 10), rf(Zn, 5), rf(Zd, 0);                            \\\n+  }\n+\n+  INSN(sve_revb, 0b00, T == H || T == S || T == D);\n+  INSN(sve_rbit, 0b11, T != Q);\n+#undef INSN\n+\n@@ -3822,0 +3836,17 @@\n+  \/\/ Shuffle active elements of vector to the right and fill with zero\n+  void sve_compact(FloatRegister Zd, SIMD_RegVariant T, FloatRegister Zn, PRegister Pg) {\n+    starti;\n+    assert(T == S || T == D, \"invalid size\");\n+    f(0b00000101, 31, 24), f(T, 23, 22), f(0b100001100, 21, 13);\n+    pgrf(Pg, 10), rf(Zn, 5), rf(Zd, 0);\n+  }\n+\n+  \/\/ SVE2 Count matching elements in vector\n+  void sve_histcnt(FloatRegister Zd, SIMD_RegVariant T, PRegister Pg,\n+                   FloatRegister Zn, FloatRegister Zm) {\n+    starti;\n+    assert(T == S || T == D, \"invalid size\");\n+    f(0b01000101, 31, 24), f(T, 23, 22), f(0b1, 21), rf(Zm, 16);\n+    f(0b110, 15, 13), pgrf(Pg, 10), rf(Zn, 5), rf(Zd, 0);\n+  }\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/assembler_aarch64.hpp","additions":31,"deletions":0,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -1073,0 +1073,1 @@\n+      assert_different_registers(dst, tmp);\n@@ -1077,0 +1078,1 @@\n+      assert_different_registers(dst, tmp);\n@@ -1088,0 +1090,1 @@\n+      assert_different_registers(dst, tmp);\n@@ -1271,0 +1274,148 @@\n+\/\/ Pack active elements of src, under the control of mask, into the lowest-numbered elements of dst.\n+\/\/ Any remaining elements of dst will be filled with zero.\n+\/\/ Clobbers: rscratch1\n+\/\/ Preserves: src, mask\n+void C2_MacroAssembler::sve_compress_short(FloatRegister dst, FloatRegister src, PRegister mask,\n+                                           FloatRegister vtmp1, FloatRegister vtmp2,\n+                                           PRegister pgtmp) {\n+  assert(pgtmp->is_governing(), \"This register has to be a governing predicate register\");\n+  assert_different_registers(dst, src, vtmp1, vtmp2);\n+  assert_different_registers(mask, pgtmp);\n+\n+  \/\/ Example input:   src   = 8888 7777 6666 5555 4444 3333 2222 1111\n+  \/\/                  mask  = 0001 0000 0000 0001 0001 0000 0001 0001\n+  \/\/ Expected result: dst   = 0000 0000 0000 8888 5555 4444 2222 1111\n+  sve_dup(vtmp2, H, 0);\n+\n+  \/\/ Extend lowest half to type INT.\n+  \/\/ dst = 00004444 00003333 00002222 00001111\n+  sve_uunpklo(dst, S, src);\n+  \/\/ pgtmp = 00000001 00000000 00000001 00000001\n+  sve_punpklo(pgtmp, mask);\n+  \/\/ Pack the active elements in size of type INT to the right,\n+  \/\/ and fill the remainings with zero.\n+  \/\/ dst = 00000000 00004444 00002222 00001111\n+  sve_compact(dst, S, dst, pgtmp);\n+  \/\/ Narrow the result back to type SHORT.\n+  \/\/ dst = 0000 0000 0000 0000 0000 4444 2222 1111\n+  sve_uzp1(dst, H, dst, vtmp2);\n+  \/\/ Count the active elements of lowest half.\n+  \/\/ rscratch1 = 3\n+  sve_cntp(rscratch1, S, ptrue, pgtmp);\n+\n+  \/\/ Repeat to the highest half.\n+  \/\/ pgtmp = 00000001 00000000 00000000 00000001\n+  sve_punpkhi(pgtmp, mask);\n+  \/\/ vtmp1 = 00008888 00007777 00006666 00005555\n+  sve_uunpkhi(vtmp1, S, src);\n+  \/\/ vtmp1 = 00000000 00000000 00008888 00005555\n+  sve_compact(vtmp1, S, vtmp1, pgtmp);\n+  \/\/ vtmp1 = 0000 0000 0000 0000 0000 0000 8888 5555\n+  sve_uzp1(vtmp1, H, vtmp1, vtmp2);\n+\n+  \/\/ Compressed low:   dst   = 0000 0000 0000 0000 0000 4444 2222 1111\n+  \/\/ Compressed high:  vtmp1 = 0000 0000 0000 0000 0000 0000 8888  5555\n+  \/\/ Left shift(cross lane) compressed high with TRUE_CNT lanes,\n+  \/\/ TRUE_CNT is the number of active elements in the compressed low.\n+  neg(rscratch1, rscratch1);\n+  \/\/ vtmp2 = {4 3 2 1 0 -1 -2 -3}\n+  sve_index(vtmp2, H, rscratch1, 1);\n+  \/\/ vtmp1 = 0000 0000 0000 8888 5555 0000 0000 0000\n+  sve_tbl(vtmp1, H, vtmp1, vtmp2);\n+\n+  \/\/ Combine the compressed high(after shifted) with the compressed low.\n+  \/\/ dst = 0000 0000 0000 8888 5555 4444 2222 1111\n+  sve_orr(dst, dst, vtmp1);\n+}\n+\n+\/\/ Clobbers: rscratch1, rscratch2\n+\/\/ Preserves: src, mask\n+void C2_MacroAssembler::sve_compress_byte(FloatRegister dst, FloatRegister src, PRegister mask,\n+                                          FloatRegister vtmp1, FloatRegister vtmp2,\n+                                          FloatRegister vtmp3, FloatRegister vtmp4,\n+                                          PRegister ptmp, PRegister pgtmp) {\n+  assert(pgtmp->is_governing(), \"This register has to be a governing predicate register\");\n+  assert_different_registers(dst, src, vtmp1, vtmp2, vtmp3, vtmp4);\n+  assert_different_registers(mask, ptmp, pgtmp);\n+  \/\/ Example input:   src   = 88 77 66 55 44 33 22 11\n+  \/\/                  mask  = 01 00 00 01 01 00 01 01\n+  \/\/ Expected result: dst   = 00 00 00 88 55 44 22 11\n+\n+  sve_dup(vtmp4, B, 0);\n+  \/\/ Extend lowest half to type SHORT.\n+  \/\/ vtmp1 = 0044 0033 0022 0011\n+  sve_uunpklo(vtmp1, H, src);\n+  \/\/ ptmp = 0001 0000 0001 0001\n+  sve_punpklo(ptmp, mask);\n+  \/\/ Count the active elements of lowest half.\n+  \/\/ rscratch2 = 3\n+  sve_cntp(rscratch2, H, ptrue, ptmp);\n+  \/\/ Pack the active elements in size of type SHORT to the right,\n+  \/\/ and fill the remainings with zero.\n+  \/\/ dst = 0000 0044 0022 0011\n+  sve_compress_short(dst, vtmp1, ptmp, vtmp2, vtmp3, pgtmp);\n+  \/\/ Narrow the result back to type BYTE.\n+  \/\/ dst = 00 00 00 00 00 44 22 11\n+  sve_uzp1(dst, B, dst, vtmp4);\n+\n+  \/\/ Repeat to the highest half.\n+  \/\/ ptmp = 0001 0000 0000 0001\n+  sve_punpkhi(ptmp, mask);\n+  \/\/ vtmp1 = 0088 0077 0066 0055\n+  sve_uunpkhi(vtmp2, H, src);\n+  \/\/ vtmp1 = 0000 0000 0088 0055\n+  sve_compress_short(vtmp1, vtmp2, ptmp, vtmp3, vtmp4, pgtmp);\n+\n+  sve_dup(vtmp4, B, 0);\n+  \/\/ vtmp1 = 00 00 00 00 00 00 88 55\n+  sve_uzp1(vtmp1, B, vtmp1, vtmp4);\n+\n+  \/\/ Compressed low:   dst   = 00 00 00 00 00 44 22 11\n+  \/\/ Compressed high:  vtmp1 = 00 00 00 00 00 00 88 55\n+  \/\/ Left shift(cross lane) compressed high with TRUE_CNT lanes,\n+  \/\/ TRUE_CNT is the number of active elements in the compressed low.\n+  neg(rscratch2, rscratch2);\n+  \/\/ vtmp2 = {4 3 2 1 0 -1 -2 -3}\n+  sve_index(vtmp2, B, rscratch2, 1);\n+  \/\/ vtmp1 = 00 00 00 88 55 00 00 00\n+  sve_tbl(vtmp1, B, vtmp1, vtmp2);\n+  \/\/ Combine the compressed high(after shifted) with the compressed low.\n+  \/\/ dst = 00 00 00 88 55 44 22 11\n+  sve_orr(dst, dst, vtmp1);\n+}\n+\n+void C2_MacroAssembler::neon_reverse_bits(FloatRegister dst, FloatRegister src, BasicType bt, bool isQ) {\n+  assert(bt == T_BYTE || bt == T_SHORT || bt == T_INT || bt == T_LONG, \"unsupported basic type\");\n+  SIMD_Arrangement size = isQ ? T16B : T8B;\n+  if (bt == T_BYTE) {\n+    rbit(dst, size, src);\n+  } else {\n+    neon_reverse_bytes(dst, src, bt, isQ);\n+    rbit(dst, size, dst);\n+  }\n+}\n+\n+void C2_MacroAssembler::neon_reverse_bytes(FloatRegister dst, FloatRegister src, BasicType bt, bool isQ) {\n+  assert(bt == T_BYTE || bt == T_SHORT || bt == T_INT || bt == T_LONG, \"unsupported basic type\");\n+  SIMD_Arrangement size = isQ ? T16B : T8B;\n+  switch (bt) {\n+    case T_BYTE:\n+      if (dst != src) {\n+        orr(dst, size, src, src);\n+      }\n+      break;\n+    case T_SHORT:\n+      rev16(dst, size, src);\n+      break;\n+    case T_INT:\n+      rev32(dst, size, src);\n+      break;\n+    case T_LONG:\n+      rev64(dst, size, src);\n+      break;\n+    default:\n+      assert(false, \"unsupported\");\n+      ShouldNotReachHere();\n+  }\n+}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.cpp","additions":151,"deletions":0,"binary":false,"changes":151,"status":"modified"},{"patch":"@@ -107,0 +107,16 @@\n+  \/\/ Pack active elements of src, under the control of mask, into the\n+  \/\/ lowest-numbered elements of dst. Any remaining elements of dst will\n+  \/\/ be filled with zero.\n+  void sve_compress_byte(FloatRegister dst, FloatRegister src, PRegister mask,\n+                         FloatRegister vtmp1, FloatRegister vtmp2,\n+                         FloatRegister vtmp3, FloatRegister vtmp4,\n+                         PRegister ptmp, PRegister pgtmp);\n+\n+  void sve_compress_short(FloatRegister dst, FloatRegister src, PRegister mask,\n+                          FloatRegister vtmp1, FloatRegister vtmp2,\n+                          PRegister pgtmp);\n+\n+  void neon_reverse_bits(FloatRegister dst, FloatRegister src, BasicType bt, bool isQ);\n+\n+  void neon_reverse_bytes(FloatRegister dst, FloatRegister src, BasicType bt, bool isQ);\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.hpp","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -4848,1 +4848,27 @@\n-void Assembler::vpopcntd(XMMRegister dst, XMMRegister src, int vector_len) {\n+void Assembler::evpopcntb(XMMRegister dst, KRegister mask, XMMRegister src, bool merge, int vector_len) {\n+  assert(VM_Version::supports_avx512_bitalg(), \"must support avx512bitalg feature\");\n+  assert(vector_len == AVX_512bit || VM_Version::supports_avx512vl(), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false, \/* uses_vl *\/ true);\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  attributes.set_is_evex_instruction();\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int16(0x54, (0xC0 | encode));\n+}\n+\n+void Assembler::evpopcntw(XMMRegister dst, KRegister mask, XMMRegister src, bool merge, int vector_len) {\n+  assert(VM_Version::supports_avx512_bitalg(), \"must support avx512bitalg feature\");\n+  assert(vector_len == AVX_512bit || VM_Version::supports_avx512vl(), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false, \/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int16(0x54, (0xC0 | encode));\n+}\n+\n+void Assembler::evpopcntd(XMMRegister dst, KRegister mask, XMMRegister src, bool merge, int vector_len) {\n@@ -4850,1 +4876,2 @@\n-  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  assert(vector_len == AVX_512bit || VM_Version::supports_avx512vl(), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false, \/* uses_vl *\/ true);\n@@ -4852,0 +4879,4 @@\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n@@ -4856,1 +4887,1 @@\n-void Assembler::vpopcntq(XMMRegister dst, XMMRegister src, int vector_len) {\n+void Assembler::evpopcntq(XMMRegister dst, KRegister mask, XMMRegister src, bool merge, int vector_len) {\n@@ -4858,1 +4889,2 @@\n-  InstructionAttr attributes(vector_len, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  assert(vector_len == AVX_512bit || VM_Version::supports_avx512vl(), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false, \/* uses_vl *\/ true);\n@@ -4860,0 +4892,4 @@\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n@@ -7904,0 +7940,24 @@\n+void Assembler::evplzcntd(XMMRegister dst, KRegister mask, XMMRegister src, bool merge, int vector_len) {\n+  assert(VM_Version::supports_avx512cd() && (vector_len == AVX_512bit || VM_Version::supports_avx512vl()), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false,\/* legacy_mode *\/ false, \/* no_mask_reg *\/ false,\/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int16(0x44, (0xC0 | encode));\n+}\n+\n+void Assembler::evplzcntq(XMMRegister dst, KRegister mask, XMMRegister src, bool merge, int vector_len) {\n+  assert(VM_Version::supports_avx512cd() && (vector_len == AVX_512bit || VM_Version::supports_avx512vl()), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ true,\/* legacy_mode *\/ false, \/* no_mask_reg *\/ false,\/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int16(0x44, (0xC0 | encode));\n+}\n+\n@@ -7940,0 +8000,78 @@\n+void Assembler::evexpandps(XMMRegister dst, KRegister mask, XMMRegister src, bool merge, int vector_len) {\n+  assert(VM_Version::supports_evex(), \"\");\n+  assert(vector_len == AVX_512bit || VM_Version::supports_avx512vl(), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false,\/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int16((unsigned char)0x88, (0xC0 | encode));\n+}\n+\n+void Assembler::evexpandpd(XMMRegister dst, KRegister mask, XMMRegister src, bool merge, int vector_len) {\n+  assert(VM_Version::supports_evex(), \"\");\n+  assert(vector_len == AVX_512bit || VM_Version::supports_avx512vl(), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false,\/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int16((unsigned char)0x88, (0xC0 | encode));\n+}\n+\n+void Assembler::evpexpandb(XMMRegister dst, KRegister mask, XMMRegister src, bool merge, int vector_len) {\n+  assert(VM_Version::supports_avx512_vbmi2(), \"\");\n+  assert(vector_len == AVX_512bit || VM_Version::supports_avx512vl(), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false,\/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int16(0x62, (0xC0 | encode));\n+}\n+\n+void Assembler::evpexpandw(XMMRegister dst, KRegister mask, XMMRegister src, bool merge, int vector_len) {\n+  assert(VM_Version::supports_avx512_vbmi2(), \"\");\n+  assert(vector_len == AVX_512bit || VM_Version::supports_avx512vl(), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false,\/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int16(0x62, (0xC0 | encode));\n+}\n+\n+void Assembler::evpexpandd(XMMRegister dst, KRegister mask, XMMRegister src, bool merge, int vector_len) {\n+  assert(VM_Version::supports_evex(), \"\");\n+  assert(vector_len == AVX_512bit || VM_Version::supports_avx512vl(), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false,\/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int16((unsigned char)0x89, (0xC0 | encode));\n+}\n+\n+void Assembler::evpexpandq(XMMRegister dst, KRegister mask, XMMRegister src, bool merge, int vector_len) {\n+  assert(VM_Version::supports_evex(), \"\");\n+  assert(vector_len == AVX_512bit || VM_Version::supports_avx512vl(), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false,\/* uses_vl *\/ true);\n+  attributes.set_is_evex_instruction();\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int16((unsigned char)0x89, (0xC0 | encode));\n+}\n+\n@@ -7983,1 +8121,1 @@\n-  assert(VM_Version::supports_avx(), \"\");\n+  assert(VM_Version::supports_evex(), \"\");\n@@ -8042,1 +8180,1 @@\n-  assert(VM_Version::supports_avx2(), \"\");\n+  assert(VM_Version::supports_evex(), \"\");\n@@ -8055,1 +8193,1 @@\n-  assert(VM_Version::supports_avx(), \"\");\n+  assert(VM_Version::supports_evex(), \"\");\n@@ -8356,0 +8494,14 @@\n+void Assembler::vpunpckhwd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n+  assert(UseAVX > 0, \"requires some form of AVX\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int16(0x69, (0xC0 | encode));\n+}\n+\n+void Assembler::vpunpcklwd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {\n+  assert(UseAVX > 0, \"requires some form of AVX\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  int encode = vex_prefix_and_encode(dst->encoding(), nds->encoding(), src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int16(0x61, (0xC0 | encode));\n+}\n+\n@@ -9872,0 +10024,8 @@\n+void Assembler::vgf2p8affineqb(XMMRegister dst, XMMRegister src2, XMMRegister src3, int imm8, int vector_len) {\n+  assert(VM_Version::supports_gfni(), \"requires GFNI support\");\n+  assert(VM_Version::supports_sse(), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  int encode = vex_prefix_and_encode(dst->encoding(), src2->encoding(), src3->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &attributes);\n+  emit_int24((unsigned char)0xCE, (unsigned char)(0xC0 | encode), imm8);\n+}\n+\n@@ -11565,0 +11725,73 @@\n+\n+void Assembler::evpcompressb(XMMRegister dst, KRegister mask, XMMRegister src, bool merge, int vector_len) {\n+  assert(VM_Version::supports_avx512_vbmi2() && (vector_len == AVX_512bit || VM_Version::supports_avx512vl()), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false, \/* uses_vl *\/ true);\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  attributes.set_is_evex_instruction();\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  int encode = vex_prefix_and_encode(src->encoding(), 0, dst->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int16((unsigned char)0x63, (0xC0 | encode));\n+}\n+\n+void Assembler::evpcompressw(XMMRegister dst, KRegister mask, XMMRegister src, bool merge, int vector_len) {\n+  assert(VM_Version::supports_avx512_vbmi2() && (vector_len == AVX_512bit || VM_Version::supports_avx512vl()), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false, \/* uses_vl *\/ true);\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  attributes.set_is_evex_instruction();\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  int encode = vex_prefix_and_encode(src->encoding(), 0, dst->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int16((unsigned char)0x63, (0xC0 | encode));\n+}\n+\n+void Assembler::evpcompressd(XMMRegister dst, KRegister mask, XMMRegister src, bool merge, int vector_len) {\n+  assert(VM_Version::supports_evex() && (vector_len == AVX_512bit || VM_Version::supports_avx512vl()), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false, \/* uses_vl *\/ true);\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  attributes.set_is_evex_instruction();\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  int encode = vex_prefix_and_encode(src->encoding(), 0, dst->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int16((unsigned char)0x8B, (0xC0 | encode));\n+}\n+\n+void Assembler::evpcompressq(XMMRegister dst, KRegister mask, XMMRegister src, bool merge, int vector_len) {\n+  assert(VM_Version::supports_evex() && (vector_len == AVX_512bit || VM_Version::supports_avx512vl()), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false, \/* uses_vl *\/ true);\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  attributes.set_is_evex_instruction();\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  int encode = vex_prefix_and_encode(src->encoding(), 0, dst->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int16((unsigned char)0x8B, (0xC0 | encode));\n+}\n+\n+void Assembler::evcompressps(XMMRegister dst, KRegister mask, XMMRegister src, bool merge, int vector_len) {\n+  assert(VM_Version::supports_evex() && (vector_len == AVX_512bit || VM_Version::supports_avx512vl()), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false, \/* uses_vl *\/ true);\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  attributes.set_is_evex_instruction();\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  int encode = vex_prefix_and_encode(src->encoding(), 0, dst->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int16((unsigned char)0x8A, (0xC0 | encode));\n+}\n+\n+void Assembler::evcompresspd(XMMRegister dst, KRegister mask, XMMRegister src, bool merge, int vector_len) {\n+  assert(VM_Version::supports_evex() && (vector_len == AVX_512bit || VM_Version::supports_avx512vl()), \"\");\n+  InstructionAttr attributes(vector_len, \/* vex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ false, \/* uses_vl *\/ true);\n+  attributes.set_embedded_opmask_register_specifier(mask);\n+  attributes.set_is_evex_instruction();\n+  if (merge) {\n+    attributes.reset_is_clear_context();\n+  }\n+  int encode = vex_prefix_and_encode(src->encoding(), 0, dst->encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &attributes);\n+  emit_int16((unsigned char)0x8A, (0xC0 | encode));\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.cpp","additions":240,"deletions":7,"binary":false,"changes":247,"status":"modified"},{"patch":"@@ -1881,2 +1881,4 @@\n-  void vpopcntd(XMMRegister dst, XMMRegister src, int vector_len);\n-  void vpopcntq(XMMRegister dst, XMMRegister src, int vector_len);\n+  void evpopcntb(XMMRegister dst, KRegister mask, XMMRegister src, bool merge, int vector_len);\n+  void evpopcntw(XMMRegister dst, KRegister mask, XMMRegister src, bool merge, int vector_len);\n+  void evpopcntd(XMMRegister dst, KRegister mask, XMMRegister src, bool merge, int vector_len);\n+  void evpopcntq(XMMRegister dst, KRegister mask, XMMRegister src, bool merge, int vector_len);\n@@ -1948,0 +1950,6 @@\n+  \/\/ Interleave High Word\n+  void vpunpckhwd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);\n+\n+  \/\/ Interleave Low Word\n+  void vpunpcklwd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len);\n+\n@@ -2209,1 +2217,0 @@\n-  void pdep(Register dst, Register src1, Register src2);\n@@ -2211,1 +2218,1 @@\n-\n+  void pdep(Register dst, Register src1, Register src2);\n@@ -2440,0 +2447,2 @@\n+  void evplzcntd(XMMRegister dst, KRegister mask, XMMRegister src, bool merge, int vector_len);\n+  void evplzcntq(XMMRegister dst, KRegister mask, XMMRegister src, bool merge, int vector_len);\n@@ -2584,0 +2593,15 @@\n+  \/\/ Vector compress\/expand instructions.\n+  void evpcompressb(XMMRegister dst, KRegister mask, XMMRegister src, bool merge, int vector_len);\n+  void evpcompressw(XMMRegister dst, KRegister mask, XMMRegister src, bool merge, int vector_len);\n+  void evpcompressd(XMMRegister dst, KRegister mask, XMMRegister src, bool merge, int vector_len);\n+  void evpcompressq(XMMRegister dst, KRegister mask, XMMRegister src, bool merge, int vector_len);\n+  void evcompressps(XMMRegister dst, KRegister mask, XMMRegister src, bool merge, int vector_len);\n+  void evcompresspd(XMMRegister dst, KRegister mask, XMMRegister src, bool merge, int vector_len);\n+\n+  void evpexpandb(XMMRegister dst, KRegister mask, XMMRegister src, bool merge, int vector_len);\n+  void evpexpandw(XMMRegister dst, KRegister mask, XMMRegister src, bool merge, int vector_len);\n+  void evpexpandd(XMMRegister dst, KRegister mask, XMMRegister src, bool merge, int vector_len);\n+  void evpexpandq(XMMRegister dst, KRegister mask, XMMRegister src, bool merge, int vector_len);\n+  void evexpandps(XMMRegister dst, KRegister mask, XMMRegister src, bool merge, int vector_len);\n+  void evexpandpd(XMMRegister dst, KRegister mask, XMMRegister src, bool merge, int vector_len);\n+\n@@ -2740,0 +2764,4 @@\n+\n+  \/\/ Galois field affine transformation instructions.\n+  void vgf2p8affineqb(XMMRegister dst, XMMRegister src2, XMMRegister src3, int imm8, int vector_len);\n+\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.hpp","additions":32,"deletions":4,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -4421,0 +4421,65 @@\n+\n+void C2_MacroAssembler::vector_mask_compress(KRegister dst, KRegister src, Register rtmp1,\n+                                             Register rtmp2, int mask_len) {\n+  kmov(rtmp1, src);\n+  andq(rtmp1, (0xFFFFFFFFFFFFFFFFUL >> (64 - mask_len)));\n+  mov64(rtmp2, -1L);\n+  pext(rtmp2, rtmp2, rtmp1);\n+  kmov(dst, rtmp2);\n+}\n+\n+void C2_MacroAssembler::vector_compress_expand(int opcode, XMMRegister dst, XMMRegister src, KRegister mask,\n+                                               bool merge, BasicType bt, int vec_enc) {\n+  if (opcode == Op_CompressV) {\n+    switch(bt) {\n+    case T_BYTE:\n+      evpcompressb(dst, mask, src, merge, vec_enc);\n+      break;\n+    case T_CHAR:\n+    case T_SHORT:\n+      evpcompressw(dst, mask, src, merge, vec_enc);\n+      break;\n+    case T_INT:\n+      evpcompressd(dst, mask, src, merge, vec_enc);\n+      break;\n+    case T_FLOAT:\n+      evcompressps(dst, mask, src, merge, vec_enc);\n+      break;\n+    case T_LONG:\n+      evpcompressq(dst, mask, src, merge, vec_enc);\n+      break;\n+    case T_DOUBLE:\n+      evcompresspd(dst, mask, src, merge, vec_enc);\n+      break;\n+    default:\n+      fatal(\"Unsupported type\");\n+      break;\n+    }\n+  } else {\n+    assert(opcode == Op_ExpandV, \"\");\n+    switch(bt) {\n+    case T_BYTE:\n+      evpexpandb(dst, mask, src, merge, vec_enc);\n+      break;\n+    case T_CHAR:\n+    case T_SHORT:\n+      evpexpandw(dst, mask, src, merge, vec_enc);\n+      break;\n+    case T_INT:\n+      evpexpandd(dst, mask, src, merge, vec_enc);\n+      break;\n+    case T_FLOAT:\n+      evexpandps(dst, mask, src, merge, vec_enc);\n+      break;\n+    case T_LONG:\n+      evpexpandq(dst, mask, src, merge, vec_enc);\n+      break;\n+    case T_DOUBLE:\n+      evexpandpd(dst, mask, src, merge, vec_enc);\n+      break;\n+    default:\n+      fatal(\"Unsupported type\");\n+      break;\n+    }\n+  }\n+}\n@@ -4484,0 +4549,26 @@\n+void C2_MacroAssembler::vbroadcast(BasicType bt, XMMRegister dst, int imm32, Register rtmp, int vec_enc) {\n+  int lane_size = type2aelembytes(bt);\n+  bool is_LP64 = LP64_ONLY(true) NOT_LP64(false);\n+  if ((is_LP64 || lane_size < 8) &&\n+      ((is_non_subword_integral_type(bt) && VM_Version::supports_avx512vl()) ||\n+       (is_subword_type(bt) && VM_Version::supports_avx512vlbw()))) {\n+    movptr(rtmp, imm32);\n+    switch(lane_size) {\n+      case 1 : evpbroadcastb(dst, rtmp, vec_enc); break;\n+      case 2 : evpbroadcastw(dst, rtmp, vec_enc); break;\n+      case 4 : evpbroadcastd(dst, rtmp, vec_enc); break;\n+      case 8 : evpbroadcastq(dst, rtmp, vec_enc); break;\n+      default : ShouldNotReachHere(); break;\n+    }\n+  } else {\n+    movptr(rtmp, imm32);\n+    LP64_ONLY(movq(dst, rtmp)) NOT_LP64(movdl(dst, rtmp));\n+    switch(lane_size) {\n+      case 1 : vpbroadcastb(dst, dst, vec_enc); break;\n+      case 2 : vpbroadcastw(dst, dst, vec_enc); break;\n+      case 4 : vpbroadcastd(dst, dst, vec_enc); break;\n+      case 8 : vpbroadcastq(dst, dst, vec_enc); break;\n+      default : ShouldNotReachHere(); break;\n+    }\n+  }\n+}\n@@ -4514,0 +4605,14 @@\n+\n+void C2_MacroAssembler::vector_popcount_byte(XMMRegister dst, XMMRegister src, XMMRegister xtmp1,\n+                                             XMMRegister xtmp2, Register rtmp, int vec_enc) {\n+  assert((vec_enc == Assembler::AVX_512bit && VM_Version::supports_avx512bw()) || VM_Version::supports_avx2(), \"\");\n+  vbroadcast(T_INT, xtmp1, 0x0F0F0F0F, rtmp, vec_enc);\n+  vpsrlw(dst, src, 4, vec_enc);\n+  vpand(dst, dst, xtmp1, vec_enc);\n+  vpand(xtmp1, src, xtmp1, vec_enc);\n+  vmovdqu(xtmp2, ExternalAddress(StubRoutines::x86::vector_popcount_lut()), rtmp, vec_enc);\n+  vpshufb(xtmp1, xtmp2, xtmp1, vec_enc);\n+  vpshufb(dst, xtmp2, dst, vec_enc);\n+  vpaddb(dst, dst, xtmp1, vec_enc);\n+}\n+\n@@ -4515,27 +4620,19 @@\n-                                            XMMRegister xtmp2, XMMRegister xtmp3, Register rtmp,\n-                                            int vec_enc) {\n-  if (VM_Version::supports_avx512_vpopcntdq()) {\n-    vpopcntd(dst, src, vec_enc);\n-  } else {\n-    assert((vec_enc == Assembler::AVX_512bit && VM_Version::supports_avx512bw()) || VM_Version::supports_avx2(), \"\");\n-    movl(rtmp, 0x0F0F0F0F);\n-    movdl(xtmp1, rtmp);\n-    vpbroadcastd(xtmp1, xtmp1, vec_enc);\n-    if (Assembler::AVX_512bit == vec_enc) {\n-      evmovdqul(xtmp2, k0, ExternalAddress(StubRoutines::x86::vector_popcount_lut()), false, vec_enc, rtmp);\n-    } else {\n-      vmovdqu(xtmp2, ExternalAddress(StubRoutines::x86::vector_popcount_lut()), rtmp);\n-    }\n-    vpand(xtmp3, src, xtmp1, vec_enc);\n-    vpshufb(xtmp3, xtmp2, xtmp3, vec_enc);\n-    vpsrlw(dst, src, 4, vec_enc);\n-    vpand(dst, dst, xtmp1, vec_enc);\n-    vpshufb(dst, xtmp2, dst, vec_enc);\n-    vpaddb(xtmp3, dst, xtmp3, vec_enc);\n-    vpxor(xtmp1, xtmp1, xtmp1, vec_enc);\n-    vpunpckhdq(dst, xtmp3, xtmp1, vec_enc);\n-    vpsadbw(dst, dst, xtmp1, vec_enc);\n-    vpunpckldq(xtmp2, xtmp3, xtmp1, vec_enc);\n-    vpsadbw(xtmp2, xtmp2, xtmp1, vec_enc);\n-    vpackuswb(dst, xtmp2, dst, vec_enc);\n-  }\n+                                            XMMRegister xtmp2, Register rtmp, int vec_enc) {\n+  vector_popcount_byte(xtmp1, src, dst, xtmp2, rtmp, vec_enc);\n+  \/\/ Following code is as per steps e,f,g and h of above algorithm.\n+  vpxor(xtmp2, xtmp2, xtmp2, vec_enc);\n+  vpunpckhdq(dst, xtmp1, xtmp2, vec_enc);\n+  vpsadbw(dst, dst, xtmp2, vec_enc);\n+  vpunpckldq(xtmp1, xtmp1, xtmp2, vec_enc);\n+  vpsadbw(xtmp1, xtmp1, xtmp2, vec_enc);\n+  vpackuswb(dst, xtmp1, dst, vec_enc);\n+}\n+\n+void C2_MacroAssembler::vector_popcount_short(XMMRegister dst, XMMRegister src, XMMRegister xtmp1,\n+                                              XMMRegister xtmp2, Register rtmp, int vec_enc) {\n+  vector_popcount_byte(xtmp1, src, dst, xtmp2, rtmp, vec_enc);\n+  \/\/ Add the popcount of upper and lower bytes of word.\n+  vbroadcast(T_INT, xtmp2, 0x00FF00FF, rtmp, vec_enc);\n+  vpsrlw(dst, xtmp1, 8, vec_enc);\n+  vpand(xtmp1, xtmp1, xtmp2, vec_enc);\n+  vpaddw(dst, dst, xtmp1, vec_enc);\n@@ -4545,23 +4642,52 @@\n-                                             XMMRegister xtmp2, XMMRegister xtmp3, Register rtmp,\n-                                             int vec_enc) {\n-  if (VM_Version::supports_avx512_vpopcntdq()) {\n-    vpopcntq(dst, src, vec_enc);\n-  } else if (vec_enc == Assembler::AVX_512bit) {\n-    assert(VM_Version::supports_avx512bw(), \"\");\n-    movl(rtmp, 0x0F0F0F0F);\n-    movdl(xtmp1, rtmp);\n-    vpbroadcastd(xtmp1, xtmp1, vec_enc);\n-    evmovdqul(xtmp2, k0, ExternalAddress(StubRoutines::x86::vector_popcount_lut()), true, vec_enc, rtmp);\n-    vpandq(xtmp3, src, xtmp1, vec_enc);\n-    vpshufb(xtmp3, xtmp2, xtmp3, vec_enc);\n-    vpsrlw(dst, src, 4, vec_enc);\n-    vpandq(dst, dst, xtmp1, vec_enc);\n-    vpshufb(dst, xtmp2, dst, vec_enc);\n-    vpaddb(xtmp3, dst, xtmp3, vec_enc);\n-    vpxorq(xtmp1, xtmp1, xtmp1, vec_enc);\n-    vpsadbw(dst, xtmp3, xtmp1, vec_enc);\n-  } else {\n-    \/\/ We do not see any performance benefit of running\n-    \/\/ above instruction sequence on 256 bit vector which\n-    \/\/ can operate over maximum 4 long elements.\n-    ShouldNotReachHere();\n+                                             XMMRegister xtmp2, Register rtmp, int vec_enc) {\n+  vector_popcount_byte(xtmp1, src, dst, xtmp2, rtmp, vec_enc);\n+  vpxor(xtmp2, xtmp2, xtmp2, vec_enc);\n+  vpsadbw(dst, xtmp1, xtmp2, vec_enc);\n+}\n+\n+void C2_MacroAssembler::vector_popcount_integral(BasicType bt, XMMRegister dst, XMMRegister src, XMMRegister xtmp1,\n+                                                 XMMRegister xtmp2, Register rtmp, int vec_enc) {\n+  switch(bt) {\n+    case T_LONG:\n+      vector_popcount_long(dst, src, xtmp1, xtmp2, rtmp, vec_enc);\n+      break;\n+    case T_INT:\n+      vector_popcount_int(dst, src, xtmp1, xtmp2, rtmp, vec_enc);\n+      break;\n+    case T_CHAR:\n+    case T_SHORT:\n+      vector_popcount_short(dst, src, xtmp1, xtmp2, rtmp, vec_enc);\n+      break;\n+    case T_BYTE:\n+    case T_BOOLEAN:\n+      vector_popcount_byte(dst, src, xtmp1, xtmp2, rtmp, vec_enc);\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+  }\n+}\n+\n+void C2_MacroAssembler::vector_popcount_integral_evex(BasicType bt, XMMRegister dst, XMMRegister src,\n+                                                      KRegister mask, bool merge, int vec_enc) {\n+  assert(VM_Version::supports_avx512vl() || vec_enc == Assembler::AVX_512bit, \"\");\n+  switch(bt) {\n+    case T_LONG:\n+      assert(VM_Version::supports_avx512_vpopcntdq(), \"\");\n+      evpopcntq(dst, mask, src, merge, vec_enc);\n+      break;\n+    case T_INT:\n+      assert(VM_Version::supports_avx512_vpopcntdq(), \"\");\n+      evpopcntd(dst, mask, src, merge, vec_enc);\n+      break;\n+    case T_CHAR:\n+    case T_SHORT:\n+      assert(VM_Version::supports_avx512_bitalg(), \"\");\n+      evpopcntw(dst, mask, src, merge, vec_enc);\n+      break;\n+    case T_BYTE:\n+    case T_BOOLEAN:\n+      assert(VM_Version::supports_avx512_bitalg(), \"\");\n+      evpopcntb(dst, mask, src, merge, vec_enc);\n+      break;\n+    default:\n+      ShouldNotReachHere();\n@@ -4569,1 +4695,0 @@\n-  evpmovqd(dst, dst, vec_enc);\n@@ -4580,0 +4705,390 @@\n+\/\/ Bit reversal algorithm first reverses the bits of each byte followed by\n+\/\/ a byte level reversal for multi-byte primitive types (short\/int\/long).\n+\/\/ Algorithm performs a lookup table access to get reverse bit sequence\n+\/\/ corresponding to a 4 bit value. Thus a reverse bit sequence for a byte\n+\/\/ is obtained by swapping the reverse bit sequences of upper and lower\n+\/\/ nibble of a byte.\n+void C2_MacroAssembler::vector_reverse_bit(BasicType bt, XMMRegister dst, XMMRegister src, XMMRegister xtmp1,\n+                                           XMMRegister xtmp2, Register rtmp, int vec_enc) {\n+  if (VM_Version::supports_avx512vlbw()) {\n+\n+    \/\/ Get the reverse bit sequence of lower nibble of each byte.\n+    vmovdqu(xtmp1, ExternalAddress(StubRoutines::x86::vector_reverse_bit_lut()), rtmp, vec_enc);\n+    vbroadcast(T_INT, xtmp2, 0x0F0F0F0F, rtmp, vec_enc);\n+    vpandq(dst, xtmp2, src, vec_enc);\n+    vpshufb(dst, xtmp1, dst, vec_enc);\n+    vpsllq(dst, dst, 4, vec_enc);\n+\n+    \/\/ Get the reverse bit sequence of upper nibble of each byte.\n+    vpandn(xtmp2, xtmp2, src, vec_enc);\n+    vpsrlq(xtmp2, xtmp2, 4, vec_enc);\n+    vpshufb(xtmp2, xtmp1, xtmp2, vec_enc);\n+\n+    \/\/ Perform logical OR operation b\/w left shifted reverse bit sequence of lower nibble and\n+    \/\/ right shifted reverse bit sequence of upper nibble to obtain the reverse bit sequence of each byte.\n+    vporq(xtmp2, dst, xtmp2, vec_enc);\n+    vector_reverse_byte(bt, dst, xtmp2, rtmp, vec_enc);\n+\n+  } else if(!VM_Version::supports_avx512vlbw() && vec_enc == Assembler::AVX_512bit) {\n+\n+    \/\/ Shift based bit reversal.\n+    assert(bt == T_LONG || bt == T_INT, \"\");\n+    vbroadcast(T_INT, xtmp1, 0x0F0F0F0F, rtmp, vec_enc);\n+\n+    \/\/ Swap lower and upper nibble of each byte.\n+    vpandq(dst, xtmp1, src, vec_enc);\n+    vpsllq(dst, dst, 4, vec_enc);\n+    vpandn(xtmp2, xtmp1, src, vec_enc);\n+    vpsrlq(xtmp2, xtmp2, 4, vec_enc);\n+    vporq(xtmp1, dst, xtmp2, vec_enc);\n+\n+    \/\/ Swap two least and most significant bits of each nibble.\n+    vbroadcast(T_INT, xtmp2, 0x33333333, rtmp, vec_enc);\n+    vpandq(dst, xtmp2, xtmp1, vec_enc);\n+    vpsllq(dst, dst, 2, vec_enc);\n+    vpandn(xtmp2, xtmp2, xtmp1, vec_enc);\n+    vpsrlq(xtmp2, xtmp2, 2, vec_enc);\n+    vporq(xtmp1, dst, xtmp2, vec_enc);\n+\n+    \/\/ Swap adjacent pair of bits.\n+    vbroadcast(T_INT, xtmp2, 0x55555555, rtmp, vec_enc);\n+    vpandq(dst, xtmp2, xtmp1, vec_enc);\n+    vpsllq(dst, dst, 1, vec_enc);\n+    vpandn(xtmp2, xtmp2, xtmp1, vec_enc);\n+    vpsrlq(xtmp2, xtmp2, 1, vec_enc);\n+    vporq(xtmp1, dst, xtmp2, vec_enc);\n+\n+    vector_reverse_byte64(bt, dst, xtmp1, xtmp1, xtmp2, rtmp, vec_enc);\n+\n+  } else {\n+    vmovdqu(xtmp1, ExternalAddress(StubRoutines::x86::vector_reverse_bit_lut()), rtmp, vec_enc);\n+    vbroadcast(T_INT, xtmp2, 0x0F0F0F0F, rtmp, vec_enc);\n+\n+    \/\/ Get the reverse bit sequence of lower nibble of each byte.\n+    vpand(dst, xtmp2, src, vec_enc);\n+    vpshufb(dst, xtmp1, dst, vec_enc);\n+    vpsllq(dst, dst, 4, vec_enc);\n+\n+    \/\/ Get the reverse bit sequence of upper nibble of each byte.\n+    vpandn(xtmp2, xtmp2, src, vec_enc);\n+    vpsrlq(xtmp2, xtmp2, 4, vec_enc);\n+    vpshufb(xtmp2, xtmp1, xtmp2, vec_enc);\n+\n+    \/\/ Perform logical OR operation b\/w left shifted reverse bit sequence of lower nibble and\n+    \/\/ right shifted reverse bit sequence of upper nibble to obtain the reverse bit sequence of each byte.\n+    vpor(xtmp2, dst, xtmp2, vec_enc);\n+    vector_reverse_byte(bt, dst, xtmp2, rtmp, vec_enc);\n+  }\n+}\n+\n+void C2_MacroAssembler::vector_reverse_bit_gfni(BasicType bt, XMMRegister dst, XMMRegister src,\n+                                                XMMRegister xtmp, AddressLiteral mask, Register rtmp, int vec_enc) {\n+  \/\/ Galois field instruction based bit reversal based on following algorithm.\n+  \/\/ http:\/\/0x80.pl\/articles\/avx512-galois-field-for-bit-shuffling.html\n+  assert(VM_Version::supports_gfni(), \"\");\n+  vpbroadcastq(xtmp, mask, vec_enc, rtmp);\n+  vgf2p8affineqb(xtmp, src, xtmp, 0, vec_enc);\n+  vector_reverse_byte(bt, dst, xtmp, rtmp, vec_enc);\n+}\n+\n+void C2_MacroAssembler::vector_reverse_byte64(BasicType bt, XMMRegister dst, XMMRegister src, XMMRegister xtmp1,\n+                                              XMMRegister xtmp2, Register rtmp, int vec_enc) {\n+  \/\/ Shift based bit reversal.\n+  assert(VM_Version::supports_evex(), \"\");\n+  evmovdqul(xtmp1, k0, src, true, vec_enc);\n+  switch(bt) {\n+    case T_LONG:\n+      \/\/ Swap upper and lower double word of each quad word.\n+      evprorq(xtmp1, k0, xtmp1, 32, true, vec_enc);\n+    case T_INT:\n+      \/\/ Swap upper and lower word of each double word.\n+      evprord(xtmp1, k0, xtmp1, 16, true, vec_enc);\n+    case T_SHORT:\n+      \/\/ Swap upper and lower byte of each word.\n+      vbroadcast(T_INT, dst, 0x00FF00FF, rtmp, vec_enc);\n+      vpandq(xtmp2, dst, xtmp1, vec_enc);\n+      vpsllq(xtmp2, xtmp2, 8, vec_enc);\n+      vpandn(xtmp1, dst, xtmp1, vec_enc);\n+      vpsrlq(dst, xtmp1, 8, vec_enc);\n+      vporq(dst, dst, xtmp2, vec_enc);\n+      break;\n+    case T_BYTE:\n+      evmovdquq(dst, k0, src, true, vec_enc);\n+      break;\n+    default:\n+      fatal(\"Unsupported type\");\n+      break;\n+  }\n+}\n+\n+void C2_MacroAssembler::vector_reverse_byte(BasicType bt, XMMRegister dst, XMMRegister src, Register rtmp, int vec_enc) {\n+  if (bt == T_BYTE) {\n+    if (VM_Version::supports_avx512vl() || vec_enc == Assembler::AVX_512bit) {\n+      evmovdquq(dst, k0, src, true, vec_enc);\n+    } else {\n+      vmovdqu(dst, src);\n+    }\n+    return;\n+  }\n+  \/\/ Perform byte reversal by shuffling the bytes of a multi-byte primitive type using\n+  \/\/ pre-computed shuffle indices.\n+  switch(bt) {\n+    case T_LONG:\n+      vmovdqu(dst, ExternalAddress(StubRoutines::x86::vector_reverse_byte_perm_mask_long()), rtmp, vec_enc);\n+      break;\n+    case T_INT:\n+      vmovdqu(dst, ExternalAddress(StubRoutines::x86::vector_reverse_byte_perm_mask_int()), rtmp, vec_enc);\n+      break;\n+    case T_SHORT:\n+      vmovdqu(dst, ExternalAddress(StubRoutines::x86::vector_reverse_byte_perm_mask_short()), rtmp, vec_enc);\n+      break;\n+    default:\n+      fatal(\"Unsupported type\");\n+      break;\n+  }\n+  vpshufb(dst, src, dst, vec_enc);\n+}\n+\n+void C2_MacroAssembler::vector_count_leading_zeros_evex(BasicType bt, XMMRegister dst, XMMRegister src,\n+                                                        XMMRegister xtmp1, XMMRegister xtmp2, XMMRegister xtmp3,\n+                                                        KRegister ktmp, Register rtmp, bool merge, int vec_enc) {\n+  assert(is_integral_type(bt), \"\");\n+  assert(VM_Version::supports_avx512vl() || vec_enc == Assembler::AVX_512bit, \"\");\n+  assert(VM_Version::supports_avx512cd(), \"\");\n+  switch(bt) {\n+    case T_LONG:\n+      evplzcntq(dst, ktmp, src, merge, vec_enc);\n+      break;\n+    case T_INT:\n+      evplzcntd(dst, ktmp, src, merge, vec_enc);\n+      break;\n+    case T_SHORT:\n+      vpternlogd(xtmp1, 0xff, xtmp1, xtmp1, vec_enc);\n+      vpunpcklwd(xtmp2, xtmp1, src, vec_enc);\n+      evplzcntd(xtmp2, ktmp, xtmp2, merge, vec_enc);\n+      vpunpckhwd(dst, xtmp1, src, vec_enc);\n+      evplzcntd(dst, ktmp, dst, merge, vec_enc);\n+      vpackusdw(dst, xtmp2, dst, vec_enc);\n+      break;\n+    case T_BYTE:\n+      \/\/ T1 = Compute leading zero counts of 4 LSB bits of each byte by\n+      \/\/ accessing the lookup table.\n+      \/\/ T2 = Compute leading zero counts of 4 MSB bits of each byte by\n+      \/\/ accessing the lookup table.\n+      \/\/ Add T1 to T2 if 4 MSB bits of byte are all zeros.\n+      assert(VM_Version::supports_avx512bw(), \"\");\n+      evmovdquq(xtmp1, ExternalAddress(StubRoutines::x86::vector_count_leading_zeros_lut()), vec_enc, rtmp);\n+      vbroadcast(T_INT, dst, 0x0F0F0F0F, rtmp, vec_enc);\n+      vpand(xtmp2, dst, src, vec_enc);\n+      vpshufb(xtmp2, xtmp1, xtmp2, vec_enc);\n+      vpsrlw(xtmp3, src, 4, vec_enc);\n+      vpand(xtmp3, dst, xtmp3, vec_enc);\n+      vpshufb(dst, xtmp1, xtmp3, vec_enc);\n+      vpxor(xtmp1, xtmp1, xtmp1, vec_enc);\n+      evpcmpeqb(ktmp, xtmp1, xtmp3, vec_enc);\n+      evpaddb(dst, ktmp, dst, xtmp2, true, vec_enc);\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+  }\n+}\n+\n+void C2_MacroAssembler::vector_count_leading_zeros_byte_avx(XMMRegister dst, XMMRegister src, XMMRegister xtmp1,\n+                                                            XMMRegister xtmp2, XMMRegister xtmp3, Register rtmp, int vec_enc) {\n+  vmovdqu(xtmp1, ExternalAddress(StubRoutines::x86::vector_count_leading_zeros_lut()), rtmp);\n+  vbroadcast(T_INT, xtmp2, 0x0F0F0F0F, rtmp, vec_enc);\n+  \/\/ T1 = Compute leading zero counts of 4 LSB bits of each byte by\n+  \/\/ accessing the lookup table.\n+  vpand(dst, xtmp2, src, vec_enc);\n+  vpshufb(dst, xtmp1, dst, vec_enc);\n+  \/\/ T2 = Compute leading zero counts of 4 MSB bits of each byte by\n+  \/\/ accessing the lookup table.\n+  vpsrlw(xtmp3, src, 4, vec_enc);\n+  vpand(xtmp3, xtmp2, xtmp3, vec_enc);\n+  vpshufb(xtmp2, xtmp1, xtmp3, vec_enc);\n+  \/\/ Add T1 to T2 if 4 MSB bits of byte are all zeros.\n+  vpxor(xtmp1, xtmp1, xtmp1, vec_enc);\n+  vpcmpeqb(xtmp3, xtmp1, xtmp3, vec_enc);\n+  vpaddb(dst, dst, xtmp2, vec_enc);\n+  vpblendvb(dst, xtmp2, dst, xtmp3, vec_enc);\n+}\n+\n+void C2_MacroAssembler::vector_count_leading_zeros_short_avx(XMMRegister dst, XMMRegister src, XMMRegister xtmp1,\n+                                                             XMMRegister xtmp2, XMMRegister xtmp3, Register rtmp, int vec_enc) {\n+  vector_count_leading_zeros_byte_avx(dst, src, xtmp1, xtmp2, xtmp3, rtmp, vec_enc);\n+  \/\/ Add zero counts of lower byte and upper byte of a word if\n+  \/\/ upper byte holds a zero value.\n+  vpsrlw(xtmp3, src, 8, vec_enc);\n+  \/\/ xtmp1 is set to all zeros by vector_count_leading_zeros_byte_avx.\n+  vpcmpeqw(xtmp3, xtmp1, xtmp3, vec_enc);\n+  vpsllw(xtmp2, dst, 8, vec_enc);\n+  vpaddw(xtmp2, xtmp2, dst, vec_enc);\n+  vpblendvb(dst, dst, xtmp2, xtmp3, vec_enc);\n+  vpsrlw(dst, dst, 8, vec_enc);\n+}\n+\n+void C2_MacroAssembler::vector_count_leading_zeros_int_avx(XMMRegister dst, XMMRegister src, XMMRegister xtmp1,\n+                                                           XMMRegister xtmp2, XMMRegister xtmp3, int vec_enc) {\n+  \/\/ Since IEEE 754 floating point format represents mantissa in 1.0 format\n+  \/\/ hence biased exponent can be used to compute leading zero count as per\n+  \/\/ following formula:-\n+  \/\/ LZCNT = 32 - (biased_exp - 127)\n+  \/\/ Special handling has been introduced for Zero, Max_Int and -ve source values.\n+\n+  \/\/ Broadcast 0xFF\n+  vpcmpeqd(xtmp1, xtmp1, xtmp1, vec_enc);\n+  vpsrld(xtmp1, xtmp1, 24, vec_enc);\n+\n+  \/\/ Extract biased exponent.\n+  vcvtdq2ps(dst, src, vec_enc);\n+  vpsrld(dst, dst, 23, vec_enc);\n+  vpand(dst, dst, xtmp1, vec_enc);\n+\n+  \/\/ Broadcast 127.\n+  vpsrld(xtmp1, xtmp1, 1, vec_enc);\n+  \/\/ Exponent = biased_exp - 127\n+  vpsubd(dst, dst, xtmp1, vec_enc);\n+\n+  \/\/ Exponent = Exponent  + 1\n+  vpsrld(xtmp3, xtmp1, 6, vec_enc);\n+  vpaddd(dst, dst, xtmp3, vec_enc);\n+\n+  \/\/ Replace -ve exponent with zero, exponent is -ve when src\n+  \/\/ lane contains a zero value.\n+  vpxor(xtmp2, xtmp2, xtmp2, vec_enc);\n+  vblendvps(dst, dst, xtmp2, dst, vec_enc);\n+\n+  \/\/ Rematerialize broadcast 32.\n+  vpslld(xtmp1, xtmp3, 5, vec_enc);\n+  \/\/ Exponent is 32 if corresponding source lane contains max_int value.\n+  vpcmpeqd(xtmp2, dst, xtmp1, vec_enc);\n+  \/\/ LZCNT = 32 - exponent\n+  vpsubd(dst, xtmp1, dst, vec_enc);\n+\n+  \/\/ Replace LZCNT with a value 1 if corresponding source lane\n+  \/\/ contains max_int value.\n+  vpblendvb(dst, dst, xtmp3, xtmp2, vec_enc);\n+\n+  \/\/ Replace biased_exp with 0 if source lane value is less than zero.\n+  vpxor(xtmp2, xtmp2, xtmp2, vec_enc);\n+  vblendvps(dst, dst, xtmp2, src, vec_enc);\n+}\n+\n+void C2_MacroAssembler::vector_count_leading_zeros_long_avx(XMMRegister dst, XMMRegister src, XMMRegister xtmp1,\n+                                                            XMMRegister xtmp2, XMMRegister xtmp3, Register rtmp, int vec_enc) {\n+  vector_count_leading_zeros_short_avx(dst, src, xtmp1, xtmp2, xtmp3, rtmp, vec_enc);\n+  \/\/ Add zero counts of lower word and upper word of a double word if\n+  \/\/ upper word holds a zero value.\n+  vpsrld(xtmp3, src, 16, vec_enc);\n+  \/\/ xtmp1 is set to all zeros by vector_count_leading_zeros_byte_avx.\n+  vpcmpeqd(xtmp3, xtmp1, xtmp3, vec_enc);\n+  vpslld(xtmp2, dst, 16, vec_enc);\n+  vpaddd(xtmp2, xtmp2, dst, vec_enc);\n+  vpblendvb(dst, dst, xtmp2, xtmp3, vec_enc);\n+  vpsrld(dst, dst, 16, vec_enc);\n+  \/\/ Add zero counts of lower doubleword and upper doubleword of a\n+  \/\/ quadword if upper doubleword holds a zero value.\n+  vpsrlq(xtmp3, src, 32, vec_enc);\n+  vpcmpeqq(xtmp3, xtmp1, xtmp3, vec_enc);\n+  vpsllq(xtmp2, dst, 32, vec_enc);\n+  vpaddq(xtmp2, xtmp2, dst, vec_enc);\n+  vpblendvb(dst, dst, xtmp2, xtmp3, vec_enc);\n+  vpsrlq(dst, dst, 32, vec_enc);\n+}\n+\n+void C2_MacroAssembler::vector_count_leading_zeros_avx(BasicType bt, XMMRegister dst, XMMRegister src,\n+                                                       XMMRegister xtmp1, XMMRegister xtmp2, XMMRegister xtmp3,\n+                                                       Register rtmp, int vec_enc) {\n+  assert(is_integral_type(bt), \"unexpected type\");\n+  assert(vec_enc < Assembler::AVX_512bit, \"\");\n+  switch(bt) {\n+    case T_LONG:\n+      vector_count_leading_zeros_long_avx(dst, src, xtmp1, xtmp2, xtmp3, rtmp, vec_enc);\n+      break;\n+    case T_INT:\n+      vector_count_leading_zeros_int_avx(dst, src, xtmp1, xtmp2, xtmp3, vec_enc);\n+      break;\n+    case T_SHORT:\n+      vector_count_leading_zeros_short_avx(dst, src, xtmp1, xtmp2, xtmp3, rtmp, vec_enc);\n+      break;\n+    case T_BYTE:\n+      vector_count_leading_zeros_byte_avx(dst, src, xtmp1, xtmp2, xtmp3, rtmp, vec_enc);\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+  }\n+}\n+\n+void C2_MacroAssembler::vpsub(BasicType bt, XMMRegister dst, XMMRegister src1, XMMRegister src2, int vec_enc) {\n+  switch(bt) {\n+    case T_BYTE:\n+      vpsubb(dst, src1, src2, vec_enc);\n+      break;\n+    case T_SHORT:\n+      vpsubw(dst, src1, src2, vec_enc);\n+      break;\n+    case T_INT:\n+      vpsubd(dst, src1, src2, vec_enc);\n+      break;\n+    case T_LONG:\n+      vpsubq(dst, src1, src2, vec_enc);\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+  }\n+}\n+\n+void C2_MacroAssembler::vpadd(BasicType bt, XMMRegister dst, XMMRegister src1, XMMRegister src2, int vec_enc) {\n+  switch(bt) {\n+    case T_BYTE:\n+      vpaddb(dst, src1, src2, vec_enc);\n+      break;\n+    case T_SHORT:\n+      vpaddw(dst, src1, src2, vec_enc);\n+      break;\n+    case T_INT:\n+      vpaddd(dst, src1, src2, vec_enc);\n+      break;\n+    case T_LONG:\n+      vpaddq(dst, src1, src2, vec_enc);\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+  }\n+}\n+\n+\/\/ Trailing zero count computation is based on leading zero count operation as per\n+\/\/ following equation. All AVX3 targets support AVX512CD feature which offers\n+\/\/ direct vector instruction to compute leading zero count.\n+\/\/      CTZ = PRIM_TYPE_WIDHT - CLZ((x - 1) & ~x)\n+void C2_MacroAssembler::vector_count_trailing_zeros_evex(BasicType bt, XMMRegister dst, XMMRegister src,\n+                                                         XMMRegister xtmp1, XMMRegister xtmp2, XMMRegister xtmp3,\n+                                                         XMMRegister xtmp4, KRegister ktmp, Register rtmp, int vec_enc) {\n+  assert(is_integral_type(bt), \"\");\n+  \/\/ xtmp = -1\n+  vpternlogd(xtmp4, 0xff, xtmp4, xtmp4, vec_enc);\n+  \/\/ xtmp = xtmp + src\n+  vpadd(bt, xtmp4, xtmp4, src, vec_enc);\n+  \/\/ xtmp = xtmp & ~src\n+  vpternlogd(xtmp4, 0x40, xtmp4, src, vec_enc);\n+  vector_count_leading_zeros_evex(bt, dst, xtmp4, xtmp1, xtmp2, xtmp3, ktmp, rtmp, true, vec_enc);\n+  vbroadcast(bt, xtmp4, 8 * type2aelembytes(bt), rtmp, vec_enc);\n+  vpsub(bt, dst, xtmp4, dst, vec_enc);\n+}\n+\n+\/\/ Trailing zero count computation for AVX2 targets is based on popcount operation as per following equation\n+\/\/      CTZ = PRIM_TYPE_WIDHT - POPC(x | -x)\n+void C2_MacroAssembler::vector_count_trailing_zeros_avx(BasicType bt, XMMRegister dst, XMMRegister src, XMMRegister xtmp1,\n+                                                        XMMRegister xtmp2, XMMRegister xtmp3, Register rtmp, int vec_enc) {\n+  assert(is_integral_type(bt), \"\");\n+  \/\/ xtmp = 0\n+  vpxor(xtmp3 , xtmp3, xtmp3, vec_enc);\n+  \/\/ xtmp = 0 - src\n+  vpsub(bt, xtmp3, xtmp3, src, vec_enc);\n+  \/\/ xtmp = xtmp | src\n+  vpor(xtmp3, xtmp3, src, vec_enc);\n+  vector_popcount_integral(bt, dst, xtmp3, xtmp1, xtmp2, rtmp, vec_enc);\n+  vbroadcast(bt, xtmp1, 8 * type2aelembytes(bt), rtmp, vec_enc);\n+  vpsub(bt, dst, xtmp1, dst, vec_enc);\n+}\n+\n@@ -4742,1 +5257,0 @@\n-\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":566,"deletions":52,"binary":false,"changes":618,"status":"modified"},{"patch":"@@ -91,0 +91,5 @@\n+  void vector_compress_expand(int opcode, XMMRegister dst, XMMRegister src, KRegister mask,\n+                              bool merge, BasicType bt, int vec_enc);\n+\n+  void vector_mask_compress(KRegister dst, KRegister src, Register rtmp1, Register rtmp2, int mask_len);\n+\n@@ -337,0 +342,10 @@\n+  void udivI(Register rax, Register divisor, Register rdx);\n+  void umodI(Register rax, Register divisor, Register rdx);\n+  void udivmodI(Register rax, Register divisor, Register rdx, Register tmp);\n+\n+#ifdef _LP64\n+  void udivL(Register rax, Register divisor, Register rdx);\n+  void umodL(Register rax, Register divisor, Register rdx);\n+  void udivmodL(Register rax, Register divisor, Register rdx, Register tmp);\n+#endif\n+\n@@ -343,2 +358,2 @@\n-  void vector_signum_avx(int opcode, XMMRegister dst, XMMRegister src, XMMRegister zero, XMMRegister one,\n-                         XMMRegister xtmp1, int vec_enc);\n+  void vector_reverse_bit(BasicType bt, XMMRegister dst, XMMRegister src, XMMRegister xtmp1,\n+                          XMMRegister xtmp2, Register rtmp, int vec_enc);\n@@ -346,2 +361,2 @@\n-  void vector_signum_evex(int opcode, XMMRegister dst, XMMRegister src, XMMRegister zero, XMMRegister one,\n-                          KRegister ktmp1, int vec_enc);\n+  void vector_reverse_bit_gfni(BasicType bt, XMMRegister dst, XMMRegister src, XMMRegister xtmp,\n+                               AddressLiteral mask, Register rtmp, int vec_enc);\n@@ -349,9 +364,1 @@\n-  void udivI(Register rax, Register divisor, Register rdx);\n-  void umodI(Register rax, Register divisor, Register rdx);\n-  void udivmodI(Register rax, Register divisor, Register rdx, Register tmp);\n-\n-  #ifdef _LP64\n-  void udivL(Register rax, Register divisor, Register rdx);\n-  void umodL(Register rax, Register divisor, Register rdx);\n-  void udivmodL(Register rax, Register divisor, Register rdx, Register tmp);\n-  #endif\n+  void vector_reverse_byte(BasicType bt, XMMRegister dst, XMMRegister src, Register rtmp, int vec_enc);\n@@ -360,2 +367,1 @@\n-                           XMMRegister xtmp2, XMMRegister xtmp3, Register rtmp,\n-                           int vec_enc);\n+                           XMMRegister xtmp2, Register rtmp, int vec_enc);\n@@ -364,2 +370,1 @@\n-                            XMMRegister xtmp2, XMMRegister xtmp3, Register rtmp,\n-                            int vec_enc);\n+                            XMMRegister xtmp2, Register rtmp, int vec_enc);\n@@ -367,0 +372,53 @@\n+  void vector_popcount_short(XMMRegister dst, XMMRegister src, XMMRegister xtmp1,\n+                             XMMRegister xtmp2, Register rtmp, int vec_enc);\n+\n+  void vector_popcount_byte(XMMRegister dst, XMMRegister src, XMMRegister xtmp1,\n+                            XMMRegister xtmp2, Register rtmp, int vec_enc);\n+\n+  void vector_popcount_integral(BasicType bt, XMMRegister dst, XMMRegister src, XMMRegister xtmp1,\n+                                XMMRegister xtmp2, Register rtmp, int vec_enc);\n+\n+  void vector_popcount_integral_evex(BasicType bt, XMMRegister dst, XMMRegister src,\n+                                     KRegister mask, bool merge, int vec_enc);\n+\n+  void vbroadcast(BasicType bt, XMMRegister dst, int imm32, Register rtmp, int vec_enc);\n+\n+  void vector_reverse_byte64(BasicType bt, XMMRegister dst, XMMRegister src, XMMRegister xtmp1,\n+                             XMMRegister xtmp2, Register rtmp, int vec_enc);\n+\n+\n+  void vector_count_leading_zeros_evex(BasicType bt, XMMRegister dst, XMMRegister src,\n+                                       XMMRegister xtmp1, XMMRegister xtmp2, XMMRegister xtmp3,\n+                                       KRegister ktmp, Register rtmp, bool merge, int vec_enc);\n+\n+  void vector_count_leading_zeros_byte_avx(XMMRegister dst, XMMRegister src, XMMRegister xtmp1,\n+                                           XMMRegister xtmp2, XMMRegister xtmp3, Register rtmp, int vec_enc);\n+\n+  void vector_count_leading_zeros_short_avx(XMMRegister dst, XMMRegister src, XMMRegister xtmp1,\n+                                            XMMRegister xtmp2, XMMRegister xtmp3, Register rtmp, int vec_enc);\n+\n+  void vector_count_leading_zeros_int_avx(XMMRegister dst, XMMRegister src, XMMRegister xtmp1,\n+                                          XMMRegister xtmp2, XMMRegister xtmp3, int vec_enc);\n+\n+  void vector_count_leading_zeros_long_avx(XMMRegister dst, XMMRegister src, XMMRegister xtmp1,\n+                                           XMMRegister xtmp2, XMMRegister xtmp3, Register rtmp, int vec_enc);\n+\n+  void vector_count_leading_zeros_avx(BasicType bt, XMMRegister dst, XMMRegister src, XMMRegister xtmp1,\n+                                      XMMRegister xtmp2, XMMRegister xtmp3, Register rtmp, int vec_enc);\n+\n+  void vpadd(BasicType bt, XMMRegister dst, XMMRegister src1, XMMRegister src2, int vec_enc);\n+\n+  void vpsub(BasicType bt, XMMRegister dst, XMMRegister src1, XMMRegister src2, int vec_enc);\n+\n+  void vector_count_trailing_zeros_evex(BasicType bt, XMMRegister dst, XMMRegister src, XMMRegister xtmp1,\n+                                        XMMRegister xtmp2, XMMRegister xtmp3, XMMRegister xtmp4, KRegister ktmp,\n+                                        Register rtmp, int vec_enc);\n+\n+  void vector_count_trailing_zeros_avx(BasicType bt, XMMRegister dst, XMMRegister src, XMMRegister xtmp1,\n+                                       XMMRegister xtmp2, XMMRegister xtmp3, Register rtmp, int vec_enc);\n+\n+  void vector_signum_avx(int opcode, XMMRegister dst, XMMRegister src, XMMRegister zero, XMMRegister one,\n+                         XMMRegister xtmp1, int vec_enc);\n+\n+  void vector_signum_evex(int opcode, XMMRegister dst, XMMRegister src, XMMRegister zero, XMMRegister one,\n+                          KRegister ktmp1, int vec_enc);\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.hpp","additions":75,"deletions":17,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -2587,2 +2587,3 @@\n-  assert(vector_len <= AVX_256bit, \"AVX2 vector length\");\n-  if (vector_len == AVX_256bit) {\n+  if (vector_len == AVX_512bit) {\n+    evmovdquq(dst, src, AVX_512bit, scratch_reg);\n+  } else if (vector_len == AVX_256bit) {\n@@ -3239,0 +3240,9 @@\n+void MacroAssembler::vpbroadcastq(XMMRegister dst, AddressLiteral src, int vector_len, Register rscratch) {\n+  if (reachable(src)) {\n+    Assembler::vpbroadcastq(dst, as_Address(src), vector_len);\n+  } else {\n+    lea(rscratch, src);\n+    Assembler::vpbroadcastq(dst, Address(rscratch, 0), vector_len);\n+  }\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":12,"deletions":2,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -1353,0 +1353,5 @@\n+  void vpbroadcastq(XMMRegister dst, AddressLiteral src, int vector_len, Register rscratch = rscratch1);\n+  void vpbroadcastq(XMMRegister dst, XMMRegister src, int vector_len) { Assembler::vpbroadcastq(dst, src, vector_len); }\n+  void vpbroadcastq(XMMRegister dst, Address src, int vector_len) { Assembler::vpbroadcastq(dst, src, vector_len); }\n+\n+\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -189,3 +189,16 @@\n-      default: return 0;\n-      case Op_PopCountVI: return VM_Version::supports_avx512_vpopcntdq() ? 0 : 50;\n-      case Op_PopCountVL: return VM_Version::supports_avx512_vpopcntdq() ? 0 : 40;\n+      default:\n+        return 0;\n+      case Op_CountTrailingZerosV:\n+      case Op_CountLeadingZerosV:\n+        return VM_Version::supports_avx512cd() && (ety == T_INT || ety == T_LONG) ? 0 : 40;\n+      case Op_PopCountVI:\n+        if (is_subword_type(ety)) {\n+          return VM_Version::supports_avx512_bitalg() ? 0 : 50;\n+        } else {\n+          assert(ety == T_INT, \"sanity\"); \/\/ for documentation purposes\n+          return VM_Version::supports_avx512_vpopcntdq() ? 0 : 50;\n+        }\n+      case Op_PopCountVL:\n+        return VM_Version::supports_avx512_vpopcntdq() ? 0 : 40;\n+      case Op_ReverseV:\n+        return VM_Version::supports_gfni() ? 0 : 30;\n@@ -198,0 +211,1 @@\n+\n","filename":"src\/hotspot\/cpu\/x86\/matcher_x86.hpp","additions":17,"deletions":3,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -591,0 +591,24 @@\n+  address generate_count_leading_zeros_lut(const char *stub_name) {\n+    __ align64();\n+    StubCodeMark mark(this, \"StubRoutines\", stub_name);\n+    address start = __ pc();\n+    __ emit_data(0x02020304, relocInfo::none, 0);\n+    __ emit_data(0x01010101, relocInfo::none, 0);\n+    __ emit_data(0x00000000, relocInfo::none, 0);\n+    __ emit_data(0x00000000, relocInfo::none, 0);\n+    __ emit_data(0x02020304, relocInfo::none, 0);\n+    __ emit_data(0x01010101, relocInfo::none, 0);\n+    __ emit_data(0x00000000, relocInfo::none, 0);\n+    __ emit_data(0x00000000, relocInfo::none, 0);\n+    __ emit_data(0x02020304, relocInfo::none, 0);\n+    __ emit_data(0x01010101, relocInfo::none, 0);\n+    __ emit_data(0x00000000, relocInfo::none, 0);\n+    __ emit_data(0x00000000, relocInfo::none, 0);\n+    __ emit_data(0x02020304, relocInfo::none, 0);\n+    __ emit_data(0x01010101, relocInfo::none, 0);\n+    __ emit_data(0x00000000, relocInfo::none, 0);\n+    __ emit_data(0x00000000, relocInfo::none, 0);\n+    return start;\n+  }\n+\n+\n@@ -638,0 +662,92 @@\n+  address generate_vector_reverse_bit_lut(const char *stub_name) {\n+    __ align(CodeEntryAlignment);\n+    StubCodeMark mark(this, \"StubRoutines\", stub_name);\n+    address start = __ pc();\n+    __ emit_data(0x0C040800, relocInfo::none, 0);\n+    __ emit_data(0x0E060A02, relocInfo::none, 0);\n+    __ emit_data(0x0D050901, relocInfo::none, 0);\n+    __ emit_data(0x0F070B03, relocInfo::none, 0);\n+    __ emit_data(0x0C040800, relocInfo::none, 0);\n+    __ emit_data(0x0E060A02, relocInfo::none, 0);\n+    __ emit_data(0x0D050901, relocInfo::none, 0);\n+    __ emit_data(0x0F070B03, relocInfo::none, 0);\n+    __ emit_data(0x0C040800, relocInfo::none, 0);\n+    __ emit_data(0x0E060A02, relocInfo::none, 0);\n+    __ emit_data(0x0D050901, relocInfo::none, 0);\n+    __ emit_data(0x0F070B03, relocInfo::none, 0);\n+    __ emit_data(0x0C040800, relocInfo::none, 0);\n+    __ emit_data(0x0E060A02, relocInfo::none, 0);\n+    __ emit_data(0x0D050901, relocInfo::none, 0);\n+    __ emit_data(0x0F070B03, relocInfo::none, 0);\n+    return start;\n+  }\n+\n+  address generate_vector_reverse_byte_perm_mask_long(const char *stub_name) {\n+    __ align(CodeEntryAlignment);\n+    StubCodeMark mark(this, \"StubRoutines\", stub_name);\n+    address start = __ pc();\n+    __ emit_data(0x04050607, relocInfo::none, 0);\n+    __ emit_data(0x00010203, relocInfo::none, 0);\n+    __ emit_data(0x0C0D0E0F, relocInfo::none, 0);\n+    __ emit_data(0x08090A0B, relocInfo::none, 0);\n+    __ emit_data(0x04050607, relocInfo::none, 0);\n+    __ emit_data(0x00010203, relocInfo::none, 0);\n+    __ emit_data(0x0C0D0E0F, relocInfo::none, 0);\n+    __ emit_data(0x08090A0B, relocInfo::none, 0);\n+    __ emit_data(0x04050607, relocInfo::none, 0);\n+    __ emit_data(0x00010203, relocInfo::none, 0);\n+    __ emit_data(0x0C0D0E0F, relocInfo::none, 0);\n+    __ emit_data(0x08090A0B, relocInfo::none, 0);\n+    __ emit_data(0x04050607, relocInfo::none, 0);\n+    __ emit_data(0x00010203, relocInfo::none, 0);\n+    __ emit_data(0x0C0D0E0F, relocInfo::none, 0);\n+    __ emit_data(0x08090A0B, relocInfo::none, 0);\n+    return start;\n+  }\n+\n+  address generate_vector_reverse_byte_perm_mask_int(const char *stub_name) {\n+    __ align(CodeEntryAlignment);\n+    StubCodeMark mark(this, \"StubRoutines\", stub_name);\n+    address start = __ pc();\n+    __ emit_data(0x00010203, relocInfo::none, 0);\n+    __ emit_data(0x04050607, relocInfo::none, 0);\n+    __ emit_data(0x08090A0B, relocInfo::none, 0);\n+    __ emit_data(0x0C0D0E0F, relocInfo::none, 0);\n+    __ emit_data(0x00010203, relocInfo::none, 0);\n+    __ emit_data(0x04050607, relocInfo::none, 0);\n+    __ emit_data(0x08090A0B, relocInfo::none, 0);\n+    __ emit_data(0x0C0D0E0F, relocInfo::none, 0);\n+    __ emit_data(0x00010203, relocInfo::none, 0);\n+    __ emit_data(0x04050607, relocInfo::none, 0);\n+    __ emit_data(0x08090A0B, relocInfo::none, 0);\n+    __ emit_data(0x0C0D0E0F, relocInfo::none, 0);\n+    __ emit_data(0x00010203, relocInfo::none, 0);\n+    __ emit_data(0x04050607, relocInfo::none, 0);\n+    __ emit_data(0x08090A0B, relocInfo::none, 0);\n+    __ emit_data(0x0C0D0E0F, relocInfo::none, 0);\n+    return start;\n+  }\n+\n+  address generate_vector_reverse_byte_perm_mask_short(const char *stub_name) {\n+    __ align(CodeEntryAlignment);\n+    StubCodeMark mark(this, \"StubRoutines\", stub_name);\n+    address start = __ pc();\n+    __ emit_data(0x02030001, relocInfo::none, 0);\n+    __ emit_data(0x06070405, relocInfo::none, 0);\n+    __ emit_data(0x0A0B0809, relocInfo::none, 0);\n+    __ emit_data(0x0E0F0C0D, relocInfo::none, 0);\n+    __ emit_data(0x02030001, relocInfo::none, 0);\n+    __ emit_data(0x06070405, relocInfo::none, 0);\n+    __ emit_data(0x0A0B0809, relocInfo::none, 0);\n+    __ emit_data(0x0E0F0C0D, relocInfo::none, 0);\n+    __ emit_data(0x02030001, relocInfo::none, 0);\n+    __ emit_data(0x06070405, relocInfo::none, 0);\n+    __ emit_data(0x0A0B0809, relocInfo::none, 0);\n+    __ emit_data(0x0E0F0C0D, relocInfo::none, 0);\n+    __ emit_data(0x02030001, relocInfo::none, 0);\n+    __ emit_data(0x06070405, relocInfo::none, 0);\n+    __ emit_data(0x0A0B0809, relocInfo::none, 0);\n+    __ emit_data(0x0E0F0C0D, relocInfo::none, 0);\n+    return start;\n+  }\n+\n@@ -3988,0 +4104,5 @@\n+    StubRoutines::x86::_vector_count_leading_zeros_lut = generate_count_leading_zeros_lut(\"count_leading_zeros_lut\");\n+    StubRoutines::x86::_vector_reverse_bit_lut = generate_vector_reverse_bit_lut(\"reverse_bit_lut\");\n+    StubRoutines::x86::_vector_reverse_byte_perm_mask_long = generate_vector_reverse_byte_perm_mask_long(\"perm_mask_long\");\n+    StubRoutines::x86::_vector_reverse_byte_perm_mask_int = generate_vector_reverse_byte_perm_mask_int(\"perm_mask_int\");\n+    StubRoutines::x86::_vector_reverse_byte_perm_mask_short = generate_vector_reverse_byte_perm_mask_short(\"perm_mask_short\");\n@@ -3989,1 +4110,1 @@\n-    if (UsePopCountInstruction && VM_Version::supports_avx2() && !VM_Version::supports_avx512_vpopcntdq()) {\n+    if (VM_Version::supports_avx2() && !VM_Version::supports_avx512_vpopcntdq()) {\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_32.cpp","additions":122,"deletions":1,"binary":false,"changes":123,"status":"modified"},{"patch":"@@ -810,0 +810,15 @@\n+  address generate_count_leading_zeros_lut(const char *stub_name) {\n+    __ align64();\n+    StubCodeMark mark(this, \"StubRoutines\", stub_name);\n+    address start = __ pc();\n+    __ emit_data64(0x0101010102020304, relocInfo::none);\n+    __ emit_data64(0x0000000000000000, relocInfo::none);\n+    __ emit_data64(0x0101010102020304, relocInfo::none);\n+    __ emit_data64(0x0000000000000000, relocInfo::none);\n+    __ emit_data64(0x0101010102020304, relocInfo::none);\n+    __ emit_data64(0x0000000000000000, relocInfo::none);\n+    __ emit_data64(0x0101010102020304, relocInfo::none);\n+    __ emit_data64(0x0000000000000000, relocInfo::none);\n+    return start;\n+  }\n+\n@@ -840,0 +855,60 @@\n+  address generate_vector_reverse_bit_lut(const char *stub_name) {\n+    __ align(CodeEntryAlignment);\n+    StubCodeMark mark(this, \"StubRoutines\", stub_name);\n+    address start = __ pc();\n+    __ emit_data64(0x0E060A020C040800, relocInfo::none);\n+    __ emit_data64(0x0F070B030D050901, relocInfo::none);\n+    __ emit_data64(0x0E060A020C040800, relocInfo::none);\n+    __ emit_data64(0x0F070B030D050901, relocInfo::none);\n+    __ emit_data64(0x0E060A020C040800, relocInfo::none);\n+    __ emit_data64(0x0F070B030D050901, relocInfo::none);\n+    __ emit_data64(0x0E060A020C040800, relocInfo::none);\n+    __ emit_data64(0x0F070B030D050901, relocInfo::none);\n+    return start;\n+  }\n+\n+  address generate_vector_reverse_byte_perm_mask_long(const char *stub_name) {\n+    __ align(CodeEntryAlignment);\n+    StubCodeMark mark(this, \"StubRoutines\", stub_name);\n+    address start = __ pc();\n+    __ emit_data64(0x0001020304050607, relocInfo::none);\n+    __ emit_data64(0x08090A0B0C0D0E0F, relocInfo::none);\n+    __ emit_data64(0x0001020304050607, relocInfo::none);\n+    __ emit_data64(0x08090A0B0C0D0E0F, relocInfo::none);\n+    __ emit_data64(0x0001020304050607, relocInfo::none);\n+    __ emit_data64(0x08090A0B0C0D0E0F, relocInfo::none);\n+    __ emit_data64(0x0001020304050607, relocInfo::none);\n+    __ emit_data64(0x08090A0B0C0D0E0F, relocInfo::none);\n+    return start;\n+  }\n+\n+  address generate_vector_reverse_byte_perm_mask_int(const char *stub_name) {\n+    __ align(CodeEntryAlignment);\n+    StubCodeMark mark(this, \"StubRoutines\", stub_name);\n+    address start = __ pc();\n+    __ emit_data64(0x0405060700010203, relocInfo::none);\n+    __ emit_data64(0x0C0D0E0F08090A0B, relocInfo::none);\n+    __ emit_data64(0x0405060700010203, relocInfo::none);\n+    __ emit_data64(0x0C0D0E0F08090A0B, relocInfo::none);\n+    __ emit_data64(0x0405060700010203, relocInfo::none);\n+    __ emit_data64(0x0C0D0E0F08090A0B, relocInfo::none);\n+    __ emit_data64(0x0405060700010203, relocInfo::none);\n+    __ emit_data64(0x0C0D0E0F08090A0B, relocInfo::none);\n+    return start;\n+  }\n+\n+  address generate_vector_reverse_byte_perm_mask_short(const char *stub_name) {\n+    __ align(CodeEntryAlignment);\n+    StubCodeMark mark(this, \"StubRoutines\", stub_name);\n+    address start = __ pc();\n+    __ emit_data64(0x0607040502030001, relocInfo::none);\n+    __ emit_data64(0x0E0F0C0D0A0B0809, relocInfo::none);\n+    __ emit_data64(0x0607040502030001, relocInfo::none);\n+    __ emit_data64(0x0E0F0C0D0A0B0809, relocInfo::none);\n+    __ emit_data64(0x0607040502030001, relocInfo::none);\n+    __ emit_data64(0x0E0F0C0D0A0B0809, relocInfo::none);\n+    __ emit_data64(0x0607040502030001, relocInfo::none);\n+    __ emit_data64(0x0E0F0C0D0A0B0809, relocInfo::none);\n+    return start;\n+  }\n+\n@@ -7952,0 +8027,5 @@\n+    StubRoutines::x86::_vector_count_leading_zeros_lut = generate_count_leading_zeros_lut(\"count_leading_zeros_lut\");\n+    StubRoutines::x86::_vector_reverse_bit_lut = generate_vector_reverse_bit_lut(\"reverse_bit_lut\");\n+    StubRoutines::x86::_vector_reverse_byte_perm_mask_long = generate_vector_reverse_byte_perm_mask_long(\"perm_mask_long\");\n+    StubRoutines::x86::_vector_reverse_byte_perm_mask_int = generate_vector_reverse_byte_perm_mask_int(\"perm_mask_int\");\n+    StubRoutines::x86::_vector_reverse_byte_perm_mask_short = generate_vector_reverse_byte_perm_mask_short(\"perm_mask_short\");\n@@ -7953,1 +8033,1 @@\n-    if (UsePopCountInstruction && VM_Version::supports_avx2() && !VM_Version::supports_avx512_vpopcntdq()) {\n+    if (VM_Version::supports_avx2() && !VM_Version::supports_avx512_vpopcntdq()) {\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.cpp","additions":81,"deletions":1,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -62,0 +62,4 @@\n+address StubRoutines::x86::_vector_reverse_bit_lut = NULL;\n+address StubRoutines::x86::_vector_reverse_byte_perm_mask_long = NULL;\n+address StubRoutines::x86::_vector_reverse_byte_perm_mask_int = NULL;\n+address StubRoutines::x86::_vector_reverse_byte_perm_mask_short = NULL;\n@@ -63,0 +67,1 @@\n+address StubRoutines::x86::_vector_count_leading_zeros_lut = NULL;\n","filename":"src\/hotspot\/cpu\/x86\/stubRoutines_x86.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -181,0 +181,5 @@\n+  static address _vector_count_leading_zeros_lut;\n+  static address _vector_reverse_bit_lut;\n+  static address _vector_reverse_byte_perm_mask_long;\n+  static address _vector_reverse_byte_perm_mask_int;\n+  static address _vector_reverse_byte_perm_mask_short;\n@@ -344,0 +349,20 @@\n+  static address vector_count_leading_zeros_lut() {\n+    return _vector_count_leading_zeros_lut;\n+  }\n+\n+  static address vector_reverse_bit_lut() {\n+    return _vector_reverse_bit_lut;\n+  }\n+\n+  static address vector_reverse_byte_perm_mask_long() {\n+    return _vector_reverse_byte_perm_mask_long;\n+  }\n+\n+  static address vector_reverse_byte_perm_mask_int() {\n+    return _vector_reverse_byte_perm_mask_int;\n+  }\n+\n+  static address vector_reverse_byte_perm_mask_short() {\n+    return _vector_reverse_byte_perm_mask_short;\n+  }\n+\n","filename":"src\/hotspot\/cpu\/x86\/stubRoutines_x86.hpp","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -925,0 +925,1 @@\n+    _features &= ~CPU_AVX512_BITALG;\n@@ -954,0 +955,2 @@\n+      _features &= ~CPU_GFNI;\n+      _features &= ~CPU_AVX512_BITALG;\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -373,1 +373,0 @@\n-                                                     \\\n@@ -376,1 +375,3 @@\n-    decl(FSRM,              \"fsrm\",              50) \/* Fast Short REP MOV *\/\n+    decl(FSRM,              \"fsrm\",              50) \/* Fast Short REP MOV *\/ \\\n+    decl(GFNI,              \"gfni\",              51) \/* Vector GFNI instructions *\/ \\\n+    decl(AVX512_BITALG,     \"avx512_bitalg\",     52) \/* Vector sub-word popcount and bit gather instructions *\/\n@@ -606,0 +607,2 @@\n+        if (_cpuid_info.sef_cpuid7_ecx.bits.gfni != 0)\n+          result |= CPU_GFNI;\n@@ -608,0 +611,2 @@\n+        if (_cpuid_info.sef_cpuid7_ecx.bits.avx512_bitalg != 0)\n+          result |= CPU_AVX512_BITALG;\n@@ -921,0 +926,1 @@\n+  static bool supports_gfni()         { return (_features & CPU_GFNI) != 0; }\n@@ -922,0 +928,1 @@\n+  static bool supports_avx512_bitalg()  { return (_features & CPU_AVX512_BITALG) != 0; }\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.hpp","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -1244,0 +1244,5 @@\n+static inline bool is_vector_popcount_predicate(BasicType bt) {\n+  return (is_subword_type(bt) && VM_Version::supports_avx512_bitalg()) ||\n+         (is_non_subword_integral_type(bt) && VM_Version::supports_avx512_vpopcntdq());\n+}\n+\n@@ -1248,0 +1253,5 @@\n+static inline bool is_clz_non_subword_predicate_evex(BasicType bt, int vlen_bytes) {\n+  return is_non_subword_integral_type(bt) && VM_Version::supports_avx512cd() &&\n+           (VM_Version::supports_avx512vl() || vlen_bytes == 64);\n+}\n+\n@@ -1408,1 +1418,1 @@\n-      if (!UsePopCountInstruction || (UseAVX < 2)) {\n+      if (UseAVX < 2) {\n@@ -1413,1 +1423,1 @@\n-      if (!UsePopCountInstruction || (UseAVX <= 2)) {\n+      if (UseAVX < 2) {\n@@ -1628,0 +1638,11 @@\n+    case Op_CompressM:\n+      if (!VM_Version::supports_avx512vl() || !VM_Version::supports_bmi2()) {\n+        return false;\n+      }\n+      break;\n+    case Op_CompressV:\n+    case Op_ExpandV:\n+      if (!VM_Version::supports_avx512vl()) {\n+        return false;\n+      }\n+      break;\n@@ -1649,0 +1670,5 @@\n+static inline bool is_pop_count_instr_target(BasicType bt) {\n+  return (is_subword_type(bt) && VM_Version::supports_avx512_bitalg()) ||\n+         (is_non_subword_integral_type(bt) && VM_Version::supports_avx512_vpopcntdq());\n+}\n+\n@@ -1854,1 +1880,1 @@\n-      if(is_subword_type(bt)) {\n+      if (is_subword_type(bt)) {\n@@ -1881,0 +1907,17 @@\n+    case Op_CompressM:\n+      if (UseAVX < 3 || !VM_Version::supports_bmi2()) {\n+        return false;\n+      }\n+      break;\n+    case Op_CompressV:\n+    case Op_ExpandV:\n+      if (is_subword_type(bt) && !VM_Version::supports_avx512_vbmi2()) {\n+        return false;\n+      }\n+      if (size_in_bits < 128 ) {\n+        return false;\n+      }\n+      if (size_in_bits < 512 && !VM_Version::supports_avx512vl()) {\n+        return false;\n+      }\n+      break;\n@@ -1896,2 +1939,10 @@\n-      if (!VM_Version::supports_avx512_vpopcntdq() &&\n-          (vlen == 16) && !VM_Version::supports_avx512bw()) {\n+    case Op_PopCountVL: {\n+        if (!is_pop_count_instr_target(bt) &&\n+            (size_in_bits == 512) && !VM_Version::supports_avx512bw()) {\n+          return false;\n+        }\n+      }\n+      break;\n+    case Op_ReverseV:\n+    case Op_ReverseBytesV:\n+      if (UseAVX < 2) {\n@@ -1901,3 +1952,3 @@\n-    case Op_PopCountVL:\n-      if (!VM_Version::supports_avx512_vpopcntdq() &&\n-          ((vlen <= 4) || ((vlen == 8) && !VM_Version::supports_avx512bw()))) {\n+    case Op_CountTrailingZerosV:\n+    case Op_CountLeadingZerosV:\n+      if (UseAVX < 2) {\n@@ -2051,0 +2102,7 @@\n+    case Op_PopCountVI:\n+    case Op_PopCountVL:\n+      if (!is_pop_count_instr_target(bt)) {\n+        return false;\n+      }\n+      return true;\n+\n@@ -2054,0 +2112,4 @@\n+    case Op_CountLeadingZerosV:\n+      if (is_non_subword_integral_type(bt) && VM_Version::supports_avx512cd()) {\n+        return true;\n+      }\n@@ -8681,2 +8743,2 @@\n-instruct vpopcountI_popcntd(vec dst, vec src) %{\n-  predicate(VM_Version::supports_avx512_vpopcntdq());\n+instruct vpopcount_integral_reg_evex(vec dst, vec src) %{\n+  predicate(is_vector_popcount_predicate(Matcher::vector_element_basic_type(n->in(1))));\n@@ -8684,1 +8746,3 @@\n-  format %{ \"vector_popcount_int $dst, $src\\t! vector popcount packedI\" %}\n+  match(Set dst (PopCountVL src));\n+  ins_cost(400);\n+  format %{ \"vector_popcount_integral $dst, $src\" %}\n@@ -8686,3 +8750,10 @@\n-    assert(UsePopCountInstruction, \"not enabled\");\n-    int vlen_enc = vector_length_encoding(this);\n-    __ vector_popcount_int($dst$$XMMRegister, $src$$XMMRegister, xnoreg, xnoreg, xnoreg, noreg, vlen_enc);\n+    int opcode = this->ideal_Opcode();\n+    int vlen_enc = vector_length_encoding(this, $src);\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n+    __ vector_popcount_integral_evex(bt, $dst$$XMMRegister, $src$$XMMRegister, k0, true, vlen_enc);\n+    \/\/ TODO: Once auto-vectorizer supports ConvL2I operation, PopCountVL\n+    \/\/ should be succeeded by its corresponding vector IR and following\n+    \/\/ special handling should be removed.\n+    if (opcode == Op_PopCountVL && Matcher::vector_element_basic_type(this) == T_INT) {\n+      __ evpmovqd($dst$$XMMRegister, $dst$$XMMRegister, vlen_enc);\n+    }\n@@ -8693,5 +8764,5 @@\n-instruct vpopcountI(vec dst, vec src, vec xtmp1, vec xtmp2, vec xtmp3, rRegP rtmp, rFlagsReg cc) %{\n-  predicate(!VM_Version::supports_avx512_vpopcntdq());\n-  match(Set dst (PopCountVI src));\n-  effect(TEMP dst, TEMP xtmp1, TEMP xtmp2, TEMP xtmp3, TEMP rtmp, KILL cc);\n-  format %{ \"vector_popcount_int  $dst, $src\\t! using $xtmp1, $xtmp2, $xtmp3, and $rtmp as TEMP\" %}\n+instruct vpopcount_integral_reg_evex_masked(vec dst, vec src, kReg mask) %{\n+  predicate(is_vector_popcount_predicate(Matcher::vector_element_basic_type(n->in(1))));\n+  match(Set dst (PopCountVI src mask));\n+  match(Set dst (PopCountVL src mask));\n+  format %{ \"vector_popcount_integral_masked $dst, $src, $mask\" %}\n@@ -8699,4 +8770,4 @@\n-    assert(UsePopCountInstruction, \"not enabled\");\n-    int vlen_enc = vector_length_encoding(this);\n-    __ vector_popcount_int($dst$$XMMRegister, $src$$XMMRegister, $xtmp1$$XMMRegister, $xtmp2$$XMMRegister,\n-                           $xtmp3$$XMMRegister, $rtmp$$Register, vlen_enc);\n+    int vlen_enc = vector_length_encoding(this, $src);\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n+    __ evmovdquq($dst$$XMMRegister, $src$$XMMRegister, vlen_enc);\n+    __ vector_popcount_integral_evex(bt, $dst$$XMMRegister, $src$$XMMRegister, $mask$$KRegister, true, vlen_enc);\n@@ -8707,2 +8778,3 @@\n-instruct vpopcountL_popcntd(vec dst, vec src) %{\n-  predicate(VM_Version::supports_avx512_vpopcntdq());\n+instruct vpopcount_avx_reg(vec dst, vec src, vec xtmp1, vec xtmp2, rRegP rtmp) %{\n+  predicate(!is_vector_popcount_predicate(Matcher::vector_element_basic_type(n->in(1))));\n+  match(Set dst (PopCountVI src));\n@@ -8710,1 +8782,2 @@\n-  format %{ \"vector_popcount_long  $dst, $src\\t! vector popcount packedL\" %}\n+  effect(TEMP dst, TEMP xtmp1, TEMP xtmp2, TEMP rtmp);\n+  format %{ \"vector_popcount_integral $dst, $src\\t! using $xtmp1, $xtmp2, and $rtmp as TEMP\" %}\n@@ -8712,1 +8785,1 @@\n-    assert(UsePopCountInstruction, \"not enabled\");\n+    int opcode = this->ideal_Opcode();\n@@ -8714,1 +8787,15 @@\n-    __ vector_popcount_long($dst$$XMMRegister, $src$$XMMRegister, xnoreg, xnoreg, xnoreg, noreg, vlen_enc);\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n+    __ vector_popcount_integral(bt, $dst$$XMMRegister, $src$$XMMRegister, $xtmp1$$XMMRegister,\n+                                $xtmp2$$XMMRegister, $rtmp$$Register, vlen_enc);\n+    \/\/ TODO: Once auto-vectorizer supports ConvL2I operation, PopCountVL\n+    \/\/ should be succeeded by its corresponding vector IR and following\n+    \/\/ special handling should be removed.\n+    if (opcode == Op_PopCountVL && Matcher::vector_element_basic_type(this) == T_INT) {\n+      if (VM_Version::supports_avx512vl()) {\n+        __ evpmovqd($dst$$XMMRegister, $dst$$XMMRegister, vlen_enc);\n+      } else {\n+        assert(VM_Version::supports_avx2(), \"\");\n+        __ vpshufd($dst$$XMMRegister, $dst$$XMMRegister, 8, vlen_enc);\n+        __ vpermq($dst$$XMMRegister, $dst$$XMMRegister, 8, vlen_enc);\n+      }\n+    }\n@@ -8719,5 +8806,9 @@\n-instruct vpopcountL(vec dst, vec src, vec xtmp1, vec xtmp2, vec xtmp3, rRegP rtmp, rFlagsReg cc) %{\n-  predicate(!VM_Version::supports_avx512_vpopcntdq());\n-  match(Set dst (PopCountVL src));\n-  effect(TEMP dst, TEMP xtmp1, TEMP xtmp2, TEMP xtmp3, TEMP rtmp, KILL cc);\n-  format %{ \"vector_popcount_long  $dst, $src\\t! using $xtmp1, $xtmp2, $xtmp3, and $rtmp as TEMP\" %}\n+\/\/ --------------------------------- Vector Trailing Zeros Count --------------------------------------\n+\n+instruct vcount_trailing_zeros_reg_evex(vec dst, vec src, vec xtmp, rRegP rtmp) %{\n+  predicate(is_clz_non_subword_predicate_evex(Matcher::vector_element_basic_type(n->in(1)),\n+                                              Matcher::vector_length_in_bytes(n->in(1))));\n+  match(Set dst (CountTrailingZerosV src));\n+  effect(TEMP dst, TEMP xtmp, TEMP rtmp);\n+  ins_cost(400);\n+  format %{ \"vector_count_trailing_zeros $dst, $src!\\t using $xtmp and $rtmp as TEMP\" %}\n@@ -8725,1 +8816,0 @@\n-    assert(UsePopCountInstruction, \"not enabled\");\n@@ -8727,2 +8817,70 @@\n-    __ vector_popcount_long($dst$$XMMRegister, $src$$XMMRegister, $xtmp1$$XMMRegister, $xtmp2$$XMMRegister,\n-                           $xtmp3$$XMMRegister, $rtmp$$Register, vlen_enc);\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n+    BasicType rbt = Matcher::vector_element_basic_type(this);\n+    __ vector_count_trailing_zeros_evex(bt, $dst$$XMMRegister, $src$$XMMRegister, xnoreg,\n+                                        xnoreg, xnoreg, $xtmp$$XMMRegister, k0, $rtmp$$Register, vlen_enc);\n+    \/\/ TODO: Once auto-vectorizer supports ConvL2I operation, CountTrailingZerosV\n+    \/\/ should be succeeded by its corresponding vector IR and following\n+    \/\/ special handling should be removed.\n+    if (bt == T_LONG && rbt == T_INT) {\n+      __ evpmovqd($dst$$XMMRegister, $dst$$XMMRegister, vlen_enc);\n+    }\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct vcount_trailing_zeros_short_reg_evex(vec dst, vec src, vec xtmp1, vec xtmp2, vec xtmp3, rRegP rtmp) %{\n+  predicate(Matcher::vector_element_basic_type(n->in(1)) == T_SHORT &&\n+            VM_Version::supports_avx512cd() &&\n+            (VM_Version::supports_avx512vl() || Matcher::vector_length_in_bytes(n) == 64));\n+  match(Set dst (CountTrailingZerosV src));\n+  effect(TEMP dst, TEMP xtmp1, TEMP xtmp2, TEMP xtmp3, TEMP rtmp);\n+  ins_cost(400);\n+  format %{ \"vector_count_trailing_zeros $dst, $src!\\t using $xtmp1, $xtmp2, $xtmp3 and $rtmp as TEMP\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this, $src);\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n+    __ vector_count_trailing_zeros_evex(bt, $dst$$XMMRegister, $src$$XMMRegister, $xtmp1$$XMMRegister,\n+                                        $xtmp2$$XMMRegister, xnoreg, $xtmp3$$XMMRegister, k0, $rtmp$$Register, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct vcount_trailing_zeros_byte_reg_evex(vec dst, vec src, vec xtmp1, vec xtmp2, vec xtmp3, vec xtmp4, kReg ktmp, rRegP rtmp) %{\n+  predicate(Matcher::vector_element_basic_type(n->in(1)) == T_BYTE && VM_Version::supports_avx512vlbw());\n+  match(Set dst (CountTrailingZerosV src));\n+  effect(TEMP dst, TEMP xtmp1, TEMP xtmp2, TEMP xtmp3, TEMP xtmp4, TEMP ktmp, TEMP rtmp);\n+  ins_cost(400);\n+  format %{ \"vector_count_trailing_zeros $dst, $src!\\t using $xtmp1, $xtmp2, $xtmp3, $xtmp4, $ktmp and $rtmp as TEMP\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this, $src);\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n+    __ vector_count_trailing_zeros_evex(bt, $dst$$XMMRegister, $src$$XMMRegister, $xtmp1$$XMMRegister,\n+                                        $xtmp2$$XMMRegister, $xtmp3$$XMMRegister, $xtmp4$$XMMRegister,\n+                                        $ktmp$$KRegister, $rtmp$$Register, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct vcount_trailing_zeros_reg_avx(vec dst, vec src, vec xtmp1, vec xtmp2, vec xtmp3, rRegP rtmp) %{\n+  predicate(!VM_Version::supports_avx512vl() && Matcher::vector_length_in_bytes(n->in(1)) < 64);\n+  match(Set dst (CountTrailingZerosV src));\n+  effect(TEMP dst, TEMP xtmp1, TEMP xtmp2, TEMP xtmp3, TEMP rtmp);\n+  format %{ \"vector_count_trailing_zeros $dst, $src\\t! using $xtmp1, $xtmp2, $xtmp3, and $rtmp as TEMP\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this, $src);\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n+    BasicType rbt = Matcher::vector_element_basic_type(this);\n+    __ vector_count_trailing_zeros_avx(bt, $dst$$XMMRegister, $src$$XMMRegister, $xtmp1$$XMMRegister,\n+                                       $xtmp2$$XMMRegister, $xtmp3$$XMMRegister, $rtmp$$Register, vlen_enc);\n+    \/\/ TODO: Once auto-vectorizer supports ConvL2I operation, PopCountVL\n+    \/\/ should be succeeded by its corresponding vector IR and following\n+    \/\/ special handling should be removed.\n+    if (bt == T_LONG && rbt == T_INT) {\n+      if (VM_Version::supports_avx512vl()) {\n+        __ evpmovqd($dst$$XMMRegister, $dst$$XMMRegister, vlen_enc);\n+      } else {\n+        assert(VM_Version::supports_avx2(), \"\");\n+        __ vpshufd($dst$$XMMRegister, $dst$$XMMRegister, 8, vlen_enc);\n+        __ vpermq($dst$$XMMRegister, $dst$$XMMRegister, 8, vlen_enc);\n+      }\n+    }\n@@ -8733,0 +8891,1 @@\n+\n@@ -9007,0 +9166,28 @@\n+\n+\/\/ --------------------------------- Compress\/Expand Operations ---------------------------\n+\n+instruct vcompress_expand_reg_evex(vec dst, vec src, kReg mask) %{\n+  match(Set dst (CompressV src mask));\n+  match(Set dst (ExpandV src mask));\n+  format %{ \"vector_compress_expand $dst, $src, $mask\" %}\n+  ins_encode %{\n+    int opcode = this->ideal_Opcode();\n+    int vector_len = vector_length_encoding(this);\n+    BasicType bt  = Matcher::vector_element_basic_type(this);\n+    __ vector_compress_expand(opcode, $dst$$XMMRegister, $src$$XMMRegister, $mask$$KRegister, false, bt, vector_len);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct vcompress_mask_reg_evex(kReg dst, kReg mask, rRegL rtmp1, rRegL rtmp2, rFlagsReg cr) %{\n+  match(Set dst (CompressM mask));\n+  effect(TEMP rtmp1, TEMP rtmp2, KILL cr);\n+  format %{ \"mask_compress_evex $dst, $mask\\t! using $rtmp1 and $rtmp2 as TEMP\" %}\n+  ins_encode %{\n+    assert(this->in(1)->bottom_type()->isa_vectmask(), \"\");\n+    int mask_len = Matcher::vector_length(this);\n+    __ vector_mask_compress($dst$$KRegister, $mask$$KRegister, $rtmp1$$Register, $rtmp2$$Register, mask_len);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n@@ -9009,0 +9196,164 @@\n+\/\/ -------------------------------- Bit and Byte Reversal Vector Operations ------------------------\n+\n+instruct vreverse_reg(vec dst, vec src, vec xtmp1, vec xtmp2, rRegI rtmp) %{\n+  predicate(!VM_Version::supports_gfni());\n+  match(Set dst (ReverseV src));\n+  effect(TEMP dst, TEMP xtmp1, TEMP xtmp2, TEMP rtmp);\n+  format %{ \"vector_reverse_bit_evex $dst, $src!\\t using $xtmp1, $xtmp2 and $rtmp as TEMP\" %}\n+  ins_encode %{\n+    int vec_enc = vector_length_encoding(this);\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ vector_reverse_bit(bt, $dst$$XMMRegister, $src$$XMMRegister, $xtmp1$$XMMRegister,\n+                          $xtmp2$$XMMRegister, $rtmp$$Register, vec_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct vreverse_reg_gfni(vec dst, vec src, vec xtmp, rRegI rtmp) %{\n+  predicate(VM_Version::supports_gfni());\n+  match(Set dst (ReverseV src));\n+  effect(TEMP dst, TEMP xtmp, TEMP rtmp);\n+  format %{ \"vector_reverse_bit_gfni $dst, $src!\\t using $rtmp and $xtmp as TEMP\" %}\n+  ins_encode %{\n+    int vec_enc = vector_length_encoding(this);\n+    BasicType bt  = Matcher::vector_element_basic_type(this);\n+    InternalAddress addr = $constantaddress(T_LONG, vreplicate_imm(T_LONG, 0x8040201008040201L, 1));\n+    __ vector_reverse_bit_gfni(bt, $dst$$XMMRegister, $src$$XMMRegister, $xtmp$$XMMRegister,\n+                               addr, $rtmp$$Register, vec_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct vreverse_byte_reg(vec dst, vec src, rRegI rtmp) %{\n+  predicate(VM_Version::supports_avx512bw() || Matcher::vector_length_in_bytes(n) < 64);\n+  match(Set dst (ReverseBytesV src));\n+  effect(TEMP dst, TEMP rtmp);\n+  format %{ \"vector_reverse_byte $dst, $src!\\t using $rtmp as TEMP\" %}\n+  ins_encode %{\n+    int vec_enc = vector_length_encoding(this);\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ vector_reverse_byte(bt, $dst$$XMMRegister, $src$$XMMRegister, $rtmp$$Register, vec_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct vreverse_byte64_reg(vec dst, vec src, vec xtmp1, vec xtmp2, rRegI rtmp) %{\n+  predicate(!VM_Version::supports_avx512bw() && Matcher::vector_length_in_bytes(n) == 64);\n+  match(Set dst (ReverseBytesV src));\n+  effect(TEMP dst, TEMP xtmp1, TEMP xtmp2, TEMP rtmp);\n+  format %{ \"vector_reverse_byte $dst, $src!\\t using $xtmp1, $xtmp2 and $rtmp as TEMP\" %}\n+  ins_encode %{\n+    int vec_enc = vector_length_encoding(this);\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ vector_reverse_byte64(bt, $dst$$XMMRegister, $src$$XMMRegister, $xtmp1$$XMMRegister,\n+                             $xtmp2$$XMMRegister, $rtmp$$Register, vec_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+\/\/ ---------------------------------- Vector Count Leading Zeros -----------------------------------\n+\n+instruct vcount_leading_zeros_IL_reg_evex(vec dst, vec src) %{\n+  predicate(is_clz_non_subword_predicate_evex(Matcher::vector_element_basic_type(n->in(1)),\n+                                              Matcher::vector_length_in_bytes(n->in(1))));\n+  match(Set dst (CountLeadingZerosV src));\n+  format %{ \"vector_count_leading_zeros $dst, $src\" %}\n+  ins_encode %{\n+     int vlen_enc = vector_length_encoding(this, $src);\n+     BasicType bt = Matcher::vector_element_basic_type(this, $src);\n+     BasicType rbt = Matcher::vector_element_basic_type(this);\n+     __ vector_count_leading_zeros_evex(bt, $dst$$XMMRegister, $src$$XMMRegister, xnoreg,\n+                                        xnoreg, xnoreg, k0, noreg, true, vlen_enc);\n+     \/\/ TODO: Once auto-vectorizer supports ConvL2I operation, CountLeadingZerosV\n+     \/\/ should be succeeded by its corresponding vector IR and following\n+     \/\/ special handling should be removed.\n+     if (rbt == T_INT && bt == T_LONG) {\n+       __ evpmovqd($dst$$XMMRegister, $dst$$XMMRegister, vlen_enc);\n+     }\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct vcount_leading_zeros_IL_reg_evex_masked(vec dst, vec src, kReg mask) %{\n+  predicate(is_clz_non_subword_predicate_evex(Matcher::vector_element_basic_type(n->in(1)),\n+                                              Matcher::vector_length_in_bytes(n->in(1))));\n+  match(Set dst (CountLeadingZerosV src mask));\n+  format %{ \"vector_count_leading_zeros $dst, $src, $mask\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this, $src);\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n+    __ evmovdquq($dst$$XMMRegister, $src$$XMMRegister, vlen_enc);\n+    __ vector_count_leading_zeros_evex(bt, $dst$$XMMRegister, $src$$XMMRegister, xnoreg, xnoreg,\n+                                       xnoreg, $mask$$KRegister, noreg, true, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct vcount_leading_zeros_short_reg_evex(vec dst, vec src, vec xtmp1, vec xtmp2) %{\n+  predicate(Matcher::vector_element_basic_type(n->in(1)) == T_SHORT &&\n+            VM_Version::supports_avx512cd() &&\n+            (VM_Version::supports_avx512vl() || Matcher::vector_length_in_bytes(n) == 64));\n+  match(Set dst (CountLeadingZerosV src));\n+  effect(TEMP dst, TEMP xtmp1, TEMP xtmp2);\n+  format %{ \"vector_count_leading_zeros $dst, $src!\\t using $xtmp1 and $xtmp2 as TEMP\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this, $src);\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n+    __ vector_count_leading_zeros_evex(bt, $dst$$XMMRegister, $src$$XMMRegister, $xtmp1$$XMMRegister,\n+                                       $xtmp2$$XMMRegister, xnoreg, k0, noreg, true, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct vcount_leading_zeros_byte_reg_evex(vec dst, vec src, vec xtmp1, vec xtmp2, vec xtmp3, kReg ktmp, rRegP rtmp) %{\n+  predicate(Matcher::vector_element_basic_type(n->in(1)) == T_BYTE && VM_Version::supports_avx512vlbw());\n+  match(Set dst (CountLeadingZerosV src));\n+  effect(TEMP dst, TEMP xtmp1, TEMP xtmp2, TEMP xtmp3, TEMP ktmp, TEMP rtmp);\n+  format %{ \"vector_count_leading_zeros $dst, $src!\\t using $xtmp1, $xtmp2, $xtmp3, $ktmp and $rtmp as TEMP\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this, $src);\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n+    __ vector_count_leading_zeros_evex(bt, $dst$$XMMRegister, $src$$XMMRegister, $xtmp1$$XMMRegister,\n+                                       $xtmp2$$XMMRegister, $xtmp3$$XMMRegister, $ktmp$$KRegister,\n+                                       $rtmp$$Register, true, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct vcount_leading_zeros_int_reg_avx(vec dst, vec src, vec xtmp1, vec xtmp2, vec xtmp3) %{\n+  predicate(Matcher::vector_element_basic_type(n->in(1)) == T_INT &&\n+            !VM_Version::supports_avx512vl() && Matcher::vector_length_in_bytes(n->in(1)) < 64);\n+  match(Set dst (CountLeadingZerosV src));\n+  effect(TEMP dst, TEMP xtmp1, TEMP xtmp2, TEMP xtmp3);\n+  format %{ \"vector_count_leading_zeros $dst, $src\\t! using $xtmp1, $xtmp2 and $xtmp3 as TEMP\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this, $src);\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n+    __ vector_count_leading_zeros_avx(bt, $dst$$XMMRegister, $src$$XMMRegister, $xtmp1$$XMMRegister,\n+                                      $xtmp2$$XMMRegister, $xtmp3$$XMMRegister, noreg, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct vcount_leading_zeros_reg_avx(vec dst, vec src, vec xtmp1, vec xtmp2, vec xtmp3, rRegP rtmp) %{\n+  predicate(Matcher::vector_element_basic_type(n->in(1)) != T_INT &&\n+            !VM_Version::supports_avx512vl() && Matcher::vector_length_in_bytes(n->in(1)) < 64);\n+  match(Set dst (CountLeadingZerosV src));\n+  effect(TEMP dst, TEMP xtmp1, TEMP xtmp2, TEMP xtmp3, TEMP rtmp);\n+  format %{ \"vector_count_leading_zeros $dst, $src\\t! using $xtmp1, $xtmp2, $xtmp3, and $rtmp as TEMP\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this, $src);\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n+    BasicType rbt = Matcher::vector_element_basic_type(this);\n+    __ vector_count_leading_zeros_avx(bt, $dst$$XMMRegister, $src$$XMMRegister, $xtmp1$$XMMRegister,\n+                                      $xtmp2$$XMMRegister, $xtmp3$$XMMRegister, $rtmp$$Register, vlen_enc);\n+    \/\/ TODO: Once auto-vectorizer supports ConvL2I operation, CountLeadingZerosV\n+    \/\/ should be succeeded by its corresponding vector IR and following\n+    \/\/ special handling should be removed.\n+    if (rbt == T_INT && bt == T_LONG) {\n+      __ evpmovqd($dst$$XMMRegister, $dst$$XMMRegister, vlen_enc);\n+    }\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":387,"deletions":36,"binary":false,"changes":423,"status":"modified"},{"patch":"@@ -4220,0 +4220,1 @@\n+    \"CompressV\", \"ExpandV\", \"CompressM\",\n@@ -4231,1 +4232,1 @@\n-    \"ReplicateB\",\"ReplicateS\",\"ReplicateI\",\"ReplicateL\",\"ReplicateF\",\"ReplicateD\",\"PopulateIndex\",\n+    \"ReplicateB\",\"ReplicateS\",\"ReplicateI\",\"ReplicateL\",\"ReplicateF\",\"ReplicateD\",\"ReverseV\",\"ReverseBytesV\",\n@@ -4240,1 +4241,2 @@\n-    \"FmaVD\",\"FmaVF\",\"PopCountVI\", \"PopCountVL\", \"SignumVF\", \"SignumVD\", \"VectorLongToMask\",\n+    \"FmaVD\",\"FmaVF\",\"PopCountVI\",\"PopCountVL\",\"PopulateIndex\",\"VectorLongToMask\",\n+    \"CountLeadingZerosV\", \"CountTrailingZerosV\", \"SignumVF\", \"SignumVD\",\n","filename":"src\/hotspot\/share\/adlc\/formssel.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -938,1 +938,1 @@\n-                                     \"I\"                                                                                                       \\\n+                                     \"J\"                                                                                                       \\\n@@ -953,1 +953,1 @@\n-                                            \"I\"                                                                                                \\\n+                                            \"J\"                                                                                                \\\n@@ -965,2 +965,4 @@\n-                                      \"Ljdk\/internal\/vm\/vector\/VectorSupport$Vector;\"                                                          \\\n-                                      \"Ljava\/lang\/Object;ILjdk\/internal\/vm\/vector\/VectorSupport$StoreVectorOperation;)\"                        \\\n+                                      \"Ljdk\/internal\/vm\/vector\/VectorSupport$VectorPayload;\"                                                   \\\n+                                      \"Ljava\/lang\/Object;\"                                                                                     \\\n+                                      \"J\"                                                                                                      \\\n+                                      \"Ljdk\/internal\/vm\/vector\/VectorSupport$StoreVectorOperation;)\"                                           \\\n@@ -980,1 +982,1 @@\n-                                             \"I\"                                                                                               \\\n+                                             \"J\"                                                                                               \\\n@@ -1140,0 +1142,11 @@\n+  do_intrinsic(_VectorCompressExpand, jdk_internal_vm_vector_VectorSupport, vector_compress_expand_op_name, vector_compress_expand_op_sig, F_S)\\\n+   do_signature(vector_compress_expand_op_sig, \"(I\"                                                                                            \\\n+                                      \"Ljava\/lang\/Class;\"                                                                                      \\\n+                                      \"Ljava\/lang\/Class;\"                                                                                      \\\n+                                      \"Ljava\/lang\/Class;\"                                                                                      \\\n+                                      \"I\"                                                                                                      \\\n+                                      \"Ljdk\/internal\/vm\/vector\/VectorSupport$Vector;\"                                                          \\\n+                                      \"Ljdk\/internal\/vm\/vector\/VectorSupport$VectorMask;\"                                                      \\\n+                                      \"Ljdk\/internal\/vm\/vector\/VectorSupport$CompressExpandOperation;)\"                                        \\\n+                                      \"Ljdk\/internal\/vm\/vector\/VectorSupport$VectorPayload;\")                                                  \\\n+   do_name(vector_compress_expand_op_name,     \"compressExpandOp\")                                                                             \\\n@@ -1248,1 +1261,1 @@\n-  LAST_COMPILER_INLINE = _VectorMaskOp,\n+  LAST_COMPILER_INLINE = _VectorCompressExpand,\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":19,"deletions":6,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -718,0 +718,1 @@\n+  case vmIntrinsics::_VectorCompressExpand:\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -54,0 +54,1 @@\n+macro(ReverseBytesV)\n@@ -78,0 +79,2 @@\n+macro(CompressBits)\n+macro(ExpandBits)\n@@ -156,0 +159,1 @@\n+macro(CountLeadingZerosV)\n@@ -158,0 +162,1 @@\n+macro(CountTrailingZerosV)\n@@ -295,0 +300,3 @@\n+macro(ReverseI)\n+macro(ReverseL)\n+macro(ReverseV)\n@@ -434,0 +442,3 @@\n+macro(CompressV)\n+macro(CompressM)\n+macro(ExpandV)\n","filename":"src\/hotspot\/share\/opto\/classes.hpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -3415,0 +3415,15 @@\n+  case Op_ReverseBytesV:\n+  case Op_ReverseV: {\n+    if ((uint)n->in(1)->Opcode() == nop) {\n+      if (n->is_predicated_vector() && n->in(1)->is_predicated_vector() &&\n+          n->in(2) == n->in(1)->in(2)) {\n+        \/\/ Node (Node X , Mask) Mask => X\n+        n->subsume_by(n->in(1)->in(1), this);\n+      } else if (!n->is_predicated_using_blend() && !n->in(1)->is_predicated_using_blend()) {\n+        \/\/ Node (Node X) =>  X\n+        n->subsume_by(n->in(1)->in(1), this);\n+      }\n+    }\n+    break;\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -703,0 +703,2 @@\n+  case vmIntrinsics::_VectorCompressExpand:\n+    return inline_vector_compress_expand();\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -347,0 +347,2 @@\n+  bool inline_vector_compress_expand();\n+\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -977,0 +977,3 @@\n+      case Op_CountTrailingZerosV:\n+      case Op_CountLeadingZerosV:\n+      case Op_ReverseV:\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2266,0 +2266,3 @@\n+    case Op_CompressV:\n+    case Op_CompressM:\n+    case Op_ExpandV:\n","filename":"src\/hotspot\/share\/opto\/matcher.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -392,0 +392,16 @@\n+\/\/------------------------------CompressBitsNode-------------------------------\n+\/\/ CompressBits placeholder node\n+class CompressBitsNode : public Node {\n+public:\n+  CompressBitsNode(Node *in1, Node *in2) : Node(0,in1,in2) {}\n+  virtual int Opcode() const;\n+};\n+\n+\/\/------------------------------ExpandBitsNode---------------------------------\n+\/\/ ExpandBits placeholder node\n+class ExpandBitsNode : public Node {\n+public:\n+  ExpandBitsNode(Node *in1, Node *in2) : Node(0,in1,in2) {}\n+  virtual int Opcode() const;\n+};\n+\n","filename":"src\/hotspot\/share\/opto\/mulnode.hpp","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -180,0 +180,3 @@\n+class ExpandVNode;\n+class CompressVNode;\n+class CompressMNode;\n@@ -711,0 +714,3 @@\n+        DEFINE_CLASS_ID(CompressV, Vector, 4)\n+        DEFINE_CLASS_ID(ExpandV, Vector, 5)\n+        DEFINE_CLASS_ID(CompressM, Vector, 6)\n@@ -780,5 +786,7 @@\n-    Flag_is_expensive                = 1 << 13,\n-    Flag_is_predicated_vector        = 1 << 14,\n-    Flag_for_post_loop_opts_igvn     = 1 << 15,\n-    Flag_is_removed_by_peephole      = 1 << 16,\n-    _last_flag                       = Flag_is_removed_by_peephole\n+    Flag_has_vector_mask_set         = 1 << 13,\n+    Flag_is_expensive                = 1 << 14,\n+    Flag_is_predicated_vector        = 1 << 15,\n+    Flag_for_post_loop_opts_igvn     = 1 << 16,\n+    Flag_is_removed_by_peephole      = 1 << 17,\n+    Flag_is_predicated_using_blend   = 1 << 18,\n+    _last_flag                       = Flag_is_predicated_using_blend\n@@ -940,1 +948,4 @@\n-  DEFINE_CLASS_QUERY(VectorReinterpret);\n+  DEFINE_CLASS_QUERY(VectorReinterpret)\n+  DEFINE_CLASS_QUERY(CompressV)\n+  DEFINE_CLASS_QUERY(ExpandV)\n+  DEFINE_CLASS_QUERY(CompressM)\n@@ -998,0 +1009,5 @@\n+  bool is_predicated_using_blend() const { return (_flags & Flag_is_predicated_using_blend) != 0; }\n+\n+  \/\/ The node is a CountedLoopEnd with a mask annotation so as to emit a restore context\n+  bool has_vector_mask_set() const { return (_flags & Flag_has_vector_mask_set) != 0; }\n+\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":22,"deletions":6,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -551,0 +551,20 @@\n+\/\/-------------------------------ReverseINode--------------------------------\n+\/\/ reverse bits of an int\n+class ReverseINode : public Node {\n+public:\n+  ReverseINode(Node *c, Node *in1) : Node(c, in1) {}\n+  virtual int Opcode() const;\n+  const Type *bottom_type() const { return TypeInt::INT; }\n+  virtual uint ideal_reg() const { return Op_RegI; }\n+};\n+\n+\/\/-------------------------------ReverseLNode--------------------------------\n+\/\/ reverse bits of a long\n+class ReverseLNode : public Node {\n+public:\n+  ReverseLNode(Node *c, Node *in1) : Node(c, in1) {}\n+  virtual int Opcode() const;\n+  const Type *bottom_type() const { return TypeLong::LONG; }\n+  virtual uint ideal_reg() const { return Op_RegL; }\n+};\n+\n","filename":"src\/hotspot\/share\/opto\/subnode.hpp","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2585,1 +2585,3 @@\n-                 opc == Op_PopCountI || opc == Op_PopCountL) {\n+                 opc == Op_PopCountI || opc == Op_PopCountL ||\n+                 opc == Op_CountLeadingZerosI || opc == Op_CountLeadingZerosL ||\n+                 opc == Op_CountTrailingZerosI || opc == Op_CountTrailingZerosL) {\n@@ -3084,3 +3086,3 @@\n-  if (VectorNode::is_vpopcnt_long(use)) {\n-    \/\/ VPOPCNT_LONG takes long and produces int - hence the special checks\n-    \/\/ on alignment and size.\n+  if (VectorNode::is_type_transition_long_to_int(use)) {\n+    \/\/ PopCountL\/CountLeadingZerosL\/CountTrailingZerosL takes long and produces\n+    \/\/ int - hence the special checks on alignment and size.\n","filename":"src\/hotspot\/share\/opto\/superword.cpp","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -85,1 +85,2 @@\n-      if (!Matcher::match_rule_supported_vector(Op_VectorLoadMask, num_elem, elem_bt)) {\n+      if (!Matcher::match_rule_supported_vector(Op_VectorLoadMask, num_elem, elem_bt) ||\n+          !Matcher::match_rule_supported_vector(Op_LoadVector, num_elem, T_BOOLEAN)) {\n@@ -265,1 +266,2 @@\n-    if (!Matcher::match_rule_supported_vector(Op_VectorLoadMask, num_elem, type)) {\n+    if (!Matcher::match_rule_supported_vector(Op_VectorLoadMask, num_elem, type) ||\n+        !Matcher::match_rule_supported_vector(Op_LoadVector, num_elem, T_BOOLEAN)) {\n@@ -278,1 +280,2 @@\n-    if (!Matcher::match_rule_supported_vector(Op_VectorStoreMask, num_elem, type)) {\n+    if (!Matcher::match_rule_supported_vector(Op_VectorStoreMask, num_elem, type) ||\n+        !Matcher::match_rule_supported_vector(Op_StoreVector, num_elem, T_BOOLEAN)) {\n@@ -564,0 +567,1 @@\n+      operation->add_flag(Node::Flag_is_predicated_using_blend);\n@@ -698,8 +702,0 @@\n-  if (!arch_supports_vector(Op_LoadVector, num_elem, T_BOOLEAN, VecMaskNotUsed)) {\n-    if (C->print_intrinsics()) {\n-      tty->print_cr(\"  ** not supported: arity=1 op=cast#%d\/3 vlen2=%d etype2=%s\",\n-                    Op_LoadVector, num_elem, type2name(T_BOOLEAN));\n-    }\n-    return false; \/\/ not supported\n-  }\n-\n@@ -707,1 +703,1 @@\n-  if (!arch_supports_vector(mopc, num_elem, elem_bt, VecMaskNotUsed)) {\n+  if (!arch_supports_vector(mopc, num_elem, elem_bt, VecMaskUseLoad)) {\n@@ -940,1 +936,1 @@\n-\/\/         C container, int index, S s,     \/\/ Arguments for default implementation\n+\/\/         C container, long index, S s,     \/\/ Arguments for default implementation\n@@ -949,1 +945,1 @@\n-\/\/            C container, int index,      \/\/ Arguments for default implementation\n+\/\/            C container, long index,      \/\/ Arguments for default implementation\n@@ -1052,10 +1048,0 @@\n-    if (!arch_supports_vector(Op_LoadVector, num_elem, T_BOOLEAN, VecMaskNotUsed)) {\n-      if (C->print_intrinsics()) {\n-        tty->print_cr(\"  ** not supported: arity=%d op=%s\/mask vlen=%d etype=bit ismask=no\",\n-                      is_store, is_store ? \"store\" : \"load\",\n-                      num_elem);\n-      }\n-      set_map(old_map);\n-      set_sp(old_sp);\n-      return false; \/\/ not supported\n-    }\n@@ -1099,1 +1085,3 @@\n-\n+    if (is_mask) {\n+      val = gvn().transform(VectorStoreMaskNode::make(gvn(), val, elem_bt, num_elem));\n+    }\n@@ -1141,1 +1129,1 @@\n-\/\/              C container, int index, S s,  \/\/ Arguments for default implementation\n+\/\/              C container, long index, S s,  \/\/ Arguments for default implementation\n@@ -1152,1 +1140,1 @@\n-\/\/                  C container, int index,  \/\/ Arguments for default implementation\n+\/\/                  C container, long index,  \/\/ Arguments for default implementation\n@@ -2739,0 +2727,94 @@\n+\/\/ public static\n+\/\/ <V extends Vector<E>,\n+\/\/  M extends VectorMask<E>,\n+\/\/  E>\n+\/\/  V compressExpandOp(int opr,\n+\/\/                    Class<? extends V> vClass, Class<? extends M> mClass, Class<E> eClass,\n+\/\/                    int length, V v, M m,\n+\/\/                    CompressExpandOperation<V, M> defaultImpl)\n+bool LibraryCallKit::inline_vector_compress_expand() {\n+  const TypeInt*     opr          = gvn().type(argument(0))->isa_int();\n+  const TypeInstPtr* vector_klass = gvn().type(argument(1))->isa_instptr();\n+  const TypeInstPtr* mask_klass   = gvn().type(argument(2))->isa_instptr();\n+  const TypeInstPtr* elem_klass   = gvn().type(argument(3))->isa_instptr();\n+  const TypeInt*     vlen         = gvn().type(argument(4))->isa_int();\n+\n+  if (vector_klass == NULL || elem_klass == NULL || mask_klass == NULL || vlen == NULL ||\n+      vector_klass->const_oop() == NULL || mask_klass->const_oop() == NULL ||\n+      elem_klass->const_oop() == NULL || !vlen->is_con() || !opr->is_con()) {\n+    if (C->print_intrinsics()) {\n+      tty->print_cr(\"  ** missing constant: opr=%s vclass=%s mclass=%s etype=%s vlen=%s\",\n+                    NodeClassNames[argument(0)->Opcode()],\n+                    NodeClassNames[argument(1)->Opcode()],\n+                    NodeClassNames[argument(2)->Opcode()],\n+                    NodeClassNames[argument(3)->Opcode()],\n+                    NodeClassNames[argument(4)->Opcode()]);\n+    }\n+    return false; \/\/ not enough info for intrinsification\n+  }\n+\n+  if (!is_klass_initialized(vector_klass) || !is_klass_initialized(mask_klass)) {\n+    if (C->print_intrinsics()) {\n+      tty->print_cr(\"  ** klass argument not initialized\");\n+    }\n+    return false;\n+  }\n+\n+  ciType* elem_type = elem_klass->const_oop()->as_instance()->java_mirror_type();\n+  if (!elem_type->is_primitive_type()) {\n+    if (C->print_intrinsics()) {\n+      tty->print_cr(\"  ** not a primitive bt=%d\", elem_type->basic_type());\n+    }\n+    return false; \/\/ should be primitive type\n+  }\n+\n+  int num_elem = vlen->get_con();\n+  BasicType elem_bt = elem_type->basic_type();\n+  int opc = VectorSupport::vop2ideal(opr->get_con(), elem_bt);\n+\n+  if (!arch_supports_vector(opc, num_elem, elem_bt, VecMaskUseLoad)) {\n+    if (C->print_intrinsics()) {\n+      tty->print_cr(\"  ** not supported: opc=%d vlen=%d etype=%s ismask=useload\",\n+                    opc, num_elem, type2name(elem_bt));\n+    }\n+    return false; \/\/ not supported\n+  }\n+\n+  Node* opd1 = NULL;\n+  const TypeInstPtr* vbox_type = NULL;\n+  if (opc != Op_CompressM) {\n+    ciKlass* vbox_klass = vector_klass->const_oop()->as_instance()->java_lang_Class_klass();\n+    vbox_type = TypeInstPtr::make_exact(TypePtr::NotNull, vbox_klass);\n+    opd1 = unbox_vector(argument(5), vbox_type, elem_bt, num_elem);\n+    if (opd1 == NULL) {\n+      if (C->print_intrinsics()) {\n+        tty->print_cr(\"  ** unbox failed vector=%s\",\n+                      NodeClassNames[argument(5)->Opcode()]);\n+      }\n+      return false;\n+    }\n+  }\n+\n+  ciKlass* mbox_klass = mask_klass->const_oop()->as_instance()->java_lang_Class_klass();\n+  assert(is_vector_mask(mbox_klass), \"argument(6) should be a mask class\");\n+  const TypeInstPtr* mbox_type = TypeInstPtr::make_exact(TypePtr::NotNull, mbox_klass);\n+\n+  Node* mask = unbox_vector(argument(6), mbox_type, elem_bt, num_elem);\n+  if (mask == NULL) {\n+    if (C->print_intrinsics()) {\n+      tty->print_cr(\"  ** unbox failed mask=%s\",\n+                    NodeClassNames[argument(6)->Opcode()]);\n+    }\n+    return false;\n+  }\n+\n+  const TypeVect* vt = TypeVect::make(elem_bt, num_elem, opc == Op_CompressM);\n+  Node* operation = gvn().transform(VectorNode::make(opc, opd1, mask, vt));\n+\n+  \/\/ Wrap it up in VectorBox to keep object type information.\n+  const TypeInstPtr* box_type = opc == Op_CompressM ? mbox_type : vbox_type;\n+  Node* vbox = box_vector(operation, box_type, elem_bt, num_elem);\n+  set_result(vbox);\n+  C->set_max_vector_size(MAX2(C->max_vector_size(), (uint)(num_elem * type2aelembytes(elem_bt))));\n+  return true;\n+}\n","filename":"src\/hotspot\/share\/opto\/vectorIntrinsics.cpp","additions":109,"deletions":27,"binary":false,"changes":136,"status":"modified"},{"patch":"@@ -165,3 +165,1 @@\n-    \/\/ Unimplemented for subword types since bit count changes\n-    \/\/ depending on size of lane (and sign bit).\n-    return (bt == T_INT ? Op_PopCountVI : 0);\n+    return Op_PopCountVI;\n@@ -170,0 +168,13 @@\n+  case Op_ReverseI:\n+  case Op_ReverseL:\n+    return (is_integral_type(bt) ? Op_ReverseV : 0);\n+  case Op_ReverseBytesS:\n+  case Op_ReverseBytesI:\n+  case Op_ReverseBytesL:\n+    return (is_integral_type(bt) ? Op_ReverseBytesV : 0);\n+  case Op_CompressBits:\n+    \/\/ Not implemented. Returning 0 temporarily\n+    return 0;\n+  case Op_ExpandBits:\n+    \/\/ Not implemented. Returning 0 temporarily\n+    return 0;\n@@ -248,0 +259,6 @@\n+  case Op_CountLeadingZerosI:\n+  case Op_CountLeadingZerosL:\n+    return Op_CountLeadingZerosV;\n+  case Op_CountTrailingZerosI:\n+  case Op_CountTrailingZerosL:\n+    return Op_CountTrailingZerosV;\n@@ -320,3 +337,8 @@\n-bool VectorNode::is_vpopcnt_long(Node* n) {\n-  if (n->Opcode() == Op_PopCountL) {\n-    return true;\n+bool VectorNode::is_type_transition_long_to_int(Node* n) {\n+  switch(n->Opcode()) {\n+    case Op_PopCountL:\n+    case Op_CountLeadingZerosL:\n+    case Op_CountTrailingZerosL:\n+       return true;\n+    default:\n+       return false;\n@@ -324,1 +346,0 @@\n-  return false;\n@@ -327,3 +348,0 @@\n-\n-\n-\n@@ -598,0 +616,3 @@\n+  case Op_ReverseV: return new ReverseVNode(n1, vt);\n+  case Op_ReverseBytesV: return new ReverseBytesVNode(n1, vt);\n+\n@@ -631,0 +652,6 @@\n+\n+  case Op_ExpandV: return new ExpandVNode(n1, n2, vt);\n+  case Op_CompressV: return new CompressVNode(n1, n2, vt);\n+  case Op_CompressM: assert(n1 == NULL, \"\"); return new CompressMNode(n2, vt);\n+  case Op_CountLeadingZerosV: return new CountLeadingZerosVNode(n1, vt);\n+  case Op_CountTrailingZerosV: return new CountTrailingZerosVNode(n1, vt);\n","filename":"src\/hotspot\/share\/opto\/vectornode.cpp","additions":37,"deletions":10,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -96,1 +96,1 @@\n-  static bool is_vpopcnt_long(Node* n);\n+  static bool is_type_transition_long_to_int(Node* n);\n@@ -772,0 +772,31 @@\n+\/\/------------------------------CompressVNode--------------------------------------\n+\/\/ Vector compress\n+class CompressVNode: public VectorNode {\n+ public:\n+  CompressVNode(Node* vec, Node* mask, const TypeVect* vt) :\n+      VectorNode(vec, mask, vt) {\n+    init_class_id(Class_CompressV);\n+  }\n+  virtual int Opcode() const;\n+};\n+\n+class CompressMNode: public VectorNode {\n+ public:\n+  CompressMNode(Node* mask, const TypeVect* vt) :\n+      VectorNode(mask, vt) {\n+    init_class_id(Class_CompressM);\n+  }\n+  virtual int Opcode() const;\n+};\n+\n+\/\/------------------------------ExpandVNode--------------------------------------\n+\/\/ Vector expand\n+class ExpandVNode: public VectorNode {\n+ public:\n+  ExpandVNode(Node* vec, Node* mask, const TypeVect* vt) :\n+      VectorNode(vec, mask, vt) {\n+    init_class_id(Class_ExpandV);\n+  }\n+  virtual int Opcode() const;\n+};\n+\n@@ -1395,1 +1426,0 @@\n-    \/\/ assert(mask->is_VectorMask(), \"VectorBlendNode requires that third argument be a mask\");\n@@ -1678,0 +1708,32 @@\n+class CountLeadingZerosVNode : public VectorNode {\n+ public:\n+  CountLeadingZerosVNode(Node* in, const TypeVect* vt)\n+  : VectorNode(in, vt) {}\n+\n+  virtual int Opcode() const;\n+};\n+\n+class CountTrailingZerosVNode : public VectorNode {\n+ public:\n+  CountTrailingZerosVNode(Node* in, const TypeVect* vt)\n+  : VectorNode(in, vt) {}\n+\n+  virtual int Opcode() const;\n+};\n+\n+class ReverseVNode : public VectorNode {\n+public:\n+  ReverseVNode(Node* in, const TypeVect* vt)\n+  : VectorNode(in, vt) {}\n+\n+  virtual int Opcode() const;\n+};\n+\n+class ReverseBytesVNode : public VectorNode {\n+public:\n+  ReverseBytesVNode(Node* in, const TypeVect* vt)\n+  : VectorNode(in, vt) {}\n+\n+  virtual int Opcode() const;\n+};\n+\n@@ -1693,0 +1755,1 @@\n+\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":65,"deletions":2,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -446,0 +446,103 @@\n+    case VECTOR_OP_EXPAND: {\n+      switch (bt) {\n+        case T_BYTE:  \/\/ fall-through\n+        case T_SHORT: \/\/ fall-through\n+        case T_INT:   \/\/ fall-through\n+        case T_LONG:  \/\/ fall-through\n+        case T_FLOAT: \/\/ fall-through\n+        case T_DOUBLE: return Op_ExpandV;\n+        default: fatal(\"EXPAND: %s\", type2name(bt));\n+      }\n+      break;\n+    }\n+    case VECTOR_OP_COMPRESS: {\n+      switch (bt) {\n+        case T_BYTE:  \/\/ fall-through\n+        case T_SHORT: \/\/ fall-through\n+        case T_INT:   \/\/ fall-through\n+        case T_LONG:  \/\/ fall-through\n+        case T_FLOAT: \/\/ fall-through\n+        case T_DOUBLE: return Op_CompressV;\n+        default: fatal(\"COMPRESS: %s\", type2name(bt));\n+      }\n+      break;\n+    }\n+    case VECTOR_OP_MASK_COMPRESS: {\n+      switch (bt) {\n+        case T_BYTE:  \/\/ fall-through\n+        case T_SHORT: \/\/ fall-through\n+        case T_INT:   \/\/ fall-through\n+        case T_LONG:  \/\/ fall-through\n+        case T_FLOAT: \/\/ fall-through\n+        case T_DOUBLE: return Op_CompressM;\n+        default: fatal(\"MASK_COMPRESS: %s\", type2name(bt));\n+      }\n+      break;\n+    }\n+    case VECTOR_OP_BIT_COUNT: {\n+      switch (bt) {\n+        case T_BYTE:  \/\/ Returning Op_PopCountI\n+        case T_SHORT: \/\/ for byte and short types temporarily\n+        case T_INT:   return Op_PopCountI;\n+        case T_LONG:  return Op_PopCountL;\n+        default: fatal(\"BIT_COUNT: %s\", type2name(bt));\n+      }\n+      break;\n+    }\n+    case VECTOR_OP_TZ_COUNT: {\n+      switch (bt) {\n+        case T_BYTE:\n+        case T_SHORT:\n+        case T_INT:   return Op_CountTrailingZerosI;\n+        case T_LONG:  return Op_CountTrailingZerosL;\n+        default: fatal(\"TZ_COUNT: %s\", type2name(bt));\n+      }\n+      break;\n+    }\n+    case VECTOR_OP_LZ_COUNT: {\n+      switch (bt) {\n+        case T_BYTE:\n+        case T_SHORT:\n+        case T_INT:   return Op_CountLeadingZerosI;\n+        case T_LONG:  return Op_CountLeadingZerosL;\n+        default: fatal(\"LZ_COUNT: %s\", type2name(bt));\n+      }\n+      break;\n+    }\n+    case VECTOR_OP_REVERSE: {\n+      switch (bt) {\n+        case T_BYTE:  \/\/ Temporarily returning\n+        case T_SHORT: \/\/ Op_ReverseI for byte and short\n+        case T_INT:   return Op_ReverseI;\n+        case T_LONG:  return Op_ReverseL;\n+        default: fatal(\"REVERSE: %s\", type2name(bt));\n+      }\n+      break;\n+    }\n+    case VECTOR_OP_REVERSE_BYTES: {\n+      switch (bt) {\n+        case T_BYTE:\n+        case T_SHORT:\n+        case T_INT:   return Op_ReverseBytesI;\n+        case T_LONG:  return Op_ReverseBytesL;\n+        default: fatal(\"REVERSE_BYTES: %s\", type2name(bt));\n+      }\n+      break;\n+    }\n+    case VECTOR_OP_COMPRESS_BITS: {\n+      switch (bt) {\n+        case T_INT:\n+        case T_LONG: return Op_CompressBits;\n+        default: fatal(\"COMPRESS_BITS: %s\", type2name(bt));\n+      }\n+      break;\n+    }\n+    case VECTOR_OP_EXPAND_BITS: {\n+      switch (bt) {\n+        case T_INT:\n+        case T_LONG: return Op_ExpandBits;\n+        default: fatal(\"EXPAND_BITS: %s\", type2name(bt));\n+      }\n+      break;\n+    }\n+\n","filename":"src\/hotspot\/share\/prims\/vectorSupport.cpp","additions":103,"deletions":0,"binary":false,"changes":103,"status":"modified"},{"patch":"@@ -57,0 +57,1 @@\n+    VECTOR_OP_BIT_COUNT = 3,\n@@ -92,0 +93,11 @@\n+    VECTOR_OP_COMPRESS = 26,\n+    VECTOR_OP_EXPAND = 27,\n+    VECTOR_OP_MASK_COMPRESS = 28,\n+\n+    VECTOR_OP_TZ_COUNT = 29,\n+    VECTOR_OP_LZ_COUNT = 30,\n+    VECTOR_OP_REVERSE  = 31,\n+    VECTOR_OP_REVERSE_BYTES = 32,\n+    VECTOR_OP_COMPRESS_BITS = 33,\n+    VECTOR_OP_EXPAND_BITS = 34,\n+\n","filename":"src\/hotspot\/share\/prims\/vectorSupport.hpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1786,0 +1786,2 @@\n+  declare_c2_type(CompressVNode, VectorNode)                              \\\n+  declare_c2_type(ExpandVNode, VectorNode)                                \\\n@@ -1877,0 +1879,2 @@\n+  declare_c2_type(CountLeadingZerosVNode, VectorNode)                     \\\n+  declare_c2_type(CountTrailingZerosVNode, VectorNode)                    \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -724,0 +724,4 @@\n+inline bool is_non_subword_integral_type(BasicType t) {\n+  return t == T_INT || t == T_LONG;\n+}\n+\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -34,2 +34,0 @@\n-import java.nio.Buffer;\n-import java.nio.ByteBuffer;\n@@ -337,40 +335,1 @@\n-    \/\/ ByteBuffer vector access ops\n-\n-    \/\/ Buffer access constants, to be initialized when required.\n-    \/\/ Avoids a null value for NIO_ACCESS, due to class initialization dependencies\n-    static final class BufferAccess {\n-        \/\/ Buffer.address\n-        static final long BUFFER_ADDRESS\n-                = UNSAFE.objectFieldOffset(Buffer.class, \"address\");\n-\n-        \/\/ ByteBuffer.hb\n-        static final long BYTE_BUFFER_HB\n-                = UNSAFE.objectFieldOffset(ByteBuffer.class, \"hb\");\n-\n-        static final long BYTE_BUFFER_IS_READ_ONLY\n-                = UNSAFE.objectFieldOffset(ByteBuffer.class, \"isReadOnly\");\n-\n-        @ForceInline\n-        static Object bufferBase(ByteBuffer bb) {\n-            return UNSAFE.getReference(bb, BYTE_BUFFER_HB);\n-        }\n-\n-        @ForceInline\n-        static long bufferAddress(ByteBuffer bb, long offset) {\n-            return UNSAFE.getLong(bb, BUFFER_ADDRESS) + offset;\n-        }\n-\n-        static final JavaNioAccess NIO_ACCESS = SharedSecrets.getJavaNioAccess();\n-\n-        @ForceInline\n-        static ScopedMemoryAccess.Scope scope(ByteBuffer bb) {\n-            MemorySegmentProxy segmentProxy = NIO_ACCESS.bufferSegment(bb);\n-            return segmentProxy != null ?\n-                    segmentProxy.scope() : null;\n-        }\n-    }\n-\n-    @ForceInline\n-    public static boolean isReadOnly(ByteBuffer bb) {\n-        return UNSAFE.getBoolean(bb, BufferAccess.BYTE_BUFFER_IS_READ_ONLY);\n-    }\n+    \/\/ MemorySegment vector access ops\n@@ -381,4 +340,9 @@\n-    V loadFromByteBuffer(Class<? extends V> vmClass, Class<E> e, int length,\n-                          ByteBuffer bb, int offset,\n-                          S s,\n-                          VectorSupport.LoadOperation<ByteBuffer, V, S> defaultImpl) {\n+    V loadFromMemorySegment(Class<? extends V> vmClass, Class<E> e, int length,\n+                         MemorySegmentProxy msp, long offset,\n+                         S s,\n+                         VectorSupport.LoadOperation<MemorySegmentProxy, V, S> defaultImpl) {\n+        \/\/ @@@ Smarter alignment checking if accessing heap segment backing non-byte[] array\n+        if (msp.maxAlignMask() > 1) {\n+            throw new IllegalArgumentException();\n+        }\n+\n@@ -386,2 +350,2 @@\n-            return loadFromByteBufferScoped(\n-                    BufferAccess.scope(bb),\n+            return loadFromMemorySegmentScopedInternal(\n+                    msp.scope(),\n@@ -389,1 +353,1 @@\n-                    bb, offset,\n+                    msp, offset,\n@@ -401,5 +365,5 @@\n-    V loadFromByteBufferScoped(ScopedMemoryAccess.Scope scope,\n-                          Class<? extends V> vmClass, Class<E> e, int length,\n-                          ByteBuffer bb, int offset,\n-                          S s,\n-                          VectorSupport.LoadOperation<ByteBuffer, V, S> defaultImpl) {\n+    V loadFromMemorySegmentScopedInternal(ScopedMemoryAccess.Scope scope,\n+                                          Class<? extends V> vmClass, Class<E> e, int length,\n+                                          MemorySegmentProxy msp, long offset,\n+                                          S s,\n+                                          VectorSupport.LoadOperation<MemorySegmentProxy, V, S> defaultImpl) {\n@@ -407,5 +371,1 @@\n-            if (scope != null) {\n-                scope.checkValidState();\n-            }\n-\n-            final byte[] base = (byte[]) BufferAccess.bufferBase(bb);\n+            scope.checkValidState();\n@@ -414,3 +374,3 @@\n-                      base, BufferAccess.bufferAddress(bb, offset),\n-                      bb, offset, s,\n-                      defaultImpl);\n+                    msp.unsafeGetBase(), msp.unsafeGetOffset() + offset,\n+                    msp, offset, s,\n+                    defaultImpl);\n@@ -426,3 +386,8 @@\n-    V loadFromByteBufferMasked(Class<? extends V> vmClass, Class<M> maskClass, Class<E> e,\n-                               int length, ByteBuffer bb, int offset, M m, S s,\n-                               VectorSupport.LoadVectorMaskedOperation<ByteBuffer, V, S, M> defaultImpl) {\n+    V loadFromMemorySegmentMasked(Class<? extends V> vmClass, Class<M> maskClass, Class<E> e,\n+                                  int length, MemorySegmentProxy msp, long offset, M m, S s,\n+                                  VectorSupport.LoadVectorMaskedOperation<MemorySegmentProxy, V, S, M> defaultImpl) {\n+        \/\/ @@@ Smarter alignment checking if accessing heap segment backing non-byte[] array\n+        if (msp.maxAlignMask() > 1) {\n+            throw new IllegalArgumentException();\n+        }\n+\n@@ -430,2 +395,2 @@\n-            return loadFromByteBufferMaskedScoped(\n-                    BufferAccess.scope(bb),\n+            return loadFromMemorySegmentMaskedScopedInternal(\n+                    msp.scope(),\n@@ -433,1 +398,1 @@\n-                    bb, offset, m,\n+                    msp, offset, m,\n@@ -446,5 +411,5 @@\n-    V loadFromByteBufferMaskedScoped(ScopedMemoryAccess.Scope scope, Class<? extends V> vmClass,\n-                                     Class<M> maskClass, Class<E> e, int length,\n-                                     ByteBuffer bb, int offset, M m,\n-                                     S s,\n-                                     VectorSupport.LoadVectorMaskedOperation<ByteBuffer, V, S, M> defaultImpl) {\n+    V loadFromMemorySegmentMaskedScopedInternal(ScopedMemoryAccess.Scope scope, Class<? extends V> vmClass,\n+                                                Class<M> maskClass, Class<E> e, int length,\n+                                                MemorySegmentProxy msp, long offset, M m,\n+                                                S s,\n+                                                VectorSupport.LoadVectorMaskedOperation<MemorySegmentProxy, V, S, M> defaultImpl) {\n@@ -452,3 +417,1 @@\n-            if (scope != null) {\n-                scope.checkValidState();\n-            }\n+            scope.checkValidState();\n@@ -457,2 +420,2 @@\n-                    BufferAccess.bufferBase(bb), BufferAccess.bufferAddress(bb, offset), m,\n-                    bb, offset, s,\n+                    msp.unsafeGetBase(), msp.unsafeGetOffset() + offset, m,\n+                    msp, offset, s,\n@@ -468,4 +431,9 @@\n-    void storeIntoByteBuffer(Class<? extends V> vmClass, Class<E> e, int length,\n-                             V v,\n-                             ByteBuffer bb, int offset,\n-                             VectorSupport.StoreVectorOperation<ByteBuffer, V> defaultImpl) {\n+    void storeIntoMemorySegment(Class<? extends V> vmClass, Class<E> e, int length,\n+                                V v,\n+                                MemorySegmentProxy msp, long offset,\n+                                VectorSupport.StoreVectorOperation<MemorySegmentProxy, V> defaultImpl) {\n+        \/\/ @@@ Smarter alignment checking if accessing heap segment backing non-byte[] array\n+        if (msp.maxAlignMask() > 1) {\n+            throw new IllegalArgumentException();\n+        }\n+\n@@ -473,2 +441,2 @@\n-            storeIntoByteBufferScoped(\n-                    BufferAccess.scope(bb),\n+            storeIntoMemorySegmentScopedInternal(\n+                    msp.scope(),\n@@ -477,1 +445,1 @@\n-                    bb, offset,\n+                    msp, offset,\n@@ -488,5 +456,5 @@\n-    void storeIntoByteBufferScoped(ScopedMemoryAccess.Scope scope,\n-                                   Class<? extends V> vmClass, Class<E> e, int length,\n-                                   V v,\n-                                   ByteBuffer bb, int offset,\n-                                   VectorSupport.StoreVectorOperation<ByteBuffer, V> defaultImpl) {\n+    void storeIntoMemorySegmentScopedInternal(ScopedMemoryAccess.Scope scope,\n+                                              Class<? extends V> vmClass, Class<E> e, int length,\n+                                              V v,\n+                                              MemorySegmentProxy msp, long offset,\n+                                              VectorSupport.StoreVectorOperation<MemorySegmentProxy, V> defaultImpl) {\n@@ -494,5 +462,1 @@\n-            if (scope != null) {\n-                scope.checkValidState();\n-            }\n-\n-            final byte[] base = (byte[]) BufferAccess.bufferBase(bb);\n+            scope.checkValidState();\n@@ -501,4 +465,4 @@\n-                                base, BufferAccess.bufferAddress(bb, offset),\n-                                v,\n-                                bb, offset,\n-                                defaultImpl);\n+                    msp.unsafeGetBase(), msp.unsafeGetOffset() + offset,\n+                    v,\n+                    msp, offset,\n+                    defaultImpl);\n@@ -513,4 +477,9 @@\n-    void storeIntoByteBufferMasked(Class<? extends V> vmClass, Class<M> maskClass, Class<E> e,\n-                                   int length, V v, M m,\n-                                   ByteBuffer bb, int offset,\n-                                   VectorSupport.StoreVectorMaskedOperation<ByteBuffer, V, M> defaultImpl) {\n+    void storeIntoMemorySegmentMasked(Class<? extends V> vmClass, Class<M> maskClass, Class<E> e,\n+                                      int length, V v, M m,\n+                                      MemorySegmentProxy msp, long offset,\n+                                      VectorSupport.StoreVectorMaskedOperation<MemorySegmentProxy, V, M> defaultImpl) {\n+        \/\/ @@@ Smarter alignment checking if accessing heap segment backing non-byte[] array\n+        if (msp.maxAlignMask() > 1) {\n+            throw new IllegalArgumentException();\n+        }\n+\n@@ -518,2 +487,2 @@\n-            storeIntoByteBufferMaskedScoped(\n-                    BufferAccess.scope(bb),\n+            storeIntoMemorySegmentMaskedScopedInternal(\n+                    msp.scope(),\n@@ -522,1 +491,1 @@\n-                    bb, offset,\n+                    msp, offset,\n@@ -533,5 +502,5 @@\n-    void storeIntoByteBufferMaskedScoped(ScopedMemoryAccess.Scope scope,\n-                                         Class<? extends V> vmClass, Class<M> maskClass,\n-                                         Class<E> e, int length, V v, M m,\n-                                         ByteBuffer bb, int offset,\n-                                         VectorSupport.StoreVectorMaskedOperation<ByteBuffer, V, M> defaultImpl) {\n+    void storeIntoMemorySegmentMaskedScopedInternal(ScopedMemoryAccess.Scope scope,\n+                                                    Class<? extends V> vmClass, Class<M> maskClass,\n+                                                    Class<E> e, int length, V v, M m,\n+                                                    MemorySegmentProxy msp, long offset,\n+                                                    VectorSupport.StoreVectorMaskedOperation<MemorySegmentProxy, V, M> defaultImpl) {\n@@ -539,3 +508,1 @@\n-            if (scope != null) {\n-                scope.checkValidState();\n-            }\n+            scope.checkValidState();\n@@ -544,1 +511,1 @@\n-                    BufferAccess.bufferBase(bb), BufferAccess.bufferAddress(bb, offset),\n+                    msp.unsafeGetBase(), msp.unsafeGetOffset() + offset,\n@@ -546,1 +513,1 @@\n-                    bb, offset,\n+                    msp, offset,\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/X-ScopedMemoryAccess.java.template","additions":83,"deletions":116,"binary":false,"changes":199,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+    public static final int VECTOR_OP_BIT_COUNT = 3;\n@@ -79,0 +80,17 @@\n+    \/\/ Compression expansion operations\n+    public static final int VECTOR_OP_COMPRESS = 26;\n+    public static final int VECTOR_OP_EXPAND = 27;\n+    public static final int VECTOR_OP_MASK_COMPRESS = 28;\n+\n+    \/\/ Leading\/Trailing zeros count operations\n+    public static final int VECTOR_OP_TZ_COUNT  = 29;\n+    public static final int VECTOR_OP_LZ_COUNT  = 30;\n+\n+    \/\/ Reverse operation\n+    public static final int VECTOR_OP_REVERSE   = 31;\n+    public static final int VECTOR_OP_REVERSE_BYTES = 32;\n+\n+    \/\/ Compress and Expand Bits operation\n+    public static final int VECTOR_OP_COMPRESS_BITS = 33;\n+    public static final int VECTOR_OP_EXPAND_BITS = 34;\n+\n@@ -366,1 +384,1 @@\n-        VM load(C container, int index, S s);\n+        VM load(C container, long index, S s);\n@@ -378,1 +396,1 @@\n-            C container, int index, S s,\n+            C container, long index, S s,\n@@ -390,1 +408,1 @@\n-        V load(C container, int index, S s, M m);\n+        V load(C container, long index, S s, M m);\n@@ -403,1 +421,1 @@\n-                 M m, C container, int index, S s,\n+                 M m, C container, long index, S s,\n@@ -440,2 +458,2 @@\n-                                          V extends Vector<?>> {\n-        void store(C container, int index, V v);\n+                                          V extends VectorPayload> {\n+        void store(C container, long index, V v);\n@@ -447,1 +465,1 @@\n-     V extends Vector<?>>\n+     V extends VectorPayload>\n@@ -451,1 +469,1 @@\n-               V v, C container, int index,\n+               V v, C container, long index,\n@@ -460,1 +478,1 @@\n-        void store(C container, int index, V v, M m);\n+        void store(C container, long index, V v, M m);\n@@ -472,1 +490,1 @@\n-                     V v, M m, C container, int index,\n+                     V v, M m, C container, long index,\n@@ -629,0 +647,20 @@\n+    public interface CompressExpandOperation<V extends Vector<?>,\n+                                     M extends VectorMask<?>> {\n+        VectorPayload apply(V v, M m);\n+    }\n+\n+    @IntrinsicCandidate\n+    public static\n+    <V extends Vector<E>,\n+     M extends VectorMask<E>,\n+     E>\n+    VectorPayload compressExpandOp(int opr,\n+                                   Class<? extends V> vClass, Class<? extends M> mClass, Class<E> eClass,\n+                                   int length, V v, M m,\n+                                   CompressExpandOperation<V, M> defaultImpl) {\n+        assert isNonCapturingLambda(defaultImpl) : defaultImpl;\n+        return defaultImpl.apply(v, m);\n+    }\n+\n+    \/* ============================================================================ *\/\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/vector\/VectorSupport.java","additions":48,"deletions":10,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -163,1 +163,2 @@\n-        jdk.incubator.foreign;\n+        jdk.incubator.foreign,\n+        jdk.incubator.vector;\n","filename":"src\/java.base\/share\/classes\/module-info.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -31,0 +31,4 @@\n+import jdk.internal.misc.Unsafe;\n+\n+import jdk.internal.vm.vector.VectorSupport;\n+\n@@ -80,1 +84,9 @@\n-        System.arraycopy(getBits(), 0, bits, i, length());\n+        AbstractSpecies<E> vsp = (AbstractSpecies<E>) vectorSpecies();\n+        int laneCount = vsp.laneCount();\n+        i = VectorIntrinsics.checkFromIndexSize(i, laneCount, bits.length);\n+        VectorSupport.store(\n+            vsp.maskType(), vsp.elementType(), laneCount,\n+            bits, (long) i + Unsafe.ARRAY_BOOLEAN_BASE_OFFSET,\n+            this, bits, i,\n+            (c, idx, s) -> System.arraycopy(s.getBits(), 0, c, (int) idx, s.length()));\n+\n@@ -195,0 +207,9 @@\n+    @Override\n+    @ForceInline\n+    public VectorMask<E> indexInRange(long offset, long limit) {\n+        int vlength = length();\n+        Vector<E> iota = vectorSpecies().zero().addIndex(1);\n+        VectorMask<E> badMask = checkIndex0(offset, limit, iota, vlength);\n+        return this.andNot(badMask);\n+    }\n+\n@@ -218,1 +239,1 @@\n-    void checkIndexByLane(int offset, int alength,\n+    void checkIndexByLane(int offset, int length,\n@@ -232,1 +253,1 @@\n-            badMask = checkIndex0(offset, alength, iota, vlength);\n+            badMask = checkIndex0(offset, length, iota, vlength);\n@@ -236,1 +257,1 @@\n-            int elemCount = Math.min(vlength, (alength - offset) \/ esize);\n+            int elemCount = Math.min(vlength, (length - offset) \/ esize);\n@@ -240,1 +261,1 @@\n-            badMask = checkIndex0(clipOffset, alength,\n+            badMask = checkIndex0(clipOffset, length,\n@@ -248,1 +269,1 @@\n-                   .checkIndexFailed(offset, badLane, alength, esize);\n+                   .checkIndexFailed(offset, badLane, length, esize);\n@@ -254,1 +275,1 @@\n-    VectorMask<E> checkIndex0(int offset, int alength,\n+    VectorMask<E> checkIndex0(int offset, int length,\n@@ -257,1 +278,1 @@\n-        \/\/ alength-offset, since when added to offset it will step off\n+        \/\/ length-offset, since when added to offset it will step off\n@@ -261,1 +282,1 @@\n-        int indexLimit = Math.max(0, Math.min(alength - offset, vlength));\n+        int indexLimit = Math.max(0, Math.min(length - offset, vlength));\n@@ -283,2 +304,78 @@\n-    private IndexOutOfBoundsException checkIndexFailed(int offset, int lane,\n-                                                       int alength, int esize) {\n+    \/**\n+     * Test if a masked memory access at a given offset into an array\n+     * of the given length will stay within the array.\n+     * The per-lane offsets are iota*esize.\n+     *\/\n+    \/*package-private*\/\n+    @ForceInline\n+    void checkIndexByLane(long offset, long length,\n+                          Vector<E> iota,\n+                          int esize) {\n+        if (VectorIntrinsics.VECTOR_ACCESS_OOB_CHECK == 0) {\n+            return;\n+        }\n+        \/\/ Although the specification is simple, the implementation is\n+        \/\/ tricky, because the value iota*esize might possibly\n+        \/\/ overflow.  So we calculate our test values as scalars,\n+        \/\/ clipping to the range [-1..VLENGTH], and test them against\n+        \/\/ the unscaled iota vector, whose values are in [0..VLENGTH-1].\n+        int vlength = length();\n+        VectorMask<E> badMask;\n+        if (esize == 1) {\n+            badMask = checkIndex0(offset, length, iota, vlength);\n+        } else if (offset >= 0) {\n+            \/\/ Masked access to multi-byte lanes in byte array.\n+            \/\/ It could be aligned anywhere.\n+            \/\/ 0 <= elemCount <= vlength\n+            int elemCount = (int) Math.min(vlength, (length - offset) \/ esize);\n+            badMask = checkIndex0(0, elemCount, iota, vlength);\n+        } else {\n+            \/\/ -vlength * esize <= clipOffset <= 0\n+            int clipOffset = (int) Math.max(offset, -(vlength * esize));\n+            badMask = checkIndex0(clipOffset, length,\n+                    iota.lanewise(VectorOperators.MUL, esize),\n+                    vlength * esize);\n+        }\n+        badMask = badMask.and(this);\n+        if (badMask.anyTrue()) {\n+            int badLane = badMask.firstTrue();\n+            throw ((AbstractMask<E>)badMask)\n+                    .checkIndexFailed(offset, badLane, length, esize);\n+        }\n+    }\n+\n+    private\n+    @ForceInline\n+    VectorMask<E> checkIndex0(long offset, long length,\n+                              Vector<E> iota, int vlength) {\n+        \/\/ An active lane is bad if its number is greater than\n+        \/\/ length-offset, since when added to offset it will step off\n+        \/\/ of the end of the array.  To avoid overflow when\n+        \/\/ converting, clip the comparison value to [0..vlength]\n+        \/\/ inclusive.\n+        \/\/ 0 <= indexLimit <= vlength\n+        int indexLimit = (int) Math.max(0, Math.min(length - offset, vlength));\n+        VectorMask<E> badMask =\n+                iota.compare(GE, iota.broadcast(indexLimit));\n+        if (offset < 0) {\n+            \/\/ An active lane is bad if its number is less than\n+            \/\/ -offset, because when added to offset it will then\n+            \/\/ address an array element at a negative index.  To avoid\n+            \/\/ overflow when converting, clip the comparison value at\n+            \/\/ vlength.  This specific expression works correctly even\n+            \/\/ when offset is Integer.MIN_VALUE.\n+            \/\/ 0 <= firstGoodIndex <= vlength\n+            int firstGoodIndex = (int) -Math.max(offset, -vlength);\n+            VectorMask<E> badMask2 =\n+                    iota.compare(LT, iota.broadcast(firstGoodIndex));\n+            if (indexLimit >= vlength) {\n+                badMask = badMask2;  \/\/ 1st badMask is all true\n+            } else {\n+                badMask = badMask.or(badMask2);\n+            }\n+        }\n+        return badMask;\n+    }\n+\n+    private IndexOutOfBoundsException checkIndexFailed(long offset, int lane,\n+                                                       long length, int esize) {\n@@ -287,2 +384,2 @@\n-                                   \"index %d+%d in array of length %d\",\n-                                   this, offset, lane * esize, alength);\n+                                   \"index %d+%d for length %d\",\n+                                   this, offset, lane * esize, length);\n@@ -290,1 +387,1 @@\n-            msg += String.format(\" (each lane spans %d array elements)\", esize);\n+            msg += String.format(\" (each lane spans %d elements)\", esize);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/AbstractMask.java","additions":111,"deletions":14,"binary":false,"changes":125,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+import jdk.incubator.foreign.MemorySegment;\n@@ -29,1 +30,0 @@\n-import java.nio.ByteOrder;\n@@ -31,0 +31,1 @@\n+import java.nio.ByteOrder;\n@@ -206,0 +207,6 @@\n+    @Override\n+    @ForceInline\n+    public final long loopBound(long length) {\n+        return VectorIntrinsics.roundDown(length, laneCount);\n+    }\n+\n@@ -212,0 +219,6 @@\n+    @Override\n+    @ForceInline\n+    public final VectorMask<E> indexInRange(long offset, long limit) {\n+        return maskAll(true).indexInRange(offset, limit);\n+    }\n+\n@@ -352,1 +365,1 @@\n-    public final Vector<E> fromByteArray(byte[] a, int offset, ByteOrder bo) {\n+    public final Vector<E> fromMemorySegment(MemorySegment ms, long offset, ByteOrder bo) {\n@@ -354,1 +367,1 @@\n-            .fromByteArray0(a, offset)\n+            .fromMemorySegment0(ms, offset)\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/AbstractSpecies.java","additions":17,"deletions":4,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+import jdk.incubator.foreign.MemorySegment;\n@@ -30,1 +31,0 @@\n-import java.nio.ByteBuffer;\n@@ -197,1 +197,1 @@\n-    abstract AbstractVector<E> fromByteArray0(byte[] a, int offset);\n+    abstract AbstractVector<E> fromMemorySegment0(MemorySegment ms, long offset);\n@@ -507,2 +507,2 @@\n-        ByteBuffer bb = ByteBuffer.allocate(blen);\n-        this.intoByteBuffer(bb, 0, bo);\n+        MemorySegment ms = MemorySegment.ofArray(new byte[blen]);\n+        this.intoMemorySegment(ms, 0, bo);\n@@ -513,1 +513,1 @@\n-            return ByteVector.fromByteBuffer(rsp.check(byte.class), bb, 0, bo, m.check(byte.class)).check0(rsp);\n+            return ByteVector.fromMemorySegment(rsp.check(byte.class), ms, 0, bo, m.check(byte.class)).check0(rsp);\n@@ -515,1 +515,1 @@\n-            return ShortVector.fromByteBuffer(rsp.check(short.class), bb, 0, bo, m.check(short.class)).check0(rsp);\n+            return ShortVector.fromMemorySegment(rsp.check(short.class), ms, 0, bo, m.check(short.class)).check0(rsp);\n@@ -517,1 +517,1 @@\n-            return IntVector.fromByteBuffer(rsp.check(int.class), bb, 0, bo, m.check(int.class)).check0(rsp);\n+            return IntVector.fromMemorySegment(rsp.check(int.class), ms, 0, bo, m.check(int.class)).check0(rsp);\n@@ -519,1 +519,1 @@\n-            return LongVector.fromByteBuffer(rsp.check(long.class), bb, 0, bo, m.check(long.class)).check0(rsp);\n+            return LongVector.fromMemorySegment(rsp.check(long.class), ms, 0, bo, m.check(long.class)).check0(rsp);\n@@ -521,1 +521,1 @@\n-            return FloatVector.fromByteBuffer(rsp.check(float.class), bb, 0, bo, m.check(float.class)).check0(rsp);\n+            return FloatVector.fromMemorySegment(rsp.check(float.class), ms, 0, bo, m.check(float.class)).check0(rsp);\n@@ -523,1 +523,1 @@\n-            return DoubleVector.fromByteBuffer(rsp.check(double.class), bb, 0, bo, m.check(double.class)).check0(rsp);\n+            return DoubleVector.fromMemorySegment(rsp.check(double.class), ms, 0, bo, m.check(double.class)).check0(rsp);\n@@ -733,9 +733,0 @@\n-    \/\/ Byte buffer wrappers.\n-    static ByteBuffer wrapper(ByteBuffer bb, ByteOrder bo) {\n-        return bb.duplicate().order(bo);\n-    }\n-\n-    static ByteBuffer wrapper(byte[] a, ByteOrder bo) {\n-        return ByteBuffer.wrap(a).order(bo);\n-    }\n-\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/AbstractVector.java","additions":11,"deletions":20,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import java.nio.ByteBuffer;\n@@ -32,0 +31,1 @@\n+import jdk.incubator.foreign.MemorySegment;\n@@ -477,0 +477,16 @@\n+    @Override\n+    @ForceInline\n+    public Byte128Vector compress(VectorMask<Byte> m) {\n+        return (Byte128Vector)\n+            super.compressTemplate(Byte128Mask.class,\n+                                   (Byte128Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Byte128Vector expand(VectorMask<Byte> m) {\n+        return (Byte128Vector)\n+            super.expandTemplate(Byte128Mask.class,\n+                                   (Byte128Mask) m);  \/\/ specialize\n+    }\n+\n@@ -680,0 +696,9 @@\n+        @Override\n+        @ForceInline\n+        public Byte128Mask compress() {\n+            return (Byte128Mask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n+                Byte128Vector.class, Byte128Mask.class, ETYPE, VLENGTH, null, this,\n+                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));\n+        }\n+\n+\n@@ -879,2 +904,2 @@\n-    ByteVector fromByteArray0(byte[] a, int offset) {\n-        return super.fromByteArray0Template(a, offset);  \/\/ specialize\n+    ByteVector fromMemorySegment0(MemorySegment ms, long offset) {\n+        return super.fromMemorySegment0Template(ms, offset);  \/\/ specialize\n@@ -886,16 +911,2 @@\n-    ByteVector fromByteArray0(byte[] a, int offset, VectorMask<Byte> m) {\n-        return super.fromByteArray0Template(Byte128Mask.class, a, offset, (Byte128Mask) m);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    ByteVector fromByteBuffer0(ByteBuffer bb, int offset) {\n-        return super.fromByteBuffer0Template(bb, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    ByteVector fromByteBuffer0(ByteBuffer bb, int offset, VectorMask<Byte> m) {\n-        return super.fromByteBuffer0Template(Byte128Mask.class, bb, offset, (Byte128Mask) m);  \/\/ specialize\n+    ByteVector fromMemorySegment0(MemorySegment ms, long offset, VectorMask<Byte> m) {\n+        return super.fromMemorySegment0Template(Byte128Mask.class, ms, offset, (Byte128Mask) m);  \/\/ specialize\n@@ -929,16 +940,2 @@\n-    void intoByteArray0(byte[] a, int offset) {\n-        super.intoByteArray0Template(a, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoByteArray0(byte[] a, int offset, VectorMask<Byte> m) {\n-        super.intoByteArray0Template(Byte128Mask.class, a, offset, (Byte128Mask) m);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoByteBuffer0(ByteBuffer bb, int offset, VectorMask<Byte> m) {\n-        super.intoByteBuffer0Template(Byte128Mask.class, bb, offset, (Byte128Mask) m);\n+    void intoMemorySegment0(MemorySegment ms, long offset, VectorMask<Byte> m) {\n+        super.intoMemorySegment0Template(Byte128Mask.class, ms, offset, (Byte128Mask) m);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte128Vector.java","additions":32,"deletions":35,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import java.nio.ByteBuffer;\n@@ -32,0 +31,1 @@\n+import jdk.incubator.foreign.MemorySegment;\n@@ -477,0 +477,16 @@\n+    @Override\n+    @ForceInline\n+    public Byte256Vector compress(VectorMask<Byte> m) {\n+        return (Byte256Vector)\n+            super.compressTemplate(Byte256Mask.class,\n+                                   (Byte256Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Byte256Vector expand(VectorMask<Byte> m) {\n+        return (Byte256Vector)\n+            super.expandTemplate(Byte256Mask.class,\n+                                   (Byte256Mask) m);  \/\/ specialize\n+    }\n+\n@@ -712,0 +728,9 @@\n+        @Override\n+        @ForceInline\n+        public Byte256Mask compress() {\n+            return (Byte256Mask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n+                Byte256Vector.class, Byte256Mask.class, ETYPE, VLENGTH, null, this,\n+                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));\n+        }\n+\n+\n@@ -911,2 +936,2 @@\n-    ByteVector fromByteArray0(byte[] a, int offset) {\n-        return super.fromByteArray0Template(a, offset);  \/\/ specialize\n+    ByteVector fromMemorySegment0(MemorySegment ms, long offset) {\n+        return super.fromMemorySegment0Template(ms, offset);  \/\/ specialize\n@@ -918,16 +943,2 @@\n-    ByteVector fromByteArray0(byte[] a, int offset, VectorMask<Byte> m) {\n-        return super.fromByteArray0Template(Byte256Mask.class, a, offset, (Byte256Mask) m);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    ByteVector fromByteBuffer0(ByteBuffer bb, int offset) {\n-        return super.fromByteBuffer0Template(bb, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    ByteVector fromByteBuffer0(ByteBuffer bb, int offset, VectorMask<Byte> m) {\n-        return super.fromByteBuffer0Template(Byte256Mask.class, bb, offset, (Byte256Mask) m);  \/\/ specialize\n+    ByteVector fromMemorySegment0(MemorySegment ms, long offset, VectorMask<Byte> m) {\n+        return super.fromMemorySegment0Template(Byte256Mask.class, ms, offset, (Byte256Mask) m);  \/\/ specialize\n@@ -961,16 +972,2 @@\n-    void intoByteArray0(byte[] a, int offset) {\n-        super.intoByteArray0Template(a, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoByteArray0(byte[] a, int offset, VectorMask<Byte> m) {\n-        super.intoByteArray0Template(Byte256Mask.class, a, offset, (Byte256Mask) m);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoByteBuffer0(ByteBuffer bb, int offset, VectorMask<Byte> m) {\n-        super.intoByteBuffer0Template(Byte256Mask.class, bb, offset, (Byte256Mask) m);\n+    void intoMemorySegment0(MemorySegment ms, long offset, VectorMask<Byte> m) {\n+        super.intoMemorySegment0Template(Byte256Mask.class, ms, offset, (Byte256Mask) m);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte256Vector.java","additions":32,"deletions":35,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import java.nio.ByteBuffer;\n@@ -32,0 +31,1 @@\n+import jdk.incubator.foreign.MemorySegment;\n@@ -477,0 +477,16 @@\n+    @Override\n+    @ForceInline\n+    public Byte512Vector compress(VectorMask<Byte> m) {\n+        return (Byte512Vector)\n+            super.compressTemplate(Byte512Mask.class,\n+                                   (Byte512Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Byte512Vector expand(VectorMask<Byte> m) {\n+        return (Byte512Vector)\n+            super.expandTemplate(Byte512Mask.class,\n+                                   (Byte512Mask) m);  \/\/ specialize\n+    }\n+\n@@ -776,0 +792,9 @@\n+        @Override\n+        @ForceInline\n+        public Byte512Mask compress() {\n+            return (Byte512Mask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n+                Byte512Vector.class, Byte512Mask.class, ETYPE, VLENGTH, null, this,\n+                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));\n+        }\n+\n+\n@@ -975,2 +1000,2 @@\n-    ByteVector fromByteArray0(byte[] a, int offset) {\n-        return super.fromByteArray0Template(a, offset);  \/\/ specialize\n+    ByteVector fromMemorySegment0(MemorySegment ms, long offset) {\n+        return super.fromMemorySegment0Template(ms, offset);  \/\/ specialize\n@@ -982,16 +1007,2 @@\n-    ByteVector fromByteArray0(byte[] a, int offset, VectorMask<Byte> m) {\n-        return super.fromByteArray0Template(Byte512Mask.class, a, offset, (Byte512Mask) m);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    ByteVector fromByteBuffer0(ByteBuffer bb, int offset) {\n-        return super.fromByteBuffer0Template(bb, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    ByteVector fromByteBuffer0(ByteBuffer bb, int offset, VectorMask<Byte> m) {\n-        return super.fromByteBuffer0Template(Byte512Mask.class, bb, offset, (Byte512Mask) m);  \/\/ specialize\n+    ByteVector fromMemorySegment0(MemorySegment ms, long offset, VectorMask<Byte> m) {\n+        return super.fromMemorySegment0Template(Byte512Mask.class, ms, offset, (Byte512Mask) m);  \/\/ specialize\n@@ -1025,16 +1036,2 @@\n-    void intoByteArray0(byte[] a, int offset) {\n-        super.intoByteArray0Template(a, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoByteArray0(byte[] a, int offset, VectorMask<Byte> m) {\n-        super.intoByteArray0Template(Byte512Mask.class, a, offset, (Byte512Mask) m);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoByteBuffer0(ByteBuffer bb, int offset, VectorMask<Byte> m) {\n-        super.intoByteBuffer0Template(Byte512Mask.class, bb, offset, (Byte512Mask) m);\n+    void intoMemorySegment0(MemorySegment ms, long offset, VectorMask<Byte> m) {\n+        super.intoMemorySegment0Template(Byte512Mask.class, ms, offset, (Byte512Mask) m);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte512Vector.java","additions":32,"deletions":35,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import java.nio.ByteBuffer;\n@@ -32,0 +31,1 @@\n+import jdk.incubator.foreign.MemorySegment;\n@@ -477,0 +477,16 @@\n+    @Override\n+    @ForceInline\n+    public Byte64Vector compress(VectorMask<Byte> m) {\n+        return (Byte64Vector)\n+            super.compressTemplate(Byte64Mask.class,\n+                                   (Byte64Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Byte64Vector expand(VectorMask<Byte> m) {\n+        return (Byte64Vector)\n+            super.expandTemplate(Byte64Mask.class,\n+                                   (Byte64Mask) m);  \/\/ specialize\n+    }\n+\n@@ -664,0 +680,9 @@\n+        @Override\n+        @ForceInline\n+        public Byte64Mask compress() {\n+            return (Byte64Mask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n+                Byte64Vector.class, Byte64Mask.class, ETYPE, VLENGTH, null, this,\n+                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));\n+        }\n+\n+\n@@ -863,2 +888,2 @@\n-    ByteVector fromByteArray0(byte[] a, int offset) {\n-        return super.fromByteArray0Template(a, offset);  \/\/ specialize\n+    ByteVector fromMemorySegment0(MemorySegment ms, long offset) {\n+        return super.fromMemorySegment0Template(ms, offset);  \/\/ specialize\n@@ -870,16 +895,2 @@\n-    ByteVector fromByteArray0(byte[] a, int offset, VectorMask<Byte> m) {\n-        return super.fromByteArray0Template(Byte64Mask.class, a, offset, (Byte64Mask) m);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    ByteVector fromByteBuffer0(ByteBuffer bb, int offset) {\n-        return super.fromByteBuffer0Template(bb, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    ByteVector fromByteBuffer0(ByteBuffer bb, int offset, VectorMask<Byte> m) {\n-        return super.fromByteBuffer0Template(Byte64Mask.class, bb, offset, (Byte64Mask) m);  \/\/ specialize\n+    ByteVector fromMemorySegment0(MemorySegment ms, long offset, VectorMask<Byte> m) {\n+        return super.fromMemorySegment0Template(Byte64Mask.class, ms, offset, (Byte64Mask) m);  \/\/ specialize\n@@ -913,16 +924,2 @@\n-    void intoByteArray0(byte[] a, int offset) {\n-        super.intoByteArray0Template(a, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoByteArray0(byte[] a, int offset, VectorMask<Byte> m) {\n-        super.intoByteArray0Template(Byte64Mask.class, a, offset, (Byte64Mask) m);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoByteBuffer0(ByteBuffer bb, int offset, VectorMask<Byte> m) {\n-        super.intoByteBuffer0Template(Byte64Mask.class, bb, offset, (Byte64Mask) m);\n+    void intoMemorySegment0(MemorySegment ms, long offset, VectorMask<Byte> m) {\n+        super.intoMemorySegment0Template(Byte64Mask.class, ms, offset, (Byte64Mask) m);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte64Vector.java","additions":32,"deletions":35,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import java.nio.ByteBuffer;\n@@ -32,0 +31,1 @@\n+import jdk.incubator.foreign.MemorySegment;\n@@ -477,0 +477,16 @@\n+    @Override\n+    @ForceInline\n+    public ByteMaxVector compress(VectorMask<Byte> m) {\n+        return (ByteMaxVector)\n+            super.compressTemplate(ByteMaxMask.class,\n+                                   (ByteMaxMask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public ByteMaxVector expand(VectorMask<Byte> m) {\n+        return (ByteMaxVector)\n+            super.expandTemplate(ByteMaxMask.class,\n+                                   (ByteMaxMask) m);  \/\/ specialize\n+    }\n+\n@@ -650,0 +666,9 @@\n+        @Override\n+        @ForceInline\n+        public ByteMaxMask compress() {\n+            return (ByteMaxMask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n+                ByteMaxVector.class, ByteMaxMask.class, ETYPE, VLENGTH, null, this,\n+                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));\n+        }\n+\n+\n@@ -849,2 +874,2 @@\n-    ByteVector fromByteArray0(byte[] a, int offset) {\n-        return super.fromByteArray0Template(a, offset);  \/\/ specialize\n+    ByteVector fromMemorySegment0(MemorySegment ms, long offset) {\n+        return super.fromMemorySegment0Template(ms, offset);  \/\/ specialize\n@@ -856,16 +881,2 @@\n-    ByteVector fromByteArray0(byte[] a, int offset, VectorMask<Byte> m) {\n-        return super.fromByteArray0Template(ByteMaxMask.class, a, offset, (ByteMaxMask) m);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    ByteVector fromByteBuffer0(ByteBuffer bb, int offset) {\n-        return super.fromByteBuffer0Template(bb, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    ByteVector fromByteBuffer0(ByteBuffer bb, int offset, VectorMask<Byte> m) {\n-        return super.fromByteBuffer0Template(ByteMaxMask.class, bb, offset, (ByteMaxMask) m);  \/\/ specialize\n+    ByteVector fromMemorySegment0(MemorySegment ms, long offset, VectorMask<Byte> m) {\n+        return super.fromMemorySegment0Template(ByteMaxMask.class, ms, offset, (ByteMaxMask) m);  \/\/ specialize\n@@ -899,16 +910,2 @@\n-    void intoByteArray0(byte[] a, int offset) {\n-        super.intoByteArray0Template(a, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoByteArray0(byte[] a, int offset, VectorMask<Byte> m) {\n-        super.intoByteArray0Template(ByteMaxMask.class, a, offset, (ByteMaxMask) m);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoByteBuffer0(ByteBuffer bb, int offset, VectorMask<Byte> m) {\n-        super.intoByteBuffer0Template(ByteMaxMask.class, bb, offset, (ByteMaxMask) m);\n+    void intoMemorySegment0(MemorySegment ms, long offset, VectorMask<Byte> m) {\n+        super.intoMemorySegment0Template(ByteMaxMask.class, ms, offset, (ByteMaxMask) m);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ByteMaxVector.java","additions":32,"deletions":35,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import java.nio.ByteBuffer;\n@@ -29,1 +28,0 @@\n-import java.nio.ReadOnlyBufferException;\n@@ -33,1 +31,0 @@\n-import java.util.function.UnaryOperator;\n@@ -35,0 +32,3 @@\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ValueLayout;\n+import jdk.internal.access.foreign.MemorySegmentProxy;\n@@ -60,0 +60,2 @@\n+    static final ValueLayout.OfByte ELEMENT_LAYOUT = ValueLayout.JAVA_BYTE.withBitAlignment(8);\n+\n@@ -354,0 +356,39 @@\n+    \/*package-private*\/\n+    interface FLdLongOp {\n+        byte apply(MemorySegment memory, long offset, int i);\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    ByteVector ldLongOp(MemorySegment memory, long offset,\n+                                  FLdLongOp f) {\n+        \/\/dummy; no vec = vec();\n+        byte[] res = new byte[length()];\n+        for (int i = 0; i < res.length; i++) {\n+            res[i] = f.apply(memory, offset, i);\n+        }\n+        return vectorFactory(res);\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    ByteVector ldLongOp(MemorySegment memory, long offset,\n+                                  VectorMask<Byte> m,\n+                                  FLdLongOp f) {\n+        \/\/byte[] vec = vec();\n+        byte[] res = new byte[length()];\n+        boolean[] mbits = ((AbstractMask<Byte>)m).getBits();\n+        for (int i = 0; i < res.length; i++) {\n+            if (mbits[i]) {\n+                res[i] = f.apply(memory, offset, i);\n+            }\n+        }\n+        return vectorFactory(res);\n+    }\n+\n+    static byte memorySegmentGet(MemorySegment ms, long o, int i) {\n+        return ms.get(ELEMENT_LAYOUT, o + i * 1L);\n+    }\n+\n@@ -384,0 +425,34 @@\n+    interface FStLongOp {\n+        void apply(MemorySegment memory, long offset, int i, byte a);\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    void stLongOp(MemorySegment memory, long offset,\n+                  FStLongOp f) {\n+        byte[] vec = vec();\n+        for (int i = 0; i < vec.length; i++) {\n+            f.apply(memory, offset, i, vec[i]);\n+        }\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    void stLongOp(MemorySegment memory, long offset,\n+                  VectorMask<Byte> m,\n+                  FStLongOp f) {\n+        byte[] vec = vec();\n+        boolean[] mbits = ((AbstractMask<Byte>)m).getBits();\n+        for (int i = 0; i < vec.length; i++) {\n+            if (mbits[i]) {\n+                f.apply(memory, offset, i, vec[i]);\n+            }\n+        }\n+    }\n+\n+    static void memorySegmentSet(MemorySegment ms, long o, int i, byte e) {\n+        ms.set(ELEMENT_LAYOUT, o + i * 1L, e);\n+    }\n+\n@@ -434,0 +509,30 @@\n+    static ByteVector expandHelper(Vector<Byte> v, VectorMask<Byte> m) {\n+        VectorSpecies<Byte> vsp = m.vectorSpecies();\n+        ByteVector r  = (ByteVector) vsp.zero();\n+        ByteVector vi = (ByteVector) v;\n+        if (m.allTrue()) {\n+            return vi;\n+        }\n+        for (int i = 0, j = 0; i < vsp.length(); i++) {\n+            if (m.laneIsSet(i)) {\n+                r = r.withLane(i, vi.lane(j++));\n+            }\n+        }\n+        return r;\n+    }\n+\n+    static ByteVector compressHelper(Vector<Byte> v, VectorMask<Byte> m) {\n+        VectorSpecies<Byte> vsp = m.vectorSpecies();\n+        ByteVector r  = (ByteVector) vsp.zero();\n+        ByteVector vi = (ByteVector) v;\n+        if (m.allTrue()) {\n+            return vi;\n+        }\n+        for (int i = 0, j = 0; i < vsp.length(); i++) {\n+            if (m.laneIsSet(i)) {\n+                r = r.withLane(j++, vi.lane(i));\n+            }\n+        }\n+        return r;\n+    }\n+\n@@ -623,0 +728,10 @@\n+            case VECTOR_OP_BIT_COUNT: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> (byte) bitCount(a));\n+            case VECTOR_OP_TZ_COUNT: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> (byte) numberOfTrailingZeros(a));\n+            case VECTOR_OP_LZ_COUNT: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> (byte) numberOfLeadingZeros(a));\n+            case VECTOR_OP_REVERSE: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> reverse(a));\n+            case VECTOR_OP_REVERSE_BYTES: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> a);\n@@ -1749,0 +1864,19 @@\n+    static int bitCount(byte a) {\n+        return Integer.bitCount((int)a & 0xFF);\n+    }\n+    static int numberOfTrailingZeros(byte a) {\n+        return a != 0 ? Integer.numberOfTrailingZeros(a) : 8;\n+    }\n+    static int numberOfLeadingZeros(byte a) {\n+        return a >= 0 ? Integer.numberOfLeadingZeros(a) - 24 : 0;\n+    }\n+\n+    static byte reverse(byte a) {\n+        if (a == 0 || a == -1) return a;\n+\n+        byte b = rotateLeft(a, 4);\n+        b = (byte) (((b & 0x55) << 1) | ((b & 0xAA) >>> 1));\n+        b = (byte) (((b & 0x33) << 2) | ((b & 0xCC) >>> 2));\n+        return b;\n+    }\n+\n@@ -2375,0 +2509,39 @@\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     * @since 19\n+     *\/\n+    @Override\n+    public abstract\n+    ByteVector compress(VectorMask<Byte> m);\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M extends AbstractMask<Byte>>\n+    ByteVector compressTemplate(Class<M> masktype, M m) {\n+      m.check(masktype, this);\n+      return (ByteVector) VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_COMPRESS, getClass(), masktype,\n+                                                        byte.class, length(), this, m,\n+                                                        (v1, m1) -> compressHelper(v1, m1));\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     * @since 19\n+     *\/\n+    @Override\n+    public abstract\n+    ByteVector expand(VectorMask<Byte> m);\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M extends AbstractMask<Byte>>\n+    ByteVector expandTemplate(Class<M> masktype, M m) {\n+      m.check(masktype, this);\n+      return (ByteVector) VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_EXPAND, getClass(), masktype,\n+                                                        byte.class, length(), this, m,\n+                                                        (v1, m1) -> expandHelper(v1, m1));\n+    }\n+\n+\n@@ -2787,84 +2960,0 @@\n-    \/**\n-     * Loads a vector from a byte array starting at an offset.\n-     * Bytes are composed into primitive lane elements according\n-     * to the specified byte order.\n-     * The vector is arranged into lanes according to\n-     * <a href=\"Vector.html#lane-order\">memory ordering<\/a>.\n-     * <p>\n-     * This method behaves as if it returns the result of calling\n-     * {@link #fromByteBuffer(VectorSpecies,ByteBuffer,int,ByteOrder,VectorMask)\n-     * fromByteBuffer()} as follows:\n-     * <pre>{@code\n-     * var bb = ByteBuffer.wrap(a);\n-     * var m = species.maskAll(true);\n-     * return fromByteBuffer(species, bb, offset, bo, m);\n-     * }<\/pre>\n-     *\n-     * @param species species of desired vector\n-     * @param a the byte array\n-     * @param offset the offset into the array\n-     * @param bo the intended byte order\n-     * @return a vector loaded from a byte array\n-     * @throws IndexOutOfBoundsException\n-     *         if {@code offset+N*ESIZE < 0}\n-     *         or {@code offset+(N+1)*ESIZE > a.length}\n-     *         for any lane {@code N} in the vector\n-     *\/\n-    @ForceInline\n-    public static\n-    ByteVector fromByteArray(VectorSpecies<Byte> species,\n-                                       byte[] a, int offset,\n-                                       ByteOrder bo) {\n-        offset = checkFromIndexSize(offset, species.vectorByteSize(), a.length);\n-        ByteSpecies vsp = (ByteSpecies) species;\n-        return vsp.dummyVector().fromByteArray0(a, offset).maybeSwap(bo);\n-    }\n-\n-    \/**\n-     * Loads a vector from a byte array starting at an offset\n-     * and using a mask.\n-     * Lanes where the mask is unset are filled with the default\n-     * value of {@code byte} (zero).\n-     * Bytes are composed into primitive lane elements according\n-     * to the specified byte order.\n-     * The vector is arranged into lanes according to\n-     * <a href=\"Vector.html#lane-order\">memory ordering<\/a>.\n-     * <p>\n-     * This method behaves as if it returns the result of calling\n-     * {@link #fromByteBuffer(VectorSpecies,ByteBuffer,int,ByteOrder,VectorMask)\n-     * fromByteBuffer()} as follows:\n-     * <pre>{@code\n-     * var bb = ByteBuffer.wrap(a);\n-     * return fromByteBuffer(species, bb, offset, bo, m);\n-     * }<\/pre>\n-     *\n-     * @param species species of desired vector\n-     * @param a the byte array\n-     * @param offset the offset into the array\n-     * @param bo the intended byte order\n-     * @param m the mask controlling lane selection\n-     * @return a vector loaded from a byte array\n-     * @throws IndexOutOfBoundsException\n-     *         if {@code offset+N*ESIZE < 0}\n-     *         or {@code offset+(N+1)*ESIZE > a.length}\n-     *         for any lane {@code N} in the vector\n-     *         where the mask is set\n-     *\/\n-    @ForceInline\n-    public static\n-    ByteVector fromByteArray(VectorSpecies<Byte> species,\n-                                       byte[] a, int offset,\n-                                       ByteOrder bo,\n-                                       VectorMask<Byte> m) {\n-        ByteSpecies vsp = (ByteSpecies) species;\n-        if (offset >= 0 && offset <= (a.length - species.vectorByteSize())) {\n-            return vsp.dummyVector().fromByteArray0(a, offset, m).maybeSwap(bo);\n-        }\n-\n-        \/\/ FIXME: optimize\n-        checkMaskFromIndexSize(offset, vsp, m, 1, a.length);\n-        ByteBuffer wb = wrapper(a, bo);\n-        return vsp.ldOp(wb, offset, (AbstractMask<Byte>)m,\n-                   (wb_, o, i)  -> wb_.get(o + i * 1));\n-    }\n-\n@@ -3177,2 +3266,2 @@\n-     * Loads a vector from a {@linkplain ByteBuffer byte buffer}\n-     * starting at an offset into the byte buffer.\n+     * Loads a vector from a {@linkplain MemorySegment memory segment}\n+     * starting at an offset into the memory segment.\n@@ -3185,2 +3274,2 @@\n-     * {@link #fromByteBuffer(VectorSpecies,ByteBuffer,int,ByteOrder,VectorMask)\n-     * fromByteBuffer()} as follows:\n+     * {@link #fromMemorySegment(VectorSpecies,MemorySegment,long,ByteOrder,VectorMask)\n+     * fromMemorySegment()} as follows:\n@@ -3189,1 +3278,1 @@\n-     * return fromByteBuffer(species, bb, offset, bo, m);\n+     * return fromMemorySegment(species, ms, offset, bo, m);\n@@ -3193,2 +3282,2 @@\n-     * @param bb the byte buffer\n-     * @param offset the offset into the byte buffer\n+     * @param ms the memory segment\n+     * @param offset the offset into the memory segment\n@@ -3196,1 +3285,1 @@\n-     * @return a vector loaded from a byte buffer\n+     * @return a vector loaded from the memory segment\n@@ -3199,1 +3288,1 @@\n-     *         or {@code offset+N*1 >= bb.limit()}\n+     *         or {@code offset+N*1 >= ms.byteSize()}\n@@ -3201,0 +3290,5 @@\n+     * @throws IllegalArgumentException if the memory segment is a heap segment that is\n+     *         not backed by a {@code byte[]} array.\n+     * @throws IllegalStateException if the memory segment's session is not alive,\n+     *         or if access occurs from a thread other than the thread owning the session.\n+     * @since 19\n@@ -3204,4 +3298,4 @@\n-    ByteVector fromByteBuffer(VectorSpecies<Byte> species,\n-                                        ByteBuffer bb, int offset,\n-                                        ByteOrder bo) {\n-        offset = checkFromIndexSize(offset, species.vectorByteSize(), bb.limit());\n+    ByteVector fromMemorySegment(VectorSpecies<Byte> species,\n+                                           MemorySegment ms, long offset,\n+                                           ByteOrder bo) {\n+        offset = checkFromIndexSize(offset, species.vectorByteSize(), ms.byteSize());\n@@ -3209,1 +3303,1 @@\n-        return vsp.dummyVector().fromByteBuffer0(bb, offset).maybeSwap(bo);\n+        return vsp.dummyVector().fromMemorySegment0(ms, offset).maybeSwap(bo);\n@@ -3213,2 +3307,2 @@\n-     * Loads a vector from a {@linkplain ByteBuffer byte buffer}\n-     * starting at an offset into the byte buffer\n+     * Loads a vector from a {@linkplain MemorySegment memory segment}\n+     * starting at an offset into the memory segment\n@@ -3225,2 +3319,1 @@\n-     * ByteBuffer eb = bb.duplicate()\n-     *     .position(offset);\n+     * var slice = ms.asSlice(offset);\n@@ -3230,1 +3323,1 @@\n-     *         ar[n] = eb.get(n);\n+     *         ar[n] = slice.getAtIndex(ValuaLayout.JAVA_BYTE.withBitAlignment(8), n);\n@@ -3239,2 +3332,2 @@\n-     * @param bb the byte buffer\n-     * @param offset the offset into the byte buffer\n+     * @param ms the memory segment\n+     * @param offset the offset into the memory segment\n@@ -3243,1 +3336,1 @@\n-     * @return a vector loaded from a byte buffer\n+     * @return a vector loaded from the memory segment\n@@ -3246,1 +3339,1 @@\n-     *         or {@code offset+N*1 >= bb.limit()}\n+     *         or {@code offset+N*1 >= ms.byteSize()}\n@@ -3249,0 +3342,5 @@\n+     * @throws IllegalArgumentException if the memory segment is a heap segment that is\n+     *         not backed by a {@code byte[]} array.\n+     * @throws IllegalStateException if the memory segment's session is not alive,\n+     *         or if access occurs from a thread other than the thread owning the session.\n+     * @since 19\n@@ -3252,4 +3350,4 @@\n-    ByteVector fromByteBuffer(VectorSpecies<Byte> species,\n-                                        ByteBuffer bb, int offset,\n-                                        ByteOrder bo,\n-                                        VectorMask<Byte> m) {\n+    ByteVector fromMemorySegment(VectorSpecies<Byte> species,\n+                                           MemorySegment ms, long offset,\n+                                           ByteOrder bo,\n+                                           VectorMask<Byte> m) {\n@@ -3257,2 +3355,2 @@\n-        if (offset >= 0 && offset <= (bb.limit() - species.vectorByteSize())) {\n-            return vsp.dummyVector().fromByteBuffer0(bb, offset, m).maybeSwap(bo);\n+        if (offset >= 0 && offset <= (ms.byteSize() - species.vectorByteSize())) {\n+            return vsp.dummyVector().fromMemorySegment0(ms, offset, m).maybeSwap(bo);\n@@ -3262,4 +3360,2 @@\n-        checkMaskFromIndexSize(offset, vsp, m, 1, bb.limit());\n-        ByteBuffer wb = wrapper(bb, bo);\n-        return vsp.ldOp(wb, offset, (AbstractMask<Byte>)m,\n-                   (wb_, o, i)  -> wb_.get(o + i * 1));\n+        checkMaskFromIndexSize(offset, vsp, m, 1, ms.byteSize());\n+        return vsp.ldLongOp(ms, offset, m, ByteVector::memorySegmentGet);\n@@ -3295,1 +3391,1 @@\n-            -> v.stOp(arr, off,\n+            -> v.stOp(arr, (int) off,\n@@ -3446,1 +3542,1 @@\n-            -> v.stOp(arr, off,\n+            -> v.stOp(arr, (int) off,\n@@ -3584,0 +3680,1 @@\n+     * @since 19\n@@ -3588,21 +3685,4 @@\n-    void intoByteArray(byte[] a, int offset,\n-                       ByteOrder bo) {\n-        offset = checkFromIndexSize(offset, byteSize(), a.length);\n-        maybeSwap(bo).intoByteArray0(a, offset);\n-    }\n-\n-    \/**\n-     * {@inheritDoc} <!--workaround-->\n-     *\/\n-    @Override\n-    @ForceInline\n-    public final\n-    void intoByteArray(byte[] a, int offset,\n-                       ByteOrder bo,\n-                       VectorMask<Byte> m) {\n-        if (m.allTrue()) {\n-            intoByteArray(a, offset, bo);\n-        } else {\n-            ByteSpecies vsp = vspecies();\n-            checkMaskFromIndexSize(offset, vsp, m, 1, a.length);\n-            maybeSwap(bo).intoByteArray0(a, offset, m);\n+    void intoMemorySegment(MemorySegment ms, long offset,\n+                           ByteOrder bo) {\n+        if (ms.isReadOnly()) {\n+            throw new UnsupportedOperationException(\"Attempt to write a read-only segment\");\n@@ -3610,1 +3690,0 @@\n-    }\n@@ -3612,13 +3691,2 @@\n-    \/**\n-     * {@inheritDoc} <!--workaround-->\n-     *\/\n-    @Override\n-    @ForceInline\n-    public final\n-    void intoByteBuffer(ByteBuffer bb, int offset,\n-                        ByteOrder bo) {\n-        if (ScopedMemoryAccess.isReadOnly(bb)) {\n-            throw new ReadOnlyBufferException();\n-        }\n-        offset = checkFromIndexSize(offset, byteSize(), bb.limit());\n-        maybeSwap(bo).intoByteBuffer0(bb, offset);\n+        offset = checkFromIndexSize(offset, byteSize(), ms.byteSize());\n+        maybeSwap(bo).intoMemorySegment0(ms, offset);\n@@ -3629,0 +3697,1 @@\n+     * @since 19\n@@ -3633,3 +3702,3 @@\n-    void intoByteBuffer(ByteBuffer bb, int offset,\n-                        ByteOrder bo,\n-                        VectorMask<Byte> m) {\n+    void intoMemorySegment(MemorySegment ms, long offset,\n+                           ByteOrder bo,\n+                           VectorMask<Byte> m) {\n@@ -3637,1 +3706,1 @@\n-            intoByteBuffer(bb, offset, bo);\n+            intoMemorySegment(ms, offset, bo);\n@@ -3639,2 +3708,2 @@\n-            if (bb.isReadOnly()) {\n-                throw new ReadOnlyBufferException();\n+            if (ms.isReadOnly()) {\n+                throw new UnsupportedOperationException(\"Attempt to write a read-only segment\");\n@@ -3643,2 +3712,2 @@\n-            checkMaskFromIndexSize(offset, vsp, m, 1, bb.limit());\n-            maybeSwap(bo).intoByteBuffer0(bb, offset, m);\n+            checkMaskFromIndexSize(offset, vsp, m, 1, ms.byteSize());\n+            maybeSwap(bo).intoMemorySegment0(ms, offset, m);\n@@ -3678,1 +3747,1 @@\n-            (arr, off, s) -> s.ldOp(arr, off,\n+            (arr, off, s) -> s.ldOp(arr, (int) off,\n@@ -3695,1 +3764,1 @@\n-            (arr, off, s, vm) -> s.ldOp(arr, off, vm,\n+            (arr, off, s, vm) -> s.ldOp(arr, (int) off, vm,\n@@ -3712,1 +3781,1 @@\n-            (arr, off, s) -> s.ldOp(arr, off,\n+            (arr, off, s) -> s.ldOp(arr, (int) off,\n@@ -3729,1 +3798,1 @@\n-            (arr, off, s, vm) -> s.ldOp(arr, off, vm,\n+            (arr, off, s, vm) -> s.ldOp(arr, (int) off, vm,\n@@ -3733,1 +3802,0 @@\n-    @Override\n@@ -3735,1 +3803,1 @@\n-    ByteVector fromByteArray0(byte[] a, int offset);\n+    ByteVector fromMemorySegment0(MemorySegment bb, long offset);\n@@ -3738,1 +3806,1 @@\n-    ByteVector fromByteArray0Template(byte[] a, int offset) {\n+    ByteVector fromMemorySegment0Template(MemorySegment ms, long offset) {\n@@ -3740,37 +3808,1 @@\n-        return VectorSupport.load(\n-            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n-            a, byteArrayAddress(a, offset),\n-            a, offset, vsp,\n-            (arr, off, s) -> {\n-                ByteBuffer wb = wrapper(arr, NATIVE_ENDIAN);\n-                return s.ldOp(wb, off,\n-                        (wb_, o, i) -> wb_.get(o + i * 1));\n-            });\n-    }\n-\n-    abstract\n-    ByteVector fromByteArray0(byte[] a, int offset, VectorMask<Byte> m);\n-    @ForceInline\n-    final\n-    <M extends VectorMask<Byte>>\n-    ByteVector fromByteArray0Template(Class<M> maskClass, byte[] a, int offset, M m) {\n-        ByteSpecies vsp = vspecies();\n-        m.check(vsp);\n-        return VectorSupport.loadMasked(\n-            vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n-            a, byteArrayAddress(a, offset), m,\n-            a, offset, vsp,\n-            (arr, off, s, vm) -> {\n-                ByteBuffer wb = wrapper(arr, NATIVE_ENDIAN);\n-                return s.ldOp(wb, off, vm,\n-                        (wb_, o, i) -> wb_.get(o + i * 1));\n-            });\n-    }\n-\n-    abstract\n-    ByteVector fromByteBuffer0(ByteBuffer bb, int offset);\n-    @ForceInline\n-    final\n-    ByteVector fromByteBuffer0Template(ByteBuffer bb, int offset) {\n-        ByteSpecies vsp = vspecies();\n-        return ScopedMemoryAccess.loadFromByteBuffer(\n+        return ScopedMemoryAccess.loadFromMemorySegment(\n@@ -3778,5 +3810,3 @@\n-                bb, offset, vsp,\n-                (buf, off, s) -> {\n-                    ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n-                    return s.ldOp(wb, off,\n-                            (wb_, o, i) -> wb_.get(o + i * 1));\n+                (MemorySegmentProxy) ms, offset, vsp,\n+                (msp, off, s) -> {\n+                    return s.ldLongOp((MemorySegment) msp, off, ByteVector::memorySegmentGet);\n@@ -3787,1 +3817,1 @@\n-    ByteVector fromByteBuffer0(ByteBuffer bb, int offset, VectorMask<Byte> m);\n+    ByteVector fromMemorySegment0(MemorySegment ms, long offset, VectorMask<Byte> m);\n@@ -3791,1 +3821,1 @@\n-    ByteVector fromByteBuffer0Template(Class<M> maskClass, ByteBuffer bb, int offset, M m) {\n+    ByteVector fromMemorySegment0Template(Class<M> maskClass, MemorySegment ms, long offset, M m) {\n@@ -3794,1 +3824,1 @@\n-        return ScopedMemoryAccess.loadFromByteBufferMasked(\n+        return ScopedMemoryAccess.loadFromMemorySegmentMasked(\n@@ -3796,5 +3826,3 @@\n-                bb, offset, m, vsp,\n-                (buf, off, s, vm) -> {\n-                    ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n-                    return s.ldOp(wb, off, vm,\n-                            (wb_, o, i) -> wb_.get(o + i * 1));\n+                (MemorySegmentProxy) ms, offset, m, vsp,\n+                (msp, off, s, vm) -> {\n+                    return s.ldLongOp((MemorySegment) msp, off, vm, ByteVector::memorySegmentGet);\n@@ -3819,1 +3847,1 @@\n-            -> v.stOp(arr, off,\n+            -> v.stOp(arr, (int) off,\n@@ -3836,1 +3864,1 @@\n-            -> v.stOp(arr, off, vm,\n+            -> v.stOp(arr, (int) off, vm,\n@@ -3855,1 +3883,1 @@\n-            -> v.stOp(arr, off, vm,\n+            -> v.stOp(arr, (int) off, vm,\n@@ -3859,36 +3887,0 @@\n-    abstract\n-    void intoByteArray0(byte[] a, int offset);\n-    @ForceInline\n-    final\n-    void intoByteArray0Template(byte[] a, int offset) {\n-        ByteSpecies vsp = vspecies();\n-        VectorSupport.store(\n-            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n-            a, byteArrayAddress(a, offset),\n-            this, a, offset,\n-            (arr, off, v) -> {\n-                ByteBuffer wb = wrapper(arr, NATIVE_ENDIAN);\n-                v.stOp(wb, off,\n-                        (tb_, o, i, e) -> tb_.put(o + i * 1, e));\n-            });\n-    }\n-\n-    abstract\n-    void intoByteArray0(byte[] a, int offset, VectorMask<Byte> m);\n-    @ForceInline\n-    final\n-    <M extends VectorMask<Byte>>\n-    void intoByteArray0Template(Class<M> maskClass, byte[] a, int offset, M m) {\n-        ByteSpecies vsp = vspecies();\n-        m.check(vsp);\n-        VectorSupport.storeMasked(\n-            vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n-            a, byteArrayAddress(a, offset),\n-            this, m, a, offset,\n-            (arr, off, v, vm) -> {\n-                ByteBuffer wb = wrapper(arr, NATIVE_ENDIAN);\n-                v.stOp(wb, off, vm,\n-                        (tb_, o, i, e) -> tb_.put(o + i * 1, e));\n-            });\n-    }\n-\n@@ -3897,1 +3889,1 @@\n-    void intoByteBuffer0(ByteBuffer bb, int offset) {\n+    void intoMemorySegment0(MemorySegment ms, long offset) {\n@@ -3899,1 +3891,1 @@\n-        ScopedMemoryAccess.storeIntoByteBuffer(\n+        ScopedMemoryAccess.storeIntoMemorySegment(\n@@ -3901,5 +3893,4 @@\n-                this, bb, offset,\n-                (buf, off, v) -> {\n-                    ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n-                    v.stOp(wb, off,\n-                            (wb_, o, i, e) -> wb_.put(o + i * 1, e));\n+                this,\n+                (MemorySegmentProxy) ms, offset,\n+                (msp, off, v) -> {\n+                    v.stLongOp((MemorySegment) msp, off, ByteVector::memorySegmentSet);\n@@ -3910,1 +3901,1 @@\n-    void intoByteBuffer0(ByteBuffer bb, int offset, VectorMask<Byte> m);\n+    void intoMemorySegment0(MemorySegment bb, long offset, VectorMask<Byte> m);\n@@ -3914,1 +3905,1 @@\n-    void intoByteBuffer0Template(Class<M> maskClass, ByteBuffer bb, int offset, M m) {\n+    void intoMemorySegment0Template(Class<M> maskClass, MemorySegment ms, long offset, M m) {\n@@ -3917,1 +3908,1 @@\n-        ScopedMemoryAccess.storeIntoByteBufferMasked(\n+        ScopedMemoryAccess.storeIntoMemorySegmentMasked(\n@@ -3919,5 +3910,4 @@\n-                this, m, bb, offset,\n-                (buf, off, v, vm) -> {\n-                    ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n-                    v.stOp(wb, off, vm,\n-                            (wb_, o, i, e) -> wb_.put(o + i * 1, e));\n+                this, m,\n+                (MemorySegmentProxy) ms, offset,\n+                (msp, off, v, vm) -> {\n+                    v.stLongOp((MemorySegment) msp, off, vm, ByteVector::memorySegmentSet);\n@@ -3940,0 +3930,10 @@\n+    private static\n+    void checkMaskFromIndexSize(long offset,\n+                                ByteSpecies vsp,\n+                                VectorMask<Byte> m,\n+                                int scale,\n+                                long limit) {\n+        ((AbstractMask<Byte>)m)\n+            .checkIndexByLane(offset, limit, vsp.iota(), scale);\n+    }\n+\n@@ -4259,0 +4259,15 @@\n+        \/*package-private*\/\n+        @ForceInline\n+        ByteVector ldLongOp(MemorySegment memory, long offset,\n+                                      FLdLongOp f) {\n+            return dummyVector().ldLongOp(memory, offset, f);\n+        }\n+\n+        \/*package-private*\/\n+        @ForceInline\n+        ByteVector ldLongOp(MemorySegment memory, long offset,\n+                                      VectorMask<Byte> m,\n+                                      FLdLongOp f) {\n+            return dummyVector().ldLongOp(memory, offset, m, f);\n+        }\n+\n@@ -4273,0 +4288,14 @@\n+        \/*package-private*\/\n+        @ForceInline\n+        void stLongOp(MemorySegment memory, long offset, FStLongOp f) {\n+            dummyVector().stLongOp(memory, offset, f);\n+        }\n+\n+        \/*package-private*\/\n+        @ForceInline\n+        void stLongOp(MemorySegment memory, long offset,\n+                      AbstractMask<Byte> m,\n+                      FStLongOp f) {\n+            dummyVector().stLongOp(memory, offset, m, f);\n+        }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ByteVector.java","additions":305,"deletions":276,"binary":false,"changes":581,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import java.nio.ByteBuffer;\n@@ -32,0 +31,1 @@\n+import jdk.incubator.foreign.MemorySegment;\n@@ -464,0 +464,16 @@\n+    @Override\n+    @ForceInline\n+    public Double128Vector compress(VectorMask<Double> m) {\n+        return (Double128Vector)\n+            super.compressTemplate(Double128Mask.class,\n+                                   (Double128Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Double128Vector expand(VectorMask<Double> m) {\n+        return (Double128Vector)\n+            super.expandTemplate(Double128Mask.class,\n+                                   (Double128Mask) m);  \/\/ specialize\n+    }\n+\n@@ -641,0 +657,9 @@\n+        @Override\n+        @ForceInline\n+        public Double128Mask compress() {\n+            return (Double128Mask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n+                Double128Vector.class, Double128Mask.class, ETYPE, VLENGTH, null, this,\n+                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));\n+        }\n+\n+\n@@ -833,2 +858,2 @@\n-    DoubleVector fromByteArray0(byte[] a, int offset) {\n-        return super.fromByteArray0Template(a, offset);  \/\/ specialize\n+    DoubleVector fromMemorySegment0(MemorySegment ms, long offset) {\n+        return super.fromMemorySegment0Template(ms, offset);  \/\/ specialize\n@@ -840,16 +865,2 @@\n-    DoubleVector fromByteArray0(byte[] a, int offset, VectorMask<Double> m) {\n-        return super.fromByteArray0Template(Double128Mask.class, a, offset, (Double128Mask) m);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    DoubleVector fromByteBuffer0(ByteBuffer bb, int offset) {\n-        return super.fromByteBuffer0Template(bb, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    DoubleVector fromByteBuffer0(ByteBuffer bb, int offset, VectorMask<Double> m) {\n-        return super.fromByteBuffer0Template(Double128Mask.class, bb, offset, (Double128Mask) m);  \/\/ specialize\n+    DoubleVector fromMemorySegment0(MemorySegment ms, long offset, VectorMask<Double> m) {\n+        return super.fromMemorySegment0Template(Double128Mask.class, ms, offset, (Double128Mask) m);  \/\/ specialize\n@@ -883,16 +894,2 @@\n-    void intoByteArray0(byte[] a, int offset) {\n-        super.intoByteArray0Template(a, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoByteArray0(byte[] a, int offset, VectorMask<Double> m) {\n-        super.intoByteArray0Template(Double128Mask.class, a, offset, (Double128Mask) m);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoByteBuffer0(ByteBuffer bb, int offset, VectorMask<Double> m) {\n-        super.intoByteBuffer0Template(Double128Mask.class, bb, offset, (Double128Mask) m);\n+    void intoMemorySegment0(MemorySegment ms, long offset, VectorMask<Double> m) {\n+        super.intoMemorySegment0Template(Double128Mask.class, ms, offset, (Double128Mask) m);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double128Vector.java","additions":32,"deletions":35,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import java.nio.ByteBuffer;\n@@ -32,0 +31,1 @@\n+import jdk.incubator.foreign.MemorySegment;\n@@ -464,0 +464,16 @@\n+    @Override\n+    @ForceInline\n+    public Double256Vector compress(VectorMask<Double> m) {\n+        return (Double256Vector)\n+            super.compressTemplate(Double256Mask.class,\n+                                   (Double256Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Double256Vector expand(VectorMask<Double> m) {\n+        return (Double256Vector)\n+            super.expandTemplate(Double256Mask.class,\n+                                   (Double256Mask) m);  \/\/ specialize\n+    }\n+\n@@ -645,0 +661,9 @@\n+        @Override\n+        @ForceInline\n+        public Double256Mask compress() {\n+            return (Double256Mask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n+                Double256Vector.class, Double256Mask.class, ETYPE, VLENGTH, null, this,\n+                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));\n+        }\n+\n+\n@@ -837,2 +862,2 @@\n-    DoubleVector fromByteArray0(byte[] a, int offset) {\n-        return super.fromByteArray0Template(a, offset);  \/\/ specialize\n+    DoubleVector fromMemorySegment0(MemorySegment ms, long offset) {\n+        return super.fromMemorySegment0Template(ms, offset);  \/\/ specialize\n@@ -844,16 +869,2 @@\n-    DoubleVector fromByteArray0(byte[] a, int offset, VectorMask<Double> m) {\n-        return super.fromByteArray0Template(Double256Mask.class, a, offset, (Double256Mask) m);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    DoubleVector fromByteBuffer0(ByteBuffer bb, int offset) {\n-        return super.fromByteBuffer0Template(bb, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    DoubleVector fromByteBuffer0(ByteBuffer bb, int offset, VectorMask<Double> m) {\n-        return super.fromByteBuffer0Template(Double256Mask.class, bb, offset, (Double256Mask) m);  \/\/ specialize\n+    DoubleVector fromMemorySegment0(MemorySegment ms, long offset, VectorMask<Double> m) {\n+        return super.fromMemorySegment0Template(Double256Mask.class, ms, offset, (Double256Mask) m);  \/\/ specialize\n@@ -887,16 +898,2 @@\n-    void intoByteArray0(byte[] a, int offset) {\n-        super.intoByteArray0Template(a, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoByteArray0(byte[] a, int offset, VectorMask<Double> m) {\n-        super.intoByteArray0Template(Double256Mask.class, a, offset, (Double256Mask) m);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoByteBuffer0(ByteBuffer bb, int offset, VectorMask<Double> m) {\n-        super.intoByteBuffer0Template(Double256Mask.class, bb, offset, (Double256Mask) m);\n+    void intoMemorySegment0(MemorySegment ms, long offset, VectorMask<Double> m) {\n+        super.intoMemorySegment0Template(Double256Mask.class, ms, offset, (Double256Mask) m);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double256Vector.java","additions":32,"deletions":35,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import java.nio.ByteBuffer;\n@@ -32,0 +31,1 @@\n+import jdk.incubator.foreign.MemorySegment;\n@@ -464,0 +464,16 @@\n+    @Override\n+    @ForceInline\n+    public Double512Vector compress(VectorMask<Double> m) {\n+        return (Double512Vector)\n+            super.compressTemplate(Double512Mask.class,\n+                                   (Double512Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Double512Vector expand(VectorMask<Double> m) {\n+        return (Double512Vector)\n+            super.expandTemplate(Double512Mask.class,\n+                                   (Double512Mask) m);  \/\/ specialize\n+    }\n+\n@@ -653,0 +669,9 @@\n+        @Override\n+        @ForceInline\n+        public Double512Mask compress() {\n+            return (Double512Mask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n+                Double512Vector.class, Double512Mask.class, ETYPE, VLENGTH, null, this,\n+                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));\n+        }\n+\n+\n@@ -845,2 +870,2 @@\n-    DoubleVector fromByteArray0(byte[] a, int offset) {\n-        return super.fromByteArray0Template(a, offset);  \/\/ specialize\n+    DoubleVector fromMemorySegment0(MemorySegment ms, long offset) {\n+        return super.fromMemorySegment0Template(ms, offset);  \/\/ specialize\n@@ -852,16 +877,2 @@\n-    DoubleVector fromByteArray0(byte[] a, int offset, VectorMask<Double> m) {\n-        return super.fromByteArray0Template(Double512Mask.class, a, offset, (Double512Mask) m);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    DoubleVector fromByteBuffer0(ByteBuffer bb, int offset) {\n-        return super.fromByteBuffer0Template(bb, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    DoubleVector fromByteBuffer0(ByteBuffer bb, int offset, VectorMask<Double> m) {\n-        return super.fromByteBuffer0Template(Double512Mask.class, bb, offset, (Double512Mask) m);  \/\/ specialize\n+    DoubleVector fromMemorySegment0(MemorySegment ms, long offset, VectorMask<Double> m) {\n+        return super.fromMemorySegment0Template(Double512Mask.class, ms, offset, (Double512Mask) m);  \/\/ specialize\n@@ -895,16 +906,2 @@\n-    void intoByteArray0(byte[] a, int offset) {\n-        super.intoByteArray0Template(a, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoByteArray0(byte[] a, int offset, VectorMask<Double> m) {\n-        super.intoByteArray0Template(Double512Mask.class, a, offset, (Double512Mask) m);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoByteBuffer0(ByteBuffer bb, int offset, VectorMask<Double> m) {\n-        super.intoByteBuffer0Template(Double512Mask.class, bb, offset, (Double512Mask) m);\n+    void intoMemorySegment0(MemorySegment ms, long offset, VectorMask<Double> m) {\n+        super.intoMemorySegment0Template(Double512Mask.class, ms, offset, (Double512Mask) m);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double512Vector.java","additions":32,"deletions":35,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import java.nio.ByteBuffer;\n@@ -32,0 +31,1 @@\n+import jdk.incubator.foreign.MemorySegment;\n@@ -464,0 +464,16 @@\n+    @Override\n+    @ForceInline\n+    public Double64Vector compress(VectorMask<Double> m) {\n+        return (Double64Vector)\n+            super.compressTemplate(Double64Mask.class,\n+                                   (Double64Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Double64Vector expand(VectorMask<Double> m) {\n+        return (Double64Vector)\n+            super.expandTemplate(Double64Mask.class,\n+                                   (Double64Mask) m);  \/\/ specialize\n+    }\n+\n@@ -639,0 +655,9 @@\n+        @Override\n+        @ForceInline\n+        public Double64Mask compress() {\n+            return (Double64Mask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n+                Double64Vector.class, Double64Mask.class, ETYPE, VLENGTH, null, this,\n+                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));\n+        }\n+\n+\n@@ -831,2 +856,2 @@\n-    DoubleVector fromByteArray0(byte[] a, int offset) {\n-        return super.fromByteArray0Template(a, offset);  \/\/ specialize\n+    DoubleVector fromMemorySegment0(MemorySegment ms, long offset) {\n+        return super.fromMemorySegment0Template(ms, offset);  \/\/ specialize\n@@ -838,16 +863,2 @@\n-    DoubleVector fromByteArray0(byte[] a, int offset, VectorMask<Double> m) {\n-        return super.fromByteArray0Template(Double64Mask.class, a, offset, (Double64Mask) m);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    DoubleVector fromByteBuffer0(ByteBuffer bb, int offset) {\n-        return super.fromByteBuffer0Template(bb, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    DoubleVector fromByteBuffer0(ByteBuffer bb, int offset, VectorMask<Double> m) {\n-        return super.fromByteBuffer0Template(Double64Mask.class, bb, offset, (Double64Mask) m);  \/\/ specialize\n+    DoubleVector fromMemorySegment0(MemorySegment ms, long offset, VectorMask<Double> m) {\n+        return super.fromMemorySegment0Template(Double64Mask.class, ms, offset, (Double64Mask) m);  \/\/ specialize\n@@ -881,16 +892,2 @@\n-    void intoByteArray0(byte[] a, int offset) {\n-        super.intoByteArray0Template(a, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoByteArray0(byte[] a, int offset, VectorMask<Double> m) {\n-        super.intoByteArray0Template(Double64Mask.class, a, offset, (Double64Mask) m);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoByteBuffer0(ByteBuffer bb, int offset, VectorMask<Double> m) {\n-        super.intoByteBuffer0Template(Double64Mask.class, bb, offset, (Double64Mask) m);\n+    void intoMemorySegment0(MemorySegment ms, long offset, VectorMask<Double> m) {\n+        super.intoMemorySegment0Template(Double64Mask.class, ms, offset, (Double64Mask) m);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double64Vector.java","additions":32,"deletions":35,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import java.nio.ByteBuffer;\n@@ -32,0 +31,1 @@\n+import jdk.incubator.foreign.MemorySegment;\n@@ -464,0 +464,16 @@\n+    @Override\n+    @ForceInline\n+    public DoubleMaxVector compress(VectorMask<Double> m) {\n+        return (DoubleMaxVector)\n+            super.compressTemplate(DoubleMaxMask.class,\n+                                   (DoubleMaxMask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public DoubleMaxVector expand(VectorMask<Double> m) {\n+        return (DoubleMaxVector)\n+            super.expandTemplate(DoubleMaxMask.class,\n+                                   (DoubleMaxMask) m);  \/\/ specialize\n+    }\n+\n@@ -638,0 +654,9 @@\n+        @Override\n+        @ForceInline\n+        public DoubleMaxMask compress() {\n+            return (DoubleMaxMask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n+                DoubleMaxVector.class, DoubleMaxMask.class, ETYPE, VLENGTH, null, this,\n+                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));\n+        }\n+\n+\n@@ -830,2 +855,2 @@\n-    DoubleVector fromByteArray0(byte[] a, int offset) {\n-        return super.fromByteArray0Template(a, offset);  \/\/ specialize\n+    DoubleVector fromMemorySegment0(MemorySegment ms, long offset) {\n+        return super.fromMemorySegment0Template(ms, offset);  \/\/ specialize\n@@ -837,16 +862,2 @@\n-    DoubleVector fromByteArray0(byte[] a, int offset, VectorMask<Double> m) {\n-        return super.fromByteArray0Template(DoubleMaxMask.class, a, offset, (DoubleMaxMask) m);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    DoubleVector fromByteBuffer0(ByteBuffer bb, int offset) {\n-        return super.fromByteBuffer0Template(bb, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    DoubleVector fromByteBuffer0(ByteBuffer bb, int offset, VectorMask<Double> m) {\n-        return super.fromByteBuffer0Template(DoubleMaxMask.class, bb, offset, (DoubleMaxMask) m);  \/\/ specialize\n+    DoubleVector fromMemorySegment0(MemorySegment ms, long offset, VectorMask<Double> m) {\n+        return super.fromMemorySegment0Template(DoubleMaxMask.class, ms, offset, (DoubleMaxMask) m);  \/\/ specialize\n@@ -880,16 +891,2 @@\n-    void intoByteArray0(byte[] a, int offset) {\n-        super.intoByteArray0Template(a, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoByteArray0(byte[] a, int offset, VectorMask<Double> m) {\n-        super.intoByteArray0Template(DoubleMaxMask.class, a, offset, (DoubleMaxMask) m);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoByteBuffer0(ByteBuffer bb, int offset, VectorMask<Double> m) {\n-        super.intoByteBuffer0Template(DoubleMaxMask.class, bb, offset, (DoubleMaxMask) m);\n+    void intoMemorySegment0(MemorySegment ms, long offset, VectorMask<Double> m) {\n+        super.intoMemorySegment0Template(DoubleMaxMask.class, ms, offset, (DoubleMaxMask) m);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/DoubleMaxVector.java","additions":32,"deletions":35,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import java.nio.ByteBuffer;\n@@ -29,1 +28,0 @@\n-import java.nio.ReadOnlyBufferException;\n@@ -33,1 +31,0 @@\n-import java.util.function.UnaryOperator;\n@@ -35,0 +32,3 @@\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ValueLayout;\n+import jdk.internal.access.foreign.MemorySegmentProxy;\n@@ -60,0 +60,2 @@\n+    static final ValueLayout.OfDouble ELEMENT_LAYOUT = ValueLayout.JAVA_DOUBLE.withBitAlignment(8);\n+\n@@ -354,0 +356,39 @@\n+    \/*package-private*\/\n+    interface FLdLongOp {\n+        double apply(MemorySegment memory, long offset, int i);\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    DoubleVector ldLongOp(MemorySegment memory, long offset,\n+                                  FLdLongOp f) {\n+        \/\/dummy; no vec = vec();\n+        double[] res = new double[length()];\n+        for (int i = 0; i < res.length; i++) {\n+            res[i] = f.apply(memory, offset, i);\n+        }\n+        return vectorFactory(res);\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    DoubleVector ldLongOp(MemorySegment memory, long offset,\n+                                  VectorMask<Double> m,\n+                                  FLdLongOp f) {\n+        \/\/double[] vec = vec();\n+        double[] res = new double[length()];\n+        boolean[] mbits = ((AbstractMask<Double>)m).getBits();\n+        for (int i = 0; i < res.length; i++) {\n+            if (mbits[i]) {\n+                res[i] = f.apply(memory, offset, i);\n+            }\n+        }\n+        return vectorFactory(res);\n+    }\n+\n+    static double memorySegmentGet(MemorySegment ms, long o, int i) {\n+        return ms.get(ELEMENT_LAYOUT, o + i * 8L);\n+    }\n+\n@@ -384,0 +425,34 @@\n+    interface FStLongOp {\n+        void apply(MemorySegment memory, long offset, int i, double a);\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    void stLongOp(MemorySegment memory, long offset,\n+                  FStLongOp f) {\n+        double[] vec = vec();\n+        for (int i = 0; i < vec.length; i++) {\n+            f.apply(memory, offset, i, vec[i]);\n+        }\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    void stLongOp(MemorySegment memory, long offset,\n+                  VectorMask<Double> m,\n+                  FStLongOp f) {\n+        double[] vec = vec();\n+        boolean[] mbits = ((AbstractMask<Double>)m).getBits();\n+        for (int i = 0; i < vec.length; i++) {\n+            if (mbits[i]) {\n+                f.apply(memory, offset, i, vec[i]);\n+            }\n+        }\n+    }\n+\n+    static void memorySegmentSet(MemorySegment ms, long o, int i, double e) {\n+        ms.set(ELEMENT_LAYOUT, o + i * 8L, e);\n+    }\n+\n@@ -423,0 +498,30 @@\n+    static DoubleVector expandHelper(Vector<Double> v, VectorMask<Double> m) {\n+        VectorSpecies<Double> vsp = m.vectorSpecies();\n+        DoubleVector r  = (DoubleVector) vsp.zero();\n+        DoubleVector vi = (DoubleVector) v;\n+        if (m.allTrue()) {\n+            return vi;\n+        }\n+        for (int i = 0, j = 0; i < vsp.length(); i++) {\n+            if (m.laneIsSet(i)) {\n+                r = r.withLane(i, vi.lane(j++));\n+            }\n+        }\n+        return r;\n+    }\n+\n+    static DoubleVector compressHelper(Vector<Double> v, VectorMask<Double> m) {\n+        VectorSpecies<Double> vsp = m.vectorSpecies();\n+        DoubleVector r  = (DoubleVector) vsp.zero();\n+        DoubleVector vi = (DoubleVector) v;\n+        if (m.allTrue()) {\n+            return vi;\n+        }\n+        for (int i = 0, j = 0; i < vsp.length(); i++) {\n+            if (m.laneIsSet(i)) {\n+                r = r.withLane(j++, vi.lane(i));\n+            }\n+        }\n+        return r;\n+    }\n+\n@@ -1597,0 +1702,1 @@\n+\n@@ -2244,0 +2350,39 @@\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     * @since 19\n+     *\/\n+    @Override\n+    public abstract\n+    DoubleVector compress(VectorMask<Double> m);\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M extends AbstractMask<Double>>\n+    DoubleVector compressTemplate(Class<M> masktype, M m) {\n+      m.check(masktype, this);\n+      return (DoubleVector) VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_COMPRESS, getClass(), masktype,\n+                                                        double.class, length(), this, m,\n+                                                        (v1, m1) -> compressHelper(v1, m1));\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     * @since 19\n+     *\/\n+    @Override\n+    public abstract\n+    DoubleVector expand(VectorMask<Double> m);\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M extends AbstractMask<Double>>\n+    DoubleVector expandTemplate(Class<M> masktype, M m) {\n+      m.check(masktype, this);\n+      return (DoubleVector) VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_EXPAND, getClass(), masktype,\n+                                                        double.class, length(), this, m,\n+                                                        (v1, m1) -> expandHelper(v1, m1));\n+    }\n+\n+\n@@ -2612,84 +2757,0 @@\n-    \/**\n-     * Loads a vector from a byte array starting at an offset.\n-     * Bytes are composed into primitive lane elements according\n-     * to the specified byte order.\n-     * The vector is arranged into lanes according to\n-     * <a href=\"Vector.html#lane-order\">memory ordering<\/a>.\n-     * <p>\n-     * This method behaves as if it returns the result of calling\n-     * {@link #fromByteBuffer(VectorSpecies,ByteBuffer,int,ByteOrder,VectorMask)\n-     * fromByteBuffer()} as follows:\n-     * <pre>{@code\n-     * var bb = ByteBuffer.wrap(a);\n-     * var m = species.maskAll(true);\n-     * return fromByteBuffer(species, bb, offset, bo, m);\n-     * }<\/pre>\n-     *\n-     * @param species species of desired vector\n-     * @param a the byte array\n-     * @param offset the offset into the array\n-     * @param bo the intended byte order\n-     * @return a vector loaded from a byte array\n-     * @throws IndexOutOfBoundsException\n-     *         if {@code offset+N*ESIZE < 0}\n-     *         or {@code offset+(N+1)*ESIZE > a.length}\n-     *         for any lane {@code N} in the vector\n-     *\/\n-    @ForceInline\n-    public static\n-    DoubleVector fromByteArray(VectorSpecies<Double> species,\n-                                       byte[] a, int offset,\n-                                       ByteOrder bo) {\n-        offset = checkFromIndexSize(offset, species.vectorByteSize(), a.length);\n-        DoubleSpecies vsp = (DoubleSpecies) species;\n-        return vsp.dummyVector().fromByteArray0(a, offset).maybeSwap(bo);\n-    }\n-\n-    \/**\n-     * Loads a vector from a byte array starting at an offset\n-     * and using a mask.\n-     * Lanes where the mask is unset are filled with the default\n-     * value of {@code double} (positive zero).\n-     * Bytes are composed into primitive lane elements according\n-     * to the specified byte order.\n-     * The vector is arranged into lanes according to\n-     * <a href=\"Vector.html#lane-order\">memory ordering<\/a>.\n-     * <p>\n-     * This method behaves as if it returns the result of calling\n-     * {@link #fromByteBuffer(VectorSpecies,ByteBuffer,int,ByteOrder,VectorMask)\n-     * fromByteBuffer()} as follows:\n-     * <pre>{@code\n-     * var bb = ByteBuffer.wrap(a);\n-     * return fromByteBuffer(species, bb, offset, bo, m);\n-     * }<\/pre>\n-     *\n-     * @param species species of desired vector\n-     * @param a the byte array\n-     * @param offset the offset into the array\n-     * @param bo the intended byte order\n-     * @param m the mask controlling lane selection\n-     * @return a vector loaded from a byte array\n-     * @throws IndexOutOfBoundsException\n-     *         if {@code offset+N*ESIZE < 0}\n-     *         or {@code offset+(N+1)*ESIZE > a.length}\n-     *         for any lane {@code N} in the vector\n-     *         where the mask is set\n-     *\/\n-    @ForceInline\n-    public static\n-    DoubleVector fromByteArray(VectorSpecies<Double> species,\n-                                       byte[] a, int offset,\n-                                       ByteOrder bo,\n-                                       VectorMask<Double> m) {\n-        DoubleSpecies vsp = (DoubleSpecies) species;\n-        if (offset >= 0 && offset <= (a.length - species.vectorByteSize())) {\n-            return vsp.dummyVector().fromByteArray0(a, offset, m).maybeSwap(bo);\n-        }\n-\n-        \/\/ FIXME: optimize\n-        checkMaskFromIndexSize(offset, vsp, m, 8, a.length);\n-        ByteBuffer wb = wrapper(a, bo);\n-        return vsp.ldOp(wb, offset, (AbstractMask<Double>)m,\n-                   (wb_, o, i)  -> wb_.getDouble(o + i * 8));\n-    }\n-\n@@ -2886,2 +2947,2 @@\n-     * Loads a vector from a {@linkplain ByteBuffer byte buffer}\n-     * starting at an offset into the byte buffer.\n+     * Loads a vector from a {@linkplain MemorySegment memory segment}\n+     * starting at an offset into the memory segment.\n@@ -2894,2 +2955,2 @@\n-     * {@link #fromByteBuffer(VectorSpecies,ByteBuffer,int,ByteOrder,VectorMask)\n-     * fromByteBuffer()} as follows:\n+     * {@link #fromMemorySegment(VectorSpecies,MemorySegment,long,ByteOrder,VectorMask)\n+     * fromMemorySegment()} as follows:\n@@ -2898,1 +2959,1 @@\n-     * return fromByteBuffer(species, bb, offset, bo, m);\n+     * return fromMemorySegment(species, ms, offset, bo, m);\n@@ -2902,2 +2963,2 @@\n-     * @param bb the byte buffer\n-     * @param offset the offset into the byte buffer\n+     * @param ms the memory segment\n+     * @param offset the offset into the memory segment\n@@ -2905,1 +2966,1 @@\n-     * @return a vector loaded from a byte buffer\n+     * @return a vector loaded from the memory segment\n@@ -2908,1 +2969,1 @@\n-     *         or {@code offset+N*8 >= bb.limit()}\n+     *         or {@code offset+N*8 >= ms.byteSize()}\n@@ -2910,0 +2971,5 @@\n+     * @throws IllegalArgumentException if the memory segment is a heap segment that is\n+     *         not backed by a {@code byte[]} array.\n+     * @throws IllegalStateException if the memory segment's session is not alive,\n+     *         or if access occurs from a thread other than the thread owning the session.\n+     * @since 19\n@@ -2913,4 +2979,4 @@\n-    DoubleVector fromByteBuffer(VectorSpecies<Double> species,\n-                                        ByteBuffer bb, int offset,\n-                                        ByteOrder bo) {\n-        offset = checkFromIndexSize(offset, species.vectorByteSize(), bb.limit());\n+    DoubleVector fromMemorySegment(VectorSpecies<Double> species,\n+                                           MemorySegment ms, long offset,\n+                                           ByteOrder bo) {\n+        offset = checkFromIndexSize(offset, species.vectorByteSize(), ms.byteSize());\n@@ -2918,1 +2984,1 @@\n-        return vsp.dummyVector().fromByteBuffer0(bb, offset).maybeSwap(bo);\n+        return vsp.dummyVector().fromMemorySegment0(ms, offset).maybeSwap(bo);\n@@ -2922,2 +2988,2 @@\n-     * Loads a vector from a {@linkplain ByteBuffer byte buffer}\n-     * starting at an offset into the byte buffer\n+     * Loads a vector from a {@linkplain MemorySegment memory segment}\n+     * starting at an offset into the memory segment\n@@ -2934,3 +3000,1 @@\n-     * DoubleBuffer eb = bb.duplicate()\n-     *     .position(offset)\n-     *     .order(bo).asDoubleBuffer();\n+     * var slice = ms.asSlice(offset);\n@@ -2940,1 +3004,1 @@\n-     *         ar[n] = eb.get(n);\n+     *         ar[n] = slice.getAtIndex(ValuaLayout.JAVA_DOUBLE.withBitAlignment(8), n);\n@@ -2954,2 +3018,2 @@\n-     * @param bb the byte buffer\n-     * @param offset the offset into the byte buffer\n+     * @param ms the memory segment\n+     * @param offset the offset into the memory segment\n@@ -2958,1 +3022,1 @@\n-     * @return a vector loaded from a byte buffer\n+     * @return a vector loaded from the memory segment\n@@ -2961,1 +3025,1 @@\n-     *         or {@code offset+N*8 >= bb.limit()}\n+     *         or {@code offset+N*8 >= ms.byteSize()}\n@@ -2964,0 +3028,5 @@\n+     * @throws IllegalArgumentException if the memory segment is a heap segment that is\n+     *         not backed by a {@code byte[]} array.\n+     * @throws IllegalStateException if the memory segment's session is not alive,\n+     *         or if access occurs from a thread other than the thread owning the session.\n+     * @since 19\n@@ -2967,4 +3036,4 @@\n-    DoubleVector fromByteBuffer(VectorSpecies<Double> species,\n-                                        ByteBuffer bb, int offset,\n-                                        ByteOrder bo,\n-                                        VectorMask<Double> m) {\n+    DoubleVector fromMemorySegment(VectorSpecies<Double> species,\n+                                           MemorySegment ms, long offset,\n+                                           ByteOrder bo,\n+                                           VectorMask<Double> m) {\n@@ -2972,2 +3041,2 @@\n-        if (offset >= 0 && offset <= (bb.limit() - species.vectorByteSize())) {\n-            return vsp.dummyVector().fromByteBuffer0(bb, offset, m).maybeSwap(bo);\n+        if (offset >= 0 && offset <= (ms.byteSize() - species.vectorByteSize())) {\n+            return vsp.dummyVector().fromMemorySegment0(ms, offset, m).maybeSwap(bo);\n@@ -2977,4 +3046,2 @@\n-        checkMaskFromIndexSize(offset, vsp, m, 8, bb.limit());\n-        ByteBuffer wb = wrapper(bb, bo);\n-        return vsp.ldOp(wb, offset, (AbstractMask<Double>)m,\n-                   (wb_, o, i)  -> wb_.getDouble(o + i * 8));\n+        checkMaskFromIndexSize(offset, vsp, m, 8, ms.byteSize());\n+        return vsp.ldLongOp(ms, offset, m, DoubleVector::memorySegmentGet);\n@@ -3010,1 +3077,1 @@\n-            -> v.stOp(arr, off,\n+            -> v.stOp(arr, (int) off,\n@@ -3170,0 +3237,1 @@\n+     * @since 19\n@@ -3174,21 +3242,4 @@\n-    void intoByteArray(byte[] a, int offset,\n-                       ByteOrder bo) {\n-        offset = checkFromIndexSize(offset, byteSize(), a.length);\n-        maybeSwap(bo).intoByteArray0(a, offset);\n-    }\n-\n-    \/**\n-     * {@inheritDoc} <!--workaround-->\n-     *\/\n-    @Override\n-    @ForceInline\n-    public final\n-    void intoByteArray(byte[] a, int offset,\n-                       ByteOrder bo,\n-                       VectorMask<Double> m) {\n-        if (m.allTrue()) {\n-            intoByteArray(a, offset, bo);\n-        } else {\n-            DoubleSpecies vsp = vspecies();\n-            checkMaskFromIndexSize(offset, vsp, m, 8, a.length);\n-            maybeSwap(bo).intoByteArray0(a, offset, m);\n+    void intoMemorySegment(MemorySegment ms, long offset,\n+                           ByteOrder bo) {\n+        if (ms.isReadOnly()) {\n+            throw new UnsupportedOperationException(\"Attempt to write a read-only segment\");\n@@ -3196,1 +3247,0 @@\n-    }\n@@ -3198,13 +3248,2 @@\n-    \/**\n-     * {@inheritDoc} <!--workaround-->\n-     *\/\n-    @Override\n-    @ForceInline\n-    public final\n-    void intoByteBuffer(ByteBuffer bb, int offset,\n-                        ByteOrder bo) {\n-        if (ScopedMemoryAccess.isReadOnly(bb)) {\n-            throw new ReadOnlyBufferException();\n-        }\n-        offset = checkFromIndexSize(offset, byteSize(), bb.limit());\n-        maybeSwap(bo).intoByteBuffer0(bb, offset);\n+        offset = checkFromIndexSize(offset, byteSize(), ms.byteSize());\n+        maybeSwap(bo).intoMemorySegment0(ms, offset);\n@@ -3215,0 +3254,1 @@\n+     * @since 19\n@@ -3219,3 +3259,3 @@\n-    void intoByteBuffer(ByteBuffer bb, int offset,\n-                        ByteOrder bo,\n-                        VectorMask<Double> m) {\n+    void intoMemorySegment(MemorySegment ms, long offset,\n+                           ByteOrder bo,\n+                           VectorMask<Double> m) {\n@@ -3223,1 +3263,1 @@\n-            intoByteBuffer(bb, offset, bo);\n+            intoMemorySegment(ms, offset, bo);\n@@ -3225,2 +3265,2 @@\n-            if (bb.isReadOnly()) {\n-                throw new ReadOnlyBufferException();\n+            if (ms.isReadOnly()) {\n+                throw new UnsupportedOperationException(\"Attempt to write a read-only segment\");\n@@ -3229,2 +3269,2 @@\n-            checkMaskFromIndexSize(offset, vsp, m, 8, bb.limit());\n-            maybeSwap(bo).intoByteBuffer0(bb, offset, m);\n+            checkMaskFromIndexSize(offset, vsp, m, 8, ms.byteSize());\n+            maybeSwap(bo).intoMemorySegment0(ms, offset, m);\n@@ -3264,1 +3304,1 @@\n-            (arr, off, s) -> s.ldOp(arr, off,\n+            (arr, off, s) -> s.ldOp(arr, (int) off,\n@@ -3281,1 +3321,1 @@\n-            (arr, off, s, vm) -> s.ldOp(arr, off, vm,\n+            (arr, off, s, vm) -> s.ldOp(arr, (int) off, vm,\n@@ -3339,1 +3379,0 @@\n-    @Override\n@@ -3341,1 +3380,1 @@\n-    DoubleVector fromByteArray0(byte[] a, int offset);\n+    DoubleVector fromMemorySegment0(MemorySegment bb, long offset);\n@@ -3344,1 +3383,1 @@\n-    DoubleVector fromByteArray0Template(byte[] a, int offset) {\n+    DoubleVector fromMemorySegment0Template(MemorySegment ms, long offset) {\n@@ -3346,37 +3385,1 @@\n-        return VectorSupport.load(\n-            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n-            a, byteArrayAddress(a, offset),\n-            a, offset, vsp,\n-            (arr, off, s) -> {\n-                ByteBuffer wb = wrapper(arr, NATIVE_ENDIAN);\n-                return s.ldOp(wb, off,\n-                        (wb_, o, i) -> wb_.getDouble(o + i * 8));\n-            });\n-    }\n-\n-    abstract\n-    DoubleVector fromByteArray0(byte[] a, int offset, VectorMask<Double> m);\n-    @ForceInline\n-    final\n-    <M extends VectorMask<Double>>\n-    DoubleVector fromByteArray0Template(Class<M> maskClass, byte[] a, int offset, M m) {\n-        DoubleSpecies vsp = vspecies();\n-        m.check(vsp);\n-        return VectorSupport.loadMasked(\n-            vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n-            a, byteArrayAddress(a, offset), m,\n-            a, offset, vsp,\n-            (arr, off, s, vm) -> {\n-                ByteBuffer wb = wrapper(arr, NATIVE_ENDIAN);\n-                return s.ldOp(wb, off, vm,\n-                        (wb_, o, i) -> wb_.getDouble(o + i * 8));\n-            });\n-    }\n-\n-    abstract\n-    DoubleVector fromByteBuffer0(ByteBuffer bb, int offset);\n-    @ForceInline\n-    final\n-    DoubleVector fromByteBuffer0Template(ByteBuffer bb, int offset) {\n-        DoubleSpecies vsp = vspecies();\n-        return ScopedMemoryAccess.loadFromByteBuffer(\n+        return ScopedMemoryAccess.loadFromMemorySegment(\n@@ -3384,5 +3387,3 @@\n-                bb, offset, vsp,\n-                (buf, off, s) -> {\n-                    ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n-                    return s.ldOp(wb, off,\n-                            (wb_, o, i) -> wb_.getDouble(o + i * 8));\n+                (MemorySegmentProxy) ms, offset, vsp,\n+                (msp, off, s) -> {\n+                    return s.ldLongOp((MemorySegment) msp, off, DoubleVector::memorySegmentGet);\n@@ -3393,1 +3394,1 @@\n-    DoubleVector fromByteBuffer0(ByteBuffer bb, int offset, VectorMask<Double> m);\n+    DoubleVector fromMemorySegment0(MemorySegment ms, long offset, VectorMask<Double> m);\n@@ -3397,1 +3398,1 @@\n-    DoubleVector fromByteBuffer0Template(Class<M> maskClass, ByteBuffer bb, int offset, M m) {\n+    DoubleVector fromMemorySegment0Template(Class<M> maskClass, MemorySegment ms, long offset, M m) {\n@@ -3400,1 +3401,1 @@\n-        return ScopedMemoryAccess.loadFromByteBufferMasked(\n+        return ScopedMemoryAccess.loadFromMemorySegmentMasked(\n@@ -3402,5 +3403,3 @@\n-                bb, offset, m, vsp,\n-                (buf, off, s, vm) -> {\n-                    ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n-                    return s.ldOp(wb, off, vm,\n-                            (wb_, o, i) -> wb_.getDouble(o + i * 8));\n+                (MemorySegmentProxy) ms, offset, m, vsp,\n+                (msp, off, s, vm) -> {\n+                    return s.ldLongOp((MemorySegment) msp, off, vm, DoubleVector::memorySegmentGet);\n@@ -3425,1 +3424,1 @@\n-            -> v.stOp(arr, off,\n+            -> v.stOp(arr, (int) off,\n@@ -3442,1 +3441,1 @@\n-            -> v.stOp(arr, off, vm,\n+            -> v.stOp(arr, (int) off, vm,\n@@ -3500,19 +3499,0 @@\n-    abstract\n-    void intoByteArray0(byte[] a, int offset);\n-    @ForceInline\n-    final\n-    void intoByteArray0Template(byte[] a, int offset) {\n-        DoubleSpecies vsp = vspecies();\n-        VectorSupport.store(\n-            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n-            a, byteArrayAddress(a, offset),\n-            this, a, offset,\n-            (arr, off, v) -> {\n-                ByteBuffer wb = wrapper(arr, NATIVE_ENDIAN);\n-                v.stOp(wb, off,\n-                        (tb_, o, i, e) -> tb_.putDouble(o + i * 8, e));\n-            });\n-    }\n-\n-    abstract\n-    void intoByteArray0(byte[] a, int offset, VectorMask<Double> m);\n@@ -3521,2 +3501,1 @@\n-    <M extends VectorMask<Double>>\n-    void intoByteArray0Template(Class<M> maskClass, byte[] a, int offset, M m) {\n+    void intoMemorySegment0(MemorySegment ms, long offset) {\n@@ -3524,17 +3503,1 @@\n-        m.check(vsp);\n-        VectorSupport.storeMasked(\n-            vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n-            a, byteArrayAddress(a, offset),\n-            this, m, a, offset,\n-            (arr, off, v, vm) -> {\n-                ByteBuffer wb = wrapper(arr, NATIVE_ENDIAN);\n-                v.stOp(wb, off, vm,\n-                        (tb_, o, i, e) -> tb_.putDouble(o + i * 8, e));\n-            });\n-    }\n-\n-    @ForceInline\n-    final\n-    void intoByteBuffer0(ByteBuffer bb, int offset) {\n-        DoubleSpecies vsp = vspecies();\n-        ScopedMemoryAccess.storeIntoByteBuffer(\n+        ScopedMemoryAccess.storeIntoMemorySegment(\n@@ -3542,5 +3505,4 @@\n-                this, bb, offset,\n-                (buf, off, v) -> {\n-                    ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n-                    v.stOp(wb, off,\n-                            (wb_, o, i, e) -> wb_.putDouble(o + i * 8, e));\n+                this,\n+                (MemorySegmentProxy) ms, offset,\n+                (msp, off, v) -> {\n+                    v.stLongOp((MemorySegment) msp, off, DoubleVector::memorySegmentSet);\n@@ -3551,1 +3513,1 @@\n-    void intoByteBuffer0(ByteBuffer bb, int offset, VectorMask<Double> m);\n+    void intoMemorySegment0(MemorySegment bb, long offset, VectorMask<Double> m);\n@@ -3555,1 +3517,1 @@\n-    void intoByteBuffer0Template(Class<M> maskClass, ByteBuffer bb, int offset, M m) {\n+    void intoMemorySegment0Template(Class<M> maskClass, MemorySegment ms, long offset, M m) {\n@@ -3558,1 +3520,1 @@\n-        ScopedMemoryAccess.storeIntoByteBufferMasked(\n+        ScopedMemoryAccess.storeIntoMemorySegmentMasked(\n@@ -3560,5 +3522,4 @@\n-                this, m, bb, offset,\n-                (buf, off, v, vm) -> {\n-                    ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n-                    v.stOp(wb, off, vm,\n-                            (wb_, o, i, e) -> wb_.putDouble(o + i * 8, e));\n+                this, m,\n+                (MemorySegmentProxy) ms, offset,\n+                (msp, off, v, vm) -> {\n+                    v.stLongOp((MemorySegment) msp, off, vm, DoubleVector::memorySegmentSet);\n@@ -3581,0 +3542,10 @@\n+    private static\n+    void checkMaskFromIndexSize(long offset,\n+                                DoubleSpecies vsp,\n+                                VectorMask<Double> m,\n+                                int scale,\n+                                long limit) {\n+        ((AbstractMask<Double>)m)\n+            .checkIndexByLane(offset, limit, vsp.iota(), scale);\n+    }\n+\n@@ -3891,0 +3862,15 @@\n+        \/*package-private*\/\n+        @ForceInline\n+        DoubleVector ldLongOp(MemorySegment memory, long offset,\n+                                      FLdLongOp f) {\n+            return dummyVector().ldLongOp(memory, offset, f);\n+        }\n+\n+        \/*package-private*\/\n+        @ForceInline\n+        DoubleVector ldLongOp(MemorySegment memory, long offset,\n+                                      VectorMask<Double> m,\n+                                      FLdLongOp f) {\n+            return dummyVector().ldLongOp(memory, offset, m, f);\n+        }\n+\n@@ -3905,0 +3891,14 @@\n+        \/*package-private*\/\n+        @ForceInline\n+        void stLongOp(MemorySegment memory, long offset, FStLongOp f) {\n+            dummyVector().stLongOp(memory, offset, f);\n+        }\n+\n+        \/*package-private*\/\n+        @ForceInline\n+        void stLongOp(MemorySegment memory, long offset,\n+                      AbstractMask<Double> m,\n+                      FStLongOp f) {\n+            dummyVector().stLongOp(memory, offset, m, f);\n+        }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/DoubleVector.java","additions":273,"deletions":273,"binary":false,"changes":546,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import java.nio.ByteBuffer;\n@@ -32,0 +31,1 @@\n+import jdk.incubator.foreign.MemorySegment;\n@@ -464,0 +464,16 @@\n+    @Override\n+    @ForceInline\n+    public Float128Vector compress(VectorMask<Float> m) {\n+        return (Float128Vector)\n+            super.compressTemplate(Float128Mask.class,\n+                                   (Float128Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Float128Vector expand(VectorMask<Float> m) {\n+        return (Float128Vector)\n+            super.expandTemplate(Float128Mask.class,\n+                                   (Float128Mask) m);  \/\/ specialize\n+    }\n+\n@@ -645,0 +661,9 @@\n+        @Override\n+        @ForceInline\n+        public Float128Mask compress() {\n+            return (Float128Mask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n+                Float128Vector.class, Float128Mask.class, ETYPE, VLENGTH, null, this,\n+                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));\n+        }\n+\n+\n@@ -837,2 +862,2 @@\n-    FloatVector fromByteArray0(byte[] a, int offset) {\n-        return super.fromByteArray0Template(a, offset);  \/\/ specialize\n+    FloatVector fromMemorySegment0(MemorySegment ms, long offset) {\n+        return super.fromMemorySegment0Template(ms, offset);  \/\/ specialize\n@@ -844,16 +869,2 @@\n-    FloatVector fromByteArray0(byte[] a, int offset, VectorMask<Float> m) {\n-        return super.fromByteArray0Template(Float128Mask.class, a, offset, (Float128Mask) m);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    FloatVector fromByteBuffer0(ByteBuffer bb, int offset) {\n-        return super.fromByteBuffer0Template(bb, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    FloatVector fromByteBuffer0(ByteBuffer bb, int offset, VectorMask<Float> m) {\n-        return super.fromByteBuffer0Template(Float128Mask.class, bb, offset, (Float128Mask) m);  \/\/ specialize\n+    FloatVector fromMemorySegment0(MemorySegment ms, long offset, VectorMask<Float> m) {\n+        return super.fromMemorySegment0Template(Float128Mask.class, ms, offset, (Float128Mask) m);  \/\/ specialize\n@@ -887,16 +898,2 @@\n-    void intoByteArray0(byte[] a, int offset) {\n-        super.intoByteArray0Template(a, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoByteArray0(byte[] a, int offset, VectorMask<Float> m) {\n-        super.intoByteArray0Template(Float128Mask.class, a, offset, (Float128Mask) m);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoByteBuffer0(ByteBuffer bb, int offset, VectorMask<Float> m) {\n-        super.intoByteBuffer0Template(Float128Mask.class, bb, offset, (Float128Mask) m);\n+    void intoMemorySegment0(MemorySegment ms, long offset, VectorMask<Float> m) {\n+        super.intoMemorySegment0Template(Float128Mask.class, ms, offset, (Float128Mask) m);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float128Vector.java","additions":32,"deletions":35,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import java.nio.ByteBuffer;\n@@ -32,0 +31,1 @@\n+import jdk.incubator.foreign.MemorySegment;\n@@ -464,0 +464,16 @@\n+    @Override\n+    @ForceInline\n+    public Float256Vector compress(VectorMask<Float> m) {\n+        return (Float256Vector)\n+            super.compressTemplate(Float256Mask.class,\n+                                   (Float256Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Float256Vector expand(VectorMask<Float> m) {\n+        return (Float256Vector)\n+            super.expandTemplate(Float256Mask.class,\n+                                   (Float256Mask) m);  \/\/ specialize\n+    }\n+\n@@ -653,0 +669,9 @@\n+        @Override\n+        @ForceInline\n+        public Float256Mask compress() {\n+            return (Float256Mask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n+                Float256Vector.class, Float256Mask.class, ETYPE, VLENGTH, null, this,\n+                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));\n+        }\n+\n+\n@@ -845,2 +870,2 @@\n-    FloatVector fromByteArray0(byte[] a, int offset) {\n-        return super.fromByteArray0Template(a, offset);  \/\/ specialize\n+    FloatVector fromMemorySegment0(MemorySegment ms, long offset) {\n+        return super.fromMemorySegment0Template(ms, offset);  \/\/ specialize\n@@ -852,16 +877,2 @@\n-    FloatVector fromByteArray0(byte[] a, int offset, VectorMask<Float> m) {\n-        return super.fromByteArray0Template(Float256Mask.class, a, offset, (Float256Mask) m);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    FloatVector fromByteBuffer0(ByteBuffer bb, int offset) {\n-        return super.fromByteBuffer0Template(bb, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    FloatVector fromByteBuffer0(ByteBuffer bb, int offset, VectorMask<Float> m) {\n-        return super.fromByteBuffer0Template(Float256Mask.class, bb, offset, (Float256Mask) m);  \/\/ specialize\n+    FloatVector fromMemorySegment0(MemorySegment ms, long offset, VectorMask<Float> m) {\n+        return super.fromMemorySegment0Template(Float256Mask.class, ms, offset, (Float256Mask) m);  \/\/ specialize\n@@ -895,16 +906,2 @@\n-    void intoByteArray0(byte[] a, int offset) {\n-        super.intoByteArray0Template(a, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoByteArray0(byte[] a, int offset, VectorMask<Float> m) {\n-        super.intoByteArray0Template(Float256Mask.class, a, offset, (Float256Mask) m);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoByteBuffer0(ByteBuffer bb, int offset, VectorMask<Float> m) {\n-        super.intoByteBuffer0Template(Float256Mask.class, bb, offset, (Float256Mask) m);\n+    void intoMemorySegment0(MemorySegment ms, long offset, VectorMask<Float> m) {\n+        super.intoMemorySegment0Template(Float256Mask.class, ms, offset, (Float256Mask) m);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float256Vector.java","additions":32,"deletions":35,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import java.nio.ByteBuffer;\n@@ -32,0 +31,1 @@\n+import jdk.incubator.foreign.MemorySegment;\n@@ -464,0 +464,16 @@\n+    @Override\n+    @ForceInline\n+    public Float512Vector compress(VectorMask<Float> m) {\n+        return (Float512Vector)\n+            super.compressTemplate(Float512Mask.class,\n+                                   (Float512Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Float512Vector expand(VectorMask<Float> m) {\n+        return (Float512Vector)\n+            super.expandTemplate(Float512Mask.class,\n+                                   (Float512Mask) m);  \/\/ specialize\n+    }\n+\n@@ -669,0 +685,9 @@\n+        @Override\n+        @ForceInline\n+        public Float512Mask compress() {\n+            return (Float512Mask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n+                Float512Vector.class, Float512Mask.class, ETYPE, VLENGTH, null, this,\n+                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));\n+        }\n+\n+\n@@ -861,2 +886,2 @@\n-    FloatVector fromByteArray0(byte[] a, int offset) {\n-        return super.fromByteArray0Template(a, offset);  \/\/ specialize\n+    FloatVector fromMemorySegment0(MemorySegment ms, long offset) {\n+        return super.fromMemorySegment0Template(ms, offset);  \/\/ specialize\n@@ -868,16 +893,2 @@\n-    FloatVector fromByteArray0(byte[] a, int offset, VectorMask<Float> m) {\n-        return super.fromByteArray0Template(Float512Mask.class, a, offset, (Float512Mask) m);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    FloatVector fromByteBuffer0(ByteBuffer bb, int offset) {\n-        return super.fromByteBuffer0Template(bb, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    FloatVector fromByteBuffer0(ByteBuffer bb, int offset, VectorMask<Float> m) {\n-        return super.fromByteBuffer0Template(Float512Mask.class, bb, offset, (Float512Mask) m);  \/\/ specialize\n+    FloatVector fromMemorySegment0(MemorySegment ms, long offset, VectorMask<Float> m) {\n+        return super.fromMemorySegment0Template(Float512Mask.class, ms, offset, (Float512Mask) m);  \/\/ specialize\n@@ -911,16 +922,2 @@\n-    void intoByteArray0(byte[] a, int offset) {\n-        super.intoByteArray0Template(a, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoByteArray0(byte[] a, int offset, VectorMask<Float> m) {\n-        super.intoByteArray0Template(Float512Mask.class, a, offset, (Float512Mask) m);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoByteBuffer0(ByteBuffer bb, int offset, VectorMask<Float> m) {\n-        super.intoByteBuffer0Template(Float512Mask.class, bb, offset, (Float512Mask) m);\n+    void intoMemorySegment0(MemorySegment ms, long offset, VectorMask<Float> m) {\n+        super.intoMemorySegment0Template(Float512Mask.class, ms, offset, (Float512Mask) m);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float512Vector.java","additions":32,"deletions":35,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import java.nio.ByteBuffer;\n@@ -32,0 +31,1 @@\n+import jdk.incubator.foreign.MemorySegment;\n@@ -464,0 +464,16 @@\n+    @Override\n+    @ForceInline\n+    public Float64Vector compress(VectorMask<Float> m) {\n+        return (Float64Vector)\n+            super.compressTemplate(Float64Mask.class,\n+                                   (Float64Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Float64Vector expand(VectorMask<Float> m) {\n+        return (Float64Vector)\n+            super.expandTemplate(Float64Mask.class,\n+                                   (Float64Mask) m);  \/\/ specialize\n+    }\n+\n@@ -641,0 +657,9 @@\n+        @Override\n+        @ForceInline\n+        public Float64Mask compress() {\n+            return (Float64Mask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n+                Float64Vector.class, Float64Mask.class, ETYPE, VLENGTH, null, this,\n+                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));\n+        }\n+\n+\n@@ -833,2 +858,2 @@\n-    FloatVector fromByteArray0(byte[] a, int offset) {\n-        return super.fromByteArray0Template(a, offset);  \/\/ specialize\n+    FloatVector fromMemorySegment0(MemorySegment ms, long offset) {\n+        return super.fromMemorySegment0Template(ms, offset);  \/\/ specialize\n@@ -840,16 +865,2 @@\n-    FloatVector fromByteArray0(byte[] a, int offset, VectorMask<Float> m) {\n-        return super.fromByteArray0Template(Float64Mask.class, a, offset, (Float64Mask) m);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    FloatVector fromByteBuffer0(ByteBuffer bb, int offset) {\n-        return super.fromByteBuffer0Template(bb, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    FloatVector fromByteBuffer0(ByteBuffer bb, int offset, VectorMask<Float> m) {\n-        return super.fromByteBuffer0Template(Float64Mask.class, bb, offset, (Float64Mask) m);  \/\/ specialize\n+    FloatVector fromMemorySegment0(MemorySegment ms, long offset, VectorMask<Float> m) {\n+        return super.fromMemorySegment0Template(Float64Mask.class, ms, offset, (Float64Mask) m);  \/\/ specialize\n@@ -883,16 +894,2 @@\n-    void intoByteArray0(byte[] a, int offset) {\n-        super.intoByteArray0Template(a, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoByteArray0(byte[] a, int offset, VectorMask<Float> m) {\n-        super.intoByteArray0Template(Float64Mask.class, a, offset, (Float64Mask) m);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoByteBuffer0(ByteBuffer bb, int offset, VectorMask<Float> m) {\n-        super.intoByteBuffer0Template(Float64Mask.class, bb, offset, (Float64Mask) m);\n+    void intoMemorySegment0(MemorySegment ms, long offset, VectorMask<Float> m) {\n+        super.intoMemorySegment0Template(Float64Mask.class, ms, offset, (Float64Mask) m);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float64Vector.java","additions":32,"deletions":35,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import java.nio.ByteBuffer;\n@@ -32,0 +31,1 @@\n+import jdk.incubator.foreign.MemorySegment;\n@@ -464,0 +464,16 @@\n+    @Override\n+    @ForceInline\n+    public FloatMaxVector compress(VectorMask<Float> m) {\n+        return (FloatMaxVector)\n+            super.compressTemplate(FloatMaxMask.class,\n+                                   (FloatMaxMask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public FloatMaxVector expand(VectorMask<Float> m) {\n+        return (FloatMaxVector)\n+            super.expandTemplate(FloatMaxMask.class,\n+                                   (FloatMaxMask) m);  \/\/ specialize\n+    }\n+\n@@ -638,0 +654,9 @@\n+        @Override\n+        @ForceInline\n+        public FloatMaxMask compress() {\n+            return (FloatMaxMask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n+                FloatMaxVector.class, FloatMaxMask.class, ETYPE, VLENGTH, null, this,\n+                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));\n+        }\n+\n+\n@@ -830,2 +855,2 @@\n-    FloatVector fromByteArray0(byte[] a, int offset) {\n-        return super.fromByteArray0Template(a, offset);  \/\/ specialize\n+    FloatVector fromMemorySegment0(MemorySegment ms, long offset) {\n+        return super.fromMemorySegment0Template(ms, offset);  \/\/ specialize\n@@ -837,16 +862,2 @@\n-    FloatVector fromByteArray0(byte[] a, int offset, VectorMask<Float> m) {\n-        return super.fromByteArray0Template(FloatMaxMask.class, a, offset, (FloatMaxMask) m);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    FloatVector fromByteBuffer0(ByteBuffer bb, int offset) {\n-        return super.fromByteBuffer0Template(bb, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    FloatVector fromByteBuffer0(ByteBuffer bb, int offset, VectorMask<Float> m) {\n-        return super.fromByteBuffer0Template(FloatMaxMask.class, bb, offset, (FloatMaxMask) m);  \/\/ specialize\n+    FloatVector fromMemorySegment0(MemorySegment ms, long offset, VectorMask<Float> m) {\n+        return super.fromMemorySegment0Template(FloatMaxMask.class, ms, offset, (FloatMaxMask) m);  \/\/ specialize\n@@ -880,16 +891,2 @@\n-    void intoByteArray0(byte[] a, int offset) {\n-        super.intoByteArray0Template(a, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoByteArray0(byte[] a, int offset, VectorMask<Float> m) {\n-        super.intoByteArray0Template(FloatMaxMask.class, a, offset, (FloatMaxMask) m);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoByteBuffer0(ByteBuffer bb, int offset, VectorMask<Float> m) {\n-        super.intoByteBuffer0Template(FloatMaxMask.class, bb, offset, (FloatMaxMask) m);\n+    void intoMemorySegment0(MemorySegment ms, long offset, VectorMask<Float> m) {\n+        super.intoMemorySegment0Template(FloatMaxMask.class, ms, offset, (FloatMaxMask) m);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/FloatMaxVector.java","additions":32,"deletions":35,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import java.nio.ByteBuffer;\n@@ -29,1 +28,0 @@\n-import java.nio.ReadOnlyBufferException;\n@@ -33,1 +31,0 @@\n-import java.util.function.UnaryOperator;\n@@ -35,0 +32,3 @@\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ValueLayout;\n+import jdk.internal.access.foreign.MemorySegmentProxy;\n@@ -60,0 +60,2 @@\n+    static final ValueLayout.OfFloat ELEMENT_LAYOUT = ValueLayout.JAVA_FLOAT.withBitAlignment(8);\n+\n@@ -354,0 +356,39 @@\n+    \/*package-private*\/\n+    interface FLdLongOp {\n+        float apply(MemorySegment memory, long offset, int i);\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    FloatVector ldLongOp(MemorySegment memory, long offset,\n+                                  FLdLongOp f) {\n+        \/\/dummy; no vec = vec();\n+        float[] res = new float[length()];\n+        for (int i = 0; i < res.length; i++) {\n+            res[i] = f.apply(memory, offset, i);\n+        }\n+        return vectorFactory(res);\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    FloatVector ldLongOp(MemorySegment memory, long offset,\n+                                  VectorMask<Float> m,\n+                                  FLdLongOp f) {\n+        \/\/float[] vec = vec();\n+        float[] res = new float[length()];\n+        boolean[] mbits = ((AbstractMask<Float>)m).getBits();\n+        for (int i = 0; i < res.length; i++) {\n+            if (mbits[i]) {\n+                res[i] = f.apply(memory, offset, i);\n+            }\n+        }\n+        return vectorFactory(res);\n+    }\n+\n+    static float memorySegmentGet(MemorySegment ms, long o, int i) {\n+        return ms.get(ELEMENT_LAYOUT, o + i * 4L);\n+    }\n+\n@@ -384,0 +425,34 @@\n+    interface FStLongOp {\n+        void apply(MemorySegment memory, long offset, int i, float a);\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    void stLongOp(MemorySegment memory, long offset,\n+                  FStLongOp f) {\n+        float[] vec = vec();\n+        for (int i = 0; i < vec.length; i++) {\n+            f.apply(memory, offset, i, vec[i]);\n+        }\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    void stLongOp(MemorySegment memory, long offset,\n+                  VectorMask<Float> m,\n+                  FStLongOp f) {\n+        float[] vec = vec();\n+        boolean[] mbits = ((AbstractMask<Float>)m).getBits();\n+        for (int i = 0; i < vec.length; i++) {\n+            if (mbits[i]) {\n+                f.apply(memory, offset, i, vec[i]);\n+            }\n+        }\n+    }\n+\n+    static void memorySegmentSet(MemorySegment ms, long o, int i, float e) {\n+        ms.set(ELEMENT_LAYOUT, o + i * 4L, e);\n+    }\n+\n@@ -423,0 +498,30 @@\n+    static FloatVector expandHelper(Vector<Float> v, VectorMask<Float> m) {\n+        VectorSpecies<Float> vsp = m.vectorSpecies();\n+        FloatVector r  = (FloatVector) vsp.zero();\n+        FloatVector vi = (FloatVector) v;\n+        if (m.allTrue()) {\n+            return vi;\n+        }\n+        for (int i = 0, j = 0; i < vsp.length(); i++) {\n+            if (m.laneIsSet(i)) {\n+                r = r.withLane(i, vi.lane(j++));\n+            }\n+        }\n+        return r;\n+    }\n+\n+    static FloatVector compressHelper(Vector<Float> v, VectorMask<Float> m) {\n+        VectorSpecies<Float> vsp = m.vectorSpecies();\n+        FloatVector r  = (FloatVector) vsp.zero();\n+        FloatVector vi = (FloatVector) v;\n+        if (m.allTrue()) {\n+            return vi;\n+        }\n+        for (int i = 0, j = 0; i < vsp.length(); i++) {\n+            if (m.laneIsSet(i)) {\n+                r = r.withLane(j++, vi.lane(i));\n+            }\n+        }\n+        return r;\n+    }\n+\n@@ -1605,0 +1710,1 @@\n+\n@@ -2256,0 +2362,39 @@\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     * @since 19\n+     *\/\n+    @Override\n+    public abstract\n+    FloatVector compress(VectorMask<Float> m);\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M extends AbstractMask<Float>>\n+    FloatVector compressTemplate(Class<M> masktype, M m) {\n+      m.check(masktype, this);\n+      return (FloatVector) VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_COMPRESS, getClass(), masktype,\n+                                                        float.class, length(), this, m,\n+                                                        (v1, m1) -> compressHelper(v1, m1));\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     * @since 19\n+     *\/\n+    @Override\n+    public abstract\n+    FloatVector expand(VectorMask<Float> m);\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M extends AbstractMask<Float>>\n+    FloatVector expandTemplate(Class<M> masktype, M m) {\n+      m.check(masktype, this);\n+      return (FloatVector) VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_EXPAND, getClass(), masktype,\n+                                                        float.class, length(), this, m,\n+                                                        (v1, m1) -> expandHelper(v1, m1));\n+    }\n+\n+\n@@ -2636,84 +2781,0 @@\n-    \/**\n-     * Loads a vector from a byte array starting at an offset.\n-     * Bytes are composed into primitive lane elements according\n-     * to the specified byte order.\n-     * The vector is arranged into lanes according to\n-     * <a href=\"Vector.html#lane-order\">memory ordering<\/a>.\n-     * <p>\n-     * This method behaves as if it returns the result of calling\n-     * {@link #fromByteBuffer(VectorSpecies,ByteBuffer,int,ByteOrder,VectorMask)\n-     * fromByteBuffer()} as follows:\n-     * <pre>{@code\n-     * var bb = ByteBuffer.wrap(a);\n-     * var m = species.maskAll(true);\n-     * return fromByteBuffer(species, bb, offset, bo, m);\n-     * }<\/pre>\n-     *\n-     * @param species species of desired vector\n-     * @param a the byte array\n-     * @param offset the offset into the array\n-     * @param bo the intended byte order\n-     * @return a vector loaded from a byte array\n-     * @throws IndexOutOfBoundsException\n-     *         if {@code offset+N*ESIZE < 0}\n-     *         or {@code offset+(N+1)*ESIZE > a.length}\n-     *         for any lane {@code N} in the vector\n-     *\/\n-    @ForceInline\n-    public static\n-    FloatVector fromByteArray(VectorSpecies<Float> species,\n-                                       byte[] a, int offset,\n-                                       ByteOrder bo) {\n-        offset = checkFromIndexSize(offset, species.vectorByteSize(), a.length);\n-        FloatSpecies vsp = (FloatSpecies) species;\n-        return vsp.dummyVector().fromByteArray0(a, offset).maybeSwap(bo);\n-    }\n-\n-    \/**\n-     * Loads a vector from a byte array starting at an offset\n-     * and using a mask.\n-     * Lanes where the mask is unset are filled with the default\n-     * value of {@code float} (positive zero).\n-     * Bytes are composed into primitive lane elements according\n-     * to the specified byte order.\n-     * The vector is arranged into lanes according to\n-     * <a href=\"Vector.html#lane-order\">memory ordering<\/a>.\n-     * <p>\n-     * This method behaves as if it returns the result of calling\n-     * {@link #fromByteBuffer(VectorSpecies,ByteBuffer,int,ByteOrder,VectorMask)\n-     * fromByteBuffer()} as follows:\n-     * <pre>{@code\n-     * var bb = ByteBuffer.wrap(a);\n-     * return fromByteBuffer(species, bb, offset, bo, m);\n-     * }<\/pre>\n-     *\n-     * @param species species of desired vector\n-     * @param a the byte array\n-     * @param offset the offset into the array\n-     * @param bo the intended byte order\n-     * @param m the mask controlling lane selection\n-     * @return a vector loaded from a byte array\n-     * @throws IndexOutOfBoundsException\n-     *         if {@code offset+N*ESIZE < 0}\n-     *         or {@code offset+(N+1)*ESIZE > a.length}\n-     *         for any lane {@code N} in the vector\n-     *         where the mask is set\n-     *\/\n-    @ForceInline\n-    public static\n-    FloatVector fromByteArray(VectorSpecies<Float> species,\n-                                       byte[] a, int offset,\n-                                       ByteOrder bo,\n-                                       VectorMask<Float> m) {\n-        FloatSpecies vsp = (FloatSpecies) species;\n-        if (offset >= 0 && offset <= (a.length - species.vectorByteSize())) {\n-            return vsp.dummyVector().fromByteArray0(a, offset, m).maybeSwap(bo);\n-        }\n-\n-        \/\/ FIXME: optimize\n-        checkMaskFromIndexSize(offset, vsp, m, 4, a.length);\n-        ByteBuffer wb = wrapper(a, bo);\n-        return vsp.ldOp(wb, offset, (AbstractMask<Float>)m,\n-                   (wb_, o, i)  -> wb_.getFloat(o + i * 4));\n-    }\n-\n@@ -2892,2 +2953,2 @@\n-     * Loads a vector from a {@linkplain ByteBuffer byte buffer}\n-     * starting at an offset into the byte buffer.\n+     * Loads a vector from a {@linkplain MemorySegment memory segment}\n+     * starting at an offset into the memory segment.\n@@ -2900,2 +2961,2 @@\n-     * {@link #fromByteBuffer(VectorSpecies,ByteBuffer,int,ByteOrder,VectorMask)\n-     * fromByteBuffer()} as follows:\n+     * {@link #fromMemorySegment(VectorSpecies,MemorySegment,long,ByteOrder,VectorMask)\n+     * fromMemorySegment()} as follows:\n@@ -2904,1 +2965,1 @@\n-     * return fromByteBuffer(species, bb, offset, bo, m);\n+     * return fromMemorySegment(species, ms, offset, bo, m);\n@@ -2908,2 +2969,2 @@\n-     * @param bb the byte buffer\n-     * @param offset the offset into the byte buffer\n+     * @param ms the memory segment\n+     * @param offset the offset into the memory segment\n@@ -2911,1 +2972,1 @@\n-     * @return a vector loaded from a byte buffer\n+     * @return a vector loaded from the memory segment\n@@ -2914,1 +2975,1 @@\n-     *         or {@code offset+N*4 >= bb.limit()}\n+     *         or {@code offset+N*4 >= ms.byteSize()}\n@@ -2916,0 +2977,5 @@\n+     * @throws IllegalArgumentException if the memory segment is a heap segment that is\n+     *         not backed by a {@code byte[]} array.\n+     * @throws IllegalStateException if the memory segment's session is not alive,\n+     *         or if access occurs from a thread other than the thread owning the session.\n+     * @since 19\n@@ -2919,4 +2985,4 @@\n-    FloatVector fromByteBuffer(VectorSpecies<Float> species,\n-                                        ByteBuffer bb, int offset,\n-                                        ByteOrder bo) {\n-        offset = checkFromIndexSize(offset, species.vectorByteSize(), bb.limit());\n+    FloatVector fromMemorySegment(VectorSpecies<Float> species,\n+                                           MemorySegment ms, long offset,\n+                                           ByteOrder bo) {\n+        offset = checkFromIndexSize(offset, species.vectorByteSize(), ms.byteSize());\n@@ -2924,1 +2990,1 @@\n-        return vsp.dummyVector().fromByteBuffer0(bb, offset).maybeSwap(bo);\n+        return vsp.dummyVector().fromMemorySegment0(ms, offset).maybeSwap(bo);\n@@ -2928,2 +2994,2 @@\n-     * Loads a vector from a {@linkplain ByteBuffer byte buffer}\n-     * starting at an offset into the byte buffer\n+     * Loads a vector from a {@linkplain MemorySegment memory segment}\n+     * starting at an offset into the memory segment\n@@ -2940,3 +3006,1 @@\n-     * FloatBuffer eb = bb.duplicate()\n-     *     .position(offset)\n-     *     .order(bo).asFloatBuffer();\n+     * var slice = ms.asSlice(offset);\n@@ -2946,1 +3010,1 @@\n-     *         ar[n] = eb.get(n);\n+     *         ar[n] = slice.getAtIndex(ValuaLayout.JAVA_FLOAT.withBitAlignment(8), n);\n@@ -2960,2 +3024,2 @@\n-     * @param bb the byte buffer\n-     * @param offset the offset into the byte buffer\n+     * @param ms the memory segment\n+     * @param offset the offset into the memory segment\n@@ -2964,1 +3028,1 @@\n-     * @return a vector loaded from a byte buffer\n+     * @return a vector loaded from the memory segment\n@@ -2967,1 +3031,1 @@\n-     *         or {@code offset+N*4 >= bb.limit()}\n+     *         or {@code offset+N*4 >= ms.byteSize()}\n@@ -2970,0 +3034,5 @@\n+     * @throws IllegalArgumentException if the memory segment is a heap segment that is\n+     *         not backed by a {@code byte[]} array.\n+     * @throws IllegalStateException if the memory segment's session is not alive,\n+     *         or if access occurs from a thread other than the thread owning the session.\n+     * @since 19\n@@ -2973,4 +3042,4 @@\n-    FloatVector fromByteBuffer(VectorSpecies<Float> species,\n-                                        ByteBuffer bb, int offset,\n-                                        ByteOrder bo,\n-                                        VectorMask<Float> m) {\n+    FloatVector fromMemorySegment(VectorSpecies<Float> species,\n+                                           MemorySegment ms, long offset,\n+                                           ByteOrder bo,\n+                                           VectorMask<Float> m) {\n@@ -2978,2 +3047,2 @@\n-        if (offset >= 0 && offset <= (bb.limit() - species.vectorByteSize())) {\n-            return vsp.dummyVector().fromByteBuffer0(bb, offset, m).maybeSwap(bo);\n+        if (offset >= 0 && offset <= (ms.byteSize() - species.vectorByteSize())) {\n+            return vsp.dummyVector().fromMemorySegment0(ms, offset, m).maybeSwap(bo);\n@@ -2983,4 +3052,2 @@\n-        checkMaskFromIndexSize(offset, vsp, m, 4, bb.limit());\n-        ByteBuffer wb = wrapper(bb, bo);\n-        return vsp.ldOp(wb, offset, (AbstractMask<Float>)m,\n-                   (wb_, o, i)  -> wb_.getFloat(o + i * 4));\n+        checkMaskFromIndexSize(offset, vsp, m, 4, ms.byteSize());\n+        return vsp.ldLongOp(ms, offset, m, FloatVector::memorySegmentGet);\n@@ -3016,1 +3083,1 @@\n-            -> v.stOp(arr, off,\n+            -> v.stOp(arr, (int) off,\n@@ -3157,0 +3224,1 @@\n+     * @since 19\n@@ -3161,21 +3229,4 @@\n-    void intoByteArray(byte[] a, int offset,\n-                       ByteOrder bo) {\n-        offset = checkFromIndexSize(offset, byteSize(), a.length);\n-        maybeSwap(bo).intoByteArray0(a, offset);\n-    }\n-\n-    \/**\n-     * {@inheritDoc} <!--workaround-->\n-     *\/\n-    @Override\n-    @ForceInline\n-    public final\n-    void intoByteArray(byte[] a, int offset,\n-                       ByteOrder bo,\n-                       VectorMask<Float> m) {\n-        if (m.allTrue()) {\n-            intoByteArray(a, offset, bo);\n-        } else {\n-            FloatSpecies vsp = vspecies();\n-            checkMaskFromIndexSize(offset, vsp, m, 4, a.length);\n-            maybeSwap(bo).intoByteArray0(a, offset, m);\n+    void intoMemorySegment(MemorySegment ms, long offset,\n+                           ByteOrder bo) {\n+        if (ms.isReadOnly()) {\n+            throw new UnsupportedOperationException(\"Attempt to write a read-only segment\");\n@@ -3183,1 +3234,0 @@\n-    }\n@@ -3185,13 +3235,2 @@\n-    \/**\n-     * {@inheritDoc} <!--workaround-->\n-     *\/\n-    @Override\n-    @ForceInline\n-    public final\n-    void intoByteBuffer(ByteBuffer bb, int offset,\n-                        ByteOrder bo) {\n-        if (ScopedMemoryAccess.isReadOnly(bb)) {\n-            throw new ReadOnlyBufferException();\n-        }\n-        offset = checkFromIndexSize(offset, byteSize(), bb.limit());\n-        maybeSwap(bo).intoByteBuffer0(bb, offset);\n+        offset = checkFromIndexSize(offset, byteSize(), ms.byteSize());\n+        maybeSwap(bo).intoMemorySegment0(ms, offset);\n@@ -3202,0 +3241,1 @@\n+     * @since 19\n@@ -3206,3 +3246,3 @@\n-    void intoByteBuffer(ByteBuffer bb, int offset,\n-                        ByteOrder bo,\n-                        VectorMask<Float> m) {\n+    void intoMemorySegment(MemorySegment ms, long offset,\n+                           ByteOrder bo,\n+                           VectorMask<Float> m) {\n@@ -3210,1 +3250,1 @@\n-            intoByteBuffer(bb, offset, bo);\n+            intoMemorySegment(ms, offset, bo);\n@@ -3212,2 +3252,2 @@\n-            if (bb.isReadOnly()) {\n-                throw new ReadOnlyBufferException();\n+            if (ms.isReadOnly()) {\n+                throw new UnsupportedOperationException(\"Attempt to write a read-only segment\");\n@@ -3216,2 +3256,2 @@\n-            checkMaskFromIndexSize(offset, vsp, m, 4, bb.limit());\n-            maybeSwap(bo).intoByteBuffer0(bb, offset, m);\n+            checkMaskFromIndexSize(offset, vsp, m, 4, ms.byteSize());\n+            maybeSwap(bo).intoMemorySegment0(ms, offset, m);\n@@ -3251,1 +3291,1 @@\n-            (arr, off, s) -> s.ldOp(arr, off,\n+            (arr, off, s) -> s.ldOp(arr, (int) off,\n@@ -3268,1 +3308,1 @@\n-            (arr, off, s, vm) -> s.ldOp(arr, off, vm,\n+            (arr, off, s, vm) -> s.ldOp(arr, (int) off, vm,\n@@ -3308,1 +3348,0 @@\n-    @Override\n@@ -3310,1 +3349,1 @@\n-    FloatVector fromByteArray0(byte[] a, int offset);\n+    FloatVector fromMemorySegment0(MemorySegment bb, long offset);\n@@ -3313,1 +3352,1 @@\n-    FloatVector fromByteArray0Template(byte[] a, int offset) {\n+    FloatVector fromMemorySegment0Template(MemorySegment ms, long offset) {\n@@ -3315,37 +3354,1 @@\n-        return VectorSupport.load(\n-            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n-            a, byteArrayAddress(a, offset),\n-            a, offset, vsp,\n-            (arr, off, s) -> {\n-                ByteBuffer wb = wrapper(arr, NATIVE_ENDIAN);\n-                return s.ldOp(wb, off,\n-                        (wb_, o, i) -> wb_.getFloat(o + i * 4));\n-            });\n-    }\n-\n-    abstract\n-    FloatVector fromByteArray0(byte[] a, int offset, VectorMask<Float> m);\n-    @ForceInline\n-    final\n-    <M extends VectorMask<Float>>\n-    FloatVector fromByteArray0Template(Class<M> maskClass, byte[] a, int offset, M m) {\n-        FloatSpecies vsp = vspecies();\n-        m.check(vsp);\n-        return VectorSupport.loadMasked(\n-            vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n-            a, byteArrayAddress(a, offset), m,\n-            a, offset, vsp,\n-            (arr, off, s, vm) -> {\n-                ByteBuffer wb = wrapper(arr, NATIVE_ENDIAN);\n-                return s.ldOp(wb, off, vm,\n-                        (wb_, o, i) -> wb_.getFloat(o + i * 4));\n-            });\n-    }\n-\n-    abstract\n-    FloatVector fromByteBuffer0(ByteBuffer bb, int offset);\n-    @ForceInline\n-    final\n-    FloatVector fromByteBuffer0Template(ByteBuffer bb, int offset) {\n-        FloatSpecies vsp = vspecies();\n-        return ScopedMemoryAccess.loadFromByteBuffer(\n+        return ScopedMemoryAccess.loadFromMemorySegment(\n@@ -3353,5 +3356,3 @@\n-                bb, offset, vsp,\n-                (buf, off, s) -> {\n-                    ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n-                    return s.ldOp(wb, off,\n-                            (wb_, o, i) -> wb_.getFloat(o + i * 4));\n+                (MemorySegmentProxy) ms, offset, vsp,\n+                (msp, off, s) -> {\n+                    return s.ldLongOp((MemorySegment) msp, off, FloatVector::memorySegmentGet);\n@@ -3362,1 +3363,1 @@\n-    FloatVector fromByteBuffer0(ByteBuffer bb, int offset, VectorMask<Float> m);\n+    FloatVector fromMemorySegment0(MemorySegment ms, long offset, VectorMask<Float> m);\n@@ -3366,1 +3367,1 @@\n-    FloatVector fromByteBuffer0Template(Class<M> maskClass, ByteBuffer bb, int offset, M m) {\n+    FloatVector fromMemorySegment0Template(Class<M> maskClass, MemorySegment ms, long offset, M m) {\n@@ -3369,1 +3370,1 @@\n-        return ScopedMemoryAccess.loadFromByteBufferMasked(\n+        return ScopedMemoryAccess.loadFromMemorySegmentMasked(\n@@ -3371,5 +3372,3 @@\n-                bb, offset, m, vsp,\n-                (buf, off, s, vm) -> {\n-                    ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n-                    return s.ldOp(wb, off, vm,\n-                            (wb_, o, i) -> wb_.getFloat(o + i * 4));\n+                (MemorySegmentProxy) ms, offset, m, vsp,\n+                (msp, off, s, vm) -> {\n+                    return s.ldLongOp((MemorySegment) msp, off, vm, FloatVector::memorySegmentGet);\n@@ -3394,1 +3393,1 @@\n-            -> v.stOp(arr, off,\n+            -> v.stOp(arr, (int) off,\n@@ -3411,1 +3410,1 @@\n-            -> v.stOp(arr, off, vm,\n+            -> v.stOp(arr, (int) off, vm,\n@@ -3450,19 +3449,0 @@\n-    abstract\n-    void intoByteArray0(byte[] a, int offset);\n-    @ForceInline\n-    final\n-    void intoByteArray0Template(byte[] a, int offset) {\n-        FloatSpecies vsp = vspecies();\n-        VectorSupport.store(\n-            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n-            a, byteArrayAddress(a, offset),\n-            this, a, offset,\n-            (arr, off, v) -> {\n-                ByteBuffer wb = wrapper(arr, NATIVE_ENDIAN);\n-                v.stOp(wb, off,\n-                        (tb_, o, i, e) -> tb_.putFloat(o + i * 4, e));\n-            });\n-    }\n-\n-    abstract\n-    void intoByteArray0(byte[] a, int offset, VectorMask<Float> m);\n@@ -3471,2 +3451,1 @@\n-    <M extends VectorMask<Float>>\n-    void intoByteArray0Template(Class<M> maskClass, byte[] a, int offset, M m) {\n+    void intoMemorySegment0(MemorySegment ms, long offset) {\n@@ -3474,17 +3453,1 @@\n-        m.check(vsp);\n-        VectorSupport.storeMasked(\n-            vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n-            a, byteArrayAddress(a, offset),\n-            this, m, a, offset,\n-            (arr, off, v, vm) -> {\n-                ByteBuffer wb = wrapper(arr, NATIVE_ENDIAN);\n-                v.stOp(wb, off, vm,\n-                        (tb_, o, i, e) -> tb_.putFloat(o + i * 4, e));\n-            });\n-    }\n-\n-    @ForceInline\n-    final\n-    void intoByteBuffer0(ByteBuffer bb, int offset) {\n-        FloatSpecies vsp = vspecies();\n-        ScopedMemoryAccess.storeIntoByteBuffer(\n+        ScopedMemoryAccess.storeIntoMemorySegment(\n@@ -3492,5 +3455,4 @@\n-                this, bb, offset,\n-                (buf, off, v) -> {\n-                    ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n-                    v.stOp(wb, off,\n-                            (wb_, o, i, e) -> wb_.putFloat(o + i * 4, e));\n+                this,\n+                (MemorySegmentProxy) ms, offset,\n+                (msp, off, v) -> {\n+                    v.stLongOp((MemorySegment) msp, off, FloatVector::memorySegmentSet);\n@@ -3501,1 +3463,1 @@\n-    void intoByteBuffer0(ByteBuffer bb, int offset, VectorMask<Float> m);\n+    void intoMemorySegment0(MemorySegment bb, long offset, VectorMask<Float> m);\n@@ -3505,1 +3467,1 @@\n-    void intoByteBuffer0Template(Class<M> maskClass, ByteBuffer bb, int offset, M m) {\n+    void intoMemorySegment0Template(Class<M> maskClass, MemorySegment ms, long offset, M m) {\n@@ -3508,1 +3470,1 @@\n-        ScopedMemoryAccess.storeIntoByteBufferMasked(\n+        ScopedMemoryAccess.storeIntoMemorySegmentMasked(\n@@ -3510,5 +3472,4 @@\n-                this, m, bb, offset,\n-                (buf, off, v, vm) -> {\n-                    ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n-                    v.stOp(wb, off, vm,\n-                            (wb_, o, i, e) -> wb_.putFloat(o + i * 4, e));\n+                this, m,\n+                (MemorySegmentProxy) ms, offset,\n+                (msp, off, v, vm) -> {\n+                    v.stLongOp((MemorySegment) msp, off, vm, FloatVector::memorySegmentSet);\n@@ -3531,0 +3492,10 @@\n+    private static\n+    void checkMaskFromIndexSize(long offset,\n+                                FloatSpecies vsp,\n+                                VectorMask<Float> m,\n+                                int scale,\n+                                long limit) {\n+        ((AbstractMask<Float>)m)\n+            .checkIndexByLane(offset, limit, vsp.iota(), scale);\n+    }\n+\n@@ -3841,0 +3812,15 @@\n+        \/*package-private*\/\n+        @ForceInline\n+        FloatVector ldLongOp(MemorySegment memory, long offset,\n+                                      FLdLongOp f) {\n+            return dummyVector().ldLongOp(memory, offset, f);\n+        }\n+\n+        \/*package-private*\/\n+        @ForceInline\n+        FloatVector ldLongOp(MemorySegment memory, long offset,\n+                                      VectorMask<Float> m,\n+                                      FLdLongOp f) {\n+            return dummyVector().ldLongOp(memory, offset, m, f);\n+        }\n+\n@@ -3855,0 +3841,14 @@\n+        \/*package-private*\/\n+        @ForceInline\n+        void stLongOp(MemorySegment memory, long offset, FStLongOp f) {\n+            dummyVector().stLongOp(memory, offset, f);\n+        }\n+\n+        \/*package-private*\/\n+        @ForceInline\n+        void stLongOp(MemorySegment memory, long offset,\n+                      AbstractMask<Float> m,\n+                      FStLongOp f) {\n+            dummyVector().stLongOp(memory, offset, m, f);\n+        }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/FloatVector.java","additions":273,"deletions":273,"binary":false,"changes":546,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import java.nio.ByteBuffer;\n@@ -32,0 +31,1 @@\n+import jdk.incubator.foreign.MemorySegment;\n@@ -477,0 +477,16 @@\n+    @Override\n+    @ForceInline\n+    public Int128Vector compress(VectorMask<Integer> m) {\n+        return (Int128Vector)\n+            super.compressTemplate(Int128Mask.class,\n+                                   (Int128Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Int128Vector expand(VectorMask<Integer> m) {\n+        return (Int128Vector)\n+            super.expandTemplate(Int128Mask.class,\n+                                   (Int128Mask) m);  \/\/ specialize\n+    }\n+\n@@ -656,0 +672,9 @@\n+        @Override\n+        @ForceInline\n+        public Int128Mask compress() {\n+            return (Int128Mask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n+                Int128Vector.class, Int128Mask.class, ETYPE, VLENGTH, null, this,\n+                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));\n+        }\n+\n+\n@@ -848,2 +873,2 @@\n-    IntVector fromByteArray0(byte[] a, int offset) {\n-        return super.fromByteArray0Template(a, offset);  \/\/ specialize\n+    IntVector fromMemorySegment0(MemorySegment ms, long offset) {\n+        return super.fromMemorySegment0Template(ms, offset);  \/\/ specialize\n@@ -855,16 +880,2 @@\n-    IntVector fromByteArray0(byte[] a, int offset, VectorMask<Integer> m) {\n-        return super.fromByteArray0Template(Int128Mask.class, a, offset, (Int128Mask) m);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    IntVector fromByteBuffer0(ByteBuffer bb, int offset) {\n-        return super.fromByteBuffer0Template(bb, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    IntVector fromByteBuffer0(ByteBuffer bb, int offset, VectorMask<Integer> m) {\n-        return super.fromByteBuffer0Template(Int128Mask.class, bb, offset, (Int128Mask) m);  \/\/ specialize\n+    IntVector fromMemorySegment0(MemorySegment ms, long offset, VectorMask<Integer> m) {\n+        return super.fromMemorySegment0Template(Int128Mask.class, ms, offset, (Int128Mask) m);  \/\/ specialize\n@@ -898,16 +909,2 @@\n-    void intoByteArray0(byte[] a, int offset) {\n-        super.intoByteArray0Template(a, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoByteArray0(byte[] a, int offset, VectorMask<Integer> m) {\n-        super.intoByteArray0Template(Int128Mask.class, a, offset, (Int128Mask) m);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoByteBuffer0(ByteBuffer bb, int offset, VectorMask<Integer> m) {\n-        super.intoByteBuffer0Template(Int128Mask.class, bb, offset, (Int128Mask) m);\n+    void intoMemorySegment0(MemorySegment ms, long offset, VectorMask<Integer> m) {\n+        super.intoMemorySegment0Template(Int128Mask.class, ms, offset, (Int128Mask) m);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int128Vector.java","additions":32,"deletions":35,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import java.nio.ByteBuffer;\n@@ -32,0 +31,1 @@\n+import jdk.incubator.foreign.MemorySegment;\n@@ -477,0 +477,16 @@\n+    @Override\n+    @ForceInline\n+    public Int256Vector compress(VectorMask<Integer> m) {\n+        return (Int256Vector)\n+            super.compressTemplate(Int256Mask.class,\n+                                   (Int256Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Int256Vector expand(VectorMask<Integer> m) {\n+        return (Int256Vector)\n+            super.expandTemplate(Int256Mask.class,\n+                                   (Int256Mask) m);  \/\/ specialize\n+    }\n+\n@@ -664,0 +680,9 @@\n+        @Override\n+        @ForceInline\n+        public Int256Mask compress() {\n+            return (Int256Mask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n+                Int256Vector.class, Int256Mask.class, ETYPE, VLENGTH, null, this,\n+                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));\n+        }\n+\n+\n@@ -856,2 +881,2 @@\n-    IntVector fromByteArray0(byte[] a, int offset) {\n-        return super.fromByteArray0Template(a, offset);  \/\/ specialize\n+    IntVector fromMemorySegment0(MemorySegment ms, long offset) {\n+        return super.fromMemorySegment0Template(ms, offset);  \/\/ specialize\n@@ -863,16 +888,2 @@\n-    IntVector fromByteArray0(byte[] a, int offset, VectorMask<Integer> m) {\n-        return super.fromByteArray0Template(Int256Mask.class, a, offset, (Int256Mask) m);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    IntVector fromByteBuffer0(ByteBuffer bb, int offset) {\n-        return super.fromByteBuffer0Template(bb, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    IntVector fromByteBuffer0(ByteBuffer bb, int offset, VectorMask<Integer> m) {\n-        return super.fromByteBuffer0Template(Int256Mask.class, bb, offset, (Int256Mask) m);  \/\/ specialize\n+    IntVector fromMemorySegment0(MemorySegment ms, long offset, VectorMask<Integer> m) {\n+        return super.fromMemorySegment0Template(Int256Mask.class, ms, offset, (Int256Mask) m);  \/\/ specialize\n@@ -906,16 +917,2 @@\n-    void intoByteArray0(byte[] a, int offset) {\n-        super.intoByteArray0Template(a, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoByteArray0(byte[] a, int offset, VectorMask<Integer> m) {\n-        super.intoByteArray0Template(Int256Mask.class, a, offset, (Int256Mask) m);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoByteBuffer0(ByteBuffer bb, int offset, VectorMask<Integer> m) {\n-        super.intoByteBuffer0Template(Int256Mask.class, bb, offset, (Int256Mask) m);\n+    void intoMemorySegment0(MemorySegment ms, long offset, VectorMask<Integer> m) {\n+        super.intoMemorySegment0Template(Int256Mask.class, ms, offset, (Int256Mask) m);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int256Vector.java","additions":32,"deletions":35,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import java.nio.ByteBuffer;\n@@ -32,0 +31,1 @@\n+import jdk.incubator.foreign.MemorySegment;\n@@ -477,0 +477,16 @@\n+    @Override\n+    @ForceInline\n+    public Int512Vector compress(VectorMask<Integer> m) {\n+        return (Int512Vector)\n+            super.compressTemplate(Int512Mask.class,\n+                                   (Int512Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Int512Vector expand(VectorMask<Integer> m) {\n+        return (Int512Vector)\n+            super.expandTemplate(Int512Mask.class,\n+                                   (Int512Mask) m);  \/\/ specialize\n+    }\n+\n@@ -680,0 +696,9 @@\n+        @Override\n+        @ForceInline\n+        public Int512Mask compress() {\n+            return (Int512Mask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n+                Int512Vector.class, Int512Mask.class, ETYPE, VLENGTH, null, this,\n+                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));\n+        }\n+\n+\n@@ -872,2 +897,2 @@\n-    IntVector fromByteArray0(byte[] a, int offset) {\n-        return super.fromByteArray0Template(a, offset);  \/\/ specialize\n+    IntVector fromMemorySegment0(MemorySegment ms, long offset) {\n+        return super.fromMemorySegment0Template(ms, offset);  \/\/ specialize\n@@ -879,16 +904,2 @@\n-    IntVector fromByteArray0(byte[] a, int offset, VectorMask<Integer> m) {\n-        return super.fromByteArray0Template(Int512Mask.class, a, offset, (Int512Mask) m);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    IntVector fromByteBuffer0(ByteBuffer bb, int offset) {\n-        return super.fromByteBuffer0Template(bb, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    IntVector fromByteBuffer0(ByteBuffer bb, int offset, VectorMask<Integer> m) {\n-        return super.fromByteBuffer0Template(Int512Mask.class, bb, offset, (Int512Mask) m);  \/\/ specialize\n+    IntVector fromMemorySegment0(MemorySegment ms, long offset, VectorMask<Integer> m) {\n+        return super.fromMemorySegment0Template(Int512Mask.class, ms, offset, (Int512Mask) m);  \/\/ specialize\n@@ -922,16 +933,2 @@\n-    void intoByteArray0(byte[] a, int offset) {\n-        super.intoByteArray0Template(a, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoByteArray0(byte[] a, int offset, VectorMask<Integer> m) {\n-        super.intoByteArray0Template(Int512Mask.class, a, offset, (Int512Mask) m);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoByteBuffer0(ByteBuffer bb, int offset, VectorMask<Integer> m) {\n-        super.intoByteBuffer0Template(Int512Mask.class, bb, offset, (Int512Mask) m);\n+    void intoMemorySegment0(MemorySegment ms, long offset, VectorMask<Integer> m) {\n+        super.intoMemorySegment0Template(Int512Mask.class, ms, offset, (Int512Mask) m);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int512Vector.java","additions":32,"deletions":35,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import java.nio.ByteBuffer;\n@@ -32,0 +31,1 @@\n+import jdk.incubator.foreign.MemorySegment;\n@@ -477,0 +477,16 @@\n+    @Override\n+    @ForceInline\n+    public Int64Vector compress(VectorMask<Integer> m) {\n+        return (Int64Vector)\n+            super.compressTemplate(Int64Mask.class,\n+                                   (Int64Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Int64Vector expand(VectorMask<Integer> m) {\n+        return (Int64Vector)\n+            super.expandTemplate(Int64Mask.class,\n+                                   (Int64Mask) m);  \/\/ specialize\n+    }\n+\n@@ -652,0 +668,9 @@\n+        @Override\n+        @ForceInline\n+        public Int64Mask compress() {\n+            return (Int64Mask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n+                Int64Vector.class, Int64Mask.class, ETYPE, VLENGTH, null, this,\n+                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));\n+        }\n+\n+\n@@ -844,2 +869,2 @@\n-    IntVector fromByteArray0(byte[] a, int offset) {\n-        return super.fromByteArray0Template(a, offset);  \/\/ specialize\n+    IntVector fromMemorySegment0(MemorySegment ms, long offset) {\n+        return super.fromMemorySegment0Template(ms, offset);  \/\/ specialize\n@@ -851,16 +876,2 @@\n-    IntVector fromByteArray0(byte[] a, int offset, VectorMask<Integer> m) {\n-        return super.fromByteArray0Template(Int64Mask.class, a, offset, (Int64Mask) m);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    IntVector fromByteBuffer0(ByteBuffer bb, int offset) {\n-        return super.fromByteBuffer0Template(bb, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    IntVector fromByteBuffer0(ByteBuffer bb, int offset, VectorMask<Integer> m) {\n-        return super.fromByteBuffer0Template(Int64Mask.class, bb, offset, (Int64Mask) m);  \/\/ specialize\n+    IntVector fromMemorySegment0(MemorySegment ms, long offset, VectorMask<Integer> m) {\n+        return super.fromMemorySegment0Template(Int64Mask.class, ms, offset, (Int64Mask) m);  \/\/ specialize\n@@ -894,16 +905,2 @@\n-    void intoByteArray0(byte[] a, int offset) {\n-        super.intoByteArray0Template(a, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoByteArray0(byte[] a, int offset, VectorMask<Integer> m) {\n-        super.intoByteArray0Template(Int64Mask.class, a, offset, (Int64Mask) m);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoByteBuffer0(ByteBuffer bb, int offset, VectorMask<Integer> m) {\n-        super.intoByteBuffer0Template(Int64Mask.class, bb, offset, (Int64Mask) m);\n+    void intoMemorySegment0(MemorySegment ms, long offset, VectorMask<Integer> m) {\n+        super.intoMemorySegment0Template(Int64Mask.class, ms, offset, (Int64Mask) m);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int64Vector.java","additions":32,"deletions":35,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import java.nio.ByteBuffer;\n@@ -32,0 +31,1 @@\n+import jdk.incubator.foreign.MemorySegment;\n@@ -477,0 +477,16 @@\n+    @Override\n+    @ForceInline\n+    public IntMaxVector compress(VectorMask<Integer> m) {\n+        return (IntMaxVector)\n+            super.compressTemplate(IntMaxMask.class,\n+                                   (IntMaxMask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public IntMaxVector expand(VectorMask<Integer> m) {\n+        return (IntMaxVector)\n+            super.expandTemplate(IntMaxMask.class,\n+                                   (IntMaxMask) m);  \/\/ specialize\n+    }\n+\n@@ -650,0 +666,9 @@\n+        @Override\n+        @ForceInline\n+        public IntMaxMask compress() {\n+            return (IntMaxMask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n+                IntMaxVector.class, IntMaxMask.class, ETYPE, VLENGTH, null, this,\n+                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));\n+        }\n+\n+\n@@ -853,2 +878,2 @@\n-    IntVector fromByteArray0(byte[] a, int offset) {\n-        return super.fromByteArray0Template(a, offset);  \/\/ specialize\n+    IntVector fromMemorySegment0(MemorySegment ms, long offset) {\n+        return super.fromMemorySegment0Template(ms, offset);  \/\/ specialize\n@@ -860,16 +885,2 @@\n-    IntVector fromByteArray0(byte[] a, int offset, VectorMask<Integer> m) {\n-        return super.fromByteArray0Template(IntMaxMask.class, a, offset, (IntMaxMask) m);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    IntVector fromByteBuffer0(ByteBuffer bb, int offset) {\n-        return super.fromByteBuffer0Template(bb, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    IntVector fromByteBuffer0(ByteBuffer bb, int offset, VectorMask<Integer> m) {\n-        return super.fromByteBuffer0Template(IntMaxMask.class, bb, offset, (IntMaxMask) m);  \/\/ specialize\n+    IntVector fromMemorySegment0(MemorySegment ms, long offset, VectorMask<Integer> m) {\n+        return super.fromMemorySegment0Template(IntMaxMask.class, ms, offset, (IntMaxMask) m);  \/\/ specialize\n@@ -903,16 +914,2 @@\n-    void intoByteArray0(byte[] a, int offset) {\n-        super.intoByteArray0Template(a, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoByteArray0(byte[] a, int offset, VectorMask<Integer> m) {\n-        super.intoByteArray0Template(IntMaxMask.class, a, offset, (IntMaxMask) m);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoByteBuffer0(ByteBuffer bb, int offset, VectorMask<Integer> m) {\n-        super.intoByteBuffer0Template(IntMaxMask.class, bb, offset, (IntMaxMask) m);\n+    void intoMemorySegment0(MemorySegment ms, long offset, VectorMask<Integer> m) {\n+        super.intoMemorySegment0Template(IntMaxMask.class, ms, offset, (IntMaxMask) m);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/IntMaxVector.java","additions":32,"deletions":35,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import java.nio.ByteBuffer;\n@@ -29,1 +28,0 @@\n-import java.nio.ReadOnlyBufferException;\n@@ -33,1 +31,0 @@\n-import java.util.function.UnaryOperator;\n@@ -35,0 +32,3 @@\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ValueLayout;\n+import jdk.internal.access.foreign.MemorySegmentProxy;\n@@ -60,0 +60,2 @@\n+    static final ValueLayout.OfInt ELEMENT_LAYOUT = ValueLayout.JAVA_INT.withBitAlignment(8);\n+\n@@ -354,0 +356,39 @@\n+    \/*package-private*\/\n+    interface FLdLongOp {\n+        int apply(MemorySegment memory, long offset, int i);\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    IntVector ldLongOp(MemorySegment memory, long offset,\n+                                  FLdLongOp f) {\n+        \/\/dummy; no vec = vec();\n+        int[] res = new int[length()];\n+        for (int i = 0; i < res.length; i++) {\n+            res[i] = f.apply(memory, offset, i);\n+        }\n+        return vectorFactory(res);\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    IntVector ldLongOp(MemorySegment memory, long offset,\n+                                  VectorMask<Integer> m,\n+                                  FLdLongOp f) {\n+        \/\/int[] vec = vec();\n+        int[] res = new int[length()];\n+        boolean[] mbits = ((AbstractMask<Integer>)m).getBits();\n+        for (int i = 0; i < res.length; i++) {\n+            if (mbits[i]) {\n+                res[i] = f.apply(memory, offset, i);\n+            }\n+        }\n+        return vectorFactory(res);\n+    }\n+\n+    static int memorySegmentGet(MemorySegment ms, long o, int i) {\n+        return ms.get(ELEMENT_LAYOUT, o + i * 4L);\n+    }\n+\n@@ -384,0 +425,34 @@\n+    interface FStLongOp {\n+        void apply(MemorySegment memory, long offset, int i, int a);\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    void stLongOp(MemorySegment memory, long offset,\n+                  FStLongOp f) {\n+        int[] vec = vec();\n+        for (int i = 0; i < vec.length; i++) {\n+            f.apply(memory, offset, i, vec[i]);\n+        }\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    void stLongOp(MemorySegment memory, long offset,\n+                  VectorMask<Integer> m,\n+                  FStLongOp f) {\n+        int[] vec = vec();\n+        boolean[] mbits = ((AbstractMask<Integer>)m).getBits();\n+        for (int i = 0; i < vec.length; i++) {\n+            if (mbits[i]) {\n+                f.apply(memory, offset, i, vec[i]);\n+            }\n+        }\n+    }\n+\n+    static void memorySegmentSet(MemorySegment ms, long o, int i, int e) {\n+        ms.set(ELEMENT_LAYOUT, o + i * 4L, e);\n+    }\n+\n@@ -434,0 +509,30 @@\n+    static IntVector expandHelper(Vector<Integer> v, VectorMask<Integer> m) {\n+        VectorSpecies<Integer> vsp = m.vectorSpecies();\n+        IntVector r  = (IntVector) vsp.zero();\n+        IntVector vi = (IntVector) v;\n+        if (m.allTrue()) {\n+            return vi;\n+        }\n+        for (int i = 0, j = 0; i < vsp.length(); i++) {\n+            if (m.laneIsSet(i)) {\n+                r = r.withLane(i, vi.lane(j++));\n+            }\n+        }\n+        return r;\n+    }\n+\n+    static IntVector compressHelper(Vector<Integer> v, VectorMask<Integer> m) {\n+        VectorSpecies<Integer> vsp = m.vectorSpecies();\n+        IntVector r  = (IntVector) vsp.zero();\n+        IntVector vi = (IntVector) v;\n+        if (m.allTrue()) {\n+            return vi;\n+        }\n+        for (int i = 0, j = 0; i < vsp.length(); i++) {\n+            if (m.laneIsSet(i)) {\n+                r = r.withLane(j++, vi.lane(i));\n+            }\n+        }\n+        return r;\n+    }\n+\n@@ -623,0 +728,10 @@\n+            case VECTOR_OP_BIT_COUNT: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> (int) Integer.bitCount(a));\n+            case VECTOR_OP_TZ_COUNT: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> (int) Integer.numberOfTrailingZeros(a));\n+            case VECTOR_OP_LZ_COUNT: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> (int) Integer.numberOfLeadingZeros(a));\n+            case VECTOR_OP_REVERSE: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> (int) Integer.reverse(a));\n+            case VECTOR_OP_REVERSE_BYTES: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> (int) Integer.reverseBytes(a));\n@@ -763,0 +878,4 @@\n+            case VECTOR_OP_COMPRESS_BITS: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, n) -> Integer.compress(a, n));\n+            case VECTOR_OP_EXPAND_BITS: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, n) -> Integer.expand(a, n));\n@@ -1748,0 +1867,1 @@\n+\n@@ -2374,0 +2494,39 @@\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     * @since 19\n+     *\/\n+    @Override\n+    public abstract\n+    IntVector compress(VectorMask<Integer> m);\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M extends AbstractMask<Integer>>\n+    IntVector compressTemplate(Class<M> masktype, M m) {\n+      m.check(masktype, this);\n+      return (IntVector) VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_COMPRESS, getClass(), masktype,\n+                                                        int.class, length(), this, m,\n+                                                        (v1, m1) -> compressHelper(v1, m1));\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     * @since 19\n+     *\/\n+    @Override\n+    public abstract\n+    IntVector expand(VectorMask<Integer> m);\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M extends AbstractMask<Integer>>\n+    IntVector expandTemplate(Class<M> masktype, M m) {\n+      m.check(masktype, this);\n+      return (IntVector) VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_EXPAND, getClass(), masktype,\n+                                                        int.class, length(), this, m,\n+                                                        (v1, m1) -> expandHelper(v1, m1));\n+    }\n+\n+\n@@ -2779,84 +2938,0 @@\n-    \/**\n-     * Loads a vector from a byte array starting at an offset.\n-     * Bytes are composed into primitive lane elements according\n-     * to the specified byte order.\n-     * The vector is arranged into lanes according to\n-     * <a href=\"Vector.html#lane-order\">memory ordering<\/a>.\n-     * <p>\n-     * This method behaves as if it returns the result of calling\n-     * {@link #fromByteBuffer(VectorSpecies,ByteBuffer,int,ByteOrder,VectorMask)\n-     * fromByteBuffer()} as follows:\n-     * <pre>{@code\n-     * var bb = ByteBuffer.wrap(a);\n-     * var m = species.maskAll(true);\n-     * return fromByteBuffer(species, bb, offset, bo, m);\n-     * }<\/pre>\n-     *\n-     * @param species species of desired vector\n-     * @param a the byte array\n-     * @param offset the offset into the array\n-     * @param bo the intended byte order\n-     * @return a vector loaded from a byte array\n-     * @throws IndexOutOfBoundsException\n-     *         if {@code offset+N*ESIZE < 0}\n-     *         or {@code offset+(N+1)*ESIZE > a.length}\n-     *         for any lane {@code N} in the vector\n-     *\/\n-    @ForceInline\n-    public static\n-    IntVector fromByteArray(VectorSpecies<Integer> species,\n-                                       byte[] a, int offset,\n-                                       ByteOrder bo) {\n-        offset = checkFromIndexSize(offset, species.vectorByteSize(), a.length);\n-        IntSpecies vsp = (IntSpecies) species;\n-        return vsp.dummyVector().fromByteArray0(a, offset).maybeSwap(bo);\n-    }\n-\n-    \/**\n-     * Loads a vector from a byte array starting at an offset\n-     * and using a mask.\n-     * Lanes where the mask is unset are filled with the default\n-     * value of {@code int} (zero).\n-     * Bytes are composed into primitive lane elements according\n-     * to the specified byte order.\n-     * The vector is arranged into lanes according to\n-     * <a href=\"Vector.html#lane-order\">memory ordering<\/a>.\n-     * <p>\n-     * This method behaves as if it returns the result of calling\n-     * {@link #fromByteBuffer(VectorSpecies,ByteBuffer,int,ByteOrder,VectorMask)\n-     * fromByteBuffer()} as follows:\n-     * <pre>{@code\n-     * var bb = ByteBuffer.wrap(a);\n-     * return fromByteBuffer(species, bb, offset, bo, m);\n-     * }<\/pre>\n-     *\n-     * @param species species of desired vector\n-     * @param a the byte array\n-     * @param offset the offset into the array\n-     * @param bo the intended byte order\n-     * @param m the mask controlling lane selection\n-     * @return a vector loaded from a byte array\n-     * @throws IndexOutOfBoundsException\n-     *         if {@code offset+N*ESIZE < 0}\n-     *         or {@code offset+(N+1)*ESIZE > a.length}\n-     *         for any lane {@code N} in the vector\n-     *         where the mask is set\n-     *\/\n-    @ForceInline\n-    public static\n-    IntVector fromByteArray(VectorSpecies<Integer> species,\n-                                       byte[] a, int offset,\n-                                       ByteOrder bo,\n-                                       VectorMask<Integer> m) {\n-        IntSpecies vsp = (IntSpecies) species;\n-        if (offset >= 0 && offset <= (a.length - species.vectorByteSize())) {\n-            return vsp.dummyVector().fromByteArray0(a, offset, m).maybeSwap(bo);\n-        }\n-\n-        \/\/ FIXME: optimize\n-        checkMaskFromIndexSize(offset, vsp, m, 4, a.length);\n-        ByteBuffer wb = wrapper(a, bo);\n-        return vsp.ldOp(wb, offset, (AbstractMask<Integer>)m,\n-                   (wb_, o, i)  -> wb_.getInt(o + i * 4));\n-    }\n-\n@@ -3035,2 +3110,2 @@\n-     * Loads a vector from a {@linkplain ByteBuffer byte buffer}\n-     * starting at an offset into the byte buffer.\n+     * Loads a vector from a {@linkplain MemorySegment memory segment}\n+     * starting at an offset into the memory segment.\n@@ -3043,2 +3118,2 @@\n-     * {@link #fromByteBuffer(VectorSpecies,ByteBuffer,int,ByteOrder,VectorMask)\n-     * fromByteBuffer()} as follows:\n+     * {@link #fromMemorySegment(VectorSpecies,MemorySegment,long,ByteOrder,VectorMask)\n+     * fromMemorySegment()} as follows:\n@@ -3047,1 +3122,1 @@\n-     * return fromByteBuffer(species, bb, offset, bo, m);\n+     * return fromMemorySegment(species, ms, offset, bo, m);\n@@ -3051,2 +3126,2 @@\n-     * @param bb the byte buffer\n-     * @param offset the offset into the byte buffer\n+     * @param ms the memory segment\n+     * @param offset the offset into the memory segment\n@@ -3054,1 +3129,1 @@\n-     * @return a vector loaded from a byte buffer\n+     * @return a vector loaded from the memory segment\n@@ -3057,1 +3132,1 @@\n-     *         or {@code offset+N*4 >= bb.limit()}\n+     *         or {@code offset+N*4 >= ms.byteSize()}\n@@ -3059,0 +3134,5 @@\n+     * @throws IllegalArgumentException if the memory segment is a heap segment that is\n+     *         not backed by a {@code byte[]} array.\n+     * @throws IllegalStateException if the memory segment's session is not alive,\n+     *         or if access occurs from a thread other than the thread owning the session.\n+     * @since 19\n@@ -3062,4 +3142,4 @@\n-    IntVector fromByteBuffer(VectorSpecies<Integer> species,\n-                                        ByteBuffer bb, int offset,\n-                                        ByteOrder bo) {\n-        offset = checkFromIndexSize(offset, species.vectorByteSize(), bb.limit());\n+    IntVector fromMemorySegment(VectorSpecies<Integer> species,\n+                                           MemorySegment ms, long offset,\n+                                           ByteOrder bo) {\n+        offset = checkFromIndexSize(offset, species.vectorByteSize(), ms.byteSize());\n@@ -3067,1 +3147,1 @@\n-        return vsp.dummyVector().fromByteBuffer0(bb, offset).maybeSwap(bo);\n+        return vsp.dummyVector().fromMemorySegment0(ms, offset).maybeSwap(bo);\n@@ -3071,2 +3151,2 @@\n-     * Loads a vector from a {@linkplain ByteBuffer byte buffer}\n-     * starting at an offset into the byte buffer\n+     * Loads a vector from a {@linkplain MemorySegment memory segment}\n+     * starting at an offset into the memory segment\n@@ -3083,3 +3163,1 @@\n-     * IntBuffer eb = bb.duplicate()\n-     *     .position(offset)\n-     *     .order(bo).asIntBuffer();\n+     * var slice = ms.asSlice(offset);\n@@ -3089,1 +3167,1 @@\n-     *         ar[n] = eb.get(n);\n+     *         ar[n] = slice.getAtIndex(ValuaLayout.JAVA_INT.withBitAlignment(8), n);\n@@ -3103,2 +3181,2 @@\n-     * @param bb the byte buffer\n-     * @param offset the offset into the byte buffer\n+     * @param ms the memory segment\n+     * @param offset the offset into the memory segment\n@@ -3107,1 +3185,1 @@\n-     * @return a vector loaded from a byte buffer\n+     * @return a vector loaded from the memory segment\n@@ -3110,1 +3188,1 @@\n-     *         or {@code offset+N*4 >= bb.limit()}\n+     *         or {@code offset+N*4 >= ms.byteSize()}\n@@ -3113,0 +3191,5 @@\n+     * @throws IllegalArgumentException if the memory segment is a heap segment that is\n+     *         not backed by a {@code byte[]} array.\n+     * @throws IllegalStateException if the memory segment's session is not alive,\n+     *         or if access occurs from a thread other than the thread owning the session.\n+     * @since 19\n@@ -3116,4 +3199,4 @@\n-    IntVector fromByteBuffer(VectorSpecies<Integer> species,\n-                                        ByteBuffer bb, int offset,\n-                                        ByteOrder bo,\n-                                        VectorMask<Integer> m) {\n+    IntVector fromMemorySegment(VectorSpecies<Integer> species,\n+                                           MemorySegment ms, long offset,\n+                                           ByteOrder bo,\n+                                           VectorMask<Integer> m) {\n@@ -3121,2 +3204,2 @@\n-        if (offset >= 0 && offset <= (bb.limit() - species.vectorByteSize())) {\n-            return vsp.dummyVector().fromByteBuffer0(bb, offset, m).maybeSwap(bo);\n+        if (offset >= 0 && offset <= (ms.byteSize() - species.vectorByteSize())) {\n+            return vsp.dummyVector().fromMemorySegment0(ms, offset, m).maybeSwap(bo);\n@@ -3126,4 +3209,2 @@\n-        checkMaskFromIndexSize(offset, vsp, m, 4, bb.limit());\n-        ByteBuffer wb = wrapper(bb, bo);\n-        return vsp.ldOp(wb, offset, (AbstractMask<Integer>)m,\n-                   (wb_, o, i)  -> wb_.getInt(o + i * 4));\n+        checkMaskFromIndexSize(offset, vsp, m, 4, ms.byteSize());\n+        return vsp.ldLongOp(ms, offset, m, IntVector::memorySegmentGet);\n@@ -3159,1 +3240,1 @@\n-            -> v.stOp(arr, off,\n+            -> v.stOp(arr, (int) off,\n@@ -3300,0 +3381,1 @@\n+     * @since 19\n@@ -3304,21 +3386,4 @@\n-    void intoByteArray(byte[] a, int offset,\n-                       ByteOrder bo) {\n-        offset = checkFromIndexSize(offset, byteSize(), a.length);\n-        maybeSwap(bo).intoByteArray0(a, offset);\n-    }\n-\n-    \/**\n-     * {@inheritDoc} <!--workaround-->\n-     *\/\n-    @Override\n-    @ForceInline\n-    public final\n-    void intoByteArray(byte[] a, int offset,\n-                       ByteOrder bo,\n-                       VectorMask<Integer> m) {\n-        if (m.allTrue()) {\n-            intoByteArray(a, offset, bo);\n-        } else {\n-            IntSpecies vsp = vspecies();\n-            checkMaskFromIndexSize(offset, vsp, m, 4, a.length);\n-            maybeSwap(bo).intoByteArray0(a, offset, m);\n+    void intoMemorySegment(MemorySegment ms, long offset,\n+                           ByteOrder bo) {\n+        if (ms.isReadOnly()) {\n+            throw new UnsupportedOperationException(\"Attempt to write a read-only segment\");\n@@ -3326,1 +3391,0 @@\n-    }\n@@ -3328,13 +3392,2 @@\n-    \/**\n-     * {@inheritDoc} <!--workaround-->\n-     *\/\n-    @Override\n-    @ForceInline\n-    public final\n-    void intoByteBuffer(ByteBuffer bb, int offset,\n-                        ByteOrder bo) {\n-        if (ScopedMemoryAccess.isReadOnly(bb)) {\n-            throw new ReadOnlyBufferException();\n-        }\n-        offset = checkFromIndexSize(offset, byteSize(), bb.limit());\n-        maybeSwap(bo).intoByteBuffer0(bb, offset);\n+        offset = checkFromIndexSize(offset, byteSize(), ms.byteSize());\n+        maybeSwap(bo).intoMemorySegment0(ms, offset);\n@@ -3345,0 +3398,1 @@\n+     * @since 19\n@@ -3349,3 +3403,3 @@\n-    void intoByteBuffer(ByteBuffer bb, int offset,\n-                        ByteOrder bo,\n-                        VectorMask<Integer> m) {\n+    void intoMemorySegment(MemorySegment ms, long offset,\n+                           ByteOrder bo,\n+                           VectorMask<Integer> m) {\n@@ -3353,1 +3407,1 @@\n-            intoByteBuffer(bb, offset, bo);\n+            intoMemorySegment(ms, offset, bo);\n@@ -3355,2 +3409,2 @@\n-            if (bb.isReadOnly()) {\n-                throw new ReadOnlyBufferException();\n+            if (ms.isReadOnly()) {\n+                throw new UnsupportedOperationException(\"Attempt to write a read-only segment\");\n@@ -3359,2 +3413,2 @@\n-            checkMaskFromIndexSize(offset, vsp, m, 4, bb.limit());\n-            maybeSwap(bo).intoByteBuffer0(bb, offset, m);\n+            checkMaskFromIndexSize(offset, vsp, m, 4, ms.byteSize());\n+            maybeSwap(bo).intoMemorySegment0(ms, offset, m);\n@@ -3394,1 +3448,1 @@\n-            (arr, off, s) -> s.ldOp(arr, off,\n+            (arr, off, s) -> s.ldOp(arr, (int) off,\n@@ -3411,1 +3465,1 @@\n-            (arr, off, s, vm) -> s.ldOp(arr, off, vm,\n+            (arr, off, s, vm) -> s.ldOp(arr, (int) off, vm,\n@@ -3451,1 +3505,0 @@\n-    @Override\n@@ -3453,1 +3506,1 @@\n-    IntVector fromByteArray0(byte[] a, int offset);\n+    IntVector fromMemorySegment0(MemorySegment bb, long offset);\n@@ -3456,1 +3509,1 @@\n-    IntVector fromByteArray0Template(byte[] a, int offset) {\n+    IntVector fromMemorySegment0Template(MemorySegment ms, long offset) {\n@@ -3458,37 +3511,1 @@\n-        return VectorSupport.load(\n-            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n-            a, byteArrayAddress(a, offset),\n-            a, offset, vsp,\n-            (arr, off, s) -> {\n-                ByteBuffer wb = wrapper(arr, NATIVE_ENDIAN);\n-                return s.ldOp(wb, off,\n-                        (wb_, o, i) -> wb_.getInt(o + i * 4));\n-            });\n-    }\n-\n-    abstract\n-    IntVector fromByteArray0(byte[] a, int offset, VectorMask<Integer> m);\n-    @ForceInline\n-    final\n-    <M extends VectorMask<Integer>>\n-    IntVector fromByteArray0Template(Class<M> maskClass, byte[] a, int offset, M m) {\n-        IntSpecies vsp = vspecies();\n-        m.check(vsp);\n-        return VectorSupport.loadMasked(\n-            vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n-            a, byteArrayAddress(a, offset), m,\n-            a, offset, vsp,\n-            (arr, off, s, vm) -> {\n-                ByteBuffer wb = wrapper(arr, NATIVE_ENDIAN);\n-                return s.ldOp(wb, off, vm,\n-                        (wb_, o, i) -> wb_.getInt(o + i * 4));\n-            });\n-    }\n-\n-    abstract\n-    IntVector fromByteBuffer0(ByteBuffer bb, int offset);\n-    @ForceInline\n-    final\n-    IntVector fromByteBuffer0Template(ByteBuffer bb, int offset) {\n-        IntSpecies vsp = vspecies();\n-        return ScopedMemoryAccess.loadFromByteBuffer(\n+        return ScopedMemoryAccess.loadFromMemorySegment(\n@@ -3496,5 +3513,3 @@\n-                bb, offset, vsp,\n-                (buf, off, s) -> {\n-                    ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n-                    return s.ldOp(wb, off,\n-                            (wb_, o, i) -> wb_.getInt(o + i * 4));\n+                (MemorySegmentProxy) ms, offset, vsp,\n+                (msp, off, s) -> {\n+                    return s.ldLongOp((MemorySegment) msp, off, IntVector::memorySegmentGet);\n@@ -3505,1 +3520,1 @@\n-    IntVector fromByteBuffer0(ByteBuffer bb, int offset, VectorMask<Integer> m);\n+    IntVector fromMemorySegment0(MemorySegment ms, long offset, VectorMask<Integer> m);\n@@ -3509,1 +3524,1 @@\n-    IntVector fromByteBuffer0Template(Class<M> maskClass, ByteBuffer bb, int offset, M m) {\n+    IntVector fromMemorySegment0Template(Class<M> maskClass, MemorySegment ms, long offset, M m) {\n@@ -3512,1 +3527,1 @@\n-        return ScopedMemoryAccess.loadFromByteBufferMasked(\n+        return ScopedMemoryAccess.loadFromMemorySegmentMasked(\n@@ -3514,5 +3529,3 @@\n-                bb, offset, m, vsp,\n-                (buf, off, s, vm) -> {\n-                    ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n-                    return s.ldOp(wb, off, vm,\n-                            (wb_, o, i) -> wb_.getInt(o + i * 4));\n+                (MemorySegmentProxy) ms, offset, m, vsp,\n+                (msp, off, s, vm) -> {\n+                    return s.ldLongOp((MemorySegment) msp, off, vm, IntVector::memorySegmentGet);\n@@ -3537,1 +3550,1 @@\n-            -> v.stOp(arr, off,\n+            -> v.stOp(arr, (int) off,\n@@ -3554,1 +3567,1 @@\n-            -> v.stOp(arr, off, vm,\n+            -> v.stOp(arr, (int) off, vm,\n@@ -3593,19 +3606,0 @@\n-    abstract\n-    void intoByteArray0(byte[] a, int offset);\n-    @ForceInline\n-    final\n-    void intoByteArray0Template(byte[] a, int offset) {\n-        IntSpecies vsp = vspecies();\n-        VectorSupport.store(\n-            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n-            a, byteArrayAddress(a, offset),\n-            this, a, offset,\n-            (arr, off, v) -> {\n-                ByteBuffer wb = wrapper(arr, NATIVE_ENDIAN);\n-                v.stOp(wb, off,\n-                        (tb_, o, i, e) -> tb_.putInt(o + i * 4, e));\n-            });\n-    }\n-\n-    abstract\n-    void intoByteArray0(byte[] a, int offset, VectorMask<Integer> m);\n@@ -3614,2 +3608,1 @@\n-    <M extends VectorMask<Integer>>\n-    void intoByteArray0Template(Class<M> maskClass, byte[] a, int offset, M m) {\n+    void intoMemorySegment0(MemorySegment ms, long offset) {\n@@ -3617,17 +3610,1 @@\n-        m.check(vsp);\n-        VectorSupport.storeMasked(\n-            vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n-            a, byteArrayAddress(a, offset),\n-            this, m, a, offset,\n-            (arr, off, v, vm) -> {\n-                ByteBuffer wb = wrapper(arr, NATIVE_ENDIAN);\n-                v.stOp(wb, off, vm,\n-                        (tb_, o, i, e) -> tb_.putInt(o + i * 4, e));\n-            });\n-    }\n-\n-    @ForceInline\n-    final\n-    void intoByteBuffer0(ByteBuffer bb, int offset) {\n-        IntSpecies vsp = vspecies();\n-        ScopedMemoryAccess.storeIntoByteBuffer(\n+        ScopedMemoryAccess.storeIntoMemorySegment(\n@@ -3635,5 +3612,4 @@\n-                this, bb, offset,\n-                (buf, off, v) -> {\n-                    ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n-                    v.stOp(wb, off,\n-                            (wb_, o, i, e) -> wb_.putInt(o + i * 4, e));\n+                this,\n+                (MemorySegmentProxy) ms, offset,\n+                (msp, off, v) -> {\n+                    v.stLongOp((MemorySegment) msp, off, IntVector::memorySegmentSet);\n@@ -3644,1 +3620,1 @@\n-    void intoByteBuffer0(ByteBuffer bb, int offset, VectorMask<Integer> m);\n+    void intoMemorySegment0(MemorySegment bb, long offset, VectorMask<Integer> m);\n@@ -3648,1 +3624,1 @@\n-    void intoByteBuffer0Template(Class<M> maskClass, ByteBuffer bb, int offset, M m) {\n+    void intoMemorySegment0Template(Class<M> maskClass, MemorySegment ms, long offset, M m) {\n@@ -3651,1 +3627,1 @@\n-        ScopedMemoryAccess.storeIntoByteBufferMasked(\n+        ScopedMemoryAccess.storeIntoMemorySegmentMasked(\n@@ -3653,5 +3629,4 @@\n-                this, m, bb, offset,\n-                (buf, off, v, vm) -> {\n-                    ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n-                    v.stOp(wb, off, vm,\n-                            (wb_, o, i, e) -> wb_.putInt(o + i * 4, e));\n+                this, m,\n+                (MemorySegmentProxy) ms, offset,\n+                (msp, off, v, vm) -> {\n+                    v.stLongOp((MemorySegment) msp, off, vm, IntVector::memorySegmentSet);\n@@ -3674,0 +3649,10 @@\n+    private static\n+    void checkMaskFromIndexSize(long offset,\n+                                IntSpecies vsp,\n+                                VectorMask<Integer> m,\n+                                int scale,\n+                                long limit) {\n+        ((AbstractMask<Integer>)m)\n+            .checkIndexByLane(offset, limit, vsp.iota(), scale);\n+    }\n+\n@@ -3984,0 +3969,15 @@\n+        \/*package-private*\/\n+        @ForceInline\n+        IntVector ldLongOp(MemorySegment memory, long offset,\n+                                      FLdLongOp f) {\n+            return dummyVector().ldLongOp(memory, offset, f);\n+        }\n+\n+        \/*package-private*\/\n+        @ForceInline\n+        IntVector ldLongOp(MemorySegment memory, long offset,\n+                                      VectorMask<Integer> m,\n+                                      FLdLongOp f) {\n+            return dummyVector().ldLongOp(memory, offset, m, f);\n+        }\n+\n@@ -3998,0 +3998,14 @@\n+        \/*package-private*\/\n+        @ForceInline\n+        void stLongOp(MemorySegment memory, long offset, FStLongOp f) {\n+            dummyVector().stLongOp(memory, offset, f);\n+        }\n+\n+        \/*package-private*\/\n+        @ForceInline\n+        void stLongOp(MemorySegment memory, long offset,\n+                      AbstractMask<Integer> m,\n+                      FStLongOp f) {\n+            dummyVector().stLongOp(memory, offset, m, f);\n+        }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/IntVector.java","additions":287,"deletions":273,"binary":false,"changes":560,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import java.nio.ByteBuffer;\n@@ -32,0 +31,1 @@\n+import jdk.incubator.foreign.MemorySegment;\n@@ -467,0 +467,16 @@\n+    @Override\n+    @ForceInline\n+    public Long128Vector compress(VectorMask<Long> m) {\n+        return (Long128Vector)\n+            super.compressTemplate(Long128Mask.class,\n+                                   (Long128Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Long128Vector expand(VectorMask<Long> m) {\n+        return (Long128Vector)\n+            super.expandTemplate(Long128Mask.class,\n+                                   (Long128Mask) m);  \/\/ specialize\n+    }\n+\n@@ -642,0 +658,9 @@\n+        @Override\n+        @ForceInline\n+        public Long128Mask compress() {\n+            return (Long128Mask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n+                Long128Vector.class, Long128Mask.class, ETYPE, VLENGTH, null, this,\n+                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));\n+        }\n+\n+\n@@ -834,2 +859,2 @@\n-    LongVector fromByteArray0(byte[] a, int offset) {\n-        return super.fromByteArray0Template(a, offset);  \/\/ specialize\n+    LongVector fromMemorySegment0(MemorySegment ms, long offset) {\n+        return super.fromMemorySegment0Template(ms, offset);  \/\/ specialize\n@@ -841,16 +866,2 @@\n-    LongVector fromByteArray0(byte[] a, int offset, VectorMask<Long> m) {\n-        return super.fromByteArray0Template(Long128Mask.class, a, offset, (Long128Mask) m);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    LongVector fromByteBuffer0(ByteBuffer bb, int offset) {\n-        return super.fromByteBuffer0Template(bb, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    LongVector fromByteBuffer0(ByteBuffer bb, int offset, VectorMask<Long> m) {\n-        return super.fromByteBuffer0Template(Long128Mask.class, bb, offset, (Long128Mask) m);  \/\/ specialize\n+    LongVector fromMemorySegment0(MemorySegment ms, long offset, VectorMask<Long> m) {\n+        return super.fromMemorySegment0Template(Long128Mask.class, ms, offset, (Long128Mask) m);  \/\/ specialize\n@@ -884,16 +895,2 @@\n-    void intoByteArray0(byte[] a, int offset) {\n-        super.intoByteArray0Template(a, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoByteArray0(byte[] a, int offset, VectorMask<Long> m) {\n-        super.intoByteArray0Template(Long128Mask.class, a, offset, (Long128Mask) m);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoByteBuffer0(ByteBuffer bb, int offset, VectorMask<Long> m) {\n-        super.intoByteBuffer0Template(Long128Mask.class, bb, offset, (Long128Mask) m);\n+    void intoMemorySegment0(MemorySegment ms, long offset, VectorMask<Long> m) {\n+        super.intoMemorySegment0Template(Long128Mask.class, ms, offset, (Long128Mask) m);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long128Vector.java","additions":32,"deletions":35,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import java.nio.ByteBuffer;\n@@ -32,0 +31,1 @@\n+import jdk.incubator.foreign.MemorySegment;\n@@ -467,0 +467,16 @@\n+    @Override\n+    @ForceInline\n+    public Long256Vector compress(VectorMask<Long> m) {\n+        return (Long256Vector)\n+            super.compressTemplate(Long256Mask.class,\n+                                   (Long256Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Long256Vector expand(VectorMask<Long> m) {\n+        return (Long256Vector)\n+            super.expandTemplate(Long256Mask.class,\n+                                   (Long256Mask) m);  \/\/ specialize\n+    }\n+\n@@ -646,0 +662,9 @@\n+        @Override\n+        @ForceInline\n+        public Long256Mask compress() {\n+            return (Long256Mask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n+                Long256Vector.class, Long256Mask.class, ETYPE, VLENGTH, null, this,\n+                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));\n+        }\n+\n+\n@@ -838,2 +863,2 @@\n-    LongVector fromByteArray0(byte[] a, int offset) {\n-        return super.fromByteArray0Template(a, offset);  \/\/ specialize\n+    LongVector fromMemorySegment0(MemorySegment ms, long offset) {\n+        return super.fromMemorySegment0Template(ms, offset);  \/\/ specialize\n@@ -845,16 +870,2 @@\n-    LongVector fromByteArray0(byte[] a, int offset, VectorMask<Long> m) {\n-        return super.fromByteArray0Template(Long256Mask.class, a, offset, (Long256Mask) m);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    LongVector fromByteBuffer0(ByteBuffer bb, int offset) {\n-        return super.fromByteBuffer0Template(bb, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    LongVector fromByteBuffer0(ByteBuffer bb, int offset, VectorMask<Long> m) {\n-        return super.fromByteBuffer0Template(Long256Mask.class, bb, offset, (Long256Mask) m);  \/\/ specialize\n+    LongVector fromMemorySegment0(MemorySegment ms, long offset, VectorMask<Long> m) {\n+        return super.fromMemorySegment0Template(Long256Mask.class, ms, offset, (Long256Mask) m);  \/\/ specialize\n@@ -888,16 +899,2 @@\n-    void intoByteArray0(byte[] a, int offset) {\n-        super.intoByteArray0Template(a, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoByteArray0(byte[] a, int offset, VectorMask<Long> m) {\n-        super.intoByteArray0Template(Long256Mask.class, a, offset, (Long256Mask) m);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoByteBuffer0(ByteBuffer bb, int offset, VectorMask<Long> m) {\n-        super.intoByteBuffer0Template(Long256Mask.class, bb, offset, (Long256Mask) m);\n+    void intoMemorySegment0(MemorySegment ms, long offset, VectorMask<Long> m) {\n+        super.intoMemorySegment0Template(Long256Mask.class, ms, offset, (Long256Mask) m);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long256Vector.java","additions":32,"deletions":35,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import java.nio.ByteBuffer;\n@@ -32,0 +31,1 @@\n+import jdk.incubator.foreign.MemorySegment;\n@@ -467,0 +467,16 @@\n+    @Override\n+    @ForceInline\n+    public Long512Vector compress(VectorMask<Long> m) {\n+        return (Long512Vector)\n+            super.compressTemplate(Long512Mask.class,\n+                                   (Long512Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Long512Vector expand(VectorMask<Long> m) {\n+        return (Long512Vector)\n+            super.expandTemplate(Long512Mask.class,\n+                                   (Long512Mask) m);  \/\/ specialize\n+    }\n+\n@@ -654,0 +670,9 @@\n+        @Override\n+        @ForceInline\n+        public Long512Mask compress() {\n+            return (Long512Mask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n+                Long512Vector.class, Long512Mask.class, ETYPE, VLENGTH, null, this,\n+                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));\n+        }\n+\n+\n@@ -846,2 +871,2 @@\n-    LongVector fromByteArray0(byte[] a, int offset) {\n-        return super.fromByteArray0Template(a, offset);  \/\/ specialize\n+    LongVector fromMemorySegment0(MemorySegment ms, long offset) {\n+        return super.fromMemorySegment0Template(ms, offset);  \/\/ specialize\n@@ -853,16 +878,2 @@\n-    LongVector fromByteArray0(byte[] a, int offset, VectorMask<Long> m) {\n-        return super.fromByteArray0Template(Long512Mask.class, a, offset, (Long512Mask) m);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    LongVector fromByteBuffer0(ByteBuffer bb, int offset) {\n-        return super.fromByteBuffer0Template(bb, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    LongVector fromByteBuffer0(ByteBuffer bb, int offset, VectorMask<Long> m) {\n-        return super.fromByteBuffer0Template(Long512Mask.class, bb, offset, (Long512Mask) m);  \/\/ specialize\n+    LongVector fromMemorySegment0(MemorySegment ms, long offset, VectorMask<Long> m) {\n+        return super.fromMemorySegment0Template(Long512Mask.class, ms, offset, (Long512Mask) m);  \/\/ specialize\n@@ -896,16 +907,2 @@\n-    void intoByteArray0(byte[] a, int offset) {\n-        super.intoByteArray0Template(a, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoByteArray0(byte[] a, int offset, VectorMask<Long> m) {\n-        super.intoByteArray0Template(Long512Mask.class, a, offset, (Long512Mask) m);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoByteBuffer0(ByteBuffer bb, int offset, VectorMask<Long> m) {\n-        super.intoByteBuffer0Template(Long512Mask.class, bb, offset, (Long512Mask) m);\n+    void intoMemorySegment0(MemorySegment ms, long offset, VectorMask<Long> m) {\n+        super.intoMemorySegment0Template(Long512Mask.class, ms, offset, (Long512Mask) m);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long512Vector.java","additions":32,"deletions":35,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import java.nio.ByteBuffer;\n@@ -32,0 +31,1 @@\n+import jdk.incubator.foreign.MemorySegment;\n@@ -467,0 +467,16 @@\n+    @Override\n+    @ForceInline\n+    public Long64Vector compress(VectorMask<Long> m) {\n+        return (Long64Vector)\n+            super.compressTemplate(Long64Mask.class,\n+                                   (Long64Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Long64Vector expand(VectorMask<Long> m) {\n+        return (Long64Vector)\n+            super.expandTemplate(Long64Mask.class,\n+                                   (Long64Mask) m);  \/\/ specialize\n+    }\n+\n@@ -640,0 +656,9 @@\n+        @Override\n+        @ForceInline\n+        public Long64Mask compress() {\n+            return (Long64Mask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n+                Long64Vector.class, Long64Mask.class, ETYPE, VLENGTH, null, this,\n+                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));\n+        }\n+\n+\n@@ -832,2 +857,2 @@\n-    LongVector fromByteArray0(byte[] a, int offset) {\n-        return super.fromByteArray0Template(a, offset);  \/\/ specialize\n+    LongVector fromMemorySegment0(MemorySegment ms, long offset) {\n+        return super.fromMemorySegment0Template(ms, offset);  \/\/ specialize\n@@ -839,16 +864,2 @@\n-    LongVector fromByteArray0(byte[] a, int offset, VectorMask<Long> m) {\n-        return super.fromByteArray0Template(Long64Mask.class, a, offset, (Long64Mask) m);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    LongVector fromByteBuffer0(ByteBuffer bb, int offset) {\n-        return super.fromByteBuffer0Template(bb, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    LongVector fromByteBuffer0(ByteBuffer bb, int offset, VectorMask<Long> m) {\n-        return super.fromByteBuffer0Template(Long64Mask.class, bb, offset, (Long64Mask) m);  \/\/ specialize\n+    LongVector fromMemorySegment0(MemorySegment ms, long offset, VectorMask<Long> m) {\n+        return super.fromMemorySegment0Template(Long64Mask.class, ms, offset, (Long64Mask) m);  \/\/ specialize\n@@ -882,16 +893,2 @@\n-    void intoByteArray0(byte[] a, int offset) {\n-        super.intoByteArray0Template(a, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoByteArray0(byte[] a, int offset, VectorMask<Long> m) {\n-        super.intoByteArray0Template(Long64Mask.class, a, offset, (Long64Mask) m);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoByteBuffer0(ByteBuffer bb, int offset, VectorMask<Long> m) {\n-        super.intoByteBuffer0Template(Long64Mask.class, bb, offset, (Long64Mask) m);\n+    void intoMemorySegment0(MemorySegment ms, long offset, VectorMask<Long> m) {\n+        super.intoMemorySegment0Template(Long64Mask.class, ms, offset, (Long64Mask) m);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long64Vector.java","additions":32,"deletions":35,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import java.nio.ByteBuffer;\n@@ -32,0 +31,1 @@\n+import jdk.incubator.foreign.MemorySegment;\n@@ -467,0 +467,16 @@\n+    @Override\n+    @ForceInline\n+    public LongMaxVector compress(VectorMask<Long> m) {\n+        return (LongMaxVector)\n+            super.compressTemplate(LongMaxMask.class,\n+                                   (LongMaxMask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public LongMaxVector expand(VectorMask<Long> m) {\n+        return (LongMaxVector)\n+            super.expandTemplate(LongMaxMask.class,\n+                                   (LongMaxMask) m);  \/\/ specialize\n+    }\n+\n@@ -640,0 +656,9 @@\n+        @Override\n+        @ForceInline\n+        public LongMaxMask compress() {\n+            return (LongMaxMask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n+                LongMaxVector.class, LongMaxMask.class, ETYPE, VLENGTH, null, this,\n+                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));\n+        }\n+\n+\n@@ -832,2 +857,2 @@\n-    LongVector fromByteArray0(byte[] a, int offset) {\n-        return super.fromByteArray0Template(a, offset);  \/\/ specialize\n+    LongVector fromMemorySegment0(MemorySegment ms, long offset) {\n+        return super.fromMemorySegment0Template(ms, offset);  \/\/ specialize\n@@ -839,16 +864,2 @@\n-    LongVector fromByteArray0(byte[] a, int offset, VectorMask<Long> m) {\n-        return super.fromByteArray0Template(LongMaxMask.class, a, offset, (LongMaxMask) m);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    LongVector fromByteBuffer0(ByteBuffer bb, int offset) {\n-        return super.fromByteBuffer0Template(bb, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    LongVector fromByteBuffer0(ByteBuffer bb, int offset, VectorMask<Long> m) {\n-        return super.fromByteBuffer0Template(LongMaxMask.class, bb, offset, (LongMaxMask) m);  \/\/ specialize\n+    LongVector fromMemorySegment0(MemorySegment ms, long offset, VectorMask<Long> m) {\n+        return super.fromMemorySegment0Template(LongMaxMask.class, ms, offset, (LongMaxMask) m);  \/\/ specialize\n@@ -882,16 +893,2 @@\n-    void intoByteArray0(byte[] a, int offset) {\n-        super.intoByteArray0Template(a, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoByteArray0(byte[] a, int offset, VectorMask<Long> m) {\n-        super.intoByteArray0Template(LongMaxMask.class, a, offset, (LongMaxMask) m);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoByteBuffer0(ByteBuffer bb, int offset, VectorMask<Long> m) {\n-        super.intoByteBuffer0Template(LongMaxMask.class, bb, offset, (LongMaxMask) m);\n+    void intoMemorySegment0(MemorySegment ms, long offset, VectorMask<Long> m) {\n+        super.intoMemorySegment0Template(LongMaxMask.class, ms, offset, (LongMaxMask) m);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/LongMaxVector.java","additions":32,"deletions":35,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import java.nio.ByteBuffer;\n@@ -29,1 +28,0 @@\n-import java.nio.ReadOnlyBufferException;\n@@ -33,1 +31,0 @@\n-import java.util.function.UnaryOperator;\n@@ -35,0 +32,3 @@\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ValueLayout;\n+import jdk.internal.access.foreign.MemorySegmentProxy;\n@@ -60,0 +60,2 @@\n+    static final ValueLayout.OfLong ELEMENT_LAYOUT = ValueLayout.JAVA_LONG.withBitAlignment(8);\n+\n@@ -354,0 +356,39 @@\n+    \/*package-private*\/\n+    interface FLdLongOp {\n+        long apply(MemorySegment memory, long offset, int i);\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    LongVector ldLongOp(MemorySegment memory, long offset,\n+                                  FLdLongOp f) {\n+        \/\/dummy; no vec = vec();\n+        long[] res = new long[length()];\n+        for (int i = 0; i < res.length; i++) {\n+            res[i] = f.apply(memory, offset, i);\n+        }\n+        return vectorFactory(res);\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    LongVector ldLongOp(MemorySegment memory, long offset,\n+                                  VectorMask<Long> m,\n+                                  FLdLongOp f) {\n+        \/\/long[] vec = vec();\n+        long[] res = new long[length()];\n+        boolean[] mbits = ((AbstractMask<Long>)m).getBits();\n+        for (int i = 0; i < res.length; i++) {\n+            if (mbits[i]) {\n+                res[i] = f.apply(memory, offset, i);\n+            }\n+        }\n+        return vectorFactory(res);\n+    }\n+\n+    static long memorySegmentGet(MemorySegment ms, long o, int i) {\n+        return ms.get(ELEMENT_LAYOUT, o + i * 8L);\n+    }\n+\n@@ -384,0 +425,34 @@\n+    interface FStLongOp {\n+        void apply(MemorySegment memory, long offset, int i, long a);\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    void stLongOp(MemorySegment memory, long offset,\n+                  FStLongOp f) {\n+        long[] vec = vec();\n+        for (int i = 0; i < vec.length; i++) {\n+            f.apply(memory, offset, i, vec[i]);\n+        }\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    void stLongOp(MemorySegment memory, long offset,\n+                  VectorMask<Long> m,\n+                  FStLongOp f) {\n+        long[] vec = vec();\n+        boolean[] mbits = ((AbstractMask<Long>)m).getBits();\n+        for (int i = 0; i < vec.length; i++) {\n+            if (mbits[i]) {\n+                f.apply(memory, offset, i, vec[i]);\n+            }\n+        }\n+    }\n+\n+    static void memorySegmentSet(MemorySegment ms, long o, int i, long e) {\n+        ms.set(ELEMENT_LAYOUT, o + i * 8L, e);\n+    }\n+\n@@ -434,0 +509,30 @@\n+    static LongVector expandHelper(Vector<Long> v, VectorMask<Long> m) {\n+        VectorSpecies<Long> vsp = m.vectorSpecies();\n+        LongVector r  = (LongVector) vsp.zero();\n+        LongVector vi = (LongVector) v;\n+        if (m.allTrue()) {\n+            return vi;\n+        }\n+        for (int i = 0, j = 0; i < vsp.length(); i++) {\n+            if (m.laneIsSet(i)) {\n+                r = r.withLane(i, vi.lane(j++));\n+            }\n+        }\n+        return r;\n+    }\n+\n+    static LongVector compressHelper(Vector<Long> v, VectorMask<Long> m) {\n+        VectorSpecies<Long> vsp = m.vectorSpecies();\n+        LongVector r  = (LongVector) vsp.zero();\n+        LongVector vi = (LongVector) v;\n+        if (m.allTrue()) {\n+            return vi;\n+        }\n+        for (int i = 0, j = 0; i < vsp.length(); i++) {\n+            if (m.laneIsSet(i)) {\n+                r = r.withLane(j++, vi.lane(i));\n+            }\n+        }\n+        return r;\n+    }\n+\n@@ -581,0 +686,10 @@\n+            case VECTOR_OP_BIT_COUNT: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> (long) Long.bitCount(a));\n+            case VECTOR_OP_TZ_COUNT: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> (long) Long.numberOfTrailingZeros(a));\n+            case VECTOR_OP_LZ_COUNT: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> (long) Long.numberOfLeadingZeros(a));\n+            case VECTOR_OP_REVERSE: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> (long) Long.reverse(a));\n+            case VECTOR_OP_REVERSE_BYTES: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> (long) Long.reverseBytes(a));\n@@ -721,0 +836,4 @@\n+            case VECTOR_OP_COMPRESS_BITS: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, n) -> Long.compress(a, n));\n+            case VECTOR_OP_EXPAND_BITS: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, n) -> Long.expand(a, n));\n@@ -1661,0 +1780,1 @@\n+\n@@ -2240,0 +2360,39 @@\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     * @since 19\n+     *\/\n+    @Override\n+    public abstract\n+    LongVector compress(VectorMask<Long> m);\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M extends AbstractMask<Long>>\n+    LongVector compressTemplate(Class<M> masktype, M m) {\n+      m.check(masktype, this);\n+      return (LongVector) VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_COMPRESS, getClass(), masktype,\n+                                                        long.class, length(), this, m,\n+                                                        (v1, m1) -> compressHelper(v1, m1));\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     * @since 19\n+     *\/\n+    @Override\n+    public abstract\n+    LongVector expand(VectorMask<Long> m);\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M extends AbstractMask<Long>>\n+    LongVector expandTemplate(Class<M> masktype, M m) {\n+      m.check(masktype, this);\n+      return (LongVector) VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_EXPAND, getClass(), masktype,\n+                                                        long.class, length(), this, m,\n+                                                        (v1, m1) -> expandHelper(v1, m1));\n+    }\n+\n+\n@@ -2640,84 +2799,0 @@\n-    \/**\n-     * Loads a vector from a byte array starting at an offset.\n-     * Bytes are composed into primitive lane elements according\n-     * to the specified byte order.\n-     * The vector is arranged into lanes according to\n-     * <a href=\"Vector.html#lane-order\">memory ordering<\/a>.\n-     * <p>\n-     * This method behaves as if it returns the result of calling\n-     * {@link #fromByteBuffer(VectorSpecies,ByteBuffer,int,ByteOrder,VectorMask)\n-     * fromByteBuffer()} as follows:\n-     * <pre>{@code\n-     * var bb = ByteBuffer.wrap(a);\n-     * var m = species.maskAll(true);\n-     * return fromByteBuffer(species, bb, offset, bo, m);\n-     * }<\/pre>\n-     *\n-     * @param species species of desired vector\n-     * @param a the byte array\n-     * @param offset the offset into the array\n-     * @param bo the intended byte order\n-     * @return a vector loaded from a byte array\n-     * @throws IndexOutOfBoundsException\n-     *         if {@code offset+N*ESIZE < 0}\n-     *         or {@code offset+(N+1)*ESIZE > a.length}\n-     *         for any lane {@code N} in the vector\n-     *\/\n-    @ForceInline\n-    public static\n-    LongVector fromByteArray(VectorSpecies<Long> species,\n-                                       byte[] a, int offset,\n-                                       ByteOrder bo) {\n-        offset = checkFromIndexSize(offset, species.vectorByteSize(), a.length);\n-        LongSpecies vsp = (LongSpecies) species;\n-        return vsp.dummyVector().fromByteArray0(a, offset).maybeSwap(bo);\n-    }\n-\n-    \/**\n-     * Loads a vector from a byte array starting at an offset\n-     * and using a mask.\n-     * Lanes where the mask is unset are filled with the default\n-     * value of {@code long} (zero).\n-     * Bytes are composed into primitive lane elements according\n-     * to the specified byte order.\n-     * The vector is arranged into lanes according to\n-     * <a href=\"Vector.html#lane-order\">memory ordering<\/a>.\n-     * <p>\n-     * This method behaves as if it returns the result of calling\n-     * {@link #fromByteBuffer(VectorSpecies,ByteBuffer,int,ByteOrder,VectorMask)\n-     * fromByteBuffer()} as follows:\n-     * <pre>{@code\n-     * var bb = ByteBuffer.wrap(a);\n-     * return fromByteBuffer(species, bb, offset, bo, m);\n-     * }<\/pre>\n-     *\n-     * @param species species of desired vector\n-     * @param a the byte array\n-     * @param offset the offset into the array\n-     * @param bo the intended byte order\n-     * @param m the mask controlling lane selection\n-     * @return a vector loaded from a byte array\n-     * @throws IndexOutOfBoundsException\n-     *         if {@code offset+N*ESIZE < 0}\n-     *         or {@code offset+(N+1)*ESIZE > a.length}\n-     *         for any lane {@code N} in the vector\n-     *         where the mask is set\n-     *\/\n-    @ForceInline\n-    public static\n-    LongVector fromByteArray(VectorSpecies<Long> species,\n-                                       byte[] a, int offset,\n-                                       ByteOrder bo,\n-                                       VectorMask<Long> m) {\n-        LongSpecies vsp = (LongSpecies) species;\n-        if (offset >= 0 && offset <= (a.length - species.vectorByteSize())) {\n-            return vsp.dummyVector().fromByteArray0(a, offset, m).maybeSwap(bo);\n-        }\n-\n-        \/\/ FIXME: optimize\n-        checkMaskFromIndexSize(offset, vsp, m, 8, a.length);\n-        ByteBuffer wb = wrapper(a, bo);\n-        return vsp.ldOp(wb, offset, (AbstractMask<Long>)m,\n-                   (wb_, o, i)  -> wb_.getLong(o + i * 8));\n-    }\n-\n@@ -2914,2 +2989,2 @@\n-     * Loads a vector from a {@linkplain ByteBuffer byte buffer}\n-     * starting at an offset into the byte buffer.\n+     * Loads a vector from a {@linkplain MemorySegment memory segment}\n+     * starting at an offset into the memory segment.\n@@ -2922,2 +2997,2 @@\n-     * {@link #fromByteBuffer(VectorSpecies,ByteBuffer,int,ByteOrder,VectorMask)\n-     * fromByteBuffer()} as follows:\n+     * {@link #fromMemorySegment(VectorSpecies,MemorySegment,long,ByteOrder,VectorMask)\n+     * fromMemorySegment()} as follows:\n@@ -2926,1 +3001,1 @@\n-     * return fromByteBuffer(species, bb, offset, bo, m);\n+     * return fromMemorySegment(species, ms, offset, bo, m);\n@@ -2930,2 +3005,2 @@\n-     * @param bb the byte buffer\n-     * @param offset the offset into the byte buffer\n+     * @param ms the memory segment\n+     * @param offset the offset into the memory segment\n@@ -2933,1 +3008,1 @@\n-     * @return a vector loaded from a byte buffer\n+     * @return a vector loaded from the memory segment\n@@ -2936,1 +3011,1 @@\n-     *         or {@code offset+N*8 >= bb.limit()}\n+     *         or {@code offset+N*8 >= ms.byteSize()}\n@@ -2938,0 +3013,5 @@\n+     * @throws IllegalArgumentException if the memory segment is a heap segment that is\n+     *         not backed by a {@code byte[]} array.\n+     * @throws IllegalStateException if the memory segment's session is not alive,\n+     *         or if access occurs from a thread other than the thread owning the session.\n+     * @since 19\n@@ -2941,4 +3021,4 @@\n-    LongVector fromByteBuffer(VectorSpecies<Long> species,\n-                                        ByteBuffer bb, int offset,\n-                                        ByteOrder bo) {\n-        offset = checkFromIndexSize(offset, species.vectorByteSize(), bb.limit());\n+    LongVector fromMemorySegment(VectorSpecies<Long> species,\n+                                           MemorySegment ms, long offset,\n+                                           ByteOrder bo) {\n+        offset = checkFromIndexSize(offset, species.vectorByteSize(), ms.byteSize());\n@@ -2946,1 +3026,1 @@\n-        return vsp.dummyVector().fromByteBuffer0(bb, offset).maybeSwap(bo);\n+        return vsp.dummyVector().fromMemorySegment0(ms, offset).maybeSwap(bo);\n@@ -2950,2 +3030,2 @@\n-     * Loads a vector from a {@linkplain ByteBuffer byte buffer}\n-     * starting at an offset into the byte buffer\n+     * Loads a vector from a {@linkplain MemorySegment memory segment}\n+     * starting at an offset into the memory segment\n@@ -2962,3 +3042,1 @@\n-     * LongBuffer eb = bb.duplicate()\n-     *     .position(offset)\n-     *     .order(bo).asLongBuffer();\n+     * var slice = ms.asSlice(offset);\n@@ -2968,1 +3046,1 @@\n-     *         ar[n] = eb.get(n);\n+     *         ar[n] = slice.getAtIndex(ValuaLayout.JAVA_LONG.withBitAlignment(8), n);\n@@ -2982,2 +3060,2 @@\n-     * @param bb the byte buffer\n-     * @param offset the offset into the byte buffer\n+     * @param ms the memory segment\n+     * @param offset the offset into the memory segment\n@@ -2986,1 +3064,1 @@\n-     * @return a vector loaded from a byte buffer\n+     * @return a vector loaded from the memory segment\n@@ -2989,1 +3067,1 @@\n-     *         or {@code offset+N*8 >= bb.limit()}\n+     *         or {@code offset+N*8 >= ms.byteSize()}\n@@ -2992,0 +3070,5 @@\n+     * @throws IllegalArgumentException if the memory segment is a heap segment that is\n+     *         not backed by a {@code byte[]} array.\n+     * @throws IllegalStateException if the memory segment's session is not alive,\n+     *         or if access occurs from a thread other than the thread owning the session.\n+     * @since 19\n@@ -2995,4 +3078,4 @@\n-    LongVector fromByteBuffer(VectorSpecies<Long> species,\n-                                        ByteBuffer bb, int offset,\n-                                        ByteOrder bo,\n-                                        VectorMask<Long> m) {\n+    LongVector fromMemorySegment(VectorSpecies<Long> species,\n+                                           MemorySegment ms, long offset,\n+                                           ByteOrder bo,\n+                                           VectorMask<Long> m) {\n@@ -3000,2 +3083,2 @@\n-        if (offset >= 0 && offset <= (bb.limit() - species.vectorByteSize())) {\n-            return vsp.dummyVector().fromByteBuffer0(bb, offset, m).maybeSwap(bo);\n+        if (offset >= 0 && offset <= (ms.byteSize() - species.vectorByteSize())) {\n+            return vsp.dummyVector().fromMemorySegment0(ms, offset, m).maybeSwap(bo);\n@@ -3005,4 +3088,2 @@\n-        checkMaskFromIndexSize(offset, vsp, m, 8, bb.limit());\n-        ByteBuffer wb = wrapper(bb, bo);\n-        return vsp.ldOp(wb, offset, (AbstractMask<Long>)m,\n-                   (wb_, o, i)  -> wb_.getLong(o + i * 8));\n+        checkMaskFromIndexSize(offset, vsp, m, 8, ms.byteSize());\n+        return vsp.ldLongOp(ms, offset, m, LongVector::memorySegmentGet);\n@@ -3038,1 +3119,1 @@\n-            -> v.stOp(arr, off,\n+            -> v.stOp(arr, (int) off,\n@@ -3198,0 +3279,1 @@\n+     * @since 19\n@@ -3202,21 +3284,4 @@\n-    void intoByteArray(byte[] a, int offset,\n-                       ByteOrder bo) {\n-        offset = checkFromIndexSize(offset, byteSize(), a.length);\n-        maybeSwap(bo).intoByteArray0(a, offset);\n-    }\n-\n-    \/**\n-     * {@inheritDoc} <!--workaround-->\n-     *\/\n-    @Override\n-    @ForceInline\n-    public final\n-    void intoByteArray(byte[] a, int offset,\n-                       ByteOrder bo,\n-                       VectorMask<Long> m) {\n-        if (m.allTrue()) {\n-            intoByteArray(a, offset, bo);\n-        } else {\n-            LongSpecies vsp = vspecies();\n-            checkMaskFromIndexSize(offset, vsp, m, 8, a.length);\n-            maybeSwap(bo).intoByteArray0(a, offset, m);\n+    void intoMemorySegment(MemorySegment ms, long offset,\n+                           ByteOrder bo) {\n+        if (ms.isReadOnly()) {\n+            throw new UnsupportedOperationException(\"Attempt to write a read-only segment\");\n@@ -3224,1 +3289,0 @@\n-    }\n@@ -3226,13 +3290,2 @@\n-    \/**\n-     * {@inheritDoc} <!--workaround-->\n-     *\/\n-    @Override\n-    @ForceInline\n-    public final\n-    void intoByteBuffer(ByteBuffer bb, int offset,\n-                        ByteOrder bo) {\n-        if (ScopedMemoryAccess.isReadOnly(bb)) {\n-            throw new ReadOnlyBufferException();\n-        }\n-        offset = checkFromIndexSize(offset, byteSize(), bb.limit());\n-        maybeSwap(bo).intoByteBuffer0(bb, offset);\n+        offset = checkFromIndexSize(offset, byteSize(), ms.byteSize());\n+        maybeSwap(bo).intoMemorySegment0(ms, offset);\n@@ -3243,0 +3296,1 @@\n+     * @since 19\n@@ -3247,3 +3301,3 @@\n-    void intoByteBuffer(ByteBuffer bb, int offset,\n-                        ByteOrder bo,\n-                        VectorMask<Long> m) {\n+    void intoMemorySegment(MemorySegment ms, long offset,\n+                           ByteOrder bo,\n+                           VectorMask<Long> m) {\n@@ -3251,1 +3305,1 @@\n-            intoByteBuffer(bb, offset, bo);\n+            intoMemorySegment(ms, offset, bo);\n@@ -3253,2 +3307,2 @@\n-            if (bb.isReadOnly()) {\n-                throw new ReadOnlyBufferException();\n+            if (ms.isReadOnly()) {\n+                throw new UnsupportedOperationException(\"Attempt to write a read-only segment\");\n@@ -3257,2 +3311,2 @@\n-            checkMaskFromIndexSize(offset, vsp, m, 8, bb.limit());\n-            maybeSwap(bo).intoByteBuffer0(bb, offset, m);\n+            checkMaskFromIndexSize(offset, vsp, m, 8, ms.byteSize());\n+            maybeSwap(bo).intoMemorySegment0(ms, offset, m);\n@@ -3292,1 +3346,1 @@\n-            (arr, off, s) -> s.ldOp(arr, off,\n+            (arr, off, s) -> s.ldOp(arr, (int) off,\n@@ -3309,1 +3363,1 @@\n-            (arr, off, s, vm) -> s.ldOp(arr, off, vm,\n+            (arr, off, s, vm) -> s.ldOp(arr, (int) off, vm,\n@@ -3367,1 +3421,0 @@\n-    @Override\n@@ -3369,1 +3422,1 @@\n-    LongVector fromByteArray0(byte[] a, int offset);\n+    LongVector fromMemorySegment0(MemorySegment bb, long offset);\n@@ -3372,1 +3425,1 @@\n-    LongVector fromByteArray0Template(byte[] a, int offset) {\n+    LongVector fromMemorySegment0Template(MemorySegment ms, long offset) {\n@@ -3374,37 +3427,1 @@\n-        return VectorSupport.load(\n-            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n-            a, byteArrayAddress(a, offset),\n-            a, offset, vsp,\n-            (arr, off, s) -> {\n-                ByteBuffer wb = wrapper(arr, NATIVE_ENDIAN);\n-                return s.ldOp(wb, off,\n-                        (wb_, o, i) -> wb_.getLong(o + i * 8));\n-            });\n-    }\n-\n-    abstract\n-    LongVector fromByteArray0(byte[] a, int offset, VectorMask<Long> m);\n-    @ForceInline\n-    final\n-    <M extends VectorMask<Long>>\n-    LongVector fromByteArray0Template(Class<M> maskClass, byte[] a, int offset, M m) {\n-        LongSpecies vsp = vspecies();\n-        m.check(vsp);\n-        return VectorSupport.loadMasked(\n-            vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n-            a, byteArrayAddress(a, offset), m,\n-            a, offset, vsp,\n-            (arr, off, s, vm) -> {\n-                ByteBuffer wb = wrapper(arr, NATIVE_ENDIAN);\n-                return s.ldOp(wb, off, vm,\n-                        (wb_, o, i) -> wb_.getLong(o + i * 8));\n-            });\n-    }\n-\n-    abstract\n-    LongVector fromByteBuffer0(ByteBuffer bb, int offset);\n-    @ForceInline\n-    final\n-    LongVector fromByteBuffer0Template(ByteBuffer bb, int offset) {\n-        LongSpecies vsp = vspecies();\n-        return ScopedMemoryAccess.loadFromByteBuffer(\n+        return ScopedMemoryAccess.loadFromMemorySegment(\n@@ -3412,5 +3429,3 @@\n-                bb, offset, vsp,\n-                (buf, off, s) -> {\n-                    ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n-                    return s.ldOp(wb, off,\n-                            (wb_, o, i) -> wb_.getLong(o + i * 8));\n+                (MemorySegmentProxy) ms, offset, vsp,\n+                (msp, off, s) -> {\n+                    return s.ldLongOp((MemorySegment) msp, off, LongVector::memorySegmentGet);\n@@ -3421,1 +3436,1 @@\n-    LongVector fromByteBuffer0(ByteBuffer bb, int offset, VectorMask<Long> m);\n+    LongVector fromMemorySegment0(MemorySegment ms, long offset, VectorMask<Long> m);\n@@ -3425,1 +3440,1 @@\n-    LongVector fromByteBuffer0Template(Class<M> maskClass, ByteBuffer bb, int offset, M m) {\n+    LongVector fromMemorySegment0Template(Class<M> maskClass, MemorySegment ms, long offset, M m) {\n@@ -3428,1 +3443,1 @@\n-        return ScopedMemoryAccess.loadFromByteBufferMasked(\n+        return ScopedMemoryAccess.loadFromMemorySegmentMasked(\n@@ -3430,5 +3445,3 @@\n-                bb, offset, m, vsp,\n-                (buf, off, s, vm) -> {\n-                    ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n-                    return s.ldOp(wb, off, vm,\n-                            (wb_, o, i) -> wb_.getLong(o + i * 8));\n+                (MemorySegmentProxy) ms, offset, m, vsp,\n+                (msp, off, s, vm) -> {\n+                    return s.ldLongOp((MemorySegment) msp, off, vm, LongVector::memorySegmentGet);\n@@ -3453,1 +3466,1 @@\n-            -> v.stOp(arr, off,\n+            -> v.stOp(arr, (int) off,\n@@ -3470,1 +3483,1 @@\n-            -> v.stOp(arr, off, vm,\n+            -> v.stOp(arr, (int) off, vm,\n@@ -3528,19 +3541,0 @@\n-    abstract\n-    void intoByteArray0(byte[] a, int offset);\n-    @ForceInline\n-    final\n-    void intoByteArray0Template(byte[] a, int offset) {\n-        LongSpecies vsp = vspecies();\n-        VectorSupport.store(\n-            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n-            a, byteArrayAddress(a, offset),\n-            this, a, offset,\n-            (arr, off, v) -> {\n-                ByteBuffer wb = wrapper(arr, NATIVE_ENDIAN);\n-                v.stOp(wb, off,\n-                        (tb_, o, i, e) -> tb_.putLong(o + i * 8, e));\n-            });\n-    }\n-\n-    abstract\n-    void intoByteArray0(byte[] a, int offset, VectorMask<Long> m);\n@@ -3549,2 +3543,1 @@\n-    <M extends VectorMask<Long>>\n-    void intoByteArray0Template(Class<M> maskClass, byte[] a, int offset, M m) {\n+    void intoMemorySegment0(MemorySegment ms, long offset) {\n@@ -3552,17 +3545,1 @@\n-        m.check(vsp);\n-        VectorSupport.storeMasked(\n-            vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n-            a, byteArrayAddress(a, offset),\n-            this, m, a, offset,\n-            (arr, off, v, vm) -> {\n-                ByteBuffer wb = wrapper(arr, NATIVE_ENDIAN);\n-                v.stOp(wb, off, vm,\n-                        (tb_, o, i, e) -> tb_.putLong(o + i * 8, e));\n-            });\n-    }\n-\n-    @ForceInline\n-    final\n-    void intoByteBuffer0(ByteBuffer bb, int offset) {\n-        LongSpecies vsp = vspecies();\n-        ScopedMemoryAccess.storeIntoByteBuffer(\n+        ScopedMemoryAccess.storeIntoMemorySegment(\n@@ -3570,5 +3547,4 @@\n-                this, bb, offset,\n-                (buf, off, v) -> {\n-                    ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n-                    v.stOp(wb, off,\n-                            (wb_, o, i, e) -> wb_.putLong(o + i * 8, e));\n+                this,\n+                (MemorySegmentProxy) ms, offset,\n+                (msp, off, v) -> {\n+                    v.stLongOp((MemorySegment) msp, off, LongVector::memorySegmentSet);\n@@ -3579,1 +3555,1 @@\n-    void intoByteBuffer0(ByteBuffer bb, int offset, VectorMask<Long> m);\n+    void intoMemorySegment0(MemorySegment bb, long offset, VectorMask<Long> m);\n@@ -3583,1 +3559,1 @@\n-    void intoByteBuffer0Template(Class<M> maskClass, ByteBuffer bb, int offset, M m) {\n+    void intoMemorySegment0Template(Class<M> maskClass, MemorySegment ms, long offset, M m) {\n@@ -3586,1 +3562,1 @@\n-        ScopedMemoryAccess.storeIntoByteBufferMasked(\n+        ScopedMemoryAccess.storeIntoMemorySegmentMasked(\n@@ -3588,5 +3564,4 @@\n-                this, m, bb, offset,\n-                (buf, off, v, vm) -> {\n-                    ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n-                    v.stOp(wb, off, vm,\n-                            (wb_, o, i, e) -> wb_.putLong(o + i * 8, e));\n+                this, m,\n+                (MemorySegmentProxy) ms, offset,\n+                (msp, off, v, vm) -> {\n+                    v.stLongOp((MemorySegment) msp, off, vm, LongVector::memorySegmentSet);\n@@ -3609,0 +3584,10 @@\n+    private static\n+    void checkMaskFromIndexSize(long offset,\n+                                LongSpecies vsp,\n+                                VectorMask<Long> m,\n+                                int scale,\n+                                long limit) {\n+        ((AbstractMask<Long>)m)\n+            .checkIndexByLane(offset, limit, vsp.iota(), scale);\n+    }\n+\n@@ -3910,0 +3895,15 @@\n+        \/*package-private*\/\n+        @ForceInline\n+        LongVector ldLongOp(MemorySegment memory, long offset,\n+                                      FLdLongOp f) {\n+            return dummyVector().ldLongOp(memory, offset, f);\n+        }\n+\n+        \/*package-private*\/\n+        @ForceInline\n+        LongVector ldLongOp(MemorySegment memory, long offset,\n+                                      VectorMask<Long> m,\n+                                      FLdLongOp f) {\n+            return dummyVector().ldLongOp(memory, offset, m, f);\n+        }\n+\n@@ -3924,0 +3924,14 @@\n+        \/*package-private*\/\n+        @ForceInline\n+        void stLongOp(MemorySegment memory, long offset, FStLongOp f) {\n+            dummyVector().stLongOp(memory, offset, f);\n+        }\n+\n+        \/*package-private*\/\n+        @ForceInline\n+        void stLongOp(MemorySegment memory, long offset,\n+                      AbstractMask<Long> m,\n+                      FStLongOp f) {\n+            dummyVector().stLongOp(memory, offset, m, f);\n+        }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/LongVector.java","additions":287,"deletions":273,"binary":false,"changes":560,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import java.nio.ByteBuffer;\n@@ -32,0 +31,1 @@\n+import jdk.incubator.foreign.MemorySegment;\n@@ -477,0 +477,16 @@\n+    @Override\n+    @ForceInline\n+    public Short128Vector compress(VectorMask<Short> m) {\n+        return (Short128Vector)\n+            super.compressTemplate(Short128Mask.class,\n+                                   (Short128Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Short128Vector expand(VectorMask<Short> m) {\n+        return (Short128Vector)\n+            super.expandTemplate(Short128Mask.class,\n+                                   (Short128Mask) m);  \/\/ specialize\n+    }\n+\n@@ -664,0 +680,9 @@\n+        @Override\n+        @ForceInline\n+        public Short128Mask compress() {\n+            return (Short128Mask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n+                Short128Vector.class, Short128Mask.class, ETYPE, VLENGTH, null, this,\n+                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));\n+        }\n+\n+\n@@ -863,2 +888,2 @@\n-    ShortVector fromByteArray0(byte[] a, int offset) {\n-        return super.fromByteArray0Template(a, offset);  \/\/ specialize\n+    ShortVector fromMemorySegment0(MemorySegment ms, long offset) {\n+        return super.fromMemorySegment0Template(ms, offset);  \/\/ specialize\n@@ -870,16 +895,2 @@\n-    ShortVector fromByteArray0(byte[] a, int offset, VectorMask<Short> m) {\n-        return super.fromByteArray0Template(Short128Mask.class, a, offset, (Short128Mask) m);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    ShortVector fromByteBuffer0(ByteBuffer bb, int offset) {\n-        return super.fromByteBuffer0Template(bb, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    ShortVector fromByteBuffer0(ByteBuffer bb, int offset, VectorMask<Short> m) {\n-        return super.fromByteBuffer0Template(Short128Mask.class, bb, offset, (Short128Mask) m);  \/\/ specialize\n+    ShortVector fromMemorySegment0(MemorySegment ms, long offset, VectorMask<Short> m) {\n+        return super.fromMemorySegment0Template(Short128Mask.class, ms, offset, (Short128Mask) m);  \/\/ specialize\n@@ -907,16 +918,2 @@\n-    void intoByteArray0(byte[] a, int offset) {\n-        super.intoByteArray0Template(a, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoByteArray0(byte[] a, int offset, VectorMask<Short> m) {\n-        super.intoByteArray0Template(Short128Mask.class, a, offset, (Short128Mask) m);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoByteBuffer0(ByteBuffer bb, int offset, VectorMask<Short> m) {\n-        super.intoByteBuffer0Template(Short128Mask.class, bb, offset, (Short128Mask) m);\n+    void intoMemorySegment0(MemorySegment ms, long offset, VectorMask<Short> m) {\n+        super.intoMemorySegment0Template(Short128Mask.class, ms, offset, (Short128Mask) m);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short128Vector.java","additions":32,"deletions":35,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import java.nio.ByteBuffer;\n@@ -32,0 +31,1 @@\n+import jdk.incubator.foreign.MemorySegment;\n@@ -477,0 +477,16 @@\n+    @Override\n+    @ForceInline\n+    public Short256Vector compress(VectorMask<Short> m) {\n+        return (Short256Vector)\n+            super.compressTemplate(Short256Mask.class,\n+                                   (Short256Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Short256Vector expand(VectorMask<Short> m) {\n+        return (Short256Vector)\n+            super.expandTemplate(Short256Mask.class,\n+                                   (Short256Mask) m);  \/\/ specialize\n+    }\n+\n@@ -680,0 +696,9 @@\n+        @Override\n+        @ForceInline\n+        public Short256Mask compress() {\n+            return (Short256Mask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n+                Short256Vector.class, Short256Mask.class, ETYPE, VLENGTH, null, this,\n+                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));\n+        }\n+\n+\n@@ -879,2 +904,2 @@\n-    ShortVector fromByteArray0(byte[] a, int offset) {\n-        return super.fromByteArray0Template(a, offset);  \/\/ specialize\n+    ShortVector fromMemorySegment0(MemorySegment ms, long offset) {\n+        return super.fromMemorySegment0Template(ms, offset);  \/\/ specialize\n@@ -886,16 +911,2 @@\n-    ShortVector fromByteArray0(byte[] a, int offset, VectorMask<Short> m) {\n-        return super.fromByteArray0Template(Short256Mask.class, a, offset, (Short256Mask) m);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    ShortVector fromByteBuffer0(ByteBuffer bb, int offset) {\n-        return super.fromByteBuffer0Template(bb, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    ShortVector fromByteBuffer0(ByteBuffer bb, int offset, VectorMask<Short> m) {\n-        return super.fromByteBuffer0Template(Short256Mask.class, bb, offset, (Short256Mask) m);  \/\/ specialize\n+    ShortVector fromMemorySegment0(MemorySegment ms, long offset, VectorMask<Short> m) {\n+        return super.fromMemorySegment0Template(Short256Mask.class, ms, offset, (Short256Mask) m);  \/\/ specialize\n@@ -923,16 +934,2 @@\n-    void intoByteArray0(byte[] a, int offset) {\n-        super.intoByteArray0Template(a, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoByteArray0(byte[] a, int offset, VectorMask<Short> m) {\n-        super.intoByteArray0Template(Short256Mask.class, a, offset, (Short256Mask) m);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoByteBuffer0(ByteBuffer bb, int offset, VectorMask<Short> m) {\n-        super.intoByteBuffer0Template(Short256Mask.class, bb, offset, (Short256Mask) m);\n+    void intoMemorySegment0(MemorySegment ms, long offset, VectorMask<Short> m) {\n+        super.intoMemorySegment0Template(Short256Mask.class, ms, offset, (Short256Mask) m);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short256Vector.java","additions":32,"deletions":35,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import java.nio.ByteBuffer;\n@@ -32,0 +31,1 @@\n+import jdk.incubator.foreign.MemorySegment;\n@@ -477,0 +477,16 @@\n+    @Override\n+    @ForceInline\n+    public Short512Vector compress(VectorMask<Short> m) {\n+        return (Short512Vector)\n+            super.compressTemplate(Short512Mask.class,\n+                                   (Short512Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Short512Vector expand(VectorMask<Short> m) {\n+        return (Short512Vector)\n+            super.expandTemplate(Short512Mask.class,\n+                                   (Short512Mask) m);  \/\/ specialize\n+    }\n+\n@@ -712,0 +728,9 @@\n+        @Override\n+        @ForceInline\n+        public Short512Mask compress() {\n+            return (Short512Mask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n+                Short512Vector.class, Short512Mask.class, ETYPE, VLENGTH, null, this,\n+                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));\n+        }\n+\n+\n@@ -911,2 +936,2 @@\n-    ShortVector fromByteArray0(byte[] a, int offset) {\n-        return super.fromByteArray0Template(a, offset);  \/\/ specialize\n+    ShortVector fromMemorySegment0(MemorySegment ms, long offset) {\n+        return super.fromMemorySegment0Template(ms, offset);  \/\/ specialize\n@@ -918,16 +943,2 @@\n-    ShortVector fromByteArray0(byte[] a, int offset, VectorMask<Short> m) {\n-        return super.fromByteArray0Template(Short512Mask.class, a, offset, (Short512Mask) m);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    ShortVector fromByteBuffer0(ByteBuffer bb, int offset) {\n-        return super.fromByteBuffer0Template(bb, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    ShortVector fromByteBuffer0(ByteBuffer bb, int offset, VectorMask<Short> m) {\n-        return super.fromByteBuffer0Template(Short512Mask.class, bb, offset, (Short512Mask) m);  \/\/ specialize\n+    ShortVector fromMemorySegment0(MemorySegment ms, long offset, VectorMask<Short> m) {\n+        return super.fromMemorySegment0Template(Short512Mask.class, ms, offset, (Short512Mask) m);  \/\/ specialize\n@@ -955,16 +966,2 @@\n-    void intoByteArray0(byte[] a, int offset) {\n-        super.intoByteArray0Template(a, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoByteArray0(byte[] a, int offset, VectorMask<Short> m) {\n-        super.intoByteArray0Template(Short512Mask.class, a, offset, (Short512Mask) m);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoByteBuffer0(ByteBuffer bb, int offset, VectorMask<Short> m) {\n-        super.intoByteBuffer0Template(Short512Mask.class, bb, offset, (Short512Mask) m);\n+    void intoMemorySegment0(MemorySegment ms, long offset, VectorMask<Short> m) {\n+        super.intoMemorySegment0Template(Short512Mask.class, ms, offset, (Short512Mask) m);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short512Vector.java","additions":32,"deletions":35,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import java.nio.ByteBuffer;\n@@ -32,0 +31,1 @@\n+import jdk.incubator.foreign.MemorySegment;\n@@ -477,0 +477,16 @@\n+    @Override\n+    @ForceInline\n+    public Short64Vector compress(VectorMask<Short> m) {\n+        return (Short64Vector)\n+            super.compressTemplate(Short64Mask.class,\n+                                   (Short64Mask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Short64Vector expand(VectorMask<Short> m) {\n+        return (Short64Vector)\n+            super.expandTemplate(Short64Mask.class,\n+                                   (Short64Mask) m);  \/\/ specialize\n+    }\n+\n@@ -656,0 +672,9 @@\n+        @Override\n+        @ForceInline\n+        public Short64Mask compress() {\n+            return (Short64Mask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n+                Short64Vector.class, Short64Mask.class, ETYPE, VLENGTH, null, this,\n+                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));\n+        }\n+\n+\n@@ -855,2 +880,2 @@\n-    ShortVector fromByteArray0(byte[] a, int offset) {\n-        return super.fromByteArray0Template(a, offset);  \/\/ specialize\n+    ShortVector fromMemorySegment0(MemorySegment ms, long offset) {\n+        return super.fromMemorySegment0Template(ms, offset);  \/\/ specialize\n@@ -862,16 +887,2 @@\n-    ShortVector fromByteArray0(byte[] a, int offset, VectorMask<Short> m) {\n-        return super.fromByteArray0Template(Short64Mask.class, a, offset, (Short64Mask) m);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    ShortVector fromByteBuffer0(ByteBuffer bb, int offset) {\n-        return super.fromByteBuffer0Template(bb, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    ShortVector fromByteBuffer0(ByteBuffer bb, int offset, VectorMask<Short> m) {\n-        return super.fromByteBuffer0Template(Short64Mask.class, bb, offset, (Short64Mask) m);  \/\/ specialize\n+    ShortVector fromMemorySegment0(MemorySegment ms, long offset, VectorMask<Short> m) {\n+        return super.fromMemorySegment0Template(Short64Mask.class, ms, offset, (Short64Mask) m);  \/\/ specialize\n@@ -899,16 +910,2 @@\n-    void intoByteArray0(byte[] a, int offset) {\n-        super.intoByteArray0Template(a, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoByteArray0(byte[] a, int offset, VectorMask<Short> m) {\n-        super.intoByteArray0Template(Short64Mask.class, a, offset, (Short64Mask) m);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoByteBuffer0(ByteBuffer bb, int offset, VectorMask<Short> m) {\n-        super.intoByteBuffer0Template(Short64Mask.class, bb, offset, (Short64Mask) m);\n+    void intoMemorySegment0(MemorySegment ms, long offset, VectorMask<Short> m) {\n+        super.intoMemorySegment0Template(Short64Mask.class, ms, offset, (Short64Mask) m);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short64Vector.java","additions":32,"deletions":35,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import java.nio.ByteBuffer;\n@@ -32,0 +31,1 @@\n+import jdk.incubator.foreign.MemorySegment;\n@@ -477,0 +477,16 @@\n+    @Override\n+    @ForceInline\n+    public ShortMaxVector compress(VectorMask<Short> m) {\n+        return (ShortMaxVector)\n+            super.compressTemplate(ShortMaxMask.class,\n+                                   (ShortMaxMask) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public ShortMaxVector expand(VectorMask<Short> m) {\n+        return (ShortMaxVector)\n+            super.expandTemplate(ShortMaxMask.class,\n+                                   (ShortMaxMask) m);  \/\/ specialize\n+    }\n+\n@@ -650,0 +666,9 @@\n+        @Override\n+        @ForceInline\n+        public ShortMaxMask compress() {\n+            return (ShortMaxMask)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n+                ShortMaxVector.class, ShortMaxMask.class, ETYPE, VLENGTH, null, this,\n+                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));\n+        }\n+\n+\n@@ -849,2 +874,2 @@\n-    ShortVector fromByteArray0(byte[] a, int offset) {\n-        return super.fromByteArray0Template(a, offset);  \/\/ specialize\n+    ShortVector fromMemorySegment0(MemorySegment ms, long offset) {\n+        return super.fromMemorySegment0Template(ms, offset);  \/\/ specialize\n@@ -856,16 +881,2 @@\n-    ShortVector fromByteArray0(byte[] a, int offset, VectorMask<Short> m) {\n-        return super.fromByteArray0Template(ShortMaxMask.class, a, offset, (ShortMaxMask) m);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    ShortVector fromByteBuffer0(ByteBuffer bb, int offset) {\n-        return super.fromByteBuffer0Template(bb, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    ShortVector fromByteBuffer0(ByteBuffer bb, int offset, VectorMask<Short> m) {\n-        return super.fromByteBuffer0Template(ShortMaxMask.class, bb, offset, (ShortMaxMask) m);  \/\/ specialize\n+    ShortVector fromMemorySegment0(MemorySegment ms, long offset, VectorMask<Short> m) {\n+        return super.fromMemorySegment0Template(ShortMaxMask.class, ms, offset, (ShortMaxMask) m);  \/\/ specialize\n@@ -893,16 +904,2 @@\n-    void intoByteArray0(byte[] a, int offset) {\n-        super.intoByteArray0Template(a, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoByteArray0(byte[] a, int offset, VectorMask<Short> m) {\n-        super.intoByteArray0Template(ShortMaxMask.class, a, offset, (ShortMaxMask) m);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoByteBuffer0(ByteBuffer bb, int offset, VectorMask<Short> m) {\n-        super.intoByteBuffer0Template(ShortMaxMask.class, bb, offset, (ShortMaxMask) m);\n+    void intoMemorySegment0(MemorySegment ms, long offset, VectorMask<Short> m) {\n+        super.intoMemorySegment0Template(ShortMaxMask.class, ms, offset, (ShortMaxMask) m);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ShortMaxVector.java","additions":32,"deletions":35,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import java.nio.ByteBuffer;\n@@ -29,1 +28,0 @@\n-import java.nio.ReadOnlyBufferException;\n@@ -33,1 +31,0 @@\n-import java.util.function.UnaryOperator;\n@@ -35,0 +32,3 @@\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ValueLayout;\n+import jdk.internal.access.foreign.MemorySegmentProxy;\n@@ -60,0 +60,2 @@\n+    static final ValueLayout.OfShort ELEMENT_LAYOUT = ValueLayout.JAVA_SHORT.withBitAlignment(8);\n+\n@@ -354,0 +356,39 @@\n+    \/*package-private*\/\n+    interface FLdLongOp {\n+        short apply(MemorySegment memory, long offset, int i);\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    ShortVector ldLongOp(MemorySegment memory, long offset,\n+                                  FLdLongOp f) {\n+        \/\/dummy; no vec = vec();\n+        short[] res = new short[length()];\n+        for (int i = 0; i < res.length; i++) {\n+            res[i] = f.apply(memory, offset, i);\n+        }\n+        return vectorFactory(res);\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    ShortVector ldLongOp(MemorySegment memory, long offset,\n+                                  VectorMask<Short> m,\n+                                  FLdLongOp f) {\n+        \/\/short[] vec = vec();\n+        short[] res = new short[length()];\n+        boolean[] mbits = ((AbstractMask<Short>)m).getBits();\n+        for (int i = 0; i < res.length; i++) {\n+            if (mbits[i]) {\n+                res[i] = f.apply(memory, offset, i);\n+            }\n+        }\n+        return vectorFactory(res);\n+    }\n+\n+    static short memorySegmentGet(MemorySegment ms, long o, int i) {\n+        return ms.get(ELEMENT_LAYOUT, o + i * 2L);\n+    }\n+\n@@ -384,0 +425,34 @@\n+    interface FStLongOp {\n+        void apply(MemorySegment memory, long offset, int i, short a);\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    void stLongOp(MemorySegment memory, long offset,\n+                  FStLongOp f) {\n+        short[] vec = vec();\n+        for (int i = 0; i < vec.length; i++) {\n+            f.apply(memory, offset, i, vec[i]);\n+        }\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    void stLongOp(MemorySegment memory, long offset,\n+                  VectorMask<Short> m,\n+                  FStLongOp f) {\n+        short[] vec = vec();\n+        boolean[] mbits = ((AbstractMask<Short>)m).getBits();\n+        for (int i = 0; i < vec.length; i++) {\n+            if (mbits[i]) {\n+                f.apply(memory, offset, i, vec[i]);\n+            }\n+        }\n+    }\n+\n+    static void memorySegmentSet(MemorySegment ms, long o, int i, short e) {\n+        ms.set(ELEMENT_LAYOUT, o + i * 2L, e);\n+    }\n+\n@@ -434,0 +509,30 @@\n+    static ShortVector expandHelper(Vector<Short> v, VectorMask<Short> m) {\n+        VectorSpecies<Short> vsp = m.vectorSpecies();\n+        ShortVector r  = (ShortVector) vsp.zero();\n+        ShortVector vi = (ShortVector) v;\n+        if (m.allTrue()) {\n+            return vi;\n+        }\n+        for (int i = 0, j = 0; i < vsp.length(); i++) {\n+            if (m.laneIsSet(i)) {\n+                r = r.withLane(i, vi.lane(j++));\n+            }\n+        }\n+        return r;\n+    }\n+\n+    static ShortVector compressHelper(Vector<Short> v, VectorMask<Short> m) {\n+        VectorSpecies<Short> vsp = m.vectorSpecies();\n+        ShortVector r  = (ShortVector) vsp.zero();\n+        ShortVector vi = (ShortVector) v;\n+        if (m.allTrue()) {\n+            return vi;\n+        }\n+        for (int i = 0, j = 0; i < vsp.length(); i++) {\n+            if (m.laneIsSet(i)) {\n+                r = r.withLane(j++, vi.lane(i));\n+            }\n+        }\n+        return r;\n+    }\n+\n@@ -623,0 +728,10 @@\n+            case VECTOR_OP_BIT_COUNT: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> (short) bitCount(a));\n+            case VECTOR_OP_TZ_COUNT: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> (short) numberOfTrailingZeros(a));\n+            case VECTOR_OP_LZ_COUNT: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> (short) numberOfLeadingZeros(a));\n+            case VECTOR_OP_REVERSE: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> reverse(a));\n+            case VECTOR_OP_REVERSE_BYTES: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> (short) Short.reverseBytes(a));\n@@ -1749,0 +1864,20 @@\n+    static int bitCount(short a) {\n+        return Integer.bitCount((int)a & 0xFFFF);\n+    }\n+    static int numberOfTrailingZeros(short a) {\n+        return a != 0 ? Integer.numberOfTrailingZeros(a) : 16;\n+    }\n+    static int numberOfLeadingZeros(short a) {\n+        return a >= 0 ? Integer.numberOfLeadingZeros(a) - 16 : 0;\n+    }\n+\n+    static short reverse(short a) {\n+        if (a == 0 || a == -1) return a;\n+\n+        short b = rotateLeft(a, 8);\n+        b = (short) (((b & 0x5555) << 1) | ((b & 0xAAAA) >>> 1));\n+        b = (short) (((b & 0x3333) << 2) | ((b & 0xCCCC) >>> 2));\n+        b = (short) (((b & 0x0F0F) << 4) | ((b & 0xF0F0) >>> 4));\n+        return b;\n+    }\n+\n@@ -2375,0 +2510,39 @@\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     * @since 19\n+     *\/\n+    @Override\n+    public abstract\n+    ShortVector compress(VectorMask<Short> m);\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M extends AbstractMask<Short>>\n+    ShortVector compressTemplate(Class<M> masktype, M m) {\n+      m.check(masktype, this);\n+      return (ShortVector) VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_COMPRESS, getClass(), masktype,\n+                                                        short.class, length(), this, m,\n+                                                        (v1, m1) -> compressHelper(v1, m1));\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     * @since 19\n+     *\/\n+    @Override\n+    public abstract\n+    ShortVector expand(VectorMask<Short> m);\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M extends AbstractMask<Short>>\n+    ShortVector expandTemplate(Class<M> masktype, M m) {\n+      m.check(masktype, this);\n+      return (ShortVector) VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_EXPAND, getClass(), masktype,\n+                                                        short.class, length(), this, m,\n+                                                        (v1, m1) -> expandHelper(v1, m1));\n+    }\n+\n+\n@@ -2787,84 +2961,0 @@\n-    \/**\n-     * Loads a vector from a byte array starting at an offset.\n-     * Bytes are composed into primitive lane elements according\n-     * to the specified byte order.\n-     * The vector is arranged into lanes according to\n-     * <a href=\"Vector.html#lane-order\">memory ordering<\/a>.\n-     * <p>\n-     * This method behaves as if it returns the result of calling\n-     * {@link #fromByteBuffer(VectorSpecies,ByteBuffer,int,ByteOrder,VectorMask)\n-     * fromByteBuffer()} as follows:\n-     * <pre>{@code\n-     * var bb = ByteBuffer.wrap(a);\n-     * var m = species.maskAll(true);\n-     * return fromByteBuffer(species, bb, offset, bo, m);\n-     * }<\/pre>\n-     *\n-     * @param species species of desired vector\n-     * @param a the byte array\n-     * @param offset the offset into the array\n-     * @param bo the intended byte order\n-     * @return a vector loaded from a byte array\n-     * @throws IndexOutOfBoundsException\n-     *         if {@code offset+N*ESIZE < 0}\n-     *         or {@code offset+(N+1)*ESIZE > a.length}\n-     *         for any lane {@code N} in the vector\n-     *\/\n-    @ForceInline\n-    public static\n-    ShortVector fromByteArray(VectorSpecies<Short> species,\n-                                       byte[] a, int offset,\n-                                       ByteOrder bo) {\n-        offset = checkFromIndexSize(offset, species.vectorByteSize(), a.length);\n-        ShortSpecies vsp = (ShortSpecies) species;\n-        return vsp.dummyVector().fromByteArray0(a, offset).maybeSwap(bo);\n-    }\n-\n-    \/**\n-     * Loads a vector from a byte array starting at an offset\n-     * and using a mask.\n-     * Lanes where the mask is unset are filled with the default\n-     * value of {@code short} (zero).\n-     * Bytes are composed into primitive lane elements according\n-     * to the specified byte order.\n-     * The vector is arranged into lanes according to\n-     * <a href=\"Vector.html#lane-order\">memory ordering<\/a>.\n-     * <p>\n-     * This method behaves as if it returns the result of calling\n-     * {@link #fromByteBuffer(VectorSpecies,ByteBuffer,int,ByteOrder,VectorMask)\n-     * fromByteBuffer()} as follows:\n-     * <pre>{@code\n-     * var bb = ByteBuffer.wrap(a);\n-     * return fromByteBuffer(species, bb, offset, bo, m);\n-     * }<\/pre>\n-     *\n-     * @param species species of desired vector\n-     * @param a the byte array\n-     * @param offset the offset into the array\n-     * @param bo the intended byte order\n-     * @param m the mask controlling lane selection\n-     * @return a vector loaded from a byte array\n-     * @throws IndexOutOfBoundsException\n-     *         if {@code offset+N*ESIZE < 0}\n-     *         or {@code offset+(N+1)*ESIZE > a.length}\n-     *         for any lane {@code N} in the vector\n-     *         where the mask is set\n-     *\/\n-    @ForceInline\n-    public static\n-    ShortVector fromByteArray(VectorSpecies<Short> species,\n-                                       byte[] a, int offset,\n-                                       ByteOrder bo,\n-                                       VectorMask<Short> m) {\n-        ShortSpecies vsp = (ShortSpecies) species;\n-        if (offset >= 0 && offset <= (a.length - species.vectorByteSize())) {\n-            return vsp.dummyVector().fromByteArray0(a, offset, m).maybeSwap(bo);\n-        }\n-\n-        \/\/ FIXME: optimize\n-        checkMaskFromIndexSize(offset, vsp, m, 2, a.length);\n-        ByteBuffer wb = wrapper(a, bo);\n-        return vsp.ldOp(wb, offset, (AbstractMask<Short>)m,\n-                   (wb_, o, i)  -> wb_.getShort(o + i * 2));\n-    }\n-\n@@ -3170,2 +3260,2 @@\n-     * Loads a vector from a {@linkplain ByteBuffer byte buffer}\n-     * starting at an offset into the byte buffer.\n+     * Loads a vector from a {@linkplain MemorySegment memory segment}\n+     * starting at an offset into the memory segment.\n@@ -3178,2 +3268,2 @@\n-     * {@link #fromByteBuffer(VectorSpecies,ByteBuffer,int,ByteOrder,VectorMask)\n-     * fromByteBuffer()} as follows:\n+     * {@link #fromMemorySegment(VectorSpecies,MemorySegment,long,ByteOrder,VectorMask)\n+     * fromMemorySegment()} as follows:\n@@ -3182,1 +3272,1 @@\n-     * return fromByteBuffer(species, bb, offset, bo, m);\n+     * return fromMemorySegment(species, ms, offset, bo, m);\n@@ -3186,2 +3276,2 @@\n-     * @param bb the byte buffer\n-     * @param offset the offset into the byte buffer\n+     * @param ms the memory segment\n+     * @param offset the offset into the memory segment\n@@ -3189,1 +3279,1 @@\n-     * @return a vector loaded from a byte buffer\n+     * @return a vector loaded from the memory segment\n@@ -3192,1 +3282,1 @@\n-     *         or {@code offset+N*2 >= bb.limit()}\n+     *         or {@code offset+N*2 >= ms.byteSize()}\n@@ -3194,0 +3284,5 @@\n+     * @throws IllegalArgumentException if the memory segment is a heap segment that is\n+     *         not backed by a {@code byte[]} array.\n+     * @throws IllegalStateException if the memory segment's session is not alive,\n+     *         or if access occurs from a thread other than the thread owning the session.\n+     * @since 19\n@@ -3197,4 +3292,4 @@\n-    ShortVector fromByteBuffer(VectorSpecies<Short> species,\n-                                        ByteBuffer bb, int offset,\n-                                        ByteOrder bo) {\n-        offset = checkFromIndexSize(offset, species.vectorByteSize(), bb.limit());\n+    ShortVector fromMemorySegment(VectorSpecies<Short> species,\n+                                           MemorySegment ms, long offset,\n+                                           ByteOrder bo) {\n+        offset = checkFromIndexSize(offset, species.vectorByteSize(), ms.byteSize());\n@@ -3202,1 +3297,1 @@\n-        return vsp.dummyVector().fromByteBuffer0(bb, offset).maybeSwap(bo);\n+        return vsp.dummyVector().fromMemorySegment0(ms, offset).maybeSwap(bo);\n@@ -3206,2 +3301,2 @@\n-     * Loads a vector from a {@linkplain ByteBuffer byte buffer}\n-     * starting at an offset into the byte buffer\n+     * Loads a vector from a {@linkplain MemorySegment memory segment}\n+     * starting at an offset into the memory segment\n@@ -3218,3 +3313,1 @@\n-     * ShortBuffer eb = bb.duplicate()\n-     *     .position(offset)\n-     *     .order(bo).asShortBuffer();\n+     * var slice = ms.asSlice(offset);\n@@ -3224,1 +3317,1 @@\n-     *         ar[n] = eb.get(n);\n+     *         ar[n] = slice.getAtIndex(ValuaLayout.JAVA_SHORT.withBitAlignment(8), n);\n@@ -3238,2 +3331,2 @@\n-     * @param bb the byte buffer\n-     * @param offset the offset into the byte buffer\n+     * @param ms the memory segment\n+     * @param offset the offset into the memory segment\n@@ -3242,1 +3335,1 @@\n-     * @return a vector loaded from a byte buffer\n+     * @return a vector loaded from the memory segment\n@@ -3245,1 +3338,1 @@\n-     *         or {@code offset+N*2 >= bb.limit()}\n+     *         or {@code offset+N*2 >= ms.byteSize()}\n@@ -3248,0 +3341,5 @@\n+     * @throws IllegalArgumentException if the memory segment is a heap segment that is\n+     *         not backed by a {@code byte[]} array.\n+     * @throws IllegalStateException if the memory segment's session is not alive,\n+     *         or if access occurs from a thread other than the thread owning the session.\n+     * @since 19\n@@ -3251,4 +3349,4 @@\n-    ShortVector fromByteBuffer(VectorSpecies<Short> species,\n-                                        ByteBuffer bb, int offset,\n-                                        ByteOrder bo,\n-                                        VectorMask<Short> m) {\n+    ShortVector fromMemorySegment(VectorSpecies<Short> species,\n+                                           MemorySegment ms, long offset,\n+                                           ByteOrder bo,\n+                                           VectorMask<Short> m) {\n@@ -3256,2 +3354,2 @@\n-        if (offset >= 0 && offset <= (bb.limit() - species.vectorByteSize())) {\n-            return vsp.dummyVector().fromByteBuffer0(bb, offset, m).maybeSwap(bo);\n+        if (offset >= 0 && offset <= (ms.byteSize() - species.vectorByteSize())) {\n+            return vsp.dummyVector().fromMemorySegment0(ms, offset, m).maybeSwap(bo);\n@@ -3261,4 +3359,2 @@\n-        checkMaskFromIndexSize(offset, vsp, m, 2, bb.limit());\n-        ByteBuffer wb = wrapper(bb, bo);\n-        return vsp.ldOp(wb, offset, (AbstractMask<Short>)m,\n-                   (wb_, o, i)  -> wb_.getShort(o + i * 2));\n+        checkMaskFromIndexSize(offset, vsp, m, 2, ms.byteSize());\n+        return vsp.ldLongOp(ms, offset, m, ShortVector::memorySegmentGet);\n@@ -3294,1 +3390,1 @@\n-            -> v.stOp(arr, off,\n+            -> v.stOp(arr, (int) off,\n@@ -3440,1 +3536,1 @@\n-            -> v.stOp(arr, off,\n+            -> v.stOp(arr, (int) off,\n@@ -3570,0 +3666,1 @@\n+     * @since 19\n@@ -3574,21 +3671,4 @@\n-    void intoByteArray(byte[] a, int offset,\n-                       ByteOrder bo) {\n-        offset = checkFromIndexSize(offset, byteSize(), a.length);\n-        maybeSwap(bo).intoByteArray0(a, offset);\n-    }\n-\n-    \/**\n-     * {@inheritDoc} <!--workaround-->\n-     *\/\n-    @Override\n-    @ForceInline\n-    public final\n-    void intoByteArray(byte[] a, int offset,\n-                       ByteOrder bo,\n-                       VectorMask<Short> m) {\n-        if (m.allTrue()) {\n-            intoByteArray(a, offset, bo);\n-        } else {\n-            ShortSpecies vsp = vspecies();\n-            checkMaskFromIndexSize(offset, vsp, m, 2, a.length);\n-            maybeSwap(bo).intoByteArray0(a, offset, m);\n+    void intoMemorySegment(MemorySegment ms, long offset,\n+                           ByteOrder bo) {\n+        if (ms.isReadOnly()) {\n+            throw new UnsupportedOperationException(\"Attempt to write a read-only segment\");\n@@ -3596,1 +3676,0 @@\n-    }\n@@ -3598,13 +3677,2 @@\n-    \/**\n-     * {@inheritDoc} <!--workaround-->\n-     *\/\n-    @Override\n-    @ForceInline\n-    public final\n-    void intoByteBuffer(ByteBuffer bb, int offset,\n-                        ByteOrder bo) {\n-        if (ScopedMemoryAccess.isReadOnly(bb)) {\n-            throw new ReadOnlyBufferException();\n-        }\n-        offset = checkFromIndexSize(offset, byteSize(), bb.limit());\n-        maybeSwap(bo).intoByteBuffer0(bb, offset);\n+        offset = checkFromIndexSize(offset, byteSize(), ms.byteSize());\n+        maybeSwap(bo).intoMemorySegment0(ms, offset);\n@@ -3615,0 +3683,1 @@\n+     * @since 19\n@@ -3619,3 +3688,3 @@\n-    void intoByteBuffer(ByteBuffer bb, int offset,\n-                        ByteOrder bo,\n-                        VectorMask<Short> m) {\n+    void intoMemorySegment(MemorySegment ms, long offset,\n+                           ByteOrder bo,\n+                           VectorMask<Short> m) {\n@@ -3623,1 +3692,1 @@\n-            intoByteBuffer(bb, offset, bo);\n+            intoMemorySegment(ms, offset, bo);\n@@ -3625,2 +3694,2 @@\n-            if (bb.isReadOnly()) {\n-                throw new ReadOnlyBufferException();\n+            if (ms.isReadOnly()) {\n+                throw new UnsupportedOperationException(\"Attempt to write a read-only segment\");\n@@ -3629,2 +3698,2 @@\n-            checkMaskFromIndexSize(offset, vsp, m, 2, bb.limit());\n-            maybeSwap(bo).intoByteBuffer0(bb, offset, m);\n+            checkMaskFromIndexSize(offset, vsp, m, 2, ms.byteSize());\n+            maybeSwap(bo).intoMemorySegment0(ms, offset, m);\n@@ -3664,1 +3733,1 @@\n-            (arr, off, s) -> s.ldOp(arr, off,\n+            (arr, off, s) -> s.ldOp(arr, (int) off,\n@@ -3681,1 +3750,1 @@\n-            (arr, off, s, vm) -> s.ldOp(arr, off, vm,\n+            (arr, off, s, vm) -> s.ldOp(arr, (int) off, vm,\n@@ -3697,1 +3766,1 @@\n-            (arr, off, s) -> s.ldOp(arr, off,\n+            (arr, off, s) -> s.ldOp(arr, (int) off,\n@@ -3714,1 +3783,1 @@\n-                (arr, off, s, vm) -> s.ldOp(arr, off, vm,\n+                (arr, off, s, vm) -> s.ldOp(arr, (int) off, vm,\n@@ -3719,1 +3788,0 @@\n-    @Override\n@@ -3721,1 +3789,1 @@\n-    ShortVector fromByteArray0(byte[] a, int offset);\n+    ShortVector fromMemorySegment0(MemorySegment bb, long offset);\n@@ -3724,1 +3792,1 @@\n-    ShortVector fromByteArray0Template(byte[] a, int offset) {\n+    ShortVector fromMemorySegment0Template(MemorySegment ms, long offset) {\n@@ -3726,37 +3794,1 @@\n-        return VectorSupport.load(\n-            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n-            a, byteArrayAddress(a, offset),\n-            a, offset, vsp,\n-            (arr, off, s) -> {\n-                ByteBuffer wb = wrapper(arr, NATIVE_ENDIAN);\n-                return s.ldOp(wb, off,\n-                        (wb_, o, i) -> wb_.getShort(o + i * 2));\n-            });\n-    }\n-\n-    abstract\n-    ShortVector fromByteArray0(byte[] a, int offset, VectorMask<Short> m);\n-    @ForceInline\n-    final\n-    <M extends VectorMask<Short>>\n-    ShortVector fromByteArray0Template(Class<M> maskClass, byte[] a, int offset, M m) {\n-        ShortSpecies vsp = vspecies();\n-        m.check(vsp);\n-        return VectorSupport.loadMasked(\n-            vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n-            a, byteArrayAddress(a, offset), m,\n-            a, offset, vsp,\n-            (arr, off, s, vm) -> {\n-                ByteBuffer wb = wrapper(arr, NATIVE_ENDIAN);\n-                return s.ldOp(wb, off, vm,\n-                        (wb_, o, i) -> wb_.getShort(o + i * 2));\n-            });\n-    }\n-\n-    abstract\n-    ShortVector fromByteBuffer0(ByteBuffer bb, int offset);\n-    @ForceInline\n-    final\n-    ShortVector fromByteBuffer0Template(ByteBuffer bb, int offset) {\n-        ShortSpecies vsp = vspecies();\n-        return ScopedMemoryAccess.loadFromByteBuffer(\n+        return ScopedMemoryAccess.loadFromMemorySegment(\n@@ -3764,5 +3796,3 @@\n-                bb, offset, vsp,\n-                (buf, off, s) -> {\n-                    ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n-                    return s.ldOp(wb, off,\n-                            (wb_, o, i) -> wb_.getShort(o + i * 2));\n+                (MemorySegmentProxy) ms, offset, vsp,\n+                (msp, off, s) -> {\n+                    return s.ldLongOp((MemorySegment) msp, off, ShortVector::memorySegmentGet);\n@@ -3773,1 +3803,1 @@\n-    ShortVector fromByteBuffer0(ByteBuffer bb, int offset, VectorMask<Short> m);\n+    ShortVector fromMemorySegment0(MemorySegment ms, long offset, VectorMask<Short> m);\n@@ -3777,1 +3807,1 @@\n-    ShortVector fromByteBuffer0Template(Class<M> maskClass, ByteBuffer bb, int offset, M m) {\n+    ShortVector fromMemorySegment0Template(Class<M> maskClass, MemorySegment ms, long offset, M m) {\n@@ -3780,1 +3810,1 @@\n-        return ScopedMemoryAccess.loadFromByteBufferMasked(\n+        return ScopedMemoryAccess.loadFromMemorySegmentMasked(\n@@ -3782,5 +3812,3 @@\n-                bb, offset, m, vsp,\n-                (buf, off, s, vm) -> {\n-                    ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n-                    return s.ldOp(wb, off, vm,\n-                            (wb_, o, i) -> wb_.getShort(o + i * 2));\n+                (MemorySegmentProxy) ms, offset, m, vsp,\n+                (msp, off, s, vm) -> {\n+                    return s.ldLongOp((MemorySegment) msp, off, vm, ShortVector::memorySegmentGet);\n@@ -3805,1 +3833,1 @@\n-            -> v.stOp(arr, off,\n+            -> v.stOp(arr, (int) off,\n@@ -3822,1 +3850,1 @@\n-            -> v.stOp(arr, off, vm,\n+            -> v.stOp(arr, (int) off, vm,\n@@ -3828,36 +3856,0 @@\n-    abstract\n-    void intoByteArray0(byte[] a, int offset);\n-    @ForceInline\n-    final\n-    void intoByteArray0Template(byte[] a, int offset) {\n-        ShortSpecies vsp = vspecies();\n-        VectorSupport.store(\n-            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n-            a, byteArrayAddress(a, offset),\n-            this, a, offset,\n-            (arr, off, v) -> {\n-                ByteBuffer wb = wrapper(arr, NATIVE_ENDIAN);\n-                v.stOp(wb, off,\n-                        (tb_, o, i, e) -> tb_.putShort(o + i * 2, e));\n-            });\n-    }\n-\n-    abstract\n-    void intoByteArray0(byte[] a, int offset, VectorMask<Short> m);\n-    @ForceInline\n-    final\n-    <M extends VectorMask<Short>>\n-    void intoByteArray0Template(Class<M> maskClass, byte[] a, int offset, M m) {\n-        ShortSpecies vsp = vspecies();\n-        m.check(vsp);\n-        VectorSupport.storeMasked(\n-            vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n-            a, byteArrayAddress(a, offset),\n-            this, m, a, offset,\n-            (arr, off, v, vm) -> {\n-                ByteBuffer wb = wrapper(arr, NATIVE_ENDIAN);\n-                v.stOp(wb, off, vm,\n-                        (tb_, o, i, e) -> tb_.putShort(o + i * 2, e));\n-            });\n-    }\n-\n@@ -3866,1 +3858,1 @@\n-    void intoByteBuffer0(ByteBuffer bb, int offset) {\n+    void intoMemorySegment0(MemorySegment ms, long offset) {\n@@ -3868,1 +3860,1 @@\n-        ScopedMemoryAccess.storeIntoByteBuffer(\n+        ScopedMemoryAccess.storeIntoMemorySegment(\n@@ -3870,5 +3862,4 @@\n-                this, bb, offset,\n-                (buf, off, v) -> {\n-                    ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n-                    v.stOp(wb, off,\n-                            (wb_, o, i, e) -> wb_.putShort(o + i * 2, e));\n+                this,\n+                (MemorySegmentProxy) ms, offset,\n+                (msp, off, v) -> {\n+                    v.stLongOp((MemorySegment) msp, off, ShortVector::memorySegmentSet);\n@@ -3879,1 +3870,1 @@\n-    void intoByteBuffer0(ByteBuffer bb, int offset, VectorMask<Short> m);\n+    void intoMemorySegment0(MemorySegment bb, long offset, VectorMask<Short> m);\n@@ -3883,1 +3874,1 @@\n-    void intoByteBuffer0Template(Class<M> maskClass, ByteBuffer bb, int offset, M m) {\n+    void intoMemorySegment0Template(Class<M> maskClass, MemorySegment ms, long offset, M m) {\n@@ -3886,1 +3877,1 @@\n-        ScopedMemoryAccess.storeIntoByteBufferMasked(\n+        ScopedMemoryAccess.storeIntoMemorySegmentMasked(\n@@ -3888,5 +3879,4 @@\n-                this, m, bb, offset,\n-                (buf, off, v, vm) -> {\n-                    ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n-                    v.stOp(wb, off, vm,\n-                            (wb_, o, i, e) -> wb_.putShort(o + i * 2, e));\n+                this, m,\n+                (MemorySegmentProxy) ms, offset,\n+                (msp, off, v, vm) -> {\n+                    v.stLongOp((MemorySegment) msp, off, vm, ShortVector::memorySegmentSet);\n@@ -3910,1 +3900,1 @@\n-            -> v.stOp(arr, off, vm,\n+            -> v.stOp(arr, (int) off, vm,\n@@ -3926,0 +3916,10 @@\n+    private static\n+    void checkMaskFromIndexSize(long offset,\n+                                ShortSpecies vsp,\n+                                VectorMask<Short> m,\n+                                int scale,\n+                                long limit) {\n+        ((AbstractMask<Short>)m)\n+            .checkIndexByLane(offset, limit, vsp.iota(), scale);\n+    }\n+\n@@ -4253,0 +4253,15 @@\n+        \/*package-private*\/\n+        @ForceInline\n+        ShortVector ldLongOp(MemorySegment memory, long offset,\n+                                      FLdLongOp f) {\n+            return dummyVector().ldLongOp(memory, offset, f);\n+        }\n+\n+        \/*package-private*\/\n+        @ForceInline\n+        ShortVector ldLongOp(MemorySegment memory, long offset,\n+                                      VectorMask<Short> m,\n+                                      FLdLongOp f) {\n+            return dummyVector().ldLongOp(memory, offset, m, f);\n+        }\n+\n@@ -4267,0 +4282,14 @@\n+        \/*package-private*\/\n+        @ForceInline\n+        void stLongOp(MemorySegment memory, long offset, FStLongOp f) {\n+            dummyVector().stLongOp(memory, offset, f);\n+        }\n+\n+        \/*package-private*\/\n+        @ForceInline\n+        void stLongOp(MemorySegment memory, long offset,\n+                      AbstractMask<Short> m,\n+                      FStLongOp f) {\n+            dummyVector().stLongOp(memory, offset, m, f);\n+        }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ShortVector.java","additions":306,"deletions":277,"binary":false,"changes":583,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,2 @@\n-import java.nio.ByteBuffer;\n+import jdk.incubator.foreign.MemorySegment;\n+\n@@ -766,1 +767,1 @@\n- * in a {@link java.nio.ByteBuffer}.\n+ * in a {@link jdk.incubator.foreign.MemorySegment}.\n@@ -770,1 +771,1 @@\n- * within the array or buffer that holds the vector, producing the\n+ * within the array or segment that holds the vector, producing the\n@@ -1042,0 +1043,6 @@\n+ * <li>The {@link #compress(VectorMask)} and {@link #expand(VectorMask)}\n+ * methods, which select up to {@code VLENGTH} lanes from an\n+ * input vector, and assemble them in lane order.  The selection of lanes\n+ * is controlled by a {@code VectorMask}, with set lane elements mapping, by\n+ * compression or expansion in lane order, source lanes to destination lanes.\n+ *\n@@ -2692,0 +2699,40 @@\n+    \/**\n+     * Compresses the lane elements of this vector selecting lanes\n+     * under the control of a specific mask.\n+     *\n+     * This is a cross-lane operation that compresses the lane\n+     * elements of this vector as selected by the specified mask.\n+     *\n+     * For each lane {@code N} of the mask, if the mask at\n+     * lane {@code N} is set, the element at lane {@code N}\n+     * of input vector is selected and stored into the output\n+     * vector contiguously starting from the lane {@code 0}.\n+     * All the upper remaining lanes, if any, of the output\n+     * vector are set to zero.\n+     *\n+     * @param m the mask controlling the compression\n+     * @return the compressed lane elements of this vector\n+     * @since 19\n+     *\/\n+    public abstract Vector<E> compress(VectorMask<E> m);\n+\n+    \/**\n+     * Expands the lane elements of this vector\n+     * under the control of a specific mask.\n+     *\n+     * This is a cross-lane operation that expands the contiguous lane\n+     * elements of this vector into lanes of an output vector\n+     * as selected by the specified mask.\n+     *\n+     * For each lane {@code N} of the mask, if the mask at\n+     * lane {@code N} is set, the next contiguous element of input vector\n+     * starting from lane {@code 0} is selected and stored into the output\n+     * vector at lane {@code N}.\n+     * All the remaining lanes, if any, of the output vector are set to zero.\n+     *\n+     * @param m the mask controlling the compression\n+     * @return the expanded lane elements of this vector\n+     * @since 19\n+     *\/\n+    public abstract Vector<E> expand(VectorMask<E> m);\n+\n@@ -2857,3 +2904,2 @@\n-     * buffer or array using little-endian byte ordering and then the\n-     * desired vector is loaded from the same byte buffer or array\n-     * using the same ordering.\n+     * array using little-endian byte ordering and then the desired vector is loaded from the same byte\n+     * array using the same ordering.\n@@ -2868,1 +2914,1 @@\n-     * byte[] ra = new byte[Math.max(domSize, ranSize)];\n+     * MemorySegment ms = MemorySegment.ofArray(new byte[Math.max(domSize, ranSize)]);\n@@ -2870,1 +2916,1 @@\n-     *     this.intoByteArray(ra, 0, ByteOrder.native());\n+     *     this.intoMemorySegment(ms, 0, ByteOrder.native());\n@@ -2872,1 +2918,1 @@\n-     *     return species.fromByteArray(ra, origin, ByteOrder.native());\n+     *     return species.fromMemorySegment(ms, origin, ByteOrder.native());\n@@ -2875,2 +2921,2 @@\n-     *     this.intoByteArray(ra, origin, ByteOrder.native());\n-     *     return species.fromByteArray(ra, 0, ByteOrder.native());\n+     *     this.intoMemorySegment(ms, origin, ByteOrder.native());\n+     *     return species.fromMemorySegment(ms, 0, ByteOrder.native());\n@@ -2913,2 +2959,2 @@\n-     * @see IntVector#intoByteArray(byte[], int, ByteOrder)\n-     * @see FloatVector#intoByteArray(byte[], int, ByteOrder)\n+     * @see IntVector#intoMemorySegment(jdk.incubator.foreign.MemorySegment, long, java.nio.ByteOrder)\n+     * @see FloatVector#intoMemorySegment(jdk.incubator.foreign.MemorySegment, long, java.nio.ByteOrder)\n@@ -3322,2 +3368,2 @@\n-     * Stores this vector into a byte array starting at an offset\n-     * using explicit byte order.\n+     * Stores this vector into a {@linkplain MemorySegment memory segment}\n+     * starting at an offset using explicit byte order.\n@@ -3331,2 +3377,2 @@\n-     * {@link #intoByteBuffer(ByteBuffer,int,ByteOrder,VectorMask)\n-     * intoByteBuffer()} as follows:\n+     * {@link #intoMemorySegment(MemorySegment,long,ByteOrder,VectorMask)\n+     * intoMemorySegment()} as follows:\n@@ -3334,1 +3380,0 @@\n-     * var bb = ByteBuffer.wrap(a);\n@@ -3336,1 +3381,1 @@\n-     * intoByteBuffer(bb, offset, bo, m);\n+     * intoMemorySegment(ms, offset, bo, m);\n@@ -3339,2 +3384,2 @@\n-     * @param a the byte array\n-     * @param offset the offset into the array\n+     * @param ms the memory segment\n+     * @param offset the offset into the memory segment\n@@ -3344,1 +3389,1 @@\n-     *         or {@code offset+(N+1)*ESIZE > a.length}\n+     *         or {@code offset+(N+1)*ESIZE > ms.byteSize()}\n@@ -3346,0 +3391,7 @@\n+     * @throws UnsupportedOperationException\n+     *         if the memory segment is read-only\n+     * @throws IllegalArgumentException if the memory segment is a heap segment that is\n+     *         not backed by a {@code byte[]} array.\n+     * @throws IllegalStateException if the memory segment's session is not alive,\n+     *         or if access occurs from a thread other than the thread owning the session.\n+     * @since 19\n@@ -3347,2 +3399,1 @@\n-    public abstract void intoByteArray(byte[] a, int offset,\n-                                       ByteOrder bo);\n+    public abstract void intoMemorySegment(MemorySegment ms, long offset, ByteOrder bo);\n@@ -3351,62 +3402,2 @@\n-     * Stores this vector into a byte array starting at an offset\n-     * using explicit byte order and a mask.\n-     * <p>\n-     * Bytes are extracted from primitive lane elements according\n-     * to the specified byte ordering.\n-     * The lanes are stored according to their\n-     * <a href=\"Vector.html#lane-order\">memory ordering<\/a>.\n-     * <p>\n-     * This method behaves as if it calls\n-     * {@link #intoByteBuffer(ByteBuffer,int,ByteOrder,VectorMask)\n-     * intoByteBuffer()} as follows:\n-     * <pre>{@code\n-     * var bb = ByteBuffer.wrap(a);\n-     * intoByteBuffer(bb, offset, bo, m);\n-     * }<\/pre>\n-     *\n-     * @param a the byte array\n-     * @param offset the offset into the array\n-     * @param bo the intended byte order\n-     * @param m the mask controlling lane selection\n-     * @throws IndexOutOfBoundsException\n-     *         if {@code offset+N*ESIZE < 0}\n-     *         or {@code offset+(N+1)*ESIZE > a.length}\n-     *         for any lane {@code N} in the vector\n-     *         where the mask is set\n-     *\/\n-    public abstract void intoByteArray(byte[] a, int offset,\n-                                       ByteOrder bo,\n-                                       VectorMask<E> m);\n-\n-    \/**\n-     * Stores this vector into a byte buffer starting at an offset\n-     * using explicit byte order.\n-     * <p>\n-     * Bytes are extracted from primitive lane elements according\n-     * to the specified byte ordering.\n-     * The lanes are stored according to their\n-     * <a href=\"Vector.html#lane-order\">memory ordering<\/a>.\n-     * <p>\n-     * This method behaves as if it calls\n-     * {@link #intoByteBuffer(ByteBuffer,int,ByteOrder,VectorMask)\n-     * intoByteBuffer()} as follows:\n-     * <pre>{@code\n-     * var m = maskAll(true);\n-     * intoByteBuffer(bb, offset, bo, m);\n-     * }<\/pre>\n-     *\n-     * @param bb the byte buffer\n-     * @param offset the offset into the array\n-     * @param bo the intended byte order\n-     * @throws IndexOutOfBoundsException\n-     *         if {@code offset+N*ESIZE < 0}\n-     *         or {@code offset+(N+1)*ESIZE > bb.limit()}\n-     *         for any lane {@code N} in the vector\n-     * @throws java.nio.ReadOnlyBufferException\n-     *         if the byte buffer is read-only\n-     *\/\n-    public abstract void intoByteBuffer(ByteBuffer bb, int offset, ByteOrder bo);\n-\n-    \/**\n-     * Stores this vector into a byte buffer starting at an offset\n-     * using explicit byte order and a mask.\n+     * Stores this vector into a {@linkplain MemorySegment memory segment}\n+     * starting at an offset using explicit byte order and a mask.\n@@ -3420,2 +3411,1 @@\n-     * the primitive element type is not of {@code byte},\n-     * {@code EBuffer} is the primitive buffer type, {@code ETYPE} is the\n+     * {@code JAVA_E} is the layout of the primitive element type, {@code ETYPE} is the\n@@ -3425,3 +3415,0 @@\n-     * EBuffer eb = bb.duplicate()\n-     *     .position(offset)\n-     *     .order(bo).asEBuffer();\n@@ -3429,0 +3416,1 @@\n+     * var slice = ms.asSlice(offset)\n@@ -3431,1 +3419,1 @@\n-     *         eb.put(n, a[n]);\n+     *         slice.setAtIndex(ValueLayout.JAVA_E.withBitAlignment(8), n);\n@@ -3435,7 +3423,0 @@\n-     * When the primitive element type is of {@code byte} the primitive\n-     * byte buffer is obtained as follows, where operation on the buffer\n-     * remains the same as in the prior pseudocode:\n-     * <pre>{@code\n-     * ByteBuffer eb = bb.duplicate()\n-     *     .position(offset);\n-     * }<\/pre>\n@@ -3454,2 +3435,2 @@\n-     * @param bb the byte buffer\n-     * @param offset the offset into the array\n+     * @param ms the memory segment\n+     * @param offset the offset into the memory segment\n@@ -3460,1 +3441,1 @@\n-     *         or {@code offset+(N+1)*ESIZE > bb.limit()}\n+     *         or {@code offset+(N+1)*ESIZE > ms.byteSize()}\n@@ -3463,5 +3444,10 @@\n-     * @throws java.nio.ReadOnlyBufferException\n-     *         if the byte buffer is read-only\n-     *\/\n-    public abstract void intoByteBuffer(ByteBuffer bb, int offset,\n-                                        ByteOrder bo, VectorMask<E> m);\n+     * @throws UnsupportedOperationException\n+     *         if the memory segment is read-only\n+     * @throws IllegalArgumentException if the memory segment is a heap segment that is\n+     *         not backed by a {@code byte[]} array.\n+     * @throws IllegalStateException if the memory segment's session is not alive,\n+     *         or if access occurs from a thread other than the thread owning the session.\n+     * @since 19\n+     *\/\n+    public abstract void intoMemorySegment(MemorySegment ms, long offset,\n+                                           ByteOrder bo, VectorMask<E> m);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Vector.java","additions":94,"deletions":108,"binary":false,"changes":202,"status":"modified"},{"patch":"@@ -57,0 +57,10 @@\n+    @ForceInline\n+    static long checkFromIndexSize(long ix, long vlen, long length) {\n+        switch (VectorIntrinsics.VECTOR_ACCESS_OOB_CHECK) {\n+            case 0: return ix; \/\/ no range check\n+            case 1: return Objects.checkFromIndexSize(ix, vlen, length);\n+            case 2: return Objects.checkIndex(ix, length - (vlen - 1));\n+            default: throw new InternalError();\n+        }\n+    }\n+\n@@ -95,1 +105,1 @@\n-            return index - Math.floorMod(index, Math.abs(size));\n+            return index - Math.floorMod(index, size);\n@@ -98,0 +108,21 @@\n+\n+    \/\/ If the index is not already a multiple of size,\n+    \/\/ round it down to the next smaller multiple of size.\n+    \/\/ It is an error if size is less than zero.\n+    @ForceInline\n+    static long roundDown(long index, int size) {\n+        if ((size & (size - 1)) == 0) {\n+            \/\/ Size is zero or a power of two, so we got this.\n+            return index & ~(size - 1);\n+        } else {\n+            return roundDownNPOT(index, size);\n+        }\n+    }\n+    private static long roundDownNPOT(long index, int size) {\n+        if (index >= 0) {\n+            return index - (index % size);\n+        } else {\n+            return index - Math.floorMod(index, size);\n+        }\n+    }\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/VectorIntrinsics.java","additions":32,"deletions":1,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -213,1 +213,1 @@\n-                  -> s.opm(n -> c[idx + n]));\n+                  -> s.opm(n -> c[((int )idx) + n]));\n@@ -474,0 +474,33 @@\n+    \/**\n+     * Removes lanes numbered {@code N} from this mask where the\n+     * adjusted index {@code N+offset}, is not in the range\n+     * {@code [0..limit-1]}.\n+     *\n+     * <p> In all cases the series of set and unset lanes is assigned\n+     * as if by using infinite precision or {@code VLENGTH-}saturating\n+     * additions or subtractions, without overflow or wrap-around.\n+     *\n+     * @apiNote\n+     *\n+     * This method performs a SIMD emulation of the check performed by\n+     * {@link Objects#checkIndex(long,long)}, on the index numbers in\n+     * the range {@code [offset..offset+VLENGTH-1]}.  If an exception\n+     * is desired, the resulting mask can be compared with the\n+     * original mask; if they are not equal, then at least one lane\n+     * was out of range, and exception processing can be performed.\n+     *\n+     * <p> A mask which is a series of {@code N} set lanes followed by\n+     * a series of unset lanes can be obtained by calling\n+     * {@code allTrue.indexInRange(0, N)}, where {@code allTrue} is a\n+     * mask of all true bits.  A mask of {@code N1} unset lanes\n+     * followed by {@code N2} set lanes can be obtained by calling\n+     * {@code allTrue.indexInRange(-N1, N2)}.\n+     *\n+     * @param offset the starting index\n+     * @param limit the upper-bound (exclusive) of index range\n+     * @return the original mask, with out-of-range lanes unset\n+     * @see VectorSpecies#indexInRange(long, long)\n+     * @since 19\n+     *\/\n+    public abstract VectorMask<E> indexInRange(long offset, long limit);\n+\n@@ -624,0 +657,12 @@\n+    \/**\n+     * Compresses set lanes from this mask.\n+     *\n+     * Returns a mask which is a series of {@code N} set lanes\n+     * followed by a series of unset lanes, where {@code N} is\n+     * the true count of this mask.\n+     *\n+     * @return the compressed mask of this mask\n+     * @since 19\n+     *\/\n+    public abstract VectorMask<E> compress();\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/VectorMask.java","additions":46,"deletions":1,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -455,0 +455,20 @@\n+    \/** Produce {@code bitCount(a)}\n+     * @since 19\n+     *\/\n+    public static final Unary BIT_COUNT = unary(\"BIT_COUNT\", \"bitCount\", VectorSupport.VECTOR_OP_BIT_COUNT, VO_NOFP);\n+    \/** Produce {@code numberOfTrailingZeros(a)}\n+     * @since 19\n+     *\/\n+    public static final Unary TRAILING_ZEROS_COUNT = unary(\"TRAILING_ZEROS_COUNT\", \"numberOfTrailingZeros\", VectorSupport.VECTOR_OP_TZ_COUNT, VO_NOFP);\n+    \/** Produce {@code numberOfLeadingZeros(a)}\n+     * @since 19\n+     *\/\n+    public static final Unary LEADING_ZEROS_COUNT = unary(\"LEADING_ZEROS_COUNT\", \"numberOfLeadingZeros\", VectorSupport.VECTOR_OP_LZ_COUNT, VO_NOFP);\n+    \/** Produce {@code reverse(a)}\n+     * @since 19\n+     *\/\n+    public static final Unary REVERSE = unary(\"REVERSE\", \"reverse\", VectorSupport.VECTOR_OP_REVERSE, VO_NOFP);\n+    \/** Produce {@code reverseBytes(a)}\n+     * @since 19\n+     *\/\n+    public static final Unary REVERSE_BYTES = unary(\"REVERSE_BYTES\", \"reverseBytes\", VectorSupport.VECTOR_OP_REVERSE_BYTES, VO_NOFP);\n@@ -559,0 +579,8 @@\n+    \/** Produce {@code compress(a,n)}. Integral, {@code int} and {@code long}, only.\n+     * @since 19\n+     *\/\n+    public static final \/*bitwise*\/ Binary COMPRESS_BITS = binary(\"COMPRESS_BITS\", \"compressBits\", VectorSupport.VECTOR_OP_COMPRESS_BITS, VO_NOFP);\n+    \/** Produce {@code expand(a,n)}. Integral, {@code int} and {@code long}, only.\n+     * @since 19\n+     *\/\n+    public static final \/*bitwise*\/ Binary EXPAND_BITS = binary(\"EXPAND_BITS\", \"expandBits\", VectorSupport.VECTOR_OP_EXPAND_BITS, VO_NOFP);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/VectorOperators.java","additions":28,"deletions":0,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,2 @@\n+import jdk.incubator.foreign.MemorySegment;\n+\n@@ -152,1 +154,1 @@\n-               negative and the result would overflow to a positive value\n+     *         negative and the result would overflow to a positive value\n@@ -157,0 +159,26 @@\n+    \/**\n+     * Loop control function which returns the largest multiple of\n+     * {@code VLENGTH} that is less than or equal to the given\n+     * {@code length} value.\n+     * Here, {@code VLENGTH} is the result of {@code this.length()},\n+     * and {@code length} is interpreted as a number of lanes.\n+     * The resulting value {@code R} satisfies this inequality:\n+     * <pre>{@code R <= length < R+VLENGTH}\n+     * <\/pre>\n+     * <p> Specifically, this method computes\n+     * {@code length - floorMod(length, VLENGTH)}, where\n+     * {@link Math#floorMod(long,int) floorMod} computes a remainder\n+     * value by rounding its quotient toward negative infinity.\n+     * As long as {@code VLENGTH} is a power of two, then the result\n+     * is also equal to {@code length & ~(VLENGTH - 1)}.\n+     *\n+     * @param length the input length\n+     * @return the largest multiple of the vector length not greater\n+     *         than the given length\n+     * @throws IllegalArgumentException if the {@code length} is\n+     *         negative and the result would overflow to a positive value\n+     * @see Math#floorMod(long, int)\n+     * @since 19\n+     *\/\n+    long loopBound(long length);\n+\n@@ -174,0 +202,18 @@\n+    \/**\n+     * Returns a mask of this species where only\n+     * the lanes at index N such that the adjusted index\n+     * {@code N+offset} is in the range {@code [0..limit-1]}\n+     * are set.\n+     *\n+     * <p>\n+     * This method returns the value of the expression\n+     * {@code maskAll(true).indexInRange(offset, limit)}\n+     *\n+     * @param offset the starting index\n+     * @param limit the upper-bound (exclusive) of index range\n+     * @return a mask with out-of-range lanes unset\n+     * @see VectorMask#indexInRange(long, long)\n+     * @since 19\n+     *\/\n+    VectorMask<E> indexInRange(long offset, long limit);\n+\n@@ -436,2 +482,2 @@\n-     * Loads a vector of this species from a byte array starting\n-     * at an offset.\n+     * Loads a vector of this species from a {@linkplain MemorySegment memory segment}\n+     * starting at an offset into the memory segment.\n@@ -444,2 +490,1 @@\n-     * {@code IntVector.fromByteArray(this,a,offset,bo)}\n-     * or an equivalent {@code fromByteArray} method,\n+     * {@code IntVector.fromMemorySegment(this,ms,offset,bo)},\n@@ -449,2 +494,2 @@\n-     * @param a a byte array\n-     * @param offset the index of the first byte to load\n+     * @param ms the memory segment\n+     * @param offset the offset into the memory segment\n@@ -452,1 +497,1 @@\n-     * @return a vector of the given species filled from the byte array\n+     * @return a vector of the given species filled from the memory segment\n@@ -457,2 +502,3 @@\n-     * @see IntVector#fromByteArray(VectorSpecies,byte[],int,ByteOrder)\n-     * @see FloatVector#fromByteArray(VectorSpecies,byte[],int,ByteOrder)\n+     * @see IntVector#fromMemorySegment(VectorSpecies, jdk.incubator.foreign.MemorySegment, long, java.nio.ByteOrder)\n+     * @see FloatVector#fromMemorySegment(VectorSpecies, jdk.incubator.foreign.MemorySegment, long, java.nio.ByteOrder)\n+     * @since 19\n@@ -460,1 +506,1 @@\n-    Vector<E> fromByteArray(byte[] a, int offset, ByteOrder bo);\n+    Vector<E> fromMemorySegment(MemorySegment ms, long offset, ByteOrder bo);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/VectorSpecies.java","additions":58,"deletions":12,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import java.nio.ByteBuffer;\n@@ -29,1 +28,0 @@\n-import java.nio.ReadOnlyBufferException;\n@@ -33,1 +31,0 @@\n-import java.util.function.UnaryOperator;\n@@ -35,0 +32,3 @@\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ValueLayout;\n+import jdk.internal.access.foreign.MemorySegmentProxy;\n@@ -64,0 +64,2 @@\n+    static final ValueLayout.Of$Type$ ELEMENT_LAYOUT = ValueLayout.JAVA_$TYPE$.withBitAlignment(8);\n+\n@@ -358,0 +360,39 @@\n+    \/*package-private*\/\n+    interface FLdLongOp {\n+        $type$ apply(MemorySegment memory, long offset, int i);\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    $abstractvectortype$ ldLongOp(MemorySegment memory, long offset,\n+                                  FLdLongOp f) {\n+        \/\/dummy; no vec = vec();\n+        $type$[] res = new $type$[length()];\n+        for (int i = 0; i < res.length; i++) {\n+            res[i] = f.apply(memory, offset, i);\n+        }\n+        return vectorFactory(res);\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    $abstractvectortype$ ldLongOp(MemorySegment memory, long offset,\n+                                  VectorMask<$Boxtype$> m,\n+                                  FLdLongOp f) {\n+        \/\/$type$[] vec = vec();\n+        $type$[] res = new $type$[length()];\n+        boolean[] mbits = ((AbstractMask<$Boxtype$>)m).getBits();\n+        for (int i = 0; i < res.length; i++) {\n+            if (mbits[i]) {\n+                res[i] = f.apply(memory, offset, i);\n+            }\n+        }\n+        return vectorFactory(res);\n+    }\n+\n+    static $type$ memorySegmentGet(MemorySegment ms, long o, int i) {\n+        return ms.get(ELEMENT_LAYOUT, o + i * $sizeInBytes$L);\n+    }\n+\n@@ -388,0 +429,34 @@\n+    interface FStLongOp {\n+        void apply(MemorySegment memory, long offset, int i, $type$ a);\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    void stLongOp(MemorySegment memory, long offset,\n+                  FStLongOp f) {\n+        $type$[] vec = vec();\n+        for (int i = 0; i < vec.length; i++) {\n+            f.apply(memory, offset, i, vec[i]);\n+        }\n+    }\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    void stLongOp(MemorySegment memory, long offset,\n+                  VectorMask<$Boxtype$> m,\n+                  FStLongOp f) {\n+        $type$[] vec = vec();\n+        boolean[] mbits = ((AbstractMask<$Boxtype$>)m).getBits();\n+        for (int i = 0; i < vec.length; i++) {\n+            if (mbits[i]) {\n+                f.apply(memory, offset, i, vec[i]);\n+            }\n+        }\n+    }\n+\n+    static void memorySegmentSet(MemorySegment ms, long o, int i, $type$ e) {\n+        ms.set(ELEMENT_LAYOUT, o + i * $sizeInBytes$L, e);\n+    }\n+\n@@ -448,0 +523,30 @@\n+    static $abstractvectortype$ expandHelper(Vector<$Boxtype$> v, VectorMask<$Boxtype$> m) {\n+        VectorSpecies<$Boxtype$> vsp = m.vectorSpecies();\n+        $abstractvectortype$ r  = ($abstractvectortype$) vsp.zero();\n+        $abstractvectortype$ vi = ($abstractvectortype$) v;\n+        if (m.allTrue()) {\n+            return vi;\n+        }\n+        for (int i = 0, j = 0; i < vsp.length(); i++) {\n+            if (m.laneIsSet(i)) {\n+                r = r.withLane(i, vi.lane(j++));\n+            }\n+        }\n+        return r;\n+    }\n+\n+    static $abstractvectortype$ compressHelper(Vector<$Boxtype$> v, VectorMask<$Boxtype$> m) {\n+        VectorSpecies<$Boxtype$> vsp = m.vectorSpecies();\n+        $abstractvectortype$ r  = ($abstractvectortype$) vsp.zero();\n+        $abstractvectortype$ vi = ($abstractvectortype$) v;\n+        if (m.allTrue()) {\n+            return vi;\n+        }\n+        for (int i = 0, j = 0; i < vsp.length(); i++) {\n+            if (m.laneIsSet(i)) {\n+                r = r.withLane(j++, vi.lane(i));\n+            }\n+        }\n+        return r;\n+    }\n+\n@@ -649,0 +754,30 @@\n+#if[!FP]\n+#if[intOrLong]\n+            case VECTOR_OP_BIT_COUNT: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> ($type$) $Boxtype$.bitCount(a));\n+            case VECTOR_OP_TZ_COUNT: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> ($type$) $Boxtype$.numberOfTrailingZeros(a));\n+            case VECTOR_OP_LZ_COUNT: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> ($type$) $Boxtype$.numberOfLeadingZeros(a));\n+            case VECTOR_OP_REVERSE: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> ($type$) $Boxtype$.reverse(a));\n+#else[intOrLong]\n+            case VECTOR_OP_BIT_COUNT: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> ($type$) bitCount(a));\n+            case VECTOR_OP_TZ_COUNT: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> ($type$) numberOfTrailingZeros(a));\n+            case VECTOR_OP_LZ_COUNT: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> ($type$) numberOfLeadingZeros(a));\n+            case VECTOR_OP_REVERSE: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> reverse(a));\n+#end[intOrLong]\n+#if[BITWISE]\n+#if[byte]\n+            case VECTOR_OP_REVERSE_BYTES: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> a);\n+#else[byte]\n+            case VECTOR_OP_REVERSE_BYTES: return (v0, m) ->\n+                    v0.uOp(m, (i, a) -> ($type$) $Boxtype$.reverseBytes(a));\n+#end[byte]\n+#end[BITWISE]\n+#end[!FP]\n@@ -842,0 +977,6 @@\n+#if[intOrLong]\n+            case VECTOR_OP_COMPRESS_BITS: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, n) -> $Boxtype$.compress(a, n));\n+            case VECTOR_OP_EXPAND_BITS: return (v0, v1, vm) ->\n+                    v0.bOp(v1, vm, (i, a, n) -> $Boxtype$.expand(a, n));\n+#end[intOrLong]\n@@ -1990,0 +2131,50 @@\n+#if[!FP]\n+#if[!intOrLong]\n+    static int bitCount($type$ a) {\n+#if[short]\n+        return Integer.bitCount((int)a & 0xFFFF);\n+#else[short]\n+        return Integer.bitCount((int)a & 0xFF);\n+#end[short]\n+    }\n+#end[!intOrLong]\n+#end[!FP]\n+#if[!FP]\n+#if[!intOrLong]\n+    static int numberOfTrailingZeros($type$ a) {\n+#if[short]\n+        return a != 0 ? Integer.numberOfTrailingZeros(a) : 16;\n+#else[short]\n+        return a != 0 ? Integer.numberOfTrailingZeros(a) : 8;\n+#end[short]\n+    }\n+#end[!intOrLong]\n+#end[!FP]\n+#if[!FP]\n+#if[!intOrLong]\n+    static int numberOfLeadingZeros($type$ a) {\n+#if[short]\n+        return a >= 0 ? Integer.numberOfLeadingZeros(a) - 16 : 0;\n+#else[short]\n+        return a >= 0 ? Integer.numberOfLeadingZeros(a) - 24 : 0;\n+#end[short]\n+    }\n+\n+    static $type$ reverse($type$ a) {\n+        if (a == 0 || a == -1) return a;\n+\n+#if[short]\n+        $type$ b = rotateLeft(a, 8);\n+        b = ($type$) (((b & 0x5555) << 1) | ((b & 0xAAAA) >>> 1));\n+        b = ($type$) (((b & 0x3333) << 2) | ((b & 0xCCCC) >>> 2));\n+        b = ($type$) (((b & 0x0F0F) << 4) | ((b & 0xF0F0) >>> 4));\n+#else[short]\n+        $type$ b = rotateLeft(a, 4);\n+        b = ($type$) (((b & 0x55) << 1) | ((b & 0xAA) >>> 1));\n+        b = ($type$) (((b & 0x33) << 2) | ((b & 0xCC) >>> 2));\n+#end[short]\n+        return b;\n+    }\n+#end[!intOrLong]\n+#end[!FP]\n+\n@@ -2698,0 +2889,39 @@\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     * @since 19\n+     *\/\n+    @Override\n+    public abstract\n+    $Type$Vector compress(VectorMask<$Boxtype$> m);\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M extends AbstractMask<$Boxtype$>>\n+    $Type$Vector compressTemplate(Class<M> masktype, M m) {\n+      m.check(masktype, this);\n+      return ($Type$Vector) VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_COMPRESS, getClass(), masktype,\n+                                                        $type$.class, length(), this, m,\n+                                                        (v1, m1) -> compressHelper(v1, m1));\n+    }\n+\n+    \/**\n+     * {@inheritDoc} <!--workaround-->\n+     * @since 19\n+     *\/\n+    @Override\n+    public abstract\n+    $Type$Vector expand(VectorMask<$Boxtype$> m);\n+\n+    \/*package-private*\/\n+    @ForceInline\n+    final\n+    <M extends AbstractMask<$Boxtype$>>\n+    $Type$Vector expandTemplate(Class<M> masktype, M m) {\n+      m.check(masktype, this);\n+      return ($Type$Vector) VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_EXPAND, getClass(), masktype,\n+                                                        $type$.class, length(), this, m,\n+                                                        (v1, m1) -> expandHelper(v1, m1));\n+    }\n+\n+\n@@ -3305,84 +3535,0 @@\n-    \/**\n-     * Loads a vector from a byte array starting at an offset.\n-     * Bytes are composed into primitive lane elements according\n-     * to the specified byte order.\n-     * The vector is arranged into lanes according to\n-     * <a href=\"Vector.html#lane-order\">memory ordering<\/a>.\n-     * <p>\n-     * This method behaves as if it returns the result of calling\n-     * {@link #fromByteBuffer(VectorSpecies,ByteBuffer,int,ByteOrder,VectorMask)\n-     * fromByteBuffer()} as follows:\n-     * <pre>{@code\n-     * var bb = ByteBuffer.wrap(a);\n-     * var m = species.maskAll(true);\n-     * return fromByteBuffer(species, bb, offset, bo, m);\n-     * }<\/pre>\n-     *\n-     * @param species species of desired vector\n-     * @param a the byte array\n-     * @param offset the offset into the array\n-     * @param bo the intended byte order\n-     * @return a vector loaded from a byte array\n-     * @throws IndexOutOfBoundsException\n-     *         if {@code offset+N*ESIZE < 0}\n-     *         or {@code offset+(N+1)*ESIZE > a.length}\n-     *         for any lane {@code N} in the vector\n-     *\/\n-    @ForceInline\n-    public static\n-    $abstractvectortype$ fromByteArray(VectorSpecies<$Boxtype$> species,\n-                                       byte[] a, int offset,\n-                                       ByteOrder bo) {\n-        offset = checkFromIndexSize(offset, species.vectorByteSize(), a.length);\n-        $Type$Species vsp = ($Type$Species) species;\n-        return vsp.dummyVector().fromByteArray0(a, offset).maybeSwap(bo);\n-    }\n-\n-    \/**\n-     * Loads a vector from a byte array starting at an offset\n-     * and using a mask.\n-     * Lanes where the mask is unset are filled with the default\n-     * value of {@code $type$} ({#if[FP]?positive }zero).\n-     * Bytes are composed into primitive lane elements according\n-     * to the specified byte order.\n-     * The vector is arranged into lanes according to\n-     * <a href=\"Vector.html#lane-order\">memory ordering<\/a>.\n-     * <p>\n-     * This method behaves as if it returns the result of calling\n-     * {@link #fromByteBuffer(VectorSpecies,ByteBuffer,int,ByteOrder,VectorMask)\n-     * fromByteBuffer()} as follows:\n-     * <pre>{@code\n-     * var bb = ByteBuffer.wrap(a);\n-     * return fromByteBuffer(species, bb, offset, bo, m);\n-     * }<\/pre>\n-     *\n-     * @param species species of desired vector\n-     * @param a the byte array\n-     * @param offset the offset into the array\n-     * @param bo the intended byte order\n-     * @param m the mask controlling lane selection\n-     * @return a vector loaded from a byte array\n-     * @throws IndexOutOfBoundsException\n-     *         if {@code offset+N*ESIZE < 0}\n-     *         or {@code offset+(N+1)*ESIZE > a.length}\n-     *         for any lane {@code N} in the vector\n-     *         where the mask is set\n-     *\/\n-    @ForceInline\n-    public static\n-    $abstractvectortype$ fromByteArray(VectorSpecies<$Boxtype$> species,\n-                                       byte[] a, int offset,\n-                                       ByteOrder bo,\n-                                       VectorMask<$Boxtype$> m) {\n-        $Type$Species vsp = ($Type$Species) species;\n-        if (offset >= 0 && offset <= (a.length - species.vectorByteSize())) {\n-            return vsp.dummyVector().fromByteArray0(a, offset, m).maybeSwap(bo);\n-        }\n-\n-        \/\/ FIXME: optimize\n-        checkMaskFromIndexSize(offset, vsp, m, $sizeInBytes$, a.length);\n-        ByteBuffer wb = wrapper(a, bo);\n-        return vsp.ldOp(wb, offset, (AbstractMask<$Boxtype$>)m,\n-                   (wb_, o, i)  -> wb_.get{#if[byte]?(:$Type$(}o + i * $sizeInBytes$));\n-    }\n-\n@@ -3920,2 +4066,2 @@\n-     * Loads a vector from a {@linkplain ByteBuffer byte buffer}\n-     * starting at an offset into the byte buffer.\n+     * Loads a vector from a {@linkplain MemorySegment memory segment}\n+     * starting at an offset into the memory segment.\n@@ -3928,2 +4074,2 @@\n-     * {@link #fromByteBuffer(VectorSpecies,ByteBuffer,int,ByteOrder,VectorMask)\n-     * fromByteBuffer()} as follows:\n+     * {@link #fromMemorySegment(VectorSpecies,MemorySegment,long,ByteOrder,VectorMask)\n+     * fromMemorySegment()} as follows:\n@@ -3932,1 +4078,1 @@\n-     * return fromByteBuffer(species, bb, offset, bo, m);\n+     * return fromMemorySegment(species, ms, offset, bo, m);\n@@ -3936,2 +4082,2 @@\n-     * @param bb the byte buffer\n-     * @param offset the offset into the byte buffer\n+     * @param ms the memory segment\n+     * @param offset the offset into the memory segment\n@@ -3939,1 +4085,1 @@\n-     * @return a vector loaded from a byte buffer\n+     * @return a vector loaded from the memory segment\n@@ -3942,1 +4088,1 @@\n-     *         or {@code offset+N*$sizeInBytes$ >= bb.limit()}\n+     *         or {@code offset+N*$sizeInBytes$ >= ms.byteSize()}\n@@ -3944,0 +4090,5 @@\n+     * @throws IllegalArgumentException if the memory segment is a heap segment that is\n+     *         not backed by a {@code byte[]} array.\n+     * @throws IllegalStateException if the memory segment's session is not alive,\n+     *         or if access occurs from a thread other than the thread owning the session.\n+     * @since 19\n@@ -3947,4 +4098,4 @@\n-    $abstractvectortype$ fromByteBuffer(VectorSpecies<$Boxtype$> species,\n-                                        ByteBuffer bb, int offset,\n-                                        ByteOrder bo) {\n-        offset = checkFromIndexSize(offset, species.vectorByteSize(), bb.limit());\n+    $abstractvectortype$ fromMemorySegment(VectorSpecies<$Boxtype$> species,\n+                                           MemorySegment ms, long offset,\n+                                           ByteOrder bo) {\n+        offset = checkFromIndexSize(offset, species.vectorByteSize(), ms.byteSize());\n@@ -3952,1 +4103,1 @@\n-        return vsp.dummyVector().fromByteBuffer0(bb, offset).maybeSwap(bo);\n+        return vsp.dummyVector().fromMemorySegment0(ms, offset).maybeSwap(bo);\n@@ -3956,2 +4107,2 @@\n-     * Loads a vector from a {@linkplain ByteBuffer byte buffer}\n-     * starting at an offset into the byte buffer\n+     * Loads a vector from a {@linkplain MemorySegment memory segment}\n+     * starting at an offset into the memory segment\n@@ -3968,5 +4119,1 @@\n-     * $Type$Buffer eb = bb.duplicate()\n-     *     .position(offset){#if[byte]?;}\n-#if[!byte]\n-     *     .order(bo).as$Type$Buffer();\n-#end[!byte]\n+     * var slice = ms.asSlice(offset);\n@@ -3976,1 +4123,1 @@\n-     *         ar[n] = eb.get(n);\n+     *         ar[n] = slice.getAtIndex(ValuaLayout.JAVA_$TYPE$.withBitAlignment(8), n);\n@@ -3994,2 +4141,2 @@\n-     * @param bb the byte buffer\n-     * @param offset the offset into the byte buffer\n+     * @param ms the memory segment\n+     * @param offset the offset into the memory segment\n@@ -3998,1 +4145,1 @@\n-     * @return a vector loaded from a byte buffer\n+     * @return a vector loaded from the memory segment\n@@ -4001,1 +4148,1 @@\n-     *         or {@code offset+N*$sizeInBytes$ >= bb.limit()}\n+     *         or {@code offset+N*$sizeInBytes$ >= ms.byteSize()}\n@@ -4004,0 +4151,5 @@\n+     * @throws IllegalArgumentException if the memory segment is a heap segment that is\n+     *         not backed by a {@code byte[]} array.\n+     * @throws IllegalStateException if the memory segment's session is not alive,\n+     *         or if access occurs from a thread other than the thread owning the session.\n+     * @since 19\n@@ -4007,4 +4159,4 @@\n-    $abstractvectortype$ fromByteBuffer(VectorSpecies<$Boxtype$> species,\n-                                        ByteBuffer bb, int offset,\n-                                        ByteOrder bo,\n-                                        VectorMask<$Boxtype$> m) {\n+    $abstractvectortype$ fromMemorySegment(VectorSpecies<$Boxtype$> species,\n+                                           MemorySegment ms, long offset,\n+                                           ByteOrder bo,\n+                                           VectorMask<$Boxtype$> m) {\n@@ -4012,2 +4164,2 @@\n-        if (offset >= 0 && offset <= (bb.limit() - species.vectorByteSize())) {\n-            return vsp.dummyVector().fromByteBuffer0(bb, offset, m).maybeSwap(bo);\n+        if (offset >= 0 && offset <= (ms.byteSize() - species.vectorByteSize())) {\n+            return vsp.dummyVector().fromMemorySegment0(ms, offset, m).maybeSwap(bo);\n@@ -4017,4 +4169,2 @@\n-        checkMaskFromIndexSize(offset, vsp, m, $sizeInBytes$, bb.limit());\n-        ByteBuffer wb = wrapper(bb, bo);\n-        return vsp.ldOp(wb, offset, (AbstractMask<$Boxtype$>)m,\n-                   (wb_, o, i)  -> wb_.get{#if[byte]?(:$Type$(}o + i * $sizeInBytes$));\n+        checkMaskFromIndexSize(offset, vsp, m, $sizeInBytes$, ms.byteSize());\n+        return vsp.ldLongOp(ms, offset, m, $abstractvectortype$::memorySegmentGet);\n@@ -4050,1 +4200,1 @@\n-            -> v.stOp(arr, off,\n+            -> v.stOp(arr, (int) off,\n@@ -4267,1 +4417,1 @@\n-            -> v.stOp(arr, off,\n+            -> v.stOp(arr, (int) off,\n@@ -4426,1 +4576,1 @@\n-            -> v.stOp(arr, off,\n+            -> v.stOp(arr, (int) off,\n@@ -4565,0 +4715,1 @@\n+     * @since 19\n@@ -4569,21 +4720,4 @@\n-    void intoByteArray(byte[] a, int offset,\n-                       ByteOrder bo) {\n-        offset = checkFromIndexSize(offset, byteSize(), a.length);\n-        maybeSwap(bo).intoByteArray0(a, offset);\n-    }\n-\n-    \/**\n-     * {@inheritDoc} <!--workaround-->\n-     *\/\n-    @Override\n-    @ForceInline\n-    public final\n-    void intoByteArray(byte[] a, int offset,\n-                       ByteOrder bo,\n-                       VectorMask<$Boxtype$> m) {\n-        if (m.allTrue()) {\n-            intoByteArray(a, offset, bo);\n-        } else {\n-            $Type$Species vsp = vspecies();\n-            checkMaskFromIndexSize(offset, vsp, m, $sizeInBytes$, a.length);\n-            maybeSwap(bo).intoByteArray0(a, offset, m);\n+    void intoMemorySegment(MemorySegment ms, long offset,\n+                           ByteOrder bo) {\n+        if (ms.isReadOnly()) {\n+            throw new UnsupportedOperationException(\"Attempt to write a read-only segment\");\n@@ -4591,1 +4725,0 @@\n-    }\n@@ -4593,13 +4726,2 @@\n-    \/**\n-     * {@inheritDoc} <!--workaround-->\n-     *\/\n-    @Override\n-    @ForceInline\n-    public final\n-    void intoByteBuffer(ByteBuffer bb, int offset,\n-                        ByteOrder bo) {\n-        if (ScopedMemoryAccess.isReadOnly(bb)) {\n-            throw new ReadOnlyBufferException();\n-        }\n-        offset = checkFromIndexSize(offset, byteSize(), bb.limit());\n-        maybeSwap(bo).intoByteBuffer0(bb, offset);\n+        offset = checkFromIndexSize(offset, byteSize(), ms.byteSize());\n+        maybeSwap(bo).intoMemorySegment0(ms, offset);\n@@ -4610,0 +4732,1 @@\n+     * @since 19\n@@ -4614,3 +4737,3 @@\n-    void intoByteBuffer(ByteBuffer bb, int offset,\n-                        ByteOrder bo,\n-                        VectorMask<$Boxtype$> m) {\n+    void intoMemorySegment(MemorySegment ms, long offset,\n+                           ByteOrder bo,\n+                           VectorMask<$Boxtype$> m) {\n@@ -4618,1 +4741,1 @@\n-            intoByteBuffer(bb, offset, bo);\n+            intoMemorySegment(ms, offset, bo);\n@@ -4620,2 +4743,2 @@\n-            if (bb.isReadOnly()) {\n-                throw new ReadOnlyBufferException();\n+            if (ms.isReadOnly()) {\n+                throw new UnsupportedOperationException(\"Attempt to write a read-only segment\");\n@@ -4624,2 +4747,2 @@\n-            checkMaskFromIndexSize(offset, vsp, m, $sizeInBytes$, bb.limit());\n-            maybeSwap(bo).intoByteBuffer0(bb, offset, m);\n+            checkMaskFromIndexSize(offset, vsp, m, $sizeInBytes$, ms.byteSize());\n+            maybeSwap(bo).intoMemorySegment0(ms, offset, m);\n@@ -4659,1 +4782,1 @@\n-            (arr, off, s) -> s.ldOp(arr, off,\n+            (arr, off, s) -> s.ldOp(arr, (int) off,\n@@ -4676,1 +4799,1 @@\n-            (arr, off, s, vm) -> s.ldOp(arr, off, vm,\n+            (arr, off, s, vm) -> s.ldOp(arr, (int) off, vm,\n@@ -4753,1 +4876,1 @@\n-            (arr, off, s) -> s.ldOp(arr, off,\n+            (arr, off, s) -> s.ldOp(arr, (int) off,\n@@ -4770,1 +4893,1 @@\n-                (arr, off, s, vm) -> s.ldOp(arr, off, vm,\n+                (arr, off, s, vm) -> s.ldOp(arr, (int) off, vm,\n@@ -4787,1 +4910,1 @@\n-            (arr, off, s) -> s.ldOp(arr, off,\n+            (arr, off, s) -> s.ldOp(arr, (int) off,\n@@ -4804,1 +4927,1 @@\n-            (arr, off, s, vm) -> s.ldOp(arr, off, vm,\n+            (arr, off, s, vm) -> s.ldOp(arr, (int) off, vm,\n@@ -4809,1 +4932,0 @@\n-    @Override\n@@ -4811,1 +4933,1 @@\n-    $abstractvectortype$ fromByteArray0(byte[] a, int offset);\n+    $abstractvectortype$ fromMemorySegment0(MemorySegment bb, long offset);\n@@ -4814,1 +4936,1 @@\n-    $abstractvectortype$ fromByteArray0Template(byte[] a, int offset) {\n+    $abstractvectortype$ fromMemorySegment0Template(MemorySegment ms, long offset) {\n@@ -4816,37 +4938,1 @@\n-        return VectorSupport.load(\n-            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n-            a, byteArrayAddress(a, offset),\n-            a, offset, vsp,\n-            (arr, off, s) -> {\n-                ByteBuffer wb = wrapper(arr, NATIVE_ENDIAN);\n-                return s.ldOp(wb, off,\n-                        (wb_, o, i) -> wb_.get{#if[byte]?(:$Type$(}o + i * $sizeInBytes$));\n-            });\n-    }\n-\n-    abstract\n-    $abstractvectortype$ fromByteArray0(byte[] a, int offset, VectorMask<$Boxtype$> m);\n-    @ForceInline\n-    final\n-    <M extends VectorMask<$Boxtype$>>\n-    $abstractvectortype$ fromByteArray0Template(Class<M> maskClass, byte[] a, int offset, M m) {\n-        $Type$Species vsp = vspecies();\n-        m.check(vsp);\n-        return VectorSupport.loadMasked(\n-            vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n-            a, byteArrayAddress(a, offset), m,\n-            a, offset, vsp,\n-            (arr, off, s, vm) -> {\n-                ByteBuffer wb = wrapper(arr, NATIVE_ENDIAN);\n-                return s.ldOp(wb, off, vm,\n-                        (wb_, o, i) -> wb_.get{#if[byte]?(:$Type$(}o + i * $sizeInBytes$));\n-            });\n-    }\n-\n-    abstract\n-    $abstractvectortype$ fromByteBuffer0(ByteBuffer bb, int offset);\n-    @ForceInline\n-    final\n-    $abstractvectortype$ fromByteBuffer0Template(ByteBuffer bb, int offset) {\n-        $Type$Species vsp = vspecies();\n-        return ScopedMemoryAccess.loadFromByteBuffer(\n+        return ScopedMemoryAccess.loadFromMemorySegment(\n@@ -4854,5 +4940,3 @@\n-                bb, offset, vsp,\n-                (buf, off, s) -> {\n-                    ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n-                    return s.ldOp(wb, off,\n-                            (wb_, o, i) -> wb_.get{#if[byte]?(:$Type$(}o + i * $sizeInBytes$));\n+                (MemorySegmentProxy) ms, offset, vsp,\n+                (msp, off, s) -> {\n+                    return s.ldLongOp((MemorySegment) msp, off, $abstractvectortype$::memorySegmentGet);\n@@ -4863,1 +4947,1 @@\n-    $abstractvectortype$ fromByteBuffer0(ByteBuffer bb, int offset, VectorMask<$Boxtype$> m);\n+    $abstractvectortype$ fromMemorySegment0(MemorySegment ms, long offset, VectorMask<$Boxtype$> m);\n@@ -4867,1 +4951,1 @@\n-    $abstractvectortype$ fromByteBuffer0Template(Class<M> maskClass, ByteBuffer bb, int offset, M m) {\n+    $abstractvectortype$ fromMemorySegment0Template(Class<M> maskClass, MemorySegment ms, long offset, M m) {\n@@ -4870,1 +4954,1 @@\n-        return ScopedMemoryAccess.loadFromByteBufferMasked(\n+        return ScopedMemoryAccess.loadFromMemorySegmentMasked(\n@@ -4872,5 +4956,3 @@\n-                bb, offset, m, vsp,\n-                (buf, off, s, vm) -> {\n-                    ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n-                    return s.ldOp(wb, off, vm,\n-                            (wb_, o, i) -> wb_.get{#if[byte]?(:$Type$(}o + i * $sizeInBytes$));\n+                (MemorySegmentProxy) ms, offset, m, vsp,\n+                (msp, off, s, vm) -> {\n+                    return s.ldLongOp((MemorySegment) msp, off, vm, $abstractvectortype$::memorySegmentGet);\n@@ -4895,1 +4977,1 @@\n-            -> v.stOp(arr, off,\n+            -> v.stOp(arr, (int) off,\n@@ -4912,1 +4994,1 @@\n-            -> v.stOp(arr, off, vm,\n+            -> v.stOp(arr, (int) off, vm,\n@@ -4993,1 +5075,1 @@\n-            -> v.stOp(arr, off, vm,\n+            -> v.stOp(arr, (int) off, vm,\n@@ -4998,2 +5080,0 @@\n-    abstract\n-    void intoByteArray0(byte[] a, int offset);\n@@ -5002,1 +5082,1 @@\n-    void intoByteArray0Template(byte[] a, int offset) {\n+    void intoMemorySegment0(MemorySegment ms, long offset) {\n@@ -5004,35 +5084,1 @@\n-        VectorSupport.store(\n-            vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n-            a, byteArrayAddress(a, offset),\n-            this, a, offset,\n-            (arr, off, v) -> {\n-                ByteBuffer wb = wrapper(arr, NATIVE_ENDIAN);\n-                v.stOp(wb, off,\n-                        (tb_, o, i, e) -> tb_.put{#if[byte]?(:$Type$(}o + i * $sizeInBytes$, e));\n-            });\n-    }\n-\n-    abstract\n-    void intoByteArray0(byte[] a, int offset, VectorMask<$Boxtype$> m);\n-    @ForceInline\n-    final\n-    <M extends VectorMask<$Boxtype$>>\n-    void intoByteArray0Template(Class<M> maskClass, byte[] a, int offset, M m) {\n-        $Type$Species vsp = vspecies();\n-        m.check(vsp);\n-        VectorSupport.storeMasked(\n-            vsp.vectorType(), maskClass, vsp.elementType(), vsp.laneCount(),\n-            a, byteArrayAddress(a, offset),\n-            this, m, a, offset,\n-            (arr, off, v, vm) -> {\n-                ByteBuffer wb = wrapper(arr, NATIVE_ENDIAN);\n-                v.stOp(wb, off, vm,\n-                        (tb_, o, i, e) -> tb_.put{#if[byte]?(:$Type$(}o + i * $sizeInBytes$, e));\n-            });\n-    }\n-\n-    @ForceInline\n-    final\n-    void intoByteBuffer0(ByteBuffer bb, int offset) {\n-        $Type$Species vsp = vspecies();\n-        ScopedMemoryAccess.storeIntoByteBuffer(\n+        ScopedMemoryAccess.storeIntoMemorySegment(\n@@ -5040,5 +5086,4 @@\n-                this, bb, offset,\n-                (buf, off, v) -> {\n-                    ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n-                    v.stOp(wb, off,\n-                            (wb_, o, i, e) -> wb_.put{#if[byte]?(:$Type$(}o + i * $sizeInBytes$, e));\n+                this,\n+                (MemorySegmentProxy) ms, offset,\n+                (msp, off, v) -> {\n+                    v.stLongOp((MemorySegment) msp, off, $abstractvectortype$::memorySegmentSet);\n@@ -5049,1 +5094,1 @@\n-    void intoByteBuffer0(ByteBuffer bb, int offset, VectorMask<$Boxtype$> m);\n+    void intoMemorySegment0(MemorySegment bb, long offset, VectorMask<$Boxtype$> m);\n@@ -5053,1 +5098,1 @@\n-    void intoByteBuffer0Template(Class<M> maskClass, ByteBuffer bb, int offset, M m) {\n+    void intoMemorySegment0Template(Class<M> maskClass, MemorySegment ms, long offset, M m) {\n@@ -5056,1 +5101,1 @@\n-        ScopedMemoryAccess.storeIntoByteBufferMasked(\n+        ScopedMemoryAccess.storeIntoMemorySegmentMasked(\n@@ -5058,5 +5103,4 @@\n-                this, m, bb, offset,\n-                (buf, off, v, vm) -> {\n-                    ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n-                    v.stOp(wb, off, vm,\n-                            (wb_, o, i, e) -> wb_.put{#if[byte]?(:$Type$(}o + i * $sizeInBytes$, e));\n+                this, m,\n+                (MemorySegmentProxy) ms, offset,\n+                (msp, off, v, vm) -> {\n+                    v.stLongOp((MemorySegment) msp, off, vm, $abstractvectortype$::memorySegmentSet);\n@@ -5081,1 +5125,1 @@\n-            -> v.stOp(arr, off, vm,\n+            -> v.stOp(arr, (int) off, vm,\n@@ -5098,0 +5142,10 @@\n+    private static\n+    void checkMaskFromIndexSize(long offset,\n+                                $Type$Species vsp,\n+                                VectorMask<$Boxtype$> m,\n+                                int scale,\n+                                long limit) {\n+        ((AbstractMask<$Boxtype$>)m)\n+            .checkIndexByLane(offset, limit, vsp.iota(), scale);\n+    }\n+\n@@ -5466,0 +5520,15 @@\n+        \/*package-private*\/\n+        @ForceInline\n+        $abstractvectortype$ ldLongOp(MemorySegment memory, long offset,\n+                                      FLdLongOp f) {\n+            return dummyVector().ldLongOp(memory, offset, f);\n+        }\n+\n+        \/*package-private*\/\n+        @ForceInline\n+        $abstractvectortype$ ldLongOp(MemorySegment memory, long offset,\n+                                      VectorMask<$Boxtype$> m,\n+                                      FLdLongOp f) {\n+            return dummyVector().ldLongOp(memory, offset, m, f);\n+        }\n+\n@@ -5479,0 +5548,14 @@\n+\n+        \/*package-private*\/\n+        @ForceInline\n+        void stLongOp(MemorySegment memory, long offset, FStLongOp f) {\n+            dummyVector().stLongOp(memory, offset, f);\n+        }\n+\n+        \/*package-private*\/\n+        @ForceInline\n+        void stLongOp(MemorySegment memory, long offset,\n+                      AbstractMask<$Boxtype$> m,\n+                      FStLongOp f) {\n+            dummyVector().stLongOp(memory, offset, m, f);\n+        }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-Vector.java.template","additions":366,"deletions":283,"binary":false,"changes":649,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import java.nio.ByteBuffer;\n@@ -32,0 +31,1 @@\n+import jdk.incubator.foreign.MemorySegment;\n@@ -483,0 +483,16 @@\n+    @Override\n+    @ForceInline\n+    public $vectortype$ compress(VectorMask<$Boxtype$> m) {\n+        return ($vectortype$)\n+            super.compressTemplate($masktype$.class,\n+                                   ($masktype$) m);  \/\/ specialize\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public $vectortype$ expand(VectorMask<$Boxtype$> m) {\n+        return ($vectortype$)\n+            super.expandTemplate($masktype$.class,\n+                                   ($masktype$) m);  \/\/ specialize\n+    }\n+\n@@ -923,0 +939,9 @@\n+        @Override\n+        @ForceInline\n+        public $masktype$ compress() {\n+            return ($masktype$)VectorSupport.compressExpandOp(VectorSupport.VECTOR_OP_MASK_COMPRESS,\n+                $vectortype$.class, $masktype$.class, ETYPE, VLENGTH, null, this,\n+                (v1, m1) -> VSPECIES.iota().compare(VectorOperators.LT, m1.trueCount()));\n+        }\n+\n+\n@@ -1162,2 +1187,2 @@\n-    $abstractvectortype$ fromByteArray0(byte[] a, int offset) {\n-        return super.fromByteArray0Template(a, offset);  \/\/ specialize\n+    $abstractvectortype$ fromMemorySegment0(MemorySegment ms, long offset) {\n+        return super.fromMemorySegment0Template(ms, offset);  \/\/ specialize\n@@ -1169,16 +1194,2 @@\n-    $abstractvectortype$ fromByteArray0(byte[] a, int offset, VectorMask<$Boxtype$> m) {\n-        return super.fromByteArray0Template($masktype$.class, a, offset, ($masktype$) m);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    $abstractvectortype$ fromByteBuffer0(ByteBuffer bb, int offset) {\n-        return super.fromByteBuffer0Template(bb, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    $abstractvectortype$ fromByteBuffer0(ByteBuffer bb, int offset, VectorMask<$Boxtype$> m) {\n-        return super.fromByteBuffer0Template($masktype$.class, bb, offset, ($masktype$) m);  \/\/ specialize\n+    $abstractvectortype$ fromMemorySegment0(MemorySegment ms, long offset, VectorMask<$Boxtype$> m) {\n+        return super.fromMemorySegment0Template($masktype$.class, ms, offset, ($masktype$) m);  \/\/ specialize\n@@ -1222,16 +1233,2 @@\n-    void intoByteArray0(byte[] a, int offset) {\n-        super.intoByteArray0Template(a, offset);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoByteArray0(byte[] a, int offset, VectorMask<$Boxtype$> m) {\n-        super.intoByteArray0Template($masktype$.class, a, offset, ($masktype$) m);  \/\/ specialize\n-    }\n-\n-    @ForceInline\n-    @Override\n-    final\n-    void intoByteBuffer0(ByteBuffer bb, int offset, VectorMask<$Boxtype$> m) {\n-        super.intoByteBuffer0Template($masktype$.class, bb, offset, ($masktype$) m);\n+    void intoMemorySegment0(MemorySegment ms, long offset, VectorMask<$Boxtype$> m) {\n+        super.intoMemorySegment0Template($masktype$.class, ms, offset, ($masktype$) m);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-VectorBits.java.template","additions":32,"deletions":35,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -35,0 +35,2 @@\n+    requires transitive jdk.incubator.foreign;\n+\n","filename":"src\/jdk.incubator.vector\/share\/classes\/module-info.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -227,0 +227,2 @@\n+        GFNI,\n+        AVX512_BITALG,\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.amd64\/src\/jdk\/vm\/ci\/amd64\/AMD64.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1772,0 +1772,4 @@\n+                        [\"index\",   \"__ sve_index(z6, __ B, r5, 2);\",                     \"index\\tz6.b, w5, #2\"],\n+                        [\"index\",   \"__ sve_index(z6, __ H, r5, 3);\",                     \"index\\tz6.h, w5, #3\"],\n+                        [\"index\",   \"__ sve_index(z6, __ S, r5, 4);\",                     \"index\\tz6.s, w5, #4\"],\n+                        [\"index\",   \"__ sve_index(z7, __ D, r5, 5);\",                     \"index\\tz7.d, x5, #5\"],\n@@ -1814,0 +1818,2 @@\n+                        [\"compact\", \"__ sve_compact(z16, __ S, z16, p1);\",                \"compact\\tz16.s, p1, z16.s\"],\n+                        [\"compact\", \"__ sve_compact(z16, __ D, z16, p1);\",                \"compact\\tz16.d, p1, z16.d\"],\n@@ -1815,0 +1821,3 @@\n+                        # SVE2 instructions\n+                        [\"histcnt\", \"__ sve_histcnt(z16, __ S, p0, z16, z16);\",           \"histcnt\\tz16.s, p0\/z, z16.s, z16.s\"],\n+                        [\"histcnt\", \"__ sve_histcnt(z17, __ D, p0, z17, z17);\",           \"histcnt\\tz17.d, p0\/z, z17.d, z17.d\"],\n@@ -1858,0 +1867,1 @@\n+                       [\"clz\", \"ZPZ\", \"m\"],\n@@ -1866,0 +1876,2 @@\n+                       [\"rbit\", \"ZPZ\", \"m\"],\n+                       [\"revb\", \"ZPZ\", \"m\"],\n@@ -1907,2 +1919,3 @@\n-# compile for sve with 8.3 and sha3 because of SHA3 crypto extension.\n-subprocess.check_call([AARCH64_AS, \"-march=armv8.3-a+sha3+sve\", \"aarch64ops.s\", \"-o\", \"aarch64ops.o\"])\n+# compile for sve with armv9-a+sha3 because of SHA3 crypto extension and SVE2 instructions.\n+# armv9-a enables sve and sve2 by default.\n+subprocess.check_call([AARCH64_AS, \"-march=armv9-a+sha3\", \"aarch64ops.s\", \"-o\", \"aarch64ops.o\"])\n","filename":"test\/hotspot\/gtest\/aarch64\/aarch64-asmtest.py","additions":15,"deletions":2,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -916,0 +916,4 @@\n+    __ sve_index(z6, __ B, r5, 2);                     \/\/       index   z6.b, w5, #2\n+    __ sve_index(z6, __ H, r5, 3);                     \/\/       index   z6.h, w5, #3\n+    __ sve_index(z6, __ S, r5, 4);                     \/\/       index   z6.s, w5, #4\n+    __ sve_index(z7, __ D, r5, 5);                     \/\/       index   z7.d, x5, #5\n@@ -958,0 +962,2 @@\n+    __ sve_compact(z16, __ S, z16, p1);                \/\/       compact z16.s, p1, z16.s\n+    __ sve_compact(z16, __ D, z16, p1);                \/\/       compact z16.d, p1, z16.d\n@@ -959,0 +965,2 @@\n+    __ sve_histcnt(z16, __ S, p0, z16, z16);           \/\/       histcnt z16.s, p0\/z, z16.s, z16.s\n+    __ sve_histcnt(z17, __ D, p0, z17, z17);           \/\/       histcnt z17.d, p0\/z, z17.d, z17.d\n@@ -1147,39 +1155,42 @@\n-    __ sve_cnt(z11, __ S, p3, z11);                    \/\/       cnt     z11.s, p3\/m, z11.s\n-    __ sve_eor(z1, __ S, p6, z8);                      \/\/       eor     z1.s, p6\/m, z1.s, z8.s\n-    __ sve_lsl(z13, __ S, p4, z17);                    \/\/       lsl     z13.s, p4\/m, z13.s, z17.s\n-    __ sve_lsr(z4, __ H, p0, z3);                      \/\/       lsr     z4.h, p0\/m, z4.h, z3.h\n-    __ sve_mul(z7, __ S, p3, z14);                     \/\/       mul     z7.s, p3\/m, z7.s, z14.s\n-    __ sve_neg(z4, __ B, p3, z29);                     \/\/       neg     z4.b, p3\/m, z29.b\n-    __ sve_not(z0, __ D, p2, z21);                     \/\/       not     z0.d, p2\/m, z21.d\n-    __ sve_orr(z3, __ S, p0, z9);                      \/\/       orr     z3.s, p0\/m, z3.s, z9.s\n-    __ sve_smax(z28, __ B, p2, z24);                   \/\/       smax    z28.b, p2\/m, z28.b, z24.b\n-    __ sve_smin(z19, __ D, p1, z23);                   \/\/       smin    z19.d, p1\/m, z19.d, z23.d\n-    __ sve_sub(z13, __ D, p5, z10);                    \/\/       sub     z13.d, p5\/m, z13.d, z10.d\n-    __ sve_fabs(z12, __ D, p4, z30);                   \/\/       fabs    z12.d, p4\/m, z30.d\n-    __ sve_fadd(z14, __ D, p0, z29);                   \/\/       fadd    z14.d, p0\/m, z14.d, z29.d\n-    __ sve_fdiv(z21, __ D, p5, z7);                    \/\/       fdiv    z21.d, p5\/m, z21.d, z7.d\n-    __ sve_fmax(z2, __ D, p0, z26);                    \/\/       fmax    z2.d, p0\/m, z2.d, z26.d\n-    __ sve_fmin(z9, __ D, p4, z17);                    \/\/       fmin    z9.d, p4\/m, z9.d, z17.d\n-    __ sve_fmul(z0, __ D, p1, z2);                     \/\/       fmul    z0.d, p1\/m, z0.d, z2.d\n-    __ sve_fneg(z14, __ D, p1, z11);                   \/\/       fneg    z14.d, p1\/m, z11.d\n-    __ sve_frintm(z14, __ S, p4, z29);                 \/\/       frintm  z14.s, p4\/m, z29.s\n-    __ sve_frintn(z3, __ S, p0, z22);                  \/\/       frintn  z3.s, p0\/m, z22.s\n-    __ sve_frintp(z3, __ S, p6, z27);                  \/\/       frintp  z3.s, p6\/m, z27.s\n-    __ sve_fsqrt(z19, __ D, p5, z7);                   \/\/       fsqrt   z19.d, p5\/m, z7.d\n-    __ sve_fsub(z21, __ S, p3, z5);                    \/\/       fsub    z21.s, p3\/m, z21.s, z5.s\n-    __ sve_fmad(z25, __ D, p1, z21, z17);              \/\/       fmad    z25.d, p1\/m, z21.d, z17.d\n-    __ sve_fmla(z0, __ S, p0, z9, z19);                \/\/       fmla    z0.s, p0\/m, z9.s, z19.s\n-    __ sve_fmls(z7, __ D, p3, z14, z17);               \/\/       fmls    z7.d, p3\/m, z14.d, z17.d\n-    __ sve_fmsb(z11, __ D, p3, z24, z17);              \/\/       fmsb    z11.d, p3\/m, z24.d, z17.d\n-    __ sve_fnmad(z17, __ D, p2, z15, z14);             \/\/       fnmad   z17.d, p2\/m, z15.d, z14.d\n-    __ sve_fnmsb(z22, __ S, p7, z22, z7);              \/\/       fnmsb   z22.s, p7\/m, z22.s, z7.s\n-    __ sve_fnmla(z5, __ S, p7, z27, z10);              \/\/       fnmla   z5.s, p7\/m, z27.s, z10.s\n-    __ sve_fnmls(z14, __ S, p6, z21, z20);             \/\/       fnmls   z14.s, p6\/m, z21.s, z20.s\n-    __ sve_mla(z3, __ D, p5, z25, z5);                 \/\/       mla     z3.d, p5\/m, z25.d, z5.d\n-    __ sve_mls(z29, __ H, p4, z17, z1);                \/\/       mls     z29.h, p4\/m, z17.h, z1.h\n-    __ sve_and(z14, z29, z13);                         \/\/       and     z14.d, z29.d, z13.d\n-    __ sve_eor(z17, z2, z30);                          \/\/       eor     z17.d, z2.d, z30.d\n-    __ sve_orr(z22, z21, z29);                         \/\/       orr     z22.d, z21.d, z29.d\n-    __ sve_bic(z8, z2, z0);                            \/\/       bic     z8.d, z2.d, z0.d\n-    __ sve_uzp1(z23, __ S, z22, z0);                   \/\/       uzp1    z23.s, z22.s, z0.s\n-    __ sve_uzp2(z25, __ H, z26, z23);                  \/\/       uzp2    z25.h, z26.h, z23.h\n+    __ sve_clz(z11, __ S, p3, z11);                    \/\/       clz     z11.s, p3\/m, z11.s\n+    __ sve_cnt(z1, __ S, p6, z8);                      \/\/       cnt     z1.s, p6\/m, z8.s\n+    __ sve_eor(z13, __ S, p4, z17);                    \/\/       eor     z13.s, p4\/m, z13.s, z17.s\n+    __ sve_lsl(z4, __ H, p0, z3);                      \/\/       lsl     z4.h, p0\/m, z4.h, z3.h\n+    __ sve_lsr(z7, __ S, p3, z14);                     \/\/       lsr     z7.s, p3\/m, z7.s, z14.s\n+    __ sve_mul(z4, __ B, p3, z29);                     \/\/       mul     z4.b, p3\/m, z4.b, z29.b\n+    __ sve_neg(z0, __ D, p2, z21);                     \/\/       neg     z0.d, p2\/m, z21.d\n+    __ sve_not(z3, __ S, p0, z9);                      \/\/       not     z3.s, p0\/m, z9.s\n+    __ sve_orr(z28, __ B, p2, z24);                    \/\/       orr     z28.b, p2\/m, z28.b, z24.b\n+    __ sve_rbit(z19, __ D, p1, z23);                   \/\/       rbit    z19.d, p1\/m, z23.d\n+    __ sve_revb(z13, __ D, p5, z10);                   \/\/       revb    z13.d, p5\/m, z10.d\n+    __ sve_smax(z12, __ S, p4, z30);                   \/\/       smax    z12.s, p4\/m, z12.s, z30.s\n+    __ sve_smin(z14, __ S, p0, z29);                   \/\/       smin    z14.s, p0\/m, z14.s, z29.s\n+    __ sve_sub(z21, __ S, p5, z7);                     \/\/       sub     z21.s, p5\/m, z21.s, z7.s\n+    __ sve_fabs(z2, __ D, p0, z26);                    \/\/       fabs    z2.d, p0\/m, z26.d\n+    __ sve_fadd(z9, __ D, p4, z17);                    \/\/       fadd    z9.d, p4\/m, z9.d, z17.d\n+    __ sve_fdiv(z0, __ D, p1, z2);                     \/\/       fdiv    z0.d, p1\/m, z0.d, z2.d\n+    __ sve_fmax(z14, __ D, p1, z11);                   \/\/       fmax    z14.d, p1\/m, z14.d, z11.d\n+    __ sve_fmin(z14, __ S, p4, z29);                   \/\/       fmin    z14.s, p4\/m, z14.s, z29.s\n+    __ sve_fmul(z3, __ S, p0, z22);                    \/\/       fmul    z3.s, p0\/m, z3.s, z22.s\n+    __ sve_fneg(z3, __ S, p6, z27);                    \/\/       fneg    z3.s, p6\/m, z27.s\n+    __ sve_frintm(z19, __ D, p5, z7);                  \/\/       frintm  z19.d, p5\/m, z7.d\n+    __ sve_frintn(z21, __ S, p3, z5);                  \/\/       frintn  z21.s, p3\/m, z5.s\n+    __ sve_frintp(z25, __ D, p1, z21);                 \/\/       frintp  z25.d, p1\/m, z21.d\n+    __ sve_fsqrt(z17, __ S, p0, z3);                   \/\/       fsqrt   z17.s, p0\/m, z3.s\n+    __ sve_fsub(z19, __ S, p3, z7);                    \/\/       fsub    z19.s, p3\/m, z19.s, z7.s\n+    __ sve_fmad(z14, __ S, p4, z17, z11);              \/\/       fmad    z14.s, p4\/m, z17.s, z11.s\n+    __ sve_fmla(z24, __ S, p4, z30, z17);              \/\/       fmla    z24.s, p4\/m, z30.s, z17.s\n+    __ sve_fmls(z15, __ D, p3, z26, z22);              \/\/       fmls    z15.d, p3\/m, z26.d, z22.d\n+    __ sve_fmsb(z22, __ D, p2, z8, z5);                \/\/       fmsb    z22.d, p2\/m, z8.d, z5.d\n+    __ sve_fnmad(z27, __ D, p2, z0, z14);              \/\/       fnmad   z27.d, p2\/m, z0.d, z14.d\n+    __ sve_fnmsb(z21, __ D, p5, z0, z3);               \/\/       fnmsb   z21.d, p5\/m, z0.d, z3.d\n+    __ sve_fnmla(z25, __ D, p1, z25, z29);             \/\/       fnmla   z25.d, p1\/m, z25.d, z29.d\n+    __ sve_fnmls(z17, __ D, p0, z12, z14);             \/\/       fnmls   z17.d, p0\/m, z12.d, z14.d\n+    __ sve_mla(z13, __ D, p0, z17, z2);                \/\/       mla     z13.d, p0\/m, z17.d, z2.d\n+    __ sve_mls(z20, __ H, p5, z21, z29);               \/\/       mls     z20.h, p5\/m, z21.h, z29.h\n+    __ sve_and(z8, z2, z0);                            \/\/       and     z8.d, z2.d, z0.d\n+    __ sve_eor(z23, z22, z0);                          \/\/       eor     z23.d, z22.d, z0.d\n+    __ sve_orr(z25, z26, z23);                         \/\/       orr     z25.d, z26.d, z23.d\n+    __ sve_bic(z21, z21, z1);                          \/\/       bic     z21.d, z21.d, z1.d\n+    __ sve_uzp1(z10, __ S, z19, z11);                  \/\/       uzp1    z10.s, z19.s, z11.s\n+    __ sve_uzp2(z23, __ D, z23, z8);                   \/\/       uzp2    z23.d, z23.d, z8.d\n@@ -1188,9 +1199,9 @@\n-    __ sve_andv(v21, __ B, p5, z1);                    \/\/       andv b21, p5, z1.b\n-    __ sve_orv(v10, __ S, p5, z11);                    \/\/       orv s10, p5, z11.s\n-    __ sve_eorv(v23, __ D, p6, z8);                    \/\/       eorv d23, p6, z8.d\n-    __ sve_smaxv(v17, __ S, p5, z19);                  \/\/       smaxv s17, p5, z19.s\n-    __ sve_sminv(v4, __ D, p5, z13);                   \/\/       sminv d4, p5, z13.d\n-    __ sve_fminv(v22, __ D, p7, z30);                  \/\/       fminv d22, p7, z30.d\n-    __ sve_fmaxv(v17, __ S, p4, z14);                  \/\/       fmaxv s17, p4, z14.s\n-    __ sve_fadda(v12, __ S, p7, z20);                  \/\/       fadda s12, p7, s12, z20.s\n-    __ sve_uaddv(v1, __ B, p3, z13);                   \/\/       uaddv d1, p3, z13.b\n+    __ sve_andv(v17, __ S, p5, z19);                   \/\/       andv s17, p5, z19.s\n+    __ sve_orv(v4, __ D, p5, z13);                     \/\/       orv d4, p5, z13.d\n+    __ sve_eorv(v22, __ D, p7, z30);                   \/\/       eorv d22, p7, z30.d\n+    __ sve_smaxv(v17, __ H, p4, z14);                  \/\/       smaxv h17, p4, z14.h\n+    __ sve_sminv(v12, __ B, p7, z20);                  \/\/       sminv b12, p7, z20.b\n+    __ sve_fminv(v1, __ S, p3, z13);                   \/\/       fminv s1, p3, z13.s\n+    __ sve_fmaxv(v7, __ D, p2, z11);                   \/\/       fmaxv d7, p2, z11.d\n+    __ sve_fadda(v4, __ S, p6, z15);                   \/\/       fadda s4, p6, s4, z15.s\n+    __ sve_uaddv(v3, __ S, p7, z0);                    \/\/       uaddv d3, p7, z0.s\n@@ -1215,7 +1226,7 @@\n-    0x14000000,     0x17ffffd7,     0x140003e4,     0x94000000,\n-    0x97ffffd4,     0x940003e1,     0x3400000a,     0x34fffa2a,\n-    0x34007bca,     0x35000008,     0x35fff9c8,     0x35007b68,\n-    0xb400000b,     0xb4fff96b,     0xb4007b0b,     0xb500001d,\n-    0xb5fff91d,     0xb5007abd,     0x10000013,     0x10fff8b3,\n-    0x10007a53,     0x90000013,     0x36300016,     0x3637f836,\n-    0x363079d6,     0x3758000c,     0x375ff7cc,     0x3758796c,\n+    0x14000000,     0x17ffffd7,     0x140003ef,     0x94000000,\n+    0x97ffffd4,     0x940003ec,     0x3400000a,     0x34fffa2a,\n+    0x34007d2a,     0x35000008,     0x35fff9c8,     0x35007cc8,\n+    0xb400000b,     0xb4fff96b,     0xb4007c6b,     0xb500001d,\n+    0xb5fff91d,     0xb5007c1d,     0x10000013,     0x10fff8b3,\n+    0x10007bb3,     0x90000013,     0x36300016,     0x3637f836,\n+    0x36307b36,     0x3758000c,     0x375ff7cc,     0x37587acc,\n@@ -1226,13 +1237,13 @@\n-    0x54007740,     0x54000001,     0x54fff541,     0x540076e1,\n-    0x54000002,     0x54fff4e2,     0x54007682,     0x54000002,\n-    0x54fff482,     0x54007622,     0x54000003,     0x54fff423,\n-    0x540075c3,     0x54000003,     0x54fff3c3,     0x54007563,\n-    0x54000004,     0x54fff364,     0x54007504,     0x54000005,\n-    0x54fff305,     0x540074a5,     0x54000006,     0x54fff2a6,\n-    0x54007446,     0x54000007,     0x54fff247,     0x540073e7,\n-    0x54000008,     0x54fff1e8,     0x54007388,     0x54000009,\n-    0x54fff189,     0x54007329,     0x5400000a,     0x54fff12a,\n-    0x540072ca,     0x5400000b,     0x54fff0cb,     0x5400726b,\n-    0x5400000c,     0x54fff06c,     0x5400720c,     0x5400000d,\n-    0x54fff00d,     0x540071ad,     0x5400000e,     0x54ffefae,\n-    0x5400714e,     0x5400000f,     0x54ffef4f,     0x540070ef,\n+    0x540078a0,     0x54000001,     0x54fff541,     0x54007841,\n+    0x54000002,     0x54fff4e2,     0x540077e2,     0x54000002,\n+    0x54fff482,     0x54007782,     0x54000003,     0x54fff423,\n+    0x54007723,     0x54000003,     0x54fff3c3,     0x540076c3,\n+    0x54000004,     0x54fff364,     0x54007664,     0x54000005,\n+    0x54fff305,     0x54007605,     0x54000006,     0x54fff2a6,\n+    0x540075a6,     0x54000007,     0x54fff247,     0x54007547,\n+    0x54000008,     0x54fff1e8,     0x540074e8,     0x54000009,\n+    0x54fff189,     0x54007489,     0x5400000a,     0x54fff12a,\n+    0x5400742a,     0x5400000b,     0x54fff0cb,     0x540073cb,\n+    0x5400000c,     0x54fff06c,     0x5400736c,     0x5400000d,\n+    0x54fff00d,     0x5400730d,     0x5400000e,     0x54ffefae,\n+    0x540072ae,     0x5400000f,     0x54ffef4f,     0x5400724f,\n@@ -1403,1 +1414,2 @@\n-    0x052281e0,     0x05238601,     0x04a14026,     0x0568aca7,\n+    0x052281e0,     0x05238601,     0x04a14026,     0x042244a6,\n+    0x046344a6,     0x04a444a6,     0x04e544a7,     0x0568aca7,\n@@ -1414,1 +1426,2 @@\n-    0x05314001,     0x05271e11,     0x1e601000,     0x1e603000,\n+    0x05314001,     0x05a18610,     0x05e18610,     0x05271e11,\n+    0x45b0c210,     0x45f1c231,     0x1e601000,     0x1e603000,\n@@ -1452,13 +1465,14 @@\n-    0x049089bc,     0x045b1787,     0x049aad6b,     0x04991901,\n-    0x0493922d,     0x04518064,     0x04900dc7,     0x0417afa4,\n-    0x04deaaa0,     0x04980123,     0x04080b1c,     0x04ca06f3,\n-    0x04c1154d,     0x04dcb3cc,     0x65c083ae,     0x65cd94f5,\n-    0x65c68342,     0x65c79229,     0x65c28440,     0x04dda56e,\n-    0x6582b3ae,     0x6580a2c3,     0x6581bb63,     0x65cdb4f3,\n-    0x65818cb5,     0x65f186b9,     0x65b30120,     0x65f12dc7,\n-    0x65f1af0b,     0x65eec9f1,     0x65a7fed6,     0x65aa5f65,\n-    0x65b47aae,     0x04c55723,     0x0441723d,     0x042d33ae,\n-    0x04be3051,     0x047d32b6,     0x04e03048,     0x05a06ad7,\n-    0x05776f59,     0x041a3435,     0x0498356a,     0x04d93917,\n-    0x04883671,     0x04ca35a4,     0x65c73fd6,     0x658631d1,\n-    0x65983e8c,     0x04012da1,\n+    0x049089bc,     0x045b1787,     0x0499ad6b,     0x049ab901,\n+    0x0499122d,     0x04538064,     0x04918dc7,     0x04100fa4,\n+    0x04d7aaa0,     0x049ea123,     0x04180b1c,     0x05e786f3,\n+    0x05e4954d,     0x048813cc,     0x048a03ae,     0x048114f5,\n+    0x04dca342,     0x65c09229,     0x65cd8440,     0x65c6856e,\n+    0x658793ae,     0x658282c3,     0x049dbb63,     0x65c2b4f3,\n+    0x6580acb5,     0x65c1a6b9,     0x658da071,     0x65818cf3,\n+    0x65ab922e,     0x65b113d8,     0x65f62f4f,     0x65e5a916,\n+    0x65eec81b,     0x65e3f415,     0x65fd4739,     0x65ee6191,\n+    0x04c2422d,     0x045d76b4,     0x04203048,     0x04a032d7,\n+    0x04773359,     0x04e132b5,     0x05ab6a6a,     0x05e86ef7,\n+    0x049a3671,     0x04d835a4,     0x04d93fd6,     0x044831d1,\n+    0x040a3e8c,     0x65872da1,     0x65c62967,     0x659839e4,\n+    0x04813c03,\n","filename":"test\/hotspot\/gtest\/aarch64\/asmtest.out.h","additions":97,"deletions":83,"binary":false,"changes":180,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (C) 2021 THL A29 Limited, a Tencent company. All rights reserved.\n+ * Copyright (C) 2021, 2022, THL A29 Limited, a Tencent company. All rights reserved.\n@@ -26,0 +26,1 @@\n+import jdk.incubator.foreign.MemorySegment;\n@@ -43,0 +44,2 @@\n+  static MemorySegment msa = MemorySegment.ofArray(a);\n+  static MemorySegment msr = MemorySegment.ofArray(r);\n@@ -45,2 +48,2 @@\n-    DoubleVector av = DoubleVector.fromByteArray(SPECIES256, a, 0, ByteOrder.BIG_ENDIAN);\n-    av.intoByteArray(r, 0, ByteOrder.BIG_ENDIAN);\n+    DoubleVector av = DoubleVector.fromMemorySegment(SPECIES256, msa, 0, ByteOrder.BIG_ENDIAN);\n+    av.intoMemorySegment(msr, 0, ByteOrder.BIG_ENDIAN);\n@@ -48,2 +51,2 @@\n-    DoubleVector bv = DoubleVector.fromByteArray(SPECIES256, a, 32, ByteOrder.LITTLE_ENDIAN);\n-    bv.intoByteArray(r, 32, ByteOrder.LITTLE_ENDIAN);\n+    DoubleVector bv = DoubleVector.fromMemorySegment(SPECIES256, msa, 32, ByteOrder.LITTLE_ENDIAN);\n+    bv.intoMemorySegment(msr, 32, ByteOrder.LITTLE_ENDIAN);\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/TestIntrinsicBailOut.java","additions":8,"deletions":5,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,0 @@\n-import java.nio.ByteBuffer;\n@@ -41,0 +40,1 @@\n+import jdk.incubator.foreign.MemorySegment;\n@@ -56,1 +56,1 @@\n-    final var bb = ByteBuffer.wrap(arr);\n+    final var ms = MemorySegment.ofArray(arr);\n@@ -62,1 +62,1 @@\n-    res.add(ones).intoByteBuffer(bb, 0, ByteOrder.nativeOrder());\n+    res.add(ones).intoMemorySegment(ms, 0L, ByteOrder.nativeOrder());\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/VectorMemoryAlias.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -23,2 +23,0 @@\n-import jdk.incubator.vector.*;\n-import jdk.internal.vm.annotation.ForceInline;\n@@ -29,2 +27,0 @@\n-import java.lang.invoke.MethodHandles;\n-import java.lang.invoke.VarHandle;\n@@ -36,2 +32,3 @@\n-import jdk.incubator.vector.VectorShape;\n-import jdk.incubator.vector.VectorSpecies;\n+\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.vector.*;\n@@ -46,1 +43,1 @@\n- * @run testng\/othervm -XX:CompileCommand=compileonly,jdk\/incubator\/vector\/ByteVector.fromByteBuffer\n+ * @run testng\/othervm -XX:CompileCommand=compileonly,jdk\/incubator\/vector\/ByteVector.fromMemorySegment\n@@ -127,2 +124,4 @@\n-    void testVectorRebracket(VectorSpecies<E> a, VectorSpecies<F> b, byte[] input, byte[] output) {\n-        Vector<E> av = a.fromByteArray(input, 0, ByteOrder.nativeOrder());\n+    void testVectorRebracket(VectorSpecies<E> a, VectorSpecies<F> b,\n+                             byte[] input, byte[] output,\n+                             MemorySegment msInput, MemorySegment msOutput) {\n+        Vector<E> av = a.fromMemorySegment(msInput, 0, ByteOrder.nativeOrder());\n@@ -142,1 +141,1 @@\n-        bv.intoByteArray(output, 0, ByteOrder.nativeOrder());\n+        bv.intoMemorySegment(msOutput, 0, ByteOrder.nativeOrder());\n@@ -155,0 +154,2 @@\n+        MemorySegment msin = MemorySegment.ofArray(barr);\n+        MemorySegment msout = MemorySegment.ofArray(bout);\n@@ -156,3 +157,3 @@\n-            testVectorRebracket(bspec128, bspec128, barr, bout);\n-            testVectorRebracket(bspec128, sspec128, barr, bout);\n-            testVectorRebracket(bspec128, ispec128, barr, bout);\n+            testVectorRebracket(bspec128, bspec128, barr, bout, msin, msout);\n+            testVectorRebracket(bspec128, sspec128, barr, bout, msin, msout);\n+            testVectorRebracket(bspec128, ispec128, barr, bout, msin, msout);\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/VectorRebracket128Test.java","additions":15,"deletions":14,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import jdk.incubator.foreign.MemorySegment;\n@@ -41,1 +42,1 @@\n-    public static void testB64toB128(byte[] input, byte[] output) {\n+    public static void testB64toB128(MemorySegment input, MemorySegment output) {\n@@ -52,1 +53,1 @@\n-    public static void testB64toB256(byte[] input, byte[] output) {\n+    public static void testB64toB256(MemorySegment input, MemorySegment output) {\n@@ -63,1 +64,1 @@\n-    public static void testB64toB512(byte[] input, byte[] output) {\n+    public static void testB64toB512(MemorySegment input, MemorySegment output) {\n@@ -74,1 +75,1 @@\n-    public static void testB128toB64(byte[] input, byte[] output) {\n+    public static void testB128toB64(MemorySegment input, MemorySegment output) {\n@@ -85,1 +86,1 @@\n-    public static void testB128toB256(byte[] input, byte[] output) {\n+    public static void testB128toB256(MemorySegment input, MemorySegment output) {\n@@ -96,1 +97,1 @@\n-    public static void testB128toB512(byte[] input, byte[] output) {\n+    public static void testB128toB512(MemorySegment input, MemorySegment output) {\n@@ -107,1 +108,1 @@\n-    public static void testB256toB64(byte[] input, byte[] output) {\n+    public static void testB256toB64(MemorySegment input, MemorySegment output) {\n@@ -118,1 +119,1 @@\n-    public static void testB256toB128(byte[] input, byte[] output) {\n+    public static void testB256toB128(MemorySegment input, MemorySegment output) {\n@@ -129,1 +130,1 @@\n-    public static void testB256toB512(byte[] input, byte[] output) {\n+    public static void testB256toB512(MemorySegment input, MemorySegment output) {\n@@ -140,1 +141,1 @@\n-    public static void testB512toB64(byte[] input, byte[] output) {\n+    public static void testB512toB64(MemorySegment input, MemorySegment output) {\n@@ -151,1 +152,1 @@\n-    public static void testB512toB128(byte[] input, byte[] output) {\n+    public static void testB512toB128(MemorySegment input, MemorySegment output) {\n@@ -162,1 +163,1 @@\n-    public static void testB512toB256(byte[] input, byte[] output) {\n+    public static void testB512toB256(MemorySegment input, MemorySegment output) {\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/reshape\/tests\/TestVectorDoubleExpandShrink.java","additions":14,"deletions":13,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import jdk.incubator.foreign.MemorySegment;\n@@ -41,1 +42,1 @@\n-    public static void testB64toB128(byte[] input, byte[] output) {\n+    public static void testB64toB128(MemorySegment input, MemorySegment output) {\n@@ -52,1 +53,1 @@\n-    public static void testB64toB256(byte[] input, byte[] output) {\n+    public static void testB64toB256(MemorySegment input, MemorySegment output) {\n@@ -63,1 +64,1 @@\n-    public static void testB64toB512(byte[] input, byte[] output) {\n+    public static void testB64toB512(MemorySegment input, MemorySegment output) {\n@@ -74,1 +75,1 @@\n-    public static void testB128toB64(byte[] input, byte[] output) {\n+    public static void testB128toB64(MemorySegment input, MemorySegment output) {\n@@ -85,1 +86,1 @@\n-    public static void testB128toB256(byte[] input, byte[] output) {\n+    public static void testB128toB256(MemorySegment input, MemorySegment output) {\n@@ -96,1 +97,1 @@\n-    public static void testB128toB512(byte[] input, byte[] output) {\n+    public static void testB128toB512(MemorySegment input, MemorySegment output) {\n@@ -107,1 +108,1 @@\n-    public static void testB256toB64(byte[] input, byte[] output) {\n+    public static void testB256toB64(MemorySegment input, MemorySegment output) {\n@@ -118,1 +119,1 @@\n-    public static void testB256toB128(byte[] input, byte[] output) {\n+    public static void testB256toB128(MemorySegment input, MemorySegment output) {\n@@ -129,1 +130,1 @@\n-    public static void testB256toB512(byte[] input, byte[] output) {\n+    public static void testB256toB512(MemorySegment input, MemorySegment output) {\n@@ -140,1 +141,1 @@\n-    public static void testB512toB64(byte[] input, byte[] output) {\n+    public static void testB512toB64(MemorySegment input, MemorySegment output) {\n@@ -151,1 +152,1 @@\n-    public static void testB512toB128(byte[] input, byte[] output) {\n+    public static void testB512toB128(MemorySegment input, MemorySegment output) {\n@@ -162,1 +163,1 @@\n-    public static void testB512toB256(byte[] input, byte[] output) {\n+    public static void testB512toB256(MemorySegment input, MemorySegment output) {\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/reshape\/tests\/TestVectorExpandShrink.java","additions":14,"deletions":13,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+import jdk.incubator.foreign.MemorySegment;\n@@ -216,2 +217,3 @@\n-    public static void vectorExpandShrink(VectorSpecies<Byte> isp, VectorSpecies<Byte> osp, byte[] input, byte[] output) {\n-        isp.fromByteArray(input, 0, ByteOrder.nativeOrder())\n+    public static void vectorExpandShrink(VectorSpecies<Byte> isp, VectorSpecies<Byte> osp,\n+                                          MemorySegment input, MemorySegment output) {\n+        isp.fromMemorySegment(input, 0, ByteOrder.nativeOrder())\n@@ -219,1 +221,1 @@\n-                .intoByteArray(output, 0, ByteOrder.nativeOrder());\n+                .intoMemorySegment(output, 0, ByteOrder.nativeOrder());\n@@ -228,1 +230,1 @@\n-                MethodType.methodType(void.class, byte.class.arrayType(), byte.class.arrayType()));\n+                MethodType.methodType(void.class, MemorySegment.class, MemorySegment.class));\n@@ -231,0 +233,2 @@\n+        MemorySegment msInput = MemorySegment.ofArray(input);\n+        MemorySegment msOutput = MemorySegment.ofArray(output);\n@@ -234,1 +238,1 @@\n-            testMethod.invokeExact(input, output);\n+            testMethod.invokeExact(msInput, msOutput);\n@@ -245,2 +249,3 @@\n-    public static void vectorDoubleExpandShrink(VectorSpecies<Byte> isp, VectorSpecies<Byte> osp, byte[] input, byte[] output) {\n-        isp.fromByteArray(input, 0, ByteOrder.nativeOrder())\n+    public static void vectorDoubleExpandShrink(VectorSpecies<Byte> isp, VectorSpecies<Byte> osp,\n+                                                MemorySegment input, MemorySegment output) {\n+        isp.fromMemorySegment(input, 0, ByteOrder.nativeOrder())\n@@ -249,1 +254,1 @@\n-                .intoByteArray(output, 0, ByteOrder.nativeOrder());\n+                .intoMemorySegment(output, 0, ByteOrder.nativeOrder());\n@@ -258,1 +263,1 @@\n-                MethodType.methodType(void.class, byte.class.arrayType(), byte.class.arrayType()));\n+                MethodType.methodType(void.class, MemorySegment.class, MemorySegment.class));\n@@ -261,0 +266,2 @@\n+        MemorySegment msInput = MemorySegment.ofArray(input);\n+        MemorySegment msOutput = MemorySegment.ofArray(output);\n@@ -264,1 +271,1 @@\n-            testMethod.invokeExact(input, output);\n+            testMethod.invokeExact(msInput, msOutput);\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/reshape\/utils\/VectorReshapeHelper.java","additions":17,"deletions":10,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -28,2 +28,2 @@\n-* @requires vm.cpu.features ~= \".*avx512bw.*\"\n-* @requires os.arch==\"x86\" | os.arch==\"i386\" | os.arch==\"amd64\" | os.arch==\"x86_64\"\n+* @requires vm.cpu.features ~= \".*avx512bw.*\" | vm.cpu.features ~= \".*sve.*\"\n+* @requires os.arch==\"x86\" | os.arch==\"i386\" | os.arch==\"amd64\" | os.arch==\"x86_64\" | os.arch==\"aarch64\"\n@@ -60,1 +60,1 @@\n-    @IR(counts = {\"PopCountVL\", \">= 1\"}) \/\/ Atleast one PopCountVL node is generated if vectorization is successful\n+    @IR(counts = {\"PopCountVL\", \">= 1\"}) \/\/ At least one PopCountVL node is generated if vectorization is successful\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/TestPopCountVectorLong.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -54,0 +54,11 @@\n+\n+    static final List<IntFunction<MemorySegment>> MEMORY_SEGMENT_GENERATORS = List.of(\n+            withToString(\"HMS\", (int s) -> {\n+                return MemorySegment.allocateNative(s, ResourceScope.newImplicitScope());\n+            }),\n+            withToString(\"DMS\", (int s) -> {\n+                byte[] b = new byte[s];\n+                return MemorySegment.ofArray(b);\n+            })\n+    );\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/AbstractVectorLoadStoreTest.java","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,3 @@\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.ValueLayout;\n@@ -42,1 +45,0 @@\n-import java.nio.ByteBuffer;\n@@ -44,1 +46,0 @@\n-import java.nio.ReadOnlyBufferException;\n@@ -69,1 +70,0 @@\n-\n@@ -109,1 +109,1 @@\n-    \/\/ Relative to byte[] array.length or ByteBuffer.limit()\n+    \/\/ Relative to byte[] array.length or MemorySegment.byteSize()\n@@ -180,1 +180,1 @@\n-    public Object[][] byteByteBufferProvider() {\n+    public Object[][] byteMemorySegmentProvider() {\n@@ -182,1 +182,1 @@\n-                flatMap(fa -> BYTE_BUFFER_GENERATORS.stream().\n+                flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n@@ -190,1 +190,1 @@\n-    public Object[][] byteByteBufferMaskProvider() {\n+    public Object[][] byteMemorySegmentMaskProvider() {\n@@ -193,1 +193,1 @@\n-                        flatMap(fa -> BYTE_BUFFER_GENERATORS.stream().\n+                        flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n@@ -200,19 +200,0 @@\n-    @DataProvider\n-    public Object[][] byteByteArrayProvider() {\n-        return BYTE_GENERATORS.stream().\n-                flatMap(fa -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                    return new Object[]{fa, bo};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] byteByteArrayMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> BYTE_GENERATORS.stream().\n-                    flatMap(fa -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                        return new Object[]{fa, fm, bo};\n-                    }))).\n-                toArray(Object[][]::new);\n-    }\n-\n@@ -238,4 +219,4 @@\n-    static ByteBuffer toBuffer(byte[] a, IntFunction<ByteBuffer> fb) {\n-        ByteBuffer bb = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n-        for (byte v : a) {\n-            bb.put(v);\n+    static MemorySegment toSegment(byte[] a, IntFunction<MemorySegment> fb) {\n+        MemorySegment ms = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n+        for (int i = 0; i < a.length; i++) {\n+            ms.set(ValueLayout.JAVA_BYTE, i * SPECIES.elementSize() \/ 8 , a[i]);\n@@ -243,8 +224,1 @@\n-        return bb.clear();\n-    }\n-\n-    static byte[] bufferToArray(ByteBuffer bb) {\n-        ByteBuffer db = bb;\n-        byte[] d = new byte[db.capacity()];\n-        db.get(0, d);\n-        return d;\n+        return ms;\n@@ -253,7 +227,2 @@\n-    static byte[] toByteArray(byte[] a, IntFunction<byte[]> fb, ByteOrder bo) {\n-        byte[] b = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n-        ByteBuffer bb = ByteBuffer.wrap(b, 0, b.length).order(bo);\n-        for (byte v : a) {\n-            bb.put(v);\n-        }\n-        return b;\n+    static byte[] segmentToArray(MemorySegment ms) {\n+        return ms.toArray(ValueLayout.JAVA_BYTE);\n@@ -299,2 +268,2 @@\n-    static ByteVector fromByteArray(byte[] a, int i, ByteOrder bo) {\n-        return ByteVector.fromByteArray(SPECIES, a, i, bo);\n+    static ByteVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo) {\n+        return ByteVector.fromMemorySegment(SPECIES, a, i, bo);\n@@ -304,2 +273,2 @@\n-    static ByteVector fromByteArray(byte[] a, int i, ByteOrder bo, VectorMask<Byte> m) {\n-        return ByteVector.fromByteArray(SPECIES, a, i, bo, m);\n+    static ByteVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo, VectorMask<Byte> m) {\n+        return ByteVector.fromMemorySegment(SPECIES, a, i, bo, m);\n@@ -309,2 +278,2 @@\n-    static void intoByteArray(ByteVector v, byte[] a, int i, ByteOrder bo) {\n-        v.intoByteArray(a, i, bo);\n+    static void intoMemorySegment(ByteVector v, MemorySegment a, int i, ByteOrder bo) {\n+        v.intoMemorySegment(a, i, bo);\n@@ -314,2 +283,2 @@\n-    static void intoByteArray(ByteVector v, byte[] a, int i, ByteOrder bo, VectorMask<Byte> m) {\n-        v.intoByteArray(a, i, bo, m);\n+    static void intoMemorySegment(ByteVector v, MemorySegment a, int i, ByteOrder bo, VectorMask<Byte> m) {\n+        v.intoMemorySegment(a, i, bo, m);\n@@ -318,21 +287,0 @@\n-    @DontInline\n-    static ByteVector fromByteBuffer(ByteBuffer a, int i, ByteOrder bo) {\n-        return ByteVector.fromByteBuffer(SPECIES, a, i, bo);\n-    }\n-\n-    @DontInline\n-    static ByteVector fromByteBuffer(ByteBuffer a, int i, ByteOrder bo, VectorMask<Byte> m) {\n-        return ByteVector.fromByteBuffer(SPECIES, a, i, bo, m);\n-    }\n-\n-    @DontInline\n-    static void intoByteBuffer(ByteVector v, ByteBuffer a, int i, ByteOrder bo) {\n-        v.intoByteBuffer(a, i, bo);\n-    }\n-\n-    @DontInline\n-    static void intoByteBuffer(ByteVector v, ByteBuffer a, int i, ByteOrder bo, VectorMask<Byte> m) {\n-        v.intoByteBuffer(a, i, bo, m);\n-    }\n-\n-\n@@ -509,6 +457,6 @@\n-    @Test(dataProvider = \"byteByteBufferProvider\")\n-    static void loadStoreByteBuffer(IntFunction<byte[]> fa,\n-                                    IntFunction<ByteBuffer> fb,\n-                                    ByteOrder bo) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), fb);\n-        ByteBuffer r = fb.apply(a.limit());\n+    @Test(dataProvider = \"byteMemorySegmentProvider\")\n+    static void loadStoreMemorySegment(IntFunction<byte[]> fa,\n+                                       IntFunction<MemorySegment> fb,\n+                                       ByteOrder bo) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb);\n+        MemorySegment r = fb.apply((int) a.byteSize());\n@@ -516,1 +464,1 @@\n-        int l = a.limit();\n+        int l = (int) a.byteSize();\n@@ -521,2 +469,2 @@\n-                ByteVector av = ByteVector.fromByteBuffer(SPECIES, a, i, bo);\n-                av.intoByteBuffer(r, i, bo);\n+                ByteVector av = ByteVector.fromMemorySegment(SPECIES, a, i, bo);\n+                av.intoMemorySegment(r, i, bo);\n@@ -525,5 +473,2 @@\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        Assert.assertEquals(r, a, \"Buffers not equal\");\n+        long m = r.mismatch(a);\n+        Assert.assertEquals(m, -1, \"Segments not equal\");\n@@ -533,3 +478,3 @@\n-    static void loadByteBufferIOOBE(IntFunction<byte[]> fa, IntFunction<Integer> fi) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n+    static void loadMemorySegmentIOOBE(IntFunction<byte[]> fa, IntFunction<Integer> fi) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n@@ -537,1 +482,1 @@\n-        int l = a.limit();\n+        int l = (int) a.byteSize();\n@@ -542,2 +487,2 @@\n-                ByteVector av = fromByteBuffer(a, i, ByteOrder.nativeOrder());\n-                av.intoByteBuffer(r, i, ByteOrder.nativeOrder());\n+                ByteVector av = fromMemorySegment(a, i, ByteOrder.nativeOrder());\n+                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n@@ -547,2 +492,2 @@\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.limit());\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());\n@@ -550,1 +495,1 @@\n-            fromByteBuffer(a, index, ByteOrder.nativeOrder());\n+            fromMemorySegment(a, index, ByteOrder.nativeOrder());\n@@ -562,3 +507,3 @@\n-    static void storeByteBufferIOOBE(IntFunction<byte[]> fa, IntFunction<Integer> fi) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n+    static void storeMemorySegmentIOOBE(IntFunction<byte[]> fa, IntFunction<Integer> fi) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n@@ -566,1 +511,1 @@\n-        int l = a.limit();\n+        int l = (int) a.byteSize();\n@@ -571,2 +516,2 @@\n-                ByteVector av = ByteVector.fromByteBuffer(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteBuffer(av, r, i, ByteOrder.nativeOrder());\n+                ByteVector av = ByteVector.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+                intoMemorySegment(av, r, i, ByteOrder.nativeOrder());\n@@ -576,2 +521,2 @@\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.limit());\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());\n@@ -579,2 +524,2 @@\n-            ByteVector av = ByteVector.fromByteBuffer(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteBuffer(av, r, index, ByteOrder.nativeOrder());\n+            ByteVector av = ByteVector.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+            intoMemorySegment(av, r, index, ByteOrder.nativeOrder());\n@@ -591,6 +536,5 @@\n-\n-    @Test(dataProvider = \"byteByteBufferMaskProvider\")\n-    static void loadStoreByteBufferMask(IntFunction<byte[]> fa,\n-                                        IntFunction<ByteBuffer> fb,\n-                                        IntFunction<boolean[]> fm,\n-                                        ByteOrder bo) {\n+    @Test(dataProvider = \"byteMemorySegmentMaskProvider\")\n+    static void loadStoreMemorySegmentMask(IntFunction<byte[]> fa,\n+                                           IntFunction<MemorySegment> fb,\n+                                           IntFunction<boolean[]> fm,\n+                                           ByteOrder bo) {\n@@ -598,2 +542,2 @@\n-        ByteBuffer a = toBuffer(_a, fb);\n-        ByteBuffer r = fb.apply(a.limit());\n+        MemorySegment a = toSegment(_a, fb);\n+        MemorySegment r = fb.apply((int) a.byteSize());\n@@ -603,1 +547,1 @@\n-        int l = a.limit();\n+        int l = (int) a.byteSize();\n@@ -608,2 +552,2 @@\n-                ByteVector av = ByteVector.fromByteBuffer(SPECIES, a, i, bo, vmask);\n-                av.intoByteBuffer(r, i, bo);\n+                ByteVector av = ByteVector.fromMemorySegment(SPECIES, a, i, bo, vmask);\n+                av.intoMemorySegment(r, i, bo);\n@@ -612,5 +556,1 @@\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        assertArraysEquals(bufferToArray(r), _a, mask);\n+        assertArraysEquals(segmentToArray(r), _a, mask);\n@@ -619,1 +559,1 @@\n-        r = fb.apply(a.limit());\n+        r = fb.apply((int) a.byteSize());\n@@ -623,2 +563,2 @@\n-                ByteVector av = ByteVector.fromByteBuffer(SPECIES, a, i, bo);\n-                av.intoByteBuffer(r, i, bo, vmask);\n+                ByteVector av = ByteVector.fromMemorySegment(SPECIES, a, i, bo);\n+                av.intoMemorySegment(r, i, bo, vmask);\n@@ -627,5 +567,1 @@\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        assertArraysEquals(bufferToArray(r), _a, mask);\n+        assertArraysEquals(segmentToArray(r), _a, mask);\n@@ -635,3 +571,3 @@\n-    static void loadByteBufferMaskIOOBE(IntFunction<byte[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n+    static void loadMemorySegmentMaskIOOBE(IntFunction<byte[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n@@ -641,1 +577,1 @@\n-        int l = a.limit();\n+        int l = (int) a.byteSize();\n@@ -646,2 +582,2 @@\n-                ByteVector av = fromByteBuffer(a, i, ByteOrder.nativeOrder(), vmask);\n-                av.intoByteBuffer(r, i, ByteOrder.nativeOrder());\n+                ByteVector av = fromMemorySegment(a, i, ByteOrder.nativeOrder(), vmask);\n+                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n@@ -651,2 +587,2 @@\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.limit(), SPECIES.elementSize() \/ 8);\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() \/ 8);\n@@ -654,1 +590,1 @@\n-            fromByteBuffer(a, index, ByteOrder.nativeOrder(), vmask);\n+            fromMemorySegment(a, index, ByteOrder.nativeOrder(), vmask);\n@@ -666,3 +602,3 @@\n-    static void storeByteBufferMaskIOOBE(IntFunction<byte[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n+    static void storeMemorySegmentMaskIOOBE(IntFunction<byte[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n@@ -672,112 +608,1 @@\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ByteVector av = ByteVector.fromByteBuffer(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteBuffer(av, r, i, ByteOrder.nativeOrder(), vmask);\n-            }\n-        }\n-\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.limit(), SPECIES.elementSize() \/ 8);\n-        try {\n-            ByteVector av = ByteVector.fromByteBuffer(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteBuffer(av, a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"byteByteBufferProvider\")\n-    static void loadStoreReadonlyByteBuffer(IntFunction<byte[]> fa,\n-                                    IntFunction<ByteBuffer> fb,\n-                                    ByteOrder bo) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), fb).asReadOnlyBuffer();\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo);\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, SPECIES.maskAll(true));\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, SPECIES.maskAll(false));\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            VectorMask<Byte> m = SPECIES.shuffleFromOp(i -> i % 2 == 0 ? 1 : -1)\n-                    .laneIsValid();\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, m);\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"byteByteArrayProvider\")\n-    static void loadStoreByteArray(IntFunction<byte[]> fa,\n-                                    ByteOrder bo) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, bo);\n-        byte[] r = new byte[a.length];\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ByteVector av = ByteVector.fromByteArray(SPECIES, a, i, bo);\n-                av.intoByteArray(r, i, bo);\n-            }\n-        }\n-        Assert.assertEquals(r, a, \"Byte arrays not equal\");\n-    }\n-\n-    @Test(dataProvider = \"byteByteProviderForIOOBE\")\n-    static void loadByteArrayIOOBE(IntFunction<byte[]> fa, IntFunction<Integer> fi) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ByteVector av = fromByteArray(a, i, ByteOrder.nativeOrder());\n-                av.intoByteArray(r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.length);\n-        try {\n-            fromByteArray(a, index, ByteOrder.nativeOrder());\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-    @Test(dataProvider = \"byteByteProviderForIOOBE\")\n-    static void storeByteArrayIOOBE(IntFunction<byte[]> fa, IntFunction<Integer> fi) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-\n+        int l = (int) a.byteSize();\n@@ -785,1 +610,0 @@\n-        int l = a.length;\n@@ -789,2 +613,2 @@\n-                ByteVector av = ByteVector.fromByteArray(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteArray(av, r, i, ByteOrder.nativeOrder());\n+                ByteVector av = ByteVector.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+                intoMemorySegment(av, r, i, ByteOrder.nativeOrder(), vmask);\n@@ -794,2 +618,2 @@\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.length);\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() \/ 8);\n@@ -797,2 +621,2 @@\n-            ByteVector av = ByteVector.fromByteArray(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteArray(av, r, index, ByteOrder.nativeOrder());\n+            ByteVector av = ByteVector.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+            intoMemorySegment(av, a, index, ByteOrder.nativeOrder(), vmask);\n@@ -809,0 +633,5 @@\n+    @Test(dataProvider = \"byteMemorySegmentProvider\")\n+    static void loadStoreReadonlyMemorySegment(IntFunction<byte[]> fa,\n+                                               IntFunction<MemorySegment> fb,\n+                                               ByteOrder bo) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb).asReadOnly();\n@@ -810,38 +639,4 @@\n-    @Test(dataProvider = \"byteByteArrayMaskProvider\")\n-    static void loadStoreByteArrayMask(IntFunction<byte[]> fa,\n-                                  IntFunction<boolean[]> fm,\n-                                  ByteOrder bo) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, bo);\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Byte> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-          for (int i = 0; i < l; i += s) {\n-              ByteVector av = ByteVector.fromByteArray(SPECIES, a, i, bo, vmask);\n-              av.intoByteArray(r, i, bo);\n-          }\n-        }\n-        assertArraysEquals(r, a, mask);\n-\n-\n-        r = new byte[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ByteVector av = ByteVector.fromByteArray(SPECIES, a, i, bo);\n-                av.intoByteArray(r, i, bo, vmask);\n-            }\n-        }\n-        assertArraysEquals(r, a, mask);\n-    }\n-\n-    @Test(dataProvider = \"byteByteMaskProviderForIOOBE\")\n-    static void loadByteArrayMaskIOOBE(IntFunction<byte[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Byte> vmask = VectorMask.fromValues(SPECIES, mask);\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo)\n+        );\n@@ -849,2 +644,4 @@\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(true))\n+        );\n@@ -852,6 +649,4 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ByteVector av = fromByteArray(a, i, ByteOrder.nativeOrder(), vmask);\n-                av.intoByteArray(r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(false))\n+        );\n@@ -859,12 +654,6 @@\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length, SPECIES.elementSize() \/ 8);\n-        try {\n-            fromByteArray(a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n+        VectorMask<Byte> m = SPECIES.shuffleFromOp(i -> i % 2 == 0 ? 1 : -1)\n+                .laneIsValid();\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, m)\n+        );\n@@ -873,31 +662,0 @@\n-    @Test(dataProvider = \"byteByteMaskProviderForIOOBE\")\n-    static void storeByteArrayMaskIOOBE(IntFunction<byte[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Byte> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ByteVector av = ByteVector.fromByteArray(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteArray(av, r, i, ByteOrder.nativeOrder(), vmask);\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length, SPECIES.elementSize() \/ 8);\n-        try {\n-            ByteVector av = ByteVector.fromByteArray(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteArray(av, a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n@@ -919,0 +677,1 @@\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte128VectorLoadStoreTests.java","additions":112,"deletions":353,"binary":false,"changes":465,"status":"modified"},{"patch":"@@ -264,0 +264,49 @@\n+    static void assertcompressArraysEquals(byte[] r, byte[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    Assert.assertEquals(r[i + k], (byte)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (byte)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals(byte[] r, byte[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        Assert.assertEquals(r[i + j], (byte)0);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (byte)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n@@ -897,1 +946,0 @@\n-\n@@ -992,2 +1040,0 @@\n-\n-\n@@ -1069,1 +1115,0 @@\n-\n@@ -1210,0 +1255,15 @@\n+    static byte TRAILING_ZEROS_COUNT_scalar(byte a) {\n+        return (byte) (a != 0 ? Integer.numberOfTrailingZeros(a) : 8);\n+    }\n+\n+    static byte LEADING_ZEROS_COUNT_scalar(byte a) {\n+        return (byte) (a >= 0 ? Integer.numberOfLeadingZeros(a) - 24 : 0);\n+    }\n+\n+    static byte REVERSE_scalar(byte a) {\n+        byte b = (byte) ROL_scalar(a, (byte) 4);\n+        b = (byte) (((b & 0x55) << 1) | ((b & 0xAA) >>> 1));\n+        b = (byte) (((b & 0x33) << 2) | ((b & 0xCC) >>> 2));\n+        return b;\n+    }\n+\n@@ -1359,0 +1419,1 @@\n+\n@@ -1379,0 +1440,1 @@\n+\n@@ -1435,0 +1497,1 @@\n+\n@@ -1455,0 +1518,1 @@\n+\n@@ -1511,0 +1575,1 @@\n+\n@@ -1531,0 +1596,1 @@\n+\n@@ -1588,2 +1654,0 @@\n-\n-\n@@ -1612,0 +1676,1 @@\n+\n@@ -1635,2 +1700,0 @@\n-\n-\n@@ -1742,0 +1805,1 @@\n+\n@@ -1761,2 +1825,0 @@\n-\n-\n@@ -1783,1 +1845,0 @@\n-\n@@ -1805,2 +1866,0 @@\n-\n-\n@@ -1827,1 +1886,0 @@\n-\n@@ -1848,0 +1906,1 @@\n+\n@@ -1867,2 +1926,0 @@\n-\n-\n@@ -1889,1 +1946,0 @@\n-\n@@ -1911,2 +1967,0 @@\n-\n-\n@@ -1933,1 +1987,0 @@\n-\n@@ -2027,3 +2080,0 @@\n-\n-\n-\n@@ -2046,2 +2096,0 @@\n-\n-\n@@ -2067,2 +2115,0 @@\n-\n-\n@@ -2097,2 +2143,0 @@\n-\n-\n@@ -2116,2 +2160,0 @@\n-\n-\n@@ -2146,2 +2188,0 @@\n-\n-\n@@ -2165,2 +2205,0 @@\n-\n-\n@@ -2181,2 +2219,0 @@\n-\n-\n@@ -2200,1 +2236,0 @@\n-\n@@ -2232,2 +2267,0 @@\n-\n-\n@@ -2255,2 +2288,0 @@\n-\n-\n@@ -2277,5 +2308,0 @@\n-\n-\n-\n-\n-\n@@ -2303,2 +2329,0 @@\n-\n-\n@@ -2325,5 +2349,0 @@\n-\n-\n-\n-\n-\n@@ -2351,2 +2370,0 @@\n-\n-\n@@ -2373,5 +2390,0 @@\n-\n-\n-\n-\n-\n@@ -2398,2 +2410,0 @@\n-\n-\n@@ -2419,5 +2429,0 @@\n-\n-\n-\n-\n-\n@@ -2444,2 +2449,0 @@\n-\n-\n@@ -2465,5 +2468,0 @@\n-\n-\n-\n-\n-\n@@ -2490,2 +2488,0 @@\n-\n-\n@@ -2511,3 +2507,0 @@\n-\n-\n-\n@@ -2535,2 +2528,0 @@\n-\n-\n@@ -2557,1 +2548,0 @@\n-\n@@ -2579,2 +2569,0 @@\n-\n-\n@@ -2601,1 +2589,0 @@\n-\n@@ -2622,2 +2609,0 @@\n-\n-\n@@ -2643,1 +2628,0 @@\n-\n@@ -2664,2 +2648,0 @@\n-\n-\n@@ -2684,4 +2666,0 @@\n-\n-\n-\n-\n@@ -2707,2 +2685,0 @@\n-\n-\n@@ -2727,4 +2703,0 @@\n-\n-\n-\n-\n@@ -2750,2 +2722,0 @@\n-\n-\n@@ -2770,2 +2740,0 @@\n-\n-\n@@ -2791,2 +2759,0 @@\n-\n-\n@@ -2811,2 +2777,0 @@\n-\n-\n@@ -2832,2 +2796,0 @@\n-\n-\n@@ -2852,2 +2814,0 @@\n-\n-\n@@ -2873,2 +2833,0 @@\n-\n-\n@@ -2914,0 +2872,1 @@\n+\n@@ -2932,0 +2891,1 @@\n+\n@@ -2952,0 +2912,1 @@\n+\n@@ -3045,1 +3006,0 @@\n-\n@@ -3071,1 +3031,0 @@\n-\n@@ -3091,1 +3050,0 @@\n-\n@@ -3119,1 +3077,0 @@\n-\n@@ -3138,1 +3095,0 @@\n-\n@@ -3164,1 +3120,0 @@\n-\n@@ -3184,1 +3139,0 @@\n-\n@@ -3212,1 +3166,0 @@\n-\n@@ -3231,1 +3184,0 @@\n-\n@@ -3257,1 +3209,0 @@\n-\n@@ -3277,1 +3228,0 @@\n-\n@@ -3322,0 +3272,1 @@\n+\n@@ -3346,0 +3297,1 @@\n+\n@@ -3364,0 +3316,1 @@\n+\n@@ -3390,0 +3343,1 @@\n+\n@@ -3407,0 +3361,1 @@\n+\n@@ -3431,0 +3386,1 @@\n+\n@@ -3449,0 +3405,1 @@\n+\n@@ -3475,0 +3432,1 @@\n+\n@@ -3492,0 +3450,1 @@\n+\n@@ -3516,0 +3475,1 @@\n+\n@@ -3534,0 +3494,1 @@\n+\n@@ -3560,0 +3521,1 @@\n+\n@@ -3577,0 +3539,1 @@\n+\n@@ -3601,0 +3564,1 @@\n+\n@@ -3619,0 +3583,1 @@\n+\n@@ -3645,0 +3610,1 @@\n+\n@@ -3662,0 +3628,1 @@\n+\n@@ -3686,0 +3653,1 @@\n+\n@@ -3704,0 +3672,1 @@\n+\n@@ -3740,1 +3709,0 @@\n-\n@@ -3756,1 +3724,0 @@\n-\n@@ -3766,1 +3733,0 @@\n-\n@@ -3782,1 +3748,0 @@\n-\n@@ -3800,0 +3765,1 @@\n+\n@@ -3840,0 +3806,1 @@\n+\n@@ -3881,3 +3848,0 @@\n-\n-\n-\n@@ -3903,1 +3867,0 @@\n-\n@@ -3946,1 +3909,0 @@\n-\n@@ -3989,1 +3951,0 @@\n-\n@@ -4009,1 +3970,0 @@\n-\n@@ -4052,1 +4012,0 @@\n-\n@@ -4095,1 +4054,0 @@\n-\n@@ -4138,1 +4096,0 @@\n-\n@@ -4181,2 +4138,0 @@\n-\n-\n@@ -4202,2 +4157,0 @@\n-\n-\n@@ -4227,3 +4180,0 @@\n-\n-\n-\n@@ -4249,2 +4199,0 @@\n-\n-\n@@ -4274,3 +4222,0 @@\n-\n-\n-\n@@ -4296,2 +4241,0 @@\n-\n-\n@@ -4321,3 +4264,0 @@\n-\n-\n-\n@@ -4343,2 +4283,0 @@\n-\n-\n@@ -4368,2 +4306,0 @@\n-\n-\n@@ -4386,1 +4322,0 @@\n-\n@@ -4423,1 +4358,0 @@\n-\n@@ -4460,1 +4394,0 @@\n-\n@@ -4497,1 +4430,0 @@\n-\n@@ -4576,0 +4508,37 @@\n+\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void compressByte128VectorTests(IntFunction<byte[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.compress(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertcompressArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void expandByte128VectorTests(IntFunction<byte[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.expand(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertexpandArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n@@ -4746,4 +4715,0 @@\n-\n-\n-\n-\n@@ -4764,3 +4729,0 @@\n-\n-\n-\n@@ -4792,0 +4754,1 @@\n+\n@@ -4821,0 +4784,1 @@\n+\n@@ -4854,0 +4818,1 @@\n+\n@@ -4881,0 +4846,1 @@\n+\n@@ -4920,0 +4886,1 @@\n+\n@@ -4977,22 +4944,0 @@\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n@@ -5002,0 +4947,1 @@\n+\n@@ -5006,1 +4952,0 @@\n-\n@@ -5025,0 +4970,1 @@\n+\n@@ -5042,1 +4988,0 @@\n-\n@@ -5065,3 +5010,0 @@\n-\n-\n-\n@@ -5097,0 +5039,1 @@\n+\n@@ -5127,1 +5070,0 @@\n-\n@@ -5166,3 +5108,0 @@\n-\n-\n-\n@@ -5183,0 +5122,1 @@\n+\n@@ -5198,1 +5138,0 @@\n-\n@@ -5217,1 +5156,0 @@\n-\n@@ -5330,1 +5268,0 @@\n-\n@@ -5339,2 +5276,0 @@\n-\n-\n@@ -5371,2 +5306,0 @@\n-\n-\n@@ -5391,2 +5324,0 @@\n-\n-\n@@ -5397,2 +5328,0 @@\n-\n-\n@@ -5414,2 +5343,0 @@\n-\n-\n@@ -5434,0 +5361,151 @@\n+    static byte BIT_COUNT(byte a) {\n+        return (byte)(Integer.bitCount((int)a & 0xFF));\n+    }\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void BIT_COUNTByte128VectorTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Byte128VectorTests::BIT_COUNT);\n+    }\n+\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void BIT_COUNTMaskedByte128VectorTests(IntFunction<byte[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Byte128VectorTests::BIT_COUNT);\n+    }\n+\n+    static byte TRAILING_ZEROS_COUNT(byte a) {\n+        return (byte)(TRAILING_ZEROS_COUNT_scalar(a));\n+    }\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void TRAILING_ZEROS_COUNTByte128VectorTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TRAILING_ZEROS_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Byte128VectorTests::TRAILING_ZEROS_COUNT);\n+    }\n+\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void TRAILING_ZEROS_COUNTMaskedByte128VectorTests(IntFunction<byte[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TRAILING_ZEROS_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Byte128VectorTests::TRAILING_ZEROS_COUNT);\n+    }\n+\n+    static byte LEADING_ZEROS_COUNT(byte a) {\n+        return (byte)(LEADING_ZEROS_COUNT_scalar(a));\n+    }\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void LEADING_ZEROS_COUNTByte128VectorTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LEADING_ZEROS_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Byte128VectorTests::LEADING_ZEROS_COUNT);\n+    }\n+\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void LEADING_ZEROS_COUNTMaskedByte128VectorTests(IntFunction<byte[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LEADING_ZEROS_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Byte128VectorTests::LEADING_ZEROS_COUNT);\n+    }\n+\n+    static byte REVERSE(byte a) {\n+        return (byte)(REVERSE_scalar(a));\n+    }\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void REVERSEByte128VectorTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Byte128VectorTests::REVERSE);\n+    }\n+\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void REVERSEMaskedByte128VectorTests(IntFunction<byte[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Byte128VectorTests::REVERSE);\n+    }\n+\n+    static byte REVERSE_BYTES(byte a) {\n+        return (byte)(a);\n+    }\n@@ -5435,0 +5513,4 @@\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void REVERSE_BYTESByte128VectorTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n@@ -5436,0 +5518,6 @@\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES).intoArray(r, i);\n+            }\n+        }\n@@ -5437,0 +5525,20 @@\n+        assertArraysEquals(r, a, Byte128VectorTests::REVERSE_BYTES);\n+    }\n+\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void REVERSE_BYTESMaskedByte128VectorTests(IntFunction<byte[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Byte128VectorTests::REVERSE_BYTES);\n+    }\n@@ -5850,0 +5958,17 @@\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCompressByte128VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        int trueCount = 0;\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                trueCount = vmask.trueCount();\n+                var rmask = vmask.compress();\n+                for (int j = 0; j < SPECIES.length(); j++)  {\n+                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);\n+                }\n+            }\n+        }\n+    }\n+\n@@ -5892,0 +6017,14 @@\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeLongByte128VectorTestsSmokeTest(int offset) {\n+        long limit = SPECIES.length() * BUFFER_REPS;\n+        for (long i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i + offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                long index = i + j + offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n@@ -5912,0 +6051,8 @@\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundLongByte128VectorTestsSmokeTest(int _length) {\n+        long length = _length;\n+        long actualLoopBound = SPECIES.loopBound(length);\n+        long expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+    }\n+\n@@ -5974,1 +6121,0 @@\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte128VectorTests.java","additions":363,"deletions":217,"binary":false,"changes":580,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,3 @@\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.ValueLayout;\n@@ -42,1 +45,0 @@\n-import java.nio.ByteBuffer;\n@@ -44,1 +46,0 @@\n-import java.nio.ReadOnlyBufferException;\n@@ -69,1 +70,0 @@\n-\n@@ -109,1 +109,1 @@\n-    \/\/ Relative to byte[] array.length or ByteBuffer.limit()\n+    \/\/ Relative to byte[] array.length or MemorySegment.byteSize()\n@@ -180,1 +180,1 @@\n-    public Object[][] byteByteBufferProvider() {\n+    public Object[][] byteMemorySegmentProvider() {\n@@ -182,1 +182,1 @@\n-                flatMap(fa -> BYTE_BUFFER_GENERATORS.stream().\n+                flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n@@ -190,1 +190,1 @@\n-    public Object[][] byteByteBufferMaskProvider() {\n+    public Object[][] byteMemorySegmentMaskProvider() {\n@@ -193,1 +193,1 @@\n-                        flatMap(fa -> BYTE_BUFFER_GENERATORS.stream().\n+                        flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n@@ -200,19 +200,0 @@\n-    @DataProvider\n-    public Object[][] byteByteArrayProvider() {\n-        return BYTE_GENERATORS.stream().\n-                flatMap(fa -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                    return new Object[]{fa, bo};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] byteByteArrayMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> BYTE_GENERATORS.stream().\n-                    flatMap(fa -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                        return new Object[]{fa, fm, bo};\n-                    }))).\n-                toArray(Object[][]::new);\n-    }\n-\n@@ -238,4 +219,4 @@\n-    static ByteBuffer toBuffer(byte[] a, IntFunction<ByteBuffer> fb) {\n-        ByteBuffer bb = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n-        for (byte v : a) {\n-            bb.put(v);\n+    static MemorySegment toSegment(byte[] a, IntFunction<MemorySegment> fb) {\n+        MemorySegment ms = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n+        for (int i = 0; i < a.length; i++) {\n+            ms.set(ValueLayout.JAVA_BYTE, i * SPECIES.elementSize() \/ 8 , a[i]);\n@@ -243,8 +224,1 @@\n-        return bb.clear();\n-    }\n-\n-    static byte[] bufferToArray(ByteBuffer bb) {\n-        ByteBuffer db = bb;\n-        byte[] d = new byte[db.capacity()];\n-        db.get(0, d);\n-        return d;\n+        return ms;\n@@ -253,7 +227,2 @@\n-    static byte[] toByteArray(byte[] a, IntFunction<byte[]> fb, ByteOrder bo) {\n-        byte[] b = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n-        ByteBuffer bb = ByteBuffer.wrap(b, 0, b.length).order(bo);\n-        for (byte v : a) {\n-            bb.put(v);\n-        }\n-        return b;\n+    static byte[] segmentToArray(MemorySegment ms) {\n+        return ms.toArray(ValueLayout.JAVA_BYTE);\n@@ -299,2 +268,2 @@\n-    static ByteVector fromByteArray(byte[] a, int i, ByteOrder bo) {\n-        return ByteVector.fromByteArray(SPECIES, a, i, bo);\n+    static ByteVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo) {\n+        return ByteVector.fromMemorySegment(SPECIES, a, i, bo);\n@@ -304,2 +273,2 @@\n-    static ByteVector fromByteArray(byte[] a, int i, ByteOrder bo, VectorMask<Byte> m) {\n-        return ByteVector.fromByteArray(SPECIES, a, i, bo, m);\n+    static ByteVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo, VectorMask<Byte> m) {\n+        return ByteVector.fromMemorySegment(SPECIES, a, i, bo, m);\n@@ -309,2 +278,2 @@\n-    static void intoByteArray(ByteVector v, byte[] a, int i, ByteOrder bo) {\n-        v.intoByteArray(a, i, bo);\n+    static void intoMemorySegment(ByteVector v, MemorySegment a, int i, ByteOrder bo) {\n+        v.intoMemorySegment(a, i, bo);\n@@ -314,2 +283,2 @@\n-    static void intoByteArray(ByteVector v, byte[] a, int i, ByteOrder bo, VectorMask<Byte> m) {\n-        v.intoByteArray(a, i, bo, m);\n+    static void intoMemorySegment(ByteVector v, MemorySegment a, int i, ByteOrder bo, VectorMask<Byte> m) {\n+        v.intoMemorySegment(a, i, bo, m);\n@@ -318,21 +287,0 @@\n-    @DontInline\n-    static ByteVector fromByteBuffer(ByteBuffer a, int i, ByteOrder bo) {\n-        return ByteVector.fromByteBuffer(SPECIES, a, i, bo);\n-    }\n-\n-    @DontInline\n-    static ByteVector fromByteBuffer(ByteBuffer a, int i, ByteOrder bo, VectorMask<Byte> m) {\n-        return ByteVector.fromByteBuffer(SPECIES, a, i, bo, m);\n-    }\n-\n-    @DontInline\n-    static void intoByteBuffer(ByteVector v, ByteBuffer a, int i, ByteOrder bo) {\n-        v.intoByteBuffer(a, i, bo);\n-    }\n-\n-    @DontInline\n-    static void intoByteBuffer(ByteVector v, ByteBuffer a, int i, ByteOrder bo, VectorMask<Byte> m) {\n-        v.intoByteBuffer(a, i, bo, m);\n-    }\n-\n-\n@@ -509,6 +457,6 @@\n-    @Test(dataProvider = \"byteByteBufferProvider\")\n-    static void loadStoreByteBuffer(IntFunction<byte[]> fa,\n-                                    IntFunction<ByteBuffer> fb,\n-                                    ByteOrder bo) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), fb);\n-        ByteBuffer r = fb.apply(a.limit());\n+    @Test(dataProvider = \"byteMemorySegmentProvider\")\n+    static void loadStoreMemorySegment(IntFunction<byte[]> fa,\n+                                       IntFunction<MemorySegment> fb,\n+                                       ByteOrder bo) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb);\n+        MemorySegment r = fb.apply((int) a.byteSize());\n@@ -516,1 +464,1 @@\n-        int l = a.limit();\n+        int l = (int) a.byteSize();\n@@ -521,2 +469,2 @@\n-                ByteVector av = ByteVector.fromByteBuffer(SPECIES, a, i, bo);\n-                av.intoByteBuffer(r, i, bo);\n+                ByteVector av = ByteVector.fromMemorySegment(SPECIES, a, i, bo);\n+                av.intoMemorySegment(r, i, bo);\n@@ -525,5 +473,2 @@\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        Assert.assertEquals(r, a, \"Buffers not equal\");\n+        long m = r.mismatch(a);\n+        Assert.assertEquals(m, -1, \"Segments not equal\");\n@@ -533,3 +478,3 @@\n-    static void loadByteBufferIOOBE(IntFunction<byte[]> fa, IntFunction<Integer> fi) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n+    static void loadMemorySegmentIOOBE(IntFunction<byte[]> fa, IntFunction<Integer> fi) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n@@ -537,1 +482,1 @@\n-        int l = a.limit();\n+        int l = (int) a.byteSize();\n@@ -542,2 +487,2 @@\n-                ByteVector av = fromByteBuffer(a, i, ByteOrder.nativeOrder());\n-                av.intoByteBuffer(r, i, ByteOrder.nativeOrder());\n+                ByteVector av = fromMemorySegment(a, i, ByteOrder.nativeOrder());\n+                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n@@ -547,2 +492,2 @@\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.limit());\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());\n@@ -550,1 +495,1 @@\n-            fromByteBuffer(a, index, ByteOrder.nativeOrder());\n+            fromMemorySegment(a, index, ByteOrder.nativeOrder());\n@@ -562,3 +507,3 @@\n-    static void storeByteBufferIOOBE(IntFunction<byte[]> fa, IntFunction<Integer> fi) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n+    static void storeMemorySegmentIOOBE(IntFunction<byte[]> fa, IntFunction<Integer> fi) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n@@ -566,1 +511,1 @@\n-        int l = a.limit();\n+        int l = (int) a.byteSize();\n@@ -571,2 +516,2 @@\n-                ByteVector av = ByteVector.fromByteBuffer(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteBuffer(av, r, i, ByteOrder.nativeOrder());\n+                ByteVector av = ByteVector.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+                intoMemorySegment(av, r, i, ByteOrder.nativeOrder());\n@@ -576,2 +521,2 @@\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.limit());\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());\n@@ -579,2 +524,2 @@\n-            ByteVector av = ByteVector.fromByteBuffer(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteBuffer(av, r, index, ByteOrder.nativeOrder());\n+            ByteVector av = ByteVector.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+            intoMemorySegment(av, r, index, ByteOrder.nativeOrder());\n@@ -591,6 +536,5 @@\n-\n-    @Test(dataProvider = \"byteByteBufferMaskProvider\")\n-    static void loadStoreByteBufferMask(IntFunction<byte[]> fa,\n-                                        IntFunction<ByteBuffer> fb,\n-                                        IntFunction<boolean[]> fm,\n-                                        ByteOrder bo) {\n+    @Test(dataProvider = \"byteMemorySegmentMaskProvider\")\n+    static void loadStoreMemorySegmentMask(IntFunction<byte[]> fa,\n+                                           IntFunction<MemorySegment> fb,\n+                                           IntFunction<boolean[]> fm,\n+                                           ByteOrder bo) {\n@@ -598,2 +542,2 @@\n-        ByteBuffer a = toBuffer(_a, fb);\n-        ByteBuffer r = fb.apply(a.limit());\n+        MemorySegment a = toSegment(_a, fb);\n+        MemorySegment r = fb.apply((int) a.byteSize());\n@@ -603,1 +547,1 @@\n-        int l = a.limit();\n+        int l = (int) a.byteSize();\n@@ -608,2 +552,2 @@\n-                ByteVector av = ByteVector.fromByteBuffer(SPECIES, a, i, bo, vmask);\n-                av.intoByteBuffer(r, i, bo);\n+                ByteVector av = ByteVector.fromMemorySegment(SPECIES, a, i, bo, vmask);\n+                av.intoMemorySegment(r, i, bo);\n@@ -612,5 +556,1 @@\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        assertArraysEquals(bufferToArray(r), _a, mask);\n+        assertArraysEquals(segmentToArray(r), _a, mask);\n@@ -619,1 +559,1 @@\n-        r = fb.apply(a.limit());\n+        r = fb.apply((int) a.byteSize());\n@@ -623,2 +563,2 @@\n-                ByteVector av = ByteVector.fromByteBuffer(SPECIES, a, i, bo);\n-                av.intoByteBuffer(r, i, bo, vmask);\n+                ByteVector av = ByteVector.fromMemorySegment(SPECIES, a, i, bo);\n+                av.intoMemorySegment(r, i, bo, vmask);\n@@ -627,5 +567,1 @@\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        assertArraysEquals(bufferToArray(r), _a, mask);\n+        assertArraysEquals(segmentToArray(r), _a, mask);\n@@ -635,3 +571,3 @@\n-    static void loadByteBufferMaskIOOBE(IntFunction<byte[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n+    static void loadMemorySegmentMaskIOOBE(IntFunction<byte[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n@@ -641,1 +577,1 @@\n-        int l = a.limit();\n+        int l = (int) a.byteSize();\n@@ -646,2 +582,2 @@\n-                ByteVector av = fromByteBuffer(a, i, ByteOrder.nativeOrder(), vmask);\n-                av.intoByteBuffer(r, i, ByteOrder.nativeOrder());\n+                ByteVector av = fromMemorySegment(a, i, ByteOrder.nativeOrder(), vmask);\n+                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n@@ -651,2 +587,2 @@\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.limit(), SPECIES.elementSize() \/ 8);\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() \/ 8);\n@@ -654,1 +590,1 @@\n-            fromByteBuffer(a, index, ByteOrder.nativeOrder(), vmask);\n+            fromMemorySegment(a, index, ByteOrder.nativeOrder(), vmask);\n@@ -666,3 +602,3 @@\n-    static void storeByteBufferMaskIOOBE(IntFunction<byte[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n+    static void storeMemorySegmentMaskIOOBE(IntFunction<byte[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n@@ -672,112 +608,1 @@\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ByteVector av = ByteVector.fromByteBuffer(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteBuffer(av, r, i, ByteOrder.nativeOrder(), vmask);\n-            }\n-        }\n-\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.limit(), SPECIES.elementSize() \/ 8);\n-        try {\n-            ByteVector av = ByteVector.fromByteBuffer(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteBuffer(av, a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"byteByteBufferProvider\")\n-    static void loadStoreReadonlyByteBuffer(IntFunction<byte[]> fa,\n-                                    IntFunction<ByteBuffer> fb,\n-                                    ByteOrder bo) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), fb).asReadOnlyBuffer();\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo);\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, SPECIES.maskAll(true));\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, SPECIES.maskAll(false));\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            VectorMask<Byte> m = SPECIES.shuffleFromOp(i -> i % 2 == 0 ? 1 : -1)\n-                    .laneIsValid();\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, m);\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"byteByteArrayProvider\")\n-    static void loadStoreByteArray(IntFunction<byte[]> fa,\n-                                    ByteOrder bo) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, bo);\n-        byte[] r = new byte[a.length];\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ByteVector av = ByteVector.fromByteArray(SPECIES, a, i, bo);\n-                av.intoByteArray(r, i, bo);\n-            }\n-        }\n-        Assert.assertEquals(r, a, \"Byte arrays not equal\");\n-    }\n-\n-    @Test(dataProvider = \"byteByteProviderForIOOBE\")\n-    static void loadByteArrayIOOBE(IntFunction<byte[]> fa, IntFunction<Integer> fi) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ByteVector av = fromByteArray(a, i, ByteOrder.nativeOrder());\n-                av.intoByteArray(r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.length);\n-        try {\n-            fromByteArray(a, index, ByteOrder.nativeOrder());\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-    @Test(dataProvider = \"byteByteProviderForIOOBE\")\n-    static void storeByteArrayIOOBE(IntFunction<byte[]> fa, IntFunction<Integer> fi) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-\n+        int l = (int) a.byteSize();\n@@ -785,1 +610,0 @@\n-        int l = a.length;\n@@ -789,2 +613,2 @@\n-                ByteVector av = ByteVector.fromByteArray(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteArray(av, r, i, ByteOrder.nativeOrder());\n+                ByteVector av = ByteVector.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+                intoMemorySegment(av, r, i, ByteOrder.nativeOrder(), vmask);\n@@ -794,2 +618,2 @@\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.length);\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() \/ 8);\n@@ -797,2 +621,2 @@\n-            ByteVector av = ByteVector.fromByteArray(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteArray(av, r, index, ByteOrder.nativeOrder());\n+            ByteVector av = ByteVector.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+            intoMemorySegment(av, a, index, ByteOrder.nativeOrder(), vmask);\n@@ -809,0 +633,5 @@\n+    @Test(dataProvider = \"byteMemorySegmentProvider\")\n+    static void loadStoreReadonlyMemorySegment(IntFunction<byte[]> fa,\n+                                               IntFunction<MemorySegment> fb,\n+                                               ByteOrder bo) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb).asReadOnly();\n@@ -810,38 +639,4 @@\n-    @Test(dataProvider = \"byteByteArrayMaskProvider\")\n-    static void loadStoreByteArrayMask(IntFunction<byte[]> fa,\n-                                  IntFunction<boolean[]> fm,\n-                                  ByteOrder bo) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, bo);\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Byte> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-          for (int i = 0; i < l; i += s) {\n-              ByteVector av = ByteVector.fromByteArray(SPECIES, a, i, bo, vmask);\n-              av.intoByteArray(r, i, bo);\n-          }\n-        }\n-        assertArraysEquals(r, a, mask);\n-\n-\n-        r = new byte[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ByteVector av = ByteVector.fromByteArray(SPECIES, a, i, bo);\n-                av.intoByteArray(r, i, bo, vmask);\n-            }\n-        }\n-        assertArraysEquals(r, a, mask);\n-    }\n-\n-    @Test(dataProvider = \"byteByteMaskProviderForIOOBE\")\n-    static void loadByteArrayMaskIOOBE(IntFunction<byte[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Byte> vmask = VectorMask.fromValues(SPECIES, mask);\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo)\n+        );\n@@ -849,2 +644,4 @@\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(true))\n+        );\n@@ -852,6 +649,4 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ByteVector av = fromByteArray(a, i, ByteOrder.nativeOrder(), vmask);\n-                av.intoByteArray(r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(false))\n+        );\n@@ -859,12 +654,6 @@\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length, SPECIES.elementSize() \/ 8);\n-        try {\n-            fromByteArray(a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n+        VectorMask<Byte> m = SPECIES.shuffleFromOp(i -> i % 2 == 0 ? 1 : -1)\n+                .laneIsValid();\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, m)\n+        );\n@@ -873,31 +662,0 @@\n-    @Test(dataProvider = \"byteByteMaskProviderForIOOBE\")\n-    static void storeByteArrayMaskIOOBE(IntFunction<byte[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Byte> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ByteVector av = ByteVector.fromByteArray(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteArray(av, r, i, ByteOrder.nativeOrder(), vmask);\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length, SPECIES.elementSize() \/ 8);\n-        try {\n-            ByteVector av = ByteVector.fromByteArray(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteArray(av, a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n@@ -919,0 +677,1 @@\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte256VectorLoadStoreTests.java","additions":112,"deletions":353,"binary":false,"changes":465,"status":"modified"},{"patch":"@@ -264,0 +264,49 @@\n+    static void assertcompressArraysEquals(byte[] r, byte[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    Assert.assertEquals(r[i + k], (byte)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (byte)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals(byte[] r, byte[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        Assert.assertEquals(r[i + j], (byte)0);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (byte)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n@@ -897,1 +946,0 @@\n-\n@@ -992,2 +1040,0 @@\n-\n-\n@@ -1069,1 +1115,0 @@\n-\n@@ -1210,0 +1255,15 @@\n+    static byte TRAILING_ZEROS_COUNT_scalar(byte a) {\n+        return (byte) (a != 0 ? Integer.numberOfTrailingZeros(a) : 8);\n+    }\n+\n+    static byte LEADING_ZEROS_COUNT_scalar(byte a) {\n+        return (byte) (a >= 0 ? Integer.numberOfLeadingZeros(a) - 24 : 0);\n+    }\n+\n+    static byte REVERSE_scalar(byte a) {\n+        byte b = (byte) ROL_scalar(a, (byte) 4);\n+        b = (byte) (((b & 0x55) << 1) | ((b & 0xAA) >>> 1));\n+        b = (byte) (((b & 0x33) << 2) | ((b & 0xCC) >>> 2));\n+        return b;\n+    }\n+\n@@ -1359,0 +1419,1 @@\n+\n@@ -1379,0 +1440,1 @@\n+\n@@ -1435,0 +1497,1 @@\n+\n@@ -1455,0 +1518,1 @@\n+\n@@ -1511,0 +1575,1 @@\n+\n@@ -1531,0 +1596,1 @@\n+\n@@ -1588,2 +1654,0 @@\n-\n-\n@@ -1612,0 +1676,1 @@\n+\n@@ -1635,2 +1700,0 @@\n-\n-\n@@ -1742,0 +1805,1 @@\n+\n@@ -1761,2 +1825,0 @@\n-\n-\n@@ -1783,1 +1845,0 @@\n-\n@@ -1805,2 +1866,0 @@\n-\n-\n@@ -1827,1 +1886,0 @@\n-\n@@ -1848,0 +1906,1 @@\n+\n@@ -1867,2 +1926,0 @@\n-\n-\n@@ -1889,1 +1946,0 @@\n-\n@@ -1911,2 +1967,0 @@\n-\n-\n@@ -1933,1 +1987,0 @@\n-\n@@ -2027,3 +2080,0 @@\n-\n-\n-\n@@ -2046,2 +2096,0 @@\n-\n-\n@@ -2067,2 +2115,0 @@\n-\n-\n@@ -2097,2 +2143,0 @@\n-\n-\n@@ -2116,2 +2160,0 @@\n-\n-\n@@ -2146,2 +2188,0 @@\n-\n-\n@@ -2165,2 +2205,0 @@\n-\n-\n@@ -2181,2 +2219,0 @@\n-\n-\n@@ -2200,1 +2236,0 @@\n-\n@@ -2232,2 +2267,0 @@\n-\n-\n@@ -2255,2 +2288,0 @@\n-\n-\n@@ -2277,5 +2308,0 @@\n-\n-\n-\n-\n-\n@@ -2303,2 +2329,0 @@\n-\n-\n@@ -2325,5 +2349,0 @@\n-\n-\n-\n-\n-\n@@ -2351,2 +2370,0 @@\n-\n-\n@@ -2373,5 +2390,0 @@\n-\n-\n-\n-\n-\n@@ -2398,2 +2410,0 @@\n-\n-\n@@ -2419,5 +2429,0 @@\n-\n-\n-\n-\n-\n@@ -2444,2 +2449,0 @@\n-\n-\n@@ -2465,5 +2468,0 @@\n-\n-\n-\n-\n-\n@@ -2490,2 +2488,0 @@\n-\n-\n@@ -2511,3 +2507,0 @@\n-\n-\n-\n@@ -2535,2 +2528,0 @@\n-\n-\n@@ -2557,1 +2548,0 @@\n-\n@@ -2579,2 +2569,0 @@\n-\n-\n@@ -2601,1 +2589,0 @@\n-\n@@ -2622,2 +2609,0 @@\n-\n-\n@@ -2643,1 +2628,0 @@\n-\n@@ -2664,2 +2648,0 @@\n-\n-\n@@ -2684,4 +2666,0 @@\n-\n-\n-\n-\n@@ -2707,2 +2685,0 @@\n-\n-\n@@ -2727,4 +2703,0 @@\n-\n-\n-\n-\n@@ -2750,2 +2722,0 @@\n-\n-\n@@ -2770,2 +2740,0 @@\n-\n-\n@@ -2791,2 +2759,0 @@\n-\n-\n@@ -2811,2 +2777,0 @@\n-\n-\n@@ -2832,2 +2796,0 @@\n-\n-\n@@ -2852,2 +2814,0 @@\n-\n-\n@@ -2873,2 +2833,0 @@\n-\n-\n@@ -2914,0 +2872,1 @@\n+\n@@ -2932,0 +2891,1 @@\n+\n@@ -2952,0 +2912,1 @@\n+\n@@ -3045,1 +3006,0 @@\n-\n@@ -3071,1 +3031,0 @@\n-\n@@ -3091,1 +3050,0 @@\n-\n@@ -3119,1 +3077,0 @@\n-\n@@ -3138,1 +3095,0 @@\n-\n@@ -3164,1 +3120,0 @@\n-\n@@ -3184,1 +3139,0 @@\n-\n@@ -3212,1 +3166,0 @@\n-\n@@ -3231,1 +3184,0 @@\n-\n@@ -3257,1 +3209,0 @@\n-\n@@ -3277,1 +3228,0 @@\n-\n@@ -3322,0 +3272,1 @@\n+\n@@ -3346,0 +3297,1 @@\n+\n@@ -3364,0 +3316,1 @@\n+\n@@ -3390,0 +3343,1 @@\n+\n@@ -3407,0 +3361,1 @@\n+\n@@ -3431,0 +3386,1 @@\n+\n@@ -3449,0 +3405,1 @@\n+\n@@ -3475,0 +3432,1 @@\n+\n@@ -3492,0 +3450,1 @@\n+\n@@ -3516,0 +3475,1 @@\n+\n@@ -3534,0 +3494,1 @@\n+\n@@ -3560,0 +3521,1 @@\n+\n@@ -3577,0 +3539,1 @@\n+\n@@ -3601,0 +3564,1 @@\n+\n@@ -3619,0 +3583,1 @@\n+\n@@ -3645,0 +3610,1 @@\n+\n@@ -3662,0 +3628,1 @@\n+\n@@ -3686,0 +3653,1 @@\n+\n@@ -3704,0 +3672,1 @@\n+\n@@ -3740,1 +3709,0 @@\n-\n@@ -3756,1 +3724,0 @@\n-\n@@ -3766,1 +3733,0 @@\n-\n@@ -3782,1 +3748,0 @@\n-\n@@ -3800,0 +3765,1 @@\n+\n@@ -3840,0 +3806,1 @@\n+\n@@ -3881,3 +3848,0 @@\n-\n-\n-\n@@ -3903,1 +3867,0 @@\n-\n@@ -3946,1 +3909,0 @@\n-\n@@ -3989,1 +3951,0 @@\n-\n@@ -4009,1 +3970,0 @@\n-\n@@ -4052,1 +4012,0 @@\n-\n@@ -4095,1 +4054,0 @@\n-\n@@ -4138,1 +4096,0 @@\n-\n@@ -4181,2 +4138,0 @@\n-\n-\n@@ -4202,2 +4157,0 @@\n-\n-\n@@ -4227,3 +4180,0 @@\n-\n-\n-\n@@ -4249,2 +4199,0 @@\n-\n-\n@@ -4274,3 +4222,0 @@\n-\n-\n-\n@@ -4296,2 +4241,0 @@\n-\n-\n@@ -4321,3 +4264,0 @@\n-\n-\n-\n@@ -4343,2 +4283,0 @@\n-\n-\n@@ -4368,2 +4306,0 @@\n-\n-\n@@ -4386,1 +4322,0 @@\n-\n@@ -4423,1 +4358,0 @@\n-\n@@ -4460,1 +4394,0 @@\n-\n@@ -4497,1 +4430,0 @@\n-\n@@ -4576,0 +4508,37 @@\n+\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void compressByte256VectorTests(IntFunction<byte[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.compress(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertcompressArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void expandByte256VectorTests(IntFunction<byte[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.expand(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertexpandArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n@@ -4746,4 +4715,0 @@\n-\n-\n-\n-\n@@ -4764,3 +4729,0 @@\n-\n-\n-\n@@ -4792,0 +4754,1 @@\n+\n@@ -4821,0 +4784,1 @@\n+\n@@ -4854,0 +4818,1 @@\n+\n@@ -4881,0 +4846,1 @@\n+\n@@ -4920,0 +4886,1 @@\n+\n@@ -4977,22 +4944,0 @@\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n@@ -5002,0 +4947,1 @@\n+\n@@ -5006,1 +4952,0 @@\n-\n@@ -5025,0 +4970,1 @@\n+\n@@ -5042,1 +4988,0 @@\n-\n@@ -5065,3 +5010,0 @@\n-\n-\n-\n@@ -5097,0 +5039,1 @@\n+\n@@ -5127,1 +5070,0 @@\n-\n@@ -5166,3 +5108,0 @@\n-\n-\n-\n@@ -5183,0 +5122,1 @@\n+\n@@ -5198,1 +5138,0 @@\n-\n@@ -5217,1 +5156,0 @@\n-\n@@ -5330,1 +5268,0 @@\n-\n@@ -5339,2 +5276,0 @@\n-\n-\n@@ -5371,2 +5306,0 @@\n-\n-\n@@ -5391,2 +5324,0 @@\n-\n-\n@@ -5397,2 +5328,0 @@\n-\n-\n@@ -5414,2 +5343,0 @@\n-\n-\n@@ -5434,0 +5361,151 @@\n+    static byte BIT_COUNT(byte a) {\n+        return (byte)(Integer.bitCount((int)a & 0xFF));\n+    }\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void BIT_COUNTByte256VectorTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Byte256VectorTests::BIT_COUNT);\n+    }\n+\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void BIT_COUNTMaskedByte256VectorTests(IntFunction<byte[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Byte256VectorTests::BIT_COUNT);\n+    }\n+\n+    static byte TRAILING_ZEROS_COUNT(byte a) {\n+        return (byte)(TRAILING_ZEROS_COUNT_scalar(a));\n+    }\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void TRAILING_ZEROS_COUNTByte256VectorTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TRAILING_ZEROS_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Byte256VectorTests::TRAILING_ZEROS_COUNT);\n+    }\n+\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void TRAILING_ZEROS_COUNTMaskedByte256VectorTests(IntFunction<byte[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TRAILING_ZEROS_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Byte256VectorTests::TRAILING_ZEROS_COUNT);\n+    }\n+\n+    static byte LEADING_ZEROS_COUNT(byte a) {\n+        return (byte)(LEADING_ZEROS_COUNT_scalar(a));\n+    }\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void LEADING_ZEROS_COUNTByte256VectorTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LEADING_ZEROS_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Byte256VectorTests::LEADING_ZEROS_COUNT);\n+    }\n+\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void LEADING_ZEROS_COUNTMaskedByte256VectorTests(IntFunction<byte[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LEADING_ZEROS_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Byte256VectorTests::LEADING_ZEROS_COUNT);\n+    }\n+\n+    static byte REVERSE(byte a) {\n+        return (byte)(REVERSE_scalar(a));\n+    }\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void REVERSEByte256VectorTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Byte256VectorTests::REVERSE);\n+    }\n+\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void REVERSEMaskedByte256VectorTests(IntFunction<byte[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Byte256VectorTests::REVERSE);\n+    }\n+\n+    static byte REVERSE_BYTES(byte a) {\n+        return (byte)(a);\n+    }\n@@ -5435,0 +5513,4 @@\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void REVERSE_BYTESByte256VectorTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n@@ -5436,0 +5518,6 @@\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES).intoArray(r, i);\n+            }\n+        }\n@@ -5437,0 +5525,20 @@\n+        assertArraysEquals(r, a, Byte256VectorTests::REVERSE_BYTES);\n+    }\n+\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void REVERSE_BYTESMaskedByte256VectorTests(IntFunction<byte[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Byte256VectorTests::REVERSE_BYTES);\n+    }\n@@ -5850,0 +5958,17 @@\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCompressByte256VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        int trueCount = 0;\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                trueCount = vmask.trueCount();\n+                var rmask = vmask.compress();\n+                for (int j = 0; j < SPECIES.length(); j++)  {\n+                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);\n+                }\n+            }\n+        }\n+    }\n+\n@@ -5892,0 +6017,14 @@\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeLongByte256VectorTestsSmokeTest(int offset) {\n+        long limit = SPECIES.length() * BUFFER_REPS;\n+        for (long i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i + offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                long index = i + j + offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n@@ -5912,0 +6051,8 @@\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundLongByte256VectorTestsSmokeTest(int _length) {\n+        long length = _length;\n+        long actualLoopBound = SPECIES.loopBound(length);\n+        long expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+    }\n+\n@@ -5974,1 +6121,0 @@\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte256VectorTests.java","additions":363,"deletions":217,"binary":false,"changes":580,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,3 @@\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.ValueLayout;\n@@ -42,1 +45,0 @@\n-import java.nio.ByteBuffer;\n@@ -44,1 +46,0 @@\n-import java.nio.ReadOnlyBufferException;\n@@ -69,1 +70,0 @@\n-\n@@ -109,1 +109,1 @@\n-    \/\/ Relative to byte[] array.length or ByteBuffer.limit()\n+    \/\/ Relative to byte[] array.length or MemorySegment.byteSize()\n@@ -180,1 +180,1 @@\n-    public Object[][] byteByteBufferProvider() {\n+    public Object[][] byteMemorySegmentProvider() {\n@@ -182,1 +182,1 @@\n-                flatMap(fa -> BYTE_BUFFER_GENERATORS.stream().\n+                flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n@@ -190,1 +190,1 @@\n-    public Object[][] byteByteBufferMaskProvider() {\n+    public Object[][] byteMemorySegmentMaskProvider() {\n@@ -193,1 +193,1 @@\n-                        flatMap(fa -> BYTE_BUFFER_GENERATORS.stream().\n+                        flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n@@ -200,19 +200,0 @@\n-    @DataProvider\n-    public Object[][] byteByteArrayProvider() {\n-        return BYTE_GENERATORS.stream().\n-                flatMap(fa -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                    return new Object[]{fa, bo};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] byteByteArrayMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> BYTE_GENERATORS.stream().\n-                    flatMap(fa -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                        return new Object[]{fa, fm, bo};\n-                    }))).\n-                toArray(Object[][]::new);\n-    }\n-\n@@ -238,4 +219,4 @@\n-    static ByteBuffer toBuffer(byte[] a, IntFunction<ByteBuffer> fb) {\n-        ByteBuffer bb = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n-        for (byte v : a) {\n-            bb.put(v);\n+    static MemorySegment toSegment(byte[] a, IntFunction<MemorySegment> fb) {\n+        MemorySegment ms = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n+        for (int i = 0; i < a.length; i++) {\n+            ms.set(ValueLayout.JAVA_BYTE, i * SPECIES.elementSize() \/ 8 , a[i]);\n@@ -243,8 +224,1 @@\n-        return bb.clear();\n-    }\n-\n-    static byte[] bufferToArray(ByteBuffer bb) {\n-        ByteBuffer db = bb;\n-        byte[] d = new byte[db.capacity()];\n-        db.get(0, d);\n-        return d;\n+        return ms;\n@@ -253,7 +227,2 @@\n-    static byte[] toByteArray(byte[] a, IntFunction<byte[]> fb, ByteOrder bo) {\n-        byte[] b = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n-        ByteBuffer bb = ByteBuffer.wrap(b, 0, b.length).order(bo);\n-        for (byte v : a) {\n-            bb.put(v);\n-        }\n-        return b;\n+    static byte[] segmentToArray(MemorySegment ms) {\n+        return ms.toArray(ValueLayout.JAVA_BYTE);\n@@ -299,2 +268,2 @@\n-    static ByteVector fromByteArray(byte[] a, int i, ByteOrder bo) {\n-        return ByteVector.fromByteArray(SPECIES, a, i, bo);\n+    static ByteVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo) {\n+        return ByteVector.fromMemorySegment(SPECIES, a, i, bo);\n@@ -304,2 +273,2 @@\n-    static ByteVector fromByteArray(byte[] a, int i, ByteOrder bo, VectorMask<Byte> m) {\n-        return ByteVector.fromByteArray(SPECIES, a, i, bo, m);\n+    static ByteVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo, VectorMask<Byte> m) {\n+        return ByteVector.fromMemorySegment(SPECIES, a, i, bo, m);\n@@ -309,2 +278,2 @@\n-    static void intoByteArray(ByteVector v, byte[] a, int i, ByteOrder bo) {\n-        v.intoByteArray(a, i, bo);\n+    static void intoMemorySegment(ByteVector v, MemorySegment a, int i, ByteOrder bo) {\n+        v.intoMemorySegment(a, i, bo);\n@@ -314,2 +283,2 @@\n-    static void intoByteArray(ByteVector v, byte[] a, int i, ByteOrder bo, VectorMask<Byte> m) {\n-        v.intoByteArray(a, i, bo, m);\n+    static void intoMemorySegment(ByteVector v, MemorySegment a, int i, ByteOrder bo, VectorMask<Byte> m) {\n+        v.intoMemorySegment(a, i, bo, m);\n@@ -318,21 +287,0 @@\n-    @DontInline\n-    static ByteVector fromByteBuffer(ByteBuffer a, int i, ByteOrder bo) {\n-        return ByteVector.fromByteBuffer(SPECIES, a, i, bo);\n-    }\n-\n-    @DontInline\n-    static ByteVector fromByteBuffer(ByteBuffer a, int i, ByteOrder bo, VectorMask<Byte> m) {\n-        return ByteVector.fromByteBuffer(SPECIES, a, i, bo, m);\n-    }\n-\n-    @DontInline\n-    static void intoByteBuffer(ByteVector v, ByteBuffer a, int i, ByteOrder bo) {\n-        v.intoByteBuffer(a, i, bo);\n-    }\n-\n-    @DontInline\n-    static void intoByteBuffer(ByteVector v, ByteBuffer a, int i, ByteOrder bo, VectorMask<Byte> m) {\n-        v.intoByteBuffer(a, i, bo, m);\n-    }\n-\n-\n@@ -509,6 +457,6 @@\n-    @Test(dataProvider = \"byteByteBufferProvider\")\n-    static void loadStoreByteBuffer(IntFunction<byte[]> fa,\n-                                    IntFunction<ByteBuffer> fb,\n-                                    ByteOrder bo) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), fb);\n-        ByteBuffer r = fb.apply(a.limit());\n+    @Test(dataProvider = \"byteMemorySegmentProvider\")\n+    static void loadStoreMemorySegment(IntFunction<byte[]> fa,\n+                                       IntFunction<MemorySegment> fb,\n+                                       ByteOrder bo) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb);\n+        MemorySegment r = fb.apply((int) a.byteSize());\n@@ -516,1 +464,1 @@\n-        int l = a.limit();\n+        int l = (int) a.byteSize();\n@@ -521,2 +469,2 @@\n-                ByteVector av = ByteVector.fromByteBuffer(SPECIES, a, i, bo);\n-                av.intoByteBuffer(r, i, bo);\n+                ByteVector av = ByteVector.fromMemorySegment(SPECIES, a, i, bo);\n+                av.intoMemorySegment(r, i, bo);\n@@ -525,5 +473,2 @@\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        Assert.assertEquals(r, a, \"Buffers not equal\");\n+        long m = r.mismatch(a);\n+        Assert.assertEquals(m, -1, \"Segments not equal\");\n@@ -533,3 +478,3 @@\n-    static void loadByteBufferIOOBE(IntFunction<byte[]> fa, IntFunction<Integer> fi) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n+    static void loadMemorySegmentIOOBE(IntFunction<byte[]> fa, IntFunction<Integer> fi) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n@@ -537,1 +482,1 @@\n-        int l = a.limit();\n+        int l = (int) a.byteSize();\n@@ -542,2 +487,2 @@\n-                ByteVector av = fromByteBuffer(a, i, ByteOrder.nativeOrder());\n-                av.intoByteBuffer(r, i, ByteOrder.nativeOrder());\n+                ByteVector av = fromMemorySegment(a, i, ByteOrder.nativeOrder());\n+                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n@@ -547,2 +492,2 @@\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.limit());\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());\n@@ -550,1 +495,1 @@\n-            fromByteBuffer(a, index, ByteOrder.nativeOrder());\n+            fromMemorySegment(a, index, ByteOrder.nativeOrder());\n@@ -562,3 +507,3 @@\n-    static void storeByteBufferIOOBE(IntFunction<byte[]> fa, IntFunction<Integer> fi) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n+    static void storeMemorySegmentIOOBE(IntFunction<byte[]> fa, IntFunction<Integer> fi) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n@@ -566,1 +511,1 @@\n-        int l = a.limit();\n+        int l = (int) a.byteSize();\n@@ -571,2 +516,2 @@\n-                ByteVector av = ByteVector.fromByteBuffer(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteBuffer(av, r, i, ByteOrder.nativeOrder());\n+                ByteVector av = ByteVector.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+                intoMemorySegment(av, r, i, ByteOrder.nativeOrder());\n@@ -576,2 +521,2 @@\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.limit());\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());\n@@ -579,2 +524,2 @@\n-            ByteVector av = ByteVector.fromByteBuffer(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteBuffer(av, r, index, ByteOrder.nativeOrder());\n+            ByteVector av = ByteVector.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+            intoMemorySegment(av, r, index, ByteOrder.nativeOrder());\n@@ -591,6 +536,5 @@\n-\n-    @Test(dataProvider = \"byteByteBufferMaskProvider\")\n-    static void loadStoreByteBufferMask(IntFunction<byte[]> fa,\n-                                        IntFunction<ByteBuffer> fb,\n-                                        IntFunction<boolean[]> fm,\n-                                        ByteOrder bo) {\n+    @Test(dataProvider = \"byteMemorySegmentMaskProvider\")\n+    static void loadStoreMemorySegmentMask(IntFunction<byte[]> fa,\n+                                           IntFunction<MemorySegment> fb,\n+                                           IntFunction<boolean[]> fm,\n+                                           ByteOrder bo) {\n@@ -598,2 +542,2 @@\n-        ByteBuffer a = toBuffer(_a, fb);\n-        ByteBuffer r = fb.apply(a.limit());\n+        MemorySegment a = toSegment(_a, fb);\n+        MemorySegment r = fb.apply((int) a.byteSize());\n@@ -603,1 +547,1 @@\n-        int l = a.limit();\n+        int l = (int) a.byteSize();\n@@ -608,2 +552,2 @@\n-                ByteVector av = ByteVector.fromByteBuffer(SPECIES, a, i, bo, vmask);\n-                av.intoByteBuffer(r, i, bo);\n+                ByteVector av = ByteVector.fromMemorySegment(SPECIES, a, i, bo, vmask);\n+                av.intoMemorySegment(r, i, bo);\n@@ -612,5 +556,1 @@\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        assertArraysEquals(bufferToArray(r), _a, mask);\n+        assertArraysEquals(segmentToArray(r), _a, mask);\n@@ -619,1 +559,1 @@\n-        r = fb.apply(a.limit());\n+        r = fb.apply((int) a.byteSize());\n@@ -623,2 +563,2 @@\n-                ByteVector av = ByteVector.fromByteBuffer(SPECIES, a, i, bo);\n-                av.intoByteBuffer(r, i, bo, vmask);\n+                ByteVector av = ByteVector.fromMemorySegment(SPECIES, a, i, bo);\n+                av.intoMemorySegment(r, i, bo, vmask);\n@@ -627,5 +567,1 @@\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        assertArraysEquals(bufferToArray(r), _a, mask);\n+        assertArraysEquals(segmentToArray(r), _a, mask);\n@@ -635,3 +571,3 @@\n-    static void loadByteBufferMaskIOOBE(IntFunction<byte[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n+    static void loadMemorySegmentMaskIOOBE(IntFunction<byte[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n@@ -641,1 +577,1 @@\n-        int l = a.limit();\n+        int l = (int) a.byteSize();\n@@ -646,2 +582,2 @@\n-                ByteVector av = fromByteBuffer(a, i, ByteOrder.nativeOrder(), vmask);\n-                av.intoByteBuffer(r, i, ByteOrder.nativeOrder());\n+                ByteVector av = fromMemorySegment(a, i, ByteOrder.nativeOrder(), vmask);\n+                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n@@ -651,2 +587,2 @@\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.limit(), SPECIES.elementSize() \/ 8);\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() \/ 8);\n@@ -654,1 +590,1 @@\n-            fromByteBuffer(a, index, ByteOrder.nativeOrder(), vmask);\n+            fromMemorySegment(a, index, ByteOrder.nativeOrder(), vmask);\n@@ -666,3 +602,3 @@\n-    static void storeByteBufferMaskIOOBE(IntFunction<byte[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n+    static void storeMemorySegmentMaskIOOBE(IntFunction<byte[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n@@ -672,112 +608,1 @@\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ByteVector av = ByteVector.fromByteBuffer(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteBuffer(av, r, i, ByteOrder.nativeOrder(), vmask);\n-            }\n-        }\n-\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.limit(), SPECIES.elementSize() \/ 8);\n-        try {\n-            ByteVector av = ByteVector.fromByteBuffer(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteBuffer(av, a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"byteByteBufferProvider\")\n-    static void loadStoreReadonlyByteBuffer(IntFunction<byte[]> fa,\n-                                    IntFunction<ByteBuffer> fb,\n-                                    ByteOrder bo) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), fb).asReadOnlyBuffer();\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo);\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, SPECIES.maskAll(true));\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, SPECIES.maskAll(false));\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            VectorMask<Byte> m = SPECIES.shuffleFromOp(i -> i % 2 == 0 ? 1 : -1)\n-                    .laneIsValid();\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, m);\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"byteByteArrayProvider\")\n-    static void loadStoreByteArray(IntFunction<byte[]> fa,\n-                                    ByteOrder bo) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, bo);\n-        byte[] r = new byte[a.length];\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ByteVector av = ByteVector.fromByteArray(SPECIES, a, i, bo);\n-                av.intoByteArray(r, i, bo);\n-            }\n-        }\n-        Assert.assertEquals(r, a, \"Byte arrays not equal\");\n-    }\n-\n-    @Test(dataProvider = \"byteByteProviderForIOOBE\")\n-    static void loadByteArrayIOOBE(IntFunction<byte[]> fa, IntFunction<Integer> fi) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ByteVector av = fromByteArray(a, i, ByteOrder.nativeOrder());\n-                av.intoByteArray(r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.length);\n-        try {\n-            fromByteArray(a, index, ByteOrder.nativeOrder());\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-    @Test(dataProvider = \"byteByteProviderForIOOBE\")\n-    static void storeByteArrayIOOBE(IntFunction<byte[]> fa, IntFunction<Integer> fi) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-\n+        int l = (int) a.byteSize();\n@@ -785,1 +610,0 @@\n-        int l = a.length;\n@@ -789,2 +613,2 @@\n-                ByteVector av = ByteVector.fromByteArray(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteArray(av, r, i, ByteOrder.nativeOrder());\n+                ByteVector av = ByteVector.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+                intoMemorySegment(av, r, i, ByteOrder.nativeOrder(), vmask);\n@@ -794,2 +618,2 @@\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.length);\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() \/ 8);\n@@ -797,2 +621,2 @@\n-            ByteVector av = ByteVector.fromByteArray(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteArray(av, r, index, ByteOrder.nativeOrder());\n+            ByteVector av = ByteVector.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+            intoMemorySegment(av, a, index, ByteOrder.nativeOrder(), vmask);\n@@ -809,0 +633,5 @@\n+    @Test(dataProvider = \"byteMemorySegmentProvider\")\n+    static void loadStoreReadonlyMemorySegment(IntFunction<byte[]> fa,\n+                                               IntFunction<MemorySegment> fb,\n+                                               ByteOrder bo) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb).asReadOnly();\n@@ -810,38 +639,4 @@\n-    @Test(dataProvider = \"byteByteArrayMaskProvider\")\n-    static void loadStoreByteArrayMask(IntFunction<byte[]> fa,\n-                                  IntFunction<boolean[]> fm,\n-                                  ByteOrder bo) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, bo);\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Byte> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-          for (int i = 0; i < l; i += s) {\n-              ByteVector av = ByteVector.fromByteArray(SPECIES, a, i, bo, vmask);\n-              av.intoByteArray(r, i, bo);\n-          }\n-        }\n-        assertArraysEquals(r, a, mask);\n-\n-\n-        r = new byte[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ByteVector av = ByteVector.fromByteArray(SPECIES, a, i, bo);\n-                av.intoByteArray(r, i, bo, vmask);\n-            }\n-        }\n-        assertArraysEquals(r, a, mask);\n-    }\n-\n-    @Test(dataProvider = \"byteByteMaskProviderForIOOBE\")\n-    static void loadByteArrayMaskIOOBE(IntFunction<byte[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Byte> vmask = VectorMask.fromValues(SPECIES, mask);\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo)\n+        );\n@@ -849,2 +644,4 @@\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(true))\n+        );\n@@ -852,6 +649,4 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ByteVector av = fromByteArray(a, i, ByteOrder.nativeOrder(), vmask);\n-                av.intoByteArray(r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(false))\n+        );\n@@ -859,12 +654,6 @@\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length, SPECIES.elementSize() \/ 8);\n-        try {\n-            fromByteArray(a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n+        VectorMask<Byte> m = SPECIES.shuffleFromOp(i -> i % 2 == 0 ? 1 : -1)\n+                .laneIsValid();\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, m)\n+        );\n@@ -873,31 +662,0 @@\n-    @Test(dataProvider = \"byteByteMaskProviderForIOOBE\")\n-    static void storeByteArrayMaskIOOBE(IntFunction<byte[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Byte> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ByteVector av = ByteVector.fromByteArray(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteArray(av, r, i, ByteOrder.nativeOrder(), vmask);\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length, SPECIES.elementSize() \/ 8);\n-        try {\n-            ByteVector av = ByteVector.fromByteArray(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteArray(av, a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n@@ -919,0 +677,1 @@\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte512VectorLoadStoreTests.java","additions":112,"deletions":353,"binary":false,"changes":465,"status":"modified"},{"patch":"@@ -264,0 +264,49 @@\n+    static void assertcompressArraysEquals(byte[] r, byte[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    Assert.assertEquals(r[i + k], (byte)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (byte)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals(byte[] r, byte[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        Assert.assertEquals(r[i + j], (byte)0);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (byte)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n@@ -897,1 +946,0 @@\n-\n@@ -992,2 +1040,0 @@\n-\n-\n@@ -1069,1 +1115,0 @@\n-\n@@ -1210,0 +1255,15 @@\n+    static byte TRAILING_ZEROS_COUNT_scalar(byte a) {\n+        return (byte) (a != 0 ? Integer.numberOfTrailingZeros(a) : 8);\n+    }\n+\n+    static byte LEADING_ZEROS_COUNT_scalar(byte a) {\n+        return (byte) (a >= 0 ? Integer.numberOfLeadingZeros(a) - 24 : 0);\n+    }\n+\n+    static byte REVERSE_scalar(byte a) {\n+        byte b = (byte) ROL_scalar(a, (byte) 4);\n+        b = (byte) (((b & 0x55) << 1) | ((b & 0xAA) >>> 1));\n+        b = (byte) (((b & 0x33) << 2) | ((b & 0xCC) >>> 2));\n+        return b;\n+    }\n+\n@@ -1359,0 +1419,1 @@\n+\n@@ -1379,0 +1440,1 @@\n+\n@@ -1435,0 +1497,1 @@\n+\n@@ -1455,0 +1518,1 @@\n+\n@@ -1511,0 +1575,1 @@\n+\n@@ -1531,0 +1596,1 @@\n+\n@@ -1588,2 +1654,0 @@\n-\n-\n@@ -1612,0 +1676,1 @@\n+\n@@ -1635,2 +1700,0 @@\n-\n-\n@@ -1742,0 +1805,1 @@\n+\n@@ -1761,2 +1825,0 @@\n-\n-\n@@ -1783,1 +1845,0 @@\n-\n@@ -1805,2 +1866,0 @@\n-\n-\n@@ -1827,1 +1886,0 @@\n-\n@@ -1848,0 +1906,1 @@\n+\n@@ -1867,2 +1926,0 @@\n-\n-\n@@ -1889,1 +1946,0 @@\n-\n@@ -1911,2 +1967,0 @@\n-\n-\n@@ -1933,1 +1987,0 @@\n-\n@@ -2027,3 +2080,0 @@\n-\n-\n-\n@@ -2046,2 +2096,0 @@\n-\n-\n@@ -2067,2 +2115,0 @@\n-\n-\n@@ -2097,2 +2143,0 @@\n-\n-\n@@ -2116,2 +2160,0 @@\n-\n-\n@@ -2146,2 +2188,0 @@\n-\n-\n@@ -2165,2 +2205,0 @@\n-\n-\n@@ -2181,2 +2219,0 @@\n-\n-\n@@ -2200,1 +2236,0 @@\n-\n@@ -2232,2 +2267,0 @@\n-\n-\n@@ -2255,2 +2288,0 @@\n-\n-\n@@ -2277,5 +2308,0 @@\n-\n-\n-\n-\n-\n@@ -2303,2 +2329,0 @@\n-\n-\n@@ -2325,5 +2349,0 @@\n-\n-\n-\n-\n-\n@@ -2351,2 +2370,0 @@\n-\n-\n@@ -2373,5 +2390,0 @@\n-\n-\n-\n-\n-\n@@ -2398,2 +2410,0 @@\n-\n-\n@@ -2419,5 +2429,0 @@\n-\n-\n-\n-\n-\n@@ -2444,2 +2449,0 @@\n-\n-\n@@ -2465,5 +2468,0 @@\n-\n-\n-\n-\n-\n@@ -2490,2 +2488,0 @@\n-\n-\n@@ -2511,3 +2507,0 @@\n-\n-\n-\n@@ -2535,2 +2528,0 @@\n-\n-\n@@ -2557,1 +2548,0 @@\n-\n@@ -2579,2 +2569,0 @@\n-\n-\n@@ -2601,1 +2589,0 @@\n-\n@@ -2622,2 +2609,0 @@\n-\n-\n@@ -2643,1 +2628,0 @@\n-\n@@ -2664,2 +2648,0 @@\n-\n-\n@@ -2684,4 +2666,0 @@\n-\n-\n-\n-\n@@ -2707,2 +2685,0 @@\n-\n-\n@@ -2727,4 +2703,0 @@\n-\n-\n-\n-\n@@ -2750,2 +2722,0 @@\n-\n-\n@@ -2770,2 +2740,0 @@\n-\n-\n@@ -2791,2 +2759,0 @@\n-\n-\n@@ -2811,2 +2777,0 @@\n-\n-\n@@ -2832,2 +2796,0 @@\n-\n-\n@@ -2852,2 +2814,0 @@\n-\n-\n@@ -2873,2 +2833,0 @@\n-\n-\n@@ -2914,0 +2872,1 @@\n+\n@@ -2932,0 +2891,1 @@\n+\n@@ -2952,0 +2912,1 @@\n+\n@@ -3045,1 +3006,0 @@\n-\n@@ -3071,1 +3031,0 @@\n-\n@@ -3091,1 +3050,0 @@\n-\n@@ -3119,1 +3077,0 @@\n-\n@@ -3138,1 +3095,0 @@\n-\n@@ -3164,1 +3120,0 @@\n-\n@@ -3184,1 +3139,0 @@\n-\n@@ -3212,1 +3166,0 @@\n-\n@@ -3231,1 +3184,0 @@\n-\n@@ -3257,1 +3209,0 @@\n-\n@@ -3277,1 +3228,0 @@\n-\n@@ -3322,0 +3272,1 @@\n+\n@@ -3346,0 +3297,1 @@\n+\n@@ -3364,0 +3316,1 @@\n+\n@@ -3390,0 +3343,1 @@\n+\n@@ -3407,0 +3361,1 @@\n+\n@@ -3431,0 +3386,1 @@\n+\n@@ -3449,0 +3405,1 @@\n+\n@@ -3475,0 +3432,1 @@\n+\n@@ -3492,0 +3450,1 @@\n+\n@@ -3516,0 +3475,1 @@\n+\n@@ -3534,0 +3494,1 @@\n+\n@@ -3560,0 +3521,1 @@\n+\n@@ -3577,0 +3539,1 @@\n+\n@@ -3601,0 +3564,1 @@\n+\n@@ -3619,0 +3583,1 @@\n+\n@@ -3645,0 +3610,1 @@\n+\n@@ -3662,0 +3628,1 @@\n+\n@@ -3686,0 +3653,1 @@\n+\n@@ -3704,0 +3672,1 @@\n+\n@@ -3740,1 +3709,0 @@\n-\n@@ -3756,1 +3724,0 @@\n-\n@@ -3766,1 +3733,0 @@\n-\n@@ -3782,1 +3748,0 @@\n-\n@@ -3800,0 +3765,1 @@\n+\n@@ -3840,0 +3806,1 @@\n+\n@@ -3881,3 +3848,0 @@\n-\n-\n-\n@@ -3903,1 +3867,0 @@\n-\n@@ -3946,1 +3909,0 @@\n-\n@@ -3989,1 +3951,0 @@\n-\n@@ -4009,1 +3970,0 @@\n-\n@@ -4052,1 +4012,0 @@\n-\n@@ -4095,1 +4054,0 @@\n-\n@@ -4138,1 +4096,0 @@\n-\n@@ -4181,2 +4138,0 @@\n-\n-\n@@ -4202,2 +4157,0 @@\n-\n-\n@@ -4227,3 +4180,0 @@\n-\n-\n-\n@@ -4249,2 +4199,0 @@\n-\n-\n@@ -4274,3 +4222,0 @@\n-\n-\n-\n@@ -4296,2 +4241,0 @@\n-\n-\n@@ -4321,3 +4264,0 @@\n-\n-\n-\n@@ -4343,2 +4283,0 @@\n-\n-\n@@ -4368,2 +4306,0 @@\n-\n-\n@@ -4386,1 +4322,0 @@\n-\n@@ -4423,1 +4358,0 @@\n-\n@@ -4460,1 +4394,0 @@\n-\n@@ -4497,1 +4430,0 @@\n-\n@@ -4576,0 +4508,37 @@\n+\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void compressByte512VectorTests(IntFunction<byte[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.compress(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertcompressArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void expandByte512VectorTests(IntFunction<byte[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.expand(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertexpandArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n@@ -4746,4 +4715,0 @@\n-\n-\n-\n-\n@@ -4764,3 +4729,0 @@\n-\n-\n-\n@@ -4792,0 +4754,1 @@\n+\n@@ -4821,0 +4784,1 @@\n+\n@@ -4854,0 +4818,1 @@\n+\n@@ -4881,0 +4846,1 @@\n+\n@@ -4920,0 +4886,1 @@\n+\n@@ -4977,22 +4944,0 @@\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n@@ -5002,0 +4947,1 @@\n+\n@@ -5006,1 +4952,0 @@\n-\n@@ -5025,0 +4970,1 @@\n+\n@@ -5042,1 +4988,0 @@\n-\n@@ -5065,3 +5010,0 @@\n-\n-\n-\n@@ -5097,0 +5039,1 @@\n+\n@@ -5127,1 +5070,0 @@\n-\n@@ -5166,3 +5108,0 @@\n-\n-\n-\n@@ -5183,0 +5122,1 @@\n+\n@@ -5198,1 +5138,0 @@\n-\n@@ -5217,1 +5156,0 @@\n-\n@@ -5330,1 +5268,0 @@\n-\n@@ -5339,2 +5276,0 @@\n-\n-\n@@ -5371,2 +5306,0 @@\n-\n-\n@@ -5391,2 +5324,0 @@\n-\n-\n@@ -5397,2 +5328,0 @@\n-\n-\n@@ -5414,2 +5343,0 @@\n-\n-\n@@ -5434,0 +5361,151 @@\n+    static byte BIT_COUNT(byte a) {\n+        return (byte)(Integer.bitCount((int)a & 0xFF));\n+    }\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void BIT_COUNTByte512VectorTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Byte512VectorTests::BIT_COUNT);\n+    }\n+\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void BIT_COUNTMaskedByte512VectorTests(IntFunction<byte[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Byte512VectorTests::BIT_COUNT);\n+    }\n+\n+    static byte TRAILING_ZEROS_COUNT(byte a) {\n+        return (byte)(TRAILING_ZEROS_COUNT_scalar(a));\n+    }\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void TRAILING_ZEROS_COUNTByte512VectorTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TRAILING_ZEROS_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Byte512VectorTests::TRAILING_ZEROS_COUNT);\n+    }\n+\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void TRAILING_ZEROS_COUNTMaskedByte512VectorTests(IntFunction<byte[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TRAILING_ZEROS_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Byte512VectorTests::TRAILING_ZEROS_COUNT);\n+    }\n+\n+    static byte LEADING_ZEROS_COUNT(byte a) {\n+        return (byte)(LEADING_ZEROS_COUNT_scalar(a));\n+    }\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void LEADING_ZEROS_COUNTByte512VectorTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LEADING_ZEROS_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Byte512VectorTests::LEADING_ZEROS_COUNT);\n+    }\n+\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void LEADING_ZEROS_COUNTMaskedByte512VectorTests(IntFunction<byte[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LEADING_ZEROS_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Byte512VectorTests::LEADING_ZEROS_COUNT);\n+    }\n+\n+    static byte REVERSE(byte a) {\n+        return (byte)(REVERSE_scalar(a));\n+    }\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void REVERSEByte512VectorTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Byte512VectorTests::REVERSE);\n+    }\n+\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void REVERSEMaskedByte512VectorTests(IntFunction<byte[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Byte512VectorTests::REVERSE);\n+    }\n+\n+    static byte REVERSE_BYTES(byte a) {\n+        return (byte)(a);\n+    }\n@@ -5435,0 +5513,4 @@\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void REVERSE_BYTESByte512VectorTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n@@ -5436,0 +5518,6 @@\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES).intoArray(r, i);\n+            }\n+        }\n@@ -5437,0 +5525,20 @@\n+        assertArraysEquals(r, a, Byte512VectorTests::REVERSE_BYTES);\n+    }\n+\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void REVERSE_BYTESMaskedByte512VectorTests(IntFunction<byte[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Byte512VectorTests::REVERSE_BYTES);\n+    }\n@@ -5850,0 +5958,17 @@\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCompressByte512VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        int trueCount = 0;\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                trueCount = vmask.trueCount();\n+                var rmask = vmask.compress();\n+                for (int j = 0; j < SPECIES.length(); j++)  {\n+                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);\n+                }\n+            }\n+        }\n+    }\n+\n@@ -5892,0 +6017,14 @@\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeLongByte512VectorTestsSmokeTest(int offset) {\n+        long limit = SPECIES.length() * BUFFER_REPS;\n+        for (long i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i + offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                long index = i + j + offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n@@ -5912,0 +6051,8 @@\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundLongByte512VectorTestsSmokeTest(int _length) {\n+        long length = _length;\n+        long actualLoopBound = SPECIES.loopBound(length);\n+        long expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+    }\n+\n@@ -5974,1 +6121,0 @@\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte512VectorTests.java","additions":363,"deletions":217,"binary":false,"changes":580,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,3 @@\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.ValueLayout;\n@@ -42,1 +45,0 @@\n-import java.nio.ByteBuffer;\n@@ -44,1 +46,0 @@\n-import java.nio.ReadOnlyBufferException;\n@@ -69,1 +70,0 @@\n-\n@@ -109,1 +109,1 @@\n-    \/\/ Relative to byte[] array.length or ByteBuffer.limit()\n+    \/\/ Relative to byte[] array.length or MemorySegment.byteSize()\n@@ -180,1 +180,1 @@\n-    public Object[][] byteByteBufferProvider() {\n+    public Object[][] byteMemorySegmentProvider() {\n@@ -182,1 +182,1 @@\n-                flatMap(fa -> BYTE_BUFFER_GENERATORS.stream().\n+                flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n@@ -190,1 +190,1 @@\n-    public Object[][] byteByteBufferMaskProvider() {\n+    public Object[][] byteMemorySegmentMaskProvider() {\n@@ -193,1 +193,1 @@\n-                        flatMap(fa -> BYTE_BUFFER_GENERATORS.stream().\n+                        flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n@@ -200,19 +200,0 @@\n-    @DataProvider\n-    public Object[][] byteByteArrayProvider() {\n-        return BYTE_GENERATORS.stream().\n-                flatMap(fa -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                    return new Object[]{fa, bo};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] byteByteArrayMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> BYTE_GENERATORS.stream().\n-                    flatMap(fa -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                        return new Object[]{fa, fm, bo};\n-                    }))).\n-                toArray(Object[][]::new);\n-    }\n-\n@@ -238,4 +219,4 @@\n-    static ByteBuffer toBuffer(byte[] a, IntFunction<ByteBuffer> fb) {\n-        ByteBuffer bb = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n-        for (byte v : a) {\n-            bb.put(v);\n+    static MemorySegment toSegment(byte[] a, IntFunction<MemorySegment> fb) {\n+        MemorySegment ms = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n+        for (int i = 0; i < a.length; i++) {\n+            ms.set(ValueLayout.JAVA_BYTE, i * SPECIES.elementSize() \/ 8 , a[i]);\n@@ -243,8 +224,1 @@\n-        return bb.clear();\n-    }\n-\n-    static byte[] bufferToArray(ByteBuffer bb) {\n-        ByteBuffer db = bb;\n-        byte[] d = new byte[db.capacity()];\n-        db.get(0, d);\n-        return d;\n+        return ms;\n@@ -253,7 +227,2 @@\n-    static byte[] toByteArray(byte[] a, IntFunction<byte[]> fb, ByteOrder bo) {\n-        byte[] b = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n-        ByteBuffer bb = ByteBuffer.wrap(b, 0, b.length).order(bo);\n-        for (byte v : a) {\n-            bb.put(v);\n-        }\n-        return b;\n+    static byte[] segmentToArray(MemorySegment ms) {\n+        return ms.toArray(ValueLayout.JAVA_BYTE);\n@@ -299,2 +268,2 @@\n-    static ByteVector fromByteArray(byte[] a, int i, ByteOrder bo) {\n-        return ByteVector.fromByteArray(SPECIES, a, i, bo);\n+    static ByteVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo) {\n+        return ByteVector.fromMemorySegment(SPECIES, a, i, bo);\n@@ -304,2 +273,2 @@\n-    static ByteVector fromByteArray(byte[] a, int i, ByteOrder bo, VectorMask<Byte> m) {\n-        return ByteVector.fromByteArray(SPECIES, a, i, bo, m);\n+    static ByteVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo, VectorMask<Byte> m) {\n+        return ByteVector.fromMemorySegment(SPECIES, a, i, bo, m);\n@@ -309,2 +278,2 @@\n-    static void intoByteArray(ByteVector v, byte[] a, int i, ByteOrder bo) {\n-        v.intoByteArray(a, i, bo);\n+    static void intoMemorySegment(ByteVector v, MemorySegment a, int i, ByteOrder bo) {\n+        v.intoMemorySegment(a, i, bo);\n@@ -314,2 +283,2 @@\n-    static void intoByteArray(ByteVector v, byte[] a, int i, ByteOrder bo, VectorMask<Byte> m) {\n-        v.intoByteArray(a, i, bo, m);\n+    static void intoMemorySegment(ByteVector v, MemorySegment a, int i, ByteOrder bo, VectorMask<Byte> m) {\n+        v.intoMemorySegment(a, i, bo, m);\n@@ -318,21 +287,0 @@\n-    @DontInline\n-    static ByteVector fromByteBuffer(ByteBuffer a, int i, ByteOrder bo) {\n-        return ByteVector.fromByteBuffer(SPECIES, a, i, bo);\n-    }\n-\n-    @DontInline\n-    static ByteVector fromByteBuffer(ByteBuffer a, int i, ByteOrder bo, VectorMask<Byte> m) {\n-        return ByteVector.fromByteBuffer(SPECIES, a, i, bo, m);\n-    }\n-\n-    @DontInline\n-    static void intoByteBuffer(ByteVector v, ByteBuffer a, int i, ByteOrder bo) {\n-        v.intoByteBuffer(a, i, bo);\n-    }\n-\n-    @DontInline\n-    static void intoByteBuffer(ByteVector v, ByteBuffer a, int i, ByteOrder bo, VectorMask<Byte> m) {\n-        v.intoByteBuffer(a, i, bo, m);\n-    }\n-\n-\n@@ -509,6 +457,6 @@\n-    @Test(dataProvider = \"byteByteBufferProvider\")\n-    static void loadStoreByteBuffer(IntFunction<byte[]> fa,\n-                                    IntFunction<ByteBuffer> fb,\n-                                    ByteOrder bo) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), fb);\n-        ByteBuffer r = fb.apply(a.limit());\n+    @Test(dataProvider = \"byteMemorySegmentProvider\")\n+    static void loadStoreMemorySegment(IntFunction<byte[]> fa,\n+                                       IntFunction<MemorySegment> fb,\n+                                       ByteOrder bo) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb);\n+        MemorySegment r = fb.apply((int) a.byteSize());\n@@ -516,1 +464,1 @@\n-        int l = a.limit();\n+        int l = (int) a.byteSize();\n@@ -521,2 +469,2 @@\n-                ByteVector av = ByteVector.fromByteBuffer(SPECIES, a, i, bo);\n-                av.intoByteBuffer(r, i, bo);\n+                ByteVector av = ByteVector.fromMemorySegment(SPECIES, a, i, bo);\n+                av.intoMemorySegment(r, i, bo);\n@@ -525,5 +473,2 @@\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        Assert.assertEquals(r, a, \"Buffers not equal\");\n+        long m = r.mismatch(a);\n+        Assert.assertEquals(m, -1, \"Segments not equal\");\n@@ -533,3 +478,3 @@\n-    static void loadByteBufferIOOBE(IntFunction<byte[]> fa, IntFunction<Integer> fi) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n+    static void loadMemorySegmentIOOBE(IntFunction<byte[]> fa, IntFunction<Integer> fi) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n@@ -537,1 +482,1 @@\n-        int l = a.limit();\n+        int l = (int) a.byteSize();\n@@ -542,2 +487,2 @@\n-                ByteVector av = fromByteBuffer(a, i, ByteOrder.nativeOrder());\n-                av.intoByteBuffer(r, i, ByteOrder.nativeOrder());\n+                ByteVector av = fromMemorySegment(a, i, ByteOrder.nativeOrder());\n+                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n@@ -547,2 +492,2 @@\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.limit());\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());\n@@ -550,1 +495,1 @@\n-            fromByteBuffer(a, index, ByteOrder.nativeOrder());\n+            fromMemorySegment(a, index, ByteOrder.nativeOrder());\n@@ -562,3 +507,3 @@\n-    static void storeByteBufferIOOBE(IntFunction<byte[]> fa, IntFunction<Integer> fi) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n+    static void storeMemorySegmentIOOBE(IntFunction<byte[]> fa, IntFunction<Integer> fi) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n@@ -566,1 +511,1 @@\n-        int l = a.limit();\n+        int l = (int) a.byteSize();\n@@ -571,2 +516,2 @@\n-                ByteVector av = ByteVector.fromByteBuffer(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteBuffer(av, r, i, ByteOrder.nativeOrder());\n+                ByteVector av = ByteVector.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+                intoMemorySegment(av, r, i, ByteOrder.nativeOrder());\n@@ -576,2 +521,2 @@\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.limit());\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());\n@@ -579,2 +524,2 @@\n-            ByteVector av = ByteVector.fromByteBuffer(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteBuffer(av, r, index, ByteOrder.nativeOrder());\n+            ByteVector av = ByteVector.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+            intoMemorySegment(av, r, index, ByteOrder.nativeOrder());\n@@ -591,6 +536,5 @@\n-\n-    @Test(dataProvider = \"byteByteBufferMaskProvider\")\n-    static void loadStoreByteBufferMask(IntFunction<byte[]> fa,\n-                                        IntFunction<ByteBuffer> fb,\n-                                        IntFunction<boolean[]> fm,\n-                                        ByteOrder bo) {\n+    @Test(dataProvider = \"byteMemorySegmentMaskProvider\")\n+    static void loadStoreMemorySegmentMask(IntFunction<byte[]> fa,\n+                                           IntFunction<MemorySegment> fb,\n+                                           IntFunction<boolean[]> fm,\n+                                           ByteOrder bo) {\n@@ -598,2 +542,2 @@\n-        ByteBuffer a = toBuffer(_a, fb);\n-        ByteBuffer r = fb.apply(a.limit());\n+        MemorySegment a = toSegment(_a, fb);\n+        MemorySegment r = fb.apply((int) a.byteSize());\n@@ -603,1 +547,1 @@\n-        int l = a.limit();\n+        int l = (int) a.byteSize();\n@@ -608,2 +552,2 @@\n-                ByteVector av = ByteVector.fromByteBuffer(SPECIES, a, i, bo, vmask);\n-                av.intoByteBuffer(r, i, bo);\n+                ByteVector av = ByteVector.fromMemorySegment(SPECIES, a, i, bo, vmask);\n+                av.intoMemorySegment(r, i, bo);\n@@ -612,5 +556,1 @@\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        assertArraysEquals(bufferToArray(r), _a, mask);\n+        assertArraysEquals(segmentToArray(r), _a, mask);\n@@ -619,1 +559,1 @@\n-        r = fb.apply(a.limit());\n+        r = fb.apply((int) a.byteSize());\n@@ -623,2 +563,2 @@\n-                ByteVector av = ByteVector.fromByteBuffer(SPECIES, a, i, bo);\n-                av.intoByteBuffer(r, i, bo, vmask);\n+                ByteVector av = ByteVector.fromMemorySegment(SPECIES, a, i, bo);\n+                av.intoMemorySegment(r, i, bo, vmask);\n@@ -627,5 +567,1 @@\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        assertArraysEquals(bufferToArray(r), _a, mask);\n+        assertArraysEquals(segmentToArray(r), _a, mask);\n@@ -635,3 +571,3 @@\n-    static void loadByteBufferMaskIOOBE(IntFunction<byte[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n+    static void loadMemorySegmentMaskIOOBE(IntFunction<byte[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n@@ -641,1 +577,1 @@\n-        int l = a.limit();\n+        int l = (int) a.byteSize();\n@@ -646,2 +582,2 @@\n-                ByteVector av = fromByteBuffer(a, i, ByteOrder.nativeOrder(), vmask);\n-                av.intoByteBuffer(r, i, ByteOrder.nativeOrder());\n+                ByteVector av = fromMemorySegment(a, i, ByteOrder.nativeOrder(), vmask);\n+                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n@@ -651,2 +587,2 @@\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.limit(), SPECIES.elementSize() \/ 8);\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() \/ 8);\n@@ -654,1 +590,1 @@\n-            fromByteBuffer(a, index, ByteOrder.nativeOrder(), vmask);\n+            fromMemorySegment(a, index, ByteOrder.nativeOrder(), vmask);\n@@ -666,3 +602,3 @@\n-    static void storeByteBufferMaskIOOBE(IntFunction<byte[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n+    static void storeMemorySegmentMaskIOOBE(IntFunction<byte[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n@@ -672,112 +608,1 @@\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ByteVector av = ByteVector.fromByteBuffer(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteBuffer(av, r, i, ByteOrder.nativeOrder(), vmask);\n-            }\n-        }\n-\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.limit(), SPECIES.elementSize() \/ 8);\n-        try {\n-            ByteVector av = ByteVector.fromByteBuffer(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteBuffer(av, a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"byteByteBufferProvider\")\n-    static void loadStoreReadonlyByteBuffer(IntFunction<byte[]> fa,\n-                                    IntFunction<ByteBuffer> fb,\n-                                    ByteOrder bo) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), fb).asReadOnlyBuffer();\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo);\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, SPECIES.maskAll(true));\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, SPECIES.maskAll(false));\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            VectorMask<Byte> m = SPECIES.shuffleFromOp(i -> i % 2 == 0 ? 1 : -1)\n-                    .laneIsValid();\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, m);\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"byteByteArrayProvider\")\n-    static void loadStoreByteArray(IntFunction<byte[]> fa,\n-                                    ByteOrder bo) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, bo);\n-        byte[] r = new byte[a.length];\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ByteVector av = ByteVector.fromByteArray(SPECIES, a, i, bo);\n-                av.intoByteArray(r, i, bo);\n-            }\n-        }\n-        Assert.assertEquals(r, a, \"Byte arrays not equal\");\n-    }\n-\n-    @Test(dataProvider = \"byteByteProviderForIOOBE\")\n-    static void loadByteArrayIOOBE(IntFunction<byte[]> fa, IntFunction<Integer> fi) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ByteVector av = fromByteArray(a, i, ByteOrder.nativeOrder());\n-                av.intoByteArray(r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.length);\n-        try {\n-            fromByteArray(a, index, ByteOrder.nativeOrder());\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-    @Test(dataProvider = \"byteByteProviderForIOOBE\")\n-    static void storeByteArrayIOOBE(IntFunction<byte[]> fa, IntFunction<Integer> fi) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-\n+        int l = (int) a.byteSize();\n@@ -785,1 +610,0 @@\n-        int l = a.length;\n@@ -789,2 +613,2 @@\n-                ByteVector av = ByteVector.fromByteArray(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteArray(av, r, i, ByteOrder.nativeOrder());\n+                ByteVector av = ByteVector.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+                intoMemorySegment(av, r, i, ByteOrder.nativeOrder(), vmask);\n@@ -794,2 +618,2 @@\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.length);\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() \/ 8);\n@@ -797,2 +621,2 @@\n-            ByteVector av = ByteVector.fromByteArray(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteArray(av, r, index, ByteOrder.nativeOrder());\n+            ByteVector av = ByteVector.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+            intoMemorySegment(av, a, index, ByteOrder.nativeOrder(), vmask);\n@@ -809,0 +633,5 @@\n+    @Test(dataProvider = \"byteMemorySegmentProvider\")\n+    static void loadStoreReadonlyMemorySegment(IntFunction<byte[]> fa,\n+                                               IntFunction<MemorySegment> fb,\n+                                               ByteOrder bo) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb).asReadOnly();\n@@ -810,38 +639,4 @@\n-    @Test(dataProvider = \"byteByteArrayMaskProvider\")\n-    static void loadStoreByteArrayMask(IntFunction<byte[]> fa,\n-                                  IntFunction<boolean[]> fm,\n-                                  ByteOrder bo) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, bo);\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Byte> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-          for (int i = 0; i < l; i += s) {\n-              ByteVector av = ByteVector.fromByteArray(SPECIES, a, i, bo, vmask);\n-              av.intoByteArray(r, i, bo);\n-          }\n-        }\n-        assertArraysEquals(r, a, mask);\n-\n-\n-        r = new byte[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ByteVector av = ByteVector.fromByteArray(SPECIES, a, i, bo);\n-                av.intoByteArray(r, i, bo, vmask);\n-            }\n-        }\n-        assertArraysEquals(r, a, mask);\n-    }\n-\n-    @Test(dataProvider = \"byteByteMaskProviderForIOOBE\")\n-    static void loadByteArrayMaskIOOBE(IntFunction<byte[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Byte> vmask = VectorMask.fromValues(SPECIES, mask);\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo)\n+        );\n@@ -849,2 +644,4 @@\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(true))\n+        );\n@@ -852,6 +649,4 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ByteVector av = fromByteArray(a, i, ByteOrder.nativeOrder(), vmask);\n-                av.intoByteArray(r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(false))\n+        );\n@@ -859,12 +654,6 @@\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length, SPECIES.elementSize() \/ 8);\n-        try {\n-            fromByteArray(a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n+        VectorMask<Byte> m = SPECIES.shuffleFromOp(i -> i % 2 == 0 ? 1 : -1)\n+                .laneIsValid();\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, m)\n+        );\n@@ -873,31 +662,0 @@\n-    @Test(dataProvider = \"byteByteMaskProviderForIOOBE\")\n-    static void storeByteArrayMaskIOOBE(IntFunction<byte[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Byte> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ByteVector av = ByteVector.fromByteArray(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteArray(av, r, i, ByteOrder.nativeOrder(), vmask);\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length, SPECIES.elementSize() \/ 8);\n-        try {\n-            ByteVector av = ByteVector.fromByteArray(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteArray(av, a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n@@ -919,0 +677,1 @@\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte64VectorLoadStoreTests.java","additions":112,"deletions":353,"binary":false,"changes":465,"status":"modified"},{"patch":"@@ -264,0 +264,49 @@\n+    static void assertcompressArraysEquals(byte[] r, byte[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    Assert.assertEquals(r[i + k], (byte)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (byte)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals(byte[] r, byte[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        Assert.assertEquals(r[i + j], (byte)0);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (byte)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n@@ -897,1 +946,0 @@\n-\n@@ -992,2 +1040,0 @@\n-\n-\n@@ -1069,1 +1115,0 @@\n-\n@@ -1210,0 +1255,15 @@\n+    static byte TRAILING_ZEROS_COUNT_scalar(byte a) {\n+        return (byte) (a != 0 ? Integer.numberOfTrailingZeros(a) : 8);\n+    }\n+\n+    static byte LEADING_ZEROS_COUNT_scalar(byte a) {\n+        return (byte) (a >= 0 ? Integer.numberOfLeadingZeros(a) - 24 : 0);\n+    }\n+\n+    static byte REVERSE_scalar(byte a) {\n+        byte b = (byte) ROL_scalar(a, (byte) 4);\n+        b = (byte) (((b & 0x55) << 1) | ((b & 0xAA) >>> 1));\n+        b = (byte) (((b & 0x33) << 2) | ((b & 0xCC) >>> 2));\n+        return b;\n+    }\n+\n@@ -1359,0 +1419,1 @@\n+\n@@ -1379,0 +1440,1 @@\n+\n@@ -1435,0 +1497,1 @@\n+\n@@ -1455,0 +1518,1 @@\n+\n@@ -1511,0 +1575,1 @@\n+\n@@ -1531,0 +1596,1 @@\n+\n@@ -1588,2 +1654,0 @@\n-\n-\n@@ -1612,0 +1676,1 @@\n+\n@@ -1635,2 +1700,0 @@\n-\n-\n@@ -1742,0 +1805,1 @@\n+\n@@ -1761,2 +1825,0 @@\n-\n-\n@@ -1783,1 +1845,0 @@\n-\n@@ -1805,2 +1866,0 @@\n-\n-\n@@ -1827,1 +1886,0 @@\n-\n@@ -1848,0 +1906,1 @@\n+\n@@ -1867,2 +1926,0 @@\n-\n-\n@@ -1889,1 +1946,0 @@\n-\n@@ -1911,2 +1967,0 @@\n-\n-\n@@ -1933,1 +1987,0 @@\n-\n@@ -2027,3 +2080,0 @@\n-\n-\n-\n@@ -2046,2 +2096,0 @@\n-\n-\n@@ -2067,2 +2115,0 @@\n-\n-\n@@ -2097,2 +2143,0 @@\n-\n-\n@@ -2116,2 +2160,0 @@\n-\n-\n@@ -2146,2 +2188,0 @@\n-\n-\n@@ -2165,2 +2205,0 @@\n-\n-\n@@ -2181,2 +2219,0 @@\n-\n-\n@@ -2200,1 +2236,0 @@\n-\n@@ -2232,2 +2267,0 @@\n-\n-\n@@ -2255,2 +2288,0 @@\n-\n-\n@@ -2277,5 +2308,0 @@\n-\n-\n-\n-\n-\n@@ -2303,2 +2329,0 @@\n-\n-\n@@ -2325,5 +2349,0 @@\n-\n-\n-\n-\n-\n@@ -2351,2 +2370,0 @@\n-\n-\n@@ -2373,5 +2390,0 @@\n-\n-\n-\n-\n-\n@@ -2398,2 +2410,0 @@\n-\n-\n@@ -2419,5 +2429,0 @@\n-\n-\n-\n-\n-\n@@ -2444,2 +2449,0 @@\n-\n-\n@@ -2465,5 +2468,0 @@\n-\n-\n-\n-\n-\n@@ -2490,2 +2488,0 @@\n-\n-\n@@ -2511,3 +2507,0 @@\n-\n-\n-\n@@ -2535,2 +2528,0 @@\n-\n-\n@@ -2557,1 +2548,0 @@\n-\n@@ -2579,2 +2569,0 @@\n-\n-\n@@ -2601,1 +2589,0 @@\n-\n@@ -2622,2 +2609,0 @@\n-\n-\n@@ -2643,1 +2628,0 @@\n-\n@@ -2664,2 +2648,0 @@\n-\n-\n@@ -2684,4 +2666,0 @@\n-\n-\n-\n-\n@@ -2707,2 +2685,0 @@\n-\n-\n@@ -2727,4 +2703,0 @@\n-\n-\n-\n-\n@@ -2750,2 +2722,0 @@\n-\n-\n@@ -2770,2 +2740,0 @@\n-\n-\n@@ -2791,2 +2759,0 @@\n-\n-\n@@ -2811,2 +2777,0 @@\n-\n-\n@@ -2832,2 +2796,0 @@\n-\n-\n@@ -2852,2 +2814,0 @@\n-\n-\n@@ -2873,2 +2833,0 @@\n-\n-\n@@ -2914,0 +2872,1 @@\n+\n@@ -2932,0 +2891,1 @@\n+\n@@ -2952,0 +2912,1 @@\n+\n@@ -3045,1 +3006,0 @@\n-\n@@ -3071,1 +3031,0 @@\n-\n@@ -3091,1 +3050,0 @@\n-\n@@ -3119,1 +3077,0 @@\n-\n@@ -3138,1 +3095,0 @@\n-\n@@ -3164,1 +3120,0 @@\n-\n@@ -3184,1 +3139,0 @@\n-\n@@ -3212,1 +3166,0 @@\n-\n@@ -3231,1 +3184,0 @@\n-\n@@ -3257,1 +3209,0 @@\n-\n@@ -3277,1 +3228,0 @@\n-\n@@ -3322,0 +3272,1 @@\n+\n@@ -3346,0 +3297,1 @@\n+\n@@ -3364,0 +3316,1 @@\n+\n@@ -3390,0 +3343,1 @@\n+\n@@ -3407,0 +3361,1 @@\n+\n@@ -3431,0 +3386,1 @@\n+\n@@ -3449,0 +3405,1 @@\n+\n@@ -3475,0 +3432,1 @@\n+\n@@ -3492,0 +3450,1 @@\n+\n@@ -3516,0 +3475,1 @@\n+\n@@ -3534,0 +3494,1 @@\n+\n@@ -3560,0 +3521,1 @@\n+\n@@ -3577,0 +3539,1 @@\n+\n@@ -3601,0 +3564,1 @@\n+\n@@ -3619,0 +3583,1 @@\n+\n@@ -3645,0 +3610,1 @@\n+\n@@ -3662,0 +3628,1 @@\n+\n@@ -3686,0 +3653,1 @@\n+\n@@ -3704,0 +3672,1 @@\n+\n@@ -3740,1 +3709,0 @@\n-\n@@ -3756,1 +3724,0 @@\n-\n@@ -3766,1 +3733,0 @@\n-\n@@ -3782,1 +3748,0 @@\n-\n@@ -3800,0 +3765,1 @@\n+\n@@ -3840,0 +3806,1 @@\n+\n@@ -3881,3 +3848,0 @@\n-\n-\n-\n@@ -3903,1 +3867,0 @@\n-\n@@ -3946,1 +3909,0 @@\n-\n@@ -3989,1 +3951,0 @@\n-\n@@ -4009,1 +3970,0 @@\n-\n@@ -4052,1 +4012,0 @@\n-\n@@ -4095,1 +4054,0 @@\n-\n@@ -4138,1 +4096,0 @@\n-\n@@ -4181,2 +4138,0 @@\n-\n-\n@@ -4202,2 +4157,0 @@\n-\n-\n@@ -4227,3 +4180,0 @@\n-\n-\n-\n@@ -4249,2 +4199,0 @@\n-\n-\n@@ -4274,3 +4222,0 @@\n-\n-\n-\n@@ -4296,2 +4241,0 @@\n-\n-\n@@ -4321,3 +4264,0 @@\n-\n-\n-\n@@ -4343,2 +4283,0 @@\n-\n-\n@@ -4368,2 +4306,0 @@\n-\n-\n@@ -4386,1 +4322,0 @@\n-\n@@ -4423,1 +4358,0 @@\n-\n@@ -4460,1 +4394,0 @@\n-\n@@ -4497,1 +4430,0 @@\n-\n@@ -4576,0 +4508,37 @@\n+\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void compressByte64VectorTests(IntFunction<byte[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.compress(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertcompressArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void expandByte64VectorTests(IntFunction<byte[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.expand(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertexpandArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n@@ -4746,4 +4715,0 @@\n-\n-\n-\n-\n@@ -4764,3 +4729,0 @@\n-\n-\n-\n@@ -4792,0 +4754,1 @@\n+\n@@ -4821,0 +4784,1 @@\n+\n@@ -4854,0 +4818,1 @@\n+\n@@ -4881,0 +4846,1 @@\n+\n@@ -4920,0 +4886,1 @@\n+\n@@ -4977,22 +4944,0 @@\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n@@ -5002,0 +4947,1 @@\n+\n@@ -5006,1 +4952,0 @@\n-\n@@ -5025,0 +4970,1 @@\n+\n@@ -5042,1 +4988,0 @@\n-\n@@ -5065,3 +5010,0 @@\n-\n-\n-\n@@ -5097,0 +5039,1 @@\n+\n@@ -5127,1 +5070,0 @@\n-\n@@ -5166,3 +5108,0 @@\n-\n-\n-\n@@ -5183,0 +5122,1 @@\n+\n@@ -5198,1 +5138,0 @@\n-\n@@ -5217,1 +5156,0 @@\n-\n@@ -5330,1 +5268,0 @@\n-\n@@ -5339,2 +5276,0 @@\n-\n-\n@@ -5371,2 +5306,0 @@\n-\n-\n@@ -5391,2 +5324,0 @@\n-\n-\n@@ -5397,2 +5328,0 @@\n-\n-\n@@ -5414,2 +5343,0 @@\n-\n-\n@@ -5434,0 +5361,151 @@\n+    static byte BIT_COUNT(byte a) {\n+        return (byte)(Integer.bitCount((int)a & 0xFF));\n+    }\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void BIT_COUNTByte64VectorTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Byte64VectorTests::BIT_COUNT);\n+    }\n+\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void BIT_COUNTMaskedByte64VectorTests(IntFunction<byte[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Byte64VectorTests::BIT_COUNT);\n+    }\n+\n+    static byte TRAILING_ZEROS_COUNT(byte a) {\n+        return (byte)(TRAILING_ZEROS_COUNT_scalar(a));\n+    }\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void TRAILING_ZEROS_COUNTByte64VectorTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TRAILING_ZEROS_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Byte64VectorTests::TRAILING_ZEROS_COUNT);\n+    }\n+\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void TRAILING_ZEROS_COUNTMaskedByte64VectorTests(IntFunction<byte[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TRAILING_ZEROS_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Byte64VectorTests::TRAILING_ZEROS_COUNT);\n+    }\n+\n+    static byte LEADING_ZEROS_COUNT(byte a) {\n+        return (byte)(LEADING_ZEROS_COUNT_scalar(a));\n+    }\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void LEADING_ZEROS_COUNTByte64VectorTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LEADING_ZEROS_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Byte64VectorTests::LEADING_ZEROS_COUNT);\n+    }\n+\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void LEADING_ZEROS_COUNTMaskedByte64VectorTests(IntFunction<byte[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LEADING_ZEROS_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Byte64VectorTests::LEADING_ZEROS_COUNT);\n+    }\n+\n+    static byte REVERSE(byte a) {\n+        return (byte)(REVERSE_scalar(a));\n+    }\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void REVERSEByte64VectorTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Byte64VectorTests::REVERSE);\n+    }\n+\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void REVERSEMaskedByte64VectorTests(IntFunction<byte[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Byte64VectorTests::REVERSE);\n+    }\n+\n+    static byte REVERSE_BYTES(byte a) {\n+        return (byte)(a);\n+    }\n@@ -5435,0 +5513,4 @@\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void REVERSE_BYTESByte64VectorTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n@@ -5436,0 +5518,6 @@\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES).intoArray(r, i);\n+            }\n+        }\n@@ -5437,0 +5525,20 @@\n+        assertArraysEquals(r, a, Byte64VectorTests::REVERSE_BYTES);\n+    }\n+\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void REVERSE_BYTESMaskedByte64VectorTests(IntFunction<byte[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Byte64VectorTests::REVERSE_BYTES);\n+    }\n@@ -5850,0 +5958,17 @@\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCompressByte64VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        int trueCount = 0;\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                trueCount = vmask.trueCount();\n+                var rmask = vmask.compress();\n+                for (int j = 0; j < SPECIES.length(); j++)  {\n+                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);\n+                }\n+            }\n+        }\n+    }\n+\n@@ -5892,0 +6017,14 @@\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeLongByte64VectorTestsSmokeTest(int offset) {\n+        long limit = SPECIES.length() * BUFFER_REPS;\n+        for (long i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i + offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                long index = i + j + offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n@@ -5912,0 +6051,8 @@\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundLongByte64VectorTestsSmokeTest(int _length) {\n+        long length = _length;\n+        long actualLoopBound = SPECIES.loopBound(length);\n+        long expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+    }\n+\n@@ -5974,1 +6121,0 @@\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte64VectorTests.java","additions":363,"deletions":217,"binary":false,"changes":580,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,3 @@\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.ValueLayout;\n@@ -44,3 +47,0 @@\n-import java.lang.invoke.MethodHandles;\n-import java.lang.invoke.VarHandle;\n-import java.nio.ByteBuffer;\n@@ -48,1 +48,0 @@\n-import java.nio.ReadOnlyBufferException;\n@@ -78,1 +77,0 @@\n-\n@@ -118,1 +116,1 @@\n-    \/\/ Relative to byte[] array.length or ByteBuffer.limit()\n+    \/\/ Relative to byte[] array.length or MemorySegment.byteSize()\n@@ -189,1 +187,1 @@\n-    public Object[][] byteByteBufferProvider() {\n+    public Object[][] byteMemorySegmentProvider() {\n@@ -191,1 +189,1 @@\n-                flatMap(fa -> BYTE_BUFFER_GENERATORS.stream().\n+                flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n@@ -199,1 +197,1 @@\n-    public Object[][] byteByteBufferMaskProvider() {\n+    public Object[][] byteMemorySegmentMaskProvider() {\n@@ -202,1 +200,1 @@\n-                        flatMap(fa -> BYTE_BUFFER_GENERATORS.stream().\n+                        flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n@@ -209,19 +207,0 @@\n-    @DataProvider\n-    public Object[][] byteByteArrayProvider() {\n-        return BYTE_GENERATORS.stream().\n-                flatMap(fa -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                    return new Object[]{fa, bo};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] byteByteArrayMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> BYTE_GENERATORS.stream().\n-                    flatMap(fa -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                        return new Object[]{fa, fm, bo};\n-                    }))).\n-                toArray(Object[][]::new);\n-    }\n-\n@@ -247,4 +226,4 @@\n-    static ByteBuffer toBuffer(byte[] a, IntFunction<ByteBuffer> fb) {\n-        ByteBuffer bb = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n-        for (byte v : a) {\n-            bb.put(v);\n+    static MemorySegment toSegment(byte[] a, IntFunction<MemorySegment> fb) {\n+        MemorySegment ms = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n+        for (int i = 0; i < a.length; i++) {\n+            ms.set(ValueLayout.JAVA_BYTE, i * SPECIES.elementSize() \/ 8 , a[i]);\n@@ -252,8 +231,1 @@\n-        return bb.clear();\n-    }\n-\n-    static byte[] bufferToArray(ByteBuffer bb) {\n-        ByteBuffer db = bb;\n-        byte[] d = new byte[db.capacity()];\n-        db.get(0, d);\n-        return d;\n+        return ms;\n@@ -262,7 +234,2 @@\n-    static byte[] toByteArray(byte[] a, IntFunction<byte[]> fb, ByteOrder bo) {\n-        byte[] b = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n-        ByteBuffer bb = ByteBuffer.wrap(b, 0, b.length).order(bo);\n-        for (byte v : a) {\n-            bb.put(v);\n-        }\n-        return b;\n+    static byte[] segmentToArray(MemorySegment ms) {\n+        return ms.toArray(ValueLayout.JAVA_BYTE);\n@@ -308,2 +275,2 @@\n-    static ByteVector fromByteArray(byte[] a, int i, ByteOrder bo) {\n-        return ByteVector.fromByteArray(SPECIES, a, i, bo);\n+    static ByteVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo) {\n+        return ByteVector.fromMemorySegment(SPECIES, a, i, bo);\n@@ -313,2 +280,2 @@\n-    static ByteVector fromByteArray(byte[] a, int i, ByteOrder bo, VectorMask<Byte> m) {\n-        return ByteVector.fromByteArray(SPECIES, a, i, bo, m);\n+    static ByteVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo, VectorMask<Byte> m) {\n+        return ByteVector.fromMemorySegment(SPECIES, a, i, bo, m);\n@@ -318,2 +285,2 @@\n-    static void intoByteArray(ByteVector v, byte[] a, int i, ByteOrder bo) {\n-        v.intoByteArray(a, i, bo);\n+    static void intoMemorySegment(ByteVector v, MemorySegment a, int i, ByteOrder bo) {\n+        v.intoMemorySegment(a, i, bo);\n@@ -323,2 +290,2 @@\n-    static void intoByteArray(ByteVector v, byte[] a, int i, ByteOrder bo, VectorMask<Byte> m) {\n-        v.intoByteArray(a, i, bo, m);\n+    static void intoMemorySegment(ByteVector v, MemorySegment a, int i, ByteOrder bo, VectorMask<Byte> m) {\n+        v.intoMemorySegment(a, i, bo, m);\n@@ -327,21 +294,0 @@\n-    @DontInline\n-    static ByteVector fromByteBuffer(ByteBuffer a, int i, ByteOrder bo) {\n-        return ByteVector.fromByteBuffer(SPECIES, a, i, bo);\n-    }\n-\n-    @DontInline\n-    static ByteVector fromByteBuffer(ByteBuffer a, int i, ByteOrder bo, VectorMask<Byte> m) {\n-        return ByteVector.fromByteBuffer(SPECIES, a, i, bo, m);\n-    }\n-\n-    @DontInline\n-    static void intoByteBuffer(ByteVector v, ByteBuffer a, int i, ByteOrder bo) {\n-        v.intoByteBuffer(a, i, bo);\n-    }\n-\n-    @DontInline\n-    static void intoByteBuffer(ByteVector v, ByteBuffer a, int i, ByteOrder bo, VectorMask<Byte> m) {\n-        v.intoByteBuffer(a, i, bo, m);\n-    }\n-\n-\n@@ -518,6 +464,6 @@\n-    @Test(dataProvider = \"byteByteBufferProvider\")\n-    static void loadStoreByteBuffer(IntFunction<byte[]> fa,\n-                                    IntFunction<ByteBuffer> fb,\n-                                    ByteOrder bo) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), fb);\n-        ByteBuffer r = fb.apply(a.limit());\n+    @Test(dataProvider = \"byteMemorySegmentProvider\")\n+    static void loadStoreMemorySegment(IntFunction<byte[]> fa,\n+                                       IntFunction<MemorySegment> fb,\n+                                       ByteOrder bo) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb);\n+        MemorySegment r = fb.apply((int) a.byteSize());\n@@ -525,1 +471,1 @@\n-        int l = a.limit();\n+        int l = (int) a.byteSize();\n@@ -530,2 +476,2 @@\n-                ByteVector av = ByteVector.fromByteBuffer(SPECIES, a, i, bo);\n-                av.intoByteBuffer(r, i, bo);\n+                ByteVector av = ByteVector.fromMemorySegment(SPECIES, a, i, bo);\n+                av.intoMemorySegment(r, i, bo);\n@@ -534,5 +480,2 @@\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        Assert.assertEquals(r, a, \"Buffers not equal\");\n+        long m = r.mismatch(a);\n+        Assert.assertEquals(m, -1, \"Segments not equal\");\n@@ -542,3 +485,3 @@\n-    static void loadByteBufferIOOBE(IntFunction<byte[]> fa, IntFunction<Integer> fi) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n+    static void loadMemorySegmentIOOBE(IntFunction<byte[]> fa, IntFunction<Integer> fi) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n@@ -546,1 +489,1 @@\n-        int l = a.limit();\n+        int l = (int) a.byteSize();\n@@ -551,2 +494,2 @@\n-                ByteVector av = fromByteBuffer(a, i, ByteOrder.nativeOrder());\n-                av.intoByteBuffer(r, i, ByteOrder.nativeOrder());\n+                ByteVector av = fromMemorySegment(a, i, ByteOrder.nativeOrder());\n+                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n@@ -556,2 +499,2 @@\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.limit());\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());\n@@ -559,1 +502,1 @@\n-            fromByteBuffer(a, index, ByteOrder.nativeOrder());\n+            fromMemorySegment(a, index, ByteOrder.nativeOrder());\n@@ -571,3 +514,3 @@\n-    static void storeByteBufferIOOBE(IntFunction<byte[]> fa, IntFunction<Integer> fi) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n+    static void storeMemorySegmentIOOBE(IntFunction<byte[]> fa, IntFunction<Integer> fi) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n@@ -575,1 +518,1 @@\n-        int l = a.limit();\n+        int l = (int) a.byteSize();\n@@ -580,2 +523,2 @@\n-                ByteVector av = ByteVector.fromByteBuffer(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteBuffer(av, r, i, ByteOrder.nativeOrder());\n+                ByteVector av = ByteVector.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+                intoMemorySegment(av, r, i, ByteOrder.nativeOrder());\n@@ -585,2 +528,2 @@\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.limit());\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());\n@@ -588,2 +531,2 @@\n-            ByteVector av = ByteVector.fromByteBuffer(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteBuffer(av, r, index, ByteOrder.nativeOrder());\n+            ByteVector av = ByteVector.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+            intoMemorySegment(av, r, index, ByteOrder.nativeOrder());\n@@ -600,6 +543,5 @@\n-\n-    @Test(dataProvider = \"byteByteBufferMaskProvider\")\n-    static void loadStoreByteBufferMask(IntFunction<byte[]> fa,\n-                                        IntFunction<ByteBuffer> fb,\n-                                        IntFunction<boolean[]> fm,\n-                                        ByteOrder bo) {\n+    @Test(dataProvider = \"byteMemorySegmentMaskProvider\")\n+    static void loadStoreMemorySegmentMask(IntFunction<byte[]> fa,\n+                                           IntFunction<MemorySegment> fb,\n+                                           IntFunction<boolean[]> fm,\n+                                           ByteOrder bo) {\n@@ -607,2 +549,2 @@\n-        ByteBuffer a = toBuffer(_a, fb);\n-        ByteBuffer r = fb.apply(a.limit());\n+        MemorySegment a = toSegment(_a, fb);\n+        MemorySegment r = fb.apply((int) a.byteSize());\n@@ -612,1 +554,1 @@\n-        int l = a.limit();\n+        int l = (int) a.byteSize();\n@@ -617,2 +559,2 @@\n-                ByteVector av = ByteVector.fromByteBuffer(SPECIES, a, i, bo, vmask);\n-                av.intoByteBuffer(r, i, bo);\n+                ByteVector av = ByteVector.fromMemorySegment(SPECIES, a, i, bo, vmask);\n+                av.intoMemorySegment(r, i, bo);\n@@ -621,5 +563,1 @@\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        assertArraysEquals(bufferToArray(r), _a, mask);\n+        assertArraysEquals(segmentToArray(r), _a, mask);\n@@ -628,1 +566,1 @@\n-        r = fb.apply(a.limit());\n+        r = fb.apply((int) a.byteSize());\n@@ -632,2 +570,2 @@\n-                ByteVector av = ByteVector.fromByteBuffer(SPECIES, a, i, bo);\n-                av.intoByteBuffer(r, i, bo, vmask);\n+                ByteVector av = ByteVector.fromMemorySegment(SPECIES, a, i, bo);\n+                av.intoMemorySegment(r, i, bo, vmask);\n@@ -636,5 +574,1 @@\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        assertArraysEquals(bufferToArray(r), _a, mask);\n+        assertArraysEquals(segmentToArray(r), _a, mask);\n@@ -644,3 +578,3 @@\n-    static void loadByteBufferMaskIOOBE(IntFunction<byte[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n+    static void loadMemorySegmentMaskIOOBE(IntFunction<byte[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n@@ -650,1 +584,1 @@\n-        int l = a.limit();\n+        int l = (int) a.byteSize();\n@@ -655,2 +589,2 @@\n-                ByteVector av = fromByteBuffer(a, i, ByteOrder.nativeOrder(), vmask);\n-                av.intoByteBuffer(r, i, ByteOrder.nativeOrder());\n+                ByteVector av = fromMemorySegment(a, i, ByteOrder.nativeOrder(), vmask);\n+                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n@@ -660,2 +594,2 @@\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.limit(), SPECIES.elementSize() \/ 8);\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() \/ 8);\n@@ -663,1 +597,1 @@\n-            fromByteBuffer(a, index, ByteOrder.nativeOrder(), vmask);\n+            fromMemorySegment(a, index, ByteOrder.nativeOrder(), vmask);\n@@ -675,3 +609,3 @@\n-    static void storeByteBufferMaskIOOBE(IntFunction<byte[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n+    static void storeMemorySegmentMaskIOOBE(IntFunction<byte[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n@@ -681,112 +615,1 @@\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ByteVector av = ByteVector.fromByteBuffer(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteBuffer(av, r, i, ByteOrder.nativeOrder(), vmask);\n-            }\n-        }\n-\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.limit(), SPECIES.elementSize() \/ 8);\n-        try {\n-            ByteVector av = ByteVector.fromByteBuffer(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteBuffer(av, a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"byteByteBufferProvider\")\n-    static void loadStoreReadonlyByteBuffer(IntFunction<byte[]> fa,\n-                                    IntFunction<ByteBuffer> fb,\n-                                    ByteOrder bo) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), fb).asReadOnlyBuffer();\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo);\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, SPECIES.maskAll(true));\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, SPECIES.maskAll(false));\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            VectorMask<Byte> m = SPECIES.shuffleFromOp(i -> i % 2 == 0 ? 1 : -1)\n-                    .laneIsValid();\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, m);\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"byteByteArrayProvider\")\n-    static void loadStoreByteArray(IntFunction<byte[]> fa,\n-                                    ByteOrder bo) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, bo);\n-        byte[] r = new byte[a.length];\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ByteVector av = ByteVector.fromByteArray(SPECIES, a, i, bo);\n-                av.intoByteArray(r, i, bo);\n-            }\n-        }\n-        Assert.assertEquals(r, a, \"Byte arrays not equal\");\n-    }\n-\n-    @Test(dataProvider = \"byteByteProviderForIOOBE\")\n-    static void loadByteArrayIOOBE(IntFunction<byte[]> fa, IntFunction<Integer> fi) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ByteVector av = fromByteArray(a, i, ByteOrder.nativeOrder());\n-                av.intoByteArray(r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.length);\n-        try {\n-            fromByteArray(a, index, ByteOrder.nativeOrder());\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-    @Test(dataProvider = \"byteByteProviderForIOOBE\")\n-    static void storeByteArrayIOOBE(IntFunction<byte[]> fa, IntFunction<Integer> fi) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-\n+        int l = (int) a.byteSize();\n@@ -794,1 +617,0 @@\n-        int l = a.length;\n@@ -798,2 +620,2 @@\n-                ByteVector av = ByteVector.fromByteArray(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteArray(av, r, i, ByteOrder.nativeOrder());\n+                ByteVector av = ByteVector.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+                intoMemorySegment(av, r, i, ByteOrder.nativeOrder(), vmask);\n@@ -803,2 +625,2 @@\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.length);\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() \/ 8);\n@@ -806,2 +628,2 @@\n-            ByteVector av = ByteVector.fromByteArray(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteArray(av, r, index, ByteOrder.nativeOrder());\n+            ByteVector av = ByteVector.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+            intoMemorySegment(av, a, index, ByteOrder.nativeOrder(), vmask);\n@@ -818,0 +640,5 @@\n+    @Test(dataProvider = \"byteMemorySegmentProvider\")\n+    static void loadStoreReadonlyMemorySegment(IntFunction<byte[]> fa,\n+                                               IntFunction<MemorySegment> fb,\n+                                               ByteOrder bo) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb).asReadOnly();\n@@ -819,38 +646,4 @@\n-    @Test(dataProvider = \"byteByteArrayMaskProvider\")\n-    static void loadStoreByteArrayMask(IntFunction<byte[]> fa,\n-                                  IntFunction<boolean[]> fm,\n-                                  ByteOrder bo) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, bo);\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Byte> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-          for (int i = 0; i < l; i += s) {\n-              ByteVector av = ByteVector.fromByteArray(SPECIES, a, i, bo, vmask);\n-              av.intoByteArray(r, i, bo);\n-          }\n-        }\n-        assertArraysEquals(r, a, mask);\n-\n-\n-        r = new byte[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ByteVector av = ByteVector.fromByteArray(SPECIES, a, i, bo);\n-                av.intoByteArray(r, i, bo, vmask);\n-            }\n-        }\n-        assertArraysEquals(r, a, mask);\n-    }\n-\n-    @Test(dataProvider = \"byteByteMaskProviderForIOOBE\")\n-    static void loadByteArrayMaskIOOBE(IntFunction<byte[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Byte> vmask = VectorMask.fromValues(SPECIES, mask);\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo)\n+        );\n@@ -858,2 +651,4 @@\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(true))\n+        );\n@@ -861,6 +656,4 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ByteVector av = fromByteArray(a, i, ByteOrder.nativeOrder(), vmask);\n-                av.intoByteArray(r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(false))\n+        );\n@@ -868,12 +661,6 @@\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length, SPECIES.elementSize() \/ 8);\n-        try {\n-            fromByteArray(a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n+        VectorMask<Byte> m = SPECIES.shuffleFromOp(i -> i % 2 == 0 ? 1 : -1)\n+                .laneIsValid();\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, m)\n+        );\n@@ -882,31 +669,0 @@\n-    @Test(dataProvider = \"byteByteMaskProviderForIOOBE\")\n-    static void storeByteArrayMaskIOOBE(IntFunction<byte[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Byte> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ByteVector av = ByteVector.fromByteArray(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteArray(av, r, i, ByteOrder.nativeOrder(), vmask);\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length, SPECIES.elementSize() \/ 8);\n-        try {\n-            ByteVector av = ByteVector.fromByteArray(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteArray(av, a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n@@ -928,0 +684,1 @@\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ByteMaxVectorLoadStoreTests.java","additions":112,"deletions":355,"binary":false,"changes":467,"status":"modified"},{"patch":"@@ -269,0 +269,49 @@\n+    static void assertcompressArraysEquals(byte[] r, byte[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    Assert.assertEquals(r[i + k], (byte)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (byte)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals(byte[] r, byte[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        Assert.assertEquals(r[i + j], (byte)0);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (byte)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n@@ -902,1 +951,0 @@\n-\n@@ -997,2 +1045,0 @@\n-\n-\n@@ -1074,1 +1120,0 @@\n-\n@@ -1215,0 +1260,15 @@\n+    static byte TRAILING_ZEROS_COUNT_scalar(byte a) {\n+        return (byte) (a != 0 ? Integer.numberOfTrailingZeros(a) : 8);\n+    }\n+\n+    static byte LEADING_ZEROS_COUNT_scalar(byte a) {\n+        return (byte) (a >= 0 ? Integer.numberOfLeadingZeros(a) - 24 : 0);\n+    }\n+\n+    static byte REVERSE_scalar(byte a) {\n+        byte b = (byte) ROL_scalar(a, (byte) 4);\n+        b = (byte) (((b & 0x55) << 1) | ((b & 0xAA) >>> 1));\n+        b = (byte) (((b & 0x33) << 2) | ((b & 0xCC) >>> 2));\n+        return b;\n+    }\n+\n@@ -1364,0 +1424,1 @@\n+\n@@ -1384,0 +1445,1 @@\n+\n@@ -1440,0 +1502,1 @@\n+\n@@ -1460,0 +1523,1 @@\n+\n@@ -1516,0 +1580,1 @@\n+\n@@ -1536,0 +1601,1 @@\n+\n@@ -1593,2 +1659,0 @@\n-\n-\n@@ -1617,0 +1681,1 @@\n+\n@@ -1640,2 +1705,0 @@\n-\n-\n@@ -1747,0 +1810,1 @@\n+\n@@ -1766,2 +1830,0 @@\n-\n-\n@@ -1788,1 +1850,0 @@\n-\n@@ -1810,2 +1871,0 @@\n-\n-\n@@ -1832,1 +1891,0 @@\n-\n@@ -1853,0 +1911,1 @@\n+\n@@ -1872,2 +1931,0 @@\n-\n-\n@@ -1894,1 +1951,0 @@\n-\n@@ -1916,2 +1972,0 @@\n-\n-\n@@ -1938,1 +1992,0 @@\n-\n@@ -2032,3 +2085,0 @@\n-\n-\n-\n@@ -2051,2 +2101,0 @@\n-\n-\n@@ -2072,2 +2120,0 @@\n-\n-\n@@ -2102,2 +2148,0 @@\n-\n-\n@@ -2121,2 +2165,0 @@\n-\n-\n@@ -2151,2 +2193,0 @@\n-\n-\n@@ -2170,2 +2210,0 @@\n-\n-\n@@ -2186,2 +2224,0 @@\n-\n-\n@@ -2205,1 +2241,0 @@\n-\n@@ -2237,2 +2272,0 @@\n-\n-\n@@ -2260,2 +2293,0 @@\n-\n-\n@@ -2282,5 +2313,0 @@\n-\n-\n-\n-\n-\n@@ -2308,2 +2334,0 @@\n-\n-\n@@ -2330,5 +2354,0 @@\n-\n-\n-\n-\n-\n@@ -2356,2 +2375,0 @@\n-\n-\n@@ -2378,5 +2395,0 @@\n-\n-\n-\n-\n-\n@@ -2403,2 +2415,0 @@\n-\n-\n@@ -2424,5 +2434,0 @@\n-\n-\n-\n-\n-\n@@ -2449,2 +2454,0 @@\n-\n-\n@@ -2470,5 +2473,0 @@\n-\n-\n-\n-\n-\n@@ -2495,2 +2493,0 @@\n-\n-\n@@ -2516,3 +2512,0 @@\n-\n-\n-\n@@ -2540,2 +2533,0 @@\n-\n-\n@@ -2562,1 +2553,0 @@\n-\n@@ -2584,2 +2574,0 @@\n-\n-\n@@ -2606,1 +2594,0 @@\n-\n@@ -2627,2 +2614,0 @@\n-\n-\n@@ -2648,1 +2633,0 @@\n-\n@@ -2669,2 +2653,0 @@\n-\n-\n@@ -2689,4 +2671,0 @@\n-\n-\n-\n-\n@@ -2712,2 +2690,0 @@\n-\n-\n@@ -2732,4 +2708,0 @@\n-\n-\n-\n-\n@@ -2755,2 +2727,0 @@\n-\n-\n@@ -2775,2 +2745,0 @@\n-\n-\n@@ -2796,2 +2764,0 @@\n-\n-\n@@ -2816,2 +2782,0 @@\n-\n-\n@@ -2837,2 +2801,0 @@\n-\n-\n@@ -2857,2 +2819,0 @@\n-\n-\n@@ -2878,2 +2838,0 @@\n-\n-\n@@ -2919,0 +2877,1 @@\n+\n@@ -2937,0 +2896,1 @@\n+\n@@ -2957,0 +2917,1 @@\n+\n@@ -3050,1 +3011,0 @@\n-\n@@ -3076,1 +3036,0 @@\n-\n@@ -3096,1 +3055,0 @@\n-\n@@ -3124,1 +3082,0 @@\n-\n@@ -3143,1 +3100,0 @@\n-\n@@ -3169,1 +3125,0 @@\n-\n@@ -3189,1 +3144,0 @@\n-\n@@ -3217,1 +3171,0 @@\n-\n@@ -3236,1 +3189,0 @@\n-\n@@ -3262,1 +3214,0 @@\n-\n@@ -3282,1 +3233,0 @@\n-\n@@ -3327,0 +3277,1 @@\n+\n@@ -3351,0 +3302,1 @@\n+\n@@ -3369,0 +3321,1 @@\n+\n@@ -3395,0 +3348,1 @@\n+\n@@ -3412,0 +3366,1 @@\n+\n@@ -3436,0 +3391,1 @@\n+\n@@ -3454,0 +3410,1 @@\n+\n@@ -3480,0 +3437,1 @@\n+\n@@ -3497,0 +3455,1 @@\n+\n@@ -3521,0 +3480,1 @@\n+\n@@ -3539,0 +3499,1 @@\n+\n@@ -3565,0 +3526,1 @@\n+\n@@ -3582,0 +3544,1 @@\n+\n@@ -3606,0 +3569,1 @@\n+\n@@ -3624,0 +3588,1 @@\n+\n@@ -3650,0 +3615,1 @@\n+\n@@ -3667,0 +3633,1 @@\n+\n@@ -3691,0 +3658,1 @@\n+\n@@ -3709,0 +3677,1 @@\n+\n@@ -3745,1 +3714,0 @@\n-\n@@ -3761,1 +3729,0 @@\n-\n@@ -3771,1 +3738,0 @@\n-\n@@ -3787,1 +3753,0 @@\n-\n@@ -3805,0 +3770,1 @@\n+\n@@ -3845,0 +3811,1 @@\n+\n@@ -3886,3 +3853,0 @@\n-\n-\n-\n@@ -3908,1 +3872,0 @@\n-\n@@ -3951,1 +3914,0 @@\n-\n@@ -3994,1 +3956,0 @@\n-\n@@ -4014,1 +3975,0 @@\n-\n@@ -4057,1 +4017,0 @@\n-\n@@ -4100,1 +4059,0 @@\n-\n@@ -4143,1 +4101,0 @@\n-\n@@ -4186,2 +4143,0 @@\n-\n-\n@@ -4207,2 +4162,0 @@\n-\n-\n@@ -4232,3 +4185,0 @@\n-\n-\n-\n@@ -4254,2 +4204,0 @@\n-\n-\n@@ -4279,3 +4227,0 @@\n-\n-\n-\n@@ -4301,2 +4246,0 @@\n-\n-\n@@ -4326,3 +4269,0 @@\n-\n-\n-\n@@ -4348,2 +4288,0 @@\n-\n-\n@@ -4373,2 +4311,0 @@\n-\n-\n@@ -4391,1 +4327,0 @@\n-\n@@ -4428,1 +4363,0 @@\n-\n@@ -4465,1 +4399,0 @@\n-\n@@ -4502,1 +4435,0 @@\n-\n@@ -4581,0 +4513,37 @@\n+\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void compressByteMaxVectorTests(IntFunction<byte[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.compress(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertcompressArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void expandByteMaxVectorTests(IntFunction<byte[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.expand(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertexpandArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n@@ -4751,4 +4720,0 @@\n-\n-\n-\n-\n@@ -4769,3 +4734,0 @@\n-\n-\n-\n@@ -4797,0 +4759,1 @@\n+\n@@ -4826,0 +4789,1 @@\n+\n@@ -4859,0 +4823,1 @@\n+\n@@ -4886,0 +4851,1 @@\n+\n@@ -4925,0 +4891,1 @@\n+\n@@ -4982,22 +4949,0 @@\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n@@ -5007,0 +4952,1 @@\n+\n@@ -5011,1 +4957,0 @@\n-\n@@ -5030,0 +4975,1 @@\n+\n@@ -5047,1 +4993,0 @@\n-\n@@ -5070,3 +5015,0 @@\n-\n-\n-\n@@ -5102,0 +5044,1 @@\n+\n@@ -5132,1 +5075,0 @@\n-\n@@ -5171,3 +5113,0 @@\n-\n-\n-\n@@ -5188,0 +5127,1 @@\n+\n@@ -5203,1 +5143,0 @@\n-\n@@ -5222,1 +5161,0 @@\n-\n@@ -5335,1 +5273,0 @@\n-\n@@ -5344,2 +5281,0 @@\n-\n-\n@@ -5376,2 +5311,0 @@\n-\n-\n@@ -5396,2 +5329,0 @@\n-\n-\n@@ -5402,2 +5333,0 @@\n-\n-\n@@ -5419,2 +5348,0 @@\n-\n-\n@@ -5439,0 +5366,151 @@\n+    static byte BIT_COUNT(byte a) {\n+        return (byte)(Integer.bitCount((int)a & 0xFF));\n+    }\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void BIT_COUNTByteMaxVectorTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, ByteMaxVectorTests::BIT_COUNT);\n+    }\n+\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void BIT_COUNTMaskedByteMaxVectorTests(IntFunction<byte[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, ByteMaxVectorTests::BIT_COUNT);\n+    }\n+\n+    static byte TRAILING_ZEROS_COUNT(byte a) {\n+        return (byte)(TRAILING_ZEROS_COUNT_scalar(a));\n+    }\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void TRAILING_ZEROS_COUNTByteMaxVectorTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TRAILING_ZEROS_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, ByteMaxVectorTests::TRAILING_ZEROS_COUNT);\n+    }\n+\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void TRAILING_ZEROS_COUNTMaskedByteMaxVectorTests(IntFunction<byte[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TRAILING_ZEROS_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, ByteMaxVectorTests::TRAILING_ZEROS_COUNT);\n+    }\n+\n+    static byte LEADING_ZEROS_COUNT(byte a) {\n+        return (byte)(LEADING_ZEROS_COUNT_scalar(a));\n+    }\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void LEADING_ZEROS_COUNTByteMaxVectorTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LEADING_ZEROS_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, ByteMaxVectorTests::LEADING_ZEROS_COUNT);\n+    }\n+\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void LEADING_ZEROS_COUNTMaskedByteMaxVectorTests(IntFunction<byte[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LEADING_ZEROS_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, ByteMaxVectorTests::LEADING_ZEROS_COUNT);\n+    }\n+\n+    static byte REVERSE(byte a) {\n+        return (byte)(REVERSE_scalar(a));\n+    }\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void REVERSEByteMaxVectorTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, ByteMaxVectorTests::REVERSE);\n+    }\n+\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void REVERSEMaskedByteMaxVectorTests(IntFunction<byte[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, ByteMaxVectorTests::REVERSE);\n+    }\n+\n+    static byte REVERSE_BYTES(byte a) {\n+        return (byte)(a);\n+    }\n@@ -5440,0 +5518,4 @@\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void REVERSE_BYTESByteMaxVectorTests(IntFunction<byte[]> fa) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n@@ -5441,0 +5523,6 @@\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES).intoArray(r, i);\n+            }\n+        }\n@@ -5442,0 +5530,20 @@\n+        assertArraysEquals(r, a, ByteMaxVectorTests::REVERSE_BYTES);\n+    }\n+\n+    @Test(dataProvider = \"byteUnaryOpMaskProvider\")\n+    static void REVERSE_BYTESMaskedByteMaxVectorTests(IntFunction<byte[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, ByteMaxVectorTests::REVERSE_BYTES);\n+    }\n@@ -5855,0 +5963,17 @@\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCompressByteMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        int trueCount = 0;\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                trueCount = vmask.trueCount();\n+                var rmask = vmask.compress();\n+                for (int j = 0; j < SPECIES.length(); j++)  {\n+                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);\n+                }\n+            }\n+        }\n+    }\n+\n@@ -5881,0 +6006,14 @@\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeLongByteMaxVectorTestsSmokeTest(int offset) {\n+        long limit = SPECIES.length() * BUFFER_REPS;\n+        for (long i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i + offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                long index = i + j + offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n@@ -5901,0 +6040,8 @@\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundLongByteMaxVectorTestsSmokeTest(int _length) {\n+        long length = _length;\n+        long actualLoopBound = SPECIES.loopBound(length);\n+        long expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+    }\n+\n@@ -5963,1 +6110,0 @@\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ByteMaxVectorTests.java","additions":363,"deletions":217,"binary":false,"changes":580,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,3 @@\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.ValueLayout;\n@@ -42,2 +45,0 @@\n-import java.nio.ByteBuffer;\n-import java.nio.DoubleBuffer;\n@@ -45,1 +46,0 @@\n-import java.nio.ReadOnlyBufferException;\n@@ -70,11 +70,0 @@\n-    static void assertArraysEquals(byte[] r, byte[] a, boolean[] mask) {\n-        int i = 0;\n-        try {\n-            for (; i < a.length; i++) {\n-                Assert.assertEquals(r[i], mask[(i*8\/SPECIES.elementSize()) % SPECIES.length()] ? a[i] : (byte) 0);\n-            }\n-        } catch (AssertionError e) {\n-            Assert.assertEquals(r[i], mask[(i*8\/SPECIES.elementSize()) % SPECIES.length()] ? a[i] : (byte) 0, \"at index #\" + i);\n-        }\n-    }\n-\n@@ -120,1 +109,1 @@\n-    \/\/ Relative to byte[] array.length or ByteBuffer.limit()\n+    \/\/ Relative to byte[] array.length or MemorySegment.byteSize()\n@@ -191,1 +180,1 @@\n-    public Object[][] doubleByteBufferProvider() {\n+    public Object[][] doubleMemorySegmentProvider() {\n@@ -193,1 +182,1 @@\n-                flatMap(fa -> BYTE_BUFFER_GENERATORS.stream().\n+                flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n@@ -201,1 +190,1 @@\n-    public Object[][] doubleByteBufferMaskProvider() {\n+    public Object[][] doubleMemorySegmentMaskProvider() {\n@@ -204,1 +193,1 @@\n-                        flatMap(fa -> BYTE_BUFFER_GENERATORS.stream().\n+                        flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n@@ -211,19 +200,0 @@\n-    @DataProvider\n-    public Object[][] doubleByteArrayProvider() {\n-        return DOUBLE_GENERATORS.stream().\n-                flatMap(fa -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                    return new Object[]{fa, bo};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] doubleByteArrayMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> DOUBLE_GENERATORS.stream().\n-                    flatMap(fa -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                        return new Object[]{fa, fm, bo};\n-                    }))).\n-                toArray(Object[][]::new);\n-    }\n-\n@@ -249,4 +219,4 @@\n-    static ByteBuffer toBuffer(double[] a, IntFunction<ByteBuffer> fb) {\n-        ByteBuffer bb = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n-        for (double v : a) {\n-            bb.putDouble(v);\n+    static MemorySegment toSegment(double[] a, IntFunction<MemorySegment> fb) {\n+        MemorySegment ms = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n+        for (int i = 0; i < a.length; i++) {\n+            ms.set(ValueLayout.JAVA_DOUBLE, i * SPECIES.elementSize() \/ 8 , a[i]);\n@@ -254,1 +224,1 @@\n-        return bb.clear();\n+        return ms;\n@@ -257,14 +227,2 @@\n-    static double[] bufferToArray(ByteBuffer bb) {\n-        DoubleBuffer db = bb.asDoubleBuffer();\n-        double[] d = new double[db.capacity()];\n-        db.get(0, d);\n-        return d;\n-    }\n-\n-    static byte[] toByteArray(double[] a, IntFunction<byte[]> fb, ByteOrder bo) {\n-        byte[] b = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n-        DoubleBuffer bb = ByteBuffer.wrap(b, 0, b.length).order(bo).asDoubleBuffer();\n-        for (double v : a) {\n-            bb.put(v);\n-        }\n-        return b;\n+    static double[] segmentToArray(MemorySegment ms) {\n+        return ms.toArray(ValueLayout.JAVA_DOUBLE);\n@@ -310,22 +268,2 @@\n-    static DoubleVector fromByteArray(byte[] a, int i, ByteOrder bo) {\n-        return DoubleVector.fromByteArray(SPECIES, a, i, bo);\n-    }\n-\n-    @DontInline\n-    static DoubleVector fromByteArray(byte[] a, int i, ByteOrder bo, VectorMask<Double> m) {\n-        return DoubleVector.fromByteArray(SPECIES, a, i, bo, m);\n-    }\n-\n-    @DontInline\n-    static void intoByteArray(DoubleVector v, byte[] a, int i, ByteOrder bo) {\n-        v.intoByteArray(a, i, bo);\n-    }\n-\n-    @DontInline\n-    static void intoByteArray(DoubleVector v, byte[] a, int i, ByteOrder bo, VectorMask<Double> m) {\n-        v.intoByteArray(a, i, bo, m);\n-    }\n-\n-    @DontInline\n-    static DoubleVector fromByteBuffer(ByteBuffer a, int i, ByteOrder bo) {\n-        return DoubleVector.fromByteBuffer(SPECIES, a, i, bo);\n+    static DoubleVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo) {\n+        return DoubleVector.fromMemorySegment(SPECIES, a, i, bo);\n@@ -335,2 +273,2 @@\n-    static DoubleVector fromByteBuffer(ByteBuffer a, int i, ByteOrder bo, VectorMask<Double> m) {\n-        return DoubleVector.fromByteBuffer(SPECIES, a, i, bo, m);\n+    static DoubleVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo, VectorMask<Double> m) {\n+        return DoubleVector.fromMemorySegment(SPECIES, a, i, bo, m);\n@@ -340,2 +278,2 @@\n-    static void intoByteBuffer(DoubleVector v, ByteBuffer a, int i, ByteOrder bo) {\n-        v.intoByteBuffer(a, i, bo);\n+    static void intoMemorySegment(DoubleVector v, MemorySegment a, int i, ByteOrder bo) {\n+        v.intoMemorySegment(a, i, bo);\n@@ -345,2 +283,2 @@\n-    static void intoByteBuffer(DoubleVector v, ByteBuffer a, int i, ByteOrder bo, VectorMask<Double> m) {\n-        v.intoByteBuffer(a, i, bo, m);\n+    static void intoMemorySegment(DoubleVector v, MemorySegment a, int i, ByteOrder bo, VectorMask<Double> m) {\n+        v.intoMemorySegment(a, i, bo, m);\n@@ -349,1 +287,0 @@\n-\n@@ -520,6 +457,6 @@\n-    @Test(dataProvider = \"doubleByteBufferProvider\")\n-    static void loadStoreByteBuffer(IntFunction<double[]> fa,\n-                                    IntFunction<ByteBuffer> fb,\n-                                    ByteOrder bo) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), fb);\n-        ByteBuffer r = fb.apply(a.limit());\n+    @Test(dataProvider = \"doubleMemorySegmentProvider\")\n+    static void loadStoreMemorySegment(IntFunction<double[]> fa,\n+                                       IntFunction<MemorySegment> fb,\n+                                       ByteOrder bo) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb);\n+        MemorySegment r = fb.apply((int) a.byteSize());\n@@ -527,1 +464,1 @@\n-        int l = a.limit();\n+        int l = (int) a.byteSize();\n@@ -532,2 +469,2 @@\n-                DoubleVector av = DoubleVector.fromByteBuffer(SPECIES, a, i, bo);\n-                av.intoByteBuffer(r, i, bo);\n+                DoubleVector av = DoubleVector.fromMemorySegment(SPECIES, a, i, bo);\n+                av.intoMemorySegment(r, i, bo);\n@@ -536,5 +473,2 @@\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        Assert.assertEquals(r, a, \"Buffers not equal\");\n+        long m = r.mismatch(a);\n+        Assert.assertEquals(m, -1, \"Segments not equal\");\n@@ -544,3 +478,3 @@\n-    static void loadByteBufferIOOBE(IntFunction<double[]> fa, IntFunction<Integer> fi) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n+    static void loadMemorySegmentIOOBE(IntFunction<double[]> fa, IntFunction<Integer> fi) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n@@ -548,1 +482,1 @@\n-        int l = a.limit();\n+        int l = (int) a.byteSize();\n@@ -553,2 +487,2 @@\n-                DoubleVector av = fromByteBuffer(a, i, ByteOrder.nativeOrder());\n-                av.intoByteBuffer(r, i, ByteOrder.nativeOrder());\n+                DoubleVector av = fromMemorySegment(a, i, ByteOrder.nativeOrder());\n+                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n@@ -558,2 +492,2 @@\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.limit());\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());\n@@ -561,1 +495,1 @@\n-            fromByteBuffer(a, index, ByteOrder.nativeOrder());\n+            fromMemorySegment(a, index, ByteOrder.nativeOrder());\n@@ -573,3 +507,3 @@\n-    static void storeByteBufferIOOBE(IntFunction<double[]> fa, IntFunction<Integer> fi) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n+    static void storeMemorySegmentIOOBE(IntFunction<double[]> fa, IntFunction<Integer> fi) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n@@ -577,1 +511,1 @@\n-        int l = a.limit();\n+        int l = (int) a.byteSize();\n@@ -582,2 +516,2 @@\n-                DoubleVector av = DoubleVector.fromByteBuffer(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteBuffer(av, r, i, ByteOrder.nativeOrder());\n+                DoubleVector av = DoubleVector.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+                intoMemorySegment(av, r, i, ByteOrder.nativeOrder());\n@@ -587,2 +521,2 @@\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.limit());\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());\n@@ -590,2 +524,2 @@\n-            DoubleVector av = DoubleVector.fromByteBuffer(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteBuffer(av, r, index, ByteOrder.nativeOrder());\n+            DoubleVector av = DoubleVector.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+            intoMemorySegment(av, r, index, ByteOrder.nativeOrder());\n@@ -602,6 +536,5 @@\n-\n-    @Test(dataProvider = \"doubleByteBufferMaskProvider\")\n-    static void loadStoreByteBufferMask(IntFunction<double[]> fa,\n-                                        IntFunction<ByteBuffer> fb,\n-                                        IntFunction<boolean[]> fm,\n-                                        ByteOrder bo) {\n+    @Test(dataProvider = \"doubleMemorySegmentMaskProvider\")\n+    static void loadStoreMemorySegmentMask(IntFunction<double[]> fa,\n+                                           IntFunction<MemorySegment> fb,\n+                                           IntFunction<boolean[]> fm,\n+                                           ByteOrder bo) {\n@@ -609,2 +542,2 @@\n-        ByteBuffer a = toBuffer(_a, fb);\n-        ByteBuffer r = fb.apply(a.limit());\n+        MemorySegment a = toSegment(_a, fb);\n+        MemorySegment r = fb.apply((int) a.byteSize());\n@@ -614,1 +547,1 @@\n-        int l = a.limit();\n+        int l = (int) a.byteSize();\n@@ -619,2 +552,2 @@\n-                DoubleVector av = DoubleVector.fromByteBuffer(SPECIES, a, i, bo, vmask);\n-                av.intoByteBuffer(r, i, bo);\n+                DoubleVector av = DoubleVector.fromMemorySegment(SPECIES, a, i, bo, vmask);\n+                av.intoMemorySegment(r, i, bo);\n@@ -623,5 +556,1 @@\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        assertArraysEquals(bufferToArray(r), _a, mask);\n+        assertArraysEquals(segmentToArray(r), _a, mask);\n@@ -630,1 +559,1 @@\n-        r = fb.apply(a.limit());\n+        r = fb.apply((int) a.byteSize());\n@@ -634,2 +563,2 @@\n-                DoubleVector av = DoubleVector.fromByteBuffer(SPECIES, a, i, bo);\n-                av.intoByteBuffer(r, i, bo, vmask);\n+                DoubleVector av = DoubleVector.fromMemorySegment(SPECIES, a, i, bo);\n+                av.intoMemorySegment(r, i, bo, vmask);\n@@ -638,5 +567,1 @@\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        assertArraysEquals(bufferToArray(r), _a, mask);\n+        assertArraysEquals(segmentToArray(r), _a, mask);\n@@ -646,3 +571,3 @@\n-    static void loadByteBufferMaskIOOBE(IntFunction<double[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n+    static void loadMemorySegmentMaskIOOBE(IntFunction<double[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n@@ -652,1 +577,1 @@\n-        int l = a.limit();\n+        int l = (int) a.byteSize();\n@@ -657,2 +582,2 @@\n-                DoubleVector av = fromByteBuffer(a, i, ByteOrder.nativeOrder(), vmask);\n-                av.intoByteBuffer(r, i, ByteOrder.nativeOrder());\n+                DoubleVector av = fromMemorySegment(a, i, ByteOrder.nativeOrder(), vmask);\n+                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n@@ -662,2 +587,2 @@\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.limit(), SPECIES.elementSize() \/ 8);\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() \/ 8);\n@@ -665,1 +590,1 @@\n-            fromByteBuffer(a, index, ByteOrder.nativeOrder(), vmask);\n+            fromMemorySegment(a, index, ByteOrder.nativeOrder(), vmask);\n@@ -677,3 +602,3 @@\n-    static void storeByteBufferMaskIOOBE(IntFunction<double[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n+    static void storeMemorySegmentMaskIOOBE(IntFunction<double[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n@@ -683,83 +608,1 @@\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                DoubleVector av = DoubleVector.fromByteBuffer(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteBuffer(av, r, i, ByteOrder.nativeOrder(), vmask);\n-            }\n-        }\n-\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.limit(), SPECIES.elementSize() \/ 8);\n-        try {\n-            DoubleVector av = DoubleVector.fromByteBuffer(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteBuffer(av, a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"doubleByteBufferProvider\")\n-    static void loadStoreReadonlyByteBuffer(IntFunction<double[]> fa,\n-                                    IntFunction<ByteBuffer> fb,\n-                                    ByteOrder bo) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), fb).asReadOnlyBuffer();\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo);\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, SPECIES.maskAll(true));\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, SPECIES.maskAll(false));\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            VectorMask<Double> m = SPECIES.shuffleFromOp(i -> i % 2 == 0 ? 1 : -1)\n-                    .laneIsValid();\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, m);\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"doubleByteArrayProvider\")\n-    static void loadStoreByteArray(IntFunction<double[]> fa,\n-                                    ByteOrder bo) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, bo);\n-        byte[] r = new byte[a.length];\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                DoubleVector av = DoubleVector.fromByteArray(SPECIES, a, i, bo);\n-                av.intoByteArray(r, i, bo);\n-            }\n-        }\n-        Assert.assertEquals(r, a, \"Byte arrays not equal\");\n-    }\n-\n-    @Test(dataProvider = \"doubleByteProviderForIOOBE\")\n-    static void loadByteArrayIOOBE(IntFunction<double[]> fa, IntFunction<Integer> fi) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-\n+        int l = (int) a.byteSize();\n@@ -767,1 +610,0 @@\n-        int l = a.length;\n@@ -771,2 +613,2 @@\n-                DoubleVector av = fromByteArray(a, i, ByteOrder.nativeOrder());\n-                av.intoByteArray(r, i, ByteOrder.nativeOrder());\n+                DoubleVector av = DoubleVector.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+                intoMemorySegment(av, r, i, ByteOrder.nativeOrder(), vmask);\n@@ -776,2 +618,2 @@\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.length);\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() \/ 8);\n@@ -779,1 +621,2 @@\n-            fromByteArray(a, index, ByteOrder.nativeOrder());\n+            DoubleVector av = DoubleVector.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+            intoMemorySegment(av, a, index, ByteOrder.nativeOrder(), vmask);\n@@ -790,62 +633,5 @@\n-    @Test(dataProvider = \"doubleByteProviderForIOOBE\")\n-    static void storeByteArrayIOOBE(IntFunction<double[]> fa, IntFunction<Integer> fi) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                DoubleVector av = DoubleVector.fromByteArray(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteArray(av, r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.length);\n-        try {\n-            DoubleVector av = DoubleVector.fromByteArray(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteArray(av, r, index, ByteOrder.nativeOrder());\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"doubleByteArrayMaskProvider\")\n-    static void loadStoreByteArrayMask(IntFunction<double[]> fa,\n-                                  IntFunction<boolean[]> fm,\n-                                  ByteOrder bo) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, bo);\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Double> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-          for (int i = 0; i < l; i += s) {\n-              DoubleVector av = DoubleVector.fromByteArray(SPECIES, a, i, bo, vmask);\n-              av.intoByteArray(r, i, bo);\n-          }\n-        }\n-        assertArraysEquals(r, a, mask);\n-\n-\n-        r = new byte[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                DoubleVector av = DoubleVector.fromByteArray(SPECIES, a, i, bo);\n-                av.intoByteArray(r, i, bo, vmask);\n-            }\n-        }\n-        assertArraysEquals(r, a, mask);\n-    }\n+    @Test(dataProvider = \"doubleMemorySegmentProvider\")\n+    static void loadStoreReadonlyMemorySegment(IntFunction<double[]> fa,\n+                                               IntFunction<MemorySegment> fb,\n+                                               ByteOrder bo) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb).asReadOnly();\n@@ -853,6 +639,4 @@\n-    @Test(dataProvider = \"doubleByteMaskProviderForIOOBE\")\n-    static void loadByteArrayMaskIOOBE(IntFunction<double[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Double> vmask = VectorMask.fromValues(SPECIES, mask);\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo)\n+        );\n@@ -860,2 +644,4 @@\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(true))\n+        );\n@@ -863,6 +649,4 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                DoubleVector av = fromByteArray(a, i, ByteOrder.nativeOrder(), vmask);\n-                av.intoByteArray(r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(false))\n+        );\n@@ -870,12 +654,6 @@\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length, SPECIES.elementSize() \/ 8);\n-        try {\n-            fromByteArray(a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n+        VectorMask<Double> m = SPECIES.shuffleFromOp(i -> i % 2 == 0 ? 1 : -1)\n+                .laneIsValid();\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, m)\n+        );\n@@ -884,31 +662,0 @@\n-    @Test(dataProvider = \"doubleByteMaskProviderForIOOBE\")\n-    static void storeByteArrayMaskIOOBE(IntFunction<double[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Double> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                DoubleVector av = DoubleVector.fromByteArray(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteArray(av, r, i, ByteOrder.nativeOrder(), vmask);\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length, SPECIES.elementSize() \/ 8);\n-        try {\n-            DoubleVector av = DoubleVector.fromByteArray(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteArray(av, a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n@@ -930,0 +677,1 @@\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double128VectorLoadStoreTests.java","additions":112,"deletions":364,"binary":false,"changes":476,"status":"modified"},{"patch":"@@ -63,1 +63,0 @@\n-    private static final double CONST_SHIFT = Double.SIZE \/ 2;\n@@ -264,0 +263,49 @@\n+    static void assertcompressArraysEquals(double[] r, double[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    Assert.assertEquals(r[i + k], (double)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (double)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals(double[] r, double[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        Assert.assertEquals(r[i + j], (double)0);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (double)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n@@ -1016,2 +1064,0 @@\n-\n-\n@@ -1201,1 +1247,0 @@\n-\n@@ -1322,1 +1367,0 @@\n-\n@@ -1347,1 +1391,0 @@\n-\n@@ -1464,0 +1507,1 @@\n+\n@@ -1520,0 +1564,1 @@\n+\n@@ -1540,0 +1585,1 @@\n+\n@@ -1596,0 +1642,1 @@\n+\n@@ -1616,0 +1663,1 @@\n+\n@@ -1693,0 +1741,1 @@\n+\n@@ -1712,2 +1761,0 @@\n-\n-\n@@ -1752,2 +1799,0 @@\n-\n-\n@@ -1795,8 +1840,0 @@\n-\n-\n-\n-\n-\n-\n-\n-\n@@ -1896,1 +1933,0 @@\n-\n@@ -1911,2 +1947,0 @@\n-\n-\n@@ -1930,9 +1964,0 @@\n-\n-\n-\n-\n-\n-\n-\n-\n-\n@@ -1970,57 +1995,0 @@\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n@@ -2047,0 +2015,1 @@\n+\n@@ -2065,0 +2034,1 @@\n+\n@@ -2085,0 +2055,1 @@\n+\n@@ -2160,11 +2131,0 @@\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n@@ -2188,0 +2148,1 @@\n+\n@@ -2212,0 +2173,1 @@\n+\n@@ -2230,0 +2192,1 @@\n+\n@@ -2256,0 +2219,1 @@\n+\n@@ -2273,0 +2237,1 @@\n+\n@@ -2297,0 +2262,1 @@\n+\n@@ -2315,0 +2281,1 @@\n+\n@@ -2341,0 +2308,1 @@\n+\n@@ -2358,0 +2326,1 @@\n+\n@@ -2382,0 +2351,1 @@\n+\n@@ -2400,0 +2370,1 @@\n+\n@@ -2426,0 +2397,1 @@\n+\n@@ -2443,0 +2415,1 @@\n+\n@@ -2467,0 +2440,1 @@\n+\n@@ -2485,0 +2459,1 @@\n+\n@@ -2511,0 +2486,1 @@\n+\n@@ -2528,0 +2504,1 @@\n+\n@@ -2552,0 +2529,1 @@\n+\n@@ -2570,0 +2548,1 @@\n+\n@@ -2597,4 +2576,0 @@\n-\n-\n-\n-\n@@ -2618,0 +2593,1 @@\n+\n@@ -2658,0 +2634,1 @@\n+\n@@ -2740,1 +2717,0 @@\n-\n@@ -2782,1 +2758,0 @@\n-\n@@ -2824,1 +2799,0 @@\n-\n@@ -2844,1 +2818,0 @@\n-\n@@ -2887,1 +2860,0 @@\n-\n@@ -2930,1 +2902,0 @@\n-\n@@ -2950,1 +2921,0 @@\n-\n@@ -2993,1 +2963,0 @@\n-\n@@ -3036,1 +3005,0 @@\n-\n@@ -3079,1 +3047,0 @@\n-\n@@ -3122,9 +3089,0 @@\n-\n-\n-\n-\n-\n-\n-\n-\n-\n@@ -3147,1 +3105,0 @@\n-\n@@ -3184,1 +3141,0 @@\n-\n@@ -3221,1 +3177,0 @@\n-\n@@ -3258,1 +3213,0 @@\n-\n@@ -3337,0 +3291,37 @@\n+\n+    @Test(dataProvider = \"doubleUnaryOpMaskProvider\")\n+    static void compressDouble128VectorTests(IntFunction<double[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.compress(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertcompressArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"doubleUnaryOpMaskProvider\")\n+    static void expandDouble128VectorTests(IntFunction<double[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.expand(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertexpandArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n@@ -3507,4 +3498,0 @@\n-\n-\n-\n-\n@@ -3525,3 +3512,0 @@\n-\n-\n-\n@@ -3553,0 +3537,1 @@\n+\n@@ -3582,0 +3567,1 @@\n+\n@@ -3615,0 +3601,1 @@\n+\n@@ -3642,0 +3629,1 @@\n+\n@@ -3681,0 +3669,1 @@\n+\n@@ -3761,1 +3750,0 @@\n-\n@@ -3785,1 +3773,0 @@\n-\n@@ -3809,1 +3796,0 @@\n-\n@@ -3833,1 +3819,0 @@\n-\n@@ -3857,1 +3842,0 @@\n-\n@@ -3881,1 +3865,0 @@\n-\n@@ -3905,1 +3888,0 @@\n-\n@@ -3929,1 +3911,0 @@\n-\n@@ -3953,1 +3934,0 @@\n-\n@@ -3977,1 +3957,0 @@\n-\n@@ -4001,1 +3980,0 @@\n-\n@@ -4025,1 +4003,0 @@\n-\n@@ -4049,1 +4026,0 @@\n-\n@@ -4073,1 +4049,0 @@\n-\n@@ -4097,1 +4072,0 @@\n-\n@@ -4124,1 +4098,0 @@\n-\n@@ -4150,0 +4123,1 @@\n+\n@@ -4176,1 +4150,0 @@\n-\n@@ -4203,1 +4176,0 @@\n-\n@@ -4218,0 +4190,1 @@\n+\n@@ -4233,1 +4206,0 @@\n-\n@@ -4237,0 +4209,1 @@\n+\n@@ -4241,1 +4214,0 @@\n-\n@@ -4267,0 +4239,1 @@\n+\n@@ -4291,1 +4264,0 @@\n-\n@@ -4321,4 +4293,0 @@\n-\n-\n-\n-\n@@ -4355,1 +4323,0 @@\n-\n@@ -4394,3 +4361,0 @@\n-\n-\n-\n@@ -4418,0 +4382,1 @@\n+\n@@ -4440,1 +4405,0 @@\n-\n@@ -4466,3 +4430,0 @@\n-\n-\n-\n@@ -4581,7 +4542,0 @@\n-\n-\n-\n-\n-\n-\n-\n@@ -4596,2 +4550,0 @@\n-\n-\n@@ -4628,2 +4580,0 @@\n-\n-\n@@ -4648,1 +4598,0 @@\n-\n@@ -5040,0 +4989,17 @@\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCompressDouble128VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        int trueCount = 0;\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                trueCount = vmask.trueCount();\n+                var rmask = vmask.compress();\n+                for (int j = 0; j < SPECIES.length(); j++)  {\n+                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);\n+                }\n+            }\n+        }\n+    }\n+\n@@ -5082,0 +5048,14 @@\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeLongDouble128VectorTestsSmokeTest(int offset) {\n+        long limit = SPECIES.length() * BUFFER_REPS;\n+        for (long i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i + offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                long index = i + j + offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n@@ -5102,0 +5082,8 @@\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundLongDouble128VectorTestsSmokeTest(int _length) {\n+        long length = _length;\n+        long actualLoopBound = SPECIES.loopBound(length);\n+        long expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+    }\n+\n@@ -5164,1 +5152,0 @@\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double128VectorTests.java","additions":165,"deletions":178,"binary":false,"changes":343,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,3 @@\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.ValueLayout;\n@@ -42,2 +45,0 @@\n-import java.nio.ByteBuffer;\n-import java.nio.DoubleBuffer;\n@@ -45,1 +46,0 @@\n-import java.nio.ReadOnlyBufferException;\n@@ -70,11 +70,0 @@\n-    static void assertArraysEquals(byte[] r, byte[] a, boolean[] mask) {\n-        int i = 0;\n-        try {\n-            for (; i < a.length; i++) {\n-                Assert.assertEquals(r[i], mask[(i*8\/SPECIES.elementSize()) % SPECIES.length()] ? a[i] : (byte) 0);\n-            }\n-        } catch (AssertionError e) {\n-            Assert.assertEquals(r[i], mask[(i*8\/SPECIES.elementSize()) % SPECIES.length()] ? a[i] : (byte) 0, \"at index #\" + i);\n-        }\n-    }\n-\n@@ -120,1 +109,1 @@\n-    \/\/ Relative to byte[] array.length or ByteBuffer.limit()\n+    \/\/ Relative to byte[] array.length or MemorySegment.byteSize()\n@@ -191,1 +180,1 @@\n-    public Object[][] doubleByteBufferProvider() {\n+    public Object[][] doubleMemorySegmentProvider() {\n@@ -193,1 +182,1 @@\n-                flatMap(fa -> BYTE_BUFFER_GENERATORS.stream().\n+                flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n@@ -201,1 +190,1 @@\n-    public Object[][] doubleByteBufferMaskProvider() {\n+    public Object[][] doubleMemorySegmentMaskProvider() {\n@@ -204,1 +193,1 @@\n-                        flatMap(fa -> BYTE_BUFFER_GENERATORS.stream().\n+                        flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n@@ -211,19 +200,0 @@\n-    @DataProvider\n-    public Object[][] doubleByteArrayProvider() {\n-        return DOUBLE_GENERATORS.stream().\n-                flatMap(fa -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                    return new Object[]{fa, bo};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] doubleByteArrayMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> DOUBLE_GENERATORS.stream().\n-                    flatMap(fa -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                        return new Object[]{fa, fm, bo};\n-                    }))).\n-                toArray(Object[][]::new);\n-    }\n-\n@@ -249,4 +219,4 @@\n-    static ByteBuffer toBuffer(double[] a, IntFunction<ByteBuffer> fb) {\n-        ByteBuffer bb = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n-        for (double v : a) {\n-            bb.putDouble(v);\n+    static MemorySegment toSegment(double[] a, IntFunction<MemorySegment> fb) {\n+        MemorySegment ms = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n+        for (int i = 0; i < a.length; i++) {\n+            ms.set(ValueLayout.JAVA_DOUBLE, i * SPECIES.elementSize() \/ 8 , a[i]);\n@@ -254,1 +224,1 @@\n-        return bb.clear();\n+        return ms;\n@@ -257,14 +227,2 @@\n-    static double[] bufferToArray(ByteBuffer bb) {\n-        DoubleBuffer db = bb.asDoubleBuffer();\n-        double[] d = new double[db.capacity()];\n-        db.get(0, d);\n-        return d;\n-    }\n-\n-    static byte[] toByteArray(double[] a, IntFunction<byte[]> fb, ByteOrder bo) {\n-        byte[] b = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n-        DoubleBuffer bb = ByteBuffer.wrap(b, 0, b.length).order(bo).asDoubleBuffer();\n-        for (double v : a) {\n-            bb.put(v);\n-        }\n-        return b;\n+    static double[] segmentToArray(MemorySegment ms) {\n+        return ms.toArray(ValueLayout.JAVA_DOUBLE);\n@@ -310,22 +268,2 @@\n-    static DoubleVector fromByteArray(byte[] a, int i, ByteOrder bo) {\n-        return DoubleVector.fromByteArray(SPECIES, a, i, bo);\n-    }\n-\n-    @DontInline\n-    static DoubleVector fromByteArray(byte[] a, int i, ByteOrder bo, VectorMask<Double> m) {\n-        return DoubleVector.fromByteArray(SPECIES, a, i, bo, m);\n-    }\n-\n-    @DontInline\n-    static void intoByteArray(DoubleVector v, byte[] a, int i, ByteOrder bo) {\n-        v.intoByteArray(a, i, bo);\n-    }\n-\n-    @DontInline\n-    static void intoByteArray(DoubleVector v, byte[] a, int i, ByteOrder bo, VectorMask<Double> m) {\n-        v.intoByteArray(a, i, bo, m);\n-    }\n-\n-    @DontInline\n-    static DoubleVector fromByteBuffer(ByteBuffer a, int i, ByteOrder bo) {\n-        return DoubleVector.fromByteBuffer(SPECIES, a, i, bo);\n+    static DoubleVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo) {\n+        return DoubleVector.fromMemorySegment(SPECIES, a, i, bo);\n@@ -335,2 +273,2 @@\n-    static DoubleVector fromByteBuffer(ByteBuffer a, int i, ByteOrder bo, VectorMask<Double> m) {\n-        return DoubleVector.fromByteBuffer(SPECIES, a, i, bo, m);\n+    static DoubleVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo, VectorMask<Double> m) {\n+        return DoubleVector.fromMemorySegment(SPECIES, a, i, bo, m);\n@@ -340,2 +278,2 @@\n-    static void intoByteBuffer(DoubleVector v, ByteBuffer a, int i, ByteOrder bo) {\n-        v.intoByteBuffer(a, i, bo);\n+    static void intoMemorySegment(DoubleVector v, MemorySegment a, int i, ByteOrder bo) {\n+        v.intoMemorySegment(a, i, bo);\n@@ -345,2 +283,2 @@\n-    static void intoByteBuffer(DoubleVector v, ByteBuffer a, int i, ByteOrder bo, VectorMask<Double> m) {\n-        v.intoByteBuffer(a, i, bo, m);\n+    static void intoMemorySegment(DoubleVector v, MemorySegment a, int i, ByteOrder bo, VectorMask<Double> m) {\n+        v.intoMemorySegment(a, i, bo, m);\n@@ -349,1 +287,0 @@\n-\n@@ -520,6 +457,6 @@\n-    @Test(dataProvider = \"doubleByteBufferProvider\")\n-    static void loadStoreByteBuffer(IntFunction<double[]> fa,\n-                                    IntFunction<ByteBuffer> fb,\n-                                    ByteOrder bo) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), fb);\n-        ByteBuffer r = fb.apply(a.limit());\n+    @Test(dataProvider = \"doubleMemorySegmentProvider\")\n+    static void loadStoreMemorySegment(IntFunction<double[]> fa,\n+                                       IntFunction<MemorySegment> fb,\n+                                       ByteOrder bo) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb);\n+        MemorySegment r = fb.apply((int) a.byteSize());\n@@ -527,1 +464,1 @@\n-        int l = a.limit();\n+        int l = (int) a.byteSize();\n@@ -532,2 +469,2 @@\n-                DoubleVector av = DoubleVector.fromByteBuffer(SPECIES, a, i, bo);\n-                av.intoByteBuffer(r, i, bo);\n+                DoubleVector av = DoubleVector.fromMemorySegment(SPECIES, a, i, bo);\n+                av.intoMemorySegment(r, i, bo);\n@@ -536,5 +473,2 @@\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        Assert.assertEquals(r, a, \"Buffers not equal\");\n+        long m = r.mismatch(a);\n+        Assert.assertEquals(m, -1, \"Segments not equal\");\n@@ -544,3 +478,3 @@\n-    static void loadByteBufferIOOBE(IntFunction<double[]> fa, IntFunction<Integer> fi) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n+    static void loadMemorySegmentIOOBE(IntFunction<double[]> fa, IntFunction<Integer> fi) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n@@ -548,1 +482,1 @@\n-        int l = a.limit();\n+        int l = (int) a.byteSize();\n@@ -553,2 +487,2 @@\n-                DoubleVector av = fromByteBuffer(a, i, ByteOrder.nativeOrder());\n-                av.intoByteBuffer(r, i, ByteOrder.nativeOrder());\n+                DoubleVector av = fromMemorySegment(a, i, ByteOrder.nativeOrder());\n+                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n@@ -558,2 +492,2 @@\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.limit());\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());\n@@ -561,1 +495,1 @@\n-            fromByteBuffer(a, index, ByteOrder.nativeOrder());\n+            fromMemorySegment(a, index, ByteOrder.nativeOrder());\n@@ -573,3 +507,3 @@\n-    static void storeByteBufferIOOBE(IntFunction<double[]> fa, IntFunction<Integer> fi) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n+    static void storeMemorySegmentIOOBE(IntFunction<double[]> fa, IntFunction<Integer> fi) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n@@ -577,1 +511,1 @@\n-        int l = a.limit();\n+        int l = (int) a.byteSize();\n@@ -582,2 +516,2 @@\n-                DoubleVector av = DoubleVector.fromByteBuffer(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteBuffer(av, r, i, ByteOrder.nativeOrder());\n+                DoubleVector av = DoubleVector.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+                intoMemorySegment(av, r, i, ByteOrder.nativeOrder());\n@@ -587,2 +521,2 @@\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.limit());\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());\n@@ -590,2 +524,2 @@\n-            DoubleVector av = DoubleVector.fromByteBuffer(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteBuffer(av, r, index, ByteOrder.nativeOrder());\n+            DoubleVector av = DoubleVector.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+            intoMemorySegment(av, r, index, ByteOrder.nativeOrder());\n@@ -602,6 +536,5 @@\n-\n-    @Test(dataProvider = \"doubleByteBufferMaskProvider\")\n-    static void loadStoreByteBufferMask(IntFunction<double[]> fa,\n-                                        IntFunction<ByteBuffer> fb,\n-                                        IntFunction<boolean[]> fm,\n-                                        ByteOrder bo) {\n+    @Test(dataProvider = \"doubleMemorySegmentMaskProvider\")\n+    static void loadStoreMemorySegmentMask(IntFunction<double[]> fa,\n+                                           IntFunction<MemorySegment> fb,\n+                                           IntFunction<boolean[]> fm,\n+                                           ByteOrder bo) {\n@@ -609,2 +542,2 @@\n-        ByteBuffer a = toBuffer(_a, fb);\n-        ByteBuffer r = fb.apply(a.limit());\n+        MemorySegment a = toSegment(_a, fb);\n+        MemorySegment r = fb.apply((int) a.byteSize());\n@@ -614,1 +547,1 @@\n-        int l = a.limit();\n+        int l = (int) a.byteSize();\n@@ -619,2 +552,2 @@\n-                DoubleVector av = DoubleVector.fromByteBuffer(SPECIES, a, i, bo, vmask);\n-                av.intoByteBuffer(r, i, bo);\n+                DoubleVector av = DoubleVector.fromMemorySegment(SPECIES, a, i, bo, vmask);\n+                av.intoMemorySegment(r, i, bo);\n@@ -623,5 +556,1 @@\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        assertArraysEquals(bufferToArray(r), _a, mask);\n+        assertArraysEquals(segmentToArray(r), _a, mask);\n@@ -630,1 +559,1 @@\n-        r = fb.apply(a.limit());\n+        r = fb.apply((int) a.byteSize());\n@@ -634,2 +563,2 @@\n-                DoubleVector av = DoubleVector.fromByteBuffer(SPECIES, a, i, bo);\n-                av.intoByteBuffer(r, i, bo, vmask);\n+                DoubleVector av = DoubleVector.fromMemorySegment(SPECIES, a, i, bo);\n+                av.intoMemorySegment(r, i, bo, vmask);\n@@ -638,5 +567,1 @@\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        assertArraysEquals(bufferToArray(r), _a, mask);\n+        assertArraysEquals(segmentToArray(r), _a, mask);\n@@ -646,3 +571,3 @@\n-    static void loadByteBufferMaskIOOBE(IntFunction<double[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n+    static void loadMemorySegmentMaskIOOBE(IntFunction<double[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n@@ -652,1 +577,1 @@\n-        int l = a.limit();\n+        int l = (int) a.byteSize();\n@@ -657,2 +582,2 @@\n-                DoubleVector av = fromByteBuffer(a, i, ByteOrder.nativeOrder(), vmask);\n-                av.intoByteBuffer(r, i, ByteOrder.nativeOrder());\n+                DoubleVector av = fromMemorySegment(a, i, ByteOrder.nativeOrder(), vmask);\n+                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n@@ -662,2 +587,2 @@\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.limit(), SPECIES.elementSize() \/ 8);\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() \/ 8);\n@@ -665,1 +590,1 @@\n-            fromByteBuffer(a, index, ByteOrder.nativeOrder(), vmask);\n+            fromMemorySegment(a, index, ByteOrder.nativeOrder(), vmask);\n@@ -677,3 +602,3 @@\n-    static void storeByteBufferMaskIOOBE(IntFunction<double[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n+    static void storeMemorySegmentMaskIOOBE(IntFunction<double[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n@@ -683,83 +608,1 @@\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                DoubleVector av = DoubleVector.fromByteBuffer(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteBuffer(av, r, i, ByteOrder.nativeOrder(), vmask);\n-            }\n-        }\n-\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.limit(), SPECIES.elementSize() \/ 8);\n-        try {\n-            DoubleVector av = DoubleVector.fromByteBuffer(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteBuffer(av, a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"doubleByteBufferProvider\")\n-    static void loadStoreReadonlyByteBuffer(IntFunction<double[]> fa,\n-                                    IntFunction<ByteBuffer> fb,\n-                                    ByteOrder bo) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), fb).asReadOnlyBuffer();\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo);\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, SPECIES.maskAll(true));\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, SPECIES.maskAll(false));\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            VectorMask<Double> m = SPECIES.shuffleFromOp(i -> i % 2 == 0 ? 1 : -1)\n-                    .laneIsValid();\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, m);\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"doubleByteArrayProvider\")\n-    static void loadStoreByteArray(IntFunction<double[]> fa,\n-                                    ByteOrder bo) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, bo);\n-        byte[] r = new byte[a.length];\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                DoubleVector av = DoubleVector.fromByteArray(SPECIES, a, i, bo);\n-                av.intoByteArray(r, i, bo);\n-            }\n-        }\n-        Assert.assertEquals(r, a, \"Byte arrays not equal\");\n-    }\n-\n-    @Test(dataProvider = \"doubleByteProviderForIOOBE\")\n-    static void loadByteArrayIOOBE(IntFunction<double[]> fa, IntFunction<Integer> fi) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-\n+        int l = (int) a.byteSize();\n@@ -767,1 +610,0 @@\n-        int l = a.length;\n@@ -771,2 +613,2 @@\n-                DoubleVector av = fromByteArray(a, i, ByteOrder.nativeOrder());\n-                av.intoByteArray(r, i, ByteOrder.nativeOrder());\n+                DoubleVector av = DoubleVector.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+                intoMemorySegment(av, r, i, ByteOrder.nativeOrder(), vmask);\n@@ -776,2 +618,2 @@\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.length);\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() \/ 8);\n@@ -779,1 +621,2 @@\n-            fromByteArray(a, index, ByteOrder.nativeOrder());\n+            DoubleVector av = DoubleVector.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+            intoMemorySegment(av, a, index, ByteOrder.nativeOrder(), vmask);\n@@ -790,62 +633,5 @@\n-    @Test(dataProvider = \"doubleByteProviderForIOOBE\")\n-    static void storeByteArrayIOOBE(IntFunction<double[]> fa, IntFunction<Integer> fi) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                DoubleVector av = DoubleVector.fromByteArray(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteArray(av, r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.length);\n-        try {\n-            DoubleVector av = DoubleVector.fromByteArray(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteArray(av, r, index, ByteOrder.nativeOrder());\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"doubleByteArrayMaskProvider\")\n-    static void loadStoreByteArrayMask(IntFunction<double[]> fa,\n-                                  IntFunction<boolean[]> fm,\n-                                  ByteOrder bo) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, bo);\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Double> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-          for (int i = 0; i < l; i += s) {\n-              DoubleVector av = DoubleVector.fromByteArray(SPECIES, a, i, bo, vmask);\n-              av.intoByteArray(r, i, bo);\n-          }\n-        }\n-        assertArraysEquals(r, a, mask);\n-\n-\n-        r = new byte[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                DoubleVector av = DoubleVector.fromByteArray(SPECIES, a, i, bo);\n-                av.intoByteArray(r, i, bo, vmask);\n-            }\n-        }\n-        assertArraysEquals(r, a, mask);\n-    }\n+    @Test(dataProvider = \"doubleMemorySegmentProvider\")\n+    static void loadStoreReadonlyMemorySegment(IntFunction<double[]> fa,\n+                                               IntFunction<MemorySegment> fb,\n+                                               ByteOrder bo) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb).asReadOnly();\n@@ -853,6 +639,4 @@\n-    @Test(dataProvider = \"doubleByteMaskProviderForIOOBE\")\n-    static void loadByteArrayMaskIOOBE(IntFunction<double[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Double> vmask = VectorMask.fromValues(SPECIES, mask);\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo)\n+        );\n@@ -860,2 +644,4 @@\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(true))\n+        );\n@@ -863,6 +649,4 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                DoubleVector av = fromByteArray(a, i, ByteOrder.nativeOrder(), vmask);\n-                av.intoByteArray(r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(false))\n+        );\n@@ -870,12 +654,6 @@\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length, SPECIES.elementSize() \/ 8);\n-        try {\n-            fromByteArray(a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n+        VectorMask<Double> m = SPECIES.shuffleFromOp(i -> i % 2 == 0 ? 1 : -1)\n+                .laneIsValid();\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, m)\n+        );\n@@ -884,31 +662,0 @@\n-    @Test(dataProvider = \"doubleByteMaskProviderForIOOBE\")\n-    static void storeByteArrayMaskIOOBE(IntFunction<double[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Double> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                DoubleVector av = DoubleVector.fromByteArray(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteArray(av, r, i, ByteOrder.nativeOrder(), vmask);\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length, SPECIES.elementSize() \/ 8);\n-        try {\n-            DoubleVector av = DoubleVector.fromByteArray(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteArray(av, a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n@@ -930,0 +677,1 @@\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double256VectorLoadStoreTests.java","additions":112,"deletions":364,"binary":false,"changes":476,"status":"modified"},{"patch":"@@ -63,1 +63,0 @@\n-    private static final double CONST_SHIFT = Double.SIZE \/ 2;\n@@ -264,0 +263,49 @@\n+    static void assertcompressArraysEquals(double[] r, double[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    Assert.assertEquals(r[i + k], (double)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (double)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals(double[] r, double[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        Assert.assertEquals(r[i + j], (double)0);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (double)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n@@ -1016,2 +1064,0 @@\n-\n-\n@@ -1201,1 +1247,0 @@\n-\n@@ -1322,1 +1367,0 @@\n-\n@@ -1347,1 +1391,0 @@\n-\n@@ -1464,0 +1507,1 @@\n+\n@@ -1520,0 +1564,1 @@\n+\n@@ -1540,0 +1585,1 @@\n+\n@@ -1596,0 +1642,1 @@\n+\n@@ -1616,0 +1663,1 @@\n+\n@@ -1693,0 +1741,1 @@\n+\n@@ -1712,2 +1761,0 @@\n-\n-\n@@ -1752,2 +1799,0 @@\n-\n-\n@@ -1795,8 +1840,0 @@\n-\n-\n-\n-\n-\n-\n-\n-\n@@ -1896,1 +1933,0 @@\n-\n@@ -1911,2 +1947,0 @@\n-\n-\n@@ -1930,9 +1964,0 @@\n-\n-\n-\n-\n-\n-\n-\n-\n-\n@@ -1970,57 +1995,0 @@\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n@@ -2047,0 +2015,1 @@\n+\n@@ -2065,0 +2034,1 @@\n+\n@@ -2085,0 +2055,1 @@\n+\n@@ -2160,11 +2131,0 @@\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n@@ -2188,0 +2148,1 @@\n+\n@@ -2212,0 +2173,1 @@\n+\n@@ -2230,0 +2192,1 @@\n+\n@@ -2256,0 +2219,1 @@\n+\n@@ -2273,0 +2237,1 @@\n+\n@@ -2297,0 +2262,1 @@\n+\n@@ -2315,0 +2281,1 @@\n+\n@@ -2341,0 +2308,1 @@\n+\n@@ -2358,0 +2326,1 @@\n+\n@@ -2382,0 +2351,1 @@\n+\n@@ -2400,0 +2370,1 @@\n+\n@@ -2426,0 +2397,1 @@\n+\n@@ -2443,0 +2415,1 @@\n+\n@@ -2467,0 +2440,1 @@\n+\n@@ -2485,0 +2459,1 @@\n+\n@@ -2511,0 +2486,1 @@\n+\n@@ -2528,0 +2504,1 @@\n+\n@@ -2552,0 +2529,1 @@\n+\n@@ -2570,0 +2548,1 @@\n+\n@@ -2597,4 +2576,0 @@\n-\n-\n-\n-\n@@ -2618,0 +2593,1 @@\n+\n@@ -2658,0 +2634,1 @@\n+\n@@ -2740,1 +2717,0 @@\n-\n@@ -2782,1 +2758,0 @@\n-\n@@ -2824,1 +2799,0 @@\n-\n@@ -2844,1 +2818,0 @@\n-\n@@ -2887,1 +2860,0 @@\n-\n@@ -2930,1 +2902,0 @@\n-\n@@ -2950,1 +2921,0 @@\n-\n@@ -2993,1 +2963,0 @@\n-\n@@ -3036,1 +3005,0 @@\n-\n@@ -3079,1 +3047,0 @@\n-\n@@ -3122,9 +3089,0 @@\n-\n-\n-\n-\n-\n-\n-\n-\n-\n@@ -3147,1 +3105,0 @@\n-\n@@ -3184,1 +3141,0 @@\n-\n@@ -3221,1 +3177,0 @@\n-\n@@ -3258,1 +3213,0 @@\n-\n@@ -3337,0 +3291,37 @@\n+\n+    @Test(dataProvider = \"doubleUnaryOpMaskProvider\")\n+    static void compressDouble256VectorTests(IntFunction<double[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.compress(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertcompressArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"doubleUnaryOpMaskProvider\")\n+    static void expandDouble256VectorTests(IntFunction<double[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.expand(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertexpandArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n@@ -3507,4 +3498,0 @@\n-\n-\n-\n-\n@@ -3525,3 +3512,0 @@\n-\n-\n-\n@@ -3553,0 +3537,1 @@\n+\n@@ -3582,0 +3567,1 @@\n+\n@@ -3615,0 +3601,1 @@\n+\n@@ -3642,0 +3629,1 @@\n+\n@@ -3681,0 +3669,1 @@\n+\n@@ -3761,1 +3750,0 @@\n-\n@@ -3785,1 +3773,0 @@\n-\n@@ -3809,1 +3796,0 @@\n-\n@@ -3833,1 +3819,0 @@\n-\n@@ -3857,1 +3842,0 @@\n-\n@@ -3881,1 +3865,0 @@\n-\n@@ -3905,1 +3888,0 @@\n-\n@@ -3929,1 +3911,0 @@\n-\n@@ -3953,1 +3934,0 @@\n-\n@@ -3977,1 +3957,0 @@\n-\n@@ -4001,1 +3980,0 @@\n-\n@@ -4025,1 +4003,0 @@\n-\n@@ -4049,1 +4026,0 @@\n-\n@@ -4073,1 +4049,0 @@\n-\n@@ -4097,1 +4072,0 @@\n-\n@@ -4124,1 +4098,0 @@\n-\n@@ -4150,0 +4123,1 @@\n+\n@@ -4176,1 +4150,0 @@\n-\n@@ -4203,1 +4176,0 @@\n-\n@@ -4218,0 +4190,1 @@\n+\n@@ -4233,1 +4206,0 @@\n-\n@@ -4237,0 +4209,1 @@\n+\n@@ -4241,1 +4214,0 @@\n-\n@@ -4267,0 +4239,1 @@\n+\n@@ -4291,1 +4264,0 @@\n-\n@@ -4321,4 +4293,0 @@\n-\n-\n-\n-\n@@ -4355,1 +4323,0 @@\n-\n@@ -4394,3 +4361,0 @@\n-\n-\n-\n@@ -4418,0 +4382,1 @@\n+\n@@ -4440,1 +4405,0 @@\n-\n@@ -4466,3 +4430,0 @@\n-\n-\n-\n@@ -4581,7 +4542,0 @@\n-\n-\n-\n-\n-\n-\n-\n@@ -4596,2 +4550,0 @@\n-\n-\n@@ -4628,2 +4580,0 @@\n-\n-\n@@ -4648,1 +4598,0 @@\n-\n@@ -5040,0 +4989,17 @@\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCompressDouble256VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        int trueCount = 0;\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                trueCount = vmask.trueCount();\n+                var rmask = vmask.compress();\n+                for (int j = 0; j < SPECIES.length(); j++)  {\n+                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);\n+                }\n+            }\n+        }\n+    }\n+\n@@ -5082,0 +5048,14 @@\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeLongDouble256VectorTestsSmokeTest(int offset) {\n+        long limit = SPECIES.length() * BUFFER_REPS;\n+        for (long i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i + offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                long index = i + j + offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n@@ -5102,0 +5082,8 @@\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundLongDouble256VectorTestsSmokeTest(int _length) {\n+        long length = _length;\n+        long actualLoopBound = SPECIES.loopBound(length);\n+        long expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+    }\n+\n@@ -5164,1 +5152,0 @@\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double256VectorTests.java","additions":165,"deletions":178,"binary":false,"changes":343,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,3 @@\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.ValueLayout;\n@@ -42,2 +45,0 @@\n-import java.nio.ByteBuffer;\n-import java.nio.DoubleBuffer;\n@@ -45,1 +46,0 @@\n-import java.nio.ReadOnlyBufferException;\n@@ -70,11 +70,0 @@\n-    static void assertArraysEquals(byte[] r, byte[] a, boolean[] mask) {\n-        int i = 0;\n-        try {\n-            for (; i < a.length; i++) {\n-                Assert.assertEquals(r[i], mask[(i*8\/SPECIES.elementSize()) % SPECIES.length()] ? a[i] : (byte) 0);\n-            }\n-        } catch (AssertionError e) {\n-            Assert.assertEquals(r[i], mask[(i*8\/SPECIES.elementSize()) % SPECIES.length()] ? a[i] : (byte) 0, \"at index #\" + i);\n-        }\n-    }\n-\n@@ -120,1 +109,1 @@\n-    \/\/ Relative to byte[] array.length or ByteBuffer.limit()\n+    \/\/ Relative to byte[] array.length or MemorySegment.byteSize()\n@@ -191,1 +180,1 @@\n-    public Object[][] doubleByteBufferProvider() {\n+    public Object[][] doubleMemorySegmentProvider() {\n@@ -193,1 +182,1 @@\n-                flatMap(fa -> BYTE_BUFFER_GENERATORS.stream().\n+                flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n@@ -201,1 +190,1 @@\n-    public Object[][] doubleByteBufferMaskProvider() {\n+    public Object[][] doubleMemorySegmentMaskProvider() {\n@@ -204,1 +193,1 @@\n-                        flatMap(fa -> BYTE_BUFFER_GENERATORS.stream().\n+                        flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n@@ -211,19 +200,0 @@\n-    @DataProvider\n-    public Object[][] doubleByteArrayProvider() {\n-        return DOUBLE_GENERATORS.stream().\n-                flatMap(fa -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                    return new Object[]{fa, bo};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] doubleByteArrayMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> DOUBLE_GENERATORS.stream().\n-                    flatMap(fa -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                        return new Object[]{fa, fm, bo};\n-                    }))).\n-                toArray(Object[][]::new);\n-    }\n-\n@@ -249,4 +219,4 @@\n-    static ByteBuffer toBuffer(double[] a, IntFunction<ByteBuffer> fb) {\n-        ByteBuffer bb = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n-        for (double v : a) {\n-            bb.putDouble(v);\n+    static MemorySegment toSegment(double[] a, IntFunction<MemorySegment> fb) {\n+        MemorySegment ms = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n+        for (int i = 0; i < a.length; i++) {\n+            ms.set(ValueLayout.JAVA_DOUBLE, i * SPECIES.elementSize() \/ 8 , a[i]);\n@@ -254,1 +224,1 @@\n-        return bb.clear();\n+        return ms;\n@@ -257,14 +227,2 @@\n-    static double[] bufferToArray(ByteBuffer bb) {\n-        DoubleBuffer db = bb.asDoubleBuffer();\n-        double[] d = new double[db.capacity()];\n-        db.get(0, d);\n-        return d;\n-    }\n-\n-    static byte[] toByteArray(double[] a, IntFunction<byte[]> fb, ByteOrder bo) {\n-        byte[] b = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n-        DoubleBuffer bb = ByteBuffer.wrap(b, 0, b.length).order(bo).asDoubleBuffer();\n-        for (double v : a) {\n-            bb.put(v);\n-        }\n-        return b;\n+    static double[] segmentToArray(MemorySegment ms) {\n+        return ms.toArray(ValueLayout.JAVA_DOUBLE);\n@@ -310,22 +268,2 @@\n-    static DoubleVector fromByteArray(byte[] a, int i, ByteOrder bo) {\n-        return DoubleVector.fromByteArray(SPECIES, a, i, bo);\n-    }\n-\n-    @DontInline\n-    static DoubleVector fromByteArray(byte[] a, int i, ByteOrder bo, VectorMask<Double> m) {\n-        return DoubleVector.fromByteArray(SPECIES, a, i, bo, m);\n-    }\n-\n-    @DontInline\n-    static void intoByteArray(DoubleVector v, byte[] a, int i, ByteOrder bo) {\n-        v.intoByteArray(a, i, bo);\n-    }\n-\n-    @DontInline\n-    static void intoByteArray(DoubleVector v, byte[] a, int i, ByteOrder bo, VectorMask<Double> m) {\n-        v.intoByteArray(a, i, bo, m);\n-    }\n-\n-    @DontInline\n-    static DoubleVector fromByteBuffer(ByteBuffer a, int i, ByteOrder bo) {\n-        return DoubleVector.fromByteBuffer(SPECIES, a, i, bo);\n+    static DoubleVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo) {\n+        return DoubleVector.fromMemorySegment(SPECIES, a, i, bo);\n@@ -335,2 +273,2 @@\n-    static DoubleVector fromByteBuffer(ByteBuffer a, int i, ByteOrder bo, VectorMask<Double> m) {\n-        return DoubleVector.fromByteBuffer(SPECIES, a, i, bo, m);\n+    static DoubleVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo, VectorMask<Double> m) {\n+        return DoubleVector.fromMemorySegment(SPECIES, a, i, bo, m);\n@@ -340,2 +278,2 @@\n-    static void intoByteBuffer(DoubleVector v, ByteBuffer a, int i, ByteOrder bo) {\n-        v.intoByteBuffer(a, i, bo);\n+    static void intoMemorySegment(DoubleVector v, MemorySegment a, int i, ByteOrder bo) {\n+        v.intoMemorySegment(a, i, bo);\n@@ -345,2 +283,2 @@\n-    static void intoByteBuffer(DoubleVector v, ByteBuffer a, int i, ByteOrder bo, VectorMask<Double> m) {\n-        v.intoByteBuffer(a, i, bo, m);\n+    static void intoMemorySegment(DoubleVector v, MemorySegment a, int i, ByteOrder bo, VectorMask<Double> m) {\n+        v.intoMemorySegment(a, i, bo, m);\n@@ -349,1 +287,0 @@\n-\n@@ -520,6 +457,6 @@\n-    @Test(dataProvider = \"doubleByteBufferProvider\")\n-    static void loadStoreByteBuffer(IntFunction<double[]> fa,\n-                                    IntFunction<ByteBuffer> fb,\n-                                    ByteOrder bo) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), fb);\n-        ByteBuffer r = fb.apply(a.limit());\n+    @Test(dataProvider = \"doubleMemorySegmentProvider\")\n+    static void loadStoreMemorySegment(IntFunction<double[]> fa,\n+                                       IntFunction<MemorySegment> fb,\n+                                       ByteOrder bo) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb);\n+        MemorySegment r = fb.apply((int) a.byteSize());\n@@ -527,1 +464,1 @@\n-        int l = a.limit();\n+        int l = (int) a.byteSize();\n@@ -532,2 +469,2 @@\n-                DoubleVector av = DoubleVector.fromByteBuffer(SPECIES, a, i, bo);\n-                av.intoByteBuffer(r, i, bo);\n+                DoubleVector av = DoubleVector.fromMemorySegment(SPECIES, a, i, bo);\n+                av.intoMemorySegment(r, i, bo);\n@@ -536,5 +473,2 @@\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        Assert.assertEquals(r, a, \"Buffers not equal\");\n+        long m = r.mismatch(a);\n+        Assert.assertEquals(m, -1, \"Segments not equal\");\n@@ -544,3 +478,3 @@\n-    static void loadByteBufferIOOBE(IntFunction<double[]> fa, IntFunction<Integer> fi) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n+    static void loadMemorySegmentIOOBE(IntFunction<double[]> fa, IntFunction<Integer> fi) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n@@ -548,1 +482,1 @@\n-        int l = a.limit();\n+        int l = (int) a.byteSize();\n@@ -553,2 +487,2 @@\n-                DoubleVector av = fromByteBuffer(a, i, ByteOrder.nativeOrder());\n-                av.intoByteBuffer(r, i, ByteOrder.nativeOrder());\n+                DoubleVector av = fromMemorySegment(a, i, ByteOrder.nativeOrder());\n+                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n@@ -558,2 +492,2 @@\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.limit());\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());\n@@ -561,1 +495,1 @@\n-            fromByteBuffer(a, index, ByteOrder.nativeOrder());\n+            fromMemorySegment(a, index, ByteOrder.nativeOrder());\n@@ -573,3 +507,3 @@\n-    static void storeByteBufferIOOBE(IntFunction<double[]> fa, IntFunction<Integer> fi) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n+    static void storeMemorySegmentIOOBE(IntFunction<double[]> fa, IntFunction<Integer> fi) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n@@ -577,1 +511,1 @@\n-        int l = a.limit();\n+        int l = (int) a.byteSize();\n@@ -582,2 +516,2 @@\n-                DoubleVector av = DoubleVector.fromByteBuffer(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteBuffer(av, r, i, ByteOrder.nativeOrder());\n+                DoubleVector av = DoubleVector.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+                intoMemorySegment(av, r, i, ByteOrder.nativeOrder());\n@@ -587,2 +521,2 @@\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.limit());\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());\n@@ -590,2 +524,2 @@\n-            DoubleVector av = DoubleVector.fromByteBuffer(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteBuffer(av, r, index, ByteOrder.nativeOrder());\n+            DoubleVector av = DoubleVector.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+            intoMemorySegment(av, r, index, ByteOrder.nativeOrder());\n@@ -602,6 +536,5 @@\n-\n-    @Test(dataProvider = \"doubleByteBufferMaskProvider\")\n-    static void loadStoreByteBufferMask(IntFunction<double[]> fa,\n-                                        IntFunction<ByteBuffer> fb,\n-                                        IntFunction<boolean[]> fm,\n-                                        ByteOrder bo) {\n+    @Test(dataProvider = \"doubleMemorySegmentMaskProvider\")\n+    static void loadStoreMemorySegmentMask(IntFunction<double[]> fa,\n+                                           IntFunction<MemorySegment> fb,\n+                                           IntFunction<boolean[]> fm,\n+                                           ByteOrder bo) {\n@@ -609,2 +542,2 @@\n-        ByteBuffer a = toBuffer(_a, fb);\n-        ByteBuffer r = fb.apply(a.limit());\n+        MemorySegment a = toSegment(_a, fb);\n+        MemorySegment r = fb.apply((int) a.byteSize());\n@@ -614,1 +547,1 @@\n-        int l = a.limit();\n+        int l = (int) a.byteSize();\n@@ -619,2 +552,2 @@\n-                DoubleVector av = DoubleVector.fromByteBuffer(SPECIES, a, i, bo, vmask);\n-                av.intoByteBuffer(r, i, bo);\n+                DoubleVector av = DoubleVector.fromMemorySegment(SPECIES, a, i, bo, vmask);\n+                av.intoMemorySegment(r, i, bo);\n@@ -623,5 +556,1 @@\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        assertArraysEquals(bufferToArray(r), _a, mask);\n+        assertArraysEquals(segmentToArray(r), _a, mask);\n@@ -630,1 +559,1 @@\n-        r = fb.apply(a.limit());\n+        r = fb.apply((int) a.byteSize());\n@@ -634,2 +563,2 @@\n-                DoubleVector av = DoubleVector.fromByteBuffer(SPECIES, a, i, bo);\n-                av.intoByteBuffer(r, i, bo, vmask);\n+                DoubleVector av = DoubleVector.fromMemorySegment(SPECIES, a, i, bo);\n+                av.intoMemorySegment(r, i, bo, vmask);\n@@ -638,5 +567,1 @@\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        assertArraysEquals(bufferToArray(r), _a, mask);\n+        assertArraysEquals(segmentToArray(r), _a, mask);\n@@ -646,3 +571,3 @@\n-    static void loadByteBufferMaskIOOBE(IntFunction<double[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n+    static void loadMemorySegmentMaskIOOBE(IntFunction<double[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n@@ -652,1 +577,1 @@\n-        int l = a.limit();\n+        int l = (int) a.byteSize();\n@@ -657,2 +582,2 @@\n-                DoubleVector av = fromByteBuffer(a, i, ByteOrder.nativeOrder(), vmask);\n-                av.intoByteBuffer(r, i, ByteOrder.nativeOrder());\n+                DoubleVector av = fromMemorySegment(a, i, ByteOrder.nativeOrder(), vmask);\n+                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n@@ -662,2 +587,2 @@\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.limit(), SPECIES.elementSize() \/ 8);\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() \/ 8);\n@@ -665,1 +590,1 @@\n-            fromByteBuffer(a, index, ByteOrder.nativeOrder(), vmask);\n+            fromMemorySegment(a, index, ByteOrder.nativeOrder(), vmask);\n@@ -677,3 +602,3 @@\n-    static void storeByteBufferMaskIOOBE(IntFunction<double[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n+    static void storeMemorySegmentMaskIOOBE(IntFunction<double[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n@@ -683,83 +608,1 @@\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                DoubleVector av = DoubleVector.fromByteBuffer(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteBuffer(av, r, i, ByteOrder.nativeOrder(), vmask);\n-            }\n-        }\n-\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.limit(), SPECIES.elementSize() \/ 8);\n-        try {\n-            DoubleVector av = DoubleVector.fromByteBuffer(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteBuffer(av, a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"doubleByteBufferProvider\")\n-    static void loadStoreReadonlyByteBuffer(IntFunction<double[]> fa,\n-                                    IntFunction<ByteBuffer> fb,\n-                                    ByteOrder bo) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), fb).asReadOnlyBuffer();\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo);\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, SPECIES.maskAll(true));\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, SPECIES.maskAll(false));\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            VectorMask<Double> m = SPECIES.shuffleFromOp(i -> i % 2 == 0 ? 1 : -1)\n-                    .laneIsValid();\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, m);\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"doubleByteArrayProvider\")\n-    static void loadStoreByteArray(IntFunction<double[]> fa,\n-                                    ByteOrder bo) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, bo);\n-        byte[] r = new byte[a.length];\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                DoubleVector av = DoubleVector.fromByteArray(SPECIES, a, i, bo);\n-                av.intoByteArray(r, i, bo);\n-            }\n-        }\n-        Assert.assertEquals(r, a, \"Byte arrays not equal\");\n-    }\n-\n-    @Test(dataProvider = \"doubleByteProviderForIOOBE\")\n-    static void loadByteArrayIOOBE(IntFunction<double[]> fa, IntFunction<Integer> fi) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-\n+        int l = (int) a.byteSize();\n@@ -767,1 +610,0 @@\n-        int l = a.length;\n@@ -771,2 +613,2 @@\n-                DoubleVector av = fromByteArray(a, i, ByteOrder.nativeOrder());\n-                av.intoByteArray(r, i, ByteOrder.nativeOrder());\n+                DoubleVector av = DoubleVector.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+                intoMemorySegment(av, r, i, ByteOrder.nativeOrder(), vmask);\n@@ -776,2 +618,2 @@\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.length);\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() \/ 8);\n@@ -779,1 +621,2 @@\n-            fromByteArray(a, index, ByteOrder.nativeOrder());\n+            DoubleVector av = DoubleVector.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+            intoMemorySegment(av, a, index, ByteOrder.nativeOrder(), vmask);\n@@ -790,62 +633,5 @@\n-    @Test(dataProvider = \"doubleByteProviderForIOOBE\")\n-    static void storeByteArrayIOOBE(IntFunction<double[]> fa, IntFunction<Integer> fi) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                DoubleVector av = DoubleVector.fromByteArray(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteArray(av, r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.length);\n-        try {\n-            DoubleVector av = DoubleVector.fromByteArray(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteArray(av, r, index, ByteOrder.nativeOrder());\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"doubleByteArrayMaskProvider\")\n-    static void loadStoreByteArrayMask(IntFunction<double[]> fa,\n-                                  IntFunction<boolean[]> fm,\n-                                  ByteOrder bo) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, bo);\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Double> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-          for (int i = 0; i < l; i += s) {\n-              DoubleVector av = DoubleVector.fromByteArray(SPECIES, a, i, bo, vmask);\n-              av.intoByteArray(r, i, bo);\n-          }\n-        }\n-        assertArraysEquals(r, a, mask);\n-\n-\n-        r = new byte[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                DoubleVector av = DoubleVector.fromByteArray(SPECIES, a, i, bo);\n-                av.intoByteArray(r, i, bo, vmask);\n-            }\n-        }\n-        assertArraysEquals(r, a, mask);\n-    }\n+    @Test(dataProvider = \"doubleMemorySegmentProvider\")\n+    static void loadStoreReadonlyMemorySegment(IntFunction<double[]> fa,\n+                                               IntFunction<MemorySegment> fb,\n+                                               ByteOrder bo) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb).asReadOnly();\n@@ -853,6 +639,4 @@\n-    @Test(dataProvider = \"doubleByteMaskProviderForIOOBE\")\n-    static void loadByteArrayMaskIOOBE(IntFunction<double[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Double> vmask = VectorMask.fromValues(SPECIES, mask);\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo)\n+        );\n@@ -860,2 +644,4 @@\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(true))\n+        );\n@@ -863,6 +649,4 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                DoubleVector av = fromByteArray(a, i, ByteOrder.nativeOrder(), vmask);\n-                av.intoByteArray(r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(false))\n+        );\n@@ -870,12 +654,6 @@\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length, SPECIES.elementSize() \/ 8);\n-        try {\n-            fromByteArray(a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n+        VectorMask<Double> m = SPECIES.shuffleFromOp(i -> i % 2 == 0 ? 1 : -1)\n+                .laneIsValid();\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, m)\n+        );\n@@ -884,31 +662,0 @@\n-    @Test(dataProvider = \"doubleByteMaskProviderForIOOBE\")\n-    static void storeByteArrayMaskIOOBE(IntFunction<double[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Double> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                DoubleVector av = DoubleVector.fromByteArray(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteArray(av, r, i, ByteOrder.nativeOrder(), vmask);\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length, SPECIES.elementSize() \/ 8);\n-        try {\n-            DoubleVector av = DoubleVector.fromByteArray(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteArray(av, a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n@@ -930,0 +677,1 @@\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double512VectorLoadStoreTests.java","additions":112,"deletions":364,"binary":false,"changes":476,"status":"modified"},{"patch":"@@ -63,1 +63,0 @@\n-    private static final double CONST_SHIFT = Double.SIZE \/ 2;\n@@ -264,0 +263,49 @@\n+    static void assertcompressArraysEquals(double[] r, double[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    Assert.assertEquals(r[i + k], (double)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (double)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals(double[] r, double[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        Assert.assertEquals(r[i + j], (double)0);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (double)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n@@ -1016,2 +1064,0 @@\n-\n-\n@@ -1201,1 +1247,0 @@\n-\n@@ -1322,1 +1367,0 @@\n-\n@@ -1347,1 +1391,0 @@\n-\n@@ -1464,0 +1507,1 @@\n+\n@@ -1520,0 +1564,1 @@\n+\n@@ -1540,0 +1585,1 @@\n+\n@@ -1596,0 +1642,1 @@\n+\n@@ -1616,0 +1663,1 @@\n+\n@@ -1693,0 +1741,1 @@\n+\n@@ -1712,2 +1761,0 @@\n-\n-\n@@ -1752,2 +1799,0 @@\n-\n-\n@@ -1795,8 +1840,0 @@\n-\n-\n-\n-\n-\n-\n-\n-\n@@ -1896,1 +1933,0 @@\n-\n@@ -1911,2 +1947,0 @@\n-\n-\n@@ -1930,9 +1964,0 @@\n-\n-\n-\n-\n-\n-\n-\n-\n-\n@@ -1970,57 +1995,0 @@\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n@@ -2047,0 +2015,1 @@\n+\n@@ -2065,0 +2034,1 @@\n+\n@@ -2085,0 +2055,1 @@\n+\n@@ -2160,11 +2131,0 @@\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n@@ -2188,0 +2148,1 @@\n+\n@@ -2212,0 +2173,1 @@\n+\n@@ -2230,0 +2192,1 @@\n+\n@@ -2256,0 +2219,1 @@\n+\n@@ -2273,0 +2237,1 @@\n+\n@@ -2297,0 +2262,1 @@\n+\n@@ -2315,0 +2281,1 @@\n+\n@@ -2341,0 +2308,1 @@\n+\n@@ -2358,0 +2326,1 @@\n+\n@@ -2382,0 +2351,1 @@\n+\n@@ -2400,0 +2370,1 @@\n+\n@@ -2426,0 +2397,1 @@\n+\n@@ -2443,0 +2415,1 @@\n+\n@@ -2467,0 +2440,1 @@\n+\n@@ -2485,0 +2459,1 @@\n+\n@@ -2511,0 +2486,1 @@\n+\n@@ -2528,0 +2504,1 @@\n+\n@@ -2552,0 +2529,1 @@\n+\n@@ -2570,0 +2548,1 @@\n+\n@@ -2597,4 +2576,0 @@\n-\n-\n-\n-\n@@ -2618,0 +2593,1 @@\n+\n@@ -2658,0 +2634,1 @@\n+\n@@ -2740,1 +2717,0 @@\n-\n@@ -2782,1 +2758,0 @@\n-\n@@ -2824,1 +2799,0 @@\n-\n@@ -2844,1 +2818,0 @@\n-\n@@ -2887,1 +2860,0 @@\n-\n@@ -2930,1 +2902,0 @@\n-\n@@ -2950,1 +2921,0 @@\n-\n@@ -2993,1 +2963,0 @@\n-\n@@ -3036,1 +3005,0 @@\n-\n@@ -3079,1 +3047,0 @@\n-\n@@ -3122,9 +3089,0 @@\n-\n-\n-\n-\n-\n-\n-\n-\n-\n@@ -3147,1 +3105,0 @@\n-\n@@ -3184,1 +3141,0 @@\n-\n@@ -3221,1 +3177,0 @@\n-\n@@ -3258,1 +3213,0 @@\n-\n@@ -3337,0 +3291,37 @@\n+\n+    @Test(dataProvider = \"doubleUnaryOpMaskProvider\")\n+    static void compressDouble512VectorTests(IntFunction<double[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.compress(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertcompressArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"doubleUnaryOpMaskProvider\")\n+    static void expandDouble512VectorTests(IntFunction<double[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.expand(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertexpandArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n@@ -3507,4 +3498,0 @@\n-\n-\n-\n-\n@@ -3525,3 +3512,0 @@\n-\n-\n-\n@@ -3553,0 +3537,1 @@\n+\n@@ -3582,0 +3567,1 @@\n+\n@@ -3615,0 +3601,1 @@\n+\n@@ -3642,0 +3629,1 @@\n+\n@@ -3681,0 +3669,1 @@\n+\n@@ -3761,1 +3750,0 @@\n-\n@@ -3785,1 +3773,0 @@\n-\n@@ -3809,1 +3796,0 @@\n-\n@@ -3833,1 +3819,0 @@\n-\n@@ -3857,1 +3842,0 @@\n-\n@@ -3881,1 +3865,0 @@\n-\n@@ -3905,1 +3888,0 @@\n-\n@@ -3929,1 +3911,0 @@\n-\n@@ -3953,1 +3934,0 @@\n-\n@@ -3977,1 +3957,0 @@\n-\n@@ -4001,1 +3980,0 @@\n-\n@@ -4025,1 +4003,0 @@\n-\n@@ -4049,1 +4026,0 @@\n-\n@@ -4073,1 +4049,0 @@\n-\n@@ -4097,1 +4072,0 @@\n-\n@@ -4124,1 +4098,0 @@\n-\n@@ -4150,0 +4123,1 @@\n+\n@@ -4176,1 +4150,0 @@\n-\n@@ -4203,1 +4176,0 @@\n-\n@@ -4218,0 +4190,1 @@\n+\n@@ -4233,1 +4206,0 @@\n-\n@@ -4237,0 +4209,1 @@\n+\n@@ -4241,1 +4214,0 @@\n-\n@@ -4267,0 +4239,1 @@\n+\n@@ -4291,1 +4264,0 @@\n-\n@@ -4321,4 +4293,0 @@\n-\n-\n-\n-\n@@ -4355,1 +4323,0 @@\n-\n@@ -4394,3 +4361,0 @@\n-\n-\n-\n@@ -4418,0 +4382,1 @@\n+\n@@ -4440,1 +4405,0 @@\n-\n@@ -4466,3 +4430,0 @@\n-\n-\n-\n@@ -4581,7 +4542,0 @@\n-\n-\n-\n-\n-\n-\n-\n@@ -4596,2 +4550,0 @@\n-\n-\n@@ -4628,2 +4580,0 @@\n-\n-\n@@ -4648,1 +4598,0 @@\n-\n@@ -5040,0 +4989,17 @@\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCompressDouble512VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        int trueCount = 0;\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                trueCount = vmask.trueCount();\n+                var rmask = vmask.compress();\n+                for (int j = 0; j < SPECIES.length(); j++)  {\n+                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);\n+                }\n+            }\n+        }\n+    }\n+\n@@ -5082,0 +5048,14 @@\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeLongDouble512VectorTestsSmokeTest(int offset) {\n+        long limit = SPECIES.length() * BUFFER_REPS;\n+        for (long i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i + offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                long index = i + j + offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n@@ -5102,0 +5082,8 @@\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundLongDouble512VectorTestsSmokeTest(int _length) {\n+        long length = _length;\n+        long actualLoopBound = SPECIES.loopBound(length);\n+        long expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+    }\n+\n@@ -5164,1 +5152,0 @@\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double512VectorTests.java","additions":165,"deletions":178,"binary":false,"changes":343,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,3 @@\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.ValueLayout;\n@@ -42,2 +45,0 @@\n-import java.nio.ByteBuffer;\n-import java.nio.DoubleBuffer;\n@@ -45,1 +46,0 @@\n-import java.nio.ReadOnlyBufferException;\n@@ -70,11 +70,0 @@\n-    static void assertArraysEquals(byte[] r, byte[] a, boolean[] mask) {\n-        int i = 0;\n-        try {\n-            for (; i < a.length; i++) {\n-                Assert.assertEquals(r[i], mask[(i*8\/SPECIES.elementSize()) % SPECIES.length()] ? a[i] : (byte) 0);\n-            }\n-        } catch (AssertionError e) {\n-            Assert.assertEquals(r[i], mask[(i*8\/SPECIES.elementSize()) % SPECIES.length()] ? a[i] : (byte) 0, \"at index #\" + i);\n-        }\n-    }\n-\n@@ -120,1 +109,1 @@\n-    \/\/ Relative to byte[] array.length or ByteBuffer.limit()\n+    \/\/ Relative to byte[] array.length or MemorySegment.byteSize()\n@@ -191,1 +180,1 @@\n-    public Object[][] doubleByteBufferProvider() {\n+    public Object[][] doubleMemorySegmentProvider() {\n@@ -193,1 +182,1 @@\n-                flatMap(fa -> BYTE_BUFFER_GENERATORS.stream().\n+                flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n@@ -201,1 +190,1 @@\n-    public Object[][] doubleByteBufferMaskProvider() {\n+    public Object[][] doubleMemorySegmentMaskProvider() {\n@@ -204,1 +193,1 @@\n-                        flatMap(fa -> BYTE_BUFFER_GENERATORS.stream().\n+                        flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n@@ -211,19 +200,0 @@\n-    @DataProvider\n-    public Object[][] doubleByteArrayProvider() {\n-        return DOUBLE_GENERATORS.stream().\n-                flatMap(fa -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                    return new Object[]{fa, bo};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] doubleByteArrayMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> DOUBLE_GENERATORS.stream().\n-                    flatMap(fa -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                        return new Object[]{fa, fm, bo};\n-                    }))).\n-                toArray(Object[][]::new);\n-    }\n-\n@@ -249,4 +219,4 @@\n-    static ByteBuffer toBuffer(double[] a, IntFunction<ByteBuffer> fb) {\n-        ByteBuffer bb = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n-        for (double v : a) {\n-            bb.putDouble(v);\n+    static MemorySegment toSegment(double[] a, IntFunction<MemorySegment> fb) {\n+        MemorySegment ms = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n+        for (int i = 0; i < a.length; i++) {\n+            ms.set(ValueLayout.JAVA_DOUBLE, i * SPECIES.elementSize() \/ 8 , a[i]);\n@@ -254,1 +224,1 @@\n-        return bb.clear();\n+        return ms;\n@@ -257,14 +227,2 @@\n-    static double[] bufferToArray(ByteBuffer bb) {\n-        DoubleBuffer db = bb.asDoubleBuffer();\n-        double[] d = new double[db.capacity()];\n-        db.get(0, d);\n-        return d;\n-    }\n-\n-    static byte[] toByteArray(double[] a, IntFunction<byte[]> fb, ByteOrder bo) {\n-        byte[] b = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n-        DoubleBuffer bb = ByteBuffer.wrap(b, 0, b.length).order(bo).asDoubleBuffer();\n-        for (double v : a) {\n-            bb.put(v);\n-        }\n-        return b;\n+    static double[] segmentToArray(MemorySegment ms) {\n+        return ms.toArray(ValueLayout.JAVA_DOUBLE);\n@@ -310,22 +268,2 @@\n-    static DoubleVector fromByteArray(byte[] a, int i, ByteOrder bo) {\n-        return DoubleVector.fromByteArray(SPECIES, a, i, bo);\n-    }\n-\n-    @DontInline\n-    static DoubleVector fromByteArray(byte[] a, int i, ByteOrder bo, VectorMask<Double> m) {\n-        return DoubleVector.fromByteArray(SPECIES, a, i, bo, m);\n-    }\n-\n-    @DontInline\n-    static void intoByteArray(DoubleVector v, byte[] a, int i, ByteOrder bo) {\n-        v.intoByteArray(a, i, bo);\n-    }\n-\n-    @DontInline\n-    static void intoByteArray(DoubleVector v, byte[] a, int i, ByteOrder bo, VectorMask<Double> m) {\n-        v.intoByteArray(a, i, bo, m);\n-    }\n-\n-    @DontInline\n-    static DoubleVector fromByteBuffer(ByteBuffer a, int i, ByteOrder bo) {\n-        return DoubleVector.fromByteBuffer(SPECIES, a, i, bo);\n+    static DoubleVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo) {\n+        return DoubleVector.fromMemorySegment(SPECIES, a, i, bo);\n@@ -335,2 +273,2 @@\n-    static DoubleVector fromByteBuffer(ByteBuffer a, int i, ByteOrder bo, VectorMask<Double> m) {\n-        return DoubleVector.fromByteBuffer(SPECIES, a, i, bo, m);\n+    static DoubleVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo, VectorMask<Double> m) {\n+        return DoubleVector.fromMemorySegment(SPECIES, a, i, bo, m);\n@@ -340,2 +278,2 @@\n-    static void intoByteBuffer(DoubleVector v, ByteBuffer a, int i, ByteOrder bo) {\n-        v.intoByteBuffer(a, i, bo);\n+    static void intoMemorySegment(DoubleVector v, MemorySegment a, int i, ByteOrder bo) {\n+        v.intoMemorySegment(a, i, bo);\n@@ -345,2 +283,2 @@\n-    static void intoByteBuffer(DoubleVector v, ByteBuffer a, int i, ByteOrder bo, VectorMask<Double> m) {\n-        v.intoByteBuffer(a, i, bo, m);\n+    static void intoMemorySegment(DoubleVector v, MemorySegment a, int i, ByteOrder bo, VectorMask<Double> m) {\n+        v.intoMemorySegment(a, i, bo, m);\n@@ -349,1 +287,0 @@\n-\n@@ -520,6 +457,6 @@\n-    @Test(dataProvider = \"doubleByteBufferProvider\")\n-    static void loadStoreByteBuffer(IntFunction<double[]> fa,\n-                                    IntFunction<ByteBuffer> fb,\n-                                    ByteOrder bo) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), fb);\n-        ByteBuffer r = fb.apply(a.limit());\n+    @Test(dataProvider = \"doubleMemorySegmentProvider\")\n+    static void loadStoreMemorySegment(IntFunction<double[]> fa,\n+                                       IntFunction<MemorySegment> fb,\n+                                       ByteOrder bo) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb);\n+        MemorySegment r = fb.apply((int) a.byteSize());\n@@ -527,1 +464,1 @@\n-        int l = a.limit();\n+        int l = (int) a.byteSize();\n@@ -532,2 +469,2 @@\n-                DoubleVector av = DoubleVector.fromByteBuffer(SPECIES, a, i, bo);\n-                av.intoByteBuffer(r, i, bo);\n+                DoubleVector av = DoubleVector.fromMemorySegment(SPECIES, a, i, bo);\n+                av.intoMemorySegment(r, i, bo);\n@@ -536,5 +473,2 @@\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        Assert.assertEquals(r, a, \"Buffers not equal\");\n+        long m = r.mismatch(a);\n+        Assert.assertEquals(m, -1, \"Segments not equal\");\n@@ -544,3 +478,3 @@\n-    static void loadByteBufferIOOBE(IntFunction<double[]> fa, IntFunction<Integer> fi) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n+    static void loadMemorySegmentIOOBE(IntFunction<double[]> fa, IntFunction<Integer> fi) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n@@ -548,1 +482,1 @@\n-        int l = a.limit();\n+        int l = (int) a.byteSize();\n@@ -553,2 +487,2 @@\n-                DoubleVector av = fromByteBuffer(a, i, ByteOrder.nativeOrder());\n-                av.intoByteBuffer(r, i, ByteOrder.nativeOrder());\n+                DoubleVector av = fromMemorySegment(a, i, ByteOrder.nativeOrder());\n+                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n@@ -558,2 +492,2 @@\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.limit());\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());\n@@ -561,1 +495,1 @@\n-            fromByteBuffer(a, index, ByteOrder.nativeOrder());\n+            fromMemorySegment(a, index, ByteOrder.nativeOrder());\n@@ -573,3 +507,3 @@\n-    static void storeByteBufferIOOBE(IntFunction<double[]> fa, IntFunction<Integer> fi) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n+    static void storeMemorySegmentIOOBE(IntFunction<double[]> fa, IntFunction<Integer> fi) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n@@ -577,1 +511,1 @@\n-        int l = a.limit();\n+        int l = (int) a.byteSize();\n@@ -582,2 +516,2 @@\n-                DoubleVector av = DoubleVector.fromByteBuffer(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteBuffer(av, r, i, ByteOrder.nativeOrder());\n+                DoubleVector av = DoubleVector.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+                intoMemorySegment(av, r, i, ByteOrder.nativeOrder());\n@@ -587,2 +521,2 @@\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.limit());\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());\n@@ -590,2 +524,2 @@\n-            DoubleVector av = DoubleVector.fromByteBuffer(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteBuffer(av, r, index, ByteOrder.nativeOrder());\n+            DoubleVector av = DoubleVector.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+            intoMemorySegment(av, r, index, ByteOrder.nativeOrder());\n@@ -602,6 +536,5 @@\n-\n-    @Test(dataProvider = \"doubleByteBufferMaskProvider\")\n-    static void loadStoreByteBufferMask(IntFunction<double[]> fa,\n-                                        IntFunction<ByteBuffer> fb,\n-                                        IntFunction<boolean[]> fm,\n-                                        ByteOrder bo) {\n+    @Test(dataProvider = \"doubleMemorySegmentMaskProvider\")\n+    static void loadStoreMemorySegmentMask(IntFunction<double[]> fa,\n+                                           IntFunction<MemorySegment> fb,\n+                                           IntFunction<boolean[]> fm,\n+                                           ByteOrder bo) {\n@@ -609,2 +542,2 @@\n-        ByteBuffer a = toBuffer(_a, fb);\n-        ByteBuffer r = fb.apply(a.limit());\n+        MemorySegment a = toSegment(_a, fb);\n+        MemorySegment r = fb.apply((int) a.byteSize());\n@@ -614,1 +547,1 @@\n-        int l = a.limit();\n+        int l = (int) a.byteSize();\n@@ -619,2 +552,2 @@\n-                DoubleVector av = DoubleVector.fromByteBuffer(SPECIES, a, i, bo, vmask);\n-                av.intoByteBuffer(r, i, bo);\n+                DoubleVector av = DoubleVector.fromMemorySegment(SPECIES, a, i, bo, vmask);\n+                av.intoMemorySegment(r, i, bo);\n@@ -623,5 +556,1 @@\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        assertArraysEquals(bufferToArray(r), _a, mask);\n+        assertArraysEquals(segmentToArray(r), _a, mask);\n@@ -630,1 +559,1 @@\n-        r = fb.apply(a.limit());\n+        r = fb.apply((int) a.byteSize());\n@@ -634,2 +563,2 @@\n-                DoubleVector av = DoubleVector.fromByteBuffer(SPECIES, a, i, bo);\n-                av.intoByteBuffer(r, i, bo, vmask);\n+                DoubleVector av = DoubleVector.fromMemorySegment(SPECIES, a, i, bo);\n+                av.intoMemorySegment(r, i, bo, vmask);\n@@ -638,5 +567,1 @@\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        assertArraysEquals(bufferToArray(r), _a, mask);\n+        assertArraysEquals(segmentToArray(r), _a, mask);\n@@ -646,3 +571,3 @@\n-    static void loadByteBufferMaskIOOBE(IntFunction<double[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n+    static void loadMemorySegmentMaskIOOBE(IntFunction<double[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n@@ -652,1 +577,1 @@\n-        int l = a.limit();\n+        int l = (int) a.byteSize();\n@@ -657,2 +582,2 @@\n-                DoubleVector av = fromByteBuffer(a, i, ByteOrder.nativeOrder(), vmask);\n-                av.intoByteBuffer(r, i, ByteOrder.nativeOrder());\n+                DoubleVector av = fromMemorySegment(a, i, ByteOrder.nativeOrder(), vmask);\n+                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n@@ -662,2 +587,2 @@\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.limit(), SPECIES.elementSize() \/ 8);\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() \/ 8);\n@@ -665,1 +590,1 @@\n-            fromByteBuffer(a, index, ByteOrder.nativeOrder(), vmask);\n+            fromMemorySegment(a, index, ByteOrder.nativeOrder(), vmask);\n@@ -677,3 +602,3 @@\n-    static void storeByteBufferMaskIOOBE(IntFunction<double[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n+    static void storeMemorySegmentMaskIOOBE(IntFunction<double[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n@@ -683,83 +608,1 @@\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                DoubleVector av = DoubleVector.fromByteBuffer(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteBuffer(av, r, i, ByteOrder.nativeOrder(), vmask);\n-            }\n-        }\n-\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.limit(), SPECIES.elementSize() \/ 8);\n-        try {\n-            DoubleVector av = DoubleVector.fromByteBuffer(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteBuffer(av, a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"doubleByteBufferProvider\")\n-    static void loadStoreReadonlyByteBuffer(IntFunction<double[]> fa,\n-                                    IntFunction<ByteBuffer> fb,\n-                                    ByteOrder bo) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), fb).asReadOnlyBuffer();\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo);\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, SPECIES.maskAll(true));\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, SPECIES.maskAll(false));\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            VectorMask<Double> m = SPECIES.shuffleFromOp(i -> i % 2 == 0 ? 1 : -1)\n-                    .laneIsValid();\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, m);\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"doubleByteArrayProvider\")\n-    static void loadStoreByteArray(IntFunction<double[]> fa,\n-                                    ByteOrder bo) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, bo);\n-        byte[] r = new byte[a.length];\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                DoubleVector av = DoubleVector.fromByteArray(SPECIES, a, i, bo);\n-                av.intoByteArray(r, i, bo);\n-            }\n-        }\n-        Assert.assertEquals(r, a, \"Byte arrays not equal\");\n-    }\n-\n-    @Test(dataProvider = \"doubleByteProviderForIOOBE\")\n-    static void loadByteArrayIOOBE(IntFunction<double[]> fa, IntFunction<Integer> fi) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-\n+        int l = (int) a.byteSize();\n@@ -767,1 +610,0 @@\n-        int l = a.length;\n@@ -771,2 +613,2 @@\n-                DoubleVector av = fromByteArray(a, i, ByteOrder.nativeOrder());\n-                av.intoByteArray(r, i, ByteOrder.nativeOrder());\n+                DoubleVector av = DoubleVector.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+                intoMemorySegment(av, r, i, ByteOrder.nativeOrder(), vmask);\n@@ -776,2 +618,2 @@\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.length);\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() \/ 8);\n@@ -779,1 +621,2 @@\n-            fromByteArray(a, index, ByteOrder.nativeOrder());\n+            DoubleVector av = DoubleVector.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+            intoMemorySegment(av, a, index, ByteOrder.nativeOrder(), vmask);\n@@ -790,62 +633,5 @@\n-    @Test(dataProvider = \"doubleByteProviderForIOOBE\")\n-    static void storeByteArrayIOOBE(IntFunction<double[]> fa, IntFunction<Integer> fi) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                DoubleVector av = DoubleVector.fromByteArray(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteArray(av, r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.length);\n-        try {\n-            DoubleVector av = DoubleVector.fromByteArray(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteArray(av, r, index, ByteOrder.nativeOrder());\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"doubleByteArrayMaskProvider\")\n-    static void loadStoreByteArrayMask(IntFunction<double[]> fa,\n-                                  IntFunction<boolean[]> fm,\n-                                  ByteOrder bo) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, bo);\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Double> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-          for (int i = 0; i < l; i += s) {\n-              DoubleVector av = DoubleVector.fromByteArray(SPECIES, a, i, bo, vmask);\n-              av.intoByteArray(r, i, bo);\n-          }\n-        }\n-        assertArraysEquals(r, a, mask);\n-\n-\n-        r = new byte[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                DoubleVector av = DoubleVector.fromByteArray(SPECIES, a, i, bo);\n-                av.intoByteArray(r, i, bo, vmask);\n-            }\n-        }\n-        assertArraysEquals(r, a, mask);\n-    }\n+    @Test(dataProvider = \"doubleMemorySegmentProvider\")\n+    static void loadStoreReadonlyMemorySegment(IntFunction<double[]> fa,\n+                                               IntFunction<MemorySegment> fb,\n+                                               ByteOrder bo) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb).asReadOnly();\n@@ -853,6 +639,4 @@\n-    @Test(dataProvider = \"doubleByteMaskProviderForIOOBE\")\n-    static void loadByteArrayMaskIOOBE(IntFunction<double[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Double> vmask = VectorMask.fromValues(SPECIES, mask);\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo)\n+        );\n@@ -860,2 +644,4 @@\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(true))\n+        );\n@@ -863,6 +649,4 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                DoubleVector av = fromByteArray(a, i, ByteOrder.nativeOrder(), vmask);\n-                av.intoByteArray(r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(false))\n+        );\n@@ -870,12 +654,6 @@\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length, SPECIES.elementSize() \/ 8);\n-        try {\n-            fromByteArray(a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n+        VectorMask<Double> m = SPECIES.shuffleFromOp(i -> i % 2 == 0 ? 1 : -1)\n+                .laneIsValid();\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, m)\n+        );\n@@ -884,31 +662,0 @@\n-    @Test(dataProvider = \"doubleByteMaskProviderForIOOBE\")\n-    static void storeByteArrayMaskIOOBE(IntFunction<double[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Double> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                DoubleVector av = DoubleVector.fromByteArray(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteArray(av, r, i, ByteOrder.nativeOrder(), vmask);\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length, SPECIES.elementSize() \/ 8);\n-        try {\n-            DoubleVector av = DoubleVector.fromByteArray(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteArray(av, a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n@@ -930,0 +677,1 @@\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double64VectorLoadStoreTests.java","additions":112,"deletions":364,"binary":false,"changes":476,"status":"modified"},{"patch":"@@ -63,1 +63,0 @@\n-    private static final double CONST_SHIFT = Double.SIZE \/ 2;\n@@ -264,0 +263,49 @@\n+    static void assertcompressArraysEquals(double[] r, double[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    Assert.assertEquals(r[i + k], (double)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (double)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals(double[] r, double[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        Assert.assertEquals(r[i + j], (double)0);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (double)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n@@ -1016,2 +1064,0 @@\n-\n-\n@@ -1201,1 +1247,0 @@\n-\n@@ -1322,1 +1367,0 @@\n-\n@@ -1347,1 +1391,0 @@\n-\n@@ -1464,0 +1507,1 @@\n+\n@@ -1520,0 +1564,1 @@\n+\n@@ -1540,0 +1585,1 @@\n+\n@@ -1596,0 +1642,1 @@\n+\n@@ -1616,0 +1663,1 @@\n+\n@@ -1693,0 +1741,1 @@\n+\n@@ -1712,2 +1761,0 @@\n-\n-\n@@ -1752,2 +1799,0 @@\n-\n-\n@@ -1795,8 +1840,0 @@\n-\n-\n-\n-\n-\n-\n-\n-\n@@ -1896,1 +1933,0 @@\n-\n@@ -1911,2 +1947,0 @@\n-\n-\n@@ -1930,9 +1964,0 @@\n-\n-\n-\n-\n-\n-\n-\n-\n-\n@@ -1970,57 +1995,0 @@\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n@@ -2047,0 +2015,1 @@\n+\n@@ -2065,0 +2034,1 @@\n+\n@@ -2085,0 +2055,1 @@\n+\n@@ -2160,11 +2131,0 @@\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n@@ -2188,0 +2148,1 @@\n+\n@@ -2212,0 +2173,1 @@\n+\n@@ -2230,0 +2192,1 @@\n+\n@@ -2256,0 +2219,1 @@\n+\n@@ -2273,0 +2237,1 @@\n+\n@@ -2297,0 +2262,1 @@\n+\n@@ -2315,0 +2281,1 @@\n+\n@@ -2341,0 +2308,1 @@\n+\n@@ -2358,0 +2326,1 @@\n+\n@@ -2382,0 +2351,1 @@\n+\n@@ -2400,0 +2370,1 @@\n+\n@@ -2426,0 +2397,1 @@\n+\n@@ -2443,0 +2415,1 @@\n+\n@@ -2467,0 +2440,1 @@\n+\n@@ -2485,0 +2459,1 @@\n+\n@@ -2511,0 +2486,1 @@\n+\n@@ -2528,0 +2504,1 @@\n+\n@@ -2552,0 +2529,1 @@\n+\n@@ -2570,0 +2548,1 @@\n+\n@@ -2597,4 +2576,0 @@\n-\n-\n-\n-\n@@ -2618,0 +2593,1 @@\n+\n@@ -2658,0 +2634,1 @@\n+\n@@ -2740,1 +2717,0 @@\n-\n@@ -2782,1 +2758,0 @@\n-\n@@ -2824,1 +2799,0 @@\n-\n@@ -2844,1 +2818,0 @@\n-\n@@ -2887,1 +2860,0 @@\n-\n@@ -2930,1 +2902,0 @@\n-\n@@ -2950,1 +2921,0 @@\n-\n@@ -2993,1 +2963,0 @@\n-\n@@ -3036,1 +3005,0 @@\n-\n@@ -3079,1 +3047,0 @@\n-\n@@ -3122,9 +3089,0 @@\n-\n-\n-\n-\n-\n-\n-\n-\n-\n@@ -3147,1 +3105,0 @@\n-\n@@ -3184,1 +3141,0 @@\n-\n@@ -3221,1 +3177,0 @@\n-\n@@ -3258,1 +3213,0 @@\n-\n@@ -3337,0 +3291,37 @@\n+\n+    @Test(dataProvider = \"doubleUnaryOpMaskProvider\")\n+    static void compressDouble64VectorTests(IntFunction<double[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.compress(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertcompressArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"doubleUnaryOpMaskProvider\")\n+    static void expandDouble64VectorTests(IntFunction<double[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.expand(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertexpandArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n@@ -3507,4 +3498,0 @@\n-\n-\n-\n-\n@@ -3525,3 +3512,0 @@\n-\n-\n-\n@@ -3553,0 +3537,1 @@\n+\n@@ -3582,0 +3567,1 @@\n+\n@@ -3615,0 +3601,1 @@\n+\n@@ -3642,0 +3629,1 @@\n+\n@@ -3681,0 +3669,1 @@\n+\n@@ -3761,1 +3750,0 @@\n-\n@@ -3785,1 +3773,0 @@\n-\n@@ -3809,1 +3796,0 @@\n-\n@@ -3833,1 +3819,0 @@\n-\n@@ -3857,1 +3842,0 @@\n-\n@@ -3881,1 +3865,0 @@\n-\n@@ -3905,1 +3888,0 @@\n-\n@@ -3929,1 +3911,0 @@\n-\n@@ -3953,1 +3934,0 @@\n-\n@@ -3977,1 +3957,0 @@\n-\n@@ -4001,1 +3980,0 @@\n-\n@@ -4025,1 +4003,0 @@\n-\n@@ -4049,1 +4026,0 @@\n-\n@@ -4073,1 +4049,0 @@\n-\n@@ -4097,1 +4072,0 @@\n-\n@@ -4124,1 +4098,0 @@\n-\n@@ -4150,0 +4123,1 @@\n+\n@@ -4176,1 +4150,0 @@\n-\n@@ -4203,1 +4176,0 @@\n-\n@@ -4218,0 +4190,1 @@\n+\n@@ -4233,1 +4206,0 @@\n-\n@@ -4237,0 +4209,1 @@\n+\n@@ -4241,1 +4214,0 @@\n-\n@@ -4267,0 +4239,1 @@\n+\n@@ -4291,1 +4264,0 @@\n-\n@@ -4321,4 +4293,0 @@\n-\n-\n-\n-\n@@ -4355,1 +4323,0 @@\n-\n@@ -4394,3 +4361,0 @@\n-\n-\n-\n@@ -4418,0 +4382,1 @@\n+\n@@ -4440,1 +4405,0 @@\n-\n@@ -4466,3 +4430,0 @@\n-\n-\n-\n@@ -4581,7 +4542,0 @@\n-\n-\n-\n-\n-\n-\n-\n@@ -4596,2 +4550,0 @@\n-\n-\n@@ -4628,2 +4580,0 @@\n-\n-\n@@ -4648,1 +4598,0 @@\n-\n@@ -5040,0 +4989,17 @@\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCompressDouble64VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        int trueCount = 0;\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                trueCount = vmask.trueCount();\n+                var rmask = vmask.compress();\n+                for (int j = 0; j < SPECIES.length(); j++)  {\n+                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);\n+                }\n+            }\n+        }\n+    }\n+\n@@ -5082,0 +5048,14 @@\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeLongDouble64VectorTestsSmokeTest(int offset) {\n+        long limit = SPECIES.length() * BUFFER_REPS;\n+        for (long i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i + offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                long index = i + j + offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n@@ -5102,0 +5082,8 @@\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundLongDouble64VectorTestsSmokeTest(int _length) {\n+        long length = _length;\n+        long actualLoopBound = SPECIES.loopBound(length);\n+        long expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+    }\n+\n@@ -5164,1 +5152,0 @@\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double64VectorTests.java","additions":165,"deletions":178,"binary":false,"changes":343,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,3 @@\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.ValueLayout;\n@@ -44,4 +47,0 @@\n-import java.lang.invoke.MethodHandles;\n-import java.lang.invoke.VarHandle;\n-import java.nio.ByteBuffer;\n-import java.nio.DoubleBuffer;\n@@ -49,1 +48,0 @@\n-import java.nio.ReadOnlyBufferException;\n@@ -79,11 +77,0 @@\n-    static void assertArraysEquals(byte[] r, byte[] a, boolean[] mask) {\n-        int i = 0;\n-        try {\n-            for (; i < a.length; i++) {\n-                Assert.assertEquals(r[i], mask[(i*8\/SPECIES.elementSize()) % SPECIES.length()] ? a[i] : (byte) 0);\n-            }\n-        } catch (AssertionError e) {\n-            Assert.assertEquals(r[i], mask[(i*8\/SPECIES.elementSize()) % SPECIES.length()] ? a[i] : (byte) 0, \"at index #\" + i);\n-        }\n-    }\n-\n@@ -129,1 +116,1 @@\n-    \/\/ Relative to byte[] array.length or ByteBuffer.limit()\n+    \/\/ Relative to byte[] array.length or MemorySegment.byteSize()\n@@ -200,1 +187,1 @@\n-    public Object[][] doubleByteBufferProvider() {\n+    public Object[][] doubleMemorySegmentProvider() {\n@@ -202,1 +189,1 @@\n-                flatMap(fa -> BYTE_BUFFER_GENERATORS.stream().\n+                flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n@@ -210,1 +197,1 @@\n-    public Object[][] doubleByteBufferMaskProvider() {\n+    public Object[][] doubleMemorySegmentMaskProvider() {\n@@ -213,1 +200,1 @@\n-                        flatMap(fa -> BYTE_BUFFER_GENERATORS.stream().\n+                        flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n@@ -220,19 +207,0 @@\n-    @DataProvider\n-    public Object[][] doubleByteArrayProvider() {\n-        return DOUBLE_GENERATORS.stream().\n-                flatMap(fa -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                    return new Object[]{fa, bo};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] doubleByteArrayMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> DOUBLE_GENERATORS.stream().\n-                    flatMap(fa -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                        return new Object[]{fa, fm, bo};\n-                    }))).\n-                toArray(Object[][]::new);\n-    }\n-\n@@ -258,4 +226,4 @@\n-    static ByteBuffer toBuffer(double[] a, IntFunction<ByteBuffer> fb) {\n-        ByteBuffer bb = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n-        for (double v : a) {\n-            bb.putDouble(v);\n+    static MemorySegment toSegment(double[] a, IntFunction<MemorySegment> fb) {\n+        MemorySegment ms = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n+        for (int i = 0; i < a.length; i++) {\n+            ms.set(ValueLayout.JAVA_DOUBLE, i * SPECIES.elementSize() \/ 8 , a[i]);\n@@ -263,1 +231,1 @@\n-        return bb.clear();\n+        return ms;\n@@ -266,14 +234,2 @@\n-    static double[] bufferToArray(ByteBuffer bb) {\n-        DoubleBuffer db = bb.asDoubleBuffer();\n-        double[] d = new double[db.capacity()];\n-        db.get(0, d);\n-        return d;\n-    }\n-\n-    static byte[] toByteArray(double[] a, IntFunction<byte[]> fb, ByteOrder bo) {\n-        byte[] b = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n-        DoubleBuffer bb = ByteBuffer.wrap(b, 0, b.length).order(bo).asDoubleBuffer();\n-        for (double v : a) {\n-            bb.put(v);\n-        }\n-        return b;\n+    static double[] segmentToArray(MemorySegment ms) {\n+        return ms.toArray(ValueLayout.JAVA_DOUBLE);\n@@ -319,22 +275,2 @@\n-    static DoubleVector fromByteArray(byte[] a, int i, ByteOrder bo) {\n-        return DoubleVector.fromByteArray(SPECIES, a, i, bo);\n-    }\n-\n-    @DontInline\n-    static DoubleVector fromByteArray(byte[] a, int i, ByteOrder bo, VectorMask<Double> m) {\n-        return DoubleVector.fromByteArray(SPECIES, a, i, bo, m);\n-    }\n-\n-    @DontInline\n-    static void intoByteArray(DoubleVector v, byte[] a, int i, ByteOrder bo) {\n-        v.intoByteArray(a, i, bo);\n-    }\n-\n-    @DontInline\n-    static void intoByteArray(DoubleVector v, byte[] a, int i, ByteOrder bo, VectorMask<Double> m) {\n-        v.intoByteArray(a, i, bo, m);\n-    }\n-\n-    @DontInline\n-    static DoubleVector fromByteBuffer(ByteBuffer a, int i, ByteOrder bo) {\n-        return DoubleVector.fromByteBuffer(SPECIES, a, i, bo);\n+    static DoubleVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo) {\n+        return DoubleVector.fromMemorySegment(SPECIES, a, i, bo);\n@@ -344,2 +280,2 @@\n-    static DoubleVector fromByteBuffer(ByteBuffer a, int i, ByteOrder bo, VectorMask<Double> m) {\n-        return DoubleVector.fromByteBuffer(SPECIES, a, i, bo, m);\n+    static DoubleVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo, VectorMask<Double> m) {\n+        return DoubleVector.fromMemorySegment(SPECIES, a, i, bo, m);\n@@ -349,2 +285,2 @@\n-    static void intoByteBuffer(DoubleVector v, ByteBuffer a, int i, ByteOrder bo) {\n-        v.intoByteBuffer(a, i, bo);\n+    static void intoMemorySegment(DoubleVector v, MemorySegment a, int i, ByteOrder bo) {\n+        v.intoMemorySegment(a, i, bo);\n@@ -354,2 +290,2 @@\n-    static void intoByteBuffer(DoubleVector v, ByteBuffer a, int i, ByteOrder bo, VectorMask<Double> m) {\n-        v.intoByteBuffer(a, i, bo, m);\n+    static void intoMemorySegment(DoubleVector v, MemorySegment a, int i, ByteOrder bo, VectorMask<Double> m) {\n+        v.intoMemorySegment(a, i, bo, m);\n@@ -358,1 +294,0 @@\n-\n@@ -529,6 +464,6 @@\n-    @Test(dataProvider = \"doubleByteBufferProvider\")\n-    static void loadStoreByteBuffer(IntFunction<double[]> fa,\n-                                    IntFunction<ByteBuffer> fb,\n-                                    ByteOrder bo) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), fb);\n-        ByteBuffer r = fb.apply(a.limit());\n+    @Test(dataProvider = \"doubleMemorySegmentProvider\")\n+    static void loadStoreMemorySegment(IntFunction<double[]> fa,\n+                                       IntFunction<MemorySegment> fb,\n+                                       ByteOrder bo) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb);\n+        MemorySegment r = fb.apply((int) a.byteSize());\n@@ -536,1 +471,1 @@\n-        int l = a.limit();\n+        int l = (int) a.byteSize();\n@@ -541,2 +476,2 @@\n-                DoubleVector av = DoubleVector.fromByteBuffer(SPECIES, a, i, bo);\n-                av.intoByteBuffer(r, i, bo);\n+                DoubleVector av = DoubleVector.fromMemorySegment(SPECIES, a, i, bo);\n+                av.intoMemorySegment(r, i, bo);\n@@ -545,5 +480,2 @@\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        Assert.assertEquals(r, a, \"Buffers not equal\");\n+        long m = r.mismatch(a);\n+        Assert.assertEquals(m, -1, \"Segments not equal\");\n@@ -553,3 +485,3 @@\n-    static void loadByteBufferIOOBE(IntFunction<double[]> fa, IntFunction<Integer> fi) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n+    static void loadMemorySegmentIOOBE(IntFunction<double[]> fa, IntFunction<Integer> fi) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n@@ -557,1 +489,1 @@\n-        int l = a.limit();\n+        int l = (int) a.byteSize();\n@@ -562,2 +494,2 @@\n-                DoubleVector av = fromByteBuffer(a, i, ByteOrder.nativeOrder());\n-                av.intoByteBuffer(r, i, ByteOrder.nativeOrder());\n+                DoubleVector av = fromMemorySegment(a, i, ByteOrder.nativeOrder());\n+                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n@@ -567,2 +499,2 @@\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.limit());\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());\n@@ -570,1 +502,1 @@\n-            fromByteBuffer(a, index, ByteOrder.nativeOrder());\n+            fromMemorySegment(a, index, ByteOrder.nativeOrder());\n@@ -582,3 +514,3 @@\n-    static void storeByteBufferIOOBE(IntFunction<double[]> fa, IntFunction<Integer> fi) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n+    static void storeMemorySegmentIOOBE(IntFunction<double[]> fa, IntFunction<Integer> fi) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n@@ -586,1 +518,1 @@\n-        int l = a.limit();\n+        int l = (int) a.byteSize();\n@@ -591,2 +523,2 @@\n-                DoubleVector av = DoubleVector.fromByteBuffer(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteBuffer(av, r, i, ByteOrder.nativeOrder());\n+                DoubleVector av = DoubleVector.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+                intoMemorySegment(av, r, i, ByteOrder.nativeOrder());\n@@ -596,2 +528,2 @@\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.limit());\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());\n@@ -599,2 +531,2 @@\n-            DoubleVector av = DoubleVector.fromByteBuffer(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteBuffer(av, r, index, ByteOrder.nativeOrder());\n+            DoubleVector av = DoubleVector.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+            intoMemorySegment(av, r, index, ByteOrder.nativeOrder());\n@@ -611,6 +543,5 @@\n-\n-    @Test(dataProvider = \"doubleByteBufferMaskProvider\")\n-    static void loadStoreByteBufferMask(IntFunction<double[]> fa,\n-                                        IntFunction<ByteBuffer> fb,\n-                                        IntFunction<boolean[]> fm,\n-                                        ByteOrder bo) {\n+    @Test(dataProvider = \"doubleMemorySegmentMaskProvider\")\n+    static void loadStoreMemorySegmentMask(IntFunction<double[]> fa,\n+                                           IntFunction<MemorySegment> fb,\n+                                           IntFunction<boolean[]> fm,\n+                                           ByteOrder bo) {\n@@ -618,2 +549,2 @@\n-        ByteBuffer a = toBuffer(_a, fb);\n-        ByteBuffer r = fb.apply(a.limit());\n+        MemorySegment a = toSegment(_a, fb);\n+        MemorySegment r = fb.apply((int) a.byteSize());\n@@ -623,1 +554,1 @@\n-        int l = a.limit();\n+        int l = (int) a.byteSize();\n@@ -628,2 +559,2 @@\n-                DoubleVector av = DoubleVector.fromByteBuffer(SPECIES, a, i, bo, vmask);\n-                av.intoByteBuffer(r, i, bo);\n+                DoubleVector av = DoubleVector.fromMemorySegment(SPECIES, a, i, bo, vmask);\n+                av.intoMemorySegment(r, i, bo);\n@@ -632,5 +563,1 @@\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        assertArraysEquals(bufferToArray(r), _a, mask);\n+        assertArraysEquals(segmentToArray(r), _a, mask);\n@@ -639,1 +566,1 @@\n-        r = fb.apply(a.limit());\n+        r = fb.apply((int) a.byteSize());\n@@ -643,2 +570,2 @@\n-                DoubleVector av = DoubleVector.fromByteBuffer(SPECIES, a, i, bo);\n-                av.intoByteBuffer(r, i, bo, vmask);\n+                DoubleVector av = DoubleVector.fromMemorySegment(SPECIES, a, i, bo);\n+                av.intoMemorySegment(r, i, bo, vmask);\n@@ -647,5 +574,1 @@\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        assertArraysEquals(bufferToArray(r), _a, mask);\n+        assertArraysEquals(segmentToArray(r), _a, mask);\n@@ -655,3 +578,3 @@\n-    static void loadByteBufferMaskIOOBE(IntFunction<double[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n+    static void loadMemorySegmentMaskIOOBE(IntFunction<double[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n@@ -661,1 +584,1 @@\n-        int l = a.limit();\n+        int l = (int) a.byteSize();\n@@ -666,2 +589,2 @@\n-                DoubleVector av = fromByteBuffer(a, i, ByteOrder.nativeOrder(), vmask);\n-                av.intoByteBuffer(r, i, ByteOrder.nativeOrder());\n+                DoubleVector av = fromMemorySegment(a, i, ByteOrder.nativeOrder(), vmask);\n+                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n@@ -671,2 +594,2 @@\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.limit(), SPECIES.elementSize() \/ 8);\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() \/ 8);\n@@ -674,1 +597,1 @@\n-            fromByteBuffer(a, index, ByteOrder.nativeOrder(), vmask);\n+            fromMemorySegment(a, index, ByteOrder.nativeOrder(), vmask);\n@@ -686,3 +609,3 @@\n-    static void storeByteBufferMaskIOOBE(IntFunction<double[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n+    static void storeMemorySegmentMaskIOOBE(IntFunction<double[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n@@ -692,83 +615,1 @@\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                DoubleVector av = DoubleVector.fromByteBuffer(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteBuffer(av, r, i, ByteOrder.nativeOrder(), vmask);\n-            }\n-        }\n-\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.limit(), SPECIES.elementSize() \/ 8);\n-        try {\n-            DoubleVector av = DoubleVector.fromByteBuffer(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteBuffer(av, a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"doubleByteBufferProvider\")\n-    static void loadStoreReadonlyByteBuffer(IntFunction<double[]> fa,\n-                                    IntFunction<ByteBuffer> fb,\n-                                    ByteOrder bo) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), fb).asReadOnlyBuffer();\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo);\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, SPECIES.maskAll(true));\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, SPECIES.maskAll(false));\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            VectorMask<Double> m = SPECIES.shuffleFromOp(i -> i % 2 == 0 ? 1 : -1)\n-                    .laneIsValid();\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, m);\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"doubleByteArrayProvider\")\n-    static void loadStoreByteArray(IntFunction<double[]> fa,\n-                                    ByteOrder bo) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, bo);\n-        byte[] r = new byte[a.length];\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                DoubleVector av = DoubleVector.fromByteArray(SPECIES, a, i, bo);\n-                av.intoByteArray(r, i, bo);\n-            }\n-        }\n-        Assert.assertEquals(r, a, \"Byte arrays not equal\");\n-    }\n-\n-    @Test(dataProvider = \"doubleByteProviderForIOOBE\")\n-    static void loadByteArrayIOOBE(IntFunction<double[]> fa, IntFunction<Integer> fi) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-\n+        int l = (int) a.byteSize();\n@@ -776,1 +617,0 @@\n-        int l = a.length;\n@@ -780,2 +620,2 @@\n-                DoubleVector av = fromByteArray(a, i, ByteOrder.nativeOrder());\n-                av.intoByteArray(r, i, ByteOrder.nativeOrder());\n+                DoubleVector av = DoubleVector.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+                intoMemorySegment(av, r, i, ByteOrder.nativeOrder(), vmask);\n@@ -785,2 +625,2 @@\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.length);\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() \/ 8);\n@@ -788,1 +628,2 @@\n-            fromByteArray(a, index, ByteOrder.nativeOrder());\n+            DoubleVector av = DoubleVector.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+            intoMemorySegment(av, a, index, ByteOrder.nativeOrder(), vmask);\n@@ -799,62 +640,5 @@\n-    @Test(dataProvider = \"doubleByteProviderForIOOBE\")\n-    static void storeByteArrayIOOBE(IntFunction<double[]> fa, IntFunction<Integer> fi) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                DoubleVector av = DoubleVector.fromByteArray(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteArray(av, r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.length);\n-        try {\n-            DoubleVector av = DoubleVector.fromByteArray(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteArray(av, r, index, ByteOrder.nativeOrder());\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"doubleByteArrayMaskProvider\")\n-    static void loadStoreByteArrayMask(IntFunction<double[]> fa,\n-                                  IntFunction<boolean[]> fm,\n-                                  ByteOrder bo) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, bo);\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Double> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-          for (int i = 0; i < l; i += s) {\n-              DoubleVector av = DoubleVector.fromByteArray(SPECIES, a, i, bo, vmask);\n-              av.intoByteArray(r, i, bo);\n-          }\n-        }\n-        assertArraysEquals(r, a, mask);\n-\n-\n-        r = new byte[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                DoubleVector av = DoubleVector.fromByteArray(SPECIES, a, i, bo);\n-                av.intoByteArray(r, i, bo, vmask);\n-            }\n-        }\n-        assertArraysEquals(r, a, mask);\n-    }\n+    @Test(dataProvider = \"doubleMemorySegmentProvider\")\n+    static void loadStoreReadonlyMemorySegment(IntFunction<double[]> fa,\n+                                               IntFunction<MemorySegment> fb,\n+                                               ByteOrder bo) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb).asReadOnly();\n@@ -862,6 +646,4 @@\n-    @Test(dataProvider = \"doubleByteMaskProviderForIOOBE\")\n-    static void loadByteArrayMaskIOOBE(IntFunction<double[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Double> vmask = VectorMask.fromValues(SPECIES, mask);\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo)\n+        );\n@@ -869,2 +651,4 @@\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(true))\n+        );\n@@ -872,6 +656,4 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                DoubleVector av = fromByteArray(a, i, ByteOrder.nativeOrder(), vmask);\n-                av.intoByteArray(r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(false))\n+        );\n@@ -879,12 +661,6 @@\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length, SPECIES.elementSize() \/ 8);\n-        try {\n-            fromByteArray(a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n+        VectorMask<Double> m = SPECIES.shuffleFromOp(i -> i % 2 == 0 ? 1 : -1)\n+                .laneIsValid();\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, m)\n+        );\n@@ -893,31 +669,0 @@\n-    @Test(dataProvider = \"doubleByteMaskProviderForIOOBE\")\n-    static void storeByteArrayMaskIOOBE(IntFunction<double[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Double> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                DoubleVector av = DoubleVector.fromByteArray(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteArray(av, r, i, ByteOrder.nativeOrder(), vmask);\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length, SPECIES.elementSize() \/ 8);\n-        try {\n-            DoubleVector av = DoubleVector.fromByteArray(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteArray(av, a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n@@ -939,0 +684,1 @@\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/DoubleMaxVectorLoadStoreTests.java","additions":112,"deletions":366,"binary":false,"changes":478,"status":"modified"},{"patch":"@@ -68,1 +68,0 @@\n-    private static final double CONST_SHIFT = Double.SIZE \/ 2;\n@@ -269,0 +268,49 @@\n+    static void assertcompressArraysEquals(double[] r, double[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    Assert.assertEquals(r[i + k], (double)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (double)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals(double[] r, double[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        Assert.assertEquals(r[i + j], (double)0);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (double)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n@@ -1021,2 +1069,0 @@\n-\n-\n@@ -1206,1 +1252,0 @@\n-\n@@ -1327,1 +1372,0 @@\n-\n@@ -1352,1 +1396,0 @@\n-\n@@ -1469,0 +1512,1 @@\n+\n@@ -1525,0 +1569,1 @@\n+\n@@ -1545,0 +1590,1 @@\n+\n@@ -1601,0 +1647,1 @@\n+\n@@ -1621,0 +1668,1 @@\n+\n@@ -1698,0 +1746,1 @@\n+\n@@ -1717,2 +1766,0 @@\n-\n-\n@@ -1757,2 +1804,0 @@\n-\n-\n@@ -1800,8 +1845,0 @@\n-\n-\n-\n-\n-\n-\n-\n-\n@@ -1901,1 +1938,0 @@\n-\n@@ -1916,2 +1952,0 @@\n-\n-\n@@ -1935,9 +1969,0 @@\n-\n-\n-\n-\n-\n-\n-\n-\n-\n@@ -1975,57 +2000,0 @@\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n@@ -2052,0 +2020,1 @@\n+\n@@ -2070,0 +2039,1 @@\n+\n@@ -2090,0 +2060,1 @@\n+\n@@ -2165,11 +2136,0 @@\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n@@ -2193,0 +2153,1 @@\n+\n@@ -2217,0 +2178,1 @@\n+\n@@ -2235,0 +2197,1 @@\n+\n@@ -2261,0 +2224,1 @@\n+\n@@ -2278,0 +2242,1 @@\n+\n@@ -2302,0 +2267,1 @@\n+\n@@ -2320,0 +2286,1 @@\n+\n@@ -2346,0 +2313,1 @@\n+\n@@ -2363,0 +2331,1 @@\n+\n@@ -2387,0 +2356,1 @@\n+\n@@ -2405,0 +2375,1 @@\n+\n@@ -2431,0 +2402,1 @@\n+\n@@ -2448,0 +2420,1 @@\n+\n@@ -2472,0 +2445,1 @@\n+\n@@ -2490,0 +2464,1 @@\n+\n@@ -2516,0 +2491,1 @@\n+\n@@ -2533,0 +2509,1 @@\n+\n@@ -2557,0 +2534,1 @@\n+\n@@ -2575,0 +2553,1 @@\n+\n@@ -2602,4 +2581,0 @@\n-\n-\n-\n-\n@@ -2623,0 +2598,1 @@\n+\n@@ -2663,0 +2639,1 @@\n+\n@@ -2745,1 +2722,0 @@\n-\n@@ -2787,1 +2763,0 @@\n-\n@@ -2829,1 +2804,0 @@\n-\n@@ -2849,1 +2823,0 @@\n-\n@@ -2892,1 +2865,0 @@\n-\n@@ -2935,1 +2907,0 @@\n-\n@@ -2955,1 +2926,0 @@\n-\n@@ -2998,1 +2968,0 @@\n-\n@@ -3041,1 +3010,0 @@\n-\n@@ -3084,1 +3052,0 @@\n-\n@@ -3127,9 +3094,0 @@\n-\n-\n-\n-\n-\n-\n-\n-\n-\n@@ -3152,1 +3110,0 @@\n-\n@@ -3189,1 +3146,0 @@\n-\n@@ -3226,1 +3182,0 @@\n-\n@@ -3263,1 +3218,0 @@\n-\n@@ -3342,0 +3296,37 @@\n+\n+    @Test(dataProvider = \"doubleUnaryOpMaskProvider\")\n+    static void compressDoubleMaxVectorTests(IntFunction<double[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.compress(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertcompressArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"doubleUnaryOpMaskProvider\")\n+    static void expandDoubleMaxVectorTests(IntFunction<double[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.expand(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertexpandArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n@@ -3512,4 +3503,0 @@\n-\n-\n-\n-\n@@ -3530,3 +3517,0 @@\n-\n-\n-\n@@ -3558,0 +3542,1 @@\n+\n@@ -3587,0 +3572,1 @@\n+\n@@ -3620,0 +3606,1 @@\n+\n@@ -3647,0 +3634,1 @@\n+\n@@ -3686,0 +3674,1 @@\n+\n@@ -3766,1 +3755,0 @@\n-\n@@ -3790,1 +3778,0 @@\n-\n@@ -3814,1 +3801,0 @@\n-\n@@ -3838,1 +3824,0 @@\n-\n@@ -3862,1 +3847,0 @@\n-\n@@ -3886,1 +3870,0 @@\n-\n@@ -3910,1 +3893,0 @@\n-\n@@ -3934,1 +3916,0 @@\n-\n@@ -3958,1 +3939,0 @@\n-\n@@ -3982,1 +3962,0 @@\n-\n@@ -4006,1 +3985,0 @@\n-\n@@ -4030,1 +4008,0 @@\n-\n@@ -4054,1 +4031,0 @@\n-\n@@ -4078,1 +4054,0 @@\n-\n@@ -4102,1 +4077,0 @@\n-\n@@ -4129,1 +4103,0 @@\n-\n@@ -4155,0 +4128,1 @@\n+\n@@ -4181,1 +4155,0 @@\n-\n@@ -4208,1 +4181,0 @@\n-\n@@ -4223,0 +4195,1 @@\n+\n@@ -4238,1 +4211,0 @@\n-\n@@ -4242,0 +4214,1 @@\n+\n@@ -4246,1 +4219,0 @@\n-\n@@ -4272,0 +4244,1 @@\n+\n@@ -4296,1 +4269,0 @@\n-\n@@ -4326,4 +4298,0 @@\n-\n-\n-\n-\n@@ -4360,1 +4328,0 @@\n-\n@@ -4399,3 +4366,0 @@\n-\n-\n-\n@@ -4423,0 +4387,1 @@\n+\n@@ -4445,1 +4410,0 @@\n-\n@@ -4471,3 +4435,0 @@\n-\n-\n-\n@@ -4586,7 +4547,0 @@\n-\n-\n-\n-\n-\n-\n-\n@@ -4601,2 +4555,0 @@\n-\n-\n@@ -4633,2 +4585,0 @@\n-\n-\n@@ -4653,1 +4603,0 @@\n-\n@@ -5045,0 +4994,17 @@\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCompressDoubleMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        int trueCount = 0;\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                trueCount = vmask.trueCount();\n+                var rmask = vmask.compress();\n+                for (int j = 0; j < SPECIES.length(); j++)  {\n+                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);\n+                }\n+            }\n+        }\n+    }\n+\n@@ -5071,0 +5037,14 @@\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeLongDoubleMaxVectorTestsSmokeTest(int offset) {\n+        long limit = SPECIES.length() * BUFFER_REPS;\n+        for (long i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i + offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                long index = i + j + offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n@@ -5091,0 +5071,8 @@\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundLongDoubleMaxVectorTestsSmokeTest(int _length) {\n+        long length = _length;\n+        long actualLoopBound = SPECIES.loopBound(length);\n+        long expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+    }\n+\n@@ -5153,1 +5141,0 @@\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/DoubleMaxVectorTests.java","additions":165,"deletions":178,"binary":false,"changes":343,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,3 @@\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.ValueLayout;\n@@ -42,2 +45,0 @@\n-import java.nio.ByteBuffer;\n-import java.nio.FloatBuffer;\n@@ -45,1 +46,0 @@\n-import java.nio.ReadOnlyBufferException;\n@@ -70,11 +70,0 @@\n-    static void assertArraysEquals(byte[] r, byte[] a, boolean[] mask) {\n-        int i = 0;\n-        try {\n-            for (; i < a.length; i++) {\n-                Assert.assertEquals(r[i], mask[(i*8\/SPECIES.elementSize()) % SPECIES.length()] ? a[i] : (byte) 0);\n-            }\n-        } catch (AssertionError e) {\n-            Assert.assertEquals(r[i], mask[(i*8\/SPECIES.elementSize()) % SPECIES.length()] ? a[i] : (byte) 0, \"at index #\" + i);\n-        }\n-    }\n-\n@@ -120,1 +109,1 @@\n-    \/\/ Relative to byte[] array.length or ByteBuffer.limit()\n+    \/\/ Relative to byte[] array.length or MemorySegment.byteSize()\n@@ -191,1 +180,1 @@\n-    public Object[][] floatByteBufferProvider() {\n+    public Object[][] floatMemorySegmentProvider() {\n@@ -193,1 +182,1 @@\n-                flatMap(fa -> BYTE_BUFFER_GENERATORS.stream().\n+                flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n@@ -201,1 +190,1 @@\n-    public Object[][] floatByteBufferMaskProvider() {\n+    public Object[][] floatMemorySegmentMaskProvider() {\n@@ -204,1 +193,1 @@\n-                        flatMap(fa -> BYTE_BUFFER_GENERATORS.stream().\n+                        flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n@@ -211,19 +200,0 @@\n-    @DataProvider\n-    public Object[][] floatByteArrayProvider() {\n-        return FLOAT_GENERATORS.stream().\n-                flatMap(fa -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                    return new Object[]{fa, bo};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] floatByteArrayMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> FLOAT_GENERATORS.stream().\n-                    flatMap(fa -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                        return new Object[]{fa, fm, bo};\n-                    }))).\n-                toArray(Object[][]::new);\n-    }\n-\n@@ -249,4 +219,4 @@\n-    static ByteBuffer toBuffer(float[] a, IntFunction<ByteBuffer> fb) {\n-        ByteBuffer bb = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n-        for (float v : a) {\n-            bb.putFloat(v);\n+    static MemorySegment toSegment(float[] a, IntFunction<MemorySegment> fb) {\n+        MemorySegment ms = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n+        for (int i = 0; i < a.length; i++) {\n+            ms.set(ValueLayout.JAVA_FLOAT, i * SPECIES.elementSize() \/ 8 , a[i]);\n@@ -254,1 +224,1 @@\n-        return bb.clear();\n+        return ms;\n@@ -257,14 +227,2 @@\n-    static float[] bufferToArray(ByteBuffer bb) {\n-        FloatBuffer db = bb.asFloatBuffer();\n-        float[] d = new float[db.capacity()];\n-        db.get(0, d);\n-        return d;\n-    }\n-\n-    static byte[] toByteArray(float[] a, IntFunction<byte[]> fb, ByteOrder bo) {\n-        byte[] b = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n-        FloatBuffer bb = ByteBuffer.wrap(b, 0, b.length).order(bo).asFloatBuffer();\n-        for (float v : a) {\n-            bb.put(v);\n-        }\n-        return b;\n+    static float[] segmentToArray(MemorySegment ms) {\n+        return ms.toArray(ValueLayout.JAVA_FLOAT);\n@@ -310,22 +268,2 @@\n-    static FloatVector fromByteArray(byte[] a, int i, ByteOrder bo) {\n-        return FloatVector.fromByteArray(SPECIES, a, i, bo);\n-    }\n-\n-    @DontInline\n-    static FloatVector fromByteArray(byte[] a, int i, ByteOrder bo, VectorMask<Float> m) {\n-        return FloatVector.fromByteArray(SPECIES, a, i, bo, m);\n-    }\n-\n-    @DontInline\n-    static void intoByteArray(FloatVector v, byte[] a, int i, ByteOrder bo) {\n-        v.intoByteArray(a, i, bo);\n-    }\n-\n-    @DontInline\n-    static void intoByteArray(FloatVector v, byte[] a, int i, ByteOrder bo, VectorMask<Float> m) {\n-        v.intoByteArray(a, i, bo, m);\n-    }\n-\n-    @DontInline\n-    static FloatVector fromByteBuffer(ByteBuffer a, int i, ByteOrder bo) {\n-        return FloatVector.fromByteBuffer(SPECIES, a, i, bo);\n+    static FloatVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo) {\n+        return FloatVector.fromMemorySegment(SPECIES, a, i, bo);\n@@ -335,2 +273,2 @@\n-    static FloatVector fromByteBuffer(ByteBuffer a, int i, ByteOrder bo, VectorMask<Float> m) {\n-        return FloatVector.fromByteBuffer(SPECIES, a, i, bo, m);\n+    static FloatVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo, VectorMask<Float> m) {\n+        return FloatVector.fromMemorySegment(SPECIES, a, i, bo, m);\n@@ -340,2 +278,2 @@\n-    static void intoByteBuffer(FloatVector v, ByteBuffer a, int i, ByteOrder bo) {\n-        v.intoByteBuffer(a, i, bo);\n+    static void intoMemorySegment(FloatVector v, MemorySegment a, int i, ByteOrder bo) {\n+        v.intoMemorySegment(a, i, bo);\n@@ -345,2 +283,2 @@\n-    static void intoByteBuffer(FloatVector v, ByteBuffer a, int i, ByteOrder bo, VectorMask<Float> m) {\n-        v.intoByteBuffer(a, i, bo, m);\n+    static void intoMemorySegment(FloatVector v, MemorySegment a, int i, ByteOrder bo, VectorMask<Float> m) {\n+        v.intoMemorySegment(a, i, bo, m);\n@@ -349,1 +287,0 @@\n-\n@@ -520,6 +457,6 @@\n-    @Test(dataProvider = \"floatByteBufferProvider\")\n-    static void loadStoreByteBuffer(IntFunction<float[]> fa,\n-                                    IntFunction<ByteBuffer> fb,\n-                                    ByteOrder bo) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), fb);\n-        ByteBuffer r = fb.apply(a.limit());\n+    @Test(dataProvider = \"floatMemorySegmentProvider\")\n+    static void loadStoreMemorySegment(IntFunction<float[]> fa,\n+                                       IntFunction<MemorySegment> fb,\n+                                       ByteOrder bo) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb);\n+        MemorySegment r = fb.apply((int) a.byteSize());\n@@ -527,1 +464,1 @@\n-        int l = a.limit();\n+        int l = (int) a.byteSize();\n@@ -532,2 +469,2 @@\n-                FloatVector av = FloatVector.fromByteBuffer(SPECIES, a, i, bo);\n-                av.intoByteBuffer(r, i, bo);\n+                FloatVector av = FloatVector.fromMemorySegment(SPECIES, a, i, bo);\n+                av.intoMemorySegment(r, i, bo);\n@@ -536,5 +473,2 @@\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        Assert.assertEquals(r, a, \"Buffers not equal\");\n+        long m = r.mismatch(a);\n+        Assert.assertEquals(m, -1, \"Segments not equal\");\n@@ -544,3 +478,3 @@\n-    static void loadByteBufferIOOBE(IntFunction<float[]> fa, IntFunction<Integer> fi) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n+    static void loadMemorySegmentIOOBE(IntFunction<float[]> fa, IntFunction<Integer> fi) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n@@ -548,1 +482,1 @@\n-        int l = a.limit();\n+        int l = (int) a.byteSize();\n@@ -553,2 +487,2 @@\n-                FloatVector av = fromByteBuffer(a, i, ByteOrder.nativeOrder());\n-                av.intoByteBuffer(r, i, ByteOrder.nativeOrder());\n+                FloatVector av = fromMemorySegment(a, i, ByteOrder.nativeOrder());\n+                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n@@ -558,2 +492,2 @@\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.limit());\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());\n@@ -561,1 +495,1 @@\n-            fromByteBuffer(a, index, ByteOrder.nativeOrder());\n+            fromMemorySegment(a, index, ByteOrder.nativeOrder());\n@@ -573,3 +507,3 @@\n-    static void storeByteBufferIOOBE(IntFunction<float[]> fa, IntFunction<Integer> fi) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n+    static void storeMemorySegmentIOOBE(IntFunction<float[]> fa, IntFunction<Integer> fi) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n@@ -577,1 +511,1 @@\n-        int l = a.limit();\n+        int l = (int) a.byteSize();\n@@ -582,2 +516,2 @@\n-                FloatVector av = FloatVector.fromByteBuffer(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteBuffer(av, r, i, ByteOrder.nativeOrder());\n+                FloatVector av = FloatVector.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+                intoMemorySegment(av, r, i, ByteOrder.nativeOrder());\n@@ -587,2 +521,2 @@\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.limit());\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());\n@@ -590,2 +524,2 @@\n-            FloatVector av = FloatVector.fromByteBuffer(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteBuffer(av, r, index, ByteOrder.nativeOrder());\n+            FloatVector av = FloatVector.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+            intoMemorySegment(av, r, index, ByteOrder.nativeOrder());\n@@ -602,6 +536,5 @@\n-\n-    @Test(dataProvider = \"floatByteBufferMaskProvider\")\n-    static void loadStoreByteBufferMask(IntFunction<float[]> fa,\n-                                        IntFunction<ByteBuffer> fb,\n-                                        IntFunction<boolean[]> fm,\n-                                        ByteOrder bo) {\n+    @Test(dataProvider = \"floatMemorySegmentMaskProvider\")\n+    static void loadStoreMemorySegmentMask(IntFunction<float[]> fa,\n+                                           IntFunction<MemorySegment> fb,\n+                                           IntFunction<boolean[]> fm,\n+                                           ByteOrder bo) {\n@@ -609,2 +542,2 @@\n-        ByteBuffer a = toBuffer(_a, fb);\n-        ByteBuffer r = fb.apply(a.limit());\n+        MemorySegment a = toSegment(_a, fb);\n+        MemorySegment r = fb.apply((int) a.byteSize());\n@@ -614,1 +547,1 @@\n-        int l = a.limit();\n+        int l = (int) a.byteSize();\n@@ -619,2 +552,2 @@\n-                FloatVector av = FloatVector.fromByteBuffer(SPECIES, a, i, bo, vmask);\n-                av.intoByteBuffer(r, i, bo);\n+                FloatVector av = FloatVector.fromMemorySegment(SPECIES, a, i, bo, vmask);\n+                av.intoMemorySegment(r, i, bo);\n@@ -623,5 +556,1 @@\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        assertArraysEquals(bufferToArray(r), _a, mask);\n+        assertArraysEquals(segmentToArray(r), _a, mask);\n@@ -630,1 +559,1 @@\n-        r = fb.apply(a.limit());\n+        r = fb.apply((int) a.byteSize());\n@@ -634,2 +563,2 @@\n-                FloatVector av = FloatVector.fromByteBuffer(SPECIES, a, i, bo);\n-                av.intoByteBuffer(r, i, bo, vmask);\n+                FloatVector av = FloatVector.fromMemorySegment(SPECIES, a, i, bo);\n+                av.intoMemorySegment(r, i, bo, vmask);\n@@ -638,5 +567,1 @@\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        assertArraysEquals(bufferToArray(r), _a, mask);\n+        assertArraysEquals(segmentToArray(r), _a, mask);\n@@ -646,3 +571,3 @@\n-    static void loadByteBufferMaskIOOBE(IntFunction<float[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n+    static void loadMemorySegmentMaskIOOBE(IntFunction<float[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n@@ -652,1 +577,1 @@\n-        int l = a.limit();\n+        int l = (int) a.byteSize();\n@@ -657,2 +582,2 @@\n-                FloatVector av = fromByteBuffer(a, i, ByteOrder.nativeOrder(), vmask);\n-                av.intoByteBuffer(r, i, ByteOrder.nativeOrder());\n+                FloatVector av = fromMemorySegment(a, i, ByteOrder.nativeOrder(), vmask);\n+                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n@@ -662,2 +587,2 @@\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.limit(), SPECIES.elementSize() \/ 8);\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() \/ 8);\n@@ -665,1 +590,1 @@\n-            fromByteBuffer(a, index, ByteOrder.nativeOrder(), vmask);\n+            fromMemorySegment(a, index, ByteOrder.nativeOrder(), vmask);\n@@ -677,3 +602,3 @@\n-    static void storeByteBufferMaskIOOBE(IntFunction<float[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n+    static void storeMemorySegmentMaskIOOBE(IntFunction<float[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n@@ -683,83 +608,1 @@\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                FloatVector av = FloatVector.fromByteBuffer(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteBuffer(av, r, i, ByteOrder.nativeOrder(), vmask);\n-            }\n-        }\n-\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.limit(), SPECIES.elementSize() \/ 8);\n-        try {\n-            FloatVector av = FloatVector.fromByteBuffer(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteBuffer(av, a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"floatByteBufferProvider\")\n-    static void loadStoreReadonlyByteBuffer(IntFunction<float[]> fa,\n-                                    IntFunction<ByteBuffer> fb,\n-                                    ByteOrder bo) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), fb).asReadOnlyBuffer();\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo);\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, SPECIES.maskAll(true));\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, SPECIES.maskAll(false));\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            VectorMask<Float> m = SPECIES.shuffleFromOp(i -> i % 2 == 0 ? 1 : -1)\n-                    .laneIsValid();\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, m);\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"floatByteArrayProvider\")\n-    static void loadStoreByteArray(IntFunction<float[]> fa,\n-                                    ByteOrder bo) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, bo);\n-        byte[] r = new byte[a.length];\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                FloatVector av = FloatVector.fromByteArray(SPECIES, a, i, bo);\n-                av.intoByteArray(r, i, bo);\n-            }\n-        }\n-        Assert.assertEquals(r, a, \"Byte arrays not equal\");\n-    }\n-\n-    @Test(dataProvider = \"floatByteProviderForIOOBE\")\n-    static void loadByteArrayIOOBE(IntFunction<float[]> fa, IntFunction<Integer> fi) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-\n+        int l = (int) a.byteSize();\n@@ -767,1 +610,0 @@\n-        int l = a.length;\n@@ -771,2 +613,2 @@\n-                FloatVector av = fromByteArray(a, i, ByteOrder.nativeOrder());\n-                av.intoByteArray(r, i, ByteOrder.nativeOrder());\n+                FloatVector av = FloatVector.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+                intoMemorySegment(av, r, i, ByteOrder.nativeOrder(), vmask);\n@@ -776,2 +618,2 @@\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.length);\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() \/ 8);\n@@ -779,1 +621,2 @@\n-            fromByteArray(a, index, ByteOrder.nativeOrder());\n+            FloatVector av = FloatVector.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+            intoMemorySegment(av, a, index, ByteOrder.nativeOrder(), vmask);\n@@ -790,62 +633,5 @@\n-    @Test(dataProvider = \"floatByteProviderForIOOBE\")\n-    static void storeByteArrayIOOBE(IntFunction<float[]> fa, IntFunction<Integer> fi) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                FloatVector av = FloatVector.fromByteArray(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteArray(av, r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.length);\n-        try {\n-            FloatVector av = FloatVector.fromByteArray(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteArray(av, r, index, ByteOrder.nativeOrder());\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"floatByteArrayMaskProvider\")\n-    static void loadStoreByteArrayMask(IntFunction<float[]> fa,\n-                                  IntFunction<boolean[]> fm,\n-                                  ByteOrder bo) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, bo);\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Float> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-          for (int i = 0; i < l; i += s) {\n-              FloatVector av = FloatVector.fromByteArray(SPECIES, a, i, bo, vmask);\n-              av.intoByteArray(r, i, bo);\n-          }\n-        }\n-        assertArraysEquals(r, a, mask);\n-\n-\n-        r = new byte[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                FloatVector av = FloatVector.fromByteArray(SPECIES, a, i, bo);\n-                av.intoByteArray(r, i, bo, vmask);\n-            }\n-        }\n-        assertArraysEquals(r, a, mask);\n-    }\n+    @Test(dataProvider = \"floatMemorySegmentProvider\")\n+    static void loadStoreReadonlyMemorySegment(IntFunction<float[]> fa,\n+                                               IntFunction<MemorySegment> fb,\n+                                               ByteOrder bo) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb).asReadOnly();\n@@ -853,6 +639,4 @@\n-    @Test(dataProvider = \"floatByteMaskProviderForIOOBE\")\n-    static void loadByteArrayMaskIOOBE(IntFunction<float[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Float> vmask = VectorMask.fromValues(SPECIES, mask);\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo)\n+        );\n@@ -860,2 +644,4 @@\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(true))\n+        );\n@@ -863,6 +649,4 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                FloatVector av = fromByteArray(a, i, ByteOrder.nativeOrder(), vmask);\n-                av.intoByteArray(r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(false))\n+        );\n@@ -870,12 +654,6 @@\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length, SPECIES.elementSize() \/ 8);\n-        try {\n-            fromByteArray(a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n+        VectorMask<Float> m = SPECIES.shuffleFromOp(i -> i % 2 == 0 ? 1 : -1)\n+                .laneIsValid();\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, m)\n+        );\n@@ -884,31 +662,0 @@\n-    @Test(dataProvider = \"floatByteMaskProviderForIOOBE\")\n-    static void storeByteArrayMaskIOOBE(IntFunction<float[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Float> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                FloatVector av = FloatVector.fromByteArray(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteArray(av, r, i, ByteOrder.nativeOrder(), vmask);\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length, SPECIES.elementSize() \/ 8);\n-        try {\n-            FloatVector av = FloatVector.fromByteArray(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteArray(av, a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n@@ -930,0 +677,1 @@\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float128VectorLoadStoreTests.java","additions":112,"deletions":364,"binary":false,"changes":476,"status":"modified"},{"patch":"@@ -63,1 +63,0 @@\n-    private static final float CONST_SHIFT = Float.SIZE \/ 2;\n@@ -264,0 +263,49 @@\n+    static void assertcompressArraysEquals(float[] r, float[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    Assert.assertEquals(r[i + k], (float)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (float)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals(float[] r, float[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        Assert.assertEquals(r[i + j], (float)0);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (float)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n@@ -1027,1 +1075,0 @@\n-\n@@ -1211,1 +1258,0 @@\n-\n@@ -1332,1 +1378,0 @@\n-\n@@ -1357,1 +1402,0 @@\n-\n@@ -1474,0 +1518,1 @@\n+\n@@ -1530,0 +1575,1 @@\n+\n@@ -1550,0 +1596,1 @@\n+\n@@ -1606,0 +1653,1 @@\n+\n@@ -1626,0 +1674,1 @@\n+\n@@ -1703,0 +1752,1 @@\n+\n@@ -1722,2 +1772,0 @@\n-\n-\n@@ -1762,2 +1810,0 @@\n-\n-\n@@ -1805,8 +1851,0 @@\n-\n-\n-\n-\n-\n-\n-\n-\n@@ -1906,1 +1944,0 @@\n-\n@@ -1921,2 +1958,0 @@\n-\n-\n@@ -1940,9 +1975,0 @@\n-\n-\n-\n-\n-\n-\n-\n-\n-\n@@ -1980,57 +2006,0 @@\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n@@ -2057,0 +2026,1 @@\n+\n@@ -2075,0 +2045,1 @@\n+\n@@ -2095,0 +2066,1 @@\n+\n@@ -2170,11 +2142,0 @@\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n@@ -2198,0 +2159,1 @@\n+\n@@ -2222,0 +2184,1 @@\n+\n@@ -2240,0 +2203,1 @@\n+\n@@ -2266,0 +2230,1 @@\n+\n@@ -2283,0 +2248,1 @@\n+\n@@ -2307,0 +2273,1 @@\n+\n@@ -2325,0 +2292,1 @@\n+\n@@ -2351,0 +2319,1 @@\n+\n@@ -2368,0 +2337,1 @@\n+\n@@ -2392,0 +2362,1 @@\n+\n@@ -2410,0 +2381,1 @@\n+\n@@ -2436,0 +2408,1 @@\n+\n@@ -2453,0 +2426,1 @@\n+\n@@ -2477,0 +2451,1 @@\n+\n@@ -2495,0 +2470,1 @@\n+\n@@ -2521,0 +2497,1 @@\n+\n@@ -2538,0 +2515,1 @@\n+\n@@ -2562,0 +2540,1 @@\n+\n@@ -2580,0 +2559,1 @@\n+\n@@ -2607,4 +2587,0 @@\n-\n-\n-\n-\n@@ -2628,0 +2604,1 @@\n+\n@@ -2668,0 +2645,1 @@\n+\n@@ -2750,1 +2728,0 @@\n-\n@@ -2792,1 +2769,0 @@\n-\n@@ -2834,1 +2810,0 @@\n-\n@@ -2854,1 +2829,0 @@\n-\n@@ -2897,1 +2871,0 @@\n-\n@@ -2940,1 +2913,0 @@\n-\n@@ -2960,1 +2932,0 @@\n-\n@@ -3003,1 +2974,0 @@\n-\n@@ -3046,1 +3016,0 @@\n-\n@@ -3089,1 +3058,0 @@\n-\n@@ -3132,9 +3100,0 @@\n-\n-\n-\n-\n-\n-\n-\n-\n-\n@@ -3157,1 +3116,0 @@\n-\n@@ -3194,1 +3152,0 @@\n-\n@@ -3231,1 +3188,0 @@\n-\n@@ -3268,1 +3224,0 @@\n-\n@@ -3347,0 +3302,37 @@\n+\n+    @Test(dataProvider = \"floatUnaryOpMaskProvider\")\n+    static void compressFloat128VectorTests(IntFunction<float[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.compress(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertcompressArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"floatUnaryOpMaskProvider\")\n+    static void expandFloat128VectorTests(IntFunction<float[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.expand(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertexpandArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n@@ -3517,4 +3509,0 @@\n-\n-\n-\n-\n@@ -3535,3 +3523,0 @@\n-\n-\n-\n@@ -3563,0 +3548,1 @@\n+\n@@ -3592,0 +3578,1 @@\n+\n@@ -3625,0 +3612,1 @@\n+\n@@ -3652,0 +3640,1 @@\n+\n@@ -3691,0 +3680,1 @@\n+\n@@ -3771,1 +3761,0 @@\n-\n@@ -3795,1 +3784,0 @@\n-\n@@ -3819,1 +3807,0 @@\n-\n@@ -3843,1 +3830,0 @@\n-\n@@ -3867,1 +3853,0 @@\n-\n@@ -3891,1 +3876,0 @@\n-\n@@ -3915,1 +3899,0 @@\n-\n@@ -3939,1 +3922,0 @@\n-\n@@ -3963,1 +3945,0 @@\n-\n@@ -3987,1 +3968,0 @@\n-\n@@ -4011,1 +3991,0 @@\n-\n@@ -4035,1 +4014,0 @@\n-\n@@ -4059,1 +4037,0 @@\n-\n@@ -4083,1 +4060,0 @@\n-\n@@ -4107,1 +4083,0 @@\n-\n@@ -4134,1 +4109,0 @@\n-\n@@ -4160,0 +4134,1 @@\n+\n@@ -4186,1 +4161,0 @@\n-\n@@ -4213,1 +4187,0 @@\n-\n@@ -4228,0 +4201,1 @@\n+\n@@ -4243,1 +4217,0 @@\n-\n@@ -4247,0 +4220,1 @@\n+\n@@ -4251,1 +4225,0 @@\n-\n@@ -4270,0 +4243,1 @@\n+\n@@ -4287,1 +4261,0 @@\n-\n@@ -4310,4 +4283,0 @@\n-\n-\n-\n-\n@@ -4344,1 +4313,0 @@\n-\n@@ -4383,3 +4351,0 @@\n-\n-\n-\n@@ -4400,0 +4365,1 @@\n+\n@@ -4415,1 +4381,0 @@\n-\n@@ -4434,3 +4399,0 @@\n-\n-\n-\n@@ -4549,7 +4511,0 @@\n-\n-\n-\n-\n-\n-\n-\n@@ -4564,2 +4519,0 @@\n-\n-\n@@ -4596,2 +4549,0 @@\n-\n-\n@@ -4616,1 +4567,0 @@\n-\n@@ -5018,0 +4968,17 @@\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCompressFloat128VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        int trueCount = 0;\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                trueCount = vmask.trueCount();\n+                var rmask = vmask.compress();\n+                for (int j = 0; j < SPECIES.length(); j++)  {\n+                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);\n+                }\n+            }\n+        }\n+    }\n+\n@@ -5060,0 +5027,14 @@\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeLongFloat128VectorTestsSmokeTest(int offset) {\n+        long limit = SPECIES.length() * BUFFER_REPS;\n+        for (long i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i + offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                long index = i + j + offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n@@ -5080,0 +5061,8 @@\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundLongFloat128VectorTestsSmokeTest(int _length) {\n+        long length = _length;\n+        long actualLoopBound = SPECIES.loopBound(length);\n+        long expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+    }\n+\n@@ -5142,1 +5131,0 @@\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float128VectorTests.java","additions":165,"deletions":177,"binary":false,"changes":342,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,3 @@\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.ValueLayout;\n@@ -42,2 +45,0 @@\n-import java.nio.ByteBuffer;\n-import java.nio.FloatBuffer;\n@@ -45,1 +46,0 @@\n-import java.nio.ReadOnlyBufferException;\n@@ -70,11 +70,0 @@\n-    static void assertArraysEquals(byte[] r, byte[] a, boolean[] mask) {\n-        int i = 0;\n-        try {\n-            for (; i < a.length; i++) {\n-                Assert.assertEquals(r[i], mask[(i*8\/SPECIES.elementSize()) % SPECIES.length()] ? a[i] : (byte) 0);\n-            }\n-        } catch (AssertionError e) {\n-            Assert.assertEquals(r[i], mask[(i*8\/SPECIES.elementSize()) % SPECIES.length()] ? a[i] : (byte) 0, \"at index #\" + i);\n-        }\n-    }\n-\n@@ -120,1 +109,1 @@\n-    \/\/ Relative to byte[] array.length or ByteBuffer.limit()\n+    \/\/ Relative to byte[] array.length or MemorySegment.byteSize()\n@@ -191,1 +180,1 @@\n-    public Object[][] floatByteBufferProvider() {\n+    public Object[][] floatMemorySegmentProvider() {\n@@ -193,1 +182,1 @@\n-                flatMap(fa -> BYTE_BUFFER_GENERATORS.stream().\n+                flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n@@ -201,1 +190,1 @@\n-    public Object[][] floatByteBufferMaskProvider() {\n+    public Object[][] floatMemorySegmentMaskProvider() {\n@@ -204,1 +193,1 @@\n-                        flatMap(fa -> BYTE_BUFFER_GENERATORS.stream().\n+                        flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n@@ -211,19 +200,0 @@\n-    @DataProvider\n-    public Object[][] floatByteArrayProvider() {\n-        return FLOAT_GENERATORS.stream().\n-                flatMap(fa -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                    return new Object[]{fa, bo};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] floatByteArrayMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> FLOAT_GENERATORS.stream().\n-                    flatMap(fa -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                        return new Object[]{fa, fm, bo};\n-                    }))).\n-                toArray(Object[][]::new);\n-    }\n-\n@@ -249,4 +219,4 @@\n-    static ByteBuffer toBuffer(float[] a, IntFunction<ByteBuffer> fb) {\n-        ByteBuffer bb = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n-        for (float v : a) {\n-            bb.putFloat(v);\n+    static MemorySegment toSegment(float[] a, IntFunction<MemorySegment> fb) {\n+        MemorySegment ms = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n+        for (int i = 0; i < a.length; i++) {\n+            ms.set(ValueLayout.JAVA_FLOAT, i * SPECIES.elementSize() \/ 8 , a[i]);\n@@ -254,1 +224,1 @@\n-        return bb.clear();\n+        return ms;\n@@ -257,14 +227,2 @@\n-    static float[] bufferToArray(ByteBuffer bb) {\n-        FloatBuffer db = bb.asFloatBuffer();\n-        float[] d = new float[db.capacity()];\n-        db.get(0, d);\n-        return d;\n-    }\n-\n-    static byte[] toByteArray(float[] a, IntFunction<byte[]> fb, ByteOrder bo) {\n-        byte[] b = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n-        FloatBuffer bb = ByteBuffer.wrap(b, 0, b.length).order(bo).asFloatBuffer();\n-        for (float v : a) {\n-            bb.put(v);\n-        }\n-        return b;\n+    static float[] segmentToArray(MemorySegment ms) {\n+        return ms.toArray(ValueLayout.JAVA_FLOAT);\n@@ -310,22 +268,2 @@\n-    static FloatVector fromByteArray(byte[] a, int i, ByteOrder bo) {\n-        return FloatVector.fromByteArray(SPECIES, a, i, bo);\n-    }\n-\n-    @DontInline\n-    static FloatVector fromByteArray(byte[] a, int i, ByteOrder bo, VectorMask<Float> m) {\n-        return FloatVector.fromByteArray(SPECIES, a, i, bo, m);\n-    }\n-\n-    @DontInline\n-    static void intoByteArray(FloatVector v, byte[] a, int i, ByteOrder bo) {\n-        v.intoByteArray(a, i, bo);\n-    }\n-\n-    @DontInline\n-    static void intoByteArray(FloatVector v, byte[] a, int i, ByteOrder bo, VectorMask<Float> m) {\n-        v.intoByteArray(a, i, bo, m);\n-    }\n-\n-    @DontInline\n-    static FloatVector fromByteBuffer(ByteBuffer a, int i, ByteOrder bo) {\n-        return FloatVector.fromByteBuffer(SPECIES, a, i, bo);\n+    static FloatVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo) {\n+        return FloatVector.fromMemorySegment(SPECIES, a, i, bo);\n@@ -335,2 +273,2 @@\n-    static FloatVector fromByteBuffer(ByteBuffer a, int i, ByteOrder bo, VectorMask<Float> m) {\n-        return FloatVector.fromByteBuffer(SPECIES, a, i, bo, m);\n+    static FloatVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo, VectorMask<Float> m) {\n+        return FloatVector.fromMemorySegment(SPECIES, a, i, bo, m);\n@@ -340,2 +278,2 @@\n-    static void intoByteBuffer(FloatVector v, ByteBuffer a, int i, ByteOrder bo) {\n-        v.intoByteBuffer(a, i, bo);\n+    static void intoMemorySegment(FloatVector v, MemorySegment a, int i, ByteOrder bo) {\n+        v.intoMemorySegment(a, i, bo);\n@@ -345,2 +283,2 @@\n-    static void intoByteBuffer(FloatVector v, ByteBuffer a, int i, ByteOrder bo, VectorMask<Float> m) {\n-        v.intoByteBuffer(a, i, bo, m);\n+    static void intoMemorySegment(FloatVector v, MemorySegment a, int i, ByteOrder bo, VectorMask<Float> m) {\n+        v.intoMemorySegment(a, i, bo, m);\n@@ -349,1 +287,0 @@\n-\n@@ -520,6 +457,6 @@\n-    @Test(dataProvider = \"floatByteBufferProvider\")\n-    static void loadStoreByteBuffer(IntFunction<float[]> fa,\n-                                    IntFunction<ByteBuffer> fb,\n-                                    ByteOrder bo) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), fb);\n-        ByteBuffer r = fb.apply(a.limit());\n+    @Test(dataProvider = \"floatMemorySegmentProvider\")\n+    static void loadStoreMemorySegment(IntFunction<float[]> fa,\n+                                       IntFunction<MemorySegment> fb,\n+                                       ByteOrder bo) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb);\n+        MemorySegment r = fb.apply((int) a.byteSize());\n@@ -527,1 +464,1 @@\n-        int l = a.limit();\n+        int l = (int) a.byteSize();\n@@ -532,2 +469,2 @@\n-                FloatVector av = FloatVector.fromByteBuffer(SPECIES, a, i, bo);\n-                av.intoByteBuffer(r, i, bo);\n+                FloatVector av = FloatVector.fromMemorySegment(SPECIES, a, i, bo);\n+                av.intoMemorySegment(r, i, bo);\n@@ -536,5 +473,2 @@\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        Assert.assertEquals(r, a, \"Buffers not equal\");\n+        long m = r.mismatch(a);\n+        Assert.assertEquals(m, -1, \"Segments not equal\");\n@@ -544,3 +478,3 @@\n-    static void loadByteBufferIOOBE(IntFunction<float[]> fa, IntFunction<Integer> fi) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n+    static void loadMemorySegmentIOOBE(IntFunction<float[]> fa, IntFunction<Integer> fi) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n@@ -548,1 +482,1 @@\n-        int l = a.limit();\n+        int l = (int) a.byteSize();\n@@ -553,2 +487,2 @@\n-                FloatVector av = fromByteBuffer(a, i, ByteOrder.nativeOrder());\n-                av.intoByteBuffer(r, i, ByteOrder.nativeOrder());\n+                FloatVector av = fromMemorySegment(a, i, ByteOrder.nativeOrder());\n+                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n@@ -558,2 +492,2 @@\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.limit());\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());\n@@ -561,1 +495,1 @@\n-            fromByteBuffer(a, index, ByteOrder.nativeOrder());\n+            fromMemorySegment(a, index, ByteOrder.nativeOrder());\n@@ -573,3 +507,3 @@\n-    static void storeByteBufferIOOBE(IntFunction<float[]> fa, IntFunction<Integer> fi) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n+    static void storeMemorySegmentIOOBE(IntFunction<float[]> fa, IntFunction<Integer> fi) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n@@ -577,1 +511,1 @@\n-        int l = a.limit();\n+        int l = (int) a.byteSize();\n@@ -582,2 +516,2 @@\n-                FloatVector av = FloatVector.fromByteBuffer(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteBuffer(av, r, i, ByteOrder.nativeOrder());\n+                FloatVector av = FloatVector.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+                intoMemorySegment(av, r, i, ByteOrder.nativeOrder());\n@@ -587,2 +521,2 @@\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.limit());\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());\n@@ -590,2 +524,2 @@\n-            FloatVector av = FloatVector.fromByteBuffer(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteBuffer(av, r, index, ByteOrder.nativeOrder());\n+            FloatVector av = FloatVector.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+            intoMemorySegment(av, r, index, ByteOrder.nativeOrder());\n@@ -602,6 +536,5 @@\n-\n-    @Test(dataProvider = \"floatByteBufferMaskProvider\")\n-    static void loadStoreByteBufferMask(IntFunction<float[]> fa,\n-                                        IntFunction<ByteBuffer> fb,\n-                                        IntFunction<boolean[]> fm,\n-                                        ByteOrder bo) {\n+    @Test(dataProvider = \"floatMemorySegmentMaskProvider\")\n+    static void loadStoreMemorySegmentMask(IntFunction<float[]> fa,\n+                                           IntFunction<MemorySegment> fb,\n+                                           IntFunction<boolean[]> fm,\n+                                           ByteOrder bo) {\n@@ -609,2 +542,2 @@\n-        ByteBuffer a = toBuffer(_a, fb);\n-        ByteBuffer r = fb.apply(a.limit());\n+        MemorySegment a = toSegment(_a, fb);\n+        MemorySegment r = fb.apply((int) a.byteSize());\n@@ -614,1 +547,1 @@\n-        int l = a.limit();\n+        int l = (int) a.byteSize();\n@@ -619,2 +552,2 @@\n-                FloatVector av = FloatVector.fromByteBuffer(SPECIES, a, i, bo, vmask);\n-                av.intoByteBuffer(r, i, bo);\n+                FloatVector av = FloatVector.fromMemorySegment(SPECIES, a, i, bo, vmask);\n+                av.intoMemorySegment(r, i, bo);\n@@ -623,5 +556,1 @@\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        assertArraysEquals(bufferToArray(r), _a, mask);\n+        assertArraysEquals(segmentToArray(r), _a, mask);\n@@ -630,1 +559,1 @@\n-        r = fb.apply(a.limit());\n+        r = fb.apply((int) a.byteSize());\n@@ -634,2 +563,2 @@\n-                FloatVector av = FloatVector.fromByteBuffer(SPECIES, a, i, bo);\n-                av.intoByteBuffer(r, i, bo, vmask);\n+                FloatVector av = FloatVector.fromMemorySegment(SPECIES, a, i, bo);\n+                av.intoMemorySegment(r, i, bo, vmask);\n@@ -638,5 +567,1 @@\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        assertArraysEquals(bufferToArray(r), _a, mask);\n+        assertArraysEquals(segmentToArray(r), _a, mask);\n@@ -646,3 +571,3 @@\n-    static void loadByteBufferMaskIOOBE(IntFunction<float[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n+    static void loadMemorySegmentMaskIOOBE(IntFunction<float[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n@@ -652,1 +577,1 @@\n-        int l = a.limit();\n+        int l = (int) a.byteSize();\n@@ -657,2 +582,2 @@\n-                FloatVector av = fromByteBuffer(a, i, ByteOrder.nativeOrder(), vmask);\n-                av.intoByteBuffer(r, i, ByteOrder.nativeOrder());\n+                FloatVector av = fromMemorySegment(a, i, ByteOrder.nativeOrder(), vmask);\n+                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n@@ -662,2 +587,2 @@\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.limit(), SPECIES.elementSize() \/ 8);\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() \/ 8);\n@@ -665,1 +590,1 @@\n-            fromByteBuffer(a, index, ByteOrder.nativeOrder(), vmask);\n+            fromMemorySegment(a, index, ByteOrder.nativeOrder(), vmask);\n@@ -677,3 +602,3 @@\n-    static void storeByteBufferMaskIOOBE(IntFunction<float[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n+    static void storeMemorySegmentMaskIOOBE(IntFunction<float[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n@@ -683,83 +608,1 @@\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                FloatVector av = FloatVector.fromByteBuffer(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteBuffer(av, r, i, ByteOrder.nativeOrder(), vmask);\n-            }\n-        }\n-\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.limit(), SPECIES.elementSize() \/ 8);\n-        try {\n-            FloatVector av = FloatVector.fromByteBuffer(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteBuffer(av, a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"floatByteBufferProvider\")\n-    static void loadStoreReadonlyByteBuffer(IntFunction<float[]> fa,\n-                                    IntFunction<ByteBuffer> fb,\n-                                    ByteOrder bo) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), fb).asReadOnlyBuffer();\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo);\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, SPECIES.maskAll(true));\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, SPECIES.maskAll(false));\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            VectorMask<Float> m = SPECIES.shuffleFromOp(i -> i % 2 == 0 ? 1 : -1)\n-                    .laneIsValid();\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, m);\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"floatByteArrayProvider\")\n-    static void loadStoreByteArray(IntFunction<float[]> fa,\n-                                    ByteOrder bo) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, bo);\n-        byte[] r = new byte[a.length];\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                FloatVector av = FloatVector.fromByteArray(SPECIES, a, i, bo);\n-                av.intoByteArray(r, i, bo);\n-            }\n-        }\n-        Assert.assertEquals(r, a, \"Byte arrays not equal\");\n-    }\n-\n-    @Test(dataProvider = \"floatByteProviderForIOOBE\")\n-    static void loadByteArrayIOOBE(IntFunction<float[]> fa, IntFunction<Integer> fi) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-\n+        int l = (int) a.byteSize();\n@@ -767,1 +610,0 @@\n-        int l = a.length;\n@@ -771,2 +613,2 @@\n-                FloatVector av = fromByteArray(a, i, ByteOrder.nativeOrder());\n-                av.intoByteArray(r, i, ByteOrder.nativeOrder());\n+                FloatVector av = FloatVector.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+                intoMemorySegment(av, r, i, ByteOrder.nativeOrder(), vmask);\n@@ -776,2 +618,2 @@\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.length);\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() \/ 8);\n@@ -779,1 +621,2 @@\n-            fromByteArray(a, index, ByteOrder.nativeOrder());\n+            FloatVector av = FloatVector.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+            intoMemorySegment(av, a, index, ByteOrder.nativeOrder(), vmask);\n@@ -790,62 +633,5 @@\n-    @Test(dataProvider = \"floatByteProviderForIOOBE\")\n-    static void storeByteArrayIOOBE(IntFunction<float[]> fa, IntFunction<Integer> fi) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                FloatVector av = FloatVector.fromByteArray(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteArray(av, r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.length);\n-        try {\n-            FloatVector av = FloatVector.fromByteArray(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteArray(av, r, index, ByteOrder.nativeOrder());\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"floatByteArrayMaskProvider\")\n-    static void loadStoreByteArrayMask(IntFunction<float[]> fa,\n-                                  IntFunction<boolean[]> fm,\n-                                  ByteOrder bo) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, bo);\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Float> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-          for (int i = 0; i < l; i += s) {\n-              FloatVector av = FloatVector.fromByteArray(SPECIES, a, i, bo, vmask);\n-              av.intoByteArray(r, i, bo);\n-          }\n-        }\n-        assertArraysEquals(r, a, mask);\n-\n-\n-        r = new byte[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                FloatVector av = FloatVector.fromByteArray(SPECIES, a, i, bo);\n-                av.intoByteArray(r, i, bo, vmask);\n-            }\n-        }\n-        assertArraysEquals(r, a, mask);\n-    }\n+    @Test(dataProvider = \"floatMemorySegmentProvider\")\n+    static void loadStoreReadonlyMemorySegment(IntFunction<float[]> fa,\n+                                               IntFunction<MemorySegment> fb,\n+                                               ByteOrder bo) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb).asReadOnly();\n@@ -853,6 +639,4 @@\n-    @Test(dataProvider = \"floatByteMaskProviderForIOOBE\")\n-    static void loadByteArrayMaskIOOBE(IntFunction<float[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Float> vmask = VectorMask.fromValues(SPECIES, mask);\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo)\n+        );\n@@ -860,2 +644,4 @@\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(true))\n+        );\n@@ -863,6 +649,4 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                FloatVector av = fromByteArray(a, i, ByteOrder.nativeOrder(), vmask);\n-                av.intoByteArray(r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(false))\n+        );\n@@ -870,12 +654,6 @@\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length, SPECIES.elementSize() \/ 8);\n-        try {\n-            fromByteArray(a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n+        VectorMask<Float> m = SPECIES.shuffleFromOp(i -> i % 2 == 0 ? 1 : -1)\n+                .laneIsValid();\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, m)\n+        );\n@@ -884,31 +662,0 @@\n-    @Test(dataProvider = \"floatByteMaskProviderForIOOBE\")\n-    static void storeByteArrayMaskIOOBE(IntFunction<float[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Float> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                FloatVector av = FloatVector.fromByteArray(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteArray(av, r, i, ByteOrder.nativeOrder(), vmask);\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length, SPECIES.elementSize() \/ 8);\n-        try {\n-            FloatVector av = FloatVector.fromByteArray(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteArray(av, a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n@@ -930,0 +677,1 @@\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float256VectorLoadStoreTests.java","additions":112,"deletions":364,"binary":false,"changes":476,"status":"modified"},{"patch":"@@ -63,1 +63,0 @@\n-    private static final float CONST_SHIFT = Float.SIZE \/ 2;\n@@ -264,0 +263,49 @@\n+    static void assertcompressArraysEquals(float[] r, float[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    Assert.assertEquals(r[i + k], (float)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (float)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals(float[] r, float[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        Assert.assertEquals(r[i + j], (float)0);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (float)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n@@ -1027,1 +1075,0 @@\n-\n@@ -1211,1 +1258,0 @@\n-\n@@ -1332,1 +1378,0 @@\n-\n@@ -1357,1 +1402,0 @@\n-\n@@ -1474,0 +1518,1 @@\n+\n@@ -1530,0 +1575,1 @@\n+\n@@ -1550,0 +1596,1 @@\n+\n@@ -1606,0 +1653,1 @@\n+\n@@ -1626,0 +1674,1 @@\n+\n@@ -1703,0 +1752,1 @@\n+\n@@ -1722,2 +1772,0 @@\n-\n-\n@@ -1762,2 +1810,0 @@\n-\n-\n@@ -1805,8 +1851,0 @@\n-\n-\n-\n-\n-\n-\n-\n-\n@@ -1906,1 +1944,0 @@\n-\n@@ -1921,2 +1958,0 @@\n-\n-\n@@ -1940,9 +1975,0 @@\n-\n-\n-\n-\n-\n-\n-\n-\n-\n@@ -1980,57 +2006,0 @@\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n@@ -2057,0 +2026,1 @@\n+\n@@ -2075,0 +2045,1 @@\n+\n@@ -2095,0 +2066,1 @@\n+\n@@ -2170,11 +2142,0 @@\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n@@ -2198,0 +2159,1 @@\n+\n@@ -2222,0 +2184,1 @@\n+\n@@ -2240,0 +2203,1 @@\n+\n@@ -2266,0 +2230,1 @@\n+\n@@ -2283,0 +2248,1 @@\n+\n@@ -2307,0 +2273,1 @@\n+\n@@ -2325,0 +2292,1 @@\n+\n@@ -2351,0 +2319,1 @@\n+\n@@ -2368,0 +2337,1 @@\n+\n@@ -2392,0 +2362,1 @@\n+\n@@ -2410,0 +2381,1 @@\n+\n@@ -2436,0 +2408,1 @@\n+\n@@ -2453,0 +2426,1 @@\n+\n@@ -2477,0 +2451,1 @@\n+\n@@ -2495,0 +2470,1 @@\n+\n@@ -2521,0 +2497,1 @@\n+\n@@ -2538,0 +2515,1 @@\n+\n@@ -2562,0 +2540,1 @@\n+\n@@ -2580,0 +2559,1 @@\n+\n@@ -2607,4 +2587,0 @@\n-\n-\n-\n-\n@@ -2628,0 +2604,1 @@\n+\n@@ -2668,0 +2645,1 @@\n+\n@@ -2750,1 +2728,0 @@\n-\n@@ -2792,1 +2769,0 @@\n-\n@@ -2834,1 +2810,0 @@\n-\n@@ -2854,1 +2829,0 @@\n-\n@@ -2897,1 +2871,0 @@\n-\n@@ -2940,1 +2913,0 @@\n-\n@@ -2960,1 +2932,0 @@\n-\n@@ -3003,1 +2974,0 @@\n-\n@@ -3046,1 +3016,0 @@\n-\n@@ -3089,1 +3058,0 @@\n-\n@@ -3132,9 +3100,0 @@\n-\n-\n-\n-\n-\n-\n-\n-\n-\n@@ -3157,1 +3116,0 @@\n-\n@@ -3194,1 +3152,0 @@\n-\n@@ -3231,1 +3188,0 @@\n-\n@@ -3268,1 +3224,0 @@\n-\n@@ -3347,0 +3302,37 @@\n+\n+    @Test(dataProvider = \"floatUnaryOpMaskProvider\")\n+    static void compressFloat256VectorTests(IntFunction<float[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.compress(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertcompressArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"floatUnaryOpMaskProvider\")\n+    static void expandFloat256VectorTests(IntFunction<float[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.expand(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertexpandArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n@@ -3517,4 +3509,0 @@\n-\n-\n-\n-\n@@ -3535,3 +3523,0 @@\n-\n-\n-\n@@ -3563,0 +3548,1 @@\n+\n@@ -3592,0 +3578,1 @@\n+\n@@ -3625,0 +3612,1 @@\n+\n@@ -3652,0 +3640,1 @@\n+\n@@ -3691,0 +3680,1 @@\n+\n@@ -3771,1 +3761,0 @@\n-\n@@ -3795,1 +3784,0 @@\n-\n@@ -3819,1 +3807,0 @@\n-\n@@ -3843,1 +3830,0 @@\n-\n@@ -3867,1 +3853,0 @@\n-\n@@ -3891,1 +3876,0 @@\n-\n@@ -3915,1 +3899,0 @@\n-\n@@ -3939,1 +3922,0 @@\n-\n@@ -3963,1 +3945,0 @@\n-\n@@ -3987,1 +3968,0 @@\n-\n@@ -4011,1 +3991,0 @@\n-\n@@ -4035,1 +4014,0 @@\n-\n@@ -4059,1 +4037,0 @@\n-\n@@ -4083,1 +4060,0 @@\n-\n@@ -4107,1 +4083,0 @@\n-\n@@ -4134,1 +4109,0 @@\n-\n@@ -4160,0 +4134,1 @@\n+\n@@ -4186,1 +4161,0 @@\n-\n@@ -4213,1 +4187,0 @@\n-\n@@ -4228,0 +4201,1 @@\n+\n@@ -4243,1 +4217,0 @@\n-\n@@ -4247,0 +4220,1 @@\n+\n@@ -4251,1 +4225,0 @@\n-\n@@ -4270,0 +4243,1 @@\n+\n@@ -4287,1 +4261,0 @@\n-\n@@ -4310,4 +4283,0 @@\n-\n-\n-\n-\n@@ -4344,1 +4313,0 @@\n-\n@@ -4383,3 +4351,0 @@\n-\n-\n-\n@@ -4400,0 +4365,1 @@\n+\n@@ -4415,1 +4381,0 @@\n-\n@@ -4434,3 +4399,0 @@\n-\n-\n-\n@@ -4549,7 +4511,0 @@\n-\n-\n-\n-\n-\n-\n-\n@@ -4564,2 +4519,0 @@\n-\n-\n@@ -4596,2 +4549,0 @@\n-\n-\n@@ -4616,1 +4567,0 @@\n-\n@@ -5018,0 +4968,17 @@\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCompressFloat256VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        int trueCount = 0;\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                trueCount = vmask.trueCount();\n+                var rmask = vmask.compress();\n+                for (int j = 0; j < SPECIES.length(); j++)  {\n+                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);\n+                }\n+            }\n+        }\n+    }\n+\n@@ -5060,0 +5027,14 @@\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeLongFloat256VectorTestsSmokeTest(int offset) {\n+        long limit = SPECIES.length() * BUFFER_REPS;\n+        for (long i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i + offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                long index = i + j + offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n@@ -5080,0 +5061,8 @@\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundLongFloat256VectorTestsSmokeTest(int _length) {\n+        long length = _length;\n+        long actualLoopBound = SPECIES.loopBound(length);\n+        long expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+    }\n+\n@@ -5142,1 +5131,0 @@\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float256VectorTests.java","additions":165,"deletions":177,"binary":false,"changes":342,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,3 @@\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.ValueLayout;\n@@ -42,2 +45,0 @@\n-import java.nio.ByteBuffer;\n-import java.nio.FloatBuffer;\n@@ -45,1 +46,0 @@\n-import java.nio.ReadOnlyBufferException;\n@@ -70,11 +70,0 @@\n-    static void assertArraysEquals(byte[] r, byte[] a, boolean[] mask) {\n-        int i = 0;\n-        try {\n-            for (; i < a.length; i++) {\n-                Assert.assertEquals(r[i], mask[(i*8\/SPECIES.elementSize()) % SPECIES.length()] ? a[i] : (byte) 0);\n-            }\n-        } catch (AssertionError e) {\n-            Assert.assertEquals(r[i], mask[(i*8\/SPECIES.elementSize()) % SPECIES.length()] ? a[i] : (byte) 0, \"at index #\" + i);\n-        }\n-    }\n-\n@@ -120,1 +109,1 @@\n-    \/\/ Relative to byte[] array.length or ByteBuffer.limit()\n+    \/\/ Relative to byte[] array.length or MemorySegment.byteSize()\n@@ -191,1 +180,1 @@\n-    public Object[][] floatByteBufferProvider() {\n+    public Object[][] floatMemorySegmentProvider() {\n@@ -193,1 +182,1 @@\n-                flatMap(fa -> BYTE_BUFFER_GENERATORS.stream().\n+                flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n@@ -201,1 +190,1 @@\n-    public Object[][] floatByteBufferMaskProvider() {\n+    public Object[][] floatMemorySegmentMaskProvider() {\n@@ -204,1 +193,1 @@\n-                        flatMap(fa -> BYTE_BUFFER_GENERATORS.stream().\n+                        flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n@@ -211,19 +200,0 @@\n-    @DataProvider\n-    public Object[][] floatByteArrayProvider() {\n-        return FLOAT_GENERATORS.stream().\n-                flatMap(fa -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                    return new Object[]{fa, bo};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] floatByteArrayMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> FLOAT_GENERATORS.stream().\n-                    flatMap(fa -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                        return new Object[]{fa, fm, bo};\n-                    }))).\n-                toArray(Object[][]::new);\n-    }\n-\n@@ -249,4 +219,4 @@\n-    static ByteBuffer toBuffer(float[] a, IntFunction<ByteBuffer> fb) {\n-        ByteBuffer bb = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n-        for (float v : a) {\n-            bb.putFloat(v);\n+    static MemorySegment toSegment(float[] a, IntFunction<MemorySegment> fb) {\n+        MemorySegment ms = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n+        for (int i = 0; i < a.length; i++) {\n+            ms.set(ValueLayout.JAVA_FLOAT, i * SPECIES.elementSize() \/ 8 , a[i]);\n@@ -254,1 +224,1 @@\n-        return bb.clear();\n+        return ms;\n@@ -257,14 +227,2 @@\n-    static float[] bufferToArray(ByteBuffer bb) {\n-        FloatBuffer db = bb.asFloatBuffer();\n-        float[] d = new float[db.capacity()];\n-        db.get(0, d);\n-        return d;\n-    }\n-\n-    static byte[] toByteArray(float[] a, IntFunction<byte[]> fb, ByteOrder bo) {\n-        byte[] b = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n-        FloatBuffer bb = ByteBuffer.wrap(b, 0, b.length).order(bo).asFloatBuffer();\n-        for (float v : a) {\n-            bb.put(v);\n-        }\n-        return b;\n+    static float[] segmentToArray(MemorySegment ms) {\n+        return ms.toArray(ValueLayout.JAVA_FLOAT);\n@@ -310,22 +268,2 @@\n-    static FloatVector fromByteArray(byte[] a, int i, ByteOrder bo) {\n-        return FloatVector.fromByteArray(SPECIES, a, i, bo);\n-    }\n-\n-    @DontInline\n-    static FloatVector fromByteArray(byte[] a, int i, ByteOrder bo, VectorMask<Float> m) {\n-        return FloatVector.fromByteArray(SPECIES, a, i, bo, m);\n-    }\n-\n-    @DontInline\n-    static void intoByteArray(FloatVector v, byte[] a, int i, ByteOrder bo) {\n-        v.intoByteArray(a, i, bo);\n-    }\n-\n-    @DontInline\n-    static void intoByteArray(FloatVector v, byte[] a, int i, ByteOrder bo, VectorMask<Float> m) {\n-        v.intoByteArray(a, i, bo, m);\n-    }\n-\n-    @DontInline\n-    static FloatVector fromByteBuffer(ByteBuffer a, int i, ByteOrder bo) {\n-        return FloatVector.fromByteBuffer(SPECIES, a, i, bo);\n+    static FloatVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo) {\n+        return FloatVector.fromMemorySegment(SPECIES, a, i, bo);\n@@ -335,2 +273,2 @@\n-    static FloatVector fromByteBuffer(ByteBuffer a, int i, ByteOrder bo, VectorMask<Float> m) {\n-        return FloatVector.fromByteBuffer(SPECIES, a, i, bo, m);\n+    static FloatVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo, VectorMask<Float> m) {\n+        return FloatVector.fromMemorySegment(SPECIES, a, i, bo, m);\n@@ -340,2 +278,2 @@\n-    static void intoByteBuffer(FloatVector v, ByteBuffer a, int i, ByteOrder bo) {\n-        v.intoByteBuffer(a, i, bo);\n+    static void intoMemorySegment(FloatVector v, MemorySegment a, int i, ByteOrder bo) {\n+        v.intoMemorySegment(a, i, bo);\n@@ -345,2 +283,2 @@\n-    static void intoByteBuffer(FloatVector v, ByteBuffer a, int i, ByteOrder bo, VectorMask<Float> m) {\n-        v.intoByteBuffer(a, i, bo, m);\n+    static void intoMemorySegment(FloatVector v, MemorySegment a, int i, ByteOrder bo, VectorMask<Float> m) {\n+        v.intoMemorySegment(a, i, bo, m);\n@@ -349,1 +287,0 @@\n-\n@@ -520,6 +457,6 @@\n-    @Test(dataProvider = \"floatByteBufferProvider\")\n-    static void loadStoreByteBuffer(IntFunction<float[]> fa,\n-                                    IntFunction<ByteBuffer> fb,\n-                                    ByteOrder bo) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), fb);\n-        ByteBuffer r = fb.apply(a.limit());\n+    @Test(dataProvider = \"floatMemorySegmentProvider\")\n+    static void loadStoreMemorySegment(IntFunction<float[]> fa,\n+                                       IntFunction<MemorySegment> fb,\n+                                       ByteOrder bo) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb);\n+        MemorySegment r = fb.apply((int) a.byteSize());\n@@ -527,1 +464,1 @@\n-        int l = a.limit();\n+        int l = (int) a.byteSize();\n@@ -532,2 +469,2 @@\n-                FloatVector av = FloatVector.fromByteBuffer(SPECIES, a, i, bo);\n-                av.intoByteBuffer(r, i, bo);\n+                FloatVector av = FloatVector.fromMemorySegment(SPECIES, a, i, bo);\n+                av.intoMemorySegment(r, i, bo);\n@@ -536,5 +473,2 @@\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        Assert.assertEquals(r, a, \"Buffers not equal\");\n+        long m = r.mismatch(a);\n+        Assert.assertEquals(m, -1, \"Segments not equal\");\n@@ -544,3 +478,3 @@\n-    static void loadByteBufferIOOBE(IntFunction<float[]> fa, IntFunction<Integer> fi) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n+    static void loadMemorySegmentIOOBE(IntFunction<float[]> fa, IntFunction<Integer> fi) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n@@ -548,1 +482,1 @@\n-        int l = a.limit();\n+        int l = (int) a.byteSize();\n@@ -553,2 +487,2 @@\n-                FloatVector av = fromByteBuffer(a, i, ByteOrder.nativeOrder());\n-                av.intoByteBuffer(r, i, ByteOrder.nativeOrder());\n+                FloatVector av = fromMemorySegment(a, i, ByteOrder.nativeOrder());\n+                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n@@ -558,2 +492,2 @@\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.limit());\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());\n@@ -561,1 +495,1 @@\n-            fromByteBuffer(a, index, ByteOrder.nativeOrder());\n+            fromMemorySegment(a, index, ByteOrder.nativeOrder());\n@@ -573,3 +507,3 @@\n-    static void storeByteBufferIOOBE(IntFunction<float[]> fa, IntFunction<Integer> fi) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n+    static void storeMemorySegmentIOOBE(IntFunction<float[]> fa, IntFunction<Integer> fi) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n@@ -577,1 +511,1 @@\n-        int l = a.limit();\n+        int l = (int) a.byteSize();\n@@ -582,2 +516,2 @@\n-                FloatVector av = FloatVector.fromByteBuffer(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteBuffer(av, r, i, ByteOrder.nativeOrder());\n+                FloatVector av = FloatVector.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+                intoMemorySegment(av, r, i, ByteOrder.nativeOrder());\n@@ -587,2 +521,2 @@\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.limit());\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());\n@@ -590,2 +524,2 @@\n-            FloatVector av = FloatVector.fromByteBuffer(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteBuffer(av, r, index, ByteOrder.nativeOrder());\n+            FloatVector av = FloatVector.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+            intoMemorySegment(av, r, index, ByteOrder.nativeOrder());\n@@ -602,6 +536,5 @@\n-\n-    @Test(dataProvider = \"floatByteBufferMaskProvider\")\n-    static void loadStoreByteBufferMask(IntFunction<float[]> fa,\n-                                        IntFunction<ByteBuffer> fb,\n-                                        IntFunction<boolean[]> fm,\n-                                        ByteOrder bo) {\n+    @Test(dataProvider = \"floatMemorySegmentMaskProvider\")\n+    static void loadStoreMemorySegmentMask(IntFunction<float[]> fa,\n+                                           IntFunction<MemorySegment> fb,\n+                                           IntFunction<boolean[]> fm,\n+                                           ByteOrder bo) {\n@@ -609,2 +542,2 @@\n-        ByteBuffer a = toBuffer(_a, fb);\n-        ByteBuffer r = fb.apply(a.limit());\n+        MemorySegment a = toSegment(_a, fb);\n+        MemorySegment r = fb.apply((int) a.byteSize());\n@@ -614,1 +547,1 @@\n-        int l = a.limit();\n+        int l = (int) a.byteSize();\n@@ -619,2 +552,2 @@\n-                FloatVector av = FloatVector.fromByteBuffer(SPECIES, a, i, bo, vmask);\n-                av.intoByteBuffer(r, i, bo);\n+                FloatVector av = FloatVector.fromMemorySegment(SPECIES, a, i, bo, vmask);\n+                av.intoMemorySegment(r, i, bo);\n@@ -623,5 +556,1 @@\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        assertArraysEquals(bufferToArray(r), _a, mask);\n+        assertArraysEquals(segmentToArray(r), _a, mask);\n@@ -630,1 +559,1 @@\n-        r = fb.apply(a.limit());\n+        r = fb.apply((int) a.byteSize());\n@@ -634,2 +563,2 @@\n-                FloatVector av = FloatVector.fromByteBuffer(SPECIES, a, i, bo);\n-                av.intoByteBuffer(r, i, bo, vmask);\n+                FloatVector av = FloatVector.fromMemorySegment(SPECIES, a, i, bo);\n+                av.intoMemorySegment(r, i, bo, vmask);\n@@ -638,5 +567,1 @@\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        assertArraysEquals(bufferToArray(r), _a, mask);\n+        assertArraysEquals(segmentToArray(r), _a, mask);\n@@ -646,3 +571,3 @@\n-    static void loadByteBufferMaskIOOBE(IntFunction<float[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n+    static void loadMemorySegmentMaskIOOBE(IntFunction<float[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n@@ -652,1 +577,1 @@\n-        int l = a.limit();\n+        int l = (int) a.byteSize();\n@@ -657,2 +582,2 @@\n-                FloatVector av = fromByteBuffer(a, i, ByteOrder.nativeOrder(), vmask);\n-                av.intoByteBuffer(r, i, ByteOrder.nativeOrder());\n+                FloatVector av = fromMemorySegment(a, i, ByteOrder.nativeOrder(), vmask);\n+                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n@@ -662,2 +587,2 @@\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.limit(), SPECIES.elementSize() \/ 8);\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() \/ 8);\n@@ -665,1 +590,1 @@\n-            fromByteBuffer(a, index, ByteOrder.nativeOrder(), vmask);\n+            fromMemorySegment(a, index, ByteOrder.nativeOrder(), vmask);\n@@ -677,3 +602,3 @@\n-    static void storeByteBufferMaskIOOBE(IntFunction<float[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n+    static void storeMemorySegmentMaskIOOBE(IntFunction<float[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n@@ -683,83 +608,1 @@\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                FloatVector av = FloatVector.fromByteBuffer(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteBuffer(av, r, i, ByteOrder.nativeOrder(), vmask);\n-            }\n-        }\n-\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.limit(), SPECIES.elementSize() \/ 8);\n-        try {\n-            FloatVector av = FloatVector.fromByteBuffer(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteBuffer(av, a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"floatByteBufferProvider\")\n-    static void loadStoreReadonlyByteBuffer(IntFunction<float[]> fa,\n-                                    IntFunction<ByteBuffer> fb,\n-                                    ByteOrder bo) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), fb).asReadOnlyBuffer();\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo);\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, SPECIES.maskAll(true));\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, SPECIES.maskAll(false));\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            VectorMask<Float> m = SPECIES.shuffleFromOp(i -> i % 2 == 0 ? 1 : -1)\n-                    .laneIsValid();\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, m);\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"floatByteArrayProvider\")\n-    static void loadStoreByteArray(IntFunction<float[]> fa,\n-                                    ByteOrder bo) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, bo);\n-        byte[] r = new byte[a.length];\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                FloatVector av = FloatVector.fromByteArray(SPECIES, a, i, bo);\n-                av.intoByteArray(r, i, bo);\n-            }\n-        }\n-        Assert.assertEquals(r, a, \"Byte arrays not equal\");\n-    }\n-\n-    @Test(dataProvider = \"floatByteProviderForIOOBE\")\n-    static void loadByteArrayIOOBE(IntFunction<float[]> fa, IntFunction<Integer> fi) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-\n+        int l = (int) a.byteSize();\n@@ -767,1 +610,0 @@\n-        int l = a.length;\n@@ -771,2 +613,2 @@\n-                FloatVector av = fromByteArray(a, i, ByteOrder.nativeOrder());\n-                av.intoByteArray(r, i, ByteOrder.nativeOrder());\n+                FloatVector av = FloatVector.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+                intoMemorySegment(av, r, i, ByteOrder.nativeOrder(), vmask);\n@@ -776,2 +618,2 @@\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.length);\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() \/ 8);\n@@ -779,1 +621,2 @@\n-            fromByteArray(a, index, ByteOrder.nativeOrder());\n+            FloatVector av = FloatVector.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+            intoMemorySegment(av, a, index, ByteOrder.nativeOrder(), vmask);\n@@ -790,62 +633,5 @@\n-    @Test(dataProvider = \"floatByteProviderForIOOBE\")\n-    static void storeByteArrayIOOBE(IntFunction<float[]> fa, IntFunction<Integer> fi) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                FloatVector av = FloatVector.fromByteArray(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteArray(av, r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.length);\n-        try {\n-            FloatVector av = FloatVector.fromByteArray(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteArray(av, r, index, ByteOrder.nativeOrder());\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"floatByteArrayMaskProvider\")\n-    static void loadStoreByteArrayMask(IntFunction<float[]> fa,\n-                                  IntFunction<boolean[]> fm,\n-                                  ByteOrder bo) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, bo);\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Float> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-          for (int i = 0; i < l; i += s) {\n-              FloatVector av = FloatVector.fromByteArray(SPECIES, a, i, bo, vmask);\n-              av.intoByteArray(r, i, bo);\n-          }\n-        }\n-        assertArraysEquals(r, a, mask);\n-\n-\n-        r = new byte[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                FloatVector av = FloatVector.fromByteArray(SPECIES, a, i, bo);\n-                av.intoByteArray(r, i, bo, vmask);\n-            }\n-        }\n-        assertArraysEquals(r, a, mask);\n-    }\n+    @Test(dataProvider = \"floatMemorySegmentProvider\")\n+    static void loadStoreReadonlyMemorySegment(IntFunction<float[]> fa,\n+                                               IntFunction<MemorySegment> fb,\n+                                               ByteOrder bo) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb).asReadOnly();\n@@ -853,6 +639,4 @@\n-    @Test(dataProvider = \"floatByteMaskProviderForIOOBE\")\n-    static void loadByteArrayMaskIOOBE(IntFunction<float[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Float> vmask = VectorMask.fromValues(SPECIES, mask);\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo)\n+        );\n@@ -860,2 +644,4 @@\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(true))\n+        );\n@@ -863,6 +649,4 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                FloatVector av = fromByteArray(a, i, ByteOrder.nativeOrder(), vmask);\n-                av.intoByteArray(r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(false))\n+        );\n@@ -870,12 +654,6 @@\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length, SPECIES.elementSize() \/ 8);\n-        try {\n-            fromByteArray(a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n+        VectorMask<Float> m = SPECIES.shuffleFromOp(i -> i % 2 == 0 ? 1 : -1)\n+                .laneIsValid();\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, m)\n+        );\n@@ -884,31 +662,0 @@\n-    @Test(dataProvider = \"floatByteMaskProviderForIOOBE\")\n-    static void storeByteArrayMaskIOOBE(IntFunction<float[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Float> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                FloatVector av = FloatVector.fromByteArray(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteArray(av, r, i, ByteOrder.nativeOrder(), vmask);\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length, SPECIES.elementSize() \/ 8);\n-        try {\n-            FloatVector av = FloatVector.fromByteArray(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteArray(av, a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n@@ -930,0 +677,1 @@\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float512VectorLoadStoreTests.java","additions":112,"deletions":364,"binary":false,"changes":476,"status":"modified"},{"patch":"@@ -63,1 +63,0 @@\n-    private static final float CONST_SHIFT = Float.SIZE \/ 2;\n@@ -264,0 +263,49 @@\n+    static void assertcompressArraysEquals(float[] r, float[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    Assert.assertEquals(r[i + k], (float)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (float)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals(float[] r, float[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        Assert.assertEquals(r[i + j], (float)0);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (float)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n@@ -1027,1 +1075,0 @@\n-\n@@ -1211,1 +1258,0 @@\n-\n@@ -1332,1 +1378,0 @@\n-\n@@ -1357,1 +1402,0 @@\n-\n@@ -1474,0 +1518,1 @@\n+\n@@ -1530,0 +1575,1 @@\n+\n@@ -1550,0 +1596,1 @@\n+\n@@ -1606,0 +1653,1 @@\n+\n@@ -1626,0 +1674,1 @@\n+\n@@ -1703,0 +1752,1 @@\n+\n@@ -1722,2 +1772,0 @@\n-\n-\n@@ -1762,2 +1810,0 @@\n-\n-\n@@ -1805,8 +1851,0 @@\n-\n-\n-\n-\n-\n-\n-\n-\n@@ -1906,1 +1944,0 @@\n-\n@@ -1921,2 +1958,0 @@\n-\n-\n@@ -1940,9 +1975,0 @@\n-\n-\n-\n-\n-\n-\n-\n-\n-\n@@ -1980,57 +2006,0 @@\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n@@ -2057,0 +2026,1 @@\n+\n@@ -2075,0 +2045,1 @@\n+\n@@ -2095,0 +2066,1 @@\n+\n@@ -2170,11 +2142,0 @@\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n@@ -2198,0 +2159,1 @@\n+\n@@ -2222,0 +2184,1 @@\n+\n@@ -2240,0 +2203,1 @@\n+\n@@ -2266,0 +2230,1 @@\n+\n@@ -2283,0 +2248,1 @@\n+\n@@ -2307,0 +2273,1 @@\n+\n@@ -2325,0 +2292,1 @@\n+\n@@ -2351,0 +2319,1 @@\n+\n@@ -2368,0 +2337,1 @@\n+\n@@ -2392,0 +2362,1 @@\n+\n@@ -2410,0 +2381,1 @@\n+\n@@ -2436,0 +2408,1 @@\n+\n@@ -2453,0 +2426,1 @@\n+\n@@ -2477,0 +2451,1 @@\n+\n@@ -2495,0 +2470,1 @@\n+\n@@ -2521,0 +2497,1 @@\n+\n@@ -2538,0 +2515,1 @@\n+\n@@ -2562,0 +2540,1 @@\n+\n@@ -2580,0 +2559,1 @@\n+\n@@ -2607,4 +2587,0 @@\n-\n-\n-\n-\n@@ -2628,0 +2604,1 @@\n+\n@@ -2668,0 +2645,1 @@\n+\n@@ -2750,1 +2728,0 @@\n-\n@@ -2792,1 +2769,0 @@\n-\n@@ -2834,1 +2810,0 @@\n-\n@@ -2854,1 +2829,0 @@\n-\n@@ -2897,1 +2871,0 @@\n-\n@@ -2940,1 +2913,0 @@\n-\n@@ -2960,1 +2932,0 @@\n-\n@@ -3003,1 +2974,0 @@\n-\n@@ -3046,1 +3016,0 @@\n-\n@@ -3089,1 +3058,0 @@\n-\n@@ -3132,9 +3100,0 @@\n-\n-\n-\n-\n-\n-\n-\n-\n-\n@@ -3157,1 +3116,0 @@\n-\n@@ -3194,1 +3152,0 @@\n-\n@@ -3231,1 +3188,0 @@\n-\n@@ -3268,1 +3224,0 @@\n-\n@@ -3347,0 +3302,37 @@\n+\n+    @Test(dataProvider = \"floatUnaryOpMaskProvider\")\n+    static void compressFloat512VectorTests(IntFunction<float[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.compress(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertcompressArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"floatUnaryOpMaskProvider\")\n+    static void expandFloat512VectorTests(IntFunction<float[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.expand(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertexpandArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n@@ -3517,4 +3509,0 @@\n-\n-\n-\n-\n@@ -3535,3 +3523,0 @@\n-\n-\n-\n@@ -3563,0 +3548,1 @@\n+\n@@ -3592,0 +3578,1 @@\n+\n@@ -3625,0 +3612,1 @@\n+\n@@ -3652,0 +3640,1 @@\n+\n@@ -3691,0 +3680,1 @@\n+\n@@ -3771,1 +3761,0 @@\n-\n@@ -3795,1 +3784,0 @@\n-\n@@ -3819,1 +3807,0 @@\n-\n@@ -3843,1 +3830,0 @@\n-\n@@ -3867,1 +3853,0 @@\n-\n@@ -3891,1 +3876,0 @@\n-\n@@ -3915,1 +3899,0 @@\n-\n@@ -3939,1 +3922,0 @@\n-\n@@ -3963,1 +3945,0 @@\n-\n@@ -3987,1 +3968,0 @@\n-\n@@ -4011,1 +3991,0 @@\n-\n@@ -4035,1 +4014,0 @@\n-\n@@ -4059,1 +4037,0 @@\n-\n@@ -4083,1 +4060,0 @@\n-\n@@ -4107,1 +4083,0 @@\n-\n@@ -4134,1 +4109,0 @@\n-\n@@ -4160,0 +4134,1 @@\n+\n@@ -4186,1 +4161,0 @@\n-\n@@ -4213,1 +4187,0 @@\n-\n@@ -4228,0 +4201,1 @@\n+\n@@ -4243,1 +4217,0 @@\n-\n@@ -4247,0 +4220,1 @@\n+\n@@ -4251,1 +4225,0 @@\n-\n@@ -4270,0 +4243,1 @@\n+\n@@ -4287,1 +4261,0 @@\n-\n@@ -4310,4 +4283,0 @@\n-\n-\n-\n-\n@@ -4344,1 +4313,0 @@\n-\n@@ -4383,3 +4351,0 @@\n-\n-\n-\n@@ -4400,0 +4365,1 @@\n+\n@@ -4415,1 +4381,0 @@\n-\n@@ -4434,3 +4399,0 @@\n-\n-\n-\n@@ -4549,7 +4511,0 @@\n-\n-\n-\n-\n-\n-\n-\n@@ -4564,2 +4519,0 @@\n-\n-\n@@ -4596,2 +4549,0 @@\n-\n-\n@@ -4616,1 +4567,0 @@\n-\n@@ -5018,0 +4968,17 @@\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCompressFloat512VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        int trueCount = 0;\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                trueCount = vmask.trueCount();\n+                var rmask = vmask.compress();\n+                for (int j = 0; j < SPECIES.length(); j++)  {\n+                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);\n+                }\n+            }\n+        }\n+    }\n+\n@@ -5060,0 +5027,14 @@\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeLongFloat512VectorTestsSmokeTest(int offset) {\n+        long limit = SPECIES.length() * BUFFER_REPS;\n+        for (long i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i + offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                long index = i + j + offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n@@ -5080,0 +5061,8 @@\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundLongFloat512VectorTestsSmokeTest(int _length) {\n+        long length = _length;\n+        long actualLoopBound = SPECIES.loopBound(length);\n+        long expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+    }\n+\n@@ -5142,1 +5131,0 @@\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float512VectorTests.java","additions":165,"deletions":177,"binary":false,"changes":342,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,3 @@\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.ValueLayout;\n@@ -42,2 +45,0 @@\n-import java.nio.ByteBuffer;\n-import java.nio.FloatBuffer;\n@@ -45,1 +46,0 @@\n-import java.nio.ReadOnlyBufferException;\n@@ -70,11 +70,0 @@\n-    static void assertArraysEquals(byte[] r, byte[] a, boolean[] mask) {\n-        int i = 0;\n-        try {\n-            for (; i < a.length; i++) {\n-                Assert.assertEquals(r[i], mask[(i*8\/SPECIES.elementSize()) % SPECIES.length()] ? a[i] : (byte) 0);\n-            }\n-        } catch (AssertionError e) {\n-            Assert.assertEquals(r[i], mask[(i*8\/SPECIES.elementSize()) % SPECIES.length()] ? a[i] : (byte) 0, \"at index #\" + i);\n-        }\n-    }\n-\n@@ -120,1 +109,1 @@\n-    \/\/ Relative to byte[] array.length or ByteBuffer.limit()\n+    \/\/ Relative to byte[] array.length or MemorySegment.byteSize()\n@@ -191,1 +180,1 @@\n-    public Object[][] floatByteBufferProvider() {\n+    public Object[][] floatMemorySegmentProvider() {\n@@ -193,1 +182,1 @@\n-                flatMap(fa -> BYTE_BUFFER_GENERATORS.stream().\n+                flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n@@ -201,1 +190,1 @@\n-    public Object[][] floatByteBufferMaskProvider() {\n+    public Object[][] floatMemorySegmentMaskProvider() {\n@@ -204,1 +193,1 @@\n-                        flatMap(fa -> BYTE_BUFFER_GENERATORS.stream().\n+                        flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n@@ -211,19 +200,0 @@\n-    @DataProvider\n-    public Object[][] floatByteArrayProvider() {\n-        return FLOAT_GENERATORS.stream().\n-                flatMap(fa -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                    return new Object[]{fa, bo};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] floatByteArrayMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> FLOAT_GENERATORS.stream().\n-                    flatMap(fa -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                        return new Object[]{fa, fm, bo};\n-                    }))).\n-                toArray(Object[][]::new);\n-    }\n-\n@@ -249,4 +219,4 @@\n-    static ByteBuffer toBuffer(float[] a, IntFunction<ByteBuffer> fb) {\n-        ByteBuffer bb = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n-        for (float v : a) {\n-            bb.putFloat(v);\n+    static MemorySegment toSegment(float[] a, IntFunction<MemorySegment> fb) {\n+        MemorySegment ms = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n+        for (int i = 0; i < a.length; i++) {\n+            ms.set(ValueLayout.JAVA_FLOAT, i * SPECIES.elementSize() \/ 8 , a[i]);\n@@ -254,1 +224,1 @@\n-        return bb.clear();\n+        return ms;\n@@ -257,14 +227,2 @@\n-    static float[] bufferToArray(ByteBuffer bb) {\n-        FloatBuffer db = bb.asFloatBuffer();\n-        float[] d = new float[db.capacity()];\n-        db.get(0, d);\n-        return d;\n-    }\n-\n-    static byte[] toByteArray(float[] a, IntFunction<byte[]> fb, ByteOrder bo) {\n-        byte[] b = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n-        FloatBuffer bb = ByteBuffer.wrap(b, 0, b.length).order(bo).asFloatBuffer();\n-        for (float v : a) {\n-            bb.put(v);\n-        }\n-        return b;\n+    static float[] segmentToArray(MemorySegment ms) {\n+        return ms.toArray(ValueLayout.JAVA_FLOAT);\n@@ -310,22 +268,2 @@\n-    static FloatVector fromByteArray(byte[] a, int i, ByteOrder bo) {\n-        return FloatVector.fromByteArray(SPECIES, a, i, bo);\n-    }\n-\n-    @DontInline\n-    static FloatVector fromByteArray(byte[] a, int i, ByteOrder bo, VectorMask<Float> m) {\n-        return FloatVector.fromByteArray(SPECIES, a, i, bo, m);\n-    }\n-\n-    @DontInline\n-    static void intoByteArray(FloatVector v, byte[] a, int i, ByteOrder bo) {\n-        v.intoByteArray(a, i, bo);\n-    }\n-\n-    @DontInline\n-    static void intoByteArray(FloatVector v, byte[] a, int i, ByteOrder bo, VectorMask<Float> m) {\n-        v.intoByteArray(a, i, bo, m);\n-    }\n-\n-    @DontInline\n-    static FloatVector fromByteBuffer(ByteBuffer a, int i, ByteOrder bo) {\n-        return FloatVector.fromByteBuffer(SPECIES, a, i, bo);\n+    static FloatVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo) {\n+        return FloatVector.fromMemorySegment(SPECIES, a, i, bo);\n@@ -335,2 +273,2 @@\n-    static FloatVector fromByteBuffer(ByteBuffer a, int i, ByteOrder bo, VectorMask<Float> m) {\n-        return FloatVector.fromByteBuffer(SPECIES, a, i, bo, m);\n+    static FloatVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo, VectorMask<Float> m) {\n+        return FloatVector.fromMemorySegment(SPECIES, a, i, bo, m);\n@@ -340,2 +278,2 @@\n-    static void intoByteBuffer(FloatVector v, ByteBuffer a, int i, ByteOrder bo) {\n-        v.intoByteBuffer(a, i, bo);\n+    static void intoMemorySegment(FloatVector v, MemorySegment a, int i, ByteOrder bo) {\n+        v.intoMemorySegment(a, i, bo);\n@@ -345,2 +283,2 @@\n-    static void intoByteBuffer(FloatVector v, ByteBuffer a, int i, ByteOrder bo, VectorMask<Float> m) {\n-        v.intoByteBuffer(a, i, bo, m);\n+    static void intoMemorySegment(FloatVector v, MemorySegment a, int i, ByteOrder bo, VectorMask<Float> m) {\n+        v.intoMemorySegment(a, i, bo, m);\n@@ -349,1 +287,0 @@\n-\n@@ -520,6 +457,6 @@\n-    @Test(dataProvider = \"floatByteBufferProvider\")\n-    static void loadStoreByteBuffer(IntFunction<float[]> fa,\n-                                    IntFunction<ByteBuffer> fb,\n-                                    ByteOrder bo) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), fb);\n-        ByteBuffer r = fb.apply(a.limit());\n+    @Test(dataProvider = \"floatMemorySegmentProvider\")\n+    static void loadStoreMemorySegment(IntFunction<float[]> fa,\n+                                       IntFunction<MemorySegment> fb,\n+                                       ByteOrder bo) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb);\n+        MemorySegment r = fb.apply((int) a.byteSize());\n@@ -527,1 +464,1 @@\n-        int l = a.limit();\n+        int l = (int) a.byteSize();\n@@ -532,2 +469,2 @@\n-                FloatVector av = FloatVector.fromByteBuffer(SPECIES, a, i, bo);\n-                av.intoByteBuffer(r, i, bo);\n+                FloatVector av = FloatVector.fromMemorySegment(SPECIES, a, i, bo);\n+                av.intoMemorySegment(r, i, bo);\n@@ -536,5 +473,2 @@\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        Assert.assertEquals(r, a, \"Buffers not equal\");\n+        long m = r.mismatch(a);\n+        Assert.assertEquals(m, -1, \"Segments not equal\");\n@@ -544,3 +478,3 @@\n-    static void loadByteBufferIOOBE(IntFunction<float[]> fa, IntFunction<Integer> fi) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n+    static void loadMemorySegmentIOOBE(IntFunction<float[]> fa, IntFunction<Integer> fi) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n@@ -548,1 +482,1 @@\n-        int l = a.limit();\n+        int l = (int) a.byteSize();\n@@ -553,2 +487,2 @@\n-                FloatVector av = fromByteBuffer(a, i, ByteOrder.nativeOrder());\n-                av.intoByteBuffer(r, i, ByteOrder.nativeOrder());\n+                FloatVector av = fromMemorySegment(a, i, ByteOrder.nativeOrder());\n+                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n@@ -558,2 +492,2 @@\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.limit());\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());\n@@ -561,1 +495,1 @@\n-            fromByteBuffer(a, index, ByteOrder.nativeOrder());\n+            fromMemorySegment(a, index, ByteOrder.nativeOrder());\n@@ -573,3 +507,3 @@\n-    static void storeByteBufferIOOBE(IntFunction<float[]> fa, IntFunction<Integer> fi) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n+    static void storeMemorySegmentIOOBE(IntFunction<float[]> fa, IntFunction<Integer> fi) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n@@ -577,1 +511,1 @@\n-        int l = a.limit();\n+        int l = (int) a.byteSize();\n@@ -582,2 +516,2 @@\n-                FloatVector av = FloatVector.fromByteBuffer(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteBuffer(av, r, i, ByteOrder.nativeOrder());\n+                FloatVector av = FloatVector.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+                intoMemorySegment(av, r, i, ByteOrder.nativeOrder());\n@@ -587,2 +521,2 @@\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.limit());\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());\n@@ -590,2 +524,2 @@\n-            FloatVector av = FloatVector.fromByteBuffer(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteBuffer(av, r, index, ByteOrder.nativeOrder());\n+            FloatVector av = FloatVector.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+            intoMemorySegment(av, r, index, ByteOrder.nativeOrder());\n@@ -602,6 +536,5 @@\n-\n-    @Test(dataProvider = \"floatByteBufferMaskProvider\")\n-    static void loadStoreByteBufferMask(IntFunction<float[]> fa,\n-                                        IntFunction<ByteBuffer> fb,\n-                                        IntFunction<boolean[]> fm,\n-                                        ByteOrder bo) {\n+    @Test(dataProvider = \"floatMemorySegmentMaskProvider\")\n+    static void loadStoreMemorySegmentMask(IntFunction<float[]> fa,\n+                                           IntFunction<MemorySegment> fb,\n+                                           IntFunction<boolean[]> fm,\n+                                           ByteOrder bo) {\n@@ -609,2 +542,2 @@\n-        ByteBuffer a = toBuffer(_a, fb);\n-        ByteBuffer r = fb.apply(a.limit());\n+        MemorySegment a = toSegment(_a, fb);\n+        MemorySegment r = fb.apply((int) a.byteSize());\n@@ -614,1 +547,1 @@\n-        int l = a.limit();\n+        int l = (int) a.byteSize();\n@@ -619,2 +552,2 @@\n-                FloatVector av = FloatVector.fromByteBuffer(SPECIES, a, i, bo, vmask);\n-                av.intoByteBuffer(r, i, bo);\n+                FloatVector av = FloatVector.fromMemorySegment(SPECIES, a, i, bo, vmask);\n+                av.intoMemorySegment(r, i, bo);\n@@ -623,5 +556,1 @@\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        assertArraysEquals(bufferToArray(r), _a, mask);\n+        assertArraysEquals(segmentToArray(r), _a, mask);\n@@ -630,1 +559,1 @@\n-        r = fb.apply(a.limit());\n+        r = fb.apply((int) a.byteSize());\n@@ -634,2 +563,2 @@\n-                FloatVector av = FloatVector.fromByteBuffer(SPECIES, a, i, bo);\n-                av.intoByteBuffer(r, i, bo, vmask);\n+                FloatVector av = FloatVector.fromMemorySegment(SPECIES, a, i, bo);\n+                av.intoMemorySegment(r, i, bo, vmask);\n@@ -638,5 +567,1 @@\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        assertArraysEquals(bufferToArray(r), _a, mask);\n+        assertArraysEquals(segmentToArray(r), _a, mask);\n@@ -646,3 +571,3 @@\n-    static void loadByteBufferMaskIOOBE(IntFunction<float[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n+    static void loadMemorySegmentMaskIOOBE(IntFunction<float[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n@@ -652,1 +577,1 @@\n-        int l = a.limit();\n+        int l = (int) a.byteSize();\n@@ -657,2 +582,2 @@\n-                FloatVector av = fromByteBuffer(a, i, ByteOrder.nativeOrder(), vmask);\n-                av.intoByteBuffer(r, i, ByteOrder.nativeOrder());\n+                FloatVector av = fromMemorySegment(a, i, ByteOrder.nativeOrder(), vmask);\n+                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n@@ -662,2 +587,2 @@\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.limit(), SPECIES.elementSize() \/ 8);\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() \/ 8);\n@@ -665,1 +590,1 @@\n-            fromByteBuffer(a, index, ByteOrder.nativeOrder(), vmask);\n+            fromMemorySegment(a, index, ByteOrder.nativeOrder(), vmask);\n@@ -677,3 +602,3 @@\n-    static void storeByteBufferMaskIOOBE(IntFunction<float[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n+    static void storeMemorySegmentMaskIOOBE(IntFunction<float[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n@@ -683,83 +608,1 @@\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                FloatVector av = FloatVector.fromByteBuffer(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteBuffer(av, r, i, ByteOrder.nativeOrder(), vmask);\n-            }\n-        }\n-\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.limit(), SPECIES.elementSize() \/ 8);\n-        try {\n-            FloatVector av = FloatVector.fromByteBuffer(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteBuffer(av, a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"floatByteBufferProvider\")\n-    static void loadStoreReadonlyByteBuffer(IntFunction<float[]> fa,\n-                                    IntFunction<ByteBuffer> fb,\n-                                    ByteOrder bo) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), fb).asReadOnlyBuffer();\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo);\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, SPECIES.maskAll(true));\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, SPECIES.maskAll(false));\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            VectorMask<Float> m = SPECIES.shuffleFromOp(i -> i % 2 == 0 ? 1 : -1)\n-                    .laneIsValid();\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, m);\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"floatByteArrayProvider\")\n-    static void loadStoreByteArray(IntFunction<float[]> fa,\n-                                    ByteOrder bo) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, bo);\n-        byte[] r = new byte[a.length];\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                FloatVector av = FloatVector.fromByteArray(SPECIES, a, i, bo);\n-                av.intoByteArray(r, i, bo);\n-            }\n-        }\n-        Assert.assertEquals(r, a, \"Byte arrays not equal\");\n-    }\n-\n-    @Test(dataProvider = \"floatByteProviderForIOOBE\")\n-    static void loadByteArrayIOOBE(IntFunction<float[]> fa, IntFunction<Integer> fi) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-\n+        int l = (int) a.byteSize();\n@@ -767,1 +610,0 @@\n-        int l = a.length;\n@@ -771,2 +613,2 @@\n-                FloatVector av = fromByteArray(a, i, ByteOrder.nativeOrder());\n-                av.intoByteArray(r, i, ByteOrder.nativeOrder());\n+                FloatVector av = FloatVector.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+                intoMemorySegment(av, r, i, ByteOrder.nativeOrder(), vmask);\n@@ -776,2 +618,2 @@\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.length);\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() \/ 8);\n@@ -779,1 +621,2 @@\n-            fromByteArray(a, index, ByteOrder.nativeOrder());\n+            FloatVector av = FloatVector.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+            intoMemorySegment(av, a, index, ByteOrder.nativeOrder(), vmask);\n@@ -790,62 +633,5 @@\n-    @Test(dataProvider = \"floatByteProviderForIOOBE\")\n-    static void storeByteArrayIOOBE(IntFunction<float[]> fa, IntFunction<Integer> fi) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                FloatVector av = FloatVector.fromByteArray(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteArray(av, r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.length);\n-        try {\n-            FloatVector av = FloatVector.fromByteArray(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteArray(av, r, index, ByteOrder.nativeOrder());\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"floatByteArrayMaskProvider\")\n-    static void loadStoreByteArrayMask(IntFunction<float[]> fa,\n-                                  IntFunction<boolean[]> fm,\n-                                  ByteOrder bo) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, bo);\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Float> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-          for (int i = 0; i < l; i += s) {\n-              FloatVector av = FloatVector.fromByteArray(SPECIES, a, i, bo, vmask);\n-              av.intoByteArray(r, i, bo);\n-          }\n-        }\n-        assertArraysEquals(r, a, mask);\n-\n-\n-        r = new byte[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                FloatVector av = FloatVector.fromByteArray(SPECIES, a, i, bo);\n-                av.intoByteArray(r, i, bo, vmask);\n-            }\n-        }\n-        assertArraysEquals(r, a, mask);\n-    }\n+    @Test(dataProvider = \"floatMemorySegmentProvider\")\n+    static void loadStoreReadonlyMemorySegment(IntFunction<float[]> fa,\n+                                               IntFunction<MemorySegment> fb,\n+                                               ByteOrder bo) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb).asReadOnly();\n@@ -853,6 +639,4 @@\n-    @Test(dataProvider = \"floatByteMaskProviderForIOOBE\")\n-    static void loadByteArrayMaskIOOBE(IntFunction<float[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Float> vmask = VectorMask.fromValues(SPECIES, mask);\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo)\n+        );\n@@ -860,2 +644,4 @@\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(true))\n+        );\n@@ -863,6 +649,4 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                FloatVector av = fromByteArray(a, i, ByteOrder.nativeOrder(), vmask);\n-                av.intoByteArray(r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(false))\n+        );\n@@ -870,12 +654,6 @@\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length, SPECIES.elementSize() \/ 8);\n-        try {\n-            fromByteArray(a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n+        VectorMask<Float> m = SPECIES.shuffleFromOp(i -> i % 2 == 0 ? 1 : -1)\n+                .laneIsValid();\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, m)\n+        );\n@@ -884,31 +662,0 @@\n-    @Test(dataProvider = \"floatByteMaskProviderForIOOBE\")\n-    static void storeByteArrayMaskIOOBE(IntFunction<float[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Float> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                FloatVector av = FloatVector.fromByteArray(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteArray(av, r, i, ByteOrder.nativeOrder(), vmask);\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length, SPECIES.elementSize() \/ 8);\n-        try {\n-            FloatVector av = FloatVector.fromByteArray(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteArray(av, a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n@@ -930,0 +677,1 @@\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float64VectorLoadStoreTests.java","additions":112,"deletions":364,"binary":false,"changes":476,"status":"modified"},{"patch":"@@ -63,1 +63,0 @@\n-    private static final float CONST_SHIFT = Float.SIZE \/ 2;\n@@ -264,0 +263,49 @@\n+    static void assertcompressArraysEquals(float[] r, float[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    Assert.assertEquals(r[i + k], (float)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (float)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals(float[] r, float[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        Assert.assertEquals(r[i + j], (float)0);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (float)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n@@ -1027,1 +1075,0 @@\n-\n@@ -1211,1 +1258,0 @@\n-\n@@ -1332,1 +1378,0 @@\n-\n@@ -1357,1 +1402,0 @@\n-\n@@ -1474,0 +1518,1 @@\n+\n@@ -1530,0 +1575,1 @@\n+\n@@ -1550,0 +1596,1 @@\n+\n@@ -1606,0 +1653,1 @@\n+\n@@ -1626,0 +1674,1 @@\n+\n@@ -1703,0 +1752,1 @@\n+\n@@ -1722,2 +1772,0 @@\n-\n-\n@@ -1762,2 +1810,0 @@\n-\n-\n@@ -1805,8 +1851,0 @@\n-\n-\n-\n-\n-\n-\n-\n-\n@@ -1906,1 +1944,0 @@\n-\n@@ -1921,2 +1958,0 @@\n-\n-\n@@ -1940,9 +1975,0 @@\n-\n-\n-\n-\n-\n-\n-\n-\n-\n@@ -1980,57 +2006,0 @@\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n@@ -2057,0 +2026,1 @@\n+\n@@ -2075,0 +2045,1 @@\n+\n@@ -2095,0 +2066,1 @@\n+\n@@ -2170,11 +2142,0 @@\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n@@ -2198,0 +2159,1 @@\n+\n@@ -2222,0 +2184,1 @@\n+\n@@ -2240,0 +2203,1 @@\n+\n@@ -2266,0 +2230,1 @@\n+\n@@ -2283,0 +2248,1 @@\n+\n@@ -2307,0 +2273,1 @@\n+\n@@ -2325,0 +2292,1 @@\n+\n@@ -2351,0 +2319,1 @@\n+\n@@ -2368,0 +2337,1 @@\n+\n@@ -2392,0 +2362,1 @@\n+\n@@ -2410,0 +2381,1 @@\n+\n@@ -2436,0 +2408,1 @@\n+\n@@ -2453,0 +2426,1 @@\n+\n@@ -2477,0 +2451,1 @@\n+\n@@ -2495,0 +2470,1 @@\n+\n@@ -2521,0 +2497,1 @@\n+\n@@ -2538,0 +2515,1 @@\n+\n@@ -2562,0 +2540,1 @@\n+\n@@ -2580,0 +2559,1 @@\n+\n@@ -2607,4 +2587,0 @@\n-\n-\n-\n-\n@@ -2628,0 +2604,1 @@\n+\n@@ -2668,0 +2645,1 @@\n+\n@@ -2750,1 +2728,0 @@\n-\n@@ -2792,1 +2769,0 @@\n-\n@@ -2834,1 +2810,0 @@\n-\n@@ -2854,1 +2829,0 @@\n-\n@@ -2897,1 +2871,0 @@\n-\n@@ -2940,1 +2913,0 @@\n-\n@@ -2960,1 +2932,0 @@\n-\n@@ -3003,1 +2974,0 @@\n-\n@@ -3046,1 +3016,0 @@\n-\n@@ -3089,1 +3058,0 @@\n-\n@@ -3132,9 +3100,0 @@\n-\n-\n-\n-\n-\n-\n-\n-\n-\n@@ -3157,1 +3116,0 @@\n-\n@@ -3194,1 +3152,0 @@\n-\n@@ -3231,1 +3188,0 @@\n-\n@@ -3268,1 +3224,0 @@\n-\n@@ -3347,0 +3302,37 @@\n+\n+    @Test(dataProvider = \"floatUnaryOpMaskProvider\")\n+    static void compressFloat64VectorTests(IntFunction<float[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.compress(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertcompressArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"floatUnaryOpMaskProvider\")\n+    static void expandFloat64VectorTests(IntFunction<float[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.expand(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertexpandArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n@@ -3517,4 +3509,0 @@\n-\n-\n-\n-\n@@ -3535,3 +3523,0 @@\n-\n-\n-\n@@ -3563,0 +3548,1 @@\n+\n@@ -3592,0 +3578,1 @@\n+\n@@ -3625,0 +3612,1 @@\n+\n@@ -3652,0 +3640,1 @@\n+\n@@ -3691,0 +3680,1 @@\n+\n@@ -3771,1 +3761,0 @@\n-\n@@ -3795,1 +3784,0 @@\n-\n@@ -3819,1 +3807,0 @@\n-\n@@ -3843,1 +3830,0 @@\n-\n@@ -3867,1 +3853,0 @@\n-\n@@ -3891,1 +3876,0 @@\n-\n@@ -3915,1 +3899,0 @@\n-\n@@ -3939,1 +3922,0 @@\n-\n@@ -3963,1 +3945,0 @@\n-\n@@ -3987,1 +3968,0 @@\n-\n@@ -4011,1 +3991,0 @@\n-\n@@ -4035,1 +4014,0 @@\n-\n@@ -4059,1 +4037,0 @@\n-\n@@ -4083,1 +4060,0 @@\n-\n@@ -4107,1 +4083,0 @@\n-\n@@ -4134,1 +4109,0 @@\n-\n@@ -4160,0 +4134,1 @@\n+\n@@ -4186,1 +4161,0 @@\n-\n@@ -4213,1 +4187,0 @@\n-\n@@ -4228,0 +4201,1 @@\n+\n@@ -4243,1 +4217,0 @@\n-\n@@ -4247,0 +4220,1 @@\n+\n@@ -4251,1 +4225,0 @@\n-\n@@ -4270,0 +4243,1 @@\n+\n@@ -4287,1 +4261,0 @@\n-\n@@ -4310,4 +4283,0 @@\n-\n-\n-\n-\n@@ -4344,1 +4313,0 @@\n-\n@@ -4383,3 +4351,0 @@\n-\n-\n-\n@@ -4400,0 +4365,1 @@\n+\n@@ -4415,1 +4381,0 @@\n-\n@@ -4434,3 +4399,0 @@\n-\n-\n-\n@@ -4549,7 +4511,0 @@\n-\n-\n-\n-\n-\n-\n-\n@@ -4564,2 +4519,0 @@\n-\n-\n@@ -4596,2 +4549,0 @@\n-\n-\n@@ -4616,1 +4567,0 @@\n-\n@@ -5018,0 +4968,17 @@\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCompressFloat64VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        int trueCount = 0;\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                trueCount = vmask.trueCount();\n+                var rmask = vmask.compress();\n+                for (int j = 0; j < SPECIES.length(); j++)  {\n+                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);\n+                }\n+            }\n+        }\n+    }\n+\n@@ -5060,0 +5027,14 @@\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeLongFloat64VectorTestsSmokeTest(int offset) {\n+        long limit = SPECIES.length() * BUFFER_REPS;\n+        for (long i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i + offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                long index = i + j + offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n@@ -5080,0 +5061,8 @@\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundLongFloat64VectorTestsSmokeTest(int _length) {\n+        long length = _length;\n+        long actualLoopBound = SPECIES.loopBound(length);\n+        long expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+    }\n+\n@@ -5142,1 +5131,0 @@\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float64VectorTests.java","additions":165,"deletions":177,"binary":false,"changes":342,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,3 @@\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.ValueLayout;\n@@ -44,4 +47,0 @@\n-import java.lang.invoke.MethodHandles;\n-import java.lang.invoke.VarHandle;\n-import java.nio.ByteBuffer;\n-import java.nio.FloatBuffer;\n@@ -49,1 +48,0 @@\n-import java.nio.ReadOnlyBufferException;\n@@ -79,11 +77,0 @@\n-    static void assertArraysEquals(byte[] r, byte[] a, boolean[] mask) {\n-        int i = 0;\n-        try {\n-            for (; i < a.length; i++) {\n-                Assert.assertEquals(r[i], mask[(i*8\/SPECIES.elementSize()) % SPECIES.length()] ? a[i] : (byte) 0);\n-            }\n-        } catch (AssertionError e) {\n-            Assert.assertEquals(r[i], mask[(i*8\/SPECIES.elementSize()) % SPECIES.length()] ? a[i] : (byte) 0, \"at index #\" + i);\n-        }\n-    }\n-\n@@ -129,1 +116,1 @@\n-    \/\/ Relative to byte[] array.length or ByteBuffer.limit()\n+    \/\/ Relative to byte[] array.length or MemorySegment.byteSize()\n@@ -200,1 +187,1 @@\n-    public Object[][] floatByteBufferProvider() {\n+    public Object[][] floatMemorySegmentProvider() {\n@@ -202,1 +189,1 @@\n-                flatMap(fa -> BYTE_BUFFER_GENERATORS.stream().\n+                flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n@@ -210,1 +197,1 @@\n-    public Object[][] floatByteBufferMaskProvider() {\n+    public Object[][] floatMemorySegmentMaskProvider() {\n@@ -213,1 +200,1 @@\n-                        flatMap(fa -> BYTE_BUFFER_GENERATORS.stream().\n+                        flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n@@ -220,19 +207,0 @@\n-    @DataProvider\n-    public Object[][] floatByteArrayProvider() {\n-        return FLOAT_GENERATORS.stream().\n-                flatMap(fa -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                    return new Object[]{fa, bo};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] floatByteArrayMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> FLOAT_GENERATORS.stream().\n-                    flatMap(fa -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                        return new Object[]{fa, fm, bo};\n-                    }))).\n-                toArray(Object[][]::new);\n-    }\n-\n@@ -258,4 +226,4 @@\n-    static ByteBuffer toBuffer(float[] a, IntFunction<ByteBuffer> fb) {\n-        ByteBuffer bb = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n-        for (float v : a) {\n-            bb.putFloat(v);\n+    static MemorySegment toSegment(float[] a, IntFunction<MemorySegment> fb) {\n+        MemorySegment ms = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n+        for (int i = 0; i < a.length; i++) {\n+            ms.set(ValueLayout.JAVA_FLOAT, i * SPECIES.elementSize() \/ 8 , a[i]);\n@@ -263,1 +231,1 @@\n-        return bb.clear();\n+        return ms;\n@@ -266,14 +234,2 @@\n-    static float[] bufferToArray(ByteBuffer bb) {\n-        FloatBuffer db = bb.asFloatBuffer();\n-        float[] d = new float[db.capacity()];\n-        db.get(0, d);\n-        return d;\n-    }\n-\n-    static byte[] toByteArray(float[] a, IntFunction<byte[]> fb, ByteOrder bo) {\n-        byte[] b = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n-        FloatBuffer bb = ByteBuffer.wrap(b, 0, b.length).order(bo).asFloatBuffer();\n-        for (float v : a) {\n-            bb.put(v);\n-        }\n-        return b;\n+    static float[] segmentToArray(MemorySegment ms) {\n+        return ms.toArray(ValueLayout.JAVA_FLOAT);\n@@ -319,22 +275,2 @@\n-    static FloatVector fromByteArray(byte[] a, int i, ByteOrder bo) {\n-        return FloatVector.fromByteArray(SPECIES, a, i, bo);\n-    }\n-\n-    @DontInline\n-    static FloatVector fromByteArray(byte[] a, int i, ByteOrder bo, VectorMask<Float> m) {\n-        return FloatVector.fromByteArray(SPECIES, a, i, bo, m);\n-    }\n-\n-    @DontInline\n-    static void intoByteArray(FloatVector v, byte[] a, int i, ByteOrder bo) {\n-        v.intoByteArray(a, i, bo);\n-    }\n-\n-    @DontInline\n-    static void intoByteArray(FloatVector v, byte[] a, int i, ByteOrder bo, VectorMask<Float> m) {\n-        v.intoByteArray(a, i, bo, m);\n-    }\n-\n-    @DontInline\n-    static FloatVector fromByteBuffer(ByteBuffer a, int i, ByteOrder bo) {\n-        return FloatVector.fromByteBuffer(SPECIES, a, i, bo);\n+    static FloatVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo) {\n+        return FloatVector.fromMemorySegment(SPECIES, a, i, bo);\n@@ -344,2 +280,2 @@\n-    static FloatVector fromByteBuffer(ByteBuffer a, int i, ByteOrder bo, VectorMask<Float> m) {\n-        return FloatVector.fromByteBuffer(SPECIES, a, i, bo, m);\n+    static FloatVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo, VectorMask<Float> m) {\n+        return FloatVector.fromMemorySegment(SPECIES, a, i, bo, m);\n@@ -349,2 +285,2 @@\n-    static void intoByteBuffer(FloatVector v, ByteBuffer a, int i, ByteOrder bo) {\n-        v.intoByteBuffer(a, i, bo);\n+    static void intoMemorySegment(FloatVector v, MemorySegment a, int i, ByteOrder bo) {\n+        v.intoMemorySegment(a, i, bo);\n@@ -354,2 +290,2 @@\n-    static void intoByteBuffer(FloatVector v, ByteBuffer a, int i, ByteOrder bo, VectorMask<Float> m) {\n-        v.intoByteBuffer(a, i, bo, m);\n+    static void intoMemorySegment(FloatVector v, MemorySegment a, int i, ByteOrder bo, VectorMask<Float> m) {\n+        v.intoMemorySegment(a, i, bo, m);\n@@ -358,1 +294,0 @@\n-\n@@ -529,6 +464,6 @@\n-    @Test(dataProvider = \"floatByteBufferProvider\")\n-    static void loadStoreByteBuffer(IntFunction<float[]> fa,\n-                                    IntFunction<ByteBuffer> fb,\n-                                    ByteOrder bo) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), fb);\n-        ByteBuffer r = fb.apply(a.limit());\n+    @Test(dataProvider = \"floatMemorySegmentProvider\")\n+    static void loadStoreMemorySegment(IntFunction<float[]> fa,\n+                                       IntFunction<MemorySegment> fb,\n+                                       ByteOrder bo) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb);\n+        MemorySegment r = fb.apply((int) a.byteSize());\n@@ -536,1 +471,1 @@\n-        int l = a.limit();\n+        int l = (int) a.byteSize();\n@@ -541,2 +476,2 @@\n-                FloatVector av = FloatVector.fromByteBuffer(SPECIES, a, i, bo);\n-                av.intoByteBuffer(r, i, bo);\n+                FloatVector av = FloatVector.fromMemorySegment(SPECIES, a, i, bo);\n+                av.intoMemorySegment(r, i, bo);\n@@ -545,5 +480,2 @@\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        Assert.assertEquals(r, a, \"Buffers not equal\");\n+        long m = r.mismatch(a);\n+        Assert.assertEquals(m, -1, \"Segments not equal\");\n@@ -553,3 +485,3 @@\n-    static void loadByteBufferIOOBE(IntFunction<float[]> fa, IntFunction<Integer> fi) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n+    static void loadMemorySegmentIOOBE(IntFunction<float[]> fa, IntFunction<Integer> fi) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n@@ -557,1 +489,1 @@\n-        int l = a.limit();\n+        int l = (int) a.byteSize();\n@@ -562,2 +494,2 @@\n-                FloatVector av = fromByteBuffer(a, i, ByteOrder.nativeOrder());\n-                av.intoByteBuffer(r, i, ByteOrder.nativeOrder());\n+                FloatVector av = fromMemorySegment(a, i, ByteOrder.nativeOrder());\n+                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n@@ -567,2 +499,2 @@\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.limit());\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());\n@@ -570,1 +502,1 @@\n-            fromByteBuffer(a, index, ByteOrder.nativeOrder());\n+            fromMemorySegment(a, index, ByteOrder.nativeOrder());\n@@ -582,3 +514,3 @@\n-    static void storeByteBufferIOOBE(IntFunction<float[]> fa, IntFunction<Integer> fi) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n+    static void storeMemorySegmentIOOBE(IntFunction<float[]> fa, IntFunction<Integer> fi) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n@@ -586,1 +518,1 @@\n-        int l = a.limit();\n+        int l = (int) a.byteSize();\n@@ -591,2 +523,2 @@\n-                FloatVector av = FloatVector.fromByteBuffer(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteBuffer(av, r, i, ByteOrder.nativeOrder());\n+                FloatVector av = FloatVector.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+                intoMemorySegment(av, r, i, ByteOrder.nativeOrder());\n@@ -596,2 +528,2 @@\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.limit());\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());\n@@ -599,2 +531,2 @@\n-            FloatVector av = FloatVector.fromByteBuffer(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteBuffer(av, r, index, ByteOrder.nativeOrder());\n+            FloatVector av = FloatVector.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+            intoMemorySegment(av, r, index, ByteOrder.nativeOrder());\n@@ -611,6 +543,5 @@\n-\n-    @Test(dataProvider = \"floatByteBufferMaskProvider\")\n-    static void loadStoreByteBufferMask(IntFunction<float[]> fa,\n-                                        IntFunction<ByteBuffer> fb,\n-                                        IntFunction<boolean[]> fm,\n-                                        ByteOrder bo) {\n+    @Test(dataProvider = \"floatMemorySegmentMaskProvider\")\n+    static void loadStoreMemorySegmentMask(IntFunction<float[]> fa,\n+                                           IntFunction<MemorySegment> fb,\n+                                           IntFunction<boolean[]> fm,\n+                                           ByteOrder bo) {\n@@ -618,2 +549,2 @@\n-        ByteBuffer a = toBuffer(_a, fb);\n-        ByteBuffer r = fb.apply(a.limit());\n+        MemorySegment a = toSegment(_a, fb);\n+        MemorySegment r = fb.apply((int) a.byteSize());\n@@ -623,1 +554,1 @@\n-        int l = a.limit();\n+        int l = (int) a.byteSize();\n@@ -628,2 +559,2 @@\n-                FloatVector av = FloatVector.fromByteBuffer(SPECIES, a, i, bo, vmask);\n-                av.intoByteBuffer(r, i, bo);\n+                FloatVector av = FloatVector.fromMemorySegment(SPECIES, a, i, bo, vmask);\n+                av.intoMemorySegment(r, i, bo);\n@@ -632,5 +563,1 @@\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        assertArraysEquals(bufferToArray(r), _a, mask);\n+        assertArraysEquals(segmentToArray(r), _a, mask);\n@@ -639,1 +566,1 @@\n-        r = fb.apply(a.limit());\n+        r = fb.apply((int) a.byteSize());\n@@ -643,2 +570,2 @@\n-                FloatVector av = FloatVector.fromByteBuffer(SPECIES, a, i, bo);\n-                av.intoByteBuffer(r, i, bo, vmask);\n+                FloatVector av = FloatVector.fromMemorySegment(SPECIES, a, i, bo);\n+                av.intoMemorySegment(r, i, bo, vmask);\n@@ -647,5 +574,1 @@\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        assertArraysEquals(bufferToArray(r), _a, mask);\n+        assertArraysEquals(segmentToArray(r), _a, mask);\n@@ -655,3 +578,3 @@\n-    static void loadByteBufferMaskIOOBE(IntFunction<float[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n+    static void loadMemorySegmentMaskIOOBE(IntFunction<float[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n@@ -661,1 +584,1 @@\n-        int l = a.limit();\n+        int l = (int) a.byteSize();\n@@ -666,2 +589,2 @@\n-                FloatVector av = fromByteBuffer(a, i, ByteOrder.nativeOrder(), vmask);\n-                av.intoByteBuffer(r, i, ByteOrder.nativeOrder());\n+                FloatVector av = fromMemorySegment(a, i, ByteOrder.nativeOrder(), vmask);\n+                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n@@ -671,2 +594,2 @@\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.limit(), SPECIES.elementSize() \/ 8);\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() \/ 8);\n@@ -674,1 +597,1 @@\n-            fromByteBuffer(a, index, ByteOrder.nativeOrder(), vmask);\n+            fromMemorySegment(a, index, ByteOrder.nativeOrder(), vmask);\n@@ -686,3 +609,3 @@\n-    static void storeByteBufferMaskIOOBE(IntFunction<float[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n+    static void storeMemorySegmentMaskIOOBE(IntFunction<float[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n@@ -692,83 +615,1 @@\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                FloatVector av = FloatVector.fromByteBuffer(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteBuffer(av, r, i, ByteOrder.nativeOrder(), vmask);\n-            }\n-        }\n-\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.limit(), SPECIES.elementSize() \/ 8);\n-        try {\n-            FloatVector av = FloatVector.fromByteBuffer(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteBuffer(av, a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"floatByteBufferProvider\")\n-    static void loadStoreReadonlyByteBuffer(IntFunction<float[]> fa,\n-                                    IntFunction<ByteBuffer> fb,\n-                                    ByteOrder bo) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), fb).asReadOnlyBuffer();\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo);\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, SPECIES.maskAll(true));\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, SPECIES.maskAll(false));\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            VectorMask<Float> m = SPECIES.shuffleFromOp(i -> i % 2 == 0 ? 1 : -1)\n-                    .laneIsValid();\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, m);\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"floatByteArrayProvider\")\n-    static void loadStoreByteArray(IntFunction<float[]> fa,\n-                                    ByteOrder bo) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, bo);\n-        byte[] r = new byte[a.length];\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                FloatVector av = FloatVector.fromByteArray(SPECIES, a, i, bo);\n-                av.intoByteArray(r, i, bo);\n-            }\n-        }\n-        Assert.assertEquals(r, a, \"Byte arrays not equal\");\n-    }\n-\n-    @Test(dataProvider = \"floatByteProviderForIOOBE\")\n-    static void loadByteArrayIOOBE(IntFunction<float[]> fa, IntFunction<Integer> fi) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-\n+        int l = (int) a.byteSize();\n@@ -776,1 +617,0 @@\n-        int l = a.length;\n@@ -780,2 +620,2 @@\n-                FloatVector av = fromByteArray(a, i, ByteOrder.nativeOrder());\n-                av.intoByteArray(r, i, ByteOrder.nativeOrder());\n+                FloatVector av = FloatVector.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+                intoMemorySegment(av, r, i, ByteOrder.nativeOrder(), vmask);\n@@ -785,2 +625,2 @@\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.length);\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() \/ 8);\n@@ -788,1 +628,2 @@\n-            fromByteArray(a, index, ByteOrder.nativeOrder());\n+            FloatVector av = FloatVector.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+            intoMemorySegment(av, a, index, ByteOrder.nativeOrder(), vmask);\n@@ -799,62 +640,5 @@\n-    @Test(dataProvider = \"floatByteProviderForIOOBE\")\n-    static void storeByteArrayIOOBE(IntFunction<float[]> fa, IntFunction<Integer> fi) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                FloatVector av = FloatVector.fromByteArray(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteArray(av, r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.length);\n-        try {\n-            FloatVector av = FloatVector.fromByteArray(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteArray(av, r, index, ByteOrder.nativeOrder());\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"floatByteArrayMaskProvider\")\n-    static void loadStoreByteArrayMask(IntFunction<float[]> fa,\n-                                  IntFunction<boolean[]> fm,\n-                                  ByteOrder bo) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, bo);\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Float> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-          for (int i = 0; i < l; i += s) {\n-              FloatVector av = FloatVector.fromByteArray(SPECIES, a, i, bo, vmask);\n-              av.intoByteArray(r, i, bo);\n-          }\n-        }\n-        assertArraysEquals(r, a, mask);\n-\n-\n-        r = new byte[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                FloatVector av = FloatVector.fromByteArray(SPECIES, a, i, bo);\n-                av.intoByteArray(r, i, bo, vmask);\n-            }\n-        }\n-        assertArraysEquals(r, a, mask);\n-    }\n+    @Test(dataProvider = \"floatMemorySegmentProvider\")\n+    static void loadStoreReadonlyMemorySegment(IntFunction<float[]> fa,\n+                                               IntFunction<MemorySegment> fb,\n+                                               ByteOrder bo) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb).asReadOnly();\n@@ -862,6 +646,4 @@\n-    @Test(dataProvider = \"floatByteMaskProviderForIOOBE\")\n-    static void loadByteArrayMaskIOOBE(IntFunction<float[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Float> vmask = VectorMask.fromValues(SPECIES, mask);\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo)\n+        );\n@@ -869,2 +651,4 @@\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(true))\n+        );\n@@ -872,6 +656,4 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                FloatVector av = fromByteArray(a, i, ByteOrder.nativeOrder(), vmask);\n-                av.intoByteArray(r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(false))\n+        );\n@@ -879,12 +661,6 @@\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length, SPECIES.elementSize() \/ 8);\n-        try {\n-            fromByteArray(a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n+        VectorMask<Float> m = SPECIES.shuffleFromOp(i -> i % 2 == 0 ? 1 : -1)\n+                .laneIsValid();\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, m)\n+        );\n@@ -893,31 +669,0 @@\n-    @Test(dataProvider = \"floatByteMaskProviderForIOOBE\")\n-    static void storeByteArrayMaskIOOBE(IntFunction<float[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Float> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                FloatVector av = FloatVector.fromByteArray(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteArray(av, r, i, ByteOrder.nativeOrder(), vmask);\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length, SPECIES.elementSize() \/ 8);\n-        try {\n-            FloatVector av = FloatVector.fromByteArray(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteArray(av, a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n@@ -939,0 +684,1 @@\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/FloatMaxVectorLoadStoreTests.java","additions":112,"deletions":366,"binary":false,"changes":478,"status":"modified"},{"patch":"@@ -68,1 +68,0 @@\n-    private static final float CONST_SHIFT = Float.SIZE \/ 2;\n@@ -269,0 +268,49 @@\n+    static void assertcompressArraysEquals(float[] r, float[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    Assert.assertEquals(r[i + k], (float)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (float)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals(float[] r, float[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        Assert.assertEquals(r[i + j], (float)0);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (float)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n@@ -1032,1 +1080,0 @@\n-\n@@ -1216,1 +1263,0 @@\n-\n@@ -1337,1 +1383,0 @@\n-\n@@ -1362,1 +1407,0 @@\n-\n@@ -1479,0 +1523,1 @@\n+\n@@ -1535,0 +1580,1 @@\n+\n@@ -1555,0 +1601,1 @@\n+\n@@ -1611,0 +1658,1 @@\n+\n@@ -1631,0 +1679,1 @@\n+\n@@ -1708,0 +1757,1 @@\n+\n@@ -1727,2 +1777,0 @@\n-\n-\n@@ -1767,2 +1815,0 @@\n-\n-\n@@ -1810,8 +1856,0 @@\n-\n-\n-\n-\n-\n-\n-\n-\n@@ -1911,1 +1949,0 @@\n-\n@@ -1926,2 +1963,0 @@\n-\n-\n@@ -1945,9 +1980,0 @@\n-\n-\n-\n-\n-\n-\n-\n-\n-\n@@ -1985,57 +2011,0 @@\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n@@ -2062,0 +2031,1 @@\n+\n@@ -2080,0 +2050,1 @@\n+\n@@ -2100,0 +2071,1 @@\n+\n@@ -2175,11 +2147,0 @@\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n@@ -2203,0 +2164,1 @@\n+\n@@ -2227,0 +2189,1 @@\n+\n@@ -2245,0 +2208,1 @@\n+\n@@ -2271,0 +2235,1 @@\n+\n@@ -2288,0 +2253,1 @@\n+\n@@ -2312,0 +2278,1 @@\n+\n@@ -2330,0 +2297,1 @@\n+\n@@ -2356,0 +2324,1 @@\n+\n@@ -2373,0 +2342,1 @@\n+\n@@ -2397,0 +2367,1 @@\n+\n@@ -2415,0 +2386,1 @@\n+\n@@ -2441,0 +2413,1 @@\n+\n@@ -2458,0 +2431,1 @@\n+\n@@ -2482,0 +2456,1 @@\n+\n@@ -2500,0 +2475,1 @@\n+\n@@ -2526,0 +2502,1 @@\n+\n@@ -2543,0 +2520,1 @@\n+\n@@ -2567,0 +2545,1 @@\n+\n@@ -2585,0 +2564,1 @@\n+\n@@ -2612,4 +2592,0 @@\n-\n-\n-\n-\n@@ -2633,0 +2609,1 @@\n+\n@@ -2673,0 +2650,1 @@\n+\n@@ -2755,1 +2733,0 @@\n-\n@@ -2797,1 +2774,0 @@\n-\n@@ -2839,1 +2815,0 @@\n-\n@@ -2859,1 +2834,0 @@\n-\n@@ -2902,1 +2876,0 @@\n-\n@@ -2945,1 +2918,0 @@\n-\n@@ -2965,1 +2937,0 @@\n-\n@@ -3008,1 +2979,0 @@\n-\n@@ -3051,1 +3021,0 @@\n-\n@@ -3094,1 +3063,0 @@\n-\n@@ -3137,9 +3105,0 @@\n-\n-\n-\n-\n-\n-\n-\n-\n-\n@@ -3162,1 +3121,0 @@\n-\n@@ -3199,1 +3157,0 @@\n-\n@@ -3236,1 +3193,0 @@\n-\n@@ -3273,1 +3229,0 @@\n-\n@@ -3352,0 +3307,37 @@\n+\n+    @Test(dataProvider = \"floatUnaryOpMaskProvider\")\n+    static void compressFloatMaxVectorTests(IntFunction<float[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.compress(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertcompressArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"floatUnaryOpMaskProvider\")\n+    static void expandFloatMaxVectorTests(IntFunction<float[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.expand(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertexpandArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n@@ -3522,4 +3514,0 @@\n-\n-\n-\n-\n@@ -3540,3 +3528,0 @@\n-\n-\n-\n@@ -3568,0 +3553,1 @@\n+\n@@ -3597,0 +3583,1 @@\n+\n@@ -3630,0 +3617,1 @@\n+\n@@ -3657,0 +3645,1 @@\n+\n@@ -3696,0 +3685,1 @@\n+\n@@ -3776,1 +3766,0 @@\n-\n@@ -3800,1 +3789,0 @@\n-\n@@ -3824,1 +3812,0 @@\n-\n@@ -3848,1 +3835,0 @@\n-\n@@ -3872,1 +3858,0 @@\n-\n@@ -3896,1 +3881,0 @@\n-\n@@ -3920,1 +3904,0 @@\n-\n@@ -3944,1 +3927,0 @@\n-\n@@ -3968,1 +3950,0 @@\n-\n@@ -3992,1 +3973,0 @@\n-\n@@ -4016,1 +3996,0 @@\n-\n@@ -4040,1 +4019,0 @@\n-\n@@ -4064,1 +4042,0 @@\n-\n@@ -4088,1 +4065,0 @@\n-\n@@ -4112,1 +4088,0 @@\n-\n@@ -4139,1 +4114,0 @@\n-\n@@ -4165,0 +4139,1 @@\n+\n@@ -4191,1 +4166,0 @@\n-\n@@ -4218,1 +4192,0 @@\n-\n@@ -4233,0 +4206,1 @@\n+\n@@ -4248,1 +4222,0 @@\n-\n@@ -4252,0 +4225,1 @@\n+\n@@ -4256,1 +4230,0 @@\n-\n@@ -4275,0 +4248,1 @@\n+\n@@ -4292,1 +4266,0 @@\n-\n@@ -4315,4 +4288,0 @@\n-\n-\n-\n-\n@@ -4349,1 +4318,0 @@\n-\n@@ -4388,3 +4356,0 @@\n-\n-\n-\n@@ -4405,0 +4370,1 @@\n+\n@@ -4420,1 +4386,0 @@\n-\n@@ -4439,3 +4404,0 @@\n-\n-\n-\n@@ -4554,7 +4516,0 @@\n-\n-\n-\n-\n-\n-\n-\n@@ -4569,2 +4524,0 @@\n-\n-\n@@ -4601,2 +4554,0 @@\n-\n-\n@@ -4621,1 +4572,0 @@\n-\n@@ -5023,0 +4973,17 @@\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCompressFloatMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        int trueCount = 0;\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                trueCount = vmask.trueCount();\n+                var rmask = vmask.compress();\n+                for (int j = 0; j < SPECIES.length(); j++)  {\n+                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);\n+                }\n+            }\n+        }\n+    }\n+\n@@ -5049,0 +5016,14 @@\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeLongFloatMaxVectorTestsSmokeTest(int offset) {\n+        long limit = SPECIES.length() * BUFFER_REPS;\n+        for (long i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i + offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                long index = i + j + offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n@@ -5069,0 +5050,8 @@\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundLongFloatMaxVectorTestsSmokeTest(int _length) {\n+        long length = _length;\n+        long actualLoopBound = SPECIES.loopBound(length);\n+        long expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+    }\n+\n@@ -5131,1 +5120,0 @@\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/FloatMaxVectorTests.java","additions":165,"deletions":177,"binary":false,"changes":342,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,3 @@\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.ValueLayout;\n@@ -42,2 +45,0 @@\n-import java.nio.ByteBuffer;\n-import java.nio.IntBuffer;\n@@ -45,1 +46,0 @@\n-import java.nio.ReadOnlyBufferException;\n@@ -70,11 +70,0 @@\n-    static void assertArraysEquals(byte[] r, byte[] a, boolean[] mask) {\n-        int i = 0;\n-        try {\n-            for (; i < a.length; i++) {\n-                Assert.assertEquals(r[i], mask[(i*8\/SPECIES.elementSize()) % SPECIES.length()] ? a[i] : (byte) 0);\n-            }\n-        } catch (AssertionError e) {\n-            Assert.assertEquals(r[i], mask[(i*8\/SPECIES.elementSize()) % SPECIES.length()] ? a[i] : (byte) 0, \"at index #\" + i);\n-        }\n-    }\n-\n@@ -120,1 +109,1 @@\n-    \/\/ Relative to byte[] array.length or ByteBuffer.limit()\n+    \/\/ Relative to byte[] array.length or MemorySegment.byteSize()\n@@ -191,1 +180,1 @@\n-    public Object[][] intByteBufferProvider() {\n+    public Object[][] intMemorySegmentProvider() {\n@@ -193,1 +182,1 @@\n-                flatMap(fa -> BYTE_BUFFER_GENERATORS.stream().\n+                flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n@@ -201,1 +190,1 @@\n-    public Object[][] intByteBufferMaskProvider() {\n+    public Object[][] intMemorySegmentMaskProvider() {\n@@ -204,1 +193,1 @@\n-                        flatMap(fa -> BYTE_BUFFER_GENERATORS.stream().\n+                        flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n@@ -211,19 +200,0 @@\n-    @DataProvider\n-    public Object[][] intByteArrayProvider() {\n-        return INT_GENERATORS.stream().\n-                flatMap(fa -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                    return new Object[]{fa, bo};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] intByteArrayMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> INT_GENERATORS.stream().\n-                    flatMap(fa -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                        return new Object[]{fa, fm, bo};\n-                    }))).\n-                toArray(Object[][]::new);\n-    }\n-\n@@ -249,4 +219,4 @@\n-    static ByteBuffer toBuffer(int[] a, IntFunction<ByteBuffer> fb) {\n-        ByteBuffer bb = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n-        for (int v : a) {\n-            bb.putInt(v);\n+    static MemorySegment toSegment(int[] a, IntFunction<MemorySegment> fb) {\n+        MemorySegment ms = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n+        for (int i = 0; i < a.length; i++) {\n+            ms.set(ValueLayout.JAVA_INT, i * SPECIES.elementSize() \/ 8 , a[i]);\n@@ -254,1 +224,1 @@\n-        return bb.clear();\n+        return ms;\n@@ -257,14 +227,2 @@\n-    static int[] bufferToArray(ByteBuffer bb) {\n-        IntBuffer db = bb.asIntBuffer();\n-        int[] d = new int[db.capacity()];\n-        db.get(0, d);\n-        return d;\n-    }\n-\n-    static byte[] toByteArray(int[] a, IntFunction<byte[]> fb, ByteOrder bo) {\n-        byte[] b = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n-        IntBuffer bb = ByteBuffer.wrap(b, 0, b.length).order(bo).asIntBuffer();\n-        for (int v : a) {\n-            bb.put(v);\n-        }\n-        return b;\n+    static int[] segmentToArray(MemorySegment ms) {\n+        return ms.toArray(ValueLayout.JAVA_INT);\n@@ -310,22 +268,2 @@\n-    static IntVector fromByteArray(byte[] a, int i, ByteOrder bo) {\n-        return IntVector.fromByteArray(SPECIES, a, i, bo);\n-    }\n-\n-    @DontInline\n-    static IntVector fromByteArray(byte[] a, int i, ByteOrder bo, VectorMask<Integer> m) {\n-        return IntVector.fromByteArray(SPECIES, a, i, bo, m);\n-    }\n-\n-    @DontInline\n-    static void intoByteArray(IntVector v, byte[] a, int i, ByteOrder bo) {\n-        v.intoByteArray(a, i, bo);\n-    }\n-\n-    @DontInline\n-    static void intoByteArray(IntVector v, byte[] a, int i, ByteOrder bo, VectorMask<Integer> m) {\n-        v.intoByteArray(a, i, bo, m);\n-    }\n-\n-    @DontInline\n-    static IntVector fromByteBuffer(ByteBuffer a, int i, ByteOrder bo) {\n-        return IntVector.fromByteBuffer(SPECIES, a, i, bo);\n+    static IntVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo) {\n+        return IntVector.fromMemorySegment(SPECIES, a, i, bo);\n@@ -335,2 +273,2 @@\n-    static IntVector fromByteBuffer(ByteBuffer a, int i, ByteOrder bo, VectorMask<Integer> m) {\n-        return IntVector.fromByteBuffer(SPECIES, a, i, bo, m);\n+    static IntVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo, VectorMask<Integer> m) {\n+        return IntVector.fromMemorySegment(SPECIES, a, i, bo, m);\n@@ -340,2 +278,2 @@\n-    static void intoByteBuffer(IntVector v, ByteBuffer a, int i, ByteOrder bo) {\n-        v.intoByteBuffer(a, i, bo);\n+    static void intoMemorySegment(IntVector v, MemorySegment a, int i, ByteOrder bo) {\n+        v.intoMemorySegment(a, i, bo);\n@@ -345,2 +283,2 @@\n-    static void intoByteBuffer(IntVector v, ByteBuffer a, int i, ByteOrder bo, VectorMask<Integer> m) {\n-        v.intoByteBuffer(a, i, bo, m);\n+    static void intoMemorySegment(IntVector v, MemorySegment a, int i, ByteOrder bo, VectorMask<Integer> m) {\n+        v.intoMemorySegment(a, i, bo, m);\n@@ -349,1 +287,0 @@\n-\n@@ -520,6 +457,6 @@\n-    @Test(dataProvider = \"intByteBufferProvider\")\n-    static void loadStoreByteBuffer(IntFunction<int[]> fa,\n-                                    IntFunction<ByteBuffer> fb,\n-                                    ByteOrder bo) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), fb);\n-        ByteBuffer r = fb.apply(a.limit());\n+    @Test(dataProvider = \"intMemorySegmentProvider\")\n+    static void loadStoreMemorySegment(IntFunction<int[]> fa,\n+                                       IntFunction<MemorySegment> fb,\n+                                       ByteOrder bo) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb);\n+        MemorySegment r = fb.apply((int) a.byteSize());\n@@ -527,1 +464,1 @@\n-        int l = a.limit();\n+        int l = (int) a.byteSize();\n@@ -532,2 +469,2 @@\n-                IntVector av = IntVector.fromByteBuffer(SPECIES, a, i, bo);\n-                av.intoByteBuffer(r, i, bo);\n+                IntVector av = IntVector.fromMemorySegment(SPECIES, a, i, bo);\n+                av.intoMemorySegment(r, i, bo);\n@@ -536,5 +473,2 @@\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        Assert.assertEquals(r, a, \"Buffers not equal\");\n+        long m = r.mismatch(a);\n+        Assert.assertEquals(m, -1, \"Segments not equal\");\n@@ -544,3 +478,3 @@\n-    static void loadByteBufferIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n+    static void loadMemorySegmentIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n@@ -548,1 +482,1 @@\n-        int l = a.limit();\n+        int l = (int) a.byteSize();\n@@ -553,2 +487,2 @@\n-                IntVector av = fromByteBuffer(a, i, ByteOrder.nativeOrder());\n-                av.intoByteBuffer(r, i, ByteOrder.nativeOrder());\n+                IntVector av = fromMemorySegment(a, i, ByteOrder.nativeOrder());\n+                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n@@ -558,2 +492,2 @@\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.limit());\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());\n@@ -561,1 +495,1 @@\n-            fromByteBuffer(a, index, ByteOrder.nativeOrder());\n+            fromMemorySegment(a, index, ByteOrder.nativeOrder());\n@@ -573,3 +507,3 @@\n-    static void storeByteBufferIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n+    static void storeMemorySegmentIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n@@ -577,1 +511,1 @@\n-        int l = a.limit();\n+        int l = (int) a.byteSize();\n@@ -582,2 +516,2 @@\n-                IntVector av = IntVector.fromByteBuffer(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteBuffer(av, r, i, ByteOrder.nativeOrder());\n+                IntVector av = IntVector.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+                intoMemorySegment(av, r, i, ByteOrder.nativeOrder());\n@@ -587,2 +521,2 @@\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.limit());\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());\n@@ -590,2 +524,2 @@\n-            IntVector av = IntVector.fromByteBuffer(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteBuffer(av, r, index, ByteOrder.nativeOrder());\n+            IntVector av = IntVector.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+            intoMemorySegment(av, r, index, ByteOrder.nativeOrder());\n@@ -602,6 +536,5 @@\n-\n-    @Test(dataProvider = \"intByteBufferMaskProvider\")\n-    static void loadStoreByteBufferMask(IntFunction<int[]> fa,\n-                                        IntFunction<ByteBuffer> fb,\n-                                        IntFunction<boolean[]> fm,\n-                                        ByteOrder bo) {\n+    @Test(dataProvider = \"intMemorySegmentMaskProvider\")\n+    static void loadStoreMemorySegmentMask(IntFunction<int[]> fa,\n+                                           IntFunction<MemorySegment> fb,\n+                                           IntFunction<boolean[]> fm,\n+                                           ByteOrder bo) {\n@@ -609,2 +542,2 @@\n-        ByteBuffer a = toBuffer(_a, fb);\n-        ByteBuffer r = fb.apply(a.limit());\n+        MemorySegment a = toSegment(_a, fb);\n+        MemorySegment r = fb.apply((int) a.byteSize());\n@@ -614,1 +547,1 @@\n-        int l = a.limit();\n+        int l = (int) a.byteSize();\n@@ -619,2 +552,2 @@\n-                IntVector av = IntVector.fromByteBuffer(SPECIES, a, i, bo, vmask);\n-                av.intoByteBuffer(r, i, bo);\n+                IntVector av = IntVector.fromMemorySegment(SPECIES, a, i, bo, vmask);\n+                av.intoMemorySegment(r, i, bo);\n@@ -623,5 +556,1 @@\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        assertArraysEquals(bufferToArray(r), _a, mask);\n+        assertArraysEquals(segmentToArray(r), _a, mask);\n@@ -630,1 +559,1 @@\n-        r = fb.apply(a.limit());\n+        r = fb.apply((int) a.byteSize());\n@@ -634,2 +563,2 @@\n-                IntVector av = IntVector.fromByteBuffer(SPECIES, a, i, bo);\n-                av.intoByteBuffer(r, i, bo, vmask);\n+                IntVector av = IntVector.fromMemorySegment(SPECIES, a, i, bo);\n+                av.intoMemorySegment(r, i, bo, vmask);\n@@ -638,5 +567,1 @@\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        assertArraysEquals(bufferToArray(r), _a, mask);\n+        assertArraysEquals(segmentToArray(r), _a, mask);\n@@ -646,3 +571,3 @@\n-    static void loadByteBufferMaskIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n+    static void loadMemorySegmentMaskIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n@@ -652,1 +577,1 @@\n-        int l = a.limit();\n+        int l = (int) a.byteSize();\n@@ -657,2 +582,2 @@\n-                IntVector av = fromByteBuffer(a, i, ByteOrder.nativeOrder(), vmask);\n-                av.intoByteBuffer(r, i, ByteOrder.nativeOrder());\n+                IntVector av = fromMemorySegment(a, i, ByteOrder.nativeOrder(), vmask);\n+                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n@@ -662,2 +587,2 @@\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.limit(), SPECIES.elementSize() \/ 8);\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() \/ 8);\n@@ -665,1 +590,1 @@\n-            fromByteBuffer(a, index, ByteOrder.nativeOrder(), vmask);\n+            fromMemorySegment(a, index, ByteOrder.nativeOrder(), vmask);\n@@ -677,3 +602,3 @@\n-    static void storeByteBufferMaskIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n+    static void storeMemorySegmentMaskIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n@@ -683,83 +608,1 @@\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                IntVector av = IntVector.fromByteBuffer(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteBuffer(av, r, i, ByteOrder.nativeOrder(), vmask);\n-            }\n-        }\n-\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.limit(), SPECIES.elementSize() \/ 8);\n-        try {\n-            IntVector av = IntVector.fromByteBuffer(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteBuffer(av, a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"intByteBufferProvider\")\n-    static void loadStoreReadonlyByteBuffer(IntFunction<int[]> fa,\n-                                    IntFunction<ByteBuffer> fb,\n-                                    ByteOrder bo) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), fb).asReadOnlyBuffer();\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo);\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, SPECIES.maskAll(true));\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, SPECIES.maskAll(false));\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            VectorMask<Integer> m = SPECIES.shuffleFromOp(i -> i % 2 == 0 ? 1 : -1)\n-                    .laneIsValid();\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, m);\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"intByteArrayProvider\")\n-    static void loadStoreByteArray(IntFunction<int[]> fa,\n-                                    ByteOrder bo) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, bo);\n-        byte[] r = new byte[a.length];\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                IntVector av = IntVector.fromByteArray(SPECIES, a, i, bo);\n-                av.intoByteArray(r, i, bo);\n-            }\n-        }\n-        Assert.assertEquals(r, a, \"Byte arrays not equal\");\n-    }\n-\n-    @Test(dataProvider = \"intByteProviderForIOOBE\")\n-    static void loadByteArrayIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-\n+        int l = (int) a.byteSize();\n@@ -767,1 +610,0 @@\n-        int l = a.length;\n@@ -771,2 +613,2 @@\n-                IntVector av = fromByteArray(a, i, ByteOrder.nativeOrder());\n-                av.intoByteArray(r, i, ByteOrder.nativeOrder());\n+                IntVector av = IntVector.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+                intoMemorySegment(av, r, i, ByteOrder.nativeOrder(), vmask);\n@@ -776,2 +618,2 @@\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.length);\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() \/ 8);\n@@ -779,1 +621,2 @@\n-            fromByteArray(a, index, ByteOrder.nativeOrder());\n+            IntVector av = IntVector.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+            intoMemorySegment(av, a, index, ByteOrder.nativeOrder(), vmask);\n@@ -790,62 +633,5 @@\n-    @Test(dataProvider = \"intByteProviderForIOOBE\")\n-    static void storeByteArrayIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                IntVector av = IntVector.fromByteArray(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteArray(av, r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.length);\n-        try {\n-            IntVector av = IntVector.fromByteArray(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteArray(av, r, index, ByteOrder.nativeOrder());\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"intByteArrayMaskProvider\")\n-    static void loadStoreByteArrayMask(IntFunction<int[]> fa,\n-                                  IntFunction<boolean[]> fm,\n-                                  ByteOrder bo) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, bo);\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Integer> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-          for (int i = 0; i < l; i += s) {\n-              IntVector av = IntVector.fromByteArray(SPECIES, a, i, bo, vmask);\n-              av.intoByteArray(r, i, bo);\n-          }\n-        }\n-        assertArraysEquals(r, a, mask);\n-\n-\n-        r = new byte[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                IntVector av = IntVector.fromByteArray(SPECIES, a, i, bo);\n-                av.intoByteArray(r, i, bo, vmask);\n-            }\n-        }\n-        assertArraysEquals(r, a, mask);\n-    }\n+    @Test(dataProvider = \"intMemorySegmentProvider\")\n+    static void loadStoreReadonlyMemorySegment(IntFunction<int[]> fa,\n+                                               IntFunction<MemorySegment> fb,\n+                                               ByteOrder bo) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb).asReadOnly();\n@@ -853,6 +639,4 @@\n-    @Test(dataProvider = \"intByteMaskProviderForIOOBE\")\n-    static void loadByteArrayMaskIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Integer> vmask = VectorMask.fromValues(SPECIES, mask);\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo)\n+        );\n@@ -860,2 +644,4 @@\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(true))\n+        );\n@@ -863,6 +649,4 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                IntVector av = fromByteArray(a, i, ByteOrder.nativeOrder(), vmask);\n-                av.intoByteArray(r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(false))\n+        );\n@@ -870,12 +654,6 @@\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length, SPECIES.elementSize() \/ 8);\n-        try {\n-            fromByteArray(a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n+        VectorMask<Integer> m = SPECIES.shuffleFromOp(i -> i % 2 == 0 ? 1 : -1)\n+                .laneIsValid();\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, m)\n+        );\n@@ -884,31 +662,0 @@\n-    @Test(dataProvider = \"intByteMaskProviderForIOOBE\")\n-    static void storeByteArrayMaskIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Integer> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                IntVector av = IntVector.fromByteArray(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteArray(av, r, i, ByteOrder.nativeOrder(), vmask);\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length, SPECIES.elementSize() \/ 8);\n-        try {\n-            IntVector av = IntVector.fromByteArray(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteArray(av, a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n@@ -930,0 +677,1 @@\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int128VectorLoadStoreTests.java","additions":112,"deletions":364,"binary":false,"changes":476,"status":"modified"},{"patch":"@@ -264,0 +264,49 @@\n+    static void assertcompressArraysEquals(int[] r, int[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    Assert.assertEquals(r[i + k], (int)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (int)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals(int[] r, int[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        Assert.assertEquals(r[i + j], (int)0);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (int)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n@@ -887,1 +936,0 @@\n-\n@@ -982,2 +1030,0 @@\n-\n-\n@@ -1029,1 +1075,0 @@\n-\n@@ -1170,0 +1215,12 @@\n+    static int TRAILING_ZEROS_COUNT_scalar(int a) {\n+        return Integer.numberOfTrailingZeros(a);\n+    }\n+\n+    static int LEADING_ZEROS_COUNT_scalar(int a) {\n+        return Integer.numberOfLeadingZeros(a);\n+    }\n+\n+    static int REVERSE_scalar(int a) {\n+        return Integer.reverse(a);\n+    }\n+\n@@ -1324,0 +1381,1 @@\n+\n@@ -1344,0 +1402,1 @@\n+\n@@ -1400,0 +1459,1 @@\n+\n@@ -1420,0 +1480,1 @@\n+\n@@ -1476,0 +1537,1 @@\n+\n@@ -1496,0 +1558,1 @@\n+\n@@ -1553,2 +1616,0 @@\n-\n-\n@@ -1577,0 +1638,1 @@\n+\n@@ -1600,2 +1662,0 @@\n-\n-\n@@ -1707,0 +1767,1 @@\n+\n@@ -1726,2 +1787,0 @@\n-\n-\n@@ -1748,1 +1807,0 @@\n-\n@@ -1770,2 +1828,0 @@\n-\n-\n@@ -1792,1 +1848,0 @@\n-\n@@ -1813,0 +1868,1 @@\n+\n@@ -1832,2 +1888,0 @@\n-\n-\n@@ -1854,1 +1908,0 @@\n-\n@@ -1876,2 +1929,0 @@\n-\n-\n@@ -1898,0 +1949,81 @@\n+    static int COMPRESS_BITS(int a, int b) {\n+        return (int)(Integer.compress(a, b));\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpProvider\")\n+    static void COMPRESS_BITSInt128VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.COMPRESS_BITS, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Int128VectorTests::COMPRESS_BITS);\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpMaskProvider\")\n+    static void COMPRESS_BITSInt128VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.COMPRESS_BITS, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Int128VectorTests::COMPRESS_BITS);\n+    }\n+\n+    static int EXPAND_BITS(int a, int b) {\n+        return (int)(Integer.expand(a, b));\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpProvider\")\n+    static void EXPAND_BITSInt128VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.EXPAND_BITS, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Int128VectorTests::EXPAND_BITS);\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpMaskProvider\")\n+    static void EXPAND_BITSInt128VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.EXPAND_BITS, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Int128VectorTests::EXPAND_BITS);\n+    }\n@@ -1992,3 +2124,0 @@\n-\n-\n-\n@@ -2011,2 +2140,0 @@\n-\n-\n@@ -2032,2 +2159,0 @@\n-\n-\n@@ -2062,2 +2187,0 @@\n-\n-\n@@ -2081,2 +2204,0 @@\n-\n-\n@@ -2111,2 +2232,0 @@\n-\n-\n@@ -2130,2 +2249,0 @@\n-\n-\n@@ -2146,2 +2263,0 @@\n-\n-\n@@ -2165,1 +2280,0 @@\n-\n@@ -2218,2 +2332,0 @@\n-\n-\n@@ -2240,5 +2352,0 @@\n-\n-\n-\n-\n-\n@@ -2266,2 +2373,0 @@\n-\n-\n@@ -2288,5 +2393,0 @@\n-\n-\n-\n-\n-\n@@ -2314,2 +2414,0 @@\n-\n-\n@@ -2336,5 +2434,0 @@\n-\n-\n-\n-\n-\n@@ -2361,2 +2454,0 @@\n-\n-\n@@ -2382,5 +2473,0 @@\n-\n-\n-\n-\n-\n@@ -2407,2 +2493,0 @@\n-\n-\n@@ -2428,5 +2512,0 @@\n-\n-\n-\n-\n-\n@@ -2453,2 +2532,0 @@\n-\n-\n@@ -2474,5 +2551,0 @@\n-\n-\n-\n-\n-\n@@ -2500,2 +2572,0 @@\n-\n-\n@@ -2522,1 +2592,0 @@\n-\n@@ -2544,2 +2613,0 @@\n-\n-\n@@ -2566,1 +2633,0 @@\n-\n@@ -2587,2 +2653,0 @@\n-\n-\n@@ -2608,1 +2672,0 @@\n-\n@@ -2629,2 +2692,0 @@\n-\n-\n@@ -2649,2 +2710,0 @@\n-\n-\n@@ -2670,2 +2729,0 @@\n-\n-\n@@ -2690,6 +2747,0 @@\n-\n-\n-\n-\n-\n-\n@@ -2715,2 +2766,0 @@\n-\n-\n@@ -2735,2 +2784,0 @@\n-\n-\n@@ -2756,2 +2803,0 @@\n-\n-\n@@ -2776,2 +2821,0 @@\n-\n-\n@@ -2797,2 +2840,0 @@\n-\n-\n@@ -2817,2 +2858,0 @@\n-\n-\n@@ -2838,2 +2877,0 @@\n-\n-\n@@ -2879,0 +2916,1 @@\n+\n@@ -2897,0 +2935,1 @@\n+\n@@ -2917,0 +2956,1 @@\n+\n@@ -3010,1 +3050,0 @@\n-\n@@ -3036,1 +3075,0 @@\n-\n@@ -3056,1 +3094,0 @@\n-\n@@ -3084,1 +3121,0 @@\n-\n@@ -3103,1 +3139,0 @@\n-\n@@ -3129,1 +3164,0 @@\n-\n@@ -3149,1 +3183,0 @@\n-\n@@ -3177,1 +3210,0 @@\n-\n@@ -3196,1 +3228,0 @@\n-\n@@ -3222,1 +3253,0 @@\n-\n@@ -3242,1 +3272,0 @@\n-\n@@ -3287,0 +3316,1 @@\n+\n@@ -3311,0 +3341,1 @@\n+\n@@ -3329,0 +3360,1 @@\n+\n@@ -3355,0 +3387,1 @@\n+\n@@ -3372,0 +3405,1 @@\n+\n@@ -3396,0 +3430,1 @@\n+\n@@ -3414,0 +3449,1 @@\n+\n@@ -3440,0 +3476,1 @@\n+\n@@ -3457,0 +3494,1 @@\n+\n@@ -3481,0 +3519,1 @@\n+\n@@ -3499,0 +3538,1 @@\n+\n@@ -3525,0 +3565,1 @@\n+\n@@ -3542,0 +3583,1 @@\n+\n@@ -3566,0 +3608,1 @@\n+\n@@ -3584,0 +3627,1 @@\n+\n@@ -3610,0 +3654,1 @@\n+\n@@ -3627,0 +3672,1 @@\n+\n@@ -3651,0 +3697,1 @@\n+\n@@ -3669,0 +3716,1 @@\n+\n@@ -3705,1 +3753,0 @@\n-\n@@ -3721,1 +3768,0 @@\n-\n@@ -3731,1 +3777,0 @@\n-\n@@ -3747,1 +3792,0 @@\n-\n@@ -3765,0 +3809,1 @@\n+\n@@ -3805,0 +3850,1 @@\n+\n@@ -3846,3 +3892,0 @@\n-\n-\n-\n@@ -3868,1 +3911,0 @@\n-\n@@ -3911,1 +3953,0 @@\n-\n@@ -3954,1 +3995,0 @@\n-\n@@ -3974,1 +4014,0 @@\n-\n@@ -4017,1 +4056,0 @@\n-\n@@ -4060,1 +4098,0 @@\n-\n@@ -4103,1 +4140,0 @@\n-\n@@ -4146,2 +4182,0 @@\n-\n-\n@@ -4167,2 +4201,0 @@\n-\n-\n@@ -4192,3 +4224,0 @@\n-\n-\n-\n@@ -4214,2 +4243,0 @@\n-\n-\n@@ -4239,3 +4266,0 @@\n-\n-\n-\n@@ -4261,2 +4285,0 @@\n-\n-\n@@ -4286,3 +4308,0 @@\n-\n-\n-\n@@ -4308,2 +4327,0 @@\n-\n-\n@@ -4333,2 +4350,0 @@\n-\n-\n@@ -4351,1 +4366,0 @@\n-\n@@ -4388,1 +4402,0 @@\n-\n@@ -4425,1 +4438,0 @@\n-\n@@ -4462,1 +4474,0 @@\n-\n@@ -4541,0 +4552,37 @@\n+\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void compressInt128VectorTests(IntFunction<int[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.compress(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertcompressArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void expandInt128VectorTests(IntFunction<int[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.expand(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertexpandArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n@@ -4711,4 +4759,0 @@\n-\n-\n-\n-\n@@ -4729,3 +4773,0 @@\n-\n-\n-\n@@ -4757,0 +4798,1 @@\n+\n@@ -4786,0 +4828,1 @@\n+\n@@ -4819,0 +4862,1 @@\n+\n@@ -4846,0 +4890,1 @@\n+\n@@ -4885,0 +4930,1 @@\n+\n@@ -4942,22 +4988,0 @@\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n@@ -4967,0 +4991,1 @@\n+\n@@ -4971,1 +4996,0 @@\n-\n@@ -4990,0 +5014,1 @@\n+\n@@ -5007,1 +5032,0 @@\n-\n@@ -5030,3 +5054,0 @@\n-\n-\n-\n@@ -5062,0 +5083,1 @@\n+\n@@ -5092,1 +5114,0 @@\n-\n@@ -5131,3 +5152,0 @@\n-\n-\n-\n@@ -5148,0 +5166,1 @@\n+\n@@ -5163,1 +5182,0 @@\n-\n@@ -5182,1 +5200,0 @@\n-\n@@ -5295,1 +5312,0 @@\n-\n@@ -5304,2 +5320,0 @@\n-\n-\n@@ -5336,2 +5350,0 @@\n-\n-\n@@ -5356,2 +5368,0 @@\n-\n-\n@@ -5362,2 +5372,0 @@\n-\n-\n@@ -5379,2 +5387,0 @@\n-\n-\n@@ -5399,0 +5405,3 @@\n+    static int BIT_COUNT(int a) {\n+        return (int)(Integer.bitCount(a));\n+    }\n@@ -5400,0 +5409,4 @@\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void BIT_COUNTInt128VectorTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n@@ -5401,0 +5414,9 @@\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Int128VectorTests::BIT_COUNT);\n+    }\n@@ -5402,0 +5424,165 @@\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void BIT_COUNTMaskedInt128VectorTests(IntFunction<int[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Int128VectorTests::BIT_COUNT);\n+    }\n+\n+    static int TRAILING_ZEROS_COUNT(int a) {\n+        return (int)(TRAILING_ZEROS_COUNT_scalar(a));\n+    }\n+\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void TRAILING_ZEROS_COUNTInt128VectorTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TRAILING_ZEROS_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Int128VectorTests::TRAILING_ZEROS_COUNT);\n+    }\n+\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void TRAILING_ZEROS_COUNTMaskedInt128VectorTests(IntFunction<int[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TRAILING_ZEROS_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Int128VectorTests::TRAILING_ZEROS_COUNT);\n+    }\n+\n+    static int LEADING_ZEROS_COUNT(int a) {\n+        return (int)(LEADING_ZEROS_COUNT_scalar(a));\n+    }\n+\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void LEADING_ZEROS_COUNTInt128VectorTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LEADING_ZEROS_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Int128VectorTests::LEADING_ZEROS_COUNT);\n+    }\n+\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void LEADING_ZEROS_COUNTMaskedInt128VectorTests(IntFunction<int[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LEADING_ZEROS_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Int128VectorTests::LEADING_ZEROS_COUNT);\n+    }\n+\n+    static int REVERSE(int a) {\n+        return (int)(REVERSE_scalar(a));\n+    }\n+\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void REVERSEInt128VectorTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Int128VectorTests::REVERSE);\n+    }\n+\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void REVERSEMaskedInt128VectorTests(IntFunction<int[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Int128VectorTests::REVERSE);\n+    }\n+\n+    static int REVERSE_BYTES(int a) {\n+        return (int)(Integer.reverseBytes(a));\n+    }\n+\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void REVERSE_BYTESInt128VectorTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Int128VectorTests::REVERSE_BYTES);\n+    }\n+\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void REVERSE_BYTESMaskedInt128VectorTests(IntFunction<int[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Int128VectorTests::REVERSE_BYTES);\n+    }\n@@ -5804,0 +5991,17 @@\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCompressInt128VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        int trueCount = 0;\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                trueCount = vmask.trueCount();\n+                var rmask = vmask.compress();\n+                for (int j = 0; j < SPECIES.length(); j++)  {\n+                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);\n+                }\n+            }\n+        }\n+    }\n+\n@@ -5846,0 +6050,14 @@\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeLongInt128VectorTestsSmokeTest(int offset) {\n+        long limit = SPECIES.length() * BUFFER_REPS;\n+        for (long i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i + offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                long index = i + j + offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n@@ -5866,0 +6084,8 @@\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundLongInt128VectorTestsSmokeTest(int _length) {\n+        long length = _length;\n+        long actualLoopBound = SPECIES.loopBound(length);\n+        long expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+    }\n+\n@@ -5928,1 +6154,0 @@\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int128VectorTests.java","additions":441,"deletions":216,"binary":false,"changes":657,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,3 @@\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.ValueLayout;\n@@ -42,2 +45,0 @@\n-import java.nio.ByteBuffer;\n-import java.nio.IntBuffer;\n@@ -45,1 +46,0 @@\n-import java.nio.ReadOnlyBufferException;\n@@ -70,11 +70,0 @@\n-    static void assertArraysEquals(byte[] r, byte[] a, boolean[] mask) {\n-        int i = 0;\n-        try {\n-            for (; i < a.length; i++) {\n-                Assert.assertEquals(r[i], mask[(i*8\/SPECIES.elementSize()) % SPECIES.length()] ? a[i] : (byte) 0);\n-            }\n-        } catch (AssertionError e) {\n-            Assert.assertEquals(r[i], mask[(i*8\/SPECIES.elementSize()) % SPECIES.length()] ? a[i] : (byte) 0, \"at index #\" + i);\n-        }\n-    }\n-\n@@ -120,1 +109,1 @@\n-    \/\/ Relative to byte[] array.length or ByteBuffer.limit()\n+    \/\/ Relative to byte[] array.length or MemorySegment.byteSize()\n@@ -191,1 +180,1 @@\n-    public Object[][] intByteBufferProvider() {\n+    public Object[][] intMemorySegmentProvider() {\n@@ -193,1 +182,1 @@\n-                flatMap(fa -> BYTE_BUFFER_GENERATORS.stream().\n+                flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n@@ -201,1 +190,1 @@\n-    public Object[][] intByteBufferMaskProvider() {\n+    public Object[][] intMemorySegmentMaskProvider() {\n@@ -204,1 +193,1 @@\n-                        flatMap(fa -> BYTE_BUFFER_GENERATORS.stream().\n+                        flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n@@ -211,19 +200,0 @@\n-    @DataProvider\n-    public Object[][] intByteArrayProvider() {\n-        return INT_GENERATORS.stream().\n-                flatMap(fa -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                    return new Object[]{fa, bo};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] intByteArrayMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> INT_GENERATORS.stream().\n-                    flatMap(fa -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                        return new Object[]{fa, fm, bo};\n-                    }))).\n-                toArray(Object[][]::new);\n-    }\n-\n@@ -249,4 +219,4 @@\n-    static ByteBuffer toBuffer(int[] a, IntFunction<ByteBuffer> fb) {\n-        ByteBuffer bb = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n-        for (int v : a) {\n-            bb.putInt(v);\n+    static MemorySegment toSegment(int[] a, IntFunction<MemorySegment> fb) {\n+        MemorySegment ms = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n+        for (int i = 0; i < a.length; i++) {\n+            ms.set(ValueLayout.JAVA_INT, i * SPECIES.elementSize() \/ 8 , a[i]);\n@@ -254,1 +224,1 @@\n-        return bb.clear();\n+        return ms;\n@@ -257,14 +227,2 @@\n-    static int[] bufferToArray(ByteBuffer bb) {\n-        IntBuffer db = bb.asIntBuffer();\n-        int[] d = new int[db.capacity()];\n-        db.get(0, d);\n-        return d;\n-    }\n-\n-    static byte[] toByteArray(int[] a, IntFunction<byte[]> fb, ByteOrder bo) {\n-        byte[] b = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n-        IntBuffer bb = ByteBuffer.wrap(b, 0, b.length).order(bo).asIntBuffer();\n-        for (int v : a) {\n-            bb.put(v);\n-        }\n-        return b;\n+    static int[] segmentToArray(MemorySegment ms) {\n+        return ms.toArray(ValueLayout.JAVA_INT);\n@@ -310,22 +268,2 @@\n-    static IntVector fromByteArray(byte[] a, int i, ByteOrder bo) {\n-        return IntVector.fromByteArray(SPECIES, a, i, bo);\n-    }\n-\n-    @DontInline\n-    static IntVector fromByteArray(byte[] a, int i, ByteOrder bo, VectorMask<Integer> m) {\n-        return IntVector.fromByteArray(SPECIES, a, i, bo, m);\n-    }\n-\n-    @DontInline\n-    static void intoByteArray(IntVector v, byte[] a, int i, ByteOrder bo) {\n-        v.intoByteArray(a, i, bo);\n-    }\n-\n-    @DontInline\n-    static void intoByteArray(IntVector v, byte[] a, int i, ByteOrder bo, VectorMask<Integer> m) {\n-        v.intoByteArray(a, i, bo, m);\n-    }\n-\n-    @DontInline\n-    static IntVector fromByteBuffer(ByteBuffer a, int i, ByteOrder bo) {\n-        return IntVector.fromByteBuffer(SPECIES, a, i, bo);\n+    static IntVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo) {\n+        return IntVector.fromMemorySegment(SPECIES, a, i, bo);\n@@ -335,2 +273,2 @@\n-    static IntVector fromByteBuffer(ByteBuffer a, int i, ByteOrder bo, VectorMask<Integer> m) {\n-        return IntVector.fromByteBuffer(SPECIES, a, i, bo, m);\n+    static IntVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo, VectorMask<Integer> m) {\n+        return IntVector.fromMemorySegment(SPECIES, a, i, bo, m);\n@@ -340,2 +278,2 @@\n-    static void intoByteBuffer(IntVector v, ByteBuffer a, int i, ByteOrder bo) {\n-        v.intoByteBuffer(a, i, bo);\n+    static void intoMemorySegment(IntVector v, MemorySegment a, int i, ByteOrder bo) {\n+        v.intoMemorySegment(a, i, bo);\n@@ -345,2 +283,2 @@\n-    static void intoByteBuffer(IntVector v, ByteBuffer a, int i, ByteOrder bo, VectorMask<Integer> m) {\n-        v.intoByteBuffer(a, i, bo, m);\n+    static void intoMemorySegment(IntVector v, MemorySegment a, int i, ByteOrder bo, VectorMask<Integer> m) {\n+        v.intoMemorySegment(a, i, bo, m);\n@@ -349,1 +287,0 @@\n-\n@@ -520,6 +457,6 @@\n-    @Test(dataProvider = \"intByteBufferProvider\")\n-    static void loadStoreByteBuffer(IntFunction<int[]> fa,\n-                                    IntFunction<ByteBuffer> fb,\n-                                    ByteOrder bo) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), fb);\n-        ByteBuffer r = fb.apply(a.limit());\n+    @Test(dataProvider = \"intMemorySegmentProvider\")\n+    static void loadStoreMemorySegment(IntFunction<int[]> fa,\n+                                       IntFunction<MemorySegment> fb,\n+                                       ByteOrder bo) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb);\n+        MemorySegment r = fb.apply((int) a.byteSize());\n@@ -527,1 +464,1 @@\n-        int l = a.limit();\n+        int l = (int) a.byteSize();\n@@ -532,2 +469,2 @@\n-                IntVector av = IntVector.fromByteBuffer(SPECIES, a, i, bo);\n-                av.intoByteBuffer(r, i, bo);\n+                IntVector av = IntVector.fromMemorySegment(SPECIES, a, i, bo);\n+                av.intoMemorySegment(r, i, bo);\n@@ -536,5 +473,2 @@\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        Assert.assertEquals(r, a, \"Buffers not equal\");\n+        long m = r.mismatch(a);\n+        Assert.assertEquals(m, -1, \"Segments not equal\");\n@@ -544,3 +478,3 @@\n-    static void loadByteBufferIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n+    static void loadMemorySegmentIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n@@ -548,1 +482,1 @@\n-        int l = a.limit();\n+        int l = (int) a.byteSize();\n@@ -553,2 +487,2 @@\n-                IntVector av = fromByteBuffer(a, i, ByteOrder.nativeOrder());\n-                av.intoByteBuffer(r, i, ByteOrder.nativeOrder());\n+                IntVector av = fromMemorySegment(a, i, ByteOrder.nativeOrder());\n+                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n@@ -558,2 +492,2 @@\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.limit());\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());\n@@ -561,1 +495,1 @@\n-            fromByteBuffer(a, index, ByteOrder.nativeOrder());\n+            fromMemorySegment(a, index, ByteOrder.nativeOrder());\n@@ -573,3 +507,3 @@\n-    static void storeByteBufferIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n+    static void storeMemorySegmentIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n@@ -577,1 +511,1 @@\n-        int l = a.limit();\n+        int l = (int) a.byteSize();\n@@ -582,2 +516,2 @@\n-                IntVector av = IntVector.fromByteBuffer(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteBuffer(av, r, i, ByteOrder.nativeOrder());\n+                IntVector av = IntVector.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+                intoMemorySegment(av, r, i, ByteOrder.nativeOrder());\n@@ -587,2 +521,2 @@\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.limit());\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());\n@@ -590,2 +524,2 @@\n-            IntVector av = IntVector.fromByteBuffer(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteBuffer(av, r, index, ByteOrder.nativeOrder());\n+            IntVector av = IntVector.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+            intoMemorySegment(av, r, index, ByteOrder.nativeOrder());\n@@ -602,6 +536,5 @@\n-\n-    @Test(dataProvider = \"intByteBufferMaskProvider\")\n-    static void loadStoreByteBufferMask(IntFunction<int[]> fa,\n-                                        IntFunction<ByteBuffer> fb,\n-                                        IntFunction<boolean[]> fm,\n-                                        ByteOrder bo) {\n+    @Test(dataProvider = \"intMemorySegmentMaskProvider\")\n+    static void loadStoreMemorySegmentMask(IntFunction<int[]> fa,\n+                                           IntFunction<MemorySegment> fb,\n+                                           IntFunction<boolean[]> fm,\n+                                           ByteOrder bo) {\n@@ -609,2 +542,2 @@\n-        ByteBuffer a = toBuffer(_a, fb);\n-        ByteBuffer r = fb.apply(a.limit());\n+        MemorySegment a = toSegment(_a, fb);\n+        MemorySegment r = fb.apply((int) a.byteSize());\n@@ -614,1 +547,1 @@\n-        int l = a.limit();\n+        int l = (int) a.byteSize();\n@@ -619,2 +552,2 @@\n-                IntVector av = IntVector.fromByteBuffer(SPECIES, a, i, bo, vmask);\n-                av.intoByteBuffer(r, i, bo);\n+                IntVector av = IntVector.fromMemorySegment(SPECIES, a, i, bo, vmask);\n+                av.intoMemorySegment(r, i, bo);\n@@ -623,5 +556,1 @@\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        assertArraysEquals(bufferToArray(r), _a, mask);\n+        assertArraysEquals(segmentToArray(r), _a, mask);\n@@ -630,1 +559,1 @@\n-        r = fb.apply(a.limit());\n+        r = fb.apply((int) a.byteSize());\n@@ -634,2 +563,2 @@\n-                IntVector av = IntVector.fromByteBuffer(SPECIES, a, i, bo);\n-                av.intoByteBuffer(r, i, bo, vmask);\n+                IntVector av = IntVector.fromMemorySegment(SPECIES, a, i, bo);\n+                av.intoMemorySegment(r, i, bo, vmask);\n@@ -638,5 +567,1 @@\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        assertArraysEquals(bufferToArray(r), _a, mask);\n+        assertArraysEquals(segmentToArray(r), _a, mask);\n@@ -646,3 +571,3 @@\n-    static void loadByteBufferMaskIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n+    static void loadMemorySegmentMaskIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n@@ -652,1 +577,1 @@\n-        int l = a.limit();\n+        int l = (int) a.byteSize();\n@@ -657,2 +582,2 @@\n-                IntVector av = fromByteBuffer(a, i, ByteOrder.nativeOrder(), vmask);\n-                av.intoByteBuffer(r, i, ByteOrder.nativeOrder());\n+                IntVector av = fromMemorySegment(a, i, ByteOrder.nativeOrder(), vmask);\n+                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n@@ -662,2 +587,2 @@\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.limit(), SPECIES.elementSize() \/ 8);\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() \/ 8);\n@@ -665,1 +590,1 @@\n-            fromByteBuffer(a, index, ByteOrder.nativeOrder(), vmask);\n+            fromMemorySegment(a, index, ByteOrder.nativeOrder(), vmask);\n@@ -677,3 +602,3 @@\n-    static void storeByteBufferMaskIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n+    static void storeMemorySegmentMaskIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n@@ -683,83 +608,1 @@\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                IntVector av = IntVector.fromByteBuffer(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteBuffer(av, r, i, ByteOrder.nativeOrder(), vmask);\n-            }\n-        }\n-\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.limit(), SPECIES.elementSize() \/ 8);\n-        try {\n-            IntVector av = IntVector.fromByteBuffer(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteBuffer(av, a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"intByteBufferProvider\")\n-    static void loadStoreReadonlyByteBuffer(IntFunction<int[]> fa,\n-                                    IntFunction<ByteBuffer> fb,\n-                                    ByteOrder bo) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), fb).asReadOnlyBuffer();\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo);\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, SPECIES.maskAll(true));\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, SPECIES.maskAll(false));\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            VectorMask<Integer> m = SPECIES.shuffleFromOp(i -> i % 2 == 0 ? 1 : -1)\n-                    .laneIsValid();\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, m);\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"intByteArrayProvider\")\n-    static void loadStoreByteArray(IntFunction<int[]> fa,\n-                                    ByteOrder bo) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, bo);\n-        byte[] r = new byte[a.length];\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                IntVector av = IntVector.fromByteArray(SPECIES, a, i, bo);\n-                av.intoByteArray(r, i, bo);\n-            }\n-        }\n-        Assert.assertEquals(r, a, \"Byte arrays not equal\");\n-    }\n-\n-    @Test(dataProvider = \"intByteProviderForIOOBE\")\n-    static void loadByteArrayIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-\n+        int l = (int) a.byteSize();\n@@ -767,1 +610,0 @@\n-        int l = a.length;\n@@ -771,2 +613,2 @@\n-                IntVector av = fromByteArray(a, i, ByteOrder.nativeOrder());\n-                av.intoByteArray(r, i, ByteOrder.nativeOrder());\n+                IntVector av = IntVector.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+                intoMemorySegment(av, r, i, ByteOrder.nativeOrder(), vmask);\n@@ -776,2 +618,2 @@\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.length);\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() \/ 8);\n@@ -779,1 +621,2 @@\n-            fromByteArray(a, index, ByteOrder.nativeOrder());\n+            IntVector av = IntVector.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+            intoMemorySegment(av, a, index, ByteOrder.nativeOrder(), vmask);\n@@ -790,62 +633,5 @@\n-    @Test(dataProvider = \"intByteProviderForIOOBE\")\n-    static void storeByteArrayIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                IntVector av = IntVector.fromByteArray(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteArray(av, r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.length);\n-        try {\n-            IntVector av = IntVector.fromByteArray(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteArray(av, r, index, ByteOrder.nativeOrder());\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"intByteArrayMaskProvider\")\n-    static void loadStoreByteArrayMask(IntFunction<int[]> fa,\n-                                  IntFunction<boolean[]> fm,\n-                                  ByteOrder bo) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, bo);\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Integer> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-          for (int i = 0; i < l; i += s) {\n-              IntVector av = IntVector.fromByteArray(SPECIES, a, i, bo, vmask);\n-              av.intoByteArray(r, i, bo);\n-          }\n-        }\n-        assertArraysEquals(r, a, mask);\n-\n-\n-        r = new byte[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                IntVector av = IntVector.fromByteArray(SPECIES, a, i, bo);\n-                av.intoByteArray(r, i, bo, vmask);\n-            }\n-        }\n-        assertArraysEquals(r, a, mask);\n-    }\n+    @Test(dataProvider = \"intMemorySegmentProvider\")\n+    static void loadStoreReadonlyMemorySegment(IntFunction<int[]> fa,\n+                                               IntFunction<MemorySegment> fb,\n+                                               ByteOrder bo) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb).asReadOnly();\n@@ -853,6 +639,4 @@\n-    @Test(dataProvider = \"intByteMaskProviderForIOOBE\")\n-    static void loadByteArrayMaskIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Integer> vmask = VectorMask.fromValues(SPECIES, mask);\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo)\n+        );\n@@ -860,2 +644,4 @@\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(true))\n+        );\n@@ -863,6 +649,4 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                IntVector av = fromByteArray(a, i, ByteOrder.nativeOrder(), vmask);\n-                av.intoByteArray(r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(false))\n+        );\n@@ -870,12 +654,6 @@\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length, SPECIES.elementSize() \/ 8);\n-        try {\n-            fromByteArray(a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n+        VectorMask<Integer> m = SPECIES.shuffleFromOp(i -> i % 2 == 0 ? 1 : -1)\n+                .laneIsValid();\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, m)\n+        );\n@@ -884,31 +662,0 @@\n-    @Test(dataProvider = \"intByteMaskProviderForIOOBE\")\n-    static void storeByteArrayMaskIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Integer> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                IntVector av = IntVector.fromByteArray(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteArray(av, r, i, ByteOrder.nativeOrder(), vmask);\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length, SPECIES.elementSize() \/ 8);\n-        try {\n-            IntVector av = IntVector.fromByteArray(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteArray(av, a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n@@ -930,0 +677,1 @@\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int256VectorLoadStoreTests.java","additions":112,"deletions":364,"binary":false,"changes":476,"status":"modified"},{"patch":"@@ -264,0 +264,49 @@\n+    static void assertcompressArraysEquals(int[] r, int[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    Assert.assertEquals(r[i + k], (int)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (int)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals(int[] r, int[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        Assert.assertEquals(r[i + j], (int)0);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (int)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n@@ -887,1 +936,0 @@\n-\n@@ -982,2 +1030,0 @@\n-\n-\n@@ -1029,1 +1075,0 @@\n-\n@@ -1170,0 +1215,12 @@\n+    static int TRAILING_ZEROS_COUNT_scalar(int a) {\n+        return Integer.numberOfTrailingZeros(a);\n+    }\n+\n+    static int LEADING_ZEROS_COUNT_scalar(int a) {\n+        return Integer.numberOfLeadingZeros(a);\n+    }\n+\n+    static int REVERSE_scalar(int a) {\n+        return Integer.reverse(a);\n+    }\n+\n@@ -1324,0 +1381,1 @@\n+\n@@ -1344,0 +1402,1 @@\n+\n@@ -1400,0 +1459,1 @@\n+\n@@ -1420,0 +1480,1 @@\n+\n@@ -1476,0 +1537,1 @@\n+\n@@ -1496,0 +1558,1 @@\n+\n@@ -1553,2 +1616,0 @@\n-\n-\n@@ -1577,0 +1638,1 @@\n+\n@@ -1600,2 +1662,0 @@\n-\n-\n@@ -1707,0 +1767,1 @@\n+\n@@ -1726,2 +1787,0 @@\n-\n-\n@@ -1748,1 +1807,0 @@\n-\n@@ -1770,2 +1828,0 @@\n-\n-\n@@ -1792,1 +1848,0 @@\n-\n@@ -1813,0 +1868,1 @@\n+\n@@ -1832,2 +1888,0 @@\n-\n-\n@@ -1854,1 +1908,0 @@\n-\n@@ -1876,2 +1929,0 @@\n-\n-\n@@ -1898,0 +1949,81 @@\n+    static int COMPRESS_BITS(int a, int b) {\n+        return (int)(Integer.compress(a, b));\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpProvider\")\n+    static void COMPRESS_BITSInt256VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.COMPRESS_BITS, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Int256VectorTests::COMPRESS_BITS);\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpMaskProvider\")\n+    static void COMPRESS_BITSInt256VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.COMPRESS_BITS, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Int256VectorTests::COMPRESS_BITS);\n+    }\n+\n+    static int EXPAND_BITS(int a, int b) {\n+        return (int)(Integer.expand(a, b));\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpProvider\")\n+    static void EXPAND_BITSInt256VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.EXPAND_BITS, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Int256VectorTests::EXPAND_BITS);\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpMaskProvider\")\n+    static void EXPAND_BITSInt256VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.EXPAND_BITS, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Int256VectorTests::EXPAND_BITS);\n+    }\n@@ -1992,3 +2124,0 @@\n-\n-\n-\n@@ -2011,2 +2140,0 @@\n-\n-\n@@ -2032,2 +2159,0 @@\n-\n-\n@@ -2062,2 +2187,0 @@\n-\n-\n@@ -2081,2 +2204,0 @@\n-\n-\n@@ -2111,2 +2232,0 @@\n-\n-\n@@ -2130,2 +2249,0 @@\n-\n-\n@@ -2146,2 +2263,0 @@\n-\n-\n@@ -2165,1 +2280,0 @@\n-\n@@ -2218,2 +2332,0 @@\n-\n-\n@@ -2240,5 +2352,0 @@\n-\n-\n-\n-\n-\n@@ -2266,2 +2373,0 @@\n-\n-\n@@ -2288,5 +2393,0 @@\n-\n-\n-\n-\n-\n@@ -2314,2 +2414,0 @@\n-\n-\n@@ -2336,5 +2434,0 @@\n-\n-\n-\n-\n-\n@@ -2361,2 +2454,0 @@\n-\n-\n@@ -2382,5 +2473,0 @@\n-\n-\n-\n-\n-\n@@ -2407,2 +2493,0 @@\n-\n-\n@@ -2428,5 +2512,0 @@\n-\n-\n-\n-\n-\n@@ -2453,2 +2532,0 @@\n-\n-\n@@ -2474,5 +2551,0 @@\n-\n-\n-\n-\n-\n@@ -2500,2 +2572,0 @@\n-\n-\n@@ -2522,1 +2592,0 @@\n-\n@@ -2544,2 +2613,0 @@\n-\n-\n@@ -2566,1 +2633,0 @@\n-\n@@ -2587,2 +2653,0 @@\n-\n-\n@@ -2608,1 +2672,0 @@\n-\n@@ -2629,2 +2692,0 @@\n-\n-\n@@ -2649,2 +2710,0 @@\n-\n-\n@@ -2670,2 +2729,0 @@\n-\n-\n@@ -2690,6 +2747,0 @@\n-\n-\n-\n-\n-\n-\n@@ -2715,2 +2766,0 @@\n-\n-\n@@ -2735,2 +2784,0 @@\n-\n-\n@@ -2756,2 +2803,0 @@\n-\n-\n@@ -2776,2 +2821,0 @@\n-\n-\n@@ -2797,2 +2840,0 @@\n-\n-\n@@ -2817,2 +2858,0 @@\n-\n-\n@@ -2838,2 +2877,0 @@\n-\n-\n@@ -2879,0 +2916,1 @@\n+\n@@ -2897,0 +2935,1 @@\n+\n@@ -2917,0 +2956,1 @@\n+\n@@ -3010,1 +3050,0 @@\n-\n@@ -3036,1 +3075,0 @@\n-\n@@ -3056,1 +3094,0 @@\n-\n@@ -3084,1 +3121,0 @@\n-\n@@ -3103,1 +3139,0 @@\n-\n@@ -3129,1 +3164,0 @@\n-\n@@ -3149,1 +3183,0 @@\n-\n@@ -3177,1 +3210,0 @@\n-\n@@ -3196,1 +3228,0 @@\n-\n@@ -3222,1 +3253,0 @@\n-\n@@ -3242,1 +3272,0 @@\n-\n@@ -3287,0 +3316,1 @@\n+\n@@ -3311,0 +3341,1 @@\n+\n@@ -3329,0 +3360,1 @@\n+\n@@ -3355,0 +3387,1 @@\n+\n@@ -3372,0 +3405,1 @@\n+\n@@ -3396,0 +3430,1 @@\n+\n@@ -3414,0 +3449,1 @@\n+\n@@ -3440,0 +3476,1 @@\n+\n@@ -3457,0 +3494,1 @@\n+\n@@ -3481,0 +3519,1 @@\n+\n@@ -3499,0 +3538,1 @@\n+\n@@ -3525,0 +3565,1 @@\n+\n@@ -3542,0 +3583,1 @@\n+\n@@ -3566,0 +3608,1 @@\n+\n@@ -3584,0 +3627,1 @@\n+\n@@ -3610,0 +3654,1 @@\n+\n@@ -3627,0 +3672,1 @@\n+\n@@ -3651,0 +3697,1 @@\n+\n@@ -3669,0 +3716,1 @@\n+\n@@ -3705,1 +3753,0 @@\n-\n@@ -3721,1 +3768,0 @@\n-\n@@ -3731,1 +3777,0 @@\n-\n@@ -3747,1 +3792,0 @@\n-\n@@ -3765,0 +3809,1 @@\n+\n@@ -3805,0 +3850,1 @@\n+\n@@ -3846,3 +3892,0 @@\n-\n-\n-\n@@ -3868,1 +3911,0 @@\n-\n@@ -3911,1 +3953,0 @@\n-\n@@ -3954,1 +3995,0 @@\n-\n@@ -3974,1 +4014,0 @@\n-\n@@ -4017,1 +4056,0 @@\n-\n@@ -4060,1 +4098,0 @@\n-\n@@ -4103,1 +4140,0 @@\n-\n@@ -4146,2 +4182,0 @@\n-\n-\n@@ -4167,2 +4201,0 @@\n-\n-\n@@ -4192,3 +4224,0 @@\n-\n-\n-\n@@ -4214,2 +4243,0 @@\n-\n-\n@@ -4239,3 +4266,0 @@\n-\n-\n-\n@@ -4261,2 +4285,0 @@\n-\n-\n@@ -4286,3 +4308,0 @@\n-\n-\n-\n@@ -4308,2 +4327,0 @@\n-\n-\n@@ -4333,2 +4350,0 @@\n-\n-\n@@ -4351,1 +4366,0 @@\n-\n@@ -4388,1 +4402,0 @@\n-\n@@ -4425,1 +4438,0 @@\n-\n@@ -4462,1 +4474,0 @@\n-\n@@ -4541,0 +4552,37 @@\n+\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void compressInt256VectorTests(IntFunction<int[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.compress(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertcompressArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void expandInt256VectorTests(IntFunction<int[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.expand(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertexpandArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n@@ -4711,4 +4759,0 @@\n-\n-\n-\n-\n@@ -4729,3 +4773,0 @@\n-\n-\n-\n@@ -4757,0 +4798,1 @@\n+\n@@ -4786,0 +4828,1 @@\n+\n@@ -4819,0 +4862,1 @@\n+\n@@ -4846,0 +4890,1 @@\n+\n@@ -4885,0 +4930,1 @@\n+\n@@ -4942,22 +4988,0 @@\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n@@ -4967,0 +4991,1 @@\n+\n@@ -4971,1 +4996,0 @@\n-\n@@ -4990,0 +5014,1 @@\n+\n@@ -5007,1 +5032,0 @@\n-\n@@ -5030,3 +5054,0 @@\n-\n-\n-\n@@ -5062,0 +5083,1 @@\n+\n@@ -5092,1 +5114,0 @@\n-\n@@ -5131,3 +5152,0 @@\n-\n-\n-\n@@ -5148,0 +5166,1 @@\n+\n@@ -5163,1 +5182,0 @@\n-\n@@ -5182,1 +5200,0 @@\n-\n@@ -5295,1 +5312,0 @@\n-\n@@ -5304,2 +5320,0 @@\n-\n-\n@@ -5336,2 +5350,0 @@\n-\n-\n@@ -5356,2 +5368,0 @@\n-\n-\n@@ -5362,2 +5372,0 @@\n-\n-\n@@ -5379,2 +5387,0 @@\n-\n-\n@@ -5399,0 +5405,3 @@\n+    static int BIT_COUNT(int a) {\n+        return (int)(Integer.bitCount(a));\n+    }\n@@ -5400,0 +5409,4 @@\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void BIT_COUNTInt256VectorTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n@@ -5401,0 +5414,9 @@\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Int256VectorTests::BIT_COUNT);\n+    }\n@@ -5402,0 +5424,165 @@\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void BIT_COUNTMaskedInt256VectorTests(IntFunction<int[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Int256VectorTests::BIT_COUNT);\n+    }\n+\n+    static int TRAILING_ZEROS_COUNT(int a) {\n+        return (int)(TRAILING_ZEROS_COUNT_scalar(a));\n+    }\n+\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void TRAILING_ZEROS_COUNTInt256VectorTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TRAILING_ZEROS_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Int256VectorTests::TRAILING_ZEROS_COUNT);\n+    }\n+\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void TRAILING_ZEROS_COUNTMaskedInt256VectorTests(IntFunction<int[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TRAILING_ZEROS_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Int256VectorTests::TRAILING_ZEROS_COUNT);\n+    }\n+\n+    static int LEADING_ZEROS_COUNT(int a) {\n+        return (int)(LEADING_ZEROS_COUNT_scalar(a));\n+    }\n+\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void LEADING_ZEROS_COUNTInt256VectorTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LEADING_ZEROS_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Int256VectorTests::LEADING_ZEROS_COUNT);\n+    }\n+\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void LEADING_ZEROS_COUNTMaskedInt256VectorTests(IntFunction<int[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LEADING_ZEROS_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Int256VectorTests::LEADING_ZEROS_COUNT);\n+    }\n+\n+    static int REVERSE(int a) {\n+        return (int)(REVERSE_scalar(a));\n+    }\n+\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void REVERSEInt256VectorTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Int256VectorTests::REVERSE);\n+    }\n+\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void REVERSEMaskedInt256VectorTests(IntFunction<int[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Int256VectorTests::REVERSE);\n+    }\n+\n+    static int REVERSE_BYTES(int a) {\n+        return (int)(Integer.reverseBytes(a));\n+    }\n+\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void REVERSE_BYTESInt256VectorTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Int256VectorTests::REVERSE_BYTES);\n+    }\n+\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void REVERSE_BYTESMaskedInt256VectorTests(IntFunction<int[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Int256VectorTests::REVERSE_BYTES);\n+    }\n@@ -5804,0 +5991,17 @@\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCompressInt256VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        int trueCount = 0;\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                trueCount = vmask.trueCount();\n+                var rmask = vmask.compress();\n+                for (int j = 0; j < SPECIES.length(); j++)  {\n+                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);\n+                }\n+            }\n+        }\n+    }\n+\n@@ -5846,0 +6050,14 @@\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeLongInt256VectorTestsSmokeTest(int offset) {\n+        long limit = SPECIES.length() * BUFFER_REPS;\n+        for (long i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i + offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                long index = i + j + offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n@@ -5866,0 +6084,8 @@\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundLongInt256VectorTestsSmokeTest(int _length) {\n+        long length = _length;\n+        long actualLoopBound = SPECIES.loopBound(length);\n+        long expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+    }\n+\n@@ -5928,1 +6154,0 @@\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int256VectorTests.java","additions":441,"deletions":216,"binary":false,"changes":657,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,3 @@\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.ValueLayout;\n@@ -42,2 +45,0 @@\n-import java.nio.ByteBuffer;\n-import java.nio.IntBuffer;\n@@ -45,1 +46,0 @@\n-import java.nio.ReadOnlyBufferException;\n@@ -70,11 +70,0 @@\n-    static void assertArraysEquals(byte[] r, byte[] a, boolean[] mask) {\n-        int i = 0;\n-        try {\n-            for (; i < a.length; i++) {\n-                Assert.assertEquals(r[i], mask[(i*8\/SPECIES.elementSize()) % SPECIES.length()] ? a[i] : (byte) 0);\n-            }\n-        } catch (AssertionError e) {\n-            Assert.assertEquals(r[i], mask[(i*8\/SPECIES.elementSize()) % SPECIES.length()] ? a[i] : (byte) 0, \"at index #\" + i);\n-        }\n-    }\n-\n@@ -120,1 +109,1 @@\n-    \/\/ Relative to byte[] array.length or ByteBuffer.limit()\n+    \/\/ Relative to byte[] array.length or MemorySegment.byteSize()\n@@ -191,1 +180,1 @@\n-    public Object[][] intByteBufferProvider() {\n+    public Object[][] intMemorySegmentProvider() {\n@@ -193,1 +182,1 @@\n-                flatMap(fa -> BYTE_BUFFER_GENERATORS.stream().\n+                flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n@@ -201,1 +190,1 @@\n-    public Object[][] intByteBufferMaskProvider() {\n+    public Object[][] intMemorySegmentMaskProvider() {\n@@ -204,1 +193,1 @@\n-                        flatMap(fa -> BYTE_BUFFER_GENERATORS.stream().\n+                        flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n@@ -211,19 +200,0 @@\n-    @DataProvider\n-    public Object[][] intByteArrayProvider() {\n-        return INT_GENERATORS.stream().\n-                flatMap(fa -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                    return new Object[]{fa, bo};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] intByteArrayMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> INT_GENERATORS.stream().\n-                    flatMap(fa -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                        return new Object[]{fa, fm, bo};\n-                    }))).\n-                toArray(Object[][]::new);\n-    }\n-\n@@ -249,4 +219,4 @@\n-    static ByteBuffer toBuffer(int[] a, IntFunction<ByteBuffer> fb) {\n-        ByteBuffer bb = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n-        for (int v : a) {\n-            bb.putInt(v);\n+    static MemorySegment toSegment(int[] a, IntFunction<MemorySegment> fb) {\n+        MemorySegment ms = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n+        for (int i = 0; i < a.length; i++) {\n+            ms.set(ValueLayout.JAVA_INT, i * SPECIES.elementSize() \/ 8 , a[i]);\n@@ -254,1 +224,1 @@\n-        return bb.clear();\n+        return ms;\n@@ -257,14 +227,2 @@\n-    static int[] bufferToArray(ByteBuffer bb) {\n-        IntBuffer db = bb.asIntBuffer();\n-        int[] d = new int[db.capacity()];\n-        db.get(0, d);\n-        return d;\n-    }\n-\n-    static byte[] toByteArray(int[] a, IntFunction<byte[]> fb, ByteOrder bo) {\n-        byte[] b = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n-        IntBuffer bb = ByteBuffer.wrap(b, 0, b.length).order(bo).asIntBuffer();\n-        for (int v : a) {\n-            bb.put(v);\n-        }\n-        return b;\n+    static int[] segmentToArray(MemorySegment ms) {\n+        return ms.toArray(ValueLayout.JAVA_INT);\n@@ -310,22 +268,2 @@\n-    static IntVector fromByteArray(byte[] a, int i, ByteOrder bo) {\n-        return IntVector.fromByteArray(SPECIES, a, i, bo);\n-    }\n-\n-    @DontInline\n-    static IntVector fromByteArray(byte[] a, int i, ByteOrder bo, VectorMask<Integer> m) {\n-        return IntVector.fromByteArray(SPECIES, a, i, bo, m);\n-    }\n-\n-    @DontInline\n-    static void intoByteArray(IntVector v, byte[] a, int i, ByteOrder bo) {\n-        v.intoByteArray(a, i, bo);\n-    }\n-\n-    @DontInline\n-    static void intoByteArray(IntVector v, byte[] a, int i, ByteOrder bo, VectorMask<Integer> m) {\n-        v.intoByteArray(a, i, bo, m);\n-    }\n-\n-    @DontInline\n-    static IntVector fromByteBuffer(ByteBuffer a, int i, ByteOrder bo) {\n-        return IntVector.fromByteBuffer(SPECIES, a, i, bo);\n+    static IntVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo) {\n+        return IntVector.fromMemorySegment(SPECIES, a, i, bo);\n@@ -335,2 +273,2 @@\n-    static IntVector fromByteBuffer(ByteBuffer a, int i, ByteOrder bo, VectorMask<Integer> m) {\n-        return IntVector.fromByteBuffer(SPECIES, a, i, bo, m);\n+    static IntVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo, VectorMask<Integer> m) {\n+        return IntVector.fromMemorySegment(SPECIES, a, i, bo, m);\n@@ -340,2 +278,2 @@\n-    static void intoByteBuffer(IntVector v, ByteBuffer a, int i, ByteOrder bo) {\n-        v.intoByteBuffer(a, i, bo);\n+    static void intoMemorySegment(IntVector v, MemorySegment a, int i, ByteOrder bo) {\n+        v.intoMemorySegment(a, i, bo);\n@@ -345,2 +283,2 @@\n-    static void intoByteBuffer(IntVector v, ByteBuffer a, int i, ByteOrder bo, VectorMask<Integer> m) {\n-        v.intoByteBuffer(a, i, bo, m);\n+    static void intoMemorySegment(IntVector v, MemorySegment a, int i, ByteOrder bo, VectorMask<Integer> m) {\n+        v.intoMemorySegment(a, i, bo, m);\n@@ -349,1 +287,0 @@\n-\n@@ -520,6 +457,6 @@\n-    @Test(dataProvider = \"intByteBufferProvider\")\n-    static void loadStoreByteBuffer(IntFunction<int[]> fa,\n-                                    IntFunction<ByteBuffer> fb,\n-                                    ByteOrder bo) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), fb);\n-        ByteBuffer r = fb.apply(a.limit());\n+    @Test(dataProvider = \"intMemorySegmentProvider\")\n+    static void loadStoreMemorySegment(IntFunction<int[]> fa,\n+                                       IntFunction<MemorySegment> fb,\n+                                       ByteOrder bo) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb);\n+        MemorySegment r = fb.apply((int) a.byteSize());\n@@ -527,1 +464,1 @@\n-        int l = a.limit();\n+        int l = (int) a.byteSize();\n@@ -532,2 +469,2 @@\n-                IntVector av = IntVector.fromByteBuffer(SPECIES, a, i, bo);\n-                av.intoByteBuffer(r, i, bo);\n+                IntVector av = IntVector.fromMemorySegment(SPECIES, a, i, bo);\n+                av.intoMemorySegment(r, i, bo);\n@@ -536,5 +473,2 @@\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        Assert.assertEquals(r, a, \"Buffers not equal\");\n+        long m = r.mismatch(a);\n+        Assert.assertEquals(m, -1, \"Segments not equal\");\n@@ -544,3 +478,3 @@\n-    static void loadByteBufferIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n+    static void loadMemorySegmentIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n@@ -548,1 +482,1 @@\n-        int l = a.limit();\n+        int l = (int) a.byteSize();\n@@ -553,2 +487,2 @@\n-                IntVector av = fromByteBuffer(a, i, ByteOrder.nativeOrder());\n-                av.intoByteBuffer(r, i, ByteOrder.nativeOrder());\n+                IntVector av = fromMemorySegment(a, i, ByteOrder.nativeOrder());\n+                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n@@ -558,2 +492,2 @@\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.limit());\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());\n@@ -561,1 +495,1 @@\n-            fromByteBuffer(a, index, ByteOrder.nativeOrder());\n+            fromMemorySegment(a, index, ByteOrder.nativeOrder());\n@@ -573,3 +507,3 @@\n-    static void storeByteBufferIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n+    static void storeMemorySegmentIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n@@ -577,1 +511,1 @@\n-        int l = a.limit();\n+        int l = (int) a.byteSize();\n@@ -582,2 +516,2 @@\n-                IntVector av = IntVector.fromByteBuffer(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteBuffer(av, r, i, ByteOrder.nativeOrder());\n+                IntVector av = IntVector.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+                intoMemorySegment(av, r, i, ByteOrder.nativeOrder());\n@@ -587,2 +521,2 @@\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.limit());\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());\n@@ -590,2 +524,2 @@\n-            IntVector av = IntVector.fromByteBuffer(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteBuffer(av, r, index, ByteOrder.nativeOrder());\n+            IntVector av = IntVector.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+            intoMemorySegment(av, r, index, ByteOrder.nativeOrder());\n@@ -602,6 +536,5 @@\n-\n-    @Test(dataProvider = \"intByteBufferMaskProvider\")\n-    static void loadStoreByteBufferMask(IntFunction<int[]> fa,\n-                                        IntFunction<ByteBuffer> fb,\n-                                        IntFunction<boolean[]> fm,\n-                                        ByteOrder bo) {\n+    @Test(dataProvider = \"intMemorySegmentMaskProvider\")\n+    static void loadStoreMemorySegmentMask(IntFunction<int[]> fa,\n+                                           IntFunction<MemorySegment> fb,\n+                                           IntFunction<boolean[]> fm,\n+                                           ByteOrder bo) {\n@@ -609,2 +542,2 @@\n-        ByteBuffer a = toBuffer(_a, fb);\n-        ByteBuffer r = fb.apply(a.limit());\n+        MemorySegment a = toSegment(_a, fb);\n+        MemorySegment r = fb.apply((int) a.byteSize());\n@@ -614,1 +547,1 @@\n-        int l = a.limit();\n+        int l = (int) a.byteSize();\n@@ -619,2 +552,2 @@\n-                IntVector av = IntVector.fromByteBuffer(SPECIES, a, i, bo, vmask);\n-                av.intoByteBuffer(r, i, bo);\n+                IntVector av = IntVector.fromMemorySegment(SPECIES, a, i, bo, vmask);\n+                av.intoMemorySegment(r, i, bo);\n@@ -623,5 +556,1 @@\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        assertArraysEquals(bufferToArray(r), _a, mask);\n+        assertArraysEquals(segmentToArray(r), _a, mask);\n@@ -630,1 +559,1 @@\n-        r = fb.apply(a.limit());\n+        r = fb.apply((int) a.byteSize());\n@@ -634,2 +563,2 @@\n-                IntVector av = IntVector.fromByteBuffer(SPECIES, a, i, bo);\n-                av.intoByteBuffer(r, i, bo, vmask);\n+                IntVector av = IntVector.fromMemorySegment(SPECIES, a, i, bo);\n+                av.intoMemorySegment(r, i, bo, vmask);\n@@ -638,5 +567,1 @@\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        assertArraysEquals(bufferToArray(r), _a, mask);\n+        assertArraysEquals(segmentToArray(r), _a, mask);\n@@ -646,3 +571,3 @@\n-    static void loadByteBufferMaskIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n+    static void loadMemorySegmentMaskIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n@@ -652,1 +577,1 @@\n-        int l = a.limit();\n+        int l = (int) a.byteSize();\n@@ -657,2 +582,2 @@\n-                IntVector av = fromByteBuffer(a, i, ByteOrder.nativeOrder(), vmask);\n-                av.intoByteBuffer(r, i, ByteOrder.nativeOrder());\n+                IntVector av = fromMemorySegment(a, i, ByteOrder.nativeOrder(), vmask);\n+                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n@@ -662,2 +587,2 @@\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.limit(), SPECIES.elementSize() \/ 8);\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() \/ 8);\n@@ -665,1 +590,1 @@\n-            fromByteBuffer(a, index, ByteOrder.nativeOrder(), vmask);\n+            fromMemorySegment(a, index, ByteOrder.nativeOrder(), vmask);\n@@ -677,3 +602,3 @@\n-    static void storeByteBufferMaskIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n+    static void storeMemorySegmentMaskIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n@@ -683,83 +608,1 @@\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                IntVector av = IntVector.fromByteBuffer(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteBuffer(av, r, i, ByteOrder.nativeOrder(), vmask);\n-            }\n-        }\n-\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.limit(), SPECIES.elementSize() \/ 8);\n-        try {\n-            IntVector av = IntVector.fromByteBuffer(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteBuffer(av, a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"intByteBufferProvider\")\n-    static void loadStoreReadonlyByteBuffer(IntFunction<int[]> fa,\n-                                    IntFunction<ByteBuffer> fb,\n-                                    ByteOrder bo) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), fb).asReadOnlyBuffer();\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo);\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, SPECIES.maskAll(true));\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, SPECIES.maskAll(false));\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            VectorMask<Integer> m = SPECIES.shuffleFromOp(i -> i % 2 == 0 ? 1 : -1)\n-                    .laneIsValid();\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, m);\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"intByteArrayProvider\")\n-    static void loadStoreByteArray(IntFunction<int[]> fa,\n-                                    ByteOrder bo) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, bo);\n-        byte[] r = new byte[a.length];\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                IntVector av = IntVector.fromByteArray(SPECIES, a, i, bo);\n-                av.intoByteArray(r, i, bo);\n-            }\n-        }\n-        Assert.assertEquals(r, a, \"Byte arrays not equal\");\n-    }\n-\n-    @Test(dataProvider = \"intByteProviderForIOOBE\")\n-    static void loadByteArrayIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-\n+        int l = (int) a.byteSize();\n@@ -767,1 +610,0 @@\n-        int l = a.length;\n@@ -771,2 +613,2 @@\n-                IntVector av = fromByteArray(a, i, ByteOrder.nativeOrder());\n-                av.intoByteArray(r, i, ByteOrder.nativeOrder());\n+                IntVector av = IntVector.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+                intoMemorySegment(av, r, i, ByteOrder.nativeOrder(), vmask);\n@@ -776,2 +618,2 @@\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.length);\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() \/ 8);\n@@ -779,1 +621,2 @@\n-            fromByteArray(a, index, ByteOrder.nativeOrder());\n+            IntVector av = IntVector.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+            intoMemorySegment(av, a, index, ByteOrder.nativeOrder(), vmask);\n@@ -790,62 +633,5 @@\n-    @Test(dataProvider = \"intByteProviderForIOOBE\")\n-    static void storeByteArrayIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                IntVector av = IntVector.fromByteArray(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteArray(av, r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.length);\n-        try {\n-            IntVector av = IntVector.fromByteArray(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteArray(av, r, index, ByteOrder.nativeOrder());\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"intByteArrayMaskProvider\")\n-    static void loadStoreByteArrayMask(IntFunction<int[]> fa,\n-                                  IntFunction<boolean[]> fm,\n-                                  ByteOrder bo) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, bo);\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Integer> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-          for (int i = 0; i < l; i += s) {\n-              IntVector av = IntVector.fromByteArray(SPECIES, a, i, bo, vmask);\n-              av.intoByteArray(r, i, bo);\n-          }\n-        }\n-        assertArraysEquals(r, a, mask);\n-\n-\n-        r = new byte[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                IntVector av = IntVector.fromByteArray(SPECIES, a, i, bo);\n-                av.intoByteArray(r, i, bo, vmask);\n-            }\n-        }\n-        assertArraysEquals(r, a, mask);\n-    }\n+    @Test(dataProvider = \"intMemorySegmentProvider\")\n+    static void loadStoreReadonlyMemorySegment(IntFunction<int[]> fa,\n+                                               IntFunction<MemorySegment> fb,\n+                                               ByteOrder bo) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb).asReadOnly();\n@@ -853,6 +639,4 @@\n-    @Test(dataProvider = \"intByteMaskProviderForIOOBE\")\n-    static void loadByteArrayMaskIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Integer> vmask = VectorMask.fromValues(SPECIES, mask);\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo)\n+        );\n@@ -860,2 +644,4 @@\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(true))\n+        );\n@@ -863,6 +649,4 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                IntVector av = fromByteArray(a, i, ByteOrder.nativeOrder(), vmask);\n-                av.intoByteArray(r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(false))\n+        );\n@@ -870,12 +654,6 @@\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length, SPECIES.elementSize() \/ 8);\n-        try {\n-            fromByteArray(a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n+        VectorMask<Integer> m = SPECIES.shuffleFromOp(i -> i % 2 == 0 ? 1 : -1)\n+                .laneIsValid();\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, m)\n+        );\n@@ -884,31 +662,0 @@\n-    @Test(dataProvider = \"intByteMaskProviderForIOOBE\")\n-    static void storeByteArrayMaskIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Integer> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                IntVector av = IntVector.fromByteArray(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteArray(av, r, i, ByteOrder.nativeOrder(), vmask);\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length, SPECIES.elementSize() \/ 8);\n-        try {\n-            IntVector av = IntVector.fromByteArray(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteArray(av, a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n@@ -930,0 +677,1 @@\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int512VectorLoadStoreTests.java","additions":112,"deletions":364,"binary":false,"changes":476,"status":"modified"},{"patch":"@@ -264,0 +264,49 @@\n+    static void assertcompressArraysEquals(int[] r, int[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    Assert.assertEquals(r[i + k], (int)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (int)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals(int[] r, int[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        Assert.assertEquals(r[i + j], (int)0);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (int)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n@@ -887,1 +936,0 @@\n-\n@@ -982,2 +1030,0 @@\n-\n-\n@@ -1029,1 +1075,0 @@\n-\n@@ -1170,0 +1215,12 @@\n+    static int TRAILING_ZEROS_COUNT_scalar(int a) {\n+        return Integer.numberOfTrailingZeros(a);\n+    }\n+\n+    static int LEADING_ZEROS_COUNT_scalar(int a) {\n+        return Integer.numberOfLeadingZeros(a);\n+    }\n+\n+    static int REVERSE_scalar(int a) {\n+        return Integer.reverse(a);\n+    }\n+\n@@ -1324,0 +1381,1 @@\n+\n@@ -1344,0 +1402,1 @@\n+\n@@ -1400,0 +1459,1 @@\n+\n@@ -1420,0 +1480,1 @@\n+\n@@ -1476,0 +1537,1 @@\n+\n@@ -1496,0 +1558,1 @@\n+\n@@ -1553,2 +1616,0 @@\n-\n-\n@@ -1577,0 +1638,1 @@\n+\n@@ -1600,2 +1662,0 @@\n-\n-\n@@ -1707,0 +1767,1 @@\n+\n@@ -1726,2 +1787,0 @@\n-\n-\n@@ -1748,1 +1807,0 @@\n-\n@@ -1770,2 +1828,0 @@\n-\n-\n@@ -1792,1 +1848,0 @@\n-\n@@ -1813,0 +1868,1 @@\n+\n@@ -1832,2 +1888,0 @@\n-\n-\n@@ -1854,1 +1908,0 @@\n-\n@@ -1876,2 +1929,0 @@\n-\n-\n@@ -1898,0 +1949,81 @@\n+    static int COMPRESS_BITS(int a, int b) {\n+        return (int)(Integer.compress(a, b));\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpProvider\")\n+    static void COMPRESS_BITSInt512VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.COMPRESS_BITS, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Int512VectorTests::COMPRESS_BITS);\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpMaskProvider\")\n+    static void COMPRESS_BITSInt512VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.COMPRESS_BITS, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Int512VectorTests::COMPRESS_BITS);\n+    }\n+\n+    static int EXPAND_BITS(int a, int b) {\n+        return (int)(Integer.expand(a, b));\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpProvider\")\n+    static void EXPAND_BITSInt512VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.EXPAND_BITS, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Int512VectorTests::EXPAND_BITS);\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpMaskProvider\")\n+    static void EXPAND_BITSInt512VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.EXPAND_BITS, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Int512VectorTests::EXPAND_BITS);\n+    }\n@@ -1992,3 +2124,0 @@\n-\n-\n-\n@@ -2011,2 +2140,0 @@\n-\n-\n@@ -2032,2 +2159,0 @@\n-\n-\n@@ -2062,2 +2187,0 @@\n-\n-\n@@ -2081,2 +2204,0 @@\n-\n-\n@@ -2111,2 +2232,0 @@\n-\n-\n@@ -2130,2 +2249,0 @@\n-\n-\n@@ -2146,2 +2263,0 @@\n-\n-\n@@ -2165,1 +2280,0 @@\n-\n@@ -2218,2 +2332,0 @@\n-\n-\n@@ -2240,5 +2352,0 @@\n-\n-\n-\n-\n-\n@@ -2266,2 +2373,0 @@\n-\n-\n@@ -2288,5 +2393,0 @@\n-\n-\n-\n-\n-\n@@ -2314,2 +2414,0 @@\n-\n-\n@@ -2336,5 +2434,0 @@\n-\n-\n-\n-\n-\n@@ -2361,2 +2454,0 @@\n-\n-\n@@ -2382,5 +2473,0 @@\n-\n-\n-\n-\n-\n@@ -2407,2 +2493,0 @@\n-\n-\n@@ -2428,5 +2512,0 @@\n-\n-\n-\n-\n-\n@@ -2453,2 +2532,0 @@\n-\n-\n@@ -2474,5 +2551,0 @@\n-\n-\n-\n-\n-\n@@ -2500,2 +2572,0 @@\n-\n-\n@@ -2522,1 +2592,0 @@\n-\n@@ -2544,2 +2613,0 @@\n-\n-\n@@ -2566,1 +2633,0 @@\n-\n@@ -2587,2 +2653,0 @@\n-\n-\n@@ -2608,1 +2672,0 @@\n-\n@@ -2629,2 +2692,0 @@\n-\n-\n@@ -2649,2 +2710,0 @@\n-\n-\n@@ -2670,2 +2729,0 @@\n-\n-\n@@ -2690,6 +2747,0 @@\n-\n-\n-\n-\n-\n-\n@@ -2715,2 +2766,0 @@\n-\n-\n@@ -2735,2 +2784,0 @@\n-\n-\n@@ -2756,2 +2803,0 @@\n-\n-\n@@ -2776,2 +2821,0 @@\n-\n-\n@@ -2797,2 +2840,0 @@\n-\n-\n@@ -2817,2 +2858,0 @@\n-\n-\n@@ -2838,2 +2877,0 @@\n-\n-\n@@ -2879,0 +2916,1 @@\n+\n@@ -2897,0 +2935,1 @@\n+\n@@ -2917,0 +2956,1 @@\n+\n@@ -3010,1 +3050,0 @@\n-\n@@ -3036,1 +3075,0 @@\n-\n@@ -3056,1 +3094,0 @@\n-\n@@ -3084,1 +3121,0 @@\n-\n@@ -3103,1 +3139,0 @@\n-\n@@ -3129,1 +3164,0 @@\n-\n@@ -3149,1 +3183,0 @@\n-\n@@ -3177,1 +3210,0 @@\n-\n@@ -3196,1 +3228,0 @@\n-\n@@ -3222,1 +3253,0 @@\n-\n@@ -3242,1 +3272,0 @@\n-\n@@ -3287,0 +3316,1 @@\n+\n@@ -3311,0 +3341,1 @@\n+\n@@ -3329,0 +3360,1 @@\n+\n@@ -3355,0 +3387,1 @@\n+\n@@ -3372,0 +3405,1 @@\n+\n@@ -3396,0 +3430,1 @@\n+\n@@ -3414,0 +3449,1 @@\n+\n@@ -3440,0 +3476,1 @@\n+\n@@ -3457,0 +3494,1 @@\n+\n@@ -3481,0 +3519,1 @@\n+\n@@ -3499,0 +3538,1 @@\n+\n@@ -3525,0 +3565,1 @@\n+\n@@ -3542,0 +3583,1 @@\n+\n@@ -3566,0 +3608,1 @@\n+\n@@ -3584,0 +3627,1 @@\n+\n@@ -3610,0 +3654,1 @@\n+\n@@ -3627,0 +3672,1 @@\n+\n@@ -3651,0 +3697,1 @@\n+\n@@ -3669,0 +3716,1 @@\n+\n@@ -3705,1 +3753,0 @@\n-\n@@ -3721,1 +3768,0 @@\n-\n@@ -3731,1 +3777,0 @@\n-\n@@ -3747,1 +3792,0 @@\n-\n@@ -3765,0 +3809,1 @@\n+\n@@ -3805,0 +3850,1 @@\n+\n@@ -3846,3 +3892,0 @@\n-\n-\n-\n@@ -3868,1 +3911,0 @@\n-\n@@ -3911,1 +3953,0 @@\n-\n@@ -3954,1 +3995,0 @@\n-\n@@ -3974,1 +4014,0 @@\n-\n@@ -4017,1 +4056,0 @@\n-\n@@ -4060,1 +4098,0 @@\n-\n@@ -4103,1 +4140,0 @@\n-\n@@ -4146,2 +4182,0 @@\n-\n-\n@@ -4167,2 +4201,0 @@\n-\n-\n@@ -4192,3 +4224,0 @@\n-\n-\n-\n@@ -4214,2 +4243,0 @@\n-\n-\n@@ -4239,3 +4266,0 @@\n-\n-\n-\n@@ -4261,2 +4285,0 @@\n-\n-\n@@ -4286,3 +4308,0 @@\n-\n-\n-\n@@ -4308,2 +4327,0 @@\n-\n-\n@@ -4333,2 +4350,0 @@\n-\n-\n@@ -4351,1 +4366,0 @@\n-\n@@ -4388,1 +4402,0 @@\n-\n@@ -4425,1 +4438,0 @@\n-\n@@ -4462,1 +4474,0 @@\n-\n@@ -4541,0 +4552,37 @@\n+\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void compressInt512VectorTests(IntFunction<int[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.compress(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertcompressArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void expandInt512VectorTests(IntFunction<int[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.expand(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertexpandArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n@@ -4711,4 +4759,0 @@\n-\n-\n-\n-\n@@ -4729,3 +4773,0 @@\n-\n-\n-\n@@ -4757,0 +4798,1 @@\n+\n@@ -4786,0 +4828,1 @@\n+\n@@ -4819,0 +4862,1 @@\n+\n@@ -4846,0 +4890,1 @@\n+\n@@ -4885,0 +4930,1 @@\n+\n@@ -4942,22 +4988,0 @@\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n@@ -4967,0 +4991,1 @@\n+\n@@ -4971,1 +4996,0 @@\n-\n@@ -4990,0 +5014,1 @@\n+\n@@ -5007,1 +5032,0 @@\n-\n@@ -5030,3 +5054,0 @@\n-\n-\n-\n@@ -5062,0 +5083,1 @@\n+\n@@ -5092,1 +5114,0 @@\n-\n@@ -5131,3 +5152,0 @@\n-\n-\n-\n@@ -5148,0 +5166,1 @@\n+\n@@ -5163,1 +5182,0 @@\n-\n@@ -5182,1 +5200,0 @@\n-\n@@ -5295,1 +5312,0 @@\n-\n@@ -5304,2 +5320,0 @@\n-\n-\n@@ -5336,2 +5350,0 @@\n-\n-\n@@ -5356,2 +5368,0 @@\n-\n-\n@@ -5362,2 +5372,0 @@\n-\n-\n@@ -5379,2 +5387,0 @@\n-\n-\n@@ -5399,0 +5405,3 @@\n+    static int BIT_COUNT(int a) {\n+        return (int)(Integer.bitCount(a));\n+    }\n@@ -5400,0 +5409,4 @@\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void BIT_COUNTInt512VectorTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n@@ -5401,0 +5414,9 @@\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Int512VectorTests::BIT_COUNT);\n+    }\n@@ -5402,0 +5424,165 @@\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void BIT_COUNTMaskedInt512VectorTests(IntFunction<int[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Int512VectorTests::BIT_COUNT);\n+    }\n+\n+    static int TRAILING_ZEROS_COUNT(int a) {\n+        return (int)(TRAILING_ZEROS_COUNT_scalar(a));\n+    }\n+\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void TRAILING_ZEROS_COUNTInt512VectorTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TRAILING_ZEROS_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Int512VectorTests::TRAILING_ZEROS_COUNT);\n+    }\n+\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void TRAILING_ZEROS_COUNTMaskedInt512VectorTests(IntFunction<int[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TRAILING_ZEROS_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Int512VectorTests::TRAILING_ZEROS_COUNT);\n+    }\n+\n+    static int LEADING_ZEROS_COUNT(int a) {\n+        return (int)(LEADING_ZEROS_COUNT_scalar(a));\n+    }\n+\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void LEADING_ZEROS_COUNTInt512VectorTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LEADING_ZEROS_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Int512VectorTests::LEADING_ZEROS_COUNT);\n+    }\n+\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void LEADING_ZEROS_COUNTMaskedInt512VectorTests(IntFunction<int[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LEADING_ZEROS_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Int512VectorTests::LEADING_ZEROS_COUNT);\n+    }\n+\n+    static int REVERSE(int a) {\n+        return (int)(REVERSE_scalar(a));\n+    }\n+\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void REVERSEInt512VectorTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Int512VectorTests::REVERSE);\n+    }\n+\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void REVERSEMaskedInt512VectorTests(IntFunction<int[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Int512VectorTests::REVERSE);\n+    }\n+\n+    static int REVERSE_BYTES(int a) {\n+        return (int)(Integer.reverseBytes(a));\n+    }\n+\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void REVERSE_BYTESInt512VectorTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Int512VectorTests::REVERSE_BYTES);\n+    }\n+\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void REVERSE_BYTESMaskedInt512VectorTests(IntFunction<int[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Int512VectorTests::REVERSE_BYTES);\n+    }\n@@ -5804,0 +5991,17 @@\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCompressInt512VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        int trueCount = 0;\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                trueCount = vmask.trueCount();\n+                var rmask = vmask.compress();\n+                for (int j = 0; j < SPECIES.length(); j++)  {\n+                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);\n+                }\n+            }\n+        }\n+    }\n+\n@@ -5846,0 +6050,14 @@\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeLongInt512VectorTestsSmokeTest(int offset) {\n+        long limit = SPECIES.length() * BUFFER_REPS;\n+        for (long i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i + offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                long index = i + j + offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n@@ -5866,0 +6084,8 @@\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundLongInt512VectorTestsSmokeTest(int _length) {\n+        long length = _length;\n+        long actualLoopBound = SPECIES.loopBound(length);\n+        long expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+    }\n+\n@@ -5928,1 +6154,0 @@\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int512VectorTests.java","additions":441,"deletions":216,"binary":false,"changes":657,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,3 @@\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.ValueLayout;\n@@ -42,2 +45,0 @@\n-import java.nio.ByteBuffer;\n-import java.nio.IntBuffer;\n@@ -45,1 +46,0 @@\n-import java.nio.ReadOnlyBufferException;\n@@ -70,11 +70,0 @@\n-    static void assertArraysEquals(byte[] r, byte[] a, boolean[] mask) {\n-        int i = 0;\n-        try {\n-            for (; i < a.length; i++) {\n-                Assert.assertEquals(r[i], mask[(i*8\/SPECIES.elementSize()) % SPECIES.length()] ? a[i] : (byte) 0);\n-            }\n-        } catch (AssertionError e) {\n-            Assert.assertEquals(r[i], mask[(i*8\/SPECIES.elementSize()) % SPECIES.length()] ? a[i] : (byte) 0, \"at index #\" + i);\n-        }\n-    }\n-\n@@ -120,1 +109,1 @@\n-    \/\/ Relative to byte[] array.length or ByteBuffer.limit()\n+    \/\/ Relative to byte[] array.length or MemorySegment.byteSize()\n@@ -191,1 +180,1 @@\n-    public Object[][] intByteBufferProvider() {\n+    public Object[][] intMemorySegmentProvider() {\n@@ -193,1 +182,1 @@\n-                flatMap(fa -> BYTE_BUFFER_GENERATORS.stream().\n+                flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n@@ -201,1 +190,1 @@\n-    public Object[][] intByteBufferMaskProvider() {\n+    public Object[][] intMemorySegmentMaskProvider() {\n@@ -204,1 +193,1 @@\n-                        flatMap(fa -> BYTE_BUFFER_GENERATORS.stream().\n+                        flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n@@ -211,19 +200,0 @@\n-    @DataProvider\n-    public Object[][] intByteArrayProvider() {\n-        return INT_GENERATORS.stream().\n-                flatMap(fa -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                    return new Object[]{fa, bo};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] intByteArrayMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> INT_GENERATORS.stream().\n-                    flatMap(fa -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                        return new Object[]{fa, fm, bo};\n-                    }))).\n-                toArray(Object[][]::new);\n-    }\n-\n@@ -249,4 +219,4 @@\n-    static ByteBuffer toBuffer(int[] a, IntFunction<ByteBuffer> fb) {\n-        ByteBuffer bb = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n-        for (int v : a) {\n-            bb.putInt(v);\n+    static MemorySegment toSegment(int[] a, IntFunction<MemorySegment> fb) {\n+        MemorySegment ms = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n+        for (int i = 0; i < a.length; i++) {\n+            ms.set(ValueLayout.JAVA_INT, i * SPECIES.elementSize() \/ 8 , a[i]);\n@@ -254,1 +224,1 @@\n-        return bb.clear();\n+        return ms;\n@@ -257,14 +227,2 @@\n-    static int[] bufferToArray(ByteBuffer bb) {\n-        IntBuffer db = bb.asIntBuffer();\n-        int[] d = new int[db.capacity()];\n-        db.get(0, d);\n-        return d;\n-    }\n-\n-    static byte[] toByteArray(int[] a, IntFunction<byte[]> fb, ByteOrder bo) {\n-        byte[] b = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n-        IntBuffer bb = ByteBuffer.wrap(b, 0, b.length).order(bo).asIntBuffer();\n-        for (int v : a) {\n-            bb.put(v);\n-        }\n-        return b;\n+    static int[] segmentToArray(MemorySegment ms) {\n+        return ms.toArray(ValueLayout.JAVA_INT);\n@@ -310,22 +268,2 @@\n-    static IntVector fromByteArray(byte[] a, int i, ByteOrder bo) {\n-        return IntVector.fromByteArray(SPECIES, a, i, bo);\n-    }\n-\n-    @DontInline\n-    static IntVector fromByteArray(byte[] a, int i, ByteOrder bo, VectorMask<Integer> m) {\n-        return IntVector.fromByteArray(SPECIES, a, i, bo, m);\n-    }\n-\n-    @DontInline\n-    static void intoByteArray(IntVector v, byte[] a, int i, ByteOrder bo) {\n-        v.intoByteArray(a, i, bo);\n-    }\n-\n-    @DontInline\n-    static void intoByteArray(IntVector v, byte[] a, int i, ByteOrder bo, VectorMask<Integer> m) {\n-        v.intoByteArray(a, i, bo, m);\n-    }\n-\n-    @DontInline\n-    static IntVector fromByteBuffer(ByteBuffer a, int i, ByteOrder bo) {\n-        return IntVector.fromByteBuffer(SPECIES, a, i, bo);\n+    static IntVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo) {\n+        return IntVector.fromMemorySegment(SPECIES, a, i, bo);\n@@ -335,2 +273,2 @@\n-    static IntVector fromByteBuffer(ByteBuffer a, int i, ByteOrder bo, VectorMask<Integer> m) {\n-        return IntVector.fromByteBuffer(SPECIES, a, i, bo, m);\n+    static IntVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo, VectorMask<Integer> m) {\n+        return IntVector.fromMemorySegment(SPECIES, a, i, bo, m);\n@@ -340,2 +278,2 @@\n-    static void intoByteBuffer(IntVector v, ByteBuffer a, int i, ByteOrder bo) {\n-        v.intoByteBuffer(a, i, bo);\n+    static void intoMemorySegment(IntVector v, MemorySegment a, int i, ByteOrder bo) {\n+        v.intoMemorySegment(a, i, bo);\n@@ -345,2 +283,2 @@\n-    static void intoByteBuffer(IntVector v, ByteBuffer a, int i, ByteOrder bo, VectorMask<Integer> m) {\n-        v.intoByteBuffer(a, i, bo, m);\n+    static void intoMemorySegment(IntVector v, MemorySegment a, int i, ByteOrder bo, VectorMask<Integer> m) {\n+        v.intoMemorySegment(a, i, bo, m);\n@@ -349,1 +287,0 @@\n-\n@@ -520,6 +457,6 @@\n-    @Test(dataProvider = \"intByteBufferProvider\")\n-    static void loadStoreByteBuffer(IntFunction<int[]> fa,\n-                                    IntFunction<ByteBuffer> fb,\n-                                    ByteOrder bo) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), fb);\n-        ByteBuffer r = fb.apply(a.limit());\n+    @Test(dataProvider = \"intMemorySegmentProvider\")\n+    static void loadStoreMemorySegment(IntFunction<int[]> fa,\n+                                       IntFunction<MemorySegment> fb,\n+                                       ByteOrder bo) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb);\n+        MemorySegment r = fb.apply((int) a.byteSize());\n@@ -527,1 +464,1 @@\n-        int l = a.limit();\n+        int l = (int) a.byteSize();\n@@ -532,2 +469,2 @@\n-                IntVector av = IntVector.fromByteBuffer(SPECIES, a, i, bo);\n-                av.intoByteBuffer(r, i, bo);\n+                IntVector av = IntVector.fromMemorySegment(SPECIES, a, i, bo);\n+                av.intoMemorySegment(r, i, bo);\n@@ -536,5 +473,2 @@\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        Assert.assertEquals(r, a, \"Buffers not equal\");\n+        long m = r.mismatch(a);\n+        Assert.assertEquals(m, -1, \"Segments not equal\");\n@@ -544,3 +478,3 @@\n-    static void loadByteBufferIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n+    static void loadMemorySegmentIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n@@ -548,1 +482,1 @@\n-        int l = a.limit();\n+        int l = (int) a.byteSize();\n@@ -553,2 +487,2 @@\n-                IntVector av = fromByteBuffer(a, i, ByteOrder.nativeOrder());\n-                av.intoByteBuffer(r, i, ByteOrder.nativeOrder());\n+                IntVector av = fromMemorySegment(a, i, ByteOrder.nativeOrder());\n+                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n@@ -558,2 +492,2 @@\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.limit());\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());\n@@ -561,1 +495,1 @@\n-            fromByteBuffer(a, index, ByteOrder.nativeOrder());\n+            fromMemorySegment(a, index, ByteOrder.nativeOrder());\n@@ -573,3 +507,3 @@\n-    static void storeByteBufferIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n+    static void storeMemorySegmentIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n@@ -577,1 +511,1 @@\n-        int l = a.limit();\n+        int l = (int) a.byteSize();\n@@ -582,2 +516,2 @@\n-                IntVector av = IntVector.fromByteBuffer(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteBuffer(av, r, i, ByteOrder.nativeOrder());\n+                IntVector av = IntVector.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+                intoMemorySegment(av, r, i, ByteOrder.nativeOrder());\n@@ -587,2 +521,2 @@\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.limit());\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());\n@@ -590,2 +524,2 @@\n-            IntVector av = IntVector.fromByteBuffer(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteBuffer(av, r, index, ByteOrder.nativeOrder());\n+            IntVector av = IntVector.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+            intoMemorySegment(av, r, index, ByteOrder.nativeOrder());\n@@ -602,6 +536,5 @@\n-\n-    @Test(dataProvider = \"intByteBufferMaskProvider\")\n-    static void loadStoreByteBufferMask(IntFunction<int[]> fa,\n-                                        IntFunction<ByteBuffer> fb,\n-                                        IntFunction<boolean[]> fm,\n-                                        ByteOrder bo) {\n+    @Test(dataProvider = \"intMemorySegmentMaskProvider\")\n+    static void loadStoreMemorySegmentMask(IntFunction<int[]> fa,\n+                                           IntFunction<MemorySegment> fb,\n+                                           IntFunction<boolean[]> fm,\n+                                           ByteOrder bo) {\n@@ -609,2 +542,2 @@\n-        ByteBuffer a = toBuffer(_a, fb);\n-        ByteBuffer r = fb.apply(a.limit());\n+        MemorySegment a = toSegment(_a, fb);\n+        MemorySegment r = fb.apply((int) a.byteSize());\n@@ -614,1 +547,1 @@\n-        int l = a.limit();\n+        int l = (int) a.byteSize();\n@@ -619,2 +552,2 @@\n-                IntVector av = IntVector.fromByteBuffer(SPECIES, a, i, bo, vmask);\n-                av.intoByteBuffer(r, i, bo);\n+                IntVector av = IntVector.fromMemorySegment(SPECIES, a, i, bo, vmask);\n+                av.intoMemorySegment(r, i, bo);\n@@ -623,5 +556,1 @@\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        assertArraysEquals(bufferToArray(r), _a, mask);\n+        assertArraysEquals(segmentToArray(r), _a, mask);\n@@ -630,1 +559,1 @@\n-        r = fb.apply(a.limit());\n+        r = fb.apply((int) a.byteSize());\n@@ -634,2 +563,2 @@\n-                IntVector av = IntVector.fromByteBuffer(SPECIES, a, i, bo);\n-                av.intoByteBuffer(r, i, bo, vmask);\n+                IntVector av = IntVector.fromMemorySegment(SPECIES, a, i, bo);\n+                av.intoMemorySegment(r, i, bo, vmask);\n@@ -638,5 +567,1 @@\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        assertArraysEquals(bufferToArray(r), _a, mask);\n+        assertArraysEquals(segmentToArray(r), _a, mask);\n@@ -646,3 +571,3 @@\n-    static void loadByteBufferMaskIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n+    static void loadMemorySegmentMaskIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n@@ -652,1 +577,1 @@\n-        int l = a.limit();\n+        int l = (int) a.byteSize();\n@@ -657,2 +582,2 @@\n-                IntVector av = fromByteBuffer(a, i, ByteOrder.nativeOrder(), vmask);\n-                av.intoByteBuffer(r, i, ByteOrder.nativeOrder());\n+                IntVector av = fromMemorySegment(a, i, ByteOrder.nativeOrder(), vmask);\n+                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n@@ -662,2 +587,2 @@\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.limit(), SPECIES.elementSize() \/ 8);\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() \/ 8);\n@@ -665,1 +590,1 @@\n-            fromByteBuffer(a, index, ByteOrder.nativeOrder(), vmask);\n+            fromMemorySegment(a, index, ByteOrder.nativeOrder(), vmask);\n@@ -677,3 +602,3 @@\n-    static void storeByteBufferMaskIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n+    static void storeMemorySegmentMaskIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n@@ -683,83 +608,1 @@\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                IntVector av = IntVector.fromByteBuffer(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteBuffer(av, r, i, ByteOrder.nativeOrder(), vmask);\n-            }\n-        }\n-\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.limit(), SPECIES.elementSize() \/ 8);\n-        try {\n-            IntVector av = IntVector.fromByteBuffer(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteBuffer(av, a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"intByteBufferProvider\")\n-    static void loadStoreReadonlyByteBuffer(IntFunction<int[]> fa,\n-                                    IntFunction<ByteBuffer> fb,\n-                                    ByteOrder bo) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), fb).asReadOnlyBuffer();\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo);\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, SPECIES.maskAll(true));\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, SPECIES.maskAll(false));\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            VectorMask<Integer> m = SPECIES.shuffleFromOp(i -> i % 2 == 0 ? 1 : -1)\n-                    .laneIsValid();\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, m);\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"intByteArrayProvider\")\n-    static void loadStoreByteArray(IntFunction<int[]> fa,\n-                                    ByteOrder bo) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, bo);\n-        byte[] r = new byte[a.length];\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                IntVector av = IntVector.fromByteArray(SPECIES, a, i, bo);\n-                av.intoByteArray(r, i, bo);\n-            }\n-        }\n-        Assert.assertEquals(r, a, \"Byte arrays not equal\");\n-    }\n-\n-    @Test(dataProvider = \"intByteProviderForIOOBE\")\n-    static void loadByteArrayIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-\n+        int l = (int) a.byteSize();\n@@ -767,1 +610,0 @@\n-        int l = a.length;\n@@ -771,2 +613,2 @@\n-                IntVector av = fromByteArray(a, i, ByteOrder.nativeOrder());\n-                av.intoByteArray(r, i, ByteOrder.nativeOrder());\n+                IntVector av = IntVector.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+                intoMemorySegment(av, r, i, ByteOrder.nativeOrder(), vmask);\n@@ -776,2 +618,2 @@\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.length);\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() \/ 8);\n@@ -779,1 +621,2 @@\n-            fromByteArray(a, index, ByteOrder.nativeOrder());\n+            IntVector av = IntVector.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+            intoMemorySegment(av, a, index, ByteOrder.nativeOrder(), vmask);\n@@ -790,62 +633,5 @@\n-    @Test(dataProvider = \"intByteProviderForIOOBE\")\n-    static void storeByteArrayIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                IntVector av = IntVector.fromByteArray(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteArray(av, r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.length);\n-        try {\n-            IntVector av = IntVector.fromByteArray(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteArray(av, r, index, ByteOrder.nativeOrder());\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"intByteArrayMaskProvider\")\n-    static void loadStoreByteArrayMask(IntFunction<int[]> fa,\n-                                  IntFunction<boolean[]> fm,\n-                                  ByteOrder bo) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, bo);\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Integer> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-          for (int i = 0; i < l; i += s) {\n-              IntVector av = IntVector.fromByteArray(SPECIES, a, i, bo, vmask);\n-              av.intoByteArray(r, i, bo);\n-          }\n-        }\n-        assertArraysEquals(r, a, mask);\n-\n-\n-        r = new byte[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                IntVector av = IntVector.fromByteArray(SPECIES, a, i, bo);\n-                av.intoByteArray(r, i, bo, vmask);\n-            }\n-        }\n-        assertArraysEquals(r, a, mask);\n-    }\n+    @Test(dataProvider = \"intMemorySegmentProvider\")\n+    static void loadStoreReadonlyMemorySegment(IntFunction<int[]> fa,\n+                                               IntFunction<MemorySegment> fb,\n+                                               ByteOrder bo) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb).asReadOnly();\n@@ -853,6 +639,4 @@\n-    @Test(dataProvider = \"intByteMaskProviderForIOOBE\")\n-    static void loadByteArrayMaskIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Integer> vmask = VectorMask.fromValues(SPECIES, mask);\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo)\n+        );\n@@ -860,2 +644,4 @@\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(true))\n+        );\n@@ -863,6 +649,4 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                IntVector av = fromByteArray(a, i, ByteOrder.nativeOrder(), vmask);\n-                av.intoByteArray(r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(false))\n+        );\n@@ -870,12 +654,6 @@\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length, SPECIES.elementSize() \/ 8);\n-        try {\n-            fromByteArray(a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n+        VectorMask<Integer> m = SPECIES.shuffleFromOp(i -> i % 2 == 0 ? 1 : -1)\n+                .laneIsValid();\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, m)\n+        );\n@@ -884,31 +662,0 @@\n-    @Test(dataProvider = \"intByteMaskProviderForIOOBE\")\n-    static void storeByteArrayMaskIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Integer> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                IntVector av = IntVector.fromByteArray(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteArray(av, r, i, ByteOrder.nativeOrder(), vmask);\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length, SPECIES.elementSize() \/ 8);\n-        try {\n-            IntVector av = IntVector.fromByteArray(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteArray(av, a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n@@ -930,0 +677,1 @@\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int64VectorLoadStoreTests.java","additions":112,"deletions":364,"binary":false,"changes":476,"status":"modified"},{"patch":"@@ -264,0 +264,49 @@\n+    static void assertcompressArraysEquals(int[] r, int[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    Assert.assertEquals(r[i + k], (int)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (int)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals(int[] r, int[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        Assert.assertEquals(r[i + j], (int)0);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (int)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n@@ -887,1 +936,0 @@\n-\n@@ -982,2 +1030,0 @@\n-\n-\n@@ -1029,1 +1075,0 @@\n-\n@@ -1170,0 +1215,12 @@\n+    static int TRAILING_ZEROS_COUNT_scalar(int a) {\n+        return Integer.numberOfTrailingZeros(a);\n+    }\n+\n+    static int LEADING_ZEROS_COUNT_scalar(int a) {\n+        return Integer.numberOfLeadingZeros(a);\n+    }\n+\n+    static int REVERSE_scalar(int a) {\n+        return Integer.reverse(a);\n+    }\n+\n@@ -1324,0 +1381,1 @@\n+\n@@ -1344,0 +1402,1 @@\n+\n@@ -1400,0 +1459,1 @@\n+\n@@ -1420,0 +1480,1 @@\n+\n@@ -1476,0 +1537,1 @@\n+\n@@ -1496,0 +1558,1 @@\n+\n@@ -1553,2 +1616,0 @@\n-\n-\n@@ -1577,0 +1638,1 @@\n+\n@@ -1600,2 +1662,0 @@\n-\n-\n@@ -1707,0 +1767,1 @@\n+\n@@ -1726,2 +1787,0 @@\n-\n-\n@@ -1748,1 +1807,0 @@\n-\n@@ -1770,2 +1828,0 @@\n-\n-\n@@ -1792,1 +1848,0 @@\n-\n@@ -1813,0 +1868,1 @@\n+\n@@ -1832,2 +1888,0 @@\n-\n-\n@@ -1854,1 +1908,0 @@\n-\n@@ -1876,2 +1929,0 @@\n-\n-\n@@ -1898,0 +1949,81 @@\n+    static int COMPRESS_BITS(int a, int b) {\n+        return (int)(Integer.compress(a, b));\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpProvider\")\n+    static void COMPRESS_BITSInt64VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.COMPRESS_BITS, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Int64VectorTests::COMPRESS_BITS);\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpMaskProvider\")\n+    static void COMPRESS_BITSInt64VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.COMPRESS_BITS, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Int64VectorTests::COMPRESS_BITS);\n+    }\n+\n+    static int EXPAND_BITS(int a, int b) {\n+        return (int)(Integer.expand(a, b));\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpProvider\")\n+    static void EXPAND_BITSInt64VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.EXPAND_BITS, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Int64VectorTests::EXPAND_BITS);\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpMaskProvider\")\n+    static void EXPAND_BITSInt64VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.EXPAND_BITS, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Int64VectorTests::EXPAND_BITS);\n+    }\n@@ -1992,3 +2124,0 @@\n-\n-\n-\n@@ -2011,2 +2140,0 @@\n-\n-\n@@ -2032,2 +2159,0 @@\n-\n-\n@@ -2062,2 +2187,0 @@\n-\n-\n@@ -2081,2 +2204,0 @@\n-\n-\n@@ -2111,2 +2232,0 @@\n-\n-\n@@ -2130,2 +2249,0 @@\n-\n-\n@@ -2146,2 +2263,0 @@\n-\n-\n@@ -2165,1 +2280,0 @@\n-\n@@ -2218,2 +2332,0 @@\n-\n-\n@@ -2240,5 +2352,0 @@\n-\n-\n-\n-\n-\n@@ -2266,2 +2373,0 @@\n-\n-\n@@ -2288,5 +2393,0 @@\n-\n-\n-\n-\n-\n@@ -2314,2 +2414,0 @@\n-\n-\n@@ -2336,5 +2434,0 @@\n-\n-\n-\n-\n-\n@@ -2361,2 +2454,0 @@\n-\n-\n@@ -2382,5 +2473,0 @@\n-\n-\n-\n-\n-\n@@ -2407,2 +2493,0 @@\n-\n-\n@@ -2428,5 +2512,0 @@\n-\n-\n-\n-\n-\n@@ -2453,2 +2532,0 @@\n-\n-\n@@ -2474,5 +2551,0 @@\n-\n-\n-\n-\n-\n@@ -2500,2 +2572,0 @@\n-\n-\n@@ -2522,1 +2592,0 @@\n-\n@@ -2544,2 +2613,0 @@\n-\n-\n@@ -2566,1 +2633,0 @@\n-\n@@ -2587,2 +2653,0 @@\n-\n-\n@@ -2608,1 +2672,0 @@\n-\n@@ -2629,2 +2692,0 @@\n-\n-\n@@ -2649,2 +2710,0 @@\n-\n-\n@@ -2670,2 +2729,0 @@\n-\n-\n@@ -2690,6 +2747,0 @@\n-\n-\n-\n-\n-\n-\n@@ -2715,2 +2766,0 @@\n-\n-\n@@ -2735,2 +2784,0 @@\n-\n-\n@@ -2756,2 +2803,0 @@\n-\n-\n@@ -2776,2 +2821,0 @@\n-\n-\n@@ -2797,2 +2840,0 @@\n-\n-\n@@ -2817,2 +2858,0 @@\n-\n-\n@@ -2838,2 +2877,0 @@\n-\n-\n@@ -2879,0 +2916,1 @@\n+\n@@ -2897,0 +2935,1 @@\n+\n@@ -2917,0 +2956,1 @@\n+\n@@ -3010,1 +3050,0 @@\n-\n@@ -3036,1 +3075,0 @@\n-\n@@ -3056,1 +3094,0 @@\n-\n@@ -3084,1 +3121,0 @@\n-\n@@ -3103,1 +3139,0 @@\n-\n@@ -3129,1 +3164,0 @@\n-\n@@ -3149,1 +3183,0 @@\n-\n@@ -3177,1 +3210,0 @@\n-\n@@ -3196,1 +3228,0 @@\n-\n@@ -3222,1 +3253,0 @@\n-\n@@ -3242,1 +3272,0 @@\n-\n@@ -3287,0 +3316,1 @@\n+\n@@ -3311,0 +3341,1 @@\n+\n@@ -3329,0 +3360,1 @@\n+\n@@ -3355,0 +3387,1 @@\n+\n@@ -3372,0 +3405,1 @@\n+\n@@ -3396,0 +3430,1 @@\n+\n@@ -3414,0 +3449,1 @@\n+\n@@ -3440,0 +3476,1 @@\n+\n@@ -3457,0 +3494,1 @@\n+\n@@ -3481,0 +3519,1 @@\n+\n@@ -3499,0 +3538,1 @@\n+\n@@ -3525,0 +3565,1 @@\n+\n@@ -3542,0 +3583,1 @@\n+\n@@ -3566,0 +3608,1 @@\n+\n@@ -3584,0 +3627,1 @@\n+\n@@ -3610,0 +3654,1 @@\n+\n@@ -3627,0 +3672,1 @@\n+\n@@ -3651,0 +3697,1 @@\n+\n@@ -3669,0 +3716,1 @@\n+\n@@ -3705,1 +3753,0 @@\n-\n@@ -3721,1 +3768,0 @@\n-\n@@ -3731,1 +3777,0 @@\n-\n@@ -3747,1 +3792,0 @@\n-\n@@ -3765,0 +3809,1 @@\n+\n@@ -3805,0 +3850,1 @@\n+\n@@ -3846,3 +3892,0 @@\n-\n-\n-\n@@ -3868,1 +3911,0 @@\n-\n@@ -3911,1 +3953,0 @@\n-\n@@ -3954,1 +3995,0 @@\n-\n@@ -3974,1 +4014,0 @@\n-\n@@ -4017,1 +4056,0 @@\n-\n@@ -4060,1 +4098,0 @@\n-\n@@ -4103,1 +4140,0 @@\n-\n@@ -4146,2 +4182,0 @@\n-\n-\n@@ -4167,2 +4201,0 @@\n-\n-\n@@ -4192,3 +4224,0 @@\n-\n-\n-\n@@ -4214,2 +4243,0 @@\n-\n-\n@@ -4239,3 +4266,0 @@\n-\n-\n-\n@@ -4261,2 +4285,0 @@\n-\n-\n@@ -4286,3 +4308,0 @@\n-\n-\n-\n@@ -4308,2 +4327,0 @@\n-\n-\n@@ -4333,2 +4350,0 @@\n-\n-\n@@ -4351,1 +4366,0 @@\n-\n@@ -4388,1 +4402,0 @@\n-\n@@ -4425,1 +4438,0 @@\n-\n@@ -4462,1 +4474,0 @@\n-\n@@ -4541,0 +4552,37 @@\n+\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void compressInt64VectorTests(IntFunction<int[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.compress(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertcompressArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void expandInt64VectorTests(IntFunction<int[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.expand(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertexpandArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n@@ -4711,4 +4759,0 @@\n-\n-\n-\n-\n@@ -4729,3 +4773,0 @@\n-\n-\n-\n@@ -4757,0 +4798,1 @@\n+\n@@ -4786,0 +4828,1 @@\n+\n@@ -4819,0 +4862,1 @@\n+\n@@ -4846,0 +4890,1 @@\n+\n@@ -4885,0 +4930,1 @@\n+\n@@ -4942,22 +4988,0 @@\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n@@ -4967,0 +4991,1 @@\n+\n@@ -4971,1 +4996,0 @@\n-\n@@ -4990,0 +5014,1 @@\n+\n@@ -5007,1 +5032,0 @@\n-\n@@ -5030,3 +5054,0 @@\n-\n-\n-\n@@ -5062,0 +5083,1 @@\n+\n@@ -5092,1 +5114,0 @@\n-\n@@ -5131,3 +5152,0 @@\n-\n-\n-\n@@ -5148,0 +5166,1 @@\n+\n@@ -5163,1 +5182,0 @@\n-\n@@ -5182,1 +5200,0 @@\n-\n@@ -5295,1 +5312,0 @@\n-\n@@ -5304,2 +5320,0 @@\n-\n-\n@@ -5336,2 +5350,0 @@\n-\n-\n@@ -5356,2 +5368,0 @@\n-\n-\n@@ -5362,2 +5372,0 @@\n-\n-\n@@ -5379,2 +5387,0 @@\n-\n-\n@@ -5399,0 +5405,3 @@\n+    static int BIT_COUNT(int a) {\n+        return (int)(Integer.bitCount(a));\n+    }\n@@ -5400,0 +5409,4 @@\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void BIT_COUNTInt64VectorTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n@@ -5401,0 +5414,9 @@\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Int64VectorTests::BIT_COUNT);\n+    }\n@@ -5402,0 +5424,165 @@\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void BIT_COUNTMaskedInt64VectorTests(IntFunction<int[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Int64VectorTests::BIT_COUNT);\n+    }\n+\n+    static int TRAILING_ZEROS_COUNT(int a) {\n+        return (int)(TRAILING_ZEROS_COUNT_scalar(a));\n+    }\n+\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void TRAILING_ZEROS_COUNTInt64VectorTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TRAILING_ZEROS_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Int64VectorTests::TRAILING_ZEROS_COUNT);\n+    }\n+\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void TRAILING_ZEROS_COUNTMaskedInt64VectorTests(IntFunction<int[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TRAILING_ZEROS_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Int64VectorTests::TRAILING_ZEROS_COUNT);\n+    }\n+\n+    static int LEADING_ZEROS_COUNT(int a) {\n+        return (int)(LEADING_ZEROS_COUNT_scalar(a));\n+    }\n+\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void LEADING_ZEROS_COUNTInt64VectorTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LEADING_ZEROS_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Int64VectorTests::LEADING_ZEROS_COUNT);\n+    }\n+\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void LEADING_ZEROS_COUNTMaskedInt64VectorTests(IntFunction<int[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LEADING_ZEROS_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Int64VectorTests::LEADING_ZEROS_COUNT);\n+    }\n+\n+    static int REVERSE(int a) {\n+        return (int)(REVERSE_scalar(a));\n+    }\n+\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void REVERSEInt64VectorTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Int64VectorTests::REVERSE);\n+    }\n+\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void REVERSEMaskedInt64VectorTests(IntFunction<int[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Int64VectorTests::REVERSE);\n+    }\n+\n+    static int REVERSE_BYTES(int a) {\n+        return (int)(Integer.reverseBytes(a));\n+    }\n+\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void REVERSE_BYTESInt64VectorTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Int64VectorTests::REVERSE_BYTES);\n+    }\n+\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void REVERSE_BYTESMaskedInt64VectorTests(IntFunction<int[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Int64VectorTests::REVERSE_BYTES);\n+    }\n@@ -5804,0 +5991,17 @@\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCompressInt64VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        int trueCount = 0;\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                trueCount = vmask.trueCount();\n+                var rmask = vmask.compress();\n+                for (int j = 0; j < SPECIES.length(); j++)  {\n+                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);\n+                }\n+            }\n+        }\n+    }\n+\n@@ -5846,0 +6050,14 @@\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeLongInt64VectorTestsSmokeTest(int offset) {\n+        long limit = SPECIES.length() * BUFFER_REPS;\n+        for (long i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i + offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                long index = i + j + offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n@@ -5866,0 +6084,8 @@\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundLongInt64VectorTestsSmokeTest(int _length) {\n+        long length = _length;\n+        long actualLoopBound = SPECIES.loopBound(length);\n+        long expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+    }\n+\n@@ -5928,1 +6154,0 @@\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int64VectorTests.java","additions":441,"deletions":216,"binary":false,"changes":657,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,3 @@\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.ValueLayout;\n@@ -44,4 +47,0 @@\n-import java.lang.invoke.MethodHandles;\n-import java.lang.invoke.VarHandle;\n-import java.nio.ByteBuffer;\n-import java.nio.IntBuffer;\n@@ -49,1 +48,0 @@\n-import java.nio.ReadOnlyBufferException;\n@@ -79,11 +77,0 @@\n-    static void assertArraysEquals(byte[] r, byte[] a, boolean[] mask) {\n-        int i = 0;\n-        try {\n-            for (; i < a.length; i++) {\n-                Assert.assertEquals(r[i], mask[(i*8\/SPECIES.elementSize()) % SPECIES.length()] ? a[i] : (byte) 0);\n-            }\n-        } catch (AssertionError e) {\n-            Assert.assertEquals(r[i], mask[(i*8\/SPECIES.elementSize()) % SPECIES.length()] ? a[i] : (byte) 0, \"at index #\" + i);\n-        }\n-    }\n-\n@@ -129,1 +116,1 @@\n-    \/\/ Relative to byte[] array.length or ByteBuffer.limit()\n+    \/\/ Relative to byte[] array.length or MemorySegment.byteSize()\n@@ -200,1 +187,1 @@\n-    public Object[][] intByteBufferProvider() {\n+    public Object[][] intMemorySegmentProvider() {\n@@ -202,1 +189,1 @@\n-                flatMap(fa -> BYTE_BUFFER_GENERATORS.stream().\n+                flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n@@ -210,1 +197,1 @@\n-    public Object[][] intByteBufferMaskProvider() {\n+    public Object[][] intMemorySegmentMaskProvider() {\n@@ -213,1 +200,1 @@\n-                        flatMap(fa -> BYTE_BUFFER_GENERATORS.stream().\n+                        flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n@@ -220,19 +207,0 @@\n-    @DataProvider\n-    public Object[][] intByteArrayProvider() {\n-        return INT_GENERATORS.stream().\n-                flatMap(fa -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                    return new Object[]{fa, bo};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] intByteArrayMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> INT_GENERATORS.stream().\n-                    flatMap(fa -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                        return new Object[]{fa, fm, bo};\n-                    }))).\n-                toArray(Object[][]::new);\n-    }\n-\n@@ -258,4 +226,4 @@\n-    static ByteBuffer toBuffer(int[] a, IntFunction<ByteBuffer> fb) {\n-        ByteBuffer bb = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n-        for (int v : a) {\n-            bb.putInt(v);\n+    static MemorySegment toSegment(int[] a, IntFunction<MemorySegment> fb) {\n+        MemorySegment ms = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n+        for (int i = 0; i < a.length; i++) {\n+            ms.set(ValueLayout.JAVA_INT, i * SPECIES.elementSize() \/ 8 , a[i]);\n@@ -263,1 +231,1 @@\n-        return bb.clear();\n+        return ms;\n@@ -266,14 +234,2 @@\n-    static int[] bufferToArray(ByteBuffer bb) {\n-        IntBuffer db = bb.asIntBuffer();\n-        int[] d = new int[db.capacity()];\n-        db.get(0, d);\n-        return d;\n-    }\n-\n-    static byte[] toByteArray(int[] a, IntFunction<byte[]> fb, ByteOrder bo) {\n-        byte[] b = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n-        IntBuffer bb = ByteBuffer.wrap(b, 0, b.length).order(bo).asIntBuffer();\n-        for (int v : a) {\n-            bb.put(v);\n-        }\n-        return b;\n+    static int[] segmentToArray(MemorySegment ms) {\n+        return ms.toArray(ValueLayout.JAVA_INT);\n@@ -319,22 +275,2 @@\n-    static IntVector fromByteArray(byte[] a, int i, ByteOrder bo) {\n-        return IntVector.fromByteArray(SPECIES, a, i, bo);\n-    }\n-\n-    @DontInline\n-    static IntVector fromByteArray(byte[] a, int i, ByteOrder bo, VectorMask<Integer> m) {\n-        return IntVector.fromByteArray(SPECIES, a, i, bo, m);\n-    }\n-\n-    @DontInline\n-    static void intoByteArray(IntVector v, byte[] a, int i, ByteOrder bo) {\n-        v.intoByteArray(a, i, bo);\n-    }\n-\n-    @DontInline\n-    static void intoByteArray(IntVector v, byte[] a, int i, ByteOrder bo, VectorMask<Integer> m) {\n-        v.intoByteArray(a, i, bo, m);\n-    }\n-\n-    @DontInline\n-    static IntVector fromByteBuffer(ByteBuffer a, int i, ByteOrder bo) {\n-        return IntVector.fromByteBuffer(SPECIES, a, i, bo);\n+    static IntVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo) {\n+        return IntVector.fromMemorySegment(SPECIES, a, i, bo);\n@@ -344,2 +280,2 @@\n-    static IntVector fromByteBuffer(ByteBuffer a, int i, ByteOrder bo, VectorMask<Integer> m) {\n-        return IntVector.fromByteBuffer(SPECIES, a, i, bo, m);\n+    static IntVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo, VectorMask<Integer> m) {\n+        return IntVector.fromMemorySegment(SPECIES, a, i, bo, m);\n@@ -349,2 +285,2 @@\n-    static void intoByteBuffer(IntVector v, ByteBuffer a, int i, ByteOrder bo) {\n-        v.intoByteBuffer(a, i, bo);\n+    static void intoMemorySegment(IntVector v, MemorySegment a, int i, ByteOrder bo) {\n+        v.intoMemorySegment(a, i, bo);\n@@ -354,2 +290,2 @@\n-    static void intoByteBuffer(IntVector v, ByteBuffer a, int i, ByteOrder bo, VectorMask<Integer> m) {\n-        v.intoByteBuffer(a, i, bo, m);\n+    static void intoMemorySegment(IntVector v, MemorySegment a, int i, ByteOrder bo, VectorMask<Integer> m) {\n+        v.intoMemorySegment(a, i, bo, m);\n@@ -358,1 +294,0 @@\n-\n@@ -529,6 +464,6 @@\n-    @Test(dataProvider = \"intByteBufferProvider\")\n-    static void loadStoreByteBuffer(IntFunction<int[]> fa,\n-                                    IntFunction<ByteBuffer> fb,\n-                                    ByteOrder bo) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), fb);\n-        ByteBuffer r = fb.apply(a.limit());\n+    @Test(dataProvider = \"intMemorySegmentProvider\")\n+    static void loadStoreMemorySegment(IntFunction<int[]> fa,\n+                                       IntFunction<MemorySegment> fb,\n+                                       ByteOrder bo) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb);\n+        MemorySegment r = fb.apply((int) a.byteSize());\n@@ -536,1 +471,1 @@\n-        int l = a.limit();\n+        int l = (int) a.byteSize();\n@@ -541,2 +476,2 @@\n-                IntVector av = IntVector.fromByteBuffer(SPECIES, a, i, bo);\n-                av.intoByteBuffer(r, i, bo);\n+                IntVector av = IntVector.fromMemorySegment(SPECIES, a, i, bo);\n+                av.intoMemorySegment(r, i, bo);\n@@ -545,5 +480,2 @@\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        Assert.assertEquals(r, a, \"Buffers not equal\");\n+        long m = r.mismatch(a);\n+        Assert.assertEquals(m, -1, \"Segments not equal\");\n@@ -553,3 +485,3 @@\n-    static void loadByteBufferIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n+    static void loadMemorySegmentIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n@@ -557,1 +489,1 @@\n-        int l = a.limit();\n+        int l = (int) a.byteSize();\n@@ -562,2 +494,2 @@\n-                IntVector av = fromByteBuffer(a, i, ByteOrder.nativeOrder());\n-                av.intoByteBuffer(r, i, ByteOrder.nativeOrder());\n+                IntVector av = fromMemorySegment(a, i, ByteOrder.nativeOrder());\n+                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n@@ -567,2 +499,2 @@\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.limit());\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());\n@@ -570,1 +502,1 @@\n-            fromByteBuffer(a, index, ByteOrder.nativeOrder());\n+            fromMemorySegment(a, index, ByteOrder.nativeOrder());\n@@ -582,3 +514,3 @@\n-    static void storeByteBufferIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n+    static void storeMemorySegmentIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n@@ -586,1 +518,1 @@\n-        int l = a.limit();\n+        int l = (int) a.byteSize();\n@@ -591,2 +523,2 @@\n-                IntVector av = IntVector.fromByteBuffer(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteBuffer(av, r, i, ByteOrder.nativeOrder());\n+                IntVector av = IntVector.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+                intoMemorySegment(av, r, i, ByteOrder.nativeOrder());\n@@ -596,2 +528,2 @@\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.limit());\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());\n@@ -599,2 +531,2 @@\n-            IntVector av = IntVector.fromByteBuffer(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteBuffer(av, r, index, ByteOrder.nativeOrder());\n+            IntVector av = IntVector.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+            intoMemorySegment(av, r, index, ByteOrder.nativeOrder());\n@@ -611,6 +543,5 @@\n-\n-    @Test(dataProvider = \"intByteBufferMaskProvider\")\n-    static void loadStoreByteBufferMask(IntFunction<int[]> fa,\n-                                        IntFunction<ByteBuffer> fb,\n-                                        IntFunction<boolean[]> fm,\n-                                        ByteOrder bo) {\n+    @Test(dataProvider = \"intMemorySegmentMaskProvider\")\n+    static void loadStoreMemorySegmentMask(IntFunction<int[]> fa,\n+                                           IntFunction<MemorySegment> fb,\n+                                           IntFunction<boolean[]> fm,\n+                                           ByteOrder bo) {\n@@ -618,2 +549,2 @@\n-        ByteBuffer a = toBuffer(_a, fb);\n-        ByteBuffer r = fb.apply(a.limit());\n+        MemorySegment a = toSegment(_a, fb);\n+        MemorySegment r = fb.apply((int) a.byteSize());\n@@ -623,1 +554,1 @@\n-        int l = a.limit();\n+        int l = (int) a.byteSize();\n@@ -628,2 +559,2 @@\n-                IntVector av = IntVector.fromByteBuffer(SPECIES, a, i, bo, vmask);\n-                av.intoByteBuffer(r, i, bo);\n+                IntVector av = IntVector.fromMemorySegment(SPECIES, a, i, bo, vmask);\n+                av.intoMemorySegment(r, i, bo);\n@@ -632,5 +563,1 @@\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        assertArraysEquals(bufferToArray(r), _a, mask);\n+        assertArraysEquals(segmentToArray(r), _a, mask);\n@@ -639,1 +566,1 @@\n-        r = fb.apply(a.limit());\n+        r = fb.apply((int) a.byteSize());\n@@ -643,2 +570,2 @@\n-                IntVector av = IntVector.fromByteBuffer(SPECIES, a, i, bo);\n-                av.intoByteBuffer(r, i, bo, vmask);\n+                IntVector av = IntVector.fromMemorySegment(SPECIES, a, i, bo);\n+                av.intoMemorySegment(r, i, bo, vmask);\n@@ -647,5 +574,1 @@\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        assertArraysEquals(bufferToArray(r), _a, mask);\n+        assertArraysEquals(segmentToArray(r), _a, mask);\n@@ -655,3 +578,3 @@\n-    static void loadByteBufferMaskIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n+    static void loadMemorySegmentMaskIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n@@ -661,1 +584,1 @@\n-        int l = a.limit();\n+        int l = (int) a.byteSize();\n@@ -666,2 +589,2 @@\n-                IntVector av = fromByteBuffer(a, i, ByteOrder.nativeOrder(), vmask);\n-                av.intoByteBuffer(r, i, ByteOrder.nativeOrder());\n+                IntVector av = fromMemorySegment(a, i, ByteOrder.nativeOrder(), vmask);\n+                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n@@ -671,2 +594,2 @@\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.limit(), SPECIES.elementSize() \/ 8);\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() \/ 8);\n@@ -674,1 +597,1 @@\n-            fromByteBuffer(a, index, ByteOrder.nativeOrder(), vmask);\n+            fromMemorySegment(a, index, ByteOrder.nativeOrder(), vmask);\n@@ -686,3 +609,3 @@\n-    static void storeByteBufferMaskIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n+    static void storeMemorySegmentMaskIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n@@ -692,83 +615,1 @@\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                IntVector av = IntVector.fromByteBuffer(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteBuffer(av, r, i, ByteOrder.nativeOrder(), vmask);\n-            }\n-        }\n-\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.limit(), SPECIES.elementSize() \/ 8);\n-        try {\n-            IntVector av = IntVector.fromByteBuffer(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteBuffer(av, a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"intByteBufferProvider\")\n-    static void loadStoreReadonlyByteBuffer(IntFunction<int[]> fa,\n-                                    IntFunction<ByteBuffer> fb,\n-                                    ByteOrder bo) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), fb).asReadOnlyBuffer();\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo);\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, SPECIES.maskAll(true));\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, SPECIES.maskAll(false));\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            VectorMask<Integer> m = SPECIES.shuffleFromOp(i -> i % 2 == 0 ? 1 : -1)\n-                    .laneIsValid();\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, m);\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"intByteArrayProvider\")\n-    static void loadStoreByteArray(IntFunction<int[]> fa,\n-                                    ByteOrder bo) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, bo);\n-        byte[] r = new byte[a.length];\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                IntVector av = IntVector.fromByteArray(SPECIES, a, i, bo);\n-                av.intoByteArray(r, i, bo);\n-            }\n-        }\n-        Assert.assertEquals(r, a, \"Byte arrays not equal\");\n-    }\n-\n-    @Test(dataProvider = \"intByteProviderForIOOBE\")\n-    static void loadByteArrayIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-\n+        int l = (int) a.byteSize();\n@@ -776,1 +617,0 @@\n-        int l = a.length;\n@@ -780,2 +620,2 @@\n-                IntVector av = fromByteArray(a, i, ByteOrder.nativeOrder());\n-                av.intoByteArray(r, i, ByteOrder.nativeOrder());\n+                IntVector av = IntVector.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+                intoMemorySegment(av, r, i, ByteOrder.nativeOrder(), vmask);\n@@ -785,2 +625,2 @@\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.length);\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() \/ 8);\n@@ -788,1 +628,2 @@\n-            fromByteArray(a, index, ByteOrder.nativeOrder());\n+            IntVector av = IntVector.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+            intoMemorySegment(av, a, index, ByteOrder.nativeOrder(), vmask);\n@@ -799,62 +640,5 @@\n-    @Test(dataProvider = \"intByteProviderForIOOBE\")\n-    static void storeByteArrayIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                IntVector av = IntVector.fromByteArray(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteArray(av, r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.length);\n-        try {\n-            IntVector av = IntVector.fromByteArray(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteArray(av, r, index, ByteOrder.nativeOrder());\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"intByteArrayMaskProvider\")\n-    static void loadStoreByteArrayMask(IntFunction<int[]> fa,\n-                                  IntFunction<boolean[]> fm,\n-                                  ByteOrder bo) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, bo);\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Integer> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-          for (int i = 0; i < l; i += s) {\n-              IntVector av = IntVector.fromByteArray(SPECIES, a, i, bo, vmask);\n-              av.intoByteArray(r, i, bo);\n-          }\n-        }\n-        assertArraysEquals(r, a, mask);\n-\n-\n-        r = new byte[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                IntVector av = IntVector.fromByteArray(SPECIES, a, i, bo);\n-                av.intoByteArray(r, i, bo, vmask);\n-            }\n-        }\n-        assertArraysEquals(r, a, mask);\n-    }\n+    @Test(dataProvider = \"intMemorySegmentProvider\")\n+    static void loadStoreReadonlyMemorySegment(IntFunction<int[]> fa,\n+                                               IntFunction<MemorySegment> fb,\n+                                               ByteOrder bo) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb).asReadOnly();\n@@ -862,6 +646,4 @@\n-    @Test(dataProvider = \"intByteMaskProviderForIOOBE\")\n-    static void loadByteArrayMaskIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Integer> vmask = VectorMask.fromValues(SPECIES, mask);\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo)\n+        );\n@@ -869,2 +651,4 @@\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(true))\n+        );\n@@ -872,6 +656,4 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                IntVector av = fromByteArray(a, i, ByteOrder.nativeOrder(), vmask);\n-                av.intoByteArray(r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(false))\n+        );\n@@ -879,12 +661,6 @@\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length, SPECIES.elementSize() \/ 8);\n-        try {\n-            fromByteArray(a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n+        VectorMask<Integer> m = SPECIES.shuffleFromOp(i -> i % 2 == 0 ? 1 : -1)\n+                .laneIsValid();\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, m)\n+        );\n@@ -893,31 +669,0 @@\n-    @Test(dataProvider = \"intByteMaskProviderForIOOBE\")\n-    static void storeByteArrayMaskIOOBE(IntFunction<int[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Integer> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                IntVector av = IntVector.fromByteArray(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteArray(av, r, i, ByteOrder.nativeOrder(), vmask);\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length, SPECIES.elementSize() \/ 8);\n-        try {\n-            IntVector av = IntVector.fromByteArray(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteArray(av, a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n@@ -939,0 +684,1 @@\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/IntMaxVectorLoadStoreTests.java","additions":112,"deletions":366,"binary":false,"changes":478,"status":"modified"},{"patch":"@@ -269,0 +269,49 @@\n+    static void assertcompressArraysEquals(int[] r, int[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    Assert.assertEquals(r[i + k], (int)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (int)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals(int[] r, int[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        Assert.assertEquals(r[i + j], (int)0);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (int)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n@@ -892,1 +941,0 @@\n-\n@@ -987,2 +1035,0 @@\n-\n-\n@@ -1034,1 +1080,0 @@\n-\n@@ -1175,0 +1220,12 @@\n+    static int TRAILING_ZEROS_COUNT_scalar(int a) {\n+        return Integer.numberOfTrailingZeros(a);\n+    }\n+\n+    static int LEADING_ZEROS_COUNT_scalar(int a) {\n+        return Integer.numberOfLeadingZeros(a);\n+    }\n+\n+    static int REVERSE_scalar(int a) {\n+        return Integer.reverse(a);\n+    }\n+\n@@ -1329,0 +1386,1 @@\n+\n@@ -1349,0 +1407,1 @@\n+\n@@ -1405,0 +1464,1 @@\n+\n@@ -1425,0 +1485,1 @@\n+\n@@ -1481,0 +1542,1 @@\n+\n@@ -1501,0 +1563,1 @@\n+\n@@ -1558,2 +1621,0 @@\n-\n-\n@@ -1582,0 +1643,1 @@\n+\n@@ -1605,2 +1667,0 @@\n-\n-\n@@ -1712,0 +1772,1 @@\n+\n@@ -1731,2 +1792,0 @@\n-\n-\n@@ -1753,1 +1812,0 @@\n-\n@@ -1775,2 +1833,0 @@\n-\n-\n@@ -1797,1 +1853,0 @@\n-\n@@ -1818,0 +1873,1 @@\n+\n@@ -1837,2 +1893,0 @@\n-\n-\n@@ -1859,1 +1913,0 @@\n-\n@@ -1881,2 +1934,0 @@\n-\n-\n@@ -1903,0 +1954,81 @@\n+    static int COMPRESS_BITS(int a, int b) {\n+        return (int)(Integer.compress(a, b));\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpProvider\")\n+    static void COMPRESS_BITSIntMaxVectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.COMPRESS_BITS, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, IntMaxVectorTests::COMPRESS_BITS);\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpMaskProvider\")\n+    static void COMPRESS_BITSIntMaxVectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.COMPRESS_BITS, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, IntMaxVectorTests::COMPRESS_BITS);\n+    }\n+\n+    static int EXPAND_BITS(int a, int b) {\n+        return (int)(Integer.expand(a, b));\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpProvider\")\n+    static void EXPAND_BITSIntMaxVectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.EXPAND_BITS, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, IntMaxVectorTests::EXPAND_BITS);\n+    }\n+\n+    @Test(dataProvider = \"intBinaryOpMaskProvider\")\n+    static void EXPAND_BITSIntMaxVectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.EXPAND_BITS, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, IntMaxVectorTests::EXPAND_BITS);\n+    }\n@@ -1997,3 +2129,0 @@\n-\n-\n-\n@@ -2016,2 +2145,0 @@\n-\n-\n@@ -2037,2 +2164,0 @@\n-\n-\n@@ -2067,2 +2192,0 @@\n-\n-\n@@ -2086,2 +2209,0 @@\n-\n-\n@@ -2116,2 +2237,0 @@\n-\n-\n@@ -2135,2 +2254,0 @@\n-\n-\n@@ -2151,2 +2268,0 @@\n-\n-\n@@ -2170,1 +2285,0 @@\n-\n@@ -2223,2 +2337,0 @@\n-\n-\n@@ -2245,5 +2357,0 @@\n-\n-\n-\n-\n-\n@@ -2271,2 +2378,0 @@\n-\n-\n@@ -2293,5 +2398,0 @@\n-\n-\n-\n-\n-\n@@ -2319,2 +2419,0 @@\n-\n-\n@@ -2341,5 +2439,0 @@\n-\n-\n-\n-\n-\n@@ -2366,2 +2459,0 @@\n-\n-\n@@ -2387,5 +2478,0 @@\n-\n-\n-\n-\n-\n@@ -2412,2 +2498,0 @@\n-\n-\n@@ -2433,5 +2517,0 @@\n-\n-\n-\n-\n-\n@@ -2458,2 +2537,0 @@\n-\n-\n@@ -2479,5 +2556,0 @@\n-\n-\n-\n-\n-\n@@ -2505,2 +2577,0 @@\n-\n-\n@@ -2527,1 +2597,0 @@\n-\n@@ -2549,2 +2618,0 @@\n-\n-\n@@ -2571,1 +2638,0 @@\n-\n@@ -2592,2 +2658,0 @@\n-\n-\n@@ -2613,1 +2677,0 @@\n-\n@@ -2634,2 +2697,0 @@\n-\n-\n@@ -2654,2 +2715,0 @@\n-\n-\n@@ -2675,2 +2734,0 @@\n-\n-\n@@ -2695,6 +2752,0 @@\n-\n-\n-\n-\n-\n-\n@@ -2720,2 +2771,0 @@\n-\n-\n@@ -2740,2 +2789,0 @@\n-\n-\n@@ -2761,2 +2808,0 @@\n-\n-\n@@ -2781,2 +2826,0 @@\n-\n-\n@@ -2802,2 +2845,0 @@\n-\n-\n@@ -2822,2 +2863,0 @@\n-\n-\n@@ -2843,2 +2882,0 @@\n-\n-\n@@ -2884,0 +2921,1 @@\n+\n@@ -2902,0 +2940,1 @@\n+\n@@ -2922,0 +2961,1 @@\n+\n@@ -3015,1 +3055,0 @@\n-\n@@ -3041,1 +3080,0 @@\n-\n@@ -3061,1 +3099,0 @@\n-\n@@ -3089,1 +3126,0 @@\n-\n@@ -3108,1 +3144,0 @@\n-\n@@ -3134,1 +3169,0 @@\n-\n@@ -3154,1 +3188,0 @@\n-\n@@ -3182,1 +3215,0 @@\n-\n@@ -3201,1 +3233,0 @@\n-\n@@ -3227,1 +3258,0 @@\n-\n@@ -3247,1 +3277,0 @@\n-\n@@ -3292,0 +3321,1 @@\n+\n@@ -3316,0 +3346,1 @@\n+\n@@ -3334,0 +3365,1 @@\n+\n@@ -3360,0 +3392,1 @@\n+\n@@ -3377,0 +3410,1 @@\n+\n@@ -3401,0 +3435,1 @@\n+\n@@ -3419,0 +3454,1 @@\n+\n@@ -3445,0 +3481,1 @@\n+\n@@ -3462,0 +3499,1 @@\n+\n@@ -3486,0 +3524,1 @@\n+\n@@ -3504,0 +3543,1 @@\n+\n@@ -3530,0 +3570,1 @@\n+\n@@ -3547,0 +3588,1 @@\n+\n@@ -3571,0 +3613,1 @@\n+\n@@ -3589,0 +3632,1 @@\n+\n@@ -3615,0 +3659,1 @@\n+\n@@ -3632,0 +3677,1 @@\n+\n@@ -3656,0 +3702,1 @@\n+\n@@ -3674,0 +3721,1 @@\n+\n@@ -3710,1 +3758,0 @@\n-\n@@ -3726,1 +3773,0 @@\n-\n@@ -3736,1 +3782,0 @@\n-\n@@ -3752,1 +3797,0 @@\n-\n@@ -3770,0 +3814,1 @@\n+\n@@ -3810,0 +3855,1 @@\n+\n@@ -3851,3 +3897,0 @@\n-\n-\n-\n@@ -3873,1 +3916,0 @@\n-\n@@ -3916,1 +3958,0 @@\n-\n@@ -3959,1 +4000,0 @@\n-\n@@ -3979,1 +4019,0 @@\n-\n@@ -4022,1 +4061,0 @@\n-\n@@ -4065,1 +4103,0 @@\n-\n@@ -4108,1 +4145,0 @@\n-\n@@ -4151,2 +4187,0 @@\n-\n-\n@@ -4172,2 +4206,0 @@\n-\n-\n@@ -4197,3 +4229,0 @@\n-\n-\n-\n@@ -4219,2 +4248,0 @@\n-\n-\n@@ -4244,3 +4271,0 @@\n-\n-\n-\n@@ -4266,2 +4290,0 @@\n-\n-\n@@ -4291,3 +4313,0 @@\n-\n-\n-\n@@ -4313,2 +4332,0 @@\n-\n-\n@@ -4338,2 +4355,0 @@\n-\n-\n@@ -4356,1 +4371,0 @@\n-\n@@ -4393,1 +4407,0 @@\n-\n@@ -4430,1 +4443,0 @@\n-\n@@ -4467,1 +4479,0 @@\n-\n@@ -4546,0 +4557,37 @@\n+\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void compressIntMaxVectorTests(IntFunction<int[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.compress(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertcompressArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void expandIntMaxVectorTests(IntFunction<int[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.expand(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertexpandArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n@@ -4716,4 +4764,0 @@\n-\n-\n-\n-\n@@ -4734,3 +4778,0 @@\n-\n-\n-\n@@ -4762,0 +4803,1 @@\n+\n@@ -4791,0 +4833,1 @@\n+\n@@ -4824,0 +4867,1 @@\n+\n@@ -4851,0 +4895,1 @@\n+\n@@ -4890,0 +4935,1 @@\n+\n@@ -4947,22 +4993,0 @@\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n@@ -4972,0 +4996,1 @@\n+\n@@ -4976,1 +5001,0 @@\n-\n@@ -4995,0 +5019,1 @@\n+\n@@ -5012,1 +5037,0 @@\n-\n@@ -5035,3 +5059,0 @@\n-\n-\n-\n@@ -5067,0 +5088,1 @@\n+\n@@ -5097,1 +5119,0 @@\n-\n@@ -5136,3 +5157,0 @@\n-\n-\n-\n@@ -5153,0 +5171,1 @@\n+\n@@ -5168,1 +5187,0 @@\n-\n@@ -5187,1 +5205,0 @@\n-\n@@ -5300,1 +5317,0 @@\n-\n@@ -5309,2 +5325,0 @@\n-\n-\n@@ -5341,2 +5355,0 @@\n-\n-\n@@ -5361,2 +5373,0 @@\n-\n-\n@@ -5367,2 +5377,0 @@\n-\n-\n@@ -5384,2 +5392,0 @@\n-\n-\n@@ -5404,0 +5410,3 @@\n+    static int BIT_COUNT(int a) {\n+        return (int)(Integer.bitCount(a));\n+    }\n@@ -5405,0 +5414,4 @@\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void BIT_COUNTIntMaxVectorTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n@@ -5406,0 +5419,9 @@\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, IntMaxVectorTests::BIT_COUNT);\n+    }\n@@ -5407,0 +5429,165 @@\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void BIT_COUNTMaskedIntMaxVectorTests(IntFunction<int[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, IntMaxVectorTests::BIT_COUNT);\n+    }\n+\n+    static int TRAILING_ZEROS_COUNT(int a) {\n+        return (int)(TRAILING_ZEROS_COUNT_scalar(a));\n+    }\n+\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void TRAILING_ZEROS_COUNTIntMaxVectorTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TRAILING_ZEROS_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, IntMaxVectorTests::TRAILING_ZEROS_COUNT);\n+    }\n+\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void TRAILING_ZEROS_COUNTMaskedIntMaxVectorTests(IntFunction<int[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TRAILING_ZEROS_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, IntMaxVectorTests::TRAILING_ZEROS_COUNT);\n+    }\n+\n+    static int LEADING_ZEROS_COUNT(int a) {\n+        return (int)(LEADING_ZEROS_COUNT_scalar(a));\n+    }\n+\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void LEADING_ZEROS_COUNTIntMaxVectorTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LEADING_ZEROS_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, IntMaxVectorTests::LEADING_ZEROS_COUNT);\n+    }\n+\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void LEADING_ZEROS_COUNTMaskedIntMaxVectorTests(IntFunction<int[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LEADING_ZEROS_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, IntMaxVectorTests::LEADING_ZEROS_COUNT);\n+    }\n+\n+    static int REVERSE(int a) {\n+        return (int)(REVERSE_scalar(a));\n+    }\n+\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void REVERSEIntMaxVectorTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, IntMaxVectorTests::REVERSE);\n+    }\n+\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void REVERSEMaskedIntMaxVectorTests(IntFunction<int[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, IntMaxVectorTests::REVERSE);\n+    }\n+\n+    static int REVERSE_BYTES(int a) {\n+        return (int)(Integer.reverseBytes(a));\n+    }\n+\n+    @Test(dataProvider = \"intUnaryOpProvider\")\n+    static void REVERSE_BYTESIntMaxVectorTests(IntFunction<int[]> fa) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, IntMaxVectorTests::REVERSE_BYTES);\n+    }\n+\n+    @Test(dataProvider = \"intUnaryOpMaskProvider\")\n+    static void REVERSE_BYTESMaskedIntMaxVectorTests(IntFunction<int[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, IntMaxVectorTests::REVERSE_BYTES);\n+    }\n@@ -5809,0 +5996,17 @@\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCompressIntMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        int trueCount = 0;\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                trueCount = vmask.trueCount();\n+                var rmask = vmask.compress();\n+                for (int j = 0; j < SPECIES.length(); j++)  {\n+                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);\n+                }\n+            }\n+        }\n+    }\n+\n@@ -5835,0 +6039,14 @@\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeLongIntMaxVectorTestsSmokeTest(int offset) {\n+        long limit = SPECIES.length() * BUFFER_REPS;\n+        for (long i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i + offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                long index = i + j + offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n@@ -5855,0 +6073,8 @@\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundLongIntMaxVectorTestsSmokeTest(int _length) {\n+        long length = _length;\n+        long actualLoopBound = SPECIES.loopBound(length);\n+        long expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+    }\n+\n@@ -5917,1 +6143,0 @@\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/IntMaxVectorTests.java","additions":441,"deletions":216,"binary":false,"changes":657,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,3 @@\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.ValueLayout;\n@@ -42,2 +45,0 @@\n-import java.nio.ByteBuffer;\n-import java.nio.LongBuffer;\n@@ -45,1 +46,0 @@\n-import java.nio.ReadOnlyBufferException;\n@@ -70,11 +70,0 @@\n-    static void assertArraysEquals(byte[] r, byte[] a, boolean[] mask) {\n-        int i = 0;\n-        try {\n-            for (; i < a.length; i++) {\n-                Assert.assertEquals(r[i], mask[(i*8\/SPECIES.elementSize()) % SPECIES.length()] ? a[i] : (byte) 0);\n-            }\n-        } catch (AssertionError e) {\n-            Assert.assertEquals(r[i], mask[(i*8\/SPECIES.elementSize()) % SPECIES.length()] ? a[i] : (byte) 0, \"at index #\" + i);\n-        }\n-    }\n-\n@@ -120,1 +109,1 @@\n-    \/\/ Relative to byte[] array.length or ByteBuffer.limit()\n+    \/\/ Relative to byte[] array.length or MemorySegment.byteSize()\n@@ -191,1 +180,1 @@\n-    public Object[][] longByteBufferProvider() {\n+    public Object[][] longMemorySegmentProvider() {\n@@ -193,1 +182,1 @@\n-                flatMap(fa -> BYTE_BUFFER_GENERATORS.stream().\n+                flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n@@ -201,1 +190,1 @@\n-    public Object[][] longByteBufferMaskProvider() {\n+    public Object[][] longMemorySegmentMaskProvider() {\n@@ -204,1 +193,1 @@\n-                        flatMap(fa -> BYTE_BUFFER_GENERATORS.stream().\n+                        flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n@@ -211,19 +200,0 @@\n-    @DataProvider\n-    public Object[][] longByteArrayProvider() {\n-        return LONG_GENERATORS.stream().\n-                flatMap(fa -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                    return new Object[]{fa, bo};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] longByteArrayMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> LONG_GENERATORS.stream().\n-                    flatMap(fa -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                        return new Object[]{fa, fm, bo};\n-                    }))).\n-                toArray(Object[][]::new);\n-    }\n-\n@@ -249,4 +219,4 @@\n-    static ByteBuffer toBuffer(long[] a, IntFunction<ByteBuffer> fb) {\n-        ByteBuffer bb = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n-        for (long v : a) {\n-            bb.putLong(v);\n+    static MemorySegment toSegment(long[] a, IntFunction<MemorySegment> fb) {\n+        MemorySegment ms = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n+        for (int i = 0; i < a.length; i++) {\n+            ms.set(ValueLayout.JAVA_LONG, i * SPECIES.elementSize() \/ 8 , a[i]);\n@@ -254,1 +224,1 @@\n-        return bb.clear();\n+        return ms;\n@@ -257,14 +227,2 @@\n-    static long[] bufferToArray(ByteBuffer bb) {\n-        LongBuffer db = bb.asLongBuffer();\n-        long[] d = new long[db.capacity()];\n-        db.get(0, d);\n-        return d;\n-    }\n-\n-    static byte[] toByteArray(long[] a, IntFunction<byte[]> fb, ByteOrder bo) {\n-        byte[] b = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n-        LongBuffer bb = ByteBuffer.wrap(b, 0, b.length).order(bo).asLongBuffer();\n-        for (long v : a) {\n-            bb.put(v);\n-        }\n-        return b;\n+    static long[] segmentToArray(MemorySegment ms) {\n+        return ms.toArray(ValueLayout.JAVA_LONG);\n@@ -310,22 +268,2 @@\n-    static LongVector fromByteArray(byte[] a, int i, ByteOrder bo) {\n-        return LongVector.fromByteArray(SPECIES, a, i, bo);\n-    }\n-\n-    @DontInline\n-    static LongVector fromByteArray(byte[] a, int i, ByteOrder bo, VectorMask<Long> m) {\n-        return LongVector.fromByteArray(SPECIES, a, i, bo, m);\n-    }\n-\n-    @DontInline\n-    static void intoByteArray(LongVector v, byte[] a, int i, ByteOrder bo) {\n-        v.intoByteArray(a, i, bo);\n-    }\n-\n-    @DontInline\n-    static void intoByteArray(LongVector v, byte[] a, int i, ByteOrder bo, VectorMask<Long> m) {\n-        v.intoByteArray(a, i, bo, m);\n-    }\n-\n-    @DontInline\n-    static LongVector fromByteBuffer(ByteBuffer a, int i, ByteOrder bo) {\n-        return LongVector.fromByteBuffer(SPECIES, a, i, bo);\n+    static LongVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo) {\n+        return LongVector.fromMemorySegment(SPECIES, a, i, bo);\n@@ -335,2 +273,2 @@\n-    static LongVector fromByteBuffer(ByteBuffer a, int i, ByteOrder bo, VectorMask<Long> m) {\n-        return LongVector.fromByteBuffer(SPECIES, a, i, bo, m);\n+    static LongVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo, VectorMask<Long> m) {\n+        return LongVector.fromMemorySegment(SPECIES, a, i, bo, m);\n@@ -340,2 +278,2 @@\n-    static void intoByteBuffer(LongVector v, ByteBuffer a, int i, ByteOrder bo) {\n-        v.intoByteBuffer(a, i, bo);\n+    static void intoMemorySegment(LongVector v, MemorySegment a, int i, ByteOrder bo) {\n+        v.intoMemorySegment(a, i, bo);\n@@ -345,2 +283,2 @@\n-    static void intoByteBuffer(LongVector v, ByteBuffer a, int i, ByteOrder bo, VectorMask<Long> m) {\n-        v.intoByteBuffer(a, i, bo, m);\n+    static void intoMemorySegment(LongVector v, MemorySegment a, int i, ByteOrder bo, VectorMask<Long> m) {\n+        v.intoMemorySegment(a, i, bo, m);\n@@ -349,1 +287,0 @@\n-\n@@ -520,6 +457,6 @@\n-    @Test(dataProvider = \"longByteBufferProvider\")\n-    static void loadStoreByteBuffer(IntFunction<long[]> fa,\n-                                    IntFunction<ByteBuffer> fb,\n-                                    ByteOrder bo) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), fb);\n-        ByteBuffer r = fb.apply(a.limit());\n+    @Test(dataProvider = \"longMemorySegmentProvider\")\n+    static void loadStoreMemorySegment(IntFunction<long[]> fa,\n+                                       IntFunction<MemorySegment> fb,\n+                                       ByteOrder bo) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb);\n+        MemorySegment r = fb.apply((int) a.byteSize());\n@@ -527,1 +464,1 @@\n-        int l = a.limit();\n+        int l = (int) a.byteSize();\n@@ -532,2 +469,2 @@\n-                LongVector av = LongVector.fromByteBuffer(SPECIES, a, i, bo);\n-                av.intoByteBuffer(r, i, bo);\n+                LongVector av = LongVector.fromMemorySegment(SPECIES, a, i, bo);\n+                av.intoMemorySegment(r, i, bo);\n@@ -536,5 +473,2 @@\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        Assert.assertEquals(r, a, \"Buffers not equal\");\n+        long m = r.mismatch(a);\n+        Assert.assertEquals(m, -1, \"Segments not equal\");\n@@ -544,3 +478,3 @@\n-    static void loadByteBufferIOOBE(IntFunction<long[]> fa, IntFunction<Integer> fi) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n+    static void loadMemorySegmentIOOBE(IntFunction<long[]> fa, IntFunction<Integer> fi) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n@@ -548,1 +482,1 @@\n-        int l = a.limit();\n+        int l = (int) a.byteSize();\n@@ -553,2 +487,2 @@\n-                LongVector av = fromByteBuffer(a, i, ByteOrder.nativeOrder());\n-                av.intoByteBuffer(r, i, ByteOrder.nativeOrder());\n+                LongVector av = fromMemorySegment(a, i, ByteOrder.nativeOrder());\n+                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n@@ -558,2 +492,2 @@\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.limit());\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());\n@@ -561,1 +495,1 @@\n-            fromByteBuffer(a, index, ByteOrder.nativeOrder());\n+            fromMemorySegment(a, index, ByteOrder.nativeOrder());\n@@ -573,3 +507,3 @@\n-    static void storeByteBufferIOOBE(IntFunction<long[]> fa, IntFunction<Integer> fi) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n+    static void storeMemorySegmentIOOBE(IntFunction<long[]> fa, IntFunction<Integer> fi) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n@@ -577,1 +511,1 @@\n-        int l = a.limit();\n+        int l = (int) a.byteSize();\n@@ -582,2 +516,2 @@\n-                LongVector av = LongVector.fromByteBuffer(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteBuffer(av, r, i, ByteOrder.nativeOrder());\n+                LongVector av = LongVector.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+                intoMemorySegment(av, r, i, ByteOrder.nativeOrder());\n@@ -587,2 +521,2 @@\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.limit());\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());\n@@ -590,2 +524,2 @@\n-            LongVector av = LongVector.fromByteBuffer(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteBuffer(av, r, index, ByteOrder.nativeOrder());\n+            LongVector av = LongVector.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+            intoMemorySegment(av, r, index, ByteOrder.nativeOrder());\n@@ -602,6 +536,5 @@\n-\n-    @Test(dataProvider = \"longByteBufferMaskProvider\")\n-    static void loadStoreByteBufferMask(IntFunction<long[]> fa,\n-                                        IntFunction<ByteBuffer> fb,\n-                                        IntFunction<boolean[]> fm,\n-                                        ByteOrder bo) {\n+    @Test(dataProvider = \"longMemorySegmentMaskProvider\")\n+    static void loadStoreMemorySegmentMask(IntFunction<long[]> fa,\n+                                           IntFunction<MemorySegment> fb,\n+                                           IntFunction<boolean[]> fm,\n+                                           ByteOrder bo) {\n@@ -609,2 +542,2 @@\n-        ByteBuffer a = toBuffer(_a, fb);\n-        ByteBuffer r = fb.apply(a.limit());\n+        MemorySegment a = toSegment(_a, fb);\n+        MemorySegment r = fb.apply((int) a.byteSize());\n@@ -614,1 +547,1 @@\n-        int l = a.limit();\n+        int l = (int) a.byteSize();\n@@ -619,2 +552,2 @@\n-                LongVector av = LongVector.fromByteBuffer(SPECIES, a, i, bo, vmask);\n-                av.intoByteBuffer(r, i, bo);\n+                LongVector av = LongVector.fromMemorySegment(SPECIES, a, i, bo, vmask);\n+                av.intoMemorySegment(r, i, bo);\n@@ -623,5 +556,1 @@\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        assertArraysEquals(bufferToArray(r), _a, mask);\n+        assertArraysEquals(segmentToArray(r), _a, mask);\n@@ -630,1 +559,1 @@\n-        r = fb.apply(a.limit());\n+        r = fb.apply((int) a.byteSize());\n@@ -634,2 +563,2 @@\n-                LongVector av = LongVector.fromByteBuffer(SPECIES, a, i, bo);\n-                av.intoByteBuffer(r, i, bo, vmask);\n+                LongVector av = LongVector.fromMemorySegment(SPECIES, a, i, bo);\n+                av.intoMemorySegment(r, i, bo, vmask);\n@@ -638,5 +567,1 @@\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        assertArraysEquals(bufferToArray(r), _a, mask);\n+        assertArraysEquals(segmentToArray(r), _a, mask);\n@@ -646,3 +571,3 @@\n-    static void loadByteBufferMaskIOOBE(IntFunction<long[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n+    static void loadMemorySegmentMaskIOOBE(IntFunction<long[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n@@ -652,1 +577,1 @@\n-        int l = a.limit();\n+        int l = (int) a.byteSize();\n@@ -657,2 +582,2 @@\n-                LongVector av = fromByteBuffer(a, i, ByteOrder.nativeOrder(), vmask);\n-                av.intoByteBuffer(r, i, ByteOrder.nativeOrder());\n+                LongVector av = fromMemorySegment(a, i, ByteOrder.nativeOrder(), vmask);\n+                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n@@ -662,2 +587,2 @@\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.limit(), SPECIES.elementSize() \/ 8);\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() \/ 8);\n@@ -665,1 +590,1 @@\n-            fromByteBuffer(a, index, ByteOrder.nativeOrder(), vmask);\n+            fromMemorySegment(a, index, ByteOrder.nativeOrder(), vmask);\n@@ -677,3 +602,3 @@\n-    static void storeByteBufferMaskIOOBE(IntFunction<long[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n+    static void storeMemorySegmentMaskIOOBE(IntFunction<long[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n@@ -683,83 +608,1 @@\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                LongVector av = LongVector.fromByteBuffer(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteBuffer(av, r, i, ByteOrder.nativeOrder(), vmask);\n-            }\n-        }\n-\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.limit(), SPECIES.elementSize() \/ 8);\n-        try {\n-            LongVector av = LongVector.fromByteBuffer(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteBuffer(av, a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"longByteBufferProvider\")\n-    static void loadStoreReadonlyByteBuffer(IntFunction<long[]> fa,\n-                                    IntFunction<ByteBuffer> fb,\n-                                    ByteOrder bo) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), fb).asReadOnlyBuffer();\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo);\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, SPECIES.maskAll(true));\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, SPECIES.maskAll(false));\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            VectorMask<Long> m = SPECIES.shuffleFromOp(i -> i % 2 == 0 ? 1 : -1)\n-                    .laneIsValid();\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, m);\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"longByteArrayProvider\")\n-    static void loadStoreByteArray(IntFunction<long[]> fa,\n-                                    ByteOrder bo) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, bo);\n-        byte[] r = new byte[a.length];\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                LongVector av = LongVector.fromByteArray(SPECIES, a, i, bo);\n-                av.intoByteArray(r, i, bo);\n-            }\n-        }\n-        Assert.assertEquals(r, a, \"Byte arrays not equal\");\n-    }\n-\n-    @Test(dataProvider = \"longByteProviderForIOOBE\")\n-    static void loadByteArrayIOOBE(IntFunction<long[]> fa, IntFunction<Integer> fi) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-\n+        int l = (int) a.byteSize();\n@@ -767,1 +610,0 @@\n-        int l = a.length;\n@@ -771,2 +613,2 @@\n-                LongVector av = fromByteArray(a, i, ByteOrder.nativeOrder());\n-                av.intoByteArray(r, i, ByteOrder.nativeOrder());\n+                LongVector av = LongVector.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+                intoMemorySegment(av, r, i, ByteOrder.nativeOrder(), vmask);\n@@ -776,2 +618,2 @@\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.length);\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() \/ 8);\n@@ -779,1 +621,2 @@\n-            fromByteArray(a, index, ByteOrder.nativeOrder());\n+            LongVector av = LongVector.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+            intoMemorySegment(av, a, index, ByteOrder.nativeOrder(), vmask);\n@@ -790,62 +633,5 @@\n-    @Test(dataProvider = \"longByteProviderForIOOBE\")\n-    static void storeByteArrayIOOBE(IntFunction<long[]> fa, IntFunction<Integer> fi) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                LongVector av = LongVector.fromByteArray(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteArray(av, r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.length);\n-        try {\n-            LongVector av = LongVector.fromByteArray(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteArray(av, r, index, ByteOrder.nativeOrder());\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"longByteArrayMaskProvider\")\n-    static void loadStoreByteArrayMask(IntFunction<long[]> fa,\n-                                  IntFunction<boolean[]> fm,\n-                                  ByteOrder bo) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, bo);\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Long> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-          for (int i = 0; i < l; i += s) {\n-              LongVector av = LongVector.fromByteArray(SPECIES, a, i, bo, vmask);\n-              av.intoByteArray(r, i, bo);\n-          }\n-        }\n-        assertArraysEquals(r, a, mask);\n-\n-\n-        r = new byte[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                LongVector av = LongVector.fromByteArray(SPECIES, a, i, bo);\n-                av.intoByteArray(r, i, bo, vmask);\n-            }\n-        }\n-        assertArraysEquals(r, a, mask);\n-    }\n+    @Test(dataProvider = \"longMemorySegmentProvider\")\n+    static void loadStoreReadonlyMemorySegment(IntFunction<long[]> fa,\n+                                               IntFunction<MemorySegment> fb,\n+                                               ByteOrder bo) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb).asReadOnly();\n@@ -853,6 +639,4 @@\n-    @Test(dataProvider = \"longByteMaskProviderForIOOBE\")\n-    static void loadByteArrayMaskIOOBE(IntFunction<long[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Long> vmask = VectorMask.fromValues(SPECIES, mask);\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo)\n+        );\n@@ -860,2 +644,4 @@\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(true))\n+        );\n@@ -863,6 +649,4 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                LongVector av = fromByteArray(a, i, ByteOrder.nativeOrder(), vmask);\n-                av.intoByteArray(r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(false))\n+        );\n@@ -870,12 +654,6 @@\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length, SPECIES.elementSize() \/ 8);\n-        try {\n-            fromByteArray(a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n+        VectorMask<Long> m = SPECIES.shuffleFromOp(i -> i % 2 == 0 ? 1 : -1)\n+                .laneIsValid();\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, m)\n+        );\n@@ -884,31 +662,0 @@\n-    @Test(dataProvider = \"longByteMaskProviderForIOOBE\")\n-    static void storeByteArrayMaskIOOBE(IntFunction<long[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Long> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                LongVector av = LongVector.fromByteArray(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteArray(av, r, i, ByteOrder.nativeOrder(), vmask);\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length, SPECIES.elementSize() \/ 8);\n-        try {\n-            LongVector av = LongVector.fromByteArray(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteArray(av, a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n@@ -930,0 +677,1 @@\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long128VectorLoadStoreTests.java","additions":112,"deletions":364,"binary":false,"changes":476,"status":"modified"},{"patch":"@@ -221,0 +221,49 @@\n+    static void assertcompressArraysEquals(long[] r, long[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    Assert.assertEquals(r[i + k], (long)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (long)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals(long[] r, long[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        Assert.assertEquals(r[i + j], (long)0);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (long)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n@@ -877,1 +926,0 @@\n-\n@@ -979,1 +1027,0 @@\n-\n@@ -1055,1 +1102,0 @@\n-\n@@ -1167,1 +1213,0 @@\n-\n@@ -1192,0 +1237,12 @@\n+    static long TRAILING_ZEROS_COUNT_scalar(long a) {\n+        return Long.numberOfTrailingZeros(a);\n+    }\n+\n+    static long LEADING_ZEROS_COUNT_scalar(long a) {\n+        return Long.numberOfLeadingZeros(a);\n+    }\n+\n+    static long REVERSE_scalar(long a) {\n+        return Long.reverse(a);\n+    }\n+\n@@ -1346,0 +1403,1 @@\n+\n@@ -1366,0 +1424,1 @@\n+\n@@ -1422,0 +1481,1 @@\n+\n@@ -1442,0 +1502,1 @@\n+\n@@ -1498,0 +1559,1 @@\n+\n@@ -1518,0 +1580,1 @@\n+\n@@ -1575,2 +1638,0 @@\n-\n-\n@@ -1599,0 +1660,1 @@\n+\n@@ -1622,2 +1684,0 @@\n-\n-\n@@ -1729,0 +1789,1 @@\n+\n@@ -1748,2 +1809,0 @@\n-\n-\n@@ -1770,1 +1829,0 @@\n-\n@@ -1792,2 +1850,0 @@\n-\n-\n@@ -1814,1 +1870,0 @@\n-\n@@ -1835,0 +1890,1 @@\n+\n@@ -1854,2 +1910,0 @@\n-\n-\n@@ -1876,1 +1930,0 @@\n-\n@@ -1898,2 +1951,0 @@\n-\n-\n@@ -1920,0 +1971,81 @@\n+    static long COMPRESS_BITS(long a, long b) {\n+        return (long)(Long.compress(a, b));\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpProvider\")\n+    static void COMPRESS_BITSLong128VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.COMPRESS_BITS, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Long128VectorTests::COMPRESS_BITS);\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpMaskProvider\")\n+    static void COMPRESS_BITSLong128VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.COMPRESS_BITS, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Long128VectorTests::COMPRESS_BITS);\n+    }\n+\n+    static long EXPAND_BITS(long a, long b) {\n+        return (long)(Long.expand(a, b));\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpProvider\")\n+    static void EXPAND_BITSLong128VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.EXPAND_BITS, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Long128VectorTests::EXPAND_BITS);\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpMaskProvider\")\n+    static void EXPAND_BITSLong128VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.EXPAND_BITS, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Long128VectorTests::EXPAND_BITS);\n+    }\n@@ -2014,3 +2146,0 @@\n-\n-\n-\n@@ -2033,2 +2162,0 @@\n-\n-\n@@ -2054,2 +2181,0 @@\n-\n-\n@@ -2084,2 +2209,0 @@\n-\n-\n@@ -2103,2 +2226,0 @@\n-\n-\n@@ -2133,2 +2254,0 @@\n-\n-\n@@ -2152,2 +2271,0 @@\n-\n-\n@@ -2168,2 +2285,0 @@\n-\n-\n@@ -2187,1 +2302,0 @@\n-\n@@ -2240,2 +2354,0 @@\n-\n-\n@@ -2262,5 +2374,0 @@\n-\n-\n-\n-\n-\n@@ -2288,2 +2395,0 @@\n-\n-\n@@ -2310,5 +2415,0 @@\n-\n-\n-\n-\n-\n@@ -2336,2 +2436,0 @@\n-\n-\n@@ -2358,5 +2456,0 @@\n-\n-\n-\n-\n-\n@@ -2383,2 +2476,0 @@\n-\n-\n@@ -2404,5 +2495,0 @@\n-\n-\n-\n-\n-\n@@ -2429,2 +2515,0 @@\n-\n-\n@@ -2450,5 +2534,0 @@\n-\n-\n-\n-\n-\n@@ -2475,2 +2554,0 @@\n-\n-\n@@ -2496,5 +2573,0 @@\n-\n-\n-\n-\n-\n@@ -2522,2 +2594,0 @@\n-\n-\n@@ -2544,1 +2614,0 @@\n-\n@@ -2566,2 +2635,0 @@\n-\n-\n@@ -2588,1 +2655,0 @@\n-\n@@ -2609,2 +2675,0 @@\n-\n-\n@@ -2630,1 +2694,0 @@\n-\n@@ -2651,2 +2714,0 @@\n-\n-\n@@ -2671,2 +2732,0 @@\n-\n-\n@@ -2692,2 +2751,0 @@\n-\n-\n@@ -2712,6 +2769,0 @@\n-\n-\n-\n-\n-\n-\n@@ -2737,2 +2788,0 @@\n-\n-\n@@ -2757,2 +2806,0 @@\n-\n-\n@@ -2778,2 +2825,0 @@\n-\n-\n@@ -2798,2 +2843,0 @@\n-\n-\n@@ -2819,2 +2862,0 @@\n-\n-\n@@ -2839,2 +2880,0 @@\n-\n-\n@@ -2860,2 +2899,0 @@\n-\n-\n@@ -2901,0 +2938,1 @@\n+\n@@ -2919,0 +2957,1 @@\n+\n@@ -2939,0 +2978,1 @@\n+\n@@ -3032,1 +3072,0 @@\n-\n@@ -3058,1 +3097,0 @@\n-\n@@ -3078,1 +3116,0 @@\n-\n@@ -3106,1 +3143,0 @@\n-\n@@ -3125,1 +3161,0 @@\n-\n@@ -3151,1 +3186,0 @@\n-\n@@ -3171,1 +3205,0 @@\n-\n@@ -3199,1 +3232,0 @@\n-\n@@ -3218,1 +3250,0 @@\n-\n@@ -3244,1 +3275,0 @@\n-\n@@ -3264,1 +3294,0 @@\n-\n@@ -3309,0 +3338,1 @@\n+\n@@ -3333,0 +3363,1 @@\n+\n@@ -3351,0 +3382,1 @@\n+\n@@ -3377,0 +3409,1 @@\n+\n@@ -3394,0 +3427,1 @@\n+\n@@ -3418,0 +3452,1 @@\n+\n@@ -3436,0 +3471,1 @@\n+\n@@ -3462,0 +3498,1 @@\n+\n@@ -3479,0 +3516,1 @@\n+\n@@ -3503,0 +3541,1 @@\n+\n@@ -3521,0 +3560,1 @@\n+\n@@ -3547,0 +3587,1 @@\n+\n@@ -3564,0 +3605,1 @@\n+\n@@ -3588,0 +3630,1 @@\n+\n@@ -3606,0 +3649,1 @@\n+\n@@ -3632,0 +3676,1 @@\n+\n@@ -3649,0 +3694,1 @@\n+\n@@ -3673,0 +3719,1 @@\n+\n@@ -3691,0 +3738,1 @@\n+\n@@ -3727,1 +3775,0 @@\n-\n@@ -3743,1 +3790,0 @@\n-\n@@ -3753,1 +3799,0 @@\n-\n@@ -3769,1 +3814,0 @@\n-\n@@ -3787,0 +3831,1 @@\n+\n@@ -3827,0 +3872,1 @@\n+\n@@ -3868,3 +3914,0 @@\n-\n-\n-\n@@ -3890,1 +3933,0 @@\n-\n@@ -3933,1 +3975,0 @@\n-\n@@ -3976,1 +4017,0 @@\n-\n@@ -3996,1 +4036,0 @@\n-\n@@ -4039,1 +4078,0 @@\n-\n@@ -4082,1 +4120,0 @@\n-\n@@ -4125,1 +4162,0 @@\n-\n@@ -4168,2 +4204,0 @@\n-\n-\n@@ -4189,2 +4223,0 @@\n-\n-\n@@ -4214,3 +4246,0 @@\n-\n-\n-\n@@ -4236,2 +4265,0 @@\n-\n-\n@@ -4261,3 +4288,0 @@\n-\n-\n-\n@@ -4283,2 +4307,0 @@\n-\n-\n@@ -4308,3 +4330,0 @@\n-\n-\n-\n@@ -4330,2 +4349,0 @@\n-\n-\n@@ -4355,2 +4372,0 @@\n-\n-\n@@ -4373,1 +4388,0 @@\n-\n@@ -4411,1 +4425,0 @@\n-\n@@ -4491,0 +4504,37 @@\n+\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void compressLong128VectorTests(IntFunction<long[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.compress(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertcompressArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void expandLong128VectorTests(IntFunction<long[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.expand(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertexpandArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n@@ -4661,4 +4711,0 @@\n-\n-\n-\n-\n@@ -4679,3 +4725,0 @@\n-\n-\n-\n@@ -4707,0 +4750,1 @@\n+\n@@ -4736,0 +4780,1 @@\n+\n@@ -4769,0 +4814,1 @@\n+\n@@ -4796,0 +4842,1 @@\n+\n@@ -4835,0 +4882,1 @@\n+\n@@ -4892,22 +4940,0 @@\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n@@ -4917,0 +4943,1 @@\n+\n@@ -4921,1 +4948,0 @@\n-\n@@ -4940,0 +4966,1 @@\n+\n@@ -4957,1 +4984,0 @@\n-\n@@ -4980,3 +5006,0 @@\n-\n-\n-\n@@ -5012,0 +5035,1 @@\n+\n@@ -5042,1 +5066,0 @@\n-\n@@ -5081,3 +5104,0 @@\n-\n-\n-\n@@ -5098,0 +5118,1 @@\n+\n@@ -5113,1 +5134,0 @@\n-\n@@ -5132,1 +5152,0 @@\n-\n@@ -5245,1 +5264,0 @@\n-\n@@ -5254,2 +5272,0 @@\n-\n-\n@@ -5286,2 +5302,0 @@\n-\n-\n@@ -5306,2 +5320,0 @@\n-\n-\n@@ -5312,2 +5324,0 @@\n-\n-\n@@ -5329,2 +5339,0 @@\n-\n-\n@@ -5349,0 +5357,3 @@\n+    static long BIT_COUNT(long a) {\n+        return (long)(Long.bitCount(a));\n+    }\n@@ -5350,0 +5361,4 @@\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void BIT_COUNTLong128VectorTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n@@ -5351,0 +5366,9 @@\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Long128VectorTests::BIT_COUNT);\n+    }\n@@ -5352,0 +5376,165 @@\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void BIT_COUNTMaskedLong128VectorTests(IntFunction<long[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Long128VectorTests::BIT_COUNT);\n+    }\n+\n+    static long TRAILING_ZEROS_COUNT(long a) {\n+        return (long)(TRAILING_ZEROS_COUNT_scalar(a));\n+    }\n+\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void TRAILING_ZEROS_COUNTLong128VectorTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TRAILING_ZEROS_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Long128VectorTests::TRAILING_ZEROS_COUNT);\n+    }\n+\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void TRAILING_ZEROS_COUNTMaskedLong128VectorTests(IntFunction<long[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TRAILING_ZEROS_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Long128VectorTests::TRAILING_ZEROS_COUNT);\n+    }\n+\n+    static long LEADING_ZEROS_COUNT(long a) {\n+        return (long)(LEADING_ZEROS_COUNT_scalar(a));\n+    }\n+\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void LEADING_ZEROS_COUNTLong128VectorTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LEADING_ZEROS_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Long128VectorTests::LEADING_ZEROS_COUNT);\n+    }\n+\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void LEADING_ZEROS_COUNTMaskedLong128VectorTests(IntFunction<long[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LEADING_ZEROS_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Long128VectorTests::LEADING_ZEROS_COUNT);\n+    }\n+\n+    static long REVERSE(long a) {\n+        return (long)(REVERSE_scalar(a));\n+    }\n+\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void REVERSELong128VectorTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Long128VectorTests::REVERSE);\n+    }\n+\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void REVERSEMaskedLong128VectorTests(IntFunction<long[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Long128VectorTests::REVERSE);\n+    }\n+\n+    static long REVERSE_BYTES(long a) {\n+        return (long)(Long.reverseBytes(a));\n+    }\n+\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void REVERSE_BYTESLong128VectorTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Long128VectorTests::REVERSE_BYTES);\n+    }\n+\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void REVERSE_BYTESMaskedLong128VectorTests(IntFunction<long[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Long128VectorTests::REVERSE_BYTES);\n+    }\n@@ -5688,0 +5877,17 @@\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCompressLong128VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        int trueCount = 0;\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                trueCount = vmask.trueCount();\n+                var rmask = vmask.compress();\n+                for (int j = 0; j < SPECIES.length(); j++)  {\n+                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);\n+                }\n+            }\n+        }\n+    }\n+\n@@ -5730,0 +5936,14 @@\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeLongLong128VectorTestsSmokeTest(int offset) {\n+        long limit = SPECIES.length() * BUFFER_REPS;\n+        for (long i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i + offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                long index = i + j + offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n@@ -5750,0 +5970,8 @@\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundLongLong128VectorTestsSmokeTest(int _length) {\n+        long length = _length;\n+        long actualLoopBound = SPECIES.loopBound(length);\n+        long expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+    }\n+\n@@ -5812,1 +6040,0 @@\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long128VectorTests.java","additions":441,"deletions":214,"binary":false,"changes":655,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,3 @@\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.ValueLayout;\n@@ -42,2 +45,0 @@\n-import java.nio.ByteBuffer;\n-import java.nio.LongBuffer;\n@@ -45,1 +46,0 @@\n-import java.nio.ReadOnlyBufferException;\n@@ -70,11 +70,0 @@\n-    static void assertArraysEquals(byte[] r, byte[] a, boolean[] mask) {\n-        int i = 0;\n-        try {\n-            for (; i < a.length; i++) {\n-                Assert.assertEquals(r[i], mask[(i*8\/SPECIES.elementSize()) % SPECIES.length()] ? a[i] : (byte) 0);\n-            }\n-        } catch (AssertionError e) {\n-            Assert.assertEquals(r[i], mask[(i*8\/SPECIES.elementSize()) % SPECIES.length()] ? a[i] : (byte) 0, \"at index #\" + i);\n-        }\n-    }\n-\n@@ -120,1 +109,1 @@\n-    \/\/ Relative to byte[] array.length or ByteBuffer.limit()\n+    \/\/ Relative to byte[] array.length or MemorySegment.byteSize()\n@@ -191,1 +180,1 @@\n-    public Object[][] longByteBufferProvider() {\n+    public Object[][] longMemorySegmentProvider() {\n@@ -193,1 +182,1 @@\n-                flatMap(fa -> BYTE_BUFFER_GENERATORS.stream().\n+                flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n@@ -201,1 +190,1 @@\n-    public Object[][] longByteBufferMaskProvider() {\n+    public Object[][] longMemorySegmentMaskProvider() {\n@@ -204,1 +193,1 @@\n-                        flatMap(fa -> BYTE_BUFFER_GENERATORS.stream().\n+                        flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n@@ -211,19 +200,0 @@\n-    @DataProvider\n-    public Object[][] longByteArrayProvider() {\n-        return LONG_GENERATORS.stream().\n-                flatMap(fa -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                    return new Object[]{fa, bo};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] longByteArrayMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> LONG_GENERATORS.stream().\n-                    flatMap(fa -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                        return new Object[]{fa, fm, bo};\n-                    }))).\n-                toArray(Object[][]::new);\n-    }\n-\n@@ -249,4 +219,4 @@\n-    static ByteBuffer toBuffer(long[] a, IntFunction<ByteBuffer> fb) {\n-        ByteBuffer bb = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n-        for (long v : a) {\n-            bb.putLong(v);\n+    static MemorySegment toSegment(long[] a, IntFunction<MemorySegment> fb) {\n+        MemorySegment ms = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n+        for (int i = 0; i < a.length; i++) {\n+            ms.set(ValueLayout.JAVA_LONG, i * SPECIES.elementSize() \/ 8 , a[i]);\n@@ -254,1 +224,1 @@\n-        return bb.clear();\n+        return ms;\n@@ -257,14 +227,2 @@\n-    static long[] bufferToArray(ByteBuffer bb) {\n-        LongBuffer db = bb.asLongBuffer();\n-        long[] d = new long[db.capacity()];\n-        db.get(0, d);\n-        return d;\n-    }\n-\n-    static byte[] toByteArray(long[] a, IntFunction<byte[]> fb, ByteOrder bo) {\n-        byte[] b = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n-        LongBuffer bb = ByteBuffer.wrap(b, 0, b.length).order(bo).asLongBuffer();\n-        for (long v : a) {\n-            bb.put(v);\n-        }\n-        return b;\n+    static long[] segmentToArray(MemorySegment ms) {\n+        return ms.toArray(ValueLayout.JAVA_LONG);\n@@ -310,22 +268,2 @@\n-    static LongVector fromByteArray(byte[] a, int i, ByteOrder bo) {\n-        return LongVector.fromByteArray(SPECIES, a, i, bo);\n-    }\n-\n-    @DontInline\n-    static LongVector fromByteArray(byte[] a, int i, ByteOrder bo, VectorMask<Long> m) {\n-        return LongVector.fromByteArray(SPECIES, a, i, bo, m);\n-    }\n-\n-    @DontInline\n-    static void intoByteArray(LongVector v, byte[] a, int i, ByteOrder bo) {\n-        v.intoByteArray(a, i, bo);\n-    }\n-\n-    @DontInline\n-    static void intoByteArray(LongVector v, byte[] a, int i, ByteOrder bo, VectorMask<Long> m) {\n-        v.intoByteArray(a, i, bo, m);\n-    }\n-\n-    @DontInline\n-    static LongVector fromByteBuffer(ByteBuffer a, int i, ByteOrder bo) {\n-        return LongVector.fromByteBuffer(SPECIES, a, i, bo);\n+    static LongVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo) {\n+        return LongVector.fromMemorySegment(SPECIES, a, i, bo);\n@@ -335,2 +273,2 @@\n-    static LongVector fromByteBuffer(ByteBuffer a, int i, ByteOrder bo, VectorMask<Long> m) {\n-        return LongVector.fromByteBuffer(SPECIES, a, i, bo, m);\n+    static LongVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo, VectorMask<Long> m) {\n+        return LongVector.fromMemorySegment(SPECIES, a, i, bo, m);\n@@ -340,2 +278,2 @@\n-    static void intoByteBuffer(LongVector v, ByteBuffer a, int i, ByteOrder bo) {\n-        v.intoByteBuffer(a, i, bo);\n+    static void intoMemorySegment(LongVector v, MemorySegment a, int i, ByteOrder bo) {\n+        v.intoMemorySegment(a, i, bo);\n@@ -345,2 +283,2 @@\n-    static void intoByteBuffer(LongVector v, ByteBuffer a, int i, ByteOrder bo, VectorMask<Long> m) {\n-        v.intoByteBuffer(a, i, bo, m);\n+    static void intoMemorySegment(LongVector v, MemorySegment a, int i, ByteOrder bo, VectorMask<Long> m) {\n+        v.intoMemorySegment(a, i, bo, m);\n@@ -349,1 +287,0 @@\n-\n@@ -520,6 +457,6 @@\n-    @Test(dataProvider = \"longByteBufferProvider\")\n-    static void loadStoreByteBuffer(IntFunction<long[]> fa,\n-                                    IntFunction<ByteBuffer> fb,\n-                                    ByteOrder bo) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), fb);\n-        ByteBuffer r = fb.apply(a.limit());\n+    @Test(dataProvider = \"longMemorySegmentProvider\")\n+    static void loadStoreMemorySegment(IntFunction<long[]> fa,\n+                                       IntFunction<MemorySegment> fb,\n+                                       ByteOrder bo) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb);\n+        MemorySegment r = fb.apply((int) a.byteSize());\n@@ -527,1 +464,1 @@\n-        int l = a.limit();\n+        int l = (int) a.byteSize();\n@@ -532,2 +469,2 @@\n-                LongVector av = LongVector.fromByteBuffer(SPECIES, a, i, bo);\n-                av.intoByteBuffer(r, i, bo);\n+                LongVector av = LongVector.fromMemorySegment(SPECIES, a, i, bo);\n+                av.intoMemorySegment(r, i, bo);\n@@ -536,5 +473,2 @@\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        Assert.assertEquals(r, a, \"Buffers not equal\");\n+        long m = r.mismatch(a);\n+        Assert.assertEquals(m, -1, \"Segments not equal\");\n@@ -544,3 +478,3 @@\n-    static void loadByteBufferIOOBE(IntFunction<long[]> fa, IntFunction<Integer> fi) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n+    static void loadMemorySegmentIOOBE(IntFunction<long[]> fa, IntFunction<Integer> fi) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n@@ -548,1 +482,1 @@\n-        int l = a.limit();\n+        int l = (int) a.byteSize();\n@@ -553,2 +487,2 @@\n-                LongVector av = fromByteBuffer(a, i, ByteOrder.nativeOrder());\n-                av.intoByteBuffer(r, i, ByteOrder.nativeOrder());\n+                LongVector av = fromMemorySegment(a, i, ByteOrder.nativeOrder());\n+                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n@@ -558,2 +492,2 @@\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.limit());\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());\n@@ -561,1 +495,1 @@\n-            fromByteBuffer(a, index, ByteOrder.nativeOrder());\n+            fromMemorySegment(a, index, ByteOrder.nativeOrder());\n@@ -573,3 +507,3 @@\n-    static void storeByteBufferIOOBE(IntFunction<long[]> fa, IntFunction<Integer> fi) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n+    static void storeMemorySegmentIOOBE(IntFunction<long[]> fa, IntFunction<Integer> fi) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n@@ -577,1 +511,1 @@\n-        int l = a.limit();\n+        int l = (int) a.byteSize();\n@@ -582,2 +516,2 @@\n-                LongVector av = LongVector.fromByteBuffer(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteBuffer(av, r, i, ByteOrder.nativeOrder());\n+                LongVector av = LongVector.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+                intoMemorySegment(av, r, i, ByteOrder.nativeOrder());\n@@ -587,2 +521,2 @@\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.limit());\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());\n@@ -590,2 +524,2 @@\n-            LongVector av = LongVector.fromByteBuffer(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteBuffer(av, r, index, ByteOrder.nativeOrder());\n+            LongVector av = LongVector.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+            intoMemorySegment(av, r, index, ByteOrder.nativeOrder());\n@@ -602,6 +536,5 @@\n-\n-    @Test(dataProvider = \"longByteBufferMaskProvider\")\n-    static void loadStoreByteBufferMask(IntFunction<long[]> fa,\n-                                        IntFunction<ByteBuffer> fb,\n-                                        IntFunction<boolean[]> fm,\n-                                        ByteOrder bo) {\n+    @Test(dataProvider = \"longMemorySegmentMaskProvider\")\n+    static void loadStoreMemorySegmentMask(IntFunction<long[]> fa,\n+                                           IntFunction<MemorySegment> fb,\n+                                           IntFunction<boolean[]> fm,\n+                                           ByteOrder bo) {\n@@ -609,2 +542,2 @@\n-        ByteBuffer a = toBuffer(_a, fb);\n-        ByteBuffer r = fb.apply(a.limit());\n+        MemorySegment a = toSegment(_a, fb);\n+        MemorySegment r = fb.apply((int) a.byteSize());\n@@ -614,1 +547,1 @@\n-        int l = a.limit();\n+        int l = (int) a.byteSize();\n@@ -619,2 +552,2 @@\n-                LongVector av = LongVector.fromByteBuffer(SPECIES, a, i, bo, vmask);\n-                av.intoByteBuffer(r, i, bo);\n+                LongVector av = LongVector.fromMemorySegment(SPECIES, a, i, bo, vmask);\n+                av.intoMemorySegment(r, i, bo);\n@@ -623,5 +556,1 @@\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        assertArraysEquals(bufferToArray(r), _a, mask);\n+        assertArraysEquals(segmentToArray(r), _a, mask);\n@@ -630,1 +559,1 @@\n-        r = fb.apply(a.limit());\n+        r = fb.apply((int) a.byteSize());\n@@ -634,2 +563,2 @@\n-                LongVector av = LongVector.fromByteBuffer(SPECIES, a, i, bo);\n-                av.intoByteBuffer(r, i, bo, vmask);\n+                LongVector av = LongVector.fromMemorySegment(SPECIES, a, i, bo);\n+                av.intoMemorySegment(r, i, bo, vmask);\n@@ -638,5 +567,1 @@\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        assertArraysEquals(bufferToArray(r), _a, mask);\n+        assertArraysEquals(segmentToArray(r), _a, mask);\n@@ -646,3 +571,3 @@\n-    static void loadByteBufferMaskIOOBE(IntFunction<long[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n+    static void loadMemorySegmentMaskIOOBE(IntFunction<long[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n@@ -652,1 +577,1 @@\n-        int l = a.limit();\n+        int l = (int) a.byteSize();\n@@ -657,2 +582,2 @@\n-                LongVector av = fromByteBuffer(a, i, ByteOrder.nativeOrder(), vmask);\n-                av.intoByteBuffer(r, i, ByteOrder.nativeOrder());\n+                LongVector av = fromMemorySegment(a, i, ByteOrder.nativeOrder(), vmask);\n+                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n@@ -662,2 +587,2 @@\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.limit(), SPECIES.elementSize() \/ 8);\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() \/ 8);\n@@ -665,1 +590,1 @@\n-            fromByteBuffer(a, index, ByteOrder.nativeOrder(), vmask);\n+            fromMemorySegment(a, index, ByteOrder.nativeOrder(), vmask);\n@@ -677,3 +602,3 @@\n-    static void storeByteBufferMaskIOOBE(IntFunction<long[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n+    static void storeMemorySegmentMaskIOOBE(IntFunction<long[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n@@ -683,83 +608,1 @@\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                LongVector av = LongVector.fromByteBuffer(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteBuffer(av, r, i, ByteOrder.nativeOrder(), vmask);\n-            }\n-        }\n-\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.limit(), SPECIES.elementSize() \/ 8);\n-        try {\n-            LongVector av = LongVector.fromByteBuffer(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteBuffer(av, a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"longByteBufferProvider\")\n-    static void loadStoreReadonlyByteBuffer(IntFunction<long[]> fa,\n-                                    IntFunction<ByteBuffer> fb,\n-                                    ByteOrder bo) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), fb).asReadOnlyBuffer();\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo);\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, SPECIES.maskAll(true));\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, SPECIES.maskAll(false));\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            VectorMask<Long> m = SPECIES.shuffleFromOp(i -> i % 2 == 0 ? 1 : -1)\n-                    .laneIsValid();\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, m);\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"longByteArrayProvider\")\n-    static void loadStoreByteArray(IntFunction<long[]> fa,\n-                                    ByteOrder bo) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, bo);\n-        byte[] r = new byte[a.length];\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                LongVector av = LongVector.fromByteArray(SPECIES, a, i, bo);\n-                av.intoByteArray(r, i, bo);\n-            }\n-        }\n-        Assert.assertEquals(r, a, \"Byte arrays not equal\");\n-    }\n-\n-    @Test(dataProvider = \"longByteProviderForIOOBE\")\n-    static void loadByteArrayIOOBE(IntFunction<long[]> fa, IntFunction<Integer> fi) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-\n+        int l = (int) a.byteSize();\n@@ -767,1 +610,0 @@\n-        int l = a.length;\n@@ -771,2 +613,2 @@\n-                LongVector av = fromByteArray(a, i, ByteOrder.nativeOrder());\n-                av.intoByteArray(r, i, ByteOrder.nativeOrder());\n+                LongVector av = LongVector.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+                intoMemorySegment(av, r, i, ByteOrder.nativeOrder(), vmask);\n@@ -776,2 +618,2 @@\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.length);\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() \/ 8);\n@@ -779,1 +621,2 @@\n-            fromByteArray(a, index, ByteOrder.nativeOrder());\n+            LongVector av = LongVector.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+            intoMemorySegment(av, a, index, ByteOrder.nativeOrder(), vmask);\n@@ -790,62 +633,5 @@\n-    @Test(dataProvider = \"longByteProviderForIOOBE\")\n-    static void storeByteArrayIOOBE(IntFunction<long[]> fa, IntFunction<Integer> fi) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                LongVector av = LongVector.fromByteArray(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteArray(av, r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.length);\n-        try {\n-            LongVector av = LongVector.fromByteArray(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteArray(av, r, index, ByteOrder.nativeOrder());\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"longByteArrayMaskProvider\")\n-    static void loadStoreByteArrayMask(IntFunction<long[]> fa,\n-                                  IntFunction<boolean[]> fm,\n-                                  ByteOrder bo) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, bo);\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Long> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-          for (int i = 0; i < l; i += s) {\n-              LongVector av = LongVector.fromByteArray(SPECIES, a, i, bo, vmask);\n-              av.intoByteArray(r, i, bo);\n-          }\n-        }\n-        assertArraysEquals(r, a, mask);\n-\n-\n-        r = new byte[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                LongVector av = LongVector.fromByteArray(SPECIES, a, i, bo);\n-                av.intoByteArray(r, i, bo, vmask);\n-            }\n-        }\n-        assertArraysEquals(r, a, mask);\n-    }\n+    @Test(dataProvider = \"longMemorySegmentProvider\")\n+    static void loadStoreReadonlyMemorySegment(IntFunction<long[]> fa,\n+                                               IntFunction<MemorySegment> fb,\n+                                               ByteOrder bo) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb).asReadOnly();\n@@ -853,6 +639,4 @@\n-    @Test(dataProvider = \"longByteMaskProviderForIOOBE\")\n-    static void loadByteArrayMaskIOOBE(IntFunction<long[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Long> vmask = VectorMask.fromValues(SPECIES, mask);\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo)\n+        );\n@@ -860,2 +644,4 @@\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(true))\n+        );\n@@ -863,6 +649,4 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                LongVector av = fromByteArray(a, i, ByteOrder.nativeOrder(), vmask);\n-                av.intoByteArray(r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(false))\n+        );\n@@ -870,12 +654,6 @@\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length, SPECIES.elementSize() \/ 8);\n-        try {\n-            fromByteArray(a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n+        VectorMask<Long> m = SPECIES.shuffleFromOp(i -> i % 2 == 0 ? 1 : -1)\n+                .laneIsValid();\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, m)\n+        );\n@@ -884,31 +662,0 @@\n-    @Test(dataProvider = \"longByteMaskProviderForIOOBE\")\n-    static void storeByteArrayMaskIOOBE(IntFunction<long[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Long> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                LongVector av = LongVector.fromByteArray(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteArray(av, r, i, ByteOrder.nativeOrder(), vmask);\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length, SPECIES.elementSize() \/ 8);\n-        try {\n-            LongVector av = LongVector.fromByteArray(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteArray(av, a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n@@ -930,0 +677,1 @@\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long256VectorLoadStoreTests.java","additions":112,"deletions":364,"binary":false,"changes":476,"status":"modified"},{"patch":"@@ -221,0 +221,49 @@\n+    static void assertcompressArraysEquals(long[] r, long[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    Assert.assertEquals(r[i + k], (long)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (long)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals(long[] r, long[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        Assert.assertEquals(r[i + j], (long)0);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (long)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n@@ -877,1 +926,0 @@\n-\n@@ -979,1 +1027,0 @@\n-\n@@ -1055,1 +1102,0 @@\n-\n@@ -1167,1 +1213,0 @@\n-\n@@ -1192,0 +1237,12 @@\n+    static long TRAILING_ZEROS_COUNT_scalar(long a) {\n+        return Long.numberOfTrailingZeros(a);\n+    }\n+\n+    static long LEADING_ZEROS_COUNT_scalar(long a) {\n+        return Long.numberOfLeadingZeros(a);\n+    }\n+\n+    static long REVERSE_scalar(long a) {\n+        return Long.reverse(a);\n+    }\n+\n@@ -1346,0 +1403,1 @@\n+\n@@ -1366,0 +1424,1 @@\n+\n@@ -1422,0 +1481,1 @@\n+\n@@ -1442,0 +1502,1 @@\n+\n@@ -1498,0 +1559,1 @@\n+\n@@ -1518,0 +1580,1 @@\n+\n@@ -1575,2 +1638,0 @@\n-\n-\n@@ -1599,0 +1660,1 @@\n+\n@@ -1622,2 +1684,0 @@\n-\n-\n@@ -1729,0 +1789,1 @@\n+\n@@ -1748,2 +1809,0 @@\n-\n-\n@@ -1770,1 +1829,0 @@\n-\n@@ -1792,2 +1850,0 @@\n-\n-\n@@ -1814,1 +1870,0 @@\n-\n@@ -1835,0 +1890,1 @@\n+\n@@ -1854,2 +1910,0 @@\n-\n-\n@@ -1876,1 +1930,0 @@\n-\n@@ -1898,2 +1951,0 @@\n-\n-\n@@ -1920,0 +1971,81 @@\n+    static long COMPRESS_BITS(long a, long b) {\n+        return (long)(Long.compress(a, b));\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpProvider\")\n+    static void COMPRESS_BITSLong256VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.COMPRESS_BITS, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Long256VectorTests::COMPRESS_BITS);\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpMaskProvider\")\n+    static void COMPRESS_BITSLong256VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.COMPRESS_BITS, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Long256VectorTests::COMPRESS_BITS);\n+    }\n+\n+    static long EXPAND_BITS(long a, long b) {\n+        return (long)(Long.expand(a, b));\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpProvider\")\n+    static void EXPAND_BITSLong256VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.EXPAND_BITS, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Long256VectorTests::EXPAND_BITS);\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpMaskProvider\")\n+    static void EXPAND_BITSLong256VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.EXPAND_BITS, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Long256VectorTests::EXPAND_BITS);\n+    }\n@@ -2014,3 +2146,0 @@\n-\n-\n-\n@@ -2033,2 +2162,0 @@\n-\n-\n@@ -2054,2 +2181,0 @@\n-\n-\n@@ -2084,2 +2209,0 @@\n-\n-\n@@ -2103,2 +2226,0 @@\n-\n-\n@@ -2133,2 +2254,0 @@\n-\n-\n@@ -2152,2 +2271,0 @@\n-\n-\n@@ -2168,2 +2285,0 @@\n-\n-\n@@ -2187,1 +2302,0 @@\n-\n@@ -2240,2 +2354,0 @@\n-\n-\n@@ -2262,5 +2374,0 @@\n-\n-\n-\n-\n-\n@@ -2288,2 +2395,0 @@\n-\n-\n@@ -2310,5 +2415,0 @@\n-\n-\n-\n-\n-\n@@ -2336,2 +2436,0 @@\n-\n-\n@@ -2358,5 +2456,0 @@\n-\n-\n-\n-\n-\n@@ -2383,2 +2476,0 @@\n-\n-\n@@ -2404,5 +2495,0 @@\n-\n-\n-\n-\n-\n@@ -2429,2 +2515,0 @@\n-\n-\n@@ -2450,5 +2534,0 @@\n-\n-\n-\n-\n-\n@@ -2475,2 +2554,0 @@\n-\n-\n@@ -2496,5 +2573,0 @@\n-\n-\n-\n-\n-\n@@ -2522,2 +2594,0 @@\n-\n-\n@@ -2544,1 +2614,0 @@\n-\n@@ -2566,2 +2635,0 @@\n-\n-\n@@ -2588,1 +2655,0 @@\n-\n@@ -2609,2 +2675,0 @@\n-\n-\n@@ -2630,1 +2694,0 @@\n-\n@@ -2651,2 +2714,0 @@\n-\n-\n@@ -2671,2 +2732,0 @@\n-\n-\n@@ -2692,2 +2751,0 @@\n-\n-\n@@ -2712,6 +2769,0 @@\n-\n-\n-\n-\n-\n-\n@@ -2737,2 +2788,0 @@\n-\n-\n@@ -2757,2 +2806,0 @@\n-\n-\n@@ -2778,2 +2825,0 @@\n-\n-\n@@ -2798,2 +2843,0 @@\n-\n-\n@@ -2819,2 +2862,0 @@\n-\n-\n@@ -2839,2 +2880,0 @@\n-\n-\n@@ -2860,2 +2899,0 @@\n-\n-\n@@ -2901,0 +2938,1 @@\n+\n@@ -2919,0 +2957,1 @@\n+\n@@ -2939,0 +2978,1 @@\n+\n@@ -3032,1 +3072,0 @@\n-\n@@ -3058,1 +3097,0 @@\n-\n@@ -3078,1 +3116,0 @@\n-\n@@ -3106,1 +3143,0 @@\n-\n@@ -3125,1 +3161,0 @@\n-\n@@ -3151,1 +3186,0 @@\n-\n@@ -3171,1 +3205,0 @@\n-\n@@ -3199,1 +3232,0 @@\n-\n@@ -3218,1 +3250,0 @@\n-\n@@ -3244,1 +3275,0 @@\n-\n@@ -3264,1 +3294,0 @@\n-\n@@ -3309,0 +3338,1 @@\n+\n@@ -3333,0 +3363,1 @@\n+\n@@ -3351,0 +3382,1 @@\n+\n@@ -3377,0 +3409,1 @@\n+\n@@ -3394,0 +3427,1 @@\n+\n@@ -3418,0 +3452,1 @@\n+\n@@ -3436,0 +3471,1 @@\n+\n@@ -3462,0 +3498,1 @@\n+\n@@ -3479,0 +3516,1 @@\n+\n@@ -3503,0 +3541,1 @@\n+\n@@ -3521,0 +3560,1 @@\n+\n@@ -3547,0 +3587,1 @@\n+\n@@ -3564,0 +3605,1 @@\n+\n@@ -3588,0 +3630,1 @@\n+\n@@ -3606,0 +3649,1 @@\n+\n@@ -3632,0 +3676,1 @@\n+\n@@ -3649,0 +3694,1 @@\n+\n@@ -3673,0 +3719,1 @@\n+\n@@ -3691,0 +3738,1 @@\n+\n@@ -3727,1 +3775,0 @@\n-\n@@ -3743,1 +3790,0 @@\n-\n@@ -3753,1 +3799,0 @@\n-\n@@ -3769,1 +3814,0 @@\n-\n@@ -3787,0 +3831,1 @@\n+\n@@ -3827,0 +3872,1 @@\n+\n@@ -3868,3 +3914,0 @@\n-\n-\n-\n@@ -3890,1 +3933,0 @@\n-\n@@ -3933,1 +3975,0 @@\n-\n@@ -3976,1 +4017,0 @@\n-\n@@ -3996,1 +4036,0 @@\n-\n@@ -4039,1 +4078,0 @@\n-\n@@ -4082,1 +4120,0 @@\n-\n@@ -4125,1 +4162,0 @@\n-\n@@ -4168,2 +4204,0 @@\n-\n-\n@@ -4189,2 +4223,0 @@\n-\n-\n@@ -4214,3 +4246,0 @@\n-\n-\n-\n@@ -4236,2 +4265,0 @@\n-\n-\n@@ -4261,3 +4288,0 @@\n-\n-\n-\n@@ -4283,2 +4307,0 @@\n-\n-\n@@ -4308,3 +4330,0 @@\n-\n-\n-\n@@ -4330,2 +4349,0 @@\n-\n-\n@@ -4355,2 +4372,0 @@\n-\n-\n@@ -4373,1 +4388,0 @@\n-\n@@ -4411,1 +4425,0 @@\n-\n@@ -4491,0 +4504,37 @@\n+\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void compressLong256VectorTests(IntFunction<long[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.compress(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertcompressArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void expandLong256VectorTests(IntFunction<long[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.expand(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertexpandArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n@@ -4661,4 +4711,0 @@\n-\n-\n-\n-\n@@ -4679,3 +4725,0 @@\n-\n-\n-\n@@ -4707,0 +4750,1 @@\n+\n@@ -4736,0 +4780,1 @@\n+\n@@ -4769,0 +4814,1 @@\n+\n@@ -4796,0 +4842,1 @@\n+\n@@ -4835,0 +4882,1 @@\n+\n@@ -4892,22 +4940,0 @@\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n@@ -4917,0 +4943,1 @@\n+\n@@ -4921,1 +4948,0 @@\n-\n@@ -4940,0 +4966,1 @@\n+\n@@ -4957,1 +4984,0 @@\n-\n@@ -4980,3 +5006,0 @@\n-\n-\n-\n@@ -5012,0 +5035,1 @@\n+\n@@ -5042,1 +5066,0 @@\n-\n@@ -5081,3 +5104,0 @@\n-\n-\n-\n@@ -5098,0 +5118,1 @@\n+\n@@ -5113,1 +5134,0 @@\n-\n@@ -5132,1 +5152,0 @@\n-\n@@ -5245,1 +5264,0 @@\n-\n@@ -5254,2 +5272,0 @@\n-\n-\n@@ -5286,2 +5302,0 @@\n-\n-\n@@ -5306,2 +5320,0 @@\n-\n-\n@@ -5312,2 +5324,0 @@\n-\n-\n@@ -5329,2 +5339,0 @@\n-\n-\n@@ -5349,0 +5357,3 @@\n+    static long BIT_COUNT(long a) {\n+        return (long)(Long.bitCount(a));\n+    }\n@@ -5350,0 +5361,4 @@\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void BIT_COUNTLong256VectorTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n@@ -5351,0 +5366,9 @@\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Long256VectorTests::BIT_COUNT);\n+    }\n@@ -5352,0 +5376,165 @@\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void BIT_COUNTMaskedLong256VectorTests(IntFunction<long[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Long256VectorTests::BIT_COUNT);\n+    }\n+\n+    static long TRAILING_ZEROS_COUNT(long a) {\n+        return (long)(TRAILING_ZEROS_COUNT_scalar(a));\n+    }\n+\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void TRAILING_ZEROS_COUNTLong256VectorTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TRAILING_ZEROS_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Long256VectorTests::TRAILING_ZEROS_COUNT);\n+    }\n+\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void TRAILING_ZEROS_COUNTMaskedLong256VectorTests(IntFunction<long[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TRAILING_ZEROS_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Long256VectorTests::TRAILING_ZEROS_COUNT);\n+    }\n+\n+    static long LEADING_ZEROS_COUNT(long a) {\n+        return (long)(LEADING_ZEROS_COUNT_scalar(a));\n+    }\n+\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void LEADING_ZEROS_COUNTLong256VectorTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LEADING_ZEROS_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Long256VectorTests::LEADING_ZEROS_COUNT);\n+    }\n+\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void LEADING_ZEROS_COUNTMaskedLong256VectorTests(IntFunction<long[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LEADING_ZEROS_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Long256VectorTests::LEADING_ZEROS_COUNT);\n+    }\n+\n+    static long REVERSE(long a) {\n+        return (long)(REVERSE_scalar(a));\n+    }\n+\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void REVERSELong256VectorTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Long256VectorTests::REVERSE);\n+    }\n+\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void REVERSEMaskedLong256VectorTests(IntFunction<long[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Long256VectorTests::REVERSE);\n+    }\n+\n+    static long REVERSE_BYTES(long a) {\n+        return (long)(Long.reverseBytes(a));\n+    }\n+\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void REVERSE_BYTESLong256VectorTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Long256VectorTests::REVERSE_BYTES);\n+    }\n+\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void REVERSE_BYTESMaskedLong256VectorTests(IntFunction<long[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Long256VectorTests::REVERSE_BYTES);\n+    }\n@@ -5688,0 +5877,17 @@\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCompressLong256VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        int trueCount = 0;\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                trueCount = vmask.trueCount();\n+                var rmask = vmask.compress();\n+                for (int j = 0; j < SPECIES.length(); j++)  {\n+                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);\n+                }\n+            }\n+        }\n+    }\n+\n@@ -5730,0 +5936,14 @@\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeLongLong256VectorTestsSmokeTest(int offset) {\n+        long limit = SPECIES.length() * BUFFER_REPS;\n+        for (long i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i + offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                long index = i + j + offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n@@ -5750,0 +5970,8 @@\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundLongLong256VectorTestsSmokeTest(int _length) {\n+        long length = _length;\n+        long actualLoopBound = SPECIES.loopBound(length);\n+        long expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+    }\n+\n@@ -5812,1 +6040,0 @@\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long256VectorTests.java","additions":441,"deletions":214,"binary":false,"changes":655,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,3 @@\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.ValueLayout;\n@@ -42,2 +45,0 @@\n-import java.nio.ByteBuffer;\n-import java.nio.LongBuffer;\n@@ -45,1 +46,0 @@\n-import java.nio.ReadOnlyBufferException;\n@@ -70,11 +70,0 @@\n-    static void assertArraysEquals(byte[] r, byte[] a, boolean[] mask) {\n-        int i = 0;\n-        try {\n-            for (; i < a.length; i++) {\n-                Assert.assertEquals(r[i], mask[(i*8\/SPECIES.elementSize()) % SPECIES.length()] ? a[i] : (byte) 0);\n-            }\n-        } catch (AssertionError e) {\n-            Assert.assertEquals(r[i], mask[(i*8\/SPECIES.elementSize()) % SPECIES.length()] ? a[i] : (byte) 0, \"at index #\" + i);\n-        }\n-    }\n-\n@@ -120,1 +109,1 @@\n-    \/\/ Relative to byte[] array.length or ByteBuffer.limit()\n+    \/\/ Relative to byte[] array.length or MemorySegment.byteSize()\n@@ -191,1 +180,1 @@\n-    public Object[][] longByteBufferProvider() {\n+    public Object[][] longMemorySegmentProvider() {\n@@ -193,1 +182,1 @@\n-                flatMap(fa -> BYTE_BUFFER_GENERATORS.stream().\n+                flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n@@ -201,1 +190,1 @@\n-    public Object[][] longByteBufferMaskProvider() {\n+    public Object[][] longMemorySegmentMaskProvider() {\n@@ -204,1 +193,1 @@\n-                        flatMap(fa -> BYTE_BUFFER_GENERATORS.stream().\n+                        flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n@@ -211,19 +200,0 @@\n-    @DataProvider\n-    public Object[][] longByteArrayProvider() {\n-        return LONG_GENERATORS.stream().\n-                flatMap(fa -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                    return new Object[]{fa, bo};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] longByteArrayMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> LONG_GENERATORS.stream().\n-                    flatMap(fa -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                        return new Object[]{fa, fm, bo};\n-                    }))).\n-                toArray(Object[][]::new);\n-    }\n-\n@@ -249,4 +219,4 @@\n-    static ByteBuffer toBuffer(long[] a, IntFunction<ByteBuffer> fb) {\n-        ByteBuffer bb = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n-        for (long v : a) {\n-            bb.putLong(v);\n+    static MemorySegment toSegment(long[] a, IntFunction<MemorySegment> fb) {\n+        MemorySegment ms = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n+        for (int i = 0; i < a.length; i++) {\n+            ms.set(ValueLayout.JAVA_LONG, i * SPECIES.elementSize() \/ 8 , a[i]);\n@@ -254,1 +224,1 @@\n-        return bb.clear();\n+        return ms;\n@@ -257,14 +227,2 @@\n-    static long[] bufferToArray(ByteBuffer bb) {\n-        LongBuffer db = bb.asLongBuffer();\n-        long[] d = new long[db.capacity()];\n-        db.get(0, d);\n-        return d;\n-    }\n-\n-    static byte[] toByteArray(long[] a, IntFunction<byte[]> fb, ByteOrder bo) {\n-        byte[] b = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n-        LongBuffer bb = ByteBuffer.wrap(b, 0, b.length).order(bo).asLongBuffer();\n-        for (long v : a) {\n-            bb.put(v);\n-        }\n-        return b;\n+    static long[] segmentToArray(MemorySegment ms) {\n+        return ms.toArray(ValueLayout.JAVA_LONG);\n@@ -310,22 +268,2 @@\n-    static LongVector fromByteArray(byte[] a, int i, ByteOrder bo) {\n-        return LongVector.fromByteArray(SPECIES, a, i, bo);\n-    }\n-\n-    @DontInline\n-    static LongVector fromByteArray(byte[] a, int i, ByteOrder bo, VectorMask<Long> m) {\n-        return LongVector.fromByteArray(SPECIES, a, i, bo, m);\n-    }\n-\n-    @DontInline\n-    static void intoByteArray(LongVector v, byte[] a, int i, ByteOrder bo) {\n-        v.intoByteArray(a, i, bo);\n-    }\n-\n-    @DontInline\n-    static void intoByteArray(LongVector v, byte[] a, int i, ByteOrder bo, VectorMask<Long> m) {\n-        v.intoByteArray(a, i, bo, m);\n-    }\n-\n-    @DontInline\n-    static LongVector fromByteBuffer(ByteBuffer a, int i, ByteOrder bo) {\n-        return LongVector.fromByteBuffer(SPECIES, a, i, bo);\n+    static LongVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo) {\n+        return LongVector.fromMemorySegment(SPECIES, a, i, bo);\n@@ -335,2 +273,2 @@\n-    static LongVector fromByteBuffer(ByteBuffer a, int i, ByteOrder bo, VectorMask<Long> m) {\n-        return LongVector.fromByteBuffer(SPECIES, a, i, bo, m);\n+    static LongVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo, VectorMask<Long> m) {\n+        return LongVector.fromMemorySegment(SPECIES, a, i, bo, m);\n@@ -340,2 +278,2 @@\n-    static void intoByteBuffer(LongVector v, ByteBuffer a, int i, ByteOrder bo) {\n-        v.intoByteBuffer(a, i, bo);\n+    static void intoMemorySegment(LongVector v, MemorySegment a, int i, ByteOrder bo) {\n+        v.intoMemorySegment(a, i, bo);\n@@ -345,2 +283,2 @@\n-    static void intoByteBuffer(LongVector v, ByteBuffer a, int i, ByteOrder bo, VectorMask<Long> m) {\n-        v.intoByteBuffer(a, i, bo, m);\n+    static void intoMemorySegment(LongVector v, MemorySegment a, int i, ByteOrder bo, VectorMask<Long> m) {\n+        v.intoMemorySegment(a, i, bo, m);\n@@ -349,1 +287,0 @@\n-\n@@ -520,6 +457,6 @@\n-    @Test(dataProvider = \"longByteBufferProvider\")\n-    static void loadStoreByteBuffer(IntFunction<long[]> fa,\n-                                    IntFunction<ByteBuffer> fb,\n-                                    ByteOrder bo) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), fb);\n-        ByteBuffer r = fb.apply(a.limit());\n+    @Test(dataProvider = \"longMemorySegmentProvider\")\n+    static void loadStoreMemorySegment(IntFunction<long[]> fa,\n+                                       IntFunction<MemorySegment> fb,\n+                                       ByteOrder bo) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb);\n+        MemorySegment r = fb.apply((int) a.byteSize());\n@@ -527,1 +464,1 @@\n-        int l = a.limit();\n+        int l = (int) a.byteSize();\n@@ -532,2 +469,2 @@\n-                LongVector av = LongVector.fromByteBuffer(SPECIES, a, i, bo);\n-                av.intoByteBuffer(r, i, bo);\n+                LongVector av = LongVector.fromMemorySegment(SPECIES, a, i, bo);\n+                av.intoMemorySegment(r, i, bo);\n@@ -536,5 +473,2 @@\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        Assert.assertEquals(r, a, \"Buffers not equal\");\n+        long m = r.mismatch(a);\n+        Assert.assertEquals(m, -1, \"Segments not equal\");\n@@ -544,3 +478,3 @@\n-    static void loadByteBufferIOOBE(IntFunction<long[]> fa, IntFunction<Integer> fi) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n+    static void loadMemorySegmentIOOBE(IntFunction<long[]> fa, IntFunction<Integer> fi) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n@@ -548,1 +482,1 @@\n-        int l = a.limit();\n+        int l = (int) a.byteSize();\n@@ -553,2 +487,2 @@\n-                LongVector av = fromByteBuffer(a, i, ByteOrder.nativeOrder());\n-                av.intoByteBuffer(r, i, ByteOrder.nativeOrder());\n+                LongVector av = fromMemorySegment(a, i, ByteOrder.nativeOrder());\n+                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n@@ -558,2 +492,2 @@\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.limit());\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());\n@@ -561,1 +495,1 @@\n-            fromByteBuffer(a, index, ByteOrder.nativeOrder());\n+            fromMemorySegment(a, index, ByteOrder.nativeOrder());\n@@ -573,3 +507,3 @@\n-    static void storeByteBufferIOOBE(IntFunction<long[]> fa, IntFunction<Integer> fi) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n+    static void storeMemorySegmentIOOBE(IntFunction<long[]> fa, IntFunction<Integer> fi) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n@@ -577,1 +511,1 @@\n-        int l = a.limit();\n+        int l = (int) a.byteSize();\n@@ -582,2 +516,2 @@\n-                LongVector av = LongVector.fromByteBuffer(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteBuffer(av, r, i, ByteOrder.nativeOrder());\n+                LongVector av = LongVector.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+                intoMemorySegment(av, r, i, ByteOrder.nativeOrder());\n@@ -587,2 +521,2 @@\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.limit());\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());\n@@ -590,2 +524,2 @@\n-            LongVector av = LongVector.fromByteBuffer(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteBuffer(av, r, index, ByteOrder.nativeOrder());\n+            LongVector av = LongVector.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+            intoMemorySegment(av, r, index, ByteOrder.nativeOrder());\n@@ -602,6 +536,5 @@\n-\n-    @Test(dataProvider = \"longByteBufferMaskProvider\")\n-    static void loadStoreByteBufferMask(IntFunction<long[]> fa,\n-                                        IntFunction<ByteBuffer> fb,\n-                                        IntFunction<boolean[]> fm,\n-                                        ByteOrder bo) {\n+    @Test(dataProvider = \"longMemorySegmentMaskProvider\")\n+    static void loadStoreMemorySegmentMask(IntFunction<long[]> fa,\n+                                           IntFunction<MemorySegment> fb,\n+                                           IntFunction<boolean[]> fm,\n+                                           ByteOrder bo) {\n@@ -609,2 +542,2 @@\n-        ByteBuffer a = toBuffer(_a, fb);\n-        ByteBuffer r = fb.apply(a.limit());\n+        MemorySegment a = toSegment(_a, fb);\n+        MemorySegment r = fb.apply((int) a.byteSize());\n@@ -614,1 +547,1 @@\n-        int l = a.limit();\n+        int l = (int) a.byteSize();\n@@ -619,2 +552,2 @@\n-                LongVector av = LongVector.fromByteBuffer(SPECIES, a, i, bo, vmask);\n-                av.intoByteBuffer(r, i, bo);\n+                LongVector av = LongVector.fromMemorySegment(SPECIES, a, i, bo, vmask);\n+                av.intoMemorySegment(r, i, bo);\n@@ -623,5 +556,1 @@\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        assertArraysEquals(bufferToArray(r), _a, mask);\n+        assertArraysEquals(segmentToArray(r), _a, mask);\n@@ -630,1 +559,1 @@\n-        r = fb.apply(a.limit());\n+        r = fb.apply((int) a.byteSize());\n@@ -634,2 +563,2 @@\n-                LongVector av = LongVector.fromByteBuffer(SPECIES, a, i, bo);\n-                av.intoByteBuffer(r, i, bo, vmask);\n+                LongVector av = LongVector.fromMemorySegment(SPECIES, a, i, bo);\n+                av.intoMemorySegment(r, i, bo, vmask);\n@@ -638,5 +567,1 @@\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        assertArraysEquals(bufferToArray(r), _a, mask);\n+        assertArraysEquals(segmentToArray(r), _a, mask);\n@@ -646,3 +571,3 @@\n-    static void loadByteBufferMaskIOOBE(IntFunction<long[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n+    static void loadMemorySegmentMaskIOOBE(IntFunction<long[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n@@ -652,1 +577,1 @@\n-        int l = a.limit();\n+        int l = (int) a.byteSize();\n@@ -657,2 +582,2 @@\n-                LongVector av = fromByteBuffer(a, i, ByteOrder.nativeOrder(), vmask);\n-                av.intoByteBuffer(r, i, ByteOrder.nativeOrder());\n+                LongVector av = fromMemorySegment(a, i, ByteOrder.nativeOrder(), vmask);\n+                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n@@ -662,2 +587,2 @@\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.limit(), SPECIES.elementSize() \/ 8);\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() \/ 8);\n@@ -665,1 +590,1 @@\n-            fromByteBuffer(a, index, ByteOrder.nativeOrder(), vmask);\n+            fromMemorySegment(a, index, ByteOrder.nativeOrder(), vmask);\n@@ -677,3 +602,3 @@\n-    static void storeByteBufferMaskIOOBE(IntFunction<long[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n+    static void storeMemorySegmentMaskIOOBE(IntFunction<long[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n@@ -683,83 +608,1 @@\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                LongVector av = LongVector.fromByteBuffer(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteBuffer(av, r, i, ByteOrder.nativeOrder(), vmask);\n-            }\n-        }\n-\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.limit(), SPECIES.elementSize() \/ 8);\n-        try {\n-            LongVector av = LongVector.fromByteBuffer(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteBuffer(av, a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"longByteBufferProvider\")\n-    static void loadStoreReadonlyByteBuffer(IntFunction<long[]> fa,\n-                                    IntFunction<ByteBuffer> fb,\n-                                    ByteOrder bo) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), fb).asReadOnlyBuffer();\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo);\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, SPECIES.maskAll(true));\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, SPECIES.maskAll(false));\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            VectorMask<Long> m = SPECIES.shuffleFromOp(i -> i % 2 == 0 ? 1 : -1)\n-                    .laneIsValid();\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, m);\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"longByteArrayProvider\")\n-    static void loadStoreByteArray(IntFunction<long[]> fa,\n-                                    ByteOrder bo) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, bo);\n-        byte[] r = new byte[a.length];\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                LongVector av = LongVector.fromByteArray(SPECIES, a, i, bo);\n-                av.intoByteArray(r, i, bo);\n-            }\n-        }\n-        Assert.assertEquals(r, a, \"Byte arrays not equal\");\n-    }\n-\n-    @Test(dataProvider = \"longByteProviderForIOOBE\")\n-    static void loadByteArrayIOOBE(IntFunction<long[]> fa, IntFunction<Integer> fi) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-\n+        int l = (int) a.byteSize();\n@@ -767,1 +610,0 @@\n-        int l = a.length;\n@@ -771,2 +613,2 @@\n-                LongVector av = fromByteArray(a, i, ByteOrder.nativeOrder());\n-                av.intoByteArray(r, i, ByteOrder.nativeOrder());\n+                LongVector av = LongVector.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+                intoMemorySegment(av, r, i, ByteOrder.nativeOrder(), vmask);\n@@ -776,2 +618,2 @@\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.length);\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() \/ 8);\n@@ -779,1 +621,2 @@\n-            fromByteArray(a, index, ByteOrder.nativeOrder());\n+            LongVector av = LongVector.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+            intoMemorySegment(av, a, index, ByteOrder.nativeOrder(), vmask);\n@@ -790,62 +633,5 @@\n-    @Test(dataProvider = \"longByteProviderForIOOBE\")\n-    static void storeByteArrayIOOBE(IntFunction<long[]> fa, IntFunction<Integer> fi) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                LongVector av = LongVector.fromByteArray(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteArray(av, r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.length);\n-        try {\n-            LongVector av = LongVector.fromByteArray(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteArray(av, r, index, ByteOrder.nativeOrder());\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"longByteArrayMaskProvider\")\n-    static void loadStoreByteArrayMask(IntFunction<long[]> fa,\n-                                  IntFunction<boolean[]> fm,\n-                                  ByteOrder bo) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, bo);\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Long> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-          for (int i = 0; i < l; i += s) {\n-              LongVector av = LongVector.fromByteArray(SPECIES, a, i, bo, vmask);\n-              av.intoByteArray(r, i, bo);\n-          }\n-        }\n-        assertArraysEquals(r, a, mask);\n-\n-\n-        r = new byte[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                LongVector av = LongVector.fromByteArray(SPECIES, a, i, bo);\n-                av.intoByteArray(r, i, bo, vmask);\n-            }\n-        }\n-        assertArraysEquals(r, a, mask);\n-    }\n+    @Test(dataProvider = \"longMemorySegmentProvider\")\n+    static void loadStoreReadonlyMemorySegment(IntFunction<long[]> fa,\n+                                               IntFunction<MemorySegment> fb,\n+                                               ByteOrder bo) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb).asReadOnly();\n@@ -853,6 +639,4 @@\n-    @Test(dataProvider = \"longByteMaskProviderForIOOBE\")\n-    static void loadByteArrayMaskIOOBE(IntFunction<long[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Long> vmask = VectorMask.fromValues(SPECIES, mask);\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo)\n+        );\n@@ -860,2 +644,4 @@\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(true))\n+        );\n@@ -863,6 +649,4 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                LongVector av = fromByteArray(a, i, ByteOrder.nativeOrder(), vmask);\n-                av.intoByteArray(r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(false))\n+        );\n@@ -870,12 +654,6 @@\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length, SPECIES.elementSize() \/ 8);\n-        try {\n-            fromByteArray(a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n+        VectorMask<Long> m = SPECIES.shuffleFromOp(i -> i % 2 == 0 ? 1 : -1)\n+                .laneIsValid();\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, m)\n+        );\n@@ -884,31 +662,0 @@\n-    @Test(dataProvider = \"longByteMaskProviderForIOOBE\")\n-    static void storeByteArrayMaskIOOBE(IntFunction<long[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Long> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                LongVector av = LongVector.fromByteArray(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteArray(av, r, i, ByteOrder.nativeOrder(), vmask);\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length, SPECIES.elementSize() \/ 8);\n-        try {\n-            LongVector av = LongVector.fromByteArray(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteArray(av, a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n@@ -930,0 +677,1 @@\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long512VectorLoadStoreTests.java","additions":112,"deletions":364,"binary":false,"changes":476,"status":"modified"},{"patch":"@@ -221,0 +221,49 @@\n+    static void assertcompressArraysEquals(long[] r, long[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    Assert.assertEquals(r[i + k], (long)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (long)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals(long[] r, long[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        Assert.assertEquals(r[i + j], (long)0);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (long)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n@@ -877,1 +926,0 @@\n-\n@@ -979,1 +1027,0 @@\n-\n@@ -1055,1 +1102,0 @@\n-\n@@ -1167,1 +1213,0 @@\n-\n@@ -1192,0 +1237,12 @@\n+    static long TRAILING_ZEROS_COUNT_scalar(long a) {\n+        return Long.numberOfTrailingZeros(a);\n+    }\n+\n+    static long LEADING_ZEROS_COUNT_scalar(long a) {\n+        return Long.numberOfLeadingZeros(a);\n+    }\n+\n+    static long REVERSE_scalar(long a) {\n+        return Long.reverse(a);\n+    }\n+\n@@ -1346,0 +1403,1 @@\n+\n@@ -1366,0 +1424,1 @@\n+\n@@ -1422,0 +1481,1 @@\n+\n@@ -1442,0 +1502,1 @@\n+\n@@ -1498,0 +1559,1 @@\n+\n@@ -1518,0 +1580,1 @@\n+\n@@ -1575,2 +1638,0 @@\n-\n-\n@@ -1599,0 +1660,1 @@\n+\n@@ -1622,2 +1684,0 @@\n-\n-\n@@ -1729,0 +1789,1 @@\n+\n@@ -1748,2 +1809,0 @@\n-\n-\n@@ -1770,1 +1829,0 @@\n-\n@@ -1792,2 +1850,0 @@\n-\n-\n@@ -1814,1 +1870,0 @@\n-\n@@ -1835,0 +1890,1 @@\n+\n@@ -1854,2 +1910,0 @@\n-\n-\n@@ -1876,1 +1930,0 @@\n-\n@@ -1898,2 +1951,0 @@\n-\n-\n@@ -1920,0 +1971,81 @@\n+    static long COMPRESS_BITS(long a, long b) {\n+        return (long)(Long.compress(a, b));\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpProvider\")\n+    static void COMPRESS_BITSLong512VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.COMPRESS_BITS, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Long512VectorTests::COMPRESS_BITS);\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpMaskProvider\")\n+    static void COMPRESS_BITSLong512VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.COMPRESS_BITS, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Long512VectorTests::COMPRESS_BITS);\n+    }\n+\n+    static long EXPAND_BITS(long a, long b) {\n+        return (long)(Long.expand(a, b));\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpProvider\")\n+    static void EXPAND_BITSLong512VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.EXPAND_BITS, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Long512VectorTests::EXPAND_BITS);\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpMaskProvider\")\n+    static void EXPAND_BITSLong512VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.EXPAND_BITS, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Long512VectorTests::EXPAND_BITS);\n+    }\n@@ -2014,3 +2146,0 @@\n-\n-\n-\n@@ -2033,2 +2162,0 @@\n-\n-\n@@ -2054,2 +2181,0 @@\n-\n-\n@@ -2084,2 +2209,0 @@\n-\n-\n@@ -2103,2 +2226,0 @@\n-\n-\n@@ -2133,2 +2254,0 @@\n-\n-\n@@ -2152,2 +2271,0 @@\n-\n-\n@@ -2168,2 +2285,0 @@\n-\n-\n@@ -2187,1 +2302,0 @@\n-\n@@ -2240,2 +2354,0 @@\n-\n-\n@@ -2262,5 +2374,0 @@\n-\n-\n-\n-\n-\n@@ -2288,2 +2395,0 @@\n-\n-\n@@ -2310,5 +2415,0 @@\n-\n-\n-\n-\n-\n@@ -2336,2 +2436,0 @@\n-\n-\n@@ -2358,5 +2456,0 @@\n-\n-\n-\n-\n-\n@@ -2383,2 +2476,0 @@\n-\n-\n@@ -2404,5 +2495,0 @@\n-\n-\n-\n-\n-\n@@ -2429,2 +2515,0 @@\n-\n-\n@@ -2450,5 +2534,0 @@\n-\n-\n-\n-\n-\n@@ -2475,2 +2554,0 @@\n-\n-\n@@ -2496,5 +2573,0 @@\n-\n-\n-\n-\n-\n@@ -2522,2 +2594,0 @@\n-\n-\n@@ -2544,1 +2614,0 @@\n-\n@@ -2566,2 +2635,0 @@\n-\n-\n@@ -2588,1 +2655,0 @@\n-\n@@ -2609,2 +2675,0 @@\n-\n-\n@@ -2630,1 +2694,0 @@\n-\n@@ -2651,2 +2714,0 @@\n-\n-\n@@ -2671,2 +2732,0 @@\n-\n-\n@@ -2692,2 +2751,0 @@\n-\n-\n@@ -2712,6 +2769,0 @@\n-\n-\n-\n-\n-\n-\n@@ -2737,2 +2788,0 @@\n-\n-\n@@ -2757,2 +2806,0 @@\n-\n-\n@@ -2778,2 +2825,0 @@\n-\n-\n@@ -2798,2 +2843,0 @@\n-\n-\n@@ -2819,2 +2862,0 @@\n-\n-\n@@ -2839,2 +2880,0 @@\n-\n-\n@@ -2860,2 +2899,0 @@\n-\n-\n@@ -2901,0 +2938,1 @@\n+\n@@ -2919,0 +2957,1 @@\n+\n@@ -2939,0 +2978,1 @@\n+\n@@ -3032,1 +3072,0 @@\n-\n@@ -3058,1 +3097,0 @@\n-\n@@ -3078,1 +3116,0 @@\n-\n@@ -3106,1 +3143,0 @@\n-\n@@ -3125,1 +3161,0 @@\n-\n@@ -3151,1 +3186,0 @@\n-\n@@ -3171,1 +3205,0 @@\n-\n@@ -3199,1 +3232,0 @@\n-\n@@ -3218,1 +3250,0 @@\n-\n@@ -3244,1 +3275,0 @@\n-\n@@ -3264,1 +3294,0 @@\n-\n@@ -3309,0 +3338,1 @@\n+\n@@ -3333,0 +3363,1 @@\n+\n@@ -3351,0 +3382,1 @@\n+\n@@ -3377,0 +3409,1 @@\n+\n@@ -3394,0 +3427,1 @@\n+\n@@ -3418,0 +3452,1 @@\n+\n@@ -3436,0 +3471,1 @@\n+\n@@ -3462,0 +3498,1 @@\n+\n@@ -3479,0 +3516,1 @@\n+\n@@ -3503,0 +3541,1 @@\n+\n@@ -3521,0 +3560,1 @@\n+\n@@ -3547,0 +3587,1 @@\n+\n@@ -3564,0 +3605,1 @@\n+\n@@ -3588,0 +3630,1 @@\n+\n@@ -3606,0 +3649,1 @@\n+\n@@ -3632,0 +3676,1 @@\n+\n@@ -3649,0 +3694,1 @@\n+\n@@ -3673,0 +3719,1 @@\n+\n@@ -3691,0 +3738,1 @@\n+\n@@ -3727,1 +3775,0 @@\n-\n@@ -3743,1 +3790,0 @@\n-\n@@ -3753,1 +3799,0 @@\n-\n@@ -3769,1 +3814,0 @@\n-\n@@ -3787,0 +3831,1 @@\n+\n@@ -3827,0 +3872,1 @@\n+\n@@ -3868,3 +3914,0 @@\n-\n-\n-\n@@ -3890,1 +3933,0 @@\n-\n@@ -3933,1 +3975,0 @@\n-\n@@ -3976,1 +4017,0 @@\n-\n@@ -3996,1 +4036,0 @@\n-\n@@ -4039,1 +4078,0 @@\n-\n@@ -4082,1 +4120,0 @@\n-\n@@ -4125,1 +4162,0 @@\n-\n@@ -4168,2 +4204,0 @@\n-\n-\n@@ -4189,2 +4223,0 @@\n-\n-\n@@ -4214,3 +4246,0 @@\n-\n-\n-\n@@ -4236,2 +4265,0 @@\n-\n-\n@@ -4261,3 +4288,0 @@\n-\n-\n-\n@@ -4283,2 +4307,0 @@\n-\n-\n@@ -4308,3 +4330,0 @@\n-\n-\n-\n@@ -4330,2 +4349,0 @@\n-\n-\n@@ -4355,2 +4372,0 @@\n-\n-\n@@ -4373,1 +4388,0 @@\n-\n@@ -4411,1 +4425,0 @@\n-\n@@ -4491,0 +4504,37 @@\n+\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void compressLong512VectorTests(IntFunction<long[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.compress(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertcompressArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void expandLong512VectorTests(IntFunction<long[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.expand(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertexpandArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n@@ -4661,4 +4711,0 @@\n-\n-\n-\n-\n@@ -4679,3 +4725,0 @@\n-\n-\n-\n@@ -4707,0 +4750,1 @@\n+\n@@ -4736,0 +4780,1 @@\n+\n@@ -4769,0 +4814,1 @@\n+\n@@ -4796,0 +4842,1 @@\n+\n@@ -4835,0 +4882,1 @@\n+\n@@ -4892,22 +4940,0 @@\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n@@ -4917,0 +4943,1 @@\n+\n@@ -4921,1 +4948,0 @@\n-\n@@ -4940,0 +4966,1 @@\n+\n@@ -4957,1 +4984,0 @@\n-\n@@ -4980,3 +5006,0 @@\n-\n-\n-\n@@ -5012,0 +5035,1 @@\n+\n@@ -5042,1 +5066,0 @@\n-\n@@ -5081,3 +5104,0 @@\n-\n-\n-\n@@ -5098,0 +5118,1 @@\n+\n@@ -5113,1 +5134,0 @@\n-\n@@ -5132,1 +5152,0 @@\n-\n@@ -5245,1 +5264,0 @@\n-\n@@ -5254,2 +5272,0 @@\n-\n-\n@@ -5286,2 +5302,0 @@\n-\n-\n@@ -5306,2 +5320,0 @@\n-\n-\n@@ -5312,2 +5324,0 @@\n-\n-\n@@ -5329,2 +5339,0 @@\n-\n-\n@@ -5349,0 +5357,3 @@\n+    static long BIT_COUNT(long a) {\n+        return (long)(Long.bitCount(a));\n+    }\n@@ -5350,0 +5361,4 @@\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void BIT_COUNTLong512VectorTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n@@ -5351,0 +5366,9 @@\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Long512VectorTests::BIT_COUNT);\n+    }\n@@ -5352,0 +5376,165 @@\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void BIT_COUNTMaskedLong512VectorTests(IntFunction<long[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Long512VectorTests::BIT_COUNT);\n+    }\n+\n+    static long TRAILING_ZEROS_COUNT(long a) {\n+        return (long)(TRAILING_ZEROS_COUNT_scalar(a));\n+    }\n+\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void TRAILING_ZEROS_COUNTLong512VectorTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TRAILING_ZEROS_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Long512VectorTests::TRAILING_ZEROS_COUNT);\n+    }\n+\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void TRAILING_ZEROS_COUNTMaskedLong512VectorTests(IntFunction<long[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TRAILING_ZEROS_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Long512VectorTests::TRAILING_ZEROS_COUNT);\n+    }\n+\n+    static long LEADING_ZEROS_COUNT(long a) {\n+        return (long)(LEADING_ZEROS_COUNT_scalar(a));\n+    }\n+\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void LEADING_ZEROS_COUNTLong512VectorTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LEADING_ZEROS_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Long512VectorTests::LEADING_ZEROS_COUNT);\n+    }\n+\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void LEADING_ZEROS_COUNTMaskedLong512VectorTests(IntFunction<long[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LEADING_ZEROS_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Long512VectorTests::LEADING_ZEROS_COUNT);\n+    }\n+\n+    static long REVERSE(long a) {\n+        return (long)(REVERSE_scalar(a));\n+    }\n+\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void REVERSELong512VectorTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Long512VectorTests::REVERSE);\n+    }\n+\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void REVERSEMaskedLong512VectorTests(IntFunction<long[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Long512VectorTests::REVERSE);\n+    }\n+\n+    static long REVERSE_BYTES(long a) {\n+        return (long)(Long.reverseBytes(a));\n+    }\n+\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void REVERSE_BYTESLong512VectorTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Long512VectorTests::REVERSE_BYTES);\n+    }\n+\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void REVERSE_BYTESMaskedLong512VectorTests(IntFunction<long[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Long512VectorTests::REVERSE_BYTES);\n+    }\n@@ -5688,0 +5877,17 @@\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCompressLong512VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        int trueCount = 0;\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                trueCount = vmask.trueCount();\n+                var rmask = vmask.compress();\n+                for (int j = 0; j < SPECIES.length(); j++)  {\n+                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);\n+                }\n+            }\n+        }\n+    }\n+\n@@ -5730,0 +5936,14 @@\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeLongLong512VectorTestsSmokeTest(int offset) {\n+        long limit = SPECIES.length() * BUFFER_REPS;\n+        for (long i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i + offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                long index = i + j + offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n@@ -5750,0 +5970,8 @@\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundLongLong512VectorTestsSmokeTest(int _length) {\n+        long length = _length;\n+        long actualLoopBound = SPECIES.loopBound(length);\n+        long expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+    }\n+\n@@ -5812,1 +6040,0 @@\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long512VectorTests.java","additions":441,"deletions":214,"binary":false,"changes":655,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,3 @@\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.ValueLayout;\n@@ -42,2 +45,0 @@\n-import java.nio.ByteBuffer;\n-import java.nio.LongBuffer;\n@@ -45,1 +46,0 @@\n-import java.nio.ReadOnlyBufferException;\n@@ -70,11 +70,0 @@\n-    static void assertArraysEquals(byte[] r, byte[] a, boolean[] mask) {\n-        int i = 0;\n-        try {\n-            for (; i < a.length; i++) {\n-                Assert.assertEquals(r[i], mask[(i*8\/SPECIES.elementSize()) % SPECIES.length()] ? a[i] : (byte) 0);\n-            }\n-        } catch (AssertionError e) {\n-            Assert.assertEquals(r[i], mask[(i*8\/SPECIES.elementSize()) % SPECIES.length()] ? a[i] : (byte) 0, \"at index #\" + i);\n-        }\n-    }\n-\n@@ -120,1 +109,1 @@\n-    \/\/ Relative to byte[] array.length or ByteBuffer.limit()\n+    \/\/ Relative to byte[] array.length or MemorySegment.byteSize()\n@@ -191,1 +180,1 @@\n-    public Object[][] longByteBufferProvider() {\n+    public Object[][] longMemorySegmentProvider() {\n@@ -193,1 +182,1 @@\n-                flatMap(fa -> BYTE_BUFFER_GENERATORS.stream().\n+                flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n@@ -201,1 +190,1 @@\n-    public Object[][] longByteBufferMaskProvider() {\n+    public Object[][] longMemorySegmentMaskProvider() {\n@@ -204,1 +193,1 @@\n-                        flatMap(fa -> BYTE_BUFFER_GENERATORS.stream().\n+                        flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n@@ -211,19 +200,0 @@\n-    @DataProvider\n-    public Object[][] longByteArrayProvider() {\n-        return LONG_GENERATORS.stream().\n-                flatMap(fa -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                    return new Object[]{fa, bo};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] longByteArrayMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> LONG_GENERATORS.stream().\n-                    flatMap(fa -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                        return new Object[]{fa, fm, bo};\n-                    }))).\n-                toArray(Object[][]::new);\n-    }\n-\n@@ -249,4 +219,4 @@\n-    static ByteBuffer toBuffer(long[] a, IntFunction<ByteBuffer> fb) {\n-        ByteBuffer bb = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n-        for (long v : a) {\n-            bb.putLong(v);\n+    static MemorySegment toSegment(long[] a, IntFunction<MemorySegment> fb) {\n+        MemorySegment ms = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n+        for (int i = 0; i < a.length; i++) {\n+            ms.set(ValueLayout.JAVA_LONG, i * SPECIES.elementSize() \/ 8 , a[i]);\n@@ -254,1 +224,1 @@\n-        return bb.clear();\n+        return ms;\n@@ -257,14 +227,2 @@\n-    static long[] bufferToArray(ByteBuffer bb) {\n-        LongBuffer db = bb.asLongBuffer();\n-        long[] d = new long[db.capacity()];\n-        db.get(0, d);\n-        return d;\n-    }\n-\n-    static byte[] toByteArray(long[] a, IntFunction<byte[]> fb, ByteOrder bo) {\n-        byte[] b = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n-        LongBuffer bb = ByteBuffer.wrap(b, 0, b.length).order(bo).asLongBuffer();\n-        for (long v : a) {\n-            bb.put(v);\n-        }\n-        return b;\n+    static long[] segmentToArray(MemorySegment ms) {\n+        return ms.toArray(ValueLayout.JAVA_LONG);\n@@ -310,22 +268,2 @@\n-    static LongVector fromByteArray(byte[] a, int i, ByteOrder bo) {\n-        return LongVector.fromByteArray(SPECIES, a, i, bo);\n-    }\n-\n-    @DontInline\n-    static LongVector fromByteArray(byte[] a, int i, ByteOrder bo, VectorMask<Long> m) {\n-        return LongVector.fromByteArray(SPECIES, a, i, bo, m);\n-    }\n-\n-    @DontInline\n-    static void intoByteArray(LongVector v, byte[] a, int i, ByteOrder bo) {\n-        v.intoByteArray(a, i, bo);\n-    }\n-\n-    @DontInline\n-    static void intoByteArray(LongVector v, byte[] a, int i, ByteOrder bo, VectorMask<Long> m) {\n-        v.intoByteArray(a, i, bo, m);\n-    }\n-\n-    @DontInline\n-    static LongVector fromByteBuffer(ByteBuffer a, int i, ByteOrder bo) {\n-        return LongVector.fromByteBuffer(SPECIES, a, i, bo);\n+    static LongVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo) {\n+        return LongVector.fromMemorySegment(SPECIES, a, i, bo);\n@@ -335,2 +273,2 @@\n-    static LongVector fromByteBuffer(ByteBuffer a, int i, ByteOrder bo, VectorMask<Long> m) {\n-        return LongVector.fromByteBuffer(SPECIES, a, i, bo, m);\n+    static LongVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo, VectorMask<Long> m) {\n+        return LongVector.fromMemorySegment(SPECIES, a, i, bo, m);\n@@ -340,2 +278,2 @@\n-    static void intoByteBuffer(LongVector v, ByteBuffer a, int i, ByteOrder bo) {\n-        v.intoByteBuffer(a, i, bo);\n+    static void intoMemorySegment(LongVector v, MemorySegment a, int i, ByteOrder bo) {\n+        v.intoMemorySegment(a, i, bo);\n@@ -345,2 +283,2 @@\n-    static void intoByteBuffer(LongVector v, ByteBuffer a, int i, ByteOrder bo, VectorMask<Long> m) {\n-        v.intoByteBuffer(a, i, bo, m);\n+    static void intoMemorySegment(LongVector v, MemorySegment a, int i, ByteOrder bo, VectorMask<Long> m) {\n+        v.intoMemorySegment(a, i, bo, m);\n@@ -349,1 +287,0 @@\n-\n@@ -520,6 +457,6 @@\n-    @Test(dataProvider = \"longByteBufferProvider\")\n-    static void loadStoreByteBuffer(IntFunction<long[]> fa,\n-                                    IntFunction<ByteBuffer> fb,\n-                                    ByteOrder bo) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), fb);\n-        ByteBuffer r = fb.apply(a.limit());\n+    @Test(dataProvider = \"longMemorySegmentProvider\")\n+    static void loadStoreMemorySegment(IntFunction<long[]> fa,\n+                                       IntFunction<MemorySegment> fb,\n+                                       ByteOrder bo) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb);\n+        MemorySegment r = fb.apply((int) a.byteSize());\n@@ -527,1 +464,1 @@\n-        int l = a.limit();\n+        int l = (int) a.byteSize();\n@@ -532,2 +469,2 @@\n-                LongVector av = LongVector.fromByteBuffer(SPECIES, a, i, bo);\n-                av.intoByteBuffer(r, i, bo);\n+                LongVector av = LongVector.fromMemorySegment(SPECIES, a, i, bo);\n+                av.intoMemorySegment(r, i, bo);\n@@ -536,5 +473,2 @@\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        Assert.assertEquals(r, a, \"Buffers not equal\");\n+        long m = r.mismatch(a);\n+        Assert.assertEquals(m, -1, \"Segments not equal\");\n@@ -544,3 +478,3 @@\n-    static void loadByteBufferIOOBE(IntFunction<long[]> fa, IntFunction<Integer> fi) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n+    static void loadMemorySegmentIOOBE(IntFunction<long[]> fa, IntFunction<Integer> fi) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n@@ -548,1 +482,1 @@\n-        int l = a.limit();\n+        int l = (int) a.byteSize();\n@@ -553,2 +487,2 @@\n-                LongVector av = fromByteBuffer(a, i, ByteOrder.nativeOrder());\n-                av.intoByteBuffer(r, i, ByteOrder.nativeOrder());\n+                LongVector av = fromMemorySegment(a, i, ByteOrder.nativeOrder());\n+                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n@@ -558,2 +492,2 @@\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.limit());\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());\n@@ -561,1 +495,1 @@\n-            fromByteBuffer(a, index, ByteOrder.nativeOrder());\n+            fromMemorySegment(a, index, ByteOrder.nativeOrder());\n@@ -573,3 +507,3 @@\n-    static void storeByteBufferIOOBE(IntFunction<long[]> fa, IntFunction<Integer> fi) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n+    static void storeMemorySegmentIOOBE(IntFunction<long[]> fa, IntFunction<Integer> fi) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n@@ -577,1 +511,1 @@\n-        int l = a.limit();\n+        int l = (int) a.byteSize();\n@@ -582,2 +516,2 @@\n-                LongVector av = LongVector.fromByteBuffer(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteBuffer(av, r, i, ByteOrder.nativeOrder());\n+                LongVector av = LongVector.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+                intoMemorySegment(av, r, i, ByteOrder.nativeOrder());\n@@ -587,2 +521,2 @@\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.limit());\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());\n@@ -590,2 +524,2 @@\n-            LongVector av = LongVector.fromByteBuffer(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteBuffer(av, r, index, ByteOrder.nativeOrder());\n+            LongVector av = LongVector.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+            intoMemorySegment(av, r, index, ByteOrder.nativeOrder());\n@@ -602,6 +536,5 @@\n-\n-    @Test(dataProvider = \"longByteBufferMaskProvider\")\n-    static void loadStoreByteBufferMask(IntFunction<long[]> fa,\n-                                        IntFunction<ByteBuffer> fb,\n-                                        IntFunction<boolean[]> fm,\n-                                        ByteOrder bo) {\n+    @Test(dataProvider = \"longMemorySegmentMaskProvider\")\n+    static void loadStoreMemorySegmentMask(IntFunction<long[]> fa,\n+                                           IntFunction<MemorySegment> fb,\n+                                           IntFunction<boolean[]> fm,\n+                                           ByteOrder bo) {\n@@ -609,2 +542,2 @@\n-        ByteBuffer a = toBuffer(_a, fb);\n-        ByteBuffer r = fb.apply(a.limit());\n+        MemorySegment a = toSegment(_a, fb);\n+        MemorySegment r = fb.apply((int) a.byteSize());\n@@ -614,1 +547,1 @@\n-        int l = a.limit();\n+        int l = (int) a.byteSize();\n@@ -619,2 +552,2 @@\n-                LongVector av = LongVector.fromByteBuffer(SPECIES, a, i, bo, vmask);\n-                av.intoByteBuffer(r, i, bo);\n+                LongVector av = LongVector.fromMemorySegment(SPECIES, a, i, bo, vmask);\n+                av.intoMemorySegment(r, i, bo);\n@@ -623,5 +556,1 @@\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        assertArraysEquals(bufferToArray(r), _a, mask);\n+        assertArraysEquals(segmentToArray(r), _a, mask);\n@@ -630,1 +559,1 @@\n-        r = fb.apply(a.limit());\n+        r = fb.apply((int) a.byteSize());\n@@ -634,2 +563,2 @@\n-                LongVector av = LongVector.fromByteBuffer(SPECIES, a, i, bo);\n-                av.intoByteBuffer(r, i, bo, vmask);\n+                LongVector av = LongVector.fromMemorySegment(SPECIES, a, i, bo);\n+                av.intoMemorySegment(r, i, bo, vmask);\n@@ -638,5 +567,1 @@\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        assertArraysEquals(bufferToArray(r), _a, mask);\n+        assertArraysEquals(segmentToArray(r), _a, mask);\n@@ -646,3 +571,3 @@\n-    static void loadByteBufferMaskIOOBE(IntFunction<long[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n+    static void loadMemorySegmentMaskIOOBE(IntFunction<long[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n@@ -652,1 +577,1 @@\n-        int l = a.limit();\n+        int l = (int) a.byteSize();\n@@ -657,2 +582,2 @@\n-                LongVector av = fromByteBuffer(a, i, ByteOrder.nativeOrder(), vmask);\n-                av.intoByteBuffer(r, i, ByteOrder.nativeOrder());\n+                LongVector av = fromMemorySegment(a, i, ByteOrder.nativeOrder(), vmask);\n+                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n@@ -662,2 +587,2 @@\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.limit(), SPECIES.elementSize() \/ 8);\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() \/ 8);\n@@ -665,1 +590,1 @@\n-            fromByteBuffer(a, index, ByteOrder.nativeOrder(), vmask);\n+            fromMemorySegment(a, index, ByteOrder.nativeOrder(), vmask);\n@@ -677,3 +602,3 @@\n-    static void storeByteBufferMaskIOOBE(IntFunction<long[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n+    static void storeMemorySegmentMaskIOOBE(IntFunction<long[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n@@ -683,83 +608,1 @@\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                LongVector av = LongVector.fromByteBuffer(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteBuffer(av, r, i, ByteOrder.nativeOrder(), vmask);\n-            }\n-        }\n-\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.limit(), SPECIES.elementSize() \/ 8);\n-        try {\n-            LongVector av = LongVector.fromByteBuffer(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteBuffer(av, a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"longByteBufferProvider\")\n-    static void loadStoreReadonlyByteBuffer(IntFunction<long[]> fa,\n-                                    IntFunction<ByteBuffer> fb,\n-                                    ByteOrder bo) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), fb).asReadOnlyBuffer();\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo);\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, SPECIES.maskAll(true));\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, SPECIES.maskAll(false));\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            VectorMask<Long> m = SPECIES.shuffleFromOp(i -> i % 2 == 0 ? 1 : -1)\n-                    .laneIsValid();\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, m);\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"longByteArrayProvider\")\n-    static void loadStoreByteArray(IntFunction<long[]> fa,\n-                                    ByteOrder bo) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, bo);\n-        byte[] r = new byte[a.length];\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                LongVector av = LongVector.fromByteArray(SPECIES, a, i, bo);\n-                av.intoByteArray(r, i, bo);\n-            }\n-        }\n-        Assert.assertEquals(r, a, \"Byte arrays not equal\");\n-    }\n-\n-    @Test(dataProvider = \"longByteProviderForIOOBE\")\n-    static void loadByteArrayIOOBE(IntFunction<long[]> fa, IntFunction<Integer> fi) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-\n+        int l = (int) a.byteSize();\n@@ -767,1 +610,0 @@\n-        int l = a.length;\n@@ -771,2 +613,2 @@\n-                LongVector av = fromByteArray(a, i, ByteOrder.nativeOrder());\n-                av.intoByteArray(r, i, ByteOrder.nativeOrder());\n+                LongVector av = LongVector.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+                intoMemorySegment(av, r, i, ByteOrder.nativeOrder(), vmask);\n@@ -776,2 +618,2 @@\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.length);\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() \/ 8);\n@@ -779,1 +621,2 @@\n-            fromByteArray(a, index, ByteOrder.nativeOrder());\n+            LongVector av = LongVector.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+            intoMemorySegment(av, a, index, ByteOrder.nativeOrder(), vmask);\n@@ -790,62 +633,5 @@\n-    @Test(dataProvider = \"longByteProviderForIOOBE\")\n-    static void storeByteArrayIOOBE(IntFunction<long[]> fa, IntFunction<Integer> fi) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                LongVector av = LongVector.fromByteArray(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteArray(av, r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.length);\n-        try {\n-            LongVector av = LongVector.fromByteArray(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteArray(av, r, index, ByteOrder.nativeOrder());\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"longByteArrayMaskProvider\")\n-    static void loadStoreByteArrayMask(IntFunction<long[]> fa,\n-                                  IntFunction<boolean[]> fm,\n-                                  ByteOrder bo) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, bo);\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Long> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-          for (int i = 0; i < l; i += s) {\n-              LongVector av = LongVector.fromByteArray(SPECIES, a, i, bo, vmask);\n-              av.intoByteArray(r, i, bo);\n-          }\n-        }\n-        assertArraysEquals(r, a, mask);\n-\n-\n-        r = new byte[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                LongVector av = LongVector.fromByteArray(SPECIES, a, i, bo);\n-                av.intoByteArray(r, i, bo, vmask);\n-            }\n-        }\n-        assertArraysEquals(r, a, mask);\n-    }\n+    @Test(dataProvider = \"longMemorySegmentProvider\")\n+    static void loadStoreReadonlyMemorySegment(IntFunction<long[]> fa,\n+                                               IntFunction<MemorySegment> fb,\n+                                               ByteOrder bo) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb).asReadOnly();\n@@ -853,6 +639,4 @@\n-    @Test(dataProvider = \"longByteMaskProviderForIOOBE\")\n-    static void loadByteArrayMaskIOOBE(IntFunction<long[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Long> vmask = VectorMask.fromValues(SPECIES, mask);\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo)\n+        );\n@@ -860,2 +644,4 @@\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(true))\n+        );\n@@ -863,6 +649,4 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                LongVector av = fromByteArray(a, i, ByteOrder.nativeOrder(), vmask);\n-                av.intoByteArray(r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(false))\n+        );\n@@ -870,12 +654,6 @@\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length, SPECIES.elementSize() \/ 8);\n-        try {\n-            fromByteArray(a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n+        VectorMask<Long> m = SPECIES.shuffleFromOp(i -> i % 2 == 0 ? 1 : -1)\n+                .laneIsValid();\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, m)\n+        );\n@@ -884,31 +662,0 @@\n-    @Test(dataProvider = \"longByteMaskProviderForIOOBE\")\n-    static void storeByteArrayMaskIOOBE(IntFunction<long[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Long> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                LongVector av = LongVector.fromByteArray(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteArray(av, r, i, ByteOrder.nativeOrder(), vmask);\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length, SPECIES.elementSize() \/ 8);\n-        try {\n-            LongVector av = LongVector.fromByteArray(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteArray(av, a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n@@ -930,0 +677,1 @@\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long64VectorLoadStoreTests.java","additions":112,"deletions":364,"binary":false,"changes":476,"status":"modified"},{"patch":"@@ -221,0 +221,49 @@\n+    static void assertcompressArraysEquals(long[] r, long[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    Assert.assertEquals(r[i + k], (long)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (long)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals(long[] r, long[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        Assert.assertEquals(r[i + j], (long)0);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (long)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n@@ -877,1 +926,0 @@\n-\n@@ -979,1 +1027,0 @@\n-\n@@ -1055,1 +1102,0 @@\n-\n@@ -1167,1 +1213,0 @@\n-\n@@ -1192,0 +1237,12 @@\n+    static long TRAILING_ZEROS_COUNT_scalar(long a) {\n+        return Long.numberOfTrailingZeros(a);\n+    }\n+\n+    static long LEADING_ZEROS_COUNT_scalar(long a) {\n+        return Long.numberOfLeadingZeros(a);\n+    }\n+\n+    static long REVERSE_scalar(long a) {\n+        return Long.reverse(a);\n+    }\n+\n@@ -1346,0 +1403,1 @@\n+\n@@ -1366,0 +1424,1 @@\n+\n@@ -1422,0 +1481,1 @@\n+\n@@ -1442,0 +1502,1 @@\n+\n@@ -1498,0 +1559,1 @@\n+\n@@ -1518,0 +1580,1 @@\n+\n@@ -1575,2 +1638,0 @@\n-\n-\n@@ -1599,0 +1660,1 @@\n+\n@@ -1622,2 +1684,0 @@\n-\n-\n@@ -1729,0 +1789,1 @@\n+\n@@ -1748,2 +1809,0 @@\n-\n-\n@@ -1770,1 +1829,0 @@\n-\n@@ -1792,2 +1850,0 @@\n-\n-\n@@ -1814,1 +1870,0 @@\n-\n@@ -1835,0 +1890,1 @@\n+\n@@ -1854,2 +1910,0 @@\n-\n-\n@@ -1876,1 +1930,0 @@\n-\n@@ -1898,2 +1951,0 @@\n-\n-\n@@ -1920,0 +1971,81 @@\n+    static long COMPRESS_BITS(long a, long b) {\n+        return (long)(Long.compress(a, b));\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpProvider\")\n+    static void COMPRESS_BITSLong64VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.COMPRESS_BITS, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Long64VectorTests::COMPRESS_BITS);\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpMaskProvider\")\n+    static void COMPRESS_BITSLong64VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.COMPRESS_BITS, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Long64VectorTests::COMPRESS_BITS);\n+    }\n+\n+    static long EXPAND_BITS(long a, long b) {\n+        return (long)(Long.expand(a, b));\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpProvider\")\n+    static void EXPAND_BITSLong64VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.EXPAND_BITS, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, Long64VectorTests::EXPAND_BITS);\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpMaskProvider\")\n+    static void EXPAND_BITSLong64VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.EXPAND_BITS, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, Long64VectorTests::EXPAND_BITS);\n+    }\n@@ -2014,3 +2146,0 @@\n-\n-\n-\n@@ -2033,2 +2162,0 @@\n-\n-\n@@ -2054,2 +2181,0 @@\n-\n-\n@@ -2084,2 +2209,0 @@\n-\n-\n@@ -2103,2 +2226,0 @@\n-\n-\n@@ -2133,2 +2254,0 @@\n-\n-\n@@ -2152,2 +2271,0 @@\n-\n-\n@@ -2168,2 +2285,0 @@\n-\n-\n@@ -2187,1 +2302,0 @@\n-\n@@ -2240,2 +2354,0 @@\n-\n-\n@@ -2262,5 +2374,0 @@\n-\n-\n-\n-\n-\n@@ -2288,2 +2395,0 @@\n-\n-\n@@ -2310,5 +2415,0 @@\n-\n-\n-\n-\n-\n@@ -2336,2 +2436,0 @@\n-\n-\n@@ -2358,5 +2456,0 @@\n-\n-\n-\n-\n-\n@@ -2383,2 +2476,0 @@\n-\n-\n@@ -2404,5 +2495,0 @@\n-\n-\n-\n-\n-\n@@ -2429,2 +2515,0 @@\n-\n-\n@@ -2450,5 +2534,0 @@\n-\n-\n-\n-\n-\n@@ -2475,2 +2554,0 @@\n-\n-\n@@ -2496,5 +2573,0 @@\n-\n-\n-\n-\n-\n@@ -2522,2 +2594,0 @@\n-\n-\n@@ -2544,1 +2614,0 @@\n-\n@@ -2566,2 +2635,0 @@\n-\n-\n@@ -2588,1 +2655,0 @@\n-\n@@ -2609,2 +2675,0 @@\n-\n-\n@@ -2630,1 +2694,0 @@\n-\n@@ -2651,2 +2714,0 @@\n-\n-\n@@ -2671,2 +2732,0 @@\n-\n-\n@@ -2692,2 +2751,0 @@\n-\n-\n@@ -2712,6 +2769,0 @@\n-\n-\n-\n-\n-\n-\n@@ -2737,2 +2788,0 @@\n-\n-\n@@ -2757,2 +2806,0 @@\n-\n-\n@@ -2778,2 +2825,0 @@\n-\n-\n@@ -2798,2 +2843,0 @@\n-\n-\n@@ -2819,2 +2862,0 @@\n-\n-\n@@ -2839,2 +2880,0 @@\n-\n-\n@@ -2860,2 +2899,0 @@\n-\n-\n@@ -2901,0 +2938,1 @@\n+\n@@ -2919,0 +2957,1 @@\n+\n@@ -2939,0 +2978,1 @@\n+\n@@ -3032,1 +3072,0 @@\n-\n@@ -3058,1 +3097,0 @@\n-\n@@ -3078,1 +3116,0 @@\n-\n@@ -3106,1 +3143,0 @@\n-\n@@ -3125,1 +3161,0 @@\n-\n@@ -3151,1 +3186,0 @@\n-\n@@ -3171,1 +3205,0 @@\n-\n@@ -3199,1 +3232,0 @@\n-\n@@ -3218,1 +3250,0 @@\n-\n@@ -3244,1 +3275,0 @@\n-\n@@ -3264,1 +3294,0 @@\n-\n@@ -3309,0 +3338,1 @@\n+\n@@ -3333,0 +3363,1 @@\n+\n@@ -3351,0 +3382,1 @@\n+\n@@ -3377,0 +3409,1 @@\n+\n@@ -3394,0 +3427,1 @@\n+\n@@ -3418,0 +3452,1 @@\n+\n@@ -3436,0 +3471,1 @@\n+\n@@ -3462,0 +3498,1 @@\n+\n@@ -3479,0 +3516,1 @@\n+\n@@ -3503,0 +3541,1 @@\n+\n@@ -3521,0 +3560,1 @@\n+\n@@ -3547,0 +3587,1 @@\n+\n@@ -3564,0 +3605,1 @@\n+\n@@ -3588,0 +3630,1 @@\n+\n@@ -3606,0 +3649,1 @@\n+\n@@ -3632,0 +3676,1 @@\n+\n@@ -3649,0 +3694,1 @@\n+\n@@ -3673,0 +3719,1 @@\n+\n@@ -3691,0 +3738,1 @@\n+\n@@ -3727,1 +3775,0 @@\n-\n@@ -3743,1 +3790,0 @@\n-\n@@ -3753,1 +3799,0 @@\n-\n@@ -3769,1 +3814,0 @@\n-\n@@ -3787,0 +3831,1 @@\n+\n@@ -3827,0 +3872,1 @@\n+\n@@ -3868,3 +3914,0 @@\n-\n-\n-\n@@ -3890,1 +3933,0 @@\n-\n@@ -3933,1 +3975,0 @@\n-\n@@ -3976,1 +4017,0 @@\n-\n@@ -3996,1 +4036,0 @@\n-\n@@ -4039,1 +4078,0 @@\n-\n@@ -4082,1 +4120,0 @@\n-\n@@ -4125,1 +4162,0 @@\n-\n@@ -4168,2 +4204,0 @@\n-\n-\n@@ -4189,2 +4223,0 @@\n-\n-\n@@ -4214,3 +4246,0 @@\n-\n-\n-\n@@ -4236,2 +4265,0 @@\n-\n-\n@@ -4261,3 +4288,0 @@\n-\n-\n-\n@@ -4283,2 +4307,0 @@\n-\n-\n@@ -4308,3 +4330,0 @@\n-\n-\n-\n@@ -4330,2 +4349,0 @@\n-\n-\n@@ -4355,2 +4372,0 @@\n-\n-\n@@ -4373,1 +4388,0 @@\n-\n@@ -4411,1 +4425,0 @@\n-\n@@ -4491,0 +4504,37 @@\n+\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void compressLong64VectorTests(IntFunction<long[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.compress(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertcompressArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void expandLong64VectorTests(IntFunction<long[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.expand(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertexpandArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n@@ -4661,4 +4711,0 @@\n-\n-\n-\n-\n@@ -4679,3 +4725,0 @@\n-\n-\n-\n@@ -4707,0 +4750,1 @@\n+\n@@ -4736,0 +4780,1 @@\n+\n@@ -4769,0 +4814,1 @@\n+\n@@ -4796,0 +4842,1 @@\n+\n@@ -4835,0 +4882,1 @@\n+\n@@ -4892,22 +4940,0 @@\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n@@ -4917,0 +4943,1 @@\n+\n@@ -4921,1 +4948,0 @@\n-\n@@ -4940,0 +4966,1 @@\n+\n@@ -4957,1 +4984,0 @@\n-\n@@ -4980,3 +5006,0 @@\n-\n-\n-\n@@ -5012,0 +5035,1 @@\n+\n@@ -5042,1 +5066,0 @@\n-\n@@ -5081,3 +5104,0 @@\n-\n-\n-\n@@ -5098,0 +5118,1 @@\n+\n@@ -5113,1 +5134,0 @@\n-\n@@ -5132,1 +5152,0 @@\n-\n@@ -5245,1 +5264,0 @@\n-\n@@ -5254,2 +5272,0 @@\n-\n-\n@@ -5286,2 +5302,0 @@\n-\n-\n@@ -5306,2 +5320,0 @@\n-\n-\n@@ -5312,2 +5324,0 @@\n-\n-\n@@ -5329,2 +5339,0 @@\n-\n-\n@@ -5349,0 +5357,3 @@\n+    static long BIT_COUNT(long a) {\n+        return (long)(Long.bitCount(a));\n+    }\n@@ -5350,0 +5361,4 @@\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void BIT_COUNTLong64VectorTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n@@ -5351,0 +5366,9 @@\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Long64VectorTests::BIT_COUNT);\n+    }\n@@ -5352,0 +5376,165 @@\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void BIT_COUNTMaskedLong64VectorTests(IntFunction<long[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Long64VectorTests::BIT_COUNT);\n+    }\n+\n+    static long TRAILING_ZEROS_COUNT(long a) {\n+        return (long)(TRAILING_ZEROS_COUNT_scalar(a));\n+    }\n+\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void TRAILING_ZEROS_COUNTLong64VectorTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TRAILING_ZEROS_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Long64VectorTests::TRAILING_ZEROS_COUNT);\n+    }\n+\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void TRAILING_ZEROS_COUNTMaskedLong64VectorTests(IntFunction<long[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TRAILING_ZEROS_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Long64VectorTests::TRAILING_ZEROS_COUNT);\n+    }\n+\n+    static long LEADING_ZEROS_COUNT(long a) {\n+        return (long)(LEADING_ZEROS_COUNT_scalar(a));\n+    }\n+\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void LEADING_ZEROS_COUNTLong64VectorTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LEADING_ZEROS_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Long64VectorTests::LEADING_ZEROS_COUNT);\n+    }\n+\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void LEADING_ZEROS_COUNTMaskedLong64VectorTests(IntFunction<long[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LEADING_ZEROS_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Long64VectorTests::LEADING_ZEROS_COUNT);\n+    }\n+\n+    static long REVERSE(long a) {\n+        return (long)(REVERSE_scalar(a));\n+    }\n+\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void REVERSELong64VectorTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Long64VectorTests::REVERSE);\n+    }\n+\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void REVERSEMaskedLong64VectorTests(IntFunction<long[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Long64VectorTests::REVERSE);\n+    }\n+\n+    static long REVERSE_BYTES(long a) {\n+        return (long)(Long.reverseBytes(a));\n+    }\n+\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void REVERSE_BYTESLong64VectorTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Long64VectorTests::REVERSE_BYTES);\n+    }\n+\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void REVERSE_BYTESMaskedLong64VectorTests(IntFunction<long[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Long64VectorTests::REVERSE_BYTES);\n+    }\n@@ -5688,0 +5877,17 @@\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCompressLong64VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        int trueCount = 0;\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                trueCount = vmask.trueCount();\n+                var rmask = vmask.compress();\n+                for (int j = 0; j < SPECIES.length(); j++)  {\n+                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);\n+                }\n+            }\n+        }\n+    }\n+\n@@ -5730,0 +5936,14 @@\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeLongLong64VectorTestsSmokeTest(int offset) {\n+        long limit = SPECIES.length() * BUFFER_REPS;\n+        for (long i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i + offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                long index = i + j + offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n@@ -5750,0 +5970,8 @@\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundLongLong64VectorTestsSmokeTest(int _length) {\n+        long length = _length;\n+        long actualLoopBound = SPECIES.loopBound(length);\n+        long expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+    }\n+\n@@ -5812,1 +6040,0 @@\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long64VectorTests.java","additions":441,"deletions":214,"binary":false,"changes":655,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,3 @@\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.ValueLayout;\n@@ -44,4 +47,0 @@\n-import java.lang.invoke.MethodHandles;\n-import java.lang.invoke.VarHandle;\n-import java.nio.ByteBuffer;\n-import java.nio.LongBuffer;\n@@ -49,1 +48,0 @@\n-import java.nio.ReadOnlyBufferException;\n@@ -79,11 +77,0 @@\n-    static void assertArraysEquals(byte[] r, byte[] a, boolean[] mask) {\n-        int i = 0;\n-        try {\n-            for (; i < a.length; i++) {\n-                Assert.assertEquals(r[i], mask[(i*8\/SPECIES.elementSize()) % SPECIES.length()] ? a[i] : (byte) 0);\n-            }\n-        } catch (AssertionError e) {\n-            Assert.assertEquals(r[i], mask[(i*8\/SPECIES.elementSize()) % SPECIES.length()] ? a[i] : (byte) 0, \"at index #\" + i);\n-        }\n-    }\n-\n@@ -129,1 +116,1 @@\n-    \/\/ Relative to byte[] array.length or ByteBuffer.limit()\n+    \/\/ Relative to byte[] array.length or MemorySegment.byteSize()\n@@ -200,1 +187,1 @@\n-    public Object[][] longByteBufferProvider() {\n+    public Object[][] longMemorySegmentProvider() {\n@@ -202,1 +189,1 @@\n-                flatMap(fa -> BYTE_BUFFER_GENERATORS.stream().\n+                flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n@@ -210,1 +197,1 @@\n-    public Object[][] longByteBufferMaskProvider() {\n+    public Object[][] longMemorySegmentMaskProvider() {\n@@ -213,1 +200,1 @@\n-                        flatMap(fa -> BYTE_BUFFER_GENERATORS.stream().\n+                        flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n@@ -220,19 +207,0 @@\n-    @DataProvider\n-    public Object[][] longByteArrayProvider() {\n-        return LONG_GENERATORS.stream().\n-                flatMap(fa -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                    return new Object[]{fa, bo};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] longByteArrayMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> LONG_GENERATORS.stream().\n-                    flatMap(fa -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                        return new Object[]{fa, fm, bo};\n-                    }))).\n-                toArray(Object[][]::new);\n-    }\n-\n@@ -258,4 +226,4 @@\n-    static ByteBuffer toBuffer(long[] a, IntFunction<ByteBuffer> fb) {\n-        ByteBuffer bb = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n-        for (long v : a) {\n-            bb.putLong(v);\n+    static MemorySegment toSegment(long[] a, IntFunction<MemorySegment> fb) {\n+        MemorySegment ms = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n+        for (int i = 0; i < a.length; i++) {\n+            ms.set(ValueLayout.JAVA_LONG, i * SPECIES.elementSize() \/ 8 , a[i]);\n@@ -263,1 +231,1 @@\n-        return bb.clear();\n+        return ms;\n@@ -266,14 +234,2 @@\n-    static long[] bufferToArray(ByteBuffer bb) {\n-        LongBuffer db = bb.asLongBuffer();\n-        long[] d = new long[db.capacity()];\n-        db.get(0, d);\n-        return d;\n-    }\n-\n-    static byte[] toByteArray(long[] a, IntFunction<byte[]> fb, ByteOrder bo) {\n-        byte[] b = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n-        LongBuffer bb = ByteBuffer.wrap(b, 0, b.length).order(bo).asLongBuffer();\n-        for (long v : a) {\n-            bb.put(v);\n-        }\n-        return b;\n+    static long[] segmentToArray(MemorySegment ms) {\n+        return ms.toArray(ValueLayout.JAVA_LONG);\n@@ -319,22 +275,2 @@\n-    static LongVector fromByteArray(byte[] a, int i, ByteOrder bo) {\n-        return LongVector.fromByteArray(SPECIES, a, i, bo);\n-    }\n-\n-    @DontInline\n-    static LongVector fromByteArray(byte[] a, int i, ByteOrder bo, VectorMask<Long> m) {\n-        return LongVector.fromByteArray(SPECIES, a, i, bo, m);\n-    }\n-\n-    @DontInline\n-    static void intoByteArray(LongVector v, byte[] a, int i, ByteOrder bo) {\n-        v.intoByteArray(a, i, bo);\n-    }\n-\n-    @DontInline\n-    static void intoByteArray(LongVector v, byte[] a, int i, ByteOrder bo, VectorMask<Long> m) {\n-        v.intoByteArray(a, i, bo, m);\n-    }\n-\n-    @DontInline\n-    static LongVector fromByteBuffer(ByteBuffer a, int i, ByteOrder bo) {\n-        return LongVector.fromByteBuffer(SPECIES, a, i, bo);\n+    static LongVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo) {\n+        return LongVector.fromMemorySegment(SPECIES, a, i, bo);\n@@ -344,2 +280,2 @@\n-    static LongVector fromByteBuffer(ByteBuffer a, int i, ByteOrder bo, VectorMask<Long> m) {\n-        return LongVector.fromByteBuffer(SPECIES, a, i, bo, m);\n+    static LongVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo, VectorMask<Long> m) {\n+        return LongVector.fromMemorySegment(SPECIES, a, i, bo, m);\n@@ -349,2 +285,2 @@\n-    static void intoByteBuffer(LongVector v, ByteBuffer a, int i, ByteOrder bo) {\n-        v.intoByteBuffer(a, i, bo);\n+    static void intoMemorySegment(LongVector v, MemorySegment a, int i, ByteOrder bo) {\n+        v.intoMemorySegment(a, i, bo);\n@@ -354,2 +290,2 @@\n-    static void intoByteBuffer(LongVector v, ByteBuffer a, int i, ByteOrder bo, VectorMask<Long> m) {\n-        v.intoByteBuffer(a, i, bo, m);\n+    static void intoMemorySegment(LongVector v, MemorySegment a, int i, ByteOrder bo, VectorMask<Long> m) {\n+        v.intoMemorySegment(a, i, bo, m);\n@@ -358,1 +294,0 @@\n-\n@@ -529,6 +464,6 @@\n-    @Test(dataProvider = \"longByteBufferProvider\")\n-    static void loadStoreByteBuffer(IntFunction<long[]> fa,\n-                                    IntFunction<ByteBuffer> fb,\n-                                    ByteOrder bo) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), fb);\n-        ByteBuffer r = fb.apply(a.limit());\n+    @Test(dataProvider = \"longMemorySegmentProvider\")\n+    static void loadStoreMemorySegment(IntFunction<long[]> fa,\n+                                       IntFunction<MemorySegment> fb,\n+                                       ByteOrder bo) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb);\n+        MemorySegment r = fb.apply((int) a.byteSize());\n@@ -536,1 +471,1 @@\n-        int l = a.limit();\n+        int l = (int) a.byteSize();\n@@ -541,2 +476,2 @@\n-                LongVector av = LongVector.fromByteBuffer(SPECIES, a, i, bo);\n-                av.intoByteBuffer(r, i, bo);\n+                LongVector av = LongVector.fromMemorySegment(SPECIES, a, i, bo);\n+                av.intoMemorySegment(r, i, bo);\n@@ -545,5 +480,2 @@\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        Assert.assertEquals(r, a, \"Buffers not equal\");\n+        long m = r.mismatch(a);\n+        Assert.assertEquals(m, -1, \"Segments not equal\");\n@@ -553,3 +485,3 @@\n-    static void loadByteBufferIOOBE(IntFunction<long[]> fa, IntFunction<Integer> fi) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n+    static void loadMemorySegmentIOOBE(IntFunction<long[]> fa, IntFunction<Integer> fi) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n@@ -557,1 +489,1 @@\n-        int l = a.limit();\n+        int l = (int) a.byteSize();\n@@ -562,2 +494,2 @@\n-                LongVector av = fromByteBuffer(a, i, ByteOrder.nativeOrder());\n-                av.intoByteBuffer(r, i, ByteOrder.nativeOrder());\n+                LongVector av = fromMemorySegment(a, i, ByteOrder.nativeOrder());\n+                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n@@ -567,2 +499,2 @@\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.limit());\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());\n@@ -570,1 +502,1 @@\n-            fromByteBuffer(a, index, ByteOrder.nativeOrder());\n+            fromMemorySegment(a, index, ByteOrder.nativeOrder());\n@@ -582,3 +514,3 @@\n-    static void storeByteBufferIOOBE(IntFunction<long[]> fa, IntFunction<Integer> fi) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n+    static void storeMemorySegmentIOOBE(IntFunction<long[]> fa, IntFunction<Integer> fi) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n@@ -586,1 +518,1 @@\n-        int l = a.limit();\n+        int l = (int) a.byteSize();\n@@ -591,2 +523,2 @@\n-                LongVector av = LongVector.fromByteBuffer(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteBuffer(av, r, i, ByteOrder.nativeOrder());\n+                LongVector av = LongVector.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+                intoMemorySegment(av, r, i, ByteOrder.nativeOrder());\n@@ -596,2 +528,2 @@\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.limit());\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());\n@@ -599,2 +531,2 @@\n-            LongVector av = LongVector.fromByteBuffer(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteBuffer(av, r, index, ByteOrder.nativeOrder());\n+            LongVector av = LongVector.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+            intoMemorySegment(av, r, index, ByteOrder.nativeOrder());\n@@ -611,6 +543,5 @@\n-\n-    @Test(dataProvider = \"longByteBufferMaskProvider\")\n-    static void loadStoreByteBufferMask(IntFunction<long[]> fa,\n-                                        IntFunction<ByteBuffer> fb,\n-                                        IntFunction<boolean[]> fm,\n-                                        ByteOrder bo) {\n+    @Test(dataProvider = \"longMemorySegmentMaskProvider\")\n+    static void loadStoreMemorySegmentMask(IntFunction<long[]> fa,\n+                                           IntFunction<MemorySegment> fb,\n+                                           IntFunction<boolean[]> fm,\n+                                           ByteOrder bo) {\n@@ -618,2 +549,2 @@\n-        ByteBuffer a = toBuffer(_a, fb);\n-        ByteBuffer r = fb.apply(a.limit());\n+        MemorySegment a = toSegment(_a, fb);\n+        MemorySegment r = fb.apply((int) a.byteSize());\n@@ -623,1 +554,1 @@\n-        int l = a.limit();\n+        int l = (int) a.byteSize();\n@@ -628,2 +559,2 @@\n-                LongVector av = LongVector.fromByteBuffer(SPECIES, a, i, bo, vmask);\n-                av.intoByteBuffer(r, i, bo);\n+                LongVector av = LongVector.fromMemorySegment(SPECIES, a, i, bo, vmask);\n+                av.intoMemorySegment(r, i, bo);\n@@ -632,5 +563,1 @@\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        assertArraysEquals(bufferToArray(r), _a, mask);\n+        assertArraysEquals(segmentToArray(r), _a, mask);\n@@ -639,1 +566,1 @@\n-        r = fb.apply(a.limit());\n+        r = fb.apply((int) a.byteSize());\n@@ -643,2 +570,2 @@\n-                LongVector av = LongVector.fromByteBuffer(SPECIES, a, i, bo);\n-                av.intoByteBuffer(r, i, bo, vmask);\n+                LongVector av = LongVector.fromMemorySegment(SPECIES, a, i, bo);\n+                av.intoMemorySegment(r, i, bo, vmask);\n@@ -647,5 +574,1 @@\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        assertArraysEquals(bufferToArray(r), _a, mask);\n+        assertArraysEquals(segmentToArray(r), _a, mask);\n@@ -655,3 +578,3 @@\n-    static void loadByteBufferMaskIOOBE(IntFunction<long[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n+    static void loadMemorySegmentMaskIOOBE(IntFunction<long[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n@@ -661,1 +584,1 @@\n-        int l = a.limit();\n+        int l = (int) a.byteSize();\n@@ -666,2 +589,2 @@\n-                LongVector av = fromByteBuffer(a, i, ByteOrder.nativeOrder(), vmask);\n-                av.intoByteBuffer(r, i, ByteOrder.nativeOrder());\n+                LongVector av = fromMemorySegment(a, i, ByteOrder.nativeOrder(), vmask);\n+                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n@@ -671,2 +594,2 @@\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.limit(), SPECIES.elementSize() \/ 8);\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() \/ 8);\n@@ -674,1 +597,1 @@\n-            fromByteBuffer(a, index, ByteOrder.nativeOrder(), vmask);\n+            fromMemorySegment(a, index, ByteOrder.nativeOrder(), vmask);\n@@ -686,3 +609,3 @@\n-    static void storeByteBufferMaskIOOBE(IntFunction<long[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n+    static void storeMemorySegmentMaskIOOBE(IntFunction<long[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n@@ -692,83 +615,1 @@\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                LongVector av = LongVector.fromByteBuffer(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteBuffer(av, r, i, ByteOrder.nativeOrder(), vmask);\n-            }\n-        }\n-\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.limit(), SPECIES.elementSize() \/ 8);\n-        try {\n-            LongVector av = LongVector.fromByteBuffer(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteBuffer(av, a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"longByteBufferProvider\")\n-    static void loadStoreReadonlyByteBuffer(IntFunction<long[]> fa,\n-                                    IntFunction<ByteBuffer> fb,\n-                                    ByteOrder bo) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), fb).asReadOnlyBuffer();\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo);\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, SPECIES.maskAll(true));\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, SPECIES.maskAll(false));\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            VectorMask<Long> m = SPECIES.shuffleFromOp(i -> i % 2 == 0 ? 1 : -1)\n-                    .laneIsValid();\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, m);\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"longByteArrayProvider\")\n-    static void loadStoreByteArray(IntFunction<long[]> fa,\n-                                    ByteOrder bo) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, bo);\n-        byte[] r = new byte[a.length];\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                LongVector av = LongVector.fromByteArray(SPECIES, a, i, bo);\n-                av.intoByteArray(r, i, bo);\n-            }\n-        }\n-        Assert.assertEquals(r, a, \"Byte arrays not equal\");\n-    }\n-\n-    @Test(dataProvider = \"longByteProviderForIOOBE\")\n-    static void loadByteArrayIOOBE(IntFunction<long[]> fa, IntFunction<Integer> fi) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-\n+        int l = (int) a.byteSize();\n@@ -776,1 +617,0 @@\n-        int l = a.length;\n@@ -780,2 +620,2 @@\n-                LongVector av = fromByteArray(a, i, ByteOrder.nativeOrder());\n-                av.intoByteArray(r, i, ByteOrder.nativeOrder());\n+                LongVector av = LongVector.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+                intoMemorySegment(av, r, i, ByteOrder.nativeOrder(), vmask);\n@@ -785,2 +625,2 @@\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.length);\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() \/ 8);\n@@ -788,1 +628,2 @@\n-            fromByteArray(a, index, ByteOrder.nativeOrder());\n+            LongVector av = LongVector.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+            intoMemorySegment(av, a, index, ByteOrder.nativeOrder(), vmask);\n@@ -799,62 +640,5 @@\n-    @Test(dataProvider = \"longByteProviderForIOOBE\")\n-    static void storeByteArrayIOOBE(IntFunction<long[]> fa, IntFunction<Integer> fi) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                LongVector av = LongVector.fromByteArray(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteArray(av, r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.length);\n-        try {\n-            LongVector av = LongVector.fromByteArray(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteArray(av, r, index, ByteOrder.nativeOrder());\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"longByteArrayMaskProvider\")\n-    static void loadStoreByteArrayMask(IntFunction<long[]> fa,\n-                                  IntFunction<boolean[]> fm,\n-                                  ByteOrder bo) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, bo);\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Long> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-          for (int i = 0; i < l; i += s) {\n-              LongVector av = LongVector.fromByteArray(SPECIES, a, i, bo, vmask);\n-              av.intoByteArray(r, i, bo);\n-          }\n-        }\n-        assertArraysEquals(r, a, mask);\n-\n-\n-        r = new byte[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                LongVector av = LongVector.fromByteArray(SPECIES, a, i, bo);\n-                av.intoByteArray(r, i, bo, vmask);\n-            }\n-        }\n-        assertArraysEquals(r, a, mask);\n-    }\n+    @Test(dataProvider = \"longMemorySegmentProvider\")\n+    static void loadStoreReadonlyMemorySegment(IntFunction<long[]> fa,\n+                                               IntFunction<MemorySegment> fb,\n+                                               ByteOrder bo) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb).asReadOnly();\n@@ -862,6 +646,4 @@\n-    @Test(dataProvider = \"longByteMaskProviderForIOOBE\")\n-    static void loadByteArrayMaskIOOBE(IntFunction<long[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Long> vmask = VectorMask.fromValues(SPECIES, mask);\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo)\n+        );\n@@ -869,2 +651,4 @@\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(true))\n+        );\n@@ -872,6 +656,4 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                LongVector av = fromByteArray(a, i, ByteOrder.nativeOrder(), vmask);\n-                av.intoByteArray(r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(false))\n+        );\n@@ -879,12 +661,6 @@\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length, SPECIES.elementSize() \/ 8);\n-        try {\n-            fromByteArray(a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n+        VectorMask<Long> m = SPECIES.shuffleFromOp(i -> i % 2 == 0 ? 1 : -1)\n+                .laneIsValid();\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, m)\n+        );\n@@ -893,31 +669,0 @@\n-    @Test(dataProvider = \"longByteMaskProviderForIOOBE\")\n-    static void storeByteArrayMaskIOOBE(IntFunction<long[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Long> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                LongVector av = LongVector.fromByteArray(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteArray(av, r, i, ByteOrder.nativeOrder(), vmask);\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length, SPECIES.elementSize() \/ 8);\n-        try {\n-            LongVector av = LongVector.fromByteArray(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteArray(av, a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n@@ -939,0 +684,1 @@\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/LongMaxVectorLoadStoreTests.java","additions":112,"deletions":366,"binary":false,"changes":478,"status":"modified"},{"patch":"@@ -226,0 +226,49 @@\n+    static void assertcompressArraysEquals(long[] r, long[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    Assert.assertEquals(r[i + k], (long)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (long)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals(long[] r, long[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        Assert.assertEquals(r[i + j], (long)0);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (long)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n@@ -882,1 +931,0 @@\n-\n@@ -984,1 +1032,0 @@\n-\n@@ -1060,1 +1107,0 @@\n-\n@@ -1172,1 +1218,0 @@\n-\n@@ -1197,0 +1242,12 @@\n+    static long TRAILING_ZEROS_COUNT_scalar(long a) {\n+        return Long.numberOfTrailingZeros(a);\n+    }\n+\n+    static long LEADING_ZEROS_COUNT_scalar(long a) {\n+        return Long.numberOfLeadingZeros(a);\n+    }\n+\n+    static long REVERSE_scalar(long a) {\n+        return Long.reverse(a);\n+    }\n+\n@@ -1351,0 +1408,1 @@\n+\n@@ -1371,0 +1429,1 @@\n+\n@@ -1427,0 +1486,1 @@\n+\n@@ -1447,0 +1507,1 @@\n+\n@@ -1503,0 +1564,1 @@\n+\n@@ -1523,0 +1585,1 @@\n+\n@@ -1580,2 +1643,0 @@\n-\n-\n@@ -1604,0 +1665,1 @@\n+\n@@ -1627,2 +1689,0 @@\n-\n-\n@@ -1734,0 +1794,1 @@\n+\n@@ -1753,2 +1814,0 @@\n-\n-\n@@ -1775,1 +1834,0 @@\n-\n@@ -1797,2 +1855,0 @@\n-\n-\n@@ -1819,1 +1875,0 @@\n-\n@@ -1840,0 +1895,1 @@\n+\n@@ -1859,2 +1915,0 @@\n-\n-\n@@ -1881,1 +1935,0 @@\n-\n@@ -1903,2 +1956,0 @@\n-\n-\n@@ -1925,0 +1976,81 @@\n+    static long COMPRESS_BITS(long a, long b) {\n+        return (long)(Long.compress(a, b));\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpProvider\")\n+    static void COMPRESS_BITSLongMaxVectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.COMPRESS_BITS, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, LongMaxVectorTests::COMPRESS_BITS);\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpMaskProvider\")\n+    static void COMPRESS_BITSLongMaxVectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.COMPRESS_BITS, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, LongMaxVectorTests::COMPRESS_BITS);\n+    }\n+\n+    static long EXPAND_BITS(long a, long b) {\n+        return (long)(Long.expand(a, b));\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpProvider\")\n+    static void EXPAND_BITSLongMaxVectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.EXPAND_BITS, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, LongMaxVectorTests::EXPAND_BITS);\n+    }\n+\n+    @Test(dataProvider = \"longBinaryOpMaskProvider\")\n+    static void EXPAND_BITSLongMaxVectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                          IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.EXPAND_BITS, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, b, mask, LongMaxVectorTests::EXPAND_BITS);\n+    }\n@@ -2019,3 +2151,0 @@\n-\n-\n-\n@@ -2038,2 +2167,0 @@\n-\n-\n@@ -2059,2 +2186,0 @@\n-\n-\n@@ -2089,2 +2214,0 @@\n-\n-\n@@ -2108,2 +2231,0 @@\n-\n-\n@@ -2138,2 +2259,0 @@\n-\n-\n@@ -2157,2 +2276,0 @@\n-\n-\n@@ -2173,2 +2290,0 @@\n-\n-\n@@ -2192,1 +2307,0 @@\n-\n@@ -2245,2 +2359,0 @@\n-\n-\n@@ -2267,5 +2379,0 @@\n-\n-\n-\n-\n-\n@@ -2293,2 +2400,0 @@\n-\n-\n@@ -2315,5 +2420,0 @@\n-\n-\n-\n-\n-\n@@ -2341,2 +2441,0 @@\n-\n-\n@@ -2363,5 +2461,0 @@\n-\n-\n-\n-\n-\n@@ -2388,2 +2481,0 @@\n-\n-\n@@ -2409,5 +2500,0 @@\n-\n-\n-\n-\n-\n@@ -2434,2 +2520,0 @@\n-\n-\n@@ -2455,5 +2539,0 @@\n-\n-\n-\n-\n-\n@@ -2480,2 +2559,0 @@\n-\n-\n@@ -2501,5 +2578,0 @@\n-\n-\n-\n-\n-\n@@ -2527,2 +2599,0 @@\n-\n-\n@@ -2549,1 +2619,0 @@\n-\n@@ -2571,2 +2640,0 @@\n-\n-\n@@ -2593,1 +2660,0 @@\n-\n@@ -2614,2 +2680,0 @@\n-\n-\n@@ -2635,1 +2699,0 @@\n-\n@@ -2656,2 +2719,0 @@\n-\n-\n@@ -2676,2 +2737,0 @@\n-\n-\n@@ -2697,2 +2756,0 @@\n-\n-\n@@ -2717,6 +2774,0 @@\n-\n-\n-\n-\n-\n-\n@@ -2742,2 +2793,0 @@\n-\n-\n@@ -2762,2 +2811,0 @@\n-\n-\n@@ -2783,2 +2830,0 @@\n-\n-\n@@ -2803,2 +2848,0 @@\n-\n-\n@@ -2824,2 +2867,0 @@\n-\n-\n@@ -2844,2 +2885,0 @@\n-\n-\n@@ -2865,2 +2904,0 @@\n-\n-\n@@ -2906,0 +2943,1 @@\n+\n@@ -2924,0 +2962,1 @@\n+\n@@ -2944,0 +2983,1 @@\n+\n@@ -3037,1 +3077,0 @@\n-\n@@ -3063,1 +3102,0 @@\n-\n@@ -3083,1 +3121,0 @@\n-\n@@ -3111,1 +3148,0 @@\n-\n@@ -3130,1 +3166,0 @@\n-\n@@ -3156,1 +3191,0 @@\n-\n@@ -3176,1 +3210,0 @@\n-\n@@ -3204,1 +3237,0 @@\n-\n@@ -3223,1 +3255,0 @@\n-\n@@ -3249,1 +3280,0 @@\n-\n@@ -3269,1 +3299,0 @@\n-\n@@ -3314,0 +3343,1 @@\n+\n@@ -3338,0 +3368,1 @@\n+\n@@ -3356,0 +3387,1 @@\n+\n@@ -3382,0 +3414,1 @@\n+\n@@ -3399,0 +3432,1 @@\n+\n@@ -3423,0 +3457,1 @@\n+\n@@ -3441,0 +3476,1 @@\n+\n@@ -3467,0 +3503,1 @@\n+\n@@ -3484,0 +3521,1 @@\n+\n@@ -3508,0 +3546,1 @@\n+\n@@ -3526,0 +3565,1 @@\n+\n@@ -3552,0 +3592,1 @@\n+\n@@ -3569,0 +3610,1 @@\n+\n@@ -3593,0 +3635,1 @@\n+\n@@ -3611,0 +3654,1 @@\n+\n@@ -3637,0 +3681,1 @@\n+\n@@ -3654,0 +3699,1 @@\n+\n@@ -3678,0 +3724,1 @@\n+\n@@ -3696,0 +3743,1 @@\n+\n@@ -3732,1 +3780,0 @@\n-\n@@ -3748,1 +3795,0 @@\n-\n@@ -3758,1 +3804,0 @@\n-\n@@ -3774,1 +3819,0 @@\n-\n@@ -3792,0 +3836,1 @@\n+\n@@ -3832,0 +3877,1 @@\n+\n@@ -3873,3 +3919,0 @@\n-\n-\n-\n@@ -3895,1 +3938,0 @@\n-\n@@ -3938,1 +3980,0 @@\n-\n@@ -3981,1 +4022,0 @@\n-\n@@ -4001,1 +4041,0 @@\n-\n@@ -4044,1 +4083,0 @@\n-\n@@ -4087,1 +4125,0 @@\n-\n@@ -4130,1 +4167,0 @@\n-\n@@ -4173,2 +4209,0 @@\n-\n-\n@@ -4194,2 +4228,0 @@\n-\n-\n@@ -4219,3 +4251,0 @@\n-\n-\n-\n@@ -4241,2 +4270,0 @@\n-\n-\n@@ -4266,3 +4293,0 @@\n-\n-\n-\n@@ -4288,2 +4312,0 @@\n-\n-\n@@ -4313,3 +4335,0 @@\n-\n-\n-\n@@ -4335,2 +4354,0 @@\n-\n-\n@@ -4360,2 +4377,0 @@\n-\n-\n@@ -4378,1 +4393,0 @@\n-\n@@ -4416,1 +4430,0 @@\n-\n@@ -4496,0 +4509,37 @@\n+\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void compressLongMaxVectorTests(IntFunction<long[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.compress(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertcompressArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void expandLongMaxVectorTests(IntFunction<long[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.expand(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertexpandArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n@@ -4666,4 +4716,0 @@\n-\n-\n-\n-\n@@ -4684,3 +4730,0 @@\n-\n-\n-\n@@ -4712,0 +4755,1 @@\n+\n@@ -4741,0 +4785,1 @@\n+\n@@ -4774,0 +4819,1 @@\n+\n@@ -4801,0 +4847,1 @@\n+\n@@ -4840,0 +4887,1 @@\n+\n@@ -4897,22 +4945,0 @@\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n@@ -4922,0 +4948,1 @@\n+\n@@ -4926,1 +4953,0 @@\n-\n@@ -4945,0 +4971,1 @@\n+\n@@ -4962,1 +4989,0 @@\n-\n@@ -4985,3 +5011,0 @@\n-\n-\n-\n@@ -5017,0 +5040,1 @@\n+\n@@ -5047,1 +5071,0 @@\n-\n@@ -5086,3 +5109,0 @@\n-\n-\n-\n@@ -5103,0 +5123,1 @@\n+\n@@ -5118,1 +5139,0 @@\n-\n@@ -5137,1 +5157,0 @@\n-\n@@ -5250,1 +5269,0 @@\n-\n@@ -5259,2 +5277,0 @@\n-\n-\n@@ -5291,2 +5307,0 @@\n-\n-\n@@ -5311,2 +5325,0 @@\n-\n-\n@@ -5317,2 +5329,0 @@\n-\n-\n@@ -5334,2 +5344,0 @@\n-\n-\n@@ -5354,0 +5362,3 @@\n+    static long BIT_COUNT(long a) {\n+        return (long)(Long.bitCount(a));\n+    }\n@@ -5355,0 +5366,4 @@\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void BIT_COUNTLongMaxVectorTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n@@ -5356,0 +5371,9 @@\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, LongMaxVectorTests::BIT_COUNT);\n+    }\n@@ -5357,0 +5381,165 @@\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void BIT_COUNTMaskedLongMaxVectorTests(IntFunction<long[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, LongMaxVectorTests::BIT_COUNT);\n+    }\n+\n+    static long TRAILING_ZEROS_COUNT(long a) {\n+        return (long)(TRAILING_ZEROS_COUNT_scalar(a));\n+    }\n+\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void TRAILING_ZEROS_COUNTLongMaxVectorTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TRAILING_ZEROS_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, LongMaxVectorTests::TRAILING_ZEROS_COUNT);\n+    }\n+\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void TRAILING_ZEROS_COUNTMaskedLongMaxVectorTests(IntFunction<long[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TRAILING_ZEROS_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, LongMaxVectorTests::TRAILING_ZEROS_COUNT);\n+    }\n+\n+    static long LEADING_ZEROS_COUNT(long a) {\n+        return (long)(LEADING_ZEROS_COUNT_scalar(a));\n+    }\n+\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void LEADING_ZEROS_COUNTLongMaxVectorTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LEADING_ZEROS_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, LongMaxVectorTests::LEADING_ZEROS_COUNT);\n+    }\n+\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void LEADING_ZEROS_COUNTMaskedLongMaxVectorTests(IntFunction<long[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LEADING_ZEROS_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, LongMaxVectorTests::LEADING_ZEROS_COUNT);\n+    }\n+\n+    static long REVERSE(long a) {\n+        return (long)(REVERSE_scalar(a));\n+    }\n+\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void REVERSELongMaxVectorTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, LongMaxVectorTests::REVERSE);\n+    }\n+\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void REVERSEMaskedLongMaxVectorTests(IntFunction<long[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, LongMaxVectorTests::REVERSE);\n+    }\n+\n+    static long REVERSE_BYTES(long a) {\n+        return (long)(Long.reverseBytes(a));\n+    }\n+\n+    @Test(dataProvider = \"longUnaryOpProvider\")\n+    static void REVERSE_BYTESLongMaxVectorTests(IntFunction<long[]> fa) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, LongMaxVectorTests::REVERSE_BYTES);\n+    }\n+\n+    @Test(dataProvider = \"longUnaryOpMaskProvider\")\n+    static void REVERSE_BYTESMaskedLongMaxVectorTests(IntFunction<long[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, LongMaxVectorTests::REVERSE_BYTES);\n+    }\n@@ -5693,0 +5882,17 @@\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCompressLongMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        int trueCount = 0;\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                trueCount = vmask.trueCount();\n+                var rmask = vmask.compress();\n+                for (int j = 0; j < SPECIES.length(); j++)  {\n+                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);\n+                }\n+            }\n+        }\n+    }\n+\n@@ -5719,0 +5925,14 @@\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeLongLongMaxVectorTestsSmokeTest(int offset) {\n+        long limit = SPECIES.length() * BUFFER_REPS;\n+        for (long i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i + offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                long index = i + j + offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n@@ -5739,0 +5959,8 @@\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundLongLongMaxVectorTestsSmokeTest(int _length) {\n+        long length = _length;\n+        long actualLoopBound = SPECIES.loopBound(length);\n+        long expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+    }\n+\n@@ -5801,1 +6029,0 @@\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/LongMaxVectorTests.java","additions":441,"deletions":214,"binary":false,"changes":655,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,3 @@\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.ValueLayout;\n@@ -42,2 +45,0 @@\n-import java.nio.ByteBuffer;\n-import java.nio.ShortBuffer;\n@@ -45,1 +46,0 @@\n-import java.nio.ReadOnlyBufferException;\n@@ -70,11 +70,0 @@\n-    static void assertArraysEquals(byte[] r, byte[] a, boolean[] mask) {\n-        int i = 0;\n-        try {\n-            for (; i < a.length; i++) {\n-                Assert.assertEquals(r[i], mask[(i*8\/SPECIES.elementSize()) % SPECIES.length()] ? a[i] : (byte) 0);\n-            }\n-        } catch (AssertionError e) {\n-            Assert.assertEquals(r[i], mask[(i*8\/SPECIES.elementSize()) % SPECIES.length()] ? a[i] : (byte) 0, \"at index #\" + i);\n-        }\n-    }\n-\n@@ -120,1 +109,1 @@\n-    \/\/ Relative to byte[] array.length or ByteBuffer.limit()\n+    \/\/ Relative to byte[] array.length or MemorySegment.byteSize()\n@@ -191,1 +180,1 @@\n-    public Object[][] shortByteBufferProvider() {\n+    public Object[][] shortMemorySegmentProvider() {\n@@ -193,1 +182,1 @@\n-                flatMap(fa -> BYTE_BUFFER_GENERATORS.stream().\n+                flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n@@ -201,1 +190,1 @@\n-    public Object[][] shortByteBufferMaskProvider() {\n+    public Object[][] shortMemorySegmentMaskProvider() {\n@@ -204,1 +193,1 @@\n-                        flatMap(fa -> BYTE_BUFFER_GENERATORS.stream().\n+                        flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n@@ -211,19 +200,0 @@\n-    @DataProvider\n-    public Object[][] shortByteArrayProvider() {\n-        return SHORT_GENERATORS.stream().\n-                flatMap(fa -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                    return new Object[]{fa, bo};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] shortByteArrayMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> SHORT_GENERATORS.stream().\n-                    flatMap(fa -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                        return new Object[]{fa, fm, bo};\n-                    }))).\n-                toArray(Object[][]::new);\n-    }\n-\n@@ -249,4 +219,4 @@\n-    static ByteBuffer toBuffer(short[] a, IntFunction<ByteBuffer> fb) {\n-        ByteBuffer bb = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n-        for (short v : a) {\n-            bb.putShort(v);\n+    static MemorySegment toSegment(short[] a, IntFunction<MemorySegment> fb) {\n+        MemorySegment ms = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n+        for (int i = 0; i < a.length; i++) {\n+            ms.set(ValueLayout.JAVA_SHORT, i * SPECIES.elementSize() \/ 8 , a[i]);\n@@ -254,1 +224,1 @@\n-        return bb.clear();\n+        return ms;\n@@ -257,14 +227,2 @@\n-    static short[] bufferToArray(ByteBuffer bb) {\n-        ShortBuffer db = bb.asShortBuffer();\n-        short[] d = new short[db.capacity()];\n-        db.get(0, d);\n-        return d;\n-    }\n-\n-    static byte[] toByteArray(short[] a, IntFunction<byte[]> fb, ByteOrder bo) {\n-        byte[] b = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n-        ShortBuffer bb = ByteBuffer.wrap(b, 0, b.length).order(bo).asShortBuffer();\n-        for (short v : a) {\n-            bb.put(v);\n-        }\n-        return b;\n+    static short[] segmentToArray(MemorySegment ms) {\n+        return ms.toArray(ValueLayout.JAVA_SHORT);\n@@ -310,22 +268,2 @@\n-    static ShortVector fromByteArray(byte[] a, int i, ByteOrder bo) {\n-        return ShortVector.fromByteArray(SPECIES, a, i, bo);\n-    }\n-\n-    @DontInline\n-    static ShortVector fromByteArray(byte[] a, int i, ByteOrder bo, VectorMask<Short> m) {\n-        return ShortVector.fromByteArray(SPECIES, a, i, bo, m);\n-    }\n-\n-    @DontInline\n-    static void intoByteArray(ShortVector v, byte[] a, int i, ByteOrder bo) {\n-        v.intoByteArray(a, i, bo);\n-    }\n-\n-    @DontInline\n-    static void intoByteArray(ShortVector v, byte[] a, int i, ByteOrder bo, VectorMask<Short> m) {\n-        v.intoByteArray(a, i, bo, m);\n-    }\n-\n-    @DontInline\n-    static ShortVector fromByteBuffer(ByteBuffer a, int i, ByteOrder bo) {\n-        return ShortVector.fromByteBuffer(SPECIES, a, i, bo);\n+    static ShortVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo) {\n+        return ShortVector.fromMemorySegment(SPECIES, a, i, bo);\n@@ -335,2 +273,2 @@\n-    static ShortVector fromByteBuffer(ByteBuffer a, int i, ByteOrder bo, VectorMask<Short> m) {\n-        return ShortVector.fromByteBuffer(SPECIES, a, i, bo, m);\n+    static ShortVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo, VectorMask<Short> m) {\n+        return ShortVector.fromMemorySegment(SPECIES, a, i, bo, m);\n@@ -340,2 +278,2 @@\n-    static void intoByteBuffer(ShortVector v, ByteBuffer a, int i, ByteOrder bo) {\n-        v.intoByteBuffer(a, i, bo);\n+    static void intoMemorySegment(ShortVector v, MemorySegment a, int i, ByteOrder bo) {\n+        v.intoMemorySegment(a, i, bo);\n@@ -345,2 +283,2 @@\n-    static void intoByteBuffer(ShortVector v, ByteBuffer a, int i, ByteOrder bo, VectorMask<Short> m) {\n-        v.intoByteBuffer(a, i, bo, m);\n+    static void intoMemorySegment(ShortVector v, MemorySegment a, int i, ByteOrder bo, VectorMask<Short> m) {\n+        v.intoMemorySegment(a, i, bo, m);\n@@ -349,1 +287,0 @@\n-\n@@ -520,6 +457,6 @@\n-    @Test(dataProvider = \"shortByteBufferProvider\")\n-    static void loadStoreByteBuffer(IntFunction<short[]> fa,\n-                                    IntFunction<ByteBuffer> fb,\n-                                    ByteOrder bo) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), fb);\n-        ByteBuffer r = fb.apply(a.limit());\n+    @Test(dataProvider = \"shortMemorySegmentProvider\")\n+    static void loadStoreMemorySegment(IntFunction<short[]> fa,\n+                                       IntFunction<MemorySegment> fb,\n+                                       ByteOrder bo) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb);\n+        MemorySegment r = fb.apply((int) a.byteSize());\n@@ -527,1 +464,1 @@\n-        int l = a.limit();\n+        int l = (int) a.byteSize();\n@@ -532,2 +469,2 @@\n-                ShortVector av = ShortVector.fromByteBuffer(SPECIES, a, i, bo);\n-                av.intoByteBuffer(r, i, bo);\n+                ShortVector av = ShortVector.fromMemorySegment(SPECIES, a, i, bo);\n+                av.intoMemorySegment(r, i, bo);\n@@ -536,5 +473,2 @@\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        Assert.assertEquals(r, a, \"Buffers not equal\");\n+        long m = r.mismatch(a);\n+        Assert.assertEquals(m, -1, \"Segments not equal\");\n@@ -544,3 +478,3 @@\n-    static void loadByteBufferIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n+    static void loadMemorySegmentIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n@@ -548,1 +482,1 @@\n-        int l = a.limit();\n+        int l = (int) a.byteSize();\n@@ -553,2 +487,2 @@\n-                ShortVector av = fromByteBuffer(a, i, ByteOrder.nativeOrder());\n-                av.intoByteBuffer(r, i, ByteOrder.nativeOrder());\n+                ShortVector av = fromMemorySegment(a, i, ByteOrder.nativeOrder());\n+                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n@@ -558,2 +492,2 @@\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.limit());\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());\n@@ -561,1 +495,1 @@\n-            fromByteBuffer(a, index, ByteOrder.nativeOrder());\n+            fromMemorySegment(a, index, ByteOrder.nativeOrder());\n@@ -573,3 +507,3 @@\n-    static void storeByteBufferIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n+    static void storeMemorySegmentIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n@@ -577,1 +511,1 @@\n-        int l = a.limit();\n+        int l = (int) a.byteSize();\n@@ -582,2 +516,2 @@\n-                ShortVector av = ShortVector.fromByteBuffer(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteBuffer(av, r, i, ByteOrder.nativeOrder());\n+                ShortVector av = ShortVector.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+                intoMemorySegment(av, r, i, ByteOrder.nativeOrder());\n@@ -587,2 +521,2 @@\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.limit());\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());\n@@ -590,2 +524,2 @@\n-            ShortVector av = ShortVector.fromByteBuffer(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteBuffer(av, r, index, ByteOrder.nativeOrder());\n+            ShortVector av = ShortVector.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+            intoMemorySegment(av, r, index, ByteOrder.nativeOrder());\n@@ -602,6 +536,5 @@\n-\n-    @Test(dataProvider = \"shortByteBufferMaskProvider\")\n-    static void loadStoreByteBufferMask(IntFunction<short[]> fa,\n-                                        IntFunction<ByteBuffer> fb,\n-                                        IntFunction<boolean[]> fm,\n-                                        ByteOrder bo) {\n+    @Test(dataProvider = \"shortMemorySegmentMaskProvider\")\n+    static void loadStoreMemorySegmentMask(IntFunction<short[]> fa,\n+                                           IntFunction<MemorySegment> fb,\n+                                           IntFunction<boolean[]> fm,\n+                                           ByteOrder bo) {\n@@ -609,2 +542,2 @@\n-        ByteBuffer a = toBuffer(_a, fb);\n-        ByteBuffer r = fb.apply(a.limit());\n+        MemorySegment a = toSegment(_a, fb);\n+        MemorySegment r = fb.apply((int) a.byteSize());\n@@ -614,1 +547,1 @@\n-        int l = a.limit();\n+        int l = (int) a.byteSize();\n@@ -619,2 +552,2 @@\n-                ShortVector av = ShortVector.fromByteBuffer(SPECIES, a, i, bo, vmask);\n-                av.intoByteBuffer(r, i, bo);\n+                ShortVector av = ShortVector.fromMemorySegment(SPECIES, a, i, bo, vmask);\n+                av.intoMemorySegment(r, i, bo);\n@@ -623,5 +556,1 @@\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        assertArraysEquals(bufferToArray(r), _a, mask);\n+        assertArraysEquals(segmentToArray(r), _a, mask);\n@@ -630,1 +559,1 @@\n-        r = fb.apply(a.limit());\n+        r = fb.apply((int) a.byteSize());\n@@ -634,2 +563,2 @@\n-                ShortVector av = ShortVector.fromByteBuffer(SPECIES, a, i, bo);\n-                av.intoByteBuffer(r, i, bo, vmask);\n+                ShortVector av = ShortVector.fromMemorySegment(SPECIES, a, i, bo);\n+                av.intoMemorySegment(r, i, bo, vmask);\n@@ -638,5 +567,1 @@\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        assertArraysEquals(bufferToArray(r), _a, mask);\n+        assertArraysEquals(segmentToArray(r), _a, mask);\n@@ -646,3 +571,3 @@\n-    static void loadByteBufferMaskIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n+    static void loadMemorySegmentMaskIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n@@ -652,1 +577,1 @@\n-        int l = a.limit();\n+        int l = (int) a.byteSize();\n@@ -657,2 +582,2 @@\n-                ShortVector av = fromByteBuffer(a, i, ByteOrder.nativeOrder(), vmask);\n-                av.intoByteBuffer(r, i, ByteOrder.nativeOrder());\n+                ShortVector av = fromMemorySegment(a, i, ByteOrder.nativeOrder(), vmask);\n+                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n@@ -662,2 +587,2 @@\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.limit(), SPECIES.elementSize() \/ 8);\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() \/ 8);\n@@ -665,1 +590,1 @@\n-            fromByteBuffer(a, index, ByteOrder.nativeOrder(), vmask);\n+            fromMemorySegment(a, index, ByteOrder.nativeOrder(), vmask);\n@@ -677,3 +602,3 @@\n-    static void storeByteBufferMaskIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n+    static void storeMemorySegmentMaskIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n@@ -683,83 +608,1 @@\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ShortVector av = ShortVector.fromByteBuffer(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteBuffer(av, r, i, ByteOrder.nativeOrder(), vmask);\n-            }\n-        }\n-\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.limit(), SPECIES.elementSize() \/ 8);\n-        try {\n-            ShortVector av = ShortVector.fromByteBuffer(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteBuffer(av, a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"shortByteBufferProvider\")\n-    static void loadStoreReadonlyByteBuffer(IntFunction<short[]> fa,\n-                                    IntFunction<ByteBuffer> fb,\n-                                    ByteOrder bo) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), fb).asReadOnlyBuffer();\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo);\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, SPECIES.maskAll(true));\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, SPECIES.maskAll(false));\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            VectorMask<Short> m = SPECIES.shuffleFromOp(i -> i % 2 == 0 ? 1 : -1)\n-                    .laneIsValid();\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, m);\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"shortByteArrayProvider\")\n-    static void loadStoreByteArray(IntFunction<short[]> fa,\n-                                    ByteOrder bo) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, bo);\n-        byte[] r = new byte[a.length];\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ShortVector av = ShortVector.fromByteArray(SPECIES, a, i, bo);\n-                av.intoByteArray(r, i, bo);\n-            }\n-        }\n-        Assert.assertEquals(r, a, \"Byte arrays not equal\");\n-    }\n-\n-    @Test(dataProvider = \"shortByteProviderForIOOBE\")\n-    static void loadByteArrayIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-\n+        int l = (int) a.byteSize();\n@@ -767,1 +610,0 @@\n-        int l = a.length;\n@@ -771,2 +613,2 @@\n-                ShortVector av = fromByteArray(a, i, ByteOrder.nativeOrder());\n-                av.intoByteArray(r, i, ByteOrder.nativeOrder());\n+                ShortVector av = ShortVector.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+                intoMemorySegment(av, r, i, ByteOrder.nativeOrder(), vmask);\n@@ -776,2 +618,2 @@\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.length);\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() \/ 8);\n@@ -779,1 +621,2 @@\n-            fromByteArray(a, index, ByteOrder.nativeOrder());\n+            ShortVector av = ShortVector.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+            intoMemorySegment(av, a, index, ByteOrder.nativeOrder(), vmask);\n@@ -790,62 +633,5 @@\n-    @Test(dataProvider = \"shortByteProviderForIOOBE\")\n-    static void storeByteArrayIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ShortVector av = ShortVector.fromByteArray(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteArray(av, r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.length);\n-        try {\n-            ShortVector av = ShortVector.fromByteArray(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteArray(av, r, index, ByteOrder.nativeOrder());\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"shortByteArrayMaskProvider\")\n-    static void loadStoreByteArrayMask(IntFunction<short[]> fa,\n-                                  IntFunction<boolean[]> fm,\n-                                  ByteOrder bo) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, bo);\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Short> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-          for (int i = 0; i < l; i += s) {\n-              ShortVector av = ShortVector.fromByteArray(SPECIES, a, i, bo, vmask);\n-              av.intoByteArray(r, i, bo);\n-          }\n-        }\n-        assertArraysEquals(r, a, mask);\n-\n-\n-        r = new byte[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ShortVector av = ShortVector.fromByteArray(SPECIES, a, i, bo);\n-                av.intoByteArray(r, i, bo, vmask);\n-            }\n-        }\n-        assertArraysEquals(r, a, mask);\n-    }\n+    @Test(dataProvider = \"shortMemorySegmentProvider\")\n+    static void loadStoreReadonlyMemorySegment(IntFunction<short[]> fa,\n+                                               IntFunction<MemorySegment> fb,\n+                                               ByteOrder bo) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb).asReadOnly();\n@@ -853,6 +639,4 @@\n-    @Test(dataProvider = \"shortByteMaskProviderForIOOBE\")\n-    static void loadByteArrayMaskIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Short> vmask = VectorMask.fromValues(SPECIES, mask);\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo)\n+        );\n@@ -860,2 +644,4 @@\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(true))\n+        );\n@@ -863,6 +649,4 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ShortVector av = fromByteArray(a, i, ByteOrder.nativeOrder(), vmask);\n-                av.intoByteArray(r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(false))\n+        );\n@@ -870,12 +654,6 @@\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length, SPECIES.elementSize() \/ 8);\n-        try {\n-            fromByteArray(a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n+        VectorMask<Short> m = SPECIES.shuffleFromOp(i -> i % 2 == 0 ? 1 : -1)\n+                .laneIsValid();\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, m)\n+        );\n@@ -884,31 +662,0 @@\n-    @Test(dataProvider = \"shortByteMaskProviderForIOOBE\")\n-    static void storeByteArrayMaskIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Short> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ShortVector av = ShortVector.fromByteArray(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteArray(av, r, i, ByteOrder.nativeOrder(), vmask);\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length, SPECIES.elementSize() \/ 8);\n-        try {\n-            ShortVector av = ShortVector.fromByteArray(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteArray(av, a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n@@ -930,0 +677,1 @@\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short128VectorLoadStoreTests.java","additions":112,"deletions":364,"binary":false,"changes":476,"status":"modified"},{"patch":"@@ -264,0 +264,49 @@\n+    static void assertcompressArraysEquals(short[] r, short[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    Assert.assertEquals(r[i + k], (short)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (short)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals(short[] r, short[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        Assert.assertEquals(r[i + j], (short)0);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (short)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n@@ -887,1 +936,0 @@\n-\n@@ -982,2 +1030,0 @@\n-\n-\n@@ -1059,1 +1105,0 @@\n-\n@@ -1200,0 +1245,16 @@\n+    static short TRAILING_ZEROS_COUNT_scalar(short a) {\n+        return (short) (a != 0 ? Integer.numberOfTrailingZeros(a) : 16);\n+    }\n+\n+    static short LEADING_ZEROS_COUNT_scalar(short a) {\n+        return (short) (a >= 0 ? Integer.numberOfLeadingZeros(a) - 16 : 0);\n+    }\n+\n+    static short REVERSE_scalar(short a) {\n+        short b = ROL_scalar(a, (short) 8);\n+        b = (short) (((b & 0x5555) << 1) | ((b & 0xAAAA) >>> 1));\n+        b = (short) (((b & 0x3333) << 2) | ((b & 0xCCCC) >>> 2));\n+        b = (short) (((b & 0x0F0F) << 4) | ((b & 0xF0F0) >>> 4));\n+        return b;\n+    }\n+\n@@ -1349,0 +1410,1 @@\n+\n@@ -1369,0 +1431,1 @@\n+\n@@ -1425,0 +1488,1 @@\n+\n@@ -1445,0 +1509,1 @@\n+\n@@ -1501,0 +1566,1 @@\n+\n@@ -1521,0 +1587,1 @@\n+\n@@ -1578,2 +1645,0 @@\n-\n-\n@@ -1602,0 +1667,1 @@\n+\n@@ -1625,2 +1691,0 @@\n-\n-\n@@ -1732,0 +1796,1 @@\n+\n@@ -1751,2 +1816,0 @@\n-\n-\n@@ -1773,1 +1836,0 @@\n-\n@@ -1795,2 +1857,0 @@\n-\n-\n@@ -1817,1 +1877,0 @@\n-\n@@ -1838,0 +1897,1 @@\n+\n@@ -1857,2 +1917,0 @@\n-\n-\n@@ -1879,1 +1937,0 @@\n-\n@@ -1901,2 +1958,0 @@\n-\n-\n@@ -1923,1 +1978,0 @@\n-\n@@ -2017,3 +2071,0 @@\n-\n-\n-\n@@ -2036,2 +2087,0 @@\n-\n-\n@@ -2057,2 +2106,0 @@\n-\n-\n@@ -2087,2 +2134,0 @@\n-\n-\n@@ -2106,2 +2151,0 @@\n-\n-\n@@ -2136,2 +2179,0 @@\n-\n-\n@@ -2155,2 +2196,0 @@\n-\n-\n@@ -2171,2 +2210,0 @@\n-\n-\n@@ -2190,1 +2227,0 @@\n-\n@@ -2222,4 +2258,0 @@\n-\n-\n-\n-\n@@ -2247,2 +2279,0 @@\n-\n-\n@@ -2269,5 +2299,0 @@\n-\n-\n-\n-\n-\n@@ -2295,2 +2320,0 @@\n-\n-\n@@ -2317,5 +2340,0 @@\n-\n-\n-\n-\n-\n@@ -2343,2 +2361,0 @@\n-\n-\n@@ -2365,5 +2381,0 @@\n-\n-\n-\n-\n-\n@@ -2390,2 +2401,0 @@\n-\n-\n@@ -2411,5 +2420,0 @@\n-\n-\n-\n-\n-\n@@ -2436,2 +2440,0 @@\n-\n-\n@@ -2457,5 +2459,0 @@\n-\n-\n-\n-\n-\n@@ -2482,2 +2479,0 @@\n-\n-\n@@ -2503,1 +2498,0 @@\n-\n@@ -2525,2 +2519,0 @@\n-\n-\n@@ -2547,1 +2539,0 @@\n-\n@@ -2569,2 +2560,0 @@\n-\n-\n@@ -2591,1 +2580,0 @@\n-\n@@ -2612,2 +2600,0 @@\n-\n-\n@@ -2633,1 +2619,0 @@\n-\n@@ -2654,2 +2639,0 @@\n-\n-\n@@ -2674,6 +2657,0 @@\n-\n-\n-\n-\n-\n-\n@@ -2699,2 +2676,0 @@\n-\n-\n@@ -2719,2 +2694,0 @@\n-\n-\n@@ -2740,2 +2713,0 @@\n-\n-\n@@ -2760,2 +2731,0 @@\n-\n-\n@@ -2781,2 +2750,0 @@\n-\n-\n@@ -2801,2 +2768,0 @@\n-\n-\n@@ -2822,2 +2787,0 @@\n-\n-\n@@ -2842,2 +2805,0 @@\n-\n-\n@@ -2863,2 +2824,0 @@\n-\n-\n@@ -2904,0 +2863,1 @@\n+\n@@ -2922,0 +2882,1 @@\n+\n@@ -2942,0 +2903,1 @@\n+\n@@ -3035,1 +2997,0 @@\n-\n@@ -3061,1 +3022,0 @@\n-\n@@ -3081,1 +3041,0 @@\n-\n@@ -3109,1 +3068,0 @@\n-\n@@ -3128,1 +3086,0 @@\n-\n@@ -3154,1 +3111,0 @@\n-\n@@ -3174,1 +3130,0 @@\n-\n@@ -3202,1 +3157,0 @@\n-\n@@ -3221,1 +3175,0 @@\n-\n@@ -3247,1 +3200,0 @@\n-\n@@ -3267,1 +3219,0 @@\n-\n@@ -3312,0 +3263,1 @@\n+\n@@ -3336,0 +3288,1 @@\n+\n@@ -3354,0 +3307,1 @@\n+\n@@ -3380,0 +3334,1 @@\n+\n@@ -3397,0 +3352,1 @@\n+\n@@ -3421,0 +3377,1 @@\n+\n@@ -3439,0 +3396,1 @@\n+\n@@ -3465,0 +3423,1 @@\n+\n@@ -3482,0 +3441,1 @@\n+\n@@ -3506,0 +3466,1 @@\n+\n@@ -3524,0 +3485,1 @@\n+\n@@ -3550,0 +3512,1 @@\n+\n@@ -3567,0 +3530,1 @@\n+\n@@ -3591,0 +3555,1 @@\n+\n@@ -3609,0 +3574,1 @@\n+\n@@ -3635,0 +3601,1 @@\n+\n@@ -3652,0 +3619,1 @@\n+\n@@ -3676,0 +3644,1 @@\n+\n@@ -3694,0 +3663,1 @@\n+\n@@ -3730,1 +3700,0 @@\n-\n@@ -3746,1 +3715,0 @@\n-\n@@ -3756,1 +3724,0 @@\n-\n@@ -3772,1 +3739,0 @@\n-\n@@ -3790,0 +3756,1 @@\n+\n@@ -3830,0 +3797,1 @@\n+\n@@ -3871,3 +3839,0 @@\n-\n-\n-\n@@ -3893,1 +3858,0 @@\n-\n@@ -3936,1 +3900,0 @@\n-\n@@ -3979,1 +3942,0 @@\n-\n@@ -3999,1 +3961,0 @@\n-\n@@ -4042,1 +4003,0 @@\n-\n@@ -4085,1 +4045,0 @@\n-\n@@ -4128,1 +4087,0 @@\n-\n@@ -4171,2 +4129,0 @@\n-\n-\n@@ -4192,2 +4148,0 @@\n-\n-\n@@ -4217,3 +4171,0 @@\n-\n-\n-\n@@ -4239,2 +4190,0 @@\n-\n-\n@@ -4264,3 +4213,0 @@\n-\n-\n-\n@@ -4286,2 +4232,0 @@\n-\n-\n@@ -4311,3 +4255,0 @@\n-\n-\n-\n@@ -4333,2 +4274,0 @@\n-\n-\n@@ -4358,2 +4297,0 @@\n-\n-\n@@ -4376,1 +4313,0 @@\n-\n@@ -4413,1 +4349,0 @@\n-\n@@ -4450,1 +4385,0 @@\n-\n@@ -4487,1 +4421,0 @@\n-\n@@ -4566,0 +4499,37 @@\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void compressShort128VectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.compress(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertcompressArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void expandShort128VectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.expand(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertexpandArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n@@ -4736,4 +4706,0 @@\n-\n-\n-\n-\n@@ -4754,3 +4720,0 @@\n-\n-\n-\n@@ -4782,0 +4745,1 @@\n+\n@@ -4811,0 +4775,1 @@\n+\n@@ -4844,0 +4809,1 @@\n+\n@@ -4871,0 +4837,1 @@\n+\n@@ -4910,0 +4877,1 @@\n+\n@@ -4967,22 +4935,0 @@\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n@@ -4992,0 +4938,1 @@\n+\n@@ -4996,1 +4943,0 @@\n-\n@@ -5015,0 +4961,1 @@\n+\n@@ -5032,1 +4979,0 @@\n-\n@@ -5055,3 +5001,0 @@\n-\n-\n-\n@@ -5087,0 +5030,1 @@\n+\n@@ -5117,1 +5061,0 @@\n-\n@@ -5156,3 +5099,0 @@\n-\n-\n-\n@@ -5173,0 +5113,1 @@\n+\n@@ -5188,1 +5129,0 @@\n-\n@@ -5207,1 +5147,0 @@\n-\n@@ -5320,1 +5259,0 @@\n-\n@@ -5329,2 +5267,0 @@\n-\n-\n@@ -5361,2 +5297,0 @@\n-\n-\n@@ -5381,2 +5315,0 @@\n-\n-\n@@ -5387,2 +5319,0 @@\n-\n-\n@@ -5404,2 +5334,0 @@\n-\n-\n@@ -5424,0 +5352,151 @@\n+    static short BIT_COUNT(short a) {\n+        return (short)(Integer.bitCount((int)a & 0xFFFF));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void BIT_COUNTShort128VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Short128VectorTests::BIT_COUNT);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void BIT_COUNTMaskedShort128VectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Short128VectorTests::BIT_COUNT);\n+    }\n+\n+    static short TRAILING_ZEROS_COUNT(short a) {\n+        return (short)(TRAILING_ZEROS_COUNT_scalar(a));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void TRAILING_ZEROS_COUNTShort128VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TRAILING_ZEROS_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Short128VectorTests::TRAILING_ZEROS_COUNT);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void TRAILING_ZEROS_COUNTMaskedShort128VectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TRAILING_ZEROS_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Short128VectorTests::TRAILING_ZEROS_COUNT);\n+    }\n+\n+    static short LEADING_ZEROS_COUNT(short a) {\n+        return (short)(LEADING_ZEROS_COUNT_scalar(a));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void LEADING_ZEROS_COUNTShort128VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LEADING_ZEROS_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Short128VectorTests::LEADING_ZEROS_COUNT);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void LEADING_ZEROS_COUNTMaskedShort128VectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LEADING_ZEROS_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Short128VectorTests::LEADING_ZEROS_COUNT);\n+    }\n+\n+    static short REVERSE(short a) {\n+        return (short)(REVERSE_scalar(a));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void REVERSEShort128VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Short128VectorTests::REVERSE);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void REVERSEMaskedShort128VectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Short128VectorTests::REVERSE);\n+    }\n+\n+    static short REVERSE_BYTES(short a) {\n+        return (short)(Short.reverseBytes(a));\n+    }\n@@ -5425,0 +5504,4 @@\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void REVERSE_BYTESShort128VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n@@ -5426,0 +5509,6 @@\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES).intoArray(r, i);\n+            }\n+        }\n@@ -5427,0 +5516,20 @@\n+        assertArraysEquals(r, a, Short128VectorTests::REVERSE_BYTES);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void REVERSE_BYTESMaskedShort128VectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Short128VectorTests::REVERSE_BYTES);\n+    }\n@@ -5829,0 +5938,17 @@\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCompressShort128VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        int trueCount = 0;\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                trueCount = vmask.trueCount();\n+                var rmask = vmask.compress();\n+                for (int j = 0; j < SPECIES.length(); j++)  {\n+                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);\n+                }\n+            }\n+        }\n+    }\n+\n@@ -5871,0 +5997,14 @@\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeLongShort128VectorTestsSmokeTest(int offset) {\n+        long limit = SPECIES.length() * BUFFER_REPS;\n+        for (long i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i + offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                long index = i + j + offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n@@ -5891,0 +6031,8 @@\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundLongShort128VectorTestsSmokeTest(int _length) {\n+        long length = _length;\n+        long actualLoopBound = SPECIES.loopBound(length);\n+        long expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+    }\n+\n@@ -5953,1 +6101,0 @@\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short128VectorTests.java","additions":364,"deletions":217,"binary":false,"changes":581,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,3 @@\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.ValueLayout;\n@@ -42,2 +45,0 @@\n-import java.nio.ByteBuffer;\n-import java.nio.ShortBuffer;\n@@ -45,1 +46,0 @@\n-import java.nio.ReadOnlyBufferException;\n@@ -70,11 +70,0 @@\n-    static void assertArraysEquals(byte[] r, byte[] a, boolean[] mask) {\n-        int i = 0;\n-        try {\n-            for (; i < a.length; i++) {\n-                Assert.assertEquals(r[i], mask[(i*8\/SPECIES.elementSize()) % SPECIES.length()] ? a[i] : (byte) 0);\n-            }\n-        } catch (AssertionError e) {\n-            Assert.assertEquals(r[i], mask[(i*8\/SPECIES.elementSize()) % SPECIES.length()] ? a[i] : (byte) 0, \"at index #\" + i);\n-        }\n-    }\n-\n@@ -120,1 +109,1 @@\n-    \/\/ Relative to byte[] array.length or ByteBuffer.limit()\n+    \/\/ Relative to byte[] array.length or MemorySegment.byteSize()\n@@ -191,1 +180,1 @@\n-    public Object[][] shortByteBufferProvider() {\n+    public Object[][] shortMemorySegmentProvider() {\n@@ -193,1 +182,1 @@\n-                flatMap(fa -> BYTE_BUFFER_GENERATORS.stream().\n+                flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n@@ -201,1 +190,1 @@\n-    public Object[][] shortByteBufferMaskProvider() {\n+    public Object[][] shortMemorySegmentMaskProvider() {\n@@ -204,1 +193,1 @@\n-                        flatMap(fa -> BYTE_BUFFER_GENERATORS.stream().\n+                        flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n@@ -211,19 +200,0 @@\n-    @DataProvider\n-    public Object[][] shortByteArrayProvider() {\n-        return SHORT_GENERATORS.stream().\n-                flatMap(fa -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                    return new Object[]{fa, bo};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] shortByteArrayMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> SHORT_GENERATORS.stream().\n-                    flatMap(fa -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                        return new Object[]{fa, fm, bo};\n-                    }))).\n-                toArray(Object[][]::new);\n-    }\n-\n@@ -249,4 +219,4 @@\n-    static ByteBuffer toBuffer(short[] a, IntFunction<ByteBuffer> fb) {\n-        ByteBuffer bb = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n-        for (short v : a) {\n-            bb.putShort(v);\n+    static MemorySegment toSegment(short[] a, IntFunction<MemorySegment> fb) {\n+        MemorySegment ms = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n+        for (int i = 0; i < a.length; i++) {\n+            ms.set(ValueLayout.JAVA_SHORT, i * SPECIES.elementSize() \/ 8 , a[i]);\n@@ -254,1 +224,1 @@\n-        return bb.clear();\n+        return ms;\n@@ -257,14 +227,2 @@\n-    static short[] bufferToArray(ByteBuffer bb) {\n-        ShortBuffer db = bb.asShortBuffer();\n-        short[] d = new short[db.capacity()];\n-        db.get(0, d);\n-        return d;\n-    }\n-\n-    static byte[] toByteArray(short[] a, IntFunction<byte[]> fb, ByteOrder bo) {\n-        byte[] b = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n-        ShortBuffer bb = ByteBuffer.wrap(b, 0, b.length).order(bo).asShortBuffer();\n-        for (short v : a) {\n-            bb.put(v);\n-        }\n-        return b;\n+    static short[] segmentToArray(MemorySegment ms) {\n+        return ms.toArray(ValueLayout.JAVA_SHORT);\n@@ -310,22 +268,2 @@\n-    static ShortVector fromByteArray(byte[] a, int i, ByteOrder bo) {\n-        return ShortVector.fromByteArray(SPECIES, a, i, bo);\n-    }\n-\n-    @DontInline\n-    static ShortVector fromByteArray(byte[] a, int i, ByteOrder bo, VectorMask<Short> m) {\n-        return ShortVector.fromByteArray(SPECIES, a, i, bo, m);\n-    }\n-\n-    @DontInline\n-    static void intoByteArray(ShortVector v, byte[] a, int i, ByteOrder bo) {\n-        v.intoByteArray(a, i, bo);\n-    }\n-\n-    @DontInline\n-    static void intoByteArray(ShortVector v, byte[] a, int i, ByteOrder bo, VectorMask<Short> m) {\n-        v.intoByteArray(a, i, bo, m);\n-    }\n-\n-    @DontInline\n-    static ShortVector fromByteBuffer(ByteBuffer a, int i, ByteOrder bo) {\n-        return ShortVector.fromByteBuffer(SPECIES, a, i, bo);\n+    static ShortVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo) {\n+        return ShortVector.fromMemorySegment(SPECIES, a, i, bo);\n@@ -335,2 +273,2 @@\n-    static ShortVector fromByteBuffer(ByteBuffer a, int i, ByteOrder bo, VectorMask<Short> m) {\n-        return ShortVector.fromByteBuffer(SPECIES, a, i, bo, m);\n+    static ShortVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo, VectorMask<Short> m) {\n+        return ShortVector.fromMemorySegment(SPECIES, a, i, bo, m);\n@@ -340,2 +278,2 @@\n-    static void intoByteBuffer(ShortVector v, ByteBuffer a, int i, ByteOrder bo) {\n-        v.intoByteBuffer(a, i, bo);\n+    static void intoMemorySegment(ShortVector v, MemorySegment a, int i, ByteOrder bo) {\n+        v.intoMemorySegment(a, i, bo);\n@@ -345,2 +283,2 @@\n-    static void intoByteBuffer(ShortVector v, ByteBuffer a, int i, ByteOrder bo, VectorMask<Short> m) {\n-        v.intoByteBuffer(a, i, bo, m);\n+    static void intoMemorySegment(ShortVector v, MemorySegment a, int i, ByteOrder bo, VectorMask<Short> m) {\n+        v.intoMemorySegment(a, i, bo, m);\n@@ -349,1 +287,0 @@\n-\n@@ -520,6 +457,6 @@\n-    @Test(dataProvider = \"shortByteBufferProvider\")\n-    static void loadStoreByteBuffer(IntFunction<short[]> fa,\n-                                    IntFunction<ByteBuffer> fb,\n-                                    ByteOrder bo) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), fb);\n-        ByteBuffer r = fb.apply(a.limit());\n+    @Test(dataProvider = \"shortMemorySegmentProvider\")\n+    static void loadStoreMemorySegment(IntFunction<short[]> fa,\n+                                       IntFunction<MemorySegment> fb,\n+                                       ByteOrder bo) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb);\n+        MemorySegment r = fb.apply((int) a.byteSize());\n@@ -527,1 +464,1 @@\n-        int l = a.limit();\n+        int l = (int) a.byteSize();\n@@ -532,2 +469,2 @@\n-                ShortVector av = ShortVector.fromByteBuffer(SPECIES, a, i, bo);\n-                av.intoByteBuffer(r, i, bo);\n+                ShortVector av = ShortVector.fromMemorySegment(SPECIES, a, i, bo);\n+                av.intoMemorySegment(r, i, bo);\n@@ -536,5 +473,2 @@\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        Assert.assertEquals(r, a, \"Buffers not equal\");\n+        long m = r.mismatch(a);\n+        Assert.assertEquals(m, -1, \"Segments not equal\");\n@@ -544,3 +478,3 @@\n-    static void loadByteBufferIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n+    static void loadMemorySegmentIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n@@ -548,1 +482,1 @@\n-        int l = a.limit();\n+        int l = (int) a.byteSize();\n@@ -553,2 +487,2 @@\n-                ShortVector av = fromByteBuffer(a, i, ByteOrder.nativeOrder());\n-                av.intoByteBuffer(r, i, ByteOrder.nativeOrder());\n+                ShortVector av = fromMemorySegment(a, i, ByteOrder.nativeOrder());\n+                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n@@ -558,2 +492,2 @@\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.limit());\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());\n@@ -561,1 +495,1 @@\n-            fromByteBuffer(a, index, ByteOrder.nativeOrder());\n+            fromMemorySegment(a, index, ByteOrder.nativeOrder());\n@@ -573,3 +507,3 @@\n-    static void storeByteBufferIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n+    static void storeMemorySegmentIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n@@ -577,1 +511,1 @@\n-        int l = a.limit();\n+        int l = (int) a.byteSize();\n@@ -582,2 +516,2 @@\n-                ShortVector av = ShortVector.fromByteBuffer(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteBuffer(av, r, i, ByteOrder.nativeOrder());\n+                ShortVector av = ShortVector.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+                intoMemorySegment(av, r, i, ByteOrder.nativeOrder());\n@@ -587,2 +521,2 @@\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.limit());\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());\n@@ -590,2 +524,2 @@\n-            ShortVector av = ShortVector.fromByteBuffer(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteBuffer(av, r, index, ByteOrder.nativeOrder());\n+            ShortVector av = ShortVector.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+            intoMemorySegment(av, r, index, ByteOrder.nativeOrder());\n@@ -602,6 +536,5 @@\n-\n-    @Test(dataProvider = \"shortByteBufferMaskProvider\")\n-    static void loadStoreByteBufferMask(IntFunction<short[]> fa,\n-                                        IntFunction<ByteBuffer> fb,\n-                                        IntFunction<boolean[]> fm,\n-                                        ByteOrder bo) {\n+    @Test(dataProvider = \"shortMemorySegmentMaskProvider\")\n+    static void loadStoreMemorySegmentMask(IntFunction<short[]> fa,\n+                                           IntFunction<MemorySegment> fb,\n+                                           IntFunction<boolean[]> fm,\n+                                           ByteOrder bo) {\n@@ -609,2 +542,2 @@\n-        ByteBuffer a = toBuffer(_a, fb);\n-        ByteBuffer r = fb.apply(a.limit());\n+        MemorySegment a = toSegment(_a, fb);\n+        MemorySegment r = fb.apply((int) a.byteSize());\n@@ -614,1 +547,1 @@\n-        int l = a.limit();\n+        int l = (int) a.byteSize();\n@@ -619,2 +552,2 @@\n-                ShortVector av = ShortVector.fromByteBuffer(SPECIES, a, i, bo, vmask);\n-                av.intoByteBuffer(r, i, bo);\n+                ShortVector av = ShortVector.fromMemorySegment(SPECIES, a, i, bo, vmask);\n+                av.intoMemorySegment(r, i, bo);\n@@ -623,5 +556,1 @@\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        assertArraysEquals(bufferToArray(r), _a, mask);\n+        assertArraysEquals(segmentToArray(r), _a, mask);\n@@ -630,1 +559,1 @@\n-        r = fb.apply(a.limit());\n+        r = fb.apply((int) a.byteSize());\n@@ -634,2 +563,2 @@\n-                ShortVector av = ShortVector.fromByteBuffer(SPECIES, a, i, bo);\n-                av.intoByteBuffer(r, i, bo, vmask);\n+                ShortVector av = ShortVector.fromMemorySegment(SPECIES, a, i, bo);\n+                av.intoMemorySegment(r, i, bo, vmask);\n@@ -638,5 +567,1 @@\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        assertArraysEquals(bufferToArray(r), _a, mask);\n+        assertArraysEquals(segmentToArray(r), _a, mask);\n@@ -646,3 +571,3 @@\n-    static void loadByteBufferMaskIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n+    static void loadMemorySegmentMaskIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n@@ -652,1 +577,1 @@\n-        int l = a.limit();\n+        int l = (int) a.byteSize();\n@@ -657,2 +582,2 @@\n-                ShortVector av = fromByteBuffer(a, i, ByteOrder.nativeOrder(), vmask);\n-                av.intoByteBuffer(r, i, ByteOrder.nativeOrder());\n+                ShortVector av = fromMemorySegment(a, i, ByteOrder.nativeOrder(), vmask);\n+                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n@@ -662,2 +587,2 @@\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.limit(), SPECIES.elementSize() \/ 8);\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() \/ 8);\n@@ -665,1 +590,1 @@\n-            fromByteBuffer(a, index, ByteOrder.nativeOrder(), vmask);\n+            fromMemorySegment(a, index, ByteOrder.nativeOrder(), vmask);\n@@ -677,3 +602,3 @@\n-    static void storeByteBufferMaskIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n+    static void storeMemorySegmentMaskIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n@@ -683,83 +608,1 @@\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ShortVector av = ShortVector.fromByteBuffer(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteBuffer(av, r, i, ByteOrder.nativeOrder(), vmask);\n-            }\n-        }\n-\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.limit(), SPECIES.elementSize() \/ 8);\n-        try {\n-            ShortVector av = ShortVector.fromByteBuffer(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteBuffer(av, a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"shortByteBufferProvider\")\n-    static void loadStoreReadonlyByteBuffer(IntFunction<short[]> fa,\n-                                    IntFunction<ByteBuffer> fb,\n-                                    ByteOrder bo) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), fb).asReadOnlyBuffer();\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo);\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, SPECIES.maskAll(true));\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, SPECIES.maskAll(false));\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            VectorMask<Short> m = SPECIES.shuffleFromOp(i -> i % 2 == 0 ? 1 : -1)\n-                    .laneIsValid();\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, m);\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"shortByteArrayProvider\")\n-    static void loadStoreByteArray(IntFunction<short[]> fa,\n-                                    ByteOrder bo) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, bo);\n-        byte[] r = new byte[a.length];\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ShortVector av = ShortVector.fromByteArray(SPECIES, a, i, bo);\n-                av.intoByteArray(r, i, bo);\n-            }\n-        }\n-        Assert.assertEquals(r, a, \"Byte arrays not equal\");\n-    }\n-\n-    @Test(dataProvider = \"shortByteProviderForIOOBE\")\n-    static void loadByteArrayIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-\n+        int l = (int) a.byteSize();\n@@ -767,1 +610,0 @@\n-        int l = a.length;\n@@ -771,2 +613,2 @@\n-                ShortVector av = fromByteArray(a, i, ByteOrder.nativeOrder());\n-                av.intoByteArray(r, i, ByteOrder.nativeOrder());\n+                ShortVector av = ShortVector.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+                intoMemorySegment(av, r, i, ByteOrder.nativeOrder(), vmask);\n@@ -776,2 +618,2 @@\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.length);\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() \/ 8);\n@@ -779,1 +621,2 @@\n-            fromByteArray(a, index, ByteOrder.nativeOrder());\n+            ShortVector av = ShortVector.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+            intoMemorySegment(av, a, index, ByteOrder.nativeOrder(), vmask);\n@@ -790,62 +633,5 @@\n-    @Test(dataProvider = \"shortByteProviderForIOOBE\")\n-    static void storeByteArrayIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ShortVector av = ShortVector.fromByteArray(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteArray(av, r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.length);\n-        try {\n-            ShortVector av = ShortVector.fromByteArray(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteArray(av, r, index, ByteOrder.nativeOrder());\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"shortByteArrayMaskProvider\")\n-    static void loadStoreByteArrayMask(IntFunction<short[]> fa,\n-                                  IntFunction<boolean[]> fm,\n-                                  ByteOrder bo) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, bo);\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Short> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-          for (int i = 0; i < l; i += s) {\n-              ShortVector av = ShortVector.fromByteArray(SPECIES, a, i, bo, vmask);\n-              av.intoByteArray(r, i, bo);\n-          }\n-        }\n-        assertArraysEquals(r, a, mask);\n-\n-\n-        r = new byte[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ShortVector av = ShortVector.fromByteArray(SPECIES, a, i, bo);\n-                av.intoByteArray(r, i, bo, vmask);\n-            }\n-        }\n-        assertArraysEquals(r, a, mask);\n-    }\n+    @Test(dataProvider = \"shortMemorySegmentProvider\")\n+    static void loadStoreReadonlyMemorySegment(IntFunction<short[]> fa,\n+                                               IntFunction<MemorySegment> fb,\n+                                               ByteOrder bo) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb).asReadOnly();\n@@ -853,6 +639,4 @@\n-    @Test(dataProvider = \"shortByteMaskProviderForIOOBE\")\n-    static void loadByteArrayMaskIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Short> vmask = VectorMask.fromValues(SPECIES, mask);\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo)\n+        );\n@@ -860,2 +644,4 @@\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(true))\n+        );\n@@ -863,6 +649,4 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ShortVector av = fromByteArray(a, i, ByteOrder.nativeOrder(), vmask);\n-                av.intoByteArray(r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(false))\n+        );\n@@ -870,12 +654,6 @@\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length, SPECIES.elementSize() \/ 8);\n-        try {\n-            fromByteArray(a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n+        VectorMask<Short> m = SPECIES.shuffleFromOp(i -> i % 2 == 0 ? 1 : -1)\n+                .laneIsValid();\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, m)\n+        );\n@@ -884,31 +662,0 @@\n-    @Test(dataProvider = \"shortByteMaskProviderForIOOBE\")\n-    static void storeByteArrayMaskIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Short> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ShortVector av = ShortVector.fromByteArray(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteArray(av, r, i, ByteOrder.nativeOrder(), vmask);\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length, SPECIES.elementSize() \/ 8);\n-        try {\n-            ShortVector av = ShortVector.fromByteArray(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteArray(av, a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n@@ -930,0 +677,1 @@\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short256VectorLoadStoreTests.java","additions":112,"deletions":364,"binary":false,"changes":476,"status":"modified"},{"patch":"@@ -264,0 +264,49 @@\n+    static void assertcompressArraysEquals(short[] r, short[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    Assert.assertEquals(r[i + k], (short)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (short)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals(short[] r, short[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        Assert.assertEquals(r[i + j], (short)0);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (short)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n@@ -887,1 +936,0 @@\n-\n@@ -982,2 +1030,0 @@\n-\n-\n@@ -1059,1 +1105,0 @@\n-\n@@ -1200,0 +1245,16 @@\n+    static short TRAILING_ZEROS_COUNT_scalar(short a) {\n+        return (short) (a != 0 ? Integer.numberOfTrailingZeros(a) : 16);\n+    }\n+\n+    static short LEADING_ZEROS_COUNT_scalar(short a) {\n+        return (short) (a >= 0 ? Integer.numberOfLeadingZeros(a) - 16 : 0);\n+    }\n+\n+    static short REVERSE_scalar(short a) {\n+        short b = ROL_scalar(a, (short) 8);\n+        b = (short) (((b & 0x5555) << 1) | ((b & 0xAAAA) >>> 1));\n+        b = (short) (((b & 0x3333) << 2) | ((b & 0xCCCC) >>> 2));\n+        b = (short) (((b & 0x0F0F) << 4) | ((b & 0xF0F0) >>> 4));\n+        return b;\n+    }\n+\n@@ -1349,0 +1410,1 @@\n+\n@@ -1369,0 +1431,1 @@\n+\n@@ -1425,0 +1488,1 @@\n+\n@@ -1445,0 +1509,1 @@\n+\n@@ -1501,0 +1566,1 @@\n+\n@@ -1521,0 +1587,1 @@\n+\n@@ -1578,2 +1645,0 @@\n-\n-\n@@ -1602,0 +1667,1 @@\n+\n@@ -1625,2 +1691,0 @@\n-\n-\n@@ -1732,0 +1796,1 @@\n+\n@@ -1751,2 +1816,0 @@\n-\n-\n@@ -1773,1 +1836,0 @@\n-\n@@ -1795,2 +1857,0 @@\n-\n-\n@@ -1817,1 +1877,0 @@\n-\n@@ -1838,0 +1897,1 @@\n+\n@@ -1857,2 +1917,0 @@\n-\n-\n@@ -1879,1 +1937,0 @@\n-\n@@ -1901,2 +1958,0 @@\n-\n-\n@@ -1923,1 +1978,0 @@\n-\n@@ -2017,3 +2071,0 @@\n-\n-\n-\n@@ -2036,2 +2087,0 @@\n-\n-\n@@ -2057,2 +2106,0 @@\n-\n-\n@@ -2087,2 +2134,0 @@\n-\n-\n@@ -2106,2 +2151,0 @@\n-\n-\n@@ -2136,2 +2179,0 @@\n-\n-\n@@ -2155,2 +2196,0 @@\n-\n-\n@@ -2171,2 +2210,0 @@\n-\n-\n@@ -2190,1 +2227,0 @@\n-\n@@ -2222,4 +2258,0 @@\n-\n-\n-\n-\n@@ -2247,2 +2279,0 @@\n-\n-\n@@ -2269,5 +2299,0 @@\n-\n-\n-\n-\n-\n@@ -2295,2 +2320,0 @@\n-\n-\n@@ -2317,5 +2340,0 @@\n-\n-\n-\n-\n-\n@@ -2343,2 +2361,0 @@\n-\n-\n@@ -2365,5 +2381,0 @@\n-\n-\n-\n-\n-\n@@ -2390,2 +2401,0 @@\n-\n-\n@@ -2411,5 +2420,0 @@\n-\n-\n-\n-\n-\n@@ -2436,2 +2440,0 @@\n-\n-\n@@ -2457,5 +2459,0 @@\n-\n-\n-\n-\n-\n@@ -2482,2 +2479,0 @@\n-\n-\n@@ -2503,1 +2498,0 @@\n-\n@@ -2525,2 +2519,0 @@\n-\n-\n@@ -2547,1 +2539,0 @@\n-\n@@ -2569,2 +2560,0 @@\n-\n-\n@@ -2591,1 +2580,0 @@\n-\n@@ -2612,2 +2600,0 @@\n-\n-\n@@ -2633,1 +2619,0 @@\n-\n@@ -2654,2 +2639,0 @@\n-\n-\n@@ -2674,6 +2657,0 @@\n-\n-\n-\n-\n-\n-\n@@ -2699,2 +2676,0 @@\n-\n-\n@@ -2719,2 +2694,0 @@\n-\n-\n@@ -2740,2 +2713,0 @@\n-\n-\n@@ -2760,2 +2731,0 @@\n-\n-\n@@ -2781,2 +2750,0 @@\n-\n-\n@@ -2801,2 +2768,0 @@\n-\n-\n@@ -2822,2 +2787,0 @@\n-\n-\n@@ -2842,2 +2805,0 @@\n-\n-\n@@ -2863,2 +2824,0 @@\n-\n-\n@@ -2904,0 +2863,1 @@\n+\n@@ -2922,0 +2882,1 @@\n+\n@@ -2942,0 +2903,1 @@\n+\n@@ -3035,1 +2997,0 @@\n-\n@@ -3061,1 +3022,0 @@\n-\n@@ -3081,1 +3041,0 @@\n-\n@@ -3109,1 +3068,0 @@\n-\n@@ -3128,1 +3086,0 @@\n-\n@@ -3154,1 +3111,0 @@\n-\n@@ -3174,1 +3130,0 @@\n-\n@@ -3202,1 +3157,0 @@\n-\n@@ -3221,1 +3175,0 @@\n-\n@@ -3247,1 +3200,0 @@\n-\n@@ -3267,1 +3219,0 @@\n-\n@@ -3312,0 +3263,1 @@\n+\n@@ -3336,0 +3288,1 @@\n+\n@@ -3354,0 +3307,1 @@\n+\n@@ -3380,0 +3334,1 @@\n+\n@@ -3397,0 +3352,1 @@\n+\n@@ -3421,0 +3377,1 @@\n+\n@@ -3439,0 +3396,1 @@\n+\n@@ -3465,0 +3423,1 @@\n+\n@@ -3482,0 +3441,1 @@\n+\n@@ -3506,0 +3466,1 @@\n+\n@@ -3524,0 +3485,1 @@\n+\n@@ -3550,0 +3512,1 @@\n+\n@@ -3567,0 +3530,1 @@\n+\n@@ -3591,0 +3555,1 @@\n+\n@@ -3609,0 +3574,1 @@\n+\n@@ -3635,0 +3601,1 @@\n+\n@@ -3652,0 +3619,1 @@\n+\n@@ -3676,0 +3644,1 @@\n+\n@@ -3694,0 +3663,1 @@\n+\n@@ -3730,1 +3700,0 @@\n-\n@@ -3746,1 +3715,0 @@\n-\n@@ -3756,1 +3724,0 @@\n-\n@@ -3772,1 +3739,0 @@\n-\n@@ -3790,0 +3756,1 @@\n+\n@@ -3830,0 +3797,1 @@\n+\n@@ -3871,3 +3839,0 @@\n-\n-\n-\n@@ -3893,1 +3858,0 @@\n-\n@@ -3936,1 +3900,0 @@\n-\n@@ -3979,1 +3942,0 @@\n-\n@@ -3999,1 +3961,0 @@\n-\n@@ -4042,1 +4003,0 @@\n-\n@@ -4085,1 +4045,0 @@\n-\n@@ -4128,1 +4087,0 @@\n-\n@@ -4171,2 +4129,0 @@\n-\n-\n@@ -4192,2 +4148,0 @@\n-\n-\n@@ -4217,3 +4171,0 @@\n-\n-\n-\n@@ -4239,2 +4190,0 @@\n-\n-\n@@ -4264,3 +4213,0 @@\n-\n-\n-\n@@ -4286,2 +4232,0 @@\n-\n-\n@@ -4311,3 +4255,0 @@\n-\n-\n-\n@@ -4333,2 +4274,0 @@\n-\n-\n@@ -4358,2 +4297,0 @@\n-\n-\n@@ -4376,1 +4313,0 @@\n-\n@@ -4413,1 +4349,0 @@\n-\n@@ -4450,1 +4385,0 @@\n-\n@@ -4487,1 +4421,0 @@\n-\n@@ -4566,0 +4499,37 @@\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void compressShort256VectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.compress(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertcompressArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void expandShort256VectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.expand(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertexpandArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n@@ -4736,4 +4706,0 @@\n-\n-\n-\n-\n@@ -4754,3 +4720,0 @@\n-\n-\n-\n@@ -4782,0 +4745,1 @@\n+\n@@ -4811,0 +4775,1 @@\n+\n@@ -4844,0 +4809,1 @@\n+\n@@ -4871,0 +4837,1 @@\n+\n@@ -4910,0 +4877,1 @@\n+\n@@ -4967,22 +4935,0 @@\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n@@ -4992,0 +4938,1 @@\n+\n@@ -4996,1 +4943,0 @@\n-\n@@ -5015,0 +4961,1 @@\n+\n@@ -5032,1 +4979,0 @@\n-\n@@ -5055,3 +5001,0 @@\n-\n-\n-\n@@ -5087,0 +5030,1 @@\n+\n@@ -5117,1 +5061,0 @@\n-\n@@ -5156,3 +5099,0 @@\n-\n-\n-\n@@ -5173,0 +5113,1 @@\n+\n@@ -5188,1 +5129,0 @@\n-\n@@ -5207,1 +5147,0 @@\n-\n@@ -5320,1 +5259,0 @@\n-\n@@ -5329,2 +5267,0 @@\n-\n-\n@@ -5361,2 +5297,0 @@\n-\n-\n@@ -5381,2 +5315,0 @@\n-\n-\n@@ -5387,2 +5319,0 @@\n-\n-\n@@ -5404,2 +5334,0 @@\n-\n-\n@@ -5424,0 +5352,151 @@\n+    static short BIT_COUNT(short a) {\n+        return (short)(Integer.bitCount((int)a & 0xFFFF));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void BIT_COUNTShort256VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Short256VectorTests::BIT_COUNT);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void BIT_COUNTMaskedShort256VectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Short256VectorTests::BIT_COUNT);\n+    }\n+\n+    static short TRAILING_ZEROS_COUNT(short a) {\n+        return (short)(TRAILING_ZEROS_COUNT_scalar(a));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void TRAILING_ZEROS_COUNTShort256VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TRAILING_ZEROS_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Short256VectorTests::TRAILING_ZEROS_COUNT);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void TRAILING_ZEROS_COUNTMaskedShort256VectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TRAILING_ZEROS_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Short256VectorTests::TRAILING_ZEROS_COUNT);\n+    }\n+\n+    static short LEADING_ZEROS_COUNT(short a) {\n+        return (short)(LEADING_ZEROS_COUNT_scalar(a));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void LEADING_ZEROS_COUNTShort256VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LEADING_ZEROS_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Short256VectorTests::LEADING_ZEROS_COUNT);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void LEADING_ZEROS_COUNTMaskedShort256VectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LEADING_ZEROS_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Short256VectorTests::LEADING_ZEROS_COUNT);\n+    }\n+\n+    static short REVERSE(short a) {\n+        return (short)(REVERSE_scalar(a));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void REVERSEShort256VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Short256VectorTests::REVERSE);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void REVERSEMaskedShort256VectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Short256VectorTests::REVERSE);\n+    }\n+\n+    static short REVERSE_BYTES(short a) {\n+        return (short)(Short.reverseBytes(a));\n+    }\n@@ -5425,0 +5504,4 @@\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void REVERSE_BYTESShort256VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n@@ -5426,0 +5509,6 @@\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES).intoArray(r, i);\n+            }\n+        }\n@@ -5427,0 +5516,20 @@\n+        assertArraysEquals(r, a, Short256VectorTests::REVERSE_BYTES);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void REVERSE_BYTESMaskedShort256VectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Short256VectorTests::REVERSE_BYTES);\n+    }\n@@ -5829,0 +5938,17 @@\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCompressShort256VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        int trueCount = 0;\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                trueCount = vmask.trueCount();\n+                var rmask = vmask.compress();\n+                for (int j = 0; j < SPECIES.length(); j++)  {\n+                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);\n+                }\n+            }\n+        }\n+    }\n+\n@@ -5871,0 +5997,14 @@\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeLongShort256VectorTestsSmokeTest(int offset) {\n+        long limit = SPECIES.length() * BUFFER_REPS;\n+        for (long i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i + offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                long index = i + j + offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n@@ -5891,0 +6031,8 @@\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundLongShort256VectorTestsSmokeTest(int _length) {\n+        long length = _length;\n+        long actualLoopBound = SPECIES.loopBound(length);\n+        long expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+    }\n+\n@@ -5953,1 +6101,0 @@\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short256VectorTests.java","additions":364,"deletions":217,"binary":false,"changes":581,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,3 @@\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.ValueLayout;\n@@ -42,2 +45,0 @@\n-import java.nio.ByteBuffer;\n-import java.nio.ShortBuffer;\n@@ -45,1 +46,0 @@\n-import java.nio.ReadOnlyBufferException;\n@@ -70,11 +70,0 @@\n-    static void assertArraysEquals(byte[] r, byte[] a, boolean[] mask) {\n-        int i = 0;\n-        try {\n-            for (; i < a.length; i++) {\n-                Assert.assertEquals(r[i], mask[(i*8\/SPECIES.elementSize()) % SPECIES.length()] ? a[i] : (byte) 0);\n-            }\n-        } catch (AssertionError e) {\n-            Assert.assertEquals(r[i], mask[(i*8\/SPECIES.elementSize()) % SPECIES.length()] ? a[i] : (byte) 0, \"at index #\" + i);\n-        }\n-    }\n-\n@@ -120,1 +109,1 @@\n-    \/\/ Relative to byte[] array.length or ByteBuffer.limit()\n+    \/\/ Relative to byte[] array.length or MemorySegment.byteSize()\n@@ -191,1 +180,1 @@\n-    public Object[][] shortByteBufferProvider() {\n+    public Object[][] shortMemorySegmentProvider() {\n@@ -193,1 +182,1 @@\n-                flatMap(fa -> BYTE_BUFFER_GENERATORS.stream().\n+                flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n@@ -201,1 +190,1 @@\n-    public Object[][] shortByteBufferMaskProvider() {\n+    public Object[][] shortMemorySegmentMaskProvider() {\n@@ -204,1 +193,1 @@\n-                        flatMap(fa -> BYTE_BUFFER_GENERATORS.stream().\n+                        flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n@@ -211,19 +200,0 @@\n-    @DataProvider\n-    public Object[][] shortByteArrayProvider() {\n-        return SHORT_GENERATORS.stream().\n-                flatMap(fa -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                    return new Object[]{fa, bo};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] shortByteArrayMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> SHORT_GENERATORS.stream().\n-                    flatMap(fa -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                        return new Object[]{fa, fm, bo};\n-                    }))).\n-                toArray(Object[][]::new);\n-    }\n-\n@@ -249,4 +219,4 @@\n-    static ByteBuffer toBuffer(short[] a, IntFunction<ByteBuffer> fb) {\n-        ByteBuffer bb = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n-        for (short v : a) {\n-            bb.putShort(v);\n+    static MemorySegment toSegment(short[] a, IntFunction<MemorySegment> fb) {\n+        MemorySegment ms = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n+        for (int i = 0; i < a.length; i++) {\n+            ms.set(ValueLayout.JAVA_SHORT, i * SPECIES.elementSize() \/ 8 , a[i]);\n@@ -254,1 +224,1 @@\n-        return bb.clear();\n+        return ms;\n@@ -257,14 +227,2 @@\n-    static short[] bufferToArray(ByteBuffer bb) {\n-        ShortBuffer db = bb.asShortBuffer();\n-        short[] d = new short[db.capacity()];\n-        db.get(0, d);\n-        return d;\n-    }\n-\n-    static byte[] toByteArray(short[] a, IntFunction<byte[]> fb, ByteOrder bo) {\n-        byte[] b = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n-        ShortBuffer bb = ByteBuffer.wrap(b, 0, b.length).order(bo).asShortBuffer();\n-        for (short v : a) {\n-            bb.put(v);\n-        }\n-        return b;\n+    static short[] segmentToArray(MemorySegment ms) {\n+        return ms.toArray(ValueLayout.JAVA_SHORT);\n@@ -310,22 +268,2 @@\n-    static ShortVector fromByteArray(byte[] a, int i, ByteOrder bo) {\n-        return ShortVector.fromByteArray(SPECIES, a, i, bo);\n-    }\n-\n-    @DontInline\n-    static ShortVector fromByteArray(byte[] a, int i, ByteOrder bo, VectorMask<Short> m) {\n-        return ShortVector.fromByteArray(SPECIES, a, i, bo, m);\n-    }\n-\n-    @DontInline\n-    static void intoByteArray(ShortVector v, byte[] a, int i, ByteOrder bo) {\n-        v.intoByteArray(a, i, bo);\n-    }\n-\n-    @DontInline\n-    static void intoByteArray(ShortVector v, byte[] a, int i, ByteOrder bo, VectorMask<Short> m) {\n-        v.intoByteArray(a, i, bo, m);\n-    }\n-\n-    @DontInline\n-    static ShortVector fromByteBuffer(ByteBuffer a, int i, ByteOrder bo) {\n-        return ShortVector.fromByteBuffer(SPECIES, a, i, bo);\n+    static ShortVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo) {\n+        return ShortVector.fromMemorySegment(SPECIES, a, i, bo);\n@@ -335,2 +273,2 @@\n-    static ShortVector fromByteBuffer(ByteBuffer a, int i, ByteOrder bo, VectorMask<Short> m) {\n-        return ShortVector.fromByteBuffer(SPECIES, a, i, bo, m);\n+    static ShortVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo, VectorMask<Short> m) {\n+        return ShortVector.fromMemorySegment(SPECIES, a, i, bo, m);\n@@ -340,2 +278,2 @@\n-    static void intoByteBuffer(ShortVector v, ByteBuffer a, int i, ByteOrder bo) {\n-        v.intoByteBuffer(a, i, bo);\n+    static void intoMemorySegment(ShortVector v, MemorySegment a, int i, ByteOrder bo) {\n+        v.intoMemorySegment(a, i, bo);\n@@ -345,2 +283,2 @@\n-    static void intoByteBuffer(ShortVector v, ByteBuffer a, int i, ByteOrder bo, VectorMask<Short> m) {\n-        v.intoByteBuffer(a, i, bo, m);\n+    static void intoMemorySegment(ShortVector v, MemorySegment a, int i, ByteOrder bo, VectorMask<Short> m) {\n+        v.intoMemorySegment(a, i, bo, m);\n@@ -349,1 +287,0 @@\n-\n@@ -520,6 +457,6 @@\n-    @Test(dataProvider = \"shortByteBufferProvider\")\n-    static void loadStoreByteBuffer(IntFunction<short[]> fa,\n-                                    IntFunction<ByteBuffer> fb,\n-                                    ByteOrder bo) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), fb);\n-        ByteBuffer r = fb.apply(a.limit());\n+    @Test(dataProvider = \"shortMemorySegmentProvider\")\n+    static void loadStoreMemorySegment(IntFunction<short[]> fa,\n+                                       IntFunction<MemorySegment> fb,\n+                                       ByteOrder bo) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb);\n+        MemorySegment r = fb.apply((int) a.byteSize());\n@@ -527,1 +464,1 @@\n-        int l = a.limit();\n+        int l = (int) a.byteSize();\n@@ -532,2 +469,2 @@\n-                ShortVector av = ShortVector.fromByteBuffer(SPECIES, a, i, bo);\n-                av.intoByteBuffer(r, i, bo);\n+                ShortVector av = ShortVector.fromMemorySegment(SPECIES, a, i, bo);\n+                av.intoMemorySegment(r, i, bo);\n@@ -536,5 +473,2 @@\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        Assert.assertEquals(r, a, \"Buffers not equal\");\n+        long m = r.mismatch(a);\n+        Assert.assertEquals(m, -1, \"Segments not equal\");\n@@ -544,3 +478,3 @@\n-    static void loadByteBufferIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n+    static void loadMemorySegmentIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n@@ -548,1 +482,1 @@\n-        int l = a.limit();\n+        int l = (int) a.byteSize();\n@@ -553,2 +487,2 @@\n-                ShortVector av = fromByteBuffer(a, i, ByteOrder.nativeOrder());\n-                av.intoByteBuffer(r, i, ByteOrder.nativeOrder());\n+                ShortVector av = fromMemorySegment(a, i, ByteOrder.nativeOrder());\n+                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n@@ -558,2 +492,2 @@\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.limit());\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());\n@@ -561,1 +495,1 @@\n-            fromByteBuffer(a, index, ByteOrder.nativeOrder());\n+            fromMemorySegment(a, index, ByteOrder.nativeOrder());\n@@ -573,3 +507,3 @@\n-    static void storeByteBufferIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n+    static void storeMemorySegmentIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n@@ -577,1 +511,1 @@\n-        int l = a.limit();\n+        int l = (int) a.byteSize();\n@@ -582,2 +516,2 @@\n-                ShortVector av = ShortVector.fromByteBuffer(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteBuffer(av, r, i, ByteOrder.nativeOrder());\n+                ShortVector av = ShortVector.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+                intoMemorySegment(av, r, i, ByteOrder.nativeOrder());\n@@ -587,2 +521,2 @@\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.limit());\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());\n@@ -590,2 +524,2 @@\n-            ShortVector av = ShortVector.fromByteBuffer(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteBuffer(av, r, index, ByteOrder.nativeOrder());\n+            ShortVector av = ShortVector.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+            intoMemorySegment(av, r, index, ByteOrder.nativeOrder());\n@@ -602,6 +536,5 @@\n-\n-    @Test(dataProvider = \"shortByteBufferMaskProvider\")\n-    static void loadStoreByteBufferMask(IntFunction<short[]> fa,\n-                                        IntFunction<ByteBuffer> fb,\n-                                        IntFunction<boolean[]> fm,\n-                                        ByteOrder bo) {\n+    @Test(dataProvider = \"shortMemorySegmentMaskProvider\")\n+    static void loadStoreMemorySegmentMask(IntFunction<short[]> fa,\n+                                           IntFunction<MemorySegment> fb,\n+                                           IntFunction<boolean[]> fm,\n+                                           ByteOrder bo) {\n@@ -609,2 +542,2 @@\n-        ByteBuffer a = toBuffer(_a, fb);\n-        ByteBuffer r = fb.apply(a.limit());\n+        MemorySegment a = toSegment(_a, fb);\n+        MemorySegment r = fb.apply((int) a.byteSize());\n@@ -614,1 +547,1 @@\n-        int l = a.limit();\n+        int l = (int) a.byteSize();\n@@ -619,2 +552,2 @@\n-                ShortVector av = ShortVector.fromByteBuffer(SPECIES, a, i, bo, vmask);\n-                av.intoByteBuffer(r, i, bo);\n+                ShortVector av = ShortVector.fromMemorySegment(SPECIES, a, i, bo, vmask);\n+                av.intoMemorySegment(r, i, bo);\n@@ -623,5 +556,1 @@\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        assertArraysEquals(bufferToArray(r), _a, mask);\n+        assertArraysEquals(segmentToArray(r), _a, mask);\n@@ -630,1 +559,1 @@\n-        r = fb.apply(a.limit());\n+        r = fb.apply((int) a.byteSize());\n@@ -634,2 +563,2 @@\n-                ShortVector av = ShortVector.fromByteBuffer(SPECIES, a, i, bo);\n-                av.intoByteBuffer(r, i, bo, vmask);\n+                ShortVector av = ShortVector.fromMemorySegment(SPECIES, a, i, bo);\n+                av.intoMemorySegment(r, i, bo, vmask);\n@@ -638,5 +567,1 @@\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        assertArraysEquals(bufferToArray(r), _a, mask);\n+        assertArraysEquals(segmentToArray(r), _a, mask);\n@@ -646,3 +571,3 @@\n-    static void loadByteBufferMaskIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n+    static void loadMemorySegmentMaskIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n@@ -652,1 +577,1 @@\n-        int l = a.limit();\n+        int l = (int) a.byteSize();\n@@ -657,2 +582,2 @@\n-                ShortVector av = fromByteBuffer(a, i, ByteOrder.nativeOrder(), vmask);\n-                av.intoByteBuffer(r, i, ByteOrder.nativeOrder());\n+                ShortVector av = fromMemorySegment(a, i, ByteOrder.nativeOrder(), vmask);\n+                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n@@ -662,2 +587,2 @@\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.limit(), SPECIES.elementSize() \/ 8);\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() \/ 8);\n@@ -665,1 +590,1 @@\n-            fromByteBuffer(a, index, ByteOrder.nativeOrder(), vmask);\n+            fromMemorySegment(a, index, ByteOrder.nativeOrder(), vmask);\n@@ -677,3 +602,3 @@\n-    static void storeByteBufferMaskIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n+    static void storeMemorySegmentMaskIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n@@ -683,83 +608,1 @@\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ShortVector av = ShortVector.fromByteBuffer(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteBuffer(av, r, i, ByteOrder.nativeOrder(), vmask);\n-            }\n-        }\n-\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.limit(), SPECIES.elementSize() \/ 8);\n-        try {\n-            ShortVector av = ShortVector.fromByteBuffer(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteBuffer(av, a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"shortByteBufferProvider\")\n-    static void loadStoreReadonlyByteBuffer(IntFunction<short[]> fa,\n-                                    IntFunction<ByteBuffer> fb,\n-                                    ByteOrder bo) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), fb).asReadOnlyBuffer();\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo);\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, SPECIES.maskAll(true));\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, SPECIES.maskAll(false));\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            VectorMask<Short> m = SPECIES.shuffleFromOp(i -> i % 2 == 0 ? 1 : -1)\n-                    .laneIsValid();\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, m);\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"shortByteArrayProvider\")\n-    static void loadStoreByteArray(IntFunction<short[]> fa,\n-                                    ByteOrder bo) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, bo);\n-        byte[] r = new byte[a.length];\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ShortVector av = ShortVector.fromByteArray(SPECIES, a, i, bo);\n-                av.intoByteArray(r, i, bo);\n-            }\n-        }\n-        Assert.assertEquals(r, a, \"Byte arrays not equal\");\n-    }\n-\n-    @Test(dataProvider = \"shortByteProviderForIOOBE\")\n-    static void loadByteArrayIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-\n+        int l = (int) a.byteSize();\n@@ -767,1 +610,0 @@\n-        int l = a.length;\n@@ -771,2 +613,2 @@\n-                ShortVector av = fromByteArray(a, i, ByteOrder.nativeOrder());\n-                av.intoByteArray(r, i, ByteOrder.nativeOrder());\n+                ShortVector av = ShortVector.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+                intoMemorySegment(av, r, i, ByteOrder.nativeOrder(), vmask);\n@@ -776,2 +618,2 @@\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.length);\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() \/ 8);\n@@ -779,1 +621,2 @@\n-            fromByteArray(a, index, ByteOrder.nativeOrder());\n+            ShortVector av = ShortVector.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+            intoMemorySegment(av, a, index, ByteOrder.nativeOrder(), vmask);\n@@ -790,62 +633,5 @@\n-    @Test(dataProvider = \"shortByteProviderForIOOBE\")\n-    static void storeByteArrayIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ShortVector av = ShortVector.fromByteArray(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteArray(av, r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.length);\n-        try {\n-            ShortVector av = ShortVector.fromByteArray(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteArray(av, r, index, ByteOrder.nativeOrder());\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"shortByteArrayMaskProvider\")\n-    static void loadStoreByteArrayMask(IntFunction<short[]> fa,\n-                                  IntFunction<boolean[]> fm,\n-                                  ByteOrder bo) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, bo);\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Short> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-          for (int i = 0; i < l; i += s) {\n-              ShortVector av = ShortVector.fromByteArray(SPECIES, a, i, bo, vmask);\n-              av.intoByteArray(r, i, bo);\n-          }\n-        }\n-        assertArraysEquals(r, a, mask);\n-\n-\n-        r = new byte[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ShortVector av = ShortVector.fromByteArray(SPECIES, a, i, bo);\n-                av.intoByteArray(r, i, bo, vmask);\n-            }\n-        }\n-        assertArraysEquals(r, a, mask);\n-    }\n+    @Test(dataProvider = \"shortMemorySegmentProvider\")\n+    static void loadStoreReadonlyMemorySegment(IntFunction<short[]> fa,\n+                                               IntFunction<MemorySegment> fb,\n+                                               ByteOrder bo) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb).asReadOnly();\n@@ -853,6 +639,4 @@\n-    @Test(dataProvider = \"shortByteMaskProviderForIOOBE\")\n-    static void loadByteArrayMaskIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Short> vmask = VectorMask.fromValues(SPECIES, mask);\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo)\n+        );\n@@ -860,2 +644,4 @@\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(true))\n+        );\n@@ -863,6 +649,4 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ShortVector av = fromByteArray(a, i, ByteOrder.nativeOrder(), vmask);\n-                av.intoByteArray(r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(false))\n+        );\n@@ -870,12 +654,6 @@\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length, SPECIES.elementSize() \/ 8);\n-        try {\n-            fromByteArray(a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n+        VectorMask<Short> m = SPECIES.shuffleFromOp(i -> i % 2 == 0 ? 1 : -1)\n+                .laneIsValid();\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, m)\n+        );\n@@ -884,31 +662,0 @@\n-    @Test(dataProvider = \"shortByteMaskProviderForIOOBE\")\n-    static void storeByteArrayMaskIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Short> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ShortVector av = ShortVector.fromByteArray(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteArray(av, r, i, ByteOrder.nativeOrder(), vmask);\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length, SPECIES.elementSize() \/ 8);\n-        try {\n-            ShortVector av = ShortVector.fromByteArray(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteArray(av, a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n@@ -930,0 +677,1 @@\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short512VectorLoadStoreTests.java","additions":112,"deletions":364,"binary":false,"changes":476,"status":"modified"},{"patch":"@@ -264,0 +264,49 @@\n+    static void assertcompressArraysEquals(short[] r, short[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    Assert.assertEquals(r[i + k], (short)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (short)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals(short[] r, short[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        Assert.assertEquals(r[i + j], (short)0);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (short)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n@@ -887,1 +936,0 @@\n-\n@@ -982,2 +1030,0 @@\n-\n-\n@@ -1059,1 +1105,0 @@\n-\n@@ -1200,0 +1245,16 @@\n+    static short TRAILING_ZEROS_COUNT_scalar(short a) {\n+        return (short) (a != 0 ? Integer.numberOfTrailingZeros(a) : 16);\n+    }\n+\n+    static short LEADING_ZEROS_COUNT_scalar(short a) {\n+        return (short) (a >= 0 ? Integer.numberOfLeadingZeros(a) - 16 : 0);\n+    }\n+\n+    static short REVERSE_scalar(short a) {\n+        short b = ROL_scalar(a, (short) 8);\n+        b = (short) (((b & 0x5555) << 1) | ((b & 0xAAAA) >>> 1));\n+        b = (short) (((b & 0x3333) << 2) | ((b & 0xCCCC) >>> 2));\n+        b = (short) (((b & 0x0F0F) << 4) | ((b & 0xF0F0) >>> 4));\n+        return b;\n+    }\n+\n@@ -1349,0 +1410,1 @@\n+\n@@ -1369,0 +1431,1 @@\n+\n@@ -1425,0 +1488,1 @@\n+\n@@ -1445,0 +1509,1 @@\n+\n@@ -1501,0 +1566,1 @@\n+\n@@ -1521,0 +1587,1 @@\n+\n@@ -1578,2 +1645,0 @@\n-\n-\n@@ -1602,0 +1667,1 @@\n+\n@@ -1625,2 +1691,0 @@\n-\n-\n@@ -1732,0 +1796,1 @@\n+\n@@ -1751,2 +1816,0 @@\n-\n-\n@@ -1773,1 +1836,0 @@\n-\n@@ -1795,2 +1857,0 @@\n-\n-\n@@ -1817,1 +1877,0 @@\n-\n@@ -1838,0 +1897,1 @@\n+\n@@ -1857,2 +1917,0 @@\n-\n-\n@@ -1879,1 +1937,0 @@\n-\n@@ -1901,2 +1958,0 @@\n-\n-\n@@ -1923,1 +1978,0 @@\n-\n@@ -2017,3 +2071,0 @@\n-\n-\n-\n@@ -2036,2 +2087,0 @@\n-\n-\n@@ -2057,2 +2106,0 @@\n-\n-\n@@ -2087,2 +2134,0 @@\n-\n-\n@@ -2106,2 +2151,0 @@\n-\n-\n@@ -2136,2 +2179,0 @@\n-\n-\n@@ -2155,2 +2196,0 @@\n-\n-\n@@ -2171,2 +2210,0 @@\n-\n-\n@@ -2190,1 +2227,0 @@\n-\n@@ -2222,4 +2258,0 @@\n-\n-\n-\n-\n@@ -2247,2 +2279,0 @@\n-\n-\n@@ -2269,5 +2299,0 @@\n-\n-\n-\n-\n-\n@@ -2295,2 +2320,0 @@\n-\n-\n@@ -2317,5 +2340,0 @@\n-\n-\n-\n-\n-\n@@ -2343,2 +2361,0 @@\n-\n-\n@@ -2365,5 +2381,0 @@\n-\n-\n-\n-\n-\n@@ -2390,2 +2401,0 @@\n-\n-\n@@ -2411,5 +2420,0 @@\n-\n-\n-\n-\n-\n@@ -2436,2 +2440,0 @@\n-\n-\n@@ -2457,5 +2459,0 @@\n-\n-\n-\n-\n-\n@@ -2482,2 +2479,0 @@\n-\n-\n@@ -2503,1 +2498,0 @@\n-\n@@ -2525,2 +2519,0 @@\n-\n-\n@@ -2547,1 +2539,0 @@\n-\n@@ -2569,2 +2560,0 @@\n-\n-\n@@ -2591,1 +2580,0 @@\n-\n@@ -2612,2 +2600,0 @@\n-\n-\n@@ -2633,1 +2619,0 @@\n-\n@@ -2654,2 +2639,0 @@\n-\n-\n@@ -2674,6 +2657,0 @@\n-\n-\n-\n-\n-\n-\n@@ -2699,2 +2676,0 @@\n-\n-\n@@ -2719,2 +2694,0 @@\n-\n-\n@@ -2740,2 +2713,0 @@\n-\n-\n@@ -2760,2 +2731,0 @@\n-\n-\n@@ -2781,2 +2750,0 @@\n-\n-\n@@ -2801,2 +2768,0 @@\n-\n-\n@@ -2822,2 +2787,0 @@\n-\n-\n@@ -2842,2 +2805,0 @@\n-\n-\n@@ -2863,2 +2824,0 @@\n-\n-\n@@ -2904,0 +2863,1 @@\n+\n@@ -2922,0 +2882,1 @@\n+\n@@ -2942,0 +2903,1 @@\n+\n@@ -3035,1 +2997,0 @@\n-\n@@ -3061,1 +3022,0 @@\n-\n@@ -3081,1 +3041,0 @@\n-\n@@ -3109,1 +3068,0 @@\n-\n@@ -3128,1 +3086,0 @@\n-\n@@ -3154,1 +3111,0 @@\n-\n@@ -3174,1 +3130,0 @@\n-\n@@ -3202,1 +3157,0 @@\n-\n@@ -3221,1 +3175,0 @@\n-\n@@ -3247,1 +3200,0 @@\n-\n@@ -3267,1 +3219,0 @@\n-\n@@ -3312,0 +3263,1 @@\n+\n@@ -3336,0 +3288,1 @@\n+\n@@ -3354,0 +3307,1 @@\n+\n@@ -3380,0 +3334,1 @@\n+\n@@ -3397,0 +3352,1 @@\n+\n@@ -3421,0 +3377,1 @@\n+\n@@ -3439,0 +3396,1 @@\n+\n@@ -3465,0 +3423,1 @@\n+\n@@ -3482,0 +3441,1 @@\n+\n@@ -3506,0 +3466,1 @@\n+\n@@ -3524,0 +3485,1 @@\n+\n@@ -3550,0 +3512,1 @@\n+\n@@ -3567,0 +3530,1 @@\n+\n@@ -3591,0 +3555,1 @@\n+\n@@ -3609,0 +3574,1 @@\n+\n@@ -3635,0 +3601,1 @@\n+\n@@ -3652,0 +3619,1 @@\n+\n@@ -3676,0 +3644,1 @@\n+\n@@ -3694,0 +3663,1 @@\n+\n@@ -3730,1 +3700,0 @@\n-\n@@ -3746,1 +3715,0 @@\n-\n@@ -3756,1 +3724,0 @@\n-\n@@ -3772,1 +3739,0 @@\n-\n@@ -3790,0 +3756,1 @@\n+\n@@ -3830,0 +3797,1 @@\n+\n@@ -3871,3 +3839,0 @@\n-\n-\n-\n@@ -3893,1 +3858,0 @@\n-\n@@ -3936,1 +3900,0 @@\n-\n@@ -3979,1 +3942,0 @@\n-\n@@ -3999,1 +3961,0 @@\n-\n@@ -4042,1 +4003,0 @@\n-\n@@ -4085,1 +4045,0 @@\n-\n@@ -4128,1 +4087,0 @@\n-\n@@ -4171,2 +4129,0 @@\n-\n-\n@@ -4192,2 +4148,0 @@\n-\n-\n@@ -4217,3 +4171,0 @@\n-\n-\n-\n@@ -4239,2 +4190,0 @@\n-\n-\n@@ -4264,3 +4213,0 @@\n-\n-\n-\n@@ -4286,2 +4232,0 @@\n-\n-\n@@ -4311,3 +4255,0 @@\n-\n-\n-\n@@ -4333,2 +4274,0 @@\n-\n-\n@@ -4358,2 +4297,0 @@\n-\n-\n@@ -4376,1 +4313,0 @@\n-\n@@ -4413,1 +4349,0 @@\n-\n@@ -4450,1 +4385,0 @@\n-\n@@ -4487,1 +4421,0 @@\n-\n@@ -4566,0 +4499,37 @@\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void compressShort512VectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.compress(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertcompressArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void expandShort512VectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.expand(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertexpandArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n@@ -4736,4 +4706,0 @@\n-\n-\n-\n-\n@@ -4754,3 +4720,0 @@\n-\n-\n-\n@@ -4782,0 +4745,1 @@\n+\n@@ -4811,0 +4775,1 @@\n+\n@@ -4844,0 +4809,1 @@\n+\n@@ -4871,0 +4837,1 @@\n+\n@@ -4910,0 +4877,1 @@\n+\n@@ -4967,22 +4935,0 @@\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n@@ -4992,0 +4938,1 @@\n+\n@@ -4996,1 +4943,0 @@\n-\n@@ -5015,0 +4961,1 @@\n+\n@@ -5032,1 +4979,0 @@\n-\n@@ -5055,3 +5001,0 @@\n-\n-\n-\n@@ -5087,0 +5030,1 @@\n+\n@@ -5117,1 +5061,0 @@\n-\n@@ -5156,3 +5099,0 @@\n-\n-\n-\n@@ -5173,0 +5113,1 @@\n+\n@@ -5188,1 +5129,0 @@\n-\n@@ -5207,1 +5147,0 @@\n-\n@@ -5320,1 +5259,0 @@\n-\n@@ -5329,2 +5267,0 @@\n-\n-\n@@ -5361,2 +5297,0 @@\n-\n-\n@@ -5381,2 +5315,0 @@\n-\n-\n@@ -5387,2 +5319,0 @@\n-\n-\n@@ -5404,2 +5334,0 @@\n-\n-\n@@ -5424,0 +5352,151 @@\n+    static short BIT_COUNT(short a) {\n+        return (short)(Integer.bitCount((int)a & 0xFFFF));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void BIT_COUNTShort512VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Short512VectorTests::BIT_COUNT);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void BIT_COUNTMaskedShort512VectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Short512VectorTests::BIT_COUNT);\n+    }\n+\n+    static short TRAILING_ZEROS_COUNT(short a) {\n+        return (short)(TRAILING_ZEROS_COUNT_scalar(a));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void TRAILING_ZEROS_COUNTShort512VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TRAILING_ZEROS_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Short512VectorTests::TRAILING_ZEROS_COUNT);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void TRAILING_ZEROS_COUNTMaskedShort512VectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TRAILING_ZEROS_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Short512VectorTests::TRAILING_ZEROS_COUNT);\n+    }\n+\n+    static short LEADING_ZEROS_COUNT(short a) {\n+        return (short)(LEADING_ZEROS_COUNT_scalar(a));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void LEADING_ZEROS_COUNTShort512VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LEADING_ZEROS_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Short512VectorTests::LEADING_ZEROS_COUNT);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void LEADING_ZEROS_COUNTMaskedShort512VectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LEADING_ZEROS_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Short512VectorTests::LEADING_ZEROS_COUNT);\n+    }\n+\n+    static short REVERSE(short a) {\n+        return (short)(REVERSE_scalar(a));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void REVERSEShort512VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Short512VectorTests::REVERSE);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void REVERSEMaskedShort512VectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Short512VectorTests::REVERSE);\n+    }\n+\n+    static short REVERSE_BYTES(short a) {\n+        return (short)(Short.reverseBytes(a));\n+    }\n@@ -5425,0 +5504,4 @@\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void REVERSE_BYTESShort512VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n@@ -5426,0 +5509,6 @@\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES).intoArray(r, i);\n+            }\n+        }\n@@ -5427,0 +5516,20 @@\n+        assertArraysEquals(r, a, Short512VectorTests::REVERSE_BYTES);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void REVERSE_BYTESMaskedShort512VectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Short512VectorTests::REVERSE_BYTES);\n+    }\n@@ -5829,0 +5938,17 @@\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCompressShort512VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        int trueCount = 0;\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                trueCount = vmask.trueCount();\n+                var rmask = vmask.compress();\n+                for (int j = 0; j < SPECIES.length(); j++)  {\n+                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);\n+                }\n+            }\n+        }\n+    }\n+\n@@ -5871,0 +5997,14 @@\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeLongShort512VectorTestsSmokeTest(int offset) {\n+        long limit = SPECIES.length() * BUFFER_REPS;\n+        for (long i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i + offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                long index = i + j + offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n@@ -5891,0 +6031,8 @@\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundLongShort512VectorTestsSmokeTest(int _length) {\n+        long length = _length;\n+        long actualLoopBound = SPECIES.loopBound(length);\n+        long expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+    }\n+\n@@ -5953,1 +6101,0 @@\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short512VectorTests.java","additions":364,"deletions":217,"binary":false,"changes":581,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,3 @@\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.ValueLayout;\n@@ -42,2 +45,0 @@\n-import java.nio.ByteBuffer;\n-import java.nio.ShortBuffer;\n@@ -45,1 +46,0 @@\n-import java.nio.ReadOnlyBufferException;\n@@ -70,11 +70,0 @@\n-    static void assertArraysEquals(byte[] r, byte[] a, boolean[] mask) {\n-        int i = 0;\n-        try {\n-            for (; i < a.length; i++) {\n-                Assert.assertEquals(r[i], mask[(i*8\/SPECIES.elementSize()) % SPECIES.length()] ? a[i] : (byte) 0);\n-            }\n-        } catch (AssertionError e) {\n-            Assert.assertEquals(r[i], mask[(i*8\/SPECIES.elementSize()) % SPECIES.length()] ? a[i] : (byte) 0, \"at index #\" + i);\n-        }\n-    }\n-\n@@ -120,1 +109,1 @@\n-    \/\/ Relative to byte[] array.length or ByteBuffer.limit()\n+    \/\/ Relative to byte[] array.length or MemorySegment.byteSize()\n@@ -191,1 +180,1 @@\n-    public Object[][] shortByteBufferProvider() {\n+    public Object[][] shortMemorySegmentProvider() {\n@@ -193,1 +182,1 @@\n-                flatMap(fa -> BYTE_BUFFER_GENERATORS.stream().\n+                flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n@@ -201,1 +190,1 @@\n-    public Object[][] shortByteBufferMaskProvider() {\n+    public Object[][] shortMemorySegmentMaskProvider() {\n@@ -204,1 +193,1 @@\n-                        flatMap(fa -> BYTE_BUFFER_GENERATORS.stream().\n+                        flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n@@ -211,19 +200,0 @@\n-    @DataProvider\n-    public Object[][] shortByteArrayProvider() {\n-        return SHORT_GENERATORS.stream().\n-                flatMap(fa -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                    return new Object[]{fa, bo};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] shortByteArrayMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> SHORT_GENERATORS.stream().\n-                    flatMap(fa -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                        return new Object[]{fa, fm, bo};\n-                    }))).\n-                toArray(Object[][]::new);\n-    }\n-\n@@ -249,4 +219,4 @@\n-    static ByteBuffer toBuffer(short[] a, IntFunction<ByteBuffer> fb) {\n-        ByteBuffer bb = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n-        for (short v : a) {\n-            bb.putShort(v);\n+    static MemorySegment toSegment(short[] a, IntFunction<MemorySegment> fb) {\n+        MemorySegment ms = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n+        for (int i = 0; i < a.length; i++) {\n+            ms.set(ValueLayout.JAVA_SHORT, i * SPECIES.elementSize() \/ 8 , a[i]);\n@@ -254,1 +224,1 @@\n-        return bb.clear();\n+        return ms;\n@@ -257,14 +227,2 @@\n-    static short[] bufferToArray(ByteBuffer bb) {\n-        ShortBuffer db = bb.asShortBuffer();\n-        short[] d = new short[db.capacity()];\n-        db.get(0, d);\n-        return d;\n-    }\n-\n-    static byte[] toByteArray(short[] a, IntFunction<byte[]> fb, ByteOrder bo) {\n-        byte[] b = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n-        ShortBuffer bb = ByteBuffer.wrap(b, 0, b.length).order(bo).asShortBuffer();\n-        for (short v : a) {\n-            bb.put(v);\n-        }\n-        return b;\n+    static short[] segmentToArray(MemorySegment ms) {\n+        return ms.toArray(ValueLayout.JAVA_SHORT);\n@@ -310,22 +268,2 @@\n-    static ShortVector fromByteArray(byte[] a, int i, ByteOrder bo) {\n-        return ShortVector.fromByteArray(SPECIES, a, i, bo);\n-    }\n-\n-    @DontInline\n-    static ShortVector fromByteArray(byte[] a, int i, ByteOrder bo, VectorMask<Short> m) {\n-        return ShortVector.fromByteArray(SPECIES, a, i, bo, m);\n-    }\n-\n-    @DontInline\n-    static void intoByteArray(ShortVector v, byte[] a, int i, ByteOrder bo) {\n-        v.intoByteArray(a, i, bo);\n-    }\n-\n-    @DontInline\n-    static void intoByteArray(ShortVector v, byte[] a, int i, ByteOrder bo, VectorMask<Short> m) {\n-        v.intoByteArray(a, i, bo, m);\n-    }\n-\n-    @DontInline\n-    static ShortVector fromByteBuffer(ByteBuffer a, int i, ByteOrder bo) {\n-        return ShortVector.fromByteBuffer(SPECIES, a, i, bo);\n+    static ShortVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo) {\n+        return ShortVector.fromMemorySegment(SPECIES, a, i, bo);\n@@ -335,2 +273,2 @@\n-    static ShortVector fromByteBuffer(ByteBuffer a, int i, ByteOrder bo, VectorMask<Short> m) {\n-        return ShortVector.fromByteBuffer(SPECIES, a, i, bo, m);\n+    static ShortVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo, VectorMask<Short> m) {\n+        return ShortVector.fromMemorySegment(SPECIES, a, i, bo, m);\n@@ -340,2 +278,2 @@\n-    static void intoByteBuffer(ShortVector v, ByteBuffer a, int i, ByteOrder bo) {\n-        v.intoByteBuffer(a, i, bo);\n+    static void intoMemorySegment(ShortVector v, MemorySegment a, int i, ByteOrder bo) {\n+        v.intoMemorySegment(a, i, bo);\n@@ -345,2 +283,2 @@\n-    static void intoByteBuffer(ShortVector v, ByteBuffer a, int i, ByteOrder bo, VectorMask<Short> m) {\n-        v.intoByteBuffer(a, i, bo, m);\n+    static void intoMemorySegment(ShortVector v, MemorySegment a, int i, ByteOrder bo, VectorMask<Short> m) {\n+        v.intoMemorySegment(a, i, bo, m);\n@@ -349,1 +287,0 @@\n-\n@@ -520,6 +457,6 @@\n-    @Test(dataProvider = \"shortByteBufferProvider\")\n-    static void loadStoreByteBuffer(IntFunction<short[]> fa,\n-                                    IntFunction<ByteBuffer> fb,\n-                                    ByteOrder bo) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), fb);\n-        ByteBuffer r = fb.apply(a.limit());\n+    @Test(dataProvider = \"shortMemorySegmentProvider\")\n+    static void loadStoreMemorySegment(IntFunction<short[]> fa,\n+                                       IntFunction<MemorySegment> fb,\n+                                       ByteOrder bo) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb);\n+        MemorySegment r = fb.apply((int) a.byteSize());\n@@ -527,1 +464,1 @@\n-        int l = a.limit();\n+        int l = (int) a.byteSize();\n@@ -532,2 +469,2 @@\n-                ShortVector av = ShortVector.fromByteBuffer(SPECIES, a, i, bo);\n-                av.intoByteBuffer(r, i, bo);\n+                ShortVector av = ShortVector.fromMemorySegment(SPECIES, a, i, bo);\n+                av.intoMemorySegment(r, i, bo);\n@@ -536,5 +473,2 @@\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        Assert.assertEquals(r, a, \"Buffers not equal\");\n+        long m = r.mismatch(a);\n+        Assert.assertEquals(m, -1, \"Segments not equal\");\n@@ -544,3 +478,3 @@\n-    static void loadByteBufferIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n+    static void loadMemorySegmentIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n@@ -548,1 +482,1 @@\n-        int l = a.limit();\n+        int l = (int) a.byteSize();\n@@ -553,2 +487,2 @@\n-                ShortVector av = fromByteBuffer(a, i, ByteOrder.nativeOrder());\n-                av.intoByteBuffer(r, i, ByteOrder.nativeOrder());\n+                ShortVector av = fromMemorySegment(a, i, ByteOrder.nativeOrder());\n+                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n@@ -558,2 +492,2 @@\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.limit());\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());\n@@ -561,1 +495,1 @@\n-            fromByteBuffer(a, index, ByteOrder.nativeOrder());\n+            fromMemorySegment(a, index, ByteOrder.nativeOrder());\n@@ -573,3 +507,3 @@\n-    static void storeByteBufferIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n+    static void storeMemorySegmentIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n@@ -577,1 +511,1 @@\n-        int l = a.limit();\n+        int l = (int) a.byteSize();\n@@ -582,2 +516,2 @@\n-                ShortVector av = ShortVector.fromByteBuffer(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteBuffer(av, r, i, ByteOrder.nativeOrder());\n+                ShortVector av = ShortVector.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+                intoMemorySegment(av, r, i, ByteOrder.nativeOrder());\n@@ -587,2 +521,2 @@\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.limit());\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());\n@@ -590,2 +524,2 @@\n-            ShortVector av = ShortVector.fromByteBuffer(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteBuffer(av, r, index, ByteOrder.nativeOrder());\n+            ShortVector av = ShortVector.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+            intoMemorySegment(av, r, index, ByteOrder.nativeOrder());\n@@ -602,6 +536,5 @@\n-\n-    @Test(dataProvider = \"shortByteBufferMaskProvider\")\n-    static void loadStoreByteBufferMask(IntFunction<short[]> fa,\n-                                        IntFunction<ByteBuffer> fb,\n-                                        IntFunction<boolean[]> fm,\n-                                        ByteOrder bo) {\n+    @Test(dataProvider = \"shortMemorySegmentMaskProvider\")\n+    static void loadStoreMemorySegmentMask(IntFunction<short[]> fa,\n+                                           IntFunction<MemorySegment> fb,\n+                                           IntFunction<boolean[]> fm,\n+                                           ByteOrder bo) {\n@@ -609,2 +542,2 @@\n-        ByteBuffer a = toBuffer(_a, fb);\n-        ByteBuffer r = fb.apply(a.limit());\n+        MemorySegment a = toSegment(_a, fb);\n+        MemorySegment r = fb.apply((int) a.byteSize());\n@@ -614,1 +547,1 @@\n-        int l = a.limit();\n+        int l = (int) a.byteSize();\n@@ -619,2 +552,2 @@\n-                ShortVector av = ShortVector.fromByteBuffer(SPECIES, a, i, bo, vmask);\n-                av.intoByteBuffer(r, i, bo);\n+                ShortVector av = ShortVector.fromMemorySegment(SPECIES, a, i, bo, vmask);\n+                av.intoMemorySegment(r, i, bo);\n@@ -623,5 +556,1 @@\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        assertArraysEquals(bufferToArray(r), _a, mask);\n+        assertArraysEquals(segmentToArray(r), _a, mask);\n@@ -630,1 +559,1 @@\n-        r = fb.apply(a.limit());\n+        r = fb.apply((int) a.byteSize());\n@@ -634,2 +563,2 @@\n-                ShortVector av = ShortVector.fromByteBuffer(SPECIES, a, i, bo);\n-                av.intoByteBuffer(r, i, bo, vmask);\n+                ShortVector av = ShortVector.fromMemorySegment(SPECIES, a, i, bo);\n+                av.intoMemorySegment(r, i, bo, vmask);\n@@ -638,5 +567,1 @@\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        assertArraysEquals(bufferToArray(r), _a, mask);\n+        assertArraysEquals(segmentToArray(r), _a, mask);\n@@ -646,3 +571,3 @@\n-    static void loadByteBufferMaskIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n+    static void loadMemorySegmentMaskIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n@@ -652,1 +577,1 @@\n-        int l = a.limit();\n+        int l = (int) a.byteSize();\n@@ -657,2 +582,2 @@\n-                ShortVector av = fromByteBuffer(a, i, ByteOrder.nativeOrder(), vmask);\n-                av.intoByteBuffer(r, i, ByteOrder.nativeOrder());\n+                ShortVector av = fromMemorySegment(a, i, ByteOrder.nativeOrder(), vmask);\n+                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n@@ -662,2 +587,2 @@\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.limit(), SPECIES.elementSize() \/ 8);\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() \/ 8);\n@@ -665,1 +590,1 @@\n-            fromByteBuffer(a, index, ByteOrder.nativeOrder(), vmask);\n+            fromMemorySegment(a, index, ByteOrder.nativeOrder(), vmask);\n@@ -677,3 +602,3 @@\n-    static void storeByteBufferMaskIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n+    static void storeMemorySegmentMaskIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n@@ -683,83 +608,1 @@\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ShortVector av = ShortVector.fromByteBuffer(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteBuffer(av, r, i, ByteOrder.nativeOrder(), vmask);\n-            }\n-        }\n-\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.limit(), SPECIES.elementSize() \/ 8);\n-        try {\n-            ShortVector av = ShortVector.fromByteBuffer(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteBuffer(av, a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"shortByteBufferProvider\")\n-    static void loadStoreReadonlyByteBuffer(IntFunction<short[]> fa,\n-                                    IntFunction<ByteBuffer> fb,\n-                                    ByteOrder bo) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), fb).asReadOnlyBuffer();\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo);\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, SPECIES.maskAll(true));\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, SPECIES.maskAll(false));\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            VectorMask<Short> m = SPECIES.shuffleFromOp(i -> i % 2 == 0 ? 1 : -1)\n-                    .laneIsValid();\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, m);\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"shortByteArrayProvider\")\n-    static void loadStoreByteArray(IntFunction<short[]> fa,\n-                                    ByteOrder bo) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, bo);\n-        byte[] r = new byte[a.length];\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ShortVector av = ShortVector.fromByteArray(SPECIES, a, i, bo);\n-                av.intoByteArray(r, i, bo);\n-            }\n-        }\n-        Assert.assertEquals(r, a, \"Byte arrays not equal\");\n-    }\n-\n-    @Test(dataProvider = \"shortByteProviderForIOOBE\")\n-    static void loadByteArrayIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-\n+        int l = (int) a.byteSize();\n@@ -767,1 +610,0 @@\n-        int l = a.length;\n@@ -771,2 +613,2 @@\n-                ShortVector av = fromByteArray(a, i, ByteOrder.nativeOrder());\n-                av.intoByteArray(r, i, ByteOrder.nativeOrder());\n+                ShortVector av = ShortVector.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+                intoMemorySegment(av, r, i, ByteOrder.nativeOrder(), vmask);\n@@ -776,2 +618,2 @@\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.length);\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() \/ 8);\n@@ -779,1 +621,2 @@\n-            fromByteArray(a, index, ByteOrder.nativeOrder());\n+            ShortVector av = ShortVector.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+            intoMemorySegment(av, a, index, ByteOrder.nativeOrder(), vmask);\n@@ -790,62 +633,5 @@\n-    @Test(dataProvider = \"shortByteProviderForIOOBE\")\n-    static void storeByteArrayIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ShortVector av = ShortVector.fromByteArray(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteArray(av, r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.length);\n-        try {\n-            ShortVector av = ShortVector.fromByteArray(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteArray(av, r, index, ByteOrder.nativeOrder());\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"shortByteArrayMaskProvider\")\n-    static void loadStoreByteArrayMask(IntFunction<short[]> fa,\n-                                  IntFunction<boolean[]> fm,\n-                                  ByteOrder bo) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, bo);\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Short> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-          for (int i = 0; i < l; i += s) {\n-              ShortVector av = ShortVector.fromByteArray(SPECIES, a, i, bo, vmask);\n-              av.intoByteArray(r, i, bo);\n-          }\n-        }\n-        assertArraysEquals(r, a, mask);\n-\n-\n-        r = new byte[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ShortVector av = ShortVector.fromByteArray(SPECIES, a, i, bo);\n-                av.intoByteArray(r, i, bo, vmask);\n-            }\n-        }\n-        assertArraysEquals(r, a, mask);\n-    }\n+    @Test(dataProvider = \"shortMemorySegmentProvider\")\n+    static void loadStoreReadonlyMemorySegment(IntFunction<short[]> fa,\n+                                               IntFunction<MemorySegment> fb,\n+                                               ByteOrder bo) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb).asReadOnly();\n@@ -853,6 +639,4 @@\n-    @Test(dataProvider = \"shortByteMaskProviderForIOOBE\")\n-    static void loadByteArrayMaskIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Short> vmask = VectorMask.fromValues(SPECIES, mask);\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo)\n+        );\n@@ -860,2 +644,4 @@\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(true))\n+        );\n@@ -863,6 +649,4 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ShortVector av = fromByteArray(a, i, ByteOrder.nativeOrder(), vmask);\n-                av.intoByteArray(r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(false))\n+        );\n@@ -870,12 +654,6 @@\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length, SPECIES.elementSize() \/ 8);\n-        try {\n-            fromByteArray(a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n+        VectorMask<Short> m = SPECIES.shuffleFromOp(i -> i % 2 == 0 ? 1 : -1)\n+                .laneIsValid();\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, m)\n+        );\n@@ -884,31 +662,0 @@\n-    @Test(dataProvider = \"shortByteMaskProviderForIOOBE\")\n-    static void storeByteArrayMaskIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Short> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ShortVector av = ShortVector.fromByteArray(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteArray(av, r, i, ByteOrder.nativeOrder(), vmask);\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length, SPECIES.elementSize() \/ 8);\n-        try {\n-            ShortVector av = ShortVector.fromByteArray(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteArray(av, a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n@@ -930,0 +677,1 @@\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short64VectorLoadStoreTests.java","additions":112,"deletions":364,"binary":false,"changes":476,"status":"modified"},{"patch":"@@ -264,0 +264,49 @@\n+    static void assertcompressArraysEquals(short[] r, short[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    Assert.assertEquals(r[i + k], (short)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (short)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals(short[] r, short[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        Assert.assertEquals(r[i + j], (short)0);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (short)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n@@ -887,1 +936,0 @@\n-\n@@ -982,2 +1030,0 @@\n-\n-\n@@ -1059,1 +1105,0 @@\n-\n@@ -1200,0 +1245,16 @@\n+    static short TRAILING_ZEROS_COUNT_scalar(short a) {\n+        return (short) (a != 0 ? Integer.numberOfTrailingZeros(a) : 16);\n+    }\n+\n+    static short LEADING_ZEROS_COUNT_scalar(short a) {\n+        return (short) (a >= 0 ? Integer.numberOfLeadingZeros(a) - 16 : 0);\n+    }\n+\n+    static short REVERSE_scalar(short a) {\n+        short b = ROL_scalar(a, (short) 8);\n+        b = (short) (((b & 0x5555) << 1) | ((b & 0xAAAA) >>> 1));\n+        b = (short) (((b & 0x3333) << 2) | ((b & 0xCCCC) >>> 2));\n+        b = (short) (((b & 0x0F0F) << 4) | ((b & 0xF0F0) >>> 4));\n+        return b;\n+    }\n+\n@@ -1349,0 +1410,1 @@\n+\n@@ -1369,0 +1431,1 @@\n+\n@@ -1425,0 +1488,1 @@\n+\n@@ -1445,0 +1509,1 @@\n+\n@@ -1501,0 +1566,1 @@\n+\n@@ -1521,0 +1587,1 @@\n+\n@@ -1578,2 +1645,0 @@\n-\n-\n@@ -1602,0 +1667,1 @@\n+\n@@ -1625,2 +1691,0 @@\n-\n-\n@@ -1732,0 +1796,1 @@\n+\n@@ -1751,2 +1816,0 @@\n-\n-\n@@ -1773,1 +1836,0 @@\n-\n@@ -1795,2 +1857,0 @@\n-\n-\n@@ -1817,1 +1877,0 @@\n-\n@@ -1838,0 +1897,1 @@\n+\n@@ -1857,2 +1917,0 @@\n-\n-\n@@ -1879,1 +1937,0 @@\n-\n@@ -1901,2 +1958,0 @@\n-\n-\n@@ -1923,1 +1978,0 @@\n-\n@@ -2017,3 +2071,0 @@\n-\n-\n-\n@@ -2036,2 +2087,0 @@\n-\n-\n@@ -2057,2 +2106,0 @@\n-\n-\n@@ -2087,2 +2134,0 @@\n-\n-\n@@ -2106,2 +2151,0 @@\n-\n-\n@@ -2136,2 +2179,0 @@\n-\n-\n@@ -2155,2 +2196,0 @@\n-\n-\n@@ -2171,2 +2210,0 @@\n-\n-\n@@ -2190,1 +2227,0 @@\n-\n@@ -2222,4 +2258,0 @@\n-\n-\n-\n-\n@@ -2247,2 +2279,0 @@\n-\n-\n@@ -2269,5 +2299,0 @@\n-\n-\n-\n-\n-\n@@ -2295,2 +2320,0 @@\n-\n-\n@@ -2317,5 +2340,0 @@\n-\n-\n-\n-\n-\n@@ -2343,2 +2361,0 @@\n-\n-\n@@ -2365,5 +2381,0 @@\n-\n-\n-\n-\n-\n@@ -2390,2 +2401,0 @@\n-\n-\n@@ -2411,5 +2420,0 @@\n-\n-\n-\n-\n-\n@@ -2436,2 +2440,0 @@\n-\n-\n@@ -2457,5 +2459,0 @@\n-\n-\n-\n-\n-\n@@ -2482,2 +2479,0 @@\n-\n-\n@@ -2503,1 +2498,0 @@\n-\n@@ -2525,2 +2519,0 @@\n-\n-\n@@ -2547,1 +2539,0 @@\n-\n@@ -2569,2 +2560,0 @@\n-\n-\n@@ -2591,1 +2580,0 @@\n-\n@@ -2612,2 +2600,0 @@\n-\n-\n@@ -2633,1 +2619,0 @@\n-\n@@ -2654,2 +2639,0 @@\n-\n-\n@@ -2674,6 +2657,0 @@\n-\n-\n-\n-\n-\n-\n@@ -2699,2 +2676,0 @@\n-\n-\n@@ -2719,2 +2694,0 @@\n-\n-\n@@ -2740,2 +2713,0 @@\n-\n-\n@@ -2760,2 +2731,0 @@\n-\n-\n@@ -2781,2 +2750,0 @@\n-\n-\n@@ -2801,2 +2768,0 @@\n-\n-\n@@ -2822,2 +2787,0 @@\n-\n-\n@@ -2842,2 +2805,0 @@\n-\n-\n@@ -2863,2 +2824,0 @@\n-\n-\n@@ -2904,0 +2863,1 @@\n+\n@@ -2922,0 +2882,1 @@\n+\n@@ -2942,0 +2903,1 @@\n+\n@@ -3035,1 +2997,0 @@\n-\n@@ -3061,1 +3022,0 @@\n-\n@@ -3081,1 +3041,0 @@\n-\n@@ -3109,1 +3068,0 @@\n-\n@@ -3128,1 +3086,0 @@\n-\n@@ -3154,1 +3111,0 @@\n-\n@@ -3174,1 +3130,0 @@\n-\n@@ -3202,1 +3157,0 @@\n-\n@@ -3221,1 +3175,0 @@\n-\n@@ -3247,1 +3200,0 @@\n-\n@@ -3267,1 +3219,0 @@\n-\n@@ -3312,0 +3263,1 @@\n+\n@@ -3336,0 +3288,1 @@\n+\n@@ -3354,0 +3307,1 @@\n+\n@@ -3380,0 +3334,1 @@\n+\n@@ -3397,0 +3352,1 @@\n+\n@@ -3421,0 +3377,1 @@\n+\n@@ -3439,0 +3396,1 @@\n+\n@@ -3465,0 +3423,1 @@\n+\n@@ -3482,0 +3441,1 @@\n+\n@@ -3506,0 +3466,1 @@\n+\n@@ -3524,0 +3485,1 @@\n+\n@@ -3550,0 +3512,1 @@\n+\n@@ -3567,0 +3530,1 @@\n+\n@@ -3591,0 +3555,1 @@\n+\n@@ -3609,0 +3574,1 @@\n+\n@@ -3635,0 +3601,1 @@\n+\n@@ -3652,0 +3619,1 @@\n+\n@@ -3676,0 +3644,1 @@\n+\n@@ -3694,0 +3663,1 @@\n+\n@@ -3730,1 +3700,0 @@\n-\n@@ -3746,1 +3715,0 @@\n-\n@@ -3756,1 +3724,0 @@\n-\n@@ -3772,1 +3739,0 @@\n-\n@@ -3790,0 +3756,1 @@\n+\n@@ -3830,0 +3797,1 @@\n+\n@@ -3871,3 +3839,0 @@\n-\n-\n-\n@@ -3893,1 +3858,0 @@\n-\n@@ -3936,1 +3900,0 @@\n-\n@@ -3979,1 +3942,0 @@\n-\n@@ -3999,1 +3961,0 @@\n-\n@@ -4042,1 +4003,0 @@\n-\n@@ -4085,1 +4045,0 @@\n-\n@@ -4128,1 +4087,0 @@\n-\n@@ -4171,2 +4129,0 @@\n-\n-\n@@ -4192,2 +4148,0 @@\n-\n-\n@@ -4217,3 +4171,0 @@\n-\n-\n-\n@@ -4239,2 +4190,0 @@\n-\n-\n@@ -4264,3 +4213,0 @@\n-\n-\n-\n@@ -4286,2 +4232,0 @@\n-\n-\n@@ -4311,3 +4255,0 @@\n-\n-\n-\n@@ -4333,2 +4274,0 @@\n-\n-\n@@ -4358,2 +4297,0 @@\n-\n-\n@@ -4376,1 +4313,0 @@\n-\n@@ -4413,1 +4349,0 @@\n-\n@@ -4450,1 +4385,0 @@\n-\n@@ -4487,1 +4421,0 @@\n-\n@@ -4566,0 +4499,37 @@\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void compressShort64VectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.compress(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertcompressArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void expandShort64VectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.expand(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertexpandArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n@@ -4736,4 +4706,0 @@\n-\n-\n-\n-\n@@ -4754,3 +4720,0 @@\n-\n-\n-\n@@ -4782,0 +4745,1 @@\n+\n@@ -4811,0 +4775,1 @@\n+\n@@ -4844,0 +4809,1 @@\n+\n@@ -4871,0 +4837,1 @@\n+\n@@ -4910,0 +4877,1 @@\n+\n@@ -4967,22 +4935,0 @@\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n@@ -4992,0 +4938,1 @@\n+\n@@ -4996,1 +4943,0 @@\n-\n@@ -5015,0 +4961,1 @@\n+\n@@ -5032,1 +4979,0 @@\n-\n@@ -5055,3 +5001,0 @@\n-\n-\n-\n@@ -5087,0 +5030,1 @@\n+\n@@ -5117,1 +5061,0 @@\n-\n@@ -5156,3 +5099,0 @@\n-\n-\n-\n@@ -5173,0 +5113,1 @@\n+\n@@ -5188,1 +5129,0 @@\n-\n@@ -5207,1 +5147,0 @@\n-\n@@ -5320,1 +5259,0 @@\n-\n@@ -5329,2 +5267,0 @@\n-\n-\n@@ -5361,2 +5297,0 @@\n-\n-\n@@ -5381,2 +5315,0 @@\n-\n-\n@@ -5387,2 +5319,0 @@\n-\n-\n@@ -5404,2 +5334,0 @@\n-\n-\n@@ -5424,0 +5352,151 @@\n+    static short BIT_COUNT(short a) {\n+        return (short)(Integer.bitCount((int)a & 0xFFFF));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void BIT_COUNTShort64VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Short64VectorTests::BIT_COUNT);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void BIT_COUNTMaskedShort64VectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Short64VectorTests::BIT_COUNT);\n+    }\n+\n+    static short TRAILING_ZEROS_COUNT(short a) {\n+        return (short)(TRAILING_ZEROS_COUNT_scalar(a));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void TRAILING_ZEROS_COUNTShort64VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TRAILING_ZEROS_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Short64VectorTests::TRAILING_ZEROS_COUNT);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void TRAILING_ZEROS_COUNTMaskedShort64VectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TRAILING_ZEROS_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Short64VectorTests::TRAILING_ZEROS_COUNT);\n+    }\n+\n+    static short LEADING_ZEROS_COUNT(short a) {\n+        return (short)(LEADING_ZEROS_COUNT_scalar(a));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void LEADING_ZEROS_COUNTShort64VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LEADING_ZEROS_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Short64VectorTests::LEADING_ZEROS_COUNT);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void LEADING_ZEROS_COUNTMaskedShort64VectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LEADING_ZEROS_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Short64VectorTests::LEADING_ZEROS_COUNT);\n+    }\n+\n+    static short REVERSE(short a) {\n+        return (short)(REVERSE_scalar(a));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void REVERSEShort64VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, Short64VectorTests::REVERSE);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void REVERSEMaskedShort64VectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Short64VectorTests::REVERSE);\n+    }\n+\n+    static short REVERSE_BYTES(short a) {\n+        return (short)(Short.reverseBytes(a));\n+    }\n@@ -5425,0 +5504,4 @@\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void REVERSE_BYTESShort64VectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n@@ -5426,0 +5509,6 @@\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES).intoArray(r, i);\n+            }\n+        }\n@@ -5427,0 +5516,20 @@\n+        assertArraysEquals(r, a, Short64VectorTests::REVERSE_BYTES);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void REVERSE_BYTESMaskedShort64VectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, Short64VectorTests::REVERSE_BYTES);\n+    }\n@@ -5829,0 +5938,17 @@\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCompressShort64VectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        int trueCount = 0;\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                trueCount = vmask.trueCount();\n+                var rmask = vmask.compress();\n+                for (int j = 0; j < SPECIES.length(); j++)  {\n+                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);\n+                }\n+            }\n+        }\n+    }\n+\n@@ -5871,0 +5997,14 @@\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeLongShort64VectorTestsSmokeTest(int offset) {\n+        long limit = SPECIES.length() * BUFFER_REPS;\n+        for (long i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i + offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                long index = i + j + offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n@@ -5891,0 +6031,8 @@\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundLongShort64VectorTestsSmokeTest(int _length) {\n+        long length = _length;\n+        long actualLoopBound = SPECIES.loopBound(length);\n+        long expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+    }\n+\n@@ -5953,1 +6101,0 @@\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short64VectorTests.java","additions":364,"deletions":217,"binary":false,"changes":581,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,3 @@\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.ValueLayout;\n@@ -44,4 +47,0 @@\n-import java.lang.invoke.MethodHandles;\n-import java.lang.invoke.VarHandle;\n-import java.nio.ByteBuffer;\n-import java.nio.ShortBuffer;\n@@ -49,1 +48,0 @@\n-import java.nio.ReadOnlyBufferException;\n@@ -79,11 +77,0 @@\n-    static void assertArraysEquals(byte[] r, byte[] a, boolean[] mask) {\n-        int i = 0;\n-        try {\n-            for (; i < a.length; i++) {\n-                Assert.assertEquals(r[i], mask[(i*8\/SPECIES.elementSize()) % SPECIES.length()] ? a[i] : (byte) 0);\n-            }\n-        } catch (AssertionError e) {\n-            Assert.assertEquals(r[i], mask[(i*8\/SPECIES.elementSize()) % SPECIES.length()] ? a[i] : (byte) 0, \"at index #\" + i);\n-        }\n-    }\n-\n@@ -129,1 +116,1 @@\n-    \/\/ Relative to byte[] array.length or ByteBuffer.limit()\n+    \/\/ Relative to byte[] array.length or MemorySegment.byteSize()\n@@ -200,1 +187,1 @@\n-    public Object[][] shortByteBufferProvider() {\n+    public Object[][] shortMemorySegmentProvider() {\n@@ -202,1 +189,1 @@\n-                flatMap(fa -> BYTE_BUFFER_GENERATORS.stream().\n+                flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n@@ -210,1 +197,1 @@\n-    public Object[][] shortByteBufferMaskProvider() {\n+    public Object[][] shortMemorySegmentMaskProvider() {\n@@ -213,1 +200,1 @@\n-                        flatMap(fa -> BYTE_BUFFER_GENERATORS.stream().\n+                        flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n@@ -220,19 +207,0 @@\n-    @DataProvider\n-    public Object[][] shortByteArrayProvider() {\n-        return SHORT_GENERATORS.stream().\n-                flatMap(fa -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                    return new Object[]{fa, bo};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] shortByteArrayMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> SHORT_GENERATORS.stream().\n-                    flatMap(fa -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                        return new Object[]{fa, fm, bo};\n-                    }))).\n-                toArray(Object[][]::new);\n-    }\n-\n@@ -258,4 +226,4 @@\n-    static ByteBuffer toBuffer(short[] a, IntFunction<ByteBuffer> fb) {\n-        ByteBuffer bb = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n-        for (short v : a) {\n-            bb.putShort(v);\n+    static MemorySegment toSegment(short[] a, IntFunction<MemorySegment> fb) {\n+        MemorySegment ms = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n+        for (int i = 0; i < a.length; i++) {\n+            ms.set(ValueLayout.JAVA_SHORT, i * SPECIES.elementSize() \/ 8 , a[i]);\n@@ -263,1 +231,1 @@\n-        return bb.clear();\n+        return ms;\n@@ -266,14 +234,2 @@\n-    static short[] bufferToArray(ByteBuffer bb) {\n-        ShortBuffer db = bb.asShortBuffer();\n-        short[] d = new short[db.capacity()];\n-        db.get(0, d);\n-        return d;\n-    }\n-\n-    static byte[] toByteArray(short[] a, IntFunction<byte[]> fb, ByteOrder bo) {\n-        byte[] b = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n-        ShortBuffer bb = ByteBuffer.wrap(b, 0, b.length).order(bo).asShortBuffer();\n-        for (short v : a) {\n-            bb.put(v);\n-        }\n-        return b;\n+    static short[] segmentToArray(MemorySegment ms) {\n+        return ms.toArray(ValueLayout.JAVA_SHORT);\n@@ -319,22 +275,2 @@\n-    static ShortVector fromByteArray(byte[] a, int i, ByteOrder bo) {\n-        return ShortVector.fromByteArray(SPECIES, a, i, bo);\n-    }\n-\n-    @DontInline\n-    static ShortVector fromByteArray(byte[] a, int i, ByteOrder bo, VectorMask<Short> m) {\n-        return ShortVector.fromByteArray(SPECIES, a, i, bo, m);\n-    }\n-\n-    @DontInline\n-    static void intoByteArray(ShortVector v, byte[] a, int i, ByteOrder bo) {\n-        v.intoByteArray(a, i, bo);\n-    }\n-\n-    @DontInline\n-    static void intoByteArray(ShortVector v, byte[] a, int i, ByteOrder bo, VectorMask<Short> m) {\n-        v.intoByteArray(a, i, bo, m);\n-    }\n-\n-    @DontInline\n-    static ShortVector fromByteBuffer(ByteBuffer a, int i, ByteOrder bo) {\n-        return ShortVector.fromByteBuffer(SPECIES, a, i, bo);\n+    static ShortVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo) {\n+        return ShortVector.fromMemorySegment(SPECIES, a, i, bo);\n@@ -344,2 +280,2 @@\n-    static ShortVector fromByteBuffer(ByteBuffer a, int i, ByteOrder bo, VectorMask<Short> m) {\n-        return ShortVector.fromByteBuffer(SPECIES, a, i, bo, m);\n+    static ShortVector fromMemorySegment(MemorySegment a, int i, ByteOrder bo, VectorMask<Short> m) {\n+        return ShortVector.fromMemorySegment(SPECIES, a, i, bo, m);\n@@ -349,2 +285,2 @@\n-    static void intoByteBuffer(ShortVector v, ByteBuffer a, int i, ByteOrder bo) {\n-        v.intoByteBuffer(a, i, bo);\n+    static void intoMemorySegment(ShortVector v, MemorySegment a, int i, ByteOrder bo) {\n+        v.intoMemorySegment(a, i, bo);\n@@ -354,2 +290,2 @@\n-    static void intoByteBuffer(ShortVector v, ByteBuffer a, int i, ByteOrder bo, VectorMask<Short> m) {\n-        v.intoByteBuffer(a, i, bo, m);\n+    static void intoMemorySegment(ShortVector v, MemorySegment a, int i, ByteOrder bo, VectorMask<Short> m) {\n+        v.intoMemorySegment(a, i, bo, m);\n@@ -358,1 +294,0 @@\n-\n@@ -529,6 +464,6 @@\n-    @Test(dataProvider = \"shortByteBufferProvider\")\n-    static void loadStoreByteBuffer(IntFunction<short[]> fa,\n-                                    IntFunction<ByteBuffer> fb,\n-                                    ByteOrder bo) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), fb);\n-        ByteBuffer r = fb.apply(a.limit());\n+    @Test(dataProvider = \"shortMemorySegmentProvider\")\n+    static void loadStoreMemorySegment(IntFunction<short[]> fa,\n+                                       IntFunction<MemorySegment> fb,\n+                                       ByteOrder bo) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb);\n+        MemorySegment r = fb.apply((int) a.byteSize());\n@@ -536,1 +471,1 @@\n-        int l = a.limit();\n+        int l = (int) a.byteSize();\n@@ -541,2 +476,2 @@\n-                ShortVector av = ShortVector.fromByteBuffer(SPECIES, a, i, bo);\n-                av.intoByteBuffer(r, i, bo);\n+                ShortVector av = ShortVector.fromMemorySegment(SPECIES, a, i, bo);\n+                av.intoMemorySegment(r, i, bo);\n@@ -545,5 +480,2 @@\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        Assert.assertEquals(r, a, \"Buffers not equal\");\n+        long m = r.mismatch(a);\n+        Assert.assertEquals(m, -1, \"Segments not equal\");\n@@ -553,3 +485,3 @@\n-    static void loadByteBufferIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n+    static void loadMemorySegmentIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n@@ -557,1 +489,1 @@\n-        int l = a.limit();\n+        int l = (int) a.byteSize();\n@@ -562,2 +494,2 @@\n-                ShortVector av = fromByteBuffer(a, i, ByteOrder.nativeOrder());\n-                av.intoByteBuffer(r, i, ByteOrder.nativeOrder());\n+                ShortVector av = fromMemorySegment(a, i, ByteOrder.nativeOrder());\n+                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n@@ -567,2 +499,2 @@\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.limit());\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());\n@@ -570,1 +502,1 @@\n-            fromByteBuffer(a, index, ByteOrder.nativeOrder());\n+            fromMemorySegment(a, index, ByteOrder.nativeOrder());\n@@ -582,3 +514,3 @@\n-    static void storeByteBufferIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n+    static void storeMemorySegmentIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n@@ -586,1 +518,1 @@\n-        int l = a.limit();\n+        int l = (int) a.byteSize();\n@@ -591,2 +523,2 @@\n-                ShortVector av = ShortVector.fromByteBuffer(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteBuffer(av, r, i, ByteOrder.nativeOrder());\n+                ShortVector av = ShortVector.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+                intoMemorySegment(av, r, i, ByteOrder.nativeOrder());\n@@ -596,2 +528,2 @@\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.limit());\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());\n@@ -599,2 +531,2 @@\n-            ShortVector av = ShortVector.fromByteBuffer(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteBuffer(av, r, index, ByteOrder.nativeOrder());\n+            ShortVector av = ShortVector.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+            intoMemorySegment(av, r, index, ByteOrder.nativeOrder());\n@@ -611,6 +543,5 @@\n-\n-    @Test(dataProvider = \"shortByteBufferMaskProvider\")\n-    static void loadStoreByteBufferMask(IntFunction<short[]> fa,\n-                                        IntFunction<ByteBuffer> fb,\n-                                        IntFunction<boolean[]> fm,\n-                                        ByteOrder bo) {\n+    @Test(dataProvider = \"shortMemorySegmentMaskProvider\")\n+    static void loadStoreMemorySegmentMask(IntFunction<short[]> fa,\n+                                           IntFunction<MemorySegment> fb,\n+                                           IntFunction<boolean[]> fm,\n+                                           ByteOrder bo) {\n@@ -618,2 +549,2 @@\n-        ByteBuffer a = toBuffer(_a, fb);\n-        ByteBuffer r = fb.apply(a.limit());\n+        MemorySegment a = toSegment(_a, fb);\n+        MemorySegment r = fb.apply((int) a.byteSize());\n@@ -623,1 +554,1 @@\n-        int l = a.limit();\n+        int l = (int) a.byteSize();\n@@ -628,2 +559,2 @@\n-                ShortVector av = ShortVector.fromByteBuffer(SPECIES, a, i, bo, vmask);\n-                av.intoByteBuffer(r, i, bo);\n+                ShortVector av = ShortVector.fromMemorySegment(SPECIES, a, i, bo, vmask);\n+                av.intoMemorySegment(r, i, bo);\n@@ -632,5 +563,1 @@\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        assertArraysEquals(bufferToArray(r), _a, mask);\n+        assertArraysEquals(segmentToArray(r), _a, mask);\n@@ -639,1 +566,1 @@\n-        r = fb.apply(a.limit());\n+        r = fb.apply((int) a.byteSize());\n@@ -643,2 +570,2 @@\n-                ShortVector av = ShortVector.fromByteBuffer(SPECIES, a, i, bo);\n-                av.intoByteBuffer(r, i, bo, vmask);\n+                ShortVector av = ShortVector.fromMemorySegment(SPECIES, a, i, bo);\n+                av.intoMemorySegment(r, i, bo, vmask);\n@@ -647,5 +574,1 @@\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        assertArraysEquals(bufferToArray(r), _a, mask);\n+        assertArraysEquals(segmentToArray(r), _a, mask);\n@@ -655,3 +578,3 @@\n-    static void loadByteBufferMaskIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n+    static void loadMemorySegmentMaskIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n@@ -661,1 +584,1 @@\n-        int l = a.limit();\n+        int l = (int) a.byteSize();\n@@ -666,2 +589,2 @@\n-                ShortVector av = fromByteBuffer(a, i, ByteOrder.nativeOrder(), vmask);\n-                av.intoByteBuffer(r, i, ByteOrder.nativeOrder());\n+                ShortVector av = fromMemorySegment(a, i, ByteOrder.nativeOrder(), vmask);\n+                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n@@ -671,2 +594,2 @@\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.limit(), SPECIES.elementSize() \/ 8);\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() \/ 8);\n@@ -674,1 +597,1 @@\n-            fromByteBuffer(a, index, ByteOrder.nativeOrder(), vmask);\n+            fromMemorySegment(a, index, ByteOrder.nativeOrder(), vmask);\n@@ -686,3 +609,3 @@\n-    static void storeByteBufferMaskIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n+    static void storeMemorySegmentMaskIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n@@ -692,83 +615,1 @@\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ShortVector av = ShortVector.fromByteBuffer(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteBuffer(av, r, i, ByteOrder.nativeOrder(), vmask);\n-            }\n-        }\n-\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.limit(), SPECIES.elementSize() \/ 8);\n-        try {\n-            ShortVector av = ShortVector.fromByteBuffer(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteBuffer(av, a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"shortByteBufferProvider\")\n-    static void loadStoreReadonlyByteBuffer(IntFunction<short[]> fa,\n-                                    IntFunction<ByteBuffer> fb,\n-                                    ByteOrder bo) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), fb).asReadOnlyBuffer();\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo);\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, SPECIES.maskAll(true));\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, SPECIES.maskAll(false));\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            VectorMask<Short> m = SPECIES.shuffleFromOp(i -> i % 2 == 0 ? 1 : -1)\n-                    .laneIsValid();\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, m);\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"shortByteArrayProvider\")\n-    static void loadStoreByteArray(IntFunction<short[]> fa,\n-                                    ByteOrder bo) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, bo);\n-        byte[] r = new byte[a.length];\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ShortVector av = ShortVector.fromByteArray(SPECIES, a, i, bo);\n-                av.intoByteArray(r, i, bo);\n-            }\n-        }\n-        Assert.assertEquals(r, a, \"Byte arrays not equal\");\n-    }\n-\n-    @Test(dataProvider = \"shortByteProviderForIOOBE\")\n-    static void loadByteArrayIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-\n+        int l = (int) a.byteSize();\n@@ -776,1 +617,0 @@\n-        int l = a.length;\n@@ -780,2 +620,2 @@\n-                ShortVector av = fromByteArray(a, i, ByteOrder.nativeOrder());\n-                av.intoByteArray(r, i, ByteOrder.nativeOrder());\n+                ShortVector av = ShortVector.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+                intoMemorySegment(av, r, i, ByteOrder.nativeOrder(), vmask);\n@@ -785,2 +625,2 @@\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.length);\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() \/ 8);\n@@ -788,1 +628,2 @@\n-            fromByteArray(a, index, ByteOrder.nativeOrder());\n+            ShortVector av = ShortVector.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+            intoMemorySegment(av, a, index, ByteOrder.nativeOrder(), vmask);\n@@ -799,62 +640,5 @@\n-    @Test(dataProvider = \"shortByteProviderForIOOBE\")\n-    static void storeByteArrayIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ShortVector av = ShortVector.fromByteArray(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteArray(av, r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.length);\n-        try {\n-            ShortVector av = ShortVector.fromByteArray(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteArray(av, r, index, ByteOrder.nativeOrder());\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"shortByteArrayMaskProvider\")\n-    static void loadStoreByteArrayMask(IntFunction<short[]> fa,\n-                                  IntFunction<boolean[]> fm,\n-                                  ByteOrder bo) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, bo);\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Short> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-          for (int i = 0; i < l; i += s) {\n-              ShortVector av = ShortVector.fromByteArray(SPECIES, a, i, bo, vmask);\n-              av.intoByteArray(r, i, bo);\n-          }\n-        }\n-        assertArraysEquals(r, a, mask);\n-\n-\n-        r = new byte[a.length];\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ShortVector av = ShortVector.fromByteArray(SPECIES, a, i, bo);\n-                av.intoByteArray(r, i, bo, vmask);\n-            }\n-        }\n-        assertArraysEquals(r, a, mask);\n-    }\n+    @Test(dataProvider = \"shortMemorySegmentProvider\")\n+    static void loadStoreReadonlyMemorySegment(IntFunction<short[]> fa,\n+                                               IntFunction<MemorySegment> fb,\n+                                               ByteOrder bo) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb).asReadOnly();\n@@ -862,6 +646,4 @@\n-    @Test(dataProvider = \"shortByteMaskProviderForIOOBE\")\n-    static void loadByteArrayMaskIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Short> vmask = VectorMask.fromValues(SPECIES, mask);\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo)\n+        );\n@@ -869,2 +651,4 @@\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(true))\n+        );\n@@ -872,6 +656,4 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ShortVector av = fromByteArray(a, i, ByteOrder.nativeOrder(), vmask);\n-                av.intoByteArray(r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(false))\n+        );\n@@ -879,12 +661,6 @@\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length, SPECIES.elementSize() \/ 8);\n-        try {\n-            fromByteArray(a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n+        VectorMask<Short> m = SPECIES.shuffleFromOp(i -> i % 2 == 0 ? 1 : -1)\n+                .laneIsValid();\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, m)\n+        );\n@@ -893,31 +669,0 @@\n-    @Test(dataProvider = \"shortByteMaskProviderForIOOBE\")\n-    static void storeByteArrayMaskIOOBE(IntFunction<short[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<Short> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                ShortVector av = ShortVector.fromByteArray(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteArray(av, r, i, ByteOrder.nativeOrder(), vmask);\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length, SPECIES.elementSize() \/ 8);\n-        try {\n-            ShortVector av = ShortVector.fromByteArray(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteArray(av, a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n@@ -939,0 +684,1 @@\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ShortMaxVectorLoadStoreTests.java","additions":112,"deletions":366,"binary":false,"changes":478,"status":"modified"},{"patch":"@@ -269,0 +269,49 @@\n+    static void assertcompressArraysEquals(short[] r, short[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    Assert.assertEquals(r[i + k], (short)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (short)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals(short[] r, short[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        Assert.assertEquals(r[i + j], (short)0);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], (short)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n@@ -892,1 +941,0 @@\n-\n@@ -987,2 +1035,0 @@\n-\n-\n@@ -1064,1 +1110,0 @@\n-\n@@ -1205,0 +1250,16 @@\n+    static short TRAILING_ZEROS_COUNT_scalar(short a) {\n+        return (short) (a != 0 ? Integer.numberOfTrailingZeros(a) : 16);\n+    }\n+\n+    static short LEADING_ZEROS_COUNT_scalar(short a) {\n+        return (short) (a >= 0 ? Integer.numberOfLeadingZeros(a) - 16 : 0);\n+    }\n+\n+    static short REVERSE_scalar(short a) {\n+        short b = ROL_scalar(a, (short) 8);\n+        b = (short) (((b & 0x5555) << 1) | ((b & 0xAAAA) >>> 1));\n+        b = (short) (((b & 0x3333) << 2) | ((b & 0xCCCC) >>> 2));\n+        b = (short) (((b & 0x0F0F) << 4) | ((b & 0xF0F0) >>> 4));\n+        return b;\n+    }\n+\n@@ -1354,0 +1415,1 @@\n+\n@@ -1374,0 +1436,1 @@\n+\n@@ -1430,0 +1493,1 @@\n+\n@@ -1450,0 +1514,1 @@\n+\n@@ -1506,0 +1571,1 @@\n+\n@@ -1526,0 +1592,1 @@\n+\n@@ -1583,2 +1650,0 @@\n-\n-\n@@ -1607,0 +1672,1 @@\n+\n@@ -1630,2 +1696,0 @@\n-\n-\n@@ -1737,0 +1801,1 @@\n+\n@@ -1756,2 +1821,0 @@\n-\n-\n@@ -1778,1 +1841,0 @@\n-\n@@ -1800,2 +1862,0 @@\n-\n-\n@@ -1822,1 +1882,0 @@\n-\n@@ -1843,0 +1902,1 @@\n+\n@@ -1862,2 +1922,0 @@\n-\n-\n@@ -1884,1 +1942,0 @@\n-\n@@ -1906,2 +1963,0 @@\n-\n-\n@@ -1928,1 +1983,0 @@\n-\n@@ -2022,3 +2076,0 @@\n-\n-\n-\n@@ -2041,2 +2092,0 @@\n-\n-\n@@ -2062,2 +2111,0 @@\n-\n-\n@@ -2092,2 +2139,0 @@\n-\n-\n@@ -2111,2 +2156,0 @@\n-\n-\n@@ -2141,2 +2184,0 @@\n-\n-\n@@ -2160,2 +2201,0 @@\n-\n-\n@@ -2176,2 +2215,0 @@\n-\n-\n@@ -2195,1 +2232,0 @@\n-\n@@ -2227,4 +2263,0 @@\n-\n-\n-\n-\n@@ -2252,2 +2284,0 @@\n-\n-\n@@ -2274,5 +2304,0 @@\n-\n-\n-\n-\n-\n@@ -2300,2 +2325,0 @@\n-\n-\n@@ -2322,5 +2345,0 @@\n-\n-\n-\n-\n-\n@@ -2348,2 +2366,0 @@\n-\n-\n@@ -2370,5 +2386,0 @@\n-\n-\n-\n-\n-\n@@ -2395,2 +2406,0 @@\n-\n-\n@@ -2416,5 +2425,0 @@\n-\n-\n-\n-\n-\n@@ -2441,2 +2445,0 @@\n-\n-\n@@ -2462,5 +2464,0 @@\n-\n-\n-\n-\n-\n@@ -2487,2 +2484,0 @@\n-\n-\n@@ -2508,1 +2503,0 @@\n-\n@@ -2530,2 +2524,0 @@\n-\n-\n@@ -2552,1 +2544,0 @@\n-\n@@ -2574,2 +2565,0 @@\n-\n-\n@@ -2596,1 +2585,0 @@\n-\n@@ -2617,2 +2605,0 @@\n-\n-\n@@ -2638,1 +2624,0 @@\n-\n@@ -2659,2 +2644,0 @@\n-\n-\n@@ -2679,6 +2662,0 @@\n-\n-\n-\n-\n-\n-\n@@ -2704,2 +2681,0 @@\n-\n-\n@@ -2724,2 +2699,0 @@\n-\n-\n@@ -2745,2 +2718,0 @@\n-\n-\n@@ -2765,2 +2736,0 @@\n-\n-\n@@ -2786,2 +2755,0 @@\n-\n-\n@@ -2806,2 +2773,0 @@\n-\n-\n@@ -2827,2 +2792,0 @@\n-\n-\n@@ -2847,2 +2810,0 @@\n-\n-\n@@ -2868,2 +2829,0 @@\n-\n-\n@@ -2909,0 +2868,1 @@\n+\n@@ -2927,0 +2887,1 @@\n+\n@@ -2947,0 +2908,1 @@\n+\n@@ -3040,1 +3002,0 @@\n-\n@@ -3066,1 +3027,0 @@\n-\n@@ -3086,1 +3046,0 @@\n-\n@@ -3114,1 +3073,0 @@\n-\n@@ -3133,1 +3091,0 @@\n-\n@@ -3159,1 +3116,0 @@\n-\n@@ -3179,1 +3135,0 @@\n-\n@@ -3207,1 +3162,0 @@\n-\n@@ -3226,1 +3180,0 @@\n-\n@@ -3252,1 +3205,0 @@\n-\n@@ -3272,1 +3224,0 @@\n-\n@@ -3317,0 +3268,1 @@\n+\n@@ -3341,0 +3293,1 @@\n+\n@@ -3359,0 +3312,1 @@\n+\n@@ -3385,0 +3339,1 @@\n+\n@@ -3402,0 +3357,1 @@\n+\n@@ -3426,0 +3382,1 @@\n+\n@@ -3444,0 +3401,1 @@\n+\n@@ -3470,0 +3428,1 @@\n+\n@@ -3487,0 +3446,1 @@\n+\n@@ -3511,0 +3471,1 @@\n+\n@@ -3529,0 +3490,1 @@\n+\n@@ -3555,0 +3517,1 @@\n+\n@@ -3572,0 +3535,1 @@\n+\n@@ -3596,0 +3560,1 @@\n+\n@@ -3614,0 +3579,1 @@\n+\n@@ -3640,0 +3606,1 @@\n+\n@@ -3657,0 +3624,1 @@\n+\n@@ -3681,0 +3649,1 @@\n+\n@@ -3699,0 +3668,1 @@\n+\n@@ -3735,1 +3705,0 @@\n-\n@@ -3751,1 +3720,0 @@\n-\n@@ -3761,1 +3729,0 @@\n-\n@@ -3777,1 +3744,0 @@\n-\n@@ -3795,0 +3761,1 @@\n+\n@@ -3835,0 +3802,1 @@\n+\n@@ -3876,3 +3844,0 @@\n-\n-\n-\n@@ -3898,1 +3863,0 @@\n-\n@@ -3941,1 +3905,0 @@\n-\n@@ -3984,1 +3947,0 @@\n-\n@@ -4004,1 +3966,0 @@\n-\n@@ -4047,1 +4008,0 @@\n-\n@@ -4090,1 +4050,0 @@\n-\n@@ -4133,1 +4092,0 @@\n-\n@@ -4176,2 +4134,0 @@\n-\n-\n@@ -4197,2 +4153,0 @@\n-\n-\n@@ -4222,3 +4176,0 @@\n-\n-\n-\n@@ -4244,2 +4195,0 @@\n-\n-\n@@ -4269,3 +4218,0 @@\n-\n-\n-\n@@ -4291,2 +4237,0 @@\n-\n-\n@@ -4316,3 +4260,0 @@\n-\n-\n-\n@@ -4338,2 +4279,0 @@\n-\n-\n@@ -4363,2 +4302,0 @@\n-\n-\n@@ -4381,1 +4318,0 @@\n-\n@@ -4418,1 +4354,0 @@\n-\n@@ -4455,1 +4390,0 @@\n-\n@@ -4492,1 +4426,0 @@\n-\n@@ -4571,0 +4504,37 @@\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void compressShortMaxVectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.compress(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertcompressArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void expandShortMaxVectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.expand(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertexpandArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n@@ -4741,4 +4711,0 @@\n-\n-\n-\n-\n@@ -4759,3 +4725,0 @@\n-\n-\n-\n@@ -4787,0 +4750,1 @@\n+\n@@ -4816,0 +4780,1 @@\n+\n@@ -4849,0 +4814,1 @@\n+\n@@ -4876,0 +4842,1 @@\n+\n@@ -4915,0 +4882,1 @@\n+\n@@ -4972,22 +4940,0 @@\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n@@ -4997,0 +4943,1 @@\n+\n@@ -5001,1 +4948,0 @@\n-\n@@ -5020,0 +4966,1 @@\n+\n@@ -5037,1 +4984,0 @@\n-\n@@ -5060,3 +5006,0 @@\n-\n-\n-\n@@ -5092,0 +5035,1 @@\n+\n@@ -5122,1 +5066,0 @@\n-\n@@ -5161,3 +5104,0 @@\n-\n-\n-\n@@ -5178,0 +5118,1 @@\n+\n@@ -5193,1 +5134,0 @@\n-\n@@ -5212,1 +5152,0 @@\n-\n@@ -5325,1 +5264,0 @@\n-\n@@ -5334,2 +5272,0 @@\n-\n-\n@@ -5366,2 +5302,0 @@\n-\n-\n@@ -5386,2 +5320,0 @@\n-\n-\n@@ -5392,2 +5324,0 @@\n-\n-\n@@ -5409,2 +5339,0 @@\n-\n-\n@@ -5429,0 +5357,151 @@\n+    static short BIT_COUNT(short a) {\n+        return (short)(Integer.bitCount((int)a & 0xFFFF));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void BIT_COUNTShortMaxVectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, ShortMaxVectorTests::BIT_COUNT);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void BIT_COUNTMaskedShortMaxVectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, ShortMaxVectorTests::BIT_COUNT);\n+    }\n+\n+    static short TRAILING_ZEROS_COUNT(short a) {\n+        return (short)(TRAILING_ZEROS_COUNT_scalar(a));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void TRAILING_ZEROS_COUNTShortMaxVectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TRAILING_ZEROS_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, ShortMaxVectorTests::TRAILING_ZEROS_COUNT);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void TRAILING_ZEROS_COUNTMaskedShortMaxVectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TRAILING_ZEROS_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, ShortMaxVectorTests::TRAILING_ZEROS_COUNT);\n+    }\n+\n+    static short LEADING_ZEROS_COUNT(short a) {\n+        return (short)(LEADING_ZEROS_COUNT_scalar(a));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void LEADING_ZEROS_COUNTShortMaxVectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LEADING_ZEROS_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, ShortMaxVectorTests::LEADING_ZEROS_COUNT);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void LEADING_ZEROS_COUNTMaskedShortMaxVectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LEADING_ZEROS_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, ShortMaxVectorTests::LEADING_ZEROS_COUNT);\n+    }\n+\n+    static short REVERSE(short a) {\n+        return (short)(REVERSE_scalar(a));\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void REVERSEShortMaxVectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, ShortMaxVectorTests::REVERSE);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void REVERSEMaskedShortMaxVectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, ShortMaxVectorTests::REVERSE);\n+    }\n+\n+    static short REVERSE_BYTES(short a) {\n+        return (short)(Short.reverseBytes(a));\n+    }\n@@ -5430,0 +5509,4 @@\n+    @Test(dataProvider = \"shortUnaryOpProvider\")\n+    static void REVERSE_BYTESShortMaxVectorTests(IntFunction<short[]> fa) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n@@ -5431,0 +5514,6 @@\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES).intoArray(r, i);\n+            }\n+        }\n@@ -5432,0 +5521,20 @@\n+        assertArraysEquals(r, a, ShortMaxVectorTests::REVERSE_BYTES);\n+    }\n+\n+    @Test(dataProvider = \"shortUnaryOpMaskProvider\")\n+    static void REVERSE_BYTESMaskedShortMaxVectorTests(IntFunction<short[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertArraysEquals(r, a, mask, ShortMaxVectorTests::REVERSE_BYTES);\n+    }\n@@ -5834,0 +5943,17 @@\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCompressShortMaxVectorTestsSmokeTest(IntFunction<boolean[]> fa) {\n+        int trueCount = 0;\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                trueCount = vmask.trueCount();\n+                var rmask = vmask.compress();\n+                for (int j = 0; j < SPECIES.length(); j++)  {\n+                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);\n+                }\n+            }\n+        }\n+    }\n+\n@@ -5860,0 +5986,14 @@\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeLongShortMaxVectorTestsSmokeTest(int offset) {\n+        long limit = SPECIES.length() * BUFFER_REPS;\n+        for (long i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i + offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                long index = i + j + offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n@@ -5880,0 +6020,8 @@\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundLongShortMaxVectorTestsSmokeTest(int _length) {\n+        long length = _length;\n+        long actualLoopBound = SPECIES.loopBound(length);\n+        long expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+    }\n+\n@@ -5942,1 +6090,0 @@\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ShortMaxVectorTests.java","additions":364,"deletions":217,"binary":false,"changes":581,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -23,0 +23,1 @@\n+import jdk.incubator.foreign.MemorySegment;\n@@ -29,2 +30,0 @@\n-import java.lang.invoke.MethodHandles;\n-import java.lang.invoke.VarHandle;\n@@ -335,1 +334,3 @@\n-        Vector<E> av = a.fromByteArray(input, 0, ByteOrder.nativeOrder());\n+        MemorySegment inputMs = MemorySegment.ofArray(input);\n+        MemorySegment outputMs = MemorySegment.ofArray(output);\n+        Vector<E> av = a.fromMemorySegment(inputMs, 0, ByteOrder.nativeOrder());\n@@ -350,1 +351,1 @@\n-                bv.intoByteArray(output, 0, ByteOrder.nativeOrder());\n+                bv.intoMemorySegment(outputMs, 0, ByteOrder.nativeOrder());\n@@ -365,1 +366,1 @@\n-                bv.intoByteArray(output, 0, ByteOrder.nativeOrder());\n+                bv.intoMemorySegment(outputMs, 0, ByteOrder.nativeOrder());\n@@ -383,1 +384,1 @@\n-            bv.intoByteArray(output, 0, ByteOrder.nativeOrder());\n+            bv.intoMemorySegment(outputMs, 0, ByteOrder.nativeOrder());\n@@ -712,1 +713,3 @@\n-        Vector<E> av = a.fromByteArray(input, 0, ByteOrder.nativeOrder());\n+        MemorySegment inputMs = MemorySegment.ofArray(input);\n+        MemorySegment outputMs = MemorySegment.ofArray(output);\n+        Vector<E> av = a.fromMemorySegment(inputMs, 0, ByteOrder.nativeOrder());\n@@ -739,1 +742,1 @@\n-                bv.intoByteArray(output, 0, ByteOrder.nativeOrder());\n+                bv.intoMemorySegment(outputMs, 0, ByteOrder.nativeOrder());\n@@ -754,1 +757,1 @@\n-                bv.intoByteArray(output, 0, ByteOrder.nativeOrder());\n+                bv.intoMemorySegment(outputMs, 0, ByteOrder.nativeOrder());\n@@ -772,1 +775,1 @@\n-            bv.intoByteArray(output, 0, ByteOrder.nativeOrder());\n+            bv.intoMemorySegment(outputMs, 0, ByteOrder.nativeOrder());\n","filename":"test\/jdk\/jdk\/incubator\/vector\/VectorReshapeTests.java","additions":14,"deletions":11,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n-# Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -77,0 +77,1 @@\n+compressexpand_template=\"CompressExpand\"\n@@ -148,1 +149,1 @@\n-    echo -e \"#if[${guard}]\\n\" >> $output\n+    echo -e \"#if[${guard}]\" >> $output\n@@ -169,1 +170,1 @@\n-    echo -e \"#end[${guard}]\\n\" >> $output\n+    echo -e \"#end[${guard}]\" >> $output\n@@ -413,0 +414,2 @@\n+gen_binary_alu_op \"COMPRESS_BITS\" \"\\$Boxtype\\$.compress(a, b)\" \"intOrLong\"\n+gen_binary_alu_op \"EXPAND_BITS\" \"\\$Boxtype\\$.expand(a, b)\" \"intOrLong\"\n@@ -511,0 +514,3 @@\n+# Compress\/Expand\n+gen_op_tmpl $compressexpand_template \"compress_expand\" \"\"\n+\n@@ -565,0 +571,9 @@\n+gen_unary_alu_op \"BIT_COUNT\" \"\\$Boxtype\\$.bitCount(a)\" \"intOrLong\"\n+gen_unary_alu_op \"BIT_COUNT\" \"Integer.bitCount((int)a \\& 0xFF)\" \"byte\"\n+gen_unary_alu_op \"BIT_COUNT\" \"Integer.bitCount((int)a \\& 0xFFFF)\" \"short\"\n+gen_unary_alu_op \"TRAILING_ZEROS_COUNT\" \"TRAILING_ZEROS_COUNT_scalar(a)\" \"BITWISE\"\n+gen_unary_alu_op \"LEADING_ZEROS_COUNT\" \"LEADING_ZEROS_COUNT_scalar(a)\" \"BITWISE\"\n+gen_unary_alu_op \"REVERSE\" \"REVERSE_scalar(a)\" \"BITWISE\"\n+gen_unary_alu_op \"REVERSE_BYTES\" \"\\$Boxtype\\$.reverseBytes(a)\" \"intOrLong\"\n+gen_unary_alu_op \"REVERSE_BYTES\" \"\\$Boxtype\\$.reverseBytes(a)\" \"short\"\n+gen_unary_alu_op \"REVERSE_BYTES\" \"a\" \"byte\"\n","filename":"test\/jdk\/jdk\/incubator\/vector\/gen-template.sh","additions":18,"deletions":3,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -254,1 +254,0 @@\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/gen-tests.sh","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,1 @@\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-Binary-Broadcast-op-math.template","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,1 @@\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-Binary-op-math.template","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,1 @@\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-Binary-op.template","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,1 @@\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-BoolReduction-Scalar-op.template","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,1 @@\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-BoolReduction-op.template","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -7,4 +7,0 @@\n-\n-\n-\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-Broadcast.template","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -18,1 +18,0 @@\n-\n@@ -56,1 +55,0 @@\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-Compare-Broadcast.template","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,1 @@\n+\n@@ -23,1 +24,0 @@\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-Compare-Masked.template","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -20,1 +20,0 @@\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-Compare.template","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,36 @@\n+\n+    @Test(dataProvider = \"$type$UnaryOpMaskProvider\")\n+    static void compress$vectorteststype$(IntFunction<$type$[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                av.compress(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertcompressArraysEquals(r, a, mask, SPECIES.length());\n+    }\n+\n+    @Test(dataProvider = \"$type$UnaryOpMaskProvider\")\n+    static void expand$vectorteststype$(IntFunction<$type$[]> fa,\n+                                                IntFunction<boolean[]> fm) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                av.expand(vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        assertexpandArraysEquals(r, a, mask, SPECIES.length());\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-CompressExpand.template","additions":36,"deletions":0,"binary":false,"changes":36,"status":"added"},{"patch":"@@ -0,0 +1,1 @@\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-Get-op.template","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -487,0 +487,17 @@\n+    @Test(dataProvider = \"maskProvider\")\n+    static void maskCompress$vectorteststype$SmokeTest(IntFunction<boolean[]> fa) {\n+        int trueCount = 0;\n+        boolean[] a = fa.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT * INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                var vmask = SPECIES.loadMask(a, i);\n+                trueCount = vmask.trueCount();\n+                var rmask = vmask.compress();\n+                for (int j = 0; j < SPECIES.length(); j++)  {\n+                    Assert.assertEquals(rmask.laneIsSet(j), j < trueCount);\n+                }\n+            }\n+        }\n+    }\n+\n@@ -531,0 +548,14 @@\n+    @Test(dataProvider = \"offsetProvider\")\n+    static void indexInRangeLong$vectorteststype$SmokeTest(int offset) {\n+        long limit = SPECIES.length() * BUFFER_REPS;\n+        for (long i = 0; i < limit; i += SPECIES.length()) {\n+            var actualMask = SPECIES.indexInRange(i + offset, limit);\n+            var expectedMask = SPECIES.maskAll(true).indexInRange(i + offset, limit);\n+            assert(actualMask.equals(expectedMask));\n+            for (int j = 0; j < SPECIES.length(); j++)  {\n+                long index = i + j + offset;\n+                Assert.assertEquals(actualMask.laneIsSet(j), index >= 0 && index < limit);\n+            }\n+        }\n+    }\n+\n@@ -551,0 +582,8 @@\n+    @Test(dataProvider = \"lengthProvider\")\n+    static void loopBoundLong$vectorteststype$SmokeTest(int _length) {\n+        long length = _length;\n+        long actualLoopBound = SPECIES.loopBound(length);\n+        long expectedLoopBound = length - Math.floorMod(length, SPECIES.length());\n+        Assert.assertEquals(actualLoopBound, expectedLoopBound);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-Miscellaneous.template","additions":39,"deletions":0,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -0,0 +1,1 @@\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-Reduction-Masked-op-func.template","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,1 @@\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-Reduction-Masked-op.template","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,1 @@\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-Reduction-Scalar-Masked-op-func.template","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,1 @@\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-Reduction-Scalar-Masked-op.template","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,1 @@\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-Reduction-Scalar-op-func.template","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,1 @@\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-Reduction-Scalar-op.template","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,1 @@\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-Reduction-op-func.template","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,1 @@\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-Reduction-op.template","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,1 @@\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-Shift-Scalar-op.template","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,1 @@\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-Shift-op.template","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,1 @@\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-Single-op.template","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,1 @@\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-Slice-Masked-bop.template","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,1 @@\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-Slice-bop.template","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,1 @@\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-Slice-op.template","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,1 @@\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-Ternary-Broadcast-Masked-op.template","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,1 @@\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-Ternary-Broadcast-op.template","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,1 @@\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-Ternary-Double-Broadcast-Masked-op.template","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,1 @@\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-Ternary-Double-Broadcast-op.template","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,1 @@\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-Ternary-Masked-op.template","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,1 @@\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-Ternary-Scalar-op.template","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,1 @@\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-Ternary-op.template","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,1 @@\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-Test.template","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,1 @@\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-Unary-op-math.template","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,1 @@\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-Unslice-Masked-bop.template","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,1 @@\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-Unslice-bop.template","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,1 @@\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-Unslice-op.template","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -7,4 +7,0 @@\n-\n-\n-\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-Zero.template","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,0 @@\n-\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-footer.template","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -92,0 +92,1 @@\n+#if[BITWISE]\n@@ -93,0 +94,1 @@\n+#end[BITWISE]\n@@ -295,0 +297,49 @@\n+    static void assertcompressArraysEquals($type$[] r, $type$[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + k], a[i + j]);\n+                        k++;\n+                    }\n+                }\n+                for (; k < vector_len; k++) {\n+                    Assert.assertEquals(r[i + k], ($type$)0);\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + k;\n+            if (m[(i + j) % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + j], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], ($type$)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n+    static void assertexpandArraysEquals($type$[] r, $type$[] a, boolean[] m, int vector_len) {\n+        int i = 0, j = 0, k = 0;\n+        try {\n+            for (; i < a.length; i += vector_len) {\n+                k = 0;\n+                for (j = 0; j < vector_len; j++) {\n+                    if (m[(i + j) % SPECIES.length()]) {\n+                        Assert.assertEquals(r[i + j], a[i + k]);\n+                        k++;\n+                    } else {\n+                        Assert.assertEquals(r[i + j], ($type$)0);\n+                    }\n+                }\n+            }\n+        } catch (AssertionError e) {\n+            int idx = i + j;\n+            if (m[idx % SPECIES.length()]) {\n+                Assert.assertEquals(r[idx], a[i + k], \"at index #\" + idx);\n+            } else {\n+                Assert.assertEquals(r[idx], ($type$)0, \"at index #\" + idx);\n+            }\n+        }\n+    }\n+\n@@ -1068,1 +1119,0 @@\n-\n@@ -1070,0 +1120,1 @@\n+\n@@ -1082,1 +1133,0 @@\n-\n@@ -1176,1 +1226,0 @@\n-\n@@ -1179,0 +1228,1 @@\n+\n@@ -1187,1 +1237,0 @@\n-\n@@ -1189,0 +1238,1 @@\n+\n@@ -1241,1 +1291,0 @@\n-\n@@ -1243,0 +1292,1 @@\n+\n@@ -1276,1 +1326,0 @@\n-\n@@ -1408,1 +1457,0 @@\n-\n@@ -1410,0 +1458,1 @@\n+\n@@ -1415,1 +1464,0 @@\n-\n@@ -1417,0 +1465,1 @@\n+\n@@ -1454,0 +1503,43 @@\n+#end[intOrLong]\n+    }\n+\n+    static $type$ TRAILING_ZEROS_COUNT_scalar($type$ a) {\n+#if[intOrLong]\n+        return $Wideboxtype$.numberOfTrailingZeros(a);\n+#else[intOrLong]\n+#if[short]\n+        return (short) (a != 0 ? Integer.numberOfTrailingZeros(a) : 16);\n+#else[short]\n+        return (byte) (a != 0 ? Integer.numberOfTrailingZeros(a) : 8);\n+#end[short]\n+#end[intOrLong]\n+    }\n+\n+    static $type$ LEADING_ZEROS_COUNT_scalar($type$ a) {\n+#if[intOrLong]\n+        return $Wideboxtype$.numberOfLeadingZeros(a);\n+#else[intOrLong]\n+#if[short]\n+        return (short) (a >= 0 ? Integer.numberOfLeadingZeros(a) - 16 : 0);\n+#else[short]\n+        return (byte) (a >= 0 ? Integer.numberOfLeadingZeros(a) - 24 : 0);\n+#end[short]\n+#end[intOrLong]\n+    }\n+\n+    static $type$ REVERSE_scalar($type$ a) {\n+#if[intOrLong]\n+        return $Wideboxtype$.reverse(a);\n+#else[intOrLong]\n+#if[short]\n+        $type$ b = ROL_scalar(a, ($type$) 8);\n+        b = (short) (((b & 0x5555) << 1) | ((b & 0xAAAA) >>> 1));\n+        b = (short) (((b & 0x3333) << 2) | ((b & 0xCCCC) >>> 2));\n+        b = (short) (((b & 0x0F0F) << 4) | ((b & 0xF0F0) >>> 4));\n+        return b;\n+#else[short]\n+        $type$ b = ($type$) ROL_scalar(a, ($type$) 4);\n+        b = (byte) (((b & 0x55) << 1) | ((b & 0xAA) >>> 1));\n+        b = (byte) (((b & 0x33) << 2) | ((b & 0xCC) >>> 2));\n+        return b;\n+#end[short]\n@@ -1481,1 +1573,0 @@\n-\n@@ -1483,0 +1574,1 @@\n+\n@@ -1596,1 +1688,0 @@\n-\n@@ -1598,0 +1689,1 @@\n+\n@@ -1605,0 +1697,1 @@\n+\n@@ -1610,0 +1703,1 @@\n+\n@@ -1621,1 +1715,0 @@\n-\n@@ -1623,0 +1716,1 @@\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-header.template","additions":105,"deletions":11,"binary":false,"changes":116,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,0 +38,3 @@\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.ValueLayout;\n@@ -50,8 +53,0 @@\n-#if[MaxBit]\n-import java.lang.invoke.MethodHandles;\n-import java.lang.invoke.VarHandle;\n-#end[MaxBit]\n-import java.nio.ByteBuffer;\n-#if[!byte]\n-import java.nio.$Type$Buffer;\n-#end[!byte]\n@@ -59,1 +54,0 @@\n-import java.nio.ReadOnlyBufferException;\n@@ -96,13 +90,0 @@\n-#if[!byte]\n-    static void assertArraysEquals(byte[] r, byte[] a, boolean[] mask) {\n-        int i = 0;\n-        try {\n-            for (; i < a.length; i++) {\n-                Assert.assertEquals(r[i], mask[(i*8\/SPECIES.elementSize()) % SPECIES.length()] ? a[i] : (byte) 0);\n-            }\n-        } catch (AssertionError e) {\n-            Assert.assertEquals(r[i], mask[(i*8\/SPECIES.elementSize()) % SPECIES.length()] ? a[i] : (byte) 0, \"at index #\" + i);\n-        }\n-    }\n-#end[!byte]\n-\n@@ -148,1 +129,1 @@\n-    \/\/ Relative to byte[] array.length or ByteBuffer.limit()\n+    \/\/ Relative to byte[] array.length or MemorySegment.byteSize()\n@@ -219,1 +200,1 @@\n-    public Object[][] $type$ByteBufferProvider() {\n+    public Object[][] $type$MemorySegmentProvider() {\n@@ -221,1 +202,1 @@\n-                flatMap(fa -> BYTE_BUFFER_GENERATORS.stream().\n+                flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n@@ -229,1 +210,1 @@\n-    public Object[][] $type$ByteBufferMaskProvider() {\n+    public Object[][] $type$MemorySegmentMaskProvider() {\n@@ -232,1 +213,1 @@\n-                        flatMap(fa -> BYTE_BUFFER_GENERATORS.stream().\n+                        flatMap(fa -> MEMORY_SEGMENT_GENERATORS.stream().\n@@ -239,19 +220,0 @@\n-    @DataProvider\n-    public Object[][] $type$ByteArrayProvider() {\n-        return $TYPE$_GENERATORS.stream().\n-                flatMap(fa -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                    return new Object[]{fa, bo};\n-                })).\n-                toArray(Object[][]::new);\n-    }\n-\n-    @DataProvider\n-    public Object[][] $type$ByteArrayMaskProvider() {\n-        return BOOLEAN_MASK_GENERATORS.stream().\n-                flatMap(fm -> $TYPE$_GENERATORS.stream().\n-                    flatMap(fa -> BYTE_ORDER_VALUES.stream().map(bo -> {\n-                        return new Object[]{fa, fm, bo};\n-                    }))).\n-                toArray(Object[][]::new);\n-    }\n-\n@@ -277,4 +239,4 @@\n-    static ByteBuffer toBuffer($type$[] a, IntFunction<ByteBuffer> fb) {\n-        ByteBuffer bb = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n-        for ($type$ v : a) {\n-            bb.{#if[byte]?put(v):put$Type$(v)};\n+    static MemorySegment toSegment($type$[] a, IntFunction<MemorySegment> fb) {\n+        MemorySegment ms = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n+        for (int i = 0; i < a.length; i++) {\n+            ms.set(ValueLayout.JAVA_$TYPE$, i * SPECIES.elementSize() \/ 8 , a[i]);\n@@ -282,8 +244,1 @@\n-        return bb.clear();\n-    }\n-\n-    static $type$[] bufferToArray(ByteBuffer bb) {\n-        $Type$Buffer db = bb{#if[byte]?;:.as$Type$Buffer();}\n-        $type$[] d = new $type$[db.capacity()];\n-        db.get(0, d);\n-        return d;\n+        return ms;\n@@ -292,11 +247,2 @@\n-    static byte[] toByteArray($type$[] a, IntFunction<byte[]> fb, ByteOrder bo) {\n-        byte[] b = fb.apply(a.length * SPECIES.elementSize() \/ 8);\n-#if[byte]\n-        $Type$Buffer bb = ByteBuffer.wrap(b, 0, b.length).order(bo);\n-#else[byte]\n-        $Type$Buffer bb = ByteBuffer.wrap(b, 0, b.length).order(bo).as$Type$Buffer();\n-#end[byte]\n-        for ($type$ v : a) {\n-            bb.put(v);\n-        }\n-        return b;\n+    static $type$[] segmentToArray(MemorySegment ms) {\n+        return ms.toArray(ValueLayout.JAVA_$TYPE$);\n@@ -342,12 +288,2 @@\n-    static $abstractvectortype$ fromByteArray(byte[] a, int i, ByteOrder bo) {\n-        return $abstractvectortype$.fromByteArray(SPECIES, a, i, bo);\n-    }\n-\n-    @DontInline\n-    static $abstractvectortype$ fromByteArray(byte[] a, int i, ByteOrder bo, VectorMask<$Boxtype$> m) {\n-        return $abstractvectortype$.fromByteArray(SPECIES, a, i, bo, m);\n-    }\n-\n-    @DontInline\n-    static void intoByteArray($abstractvectortype$ v, byte[] a, int i, ByteOrder bo) {\n-        v.intoByteArray(a, i, bo);\n+    static $abstractvectortype$ fromMemorySegment(MemorySegment a, int i, ByteOrder bo) {\n+        return $abstractvectortype$.fromMemorySegment(SPECIES, a, i, bo);\n@@ -357,2 +293,2 @@\n-    static void intoByteArray($abstractvectortype$ v, byte[] a, int i, ByteOrder bo, VectorMask<$Boxtype$> m) {\n-        v.intoByteArray(a, i, bo, m);\n+    static $abstractvectortype$ fromMemorySegment(MemorySegment a, int i, ByteOrder bo, VectorMask<$Boxtype$> m) {\n+        return $abstractvectortype$.fromMemorySegment(SPECIES, a, i, bo, m);\n@@ -362,2 +298,2 @@\n-    static $abstractvectortype$ fromByteBuffer(ByteBuffer a, int i, ByteOrder bo) {\n-        return $abstractvectortype$.fromByteBuffer(SPECIES, a, i, bo);\n+    static void intoMemorySegment($abstractvectortype$ v, MemorySegment a, int i, ByteOrder bo) {\n+        v.intoMemorySegment(a, i, bo);\n@@ -367,2 +303,2 @@\n-    static $abstractvectortype$ fromByteBuffer(ByteBuffer a, int i, ByteOrder bo, VectorMask<$Boxtype$> m) {\n-        return $abstractvectortype$.fromByteBuffer(SPECIES, a, i, bo, m);\n+    static void intoMemorySegment($abstractvectortype$ v, MemorySegment a, int i, ByteOrder bo, VectorMask<$Boxtype$> m) {\n+        v.intoMemorySegment(a, i, bo, m);\n@@ -371,11 +307,0 @@\n-    @DontInline\n-    static void intoByteBuffer($abstractvectortype$ v, ByteBuffer a, int i, ByteOrder bo) {\n-        v.intoByteBuffer(a, i, bo);\n-    }\n-\n-    @DontInline\n-    static void intoByteBuffer($abstractvectortype$ v, ByteBuffer a, int i, ByteOrder bo, VectorMask<$Boxtype$> m) {\n-        v.intoByteBuffer(a, i, bo, m);\n-    }\n-\n-\n@@ -552,6 +477,6 @@\n-    @Test(dataProvider = \"$type$ByteBufferProvider\")\n-    static void loadStoreByteBuffer(IntFunction<$type$[]> fa,\n-                                    IntFunction<ByteBuffer> fb,\n-                                    ByteOrder bo) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), fb);\n-        ByteBuffer r = fb.apply(a.limit());\n+    @Test(dataProvider = \"$type$MemorySegmentProvider\")\n+    static void loadStoreMemorySegment(IntFunction<$type$[]> fa,\n+                                       IntFunction<MemorySegment> fb,\n+                                       ByteOrder bo) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb);\n+        MemorySegment r = fb.apply((int) a.byteSize());\n@@ -559,1 +484,1 @@\n-        int l = a.limit();\n+        int l = (int) a.byteSize();\n@@ -564,2 +489,2 @@\n-                $abstractvectortype$ av = $abstractvectortype$.fromByteBuffer(SPECIES, a, i, bo);\n-                av.intoByteBuffer(r, i, bo);\n+                $abstractvectortype$ av = $abstractvectortype$.fromMemorySegment(SPECIES, a, i, bo);\n+                av.intoMemorySegment(r, i, bo);\n@@ -568,5 +493,2 @@\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        Assert.assertEquals(r, a, \"Buffers not equal\");\n+        long m = r.mismatch(a);\n+        Assert.assertEquals(m, -1, \"Segments not equal\");\n@@ -576,3 +498,3 @@\n-    static void loadByteBufferIOOBE(IntFunction<$type$[]> fa, IntFunction<Integer> fi) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n+    static void loadMemorySegmentIOOBE(IntFunction<$type$[]> fa, IntFunction<Integer> fi) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n@@ -580,1 +502,1 @@\n-        int l = a.limit();\n+        int l = (int) a.byteSize();\n@@ -585,2 +507,2 @@\n-                $abstractvectortype$ av = fromByteBuffer(a, i, ByteOrder.nativeOrder());\n-                av.intoByteBuffer(r, i, ByteOrder.nativeOrder());\n+                $abstractvectortype$ av = fromMemorySegment(a, i, ByteOrder.nativeOrder());\n+                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n@@ -590,2 +512,2 @@\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.limit());\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());\n@@ -593,1 +515,1 @@\n-            fromByteBuffer(a, index, ByteOrder.nativeOrder());\n+            fromMemorySegment(a, index, ByteOrder.nativeOrder());\n@@ -605,3 +527,3 @@\n-    static void storeByteBufferIOOBE(IntFunction<$type$[]> fa, IntFunction<Integer> fi) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n+    static void storeMemorySegmentIOOBE(IntFunction<$type$[]> fa, IntFunction<Integer> fi) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n@@ -609,1 +531,1 @@\n-        int l = a.limit();\n+        int l = (int) a.byteSize();\n@@ -614,2 +536,2 @@\n-                $abstractvectortype$ av = $abstractvectortype$.fromByteBuffer(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteBuffer(av, r, i, ByteOrder.nativeOrder());\n+                $abstractvectortype$ av = $abstractvectortype$.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+                intoMemorySegment(av, r, i, ByteOrder.nativeOrder());\n@@ -619,2 +541,2 @@\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.limit());\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, (int) a.byteSize());\n@@ -622,2 +544,2 @@\n-            $abstractvectortype$ av = $abstractvectortype$.fromByteBuffer(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteBuffer(av, r, index, ByteOrder.nativeOrder());\n+            $abstractvectortype$ av = $abstractvectortype$.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+            intoMemorySegment(av, r, index, ByteOrder.nativeOrder());\n@@ -634,6 +556,5 @@\n-\n-    @Test(dataProvider = \"$type$ByteBufferMaskProvider\")\n-    static void loadStoreByteBufferMask(IntFunction<$type$[]> fa,\n-                                        IntFunction<ByteBuffer> fb,\n-                                        IntFunction<boolean[]> fm,\n-                                        ByteOrder bo) {\n+    @Test(dataProvider = \"$type$MemorySegmentMaskProvider\")\n+    static void loadStoreMemorySegmentMask(IntFunction<$type$[]> fa,\n+                                           IntFunction<MemorySegment> fb,\n+                                           IntFunction<boolean[]> fm,\n+                                           ByteOrder bo) {\n@@ -641,2 +562,2 @@\n-        ByteBuffer a = toBuffer(_a, fb);\n-        ByteBuffer r = fb.apply(a.limit());\n+        MemorySegment a = toSegment(_a, fb);\n+        MemorySegment r = fb.apply((int) a.byteSize());\n@@ -646,1 +567,1 @@\n-        int l = a.limit();\n+        int l = (int) a.byteSize();\n@@ -651,2 +572,2 @@\n-                $abstractvectortype$ av = $abstractvectortype$.fromByteBuffer(SPECIES, a, i, bo, vmask);\n-                av.intoByteBuffer(r, i, bo);\n+                $abstractvectortype$ av = $abstractvectortype$.fromMemorySegment(SPECIES, a, i, bo, vmask);\n+                av.intoMemorySegment(r, i, bo);\n@@ -655,5 +576,1 @@\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        assertArraysEquals(bufferToArray(r), _a, mask);\n+        assertArraysEquals(segmentToArray(r), _a, mask);\n@@ -662,1 +579,1 @@\n-        r = fb.apply(a.limit());\n+        r = fb.apply((int) a.byteSize());\n@@ -666,2 +583,2 @@\n-                $abstractvectortype$ av = $abstractvectortype$.fromByteBuffer(SPECIES, a, i, bo);\n-                av.intoByteBuffer(r, i, bo, vmask);\n+                $abstractvectortype$ av = $abstractvectortype$.fromMemorySegment(SPECIES, a, i, bo);\n+                av.intoMemorySegment(r, i, bo, vmask);\n@@ -670,5 +587,1 @@\n-        Assert.assertEquals(a.position(), 0, \"Input buffer position changed\");\n-        Assert.assertEquals(a.limit(), l, \"Input buffer limit changed\");\n-        Assert.assertEquals(r.position(), 0, \"Result buffer position changed\");\n-        Assert.assertEquals(r.limit(), l, \"Result buffer limit changed\");\n-        assertArraysEquals(bufferToArray(r), _a, mask);\n+        assertArraysEquals(segmentToArray(r), _a, mask);\n@@ -678,3 +591,3 @@\n-    static void loadByteBufferMaskIOOBE(IntFunction<$type$[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n+    static void loadMemorySegmentMaskIOOBE(IntFunction<$type$[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n@@ -684,1 +597,1 @@\n-        int l = a.limit();\n+        int l = (int) a.byteSize();\n@@ -689,2 +602,2 @@\n-                $abstractvectortype$ av = fromByteBuffer(a, i, ByteOrder.nativeOrder(), vmask);\n-                av.intoByteBuffer(r, i, ByteOrder.nativeOrder());\n+                $abstractvectortype$ av = fromMemorySegment(a, i, ByteOrder.nativeOrder(), vmask);\n+                av.intoMemorySegment(r, i, ByteOrder.nativeOrder());\n@@ -694,2 +607,2 @@\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.limit(), SPECIES.elementSize() \/ 8);\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() \/ 8);\n@@ -697,1 +610,1 @@\n-            fromByteBuffer(a, index, ByteOrder.nativeOrder(), vmask);\n+            fromMemorySegment(a, index, ByteOrder.nativeOrder(), vmask);\n@@ -709,3 +622,3 @@\n-    static void storeByteBufferMaskIOOBE(IntFunction<$type$[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), ByteBuffer::allocateDirect);\n-        ByteBuffer r = ByteBuffer.allocateDirect(a.limit());\n+    static void storeMemorySegmentMaskIOOBE(IntFunction<$type$[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope()));\n+        MemorySegment r = MemorySegment.allocateNative(a.byteSize(), ResourceScope.newImplicitScope());\n@@ -715,112 +628,1 @@\n-        int l = a.limit();\n-        int s = SPECIES.vectorByteSize();\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                $abstractvectortype$ av = $abstractvectortype$.fromByteBuffer(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteBuffer(av, r, i, ByteOrder.nativeOrder(), vmask);\n-            }\n-        }\n-\n-        int index = fi.apply(a.limit());\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.limit(), SPECIES.elementSize() \/ 8);\n-        try {\n-            $abstractvectortype$ av = $abstractvectortype$.fromByteBuffer(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteBuffer(av, a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"$type$ByteBufferProvider\")\n-    static void loadStoreReadonlyByteBuffer(IntFunction<$type$[]> fa,\n-                                    IntFunction<ByteBuffer> fb,\n-                                    ByteOrder bo) {\n-        ByteBuffer a = toBuffer(fa.apply(SPECIES.length()), fb).asReadOnlyBuffer();\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo);\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, SPECIES.maskAll(true));\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, SPECIES.maskAll(false));\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-\n-        try {\n-            VectorMask<$Boxtype$> m = SPECIES.shuffleFromOp(i -> i % 2 == 0 ? 1 : -1)\n-                    .laneIsValid();\n-            SPECIES.zero().intoByteBuffer(a, 0, bo, m);\n-            Assert.fail(\"ReadOnlyBufferException expected\");\n-        } catch (ReadOnlyBufferException e) {\n-        }\n-    }\n-\n-\n-    @Test(dataProvider = \"$type$ByteArrayProvider\")\n-    static void loadStoreByteArray(IntFunction<$type$[]> fa,\n-                                    ByteOrder bo) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, bo);\n-        byte[] r = new byte[a.length];\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                $abstractvectortype$ av = $abstractvectortype$.fromByteArray(SPECIES, a, i, bo);\n-                av.intoByteArray(r, i, bo);\n-            }\n-        }\n-        Assert.assertEquals(r, a, \"Byte arrays not equal\");\n-    }\n-\n-    @Test(dataProvider = \"$type$ByteProviderForIOOBE\")\n-    static void loadByteArrayIOOBE(IntFunction<$type$[]> fa, IntFunction<Integer> fi) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                $abstractvectortype$ av = fromByteArray(a, i, ByteOrder.nativeOrder());\n-                av.intoByteArray(r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.length);\n-        try {\n-            fromByteArray(a, index, ByteOrder.nativeOrder());\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-    @Test(dataProvider = \"$type$ByteProviderForIOOBE\")\n-    static void storeByteArrayIOOBE(IntFunction<$type$[]> fa, IntFunction<Integer> fi) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-\n+        int l = (int) a.byteSize();\n@@ -828,1 +630,0 @@\n-        int l = a.length;\n@@ -832,2 +633,2 @@\n-                $abstractvectortype$ av = $abstractvectortype$.fromByteArray(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteArray(av, r, i, ByteOrder.nativeOrder());\n+                $abstractvectortype$ av = $abstractvectortype$.fromMemorySegment(SPECIES, a, i, ByteOrder.nativeOrder());\n+                intoMemorySegment(av, r, i, ByteOrder.nativeOrder(), vmask);\n@@ -837,2 +638,2 @@\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBounds(SPECIES.vectorByteSize(), index, a.length);\n+        int index = fi.apply((int) a.byteSize());\n+        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, (int) a.byteSize(), SPECIES.elementSize() \/ 8);\n@@ -840,2 +641,2 @@\n-            $abstractvectortype$ av = $abstractvectortype$.fromByteArray(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteArray(av, r, index, ByteOrder.nativeOrder());\n+            $abstractvectortype$ av = $abstractvectortype$.fromMemorySegment(SPECIES, a, 0, ByteOrder.nativeOrder());\n+            intoMemorySegment(av, a, index, ByteOrder.nativeOrder(), vmask);\n@@ -852,0 +653,5 @@\n+    @Test(dataProvider = \"$type$MemorySegmentProvider\")\n+    static void loadStoreReadonlyMemorySegment(IntFunction<$type$[]> fa,\n+                                               IntFunction<MemorySegment> fb,\n+                                               ByteOrder bo) {\n+        MemorySegment a = toSegment(fa.apply(SPECIES.length()), fb).asReadOnly();\n@@ -853,19 +659,4 @@\n-    @Test(dataProvider = \"$type$ByteArrayMaskProvider\")\n-    static void loadStoreByteArrayMask(IntFunction<$type$[]> fa,\n-                                  IntFunction<boolean[]> fm,\n-                                  ByteOrder bo) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, bo);\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<$Boxtype$> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-          for (int i = 0; i < l; i += s) {\n-              $abstractvectortype$ av = $abstractvectortype$.fromByteArray(SPECIES, a, i, bo, vmask);\n-              av.intoByteArray(r, i, bo);\n-          }\n-        }\n-        assertArraysEquals(r, a, mask);\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo)\n+        );\n@@ -873,0 +664,4 @@\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(true))\n+        );\n@@ -874,1 +669,4 @@\n-        r = new byte[a.length];\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, SPECIES.maskAll(false))\n+        );\n@@ -876,7 +674,6 @@\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                $abstractvectortype$ av = $abstractvectortype$.fromByteArray(SPECIES, a, i, bo);\n-                av.intoByteArray(r, i, bo, vmask);\n-            }\n-        }\n-        assertArraysEquals(r, a, mask);\n+        VectorMask<$Boxtype$> m = SPECIES.shuffleFromOp(i -> i % 2 == 0 ? 1 : -1)\n+                .laneIsValid();\n+        Assert.assertThrows(\n+                UnsupportedOperationException.class,\n+                () -> SPECIES.zero().intoMemorySegment(a, 0, bo, m)\n+        );\n@@ -885,62 +682,0 @@\n-    @Test(dataProvider = \"$type$ByteMaskProviderForIOOBE\")\n-    static void loadByteArrayMaskIOOBE(IntFunction<$type$[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<$Boxtype$> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                $abstractvectortype$ av = fromByteArray(a, i, ByteOrder.nativeOrder(), vmask);\n-                av.intoByteArray(r, i, ByteOrder.nativeOrder());\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length, SPECIES.elementSize() \/ 8);\n-        try {\n-            fromByteArray(a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n-\n-    @Test(dataProvider = \"$type$ByteMaskProviderForIOOBE\")\n-    static void storeByteArrayMaskIOOBE(IntFunction<$type$[]> fa, IntFunction<Integer> fi, IntFunction<boolean[]> fm) {\n-        byte[] a = toByteArray(fa.apply(SPECIES.length()), byte[]::new, ByteOrder.nativeOrder());\n-        byte[] r = new byte[a.length];\n-        boolean[] mask = fm.apply(SPECIES.length());\n-        VectorMask<$Boxtype$> vmask = VectorMask.fromValues(SPECIES, mask);\n-\n-        int s = SPECIES.vectorByteSize();\n-        int l = a.length;\n-\n-        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n-            for (int i = 0; i < l; i += s) {\n-                $abstractvectortype$ av = $abstractvectortype$.fromByteArray(SPECIES, a, i, ByteOrder.nativeOrder());\n-                intoByteArray(av, r, i, ByteOrder.nativeOrder(), vmask);\n-            }\n-        }\n-\n-        int index = fi.apply(a.length);\n-        boolean shouldFail = isIndexOutOfBoundsForMask(mask, index, a.length, SPECIES.elementSize() \/ 8);\n-        try {\n-            $abstractvectortype$ av = $abstractvectortype$.fromByteArray(SPECIES, a, 0, ByteOrder.nativeOrder());\n-            intoByteArray(av, a, index, ByteOrder.nativeOrder(), vmask);\n-            if (shouldFail) {\n-                Assert.fail(\"Failed to throw IndexOutOfBoundsException\");\n-            }\n-        } catch (IndexOutOfBoundsException e) {\n-            if (!shouldFail) {\n-                Assert.fail(\"Unexpected IndexOutOfBoundsException\");\n-            }\n-        }\n-    }\n@@ -962,0 +697,1 @@\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/X-LoadStoreTest.java.template","additions":112,"deletions":376,"binary":false,"changes":488,"status":"modified"},{"patch":"@@ -66,1 +66,1 @@\n-                    \"hv\"\n+                    \"hv\",           \"fsrm\",             \"avx512_bitalg\",     \"gfni\"\n","filename":"test\/lib-test\/jdk\/test\/whitebox\/CPUInfoTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,224 @@\n+\/*\n+ *  Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector;\n+\n+import jdk.incubator.vector.*;\n+import java.util.concurrent.TimeUnit;\n+import org.openjdk.jmh.annotations.*;\n+\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Thread)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class MaskCastOperationsBenchmark {\n+    VectorMask<Byte> bmask64;\n+    VectorMask<Byte> bmask128;\n+    VectorMask<Byte> bmask256;\n+\n+    VectorMask<Short> smask64;\n+    VectorMask<Short> smask128;\n+    VectorMask<Short> smask256;\n+    VectorMask<Short> smask512;\n+\n+    VectorMask<Integer> imask64;\n+    VectorMask<Integer> imask128;\n+    VectorMask<Integer> imask256;\n+    VectorMask<Integer> imask512;\n+\n+    VectorMask<Long> lmask128;\n+    VectorMask<Long> lmask256;\n+    VectorMask<Long> lmask512;\n+\n+    static final boolean [] mask_arr = {\n+       false, false, false, true, false, false, false, false,\n+       false, false, false, true, false, false, false, false,\n+       false, false, false, true, false, false, false, false,\n+       true, true, true, true, true, true, true, true,\n+       true, true, true, true, true, true, true, true,\n+       false, false, false, true, false, false, false, false,\n+       false, false, false, true, false, false, false, false,\n+       false, false, false, true, false, false, false, false\n+    };\n+\n+    @Setup(Level.Trial)\n+    public void BmSetup() {\n+        bmask64 = VectorMask.fromArray(ByteVector.SPECIES_64, mask_arr, 0);\n+        bmask128 = VectorMask.fromArray(ByteVector.SPECIES_128, mask_arr, 0);\n+        bmask256 = VectorMask.fromArray(ByteVector.SPECIES_256, mask_arr, 0);\n+\n+        smask64 = VectorMask.fromArray(ShortVector.SPECIES_64, mask_arr, 0);\n+        smask128 = VectorMask.fromArray(ShortVector.SPECIES_128, mask_arr, 0);\n+        smask256 = VectorMask.fromArray(ShortVector.SPECIES_256, mask_arr, 0);\n+        smask512 = VectorMask.fromArray(ShortVector.SPECIES_512, mask_arr, 0);\n+\n+        imask64 = VectorMask.fromArray(IntVector.SPECIES_64, mask_arr, 0);\n+        imask128 = VectorMask.fromArray(IntVector.SPECIES_128, mask_arr, 0);\n+        imask256 = VectorMask.fromArray(IntVector.SPECIES_256, mask_arr, 0);\n+        imask512 = VectorMask.fromArray(IntVector.SPECIES_512, mask_arr, 0);\n+\n+        lmask128 = VectorMask.fromArray(LongVector.SPECIES_128, mask_arr, 0);\n+        lmask256 = VectorMask.fromArray(LongVector.SPECIES_256, mask_arr, 0);\n+        lmask512 = VectorMask.fromArray(LongVector.SPECIES_512, mask_arr, 0);\n+    }\n+\n+    @Benchmark\n+    public VectorMask<Short> microMaskCastByte64ToShort128() {\n+        return bmask64.cast(ShortVector.SPECIES_128);\n+    }\n+\n+    @Benchmark\n+    public VectorMask<Integer> microMaskCastByte64ToInteger256() {\n+        return bmask64.cast(IntVector.SPECIES_256);\n+    }\n+\n+    @Benchmark\n+    public VectorMask<Long> microMaskCastByte64ToLong512() {\n+        return bmask64.cast(LongVector.SPECIES_512);\n+    }\n+\n+    @Benchmark\n+    public VectorMask<Short> microMaskCastByte128ToShort256() {\n+        return bmask128.cast(ShortVector.SPECIES_256);\n+    }\n+\n+    @Benchmark\n+    public VectorMask<Integer> microMaskCastByte128ToInteger512() {\n+        return bmask128.cast(IntVector.SPECIES_512);\n+    }\n+\n+    @Benchmark\n+    public VectorMask<Short> microMaskCastByte256ToShort512() {\n+        return bmask256.cast(ShortVector.SPECIES_512);\n+    }\n+\n+    @Benchmark\n+    public VectorMask<Integer> microMaskCastShort64ToInteger128() {\n+        return smask64.cast(IntVector.SPECIES_128);\n+    }\n+\n+    @Benchmark\n+    public VectorMask<Long> microMaskCastShort64ToLong256() {\n+        return smask64.cast(LongVector.SPECIES_256);\n+    }\n+\n+    @Benchmark\n+    public VectorMask<Byte> microMaskCastShort128ToByte64() {\n+        return smask128.cast(ByteVector.SPECIES_64);\n+    }\n+\n+    @Benchmark\n+    public VectorMask<Integer> microMaskCastShort128ToInteger256() {\n+        return smask128.cast(IntVector.SPECIES_256);\n+    }\n+\n+    @Benchmark\n+    public VectorMask<Long> microMaskCastShort128ToLong512() {\n+        return smask128.cast(LongVector.SPECIES_512);\n+    }\n+\n+    @Benchmark\n+    public VectorMask<Byte> microMaskCastShort256ToByte128() {\n+        return smask256.cast(ByteVector.SPECIES_128);\n+    }\n+\n+    @Benchmark\n+    public VectorMask<Integer> microMaskCastShort256ToInteger512() {\n+        return smask256.cast(IntVector.SPECIES_512);\n+    }\n+\n+    @Benchmark\n+    public VectorMask<Byte> microMaskCastShort512ToByte256() {\n+        return smask512.cast(ByteVector.SPECIES_256);\n+    }\n+\n+    @Benchmark\n+    public VectorMask<Long> microMaskCastInteger64ToLong128() {\n+        return imask64.cast(LongVector.SPECIES_128);\n+    }\n+\n+    @Benchmark\n+    public VectorMask<Short> microMaskCastInteger128ToShort64() {\n+        return imask128.cast(ShortVector.SPECIES_64);\n+    }\n+\n+    @Benchmark\n+    public VectorMask<Long> microMaskCastInteger128ToLong256() {\n+        return imask128.cast(LongVector.SPECIES_256);\n+    }\n+\n+    @Benchmark\n+    public VectorMask<Byte> microMaskCastInteger256ToByte64() {\n+        return imask256.cast(ByteVector.SPECIES_64);\n+    }\n+\n+    @Benchmark\n+    public VectorMask<Short> microMaskCastInteger256ToShort128() {\n+        return imask256.cast(ShortVector.SPECIES_128);\n+    }\n+\n+    @Benchmark\n+    public VectorMask<Long> microMaskCastInteger256ToLong512() {\n+        return imask256.cast(LongVector.SPECIES_512);\n+    }\n+\n+    @Benchmark\n+    public VectorMask<Byte> microMaskCastInteger512ToByte128() {\n+        return imask512.cast(ByteVector.SPECIES_128);\n+    }\n+\n+    @Benchmark\n+    public VectorMask<Short> microMaskCastInteger512ToShort256() {\n+        return imask512.cast(ShortVector.SPECIES_256);\n+    }\n+\n+    @Benchmark\n+    public VectorMask<Integer> microMaskCastLong128ToInteger64() {\n+        return lmask128.cast(IntVector.SPECIES_64);\n+    }\n+\n+    @Benchmark\n+    public VectorMask<Short> microMaskCastLong256ToShort64() {\n+        return lmask256.cast(ShortVector.SPECIES_64);\n+    }\n+\n+    @Benchmark\n+    public VectorMask<Integer> microMaskCastLong256ToInteger128() {\n+        return lmask256.cast(IntVector.SPECIES_128);\n+    }\n+\n+    @Benchmark\n+    public VectorMask<Byte> microMaskCastLong512ToByte64() {\n+        return lmask512.cast(ByteVector.SPECIES_64);\n+    }\n+\n+    @Benchmark\n+    public VectorMask<Short> microMaskCastLong512ToShort128() {\n+        return lmask512.cast(ShortVector.SPECIES_128);\n+    }\n+\n+    @Benchmark\n+    public VectorMask<Integer> microMaskCastLong512ToInteger256() {\n+        return lmask512.cast(IntVector.SPECIES_256);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/MaskCastOperationsBenchmark.java","additions":224,"deletions":0,"binary":false,"changes":224,"status":"added"},{"patch":"@@ -158,0 +158,19 @@\n+\n+    @Benchmark\n+    public long testToLongByte(Blackhole bh) {\n+        return bmask.toLong();\n+    }\n+\n+    @Benchmark\n+    public long testToLongShort(Blackhole bh) {\n+        return smask.toLong();\n+    }\n+    @Benchmark\n+    public long testToLongInt(Blackhole bh) {\n+        return imask.toLong();\n+    }\n+    @Benchmark\n+    public long testToLongLong(Blackhole bh) {\n+        return lmask.toLong();\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/MaskQueryOperationsBenchmark.java","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -0,0 +1,164 @@\n+\/*\n+ *  Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2021, Rado Smogura. All rights reserved.\n+ *\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+package org.openjdk.bench.jdk.incubator.vector;\n+\n+import java.nio.ByteOrder;\n+import java.util.concurrent.TimeUnit;\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.vector.ByteVector;\n+import jdk.incubator.vector.VectorSpecies;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@State(org.openjdk.jmh.annotations.Scope.Benchmark)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Fork(value = 1, jvmArgsAppend = {\n+    \"--add-modules=jdk.incubator.foreign,jdk.incubator.vector\",\n+    \"-Dforeign.restricted=permit\",\n+    \"--enable-native-access\", \"ALL-UNNAMED\"})\n+public class MemorySegmentVectorAccess {\n+  private static final VectorSpecies<Byte> SPECIES = VectorSpecies.ofLargestShape(byte.class);\n+\n+  @Param(\"1024\")\n+  private int size;\n+\n+  byte[] byteIn;\n+  byte[] byteOut;\n+\n+  MemorySegment nativeIn, nativeOut;\n+  MemorySegment heapIn, heapOut;\n+\n+  MemorySegment nativeInRo, nativeOutRo;\n+  MemorySegment heapInRo, heapOutRo;\n+\n+  @Setup\n+  public void setup() {\n+    nativeIn = MemorySegment.allocateNative(size, ResourceScope.newImplicitScope());\n+    nativeOut = MemorySegment.allocateNative(size, ResourceScope.newImplicitScope());\n+\n+    byteIn = new byte[size];\n+    byteOut = new byte[size];\n+\n+    heapIn = MemorySegment.ofArray(byteIn);\n+    heapOut = MemorySegment.ofArray(byteOut);\n+\n+    nativeInRo = nativeIn.asReadOnly();\n+    nativeOutRo = nativeOut.asReadOnly();\n+\n+    heapInRo = heapIn.asReadOnly();\n+    heapOutRo = heapOut.asReadOnly();\n+  }\n+\n+  @Benchmark\n+  public void directSegments() {\n+    copyMemory(nativeIn, nativeOut);\n+  }\n+\n+  @Benchmark\n+  public void heapSegments() {\n+    copyMemory(heapIn, heapOut);\n+  }\n+\n+  @Benchmark\n+  public void pollutedSegments2() {\n+    copyIntoNotInlined(nativeIn, nativeOut);\n+    copyIntoNotInlined(heapIn, heapOut);\n+  }\n+\n+  @Benchmark\n+  public void pollutedSegments3() {\n+    copyIntoNotInlined(nativeIn, nativeOut);\n+    copyIntoNotInlined(heapIn, heapOut);\n+\n+    copyIntoNotInlined(nativeInRo, nativeOut);\n+    copyIntoNotInlined(heapInRo, heapOut);\n+  }\n+\n+  @Benchmark\n+  public void pollutedSegments4() {\n+    copyIntoNotInlined(nativeIn, heapOut); \/\/ Pollute if unswitch on 2nd param\n+    copyIntoNotInlined(heapIn, heapOut);\n+\n+    copyIntoNotInlined(heapIn, nativeIn); \/\/ Pollute if unswitch on 1st param\n+    copyIntoNotInlined(heapIn, nativeOut);\n+  }\n+\n+\n+  boolean readOnlyException;\n+\n+  @Benchmark\n+  public void pollutedSegments5() {\n+    copyIntoNotInlined(nativeIn, heapOut);\n+    copyIntoNotInlined(heapIn, heapOut);\n+\n+    copyIntoNotInlined(heapIn, nativeIn);\n+    copyIntoNotInlined(heapIn, nativeOut);\n+\n+    if (readOnlyException) {\n+      try {\n+        copyIntoNotInlined(heapIn, nativeOutRo);\n+      } catch (Exception ignored) {}\n+      readOnlyException = !readOnlyException;\n+    }\n+  }\n+\n+  @Benchmark\n+  public void arrayCopy() {\n+    byte[] in = byteIn;\n+    byte[] out = byteOut;\n+\n+    for (int i = 0; i < SPECIES.loopBound(in.length); i += SPECIES.vectorByteSize()) {\n+      final var v = ByteVector.fromArray(SPECIES, in, i);\n+      v.intoArray(out, i);\n+    }\n+  }\n+\n+  @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+  protected void copyIntoNotInlined(MemorySegment in, MemorySegment out) {\n+    copyMemory(in, out);\n+  }\n+\n+  @CompilerControl(CompilerControl.Mode.INLINE)\n+  protected void copyMemory(MemorySegment in, MemorySegment out) {\n+    for (long i = 0; i < SPECIES.loopBound(in.byteSize()); i += SPECIES.vectorByteSize()) {\n+      final var v = ByteVector.fromMemorySegment(SPECIES, in, i, ByteOrder.nativeOrder());\n+      v.intoMemorySegment(out, i, ByteOrder.nativeOrder());\n+    }\n+  }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/MemorySegmentVectorAccess.java","additions":164,"deletions":0,"binary":false,"changes":164,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n-import java.nio.ByteBuffer;\n@@ -70,1 +69,1 @@\n-  private ByteBuffer srcBufferHeap;\n+  private MemorySegment srcSegmentHeap;\n@@ -72,5 +71,1 @@\n-  private ByteBuffer dstBufferHeap;\n-\n-  private ByteBuffer srcBufferNative;\n-\n-  private ByteBuffer dstBufferNative;\n+  private MemorySegment dstSegmentHeap;\n@@ -81,3 +76,1 @@\n-  private MemorySegment srcSegmentImplicit;\n-\n-  private MemorySegment dstSegmentImplicit;\n+  private MemorySegment srcSegment;\n@@ -85,3 +78,1 @@\n-  private ByteBuffer srcBufferSegmentImplicit;\n-\n-  private ByteBuffer dstBufferSegmentImplicit;\n+  private MemorySegment dstSegment;\n@@ -94,1 +85,1 @@\n-  byte[] a, b, c;\n+  private byte[] a, b, c;\n@@ -104,7 +95,2 @@\n-\n-    srcBufferHeap = ByteBuffer.allocate(size);\n-    dstBufferHeap = ByteBuffer.allocate(size);\n-\n-    srcBufferNative = ByteBuffer.allocateDirect(size);\n-    dstBufferNative = ByteBuffer.allocateDirect(size);\n-\n+    srcSegmentHeap = MemorySegment.ofArray(new byte[size]);\n+    dstSegmentHeap = MemorySegment.ofArray(new byte[size]);\n@@ -113,4 +99,2 @@\n-    srcSegmentImplicit = MemorySegment.allocateNative(size, SPECIES.vectorByteSize(), implicitScope);\n-    srcBufferSegmentImplicit = srcSegmentImplicit.asByteBuffer();\n-    dstSegmentImplicit = MemorySegment.allocateNative(size, SPECIES.vectorByteSize(), implicitScope);\n-    dstBufferSegmentImplicit = dstSegmentImplicit.asByteBuffer();\n+    srcSegment = MemorySegment.allocateNative(size, SPECIES.vectorByteSize(), implicitScope);\n+    dstSegment = MemorySegment.allocateNative(size, SPECIES.vectorByteSize(), implicitScope);\n@@ -118,3 +102,2 @@\n-\n-    srcAddress = MemorySegment.allocateNative(size, implicitScope).address();\n-    dstAddress = MemorySegment.allocateNative(size, implicitScope).address();\n+    srcAddress = srcSegment.address();\n+    dstAddress = dstSegment.address();\n@@ -130,1 +113,0 @@\n-\/\/    final var srcArray = this.srcArray;\n@@ -137,9 +119,0 @@\n-  @Benchmark\n-  public void array2() {\n-\/\/    final var srcArray = this.srcArray;\n-    for (int i = 0; i < SPECIES.loopBound(srcArray.length); i += SPECIES.length()) {\n-      var v = ByteVector.fromByteArray(SPECIES, srcArray, i, ByteOrder.nativeOrder());\n-      v.intoByteArray(dstArray, i, ByteOrder.nativeOrder());\n-    }\n-  }\n-\n@@ -190,38 +163,4 @@\n-  public void bufferHeap() {\n-    for (int i = 0; i < SPECIES.loopBound(srcArray.length); i += SPECIES.length()) {\n-      var v = ByteVector.fromByteBuffer(SPECIES, srcBufferHeap, i, ByteOrder.nativeOrder());\n-      v.intoByteBuffer(dstBufferHeap, i, ByteOrder.nativeOrder());\n-    }\n-  }\n-\n-  @Benchmark\n-  public void bufferHeapScalar() {\n-    for (int i = 0; i < SPECIES.loopBound(srcArray.length); i++) {\n-      var v = srcBufferHeap.get(i);\n-      dstBufferHeap.put(i, v);\n-    }\n-  }\n-\n-  @Benchmark\n-  @CompilerControl(CompilerControl.Mode.PRINT)\n-  public void bufferNative() {\n-    for (int i = 0; i < SPECIES.loopBound(srcArray.length); i += SPECIES.length()) {\n-      var v = ByteVector.fromByteBuffer(SPECIES, srcBufferNative, i, ByteOrder.nativeOrder());\n-      v.intoByteBuffer(dstBufferNative, i, ByteOrder.nativeOrder());\n-    }\n-  }\n-\n-  @Benchmark\n-  public void bufferNativeScalar() {\n-    for (int i = 0; i < SPECIES.loopBound(srcArray.length); i++) {\n-      var v = srcBufferNative.get(i);\n-      dstBufferNative.put(i, v);\n-    }\n-  }\n-\n-\n-  @Benchmark\n-  public void bufferSegmentImplicit() {\n-    for (int i = 0; i < SPECIES.loopBound(srcArray.length); i += SPECIES.length()) {\n-      var v = ByteVector.fromByteBuffer(SPECIES, srcBufferSegmentImplicit, i, ByteOrder.nativeOrder());\n-      v.intoByteBuffer(dstBufferSegmentImplicit, i, ByteOrder.nativeOrder());\n+  public void segmentHeap() {\n+    for (long i = 0; i < SPECIES.loopBound(srcArray.length); i += SPECIES.length()) {\n+      var v = ByteVector.fromMemorySegment(SPECIES, srcSegmentHeap, i, ByteOrder.nativeOrder());\n+      v.intoMemorySegment(dstSegmentHeap, i, ByteOrder.nativeOrder());\n@@ -232,5 +171,4 @@\n-  @CompilerControl(CompilerControl.Mode.PRINT)\n-  public void segmentImplicitScalar() {\n-    for (int i = 0; i < SPECIES.loopBound(srcArray.length); i++) {\n-      var v = srcSegmentImplicit.get(JAVA_BYTE, i);\n-      dstSegmentImplicit.set(JAVA_BYTE, i, v);\n+  public void segmentNativeImplicit() {\n+    for (long i = 0; i < SPECIES.loopBound(srcArray.length); i += SPECIES.length()) {\n+      var v = ByteVector.fromMemorySegment(SPECIES, srcSegment, i, ByteOrder.nativeOrder());\n+      v.intoMemorySegment(dstSegment, i, ByteOrder.nativeOrder());\n@@ -241,1 +179,1 @@\n-  public void bufferSegmentConfined() {\n+  public void segmentNativeConfined() {\n@@ -243,2 +181,2 @@\n-      final var srcBufferSegmentConfined = MemorySegment.ofAddress(srcAddress, size, scope).asByteBuffer();\n-      final var dstBufferSegmentConfined = MemorySegment.ofAddress(dstAddress, size, scope).asByteBuffer();\n+      final var srcSegmentConfined = MemorySegment.ofAddress(srcAddress, size, scope);\n+      final var dstSegmentConfined = MemorySegment.ofAddress(dstAddress, size, scope);\n@@ -246,3 +184,3 @@\n-      for (int i = 0; i < SPECIES.loopBound(srcArray.length); i += SPECIES.length()) {\n-        var v = ByteVector.fromByteBuffer(SPECIES, srcBufferSegmentConfined, i, ByteOrder.nativeOrder());\n-        v.intoByteBuffer(dstBufferSegmentConfined, i, ByteOrder.nativeOrder());\n+      for (long i = 0; i < SPECIES.loopBound(srcArray.length); i += SPECIES.length()) {\n+        var v = ByteVector.fromMemorySegment(SPECIES, srcSegmentConfined, i, ByteOrder.nativeOrder());\n+        v.intoMemorySegment(dstSegmentConfined, i, ByteOrder.nativeOrder());\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/TestLoadStoreBytes.java","additions":26,"deletions":88,"binary":false,"changes":114,"status":"modified"},{"patch":"@@ -1,222 +0,0 @@\n-\/*\n- *  Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\n- *\/\n-package org.openjdk.bench.jdk.incubator.vector;\n-\n-import java.nio.ByteBuffer;\n-import java.nio.ByteOrder;\n-import java.util.concurrent.TimeUnit;\n-\n-import jdk.incubator.foreign.MemoryAddress;\n-import jdk.incubator.foreign.MemorySegment;\n-import jdk.incubator.foreign.ResourceScope;\n-import jdk.incubator.vector.ShortVector;\n-import jdk.incubator.vector.VectorOperators;\n-import jdk.incubator.vector.VectorSpecies;\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.BenchmarkMode;\n-import org.openjdk.jmh.annotations.CompilerControl;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Measurement;\n-import org.openjdk.jmh.annotations.Mode;\n-import org.openjdk.jmh.annotations.OutputTimeUnit;\n-import org.openjdk.jmh.annotations.Param;\n-import org.openjdk.jmh.annotations.Setup;\n-import org.openjdk.jmh.annotations.State;\n-import org.openjdk.jmh.annotations.TearDown;\n-import org.openjdk.jmh.annotations.Warmup;\n-\n-@BenchmarkMode(Mode.AverageTime)\n-@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n-@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n-@State(org.openjdk.jmh.annotations.Scope.Thread)\n-@OutputTimeUnit(TimeUnit.NANOSECONDS)\n-@Fork(value = 1, jvmArgsAppend = {\n-    \"--add-modules=jdk.incubator.foreign,jdk.incubator.vector\",\n-    \"-Dforeign.restricted=permit\",\n-    \"--enable-native-access\", \"ALL-UNNAMED\"})\n-public class TestLoadStoreShort {\n-  private static final VectorSpecies<Short> SPECIES = VectorSpecies.ofLargestShape(short.class);\n-\n-  @Param(\"256\")\n-  private int size;\n-\n-  private int longSize;\n-\n-  private short[] srcArray;\n-\n-  private short[] dstArray;\n-\n-\n-  private ByteBuffer srcBufferHeap;\n-\n-  private ByteBuffer dstBufferHeap;\n-\n-  private ByteBuffer srcBufferNative;\n-\n-  private ByteBuffer dstBufferNative;\n-\n-\n-  private ResourceScope implicitScope;\n-\n-  private MemorySegment srcSegmentImplicit;\n-\n-  private MemorySegment dstSegmentImplicit;\n-\n-  private ByteBuffer srcBufferSegmentImplicit;\n-\n-  private ByteBuffer dstBufferSegmentImplicit;\n-\n-\n-  private MemoryAddress srcAddress;\n-\n-  private MemoryAddress dstAddress;\n-\n-\/\/  private byte[] bigArray = new byte[Integer.MAX_VALUE];\n-\n-  private volatile short[] a, b, c;\n-  @Setup\n-  public void setup() {\n-    var longSize = size \/ Short.BYTES;\n-    srcArray = new short[longSize];\n-    dstArray = srcArray.clone();\n-    for (int i = 0; i < srcArray.length; i++) {\n-      srcArray[i] = (short) i;\n-    }\n-\n-\n-    srcBufferHeap = ByteBuffer.allocate(size);\n-    dstBufferHeap = ByteBuffer.allocate(size);\n-\n-    srcBufferNative = ByteBuffer.allocateDirect(size);\n-    dstBufferNative = ByteBuffer.allocateDirect(size);\n-\n-\n-    implicitScope = ResourceScope.newSharedScope();\n-    srcSegmentImplicit = MemorySegment.allocateNative(size, SPECIES.vectorByteSize(), implicitScope);\n-    srcBufferSegmentImplicit = srcSegmentImplicit.asByteBuffer();\n-    dstSegmentImplicit = MemorySegment.allocateNative(size, SPECIES.vectorByteSize(), implicitScope);\n-    dstBufferSegmentImplicit = dstSegmentImplicit.asByteBuffer();\n-\n-\n-    srcAddress = MemorySegment.allocateNative(size, implicitScope).address();\n-    dstAddress = MemorySegment.allocateNative(size, implicitScope).address();\n-\n-    this.longSize = longSize;\n-\n-    a = new short[size];\n-    b = new short[size];\n-    c = new short[size];\n-\n-  }\n-\n-  @Benchmark\n-  @CompilerControl(CompilerControl.Mode.PRINT)\n-  public void array() {\n-    for (int i = 0; i < SPECIES.loopBound(srcArray.length); i += SPECIES.length()) {\n-      var v = ShortVector.fromArray(SPECIES, srcArray, i);\n-      v.intoArray(dstArray, i);\n-    }\n-  }\n-\n-  @Benchmark\n-  public void vectAdd1() {\n-    var a = this.a;\n-    var b = this.b;\n-    var c = this.c;\n-\n-    for (int i = 0; i < a.length; i += SPECIES.length()) {\n-      ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n-      ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n-      av.lanewise(VectorOperators.ADD, bv).intoArray(c, i);\n-    }\n-  }\n-\n-  @Benchmark\n-  public void vectAdd2() {\n-    var a = this.a;\n-    var b = this.b;\n-    var c = this.c;\n-\n-    for (int i = 0; i < a.length\/SPECIES.length(); i++) {\n-      ShortVector av = ShortVector.fromArray(SPECIES, a, (i*SPECIES.length()));\n-      ShortVector bv = ShortVector.fromArray(SPECIES, b, (i*SPECIES.length()));\n-      av.lanewise(VectorOperators.ADD, bv).intoArray(c, (i*SPECIES.length()));\n-    }\n-  }\n-\n-  @Benchmark\n-  public void arrayAdd() {\n-    for (int i = 0; i < SPECIES.loopBound(srcArray.length); i += SPECIES.length()) {\n-      var v = ShortVector.fromArray(SPECIES, srcArray, i);\n-      v = v.add(v);\n-      v.intoArray(dstArray, i);\n-    }\n-  }\n-\n-  @Benchmark\n-  public void bufferHeap() {\n-    for (int i = 0; i < SPECIES.loopBound(longSize); i += SPECIES.length()) {\n-      var v = ShortVector.fromByteBuffer(SPECIES, srcBufferHeap, i, ByteOrder.nativeOrder());\n-      v.intoByteBuffer(dstBufferHeap, i, ByteOrder.nativeOrder());\n-    }\n-  }\n-\n-  @Benchmark\n-  public void bufferNative() {\n-    for (int i = 0; i < SPECIES.loopBound(srcArray.length); i += SPECIES.length()) {\n-      var v = ShortVector.fromByteBuffer(SPECIES, srcBufferNative, i, ByteOrder.nativeOrder());\n-      v.intoByteBuffer(dstBufferNative, i, ByteOrder.nativeOrder());\n-    }\n-  }\n-\n-  @Benchmark\n-  public void bufferNativeAdd() {\n-    for (int i = 0; i < SPECIES.loopBound(srcArray.length); i += SPECIES.length()) {\n-      var v = ShortVector.fromByteBuffer(SPECIES, srcBufferNative, i, ByteOrder.nativeOrder());\n-      v = v.add(v);\n-      v.intoByteBuffer(dstBufferNative, i, ByteOrder.nativeOrder());\n-    }\n-  }\n-\n-  @Benchmark\n-  public void bufferSegmentImplicit() {\n-    for (int i = 0; i < SPECIES.loopBound(srcArray.length); i += SPECIES.length()) {\n-      var v = ShortVector.fromByteBuffer(SPECIES, srcBufferSegmentImplicit, i, ByteOrder.nativeOrder());\n-      v.intoByteBuffer(dstBufferSegmentImplicit, i, ByteOrder.nativeOrder());\n-    }\n-  }\n-\n-  @Benchmark\n-  public void bufferSegmentConfined() {\n-    try (final var scope = ResourceScope.newConfinedScope()) {\n-      final var srcBufferSegmentConfined = MemorySegment.ofAddress(srcAddress, size, scope).asByteBuffer();\n-      final var dstBufferSegmentConfined = MemorySegment.ofAddress(dstAddress, size, scope).asByteBuffer();\n-\n-      for (int i = 0; i < SPECIES.loopBound(srcArray.length); i += SPECIES.length()) {\n-        var v = ShortVector.fromByteBuffer(SPECIES, srcBufferSegmentConfined, i, ByteOrder.nativeOrder());\n-        v.intoByteBuffer(dstBufferSegmentConfined, i, ByteOrder.nativeOrder());\n-      }\n-    }\n-  }\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/TestLoadStoreShort.java","additions":0,"deletions":222,"binary":false,"changes":222,"status":"deleted"},{"patch":"@@ -0,0 +1,185 @@\n+\/*\n+ *  Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+package org.openjdk.bench.jdk.incubator.vector;\n+\n+import java.nio.ByteOrder;\n+import java.util.concurrent.TimeUnit;\n+\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.vector.ShortVector;\n+import jdk.incubator.vector.VectorOperators;\n+import jdk.incubator.vector.VectorSpecies;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.TearDown;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@State(org.openjdk.jmh.annotations.Scope.Thread)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Fork(value = 1, jvmArgsAppend = {\n+    \"--add-modules=jdk.incubator.foreign,jdk.incubator.vector\",\n+    \"-Dforeign.restricted=permit\",\n+    \"--enable-native-access\", \"ALL-UNNAMED\"})\n+public class TestLoadStoreShorts {\n+  private static final VectorSpecies<Short> SPECIES = VectorSpecies.ofLargestShape(short.class);\n+\n+  @Param(\"256\")\n+  private int size;\n+\n+  private int longSize;\n+\n+  private short[] srcArray;\n+\n+  private short[] dstArray;\n+\n+\n+  private MemorySegment srcSegmentHeap;\n+\n+  private MemorySegment dstSegmentHeap;\n+\n+\n+  private ResourceScope implicitScope;\n+\n+  private MemorySegment srcSegment;\n+\n+  private MemorySegment dstSegment;\n+\n+\n+  private MemoryAddress srcAddress;\n+\n+  private MemoryAddress dstAddress;\n+\n+  private short[] a, b, c;\n+\n+  @Setup\n+  public void setup() {\n+    var longSize = size \/ Short.BYTES;\n+    srcArray = new short[longSize];\n+    dstArray = srcArray.clone();\n+    for (int i = 0; i < srcArray.length; i++) {\n+      srcArray[i] = (short) i;\n+    }\n+\n+    srcSegmentHeap = MemorySegment.ofArray(new byte[size]);\n+    dstSegmentHeap = MemorySegment.ofArray(new byte[size]);\n+\n+    implicitScope = ResourceScope.newImplicitScope();\n+    srcSegment = MemorySegment.allocateNative(size, SPECIES.vectorByteSize(), implicitScope);\n+    dstSegment = MemorySegment.allocateNative(size, SPECIES.vectorByteSize(), implicitScope);\n+\n+    srcAddress = srcSegment.address();\n+    dstAddress = dstSegment.address();\n+\n+    this.longSize = longSize;\n+\n+    a = new short[size];\n+    b = new short[size];\n+    c = new short[size];\n+  }\n+\n+  @Benchmark\n+  public void array() {\n+    for (int i = 0; i < SPECIES.loopBound(srcArray.length); i += SPECIES.length()) {\n+      var v = ShortVector.fromArray(SPECIES, srcArray, i);\n+      v.intoArray(dstArray, i);\n+    }\n+  }\n+\n+  @Benchmark\n+  public void vectAdd1() {\n+    var a = this.a;\n+    var b = this.b;\n+    var c = this.c;\n+\n+    for (int i = 0; i < a.length; i += SPECIES.length()) {\n+      ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+      ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+      av.lanewise(VectorOperators.ADD, bv).intoArray(c, i);\n+    }\n+  }\n+\n+  @Benchmark\n+  public void vectAdd2() {\n+    var a = this.a;\n+    var b = this.b;\n+    var c = this.c;\n+\n+    for (int i = 0; i < a.length\/SPECIES.length(); i++) {\n+      ShortVector av = ShortVector.fromArray(SPECIES, a, (i*SPECIES.length()));\n+      ShortVector bv = ShortVector.fromArray(SPECIES, b, (i*SPECIES.length()));\n+      av.lanewise(VectorOperators.ADD, bv).intoArray(c, (i*SPECIES.length()));\n+    }\n+  }\n+\n+  @Benchmark\n+  public void arrayAdd() {\n+    for (int i = 0; i < SPECIES.loopBound(srcArray.length); i += SPECIES.length()) {\n+      var v = ShortVector.fromArray(SPECIES, srcArray, i);\n+      v = v.add(v);\n+      v.intoArray(dstArray, i);\n+    }\n+  }\n+\n+  @Benchmark\n+  public void heapSegment() {\n+    for (long i = 0; i < SPECIES.loopBound(longSize); i += SPECIES.length()) {\n+      var v = ShortVector.fromMemorySegment(SPECIES, srcSegmentHeap, i, ByteOrder.nativeOrder());\n+      v.intoMemorySegment(dstSegmentHeap, i, ByteOrder.nativeOrder());\n+    }\n+  }\n+\n+  @Benchmark\n+  public void segmentNativeImplicit() {\n+    for (long i = 0; i < SPECIES.loopBound(srcArray.length); i += SPECIES.length()) {\n+      var v = ShortVector.fromMemorySegment(SPECIES, srcSegment, i, ByteOrder.nativeOrder());\n+      v.intoMemorySegment(dstSegment, i, ByteOrder.nativeOrder());\n+    }\n+  }\n+\n+  @Benchmark\n+  public void segmentNativeConfined() {\n+    try (final var scope = ResourceScope.newConfinedScope()) {\n+      final var srcSegmentConfined = MemorySegment.ofAddress(srcAddress, size, scope);\n+      final var dstSegmentConfined = MemorySegment.ofAddress(dstAddress, size, scope);\n+\n+      for (long i = 0; i < SPECIES.loopBound(srcArray.length); i += SPECIES.length()) {\n+        var v = ShortVector.fromMemorySegment(SPECIES, srcSegmentConfined, i, ByteOrder.nativeOrder());\n+        v.intoMemorySegment(dstSegmentConfined, i, ByteOrder.nativeOrder());\n+      }\n+    }\n+  }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/TestLoadStoreShorts.java","additions":185,"deletions":0,"binary":false,"changes":185,"status":"added"}]}