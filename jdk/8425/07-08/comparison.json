{"files":[{"patch":"@@ -11720,1 +11720,2 @@\n-  assert(VM_Version::supports_avx512_vbmi2() && (vector_len == AVX_512bit || VM_Version::supports_avx512vl()), \"\");\n+  assert(VM_Version::supports_avx512_vbmi2(), \"\");\n+  assert(vector_len == AVX_512bit || VM_Version::supports_avx512vl(), \"\");\n@@ -11732,1 +11733,2 @@\n-  assert(VM_Version::supports_avx512_vbmi2() && (vector_len == AVX_512bit || VM_Version::supports_avx512vl()), \"\");\n+  assert(VM_Version::supports_avx512_vbmi2(), \"\");\n+  assert(vector_len == AVX_512bit || VM_Version::supports_avx512vl(), \"\");\n@@ -11744,1 +11746,2 @@\n-  assert(VM_Version::supports_evex() && (vector_len == AVX_512bit || VM_Version::supports_avx512vl()), \"\");\n+  assert(VM_Version::supports_evex(), \"\");\n+  assert(vector_len == AVX_512bit || VM_Version::supports_avx512vl(), \"\");\n@@ -11756,1 +11759,2 @@\n-  assert(VM_Version::supports_evex() && (vector_len == AVX_512bit || VM_Version::supports_avx512vl()), \"\");\n+  assert(VM_Version::supports_evex(), \"\");\n+  assert(vector_len == AVX_512bit || VM_Version::supports_avx512vl(), \"\");\n@@ -11768,1 +11772,2 @@\n-  assert(VM_Version::supports_evex() && (vector_len == AVX_512bit || VM_Version::supports_avx512vl()), \"\");\n+  assert(VM_Version::supports_evex(), \"\");\n+  assert(vector_len == AVX_512bit || VM_Version::supports_avx512vl(), \"\");\n@@ -11780,1 +11785,2 @@\n-  assert(VM_Version::supports_evex() && (vector_len == AVX_512bit || VM_Version::supports_avx512vl()), \"\");\n+  assert(VM_Version::supports_evex(), \"\");\n+  assert(vector_len == AVX_512bit || VM_Version::supports_avx512vl(), \"\");\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.cpp","additions":12,"deletions":6,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -4455,1 +4455,1 @@\n-      fatal(\"Unsupported type\");\n+      fatal(\"Unsupported type %s\", type2name(bt));\n@@ -4481,1 +4481,1 @@\n-      fatal(\"Unsupported type\");\n+      fatal(\"Unsupported type %s\", type2name(bt));\n@@ -4561,1 +4561,2 @@\n-      default : ShouldNotReachHere(); break;\n+      fatal(\"Unsupported lane size %d\", lane_size);\n+      break;\n@@ -4571,1 +4572,2 @@\n-      default : ShouldNotReachHere(); break;\n+      fatal(\"Unsupported lane size %d\", lane_size);\n+      break;\n@@ -4666,1 +4668,2 @@\n-      ShouldNotReachHere();\n+      fatal(\"Unsupported type %s\", type2name(bt));\n+      break;\n@@ -4693,1 +4696,2 @@\n-      ShouldNotReachHere();\n+      fatal(\"Unsupported type %s\", type2name(bt));\n+      break;\n@@ -4732,2 +4736,1 @@\n-  } else if(!VM_Version::supports_avx512vlbw() && vec_enc == Assembler::AVX_512bit) {\n-\n+  } else if(vec_enc == Assembler::AVX_512bit) {\n@@ -4736,1 +4739,0 @@\n-    vbroadcast(T_INT, xtmp1, 0x0F0F0F0F, rtmp, vec_enc);\n@@ -4739,5 +4741,1 @@\n-    vpandq(dst, xtmp1, src, vec_enc);\n-    vpsllq(dst, dst, 4, vec_enc);\n-    vpandn(xtmp2, xtmp1, src, vec_enc);\n-    vpsrlq(xtmp2, xtmp2, 4, vec_enc);\n-    vporq(xtmp1, dst, xtmp2, vec_enc);\n+    vector_swap_nbits(4, 0x0F0F0F0F, xtmp1, src, xtmp2, rtmp, vec_enc);\n@@ -4746,6 +4744,1 @@\n-    vbroadcast(T_INT, xtmp2, 0x33333333, rtmp, vec_enc);\n-    vpandq(dst, xtmp2, xtmp1, vec_enc);\n-    vpsllq(dst, dst, 2, vec_enc);\n-    vpandn(xtmp2, xtmp2, xtmp1, vec_enc);\n-    vpsrlq(xtmp2, xtmp2, 2, vec_enc);\n-    vporq(xtmp1, dst, xtmp2, vec_enc);\n+    vector_swap_nbits(2, 0x33333333, dst, xtmp1, xtmp2, rtmp, vec_enc);\n@@ -4754,6 +4747,2 @@\n-    vbroadcast(T_INT, xtmp2, 0x55555555, rtmp, vec_enc);\n-    vpandq(dst, xtmp2, xtmp1, vec_enc);\n-    vpsllq(dst, dst, 1, vec_enc);\n-    vpandn(xtmp2, xtmp2, xtmp1, vec_enc);\n-    vpsrlq(xtmp2, xtmp2, 1, vec_enc);\n-    vporq(xtmp1, dst, xtmp2, vec_enc);\n+    evmovdqul(xtmp1, k0, dst, true, vec_enc);\n+    vector_swap_nbits(1, 0x55555555, dst, xtmp1, xtmp2, rtmp, vec_enc);\n@@ -4761,0 +4750,1 @@\n+    evmovdqul(xtmp1, k0, dst, true, vec_enc);\n@@ -4762,1 +4752,0 @@\n-\n@@ -4794,0 +4783,10 @@\n+void C2_MacroAssembler::vector_swap_nbits(int nbits, int bitmask, XMMRegister dst, XMMRegister src,\n+                                          XMMRegister xtmp1, Register rtmp, int vec_enc) {\n+  vbroadcast(T_INT, xtmp1, bitmask, rtmp, vec_enc);\n+  vpandq(dst, xtmp1, src, vec_enc);\n+  vpsllq(dst, dst, nbits, vec_enc);\n+  vpandn(xtmp1, xtmp1, src, vec_enc);\n+  vpsrlq(xtmp1, xtmp1, nbits, vec_enc);\n+  vporq(dst, dst, xtmp1, vec_enc);\n+}\n+\n@@ -4798,1 +4797,0 @@\n-  evmovdqul(xtmp1, k0, src, true, vec_enc);\n@@ -4802,1 +4800,4 @@\n-      evprorq(xtmp1, k0, xtmp1, 32, true, vec_enc);\n+      evprorq(xtmp1, k0, src, 32, true, vec_enc);\n+      evprord(xtmp1, k0, xtmp1, 16, true, vec_enc);\n+      vector_swap_nbits(8, 0x00FF00FF, dst, xtmp1, xtmp2, rtmp, vec_enc);\n+      break;\n@@ -4805,1 +4806,3 @@\n-      evprord(xtmp1, k0, xtmp1, 16, true, vec_enc);\n+      evprord(xtmp1, k0, src, 16, true, vec_enc);\n+      vector_swap_nbits(8, 0x00FF00FF, dst, xtmp1, xtmp2, rtmp, vec_enc);\n+      break;\n@@ -4808,6 +4811,1 @@\n-      vbroadcast(T_INT, dst, 0x00FF00FF, rtmp, vec_enc);\n-      vpandq(xtmp2, dst, xtmp1, vec_enc);\n-      vpsllq(xtmp2, xtmp2, 8, vec_enc);\n-      vpandn(xtmp1, dst, xtmp1, vec_enc);\n-      vpsrlq(dst, xtmp1, 8, vec_enc);\n-      vporq(dst, dst, xtmp2, vec_enc);\n+      vector_swap_nbits(8, 0x00FF00FF, dst, src, xtmp2, rtmp, vec_enc);\n@@ -4819,1 +4817,1 @@\n-      fatal(\"Unsupported type\");\n+      fatal(\"Unsupported type %s\", type2name(bt));\n@@ -4846,1 +4844,1 @@\n-      fatal(\"Unsupported type\");\n+      fatal(\"Unsupported type %s\", type2name(bt));\n@@ -4892,1 +4890,2 @@\n-      ShouldNotReachHere();\n+      fatal(\"Unsupported type %s\", type2name(bt));\n+      break;\n@@ -5018,1 +5017,2 @@\n-      ShouldNotReachHere();\n+      fatal(\"Unsupported type %s\", type2name(bt));\n+      break;\n@@ -5037,1 +5037,2 @@\n-      ShouldNotReachHere();\n+      fatal(\"Unsupported type %s\", type2name(bt));\n+      break;\n@@ -5056,1 +5057,2 @@\n-      ShouldNotReachHere();\n+      fatal(\"Unsupported type %s\", type2name(bt));\n+      break;\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":44,"deletions":42,"binary":false,"changes":86,"status":"modified"},{"patch":"@@ -389,1 +389,0 @@\n-\n@@ -417,0 +416,3 @@\n+  void vector_swap_nbits(int nbits, int bitmask, XMMRegister dst, XMMRegister src,\n+                         XMMRegister xtmp1, Register rtmp, int vec_enc);\n+\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -8879,7 +8879,3 @@\n-      if (VM_Version::supports_avx512vl()) {\n-        __ evpmovqd($dst$$XMMRegister, $dst$$XMMRegister, vlen_enc);\n-      } else {\n-        assert(VM_Version::supports_avx2(), \"\");\n-        __ vpshufd($dst$$XMMRegister, $dst$$XMMRegister, 8, vlen_enc);\n-        __ vpermq($dst$$XMMRegister, $dst$$XMMRegister, 8, vlen_enc);\n-      }\n+      assert(VM_Version::supports_avx2(), \"\");\n+      __ vpshufd($dst$$XMMRegister, $dst$$XMMRegister, 8, vlen_enc);\n+      __ vpermq($dst$$XMMRegister, $dst$$XMMRegister, 8, vlen_enc);\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -782,6 +782,5 @@\n-    Flag_has_vector_mask_set         = 1 << 13,\n-    Flag_is_expensive                = 1 << 14,\n-    Flag_is_predicated_vector        = 1 << 15,\n-    Flag_for_post_loop_opts_igvn     = 1 << 16,\n-    Flag_is_removed_by_peephole      = 1 << 17,\n-    Flag_is_predicated_using_blend   = 1 << 18,\n+    Flag_is_expensive                = 1 << 13,\n+    Flag_is_predicated_vector        = 1 << 14,\n+    Flag_for_post_loop_opts_igvn     = 1 << 15,\n+    Flag_is_removed_by_peephole      = 1 << 16,\n+    Flag_is_predicated_using_blend   = 1 << 17,\n@@ -1005,3 +1004,0 @@\n-  \/\/ The node is a CountedLoopEnd with a mask annotation so as to emit a restore context\n-  bool has_vector_mask_set() const { return (_flags & Flag_has_vector_mask_set) != 0; }\n-\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":5,"deletions":9,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -83,1 +83,3 @@\n-    \/\/ Check whether mask unboxing is supported.\n+    \/\/ Check if mask unboxing is supported, this is a two step process which first loads the contents\n+    \/\/ of boolean array into vector followed by either lane expansion to match the lane size of masked\n+    \/\/ vector operation or populate the predicate register.\n@@ -264,1 +266,3 @@\n-  \/\/ Check whether mask unboxing is supported.\n+  \/\/ Check if mask unboxing is supported, this is a two step process which first loads the contents\n+  \/\/ of boolean array into vector followed by either lane expansion to match the lane size of masked\n+  \/\/ vector operation or populate the predicate register.\n@@ -278,1 +282,3 @@\n-  \/\/ Check whether mask boxing is supported.\n+  \/\/ Check if mask boxing is supported, this is a two step process which first stores the contents\n+  \/\/ of mask vector \/ predicate register into a boolean vector followed by vector store operation to\n+  \/\/ transfer the contents to underlined storage of mask boxes which is a boolean array.\n","filename":"src\/hotspot\/share\/opto\/vectorIntrinsics.cpp","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1779,0 +1779,1 @@\n+  declare_c2_type(CompressMNode, VectorNode)                              \\\n@@ -1873,0 +1874,2 @@\n+  declare_c2_type(ReverseBytesVNode, VectorNode)                          \\\n+  declare_c2_type(ReverseVNode, VectorNode)                               \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"}]}