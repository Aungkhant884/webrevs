{"files":[{"patch":"@@ -150,0 +150,1 @@\n+  template(java_version_name,                         \"java_version\")                             \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -691,0 +691,1 @@\n+const char* JDK_Version::_short_version;\n","filename":"src\/hotspot\/share\/runtime\/java.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -68,0 +68,1 @@\n+  static const char* _short_version;\n@@ -133,0 +134,7 @@\n+  static const char* short_version() {\n+    return _short_version;\n+  }\n+  static void set_short_version(const char* version) {\n+    _short_version = version;\n+  }\n+\n","filename":"src\/hotspot\/share\/runtime\/java.hpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -176,4 +176,2 @@\n- * method to upcall into Java to return the value of the specified\n- * property as a utf8 string, or NULL if does not exist. The caller\n- * is responsible for setting a ResourceMark for proper cleanup of\n- * the utf8 strings.\n+ * Call into java.lang.System.getProperty to check that the value of the\n+ * specified property matches\n@@ -181,1 +179,3 @@\n-const char* StatSampler::get_system_property(const char* name, TRAPS) {\n+void StatSampler::assert_system_property(const char* name, const char* value, TRAPS) {\n+#ifdef ASSERT\n+  ResourceMark rm(THREAD);\n@@ -184,1 +184,1 @@\n-  Handle key_str   = java_lang_String::create_from_str(name, CHECK_NULL);\n+  Handle key_str   = java_lang_String::create_from_str(name, CHECK);\n@@ -195,1 +195,1 @@\n-                         CHECK_NULL);\n+                         CHECK);\n@@ -198,3 +198,1 @@\n-  if (value_oop == NULL) {\n-    return NULL;\n-  }\n+  assert(value_oop != NULL, \"property must have a value\");\n@@ -203,1 +201,1 @@\n-  char* value = java_lang_String::as_utf8_string(value_oop);\n+  char* system_value = java_lang_String::as_utf8_string(value_oop);\n@@ -205,1 +203,2 @@\n-  return value;\n+  assert(strcmp(value, system_value) == 0, \"property value mustn't differ from System.getProperty\");\n+#endif \/\/ ASSERT\n@@ -218,2 +217,2 @@\n-\/\/ stable interface, supported counters\n-static const char* property_counters_ss[] = {\n+\/\/ stable interface, supported counters in the JAVA_PROPERTY name space\n+static const char* stable_java_property_counters[] = {\n@@ -221,1 +220,0 @@\n-  \"java.vm.specification.name\",\n@@ -223,3 +221,0 @@\n-  \"java.vm.version\",\n-  \"java.vm.name\",\n-  \"java.vm.vendor\",\n@@ -227,1 +222,0 @@\n-  \"jdk.debug\",\n@@ -230,1 +224,0 @@\n-  \"java.version\",\n@@ -235,23 +228,13 @@\n-\/\/ unstable interface, supported counters\n-static const char* property_counters_us[] = {\n-  NULL\n-};\n-\n-\/\/ unstable interface, unsupported counters\n-static const char* property_counters_uu[] = {\n-  \"sun.boot.library.path\",\n-  NULL\n-};\n-\n-typedef struct {\n-  const char** property_list;\n-  CounterNS name_space;\n-} PropertyCounters;\n-\n-static PropertyCounters property_counters[] = {\n-  { property_counters_ss, JAVA_PROPERTY },\n-  { property_counters_us, COM_PROPERTY },\n-  { property_counters_uu, SUN_PROPERTY },\n-  { NULL, SUN_PROPERTY }\n-};\n-\n+\/*\n+ * Adds a constant counter of the given property. Asserts if the value for the\n+ * system property differs from the value retrievable from System.getProperty\n+ *\/\n+void StatSampler::add_property_constant(CounterNS name_space, const char* name, const char* value, TRAPS) {\n+  \/\/ the property must exist\n+  assert(value != NULL, \"property name should be have a value: %s\", name);\n+  assert_system_property(name, value, CHECK);\n+  if (value != NULL) {\n+    \/\/ create the property counter\n+    PerfDataManager::create_string_constant(name_space, name, value, CHECK);\n+  }\n+}\n@@ -261,2 +244,1 @@\n- * of various system properties. String instruments are created for each\n- * property specified in the property lists provided in property_counters[].\n+ * of various system properties.\n@@ -264,1 +246,1 @@\n- * property name as indicated in property_counters[].\n+ * property name.\n@@ -268,20 +250,19 @@\n-  ResourceMark rm;\n-\n-  for (int i = 0; property_counters[i].property_list != NULL; i++) {\n-\n-    for (int j = 0; property_counters[i].property_list[j] != NULL; j++) {\n-\n-      const char* property_name = property_counters[i].property_list[j];\n-      assert(property_name != NULL, \"property name should not be NULL\");\n-\n-      const char* value = get_system_property(property_name, CHECK);\n-\n-      \/\/ the property must exist\n-      assert(value != NULL, \"property name should be valid\");\n-\n-      if (value != NULL) {\n-        \/\/ create the property counter\n-        PerfDataManager::create_string_constant(property_counters[i].name_space,\n-                                                property_name, value, CHECK);\n-      }\n-    }\n+  \/\/ Non-writeable, constant properties\n+  add_property_constant(JAVA_PROPERTY, \"java.vm.specification.name\", \"Java Virtual Machine Specification\", CHECK);\n+  add_property_constant(JAVA_PROPERTY, \"java.version\", JDK_Version::short_version(), CHECK);\n+  add_property_constant(JAVA_PROPERTY, \"java.vm.version\", VM_Version::vm_release(), CHECK);\n+  add_property_constant(JAVA_PROPERTY, \"java.vm.name\", VM_Version::vm_name(), CHECK);\n+  add_property_constant(JAVA_PROPERTY, \"java.vm.vendor\", VM_Version::vm_vendor(), CHECK);\n+  add_property_constant(JAVA_PROPERTY, \"jdk.debug\", VM_Version::jdk_debug_level(), CHECK);\n+\n+  \/\/ Get remaining property constants via Arguments::get_property,\n+  \/\/ which does a linear search over the internal system properties list.\n+\n+  \/\/ SUN_PROPERTY properties\n+  add_property_constant(SUN_PROPERTY, \"sun.boot.library.path\", Arguments::get_property(\"sun.boot.library.path\"), CHECK);\n+\n+  \/\/ JAVA_PROPERTY properties\n+  for (int i = 0; stable_java_property_counters[i] != NULL; i++) {\n+    const char* property_name = stable_java_property_counters[i];\n+    const char* value = Arguments::get_property(property_name);\n+    add_property_constant(JAVA_PROPERTY, property_name, value, CHECK);\n","filename":"src\/hotspot\/share\/runtime\/statSampler.cpp","additions":47,"deletions":66,"binary":false,"changes":113,"status":"modified"},{"patch":"@@ -54,1 +54,2 @@\n-    static const char* get_system_property(const char* name, TRAPS);\n+    static void assert_system_property(const char* name, const char* value, TRAPS);\n+    static void add_property_constant(CounterNS name_space, const char* name, const char* value, TRAPS);\n","filename":"src\/hotspot\/share\/runtime\/statSampler.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1111,0 +1111,1 @@\n+char java_version[32] = \"\";\n@@ -1116,0 +1117,22 @@\n+\/\/ extract the JRE version string from java.lang.VersionProps.java_version\n+static const char* get_java_version(TRAPS) {\n+  Klass* k = SystemDictionary::find(vmSymbols::java_lang_VersionProps(),\n+                                    Handle(), Handle(), CHECK_AND_CLEAR_NULL);\n+  fieldDescriptor fd;\n+  bool found = k != NULL &&\n+               InstanceKlass::cast(k)->find_local_field(vmSymbols::java_version_name(),\n+                                                        vmSymbols::string_signature(), &fd);\n+  if (found) {\n+    oop name_oop = k->java_mirror()->obj_field(fd.offset());\n+    if (name_oop == NULL) {\n+      return NULL;\n+    }\n+    const char* name = java_lang_String::as_utf8_string(name_oop,\n+                                                        java_version,\n+                                                        sizeof(java_version));\n+    return name;\n+  } else {\n+    return NULL;\n+  }\n+}\n+\n@@ -3603,0 +3626,1 @@\n+  JDK_Version::set_short_version(get_java_version(THREAD));\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"}]}