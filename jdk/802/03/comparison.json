{"files":[{"patch":"@@ -150,0 +150,1 @@\n+  template(java_version_name,                         \"java_version\")                             \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -691,0 +691,1 @@\n+const char* JDK_Version::_java_version;\n","filename":"src\/hotspot\/share\/runtime\/java.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -68,0 +68,1 @@\n+  static const char* _java_version;\n@@ -133,0 +134,7 @@\n+  static const char* java_version() {\n+    return _java_version;\n+  }\n+  static void set_java_version(const char* version) {\n+    _java_version = version;\n+  }\n+\n","filename":"src\/hotspot\/share\/runtime\/java.hpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -176,4 +176,2 @@\n- * method to upcall into Java to return the value of the specified\n- * property as a utf8 string, or NULL if does not exist. The caller\n- * is responsible for setting a ResourceMark for proper cleanup of\n- * the utf8 strings.\n+ * Call into java.lang.System.getProperty to check that the value of the\n+ * specified property matches\n@@ -181,1 +179,3 @@\n-const char* StatSampler::get_system_property(const char* name, TRAPS) {\n+void StatSampler::assert_system_property(const char* name, const char* value, TRAPS) {\n+#ifdef ASSERT\n+  ResourceMark rm(THREAD);\n@@ -184,1 +184,1 @@\n-  Handle key_str   = java_lang_String::create_from_str(name, CHECK_NULL);\n+  Handle key_str   = java_lang_String::create_from_str(name, CHECK);\n@@ -195,1 +195,1 @@\n-                         CHECK_NULL);\n+                         CHECK);\n@@ -198,3 +198,1 @@\n-  if (value_oop == NULL) {\n-    return NULL;\n-  }\n+  assert(value_oop != NULL, \"property must have a value\");\n@@ -203,1 +201,1 @@\n-  char* value = java_lang_String::as_utf8_string(value_oop);\n+  char* system_value = java_lang_String::as_utf8_string(value_oop);\n@@ -205,1 +203,2 @@\n-  return value;\n+  assert(strcmp(value, system_value) == 0, \"property value mustn't differ from System.getProperty\");\n+#endif \/\/ ASSERT\n@@ -209,7 +208,2 @@\n- * The list of System Properties that have corresponding PerfData\n- * string instrumentation created by retrieving the named property's\n- * value from System.getProperty() and unconditionally creating a\n- * PerfStringConstant object initialized to the retrieved value. This\n- * is not an exhaustive list of Java properties with corresponding string\n- * instrumentation as the create_system_property_instrumentation() method\n- * creates other property based instrumentation conditionally.\n+ * Adds a constant counter of the given property. Asserts the value does not\n+ * differ from the value retrievable from System.getProperty(name)\n@@ -217,0 +211,9 @@\n+void StatSampler::add_property_constant(CounterNS name_space, const char* name, const char* value, TRAPS) {\n+  \/\/ the property must exist\n+  assert(value != NULL, \"property name should be have a value: %s\", name);\n+  assert_system_property(name, value, CHECK);\n+  if (value != NULL) {\n+    \/\/ create the property counter\n+    PerfDataManager::create_string_constant(name_space, name, value, CHECK);\n+  }\n+}\n@@ -218,40 +221,8 @@\n-\/\/ stable interface, supported counters\n-static const char* property_counters_ss[] = {\n-  \"java.vm.specification.version\",\n-  \"java.vm.specification.name\",\n-  \"java.vm.specification.vendor\",\n-  \"java.vm.version\",\n-  \"java.vm.name\",\n-  \"java.vm.vendor\",\n-  \"java.vm.info\",\n-  \"jdk.debug\",\n-  \"java.library.path\",\n-  \"java.class.path\",\n-  \"java.version\",\n-  \"java.home\",\n-  NULL\n-};\n-\n-\/\/ unstable interface, supported counters\n-static const char* property_counters_us[] = {\n-  NULL\n-};\n-\n-\/\/ unstable interface, unsupported counters\n-static const char* property_counters_uu[] = {\n-  \"sun.boot.library.path\",\n-  NULL\n-};\n-\n-typedef struct {\n-  const char** property_list;\n-  CounterNS name_space;\n-} PropertyCounters;\n-\n-static PropertyCounters property_counters[] = {\n-  { property_counters_ss, JAVA_PROPERTY },\n-  { property_counters_us, COM_PROPERTY },\n-  { property_counters_uu, SUN_PROPERTY },\n-  { NULL, SUN_PROPERTY }\n-};\n-\n+\/*\n+ * Adds a string constant of the given property. Retrieves the value via\n+ * Arguments::get_property() and asserts the value for the does not differ from\n+ * the value retrievable from System.getProperty()\n+ *\/\n+void StatSampler::add_property_constant(CounterNS name_space, const char* name, TRAPS) {\n+  add_property_constant(name_space, name, Arguments::get_property(name), CHECK);\n+}\n@@ -260,3 +231,5 @@\n- * Method to create PerfData string instruments that contain the values\n- * of various system properties. String instruments are created for each\n- * property specified in the property lists provided in property_counters[].\n+ * Method to create PerfStringConstants containing the values of various\n+ * system properties. Constants are created from information known to HotSpot,\n+ * but are initialized as-if getting the values from System.getProperty()\n+ * during bootstrap.\n+ *\n@@ -264,1 +237,1 @@\n- * property name as indicated in property_counters[].\n+ * property name.\n@@ -268,21 +241,21 @@\n-  ResourceMark rm;\n-\n-  for (int i = 0; property_counters[i].property_list != NULL; i++) {\n-\n-    for (int j = 0; property_counters[i].property_list[j] != NULL; j++) {\n-\n-      const char* property_name = property_counters[i].property_list[j];\n-      assert(property_name != NULL, \"property name should not be NULL\");\n-\n-      const char* value = get_system_property(property_name, CHECK);\n-\n-      \/\/ the property must exist\n-      assert(value != NULL, \"property name should be valid\");\n-\n-      if (value != NULL) {\n-        \/\/ create the property counter\n-        PerfDataManager::create_string_constant(property_counters[i].name_space,\n-                                                property_name, value, CHECK);\n-      }\n-    }\n-  }\n+  \/\/ Non-writeable, constant properties\n+  add_property_constant(JAVA_PROPERTY, \"java.vm.specification.name\", \"Java Virtual Machine Specification\", CHECK);\n+  add_property_constant(JAVA_PROPERTY, \"java.version\", JDK_Version::java_version(), CHECK);\n+  add_property_constant(JAVA_PROPERTY, \"java.vm.version\", VM_Version::vm_release(), CHECK);\n+  add_property_constant(JAVA_PROPERTY, \"java.vm.name\", VM_Version::vm_name(), CHECK);\n+  add_property_constant(JAVA_PROPERTY, \"java.vm.vendor\", VM_Version::vm_vendor(), CHECK);\n+  add_property_constant(JAVA_PROPERTY, \"jdk.debug\", VM_Version::jdk_debug_level(), CHECK);\n+\n+  \/\/ Get remaining property constants via Arguments::get_property,\n+  \/\/ which does a linear search over the internal system properties list.\n+\n+  \/\/ SUN_PROPERTY properties\n+  add_property_constant(SUN_PROPERTY, \"sun.boot.library.path\", CHECK);\n+\n+  \/\/ JAVA_PROPERTY properties\n+  add_property_constant(JAVA_PROPERTY, \"java.vm.specification.version\", CHECK);\n+  add_property_constant(JAVA_PROPERTY, \"java.vm.specification.vendor\", CHECK);\n+  add_property_constant(JAVA_PROPERTY, \"java.vm.info\", CHECK);\n+  add_property_constant(JAVA_PROPERTY, \"java.library.path\", CHECK);\n+  add_property_constant(JAVA_PROPERTY, \"java.class.path\", CHECK);\n+  add_property_constant(JAVA_PROPERTY, \"java.home\", CHECK);\n","filename":"src\/hotspot\/share\/runtime\/statSampler.cpp","additions":57,"deletions":84,"binary":false,"changes":141,"status":"modified"},{"patch":"@@ -54,1 +54,3 @@\n-    static const char* get_system_property(const char* name, TRAPS);\n+    static void assert_system_property(const char* name, const char* value, TRAPS);\n+    static void add_property_constant(CounterNS name_space, const char* name, TRAPS);\n+    static void add_property_constant(CounterNS name_space, const char* name, const char* value, TRAPS);\n","filename":"src\/hotspot\/share\/runtime\/statSampler.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -897,0 +897,1 @@\n+char java_version[64] = \"\";\n@@ -902,0 +903,22 @@\n+\/\/ extract the JRE version string from java.lang.VersionProps.java_version\n+static const char* get_java_version(TRAPS) {\n+  Klass* k = SystemDictionary::find(vmSymbols::java_lang_VersionProps(),\n+                                    Handle(), Handle(), CHECK_AND_CLEAR_NULL);\n+  fieldDescriptor fd;\n+  bool found = k != NULL &&\n+               InstanceKlass::cast(k)->find_local_field(vmSymbols::java_version_name(),\n+                                                        vmSymbols::string_signature(), &fd);\n+  if (found) {\n+    oop name_oop = k->java_mirror()->obj_field(fd.offset());\n+    if (name_oop == NULL) {\n+      return NULL;\n+    }\n+    const char* name = java_lang_String::as_utf8_string(name_oop,\n+                                                        java_version,\n+                                                        sizeof(java_version));\n+    return name;\n+  } else {\n+    return NULL;\n+  }\n+}\n+\n@@ -3386,0 +3409,1 @@\n+  JDK_Version::set_java_version(get_java_version(THREAD));\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+    \/\/ This field is read by HotSpot\n","filename":"src\/java.base\/share\/classes\/java\/lang\/VersionProps.java.template","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}