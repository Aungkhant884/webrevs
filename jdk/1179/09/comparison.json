{"files":[{"patch":"@@ -283,1 +283,1 @@\n-\/\/ In the end, users need invoke commit() to finalize the pending changes.\n+\/\/ In the end, users need to invoke commit() to finalize the pending changes.\n","filename":"src\/hotspot\/share\/compiler\/compilerDirectives.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -188,0 +188,33 @@\n+class ControlIntrinsicValidator {\n+ private:\n+  bool _valid;\n+  char* _bad;\n+\n+ public:\n+  ControlIntrinsicValidator(ccstrlist option, bool disabled_all) : _valid(true), _bad(nullptr) {\n+    for (ControlIntrinsicIter iter(option, disabled_all); *iter != NULL && _valid; ++iter) {\n+      if (vmIntrinsics::_none == vmIntrinsics::find_id(*iter)) {\n+        const size_t len = MIN2<size_t>(strlen(*iter), 63) + 1;  \/\/ cap len to a value we know is enough for all intrinsic names\n+        _bad = NEW_C_HEAP_ARRAY(char, len, mtCompiler);\n+        \/\/ strncpy always write len characters.if the source string is shorter, the function fills the remaining bytes with NULs.\n+        strncpy(_bad, *iter, len);\n+        _valid = false;\n+      }\n+    }\n+  }\n+\n+  ~ControlIntrinsicValidator() {\n+    if (_bad != NULL) {\n+      FREE_C_HEAP_ARRAY(char, _bad);\n+    }\n+  }\n+\n+  bool is_valid() const {\n+    return _valid;\n+  }\n+\n+  const char* what() const {\n+    return _bad;\n+  }\n+};\n+\n","filename":"src\/hotspot\/share\/compiler\/compilerDirectives.hpp","additions":33,"deletions":0,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"compiler\/compilerDirectives.hpp\"\n@@ -298,1 +299,1 @@\n-    \/\/ Print out the succesful registration of a comile command\n+    \/\/ Print out the successful registration of a compile command\n@@ -573,0 +574,9 @@\n+\n+      if (option == CompileCommand::ControlIntrinsic || option == CompileCommand::DisableIntrinsic) {\n+        ControlIntrinsicValidator validator(value, (option == CompileCommand::DisableIntrinsic));\n+\n+        if (!validator.is_valid()) {\n+          jio_snprintf(errorbuf, buf_size, \"Unrecognized intrinsic detected in %s: %s\", option2name(option), validator.what());\n+        }\n+      }\n+\n","filename":"src\/hotspot\/share\/compiler\/compilerOracle.cpp","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -322,0 +322,17 @@\n+\n+        if (strncmp(option_key->name, \"ControlIntrinsic\", 16) == 0) {\n+          ControlIntrinsicValidator validator(s, false\/*disabled_all*\/);\n+\n+          if (!validator.is_valid()) {\n+            error(VALUE_ERROR, \"Unrecognized intrinsic detected in ControlIntrinsic: %s\", validator.what());\n+            return false;\n+          }\n+        }\n+        else if (strncmp(option_key->name, \"DisableIntrinsic\", 16) == 0) {\n+          ControlIntrinsicValidator validator(s, true\/*disabled_all*\/);\n+\n+          if (!validator.is_valid()) {\n+            error(VALUE_ERROR, \"Unrecognized intrinsic detected in DisableIntrinsic: %s\", validator.what());\n+            return false;\n+          }\n+        }\n","filename":"src\/hotspot\/share\/compiler\/directivesParser.cpp","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -362,1 +362,1 @@\n-  BasicMatcher *bm = new BasicMatcher();\n+  BasicMatcher* bm = new BasicMatcher();\n","filename":"src\/hotspot\/share\/compiler\/methodMatcher.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -360,0 +360,6 @@\n+  const int type_enum = flag->type();\n+  if (type_enum == JVMFlag::TYPE_ccstr || type_enum == JVMFlag::TYPE_ccstrlist) {\n+    \/\/ ccstr and ccstrlist are the same type.\n+    return ((JVMFlagConstraintFunc_ccstr)func)(flag->get_ccstr(), verbose);\n+  }\n+\n","filename":"src\/hotspot\/share\/runtime\/flags\/jvmFlagAccess.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"compiler\/compilerDirectives.hpp\"\n@@ -416,0 +417,24 @@\n+\n+JVMFlag::Error DisableIntrinsicConstraintFunc(ccstrlist value, bool verbose) {\n+  ControlIntrinsicValidator validator(value, true\/*disabled_all*\/);\n+  if (!validator.is_valid()) {\n+    JVMFlag::printError(verbose,\n+                        \"Unrecognized intrinsic detected in DisableIntrinsic: %s\\n\",\n+                        validator.what());\n+    return JVMFlag::VIOLATES_CONSTRAINT;\n+  }\n+\n+  return JVMFlag::SUCCESS;\n+}\n+\n+JVMFlag::Error ControlIntrinsicConstraintFunc(ccstrlist value, bool verbose) {\n+  ControlIntrinsicValidator validator(value, false\/*disabled_all*\/);\n+  if (!validator.is_valid()) {\n+    JVMFlag::printError(verbose,\n+                        \"Unrecognized intrinsic detected in ControlIntrinsic: %s\\n\",\n+                        validator.what());\n+    return JVMFlag::VIOLATES_CONSTRAINT;\n+  }\n+\n+  return JVMFlag::SUCCESS;\n+}\n\\ No newline at end of file\n","filename":"src\/hotspot\/share\/runtime\/flags\/jvmFlagConstraintsCompiler.cpp","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -54,0 +54,2 @@\n+  f(ccstrlist, DisableIntrinsicConstraintFunc)          \\\n+  f(ccstrlist, ControlIntrinsicConstraintFunc)          \\\n","filename":"src\/hotspot\/share\/runtime\/flags\/jvmFlagConstraintsCompiler.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -51,0 +51,1 @@\n+typedef JVMFlag::Error (*JVMFlagConstraintFunc_ccstr)(ccstr value, bool verbose);\n","filename":"src\/hotspot\/share\/runtime\/flags\/jvmFlagLimit.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -368,0 +368,1 @@\n+         constraint(DisableIntrinsicConstraintFunc,AfterErgo)               \\\n@@ -372,0 +373,1 @@\n+         constraint(ControlIntrinsicConstraintFunc,AfterErgo)               \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,56 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8247732\n+ * @summary Tests CompileCommand=option,*,ccstrlist,ControlIntrinsic,+_id\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib \/\n+ *\n+ * @build sun.hotspot.WhiteBox\n+ * @run driver ClassFileInstaller sun.hotspot.WhiteBox\n+ * @run driver compiler.compilercontrol.commands.ControlIntrinsicTest\n+ *\/\n+\n+package compiler.compilercontrol.commands;\n+\n+import compiler.compilercontrol.share.IntrinsicCommand;\n+import compiler.compilercontrol.share.IntrinsicCommand.IntrinsicId;\n+import compiler.compilercontrol.share.scenario.Scenario;\n+\n+public class ControlIntrinsicTest {\n+    public static void main(String[] args) {\n+        IntrinsicId ids[] = new IntrinsicId[3];\n+\n+        ids[0] = new IntrinsicId(\"_newArray\", true);\n+        ids[1] = new IntrinsicId(\"_minF\", false);\n+        ids[2] = new IntrinsicId(\"_copyOf\", true);\n+        new IntrinsicCommand(Scenario.Type.OPTION, ids).test();\n+\n+        \/\/ even though intrinsic ids are invalid, hotspot returns 0\n+        ids[0] = new IntrinsicId(\"brokenIntrinsic\", true);\n+        ids[1] = new IntrinsicId(\"invalidIntrinsic\", false);\n+        new IntrinsicCommand(Scenario.Type.OPTION, ids).test();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/compilercontrol\/commands\/ControlIntrinsicTest.java","additions":56,"deletions":0,"binary":false,"changes":56,"status":"added"},{"patch":"@@ -5,1 +5,0 @@\n-    DisableIntrinsic:\"x\"\n","filename":"test\/hotspot\/jtreg\/compiler\/compilercontrol\/control_off.txt","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,56 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8247732\n+ * @summary Tests  -XX:CompilerDirectivesFile=directives.json\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib \/\n+ *\n+ * @build sun.hotspot.WhiteBox\n+ * @run driver ClassFileInstaller sun.hotspot.WhiteBox\n+ * @run driver compiler.compilercontrol.directives.ControlIntrinsicTest\n+ *\/\n+\n+package compiler.compilercontrol.directives;\n+\n+import compiler.compilercontrol.share.IntrinsicCommand;\n+import compiler.compilercontrol.share.IntrinsicCommand.IntrinsicId;\n+import compiler.compilercontrol.share.scenario.Scenario;\n+\n+public class ControlIntrinsicTest {\n+    public static void main(String[] args) {\n+        IntrinsicId ids[] = new IntrinsicId[3];\n+\n+        ids[0] = new IntrinsicId(\"_newArray\", true);\n+        ids[1] = new IntrinsicId(\"_minF\", false);\n+        ids[2] = new IntrinsicId(\"_copyOf\", true);\n+        new IntrinsicCommand(Scenario.Type.DIRECTIVE, ids).test();\n+\n+        \/\/ invalid compileCommands, hotspot exits with non-zero retval\n+        ids[0] = new IntrinsicId(\"brokenIntrinsic\", true);\n+        ids[1] = new IntrinsicId(\"invalidIntrinsic\", false);\n+        new IntrinsicCommand(Scenario.Type.DIRECTIVE, ids).test();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/compilercontrol\/directives\/ControlIntrinsicTest.java","additions":56,"deletions":0,"binary":false,"changes":56,"status":"added"},{"patch":"@@ -0,0 +1,56 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8247732\n+ * @summary Test ControlIntrinsic via jcmd\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib \/\n+ *\n+ * @build sun.hotspot.WhiteBox\n+ * @run driver ClassFileInstaller sun.hotspot.WhiteBox\n+ * @run driver compiler.compilercontrol.jcmd.ControlIntrinsicTest\n+ *\/\n+\n+package compiler.compilercontrol.jcmd;\n+\n+import compiler.compilercontrol.share.IntrinsicCommand;\n+import compiler.compilercontrol.share.IntrinsicCommand.IntrinsicId;\n+import compiler.compilercontrol.share.scenario.Scenario;\n+\n+public class ControlIntrinsicTest {\n+    public static void main(String[] args) {\n+        IntrinsicId ids[] = new IntrinsicId[3];\n+\n+        ids[0] = new IntrinsicId(\"_newArray\", true);\n+        ids[1] = new IntrinsicId(\"_minF\", false);\n+        ids[2] = new IntrinsicId(\"_copyOf\", true);\n+        new IntrinsicCommand(Scenario.Type.JCMD, ids).test();\n+\n+        \/\/ will get error message but jcmd process still return 0\n+        ids[0] = new IntrinsicId(\"brokenIntrinsic\", true);\n+        ids[1] = new IntrinsicId(\"invalidIntrinsic\", false);\n+        new IntrinsicCommand(Scenario.Type.JCMD, ids).test();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/compilercontrol\/jcmd\/ControlIntrinsicTest.java","additions":56,"deletions":0,"binary":false,"changes":56,"status":"added"},{"patch":"@@ -51,0 +51,2 @@\n+import static compiler.compilercontrol.share.IntrinsicCommand.VALID_INTRINSIC_SAMPLES;\n+\n@@ -66,0 +68,3 @@\n+            String vmOptionType = null;\n+            String argument = null;\n+\n@@ -73,0 +78,4 @@\n+            if (command == Command.INTRINSIC) {\n+                vmOptionType = \"ccstrlist\";\n+                argument = Utils.getRandomElement(VALID_INTRINSIC_SAMPLES);\n+            }\n@@ -75,1 +84,1 @@\n-                    Scenario.Type.DIRECTIVE);\n+                    Scenario.Type.DIRECTIVE, vmOptionType, argument);\n","filename":"test\/hotspot\/jtreg\/compiler\/compilercontrol\/jcmd\/PrintDirectivesTest.java","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -39,0 +39,2 @@\n+import static compiler.compilercontrol.share.IntrinsicCommand.VALID_INTRINSIC_SAMPLES;\n+\n@@ -85,2 +87,5 @@\n-            file.option(Utils.getRandomElement(DirectiveWriter.Option.values()),\n-                    random.nextBoolean());\n+            DirectiveWriter.Option option = Utils.getRandomElement(DirectiveWriter.Option.values());\n+            file.option(option,\n+                    option != DirectiveWriter.Option.INTRINSIC\n+                    ? random.nextBoolean()\n+                    : \"\\\"\" + Utils.getRandomElement(VALID_INTRINSIC_SAMPLES) + \"\\\"\");\n","filename":"test\/hotspot\/jtreg\/compiler\/compilercontrol\/parser\/HugeDirectiveUtil.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,80 @@\n+\/*\n+ * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.compilercontrol.share;\n+\n+import compiler.compilercontrol.share.method.MethodDescriptor;\n+import compiler.compilercontrol.share.scenario.Command;\n+import compiler.compilercontrol.share.scenario.CommandGenerator;\n+import compiler.compilercontrol.share.scenario.CompileCommand;\n+import compiler.compilercontrol.share.scenario.Scenario;\n+import jdk.test.lib.Utils;\n+\n+import java.lang.reflect.Executable;\n+import java.util.Arrays;\n+import java.util.stream.Collectors;\n+\n+public class IntrinsicCommand extends AbstractTestBase {\n+    public static String[] VALID_INTRINSIC_SAMPLES = {\"+_fabs\", \"-_maxF\", \"+_newArray\", \"-_isDigit\", \"+_putInt\"};\n+    public static String[] INVALID_INTRINSIC_SAMPLES = {\"+fabs\", \"-maxF\"};\n+\n+    public static class IntrinsicId {\n+        private String id;\n+        private boolean enable;\n+\n+        public IntrinsicId(String id, boolean enable) {\n+            this.id = id;\n+            this.enable = enable;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return (enable ? \"+\" : \"-\")  + id;\n+        }\n+    }\n+\n+    private final Command command;\n+    private final Scenario.Type type;\n+    private String intrinsic_ids;\n+\n+    public IntrinsicCommand(Scenario.Type type, IntrinsicId[] intrinsic_ids) {\n+        this.command = Command.INTRINSIC;\n+        this.type = type;\n+        this.intrinsic_ids = Arrays.stream(intrinsic_ids).map(id -> id.toString())\n+                                                         .collect(Collectors.joining(\",\"));\n+    }\n+\n+    @Override\n+    public void test() {\n+        Scenario.Builder builder = Scenario.getBuilder();\n+        Executable exec = Utils.getRandomElement(METHODS).first;\n+        MethodDescriptor md = getValidMethodDescriptor(exec);\n+        CommandGenerator cmdGen = new CommandGenerator();\n+\n+        CompileCommand compileCommand = cmdGen.generateCompileCommand(command,\n+                md, type, \"ccstrlist\", intrinsic_ids);\n+        builder.add(compileCommand);\n+        Scenario scenario = builder.build();\n+        scenario.execute();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/compilercontrol\/share\/IntrinsicCommand.java","additions":80,"deletions":0,"binary":false,"changes":80,"status":"added"},{"patch":"@@ -37,0 +37,3 @@\n+import static compiler.compilercontrol.share.IntrinsicCommand.VALID_INTRINSIC_SAMPLES;\n+import static compiler.compilercontrol.share.IntrinsicCommand.INVALID_INTRINSIC_SAMPLES;\n+\n@@ -54,0 +57,1 @@\n+\n@@ -55,0 +59,3 @@\n+            String vmOptionType = null;\n+            String argument = null;\n+\n@@ -59,0 +66,9 @@\n+            if (cmd == Command.INTRINSIC) {\n+                vmOptionType = \"ccstrlist\";\n+                if (validOnly) {\n+                    argument = Utils.getRandomElement(VALID_INTRINSIC_SAMPLES);\n+                } else {\n+                    argument = Utils.getRandomElement(INVALID_INTRINSIC_SAMPLES);\n+                }\n+            }\n+\n@@ -66,1 +82,6 @@\n-            CompileCommand cc = cmdGen.generateCompileCommand(cmd, md, null);\n+            CompileCommand cc;\n+            if (cmd == Command.INTRINSIC) {\n+                cc = cmdGen.generateCompileCommand(cmd, md, null, vmOptionType, argument);\n+            } else {\n+                cc = cmdGen.generateCompileCommand(cmd, md, null);\n+            }\n","filename":"test\/hotspot\/jtreg\/compiler\/compilercontrol\/share\/MultiCommand.java","additions":22,"deletions":1,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+import compiler.compilercontrol.share.scenario.Command;\n@@ -41,0 +42,2 @@\n+    private static final String WARNING_COMMAND_MSG = \"CompileCommand: An error occurred during parsing\";\n+\n@@ -63,0 +66,5 @@\n+        \/\/ -XX:CompileCommand(File) ignores invalid items\n+        if (input.equals(WARNING_COMMAND_MSG)) {\n+            return;\n+        }\n+\n@@ -67,1 +75,1 @@\n-                        getOutputString(command) + \"missing in output\");\n+                        getOutputString(command) + \" missing in output\");\n@@ -85,4 +93,33 @@\n-    private String getOutputString(CompileCommand command) {\n-        return \"CompileCommand: \"\n-                + command.command.name + \" \"\n-                + command.methodDescriptor.getCanonicalString();\n+    \/\/ the output here must match hotspot compilerOracle.cpp::register_command\n+    \/\/    tty->print(\"CompileCommand: %s \", option2name(option));\n+    \/\/    matcher->print();\n+    private String getOutputString(CompileCommand cc) {\n+        StringBuilder sb = new StringBuilder(\"CompileCommand: \");\n+        \/\/ CompileCommand: ControlIntrinsic *Klass.-()V const char* ControlIntrinsic = '+_newArray -_minF +_copyOf'\n+        if (cc.command == Command.INTRINSIC) {\n+            sb.append(\"ControlIntrinsic\");\n+        }\n+        else {\n+            sb.append(cc.command.name);\n+        }\n+\n+        sb.append(\" \");\n+        sb.append(cc.methodDescriptor.getCanonicalString());\n+        if (cc.command == Command.INTRINSIC) {\n+            sb.append(\" const char* \");\n+            sb.append(\"ControlIntrinsic = '\");\n+\n+            boolean initial = true;\n+            for (String id: cc.argument.split(\",\")) {\n+                if(!initial) {\n+                    sb.append(\" \");\n+                }\n+                else {\n+                    initial = false;\n+                }\n+                sb.append(id);\n+            }\n+            sb.append(\"'\");\n+        }\n+\n+        return sb.toString();\n","filename":"test\/hotspot\/jtreg\/compiler\/compilercontrol\/share\/processors\/CommandProcessor.java","additions":43,"deletions":6,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -66,2 +66,5 @@\n-        \/\/ -XX:CompileCommand(File) ignores invalid items\n-        return true;\n+        boolean isValid = true;\n+        for (CompileCommand cmd : compileCommands) {\n+            isValid &= cmd.isValid();\n+        }\n+        return isValid;\n","filename":"test\/hotspot\/jtreg\/compiler\/compilercontrol\/share\/scenario\/AbstractCommandBuilder.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+    INTRINSIC(\"option\", \"\"),\n","filename":"test\/hotspot\/jtreg\/compiler\/compilercontrol\/share\/scenario\/Command.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import java.util.function.Function;\n@@ -43,0 +44,14 @@\n+        Function<CompileCommand, String> mapper = cc -> {\n+            if (cc.command != Command.INTRINSIC) {\n+                return cc.command.name + \" \"\n+                    + cc.methodDescriptor.getString();\n+            }\n+            else {\n+                return cc.command.name + \" \"\n+                    + cc.methodDescriptor.getString()\n+                    + \" ccstrlist \"\n+                    + \" ControlIntrinsic \"\n+                    + cc.argument;\n+            }\n+        };\n+\n@@ -46,2 +61,1 @@\n-                    .map(cc -> cc.command.name + \" \"\n-                            + cc.methodDescriptor.getString())\n+                    .map(mapper)\n","filename":"test\/hotspot\/jtreg\/compiler\/compilercontrol\/share\/scenario\/CommandFileBuilder.java","additions":16,"deletions":2,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import jdk.test.lib.Asserts;\n@@ -91,0 +92,11 @@\n+    public CompileCommand generateCompileCommand(Command command,\n+            MethodDescriptor md, Scenario.Type type, String vmOptionType, String argument) {\n+        Asserts.assertTrue(command == Command.INTRINSIC, \"only command INTRINSIC support argument\");\n+        Asserts.assertTrue(vmOptionType.equals(\"ccstrlist\"), \"vmOptionType should be consistent with globals.hpp\");\n+        if (type == null) {\n+            type = Utils.getRandomElement(Scenario.Type.values());\n+        }\n+        return type.createCompileCommand(command, md, generateCompiler(), vmOptionType, argument);\n+    }\n+\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/compilercontrol\/share\/scenario\/CommandGenerator.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.util.function.Function;\n@@ -37,6 +38,25 @@\n-        return compileCommands.stream()\n-                .map(cc -> \"-XX:CompileCommand=\"\n-                        + cc.command.name\n-                        + MethodDescriptor.Separator.COMMA.symbol\n-                        + cc.methodDescriptor.getString())\n-                .collect(Collectors.toList());\n+        Function<CompileCommand, String> mapper = cc -> {\n+            if (cc.command != Command.INTRINSIC) {\n+                return \"-XX:CompileCommand=\"\n+                    + cc.command.name\n+                    + MethodDescriptor.Separator.COMMA.symbol\n+                    + cc.methodDescriptor.getString();\n+            }\n+            else {\n+                return \"-XX:CompileCommand=\"\n+                    + cc.command.name\n+                    + MethodDescriptor.Separator.COMMA.symbol\n+                    + cc.methodDescriptor.getString()\n+                    + MethodDescriptor.Separator.COMMA.symbol\n+                    + \"ccstrlist\"\n+                    + MethodDescriptor.Separator.COMMA.symbol\n+                    + \"ControlIntrinsic\"\n+                    + MethodDescriptor.Separator.COMMA.symbol\n+                    + cc.argument;\n+            }\n+        };\n+\n+        List<String> options = compileCommands.stream()\n+                .map(mapper).collect(Collectors.toList());\n+\n+        return options;\n","filename":"test\/hotspot\/jtreg\/compiler\/compilercontrol\/share\/scenario\/CommandOptionsBuilder.java","additions":26,"deletions":6,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -36,0 +36,2 @@\n+    public final String vmOptionType;\n+    public final String argument;\n@@ -45,0 +47,2 @@\n+        this.vmOptionType = null;\n+        this.argument = null;\n@@ -47,0 +51,14 @@\n+    public CompileCommand(Command command,\n+                          MethodDescriptor methodDescriptor,\n+                          Scenario.Compiler compiler,\n+                          Scenario.Type type,\n+                          String vmOptionType, String argument) {\n+        this.command = command;\n+        this.methodDescriptor = methodDescriptor;\n+        this.compiler = compiler;\n+        this.type = type;\n+        this.vmOptionType = vmOptionType;\n+        this.argument = argument;\n+    }\n+\n+\n@@ -56,0 +74,18 @@\n+        \/\/ -XX:CompileCommand(File) ignores invalid items\n+        \/\/ Invalid intrinsic ids in CompilerDirectivesFile will force hotspot to exit with non-zero value.\n+        if (command == Command.INTRINSIC && type == Scenario.Type.DIRECTIVE) {\n+            if (argument != null) {\n+                String[] ids = argument.split(\",\");\n+                for (String id : ids) {\n+                    char ch = id.charAt(0);\n+\n+                    \/\/ Not a strict check.\n+                    \/\/ a valid ControlIntrinsic argument is separated by \",\", each one starts with '+' or '-'.\n+                    \/\/ intrinsicId starts with '_'\n+                    if ((ch != '+' && ch != '-') || id.charAt(1) != '_') {\n+                      return false;\n+                    }\n+                }\n+            }\n+        }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/compilercontrol\/share\/scenario\/CompileCommand.java","additions":36,"deletions":0,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -215,0 +215,3 @@\n+            case INTRINSIC:\n+                dirFile.option(DirectiveWriter.Option.INTRINSIC, \"\\\"\" + cmd.argument + \"\\\"\");\n+                break;\n","filename":"test\/hotspot\/jtreg\/compiler\/compilercontrol\/share\/scenario\/DirectiveBuilder.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -195,1 +195,2 @@\n-        ENABLE(\"Enable\");\n+        ENABLE(\"Enable\"),\n+        INTRINSIC(\"ControlIntrinsic\");\n","filename":"test\/hotspot\/jtreg\/compiler\/compilercontrol\/share\/scenario\/DirectiveWriter.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -88,1 +88,1 @@\n-            if (isValid) {\n+            {\n@@ -153,1 +153,5 @@\n-            throw new Error(\"Failed to write data: \" + e.getMessage(), e);\n+            \/\/ hotspot process may exit because of invalid directives,\n+            \/\/ suppress the IOException of closed socket.\n+            if (!e.getMessage().equals(\"Socket closed\")) {\n+              throw new Error(\"Failed to write data: \" + e.getMessage(), e);\n+            }\n","filename":"test\/hotspot\/jtreg\/compiler\/compilercontrol\/share\/scenario\/Executor.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -40,0 +40,12 @@\n+    public JcmdCommand(Command command,\n+                       MethodDescriptor methodDescriptor,\n+                       Scenario.Compiler compiler,\n+                       Scenario.Type type,\n+                       Scenario.JcmdType jcmdType,\n+                       String vmOptionType,\n+                       String argument) {\n+        super(command, methodDescriptor, compiler, type, vmOptionType, argument);\n+        this.jcmdType = jcmdType;\n+    }\n+\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/compilercontrol\/share\/scenario\/JcmdCommand.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -167,2 +167,2 @@\n-        OPTION(\"\"),\n-        FILE(\"command_file\"),\n+        OPTION(\"\"),               \/\/ CompilerOracle: -XX:CompileCommand=\n+        FILE(\"command_file\"),     \/\/ CompilerOracle: -XX:CompileCommandFile=\n@@ -177,0 +177,7 @@\n+\n+            @Override\n+            public CompileCommand createCompileCommand(Command command,\n+                    MethodDescriptor md, Compiler compiler, String vmOptionType, String argument) {\n+                return new JcmdCommand(command, md, compiler, this,\n+                        JcmdType.ADD, vmOptionType, argument);\n+            }\n@@ -186,0 +193,5 @@\n+        public CompileCommand createCompileCommand(Command command,\n+                MethodDescriptor md, Compiler compiler, String vmOptionType, String argument) {\n+            return new CompileCommand(command, md, compiler, this, vmOptionType, argument);\n+        }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/compilercontrol\/share\/scenario\/Scenario.java","additions":14,"deletions":2,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+    private Optional<String> controlIntrinsic = Optional.empty();\n@@ -278,0 +279,6 @@\n+    public void setControlIntrinsic(String argument) {\n+        if (argument != null) {\n+            controlIntrinsic = Optional.of(argument);\n+        }\n+    }\n+\n@@ -317,0 +324,3 @@\n+            case INTRINSIC:\n+                setControlIntrinsic(compileCommand.argument);\n+                break;\n@@ -371,0 +381,3 @@\n+        \/\/ set controlIntrinsic\n+        result.controlIntrinsic = mergeOptional(high.controlIntrinsic, low.controlIntrinsic);\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/compilercontrol\/share\/scenario\/State.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -47,2 +47,2 @@\n- *                   -XX:CompileCommand=option,jdk.internal.misc.Unsafe::putChar,ccstrlist,ControlIntrinsic,-_getCharVolatile,-_getInt\n- *                   -XX:CompileCommand=option,jdk.internal.misc.Unsafe::putCharVolatile,ccstrlist,ControlIntrinsic,-_getIntVolatile\n+ *                   -XX:CompileCommand=ControlIntrinsic,jdk.internal.misc.Unsafe::putChar,-_getCharVolatile,-_getInt\n+ *                   -XX:CompileCommand=ControlIntrinsic,jdk.internal.misc.Unsafe::putCharVolatile,-_getIntVolatile\n@@ -53,1 +53,1 @@\n- *                   -XX:ControlIntrinsic=+putIntVolatile,+_putCharVolatile,+_putInt\n+ *                   -XX:ControlIntrinsic=+_putIntVolatile,+_putCharVolatile,+_putInt\n@@ -56,4 +56,4 @@\n- *                   -XX:CompileCommand=option,jdk.internal.misc.Unsafe::putChar,ccstrlist,ControlIntrinsic,+_getCharVolatile,+_getInt\n- *                   -XX:CompileCommand=option,jdk.internal.misc.Unsafe::putCharVolatile,ccstrlist,ControlIntrinsic,+_getIntVolatile\n- *                   -XX:CompileCommand=option,jdk.internal.misc.Unsafe::putChar,ccstrlist,DisableIntrinsic,_getCharVolatile,_getInt\n- *                   -XX:CompileCommand=option,jdk.internal.misc.Unsafe::putCharVolatile,ccstrlist,DisableIntrinsic,_getIntVolatile\n+ *                   -XX:CompileCommand=ControlIntrinsic,jdk.internal.misc.Unsafe::putChar,+_getCharVolatile,+_getInt\n+ *                   -XX:CompileCommand=ControlIntrinsic,jdk.internal.misc.Unsafe::putCharVolatile,+_getIntVolatile\n+ *                   -XX:CompileCommand=DisableIntrinsic,jdk.internal.misc.Unsafe::putChar,_getCharVolatile,_getInt\n+ *                   -XX:CompileCommand=DisableIntrinsic,jdk.internal.misc.Unsafe::putCharVolatile,_getIntVolatile\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/IntrinsicDisabledTest.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"}]}