{"files":[{"patch":"@@ -88,0 +88,3 @@\n+#define BLOCK_FORMAT          \"Block @\" PTR_FORMAT \": size: \" SIZE_FORMAT \", next: \" PTR_FORMAT\n+#define BLOCK_FORMAT_ARGS(b)  p2i(b), (b)->_word_size, p2i((b)->_next)\n+\n@@ -153,4 +156,1 @@\n-      assert(_blocks[index] != NULL &&\n-             _blocks[index]->_word_size >= word_size, \"sanity\");\n-\n-      MetaWord* const p = (MetaWord*)_blocks[index];\n+      Block* b = _blocks[index];\n@@ -158,3 +158,5 @@\n-\n-      _blocks[index] = _blocks[index]->_next;\n-\n+      assert(b != NULL, \"Sanity\");\n+      assert(b->_word_size >= word_size &&\n+             b->_word_size == real_word_size,\n+             \"bad block size in list[%d] (\" BLOCK_FORMAT \")\", index, BLOCK_FORMAT_ARGS(b));\n+      _blocks[index] = b->_next;\n@@ -163,3 +165,1 @@\n-\n-      return p;\n-\n+      return (MetaWord*)b;\n@@ -185,2 +185,5 @@\n-      for (Block* b = _blocks[i]; b != NULL; b = b->_next) {\n-        assert(b->_word_size == s, \"bad block size\");\n+      int pos = 0;\n+      for (Block* b = _blocks[i]; b != NULL; b = b->_next, pos++) {\n+        assert(b->_word_size == s,\n+               \"bad block size in list[%d] at pos %d (\" BLOCK_FORMAT \")\",\n+               i, pos, BLOCK_FORMAT_ARGS(b));\n","filename":"src\/hotspot\/share\/memory\/metaspace\/binList.hpp","additions":15,"deletions":12,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"memory\/metaspace\/chunklevel.hpp\"\n@@ -39,0 +40,18 @@\n+#define NODE_FORMAT \\\n+  \"@\" PTR_FORMAT \\\n+  \": canary \" INTPTR_FORMAT \\\n+  \", parent \" PTR_FORMAT \\\n+  \", left \" PTR_FORMAT \\\n+  \", right \" PTR_FORMAT \\\n+  \", next \" PTR_FORMAT \\\n+  \", size \" SIZE_FORMAT\n+\n+#define NODE_FORMAT_ARGS(n) \\\n+  p2i(n), \\\n+  (n)->_canary, \\\n+  p2i((n)->_parent), \\\n+  p2i((n)->_left), \\\n+  p2i((n)->_right), \\\n+  p2i((n)->_next), \\\n+  (n)->_word_size\n+\n@@ -43,2 +62,2 @@\n-\/\/ These asserts prints the tree, then asserts\n-#define assrt(cond, format, ...) \\\n+\/\/ This assert prints the tree too\n+#define tree_assert(cond, format, ...) \\\n@@ -47,0 +66,3 @@\n+      tty->print(\"Error in tree @\" PTR_FORMAT \": \", p2i(this)); \\\n+      tty->print_cr(format, __VA_ARGS__); \\\n+      tty->print_cr(\"Tree:\"); \\\n@@ -52,8 +74,3 @@\n-  \/\/ This assert prints the tree, then stops (generic message)\n-#define assrt0(cond) \\\n-  do { \\\n-    if (!(cond)) { \\\n-      print_tree(tty); \\\n-      assert(cond, \"sanity\"); \\\n-    } \\\n-  } while (0)\n+\/\/ Assert, prints tree and specific given node\n+#define tree_assert_invalid_node(cond, failure_node) \\\n+  tree_assert(cond, \"Invalid node: \" NODE_FORMAT, NODE_FORMAT_ARGS(failure_node))\n@@ -70,0 +87,13 @@\n+\/\/ Helper for verify()\n+void BlockTree::verify_node_pointer(const Node* n) const {\n+  tree_assert(os::is_readable_pointer(n),\n+              \"Invalid node: @\" PTR_FORMAT \" is unreadable.\", p2i(n));\n+  \/\/ If the canary is broken, this is either an invalid node pointer or\n+  \/\/ the node has been overwritten. Either way, print a hex dump, then\n+  \/\/ assert away.\n+  if (n->_canary != Node::_canary_value) {\n+    os::print_hex_dump(tty, (address)n, (address)n + sizeof(Node), 1);\n+    tree_assert(false, \"Invalid node: @\" PTR_FORMAT \" canary broken or pointer invalid\", p2i(n));\n+  }\n+}\n+\n@@ -75,1 +105,0 @@\n-\n@@ -93,0 +122,2 @@\n+      verify_node_pointer(n);\n+\n@@ -95,1 +126,1 @@\n-      assrt0(info.depth < 10000);\n+      tree_assert(info.depth < 10000, \"too deep (%d)\", info.depth);\n@@ -98,1 +129,0 @@\n-      \/\/ Verify node.\n@@ -100,1 +130,1 @@\n-        assrt0(n->_parent == NULL);\n+        tree_assert_invalid_node(n->_parent == NULL, n);\n@@ -102,1 +132,1 @@\n-        assrt0(n->_parent != NULL);\n+        tree_assert_invalid_node(n->_parent != NULL, n);\n@@ -106,3 +136,4 @@\n-      assrt(n->_word_size >= MinWordSize, \"bad node size \" SIZE_FORMAT, n->_word_size);\n-      assrt0(n->_word_size > info.lim1);\n-      assrt0(n->_word_size < info.lim2);\n+      tree_assert_invalid_node(n->_word_size >= MinWordSize, n);\n+      tree_assert_invalid_node(n->_word_size <= chunklevel::MAX_CHUNK_WORD_SIZE, n);\n+      tree_assert_invalid_node(n->_word_size > info.lim1, n);\n+      tree_assert_invalid_node(n->_word_size < info.lim2, n);\n@@ -112,2 +143,2 @@\n-        assrt0(n->_left != n);\n-        assrt0(n->_left->_parent == n);\n+        tree_assert_invalid_node(n->_left != n, n);\n+        tree_assert_invalid_node(n->_left->_parent == n, n);\n@@ -124,2 +155,2 @@\n-        assrt0(n->_right != n);\n-        assrt0(n->_right->_parent == n);\n+        tree_assert_invalid_node(n->_right != n, n);\n+        tree_assert_invalid_node(n->_right->_parent == n, n);\n@@ -138,2 +169,3 @@\n-        assrt0(n2 != n);\n-        assrt0(n2->_word_size == n->_word_size);\n+        verify_node_pointer(n2);\n+        tree_assert_invalid_node(n2 != n, n2); \/\/ catch simple circles\n+        tree_assert_invalid_node(n2->_word_size == n->_word_size, n2);\n@@ -147,0 +179,2 @@\n+  \/\/ (which also verifies that we visited every node, or at least\n+  \/\/  as many nodes as are in this tree)\n@@ -148,0 +182,2 @@\n+\n+  #undef assrt0n\n@@ -154,3 +190,0 @@\n-#undef assrt\n-#undef assrt0\n-\n@@ -158,0 +191,5 @@\n+\n+  \/\/ Note: we do not print the tree indented, since I found that printing it\n+  \/\/  as a quasi list is much clearer to the eye.\n+  \/\/ We print the tree depth-first, with stacked nodes below normal ones\n+  \/\/  (normal \"real\" nodes are marked with a leading '+')\n@@ -171,0 +209,1 @@\n+\n@@ -172,2 +211,17 @@\n-      for (int i = 0; i < info.depth; i++) {\n-         st->print(\"---\");\n+      st->print(\"%4d + \", info.depth);\n+      if (os::is_readable_pointer(n)) {\n+        st->print_cr(NODE_FORMAT, NODE_FORMAT_ARGS(n));\n+      } else {\n+        st->print_cr(\"@\" PTR_FORMAT \": unreadable (skipping subtree)\", p2i(n));\n+        continue; \/\/ don't print this subtree\n+      }\n+\n+      \/\/ Print same-sized-nodes stacked under this node\n+      for (Node* n2 = n->_next; n2 != NULL; n2 = n2->_next) {\n+        st->print_raw(\"       \");\n+        if (os::is_readable_pointer(n2)) {\n+          st->print_cr(NODE_FORMAT, NODE_FORMAT_ARGS(n2));\n+        } else {\n+          st->print_cr(\"@\" PTR_FORMAT \": unreadable (skipping rest of chain).\", p2i(n2));\n+          break; \/\/ stop printing this chain.\n+        }\n@@ -175,1 +229,1 @@\n-      st->print_cr(\"<\" PTR_FORMAT \" (size \" SIZE_FORMAT \")\", p2i(n), n->_word_size);\n+\n","filename":"src\/hotspot\/share\/memory\/metaspace\/blockTree.cpp","additions":84,"deletions":30,"binary":false,"changes":114,"status":"modified"},{"patch":"@@ -80,0 +80,10 @@\n+    static const intptr_t _canary_value =\n+        NOT_LP64(0x4e4f4445) LP64_ONLY(0x4e4f44454e4f4445ULL); \/\/ \"NODE\" resp \"NODENODE\"\n+\n+    \/\/ Note: we afford us the luxury of an always-there canary value.\n+    \/\/  The space for that is there (these nodes are only used to manage larger blocks,\n+    \/\/  see FreeBlocks::MaxSmallBlocksWordSize).\n+    \/\/  It is initialized in debug and release, but only automatically tested\n+    \/\/  in debug.\n+    const intptr_t _canary;\n+\n@@ -81,0 +91,1 @@\n+    \/\/  (Note: all null if this is a stacked node)\n@@ -94,0 +105,1 @@\n+      _canary(_canary_value),\n@@ -101,0 +113,7 @@\n+#ifdef ASSERT\n+    bool valid() const {\n+      return _canary == _canary_value &&\n+        _word_size >= sizeof(Node) &&\n+        _word_size < chunklevel::MAX_CHUNK_WORD_SIZE;\n+    }\n+#endif\n@@ -106,0 +125,5 @@\n+#ifdef ASSERT\n+  \/\/ Run a quick check on a node; upon suspicion dive into a full tree check.\n+  void check_node(const Node* n) const { if (!n->valid()) verify(); }\n+#endif\n+\n@@ -199,1 +223,1 @@\n-  static void insert(Node* insertion_point, Node* n) {\n+  void insert(Node* insertion_point, Node* n) {\n@@ -202,0 +226,1 @@\n+      DEBUG_ONLY(check_node(insertion_point);)\n@@ -225,1 +250,1 @@\n-  static Node* find_closest_fit(Node* n, size_t s) {\n+  Node* find_closest_fit(Node* n, size_t s) {\n@@ -228,0 +253,1 @@\n+      DEBUG_ONLY(check_node(n);)\n@@ -314,0 +340,2 @@\n+  \/\/ Helper for verify()\n+  void verify_node_pointer(const Node* n) const;\n@@ -342,0 +370,1 @@\n+      DEBUG_ONLY(check_node(n);)\n","filename":"src\/hotspot\/share\/memory\/metaspace\/blockTree.hpp","additions":31,"deletions":2,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -72,0 +72,4 @@\n+  \/\/ This verifies that blocks too large to go into the binlist can be\n+  \/\/ kept in the blocktree.\n+  STATIC_ASSERT(BinList32::MaxWordSize >= BlockTree::MinWordSize);\n+\n","filename":"src\/hotspot\/share\/memory\/metaspace\/freeBlocks.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -218,0 +218,19 @@\n+}\n+\n+\/\/ Test that an overwritten node would result in an assert and a printed tree\n+TEST_VM_ASSERT_MSG(metaspace, BlockTree_overwriter_test, \"Invalid node\") {\n+  static const size_t sizes1[] = { 30, 17, 0 };\n+  static const size_t sizes2[] = { 12, 12, 0 };\n+\n+  BlockTree bt;\n+  FeederBuffer fb(4 * K);\n+\n+  \/\/ some nodes...\n+  create_nodes(sizes1, fb, bt);\n+\n+  \/\/ a node we will break...\n+  MetaWord* p_broken = fb.get(12);\n+  bt.add_block(p_broken, 12);\n+\n+  \/\/ some more nodes...\n+  create_nodes(sizes2, fb, bt);\n@@ -219,0 +238,7 @@\n+  \/\/ overwrite node memory (only the very first byte), then verify tree.\n+  \/\/ Verification should catch the broken canary, print the tree,\n+  \/\/ then assert.\n+  LOG(\"Will break node at \" PTR_FORMAT \".\", p2i(p_broken));\n+  tty->print_cr(\"Death test, please ignore the following \\\"Invalid node\\\" printout.\");\n+  *((char*)p_broken) = '\\0';\n+  bt.verify();\n","filename":"test\/hotspot\/gtest\/metaspace\/test_blocktree.cpp","additions":26,"deletions":0,"binary":false,"changes":26,"status":"modified"}]}