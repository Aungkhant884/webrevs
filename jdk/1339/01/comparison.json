{"files":[{"patch":"@@ -88,0 +88,3 @@\n+#define BLOCK_FORMAT          \"Block @\" PTR_FORMAT \": size: \" SIZE_FORMAT \", next: \" PTR_FORMAT\n+#define BLOCK_FORMAT_ARGS(b)  p2i(b), (b)->_word_size, p2i((b)->_next)\n+\n@@ -185,2 +188,5 @@\n-      for (Block* b = _blocks[i]; b != NULL; b = b->_next) {\n-        assert(b->_word_size == s, \"bad block size\");\n+      int pos = 0;\n+      for (Block* b = _blocks[i]; b != NULL; b = b->_next, pos++) {\n+        assert(b->_word_size == s,\n+               \"bad block size in list[%u] at pos %d (\" BLOCK_FORMAT \")\",\n+               i, pos, BLOCK_FORMAT_ARGS(b));\n","filename":"src\/hotspot\/share\/memory\/metaspace\/binList.hpp","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"memory\/metaspace\/chunklevel.hpp\"\n@@ -39,0 +40,18 @@\n+#define NODE_FORMAT \\\n+  \"@\" PTR_FORMAT \\\n+  \": canary \" INTPTR_FORMAT \\\n+  \", parent \" PTR_FORMAT \\\n+  \", left \" PTR_FORMAT \\\n+  \", right \" PTR_FORMAT \\\n+  \", next \" PTR_FORMAT \\\n+  \", size \" SIZE_FORMAT\n+\n+#define NODE_FORMAT_ARGS(n) \\\n+  p2i(n), \\\n+  ((n) ? (n)->_canary : 0), \\\n+  p2i((n) ? (n)->_parent : NULL), \\\n+  p2i((n) ? (n)->_left : NULL), \\\n+  p2i((n) ? (n)->_right : NULL), \\\n+  p2i((n) ? (n)->_next : NULL), \\\n+  ((n) ? (n)->_word_size : 0)\n+\n@@ -43,2 +62,2 @@\n-\/\/ These asserts prints the tree, then asserts\n-#define assrt(cond, format, ...) \\\n+\/\/ This assert prints the tree too\n+#define tree_assert(cond, format, ...) \\\n@@ -47,0 +66,3 @@\n+      tty->print(\"Error in tree @\" PTR_FORMAT \": \", p2i(this)); \\\n+      tty->print_cr(format, __VA_ARGS__); \\\n+      tty->print_cr(\"Tree:\"); \\\n@@ -52,8 +74,4 @@\n-  \/\/ This assert prints the tree, then stops (generic message)\n-#define assrt0(cond) \\\n-  do { \\\n-    if (!(cond)) { \\\n-      print_tree(tty); \\\n-      assert(cond, \"sanity\"); \\\n-    } \\\n-  } while (0)\n+\/\/ Assert, prints tree and specific given node\n+#define tree_assert_invalid_node(cond, failure_node) \\\n+  tree_assert(cond, \"Invalid node: \" NODE_FORMAT, NODE_FORMAT_ARGS(failure_node))\n+\n@@ -75,1 +93,0 @@\n-\n@@ -95,1 +112,1 @@\n-      assrt0(info.depth < 10000);\n+      tree_assert(info.depth < 10000, \"too deep (%u)\", info.depth);\n@@ -99,0 +116,2 @@\n+      tree_assert_invalid_node(n->_canary == Node::_canary_value, n);\n+\n@@ -100,1 +119,1 @@\n-        assrt0(n->_parent == NULL);\n+        tree_assert_invalid_node(n->_parent == NULL, n);\n@@ -102,1 +121,1 @@\n-        assrt0(n->_parent != NULL);\n+        tree_assert_invalid_node(n->_parent != NULL, n);\n@@ -106,3 +125,4 @@\n-      assrt(n->_word_size >= MinWordSize, \"bad node size \" SIZE_FORMAT, n->_word_size);\n-      assrt0(n->_word_size > info.lim1);\n-      assrt0(n->_word_size < info.lim2);\n+      tree_assert_invalid_node(n->_word_size >= MinWordSize &&\n+                               n->_word_size <= chunklevel::MAX_CHUNK_WORD_SIZE, n);\n+      tree_assert_invalid_node(n->_word_size > info.lim1, n);\n+      tree_assert_invalid_node(n->_word_size < info.lim2, n);\n@@ -112,2 +132,2 @@\n-        assrt0(n->_left != n);\n-        assrt0(n->_left->_parent == n);\n+        tree_assert_invalid_node(n->_left != n, n);\n+        tree_assert_invalid_node(n->_left->_parent == n, n);\n@@ -124,2 +144,2 @@\n-        assrt0(n->_right != n);\n-        assrt0(n->_right->_parent == n);\n+        tree_assert_invalid_node(n->_right != n, n);\n+        tree_assert_invalid_node(n->_right->_parent == n, n);\n@@ -138,2 +158,3 @@\n-        assrt0(n2 != n);\n-        assrt0(n2->_word_size == n->_word_size);\n+        tree_assert_invalid_node(n2->_canary == Node::_canary_value, n2);\n+        tree_assert_invalid_node(n2 != n, n2);\n+        tree_assert_invalid_node(n2->_word_size == n->_word_size, n2);\n@@ -147,0 +168,2 @@\n+  \/\/ (which also verifies that we visited every node, or at least\n+  \/\/  as many nodes as are in this tree)\n@@ -148,0 +171,2 @@\n+\n+  #undef assrt0n\n@@ -154,3 +179,0 @@\n-#undef assrt\n-#undef assrt0\n-\n@@ -158,0 +180,6 @@\n+\n+  \/\/ Note: we do not print the tree indented, since I found that printing it\n+  \/\/  as a quasi list is much clearer to the eye.\n+  \/\/ We print the tree depth-first, with stacked nodes below normal ones\n+  \/\/  (normal \"real\" nodes are marked with a leading '+')\n+\n@@ -171,0 +199,1 @@\n+\n@@ -172,2 +201,7 @@\n-      for (int i = 0; i < info.depth; i++) {\n-         st->print(\"---\");\n+      st->print(\"%4d + \", info.depth);\n+      st->print_cr(NODE_FORMAT, NODE_FORMAT_ARGS(n));\n+\n+      \/\/ Print same-sized-nodes stacked under this node\n+      for (Node* n2 = n->_next; n2 != NULL; n2 = n2->_next) {\n+        st->print_raw(\"       \");\n+        st->print_cr(NODE_FORMAT, NODE_FORMAT_ARGS(n2));\n@@ -175,1 +209,1 @@\n-      st->print_cr(\"<\" PTR_FORMAT \" (size \" SIZE_FORMAT \")\", p2i(n), n->_word_size);\n+\n","filename":"src\/hotspot\/share\/memory\/metaspace\/blockTree.cpp","additions":63,"deletions":29,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -80,0 +80,10 @@\n+    static const intptr_t _canary_value =\n+        NOT_LP64(0x4e4f4445) LP64_ONLY(0x4e4f44454e4f4445ULL); \/\/ \"NODE\" resp \"NODENODE\"\n+\n+    \/\/ Note: we afford us the luxury of an always-there canary value.\n+    \/\/  The space for that is there (these nodes are only used to manage larger blocks,\n+    \/\/  see FreeBlocks::MaxSmallBlocksWordSize).\n+    \/\/  It is initialized in debug and release, but only automatically tested\n+    \/\/  in debug.\n+    const intptr_t _canary;\n+\n@@ -94,0 +104,1 @@\n+      _canary(_canary_value),\n","filename":"src\/hotspot\/share\/memory\/metaspace\/blockTree.hpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -72,0 +72,4 @@\n+  \/\/ This verifies that blocks too large to go into the binlist can be\n+  \/\/ kept in the blocktree.\n+  STATIC_ASSERT(BinList32::MaxWordSize >= BlockTree::MinWordSize);\n+\n","filename":"src\/hotspot\/share\/memory\/metaspace\/freeBlocks.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -218,0 +218,19 @@\n+}\n+\n+\/\/ Test that an overwritten node would result in an assert and a printed tree\n+TEST_VM_ASSERT_MSG(metaspace, BlockTree_overwriter_test, \"Invalid node\") {\n+  static const size_t sizes1[] = { 30, 17, 0 };\n+  static const size_t sizes2[] = { 12, 12, 0 };\n+\n+  BlockTree bt;\n+  FeederBuffer fb(4 * K);\n+\n+  \/\/ some nodes...\n+  create_nodes(sizes1, fb, bt);\n+\n+  \/\/ a node we will break...\n+  MetaWord* p_broken = fb.get(12);\n+  bt.add_block(p_broken, 12);\n+\n+  \/\/ some more nodes...\n+  create_nodes(sizes2, fb, bt);\n@@ -219,0 +238,7 @@\n+  \/\/ overwrite node memory (only the very first byte), then verify tree.\n+  \/\/ Verification should catch the broken canary, print the tree,\n+  \/\/ then assert.\n+  LOG(\"Will break node at \" PTR_FORMAT \".\", p2i(p_broken));\n+  tty->print_cr(\"Death test, please ignore the following \\\"Invalid node\\\" printout.\");\n+  *((char*)p_broken) = '\\0';\n+  bt.verify();\n","filename":"test\/hotspot\/gtest\/metaspace\/test_blocktree.cpp","additions":26,"deletions":0,"binary":false,"changes":26,"status":"modified"}]}