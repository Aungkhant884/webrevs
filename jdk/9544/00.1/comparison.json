{"files":[{"patch":"@@ -377,2 +377,4 @@\n-      \/\/ Map the maximal common vector\n-      if (VectorNode::implemented(n->Opcode(), cur_max_vector, bt)) {\n+      \/\/ Map the maximal common vector except conversion nodes, because we can't get\n+      \/\/ the precise basic type for conversion nodes in the stage of early analysis.\n+      if (!VectorNode::is_convert_opcode(n->Opcode()) &&\n+          VectorNode::implemented(n->Opcode(), cur_max_vector, bt)) {\n@@ -1010,0 +1012,6 @@\n+  \/\/ Check for special case where there is a type conversion between different data size.\n+  int vectsize = max_vector_size_in_def_use_chain(s);\n+  if (vectsize < max_vector_size(btype)) {\n+    vw = MIN2(vectsize * type2aelembytes(btype), vw);\n+  }\n+\n@@ -1198,1 +1206,3 @@\n-  if (Matcher::max_vector_size(bt1) < 2) {\n+  BasicType longer_bt = longer_type_for_conversion(s1);\n+  if (max_vector_size(bt1) < 2 ||\n+      (longer_bt != T_ILLEGAL && max_vector_size(longer_bt) < 2)) {\n@@ -1441,0 +1451,16 @@\n+\/\/------------------------------adjust_alignment_for_type_conversion---------------------------------\n+\/\/ Adjust the target alignment if conversion between different data size exists in def-use nodes.\n+int SuperWord::adjust_alignment_for_type_conversion(Node* s, Node* t, int align) {\n+  \/\/ Do not use superword for non-primitives\n+  BasicType bt1 = velt_basic_type(s);\n+  BasicType bt2 = velt_basic_type(t);\n+  if (!is_java_primitive(bt1) || !is_java_primitive(bt2)) {\n+    return align;\n+  }\n+  if (longer_type_for_conversion(s) != T_ILLEGAL ||\n+      longer_type_for_conversion(t) != T_ILLEGAL) {\n+    align = align \/ data_size(s) * data_size(t);\n+  }\n+  return align;\n+}\n+\n@@ -1452,2 +1478,1 @@\n-  int align = alignment(s1);\n-  NOT_PRODUCT(if(is_trace_alignment()) tty->print_cr(\"SuperWord::follow_use_defs: s1 %d, align %d\", s1->_idx, align);)\n+  NOT_PRODUCT(if(is_trace_alignment()) tty->print_cr(\"SuperWord::follow_use_defs: s1 %d, align %d\", s1->_idx, alignment(s1));)\n@@ -1458,0 +1483,1 @@\n+    int align = alignment(s1);\n@@ -1462,0 +1488,1 @@\n+    align = adjust_alignment_for_type_conversion(s1, t1, align);\n@@ -1505,1 +1532,3 @@\n-      if (stmts_can_pack(t1, t2, align)) {\n+      int adjusted_align = alignment(s1);\n+      adjusted_align = adjust_alignment_for_type_conversion(s1, t1, adjusted_align);\n+      if (stmts_can_pack(t1, t2, adjusted_align)) {\n@@ -1511,0 +1540,1 @@\n+          align = adjusted_align;\n@@ -1703,2 +1733,1 @@\n-      BasicType bt = velt_basic_type(p1->at(0));\n-      uint max_vlen = max_vector_size(bt); \/\/ Max elements in vector\n+      uint max_vlen = max_vector_size_in_def_use_chain(p1->at(0)); \/\/ Max elements in vector\n@@ -2027,0 +2056,2 @@\n+    } else if (VectorNode::is_convert_opcode(opc)) {\n+      retValue = VectorCastNode::implemented(opc, size, velt_basic_type(p0->in(1)), velt_basic_type(p0));\n@@ -2623,2 +2654,1 @@\n-      } else if (opc == Op_ConvI2F || opc == Op_ConvL2D ||\n-                 opc == Op_ConvF2I || opc == Op_ConvD2L) {\n+      } else if (VectorNode::is_convert_opcode(opc)) {\n@@ -2627,1 +2657,1 @@\n-        int vopc = VectorNode::opcode(opc, bt);\n+        int vopc = VectorCastNode::opcode(in->bottom_type()->is_vect()->element_basic_type());\n@@ -3141,1 +3171,0 @@\n-\n@@ -3144,0 +3173,18 @@\n+\n+  if (longer_type_for_conversion(use) != T_ILLEGAL) {\n+    \/\/ type conversion takes a type of a kind of size and produces a type of\n+    \/\/ another size - hence the special checks on alignment and size.\n+    for (uint i = 0; i < u_pk->size(); i++) {\n+      Node* ui = u_pk->at(i);\n+      Node* di = d_pk->at(i);\n+      if (ui->in(u_idx) != di) {\n+        return false;\n+      }\n+      if (alignment(ui) \/ type2aelembytes(velt_basic_type(ui)) !=\n+          alignment(di) \/ type2aelembytes(velt_basic_type(di))) {\n+        return false;\n+      }\n+    }\n+    return true;\n+  }\n+\n@@ -3376,0 +3423,48 @@\n+BasicType SuperWord::longer_type_for_conversion(Node* n) {\n+  if (!VectorNode::is_convert_opcode(n->Opcode()) ||\n+      !in_bb(n->in(1))) {\n+    return T_ILLEGAL;\n+  }\n+  assert(in_bb(n), \"must be in the bb\");\n+  BasicType src_t = velt_basic_type(n->in(1));\n+  BasicType dst_t = velt_basic_type(n);\n+  \/\/ Do not use superword for non-primitives.\n+  \/\/ Superword does not support casting involving unsigned types.\n+  if (!is_java_primitive(src_t) || is_unsigned_subword_type(src_t) ||\n+      !is_java_primitive(dst_t) || is_unsigned_subword_type(dst_t)) {\n+    return T_ILLEGAL;\n+  }\n+  int src_size = type2aelembytes(src_t);\n+  int dst_size = type2aelembytes(dst_t);\n+  return src_size == dst_size ? T_ILLEGAL\n+                              : (src_size > dst_size ? src_t : dst_t);\n+}\n+\n+int SuperWord::max_vector_size_in_def_use_chain(Node* n) {\n+  BasicType bt = velt_basic_type(n);\n+  BasicType vt = bt;\n+\n+  \/\/ find the longest type among def nodes.\n+  uint start, end;\n+  VectorNode::vector_operands(n, &start, &end);\n+  for (uint i = start; i < end; ++i) {\n+    Node* input = n->in(i);\n+    if (!in_bb(input)) continue;\n+    BasicType newt = longer_type_for_conversion(input);\n+    vt = (newt == T_ILLEGAL) ? vt : newt;\n+  }\n+\n+  \/\/ find the longest type among use nodes.\n+  for (uint i = 0; i < n->outcnt(); ++i) {\n+    Node* output = n->raw_out(i);\n+    if (!in_bb(output)) continue;\n+    BasicType newt = longer_type_for_conversion(output);\n+    vt = (newt == T_ILLEGAL) ? vt : newt;\n+  }\n+\n+  int max = max_vector_size(vt);\n+  \/\/ If now there is no vectors for the longest type, the nodes with the longest\n+  \/\/ type in the def-use chain are not packed in SuperWord::stmts_can_pack.\n+  return max < 2 ? max_vector_size(bt) : max;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/superword.cpp","additions":107,"deletions":12,"binary":false,"changes":119,"status":"modified"}]}