{"files":[{"patch":"@@ -38,1 +38,1 @@\n-  G1SegmentedArray<Elem, mtGCCardSet>(name, buffer_options, free_buffer_list),\n+  _segmented_array(name, buffer_options, free_buffer_list),\n@@ -45,1 +45,1 @@\n-  uint elem_size = G1SegmentedArray<Elem, mtGCCardSet>::elem_size();\n+  uint elem_size = _segmented_array.elem_size();\n@@ -88,1 +88,0 @@\n-  \/\/ assert(elem_size() >= sizeof(G1CardSetContainer), \"size mismatch\");\n@@ -118,2 +117,0 @@\n-\n-  G1SegmentedArray<Elem, mtGCCardSet>::drop_all();\n@@ -124,4 +121,4 @@\n-  uint num_allocated_nodes = G1SegmentedArray<Elem, mtGCCardSet>::num_allocated_nodes();\n-  uint num_available_nodes = G1SegmentedArray<Elem, mtGCCardSet>::num_available_nodes();\n-  const G1SegmentedArrayBuffer<mtGCCardSet>* first_array_buffer = G1SegmentedArray<Elem, mtGCCardSet>::first_array_buffer();\n-  uint num_buffers = G1SegmentedArray<Elem, mtGCCardSet>::num_buffers();\n+  uint num_allocated_nodes = _segmented_array.num_allocated_nodes();\n+  uint num_available_nodes = _segmented_array.num_available_nodes();\n+  const G1SegmentedArrayBuffer<mtGCCardSet>* first_array_buffer = _segmented_array.first_array_buffer();\n+  uint num_buffers = _segmented_array.num_buffers();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardSetMemory.cpp","additions":6,"deletions":9,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -64,14 +64,0 @@\n-\/\/ Actual allocation from the C heap occurs on G1CardSetBuffer basis, i.e. sets\n-\/\/ of elements. The assumed allocation pattern for these G1CardSetBuffer elements\n-\/\/ is assumed to be strictly two-phased:\n-\/\/\n-\/\/ - in the first phase, G1CardSetBuffers are allocated from the C heap (or a free\n-\/\/ list given at initialization time). This allocation may occur in parallel. This\n-\/\/ typically corresponds to a single mutator phase, but may extend over multiple.\n-\/\/\n-\/\/ - in the second phase, G1CardSetBuffers are given back in bulk to the free list.\n-\/\/ This is typically done during a GC pause.\n-\/\/\n-\/\/ Some third party is responsible for giving back memory from the free list to\n-\/\/ the operating system.\n-\/\/\n@@ -86,1 +72,1 @@\n-\/\/ The G1CardSetContainerOnHeaps free list is a linked list of G1CardSetContainers\n+\/\/ The NodeStack free list is a linked list of G1CardSetContainers\n@@ -99,1 +85,1 @@\n-class G1CardSetAllocator : public G1SegmentedArray<Elem, mtGCCardSet> {\n+class G1CardSetAllocator {\n@@ -102,0 +88,1 @@\n+  typedef G1SegmentedArray<Elem, mtGCCardSet> SegmentedArray;\n@@ -107,0 +94,1 @@\n+  SegmentedArray _segmented_array;\n@@ -138,2 +126,2 @@\n-      G1SegmentedArray<Elem, mtGCCardSet>::num_buffers() * sizeof(G1CardSetBuffer)\n-            + G1SegmentedArray<Elem, mtGCCardSet>::num_available_nodes() * G1SegmentedArray<Elem, mtGCCardSet>::elem_size();\n+      _segmented_array.num_buffers() * sizeof(G1CardSetBuffer)\n+            + _segmented_array.num_available_nodes() * _segmented_array.elem_size();\n@@ -143,3 +131,3 @@\n-    return (G1SegmentedArray<Elem, mtGCCardSet>::num_available_nodes()\n-              - (G1SegmentedArray<Elem, mtGCCardSet>::num_allocated_nodes() - _num_pending_nodes))\n-                * G1SegmentedArray<Elem, mtGCCardSet>::elem_size();\n+    return (_segmented_array.num_available_nodes()\n+              - (_segmented_array.num_allocated_nodes() - _num_pending_nodes))\n+                * _segmented_array.elem_size();\n@@ -147,0 +135,1 @@\n+  inline uint num_buffers() { return _segmented_array.num_buffers(); }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardSetMemory.hpp","additions":10,"deletions":21,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-  uint elem_size = G1SegmentedArray<Elem, mtGCCardSet>::elem_size();\n+  uint elem_size = _segmented_array.elem_size();\n@@ -60,1 +60,1 @@\n-  Elem* elem = G1SegmentedArray<Elem, mtGCCardSet>::allocate();\n+  Elem* elem = _segmented_array.allocate();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardSetMemory.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -84,2 +84,0 @@\n-  const char* start() const { return _buffer; }\n-\n@@ -139,1 +137,0 @@\n-\n@@ -157,1 +154,1 @@\n-  uint elem_size() const {return _elem_size;}\n+  uint elem_size() const { return _elem_size; }\n@@ -167,0 +164,24 @@\n+\/\/\n+\/\/ Implementation details as below:\n+\/\/\n+\/\/ Arena-like allocator for (card set, or ...) heap memory objects (Elem elements).\n+\/\/\n+\/\/ Actual allocation from the C heap occurs on G1SegmentedArrayBuffer basis, i.e. segments\n+\/\/ of elements. The assumed allocation pattern for these G1SegmentedArrayBuffer elements\n+\/\/ is assumed to be strictly two-phased:\n+\/\/\n+\/\/ - in the first phase, G1SegmentedArrayBuffers are allocated from the C heap (or a free\n+\/\/ list given at initialization time). This allocation may occur in parallel. This\n+\/\/ typically corresponds to a single mutator phase, but may extend over multiple.\n+\/\/\n+\/\/ - in the second phase, G1SegmentedArrayBuffers are given back in bulk to the free list.\n+\/\/ This is typically done during a GC pause.\n+\/\/\n+\/\/ Some third party is responsible for giving back memory from the free list to\n+\/\/ the operating system.\n+\/\/\n+\/\/ Allocation and deallocation in the first phase basis may occur by multiple threads at once.\n+\/\/\n+\/\/ The class also manages a few counters for statistics using atomic operations.\n+\/\/ Their values are only consistent within each other with extra global\n+\/\/ synchronization.\n@@ -173,3 +194,0 @@\n-  volatile uint _num_available_nodes; \/\/ Number of nodes available in all buffers (allocated + free + pending + not yet used).\n-  volatile uint _num_allocated_nodes; \/\/ Number of total nodes allocated and in use.\n-\n@@ -182,1 +200,4 @@\n-  \/\/ preferentially get new buffers from.\n+                                                       \/\/ preferentially get new buffers from.\n+\n+  volatile uint _num_available_nodes; \/\/ Number of nodes available in all buffers (allocated + free + pending + not yet used).\n+  volatile uint _num_allocated_nodes; \/\/ Number of total nodes allocated and in use.\n@@ -187,1 +208,1 @@\n-protected:\n+public:\n@@ -193,1 +214,0 @@\n-public:\n@@ -208,5 +228,0 @@\n-\n-  uint length();\n-\n-  template<typename Visitor>\n-  void iterate_nodes(Visitor& v);\n@@ -215,1 +230,0 @@\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1SegmentedArray.hpp","additions":30,"deletions":16,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-#include \"utilities\/globalCounter.hpp\"\n@@ -35,2 +34,0 @@\n-\/\/ ==== G1SegmentedArrayBuffer ====\n-\n@@ -63,2 +60,0 @@\n-\/\/ ==== G1SegmentedArrayBufferList ====\n-\n@@ -126,2 +121,0 @@\n-\/\/ ==== G1SegmentedArray ====\n-\n@@ -129,2 +122,1 @@\n-G1SegmentedArrayBuffer<flag>* G1SegmentedArray<Elem, flag>::create_new_buffer(\n-  G1SegmentedArrayBuffer<flag>* const prev) {\n+G1SegmentedArrayBuffer<flag>* G1SegmentedArray<Elem, flag>::create_new_buffer(G1SegmentedArrayBuffer<flag>* const prev) {\n@@ -173,2 +165,0 @@\n-     _num_available_nodes(0),\n-     _num_allocated_nodes(0),\n@@ -179,1 +169,3 @@\n-     _free_buffer_list(free_buffer_list) {\n+     _free_buffer_list(free_buffer_list),\n+     _num_available_nodes(0),\n+     _num_allocated_nodes(0) {\n@@ -222,0 +214,3 @@\n+  uint es = elem_size();\n+  assert(es > 0, \"instance size not set.\");\n+\n@@ -246,36 +241,0 @@\n-class LengthVisitor {\n-  uint _total;\n-public:\n-  LengthVisitor() : _total(0) {}\n-  void visit(G1SegmentedArrayBuffer<mtGC>* node, uint32_t limit) {\n-    _total += limit;\n-  }\n-  uint length() {\n-    return _total;\n-  }\n-};\n-\n-template <class Elem, MEMFLAGS flag>\n-uint G1SegmentedArray<Elem, flag>::length() {\n-  LengthVisitor v;\n-  iterate_nodes(v);\n-  return v.length();\n-}\n-\n-template <class Elem, MEMFLAGS flag>\n-template <typename Visitor>\n-void G1SegmentedArray<Elem, flag>::iterate_nodes(Visitor& v)  {\n-  G1SegmentedArrayBuffer<flag>* cur = Atomic::load_acquire(&_first);\n-\n-  if (cur != nullptr) {\n-    assert(_last != nullptr, \"If there is at least one element, there must be a last one.\");\n-\n-    while (cur != nullptr) {\n-      uint limit = cur->length();\n-      v.visit(cur, limit);\n-\n-      cur = cur->next();\n-    }\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1SegmentedArray.inline.hpp","additions":7,"deletions":48,"binary":false,"changes":55,"status":"modified"}]}