{"files":[{"patch":"@@ -38,1 +38,0 @@\n-import java.time.Duration;\n@@ -56,2 +55,4 @@\n-    \/\/ Usually succeeds in less than a second, but give it time\n-    private static final Duration MAX_DURATION = Duration.ofSeconds(60);\n+    \/\/ With -Xmx4M it succeeds in 30 iterations; with 40M it needs\n+    \/\/ 926 iterations, so 5000 should be safe. If this ever fails\n+    \/\/ in future, you can just increase the number of iterations.\n+    private static final int MAX_ITERATIONS = 5000;\n@@ -78,3 +79,1 @@\n-        long start = System.nanoTime();\n-        long deadline = start + MAX_DURATION.toNanos();\n-        while (System.nanoTime() < deadline) {\n+        for (int count = 0; count < MAX_ITERATIONS; ++count) {\n","filename":"test\/jdk\/jdk\/dynalink\/TypeConverterFactoryMemoryLeakTest.java","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -37,1 +37,0 @@\n-import java.time.Duration;\n@@ -54,2 +53,5 @@\n-    \/\/ Usually succeeds in less than a second, but give it time\n-    private static final Duration MAX_DURATION = Duration.ofSeconds(60);\n+    \/\/ With -Xmx4M the three tests succeeds in 219, 145, and 130\n+    \/\/ iteration, respectively, so 5000 should be safe; that works up to\n+    \/\/ -Xmx38M. If this ever fails in future, you can just increase the\n+    \/\/ number of iterations.\n+    private static final int MAX_ITERATIONS = 5000;\n@@ -138,3 +140,1 @@\n-        long start = System.nanoTime();\n-        long deadline = start + MAX_DURATION.toNanos();\n-        while (System.nanoTime() < deadline) {\n+        for (int count = 0; count < MAX_ITERATIONS; ++count) {\n@@ -169,3 +169,1 @@\n-        long start = System.nanoTime();\n-        long deadline = start + MAX_DURATION.toNanos();\n-        while (System.nanoTime() < deadline) {\n+        for (int count = 0; count < MAX_ITERATIONS; ++count) {\n","filename":"test\/jdk\/jdk\/dynalink\/TypeConverterFactoryRetentionTests.java","additions":7,"deletions":9,"binary":false,"changes":16,"status":"modified"}]}