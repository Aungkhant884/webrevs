{"files":[{"patch":"@@ -65,4 +65,1 @@\n-  BUILD_JDK_JTREG_EXECUTABLES_LIBS_exeNullCallerClassLoaderTest := jvm.lib\n-  BUILD_JDK_JTREG_EXECUTABLES_LIBS_exeNullCallerLookupTest := jvm.lib\n-  BUILD_JDK_JTREG_EXECUTABLES_LIBS_exeNullCallerResourceBundle := jvm.lib\n-  BUILD_JDK_JTREG_EXECUTABLES_LIBS_exeNullCallerGetResource := jvm.lib\n+  BUILD_JDK_JTREG_EXECUTABLES_LIBS_exeNullCallerTest := jvm.lib\n@@ -96,4 +93,1 @@\n-  BUILD_JDK_JTREG_EXECUTABLES_LIBS_exeNullCallerClassLoaderTest := -ljvm\n-  BUILD_JDK_JTREG_EXECUTABLES_LIBS_exeNullCallerLookupTest := -ljvm\n-  BUILD_JDK_JTREG_EXECUTABLES_LIBS_exeNullCallerResourceBundle := -ljvm\n-  BUILD_JDK_JTREG_EXECUTABLES_LIBS_exeNullCallerGetResource := -ljvm\n+  BUILD_JDK_JTREG_EXECUTABLES_LIBS_exeNullCallerTest := -ljvm\n","filename":"make\/test\/JtregNativeJdk.gmk","additions":2,"deletions":8,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -113,1 +113,2 @@\n-    jdk\/modules\n+    jdk\/modules \\\n+    jni\/nullCaller\n","filename":"test\/jdk\/TEST.groups","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1,71 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-\/**\n- * @test\n- * @bug 8281000\n- * @summary Test uses custom launcher that starts VM using JNI that verifies\n- *          ClassLoader.registerAsParallelCapable with null caller class\n- *          throws an IllegalCallerException.\n- * @library \/test\/lib\n- * @requires os.family != \"aix\"\n- * @run main\/native NullCallerClassLoaderTest\n- *\/\n-\n-\/\/ Test disabled on AIX since we cannot invoke the JVM on the primordial thread.\n-\n-import java.io.File;\n-import java.util.Map;\n-import jdk.test.lib.Platform;\n-import jdk.test.lib.process.OutputAnalyzer;\n-\n-import java.io.IOException;\n-import java.nio.file.Path;\n-import java.nio.file.Paths;\n-\n-public class NullCallerClassLoaderTest {\n-    public static void main(String[] args) throws IOException {\n-        Path launcher = Path.of(System.getProperty(\"test.nativepath\"), \"NullCallerClassLoaderTest\");\n-        ProcessBuilder pb = new ProcessBuilder(launcher.toString());\n-        Map<String, String> env = pb.environment();\n-\n-        String libDir = Platform.libDir().toString();\n-        String vmDir = Platform.jvmLibDir().toString();\n-\n-        \/\/ set up shared library path\n-        String sharedLibraryPathEnvName = Platform.sharedLibraryPathVariableName();\n-        env.compute(sharedLibraryPathEnvName,\n-                (k, v) -> (v == null) ? libDir : v + File.pathSeparator + libDir);\n-        env.compute(sharedLibraryPathEnvName,\n-                (k, v) -> (v == null) ? vmDir : v + File.pathSeparator + vmDir);\n-\n-        System.out.println(\"Launching: \" + launcher + \" shared library path: \" +\n-                env.get(sharedLibraryPathEnvName));\n-        new OutputAnalyzer(pb.start())\n-                .outputTo(System.out)\n-                .errorTo(System.err)\n-                .shouldHaveExitValue(0);\n-    }\n-}\n-\n","filename":"test\/jdk\/java\/lang\/ClassLoader\/exeNullCallerClassLoaderTest\/NullCallerClassLoaderTest.java","additions":0,"deletions":71,"binary":false,"changes":71,"status":"deleted"},{"patch":"@@ -1,76 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include <stdio.h>\n-#include <stdlib.h>\n-\n-#include \"jni.h\"\n-#include \"assert.h\"\n-\n-static jclass class_IllegalCallerException;\n-\n-int checkAndClearIllegalCallerExceptionThrown(JNIEnv *env) {\n-    jthrowable t = (*env)->ExceptionOccurred(env);\n-    if ((*env)->IsInstanceOf(env, t, class_IllegalCallerException) == JNI_TRUE) {\n-        (*env)->ExceptionClear(env);\n-        return JNI_TRUE;\n-    }\n-    return JNI_FALSE;\n-}\n-\n-int main(int argc, char** args) {\n-    JavaVM *jvm;\n-    JNIEnv *env;\n-    JavaVMInitArgs vm_args;\n-    JavaVMOption options[1];\n-    jint rc;\n-\n-\n-    vm_args.version = JNI_VERSION_1_2;\n-    vm_args.nOptions = 0;\n-    vm_args.options = options;\n-\n-    if ((rc = JNI_CreateJavaVM(&jvm, (void**)&env, &vm_args)) != JNI_OK) {\n-        printf(\"ERROR: cannot create VM.\\n\");\n-        exit(-1);\n-    }\n-    class_IllegalCallerException = (*env)->FindClass(env, \"java\/lang\/IllegalCallerException\");\n-    assert (class_IllegalCallerException != NULL);\n-\n-    \/\/ call ClassLoader.registerAsParallelCapable()\n-    jclass class_ClassLoader = (*env)->FindClass(env, \"java\/lang\/ClassLoader\");\n-    assert(class_ClassLoader != NULL);\n-    jmethodID mid_ClassLoader_registerAsParallelCapable = (*env)->GetStaticMethodID(env, class_ClassLoader, \"registerAsParallelCapable\", \"()Z\" );\n-    assert(mid_ClassLoader_registerAsParallelCapable != NULL);\n-    jboolean b = (*env)->CallStaticBooleanMethod(env, class_ClassLoader, mid_ClassLoader_registerAsParallelCapable );\n-    if ((rc = checkAndClearIllegalCallerExceptionThrown(env)) != JNI_TRUE) {\n-        printf(\"ERROR: Didn't get the expected IllegalCallerException.\\n\");\n-        exit(-1);\n-    }\n-\n-    printf(\"Expected IllegalCallerException was thrown\\n\");\n-\n-    (*jvm)->DestroyJavaVM(jvm);\n-    return 0;\n-}\n-\n","filename":"test\/jdk\/java\/lang\/ClassLoader\/exeNullCallerClassLoaderTest\/exeNullCallerClassLoaderTest.c","additions":0,"deletions":76,"binary":false,"changes":76,"status":"deleted"},{"patch":"@@ -1,69 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-\/**\n- * @test\n- * @bug 8281003\n- * @summary Test uses custom launcher that starts VM using JNI that verifies\n- *          MethodHandles::lookup with null caller class throws an IllegalCallerException.\n- * @library \/test\/lib\n- * @requires os.family != \"aix\"\n- * @run main\/native NullCallerLookupTest\n- *\/\n-\n-\/\/ Test disabled on AIX since we cannot invoke the JVM on the primordial thread.\n-\n-import java.io.File;\n-import java.util.Map;\n-import jdk.test.lib.Platform;\n-import jdk.test.lib.process.OutputAnalyzer;\n-\n-import java.io.IOException;\n-import java.nio.file.Path;\n-\n-public class NullCallerLookupTest {\n-    public static void main(String[] args) throws IOException {\n-        Path launcher = Path.of(System.getProperty(\"test.nativepath\"), \"NullCallerLookupTest\");\n-        ProcessBuilder pb = new ProcessBuilder(launcher.toString());\n-        Map<String, String> env = pb.environment();\n-\n-        String libDir = Platform.libDir().toString();\n-        String vmDir = Platform.jvmLibDir().toString();\n-\n-        \/\/ set up shared library path\n-        String sharedLibraryPathEnvName = Platform.sharedLibraryPathVariableName();\n-        env.compute(sharedLibraryPathEnvName,\n-                    (k, v) -> (v == null) ? libDir : v + File.pathSeparator + libDir);\n-        env.compute(sharedLibraryPathEnvName,\n-                    (k, v) -> (v == null) ? vmDir : v + File.pathSeparator + vmDir);\n-\n-        System.out.println(\"Launching: \" + launcher + \" shared library path: \" +\n-                           env.get(sharedLibraryPathEnvName));\n-        new OutputAnalyzer(pb.start())\n-                .outputTo(System.out)\n-                .errorTo(System.err)\n-                .shouldHaveExitValue(0);\n-    }\n-}\n-\n","filename":"test\/jdk\/java\/lang\/invoke\/MethodHandles\/exeNullCallerLookup\/NullCallerLookupTest.java","additions":0,"deletions":69,"binary":false,"changes":69,"status":"deleted"},{"patch":"@@ -1,76 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include <stdio.h>\n-#include <stdlib.h>\n-\n-#include \"jni.h\"\n-#include \"assert.h\"\n-\n-static jclass class_IllegalCallerException;\n-\n-int checkAndClearIllegalCallerExceptionThrown(JNIEnv *env) {\n-    jthrowable t = (*env)->ExceptionOccurred(env);\n-    if ((*env)->IsInstanceOf(env, t, class_IllegalCallerException) == JNI_TRUE) {\n-        (*env)->ExceptionClear(env);\n-        return JNI_TRUE;\n-    }\n-    return JNI_FALSE;\n-}\n-\n-int main(int argc, char** args) {\n-    JavaVM *jvm;\n-    JNIEnv *env;\n-    JavaVMInitArgs vm_args;\n-    JavaVMOption options[1];\n-    jint rc;\n-\n-\n-    vm_args.version = JNI_VERSION_1_2;\n-    vm_args.nOptions = 0;\n-    vm_args.options = options;\n-\n-    if ((rc = JNI_CreateJavaVM(&jvm, (void**)&env, &vm_args)) != JNI_OK) {\n-        printf(\"ERROR: cannot create VM.\\n\");\n-        exit(-1);\n-    }\n-    class_IllegalCallerException = (*env)->FindClass(env, \"java\/lang\/IllegalCallerException\");\n-    assert (class_IllegalCallerException != NULL);\n-\n-    \/\/ call MethodHandles.lookup()\n-    jclass methodHandlesClass = (*env)->FindClass(env, \"java\/lang\/invoke\/MethodHandles\");\n-    assert(methodHandlesClass != NULL);\n-    jmethodID mid_MethodHandles_lookup = (*env)->GetStaticMethodID(env, methodHandlesClass, \"lookup\", \"()Ljava\/lang\/invoke\/MethodHandles$Lookup;\" );\n-    assert(mid_MethodHandles_lookup != NULL);\n-    jobject l = (*env)->CallStaticObjectMethod(env, methodHandlesClass, mid_MethodHandles_lookup );\n-    if ((rc = checkAndClearIllegalCallerExceptionThrown(env)) != JNI_TRUE) {\n-        printf(\"ERROR: Didn't get the expected IllegalCallerException.\\n\");\n-        exit(-1);\n-    }\n-\n-    printf(\"Expected IllegalCallerException was thrown\\n\");\n-\n-    (*jvm)->DestroyJavaVM(jvm);\n-    return 0;\n-}\n-\n","filename":"test\/jdk\/java\/lang\/invoke\/MethodHandles\/exeNullCallerLookup\/exeNullCallerLookupTest.c","additions":0,"deletions":76,"binary":false,"changes":76,"status":"deleted"},{"patch":"@@ -1,113 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-\/**\n- * @test\n- * @bug 8281006\n- * @summary Test uses custom launcher that starts VM using JNI that verifies\n- *          Module::getResourceAsStream and Class::getResourceAsStream with\n- *          a null caller class functions properly.\n- * @library \/test\/lib\n- * @modules java.base\/jdk.internal.module\n- *          jdk.compiler\n- * @build NullCallerGetResource\n- *        jdk.test.lib.compiler.CompilerUtils\n- * @requires os.family != \"aix\"\n- * @run main\/native NullCallerGetResource\n- *\/\n-\n-\/\/ Test disabled on AIX since we cannot invoke the JVM on the primordial thread.\n-\n-import java.io.File;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.nio.file.Paths;\n-import jdk.test.lib.Platform;\n-import jdk.test.lib.process.OutputAnalyzer;\n-import jdk.test.lib.compiler.CompilerUtils;\n-\n-public class NullCallerGetResource {\n-\n-    private static final String TEST_SRC = System.getProperty(\"test.src\");\n-\n-    \/\/ the module name of the test module\n-    private static final String TEST_MODULE = \"n\";\n-\n-    private static final Path SRC_DIR    = Paths.get(TEST_SRC, \"src\");\n-    private static final Path MODS_DIR   = Paths.get(\"mods\");\n-    private static final Path TEST_MOD_DIR = MODS_DIR.resolve(TEST_MODULE);\n-\n-    \/*\n-     * Build the test module called 'n' which opens the package 'open'\n-     * to everyone.  There is also a package 'closed' which is neither\n-     * opened or exported.\n-     *\/\n-    static void compileTestModule() throws Exception {\n-        \/\/ javac -d mods\/$TESTMODULE src\/$TESTMODULE\/**\n-        boolean compiled\n-                = CompilerUtils.compile(SRC_DIR.resolve(TEST_MODULE), TEST_MOD_DIR);\n-        assert (compiled);\n-        var open = TEST_MOD_DIR.resolve(\"open\/test.txt\");\n-        try (var out = Files.newBufferedWriter(open)) {\n-            out.write(\"open\");\n-            out.flush();\n-        }\n-        var closed = TEST_MOD_DIR.resolve(\"closed\/test.txt\");\n-        try (var out = Files.newBufferedWriter(closed)) {\n-            out.write(\"closed\");\n-            out.flush();\n-        }\n-    }\n-\n-    public static void main(String[] args) throws Exception {\n-\n-        \/\/ build the module used for the test\n-        compileTestModule();\n-\n-        var launcher = Path.of(System.getProperty(\"test.nativepath\"), \"NullCallerGetResource\");\n-        var pb = new ProcessBuilder(launcher.toString());\n-        var env = pb.environment();\n-\n-        var libDir = Platform.libDir().toString();\n-        var vmDir = Platform.jvmLibDir().toString();\n-\n-        \/\/ set up shared library path\n-        var sharedLibraryPathEnvName = Platform.sharedLibraryPathVariableName();\n-        env.compute(sharedLibraryPathEnvName,\n-                (k, v) -> (v == null) ? libDir : v + File.pathSeparator + libDir);\n-        env.compute(sharedLibraryPathEnvName,\n-                (k, v) -> (v == null) ? vmDir : v + File.pathSeparator + vmDir);\n-\n-        \/\/ launch the actual test\n-        System.out.println(\"Launching: \" + launcher + \" shared library path: \" +\n-                env.get(sharedLibraryPathEnvName));\n-        new OutputAnalyzer(pb.start())\n-                .outputTo(System.out)\n-                .errorTo(System.err)\n-                .shouldHaveExitValue(0);\n-\n-    }\n-\n-}\n-\n","filename":"test\/jdk\/java\/lang\/module\/exeNullCallerGetResource\/NullCallerGetResource.java","additions":0,"deletions":113,"binary":false,"changes":113,"status":"deleted"},{"patch":"@@ -1,184 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include <stdio.h>\n-#include <stdlib.h>\n-\n-#include \"jni.h\"\n-#undef NDEBUG\n-#include \"assert.h\"\n-#include \"string.h\"\n-\n-static jclass class_InputStream = NULL;\n-static jmethodID mid_InputStream_close = NULL;\n-\n-\/\/ in.close();\n-void closeInputStream(JNIEnv *env, jobject in) {\n-    (*env)->CallObjectMethod(env, in, mid_InputStream_close);\n-    if ((*env)->ExceptionOccurred(env) != NULL) {\n-        printf(\"ERROR: Exception was thrown calling InputStream::close.\\n\");\n-        (*env)->ExceptionDescribe(env);\n-        exit(-1);\n-    }\n-}\n-\n-\/*\n- * The java test running this native test creates a test module named 'n'\n- * which opens the package 'open'.  It has a text file resource named\n- * 'test.txt' in the open package.  It also has a class called\n- * open.OpenResources.  One should be able to get the resource through\n- * either the Class or the Module with getResourceAsStream.\n- *\n- * Class c = open.OpenResources.fetchClass();\n- * InputStream in1 = c.getResourceAsStream(\"test.txt\");\n- * Module n = c.getModule();\n- * InputStream in2 = n.getResourceAsStream(\"open\/test.txt\");\n- *\n- * The test also checks that closed resources are not available and\n- * don't throw any exceptions.  The test module contains a class\n- * called closed.ClosedResources and a file 'test.txt' in the package\n- * 'closed'.\n- *\n- * Class closed = closed.ClosedResources.fetchClass();\n- * assert(closed.getResourceAsStream(\"test.txt\") == null);\n- * assert(n.getResourceAsStream(\"closed\/test.txt\") == null);\n- *\n- *\/\n-int main(int argc, char** args) {\n-    JavaVM *jvm;\n-    JNIEnv *env;\n-    JavaVMInitArgs vm_args;\n-    JavaVMOption options[4];\n-    jint rc;\n-\n-    options[0].optionString = \"--module-path=mods\";\n-    options[1].optionString = \"--add-modules=n\";\n-\n-    vm_args.version = JNI_VERSION_9;\n-    vm_args.nOptions = 2;\n-    vm_args.options = options;\n-\n-    if ((rc = JNI_CreateJavaVM(&jvm, (void**)&env, &vm_args)) != JNI_OK) {\n-        printf(\"ERROR: cannot create VM.\\n\");\n-        exit(-1);\n-    }\n-\n-    \/\/ initialize for stream close\n-    class_InputStream = (*env)->FindClass(env, \"java\/io\/InputStream\");\n-    assert(class_InputStream != NULL);\n-    mid_InputStream_close = (*env)->GetMethodID(env, class_InputStream, \"close\", \"()V\" );\n-    assert(mid_InputStream_close != NULL);\n-\n-    \/\/ the open and closed classes\n-    jclass class_OpenResources = (*env)->FindClass(env, \"open\/OpenResources\");\n-    assert(class_OpenResources != NULL);\n-    jclass class_ClosedResources = (*env)->FindClass(env, \"closed\/ClosedResources\");\n-    assert(class_ClosedResources != NULL);\n-\n-    \/\/ Fetch the Module from one of the classes in the module\n-    jclass class_Class = (*env)->FindClass(env, \"java\/lang\/Class\");\n-    assert(class_Class != NULL);\n-    jmethodID mid_Class_getModule = (*env)->GetMethodID(env, class_Class, \"getModule\", \"()Ljava\/lang\/Module;\" );\n-    assert(mid_Class_getModule != NULL);\n-    jobject n =(*env)->CallObjectMethod(env, class_OpenResources, mid_Class_getModule);\n-    if ((*env)->ExceptionOccurred(env) != NULL) {\n-        printf(\"ERROR: Exception was thrown calling Class::getModule.\\n\");\n-        (*env)->ExceptionDescribe(env);\n-        exit(-1);\n-    }\n-    assert(n != NULL);\n-\n-    \/\/ Attempt to fetch an open resource from the module.  It should return a valid stream.\n-    \/\/ InputStream in = n.getResourceAsStream(\"open\/test.txt\");\n-    jclass class_Module = (*env)->FindClass(env, \"java\/lang\/Module\");\n-    assert(class_Module != NULL);\n-    jmethodID mid_Module_getResourceAsStream =\n-        (*env)->GetMethodID(env, class_Module, \"getResourceAsStream\", \"(Ljava\/lang\/String;)Ljava\/io\/InputStream;\" );\n-    assert(mid_Module_getResourceAsStream != NULL);\n-    jobject in = (*env)->CallObjectMethod(env, n, mid_Module_getResourceAsStream,\n-        (*env)->NewStringUTF(env, \"open\/test.txt\"));\n-    if ((*env)->ExceptionOccurred(env) != NULL) {\n-        printf(\"ERROR: Exception was thrown calling Module::getResourceAsStream on 'open\/test.txt'.\\n\");\n-        (*env)->ExceptionDescribe(env);\n-        exit(-1);\n-    }\n-    if (in == NULL) {\n-        printf(\"ERROR: Module::getResourceAsStream, expected valid stream for open resource\\n\");\n-        exit(-1);\n-    }\n-\n-    \/\/ in.close();\n-    closeInputStream(env, in);\n-\n-    \/\/ Attempt to fetch closed resource from the module.  It should return null.\n-    \/\/ in = n.getResourceAsStream(\"closed\/test.txt\");\n-    in =  (*env)->CallObjectMethod(env, n, mid_Module_getResourceAsStream,\n-        (*env)->NewStringUTF(env, \"closed\/test.txt\"));\n-    if ((*env)->ExceptionOccurred(env) != NULL) {\n-        printf(\"ERROR: Exception was thrown calling Module::getResourceAsStream on 'closed\/test.txt'.\\n\");\n-        (*env)->ExceptionDescribe(env);\n-        exit(-1);\n-    }\n-    if (in != NULL) {\n-        printf(\"ERROR: Module::getResourceAsStream, expected null value for closed resource\\n\");\n-        exit(-1);\n-    }\n-\n-    \/\/ Attempt to fetch open resource from the class.  It should return a valid stream.\n-    \/\/ in = open.OpenReosurces.class.getResourceAsStream(\"test.txt\");\n-    jmethodID mid_Class_getResourceAsStream =\n-        (*env)->GetMethodID(env, class_Class, \"getResourceAsStream\", \"(Ljava\/lang\/String;)Ljava\/io\/InputStream;\" );\n-    assert(mid_Class_getResourceAsStream != NULL);\n-    in =  (*env)->CallObjectMethod(env, class_OpenResources, mid_Class_getResourceAsStream,\n-        (*env)->NewStringUTF(env, \"test.txt\"));\n-    if ((*env)->ExceptionOccurred(env) != NULL) {\n-        printf(\"ERROR: Exception was thrown calling Class::getResourceAsStream on 'test.txt'.\\n\");\n-        (*env)->ExceptionDescribe(env);\n-        exit(-1);\n-    }\n-    if (in == NULL) {\n-        printf(\"ERROR: Class::getResourceAsStream, expected valid stream for open resource\\n\");\n-        exit(-1);\n-    }\n-\n-    \/\/ in.close();\n-    closeInputStream(env, in);\n-\n-    \/\/ Attempt to fetch closed resource from the class.  It should return null.\n-    \/\/ in = closed.ClosedResources.class.getResourceAsStream(\"test.txt\");\n-    in =  (*env)->CallObjectMethod(env, class_ClosedResources, mid_Class_getResourceAsStream,\n-        (*env)->NewStringUTF(env, \"test.txt\"));\n-    if ((*env)->ExceptionOccurred(env) != NULL) {\n-        printf(\"ERROR: Exception was thrown calling Class::getResourceAsStream on closed 'test.txt'.\\n\");\n-        (*env)->ExceptionDescribe(env);\n-        exit(-1);\n-    }\n-    if (in != NULL) {\n-        printf(\"ERROR: Class::getResourceAsStream, expected null value for closed resource\\n\");\n-        exit(-1);\n-    }\n-\n-    (*jvm)->DestroyJavaVM(jvm);\n-    return 0;\n-}\n-\n","filename":"test\/jdk\/java\/lang\/module\/exeNullCallerGetResource\/exeNullCallerGetResource.c","additions":0,"deletions":184,"binary":false,"changes":184,"status":"deleted"},{"patch":"@@ -1,83 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-\/**\n- * @test\n- * @bug 8280902\n- * @summary Test uses custom launcher that starts VM using JNI that verifies\n- *          ResourceBundle::getBundle with null caller class functions properly\n- *          using the system class loader unnamed module.  The custom launcher\n- *          creates a properties file and passes the VM option to the JNI\n- *          functionality for the resource lookup.\n- * @library \/test\/lib\n- * @requires os.family != \"aix\"\n- * @run main\/native NullCallerResourceBundle\n- *\/\n-\n-\/\/ Test disabled on AIX since we cannot invoke the JVM on the primordial thread.\n-\n-import java.io.File;\n-import java.io.IOException;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.util.Properties;\n-import jdk.test.lib.Platform;\n-import jdk.test.lib.process.OutputAnalyzer;\n-\n-public class NullCallerResourceBundle {\n-    public static void main(String[] args) throws IOException {\n-\n-        \/\/ build a properties file for the native test\n-        var propPath = Path.of(System.getProperty(\"test.classes\"), \"NullCallerResource.properties\");\n-        try (var stream = Files.newOutputStream(propPath)) {\n-            var props = new Properties();\n-            props.put(\"message\", \"Hello!\");\n-            props.save(stream, \"Test property list\");\n-        }\n-\n-        var launcher = Path.of(System.getProperty(\"test.nativepath\"), \"NullCallerResourceBundle\");\n-        var classpathAppend = \"-Djava.class.path=\" + System.getProperty(\"test.classes\");\n-        var pb = new ProcessBuilder(launcher.toString(), classpathAppend);\n-        var env = pb.environment();\n-\n-        var libDir = Platform.libDir().toString();\n-        var vmDir = Platform.jvmLibDir().toString();\n-\n-        \/\/ set up shared library path\n-        var sharedLibraryPathEnvName = Platform.sharedLibraryPathVariableName();\n-        env.compute(sharedLibraryPathEnvName,\n-                (k, v) -> (v == null) ? libDir : v + File.pathSeparator + libDir);\n-        env.compute(sharedLibraryPathEnvName,\n-                (k, v) -> (v == null) ? vmDir : v + File.pathSeparator + vmDir);\n-\n-        System.out.println(\"Launching: \" + launcher + \" shared library path: \" +\n-                env.get(sharedLibraryPathEnvName));\n-        new OutputAnalyzer(pb.start())\n-                .outputTo(System.out)\n-                .errorTo(System.err)\n-                .shouldHaveExitValue(0);\n-    }\n-\n-}\n-\n","filename":"test\/jdk\/java\/util\/ResourceBundle\/exeNullCallerResourceBundle\/NullCallerResourceBundle.java","additions":0,"deletions":83,"binary":false,"changes":83,"status":"deleted"},{"patch":"@@ -1,102 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include <stdio.h>\n-#include <stdlib.h>\n-\n-#include \"jni.h\"\n-#undef NDEBUG\n-#include \"assert.h\"\n-#include \"string.h\"\n-\n-\n-\/*\n- * The java test running this native test passes in an argument to provide as\n- * an option for the configuration of the JVM.  The system classpath has the\n- * classpath of the java test appended so it can pick up the resource that\n- * was created by the java part of the test.\n- *\/\n-int main(int argc, char** args) {\n-    JavaVM *jvm;\n-    JNIEnv *env;\n-    JavaVMInitArgs vm_args;\n-    JavaVMOption options[1];\n-    jint rc;\n-\n-    assert(argc == 2);\n-    options[0].optionString = args[1];\n-\n-    vm_args.version = JNI_VERSION_1_2;\n-    vm_args.nOptions = 1;\n-    vm_args.options = options;\n-\n-    if ((rc = JNI_CreateJavaVM(&jvm, (void**)&env, &vm_args)) != JNI_OK) {\n-        printf(\"ERROR: cannot create VM.\\n\");\n-        exit(-1);\n-    }\n-\n-    \/\/ b = ResourceBundle.getBundle(\"NullCallerResource\");\n-    jclass class_ResourceBundle = (*env)->FindClass(env, \"java\/util\/ResourceBundle\");\n-    assert(class_ResourceBundle != NULL);\n-    jmethodID mid_ResourceBundle_getBundle = (*env)->GetStaticMethodID(env, class_ResourceBundle, \"getBundle\", \"(Ljava\/lang\/String;)Ljava\/util\/ResourceBundle;\" );\n-    assert(mid_ResourceBundle_getBundle != NULL);\n-    jobject resourceName = (*env)->NewStringUTF(env, \"NullCallerResource\");\n-    assert(resourceName != NULL);\n-    jobject b = (*env)->CallStaticObjectMethod(env, class_ResourceBundle, mid_ResourceBundle_getBundle, resourceName);\n-    if ((*env)->ExceptionOccurred(env) != NULL) {\n-        printf(\"ERROR: Exception was thrown calling ResourceBundle::getBundle.\\n\");\n-        (*env)->ExceptionDescribe(env);\n-        exit(-1);\n-    }\n-\n-    \/\/ msg = b.getString(\"message\");\n-    jmethodID mid_ResourceBundle_getString = (*env)->GetMethodID(env, class_ResourceBundle, \"getString\", \"(Ljava\/lang\/String;)Ljava\/lang\/String;\" );\n-    assert(mid_ResourceBundle_getString != NULL);\n-    jobject key = (*env)->NewStringUTF(env, \"message\");\n-    jobject msg =(*env)->CallObjectMethod(env, b, mid_ResourceBundle_getString, key);\n-    if ((*env)->ExceptionOccurred(env) != NULL) {\n-        printf(\"ERROR: Exception was thrown calling ResourceBundle::getString.\\n\");\n-        (*env)->ExceptionDescribe(env);\n-        exit(-1);\n-    }\n-    assert(msg != NULL);\n-\n-    \/\/ check the message\n-    const char* cstr = (*env)->GetStringUTFChars(env, msg, NULL);\n-    assert(cstr != NULL);\n-    assert(strcmp(cstr,\"Hello!\") == 0);\n-\n-    \/\/ ResourceBundle.clearCache()\n-    jmethodID mid_ResourceBundle_clearCache = (*env)->GetStaticMethodID(env, class_ResourceBundle, \"clearCache\", \"()V\" );\n-    assert(mid_ResourceBundle_clearCache != NULL);\n-    (*env)->CallStaticVoidMethod(env, class_ResourceBundle, mid_ResourceBundle_clearCache);\n-    if ((*env)->ExceptionOccurred(env) != NULL) {\n-        printf(\"ERROR: Exception was thrown calling ResourceBundle::clearCache.\\n\");\n-        (*env)->ExceptionDescribe(env);\n-        exit(-1);\n-    }\n-\n-    (*jvm)->DestroyJavaVM(jvm);\n-    return 0;\n-}\n-\n","filename":"test\/jdk\/java\/util\/ResourceBundle\/exeNullCallerResourceBundle\/exeNullCallerResourceBundle.c","additions":0,"deletions":102,"binary":false,"changes":102,"status":"deleted"},{"patch":"@@ -0,0 +1,210 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+#ifndef __CallHelper_hpp__\n+#define __CallHelper_hpp__\n+\n+#include <stdlib.h>\n+#include <stdio.h>\n+#include <jni.h>\n+#undef NDEBUG\n+#include <assert.h>\n+#include <string>\n+#include <algorithm>\n+\n+\/*\n+ * basis of classes to provide a bunch of checking in native calls to java\n+ *\/\n+class CallHelper {\n+public:\n+    CallHelper(JNIEnv* e, const std::string& cname, const std::string& mname, const std::string& sig) :\n+        classname(cname), method(mname), signature(sig), m(NULL), env(e) {\n+        c = env->FindClass(classname.c_str());\n+        assert (c != NULL);\n+    }\n+\n+protected:\n+\n+    \/\/ emit a message with the call made appended to the message\n+    void emitErrorMessage(const std::string& msg) {\n+        std::string nm = classname;\n+        std::replace(nm.begin(), nm.end(), '\/', '.');\n+        ::printf(\"ERROR: %s::%s, %s\\n\", nm.c_str(), method.c_str(), msg.c_str());\n+    }\n+\n+    \/\/ check the given object which is expected to be null\n+    void checkReturnNull(jobject obj) {\n+        if (obj != NULL) {\n+            emitErrorMessage(\"Null return expected\");\n+            ::exit(-1);\n+        }\n+    }\n+\n+    \/\/ check the given object which is expected to NOT be null\n+    void checkReturnNotNull(jobject obj) {\n+        if (obj == NULL) {\n+            emitErrorMessage(\"Non-Null return expected\");\n+            ::exit(-1);\n+        }\n+    }\n+\n+    \/\/ check if any unexpected exceptions were thrown\n+    void checkException() {\n+        if (env->ExceptionOccurred() != NULL) {\n+            emitErrorMessage(\"Exception was thrown\");\n+            env->ExceptionDescribe();\n+            ::exit(-1);\n+        }\n+    }\n+\n+    \/\/ check if an expected exception was thrown\n+    void checkExpectedExceptionThrown(const std::string& exception) {\n+         jclass expected = env->FindClass(exception.c_str());\n+         assert(expected != NULL);\n+         jthrowable t = env->ExceptionOccurred();\n+         if (env->IsInstanceOf(t, expected) == JNI_FALSE) {\n+            emitErrorMessage(\"Didn't get the expected \" + exception);\n+            ::exit(-1);\n+         }\n+         env->ExceptionClear();\n+    }\n+\n+protected:\n+    std::string classname;\n+    std::string method;\n+    std::string signature;\n+    jclass c;\n+    jmethodID m;\n+    JNIEnv* env;\n+};\n+\n+\/*\n+ * support for making checked calls on instances of an object\n+ *\/\n+class InstanceCall : public CallHelper {\n+public:\n+    InstanceCall(JNIEnv* e, const std::string& cname, const std::string& mname, const std::string& sig)\n+        : CallHelper(e, cname, mname, sig) {\n+\n+        m = env->GetMethodID(c, method.c_str(), signature.c_str());\n+        assert(m != NULL);\n+    }\n+\n+    \/\/ call on the given object, checking for exceptions and that the return is not null\n+    jobject callReturnNotNull(jobject obj) {\n+        jobject robj = call(obj);\n+        checkReturnNotNull(robj);\n+        return robj;\n+    }\n+\n+    \/\/ call on the given object with an argument,\n+    \/\/ checking for exceptions and that the return is not null\n+    jobject callReturnNotNull(jobject obj, jobject arg) {\n+        jobject robj = call(obj, arg);\n+        checkReturnNotNull(robj);\n+        return robj;\n+    }\n+\n+    \/\/ call on the given object, checking for exceptions and that the return is null\n+    jobject callReturnIsNull(jobject obj) {\n+        jobject robj = call(obj);\n+        checkReturnNull(robj);\n+        return robj;\n+    }\n+\n+    \/\/ call on the given object with an argument,\n+    \/\/ checking for exceptions and that the return is null\n+    jobject callReturnIsNull(jobject obj, jobject arg) {\n+        jobject robj = call(obj, arg);\n+        checkReturnNull(robj);\n+        return robj;\n+    }\n+\n+    \/\/ call a void method checking if exceptions were thrown\n+    void callVoidMethod(jobject obj) {\n+        env->CallVoidMethod(obj, m);\n+        checkException();\n+    }\n+\n+    jobject call(jobject obj) {\n+        jobject robj = env->CallObjectMethod(obj, m);\n+        checkException();\n+        return robj;\n+    }\n+\n+    jobject call(jobject obj, jobject arg) {\n+        jobject robj = env->CallObjectMethod(obj, m, arg);\n+        checkException();\n+        return robj;\n+    }\n+\n+};\n+\n+\/*\n+ * support for making checked static calls\n+ *\/\n+class StaticCall : public CallHelper {\n+public:\n+    StaticCall(JNIEnv* e, const std::string& cname, const std::string& mname, const std::string& sig)\n+        : CallHelper(e, cname, mname, sig) {\n+\n+        m = env->GetStaticMethodID(c, method.c_str(), signature.c_str());\n+        assert(m != NULL);\n+    }\n+\n+    \/\/ call a method returning an object checking for exceptions and\n+    \/\/ the the return value is not null.\n+    jobject callReturnNotNull(jobject arg) {\n+        jobject robj = env->CallStaticObjectMethod(c, m, arg);\n+        checkException();\n+        checkReturnNotNull(robj);\n+        return robj;\n+    }\n+\n+    \/\/ call a void method checking if any exceptions thrown\n+    void callVoidMethod() {\n+        env->CallStaticVoidMethod(c, m);\n+        checkException();\n+    }\n+\n+    \/\/ call method returning boolean that is expected to throw the\n+    \/\/ given exception\n+    void callBooleanMethodWithException(const std::string& exception) {\n+        env->CallStaticBooleanMethod(c, m);\n+        checkExpectedExceptionThrown(exception);\n+    }\n+\n+    \/\/ call method returning an object that is expected to throw the\n+    \/\/ given exception\n+    void callObjectMethodWithException(const std::string& exception) {\n+        env->CallStaticObjectMethod(c, m);\n+        checkExpectedExceptionThrown(exception);\n+    }\n+};\n+\n+void emitErrorMessageAndExit(const std::string& msg) {\n+    ::printf(\"ERROR: %s\\n\", msg.c_str());\n+    ::exit(-1);\n+}\n+\n+#endif \/\/ __CallHelper_hpp__\n+\n","filename":"test\/jdk\/jni\/nullCaller\/CallHelper.hpp","additions":210,"deletions":0,"binary":false,"changes":210,"status":"added"},{"patch":"@@ -0,0 +1,116 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8280902 8281000 8281003 8281006\n+ * @summary Test uses custom launcher that starts VM using JNI that verifies\n+ *          various API called with a null caller class function properly.\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.module\n+ *          jdk.compiler\n+ * @build NullCallerTest\n+ *        jdk.test.lib.compiler.CompilerUtils\n+ * @requires os.family != \"aix\"\n+ * @run main\/native NullCallerTest\n+ *\/\n+\n+\/\/ Test disabled on AIX since we cannot invoke the JVM on the primordial thread.\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.List;\n+import java.util.Properties;\n+\n+import jdk.test.lib.Platform;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.compiler.CompilerUtils;\n+\n+public class NullCallerTest {\n+\n+    private static final String TEST_SRC = System.getProperty(\"test.src\");\n+\n+    \/\/ the module name of the test module\n+    private static final String TEST_MODULE = \"n\";\n+\n+    private static final Path SRC_DIR    = Paths.get(TEST_SRC, \"src\");\n+    private static final Path MODS_DIR   = Paths.get(\"mods\");\n+    private static final Path TEST_MOD_DIR = MODS_DIR.resolve(TEST_MODULE);\n+    private static final Path TEST_MOD_SRC_DIR = SRC_DIR.resolve(TEST_MODULE);\n+\n+    \/*\n+     * Build the test module called 'n' which opens the package 'open'\n+     * to everyone.  There is also a package 'closed' which is neither\n+     * opened or exported.\n+     *\/\n+    static void compileTestModule() throws Exception {\n+        \/\/ javac -d mods\/$TESTMODULE src\/$TESTMODULE\/**\n+        boolean compiled = CompilerUtils.compile(SRC_DIR.resolve(TEST_MODULE), TEST_MOD_DIR);\n+        assert (compiled);\n+\n+        \/\/ copy resources\n+        var resources = List.of(\"open\/test.txt\", \"closed\/test.txt\", \"open\/NullCallerResource.properties\");\n+        resources.stream().forEach(r -> {\n+            try {\n+                Files.copy(TEST_MOD_SRC_DIR.resolve(r), TEST_MOD_DIR.resolve(r));\n+            } catch (IOException e) {\n+                throw new RuntimeException(\"Failed to copy resource: \" + r, e);\n+            }\n+        });\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        \/\/ build the module used for the test\n+        compileTestModule();\n+\n+        var launcher = Path.of(System.getProperty(\"test.nativepath\"), \"NullCallerTest\");\n+        var pb = new ProcessBuilder(launcher.toString());\n+        var env = pb.environment();\n+\n+        var libDir = Platform.libDir().toString();\n+        var vmDir = Platform.jvmLibDir().toString();\n+\n+        \/\/ set up shared library path\n+        var sharedLibraryPathEnvName = Platform.sharedLibraryPathVariableName();\n+        env.compute(sharedLibraryPathEnvName,\n+                (k, v) -> (v == null) ? libDir : v + File.pathSeparator + libDir);\n+        env.compute(sharedLibraryPathEnvName,\n+                (k, v) -> (v == null) ? vmDir : v + File.pathSeparator + vmDir);\n+\n+        \/\/ launch the actual test\n+        System.out.println(\"Launching: \" + launcher + \" shared library path: \" +\n+                env.get(sharedLibraryPathEnvName));\n+        new OutputAnalyzer(pb.start())\n+                .outputTo(System.out)\n+                .errorTo(System.err)\n+                .shouldHaveExitValue(0);\n+\n+    }\n+\n+}\n+\n","filename":"test\/jdk\/jni\/nullCaller\/NullCallerTest.java","additions":116,"deletions":0,"binary":false,"changes":116,"status":"added"},{"patch":"@@ -0,0 +1,178 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"CallHelper.hpp\"\n+\n+\/*\n+ * Test for JDK-8280902\n+ *\/\n+void getBundle(JNIEnv* env) {\n+    StaticCall m_ResourceBundle_getBundle { env,\n+        \"java\/util\/ResourceBundle\", \"getBundle\",\n+        \"(Ljava\/lang\/String;)Ljava\/util\/ResourceBundle;\" };\n+    InstanceCall m_ResourceBundle_getString { env,\n+        \"java\/util\/ResourceBundle\", \"getString\",\n+        \"(Ljava\/lang\/String;)Ljava\/lang\/String;\" };\n+    StaticCall m_ResourceBundle_clearCache { env,\n+        \"java\/util\/ResourceBundle\", \"clearCache\", \"()V\"\n+    };\n+\n+    \/\/ The following should not throw\n+    \/\/ b = ResourceBundle.getBundle(\"NullCallerResource\");\n+    jobject b = m_ResourceBundle_getBundle.callReturnNotNull(\n+        env->NewStringUTF(\"open\/NullCallerResource\"));\n+\n+    \/\/ msg = b.getString(\"message\");\n+    jstring msg = (jstring) m_ResourceBundle_getString.callReturnNotNull(b, env->NewStringUTF(\"message\"));\n+\n+    \/\/ check the message\n+    if (std::string(\"Hello!\") != env->GetStringUTFChars(msg, NULL)) {\n+        emitErrorMessageAndExit(\"Bundle didn't contain expected content\");\n+    }\n+\n+    \/\/ The following should not throw\n+    \/\/ ResourceBundle.clearCache()\n+    m_ResourceBundle_clearCache.callVoidMethod();\n+}\n+\n+\/*\n+ * Test for JDK-8281000\n+ *\/\n+void registerAsParallelCapable(JNIEnv* env) {\n+    StaticCall m_ClassLoader_registerAsParallelCapable { env,\n+        \"java\/lang\/ClassLoader\", \"registerAsParallelCapable\", \"()Z\" };\n+\n+    \/\/ The call should throw ICE\n+    m_ClassLoader_registerAsParallelCapable.\n+        callBooleanMethodWithException(\"java\/lang\/IllegalCallerException\");\n+}\n+\n+\/*\n+ * Test for JDK-8281001\n+ *\n+ * Try and load a class using Class::forName in the module n which should be\n+ * found with the system classloader (to match FindClass() used above).\n+ * Class exp = Class.forName(\"open.OpenResources\");\n+ *\/\n+void forName(JNIEnv* env) {\n+\/* coming soon\n+    StaticCall m_Class_forName { env,\n+        \"java\/lang\/Class\", \"forName\", \"(Ljava\/lang\/String;)Ljava\/lang\/Class;\" };\n+\n+    m_Class_forName.callReturnNotNull(env->NewStringUTF(\"open.OpenResources\"));\n+*\/\n+}\n+\n+\/*\n+ * Test for JDK-8281003\n+ *\/\n+void lookup(JNIEnv* env) {\n+    StaticCall m_MethodHandles_lookup { env,\n+        \"java\/lang\/invoke\/MethodHandles\", \"lookup\", \"()Ljava\/lang\/invoke\/MethodHandles$Lookup;\" };\n+\n+    \/\/ The call should throw ICE\n+    m_MethodHandles_lookup.\n+        callObjectMethodWithException(\"java\/lang\/IllegalCallerException\");\n+}\n+\n+\/*\n+ * This function tests changes made for JDK-8281006\n+ * Module::getResourceAsStream should check if the resource is open\n+ * unconditionally when caller is null\n+ *\n+ * The java test running this native test creates a test module named 'n'\n+ * which opens the package 'open'.  It has a text file resource named\n+ * 'test.txt' in the open package.  It also has a class called\n+ * open.OpenResources.  One should be able to get the resource through\n+ * either the Class or the Module with getResourceAsStream.\n+ *\/\n+void getResourceAsStream(JNIEnv *env) {\n+    InstanceCall m_InputStream_close { env,\n+        \"java\/io\/InputStream\", \"close\", \"()V\" };\n+    InstanceCall m_Class_getModule {env,\n+        \"java\/lang\/Class\", \"getModule\", \"()Ljava\/lang\/Module;\" };\n+    InstanceCall m_Module_getResourceAsStream { env,\n+        \"java\/lang\/Module\", \"getResourceAsStream\", \"(Ljava\/lang\/String;)Ljava\/io\/InputStream;\" };\n+    InstanceCall m_Class_getResourceAsStream { env,\n+        \"java\/lang\/Class\", \"getResourceAsStream\", \"(Ljava\/lang\/String;)Ljava\/io\/InputStream;\" };\n+\n+    \/\/ fetch the open and closed classes\n+    jclass class_OpenResources = env->FindClass(\"open\/OpenResources\");\n+    assert(class_OpenResources != NULL);\n+    jclass class_ClosedResources = env->FindClass(\"closed\/ClosedResources\");\n+    assert(class_ClosedResources != NULL);\n+\n+    \/\/ Fetch the Module from one of the classes in the module\n+    jobject n = m_Class_getModule.callReturnNotNull(class_OpenResources);\n+\n+    \/\/ Attempt to fetch an open resource from the module.  It should return a valid stream.\n+    \/\/ InputStream in1 = n.getResourceAsStream(\"open\/test.txt\");\n+    \/\/ in1.close();\n+    jobject in1 = m_Module_getResourceAsStream.callReturnNotNull(n, env->NewStringUTF(\"open\/test.txt\"));\n+    m_InputStream_close.callVoidMethod(in1);\n+\n+    \/\/ Attempt to fetch closed resource from the module.  It should return null.\n+    \/\/ InputStream in2 = n.getResourceAsStream(\"closed\/test.txt\");\n+    m_Module_getResourceAsStream.callReturnIsNull(n, env->NewStringUTF(\"closed\/test.txt\"));\n+\n+    \/\/ Attempt to fetch open resource from the class.  It should return a valid stream.\n+    \/\/ InputStream in3 = open.OpenReosurces.class.getResourceAsStream(\"test.txt\");\n+    \/\/ in3.close();\n+    jobject in3 = m_Class_getResourceAsStream.callReturnNotNull(\n+        class_OpenResources, env->NewStringUTF(\"test.txt\"));\n+    m_InputStream_close.callVoidMethod(in3);\n+\n+    \/\/ Attempt to fetch closed resource from the class.  It should return null.\n+    \/\/ InputStream in4 = closed.ClosedResources.class.getResourceAsStream(\"test.txt\");\n+    m_Class_getResourceAsStream.callReturnIsNull(\n+        class_ClosedResources, env->NewStringUTF(\"test.txt\"));\n+}\n+\n+int main(int argc, char** args) {\n+    JavaVM *jvm;\n+    JNIEnv *env;\n+    JavaVMInitArgs vm_args;\n+    JavaVMOption options[4];\n+    jint rc;\n+\n+    options[0].optionString = (char*) \"--module-path=mods\";\n+    options[1].optionString = (char*) \"--add-modules=n\";\n+\n+    vm_args.version = JNI_VERSION_9;\n+    vm_args.nOptions = 2;\n+    vm_args.options = options;\n+\n+    if ((rc = JNI_CreateJavaVM(&jvm, (void**)&env, &vm_args)) != JNI_OK) {\n+        emitErrorMessageAndExit(\"Cannot create VM.\");\n+    }\n+\n+    getBundle(env);\n+    registerAsParallelCapable(env);\n+    forName(env);\n+    lookup(env);\n+    getResourceAsStream(env);\n+\n+    jvm->DestroyJavaVM();\n+    return 0;\n+}\n+\n","filename":"test\/jdk\/jni\/nullCaller\/exeNullCallerTest.cpp","additions":178,"deletions":0,"binary":false,"changes":178,"status":"added"},{"patch":"","filename":"test\/jdk\/jni\/nullCaller\/src\/n\/closed\/ClosedResources.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/jdk\/java\/lang\/module\/exeNullCallerGetResource\/src\/n\/closed\/ClosedResources.java","status":"renamed"},{"patch":"@@ -0,0 +1,1 @@\n+closed\n","filename":"test\/jdk\/jni\/nullCaller\/src\/n\/closed\/test.txt","additions":1,"deletions":0,"binary":false,"changes":1,"status":"added"},{"patch":"","filename":"test\/jdk\/jni\/nullCaller\/src\/n\/module-info.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/jdk\/java\/lang\/module\/exeNullCallerGetResource\/src\/n\/module-info.java","status":"renamed"},{"patch":"@@ -0,0 +1,3 @@\n+#Test property list\n+#Fri May 27 15:30:57 CDT 2022\n+message=Hello\\!\n","filename":"test\/jdk\/jni\/nullCaller\/src\/n\/open\/NullCallerResource.properties","additions":3,"deletions":0,"binary":false,"changes":3,"status":"added"},{"patch":"","filename":"test\/jdk\/jni\/nullCaller\/src\/n\/open\/OpenResources.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/jdk\/java\/lang\/module\/exeNullCallerGetResource\/src\/n\/open\/OpenResources.java","status":"renamed"},{"patch":"@@ -0,0 +1,1 @@\n+open\n","filename":"test\/jdk\/jni\/nullCaller\/src\/n\/open\/test.txt","additions":1,"deletions":0,"binary":false,"changes":1,"status":"added"}]}