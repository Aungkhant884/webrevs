{"files":[{"patch":"@@ -539,1 +539,0 @@\n-                  _save_argument_registers(false),\n@@ -842,1 +841,0 @@\n-                  bool save_arg_registers,\n@@ -847,1 +845,0 @@\n-    _save_argument_registers(save_arg_registers),\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -248,1 +248,0 @@\n-  const bool            _save_argument_registers; \/\/ save\/restore arg regs for trampolines\n@@ -515,1 +514,0 @@\n-  bool              save_argument_registers() const { return _save_argument_registers; }\n@@ -1039,1 +1037,1 @@\n-          bool save_arg_registers, bool return_pc, DirectiveSet* directive);\n+          bool return_pc, DirectiveSet* directive);\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -726,1 +726,1 @@\n-bool Matcher::is_save_on_entry( int reg ) {\n+bool Matcher::is_save_on_entry(int reg) {\n@@ -729,3 +729,1 @@\n-    _register_save_policy[reg] == 'A' || \/\/ Save-on-entry register?\n-    \/\/ Also save argument registers in the trampolining stubs\n-    (C->save_argument_registers() && is_spillable_arg(reg));\n+    _register_save_policy[reg] == 'A'; \/\/ Save-on-entry register?\n@@ -747,6 +745,0 @@\n-  \/\/ Save argument registers in the trampolining stubs\n-  if( C->save_argument_registers() )\n-    for( i = 0; i < _last_Mach_Reg; i++ )\n-      if( is_spillable_arg(i) )\n-        soe_cnt++;\n-\n","filename":"src\/hotspot\/share\/opto\/matcher.cpp","additions":2,"deletions":10,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1269,15 +1269,0 @@\n-#if defined(IA64) && !defined(AIX)\n-  if (save_argument_registers()) {\n-    \/\/ 4815101: this is a stub with implicit and unknown precision fp args.\n-    \/\/ The usual spill mechanism can only generate stfd's in this case, which\n-    \/\/ doesn't work if the fp reg to spill contains a single-precision denorm.\n-    \/\/ Instead, we hack around the normal spill mechanism using stfspill's and\n-    \/\/ ldffill's in the MachProlog and MachEpilog emit methods.  We allocate\n-    \/\/ space here for the fp arg regs (f8-f15) we're going to thusly spill.\n-    \/\/\n-    \/\/ If we ever implement 16-byte 'registers' == stack slots, we can\n-    \/\/ get rid of this hack and have SpillCopy generate stfspill\/ldffill\n-    \/\/ instead of stfd\/stfs\/ldfd\/ldfs.\n-    _frame_slots += 8*(16\/BytesPerInt);\n-  }\n-#endif\n@@ -3359,2 +3344,1 @@\n-    install_stub(C->stub_name(),\n-                 C->save_argument_registers());\n+    install_stub(C->stub_name());\n@@ -3415,2 +3399,1 @@\n-void PhaseOutput::install_stub(const char* stub_name,\n-                               bool        caller_must_gc_arguments) {\n+void PhaseOutput::install_stub(const char* stub_name) {\n@@ -3435,1 +3418,1 @@\n-                                                      caller_must_gc_arguments);\n+                                                      false);\n","filename":"src\/hotspot\/share\/opto\/output.cpp","additions":3,"deletions":20,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -167,2 +167,1 @@\n-  void install_stub(const char* stub_name,\n-                    bool        caller_must_gc_arguments);\n+  void install_stub(const char* stub_name);\n","filename":"src\/hotspot\/share\/opto\/output.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -127,2 +127,2 @@\n-#define gen(env, var, type_func_gen, c_func, fancy_jump, pass_tls, save_arg_regs, return_pc) \\\n-  var = generate_stub(env, type_func_gen, CAST_FROM_FN_PTR(address, c_func), #var, fancy_jump, pass_tls, save_arg_regs, return_pc); \\\n+#define gen(env, var, type_func_gen, c_func, fancy_jump, pass_tls, return_pc) \\\n+  var = generate_stub(env, type_func_gen, CAST_FROM_FN_PTR(address, c_func), #var, fancy_jump, pass_tls, return_pc); \\\n@@ -137,1 +137,1 @@\n-  \/\/   variable\/name                       type-function-gen              , runtime method                  ,fncy_jp, tls,save_args,retpc\n+  \/\/   variable\/name                       type-function-gen              , runtime method                  ,fncy_jp, tls,retpc\n@@ -139,15 +139,15 @@\n-  gen(env, _new_instance_Java              , new_instance_Type            , new_instance_C                  ,    0 , true , false, false);\n-  gen(env, _new_array_Java                 , new_array_Type               , new_array_C                     ,    0 , true , false, false);\n-  gen(env, _new_array_nozero_Java          , new_array_Type               , new_array_nozero_C              ,    0 , true , false, false);\n-  gen(env, _multianewarray2_Java           , multianewarray2_Type         , multianewarray2_C               ,    0 , true , false, false);\n-  gen(env, _multianewarray3_Java           , multianewarray3_Type         , multianewarray3_C               ,    0 , true , false, false);\n-  gen(env, _multianewarray4_Java           , multianewarray4_Type         , multianewarray4_C               ,    0 , true , false, false);\n-  gen(env, _multianewarray5_Java           , multianewarray5_Type         , multianewarray5_C               ,    0 , true , false, false);\n-  gen(env, _multianewarrayN_Java           , multianewarrayN_Type         , multianewarrayN_C               ,    0 , true , false, false);\n-  gen(env, _complete_monitor_locking_Java  , complete_monitor_enter_Type  , SharedRuntime::complete_monitor_locking_C, 0, false, false, false);\n-  gen(env, _monitor_notify_Java            , monitor_notify_Type          , monitor_notify_C                ,    0 , false, false, false);\n-  gen(env, _monitor_notifyAll_Java         , monitor_notify_Type          , monitor_notifyAll_C             ,    0 , false, false, false);\n-  gen(env, _rethrow_Java                   , rethrow_Type                 , rethrow_C                       ,    2 , true , false, true );\n-\n-  gen(env, _slow_arraycopy_Java            , slow_arraycopy_Type          , SharedRuntime::slow_arraycopy_C ,    0 , false, false, false);\n-  gen(env, _register_finalizer_Java        , register_finalizer_Type      , register_finalizer              ,    0 , false, false, false);\n+  gen(env, _new_instance_Java              , new_instance_Type            , new_instance_C                  ,    0 , true, false);\n+  gen(env, _new_array_Java                 , new_array_Type               , new_array_C                     ,    0 , true, false);\n+  gen(env, _new_array_nozero_Java          , new_array_Type               , new_array_nozero_C              ,    0 , true, false);\n+  gen(env, _multianewarray2_Java           , multianewarray2_Type         , multianewarray2_C               ,    0 , true, false);\n+  gen(env, _multianewarray3_Java           , multianewarray3_Type         , multianewarray3_C               ,    0 , true, false);\n+  gen(env, _multianewarray4_Java           , multianewarray4_Type         , multianewarray4_C               ,    0 , true, false);\n+  gen(env, _multianewarray5_Java           , multianewarray5_Type         , multianewarray5_C               ,    0 , true, false);\n+  gen(env, _multianewarrayN_Java           , multianewarrayN_Type         , multianewarrayN_C               ,    0 , true, false);\n+  gen(env, _complete_monitor_locking_Java  , complete_monitor_enter_Type  , SharedRuntime::complete_monitor_locking_C, 0, false, false);\n+  gen(env, _monitor_notify_Java            , monitor_notify_Type          , monitor_notify_C                ,    0 , false, false);\n+  gen(env, _monitor_notifyAll_Java         , monitor_notify_Type          , monitor_notifyAll_C             ,    0 , false, false);\n+  gen(env, _rethrow_Java                   , rethrow_Type                 , rethrow_C                       ,    2 , true , true );\n+\n+  gen(env, _slow_arraycopy_Java            , slow_arraycopy_Type          , SharedRuntime::slow_arraycopy_C ,    0 , false, false);\n+  gen(env, _register_finalizer_Java        , register_finalizer_Type      , register_finalizer              ,    0 , false, false);\n@@ -162,6 +162,5 @@\n-address OptoRuntime::generate_stub( ciEnv* env,\n-                                    TypeFunc_generator gen, address C_function,\n-                                    const char *name, int is_fancy_jump,\n-                                    bool pass_tls,\n-                                    bool save_argument_registers,\n-                                    bool return_pc) {\n+address OptoRuntime::generate_stub(ciEnv* env,\n+                                   TypeFunc_generator gen, address C_function,\n+                                   const char *name, int is_fancy_jump,\n+                                   bool pass_tls,\n+                                   bool return_pc) {\n@@ -172,1 +171,1 @@\n-  Compile C( env, gen, C_function, name, is_fancy_jump, pass_tls, save_argument_registers, return_pc, directive);\n+  Compile C(env, gen, C_function, name, is_fancy_jump, pass_tls, return_pc, directive);\n","filename":"src\/hotspot\/share\/opto\/runtime.cpp","additions":24,"deletions":25,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -133,1 +133,1 @@\n-  static address generate_stub(ciEnv* ci_env, TypeFunc_generator gen, address C_function, const char *name, int is_fancy_jump, bool pass_tls, bool save_arguments, bool return_pc);\n+  static address generate_stub(ciEnv* ci_env, TypeFunc_generator gen, address C_function, const char* name, int is_fancy_jump, bool pass_tls, bool return_pc);\n","filename":"src\/hotspot\/share\/opto\/runtime.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -915,1 +915,0 @@\n-  c2_nonstatic_field(Compile,                  _save_argument_registers,                      const bool)                            \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"}]}