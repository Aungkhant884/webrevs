{"files":[{"patch":"@@ -198,5 +198,22 @@\n-    \/** tries once to CAS a new dummy node for head *\/\n-    private void tryInitializeHead() {\n-        Node h = new ExclusiveNode();\n-        if (U.compareAndSetReference(this, HEAD, null, h))\n-            tail = h;\n+    \/**\n+     * Tries to CAS a new dummy node for head.\n+     * Returns new tail, or null if OutOfMemory\n+     *\/\n+    private Node tryInitializeHead() {\n+        for (Node h = null, t;;) {\n+            if ((t = tail) != null)\n+                return t;\n+            else if (head != null)\n+                Thread.onSpinWait();\n+            else {\n+                if (h == null) {\n+                    try {\n+                        h = new ExclusiveNode();\n+                    } catch (OutOfMemoryError oome) {\n+                        return null;\n+                    }\n+                }\n+                if (U.compareAndSetReference(this, HEAD, null, h))\n+                    return tail = h;\n+            }\n+        }\n@@ -205,0 +222,1 @@\n+\n@@ -209,1 +227,1 @@\n-    final void enqueue(Node node) {\n+    final void enqueue(ConditionNode node) {\n@@ -211,2 +229,6 @@\n-            for (;;) {\n-                Node t = tail;\n+            boolean unpark = false;\n+            for (Node t;;) {\n+                if ((t = tail) == null && (t = tryInitializeHead()) == null) {\n+                    unpark = true;             \/\/ wake up to spin on OOME\n+                    break;\n+                }\n@@ -214,3 +236,1 @@\n-                if (t == null)                 \/\/ initialize\n-                    tryInitializeHead();\n-                else if (casTail(t, node)) {\n+                if (casTail(t, node)) {\n@@ -219,1 +239,1 @@\n-                        LockSupport.unpark(node.waiter);\n+                        unpark = true;\n@@ -223,0 +243,2 @@\n+            if (unpark)\n+                LockSupport.unpark(node.waiter);\n@@ -281,0 +303,2 @@\n+         *  else if queue is not initialized, do so by attaching new header node\n+         *     resort to spinwait on OOME trying to create node\n@@ -282,0 +306,1 @@\n+         *     resort to spinwait on OOME trying to create node\n@@ -324,5 +349,10 @@\n-            if (node == null) {                 \/\/ allocate; retry before enqueue\n-                if (shared)\n-                    node = new SharedNode();\n-                else\n-                    node = new ExclusiveNode();\n+            Node t;\n+            if ((t = tail) == null) {           \/\/ initialize queue\n+                if (tryInitializeHead() == null)\n+                    return acquireOnOOME(shared, arg);\n+            } else if (node == null) {          \/\/ allocate; retry before enqueue\n+                try {\n+                    node = (shared) ? new SharedNode() : new ExclusiveNode();\n+                } catch (OutOfMemoryError oome) {\n+                    return acquireOnOOME(shared, arg);\n+                }\n@@ -331,1 +361,0 @@\n-                Node t = tail;\n@@ -333,3 +362,1 @@\n-                if (t == null)\n-                    tryInitializeHead();\n-                else if (!casTail(t, node))\n+                if (!casTail(t, node))\n@@ -361,0 +388,13 @@\n+    \/**\n+     * Spin-waits with backoff; used only upon OOME failures during acquire.\n+     *\/\n+    private int acquireOnOOME(boolean shared, long arg) {\n+        for (long nanos = 1L;;) {\n+            if (shared ? (tryAcquireShared(arg) >= 0) : tryAcquire(arg))\n+                return 1;\n+            U.park(false, nanos);               \/\/ must use Unsafe park to sleep\n+            if (nanos < 1L << 30)               \/\/ max about 1 second\n+                nanos <<= 1;\n+        }\n+    }\n+\n@@ -363,1 +403,2 @@\n-     * nodes until none are found.\n+     * nodes until none are found. Unparks nodes that may have been\n+     * relinked to be next eligible acquirer.\n@@ -1070,0 +1111,6 @@\n+        \/**\n+         * Fixed delay in nanoseconds between releasing and reacquiring\n+         * lock during Condition waits that encounter OutOfMemoryErrors\n+         *\/\n+        static final long OOME_COND_WAIT_DELAY = 10L * 1000L * 1000L; \/\/ 10 ms\n+\n@@ -1106,1 +1153,1 @@\n-            if (first != null)\n+            else if (first != null)\n@@ -1121,1 +1168,1 @@\n-            if (first != null)\n+            else if (first != null)\n@@ -1188,0 +1235,20 @@\n+        \/**\n+         * Constructs objects needed for condition wait. On OOME,\n+         * releases lock, sleeps, reacquires, and returns null.\n+         *\/\n+        private ConditionNode newConditionNode() {\n+            long savedState;\n+            if (tryInitializeHead() != null) {\n+                try {\n+                    return new ConditionNode();\n+                } catch (OutOfMemoryError oome) {\n+                }\n+            }\n+            \/\/ fall through if encountered OutOfMemoryError\n+            if (!isHeldExclusively() || !release(savedState = getState()))\n+                throw new IllegalMonitorStateException();\n+            U.park(false, OOME_COND_WAIT_DELAY);\n+            acquireOnOOME(false, savedState);\n+            return null;\n+        }\n+\n@@ -1200,1 +1267,3 @@\n-            ConditionNode node = new ConditionNode();\n+            ConditionNode node = newConditionNode();\n+            if (node == null)\n+                return;\n@@ -1244,1 +1313,3 @@\n-            ConditionNode node = new ConditionNode();\n+            ConditionNode node = newConditionNode();\n+            if (node == null)\n+                return;\n@@ -1295,1 +1366,3 @@\n-            ConditionNode node = new ConditionNode();\n+            ConditionNode node = newConditionNode();\n+            if (node == null)\n+                return nanosTimeout - OOME_COND_WAIT_DELAY;\n@@ -1339,1 +1412,3 @@\n-            ConditionNode node = new ConditionNode();\n+            ConditionNode node = newConditionNode();\n+            if (node == null)\n+                return false;\n@@ -1380,1 +1455,3 @@\n-            ConditionNode node = new ConditionNode();\n+            ConditionNode node = newConditionNode();\n+            if (node == null)\n+                return false;\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/locks\/AbstractQueuedLongSynchronizer.java","additions":106,"deletions":29,"binary":false,"changes":135,"status":"modified"},{"patch":"@@ -435,0 +435,13 @@\n+     * Most AQS methods may be called by JDK components that cannot be\n+     * allowed to fail when encountering OutOfMemoryErrors. The main\n+     * acquire method resorts to spin-waits with backoff if nodes\n+     * cannot be allocated. Condition waits release and reacquire\n+     * locks upon OOME at a slow fixed rate (OOME_COND_WAIT_DELAY)\n+     * designed with the hope that eventually enough memory will be\n+     * recovered; if not performance can be very slow. Effectiveness\n+     * is also limited by the possibility of class loading triggered\n+     * by first-time usages, that may encounter unrecoverable\n+     * OOMEs. Also, it is possible for OutOfMemoryErrors to be thrown\n+     * when attempting to create and throw\n+     * IllegalMonitorStateExceptions and InterruptedExceptions.\n+     *\n@@ -565,5 +578,22 @@\n-    \/** tries once to CAS a new dummy node for head *\/\n-    private void tryInitializeHead() {\n-        Node h = new ExclusiveNode();\n-        if (U.compareAndSetReference(this, HEAD, null, h))\n-            tail = h;\n+    \/**\n+     * Tries to CAS a new dummy node for head.\n+     * Returns new tail, or null if OutOfMemory\n+     *\/\n+    private Node tryInitializeHead() {\n+        for (Node h = null, t;;) {\n+            if ((t = tail) != null)\n+                return t;\n+            else if (head != null)\n+                Thread.onSpinWait();\n+            else {\n+                if (h == null) {\n+                    try {\n+                        h = new ExclusiveNode();\n+                    } catch (OutOfMemoryError oome) {\n+                        return null;\n+                    }\n+                }\n+                if (U.compareAndSetReference(this, HEAD, null, h))\n+                    return tail = h;\n+            }\n+        }\n@@ -576,1 +606,1 @@\n-    final void enqueue(Node node) {\n+    final void enqueue(ConditionNode node) {\n@@ -578,2 +608,6 @@\n-            for (;;) {\n-                Node t = tail;\n+            boolean unpark = false;\n+            for (Node t;;) {\n+                if ((t = tail) == null && (t = tryInitializeHead()) == null) {\n+                    unpark = true;             \/\/ wake up to spin on OOME\n+                    break;\n+                }\n@@ -581,3 +615,1 @@\n-                if (t == null)                 \/\/ initialize\n-                    tryInitializeHead();\n-                else if (casTail(t, node)) {\n+                if (casTail(t, node)) {\n@@ -586,1 +618,1 @@\n-                        LockSupport.unpark(node.waiter);\n+                        unpark = true;\n@@ -590,0 +622,2 @@\n+            if (unpark)\n+                LockSupport.unpark(node.waiter);\n@@ -641,1 +675,1 @@\n-        Node pred = null;                \/\/ predecessor of node when enqueued\n+        Node pred = null;               \/\/ predecessor of node when enqueued\n@@ -648,0 +682,2 @@\n+         *  else if queue is not initialized, do so by attaching new header node\n+         *     resort to spinwait on OOME trying to create node\n@@ -649,0 +685,1 @@\n+         *     resort to spinwait on OOME trying to create node\n@@ -691,5 +728,10 @@\n-            if (node == null) {                 \/\/ allocate; retry before enqueue\n-                if (shared)\n-                    node = new SharedNode();\n-                else\n-                    node = new ExclusiveNode();\n+            Node t;\n+            if ((t = tail) == null) {           \/\/ initialize queue\n+                if (tryInitializeHead() == null)\n+                    return acquireOnOOME(shared, arg);\n+            } else if (node == null) {          \/\/ allocate; retry before enqueue\n+                try {\n+                    node = (shared) ? new SharedNode() : new ExclusiveNode();\n+                } catch (OutOfMemoryError oome) {\n+                    return acquireOnOOME(shared, arg);\n+                }\n@@ -698,1 +740,0 @@\n-                Node t = tail;\n@@ -700,3 +741,1 @@\n-                if (t == null)\n-                    tryInitializeHead();\n-                else if (!casTail(t, node))\n+                if (!casTail(t, node))\n@@ -728,0 +767,13 @@\n+    \/**\n+     * Spin-waits with backoff; used only upon OOME failures during acquire.\n+     *\/\n+    private int acquireOnOOME(boolean shared, int arg) {\n+        for (long nanos = 1L;;) {\n+            if (shared ? (tryAcquireShared(arg) >= 0) : tryAcquire(arg))\n+                return 1;\n+            U.park(false, nanos);               \/\/ must use Unsafe park to sleep\n+            if (nanos < 1L << 30)               \/\/ max about 1 second\n+                nanos <<= 1;\n+        }\n+    }\n+\n@@ -1438,0 +1490,6 @@\n+        \/**\n+         * Fixed delay in nanoseconds between releasing and reacquiring\n+         * lock during Condition waits that encounter OutOfMemoryErrors\n+         *\/\n+        static final long OOME_COND_WAIT_DELAY = 10L * 1000L * 1000L; \/\/ 10 ms\n+\n@@ -1474,1 +1532,1 @@\n-            if (first != null)\n+            else if (first != null)\n@@ -1489,1 +1547,1 @@\n-            if (first != null)\n+            else if (first != null)\n@@ -1556,0 +1614,20 @@\n+        \/**\n+         * Constructs objects needed for condition wait. On OOME,\n+         * releases lock, sleeps, reacquires, and returns null.\n+         *\/\n+        private ConditionNode newConditionNode() {\n+            int savedState;\n+            if (tryInitializeHead() != null) {\n+                try {\n+                    return new ConditionNode();\n+                } catch (OutOfMemoryError oome) {\n+                }\n+            }\n+            \/\/ fall through if encountered OutOfMemoryError\n+            if (!isHeldExclusively() || !release(savedState = getState()))\n+                throw new IllegalMonitorStateException();\n+            U.park(false, OOME_COND_WAIT_DELAY);\n+            acquireOnOOME(false, savedState);\n+            return null;\n+        }\n+\n@@ -1568,1 +1646,3 @@\n-            ConditionNode node = new ConditionNode();\n+            ConditionNode node = newConditionNode();\n+            if (node == null)\n+                return;\n@@ -1612,1 +1692,3 @@\n-            ConditionNode node = new ConditionNode();\n+            ConditionNode node = newConditionNode();\n+            if (node == null)\n+                return;\n@@ -1663,1 +1745,3 @@\n-            ConditionNode node = new ConditionNode();\n+            ConditionNode node = newConditionNode();\n+            if (node == null)\n+                return nanosTimeout - OOME_COND_WAIT_DELAY;\n@@ -1707,1 +1791,3 @@\n-            ConditionNode node = new ConditionNode();\n+            ConditionNode node = newConditionNode();\n+            if (node == null)\n+                return false;\n@@ -1748,1 +1834,3 @@\n-            ConditionNode node = new ConditionNode();\n+            ConditionNode node = newConditionNode();\n+            if (node == null)\n+                return false;\n@@ -1854,1 +1942,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/locks\/AbstractQueuedSynchronizer.java","additions":117,"deletions":30,"binary":false,"changes":147,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-java\/lang\/ref\/OOMEInReferenceHandler.java 8066859 generic-all\n","filename":"test\/jdk\/ProblemList-Xcomp.txt","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -498,1 +498,0 @@\n-java\/lang\/ref\/OOMEInReferenceHandler.java                       8066859 generic-all\n","filename":"test\/jdk\/ProblemList.txt","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,128 @@\n+\/*\n+ * Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.Phaser;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.concurrent.locks.Condition;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.Condition;\n+import java.util.concurrent.locks.ReentrantLock;\n+import java.util.function.Consumer;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+\/**\n+ * @test\n+ * @bug 8066859\n+ * @summary Check that AQS-based locks, conditions, and CountDownLatches do not fail when encountering OOME\n+ * @run main\/othervm -XX:-UseGCOverheadLimit -Xmx24M -XX:-UseTLAB OOMEInAQS\n+ *\/\n+\n+public class OOMEInAQS extends Thread {\n+    static final int NTHREADS = 2; \/\/ intentionally not a scalable test; > 2 is very slow\n+    static final int NREPS = 100;\n+    \/\/ statically allocate\n+    static final ReentrantLock mainLock = new ReentrantLock();\n+    static final Condition condition = mainLock.newCondition();\n+    static final CountDownLatch started = new CountDownLatch(1);\n+    static final CountDownLatch filled = new CountDownLatch(1);\n+    static volatile Object data;\n+    static int turn;\n+\n+    \/**\n+     * For each of NTHREADS threads, REPS times: Take turns\n+     * executing. Introduce OOM using fillHeap during runs.\n+     *\/\n+    public static void main(String[] args) throws Throwable {\n+        OOMEInAQS[] threads = new OOMEInAQS[NTHREADS];\n+        for (int i = 0; i < NTHREADS; ++i)\n+            (threads[i] = new OOMEInAQS(i)).start();\n+        started.countDown();\n+        long t0 = System.nanoTime();\n+        data = fillHeap();\n+        filled.countDown();\n+        long t1 = System.nanoTime();\n+        for (int i = 0; i < NTHREADS; ++i)\n+            threads[i].join();\n+        data = null;  \/\/ free heap before reporting and terminating\n+        System.gc();\n+        System.out.println(\n+            \"fillHeap time: \" + (t1 - t0) \/ 1000_000 +\n+            \" millis, whole test time: \" + (System.nanoTime() - t0) \/ 1000_000 +\n+            \" millis\"\n+        );\n+    }\n+\n+    final int tid;\n+    OOMEInAQS(int tid) {\n+        this.tid = tid;\n+    }\n+\n+    @Override\n+    public void run() {\n+        int id = tid, nextId = (id + 1) % NTHREADS;\n+        final ReentrantLock lock = mainLock;\n+        final Condition cond = condition;\n+        try {\n+            started.await();\n+            for (int i = 0; i < NREPS; i++) {\n+                try {\n+                    lock.lock();\n+                    while (turn != id)\n+                        cond.await();\n+                    turn = nextId;\n+                    cond.signalAll();\n+                } finally {\n+                    lock.unlock();\n+                }\n+                if (i == 2) \/\/ Subsequent AQS methods encounter OOME\n+                    filled.await();\n+            }\n+        } catch (Throwable ex) { \/\/ Could be InterruptedExeption or OOME\n+            data = null;\n+            System.exit(0); \/\/ avoid getting stuck trying to recover\n+        }\n+    }\n+\n+    static Object[] fillHeap() {\n+        Object[] first = null, last = null;\n+        int size = 1 << 20;\n+        while (size > 0) {\n+            try {\n+                Object[] array = new Object[size];\n+                if (first == null) {\n+                    first = array;\n+                } else {\n+                    last[0] = array;\n+                }\n+                last = array;\n+            } catch (OutOfMemoryError oome) {\n+                size = size >>> 1;\n+            }\n+        }\n+        return first;\n+    }\n+}\n","filename":"test\/jdk\/java\/util\/concurrent\/locks\/Lock\/OOMEInAQS.java","additions":128,"deletions":0,"binary":false,"changes":128,"status":"added"}]}