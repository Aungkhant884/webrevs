{"files":[{"patch":"@@ -198,5 +198,22 @@\n-    \/** tries once to CAS a new dummy node for head *\/\n-    private void tryInitializeHead() {\n-        Node h = new ExclusiveNode();\n-        if (U.compareAndSetReference(this, HEAD, null, h))\n-            tail = h;\n+    \/**\n+     * Tries to CAS a new dummy node for head.\n+     * Returns new tail, or null if OutOfMemory\n+     *\/\n+    private Node tryInitializeHead() {\n+        for (Node h = null, t;;) {\n+            if ((t = tail) != null)\n+                return t;\n+            else if (head != null)\n+                Thread.onSpinWait();\n+            else {\n+                if (h == null) {\n+                    try {\n+                        h = new ExclusiveNode();\n+                    } catch (OutOfMemoryError oome) {\n+                        return null;\n+                    }\n+                }\n+                if (U.compareAndSetReference(this, HEAD, null, h))\n+                    return tail = h;\n+            }\n+        }\n@@ -205,0 +222,1 @@\n+\n@@ -209,1 +227,1 @@\n-    final void enqueue(Node node) {\n+    final void enqueue(ConditionNode node) {\n@@ -211,2 +229,6 @@\n-            for (;;) {\n-                Node t = tail;\n+            boolean unpark = false;\n+            for (Node t;;) {\n+                if ((t = tail) == null && (t = tryInitializeHead()) == null) {\n+                    unpark = true;             \/\/ wake up to spin on OOME\n+                    break;\n+                }\n@@ -214,3 +236,1 @@\n-                if (t == null)                 \/\/ initialize\n-                    tryInitializeHead();\n-                else if (casTail(t, node)) {\n+                if (casTail(t, node)) {\n@@ -219,1 +239,1 @@\n-                        LockSupport.unpark(node.waiter);\n+                        unpark = true;\n@@ -223,0 +243,2 @@\n+            if (unpark)\n+                LockSupport.unpark(node.waiter);\n@@ -281,0 +303,2 @@\n+         *  else if queue is not initialized, do so by attaching new header node\n+         *     resort to spinwait on OOME trying to create node\n@@ -282,0 +306,1 @@\n+         *     resort to spinwait on OOME trying to create node\n@@ -324,5 +349,10 @@\n-            if (node == null) {                 \/\/ allocate; retry before enqueue\n-                if (shared)\n-                    node = new SharedNode();\n-                else\n-                    node = new ExclusiveNode();\n+            Node t;\n+            if ((t = tail) == null) {           \/\/ initialize queue\n+                if (tryInitializeHead() == null)\n+                    return acquireOnOOME(shared, arg);\n+            } else if (node == null) {          \/\/ allocate; retry before enqueue\n+                try {\n+                    node = (shared) ? new SharedNode() : new ExclusiveNode();\n+                } catch (OutOfMemoryError oome) {\n+                    return acquireOnOOME(shared, arg);\n+                }\n@@ -331,1 +361,0 @@\n-                Node t = tail;\n@@ -333,3 +362,1 @@\n-                if (t == null)\n-                    tryInitializeHead();\n-                else if (!casTail(t, node))\n+                if (!casTail(t, node))\n@@ -361,0 +388,13 @@\n+    \/**\n+     * Spin-waits with backoff; used only upon OOME failures during acquire.\n+     *\/\n+    private int acquireOnOOME(boolean shared, long arg) {\n+        for (long nanos = 1L;;) {\n+            if (shared ? (tryAcquireShared(arg) >= 0) : tryAcquire(arg))\n+                return 1;\n+            U.park(false, nanos);               \/\/ must use Unsafe park to sleep\n+            if (nanos < 1L << 30)               \/\/ max about 1 second\n+                nanos <<= 1;\n+        }\n+    }\n+\n@@ -363,1 +403,2 @@\n-     * nodes until none are found.\n+     * nodes until none are found. Unparks nodes that may have been\n+     * relinked to be next eligible acquirer.\n@@ -591,1 +632,1 @@\n-            throw new InterruptedException();\n+            throw LockSupport.interruptedException();\n@@ -680,1 +721,1 @@\n-            throw new InterruptedException();\n+            throw LockSupport.interruptedException();\n@@ -713,1 +754,1 @@\n-        throw new InterruptedException();\n+        throw LockSupport.interruptedException();\n@@ -1070,0 +1111,6 @@\n+        \/**\n+         * Fixed delay in nanoseconds between releasing and reacquiring\n+         * lock during Condition waits that encounter OutOfMemoryErrors\n+         *\/\n+        static final long OOME_COND_WAIT_DELAY = 10L * 1000L * 1000L; \/\/ 10 ms\n+\n@@ -1105,2 +1152,2 @@\n-                throw new IllegalMonitorStateException();\n-            if (first != null)\n+                throw LockSupport.illegalMonitorStateException();\n+            else if (first != null)\n@@ -1120,2 +1167,2 @@\n-                throw new IllegalMonitorStateException();\n-            if (first != null)\n+                throw LockSupport.illegalMonitorStateException();\n+            else if (first != null)\n@@ -1148,1 +1195,1 @@\n-            throw new IllegalMonitorStateException();\n+            throw LockSupport.illegalMonitorStateException();\n@@ -1188,0 +1235,20 @@\n+        \/**\n+         * Constructs objects needed for condition wait. On OOME,\n+         * releases lock, sleeps, reacquires, and returns null.\n+         *\/\n+        private ConditionNode newConditionNode() {\n+            long savedState;\n+            if (tryInitializeHead() != null) {\n+                try {\n+                    return new ConditionNode();\n+                } catch (OutOfMemoryError oome) {\n+                }\n+            }\n+            \/\/ fall through if encountered OutOfMemoryError\n+            if (!isHeldExclusively() || !release(savedState = getState()))\n+                throw LockSupport.staticIllegalMonitorStateException;\n+            U.park(false, OOME_COND_WAIT_DELAY);\n+            acquireOnOOME(false, savedState);\n+            return null;\n+        }\n+\n@@ -1200,1 +1267,3 @@\n-            ConditionNode node = new ConditionNode();\n+            ConditionNode node = newConditionNode();\n+            if (node == null)\n+                return;\n@@ -1243,2 +1312,4 @@\n-                throw new InterruptedException();\n-            ConditionNode node = new ConditionNode();\n+                throw LockSupport.interruptedException();\n+            ConditionNode node = newConditionNode();\n+            if (node == null)\n+                return;\n@@ -1272,1 +1343,1 @@\n-                    throw new InterruptedException();\n+                    throw LockSupport.interruptedException();\n@@ -1294,2 +1365,4 @@\n-                throw new InterruptedException();\n-            ConditionNode node = new ConditionNode();\n+                throw LockSupport.interruptedException();\n+            ConditionNode node = newConditionNode();\n+            if (node == null)\n+                return nanosTimeout - OOME_COND_WAIT_DELAY;\n@@ -1313,1 +1386,1 @@\n-                    throw new InterruptedException();\n+                    throw LockSupport.interruptedException();\n@@ -1338,2 +1411,4 @@\n-                throw new InterruptedException();\n-            ConditionNode node = new ConditionNode();\n+                throw LockSupport.interruptedException();\n+            ConditionNode node = newConditionNode();\n+            if (node == null)\n+                return false;\n@@ -1355,1 +1430,1 @@\n-                    throw new InterruptedException();\n+                    throw LockSupport.interruptedException();\n@@ -1379,2 +1454,4 @@\n-                throw new InterruptedException();\n-            ConditionNode node = new ConditionNode();\n+                throw LockSupport.interruptedException();\n+            ConditionNode node = newConditionNode();\n+            if (node == null)\n+                return false;\n@@ -1398,1 +1475,1 @@\n-                    throw new InterruptedException();\n+                    throw LockSupport.interruptedException();\n@@ -1426,1 +1503,1 @@\n-                throw new IllegalMonitorStateException();\n+                throw LockSupport.illegalMonitorStateException();\n@@ -1445,1 +1522,1 @@\n-                throw new IllegalMonitorStateException();\n+                throw LockSupport.illegalMonitorStateException();\n@@ -1465,1 +1542,1 @@\n-                throw new IllegalMonitorStateException();\n+                throw LockSupport.illegalMonitorStateException();\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/locks\/AbstractQueuedLongSynchronizer.java","additions":123,"deletions":46,"binary":false,"changes":169,"status":"modified"},{"patch":"@@ -435,0 +435,13 @@\n+     * Most AQS methods may be called by JDK components that cannot be\n+     * allowed to fail when encountering OutOfMemoryErrors. The main\n+     * acquire method resorts to spin-waits with backoff if nodes\n+     * cannot be allocated. Static IllegalMonitorStateException and\n+     * InterruptedException objects (without useful stack traces)\n+     * defined in class LockSupport are thrown when applicable on\n+     * OOM. Condition waits release and reacquire locks upon OOME at a\n+     * slow fixed rate (OOME_COND_WAIT_DELAY) designed with the hope\n+     * that eventually enough memory will be recovered; if not\n+     * performance can be very slow. Effectiveness is also limited by\n+     * the possibility of class loading triggered by first-time\n+     * usages, that may encounter unrecoverable OOMEs.\n+     *\n@@ -565,5 +578,22 @@\n-    \/** tries once to CAS a new dummy node for head *\/\n-    private void tryInitializeHead() {\n-        Node h = new ExclusiveNode();\n-        if (U.compareAndSetReference(this, HEAD, null, h))\n-            tail = h;\n+    \/**\n+     * Tries to CAS a new dummy node for head.\n+     * Returns new tail, or null if OutOfMemory\n+     *\/\n+    private Node tryInitializeHead() {\n+        for (Node h = null, t;;) {\n+            if ((t = tail) != null)\n+                return t;\n+            else if (head != null)\n+                Thread.onSpinWait();\n+            else {\n+                if (h == null) {\n+                    try {\n+                        h = new ExclusiveNode();\n+                    } catch (OutOfMemoryError oome) {\n+                        return null;\n+                    }\n+                }\n+                if (U.compareAndSetReference(this, HEAD, null, h))\n+                    return tail = h;\n+            }\n+        }\n@@ -576,1 +606,1 @@\n-    final void enqueue(Node node) {\n+    final void enqueue(ConditionNode node) {\n@@ -578,2 +608,6 @@\n-            for (;;) {\n-                Node t = tail;\n+            boolean unpark = false;\n+            for (Node t;;) {\n+                if ((t = tail) == null && (t = tryInitializeHead()) == null) {\n+                    unpark = true;             \/\/ wake up to spin on OOME\n+                    break;\n+                }\n@@ -581,3 +615,1 @@\n-                if (t == null)                 \/\/ initialize\n-                    tryInitializeHead();\n-                else if (casTail(t, node)) {\n+                if (casTail(t, node)) {\n@@ -586,1 +618,1 @@\n-                        LockSupport.unpark(node.waiter);\n+                        unpark = true;\n@@ -590,0 +622,2 @@\n+            if (unpark)\n+                LockSupport.unpark(node.waiter);\n@@ -641,1 +675,1 @@\n-        Node pred = null;                \/\/ predecessor of node when enqueued\n+        Node pred = null;               \/\/ predecessor of node when enqueued\n@@ -648,0 +682,2 @@\n+         *  else if queue is not initialized, do so by attaching new header node\n+         *     resort to spinwait on OOME trying to create node\n@@ -649,0 +685,1 @@\n+         *     resort to spinwait on OOME trying to create node\n@@ -691,5 +728,10 @@\n-            if (node == null) {                 \/\/ allocate; retry before enqueue\n-                if (shared)\n-                    node = new SharedNode();\n-                else\n-                    node = new ExclusiveNode();\n+            Node t;\n+            if ((t = tail) == null) {           \/\/ initialize queue\n+                if (tryInitializeHead() == null)\n+                    return acquireOnOOME(shared, arg);\n+            } else if (node == null) {          \/\/ allocate; retry before enqueue\n+                try {\n+                    node = (shared) ? new SharedNode() : new ExclusiveNode();\n+                } catch (OutOfMemoryError oome) {\n+                    return acquireOnOOME(shared, arg);\n+                }\n@@ -698,1 +740,0 @@\n-                Node t = tail;\n@@ -700,3 +741,1 @@\n-                if (t == null)\n-                    tryInitializeHead();\n-                else if (!casTail(t, node))\n+                if (!casTail(t, node))\n@@ -728,0 +767,13 @@\n+    \/**\n+     * Spin-waits with backoff; used only upon OOME failures during acquire.\n+     *\/\n+    private int acquireOnOOME(boolean shared, int arg) {\n+        for (long nanos = 1L;;) {\n+            if (shared ? (tryAcquireShared(arg) >= 0) : tryAcquire(arg))\n+                return 1;\n+            U.park(false, nanos);               \/\/ must use Unsafe park to sleep\n+            if (nanos < 1L << 30)               \/\/ max about 1 second\n+                nanos <<= 1;\n+        }\n+    }\n+\n@@ -959,1 +1011,1 @@\n-            throw new InterruptedException();\n+            throw LockSupport.interruptedException();\n@@ -993,1 +1045,1 @@\n-        throw new InterruptedException();\n+        throw LockSupport.interruptedException();\n@@ -1048,1 +1100,1 @@\n-            throw new InterruptedException();\n+            throw LockSupport.interruptedException();\n@@ -1081,1 +1133,1 @@\n-        throw new InterruptedException();\n+        throw LockSupport.interruptedException();\n@@ -1438,0 +1490,6 @@\n+        \/**\n+         * Fixed delay in nanoseconds between releasing and reacquiring\n+         * lock during Condition waits that encounter OutOfMemoryErrors\n+         *\/\n+        static final long OOME_COND_WAIT_DELAY = 10L * 1000L * 1000L; \/\/ 10 ms\n+\n@@ -1473,2 +1531,2 @@\n-                throw new IllegalMonitorStateException();\n-            if (first != null)\n+                throw LockSupport.illegalMonitorStateException();\n+            else if (first != null)\n@@ -1488,2 +1546,2 @@\n-                throw new IllegalMonitorStateException();\n-            if (first != null)\n+                throw LockSupport.illegalMonitorStateException();\n+            else if (first != null)\n@@ -1516,1 +1574,1 @@\n-            throw new IllegalMonitorStateException();\n+            throw LockSupport.illegalMonitorStateException();\n@@ -1556,0 +1614,20 @@\n+        \/**\n+         * Constructs objects needed for condition wait. On OOME,\n+         * releases lock, sleeps, reacquires, and returns null.\n+         *\/\n+        private ConditionNode newConditionNode() {\n+            int savedState;\n+            if (tryInitializeHead() != null) {\n+                try {\n+                    return new ConditionNode();\n+                } catch (OutOfMemoryError oome) {\n+                }\n+            }\n+            \/\/ fall through if encountered OutOfMemoryError\n+            if (!isHeldExclusively() || !release(savedState = getState()))\n+                throw LockSupport.staticIllegalMonitorStateException;\n+            U.park(false, OOME_COND_WAIT_DELAY);\n+            acquireOnOOME(false, savedState);\n+            return null;\n+        }\n+\n@@ -1568,1 +1646,3 @@\n-            ConditionNode node = new ConditionNode();\n+            ConditionNode node = newConditionNode();\n+            if (node == null)\n+                return;\n@@ -1611,2 +1691,4 @@\n-                throw new InterruptedException();\n-            ConditionNode node = new ConditionNode();\n+                throw LockSupport.interruptedException();\n+            ConditionNode node = newConditionNode();\n+            if (node == null)\n+                return;\n@@ -1640,1 +1722,1 @@\n-                    throw new InterruptedException();\n+                    throw LockSupport.interruptedException();\n@@ -1662,2 +1744,4 @@\n-                throw new InterruptedException();\n-            ConditionNode node = new ConditionNode();\n+                throw LockSupport.interruptedException();\n+            ConditionNode node = newConditionNode();\n+            if (node == null)\n+                return nanosTimeout - OOME_COND_WAIT_DELAY;\n@@ -1681,1 +1765,1 @@\n-                    throw new InterruptedException();\n+                    throw LockSupport.interruptedException();\n@@ -1706,2 +1790,4 @@\n-                throw new InterruptedException();\n-            ConditionNode node = new ConditionNode();\n+                throw LockSupport.interruptedException();\n+            ConditionNode node = newConditionNode();\n+            if (node == null)\n+                return false;\n@@ -1723,1 +1809,1 @@\n-                    throw new InterruptedException();\n+                    throw LockSupport.interruptedException();\n@@ -1747,2 +1833,4 @@\n-                throw new InterruptedException();\n-            ConditionNode node = new ConditionNode();\n+                throw LockSupport.interruptedException();\n+            ConditionNode node = newConditionNode();\n+            if (node == null)\n+                return false;\n@@ -1766,1 +1854,1 @@\n-                    throw new InterruptedException();\n+                    throw LockSupport.interruptedException();\n@@ -1794,1 +1882,1 @@\n-                throw new IllegalMonitorStateException();\n+                throw LockSupport.illegalMonitorStateException();\n@@ -1813,1 +1901,1 @@\n-                throw new IllegalMonitorStateException();\n+                throw LockSupport.illegalMonitorStateException();\n@@ -1833,1 +1921,1 @@\n-                throw new IllegalMonitorStateException();\n+                throw LockSupport.illegalMonitorStateException();\n@@ -1854,1 +1942,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/locks\/AbstractQueuedSynchronizer.java","additions":135,"deletions":48,"binary":false,"changes":183,"status":"modified"},{"patch":"@@ -460,0 +460,40 @@\n+    \/**\n+     *  Preallocated exceptions thrown if acquiring or releasing locks\n+     *  when OutOfMemory.\n+     *\/\n+    static final IllegalMonitorStateException staticIllegalMonitorStateException\n+        = new IllegalMonitorStateException() {\n+                @Override public Throwable fillInStackTrace() { return this; }\n+                @Override public void setStackTrace(java.lang.StackTraceElement[] new_stackTrace) {}\n+            };\n+\n+    static final InterruptedException staticInterruptedException\n+        = new InterruptedException() {\n+                @Override public Throwable fillInStackTrace() { return this; }\n+                @Override public void setStackTrace(java.lang.StackTraceElement[] new_stackTrace) {}\n+            };\n+\n+    \/**\n+     * Returns an IllegalMonitorStateException, using preallocated\n+     * exception on OutOfMemoryError\n+     *\/\n+    static final IllegalMonitorStateException illegalMonitorStateException() {\n+        try {\n+            return new IllegalMonitorStateException();\n+        } catch (OutOfMemoryError oome) {\n+            return staticIllegalMonitorStateException;\n+        }\n+    }\n+\n+    \/**\n+     * Returns an InterruptedException, using preallocated\n+     * exception on OutOfMemoryError\n+     *\/\n+    static final InterruptedException interruptedException() {\n+        try {\n+            return new InterruptedException();\n+        } catch (OutOfMemoryError oome) {\n+            return staticInterruptedException;\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/locks\/LockSupport.java","additions":40,"deletions":0,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-java\/lang\/ref\/OOMEInReferenceHandler.java 8066859 generic-all\n","filename":"test\/jdk\/ProblemList-Xcomp.txt","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -498,1 +498,1 @@\n-java\/lang\/ref\/OOMEInReferenceHandler.java                       8066859 generic-all\n+java\/lang\/CompressExpandTest.java                               8287851 generic-all\n","filename":"test\/jdk\/ProblemList.txt","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,107 @@\n+\/\/package concurrent;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.Phaser;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.concurrent.locks.Condition;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.Condition;\n+import java.util.concurrent.locks.ReentrantLock;\n+import java.util.function.Consumer;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+\/**\n+ * @test\n+ * @bug 8066859\n+ * @summary Check that AQS-based locks, conditions, and CountDownLatches do not fail when encountering OOME\n+ * @run main\/othervm -XX:-UseGCOverheadLimit -Xmx24M -XX:-UseTLAB OOMEInAQS\n+ *\/\n+\n+public class OOMEInAQS extends Thread {\n+    static final int NTHREADS = 2; \/\/ intentionally not a scalable test; > 2 is very slow\n+    static final int NREPS = 100;\n+    \/\/ statically allocate\n+    static final ReentrantLock mainLock = new ReentrantLock();\n+    static final Condition condition = mainLock.newCondition();\n+    static final CountDownLatch started = new CountDownLatch(1);\n+    static final CountDownLatch filled = new CountDownLatch(1);\n+    static volatile Object data;\n+    static int turn;\n+\n+    \/**\n+     * For each of NTHREADS threads, REPS times: Take turns\n+     * executing. Introduce OOM using fillHeap during runs.\n+     *\/\n+    public static void main(String[] args) throws Throwable {\n+        OOMEInAQS[] threads = new OOMEInAQS[NTHREADS];\n+        for (int i = 0; i < NTHREADS; ++i)\n+            (threads[i] = new OOMEInAQS(i)).start();\n+        started.countDown();\n+        long t0 = System.nanoTime();\n+        data = fillHeap();\n+        filled.countDown();\n+        long t1 = System.nanoTime();\n+        for (int i = 0; i < NTHREADS; ++i)\n+            threads[i].join();\n+        data = null;  \/\/ free heap before reporting and terminating\n+        System.gc();\n+        System.out.println(\n+            \"fillHeap time: \" + (t1 - t0) \/ 1000_000 +\n+            \" millis, whole test time: \" + (System.nanoTime() - t0) \/ 1000_000 +\n+            \" millis\"\n+        );\n+    }\n+\n+    final int tid;\n+    OOMEInAQS(int tid) {\n+        this.tid = tid;\n+    }\n+\n+    @Override\n+    public void run() {\n+        int id = tid, nextId = (id + 1) % NTHREADS;\n+        final ReentrantLock lock = mainLock;\n+        final Condition cond = condition;\n+        try {\n+            started.await();\n+            for (int i = 0; i < NREPS; i++) {\n+                try {\n+                    lock.lock();\n+                    while (turn != id)\n+                        cond.await();\n+                    turn = nextId;\n+                    cond.signalAll();\n+                } finally {\n+                    lock.unlock();\n+                }\n+                if (i == 2) \/\/ Subsequent AQS methods encounter OOME\n+                    filled.await();\n+            }\n+        } catch (InterruptedException ie) {\n+            data = null;\n+            System.exit(0); \/\/ avoid getting stuck trying to recover\n+        }\n+    }\n+\n+    static Object[] fillHeap() {\n+        Object[] first = null, last = null;\n+        int size = 1 << 20;\n+        while (size > 0) {\n+            try {\n+                Object[] array = new Object[size];\n+                if (first == null) {\n+                    first = array;\n+                } else {\n+                    last[0] = array;\n+                }\n+                last = array;\n+            } catch (OutOfMemoryError oome) {\n+                size = size >>> 1;\n+            }\n+        }\n+        return first;\n+    }\n+}\n","filename":"test\/jdk\/java\/util\/concurrent\/locks\/Lock\/OOMEInAQS.java","additions":107,"deletions":0,"binary":false,"changes":107,"status":"added"}]}