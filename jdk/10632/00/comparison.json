{"files":[{"patch":"@@ -26,1 +26,0 @@\n-#include \"nativeInst_ppc.hpp\"\n@@ -172,1 +171,4 @@\n-  __ isync();\n+  \/\/ But, many GCs don't modify nmethods during a concurrent phase.\n+  if (!UseSerialGC && !UseG1GC && !UseParallelGC && !UseEpsilonGC) {\n+    __ isync();\n+  }\n","filename":"src\/hotspot\/cpu\/ppc\/gc\/shared\/barrierSetAssembler_ppc.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -85,1 +85,1 @@\n-    verify_op_code(current_instruction, Assembler::ISYNC_OPCODE);\n+    \/\/ isync is optional\n@@ -103,1 +103,4 @@\n-  address barrier_address = nm->code_begin() + nm->frame_complete_offset() + (-9 * 4);\n+  address barrier_address = nm->code_begin() + nm->frame_complete_offset() + (-8 * 4);\n+  if (!UseSerialGC && !UseG1GC && !UseParallelGC && !UseEpsilonGC) {\n+    barrier_address -= 4; \/\/ isync (see nmethod_entry_barrier)\n+  }\n","filename":"src\/hotspot\/cpu\/ppc\/gc\/shared\/barrierSetNMethod_ppc.cpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"}]}