{"files":[{"patch":"@@ -80,0 +80,52 @@\n+\n+    \/\/ returns true if extended attributes enabled on file system where given\n+    \/\/ file resides, returns false if disabled or unable to determine.\n+    private boolean isExtendedAttributesEnabled(UnixPath path) {\n+        int fd = -1;\n+        try {\n+            fd = path.openForAttributeAccess(false);\n+\n+            \/\/ fgetxattr returns size if called with size==0\n+            byte[] name = Util.toBytes(\"user.java\");\n+            BsdNativeDispatcher.fgetxattr(fd, name, 0L, 0);\n+            return true;\n+        } catch (UnixException e) {\n+            \/\/ attribute does not exist\n+            if (e.errno() == UnixConstants.ENOATTR)\n+                return true;\n+        } finally {\n+            UnixNativeDispatcher.close(fd);\n+        }\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean supportsFileAttributeView(Class<? extends FileAttributeView> type) {\n+        \/\/ support UserDefinedAttributeView if extended attributes enabled\n+        if (type == UserDefinedFileAttributeView.class) {\n+            \/\/ lookup fstypes.properties\n+            FeatureStatus status = checkIfFeaturePresent(\"user_xattr\");\n+            if (status == FeatureStatus.PRESENT)\n+                return true;\n+            if (status == FeatureStatus.NOT_PRESENT)\n+                return false;\n+\n+            \/\/ typical macOS file system types that are known to support xattr\n+            if (entry().fstype().equals(\"apfs\")\n+                || entry().fstype().equals(\"hfs\")) {\n+                return true;\n+            }\n+\n+            \/\/ probe file system capabilities\n+            UnixPath dir = new UnixPath(file().getFileSystem(), entry().dir());\n+            return isExtendedAttributesEnabled(dir);\n+        }\n+        return super.supportsFileAttributeView(type);\n+    }\n+\n+    @Override\n+    public boolean supportsFileAttributeView(String name) {\n+        if (name.equals(\"user\"))\n+            return supportsFileAttributeView(UserDefinedFileAttributeView.class);\n+        return super.supportsFileAttributeView(name);\n+    }\n","filename":"src\/java.base\/macosx\/classes\/sun\/nio\/fs\/BsdFileStore.java","additions":52,"deletions":0,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -59,0 +59,2 @@\n+            \/\/ additional BSD-specific views\n+            result.add(\"user\");\n","filename":"src\/java.base\/macosx\/classes\/sun\/nio\/fs\/BsdFileSystem.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import java.nio.file.*;\n+import java.nio.file.attribute.*;\n@@ -48,0 +50,25 @@\n+\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public <V extends FileAttributeView> V getFileAttributeView(Path obj,\n+                                                                Class<V> type,\n+                                                                LinkOption... options)\n+    {\n+        if (type == UserDefinedFileAttributeView.class) {\n+            return (V) new BsdUserDefinedFileAttributeView(UnixPath.toUnixPath(obj),\n+                    Util.followLinks(options));\n+        }\n+        return super.getFileAttributeView(obj, type, options);\n+    }\n+\n+    @Override\n+    public DynamicFileAttributeView getFileAttributeView(Path obj,\n+                                                         String name,\n+                                                         LinkOption... options)\n+    {\n+        if (name.equals(\"user\")) {\n+            return new BsdUserDefinedFileAttributeView(UnixPath.toUnixPath(obj),\n+                    Util.followLinks(options));\n+        }\n+        return super.getFileAttributeView(obj, name, options);\n+    }\n","filename":"src\/java.base\/macosx\/classes\/sun\/nio\/fs\/BsdFileSystemProvider.java","additions":27,"deletions":0,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -68,0 +68,55 @@\n+    \/**\n+     * ssize_t fgetxattr(int fd, const char *name, void *value, size_t size, u_int32_t position, int options);\n+     *\/\n+    static int fgetxattr(int fd, byte[] name, long valueAddress, int valueLen) throws UnixException\n+    {\n+        NativeBuffer buffer = NativeBuffers.asNativeBuffer(name);\n+        try {\n+            return fgetxattr0(fd, buffer.address(), valueAddress, valueLen, 0L, 0);\n+        } finally {\n+            buffer.release();\n+        }\n+    }\n+\n+    private static native int fgetxattr0(int fd, long nameAddress, long valueAddress, int valueLen,\n+                                         long position, int options) throws UnixException;\n+\n+    \/**\n+     * int fsetxattr(int fd, const char *name, void *value, size_t size, u_int32_t position, int options);\n+     *\/\n+    static void fsetxattr(int fd, byte[] name, long valueAddress, int valueLen) throws UnixException\n+    {\n+        NativeBuffer buffer = NativeBuffers.asNativeBuffer(name);\n+        try {\n+            fsetxattr0(fd, buffer.address(), valueAddress, valueLen, 0L, 0);\n+        } finally {\n+            buffer.release();\n+        }\n+    }\n+\n+    private static native void fsetxattr0(int fd, long nameAddress, long valueAddress, int valueLen,\n+                                          long position, int options) throws UnixException;\n+\n+    \/**\n+     * int fremovexattr(int fd, const char *name, int options);\n+     *\/\n+    static void fremovexattr(int fd, byte[] name) throws UnixException {\n+        NativeBuffer buffer = NativeBuffers.asNativeBuffer(name);\n+        try {\n+            fremovexattr0(fd, buffer.address(), 0);\n+        } finally {\n+            buffer.release();\n+        }\n+    }\n+\n+    private static native void fremovexattr0(int fd, long nameAddress, int options) throws UnixException;\n+\n+    \/**\n+     * ssize_t flistxattr(int fd, char *namebuf, size_t size, int options);\n+     *\/\n+    static int flistxattr(int fd, long nameBufAddress, int size) throws UnixException {\n+        return flistxattr0(fd, nameBufAddress, size, 0);\n+    }\n+\n+    private static native int flistxattr0(int fd, long nameBufAddress, int size, int options) throws UnixException;\n+\n","filename":"src\/java.base\/macosx\/classes\/sun\/nio\/fs\/BsdNativeDispatcher.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-import static sun.nio.fs.LinuxNativeDispatcher.*;\n+import static sun.nio.fs.BsdNativeDispatcher.*;\n@@ -38,1 +38,1 @@\n- * Linux implementation of UserDefinedFileAttributeView using extended attributes.\n+ * BSD implementation of UserDefinedFileAttributeView using extended attributes.\n@@ -41,1 +41,1 @@\n-class LinuxUserDefinedFileAttributeView\n+class BsdUserDefinedFileAttributeView\n@@ -49,2 +49,3 @@\n-    \/\/ maximum bytes in extended attribute name (includes namespace)\n-    private static final int XATTR_NAME_MAX = 255;\n+    \/\/ maximum bytes in extended attribute name (includes namespace),\n+    \/\/ see XATTR_MAXNAMELEN in https:\/\/github.com\/apple\/darwin-xnu\/blob\/master\/bsd\/sys\/xattr.h\n+    private static final int XATTR_NAME_MAX = 127;\n@@ -90,1 +91,1 @@\n-    LinuxUserDefinedFileAttributeView(UnixPath file, boolean followLinks) {\n+    BsdUserDefinedFileAttributeView(UnixPath file, boolean followLinks) {\n","filename":"src\/java.base\/macosx\/classes\/sun\/nio\/fs\/BsdUserDefinedFileAttributeView.java","additions":7,"deletions":6,"binary":false,"changes":13,"previous_filename":"src\/java.base\/linux\/classes\/sun\/nio\/fs\/LinuxUserDefinedFileAttributeView.java","status":"copied"},{"patch":"@@ -33,0 +33,1 @@\n+#include <sys\/xattr.h>\n@@ -227,0 +228,49 @@\n+\n+JNIEXPORT jint JNICALL\n+Java_sun_nio_fs_BsdNativeDispatcher_fgetxattr0(JNIEnv* env, jclass clazz,\n+    jint fd, jlong nameAddress, jlong valueAddress, jint valueLen, jlong position, jint options)\n+{\n+    const char* name = jlong_to_ptr(nameAddress);\n+    void* value = jlong_to_ptr(valueAddress);\n+\n+    ssize_t res = fgetxattr(fd, name, value, valueLen, (u_int32_t)position, options);\n+    if (res == (ssize_t)-1)\n+        throwUnixException(env, errno);\n+    return (jint)res;\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_sun_nio_fs_BsdNativeDispatcher_fsetxattr0(JNIEnv* env, jclass clazz,\n+    jint fd, jlong nameAddress, jlong valueAddress, jint valueLen, jlong position, jint options)\n+{\n+    const char* name = jlong_to_ptr(nameAddress);\n+    void* value = jlong_to_ptr(valueAddress);\n+\n+    int res = fsetxattr(fd, name, value, valueLen, (u_int32_t)position, options);\n+    if (res == -1)\n+        throwUnixException(env, errno);\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_sun_nio_fs_BsdNativeDispatcher_fremovexattr0(JNIEnv* env, jclass clazz,\n+    jint fd, jlong nameAddress, jint options)\n+{\n+    const char* name = jlong_to_ptr(nameAddress);\n+\n+    int res = fremovexattr(fd, name, options);\n+    if (res == -1)\n+        throwUnixException(env, errno);\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_sun_nio_fs_BsdNativeDispatcher_flistxattr0(JNIEnv* env, jclass clazz,\n+    jint fd, jlong nameBufAddress, jint size, jint options)\n+{\n+    char* nameBuf = jlong_to_ptr(nameBufAddress);\n+\n+    ssize_t res = flistxattr(fd, nameBuf, (size_t)size, options);\n+\n+    if (res == (ssize_t)-1)\n+        throwUnixException(env, errno);\n+    return (jint)res;\n+}\n","filename":"src\/java.base\/macosx\/native\/libnio\/fs\/BsdNativeDispatcher.c","additions":50,"deletions":0,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -120,0 +120,5 @@\n+#ifdef ENOATTR\n+    \/\/ BSD uses ENOATTR instead of ENODATA during xattr calls\n+    static final int PREFIX_ENOATTR = ENOATTR;\n+#endif\n+\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/UnixConstants.java.template","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"}]}