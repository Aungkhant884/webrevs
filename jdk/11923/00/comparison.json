{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Red Hat, Inc. All rights reserved.\n+ * Copyright (c) 2017, 2023, Red Hat, Inc. All rights reserved.\n@@ -112,3 +112,2 @@\n-  virtual bool supports_object_pinning() const           { return true; }\n-  virtual oop pin_object(JavaThread* thread, oop obj)    { return obj; }\n-  virtual void unpin_object(JavaThread* thread, oop obj) { }\n+  void pin_object(JavaThread* thread, oop obj) override { }\n+  void unpin_object(JavaThread* thread, oop obj) override { }\n","filename":"src\/hotspot\/share\/gc\/epsilon\/epsilonHeap.hpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -82,1 +82,1 @@\n-#include \"gc\/shared\/gcLocker.hpp\"\n+#include \"gc\/shared\/gcLocker.inline.hpp\"\n@@ -2407,0 +2407,8 @@\n+void G1CollectedHeap::pin_object(JavaThread* thread, oop obj) {\n+  GCLocker::lock_critical(thread);\n+}\n+\n+void G1CollectedHeap::unpin_object(JavaThread* thread, oop obj) {\n+  GCLocker::unlock_critical(thread);\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -1315,0 +1315,3 @@\n+  void pin_object(JavaThread* thread, oop obj) override;\n+  void unpin_object(JavaThread* thread, oop obj) override;\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n-#include \"gc\/shared\/gcLocker.hpp\"\n+#include \"gc\/shared\/gcLocker.inline.hpp\"\n@@ -863,0 +863,8 @@\n+\n+void ParallelScavengeHeap::pin_object(JavaThread* thread, oop obj) {\n+  GCLocker::lock_critical(thread);\n+}\n+\n+void ParallelScavengeHeap::unpin_object(JavaThread* thread, oop obj) {\n+  GCLocker::unlock_critical(thread);\n+}\n","filename":"src\/hotspot\/share\/gc\/parallel\/parallelScavengeHeap.cpp","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -276,0 +276,3 @@\n+\n+  void pin_object(JavaThread* thread, oop obj) override;\n+  void unpin_object(JavaThread* thread, oop obj) override;\n","filename":"src\/hotspot\/share\/gc\/parallel\/parallelScavengeHeap.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+#include \"gc\/shared\/gcLocker.inline.hpp\"\n@@ -126,0 +127,8 @@\n+\n+void SerialHeap::pin_object(JavaThread* thread, oop obj) {\n+  GCLocker::lock_critical(thread);\n+}\n+\n+void SerialHeap::unpin_object(JavaThread* thread, oop obj) {\n+  GCLocker::unlock_critical(thread);\n+}\n","filename":"src\/hotspot\/share\/gc\/serial\/serialHeap.cpp","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -111,0 +111,3 @@\n+\n+  void pin_object(JavaThread* thread, oop obj) override;\n+  void unpin_object(JavaThread* thread, oop obj) override;\n","filename":"src\/hotspot\/share\/gc\/serial\/serialHeap.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -638,13 +638,0 @@\n-bool CollectedHeap::supports_object_pinning() const {\n-  return false;\n-}\n-\n-oop CollectedHeap::pin_object(JavaThread* thread, oop obj) {\n-  ShouldNotReachHere();\n-  return NULL;\n-}\n-\n-void CollectedHeap::unpin_object(JavaThread* thread, oop obj) {\n-  ShouldNotReachHere();\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.cpp","additions":1,"deletions":14,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -504,5 +504,5 @@\n-  \/\/ and Release*Critical() family of functions. If supported, the GC\n-  \/\/ must guarantee that pinned objects never move.\n-  virtual bool supports_object_pinning() const;\n-  virtual oop pin_object(JavaThread* thread, oop obj);\n-  virtual void unpin_object(JavaThread* thread, oop obj);\n+  \/\/ and Release*Critical() family of functions. The GC must guarantee\n+  \/\/ that pinned objects never move and don't get reclaimed as garbage.\n+  \/\/ These functions are potentially safepointing.\n+  virtual void pin_object(JavaThread* thread, oop obj) = 0;\n+  virtual void unpin_object(JavaThread* thread, oop obj) = 0;\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.hpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,0 +2,1 @@\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -1919,1 +1920,1 @@\n-oop ShenandoahHeap::pin_object(JavaThread* thr, oop o) {\n+void ShenandoahHeap::pin_object(JavaThread* thr, oop o) {\n@@ -1921,1 +1922,0 @@\n-  return o;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,0 +2,1 @@\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -511,4 +512,2 @@\n-  bool supports_object_pinning() const { return true; }\n-\n-  oop pin_object(JavaThread* thread, oop obj);\n-  void unpin_object(JavaThread* thread, oop obj);\n+  void pin_object(JavaThread* thread, oop obj) override;\n+  void unpin_object(JavaThread* thread, oop obj) override;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.hpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+#include \"gc\/shared\/gcLocker.inline.hpp\"\n@@ -292,0 +293,8 @@\n+void ZCollectedHeap::pin_object(JavaThread* thread, oop obj) {\n+  GCLocker::lock_critical(thread);\n+}\n+\n+void ZCollectedHeap::unpin_object(JavaThread* thread, oop obj) {\n+  GCLocker::unlock_critical(thread);\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zCollectedHeap.cpp","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -116,0 +116,3 @@\n+  void pin_object(JavaThread* thread, oop obj) override;\n+  void unpin_object(JavaThread* thread, oop obj) override;\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zCollectedHeap.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -2796,19 +2796,0 @@\n-static oop lock_gc_or_pin_object(JavaThread* thread, jobject obj) {\n-  if (Universe::heap()->supports_object_pinning()) {\n-    const oop o = JNIHandles::resolve_non_null(obj);\n-    return Universe::heap()->pin_object(thread, o);\n-  } else {\n-    GCLocker::lock_critical(thread);\n-    return JNIHandles::resolve_non_null(obj);\n-  }\n-}\n-\n-static void unlock_gc_or_unpin_object(JavaThread* thread, jobject obj) {\n-  if (Universe::heap()->supports_object_pinning()) {\n-    const oop o = JNIHandles::resolve_non_null(obj);\n-    return Universe::heap()->unpin_object(thread, o);\n-  } else {\n-    GCLocker::unlock_critical(thread);\n-  }\n-}\n-\n@@ -2817,0 +2798,8 @@\n+  Handle a(thread, JNIHandles::resolve_non_null(array));\n+  assert(a->is_typeArray(), \"just checking\");\n+\n+  \/\/ Pin object\n+  Universe::heap()->pin_object(thread, a());\n+\n+  BasicType type = TypeArrayKlass::cast(a->klass())->element_type();\n+  void* ret = arrayOop(a())->base(type);\n@@ -2820,4 +2809,0 @@\n-  oop a = lock_gc_or_pin_object(thread, array);\n-  assert(a->is_typeArray(), \"Primitive array only\");\n-  BasicType type = TypeArrayKlass::cast(a->klass())->element_type();\n-  void* ret = arrayOop(a)->base(type);\n@@ -2831,1 +2816,2 @@\n-  unlock_gc_or_unpin_object(thread, array);\n+  \/\/ Unpin object\n+  Universe::heap()->unpin_object(thread, JNIHandles::resolve_non_null(array));\n@@ -2836,28 +2822,0 @@\n-static typeArrayOop lock_gc_or_pin_string_value(JavaThread* thread, oop str) {\n-  if (Universe::heap()->supports_object_pinning()) {\n-    \/\/ Forbid deduplication before obtaining the value array, to prevent\n-    \/\/ deduplication from replacing the value array while setting up or in\n-    \/\/ the critical section.  That would lead to the release operation\n-    \/\/ unpinning the wrong object.\n-    if (StringDedup::is_enabled()) {\n-      NoSafepointVerifier nsv;\n-      StringDedup::forbid_deduplication(str);\n-    }\n-    typeArrayOop s_value = java_lang_String::value(str);\n-    return (typeArrayOop) Universe::heap()->pin_object(thread, s_value);\n-  } else {\n-    Handle h(thread, str);      \/\/ Handlize across potential safepoint.\n-    GCLocker::lock_critical(thread);\n-    return java_lang_String::value(h());\n-  }\n-}\n-\n-static void unlock_gc_or_unpin_string_value(JavaThread* thread, oop str) {\n-  if (Universe::heap()->supports_object_pinning()) {\n-    typeArrayOop s_value = java_lang_String::value(str);\n-    Universe::heap()->unpin_object(thread, s_value);\n-  } else {\n-    GCLocker::unlock_critical(thread);\n-  }\n-}\n-\n@@ -2869,1 +2827,5 @@\n-    typeArrayOop s_value = lock_gc_or_pin_string_value(thread, s);\n+    typeArrayHandle s_value(thread, java_lang_String::value(s));\n+\n+    \/\/ Pin value array\n+    Universe::heap()->pin_object(thread, s_value());\n+\n@@ -2895,0 +2857,1 @@\n+\n@@ -2900,2 +2863,6 @@\n-    \/\/ For non-latin1 string, drop the associated gc-locker\/pin.\n-    unlock_gc_or_unpin_string_value(thread, s);\n+    \/\/ StringDedup can have replaced the value array, so don't fetch the array from 's'.\n+    \/\/ Instead, we calculate the address based on the jchar array exposed with GetStringCritical.\n+    oop value = cast_to_oop((address)chars - arrayOopDesc::base_offset_in_bytes(T_CHAR));\n+\n+    \/\/ Unpin value array\n+    Universe::heap()->unpin_object(thread, value);\n","filename":"src\/hotspot\/share\/prims\/jni.cpp","additions":23,"deletions":56,"binary":false,"changes":79,"status":"modified"}]}