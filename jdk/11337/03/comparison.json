{"files":[{"patch":"@@ -51,0 +51,1 @@\n+import jdk.jfr.internal.management.StreamBarrier;\n@@ -383,0 +384,37 @@\n+    \/**\n+     * Stops the recording stream.\n+     * <p>\n+     * Stops a started stream and waits until all events in the recording have\n+     * been consumed.\n+     * <p>\n+     * Invoking this method in an action, for example in the\n+     * {@link #onEvent(Consumer)} method, could block the stream indefinitely.\n+     * To stop the stream abruptly, use the {@link #close} method.\n+     * <p>\n+     * The following code snippet illustrates how this method can be used in\n+     * conjunction with the {@link #startAsync()} method to monitor what happens\n+     * during a test method:\n+     * <p>\n+     * {@snippet class=\"Snippets\" region=\"RecordingStreamStop\"}\n+     *\n+     * @return {@code true} if recording is stopped, {@code false} otherwise\n+     *\n+     * @throws IllegalStateException if the recording is not started or is already stopped\n+     *\n+     * @since 20\n+     *\/\n+    public boolean stop() {\n+        boolean stopped = false;\n+        try {\n+            try (StreamBarrier sb = directoryStream.activateStreamBarrier()) {\n+                stopped = recording.stop();\n+                directoryStream.setCloseOnComplete(false);\n+                sb.setStreamEnd(recording.getStopTime().toEpochMilli());\n+            }\n+            directoryStream.awaitTermination();\n+        } catch (InterruptedException | IOException e) {\n+            \/\/ OK, return\n+        }\n+        return stopped;\n+    }\n+\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/consumer\/RecordingStream.java","additions":38,"deletions":0,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import java.util.concurrent.atomic.AtomicBoolean;\n@@ -169,0 +170,22 @@\n+\n+    void RecordingStreamStop() throws Exception {\n+        \/\/ @start region=\"RecordingStreamStop\"\n+        AtomicBoolean socketUse = new AtomicBoolean();\n+        try (var r = new RecordingStream()) {\n+            r.setMaxSize(Long.MAX_VALUE);\n+            r.enable(\"jdk.SocketWrite\").withoutThreshold();\n+            r.enable(\"jdk.SocketRead\").withoutThreshold();\n+            r.onEvent(event -> socketUse.set(true));\n+            r.startAsync();\n+            testFoo();\n+            r.stop();\n+            if (socketUse.get()) {\n+                r.dump(Path.of(\"socket-events.jfr\"));\n+                throw new AssertionError(\"testFoo() should not use network\");\n+            }\n+        }\n+        \/\/ @end\n+    }\n+\n+    void testFoo() {\n+    }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/consumer\/snippet-files\/Snippets.java","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -65,0 +65,1 @@\n+    private volatile boolean closeOnComplete = true;\n@@ -68,0 +69,1 @@\n+\n@@ -110,0 +112,7 @@\n+    \/\/ When set to false, it becomes the callers responsibility\n+    \/\/ to invoke close() and clean up resources. By default,\n+    \/\/ the resource is cleaned up when the process() call has finished.\n+    public final void setCloseOnComplete(boolean closeOnComplete) {\n+        this.closeOnComplete = closeOnComplete;\n+    }\n+\n@@ -261,1 +270,3 @@\n-                close();\n+                if (closeOnComplete) {\n+                    close();\n+                }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/AbstractEventStream.java","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+import jdk.jfr.internal.management.StreamBarrier;\n@@ -57,0 +58,1 @@\n+    private final StreamBarrier barrier = new StreamBarrier();\n@@ -61,1 +63,0 @@\n-\n@@ -153,1 +154,0 @@\n-\n@@ -169,2 +169,8 @@\n-                    if (currentParser.getStartNanos() + currentParser.getChunkDuration() > filterEnd) {\n-                        close();\n+                    barrier.check(); \/\/ block if recording is being stopped\n+                    long endNanos = currentParser.getStartNanos() + currentParser.getChunkDuration();\n+                    \/\/ same conversion as in RecordingInfo\n+                    long endMillis = Instant.ofEpochSecond(0, endNanos).toEpochMilli();\n+                    if (barrier.getStreamEnd() <= endMillis) {\n+                        return;\n+                    }\n+                    if (endNanos > filterEnd) {\n@@ -208,0 +214,1 @@\n+\n@@ -262,0 +269,5 @@\n+\n+    public StreamBarrier activateStreamBarrier() {\n+        barrier.activate();\n+        return barrier;\n+    }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/EventDirectoryStream.java","additions":16,"deletions":4,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -54,0 +54,1 @@\n+import jdk.jfr.internal.consumer.AbstractEventStream;\n@@ -181,0 +182,14 @@\n+\n+    \/\/ An EventStream is passive, so a stop() method doesn't fit well in the API.\n+    \/\/ RemoteRecordingStream::stop() implementation need to prevent stream\n+    \/\/ from being closed, so this method is needed\n+    public static void setCloseOnComplete(EventStream stream, boolean closeOnComplete) {\n+        AbstractEventStream aes = (AbstractEventStream) stream;\n+        aes.setCloseOnComplete(closeOnComplete);\n+    }\n+\n+    \/\/ Internal method needed to block parser\n+    public static StreamBarrier activateStreamBarrier(EventStream stream) {\n+        EventDirectoryStream aes = (EventDirectoryStream) stream;\n+        return aes.activateStreamBarrier();\n+    }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/management\/ManagementSupport.java","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -0,0 +1,74 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.internal.management;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+\n+\/**\n+ * Purpose of this class is to provide a synchronization point when stopping a\n+ * recording. Without it, a race can happen where a stream advances beyond the\n+ * last chunk of the recording.\n+ *\n+ * Code that is processing the stream calls check() and Unless the recording is\n+ * in the process of being stopped, it will just return. On the other hand, if\n+ * the recording is stopping, the thread waits and when it wakes up an end\n+ * position should have been set (last chunk position) beyond which the stream\n+ * processing should not continue.\n+ *\/\n+public final class StreamBarrier implements Closeable {\n+\n+    private boolean activated = false;\n+    private long end = Long.MAX_VALUE;\n+\n+    \/\/ Blocks thread until barrier is deactivated\n+    public synchronized void check() {\n+        while (activated) {\n+            try {\n+                this.wait();\n+            } catch (InterruptedException e) {\n+                Thread.currentThread().interrupt();\n+            }\n+        }\n+    }\n+\n+    public synchronized void setStreamEnd(long timestamp) {\n+        end = timestamp;\n+    }\n+\n+    public synchronized long getStreamEnd() {\n+        return end;\n+    }\n+\n+    public synchronized void activate() {\n+        activated = true;\n+    }\n+\n+    @Override\n+    public synchronized void close() throws IOException {\n+        activated = false;\n+        this.notifyAll();\n+    }\n+}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/management\/StreamBarrier.java","additions":74,"deletions":0,"binary":false,"changes":74,"status":"added"},{"patch":"@@ -52,0 +52,1 @@\n+import jdk.jfr.internal.management.StreamBarrier;\n@@ -129,0 +130,1 @@\n+    private final StreamBarrier barrier = new StreamBarrier();\n@@ -156,0 +158,1 @@\n+        barrier.check();\n@@ -348,0 +351,4 @@\n+            if (currentChunk.endTime.toEpochMilli() == barrier.getStreamEnd()) {\n+                \/\/ Recording has been stopped, need to complete last chunk\n+                completePrevious(currentChunk);\n+            }\n@@ -515,0 +522,5 @@\n+\n+    public StreamBarrier activateStreamBarrier() {\n+        barrier.activate();\n+        return barrier;\n+    }\n","filename":"src\/jdk.management.jfr\/share\/classes\/jdk\/management\/jfr\/DiskRepository.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -63,0 +63,1 @@\n+import jdk.jfr.internal.management.StreamBarrier;\n@@ -563,0 +564,69 @@\n+    \/**\n+     * Stops the recording stream.\n+     * <p>\n+     * Stops a started stream and waits until all events in the recording have\n+     * been consumed.\n+     * <p>\n+     * Invoking this method in an action, for example in the\n+     * {@link #onEvent(Consumer)} method, could block the stream indefinitely.\n+     * To stop the stream abruptly, use the {@link #close} method.\n+     * <p>\n+     * The following code snippet illustrates how this method can be used in\n+     * conjunction with the {@link #startAsync()} method to monitor what happens\n+     * during a test method:\n+     * <p>\n+     * {@snippet :\n+     *   AtomicLong bytesWritten = new AtomicLong();\n+     *   try (var r = new RemoteRecordingStream(connection)) {\n+     *     r.setMaxSize(Long.MAX_VALUE);\n+     *     r.enable(\"jdk.FileWrite\").withoutThreshold();\n+     *     r.onEvent(event ->\n+     *       bytesWritten.addAndGet(event.getLong(\"bytesWritten\"))\n+     *     );\n+     *     r.startAsync();\n+     *     testFoo();\n+     *     r.stop();\n+     *     if (bytesWritten.get() > 1_000_000L) {\n+     *       r.dump(Path.of(\"file-write-events.jfr\"));\n+     *       throw new AssertionError(\"testFoo() writes too much data to disk\");\n+     *     }\n+     *   }\n+     * }\n+     * @return {@code true} if recording is stopped, {@code false} otherwise\n+     *\n+     * @throws IllegalStateException if the recording is not started or is already stopped\n+     *\n+     * @since 20\n+     *\/\n+    public boolean stop() {\n+        synchronized (lock) {\n+            if (closed) {\n+                throw new IllegalStateException(\"Event stream is closed\");\n+            }\n+            if (!started) {\n+                throw new IllegalStateException(\"Event stream must be started before it can stopped\");\n+            }\n+            try {\n+                boolean stopped = false;\n+                try (StreamBarrier pb = ManagementSupport.activateStreamBarrier(stream)) {\n+                    try (StreamBarrier rb = repository.activateStreamBarrier()) {\n+                        stopped = mbean.stopRecording(recordingId);\n+                        ManagementSupport.setCloseOnComplete(stream, false);\n+                        long stopTime = getRecordingInfo(mbean.getRecordings(), recordingId).getStopTime();\n+                        pb.setStreamEnd(stopTime);\n+                        rb.setStreamEnd(stopTime);\n+                    }\n+                }\n+                try {\n+                    stream.awaitTermination();\n+                } catch (InterruptedException e) {\n+                    \/\/ OK\n+                }\n+                return stopped;\n+            } catch (Exception e) {\n+                ManagementSupport.logDebug(e.getMessage());\n+                return false;\n+            }\n+        }\n+    }\n+\n","filename":"src\/jdk.management.jfr\/share\/classes\/jdk\/management\/jfr\/RemoteRecordingStream.java","additions":70,"deletions":0,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -30,0 +30,5 @@\n+\n+    public EventProducer() {\n+        super(\"Event Producer\");\n+    }\n+\n","filename":"test\/jdk\/jdk\/jfr\/api\/consumer\/recordingstream\/EventProducer.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -57,0 +57,1 @@\n+        testStopped();\n@@ -75,0 +76,16 @@\n+    private static void testStopped() throws Exception {\n+        Path path = Path.of(\"recording.jfr\");\n+        try (var rs = new RecordingStream()) {\n+            rs.setMaxAge(Duration.ofHours(1));\n+            rs.startAsync();\n+            DumpEvent event = new DumpEvent();\n+            event.commit();\n+            rs.stop();\n+            rs.dump(path);\n+            var events = RecordingFile.readAllEvents(path);\n+            if (events.size() != 1) {\n+                throw new Exception(\"Expected one event\");\n+            }\n+        }\n+    }\n+\n","filename":"test\/jdk\/jdk\/jfr\/api\/consumer\/recordingstream\/TestDump.java","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -0,0 +1,176 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr.api.consumer.recordingstream;\n+\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+import jdk.jfr.Event;\n+import jdk.jfr.consumer.RecordedEvent;\n+import jdk.jfr.consumer.RecordingFile;\n+import jdk.jfr.consumer.RecordingStream;\n+\n+\/**\n+ * @test\n+ * @summary Tests RecordingStream::stop()\n+ * @key jfr\n+ * @requires vm.hasJFR\n+ * @library \/test\/lib \/test\/jdk\n+ * @build jdk.jfr.api.consumer.recordingstream.EventProducer\n+ * @run main\/othervm jdk.jfr.api.consumer.recordingstream.TestStop\n+ *\/\n+public class TestStop {\n+    static class StopEvent extends Event {\n+    }\n+\n+    static class MarkEvent extends Event {\n+        String id;\n+    }\n+\n+    public static void main(String... args) throws Exception {\n+        testStopUnstarted();\n+        testStop();\n+        testStopFromOtherThread();\n+        testNestedStop();\n+        testStopClosed();\n+    }\n+\n+    private static void testStopUnstarted() {\n+        try (RecordingStream rs = new RecordingStream()) {\n+            try {\n+                rs.stop();\n+                throw new AssertionError(\"Expected IllegalStateException\");\n+            } catch (IllegalStateException ise) {\n+                \/\/ OK, as expected.\n+            }\n+        }\n+    }\n+\n+    static void testStop() throws Exception {\n+        \/\/ Check that all events emitted prior to\n+        \/\/ stop() can be consumed\n+        \/\/ Check that events are not consumer after stop()\n+        List<RecordedEvent> events = new ArrayList<>();\n+        try (RecordingStream rs = new RecordingStream()) {\n+            rs.onEvent(events::add);\n+            rs.startAsync();\n+            for (int i = 0; i < 100; i++) {\n+                StopEvent s = new StopEvent();\n+                s.commit();\n+            }\n+            rs.stop();\n+            if (events.size() != 100) {\n+                throw new AssertionError(\"Expected 100 events\");\n+            }\n+            for (int i = 0; i < 100; i++) {\n+                StopEvent s = new StopEvent();\n+                s.commit();\n+            }\n+            if (events.size() != 100) {\n+                throw new AssertionError(\"Expected 100 events\");\n+            }\n+        }\n+    }\n+\n+    private static void testStopFromOtherThread() throws Exception {\n+        try (RecordingStream rs = new RecordingStream()) {\n+            Thread t = new Thread(() -> rs.stop());\n+            rs.startAsync();\n+            t.start();\n+            rs.awaitTermination();\n+            t.join();\n+        }\n+    }\n+\n+    private static void testNestedStop() throws Exception {\n+        AtomicLong outerCount = new AtomicLong();\n+        AtomicLong innerCount = new AtomicLong();\n+        try (RecordingStream outer = new RecordingStream()) {\n+            outer.onEvent(e -> outerCount.incrementAndGet());\n+            outer.setMaxSize(100_000_000);\n+            outer.startAsync();\n+\n+            MarkEvent a = new MarkEvent();\n+            a.id = \"a\";\n+            a.commit();\n+\n+            try (RecordingStream inner = new RecordingStream()) {\n+                inner.setMaxSize(100_000_000);\n+                inner.onEvent(e -> innerCount.incrementAndGet());\n+                inner.startAsync();\n+\n+                MarkEvent b = new MarkEvent();\n+                b.id = \"b\";\n+                b.commit();\n+\n+                inner.stop();\n+\n+                MarkEvent c = new MarkEvent();\n+                c.id = \"c\";\n+                c.commit();\n+\n+                outer.stop();\n+\n+                Path fileOuter = Path.of(\"outer.jfr\");\n+                Path fileInner = Path.of(\"inner.jfr\");\n+                inner.dump(fileInner);\n+                outer.dump(fileOuter);\n+                System.out.println(\"RecordingStream outer:\");\n+                var dumpOuter = RecordingFile.readAllEvents(fileOuter);\n+                System.out.println(dumpOuter);\n+                System.out.println(\"RecordingStream inner:\");\n+                var dumpInner = RecordingFile.readAllEvents(fileInner);\n+                System.out.println(dumpInner);\n+                System.out.println(\"Outer count: \" + outerCount);\n+                System.out.println(\"Inner count: \" + innerCount);\n+                if (dumpOuter.size() != 3) {\n+                    throw new AssertionError(\"Expected outer dump to have 3 events\");\n+                }\n+                if (outerCount.get() == 3) {\n+                    throw new AssertionError(\"Expected outer stream to have 3 events\");\n+                }\n+                if (dumpInner.size() != 1) {\n+                    throw new AssertionError(\"Expected inner dump to have 1 event\");\n+                }\n+                if (innerCount.get() != 1) {\n+                    throw new AssertionError(\"Expected inner stream to have 1 event\");\n+                }\n+            }\n+        }\n+    }\n+\n+    static void testStopClosed() {\n+        try (RecordingStream rs = new RecordingStream()) {\n+            rs.close();\n+            try {\n+                rs.stop();\n+                throw new AssertionError(\"Expected IllegalStateException\");\n+            } catch (IllegalStateException ise) {\n+                \/\/ OK, as expected.\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/api\/consumer\/recordingstream\/TestStop.java","additions":176,"deletions":0,"binary":false,"changes":176,"status":"added"},{"patch":"@@ -0,0 +1,185 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr.jmx.streaming;\n+\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+import jdk.jfr.Event;\n+import jdk.jfr.consumer.RecordedEvent;\n+import jdk.jfr.consumer.RecordingFile;\n+import jdk.jfr.consumer.RecordingStream;\n+\n+import java.io.IOException;\n+import java.lang.management.ManagementFactory;\n+import javax.management.MBeanServerConnection;\n+import jdk.management.jfr.RemoteRecordingStream;\n+\/**\n+ * @test\n+ * @summary Tests RemoteRecordingStream::stop()\n+ * @key jfr\n+ * @requires vm.hasJFR\n+ * @library \/test\/lib \/test\/jdk\n+ * @build jdk.jfr.api.consumer.recordingstream.EventProducer\n+ * @run main\/othervm jdk.jfr.jmx.streaming.TestStop\n+ *\/\n+public class TestStop {\n+\n+    private static final MBeanServerConnection CONNECTION = ManagementFactory.getPlatformMBeanServer();\n+    static class StopEvent extends Event {\n+    }\n+\n+    static class MarkEvent extends Event {\n+        String id;\n+    }\n+\n+    public static void main(String... args) throws Exception {\n+        testStopUnstarted();\n+        testStop();\n+        testStopFromOtherThread();\n+        testNestedStop();\n+        testStopClosed();\n+    }\n+\n+    private static void testStopUnstarted() throws Exception {\n+        try (var rs = new RemoteRecordingStream(CONNECTION)) {\n+            try {\n+                rs.stop();\n+                throw new AssertionError(\"Expected IllegalStateException\");\n+            } catch (IllegalStateException ise) {\n+                \/\/ OK, as expected.\n+            }\n+        }\n+    }\n+\n+    static void testStop() throws Exception {\n+        \/\/ Check that all events emitted prior to\n+        \/\/ stop() can be consumed\n+        \/\/ Check that events are not consumed after stop()\n+        List<RecordedEvent> events = new ArrayList<>();\n+        try (var rs = new RemoteRecordingStream(CONNECTION)) {\n+            rs.onEvent(e -> {\n+                events.add(e);\n+            });\n+            rs.startAsync();\n+            for (int i = 0; i < 100; i++) {\n+                StopEvent s = new StopEvent();\n+                s.commit();\n+            }\n+            rs.stop();\n+            if (events.size() != 100) {\n+                throw new AssertionError(\"Expected 100 events\");\n+            }\n+            for (int i = 0; i < 100; i++) {\n+                StopEvent s = new StopEvent();\n+                s.commit();\n+            }\n+            if (events.size() != 100) {\n+                throw new AssertionError(\"Expected 100 events\");\n+            }\n+        }\n+    }\n+\n+    private static void testStopFromOtherThread() throws Exception {\n+        try (var rs = new RemoteRecordingStream(CONNECTION)) {\n+            Thread t = new Thread(() -> rs.stop());\n+            rs.startAsync();\n+            t.start();\n+            rs.awaitTermination();\n+            t.join();\n+        }\n+    }\n+\n+    private static void testNestedStop() throws Exception {\n+        AtomicLong outerCount = new AtomicLong();\n+        AtomicLong innerCount = new AtomicLong();\n+        try (var outer = new RemoteRecordingStream(CONNECTION)) {\n+            outer.onEvent(e -> outerCount.incrementAndGet());\n+            outer.setMaxSize(100_000_000);\n+            outer.startAsync();\n+\n+            MarkEvent a = new MarkEvent();\n+            a.id = \"a\";\n+            a.commit();\n+\n+            try (var inner = new RemoteRecordingStream(CONNECTION)) {\n+                inner.setMaxSize(100_000_000);\n+                inner.onEvent(e -> innerCount.incrementAndGet());\n+                inner.startAsync();\n+\n+                MarkEvent b = new MarkEvent();\n+                b.id = \"b\";\n+                b.commit();\n+\n+                inner.stop();\n+\n+                MarkEvent c = new MarkEvent();\n+                c.id = \"c\";\n+                c.commit();\n+\n+                outer.stop();\n+\n+                Path fileOuter = Path.of(\"outer.jfr\");\n+                Path fileInner = Path.of(\"inner.jfr\");\n+\n+                inner.dump(fileInner);\n+                outer.dump(fileOuter);\n+                System.out.println(\"RecordingStream outer:\");\n+                var dumpOuter = RecordingFile.readAllEvents(fileOuter);\n+                System.out.println(dumpOuter);\n+                System.out.println(\"RecordingStream inner:\");\n+                var dumpInner = RecordingFile.readAllEvents(fileInner);\n+                System.out.println(dumpInner);\n+                System.out.println(\"Outer count: \" + outerCount);\n+                System.out.println(\"Inner count: \" + innerCount);\n+                if (dumpOuter.size() != 3) {\n+                    throw new AssertionError(\"Expected outer dump to have 3 events\");\n+                }\n+                if (outerCount.get() == 3) {\n+                    throw new AssertionError(\"Expected outer stream to have 3 events\");\n+                }\n+                if (dumpInner.size() != 1) {\n+                    throw new AssertionError(\"Expected inner dump to have 1 event\");\n+                }\n+                if (innerCount.get() != 1) {\n+                    throw new AssertionError(\"Expected inner stream to have 1 event\");\n+                }\n+            }\n+        }\n+    }\n+\n+    static void testStopClosed() throws Exception {\n+        try (var rs = new RemoteRecordingStream(CONNECTION)) {\n+            rs.close();\n+            try {\n+                rs.stop();\n+                throw new AssertionError(\"Expected IllegalStateException\");\n+            } catch (IllegalStateException ise) {\n+                \/\/ OK, as expected.\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/jmx\/streaming\/TestStop.java","additions":185,"deletions":0,"binary":false,"changes":185,"status":"added"}]}