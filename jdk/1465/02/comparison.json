{"files":[{"patch":"@@ -107,2 +107,21 @@\n-    \/*\n-     * Private constructor which uses a byte array to construct the new UUID.\n+    \/**\n+     * Constructs a new {@code UUID} from the given {@code bytes}.\n+     *\n+     * <p>The {@link #version()} is set to the given {@code version} and the\n+     * {@link #variant()} is <strong>always<\/strong> set to RFC&nbsp;4122.\n+     *\n+     * @implNote\n+     * This constructor is <em>private<\/em> because it performs no validation\n+     * on {@code bytes} or {@code version} to be extensible for future needs of\n+     * the {@code UUID} implementation. {@code bytes} is expected to contain at\n+     * least 16 bytes and any additional data will silently be ignored, this is\n+     * for example required during the creation of version 5 UUIDs where the\n+     * SHA-1 digest is 20 bytes long and truncated.\n+     *\n+     * @param  bytes\n+     *         The bytes of this {@code UUID}\n+     *\n+     * @param  version\n+     *         The {@linkplain #version() version} of this {@code UUID}\n+     *\n+     * @since  16\n@@ -110,8 +129,9 @@\n-    private UUID(byte[] data) {\n-        long msb = 0;\n-        long lsb = 0;\n-        assert data.length == 16 : \"data must be 16 bytes in length\";\n-        for (int i=0; i<8; i++)\n-            msb = (msb << 8) | (data[i] & 0xff);\n-        for (int i=8; i<16; i++)\n-            lsb = (lsb << 8) | (data[i] & 0xff);\n+    private UUID(final byte[] bytes, final int version) {\n+        long msb = (long) (bytes[0]  & 0xFF) << 56;\n+        msb     |= (long) (bytes[1]  & 0xFF) << 48;\n+        msb     |= (long) (bytes[2]  & 0xFF) << 40;\n+        msb     |= (long) (bytes[3]  & 0xFF) << 32;\n+        msb     |= (long) (bytes[4]  & 0xFF) << 24;\n+        msb     |= (long) (bytes[5]  & 0xFF) << 16;\n+        msb     |= (long) (bytes[6]  & 0x0F | version) << 8;\n+        msb     |= (long)  bytes[7]  & 0xFF;\n@@ -119,0 +139,9 @@\n+\n+        long lsb = (long) (bytes[8]  & 0x3F | 0x80) << 56;\n+        lsb     |= (long) (bytes[9]  & 0xFF) << 48;\n+        lsb     |= (long) (bytes[10] & 0xFF) << 40;\n+        lsb     |= (long) (bytes[11] & 0xFF) << 32;\n+        lsb     |= (long) (bytes[12] & 0xFF) << 24;\n+        lsb     |= (long) (bytes[13] & 0xFF) << 16;\n+        lsb     |= (long) (bytes[14] & 0xFF) << 8;\n+        lsb     |= (long)  bytes[15] & 0xFF;\n@@ -123,4 +152,10 @@\n-     * Constructs a new {@code UUID} using the specified data.  {@code\n-     * mostSigBits} is used for the most significant 64 bits of the {@code\n-     * UUID} and {@code leastSigBits} becomes the least significant 64 bits of\n-     * the {@code UUID}.\n+     * Constructs a new {@code UUID} from the given 64-bit big-endian integers.\n+     *\n+     * <p>{@code mostSigBits} is used for the most significant 64 bits of the\n+     * {@code UUID} and {@code leastSigBits} becomes the least significant 64\n+     * bits of the {@code UUID}.\n+     *\n+     * <p>It is impossible to verify if the given data is a <em>valid<\/em> UUID\n+     * according to RFC&nbsp;4122 or just two random numbers. Consequently no\n+     * attempt is made to validate the data in any way and this constructor can\n+     * be used to construct arbitrary {@code UUID} instances.\n@@ -129,1 +164,1 @@\n-     *         The most significant bits of the {@code UUID}\n+     *         The most significant 64 bits of the {@code UUID}\n@@ -132,1 +167,1 @@\n-     *         The least significant bits of the {@code UUID}\n+     *         The least significant 64 bits of the {@code UUID}\n@@ -134,1 +169,1 @@\n-    public UUID(long mostSigBits, long leastSigBits) {\n+    public UUID(final long mostSigBits, final long leastSigBits) {\n@@ -139,0 +174,42 @@\n+    \/**\n+     * Constructs a new {@code UUID} from the given big-endian {@code bytes}.\n+     *\n+     * <p>The first 8 bytes are used for the most significant 64 bits of the\n+     * {@code UUID} and the remaining 8 bytes are used for the least significant\n+     * 64 bits of the {@code UUID}.\n+     *\n+     * <p>It is impossible to verify if the given data is a <em>valid<\/em> UUID\n+     * according to RFC&nbsp;4122 or just 16 random bytes. Consequently no\n+     * attempt is made to validate the data in any way and this static factory\n+     * can be used to construct arbitrary {@code UUID} instances.\n+     *\n+     * @param  bytes\n+     *         The bytes of the {@code UUID}\n+     *\n+     * @return {@code UUID} constructed from the given {@code bytes}\n+     *\n+     * @throws IllegalArgumentException\n+     *         If {@code bytes} is not exactly of length 16\n+     *\n+     * @throws NullPointerException\n+     *         If {@code bytes} is {@code null}\n+     *\n+     * @since  16\n+     *\/\n+    public static UUID valueOf(final byte[] bytes) {\n+        if (bytes == null) {\n+            throw new NullPointerException(\"bytes must not be null\");\n+        }\n+\n+        if (bytes.length != 16) {\n+            throw new IllegalArgumentException(\"UUID bytes must be exactly of length 16, got: \" + bytes.length);\n+        }\n+\n+        int i = 0;\n+        long msb = 0;\n+        long lsb = 0;\n+        for (; i <  8; ++i) msb = (msb << 8) | (bytes[i] & 0xFF);\n+        for (; i < 16; ++i) lsb = (lsb << 8) | (bytes[i] & 0xFF);\n+        return new UUID(msb, lsb);\n+    }\n+\n@@ -148,9 +225,3 @@\n-        SecureRandom ng = Holder.numberGenerator;\n-\n-        byte[] randomBytes = new byte[16];\n-        ng.nextBytes(randomBytes);\n-        randomBytes[6]  &= 0x0f;  \/* clear version        *\/\n-        randomBytes[6]  |= 0x40;  \/* set to version 4     *\/\n-        randomBytes[8]  &= 0x3f;  \/* clear variant        *\/\n-        randomBytes[8]  |= 0x80;  \/* set to IETF variant  *\/\n-        return new UUID(randomBytes);\n+        final byte[] bytes = new byte[16];\n+        Holder.numberGenerator.nextBytes(bytes);\n+        return new UUID(bytes, 0x40);\n@@ -169,1 +240,1 @@\n-        MessageDigest md;\n+        final MessageDigest md;\n@@ -175,6 +246,1 @@\n-        byte[] md5Bytes = md.digest(name);\n-        md5Bytes[6]  &= 0x0f;  \/* clear version        *\/\n-        md5Bytes[6]  |= 0x30;  \/* set to version 3     *\/\n-        md5Bytes[8]  &= 0x3f;  \/* clear variant        *\/\n-        md5Bytes[8]  |= 0x80;  \/* set to IETF variant  *\/\n-        return new UUID(md5Bytes);\n+        return new UUID(md.digest(name), 0x30);\n@@ -433,0 +499,34 @@\n+    \/**\n+     * Gets the bytes of this {@code UUID}.\n+     *\n+     * <p>The layout of the {@code UUID} bytes is defined in\n+     * <a href=\"https:\/\/tools.ietf.org\/html\/rfc4122#section-4.1.2\">RFC&nbsp;4122\n+     * Section 4.1.2<\/a>. The meaning of the individual bytes of this\n+     * {@code UUID} may or may not conform to the specification depending on how\n+     * it was initially generated.\n+     *\n+     * @return The bytes of this {@code UUID}.\n+     *\n+     * @since  16\n+     *\/\n+    public byte[] getBytes() {\n+        byte[] bytes = new byte[16];\n+        bytes[0]  = (byte) (mostSigBits >>> 56);\n+        bytes[1]  = (byte) (mostSigBits >>> 48);\n+        bytes[2]  = (byte) (mostSigBits >>> 40);\n+        bytes[3]  = (byte) (mostSigBits >>> 32);\n+        bytes[4]  = (byte) (mostSigBits >>> 24);\n+        bytes[5]  = (byte) (mostSigBits >>> 16);\n+        bytes[6]  = (byte) (mostSigBits >>> 8);\n+        bytes[7]  = (byte) (mostSigBits);\n+        bytes[8]  = (byte) (leastSigBits >>> 56);\n+        bytes[9]  = (byte) (leastSigBits >>> 48);\n+        bytes[10] = (byte) (leastSigBits >>> 40);\n+        bytes[11] = (byte) (leastSigBits >>> 32);\n+        bytes[12] = (byte) (leastSigBits >>> 24);\n+        bytes[13] = (byte) (leastSigBits >>> 16);\n+        bytes[14] = (byte) (leastSigBits >>> 8);\n+        bytes[15] = (byte) (leastSigBits);\n+        return bytes;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/util\/UUID.java","additions":133,"deletions":33,"binary":false,"changes":166,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+        bytesTest();\n@@ -122,0 +123,19 @@\n+    private static void bytesTest() throws Exception {\n+        final UUID a = UUID.randomUUID();\n+        final UUID b = new UUID(a.getBytes());\n+        if (!a.equals(b)) {\n+            throw new Exception(\"UUID -> byte[] -> UUID failed\");\n+        }\n+\n+        final byte[] dnsBytes = {\n+                (byte) 0x6B, (byte) 0xA7, (byte) 0xB8, (byte) 0x10, (byte) 0x9D,\n+                (byte) 0xAD, (byte) 0x11, (byte) 0xD1, (byte) 0x80, (byte) 0xB4,\n+                (byte) 0x00, (byte) 0xC0, (byte) 0x4F, (byte) 0xD4, (byte) 0x30,\n+                (byte) 0xC8\n+        };\n+        final String dnsUuid = new UUID(dnsBytes).toString();\n+        if (!\"6ba7b810-9dad-11d1-80b4-00c04fd430c8\".equals(dnsUuid)) {\n+            throw new Exception(\"DNS UUID was not correctly reconstructed from raw bytes, got: \" + dnsUuid);\n+        }\n+    }\n+\n","filename":"test\/jdk\/java\/util\/UUID\/UUIDTest.java","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"}]}