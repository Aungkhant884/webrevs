{"files":[{"patch":"@@ -108,3 +108,3 @@\n-     * Constructs new {@code UUID} from the given {@code bytes}.\n-     * <p>\n-     * The {@link #version()} is set to the given {@code version} and the\n+     * Constructs a new {@code UUID} from the given {@code bytes}.\n+     *\n+     * <p>The {@link #version()} is set to the given {@code version} and the\n@@ -113,4 +113,15 @@\n-     * @param bytes   to construct the {@code UUID} from.\n-     * @param version to set for this {@code UUID}.\n-     * @throws AssertionError if {@code bytes} is not of length 16.\n-     * @since 16\n+     * @implNote\n+     * This constructor is <em>private<\/em> because it performs no validation\n+     * on {@code bytes} or {@code version} to be extensible for future needs of\n+     * the {@code UUID} implementation. {@code bytes} is expected to contain at\n+     * least 16 bytes and any additional data will silently be ignored, this is\n+     * for example required during the creation of version 5 UUIDs where the\n+     * SHA-1 digest is 20 bytes long and truncated.\n+     *\n+     * @param  bytes\n+     *         The bytes of this {@code UUID}\n+     *\n+     * @param  version\n+     *         The {@linkplain #version() version} of this {@code UUID}\n+     *\n+     * @since  16\n@@ -119,2 +130,0 @@\n-        assert bytes.length == 16 : \"UUID bytes must be exactly of length 16, got: \" + bytes.length;\n-\n@@ -128,1 +137,1 @@\n-        msb     |=         bytes[7]  & 0xFF;\n+        msb     |= (long)  bytes[7]  & 0xFF;\n@@ -138,1 +147,1 @@\n-        lsb     |=         bytes[15] & 0xFF;\n+        lsb     |= (long)  bytes[15] & 0xFF;\n@@ -143,4 +152,13 @@\n-     * Constructs a new {@code UUID} from the given {@code bytes}.\n-     * <p>\n-     * It is impossible to verify if the given data is a <em>valid<\/em> UUID\n-     * according to RFC&nbsp;4122 or just 16 random bytes.\n+     * Constructs a new {@code UUID} from the given 64-bit big-endian integers.\n+     *\n+     * <p>{@code mostSigBits} is used for the most significant 64 bits of the\n+     * {@code UUID} and {@code leastSigBits} becomes the least significant 64\n+     * bits of the {@code UUID}.\n+     *\n+     * <p>It is impossible to verify if the given data is a <em>valid<\/em> UUID\n+     * according to RFC&nbsp;4122 or just two random numbers. Consequently no\n+     * attempt is made to validate the data in any way and this constructor can\n+     * be used to construct arbitrary {@code UUID} instances.\n+     *\n+     * @param  mostSigBits\n+     *         The most significant 64 bits of the {@code UUID}\n@@ -148,3 +166,2 @@\n-     * @param bytes to construct the {@code UUID} from.\n-     * @throws IllegalArgumentException if {@code bytes} is not of length 16.\n-     * @since 16\n+     * @param  leastSigBits\n+     *         The least significant 64 bits of the {@code UUID}\n@@ -152,1 +169,35 @@\n-    public UUID(final byte[] bytes) {\n+    public UUID(final long mostSigBits, final long leastSigBits) {\n+        this.mostSigBits = mostSigBits;\n+        this.leastSigBits = leastSigBits;\n+    }\n+\n+    \/**\n+     * Constructs a new {@code UUID} from the given big-endian {@code bytes}.\n+     *\n+     * <p>The first 8 bytes are used for the most significant 64 bits of the\n+     * {@code UUID} and the remaining 8 bytes are used for the least significant\n+     * 64 bits of the {@code UUID}.\n+     *\n+     * <p>It is impossible to verify if the given data is a <em>valid<\/em> UUID\n+     * according to RFC&nbsp;4122 or just 16 random bytes. Consequently no\n+     * attempt is made to validate the data in any way and this static factory\n+     * can be used to construct arbitrary {@code UUID} instances.\n+     *\n+     * @param  bytes\n+     *         The bytes of the {@code UUID}\n+     *\n+     * @return {@code UUID} constructed from the given {@code bytes}\n+     *\n+     * @throws IllegalArgumentException\n+     *         If {@code bytes} is not exactly of length 16\n+     *\n+     * @throws NullPointerException\n+     *         If {@code bytes} is {@code null}\n+     *\n+     * @since  16\n+     *\/\n+    public static UUID valueOf(final byte[] bytes) {\n+        if (bytes == null) {\n+            throw new NullPointerException(\"bytes must not be null\");\n+        }\n+\n@@ -162,19 +213,1 @@\n-        this.mostSigBits = msb;\n-        this.leastSigBits = lsb;\n-    }\n-\n-    \/**\n-     * Constructs a new {@code UUID} using the specified data.  {@code\n-     * mostSigBits} is used for the most significant 64 bits of the {@code\n-     * UUID} and {@code leastSigBits} becomes the least significant 64 bits of\n-     * the {@code UUID}.\n-     *\n-     * @param  mostSigBits\n-     *         The most significant bits of the {@code UUID}\n-     *\n-     * @param  leastSigBits\n-     *         The least significant bits of the {@code UUID}\n-     *\/\n-    public UUID(long mostSigBits, long leastSigBits) {\n-        this.mostSigBits = mostSigBits;\n-        this.leastSigBits = leastSigBits;\n+        return new UUID(msb, lsb);\n@@ -467,1 +500,9 @@\n-     * Gets the raw byte representation of this {@code UUID}.\n+     * Gets the bytes of this {@code UUID}.\n+     *\n+     * <p>The layout of the {@code UUID} bytes is defined in\n+     * <a href=\"https:\/\/tools.ietf.org\/html\/rfc4122#section-4.1.2\">RFC&nbsp;4122\n+     * Section 4.1.2<\/a>. The meaning of the individual bytes of this\n+     * {@code UUID} may or may not conform to the specification depending on how\n+     * it was initially generated.\n+     *\n+     * @return The bytes of this {@code UUID}.\n@@ -469,2 +510,1 @@\n-     * @return the raw bytes of this {@code UUID}.\n-     * @since 16\n+     * @since  16\n","filename":"src\/java.base\/share\/classes\/java\/util\/UUID.java","additions":81,"deletions":41,"binary":false,"changes":122,"status":"modified"}]}