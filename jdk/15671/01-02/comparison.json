{"files":[{"patch":"@@ -39,1 +39,1 @@\n-    Choice c;\n+    final Choice c;\n","filename":"test\/jdk\/java\/awt\/Choice\/ChoiceSelectTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -94,5 +94,8 @@\n-            Displayable test = new Displayable();\n-            test.init();\n-            f.add(\"North\", test);\n-            f.pack();\n-            f.dispose();\n+            try {\n+                Displayable test = new Displayable();\n+                test.init();\n+                f.add(\"North\", test);\n+                f.pack();\n+            } finally {\n+                f.dispose();\n+            }\n","filename":"test\/jdk\/java\/awt\/Component\/Displayable.java","additions":8,"deletions":5,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -64,0 +64,1 @@\n+                actionFired = false;\n@@ -112,0 +113,1 @@\n+            robot.waitForIdle();\n","filename":"test\/jdk\/java\/awt\/Focus\/TestWindowsLFFocus.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -24,0 +24,10 @@\n+import java.awt.BorderLayout;\n+import java.awt.Canvas;\n+import java.awt.Choice;\n+import java.awt.Color;\n+import java.awt.Dimension;\n+import java.awt.EventQueue;\n+import java.awt.Frame;\n+import java.awt.Graphics;\n+import java.awt.Graphics2D;\n+import java.awt.Panel;\n@@ -39,0 +49,2 @@\n+ * @library \/open\/test\/jdk\/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n@@ -42,0 +54,12 @@\n+\/*\n+ * @test\n+ * @bug 4210936 4214524\n+ * @summary Tests the results of the hit test methods on 3 different\n+ *          Shape objects - Polygon, Area, and GeneralPath.  Both an\n+ *          automatic test for constraint compliance and a manual\n+ *          test for correctness are included in this one class.\n+ * @library \/open\/test\/jdk\/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual PathHitTest manual\n+ *\/\n+\n@@ -43,0 +67,1 @@\n+\n@@ -46,0 +71,1 @@\n+    public static final int NUMTESTS = (TESTSIZE + BOXSIZE - 1) \/ BOXSIZE;\n@@ -66,1 +92,1 @@\n-            ell.setFrame(center.getX()-50, center.getY()-50, 100, 100);\n+            ell.setFrame(center.getX() - 50, center.getY() - 50, 100, 100);\n@@ -116,8 +142,12 @@\n-    public static void main(String[] argv) {\n-        int totalerrs = 0;\n-        for (int i = 0; i < testShapes.length; i++) {\n-            totalerrs += testshape(testShapes[i], testNames[i]);\n-        }\n-        if (totalerrs != 0) {\n-            throw new RuntimeException(totalerrs+\n-                    \" constraint conditions violated!\");\n+    public static void main(String[] argv) throws Exception {\n+        if (argv.length > 0 && argv[0].equals(\"manual\")) {\n+            PathHitTestManual.doManual();\n+        } else {\n+            int totalerrs = 0;\n+            for (int i = 0; i < testShapes.length; i++) {\n+                totalerrs += testshape(testShapes[i], testNames[i]);\n+            }\n+            if (totalerrs != 0) {\n+                throw new RuntimeException(totalerrs +\n+                        \" constraint conditions violated!\");\n+            }\n@@ -134,1 +164,1 @@\n-                boolean pointcontains = s.contains(x+BOXCENTER, y+BOXCENTER);\n+                boolean pointcontains = s.contains(x + BOXCENTER, y + BOXCENTER);\n@@ -136,1 +166,1 @@\n-                    System.err.println(\"rect is contained \"+\n+                    System.err.println(\"rect is contained \" +\n@@ -141,1 +171,1 @@\n-                    System.err.println(\"rect is contained \"+\n+                    System.err.println(\"rect is contained \" +\n@@ -146,1 +176,1 @@\n-                    System.err.println(\"center is contained \"+\n+                    System.err.println(\"center is contained \" +\n@@ -153,3 +183,3 @@\n-        System.out.println(name+\" completed in \"+\n-                (end-start)+\"ms with \"+\n-                numerrs+\" errors\");\n+        System.out.println(name + \" completed in \" +\n+                (end - start) + \"ms with \" +\n+                numerrs + \" errors\");\n@@ -158,0 +188,204 @@\n+\n+    static class PathHitTestManual extends Panel {\n+        private static final String INSTRUCTIONS = \"\"\"\n+            This test displays the results of hit testing 5 different Shape\n+            objects one at a time.\n+    \n+            You can switch between shapes using the Choice component located\n+            at the bottom of the window.\n+    \n+            Each square in the test represents the\n+            return values of the hit testing operators for that square region:\n+    \n+                yellow - not yet tested\n+                translucent blue overlay - the shape being tested\n+    \n+                black - all outside\n+                dark gray - rectangle intersects shape\n+                light gray - rectangle intersects and center point is inside shape\n+                white - rectangle is entirely contained in shape\n+                red - some constraint was violated, including:\n+                    rectangle is contained, but center point is not\n+                    rectangle is contained, but rectangle.intersects is false\n+                    centerpoint is contained, but rectangle.intersects is false\n+    \n+            Visually inspect the results to see if they match the above table.\n+            Note that it is not a violation for rectangles that are entirely\n+            inside the path to be light gray instead of white since sometimes\n+            the path is complex enough to make an exact determination expensive.\n+            You might see this on the GeneralPath NonZero example where the\n+            circles that make up the path cross over the interior of the shape\n+            and cause the hit testing methods to guess that the rectangle is\n+            not guaranteed to be contained within the shape.\n+            \"\"\";\n+\n+        PathHitTestCanvas phtc;\n+\n+        public void init() {\n+            setLayout(new BorderLayout());\n+            phtc = new PathHitTestCanvas();\n+            add(\"Center\", phtc);\n+            final Choice ch = new Choice();\n+            for (int i = 0; i < PathHitTest.testNames.length; i++) {\n+                ch.add(PathHitTest.testNames[i]);\n+            }\n+            ch.addItemListener(e -> phtc.setShape(ch.getSelectedIndex()));\n+            ch.select(0);\n+            phtc.setShape(0);\n+            add(\"South\", ch);\n+        }\n+\n+        public void start() {\n+            phtc.start();\n+        }\n+\n+        public void stop() {\n+            phtc.stop();\n+        }\n+\n+        public static class PathHitTestCanvas extends Canvas implements Runnable {\n+            public static final Color[] colors = {\n+                                        \/* contains?  point in?  intersects? *\/\n+                    Color.black,        \/*    NO         NO          NO      *\/\n+                    Color.darkGray,     \/*    NO         NO          YES     *\/\n+                    Color.red,          \/*    NO         YES         NO      *\/\n+                    Color.lightGray,    \/*    NO         YES         YES     *\/\n+                    Color.red,          \/*    YES        NO          NO      *\/\n+                    Color.red,          \/*    YES        NO          YES     *\/\n+                    Color.red,          \/*    YES        YES         NO      *\/\n+                    Color.white,        \/*    YES        YES         YES     *\/\n+                    Color.yellow,       \/*     used for untested points      *\/\n+            };\n+\n+            public Dimension getPreferredSize() {\n+                return new Dimension(TESTSIZE, TESTSIZE);\n+            }\n+\n+            public synchronized void start() {\n+                if (!testdone) {\n+                    renderer = new Thread(this);\n+                    renderer.setPriority(Thread.MIN_PRIORITY);\n+                    renderer.start();\n+                }\n+            }\n+\n+            public synchronized void stop() {\n+                renderer = null;\n+            }\n+\n+            private Thread renderer;\n+            private int shapeIndex = 0;\n+            private byte[] indices = new byte[NUMTESTS * NUMTESTS];\n+            boolean testdone = false;\n+\n+            private synchronized void setShape(int index) {\n+                shapeIndex = index;\n+                testdone = false;\n+                start();\n+            }\n+\n+            public void run() {\n+                Thread me = Thread.currentThread();\n+                Graphics2D g2d = (Graphics2D) getGraphics();\n+                byte[] indices;\n+                Shape s = testShapes[shapeIndex];\n+                synchronized (this) {\n+                    if (renderer != me) {\n+                        return;\n+                    }\n+                    this.indices = new byte[NUMTESTS * NUMTESTS];\n+                    java.util.Arrays.fill(this.indices, (byte) 8);\n+                    indices = this.indices;\n+                }\n+\n+                System.err.printf(\"%s %s\\n\", g2d, Color.yellow);\n+                g2d.setColor(Color.yellow);\n+                g2d.fillRect(0, 0, TESTSIZE, TESTSIZE);\n+                int numtests = 0;\n+                long start = System.currentTimeMillis();\n+                for (int y = 0; renderer == me && y < TESTSIZE; y += BOXSIZE) {\n+                    for (int x = 0; renderer == me && x < TESTSIZE; x += BOXSIZE) {\n+                        byte index = 0;\n+                        if (s.intersects(x, y, BOXSIZE, BOXSIZE)) {\n+                            index += 1;\n+                        }\n+                        if (s.contains(x + BOXCENTER, y + BOXCENTER)) {\n+                            index += 2;\n+                        }\n+                        if (s.contains(x, y, BOXSIZE, BOXSIZE)) {\n+                            index += 4;\n+                        }\n+                        numtests++;\n+                        int i = (y \/ BOXSIZE) * NUMTESTS + (x \/ BOXSIZE);\n+                        indices[i] = index;\n+                        g2d.setColor(colors[index]);\n+                        g2d.fillRect(x, y, BOXSIZE, BOXSIZE);\n+                    }\n+                }\n+                synchronized (this) {\n+                    if (renderer != me) {\n+                        return;\n+                    }\n+                    g2d.setColor(new Color(0, 0, 1, .2f));\n+                    g2d.fill(s);\n+                    testdone = true;\n+                    long end = System.currentTimeMillis();\n+                    System.out.println(numtests + \" tests took \" + (end - start) + \"ms\");\n+                }\n+            }\n+\n+            public void paint(Graphics g) {\n+                g.setColor(Color.yellow);\n+                g.fillRect(0, 0, TESTSIZE, TESTSIZE);\n+                byte[] indices = this.indices;\n+                if (indices != null) {\n+                    for (int y = 0; y < TESTSIZE; y += BOXSIZE) {\n+                        for (int x = 0; x < TESTSIZE; x += BOXSIZE) {\n+                            int i = (y \/ BOXSIZE) * NUMTESTS + (x \/ BOXSIZE);\n+                            g.setColor(colors[indices[i]]);\n+                            g.fillRect(x, y, BOXSIZE, BOXSIZE);\n+                        }\n+                    }\n+                }\n+                Graphics2D g2d = (Graphics2D) g;\n+                g2d.setColor(new Color(0, 0, 1, .2f));\n+                g2d.fill(testShapes[shapeIndex]);\n+            }\n+        }\n+\n+        static volatile PathHitTestManual pathHitTestManual;\n+\n+        private static void createAndShowGUI() {\n+            pathHitTestManual = new PathHitTestManual();\n+            Frame frame = new Frame(\"PathHitTestManual test window\");\n+\n+            frame.add(pathHitTestManual);\n+            frame.setSize(400, 450);\n+\n+            PassFailJFrame.addTestWindow(frame);\n+            PassFailJFrame.positionTestWindow(frame, PassFailJFrame.Position.HORIZONTAL);\n+\n+            frame.setVisible(true);\n+\n+            pathHitTestManual.init();\n+            pathHitTestManual.start();\n+        }\n+\n+        public static void doManual() throws Exception {\n+            PassFailJFrame passFailJFrame = new PassFailJFrame.Builder()\n+                    .title(\"PathHitTestManual Instructions\")\n+                    .instructions(INSTRUCTIONS)\n+                    .testTimeOut(5)\n+                    .rows(30)\n+                    .columns(70)\n+                    .screenCapture()\n+                    .build();\n+\n+            EventQueue.invokeAndWait(PathHitTestManual::createAndShowGUI);\n+            try {\n+                passFailJFrame.awaitAndCheck();\n+            } finally {\n+                pathHitTestManual.stop();\n+            }\n+        }\n+    }\n","filename":"test\/jdk\/java\/awt\/geom\/HitTest\/PathHitTest.java","additions":250,"deletions":16,"binary":false,"changes":266,"status":"modified"},{"patch":"@@ -1,257 +0,0 @@\n-\/*\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.awt.BorderLayout;\n-import java.awt.Canvas;\n-import java.awt.Choice;\n-import java.awt.Color;\n-import java.awt.Dimension;\n-import java.awt.EventQueue;\n-import java.awt.Frame;\n-import java.awt.Graphics;\n-import java.awt.Graphics2D;\n-import java.awt.Panel;\n-import java.awt.Shape;\n-\n-\/*\n- *    @test\n- *    @bug 4210936\n- *    @summary Tests the results of the hit test methods on 3 different\n- *           Shape objects - Polygon, Area, and GeneralPath.  Both an\n- *           automatic test for constraint compliance and a manual\n- *           test for correctness are included in this one class.\n- *    @key headful\n- *    @library \/java\/awt\/regtesthelpers\n- *    @build PassFailJFrame\n- *    @run main\/manual PathHitTestManual\n- *\/\n-\n-public class PathHitTestManual extends Panel {\n-    private static final String INSTRUCTIONS = \"\"\"\n-            This test displays the results of hit testing 5 different Shape\n-            objects one at a time.\n-\n-            You can switch between shapes using the Choice component located\n-            at the bottom of the window.\n-\n-            Each square in the test represents the\n-            return values of the hit testing operators for that square region:\n-\n-                yellow - not yet tested\n-                translucent blue overlay - the shape being tested\n-\n-                black - all outside\n-                dark gray - rectangle intersects shape\n-                light gray - rectangle intersects and center point is inside shape\n-                white - rectangle is entirely contained in shape\n-                red - some constraint was violated, including:\n-                    rectangle is contained, but center point is not\n-                    rectangle is contained, but rectangle.intersects is false\n-                    centerpoint is contained, but rectangle.intersects is false\n-\n-            Visually inspect the results to see if they match the above table.\n-            Note that it is not a violation for rectangles that are entirely\n-            inside the path to be light gray instead of white since sometimes\n-            the path is complex enough to make an exact determination expensive.\n-            You might see this on the GeneralPath NonZero example where the\n-            circles that make up the path cross over the interior of the shape\n-            and cause the hit testing methods to guess that the rectangle is\n-            not guaranteed to be contained within the shape.\n-            \"\"\";\n-\n-    public static final int BOXSIZE = PathHitTest.BOXSIZE;\n-    public static final int BOXCENTER = PathHitTest.BOXCENTER;\n-    public static final int TESTSIZE = PathHitTest.TESTSIZE;\n-\n-    public static final int NUMTESTS = (TESTSIZE + BOXSIZE - 1) \/ BOXSIZE;\n-\n-    PathHitTestCanvas phtc;\n-\n-    public void init() {\n-        setLayout(new BorderLayout());\n-        phtc = new PathHitTestCanvas();\n-        add(\"Center\", phtc);\n-        final Choice ch = new Choice();\n-        for (int i = 0; i < PathHitTest.testNames.length; i++) {\n-            ch.add(PathHitTest.testNames[i]);\n-        }\n-        ch.addItemListener(e -> phtc.setShape(ch.getSelectedIndex()));\n-        ch.select(0);\n-        phtc.setShape(0);\n-        add(\"South\", ch);\n-    }\n-\n-    public void start() {\n-        phtc.start();\n-    }\n-\n-    public void stop() {\n-        phtc.stop();\n-    }\n-\n-    public static class PathHitTestCanvas extends Canvas implements Runnable {\n-        public static final Color[] colors = {\n-                \/* contains?  point in?  intersects? *\/\n-                Color.black,        \/*    NO         NO          NO      *\/\n-                Color.darkGray,     \/*    NO         NO          YES     *\/\n-                Color.red,          \/*    NO         YES         NO      *\/\n-                Color.lightGray,    \/*    NO         YES         YES     *\/\n-                Color.red,          \/*    YES        NO          NO      *\/\n-                Color.red,          \/*    YES        NO          YES     *\/\n-                Color.red,          \/*    YES        YES         NO      *\/\n-                Color.white,        \/*    YES        YES         YES     *\/\n-                Color.yellow,       \/*     used for untested points      *\/\n-        };\n-\n-        public Dimension getPreferredSize() {\n-            return new Dimension(TESTSIZE, TESTSIZE);\n-        }\n-\n-        public synchronized void start() {\n-            if (!testdone) {\n-                renderer = new Thread(this);\n-                renderer.setPriority(Thread.MIN_PRIORITY);\n-                renderer.start();\n-            }\n-        }\n-\n-        public synchronized void stop() {\n-            renderer = null;\n-        }\n-\n-        private Thread renderer;\n-        private int shapeIndex = 0;\n-        private byte[] indices = new byte[NUMTESTS * NUMTESTS];\n-        boolean testdone = false;\n-\n-        private synchronized void setShape(int index) {\n-            shapeIndex = index;\n-            testdone = false;\n-            start();\n-        }\n-\n-        public void run() {\n-            Thread me = Thread.currentThread();\n-            Graphics2D g2d = (Graphics2D) getGraphics();\n-            byte[] indices;\n-            Shape s = PathHitTest.testShapes[shapeIndex];\n-            synchronized (this) {\n-                if (renderer != me) {\n-                    return;\n-                }\n-                this.indices = new byte[NUMTESTS * NUMTESTS];\n-                java.util.Arrays.fill(this.indices, (byte) 8);\n-                indices = this.indices;\n-            }\n-\n-            System.err.printf(\"%s %s\\n\", g2d, Color.yellow);\n-            g2d.setColor(Color.yellow);\n-            g2d.fillRect(0, 0, TESTSIZE, TESTSIZE);\n-            int numtests = 0;\n-            long start = System.currentTimeMillis();\n-            for (int y = 0; renderer == me && y < TESTSIZE; y += BOXSIZE) {\n-                for (int x = 0; renderer == me && x < TESTSIZE; x += BOXSIZE) {\n-                    byte index = 0;\n-                    if (s.intersects(x, y, BOXSIZE, BOXSIZE)) {\n-                        index += 1;\n-                    }\n-                    if (s.contains(x+BOXCENTER, y+BOXCENTER)) {\n-                        index += 2;\n-                    }\n-                    if (s.contains(x, y, BOXSIZE, BOXSIZE)) {\n-                        index += 4;\n-                    }\n-                    numtests++;\n-                    int i = (y \/ BOXSIZE) * NUMTESTS + (x \/ BOXSIZE);\n-                    indices[i] = index;\n-                    g2d.setColor(colors[index]);\n-                    g2d.fillRect(x, y, BOXSIZE, BOXSIZE);\n-                }\n-            }\n-            synchronized (this) {\n-                if (renderer != me) {\n-                    return;\n-                }\n-                g2d.setColor(new Color(0, 0, 1, .2f));\n-                g2d.fill(s);\n-                testdone = true;\n-                long end = System.currentTimeMillis();\n-                System.out.println(numtests+\" tests took \"+(end-start)+\"ms\");\n-            }\n-        }\n-\n-        public void paint(Graphics g) {\n-            g.setColor(Color.yellow);\n-            g.fillRect(0, 0, TESTSIZE, TESTSIZE);\n-            byte[] indices = this.indices;\n-            if (indices != null) {\n-                for (int y = 0; y < TESTSIZE; y += BOXSIZE) {\n-                    for (int x = 0; x < TESTSIZE; x += BOXSIZE) {\n-                        int i = (y \/ BOXSIZE) * NUMTESTS + (x \/ BOXSIZE);\n-                        g.setColor(colors[indices[i]]);\n-                        g.fillRect(x, y, BOXSIZE, BOXSIZE);\n-                    }\n-                }\n-            }\n-            Graphics2D g2d = (Graphics2D) g;\n-            g2d.setColor(new Color(0, 0, 1, .2f));\n-            g2d.fill(PathHitTest.testShapes[shapeIndex]);\n-        }\n-    }\n-\n-\n-    static volatile PathHitTestManual pathHitTestManual = null;\n-    private static void createAndShowGUI() {\n-        pathHitTestManual = new PathHitTestManual();\n-        Frame frame = new Frame(\"PathHitTestManual test window\");\n-\n-        frame.add(pathHitTestManual);\n-        frame.setSize(400, 450);\n-\n-        PassFailJFrame.addTestWindow(frame);\n-        PassFailJFrame.positionTestWindow(frame, PassFailJFrame.Position.HORIZONTAL);\n-\n-        frame.setVisible(true);\n-\n-        pathHitTestManual.init();\n-        pathHitTestManual.start();\n-    }\n-\n-    public static void main(String[] args) throws Exception {\n-        PassFailJFrame passFailJFrame = new PassFailJFrame.Builder()\n-                .title(\"PathHitTestManual Instructions\")\n-                .instructions(INSTRUCTIONS)\n-                .testTimeOut(5)\n-                .rows(30)\n-                .columns(70)\n-                .screenCapture()\n-                .build();\n-\n-        EventQueue.invokeAndWait(PathHitTestManual::createAndShowGUI);\n-        try {\n-            passFailJFrame.awaitAndCheck();\n-        } finally {\n-            pathHitTestManual.stop();\n-        }\n-    }\n-}\n","filename":"test\/jdk\/java\/awt\/geom\/HitTest\/PathHitTestManual.java","additions":0,"deletions":257,"binary":false,"changes":257,"status":"deleted"}]}