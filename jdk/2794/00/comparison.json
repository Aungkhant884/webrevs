{"files":[{"patch":"@@ -60,1 +60,1 @@\n-#include \"gc\/shared\/weakProcessor.hpp\"\n+#include \"gc\/shared\/weakProcessor.inline.hpp\"\n@@ -783,1 +783,1 @@\n-HeapWord* ParallelCompactData::calc_new_pointer(HeapWord* addr, ParCompactionManager* cm) {\n+HeapWord* ParallelCompactData::calc_new_pointer(HeapWord* addr, ParCompactionManager* cm) const {\n@@ -1791,2 +1791,0 @@\n-    ResourceMark rm;\n-\n@@ -1837,1 +1835,1 @@\n-    adjust_roots(vmthread_cm);\n+    adjust_roots();\n@@ -2212,3 +2210,5 @@\n-void PSParallelCompact::adjust_roots(ParCompactionManager* cm) {\n-  \/\/ Adjust the pointers to reflect the new locations\n-  GCTraceTime(Info, gc, phases) tm(\"Adjust Roots\", &_gc_timer);\n+class PSAdjustTask final : public AbstractGangTask {\n+  SubTasksDone                               _sub_tasks;\n+  WeakProcessor::Task                        _weak_proc_task;\n+  OopStorageSetStrongParState<false, false>  _oop_storage_iter;\n+  uint                                       _nworkers;\n@@ -2216,2 +2216,5 @@\n-  \/\/ Need new claim bits when tracing through and adjusting pointers.\n-  ClassLoaderDataGraph::clear_claimed_marks();\n+  enum PSAdjustSubTask {\n+    PSAdjustSubTask_code_cache,\n+    PSAdjustSubTask_aot,\n+    PSAdjustSubTask_old_ref_process,\n+    PSAdjustSubTask_young_ref_process,\n@@ -2219,1 +2222,2 @@\n-  PCAdjustPointerClosure oop_closure(cm);\n+    PSAdjustSubTask_num_elements\n+  };\n@@ -2221,5 +2225,12 @@\n-  \/\/ General strong roots.\n-  Threads::oops_do(&oop_closure, NULL);\n-  OopStorageSet::strong_oops_do(&oop_closure);\n-  CLDToOopClosure cld_closure(&oop_closure, ClassLoaderData::_claim_strong);\n-  ClassLoaderDataGraph::cld_do(&cld_closure);\n+public:\n+  PSAdjustTask(uint nworkers) :\n+    AbstractGangTask(\"PSAdjust task\"),\n+    _sub_tasks(PSAdjustSubTask_num_elements),\n+    _weak_proc_task(nworkers),\n+    _nworkers(nworkers) {\n+    \/\/ Need new claim bits when tracing through and adjusting pointers.\n+    ClassLoaderDataGraph::clear_claimed_marks();\n+    if (nworkers > 1) {\n+      Threads::change_thread_claim_token();\n+    }\n+  }\n@@ -2227,3 +2238,3 @@\n-  \/\/ Now adjust pointers in remaining weak roots.  (All of which should\n-  \/\/ have been cleared if they pointed to non-surviving objects.)\n-  WeakProcessor::oops_do(&oop_closure);\n+  ~PSAdjustTask() {\n+    Threads::assert_all_threads_claimed();\n+  }\n@@ -2231,3 +2242,36 @@\n-  CodeBlobToOopClosure adjust_from_blobs(&oop_closure, CodeBlobToOopClosure::FixRelocations);\n-  CodeCache::blobs_do(&adjust_from_blobs);\n-  AOT_ONLY(AOTLoader::oops_do(&oop_closure);)\n+  void work(uint worker_id) {\n+    ParCompactionManager* cm = ParCompactionManager::gc_thread_compaction_manager(worker_id);\n+    PCAdjustPointerClosure adjust(cm);\n+    {\n+      ResourceMark rm;\n+      Threads::possibly_parallel_oops_do(_nworkers > 1, &adjust, nullptr);\n+    }\n+    _oop_storage_iter.oops_do(&adjust);\n+    {\n+      CLDToOopClosure cld_closure(&adjust, ClassLoaderData::_claim_strong);\n+      ClassLoaderDataGraph::cld_do(&cld_closure);\n+    }\n+    {\n+      AlwaysTrueClosure always_alive;\n+      _weak_proc_task.work(worker_id, &always_alive, &adjust);\n+    }\n+    if (_sub_tasks.try_claim_task(PSAdjustSubTask_code_cache)) {\n+      CodeBlobToOopClosure adjust_code(&adjust, CodeBlobToOopClosure::FixRelocations);\n+      CodeCache::blobs_do(&adjust_code);\n+    }\n+    if (_sub_tasks.try_claim_task(PSAdjustSubTask_aot)) {\n+      AOT_ONLY(AOTLoader::oops_do(&adjust);)\n+    }\n+    if (_sub_tasks.try_claim_task(PSAdjustSubTask_old_ref_process)) {\n+      PSParallelCompact::ref_processor()->weak_oops_do(&adjust);\n+    }\n+    if (_sub_tasks.try_claim_task(PSAdjustSubTask_young_ref_process)) {\n+      \/\/ Roots were visited so references into the young gen in roots\n+      \/\/ may have been scanned.  Process them also.\n+      \/\/ Should the reference processor have a span that excludes\n+      \/\/ young gen objects?\n+      PSScavenge::reference_processor()->weak_oops_do(&adjust);\n+    }\n+    _sub_tasks.all_tasks_claimed();\n+  }\n+};\n@@ -2235,6 +2279,6 @@\n-  ref_processor()->weak_oops_do(&oop_closure);\n-  \/\/ Roots were visited so references into the young gen in roots\n-  \/\/ may have been scanned.  Process them also.\n-  \/\/ Should the reference processor have a span that excludes\n-  \/\/ young gen objects?\n-  PSScavenge::reference_processor()->weak_oops_do(&oop_closure);\n+void PSParallelCompact::adjust_roots() {\n+  \/\/ Adjust the pointers to reflect the new locations\n+  GCTraceTime(Info, gc, phases) tm(\"Adjust Roots\", &_gc_timer);\n+  uint nworkers = ParallelScavengeHeap::heap()->workers().active_workers();\n+  PSAdjustTask task(nworkers);\n+  ParallelScavengeHeap::heap()->workers().run_task(&task);\n@@ -2309,1 +2353,1 @@\n-        ParCompactionManager* cm = ParCompactionManager::manager_array(worker_id);\n+        ParCompactionManager* cm = ParCompactionManager::gc_thread_compaction_manager(worker_id);\n@@ -2508,1 +2552,0 @@\n-  return;\n@@ -3136,1 +3179,1 @@\n-    ParCompactionManager *cm = ParCompactionManager::manager_array(i);\n+    ParCompactionManager *cm = ParCompactionManager::gc_thread_compaction_manager(i);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.cpp","additions":74,"deletions":31,"binary":false,"changes":105,"status":"modified"},{"patch":"@@ -483,1 +483,1 @@\n-  HeapWord* calc_new_pointer(HeapWord* addr, ParCompactionManager* cm);\n+  HeapWord* calc_new_pointer(HeapWord* addr, ParCompactionManager* cm) const;\n@@ -485,1 +485,1 @@\n-  HeapWord* calc_new_pointer(oop p, ParCompactionManager* cm) {\n+  HeapWord* calc_new_pointer(oop p, ParCompactionManager* cm) const {\n@@ -1110,1 +1110,1 @@\n-  static void adjust_roots(ParCompactionManager* cm);\n+  static void adjust_roots();\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -116,4 +116,3 @@\n-    assert(new_obj != NULL,                    \/\/ is forwarding ptr?\n-           \"should be forwarded\");\n-    \/\/ Just always do the update unconditionally?\n-    if (new_obj != NULL) {\n+    assert(new_obj != NULL, \"non-null address for live objects\");\n+    \/\/ Is it actually relocated at all?\n+    if (new_obj != obj) {\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.inline.hpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"}]}