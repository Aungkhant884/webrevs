{"files":[{"patch":"@@ -2700,0 +2700,2 @@\n+\/\/            | (AddX SIV[iv] SIV[iv])  -- sum of two scaled iv; note recursion\n+\/\/            | (SubX SIV[iv] SIV[iv])  -- difference of two scaled iv; note recursion\n@@ -2761,7 +2763,14 @@\n-  } else if (opc == Op_Sub(exp_bt) &&\n-             exp->in(1)->find_integer_as_long(exp_bt, -1) == 0) {\n-    jlong scale = 0;\n-    if (depth == 0 && is_scaled_iv(exp->in(2), iv, exp_bt, &scale, p_short_scale, depth + 1)) {\n-      \/\/ SubX(0, iv*K) => iv*(-K)\n-      if (scale == min_signed_integer(exp_bt)) {\n-        \/\/ This should work even if -K overflows, but let's not.\n+  } else if (opc == Op_Add(exp_bt)) {\n+    jlong scale_l = 0;\n+    jlong scale_r = 0;\n+    bool short_scale_l = false;\n+    bool short_scale_r = false;\n+    if (depth == 0 &&\n+        is_scaled_iv(exp->in(1), iv, exp_bt, &scale_l, &short_scale_l, depth + 1) &&\n+        is_scaled_iv(exp->in(2), iv, exp_bt, &scale_r, &short_scale_r, depth + 1)) {\n+      \/\/ AddX(iv*K1, iv*K2) => iv*(K1+K2)\n+      jlong scale_sum = java_add(scale_l, scale_r);\n+      if (scale_sum > max_signed_integer(exp_bt) || scale_sum <= min_signed_integer(exp_bt)) {\n+        \/\/ This logic is shared by int and long. For int, the result may overflow\n+        \/\/ as we use jlong to compute so do the check here. Long result may also\n+        \/\/ overflow but that's fine because result wraps.\n@@ -2770,1 +2779,0 @@\n-      scale = java_multiply(scale, (jlong)-1);\n@@ -2772,1 +2780,1 @@\n-        *p_scale = scale;\n+        *p_scale = scale_sum;\n@@ -2775,2 +2783,1 @@\n-        \/\/ (ConvI2L (MulI iv K)) can be 64-bit linear if iv is kept small enough...\n-        *p_short_scale = *p_short_scale || (exp_bt != bt && scale != 1);\n+        *p_short_scale = short_scale_l && short_scale_r;\n@@ -2780,0 +2787,44 @@\n+  } else if (opc == Op_Sub(exp_bt)) {\n+    if (exp->in(1)->find_integer_as_long(exp_bt, -1) == 0) {\n+      jlong scale = 0;\n+      if (depth == 0 && is_scaled_iv(exp->in(2), iv, exp_bt, &scale, p_short_scale, depth + 1)) {\n+        \/\/ SubX(0, iv*K) => iv*(-K)\n+        if (scale == min_signed_integer(exp_bt)) {\n+          \/\/ This should work even if -K overflows, but let's not.\n+          return false;\n+        }\n+        scale = java_multiply(scale, (jlong)-1);\n+        if (p_scale != NULL) {\n+          *p_scale = scale;\n+        }\n+        if (p_short_scale != NULL) {\n+          \/\/ (ConvI2L (MulI iv K)) can be 64-bit linear if iv is kept small enough...\n+          *p_short_scale = *p_short_scale || (exp_bt != bt && scale != 1);\n+        }\n+        return true;\n+      }\n+    } else {\n+      jlong scale_l = 0;\n+      jlong scale_r = 0;\n+      bool short_scale_l = false;\n+      bool short_scale_r = false;\n+      if (depth == 0 &&\n+          is_scaled_iv(exp->in(1), iv, exp_bt, &scale_l, &short_scale_l, depth + 1) &&\n+          is_scaled_iv(exp->in(2), iv, exp_bt, &scale_r, &short_scale_r, depth + 1)) {\n+        \/\/ SubX(iv*K1, iv*K2) => iv*(K1-K2)\n+        jlong scale_diff = java_subtract(scale_l, scale_r);\n+        if (scale_diff > max_signed_integer(exp_bt) || scale_diff <= min_signed_integer(exp_bt)) {\n+          \/\/ This logic is shared by int and long. For int, the result may\n+          \/\/ overflow as we use jlong to compute so do the check here. Long\n+          \/\/ result may also overflow but that's fine because result wraps.\n+          return false;\n+        }\n+        if (p_scale != NULL) {\n+          *p_scale = scale_diff;\n+        }\n+        if (p_short_scale != NULL) {\n+          *p_short_scale = short_scale_l && short_scale_r;\n+        }\n+        return true;\n+      }\n+    }\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":62,"deletions":11,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+ * @run main\/othervm -XX:-TieredCompilation -XX:-BackgroundCompilation -XX:-UseOnStackReplacement -XX:+UseLoopPredicate RangeCheckEliminationScaleNotOne\n@@ -76,0 +77,40 @@\n+\n+        {\n+            int[] array = new int[299];\n+            boolean[] flags = new boolean[100];\n+            Arrays.fill(flags, true);\n+            flags[0] = false;\n+            flags[1] = false;\n+            for (int i = 0; i < 20_000; i++) {\n+                test3(100, array, 1, flags);\n+            }\n+            boolean ex = false;\n+            try {\n+                test3(100, array, -8, flags);\n+            } catch (ArrayIndexOutOfBoundsException aie) {\n+                ex = true;\n+            }\n+            if (!ex) {\n+                throw new RuntimeException(\"no AIOOB exception\");\n+            }\n+        }\n+\n+        {\n+            int[] array = new int[1000];\n+            boolean[] flags = new boolean[100];\n+            Arrays.fill(flags, true);\n+            flags[0] = false;\n+            flags[1] = false;\n+            for (int i = 0; i < 20_000; i++) {\n+                test4(100, array, 302, flags);\n+            }\n+            boolean ex = false;\n+            try {\n+                test4(100, array, 320, flags);\n+            } catch (ArrayIndexOutOfBoundsException aie) {\n+                ex = true;\n+            }\n+            if (!ex) {\n+                throw new RuntimeException(\"no AIOOB exception\");\n+            }\n+        }\n@@ -89,1 +130,0 @@\n-\n@@ -100,0 +140,22 @@\n+\n+    private static int test3(int stop, int[] array, int offset, boolean[] flags) {\n+        if (array == null) {}\n+        int res = 0;\n+        for (int i = 0; i < stop; i++) {\n+            if (flags[i]) {\n+                res += array[3 * i + offset];\n+            }\n+        }\n+        return res;\n+    }\n+\n+    private static int test4(int stop, int[] array, int offset, boolean[] flags) {\n+        if (array == null) {}\n+        int res = 0;\n+        for (int i = 0; i < stop; i++) {\n+            if (flags[i]) {\n+                res += array[7 * i + offset];\n+            }\n+        }\n+        return res;\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/rangechecks\/RangeCheckEliminationScaleNotOne.java","additions":63,"deletions":1,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -0,0 +1,100 @@\n+\/*\n+ * Copyright (c) 2022, Arm Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8289996\n+ * @summary Test range check hoisting for some scaled iv at array index\n+ * @library \/test\/lib \/\n+ * @requires vm.debug & vm.compiler2.enabled & (os.simpleArch == \"x64\" | os.arch == \"aarch64\")\n+ * @modules jdk.incubator.vector\n+ * @compile --enable-preview -source ${jdk.version} TestRangeCheckHoistingScaledIV.java\n+ * @run main\/othervm --enable-preview compiler.rangechecks.TestRangeCheckHoistingScaledIV\n+ *\/\n+\n+package compiler.rangechecks;\n+\n+import java.lang.foreign.MemorySegment;\n+import java.nio.ByteOrder;\n+\n+import jdk.incubator.vector.ByteVector;\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class TestRangeCheckHoistingScaledIV {\n+\n+    \/\/ Inner class for test loops\n+    class Launcher {\n+        private static final int SIZE = 16000;\n+        private static final VectorSpecies<Byte> SPECIES = ByteVector.SPECIES_64;\n+        private static final ByteOrder ORDER = ByteOrder.nativeOrder();\n+\n+        private static byte[] ta = new byte[SIZE];\n+        private static byte[] tb = new byte[SIZE];\n+\n+        private static MemorySegment sa = MemorySegment.ofArray(ta);\n+        private static MemorySegment sb = MemorySegment.ofArray(tb);\n+\n+        private static int count = 789;\n+\n+        \/\/ Normal array accesses with int range checks\n+        public static void scaledIntIV() {\n+            for (int i = 0; i < count; i += 2) {\n+                tb[7 * i] = ta[3 * i];\n+            }\n+        }\n+\n+        \/\/ Memory segment accesses with long range checks\n+        public static void scaledLongIV() {\n+            for (long l = 0; l < count; l += 64) {\n+                ByteVector v = ByteVector.fromMemorySegment(SPECIES, sa, l * 6, ORDER);\n+                v.intoMemorySegment(sb, l * 15, ORDER);\n+            }\n+        }\n+\n+        public static void main(String[] args) {\n+            for (int i = 0; i < 20000; i++) {\n+                scaledIntIV();\n+                scaledLongIV();\n+            }\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(\n+                \"--enable-preview\", \"--add-modules\", \"jdk.incubator.vector\",\n+                \"-Xbatch\", \"-XX:+TraceLoopPredicate\", Launcher.class.getName());\n+        OutputAnalyzer analyzer = new OutputAnalyzer(pb.start());\n+        analyzer.shouldHaveExitValue(0);\n+        analyzer.outputTo(System.out);\n+\n+        \/\/ Check if int range checks are hoisted\n+        analyzer.stdoutShouldContain(\"rc_predicate init * 3\");\n+        analyzer.stdoutShouldContain(\"rc_predicate init * 7\");\n+\n+        \/\/ Check if long range checks are hoisted\n+        analyzer.stdoutShouldContain(\"rc_predicate init * 6\");\n+        analyzer.stdoutShouldContain(\"rc_predicate init * 15\");\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/rangechecks\/TestRangeCheckHoistingScaledIV.java","additions":100,"deletions":0,"binary":false,"changes":100,"status":"added"},{"patch":"@@ -0,0 +1,54 @@\n+\/*\n+ * Copyright (c) 2022, Arm Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.vm.compiler;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.State;\n+\n+@State(Scope.Benchmark)\n+public class RangeCheckHoisting {\n+\n+    private static final int SIZE = 65536;\n+\n+    @Param(\"6789\") private int count;\n+\n+    private static int[] a = new int[SIZE];\n+    private static int[] b = new int[SIZE];\n+\n+    @Benchmark\n+    public void ivScaled3() {\n+        for (int i = 0; i < count; i++) {\n+            b[3 * i] = a[3 * i];\n+        }\n+    }\n+\n+    @Benchmark\n+    public void ivScaled7() {\n+        for (int i = 0; i < count; i++) {\n+            b[7 * i] = a[7 * i];\n+        }\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/RangeCheckHoisting.java","additions":54,"deletions":0,"binary":false,"changes":54,"status":"added"}]}