{"files":[{"patch":"@@ -616,1 +616,4 @@\n-                    if (pt == Type.recoveryType) {\n+                    boolean needsReport = pt == Type.recoveryType ||\n+                            (details.getDiagnosticPosition() != null &&\n+                            details.getDiagnosticPosition().getTree().hasTag(LAMBDA));\n+                    if (needsReport) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,20 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @bug 8262095\n+ * @summary Report diagnostics produced by incorrect lambdas\n+ * @compile\/fail\/ref=T8262095.out -XDrawDiagnostics T8262095.java\n+ *\/\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.stream.Stream;\n+\n+class T8262095 {\n+\n+    void f(Stream<Entry<Long, List<String>>> stream) {\n+        stream.sorted(Entry.comparingByKey()\n+                           .thenComparing((Map.Entry<Long, List<String>> e) -> e.getValue().hashCode()))\n+              .count();\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/lambda\/8262095\/T8262095.java","additions":20,"deletions":0,"binary":false,"changes":20,"status":"added"},{"patch":"@@ -0,0 +1,2 @@\n+T8262095.java:17:42: compiler.err.prob.found.req: (compiler.misc.infer.no.conforming.assignment.exists: U, (compiler.misc.inconvertible.types: java.util.function.Function<java.util.Map.Entry<java.lang.Long,java.util.List<java.lang.String>>,java.lang.Integer>, java.util.function.Function<? super java.util.Map.Entry<K,java.lang.Object>,? extends java.lang.Integer>))\n+1 error\n","filename":"test\/langtools\/tools\/javac\/lambda\/8262095\/T8262095.out","additions":2,"deletions":0,"binary":false,"changes":2,"status":"added"}]}