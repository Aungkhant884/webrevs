{"files":[{"patch":"@@ -257,0 +257,2 @@\n+    ConnectionGraph::print_statistics();\n+    PhaseMacroExpand::print_statistics();\n@@ -2191,0 +2193,3 @@\n+#ifndef PRODUCT\n+        int _prev_scalar_replaced = PhaseMacroExpand::_objs_scalar_replaced_counter;\n+#endif\n@@ -2196,0 +2201,3 @@\n+#ifndef PRODUCT\n+        congraph()->update_escape_state(Atomic::load(&PhaseMacroExpand::_objs_scalar_replaced_counter) - _prev_scalar_replaced);\n+#endif\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -55,1 +55,7 @@\n-  _node_map(C->comp_arena()) {\n+  _node_map(C->comp_arena())\n+#ifndef PRODUCT\n+  , _prev_no_escape(0),\n+  _prev_arg_escape(0),\n+  _prev_global_escape(0)\n+#endif\n+{\n@@ -98,0 +104,4 @@\n+#ifndef PRODUCT\n+  elapsedTimer et;\n+  et.start();\n+#endif\n@@ -105,0 +115,6 @@\n+#ifndef PRODUCT\n+    \/\/ Reset counters when do_analysis is called again so objects are not double counted\n+    Atomic::store(&_no_escape_counter, C->congraph()->_prev_no_escape);\n+    Atomic::store(&_arg_escape_counter, C->congraph()->_prev_arg_escape);\n+    Atomic::store(&_global_escape_counter, C->congraph()->_prev_global_escape);\n+#endif\n@@ -107,0 +123,6 @@\n+#ifndef PRODUCT\n+  \/\/ Save past value of counters in case do_analysis is called again\n+  congraph->_prev_no_escape = Atomic::load(&_no_escape_counter);\n+  congraph->_prev_arg_escape = Atomic::load(&_arg_escape_counter);\n+  congraph->_prev_global_escape = Atomic::load(&_global_escape_counter);\n+#endif\n@@ -119,0 +141,5 @@\n+\n+#ifndef PRODUCT\n+  et.stop();\n+  Atomic::add(&ConnectionGraph::_time_elapsed, et.milliseconds());\n+#endif\n@@ -236,0 +263,3 @@\n+#ifndef PRODUCT\n+    escape_state_statistics(java_objects_worklist);\n+#endif\n@@ -265,1 +295,6 @@\n-  if (C->failing())  return false;\n+  if (C->failing()) {\n+#ifndef PRODUCT\n+    escape_state_statistics(java_objects_worklist);\n+#endif\n+    return false;\n+  }\n@@ -273,0 +308,3 @@\n+#ifndef PRODUCT\n+    escape_state_statistics(java_objects_worklist);\n+#endif\n@@ -342,1 +380,6 @@\n-    if (C->failing())  return false;\n+    if (C->failing()) {\n+#ifndef PRODUCT\n+      escape_state_statistics(java_objects_worklist);\n+#endif\n+      return false;\n+    }\n@@ -378,0 +421,3 @@\n+#ifndef PRODUCT\n+  escape_state_statistics(java_objects_worklist);\n+#endif\n@@ -3634,0 +3680,5 @@\n+int ConnectionGraph::_no_escape_counter = 0;\n+int ConnectionGraph::_arg_escape_counter = 0;\n+int ConnectionGraph::_global_escape_counter = 0;\n+long ConnectionGraph::_time_elapsed = 0;\n+\n@@ -3742,0 +3793,32 @@\n+void ConnectionGraph::print_statistics() {\n+  tty->print_cr(\"No escape: %d\", Atomic::load(&_no_escape_counter));\n+  tty->print_cr(\"Arg escape: %d\", Atomic::load(&_arg_escape_counter));\n+  tty->print_cr(\"Global escape: %d\", Atomic::load(&_global_escape_counter));\n+  tty->print_cr(\"Total java objects in escape analysis: %d\", Atomic::load(&_global_escape_counter) + Atomic::load(&_arg_escape_counter) + Atomic::load(&_no_escape_counter));\n+  tty->print_cr(\"Total time in escape analysis: %7.2f seconds\", Atomic::load(&_time_elapsed) * 0.001);\n+}\n+\n+void ConnectionGraph::update_escape_state(int eliminated) {\n+  _prev_no_escape += eliminated;\n+}\n+\n+void ConnectionGraph::escape_state_statistics(GrowableArray<JavaObjectNode*>& java_objects_worklist) {\n+  for (int next = 0; next < java_objects_worklist.length(); ++next) {\n+    JavaObjectNode* ptn = java_objects_worklist.at(next);\n+    if (ptn->ideal_node()->is_Allocate()) {\n+      if(ptn->escape_state() == PointsToNode::NoEscape) {\n+        Atomic::add(&ConnectionGraph::_no_escape_counter, 1);\n+      }\n+      else if (ptn->escape_state() == PointsToNode::ArgEscape) {\n+        Atomic::add(&ConnectionGraph::_arg_escape_counter, 1);\n+      }\n+      else if (ptn->escape_state() == PointsToNode::GlobalEscape) {\n+        Atomic::add(&ConnectionGraph::_global_escape_counter, 1);\n+      }\n+      else {\n+        assert(false, \"Unexpected Escape State\");\n+      }\n+    }\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/escape.cpp","additions":86,"deletions":3,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -639,0 +639,7 @@\n+  static int _no_escape_counter;\n+  static int _arg_escape_counter;\n+  static int _global_escape_counter;\n+  int _prev_no_escape;\n+  int _prev_arg_escape;\n+  int _prev_global_escape;\n+  static long _time_elapsed;\n@@ -640,0 +647,3 @@\n+  static void print_statistics();\n+  void update_escape_state(int eliminated);\n+  void escape_state_statistics(GrowableArray<JavaObjectNode*>& java_objects_worklist);\n","filename":"src\/hotspot\/share\/opto\/escape.hpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -162,0 +162,3 @@\n+#ifndef PRODUCT\n+  Atomic::add(&PhaseMacroExpand::_GC_barriers_removed_counter, 1);\n+#endif\n@@ -2313,0 +2316,4 @@\n+  #ifndef PRODUCT\n+    int membar_before = count_MemBar();\n+  #endif\n+\n@@ -2337,0 +2344,5 @@\n+#ifndef PRODUCT\n+        if(success) {\n+          Atomic::add(&PhaseMacroExpand::_monitor_objects_removed_counter, 1);\n+        }\n+#endif\n@@ -2355,0 +2367,5 @@\n+#ifndef PRODUCT\n+        if(success){\n+          Atomic::add(&PhaseMacroExpand::_objs_scalar_replaced_counter, 1);\n+        }\n+#endif\n@@ -2384,0 +2401,4 @@\n+#ifndef PRODUCT\n+  int membar_after = count_MemBar();\n+  Atomic::add(&PhaseMacroExpand::_memory_barriers_removed_counter, membar_before - membar_after);\n+#endif\n@@ -2572,0 +2593,32 @@\n+\n+#ifndef PRODUCT\n+int PhaseMacroExpand::_objs_scalar_replaced_counter = 0;\n+int PhaseMacroExpand::_monitor_objects_removed_counter = 0;\n+int PhaseMacroExpand::_GC_barriers_removed_counter = 0;\n+int PhaseMacroExpand::_memory_barriers_removed_counter = 0;\n+\n+void PhaseMacroExpand::print_statistics() {\n+  tty->print_cr(\"Objects scalar replaced: %d\", Atomic::load(&_objs_scalar_replaced_counter));\n+  tty->print_cr(\"Monitor objects removed: %d\", Atomic::load(&_monitor_objects_removed_counter));\n+  tty->print_cr(\"GC barriers removed: %d\", Atomic::load(&_GC_barriers_removed_counter));\n+  tty->print_cr(\"Memory barriers removed: %d\", Atomic::load(&_memory_barriers_removed_counter));\n+}\n+\n+int PhaseMacroExpand::count_MemBar() {\n+  Unique_Node_List ideal_nodes;\n+  int total = 0;\n+  ideal_nodes.map(C->live_nodes(), NULL);\n+  ideal_nodes.push(C->root());\n+  for( uint next = 0; next < ideal_nodes.size(); ++next ) {\n+    Node* n = ideal_nodes.at(next);\n+    if (n->is_MemBar()) {\n+      total++;\n+    }\n+    for (DUIterator_Fast imax, i = n->fast_outs(imax); i < imax; i++) {\n+      Node* m = n->fast_out(i);\n+      ideal_nodes.push(m);\n+    }\n+  }\n+  return total;\n+}\n+#endif\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":53,"deletions":0,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -211,0 +211,9 @@\n+  #ifndef PRODUCT\n+    static int _objs_scalar_replaced_counter;\n+    static int _monitor_objects_removed_counter;\n+    static int _GC_barriers_removed_counter;\n+    static int _memory_barriers_removed_counter;\n+    static void print_statistics();\n+    int count_MemBar();\n+  #endif\n+\n","filename":"src\/hotspot\/share\/opto\/macro.hpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"}]}