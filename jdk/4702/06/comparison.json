{"files":[{"patch":"@@ -28,0 +28,5 @@\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.DoubleSupplier;\n+import java.util.function.LongSupplier;\n+import java.util.function.ToDoubleFunction;\n+\n@@ -31,2 +36,0 @@\n-\n-import java.util.concurrent.TimeUnit;\n@@ -45,2 +48,124 @@\n-    private long usageTicks = 0; \/\/ used for cpu load calculation\n-    private long totalTicks = 0; \/\/ used for cpu load calculation\n+    private ContainerCpuTicks systemLoadTicks = new SystemCpuTicks();\n+    private ContainerCpuTicks processLoadTicks = new ProcessCpuTicks();\n+\n+    private abstract class ContainerCpuTicks {\n+        private long usageTicks = 0;\n+        private long totalTicks = 0;\n+\n+        private double getUsageDividesTotal(long usageTicks, long totalTicks) {\n+            \/\/ If cpu quota or cpu shares are in effect. Calculate the cpu load\n+            \/\/ based on the following formula (similar to how\n+            \/\/ getCpuLoad0() is being calculated):\n+            \/\/\n+            \/\/   | usageTicks - usageTicks' |\n+            \/\/  ------------------------------\n+            \/\/   | totalTicks - totalTicks' |\n+            \/\/\n+            \/\/ where usageTicks' and totalTicks' are historical values\n+            \/\/ retrieved via an earlier call of this method.\n+            if (usageTicks < 0 || totalTicks <= 0) {\n+                return -1;\n+            }\n+            long distance = usageTicks - this.usageTicks;\n+            this.usageTicks = usageTicks;\n+            long totalDistance = totalTicks - this.totalTicks;\n+            this.totalTicks = totalTicks;\n+            double systemLoad = 0.0;\n+            if (distance > 0 && totalDistance > 0) {\n+                systemLoad = ((double)distance) \/ totalDistance;\n+            }\n+            \/\/ Ensure the return value is in the range 0.0 -> 1.0\n+            systemLoad = Math.max(0.0, systemLoad);\n+            systemLoad = Math.min(1.0, systemLoad);\n+            return systemLoad;\n+        }\n+\n+        public double getContainerCpuLoad() {\n+            assert(containerMetrics != null);\n+            long quota = containerMetrics.getCpuQuota();\n+            long share = containerMetrics.getCpuShares();\n+            if (quota > 0) {\n+                long numPeriods = containerMetrics.getCpuNumPeriods();\n+                long quotaNanos = TimeUnit.MICROSECONDS.toNanos(quota * numPeriods);\n+                return getUsageDividesTotal(cpuUsageSupplier().getAsLong(), quotaNanos);\n+            } else if (share > 0) {\n+                long hostTicks = getHostTotalCpuTicks0();\n+                int totalCPUs = getHostOnlineCpuCount0();\n+                int containerCPUs = getAvailableProcessors();\n+                \/\/ scale the total host load to the actual container cpus\n+                hostTicks = hostTicks * containerCPUs \/ totalCPUs;\n+                return getUsageDividesTotal(cpuUsageSupplier().getAsLong(), hostTicks);\n+            } else {\n+                if (isCpuSetSameAsHostCpuSet()) {\n+                    return defaultCpuLoadSupplier().getAsDouble();\n+                } else {\n+                    int[] cpuSet = containerMetrics.getEffectiveCpuSetCpus();\n+                    if (cpuSet == null || cpuSet.length <= 0) {\n+                        cpuSet = containerMetrics.getCpuSetCpus();\n+                    }\n+                    if (cpuSet == null) {\n+                        return defaultCpuLoadSupplier().getAsDouble();\n+                    } else if (cpuSet.length > 0) {\n+                        return cpuSetCalc().applyAsDouble(cpuSet);\n+                    }\n+                    return -1;\n+                }\n+            }\n+        }\n+\n+        protected abstract DoubleSupplier defaultCpuLoadSupplier();\n+        protected abstract ToDoubleFunction<int[]> cpuSetCalc();\n+        protected abstract LongSupplier cpuUsageSupplier();\n+    }\n+\n+    private class ProcessCpuTicks extends ContainerCpuTicks {\n+\n+        @Override\n+        protected DoubleSupplier defaultCpuLoadSupplier() {\n+            return () -> getProcessCpuLoad0();\n+        }\n+\n+        @Override\n+        protected ToDoubleFunction<int[]> cpuSetCalc() {\n+            return (int[] cpuSet) -> {\n+                int totalCPUs = getHostOnlineCpuCount0();\n+                int containerCPUs = getAvailableProcessors();\n+                return Math.min(1.0, getProcessCpuLoad0() * totalCPUs \/ containerCPUs);\n+            };\n+        }\n+\n+        @Override\n+        protected LongSupplier cpuUsageSupplier() {\n+            return () ->  getProcessCpuTime();\n+        }\n+\n+    }\n+\n+    private class SystemCpuTicks extends ContainerCpuTicks {\n+\n+        @Override\n+        protected DoubleSupplier defaultCpuLoadSupplier() {\n+            return () -> getCpuLoad0();\n+        }\n+\n+        @Override\n+        protected ToDoubleFunction<int[]> cpuSetCalc() {\n+            return (int[] cpuSet) -> {\n+                double systemLoad = 0.0;\n+                for (int cpu : cpuSet) {\n+                    double cpuLoad = getSingleCpuLoad0(cpu);\n+                    if (cpuLoad < 0) {\n+                        return -1;\n+                    }\n+                    systemLoad += cpuLoad;\n+                }\n+                return systemLoad \/ cpuSet.length;\n+            };\n+        }\n+\n+        @Override\n+        protected LongSupplier cpuUsageSupplier() {\n+            return () -> containerMetrics.getCpuUsage();\n+        }\n+\n+    }\n@@ -137,32 +262,0 @@\n-    private double getUsageDividesTotal(long usageTicks, long totalTicks) {\n-        \/\/ If cpu quota or cpu shares are in effect calculate the cpu load\n-        \/\/ based on the following formula (similar to how\n-        \/\/ getCpuLoad0() is being calculated):\n-        \/\/\n-        \/\/   | usageTicks - usageTicks' |\n-        \/\/  ------------------------------\n-        \/\/   | totalTicks - totalTicks' |\n-        \/\/\n-        \/\/ where usageTicks' and totalTicks' are historical values\n-        \/\/ retrieved via an earlier call of this method.\n-        \/\/\n-        \/\/ Total ticks should be scaled to the container effective number\n-        \/\/ of cpus, if cpu shares are in effect.\n-        if (usageTicks < 0 || totalTicks <= 0) {\n-            return -1;\n-        }\n-        long distance = usageTicks - this.usageTicks;\n-        this.usageTicks = usageTicks;\n-        long totalDistance = totalTicks - this.totalTicks;\n-        this.totalTicks = totalTicks;\n-\n-        double systemLoad = 0.0;\n-        if (distance > 0 && totalDistance > 0) {\n-            systemLoad = ((double)distance) \/ totalDistance;\n-        }\n-        \/\/ Ensure the return value is in the range 0.0 -> 1.0\n-        systemLoad = Math.max(0.0, systemLoad);\n-        systemLoad = Math.min(1.0, systemLoad);\n-        return systemLoad;\n-    }\n-\n@@ -171,45 +264,1 @@\n-            long quota = containerMetrics.getCpuQuota();\n-            long share = containerMetrics.getCpuShares();\n-            long usageNanos = containerMetrics.getCpuUsage();\n-            if (quota > 0) {\n-                long numPeriods = containerMetrics.getCpuNumPeriods();\n-                long quotaNanos = TimeUnit.MICROSECONDS.toNanos(quota * numPeriods);\n-                return getUsageDividesTotal(usageNanos, quotaNanos);\n-            } else if (share > 0) {\n-                long hostTicks = getHostTotalCpuTicks0();\n-                int totalCPUs = getHostOnlineCpuCount0();\n-                int containerCPUs = getAvailableProcessors();\n-                \/\/ scale the total host load to the actual container cpus\n-                hostTicks = hostTicks * containerCPUs \/ totalCPUs;\n-                return getUsageDividesTotal(usageNanos, hostTicks);\n-            } else {\n-                \/\/ If CPU quotas and shares are not active then find the average system load for\n-                \/\/ all online CPUs that are allowed to run this container.\n-\n-                \/\/ If the cpuset is the same as the host's one there is no need to iterate over each CPU\n-                if (isCpuSetSameAsHostCpuSet()) {\n-                    return getCpuLoad0();\n-                } else {\n-                    int[] cpuSet = containerMetrics.getEffectiveCpuSetCpus();\n-                    \/\/ in case the effectiveCPUSetCpus are not available, attempt to use just cpusets.cpus\n-                    if (cpuSet == null || cpuSet.length <= 0) {\n-                        cpuSet = containerMetrics.getCpuSetCpus();\n-                    }\n-                    if (cpuSet == null) {\n-                        \/\/ cgroups is mounted, but CPU resource is not limited.\n-                        \/\/ We can assume the VM is run on the host CPUs.\n-                        return getCpuLoad0();\n-                    } else if (cpuSet.length > 0) {\n-                        double systemLoad = 0.0;\n-                        for (int cpu : cpuSet) {\n-                            double cpuLoad = getSingleCpuLoad0(cpu);\n-                            if (cpuLoad < 0) {\n-                                return -1;\n-                            }\n-                            systemLoad += cpuLoad;\n-                        }\n-                        return systemLoad \/ cpuSet.length;\n-                    }\n-                    return -1;\n-                }\n-            }\n+            return systemLoadTicks.getContainerCpuLoad();\n@@ -221,0 +270,3 @@\n+        if (containerMetrics != null) {\n+            return processLoadTicks.getContainerCpuLoad();\n+        }\n","filename":"src\/jdk.management\/unix\/classes\/com\/sun\/management\/internal\/OperatingSystemImpl.java","additions":133,"deletions":81,"binary":false,"changes":214,"status":"modified"}]}