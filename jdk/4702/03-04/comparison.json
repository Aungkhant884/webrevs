{"files":[{"patch":"@@ -33,0 +33,2 @@\n+import java.util.function.DoubleSupplier;\n+import java.util.function.ToDoubleFunction;\n@@ -53,0 +55,5 @@\n+    private enum CpuLoadTarget {\n+        CPU_LOAD_VM_ONLY,\n+        CPU_LOAD_GLOBAL\n+    }\n+\n@@ -173,11 +180,25 @@\n-    public double getCpuLoad() {\n-        if (containerMetrics != null) {\n-            long quota = containerMetrics.getCpuQuota();\n-            long share = containerMetrics.getCpuShares();\n-            long usageNanos = containerMetrics.getCpuUsage();\n-            if (quota > 0) {\n-                long numPeriods = containerMetrics.getCpuNumPeriods();\n-                long quotaNanos = TimeUnit.MICROSECONDS.toNanos(quota * numPeriods);\n-                return getUsageDividesTotal(usageNanos, quotaNanos, this.systemLoadTicks);\n-            } else if (share > 0) {\n-                long hostTicks = getHostTotalCpuTicks0();\n+    public double getCpuLoadWithTarget(CpuLoadTarget cpuLoadTarget) {\n+        long usageNanos = -1;\n+        CpuTicks cpuTicks = null;\n+        DoubleSupplier defaultCpuSupplier = null;\n+        ToDoubleFunction<int[]> cpuSetFunction = null;\n+        if(cpuLoadTarget == CpuLoadTarget.CPU_LOAD_GLOBAL) {\n+            usageNanos = containerMetrics.getCpuUsage();\n+            cpuTicks = this.systemLoadTicks;\n+            defaultCpuSupplier = () -> getCpuLoad0();\n+            cpuSetFunction = (int[] cpuSet) ->{\n+                double systemLoad = 0.0;\n+                for (int cpu : cpuSet) {\n+                    double cpuLoad = getSingleCpuLoad0(cpu);\n+                    if (cpuLoad < 0) {\n+                        return -1;\n+                    }\n+                    systemLoad += cpuLoad;\n+                }\n+                return systemLoad \/ cpuSet.length;\n+            };\n+        } else if (cpuLoadTarget == CpuLoadTarget.CPU_LOAD_VM_ONLY) {\n+            usageNanos = getProcessCpuTime();\n+            cpuTicks = this.processLoadTicks;\n+            defaultCpuSupplier = ()-> getProcessCpuLoad0();\n+            cpuSetFunction = (int[] cpuSet) ->{\n@@ -186,3 +207,19 @@\n-                \/\/ scale the total host load to the actual container cpus\n-                hostTicks = hostTicks * containerCPUs \/ totalCPUs;\n-                return getUsageDividesTotal(usageNanos, hostTicks, this.systemLoadTicks);\n+                return getProcessCpuLoad0() * totalCPUs \/ containerCPUs;\n+            };\n+        }\n+        long quota = containerMetrics.getCpuQuota();\n+        long share = containerMetrics.getCpuShares();\n+        if (quota > 0) {\n+            long numPeriods = containerMetrics.getCpuNumPeriods();\n+            long quotaNanos = TimeUnit.MICROSECONDS.toNanos(quota * numPeriods);\n+            return getUsageDividesTotal(usageNanos, quotaNanos, cpuTicks);\n+        } else if (share > 0) {\n+            long hostTicks = getHostTotalCpuTicks0();\n+            int totalCPUs = getHostOnlineCpuCount0();\n+            int containerCPUs = getAvailableProcessors();\n+            \/\/ scale the total host load to the actual container cpus\n+            hostTicks = hostTicks * containerCPUs \/ totalCPUs;\n+            return getUsageDividesTotal(usageNanos, hostTicks, cpuTicks);\n+        } else {\n+            if (isCpuSetSameAsHostCpuSet()) {\n+                return defaultCpuSupplier.getAsDouble();\n@@ -190,28 +227,8 @@\n-                \/\/ If CPU quotas and shares are not active then find the average system load for\n-                \/\/ all online CPUs that are allowed to run this container.\n-\n-                \/\/ If the cpuset is the same as the host's one there is no need to iterate over each CPU\n-                if (isCpuSetSameAsHostCpuSet()) {\n-                    return getCpuLoad0();\n-                } else {\n-                    int[] cpuSet = containerMetrics.getEffectiveCpuSetCpus();\n-                    \/\/ in case the effectiveCPUSetCpus are not available, attempt to use just cpusets.cpus\n-                    if (cpuSet == null || cpuSet.length <= 0) {\n-                        cpuSet = containerMetrics.getCpuSetCpus();\n-                    }\n-                    if (cpuSet == null) {\n-                        \/\/ cgroups is mounted, but CPU resource is not limited.\n-                        \/\/ We can assume the VM is run on the host CPUs.\n-                        return getCpuLoad0();\n-                    } else if (cpuSet.length > 0) {\n-                        double systemLoad = 0.0;\n-                        for (int cpu : cpuSet) {\n-                            double cpuLoad = getSingleCpuLoad0(cpu);\n-                            if (cpuLoad < 0) {\n-                                return -1;\n-                            }\n-                            systemLoad += cpuLoad;\n-                        }\n-                        return systemLoad \/ cpuSet.length;\n-                    }\n-                    return -1;\n+                int[] cpuSet = containerMetrics.getEffectiveCpuSetCpus();\n+                if (cpuSet == null || cpuSet.length <= 0) {\n+                    cpuSet = containerMetrics.getCpuSetCpus();\n+                }\n+                if (cpuSet == null) {\n+                    return defaultCpuSupplier.getAsDouble();\n+                } else if (cpuSet.length > 0) {\n+                    return cpuSetFunction.applyAsDouble(cpuSet);\n@@ -219,0 +236,1 @@\n+                return -1;\n@@ -221,0 +239,6 @@\n+    }\n+\n+    public double getCpuLoad() {\n+        if (containerMetrics != null) {\n+            return getCpuLoadWithTarget(CpuLoadTarget.CPU_LOAD_GLOBAL);\n+        }\n@@ -226,32 +250,1 @@\n-            long quota = containerMetrics.getCpuQuota();\n-            long share = containerMetrics.getCpuShares();\n-            long usageNanos = getProcessCpuTime();\n-            if (quota > 0) {\n-                long numPeriods = containerMetrics.getCpuNumPeriods();\n-                long quotaNanos = TimeUnit.MICROSECONDS.toNanos(quota * numPeriods);\n-                return getUsageDividesTotal(usageNanos, quotaNanos, this.processLoadTicks);\n-            } else if (share > 0) {\n-                long hostTicks = getHostTotalCpuTicks0();\n-                int totalCPUs = getHostOnlineCpuCount0();\n-                int containerCPUs = getAvailableProcessors();\n-                \/\/ scale the total host load to the actual container cpus\n-                hostTicks = hostTicks * containerCPUs \/ totalCPUs;\n-                return getUsageDividesTotal(usageNanos, hostTicks, this.processLoadTicks);\n-            } else {\n-                if (isCpuSetSameAsHostCpuSet()) {\n-                    return getProcessCpuLoad0();\n-                } else {\n-                    int[] cpuSet = containerMetrics.getEffectiveCpuSetCpus();\n-                    if (cpuSet == null || cpuSet.length <= 0) {\n-                        cpuSet = containerMetrics.getCpuSetCpus();\n-                    }\n-                    if (cpuSet == null) {\n-                        return getProcessCpuLoad0();\n-                    } else if (cpuSet.length > 0) {\n-                        int totalCPUs = getHostOnlineCpuCount0();\n-                        int containerCPUs = getAvailableProcessors();\n-                        return getProcessCpuLoad0() * totalCPUs \/ containerCPUs;\n-                    }\n-                    return -1;\n-                }\n-            }\n+            return getCpuLoadWithTarget(CpuLoadTarget.CPU_LOAD_VM_ONLY);\n","filename":"src\/jdk.management\/unix\/classes\/com\/sun\/management\/internal\/OperatingSystemImpl.java","additions":67,"deletions":74,"binary":false,"changes":141,"status":"modified"}]}