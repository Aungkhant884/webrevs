{"files":[{"patch":"@@ -33,0 +33,2 @@\n+import java.util.function.DoubleSupplier;\n+import java.util.function.ToDoubleFunction;\n@@ -45,2 +47,12 @@\n-    private long usageTicks = 0; \/\/ used for cpu load calculation\n-    private long totalTicks = 0; \/\/ used for cpu load calculation\n+    private CpuTicks systemLoadTicks = new CpuTicks();\n+    private CpuTicks processLoadTicks = new CpuTicks();\n+\n+    private class CpuTicks {\n+        long usageTicks = 0;\n+        long totalTicks = 0;\n+    }\n+\n+    private enum CpuLoadTarget {\n+        CPU_LOAD_VM_ONLY,\n+        CPU_LOAD_GLOBAL\n+    }\n@@ -137,1 +149,1 @@\n-    private double getUsageDividesTotal(long usageTicks, long totalTicks) {\n+    private double getUsageDividesTotal(long usageTicks, long totalTicks, CpuTicks cpuTicks) {\n@@ -154,5 +166,4 @@\n-        long distance = usageTicks - this.usageTicks;\n-        this.usageTicks = usageTicks;\n-        long totalDistance = totalTicks - this.totalTicks;\n-        this.totalTicks = totalTicks;\n-\n+        long distance = usageTicks - cpuTicks.usageTicks;\n+        cpuTicks.usageTicks = usageTicks;\n+        long totalDistance = totalTicks - cpuTicks.totalTicks;\n+        cpuTicks.totalTicks = totalTicks;\n@@ -169,11 +180,25 @@\n-    public double getCpuLoad() {\n-        if (containerMetrics != null) {\n-            long quota = containerMetrics.getCpuQuota();\n-            long share = containerMetrics.getCpuShares();\n-            long usageNanos = containerMetrics.getCpuUsage();\n-            if (quota > 0) {\n-                long numPeriods = containerMetrics.getCpuNumPeriods();\n-                long quotaNanos = TimeUnit.MICROSECONDS.toNanos(quota * numPeriods);\n-                return getUsageDividesTotal(usageNanos, quotaNanos);\n-            } else if (share > 0) {\n-                long hostTicks = getHostTotalCpuTicks0();\n+    public double getCpuLoadWithTarget(CpuLoadTarget cpuLoadTarget) {\n+        long usageNanos = -1;\n+        CpuTicks cpuTicks = null;\n+        DoubleSupplier defaultCpuSupplier = null;\n+        ToDoubleFunction<int[]> cpuSetFunction = null;\n+        if(cpuLoadTarget == CpuLoadTarget.CPU_LOAD_GLOBAL) {\n+            usageNanos = containerMetrics.getCpuUsage();\n+            cpuTicks = this.systemLoadTicks;\n+            defaultCpuSupplier = () -> getCpuLoad0();\n+            cpuSetFunction = (int[] cpuSet) ->{\n+                double systemLoad = 0.0;\n+                for (int cpu : cpuSet) {\n+                    double cpuLoad = getSingleCpuLoad0(cpu);\n+                    if (cpuLoad < 0) {\n+                        return -1;\n+                    }\n+                    systemLoad += cpuLoad;\n+                }\n+                return systemLoad \/ cpuSet.length;\n+            };\n+        } else if (cpuLoadTarget == CpuLoadTarget.CPU_LOAD_VM_ONLY) {\n+            usageNanos = getProcessCpuTime();\n+            cpuTicks = this.processLoadTicks;\n+            defaultCpuSupplier = ()-> getProcessCpuLoad0();\n+            cpuSetFunction = (int[] cpuSet) ->{\n@@ -182,3 +207,19 @@\n-                \/\/ scale the total host load to the actual container cpus\n-                hostTicks = hostTicks * containerCPUs \/ totalCPUs;\n-                return getUsageDividesTotal(usageNanos, hostTicks);\n+                return getProcessCpuLoad0() * totalCPUs \/ containerCPUs;\n+            };\n+        }\n+        long quota = containerMetrics.getCpuQuota();\n+        long share = containerMetrics.getCpuShares();\n+        if (quota > 0) {\n+            long numPeriods = containerMetrics.getCpuNumPeriods();\n+            long quotaNanos = TimeUnit.MICROSECONDS.toNanos(quota * numPeriods);\n+            return getUsageDividesTotal(usageNanos, quotaNanos, cpuTicks);\n+        } else if (share > 0) {\n+            long hostTicks = getHostTotalCpuTicks0();\n+            int totalCPUs = getHostOnlineCpuCount0();\n+            int containerCPUs = getAvailableProcessors();\n+            \/\/ scale the total host load to the actual container cpus\n+            hostTicks = hostTicks * containerCPUs \/ totalCPUs;\n+            return getUsageDividesTotal(usageNanos, hostTicks, cpuTicks);\n+        } else {\n+            if (isCpuSetSameAsHostCpuSet()) {\n+                return defaultCpuSupplier.getAsDouble();\n@@ -186,28 +227,3 @@\n-                \/\/ If CPU quotas and shares are not active then find the average system load for\n-                \/\/ all online CPUs that are allowed to run this container.\n-\n-                \/\/ If the cpuset is the same as the host's one there is no need to iterate over each CPU\n-                if (isCpuSetSameAsHostCpuSet()) {\n-                    return getCpuLoad0();\n-                } else {\n-                    int[] cpuSet = containerMetrics.getEffectiveCpuSetCpus();\n-                    \/\/ in case the effectiveCPUSetCpus are not available, attempt to use just cpusets.cpus\n-                    if (cpuSet == null || cpuSet.length <= 0) {\n-                        cpuSet = containerMetrics.getCpuSetCpus();\n-                    }\n-                    if (cpuSet == null) {\n-                        \/\/ cgroups is mounted, but CPU resource is not limited.\n-                        \/\/ We can assume the VM is run on the host CPUs.\n-                        return getCpuLoad0();\n-                    } else if (cpuSet.length > 0) {\n-                        double systemLoad = 0.0;\n-                        for (int cpu : cpuSet) {\n-                            double cpuLoad = getSingleCpuLoad0(cpu);\n-                            if (cpuLoad < 0) {\n-                                return -1;\n-                            }\n-                            systemLoad += cpuLoad;\n-                        }\n-                        return systemLoad \/ cpuSet.length;\n-                    }\n-                    return -1;\n+                int[] cpuSet = containerMetrics.getEffectiveCpuSetCpus();\n+                if (cpuSet == null || cpuSet.length <= 0) {\n+                    cpuSet = containerMetrics.getCpuSetCpus();\n@@ -215,0 +231,6 @@\n+                if (cpuSet == null) {\n+                    return defaultCpuSupplier.getAsDouble();\n+                } else if (cpuSet.length > 0) {\n+                    return cpuSetFunction.applyAsDouble(cpuSet);\n+                }\n+                return -1;\n@@ -217,0 +239,6 @@\n+    }\n+\n+    public double getCpuLoad() {\n+        if (containerMetrics != null) {\n+            return getCpuLoadWithTarget(CpuLoadTarget.CPU_LOAD_GLOBAL);\n+        }\n@@ -221,0 +249,3 @@\n+        if (containerMetrics != null) {\n+            return getCpuLoadWithTarget(CpuLoadTarget.CPU_LOAD_VM_ONLY);\n+        }\n","filename":"src\/jdk.management\/unix\/classes\/com\/sun\/management\/internal\/OperatingSystemImpl.java","additions":81,"deletions":50,"binary":false,"changes":131,"status":"modified"}]}