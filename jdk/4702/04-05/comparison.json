{"files":[{"patch":"@@ -28,4 +28,0 @@\n-import jdk.internal.platform.Metrics;\n-import sun.management.BaseOperatingSystemImpl;\n-import sun.management.VMManagement;\n-\n@@ -34,0 +30,1 @@\n+import java.util.function.LongSupplier;\n@@ -35,0 +32,4 @@\n+\n+import jdk.internal.platform.Metrics;\n+import sun.management.BaseOperatingSystemImpl;\n+import sun.management.VMManagement;\n@@ -47,2 +48,93 @@\n-    private CpuTicks systemLoadTicks = new CpuTicks();\n-    private CpuTicks processLoadTicks = new CpuTicks();\n+    private ContainerCpuTicks systemLoadTicks = new SystemCpuTicks();\n+    private ContainerCpuTicks processLoadTicks = new ProcessCpuTicks();\n+\n+    private abstract class ContainerCpuTicks {\n+        private long usageTicks = 0;\n+        private long totalTicks = 0;\n+\n+        private double getUsageDividesTotal(long usageTicks, long totalTicks) {\n+            \/\/ If cpu quota or cpu shares are in effect. Calculate the cpu load\n+            \/\/ based on the following formula (similar to how\n+            \/\/ getCpuLoad0() is being calculated):\n+            \/\/\n+            \/\/   | usageTicks - usageTicks' |\n+            \/\/  ------------------------------\n+            \/\/   | totalTicks - totalTicks' |\n+            \/\/\n+            \/\/ where usageTicks' and totalTicks' are historical values\n+            \/\/ retrieved via an earlier call of this method.\n+            if (usageTicks < 0 || totalTicks <= 0) {\n+                return -1;\n+            }\n+            long distance = usageTicks - this.usageTicks;\n+            this.usageTicks = usageTicks;\n+            long totalDistance = totalTicks - this.totalTicks;\n+            this.totalTicks = totalTicks;\n+            double systemLoad = 0.0;\n+            if (distance > 0 && totalDistance > 0) {\n+                systemLoad = ((double)distance) \/ totalDistance;\n+            }\n+            \/\/ Ensure the return value is in the range 0.0 -> 1.0\n+            systemLoad = Math.max(0.0, systemLoad);\n+            systemLoad = Math.min(1.0, systemLoad);\n+            return systemLoad;\n+        }\n+\n+        public double getContainerCpuLoad() {\n+            assert(containerMetrics != null);\n+            long quota = containerMetrics.getCpuQuota();\n+            long share = containerMetrics.getCpuShares();\n+            if (quota > 0) {\n+                long numPeriods = containerMetrics.getCpuNumPeriods();\n+                long quotaNanos = TimeUnit.MICROSECONDS.toNanos(quota * numPeriods);\n+                return getUsageDividesTotal(cpuUsageSupplier().getAsLong(), quotaNanos);\n+            } else if (share > 0) {\n+                long hostTicks = getHostTotalCpuTicks0();\n+                int totalCPUs = getHostOnlineCpuCount0();\n+                int containerCPUs = getAvailableProcessors();\n+                \/\/ scale the total host load to the actual container cpus\n+                hostTicks = hostTicks * containerCPUs \/ totalCPUs;\n+                return getUsageDividesTotal(cpuUsageSupplier().getAsLong(), hostTicks);\n+            } else {\n+                if (isCpuSetSameAsHostCpuSet()) {\n+                    return defaultCpuLoadSupplier().getAsDouble();\n+                } else {\n+                    int[] cpuSet = containerMetrics.getEffectiveCpuSetCpus();\n+                    if (cpuSet == null || cpuSet.length <= 0) {\n+                        cpuSet = containerMetrics.getCpuSetCpus();\n+                    }\n+                    if (cpuSet == null) {\n+                        return defaultCpuLoadSupplier().getAsDouble();\n+                    } else if (cpuSet.length > 0) {\n+                        return cpuSetCalc().applyAsDouble(cpuSet);\n+                    }\n+                    return -1;\n+                }\n+            }\n+        }\n+\n+        protected abstract DoubleSupplier defaultCpuLoadSupplier();\n+        protected abstract ToDoubleFunction<int[]> cpuSetCalc();\n+        protected abstract LongSupplier cpuUsageSupplier();\n+    }\n+\n+    private class ProcessCpuTicks extends ContainerCpuTicks {\n+\n+        @Override\n+        protected DoubleSupplier defaultCpuLoadSupplier() {\n+            return () -> getProcessCpuLoad0();\n+        }\n+\n+        @Override\n+        protected ToDoubleFunction<int[]> cpuSetCalc() {\n+            return (int[] cpuSet) -> {\n+                int totalCPUs = getHostOnlineCpuCount0();\n+                int containerCPUs = getAvailableProcessors();\n+                return getProcessCpuLoad0() * totalCPUs \/ containerCPUs;\n+            };\n+        }\n+\n+        @Override\n+        protected LongSupplier cpuUsageSupplier() {\n+            return () ->  getProcessCpuTime();\n+        }\n@@ -50,3 +142,0 @@\n-    private class CpuTicks {\n-        long usageTicks = 0;\n-        long totalTicks = 0;\n@@ -55,3 +144,27 @@\n-    private enum CpuLoadTarget {\n-        CPU_LOAD_VM_ONLY,\n-        CPU_LOAD_GLOBAL\n+    private class SystemCpuTicks extends ContainerCpuTicks {\n+\n+        @Override\n+        protected DoubleSupplier defaultCpuLoadSupplier() {\n+            return () -> getCpuLoad0();\n+        }\n+\n+        @Override\n+        protected ToDoubleFunction<int[]> cpuSetCalc() {\n+            return (int[] cpuSet) -> {\n+                double systemLoad = 0.0;\n+                for (int cpu : cpuSet) {\n+                    double cpuLoad = getSingleCpuLoad0(cpu);\n+                    if (cpuLoad < 0) {\n+                        return -1;\n+                    }\n+                    systemLoad += cpuLoad;\n+                }\n+                return systemLoad \/ cpuSet.length;\n+            };\n+        }\n+\n+        @Override\n+        protected LongSupplier cpuUsageSupplier() {\n+            return () -> containerMetrics.getCpuUsage();\n+        }\n+\n@@ -149,92 +262,0 @@\n-    private double getUsageDividesTotal(long usageTicks, long totalTicks, CpuTicks cpuTicks) {\n-        \/\/ If cpu quota or cpu shares are in effect calculate the cpu load\n-        \/\/ based on the following formula (similar to how\n-        \/\/ getCpuLoad0() is being calculated):\n-        \/\/\n-        \/\/   | usageTicks - usageTicks' |\n-        \/\/  ------------------------------\n-        \/\/   | totalTicks - totalTicks' |\n-        \/\/\n-        \/\/ where usageTicks' and totalTicks' are historical values\n-        \/\/ retrieved via an earlier call of this method.\n-        \/\/\n-        \/\/ Total ticks should be scaled to the container effective number\n-        \/\/ of cpus, if cpu shares are in effect.\n-        if (usageTicks < 0 || totalTicks <= 0) {\n-            return -1;\n-        }\n-        long distance = usageTicks - cpuTicks.usageTicks;\n-        cpuTicks.usageTicks = usageTicks;\n-        long totalDistance = totalTicks - cpuTicks.totalTicks;\n-        cpuTicks.totalTicks = totalTicks;\n-        double systemLoad = 0.0;\n-        if (distance > 0 && totalDistance > 0) {\n-            systemLoad = ((double)distance) \/ totalDistance;\n-        }\n-        \/\/ Ensure the return value is in the range 0.0 -> 1.0\n-        systemLoad = Math.max(0.0, systemLoad);\n-        systemLoad = Math.min(1.0, systemLoad);\n-        return systemLoad;\n-    }\n-\n-    public double getCpuLoadWithTarget(CpuLoadTarget cpuLoadTarget) {\n-        long usageNanos = -1;\n-        CpuTicks cpuTicks = null;\n-        DoubleSupplier defaultCpuSupplier = null;\n-        ToDoubleFunction<int[]> cpuSetFunction = null;\n-        if(cpuLoadTarget == CpuLoadTarget.CPU_LOAD_GLOBAL) {\n-            usageNanos = containerMetrics.getCpuUsage();\n-            cpuTicks = this.systemLoadTicks;\n-            defaultCpuSupplier = () -> getCpuLoad0();\n-            cpuSetFunction = (int[] cpuSet) ->{\n-                double systemLoad = 0.0;\n-                for (int cpu : cpuSet) {\n-                    double cpuLoad = getSingleCpuLoad0(cpu);\n-                    if (cpuLoad < 0) {\n-                        return -1;\n-                    }\n-                    systemLoad += cpuLoad;\n-                }\n-                return systemLoad \/ cpuSet.length;\n-            };\n-        } else if (cpuLoadTarget == CpuLoadTarget.CPU_LOAD_VM_ONLY) {\n-            usageNanos = getProcessCpuTime();\n-            cpuTicks = this.processLoadTicks;\n-            defaultCpuSupplier = ()-> getProcessCpuLoad0();\n-            cpuSetFunction = (int[] cpuSet) ->{\n-                int totalCPUs = getHostOnlineCpuCount0();\n-                int containerCPUs = getAvailableProcessors();\n-                return getProcessCpuLoad0() * totalCPUs \/ containerCPUs;\n-            };\n-        }\n-        long quota = containerMetrics.getCpuQuota();\n-        long share = containerMetrics.getCpuShares();\n-        if (quota > 0) {\n-            long numPeriods = containerMetrics.getCpuNumPeriods();\n-            long quotaNanos = TimeUnit.MICROSECONDS.toNanos(quota * numPeriods);\n-            return getUsageDividesTotal(usageNanos, quotaNanos, cpuTicks);\n-        } else if (share > 0) {\n-            long hostTicks = getHostTotalCpuTicks0();\n-            int totalCPUs = getHostOnlineCpuCount0();\n-            int containerCPUs = getAvailableProcessors();\n-            \/\/ scale the total host load to the actual container cpus\n-            hostTicks = hostTicks * containerCPUs \/ totalCPUs;\n-            return getUsageDividesTotal(usageNanos, hostTicks, cpuTicks);\n-        } else {\n-            if (isCpuSetSameAsHostCpuSet()) {\n-                return defaultCpuSupplier.getAsDouble();\n-            } else {\n-                int[] cpuSet = containerMetrics.getEffectiveCpuSetCpus();\n-                if (cpuSet == null || cpuSet.length <= 0) {\n-                    cpuSet = containerMetrics.getCpuSetCpus();\n-                }\n-                if (cpuSet == null) {\n-                    return defaultCpuSupplier.getAsDouble();\n-                } else if (cpuSet.length > 0) {\n-                    return cpuSetFunction.applyAsDouble(cpuSet);\n-                }\n-                return -1;\n-            }\n-        }\n-    }\n-\n@@ -243,1 +264,1 @@\n-            return getCpuLoadWithTarget(CpuLoadTarget.CPU_LOAD_GLOBAL);\n+            return systemLoadTicks.getContainerCpuLoad();\n@@ -250,1 +271,1 @@\n-            return getCpuLoadWithTarget(CpuLoadTarget.CPU_LOAD_VM_ONLY);\n+            return processLoadTicks.getContainerCpuLoad();\n","filename":"src\/jdk.management\/unix\/classes\/com\/sun\/management\/internal\/OperatingSystemImpl.java","additions":127,"deletions":106,"binary":false,"changes":233,"status":"modified"}]}