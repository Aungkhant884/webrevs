{"files":[{"patch":"@@ -44,0 +44,2 @@\n+\n+bool IsEmojiFont(CTFontRef font);\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/font\/AWTFont.h","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -586,0 +586,11 @@\n+\n+static CFStringRef EMOJI_FONT_NAME = CFSTR(\"Apple Color Emoji\");\n+\n+bool IsEmojiFont(CTFontRef font)\n+{\n+    CFStringRef name = CTFontCopyFullName(font);\n+    if (name == NULL) return false;\n+    bool isFixedColor = CFStringCompare(name, EMOJI_FONT_NAME, 0) == kCFCompareEqualTo;\n+    CFRelease(name);\n+    return isFixedColor;\n+}\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/font\/AWTFont.m","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -154,1 +154,1 @@\n-    CTFontGetAdvancesForGlyphs(fallback, kCTFontDefaultOrientation, &glyph, &advance, 1);\n+    CGGlyphImages_GetGlyphMetrics(fallback, &awtStrike->fAltTx, awtStrike->fStyle, &glyph, 1, NULL, &advance);\n@@ -191,1 +191,1 @@\n-    JRSFontGetBoundingBoxesForGlyphsAndStyle(fallback, &tx, awtStrike->fStyle, &glyph, 1, &bbox);\n+    CGGlyphImages_GetGlyphMetrics(fallback, &tx, awtStrike->fStyle, &glyph, 1, &bbox, NULL);\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/font\/AWTStrike.m","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -36,1 +36,8 @@\n-\n+void\n+CGGlyphImages_GetGlyphMetrics(const CTFontRef font,\n+                              const CGAffineTransform *tx,\n+                              const JRSFontRenderingStyle style,\n+                              const CGGlyph glyphs[],\n+                              size_t count,\n+                              CGRect bboxes[],\n+                              CGSize advances[]);\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/font\/CGGlyphImages.h","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -312,0 +312,34 @@\n+static void\n+CGGI_CopyImageFromCanvasToARGBInfo(CGGI_GlyphCanvas *canvas, GlyphInfo *info)\n+{\n+    CGBitmapInfo bitmapInfo = CGBitmapContextGetBitmapInfo(canvas->context);\n+    bool littleEndian = (bitmapInfo & kCGBitmapByteOrderMask) == kCGBitmapByteOrder32Little;\n+\n+    UInt32 *src = (UInt32 *)canvas->image->data;\n+    size_t srcRowWidth = canvas->image->width;\n+\n+    UInt8 *dest = (UInt8 *)info->image;\n+    size_t destRowWidth = info->width;\n+\n+    size_t height = info->height;\n+\n+    size_t y;\n+\n+    for (y = 0; y < height; y++) {\n+        size_t srcRow = y * srcRowWidth;\n+        if (littleEndian) {\n+            UInt16 destRowBytes = info->rowBytes;\n+            memcpy(dest, src + srcRow, destRowBytes);\n+            dest += destRowBytes;\n+        } else {\n+            size_t x;\n+            for (x = 0; x < destRowWidth; x++) {\n+                UInt32 p = src[srcRow + x];\n+                *dest++ = (p >> 24  & 0xFF); \/\/ blue  (alpha-premultiplied)\n+                *dest++ = (p >> 16 & 0xFF); \/\/ green (alpha-premultiplied)\n+                *dest++ = (p >> 8   & 0xFF); \/\/ red   (alpha-premultiplied)\n+                *dest++ = (p & 0xFF); \/\/ alpha\n+            }\n+        }\n+    }\n+}\n@@ -329,0 +363,8 @@\n+static CGGI_GlyphInfoDescriptor argb =\n+    { 4, &CGGI_CopyImageFromCanvasToARGBInfo };\n+\n+static inline CGGI_GlyphInfoDescriptor*\n+CGGI_GetGlyphInfoDescriptor(const CGGI_RenderingMode *mode, CTFontRef font)\n+{\n+    return IsEmojiFont(font) ? &argb : mode->glyphDescriptor;\n+}\n@@ -462,1 +504,1 @@\n- * Clear the canvas by blitting white only into the region of interest\n+ * Clear the canvas by blitting white (or transparent background for color glyphs) only into the region of interest\n@@ -466,1 +508,1 @@\n-CGGI_ClearCanvas(CGGI_GlyphCanvas *canvas, GlyphInfo *info)\n+CGGI_ClearCanvas(CGGI_GlyphCanvas *canvas, GlyphInfo *info, bool transparent)\n@@ -477,1 +519,1 @@\n-    Pixel_8888 opaqueWhite = { 0xE0, 0xE0, 0xE0, 0xE0 };\n+    Pixel_8888 background = { 0xE0, 0xE0, 0xE0, 0xE0 };\n@@ -479,1 +521,4 @@\n-    Pixel_8888 opaqueWhite = { 0xFF, 0xFF, 0xFF, 0xFF };\n+    Pixel_8888 background = { transparent ? 0 : 0xFF,\n+                               transparent ? 0 : 0xFF,\n+                               transparent ? 0 : 0xFF,\n+                               transparent ? 0 : 0xFF };\n@@ -482,2 +527,2 @@\n-    \/\/ clear canvas background and set foreground color\n-    vImageBufferFill_ARGB8888(&canvasRectToClear, opaqueWhite, kvImageNoFlags);\n+    \/\/ clear canvas background\n+    vImageBufferFill_ARGB8888(&canvasRectToClear, background, kvImageNoFlags);\n@@ -496,1 +541,1 @@\n-                            const CGGI_RenderingMode *mode)\n+                            const CGGI_GlyphInfoDescriptor *glyphDescriptor)\n@@ -498,1 +543,1 @@\n-    size_t pixelSize = mode->glyphDescriptor->pixelSize;\n+    size_t pixelSize = glyphDescriptor->pixelSize;\n@@ -563,1 +608,1 @@\n-     GlyphInfo *info, const CGGI_RenderingMode *mode)\n+     GlyphInfo *info, const CGGI_GlyphInfoDescriptor *glyphDescriptor, const AWTStrike *strike, CTFontRef font)\n@@ -572,1 +617,1 @@\n-        (*mode->glyphDescriptor->copyFxnPtr)(canvas, info);\n+        (*glyphDescriptor->copyFxnPtr)(canvas, info);\n@@ -577,1 +622,1 @@\n-    CGGI_ClearCanvas(canvas, info);\n+    CGGI_ClearCanvas(canvas, info, glyphDescriptor == &argb);\n@@ -580,4 +625,32 @@\n-    CGContextShowGlyphsAtPoint(canvas->context,\n-                               -info->topLeftX,\n-                               canvas->image->height + info->topLeftY,\n-                               &glyph, 1);\n+    CGFloat x = -info->topLeftX;\n+    CGFloat y = canvas->image->height + info->topLeftY;\n+\n+    if (glyphDescriptor == &argb) {\n+        \/\/ Emoji glyphs are not rendered by CGContextShowGlyphsAtPoint.\n+        \/\/ Also, it's not possible to use transformation matrix to get the emoji glyph\n+        \/\/ rendered for the desired font size - actual-size font object is needed.\n+        \/\/ The logic here must match the logic in CGGlyphImages_GetGlyphMetrics,\n+        \/\/ which calculates glyph metrics.\n+\n+        CGAffineTransform matrix = CGContextGetTextMatrix(canvas->context);\n+        CGFloat fontSize = sqrt(fabs(matrix.a * matrix.d - matrix.b * matrix.c));\n+        CTFontRef sizedFont = CTFontCreateCopyWithSymbolicTraits(font, fontSize, NULL, 0, 0);\n+\n+        CGFloat normFactor = 1.0 \/ fontSize;\n+        CGAffineTransform normalizedMatrix = CGAffineTransformScale(matrix, normFactor, normFactor);\n+        CGContextSetTextMatrix(canvas->context, normalizedMatrix);\n+\n+        CGPoint userPoint = CGPointMake(x, y);\n+        CGAffineTransform normalizedMatrixInv = CGAffineTransformInvert(normalizedMatrix);\n+        CGPoint textPoint = CGPointApplyAffineTransform(userPoint, normalizedMatrixInv);\n+\n+        CTFontDrawGlyphs(sizedFont, &glyph, &textPoint, 1, canvas->context);\n+\n+        CFRelease(sizedFont);\n+        \/\/ restore context's original state\n+        CGContextSetTextMatrix(canvas->context, matrix);\n+        CGContextSetFontSize(canvas->context, 1); \/\/ CTFontDrawGlyphs tampers with it\n+    } else {\n+        CGContextShowGlyphsAtPoint(canvas->context, x, y, &glyph, 1);\n+    }\n+\n@@ -585,1 +658,1 @@\n-    (*mode->glyphDescriptor->copyFxnPtr)(canvas, info);\n+    (*glyphDescriptor->copyFxnPtr)(canvas, info);\n@@ -618,2 +691,0 @@\n-    JRSFontGetBoundingBoxesForGlyphsAndStyle(fallback, &tx, style, &glyph, 1, &bbox);\n-\n@@ -621,1 +692,3 @@\n-    CTFontGetAdvancesForGlyphs(fallback, kCTFontDefaultOrientation, &glyph, &advance, 1);\n+    CGGlyphImages_GetGlyphMetrics(fallback, &tx, style, &glyph, 1, &bbox, &advance);\n+\n+    CGGI_GlyphInfoDescriptor *glyphDescriptor = CGGI_GetGlyphInfoDescriptor(mode, fallback);\n@@ -624,1 +697,1 @@\n-    GlyphInfo *info = CGGI_CreateNewGlyphInfoFrom(advance, bbox, strike, mode);\n+    GlyphInfo *info = CGGI_CreateNewGlyphInfoFrom(advance, bbox, strike, glyphDescriptor);\n@@ -637,1 +710,1 @@\n-    CGGI_CreateImageForGlyph(canvas, glyph, info, mode);\n+    CGGI_CreateImageForGlyph(canvas, glyph, info, glyphDescriptor, strike, fallback);\n@@ -680,0 +753,3 @@\n+    CTFontRef mainFont = (CTFontRef)strike->fAWTFont->fFont;\n+    CGGI_GlyphInfoDescriptor* mainFontDescriptor = CGGI_GetGlyphInfoDescriptor(mode, mainFont);\n+\n@@ -684,1 +760,1 @@\n-            CGGI_CreateImageForGlyph(canvas, glyphs[i], info, mode);\n+            CGGI_CreateImageForGlyph(canvas, glyphs[i], info, mainFontDescriptor, strike, mainFont);\n@@ -777,2 +853,3 @@\n-    JRSFontGetBoundingBoxesForGlyphsAndStyle((CTFontRef)font->fFont, &tx, bboxCGMode, glyphs, len, bboxes);\n-    CTFontGetAdvancesForGlyphs((CTFontRef)font->fFont, kCTFontDefaultOrientation, glyphs, advances, len);\n+    CTFontRef fontRef = (CTFontRef)font->fFont;\n+    CGGlyphImages_GetGlyphMetrics(fontRef, &tx, bboxCGMode, glyphs, len, bboxes, advances);\n+    CGGI_GlyphInfoDescriptor* mainFontDescriptor = CGGI_GetGlyphInfoDescriptor(mode, fontRef);\n@@ -795,1 +872,1 @@\n-        GlyphInfo *glyphInfo = CGGI_CreateNewGlyphInfoFrom(advance, bbox, strike, mode);\n+        GlyphInfo *glyphInfo = CGGI_CreateNewGlyphInfoFrom(advance, bbox, strike, mainFontDescriptor);\n@@ -891,0 +968,56 @@\n+\n+\/*\n+ * Calculates bounding boxes (for given transform) and advance (for untransformed 1pt-size font) for specified glyphs.\n+ *\/\n+void\n+CGGlyphImages_GetGlyphMetrics(const CTFontRef font,\n+                              const CGAffineTransform *tx,\n+                              const JRSFontRenderingStyle style,\n+                              const CGGlyph glyphs[],\n+                              size_t count,\n+                              CGRect bboxes[],\n+                              CGSize advances[]) {\n+    if (IsEmojiFont(font)) {\n+        \/\/ Glyph metrics for emoji font are not strictly proportional to font size,\n+        \/\/ so we need to construct real-sized font object to calculate them.\n+        \/\/ The logic here must match the logic in CGGI_CreateImageForGlyph,\n+        \/\/ which performs glyph drawing.\n+\n+        CGFloat fontSize = sqrt(fabs(tx->a * tx->d - tx->b * tx->c));\n+        CTFontRef sizedFont = CTFontCreateCopyWithSymbolicTraits(font, fontSize, NULL, 0, 0);\n+\n+        if (bboxes) {\n+            \/\/ JRSFontGetBoundingBoxesForGlyphsAndStyle works incorrectly for AppleColorEmoji font:\n+            \/\/ it uses bottom left corner of the glyph's bounding box as a fixed point of transformation\n+            \/\/ instead of glyph's origin point (used at drawing). So, as a workaround,\n+            \/\/ we request a bounding box for the untransformed glyph, and apply the transform ourselves.\n+            JRSFontGetBoundingBoxesForGlyphsAndStyle(sizedFont, &CGAffineTransformIdentity, style, glyphs, count, bboxes);\n+            CGAffineTransform txNormalized = CGAffineTransformMake(tx->a \/ fontSize,\n+                                                                   tx->b \/ fontSize,\n+                                                                   tx->c \/ fontSize,\n+                                                                   tx->d \/ fontSize,\n+                                                                   0, 0);\n+            for (int i = 0; i < count; i++) {\n+                bboxes[i] = CGRectApplyAffineTransform(bboxes[i], txNormalized);\n+            }\n+        }\n+\n+        if (advances) {\n+            CTFontGetAdvancesForGlyphs(sizedFont, kCTFontDefaultOrientation, glyphs, advances, count);\n+            for (int i = 0; i < count; i++) {\n+                \/\/ Calling code will scale the result back\n+                advances[i].width \/= fontSize;\n+                advances[i].height \/= fontSize;\n+            }\n+        }\n+\n+        CFRelease(sizedFont);\n+    } else {\n+        if (bboxes) {\n+            JRSFontGetBoundingBoxesForGlyphsAndStyle(font, tx, style, glyphs, count, bboxes);\n+        }\n+        if (advances) {\n+            CTFontGetAdvancesForGlyphs(font, kCTFontDefaultOrientation, glyphs, advances, count);\n+        }\n+    }\n+}\n\\ No newline at end of file\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/font\/CGGlyphImages.m","additions":158,"deletions":25,"binary":false,"changes":183,"status":"modified"},{"patch":"@@ -0,0 +1,71 @@\n+\/*\n+ * Copyright 2021 JetBrains s.r.o.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.font;\n+\n+import sun.java2d.SurfaceData;\n+\n+import java.awt.GraphicsConfiguration;\n+import java.awt.Rectangle;\n+import java.awt.image.Raster;\n+\n+\/**\n+ * SurfaceData view for a color glyph from glyph cache\n+ *\/\n+class ColorGlyphSurfaceData extends SurfaceData {\n+    ColorGlyphSurfaceData() {\n+        super(State.UNTRACKABLE);\n+        initOps();\n+    }\n+\n+    private native void initOps();\n+\n+    native void setCurrentGlyph(long imgPtr);\n+\n+    @Override\n+    public SurfaceData getReplacement() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public GraphicsConfiguration getDeviceConfiguration() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public Raster getRaster(int x, int y, int w, int h) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public Rectangle getBounds() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public Object getDestination() {\n+        throw new UnsupportedOperationException();\n+    }\n+}\n","filename":"src\/java.desktop\/share\/classes\/sun\/font\/ColorGlyphSurfaceData.java","additions":71,"deletions":0,"binary":false,"changes":71,"status":"added"},{"patch":"@@ -28,1 +28,0 @@\n-import java.awt.Font;\n@@ -30,1 +29,0 @@\n-import java.awt.font.FontRenderContext;\n@@ -32,0 +30,2 @@\n+\n+import sun.java2d.SurfaceData;\n@@ -55,1 +55,1 @@\n- *         int strbounds[] = gl.getBounds();\n+ *         gl.startGlyphIteration();\n@@ -158,0 +158,1 @@\n+    private ColorGlyphSurfaceData glyphSurfaceData;\n@@ -279,5 +280,1 @@\n-    public int[] getBounds() {\n-        \/* We co-opt the 5 element array that holds per glyph metrics in order\n-         * to return the bounds. So a caller must copy the data out of the\n-         * array before calling any other methods on this GlyphList\n-         *\/\n+    public void startGlyphIteration() {\n@@ -285,1 +282,1 @@\n-            throw new InternalError(\"calling getBounds after setGlyphIndex\");\n+            throw new InternalError(\"glyph iteration restarted\");\n@@ -294,1 +291,12 @@\n-        fillBounds(metrics);\n+    }\n+\n+    \/*\n+     * Must be called after 'startGlyphIteration'.\n+     * Returns overall bounds for glyphs starting from the next glyph\n+     * in iteration till the glyph with specified index.\n+     * The underlying storage for bounds is shared with metrics,\n+     * so this method (and the array it returns) shouldn't be used between\n+     * 'setGlyphIndex' call and matching 'getMetrics' call.\n+     *\/\n+    public int[] getBounds(int endGlyphIndex) {\n+        fillBounds(metrics, endGlyphIndex);\n@@ -439,1 +447,1 @@\n-    private void fillBounds(int[] bounds) {\n+    private void fillBounds(int[] bounds, int endGlyphIndex) {\n@@ -448,1 +456,2 @@\n-        if (len == 0) {\n+        int startGlyphIndex = glyphindex + 1;\n+        if (startGlyphIndex >= endGlyphIndex) {\n@@ -456,3 +465,3 @@\n-        int posIndex = 0;\n-        float glx = x + 0.5f;\n-        float gly = y + 0.5f;\n+        int posIndex = startGlyphIndex<<1;\n+        float glx = gposx;\n+        float gly = gposy;\n@@ -461,1 +470,1 @@\n-        for (int i=0; i<len; i++) {\n+        for (int i=startGlyphIndex; i<endGlyphIndex; i++) {\n@@ -494,0 +503,20 @@\n+\n+    public static boolean canContainColorGlyphs() {\n+        return FontUtilities.isMacOSX;\n+    }\n+\n+    public boolean isColorGlyph(int glyphIndex) {\n+        int width = StrikeCache.unsafe.getChar(images[glyphIndex] +\n+                                               StrikeCache.widthOffset);\n+        int rowBytes = StrikeCache.unsafe.getChar(images[glyphIndex] +\n+                                                  StrikeCache.rowBytesOffset);\n+        return rowBytes == width * 4;\n+    }\n+\n+    public SurfaceData getColorGlyphData() {\n+        if (glyphSurfaceData == null) {\n+            glyphSurfaceData = new ColorGlyphSurfaceData();\n+        }\n+        glyphSurfaceData.setCurrentGlyph(images[glyphindex]);\n+        return glyphSurfaceData;\n+    }\n","filename":"src\/java.desktop\/share\/classes\/sun\/font\/GlyphList.java","additions":45,"deletions":16,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -56,0 +56,1 @@\n+import sun.java2d.loops.DrawGlyphListColor;\n@@ -895,0 +896,2 @@\n+        loops.drawGlyphListColorLoop =\n+                DrawGlyphListColor.locate(src, comp, dst);\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/SurfaceData.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -71,1 +71,2 @@\n-                                     GlyphList srcData);\n+                                     GlyphList srcData,\n+                                     int fromGlyph, int toGlyph);\n@@ -97,1 +98,1 @@\n-                                  GlyphList gl) {\n+                                  GlyphList gl, int fromGlyph, int toGlyph) {\n@@ -99,2 +100,0 @@\n-            int[] strbounds = gl.getBounds(); \/\/ Don't delete, bug 4895493\n-            int num = gl.getNumGlyphs();\n@@ -106,1 +105,1 @@\n-            for (int i = 0; i < num; i++) {\n+            for (int i = fromGlyph; i < toGlyph; i++) {\n@@ -154,1 +153,1 @@\n-                                  GlyphList glyphs)\n+                                  GlyphList glyphs, int fromGlyph, int toGlyph)\n@@ -157,1 +156,1 @@\n-            target.DrawGlyphList(sg2d, dest, glyphs);\n+            target.DrawGlyphList(sg2d, dest, glyphs, fromGlyph, toGlyph);\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/loops\/DrawGlyphList.java","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -70,1 +70,2 @@\n-                                       GlyphList srcData);\n+                                       GlyphList srcData,\n+                                       int fromGlyph, int toGlyph);\n@@ -95,1 +96,1 @@\n-                                    GlyphList gl)\n+                                    GlyphList gl, int fromGlyph, int toGlyph)\n@@ -97,2 +98,0 @@\n-            gl.getBounds(); \/\/ Don't delete, bug 4895493\n-            int num = gl.getNumGlyphs();\n@@ -104,1 +103,1 @@\n-            for (int i = 0; i < num; i++) {\n+            for (int i = fromGlyph; i < toGlyph; i++) {\n@@ -152,1 +151,2 @@\n-                                    GlyphList glyphs)\n+                                    GlyphList glyphs,\n+                                    int fromGlyph, int toGlyph)\n@@ -155,1 +155,1 @@\n-            target.DrawGlyphListAA(sg2d, dest, glyphs);\n+            target.DrawGlyphListAA(sg2d, dest, glyphs, fromGlyph, toGlyph);\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/loops\/DrawGlyphListAA.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -0,0 +1,148 @@\n+\/*\n+ * Copyright 2021 JetBrains s.r.o.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.java2d.loops;\n+\n+import sun.font.GlyphList;\n+import sun.java2d.SunGraphics2D;\n+import sun.java2d.SurfaceData;\n+import sun.java2d.pipe.Region;\n+\n+import java.awt.*;\n+\n+\/**\n+ *   Draws color glyphs onto destination surface\n+ *\/\n+public class DrawGlyphListColor extends GraphicsPrimitive {\n+\n+    public final static String methodSignature =\n+            \"DrawGlyphListColor(...)\".toString();\n+\n+    public final static int primTypeID = makePrimTypeID();\n+\n+    public static DrawGlyphListColor locate(SurfaceType srctype,\n+                                            CompositeType comptype,\n+                                            SurfaceType dsttype)\n+    {\n+        return (DrawGlyphListColor)\n+            GraphicsPrimitiveMgr.locate(primTypeID,\n+                                        srctype, comptype, dsttype);\n+    }\n+\n+    protected DrawGlyphListColor(SurfaceType srctype,\n+                                 CompositeType comptype,\n+                                 SurfaceType dsttype)\n+    {\n+        super(methodSignature, primTypeID, srctype, comptype, dsttype);\n+    }\n+\n+\n+    public void DrawGlyphListColor(SunGraphics2D sg2d, SurfaceData dest,\n+                                   GlyphList srcData,\n+                                   int fromGlyph, int toGlyph) {\n+        \/\/ actual implementation is in the 'General' subclass\n+    }\n+\n+    \/\/ This instance is used only for lookup.\n+    static {\n+        GraphicsPrimitiveMgr.registerGeneral(\n+                                new DrawGlyphListColor(null, null, null));\n+    }\n+\n+    public GraphicsPrimitive makePrimitive(SurfaceType srctype,\n+                                           CompositeType comptype,\n+                                           SurfaceType dsttype) {\n+        return new General(srctype, comptype, dsttype);\n+    }\n+\n+    private static class General extends DrawGlyphListColor {\n+        private final Blit blit;\n+\n+        public General(SurfaceType srctype,\n+                       CompositeType comptype,\n+                       SurfaceType dsttype)\n+        {\n+            super(srctype, comptype, dsttype);\n+            blit = Blit.locate(SurfaceType.IntArgbPre,\n+                    CompositeType.SrcOverNoEa, dsttype);\n+        }\n+\n+        public void DrawGlyphListColor(SunGraphics2D sg2d, SurfaceData dest,\n+                                  GlyphList gl, int fromGlyph, int toGlyph) {\n+\n+            Region clip = sg2d.getCompClip();\n+            int cx1 = clip.getLoX();\n+            int cy1 = clip.getLoY();\n+            int cx2 = clip.getHiX();\n+            int cy2 = clip.getHiY();\n+            for (int i = fromGlyph; i < toGlyph; i++) {\n+                gl.setGlyphIndex(i);\n+                int[] metrics = gl.getMetrics();\n+                int x = metrics[0];\n+                int y = metrics[1];\n+                int w = metrics[2];\n+                int h = metrics[3];\n+                int gx1 = x;\n+                int gy1 = y;\n+                int gx2 = x + w;\n+                int gy2 = y + h;\n+                if (gx1 < cx1) gx1 = cx1;\n+                if (gy1 < cy1) gy1 = cy1;\n+                if (gx2 > cx2) gx2 = cx2;\n+                if (gy2 > cy2) gy2 = cy2;\n+                if (gx2 > gx1 && gy2 > gy1) {\n+                    blit.Blit(gl.getColorGlyphData(), dest, AlphaComposite.SrcOver, clip,\n+                            gx1 - x, gy1 - y, gx1, gy1, gx2 - gx1, gy2 - gy1);\n+                }\n+            }\n+        }\n+    }\n+\n+    public GraphicsPrimitive traceWrap() {\n+        return new TraceDrawGlyphListColor(this);\n+    }\n+\n+    private static class TraceDrawGlyphListColor extends DrawGlyphListColor {\n+        DrawGlyphListColor target;\n+\n+        public TraceDrawGlyphListColor(DrawGlyphListColor target) {\n+            super(target.getSourceType(),\n+                  target.getCompositeType(),\n+                  target.getDestType());\n+            this.target = target;\n+        }\n+\n+        public GraphicsPrimitive traceWrap() {\n+            return this;\n+        }\n+\n+        public void DrawGlyphListColor(SunGraphics2D sg2d, SurfaceData dest,\n+                                  GlyphList glyphs, int fromGlyph, int toGlyph)\n+        {\n+            tracePrimitive(target);\n+            target.DrawGlyphListColor(sg2d, dest, glyphs, fromGlyph, toGlyph);\n+        }\n+    }\n+}\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/loops\/DrawGlyphListColor.java","additions":148,"deletions":0,"binary":false,"changes":148,"status":"added"},{"patch":"@@ -71,1 +71,2 @@\n-                                         GlyphList srcData);\n+                                        GlyphList srcData,\n+                                        int fromGlyph, int toGlyph);\n@@ -92,1 +93,2 @@\n-                                      GlyphList glyphs)\n+                                     GlyphList glyphs,\n+                                     int fromGlyph, int toGlyph)\n@@ -95,1 +97,1 @@\n-            target.DrawGlyphListLCD(sg2d, dest, glyphs);\n+            target.DrawGlyphListLCD(sg2d, dest, glyphs, fromGlyph, toGlyph);\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/loops\/DrawGlyphListLCD.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -368,1 +368,2 @@\n-                                GlyphList gl, Region clip)\n+                                GlyphList gl, int fromGlyph, int toGlyph,\n+                                Region clip)\n@@ -370,1 +371,1 @@\n-        int[] bounds = gl.getBounds();\n+        int[] bounds = gl.getBounds(toGlyph);\n@@ -381,2 +382,1 @@\n-        int num = gl.getNumGlyphs();\n-        for (int i = 0; i < num; i++) {\n+        for (int i = fromGlyph; i < toGlyph; i++) {\n@@ -974,1 +974,1 @@\n-                              GlyphList gl)\n+                              GlyphList gl, int fromGlyph, int toGlyph)\n@@ -977,1 +977,2 @@\n-        GeneralRenderer.doDrawGlyphList(sData, pw, gl, sg2d.getCompClip());\n+        GeneralRenderer.doDrawGlyphList(sData, pw, gl, fromGlyph, toGlyph,\n+                sg2d.getCompClip());\n@@ -989,1 +990,1 @@\n-                                GlyphList gl)\n+                                GlyphList gl, int fromGlyph, int toGlyph)\n@@ -992,1 +993,2 @@\n-        GeneralRenderer.doDrawGlyphList(sData, pw, gl, sg2d.getCompClip());\n+        GeneralRenderer.doDrawGlyphList(sData, pw, gl, fromGlyph, toGlyph,\n+                sg2d.getCompClip());\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/loops\/GeneralRenderer.java","additions":10,"deletions":8,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -55,0 +55,1 @@\n+    public DrawGlyphListColor   drawGlyphListColorLoop;\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/loops\/RenderLoops.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import sun.awt.SunHints;\n@@ -40,2 +41,1 @@\n-       sg2d.loops.drawGlyphListAALoop.DrawGlyphListAA(sg2d, sg2d.surfaceData,\n-                                                      gl);\n+       drawGlyphList(sg2d, gl, SunHints.INTVAL_TEXT_ANTIALIAS_ON);\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/pipe\/AATextRenderer.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -43,14 +43,45 @@\n-        switch (aaHint) {\n-         case SunHints.INTVAL_TEXT_ANTIALIAS_OFF:\n-             sg2d.loops.drawGlyphListLoop.\n-                 DrawGlyphList(sg2d, sg2d.surfaceData, gl);\n-             return;\n-         case SunHints.INTVAL_TEXT_ANTIALIAS_ON:\n-             sg2d.loops.drawGlyphListAALoop.\n-                 DrawGlyphListAA(sg2d, sg2d.surfaceData, gl);\n-             return;\n-        case SunHints.INTVAL_TEXT_ANTIALIAS_LCD_HRGB:\n-        case SunHints.INTVAL_TEXT_ANTIALIAS_LCD_VRGB:\n-            sg2d.loops.drawGlyphListLCDLoop.\n-                DrawGlyphListLCD(sg2d,sg2d.surfaceData, gl);\n-            return;\n+        int prevLimit = 0;\n+        boolean isColor = false;\n+        int len = gl.getNumGlyphs();\n+        gl.startGlyphIteration();\n+        if (GlyphList.canContainColorGlyphs()) {\n+            for (int i = 0; i < len; i++) {\n+                boolean newIsColor = gl.isColorGlyph(i);\n+                if (newIsColor != isColor) {\n+                    drawGlyphListSegment(sg2d, gl, prevLimit, i, aaHint,\n+                            isColor);\n+                    prevLimit = i;\n+                    isColor = newIsColor;\n+                }\n+            }\n+        }\n+        drawGlyphListSegment(sg2d, gl, prevLimit, len, aaHint, isColor);\n+    }\n+\n+    private void drawGlyphListSegment(SunGraphics2D sg2d, GlyphList gl,\n+                                      int fromglyph, int toGlyph,\n+                                      int aaHint, boolean isColor) {\n+        if (fromglyph >= toGlyph) return;\n+        if (isColor) {\n+            sg2d.loops.drawGlyphListColorLoop.\n+                    DrawGlyphListColor(sg2d, sg2d.surfaceData,\n+                            gl, fromglyph, toGlyph);\n+        } else {\n+            switch (aaHint) {\n+                case SunHints.INTVAL_TEXT_ANTIALIAS_OFF:\n+                    sg2d.loops.drawGlyphListLoop.\n+                            DrawGlyphList(sg2d, sg2d.surfaceData,\n+                                    gl, fromglyph, toGlyph);\n+                    return;\n+                case SunHints.INTVAL_TEXT_ANTIALIAS_ON:\n+                    sg2d.loops.drawGlyphListAALoop.\n+                            DrawGlyphListAA(sg2d, sg2d.surfaceData,\n+                                    gl, fromglyph, toGlyph);\n+                    return;\n+                case SunHints.INTVAL_TEXT_ANTIALIAS_LCD_HRGB:\n+                case SunHints.INTVAL_TEXT_ANTIALIAS_LCD_VRGB:\n+                    sg2d.loops.drawGlyphListLCDLoop.\n+                            DrawGlyphListLCD(sg2d, sg2d.surfaceData,\n+                                    gl, fromglyph, toGlyph);\n+                    return;\n+            }\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/pipe\/GlyphListLoopPipe.java","additions":45,"deletions":14,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-import java.awt.font.GlyphVector;\n+import sun.awt.SunHints;\n@@ -31,1 +31,0 @@\n-import static sun.awt.SunHints.*;\n@@ -41,2 +40,2 @@\n-        sg2d.loops.drawGlyphListLCDLoop.\n-            DrawGlyphListLCD(sg2d, sg2d.surfaceData, gl);\n+        drawGlyphList(sg2d, gl, SunHints.INTVAL_TEXT_ANTIALIAS_LCD_HRGB);\n+\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/pipe\/LCDTextRenderer.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import sun.awt.SunHints;\n@@ -40,1 +41,1 @@\n-        sg2d.loops.drawGlyphListLoop.DrawGlyphList(sg2d, sg2d.surfaceData, gl);\n+        drawGlyphList(sg2d, gl, SunHints.INTVAL_TEXT_ANTIALIAS_OFF);\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/pipe\/SolidTextRenderer.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -54,1 +54,2 @@\n-            int[] bounds = gl.getBounds();\n+            gl.startGlyphIteration();\n+            int[] bounds = gl.getBounds(num);\n@@ -79,1 +80,1 @@\n-                if (gx2 > gx1 && gy2 > gy1 &&\n+                if (gx2 > gx1 && gy2 > gy1 && !gl.isColorGlyph(i) &&\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/pipe\/TextRenderer.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -66,1 +66,2 @@\n-    MODE_NO_CACHE_LCD\n+    MODE_NO_CACHE_LCD,\n+    MODE_NO_CACHE_COLOR\n@@ -529,0 +530,1 @@\n+    case MODE_NO_CACHE_COLOR:\n@@ -981,0 +983,27 @@\n+static jboolean\n+OGLTR_DrawColorGlyphNoCache(OGLContext *oglc, GlyphInfo *ginfo, jint x, jint y)\n+{\n+    if (glyphMode != MODE_NO_CACHE_COLOR) {\n+        OGLTR_DisableGlyphModeState();\n+        RESET_PREVIOUS_OP();\n+        glyphMode = MODE_NO_CACHE_COLOR;\n+    }\n+\n+    \/\/ see OGLBlitSwToSurface() in OGLBlitLoops.c\n+    \/\/ for more info on the following two lines\n+    j2d_glRasterPos2i(0, 0);\n+    j2d_glBitmap(0, 0, 0, 0, (GLfloat) x, (GLfloat) (-y), NULL);\n+\n+    \/\/ in OpenGL image data is assumed to contain lines from bottom to top\n+    j2d_glPixelZoom(1, -1);\n+\n+    j2d_glDrawPixels(ginfo->width, ginfo->height, GL_BGRA, GL_UNSIGNED_BYTE,\n+                     ginfo->image);\n+\n+    \/\/ restoring state\n+    j2d_glPixelZoom(1, 1);\n+\n+    return JNI_TRUE;\n+}\n+\n+\n@@ -1031,1 +1060,1 @@\n-        jboolean grayscale, ok;\n+        jboolean ok;\n@@ -1041,2 +1070,0 @@\n-        grayscale = (ginfo->rowBytes == ginfo->width);\n-\n@@ -1063,1 +1090,1 @@\n-        if (grayscale) {\n+        if (ginfo->rowBytes == ginfo->width) {\n@@ -1072,0 +1099,3 @@\n+        } else if (ginfo->rowBytes == ginfo->width * 4) {\n+            \/\/ color glyph data\n+            ok = OGLTR_DrawColorGlyphNoCache(oglc, ginfo, x, y);\n","filename":"src\/java.desktop\/share\/native\/common\/java2d\/opengl\/OGLTextRenderer.c","additions":35,"deletions":5,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -0,0 +1,93 @@\n+\/*\n+ * Copyright 2021 JetBrains s.r.o.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"jni_util.h\"\n+#include \"fontscalerdefs.h\"\n+#include \"SurfaceData.h\"\n+\n+typedef struct _GlyphOps {\n+    SurfaceDataOps sdOps;\n+    GlyphInfo*     glyph;\n+} GlyphOps;\n+\n+static jint Glyph_Lock(JNIEnv *env,\n+                       SurfaceDataOps *ops,\n+                       SurfaceDataRasInfo *pRasInfo,\n+                       jint lockflags)\n+{\n+    SurfaceDataBounds bounds;\n+    GlyphInfo *glyph;\n+    if (lockflags &\n+        (SD_LOCK_WRITE | SD_LOCK_LUT | SD_LOCK_INVCOLOR | SD_LOCK_INVGRAY)) {\n+        JNU_ThrowInternalError(env, \"Unsupported mode for glyph image surface\");\n+        return SD_FAILURE;\n+    }\n+    glyph = ((GlyphOps*)ops)->glyph;\n+    bounds.x1 = 0;\n+    bounds.y1 = 0;\n+    bounds.x2 = glyph->width;\n+    bounds.y2 = glyph->height;\n+    SurfaceData_IntersectBounds(&pRasInfo->bounds, &bounds);\n+    return SD_SUCCESS;\n+}\n+\n+static void Glyph_GetRasInfo(JNIEnv *env,\n+                             SurfaceDataOps *ops,\n+                             SurfaceDataRasInfo *pRasInfo)\n+{\n+    GlyphInfo *glyph = ((GlyphOps*)ops)->glyph;\n+\n+    pRasInfo->rasBase = glyph->image;\n+    pRasInfo->pixelBitOffset = 0;\n+    pRasInfo->pixelStride = 4;\n+    pRasInfo->scanStride = glyph->rowBytes;\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_sun_font_ColorGlyphSurfaceData_initOps(JNIEnv *env,\n+                                            jobject sData)\n+{\n+    GlyphOps *ops =\n+        (GlyphOps*) SurfaceData_InitOps(env, sData, sizeof(GlyphOps));\n+    if (ops == NULL) {\n+        JNU_ThrowOutOfMemoryError(env,\n+            \"Initialization of ColorGlyphSurfaceData failed\");\n+        return;\n+    }\n+    ops->sdOps.Lock = Glyph_Lock;\n+    ops->sdOps.GetRasInfo = Glyph_GetRasInfo;\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_sun_font_ColorGlyphSurfaceData_setCurrentGlyph(JNIEnv *env,\n+                                                    jobject sData,\n+                                                    jlong imgPtr)\n+{\n+    GlyphOps *ops = (GlyphOps*) SurfaceData_GetOps(env, sData);\n+    if (ops == NULL) {\n+        return;\n+    }\n+    ops->glyph = (GlyphInfo*) jlong_to_ptr(imgPtr);\n+}\n\\ No newline at end of file\n","filename":"src\/java.desktop\/share\/native\/libfontmanager\/ColorGlyphSurfaceData.c","additions":93,"deletions":0,"binary":false,"changes":93,"status":"added"},{"patch":"@@ -53,1 +53,2 @@\n-GlyphBlitVector* setupBlitVector(JNIEnv *env, jobject glyphlist) {\n+GlyphBlitVector* setupBlitVector(JNIEnv *env, jobject glyphlist,\n+                                 jint fromGlyph, jint toGlyph) {\n@@ -64,1 +65,1 @@\n-    jint len =  (*env)->GetIntField(env, glyphlist, sunFontIDs.glyphListLen);\n+    jint len =  toGlyph - fromGlyph;\n@@ -87,5 +88,0 @@\n-    \/* Add 0.5 to x and y and then use floor (or an equivalent operation)\n-     * to round down the glyph positions to integral pixel positions.\n-     *\/\n-    x += 0.5f;\n-    y += 0.5f;\n@@ -93,1 +89,1 @@\n-        int n = -1;\n+        int n = fromGlyph * 2 - 1;\n@@ -108,1 +104,1 @@\n-            ginfo = (GlyphInfo*)((uintptr_t)imagePtrs[g]);\n+            ginfo = (GlyphInfo*)((uintptr_t)imagePtrs[g + fromGlyph]);\n@@ -121,1 +117,1 @@\n-            ginfo = (GlyphInfo*)((uintptr_t)imagePtrs[g]);\n+            ginfo = (GlyphInfo*)((uintptr_t)imagePtrs[g + fromGlyph]);\n@@ -138,0 +134,6 @@\n+\n+    if (!glyphPositions) {\n+        (*env)->SetFloatField(env, glyphlist, sunFontIDs.glyphListX, x);\n+        (*env)->SetFloatField(env, glyphlist, sunFontIDs.glyphListY, y);\n+    }\n+\n@@ -308,1 +310,1 @@\n- * Signature: (Lsun\/java2d\/SunGraphics2D;Lsun\/java2d\/SurfaceData;Lsun\/java2d\/font\/GlyphList;J)V\n+ * Signature: (Lsun\/java2d\/SunGraphics2D;Lsun\/java2d\/SurfaceData;Lsun\/java2d\/font\/GlyphList;II)V\n@@ -313,1 +315,2 @@\n-     jobject sg2d, jobject sData, jobject glyphlist) {\n+     jobject sg2d, jobject sData, jobject glyphlist,\n+     jint fromGlyph, jint toGlyph) {\n@@ -323,1 +326,1 @@\n-    if ((gbv = setupBlitVector(env, glyphlist)) == NULL) {\n+    if ((gbv = setupBlitVector(env, glyphlist, fromGlyph, toGlyph)) == NULL) {\n@@ -338,1 +341,1 @@\n- * Signature: (Lsun\/java2d\/SunGraphics2D;Lsun\/java2d\/SurfaceData;Lsun\/java2d\/font\/GlyphList;J)V\n+ * Signature: (Lsun\/java2d\/SunGraphics2D;Lsun\/java2d\/SurfaceData;Lsun\/java2d\/font\/GlyphList;II)V\n@@ -343,1 +346,2 @@\n-     jobject sg2d, jobject sData, jobject glyphlist) {\n+     jobject sg2d, jobject sData, jobject glyphlist,\n+     jint fromGlyph, jint toGlyph) {\n@@ -353,1 +357,1 @@\n-    if ((gbv = setupBlitVector(env, glyphlist)) == NULL) {\n+    if ((gbv = setupBlitVector(env, glyphlist, fromGlyph, toGlyph)) == NULL) {\n@@ -366,1 +370,1 @@\n- * Signature: (Lsun\/java2d\/SunGraphics2D;Lsun\/java2d\/SurfaceData;Lsun\/java2d\/font\/GlyphList;J)V\n+ * Signature: (Lsun\/java2d\/SunGraphics2D;Lsun\/java2d\/SurfaceData;Lsun\/java2d\/font\/GlyphList;II)V\n@@ -371,1 +375,2 @@\n-     jobject sg2d, jobject sData, jobject glyphlist) {\n+     jobject sg2d, jobject sData, jobject glyphlist,\n+     jint fromGlyph, jint toGlyph) {\n@@ -382,1 +387,2 @@\n-    if ((gbv = setupLCDBlitVector(env, glyphlist)) == NULL) {\n+    if ((gbv = setupLCDBlitVector(env, glyphlist, fromGlyph, toGlyph))\n+            == NULL) {\n@@ -484,1 +490,2 @@\n-GlyphBlitVector* setupLCDBlitVector(JNIEnv *env, jobject glyphlist) {\n+GlyphBlitVector* setupLCDBlitVector(JNIEnv *env, jobject glyphlist,\n+                                    jint fromGlyph, jint toGlyph) {\n@@ -495,1 +502,1 @@\n-    jint len =  (*env)->GetIntField(env, glyphlist, sunFontIDs.glyphListLen);\n+    jint len =  toGlyph - fromGlyph;\n@@ -534,1 +541,1 @@\n-        ginfo = (GlyphInfo*)((uintptr_t)imagePtrs[0]);\n+        ginfo = (GlyphInfo*)((uintptr_t)imagePtrs[fromGlyph]);\n@@ -546,7 +553,0 @@\n-    if (subPixPos) {\n-        x += 0.1666667f;\n-        y += 0.1666667f;\n-    } else {\n-        x += 0.5f;\n-        y += 0.5f;\n-    }\n@@ -555,1 +555,1 @@\n-        int n = -1;\n+        int n = fromGlyph * 2 - 1;\n@@ -569,1 +569,1 @@\n-            ginfo = (GlyphInfo*)((uintptr_t)imagePtrs[g]);\n+            ginfo = (GlyphInfo*)((uintptr_t)imagePtrs[g + fromGlyph]);\n@@ -611,1 +611,6 @@\n-                float pos = px + ginfo->topLeftX;\n+                float pos;\n+\n+                px += 0.1666667f - 0.5f;\n+                py += 0.1666667f - 0.5f;\n+\n+                pos = px + ginfo->topLeftX;\n@@ -650,1 +655,3 @@\n-            ginfo = (GlyphInfo*)((uintptr_t)imagePtrs[g]);\n+            jfloat px = x;\n+            jfloat py = y;\n+            ginfo = (GlyphInfo*)((uintptr_t)imagePtrs[g + fromGlyph]);\n@@ -665,1 +672,6 @@\n-                float pos = x + ginfo->topLeftX;\n+                float pos;\n+\n+                px += 0.1666667f - 0.5f;\n+                py += 0.1666667f - 0.5f;\n+\n+                pos = px + ginfo->topLeftX;\n@@ -675,1 +687,1 @@\n-                FLOOR_ASSIGN(gbv->glyphs[g].x, x + ginfo->topLeftX);\n+                FLOOR_ASSIGN(gbv->glyphs[g].x, px + ginfo->topLeftX);\n@@ -678,1 +690,2 @@\n-            FLOOR_ASSIGN(gbv->glyphs[g].y, y + ginfo->topLeftY);\n+            FLOOR_ASSIGN(gbv->glyphs[g].y, py + ginfo->topLeftY);\n+\n@@ -687,0 +700,5 @@\n+    if (!glyphPositions) {\n+        (*env)->SetFloatField(env, glyphlist, sunFontIDs.glyphListX, x);\n+        (*env)->SetFloatField(env, glyphlist, sunFontIDs.glyphListY, y);\n+    }\n+\n","filename":"src\/java.desktop\/share\/native\/libfontmanager\/DrawGlyphList.c","additions":54,"deletions":36,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -43,2 +43,4 @@\n-extern GlyphBlitVector* setupBlitVector(JNIEnv *env, jobject glyphlist);\n-extern GlyphBlitVector* setupLCDBlitVector(JNIEnv *env, jobject glyphlist);\n+extern GlyphBlitVector* setupBlitVector(JNIEnv *env, jobject glyphlist,\n+                                        jint fromGlyph, jint toGlyph);\n+extern GlyphBlitVector* setupLCDBlitVector(JNIEnv *env, jobject glyphlist,\n+                                           jint fromGlyph, jint toGlyph);\n","filename":"src\/java.desktop\/share\/native\/libfontmanager\/glyphblitting.h","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -176,1 +176,1 @@\n-         (*env)->GetFieldID(env, tmpClass, \"x\", \"F\"));\n+         (*env)->GetFieldID(env, tmpClass, \"gposx\", \"F\"));\n@@ -178,1 +178,1 @@\n-         (*env)->GetFieldID(env, tmpClass, \"y\", \"F\"));\n+         (*env)->GetFieldID(env, tmpClass, \"gposy\", \"F\"));\n","filename":"src\/java.desktop\/share\/native\/libfontmanager\/sunFont.c","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -80,0 +80,1 @@\n+            gl.startGlyphIteration();\n","filename":"src\/java.desktop\/unix\/classes\/sun\/font\/X11TextRenderer.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -86,1 +86,1 @@\n-            gl.getBounds();\n+            gl.startGlyphIteration();\n","filename":"src\/java.desktop\/unix\/classes\/sun\/font\/XRTextRenderer.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -60,0 +60,1 @@\n+    jint glyphCount;\n@@ -64,1 +65,2 @@\n-    if ((gbv = setupBlitVector(env, glyphlist)) == NULL) {\n+    glyphCount =  (*env)->GetIntField(env, glyphlist, sunFontIDs.glyphListLen);\n+    if ((gbv = setupBlitVector(env, glyphlist, 0, glyphCount)) == NULL) {\n","filename":"src\/java.desktop\/unix\/native\/libfontmanager\/X11TextRenderer.c","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,62 @@\n+\/*\n+ * Copyright 2021 JetBrains s.r.o.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8263583\n+ * @summary Checks that emoji characters are rendered\n+ * @requires (os.family == \"mac\")\n+ *\/\n+\n+import java.awt.*;\n+import java.awt.image.BufferedImage;\n+\n+public class MacEmoji {\n+    private static final int IMG_WIDTH = 20;\n+    private static final int IMG_HEIGHT = 20;\n+\n+    public static void main(String[] args) {\n+        BufferedImage img = new BufferedImage(IMG_WIDTH, IMG_HEIGHT,\n+                                              BufferedImage.TYPE_INT_RGB);\n+\n+        Graphics2D g = img.createGraphics();\n+        g.setColor(Color.white);\n+        g.fillRect(0, 0, IMG_WIDTH, IMG_HEIGHT);\n+        g.setFont(new Font(Font.DIALOG, Font.PLAIN, 12));\n+        g.drawString(\"\\uD83D\\uDE00\" \/* U+1F600 'GRINNING FACE' *\/, 2, 15);\n+        g.dispose();\n+\n+        boolean rendered = false;\n+        for (int x = 0; x < IMG_WIDTH; x++) {\n+            for (int y = 0; y < IMG_HEIGHT; y++) {\n+                if (img.getRGB(x, y) != 0xFFFFFFFF) {\n+                    rendered = true;\n+                    break;\n+                }\n+            }\n+        }\n+        if (!rendered) {\n+            throw new RuntimeException(\"Emoji character wasn't rendered\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/font\/MacEmoji.java","additions":62,"deletions":0,"binary":false,"changes":62,"status":"added"}]}