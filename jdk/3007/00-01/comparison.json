{"files":[{"patch":"@@ -327,0 +327,13 @@\n+MTLPaint* storedPaint = nil;\n+\n+static void EnableColorGlyphPainting(MTLContext *mtlc) {\n+    storedPaint = mtlc.paint;\n+    mtlc.paint = [[MTLPaint alloc] init];\n+}\n+\n+static void DisableColorGlyphPainting(MTLContext *mtlc) {\n+    [mtlc.paint release];\n+    mtlc.paint = storedPaint;\n+    storedPaint = nil;\n+}\n+\n@@ -340,0 +353,2 @@\n+        } else if (glyphMode == MODE_NO_CACHE_COLOR) {\n+            DisableColorGlyphPainting(mtlc);\n@@ -386,0 +401,2 @@\n+        } else if (glyphMode == MODE_NO_CACHE_COLOR) {\n+            DisableColorGlyphPainting(mtlc);\n@@ -458,0 +475,2 @@\n+        } else if (glyphMode == MODE_NO_CACHE_COLOR) {\n+            DisableColorGlyphPainting(mtlc);\n@@ -520,0 +539,2 @@\n+        } else if (glyphMode == MODE_NO_CACHE_COLOR) {\n+            DisableColorGlyphPainting(mtlc);\n@@ -589,0 +610,45 @@\n+static jboolean\n+MTLTR_DrawColorGlyphNoCache(MTLContext *mtlc,\n+                            GlyphInfo *ginfo, jint x, jint y, BMTLSDOps *dstOps)\n+{\n+    id<MTLTexture> dest = dstOps->pTexture;\n+    const void *src = ginfo->image;\n+    jint w = ginfo->width;\n+    jint h = ginfo->height;\n+    jint rowBytes = ginfo->rowBytes;\n+    unsigned int imageSize = rowBytes * h;\n+\n+    J2dTraceLn(J2D_TRACE_INFO, \"MTLTR_DrawColorGlyphNoCache\");\n+\n+    if (glyphMode != MODE_NO_CACHE_COLOR) {\n+        if (glyphMode == MODE_NO_CACHE_GRAY) {\n+            MTLVertexCache_DisableMaskCache(mtlc);\n+        } else if (glyphMode == MODE_USE_CACHE_GRAY) {\n+            MTLTR_DisableGlyphVertexCache(mtlc);\n+        } else if (glyphMode == MODE_USE_CACHE_LCD) {\n+            [mtlc.encoderManager endEncoder];\n+            lcdCacheEncoder = nil;\n+        }\n+        glyphMode = MODE_NO_CACHE_COLOR;\n+        EnableColorGlyphPainting(mtlc);\n+    }\n+\n+    MTLPooledTextureHandle* texHandle = [mtlc.texturePool getTexture:w height:h format:MTLPixelFormatBGRA8Unorm];\n+    if (texHandle == nil) {\n+        J2dTraceLn(J2D_TRACE_ERROR, \"MTLTR_DrawColorGlyphNoCache: can't obtain temporary texture object from pool\");\n+        return JNI_FALSE;\n+    }\n+\n+    [[mtlc getCommandBufferWrapper] registerPooledTexture:texHandle];\n+\n+    [texHandle.texture replaceRegion:MTLRegionMake2D(0, 0, w, h)\n+                         mipmapLevel:0\n+                           withBytes:src\n+                         bytesPerRow:rowBytes];\n+\n+    drawTex2Tex(mtlc, texHandle.texture, dest, JNI_FALSE, dstOps->isOpaque, INTERPOLATION_NEAREST_NEIGHBOR,\n+                0, 0, w, h, x, y, x + w, y + h);\n+\n+    return JNI_TRUE;\n+}\n+\n@@ -619,1 +685,1 @@\n-        jboolean grayscale, ok;\n+        jboolean ok;\n@@ -629,2 +695,0 @@\n-        grayscale = (ginfo->rowBytes == ginfo->width);\n-\n@@ -654,1 +718,1 @@\n-        if (grayscale) {\n+        if (ginfo->rowBytes == ginfo->width) {\n@@ -665,0 +729,4 @@\n+        } else if (ginfo->rowBytes == ginfo->width * 4) {\n+            J2dTraceLn(J2D_TRACE_INFO, \"MTLTR_DrawGlyphList color glyph no cache\");\n+            ok = MTLTR_DrawColorGlyphNoCache(mtlc, ginfo, x, y, dstOps);\n+            flushBeforeLCD = JNI_FALSE;\n@@ -723,0 +791,2 @@\n+    } else if (glyphMode == MODE_NO_CACHE_COLOR) {\n+        DisableColorGlyphPainting(mtlc);\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/java2d\/metal\/MTLTextRenderer.m","additions":74,"deletions":4,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * @key headful\n@@ -27,1 +28,3 @@\n- * @summary Checks that emoji characters are rendered\n+ * @summary Checks that emoji character has a non-empty and identical\n+ *          representation when rendered to different types of images,\n+ *          including an accelerated (OpenGL or Metal) surface.\n@@ -29,0 +32,1 @@\n+ * @run main\/othervm -Dsun.java2d.uiScale=1 MacEmoji\n@@ -33,0 +37,2 @@\n+import java.awt.image.VolatileImage;\n+import java.util.List;\n@@ -39,2 +45,3 @@\n-        BufferedImage img = new BufferedImage(IMG_WIDTH, IMG_HEIGHT,\n-                                              BufferedImage.TYPE_INT_RGB);\n+        GraphicsConfiguration cfg\n+                = GraphicsEnvironment.getLocalGraphicsEnvironment()\n+                .getDefaultScreenDevice().getDefaultConfiguration();\n@@ -42,6 +49,14 @@\n-        Graphics2D g = img.createGraphics();\n-        g.setColor(Color.white);\n-        g.fillRect(0, 0, IMG_WIDTH, IMG_HEIGHT);\n-        g.setFont(new Font(Font.DIALOG, Font.PLAIN, 12));\n-        g.drawString(\"\\uD83D\\uDE00\" \/* U+1F600 'GRINNING FACE' *\/, 2, 15);\n-        g.dispose();\n+        VolatileImage vImg = cfg.createCompatibleVolatileImage(IMG_WIDTH,\n+                                                               IMG_HEIGHT);\n+        BufferedImage refImg;\n+        int attempt = 0;\n+        do {\n+            if (++attempt > 10) {\n+                throw new RuntimeException(\"Failed to render to VolatileImage\");\n+            }\n+            if (vImg.validate(cfg) == VolatileImage.IMAGE_INCOMPATIBLE) {\n+                throw new RuntimeException(\"Unexpected validation failure\");\n+            }\n+            drawEmoji(vImg);\n+            refImg = vImg.getSnapshot();\n+        } while (vImg.contentsLost());\n@@ -52,1 +67,1 @@\n-                if (img.getRGB(x, y) != 0xFFFFFFFF) {\n+                if (refImg.getRGB(x, y) != 0xFFFFFFFF) {\n@@ -61,0 +76,31 @@\n+\n+        List<Integer> imageTypes = List.of(\n+                BufferedImage.TYPE_INT_RGB,\n+                BufferedImage.TYPE_INT_ARGB,\n+                BufferedImage.TYPE_INT_ARGB_PRE,\n+                BufferedImage.TYPE_INT_BGR,\n+                BufferedImage.TYPE_3BYTE_BGR,\n+                BufferedImage.TYPE_4BYTE_ABGR,\n+                BufferedImage.TYPE_4BYTE_ABGR_PRE\n+        );\n+        for (Integer type : imageTypes) {\n+            BufferedImage img = new BufferedImage(IMG_WIDTH, IMG_HEIGHT, type);\n+            drawEmoji(img);\n+            for (int x = 0; x < IMG_WIDTH; x++) {\n+                for (int y = 0; y < IMG_HEIGHT; y++) {\n+                    if (refImg.getRGB(x, y) != img.getRGB(x, y)) {\n+                        throw new RuntimeException(\n+                                \"Rendering differs for image type \" + type);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private static void drawEmoji(Image img) {\n+        Graphics g = img.getGraphics();\n+        g.setColor(Color.white);\n+        g.fillRect(0, 0, IMG_WIDTH, IMG_HEIGHT);\n+        g.setFont(new Font(Font.DIALOG, Font.PLAIN, 12));\n+        g.drawString(\"\\uD83D\\uDE00\" \/* U+1F600 'GRINNING FACE' *\/, 2, 15);\n+        g.dispose();\n","filename":"test\/jdk\/java\/awt\/font\/MacEmoji.java","additions":56,"deletions":10,"binary":false,"changes":66,"status":"modified"}]}