{"files":[{"patch":"@@ -94,0 +94,3 @@\n+     * If obuffer is null\/zero-sized, do not allocate a new buffer.\n+     * This reduces allocation for AEAD ciphers that never return data from update\n+     *\n@@ -97,0 +100,3 @@\n+        if (obuffer == null || obuffer.length == 0) {\n+            return;\n+        }\n@@ -98,1 +104,1 @@\n-        if (obuffer == null || obuffer.length < minLen) {\n+        if (obuffer.length < minLen) {\n@@ -147,1 +153,9 @@\n-            int ostored = cipher.update(ibuffer, 0, 1, obuffer);\n+            \/\/ initial obuffer is assigned by update\/doFinal;\n+            \/\/ for AEAD ciphers, obuffer is always null or zero-length here\n+            int ostored;\n+            if (obuffer != null && obuffer.length > 0) {\n+                ostored = cipher.update(ibuffer, 0, 1, obuffer);\n+            } else {\n+                obuffer = cipher.update(ibuffer, 0, 1);\n+                ostored = (obuffer != null) ? obuffer.length : 0;\n+            }\n@@ -189,1 +203,9 @@\n-            int ostored = cipher.update(b, off, len, obuffer);\n+            \/\/ initial obuffer is assigned by update\/doFinal;\n+            \/\/ for AEAD ciphers, obuffer is always null or zero-length here\n+            int ostored;\n+            if (obuffer != null && obuffer.length > 0) {\n+                ostored = cipher.update(b, off, len, obuffer);\n+            } else {\n+                obuffer = cipher.update(b, off, len);\n+                ostored = (obuffer != null) ? obuffer.length : 0;\n+            }\n@@ -244,1 +266,7 @@\n-            int ostored = cipher.doFinal(obuffer, 0);\n+            int ostored;\n+            if (obuffer != null && obuffer.length > 0) {\n+                ostored = cipher.doFinal(obuffer, 0);\n+            } else {\n+                obuffer = cipher.doFinal();\n+                ostored = obuffer.length;\n+            }\n","filename":"src\/java.base\/share\/classes\/javax\/crypto\/CipherOutputStream.java","additions":32,"deletions":4,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -0,0 +1,122 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.javax.crypto.full;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Setup;\n+\n+import javax.crypto.Cipher;\n+import javax.crypto.CipherOutputStream;\n+import javax.crypto.spec.GCMParameterSpec;\n+import javax.crypto.spec.SecretKeySpec;\n+import java.io.ByteArrayOutputStream;\n+import java.io.OutputStream;\n+\n+\/**\n+ * This performance test runs AES\/GCM encryption and decryption using CipherOutputStream.\n+ *\n+ * This test rotates the IV and creates a new GCMParameterSpec for each encrypt\n+ * benchmark operation\n+ *\/\n+\n+public class AESGCMCipherOutputStream extends CryptoBase {\n+\n+    @Param({\"128\"})\n+    private int keyLength;\n+\n+    @Param({\"16384\", \"1048576\"})\n+    private int dataSize;\n+\n+    byte[] encryptedData;\n+    byte[] in;\n+    ByteArrayOutputStream out;\n+    private Cipher encryptCipher;\n+    private Cipher decryptCipher;\n+    SecretKeySpec ks;\n+    GCMParameterSpec gcm_spec;\n+    byte[] iv;\n+\n+    private static final int IV_BUFFER_SIZE = 32;\n+    private static final int IV_MODULO = IV_BUFFER_SIZE - 16;\n+    int iv_index = 0;\n+\n+    private int next_iv_index() {\n+        int r = iv_index;\n+        iv_index = (iv_index + 1) % IV_MODULO;\n+        return r;\n+    }\n+\n+    @Setup\n+    public void setup() throws Exception {\n+        setupProvider();\n+\n+        \/\/ Setup key material\n+        byte[] keystring = fillSecureRandom(new byte[keyLength \/ 8]);\n+        ks = new SecretKeySpec(keystring, \"AES\");\n+        iv = fillSecureRandom(new byte[IV_BUFFER_SIZE]);\n+        gcm_spec = new GCMParameterSpec(96, iv, next_iv_index(), 16);\n+\n+        \/\/ Setup Cipher classes\n+        encryptCipher = makeCipher(prov, \"AES\/GCM\/NoPadding\");\n+        encryptCipher.init(Cipher.ENCRYPT_MODE, ks, gcm_spec);\n+        decryptCipher = makeCipher(prov, \"AES\/GCM\/NoPadding\");\n+        decryptCipher.init(Cipher.DECRYPT_MODE, ks,\n+            encryptCipher.getParameters().\n+                getParameterSpec(GCMParameterSpec.class));\n+\n+        \/\/ Setup input\/output buffers\n+        in = fillRandom(new byte[dataSize]);\n+        encryptedData = new byte[encryptCipher.getOutputSize(in.length)];\n+        out = new ByteArrayOutputStream(encryptedData.length);\n+        encryptCipher.doFinal(in, 0, in.length, encryptedData, 0);\n+    }\n+\n+    @Benchmark\n+    public byte[] encrypt() throws Exception {\n+        out.reset();\n+        gcm_spec = new GCMParameterSpec(96, iv, next_iv_index(), 16);\n+        encryptCipher.init(Cipher.ENCRYPT_MODE, ks, gcm_spec);\n+\n+        OutputStream cout = new CipherOutputStream(out, encryptCipher);\n+        for (int i = 0; i < in.length; i += 512) {\n+            cout.write(in, i, Math.min(512, in.length - i));\n+        }\n+        cout.close();\n+        return out.toByteArray();\n+    }\n+\n+    @Benchmark\n+    public byte[] decrypt() throws Exception {\n+        out.reset();\n+        decryptCipher.init(Cipher.DECRYPT_MODE, ks,\n+                encryptCipher.getParameters().\n+                        getParameterSpec(GCMParameterSpec.class));\n+        OutputStream cout = new CipherOutputStream(out, decryptCipher);\n+        for (int i = 0; i < encryptedData.length; i += 512) {\n+            cout.write(encryptedData, i, Math.min(512, encryptedData.length - i));\n+        }\n+        cout.close();\n+        return out.toByteArray();\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/javax\/crypto\/full\/AESGCMCipherOutputStream.java","additions":122,"deletions":0,"binary":false,"changes":122,"status":"added"}]}