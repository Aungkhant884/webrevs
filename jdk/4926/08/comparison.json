{"files":[{"patch":"@@ -98,0 +98,53 @@\n+static bool is_hidden_class_pattern(const char * current, const char * start) {\n+  int index = 0;\n+  char c = *(++current);\n+\n+  while (c != '\\0' && c != '*' && c != ':') {\n+    if (index == 0) {\n+      \/\/ The first non-'*' char after '\/' should be '0'\n+      if (c != '0') {\n+        return false;\n+      }\n+    } else if (index == 1) {\n+      \/\/ The second non-'*' char after '\/' should be 'x'\n+      if (c != 'x') {\n+        return false;\n+      }\n+    } else {\n+      \/\/ The remaining non-'*' chars should be xdigits\n+      if (!isxdigit(c)) {\n+        return false;\n+      }\n+    }\n+    index++;\n+    c = *(++current);\n+  }\n+\n+  if (c == '*' || c == ':') {\n+    char next = *(++current);\n+    if (next == ':') {\n+      if (c == ':') {\n+        \/\/ Full hidden class name without '*'\n+        return true;\n+      } else {\n+        char next_next = *(++current);\n+        if (next_next == ':') {\n+          \/\/ May be partial hidden class name with suffix '*'\n+          if (index == 0) {\n+            \/\/ To be conservative for \"\/*::\" pattern\n+            \/\/ Check if '$' exists to avoid cases like \"java.util\/*::method\"\n+            const char* pos = strchr(start, '$');\n+            if (pos != NULL && pos < current) {\n+              return true;\n+            }\n+          } else {\n+            return true;\n+          }\n+        }\n+      }\n+    }\n+  }\n+\n+  return false;\n+}\n+\n@@ -118,2 +171,12 @@\n-          error_msg = \"Method pattern uses '\/' together with '::'\";\n-          return false;\n+          \/\/ Check whether it's a hidden class method.\n+          if (is_hidden_class_pattern(lp, line)) {\n+            \/\/ According to ClassFileParser::mangle_hidden_class_name, the pattern of\n+            \/\/ hidden class name in the VM should be: _class_name, \"+\", and &ik\n+            \/\/ But \"+\" will be replaced with \"\/\" when it is printed by PrintCompilation.\n+            \/\/ So replace '\/' with '+'\n+            *lp = '+';\n+          } else {\n+            \/\/ Not a hidden class method\n+            error_msg = \"Method pattern uses '\/' together with '::'\";\n+            return false;\n+          }\n","filename":"src\/hotspot\/share\/compiler\/methodMatcher.cpp","additions":65,"deletions":2,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -159,0 +159,7 @@\n+        testCases.add(toString, \"java.util.ResourceBundle$$Lambda$1\/0x00000008010413c8::run\", NO_MATCH);\n+        testCases.add(toString, \"java.util.ResourceBundle$$Lambda$1\/*::run\", NO_MATCH);\n+        testCases.add(toString, \"java.util\/*::run\", PARSING_FAILURE);\n+        testCases.add(toString, \"java.util.ResourceBundle$$Lambda$1\/01234::run\", PARSING_FAILURE);\n+        testCases.add(toString, \"java.util.ResourceBundle$$Lambda$1\/0x1234u::run\", PARSING_FAILURE);\n+        testCases.add(toString, \"java.util\/*.ResourceBundle$$Lambda$1\/0x00000008010413c8::run\", PARSING_FAILURE);\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/oracle\/MethodMatcherTest.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"}]}