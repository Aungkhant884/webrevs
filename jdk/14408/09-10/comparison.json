{"files":[{"patch":"@@ -544,0 +544,1 @@\n+        private final int DEDUP_LIST_VAR = MAX_LOCAL_VARS + 2;\n@@ -742,1 +743,1 @@\n-            final ClassDesc arrayListClassDesc = ClassDesc.ofInternalName(\"java\/util\/ArrayList\");\n+            ClassDesc arrayListClassDesc = ClassDesc.ofInternalName(\"java\/util\/ArrayList\");\n@@ -744,1 +745,4 @@\n-            final int firstVariableForDedup = nextLocalVar;\n+            int firstVar = nextLocalVar;\n+            var wrapper = new Object() {\n+                int lastCopiedVar = nextLocalVar;\n+            };\n@@ -748,1 +752,1 @@\n-                    MethodTypeDesc.of(CD_MODULE_DESCRIPTOR.arrayType()),\n+                    MTD_ModuleDescriptorArray,\n@@ -757,1 +761,2 @@\n-                           .invokespecial(arrayListClassDesc, \"<init>\", MethodTypeDesc.of(CD_void))\n+                           .sipush(moduleInfos.size())\n+                           .invokespecial(arrayListClassDesc, INIT_NAME, MethodTypeDesc.of(CD_int))\n@@ -771,1 +776,1 @@\n-                int index = n;          \/\/ the index of which ModuleInfo being processed in the current batch\n+                int index = n;       \/\/ the index of which ModuleInfo being processed in the current batch\n@@ -774,1 +779,1 @@\n-                        helperMethodNamePrefix + index[0],\n+                        helperMethodNamePrefix + index,\n@@ -778,1 +783,2 @@\n-                            List<ModuleInfo> currentBatch = splitModuleInfos.get(index[0]);\n+                            cob.aload(2)\n+                               .astore(DEDUP_LIST_VAR);\n@@ -780,4 +786,4 @@\n-                            if (nextLocalVar > firstVariableForDedup) {\n-                                for (int i = nextLocalVar-1; i >= firstVariableForDedup; i--) {\n-                                    cob.aload(2)\n-                                       .constantInstruction(i-firstVariableForDedup)\n+                            if (nextLocalVar > firstVar) {\n+                                for (int i = firstVar; i < nextLocalVar; i++) {\n+                                    cob.aload(DEDUP_LIST_VAR)\n+                                       .constantInstruction(i - firstVar)\n@@ -789,2 +795,3 @@\n-                            for (int j = 0; j < moduleInfosPackage.size(); j++) {\n-                                ModuleInfo minfo = moduleInfosPackage.get(j);\n+                            List<ModuleInfo> currentBatch = splitModuleInfos.get(index);\n+                            for (int j = 0; j < currentBatch.size(); j++) {\n+                                ModuleInfo minfo = currentBatch.get(j);\n@@ -794,2 +801,1 @@\n-                                                            globalCount[0]).build();\n-                                globalCount[0]++;\n+                                                            start + j).build();\n@@ -798,8 +804,4 @@\n-                            if (index[0] + 1 < (splitModuleInfos.size())) {\n-                                if (nextLocalVar > firstVariableForDedup) {\n-                                    cob.new_(arrayListClassDesc)\n-                                       .dup()\n-                                       .invokespecial(arrayListClassDesc, \"<init>\", MethodTypeDesc.of(CD_void))\n-                                       .astore(nextLocalVar);\n-                                    for (int i = firstVariableForDedup; i < nextLocalVar; i++) {\n-                                        cob.aload(nextLocalVar)\n+                            if (index < splitModuleInfos.size() - 1) {\n+                                if (nextLocalVar > wrapper.lastCopiedVar) {\n+                                    for (int i = wrapper.lastCopiedVar + 1; i < nextLocalVar; i++) {\n+                                        cob.aload(DEDUP_LIST_VAR)\n@@ -810,0 +812,1 @@\n+                                    wrapper.lastCopiedVar = nextLocalVar;\n@@ -813,1 +816,1 @@\n-                                   .aload(nextLocalVar)\n+                                   .aload(DEDUP_LIST_VAR)\n@@ -816,1 +819,1 @@\n-                                           helperMethodNamePrefix + (index[0] + 1),\n+                                           helperMethodNamePrefix + (index+1),\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/plugins\/SystemModulesPlugin.java","additions":28,"deletions":25,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n- * @run main\/othervm -verbose:gc -Xmx1g -Xlog:init=debug -XX:+UnlockDiagnosticVMOptions -XX:+BytecodeVerificationLocal JLink100Modules\n+ * @run main\/othervm -Xmx1g -Xlog:init=debug -XX:+UnlockDiagnosticVMOptions -XX:+BytecodeVerificationLocal JLink100Modules\n@@ -124,0 +124,17 @@\n+\n+        Path bin = src.resolve(\"out-jlink\").resolve(\"bin\");\n+\n+        \/\/ String binName = jdk.internal.util.OperatingSystem.isWindows() ? \"java.exe\" : \"java\";\n+        String binName = \"java.exe\";\n+        if (!Files.exists(Path.of(binName))) {\n+            binName = \"java\";\n+        }\n+\n+        ProcessBuilder processBuilder = new ProcessBuilder(binName, \"-XX:+UnlockDiagnosticVMOptions\", \"-XX:+BytecodeVerificationLocal\", \"-m\", \"bug8240567x\/testpackage.JLink100ModulesTest\");\n+        processBuilder.inheritIO();\n+        processBuilder.directory(bin.toFile());\n+        Process process = processBuilder.start();\n+        int exitCode = process.waitFor();\n+\n+        System.err.println(exitCode);\n+        if (exitCode != 0) throw new AssertionError(\"Exit code is not 0\");\n","filename":"test\/jdk\/tools\/jlink\/JLink100Modules.java","additions":18,"deletions":1,"binary":false,"changes":19,"status":"modified"}]}