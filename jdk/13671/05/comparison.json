{"files":[{"patch":"@@ -598,10 +598,1 @@\n-  $1_JMH_JVM_ARGS := -Djava.library.path=$$(TEST_IMAGE_DIR)\/micro\/native \\\n-        --add-exports java.base\/jdk.internal.org.objectweb.asm=ALL-UNNAMED \\\n-        --add-exports java.base\/jdk.internal.org.objectweb.asm.tree=ALL-UNNAMED \\\n-        --add-exports java.base\/jdk.internal.classfile=ALL-UNNAMED \\\n-        --add-exports java.base\/jdk.internal.classfile.attribute=ALL-UNNAMED \\\n-        --add-exports java.base\/jdk.internal.classfile.constantpool=ALL-UNNAMED \\\n-        --add-exports java.base\/jdk.internal.classfile.instruction=ALL-UNNAMED \\\n-        --add-exports java.base\/jdk.internal.classfile.java.lang.constant=ALL-UNNAMED \\\n-        --add-exports java.base\/jdk.internal.classfile.components=ALL-UNNAMED \\\n-        --add-exports java.base\/jdk.internal.classfile.impl=ALL-UNNAMED\n+  $1_JMH_JVM_ARGS := -Djava.library.path=$$(TEST_IMAGE_DIR)\/micro\/native\n","filename":"make\/RunTests.gmk","additions":1,"deletions":10,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+import jdk.internal.classfile.impl.Util;\n@@ -84,1 +85,1 @@\n-        return enclosingMethodType().map(n -> MethodTypeDesc.ofDescriptor(n.stringValue()));\n+        return enclosingMethod().map(Util::methodTypeSymbol);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/attribute\/EnclosingMethodAttribute.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-import java.lang.constant.ClassDesc;\n+import jdk.internal.classfile.impl.Util;\n@@ -53,1 +53,1 @@\n-                                           ClassDesc.ofDescriptor(type().stringValue()),\n+                                           Util.fieldTypeSymbol(nameAndType()),\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/constantpool\/ConstantDynamicEntry.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -46,0 +46,2 @@\n+import jdk.internal.classfile.impl.AbstractPoolEntry.ClassEntryImpl;\n+import jdk.internal.classfile.impl.AbstractPoolEntry.NameAndTypeEntryImpl;\n@@ -163,1 +165,3 @@\n-        return classEntry(utf8Entry(classDesc.isArray() ? classDesc.descriptorString() : Util.toInternalName(classDesc)));\n+        ClassEntryImpl ret = (ClassEntryImpl)classEntry(utf8Entry(classDesc.isArray() ? classDesc.descriptorString() : Util.toInternalName(classDesc)));\n+        ret.sym = classDesc;\n+        return ret;\n@@ -236,1 +240,3 @@\n-        return nameAndTypeEntry(utf8Entry(name), utf8Entry(type.descriptorString()));\n+        var ret = (NameAndTypeEntryImpl)nameAndTypeEntry(utf8Entry(name), utf8Entry(type.descriptorString()));\n+        ret.typeSym = type;\n+        return ret;\n@@ -249,1 +255,3 @@\n-        return nameAndTypeEntry(utf8Entry(name), utf8Entry(type.descriptorString()));\n+        var ret = (NameAndTypeEntryImpl)nameAndTypeEntry(utf8Entry(name), utf8Entry(type.descriptorString()));\n+        ret.typeSym = type;\n+        return ret;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/constantpool\/ConstantPoolBuilder.java","additions":11,"deletions":3,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import java.lang.constant.MethodTypeDesc;\n@@ -32,0 +31,1 @@\n+import jdk.internal.classfile.impl.Util;\n@@ -46,1 +46,1 @@\n-                                      MethodTypeDesc.ofDescriptor(type().stringValue()),\n+                                      Util.methodTypeSymbol(nameAndType()),\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/constantpool\/InvokeDynamicEntry.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -53,3 +53,1 @@\n-    default MethodTypeDesc asSymbol() {\n-        return MethodTypeDesc.ofDescriptor(descriptor().stringValue());\n-    }\n+    MethodTypeDesc asSymbol();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/constantpool\/MethodTypeEntry.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -427,1 +427,1 @@\n-            return Util.parameterSlots(type().stringValue());\n+            return Util.parameterSlots(Util.methodTypeSymbol(method().nameAndType()));\n@@ -1062,1 +1062,1 @@\n-                   ? Util.parameterSlots(methodEntry.nameAndType().type().stringValue()) + 1\n+                   ? Util.parameterSlots(Util.methodTypeSymbol(methodEntry.nameAndType())) + 1\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/AbstractInstruction.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.lang.invoke.TypeDescriptor;\n@@ -166,0 +167,4 @@\n+            this(cpm, index, s, hashString(s.hashCode()));\n+        }\n+\n+        Utf8EntryImpl(ConstantPool cpm, int index, String s, int hash) {\n@@ -173,1 +178,1 @@\n-            this.hash = hashString(s.hashCode());\n+            this.hash = hash;\n@@ -559,0 +564,2 @@\n+        public ClassDesc sym = null;\n+\n@@ -565,1 +572,7 @@\n-            return cp.canWriteDirect(constantPool) ? this : cp.classEntry(ref1);\n+            if (cp.canWriteDirect(constantPool)) {\n+                return this;\n+            } else {\n+                ClassEntryImpl ret = (ClassEntryImpl)cp.classEntry(ref1);\n+                ret.sym = sym;\n+                return ret;\n+            }\n@@ -570,1 +583,5 @@\n-            return Util.toClassDesc(asInternalName());\n+            var sym = this.sym;\n+            if (sym != null) {\n+                return sym;\n+            }\n+            return this.sym = Util.toClassDesc(asInternalName());\n@@ -640,0 +657,2 @@\n+        public TypeDescriptor typeSym = null;\n+\n@@ -654,0 +673,16 @@\n+        public ClassDesc fieldTypeSymbol() {\n+            if (typeSym instanceof ClassDesc cd) {\n+                return cd;\n+            } else {\n+                return (ClassDesc)(typeSym = ClassDesc.ofDescriptor(ref2.stringValue()));\n+            }\n+        }\n+\n+        public MethodTypeDesc methodTypeSymbol() {\n+            if (typeSym instanceof MethodTypeDesc mtd) {\n+                return mtd;\n+            } else {\n+                return (MethodTypeDesc)(typeSym = MethodTypeDesc.ofDescriptor(ref2.stringValue()));\n+            }\n+        }\n+\n@@ -656,1 +691,7 @@\n-            return cp.canWriteDirect(constantPool) ? this : cp.nameAndTypeEntry(ref1, ref2);\n+            if (cp.canWriteDirect(constantPool)) {\n+                return this;\n+            } else {\n+                var ret = (NameAndTypeEntryImpl)cp.nameAndTypeEntry(ref1, ref2);\n+                ret.typeSym = typeSym;\n+                return ret;\n+            }\n@@ -921,0 +962,2 @@\n+        public MethodTypeDesc sym = null;\n+\n@@ -932,1 +975,16 @@\n-            return cp.canWriteDirect(constantPool) ? this : cp.methodTypeEntry(ref1);\n+            if (cp.canWriteDirect(constantPool)) {\n+                return this;\n+            } else {\n+                var ret = (MethodTypeEntryImpl)cp.methodTypeEntry(ref1);\n+                ret.sym = sym;\n+                return ret;\n+            }\n+        }\n+\n+        @Override\n+        public MethodTypeDesc asSymbol() {\n+            var sym = this.sym;\n+            if (sym != null) {\n+                return sym;\n+            }\n+            return this.sym = MethodTypeDesc.ofDescriptor(descriptor().stringValue());\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/AbstractPoolEntry.java","additions":63,"deletions":5,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -63,1 +63,1 @@\n-        this.maxLocals = Util.maxLocals(methodInfo.methodFlags(), methodInfo.methodType().stringValue());\n+        this.maxLocals = Util.maxLocals(methodInfo.methodFlags(), methodInfo.methodTypeSymbol());\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/BufferedCodeBuilder.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import java.lang.constant.MethodTypeDesc;\n@@ -54,0 +55,1 @@\n+    MethodTypeDesc mDesc;\n@@ -94,0 +96,12 @@\n+    @Override\n+    public MethodTypeDesc methodTypeSymbol() {\n+        if (mDesc == null) {\n+            if (original instanceof MethodInfo mi) {\n+                mDesc = mi.methodTypeSymbol();\n+            } else {\n+                mDesc = MethodTypeDesc.ofDescriptor(methodType().stringValue());\n+            }\n+        }\n+        return mDesc;\n+    }\n+\n@@ -102,1 +116,1 @@\n-            parameterSlots = Util.parseParameterSlots(methodFlags(), methodType().stringValue());\n+            parameterSlots = Util.parseParameterSlots(methodFlags(), methodTypeSymbol());\n@@ -161,0 +175,5 @@\n+        @Override\n+        public MethodTypeDesc methodTypeSymbol() {\n+            return BufferedMethodBuilder.this.methodTypeSymbol();\n+        }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/BufferedMethodBuilder.java","additions":20,"deletions":1,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -133,1 +133,1 @@\n-        this.topLocal = Util.maxLocals(methodInfo.methodFlags(), methodInfo.methodType().stringValue());\n+        this.topLocal = Util.maxLocals(methodInfo.methodFlags(), methodInfo.methodTypeSymbol());\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/DirectCodeBuilder.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.lang.constant.MethodTypeDesc;\n@@ -49,0 +50,1 @@\n+    MethodTypeDesc mDesc;\n@@ -80,0 +82,12 @@\n+    @Override\n+    public MethodTypeDesc methodTypeSymbol() {\n+        if (mDesc == null) {\n+            if (original instanceof MethodInfo mi) {\n+                mDesc = mi.methodTypeSymbol();\n+            } else {\n+                mDesc = MethodTypeDesc.ofDescriptor(methodType().stringValue());\n+            }\n+        }\n+        return mDesc;\n+    }\n+\n@@ -88,1 +102,1 @@\n-            parameterSlots = Util.parseParameterSlots(methodFlags(), methodType().stringValue());\n+            parameterSlots = Util.parseParameterSlots(methodFlags(), methodTypeSymbol());\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/DirectMethodBuilder.java","additions":15,"deletions":1,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import java.lang.constant.MethodTypeDesc;\n@@ -42,0 +43,1 @@\n+    private MethodTypeDesc mDesc;\n@@ -73,0 +75,8 @@\n+    @Override\n+    public MethodTypeDesc methodTypeSymbol() {\n+        if (mDesc == null) {\n+            mDesc = MethodTypeDesc.ofDescriptor(methodType().stringValue());\n+        }\n+        return mDesc;\n+    }\n+\n@@ -81,1 +91,1 @@\n-            parameterSlots = Util.parseParameterSlots(methodFlags(), methodType().stringValue());\n+            parameterSlots = Util.parseParameterSlots(methodFlags(), methodTypeSymbol());\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/MethodImpl.java","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import java.lang.constant.MethodTypeDesc;\n@@ -34,0 +35,1 @@\n+    MethodTypeDesc methodTypeSymbol();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/MethodInfo.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -106,0 +106,1 @@\n+        this.doneFullScan = true;\n@@ -383,2 +384,3 @@\n-        var ce = tryFindUtf8(AbstractPoolEntry.hashString(s.hashCode()), s);\n-        return ce == null ? internalAdd(new AbstractPoolEntry.Utf8EntryImpl(this, size, s)) : ce;\n+        int hash = AbstractPoolEntry.hashString(s.hashCode());\n+        var ce = tryFindUtf8(hash, s);\n+        return ce == null ? internalAdd(new AbstractPoolEntry.Utf8EntryImpl(this, size, s, hash)) : ce;\n@@ -462,1 +464,3 @@\n-        return methodTypeEntry(utf8Entry(descriptor.descriptorString()));\n+        var ret = (AbstractPoolEntry.MethodTypeEntryImpl)methodTypeEntry(utf8Entry(descriptor.descriptorString()));\n+        ret.sym = descriptor;\n+        return ret;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/SplitConstantPool.java","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-                MethodTypeDesc.ofDescriptor(dcb.methodInfo.methodType().stringValue()),\n+                dcb.methodInfo.methodTypeSymbol(),\n@@ -109,1 +109,1 @@\n-            maxLocals += TypeKind.from(cd).slotSize();\n+            maxLocals += Util.slotSize(cd);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/StackCounter.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -66,1 +66,1 @@\n-                method.methodType().stringValue(),\n+                method.methodTypeSymbol(),\n@@ -70,2 +70,1 @@\n-    public static List<VerificationTypeInfo> initFrameLocals(ClassEntry thisClass, String methodName, String methodType, boolean isStatic) {\n-        var mdesc = MethodTypeDesc.ofDescriptor(methodType);\n+    public static List<VerificationTypeInfo> initFrameLocals(ClassEntry thisClass, String methodName, MethodTypeDesc methodType, boolean isStatic) {\n@@ -75,1 +74,1 @@\n-            vtis = new VerificationTypeInfo[mdesc.parameterCount() + 1];\n+            vtis = new VerificationTypeInfo[methodType.parameterCount() + 1];\n@@ -82,1 +81,1 @@\n-            vtis = new VerificationTypeInfo[mdesc.parameterCount()];\n+            vtis = new VerificationTypeInfo[methodType.parameterCount()];\n@@ -84,7 +83,7 @@\n-        for(var arg : mdesc.parameterList()) {\n-            vtis[i++] = switch (arg.descriptorString()) {\n-                case \"I\", \"S\", \"C\" ,\"B\", \"Z\" ->  SimpleVerificationTypeInfo.ITEM_INTEGER;\n-                case \"J\" -> SimpleVerificationTypeInfo.ITEM_LONG;\n-                case \"F\" -> SimpleVerificationTypeInfo.ITEM_FLOAT;\n-                case \"D\" -> SimpleVerificationTypeInfo.ITEM_DOUBLE;\n-                case \"V\" -> throw new IllegalArgumentException(\"Illegal method argument type: \" + arg);\n+        for(var arg : methodType.parameterList()) {\n+            vtis[i++] = switch (arg.descriptorString().charAt(0)) {\n+                case 'I', 'S', 'C' ,'B', 'Z' -> SimpleVerificationTypeInfo.ITEM_INTEGER;\n+                case 'J' -> SimpleVerificationTypeInfo.ITEM_LONG;\n+                case 'F' -> SimpleVerificationTypeInfo.ITEM_FLOAT;\n+                case 'D' -> SimpleVerificationTypeInfo.ITEM_DOUBLE;\n+                case 'V' -> throw new IllegalArgumentException(\"Illegal method argument type: \" + arg);\n@@ -103,1 +102,1 @@\n-                mi.methodType().stringValue(),\n+                mi.methodTypeSymbol(),\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/StackMapDecoder.java","additions":12,"deletions":13,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -152,1 +152,1 @@\n-                MethodTypeDesc.ofDescriptor(dcb.methodInfo.methodType().stringValue()),\n+                dcb.methodInfo.methodTypeSymbol(),\n@@ -184,0 +184,2 @@\n+    static record RawExceptionCatch(int start, int end, int handler, Type catchType) {}\n+\n@@ -191,1 +193,2 @@\n-    private final List<AbstractPseudoInstruction.ExceptionCatchImpl> exceptionTable;\n+    private final List<AbstractPseudoInstruction.ExceptionCatchImpl> handlers;\n+    private final List<RawExceptionCatch> rawHandlers;\n@@ -229,1 +232,2 @@\n-        this.exceptionTable = handlers;\n+        this.handlers = handlers;\n+        this.rawHandlers = new ArrayList<>(handlers.size());\n@@ -252,6 +256,13 @@\n-    private int getFrameIndexFromOffset(int offset) {\n-        int i = 0;\n-        for (; i < frames.size(); i++) {\n-            if (frames.get(i).offset == offset) {\n-                return i;\n-            }\n+    private Frame getFrame(int offset) {\n+        \/\/binary search over frames ordered by offset\n+        int low = 0;\n+        int high = frames.size() - 1;\n+        while (low <= high) {\n+            int mid = (low + high) >>> 1;\n+            var f = frames.get(mid);\n+            if (f.offset < offset)\n+                low = mid + 1;\n+            else if (f.offset > offset)\n+                high = mid - 1;\n+            else\n+                return f;\n@@ -259,1 +270,1 @@\n-        return i;\n+        return null;\n@@ -263,2 +274,1 @@\n-        int index = getFrameIndexFromOffset(target);\n-        frame.checkAssignableTo(frames.get(index));\n+        frame.checkAssignableTo(getFrame(target));\n@@ -279,1 +289,1 @@\n-        for (var exhandler : exceptionTable) {\n+        for (var exhandler : handlers) {\n@@ -282,2 +292,9 @@\n-            if (start_pc < exMin) exMin = start_pc;\n-            if (end_pc > exMax) exMax = end_pc;\n+            int handler_pc = labelContext.labelToBci(exhandler.handler());\n+            if (start_pc >= 0 && end_pc >= 0 && end_pc > start_pc && handler_pc >= 0) {\n+                if (start_pc < exMin) exMin = start_pc;\n+                if (end_pc > exMax) exMax = end_pc;\n+                var catchType = exhandler.catchType();\n+                rawHandlers.add(new RawExceptionCatch(start_pc, end_pc, handler_pc,\n+                        catchType.isPresent() ? cpIndexToType(catchType.get().index(), cp)\n+                                              : Type.THROWABLE_TYPE));\n+            }\n@@ -321,1 +338,1 @@\n-        var it = exceptionTable.listIterator();\n+        var it = handlers.listIterator();\n@@ -382,4 +399,0 @@\n-    private static boolean isDoubleSlot(ClassDesc desc) {\n-        return CD_double.equals(desc) || CD_long.equals(desc);\n-    }\n-\n@@ -654,2 +667,2 @@\n-        for (var exhandler : exceptionTable) {\n-            if (bci >= labelContext.labelToBci(exhandler.tryStart()) && bci < labelContext.labelToBci(exhandler.tryEnd())) {\n+        for (var ex : rawHandlers) {\n+            if (bci == ex.start || (currentFrame.localsChanged && bci > ex.start && bci < ex.end)) {\n@@ -658,5 +671,2 @@\n-                Frame newFrame = currentFrame.frameInExceptionHandler(flags);\n-                var catchType = exhandler.catchType();\n-                newFrame.pushStack(catchType.isPresent() ? cpIndexToType(catchType.get().index(), cp) : Type.THROWABLE_TYPE);\n-                int handler = labelContext.labelToBci(exhandler.handler());\n-                if (handler != -1) checkJumpTarget(newFrame, handler);\n+                Frame newFrame = currentFrame.frameInExceptionHandler(flags, ex.catchType);\n+                checkJumpTarget(newFrame, ex.handler);\n@@ -665,0 +675,1 @@\n+        currentFrame.localsChanged = false;\n@@ -735,1 +746,1 @@\n-        var desc = ClassDesc.ofDescriptor(((MemberRefEntry)cp.entryByIndex(bcs.getIndexU2())).nameAndType().type().stringValue());\n+        var desc = Util.fieldTypeSymbol(((MemberRefEntry)cp.entryByIndex(bcs.getIndexU2())).nameAndType());\n@@ -741,1 +752,1 @@\n-                if (isDoubleSlot(desc)) currentFrame.popStack();\n+                if (Util.isDoubleSlot(desc)) currentFrame.popStack();\n@@ -750,1 +761,1 @@\n-                if (isDoubleSlot(desc)) currentFrame.popStack();\n+                if (Util.isDoubleSlot(desc)) currentFrame.popStack();\n@@ -762,28 +773,1 @@\n-\n-        var mDesc = nameAndType.type().stringValue();\n-        \/\/faster counting of method descriptor argument slots instead of full parsing\n-        int nargs = 0, pos = 0, descLen = mDesc.length();\n-        if (descLen < 3 || mDesc.charAt(0) != '(')\n-            throw new IllegalArgumentException(\"Bad method descriptor: \" + mDesc);\n-        char ch;\n-        while (++pos < descLen && (ch = mDesc.charAt(pos)) != ')') {\n-            switch (ch) {\n-                case '[' -> {\n-                    nargs++;\n-                    while (++pos < descLen && mDesc.charAt(pos) == '[');\n-                    if (mDesc.charAt(pos) == 'L')\n-                        while (++pos < descLen && mDesc.charAt(pos) != ';');\n-                }\n-                case 'D', 'J' -> nargs += 2;\n-                case 'B', 'C', 'F', 'I', 'S', 'Z' -> nargs++;\n-                case 'L' -> {\n-                    nargs++;\n-                    while (++pos < descLen && mDesc.charAt(pos) != ';');\n-                }\n-                default ->\n-                    throw new IllegalArgumentException(\"Bad method descriptor: \" + mDesc);\n-            }\n-        }\n-        if (++pos >= descLen)\n-            throw new IllegalArgumentException(\"Bad method descriptor: \" + mDesc);\n-\n+        var mDesc = Util.methodTypeSymbol(nameAndType);\n@@ -791,1 +775,1 @@\n-        currentFrame.decStack(nargs);\n+        currentFrame.decStack(Util.parameterSlots(mDesc));\n@@ -816,1 +800,1 @@\n-        currentFrame.pushStack(ClassDesc.ofDescriptor(mDesc.substring(pos)));\n+        currentFrame.pushStack(mDesc.returnType());\n@@ -947,2 +931,2 @@\n-        for (var exhandler : exceptionTable) try {\n-            offsets.set(labelContext.labelToBci(exhandler.handler()));\n+        for (var exhandler : rawHandlers) try {\n+             offsets.set(exhandler.handler());\n@@ -963,0 +947,1 @@\n+        boolean localsChanged = false;\n@@ -992,2 +977,2 @@\n-            return switch (desc.descriptorString()) {\n-                case \"J\" ->\n+            return switch (desc.descriptorString().charAt(0)) {\n+                case 'J' ->\n@@ -995,1 +980,1 @@\n-                case \"D\" ->\n+                case 'D' ->\n@@ -997,1 +982,1 @@\n-                case \"I\", \"Z\", \"B\", \"C\", \"S\" ->\n+                case 'I', 'Z', 'B', 'C', 'S' ->\n@@ -999,1 +984,1 @@\n-                case \"F\" ->\n+                case 'F' ->\n@@ -1001,1 +986,1 @@\n-                case \"V\" ->\n+                case 'V' ->\n@@ -1032,2 +1017,2 @@\n-        Frame frameInExceptionHandler(int flags) {\n-            return new Frame(offset, flags, localsSize, 0, locals, new Type[] {Type.TOP_TYPE}, classHierarchy);\n+        Frame frameInExceptionHandler(int flags, Type excType) {\n+            return new Frame(offset, flags, localsSize, 1, locals, new Type[] {excType}, classHierarchy);\n@@ -1041,0 +1026,1 @@\n+                    localsChanged = true;\n@@ -1080,0 +1066,1 @@\n+            localsChanged |= !type.equals(locals[index]);\n@@ -1098,2 +1085,2 @@\n-                } else switch (desc.descriptorString()) {\n-                    case \"J\" -> {\n+                } else switch (desc.descriptorString().charAt(0)) {\n+                    case 'J' -> {\n@@ -1103,1 +1090,1 @@\n-                    case \"D\" -> {\n+                    case 'D' -> {\n@@ -1107,1 +1094,1 @@\n-                    case \"I\", \"Z\", \"B\", \"C\", \"S\" ->\n+                    case 'I', 'Z', 'B', 'C', 'S' ->\n@@ -1109,1 +1096,1 @@\n-                    case \"F\" ->\n+                    case 'F' ->\n@@ -1126,0 +1113,1 @@\n+            localsChanged = true;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/StackMapGenerator.java","additions":63,"deletions":75,"binary":false,"changes":138,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.lang.constant.MethodTypeDesc;\n@@ -38,0 +39,1 @@\n+import jdk.internal.classfile.constantpool.NameAndTypeEntry;\n@@ -39,1 +41,0 @@\n-import jdk.internal.classfile.impl.TemporaryConstantPool;\n@@ -59,31 +60,1 @@\n-    public static BitSet findParams(String type) {\n-        BitSet bs = new BitSet();\n-        if (type.charAt(0) != '(')\n-            throw new IllegalArgumentException();\n-        loop: for (int i = 1; i < type.length(); ++i) {\n-            switch (type.charAt(i)) {\n-                case '[':\n-                    bs.set(i);\n-                    while (type.charAt(++i) == '[')\n-                        ;\n-                    if (type.charAt(i) == 'L') {\n-                        while (type.charAt(++i) != ';')\n-                            ;\n-                    }\n-                    break;\n-                case ')':\n-                    break loop;\n-                default:\n-                    bs.set(i);\n-                    if (type.charAt(i) == 'L') {\n-                        while (type.charAt(++i) != ';')\n-                            ;\n-                    }\n-            }\n-        }\n-        return bs;\n-    }\n-\n-    @SuppressWarnings(\"fallthrough\")\n-    public static int parameterSlots(String type) {\n-        BitSet bs = findParams(type);\n+    public static int parameterSlots(MethodTypeDesc mDesc) {\n@@ -91,2 +62,2 @@\n-        for (int i = bs.nextSetBit(0); i >= 0; i = bs.nextSetBit(i+1)) {\n-            count += (type.charAt(i) == 'J' || type.charAt(i) == 'D') ? 2 : 1;\n+        for (int i = 0; i < mDesc.parameterCount(); i++) {\n+            count += slotSize(mDesc.parameterType(i));\n@@ -97,4 +68,2 @@\n-    public static int[] parseParameterSlots(int flags, String type) {\n-        BitSet bs = findParams(type);\n-        int[] result = new int[bs.cardinality()];\n-        int index = 0;\n+    public static int[] parseParameterSlots(int flags, MethodTypeDesc mDesc) {\n+        int[] result = new int[mDesc.parameterCount()];\n@@ -102,3 +71,3 @@\n-        for (int i = bs.nextSetBit(0); i >= 0; i = bs.nextSetBit(i+1)) {\n-            result[index++] = count;\n-            count += (type.charAt(i) == 'J' || type.charAt(i) == 'D') ? 2 : 1;\n+        for (int i = 0; i < result.length; i++) {\n+            result[i] = count;\n+            count += slotSize(mDesc.parameterType(i));\n@@ -109,2 +78,1 @@\n-    public static int maxLocals(int flags, String type) {\n-        BitSet bs = findParams(type);\n+    public static int maxLocals(int flags, MethodTypeDesc mDesc) {\n@@ -112,2 +80,3 @@\n-        for (int i = bs.nextSetBit(0); i >= 0; i = bs.nextSetBit(i+1))\n-            count += (type.charAt(i) == 'J' || type.charAt(i) == 'D') ? 2 : 1;\n+        for (int i = 0; i < mDesc.parameterCount(); i++) {\n+            count += slotSize(mDesc.parameterType(i));\n+        }\n@@ -190,1 +159,1 @@\n-            result[i] = TemporaryConstantPool.INSTANCE.classEntry(TemporaryConstantPool.INSTANCE.utf8Entry(toInternalName(list.get(i))));\n+            result[i] = TemporaryConstantPool.INSTANCE.classEntry(list.get(i));\n@@ -234,0 +203,21 @@\n+\n+    public static ClassDesc fieldTypeSymbol(NameAndTypeEntry nat) {\n+        return ((AbstractPoolEntry.NameAndTypeEntryImpl)nat).fieldTypeSymbol();\n+    }\n+\n+    public static MethodTypeDesc methodTypeSymbol(NameAndTypeEntry nat) {\n+        return ((AbstractPoolEntry.NameAndTypeEntryImpl)nat).methodTypeSymbol();\n+    }\n+\n+    public static int slotSize(ClassDesc desc) {\n+        return switch (desc.descriptorString().charAt(0)) {\n+            case 'V' -> 0;\n+            case 'D','J' -> 2;\n+            default -> 1;\n+        };\n+    }\n+\n+    public static boolean isDoubleSlot(ClassDesc desc) {\n+        char ch = desc.descriptorString().charAt(0);\n+        return ch == 'D' || ch == 'J';\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/Util.java","additions":36,"deletions":46,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+import jdk.internal.classfile.impl.AbstractPoolEntry;\n@@ -79,1 +80,1 @@\n-        return ClassDesc.ofDescriptor(type().stringValue());\n+        return Util.fieldTypeSymbol(field().nameAndType());\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/instruction\/FieldInstruction.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+import jdk.internal.classfile.impl.AbstractPoolEntry;\n@@ -72,1 +73,1 @@\n-        return MethodTypeDesc.ofDescriptor(type().stringValue());\n+        return Util.methodTypeSymbol(invokedynamic().nameAndType());\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/instruction\/InvokeDynamicInstruction.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+import jdk.internal.classfile.impl.AbstractPoolEntry;\n@@ -92,1 +93,1 @@\n-        return MethodTypeDesc.ofDescriptor(type().stringValue());\n+        return Util.methodTypeSymbol(method().nameAndType());\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/instruction\/InvokeInstruction.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import java.lang.constant.MethodTypeDesc;\n@@ -40,10 +41,0 @@\n-    @Test\n-    void testFindParams() {\n-        assertEquals(Util.findParams(\"(IIII)V\").cardinality(), 4);\n-        assertEquals(Util.findParams(\"([I[I[I[I)V\").cardinality(), 4);\n-        assertEquals(Util.findParams(\"(IJLFoo;IJ)V\").cardinality(), 5);\n-        assertEquals(Util.findParams(\"([[[[I)V\").cardinality(), 1);\n-        assertEquals(Util.findParams(\"([[[[LFoo;)V\").cardinality(), 1);\n-        assertEquals(Util.findParams(\"([I[LFoo;)V\").cardinality(), 2);\n-        assertEquals(Util.findParams(\"()V\").cardinality(), 0);\n-    }\n@@ -53,18 +44,22 @@\n-        assertEquals(Util.parameterSlots(\"(IIII)V\"), 4);\n-        assertEquals(Util.parameterSlots(\"([I[I[I[I)V\"), 4);\n-        assertEquals(Util.parameterSlots(\"(IJLFoo;IJ)V\"), 7);\n-        assertEquals(Util.parameterSlots(\"([[[[I)V\"), 1);\n-        assertEquals(Util.parameterSlots(\"([[[[LFoo;)V\"), 1);\n-        assertEquals(Util.parameterSlots(\"([I[LFoo;)V\"), 2);\n-        assertEquals(Util.parameterSlots(\"()V\"), 0);\n-        assertEquals(Util.parameterSlots(\"(I)V\"), 1);\n-        assertEquals(Util.parameterSlots(\"(S)V\"), 1);\n-        assertEquals(Util.parameterSlots(\"(C)V\"), 1);\n-        assertEquals(Util.parameterSlots(\"(B)V\"), 1);\n-        assertEquals(Util.parameterSlots(\"(Z)V\"), 1);\n-        assertEquals(Util.parameterSlots(\"(F)V\"), 1);\n-        assertEquals(Util.parameterSlots(\"(LFoo;)V\"), 1);\n-        assertEquals(Util.parameterSlots(\"(J)V\"), 2);\n-        assertEquals(Util.parameterSlots(\"(D)V\"), 2);\n-        assertEquals(Util.parameterSlots(\"([J)V\"), 1);\n-        assertEquals(Util.parameterSlots(\"([D)V\"), 1);\n+        assertSlots(\"(IIII)V\", 4);\n+        assertSlots(\"([I[I[I[I)V\", 4);\n+        assertSlots(\"(IJLFoo;IJ)V\", 7);\n+        assertSlots(\"([[[[I)V\", 1);\n+        assertSlots(\"([[[[LFoo;)V\", 1);\n+        assertSlots(\"([I[LFoo;)V\", 2);\n+        assertSlots(\"()V\", 0);\n+        assertSlots(\"(I)V\", 1);\n+        assertSlots(\"(S)V\", 1);\n+        assertSlots(\"(C)V\", 1);\n+        assertSlots(\"(B)V\", 1);\n+        assertSlots(\"(Z)V\", 1);\n+        assertSlots(\"(F)V\", 1);\n+        assertSlots(\"(LFoo;)V\", 1);\n+        assertSlots(\"(J)V\", 2);\n+        assertSlots(\"(D)V\", 2);\n+        assertSlots(\"([J)V\", 1);\n+        assertSlots(\"([D)V\", 1);\n+    }\n+\n+    private void assertSlots(String methodDesc, int slots) {\n+        assertEquals(Util.parameterSlots(MethodTypeDesc.ofDescriptor(methodDesc)), slots);\n","filename":"test\/jdk\/jdk\/classfile\/UtilTest.java","additions":23,"deletions":28,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -48,1 +48,11 @@\n-@Fork(1)\n+@Fork(value = 1, jvmArgsAppend = {\n+        \"--enable-preview\",\n+        \"--add-exports\", \"java.base\/jdk.internal.org.objectweb.asm=ALL-UNNAMED\",\n+        \"--add-exports\", \"java.base\/jdk.internal.org.objectweb.asm.tree=ALL-UNNAMED\",\n+        \"--add-exports\", \"java.base\/jdk.internal.classfile=ALL-UNNAMED\",\n+        \"--add-exports\", \"java.base\/jdk.internal.classfile.attribute=ALL-UNNAMED\",\n+        \"--add-exports\", \"java.base\/jdk.internal.classfile.constantpool=ALL-UNNAMED\",\n+        \"--add-exports\", \"java.base\/jdk.internal.classfile.instruction=ALL-UNNAMED\",\n+        \"--add-exports\", \"java.base\/jdk.internal.classfile.java.lang.constant=ALL-UNNAMED\",\n+        \"--add-exports\", \"java.base\/jdk.internal.classfile.components=ALL-UNNAMED\",\n+        \"--add-exports\", \"java.base\/jdk.internal.classfile.impl=ALL-UNNAMED\"})\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/classfile\/AbstractCorpusBenchmark.java","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -58,1 +58,9 @@\n-@Fork(1)\n+@Fork(value = 1, jvmArgsAppend = {\n+        \"--enable-preview\",\n+        \"--add-exports\", \"java.base\/jdk.internal.classfile=ALL-UNNAMED\",\n+        \"--add-exports\", \"java.base\/jdk.internal.classfile.attribute=ALL-UNNAMED\",\n+        \"--add-exports\", \"java.base\/jdk.internal.classfile.constantpool=ALL-UNNAMED\",\n+        \"--add-exports\", \"java.base\/jdk.internal.classfile.instruction=ALL-UNNAMED\",\n+        \"--add-exports\", \"java.base\/jdk.internal.classfile.java.lang.constant=ALL-UNNAMED\",\n+        \"--add-exports\", \"java.base\/jdk.internal.classfile.components=ALL-UNNAMED\",\n+        \"--add-exports\", \"java.base\/jdk.internal.classfile.impl=ALL-UNNAMED\"})\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/classfile\/GenerateStackMaps.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,115 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.jdk.classfile;\n+\n+import java.io.IOException;\n+import java.net.URI;\n+import java.nio.file.FileSystems;\n+import java.nio.file.Files;\n+import java.util.Iterator;\n+import java.util.ArrayList;\n+import java.util.List;\n+import jdk.internal.classfile.ClassModel;\n+import jdk.internal.classfile.Classfile;\n+import jdk.internal.classfile.ClassTransform;\n+import jdk.internal.classfile.instruction.*;\n+import org.openjdk.jmh.annotations.*;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@State(Scope.Benchmark)\n+@Fork(value = 1, jvmArgsAppend = {\n+        \"--enable-preview\",\n+        \"--add-exports\", \"java.base\/jdk.internal.classfile=ALL-UNNAMED\",\n+        \"--add-exports\", \"java.base\/jdk.internal.classfile.constantpool=ALL-UNNAMED\",\n+        \"--add-exports\", \"java.base\/jdk.internal.classfile.instruction=ALL-UNNAMED\"})\n+@Warmup(iterations = 2)\n+@Measurement(iterations = 4)\n+public class RebuildMethodBodies {\n+\n+    List<ClassModel> shared, unshared;\n+    Iterator<ClassModel> it1, it2;\n+\n+    @Setup(Level.Trial)\n+    public void setup() throws IOException {\n+        shared = new ArrayList<>();\n+        unshared = new ArrayList<>();\n+        Files.walk(FileSystems.getFileSystem(URI.create(\"jrt:\/\")).getPath(\"modules\/java.base\/java\")).forEach(p -> {\n+            if (Files.isRegularFile(p) && p.toString().endsWith(\".class\")) try {\n+                var clm = Classfile.parse(p,\n+                        Classfile.Option.constantPoolSharing(true),\n+                        Classfile.Option.processDebug(false),\n+                        Classfile.Option.processLineNumbers(false));\n+                shared.add(clm);\n+                transform(clm); \/\/dry run to expand model and symbols\n+                clm = Classfile.parse(p,\n+                        Classfile.Option.constantPoolSharing(false),\n+                        Classfile.Option.processDebug(false),\n+                        Classfile.Option.processLineNumbers(false));\n+                unshared.add(clm);\n+                transform(clm); \/\/dry run to expand model and symbols\n+            } catch (IOException e) {\n+                throw new RuntimeException(e);\n+            }\n+        });\n+    }\n+\n+    @Benchmark\n+    public void shared() {\n+        if (it1 == null || !it1.hasNext())\n+            it1 = shared.iterator();\n+        \/\/model and symbols were already expanded, so benchmark is focused more on builder performance\n+        transform(it1.next());\n+    }\n+\n+    @Benchmark\n+    public void unshared() {\n+        if (it2 == null || !it2.hasNext())\n+            it2 = unshared.iterator();\n+        \/\/model and symbols were already expanded, so benchmark is focused more on builder performance\n+        transform(it2.next());\n+    }\n+\n+    private static void transform(ClassModel clm) {\n+        clm.transform(ClassTransform.transformingMethodBodies((cob, coe) -> {\n+            switch (coe) {\n+                case FieldInstruction i ->\n+                    cob.fieldInstruction(i.opcode(), i.owner().asSymbol(), i.name().stringValue(), i.typeSymbol());\n+                case InvokeDynamicInstruction i ->\n+                    cob.invokedynamic(i.invokedynamic().asSymbol());\n+                case InvokeInstruction i ->\n+                    cob.invokeInstruction(i.opcode(), i.owner().asSymbol(), i.name().stringValue(), i.typeSymbol(), i.isInterface());\n+                case NewMultiArrayInstruction i ->\n+                    cob.multianewarray(i.arrayType().asSymbol(), i.dimensions());\n+                case NewObjectInstruction i ->\n+                    cob.new_(i.className().asSymbol());\n+                case NewReferenceArrayInstruction i ->\n+                    cob.anewarray(i.componentType().asSymbol());\n+                case TypeCheckInstruction i ->\n+                    cob.typeCheckInstruction(i.opcode(), i.type().asSymbol());\n+                default -> cob.with(coe);\n+            }\n+        }));\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/classfile\/RebuildMethodBodies.java","additions":115,"deletions":0,"binary":false,"changes":115,"status":"added"},{"patch":"@@ -0,0 +1,71 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.jdk.classfile;\n+\n+import java.io.IOException;\n+import java.net.URI;\n+import java.nio.file.FileSystems;\n+import java.nio.file.Files;\n+import java.util.Iterator;\n+import java.util.LinkedList;\n+import java.util.List;\n+import jdk.internal.classfile.ClassModel;\n+import jdk.internal.classfile.Classfile;\n+import jdk.internal.classfile.components.ClassPrinter;\n+import org.openjdk.jmh.annotations.*;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@State(Scope.Benchmark)\n+@Fork(value = 1, jvmArgsAppend = {\n+        \"--enable-preview\",\n+        \"--add-exports\", \"java.base\/jdk.internal.classfile=ALL-UNNAMED\",\n+        \"--add-exports\", \"java.base\/jdk.internal.classfile.components=ALL-UNNAMED\"})\n+@Warmup(iterations = 3)\n+@Measurement(iterations = 4)\n+public class RepeatedModelTraversal {\n+\n+    List<ClassModel> models;\n+    Iterator<ClassModel> it;\n+\n+    @Setup(Level.Trial)\n+    public void setup() throws IOException {\n+        models = new LinkedList<>();\n+        Files.walk(FileSystems.getFileSystem(URI.create(\"jrt:\/\")).getPath(\"modules\/java.base\/java\/util\")).forEach(p -> {\n+            if (Files.isRegularFile(p) && p.toString().endsWith(\".class\")) try {\n+                var clm = Classfile.parse(p);\n+                models.add(clm);\n+            } catch (IOException e) {\n+                throw new RuntimeException(e);\n+            }\n+        });\n+    }\n+\n+    @Benchmark\n+    public void traverseModel() {\n+        if (it == null || !it.hasNext())\n+            it = models.iterator();\n+        ClassPrinter.toTree(it.next(), ClassPrinter.Verbosity.TRACE_ALL);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/classfile\/RepeatedModelTraversal.java","additions":71,"deletions":0,"binary":false,"changes":71,"status":"added"},{"patch":"@@ -68,1 +68,11 @@\n-@Fork(1)\n+@Fork(value = 1, jvmArgsAppend = {\n+        \"--enable-preview\",\n+        \"--add-exports\", \"java.base\/jdk.internal.org.objectweb.asm=ALL-UNNAMED\",\n+        \"--add-exports\", \"java.base\/jdk.internal.org.objectweb.asm.tree=ALL-UNNAMED\",\n+        \"--add-exports\", \"java.base\/jdk.internal.classfile=ALL-UNNAMED\",\n+        \"--add-exports\", \"java.base\/jdk.internal.classfile.attribute=ALL-UNNAMED\",\n+        \"--add-exports\", \"java.base\/jdk.internal.classfile.constantpool=ALL-UNNAMED\",\n+        \"--add-exports\", \"java.base\/jdk.internal.classfile.instruction=ALL-UNNAMED\",\n+        \"--add-exports\", \"java.base\/jdk.internal.classfile.java.lang.constant=ALL-UNNAMED\",\n+        \"--add-exports\", \"java.base\/jdk.internal.classfile.components=ALL-UNNAMED\",\n+        \"--add-exports\", \"java.base\/jdk.internal.classfile.impl=ALL-UNNAMED\"})\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/classfile\/Write.java","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"}]}