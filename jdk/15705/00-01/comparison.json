{"files":[{"patch":"@@ -197,1 +197,1 @@\n-    (_mask_size == 0 || _mask_size == INT_MAX) &&\n+    (_mask_size == 0 || _mask_size == USHRT_MAX) &&\n@@ -204,1 +204,1 @@\n-  _mask_size = INT_MAX;  \/\/ This value should cause a failure quickly\n+  _mask_size = USHRT_MAX;  \/\/ This value should cause a failure quickly\n","filename":"src\/hotspot\/share\/interpreter\/oopMapCache.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -87,1 +87,1 @@\n-  int            _mask_size;      \/\/ the mask size in bits (INT_MAX if invalid)\n+  int            _mask_size;      \/\/ the mask size in bits (USHRT_MAX if invalid)\n@@ -150,1 +150,1 @@\n-  bool has_valid_mask() const { return _mask_size != INT_MAX; }\n+  bool has_valid_mask() const { return _mask_size != USHRT_MAX; }\n","filename":"src\/hotspot\/share\/interpreter\/oopMapCache.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3079,2 +3079,2 @@\n-C2V_VMENTRY_0(jlong, getLiveObjectLocalsAt, (JNIEnv* env, jobject, ARGUMENT_PAIR(method),\n-                 jint bci, jlong buffer))\n+C2V_VMENTRY(void, getOopMapAt, (JNIEnv* env, jobject, ARGUMENT_PAIR(method),\n+                 jint bci, jlongArray oop_map_handle))\n@@ -3083,1 +3083,1 @@\n-    JVMCI_THROW_MSG_0(IllegalArgumentException,\n+    JVMCI_THROW_MSG(IllegalArgumentException,\n@@ -3089,8 +3089,25 @@\n-    JVMCI_THROW_MSG_0(IllegalArgumentException, err_msg(\"bci %d is not valid\", bci));\n-  }\n-  int nlocals = method->max_locals();\n-  jlong liveness = 0L;\n-  \/\/ stringStream st;\n-  \/\/ st.print(\"BitMap[%s@%d, nlocals:%d]:\", method->name_and_sig_as_C_string(), bci, nlocals);\n-  BitMapView bm = BitMapView((BitMap::bm_word_t*) (nlocals <= 64 ? (jlong) &liveness : buffer), nlocals);\n-  for (int i = 0; i < nlocals ; i++ ) {\n+    JVMCI_THROW_MSG(IllegalArgumentException, err_msg(\"bci %d is not valid\", bci));\n+  }\n+  if (mask.number_of_entries() == 0) {\n+    return;\n+  }\n+\n+  int nslots = method->max_locals() + method->max_stack();\n+  int nwords = ((nslots - 1) \/ 64) + 1;\n+  JVMCIPrimitiveArray oop_map = JVMCIENV->wrap(oop_map_handle);\n+  int oop_map_len = JVMCIENV->get_length(oop_map);\n+  if (nwords > oop_map_len) {\n+    JVMCI_THROW_MSG(IllegalArgumentException,\n+                err_msg(\"oop map too short: %d > %d\", nwords, oop_map_len));\n+  }\n+\n+  jlong* oop_map_buf = NEW_RESOURCE_ARRAY_IN_THREAD_RETURN_NULL(THREAD, jlong, nwords);\n+  if (oop_map_buf == nullptr) {\n+    JVMCI_THROW_MSG(InternalError, err_msg(\"could not allocate %d longs\", nwords));\n+  }\n+  for (int i = 0; i < nwords; i++) {\n+    oop_map_buf[i] = 0L;\n+  }\n+\n+  BitMapView oop_map_view = BitMapView((BitMap::bm_word_t*) oop_map_buf, nwords * BitsPerLong);\n+  for (int i = 0; i < nslots; i++) {\n@@ -3098,2 +3115,1 @@\n-      bm.set_bit(i);\n-      \/\/ st.print(\" %d\", i);\n+      oop_map_view.set_bit(i);\n@@ -3102,4 +3118,1 @@\n-  \/\/ st.print(\" [liveness: 0x\" JULONG_FORMAT_X \"]\", (julong) liveness);\n-  \/\/ tty->print_raw_cr(st.as_string());\n-  \/\/ tty->flush();\n-  return liveness;\n+  JVMCIENV->copy_longs_from((jlong*)oop_map_buf, oop_map, 0, nwords);\n@@ -3265,1 +3278,1 @@\n-  {CC \"getLiveObjectLocalsAt\",                        CC \"(\" HS_METHOD2 \"IJ)J\",                                                             FN_PTR(getLiveObjectLocalsAt)},\n+  {CC \"getOopMapAt\",                                  CC \"(\" HS_METHOD2 \"I[J)V\",                                                            FN_PTR(getOopMapAt)},\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":31,"deletions":18,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -1477,3 +1477,5 @@\n-\n-    long getLiveObjectLocalsAt(HotSpotResolvedJavaMethodImpl method, int bci, long buffer) {\n-        return getLiveObjectLocalsAt(method, method.getMethodPointer(), bci, buffer);\n+    \/**\n+     * @see HotSpotResolvedJavaMethod#getOopMapAt\n+     *\/\n+    void getOopMapAt(HotSpotResolvedJavaMethodImpl method, int bci, long[] oopMap) {\n+        getOopMapAt(method, method.getMethodPointer(), bci, oopMap);\n@@ -1482,1 +1484,1 @@\n-    native long getLiveObjectLocalsAt(HotSpotResolvedJavaMethodImpl method, long methodPointer, int bci, long buffer);\n+    native void getOopMapAt(HotSpotResolvedJavaMethodImpl method, long methodPointer, int bci, long[] oopMap);\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/CompilerToVM.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+import java.util.BitSet;\n@@ -130,0 +131,14 @@\n+\n+\n+    \/**\n+     * Computes which local variables and operand stack slots in {@code method} contain\n+     * live object values at the instruction denoted by {@code bci}. This is the \"oop map\"\n+     * used by the garbage collector for interpreter frames.\n+     *\n+     * @param bci the index of an instruction in this method's bytecodes\n+     * @return the computed oop map. The first {@link #getMaxLocals} bits are for\n+     *         the local variables, the remaining bits are for the stack slots.\n+     * @throws IllegalArgumentException if this method has no bytecode or\n+     *         {@code bci} is not the index of a bytecode instruction\n+     *\/\n+    BitSet getOopMapAt(int bci);\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotResolvedJavaMethod.java","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -37,1 +37,0 @@\n-import java.lang.reflect.Parameter;\n@@ -44,1 +43,0 @@\n-import jdk.internal.misc.Unsafe;\n@@ -774,13 +772,0 @@\n-    \/*\n-     * BitSets are packed into arrays of \"words.\"  Currently a word is\n-     * a long, which consists of 64 bits, requiring 6 address bits.\n-     * The choice of word size is determined purely by performance concerns.\n-     *\/\n-    private static final int ADDRESS_BITS_PER_WORD = 6;\n-    private static final int BITS_PER_WORD = 1 << ADDRESS_BITS_PER_WORD;\n-    private static final int BIT_INDEX_MASK = BITS_PER_WORD - 1;\n-\n-    private static int wordIndex(int bitIndex) {\n-        return bitIndex >> ADDRESS_BITS_PER_WORD;\n-    }\n-\n@@ -788,22 +773,3 @@\n-    public long getLiveObjectLocalsAt(int bci, BitSet bigOopMap) {\n-        int locals = getMaxLocals();\n-        if (locals == 0) {\n-            throw new IllegalArgumentException(\"cannot compute oop map for method with no local variables\");\n-        }\n-        if (locals > 64) {\n-            int nwords = ((locals - 1) \/ 64) + 1;\n-            Unsafe unsafe = UnsafeAccess.UNSAFE;\n-            long buffer = unsafe.allocateMemory(nwords);\n-            try {\n-                compilerToVM().getLiveObjectLocalsAt(this, bci, buffer);\n-                long liveness[] = new long[nwords];\n-                for (int i = 0; i < nwords; i++) {\n-                    liveness[i] = unsafe.getLong(buffer + i);\n-                }\n-                bigOopMap.or(BitSet.valueOf(liveness));\n-            } finally {\n-                unsafe.freeMemory(buffer);\n-            }\n-            return 0;\n-        } else {\n-            return compilerToVM().getLiveObjectLocalsAt(this, bci, 0);\n+    public BitSet getOopMapAt(int bci) {\n+        if (getCodeSize() == 0) {\n+            throw new IllegalArgumentException(\"has no bytecode\");\n@@ -811,0 +777,4 @@\n+        int nwords = ((getMaxLocals() + getMaxStackSize() - 1) \/ 64) + 1;\n+        long[] oopMap = new long[nwords];\n+        compilerToVM().getOopMapAt(this, bci, oopMap);\n+        return BitSet.valueOf(oopMap);\n@@ -812,1 +782,0 @@\n-\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotResolvedJavaMethodImpl.java","additions":7,"deletions":38,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -473,24 +473,0 @@\n-\n-    \/**\n-     * Computes which local variables contain live object values\n-     * at the instruction denoted by {@code bci}. This is the \"oop map\" used\n-     * by the garbage collector.\n-     *\n-     * If {@link #getMaxLocals()} {@code <= 64}, then the oop map is encoded\n-     * in the return value. Otherwise, it is copied into {@code bigOopMap}.\n-     *\n-     * @param bci the index of an instruction in this method's bytecodes\n-     * @param bigOopMap the bit set in which the oop map is returned for\n-     *         methods whose max number of local variables is {@code > 64}. It's up\n-     *         to the caller to ensure this bit set is large enough and initially has\n-     *         all bits set to 0.\n-     * @return the oop map for methods with 64 or less max locals otherwise 0\n-     * @throws NullPointerException if {@link #getMaxLocals()} {@code > 64 && bigOopMap == null}\n-     * @throws IllegalArgumentException if {@link #getMaxLocals()} {@code == 0} or if\n-     *         {@code bci} is not the index of a bytecode instruction\n-     * @throws UnsupportedOperationException if local variable liveness is not provided\n-     *         by the current JVMCI runtime\n-     *\/\n-    default long getLiveObjectLocalsAt(int bci, BitSet bigOopMap) {\n-        throw new UnsupportedOperationException();\n-    }\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/meta\/ResolvedJavaMethod.java","additions":0,"deletions":24,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+ *          jdk.internal.vm.ci\/jdk.vm.ci.hotspot\n@@ -106,0 +107,1 @@\n+import jdk.vm.ci.hotspot.HotSpotResolvedJavaMethod;\n@@ -610,79 +612,29 @@\n-        Object o1, int i1,\n-        Object o2, int i2,\n-        Object o3, int i3,\n-        Object o4, int i4,\n-        Object o5, int i5,\n-        Object o6, int i6,\n-        Object o7, int i7,\n-        Object o8, int i8,\n-        Object o9, int i9,\n-        Object o10, int i10,\n-        Object o11, int i11,\n-        Object o12, int i12,\n-        Object o13, int i13,\n-        Object o14, int i14,\n-        Object o15, int i15,\n-        Object o16, int i16,\n-        Object o17, int i17,\n-        Object o18, int i18,\n-        Object o19, int i19,\n-        Object o20, int i20,\n-        Object o21, int i21,\n-        Object o22, int i22,\n-        Object o23, int i23,\n-        Object o24, int i24,\n-        Object o25, int i25,\n-        Object o26, int i26,\n-        Object o27, int i27,\n-        Object o28, int i28,\n-        Object o29, int i29,\n-        Object o30, int i30,\n-        Object o31, int i31,\n-        Object o32, int i32,\n-        Object o33, int i33,\n-        Object o34, int i34,\n-        Object o35, int i35,\n-        Object o36, int i36,\n-        Object o37, int i37,\n-        Object o38, int i38,\n-        Object o39, int i39,\n-        Object o40, int i40,\n-        Object o41, int i41,\n-        Object o42, int i42,\n-        Object o43, int i43,\n-        Object o44, int i44,\n-        Object o45, int i45,\n-        Object o46, int i46,\n-        Object o47, int i47,\n-        Object o48, int i48,\n-        Object o49, int i49,\n-        Object o50, int i50,\n-        Object o51, int i51,\n-        Object o52, int i52,\n-        Object o53, int i53,\n-        Object o54, int i54,\n-        Object o55, int i55,\n-        Object o56, int i56,\n-        Object o57, int i57,\n-        Object o58, int i58,\n-        Object o59, int i59) {\n-            System.out.println(\"\" + o1 + i1);\n-            System.out.println(\"\" + o2 + i2);\n-            System.out.println(\"\" + o3 + i3);\n-            System.out.println(\"\" + o4 + i4);\n-            System.out.println(\"\" + o5 + i5);\n-            System.out.println(\"\" + o6 + i6);\n-            System.out.println(\"\" + o7 + i7);\n-            System.out.println(\"\" + o8 + i8);\n-            System.out.println(\"\" + o9 + i9);\n-            System.out.println(\"\" + o10 + i10);\n-            System.out.println(\"\" + o11 + i11);\n-            System.out.println(\"\" + o12 + i12);\n-            System.out.println(\"\" + o13 + i13);\n-            System.out.println(\"\" + o14 + i14);\n-            System.out.println(\"\" + o15 + i15);\n-            System.out.println(\"\" + o16 + i16);\n-            System.out.println(\"\" + o17 + i17);\n-            System.out.println(\"\" + o58 + i58);\n-            System.out.println(\"\" + o59 + i59);\n-        }\n+        Object   o0, int   i1, int  i2,  int   i3, int   i4, int   i5, int   i6, int  i7,\n+           int   i8, int   i9, int  i10, int  i11, int  i12, int  i13, int  i14, int  i15,\n+           int  i16, int  i17, int  i18, int  i19, int  i20, int  i21, int  i22, int  i23,\n+           int  i24, int  i25, int  i26, int  i27, int  i28, int  i29, int  i30, int  i31,\n+           int  i32, int  i33, int  i34, int  i35, int  i36, int  i37, int  i38, int  i39,\n+           int  i40, int  i41, int  i42, int  i43, int  i44, int  i45, int  i46, int  i47,\n+           int  i48, int  i49, int  i50, int  i51, int  i52, int  i53, int  i54, int  i55,\n+           int  i56, int  i57, int  i58, int  i59, int  i60, int  i61, int  i62, int  i63,\n+        Object  o64, int  i65, int  i66, int  i67, int  i68, int  i69, int  i70, int  i71,\n+           int  i72, int  i73, int  i74, int  i75, int  i76, int  i77, int  i78, int  i79,\n+           int  i80, int  i81, int  i82, int  i83, int  i84, int  i85, int  i86, int  i87,\n+           int  i88, int  i89, int  i90, int  i91, int  i92, int  i93, int  i94, int  i95,\n+           int  i96, int  i97, int  i98, int  i99, int i100, int i101, int i102, int i103,\n+           int i104, int i105, int i106, int i107, int i108, int i109, int i110, int i111,\n+           int i112, int i113, int i114, int i115, int i116, int i117, int i118, int i119,\n+           int i120, int i121, int i122, int i123, int i124, int i125, int i126, int i127,\n+        Object o128)\n+    {\n+        o0.hashCode();\n+        o64.hashCode();\n+        if (o128 != null) {\n+            Object t1 = \"tmp val\";\n+            t1.hashCode();\n+        } else {\n+            int t1 = 42 + i1;\n+            String.valueOf(t1);\n+        }\n+        o128.hashCode();\n+    }\n@@ -713,1 +665,1 @@\n-    public void getLiveObjectLocalsAtTest() throws Exception {\n+    public void getOopMapAtTest() throws Exception {\n@@ -719,0 +671,2 @@\n+        boolean[] processedMethodWithManyArgs = {false};\n+\n@@ -729,11 +683,4 @@\n-                    ResolvedJavaMethod m = Objects.requireNonNull(methodMap.get(key));\n-                    int maxLocals = m.getMaxLocals();\n-\n-                    \/\/ Requesting an oop map for a method with 0 locals must throw an exception\n-                    if (maxLocals == 0) {\n-                        try {\n-                            m.getLiveObjectLocalsAt(0, null);\n-                            throw new AssertionError(\"expected exception for method %s with no locals\".formatted(m.format(\"%H.%n(%p)\")));\n-                        } catch(IllegalArgumentException e) {\n-                            return;\n-                        }\n+                    HotSpotResolvedJavaMethod m = (HotSpotResolvedJavaMethod) Objects.requireNonNull(methodMap.get(key));\n+                    boolean isMethodWithManyArgs = c == getClass() && m.getName().equals(\"methodWithManyArgs\");\n+                    if (isMethodWithManyArgs) {\n+                        processedMethodWithManyArgs[0] = true;\n@@ -741,0 +688,1 @@\n+                    int maxSlots = m.getMaxLocals() + m.getMaxStackSize();\n@@ -743,0 +691,4 @@\n+                    Map<String, int[]> expectOopMaps = !isMethodWithManyArgs ? null : Map.of(\n+                        \"{0, 64, 128}\",      new int[] {0},\n+                        \"{0, 64, 128, 130}\", new int[] {0},\n+                        \"{0, 64, 128, 129}\", new int[] {0});\n@@ -745,5 +697,13 @@\n-                            BitSet bigOopMap = maxLocals <= 64 ? null : new BitSet(maxLocals);\n-                            long oopMap = m.getLiveObjectLocalsAt(bci, bigOopMap);\n-                            if (maxLocals > 64) {\n-                                Assert.assertEquals(m.toString(), oopMap, 0L);\n-                                Assert.assertNotEquals(m.toString(), bigOopMap.cardinality(), 0);\n+                            BitSet oopMap = m.getOopMapAt(bci);\n+                            if (isMethodWithManyArgs) {\n+                                System.out.printf(\"methodWithManyArgs@%d [%d]: %s%n\", bci, maxSlots, oopMap);\n+                                System.out.printf(\"methodWithManyArgs@%d [%d]: %s%n\", bci, maxSlots, ins);\n+\n+                                \/\/ Assumes stability of javac output\n+                                String where = \"methodWithManyArgs@\" + bci;\n+                                String oopMapString = String.valueOf(oopMap);\n+                                int[] count = expectOopMaps.get(oopMapString);\n+                                if (count == null) {\n+                                    throw new AssertionError(where + \": unexpected oop map: \" + oopMapString);\n+                                }\n+                                count[0]++;\n@@ -755,2 +715,2 @@\n-                                    m.getLiveObjectLocalsAt(bci + 1, bigOopMap);\n-                                    throw new AssertionError(\"expected exception for illegal bci %d in %s\".formatted(bci + 1, m.format(\"%H.%n(%p)\")));\n+                                    oopMap = m.getOopMapAt(bci + 1);\n+                                    throw new AssertionError(\"expected exception for illegal bci %d in %s: %s\".formatted(bci + 1, m.format(\"%H.%n(%p)\"), oopMap));\n@@ -764,0 +724,8 @@\n+                    if (isMethodWithManyArgs) {\n+                        for (var e : expectOopMaps.entrySet()) {\n+                            if (e.getValue()[0] == 0) {\n+                                throw new AssertionError(m.format(\"%H.%n(%p)\") + \"did not find expected oop map: \" + e.getKey());\n+                            }\n+                            System.out.printf(\"methodWithManyArgs: %s = %d%n\", e.getKey(), e.getValue()[0]);\n+                        }\n+                    }\n@@ -767,0 +735,2 @@\n+\n+        Assert.assertTrue(processedMethodWithManyArgs[0]);\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/jdk.vm.ci.runtime.test\/src\/jdk\/vm\/ci\/runtime\/test\/TestResolvedJavaMethod.java","additions":68,"deletions":98,"binary":false,"changes":166,"status":"modified"}]}