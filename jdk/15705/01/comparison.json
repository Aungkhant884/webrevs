{"files":[{"patch":"@@ -615,1 +615,3 @@\n-  entry->resource_copy(tmp);\n+  if (tmp->has_valid_mask()) {\n+    entry->resource_copy(tmp);\n+  }\n","filename":"src\/hotspot\/share\/interpreter\/oopMapCache.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -87,1 +87,1 @@\n-  int            _mask_size;      \/\/ the mask size in bits\n+  int            _mask_size;      \/\/ the mask size in bits (USHRT_MAX if invalid)\n@@ -149,0 +149,2 @@\n+  \/\/ Determines if a valid mask has been computed\n+  bool has_valid_mask() const { return _mask_size != USHRT_MAX; }\n","filename":"src\/hotspot\/share\/interpreter\/oopMapCache.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+#include \"interpreter\/oopMapCache.hpp\"\n@@ -2515,1 +2516,1 @@\n-}\n+C2V_END\n@@ -2780,1 +2781,1 @@\n-}\n+C2V_END\n@@ -2793,1 +2794,1 @@\n-}\n+C2V_END\n@@ -2799,1 +2800,1 @@\n-}\n+C2V_END\n@@ -2815,1 +2816,1 @@\n-}\n+C2V_END\n@@ -2831,1 +2832,1 @@\n-}\n+C2V_END\n@@ -2853,1 +2854,1 @@\n-}\n+C2V_END\n@@ -2967,1 +2968,1 @@\n-}\n+C2V_END\n@@ -2978,1 +2979,1 @@\n-}\n+C2V_END\n@@ -2982,1 +2983,1 @@\n-}\n+C2V_END\n@@ -2990,1 +2991,1 @@\n-}\n+C2V_END\n@@ -3002,1 +3003,1 @@\n-}\n+C2V_END\n@@ -3006,1 +3007,1 @@\n-}\n+C2V_END\n@@ -3016,1 +3017,1 @@\n-}\n+C2V_END\n@@ -3023,1 +3024,1 @@\n-}\n+C2V_END\n@@ -3033,1 +3034,1 @@\n-}\n+C2V_END\n@@ -3043,1 +3044,1 @@\n-}\n+C2V_END\n@@ -3052,1 +3053,1 @@\n-}\n+C2V_END\n@@ -3064,1 +3065,1 @@\n-}\n+C2V_END\n@@ -3076,1 +3077,43 @@\n-}\n+C2V_END\n+\n+C2V_VMENTRY(void, getOopMapAt, (JNIEnv* env, jobject, ARGUMENT_PAIR(method),\n+                 jint bci, jlongArray oop_map_handle))\n+  methodHandle method(THREAD, UNPACK_PAIR(Method, method));\n+  if (bci < 0 || bci >= method->code_size()) {\n+    JVMCI_THROW_MSG(IllegalArgumentException,\n+                err_msg(\"bci %d is out of bounds [0 .. %d)\", bci, method->code_size()));\n+  }\n+  InterpreterOopMap mask;\n+  OopMapCache::compute_one_oop_map(method, bci, &mask);\n+  if (!mask.has_valid_mask()) {\n+    JVMCI_THROW_MSG(IllegalArgumentException, err_msg(\"bci %d is not valid\", bci));\n+  }\n+  if (mask.number_of_entries() == 0) {\n+    return;\n+  }\n+\n+  int nslots = method->max_locals() + method->max_stack();\n+  int nwords = ((nslots - 1) \/ 64) + 1;\n+  JVMCIPrimitiveArray oop_map = JVMCIENV->wrap(oop_map_handle);\n+  int oop_map_len = JVMCIENV->get_length(oop_map);\n+  if (nwords > oop_map_len) {\n+    JVMCI_THROW_MSG(IllegalArgumentException,\n+                err_msg(\"oop map too short: %d > %d\", nwords, oop_map_len));\n+  }\n+\n+  jlong* oop_map_buf = NEW_RESOURCE_ARRAY_IN_THREAD_RETURN_NULL(THREAD, jlong, nwords);\n+  if (oop_map_buf == nullptr) {\n+    JVMCI_THROW_MSG(InternalError, err_msg(\"could not allocate %d longs\", nwords));\n+  }\n+  for (int i = 0; i < nwords; i++) {\n+    oop_map_buf[i] = 0L;\n+  }\n+\n+  BitMapView oop_map_view = BitMapView((BitMap::bm_word_t*) oop_map_buf, nwords * BitsPerLong);\n+  for (int i = 0; i < nslots; i++) {\n+    if (mask.is_oop(i)) {\n+      oop_map_view.set_bit(i);\n+    }\n+  }\n+  JVMCIENV->copy_longs_from((jlong*)oop_map_buf, oop_map, 0, nwords);\n+C2V_END\n@@ -3235,0 +3278,1 @@\n+  {CC \"getOopMapAt\",                                  CC \"(\" HS_METHOD2 \"I[J)V\",                                                            FN_PTR(getOopMapAt)},\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":64,"deletions":20,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -1476,0 +1476,9 @@\n+\n+    \/**\n+     * @see HotSpotResolvedJavaMethod#getOopMapAt\n+     *\/\n+    void getOopMapAt(HotSpotResolvedJavaMethodImpl method, int bci, long[] oopMap) {\n+        getOopMapAt(method, method.getMethodPointer(), bci, oopMap);\n+    }\n+\n+    native void getOopMapAt(HotSpotResolvedJavaMethodImpl method, long methodPointer, int bci, long[] oopMap);\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/CompilerToVM.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+import java.util.BitSet;\n@@ -130,0 +131,14 @@\n+\n+\n+    \/**\n+     * Computes which local variables and operand stack slots in {@code method} contain\n+     * live object values at the instruction denoted by {@code bci}. This is the \"oop map\"\n+     * used by the garbage collector for interpreter frames.\n+     *\n+     * @param bci the index of an instruction in this method's bytecodes\n+     * @return the computed oop map. The first {@link #getMaxLocals} bits are for\n+     *         the local variables, the remaining bits are for the stack slots.\n+     * @throws IllegalArgumentException if this method has no bytecode or\n+     *         {@code bci} is not the index of a bytecode instruction\n+     *\/\n+    BitSet getOopMapAt(int bci);\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotResolvedJavaMethod.java","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+import java.util.BitSet;\n@@ -770,0 +771,11 @@\n+\n+    @Override\n+    public BitSet getOopMapAt(int bci) {\n+        if (getCodeSize() == 0) {\n+            throw new IllegalArgumentException(\"has no bytecode\");\n+        }\n+        int nwords = ((getMaxLocals() + getMaxStackSize() - 1) \/ 64) + 1;\n+        long[] oopMap = new long[nwords];\n+        compilerToVM().getOopMapAt(this, bci, oopMap);\n+        return BitSet.valueOf(oopMap);\n+    }\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotResolvedJavaMethodImpl.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import java.util.BitSet;\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/meta\/ResolvedJavaMethod.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -38,0 +38,4 @@\n+ *          jdk.internal.vm.ci\/jdk.vm.ci.hotspot\n+ *          java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.classfile.attribute\n+ *          java.base\/jdk.internal.classfile.constantpool\n@@ -53,0 +57,1 @@\n+import java.io.DataInputStream;\n@@ -64,0 +69,6 @@\n+import java.net.URI;\n+import java.nio.file.FileSystem;\n+import java.nio.file.FileSystems;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n@@ -66,0 +77,2 @@\n+import java.util.BitSet;\n+import java.util.Collection;\n@@ -70,0 +83,1 @@\n+import java.util.Objects;\n@@ -76,0 +90,8 @@\n+import jdk.internal.classfile.Attributes;\n+import jdk.internal.classfile.Classfile;\n+import jdk.internal.classfile.ClassModel;\n+import jdk.internal.classfile.CodeElement;\n+import jdk.internal.classfile.MethodModel;\n+import jdk.internal.classfile.Instruction;\n+import jdk.internal.classfile.attribute.CodeAttribute;\n+\n@@ -85,0 +107,1 @@\n+import jdk.vm.ci.hotspot.HotSpotResolvedJavaMethod;\n@@ -570,0 +593,146 @@\n+    private static ClassModel readClassfile(Class<?> c) throws Exception {\n+        String name = c.getName();\n+        final int lastDot = name.lastIndexOf('.');\n+        if (lastDot != -1) {\n+            name = name.substring(lastDot + 1);\n+        }\n+        URI uri = c.getResource(name + \".class\").toURI();\n+        if (uri.getScheme().equals(\"jar\")) {\n+            final String[] parts = uri.toString().split(\"!\");\n+            if (parts.length == 2) {\n+                try (FileSystem fs = FileSystems.newFileSystem(URI.create(parts[0]), new HashMap<>())) {\n+                    return Classfile.of().parse(fs.getPath(parts[1]));\n+                }\n+            }\n+        }\n+        return Classfile.of().parse(Paths.get(uri));\n+    }\n+\n+    public static void methodWithManyArgs(\n+        Object   o0, int   i1, int  i2,  int   i3, int   i4, int   i5, int   i6, int  i7,\n+           int   i8, int   i9, int  i10, int  i11, int  i12, int  i13, int  i14, int  i15,\n+           int  i16, int  i17, int  i18, int  i19, int  i20, int  i21, int  i22, int  i23,\n+           int  i24, int  i25, int  i26, int  i27, int  i28, int  i29, int  i30, int  i31,\n+           int  i32, int  i33, int  i34, int  i35, int  i36, int  i37, int  i38, int  i39,\n+           int  i40, int  i41, int  i42, int  i43, int  i44, int  i45, int  i46, int  i47,\n+           int  i48, int  i49, int  i50, int  i51, int  i52, int  i53, int  i54, int  i55,\n+           int  i56, int  i57, int  i58, int  i59, int  i60, int  i61, int  i62, int  i63,\n+        Object  o64, int  i65, int  i66, int  i67, int  i68, int  i69, int  i70, int  i71,\n+           int  i72, int  i73, int  i74, int  i75, int  i76, int  i77, int  i78, int  i79,\n+           int  i80, int  i81, int  i82, int  i83, int  i84, int  i85, int  i86, int  i87,\n+           int  i88, int  i89, int  i90, int  i91, int  i92, int  i93, int  i94, int  i95,\n+           int  i96, int  i97, int  i98, int  i99, int i100, int i101, int i102, int i103,\n+           int i104, int i105, int i106, int i107, int i108, int i109, int i110, int i111,\n+           int i112, int i113, int i114, int i115, int i116, int i117, int i118, int i119,\n+           int i120, int i121, int i122, int i123, int i124, int i125, int i126, int i127,\n+        Object o128)\n+    {\n+        o0.hashCode();\n+        o64.hashCode();\n+        if (o128 != null) {\n+            Object t1 = \"tmp val\";\n+            t1.hashCode();\n+        } else {\n+            int t1 = 42 + i1;\n+            String.valueOf(t1);\n+        }\n+        o128.hashCode();\n+    }\n+\n+    private static Map<String, ResolvedJavaMethod> buildMethodMap(ResolvedJavaType type) {\n+        Map<String, ResolvedJavaMethod> methodMap = new HashMap<>();\n+        for (ResolvedJavaMethod m : type.getDeclaredMethods()) {\n+            if (m.hasBytecodes()) {\n+                String key = m.getName() + \":\" + m.getSignature().toMethodDescriptor();\n+                methodMap.put(key, m);\n+            }\n+        }\n+        for (ResolvedJavaMethod m : type.getDeclaredConstructors()) {\n+            if (m.hasBytecodes()) {\n+                String key = \"<init>:\" + m.getSignature().toMethodDescriptor();\n+                methodMap.put(key, m);\n+            }\n+        }\n+        ResolvedJavaMethod clinit = type.getClassInitializer();\n+        if (clinit != null) {\n+            String key = \"<clinit>:()V\";\n+            methodMap.put(key, clinit);\n+        }\n+        return methodMap;\n+    }\n+\n+    @Test\n+    public void getOopMapAtTest() throws Exception {\n+        Collection<Class<?>> allClasses = new ArrayList<>(classes);\n+\n+        \/\/ Add this class so that methodWithManyArgs is processed\n+        allClasses.add(getClass());\n+\n+        boolean[] processedMethodWithManyArgs = {false};\n+\n+        for (Class<?> c : allClasses) {\n+            if (c.isArray() || c.isPrimitive() || c.isHidden()) {\n+                continue;\n+            }\n+            ResolvedJavaType type = metaAccess.lookupJavaType(c);\n+            Map<String, ResolvedJavaMethod> methodMap = buildMethodMap(type);\n+            ClassModel cf = readClassfile(c);\n+            for (MethodModel cm : cf.methods()) {\n+                cm.findAttribute(Attributes.CODE).ifPresent(codeAttr -> {\n+                    String key = cm.methodName().stringValue() + \":\" + cm.methodType().stringValue();\n+                    HotSpotResolvedJavaMethod m = (HotSpotResolvedJavaMethod) Objects.requireNonNull(methodMap.get(key));\n+                    boolean isMethodWithManyArgs = c == getClass() && m.getName().equals(\"methodWithManyArgs\");\n+                    if (isMethodWithManyArgs) {\n+                        processedMethodWithManyArgs[0] = true;\n+                    }\n+                    int maxSlots = m.getMaxLocals() + m.getMaxStackSize();\n+\n+                    int bci = 0;\n+                    Map<String, int[]> expectOopMaps = !isMethodWithManyArgs ? null : Map.of(\n+                        \"{0, 64, 128}\",      new int[] {0},\n+                        \"{0, 64, 128, 130}\", new int[] {0},\n+                        \"{0, 64, 128, 129}\", new int[] {0});\n+                    for (CodeElement i : codeAttr.elementList()) {\n+                        if (i instanceof Instruction ins) {\n+                            BitSet oopMap = m.getOopMapAt(bci);\n+                            if (isMethodWithManyArgs) {\n+                                System.out.printf(\"methodWithManyArgs@%d [%d]: %s%n\", bci, maxSlots, oopMap);\n+                                System.out.printf(\"methodWithManyArgs@%d [%d]: %s%n\", bci, maxSlots, ins);\n+\n+                                \/\/ Assumes stability of javac output\n+                                String where = \"methodWithManyArgs@\" + bci;\n+                                String oopMapString = String.valueOf(oopMap);\n+                                int[] count = expectOopMaps.get(oopMapString);\n+                                if (count == null) {\n+                                    throw new AssertionError(where + \": unexpected oop map: \" + oopMapString);\n+                                }\n+                                count[0]++;\n+                            }\n+\n+                            \/\/ Requesting an oop map at an invalid BCI must throw an exception\n+                            if (ins.sizeInBytes() > 1) {\n+                                try {\n+                                    oopMap = m.getOopMapAt(bci + 1);\n+                                    throw new AssertionError(\"expected exception for illegal bci %d in %s: %s\".formatted(bci + 1, m.format(\"%H.%n(%p)\"), oopMap));\n+                                } catch(IllegalArgumentException e) {\n+                                    \/\/ expected\n+                                }\n+                            }\n+                            bci += ins.sizeInBytes();\n+                        }\n+                    }\n+                    if (isMethodWithManyArgs) {\n+                        for (var e : expectOopMaps.entrySet()) {\n+                            if (e.getValue()[0] == 0) {\n+                                throw new AssertionError(m.format(\"%H.%n(%p)\") + \"did not find expected oop map: \" + e.getKey());\n+                            }\n+                            System.out.printf(\"methodWithManyArgs: %s = %d%n\", e.getKey(), e.getValue()[0]);\n+                        }\n+                    }\n+                });\n+            }\n+        }\n+\n+        Assert.assertTrue(processedMethodWithManyArgs[0]);\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/jdk.vm.ci.runtime.test\/src\/jdk\/vm\/ci\/runtime\/test\/TestResolvedJavaMethod.java","additions":169,"deletions":0,"binary":false,"changes":169,"status":"modified"}]}