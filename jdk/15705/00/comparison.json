{"files":[{"patch":"@@ -197,1 +197,1 @@\n-    (_mask_size == 0 || _mask_size == USHRT_MAX) &&\n+    (_mask_size == 0 || _mask_size == INT_MAX) &&\n@@ -204,1 +204,1 @@\n-  _mask_size = USHRT_MAX;  \/\/ This value should cause a failure quickly\n+  _mask_size = INT_MAX;  \/\/ This value should cause a failure quickly\n@@ -615,1 +615,3 @@\n-  entry->resource_copy(tmp);\n+  if (tmp->has_valid_mask()) {\n+    entry->resource_copy(tmp);\n+  }\n","filename":"src\/hotspot\/share\/interpreter\/oopMapCache.cpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -87,1 +87,1 @@\n-  int            _mask_size;      \/\/ the mask size in bits\n+  int            _mask_size;      \/\/ the mask size in bits (INT_MAX if invalid)\n@@ -149,0 +149,2 @@\n+  \/\/ Determines if a valid mask has been computed\n+  bool has_valid_mask() const { return _mask_size != INT_MAX; }\n","filename":"src\/hotspot\/share\/interpreter\/oopMapCache.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+#include \"interpreter\/oopMapCache.hpp\"\n@@ -2515,1 +2516,1 @@\n-}\n+C2V_END\n@@ -2780,1 +2781,1 @@\n-}\n+C2V_END\n@@ -2793,1 +2794,1 @@\n-}\n+C2V_END\n@@ -2799,1 +2800,1 @@\n-}\n+C2V_END\n@@ -2815,1 +2816,1 @@\n-}\n+C2V_END\n@@ -2831,1 +2832,1 @@\n-}\n+C2V_END\n@@ -2853,1 +2854,1 @@\n-}\n+C2V_END\n@@ -2967,1 +2968,1 @@\n-}\n+C2V_END\n@@ -2978,1 +2979,1 @@\n-}\n+C2V_END\n@@ -2982,1 +2983,1 @@\n-}\n+C2V_END\n@@ -2990,1 +2991,1 @@\n-}\n+C2V_END\n@@ -3002,1 +3003,1 @@\n-}\n+C2V_END\n@@ -3006,1 +3007,1 @@\n-}\n+C2V_END\n@@ -3016,1 +3017,1 @@\n-}\n+C2V_END\n@@ -3023,1 +3024,1 @@\n-}\n+C2V_END\n@@ -3033,1 +3034,1 @@\n-}\n+C2V_END\n@@ -3043,1 +3044,1 @@\n-}\n+C2V_END\n@@ -3052,1 +3053,1 @@\n-}\n+C2V_END\n@@ -3064,1 +3065,1 @@\n-}\n+C2V_END\n@@ -3076,1 +3077,30 @@\n-}\n+C2V_END\n+\n+C2V_VMENTRY_0(jlong, getLiveObjectLocalsAt, (JNIEnv* env, jobject, ARGUMENT_PAIR(method),\n+                 jint bci, jlong buffer))\n+  methodHandle method(THREAD, UNPACK_PAIR(Method, method));\n+  if (bci < 0 || bci >= method->code_size()) {\n+    JVMCI_THROW_MSG_0(IllegalArgumentException,\n+                err_msg(\"bci %d is out of bounds [0 .. %d)\", bci, method->code_size()));\n+  }\n+  InterpreterOopMap mask;\n+  OopMapCache::compute_one_oop_map(method, bci, &mask);\n+  if (!mask.has_valid_mask()) {\n+    JVMCI_THROW_MSG_0(IllegalArgumentException, err_msg(\"bci %d is not valid\", bci));\n+  }\n+  int nlocals = method->max_locals();\n+  jlong liveness = 0L;\n+  \/\/ stringStream st;\n+  \/\/ st.print(\"BitMap[%s@%d, nlocals:%d]:\", method->name_and_sig_as_C_string(), bci, nlocals);\n+  BitMapView bm = BitMapView((BitMap::bm_word_t*) (nlocals <= 64 ? (jlong) &liveness : buffer), nlocals);\n+  for (int i = 0; i < nlocals ; i++ ) {\n+    if (mask.is_oop(i)) {\n+      bm.set_bit(i);\n+      \/\/ st.print(\" %d\", i);\n+    }\n+  }\n+  \/\/ st.print(\" [liveness: 0x\" JULONG_FORMAT_X \"]\", (julong) liveness);\n+  \/\/ tty->print_raw_cr(st.as_string());\n+  \/\/ tty->flush();\n+  return liveness;\n+C2V_END\n@@ -3235,0 +3265,1 @@\n+  {CC \"getLiveObjectLocalsAt\",                        CC \"(\" HS_METHOD2 \"IJ)J\",                                                             FN_PTR(getLiveObjectLocalsAt)},\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":51,"deletions":20,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -1476,0 +1476,7 @@\n+\n+\n+    long getLiveObjectLocalsAt(HotSpotResolvedJavaMethodImpl method, int bci, long buffer) {\n+        return getLiveObjectLocalsAt(method, method.getMethodPointer(), bci, buffer);\n+    }\n+\n+    native long getLiveObjectLocalsAt(HotSpotResolvedJavaMethodImpl method, long methodPointer, int bci, long buffer);\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/CompilerToVM.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+import java.lang.reflect.Parameter;\n@@ -38,0 +39,1 @@\n+import java.util.BitSet;\n@@ -42,0 +44,1 @@\n+import jdk.internal.misc.Unsafe;\n@@ -770,0 +773,40 @@\n+\n+    \/*\n+     * BitSets are packed into arrays of \"words.\"  Currently a word is\n+     * a long, which consists of 64 bits, requiring 6 address bits.\n+     * The choice of word size is determined purely by performance concerns.\n+     *\/\n+    private static final int ADDRESS_BITS_PER_WORD = 6;\n+    private static final int BITS_PER_WORD = 1 << ADDRESS_BITS_PER_WORD;\n+    private static final int BIT_INDEX_MASK = BITS_PER_WORD - 1;\n+\n+    private static int wordIndex(int bitIndex) {\n+        return bitIndex >> ADDRESS_BITS_PER_WORD;\n+    }\n+\n+    @Override\n+    public long getLiveObjectLocalsAt(int bci, BitSet bigOopMap) {\n+        int locals = getMaxLocals();\n+        if (locals == 0) {\n+            throw new IllegalArgumentException(\"cannot compute oop map for method with no local variables\");\n+        }\n+        if (locals > 64) {\n+            int nwords = ((locals - 1) \/ 64) + 1;\n+            Unsafe unsafe = UnsafeAccess.UNSAFE;\n+            long buffer = unsafe.allocateMemory(nwords);\n+            try {\n+                compilerToVM().getLiveObjectLocalsAt(this, bci, buffer);\n+                long liveness[] = new long[nwords];\n+                for (int i = 0; i < nwords; i++) {\n+                    liveness[i] = unsafe.getLong(buffer + i);\n+                }\n+                bigOopMap.or(BitSet.valueOf(liveness));\n+            } finally {\n+                unsafe.freeMemory(buffer);\n+            }\n+            return 0;\n+        } else {\n+            return compilerToVM().getLiveObjectLocalsAt(this, bci, 0);\n+        }\n+    }\n+\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotResolvedJavaMethodImpl.java","additions":43,"deletions":0,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import java.util.BitSet;\n@@ -472,0 +473,24 @@\n+\n+    \/**\n+     * Computes which local variables contain live object values\n+     * at the instruction denoted by {@code bci}. This is the \"oop map\" used\n+     * by the garbage collector.\n+     *\n+     * If {@link #getMaxLocals()} {@code <= 64}, then the oop map is encoded\n+     * in the return value. Otherwise, it is copied into {@code bigOopMap}.\n+     *\n+     * @param bci the index of an instruction in this method's bytecodes\n+     * @param bigOopMap the bit set in which the oop map is returned for\n+     *         methods whose max number of local variables is {@code > 64}. It's up\n+     *         to the caller to ensure this bit set is large enough and initially has\n+     *         all bits set to 0.\n+     * @return the oop map for methods with 64 or less max locals otherwise 0\n+     * @throws NullPointerException if {@link #getMaxLocals()} {@code > 64 && bigOopMap == null}\n+     * @throws IllegalArgumentException if {@link #getMaxLocals()} {@code == 0} or if\n+     *         {@code bci} is not the index of a bytecode instruction\n+     * @throws UnsupportedOperationException if local variable liveness is not provided\n+     *         by the current JVMCI runtime\n+     *\/\n+    default long getLiveObjectLocalsAt(int bci, BitSet bigOopMap) {\n+        throw new UnsupportedOperationException();\n+    }\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/meta\/ResolvedJavaMethod.java","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -38,0 +38,3 @@\n+ *          java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.classfile.attribute\n+ *          java.base\/jdk.internal.classfile.constantpool\n@@ -53,0 +56,1 @@\n+import java.io.DataInputStream;\n@@ -64,0 +68,6 @@\n+import java.net.URI;\n+import java.nio.file.FileSystem;\n+import java.nio.file.FileSystems;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n@@ -66,0 +76,2 @@\n+import java.util.BitSet;\n+import java.util.Collection;\n@@ -70,0 +82,1 @@\n+import java.util.Objects;\n@@ -76,0 +89,8 @@\n+import jdk.internal.classfile.Attributes;\n+import jdk.internal.classfile.Classfile;\n+import jdk.internal.classfile.ClassModel;\n+import jdk.internal.classfile.CodeElement;\n+import jdk.internal.classfile.MethodModel;\n+import jdk.internal.classfile.Instruction;\n+import jdk.internal.classfile.attribute.CodeAttribute;\n+\n@@ -570,0 +591,178 @@\n+    private static ClassModel readClassfile(Class<?> c) throws Exception {\n+        String name = c.getName();\n+        final int lastDot = name.lastIndexOf('.');\n+        if (lastDot != -1) {\n+            name = name.substring(lastDot + 1);\n+        }\n+        URI uri = c.getResource(name + \".class\").toURI();\n+        if (uri.getScheme().equals(\"jar\")) {\n+            final String[] parts = uri.toString().split(\"!\");\n+            if (parts.length == 2) {\n+                try (FileSystem fs = FileSystems.newFileSystem(URI.create(parts[0]), new HashMap<>())) {\n+                    return Classfile.of().parse(fs.getPath(parts[1]));\n+                }\n+            }\n+        }\n+        return Classfile.of().parse(Paths.get(uri));\n+    }\n+\n+    public static void methodWithManyArgs(\n+        Object o1, int i1,\n+        Object o2, int i2,\n+        Object o3, int i3,\n+        Object o4, int i4,\n+        Object o5, int i5,\n+        Object o6, int i6,\n+        Object o7, int i7,\n+        Object o8, int i8,\n+        Object o9, int i9,\n+        Object o10, int i10,\n+        Object o11, int i11,\n+        Object o12, int i12,\n+        Object o13, int i13,\n+        Object o14, int i14,\n+        Object o15, int i15,\n+        Object o16, int i16,\n+        Object o17, int i17,\n+        Object o18, int i18,\n+        Object o19, int i19,\n+        Object o20, int i20,\n+        Object o21, int i21,\n+        Object o22, int i22,\n+        Object o23, int i23,\n+        Object o24, int i24,\n+        Object o25, int i25,\n+        Object o26, int i26,\n+        Object o27, int i27,\n+        Object o28, int i28,\n+        Object o29, int i29,\n+        Object o30, int i30,\n+        Object o31, int i31,\n+        Object o32, int i32,\n+        Object o33, int i33,\n+        Object o34, int i34,\n+        Object o35, int i35,\n+        Object o36, int i36,\n+        Object o37, int i37,\n+        Object o38, int i38,\n+        Object o39, int i39,\n+        Object o40, int i40,\n+        Object o41, int i41,\n+        Object o42, int i42,\n+        Object o43, int i43,\n+        Object o44, int i44,\n+        Object o45, int i45,\n+        Object o46, int i46,\n+        Object o47, int i47,\n+        Object o48, int i48,\n+        Object o49, int i49,\n+        Object o50, int i50,\n+        Object o51, int i51,\n+        Object o52, int i52,\n+        Object o53, int i53,\n+        Object o54, int i54,\n+        Object o55, int i55,\n+        Object o56, int i56,\n+        Object o57, int i57,\n+        Object o58, int i58,\n+        Object o59, int i59) {\n+            System.out.println(\"\" + o1 + i1);\n+            System.out.println(\"\" + o2 + i2);\n+            System.out.println(\"\" + o3 + i3);\n+            System.out.println(\"\" + o4 + i4);\n+            System.out.println(\"\" + o5 + i5);\n+            System.out.println(\"\" + o6 + i6);\n+            System.out.println(\"\" + o7 + i7);\n+            System.out.println(\"\" + o8 + i8);\n+            System.out.println(\"\" + o9 + i9);\n+            System.out.println(\"\" + o10 + i10);\n+            System.out.println(\"\" + o11 + i11);\n+            System.out.println(\"\" + o12 + i12);\n+            System.out.println(\"\" + o13 + i13);\n+            System.out.println(\"\" + o14 + i14);\n+            System.out.println(\"\" + o15 + i15);\n+            System.out.println(\"\" + o16 + i16);\n+            System.out.println(\"\" + o17 + i17);\n+            System.out.println(\"\" + o58 + i58);\n+            System.out.println(\"\" + o59 + i59);\n+        }\n+\n+    private static Map<String, ResolvedJavaMethod> buildMethodMap(ResolvedJavaType type) {\n+        Map<String, ResolvedJavaMethod> methodMap = new HashMap<>();\n+        for (ResolvedJavaMethod m : type.getDeclaredMethods()) {\n+            if (m.hasBytecodes()) {\n+                String key = m.getName() + \":\" + m.getSignature().toMethodDescriptor();\n+                methodMap.put(key, m);\n+            }\n+        }\n+        for (ResolvedJavaMethod m : type.getDeclaredConstructors()) {\n+            if (m.hasBytecodes()) {\n+                String key = \"<init>:\" + m.getSignature().toMethodDescriptor();\n+                methodMap.put(key, m);\n+            }\n+        }\n+        ResolvedJavaMethod clinit = type.getClassInitializer();\n+        if (clinit != null) {\n+            String key = \"<clinit>:()V\";\n+            methodMap.put(key, clinit);\n+        }\n+        return methodMap;\n+    }\n+\n+    @Test\n+    public void getLiveObjectLocalsAtTest() throws Exception {\n+        Collection<Class<?>> allClasses = new ArrayList<>(classes);\n+\n+        \/\/ Add this class so that methodWithManyArgs is processed\n+        allClasses.add(getClass());\n+\n+        for (Class<?> c : allClasses) {\n+            if (c.isArray() || c.isPrimitive() || c.isHidden()) {\n+                continue;\n+            }\n+            ResolvedJavaType type = metaAccess.lookupJavaType(c);\n+            Map<String, ResolvedJavaMethod> methodMap = buildMethodMap(type);\n+            ClassModel cf = readClassfile(c);\n+            for (MethodModel cm : cf.methods()) {\n+                cm.findAttribute(Attributes.CODE).ifPresent(codeAttr -> {\n+                    String key = cm.methodName().stringValue() + \":\" + cm.methodType().stringValue();\n+                    ResolvedJavaMethod m = Objects.requireNonNull(methodMap.get(key));\n+                    int maxLocals = m.getMaxLocals();\n+\n+                    \/\/ Requesting an oop map for a method with 0 locals must throw an exception\n+                    if (maxLocals == 0) {\n+                        try {\n+                            m.getLiveObjectLocalsAt(0, null);\n+                            throw new AssertionError(\"expected exception for method %s with no locals\".formatted(m.format(\"%H.%n(%p)\")));\n+                        } catch(IllegalArgumentException e) {\n+                            return;\n+                        }\n+                    }\n+\n+                    int bci = 0;\n+                    for (CodeElement i : codeAttr.elementList()) {\n+                        if (i instanceof Instruction ins) {\n+                            BitSet bigOopMap = maxLocals <= 64 ? null : new BitSet(maxLocals);\n+                            long oopMap = m.getLiveObjectLocalsAt(bci, bigOopMap);\n+                            if (maxLocals > 64) {\n+                                Assert.assertEquals(m.toString(), oopMap, 0L);\n+                                Assert.assertNotEquals(m.toString(), bigOopMap.cardinality(), 0);\n+                            }\n+\n+                            \/\/ Requesting an oop map at an invalid BCI must throw an exception\n+                            if (ins.sizeInBytes() > 1) {\n+                                try {\n+                                    m.getLiveObjectLocalsAt(bci + 1, bigOopMap);\n+                                    throw new AssertionError(\"expected exception for illegal bci %d in %s\".formatted(bci + 1, m.format(\"%H.%n(%p)\")));\n+                                } catch(IllegalArgumentException e) {\n+                                    \/\/ expected\n+                                }\n+                            }\n+                            bci += ins.sizeInBytes();\n+                        }\n+                    }\n+                });\n+            }\n+        }\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/jdk.vm.ci.runtime.test\/src\/jdk\/vm\/ci\/runtime\/test\/TestResolvedJavaMethod.java","additions":199,"deletions":0,"binary":false,"changes":199,"status":"modified"}]}