{"files":[{"patch":"@@ -47,0 +47,1 @@\n+#include \"runtime\/flags\/jvmFlagLimit.hpp\"\n@@ -2270,5 +2271,3 @@\n-  const julong min_ThreadStackSize = 0;\n-  const julong max_ThreadStackSize = 1 * M;\n-\n-  const julong min_size = min_ThreadStackSize * K;\n-  const julong max_size = max_ThreadStackSize * K;\n+  const JVMTypedFlagLimit<intx>* limit = JVMFlagLimit::get_range_at(FLAG_MEMBER_ENUM(ThreadStackSize))->cast<intx>();\n+  const julong min_size = limit->min() * K;\n+  const julong max_size = limit->max() * K;\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,1 @@\n+#include <type_traits>\n@@ -293,0 +294,21 @@\n+  \/\/ type checking\n+  template <typename T>\n+  static void assert_compatible_type(int flag_enum) {\n+#ifndef PRODUCT\n+    if (std::is_integral<T>::value) {\n+      switch (flag_enum) {\n+      case TYPE_bool:     assert(sizeof(T) == sizeof(bool)     && std::is_signed<T>::value == std::is_signed<bool>    ::value, \"must be\"); break;\n+      case TYPE_int:      assert(sizeof(T) == sizeof(int)      && std::is_signed<T>::value == std::is_signed<int>     ::value, \"must be\"); break;\n+      case TYPE_uint:     assert(sizeof(T) == sizeof(uint)     && std::is_signed<T>::value == std::is_signed<uint>    ::value, \"must be\"); break;\n+      case TYPE_intx:     assert(sizeof(T) == sizeof(intx)     && std::is_signed<T>::value == std::is_signed<intx>    ::value, \"must be\"); break;\n+      case TYPE_uintx:    assert(sizeof(T) == sizeof(uintx)    && std::is_signed<T>::value == std::is_signed<uintx>   ::value, \"must be\"); break;\n+      case TYPE_uint64_t: assert(sizeof(T) == sizeof(uint64_t) && std::is_signed<T>::value == std::is_signed<uint64_t>::value, \"must be\"); break;\n+      case TYPE_size_t:   assert(sizeof(T) == sizeof(size_t)   && std::is_signed<T>::value == std::is_signed<size_t>  ::value, \"must be\"); break;\n+      default: ShouldNotReachHere();\n+      }\n+    } else {\n+      assert(flag_enum == JVMFlag::TYPE_double, \"must be double\");\n+    }\n+#endif\n+  }\n+\n","filename":"src\/hotspot\/share\/runtime\/flags\/jvmFlag.hpp","additions":23,"deletions":1,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -95,1 +95,1 @@\n-#define FLAG_LIMIT_DEFINE(      type, name, ...)       ); constexpr JVMTypedFlagLimit<type> limit_##name(0\n+#define FLAG_LIMIT_DEFINE(      type, name, ...)       ); constexpr JVMTypedFlagLimit<type> limit_##name(JVMFlag::TYPE_##type\n","filename":"src\/hotspot\/share\/runtime\/flags\/jvmFlagLimit.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,0 +53,2 @@\n+template <typename T> class JVMTypedFlagLimit;\n+\n@@ -71,0 +73,4 @@\n+#ifndef PRODUCT\n+  int   _type_enum;\n+#endif\n+\n@@ -100,1 +106,2 @@\n-  constexpr JVMFlagLimit(short func, short phase, short kind) : _constraint_func(func), _phase(phase), _kind(kind) {}\n+  constexpr JVMFlagLimit(int type_enum, short func, short phase, short kind)\n+    : _constraint_func(func), _phase(phase), _kind(kind) NOT_PRODUCT(COMMA _type_enum(type_enum)) {}\n@@ -133,0 +140,23 @@\n+\n+  template <typename T>\n+  const JVMTypedFlagLimit<T>* cast() const;\n+\n+  template <typename T>\n+  static void assert_compatible_type(int flag_enum) {\n+#ifndef PRODUCT\n+    if (std::is_integral<T>::value) {\n+      switch (flag_enum) {\n+      case JVMFlag::TYPE_bool:     assert(sizeof(T) == sizeof(bool)     && std::is_signed<T>::value == std::is_signed<bool>    ::value, \"must be\"); break;\n+      case JVMFlag::TYPE_int:      assert(sizeof(T) == sizeof(int)      && std::is_signed<T>::value == std::is_signed<int>     ::value, \"must be\"); break;\n+      case JVMFlag::TYPE_uint:     assert(sizeof(T) == sizeof(uint)     && std::is_signed<T>::value == std::is_signed<uint>    ::value, \"must be\"); break;\n+      case JVMFlag::TYPE_intx:     assert(sizeof(T) == sizeof(intx)     && std::is_signed<T>::value == std::is_signed<intx>    ::value, \"must be\"); break;\n+      case JVMFlag::TYPE_uintx:    assert(sizeof(T) == sizeof(uintx)    && std::is_signed<T>::value == std::is_signed<uintx>   ::value, \"must be\"); break;\n+      case JVMFlag::TYPE_uint64_t: assert(sizeof(T) == sizeof(uint64_t) && std::is_signed<T>::value == std::is_signed<uint64_t>::value, \"must be\"); break;\n+      case JVMFlag::TYPE_size_t:   assert(sizeof(T) == sizeof(size_t)   && std::is_signed<T>::value == std::is_signed<size_t>  ::value, \"must be\"); break;\n+      default: ShouldNotReachHere();\n+      }\n+    } else {\n+      assert(flag_enum == JVMFlag::TYPE_double, \"must be double\");\n+    }\n+#endif\n+  }\n@@ -147,2 +177,2 @@\n-  constexpr JVMTypedFlagLimit(int dummy) :\n-    JVMFlagLimit(0, 0, 0), _min(0), _max(0) {}\n+  constexpr JVMTypedFlagLimit(int type_enum) :\n+  JVMFlagLimit(0, 0, 0, 0), _min(0), _max(0) {}\n@@ -151,2 +181,2 @@\n-  constexpr JVMTypedFlagLimit(int dummy, T min, T max) :\n-    JVMFlagLimit(0, 0, HAS_RANGE), _min(min), _max(max) {}\n+  constexpr JVMTypedFlagLimit(int type_enum, T min, T max) :\n+    JVMFlagLimit(type_enum, 0, 0, HAS_RANGE), _min(min), _max(max) {}\n@@ -155,2 +185,2 @@\n-  constexpr JVMTypedFlagLimit(int dummy, ConstraintMarker dummy2, short func, int phase) :\n-    JVMFlagLimit(func, phase, HAS_CONSTRAINT), _min(0), _max(0) {}\n+  constexpr JVMTypedFlagLimit(int type_enum, ConstraintMarker dummy2, short func, int phase) :\n+    JVMFlagLimit(type_enum, func, phase, HAS_CONSTRAINT), _min(0), _max(0) {}\n@@ -159,2 +189,2 @@\n-  constexpr JVMTypedFlagLimit(int dummy, T min, T max, ConstraintMarker dummy2, short func, int phase)  :\n-    JVMFlagLimit(func, phase, HAS_RANGE | HAS_CONSTRAINT), _min(min), _max(max) {}\n+  constexpr JVMTypedFlagLimit(int type_enum, T min, T max, ConstraintMarker dummy2, short func, int phase)  :\n+    JVMFlagLimit(type_enum, func, phase, HAS_RANGE | HAS_CONSTRAINT), _min(min), _max(max) {}\n@@ -163,2 +193,2 @@\n-  constexpr JVMTypedFlagLimit(int dummy, ConstraintMarker dummy2, short func, int phase, T min, T max)  :\n-    JVMFlagLimit(func, phase, HAS_RANGE | HAS_CONSTRAINT), _min(min), _max(max) {}\n+  constexpr JVMTypedFlagLimit(int type_enum, ConstraintMarker dummy2, short func, int phase, T min, T max)  :\n+    JVMFlagLimit(type_enum, func, phase, HAS_RANGE | HAS_CONSTRAINT), _min(min), _max(max) {}\n@@ -170,0 +200,6 @@\n+template <typename T>\n+const JVMTypedFlagLimit<T>* JVMFlagLimit::cast() const {\n+  NOT_PRODUCT(JVMFlag::assert_compatible_type<T>(_type_enum));\n+  return static_cast<const JVMTypedFlagLimit<T>*>(this);\n+}\n+\n","filename":"src\/hotspot\/share\/runtime\/flags\/jvmFlagLimit.hpp","additions":48,"deletions":12,"binary":false,"changes":60,"status":"modified"}]}