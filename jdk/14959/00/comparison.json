{"files":[{"patch":"@@ -31,0 +31,1 @@\n+#include \"cds\/dynamicArchive.hpp\"\n@@ -235,0 +236,3 @@\n+  if (DynamicDumpSharedSpaces) {\n+    iterate_primitive_array_klasses(&doit);\n+  }\n@@ -521,4 +525,0 @@\n-    if (DynamicDumpSharedSpaces) {\n-      \/\/ Don't support archiving of array klasses for now (WHY???)\n-      return true;\n-    }\n@@ -793,0 +793,32 @@\n+\n+  DynamicArchive::make_array_klasses_shareable();\n+}\n+\n+void ArchiveBuilder::gather_array_klasses() {\n+  for (int i = 0; i < klasses()->length(); i++) {\n+    if (klasses()->at(i)->is_objArray_klass()) {\n+      ObjArrayKlass* oak = ObjArrayKlass::cast(klasses()->at(i));\n+      Klass* elem = oak->element_klass();\n+      if (MetaspaceShared::is_shared_static(elem)) {\n+        \/\/ Only capture the array klass whose element_klass is in the static archive.\n+        \/\/ During run time, setup (see DynamicArchive::setup_array_klasses()) is needed\n+        \/\/ so that the element_klass can find its array klasses from the dynamic archive.\n+        ArrayKlass* ak = ArrayKlass::cast(klasses()->at(i));\n+        DynamicArchive::append_array_klass(ak);\n+      } else {\n+        \/\/ The element_klass and its array klasses are in the same archive.\n+        if (oak->dimension() > 1) {\n+          assert(ArrayKlass::cast(elem)->higher_dimension() == oak, \"must be\");\n+        } else {\n+          assert(InstanceKlass::cast(elem)->array_klasses() == oak, \"must be\");\n+        }\n+      }\n+    }\n+  }\n+  log_debug(cds)(\"Total array klasses gathered for dynamic archive: %d\", DynamicArchive::num_array_klasses());\n+}\n+\n+void ArchiveBuilder::serialize_dynamic_archivable_items(SerializeClosure* soc) {\n+  SymbolTable::serialize_shared_table_header(soc, false);\n+  SystemDictionaryShared::serialize_dictionary_headers(soc, false);\n+  DynamicArchive::serialize_array_klasses(soc);\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.cpp","additions":36,"deletions":4,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -259,0 +259,1 @@\n+  virtual void iterate_primitive_array_klasses(MetaspaceClosure* it) = 0;\n@@ -344,0 +345,2 @@\n+  void gather_array_klasses();\n+  static void serialize_dynamic_archivable_items(SerializeClosure* soc);\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -155,1 +155,5 @@\n-  assert(!k->is_shared(), \"Do not call with shared classes\");\n+#ifdef ASSERT\n+    if (k->is_shared()) {\n+      assert(DynamicDumpSharedSpaces, \"Should only be called with shared class during DynamicDumpSharedSpaces\");\n+    }\n+#endif\n@@ -157,3 +161,7 @@\n-  assert(p != nullptr, \"we must not see any non-shared InstanceKlass* that's \"\n-         \"not stored with SystemDictionaryShared::init_dumptime_info\");\n-  assert(p->_klass == k, \"Sanity\");\n+#ifdef ASSERT\n+  if (DumpSharedSpaces) {\n+    assert(p != nullptr, \"we must not see any non-shared InstanceKlass* that's \"\n+           \"not stored with SystemDictionaryShared::init_dumptime_info\");\n+    assert(p->_klass == k, \"Sanity\");\n+  }\n+#endif\n","filename":"src\/hotspot\/share\/cds\/dumpTimeClassInfo.cpp","additions":12,"deletions":4,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -48,0 +48,1 @@\n+#include \"runtime\/signature.hpp\"\n@@ -121,0 +122,1 @@\n+    gather_array_klasses();\n@@ -142,0 +144,1 @@\n+      DynamicArchive::dump_array_klasses();\n@@ -145,2 +148,1 @@\n-      SymbolTable::serialize_shared_table_header(&wc, false);\n-      SystemDictionaryShared::serialize_dictionary_headers(&wc, false);\n+      ArchiveBuilder::serialize_dynamic_archivable_items(&wc);\n@@ -163,0 +165,1 @@\n+    DynamicArchive::post_dump();\n@@ -174,0 +177,22 @@\n+\n+  virtual void iterate_primitive_array_klasses(MetaspaceClosure* it) {\n+    for (int i = T_BOOLEAN; i <= T_LONG; i++) {\n+      assert(is_java_primitive((BasicType)i), \"sanity\");\n+      Klass* k = Universe::typeArrayKlassObj((BasicType)i);  \/\/ this give you \"[I\", etc\n+      assert(MetaspaceShared::is_shared_static((void*)k),\n+        \"one-dimensional primitive array should be in static archive\");\n+      ArrayKlass* ak = ArrayKlass::cast(k);\n+      while (ak != nullptr && ak->is_shared()) {\n+        Klass* next_k = ak->array_klass_or_null();\n+        if (next_k != nullptr) {\n+          ak = ArrayKlass::cast(next_k);\n+        } else {\n+          ak = nullptr;\n+        }\n+      }\n+      if (ak != nullptr && (ak->dimension() > 1)) {\n+        \/\/ this is the lowest dimension that's not in the static archive\n+        it->push(&ak);\n+      }\n+    }\n+  }\n@@ -352,0 +377,137 @@\n+GrowableArray<ArrayKlass*>* DynamicArchive::_array_klasses = nullptr;\n+Array<ArrayKlass*>* DynamicArchive::_dynamic_archive_array_klasses = nullptr;\n+\n+void DynamicArchive::append_array_klass(ArrayKlass* ak) {\n+  if (_array_klasses == nullptr) {\n+    _array_klasses = new (mtClassShared) GrowableArray<ArrayKlass*>(50, mtClassShared);\n+  }\n+  _array_klasses->append(ak);\n+}\n+\n+void DynamicArchive::dump_array_klasses() {\n+  assert(DynamicDumpSharedSpaces, \"DynamicDumpSharedSpaces only\");\n+  if (_array_klasses != nullptr) {\n+    ArchiveBuilder* builder = ArchiveBuilder::current();\n+    int num_array_klasses = _array_klasses->length();\n+    _dynamic_archive_array_klasses =\n+        ArchiveBuilder::new_ro_array<ArrayKlass*>(num_array_klasses);\n+    for (int i = 0; i < num_array_klasses; i++) {\n+      ArrayKlass* ak = _array_klasses->at(i);\n+      _dynamic_archive_array_klasses->at_put(i, ak);\n+      builder->write_pointer_in_buffer(_dynamic_archive_array_klasses->adr_at(i), ak);\n+    }\n+  }\n+}\n+\n+void DynamicArchive::setup_array_klasses() {\n+  if (_dynamic_archive_array_klasses != nullptr) {\n+    for (int i = 0; i < _dynamic_archive_array_klasses->length(); i++) {\n+      ArrayKlass* ak = _dynamic_archive_array_klasses->at(i);\n+      ArrayKlass* sav_ak = ak;\n+      SignatureStream ss(ak->name(), false);\n+      int ndims = ss.skip_array_prefix();  \/\/ skip all '['s, has_envelope() requires it.\n+      BasicType t = ss.type();\n+      bool is_obj_array = ss.has_envelope();\n+      Klass* bk = nullptr;\n+      if (is_obj_array) {\n+        bk = ObjArrayKlass::cast(ak)->bottom_klass();\n+        assert(MetaspaceShared::is_shared_static((void*)bk), \"bottom_klass should be in static archive\");\n+      }\n+      if (ak->dimension() > 1) {\n+        Klass* higher_dim = nullptr;\n+        while (ak->dimension() > 1) {\n+          if (ak->dimension() == 2) {\n+            \/\/ Save the two-dimensional array for setting up primitive array.\n+            higher_dim = ak;\n+          }\n+          Klass* ld = ak->lower_dimension();\n+          assert(ld != nullptr, \"unexpected null lower_dimension klass\");\n+          assert(MetaspaceShared::is_in_shared_metaspace((void*)ld), \"lower_dimension klass should be in CDS archive\");\n+          ld = ArrayKlass::cast(ld)->lower_dimension();\n+          if (ld != nullptr) {\n+            ak = ArrayKlass::cast(ld);\n+          }  else {\n+            break;\n+          }\n+        }\n+        if (is_obj_array) {\n+          assert(ak->dimension() >= 1, \"sanity\");\n+          int target_dim = ak->dimension() - 1;\n+          assert(target_dim >= 0, \"sanity\");\n+          if (target_dim == 0) {\n+            \/\/ Point InstanceKlass::_array_klasses to the one-dimensional archived ObjArrayKlass\n+            InstanceKlass* ik = InstanceKlass::cast(bk);\n+            ik->release_set_array_klasses(ObjArrayKlass::cast(ak));\n+          } else {\n+            ObjArrayKlass* fixup_oak = ObjArrayKlass::cast(bk->array_klass_or_null(target_dim));\n+            assert(fixup_oak != nullptr, \"sanity\");\n+            assert(MetaspaceShared::is_shared_static((void*)fixup_oak),\n+              \"ObjArrayKlass to be fixed should be in static CDS archive\");\n+            fixup_oak->set_higher_dimension(ak);\n+          }\n+        } else {\n+          if (is_java_primitive(t)) {\n+            \/\/ Setup primitive array - obtain the equivalent of a \"bottom_klass\" of a primitive array.\n+            Klass* k = Universe::typeArrayKlassObj(t);\n+            \/\/ A one-dimensional primitive array should exist in the static CDS archive.\n+            assert(ArrayKlass::cast(k)->dimension() == 1, \"expecting one-dimension primitive array klass\");\n+            assert(MetaspaceShared::is_shared_static((void*)k),\n+              \"one-dimension primitive array klass should be in static CDS archive\");\n+            if (ArrayKlass::cast(k)->higher_dimension() == nullptr) {\n+              \/\/ Point _higher_dimension to the archived array.\n+              ArrayKlass::cast(k)->set_higher_dimension(higher_dim);\n+            }\n+          }\n+        }\n+      } else {\n+        assert(ak->dimension() == 1, \"must be\");\n+        assert(ak->lower_dimension() == nullptr, \"unexpected non-null lower_dimension klass\");\n+        assert(is_obj_array, \"sanity\");\n+        \/\/ Point InstanceKlass::_array_klasses to the one-dimensional archived ObjArrayKlass\n+        InstanceKlass* ik = InstanceKlass::cast(bk);\n+        ik->release_set_array_klasses(ObjArrayKlass::cast(ak));\n+      }\n+    }\n+    log_debug(cds)(\"Total array klasses read from dynamic archive: %d\", _dynamic_archive_array_klasses->length());\n+  }\n+}\n+\n+void DynamicArchive::serialize_array_klasses(SerializeClosure* soc) {\n+  soc->do_ptr(&_dynamic_archive_array_klasses);\n+}\n+\n+void DynamicArchive::make_array_klasses_shareable() {\n+  if (_array_klasses != nullptr) {\n+    int num_array_klasses = _array_klasses->length();\n+    for (int i = 0; i < num_array_klasses; i++) {\n+      ArrayKlass* k = ArchiveBuilder::current()->get_buffered_addr(_array_klasses->at(i));\n+      k->remove_unshareable_info();\n+    }\n+  }\n+}\n+\n+void DynamicArchive::post_dump() {\n+  if (_array_klasses != nullptr) {\n+    delete _array_klasses;\n+  }\n+}\n+\n+int DynamicArchive::num_array_klasses() {\n+  return _array_klasses != nullptr ? _array_klasses->length() : 0;\n+}\n+\n+void DynamicArchive::log_array_class_load(JavaThread* thread, Klass* k) {\n+  LogTarget(Debug, class, load, cds) lt;\n+  if (lt.is_enabled() && MetaspaceShared::is_in_shared_metaspace((void*)k)) {\n+    LogStream ls(lt);\n+    ResourceMark rm(thread);\n+    ls.print(\"%s\", k->external_name());\n+    if (MetaspaceShared::is_shared_dynamic((void*)k)) {\n+      ls.print(\" source: shared objects file (top)\");\n+    } else {\n+      ls.print(\" source: shared objects file\");\n+    }\n+    ls.cr();\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/cds\/dynamicArchive.cpp","additions":164,"deletions":2,"binary":false,"changes":166,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"oops\/array.hpp\"\n@@ -35,0 +36,1 @@\n+#include \"utilities\/growableArray.hpp\"\n@@ -61,0 +63,3 @@\n+private:\n+  static GrowableArray<ArrayKlass*>* _array_klasses;\n+  static Array<ArrayKlass*>* _dynamic_archive_array_klasses;\n@@ -67,0 +72,8 @@\n+  static void dump_array_klasses();\n+  static void setup_array_klasses();\n+  static void append_array_klass(ArrayKlass* oak);\n+  static void serialize_array_klasses(SerializeClosure* soc);\n+  static void make_array_klasses_shareable();\n+  static void post_dump();\n+  static int  num_array_klasses();\n+  static void log_array_class_load(JavaThread* thread, Klass* k);\n","filename":"src\/hotspot\/share\/cds\/dynamicArchive.hpp","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+#include \"cds\/dynamicArchive.hpp\"\n@@ -471,0 +472,2 @@\n+\n+  virtual void iterate_primitive_array_klasses(MetaspaceClosure* it) { ShouldNotReachHere(); }\n@@ -876,0 +879,8 @@\n+bool MetaspaceShared::is_shared_static(void* p) {\n+  if (is_in_shared_metaspace(p) && !is_shared_dynamic(p)) {\n+    return true;\n+  } else {\n+    return false;\n+  }\n+}\n+\n@@ -1472,2 +1483,2 @@\n-    SymbolTable::serialize_shared_table_header(&rc, false);\n-    SystemDictionaryShared::serialize_dictionary_headers(&rc, false);\n+    ArchiveBuilder::serialize_dynamic_archivable_items(&rc);\n+    DynamicArchive::setup_array_klasses();\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":13,"deletions":2,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -105,0 +105,1 @@\n+  static bool is_shared_static(void* p) NOT_CDS_RETURN_(false);\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -189,1 +189,7 @@\n-  assert(!k->is_shared(), \"sanity\");\n+#ifdef ASSERT\n+  if (DumpSharedSpaces) {\n+    assert(!k->is_shared(), \"sanity\");\n+  } else {\n+    assert(DynamicDumpSharedSpaces, \"sanity\");\n+  }\n+#endif\n@@ -191,1 +197,5 @@\n-  assert(info != nullptr, \"must be\");\n+#ifdef ASSERT\n+  if (!k->is_shared()) {\n+    assert(info != nullptr, \"must be\");\n+  }\n+#endif\n@@ -651,1 +661,5 @@\n-  return p->is_excluded();\n+  if (p != nullptr) {\n+    return p->is_excluded();\n+  } else {\n+    return false;\n+  }\n","filename":"src\/hotspot\/share\/classfile\/systemDictionaryShared.cpp","additions":17,"deletions":3,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -47,0 +47,3 @@\n+#if INCLUDE_CDS\n+#include \"cds\/dynamicArchive.hpp\"\n+#endif\n@@ -315,1 +318,8 @@\n-  if (dim == n) return this;\n+  if (dim == n) {\n+#if INCLUDE_CDS\n+  if (UseSharedSpaces) {\n+    DynamicArchive::log_array_class_load(THREAD, this);\n+  }\n+#endif\n+    return this;\n+  }\n","filename":"src\/hotspot\/share\/oops\/objArrayKlass.cpp","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,1 +50,96 @@\n-        dumpAndRun(topArchiveName, \"-Xlog:cds+dynamic=debug\", \"-cp\", appJar, mainClass);\n+        \/\/ Case 1\n+        \/\/ Create a dynamic archive with the ArrayKlassesApp app class and its\n+        \/\/ array classes.\n+        dump2(null, topArchiveName,\n+              \"-Xlog:cds+dynamic=debug,cds+class=debug\",\n+              \"-cp\", appJar, mainClass)\n+              .assertNormalExit(output -> {\n+                     output\/\/.shouldMatch(\"cds.class.*klasses.*array \\\\[LArrayKlassesApp;\")\n+                           .shouldMatch(\"cds.class.*klasses.*array \\\\[\\\\[\\\\[LArrayKlassesApp;\");\n+                 });\n+\n+        \/\/ Case 1\n+        \/\/ At runtime , the ArrayKlasesApp and its array class should be loaded\n+        \/\/ from the dynamic archive.\n+        run2(null, topArchiveName,\n+             \"-Xlog:class+load,class+load+cds=debug,cds+dynamic=debug,cds=debug\",\n+             \"-cp\", appJar, mainClass)\n+             .assertNormalExit(output -> {\n+                     output.shouldContain(\"ArrayKlassesApp source: shared objects file (top)\")\n+                           .shouldContain(\"[[[LArrayKlassesApp; source: shared objects file (top)\")\n+                           .shouldHaveExitValue(0);\n+                 });\n+\n+        \/\/ Case 2\n+        \/\/ Create a dynamic archive with the array classes of java\/util\/Date which\n+        \/\/ is in the default CDS archive.\n+        topArchiveName = getNewArchiveName();\n+        dump2(null, topArchiveName,\n+              \"-Xlog:class+load,cds+dynamic=debug,cds+class=debug\",\n+              \"-cp\", appJar, mainClass, \"system\")\n+              .assertNormalExit(output -> {\n+                     output.shouldContain(\"java.util.Date source: shared objects file\")\n+                           .shouldMatch(\"cds.class.*klasses.*array \\\\[Ljava.util.Date;\")\n+                           .shouldMatch(\"cds.class.*klasses.*array \\\\[\\\\[Ljava.util.Date;\")\n+                           .shouldMatch(\"cds.class.*klasses.*array \\\\[\\\\[\\\\[Ljava.util.Date;\");\n+                 });\n+\n+        \/\/ Case 2\n+        \/\/ At runtime, the java\/util\/Date class should be loaded from the default\n+        \/\/ CDS archive; its array class should be loaded from the dynamic archive.\n+        run2(null, topArchiveName,\n+             \"-Xlog:class+load,class+load+cds=debug,cds+dynamic=debug,cds=debug\",\n+             \"-cp\", appJar, mainClass, \"system\")\n+             .assertNormalExit(output -> {\n+                     output.shouldContain(\"java.util.Date source: shared objects file\")\n+                           .shouldContain(\"[[[Ljava.util.Date; source: shared objects file (top)\")\n+                           .shouldHaveExitValue(0);\n+                 });\n+\n+        \/\/ Case 3\n+        \/\/ Create a dynamic archive with primitive arrays [[J and [[[J with [J\n+        \/\/ already in the default CDS archive\n+        topArchiveName = getNewArchiveName();\n+        dump2(null, topArchiveName,\n+              \"-Xlog:class+load,cds+dynamic=debug,cds+class=debug\",\n+              \"-cp\", appJar, mainClass, \"primitive\")\n+              .assertNormalExit(output -> {\n+                     output.shouldMatch(\"cds.class.*klasses.*array \\\\[\\\\[J\")\n+                           .shouldMatch(\"cds.class.*klasses.*array \\\\[\\\\[\\\\[J\");\n+                 });\n+\n+        \/\/ Case 3\n+        \/\/ At runtime, the [J should be loaded from the default CDS archive;\n+        \/\/ the higher-dimension array should be loaded from the dynamic archive.\n+        run2(null, topArchiveName,\n+             \"-Xlog:class+load,class+load+cds=debug,cds+dynamic=debug,cds=debug\",\n+             \"-cp\", appJar, mainClass, \"primitive\")\n+             .assertNormalExit(output -> {\n+                     output.shouldContain(\"[J source: shared objects file\")\n+                           .shouldContain(\"[[[J source: shared objects file (top)\")\n+                           .shouldHaveExitValue(0);\n+                 });\n+\n+        \/\/ Case 4\n+        \/\/ Create a dynamic archive with 2-, 3- and 4-dimension arrays of java\/lang\/Integer.\n+        \/\/ The java\/lang\/Integer class and the 1-dimension array is in the default archive.\n+        topArchiveName = getNewArchiveName();\n+        dump2(null, topArchiveName,\n+              \"-Xlog:class+load,cds+dynamic=debug,cds+class=debug\",\n+              \"-cp\", appJar, mainClass, \"integer-array\")\n+              .assertNormalExit(output -> {\n+                     output.shouldMatch(\"cds.class.*klasses.*array \\\\[\\\\[Ljava.lang.Integer;\")\n+                           .shouldMatch(\"cds.class.*klasses.*array \\\\[\\\\[\\\\[Ljava.lang.Integer;\")\n+                           .shouldMatch(\"cds.class.*klasses.*array \\\\[\\\\[\\\\[\\\\[Ljava.lang.Integer;\");\n+                 });\n+\n+        \/\/ Case 4\n+        \/\/ At runtime, the 4-dimension array of java\/lang\/Integer should be\n+        \/\/ loaded from the dynamic archive.\n+        run2(null, topArchiveName,\n+             \"-Xlog:class+load,class+load+cds=debug,cds+dynamic=debug,cds=debug\",\n+             \"-cp\", appJar, mainClass, \"integer-array\")\n+             .assertNormalExit(output -> {\n+                     output.shouldContain(\"[[[[Ljava.lang.Integer; source: shared objects file (top)\")\n+                           .shouldHaveExitValue(0);\n+                 });\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/ArrayKlasses.java","additions":97,"deletions":2,"binary":false,"changes":99,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,0 +25,3 @@\n+import java.lang.reflect.Array;\n+import java.util.Date;\n+\n@@ -27,4 +30,39 @@\n-        ArrayKlassesApp[][] array = new ArrayKlassesApp[1][2];\n-        for (int i=0; i<1; i++) {\n-            for (int j=0; j<2; j++) {\n-                array[i][j] = new ArrayKlassesApp();\n+        if (args.length == 1) {\n+            if (args[0].equals(\"system\")) {\n+                Date[][][] array = new Date[1][2][2];\n+                int count = 0;\n+                for (int i=0; i<1; i++) {\n+                    for (int j=0; j<2; j++) {\n+                        for (int k=0; k<2; k++) {\n+                            array[i][j][k] = new Date();\n+                            count++;\n+                            array[i][j][k].setTime(20000 * count);\n+                        }\n+                    }\n+                }\n+            } else if (args[0].equals(\"primitive\")) {\n+                long[][][] larray = new long[1][2][2];\n+                long lcount = 0;\n+                for (int i=0; i<1; i++) {\n+                    for (int j=0; j<2; j++) {\n+                        for (int k=0; k<2; k++) {\n+                            lcount++;\n+                            larray[i][j][k] = lcount;\n+                        }\n+                    }\n+                }\n+            } else if (args[0].equals(\"integer-array\")) {\n+                Integer[][][][] iarray = new Integer[4][4][4][4];\n+                int count = 0;\n+                for (int i = 0; i < 4; i++) {\n+                    for (int j = 0; j < 4; j++) {\n+                        for (int k = 0; k < 4; k++) {\n+                            for (int l = 0; l < 4; l++) {\n+                                count++;\n+                                iarray[i][j][k][l] = new Integer(count);\n+                            }\n+                        }\n+                    }\n+                }\n+                System.out.println(iarray);\n+                System.out.println(iarray.getClass());\n@@ -32,0 +70,5 @@\n+        } else {\n+            Object x = Array.newInstance(ArrayKlassesApp.class, 3,3,3);\n+            System.out.println(x);\n+            System.out.println(x.getClass());\n+            System.out.println(Array.getLength(x));\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/test-classes\/ArrayKlassesApp.java","additions":48,"deletions":5,"binary":false,"changes":53,"status":"modified"}]}