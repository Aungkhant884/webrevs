{"files":[{"patch":"@@ -31,0 +31,1 @@\n+#include \"cds\/dynamicArchive.hpp\"\n@@ -523,4 +524,0 @@\n-    if (DynamicDumpSharedSpaces) {\n-      \/\/ Don't support archiving of array klasses for now (WHY???)\n-      return true;\n-    }\n@@ -528,1 +525,5 @@\n-    if (bottom->is_instance_klass()) {\n+    if (MetaspaceShared::is_shared_static(bottom)) {\n+      \/\/ The bottom class is in the static archive so it's clearly not excluded.\n+      assert(DynamicDumpSharedSpaces, \"sanity\");\n+      return false;\n+    } else if (bottom->is_instance_klass()) {\n@@ -795,0 +796,8 @@\n+\n+  DynamicArchive::make_array_klasses_shareable();\n+}\n+\n+void ArchiveBuilder::serialize_dynamic_archivable_items(SerializeClosure* soc) {\n+  SymbolTable::serialize_shared_table_header(soc, false);\n+  SystemDictionaryShared::serialize_dictionary_headers(soc, false);\n+  DynamicArchive::serialize_array_klasses(soc);\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.cpp","additions":14,"deletions":5,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -344,0 +344,1 @@\n+  static void serialize_dynamic_archivable_items(SerializeClosure* soc);\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -91,0 +91,1 @@\n+  void gather_array_klasses();\n@@ -121,0 +122,1 @@\n+    gather_array_klasses();\n@@ -142,0 +144,1 @@\n+      DynamicArchive::dump_array_klasses();\n@@ -145,2 +148,1 @@\n-      SymbolTable::serialize_shared_table_header(&wc, false);\n-      SystemDictionaryShared::serialize_dictionary_headers(&wc, false);\n+      ArchiveBuilder::serialize_dynamic_archivable_items(&wc);\n@@ -163,0 +165,1 @@\n+    DynamicArchive::post_dump();\n@@ -173,0 +176,24 @@\n+    iterate_primitive_array_klasses(it);\n+  }\n+\n+  void iterate_primitive_array_klasses(MetaspaceClosure* it) {\n+    for (int i = T_BOOLEAN; i <= T_LONG; i++) {\n+      assert(is_java_primitive((BasicType)i), \"sanity\");\n+      Klass* k = Universe::typeArrayKlassObj((BasicType)i);  \/\/ this give you \"[I\", etc\n+      assert(MetaspaceShared::is_shared_static((void*)k),\n+        \"one-dimensional primitive array should be in static archive\");\n+      ArrayKlass* ak = ArrayKlass::cast(k);\n+      while (ak != nullptr && ak->is_shared()) {\n+        Klass* next_k = ak->array_klass_or_null();\n+        if (next_k != nullptr) {\n+          ak = ArrayKlass::cast(next_k);\n+        } else {\n+          ak = nullptr;\n+        }\n+      }\n+      if (ak != nullptr) {\n+        assert(ak->dimension() > 1, \"sanity\");\n+        \/\/ this is the lowest dimension that's not in the static archive\n+        it->push(&ak);\n+      }\n+    }\n@@ -331,0 +358,20 @@\n+void DynamicArchiveBuilder::gather_array_klasses() {\n+  for (int i = 0; i < klasses()->length(); i++) {\n+    if (klasses()->at(i)->is_objArray_klass()) {\n+      ObjArrayKlass* oak = ObjArrayKlass::cast(klasses()->at(i));\n+      Klass* elem = oak->element_klass();\n+      if (MetaspaceShared::is_shared_static(elem)) {\n+        \/\/ Only capture the array klass whose element_klass is in the static archive.\n+        \/\/ During run time, setup (see DynamicArchive::setup_array_klasses()) is needed\n+        \/\/ so that the element_klass can find its array klasses from the dynamic archive.\n+        DynamicArchive::append_array_klass(oak);\n+      } else {\n+        \/\/ The element_klass and its array klasses are in the same archive.\n+        assert(!MetaspaceShared::is_shared_static(oak),\n+          \"we should not gather klasses that are already in the static archive\");\n+      }\n+    }\n+  }\n+  log_debug(cds)(\"Total array klasses gathered for dynamic archive: %d\", DynamicArchive::num_array_klasses());\n+}\n+\n@@ -352,0 +399,72 @@\n+GrowableArray<ObjArrayKlass*>* DynamicArchive::_array_klasses = nullptr;\n+Array<ObjArrayKlass*>* DynamicArchive::_dynamic_archive_array_klasses = nullptr;\n+\n+void DynamicArchive::append_array_klass(ObjArrayKlass* ak) {\n+  if (_array_klasses == nullptr) {\n+    _array_klasses = new (mtClassShared) GrowableArray<ObjArrayKlass*>(50, mtClassShared);\n+  }\n+  _array_klasses->append(ak);\n+}\n+\n+void DynamicArchive::dump_array_klasses() {\n+  assert(DynamicDumpSharedSpaces, \"DynamicDumpSharedSpaces only\");\n+  if (_array_klasses != nullptr) {\n+    ArchiveBuilder* builder = ArchiveBuilder::current();\n+    int num_array_klasses = _array_klasses->length();\n+    _dynamic_archive_array_klasses =\n+        ArchiveBuilder::new_ro_array<ObjArrayKlass*>(num_array_klasses);\n+    for (int i = 0; i < num_array_klasses; i++) {\n+      ObjArrayKlass* oak = _array_klasses->at(i);\n+      _dynamic_archive_array_klasses->at_put(i, oak);\n+      builder->write_pointer_in_buffer(_dynamic_archive_array_klasses->adr_at(i), oak);\n+    }\n+  }\n+}\n+\n+void DynamicArchive::setup_array_klasses() {\n+  if (_dynamic_archive_array_klasses != nullptr) {\n+    for (int i = 0; i < _dynamic_archive_array_klasses->length(); i++) {\n+      ObjArrayKlass* oak = _dynamic_archive_array_klasses->at(i);\n+      assert(!oak->is_typeArray_klass(), \"all type array classes must be in static archive\");\n+\n+      Klass* elm = oak->element_klass();\n+      assert(MetaspaceShared::is_shared_static((void*)elm), \"must be\");\n+\n+      if (elm->is_instance_klass()) {\n+        assert(InstanceKlass::cast(elm)->array_klasses() == nullptr, \"must be\");\n+        InstanceKlass::cast(elm)->set_array_klasses(oak);\n+      } else {\n+        assert(elm->is_array_klass(), \"sanity\");\n+        assert(ArrayKlass::cast(elm)->higher_dimension() == nullptr, \"must be\");\n+        ArrayKlass::cast(elm)->set_higher_dimension(oak);\n+      }\n+    }\n+    log_debug(cds)(\"Total array klasses read from dynamic archive: %d\", _dynamic_archive_array_klasses->length());\n+  }\n+}\n+\n+void DynamicArchive::serialize_array_klasses(SerializeClosure* soc) {\n+  soc->do_ptr(&_dynamic_archive_array_klasses);\n+}\n+\n+void DynamicArchive::make_array_klasses_shareable() {\n+  if (_array_klasses != nullptr) {\n+    int num_array_klasses = _array_klasses->length();\n+    for (int i = 0; i < num_array_klasses; i++) {\n+      ObjArrayKlass* k = ArchiveBuilder::current()->get_buffered_addr(_array_klasses->at(i));\n+      k->remove_unshareable_info();\n+    }\n+  }\n+}\n+\n+void DynamicArchive::post_dump() {\n+  if (_array_klasses != nullptr) {\n+    delete _array_klasses;\n+    _array_klasses = nullptr;\n+  }\n+}\n+\n+int DynamicArchive::num_array_klasses() {\n+  return _array_klasses != nullptr ? _array_klasses->length() : 0;\n+}\n+\n","filename":"src\/hotspot\/share\/cds\/dynamicArchive.cpp","additions":121,"deletions":2,"binary":false,"changes":123,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"oops\/array.hpp\"\n@@ -35,0 +36,1 @@\n+#include \"utilities\/growableArray.hpp\"\n@@ -61,0 +63,3 @@\n+private:\n+  static GrowableArray<ObjArrayKlass*>* _array_klasses;\n+  static Array<ObjArrayKlass*>* _dynamic_archive_array_klasses;\n@@ -67,0 +72,7 @@\n+  static void dump_array_klasses();\n+  static void setup_array_klasses();\n+  static void append_array_klass(ObjArrayKlass* oak);\n+  static void serialize_array_klasses(SerializeClosure* soc);\n+  static void make_array_klasses_shareable();\n+  static void post_dump();\n+  static int  num_array_klasses();\n","filename":"src\/hotspot\/share\/cds\/dynamicArchive.hpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+#include \"cds\/dynamicArchive.hpp\"\n@@ -470,0 +471,1 @@\n+\n@@ -873,0 +875,8 @@\n+bool MetaspaceShared::is_shared_static(void* p) {\n+  if (is_in_shared_metaspace(p) && !is_shared_dynamic(p)) {\n+    return true;\n+  } else {\n+    return false;\n+  }\n+}\n+\n@@ -1469,2 +1479,2 @@\n-    SymbolTable::serialize_shared_table_header(&rc, false);\n-    SystemDictionaryShared::serialize_dictionary_headers(&rc, false);\n+    ArchiveBuilder::serialize_dynamic_archivable_items(&rc);\n+    DynamicArchive::setup_array_klasses();\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":12,"deletions":2,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -104,0 +104,1 @@\n+  static bool is_shared_static(void* p) NOT_CDS_RETURN_(false);\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -189,1 +189,7 @@\n-  assert(!k->is_shared(), \"sanity\");\n+#ifdef ASSERT\n+  if (DumpSharedSpaces) {\n+    assert(!k->is_shared(), \"sanity\");\n+  } else {\n+    assert(DynamicDumpSharedSpaces, \"sanity\");\n+  }\n+#endif\n@@ -191,1 +197,5 @@\n-  assert(info != nullptr, \"must be\");\n+#ifdef ASSERT\n+  if (!k->is_shared()) {\n+    assert(info != nullptr, \"must be\");\n+  }\n+#endif\n@@ -651,1 +661,5 @@\n-  return p->is_excluded();\n+  if (p != nullptr) {\n+    return p->is_excluded();\n+  } else {\n+    return false;\n+  }\n","filename":"src\/hotspot\/share\/classfile\/systemDictionaryShared.cpp","additions":17,"deletions":3,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+  LOG_TAG(array) \\\n","filename":"src\/hotspot\/share\/logging\/logTag.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"cds\/metaspaceShared.hpp\"\n@@ -99,0 +100,1 @@\n+  log_array_class_load(this);\n@@ -182,0 +184,1 @@\n+    log_array_class_load(ak);\n@@ -197,0 +200,15 @@\n+void ArrayKlass::log_array_class_load(Klass* k) {\n+  LogTarget(Debug, class, load, array) lt;\n+  if (lt.is_enabled()) {\n+    LogStream ls(lt);\n+    ResourceMark rm;\n+    ls.print(\"%s\", k->name()->as_klass_external_name());\n+    if (MetaspaceShared::is_shared_dynamic((void*)k)) {\n+      ls.print(\" source: shared objects file (top)\");\n+    } else if (MetaspaceShared::is_shared_static((void*)k)) {\n+      ls.print(\" source: shared objects file\");\n+    }\n+    ls.cr();\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/oops\/arrayKlass.cpp","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -126,0 +126,1 @@\n+  void log_array_class_load(Klass* k);\n","filename":"src\/hotspot\/share\/oops\/arrayKlass.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -350,0 +350,1 @@\n+  void set_array_klasses(ObjArrayKlass* k) { _array_klasses = k; }\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,1 +50,104 @@\n-        dumpAndRun(topArchiveName, \"-Xlog:cds+dynamic=debug\", \"-cp\", appJar, mainClass);\n+        \/\/ Case 1\n+        \/\/ Create a dynamic archive with the ArrayKlassesApp app class and its\n+        \/\/ array classes.\n+        dump2(null, topArchiveName,\n+              \"-Xlog:cds+dynamic=debug,cds+class=debug\",\n+              \"-cp\", appJar, mainClass)\n+              .assertNormalExit(output -> {\n+                     output.shouldMatch(\"cds.class.*klasses.*array \\\\[LArrayKlassesApp;\")\n+                           .shouldMatch(\"cds.class.*klasses.*array \\\\[\\\\[LArrayKlassesApp;\")\n+                           .shouldMatch(\"cds.class.*klasses.*array \\\\[\\\\[\\\\[LArrayKlassesApp;\");\n+                 });\n+\n+        \/\/ Case 1\n+        \/\/ At runtime , the ArrayKlasesApp and its array class should be loaded\n+        \/\/ from the dynamic archive.\n+        run2(null, topArchiveName,\n+             \"-Xlog:class+load,class+load+array=debug,cds+dynamic=debug,cds=debug\",\n+             \"-cp\", appJar, mainClass)\n+             .assertNormalExit(output -> {\n+                     output.shouldContain(\"ArrayKlassesApp source: shared objects file (top)\")\n+                           .shouldContain(\"[LArrayKlassesApp; source: shared objects file (top)\")\n+                           .shouldContain(\"[[LArrayKlassesApp; source: shared objects file (top)\")\n+                           .shouldContain(\"[[[LArrayKlassesApp; source: shared objects file (top)\")\n+                           .shouldHaveExitValue(0);\n+                 });\n+\n+        \/\/ Case 2\n+        \/\/ Create a dynamic archive with the array classes of java\/util\/Date which\n+        \/\/ is in the default CDS archive.\n+        topArchiveName = getNewArchiveName();\n+        dump2(null, topArchiveName,\n+              \"-Xlog:class+load,cds+dynamic=debug,cds+class=debug\",\n+              \"-cp\", appJar, mainClass, \"system\")\n+              .assertNormalExit(output -> {\n+                     output.shouldContain(\"java.util.Date source: shared objects file\")\n+                           .shouldMatch(\"cds.class.*klasses.*array \\\\[Ljava.util.Date;\")\n+                           .shouldMatch(\"cds.class.*klasses.*array \\\\[\\\\[Ljava.util.Date;\")\n+                           .shouldMatch(\"cds.class.*klasses.*array \\\\[\\\\[\\\\[Ljava.util.Date;\");\n+                 });\n+\n+        \/\/ Case 2\n+        \/\/ At runtime, the java\/util\/Date class should be loaded from the default\n+        \/\/ CDS archive; its array class should be loaded from the dynamic archive.\n+        run2(null, topArchiveName,\n+             \"-Xlog:class+load,class+load+array=debug,cds+dynamic=debug,cds=debug\",\n+             \"-cp\", appJar, mainClass, \"system\")\n+             .assertNormalExit(output -> {\n+                     output.shouldContain(\"java.util.Date source: shared objects file\")\n+                           .shouldContain(\"[Ljava.util.Date; source: shared objects file (top)\")\n+                           .shouldContain(\"[[Ljava.util.Date; source: shared objects file (top)\")\n+                           .shouldContain(\"[[[Ljava.util.Date; source: shared objects file (top)\")\n+                           .shouldHaveExitValue(0);\n+                 });\n+\n+        \/\/ Case 3\n+        \/\/ Create a dynamic archive with primitive arrays [[J and [[[J with [J\n+        \/\/ already in the default CDS archive\n+        topArchiveName = getNewArchiveName();\n+        dump2(null, topArchiveName,\n+              \"-Xlog:class+load,cds+dynamic=debug,cds+class=debug\",\n+              \"-cp\", appJar, mainClass, \"primitive\")\n+              .assertNormalExit(output -> {\n+                     output.shouldMatch(\"cds.class.*klasses.*array \\\\[\\\\[J\")\n+                           .shouldMatch(\"cds.class.*klasses.*array \\\\[\\\\[\\\\[J\");\n+                 });\n+\n+        \/\/ Case 3\n+        \/\/ At runtime, the [J should be loaded from the default CDS archive;\n+        \/\/ the higher-dimension array should be loaded from the dynamic archive.\n+        run2(null, topArchiveName,\n+             \"-Xlog:class+load,class+load+array=debug,cds+dynamic=debug,cds=debug\",\n+             \"-cp\", appJar, mainClass, \"primitive\")\n+             .assertNormalExit(output -> {\n+                     output.shouldContain(\"[J source: shared objects file\")\n+                           .shouldContain(\"[[J source: shared objects file (top)\")\n+                           .shouldContain(\"[[[J source: shared objects file (top)\")\n+                           .shouldHaveExitValue(0);\n+                 });\n+\n+        \/\/ Case 4\n+        \/\/ Create a dynamic archive with 2-, 3- and 4-dimension arrays of java\/lang\/Integer.\n+        \/\/ The java\/lang\/Integer class and the 1-dimension array is in the default archive.\n+        topArchiveName = getNewArchiveName();\n+        dump2(null, topArchiveName,\n+              \"-Xlog:class+load,cds+dynamic=debug,cds+class=debug\",\n+              \"-cp\", appJar, mainClass, \"integer-array\")\n+              .assertNormalExit(output -> {\n+                     output.shouldMatch(\"cds.class.*klasses.*array \\\\[\\\\[Ljava.lang.Integer;\")\n+                           .shouldMatch(\"cds.class.*klasses.*array \\\\[\\\\[\\\\[Ljava.lang.Integer;\")\n+                           .shouldMatch(\"cds.class.*klasses.*array \\\\[\\\\[\\\\[\\\\[Ljava.lang.Integer;\");\n+                 });\n+\n+        \/\/ Case 4\n+        \/\/ At runtime, the 4-dimension array of java\/lang\/Integer should be\n+        \/\/ loaded from the dynamic archive.\n+        run2(null, topArchiveName,\n+             \"-Xlog:class+load,class+load+array=debug,cds+dynamic=debug,cds=debug\",\n+             \"-cp\", appJar, mainClass, \"integer-array\")\n+             .assertNormalExit(output -> {\n+                     output.shouldContain(\"[[Ljava.lang.Integer; source: shared objects file (top)\")\n+                           .shouldContain(\"[[[Ljava.lang.Integer; source: shared objects file (top)\")\n+                           .shouldContain(\"[[[[Ljava.lang.Integer; source: shared objects file (top)\")\n+                           .shouldHaveExitValue(0);\n+                 });\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/ArrayKlasses.java","additions":105,"deletions":2,"binary":false,"changes":107,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,0 +25,3 @@\n+import java.lang.reflect.Array;\n+import java.util.Date;\n+\n@@ -27,4 +30,39 @@\n-        ArrayKlassesApp[][] array = new ArrayKlassesApp[1][2];\n-        for (int i=0; i<1; i++) {\n-            for (int j=0; j<2; j++) {\n-                array[i][j] = new ArrayKlassesApp();\n+        if (args.length == 1) {\n+            if (args[0].equals(\"system\")) {\n+                Date[][][] array = new Date[1][2][2];\n+                int count = 0;\n+                for (int i=0; i<1; i++) {\n+                    for (int j=0; j<2; j++) {\n+                        for (int k=0; k<2; k++) {\n+                            array[i][j][k] = new Date();\n+                            count++;\n+                            array[i][j][k].setTime(20000 * count);\n+                        }\n+                    }\n+                }\n+            } else if (args[0].equals(\"primitive\")) {\n+                long[][][] larray = new long[1][2][2];\n+                long lcount = 0;\n+                for (int i=0; i<1; i++) {\n+                    for (int j=0; j<2; j++) {\n+                        for (int k=0; k<2; k++) {\n+                            lcount++;\n+                            larray[i][j][k] = lcount;\n+                        }\n+                    }\n+                }\n+            } else if (args[0].equals(\"integer-array\")) {\n+                Integer[][][][] iarray = new Integer[4][4][4][4];\n+                int count = 0;\n+                for (int i = 0; i < 4; i++) {\n+                    for (int j = 0; j < 4; j++) {\n+                        for (int k = 0; k < 4; k++) {\n+                            for (int l = 0; l < 4; l++) {\n+                                count++;\n+                                iarray[i][j][k][l] = new Integer(count);\n+                            }\n+                        }\n+                    }\n+                }\n+                System.out.println(iarray);\n+                System.out.println(iarray.getClass());\n@@ -32,0 +70,5 @@\n+        } else {\n+            Object x = Array.newInstance(ArrayKlassesApp.class, 3,3,3);\n+            System.out.println(x);\n+            System.out.println(x.getClass());\n+            System.out.println(Array.getLength(x));\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/test-classes\/ArrayKlassesApp.java","additions":48,"deletions":5,"binary":false,"changes":53,"status":"modified"}]}