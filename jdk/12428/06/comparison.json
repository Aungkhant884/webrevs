{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1994, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1994, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -2194,0 +2194,129 @@\n+    \/**\n+     * Clamps the value to fit between min and max. If the value is less\n+     * than {@code min}, then {@code min} is returned. If the value is greater\n+     * than {@code max}, then {@code max} is returned. Otherwise, the original\n+     * value is returned.\n+     * <p>\n+     * While the original value of type long may not fit into the int type,\n+     * the bounds have the int type, so the result always fits the int type.\n+     * This allows to use method to safely cast long value to int with\n+     * saturation.\n+     *\n+     * @param value value to clamp\n+     * @param min minimal allowed value\n+     * @param max maximal allowed value\n+     * @return a clamped value that fits into {@code min..max} interval\n+     * @throws IllegalArgumentException if {@code min > max}\n+     *\n+     * @since 21\n+     *\/\n+    public static int clamp(long value, int min, int max) {\n+        if (min > max) {\n+            throw new IllegalArgumentException(min + \" > \" + max);\n+        }\n+        return (int) Math.min(max, Math.max(value, min));\n+    }\n+\n+    \/**\n+     * Clamps the value to fit between min and max. If the value is less\n+     * than {@code min}, then {@code min} is returned. If the value is greater\n+     * than {@code max}, then {@code max} is returned. Otherwise, the original\n+     * value is returned.\n+     *\n+     * @param value value to clamp\n+     * @param min minimal allowed value\n+     * @param max maximal allowed value\n+     * @return a clamped value that fits into {@code min..max} interval\n+     * @throws IllegalArgumentException if {@code min > max}\n+     *\n+     * @since 21\n+     *\/\n+    public static long clamp(long value, long min, long max) {\n+        if (min > max) {\n+            throw new IllegalArgumentException(min + \" > \" + max);\n+        }\n+        return Math.min(max, Math.max(value, min));\n+    }\n+\n+    \/**\n+     * Clamps the value to fit between min and max. If the value is less\n+     * than {@code min}, then {@code min} is returned. If the value is greater\n+     * than {@code max}, then {@code max} is returned. Otherwise, the original\n+     * value is returned. If value is NaN, the result is also NaN.\n+     * <p>\n+     * Unlike the numerical comparison operators, this method considers\n+     * negative zero to be strictly smaller than positive zero.\n+     * E.g., {@code clamp(-0.0, 0.0, 1.0)} returns 0.0.\n+     *\n+     * @param value value to clamp\n+     * @param min minimal allowed value\n+     * @param max maximal allowed value\n+     * @return a clamped value that fits into {@code min..max} interval\n+     * @throws IllegalArgumentException if either of {@code min} and {@code max}\n+     * arguments is NaN, or {@code min > max}, or {@code min} is +0.0, and\n+     * {@code max} is -0.0.\n+     *\n+     * @since 21\n+     *\/\n+    public static double clamp(double value, double min, double max) {\n+        \/\/ This unusual condition allows keeping only one branch\n+        \/\/ on common path when min < max and neither of them is NaN.\n+        \/\/ If min == max, we should additionally check for +0.0\/-0.0 case,\n+        \/\/ so we're still visiting the if statement.\n+        if (!(min < max)) { \/\/ min greater than, equal to, or unordered with respect to max; NaN values are unordered\n+            if (Double.isNaN(min)) {\n+                throw new IllegalArgumentException(\"min is NaN\");\n+            }\n+            if (Double.isNaN(max)) {\n+                throw new IllegalArgumentException(\"max is NaN\");\n+            }\n+            if (Double.compare(min, max) > 0) {\n+                throw new IllegalArgumentException(min + \" > \" + max);\n+            }\n+            \/\/ Fall-through if min and max are exactly equal (or min = -0.0 and max = +0.0)\n+            \/\/ and none of them is NaN\n+        }\n+        return Math.min(max, Math.max(value, min));\n+    }\n+\n+    \/**\n+     * Clamps the value to fit between min and max. If the value is less\n+     * than {@code min}, then {@code min} is returned. If the value is greater\n+     * than {@code max}, then {@code max} is returned. Otherwise, the original\n+     * value is returned. If value is NaN, the result is also NaN.\n+     * <p>\n+     * Unlike the numerical comparison operators, this method considers\n+     * negative zero to be strictly smaller than positive zero.\n+     * E.g., {@code clamp(-0.0f, 0.0f, 1.0f)} returns 0.0f.\n+     *\n+     * @param value value to clamp\n+     * @param min minimal allowed value\n+     * @param max maximal allowed value\n+     * @return a clamped value that fits into {@code min..max} interval\n+     * @throws IllegalArgumentException if either of {@code min} and {@code max}\n+     * arguments is NaN, or {@code min > max}, or {@code min} is +0.0f, and\n+     * {@code max} is -0.0f.\n+     *\n+     * @since 21\n+     *\/\n+    public static float clamp(float value, float min, float max) {\n+        \/\/ This unusual condition allows keeping only one branch\n+        \/\/ on common path when min < max and neither of them is NaN.\n+        \/\/ If min == max, we should additionally check for +0.0\/-0.0 case,\n+        \/\/ so we're still visiting the if statement.\n+        if (!(min < max)) { \/\/ min greater than, equal to, or unordered with respect to max; NaN values are unordered\n+            if (Float.isNaN(min)) {\n+                throw new IllegalArgumentException(\"min is NaN\");\n+            }\n+            if (Float.isNaN(max)) {\n+                throw new IllegalArgumentException(\"max is NaN\");\n+            }\n+            if (Float.compare(min, max) > 0) {\n+                throw new IllegalArgumentException(min + \" > \" + max);\n+            }\n+            \/\/ Fall-through if min and max are exactly equal (or min = -0.0 and max = +0.0)\n+            \/\/ and none of them is NaN\n+        }\n+        return Math.min(max, Math.max(value, min));\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Math.java","additions":130,"deletions":1,"binary":false,"changes":131,"status":"modified"},{"patch":"@@ -1760,0 +1760,89 @@\n+    \/**\n+     * Clamps the value to fit between min and max. If the value is less\n+     * than {@code min}, then {@code min} is returned. If the value is greater\n+     * than {@code max}, then {@code max} is returned. Otherwise, the original\n+     * value is returned.\n+     * <p>\n+     * While the original value of type long may not fit into the int type,\n+     * the bounds have the int type, so the result always fits the int type.\n+     * This allows to use method to safely cast long value to int with\n+     * saturation.\n+     *\n+     * @param value value to clamp\n+     * @param min minimal allowed value\n+     * @param max maximal allowed value\n+     * @return a clamped value that fits into {@code min..max} interval\n+     * @throws IllegalArgumentException if {@code min > max}\n+     *\n+     * @since 21\n+     *\/\n+    public static int clamp(long value, int min, int max) {\n+        return Math.clamp(value, min, max);\n+    }\n+\n+    \/**\n+     * Clamps the value to fit between min and max. If the value is less\n+     * than {@code min}, then {@code min} is returned. If the value is greater\n+     * than {@code max}, then {@code max} is returned. Otherwise, the original\n+     * value is returned.\n+     *\n+     * @param value value to clamp\n+     * @param min minimal allowed value\n+     * @param max maximal allowed value\n+     * @return a clamped value that fits into {@code min..max} interval\n+     * @throws IllegalArgumentException if {@code min > max}\n+     *\n+     * @since 21\n+     *\/\n+    public static long clamp(long value, long min, long max) {\n+        return Math.clamp(value, min, max);\n+    }\n+\n+    \/**\n+     * Clamps the value to fit between min and max. If the value is less\n+     * than {@code min}, then {@code min} is returned. If the value is greater\n+     * than {@code max}, then {@code max} is returned. Otherwise, the original\n+     * value is returned. If value is NaN, the result is also NaN.\n+     * <p>\n+     * Unlike the numerical comparison operators, this method considers\n+     * negative zero to be strictly smaller than positive zero.\n+     * E.g., {@code clamp(-0.0, 0.0, 1.0)} returns 0.0.\n+     *\n+     * @param value value to clamp\n+     * @param min minimal allowed value\n+     * @param max maximal allowed value\n+     * @return a clamped value that fits into {@code min..max} interval\n+     * @throws IllegalArgumentException if either of {@code min} and {@code max}\n+     * arguments is NaN, or {@code min > max}, or {@code min} is +0.0, and\n+     * {@code max} is -0.0.\n+     *\n+     * @since 21\n+     *\/\n+    public static double clamp(double value, double min, double max) {\n+        return Math.clamp(value, min, max);\n+    }\n+\n+    \/**\n+     * Clamps the value to fit between min and max. If the value is less\n+     * than {@code min}, then {@code min} is returned. If the value is greater\n+     * than {@code max}, then {@code max} is returned. Otherwise, the original\n+     * value is returned. If value is NaN, the result is also NaN.\n+     * <p>\n+     * Unlike the numerical comparison operators, this method considers\n+     * negative zero to be strictly smaller than positive zero.\n+     * E.g., {@code clamp(-0.0f, 0.0f, 1.0f)} returns 0.0f.\n+     *\n+     * @param value value to clamp\n+     * @param min minimal allowed value\n+     * @param max maximal allowed value\n+     * @return a clamped value that fits into {@code min..max} interval\n+     * @throws IllegalArgumentException if either of {@code min} and {@code max}\n+     * arguments is NaN, or {@code min > max}, or {@code min} is +0.0f, and\n+     * {@code max} is -0.0f.\n+     *\n+     * @since 21\n+     *\/\n+    public static float clamp(float value, float min, float max) {\n+        return Math.clamp(value, min, max);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StrictMath.java","additions":89,"deletions":0,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -0,0 +1,277 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+   @bug 8301226\n+   @summary Add clamp() methods to java.lang.Math\n+ *\/\n+\n+\n+public class Clamp {\n+    public static void main(String[] args) {\n+        int failures = 0;\n+\n+        failures += testIntClamp();\n+        failures += testLongClamp();\n+        failures += testDoubleClamp();\n+        failures += testFloatClamp();\n+\n+        if (failures > 0) {\n+            System.err.println(\"Testing clamp incurred \" + failures + \" failures.\");\n+            throw new RuntimeException();\n+        }\n+    }\n+\n+    private static int testIntClamp() {\n+        int failures = 0;\n+        long[][] tests = {\n+                {0, 1, 2, 1},\n+                {0, 0, 2, 0},\n+                {1, 0, 2, 1},\n+                {2, 0, 2, 2},\n+                {3, 0, 2, 2},\n+                {0, Integer.MIN_VALUE, Integer.MAX_VALUE, 0},\n+                {Integer.MIN_VALUE, Integer.MIN_VALUE, Integer.MAX_VALUE, Integer.MIN_VALUE},\n+                {Integer.MAX_VALUE, Integer.MIN_VALUE, Integer.MAX_VALUE, Integer.MAX_VALUE},\n+                {Long.MAX_VALUE, Integer.MIN_VALUE, Integer.MAX_VALUE, Integer.MAX_VALUE},\n+                {Long.MIN_VALUE, Integer.MIN_VALUE, Integer.MAX_VALUE, Integer.MIN_VALUE},\n+                {0, 1, 1, 1},\n+                {Long.MAX_VALUE, 1, 1, 1}\n+        };\n+        long[][] exceptionTests = {\n+                {1, 2, 0},\n+                {1, Integer.MAX_VALUE, Integer.MIN_VALUE}\n+        };\n+        for (long[] test : tests) {\n+            long value = test[0];\n+            int min = Math.toIntExact(test[1]);\n+            int max = Math.toIntExact(test[2]);\n+            int expected = Math.toIntExact(test[3]);\n+            failures += checkEquals(\"(int) Math.clamp(\" + value + \", \" + min + \", \" + max + \")\", Math.clamp(value, min, max), expected);\n+            failures += checkEquals(\"(int) StrictMath.clamp(\" + value + \", \" + min + \", \" + max + \")\", StrictMath.clamp(value, min, max), expected);\n+        }\n+        for (long[] test : exceptionTests) {\n+            long value = test[0];\n+            int min = Math.toIntExact(test[1]);\n+            int max = Math.toIntExact(test[2]);\n+            failures += checkIllegalArgumentException(\"(int) Math.clamp(\" + value + \", \" + min + \", \" + max + \")\",\n+                    () -> Math.clamp(value, min, max));\n+            failures += checkIllegalArgumentException(\"(int) StrictMath.clamp(\" + value + \", \" + min + \", \" + max + \")\",\n+                    () -> StrictMath.clamp(value, min, max));\n+        }\n+        return failures;\n+    }\n+\n+    private static int testLongClamp() {\n+        int failures = 0;\n+        long[][] tests = {\n+                {0L, 1L, 2L, 1L},\n+                {0L, 0L, 2L, 0L},\n+                {1L, 0L, 2L, 1L},\n+                {2L, 0L, 2L, 2L},\n+                {3L, 0L, 2L, 2L},\n+                {0L, Long.MIN_VALUE, Long.MAX_VALUE, 0},\n+                {Long.MIN_VALUE, Long.MIN_VALUE, Long.MAX_VALUE, Long.MIN_VALUE},\n+                {Long.MAX_VALUE, Long.MIN_VALUE, Long.MAX_VALUE, Long.MAX_VALUE},\n+                {0, 1, 1, 1},\n+                {Long.MAX_VALUE, 1, 1, 1}\n+        };\n+        long[][] exceptionTests = {\n+                {1L, 2L, 0L},\n+                {1, Long.MAX_VALUE, Long.MIN_VALUE}\n+        };\n+        for (long[] test : tests) {\n+            long value = test[0];\n+            long min = test[1];\n+            long max = test[2];\n+            long expected = test[3];\n+            failures += checkEquals(\"(long) Math.clamp(\" + value + \", \" + min + \", \" + max + \")\", Math.clamp(value, min, max), expected);\n+            failures += checkEquals(\"(long) StrictMath.clamp(\" + value + \", \" + min + \", \" + max + \")\", StrictMath.clamp(value, min, max), expected);\n+        }\n+        for (long[] test : exceptionTests) {\n+            long value = test[0];\n+            long min = test[1];\n+            long max = test[2];\n+            failures += checkIllegalArgumentException(\"(long) Math.clamp(\" + value + \", \" + min + \", \" + max + \")\",\n+                    () -> Math.clamp(value, min, max));\n+            failures += checkIllegalArgumentException(\"(long) StrictMath.clamp(\" + value + \", \" + min + \", \" + max + \")\",\n+                    () -> StrictMath.clamp(value, min, max));\n+        }\n+        return failures;\n+    }\n+\n+    private static int testDoubleClamp() {\n+        int failures = 0;\n+        double[][] tests = {\n+                \/\/ value, min, max, expected\n+                {-0.1, 0.0, 0.5, 0.0},\n+                {-0.0, 0.0, 0.5, 0.0},\n+                {0.0, 0.0, 0.5, 0.0},\n+                {Double.MIN_VALUE, 0.0, 0.5, Double.MIN_VALUE},\n+                {0.2, 0.0, 0.5, 0.2},\n+                {Math.nextDown(0.5), 0.0, 0.5, Math.nextDown(0.5)},\n+                {0.5, 0.0, 0.5, 0.5},\n+                {Math.nextUp(0.5), 0.0, 0.5, 0.5},\n+                {0.6, 0.0, 0.5, 0.5},\n+\n+                {Double.MAX_VALUE, 0.0, Double.POSITIVE_INFINITY, Double.MAX_VALUE},\n+                {Double.POSITIVE_INFINITY, 0.0, Double.MAX_VALUE, Double.MAX_VALUE},\n+                {-Double.MAX_VALUE, Double.NEGATIVE_INFINITY, 0.0, -Double.MAX_VALUE},\n+                {Double.NEGATIVE_INFINITY, -Double.MAX_VALUE, 0.0, -Double.MAX_VALUE},\n+\n+                {-1.0, -0.0, 0.0, -0.0},\n+                {-0.0, -0.0, 0.0, -0.0},\n+                {0.0, -0.0, 0.0, 0.0},\n+                {1.0, -0.0, 0.0, 0.0},\n+                {-1.0, 0.0, 0.0, 0.0},\n+                {-0.0, 0.0, 0.0, 0.0},\n+                {0.0, 0.0, 0.0, 0.0},\n+                {1.0, 0.0, 0.0, 0.0},\n+                {-1.0, -0.0, -0.0, -0.0},\n+                {-0.0, -0.0, -0.0, -0.0},\n+                {0.0, -0.0, -0.0, -0.0},\n+                {1.0, -0.0, -0.0, -0.0},\n+\n+                {Double.NaN, 0.0, 1.0, Double.NaN},\n+                {Double.NaN, Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY, Double.NaN}\n+        };\n+        double[][] exceptionTests = {\n+                \/\/ value, min, max\n+                {0.0, Double.NaN, Double.NaN},\n+                {0.0, 0.0, Double.NaN},\n+                {0.0, Double.NaN, 0.0},\n+                {Double.NaN, 1.0, 0.0},\n+                {0.0, 0.0, -0.0},\n+                {0.0, 1.0, -1.0}\n+        };\n+        for (double[] test : tests) {\n+            double value = test[0];\n+            double min = test[1];\n+            double max = test[2];\n+            double expected = test[3];\n+            failures += checkEquals(\"(double) Math.clamp(\" + value + \", \" + min + \", \" + max + \")\", Math.clamp(value, min, max), expected);\n+            failures += checkEquals(\"(double) StrictMath.clamp(\" + value + \", \" + min + \", \" + max + \")\", StrictMath.clamp(value, min, max), expected);\n+        }\n+        for (double[] test : exceptionTests) {\n+            double value = test[0];\n+            double min = test[1];\n+            double max = test[2];\n+            failures += checkIllegalArgumentException(\"(double) Math.clamp(\" + value + \", \" + min + \", \" + max + \")\",\n+                    () -> Math.clamp(value, min, max));\n+            failures += checkIllegalArgumentException(\"(double) StrictMath.clamp(\" + value + \", \" + min + \", \" + max + \")\",\n+                    () -> StrictMath.clamp(value, min, max));\n+        }\n+        return failures;\n+    }\n+\n+    private static int testFloatClamp() {\n+        int failures = 0;\n+        float[][] tests = {\n+                \/\/ value, min, max, expected\n+                {-0.1f, 0.0f, 0.5f, 0.0f},\n+                {-0.0f, 0.0f, 0.5f, 0.0f},\n+                {0.0f, 0.0f, 0.5f, 0.0f},\n+                {Float.MIN_VALUE, 0.0f, 0.5f, Float.MIN_VALUE},\n+                {0.2f, 0.0f, 0.5f, 0.2f},\n+                {Math.nextDown(0.5f), 0.0f, 0.5f, Math.nextDown(0.5f)},\n+                {0.5f, 0.0f, 0.5f, 0.5f},\n+                {Math.nextUp(0.5f), 0.0f, 0.5f, 0.5f},\n+                {0.6f, 0.0f, 0.5f, 0.5f},\n+\n+                {Float.MAX_VALUE, 0.0f, Float.POSITIVE_INFINITY, Float.MAX_VALUE},\n+                {Float.POSITIVE_INFINITY, 0.0f, Float.MAX_VALUE, Float.MAX_VALUE},\n+                {-Float.MAX_VALUE, Float.NEGATIVE_INFINITY, 0.0f, -Float.MAX_VALUE},\n+                {Float.NEGATIVE_INFINITY, -Float.MAX_VALUE, 0.0f, -Float.MAX_VALUE},\n+\n+                {-1.0f, -0.0f, 0.0f, -0.0f},\n+                {-0.0f, -0.0f, 0.0f, -0.0f},\n+                {0.0f, -0.0f, 0.0f, 0.0f},\n+                {1.0f, -0.0f, 0.0f, 0.0f},\n+                {-1.0f, 0.0f, 0.0f, 0.0f},\n+                {-0.0f, 0.0f, 0.0f, 0.0f},\n+                {0.0f, 0.0f, 0.0f, 0.0f},\n+                {1.0f, 0.0f, 0.0f, 0.0f},\n+                {-1.0f, -0.0f, -0.0f, -0.0f},\n+                {-0.0f, -0.0f, -0.0f, -0.0f},\n+                {0.0f, -0.0f, -0.0f, -0.0f},\n+                {1.0f, -0.0f, -0.0f, -0.0f},\n+\n+                {Float.NaN, 0.0f, 1.0f, Float.NaN},\n+                {Float.NaN, Float.NEGATIVE_INFINITY, Float.POSITIVE_INFINITY, Float.NaN}\n+        };\n+        float[][] exceptionTests = {\n+                \/\/ value, min, max\n+                {0.0f, Float.NaN, Float.NaN},\n+                {0.0f, 0.0f, Float.NaN},\n+                {0.0f, Float.NaN, 0.0f},\n+                {Float.NaN, 1.0f, 0.0f},\n+                {0.0f, 0.0f, -0.0f},\n+                {0.0f, 1.0f, -1.0f}\n+        };\n+        for (float[] test : tests) {\n+            float value = test[0];\n+            float min = test[1];\n+            float max = test[2];\n+            float expected = test[3];\n+            failures += checkEquals(\"(float) Math.clamp(\" + value + \", \" + min + \", \" + max + \")\", Math.clamp(value, min, max), expected);\n+            failures += checkEquals(\"(float) StrictMath.clamp(\" + value + \", \" + min + \", \" + max + \")\", StrictMath.clamp(value, min, max), expected);\n+        }\n+        for (float[] test : exceptionTests) {\n+            float value = test[0];\n+            float min = test[1];\n+            float max = test[2];\n+            failures += checkIllegalArgumentException(\"(float) Math.clamp(\" + value + \", \" + min + \", \" + max + \")\",\n+                    () -> Math.clamp(value, min, max));\n+            failures += checkIllegalArgumentException(\"(float) StrictMath.clamp(\" + value + \", \" + min + \", \" + max + \")\",\n+                    () -> StrictMath.clamp(value, min, max));\n+        }\n+        return failures;\n+    }\n+\n+    private static int checkIllegalArgumentException(String what, Runnable r) {\n+        try {\n+            r.run();\n+        }\n+        catch (IllegalArgumentException ex) {\n+            return 0;\n+        }\n+        System.err.println(what+\": missing expected exception\");\n+        return 1;\n+    }\n+\n+    private static int checkEquals(String what, double actual, double expected) {\n+        if (Double.doubleToLongBits(actual) != Double.doubleToLongBits(expected)) {\n+            System.err.println(what + \": expected = \" + expected + \"; actual = \" + actual);\n+            return 1;\n+        }\n+        return 0;\n+    }\n+\n+    private static int checkEquals(String what, long actual, long expected) {\n+        if (actual != expected) {\n+            System.err.println(what + \": expected = \" + expected + \"; actual = \" + actual);\n+            return 1;\n+        }\n+        return 0;\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/Math\/Clamp.java","additions":277,"deletions":0,"binary":false,"changes":277,"status":"added"}]}