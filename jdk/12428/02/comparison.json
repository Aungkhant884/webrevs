{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1994, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1994, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -2194,0 +2194,117 @@\n+    \/**\n+     * Clamps the value to fit between min and max. If the value is less\n+     * than {@code min}, then {@code min} is returned. If the value is greater\n+     * than {@code max}, then {@code max} is returned. Otherwise, the original\n+     * value is returned.\n+     * <p>\n+     * While the original value of type long may not fit into the int type,\n+     * the bounds have the int type, so the result always fits the int type.\n+     * This allows to use method to safely cast long value to int with\n+     * saturation.\n+     *\n+     * @param value value to clamp\n+     * @param min minimal allowed value\n+     * @param max maximal allowed value\n+     * @return a clamped value that fits into {@code min..max} interval\n+     * @throws IllegalArgumentException if {@code min > max}\n+     *\n+     * @since 21\n+     *\/\n+    public static int clamp(long value, int min, int max) {\n+        if (min > max) {\n+            throw new IllegalArgumentException(min + \" > \" + max);\n+        }\n+        return (int) Math.min(max, Math.max(value, min));\n+    }\n+\n+    \/**\n+     * Clamps the value to fit between min and max. If the value is less\n+     * than {@code min}, then {@code min} is returned. If the value is greater\n+     * than {@code max}, then {@code max} is returned. Otherwise, the original\n+     * value is returned.\n+     *\n+     * @param value value to clamp\n+     * @param min minimal allowed value\n+     * @param max maximal allowed value\n+     * @return a clamped value that fits into {@code min..max} interval\n+     * @throws IllegalArgumentException if {@code min > max}\n+     *\n+     * @since 21\n+     *\/\n+    public static long clamp(long value, long min, long max) {\n+        if (min > max) {\n+            throw new IllegalArgumentException(min + \" > \" + max);\n+        }\n+        return Math.min(max, Math.max(value, min));\n+    }\n+\n+    \/**\n+     * Clamps the value to fit between min and max. If the value is less\n+     * than {@code min}, then {@code min} is returned. If the value is greater\n+     * than {@code max}, then {@code max} is returned. Otherwise, the original\n+     * value is returned. If value is NaN, the result is also NaN.\n+     * <p>\n+     * Unlike the numerical comparison operators, this method considers\n+     * negative zero to be strictly smaller than positive zero.\n+     * E.g., {@code clamp(-0.0, 0.0, 1.0)} returns 0.0.\n+     *\n+     * @param value value to clamp\n+     * @param min minimal allowed value\n+     * @param max maximal allowed value\n+     * @return a clamped value that fits into {@code min..max} interval\n+     * @throws IllegalArgumentException if either of {@code min} and {@code max}\n+     * arguments is NaN, or {@code min > max}, or {@code min} is +0.0, and\n+     * {@code max} is -0.0.\n+     *\n+     * @since 21\n+     *\/\n+    public static double clamp(double value, double min, double max) {\n+        if (!(min < max)) {\n+            if (Double.isNaN(min)) {\n+                throw new IllegalArgumentException(\"min is NaN\");\n+            }\n+            if (Double.isNaN(max)) {\n+                throw new IllegalArgumentException(\"max is NaN\");\n+            }\n+            if (Double.compare(min, max) > 0) {\n+                throw new IllegalArgumentException(min + \" > \" + max);\n+            }\n+        }\n+        return Math.min(max, Math.max(value, min));\n+    }\n+\n+    \/**\n+     * Clamps the value to fit between min and max. If the value is less\n+     * than {@code min}, then {@code min} is returned. If the value is greater\n+     * than {@code max}, then {@code max} is returned. Otherwise, the original\n+     * value is returned. If value is NaN, the result is also NaN.\n+     * <p>\n+     * Unlike the numerical comparison operators, this method considers\n+     * negative zero to be strictly smaller than positive zero.\n+     * E.g., {@code clamp(-0.0f, 0.0f, 1.0f)} returns 0.0f.\n+     *\n+     * @param value value to clamp\n+     * @param min minimal allowed value\n+     * @param max maximal allowed value\n+     * @return a clamped value that fits into {@code min..max} interval\n+     * @throws IllegalArgumentException if either of {@code min} and {@code max}\n+     * arguments is NaN, or {@code min > max}, or {@code min} is +0.0f, and\n+     * {@code max} is -0.0f.\n+     *\n+     * @since 21\n+     *\/\n+    public static float clamp(float value, float min, float max) {\n+        if (!(min < max)) {\n+            if (Float.isNaN(min)) {\n+                throw new IllegalArgumentException(\"min is NaN\");\n+            }\n+            if (Float.isNaN(max)) {\n+                throw new IllegalArgumentException(\"max is NaN\");\n+            }\n+            if (Float.compare(min, max) > 0) {\n+                throw new IllegalArgumentException(min + \" > \" + max);\n+            }\n+        }\n+        return Math.min(max, Math.max(value, min));\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Math.java","additions":118,"deletions":1,"binary":false,"changes":119,"status":"modified"},{"patch":"@@ -1760,0 +1760,89 @@\n+    \/**\n+     * Clamps the value to fit between min and max. If the value is less\n+     * than {@code min}, then {@code min} is returned. If the value is greater\n+     * than {@code max}, then {@code max} is returned. Otherwise, the original\n+     * value is returned.\n+     * <p>\n+     * While the original value of type long may not fit into the int type,\n+     * the bounds have the int type, so the result always fits the int type.\n+     * This allows to use method to safely cast long value to int with\n+     * saturation.\n+     *\n+     * @param value value to clamp\n+     * @param min minimal allowed value\n+     * @param max maximal allowed value\n+     * @return a clamped value that fits into {@code min..max} interval\n+     * @throws IllegalArgumentException if {@code min > max}\n+     *\n+     * @since 21\n+     *\/\n+    public static int clamp(long value, int min, int max) {\n+        return Math.clamp(value, min, max);\n+    }\n+\n+    \/**\n+     * Clamps the value to fit between min and max. If the value is less\n+     * than {@code min}, then {@code min} is returned. If the value is greater\n+     * than {@code max}, then {@code max} is returned. Otherwise, the original\n+     * value is returned.\n+     *\n+     * @param value value to clamp\n+     * @param min minimal allowed value\n+     * @param max maximal allowed value\n+     * @return a clamped value that fits into {@code min..max} interval\n+     * @throws IllegalArgumentException if {@code min > max}\n+     *\n+     * @since 21\n+     *\/\n+    public static long clamp(long value, long min, long max) {\n+        return Math.clamp(value, min, max);\n+    }\n+\n+    \/**\n+     * Clamps the value to fit between min and max. If the value is less\n+     * than {@code min}, then {@code min} is returned. If the value is greater\n+     * than {@code max}, then {@code max} is returned. Otherwise, the original\n+     * value is returned. If value is NaN, the result is also NaN.\n+     * <p>\n+     * Unlike the numerical comparison operators, this method considers\n+     * negative zero to be strictly smaller than positive zero.\n+     * E.g., {@code clamp(-0.0, 0.0, 1.0)} returns 0.0.\n+     *\n+     * @param value value to clamp\n+     * @param min minimal allowed value\n+     * @param max maximal allowed value\n+     * @return a clamped value that fits into {@code min..max} interval\n+     * @throws IllegalArgumentException if either of {@code min} and {@code max}\n+     * arguments is NaN, or {@code min > max}, or {@code min} is +0.0, and\n+     * {@code max} is -0.0.\n+     *\n+     * @since 21\n+     *\/\n+    public static double clamp(double value, double min, double max) {\n+        return Math.clamp(value, min, max);\n+    }\n+\n+    \/**\n+     * Clamps the value to fit between min and max. If the value is less\n+     * than {@code min}, then {@code min} is returned. If the value is greater\n+     * than {@code max}, then {@code max} is returned. Otherwise, the original\n+     * value is returned. If value is NaN, the result is also NaN.\n+     * <p>\n+     * Unlike the numerical comparison operators, this method considers\n+     * negative zero to be strictly smaller than positive zero.\n+     * E.g., {@code clamp(-0.0f, 0.0f, 1.0f)} returns 0.0f.\n+     *\n+     * @param value value to clamp\n+     * @param min minimal allowed value\n+     * @param max maximal allowed value\n+     * @return a clamped value that fits into {@code min..max} interval\n+     * @throws IllegalArgumentException if either of {@code min} and {@code max}\n+     * arguments is NaN, or {@code min > max}, or {@code min} is +0.0f, and\n+     * {@code max} is -0.0f.\n+     *\n+     * @since 21\n+     *\/\n+    public static float clamp(float value, float min, float max) {\n+        return Math.clamp(value, min, max);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StrictMath.java","additions":89,"deletions":0,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -0,0 +1,219 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+   @bug 8301226\n+   @summary Add clamp() methods to java.lang.Math\n+ *\/\n+\n+\n+public class Clamp {\n+    public static void main(String[] args) {\n+        int failures = 0;\n+\n+        failures += testIntClamp();\n+        failures += testLongClamp();\n+        failures += testDoubleClamp();\n+        failures += testFloatClamp();\n+\n+        if (failures > 0) {\n+            System.err.println(\"Testing clamp incurred \" + failures + \" failures.\");\n+            throw new RuntimeException();\n+        }\n+    }\n+\n+    private static int testIntClamp() {\n+        int failures = 0;\n+        failures += checkIntClamp(0, 1, 2, 1);\n+        failures += checkIntClamp(0, 0, 2, 0);\n+        failures += checkIntClamp(1, 0, 2, 1);\n+        failures += checkIntClamp(2, 0, 2, 2);\n+        failures += checkIntClamp(3, 0, 2, 2);\n+        failures += checkIntClamp(0, Integer.MIN_VALUE, Integer.MAX_VALUE, 0);\n+        failures += checkIntClamp(Integer.MIN_VALUE, Integer.MIN_VALUE, Integer.MAX_VALUE, Integer.MIN_VALUE);\n+        failures += checkIntClamp(Integer.MAX_VALUE, Integer.MIN_VALUE, Integer.MAX_VALUE, Integer.MAX_VALUE);\n+        failures += checkIntClamp(Long.MAX_VALUE, Integer.MIN_VALUE, Integer.MAX_VALUE, Integer.MAX_VALUE);\n+        failures += checkIntClamp(Long.MIN_VALUE, Integer.MIN_VALUE, Integer.MAX_VALUE, Integer.MIN_VALUE);\n+        failures += checkIntClamp(0, 1, 1, 1);\n+        failures += checkIntClamp(Long.MAX_VALUE, 1, 1, 1);\n+        failures += checkIllegalArgumentException(\"clamp(1, 2, 0)\", () -> Math.clamp(1, 2, 0), () -> StrictMath.clamp(1, 2, 0));\n+        failures += checkIllegalArgumentException(\"clamp(1, Integer.MAX_VALUE, Integer.MIN_VALUE)\",\n+                () -> Math.clamp(1, Integer.MAX_VALUE, Integer.MIN_VALUE),\n+                () -> StrictMath.clamp(1, Integer.MAX_VALUE, Integer.MIN_VALUE));\n+        return failures;\n+    }\n+\n+    private static int testLongClamp() {\n+        int failures = 0;\n+        failures += checkLongClamp(0L, 1L, 2L, 1L);\n+        failures += checkLongClamp(0L, 0L, 2L, 0L);\n+        failures += checkLongClamp(1L, 0L, 2L, 1L);\n+        failures += checkLongClamp(2L, 0L, 2L, 2L);\n+        failures += checkLongClamp(3L, 0L, 2L, 2L);\n+        failures += checkLongClamp(0L, Long.MIN_VALUE, Long.MAX_VALUE, 0);\n+        failures += checkLongClamp(Long.MIN_VALUE, Long.MIN_VALUE, Long.MAX_VALUE, Long.MIN_VALUE);\n+        failures += checkLongClamp(Long.MAX_VALUE, Long.MIN_VALUE, Long.MAX_VALUE, Long.MAX_VALUE);\n+        failures += checkLongClamp(0, 1, 1, 1);\n+        failures += checkLongClamp(Long.MAX_VALUE, 1, 1, 1);\n+        failures += checkIllegalArgumentException(\"clamp(1, 2, 0)\", () -> Math.clamp(1L, 2L, 0L), () -> StrictMath.clamp(1L, 2L, 0L));\n+        failures += checkIllegalArgumentException(\"clamp(1, Long.MAX_VALUE, Long.MIN_VALUE)\",\n+                () -> Math.clamp(1, Long.MAX_VALUE, Long.MIN_VALUE),\n+                () -> StrictMath.clamp(1, Long.MAX_VALUE, Long.MIN_VALUE));\n+        return failures;\n+    }\n+\n+    private static int testDoubleClamp() {\n+        int failures = 0;\n+        failures += checkDoubleClamp(-0.1, 0.0, 0.5, 0.0);\n+        failures += checkDoubleClamp(-0.0, 0.0, 0.5, 0.0);\n+        failures += checkDoubleClamp(0.0, 0.0, 0.5, 0.0);\n+        failures += checkDoubleClamp(Double.MIN_VALUE, 0.0, 0.5, Double.MIN_VALUE);\n+        failures += checkDoubleClamp(0.2, 0.0, 0.5, 0.2);\n+        failures += checkDoubleClamp(Math.nextDown(0.5), 0.0, 0.5, Math.nextDown(0.5));\n+        failures += checkDoubleClamp(0.5, 0.0, 0.5, 0.5);\n+        failures += checkDoubleClamp(Math.nextUp(0.5), 0.0, 0.5, 0.5);\n+        failures += checkDoubleClamp(0.6, 0.0, 0.5, 0.5);\n+\n+        failures += checkDoubleClamp(Double.MAX_VALUE, 0.0, Double.POSITIVE_INFINITY, Double.MAX_VALUE);\n+        failures += checkDoubleClamp(Double.POSITIVE_INFINITY, 0.0, Double.MAX_VALUE, Double.MAX_VALUE);\n+        failures += checkDoubleClamp(-Double.MAX_VALUE, Double.NEGATIVE_INFINITY, 0.0, -Double.MAX_VALUE);\n+        failures += checkDoubleClamp(Double.NEGATIVE_INFINITY, -Double.MAX_VALUE, 0.0, -Double.MAX_VALUE);\n+\n+        failures += checkDoubleClamp(-1.0, -0.0, 0.0, -0.0);\n+        failures += checkDoubleClamp(-0.0, -0.0, 0.0, -0.0);\n+        failures += checkDoubleClamp(0.0, -0.0, 0.0, 0.0);\n+        failures += checkDoubleClamp(1.0, -0.0, 0.0, 0.0);\n+        failures += checkDoubleClamp(-1.0, 0.0, 0.0, 0.0);\n+        failures += checkDoubleClamp(-0.0, 0.0, 0.0, 0.0);\n+        failures += checkDoubleClamp(0.0, 0.0, 0.0, 0.0);\n+        failures += checkDoubleClamp(1.0, 0.0, 0.0, 0.0);\n+\n+        failures += checkDoubleClamp(Double.NaN, 0.0, 1.0, Double.NaN);\n+        failures += checkDoubleClamp(Double.NaN, Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY, Double.NaN);\n+\n+        failures += checkIllegalArgumentException(\"clamp(0.0, NaN, NaN)\", () -> Math.clamp(0.0, Double.NaN, Double.NaN),\n+                () -> StrictMath.clamp(0.0, Double.NaN, Double.NaN));\n+        failures += checkIllegalArgumentException(\"clamp(0.0, 0.0, NaN)\", () -> Math.clamp(0.0, 0.0, Double.NaN),\n+                () -> StrictMath.clamp(0.0, 0.0, Double.NaN));\n+        failures += checkIllegalArgumentException(\"clamp(0.0, NaN, 0.0)\", () -> Math.clamp(0.0, Double.NaN, 0.0),\n+                () -> StrictMath.clamp(0.0, Double.NaN, 0.0));\n+        failures += checkIllegalArgumentException(\"clamp(NaN, 1.0, 0.0)\", () -> Math.clamp(Double.NaN, 1.0, 0.0),\n+                () -> StrictMath.clamp(Double.NaN, 1.0, 0.0));\n+        failures += checkIllegalArgumentException(\"clamp(0.0, 0.0, -0.0)\", () -> Math.clamp(0.0, 0.0, -0.0),\n+                () -> StrictMath.clamp(0.0, 0.0, -0.0));\n+        return failures;\n+    }\n+\n+    private static int testFloatClamp() {\n+        int failures = 0;\n+        failures += checkFloatClamp(-0.1f, 0.0f, 0.5f, 0.0f);\n+        failures += checkFloatClamp(-0.0f, 0.0f, 0.5f, 0.0f);\n+        failures += checkFloatClamp(0.0f, 0.0f, 0.5f, 0.0f);\n+        failures += checkFloatClamp(Float.MIN_VALUE, 0.0f, 0.5f, Float.MIN_VALUE);\n+        failures += checkFloatClamp(0.2f, 0.0f, 0.5f, 0.2f);\n+        failures += checkFloatClamp(Math.nextDown(0.5f), 0.0f, 0.5f, Math.nextDown(0.5f));\n+        failures += checkFloatClamp(0.5f, 0.0f, 0.5f, 0.5f);\n+        failures += checkFloatClamp(Math.nextUp(0.5f), 0.0f, 0.5f, 0.5f);\n+        failures += checkFloatClamp(0.6f, 0.0f, 0.5f, 0.5f);\n+\n+        failures += checkFloatClamp(Float.MAX_VALUE, 0.0f, Float.POSITIVE_INFINITY, Float.MAX_VALUE);\n+        failures += checkFloatClamp(Float.POSITIVE_INFINITY, 0.0f, Float.MAX_VALUE, Float.MAX_VALUE);\n+        failures += checkFloatClamp(-Float.MAX_VALUE, Float.NEGATIVE_INFINITY, 0.0f, -Float.MAX_VALUE);\n+        failures += checkFloatClamp(Float.NEGATIVE_INFINITY, -Float.MAX_VALUE, 0.0f, -Float.MAX_VALUE);\n+\n+        failures += checkFloatClamp(-1.0f, -0.0f, 0.0f, -0.0f);\n+        failures += checkFloatClamp(-0.0f, -0.0f, 0.0f, -0.0f);\n+        failures += checkFloatClamp(0.0f, -0.0f, 0.0f, 0.0f);\n+        failures += checkFloatClamp(1.0f, -0.0f, 0.0f, 0.0f);\n+        failures += checkFloatClamp(-1.0f, 0.0f, 0.0f, 0.0f);\n+        failures += checkFloatClamp(-0.0f, 0.0f, 0.0f, 0.0f);\n+        failures += checkFloatClamp(0.0f, 0.0f, 0.0f, 0.0f);\n+        failures += checkFloatClamp(1.0f, 0.0f, 0.0f, 0.0f);\n+\n+        failures += checkFloatClamp(Float.NaN, 0.0f, 1.0f, Float.NaN);\n+        failures += checkFloatClamp(Float.NaN, Float.NEGATIVE_INFINITY, Float.POSITIVE_INFINITY, Float.NaN);\n+\n+        failures += checkIllegalArgumentException(\"clamp(0.0f, NaN, NaN)\", () -> Math.clamp(0.0f, Float.NaN, Float.NaN),\n+                () -> StrictMath.clamp(0.0f, Float.NaN, Float.NaN));\n+        failures += checkIllegalArgumentException(\"clamp(0.0f, 0.0f, NaN)\", () -> Math.clamp(0.0f, 0.0f, Float.NaN),\n+                () -> StrictMath.clamp(0.0f, 0.0f, Float.NaN));\n+        failures += checkIllegalArgumentException(\"clamp(0.0f, NaN, 0.0f)\", () -> Math.clamp(0.0f, Float.NaN, 0.0f),\n+                () -> StrictMath.clamp(0.0f, Float.NaN, 0.0f));\n+        failures += checkIllegalArgumentException(\"clamp(NaN, 1.0f, 0.0f)\", () -> Math.clamp(Float.NaN, 1.0f, 0.0f),\n+                () -> StrictMath.clamp(Float.NaN, 1.0f, 0.0f));\n+        failures += checkIllegalArgumentException(\"clamp(0.0f, 0.0f, -0.0f)\", () -> Math.clamp(0.0f, 0.0f, -0.0f),\n+                () -> StrictMath.clamp(0.0f, 0.0f, -0.0f));\n+        return failures;\n+    }\n+\n+    private static int checkIntClamp(long value, int min, int max, int expected) {\n+        return checkEquals(\"Math.clamp(\" + value + \", \" + min + \", \" + max + \")\", Math.clamp(value, min, max), expected) +\n+            checkEquals(\"StrictMath.clamp(\" + value + \", \" + min + \", \" + max + \")\", StrictMath.clamp(value, min, max), expected);\n+    }\n+\n+    private static int checkLongClamp(long value, long min, long max, long expected) {\n+        return checkEquals(\"Math.clamp(\" + value + \", \" + min + \", \" + max + \")\", Math.clamp(value, min, max), expected) +\n+            checkEquals(\"StrictMath.clamp(\" + value + \", \" + min + \", \" + max + \")\", StrictMath.clamp(value, min, max), expected);\n+    }\n+\n+    private static int checkFloatClamp(float value, float min, float max, float expected) {\n+        return checkEquals(\"Math.clamp(\" + value + \", \" + min + \", \" + max + \")\", Math.clamp(value, min, max), expected) +\n+            checkEquals(\"StrictMath.clamp(\" + value + \", \" + min + \", \" + max + \")\", StrictMath.clamp(value, min, max), expected);\n+    }\n+\n+    private static int checkDoubleClamp(double value, double min, double max, double expected) {\n+        return checkEquals(\"Math.clamp(\" + value + \", \" + min + \", \" + max + \")\", Math.clamp(value, min, max), expected) +\n+            checkEquals(\"StrictMath.clamp(\" + value + \", \" + min + \", \" + max + \")\", StrictMath.clamp(value, min, max), expected);\n+    }\n+\n+    private static int checkIllegalArgumentException(String what, Runnable... runnables) {\n+        int failures = 0;\n+        for (Runnable runnable : runnables) {\n+            try {\n+                runnable.run();\n+            }\n+            catch (IllegalArgumentException ex) {\n+                continue;\n+            }\n+            System.err.println(what+\": missing expected exception\");\n+            failures++;\n+        }\n+        return failures;\n+    }\n+\n+    private static int checkEquals(String what, double actual, double expected) {\n+        if (Double.doubleToLongBits(actual) != Double.doubleToLongBits(expected)) {\n+            System.err.println(what + \": expected = \" + expected + \"; actual = \" + actual);\n+            return 1;\n+        }\n+        return 0;\n+    }\n+\n+    private static int checkEquals(String what, long actual, long expected) {\n+        if (actual != expected) {\n+            System.err.println(what + \": expected = \" + expected + \"; actual = \" + actual);\n+            return 1;\n+        }\n+        return 0;\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/Math\/Clamp.java","additions":219,"deletions":0,"binary":false,"changes":219,"status":"added"}]}