{"files":[{"patch":"@@ -3340,1 +3340,1 @@\n-    no tag name after '@'\n+    no tag name after ''@''\n@@ -3604,1 +3604,1 @@\n-    {0} {1} in module {2} is not indirectly exported using 'requires transitive'\n+    {0} {1} in module {2} is not indirectly exported using ''requires transitive''\n@@ -3666,1 +3666,1 @@\n-    (as it is not listed in its 'permits' clause)\n+    (as it is not listed in its ''permits'' clause)\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import java.util.regex.*;\n@@ -50,0 +51,2 @@\n+     * -checkformats\n+     *      validate MessageFormat patterns in resource bundle\n@@ -74,0 +77,1 @@\n+        boolean checkFormats = false;\n@@ -79,0 +83,1 @@\n+                checkFormats = true;\n@@ -84,0 +89,1 @@\n+                System.err.println(\"  -checkformats      validate MessageFormat patterns in resource bundle\");\n@@ -92,0 +98,2 @@\n+                else if (arg.equalsIgnoreCase(\"-checkformats\"))\n+                    checkFormats = true;\n@@ -109,0 +117,3 @@\n+        if (checkFormats)\n+            checkFormats(getMessageFormatBundles());\n+\n@@ -315,0 +326,103 @@\n+    void checkFormats(List<ResourceBundle> messageFormatBundles) {\n+        for (ResourceBundle bundle : messageFormatBundles) {\n+            for (String key : bundle.keySet()) {\n+                final String pattern = bundle.getString(key);\n+                try {\n+                    validateMessageFormatPattern(pattern);\n+                } catch (IllegalArgumentException e) {\n+                    error(\"Invalid MessageFormat pattern for resource \\\"\"\n+                        + key + \"\\\": \" + e.getMessage());\n+                }\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Do some basic validation of a {@link java.text.MessageFormat} format string.\n+     *\n+     * <p>\n+     * This checks for balanced braces and unnecessary quoting.\n+     * Code cut, pasted, &amp; simplified from {@link java.text.MessageFormat#applyPattern}.\n+     *\n+     * @throws IllegalArgumentException if {@code pattern} is invalid\n+     * @throws IllegalArgumentException if {@code pattern} is null\n+     *\/\n+    public static void validateMessageFormatPattern(String pattern) {\n+\n+        \/\/ Check for null\n+        if (pattern == null)\n+            throw new IllegalArgumentException(\"null pattern\");\n+\n+        \/\/ Replicate the quirky lexical analysis of MessageFormat's parsing algorithm\n+        final int SEG_RAW = 0;\n+        final int SEG_INDEX = 1;\n+        final int SEG_TYPE = 2;\n+        final int SEG_MODIFIER = 3;\n+        int part = SEG_RAW;\n+        int braceStack = 0;\n+        int quotedStartPos = -1;\n+        for (int i = 0; i < pattern.length(); i++) {\n+            final char ch = pattern.charAt(i);\n+            if (part == SEG_RAW) {\n+                if (ch == '\\'') {\n+                    if (i + 1 < pattern.length() && pattern.charAt(i + 1) == '\\'')\n+                        i++;\n+                    else if (quotedStartPos == -1)\n+                        quotedStartPos = i;\n+                    else {\n+                        validateMessageFormatQuoted(pattern.substring(quotedStartPos + 1, i));\n+                        quotedStartPos = -1;\n+                    }\n+                } else if (ch == '{' && quotedStartPos == -1)\n+                    part = SEG_INDEX;\n+                continue;\n+            }\n+            if (quotedStartPos != -1) {\n+                if (ch == '\\'') {\n+                    validateMessageFormatQuoted(pattern.substring(quotedStartPos + 1, i));\n+                    quotedStartPos = -1;\n+                }\n+                continue;\n+            }\n+            switch (ch) {\n+            case ',':\n+                if (part < SEG_MODIFIER)\n+                    part++;\n+                break;\n+            case '{':\n+                braceStack++;\n+                break;\n+            case '}':\n+                if (braceStack == 0)\n+                    part = SEG_RAW;\n+                else\n+                    braceStack--;\n+                break;\n+            case '\\'':\n+                quotedStartPos = i;\n+                break;\n+            default:\n+                break;\n+            }\n+        }\n+        if (part != SEG_RAW)\n+            throw new IllegalArgumentException(\"unmatched braces\");\n+        if (quotedStartPos != -1)\n+            throw new IllegalArgumentException(\"unmatched quote starting at offset \" + quotedStartPos);\n+    }\n+\n+    \/**\n+     * Validate the content of a quoted substring in a {@link java.text.MessageFormat} pattern.\n+     *\n+     * <p>\n+     * We expect this content to contain at least one special character. Otherwise,\n+     * it was probably meant to be something in single quotes but somebody forgot\n+     * to escape the single quotes by doulbing them; and even if intentional,\n+     * it's still bogus because the single quotes are just going to get discarded\n+     * and so they were unnecessary in the first place.\n+     *\/\n+    static void validateMessageFormatQuoted(String quoted) {\n+        if (quoted.matches(\"[^'{}]+\"))\n+            throw new IllegalArgumentException(\"unescaped single quotes around \\\"\" + quoted + \"\\\"\");\n+    }\n+\n@@ -408,0 +522,14 @@\n+    \/**\n+     * Get resource bundles containing MessageFormat strings.\n+     *\/\n+    List<ResourceBundle> getMessageFormatBundles() {\n+        Module jdk_compiler = ModuleLayer.boot().findModule(\"jdk.compiler\").get();\n+        List<ResourceBundle> results = new ArrayList<>();\n+        for (String name : new String[]{\"compiler\", \"launcher\"}) {\n+            ResourceBundle b =\n+                    ResourceBundle.getBundle(\"com.sun.tools.javac.resources.\" + name, jdk_compiler);\n+            results.add(b);\n+        }\n+        return results;\n+    }\n+\n","filename":"test\/langtools\/tools\/javac\/diags\/CheckResourceKeys.java","additions":128,"deletions":0,"binary":false,"changes":128,"status":"modified"}]}