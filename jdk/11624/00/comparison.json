{"files":[{"patch":"@@ -220,0 +220,9 @@\n+    \/** Cache the hash code for the throwable *\/\n+    private transient int hash; \/\/ Default to 0\n+\n+    \/**\n+     * Cache if the hash has been calculated as actually being zero, enabling\n+     * us to avoid recalculating this.\n+     *\/\n+    private transient boolean hashIsZero; \/\/ Default to false;\n+\n@@ -1133,0 +1142,90 @@\n+\n+    \/**\n+     * Returns {@code true} if the specified object is another {@code Throwable}\n+     * instance representing the same exception as this instance. Two throwables\n+     * {@code a} and {@code b} are equal if and only if:\n+     * <pre>{@code\n+     *     Objects.equals(a.getClass(), b.getClass()) &&\n+     *     Objects.equals(a.getMessage(), b.getMessage()) &&\n+     *     Objects.equals(a.getCause(), b.getCause()) &&\n+     *     Arrays.equals(a.getStacktrace(), b.getStacktrace()) &&\n+     *     Arrays.equals(a.getSupressed(), b.getSupressed())\n+     * }<\/pre>\n+     *\n+     * @param  obj The object to be compared with this throwable.\n+     * @return {@code true} if the specified object is another\n+     *         {@code Throwable} instance representing the same\n+     *         exception.\n+     *\/\n+    public boolean equals(Object obj) {\n+        if (this == obj) {\n+            return true;\n+        }\n+\n+        if (obj instanceof Throwable) {\n+            Throwable t = (Throwable) obj;\n+            return getClass().equals(t.getClass())\n+                && Objects.equals(detailMessage, t.detailMessage)\n+                && causeEquals(t)\n+                && Arrays.equals(getOurStackTrace(), t.getOurStackTrace())\n+                && Objects.equals(suppressedExceptions, t.suppressedExceptions);\n+        }\n+\n+        return false;\n+    }\n+\n+    \/**\n+     * Checks if the cause for this instance and {@code t} are to be treated as\n+     * equal. As the field {@code cause} defaults to {@code this} for\n+     * {@code Throwable}s, comparing for equality needs to handle this special\n+     * case to prevent circular lookups for defaults.\n+     *\n+     * @param t The throwable of which the cause is compared against the\n+     *        cause of this instance\n+     * @return {@code true} if this instance and the specified throwable have\n+     *         either the same cause or no cause at all\n+     *\/\n+    private boolean causeEquals(Throwable t) {\n+        \/\/ prevent circular lookup as \"cause\" is by default set to \"this\"\n+        if ((cause != this) && (t.cause != t)) {\n+            return Objects.equals(cause, t.cause);\n+        }\n+\n+        return (cause == this) && (t.cause == t);\n+    }\n+\n+    \/**\n+     * Returns a hash code for this throwable. The hash code for two\n+     * {@code Throwable} objects (and subclasses) is expected to be the same\n+     * when they are of the same type, constructed on the same line and with\n+     * the same parameters. The hash code is computesd lazily.\n+     *\n+     * @return  A hash code value for this object.\n+     *\/\n+    public int hashCode() {\n+        int h = hash;\n+        if (h == 0 && !hashIsZero) {\n+            h = 31 + getClass().hashCode();\n+\n+            \/\/ calling getOurStackTrace() instead of accessing stack trace\n+            \/\/ field directly since it might be not initialized yet\n+            h = 31 * h + Arrays.hashCode(getOurStackTrace());\n+            h = 31 * h + Objects.hashCode(detailMessage);\n+\n+            \/\/ don't check for circular references other than the special\n+            \/\/ case \"this\" as this would make the code unnecessary complex\n+            \/\/ for an theoretical use case with little use, if at all\n+            h = 31 * h + (cause == this\n+                    ? 0 : Objects.hashCode(cause));\n+\n+            h = 31 * h + (suppressedExceptions == SUPPRESSED_SENTINEL\n+                    ? 0 : suppressedExceptions.hashCode());\n+\n+            if (h == 0) {\n+                hashIsZero = true;\n+            } else {\n+                hash = h;\n+            }\n+        }\n+        return h;\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Throwable.java","additions":99,"deletions":0,"binary":false,"changes":99,"status":"modified"},{"patch":"@@ -0,0 +1,230 @@\n+\/*\n+ * Copyright 2022 Victor Toni. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.function.Supplier;\n+\n+\/*\n+ * @test\n+ * @bug 8203035\n+ * @summary Basic tests for Throwable hashCode() and equals()\n+ * @author  Victor Toni\n+ *\/\n+\n+public class EqualsHashCode {\n+\n+    private static final String MESSAGE = \"Throwable test message\";\n+    private static final int TEST_THROWABLES_COUNT = 5;\n+\n+    void doTests() throws Exception {\n+        constructingWithDefaultsTest();\n+        withMessageTest();\n+        withDifferentMessageTest();\n+        sameCauseTypeWithDifferentMessageTest();\n+        withDifferentCauseTypeTest();\n+    }\n+\n+    void constructingWithDefaultsTest() throws Exception {\n+        Throwable t1 = new Throwable();\n+        \/\/ assert reflexive equals and hashCode\n+        assertHashCodeAndEqualsAreEqual(t1, t1);\n+\n+        Throwable t2 = new Throwable();\n+        \/\/ assert reflexive equals and hashCode\n+        assertHashCodeAndEqualsAreEqual(t2, t2);\n+\n+        \/\/ Throwables created on different lines should not be equal\n+        assertHashCodeAndEqualsAreNotEqual(t1, t2);\n+\n+        List<Throwable> throwables = new ArrayList<>();\n+        for (int i = 0; i < TEST_THROWABLES_COUNT; i++) {\n+            \/\/ Creating a Throwable in the same way on the same line\n+            \/\/ that should always be equal by contract\n+            Throwable newThrowable = new Throwable();\n+            \/\/ assert reflexive equals and hashCode\n+            assertHashCodeAndEqualsAreEqual(newThrowable, newThrowable);\n+\n+            for (Throwable existingThrowable : throwables) {\n+                \/\/ assert stable equals and hashCode\n+                assertHashCodeAndEqualsAreEqual(existingThrowable, newThrowable);\n+            }\n+            throwables.add(newThrowable);\n+        }\n+    }\n+\n+    void withMessageTest() throws Exception {\n+        Throwable t1 = new Throwable(MESSAGE);\n+        \/\/ assert reflexive equals and hashCode\n+        assertHashCodeAndEqualsAreEqual(t1, t1);\n+\n+        Throwable t2 = new Throwable(MESSAGE);\n+        \/\/ assert reflexive equals and hashCode\n+        assertHashCodeAndEqualsAreEqual(t2, t2);\n+\n+        \/\/ Throwables created on different lines should not be equal.\n+        assertHashCodeAndEqualsAreNotEqual(t1, t2);\n+\n+        List<Throwable> throwables = new ArrayList<>();\n+        for (int i = 0; i < TEST_THROWABLES_COUNT; i++) {\n+            \/\/ Creating a Throwable in the same way on the same line\n+            \/\/ that should always be equal by contract.\n+            Throwable newThrowable = new Throwable(MESSAGE);\n+            \/\/ assert reflexive equals and hashCode\n+            assertHashCodeAndEqualsAreEqual(newThrowable, newThrowable);\n+\n+            for (Throwable existingThrowable : throwables) {\n+                \/\/ assert stable equals and hashCode\n+                assertHashCodeAndEqualsAreEqual(existingThrowable, newThrowable);\n+            }\n+            throwables.add(newThrowable);\n+        }\n+    }\n+\n+    void withDifferentMessageTest() throws Exception {\n+        List<Throwable> throwables = new ArrayList<>();\n+        for (int i = 0; i < TEST_THROWABLES_COUNT; i++) {\n+            \/\/ Creating a Throwable in the same way on the same line\n+            \/\/ that should always be equal by contract.\n+            \/\/ But now each Throwable has a different message\n+            Throwable newThrowable = new Throwable(MESSAGE + i);\n+            \/\/ assert reflexive equals and hashCode\n+            assertHashCodeAndEqualsAreEqual(newThrowable, newThrowable);\n+\n+            for (Throwable existingThrowable : throwables) {\n+                assertHashCodeAndEqualsAreNotEqual(existingThrowable, newThrowable);\n+            }\n+            throwables.add(newThrowable);\n+        }\n+    }\n+\n+    void sameCauseTypeWithDifferentMessageTest() throws Exception {\n+        List<Throwable> throwables = new ArrayList<>();\n+        for (int i = 0; i < TEST_THROWABLES_COUNT; i++) {\n+            \/\/ Creating a Throwable in the same way on the same line\n+            \/\/ that should always be equal by contract.\n+            \/\/ But now each Throwable has a different message\n+            Throwable cause = new Throwable(MESSAGE + i);\n+\n+            \/\/ Creating a Throwable in the same way on the same line\n+            \/\/ that should always be equal by contract.\n+            \/\/ But now each Throwable has a different cause (due to the\n+            \/\/ different messages).\n+            Throwable newThrowable = new Throwable(cause);\n+            \/\/ assert reflexive equals and hashCode\n+            assertHashCodeAndEqualsAreEqual(newThrowable, newThrowable);\n+\n+            for (Throwable existingThrowable : throwables) {\n+                assertHashCodeAndEqualsAreNotEqual(existingThrowable, newThrowable);\n+            }\n+            throwables.add(newThrowable);\n+        }\n+    }\n+\n+    void withDifferentCauseTypeTest() throws Exception {\n+        List<Supplier<Throwable>> causeSuppliers = Arrays.asList(\n+            Exception::new,\n+            NullPointerException::new,\n+            IOException::new,\n+            RuntimeException::new\n+        );\n+\n+        List<Throwable> throwables = new ArrayList<>();\n+        for (Supplier<Throwable> causeSupplier : causeSuppliers) {\n+            \/\/ Creating a Throwable in the same way on the same line\n+            \/\/ that should always be equal by contract.\n+            \/\/ But now each Throwable has a different exception type.\n+            Throwable cause = causeSupplier.get();\n+\n+            Throwable newThrowable = new Throwable(cause);\n+            \/\/ assert reflexive equals and hashCode\n+            assertHashCodeAndEqualsAreEqual(newThrowable, newThrowable);\n+\n+            for (Throwable existingThrowable : throwables) {\n+                assertHashCodeAndEqualsAreNotEqual(existingThrowable, newThrowable);\n+            }\n+            throwables.add(newThrowable);\n+        }\n+    }\n+\n+    \/\/ --------------------- Infrastructure ---------------------------\n+\n+    void assertHashCodeAndEqualsAreNotEqual(Throwable t1, Throwable t2) {\n+        assertHashCodeNotEquals(t1, t2);\n+\n+        assertNotEquals(t1, t2);\n+    }\n+\n+    void assertHashCodeAndEqualsAreEqual(Throwable t1, Throwable t2) {\n+        assertHashCodeEquals(t1, t2);\n+\n+        assertEquals(t1, t2);\n+    }\n+\n+    void assertHashCodeNotEquals(Throwable t1, Throwable t2) {\n+        int h1 = t1.hashCode();\n+        int h2 = t2.hashCode();\n+\n+        if (h1 == h2) {\n+            throw new AssertionError(\"Throwables hashCode() are equal: \" + h1);\n+        }\n+    }\n+\n+    void assertHashCodeEquals(Throwable t1, Throwable t2) {\n+        int h1 = t1.hashCode();\n+        int h2 = t2.hashCode();\n+\n+        if (h1 != h2) {\n+            throw new AssertionError(\"Throwables hashCode() are not equal: \" +\n+                    h1 + \" != \" + h2);\n+        }\n+    }\n+\n+    void assertNotEquals(Throwable t1, Throwable t2) {\n+        if (t1.equals(t2)) {\n+            throw new AssertionError(\"Throwables are equal\");\n+        }\n+        \/\/ assert symmetry of equals\n+        if (t2.equals(t1)) {\n+            throw new AssertionError(\"Throwables are reflexive equal\");\n+        }\n+    }\n+\n+    void assertEquals(Throwable t1, Throwable t2) {\n+        if (!t1.equals(t2)) {\n+            throw new AssertionError(\"Throwables are not equal\");\n+        }\n+        \/\/ assert symmetry of equals\n+        if (!t2.equals(t1)) {\n+            throw new AssertionError(\"Throwables are reflexively not equal\");\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Throwable {\n+        new EqualsHashCode().doTests();\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/lang\/Throwable\/EqualsHashCode.java","additions":230,"deletions":0,"binary":false,"changes":230,"status":"added"}]}