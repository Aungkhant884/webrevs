{"files":[{"patch":"@@ -91,1 +91,0 @@\n-#include \"utilities\/pair.hpp\"\n@@ -1627,0 +1626,5 @@\n+\n+static int compare_fields_by_offset(int* a, int* b) {\n+  return a[0] - b[0];\n+}\n+\n@@ -1634,0 +1638,3 @@\n+  \/\/ In DebugInfo nonstatic fields are sorted by offset.\n+  int* fields_sorted = NEW_C_HEAP_ARRAY(int, 2*(length+1), mtClass);\n+  int j = 0;\n@@ -1637,1 +1644,3 @@\n-      cl->do_field(&fd);\n+      fields_sorted[j + 0] = fd.offset();\n+      fields_sorted[j + 1] = i;\n+      j += 2;\n@@ -1640,28 +1649,2 @@\n-}\n-\n-\/\/ first in Pair is offset, second is index.\n-static int compare_fields_by_offset(Pair<int,int>* a, Pair<int,int>* b) {\n-  return a->first - b->first;\n-}\n-\n-void InstanceKlass::print_nonstatic_fields(FieldClosure* cl) {\n-  InstanceKlass* super = superklass();\n-  if (super != NULL) {\n-    super->print_nonstatic_fields(cl);\n-  }\n-  ResourceMark rm;\n-  fieldDescriptor fd;\n-  \/\/ In DebugInfo nonstatic fields are sorted by offset.\n-  GrowableArray<Pair<int,int> > fields_sorted;\n-  int i = 0;\n-  for (AllFieldStream fs(this); !fs.done(); fs.next()) {\n-    if (!fs.access_flags().is_static()) {\n-      fd = fs.field_descriptor();\n-      Pair<int,int> f(fs.offset(), fs.index());\n-      fields_sorted.push(f);\n-      i++;\n-    }\n-  }\n-  if (i > 0) {\n-    int length = i;\n-    assert(length == fields_sorted.length(), \"duh\");\n+  if (j > 0) {\n+    length = j;\n@@ -1669,4 +1652,4 @@\n-    fields_sorted.sort(compare_fields_by_offset);\n-    for (int i = 0; i < length; i++) {\n-      fd.reinitialize(this, fields_sorted.at(i).second);\n-      assert(!fd.is_static() && fd.offset() == fields_sorted.at(i).first, \"only nonstatic fields\");\n+    qsort(fields_sorted, length\/2, 2*sizeof(int), (_sort_Fn)compare_fields_by_offset);\n+    for (int i = 0; i < length; i += 2) {\n+      fd.reinitialize(this, fields_sorted[i + 1]);\n+      assert(!fd.is_static() && fd.offset() == fields_sorted[i], \"only nonstatic fields\");\n@@ -1676,0 +1659,1 @@\n+  FREE_C_HEAP_ARRAY(int, fields_sorted);\n@@ -1678,0 +1662,1 @@\n+\n@@ -3455,1 +3440,1 @@\n-  ik->print_nonstatic_fields(&print_nonstatic_field);\n+  ik->do_nonstatic_fields(&print_nonstatic_field);\n@@ -3497,0 +3482,1 @@\n+      if (!WizardMode)  return;  \/\/ that is enough\n@@ -3502,1 +3488,1 @@\n-  print_nonstatic_fields(&print_field);\n+  do_nonstatic_fields(&print_field);\n@@ -3508,0 +3494,10 @@\n+    Klass* mirrored_klass = java_lang_Class::as_Klass(obj);\n+    st->print(BULLET\"fake entry for mirror: \");\n+    Metadata::print_value_on_maybe_null(st, mirrored_klass);\n+    st->cr();\n+    Klass* array_klass = java_lang_Class::array_klass_acquire(obj);\n+    st->print(BULLET\"fake entry for array: \");\n+    Metadata::print_value_on_maybe_null(st, array_klass);\n+    st->cr();\n+    st->print_cr(BULLET\"fake entry for oop_size: %d\", java_lang_Class::oop_size(obj));\n+    st->print_cr(BULLET\"fake entry for static_oop_field_count: %d\", java_lang_Class::static_oop_field_count(obj));\n@@ -3510,1 +3506,0 @@\n-      st->print_cr(BULLET\"---- static fields (%d words):\", java_lang_Class::static_oop_field_count(obj));\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":32,"deletions":37,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -1010,1 +1010,0 @@\n-  void print_nonstatic_fields(FieldClosure* cl); \/\/ including inherited and injected fields\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -113,0 +113,2 @@\n+  assert(!f->is_internal(), \"regular Java fields only\");\n+\n@@ -126,2 +128,1 @@\n-    assert(access_flags().is_internal() ||\n-           _index < field_holder()->java_fields_count(), \"oob\");\n+    assert(_index < field_holder()->java_fields_count(), \"oob\");\n@@ -135,1 +136,0 @@\n-  if (access_flags().is_internal()) st->print(\"internal \");\n","filename":"src\/hotspot\/share\/runtime\/fieldDescriptor.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n-#include \"classfile\/systemDictionary.hpp\"\n@@ -29,1 +28,0 @@\n-#include \"oops\/klass.inline.hpp\"\n@@ -42,20 +40,0 @@\n-\n-TEST_VM(InstanceKlass, class_loader_printer) {\n-  ResourceMark rm;\n-  oop loader = SystemDictionary::java_platform_loader();\n-  stringStream st;\n-  loader->print_on(&st);\n-  \/\/ See if injected loader_data field is printed in string\n-  ASSERT_TRUE(strstr(st.as_string(), \"internal 'loader_data'\") != NULL) << \"Must contain internal fields\";\n-  st.reset();\n-  \/\/ See if mirror injected fields are printed.\n-  oop mirror = vmClasses::ClassLoader_klass()->java_mirror();\n-  mirror->print_on(&st);\n-  ASSERT_TRUE(strstr(st.as_string(), \"internal 'protection_domain'\") != NULL) << \"Must contain internal fields\";\n-  \/\/ We should test other printing functions too.\n-  st.reset();\n-  Method* method = vmClasses::ClassLoader_klass()->methods()->at(0);  \/\/ we know there's a method here!\n-  method->print_on(&st);\n-  ASSERT_TRUE(strstr(st.as_string(), \"method holder:\") != NULL) << \"Must contain method_holder field\";\n-  ASSERT_TRUE(strstr(st.as_string(), \"'java\/lang\/ClassLoader'\") != NULL) << \"Must be in ClassLoader\";\n-}\n","filename":"test\/hotspot\/gtest\/oops\/test_instanceKlass.cpp","additions":0,"deletions":22,"binary":false,"changes":22,"status":"modified"}]}