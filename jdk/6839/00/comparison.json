{"files":[{"patch":"@@ -0,0 +1,138 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8272944\n+ * @summary Use snippets in jdk.javadoc documentation\n+ * @library \/tools\/lib ..\/..\/lib\n+ * @modules jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.main\n+ *          jdk.javadoc\/jdk.javadoc.internal.tool\n+ * @build snippets.SnippetUtils toolbox.JavacTask toolbox.ToolBox javadoc.tester.*\n+ * @run main TestDocletExample\n+ *\/\n+\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.spi.ToolProvider;\n+import java.util.stream.Stream;\n+\n+import snippets.SnippetUtils;\n+import toolbox.Task;\n+import toolbox.TestRunner;\n+import toolbox.ToolBox;\n+\n+import javax.tools.DiagnosticCollector;\n+import javax.tools.JavaFileObject;\n+\n+\n+public class TestDocletExample extends TestRunner {\n+    public static void main(String... args) throws Exception {\n+        var t = new TestDocletExample();\n+        t.runTests(m -> new Object[] { Path.of(m.getName()) });\n+    }\n+\n+    SnippetUtils snippets = new SnippetUtils(\"jdk.javadoc\");\n+    ToolBox tb = new ToolBox();\n+\n+    TestDocletExample() {\n+        super(System.out);\n+    }\n+\n+    @Test\n+    public void testEntryPoint(Path base) throws Exception {\n+        var docletPkg = snippets.getElements().getPackageElement(\"jdk.javadoc.doclet\");\n+        var dc = snippets.getDocTrees().getDocCommentTree(docletPkg);\n+        var entryPointSnippet = snippets.getSnippetById(dc, \"entry-point\");\n+        var entryPointCode = entryPointSnippet.getBody().getBody();\n+        var code = \"\"\"\n+                class C {\n+                    %s { }\n+                }\n+                \"\"\".formatted(entryPointCode);\n+        DiagnosticCollector<JavaFileObject> collector = new DiagnosticCollector<>();\n+        snippets.parse(code, null, collector);\n+        var diags = collector.getDiagnostics();\n+        if (diags.isEmpty()) {\n+            out.println(\"parsed entry point snippet\");\n+        } else {\n+            diags.forEach(out::println);\n+            throw new Exception(\"parse failed\");\n+        }\n+    }\n+\n+    @Test\n+    public void testDocletExample(Path base) throws Exception {\n+\n+        \/\/ get source code\n+        var docletPkg = snippets.getElements().getPackageElement(\"jdk.javadoc.doclet\");\n+        var dc = snippets.getDocTrees().getDocCommentTree(docletPkg);\n+        var exampleSnippet = snippets.getSnippetById(dc, \"Example.java\");\n+        var exampleCode = exampleSnippet.getBody().getBody();\n+\n+        \/\/ compile it\n+        Path src = base.resolve(\"src\");\n+        Path classes = base.resolve(\"classes\");\n+        Files.createDirectories(classes);\n+\n+        tb.writeJavaFiles(src, exampleCode);\n+        new toolbox.JavacTask(tb)\n+                .outdir(classes)\n+                .files(tb.findJavaFiles(src))\n+                .run(Task.Expect.SUCCESS)\n+                .writeAll();\n+\n+        \/\/ get demo command\n+        var cmdSnippet = snippets.getSnippetById(dc, \"run-doclet\");\n+        var cmd = cmdSnippet.getBody().getBody()\n+                .replaceAll(\"\\\\s+\/\/.*\", \"\")     \/\/ remove markup\n+                .replaceAll(\"\\\\\\\\\\n\", \" \")      \/\/ join lines\n+                .trim();\n+        out.println(cmd);\n+\n+        tb.writeFile(src.resolve(\"overview.html\"),\n+                \"\"\"\n+                        <!doctype html>\n+                        <html><title>Overview<\/title>\n+                        <body>\n+                        Overview\n+                        <\/body>\n+                        <\/html>\n+                        \"\"\");\n+\n+        var cmdWords = Stream.of(cmd.split(\"\\\\s+\"))\n+                .map(s -> s.replace(\"source-location\", src.toString()))\n+                .map(s -> s.replace(\"doclet-classes\", classes.toString()))\n+                .toList();\n+        var toolName = cmdWords.get(0);\n+        var toolArgs = cmdWords.subList(1, cmdWords.size());\n+\n+        ToolProvider tool = ToolProvider.findFirst(toolName)\n+                .orElseThrow(() -> new Exception(\"tool not found: \" + toolName));\n+        int rc = tool.run(System.out, System.err, toolArgs.toArray(new String[0]));\n+        if (rc != 0) {\n+            throw new Exception(\"ecommand return code: \" + rc);\n+        }\n+    }\n+}\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testDocletExample\/TestDocletExample.java","additions":138,"deletions":0,"binary":false,"changes":138,"status":"added"},{"patch":"@@ -0,0 +1,123 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8272944\n+ * @summary Use snippets in java.compiler documentation\n+ * @library \/tools\/lib ..\/..\/lib\n+ * @modules jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.main\n+ * @build snippets.SnippetUtils toolbox.JavacTask toolbox.TestRunner toolbox.ToolBox\n+ * @run main TestJavaxToolsSnippets\n+ *\/\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Objects;\n+\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.TypeElement;\n+import javax.tools.DiagnosticCollector;\n+import javax.tools.JavaFileObject;\n+\n+import com.sun.source.doctree.SnippetTree;\n+\n+import snippets.SnippetUtils;\n+import toolbox.JavacTask;\n+import toolbox.Task;\n+import toolbox.TestRunner;\n+import toolbox.ToolBox;\n+\n+\/**\n+ * Tests the snippets in the {@code javax.tools} package, by compiling the\n+ * external snippets and parsing the internal Java snippets.\n+ *\/\n+public class TestJavaxToolsSnippets extends TestRunner {\n+    public static void main(String... args) throws Exception {\n+        new TestJavaxToolsSnippets().runTests(m -> new Object[] { Path.of(m.getName()) });\n+    }\n+\n+    SnippetUtils snippets = new SnippetUtils(\"java.compiler\");\n+    ToolBox tb = new ToolBox();\n+\n+    TestJavaxToolsSnippets() {\n+        super(System.err);\n+    }\n+\n+    @Test\n+    public void testExternalSnippets(Path base) throws Exception {\n+        Path snippetFilesDir = snippets.getSourceDir()\n+                .resolve(\"java.compiler\")  \/\/ module\n+                .resolve(\"share\").resolve(\"classes\")\n+                .resolve(\"javax.tools\".replace(\".\", File.separator)) \/\/ package\n+                .resolve(\"snippet-files\");\n+        new JavacTask(tb)\n+                .files(tb.findJavaFiles(snippetFilesDir))\n+                .outdir(Files.createDirectories(base.resolve(\"classes\")))\n+                .run(Task.Expect.SUCCESS)\n+                .writeAll();\n+        out.println(\"Compilation succeeded\");\n+    }\n+\n+    @Test\n+    public void testJavaCompilerSnippets(Path base) {\n+        TypeElement te = snippets.getElements().getTypeElement(\"javax.tools.JavaCompiler\");\n+        snippets.scan(te, this::handleSnippet);\n+    }\n+\n+    @Test\n+    public void testJavaFileManagerSnippets(Path base) {\n+        TypeElement te = snippets.getElements().getTypeElement(\"javax.tools.JavaFileManager\");\n+        snippets.scan(te, this::handleSnippet);\n+    }\n+\n+    @Test\n+    public void testStandardJavaFileManagerSnippets(Path base) {\n+        TypeElement te = snippets.getElements().getTypeElement(\"javax.tools.StandardJavaFileManager\");\n+        snippets.scan(te, this::handleSnippet);\n+    }\n+\n+    void handleSnippet(Element e, SnippetTree tree) {\n+        String lang = snippets.getAttr(tree, \"lang\");\n+        if (Objects.equals(lang, \"java\")) {\n+            String body = snippets.getBody(tree);\n+            if (body != null) {\n+                String id = snippets.getAttr(tree, \"id\");\n+                try {\n+                    out.println(\"parsing snippet \" + e + \":\" + id);\n+                    if (snippets.parse(body, out::println)) {\n+                        out.println(\"parsed snippet\");\n+                    } else {\n+                        error(\"parse failed\");\n+                    }\n+                } catch (IOException ex) {\n+                    throw new UncheckedIOException(ex);\n+                }\n+            }\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/api\/snippets\/TestJavaxToolsSnippets.java","additions":123,"deletions":0,"binary":false,"changes":123,"status":"added"},{"patch":"@@ -0,0 +1,543 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package snippets;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.net.URI;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.function.BiConsumer;\n+import java.util.function.Consumer;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.Modifier;\n+import javax.lang.model.element.ModuleElement;\n+import javax.lang.model.element.PackageElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.element.VariableElement;\n+import javax.lang.model.util.Elements;\n+import javax.lang.model.util.SimpleElementVisitor14;\n+import javax.tools.Diagnostic;\n+import javax.tools.DiagnosticCollector;\n+import javax.tools.DiagnosticListener;\n+import javax.tools.JavaCompiler;\n+import javax.tools.JavaFileManager;\n+import javax.tools.JavaFileObject;\n+import javax.tools.SimpleJavaFileObject;\n+import javax.tools.StandardJavaFileManager;\n+import javax.tools.ToolProvider;\n+\n+import com.sun.source.doctree.AttributeTree;\n+import com.sun.source.doctree.DocCommentTree;\n+import com.sun.source.doctree.DocTree;\n+import com.sun.source.doctree.SnippetTree;\n+import com.sun.source.doctree.TextTree;\n+import com.sun.source.util.DocTreeScanner;\n+import com.sun.source.util.DocTrees;\n+import com.sun.source.util.JavacTask;\n+\n+\/**\n+ * Utilities for analyzing snippets.\n+ *\n+ * Support is provided for the following:\n+ * <ul>\n+ * <li>creating an instance of {@link JavacTask} suitable for looking up\n+ *     elements by name, in order to access any corresponding documentation comment,\n+ * <li>scanning elements to find all associated snippets,\n+ * <li>locating instances of snippets by their {@code id},\n+ * <li>parsing snippets, and\n+ * <li>accessing the body of snippets, for any additional analysis.\n+ * <\/ul>\n+ *\n+ * @apiNote\n+ * The utilities do not provide support for compiling and running snippets,\n+ * because in general, this requires too much additional context. However,\n+ * the utilities do provide support for locating snippets in various ways,\n+ * and accessing the body of those snippets, to simplify the task of writing\n+ * code to compile and run snippets, where that is appropriate.\n+ *\/\n+public class SnippetUtils {\n+    private static final JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();\n+\n+    private final StandardJavaFileManager fileManager;\n+    private final Path srcDir;\n+    private final JavacTask javacTask;\n+    private final Elements elements;\n+    private final DocTrees docTrees;\n+\n+    \/**\n+     * Creates an instance for analysing snippets in one or more JDK modules.\n+     *\n+     * The source for the modules is derived from the value of the\n+     * {@code test.src} system property.\n+     *\n+     * Any messages, including error messages, will be written to {@code System.err}.\n+     *\n+     * @param modules the modules\n+     *\n+     * @throws IllegalArgumentException if no modules are specified\n+     *\/\n+    public SnippetUtils(String... modules) {\n+        this(findSourceDir(), null, null, Set.of(modules));\n+    }\n+\n+    \/**\n+     * Creates an instance for analysing snippets in one or more modules.\n+     *\n+     * @param srcDir the location for the source of the modules;\n+     *               the location for the source of a specific module should be\n+     *               in <em>srcDir<\/em>{@code \/}<em>module<\/em>{@code \/share\/module}\n+     *\n+     * @param pw     a writer for any text messages that may be generated;\n+     *               if null, messages will be written to {@code System.err}\n+     *\n+     * @param dl     a diagnostic listener for any diagnostic messages that may be generated;\n+     *               if null, messages will be written to {@code System.err}\n+     *\n+     * @param modules the modules\n+     *\n+     * @throws IllegalArgumentException if no modules are specified\n+     *\/\n+    public SnippetUtils(Path srcDir, PrintWriter pw, DiagnosticListener<JavaFileObject> dl, Set<String> modules) {\n+        if (modules.isEmpty()) {\n+            throw new IllegalArgumentException(\"no modules specified\");\n+        }\n+\n+        this.srcDir = srcDir;\n+        fileManager = compiler.getStandardFileManager(dl, null, null);\n+\n+        List<String> opts = new ArrayList<>();\n+        opts.addAll(List.of(\"--add-modules\", String.join(\",\", modules)));  \/\/ could use CompilationTask.addModules\n+        modules.forEach(m -> opts.addAll(List.of(\"--patch-module\", m + \"=\" + getModuleSourceDir(m))));\n+        opts.add(\"-proc:only\");\n+\n+        javacTask = (JavacTask) compiler.getTask(pw, fileManager, dl, opts, null, null);\n+        elements = javacTask.getElements();\n+        elements.getModuleElement(\"java.base\"); \/\/ forces module graph to be instantiated, etc\n+\n+        docTrees = DocTrees.instance(javacTask);\n+    }\n+\n+    \/**\n+     * {@return the source directory for the task used to access snippets}\n+     *\/\n+    public Path getSourceDir() {\n+        return srcDir;\n+    }\n+\n+    \/**\n+     * {@return the file manager for the task used to access snippets}\n+     *\/\n+    public StandardJavaFileManager  getFileManager() {\n+        return fileManager;\n+    }\n+\n+    \/**\n+     * {@return the instance of {@code Elements} for the task used to access snippets}\n+     *\/\n+    public Elements getElements() {\n+        return elements;\n+    }\n+\n+    \/**\n+     * {@return the instance of {@code DocTrees} for the task used to access snippets}\n+     *\/\n+    public DocTrees getDocTrees() {\n+        return docTrees;\n+    }\n+\n+    \/**\n+     * {@return the doc comment tree for an element}\n+     *\n+     * @param element the element\n+     *\/\n+    public DocCommentTree getDocCommentTree(Element element) {\n+        return docTrees.getDocCommentTree(element);\n+    }\n+\n+    \/**\n+     * {@return the snippet with a given id in a doc comment tree}\n+     *\n+     * @param tree the doc comment tree\n+     * @param id   the id\n+     *\/\n+    public SnippetTree getSnippetById(DocCommentTree tree, String id) {\n+        return new SnippetFinder().scan(tree, id);\n+    }\n+\n+    \/**\n+     * {@return the snippet with a given id in the doc comment tree for an element}\n+     *\n+     * @param element the element\n+     * @param id      the id\n+     *\/\n+    public SnippetTree getSnippetById(Element element, String id) {\n+        DocCommentTree tree = getDocCommentTree(element);\n+        return new SnippetFinder().scan(tree, id);\n+    }\n+\n+    \/**\n+     * A scanner to locate the tree for a snippet with a given id.\n+     * Note: the scanner is use-once.\n+     *\/\n+    private static class SnippetFinder extends DocTreeScanner<SnippetTree,String> {\n+        private SnippetTree result;\n+        private SnippetTree inSnippet;\n+\n+        @Override\n+        public SnippetTree scan(DocTree tree, String id) {\n+            \/\/ stop scanning once the result has been found\n+            return result != null ? result : super.scan(tree, id);\n+        }\n+\n+        @Override\n+        public SnippetTree visitSnippet(SnippetTree tree, String id) {\n+            inSnippet = tree;\n+            try {\n+                return super.visitSnippet(tree, id);\n+            } finally {\n+                inSnippet = null;\n+            }\n+        }\n+\n+        @Override\n+        public SnippetTree visitAttribute(AttributeTree tree, String id) {\n+            if (tree.getName().contentEquals(\"id\")\n+                    && tree.getValue().toString().equals(id)) {\n+                result = inSnippet;\n+                return result;\n+            } else {\n+                return null;\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Scans an element and appropriate enclosed elements for doc comments,\n+     * and call a handler to handle any snippet trees in those doc comments.\n+     *\n+     * Only the public and protected members of type elements are scanned.\n+     * The enclosed elements of modules and packages are <em>not<\/em> scanned.\n+     *\n+     * @param element the element\n+     * @param handler the handler\n+     * @throws IllegalArgumentException if any inappropriate element is scanned\n+     *\/\n+    public void scan(Element element, BiConsumer<Element, SnippetTree> handler) {\n+        new ElementScanner(docTrees).scan(element, handler);\n+    }\n+\n+    private static class ElementScanner extends SimpleElementVisitor14<Void, DocTreeScanner<Void, Element>> {\n+        private final DocTrees trees;\n+\n+        public ElementScanner(DocTrees trees) {\n+            this.trees = trees;\n+        }\n+\n+        public void scan(Element e, BiConsumer<Element, SnippetTree> snippetHandler) {\n+            visit(e, new DocTreeScanner<>() {\n+                @Override\n+                public Void visitSnippet(SnippetTree tree, Element e) {\n+                    snippetHandler.accept(e, tree);\n+                    return null;\n+                }\n+            });\n+        }\n+\n+        @Override\n+        public Void visitModule(ModuleElement me, DocTreeScanner<Void, Element> treeScanner) {\n+            scanDocComment(me, treeScanner);\n+            return null;\n+        }\n+\n+        @Override\n+        public Void visitPackage(PackageElement pe, DocTreeScanner<Void, Element> treeScanner) {\n+            scanDocComment(pe, treeScanner);\n+            return null;\n+        }\n+\n+        @Override\n+        public Void visitType(TypeElement te, DocTreeScanner<Void, Element> treeScanner) {\n+            scanDocComment(te, treeScanner);\n+            for (Element e : te.getEnclosedElements()) {\n+                Set<Modifier> mods = e.getModifiers();\n+                if (mods.contains(Modifier.PUBLIC) || mods.contains(Modifier.PROTECTED)) {\n+                    e.accept(this, treeScanner);\n+                }\n+            }\n+            return null;\n+        }\n+\n+        @Override\n+        public Void visitExecutable(ExecutableElement ee, DocTreeScanner<Void, Element> treeScanner) {\n+            scanDocComment(ee, treeScanner);\n+            return null;\n+        }\n+\n+        @Override\n+        public Void visitVariable(VariableElement ve, DocTreeScanner<Void, Element> treeScanner) {\n+            switch (ve.getKind()) {\n+                case ENUM_CONSTANT, FIELD -> scanDocComment(ve, treeScanner);\n+                default -> defaultAction(ve, treeScanner);\n+            }\n+            return null;\n+        }\n+\n+        @Override\n+        public Void defaultAction(Element e, DocTreeScanner<Void, Element> treeScanner) {\n+            throw new IllegalArgumentException(e.getKind() + \" \" + e.getSimpleName());\n+        }\n+\n+        private void scanDocComment(Element e, DocTreeScanner<Void, Element> treeScanner) {\n+            DocCommentTree dc = trees.getDocCommentTree(e);\n+            if (dc != null) {\n+                treeScanner.scan(dc, e);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * {@return the string content of an inline or hybrid snippet, or {@code null} for an external snippet}\n+     *\n+     * @param tree the snippet\n+     *\/\n+    public String getBody(SnippetTree tree) {\n+        TextTree body = tree.getBody();\n+        return body == null ? null : body.getBody();\n+    }\n+\n+    \/**\n+     * {@return the string content of an external or inline snippet}\n+     *\n+     * @param element the element whose documentation contains the snippet\n+     * @param tree    the snippet\n+     *\/\n+    public String getBody(Element element, SnippetTree tree) throws IOException {\n+        Path externalSnippetPath = getExternalSnippetPath(element, tree);\n+        return externalSnippetPath == null ? getBody(tree) : Files.readString(externalSnippetPath);\n+    }\n+\n+    \/**\n+     * {@return the path for the {@code snippet-files} directory for an element}\n+     *\n+     * @param element the element\n+     *\n+     * @return the path\n+     *\/\n+    public Path getSnippetFilesDir(Element element) {\n+        var moduleElem = elements.getModuleOf(element);\n+        var modulePath = getModuleSourceDir(moduleElem);\n+\n+        var packageElem = elements.getPackageOf(element); \/\/ null for a module\n+        var packagePath = packageElem == null\n+                ? modulePath\n+                : modulePath.resolve(packageElem.getQualifiedName().toString().replace(\".\", File.separator));\n+\n+        return packagePath.resolve(\"snippet-files\");\n+    }\n+\n+    \/**\n+     * {@return the path for an external snippet, or {@code null} if the snippet is inline}\n+     *\n+     * @param element the element whose documentation contains the snippet\n+     * @param tree    the snippet\n+     *\/\n+    public Path getExternalSnippetPath(Element element, SnippetTree tree) {\n+        var classAttr = getAttr(tree, \"class\");\n+        String file = (classAttr != null)\n+            ? classAttr.replace(\".\", \"\/\") + \".java\"\n+            : getAttr(tree, \"file\");\n+        return file == null ? null : getSnippetFilesDir(element).resolve(file.replace(\"\/\", File.separator));\n+    }\n+\n+    \/**\n+     * {@return the value of an attribute defined by a snippet}\n+     *\n+     * @param tree the snippet\n+     * @param name the name of the attribute\n+     *\/\n+    public String getAttr(SnippetTree tree, String name) {\n+        for (DocTree t : tree.getAttributes()) {\n+            if (t instanceof AttributeTree at && at.getName().contentEquals(name)) {\n+                return at.getValue().toString();\n+            }\n+        }\n+        return null;\n+    }\n+\n+    \/**\n+     * {@return the primary source directory for a module}\n+     *\n+     * The directory is <em>srcDir<\/em>\/<em>module-name<\/em>\/share\/classes.\n+     *\n+     * @param e the module\n+     *\/\n+    public Path getModuleSourceDir(ModuleElement e) {\n+        return getModuleSourceDir(e.getQualifiedName().toString());\n+    }\n+\n+    \/**\n+     * {@return the primary source directory for a module}\n+     *\n+     * The directory is <em>srcDir<\/em>\/<em>moduleName<\/em>\/share\/classes.\n+     *\n+     * @param moduleName the module name\n+     *\/\n+    public Path getModuleSourceDir(String moduleName) {\n+        return srcDir.resolve(moduleName).resolve(\"share\").resolve(\"classes\");\n+    }\n+\n+    \/**\n+     * Kinds of fragments of source code.\n+     *\/\n+    public enum SourceKind {\n+        \/** A module declaration. *\/\n+        MODULE_INFO,\n+        \/** A package declaration. *\/\n+        PACKAGE_INFO,\n+        \/** A class or interface declaration. *\/\n+        TYPE_DECL,\n+        \/** A member declaration for a class or interface. *\/\n+        MEMBER_DECL,\n+        \/** A statement, expression or other kind of fragment. *\/\n+        OTHER\n+    }\n+\n+    \/**\n+     * Parses a fragment of source code, after trying to infer the kind of the fragment.\n+     *\n+     * @param body      the string to be parsed\n+     * @param showDiag  a function to handle any diagnostics that may be generated\n+     * @return          {@code true} if the parse succeeded, and {@code false} otherwise\n+     *\n+     * @throws IOException if an IO exception occurs\n+     *\/\n+    public boolean parse(String body, Consumer<? super Diagnostic<? extends JavaFileObject>> showDiag) throws IOException {\n+        DiagnosticCollector<JavaFileObject> collector = new DiagnosticCollector<>();\n+        parse(body, null, collector);\n+        var diags = collector.getDiagnostics();\n+        diags.forEach(showDiag);\n+        return diags.isEmpty();\n+    }\n+\n+    \/**\n+     * Parses a fragment of source code, after trying to infer the kind of the fragment.\n+     *\n+     * @param body the string to be parsed\n+     * @param pw   a stream for diagnostics, or {@code null} to use {@code System.err}\n+     * @param dl   a diagnostic listener, or {@code null} to report diagnostics to {@code pw} or {@code System.err}\n+     * @throws IOException if an IO exception occurs\n+     *\/\n+    public void parse(String body, PrintWriter pw, DiagnosticListener<JavaFileObject> dl)\n+            throws IOException {\n+        parse(inferSourceKind(body), body, pw, dl);\n+    }\n+\n+    \/**\n+     * Parses a fragment of source code of a given kind.\n+     *\n+     * @param kind the kind of code to be parsed\n+     * @param body the string to be parsed\n+     * @param pw   a stream for diagnostics, or {@code null} to use {@code System.err}\n+     * @param dl   a diagnostic listener, or {@code null} to report diagnostics to {@code pw} or {@code System.err}.\n+     * @throws IOException if an IO exception occurs\n+     *\/\n+    public void parse(SourceKind kind, String body, PrintWriter pw, DiagnosticListener<JavaFileObject> dl)\n+            throws IOException {\n+        String fileBase = switch (kind) {\n+            case MODULE_INFO -> \"module-info\";\n+            case PACKAGE_INFO -> \"package-info\";\n+            default -> \"C\";  \/\/ the exact name doesn't matter if just parsing (the filename check for public types comes later on)\n+        };\n+        URI uri = URI.create(\"mem:\/\/%s.java\".formatted(fileBase));\n+\n+        String compUnit = switch (kind) {\n+            case MODULE_INFO, PACKAGE_INFO, TYPE_DECL -> body;\n+            case MEMBER_DECL -> \"\"\"\n+                    class C {\n+                    %s\n+                    }\"\"\".formatted(body);\n+            case OTHER -> \"\"\"\n+                    class C {\n+                        void m() {\n+                        %s\n+                        ;\n+                        }\n+                    }\"\"\".formatted(body);\n+        };\n+        JavaFileObject fo = new SimpleJavaFileObject(uri, JavaFileObject.Kind.SOURCE) {\n+            public CharSequence getCharContent(boolean ignoreEncodingErrors) {\n+                return compUnit;\n+            }\n+        };\n+\n+        JavaFileManager fm = compiler.getStandardFileManager(dl, null, null);\n+\n+        List<String> opts = new ArrayList<>();\n+        JavacTask javacTask = (JavacTask) compiler.getTask(pw, fm, dl, opts, null, List.of(fo));\n+\n+        javacTask.parse();\n+    }\n+\n+    public SourceKind inferSourceKind(String s) {\n+        Pattern typeDecl = Pattern.compile(\"(?s)(^|\\\\R)([A-Za-z0-9_$ ])*\\\\b(?<kw>module|package|class|interface|record|enum)\\\\s+(?<name>[A-Za-z0-9_$]+)\");\n+        Matcher m1 = typeDecl.matcher(s);\n+        if (m1.find()) {\n+            return switch (m1.group(\"kw\")) {\n+                case \"module\" -> SourceKind.MODULE_INFO;\n+                case \"package\" -> m1.find() ? SourceKind.TYPE_DECL : SourceKind.PACKAGE_INFO;\n+                default -> SourceKind.TYPE_DECL;\n+            };\n+        }\n+\n+        Pattern methodDecl = Pattern.compile(\"(?s)(^|\\\\R)([A-Za-z0-9<>,]+ )+\\\\b(?<name>[A-Za-z0-9_$]+)([(;]| +=)\");\n+        Matcher m2 = methodDecl.matcher(s);\n+        if (m2.find()) {\n+            return SourceKind.MEMBER_DECL;\n+        }\n+\n+        return SourceKind.OTHER;\n+    }\n+\n+    private static Path findSourceDir() {\n+        String testSrc = System.getProperty(\"test.src\");\n+        Path p = Path.of(testSrc).toAbsolutePath();\n+        while (p.getParent() != null) {\n+            Path srcDir = p.resolve(\"src\");\n+            if (Files.exists(srcDir.resolve(\"java.base\"))) {\n+                return srcDir;\n+            }\n+            p = p.getParent();\n+        }\n+        throw new IllegalArgumentException(\"Cannot find src\/ from \" + testSrc);\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/langtools\/tools\/lib\/snippets\/SnippetUtils.java","additions":543,"deletions":0,"binary":false,"changes":543,"status":"added"}]}