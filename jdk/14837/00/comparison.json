{"files":[{"patch":"@@ -27,1 +27,5 @@\n- * @modules jdk.jdeps\/com.sun.tools.classfile\n+ * @modules java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.classfile.attribute\n+ *          java.base\/jdk.internal.classfile.constantpool\n+ *          java.base\/jdk.internal.classfile.instruction\n+ *          java.base\/jdk.internal.classfile.components\n@@ -31,1 +35,4 @@\n-import com.sun.tools.classfile.*;\n+import java.nio.file.Files;\n+\n+import jdk.internal.classfile.*;\n+import jdk.internal.classfile.attribute.*;\n@@ -41,4 +48,3 @@\n-\n-        ClassFile cf = ClassFile.read(classFile);\n-        for (Method m: cf.methods) {\n-            test(cf, m);\n+        ClassModel cm = Classfile.of().parse(classFile.toPath());\n+        for (MethodModel mm: cm.methods()) {\n+            test(mm);\n@@ -51,3 +57,3 @@\n-    void test(ClassFile cf, Method m) {\n-        test(cf, m, Attribute.Code, Code_attribute.class);\n-        test(cf, m, Attribute.Exceptions, Exceptions_attribute.class);\n+    void test(MethodModel mm) {\n+        test(mm, Attributes.CODE, CodeAttribute.class);\n+        test(mm, Attributes.EXCEPTIONS, ExceptionsAttribute.class);\n@@ -56,1 +62,1 @@\n-    \/\/ test the result of Attributes.getIndex according to expectations\n+    \/\/ test the result of MethodModel.findAttribute, MethodModel.attributes().indexOf() according to expectations\n@@ -58,18 +64,14 @@\n-    void test(ClassFile cf, Method m, String name, Class<?> c) {\n-        int index = m.attributes.getIndex(cf.constant_pool, name);\n-        try {\n-            String m_name = m.getName(cf.constant_pool);\n-            System.err.println(\"Method \" + m_name + \" name:\" + name + \" index:\" + index + \" class: \" + c);\n-            boolean expect = (m_name.equals(\"<init>\") && name.equals(\"Code\"))\n-                || (m_name.indexOf(name) != -1);\n-            boolean found = (index != -1);\n-            if (expect) {\n-                if (found) {\n-                    Attribute attr = m.attributes.get(index);\n-                    if (!c.isAssignableFrom(attr.getClass())) {\n-                        error(m + \": unexpected attribute found,\"\n-                              + \" expected \" + c.getName()\n-                              + \" found \" + attr.getClass().getName());\n-                    }\n-                } else {\n-                    error(m + \": expected attribute \" + name + \" not found\");\n+    <T extends Attribute<T>> void test(MethodModel mm, AttributeMapper<T> attr, Class<?> c) {\n+        Attribute<T> attr_instance = mm.findAttribute(attr).orElse(null);\n+        int index = mm.attributes().indexOf(attr_instance);\n+        String mm_name = mm.methodName().stringValue();\n+        System.err.println(\"Method \" + mm_name + \" name:\" + attr.name() + \" index:\" + index + \" class: \" + c);\n+        boolean expect = (mm_name.equals(\"<init>\") && attr.name().equals(\"Code\"))\n+                || (mm_name.contains(attr.name()));\n+        boolean found = (index != -1);\n+        if (expect) {\n+            if (found) {\n+                if (!c.isAssignableFrom(mm.attributes().get(index).getClass())) {\n+                    error(mm + \": unexpected attribute found,\"\n+                            + \" expected \" + c.getName()\n+                            + \" found \" + mm.attributes().get(index).attributeName());\n@@ -78,3 +80,5 @@\n-                if (found) {\n-                    error(m + \": unexpected attribute \" + name);\n-                }\n+                error(mm + \": expected attribute \" + attr.name() + \" not found\");\n+            }\n+        } else {\n+            if (found) {\n+                error(mm + \": unexpected attribute \" + attr.name());\n@@ -82,2 +86,0 @@\n-        } catch (ConstantPoolException e) {\n-            error(m + \": \" + e);\n","filename":"test\/langtools\/tools\/javap\/T6716452.java","additions":35,"deletions":33,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n- *      jdk.jdeps\/com.sun.tools.classfile\n@@ -34,0 +33,5 @@\n+ *      java.base\/jdk.internal.classfile\n+ *      java.base\/jdk.internal.classfile.attribute\n+ *      java.base\/jdk.internal.classfile.constantpool\n+ *      java.base\/jdk.internal.classfile.instruction\n+ *      java.base\/jdk.internal.classfile.components\n@@ -38,0 +42,1 @@\n+import java.lang.constant.ClassDesc;\n@@ -46,2 +51,0 @@\n-import com.sun.tools.classfile.ClassFile;\n-import com.sun.tools.classfile.ClassWriter;\n@@ -49,0 +52,1 @@\n+import jdk.internal.classfile.*;\n@@ -143,1 +147,1 @@\n-                                searchBytes, 0, searchBytes.length)) {\n+                    searchBytes, 0, searchBytes.length)) {\n@@ -175,8 +179,9 @@\n-\n-        ClassFile cf = ClassFile.read(classes.resolve(\"A.class\"));\n-        ClassFile cf2 = new ClassFile(\n-                cf.magic, cf.minor_version, cf.major_version, cf.constant_pool,\n-                cf.access_flags,\n-                0, \/\/ this_class,\n-                cf.super_class, cf.interfaces, cf.fields, cf.methods, cf.attributes);\n-        new ClassWriter().write(cf2, Files.newOutputStream(classes.resolve(\"Z.class\")));\n+        ClassModel cm = Classfile.of().parse(classes.resolve(\"A.class\"));\n+        Classfile.of().buildTo(\n+                classes.resolve(\"Z.class\"),\n+                ClassDesc.of(\"0\"), cb -> {\n+                    for (ClassElement ce : cm) {\n+                        cb.with(ce);\n+                    }\n+                }\n+        );\n@@ -241,1 +246,0 @@\n-\n","filename":"test\/langtools\/tools\/javap\/TestClassNameWarning.java","additions":17,"deletions":13,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+import java.lang.constant.*;\n+import java.nio.file.Paths;\n@@ -28,8 +30,3 @@\n-import com.sun.tools.classfile.*;\n-import com.sun.tools.classfile.Type.ArrayType;\n-import com.sun.tools.classfile.Type.ClassSigType;\n-import com.sun.tools.classfile.Type.ClassType;\n-import com.sun.tools.classfile.Type.MethodType;\n-import com.sun.tools.classfile.Type.SimpleType;\n-import com.sun.tools.classfile.Type.TypeParamType;\n-import com.sun.tools.classfile.Type.WildcardType;\n+import jdk.internal.classfile.*;\n+import jdk.internal.classfile.attribute.*;\n+import jdk.internal.classfile.constantpool.*;\n@@ -41,1 +38,6 @@\n- * @modules jdk.jdeps\/com.sun.tools.classfile\n+ * @modules java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.classfile.attribute\n+ *          java.base\/jdk.internal.classfile.constantpool\n+ *          java.base\/jdk.internal.classfile.instruction\n+ *          java.base\/jdk.internal.classfile.components\n+ *          java.base\/jdk.internal.classfile.impl\n@@ -64,1 +66,1 @@\n-        ClassFile cf = getClassFile(\"Test\");\n+        ClassModel cm = getClassFile(\"Test\");\n@@ -66,3 +68,3 @@\n-        testFields(cf);\n-        testMethods(cf);\n-        testInnerClasses(cf); \/\/ recursive\n+        testFields(cm);\n+        testMethods(cm);\n+        testInnerClasses(cm); \/\/ recursive\n@@ -74,5 +76,4 @@\n-    void testFields(ClassFile cf) throws Exception {\n-        String cn = cf.getName();\n-        ConstantPool cp = cf.constant_pool;\n-        for (Field f: cf.fields) {\n-            test(\"field \" + cn + \".\" + f.getName(cp), f.descriptor, f.attributes, cp);\n+    void testFields(ClassModel cm) throws Exception {\n+        String cn = cm.thisClass().name().stringValue();\n+        for (FieldModel fm: cm.fields()) {\n+            test(\"field \" + cn + \".\" + fm.fieldName(), fm.fieldTypeSymbol(), fm);\n@@ -82,5 +83,4 @@\n-    void testMethods(ClassFile cf) throws Exception {\n-        String cn = cf.getName();\n-        ConstantPool cp = cf.constant_pool;\n-        for (Method m: cf.methods) {\n-            test(\"method \" + cn + \".\" + m.getName(cp), m.descriptor, m.attributes, cp);\n+    void testMethods(ClassModel cm) throws Exception {\n+        String cn = cm.thisClass().name().stringValue();\n+        for (MethodModel mm: cm.methods()) {\n+            test(\"method \" + cn + \".\" + mm.methodName(), mm.methodTypeSymbol(), mm);\n@@ -90,7 +90,7 @@\n-    void testInnerClasses(ClassFile cf) throws Exception {\n-        ConstantPool cp = cf.constant_pool;\n-        InnerClasses_attribute ic =\n-                (InnerClasses_attribute) cf.attributes.get(Attribute.InnerClasses);\n-        for (InnerClasses_attribute.Info info: ic.classes) {\n-            String outerClassName = cp.getClassInfo(info.outer_class_info_index).getName();\n-            if (!outerClassName.equals(cf.getName())) {\n+    void testInnerClasses(ClassModel cm) throws Exception {\n+        InnerClassesAttribute ic =\n+                cm.findAttribute(Attributes.INNER_CLASSES).orElse(null);\n+        assert ic != null;\n+        for (InnerClassInfo info: ic.classes()) {\n+            ClassEntry outerClass = info.outerClass().orElse(null);\n+            if (outerClass == null || !outerClass.name().equalsString(cm.getClass().getName())) {\n@@ -99,4 +99,4 @@\n-            String innerClassName = cp.getClassInfo(info.inner_class_info_index).getName();\n-            ClassFile icf = getClassFile(innerClassName);\n-            test(\"class \" + innerClassName, null, icf.attributes, icf.constant_pool);\n-            testInnerClasses(icf);\n+            String innerClassName = info.innerClass().asInternalName();\n+            ClassModel icm = getClassFile(innerClassName);\n+            test(\"class \" + innerClassName, null, icm);\n+            testInnerClasses(icm);\n@@ -106,4 +106,3 @@\n-    void test(String name, Descriptor desc, Attributes attrs, ConstantPool cp)\n-            throws Exception {\n-        AnnotValues d = getDescValue(attrs, cp);\n-        AnnotValues s = getSigValue(attrs, cp);\n+    void test(String name, ConstantDesc desc, AttributedElement m) {\n+        AnnotValues d = getDescValue(m);\n+        AnnotValues s = getSigValue(m);\n@@ -114,9 +113,1 @@\n-\n-        if (desc != null) {\n-            System.err.println(\"    descriptor: \" + desc.getValue(cp));\n-            checkEqual(d.raw, desc.getValue(cp));\n-            Type dt = new Signature(desc.index).getType(cp);\n-            checkEqual(d.type, tp.print(dt));\n-        }\n-\n-        Signature_attribute sa = (Signature_attribute) attrs.get(Attribute.Signature);\n+        SignatureAttribute sa = m.findAttribute(Attributes.SIGNATURE).orElse(null);\n@@ -124,11 +115,36 @@\n-            System.err.println(\"     signature: \" + sa.getSignature(cp));\n-\n-        if (s != null || sa != null) {\n-            if (s != null && sa != null) {\n-                checkEqual(s.raw, sa.getSignature(cp));\n-                Type st = new Signature(sa.signature_index).getType(cp);\n-                checkEqual(s.type, tp.print(st));\n-            } else if (s != null)\n-                error(\"@Sig annotation found but not Signature attribute\");\n-            else\n-                error(\"Signature attribute found but no @Sig annotation\");\n+            System.err.println(\"     signature: \" + sa.signature());\n+\n+        switch (desc) {\n+            case ClassDesc cDesc -> {\n+                System.err.println(\"    descriptor: \" + cDesc.descriptorString());\n+                checkEqual(d.raw, cDesc.descriptorString());\n+                Signature dt = Signature.of(cDesc);\n+                checkEqual(d.type, tp.print(dt));\n+                if (s != null || sa != null) {\n+                    if (s != null && sa != null) {\n+                        checkEqual(s.raw, sa.signature().stringValue());\n+                        Signature st = Signature.parseFrom(sa.signature().stringValue());\n+                        checkEqual(s.type, tp.print(st));\n+                    } else if (s != null)\n+                        error(\"@Sig annotation found but not Signature attribute\");\n+                    else\n+                        error(\"Signature attribute found but no @Sig annotation\");\n+                }\n+            }\n+            case MethodTypeDesc mDesc -> {\n+                System.err.println(\"    descriptor: \" + mDesc.descriptorString());\n+                checkEqual(d.raw, mDesc.descriptorString());\n+                MethodSignature mdt = MethodSignature.of(mDesc);\n+                checkEqual(d.type, tp.print(mdt));\n+                if (s != null || sa != null) {\n+                    if (s != null && sa != null) {\n+                        checkEqual(s.raw, sa.signature().stringValue());\n+                        MethodSignature mst = MethodSignature.parseFrom(sa.signature().stringValue());\n+                        checkEqual(s.type, tp.print(mst));\n+                    } else if (s != null)\n+                        error(\"@Sig annotation found but not Signature attribute\");\n+                    else\n+                        error(\"Signature attribute found but no @Sig annotation\");\n+                }\n+            }\n+            default -> throw new AssertionError();\n@@ -136,1 +152,0 @@\n-\n@@ -141,8 +156,4 @@\n-    ClassFile getClassFile(String name) throws IOException, ConstantPoolException {\n-        URL url = getClass().getResource(name + \".class\");\n-        InputStream in = url.openStream();\n-        try {\n-            return ClassFile.read(in);\n-        } finally {\n-            in.close();\n-        }\n+    ClassModel getClassFile(String name) throws IOException, URISyntaxException {\n+        URL rsc = getClass().getResource(name + \".class\");\n+        assert rsc != null;\n+        return Classfile.of().parse(Paths.get(rsc.toURI()));\n@@ -151,2 +162,2 @@\n-    AnnotValues getDescValue(Attributes attrs, ConstantPool cp) throws Exception {\n-        return getAnnotValues(Desc.class.getName(), attrs, cp);\n+    AnnotValues getDescValue(AttributedElement m) {\n+        return getAnnotValues(Desc.class.getName(), m);\n@@ -155,2 +166,2 @@\n-    AnnotValues getSigValue(Attributes attrs, ConstantPool cp) throws Exception {\n-        return getAnnotValues(Sig.class.getName(), attrs, cp);\n+    AnnotValues getSigValue(AttributedElement m) {\n+        return getAnnotValues(Sig.class.getName(), m);\n@@ -168,4 +179,2 @@\n-    AnnotValues getAnnotValues(String annotName, Attributes attrs, ConstantPool cp)\n-            throws Exception {\n-        RuntimeInvisibleAnnotations_attribute annots =\n-                (RuntimeInvisibleAnnotations_attribute)attrs.get(Attribute.RuntimeInvisibleAnnotations);\n+    AnnotValues getAnnotValues(String annotName, AttributedElement m) {\n+        RuntimeInvisibleAnnotationsAttribute annots = m.findAttribute(Attributes.RUNTIME_INVISIBLE_ANNOTATIONS).orElse(null);\n@@ -173,9 +182,5 @@\n-            for (Annotation a: annots.annotations) {\n-                if (cp.getUTF8Value(a.type_index).equals(\"L\" + annotName + \";\")) {\n-                    Annotation.Primitive_element_value pv0 =\n-                            (Annotation.Primitive_element_value) a.element_value_pairs[0].value;\n-                    Annotation.Primitive_element_value pv1 =\n-                            (Annotation.Primitive_element_value) a.element_value_pairs[1].value;\n-                    return new AnnotValues(\n-                            cp.getUTF8Value(pv0.const_value_index),\n-                            cp.getUTF8Value(pv1.const_value_index));\n+            for (Annotation a: annots.annotations()) {\n+                if (a.classSymbol().descriptorString().equals(\"L\" + annotName + \";\")) {\n+                    String pv0 = ((AnnotationValue.OfString) a.elements().get(0).value()).stringValue();\n+                    String pv1 = ((AnnotationValue.OfString) a.elements().get(1).value()).stringValue();\n+                    return new AnnotValues(pv0, pv1);\n@@ -190,1 +195,1 @@\n-        if (!(expect == null ? found == null : expect.equals(found))) {\n+        if (!(Objects.equals(expect, found))) {\n@@ -206,3 +211,25 @@\n-    class TypePrinter implements Type.Visitor<String,Void> {\n-        String print(Type t) {\n-            return t == null ? null : t.accept(this, null);\n+    class TypePrinter {\n+        <T> String print(T t) {\n+            switch (t) {\n+                case Signature.BaseTypeSig type -> {\n+                    return visitSimpleType(type);\n+                }\n+                case Signature.ArrayTypeSig type -> {\n+                    return visitArrayType(type);\n+                }\n+                case Signature.ClassTypeSig type -> {\n+                    return visitClassType(type);\n+                }\n+                case ClassSignature type -> {\n+                    return visitClassSigType(type);\n+                }\n+                case MethodSignature type -> {\n+                    return visitMethodType(type);\n+                }\n+                case Signature.TypeVarSig type -> {\n+                    return \"S{\" + type.identifier() + \"}\"; \/\/Consider the TypeVarSig as Simple Type\n+                }\n+                default -> {\n+                    return null;\n+                }\n+            }\n@@ -210,1 +237,1 @@\n-        String print(String pre, List<? extends Type> ts, String post) {\n+        <T> String print(String pre, List<T> ts, String post) {\n@@ -216,1 +243,1 @@\n-            for (Type t: ts) {\n+            for (T t: ts) {\n@@ -218,1 +245,6 @@\n-                sb.append(print(t));\n+                switch (t) {\n+                    case Signature sig -> sb.append(print(sig));\n+                    case Signature.TypeParam pSig -> sb.append(visitTypeParamType(pSig));\n+                    case Signature.TypeArg aSig -> sb.append(visitWildcardType(aSig));\n+                    default -> throw new AssertionError();\n+                }\n@@ -225,2 +257,2 @@\n-        public String visitSimpleType(SimpleType type, Void p) {\n-            return \"S{\" + type.name + \"}\";\n+        public String visitSimpleType(Signature.BaseTypeSig type) {\n+            return \"S{\" + type.baseType() + \"}\";\n@@ -229,2 +261,2 @@\n-        public String visitArrayType(ArrayType type, Void p) {\n-            return \"A{\" + print(type.elemType) + \"}\";\n+        public String visitArrayType(Signature.ArrayTypeSig type) {\n+            return \"A{\" + print(type.componentSignature()) + \"}\";\n@@ -233,1 +265,1 @@\n-        public String visitMethodType(MethodType type, Void p) {\n+        public String visitMethodType(MethodSignature type) {\n@@ -236,6 +268,6 @@\n-            if (type.typeParamTypes != null)\n-                sb.append(print(\"<\", type.typeParamTypes, \">\"));\n-            sb.append(print(type.returnType));\n-            sb.append(print(\"(\", type.paramTypes, \")\"));\n-            if (type.throwsTypes != null)\n-                sb.append(print(\"\", type.throwsTypes, \"\"));\n+            if (!type.typeParameters().isEmpty())\n+                sb.append(print(\"<\", type.typeParameters(), \">\"));\n+            sb.append(print(type.result()));\n+            sb.append(print(\"(\", type.arguments(), \")\"));\n+            if (!type.throwableSignatures().isEmpty())\n+                sb.append(print(\"\", type.throwableSignatures(), \"\"));\n@@ -246,1 +278,1 @@\n-        public String visitClassSigType(ClassSigType type, Void p) {\n+        public String visitClassSigType(ClassSignature type) {\n@@ -249,5 +281,5 @@\n-            if (type.typeParamTypes != null)\n-                sb.append(print(\"<\", type.typeParamTypes, \">\"));\n-            sb.append(print(type.superclassType));\n-            if (type.superinterfaceTypes != null)\n-                sb.append(print(\"i(\", type.superinterfaceTypes, \")\"));\n+            if (!type.typeParameters().isEmpty())\n+                sb.append(print(\"<\", type.typeParameters(), \">\"));\n+            sb.append(print(type.superclassSignature()));\n+            if (!type.superinterfaceSignatures().isEmpty())\n+                sb.append(print(\"i(\", type.superinterfaceSignatures(), \")\"));\n@@ -258,1 +290,1 @@\n-        public String visitClassType(ClassType type, Void p) {\n+        public String visitClassType(Signature.ClassTypeSig type) {\n@@ -261,2 +293,2 @@\n-            if (type.outerType != null) {\n-                sb.append(print(type.outerType));\n+            if (type.outerType().isPresent()) {\n+                sb.append(print(type.outerType().get()));\n@@ -265,3 +297,3 @@\n-            sb.append(type.name);\n-            if (type.typeArgs != null)\n-                sb.append(print(\"<\", type.typeArgs, \">\"));\n+            sb.append(type.className());\n+            if (!type.typeArgs().isEmpty())\n+                sb.append(print(\"<\", type.typeArgs(), \">\"));\n@@ -272,1 +304,1 @@\n-        public String visitTypeParamType(TypeParamType type, Void p) {\n+        public String visitTypeParamType(Signature.TypeParam type) {\n@@ -275,2 +307,2 @@\n-            sb.append(type.name);\n-            if (type.classBound != null) {\n+            sb.append(type.identifier());\n+            if (type.classBound().isPresent()) {\n@@ -278,1 +310,1 @@\n-                sb.append(print(type.classBound));\n+                sb.append(print(type.classBound().get()));\n@@ -280,2 +312,2 @@\n-            if (type.interfaceBounds != null)\n-                sb.append(print(\":i\", type.interfaceBounds, \"\"));\n+            if (!type.interfaceBounds().isEmpty())\n+                sb.append(print(\":i\", type.interfaceBounds(), \"\"));\n@@ -286,3 +318,3 @@\n-        public String visitWildcardType(WildcardType type, Void p) {\n-            switch (type.kind) {\n-                case UNBOUNDED:\n+        public String visitWildcardType(Signature.TypeArg type) {\n+            switch (type.wildcardIndicator()) {\n+                case UNBOUNDED -> {\n@@ -290,6 +322,11 @@\n-                case EXTENDS:\n-                    return \"W{e,\" + print(type.boundType) + \"}\";\n-                case SUPER:\n-                    return \"W{s,\" + print(type.boundType) + \"}\";\n-                default:\n-                    throw new AssertionError();\n+                }\n+                case EXTENDS -> {\n+                    return \"W{e,\" + print(type.boundType().get()) + \"}\";\n+                }\n+                case SUPER -> {\n+                    return \"W{s,\" + print(type.boundType().get()) + \"}\";\n+                }\n+                default -> {\n+                    if (type.boundType().isPresent()) return print(type.boundType().get());\n+                    else throw new AssertionError();\n+                }\n@@ -320,1 +357,1 @@\n-    @Desc(d=\"Z\", t=\"S{boolean}\")\n+    @Desc(d=\"Z\", t=\"S{Z}\")\n@@ -323,1 +360,1 @@\n-    @Desc(d=\"B\", t=\"S{byte}\")\n+    @Desc(d=\"B\", t=\"S{B}\")\n@@ -326,1 +363,1 @@\n-    @Desc(d=\"C\", t=\"S{char}\")\n+    @Desc(d=\"C\", t=\"S{C}\")\n@@ -329,1 +366,1 @@\n-    @Desc(d=\"D\", t=\"S{double}\")\n+    @Desc(d=\"D\", t=\"S{D}\")\n@@ -332,1 +369,1 @@\n-    @Desc(d=\"F\", t=\"S{float}\")\n+    @Desc(d=\"F\", t=\"S{F}\")\n@@ -335,1 +372,1 @@\n-    @Desc(d=\"I\", t=\"S{int}\")\n+    @Desc(d=\"I\", t=\"S{I}\")\n@@ -338,1 +375,1 @@\n-    @Desc(d=\"J\", t=\"S{long}\")\n+    @Desc(d=\"J\", t=\"S{J}\")\n@@ -341,1 +378,1 @@\n-    @Desc(d=\"S\", t=\"S{short}\")\n+    @Desc(d=\"S\", t=\"S{S}\")\n@@ -350,1 +387,1 @@\n-    @Desc(d=\"[I\", t=\"A{S{int}}\")\n+    @Desc(d=\"[I\", t=\"A{S{I}}\")\n@@ -362,1 +399,1 @@\n-    @Desc(d=\"()V\", t=\"M{S{void}()}\")\n+    @Desc(d=\"()V\", t=\"M{S{V}()}\")\n@@ -365,1 +402,1 @@\n-    @Desc(d=\"()I\", t=\"M{S{int}()}\")\n+    @Desc(d=\"()I\", t=\"M{S{I}()}\")\n@@ -371,1 +408,1 @@\n-    @Desc(d=\"()[I\", t=\"M{A{S{int}}()}\")\n+    @Desc(d=\"()[I\", t=\"M{A{S{I}}()}\")\n@@ -408,1 +445,1 @@\n-    @Desc(d=\"(I)V\", t=\"M{S{void}(S{int})}\")\n+    @Desc(d=\"(I)V\", t=\"M{S{V}(S{I})}\")\n@@ -411,1 +448,1 @@\n-    @Desc(d=\"(LClss;)V\", t=\"M{S{void}(C{Clss})}\")\n+    @Desc(d=\"(LClss;)V\", t=\"M{S{V}(C{Clss})}\")\n@@ -414,1 +451,1 @@\n-    @Desc(d=\"([I)V\", t=\"M{S{void}(A{S{int}})}\")\n+    @Desc(d=\"([I)V\", t=\"M{S{V}(A{S{I}})}\")\n@@ -417,1 +454,1 @@\n-    @Desc(d=\"([LClss;)V\", t=\"M{S{void}(A{C{Clss}})}\")\n+    @Desc(d=\"([LClss;)V\", t=\"M{S{V}(A{C{Clss}})}\")\n@@ -420,2 +457,2 @@\n-    @Desc(d=\"(LGenClss;)V\", t=\"M{S{void}(C{GenClss})}\")\n-    @Sig(s=\"(LGenClss<LClss;>;)V\", t=\"M{S{void}(C{GenClss<C{Clss}>})}\")\n+    @Desc(d=\"(LGenClss;)V\", t=\"M{S{V}(C{GenClss})}\")\n+    @Sig(s=\"(LGenClss<LClss;>;)V\", t=\"M{S{V}(C{GenClss<C{Clss}>})}\")\n@@ -424,2 +461,2 @@\n-    @Desc(d=\"(LGenClss;)V\", t=\"M{S{void}(C{GenClss})}\")\n-    @Sig(s=\"(LGenClss<*>;)V\", t=\"M{S{void}(C{GenClss<W{?}>})}\")\n+    @Desc(d=\"(LGenClss;)V\", t=\"M{S{V}(C{GenClss})}\")\n+    @Sig(s=\"(LGenClss<*>;)V\", t=\"M{S{V}(C{GenClss<W{?}>})}\")\n@@ -428,2 +465,2 @@\n-    @Desc(d=\"(LGenClss;)V\", t=\"M{S{void}(C{GenClss})}\")\n-    @Sig(s=\"(LGenClss<+LClss;>;)V\", t=\"M{S{void}(C{GenClss<W{e,C{Clss}}>})}\")\n+    @Desc(d=\"(LGenClss;)V\", t=\"M{S{V}(C{GenClss})}\")\n+    @Sig(s=\"(LGenClss<+LClss;>;)V\", t=\"M{S{V}(C{GenClss<W{e,C{Clss}}>})}\")\n@@ -432,2 +469,2 @@\n-    @Desc(d=\"(LGenClss;)V\", t=\"M{S{void}(C{GenClss})}\")\n-    @Sig(s=\"(LGenClss<-LClss;>;)V\", t=\"M{S{void}(C{GenClss<W{s,C{Clss}}>})}\")\n+    @Desc(d=\"(LGenClss;)V\", t=\"M{S{V}(C{GenClss})}\")\n+    @Sig(s=\"(LGenClss<-LClss;>;)V\", t=\"M{S{V}(C{GenClss<W{s,C{Clss}}>})}\")\n@@ -436,1 +473,1 @@\n-    @Desc(d=\"(Ljava\/lang\/Object;)V\", t=\"M{S{void}(C{java\/lang\/Object})}\")\n+    @Desc(d=\"(Ljava\/lang\/Object;)V\", t=\"M{S{V}(C{java\/lang\/Object})}\")\n@@ -438,1 +475,1 @@\n-        t=\"M{<TA{T:cC{java\/lang\/Object}}>S{void}(S{T})}\")\n+        t=\"M{<TA{T:cC{java\/lang\/Object}}>S{V}(S{T})}\")\n@@ -441,1 +478,1 @@\n-    @Desc(d=\"(LGenClss;)V\", t=\"M{S{void}(C{GenClss})}\")\n+    @Desc(d=\"(LGenClss;)V\", t=\"M{S{V}(C{GenClss})}\")\n@@ -443,1 +480,1 @@\n-        t=\"M{<TA{T:cC{java\/lang\/Object}}>S{void}(C{GenClss<W{e,S{T}}>})}\")\n+        t=\"M{<TA{T:cC{java\/lang\/Object}}>S{V}(C{GenClss<W{e,S{T}}>})}\")\n@@ -446,1 +483,1 @@\n-    @Desc(d=\"(LGenClss;)V\", t=\"M{S{void}(C{GenClss})}\")\n+    @Desc(d=\"(LGenClss;)V\", t=\"M{S{V}(C{GenClss})}\")\n@@ -448,1 +485,1 @@\n-        t=\"M{<TA{T:cC{java\/lang\/Object}}>S{void}(C{GenClss<W{s,S{T}}>})}\")\n+        t=\"M{<TA{T:cC{java\/lang\/Object}}>S{V}(C{GenClss<W{s,S{T}}>})}\")\n@@ -453,1 +490,1 @@\n-    @Desc(d=\"()V\", t=\"M{S{void}()}\")\n+    @Desc(d=\"()V\", t=\"M{S{V}()}\")\n@@ -456,1 +493,1 @@\n-    @Desc(d=\"()V\", t=\"M{S{void}()}\")\n+    @Desc(d=\"()V\", t=\"M{S{V}()}\")\n@@ -458,1 +495,1 @@\n-        t=\"M{<TA{T:cC{java\/lang\/Throwable}}>S{void}()S{T}}\")\n+        t=\"M{<TA{T:cC{java\/lang\/Throwable}}>S{V}()S{T}}\")\n","filename":"test\/langtools\/tools\/javap\/classfile\/6888367\/T6888367.java","additions":199,"deletions":162,"binary":false,"changes":361,"status":"modified"},{"patch":"@@ -27,2 +27,6 @@\n- * @summary CONSTANT_Class_info getBaseName does not handle arrays of primitives correctly\n- * @modules jdk.jdeps\/com.sun.tools.classfile\n+ * @summary test getting constantpool elements' basename through asInternalName() API\n+ * @modules java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.classfile.attribute\n+ *          java.base\/jdk.internal.classfile.constantpool\n+ *          java.base\/jdk.internal.classfile.instruction\n+ *          java.base\/jdk.internal.classfile.components\n@@ -33,0 +37,1 @@\n+import java.nio.file.Paths;\n@@ -34,2 +39,2 @@\n-import com.sun.tools.classfile.*;\n-import com.sun.tools.classfile.ConstantPool.*;\n+import jdk.internal.classfile.*;\n+import jdk.internal.classfile.constantpool.*;\n@@ -45,9 +50,8 @@\n-        ClassFile cf = getClassFile(\"T6887895$Test.class\");\n-        for (CPInfo cpInfo: cf.constant_pool.entries()) {\n-            if (cpInfo instanceof CONSTANT_Class_info) {\n-                CONSTANT_Class_info info = (CONSTANT_Class_info) cpInfo;\n-                String name = info.getName();\n-                String baseName = info.getBaseName();\n-                System.out.println(\"found: \" + name + \" \" + baseName);\n-                if (baseName != null)\n-                    found.add(baseName);\n+        ClassModel cm = getClassFile(\"T6887895$Test.class\");\n+        ConstantPool cp = cm.constantPool();\n+        for (int i = 1; i < cp.entryCount(); ++i) {\n+            if (cp.entryByIndex(i) instanceof ClassEntry ce) {\n+                String name = ce.asInternalName();\n+                System.out.println(\"found: \" + name);\n+                if (ce.asSymbol().isClassOrInterface())\n+                    found.add(name);\n@@ -58,4 +62,4 @@\n-            \"java\/lang\/Object\",\n-            \"java\/lang\/String\",\n-            \"T6887895\",\n-            \"T6887895$Test\"\n+                \"java\/lang\/Object\",\n+                \"java\/lang\/String\",\n+                \"T6887895\",\n+                \"T6887895$Test\"\n@@ -72,8 +76,3 @@\n-    ClassFile getClassFile(String name) throws IOException, ConstantPoolException {\n-        URL url = getClass().getResource(name);\n-        InputStream in = url.openStream();\n-        try {\n-            return ClassFile.read(in);\n-        } finally {\n-            in.close();\n-        }\n+    ClassModel getClassFile(String name) throws IOException, URISyntaxException {\n+        URL rsc = getClass().getResource(name);\n+        return Classfile.of().parse(Paths.get(rsc.toURI()));\n","filename":"test\/langtools\/tools\/javap\/classfile\/T6887895.java","additions":24,"deletions":25,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -25,1 +25,3 @@\n-import com.sun.tools.classfile.*;\n+import jdk.internal.classfile.*;\n+import jdk.internal.classfile.Attributes;\n+import jdk.internal.classfile.attribute.*;\n@@ -31,1 +33,5 @@\n- * @modules jdk.jdeps\/com.sun.tools.classfile\n+ * @modules java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.classfile.attribute\n+ *          java.base\/jdk.internal.classfile.constantpool\n+ *          java.base\/jdk.internal.classfile.instruction\n+ *          java.base\/jdk.internal.classfile.components\n@@ -43,3 +49,3 @@\n-        ClassFile cf = ClassFile.read(classFile);\n-        for (Field f : cf.fields) {\n-            test(cf, f);\n+        ClassModel cm = Classfile.of().parse(classFile.toPath());\n+        for (MethodModel mm: cm.methods()) {\n+            test(mm);\n@@ -47,2 +53,2 @@\n-        for (Method m: cf.methods) {\n-            test(cf, m);\n+        for (FieldModel fm: cm.fields()) {\n+            test(fm);\n@@ -58,3 +64,3 @@\n-    void test(ClassFile cf, Method m) {\n-        test(cf, m, Attribute.RuntimeVisibleTypeAnnotations, true);\n-        test(cf, m, Attribute.RuntimeInvisibleTypeAnnotations, false);\n+    void test(AttributedElement m) {\n+        test(m, Attributes.RUNTIME_VISIBLE_TYPE_ANNOTATIONS);\n+        test(m, Attributes.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS);\n@@ -63,34 +69,15 @@\n-    void test(ClassFile cf, Field m) {\n-        test(cf, m, Attribute.RuntimeVisibleTypeAnnotations, true);\n-        test(cf, m, Attribute.RuntimeInvisibleTypeAnnotations, false);\n-    }\n-\n-    \/\/ test the result of Attributes.getIndex according to expectations\n-    \/\/ encoded in the method's name\n-    void test(ClassFile cf, Method m, String name, boolean visible) {\n-        int index = m.attributes.getIndex(cf.constant_pool, name);\n-        if (index != -1) {\n-            Attribute attr = m.attributes.get(index);\n-            assert attr instanceof RuntimeTypeAnnotations_attribute;\n-            RuntimeTypeAnnotations_attribute tAttr = (RuntimeTypeAnnotations_attribute)attr;\n-            all += tAttr.annotations.length;\n-            if (visible)\n-                visibles += tAttr.annotations.length;\n-            else\n-                invisibles += tAttr.annotations.length;\n-        }\n-    }\n-\n-    \/\/ test the result of Attributes.getIndex according to expectations\n-    \/\/ encoded in the method's name\n-    void test(ClassFile cf, Field m, String name, boolean visible) {\n-        int index = m.attributes.getIndex(cf.constant_pool, name);\n-        if (index != -1) {\n-            Attribute attr = m.attributes.get(index);\n-            assert attr instanceof RuntimeTypeAnnotations_attribute;\n-            RuntimeTypeAnnotations_attribute tAttr = (RuntimeTypeAnnotations_attribute)attr;\n-            all += tAttr.annotations.length;\n-            if (visible)\n-                visibles += tAttr.annotations.length;\n-            else\n-                invisibles += tAttr.annotations.length;\n+    \/\/ test the result of AttributedElement.findAttribute according to expectations\n+    <T extends jdk.internal.classfile.Attribute<T>> void test(AttributedElement m, AttributeMapper<T> attr_name) {\n+        Attribute<T> attr_instance = m.findAttribute(attr_name).orElse(null);\n+        if (attr_instance != null) {\n+            switch (attr_instance) {\n+                case RuntimeVisibleTypeAnnotationsAttribute tAttr -> {\n+                    all += tAttr.annotations().size();\n+                    visibles += tAttr.annotations().size();\n+                }\n+                case RuntimeInvisibleTypeAnnotationsAttribute tAttr -> {\n+                    all += tAttr.annotations().size();\n+                    invisibles += tAttr.annotations().size();\n+                }\n+                default -> throw new AssertionError();\n+            }\n","filename":"test\/langtools\/tools\/javap\/typeAnnotations\/JSR175Annotations.java","additions":31,"deletions":44,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -25,1 +25,2 @@\n-import com.sun.tools.classfile.*;\n+import jdk.internal.classfile.*;\n+import jdk.internal.classfile.attribute.*;\n@@ -31,1 +32,5 @@\n- * @modules jdk.jdeps\/com.sun.tools.classfile\n+ * @modules java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.classfile.attribute\n+ *          java.base\/jdk.internal.classfile.constantpool\n+ *          java.base\/jdk.internal.classfile.instruction\n+ *          java.base\/jdk.internal.classfile.components\n@@ -35,1 +40,0 @@\n-\n@@ -44,3 +48,3 @@\n-        ClassFile cf = ClassFile.read(classFile);\n-        for (Method m: cf.methods) {\n-            test(cf, m);\n+        ClassModel cm = Classfile.of().parse(classFile.toPath());\n+        for (MethodModel mm: cm.methods()) {\n+            test(mm);\n@@ -48,1 +52,0 @@\n-\n@@ -50,1 +53,0 @@\n-\n@@ -56,3 +58,3 @@\n-    void test(ClassFile cf, Method m) {\n-        test(cf, m, Attribute.RuntimeVisibleTypeAnnotations, true);\n-        test(cf, m, Attribute.RuntimeInvisibleTypeAnnotations, false);\n+    void test(MethodModel mm) {\n+        test(mm, Attributes.RUNTIME_VISIBLE_TYPE_ANNOTATIONS);\n+        test(mm, Attributes.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS);\n@@ -63,21 +65,20 @@\n-    void test(ClassFile cf, Method m, String name, boolean visible) {\n-        Attribute attr = null;\n-        Code_attribute cAttr = null;\n-        RuntimeTypeAnnotations_attribute tAttr = null;\n-\n-        int index = m.attributes.getIndex(cf.constant_pool, Attribute.Code);\n-        if(index!= -1) {\n-            attr = m.attributes.get(index);\n-            assert attr instanceof Code_attribute;\n-            cAttr = (Code_attribute)attr;\n-            index = cAttr.attributes.getIndex(cf.constant_pool, name);\n-            if(index!= -1) {\n-                attr = cAttr.attributes.get(index);\n-                assert attr instanceof RuntimeTypeAnnotations_attribute;\n-                tAttr = (RuntimeTypeAnnotations_attribute)attr;\n-                all += tAttr.annotations.length;\n-                if (visible)\n-                    visibles += tAttr.annotations.length;\n-                else\n-                    invisibles += tAttr.annotations.length;\n-               }\n+    <T extends Attribute<T>> void test(MethodModel mm, AttributeMapper<T> attr_name) {\n+        Attribute<T> attr_instance;\n+        CodeAttribute cAttr;\n+\n+        cAttr = mm.findAttribute(Attributes.CODE).orElse(null);\n+        if (cAttr != null) {\n+            attr_instance = cAttr.findAttribute(attr_name).orElse(null);\n+            if (attr_instance != null) {\n+                switch (attr_instance) {\n+                    case RuntimeVisibleTypeAnnotationsAttribute tAttr -> {\n+                        all += tAttr.annotations().size();\n+                        visibles += tAttr.annotations().size();\n+                    }\n+                    case RuntimeInvisibleTypeAnnotationsAttribute tAttr -> {\n+                        all += tAttr.annotations().size();\n+                        invisibles += tAttr.annotations().size();\n+                    }\n+                    default -> throw new AssertionError();\n+                }\n+            }\n@@ -88,1 +89,1 @@\n-      File f = new File(\"Test.java\");\n+        File f = new File(\"Test.java\");\n@@ -136,1 +137,0 @@\n-\n","filename":"test\/langtools\/tools\/javap\/typeAnnotations\/NewArray.java","additions":34,"deletions":34,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -26,2 +26,2 @@\n-\n-import com.sun.tools.classfile.*;\n+import jdk.internal.classfile.*;\n+import jdk.internal.classfile.attribute.*;\n@@ -33,1 +33,5 @@\n- * @modules jdk.jdeps\/com.sun.tools.classfile\n+ * @modules java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.classfile.attribute\n+ *          java.base\/jdk.internal.classfile.constantpool\n+ *          java.base\/jdk.internal.classfile.instruction\n+ *          java.base\/jdk.internal.classfile.components\n@@ -45,4 +49,4 @@\n-        ClassFile cf = ClassFile.read(classFile);\n-        test(cf);\n-        for (Field f : cf.fields) {\n-            test(cf, f);\n+        ClassModel cm = Classfile.of().parse(classFile.toPath());\n+        test(cm);\n+        for (FieldModel fm : cm.fields()) {\n+            test(fm);\n@@ -50,2 +54,2 @@\n-        for (Method m: cf.methods) {\n-            test(cf, m);\n+        for (MethodModel mm: cm.methods()) {\n+            test(mm);\n@@ -61,29 +65,3 @@\n-    void test(ClassFile cf) {\n-        test(cf, Attribute.RuntimeVisibleTypeAnnotations, true);\n-        test(cf, Attribute.RuntimeInvisibleTypeAnnotations, false);\n-    }\n-\n-    void test(ClassFile cf, Method m) {\n-        test(cf, m, Attribute.RuntimeVisibleTypeAnnotations, true);\n-        test(cf, m, Attribute.RuntimeInvisibleTypeAnnotations, false);\n-    }\n-\n-    void test(ClassFile cf, Field m) {\n-        test(cf, m, Attribute.RuntimeVisibleTypeAnnotations, true);\n-        test(cf, m, Attribute.RuntimeInvisibleTypeAnnotations, false);\n-    }\n-\n-    \/\/ test the result of Attributes.getIndex according to expectations\n-    \/\/ encoded in the method's name\n-    void test(ClassFile cf, String name, boolean visible) {\n-        int index = cf.attributes.getIndex(cf.constant_pool, name);\n-        if (index != -1) {\n-            Attribute attr = cf.attributes.get(index);\n-            assert attr instanceof RuntimeTypeAnnotations_attribute;\n-            RuntimeTypeAnnotations_attribute tAttr = (RuntimeTypeAnnotations_attribute)attr;\n-            all += tAttr.annotations.length;\n-            if (visible)\n-                visibles += tAttr.annotations.length;\n-            else\n-                invisibles += tAttr.annotations.length;\n-        }\n+    void test(AttributedElement m) {\n+        test(m, Attributes.RUNTIME_VISIBLE_TYPE_ANNOTATIONS);\n+        test(m, Attributes.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS);\n@@ -92,18 +70,15 @@\n-    \/\/ test the result of Attributes.getIndex according to expectations\n-    \/\/ encoded in the method's name\n-    void test(ClassFile cf, Method m, String name, boolean visible) {\n-        Attribute attr = null;\n-        Code_attribute cAttr = null;\n-        RuntimeTypeAnnotations_attribute tAttr = null;\n-\n-        \/\/ collect annotations attributes on method\n-        int index = m.attributes.getIndex(cf.constant_pool, name);\n-        if (index != -1) {\n-            attr = m.attributes.get(index);\n-            assert attr instanceof RuntimeTypeAnnotations_attribute;\n-            tAttr = (RuntimeTypeAnnotations_attribute)attr;\n-            all += tAttr.annotations.length;\n-            if (visible)\n-                visibles += tAttr.annotations.length;\n-            else\n-                invisibles += tAttr.annotations.length;\n+    \/\/ test the result of AttributedElement.findAttribute according to expectations\n+    <T extends Attribute<T>> void test(AttributedElement m, AttributeMapper<T> attr_name) {\n+        Object attr_instance = m.findAttribute(attr_name).orElse(null);\n+        if (attr_instance != null) {\n+            switch (attr_instance) {\n+                case RuntimeVisibleTypeAnnotationsAttribute tAttr -> {\n+                    all += tAttr.annotations().size();\n+                    visibles += tAttr.annotations().size();\n+                }\n+                case RuntimeInvisibleTypeAnnotationsAttribute tAttr -> {\n+                    all += tAttr.annotations().size();\n+                    invisibles += tAttr.annotations().size();\n+                }\n+                default -> throw new AssertionError();\n+            }\n@@ -111,17 +86,19 @@\n-        \/\/ collect annotations from method's code attribute\n-        index = m.attributes.getIndex(cf.constant_pool, Attribute.Code);\n-        if(index!= -1) {\n-            attr = m.attributes.get(index);\n-            assert attr instanceof Code_attribute;\n-            cAttr = (Code_attribute)attr;\n-            index = cAttr.attributes.getIndex(cf.constant_pool, name);\n-            if(index!= -1) {\n-                attr = cAttr.attributes.get(index);\n-                assert attr instanceof RuntimeTypeAnnotations_attribute;\n-                tAttr = (RuntimeTypeAnnotations_attribute)attr;\n-                all += tAttr.annotations.length;\n-                if (visible)\n-                    visibles += tAttr.annotations.length;\n-                else\n-                    invisibles += tAttr.annotations.length;\n-               }\n+        if (m instanceof MethodModel) {\n+            attr_instance = m.findAttribute(Attributes.CODE).orElse(null);\n+            if(attr_instance!= null) {\n+                CodeAttribute cAttr = (CodeAttribute)attr_instance;\n+                attr_instance = cAttr.findAttribute(attr_name).orElse(null);\n+                if(attr_instance!= null) {\n+                    switch (attr_instance) {\n+                        case RuntimeVisibleTypeAnnotationsAttribute tAttr -> {\n+                            all += tAttr.annotations().size();\n+                            visibles += tAttr.annotations().size();\n+                        }\n+                        case RuntimeInvisibleTypeAnnotationsAttribute tAttr -> {\n+                            all += tAttr.annotations().size();\n+                            invisibles += tAttr.annotations().size();\n+                        }\n+                        default -> throw new AssertionError();\n+                    }\n+                }\n+            }\n@@ -131,15 +108,1 @@\n-    \/\/ test the result of Attributes.getIndex according to expectations\n-    \/\/ encoded in the method's name\n-    void test(ClassFile cf, Field m, String name, boolean visible) {\n-        int index = m.attributes.getIndex(cf.constant_pool, name);\n-        if (index != -1) {\n-            Attribute attr = m.attributes.get(index);\n-            assert attr instanceof RuntimeTypeAnnotations_attribute;\n-            RuntimeTypeAnnotations_attribute tAttr = (RuntimeTypeAnnotations_attribute)attr;\n-            all += tAttr.annotations.length;\n-            if (visible)\n-                visibles += tAttr.annotations.length;\n-            else\n-                invisibles += tAttr.annotations.length;\n-        }\n-    }\n+\n","filename":"test\/langtools\/tools\/javap\/typeAnnotations\/Presence.java","additions":51,"deletions":88,"binary":false,"changes":139,"status":"modified"},{"patch":"@@ -25,1 +25,2 @@\n-import com.sun.tools.classfile.*;\n+import jdk.internal.classfile.*;\n+import jdk.internal.classfile.attribute.*;\n@@ -31,1 +32,5 @@\n- * @modules jdk.jdeps\/com.sun.tools.classfile\n+ * @modules java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.classfile.attribute\n+ *          java.base\/jdk.internal.classfile.constantpool\n+ *          java.base\/jdk.internal.classfile.instruction\n+ *          java.base\/jdk.internal.classfile.components\n@@ -43,4 +48,4 @@\n-        ClassFile cf = ClassFile.read(classFile);\n-        test(cf);\n-        for (Field f : cf.fields) {\n-            test(cf, f);\n+        ClassModel cm = Classfile.of().parse(classFile.toPath());\n+        test(cm);\n+        for (FieldModel fm : cm.fields()) {\n+            test(fm);\n@@ -48,2 +53,2 @@\n-        for (Method m: cf.methods) {\n-            test(cf, m);\n+        for (MethodModel mm: cm.methods()) {\n+            test(mm);\n@@ -57,4 +62,4 @@\n-        ClassFile icf = ClassFile.read(innerFile);\n-        test(icf);\n-        for (Field f : icf.fields) {\n-            test(cf, f);\n+        ClassModel icm = Classfile.of().parse(innerFile.toPath());\n+        test(icm);\n+        for (FieldModel fm : icm.fields()) {\n+            test(fm);\n@@ -62,2 +67,2 @@\n-        for (Method m: icf.methods) {\n-            test(cf, m);\n+        for (MethodModel mm: icm.methods()) {\n+            test(mm);\n@@ -72,3 +77,3 @@\n-    void test(ClassFile cf) {\n-        test(cf, Attribute.RuntimeVisibleTypeAnnotations, true);\n-        test(cf, Attribute.RuntimeInvisibleTypeAnnotations, false);\n+    void test(AttributedElement m) {\n+        test(m, Attributes.RUNTIME_VISIBLE_TYPE_ANNOTATIONS);\n+        test(m, Attributes.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS);\n@@ -77,55 +82,15 @@\n-    void test(ClassFile cf, Method m) {\n-        test(cf, m, Attribute.RuntimeVisibleTypeAnnotations, true);\n-        test(cf, m, Attribute.RuntimeInvisibleTypeAnnotations, false);\n-    }\n-\n-    void test(ClassFile cf, Field m) {\n-        test(cf, m, Attribute.RuntimeVisibleTypeAnnotations, true);\n-        test(cf, m, Attribute.RuntimeInvisibleTypeAnnotations, false);\n-    }\n-\n-    \/\/ test the result of Attributes.getIndex according to expectations\n-    \/\/ encoded in the method's name\n-    void test(ClassFile cf, String name, boolean visible) {\n-        int index = cf.attributes.getIndex(cf.constant_pool, name);\n-        if (index != -1) {\n-            Attribute attr = cf.attributes.get(index);\n-            assert attr instanceof RuntimeTypeAnnotations_attribute;\n-            RuntimeTypeAnnotations_attribute tAttr = (RuntimeTypeAnnotations_attribute)attr;\n-            all += tAttr.annotations.length;\n-            if (visible)\n-                visibles += tAttr.annotations.length;\n-            else\n-                invisibles += tAttr.annotations.length;\n-        }\n-    }\n-\n-    \/\/ test the result of Attributes.getIndex according to expectations\n-    \/\/ encoded in the method's name\n-    void test(ClassFile cf, Method m, String name, boolean visible) {\n-        int index = m.attributes.getIndex(cf.constant_pool, name);\n-        if (index != -1) {\n-            Attribute attr = m.attributes.get(index);\n-            assert attr instanceof RuntimeTypeAnnotations_attribute;\n-            RuntimeTypeAnnotations_attribute tAttr = (RuntimeTypeAnnotations_attribute)attr;\n-            all += tAttr.annotations.length;\n-            if (visible)\n-                visibles += tAttr.annotations.length;\n-            else\n-                invisibles += tAttr.annotations.length;\n-        }\n-    }\n-\n-    \/\/ test the result of Attributes.getIndex according to expectations\n-    \/\/ encoded in the method's name\n-    void test(ClassFile cf, Field m, String name, boolean visible) {\n-        int index = m.attributes.getIndex(cf.constant_pool, name);\n-        if (index != -1) {\n-            Attribute attr = m.attributes.get(index);\n-            assert attr instanceof RuntimeTypeAnnotations_attribute;\n-            RuntimeTypeAnnotations_attribute tAttr = (RuntimeTypeAnnotations_attribute)attr;\n-            all += tAttr.annotations.length;\n-            if (visible)\n-                visibles += tAttr.annotations.length;\n-            else\n-                invisibles += tAttr.annotations.length;\n+    \/\/ test the result of AttributedElement.findAttribute according to expectations\n+    <T extends Attribute<T>> void test(AttributedElement m, AttributeMapper<T> attr_name) {\n+        Attribute<T> attr_instance = m.findAttribute(attr_name).orElse(null);\n+        if (attr_instance != null) {\n+            switch (attr_instance) {\n+                case RuntimeVisibleTypeAnnotationsAttribute tAttr -> {\n+                    all += tAttr.annotations().size();\n+                    visibles += tAttr.annotations().size();\n+                }\n+                case RuntimeInvisibleTypeAnnotationsAttribute tAttr -> {\n+                    all += tAttr.annotations().size();\n+                    invisibles += tAttr.annotations().size();\n+                }\n+                default -> throw new AssertionError();\n+            }\n","filename":"test\/langtools\/tools\/javap\/typeAnnotations\/PresenceInner.java","additions":37,"deletions":72,"binary":false,"changes":109,"status":"modified"},{"patch":"@@ -24,0 +24,2 @@\n+import jdk.internal.classfile.*;\n+import jdk.internal.classfile.attribute.*;\n@@ -25,1 +27,0 @@\n-import com.sun.tools.classfile.*;\n@@ -32,1 +33,5 @@\n- * @modules jdk.jdeps\/com.sun.tools.classfile\n+ * @modules java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.classfile.attribute\n+ *          java.base\/jdk.internal.classfile.constantpool\n+ *          java.base\/jdk.internal.classfile.instruction\n+ *          java.base\/jdk.internal.classfile.components\n@@ -44,3 +49,3 @@\n-        ClassFile cf = ClassFile.read(classFile);\n-        for (Method m: cf.methods) {\n-            test(cf, m);\n+        ClassModel cm = Classfile.of().parse(classFile.toPath());\n+        for (MethodModel mm: cm.methods()) {\n+            test(mm);\n@@ -56,3 +61,3 @@\n-    void test(ClassFile cf, Method m) {\n-        test(cf, m, Attribute.RuntimeVisibleTypeAnnotations, true);\n-        test(cf, m, Attribute.RuntimeInvisibleTypeAnnotations, false);\n+    void test(MethodModel mm) {\n+        test(mm, Attributes.RUNTIME_VISIBLE_TYPE_ANNOTATIONS);\n+        test(mm, Attributes.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS);\n@@ -62,1 +67,1 @@\n-    \/\/ test the result of Attributes.getIndex according to expectations\n+    \/\/ test the result of MethodModel.findAttribute according to expectations\n@@ -64,3 +69,3 @@\n-    void test(ClassFile cf, Method m, String name, boolean visible) {\n-        Attribute attr = null;\n-        Code_attribute cAttr = null;\n+    <T extends Attribute<T>> void test(MethodModel mm, AttributeMapper<T> attr_name) {\n+        Attribute<T> attr;\n+        CodeAttribute cAttr;\n@@ -68,16 +73,16 @@\n-        int index = m.attributes.getIndex(cf.constant_pool, Attribute.Code);\n-        if(index!= -1) {\n-            attr = m.attributes.get(index);\n-            assert attr instanceof Code_attribute;\n-            cAttr = (Code_attribute)attr;\n-            index = cAttr.attributes.getIndex(cf.constant_pool, name);\n-            if(index!= -1) {\n-                attr = cAttr.attributes.get(index);\n-                assert attr instanceof RuntimeTypeAnnotations_attribute;\n-                RuntimeTypeAnnotations_attribute tAttr = (RuntimeTypeAnnotations_attribute)attr;\n-                all += tAttr.annotations.length;\n-                if (visible)\n-                    visibles += tAttr.annotations.length;\n-                else\n-                    invisibles += tAttr.annotations.length;\n-               }\n+        cAttr = mm.findAttribute(Attributes.CODE).orElse(null);\n+        if (cAttr != null) {\n+            attr = cAttr.findAttribute(attr_name).orElse(null);\n+            if (attr != null) {\n+                switch (attr) {\n+                    case RuntimeVisibleTypeAnnotationsAttribute tAttr -> {\n+                        all += tAttr.annotations().size();\n+                        visibles += tAttr.annotations().size();\n+                    }\n+                    case RuntimeInvisibleTypeAnnotationsAttribute tAttr -> {\n+                        all += tAttr.annotations().size();\n+                        invisibles += tAttr.annotations().size();\n+                    }\n+                    default -> throw new AssertionError();\n+                }\n+            }\n","filename":"test\/langtools\/tools\/javap\/typeAnnotations\/TypeCasts.java","additions":33,"deletions":28,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -25,1 +25,3 @@\n-import com.sun.tools.classfile.*;\n+import jdk.internal.classfile.*;\n+import jdk.internal.classfile.Attributes;\n+import jdk.internal.classfile.attribute.*;\n@@ -31,1 +33,5 @@\n- * @modules jdk.jdeps\/com.sun.tools.classfile\n+ * @modules java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.classfile.attribute\n+ *          java.base\/jdk.internal.classfile.constantpool\n+ *          java.base\/jdk.internal.classfile.instruction\n+ *          java.base\/jdk.internal.classfile.components\n@@ -43,3 +49,3 @@\n-        ClassFile cf = ClassFile.read(classFile);\n-        for (Method m: cf.methods) {\n-            test(cf, m);\n+        ClassModel cm = Classfile.of().parse(classFile.toPath());\n+        for (MethodModel mm: cm.methods()) {\n+            test(mm);\n@@ -55,3 +61,3 @@\n-    void test(ClassFile cf, Method m) {\n-        test(cf, m, Attribute.RuntimeVisibleTypeAnnotations, true);\n-        test(cf, m, Attribute.RuntimeInvisibleTypeAnnotations, false);\n+    void test(MethodModel mm) {\n+        test(mm, Attributes.RUNTIME_VISIBLE_TYPE_ANNOTATIONS);\n+        test(mm, Attributes.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS);\n@@ -60,1 +66,1 @@\n-    \/\/ test the result of Attributes.getIndex according to expectations\n+    \/\/ test the result of mm.findAttribute according to expectations\n@@ -62,11 +68,14 @@\n-    void test(ClassFile cf, Method m, String name, boolean visible) {\n-        int index = m.attributes.getIndex(cf.constant_pool, name);\n-        if (index != -1) {\n-            Attribute attr = m.attributes.get(index);\n-            assert attr instanceof RuntimeTypeAnnotations_attribute;\n-            RuntimeTypeAnnotations_attribute tAttr = (RuntimeTypeAnnotations_attribute)attr;\n-            all += tAttr.annotations.length;\n-            if (visible)\n-                visibles += tAttr.annotations.length;\n-            else\n-                invisibles += tAttr.annotations.length;\n+    <T extends Attribute<T>> void test(MethodModel mm, AttributeMapper<T> attr_name) {\n+        Attribute<T> attr_instance = mm.findAttribute(attr_name).orElse(null);\n+        if (attr_instance != null) {\n+            switch (attr_instance) {\n+                case RuntimeInvisibleTypeAnnotationsAttribute tAttr -> {\n+                    all += tAttr.annotations().size();\n+                    invisibles += tAttr.annotations().size();\n+                }\n+                case RuntimeVisibleTypeAnnotationsAttribute tAttr -> {\n+                    all += tAttr.annotations().size();\n+                    visibles += tAttr.annotations().size();\n+                }\n+                default -> throw new AssertionError();\n+            }\n@@ -112,1 +121,1 @@\n-      int rc = com.sun.tools.javac.Main.compile(new String[] {\"-g\", f.getPath() });\n+        int rc = com.sun.tools.javac.Main.compile(new String[] {\"-g\", f.getPath() });\n","filename":"test\/langtools\/tools\/javap\/typeAnnotations\/Visibility.java","additions":30,"deletions":21,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -25,1 +25,2 @@\n-import com.sun.tools.classfile.*;\n+import jdk.internal.classfile.*;\n+import jdk.internal.classfile.attribute.*;\n@@ -31,1 +32,5 @@\n- * @modules jdk.jdeps\/com.sun.tools.classfile\n+ * @modules java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.classfile.attribute\n+ *          java.base\/jdk.internal.classfile.constantpool\n+ *          java.base\/jdk.internal.classfile.instruction\n+ *          java.base\/jdk.internal.classfile.components\n@@ -42,4 +47,4 @@\n-        ClassFile cf = ClassFile.read(classFile);\n-        test(cf);\n-        for (Field f : cf.fields) {\n-            test(cf, f);\n+        ClassModel cm = Classfile.of().parse(classFile.toPath());\n+        test(cm);\n+        for (FieldModel fm : cm.fields()) {\n+            test(fm);\n@@ -47,2 +52,2 @@\n-        for (Method m: cf.methods) {\n-            test(cf, m);\n+        for (MethodModel mm: cm.methods()) {\n+            test(mm);\n@@ -57,9 +62,3 @@\n-\n-    void test(ClassFile cf) {\n-        test(cf, Attribute.RuntimeVisibleTypeAnnotations, true);\n-        test(cf, Attribute.RuntimeInvisibleTypeAnnotations, false);\n-    }\n-\n-    void test(ClassFile cf, Method m) {\n-        test(cf, m, Attribute.RuntimeVisibleTypeAnnotations, true);\n-        test(cf, m, Attribute.RuntimeInvisibleTypeAnnotations, false);\n+    void test(AttributedElement m) {\n+        test(m, Attributes.RUNTIME_VISIBLE_TYPE_ANNOTATIONS);\n+        test(m, Attributes.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS);\n@@ -67,19 +66,14 @@\n-\n-    void test(ClassFile cf, Field m) {\n-        test(cf, m, Attribute.RuntimeVisibleTypeAnnotations, true);\n-        test(cf, m, Attribute.RuntimeInvisibleTypeAnnotations, false);\n-    }\n-\n-    \/\/ test the result of Attributes.getIndex according to expectations\n-    \/\/ encoded in the method's name\n-    void test(ClassFile cf, String name, boolean visible) {\n-        int index = cf.attributes.getIndex(cf.constant_pool, name);\n-        if (index != -1) {\n-            Attribute attr = cf.attributes.get(index);\n-            assert attr instanceof RuntimeTypeAnnotations_attribute;\n-            RuntimeTypeAnnotations_attribute tAttr = (RuntimeTypeAnnotations_attribute)attr;\n-            all += tAttr.annotations.length;\n-            if (visible)\n-                visibles += tAttr.annotations.length;\n-            else\n-                invisibles += tAttr.annotations.length;\n+    <T extends Attribute<T>> void test(AttributedElement m, AttributeMapper<T> attr_name) {\n+        Attribute<T> attr_instance = m.findAttribute(attr_name).orElse(null);\n+        if (attr_instance != null) {\n+            switch (attr_instance) {\n+                case RuntimeVisibleTypeAnnotationsAttribute tAttr -> {\n+                    all += tAttr.annotations().size();\n+                    visibles += tAttr.annotations().size();\n+                }\n+                case RuntimeInvisibleTypeAnnotationsAttribute tAttr -> {\n+                    all += tAttr.annotations().size();\n+                    invisibles += tAttr.annotations().size();\n+                }\n+                default -> throw new AssertionError();\n+            }\n@@ -88,33 +82,0 @@\n-\n-    \/\/ test the result of Attributes.getIndex according to expectations\n-    \/\/ encoded in the method's name\n-    void test(ClassFile cf, Method m, String name, boolean visible) {\n-        int index = m.attributes.getIndex(cf.constant_pool, name);\n-        if (index != -1) {\n-            Attribute attr = m.attributes.get(index);\n-            assert attr instanceof RuntimeTypeAnnotations_attribute;\n-            RuntimeTypeAnnotations_attribute tAttr = (RuntimeTypeAnnotations_attribute)attr;\n-            all += tAttr.annotations.length;\n-            if (visible)\n-                visibles += tAttr.annotations.length;\n-            else\n-                invisibles += tAttr.annotations.length;\n-        }\n-    }\n-\n-    \/\/ test the result of Attributes.getIndex according to expectations\n-    \/\/ encoded in the method's name\n-    void test(ClassFile cf, Field m, String name, boolean visible) {\n-        int index = m.attributes.getIndex(cf.constant_pool, name);\n-        if (index != -1) {\n-            Attribute attr = m.attributes.get(index);\n-            assert attr instanceof RuntimeTypeAnnotations_attribute;\n-            RuntimeTypeAnnotations_attribute tAttr = (RuntimeTypeAnnotations_attribute)attr;\n-            all += tAttr.annotations.length;\n-            if (visible)\n-                visibles += tAttr.annotations.length;\n-            else\n-                invisibles += tAttr.annotations.length;\n-        }\n-    }\n-\n@@ -122,1 +83,1 @@\n-      File f = new File(\"Test.java\");\n+        File f = new File(\"Test.java\");\n","filename":"test\/langtools\/tools\/javap\/typeAnnotations\/Wildcards.java","additions":31,"deletions":70,"binary":false,"changes":101,"status":"modified"}]}