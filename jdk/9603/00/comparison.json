{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,0 +25,1 @@\n+#include \"classfile\/symbolTable.hpp\"\n@@ -290,0 +291,98 @@\n+\n+class ResourceHashtableDeleteTest : public ::testing::Test {\n+ public:\n+    class TestValue : public CHeapObj<mtTest> {\n+        Symbol* _s;\n+      public:\n+        \/\/ Never have ctors and dtors fix refcounts without copy ctors and assignment operators!\n+        TestValue(Symbol* name) : _s(name) { _s->increment_refcount(); }\n+        TestValue(const TestValue& tv) { _s = tv.s(); _s->increment_refcount(); }\n+        TestValue& operator=(const TestValue& tv) { _s = tv.s(); _s->increment_refcount(); return *this; }\n+        ~TestValue() { _s->decrement_refcount(); }\n+        Symbol* s() const { return _s; }\n+    };\n+\n+    ResourceHashtable<Symbol*, TestValue, 107, ResourceObj::C_HEAP, mtTest> _test_table;\n+\n+    class Deleter : public StackObj {\n+      public:\n+        bool do_entry(Symbol*& key, TestValue& value) {\n+          \/\/ decrement the refcount in key or not?\n+          \/\/ Since we didn't increment the key, we shouldn't decrement it.\n+          \/\/ Calling delete on the hashtable Node which contains value will\n+          \/\/ decrement the refcount.  That's actually best since the whole\n+          \/\/ entry will be gone at once.\n+          return true;\n+        }\n+        bool do_entry(Symbol*& key, TestValue*& value) {\n+          \/\/ decrement the refcount in key or not?\n+          \/\/ Since we incremented the key, in this case, we should decrement it.\n+          key->decrement_refcount();\n+          \/\/ If the hashtable value is a pointer, need to delete it from here.\n+          delete value;\n+          \/\/ The risk is that if this is the last reference to the key, it'll be\n+          \/\/ pointed to in the table with refcount 0.\n+          \/\/ But the node is going to be deleted next anyway, so a pointer to dead data\n+          \/\/ is ok?\n+          return true;\n+        }\n+    };\n+\n+    ResourceHashtable<Symbol*, TestValue*, 107, ResourceObj::C_HEAP, mtTest> _ptr_test_table;\n+};\n+\n+TEST_VM_F(ResourceHashtableDeleteTest, check_delete) {\n+  TempNewSymbol s = SymbolTable::new_symbol(\"abc\");\n+  int s_orig_count = s->refcount();\n+  {\n+    TestValue tv(s);\n+    \/\/ If you use a Symbol* as key in the ResourceHashtable, you must increment the\n+    \/\/ refcount outside the hashtable functions.\n+    s->increment_refcount();\n+    _test_table.put(s, tv);\n+    ASSERT_EQ(s->refcount(), s_orig_count + 3) << \"refcount incremented\";\n+  }\n+  ASSERT_EQ(s->refcount(), s_orig_count + 2) << \"refcount not copied\";\n+\n+  \/\/ Deleting this value from a hashtable calls the destructor!\n+  _test_table.remove(s);\n+  \/\/ Now decrement the refcount for s since it's no longer in the table.\n+  s->decrement_refcount();\n+  \/\/ Removal should make the refcount be the original refcount.\n+  ASSERT_EQ(s->refcount(), s_orig_count) << \"refcount now decremented\";\n+\n+  TempNewSymbol d = SymbolTable::new_symbol(\"defghijklmnop\");\n+  int d_orig_count = d->refcount();\n+  {\n+    TestValue tv(d);\n+    \/\/ On the other hand, if the Key Symbol* is already a member of the entry, it's not strictly\n+    \/\/ necessary to increment the refcount on the symbol.\n+    _test_table.put(d, tv);\n+    ASSERT_EQ(d->refcount(), d_orig_count + 2) << \"refcount incremented\";\n+  }\n+  ASSERT_EQ(d->refcount(), d_orig_count + 1) << \"refcount incremented\";\n+  Deleter deleter;\n+  _test_table.unlink(&deleter);\n+  ASSERT_EQ(d->refcount(), d_orig_count) << \"refcount should be as we started\";\n+}\n+\n+TEST_VM_F(ResourceHashtableDeleteTest, check_delete_ptr) {\n+  TempNewSymbol s = SymbolTable::new_symbol(\"abcdefg_ptr\");\n+  int s_orig_count = s->refcount();\n+  {\n+    TestValue* tv = new TestValue(s);\n+    \/\/ If you use a Symbol* as key in the ResourceHashtable, you must increment the\n+    \/\/ refcount outside the hashtable functions.\n+    s->increment_refcount();\n+    _ptr_test_table.put(s, tv);\n+    ASSERT_EQ(s->refcount(), s_orig_count + 2) << \"refcount incremented\";\n+  }\n+  ASSERT_EQ(s->refcount(), s_orig_count + 2) << \"refcount not copied\";\n+\n+  \/\/ Deleting this value from a hashtable must call the destructor in the\n+  \/\/ do_entry function.\n+  Deleter deleter;\n+  _ptr_test_table.unlink(&deleter);\n+  \/\/ Removal should make the refcount be the original refcount.\n+  ASSERT_EQ(s->refcount(), s_orig_count) << \"refcount now decremented\";\n+}\n","filename":"test\/hotspot\/gtest\/utilities\/test_resourceHash.cpp","additions":100,"deletions":1,"binary":false,"changes":101,"status":"modified"}]}