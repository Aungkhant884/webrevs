{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,0 +25,1 @@\n+#include \"classfile\/symbolTable.hpp\"\n@@ -290,0 +291,158 @@\n+\n+\/\/ Simple ResourceHashtable whose key is a Symbol* and value is an int\n+\/\/ This test is to show that you need to manipulate the refcount of the Symbol to store\n+\/\/ in the table.\n+class SimpleResourceHashtableDeleteTest : public ::testing::Test {\n+ public:\n+    ResourceHashtable<Symbol*, int, 107, ResourceObj::C_HEAP, mtTest> _simple_test_table;\n+\n+    class SimpleDeleter : public StackObj {\n+      public:\n+        bool do_entry(Symbol*& key, int value) {\n+          \/\/ We need to decrement the refcount for the key in the delete function.\n+          \/\/ Since we incremented the key, in this case, we should decrement it.\n+          key->decrement_refcount();\n+          return true;\n+        }\n+    };\n+};\n+\n+TEST_VM_F(SimpleResourceHashtableDeleteTest, simple_remove) {\n+  TempNewSymbol s = SymbolTable::new_symbol(\"abcdefg_simple\");\n+  int s_orig_count = s->refcount();\n+  \/\/ Need to increment a Symbol* when you keep it in a table.\n+  s->increment_refcount();\n+  _simple_test_table.put(s, 55);\n+  ASSERT_EQ(s->refcount(), s_orig_count + 1) << \"refcount should be incremented in table\";\n+\n+  \/\/ Deleting this value from a hashtable\n+  _simple_test_table.remove(s);\n+  \/\/ Now decrement the refcount for s since it's no longer in the table.\n+  s->decrement_refcount();\n+  ASSERT_EQ(s->refcount(), s_orig_count) << \"refcount should be same as start\";\n+}\n+\n+TEST_VM_F(SimpleResourceHashtableDeleteTest, simple_delete) {\n+  TempNewSymbol s = SymbolTable::new_symbol(\"abcdefg_simple\");\n+  int s_orig_count = s->refcount();\n+  \/\/ Need to increment a Symbol* when you keep it in a table.\n+  s->increment_refcount();\n+  _simple_test_table.put(s, 66);\n+  ASSERT_EQ(s->refcount(), s_orig_count + 1) << \"refcount should be incremented in table\";\n+\n+  \/\/ Use unlink to remove the matching (or all) values from the table.\n+  SimpleDeleter deleter;\n+  _simple_test_table.unlink(&deleter);\n+  ASSERT_EQ(s->refcount(), s_orig_count) << \"refcount should be same as start\";\n+}\n+\n+\/\/ More complicated ResourceHashtable with Symbol* as the key. Since the *same* Symbol is part\n+\/\/ of the value, it's not necessary to maniuplate the refcount of the key, but you must in the value.\n+class ResourceHashtableDeleteTest : public ::testing::Test {\n+ public:\n+    class TestValue : public CHeapObj<mtTest> {\n+        Symbol* _s;\n+      public:\n+        \/\/ Never have ctors and dtors fix refcounts without copy ctors and assignment operators!\n+        \/\/ Unless it's declared and used as a CHeapObj with\n+        \/\/ NONCOPYABLE(TestValue)\n+        TestValue(Symbol* name) : _s(name) { _s->increment_refcount(); }\n+        TestValue(const TestValue& tv) { _s = tv.s(); _s->increment_refcount(); }\n+\n+        \/\/ Refcounting with assignment operators is tricky.  See TempNewSymbol for more information.\n+        \/\/ (1) A copy (from) of the argument is created to be passed by value to operator=.  This increments\n+        \/\/ the refcount of the symbol.\n+        \/\/ (2) Exchange the values this->_s and from._s as a trivial pointer exchange.  No reference count\n+        \/\/ manipulation occurs.  this->_s is the desired new value, with its refcount incremented appropriately\n+        \/\/ (by the copy that created from).\n+        \/\/ (3) The operation completes and from goes out of scope, calling its destructor.  This decrements the\n+        \/\/ refcount for from._s, which is the _old_ value of this->_s.\n+        TestValue& operator=(TestValue tv) { swap(_s, tv._s); return *this; }\n+\n+        ~TestValue() { _s->decrement_refcount(); }\n+        Symbol* s() const { return _s; }\n+    };\n+\n+    \/\/ ResourceHashtable whose value is a *copy* of TestValue.\n+    ResourceHashtable<Symbol*, TestValue, 107, ResourceObj::C_HEAP, mtTest> _test_table;\n+\n+    class Deleter : public StackObj {\n+      public:\n+        bool do_entry(Symbol*& key, TestValue& value) {\n+          \/\/ Since we didn't increment the key, we shouldn't decrement it.\n+          \/\/ Calling delete on the hashtable Node which contains value will\n+          \/\/ decrement the refcount.  That's actually best since the whole\n+          \/\/ entry will be gone at once.\n+          return true;\n+        }\n+    };\n+\n+    \/\/ ResourceHashtable whose value is a pointer to TestValue.\n+    ResourceHashtable<Symbol*, TestValue*, 107, ResourceObj::C_HEAP, mtTest> _ptr_test_table;\n+\n+    class PtrDeleter : public StackObj {\n+      public:\n+        bool do_entry(Symbol*& key, TestValue*& value) {\n+          \/\/ If the hashtable value is a pointer, need to delete it from here.\n+          \/\/ This will also potentially make the refcount of the Key = 0, but the\n+          \/\/ next thing that happens is that the hashtable node is deleted so this is ok.\n+          delete value;\n+          return true;\n+        }\n+    };\n+};\n+\n+\n+TEST_VM_F(ResourceHashtableDeleteTest, value_remove) {\n+  TempNewSymbol s = SymbolTable::new_symbol(\"abcdefg\");\n+  int s_orig_count = s->refcount();\n+  {\n+    TestValue tv(s);\n+    \/\/ Since TestValue contains the pointer to the key, it will handle the\n+    \/\/ refcounting.\n+    _test_table.put(s, tv);\n+    ASSERT_EQ(s->refcount(), s_orig_count + 2) << \"refcount incremented by copy\";\n+  }\n+  ASSERT_EQ(s->refcount(), s_orig_count + 1) << \"refcount incremented in table\";\n+\n+  \/\/ Deleting this value from a hashtable calls the destructor!\n+  _test_table.remove(s);\n+  \/\/ Removal should make the refcount be the original refcount.\n+  ASSERT_EQ(s->refcount(), s_orig_count) << \"refcount should be as we started\";\n+}\n+\n+TEST_VM_F(ResourceHashtableDeleteTest, value_delete) {\n+  TempNewSymbol d = SymbolTable::new_symbol(\"defghijklmnop\");\n+  int d_orig_count = d->refcount();\n+  {\n+    TestValue tv(d);\n+    \/\/ Same as above, but the do_entry does nothing because the value is deleted when the\n+    \/\/ hashtable node is deleted.\n+    _test_table.put(d, tv);\n+    ASSERT_EQ(d->refcount(), d_orig_count + 2) << \"refcount incremented by copy\";\n+  }\n+  ASSERT_EQ(d->refcount(), d_orig_count + 1) << \"refcount incremented in table\";\n+  Deleter deleter;\n+  _test_table.unlink(&deleter);\n+  ASSERT_EQ(d->refcount(), d_orig_count) << \"refcount should be as we started\";\n+}\n+\n+TEST_VM_F(ResourceHashtableDeleteTest, check_delete_ptr) {\n+  TempNewSymbol s = SymbolTable::new_symbol(\"abcdefg_ptr\");\n+  int s_orig_count = s->refcount();\n+  {\n+    TestValue* tv = new TestValue(s);\n+    \/\/ Again since TestValue contains the pointer to the key Symbol, it will\n+    \/\/ handle the refcounting.\n+    _ptr_test_table.put(s, tv);\n+    ASSERT_EQ(s->refcount(), s_orig_count + 1) << \"refcount incremented by allocation\";\n+  }\n+  ASSERT_EQ(s->refcount(), s_orig_count + 1) << \"refcount incremented in table\";\n+\n+  \/\/ Deleting this pointer value from a hashtable must call the destructor in the\n+  \/\/ do_entry function.\n+  PtrDeleter deleter;\n+  _ptr_test_table.unlink(&deleter);\n+  \/\/ Removal should make the refcount be the original refcount.\n+  ASSERT_EQ(s->refcount(), s_orig_count) << \"refcount should be as we started\";\n+}\n","filename":"test\/hotspot\/gtest\/utilities\/test_resourceHash.cpp","additions":160,"deletions":1,"binary":false,"changes":161,"status":"modified"}]}