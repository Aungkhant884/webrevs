{"files":[{"patch":"@@ -146,1 +146,1 @@\n-address Method::get_i2c_entry() const {\n+address Method::get_i2c_entry() {\n@@ -151,1 +151,1 @@\n-address Method::get_c2i_entry() const {\n+address Method::get_c2i_entry() {\n@@ -156,1 +156,1 @@\n-address Method::get_c2i_unverified_entry() const {\n+address Method::get_c2i_unverified_entry() {\n@@ -161,1 +161,1 @@\n-address Method::get_c2i_no_clinit_check_entry() const {\n+address Method::get_c2i_no_clinit_check_entry() {\n@@ -1282,9 +1282,8 @@\n-\/\/ This must be called when an invoke is resolved on this method.\n-\/\/ It returns the compiled code entry point, or the c2i entry point if\n-\/\/ in interpreted only mode. This function is called after potential\n-\/\/ safepoints so that the nmethod or adapter that it points to is still\n-\/\/ live and valid, and no switch to interpreted only mode happens after\n-\/\/ we already returned the compiled entry point.\n-\/\/ TODO: _linkToNative doesn't have an interpreted version so we always\n-\/\/ return the compiled code entry point.\n-address Method::from_compiled_entry(bool is_interp_only_mode) const {\n+\/\/ The verified_code_entry() must be called when a invoke is resolved\n+\/\/ on this method.\n+\n+\/\/ It returns the compiled code entry point, after asserting not null.\n+\/\/ This function is called after potential safepoints so that nmethod\n+\/\/ or adapter that it points to is still live and valid.\n+\/\/ This function must not hit a safepoint!\n+address Method::verified_code_entry() {\n@@ -1292,8 +1291,2 @@\n-  address target = nullptr;\n-  if (!is_interp_only_mode || (intrinsic_id() == vmIntrinsics::_linkToNative)) {\n-    target = _from_compiled_entry;\n-  } else {\n-    target = get_c2i_entry();\n-  }\n-  assert(target != nullptr, \"Jump to zero!\");\n-  return target;\n+  assert(_from_compiled_entry != nullptr, \"must be set\");\n+  return _from_compiled_entry;\n","filename":"src\/hotspot\/share\/oops\/method.cpp","additions":14,"deletions":21,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -417,1 +417,1 @@\n-  address from_compiled_entry(bool is_interp_only_mode) const;\n+  address verified_code_entry();\n@@ -439,4 +439,4 @@\n-  address get_i2c_entry() const;\n-  address get_c2i_entry() const;\n-  address get_c2i_unverified_entry() const;\n-  address get_c2i_no_clinit_check_entry() const;\n+  address get_i2c_entry();\n+  address get_c2i_entry();\n+  address get_c2i_unverified_entry();\n+  address get_c2i_no_clinit_check_entry();\n","filename":"src\/hotspot\/share\/oops\/method.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1503,1 +1503,3 @@\n-  return callee_method->from_compiled_entry(current->is_interp_only_mode());\n+  \/\/ return compiled code entry point after potential safepoints\n+  assert(callee_method->verified_code_entry() != nullptr, \" Jump to zero!\");\n+  return callee_method->verified_code_entry();\n@@ -1555,1 +1557,3 @@\n-  return callee_method->from_compiled_entry(current->is_interp_only_mode());\n+  \/\/ return compiled code entry point after potential safepoints\n+  assert(callee_method->verified_code_entry() != nullptr, \" Jump to zero!\");\n+  return callee_method->verified_code_entry();\n@@ -1596,0 +1600,1 @@\n+  bool enter_special = false;\n@@ -1599,0 +1604,12 @@\n+\n+    if (current->is_interp_only_mode()) {\n+      RegisterMap reg_map(current,\n+                          RegisterMap::UpdateMap::skip,\n+                          RegisterMap::ProcessFrames::include,\n+                          RegisterMap::WalkContinuation::skip);\n+      frame stub_frame = current->last_frame();\n+      assert(stub_frame.is_runtime_frame(), \"must be a runtimeStub\");\n+      frame caller = stub_frame.sender(&reg_map);\n+      enter_special = caller.cb() != nullptr && caller.cb()->is_compiled()\n+        && caller.cb()->as_compiled_method()->method()->is_continuation_enter_intrinsic();\n+    }\n@@ -1600,1 +1617,15 @@\n-  return callee_method->from_compiled_entry(current->is_interp_only_mode());\n+\n+  if (current->is_interp_only_mode() && enter_special) {\n+    \/\/ enterSpecial is compiled and calls this method to resolve the call to Continuation::enter\n+    \/\/ but in interp_only_mode we need to go to the interpreted entry\n+    \/\/ The c2i won't patch in this mode -- see fixup_callers_callsite\n+    \/\/\n+    \/\/ This should probably be done in all cases, not just enterSpecial (see JDK-8218403),\n+    \/\/ but that's part of a larger fix, and the situation is worse for enterSpecial, as it has no\n+    \/\/ interpreted version.\n+    return callee_method->get_c2i_entry();\n+  }\n+\n+  \/\/ return compiled code entry point after potential safepoints\n+  assert(callee_method->verified_code_entry() != nullptr, \" Jump to zero!\");\n+  return callee_method->verified_code_entry();\n@@ -1611,1 +1642,3 @@\n-  return callee_method->from_compiled_entry(current->is_interp_only_mode());\n+  \/\/ return compiled code entry point after potential safepoints\n+  assert(callee_method->verified_code_entry() != nullptr, \" Jump to zero!\");\n+  return callee_method->verified_code_entry();\n@@ -1623,1 +1656,3 @@\n-  return callee_method->from_compiled_entry(current->is_interp_only_mode());\n+  \/\/ return compiled code entry point after potential safepoints\n+  assert(callee_method->verified_code_entry() != nullptr, \" Jump to zero!\");\n+  return callee_method->verified_code_entry();\n@@ -2038,3 +2073,0 @@\n-  assert(!JavaThread::current()->is_interp_only_mode() || !nm->method()->is_continuation_enter_intrinsic()\n-    || ContinuationEntry::is_interpreted_call(return_pc), \"interp_only_mode but not in enterSpecial interpreted entry\");\n-\n@@ -2078,2 +2110,0 @@\n-        assert(ContinuationEntry::is_interpreted_call(call->instruction_address()) == JavaThread::current()->is_interp_only_mode(),\n-          \"mode: %d\", JavaThread::current()->is_interp_only_mode());\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":40,"deletions":10,"binary":false,"changes":50,"status":"modified"}]}