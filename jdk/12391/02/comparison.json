{"files":[{"patch":"@@ -238,6 +238,5 @@\n-    \/**\n-     * The class represents the border of a {@code JInternalFrame}.\n-     *\/\n-    @SuppressWarnings(\"serial\") \/\/ Superclass is not serializable across versions\n-    public static class InternalFrameBorder extends AbstractBorder implements UIResource {\n-        private static final int CORNER = 14;\n+    @SuppressWarnings(\"serial\")\n+    private abstract static sealed class AbstractMetalBorder\n+            extends AbstractBorder\n+            implements UIResource\n+            permits FrameBorder, DialogBorder, InternalFrameBorderImpl {\n@@ -245,4 +244,3 @@\n-        \/**\n-         * Constructs a {@code InternalFrameBorder}.\n-         *\/\n-        public InternalFrameBorder() {}\n+        protected Color background;\n+        protected Color highlight;\n+        protected Color shadow;\n@@ -250,2 +248,5 @@\n-        public void paintBorder(Component c, Graphics g, int x, int y,\n-                                int w, int h) {\n+        private static final int CORNER = 14;\n+\n+        @Override\n+        public final void paintBorder(Component c, Graphics g,\n+                                      int x, int y, int w, int h) {\n@@ -253,2 +254,2 @@\n-                                        x, y, w, h,\n-                                        this::paintUnscaledBorder);\n+                    x, y, w, h,\n+                    this::paintUnscaledBorder);\n@@ -257,8 +258,2 @@\n-        private void paintUnscaledBorder(Component c, Graphics g,\n-                                         int width, int height,\n-                                         double scaleFactor) {\n-            Color background;\n-            Color highlight;\n-            Color shadow;\n-\n-            if (c instanceof JInternalFrame && ((JInternalFrame)c).isSelected()) {\n+        protected void updateColors(Component c) {\n+            if (isActive(c)) {\n@@ -273,0 +268,1 @@\n+        }\n@@ -274,2 +270,1 @@\n-            \/\/ scaled border\n-            int thickness = (int) Math.ceil(4 * scaleFactor);\n+        protected abstract boolean isActive(Component c);\n@@ -277,0 +272,6 @@\n+        protected abstract boolean isResizable(Component c);\n+\n+        private void paintUnscaledBorder(Component c, Graphics g,\n+                                         int width, int height,\n+                                         double scaleFactor) {\n+            updateColors(c);\n@@ -278,0 +279,3 @@\n+\n+            \/\/ scaled thickness\n+            int thickness = (int) Math.ceil(4 * scaleFactor);\n@@ -283,3 +287,3 @@\n-            if (c instanceof JInternalFrame && ((JInternalFrame)c).isResizable()) {\n-                \/\/ midpoint at which highlight & shadow lines\n-                \/\/ are positioned on the border\n+            if (isResizable(c)) {\n+                \/\/midpoint at which highlight & shadow lines\n+                \/\/are positioned on the border\n@@ -318,1 +322,2 @@\n-        public Insets getBorderInsets(Component c, Insets newInsets) {\n+        @Override\n+        public final Insets getBorderInsets(Component c, Insets newInsets) {\n@@ -324,0 +329,15 @@\n+    @SuppressWarnings(\"serial\")\n+    private static final class InternalFrameBorderImpl extends AbstractMetalBorder {\n+        @Override\n+        protected boolean isActive(Component c) {\n+            return (c instanceof JInternalFrame\n+                    && ((JInternalFrame)c).isSelected());\n+        }\n+\n+        @Override\n+        protected boolean isResizable(Component c) {\n+            return ((c instanceof JInternalFrame\n+                    && ((JInternalFrame) c).isResizable()));\n+        }\n+    }\n+\n@@ -325,2 +345,1 @@\n-     * Border for a Frame.\n-     * @since 1.4\n+     * The class represents the border of a {@code JInternalFrame}.\n@@ -329,5 +348,1 @@\n-    static class FrameBorder extends AbstractBorder implements UIResource {\n-        private static final int corner = 14;\n-\n-        public void paintBorder(Component c, Graphics g, int x, int y,\n-            int w, int h) {\n+    public static class InternalFrameBorder extends AbstractBorder implements UIResource {\n@@ -335,3 +350,1 @@\n-            Color background;\n-            Color highlight;\n-            Color shadow;\n+        private final InternalFrameBorderImpl border;\n@@ -339,17 +352,6 @@\n-            Window window = SwingUtilities.getWindowAncestor(c);\n-            if (window != null && window.isActive()) {\n-                background = MetalLookAndFeel.getPrimaryControlDarkShadow();\n-                highlight = MetalLookAndFeel.getPrimaryControlShadow();\n-                shadow = MetalLookAndFeel.getPrimaryControlInfo();\n-            } else {\n-                background = MetalLookAndFeel.getControlDarkShadow();\n-                highlight = MetalLookAndFeel.getControlShadow();\n-                shadow = MetalLookAndFeel.getControlInfo();\n-            }\n-\n-            g.setColor(background);\n-            \/\/ Draw outermost lines\n-            g.drawLine( x+1, y+0, x+w-2, y+0);\n-            g.drawLine( x+0, y+1, x+0, y +h-2);\n-            g.drawLine( x+w-1, y+1, x+w-1, y+h-2);\n-            g.drawLine( x+1, y+h-1, x+w-2, y+h-1);\n+        \/**\n+         * Constructs a {@code InternalFrameBorder}.\n+         *\/\n+        public InternalFrameBorder() {\n+            border = new InternalFrameBorderImpl();\n+        }\n@@ -357,4 +359,4 @@\n-            \/\/ Draw the bulk of the border\n-            for (int i = 1; i < 5; i++) {\n-                g.drawRect(x+i,y+i,w-(i*2)-1, h-(i*2)-1);\n-            }\n+        public void paintBorder(Component c, Graphics g, int x, int y,\n+                                int w, int h) {\n+            border.paintBorder(c, g, x, y, w, h);\n+        }\n@@ -362,7 +364,5 @@\n-            if ((window instanceof Frame) && ((Frame) window).isResizable()) {\n-                g.setColor(highlight);\n-                \/\/ Draw the Long highlight lines\n-                g.drawLine( corner+1, 3, w-corner, 3);\n-                g.drawLine( 3, corner+1, 3, h-corner);\n-                g.drawLine( w-2, corner+1, w-2, h-corner);\n-                g.drawLine( corner+1, h-2, w-corner, h-2);\n+        public Insets getBorderInsets(Component c, Insets newInsets) {\n+            newInsets.set(4, 4, 4, 4);\n+            return newInsets;\n+        }\n+    }\n@@ -370,7 +370,6 @@\n-                g.setColor(shadow);\n-                \/\/ Draw the Long shadow lines\n-                g.drawLine( corner, 2, w-corner-1, 2);\n-                g.drawLine( 2, corner, 2, h-corner-1);\n-                g.drawLine( w-3, corner, w-3, h-corner-1);\n-                g.drawLine( corner, h-3, w-corner-1, h-3);\n-            }\n+    \/**\n+     * Border for a Frame.\n+     * @since 1.4\n+     *\/\n+    @SuppressWarnings(\"serial\") \/\/ Superclass is not serializable across versions\n+    static final class FrameBorder extends AbstractMetalBorder implements UIResource {\n@@ -378,0 +377,4 @@\n+        @Override\n+        protected boolean isActive(Component c) {\n+            Window window = SwingUtilities.getWindowAncestor(c);\n+            return (window != null && window.isActive());\n@@ -380,4 +383,5 @@\n-        public Insets getBorderInsets(Component c, Insets newInsets)\n-        {\n-            newInsets.set(5, 5, 5, 5);\n-            return newInsets;\n+        @Override\n+        protected boolean isResizable(Component c) {\n+            Window window = SwingUtilities.getWindowAncestor(c);\n+            return ((window instanceof Frame)\n+                    && ((Frame) window).isResizable());\n@@ -392,3 +396,4 @@\n-    static class DialogBorder extends AbstractBorder implements UIResource\n-    {\n-        private static final int corner = 14;\n+    static sealed class DialogBorder\n+            extends AbstractMetalBorder\n+            implements UIResource\n+            permits ErrorDialogBorder, QuestionDialogBorder, WarningDialogBorder {\n@@ -396,2 +401,1 @@\n-        protected Color getActiveBackground()\n-        {\n+        protected Color getActiveBackground() {\n@@ -401,1 +405,1 @@\n-        protected Color getActiveHighlight()\n+        protected final Color getActiveHighlight()\n@@ -406,1 +410,1 @@\n-        protected Color getActiveShadow()\n+        protected final Color getActiveShadow()\n@@ -411,1 +415,1 @@\n-        protected Color getInactiveBackground()\n+        protected final Color getInactiveBackground()\n@@ -416,1 +420,1 @@\n-        protected Color getInactiveHighlight()\n+        protected final Color getInactiveHighlight()\n@@ -421,1 +425,1 @@\n-        protected Color getInactiveShadow()\n+        protected final Color getInactiveShadow()\n@@ -426,8 +430,3 @@\n-        public void paintBorder(Component c, Graphics g, int x, int y, int w, int h)\n-        {\n-            Color background;\n-            Color highlight;\n-            Color shadow;\n-\n-            Window window = SwingUtilities.getWindowAncestor(c);\n-            if (window != null && window.isActive()) {\n+        @Override\n+        protected final void updateColors(Component c) {\n+            if (isActive(c)) {\n@@ -442,0 +441,1 @@\n+        }\n@@ -443,29 +443,4 @@\n-            g.setColor(background);\n-            \/\/ Draw outermost lines\n-            g.drawLine( x + 1, y + 0, x + w-2, y + 0);\n-            g.drawLine( x + 0, y + 1, x + 0, y + h - 2);\n-            g.drawLine( x + w - 1, y + 1, x + w - 1, y + h - 2);\n-            g.drawLine( x + 1, y + h - 1, x + w - 2, y + h - 1);\n-\n-            \/\/ Draw the bulk of the border\n-            for (int i = 1; i < 5; i++) {\n-                g.drawRect(x+i,y+i,w-(i*2)-1, h-(i*2)-1);\n-            }\n-\n-\n-            if ((window instanceof Dialog) && ((Dialog) window).isResizable()) {\n-                g.setColor(highlight);\n-                \/\/ Draw the Long highlight lines\n-                g.drawLine( corner+1, 3, w-corner, 3);\n-                g.drawLine( 3, corner+1, 3, h-corner);\n-                g.drawLine( w-2, corner+1, w-2, h-corner);\n-                g.drawLine( corner+1, h-2, w-corner, h-2);\n-\n-                g.setColor(shadow);\n-                \/\/ Draw the Long shadow lines\n-                g.drawLine( corner, 2, w-corner-1, 2);\n-                g.drawLine( 2, corner, 2, h-corner-1);\n-                g.drawLine( w-3, corner, w-3, h-corner-1);\n-                g.drawLine( corner, h-3, w-corner-1, h-3);\n-            }\n-\n+        @Override\n+        protected final boolean isActive(Component c) {\n+            Window window = SwingUtilities.getWindowAncestor(c);\n+            return (window != null && window.isActive());\n@@ -474,4 +449,5 @@\n-        public Insets getBorderInsets(Component c, Insets newInsets)\n-        {\n-            newInsets.set(5, 5, 5, 5);\n-            return newInsets;\n+        @Override\n+        protected final boolean isResizable(Component c) {\n+            Window window = SwingUtilities.getWindowAncestor(c);\n+            return ((window instanceof Dialog)\n+                    && ((Dialog) window).isResizable());\n@@ -486,1 +462,1 @@\n-    static class ErrorDialogBorder extends DialogBorder implements UIResource\n+    static final class ErrorDialogBorder extends DialogBorder implements UIResource\n@@ -500,1 +476,1 @@\n-    static class QuestionDialogBorder extends DialogBorder implements UIResource\n+    static final class QuestionDialogBorder extends DialogBorder implements UIResource\n@@ -513,1 +489,1 @@\n-    static class WarningDialogBorder extends DialogBorder implements UIResource\n+    static final class WarningDialogBorder extends DialogBorder implements UIResource\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/metal\/MetalBorders.java","additions":107,"deletions":131,"binary":false,"changes":238,"status":"modified"},{"patch":"@@ -1,266 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.awt.AWTException;\n-import java.awt.Color;\n-import java.awt.GridBagLayout;\n-import java.awt.Image;\n-import java.awt.Point;\n-import java.awt.Rectangle;\n-import java.awt.Robot;\n-import java.awt.image.MultiResolutionImage;\n-import java.awt.image.RenderedImage;\n-import java.io.File;\n-import java.lang.reflect.InvocationTargetException;\n-import java.util.List;\n-\n-import javax.imageio.ImageIO;\n-import javax.swing.JFrame;\n-import javax.swing.JInternalFrame;\n-import javax.swing.JLabel;\n-import javax.swing.SwingUtilities;\n-import javax.swing.UIManager;\n-\n-\/*\n- * @test\n- * @bug 8015739\n- * @key headful\n- * @summary Tests whether background color of JInternalFrame is visible\n- * in the border region at different scales by checking the midpoints\n- * and corners of the border.\n- *\n- * @requires (os.family == \"windows\")\n- * @run main\/othervm -Dsun.java2d.uiScale=1 InternalFrameBorderTest\n- * @run main\/othervm -Dsun.java2d.uiScale=1.25 InternalFrameBorderTest\n- * @run main\/othervm -Dsun.java2d.uiScale=1.5 InternalFrameBorderTest\n- * @run main\/othervm -Dsun.java2d.uiScale=1.75 InternalFrameBorderTest\n- * @run main\/othervm -Dsun.java2d.uiScale=2 InternalFrameBorderTest\n- * @run main\/othervm -Dsun.java2d.uiScale=2.5 InternalFrameBorderTest\n- * @run main\/othervm -Dsun.java2d.uiScale=3 InternalFrameBorderTest\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8015739\n- * @key headful\n- * @summary Tests whether background color of JInternalFrame is visible\n- * in the border region at different scales by checking the midpoints\n- * and corners of the border.\n- *\n- * @requires (os.family == \"mac\" | os.family == \"linux\")\n- * @run main\/othervm -Dsun.java2d.uiScale=1 InternalFrameBorderTest\n- * @run main\/othervm -Dsun.java2d.uiScale=2 InternalFrameBorderTest\n- *\/\n-\n-public class InternalFrameBorderTest {\n-    private static final int FRAME_SIZE = 300;\n-    private static final int INTFRAME_SIZE = 150;\n-    private static final int MIDPOINT = INTFRAME_SIZE \/ 2;\n-    private static final int BORDER_THICKNESS = 4;\n-\n-    private static final StringBuffer errorLog = new StringBuffer();\n-\n-    private static JFrame jFrame;\n-    private static Rectangle jFrameBounds;\n-    private static JInternalFrame iFrame;\n-    private static Point iFrameLoc;\n-    private static int iFrameMaxX;\n-    private static int iFrameMaxY;\n-\n-    private static Robot robot;\n-    private static String uiScale;\n-\n-    public static void main(String[] args) throws AWTException,\n-            InterruptedException, InvocationTargetException {\n-        try {\n-            UIManager.setLookAndFeel(\"javax.swing.plaf.metal.MetalLookAndFeel\");\n-        } catch (Exception e) {\n-            System.out.println(\"Metal LAF class not supported\");\n-            return;\n-        }\n-\n-        try {\n-            robot = new Robot();\n-            robot.setAutoDelay(200);\n-            uiScale = System.getProperty(\"sun.java2d.uiScale\");\n-\n-            SwingUtilities.invokeAndWait(InternalFrameBorderTest::createAndShowGUI);\n-            robot.waitForIdle();\n-            robot.delay(500);\n-\n-            SwingUtilities.invokeAndWait(() -> {\n-                iFrameLoc = iFrame.getLocationOnScreen();\n-                iFrameMaxX = iFrameLoc.x + INTFRAME_SIZE;\n-                iFrameMaxY = iFrameLoc.y + INTFRAME_SIZE;\n-                jFrameBounds = jFrame.getBounds();\n-            });\n-\n-            \/\/ Check Borders\n-            checkBorderMidPoints(\"TOP\");\n-            checkBorderMidPoints(\"RIGHT\");\n-            checkBorderMidPoints(\"BOTTOM\");\n-            checkBorderMidPoints(\"LEFT\");\n-\n-            \/\/ Check Corner Diagonals\n-            checkCorners(\"TOP_LEFT\");\n-            checkCorners(\"TOP_RIGHT\");\n-            checkCorners(\"BOTTOM_RIGHT\");\n-            checkCorners(\"BOTTOM_LEFT\");\n-\n-            if (!errorLog.isEmpty()) {\n-                saveScreenCapture(\"JIF_uiScale_\" + uiScale + \".png\");\n-                throw new RuntimeException(\"Following error(s) occurred: \\n\"\n-                        + errorLog);\n-            }\n-        } finally {\n-            if (jFrame != null) {\n-                jFrame.dispose();\n-            }\n-            robot.delay(500);\n-        }\n-    }\n-\n-    private static void checkBorderMidPoints(String borderDirection) {\n-        int x, y;\n-        int start, stop;\n-\n-        switch (borderDirection) {\n-            case \"TOP\" -> {\n-                x = iFrameLoc.x + MIDPOINT;\n-                y = iFrameLoc.y + BORDER_THICKNESS;\n-                start = iFrameLoc.y;\n-                stop = iFrameLoc.y + BORDER_THICKNESS - 1;\n-            }\n-            case \"RIGHT\" -> {\n-                x = iFrameMaxX - BORDER_THICKNESS;\n-                y = iFrameLoc.y + MIDPOINT;\n-                start = iFrameMaxX - BORDER_THICKNESS + 1;\n-                stop = iFrameMaxX;\n-            }\n-            case \"BOTTOM\" -> {\n-                x = iFrameLoc.x + MIDPOINT;\n-                y = iFrameMaxY - BORDER_THICKNESS;\n-                start = iFrameMaxY - BORDER_THICKNESS + 1;\n-                stop = iFrameMaxY;\n-            }\n-            case \"LEFT\" -> {\n-                x = iFrameLoc.x;\n-                y = iFrameLoc.y + MIDPOINT;\n-                start = iFrameLoc.x;\n-                stop = iFrameLoc.x + BORDER_THICKNESS - 1;\n-            }\n-            default -> throw new IllegalStateException(\"Unexpected value: \"\n-                    + borderDirection);\n-        }\n-\n-        boolean isVertical = borderDirection.equals(\"RIGHT\")\n-                || borderDirection.equals(\"LEFT\");\n-        boolean isHorizontal = borderDirection.equals(\"TOP\")\n-                || borderDirection.equals(\"BOTTOM\");\n-\n-        robot.mouseMove(x, y);\n-        for (int i = start; i < stop; i++) {\n-            int locX = isVertical ? i : (iFrameLoc.x + MIDPOINT);\n-            int locY = isHorizontal ? i : (iFrameLoc.y + MIDPOINT);\n-            if (Color.RED.equals(robot.getPixelColor(locX, locY))) {\n-                errorLog.append(\"At uiScale: \" + uiScale\n-                        + \", Red background color detected at \"\n-                        + borderDirection + \" border.\\n\");\n-                break;\n-            }\n-        }\n-        robot.delay(300);\n-    }\n-\n-    private static void checkCorners(String cornerLocation) {\n-        int x, y;\n-\n-        switch (cornerLocation) {\n-            case \"TOP_LEFT\" -> {\n-                x = iFrameLoc.x;\n-                y = iFrameLoc.y;\n-            }\n-            case \"TOP_RIGHT\" -> {\n-                x = iFrameMaxX;\n-                y = iFrameLoc.y;\n-            }\n-            case \"BOTTOM_RIGHT\" -> {\n-                x = iFrameMaxX;\n-                y = iFrameMaxY;\n-            }\n-            case \"BOTTOM_LEFT\" -> {\n-                x = iFrameLoc.x;\n-                y = iFrameMaxY;\n-            }\n-            default -> throw new IllegalStateException(\"Unexpected value: \"\n-                    + cornerLocation);\n-        }\n-\n-        boolean isTop = cornerLocation.equals(\"TOP_LEFT\")\n-                || cornerLocation.equals(\"TOP_RIGHT\");\n-        boolean isLeft = cornerLocation.equals(\"TOP_LEFT\")\n-                || cornerLocation.equals(\"BOTTOM_LEFT\");\n-\n-        robot.mouseMove(x, y);\n-        for (int i = 0; i < BORDER_THICKNESS - 1; i++) {\n-            int locX = isLeft ? (x + i) : (x - i);\n-            int locY = isTop ? (y + i) : (y - i);\n-            if (Color.RED.equals(robot.getPixelColor(locX, locY))) {\n-                errorLog.append(\"At uiScale: \" + uiScale + \", Red background color\"\n-                        + \" detected at \" + cornerLocation + \" corner.\\n\");\n-                break;\n-            }\n-        }\n-        robot.delay(300);\n-    }\n-\n-    private static void createAndShowGUI() {\n-        jFrame = new JFrame();\n-        jFrame.setSize(FRAME_SIZE, FRAME_SIZE);\n-        jFrame.setLayout(null);\n-        jFrame.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);\n-\n-        JLabel scale = new JLabel(\"UI Scale: \" + uiScale);\n-        iFrame = new JInternalFrame(\"iframe\", true);\n-        iFrame.setLayout(new GridBagLayout());\n-        iFrame.setBackground(Color.RED);\n-        iFrame.add(scale);\n-        iFrame.setLocation(30, 30);\n-        jFrame.getContentPane().add(iFrame);\n-        iFrame.setSize(INTFRAME_SIZE, INTFRAME_SIZE);\n-        iFrame.setVisible(true);\n-        jFrame.setLocation(150, 150);\n-        jFrame.setVisible(true);\n-    }\n-\n-    private static void saveScreenCapture(String filename) {\n-        MultiResolutionImage mrImage = robot.createMultiResolutionScreenCapture(jFrameBounds);\n-        List<Image> variants = mrImage.getResolutionVariants();\n-        RenderedImage image = (RenderedImage) variants.get(variants.size() - 1);\n-        try {\n-            ImageIO.write(image, \"png\", new File(filename));\n-        } catch (Exception e) {\n-            e.printStackTrace();\n-        }\n-    }\n-}\n","filename":"test\/jdk\/javax\/swing\/JInternalFrame\/InternalFrameBorderTest.java","additions":0,"deletions":266,"binary":false,"changes":266,"status":"deleted"},{"patch":"@@ -0,0 +1,351 @@\n+\/*\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.AWTException;\n+import java.awt.Color;\n+import java.awt.Frame;\n+import java.awt.GridBagLayout;\n+import java.awt.Image;\n+import java.awt.Point;\n+import java.awt.Rectangle;\n+import java.awt.Robot;\n+import java.awt.image.MultiResolutionImage;\n+import java.awt.image.RenderedImage;\n+import java.io.File;\n+import java.lang.reflect.InvocationTargetException;\n+import java.util.List;\n+import javax.imageio.ImageIO;\n+import javax.swing.JDialog;\n+import javax.swing.JFrame;\n+import javax.swing.JInternalFrame;\n+import javax.swing.JLabel;\n+import javax.swing.SwingUtilities;\n+import javax.swing.UIManager;\n+\n+\/*\n+ * @test\n+ * @bug 8015739 8294484\n+ * @key headful\n+ * @summary Tests whether Metal borders for JFrame, JDialog and JInternalFrame\n+ * scales correctly without any distortions by checking the midpoints and\n+ * corners of the border.\n+ *\n+ * @requires (os.family == \"windows\")\n+ * @run main\/othervm -Dsun.java2d.uiScale=1 ScaledMetalBorderTest\n+ * @run main\/othervm -Dsun.java2d.uiScale=1.25 ScaledMetalBorderTest\n+ * @run main\/othervm -Dsun.java2d.uiScale=1.5 ScaledMetalBorderTest\n+ * @run main\/othervm -Dsun.java2d.uiScale=1.75 ScaledMetalBorderTest\n+ * @run main\/othervm -Dsun.java2d.uiScale=2 ScaledMetalBorderTest\n+ * @run main\/othervm -Dsun.java2d.uiScale=2.5 ScaledMetalBorderTest\n+ * @run main\/othervm -Dsun.java2d.uiScale=3 ScaledMetalBorderTest\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8015739 8294484\n+ * @key headful\n+ * @summary Tests whether Metal borders for JFrame, JDialog and JInternalFrame\n+ * scales correctly without any distortions by checking the midpoints and\n+ * corners of the border.\n+ *\n+ * @requires (os.family == \"mac\" | os.family == \"linux\")\n+ * @run main\/othervm -Dsun.java2d.uiScale=1 ScaledMetalBorderTest\n+ * @run main\/othervm -Dsun.java2d.uiScale=2 ScaledMetalBorderTest\n+ *\/\n+\n+public class ScaledMetalBorderTest {\n+    private static final int SIZE = 250;\n+    private static final int INTFRAME_SIZE = 180;\n+    private static int MIDPOINT = SIZE \/ 2;\n+    private static final int BORDER_THICKNESS = 4;\n+\n+    private static final StringBuffer errorLog = new StringBuffer();\n+\n+    private static JFrame jFrame;\n+    private static JDialog jDialog;\n+    private static JInternalFrame iFrame;\n+    private static Rectangle windowBounds;\n+    private static Point windowLoc;\n+    private static int windowMaxX;\n+    private static int windowMaxY;\n+\n+    private static Robot robot;\n+    private static String uiScale;\n+    private static JLabel scale;\n+\n+    public static void main(String[] args) throws AWTException,\n+            InterruptedException, InvocationTargetException {\n+        try {\n+            UIManager.setLookAndFeel(\"javax.swing.plaf.metal.MetalLookAndFeel\");\n+            JFrame.setDefaultLookAndFeelDecorated(true);\n+            JDialog.setDefaultLookAndFeelDecorated(true);\n+        } catch (Exception e) {\n+            System.out.println(\"Metal LAF class not supported\");\n+            return;\n+        }\n+\n+        try {\n+            robot = new Robot();\n+            robot.setAutoDelay(100);\n+            uiScale = System.getProperty(\"sun.java2d.uiScale\");\n+            scale = new JLabel(\"UI Scale: \" + uiScale);\n+\n+            \/\/Case 1: JFrame\n+            SwingUtilities.invokeAndWait(ScaledMetalBorderTest::createFrame);\n+            robot.waitForIdle();\n+            robot.delay(100);\n+            runTests(\"JFrame\");\n+\n+            if (!errorLog.isEmpty()) {\n+                saveScreenCapture(\"Frame_uiScale_\" + uiScale + \".png\");\n+                System.err.println(\"JFrame at uiScale: \" + uiScale);\n+                throw new RuntimeException(\"Following error(s) occurred: \\n\"\n+                        + errorLog);\n+            }\n+            errorLog.setLength(0); \/\/ to clear the StringBuffer before next test.\n+\n+            \/\/Case 2: JDialog\n+            SwingUtilities.invokeAndWait(ScaledMetalBorderTest::createDialog);\n+            robot.waitForIdle();\n+            robot.delay(100);\n+            runTests(\"JDialog\");\n+\n+            if (!errorLog.isEmpty()) {\n+                saveScreenCapture(\"Dialog_uiScale_\" + uiScale + \".png\");\n+                System.err.println(\"JDialog at uiScale: \" + uiScale);\n+                throw new RuntimeException(\"Following error(s) occurred: \\n\"\n+                        + errorLog);\n+            }\n+            errorLog.setLength(0); \/\/ to clear the StringBuffer before next test.\n+\n+            \/\/Case 3: JInternalFrame\n+            SwingUtilities.invokeAndWait(ScaledMetalBorderTest::createJInternalFrame);\n+            robot.waitForIdle();\n+            robot.delay(100);\n+            runTests(\"JIF\");\n+\n+            if (!errorLog.isEmpty()) {\n+                saveScreenCapture(\"JIF_uiScale_\" + uiScale + \".png\");\n+                System.err.println(\"JInternalFrame at uiScale: \" + uiScale);\n+                throw new RuntimeException(\"Following error(s) occurred: \\n\"\n+                        + errorLog);\n+            }\n+        } finally {\n+            SwingUtilities.invokeAndWait(() ->{\n+                if (jFrame != null) {\n+                    jFrame.dispose();\n+                }\n+                if (jDialog != null) {\n+                    jDialog.dispose();\n+                }\n+            });\n+            robot.delay(200);\n+        }\n+    }\n+\n+    private static void runTests(String windowType) throws InterruptedException,\n+                                                         InvocationTargetException {\n+        SwingUtilities.invokeAndWait(() -> {\n+            switch (windowType) {\n+                case \"JFrame\" -> {\n+                    windowLoc = jFrame.getLocationOnScreen();\n+                    windowBounds = jFrame.getBounds();\n+                    windowMaxX = windowLoc.x + SIZE;\n+                    windowMaxY = windowLoc.y + SIZE;\n+                }\n+                case \"JDialog\" -> {\n+                    windowLoc = jDialog.getLocationOnScreen();\n+                    windowBounds = jDialog.getBounds();\n+                    windowMaxX = windowLoc.x + SIZE;\n+                    windowMaxY = windowLoc.y + SIZE;\n+                }\n+                case \"JIF\" -> {\n+                    MIDPOINT = INTFRAME_SIZE \/ 2;\n+                    windowLoc = iFrame.getLocationOnScreen();\n+                    windowBounds = jFrame.getBounds();\n+                    windowMaxX = windowLoc.x + INTFRAME_SIZE;\n+                    windowMaxY = windowLoc.y + INTFRAME_SIZE;\n+                }\n+            }\n+        });\n+\n+        \/\/ Check Borders\n+        checkBorderMidPoints(\"TOP\");\n+        checkBorderMidPoints(\"RIGHT\");\n+        checkBorderMidPoints(\"BOTTOM\");\n+        checkBorderMidPoints(\"LEFT\");\n+\n+        \/\/ Check Corner Diagonals\n+        checkCorners(\"TOP_LEFT\");\n+        checkCorners(\"TOP_RIGHT\");\n+        checkCorners(\"BOTTOM_RIGHT\");\n+        checkCorners(\"BOTTOM_LEFT\");\n+    }\n+\n+    private static void checkBorderMidPoints(String borderDirection) {\n+        int x, y;\n+        int start, stop;\n+\n+        switch (borderDirection) {\n+            case \"TOP\" -> {\n+                x = windowLoc.x + MIDPOINT;\n+                y = windowLoc.y + BORDER_THICKNESS;\n+                start = windowLoc.y;\n+                stop = windowLoc.y + BORDER_THICKNESS - 1;\n+            }\n+            case \"RIGHT\" -> {\n+                x = windowMaxX - BORDER_THICKNESS;\n+                y = windowLoc.y + MIDPOINT;\n+                start = windowMaxX - BORDER_THICKNESS + 1;\n+                stop = windowMaxX;\n+            }\n+            case \"BOTTOM\" -> {\n+                x = windowLoc.x + MIDPOINT;\n+                y = windowMaxY - BORDER_THICKNESS;\n+                start = windowMaxY - BORDER_THICKNESS + 1;\n+                stop = windowMaxY;\n+            }\n+            case \"LEFT\" -> {\n+                x = windowLoc.x;\n+                y = windowLoc.y + MIDPOINT;\n+                start = windowLoc.x;\n+                stop = windowLoc.x + BORDER_THICKNESS - 1;\n+            }\n+            default -> throw new IllegalStateException(\"Unexpected value: \"\n+                    + borderDirection);\n+        }\n+\n+        boolean isVertical = borderDirection.equals(\"RIGHT\")\n+                || borderDirection.equals(\"LEFT\");\n+        boolean isHorizontal = borderDirection.equals(\"TOP\")\n+                || borderDirection.equals(\"BOTTOM\");\n+\n+        robot.mouseMove(x, y);\n+        for (int i = start; i < stop; i++) {\n+            int locX = isVertical ? i : (windowLoc.x + MIDPOINT);\n+            int locY = isHorizontal ? i : (windowLoc.y + MIDPOINT);\n+            if (Color.RED.equals(robot.getPixelColor(locX, locY))) {\n+                errorLog.append(\"At uiScale: \" + uiScale\n+                        + \", Red background color detected at \"\n+                        + borderDirection + \" border.\\n\");\n+                break;\n+            }\n+        }\n+        robot.delay(100);\n+    }\n+\n+    private static void checkCorners(String cornerLocation) {\n+        int x, y;\n+\n+        switch (cornerLocation) {\n+            case \"TOP_LEFT\" -> {\n+                x = windowLoc.x;\n+                y = windowLoc.y;\n+            }\n+            case \"TOP_RIGHT\" -> {\n+                x = windowMaxX;\n+                y = windowLoc.y;\n+            }\n+            case \"BOTTOM_RIGHT\" -> {\n+                x = windowMaxX;\n+                y = windowMaxY;\n+            }\n+            case \"BOTTOM_LEFT\" -> {\n+                x = windowLoc.x;\n+                y = windowMaxY;\n+            }\n+            default -> throw new IllegalStateException(\"Unexpected value: \"\n+                    + cornerLocation);\n+        }\n+\n+        boolean isTop = cornerLocation.equals(\"TOP_LEFT\")\n+                || cornerLocation.equals(\"TOP_RIGHT\");\n+        boolean isLeft = cornerLocation.equals(\"TOP_LEFT\")\n+                || cornerLocation.equals(\"BOTTOM_LEFT\");\n+\n+        robot.mouseMove(x, y);\n+        for (int i = 0; i < BORDER_THICKNESS - 1; i++) {\n+            int locX = isLeft ? (x + i) : (x - i);\n+            int locY = isTop ? (y + i) : (y - i);\n+            if (Color.RED.equals(robot.getPixelColor(locX, locY))) {\n+                errorLog.append(\"At uiScale: \" + uiScale + \", Red background color\"\n+                        + \" detected at \" + cornerLocation + \" corner.\\n\");\n+                break;\n+            }\n+        }\n+        robot.delay(100);\n+    }\n+\n+    private static void createFrame() {\n+        jFrame = new JFrame(\"Frame with Metal Border\");\n+        jFrame.setSize(SIZE, SIZE);\n+        jFrame.setBackground(Color.RED);\n+        jFrame.getContentPane().setBackground(Color.RED);\n+        jFrame.setLayout(new GridBagLayout());\n+        jFrame.getContentPane().add(scale);\n+        jFrame.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);\n+        jFrame.setLocation(150, 150);\n+        jFrame.setVisible(true);\n+    }\n+\n+    private static void createDialog() {\n+        jDialog = new JDialog((Frame) null , \"Dialog with Metal Border\");\n+        jDialog.setSize(SIZE, SIZE);\n+        jDialog.setBackground(Color.RED);\n+        jDialog.getContentPane().setBackground(Color.RED);\n+        jDialog.setLayout(new GridBagLayout());\n+        jDialog.getContentPane().add(scale);\n+        jDialog.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);\n+        jDialog.setLocation(150, 150);\n+        jDialog.setVisible(true);\n+    }\n+\n+    private static void createJInternalFrame() {\n+        jFrame = new JFrame(\"JIF with Metal Border\");\n+        jFrame.setSize(SIZE, SIZE);\n+        jFrame.setLayout(null);\n+        jFrame.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);\n+\n+        iFrame = new JInternalFrame(\"iframe\", true);\n+        iFrame.setLayout(new GridBagLayout());\n+        iFrame.setBackground(Color.RED);\n+        iFrame.add(scale);\n+        iFrame.setLocation(30, 30);\n+        jFrame.getContentPane().add(iFrame);\n+        iFrame.setSize(INTFRAME_SIZE, INTFRAME_SIZE);\n+        iFrame.setVisible(true);\n+        jFrame.setLocation(150, 150);\n+        jFrame.setVisible(true);\n+    }\n+\n+    private static void saveScreenCapture(String filename) {\n+        MultiResolutionImage mrImage = robot.createMultiResolutionScreenCapture(windowBounds);\n+        List<Image> variants = mrImage.getResolutionVariants();\n+        RenderedImage image = (RenderedImage) variants.get(variants.size() - 1);\n+        try {\n+            ImageIO.write(image, \"png\", new File(filename));\n+        } catch (Exception e) {\n+            e.printStackTrace();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/javax\/swing\/plaf\/metal\/MetalBorders\/ScaledMetalBorderTest.java","additions":351,"deletions":0,"binary":false,"changes":351,"status":"added"}]}