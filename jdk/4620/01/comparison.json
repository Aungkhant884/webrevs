{"files":[{"patch":"@@ -37,0 +37,1 @@\n+#include \"runtime\/atomic.hpp\"\n@@ -48,0 +49,3 @@\n+volatile intx JVMCI::_fatal_log_init_thread = -1;\n+volatile outputStream* JVMCI::_fatal_log_stream = NULL;\n+const char* JVMCI::_fatal_log_filename = NULL;\n@@ -214,0 +218,40 @@\n+void JVMCI::fatal_log(const char* buf, size_t count) {\n+  intx current_thread_id = os::current_thread_id();\n+  intx invalid_id = -1;\n+  if (_fatal_log_init_thread == invalid_id && Atomic::cmpxchg(&_fatal_log_init_thread, invalid_id, current_thread_id) == invalid_id) {\n+    static char name_buffer[O_BUFLEN];\n+    static fdStream log(-1);\n+    if (ErrorFileToStdout) {\n+      log.set_fd(1);\n+    } else if (ErrorFileToStderr) {\n+      log.set_fd(2);\n+    } else {\n+      int fd = VMError::prepare_log_file(JVMCINativeLibraryErrorFile, LIBJVMCI_ERR_FILE, true, name_buffer, sizeof(name_buffer));\n+      if (fd != -1) {\n+        _fatal_log_filename = name_buffer;\n+        log.set_fd(fd);\n+      } else {\n+        int e = errno;\n+        tty->print(\"Can't open JVMCI shared library report file. Error: \");\n+        tty->print_raw_cr(os::strerror(e));\n+        tty->print_cr(\"JVMCI shared library report will be written to console.\");\n+\n+        \/\/ See notes in VMError::report_and_die about hard coding tty to 1\n+        log.set_fd(1);\n+      }\n+      _fatal_log_stream = &log;\n+    }\n+  } else {\n+    \/\/ Another thread won the race to initialize the stream. Give it time\n+    \/\/ to complete initialization. VM locks cannot be used as the current\n+    \/\/ thread might not be attached to the VM (e.g. a native thread started\n+    \/\/ within libjvmci).\n+    while (_fatal_log_stream == NULL) {\n+      os::naked_short_sleep(50);\n+    }\n+  }\n+  outputStream* out = (outputStream*) _fatal_log_stream;\n+  out->write(buf, count);\n+  out->flush();\n+}\n+\n","filename":"src\/hotspot\/share\/jvmci\/jvmci.cpp","additions":44,"deletions":0,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -77,0 +77,10 @@\n+  \/\/ The stream to which fatal_log() writes. The stream is configured on\n+  \/\/ first call to fatal_log().\n+  static volatile outputStream* _fatal_log_stream;\n+\n+  \/\/ The path of the file underlying _fatal_log_stream if it is a fileStream.\n+  static const char* _fatal_log_filename;\n+\n+  \/\/ Native thread id of thread that will initialize _fatal_log_stream.\n+  static volatile intx _fatal_log_init_thread;\n+\n@@ -103,0 +113,7 @@\n+  \/\/ Logs the fatal crash data in `buf` to the appropriate stream.\n+  static void fatal_log(const char* buf, size_t count);\n+\n+  \/\/ Gets the name of the opened JVMCI shared library crash data file or NULL\n+  \/\/ if this file has not been created.\n+  static const char* fatal_log_filename() { return _fatal_log_filename; }\n+\n","filename":"src\/hotspot\/share\/jvmci\/jvmci.hpp","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -894,0 +894,6 @@\n+\/\/ Function for redirecting shared library JavaVM fatal error data to a log file.\n+\/\/ The log file is opened on first call to this function.\n+static void _fatal_log(const char* buf, size_t count) {\n+  JVMCI::fatal_log(buf, count);\n+}\n+\n@@ -901,1 +907,2 @@\n-  fatal(\"Fatal error in JVMCI shared library\");\n+  intx current_thread_id = os::current_thread_id();\n+  fatal(\"thread \" INTX_FORMAT \": Fatal error in JVMCI shared library\", current_thread_id);\n@@ -928,1 +935,1 @@\n-    JavaVMOption options[4];\n+    JavaVMOption options[5];\n@@ -943,0 +950,2 @@\n+    options[4].optionString = (char*) \"_fatal_log\";\n+    options[4].extraInfo = (void*) _fatal_log;\n","filename":"src\/hotspot\/share\/jvmci\/jvmciRuntime.cpp","additions":11,"deletions":2,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -124,0 +124,1 @@\n+  CHECK_NOT_SET(JVMCINativeLibraryErrorFile,  EnableJVMCI)\n@@ -179,0 +180,1 @@\n+    \"JVMCINativeLibraryErrorFile\",\n","filename":"src\/hotspot\/share\/jvmci\/jvmci_globals.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,0 +33,2 @@\n+#define LIBJVMCI_ERR_FILE \"hs_err_pid%p_libjvmci.log\"\n+\n@@ -126,0 +128,5 @@\n+  product(ccstr, JVMCINativeLibraryErrorFile, NULL, EXPERIMENTAL,           \\\n+          \"If an error in the JVMCI native library occurs, save the \"       \\\n+          \"error data to this file\"                                         \\\n+          \"[default: .\/\" LIBJVMCI_ERR_FILE \"] (%p replaced with pid)\")      \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/jvmci\/jvmci_globals.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -66,0 +66,3 @@\n+#if INCLUDE_JVMCI\n+#include \"jvmci\/jvmci.hpp\"\n+#endif\n@@ -1276,1 +1279,1 @@\n-static int prepare_log_file(const char* pattern, const char* default_pattern, bool overwrite_existing, char* buf, size_t buflen) {\n+int VMError::prepare_log_file(const char* pattern, const char* default_pattern, bool overwrite_existing, char* buf, size_t buflen) {\n@@ -1587,0 +1590,7 @@\n+#if INCLUDE_JVMCI\n+  if (JVMCI::fatal_log_filename() != NULL) {\n+    out.print_raw(\"#\\n# The JVMCI shared library report file is saved as:\\n# \");\n+    out.print_raw_cr(JVMCI::fatal_log_filename());\n+  }\n+#endif\n+\n","filename":"src\/hotspot\/share\/utilities\/vmError.cpp","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -187,0 +187,5 @@\n+  \/\/ Construct file name for a log file and return it's file descriptor.\n+  \/\/ Name and location depends on pattern, default_pattern params and access\n+  \/\/ permissions.\n+  static int prepare_log_file(const char* pattern, const char* default_pattern, bool overwrite_existing, char* buf, size_t buflen);\n+\n","filename":"src\/hotspot\/share\/utilities\/vmError.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"}]}