{"files":[{"patch":"@@ -1898,1 +1898,0 @@\n-                                      bool need_verify,\n@@ -1909,1 +1908,1 @@\n-  \/\/ check code_attribute_length first\n+  \/\/ check code_attribute_length\n@@ -1912,3 +1911,0 @@\n-  if (!need_verify && !DumpSharedSpaces) {\n-    return nullptr;\n-  }\n@@ -2538,1 +2534,1 @@\n-          stackmap_data = parse_stackmap_table(cfs, code_attribute_length, _need_verify, CHECK_NULL);\n+          stackmap_data = parse_stackmap_table(cfs, code_attribute_length, CHECK_NULL);\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,115 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ *\n+ * @bug 8228604\n+ *\n+ * @requires vm.jvmti\n+ * @modules java.base\/jdk.internal.org.objectweb.asm\n+ * @library \/test\/lib\n+ *\n+ * @run main\/othervm\/native -agentlib:MissedStackMapFrames MissedStackMapFrames\n+ *\/\n+\n+import jdk.internal.org.objectweb.asm.ClassReader;\n+import jdk.internal.org.objectweb.asm.ClassVisitor;\n+import jdk.internal.org.objectweb.asm.MethodVisitor;\n+import jdk.internal.org.objectweb.asm.Opcodes;\n+\n+\n+public class MissedStackMapFrames {\n+    static {\n+        System.loadLibrary(\"MissedStackMapFrames\");\n+    }\n+\n+    \/* For each test class:\n+     *  - loads class (JNIEnv::FindClass);\n+     *  - retransforms class (jvmtiEnv::RetransformClasses).\n+     * Saves class bytes passed to ClassFileLoadHook.\n+     *\/\n+    private static native boolean doTest();\n+\n+    \/* methods to analyze doTest results *\/\n+    private static native int testCount();\n+    private static native Class testClass(int idx);\n+    private static native byte[] loadBytes(int idx);\n+    private static native byte[] retransformBytes(int idx);\n+\n+    private static int getStackMapFrameCount(byte[] classfileBuffer) {\n+        ClassReader reader = new ClassReader(classfileBuffer);\n+        final int[] frameCount = {0};\n+        ClassVisitor cv = new ClassVisitor(Opcodes.ASM9) {\n+            @Override\n+            public MethodVisitor visitMethod(int access, String name,\n+                                             String descriptor, String signature,\n+                                             String[] exceptions) {\n+                return new MethodVisitor(Opcodes.ASM9) {\n+                    private int methodFrames = 0;\n+                    @Override\n+                    public void visitFrame(int type, int numLocal, Object[] local,\n+                                           int numStack, Object[] stack) {\n+                        methodFrames++;\n+                    }\n+                    @Override\n+                    public void visitEnd() {\n+                        log(\"  method \" + name + \" - \" + methodFrames + \" frames\");\n+                        frameCount[0] += methodFrames;\n+                    }\n+                };\n+            }\n+        };\n+        reader.accept(cv, 0);\n+        return frameCount[0];\n+    }\n+\n+    private static void checkStackMapFrames(String mode, byte[] classfileBuffer) {\n+        log(mode + \", len = \" + classfileBuffer.length);\n+        int frameCount = getStackMapFrameCount(classfileBuffer);\n+        log(\"  Has stack map frames: \" + frameCount);\n+        if (frameCount == 0) {\n+            throw new RuntimeException(mode + \" - no stack frames\");\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        if (!doTest()) {\n+            throw new RuntimeException(\"Test failed\");\n+        }\n+\n+        \/\/ verify results\n+        for (int i = 0; i < testCount(); i++) {\n+            Class cls = testClass(i);\n+            byte[] loadBytes = loadBytes(i);\n+            byte[] retransformBytes = retransformBytes(i);\n+            checkStackMapFrames(cls + \"(load)\", loadBytes);\n+            checkStackMapFrames(cls + \"(retranform)\", retransformBytes);\n+        }\n+    }\n+\n+    private static void log(Object msg) {\n+        System.out.println(msg);\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/RedefineClasses\/MissedStackMapFrames\/MissedStackMapFrames.java","additions":115,"deletions":0,"binary":false,"changes":115,"status":"added"},{"patch":"@@ -0,0 +1,223 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <jni.h>\n+#include <jvmti.h>\n+#include <stdio.h>\n+#include <string.h>\n+\n+static void _log(const char* format, ...) {\n+    va_list args;\n+    va_start(args, format);\n+    vprintf(format, args);\n+    va_end(args);\n+    fflush(0);\n+}\n+\n+static jvmtiEnv* jvmti = nullptr;\n+\n+static const char* testClassNames[] = {\n+    \"java\/util\/Date\",               \/\/ JDK class in CDS archive\n+    \"java\/lang\/ProcessBuilder\",     \/\/ JDK class not in CDS\n+    \"MissedStackMapFrames\"          \/\/ non-JDK class\n+};\n+static const int testClassCount = sizeof(testClassNames) \/ sizeof(testClassNames[0]);\n+\n+struct SavedClassBytes {\n+    struct Buffer {\n+        unsigned char* bytes;\n+        jint len;\n+\n+        Buffer() : bytes(nullptr), len(0) {}\n+\n+        void save(const unsigned char *bytes, jint len) {\n+            jvmtiError err = jvmti->Allocate(len, &this->bytes);\n+            if (err != JVMTI_ERROR_NONE) {\n+                _log(\"ClassFileLoadHook: failed to allocate %ld bytes for saved class bytes: %d\", len, err);\n+                return;\n+            }\n+            memcpy(this->bytes, bytes, len);\n+            this->len = len;\n+        }\n+\n+        jbyteArray get(JNIEnv *env) {\n+            if (bytes == nullptr) {\n+                _log(\"SavedClassBytes: NULL\\n\");\n+                return nullptr;\n+            }\n+\n+            jbyteArray result = env->NewByteArray(len);\n+            if (result == nullptr) {\n+                _log(\"SavedClassBytes: NewByteArray(%ld) failed\\n\", len);\n+            } else {\n+                jbyte* arrayPtr = env->GetByteArrayElements(result, nullptr);\n+                if (arrayPtr == nullptr) {\n+                    _log(\"SavedClassBytes: Failed to get array elements\\n\");\n+                    result = nullptr;\n+                } else {\n+                    memcpy(arrayPtr, bytes, len);\n+                    env->ReleaseByteArrayElements(result, arrayPtr, 0);\n+                }\n+            }\n+            return result;\n+        }\n+\n+    };\n+\n+    jclass klass;\n+\n+    Buffer load;\n+    Buffer retransform;\n+\n+    SavedClassBytes() : klass(nullptr) {}\n+};\n+\n+static SavedClassBytes savedBytes[testClassCount];\n+\n+static int testClassIndex(const char *name) {\n+    if (name != nullptr) {\n+        for (int i = 0; i < testClassCount; i++) {\n+            if (strcmp(name, testClassNames[i]) == 0) {\n+                return i;\n+            }\n+        }\n+    }\n+    return -1;\n+}\n+\n+\n+extern \"C\" {\n+\n+JNIEXPORT void JNICALL\n+callbackClassFileLoadHook(jvmtiEnv *jvmti_env,\n+        JNIEnv* jni_env,\n+        jclass class_being_redefined,\n+        jobject loader,\n+        const char* name,\n+        jobject protection_domain,\n+        jint class_data_len,\n+        const unsigned char* class_data,\n+        jint* new_class_data_len,\n+        unsigned char** new_class_data) {\n+    int idx = testClassIndex(name);\n+    if (idx >= 0) {\n+        if (class_being_redefined == nullptr) {\n+            \/\/ load\n+            savedBytes[idx].load.save(class_data, class_data_len);\n+        } else {\n+            \/\/ retransform\/redefine\n+            savedBytes[idx].retransform.save(class_data, class_data_len);\n+        }\n+    }\n+}\n+\n+JNIEXPORT jint JNICALL Agent_OnLoad(JavaVM* jvm, char* options, void* reserved) {\n+    jint res = jvm->GetEnv((void **)&jvmti, JVMTI_VERSION_1_1);\n+    if (res != JNI_OK) {\n+        _log(\"Failed to get JVMTI interface: %ld\\n\", res);\n+        return JNI_ERR;\n+    }\n+\n+    jvmtiCapabilities caps;\n+    memset(&caps, 0, sizeof(caps));\n+\n+    caps.can_retransform_classes = 1;\n+    jvmtiError err = jvmti->AddCapabilities(&caps);\n+    if (err != JVMTI_ERROR_NONE) {\n+        _log(\"Failed to add capabilities: %d\\n\", err);\n+        return JNI_ERR;\n+    }\n+\n+    jvmtiEventCallbacks eventCallbacks;\n+    memset(&eventCallbacks, 0, sizeof(eventCallbacks));\n+    eventCallbacks.ClassFileLoadHook = callbackClassFileLoadHook;\n+    err = jvmti->SetEventCallbacks(&eventCallbacks, sizeof(eventCallbacks));\n+    if (err != JVMTI_ERROR_NONE) {\n+        _log(\"Error setting event callbacks: %d\\n\", err);\n+        return JNI_ERR;\n+    }\n+\n+    err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_CLASS_FILE_LOAD_HOOK, nullptr);\n+    if (err != JVMTI_ERROR_NONE) {\n+        _log(\"SetEventNotificationMode(JVMTI_ENABLE) error %d\\n\", err);\n+        return JNI_ERR;\n+    }\n+\n+    return JNI_OK;\n+}\n+\n+JNIEXPORT void JNICALL\n+Agent_OnUnload(JavaVM* jvm) {\n+    return;\n+}\n+\n+\n+JNIEXPORT jboolean JNICALL\n+Java_MissedStackMapFrames_doTest(JNIEnv* env, jclass klass) {\n+\n+    jboolean result = JNI_TRUE;\n+    _log(\">>nTest\\n\");\n+\n+    for (int i = 0; i < testClassCount; i++) {\n+        _log(\"Loading %s...\\n\", testClassNames[i]);\n+\n+        savedBytes[i].klass = env->FindClass(testClassNames[i]);\n+        if (savedBytes[i].klass == nullptr) {\n+            _log(\"Load error\\n\");\n+            result = JNI_FALSE;\n+            continue;\n+        }\n+        savedBytes[i].klass = (jclass)env->NewGlobalRef(savedBytes[i].klass);\n+\n+        _log(\"Retransforming %s...\\n\", testClassNames[i]);\n+        jvmtiError err = jvmti->RetransformClasses(1, &savedBytes[i].klass);\n+        if (err != JVMTI_ERROR_NONE) {\n+            _log(\"RetransformClasses error %d\\n\", err);\n+            result = JNI_FALSE;\n+        }\n+    }\n+    _log(\"<<nTest\\n\");\n+    return result;\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_MissedStackMapFrames_testCount(JNIEnv* env, jclass klass) {\n+    return testClassCount;\n+}\n+\n+JNIEXPORT jclass JNICALL\n+Java_MissedStackMapFrames_testClass(JNIEnv* env, jclass klass, jint idx) {\n+    return savedBytes[idx].klass;\n+}\n+\n+JNIEXPORT jbyteArray JNICALL\n+Java_MissedStackMapFrames_loadBytes(JNIEnv* env, jclass klass, jint idx) {\n+    return savedBytes[idx].load.get(env);\n+}\n+\n+JNIEXPORT jbyteArray JNICALL\n+Java_MissedStackMapFrames_retransformBytes(JNIEnv* env, jclass klass, jint idx) {\n+    return savedBytes[idx].retransform.get(env);\n+}\n+\n+} \/\/ extern \"C\"\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/RedefineClasses\/MissedStackMapFrames\/libMissedStackMapFrames.cpp","additions":223,"deletions":0,"binary":false,"changes":223,"status":"added"}]}