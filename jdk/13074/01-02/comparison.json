{"files":[{"patch":"@@ -36,0 +36,1 @@\n+import java.util.Objects;\n@@ -76,1 +77,1 @@\n-     * {@code String} or {@code Integer} or {@code Class}.\n+     * {@code String} or {@code Integer} or {@code Class} or {@code EnumDesc}.\n@@ -108,1 +109,1 @@\n-     *               and {@code Class} instances, in any combination\n+     *               and {@code Class} and {@code EnumDesc} instances, in any combination\n@@ -152,0 +153,2 @@\n+        Objects.checkIndex(startIndex, labels.length + 1);\n+\n@@ -271,3 +274,1 @@\n-        } else if (labelClass == String.class) {\n-            \/\/OK\n-        } else {\n+        } else if (labelClass != String.class) {\n@@ -321,0 +322,2 @@\n+        Objects.checkIndex(startIndex, labels.length + 1);\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/runtime\/SwitchBootstraps.java","additions":8,"deletions":5,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -201,1 +201,1 @@\n-    private boolean allowUnconditionalPatternsInstanceOf;\n+    private final boolean allowUnconditionalPatternsInstanceOf;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -66,0 +66,1 @@\n+import java.util.stream.Collectors;\n@@ -774,0 +775,9 @@\n+            @Override\n+            public boolean equals(Object o) {\n+                return o instanceof BindingPattern other &&\n+                       type.tsym == other.type.tsym;\n+            }\n+            @Override\n+            public String toString() {\n+                return type.tsym + \" _\";\n+            }\n@@ -782,0 +792,1 @@\n+            @Override\n@@ -786,0 +797,7 @@\n+            @Override\n+            public boolean equals(Object o) {\n+                return o instanceof RecordPattern other &&\n+                       recordType.tsym == other.recordType.tsym &&\n+                       Arrays.equals(nested, other.nested);\n+            }\n+\n@@ -800,0 +818,6 @@\n+            @Override\n+            public String toString() {\n+                return recordType.tsym + \"(\" + Arrays.stream(nested)\n+                                                     .map(pd -> pd.toString())\n+                                                     .collect(Collectors.joining(\", \")) + \")\";\n+            }\n@@ -803,1 +827,1 @@\n-            List<PatternDescription> patterns = List.nil();\n+            Set<PatternDescription> patternSet = new HashSet<>();\n@@ -812,1 +836,1 @@\n-                            patterns = patterns.prepend(PatternDescription.from(types, component, patternLabel.pat));\n+                            patternSet.add(PatternDescription.from(types, component, patternLabel.pat));\n@@ -830,1 +854,1 @@\n-                    patterns = patterns.prepend(new BindingPattern(e.getKey().type));\n+                    patternSet.add(new BindingPattern(e.getKey().type));\n@@ -833,0 +857,1 @@\n+            List<PatternDescription> patterns = List.from(patternSet);\n@@ -890,0 +915,5 @@\n+            Set<Symbol> existingBindings = patterns.stream()\n+                                                   .filter(pd -> pd instanceof BindingPattern)\n+                                                   .map(pd -> ((BindingPattern) pd).type.tsym)\n+                                                   .collect(Collectors.toSet());\n+\n@@ -896,1 +926,0 @@\n-                        ListBuffer<PatternDescription> bindings = new ListBuffer<>();\n@@ -899,1 +928,4 @@\n-                        if (clazz.isSealed() && clazz.isAbstract()) {\n+                        if (clazz.isSealed() && clazz.isAbstract() &&\n+                            \/\/if a binding pattern for clazz already exists, no need to analyze it again:\n+                            !existingBindings.contains(clazz)) {\n+                            ListBuffer<PatternDescription> bindings = new ListBuffer<>();\n@@ -909,1 +941,6 @@\n-                                Type instantiated = infer.instantiatePatternType(selectorType, csym);\n+                                Type instantiated;\n+                                if (csym.type.allparams().isEmpty()) {\n+                                    instantiated = csym.type;\n+                                } else {\n+                                    instantiated = infer.instantiatePatternType(selectorType, csym);\n+                                }\n@@ -923,7 +960,0 @@\n-                                        if (types.isSubtype(types.erasure(perm.type),\n-                                                            types.erasure(bpOther.type))) {\n-                                            it.remove();\n-                                            reduces = true;\n-                                            continue PERMITTED;\n-                                        }\n-\n@@ -934,1 +964,0 @@\n-                                                reduces = true;\n@@ -938,0 +967,7 @@\n+                                        if (types.isSubtype(types.erasure(perm.type),\n+                                                            types.erasure(bpOther.type))) {\n+                                            it.remove();\n+                                            reduces = true;\n+                                            continue ;\n+                                        }\n+\n@@ -953,10 +989,2 @@\n-                    Set<PatternDescription> cleanedToRemove = new HashSet<>(toRemove);\n-                    Set<PatternDescription> cleanedToAdd = new HashSet<>(toAdd);\n-\n-                    \/\/make sure we don't unnecessarily modify the list of patterns with\n-                    \/\/addition and removal of the same binding pattern:\n-                    cleanedToRemove.removeAll(toAdd);\n-                    cleanedToAdd.removeAll(toRemove);\n-\n-                    if (!cleanedToAdd.isEmpty() || !cleanedToRemove.isEmpty()) {\n-                        for (PatternDescription pd : cleanedToRemove) {\n+                    if (!toAdd.isEmpty() || !toRemove.isEmpty()) {\n+                        for (PatternDescription pd : toRemove) {\n@@ -965,1 +993,1 @@\n-                        for (PatternDescription pd : cleanedToAdd) {\n+                        for (PatternDescription pd : toAdd) {\n@@ -1021,1 +1049,1 @@\n-            var grouppedPerRecordClass =\n+            var groupByRecordClass =\n@@ -1027,1 +1055,1 @@\n-            for (var e : grouppedPerRecordClass.entrySet()) {\n+            for (var e : groupByRecordClass.entrySet()) {\n@@ -1051,1 +1079,1 @@\n-                            NEXT_PATTERN: for (int nextCandidate = firstCandidate + 1;\n+                            NEXT_PATTERN: for (int nextCandidate = 0;\n@@ -1054,0 +1082,4 @@\n+                                if (firstCandidate == nextCandidate) {\n+                                    continue;\n+                                }\n+\n@@ -1058,1 +1090,1 @@\n-                                            !exactlyMatches(rpOne.nested[i], rpOther.nested[i])) {\n+                                            !rpOne.nested[i].equals(rpOther.nested[i])) {\n@@ -1069,0 +1101,1 @@\n+                            updatedPatterns = reduceRecordPatterns(updatedPatterns);\n@@ -1100,16 +1133,0 @@\n-        private boolean exactlyMatches(PatternDescription one, PatternDescription other) {\n-            if (one instanceof BindingPattern bpOne && other instanceof BindingPattern bpOther) {\n-                return bpOne.type.tsym == bpOther.type.tsym;\n-            } else if (one instanceof RecordPattern rpOne && other instanceof RecordPattern rpOther) {\n-                if (rpOne.recordType.tsym == rpOther.recordType.tsym) {\n-                    for (int i = 0; i < rpOne.nested.length; i++) {\n-                        if (!exactlyMatches(rpOne.nested[i], rpOther.nested[i])) {\n-                            return false;\n-                        }\n-                    }\n-                    return true;\n-                }\n-            }\n-            return false;\n-        }\n-\n@@ -1136,1 +1153,1 @@\n-        }\n+                }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Flow.java","additions":63,"deletions":46,"binary":false,"changes":109,"status":"modified"},{"patch":"@@ -313,1 +313,1 @@\n-            JCPattern nestedPattern = TreeInfo.skipParens(nestedPatterns.head);\n+            JCPattern nestedPattern = nestedPatterns.head;\n@@ -436,1 +436,1 @@\n-                        JCPattern pattern = TreeInfo.skipParens(patternLabel.pat);\n+                        JCPattern pattern = patternLabel.pat;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TransPatterns.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -845,7 +845,0 @@\n-    \/** Skip parens and return the enclosed expression\n-     *\/\n-    \/\/XXX: remove??\n-    public static JCPattern skipParens(JCPattern tree) {\n-        return tree;\n-    }\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeInfo.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -268,0 +268,46 @@\n+\n+    public void testIncorrectEnumLabels() throws Throwable {\n+        try {\n+            testEnum(E1.B, 0, -1, \"B\", 1);\n+            fail(\"Didn't get the expected exception.\");\n+        } catch (IllegalArgumentException ex) {\n+            \/\/OK\n+        }\n+        try {\n+            testEnum(E1.B, 0, -1, \"B\", null);\n+            fail(\"Didn't get the expected exception.\");\n+        } catch (IllegalArgumentException ex) {\n+            \/\/OK\n+        }\n+    }\n+\n+    public void testIncorrectEnumStartIndex() throws Throwable {\n+        try {\n+            testEnum(E1.B, -1, -1, \"B\");\n+            fail(\"Didn't get the expected exception.\");\n+        } catch (IndexOutOfBoundsException ex) {\n+            \/\/OK\n+        }\n+        try {\n+            testEnum(E1.B, 2, -1, \"B\");\n+            fail(\"Didn't get the expected exception.\");\n+        } catch (IndexOutOfBoundsException ex) {\n+            \/\/OK\n+        }\n+    }\n+\n+    public void testIncorrectTypeStartIndex() throws Throwable {\n+        try {\n+            testType(\"\", -1, -1, \"\");\n+            fail(\"Didn't get the expected exception.\");\n+        } catch (IndexOutOfBoundsException ex) {\n+            \/\/OK\n+        }\n+        try {\n+            testType(\"\", 2, -1, \"\");\n+            fail(\"Didn't get the expected exception.\");\n+        } catch (IndexOutOfBoundsException ex) {\n+            \/\/OK\n+        }\n+    }\n+\n","filename":"test\/jdk\/java\/lang\/runtime\/SwitchBootstrapsTest.java","additions":46,"deletions":0,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -1575,0 +1575,27 @@\n+    @Test\n+    public void testComplexSubTypes6(Path base) throws Exception {\n+        doTest(base,\n+               new String[0],\n+               \"\"\"\n+               class Test {\n+                   sealed interface I0 permits I1, I2 { }\n+                   sealed interface I00 permits I1, I2 { }\n+\n+                   sealed interface I1 extends I0, I00 permits B, C { }\n+                   sealed interface I2 extends I0, I00 permits B, C { }\n+\n+                   static final class B implements I1, I2 { }\n+                   static final class C implements I1, I2 { }\n+\n+                   int test(Object o) {\n+                       return switch (o) {\n+                           case B c -> 2;\n+                           case C d -> 3;\n+                       };\n+                   }\n+               }\n+               \"\"\",\n+               \"Test.java:12:16: compiler.err.not.exhaustive\",\n+               \"1 error\");\n+    }\n+\n@@ -1798,0 +1825,24 @@\n+        doTest(base,\n+               new String[0],\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   sealed interface I {}\n+                   sealed interface S1 extends I {}\n+                   sealed interface S2 extends I {}\n+                   final class C1 implements S1 {}\n+                   final class C2 implements S2 {}\n+                   final class C12 implements S1, S2 {}\n+\n+                   void test(I i) {\n+                       switch (i) {\n+                           case C12 c ->\n+                               System.out.println(\"C12\");\n+                           case C1 c ->\n+                               System.out.println(\"C1\");\n+                           case C2 c ->\n+                               System.out.println(\"C2\");\n+                       }\n+                   }\n+               }\n+               \"\"\");\n@@ -1825,0 +1876,130 @@\n+               }\n+               \"\"\");\n+        doTest(base,\n+               new String[0],\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   sealed interface I {}\n+                   sealed interface S1 extends I {}\n+                   sealed interface S2 extends I {}\n+                   final class C1 implements S1 {}\n+                   final class C2 implements S2 {}\n+                   final class C12 implements S1, S2 {}\n+                   record R(I i) {}\n+\n+                   void test(R r) {\n+                       switch (r) {\n+                           case R(C12 c) ->\n+                               System.out.println(\"C12\");\n+                           case R(C1 c) ->\n+                               System.out.println(\"C1\");\n+                           case R(C2 c) ->\n+                               System.out.println(\"C2\");\n+                       }\n+                   }\n+               }\n+               \"\"\");\n+    }\n+\n+    @Test\n+    public void testDiamondInheritance5(Path base) throws Exception {\n+        doTest(base,\n+               new String[0],\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   sealed interface I {}\n+                   sealed interface S1 extends I {}\n+                   sealed interface S2 extends I {}\n+                   sealed interface S3 extends I {}\n+                   final class C13 implements S1, S3 {}\n+                   final class C23 implements S2, S3 {}\n+\n+                   void test(I i) {\n+                       switch (i) {\n+                           case C13 c ->\n+                               System.out.println(\"C13\");\n+                           case C23 c ->\n+                               System.out.println(\"C23\");\n+                       }\n+                   }\n+               }\n+               \"\"\");\n+    }\n+\n+    @Test\n+    public void testDiamondInheritance6(Path base) throws Exception {\n+        doTest(base,\n+               new String[0],\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   sealed interface I {}\n+                   sealed interface S1 extends I {}\n+                   sealed interface S2 extends I {}\n+                   final class C1 implements S1 {}\n+                   sealed abstract class C2 implements S2 {}\n+                   final class C2Prime extends C2 {}\n+                   final class C12 implements S1, S2 {}\n+\n+                   void test(I i) {\n+                       switch (i) {\n+                           case C1 c ->\n+                               System.out.println(\"C1\");\n+                           case C2Prime c ->\n+                               System.out.println(\"C2\");\n+                           case C12 c ->\n+                               System.out.println(\"C12\");\n+                       }\n+                   }\n+               }\n+               \"\"\");\n+        doTest(base,\n+               new String[0],\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   sealed interface I {}\n+                   sealed interface S1 extends I {}\n+                   sealed interface S2 extends I {}\n+                   final class C1 implements S1 {}\n+                   sealed abstract class C2 implements S2 {}\n+                   final class C2Prime extends C2 {}\n+                   final class C12 implements S1, S2 {}\n+\n+                   void test(I i) {\n+                       switch (i) {\n+                           case C2Prime c ->\n+                               System.out.println(\"C2\");\n+                           case C1 c ->\n+                               System.out.println(\"C1\");\n+                           case C12 c ->\n+                               System.out.println(\"C12\");\n+                       }\n+                   }\n+               }\n+               \"\"\");\n+        doTest(base,\n+               new String[0],\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   sealed interface I {}\n+                   sealed interface S1 extends I {}\n+                   sealed interface S2 extends I {}\n+                   final class C1 implements S1 {}\n+                   sealed abstract class C2 implements S2 {}\n+                   final class C2Prime extends C2 {}\n+                   final class C12 implements S1, S2 {}\n+\n+                   void test(I i) {\n+                       switch (i) {\n+                           case C12 c ->\n+                               System.out.println(\"C12\");\n+                           case C1 c ->\n+                               System.out.println(\"C1\");\n+                           case C2Prime c ->\n+                               System.out.println(\"C2\");\n+                       }\n+                   }\n","filename":"test\/langtools\/tools\/javac\/patterns\/Exhaustiveness.java","additions":181,"deletions":0,"binary":false,"changes":181,"status":"modified"}]}