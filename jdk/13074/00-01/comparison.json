{"files":[{"patch":"@@ -28,0 +28,1 @@\n+import java.lang.Enum.EnumDesc;\n@@ -34,0 +35,1 @@\n+import java.lang.invoke.MutableCallSite;\n@@ -54,0 +56,1 @@\n+    private static final MethodHandle LAZY_DO_ENUM_SWITCH;\n@@ -61,0 +64,2 @@\n+            LAZY_DO_ENUM_SWITCH = LOOKUP.findStatic(SwitchBootstraps.class, \"lazyDoEnumSwitch\",\n+                                                    MethodType.methodType(int.class, Enum.class, int.class, Object[].class, MethodHandles.Lookup.class, Class.class, MutableCallSite.class));\n@@ -89,1 +94,1 @@\n-     *   <li>the element is of type that is an enum and\n+     *   <li>the element is of type {@code EnumDesc}, that describes a constant that is\n@@ -111,1 +116,1 @@\n-     * {@code Integer}, {@code Class} or an enum type.\n+     * {@code Integer}, {@code Class} or {@code EnumDesc}.\n@@ -141,1 +146,1 @@\n-            !labelClass.isEnum()) {\n+            labelClass != EnumDesc.class) {\n@@ -163,0 +168,5 @@\n+            } else if (label instanceof EnumDesc<?> enumDesc) {\n+                if (target.getClass().isEnum() &&\n+                    ((Enum<?>) target).describeConstable().stream().anyMatch(d -> d.equals(enumDesc))) {\n+                    return i;\n+                }\n@@ -238,0 +248,36 @@\n+        Stream.of(labels).forEach(l -> validateEnumLabel(enumClass, l));\n+        MutableCallSite result =\n+                new MutableCallSite(invocationType);\n+\n+        MethodHandle temporary =\n+                MethodHandles.insertArguments(LAZY_DO_ENUM_SWITCH, 2, labels, lookup, enumClass, result);\n+        temporary = temporary.asType(invocationType);\n+\n+        result.setTarget(temporary);\n+\n+        return result;\n+    }\n+\n+    private static <E extends Enum<E>> void validateEnumLabel(Class<?> enumClassTemplate, Object label) {\n+        if (label == null) {\n+            throw new IllegalArgumentException(\"null label found\");\n+        }\n+        Class<?> labelClass = label.getClass();\n+        if (labelClass == Class.class) {\n+            if (label != enumClassTemplate) {\n+                throw new IllegalArgumentException(\"the Class label: \" + label +\n+                                                   \", expected the provided enum class: \" + enumClassTemplate);\n+            }\n+        } else if (labelClass == String.class) {\n+            \/\/OK\n+        } else {\n+            throw new IllegalArgumentException(\"label with illegal type found: \" + labelClass +\n+                                               \", expected label of type either String or Class\");\n+        }\n+    }\n+\n+    private static int lazyDoEnumSwitch(Enum<?> target, int startIndex, Object[] labels, MethodHandles.Lookup lookup, Class<?> enumClass, MutableCallSite callSite) throws Throwable {\n+        if (target == null) {\n+            return -1;\n+        }\n+\n@@ -240,1 +286,1 @@\n-        MethodHandle target =\n+        MethodHandle optimized =\n@@ -242,1 +288,1 @@\n-        target = target.asType(invocationType);\n+        optimized = optimized.asType(callSite.type());\n@@ -244,1 +290,3 @@\n-        return new ConstantCallSite(target);\n+        callSite.setTarget(optimized);\n+\n+        return (int) optimized.invoke(target, startIndex);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/runtime\/SwitchBootstraps.java","additions":54,"deletions":6,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -228,0 +228,2 @@\n+    public final Type classDescType;\n+    public final Type enumDescType;\n@@ -606,0 +608,2 @@\n+        classDescType = enterClass(\"java.lang.constant.ClassDesc\");\n+        enumDescType = enterClass(\"java.lang.Enum$EnumDesc\");\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symtab.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -4092,1 +4092,0 @@\n-                    allowUnconditionalPatternsInstanceOf = true;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -65,0 +65,1 @@\n+import java.util.function.Predicate;\n@@ -854,2 +855,2 @@\n-                for (var it1 = patterns; it1.nonEmpty(); it1 = it1.tail) {\n-                    if (it1.head instanceof BindingPattern bp &&\n+                for (PatternDescription pd : patterns) {\n+                    if (pd instanceof BindingPattern bp &&\n@@ -879,3 +880,1 @@\n-                default -> {\n-                    yield List.of(types.erasure(seltype));\n-                }\n+                default -> List.of(types.erasure(seltype));\n@@ -891,2 +890,5 @@\n-            for (var it1 = patterns; it1.nonEmpty(); it1 = it1.tail) {\n-                if (it1.head instanceof BindingPattern bpOne) {\n+            for (PatternDescription pdOne : patterns) {\n+                if (pdOne instanceof BindingPattern bpOne) {\n+                    Set<PatternDescription> toRemove = new HashSet<>();\n+                    Set<PatternDescription> toAdd = new HashSet<>();\n+\n@@ -901,1 +903,1 @@\n-                                                        .map(c -> types.erasure(c))\n+                                                        .map(types::erasure)\n@@ -905,12 +907,0 @@\n-                            Set<Symbol> permitted = new HashSet<>();\n-                            for (Symbol permittedSubtype : clazz.permitted) {\n-                                Type instantiated = infer.instantiatePatternType(selectorType, (TypeSymbol) permittedSubtype);\n-                                if (instantiated != null && types.isCastable(selectorType, instantiated)) {\n-                                    permitted.add(permittedSubtype);\n-                                }\n-                            }\n-                            permitted.remove(bpOne.type.tsym);\n-                            bindings.append(it1.head);\n-                            for (var it2 = it1.tail; it2.nonEmpty(); it2 = it2.tail) {\n-                                if (it2.head instanceof BindingPattern bpOther) {\n-                                    boolean reduces = false;\n@@ -918,1 +908,11 @@\n-                                    List<Symbol> permittedSubtypesClosure = List.of(bpOther.type.tsym);\n+                            Set<Symbol> permitted = allPermittedSubTypes(clazz, csym -> {\n+                                Type instantiated = infer.instantiatePatternType(selectorType, csym);\n+\n+                                return instantiated != null && types.isCastable(selectorType, instantiated);\n+                            });\n+\n+                            for (PatternDescription pdOther : patterns) {\n+                                if (pdOther instanceof BindingPattern bpOther) {\n+                                    boolean reduces = false;\n+                                    Set<Symbol> currentPermittedSubTypes =\n+                                            allPermittedSubTypes((ClassSymbol) bpOther.type.tsym, s -> true);\n@@ -920,3 +920,2 @@\n-                                    while (permittedSubtypesClosure.nonEmpty()) {\n-                                        ClassSymbol fromClosure = (ClassSymbol) permittedSubtypesClosure.head;\n-                                        permittedSubtypesClosure = permittedSubtypesClosure.tail;\n+                                    PERMITTED: for (Iterator<Symbol> it = permitted.iterator(); it.hasNext();) {\n+                                        Symbol perm = it.next();\n@@ -924,2 +923,6 @@\n-                                        for (Iterator<Symbol> it = permitted.iterator(); it.hasNext();) {\n-                                            Symbol perm = it.next();\n+                                        if (types.isSubtype(types.erasure(perm.type),\n+                                                            types.erasure(bpOther.type))) {\n+                                            it.remove();\n+                                            reduces = true;\n+                                            continue PERMITTED;\n+                                        }\n@@ -927,1 +930,3 @@\n-                                            if (types.isSubtype(types.erasure(fromClosure.type), types.erasure(perm.type))) {\n+                                        for (Symbol currentPermitted : currentPermittedSubTypes) {\n+                                            if (types.isSubtype(types.erasure(currentPermitted.type),\n+                                                                types.erasure(perm.type))) {\n@@ -930,0 +935,1 @@\n+                                                continue PERMITTED;\n@@ -932,4 +938,0 @@\n-\n-                                        if (fromClosure.isSealed() && fromClosure.isAbstract()) {\n-                                            permittedSubtypesClosure = permittedSubtypesClosure.prependList(fromClosure.permitted);\n-                                        }\n@@ -939,1 +941,1 @@\n-                                        bindings.append(it2.head);\n+                                        bindings.append(pdOther);\n@@ -943,0 +945,1 @@\n+\n@@ -944,5 +947,2 @@\n-                                for (PatternDescription pd : bindings) {\n-                                    patterns = List.filter(patterns, pd);\n-                                }\n-                                patterns = patterns.prepend(new BindingPattern(clazz.type));\n-                                return patterns;\n+                                toRemove.addAll(bindings);\n+                                toAdd.add(new BindingPattern(clazz.type));\n@@ -952,0 +952,18 @@\n+\n+                    Set<PatternDescription> cleanedToRemove = new HashSet<>(toRemove);\n+                    Set<PatternDescription> cleanedToAdd = new HashSet<>(toAdd);\n+\n+                    \/\/make sure we don't unnecessarily modify the list of patterns with\n+                    \/\/addition and removal of the same binding pattern:\n+                    cleanedToRemove.removeAll(toAdd);\n+                    cleanedToAdd.removeAll(toRemove);\n+\n+                    if (!cleanedToAdd.isEmpty() || !cleanedToRemove.isEmpty()) {\n+                        for (PatternDescription pd : cleanedToRemove) {\n+                            patterns = List.filter(patterns, pd);\n+                        }\n+                        for (PatternDescription pd : cleanedToAdd) {\n+                            patterns = patterns.prepend(pd);\n+                        }\n+                        return patterns;\n+                    }\n@@ -957,0 +975,24 @@\n+        private Set<Symbol> allPermittedSubTypes(ClassSymbol root, Predicate<ClassSymbol> accept) {\n+            Set<Symbol> permitted = new HashSet<>();\n+            List<ClassSymbol> permittedSubtypesClosure = List.of(root);\n+\n+            while (permittedSubtypesClosure.nonEmpty()) {\n+                ClassSymbol current = permittedSubtypesClosure.head;\n+\n+                permittedSubtypesClosure = permittedSubtypesClosure.tail;\n+\n+                if (current.isSealed() && current.isAbstract()) {\n+                    for (Symbol sym : current.permitted) {\n+                        ClassSymbol csym = (ClassSymbol) sym;\n+\n+                        if (accept.test(csym)) {\n+                            permittedSubtypesClosure = permittedSubtypesClosure.prepend(csym);\n+                            permitted.add(csym);\n+                        }\n+                    }\n+                }\n+            }\n+\n+            return permitted;\n+        }\n+\n@@ -971,1 +1013,1 @@\n-             * column is time consuming task, so this method speeds it up by:\n+             * column is time-consuming task, so this method speeds it up by:\n@@ -974,1 +1016,1 @@\n-             * -- group patterns by their hashs\n+             * -- group patterns by their hash\n@@ -976,2 +1018,2 @@\n-             *    the chosen column, and tcall reduceBindingPatterns and reduceNestedPatterns\n-             *    on patterns in the chosed column, as described above\n+             *    the chosen column, and then call reduceBindingPatterns and reduceNestedPatterns\n+             *    on patterns in the chosen column, as described above\n@@ -999,1 +1041,1 @@\n-                        var candidatesArr = candidates.toArray(s -> new RecordPattern[s]);\n+                        var candidatesArr = candidates.toArray(RecordPattern[]::new);\n@@ -1042,3 +1084,6 @@\n-                                    PatternDescription[] nue = Arrays.copyOf(rpOne.nested, rpOne.nested.length);\n-                                    nue[mismatchingCandidateFin] = nested;\n-                                    result.append(new RecordPattern(rpOne.recordType(), rpOne.fullComponentTypes(), nue));\n+                                    PatternDescription[] newNested =\n+                                            Arrays.copyOf(rpOne.nested, rpOne.nested.length);\n+                                    newNested[mismatchingCandidateFin] = nested;\n+                                    result.append(new RecordPattern(rpOne.recordType(),\n+                                                                    rpOne.fullComponentTypes(),\n+                                                                    newNested));\n@@ -1077,1 +1122,1 @@\n-            var newList = new ListBuffer<PatternDescription>();\n+            var newPatterns = new ListBuffer<PatternDescription>();\n@@ -1079,6 +1124,6 @@\n-            for (var it = patterns; it.nonEmpty(); it = it.tail) {\n-                if (it.head instanceof RecordPattern rpOne) {\n-                    PatternDescription nue = reduceRecordPattern(rpOne);\n-                    if (nue != rpOne) {\n-                        newList.append(nue);\n-                        modified |= true;\n+            for (PatternDescription pd : patterns) {\n+                if (pd instanceof RecordPattern rpOne) {\n+                    PatternDescription reducedPattern = reduceRecordPattern(rpOne);\n+                    if (reducedPattern != rpOne) {\n+                        newPatterns.append(reducedPattern);\n+                        modified = true;\n@@ -1088,1 +1133,1 @@\n-                newList.append(it.head);\n+                newPatterns.append(pd);\n@@ -1090,1 +1135,1 @@\n-            return modified ? newList.toList() : patterns;\n+            return modified ? newPatterns.toList() : patterns;\n@@ -1111,1 +1156,2 @@\n-                    covered &= newNested instanceof BindingPattern bp && types.isSubtype(types.erasure(componentType[i]), types.erasure(bp.type));\n+                    covered &= newNested instanceof BindingPattern bp &&\n+                               types.isSubtype(types.erasure(componentType[i]), types.erasure(bp.type));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Flow.java","additions":101,"deletions":55,"binary":false,"changes":156,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+import com.sun.tools.javac.code.Symbol.MethodHandleSymbol;\n@@ -107,0 +108,2 @@\n+import com.sun.tools.javac.util.JCDiagnostic;\n+import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;\n@@ -841,10 +844,1 @@\n-                    List<Type> bsm_staticArgs = List.of(syms.methodHandleLookupType,\n-                                                        syms.stringType,\n-                                                        new ClassType(syms.classType.getEnclosingType(),\n-                                                                      List.of(sym.owner.type),\n-                                                                      syms.classType.tsym));\n-\n-                    MethodSymbol bsm = rs.resolveInternalMethod(l.pos(), env, syms.constantBootstrapsType,\n-                            names.enumConstant, bsm_staticArgs, List.nil());\n-\n-                    return new DynamicVarSymbol(sym.getSimpleName(), sym, bsm.asHandle(), sym.owner.type, new LoadableConstant[0]);\n+                    return createEnumDesc(l.pos(), (ClassSymbol) sym.owner, sym.getSimpleName());\n@@ -867,0 +861,33 @@\n+    private LoadableConstant createEnumDesc(DiagnosticPosition pos, ClassSymbol enumClass, Name constant) {\n+        \/\/ConstantBootstrap.invoke(..., EnumDesc.of(ConstantBootstrap.invoke(..., ClassDesc.of(enumClass)), constant))\n+        MethodSymbol classDesc = rs.resolveInternalMethod(pos, env, syms.classDescType, names.of, List.of(syms.stringType), List.nil());\n+        MethodSymbol enumDesc = rs.resolveInternalMethod(pos, env, syms.enumDescType, names.of, List.of(syms.classDescType, syms.stringType), List.nil());\n+        return invokeMethodWrapper(pos,\n+                                   enumDesc.asHandle(),\n+                                   invokeMethodWrapper(pos,\n+                                                       classDesc.asHandle(),\n+                                                       LoadableConstant.String(enumClass.flatname.toString())),\n+                                   LoadableConstant.String(constant.toString()));\n+    }\n+\n+    private LoadableConstant invokeMethodWrapper(DiagnosticPosition pos, MethodHandleSymbol toCall, LoadableConstant... params) {\n+        List<Type> bsm_staticArgs = List.of(syms.methodHandleLookupType,\n+                                            syms.stringType,\n+                                            new ClassType(syms.classType.getEnclosingType(),\n+                                                          List.of(syms.botType), \/\/XXX - botType\n+                                                          syms.classType.tsym),\n+                                            syms.methodHandleType,\n+                                            types.makeArrayType(syms.objectType));\n+\n+        MethodSymbol bsm = rs.resolveInternalMethod(pos, env, syms.constantBootstrapsType,\n+                names.invoke, bsm_staticArgs, List.nil());\n+\n+        LoadableConstant[] actualParams = new LoadableConstant[params.length + 1];\n+\n+        actualParams[0] = toCall;\n+\n+        System.arraycopy(params, 0, actualParams, 1, params.length);\n+\n+        return new DynamicVarSymbol(bsm.name, bsm.owner, bsm.asHandle(), toCall.getReturnType(), actualParams);\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TransPatterns.java","additions":37,"deletions":10,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -95,0 +95,1 @@\n+    public final Name invoke;\n@@ -98,0 +99,1 @@\n+    public final Name of;\n@@ -278,0 +280,1 @@\n+        invoke = fromString(\"invoke\");\n@@ -281,0 +284,1 @@\n+        of = fromString(\"of\");\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/Names.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+import java.lang.Enum.EnumDesc;\n+import java.lang.constant.ClassDesc;\n@@ -32,0 +34,1 @@\n+import java.util.concurrent.atomic.AtomicBoolean;\n@@ -36,0 +39,2 @@\n+import static org.testng.Assert.assertFalse;\n+import static org.testng.Assert.assertTrue;\n@@ -161,0 +166,22 @@\n+    public void testSwitchLabelTypes() throws Throwable {\n+        enum E {A}\n+        try {\n+            testType(E.A, 0, -1, E.A);\n+            fail(\"Didn't get the expected exception.\");\n+        } catch (IllegalArgumentException ex) {\n+            \/\/OK, expected\n+        }\n+    }\n+\n+    public void testSwitchQualifiedEnum() throws Throwable {\n+        enum E {A, B, C}\n+        Object[] labels = new Object[] {\n+            EnumDesc.of(ClassDesc.of(E.class.getName()), \"A\"),\n+            EnumDesc.of(ClassDesc.of(E.class.getName()), \"B\"),\n+            EnumDesc.of(ClassDesc.of(E.class.getName()), \"C\")\n+        };\n+        testType(E.A, 0, 0, labels);\n+        testType(E.B, 0, 1, labels);\n+        testType(E.C, 0, 2, labels);\n+    }\n+\n@@ -191,0 +218,50 @@\n+\n+    private static AtomicBoolean enumInitialized = new AtomicBoolean();\n+    public void testEnumInitialization1() throws Throwable {\n+        enumInitialized.set(false);\n+\n+        enum E {\n+            A;\n+\n+            static {\n+                enumInitialized.set(true);\n+            }\n+        }\n+\n+        MethodType enumSwitchType = MethodType.methodType(int.class, E.class, int.class);\n+\n+        CallSite invocation = (CallSite) BSM_ENUM_SWITCH.invoke(MethodHandles.lookup(), \"\", enumSwitchType, new Object[] {\"A\"});\n+        assertFalse(enumInitialized.get());\n+        assertEquals(invocation.dynamicInvoker().invoke(null, 0), -1);\n+        assertFalse(enumInitialized.get());\n+        E e = E.A;\n+        assertTrue(enumInitialized.get());\n+        assertEquals(invocation.dynamicInvoker().invoke(e, 0), 0);\n+    }\n+\n+    public void testEnumInitialization2() throws Throwable {\n+        enumInitialized.set(false);\n+\n+        enum E {\n+            A;\n+\n+            static {\n+                enumInitialized.set(true);\n+            }\n+        }\n+\n+        MethodType switchType = MethodType.methodType(int.class, Object.class, int.class);\n+        Object[] labels = new Object[] {\n+            EnumDesc.of(ClassDesc.of(E.class.getName()), \"A\"),\n+            \"test\"\n+        };\n+        CallSite invocation = (CallSite) BSM_TYPE_SWITCH.invoke(MethodHandles.lookup(), \"\", switchType, labels);\n+        assertFalse(enumInitialized.get());\n+        assertEquals(invocation.dynamicInvoker().invoke(null, 0), -1);\n+        assertFalse(enumInitialized.get());\n+        assertEquals(invocation.dynamicInvoker().invoke(\"test\", 0), 1);\n+        assertFalse(enumInitialized.get());\n+        E e = E.A;\n+        assertTrue(enumInitialized.get());\n+        assertEquals(invocation.dynamicInvoker().invoke(e, 0), 0);\n+    }\n","filename":"test\/jdk\/java\/lang\/runtime\/SwitchBootstrapsTest.java","additions":77,"deletions":0,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -1552,0 +1552,23 @@\n+    @Test\n+    public void testComplexSubTypes5(Path base) throws Exception {\n+        doTest(base,\n+               new String[0],\n+               \"\"\"\n+               class Test {\n+                   sealed interface I permits A, B, C { }\n+                   interface I3 { }\n+                   sealed interface I2 extends I3 permits B, C { }\n+                   final class A implements I {}\n+                   final class B implements I, I2 {}\n+                   final class C implements I, I2 {}\n+\n+                   int m(I i) {\n+                       return switch (i) {\n+                           case A a -> 1;\n+                           case I3 e -> 2;\n+                       };\n+                   }\n+               }\n+               \"\"\");\n+    }\n+\n","filename":"test\/langtools\/tools\/javac\/patterns\/Exhaustiveness.java","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"}]}