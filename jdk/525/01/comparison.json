{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,1 @@\n+import com.sun.tools.javac.file.JavacFileManager;\n@@ -39,2 +40,0 @@\n-import java.lang.reflect.InvocationTargetException;\n-import java.lang.reflect.Method;\n@@ -42,1 +41,0 @@\n-import java.util.HashSet;\n@@ -44,0 +42,1 @@\n+import java.util.regex.Pattern;\n@@ -46,1 +45,1 @@\n-import static com.sun.tools.javac.util.LayoutCharacters.*;\n+import static com.sun.tools.javac.util.LayoutCharacters.EOI;\n@@ -48,2 +47,3 @@\n-\/** The lexical analyzer maps an input stream consisting of\n- *  ASCII characters and Unicode escapes into a token sequence.\n+\/**\n+ * The lexical analyzer maps an input stream consisting of UTF-8 characters and unicode\n+ * escape sequences into a token sequence.\n@@ -56,2 +56,4 @@\n-public class JavaTokenizer {\n-\n+public class JavaTokenizer extends UnicodeReader {\n+    \/**\n+     * If true then prints token information after each nextToken().\n+     *\/\n@@ -60,1 +62,7 @@\n-    \/** The source language setting.\n+    \/**\n+     * Sentinal for non-value.\n+     *\/\n+    private int NOT_FOUND = -1;\n+\n+    \/**\n+     * The source language setting. Copied from scanner factory.\n@@ -64,1 +72,3 @@\n-    \/** The preview language setting. *\/\n+    \/**\n+     * The preview language setting. Copied from scanner factory.\n+     *\/\n@@ -67,1 +77,2 @@\n-    \/** The log to be used for error reporting.\n+    \/**\n+     * The log to be used for error reporting. Copied from scanner factory.\n@@ -71,1 +82,3 @@\n-    \/** The token factory. *\/\n+    \/**\n+     * The token factory. Copied from scanner factory.\n+     *\/\n@@ -74,1 +87,7 @@\n-    \/** The token kind, set by nextToken().\n+    \/**\n+     * The names factory. Copied from scanner factory.\n+     *\/\n+    private final Names names;\n+\n+    \/**\n+     * The token kind, set by nextToken().\n@@ -78,1 +97,2 @@\n-    \/** The token's radix, set by nextToken().\n+    \/**\n+     * The token's radix, set by nextToken().\n@@ -82,1 +102,2 @@\n-    \/** The token's name, set by nextToken().\n+    \/**\n+     * The token's name, set by nextToken().\n@@ -86,1 +107,2 @@\n-    \/** The position where a lexical error occurred;\n+    \/**\n+     * The position where a lexical error occurred;\n@@ -90,5 +112,2 @@\n-    \/** The Unicode reader (low-level stream reader).\n-     *\/\n-    protected UnicodeReader reader;\n-\n-    \/** If is a text block\n+    \/**\n+     * true if is a text block, set by nextToken().\n@@ -98,1 +117,2 @@\n-    \/** If contains escape sequences\n+    \/**\n+     * true if contains escape sequences, set by nextToken().\n@@ -102,0 +122,8 @@\n+    \/**\n+     * Buffer for building literals, used by nextToken().\n+     *\/\n+    protected StringBuilder sb;\n+\n+    \/**\n+     * Origin scanner factory.\n+     *\/\n@@ -104,3 +132,5 @@\n-    \/\/ The set of lint options currently in effect. It is initialized\n-    \/\/ from the context, and then is set\/reset as needed by Attr as it\n-    \/\/ visits all the various parts of the trees during attribution.\n+    \/**\n+     * The set of lint options currently in effect. It is initialized\n+     * from the context, and then is set\/reset as needed by Attr as it\n+     * visits all the various parts of the trees during attribution.\n+     *\/\n@@ -109,10 +139,0 @@\n-    private static final boolean hexFloatsWork = hexFloatsWork();\n-    private static boolean hexFloatsWork() {\n-        try {\n-            Float.valueOf(\"0x1.0p1\");\n-            return true;\n-        } catch (NumberFormatException ex) {\n-            return false;\n-        }\n-    }\n-\n@@ -120,4 +140,1 @@\n-     * Create a scanner from the input array.  This method might\n-     * modify the array.  To avoid copying the input array, ensure\n-     * that {@code inputLength < input.length} or\n-     * {@code input[input.length -1]} is a white space character.\n+     * Construct a Java token scanner from the input character buffer.\n@@ -125,3 +142,2 @@\n-     * @param fac the factory which created this Scanner\n-     * @param buf the input, might be modified\n-     * Must be positive and less than or equal to input.length.\n+     * @param fac  the factory which created this Scanner.\n+     * @param cb   the input character buffer.\n@@ -129,2 +145,2 @@\n-    protected JavaTokenizer(ScannerFactory fac, CharBuffer buf) {\n-        this(fac, new UnicodeReader(fac, buf));\n+    protected JavaTokenizer(ScannerFactory fac, CharBuffer cb) {\n+        this(fac, JavacFileManager.toArray(cb), cb.limit());\n@@ -133,5 +149,9 @@\n-    protected JavaTokenizer(ScannerFactory fac, char[] buf, int inputLength) {\n-        this(fac, new UnicodeReader(fac, buf, inputLength));\n-    }\n-\n-    protected JavaTokenizer(ScannerFactory fac, UnicodeReader reader) {\n+    \/**\n+     * Construct a Java token scanner from the input character array.\n+     *\n+     * @param fac     the factory which created this Scanner\n+     * @param array   the input character array.\n+     * @param length  The length of the meaningful content in the array.\n+     *\/\n+    protected JavaTokenizer(ScannerFactory fac, char[] array, int length) {\n+        super(fac, array, length);\n@@ -140,0 +160,1 @@\n+        this.names = fac.names;\n@@ -143,1 +164,0 @@\n-        this.reader = reader;\n@@ -145,0 +165,1 @@\n+        this.sb = new StringBuilder(256);\n@@ -147,0 +168,6 @@\n+    \/**\n+     * Check the source level for a lexical feature.\n+     *\n+     * @param pos      position in input buffer.\n+     * @param feature  feature to verify.\n+     *\/\n@@ -160,1 +187,5 @@\n-    \/** Report an error at the given position using the provided arguments.\n+    \/**\n+     * Report an error at the given position using the provided arguments.\n+     *\n+     * @param pos  position in input buffer.\n+     * @param key  error key to report.\n@@ -168,0 +199,7 @@\n+    \/**\n+     * Report an error at the given position using the provided arguments.\n+     *\n+     * @param flags  diagnostic flags.\n+     * @param pos    position in input buffer.\n+     * @param key    error key to report.\n+     *\/\n@@ -174,0 +212,7 @@\n+    \/**\n+     * Report an error at the given position using the provided arguments.\n+     *\n+     * @param lc     lint category.\n+     * @param pos    position in input buffer.\n+     * @param key    error key to report.\n+     *\/\n@@ -179,6 +224,4 @@\n-    \/** Read next character in character or string literal and copy into sbuf.\n-     *      pos - start of literal offset\n-     *      translateEscapesNow - true if String::translateEscapes is not available\n-     *                            in the java.base libs. Occurs during bootstrapping.\n-     *      multiline - true if scanning a text block. Allows newlines to be embedded\n-     *                  in the result.\n+    \/**\n+     * Add a character to the literal buffer.\n+     *\n+     * @param ch  character to add.\n@@ -186,66 +229,2 @@\n-    private void scanLitChar(int pos, boolean translateEscapesNow, boolean multiline) {\n-         if (reader.ch == '\\\\') {\n-            if (reader.peekChar() == '\\\\' && !reader.isUnicode()) {\n-                reader.skipChar();\n-                if (!translateEscapesNow) {\n-                    reader.putChar(false);\n-                }\n-                reader.putChar(true);\n-            } else {\n-                reader.nextChar(translateEscapesNow);\n-                switch (reader.ch) {\n-                case '0': case '1': case '2': case '3':\n-                case '4': case '5': case '6': case '7':\n-                    char leadch = reader.ch;\n-                    int oct = reader.digit(pos, 8);\n-                    reader.nextChar(translateEscapesNow);\n-                    if ('0' <= reader.ch && reader.ch <= '7') {\n-                        oct = oct * 8 + reader.digit(pos, 8);\n-                        reader.nextChar(translateEscapesNow);\n-                        if (leadch <= '3' && '0' <= reader.ch && reader.ch <= '7') {\n-                            oct = oct * 8 + reader.digit(pos, 8);\n-                            reader.nextChar(translateEscapesNow);\n-                        }\n-                    }\n-                    if (translateEscapesNow) {\n-                        reader.putChar((char)oct);\n-                    }\n-                    break;\n-                case 'b':\n-                    reader.putChar(translateEscapesNow ? '\\b' : 'b', true); break;\n-                case 't':\n-                    reader.putChar(translateEscapesNow ? '\\t' : 't', true); break;\n-                case 'n':\n-                    reader.putChar(translateEscapesNow ? '\\n' : 'n', true); break;\n-                case 'f':\n-                    reader.putChar(translateEscapesNow ? '\\f' : 'f', true); break;\n-                case 'r':\n-                    reader.putChar(translateEscapesNow ? '\\r' : 'r', true); break;\n-                case '\\'':\n-                case '\\\"':\n-                case '\\\\':\n-                    reader.putChar(true); break;\n-                case 's':\n-                    checkSourceLevel(reader.bp, Feature.TEXT_BLOCKS);\n-                    reader.putChar(translateEscapesNow ? ' ' : 's', true); break;\n-                case '\\n':\n-                case '\\r':\n-                    if (!multiline) {\n-                        lexError(reader.bp, Errors.IllegalEscChar);\n-                    } else {\n-                        checkSourceLevel(reader.bp, Feature.TEXT_BLOCKS);\n-                        int start = reader.bp;\n-                        if (reader.ch == '\\r' && reader.peekChar() == '\\n') {\n-                           reader.nextChar(translateEscapesNow);\n-                        }\n-                        reader.nextChar(translateEscapesNow);\n-                        processLineTerminator(start, reader.bp);\n-                    }\n-                    break;\n-                default:\n-                    lexError(reader.bp, Errors.IllegalEscChar);\n-                }\n-            }\n-        } else if (reader.bp != reader.buflen) {\n-            reader.putChar(true);\n-        }\n+    protected void put(char ch) {\n+        sb.append(ch);\n@@ -254,3 +233,4 @@\n-    \/** Interim access to String methods used to support text blocks.\n-     *  Required to handle bootstrapping with pre-text block jdks.\n-     *  Should be replaced with direct calls in the 'next' jdk.\n+    \/**\n+     * Add a codepoint to the literal buffer.\n+     *\n+     * @param codePoint  codepoint to add.\n@@ -258,4 +238,3 @@\n-    static class TextBlockSupport {\n-        \/** Reflection method to remove incidental indentation.\n-         *\/\n-        private static final Method stripIndent;\n+    protected void putCodePoint(int codePoint) {\n+        sb.appendCodePoint(codePoint);\n+    }\n@@ -263,3 +242,10 @@\n-        \/** Reflection method to translate escape sequences.\n-         *\/\n-        private static final Method translateEscapes;\n+    \/**\n+     * Add current character or codepoint to the literal buffer.\n+     *\/\n+    protected void put() {\n+        if (isSurrogate()) {\n+            putCodePoint(getCodepoint());\n+        } else {\n+            put(get());\n+        }\n+    }\n@@ -267,3 +253,6 @@\n-        \/** true if stripIndent and translateEscapes are available in the bootstrap jdk.\n-         *\/\n-        private static final boolean hasSupport;\n+    \/**\n+     * Add a string to the literal buffer.\n+     *\/\n+    protected void put(String string) {\n+        sb.append(string);\n+    }\n@@ -271,10 +260,5 @@\n-        \/** Get a string method via refection or null if not available.\n-         *\/\n-        private static Method getStringMethodOrNull(String name) {\n-            try {\n-                return String.class.getMethod(name);\n-            } catch (Exception ex) {\n-                \/\/ Method not available, return null.\n-            }\n-            return null;\n-        }\n+    \/**\n+     * Add current character or codepoint to the literal buffer then return next character.\n+     *\/\n+    protected char putThenNext() {\n+        put();\n@@ -282,7 +266,2 @@\n-        static {\n-            \/\/ Get text block string methods.\n-            stripIndent = getStringMethodOrNull(\"stripIndent\");\n-            translateEscapes = getStringMethodOrNull(\"translateEscapes\");\n-            \/\/ true if stripIndent and translateEscapes are available in the bootstrap jdk.\n-            hasSupport = stripIndent != null && translateEscapes != null;\n-        }\n+        return next();\n+    }\n@@ -290,5 +269,12 @@\n-        \/** Return true if stripIndent and translateEscapes are available in the bootstrap jdk.\n-         *\/\n-        static boolean hasSupport() {\n-            return hasSupport;\n-        }\n+    \/**\n+     * If the specified character ch matches the current character then add current character\n+     * to the literal buffer and then advance.\n+     *\n+     * @param ch  character to match.\n+     *\n+     * @return true if ch matches current character.\n+     *\/\n+    protected boolean acceptThenPut(char ch) {\n+        if (is(ch)) {\n+            put(get());\n+            next();\n@@ -296,4 +282,1 @@\n-        \/** Return the leading whitespace count (indentation) of the line.\n-         *\/\n-        private static int indent(String line) {\n-            return line.length() - line.stripLeading().length();\n+            return true;\n@@ -302,4 +285,2 @@\n-        enum WhitespaceChecks {\n-            INCONSISTENT,\n-            TRAILING\n-        };\n+        return false;\n+    }\n@@ -307,52 +288,13 @@\n-        \/** Check that the use of white space in content is not problematic.\n-         *\/\n-        static Set<WhitespaceChecks> checkWhitespace(String string) {\n-            \/\/ Start with empty result set.\n-            Set<WhitespaceChecks> checks = new HashSet<>();\n-            \/\/ No need to check empty strings.\n-            if (string.isEmpty()) {\n-                return checks;\n-            }\n-            \/\/ Maximum common indentation.\n-            int outdent = 0;\n-            \/\/ No need to check indentation if opting out (last line is empty.)\n-            char lastChar = string.charAt(string.length() - 1);\n-            boolean optOut = lastChar == '\\n' || lastChar == '\\r';\n-            \/\/ Split string based at line terminators.\n-            String[] lines = string.split(\"\\\\R\");\n-            int length = lines.length;\n-            \/\/ Extract last line.\n-            String lastLine = length == 0 ? \"\" : lines[length - 1];\n-             if (!optOut) {\n-                \/\/ Prime with the last line indentation (may be blank.)\n-                outdent = indent(lastLine);\n-                for (String line : lines) {\n-                    \/\/ Blanks lines have no influence (last line accounted for.)\n-                    if (!line.isBlank()) {\n-                        outdent = Integer.min(outdent, indent(line));\n-                        if (outdent == 0) {\n-                            break;\n-                        }\n-                    }\n-                }\n-            }\n-            \/\/ Last line is representative.\n-            String start = lastLine.substring(0, outdent);\n-            for (String line : lines) {\n-                \/\/ Fail if a line does not have the same indentation.\n-                if (!line.isBlank() && !line.startsWith(start)) {\n-                    \/\/ Mix of different white space\n-                    checks.add(WhitespaceChecks.INCONSISTENT);\n-                }\n-                \/\/ Line has content even after indent is removed.\n-                if (outdent < line.length()) {\n-                    \/\/ Is the last character a white space.\n-                    lastChar = line.charAt(line.length() - 1);\n-                    if (Character.isWhitespace(lastChar)) {\n-                        \/\/ Has trailing white space.\n-                        checks.add(WhitespaceChecks.TRAILING);\n-                    }\n-                }\n-            }\n-            return checks;\n-        }\n+    \/**\n+     * If either ch1 or ch2 matches the current character then add current character\n+     * to the literal buffer and then advance.\n+     *\n+     * @param ch1  first character to match.\n+     * @param ch2  second character to match.\n+     *\n+     * @return true if either ch1 or ch2 matches current character.\n+     *\/\n+    protected boolean acceptOneOfThenPut(char ch1, char ch2) {\n+        if (isOneOf(ch1, ch2)) {\n+            put(get());\n+            next();\n@@ -360,9 +302,1 @@\n-        \/** Invoke String::stripIndent through reflection.\n-         *\/\n-        static String stripIndent(String string) {\n-            try {\n-                string = (String)stripIndent.invoke(string);\n-            } catch (InvocationTargetException | IllegalAccessException ex) {\n-                throw new RuntimeException(ex);\n-            }\n-            return string;\n+            return true;\n@@ -371,10 +305,1 @@\n-        \/** Invoke String::translateEscapes through reflection.\n-         *\/\n-        static String translateEscapes(String string) {\n-            try {\n-                string = (String)translateEscapes.invoke(string);\n-            } catch (InvocationTargetException | IllegalAccessException ex) {\n-                throw new RuntimeException(ex);\n-            }\n-            return string;\n-        }\n+        return false;\n@@ -383,1 +308,4 @@\n-    \/** Test for EOLN.\n+    \/**\n+     * Test if the current character is a line terminator.\n+     *\n+     * @return true if current character is a line terminator.\n@@ -386,1 +314,1 @@\n-        return reader.ch == LF || reader.ch == CR;\n+        return isOneOf('\\n', '\\r');\n@@ -389,1 +317,2 @@\n-    \/** Test for CRLF.\n+    \/**\n+     * Skip and process a line terminator sequence.\n@@ -391,2 +320,5 @@\n-    private boolean isCRLF() {\n-        return reader.ch == CR && reader.peekChar() == LF;\n+    private void skipLineTerminator() {\n+        int start = position();\n+        accept('\\r');\n+        accept('\\n');\n+        processLineTerminator(start, position());\n@@ -395,1 +327,6 @@\n-    \/** Count and skip repeated occurrences of the specified character.\n+    \/**\n+     * Processes the current character and places in the literal buffer. If the current\n+     * character is a backslash then the next character is validated as a proper\n+     * escape character. Conversion of escape sequences takes place at end of nextToken().\n+     *\n+     * @param pos position of the first character in literal.\n@@ -397,7 +334,3 @@\n-    private int countChar(char ch, int max) {\n-        int count = 0;\n-        for ( ; count < max && reader.bp < reader.buflen && reader.ch == ch; count++) {\n-            reader.scanChar();\n-        }\n-        return count;\n-    }\n+    private void scanLitChar(int pos) {\n+        if (acceptThenPut('\\\\')) {\n+            hasEscapeSequences = true;\n@@ -405,6 +338,48 @@\n-    \/** Skip and process a line terminator.\n-     *\/\n-    private void skipLineTerminator() {\n-        int start = reader.bp;\n-        if (isCRLF()) {\n-            reader.scanChar();\n+            switch (get()) {\n+                case '0': case '1': case '2': case '3':\n+                case '4': case '5': case '6': case '7':\n+                    char leadch = get();\n+                    putThenNext();\n+\n+                    if (inRange('0', '7')) {\n+                        putThenNext();\n+\n+                        if (leadch <= '3' && inRange('0', '7')) {\n+                            putThenNext();\n+                        }\n+                    }\n+                    break;\n+\n+                case 'b':\n+                case 't':\n+                case 'n':\n+                case 'f':\n+                case 'r':\n+                case '\\'':\n+                case '\\\"':\n+                case '\\\\':\n+                    putThenNext();\n+                    break;\n+\n+                case 's':\n+                    checkSourceLevel(position(), Feature.TEXT_BLOCKS);\n+                    putThenNext();\n+                    break;\n+\n+                case '\\n':\n+                case '\\r':\n+                    if (isTextBlock) {\n+                        skipLineTerminator();\n+                        \/\/ Normalize line terminator.\n+                        put('\\n');\n+                    } else {\n+                        lexError(position(), Errors.IllegalEscChar);\n+                    }\n+                    break;\n+\n+                default:\n+                    lexError(position(), Errors.IllegalEscChar);\n+                    break;\n+            }\n+        } else {\n+            putThenNext();\n@@ -412,2 +387,0 @@\n-        reader.scanChar();\n-        processLineTerminator(start, reader.bp);\n@@ -416,1 +389,4 @@\n-    \/** Scan a string literal or text block.\n+    \/**\n+     * Scan a string literal or text block.\n+     *\n+     * @param pos  position of the first character in literal.\n@@ -419,3 +395,2 @@\n-        \/\/ Clear flags.\n-        isTextBlock = false;\n-        hasEscapeSequences = false;\n+        \/\/ Assume the best.\n+        tk = Tokens.TokenKind.STRINGLITERAL;\n@@ -423,10 +398,5 @@\n-        int firstEOLN = -1;\n-        \/\/ Attempt to scan for up to 3 double quotes.\n-        int openCount = countChar('\\\"', 3);\n-        switch (openCount) {\n-        case 1: \/\/ Starting a string literal.\n-            break;\n-        case 2: \/\/ Starting an empty string literal.\n-            tk = Tokens.TokenKind.STRINGLITERAL;\n-            return;\n-        case 3: \/\/ Starting a text block.\n+        int firstEOLN = NOT_FOUND;\n+        \/\/ Check for text block delimiter.\n+        isTextBlock = accept(\"\\\"\\\"\\\"\");\n+\n+        if (isTextBlock) {\n@@ -435,1 +405,1 @@\n-            isTextBlock = true;\n+\n@@ -437,7 +407,3 @@\n-            while (reader.bp < reader.buflen) {\n-                char ch = reader.ch;\n-                if (ch != ' ' && ch != '\\t' && ch != FF) {\n-                    break;\n-                }\n-                reader.scanChar();\n-            }\n+            \/\/ Error if the open delimiter sequence is not \"\"\"<white space>*<LineTerminator>.\n+            skipWhitespace();\n+\n@@ -447,3 +413,1 @@\n-                \/\/ Error if the open delimiter sequence is not\n-                \/\/     \"\"\"<white space>*<LineTerminator>.\n-                lexError(reader.bp, Errors.IllegalTextBlockOpen);\n+                lexError(position(), Errors.IllegalTextBlockOpen);\n@@ -452,11 +416,4 @@\n-            break;\n-        }\n-        \/\/ While characters are available.\n-        while (reader.bp < reader.buflen) {\n-            \/\/ If possible close delimiter sequence.\n-            if (reader.ch == '\\\"') {\n-                \/\/ Check to see if enough double quotes are present.\n-                int closeCount = countChar('\\\"', openCount);\n-                if (openCount == closeCount) {\n-                    \/\/ Good result.\n-                    tk = Tokens.TokenKind.STRINGLITERAL;\n+\n+            \/\/ While characters are available.\n+            while (isAvailable()) {\n+                if (accept(\"\\\"\\\"\\\"\")) {\n@@ -465,7 +422,13 @@\n-                \/\/ False alarm, add double quotes to string buffer.\n-                reader.repeat('\\\"', closeCount);\n-            } else if (isEOLN()) {\n-                \/\/ Line terminator in string literal is an error.\n-                \/\/ Fall out to unclosed string literal error.\n-                if (openCount == 1) {\n-                    break;\n+\n+                if (isEOLN()) {\n+                    skipLineTerminator();\n+                    \/\/ Add normalized line terminator to literal buffer.\n+                    put('\\n');\n+\n+                    \/\/ Record first line terminator for error recovery.\n+                    if (firstEOLN == NOT_FOUND) {\n+                        firstEOLN = position();\n+                    }\n+                } else {\n+                    \/\/ Add character to string buffer.\n+                    scanLitChar(pos);\n@@ -473,6 +436,18 @@\n-                skipLineTerminator();\n-                \/\/ Add line terminator to string buffer.\n-                reader.putChar('\\n', false);\n-                \/\/ Record first line terminator for error recovery.\n-                if (firstEOLN == -1) {\n-                    firstEOLN = reader.bp;\n+            }\n+        } else {\n+            \/\/ Skip first quote.\n+            next();\n+\n+            \/\/ While characters are available.\n+            while (isAvailable()) {\n+                if (accept('\\\"')) {\n+                    return;\n+                }\n+\n+                if (isEOLN()) {\n+                    \/\/ Line terminator in string literal is an error.\n+                    \/\/ Fall out to unclosed string literal error.\n+                    break;\n+                } else {\n+                    \/\/ Add character to string buffer.\n+                    scanLitChar(pos);\n@@ -480,10 +455,0 @@\n-            } else if (reader.ch == '\\\\') {\n-                \/\/ Handle escape sequences.\n-                hasEscapeSequences = true;\n-                \/\/ Translate escapes immediately if TextBlockSupport is not available\n-                \/\/ during bootstrapping.\n-                boolean translateEscapesNow = !TextBlockSupport.hasSupport();\n-                scanLitChar(pos, translateEscapesNow, openCount != 1);\n-            } else {\n-                \/\/ Add character to string buffer.\n-                reader.putChar(true);\n@@ -492,0 +457,1 @@\n+\n@@ -493,4 +459,5 @@\n-        lexError(pos, openCount == 1 ? Errors.UnclosedStrLit : Errors.UnclosedTextBlock);\n-        if (firstEOLN  != -1) {\n-            \/\/ Reset recovery position to point after open delimiter sequence.\n-            reader.reset(firstEOLN);\n+        lexError(pos, isTextBlock ? Errors.UnclosedTextBlock : Errors.UnclosedStrLit);\n+\n+        if (firstEOLN  != NOT_FOUND) {\n+            \/\/ Reset recovery position to point after text block open delimiter sequence.\n+            reset(firstEOLN);\n@@ -500,0 +467,6 @@\n+    \/**\n+     * Scan sequence of digits.\n+     *\n+     * @param pos         position of the first character in literal.\n+     * @param digitRadix  radix of numeric literal.\n+     *\/\n@@ -501,2 +474,3 @@\n-        char saveCh;\n-        int savePos;\n+        int leadingUnderscorePos = is('_') ? position() : NOT_FOUND;\n+        int trailingUnderscorePos;\n+\n@@ -504,2 +478,5 @@\n-            if (reader.ch != '_') {\n-                reader.putChar(false);\n+            if (!is('_')) {\n+                put();\n+                trailingUnderscorePos = NOT_FOUND;\n+            } else {\n+                trailingUnderscorePos = position();\n@@ -507,6 +484,9 @@\n-            saveCh = reader.ch;\n-            savePos = reader.bp;\n-            reader.scanChar();\n-        } while (reader.digit(pos, digitRadix) >= 0 || reader.ch == '_');\n-        if (saveCh == '_')\n-            lexError(savePos, Errors.IllegalUnderscore);\n+\n+            next();\n+        } while (digit(pos, digitRadix) >= 0 || is('_'));\n+\n+        if (leadingUnderscorePos != NOT_FOUND) {\n+            lexError(leadingUnderscorePos, Errors.IllegalUnderscore);\n+        } else if (trailingUnderscorePos != NOT_FOUND) {\n+            lexError(trailingUnderscorePos, Errors.IllegalUnderscore);\n+        }\n@@ -515,1 +495,4 @@\n-    \/** Read fractional part of hexadecimal floating point number.\n+    \/**\n+     * Read fractional part of hexadecimal floating point number.\n+     *\n+     * @param pos  position of the first character in literal.\n@@ -518,2 +501,1 @@\n-        if (reader.ch == 'p' || reader.ch == 'P') {\n-            reader.putChar(true);\n+        if (acceptOneOfThenPut('p', 'P')) {\n@@ -521,3 +503,1 @@\n-            if (reader.ch == '+' || reader.ch == '-') {\n-                reader.putChar(true);\n-            }\n+            acceptOneOfThenPut('+', '-');\n@@ -525,1 +505,2 @@\n-            if (reader.digit(pos, 10) >= 0) {\n+\n+            if (digit(pos, 10) >= 0) {\n@@ -527,3 +508,1 @@\n-                if (!hexFloatsWork)\n-                    lexError(pos, Errors.UnsupportedCrossFpLit);\n-            } else\n+            } else {\n@@ -531,0 +510,1 @@\n+            }\n@@ -534,2 +514,2 @@\n-        if (reader.ch == 'f' || reader.ch == 'F') {\n-            reader.putChar(true);\n+\n+        if (acceptOneOfThenPut('f', 'F')) {\n@@ -539,3 +519,1 @@\n-            if (reader.ch == 'd' || reader.ch == 'D') {\n-                reader.putChar(true);\n-            }\n+            acceptOneOfThenPut('d', 'D');\n@@ -547,1 +525,4 @@\n-    \/** Read fractional part of floating point number.\n+    \/**\n+     * Read fractional part of floating point number.\n+     *\n+     * @param pos  position of the first character in literal.\n@@ -551,1 +532,2 @@\n-        if (reader.digit(pos, 10) >= 0) {\n+\n+        if (digit(pos, 10) >= 0) {\n@@ -554,3 +536,4 @@\n-        int sp1 = reader.sp;\n-        if (reader.ch == 'e' || reader.ch == 'E') {\n-            reader.putChar(true);\n+\n+        int index = sb.length();\n+\n+        if (acceptOneOfThenPut('e', 'E')) {\n@@ -558,3 +541,1 @@\n-            if (reader.ch == '+' || reader.ch == '-') {\n-                reader.putChar(true);\n-            }\n+            acceptOneOfThenPut('+', '-');\n@@ -562,1 +543,2 @@\n-            if (reader.digit(pos, 10) >= 0) {\n+\n+            if (digit(pos, 10) >= 0) {\n@@ -566,0 +548,1 @@\n+\n@@ -567,1 +550,1 @@\n-            reader.sp = sp1;\n+            sb.setLength(index);\n@@ -571,1 +554,4 @@\n-    \/** Read fractional part and 'd' or 'f' suffix of floating point number.\n+    \/**\n+     * Read fractional part and 'd' or 'f' suffix of floating point number.\n+     *\n+     * @param pos  position of the first character in literal.\n@@ -576,3 +562,3 @@\n-        if (reader.ch == 'f' || reader.ch == 'F') {\n-            reader.putChar(true);\n-            tk = TokenKind.FLOATLITERAL;\n+\n+        if (acceptOneOfThenPut('f', 'F')) {\n+             tk = TokenKind.FLOATLITERAL;\n@@ -580,3 +566,1 @@\n-            if (reader.ch == 'd' || reader.ch == 'D') {\n-                reader.putChar(true);\n-            }\n+            acceptOneOfThenPut('d', 'D');\n@@ -587,1 +571,4 @@\n-    \/** Read fractional part and 'd' or 'f' suffix of floating point number.\n+    \/**\n+     * Read fractional part and 'd' or 'f' suffix of hexadecimal floating point number.\n+     *\n+     * @param pos  position of the first character in literal.\n@@ -591,2 +578,2 @@\n-        Assert.check(reader.ch == '.');\n-        reader.putChar(true);\n+        Assert.check(is('.'));\n+        putThenNext();\n@@ -594,1 +581,2 @@\n-        if (reader.digit(pos, 16) >= 0) {\n+\n+        if (digit(pos, 16) >= 0) {\n@@ -598,0 +586,1 @@\n+\n@@ -604,0 +593,3 @@\n+    \/**\n+     * Skip over underscores and report as a error if found.\n+     *\/\n@@ -605,4 +597,3 @@\n-        if (reader.ch == '_') {\n-            lexError(reader.bp, Errors.IllegalUnderscore);\n-            while (reader.ch == '_')\n-                reader.scanChar();\n+        if (is('_')) {\n+            lexError(position(), Errors.IllegalUnderscore);\n+            skip('_');\n@@ -612,2 +603,5 @@\n-    \/** Read a number.\n-     *  @param radix  The radix of the number; one of 2, 8, 10, 16.\n+    \/**\n+     * Read a number. (Spec. 3.10)\n+     *\n+     * @param pos    position of the first character in literal.\n+     * @param radix  the radix of the number; one of 2, 8, 10, 16.\n@@ -619,1 +613,1 @@\n-        int firstDigit = reader.digit(pos, Math.max(10, digitRadix));\n+        int firstDigit = digit(pos, Math.max(10, digitRadix));\n@@ -622,0 +616,1 @@\n+\n@@ -625,1 +620,2 @@\n-        if (radix == 16 && reader.ch == '.') {\n+\n+        if (radix == 16 && is('.')) {\n@@ -627,1 +623,1 @@\n-        } else if (seendigit && radix == 16 && (reader.ch == 'p' || reader.ch == 'P')) {\n+        } else if (seendigit && radix == 16 && isOneOf('p', 'P')) {\n@@ -629,2 +625,2 @@\n-        } else if (digitRadix == 10 && reader.ch == '.') {\n-            reader.putChar(true);\n+        } else if (digitRadix == 10 && is('.')) {\n+            putThenNext();\n@@ -632,4 +628,1 @@\n-        } else if (digitRadix == 10 &&\n-                   (reader.ch == 'e' || reader.ch == 'E' ||\n-                    reader.ch == 'f' || reader.ch == 'F' ||\n-                    reader.ch == 'd' || reader.ch == 'D')) {\n+        } else if (digitRadix == 10 && isOneOf('e', 'E', 'f', 'F', 'd', 'D')) {\n@@ -648,2 +641,2 @@\n-            if (reader.ch == 'l' || reader.ch == 'L') {\n-                reader.scanChar();\n+\n+            if (acceptOneOf('l', 'L')) {\n@@ -657,1 +650,10 @@\n-    \/** Read an identifier.\n+    \/**\n+     * Determines if the sequence in the literal buffer is a token (keyword, operator.)\n+     *\/\n+    private void checkIdent() {\n+        name = names.fromString(sb.toString());\n+        tk = tokens.lookupKind(name);\n+    }\n+\n+    \/**\n+     * Read an identifier. (Spec. 3.8)\n@@ -660,3 +662,2 @@\n-        boolean isJavaIdentifierPart;\n-        char high;\n-        reader.putChar(true);\n+        putThenNext();\n+\n@@ -664,1 +665,1 @@\n-            switch (reader.ch) {\n+            switch (get()) {\n@@ -681,0 +682,1 @@\n+\n@@ -688,1 +690,1 @@\n-                reader.scanChar();\n+                next();\n@@ -690,0 +692,1 @@\n+\n@@ -691,4 +694,3 @@\n-                if (reader.bp >= reader.buflen) {\n-                    name = reader.name();\n-                    tk = tokens.lookupKind(name);\n-                    return;\n+                if (isAvailable()) {\n+                    next();\n+                    continue;\n@@ -696,2 +698,4 @@\n-                reader.scanChar();\n-                continue;\n+\n+                checkIdent();\n+                return;\n+\n@@ -699,1 +703,3 @@\n-                if (reader.ch < '\\u0080') {\n+                boolean isJavaIdentifierPart;\n+\n+                if (isASCII()) {\n@@ -703,2 +709,2 @@\n-                    if (Character.isIdentifierIgnorable(reader.ch)) {\n-                        reader.scanChar();\n+                    if (Character.isIdentifierIgnorable(get())) {\n+                        next();\n@@ -706,9 +712,0 @@\n-                    } else {\n-                        int codePoint = reader.peekSurrogates();\n-                        if (codePoint >= 0) {\n-                            if (isJavaIdentifierPart = Character.isJavaIdentifierPart(codePoint)) {\n-                                reader.putChar(true);\n-                            }\n-                        } else {\n-                            isJavaIdentifierPart = Character.isJavaIdentifierPart(reader.ch);\n-                        }\n@@ -716,0 +713,4 @@\n+\n+                    isJavaIdentifierPart = isSurrogate()\n+                            ? Character.isJavaIdentifierPart(getCodepoint())\n+                            : Character.isJavaIdentifierPart(get());\n@@ -717,0 +718,1 @@\n+\n@@ -718,2 +720,1 @@\n-                    name = reader.name();\n-                    tk = tokens.lookupKind(name);\n+                    checkIdent();\n@@ -723,1 +724,2 @@\n-            reader.putChar(true);\n+\n+            putThenNext();\n@@ -727,1 +729,6 @@\n-    \/** Return true if reader.ch can be part of an operator.\n+    \/**\n+     * Return true if ch can be part of an operator.\n+     *\n+     * @param ch  character to check.\n+     *\n+     * @return true if ch can be part of an operator.\n@@ -736,0 +743,1 @@\n+\n@@ -741,2 +749,2 @@\n-    \/** Read longest possible sequence of special characters and convert\n-     *  to token.\n+    \/**\n+     * Read longest possible sequence of special characters and convert to token.\n@@ -746,5 +754,12 @@\n-            reader.putChar(false);\n-            Name newname = reader.name();\n-            TokenKind tk1 = tokens.lookupKind(newname);\n-            if (tk1 == TokenKind.IDENTIFIER) {\n-                reader.sp--;\n+            put();\n+            TokenKind newtk = tokens.lookupKind(sb.toString());\n+\n+            if (newtk == TokenKind.IDENTIFIER) {\n+                sb.setLength(sb.length() - 1);\n+                break;\n+            }\n+\n+            tk = newtk;\n+            next();\n+\n+            if (!isSpecial(get())) {\n@@ -753,3 +768,0 @@\n-            tk = tk1;\n-            reader.scanChar();\n-            if (!isSpecial(reader.ch)) break;\n@@ -759,1 +771,2 @@\n-    \/** Read token.\n+    \/**\n+     * Read token (main entrypoint.)\n@@ -762,2 +775,1 @@\n-\n-        reader.sp = 0;\n+        sb.setLength(0);\n@@ -766,0 +778,2 @@\n+        isTextBlock = false;\n+        hasEscapeSequences = false;\n@@ -767,2 +781,1 @@\n-        int pos = 0;\n-        int endPos = 0;\n+        int pos;\n@@ -773,3 +786,4 @@\n-                pos = reader.bp;\n-                switch (reader.ch) {\n-                case ' ': \/\/ (Spec 3.6)\n+                pos = position();\n+\n+                switch (get()) {\n+                case ' ':  \/\/ (Spec 3.6)\n@@ -777,5 +791,3 @@\n-                case FF: \/\/ (Spec 3.6)\n-                    do {\n-                        reader.scanChar();\n-                    } while (reader.ch == ' ' || reader.ch == '\\t' || reader.ch == FF);\n-                    processWhiteSpace(pos, reader.bp);\n+                case '\\f': \/\/ (Spec 3.6)\n+                    skipWhitespace();\n+                    processWhiteSpace(pos, position());\n@@ -783,3 +795,4 @@\n-                case LF: \/\/ (Spec 3.4)\n-                    reader.scanChar();\n-                    processLineTerminator(pos, reader.bp);\n+\n+                case '\\n': \/\/ (Spec 3.4)\n+                    next();\n+                    processLineTerminator(pos, position());\n@@ -787,6 +800,5 @@\n-                case CR: \/\/ (Spec 3.4)\n-                    reader.scanChar();\n-                    if (reader.ch == LF) {\n-                        reader.scanChar();\n-                    }\n-                    processLineTerminator(pos, reader.bp);\n+\n+                case '\\r': \/\/ (Spec 3.4)\n+                    next();\n+                    accept('\\n');\n+                    processLineTerminator(pos, position());\n@@ -794,0 +806,1 @@\n+\n@@ -806,1 +819,1 @@\n-                case '$': case '_':\n+                case '$': case '_': \/\/ (Spec. 3.8)\n@@ -809,4 +822,5 @@\n-                case '0':\n-                    reader.scanChar();\n-                    if (reader.ch == 'x' || reader.ch == 'X') {\n-                        reader.scanChar();\n+\n+                case '0': \/\/ (Spec. 3.10)\n+                    next();\n+\n+                    if (acceptOneOf('x', 'X')) {\n@@ -815,2 +829,1 @@\n-                    } else if (reader.ch == 'b' || reader.ch == 'B') {\n-                        reader.scanChar();\n+                    } else if (acceptOneOf('b', 'B')) {\n@@ -820,7 +833,7 @@\n-                        reader.putChar('0');\n-                        if (reader.ch == '_') {\n-                            int savePos = reader.bp;\n-                            do {\n-                                reader.scanChar();\n-                            } while (reader.ch == '_');\n-                            if (reader.digit(pos, 10) < 0) {\n+                        put('0');\n+\n+                        if (is('_')) {\n+                            int savePos = position();\n+                            skip('_');\n+\n+                            if (digit(pos, 10) < 0) {\n@@ -830,0 +843,1 @@\n+\n@@ -833,0 +847,1 @@\n+\n@@ -834,1 +849,1 @@\n-                case '5': case '6': case '7': case '8': case '9':\n+                case '5': case '6': case '7': case '8': case '9':  \/\/ (Spec. 3.10)\n@@ -837,13 +852,10 @@\n-                case '.':\n-                    reader.scanChar();\n-                    if (reader.digit(pos, 10) >= 0) {\n-                        reader.putChar('.');\n-                        scanFractionAndSuffix(pos);\n-                    } else if (reader.ch == '.') {\n-                        int savePos = reader.bp;\n-                        reader.putChar('.'); reader.putChar('.', true);\n-                        if (reader.ch == '.') {\n-                            reader.scanChar();\n-                            reader.putChar('.');\n-                            tk = TokenKind.ELLIPSIS;\n-                        } else {\n+\n+                case '.': \/\/ (Spec. 3.12)\n+                    if (accept(\"...\")) {\n+                        put(\"...\");\n+                        tk = TokenKind.ELLIPSIS;\n+                    } else {\n+                        next();\n+                        int savePos = position();\n+\n+                        if (accept('.')) {\n@@ -851,0 +863,5 @@\n+                        } else if (digit(pos, 10) >= 0) {\n+                            put('.');\n+                            scanFractionAndSuffix(pos); \/\/ (Spec. 3.10)\n+                        } else {\n+                            tk = TokenKind.DOT;\n@@ -852,2 +869,0 @@\n-                    } else {\n-                        tk = TokenKind.DOT;\n@@ -856,16 +871,41 @@\n-                case ',':\n-                    reader.scanChar(); tk = TokenKind.COMMA; break loop;\n-                case ';':\n-                    reader.scanChar(); tk = TokenKind.SEMI; break loop;\n-                case '(':\n-                    reader.scanChar(); tk = TokenKind.LPAREN; break loop;\n-                case ')':\n-                    reader.scanChar(); tk = TokenKind.RPAREN; break loop;\n-                case '[':\n-                    reader.scanChar(); tk = TokenKind.LBRACKET; break loop;\n-                case ']':\n-                    reader.scanChar(); tk = TokenKind.RBRACKET; break loop;\n-                case '{':\n-                    reader.scanChar(); tk = TokenKind.LBRACE; break loop;\n-                case '}':\n-                    reader.scanChar(); tk = TokenKind.RBRACE; break loop;\n+\n+                case ',': \/\/ (Spec. 3.12)\n+                    next();\n+                    tk = TokenKind.COMMA;\n+                    break loop;\n+\n+                case ';': \/\/ (Spec. 3.12)\n+                    next();\n+                    tk = TokenKind.SEMI;\n+                    break loop;\n+\n+                case '(': \/\/ (Spec. 3.12)\n+                    next();\n+                    tk = TokenKind.LPAREN;\n+                    break loop;\n+\n+                case ')': \/\/ (Spec. 3.12)\n+                    next();\n+                    tk = TokenKind.RPAREN;\n+                    break loop;\n+\n+                case '[': \/\/ (Spec. 3.12)\n+                    next();\n+                    tk = TokenKind.LBRACKET;\n+                    break loop;\n+\n+                case ']': \/\/ (Spec. 3.12)\n+                    next();\n+                    tk = TokenKind.RBRACKET;\n+                    break loop;\n+\n+                case '{': \/\/ (Spec. 3.12)\n+                    next();\n+                    tk = TokenKind.LBRACE;\n+                    break loop;\n+\n+                case '}': \/\/ (Spec. 3.12)\n+                    next();\n+                    tk = TokenKind.RBRACE;\n+                    break loop;\n+\n@@ -873,7 +913,7 @@\n-                    reader.scanChar();\n-                    if (reader.ch == '\/') {\n-                        do {\n-                            reader.scanCommentChar();\n-                        } while (reader.ch != CR && reader.ch != LF && reader.bp < reader.buflen);\n-                        if (reader.bp < reader.buflen) {\n-                            comments = addComment(comments, processComment(pos, reader.bp, CommentStyle.LINE));\n+                    next();\n+\n+                    if (accept('\/')) { \/\/ (Spec. 3.7)\n+                        skipToEOLN();\n+\n+                        if (isAvailable()) {\n+                            comments = appendComment(comments, processComment(pos, position(), CommentStyle.LINE));\n@@ -882,1 +922,1 @@\n-                    } else if (reader.ch == '*') {\n+                    } else if (accept('*')) { \/\/ (Spec. 3.7)\n@@ -884,1 +924,0 @@\n-                        reader.scanChar();\n@@ -886,1 +925,2 @@\n-                        if (reader.ch == '*') {\n+\n+                        if (accept('*')) {\n@@ -888,2 +928,2 @@\n-                            reader.scanCommentChar();\n-                            if (reader.ch == '\/') {\n+\n+                            if (is('\/')) {\n@@ -895,6 +935,10 @@\n-                        while (!isEmpty && reader.bp < reader.buflen) {\n-                            if (reader.ch == '*') {\n-                                reader.scanChar();\n-                                if (reader.ch == '\/') break;\n-                            } else {\n-                                reader.scanCommentChar();\n+\n+                        if (!isEmpty) {\n+                            while (isAvailable()) {\n+                                if (accept('*')) {\n+                                    if (is('\/')) {\n+                                        break;\n+                                    }\n+                                } else {\n+                                    next();\n+                                }\n@@ -903,3 +947,4 @@\n-                        if (reader.ch == '\/') {\n-                            reader.scanChar();\n-                            comments = addComment(comments, processComment(pos, reader.bp, style));\n+\n+                        if (accept('\/')) {\n+                            comments = appendComment(comments, processComment(pos, position(), style));\n+\n@@ -909,0 +954,1 @@\n+\n@@ -911,3 +957,2 @@\n-                    } else if (reader.ch == '=') {\n-                        tk = TokenKind.SLASHEQ;\n-                        reader.scanChar();\n+                    } else if (accept('=')) {\n+                        tk = TokenKind.SLASHEQ; \/\/ (Spec. 3.12)\n@@ -915,1 +960,1 @@\n-                        tk = TokenKind.SLASH;\n+                        tk = TokenKind.SLASH; \/\/ (Spec. 3.12)\n@@ -918,3 +963,5 @@\n-                case '\\'':\n-                    reader.scanChar();\n-                    if (reader.ch == '\\'') {\n+\n+                case '\\'': \/\/ (Spec. 3.10)\n+                    next();\n+\n+                    if (accept('\\'')) {\n@@ -922,1 +969,0 @@\n-                        reader.scanChar();\n@@ -924,1 +970,1 @@\n-                        if (isEOLN())\n+                        if (isEOLN()) {\n@@ -926,3 +972,5 @@\n-                        scanLitChar(pos, true, false);\n-                        if (reader.ch == '\\'') {\n-                            reader.scanChar();\n+                        }\n+\n+                        scanLitChar(pos);\n+\n+                        if (accept('\\'')) {\n@@ -935,1 +983,2 @@\n-                case '\\\"':\n+\n+                case '\\\"': \/\/ (Spec. 3.10)\n@@ -938,0 +987,1 @@\n+\n@@ -939,1 +989,1 @@\n-                    if (isSpecial(reader.ch)) {\n+                    if (isSpecial(get())) {\n@@ -943,2 +993,2 @@\n-                        int codePoint = -1;\n-                        if (reader.ch < '\\u0080') {\n+\n+                        if (isASCII()) {\n@@ -948,8 +998,3 @@\n-                            codePoint = reader.peekSurrogates();\n-                            if (codePoint >= 0) {\n-                                if (isJavaIdentifierStart = Character.isJavaIdentifierStart(codePoint)) {\n-                                    reader.putChar(true);\n-                                }\n-                            } else {\n-                                isJavaIdentifierStart = Character.isJavaIdentifierStart(reader.ch);\n-                            }\n+                            isJavaIdentifierStart = isSurrogate()\n+                                    ? Character.isJavaIdentifierStart(getCodepoint())\n+                                    : Character.isJavaIdentifierStart(get());\n@@ -957,0 +1002,1 @@\n+\n@@ -959,1 +1005,1 @@\n-                        } else if (reader.digit(pos, 10) >= 0) {\n+                        } else if (digit(pos, 10) >= 0) {\n@@ -961,1 +1007,1 @@\n-                        } else if (reader.bp == reader.buflen || reader.ch == EOI && reader.bp + 1 == reader.buflen) { \/\/ JLS 3.5\n+                        } else if (is((char)EOI) || !isAvailable()) {\n@@ -963,1 +1009,1 @@\n-                            pos = reader.realLength;\n+                            pos = position();\n@@ -967,4 +1013,5 @@\n-                            if (codePoint >= 0) {\n-                                char high = reader.ch;\n-                                reader.scanChar();\n-                                arg = String.format(\"\\\\u%04x\\\\u%04x\", (int) high, (int)reader.ch);\n+                            if (isSurrogate()) {\n+                                int codePoint = getCodepoint();\n+                                char hi = Character.highSurrogate(codePoint);\n+                                char lo = Character.lowSurrogate(codePoint);\n+                                arg = String.format(\"\\\\u%04x\\\\u%04x\", (int) hi, (int) lo);\n@@ -972,3 +1019,3 @@\n-                                arg = (32 < reader.ch && reader.ch < 127) ?\n-                                                String.format(\"%s\", reader.ch) :\n-                                                String.format(\"\\\\u%04x\", (int)reader.ch);\n+                                char ch = get();\n+                                arg = (32 < ch && ch < 127) ? String.format(\"%s\", ch) :\n+                                                              String.format(\"\\\\u%04x\", (int) ch);\n@@ -976,0 +1023,1 @@\n+\n@@ -977,1 +1025,1 @@\n-                            reader.scanChar();\n+                            next();\n@@ -983,21 +1031,20 @@\n-            endPos = reader.bp;\n-            switch (tk.tag) {\n-                case DEFAULT: return new Token(tk, pos, endPos, comments);\n-                case NAMED: return new NamedToken(tk, pos, endPos, name, comments);\n-                case STRING: {\n-                    \/\/ Get characters from string buffer.\n-                    String string = reader.chars();\n-                    \/\/ If a text block.\n-                    if (isTextBlock && TextBlockSupport.hasSupport()) {\n-                        \/\/ Verify that the incidental indentation is consistent.\n-                        if (lint.isEnabled(LintCategory.TEXT_BLOCKS)) {\n-                            Set<TextBlockSupport.WhitespaceChecks> checks =\n-                                    TextBlockSupport.checkWhitespace(string);\n-                            if (checks.contains(TextBlockSupport.WhitespaceChecks.INCONSISTENT)) {\n-                                lexWarning(LintCategory.TEXT_BLOCKS, pos,\n-                                        Warnings.InconsistentWhiteSpaceIndentation);\n-                            }\n-                            if (checks.contains(TextBlockSupport.WhitespaceChecks.TRAILING)) {\n-                                lexWarning(LintCategory.TEXT_BLOCKS, pos,\n-                                        Warnings.TrailingWhiteSpaceWillBeRemoved);\n-                            }\n+\n+            int endPos = position();\n+\n+            if (tk.tag == Token.Tag.DEFAULT) {\n+                return new Token(tk, pos, endPos, comments);\n+            } else  if (tk.tag == Token.Tag.NAMED) {\n+                return new NamedToken(tk, pos, endPos, name, comments);\n+            } else {\n+                \/\/ Get characters from string buffer.\n+                String string = sb.toString();\n+\n+                \/\/ If a text block.\n+                if (isTextBlock) {\n+                    \/\/ Verify that the incidental indentation is consistent.\n+                    if (lint.isEnabled(LintCategory.TEXT_BLOCKS)) {\n+                        Set<TextBlockSupport.WhitespaceChecks> checks =\n+                                TextBlockSupport.checkWhitespace(string);\n+                        if (checks.contains(TextBlockSupport.WhitespaceChecks.INCONSISTENT)) {\n+                            lexWarning(LintCategory.TEXT_BLOCKS, pos,\n+                                    Warnings.InconsistentWhiteSpaceIndentation);\n@@ -1005,5 +1052,3 @@\n-                        \/\/ Remove incidental indentation.\n-                        try {\n-                            string = TextBlockSupport.stripIndent(string);\n-                        } catch (Exception ex) {\n-                            \/\/ Error already reported, just use unstripped string.\n+                        if (checks.contains(TextBlockSupport.WhitespaceChecks.TRAILING)) {\n+                            lexWarning(LintCategory.TEXT_BLOCKS, pos,\n+                                    Warnings.TrailingWhiteSpaceWillBeRemoved);\n@@ -1012,7 +1057,14 @@\n-                    \/\/ Translate escape sequences if present.\n-                    if (hasEscapeSequences && TextBlockSupport.hasSupport()) {\n-                        try {\n-                            string = TextBlockSupport.translateEscapes(string);\n-                        } catch (Exception ex) {\n-                            \/\/ Error already reported, just use untranslated string.\n-                        }\n+                    \/\/ Remove incidental indentation.\n+                    try {\n+                        string = string.stripIndent();\n+                    } catch (Exception ex) {\n+                        \/\/ Error already reported, just use unstripped string.\n+                    }\n+                }\n+\n+                \/\/ Translate escape sequences if present.\n+                if (hasEscapeSequences) {\n+                    try {\n+                        string = string.translateEscapes();\n+                    } catch (Exception ex) {\n+                        \/\/ Error already reported, just use untranslated string.\n@@ -1020,0 +1072,3 @@\n+                }\n+\n+                if (tk.tag == Token.Tag.STRING) {\n@@ -1022,0 +1077,3 @@\n+                } else {\n+                    \/\/ Build numeric token.\n+                    return new NumericToken(tk, pos, endPos, string, radix, comments);\n@@ -1023,2 +1081,0 @@\n-                case NUMERIC: return new NumericToken(tk, pos, endPos, reader.chars(), radix, comments);\n-                default: throw new AssertionError();\n@@ -1026,2 +1082,3 @@\n-        }\n-        finally {\n+        } finally {\n+            int endPos = position();\n+\n@@ -1031,1 +1088,1 @@\n-                                       new String(reader.getRawCharacters(pos, endPos))\n+                                       new String(getRawCharacters(pos, endPos))\n@@ -1036,6 +1093,0 @@\n-    \/\/where\n-        List<Comment> addComment(List<Comment> comments, Comment comment) {\n-            return comments == null ?\n-                    List.of(comment) :\n-                    comments.prepend(comment);\n-        }\n@@ -1043,1 +1094,18 @@\n-    \/** Return the position where a lexical error occurred;\n+    \/**\n+     * Appends a comment to the list of comments preceding the current token.\n+     *\n+     * @param comments  existing list of comments.\n+     * @param comment   comment to append.\n+     *\n+     * @return new list with comment prepended to the existing list.\n+     *\/\n+    List<Comment> appendComment(List<Comment> comments, Comment comment) {\n+        return comments == null ?\n+                List.of(comment) :\n+                comments.prepend(comment);\n+    }\n+\n+    \/**\n+     * Return the position where a lexical error occurred.\n+     *\n+     * @return position in the input buffer of where the error occurred.\n@@ -1049,1 +1117,4 @@\n-    \/** Set the position where a lexical error occurred;\n+    \/**\n+     * Set the position where a lexical error occurred.\n+     *\n+     * @param pos  position in the input buffer of where the error occurred.\n@@ -1058,0 +1129,6 @@\n+     *\n+     * @param pos     position of the opening \/ in the input buffer.\n+     * @param endPos  position + 1 of the closing \/ in the input buffer.\n+     * @param style   style of comment.\n+     *\n+     * @return the constructed BasicComment.\n@@ -1060,1 +1137,1 @@\n-        if (scannerDebug)\n+        if (scannerDebug) {\n@@ -1062,5 +1139,8 @@\n-                               + \",\" + endPos + \",\" + style + \")=|\"\n-                               + new String(reader.getRawCharacters(pos, endPos))\n-                               + \"|\");\n-        char[] buf = reader.getRawCharacters(pos, endPos);\n-        return new BasicComment<>(new UnicodeReader(fac, buf, buf.length), style);\n+                                + \",\" + endPos + \",\" + style + \")=|\"\n+                                + new String(getRawCharacters(pos, endPos))\n+                                + \"|\");\n+        }\n+\n+        char[] buf = getRawCharacters(pos, endPos);\n+\n+        return new BasicComment(style, fac, buf, pos);\n@@ -1072,0 +1152,5 @@\n+     *\n+     * (Spec 3.6)\n+     *\n+     * @param pos     position in input buffer of first whitespace character.\n+     * @param endPos  position + 1 in input buffer of last whitespace character.\n@@ -1074,1 +1159,1 @@\n-        if (scannerDebug)\n+        if (scannerDebug) {\n@@ -1076,3 +1161,4 @@\n-                               + \",\" + endPos + \")=|\" +\n-                               new String(reader.getRawCharacters(pos, endPos))\n-                               + \"|\");\n+                                + \",\" + endPos + \")=|\" +\n+                                new String(getRawCharacters(pos, endPos))\n+                                + \"|\");\n+        }\n@@ -1083,0 +1169,3 @@\n+     *\n+     * @param pos     position in input buffer of first character in sequence.\n+     * @param endPos  position + 1 in input buffer of last character in sequence.\n@@ -1085,1 +1174,1 @@\n-        if (scannerDebug)\n+        if (scannerDebug) {\n@@ -1087,3 +1176,4 @@\n-                               + \",\" + endPos + \")=|\" +\n-                               new String(reader.getRawCharacters(pos, endPos))\n-                               + \"|\");\n+                                + \",\" + endPos + \")=|\" +\n+                                new String(getRawCharacters(pos, endPos))\n+                                + \"|\");\n+        }\n@@ -1092,2 +1182,2 @@\n-    \/** Build a map for translating between line numbers and\n-     * positions in the input.\n+    \/**\n+     * Build a map for translating between line numbers and positions in the input.\n@@ -1095,1 +1185,2 @@\n-     * @return a LineMap *\/\n+     * @return a LineMap\n+     *\/\n@@ -1097,1 +1188,1 @@\n-        return Position.makeLineMap(reader.getRawCharacters(), reader.buflen, false);\n+        return Position.makeLineMap(getRawCharacters(), length(), false);\n@@ -1100,1 +1191,0 @@\n-\n@@ -1102,7 +1192,12 @@\n-    * Scan a documentation comment; determine if a deprecated tag is present.\n-    * Called once the initial \/, * have been skipped, positioned at the second *\n-    * (which is treated as the beginning of the first line).\n-    * Stops positioned at the closing '\/'.\n-    *\/\n-    protected static class BasicComment<U extends UnicodeReader> implements Comment {\n-\n+     * Scan a documentation comment; determine if a deprecated tag is present.\n+     * Called once the initial \/, * have been skipped, positioned at the second *\n+     * (which is treated as the beginning of the first line).\n+     * Stops positioned at the closing '\/'.\n+     *\/\n+    protected static class BasicComment extends PositionTrackingReader implements Comment {\n+        \/**\n+         * Style of comment\n+         *   LINE starting with \/\/\n+         *   BLOCK starting with \/*\n+         *   JAVADOC starting with \/**\n+         *\/\n@@ -1110,1 +1205,0 @@\n-        U comment_reader;\n@@ -1112,0 +1206,3 @@\n+        \/**\n+         * true if comment contains @deprecated at beginning of a line.\n+         *\/\n@@ -1113,0 +1210,4 @@\n+\n+        \/**\n+         * true if comment has been fully scanned.\n+         *\/\n@@ -1115,2 +1216,10 @@\n-        protected BasicComment(U comment_reader, CommentStyle cs) {\n-            this.comment_reader = comment_reader;\n+        \/**\n+         * Constructor.\n+         *\n+         * @param cs      comment style\n+         * @param sf      Scan factory.\n+         * @param array   Array containing contents of source.\n+         * @param offset  Position offset in original source buffer.\n+         *\/\n+        protected BasicComment(CommentStyle cs, ScannerFactory sf, char[] array, int offset) {\n+            super(sf, array, offset);\n@@ -1120,0 +1229,5 @@\n+        \/**\n+         * Return comment body text minus comment adornments or null if not scanned.\n+         *\n+         * @return comment body text.\n+         *\/\n@@ -1124,0 +1238,7 @@\n+        \/**\n+         * Return buffer position in original buffer mapped from buffer position in comment.\n+         *\n+         * @param pos  buffer position in comment.\n+         *\n+         * @return buffer position in original buffer.\n+         *\/\n@@ -1128,0 +1249,8 @@\n+        \/**\n+         * Return style of comment.\n+         *   LINE starting with \/\/\n+         *   BLOCK starting with \/*\n+         *   JAVADOC starting with \/**\n+         *\n+         * @return\n+         *\/\n@@ -1132,0 +1261,5 @@\n+        \/**\n+         * true if comment contains @deprecated at beginning of a line.\n+         *\n+         * @return true if comment contains @deprecated.\n+         *\/\n@@ -1136,0 +1270,1 @@\n+\n@@ -1139,1 +1274,3 @@\n-        @SuppressWarnings(\"fallthrough\")\n+        \/**\n+         * Scan JAVADOC comment for details.\n+         *\/\n@@ -1143,3 +1280,1 @@\n-\n-                comment_reader.bp += 3; \/\/ '\/**'\n-                comment_reader.ch = comment_reader.buf[comment_reader.bp];\n+                accept(\"\/**\");\n@@ -1148,2 +1283,1 @@\n-                while (comment_reader.bp < comment_reader.buflen) {\n-\n+                while (isAvailable()) {\n@@ -1151,3 +1285,1 @@\n-                    while (comment_reader.bp < comment_reader.buflen && (comment_reader.ch == ' ' || comment_reader.ch == '\\t' || comment_reader.ch == FF)) {\n-                        comment_reader.scanCommentChar();\n-                    }\n+                    skipWhitespace();\n@@ -1156,3 +1288,2 @@\n-                    while (comment_reader.bp < comment_reader.buflen && comment_reader.ch == '*') {\n-                        comment_reader.scanCommentChar();\n-                        if (comment_reader.ch == '\/') {\n+                    while (accept('*')) {\n+                        if (is('\/')) {\n@@ -1164,3 +1295,1 @@\n-                    while (comment_reader.bp < comment_reader.buflen && (comment_reader.ch == ' ' || comment_reader.ch == '\\t' || comment_reader.ch == FF)) {\n-                        comment_reader.scanCommentChar();\n-                    }\n+                    skipWhitespace();\n@@ -1168,1 +1297,0 @@\n-                    deprecatedPrefix = false;\n@@ -1170,12 +1298,1 @@\n-                    if (!deprecatedFlag) {\n-                        String deprecated = \"@deprecated\";\n-                        int i = 0;\n-                        while (comment_reader.bp < comment_reader.buflen && comment_reader.ch == deprecated.charAt(i)) {\n-                            comment_reader.scanCommentChar();\n-                            i++;\n-                            if (i == deprecated.length()) {\n-                                deprecatedPrefix = true;\n-                                break;\n-                            }\n-                        }\n-                    }\n+                    deprecatedPrefix = deprecatedFlag || accept(\"@deprecated\");\n@@ -1183,2 +1300,2 @@\n-                    if (deprecatedPrefix && comment_reader.bp < comment_reader.buflen) {\n-                        if (Character.isWhitespace(comment_reader.ch)) {\n+                    if (deprecatedPrefix && isAvailable()) {\n+                        if (Character.isWhitespace(get())) {\n@@ -1186,3 +1303,2 @@\n-                        } else if (comment_reader.ch == '*') {\n-                            comment_reader.scanCommentChar();\n-                            if (comment_reader.ch == '\/') {\n+                        } else if (accept('*')) {\n+                            if (is('\/')) {\n@@ -1196,2 +1312,2 @@\n-                    while (comment_reader.bp < comment_reader.buflen) {\n-                        switch (comment_reader.ch) {\n+                    while (isAvailable()) {\n+                        switch (get()) {\n@@ -1199,2 +1315,3 @@\n-                                comment_reader.scanCommentChar();\n-                                if (comment_reader.ch == '\/') {\n+                                next();\n+\n+                                if (is('\/')) {\n@@ -1203,0 +1320,1 @@\n+\n@@ -1204,8 +1322,4 @@\n-                            case CR: \/\/ (Spec 3.4)\n-                                comment_reader.scanCommentChar();\n-                                if (comment_reader.ch != LF) {\n-                                    continue forEachLine;\n-                                }\n-                            \/* fall through to LF case *\/\n-                            case LF: \/\/ (Spec 3.4)\n-                                comment_reader.scanCommentChar();\n+                            case '\\r': \/\/ (Spec 3.4)\n+                            case '\\n': \/\/ (Spec 3.4)\n+                                accept('\\r');\n+                                accept('\\n');\n@@ -1213,0 +1327,1 @@\n+\n@@ -1214,1 +1329,2 @@\n-                                comment_reader.scanCommentChar();\n+                                next();\n+                                break;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavaTokenizer.java","additions":784,"deletions":668,"binary":false,"changes":1452,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,2 @@\n-import java.nio.*;\n+import java.nio.CharBuffer;\n+import java.util.Arrays;\n@@ -35,6 +36,5 @@\n-import static com.sun.tools.javac.util.LayoutCharacters.*;\n-\n-\/** An extension to the base lexical analyzer that captures\n- *  and processes the contents of doc comments.  It does so by\n- *  translating Unicode escape sequences and by stripping the\n- *  leading whitespace and starts from each line of the comment.\n+\/**\n+ * An extension to the base lexical analyzer (JavaTokenizer) that\n+ * captures and processes the contents of doc comments. It does\n+ * so by stripping the leading whitespace and comment starts from\n+ * each line of the Javadoc comment.\n@@ -48,0 +48,4 @@\n+    \/**\n+     * The factory that created this Scanner.\n+     *\/\n+    final ScannerFactory fac;\n@@ -49,2 +53,7 @@\n-    \/** Create a scanner from the input buffer.  buffer must implement\n-     *  array() and compact(), and remaining() must be less than limit().\n+    \/**\n+     * Create a tokenizer from the input character buffer. The input buffer\n+     * content would typically be a Javadoc comment extracted by\n+     * JavaTokenizer.\n+     *\n+     * @param fac  the factory which created this Scanner.\n+     * @param cb   the input character buffer.\n@@ -52,2 +61,3 @@\n-    protected JavadocTokenizer(ScannerFactory fac, CharBuffer buffer) {\n-        super(fac, buffer);\n+    protected JavadocTokenizer(ScannerFactory fac, CharBuffer cb) {\n+        super(fac, cb);\n+        this.fac = fac;\n@@ -56,2 +66,8 @@\n-    \/** Create a scanner from the input array.  The array must have at\n-     *  least a single character of extra space.\n+    \/**\n+     * Create a tokenizer from the input array. The input buffer\n+     * content would typically be a Javadoc comment extracted by\n+     * JavaTokenizer.\n+     *\n+     * @param fac     factory which created this Scanner\n+     * @param array   input character array.\n+     * @param length  length of the meaningful content in the array.\n@@ -59,2 +75,3 @@\n-    protected JavadocTokenizer(ScannerFactory fac, char[] input, int inputLength) {\n-        super(fac, input, inputLength);\n+    protected JavadocTokenizer(ScannerFactory fac, char[] array, int length) {\n+        super(fac, array, length);\n+        this.fac = fac;\n@@ -65,2 +82,2 @@\n-        char[] buf = reader.getRawCharacters(pos, endPos);\n-        return new JavadocComment(new DocReader(fac, buf, buf.length, pos), style);\n+        char[] buf = getRawCharacters(pos, endPos);\n+        return new JavadocComment(style, fac, buf, pos);\n@@ -70,4 +87,2 @@\n-     * This is a specialized version of UnicodeReader that keeps track of the\n-     * column position within a given character stream (used for Javadoc processing),\n-     * and which builds a table for mapping positions in the comment string to\n-     * positions in the source file.\n+     * An extension of BasicComment used to extract the relevant portion\n+     * of a Javadoc comment.\n@@ -75,137 +90,7 @@\n-    static class DocReader extends UnicodeReader {\n-\n-         int col;\n-         int startPos;\n-\n-         \/**\n-          * A buffer for building a table for mapping positions in {@link #sbuf}\n-          * to positions in the source buffer.\n-          *\n-          * The array is organized as a series of pairs of integers: the first\n-          * number in each pair specifies a position in the comment text,\n-          * the second number in each pair specifies the corresponding position\n-          * in the source buffer. The pairs are sorted in ascending order.\n-          *\n-          * Since the mapping function is generally continuous, with successive\n-          * positions in the string corresponding to successive positions in the\n-          * source buffer, the table only needs to record discontinuities in\n-          * the mapping. The values of intermediate positions can be inferred.\n-          *\n-          * Discontinuities may occur in a number of places: when a newline\n-          * is followed by whitespace and asterisks (which are ignored),\n-          * when a tab is expanded into spaces, and when unicode escapes\n-          * are used in the source buffer.\n-          *\n-          * Thus, to find the source position of any position, p, in the comment\n-          * string, find the index, i, of the pair whose string offset\n-          * ({@code pbuf[i] }) is closest to but not greater than p. Then,\n-          * {@code sourcePos(p) = pbuf[i+1] + (p - pbuf[i]) }.\n-          *\/\n-         int[] pbuf = new int[128];\n-\n-         \/**\n-          * The index of the next empty slot in the pbuf buffer.\n-          *\/\n-         int pp = 0;\n-\n-         \/** The buffer index of the last double backslash sequence\n-          *\/\n-         private int doubleBackslashBp = -1;\n-\n-         DocReader(ScannerFactory fac, char[] input, int inputLength, int startPos) {\n-             super(fac, input, inputLength);\n-             this.startPos = startPos;\n-         }\n-\n-         @Override\n-         protected void convertUnicode() {\n-             if (ch == '\\\\' && unicodeConversionBp != bp) {\n-                 bp++; ch = buf[bp]; col++;\n-                 if (ch == 'u') {\n-                     do {\n-                         bp++; ch = buf[bp]; col++;\n-                     } while (ch == 'u');\n-                     int limit = bp + 3;\n-                     if (limit < buflen) {\n-                         int d = digit(bp, 16);\n-                         int code = d;\n-                         while (bp < limit && d >= 0) {\n-                             bp++; ch = buf[bp]; col++;\n-                             d = digit(bp, 16);\n-                             code = (code << 4) + d;\n-                         }\n-                         if (d >= 0) {\n-                             ch = (char)code;\n-                             unicodeConversionBp = bp;\n-                             return;\n-                         }\n-                     }\n-                     \/\/ \"illegal.Unicode.esc\", reported by base scanner\n-                 } else {\n-                     bp--;\n-                     ch = '\\\\';\n-                     col--;\n-                 }\n-             }\n-         }\n-\n-         @Override\n-         protected void scanCommentChar() {\n-             scanChar();\n-             if (ch == '\\\\') {\n-                 if (peekChar() == '\\\\' && !isUnicode()) {\n-                     bp++; col++;\n-                     doubleBackslashBp = bp;\n-                 } else {\n-                     convertUnicode();\n-                 }\n-             }\n-         }\n-\n-         @Override\n-         protected void scanChar() {\n-             bp++;\n-             ch = buf[bp];\n-             switch (ch) {\n-             case '\\r': \/\/ return\n-                 col = 0;\n-                 break;\n-             case '\\n': \/\/ newline\n-                 if (bp == 0 || buf[bp-1] != '\\r') {\n-                     col = 0;\n-                 }\n-                 break;\n-             case '\\t': \/\/ tab\n-                 col = (col \/ TabInc * TabInc) + TabInc;\n-                 break;\n-             case '\\\\': \/\/ possible Unicode\n-                 col++;\n-                 convertUnicode();\n-                 break;\n-             default:\n-                 col++;\n-                 break;\n-             }\n-         }\n-\n-         @Override\n-         public void putChar(char ch, boolean scan) {\n-             \/\/ At this point, bp is the position of the current character in buf,\n-             \/\/ and sp is the position in sbuf where this character will be put.\n-             \/\/ Record a new entry in pbuf if pbuf is empty or if sp and its\n-             \/\/ corresponding source position are not equidistant from the\n-             \/\/ corresponding values in the latest entry in the pbuf array.\n-             \/\/ (i.e. there is a discontinuity in the map function.)\n-             if ((pp == 0)\n-                     || (sp - pbuf[pp - 2] != (startPos + bp) - pbuf[pp - 1])) {\n-                 if (pp + 1 >= pbuf.length) {\n-                     int[] new_pbuf = new int[pbuf.length * 2];\n-                     System.arraycopy(pbuf, 0, new_pbuf, 0, pbuf.length);\n-                     pbuf = new_pbuf;\n-                 }\n-                 pbuf[pp] = sp;\n-                 pbuf[pp + 1] = startPos + bp;\n-                 pp += 2;\n-             }\n-             super.putChar(ch, scan);\n-         }\n+    protected static class JavadocComment extends BasicComment {\n+        \/**\n+         * Pattern used to detect a well formed @deprecated tag in a JaavDoc\n+         * comment.\n+         *\/\n+        private static final Pattern DEPRECATED_PATTERN =\n+            Pattern.compile(\"(?sm).*^\\\\s*@deprecated( |$).*\");\n@@ -213,4 +98,5 @@\n-         \/** Whether the ch represents a sequence of two backslashes. *\/\n-         boolean isDoubleBackslash() {\n-             return doubleBackslashBp == bp;\n-         }\n+        \/**\n+         * The relevant portion of the comment that is of interest to Javadoc.\n+         * Produced by invoking scanDocComment.\n+         *\/\n+        private String docComment = null;\n@@ -218,0 +104,4 @@\n+        \/**\n+         * StringBuilder used to extract the relevant portion of the Javadoc comment.\n+         *\/\n+        private StringBuilder sb;\n@@ -219,1 +109,10 @@\n-     }\n+        \/**\n+         * Map used to map the extracted Javadoc comment's character positions back to\n+         * the original source.\n+         *\/\n+        OffsetMap offsetMap = new OffsetMap();\n+\n+        JavadocComment(CommentStyle cs, ScannerFactory sf, char[] array, int offset) {\n+            super( cs, sf, array, offset);\n+            this.sb = new StringBuilder();\n+        }\n@@ -221,1 +120,9 @@\n-     protected static class JavadocComment extends JavaTokenizer.BasicComment<DocReader> {\n+        \/**\n+         * Add a character to the extraction buffer.\n+         *\n+         * @param ch  character to add.\n+         *\/\n+        protected void put(char ch) {\n+            offsetMap.add(sb.length(), offsetPosition());\n+            sb.append(ch);\n+        }\n@@ -224,4 +131,8 @@\n-        * Translated and stripped contents of doc comment\n-        *\/\n-        private String docComment = null;\n-        private int[] docPosns = null;\n+         * Add a code point to the extraction buffer.\n+         *\n+         * @param codePoint  code point to add.\n+         *\/\n+        protected void putCodePoint(int codePoint) {\n+            offsetMap.add(sb.length(), offsetPosition());\n+            sb.appendCodePoint(codePoint);\n+        }\n@@ -229,2 +140,9 @@\n-        JavadocComment(DocReader reader, CommentStyle cs) {\n-            super(reader, cs);\n+        \/**\n+         * Add current character or code point to the extraction buffer.\n+         *\/\n+        protected void put() {\n+            if (isSurrogate()) {\n+                putCodePoint(getCodepoint());\n+            } else {\n+                put(get());\n+            }\n@@ -243,7 +161,1 @@\n-            \/\/ Binary search to find the entry for which the string index is\n-            \/\/ less than pos. Since docPosns is a list of pairs of integers\n-            \/\/ we must make sure the index is always even.\n-            \/\/ If we find an exact match for pos, the other item in the pair\n-            \/\/ gives the source pos; otherwise, compute the source position\n-            \/\/ relative to the best match found in the array.\n-            if (pos == Position.NOPOS)\n+            if (pos == Position.NOPOS) {\n@@ -251,1 +163,3 @@\n-            if (pos < 0 || pos > docComment.length())\n+            }\n+\n+            if (pos < 0 || pos > docComment.length()) {\n@@ -253,13 +167,0 @@\n-            if (docPosns == null)\n-                return Position.NOPOS;\n-            int start = 0;\n-            int end = docPosns.length;\n-            while (start < end - 2) {\n-                \/\/ find an even index midway between start and end\n-                int index = ((start  + end) \/ 4) * 2;\n-                if (docPosns[index] < pos)\n-                    start = index;\n-                else if (docPosns[index] == pos)\n-                    return docPosns[index + 1];\n-                else\n-                    end = index;\n@@ -267,1 +168,2 @@\n-            return docPosns[start + 1] + (pos - docPosns[start]);\n+\n+            return offsetMap.getSourcePos(pos);\n@@ -271,1 +173,0 @@\n-        @SuppressWarnings(\"fallthrough\")\n@@ -276,4 +177,2 @@\n-                 \/\/ Skip over first slash\n-                 comment_reader.scanCommentChar();\n-                 \/\/ Skip over first star\n-                 comment_reader.scanCommentChar();\n+                 \/\/ Skip over \/*\n+                 accept(\"\/*\");\n@@ -281,6 +180,5 @@\n-                 \/\/ consume any number of stars\n-                 while (comment_reader.bp < comment_reader.buflen && comment_reader.ch == '*') {\n-                     comment_reader.scanCommentChar();\n-                 }\n-                 \/\/ is the comment in the form \/**\/, \/***\/, \/****\/, etc. ?\n-                 if (comment_reader.bp < comment_reader.buflen && comment_reader.ch == '\/') {\n+                 \/\/ Consume any number of stars\n+                 skip('*');\n+\n+                 \/\/ Is the comment in the form \/**\/, \/***\/, \/****\/, etc. ?\n+                 if (is('\/')) {\n@@ -291,12 +189,5 @@\n-                 \/\/ skip a newline on the first line of the comment.\n-                 if (comment_reader.bp < comment_reader.buflen) {\n-                     if (comment_reader.ch == LF) {\n-                         comment_reader.scanCommentChar();\n-                         firstLine = false;\n-                     } else if (comment_reader.ch == CR) {\n-                         comment_reader.scanCommentChar();\n-                         if (comment_reader.ch == LF) {\n-                             comment_reader.scanCommentChar();\n-                             firstLine = false;\n-                         }\n-                     }\n+                 \/\/ Skip line terminator on the first line of the comment.\n+                 if (isOneOf('\\n', '\\r')) {\n+                     accept('\\r');\n+                     accept('\\n');\n+                     firstLine = false;\n@@ -306,1 +197,0 @@\n-\n@@ -310,42 +200,5 @@\n-                 \/\/ puts the rest of the line into our buffer.\n-                 while (comment_reader.bp < comment_reader.buflen) {\n-                     int begin_bp = comment_reader.bp;\n-                     char begin_ch = comment_reader.ch;\n-                     \/\/ The wsLoop consumes whitespace from the beginning\n-                     \/\/ of each line.\n-                 wsLoop:\n-\n-                     while (comment_reader.bp < comment_reader.buflen) {\n-                         switch(comment_reader.ch) {\n-                         case ' ':\n-                             comment_reader.scanCommentChar();\n-                             break;\n-                         case '\\t':\n-                             comment_reader.col = ((comment_reader.col - 1) \/ TabInc * TabInc) + TabInc;\n-                             comment_reader.scanCommentChar();\n-                             break;\n-                         case FF:\n-                             comment_reader.col = 0;\n-                             comment_reader.scanCommentChar();\n-                             break;\n-         \/\/ Treat newline at beginning of line (blank line, no star)\n-         \/\/ as comment text.  Old Javadoc compatibility requires this.\n-         \/*---------------------------------*\n-                         case CR: \/\/ (Spec 3.4)\n-                             doc_reader.scanCommentChar();\n-                             if (ch == LF) {\n-                                 col = 0;\n-                                 doc_reader.scanCommentChar();\n-                             }\n-                             break;\n-                         case LF: \/\/ (Spec 3.4)\n-                             doc_reader.scanCommentChar();\n-                             break;\n-         *---------------------------------*\/\n-                         default:\n-                             \/\/ we've seen something that isn't whitespace;\n-                             \/\/ jump out.\n-                             break wsLoop;\n-                         }\n-                     }\n-\n+                 \/\/ puts the rest of the line into the extraction buffer.\n+                 while (isAvailable()) {\n+                     int begin_pos = position();\n+                     \/\/ Consume  whitespace from the beginning of each line.\n+                     skipWhitespace();\n@@ -354,1 +207,1 @@\n-                     if (comment_reader.ch == '*') {\n+                     if (is('*')) {\n@@ -356,3 +209,1 @@\n-                         do {\n-                             comment_reader.scanCommentChar();\n-                         } while (comment_reader.ch == '*');\n+                         skip('*');\n@@ -361,3 +212,2 @@\n-                         if (comment_reader.ch == '\/') {\n-                             \/\/ We're done with the doc comment\n-                             \/\/ scanChar() and breakout.\n+                         if (accept('\/')) {\n+                             \/\/ We're done with the Javadoc comment\n@@ -366,1 +216,1 @@\n-                     } else if (! firstLine) {\n+                     } else if (!firstLine) {\n@@ -369,2 +219,1 @@\n-                         comment_reader.bp = begin_bp;\n-                         comment_reader.ch = begin_ch;\n+                         reset(begin_pos);\n@@ -372,2 +221,1 @@\n-                     \/\/ The textLoop processes the rest of the characters\n-                     \/\/ on the line, adding them to our buffer.\n+\n@@ -375,40 +223,8 @@\n-                     while (comment_reader.bp < comment_reader.buflen) {\n-                         switch (comment_reader.ch) {\n-                         case '*':\n-                             \/\/ Is this just a star?  Or is this the\n-                             \/\/ end of a comment?\n-                             comment_reader.scanCommentChar();\n-                             if (comment_reader.ch == '\/') {\n-                                 \/\/ This is the end of the comment,\n-                                 \/\/ set ch and return our buffer.\n-                                 break outerLoop;\n-                             }\n-                             \/\/ This is just an ordinary star.  Add it to\n-                             \/\/ the buffer.\n-                             comment_reader.putChar('*', false);\n-                             break;\n-                         case '\\\\':\n-                             comment_reader.putChar('\\\\', false);\n-                             \/\/ If a double backslash was found, write two\n-                             if (comment_reader.isDoubleBackslash()) {\n-                                 comment_reader.putChar('\\\\', false);\n-                             }\n-                             comment_reader.scanCommentChar();\n-                             break;\n-                         case ' ':\n-                         case '\\t':\n-                             comment_reader.putChar(comment_reader.ch, false);\n-                             comment_reader.scanCommentChar();\n-                             break;\n-                         case FF:\n-                             comment_reader.scanCommentChar();\n-                             break textLoop; \/\/ treat as end of line\n-                         case CR: \/\/ (Spec 3.4)\n-                             comment_reader.scanCommentChar();\n-                             if (comment_reader.ch != LF) {\n-                                 \/\/ Canonicalize CR-only line terminator to LF\n-                                 comment_reader.putChar((char)LF, false);\n-                                 break textLoop;\n-                             }\n-                             \/* fall through to LF case *\/\n-                         case LF: \/\/ (Spec 3.4)\n+                     \/\/ The textLoop processes the rest of the characters\n+                     \/\/ on the line, adding them to the extraction buffer.\n+                     while (isAvailable()) {\n+                         if (accept(\"*\/\")) {\n+                             \/\/ This is the end of the comment, return\n+                             \/\/ the contents of the extraction buffer.\n+                             break outerLoop;\n+                         } else if (isOneOf('\\n', '\\r')) {\n@@ -418,2 +234,3 @@\n-                             comment_reader.putChar(comment_reader.ch, false);\n-                             comment_reader.scanCommentChar();\n+                             put('\\n');\n+                             accept('\\r');\n+                             accept('\\n');\n@@ -421,1 +238,5 @@\n-                         default:\n+                         } else if (is('\\f')){\n+                             next();\n+                             break textLoop; \/\/ treat as end of line\n+\n+                         } else {\n@@ -423,2 +244,2 @@\n-                             comment_reader.putChar(comment_reader.ch, false);\n-                             comment_reader.scanCommentChar();\n+                             put();\n+                             next();\n@@ -430,11 +251,6 @@\n-                 if (comment_reader.sp > 0) {\n-                     int i = comment_reader.sp - 1;\n-                 trailLoop:\n-                     while (i > -1) {\n-                         switch (comment_reader.sbuf[i]) {\n-                         case '*':\n-                             i--;\n-                             break;\n-                         default:\n-                             break trailLoop;\n-                         }\n+                 \/\/ If extraction buffer is not empty.\n+                 if (sb.length() > 0) {\n+                     \/\/ Remove trailing asterisks.\n+                     int i = sb.length() - 1;\n+                     while (i > -1 && sb.charAt(i) == '*') {\n+                         i--;\n@@ -442,1 +258,1 @@\n-                     comment_reader.sp = i + 1;\n+                     sb.setLength(i + 1) ;\n@@ -445,4 +261,2 @@\n-                    docComment = comment_reader.chars();\n-                    docPosns = new int[comment_reader.pp];\n-                    System.arraycopy(comment_reader.pbuf, 0, docPosns, 0, docPosns.length);\n-                } else {\n+                    docComment = sb.toString();\n+                 } else {\n@@ -453,3 +267,3 @@\n-                comment_reader = null;\n-                if (docComment != null &&\n-                        DEPRECATED_PATTERN.matcher(docComment).matches()) {\n+\n+                \/\/ Check if comment contains @deprecated comment.\n+                if (docComment != null && DEPRECATED_PATTERN.matcher(docComment).matches()) {\n@@ -460,4 +274,0 @@\n-        \/\/where:\n-            private static final Pattern DEPRECATED_PATTERN =\n-                    Pattern.compile(\"(?sm).*^\\\\s*@deprecated( |$).*\");\n-\n@@ -466,0 +276,6 @@\n+    \/**\n+     * Build a map for translating between line numbers and positions in the input.\n+     * Overridden to expand tabs.\n+     *\n+     * @return a LineMap\n+     *\/\n@@ -468,1 +284,1 @@\n-        char[] buf = reader.getRawCharacters();\n+        char[] buf = getRawCharacters();\n@@ -471,0 +287,162 @@\n+\n+    \/**\n+     * Build an int table to mapping positions in extracted Javadoc comment\n+     * to positions in the JavaTokenizer source buffer.\n+     *\n+     * The array is organized as a series of pairs of integers: the first\n+     * number in each pair specifies a position in the comment text,\n+     * the second number in each pair specifies the corresponding position\n+     * in the source buffer. The pairs are sorted in ascending order.\n+     *\n+     * Since the mapping function is generally continuous, with successive\n+     * positions in the string corresponding to successive positions in the\n+     * source buffer, the table only needs to record discontinuities in\n+     * the mapping. The values of intermediate positions can be inferred.\n+     *\n+     * Discontinuities may occur in a number of places: when a newline\n+     * is followed by whitespace and asterisks (which are ignored),\n+     * when a tab is expanded into spaces, and when unicode escapes\n+     * are used in the source buffer.\n+     *\n+     * Thus, to find the source position of any position, p, in the comment\n+     * string, find the index, i, of the pair whose string offset\n+     * ({@code map[i * NOFFSETS + SB_OFFSET] }) is closest to but not greater\n+     * than p. Then, {@code sourcePos(p) = map[i * NOFFSETS + POS_OFFSET] +\n+     *                                (p - map[i * NOFFSETS + SB_OFFSET]) }.\n+     *\/\n+    static class OffsetMap {\n+        \/**\n+         * map entry offset for comment offset member of pair.\n+         *\/\n+        private static final int SB_OFFSET = 0;\n+\n+        \/**\n+         * map entry offset of input offset member of pair.\n+         *\/\n+        private static final int POS_OFFSET = 1;\n+\n+        \/**\n+         * Number of elements in each entry.\n+         *\/\n+        private static final int NOFFSETS = 2;\n+\n+        \/**\n+         * Array storing entries in map.\n+         *\/\n+        private int[] map;\n+\n+        \/**\n+         * Logical size of map (number of valid entries.)\n+         *\/\n+        private int size;\n+\n+        \/**\n+         * Constructor.\n+         *\/\n+        OffsetMap() {\n+            this.map = new int[128];\n+            this.size = 0;\n+        }\n+\n+        \/**\n+         * Returns true if it is worthwhile adding the entry pair to the map. That is\n+         * if there is a change in relative offset.\n+         *\n+         * @param sbOffset  comment offset member of pair.\n+         * @param posOffet  input offset member of pair.\n+         *\n+         * @return true if it is worthwhile adding the entry pair.\n+         *\/\n+        boolean shouldAdd(int sbOffset, int posOffet) {\n+            return sbOffset - lastSBOffset() != posOffet - lastPosOffset();\n+        }\n+\n+        \/**\n+         * Adds entry pair if worthwhile.\n+         *\n+         * @param sbOffset  comment offset member of pair.\n+         * @param posOffet  input offset member of pair.\n+         *\/\n+        void add(int sbOffset, int posOffet) {\n+            if (size == 0 || shouldAdd(sbOffset, posOffet)) {\n+                ensure(NOFFSETS);\n+                map[size + SB_OFFSET] = sbOffset;\n+                map[size + POS_OFFSET] = posOffet;\n+                size += NOFFSETS;\n+            }\n+        }\n+\n+        \/**\n+         * Returns the previous comment offset.\n+         *\n+         * @return the previous comment offset.\n+         *\/\n+        private int lastSBOffset() {\n+            return size == 0 ? 0 : map[size - NOFFSETS + SB_OFFSET];\n+        }\n+\n+        \/**\n+         * Returns the previous input offset.\n+         *\n+         * @return the previous input offset.\n+         *\/\n+        private int lastPosOffset() {\n+            return size == 0 ? 0 : map[size - NOFFSETS + POS_OFFSET];\n+        }\n+\n+        \/**\n+         * Ensures there is enough space for a new entry.\n+         *\n+         * @param need  number of array slots needed.\n+         *\/\n+        private void ensure(int need) {\n+            need += size;\n+            int grow = map.length;\n+\n+            while (need > grow) {\n+                grow <<= 1;\n+            }\n+\n+            \/\/ Handle overflow.\n+            if (grow < map.length) {\n+                throw new IndexOutOfBoundsException();\n+            } else if (grow != map.length) {\n+                map = Arrays.copyOf(map, grow);\n+            }\n+        }\n+\n+        \/**\n+         * Binary search to find the entry for which the string index is less\n+         * than pos. Since the map is a list of pairs of integers we must make\n+         * sure the index is always NOFFSETS scaled. If we find an exact match\n+         * for pos, the other item in the pair gives the source pos; otherwise,\n+         * compute the source position relative to the best match found in the\n+         * array.\n+         *\/\n+        int getSourcePos(int pos) {\n+            if (size == 0) {\n+                return Position.NOPOS;\n+            }\n+\n+            int start = 0;\n+            int end = size \/ NOFFSETS;\n+\n+            while (start < end - 1) {\n+                \/\/ find an index midway between start and end\n+                int index = (start + end) \/ 2;\n+                int indexScaled = index * NOFFSETS;\n+\n+                if (map[indexScaled + SB_OFFSET] < pos) {\n+                    start = index;\n+                } else if (map[indexScaled + SB_OFFSET] == pos) {\n+                    return map[indexScaled + POS_OFFSET];\n+                } else {\n+                    end = index;\n+                }\n+            }\n+\n+            int startScaled = start * NOFFSETS;\n+\n+            return map[startScaled + POS_OFFSET] + (pos - map[startScaled + SB_OFFSET]);\n+        }\n+    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavadocTokenizer.java","additions":318,"deletions":340,"binary":false,"changes":658,"status":"modified"},{"patch":"@@ -0,0 +1,101 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.tools.javac.parser;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+\/**\n+ * Methods used to support text blocks lint.\n+ *\n+ *  <p><b>This is NOT part of any supported API.\n+ *  If you write code that depends on this, you do so at your own risk.\n+ *  This code and its internal interfaces are subject to change or\n+ *  deletion without notice.<\/b>\n+ *\/\n+class TextBlockSupport {\n+     enum WhitespaceChecks {\n+        INCONSISTENT,\n+        TRAILING\n+    };\n+\n+    \/** Check that the use of white space in content is not problematic.\n+     *\/\n+    static Set<WhitespaceChecks> checkWhitespace(String string) {\n+        \/\/ Start with empty result set.\n+        Set<WhitespaceChecks> checks = new HashSet<>();\n+        \/\/ No need to check empty strings.\n+        if (string.isEmpty()) {\n+            return checks;\n+        }\n+        \/\/ Maximum common indentation.\n+        int outdent = 0;\n+        \/\/ No need to check indentation if opting out (last line is empty.)\n+        char lastChar = string.charAt(string.length() - 1);\n+        boolean optOut = lastChar == '\\n' || lastChar == '\\r';\n+        \/\/ Split string based at line terminators.\n+        String[] lines = string.split(\"\\\\R\");\n+        int length = lines.length;\n+        \/\/ Extract last line.\n+        String lastLine = length == 0 ? \"\" : lines[length - 1];\n+         if (!optOut) {\n+            \/\/ Prime with the last line indentation (may be blank.)\n+            outdent = indexOfNonWhitespace(lastLine);\n+            for (String line : lines) {\n+                \/\/ Blanks lines have no influence (last line accounted for.)\n+                if (!line.isBlank()) {\n+                    outdent = Integer.min(outdent, indexOfNonWhitespace(line));\n+                    if (outdent == 0) {\n+                        break;\n+                    }\n+                }\n+            }\n+        }\n+        \/\/ Last line is representative.\n+        String start = lastLine.substring(0, outdent);\n+        for (String line : lines) {\n+            \/\/ Fail if a line does not have the same indentation.\n+            if (!line.isBlank() && !line.startsWith(start)) {\n+                \/\/ Mix of different white space\n+                checks.add(WhitespaceChecks.INCONSISTENT);\n+            }\n+            \/\/ Line has content even after indent is removed.\n+            if (outdent < line.length()) {\n+                \/\/ Is the last character a white space.\n+                lastChar = line.charAt(line.length() - 1);\n+                if (Character.isWhitespace(lastChar)) {\n+                    \/\/ Has trailing white space.\n+                    checks.add(WhitespaceChecks.TRAILING);\n+                }\n+            }\n+        }\n+        return checks;\n+    }\n+\n+   private static int indexOfNonWhitespace(String string) {\n+        return string.length() - string.stripLeading().length();\n+    }\n+}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/TextBlockSupport.java","additions":101,"deletions":0,"binary":false,"changes":101,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-import java.nio.CharBuffer;\n@@ -31,1 +30,0 @@\n-import com.sun.tools.javac.file.JavacFileManager;\n@@ -33,1 +31,0 @@\n-import com.sun.tools.javac.util.ArrayUtils;\n@@ -35,2 +32,0 @@\n-import com.sun.tools.javac.util.Name;\n-import com.sun.tools.javac.util.Names;\n@@ -38,1 +33,2 @@\n-import static com.sun.tools.javac.util.LayoutCharacters.*;\n+import static com.sun.tools.javac.util.LayoutCharacters.EOI;\n+import static com.sun.tools.javac.util.LayoutCharacters.tabulate;\n@@ -40,4 +36,3 @@\n-\/** The char reader used by the javac lexer\/tokenizer. Returns the sequence of\n- * characters contained in the input stream, handling unicode escape accordingly.\n- * Additionally, it provides features for saving chars into a buffer and to retrieve\n- * them at a later stage.\n+\/**\n+ * The unicode character reader used by the javac\/javadoc lexer\/tokenizer, returns characters\n+ * one by one as contained in the input stream, handling unicode escape sequences accordingly.\n@@ -48,1 +43,1 @@\n- *  deletion without notice.<\/b>\n+ *  deletion without notice.<\/b><\/p>\n@@ -51,0 +46,5 @@\n+    \/**\n+     * Buffer containing characters from source file. May contain extraneous characters\n+     * beyond this.length.\n+     *\/\n+    private final char[] buffer;\n@@ -52,2 +52,2 @@\n-    \/** The input buffer, index of next character to be read,\n-     *  index of one past last character in buffer.\n+    \/**\n+     * Length of meaningful content in buffer.\n@@ -55,3 +55,1 @@\n-    protected char[] buf;\n-    protected int bp;\n-    protected final int buflen;\n+    private final int length;\n@@ -59,1 +57,2 @@\n-    \/** The current character.\n+    \/**\n+     * Character buffer index of character currently being observed.\n@@ -61,1 +60,1 @@\n-    protected char ch;\n+    private int position;\n@@ -63,1 +62,4 @@\n-    \/** The buffer index of the last converted unicode character\n+    \/**\n+     * Number of characters combined to provide character currently being observed. Typically\n+     * one, but may be more when combinations of surrogate pairs and unicode escape sequences\n+     * are read.\n@@ -65,1 +67,1 @@\n-    protected int unicodeConversionBp = -1;\n+    private int width;\n@@ -67,2 +69,5 @@\n-    protected Log log;\n-    protected Names names;\n+    \/**\n+     * Character currently being observed. If a surrogate pair is read then will be the high\n+     * member of the pair.\n+     *\/\n+    private char character;\n@@ -70,1 +75,10 @@\n-    \/** A character buffer for saved chars.\n+    \/**\n+     * Codepoint of character currently being observed. Typically equivalent to the character\n+     * but will have a value greater that 0xFFFF when a surrogate pair.\n+     *\/\n+    private int codepoint;\n+\n+    \/**\n+     * true if the last character was a backslash. This is used to handle the special case\n+     * when a backslash precedes an unicode escape. In that case, the second backslash\n+     * is treated as a backslash and not part of an unicode escape.\n@@ -72,3 +86,1 @@\n-    protected char[] sbuf = new char[128];\n-    protected int realLength;\n-    protected int sp;\n+    private boolean wasBackslash;\n@@ -77,4 +89,6 @@\n-     * Create a scanner from the input array.  This method might\n-     * modify the array.  To avoid copying the input array, ensure\n-     * that {@code inputLength < input.length} or\n-     * {@code input[input.length -1]} is a white space character.\n+     * Log for error reporting.\n+     *\/\n+    private final Log log;\n+\n+    \/**\n+     * Constructor.\n@@ -82,3 +96,3 @@\n-     * @param sf the factory which created this Scanner\n-     * @param buffer the input, might be modified\n-     * Must be positive and less than or equal to input.length.\n+     * @param sf      scan factory.\n+     * @param array   array containing contents of source.\n+     * @param length  length of meaningful content in buffer.\n@@ -86,2 +100,11 @@\n-    protected UnicodeReader(ScannerFactory sf, CharBuffer buffer) {\n-        this(sf, JavacFileManager.toArray(buffer), buffer.limit());\n+    protected UnicodeReader(ScannerFactory sf, char[] array, int length) {\n+        this.buffer = array;\n+        this.length = length;\n+        this.position = 0;\n+        this.width = 0;\n+        this.character = '\\0';\n+        this.codepoint = 0;\n+        this.wasBackslash = false;\n+        this.log = sf.log;\n+\n+        nextCodePoint();\n@@ -90,10 +113,35 @@\n-    protected UnicodeReader(ScannerFactory sf, char[] input, int inputLength) {\n-        log = sf.log;\n-        names = sf.names;\n-        realLength = inputLength;\n-        if (inputLength == input.length) {\n-            if (input.length > 0 && Character.isWhitespace(input[input.length - 1])) {\n-                inputLength--;\n-            } else {\n-                input = Arrays.copyOf(input, inputLength + 1);\n-            }\n+    \/**\n+     * Returns the length of the buffer. This is length of meaningful content in buffer and\n+     * not the length of the buffer array.\n+     *\n+     * @return length of the buffer.\n+     *\/\n+    protected int length() {\n+        return length;\n+    }\n+\n+    \/**\n+     * Return true if current position is within the meaningful part of the buffer.\n+     *\n+     * @return true if current position is within the meaningful part of the buffer.\n+     *\/\n+    protected boolean isAvailable() {\n+        return position < length;\n+    }\n+\n+    \/**\n+     * Fetches the next 16-bit character from the buffer and places it in this.character.\n+     *\/\n+    private void nextCodeUnit() {\n+        \/\/ Index of next character in buffer.\n+        int index = position + width;\n+\n+        \/\/ If past end of buffer.\n+        if (length <= index) {\n+            \/\/ End of file is marked with EOI.\n+            character = EOI;\n+        } else {\n+            \/\/ Next character in buffer.\n+            character = buffer[index];\n+            \/\/ Increment length of codepoint.\n+            width++;\n@@ -101,5 +149,0 @@\n-        buf = input;\n-        buflen = inputLength;\n-        buf[buflen] = EOI;\n-        bp = -1;\n-        scanChar();\n@@ -108,1 +151,3 @@\n-    \/** Read next character.\n+    \/**\n+     * Fetches the next 16-bit character from the buffer. If an unicode escape\n+     * is detected then converts the unicode escape to a character.\n@@ -110,6 +155,16 @@\n-    protected void scanChar() {\n-        if (bp < buflen) {\n-            ch = buf[++bp];\n-            if (ch == '\\\\') {\n-                convertUnicode();\n-            }\n+    private void nextUnicodeInputCharacter() {\n+        \/\/ Position to next codepoint.\n+        position += width;\n+        \/\/ Codepoint has no characters yet.\n+        width = 0;\n+\n+        \/\/ Fetch next character.\n+        nextCodeUnit();\n+\n+        \/\/ If second backslash is detected.\n+        if (wasBackslash) {\n+            \/\/ Treat like a normal character (not part of unicode escape.)\n+            wasBackslash = false;\n+        } else if (character == '\\\\') {\n+            \/\/ May be an unicode escape.\n+            wasBackslash = !unicodeEscape();\n@@ -117,0 +172,3 @@\n+\n+        \/\/ Codepoint and character match if not surrogate.\n+        codepoint = (int)character;\n@@ -119,1 +177,4 @@\n-    \/** Read next character in comment, skipping over double '\\' characters.\n+    \/**\n+     * Fetches the nextcode point from the buffer. If an unicode escape is recognized\n+     * then converts unicode escape to a character. If two characters are a surrogate pair\n+     * then converts to a codepoint.\n@@ -121,7 +182,52 @@\n-    protected void scanCommentChar() {\n-        scanChar();\n-        if (ch == '\\\\') {\n-            if (peekChar() == '\\\\' && !isUnicode()) {\n-                skipChar();\n-            } else {\n-                convertUnicode();\n+    private void nextCodePoint() {\n+        \/\/ Next unicode character.\n+        nextUnicodeInputCharacter();\n+\n+        \/\/ Return early if ASCII or not a surrogate pair.\n+        if (isASCII() || !Character.isHighSurrogate(character)) {\n+            return;\n+        }\n+\n+        \/\/ Capture high surrogate and position.\n+        char hi = character;\n+        int savePosition = position;\n+        int saveWidth = width;\n+\n+        \/\/ Get potential low surrogate.\n+        nextUnicodeInputCharacter();\n+        char lo = character;\n+\n+        if (Character.isLowSurrogate(lo)) {\n+            \/\/ Start codepoint at start of high surrogate.\n+            position = savePosition;\n+            width += saveWidth;\n+            \/\/ Compute codepoint.\n+            codepoint = Character.toCodePoint(hi, lo);\n+        } else {\n+            \/\/ Restore to treat high surrogate as just a character.\n+            position = savePosition;\n+            width = saveWidth;\n+            character = hi;\n+            codepoint = (int)hi;\n+            \/\/ Could potential report an error here (old code did not.)\n+        }\n+    }\n+\n+    \/**\n+     * Converts an unicode escape into a character.\n+     *\n+     * @return true if was an unicode escape.\n+     *\/\n+    private boolean unicodeEscape() {\n+        \/\/ Start of unicode escape (past backslash.)\n+        int start = position + width;\n+\n+        \/\/ Default to backslash result, unless proven otherwise.\n+        character = '\\\\';\n+        width = 1;\n+\n+        \/\/ Skip multiple 'u'.\n+        int index;\n+        for (index = start; index < length; index++) {\n+            if (buffer[index] != 'u') {\n+                break;\n@@ -130,0 +236,34 @@\n+\n+        \/\/ Needs to have been at least one u.\n+        if (index == start) {\n+            return false;\n+        }\n+\n+        int code = 0;\n+\n+        for (int i = 0; i < 4; i++) {\n+            \/\/ Translate and merge digit.\n+            int digit = index < length ? Character.digit(buffer[index], 16) : -1;\n+            code = code << 4 | digit;\n+\n+            \/\/ If invalid digit.\n+            if (code < 0) {\n+                break;\n+            }\n+\n+            \/\/ On to next character.\n+            index++;\n+        }\n+\n+        \/\/ Skip digits even if error.\n+        width = index - position;\n+\n+        \/\/ If all digits are good.\n+        if (code >= 0) {\n+            character = (char)code;\n+        } else {\n+            log.error(position, Errors.IllegalUnicodeEsc);\n+        }\n+\n+        \/\/ Return true even if error so that the invalid unicode escape is skipped.\n+        return true;\n@@ -132,1 +272,4 @@\n-    \/** Append a character to sbuf.\n+    \/**\n+     * Return the current position in the character buffer.\n+     *\n+     * @return  current position in the character buffer.\n@@ -134,5 +277,2 @@\n-    protected void putChar(char ch, boolean scan) {\n-        sbuf = ArrayUtils.ensureCapacity(sbuf, sp);\n-        sbuf[sp++] = ch;\n-        if (scan)\n-            scanChar();\n+    protected int position() {\n+        return position;\n@@ -141,2 +281,11 @@\n-    protected void putChar(char ch) {\n-        putChar(ch, false);\n+\n+    \/**\n+     * Reset the reader to the specified position.\n+     * Warning: Do not use when previous character was an ASCII or unicode backslash.\n+     * @param pos\n+     *\/\n+    protected void reset(int pos) {\n+        position = pos;\n+        width = 0;\n+        wasBackslash = false;\n+        nextCodePoint();\n@@ -145,2 +294,7 @@\n-    protected void putChar(boolean scan) {\n-        putChar(ch, scan);\n+    \/**\n+     * Return the current character in at the current position.\n+     *\n+     * @return current character in at the current position.\n+     *\/\n+    protected char get() {\n+        return character;\n@@ -149,5 +303,8 @@\n-    protected void nextChar(boolean skip) {\n-        if (!skip) {\n-            sbuf = ArrayUtils.ensureCapacity(sbuf, sp);\n-            sbuf[sp++] = ch;\n-        }\n+    \/**\n+     * Return the current codepoint in at the current position.\n+     *\n+     * @return current codepoint in at the current position.\n+     *\/\n+    protected int getCodepoint() {\n+        return codepoint;\n+    }\n@@ -155,1 +312,7 @@\n-        scanChar();\n+    \/**\n+     * Returns true if the current codepoint is a surrogate.\n+     *\n+     * @return true if the current codepoint is a surrogate.\n+     *\/\n+    protected boolean isSurrogate() {\n+        return 0xFFFF < codepoint;\n@@ -158,2 +321,7 @@\n-    Name name() {\n-        return names.fromChars(sbuf, 0, sp);\n+    \/**\n+     * Returns true if the current character is ASCII.\n+     *\n+     * @return true if the current character is ASCII.\n+     *\/\n+    protected boolean isASCII() {\n+        return character <= 0x7F;\n@@ -162,2 +330,9 @@\n-    String chars() {\n-        return new String(sbuf, 0, sp);\n+    \/**\n+     * Advances the current character to the next character.\n+     *\n+     * @return next character.\n+     *\/\n+    protected char next() {\n+        nextCodePoint();\n+\n+        return character;\n@@ -166,1 +341,6 @@\n-    \/** Add 'count' copies of the character 'ch' to the string buffer.\n+    \/**\n+     * Compare character. Returns true if a match.\n+     *\n+     * @param ch  character to match.\n+     *\n+     * @return true if a match.\n@@ -168,4 +348,2 @@\n-    protected void repeat(char ch, int count) {\n-        for ( ; 0 < count; count--) {\n-            putChar(ch, false);\n-        }\n+    protected boolean is(char ch) {\n+        return character == ch;\n@@ -174,1 +352,2 @@\n-    \/** Reset the scan buffer pointer to 'pos'.\n+    \/**\n+     * Match one of the arguments. Returns true if a match.\n@@ -176,3 +355,8 @@\n-    protected void reset(int pos) {\n-        bp = pos - 1;\n-        scanChar();\n+    protected boolean isOneOf(char ch1, char ch2) {\n+        return is(ch1) || is(ch2);\n+    }\n+    protected boolean isOneOf(char ch1, char ch2, char ch3) {\n+        return is(ch1) || is(ch2) || is(ch3);\n+    }\n+    protected boolean isOneOf(char ch1, char ch2, char ch3, char ch4, char ch5, char ch6) {\n+        return is(ch1) || is(ch2) || is(ch3) || is(ch4) || is(ch5) || is(ch6);\n@@ -181,31 +365,10 @@\n-    \/** Convert unicode escape; bp points to initial '\\' character\n-     *  (Spec 3.3).\n-     *\/\n-    protected void convertUnicode() {\n-        if (ch == '\\\\' && unicodeConversionBp != bp ) {\n-            bp++; ch = buf[bp];\n-            if (ch == 'u') {\n-                do {\n-                    bp++; ch = buf[bp];\n-                } while (ch == 'u');\n-                int limit = bp + 3;\n-                if (limit < buflen) {\n-                    int d = digit(bp, 16);\n-                    int code = d;\n-                    while (bp < limit && d >= 0) {\n-                        bp++; ch = buf[bp];\n-                        d = digit(bp, 16);\n-                        code = (code << 4) + d;\n-                    }\n-                    if (d >= 0) {\n-                        ch = (char)code;\n-                        unicodeConversionBp = bp;\n-                        return;\n-                    }\n-                }\n-                log.error(bp, Errors.IllegalUnicodeEsc);\n-            } else {\n-                bp--;\n-                ch = '\\\\';\n-            }\n-        }\n+    \/**\n+     * Tests to see if current character is in the range of lo to hi characters (inclusive).\n+     *\n+     * @param lo  lowest character in range.\n+     * @param hi  highest character in range.\n+     *\n+     * @return true if the current character is in range.\n+     *\/\n+    protected boolean inRange(char lo, char hi) {\n+        return lo <= character && character <= hi;\n@@ -214,1 +377,6 @@\n-    \/** Are surrogates supported?\n+    \/**\n+     * Compare character and advance if a match. Returns true if a match.\n+     *\n+     * @param ch  character to match.\n+     *\n+     * @return true if a match.\n@@ -216,4 +384,4 @@\n-    final static boolean surrogatesSupported = surrogatesSupported();\n-    private static boolean surrogatesSupported() {\n-        try {\n-            Character.isHighSurrogate('a');\n+    protected boolean accept(char ch) {\n+        if (is(ch)) {\n+            next();\n+\n@@ -221,2 +389,0 @@\n-        } catch (NoSuchMethodError ex) {\n-            return false;\n@@ -224,0 +390,2 @@\n+\n+        return false;\n@@ -226,4 +394,2 @@\n-    \/** Scan surrogate pairs.  If 'ch' is a high surrogate and\n-     *  the next character is a low surrogate, returns the code point\n-     *  constructed from these surrogates. Otherwise, returns -1.\n-     *  This method will not consume any of the characters.\n+    \/**\n+     * Match one of the arguments and advance if a match. Returns true if a match.\n@@ -231,4 +397,3 @@\n-    protected int peekSurrogates() {\n-        if (surrogatesSupported && Character.isHighSurrogate(ch)) {\n-            char high = ch;\n-            int prevBP = bp;\n+    protected boolean acceptOneOf(char ch1, char ch2) {\n+        if (isOneOf(ch1, ch2)) {\n+            next();\n@@ -236,1 +401,2 @@\n-            scanChar();\n+            return true;\n+        }\n@@ -238,1 +404,2 @@\n-            char low = ch;\n+        return false;\n+    }\n@@ -240,2 +407,3 @@\n-            ch = high;\n-            bp = prevBP;\n+    protected boolean acceptOneOf(char ch1, char ch2, char ch3) {\n+        if (isOneOf(ch1, ch2, ch3)) {\n+            next();\n@@ -243,3 +411,1 @@\n-            if (Character.isLowSurrogate(low)) {\n-                return Character.toCodePoint(high, low);\n-            }\n+            return true;\n@@ -248,1 +414,1 @@\n-        return -1;\n+        return false;\n@@ -251,14 +417,17 @@\n-    \/** Convert an ASCII digit from its base (8, 10, or 16)\n-     *  to its value.\n-     *\/\n-    protected int digit(int pos, int base) {\n-        char c = ch;\n-        if ('0' <= c && c <= '9')\n-            return Character.digit(c, base); \/\/a fast common case\n-        int codePoint = peekSurrogates();\n-        int result = codePoint >= 0 ? Character.digit(codePoint, base) : Character.digit(c, base);\n-        if (result >= 0 && c > 0x7f) {\n-            log.error(pos + 1, Errors.IllegalNonasciiDigit);\n-            if (codePoint >= 0)\n-                scanChar();\n-            ch = \"0123456789abcdef\".charAt(result);\n+    \/**\n+     * Skip over all occurances of character.\n+     *\n+     * @param ch character to accept.\n+     *\/\n+    protected void skip(char ch) {\n+        while (accept(ch)) {\n+            \/\/ next\n+        }\n+    }\n+\n+    \/**\n+     * Skip over ASCII white space characters.\n+     *\/\n+    protected void skipWhitespace() {\n+        while (acceptOneOf(' ', '\\t', '\\f')) {\n+            \/\/ next\n@@ -266,1 +435,0 @@\n-        return result;\n@@ -269,2 +437,12 @@\n-    protected boolean isUnicode() {\n-        return unicodeConversionBp == bp;\n+    \/**\n+     * Skip to end of line.\n+     *\/\n+    protected void skipToEOLN() {\n+        while (isAvailable()) {\n+            if (isOneOf('\\r', '\\n')) {\n+                break;\n+            }\n+\n+            next();\n+        }\n+\n@@ -273,2 +451,33 @@\n-    protected void skipChar() {\n-        bp++;\n+    \/**\n+     * Compare string and advance if a match. Returns true if a match.\n+     * Warning: Do not use when previous character was a backslash\n+     * (confuses state of wasBackslash.)\n+     *\n+     * @param string string to match character for character.\n+     *\n+     * @return true if a match.\n+     *\/\n+    protected boolean accept(String string) {\n+        \/\/ Quick test.\n+        if (string.length() == 0 || !is(string.charAt(0))) {\n+            return false;\n+        }\n+\n+        \/\/ Be prepared to retreat if not a match.\n+        int savedPosition = position;\n+\n+        nextCodePoint();\n+\n+        \/\/ Check each character.\n+        for (int i = 1; i < string.length(); i++) {\n+            if (!is(string.charAt(i))) {\n+                \/\/ Restart if not a match.\n+                reset(savedPosition);\n+\n+                return false;\n+            }\n+\n+            nextCodePoint();\n+        }\n+\n+        return true;\n@@ -277,2 +486,30 @@\n-    protected char peekChar() {\n-        return buf[bp + 1];\n+    \/**\n+     * Convert an ASCII digit from its base (8, 10, or 16) to its value. Does not\n+     * advance character.\n+     *\n+     * @param pos         starting position.\n+     * @param digitRadix  base of number being converted.\n+     *\n+     * @return value of digit.\n+     *\/\n+    protected int digit(int pos, int digitRadix) {\n+        int result;\n+\n+        \/\/ Just an ASCII digit.\n+        if (inRange('0', '9')) {\n+            \/\/ Fast common case.\n+            result = character - '0';\n+\n+            return result < digitRadix ? result : -1;\n+        }\n+\n+        \/\/ Handle other digits.\n+        result = isSurrogate() ? Character.digit(codepoint, digitRadix) :\n+                                 Character.digit(character, digitRadix);\n+\n+        if (result >= 0 && !isASCII()) {\n+            log.error(position(), Errors.IllegalNonasciiDigit);\n+            character = \"0123456789abcdef\".charAt(result);\n+        }\n+\n+        return result;\n@@ -282,2 +519,3 @@\n-     * Returns a copy of the input buffer, up to its inputLength.\n-     * Unicode escape sequences are not translated.\n+     * Returns the input buffer. Unicode escape sequences are not translated.\n+     *\n+     * @return the input buffer.\n@@ -286,3 +524,1 @@\n-        char[] chars = new char[buflen];\n-        System.arraycopy(buf, 0, chars, 0, buflen);\n-        return chars;\n+        return length == buffer.length ? buffer : Arrays.copyOf(buffer, length);\n@@ -300,2 +536,3 @@\n-     * @param beginIndex the beginning index, inclusive.\n-     * @param endIndex the ending index, exclusive.\n+     * @param  beginIndex the beginning index, inclusive.\n+     * @param  endIndex the ending index, exclusive.\n+     *\n@@ -306,4 +543,70 @@\n-        int length = endIndex - beginIndex;\n-        char[] chars = new char[length];\n-        System.arraycopy(buf, beginIndex, chars, 0, length);\n-        return chars;\n+        return Arrays.copyOfRange(buffer, beginIndex, endIndex);\n+    }\n+\n+    \/**\n+     * This is a specialized version of UnicodeReader that keeps track of the\n+     * column position within a given character stream. Used for Javadoc\n+     * processing to build a table for mapping positions in the comment string\n+     * to positions in the source file.\n+     *\/\n+    static class PositionTrackingReader extends UnicodeReader {\n+        \/**\n+         * Offset from the beginning of the original reader buffer.\n+         *\/\n+        final private int offset;\n+\n+        \/**\n+         * Current column in the comment.\n+         *\/\n+        private int column;\n+\n+        \/**\n+         * Constructor.\n+         *\n+         * @param sf      Scan factory.\n+         * @param array   Array containing contents of source.\n+         * @param offset  Position offset in original source buffer.\n+         *\/\n+        protected PositionTrackingReader(ScannerFactory sf, char[] array, int offset) {\n+            super(sf, array, array.length);\n+            this.offset = offset;\n+            this.column = 0;\n+        }\n+\n+        \/**\n+         * Advances the current character to the next character. Tracks column.\n+         *\n+         * @return next character.\n+         *\/\n+        @Override\n+        protected char next() {\n+            super.next();\n+\n+            if (isOneOf('\\n', '\\r', '\\f')) {\n+                column = 0;\n+            } else if (is('\\t')) {\n+                column = tabulate(column);\n+            } else {\n+                column++;\n+            }\n+\n+            return get();\n+        }\n+\n+        \/**\n+         * Returns the current column.\n+         *\n+         * @return  the current column.\n+         *\/\n+        protected int column() {\n+            return column;\n+        }\n+\n+        \/**\n+         * Returns position relative to the original source buffer.\n+         *\n+         * @return\n+         *\/\n+        protected int offsetPosition() {\n+            return position() + offset;\n+        }\n@@ -311,0 +614,1 @@\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/UnicodeReader.java","additions":485,"deletions":181,"binary":false,"changes":666,"status":"modified"},{"patch":"@@ -1386,3 +1386,0 @@\n-compiler.err.unsupported.cross.fp.lit=\\\n-    hexadecimal floating-point literals are not supported on this VM\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -987,2 +987,0 @@\n-compiler.err.unsupported.cross.fp.lit=16\\u9032\\u6D6E\\u52D5\\u5C0F\\u6570\\u70B9\\u30EA\\u30C6\\u30E9\\u30EB\\u306F\\u3053\\u306EVM\\u3067\\u306F\\u30B5\\u30DD\\u30FC\\u30C8\\u3055\\u308C\\u3066\\u3044\\u307E\\u305B\\u3093\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler_ja.properties","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -987,2 +987,0 @@\n-compiler.err.unsupported.cross.fp.lit=\\u8BE5 VM \\u4E0D\\u652F\\u6301\\u5341\\u516D\\u8FDB\\u5236\\u6D6E\\u70B9\\u6587\\u5B57\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler_zh_CN.properties","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2012, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -99,1 +99,1 @@\n-                        column = (column \/ TabInc * TabInc) + TabInc;\n+                        column = tabulate(column);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/DiagnosticSource.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2010, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -71,0 +71,6 @@\n+\n+    \/** Bump column to the next tab.\n+     *\/\n+    static int tabulate(int column) {\n+        return (column \/ TabInc * TabInc) + TabInc;\n+    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/LayoutCharacters.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -268,1 +268,1 @@\n-                    column = (column \/ TabInc * TabInc) + TabInc;\n+                    column = tabulate(column);\n@@ -282,1 +282,1 @@\n-                    col = (col \/ TabInc * TabInc) + TabInc;\n+                    col = tabulate(col);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/Position.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-Digits.java:11:41: compiler.err.illegal.nonascii.digit\n+Digits.java:11:43: compiler.err.illegal.nonascii.digit\n","filename":"test\/langtools\/tools\/javac\/Digits.out","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -47,1 +47,0 @@\n-compiler.err.unsupported.cross.fp.lit                   # Scanner: host system dependent\n","filename":"test\/langtools\/tools\/javac\/diags\/examples.not-yet.txt","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,174 @@\n+\/*\n+ * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8254073\n+ * @modules jdk.compiler\/com.sun.tools.javac.parser\n+ *          jdk.compiler\/com.sun.tools.javac.util\n+ * @summary Proper lexing of various token kinds.\n+ *\/\n+\n+import java.io.IOException;\n+import java.net.URI;\n+import java.util.Objects;\n+\n+import javax.tools.JavaFileObject;\n+import javax.tools.SimpleJavaFileObject;\n+\n+import com.sun.tools.javac.parser.JavaTokenizer;\n+import com.sun.tools.javac.parser.ScannerFactory;\n+import com.sun.tools.javac.parser.Tokens.Token;\n+import com.sun.tools.javac.parser.Tokens.TokenKind;\n+import com.sun.tools.javac.util.Context;\n+import com.sun.tools.javac.util.Log;\n+\n+import static com.sun.tools.javac.parser.Tokens.TokenKind.*;\n+\n+public class JavaLexerTest2 {\n+    static final TestTuple[] TESTS = {\n+            new TestTuple(\"0bL\",         LONGLITERAL, true),\n+            new TestTuple(\"0b20L\",       LONGLITERAL, true),\n+\n+            new TestTuple(\"0xL\",         LONGLITERAL, true),\n+            new TestTuple(\"0xG000L\",     LONGLITERAL, true),\n+\n+            new TestTuple(\"0.0f\",        FLOATLITERAL, false),\n+            new TestTuple(\"0.0F\",        FLOATLITERAL, false),\n+            new TestTuple(\".0F\",         FLOATLITERAL, false),\n+            new TestTuple(\"0.F\",         FLOATLITERAL, false),\n+            new TestTuple(\"0E0F\",        FLOATLITERAL, false),\n+            new TestTuple(\"0E+0F\",       FLOATLITERAL, false),\n+            new TestTuple(\"0E-0F\",       FLOATLITERAL, false),\n+            new TestTuple(\"0E*0F\",       FLOATLITERAL, true),\n+\n+            new TestTuple(\"0.0d\",        DOUBLELITERAL, false),\n+            new TestTuple(\"0.0D\",        DOUBLELITERAL, false),\n+            new TestTuple(\".0D\",         DOUBLELITERAL, false),\n+            new TestTuple(\"0.D\",         DOUBLELITERAL, false),\n+            new TestTuple(\"0E0D\",        DOUBLELITERAL, false),\n+            new TestTuple(\"0E+0D\",       DOUBLELITERAL, false),\n+            new TestTuple(\"0E-0D\",       DOUBLELITERAL, false),\n+            new TestTuple(\"0E*0D\",       DOUBLELITERAL, true),\n+\n+            new TestTuple(\"0x0.0p0d\",    DOUBLELITERAL, false),\n+            new TestTuple(\"0xff.0p8d\",   DOUBLELITERAL, false),\n+            new TestTuple(\"0xp8d\",       DOUBLELITERAL, true),\n+            new TestTuple(\"0x8pd\",       DOUBLELITERAL, true),\n+            new TestTuple(\"0xpd\",        DOUBLELITERAL, true),\n+\n+            new TestTuple(\"\\\"\\\\u2022\\\"\", STRINGLITERAL, false),\n+            new TestTuple(\"\\\"\\\\u20\\\"\",   STRINGLITERAL, true),\n+            new TestTuple(\"\\\"\\\\u\\\"\",     STRINGLITERAL, true),\n+            new TestTuple(\"\\\"\\\\uG000\\\"\", STRINGLITERAL, true),\n+            new TestTuple(\"\\\"\\\\u \\\"\",    STRINGLITERAL, true),\n+\n+            new TestTuple(\"\\\"\\\\b\\\\t\\\\n\\\\f\\\\r\\\\\\'\\\\\\\"\\\\\\\\\\\"\", STRINGLITERAL, false),\n+            new TestTuple(\"\\\"\\\\q\\\"\",     STRINGLITERAL, true),\n+\n+            new TestTuple(\"\\'\\'\",        CHARLITERAL, true),\n+            new TestTuple(\"\\'\\\\b\\'\",     CHARLITERAL, false),\n+            new TestTuple(\"\\'\\\\t\\'\",     CHARLITERAL, false),\n+            new TestTuple(\"\\'\\\\n\\'\",     CHARLITERAL, false),\n+            new TestTuple(\"\\'\\\\f\\'\",     CHARLITERAL, false),\n+            new TestTuple(\"\\'\\\\r\\'\",     CHARLITERAL, false),\n+            new TestTuple(\"\\'\\\\'\\'\",     CHARLITERAL, false),\n+            new TestTuple(\"\\'\\\\\\\\'\",     CHARLITERAL, false),\n+            new TestTuple(\"\\'\\\\\\'\\'\",    CHARLITERAL, false),\n+            new TestTuple(\"\\'\\\\\\\"\\'\",    CHARLITERAL, false),\n+            new TestTuple(\"\\'\\\\q\\'\",     CHARLITERAL, true),\n+\n+            new TestTuple(\"abc\\\\u0005def\",IDENTIFIER, false),\n+    };\n+\n+    static class TestTuple {\n+        String input;\n+        TokenKind kind;\n+        String expected;\n+        boolean willFail;\n+\n+        TestTuple(String input, TokenKind kind, String expected, boolean willFail) {\n+            this.input = input;\n+            this.kind = kind;\n+            this.expected = expected;\n+            this.willFail = willFail;\n+        }\n+\n+        TestTuple(String input, TokenKind kind, boolean willFail) {\n+            this(input, kind, input, willFail);\n+        }\n+    }\n+\n+    void assertTest(Token token, TestTuple test) {\n+        boolean normal = token != null == !test.willFail;\n+\n+        if (!normal) {\n+            String message = test.willFail ? \"Expected to fail: \"\n+                                           : \"Expected to pass: \";\n+            throw new AssertionError(message + test.input);\n+        }\n+\n+        if (token != null) {\n+            String actual = test.input.substring(token.pos, token.endPos);\n+\n+            if (token.kind != test.kind) {\n+                throw new AssertionError(\"Unexpected token kind: \" + token.kind);\n+            }\n+\n+            if (!Objects.equals(test.expected, actual)) {\n+                throw new AssertionError(\"Unexpected token content: \" + actual);\n+            }\n+        }\n+    }\n+\n+    Token readToken(String input) throws Exception {\n+        Context ctx = new Context();\n+        Log log = Log.instance(ctx);\n+\n+        log.useSource(new SimpleJavaFileObject(new URI(\"mem:\/\/Test.java\"), JavaFileObject.Kind.SOURCE) {\n+            @Override\n+            public CharSequence getCharContent(boolean ignoreEncodingErrors) throws IOException {\n+                return input;\n+            }\n+        });\n+\n+        char[] inputArr = input.toCharArray();\n+        JavaTokenizer tokenizer = new JavaTokenizer(ScannerFactory.instance(ctx), inputArr, inputArr.length) {};\n+        Token token = tokenizer.readToken();\n+\n+        return log.nerrors == 0 ? token : null;\n+    }\n+\n+    void run() throws Exception {\n+        for (TestTuple test : TESTS) {\n+            Token token = readToken(test.input);\n+            assertTest(token, test);\n+        }\n+\n+        System.out.println(\"Done!\");\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        new JavaLexerTest2().run();\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/lexer\/JavaLexerTest2.java","additions":174,"deletions":0,"binary":false,"changes":174,"status":"added"},{"patch":"@@ -1,1 +1,1 @@\n-NonasciiDigit.java:12:24: compiler.err.illegal.nonascii.digit\n+NonasciiDigit.java:12:18: compiler.err.illegal.nonascii.digit\n@@ -3,5 +3,5 @@\n-NonasciiDigit.java:14:24: compiler.err.illegal.nonascii.digit\n-NonasciiDigit.java:16:27: compiler.err.illegal.nonascii.digit\n-NonasciiDigit.java:17:22: compiler.err.illegal.nonascii.digit\n-NonasciiDigit.java:18:22: compiler.err.illegal.nonascii.digit\n-NonasciiDigit.java:19:22: compiler.err.illegal.nonascii.digit\n+NonasciiDigit.java:14:18: compiler.err.illegal.nonascii.digit\n+NonasciiDigit.java:16:21: compiler.err.illegal.nonascii.digit\n+NonasciiDigit.java:17:23: compiler.err.illegal.nonascii.digit\n+NonasciiDigit.java:18:25: compiler.err.illegal.nonascii.digit\n+NonasciiDigit.java:19:23: compiler.err.illegal.nonascii.digit\n@@ -9,1 +9,1 @@\n-NonasciiDigit.java:21:27: compiler.err.illegal.nonascii.digit\n+NonasciiDigit.java:21:21: compiler.err.illegal.nonascii.digit\n","filename":"test\/langtools\/tools\/javac\/unicode\/NonasciiDigit.out","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,3 +28,5 @@\n- * @author gafter\n- *\n- * @compile SubChar.java\n+ * @library \/tools\/lib\n+ * @modules jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.main\n+ * @build toolbox.ToolBox toolbox.JavacTask\n+ * @run main SubChar\n@@ -33,0 +35,4 @@\n+import toolbox.JavacTask;\n+import toolbox.JavaTask;\n+import toolbox.Task;\n+import toolbox.ToolBox;\n@@ -34,7 +40,0 @@\n-\/*\n-Note: this source file has been crafted very carefully to end with the\n-unicode escape sequence for the control-Z character without a\n-following newline.  The scanner is specified to allow control-Z there.\n-If you edit this source file, please make sure that your editor does\n-not insert a newline after that trailing line.\n-*\/\n@@ -42,5 +41,31 @@\n-\/** \\u001A *\/\n-class SubChar {\n-    public static void main(String args[]) {\n-        return;\n-    }\n+public class SubChar {\n+    private static final ToolBox TOOLBOX = new ToolBox();\n+\n+    private static final String SOURCE = \"\"\"\n+        \/*\n+        Note: this source file has been crafted very carefully to end with the\n+        unicode escape sequence for the control-Z character without a\n+        following newline.  The scanner is specified to allow control-Z there.\n+        If you edit this source file, please make sure that your editor does\n+        not insert a newline after that trailing line.\n+        *\/\n+\n+        \/** \\\\u001A *\/\n+        class ControlZTest {\n+            public static void main(String args[]) {\n+                return;\n+            }\n+        }\n+        \/* \\\\u001A *\/\\\n+        \"\"\";\n+\n+        public static void main(String... args) {\n+            String output = new JavacTask(TOOLBOX)\n+                    .sources(SOURCE)\n+                    .classpath(\".\")\n+                    .options(\"-encoding\", \"utf8\")\n+                    .run()\n+                    .writeAll()\n+                    .getOutput(Task.OutputKind.DIRECT);\n+            System.out.println(output);\n+        }\n@@ -48,1 +73,0 @@\n-\/* \\u001A *\/\n","filename":"test\/langtools\/tools\/javac\/unicode\/SubChar.java","additions":41,"deletions":17,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -1,2 +1,2 @@\n-SupplementaryJavaID2.java:12:14: compiler.err.illegal.char: \\ud801\n-SupplementaryJavaID2.java:12:20: compiler.err.illegal.char: \\ud801\n+SupplementaryJavaID2.java:12:9: compiler.err.illegal.char: \\ud801\n+SupplementaryJavaID2.java:12:15: compiler.err.illegal.char: \\ud801\n","filename":"test\/langtools\/tools\/javac\/unicode\/SupplementaryJavaID2.out","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,2 +1,2 @@\n-SupplementaryJavaID3.java:12:17: compiler.err.illegal.char: \\ud801\n-SupplementaryJavaID3.java:12:23: compiler.err.illegal.char: \\ud801\n+SupplementaryJavaID3.java:12:12: compiler.err.illegal.char: \\ud801\n+SupplementaryJavaID3.java:12:18: compiler.err.illegal.char: \\ud801\n","filename":"test\/langtools\/tools\/javac\/unicode\/SupplementaryJavaID3.out","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-SupplementaryJavaID4.java:14:14: compiler.err.illegal.char: \\ud834\\udd7b\n+SupplementaryJavaID4.java:14:9: compiler.err.illegal.char: \\ud834\\udd7b\n","filename":"test\/langtools\/tools\/javac\/unicode\/SupplementaryJavaID4.out","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-SupplementaryJavaID5.java:14:17: compiler.err.illegal.char: \\ud834\\udd00\n+SupplementaryJavaID5.java:14:12: compiler.err.illegal.char: \\ud834\\udd00\n","filename":"test\/langtools\/tools\/javac\/unicode\/SupplementaryJavaID5.out","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}