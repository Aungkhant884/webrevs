{"files":[{"patch":"@@ -245,1 +245,2 @@\n-            int digit = Character.digit(buffer[index], 16);\n+            \/\/ Translate and merge digit.\n+            int digit = index < length ? Character.digit(buffer[index], 16) : -1;\n@@ -248,0 +249,1 @@\n+            \/\/ If invalid digit.\n@@ -252,0 +254,1 @@\n+            \/\/ On to next character.\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/UnicodeReader.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,174 @@\n+\/*\n+ * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8254073\n+ * @modules jdk.compiler\/com.sun.tools.javac.parser\n+ *          jdk.compiler\/com.sun.tools.javac.util\n+ * @summary Proper lexing of various token kinds.\n+ *\/\n+\n+import java.io.IOException;\n+import java.net.URI;\n+import java.util.Objects;\n+\n+import javax.tools.JavaFileObject;\n+import javax.tools.SimpleJavaFileObject;\n+\n+import com.sun.tools.javac.parser.JavaTokenizer;\n+import com.sun.tools.javac.parser.ScannerFactory;\n+import com.sun.tools.javac.parser.Tokens.Token;\n+import com.sun.tools.javac.parser.Tokens.TokenKind;\n+import com.sun.tools.javac.util.Context;\n+import com.sun.tools.javac.util.Log;\n+\n+import static com.sun.tools.javac.parser.Tokens.TokenKind.*;\n+\n+public class JavaLexerTest2 {\n+    static final TestTuple[] TESTS = {\n+            new TestTuple(\"0bL\",         LONGLITERAL, true),\n+            new TestTuple(\"0b20L\",       LONGLITERAL, true),\n+\n+            new TestTuple(\"0xL\",         LONGLITERAL, true),\n+            new TestTuple(\"0xG000L\",     LONGLITERAL, true),\n+\n+            new TestTuple(\"0.0f\",        FLOATLITERAL, false),\n+            new TestTuple(\"0.0F\",        FLOATLITERAL, false),\n+            new TestTuple(\".0F\",         FLOATLITERAL, false),\n+            new TestTuple(\"0.F\",         FLOATLITERAL, false),\n+            new TestTuple(\"0E0F\",        FLOATLITERAL, false),\n+            new TestTuple(\"0E+0F\",       FLOATLITERAL, false),\n+            new TestTuple(\"0E-0F\",       FLOATLITERAL, false),\n+            new TestTuple(\"0E*0F\",       FLOATLITERAL, true),\n+\n+            new TestTuple(\"0.0d\",        DOUBLELITERAL, false),\n+            new TestTuple(\"0.0D\",        DOUBLELITERAL, false),\n+            new TestTuple(\".0D\",         DOUBLELITERAL, false),\n+            new TestTuple(\"0.D\",         DOUBLELITERAL, false),\n+            new TestTuple(\"0E0D\",        DOUBLELITERAL, false),\n+            new TestTuple(\"0E+0D\",       DOUBLELITERAL, false),\n+            new TestTuple(\"0E-0D\",       DOUBLELITERAL, false),\n+            new TestTuple(\"0E*0D\",       DOUBLELITERAL, true),\n+\n+            new TestTuple(\"0x0.0p0d\",    DOUBLELITERAL, false),\n+            new TestTuple(\"0xff.0p8d\",   DOUBLELITERAL, false),\n+            new TestTuple(\"0xp8d\",       DOUBLELITERAL, true),\n+            new TestTuple(\"0x8pd\",       DOUBLELITERAL, true),\n+            new TestTuple(\"0xpd\",        DOUBLELITERAL, true),\n+\n+            new TestTuple(\"\\\"\\\\u2022\\\"\", STRINGLITERAL, false),\n+            new TestTuple(\"\\\"\\\\u20\\\"\",   STRINGLITERAL, true),\n+            new TestTuple(\"\\\"\\\\u\\\"\",     STRINGLITERAL, true),\n+            new TestTuple(\"\\\"\\\\uG000\\\"\", STRINGLITERAL, true),\n+            new TestTuple(\"\\\"\\\\u \\\"\",    STRINGLITERAL, true),\n+\n+            new TestTuple(\"\\\"\\\\b\\\\t\\\\n\\\\f\\\\r\\\\\\'\\\\\\\"\\\\\\\\\\\"\", STRINGLITERAL, false),\n+            new TestTuple(\"\\\"\\\\q\\\"\",     STRINGLITERAL, true),\n+\n+            new TestTuple(\"\\'\\'\",        CHARLITERAL, true),\n+            new TestTuple(\"\\'\\\\b\\'\",     CHARLITERAL, false),\n+            new TestTuple(\"\\'\\\\t\\'\",     CHARLITERAL, false),\n+            new TestTuple(\"\\'\\\\n\\'\",     CHARLITERAL, false),\n+            new TestTuple(\"\\'\\\\f\\'\",     CHARLITERAL, false),\n+            new TestTuple(\"\\'\\\\r\\'\",     CHARLITERAL, false),\n+            new TestTuple(\"\\'\\\\'\\'\",     CHARLITERAL, false),\n+            new TestTuple(\"\\'\\\\\\\\'\",     CHARLITERAL, false),\n+            new TestTuple(\"\\'\\\\\\'\\'\",    CHARLITERAL, false),\n+            new TestTuple(\"\\'\\\\\\\"\\'\",    CHARLITERAL, false),\n+            new TestTuple(\"\\'\\\\q\\'\",     CHARLITERAL, true),\n+\n+            new TestTuple(\"abc\\\\u0005def\",IDENTIFIER, false),\n+    };\n+\n+    static class TestTuple {\n+        String input;\n+        TokenKind kind;\n+        String expected;\n+        boolean willFail;\n+\n+        TestTuple(String input, TokenKind kind, String expected, boolean willFail) {\n+            this.input = input;\n+            this.kind = kind;\n+            this.expected = expected;\n+            this.willFail = willFail;\n+        }\n+\n+        TestTuple(String input, TokenKind kind, boolean willFail) {\n+            this(input, kind, input, willFail);\n+        }\n+    }\n+\n+    void assertTest(Token token, TestTuple test) {\n+        boolean normal = token != null == !test.willFail;\n+\n+        if (!normal) {\n+            String message = test.willFail ? \"Expected to fail: \"\n+                                           : \"Expected to pass: \";\n+            throw new AssertionError(message + test.input);\n+        }\n+\n+        if (token != null) {\n+            String actual = test.input.substring(token.pos, token.endPos);\n+\n+            if (token.kind != test.kind) {\n+                throw new AssertionError(\"Unexpected token kind: \" + token.kind);\n+            }\n+\n+            if (!Objects.equals(test.expected, actual)) {\n+                throw new AssertionError(\"Unexpected token content: \" + actual);\n+            }\n+        }\n+    }\n+\n+    Token readToken(String input) throws Exception {\n+        Context ctx = new Context();\n+        Log log = Log.instance(ctx);\n+\n+        log.useSource(new SimpleJavaFileObject(new URI(\"mem:\/\/Test.java\"), JavaFileObject.Kind.SOURCE) {\n+            @Override\n+            public CharSequence getCharContent(boolean ignoreEncodingErrors) throws IOException {\n+                return input;\n+            }\n+        });\n+\n+        char[] inputArr = input.toCharArray();\n+        JavaTokenizer tokenizer = new JavaTokenizer(ScannerFactory.instance(ctx), inputArr, inputArr.length) {};\n+        Token token = tokenizer.readToken();\n+\n+        return log.nerrors == 0 ? token : null;\n+    }\n+\n+    void run() throws Exception {\n+        for (TestTuple test : TESTS) {\n+            Token token = readToken(test.input);\n+            assertTest(token, test);\n+        }\n+\n+        System.out.println(\"Done!\");\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        new JavaLexerTest2().run();\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/lexer\/JavaLexerTest2.java","additions":174,"deletions":0,"binary":false,"changes":174,"status":"added"}]}