{"files":[{"patch":"@@ -30,1 +30,1 @@\n-ifeq ($(call isTargetOs, linux macosx), true)\n+ifeq ($(call isTargetOs, linux macosx windows), true)\n@@ -38,1 +38,1 @@\n-      LIBS := -ljava, \\\n+      LIBS_unix := -ljava, \\\n@@ -40,0 +40,1 @@\n+      LIBS_windows := jvm.lib ws2_32.lib $(WIN_JAVA_LIB), \\\n","filename":"make\/modules\/jdk.net\/Lib.gmk","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -111,1 +111,2 @@\n-        if (option.name().startsWith(\"UDP_\") || isUnixDomainOption(option)) {\n+        if (option.name().startsWith(\"UDP_\") || isUnixDomainOption(option)\n+            || option.name().equals(\"IP_DONTFRAGMENT\")) {\n","filename":"src\/java.base\/share\/classes\/sun\/net\/ext\/ExtendedSocketOptions.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -105,0 +105,10 @@\n+    @Override\n+    void setIpDontFragment(int fd, final boolean value) throws SocketException {\n+        setIpDontFragment0(fd, value);\n+    }\n+\n+    @Override\n+    boolean getIpDontFragment(int fd) throws SocketException {\n+        return getIpDontFragment0(fd);\n+    }\n+\n@@ -118,0 +128,1 @@\n+    private static native void setIpDontFragment0(int fd, boolean value) throws SocketException;\n@@ -121,0 +132,1 @@\n+    private static native boolean getIpDontFragment0(int fd) throws SocketException;\n","filename":"src\/jdk.net\/linux\/classes\/jdk\/net\/LinuxSocketOptions.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -246,0 +246,62 @@\n+\n+static int socketFamily(jint fd) {\n+    struct sockaddr_storage st;\n+    struct sockaddr *sa = (struct sockaddr *)&st;\n+    socklen_t sa_len = sizeof(st);\n+\n+    if (getsockname(fd, sa, &sa_len) == 0) {\n+        return sa->sa_family;\n+    }\n+    return -1;\n+}\n+\n+\/*\n+ * Class:     jdk_net_LinuxSocketOptions\n+ * Method:    setIpDontFragment0\n+ * Signature: (IZ)V\n+ *\/\n+JNIEXPORT void JNICALL Java_jdk_net_LinuxSocketOptions_setIpDontFragment0\n+(JNIEnv *env, jobject unused, jint fd, jboolean optval) {\n+    jint rv, optsetting;\n+    jint family = socketFamily(fd);\n+    if (family == -1) {\n+        handleError(env, family, \"get socket family failed\");\n+        return;\n+    }\n+\n+    optsetting = optval ? IP_PMTUDISC_DO : IP_PMTUDISC_DONT;\n+\n+    if (family == AF_INET) {\n+        rv = setsockopt(fd, IPPROTO_IP, IP_MTU_DISCOVER, &optsetting, sizeof (optsetting));\n+    } else {\n+        rv = setsockopt(fd, IPPROTO_IPV6, IPV6_MTU_DISCOVER, &optsetting, sizeof (optsetting));\n+    }\n+    handleError(env, rv, \"set option IP_DONTFRAGMENT failed\");\n+}\n+\n+\/*\n+ * Class:     jdk_net_LinuxSocketOptions\n+ * Method:    getIpDontFragment0\n+ * Signature: (I)Z;\n+ *\/\n+JNIEXPORT jboolean JNICALL Java_jdk_net_LinuxSocketOptions_getIpDontFragment0\n+(JNIEnv *env, jobject unused, jint fd) {\n+    jint optlevel, optname, optval, rv;\n+    jint family = socketFamily(fd);\n+    if (family == -1) {\n+        handleError(env, family, \"get socket family failed\");\n+        return JNI_FALSE;\n+    }\n+\n+    if (family == AF_INET) {\n+        optlevel = IPPROTO_IP;\n+        optname = IP_MTU_DISCOVER;\n+    } else {\n+        optlevel = IPPROTO_IPV6;\n+        optname = IPV6_MTU_DISCOVER;\n+    }\n+    socklen_t sz = sizeof(optval);\n+    rv = getsockopt(fd, optlevel, optname, &optval, &sz);\n+    handleError(env, rv, \"get option IP_DONTFRAGMENT failed\");\n+    return optval == IP_PMTUDISC_DO ? JNI_TRUE : JNI_FALSE;\n+}\n","filename":"src\/jdk.net\/linux\/native\/libextnet\/LinuxSocketOptions.c","additions":62,"deletions":0,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -81,0 +81,10 @@\n+    @Override\n+    void setIpDontFragment(int fd, final boolean value) throws SocketException {\n+        setIpDontFragment0(fd, value);\n+    }\n+\n+    @Override\n+    boolean getIpDontFragment(int fd) throws SocketException {\n+        return getIpDontFragment0(fd);\n+    }\n+\n@@ -94,0 +104,1 @@\n+    private static native void setIpDontFragment0(int fd, boolean value) throws SocketException;\n@@ -97,0 +108,1 @@\n+    private static native boolean getIpDontFragment0(int fd) throws SocketException;\n","filename":"src\/jdk.net\/macosx\/classes\/jdk\/net\/MacOSXSocketOptions.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -33,0 +33,2 @@\n+\n+#define __APPLE_USE_RFC_3542\n@@ -34,0 +36,5 @@\n+\n+#ifndef IP_DONTFRAG\n+#define IP_DONTFRAG             28\n+#endif\n+\n@@ -173,0 +180,57 @@\n+\n+static int socketFamily(jint fd) {\n+    struct sockaddr_storage st;\n+    struct sockaddr* sa = (struct sockaddr *)&st;\n+    socklen_t sa_len = sizeof(st);\n+\n+    if (getsockname(fd, sa, &sa_len) == 0) {\n+        return sa->sa_family;\n+    }\n+    return -1;\n+}\n+\n+\/*\n+ * Class:     jdk_net_MacOSXSocketOptions\n+ * Method:    setIpDontFragment0\n+ * Signature: (IZ)V\n+ *\/\n+JNIEXPORT void JNICALL Java_jdk_net_MacOSXSocketOptions_setIpDontFragment0\n+(JNIEnv *env, jobject unused, jint fd, jboolean optval) {\n+    jint rv;\n+    jint family = socketFamily(fd);\n+    jint value = optval ? 1 : 0;\n+\n+    if (family == -1) {\n+        handleError(env, family, \"get socket family failed\");\n+        return;\n+    }\n+    if (family == AF_INET) {\n+        rv = setsockopt(fd, IPPROTO_IP, IP_DONTFRAG, &value, sizeof(value));\n+    } else {\n+        rv = setsockopt(fd, IPPROTO_IPV6, IPV6_DONTFRAG, &value, sizeof(value));\n+    }\n+    handleError(env, rv, \"set option IP_DONTFRAGMENT failed\");\n+}\n+\n+\/*\n+ * Class:     jdk_net_MacOSXSocketOptions\n+ * Method:    getIpDontFragment0\n+ * Signature: (I)Z;\n+ *\/\n+JNIEXPORT jboolean JNICALL Java_jdk_net_MacOSXSocketOptions_getIpDontFragment0\n+(JNIEnv *env, jobject unused, jint fd) {\n+    jint optval, rv;\n+    socklen_t sz = sizeof (optval);\n+    jint family = socketFamily(fd);\n+    if (family == -1) {\n+        handleError(env, family, \"get socket family failed\");\n+        return 0;\n+    }\n+    if (family == AF_INET) {\n+        rv = getsockopt(fd, IPPROTO_IP, IP_DONTFRAG, &optval, &sz);\n+    } else {\n+        rv = getsockopt(fd, IPPROTO_IPV6, IPV6_DONTFRAG, &optval, &sz);\n+    }\n+    handleError(env, rv, \"get option IP_DONTFRAGMENT failed\");\n+    return optval;\n+}\n","filename":"src\/jdk.net\/macosx\/native\/libextnet\/MacOSXSocketOptions.c","additions":64,"deletions":0,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -202,0 +202,22 @@\n+    \/**\n+     * Disable IP packet fragmentation.\n+     *\n+     * <p> The value of this socket option is a {@code Boolean} that represents\n+     * whether the option is enabled or disabled. When {@code true} fragmentation\n+     * of outgoing IPv4 and IPv6 packets does not occur. This option can only be used\n+     * with datagram sockets. When set, care must be taken to limit outgoing packet\n+     * sizes to the {@link java.net.NetworkInterface#getMTU() local MTU}. Depending\n+     * on the implementation and the network interface, packets larger than the MTU\n+     * may be sent or dropped silently or dropped with an exception thrown.\n+     *\n+     * @apiNote\n+     * For IPv4 this option sets the DF (Do not Fragment) flag in the IP packet\n+     * header. This instructs intermediate routers to not fragment the packet.\n+     * IPv6 routers never fragment packets. Instead, fragmentation is handled\n+     * by the sending and receiving nodes exclusively. Setting this option for\n+     * an IPv6 socket ensures that packets to be sent are never fragmented, in\n+     * which case, the local network MTU must be observed.\n+     *\/\n+    public static final SocketOption<Boolean> IP_DONTFRAGMENT =\n+        new ExtSocketOption<Boolean>(\"IP_DONTFRAGMENT\", Boolean.class);\n+\n@@ -213,0 +235,1 @@\n+\n@@ -229,0 +252,1 @@\n+        options.add(IP_DONTFRAGMENT);\n@@ -251,0 +275,2 @@\n+                } else if (option == IP_DONTFRAGMENT) {\n+                    setIpDontFragment(fd, (Boolean) value);\n@@ -280,0 +306,2 @@\n+                } else if (option == IP_DONTFRAGMENT) {\n+                    return getIpDontFragment(fd);\n@@ -323,0 +351,5 @@\n+    private static void setIpDontFragment(FileDescriptor fd, boolean value)\n+            throws SocketException {\n+        platformSocketOptions.setIpDontFragment(fdAccess.get(fd), value);\n+    }\n+\n@@ -332,0 +365,4 @@\n+    private static boolean getIpDontFragment(FileDescriptor fd) throws SocketException {\n+        return platformSocketOptions.getIpDontFragment(fdAccess.get(fd));\n+    }\n+\n@@ -371,0 +408,2 @@\n+            } else if (osname.startsWith(\"Windows\")) {\n+                return newInstance(\"jdk.net.WindowsSocketOptions\");\n@@ -418,0 +457,8 @@\n+        void setIpDontFragment(int fd, final boolean value) throws SocketException {\n+            throw new UnsupportedOperationException(\"unsupported IP_DONTFRAGMENT option\");\n+        }\n+\n+        boolean getIpDontFragment(int fd) throws SocketException {\n+            throw new UnsupportedOperationException(\"unsupported IP_DONTFRAGMENT option\");\n+        }\n+\n","filename":"src\/jdk.net\/share\/classes\/jdk\/net\/ExtendedSocketOptions.java","additions":47,"deletions":0,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -0,0 +1,62 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.net;\n+\n+import java.net.SocketException;\n+import java.security.AccessController;\n+import java.security.PrivilegedAction;\n+import jdk.net.ExtendedSocketOptions.PlatformSocketOptions;\n+\n+\n+@SuppressWarnings(\"removal\")\n+class WindowsSocketOptions extends PlatformSocketOptions {\n+\n+    public WindowsSocketOptions() {\n+    }\n+\n+    @Override\n+    void setIpDontFragment(int fd, final boolean value) throws SocketException {\n+        setIpDontFragment0(fd, value);\n+    }\n+\n+    @Override\n+    boolean getIpDontFragment(int fd) throws SocketException {\n+        return getIpDontFragment0(fd);\n+    }\n+\n+    private static native void setIpDontFragment0(int fd, boolean value) throws SocketException;\n+    private static native boolean getIpDontFragment0(int fd) throws SocketException;\n+\n+    static {\n+        if (System.getSecurityManager() == null) {\n+            System.loadLibrary(\"extnet\");\n+        } else {\n+            AccessController.doPrivileged((PrivilegedAction<Void>) () -> {\n+                System.loadLibrary(\"extnet\");\n+                return null;\n+            });\n+        }\n+    }\n+}\n","filename":"src\/jdk.net\/windows\/classes\/jdk\/net\/WindowsSocketOptions.java","additions":62,"deletions":0,"binary":false,"changes":62,"status":"added"},{"patch":"@@ -0,0 +1,116 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <windows.h>\n+#include <winsock2.h>\n+\n+#include <WS2tcpip.h>\n+\n+#include \"jni.h\"\n+#include \"jni_util.h\"\n+#include \"jvm.h\"\n+\n+static void handleError(JNIEnv *env, jint rv, const char *errmsg) {\n+    if (rv < 0) {\n+        if (errno == ENOPROTOOPT) {\n+            JNU_ThrowByName(env, \"java\/lang\/UnsupportedOperationException\",\n+                    \"unsupported socket option\");\n+        } else {\n+            JNU_ThrowByNameWithLastError(env, \"java\/net\/SocketException\", errmsg);\n+        }\n+    }\n+}\n+\n+static int socketFamily(jint fd) {\n+    WSAPROTOCOL_INFO info;\n+    socklen_t sa_len = sizeof(info);\n+\n+    if (getsockopt(fd, SOL_SOCKET, SO_PROTOCOL_INFO, (char *)&info, &sa_len) == 0) {\n+        return info.iAddressFamily;\n+    }\n+    return -1;\n+}\n+\n+\/*\n+ * Class:     jdk_net_WindowsSocketOptions\n+ * Method:    setIpDontFragment0\n+ * Signature: (IZ)V\n+ *\/\n+JNIEXPORT void JNICALL Java_jdk_net_WindowsSocketOptions_setIpDontFragment0\n+(JNIEnv *env, jobject unused, jint fd, jboolean optval) {\n+    int rv, opt;\n+    jint family = socketFamily(fd);\n+    if (family == -1) {\n+        handleError(env, family, \"get socket family failed\");\n+        return;\n+    }\n+\n+\n+    if (family == AF_INET) {\n+        opt = optval;\n+        rv = setsockopt(fd, IPPROTO_IP, IP_DONTFRAGMENT, (char *)&opt, sizeof(int));\n+    } else {\n+        opt = optval ? IP_PMTUDISC_DO : IP_PMTUDISC_DONT;\n+        rv = setsockopt(fd, IPPROTO_IPV6, IPV6_MTU_DISCOVER, (char *)&opt, sizeof(int));\n+        if (rv == SOCKET_ERROR && WSAGetLastError() == WSAENOPROTOOPT) {\n+            \/* IPV6_MTU_DISCOVER not supported on W 2016 and older, can use old option *\/\n+            opt = optval;\n+            rv = setsockopt(fd, IPPROTO_IP, IP_DONTFRAGMENT, (char *)&opt, sizeof(int));\n+        }\n+    }\n+    handleError(env, rv, \"set option IP_DONTFRAGMENT failed\");\n+}\n+\n+\/*\n+ * Class:     jdk_net_WindowsSocketOptions\n+ * Method:    getIpDontFragment0\n+ * Signature: (I)Z;\n+ *\/\n+JNIEXPORT jboolean JNICALL Java_jdk_net_WindowsSocketOptions_getIpDontFragment0\n+(JNIEnv *env, jobject unused, jint fd) {\n+    int optval, rv, sz = sizeof(optval);\n+    jint family = socketFamily(fd);\n+    if (family == -1) {\n+        handleError(env, family, \"get socket family failed\");\n+        return JNI_FALSE;\n+    }\n+\n+    if (family == AF_INET) {\n+        rv = getsockopt(fd, IPPROTO_IP, IP_DONTFRAGMENT, (char *)&optval, &sz);\n+        handleError(env, rv, \"get option IP_DONTFRAGMENT failed\");\n+        return optval;\n+    } else {\n+        rv = getsockopt(fd, IPPROTO_IPV6, IPV6_MTU_DISCOVER, (char *)&optval, &sz);\n+        if (rv == SOCKET_ERROR && WSAGetLastError() == WSAENOPROTOOPT) {\n+            sz = sizeof(optval);\n+            rv = getsockopt(fd, IPPROTO_IP, IP_DONTFRAGMENT, (char *)&optval, &sz);\n+            handleError(env, rv, \"get option IP_DONTFRAGMENT failed\");\n+            return optval;\n+        }\n+        handleError(env, rv, \"get option IP_DONTFRAGMENT failed\");\n+        return optval == IP_PMTUDISC_DO ? JNI_TRUE : JNI_FALSE;\n+    }\n+}\n+\n","filename":"src\/jdk.net\/windows\/native\/libextnet\/WindowsSocketOptions.c","additions":116,"deletions":0,"binary":false,"changes":116,"status":"added"},{"patch":"@@ -108,0 +108,2 @@\n+            field = c.getField(\"IP_DONTFRAGMENT\");\n+            map.put((SocketOption<?>)field.get(null), listOf(TRUE, FALSE));\n","filename":"test\/jdk\/java\/net\/SocketOption\/AfterClose.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,59 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8243099\n+ * @modules jdk.net\n+ * @run main\/othervm DontFragmentTest ipv4\n+ * @run main\/othervm DontFragmentTest ipv6\n+ *\/\n+\n+import java.io.IOException;\n+import java.net.*;\n+import java.nio.channels.*;\n+import static java.net.StandardProtocolFamily.INET;\n+import static java.net.StandardProtocolFamily.INET6;\n+import static jdk.net.ExtendedSocketOptions.IP_DONTFRAGMENT;\n+\n+public class DontFragmentTest {\n+\n+    public static void main(String[] args) throws IOException {\n+        StandardProtocolFamily fam = args[0].equals(\"ipv4\") ? INET : INET6;\n+        System.out.println(\"Family = \" + fam);\n+        DatagramChannel c1 = DatagramChannel.open(fam);\n+\n+        if (c1.getOption(IP_DONTFRAGMENT)) {\n+            throw new RuntimeException(\"IP_DONTFRAGMENT should not be set\");\n+        }\n+        c1.setOption(IP_DONTFRAGMENT, true);\n+        if (!c1.getOption(IP_DONTFRAGMENT)) {\n+            throw new RuntimeException(\"IP_DONTFRAGMENT should be set\");\n+        }\n+        c1.setOption(IP_DONTFRAGMENT, false);\n+        if (c1.getOption(IP_DONTFRAGMENT)) {\n+            throw new RuntimeException(\"IP_DONTFRAGMENT should not be set\");\n+        }\n+        c1.close();\n+    }\n+}\n","filename":"test\/jdk\/jdk\/net\/ExtendedSocketOption\/DontFragmentTest.java","additions":59,"deletions":0,"binary":false,"changes":59,"status":"added"}]}