{"files":[{"patch":"@@ -47,1 +47,0 @@\n-import jdk.jfr.internal.RequestEngine;\n@@ -49,0 +48,1 @@\n+import jdk.jfr.internal.periodic.PeriodicEvents;\n@@ -228,1 +228,1 @@\n-        RequestEngine.addHook(acc, EventType.getEventType(eventClass).getPlatformEventType(), hook);\n+        PeriodicEvents.addUserEvent(acc, eventClass, hook);\n@@ -245,1 +245,1 @@\n-        return RequestEngine.removeHook(hook);\n+        return PeriodicEvents.removeEvent(hook);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/FlightRecorder.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n-    static final Object CHUNK_ROTATION_MONITOR = new ChunkRotationMonitor();\n+    public static final Object CHUNK_ROTATION_MONITOR = new ChunkRotationMonitor();\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/JVM.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -49,1 +49,0 @@\n-import jdk.jfr.internal.RequestEngine.RequestHook;\n@@ -52,0 +51,1 @@\n+import jdk.jfr.internal.periodic.PeriodicEvents;\n@@ -73,1 +73,0 @@\n-        List<RequestHook> requestHooks = new ArrayList<>();\n@@ -87,1 +86,1 @@\n-                        requestHooks.add(new RequestHook(pEventType));\n+                        PeriodicEvents.addJVMEvent(pEventType);\n@@ -94,1 +93,0 @@\n-        RequestEngine.addHooks(requestHooks);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/MetadataRepository.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-\n+import jdk.jfr.internal.periodic.PeriodicEvents;\n@@ -68,1 +68,0 @@\n-\n@@ -204,0 +203,1 @@\n+        boolean changed = enabled != this.enabled;\n@@ -214,0 +214,3 @@\n+        if (changed) {\n+            PeriodicEvents.setChanged();\n+        }\n@@ -223,0 +226,1 @@\n+        boolean changed = period != periodMillis;\n@@ -224,0 +228,3 @@\n+        if (changed) {\n+            PeriodicEvents.setChanged();\n+        }\n@@ -266,0 +273,1 @@\n+        PeriodicEvents.setChanged();\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/PlatformEventType.java","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -60,0 +60,1 @@\n+import jdk.jfr.internal.periodic.PeriodicEvents;\n@@ -261,1 +262,1 @@\n-                RequestEngine.doChunkEnd();\n+                PeriodicEvents.doChunkEnd();\n@@ -278,1 +279,1 @@\n-            RequestEngine.setFlushInterval(streamInterval);\n+            PeriodicEvents.setFlushInterval(streamInterval);\n@@ -280,1 +281,1 @@\n-        RequestEngine.doChunkBegin();\n+        PeriodicEvents.doChunkBegin();\n@@ -316,1 +317,1 @@\n-            RequestEngine.doChunkEnd();\n+            PeriodicEvents.doChunkEnd();\n@@ -333,1 +334,1 @@\n-            RequestEngine.doChunkEnd();\n+            PeriodicEvents.doChunkEnd();\n@@ -351,1 +352,1 @@\n-            RequestEngine.doChunkBegin();\n+            PeriodicEvents.doChunkBegin();\n@@ -355,1 +356,1 @@\n-            RequestEngine.setFlushInterval(streamInterval);\n+            PeriodicEvents.setFlushInterval(streamInterval);\n@@ -357,1 +358,1 @@\n-            RequestEngine.setFlushInterval(Long.MAX_VALUE);\n+            PeriodicEvents.setFlushInterval(Long.MAX_VALUE);\n@@ -397,1 +398,1 @@\n-        RequestEngine.doChunkEnd();\n+        PeriodicEvents.doChunkEnd();\n@@ -406,1 +407,1 @@\n-        RequestEngine.doChunkBegin();\n+        PeriodicEvents.doChunkBegin();\n@@ -502,1 +503,1 @@\n-            long minDelta = RequestEngine.doPeriodic();\n+            long minDelta = PeriodicEvents.doPeriodic();\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/PlatformRecorder.java","additions":12,"deletions":11,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -1,311 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.jfr.internal;\n-\n-import java.security.AccessControlContext;\n-import java.security.AccessController;\n-import java.security.PrivilegedAction;\n-import java.util.Collection;\n-import java.util.Iterator;\n-import java.util.List;\n-import java.util.Objects;\n-import java.util.concurrent.CopyOnWriteArrayList;\n-import java.util.concurrent.locks.ReentrantLock;\n-import java.util.function.Predicate;\n-import jdk.jfr.Event;\n-import jdk.jfr.EventType;\n-\n-public final class RequestEngine {\n-    enum PeriodicType {\n-        BEGIN_CHUNK, INTERVAL, END_CHUNK\n-    }\n-\n-    private static final JVM jvm = JVM.getJVM();\n-    private static final ReentrantLock lock = new ReentrantLock();\n-\n-    static final class RequestHook {\n-        private final Runnable hook;\n-        private final PlatformEventType type;\n-        @SuppressWarnings(\"removal\")\n-        private final AccessControlContext accessControllerContext;\n-        private long delta;\n-\n-        \/\/ Java events\n-        private RequestHook(@SuppressWarnings(\"removal\") AccessControlContext acc, PlatformEventType eventType, Runnable hook) {\n-            this.hook = hook;\n-            this.type = eventType;\n-            this.accessControllerContext = acc;\n-        }\n-\n-        \/\/ native events\n-        RequestHook(PlatformEventType eventType) {\n-            this(null, eventType, null);\n-        }\n-\n-        private void execute(long timestamp, PeriodicType periodicType) {\n-            try {\n-                if (accessControllerContext == null) { \/\/ native\n-                    if (type.isJDK()) {\n-                        hook.run();\n-                    } else {\n-                        emitJVMEvent(type, timestamp, periodicType);\n-                    }\n-                    if (Logger.shouldLog(LogTag.JFR_SYSTEM, LogLevel.DEBUG)) {\n-                        Logger.log(LogTag.JFR_SYSTEM, LogLevel.DEBUG, \"Executed periodic hook for \" + type.getLogName());\n-                    }\n-                } else {\n-                    executeSecure();\n-                }\n-            } catch (Throwable e) {\n-                \/\/ Prevent malicious user to propagate exception callback in the wrong context\n-                Logger.log(LogTag.JFR_SYSTEM, LogLevel.WARN, \"Exception occurred during execution of period hook for \" + type.getLogName());\n-            }\n-        }\n-\n-        private void emitJVMEvent(PlatformEventType type, long timestamp, PeriodicType periodicType) {\n-            try {\n-                \/\/ There should only be one thread in native at a time.\n-                \/\/ ReentrantLock is used to avoid JavaMonitorBlocked event\n-                \/\/ from synchronized block.\n-                lock.lock();\n-                jvm.emitEvent(type.getId(), timestamp, periodicType.ordinal());\n-            } finally {\n-                lock.unlock();\n-            }\n-        }\n-\n-        @SuppressWarnings(\"removal\")\n-        private void executeSecure() {\n-            AccessController.doPrivileged(new PrivilegedAction<Void>() {\n-                @Override\n-                public Void run() {\n-                    try {\n-                        hook.run();\n-                        if (Logger.shouldLog(LogTag.JFR_EVENT, LogLevel.DEBUG)) {\n-                            Logger.log(LogTag.JFR_EVENT, LogLevel.DEBUG, \"Executed periodic hook for \" + type.getLogName());\n-                        }\n-                    } catch (Throwable t) {\n-                        \/\/ Prevent malicious user to propagate exception callback in the wrong context\n-                        Logger.log(LogTag.JFR_EVENT, LogLevel.WARN, \"Exception occurred during execution of period hook for \" + type.getLogName());\n-                    }\n-                    return null;\n-                }\n-            }, accessControllerContext);\n-        }\n-    }\n-\n-    private static final List<RequestHook> entries = new CopyOnWriteArrayList<>();\n-    private static long lastTimeMillis;\n-    private static long flushInterval = Long.MAX_VALUE;\n-    private static long streamDelta;\n-\n-    public static void addHook(@SuppressWarnings(\"removal\") AccessControlContext acc, PlatformEventType type, Runnable hook) {\n-        Objects.requireNonNull(acc);\n-        addHookInternal(acc, type, hook);\n-    }\n-\n-    private static void addHookInternal(@SuppressWarnings(\"removal\") AccessControlContext acc, PlatformEventType type, Runnable hook) {\n-        RequestHook he = new RequestHook(acc, type, hook);\n-        for (RequestHook e : entries) {\n-            if (e.hook == hook) {\n-                throw new IllegalArgumentException(\"Hook has already been added\");\n-            }\n-        }\n-        he.type.setEventHook(true);\n-        \/\/ Insertion takes O(2*n), could be O(1) with HashMap, but\n-        \/\/ thinking is that CopyOnWriteArrayList is faster\n-        \/\/ to iterate over, which will happen more over time.\n-        entries.add(he);\n-        logHook(\"Added\", type);\n-    }\n-\n-    public static void addTrustedJDKHook(Class<? extends Event> eventClass, Runnable runnable) {\n-        if (eventClass.getClassLoader() != null) {\n-            throw new SecurityException(\"Hook can only be registered for event classes that are loaded by the bootstrap class loader\");\n-        }\n-        if (runnable.getClass().getClassLoader() != null) {\n-            throw new SecurityException(\"Runnable hook class must be loaded by the bootstrap class loader\");\n-        }\n-        EventType eType = MetadataRepository.getInstance().getEventType(eventClass);\n-        PlatformEventType pType = PrivateAccess.getInstance().getPlatformEventType(eType);\n-        addHookInternal(null, pType, runnable);\n-    }\n-\n-    private static void logHook(String action, PlatformEventType type) {\n-        if (type.isSystem()) {\n-            Logger.log(LogTag.JFR_SYSTEM, LogLevel.INFO, action + \" periodic hook for \" + type.getLogName());\n-        } else {\n-            Logger.log(LogTag.JFR, LogLevel.INFO, action + \" periodic hook for \" + type.getLogName());\n-        }\n-    }\n-\n-    \/\/ Takes O(2*n), see addHook.\n-    public static boolean removeHook(Runnable hook) {\n-        for (RequestHook rh : entries) {\n-            if (rh.hook == hook) {\n-                entries.remove(rh);\n-                rh.type.setEventHook(false);\n-                logHook(\"Removed\", rh.type);\n-                return true;\n-            }\n-        }\n-        return false;\n-    }\n-\n-    \/\/ Only to be used for JVM events. No access control contest\n-    \/\/ or check if hook already exists\n-    static void addHooks(List<RequestHook> newEntries) {\n-        for (RequestHook rh : newEntries) {\n-            rh.type.setEventHook(true);\n-            logHook(\"Added\", rh.type);\n-        }\n-        entries.addAll(newEntries);\n-    }\n-\n-    static void doChunkEnd() {\n-        doChunk(x -> x.isEndChunk(), PeriodicType.END_CHUNK);\n-    }\n-\n-    static void doChunkBegin() {\n-        doChunk(x -> x.isBeginChunk(), PeriodicType.BEGIN_CHUNK);\n-    }\n-\n-    private static void doChunk(Predicate<PlatformEventType> predicate, PeriodicType type) {\n-        long timestamp = JVM.counterTime();\n-        for (RequestHook requestHook : entries) {\n-            PlatformEventType s = requestHook.type;\n-            if (s.isEnabled() && predicate.test(s)) {\n-                requestHook.execute(timestamp, type);\n-            }\n-        }\n-    }\n-\n-    static long doPeriodic() {\n-        return run_requests(entries, JVM.counterTime());\n-    }\n-\n-    \/\/ code copied from native impl.\n-    private static long run_requests(Collection<RequestHook> entries, long eventTimestamp) {\n-        long last = lastTimeMillis;\n-        \/\/ The interval for periodic events is typically at least 1 s, so\n-        \/\/ System.currentTimeMillis() is sufficient. JVM.counterTime() lacks\n-        \/\/ unit and has in the past been more unreliable.\n-        long now = System.currentTimeMillis();\n-        long min = 0;\n-        long delta = 0;\n-\n-        if (last == 0) {\n-            last = now;\n-        }\n-\n-        \/\/ time from then to now\n-        delta = now - last;\n-\n-        if (delta < 0) {\n-            \/\/ to handle time adjustments\n-            \/\/ for example Daylight Savings\n-            lastTimeMillis = now;\n-            return 0;\n-        }\n-        Iterator<RequestHook> hookIterator = entries.iterator();\n-        while(hookIterator.hasNext()) {\n-            RequestHook he = hookIterator.next();\n-            long left = 0;\n-            PlatformEventType es = he.type;\n-            \/\/ Not enabled, skip.\n-            if (!es.isEnabled() || es.isChunkTime()) {\n-                continue;\n-            }\n-            long r_period = es.getPeriod();\n-            long r_delta = he.delta;\n-\n-            \/\/ add time elapsed.\n-            r_delta += delta;\n-\n-            \/\/ above threshold?\n-            if (r_delta >= r_period) {\n-                \/\/ Bug 9000556 - don't try to compensate\n-                \/\/ for wait > period\n-                r_delta = 0;\n-                he.execute(eventTimestamp, PeriodicType.INTERVAL);\n-            }\n-\n-            \/\/ calculate time left\n-            left = (r_period - r_delta);\n-\n-            \/*\n-             * nothing outside checks that a period is >= 0, so left can end up\n-             * negative here. ex. (r_period =(-1)) - (r_delta = 0) if it is,\n-             * handle it.\n-             *\/\n-            if (left < 0) {\n-                left = 0;\n-            }\n-\n-            \/\/ assign delta back\n-            he.delta = r_delta;\n-\n-            if (min == 0 || left < min) {\n-                min = left;\n-            }\n-        }\n-        \/\/ Flush should happen after all periodic events has been emitted\n-        \/\/ Repeat of the above algorithm, but using the stream interval.\n-        if (flushInterval != Long.MAX_VALUE) {\n-            long r_period = flushInterval;\n-            long r_delta = streamDelta;\n-            r_delta += delta;\n-            if (r_delta >= r_period) {\n-                r_delta = 0;\n-                MetadataRepository.getInstance().flush();\n-                Utils.notifyFlush();\n-            }\n-            long left = (r_period - r_delta);\n-            if (left < 0) {\n-                left = 0;\n-            }\n-            streamDelta = r_delta;\n-            if (min == 0 || left < min) {\n-                min = left;\n-            }\n-        }\n-\n-        lastTimeMillis = now;\n-        return min;\n-    }\n-\n-    static void setFlushInterval(long millis) {\n-        \/\/ Don't accept shorter interval than 1 s.\n-        long interval = millis < 1000 ? 1000 : millis;\n-        boolean needNotify = interval < flushInterval;\n-        flushInterval = interval;\n-        if (needNotify) {\n-            synchronized (JVM.CHUNK_ROTATION_MONITOR) {\n-                JVM.CHUNK_ROTATION_MONITOR.notifyAll();\n-            }\n-        }\n-    }\n-}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/RequestEngine.java","additions":0,"deletions":311,"binary":false,"changes":311,"status":"deleted"},{"patch":"@@ -67,1 +67,0 @@\n-import jdk.jfr.internal.RequestEngine;\n@@ -69,1 +68,1 @@\n-\n+import jdk.jfr.internal.periodic.PeriodicEvents;\n@@ -151,4 +150,3 @@\n-\n-                RequestEngine.addTrustedJDKHook(ExceptionStatisticsEvent.class, emitExceptionStatistics);\n-                RequestEngine.addTrustedJDKHook(DirectBufferStatisticsEvent.class, emitDirectBufferStatistics);\n-                RequestEngine.addTrustedJDKHook(InitialSecurityPropertyEvent.class, emitInitialSecurityProperties);\n+                PeriodicEvents.addJDKEvent(ExceptionStatisticsEvent.class, emitExceptionStatistics);\n+                PeriodicEvents.addJDKEvent(DirectBufferStatisticsEvent.class, emitDirectBufferStatistics);\n+                PeriodicEvents.addJDKEvent(InitialSecurityPropertyEvent.class, emitInitialSecurityProperties);\n@@ -200,5 +198,5 @@\n-        RequestEngine.addTrustedJDKHook(ContainerConfigurationEvent.class, emitContainerConfiguration);\n-        RequestEngine.addTrustedJDKHook(ContainerCPUUsageEvent.class, emitContainerCPUUsage);\n-        RequestEngine.addTrustedJDKHook(ContainerCPUThrottlingEvent.class, emitContainerCPUThrottling);\n-        RequestEngine.addTrustedJDKHook(ContainerMemoryUsageEvent.class, emitContainerMemoryUsage);\n-        RequestEngine.addTrustedJDKHook(ContainerIOUsageEvent.class, emitContainerIOUsage);\n+        PeriodicEvents.addJDKEvent(ContainerConfigurationEvent.class, emitContainerConfiguration);\n+        PeriodicEvents.addJDKEvent(ContainerCPUUsageEvent.class, emitContainerCPUUsage);\n+        PeriodicEvents.addJDKEvent(ContainerCPUThrottlingEvent.class, emitContainerCPUThrottling);\n+        PeriodicEvents.addJDKEvent(ContainerMemoryUsageEvent.class, emitContainerMemoryUsage);\n+        PeriodicEvents.addJDKEvent(ContainerIOUsageEvent.class, emitContainerIOUsage);\n@@ -296,3 +294,3 @@\n-        RequestEngine.removeHook(emitExceptionStatistics);\n-        RequestEngine.removeHook(emitDirectBufferStatistics);\n-        RequestEngine.removeHook(emitInitialSecurityProperties);\n+        PeriodicEvents.removeEvent(emitExceptionStatistics);\n+        PeriodicEvents.removeEvent(emitDirectBufferStatistics);\n+        PeriodicEvents.removeEvent(emitInitialSecurityProperties);\n@@ -300,5 +298,5 @@\n-        RequestEngine.removeHook(emitContainerConfiguration);\n-        RequestEngine.removeHook(emitContainerCPUUsage);\n-        RequestEngine.removeHook(emitContainerCPUThrottling);\n-        RequestEngine.removeHook(emitContainerMemoryUsage);\n-        RequestEngine.removeHook(emitContainerIOUsage);\n+        PeriodicEvents.removeEvent(emitContainerConfiguration);\n+        PeriodicEvents.removeEvent(emitContainerCPUUsage);\n+        PeriodicEvents.removeEvent(emitContainerCPUThrottling);\n+        PeriodicEvents.removeEvent(emitContainerMemoryUsage);\n+        PeriodicEvents.removeEvent(emitContainerIOUsage);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/instrument\/JDKEvents.java","additions":17,"deletions":19,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -0,0 +1,76 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.internal.periodic;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+\/**\n+ * Class that holds periodic tasks that run at the same time.\n+ * <p>\n+ * For example, events with period 1s, 3s and 7s can run when the 1s event run,\n+ * not every time, but some of the time. An event with period 1.5s would not\n+ * belong to the same batch since it would need to run between the 1s interval.\n+ * <p>\n+ * This class should only be accessed from the periodic task thread.\n+ *\/\n+final class Batch {\n+    private final List<PeriodicTask> tasks = new ArrayList<>();\n+    private final long period;\n+    private long delta;\n+\n+    public Batch(long period) {\n+        this.period = period;\n+    }\n+\n+    public long getDelta() {\n+        return delta;\n+    }\n+\n+    public void setDelta(long delta) {\n+        this.delta = delta;\n+    }\n+\n+    public long getPeriod() {\n+        return period;\n+    }\n+\n+    public List<PeriodicTask> getTasks() {\n+        return tasks;\n+    }\n+\n+    public void add(PeriodicTask task) {\n+        task.setBatch(this);\n+        tasks.add(task);\n+    }\n+\n+    public void clear() {\n+        tasks.clear();\n+    }\n+\n+    public boolean isEmpty() {\n+        return tasks.isEmpty();\n+    }\n+}\n\\ No newline at end of file\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/periodic\/Batch.java","additions":76,"deletions":0,"binary":false,"changes":76,"status":"added"},{"patch":"@@ -0,0 +1,125 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.internal.periodic;\n+\n+import java.util.ArrayList;\n+import java.util.Comparator;\n+import java.util.List;\n+\n+import jdk.jfr.internal.LogLevel;\n+import jdk.jfr.internal.LogTag;\n+import jdk.jfr.internal.Logger;\n+\n+\/**\n+ * Class that groups periodic tasks into batches.\n+ * <p>\n+ * This class should only be accessed from the periodic task thread.\n+ *\/\n+final class BatchManager {\n+    private final List<Batch> batches = new ArrayList<>();\n+    private long iteration = -1;\n+\n+    public List<Batch> getBatches() {\n+        return batches;\n+    }\n+\n+    public long getIteration() {\n+        return iteration;\n+    }\n+\n+    public void refresh(long iteration, List<PeriodicTask> tasks) {\n+        groupTasksIntoBatches(tasks);\n+        this.iteration = iteration;\n+        logBatches();\n+    }\n+\n+    private void groupTasksIntoBatches(List<PeriodicTask> tasks) {\n+        \/\/ Batches are cleared instead of recreated to keep batch delta intact\n+        for (Batch batch : batches) {\n+            batch.clear();\n+        }\n+        for (PeriodicTask task : activeSortedTasks(tasks)) {\n+            if (task.isSchedulable()) {\n+                Batch batch = task.getBatch();\n+                \/\/ If new task, or period has changed, find new batch\n+                if (batch == null) {\n+                    batch = findBatch(task.getPeriod());\n+                }\n+                batch.add(task);\n+            }\n+        }\n+        \/\/ Remove unused batches\n+        batches.removeIf(Batch::isEmpty);\n+    }\n+\n+    private List<PeriodicTask> activeSortedTasks(List<PeriodicTask> unsorted) {\n+        \/\/ Update with latest periods\n+        List<PeriodicTask> tasks = new ArrayList<>(unsorted.size());\n+        for (PeriodicTask task : unsorted) {\n+            task.updatePeriod();\n+            if (task.getPeriod() != 0) {\n+                tasks.add(task);\n+            }\n+        }\n+        \/\/ Sort tasks by lowest period\n+        tasks.sort(Comparator.comparingLong(PeriodicTask::getPeriod));\n+        return tasks;\n+    }\n+\n+    private Batch findBatch(long period) {\n+        \/\/ All events with a period less than 1000 ms\n+        \/\/ get their own unique batch. The rationale for\n+        \/\/ this is to avoid a scenario where a user (mistakenly) specifies\n+        \/\/ period=1ms for an event and then all events end\n+        \/\/ up in that batch. It would work, but 99,9% of the time\n+        \/\/ the iteration would be pointless.\n+        for (Batch batch : batches) {\n+            long batchPeriod = batch.getPeriod();\n+            if ((period >= 1000 && batchPeriod >= 1000 && period % batchPeriod == 0) || (batchPeriod == period)) {\n+                return batch;\n+            }\n+        }\n+        Batch batch = new Batch(period);\n+        batches.add(batch);\n+        return batch;\n+    }\n+\n+    private void logBatches() {\n+        if (!Logger.shouldLog(LogTag.JFR, LogLevel.TRACE)) {\n+            return;\n+        }\n+        String prefix = \"Periodic task: settings iteration: \" + iteration + \", batch period: \";\n+        for (Batch batch : batches) {\n+            String batchPrefix = prefix + batch.getPeriod();\n+            for (PeriodicTask task : batch.getTasks()) {\n+                logTrace(batchPrefix + \", period: \" + task.getPeriod() + \", task: \" + task.getName());\n+            }\n+        }\n+    }\n+\n+    private void logTrace(String text) {\n+       Logger.log(LogTag.JFR_SYSTEM, LogLevel.TRACE, text);\n+    }\n+}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/periodic\/BatchManager.java","additions":125,"deletions":0,"binary":false,"changes":125,"status":"added"},{"patch":"@@ -0,0 +1,53 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.internal.periodic;\n+\n+import jdk.jfr.internal.PlatformEventType;\n+\n+\/**\n+ * Base class for periodic events.\n+ *\/\n+abstract class EventTask extends PeriodicTask {\n+    private final PlatformEventType eventType;\n+\n+    public EventTask(PlatformEventType eventType, LookupKey lookupKey) {\n+        super(lookupKey, eventType.getLogName());\n+        this.eventType = eventType;\n+    }\n+\n+    @Override\n+    public final boolean isSchedulable() {\n+        return eventType.isEnabled() && !eventType.isChunkTime();\n+    }\n+\n+    @Override\n+    protected final long fetchPeriod() {\n+        return eventType.getPeriod();\n+    }\n+\n+    public final PlatformEventType getEventType() {\n+        return eventType;\n+    }\n+}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/periodic\/EventTask.java","additions":53,"deletions":0,"binary":false,"changes":53,"status":"added"},{"patch":"@@ -0,0 +1,73 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.internal.periodic;\n+\n+import jdk.jfr.internal.JVM;\n+import jdk.jfr.internal.MetadataRepository;\n+import jdk.jfr.internal.Utils;\n+\n+\/**\n+ * Periodic task that flushes event data to disk.\n+ *<p>\n+ * The task is run once every second and after all other periodic events.\n+ * <p>\n+ * A flush interval of {@code Long.MAX_VALUE} means the event is disabled.\n+ *\/\n+final class FlushTask extends PeriodicTask {\n+    private volatile long flushInterval = Long.MAX_VALUE;\n+\n+    public FlushTask() {\n+        super(new LookupKey(new Object()), \"JFR: Flush Task\");\n+    }\n+\n+    @Override\n+    public void execute(long timestamp, PeriodicType periodicType) {\n+        MetadataRepository.getInstance().flush();\n+        Utils.notifyFlush();\n+    }\n+\n+    @Override\n+    public boolean isSchedulable() {\n+        return true;\n+    }\n+\n+    @Override\n+    protected long fetchPeriod() {\n+        return flushInterval;\n+    }\n+\n+    public void setInterval(long millis) {\n+        \/\/ Don't accept shorter interval than 1 s\n+        long interval = millis < 1000 ? 1000 : millis;\n+        boolean needsNotify = interval < flushInterval;\n+        flushInterval = interval;\n+        PeriodicEvents.setChanged();\n+        if (needsNotify) {\n+            synchronized (JVM.CHUNK_ROTATION_MONITOR) {\n+                JVM.CHUNK_ROTATION_MONITOR.notifyAll();\n+            }\n+        }\n+    }\n+}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/periodic\/FlushTask.java","additions":73,"deletions":0,"binary":false,"changes":73,"status":"added"},{"patch":"@@ -0,0 +1,54 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.internal.periodic;\n+\n+import jdk.jfr.Event;\n+\n+\/**\n+ * Periodic task that runs trusted code that doesn't require an access control\n+ * context.\n+ * <p>\n+ * This class can be removed once the Security Manager is no longer supported.\n+ *\/\n+final class JDKEventTask extends JavaEventTask {\n+\n+    public JDKEventTask(Class<? extends Event> eventClass, Runnable runnable) {\n+        super(eventClass, runnable);\n+        if (!getEventType().isJDK()) {\n+            throw new InternalError(\"Must be a JDK event\");\n+        }\n+        if (eventClass.getClassLoader() != null) {\n+            throw new SecurityException(\"Periodic task can only be registered for event classes that are loaded by the bootstrap class loader\");\n+        }\n+        if (runnable.getClass().getClassLoader() != null) {\n+            throw new SecurityException(\"Runnable class must be loaded by the bootstrap class loader\");\n+        }\n+    }\n+\n+    @Override\n+    public void execute(long timestamp, PeriodicType periodicType) {\n+        getRunnable().run();\n+    }\n+}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/periodic\/JDKEventTask.java","additions":54,"deletions":0,"binary":false,"changes":54,"status":"added"},{"patch":"@@ -0,0 +1,59 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.internal.periodic;\n+\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+import jdk.jfr.internal.JVM;\n+import jdk.jfr.internal.PlatformEventType;\n+\n+\/**\n+ * Task for periodic events defined in the JVM.\n+ * <p>\n+ * This class guarantees that only one event can execute in native at a time.\n+ *\/\n+final class JVMEventTask extends EventTask {\n+    \/\/ java.util.concurrent lock is used to avoid JavaMonitorBlocked event from\n+    \/\/ synchronized block.\n+    private static final Lock lock = new ReentrantLock();\n+\n+    public JVMEventTask(PlatformEventType eventType) {\n+        super(eventType, new LookupKey(eventType));\n+        if (!eventType.isJVM()) {\n+            throw new InternalError(\"Must be a JVM event\");\n+        }\n+    }\n+\n+    @Override\n+    public void execute(long timestamp, PeriodicType periodicType) {\n+        try {\n+            lock.lock();\n+            JVM.getJVM().emitEvent(getEventType().getId(), timestamp, periodicType.ordinal());\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/periodic\/JVMEventTask.java","additions":59,"deletions":0,"binary":false,"changes":59,"status":"added"},{"patch":"@@ -0,0 +1,54 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.internal.periodic;\n+\n+import jdk.jfr.Event;\n+import jdk.jfr.EventType;\n+import jdk.jfr.internal.MetadataRepository;\n+import jdk.jfr.internal.PlatformEventType;\n+import jdk.jfr.internal.PrivateAccess;\n+\/**\n+ * Base class for periodic Java events.\n+ *\/\n+abstract class JavaEventTask extends EventTask {\n+    private final Runnable runnable;\n+\n+    public JavaEventTask(Class<? extends Event> eventClass, Runnable runnable) {\n+        super(toPlatformEventType(eventClass), new LookupKey(runnable));\n+        this.runnable = runnable;\n+        if (getEventType().isJVM()) {\n+            throw new InternalError(\"Must not be a JVM event\");\n+        }\n+    }\n+\n+    private static PlatformEventType toPlatformEventType(Class<? extends Event> eventClass) {\n+        EventType eventType = MetadataRepository.getInstance().getEventType(eventClass);\n+        return PrivateAccess.getInstance().getPlatformEventType(eventType);\n+    }\n+\n+    protected final Runnable getRunnable() {\n+        return runnable;\n+    }\n+}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/periodic\/JavaEventTask.java","additions":54,"deletions":0,"binary":false,"changes":54,"status":"added"},{"patch":"@@ -0,0 +1,53 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.internal.periodic;\n+\n+\/**\n+ * Lookup key that can safely be used in a {@code Map}.\n+ * <p>\n+ * {@code Runnable} objects can't be used with {@code LinkedHashMap} as it\n+ * invokes {@code hashCode} and {@code equals}, for example when resizing the\n+ * {@code Map}, possibly in a non-secure context.\n+ * <p>\n+ * {@code IdentityHashMap} can't be used as it will not preserve order.\n+ *\/\n+final class LookupKey {\n+    private final Object object;\n+\n+    public LookupKey(Object object) {\n+        this.object = object;\n+    }\n+\n+    public int hashCode() {\n+        return System.identityHashCode(object);\n+    }\n+\n+    public boolean equals(Object that) {\n+        if (that instanceof LookupKey lookupKey) {\n+            return lookupKey.object == object;\n+        }\n+        return false;\n+    }\n+}\n\\ No newline at end of file\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/periodic\/LookupKey.java","additions":53,"deletions":0,"binary":false,"changes":53,"status":"added"},{"patch":"@@ -0,0 +1,208 @@\n+\/*\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.internal.periodic;\n+\n+import java.security.AccessControlContext;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+import jdk.jfr.Event;\n+import jdk.jfr.internal.JVM;\n+import jdk.jfr.internal.PlatformEventType;\n+\n+\/**\n+ * Class that runs and schedules tasks for periodic events.\n+ * <p>\n+ * Events can run at the beginning of a chunk rotation, at the end of a chunk\n+ * rotation or at a periodic interval.\n+ * <p>\n+ * Events with the same period runs in the same order as users added them.\n+ * Temporarily disabling events don't impact the order of execution.\n+ * <p>\n+ * A best effort is made to run events with different periods at the same time.\n+ * For example, an event that runs every two seconds executes half of the time\n+ * with the events that run every second.\n+ *\/\n+public final class PeriodicEvents {\n+    private static final TaskRepository taskRepository = new TaskRepository();\n+    private static final BatchManager batchManager = new BatchManager();\n+    private static final FlushTask flushTask = new FlushTask();\n+    private static final AtomicLong settingsIteration = new AtomicLong();\n+\n+    \/\/ State only to be read and modified by periodic task thread\n+    private static long lastTimeMillis;\n+\n+    public static void addJDKEvent(Class<? extends Event> eventClass, Runnable runnable) {\n+        taskRepository.add(new JDKEventTask(eventClass, runnable));\n+    }\n+\n+    public static void addJVMEvent(PlatformEventType eventType) {\n+        taskRepository.add(new JVMEventTask(eventType));\n+    }\n+\n+    public static void addUserEvent(@SuppressWarnings(\"removal\") AccessControlContext acc, Class<? extends Event> eventClass, Runnable runnable) {\n+        taskRepository.add(new UserEventTask(acc, eventClass, runnable));\n+    }\n+\n+    public static boolean removeEvent(Runnable runnable) {\n+        return taskRepository.removeTask(runnable);\n+    }\n+\n+    public static void doChunkBegin() {\n+        long timestamp = JVM.counterTime();\n+        for (EventTask task : taskRepository.getTasks()) {\n+            var eventType = task.getEventType();\n+            if (eventType.isEnabled() && eventType.isBeginChunk()) {\n+                task.run(timestamp, PeriodicType.BEGIN_CHUNK);\n+            }\n+        }\n+    }\n+\n+    public static void doChunkEnd() {\n+        long timestamp = JVM.counterTime();\n+        for (EventTask task : taskRepository.getTasks()) {\n+            var eventType = task.getEventType();\n+            if (eventType.isEnabled() && eventType.isEndChunk()) {\n+                task.run(timestamp, PeriodicType.END_CHUNK);\n+            }\n+        }\n+    }\n+\n+    \/\/ Only to be called from periodic task thread\n+    public static long doPeriodic() {\n+        try {\n+            return runPeriodic(JVM.counterTime());\n+        } catch (Throwable t) {\n+            t.printStackTrace();\n+            throw t;\n+        }\n+    }\n+\n+    \/\/ Code copied from prior native implementation\n+    private static long runPeriodic(long eventTimestamp) {\n+        long last = lastTimeMillis;\n+        \/\/ The interval for periodic events is typically at least 1 s, so\n+        \/\/ System.currentTimeMillis() is sufficient. JVM.counterTime() lacks\n+        \/\/ unit and has in the past been more unreliable.\n+        long now = System.currentTimeMillis();\n+        long min = 0;\n+        long delta = 0;\n+\n+        if (last == 0) {\n+            last = now;\n+        }\n+\n+        \/\/ time from then to now\n+        delta = now - last;\n+        if (delta < 0) {\n+            \/\/ to handle time adjustments\n+            \/\/ for example Daylight Savings\n+            lastTimeMillis = now;\n+            return 0;\n+        }\n+        long iteration = settingsIteration.get();\n+        if (iteration > batchManager.getIteration()) {\n+            List<PeriodicTask> tasks = new ArrayList<>();\n+            tasks.addAll(taskRepository.getTasks());\n+            tasks.add(flushTask);\n+            batchManager.refresh(iteration, tasks);\n+\n+        }\n+        boolean flush = false;\n+        for (Batch batch : batchManager.getBatches()) {\n+            long left = 0;\n+            long r_period = batch.getPeriod();\n+            long r_delta = batch.getDelta();\n+\n+            \/\/ add time elapsed.\n+            r_delta += delta;\n+\n+            \/\/ above threshold?\n+            if (r_delta >= r_period) {\n+                \/\/ Bug 9000556 - don't try to compensate\n+                \/\/ for wait > period\n+                r_delta = 0;\n+                for (PeriodicTask task : batch.getTasks()) {\n+                    task.tick();\n+                    if (task.shouldRun()) {\n+                        if (task instanceof FlushTask) {\n+                            flush = true;\n+                        } else {\n+                            task.run(eventTimestamp, PeriodicType.INTERVAL);\n+                        }\n+                    }\n+                }\n+            }\n+\n+            \/\/ calculate time left\n+            left = (r_period - r_delta);\n+\n+            \/*\n+             * nothing outside checks that a period is >= 0, so left can end up negative\n+             * here. ex. (r_period =(-1)) - (r_delta = 0) if it is, handle it.\n+             *\/\n+            if (left < 0) {\n+                left = 0;\n+            }\n+\n+            \/\/ assign delta back\n+            batch.setDelta(r_delta);\n+\n+            if (min == 0 || left < min) {\n+                min = left;\n+            }\n+        }\n+        if (flush) {\n+            flushTask.run(eventTimestamp, PeriodicType.INTERVAL);\n+        }\n+        lastTimeMillis = now;\n+        return min;\n+    }\n+\n+    \/**\n+     * Marks that a change has happened to a periodic event.\n+     * <p>\n+     * This method should be invoked if a periodic event has:\n+     * <ul>\n+     * <li>been added<\/li>\n+     * <li>been removed<\/li>\n+     * <li>been enabled\n+     * <li>been disabled<\/li>\n+     * <li>changed period<\/li>\n+     * <\/ul>\n+     * <p>\n+     * The periodic task thread will poll the changed state at least once every\n+     * second to see if a change has occurred. if that's the case, it will refresh\n+     * periodic tasks that need to be run.\n+     *\/\n+    public static void setChanged() {\n+        settingsIteration.incrementAndGet();\n+    }\n+\n+    public static void setFlushInterval(long millis) {\n+        flushTask.setInterval(millis);\n+    }\n+}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/periodic\/PeriodicEvents.java","additions":208,"deletions":0,"binary":false,"changes":208,"status":"added"},{"patch":"@@ -0,0 +1,127 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.internal.periodic;\n+\n+import jdk.jfr.internal.LogLevel;\n+import jdk.jfr.internal.LogTag;\n+import jdk.jfr.internal.Logger;\n+\n+\/**\n+ * Base class that holds time related information for a periodic task.\n+ * <p>\n+ * Class hierarchy for periodic tasks:\n+ * <pre>\n+ *               PeriodicTask\n+ *                \/        \\\n+ *               \/          \\\n+ *          EventTask    FlushTask\n+ *           \/     \\\n+ *          \/       \\\n+ * JVMEventTask   JavaEventTask\n+ *                \/         \\\n+ *               \/           \\\n+ *      UserEventTask     JDKEventTask\n+ * <\/pre>\n+ * <p>\n+ * State modifications should only be done from the periodic task thread.\n+ *\/\n+abstract class PeriodicTask {\n+    private final LookupKey lookupKey;\n+    private final String name;\n+    \/\/ State only to be modified by the periodic task thread\n+    private long counter;\n+    private long period;\n+    private Batch batch;\n+\n+    public PeriodicTask(LookupKey lookupKey, String name) {\n+        this.lookupKey = lookupKey;\n+        this.name = name;\n+    }\n+\n+    public abstract void execute(long timestamp, PeriodicType periodicType);\n+\n+    public abstract boolean isSchedulable();\n+\n+    protected abstract long fetchPeriod();\n+\n+    public final LookupKey getLookupKey() {\n+        return lookupKey;\n+    }\n+\n+    public final String getName() {\n+        return name;\n+    }\n+\n+    \/\/ Only to be called from periodic task thread\n+    public void setBatch(Batch batch) {\n+        this.batch = batch;\n+    }\n+\n+    \/\/ Only to be called from periodic task thread\n+    public Batch getBatch() {\n+        return batch;\n+    }\n+\n+    \/\/ Only to be called from periodic task thread\n+    public final void tick() {\n+        long increment = batch.getPeriod();\n+        if (period != 0) {\n+            counter = (counter + increment) % period;\n+        }\n+    }\n+\n+    \/\/ Only to be called from periodic task thread\n+    public final boolean shouldRun() {\n+        return counter == 0 && period != 0;\n+    }\n+\n+    \/\/ Only to be called from periodic task thread\n+    public final void updatePeriod() {\n+        long p = fetchPeriod();\n+        \/\/ Reset counter if new period\n+        if (p != period) {\n+            counter = 0;\n+            period = p;\n+            batch = null;\n+        }\n+    }\n+\n+    \/\/ Only to be called from periodic task thread\n+    public final long getPeriod() {\n+        return period;\n+    }\n+\n+    public final void run(long timestamp, PeriodicType periodicType) {\n+        try {\n+            execute(timestamp, periodicType);\n+        } catch (Throwable e) {\n+            \/\/ Prevent malicious user to propagate exception callback in the wrong context\n+            Logger.log(LogTag.JFR_SYSTEM, LogLevel.WARN, \"Exception occurred during execution of period task for \" + name);\n+        }\n+        if (Logger.shouldLog(LogTag.JFR_SYSTEM, LogLevel.DEBUG)) {\n+            Logger.log(LogTag.JFR_SYSTEM, LogLevel.DEBUG, \"Executed periodic task for \" + name);\n+        }\n+    }\n+}\n\\ No newline at end of file\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/periodic\/PeriodicTask.java","additions":127,"deletions":0,"binary":false,"changes":127,"status":"added"},{"patch":"@@ -0,0 +1,40 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.internal.periodic;\n+\n+enum PeriodicType {\n+    \/**\n+     * Event is running at the beginning of a chunk rotation.\n+     *\/\n+    BEGIN_CHUNK,\n+    \/**\n+     * Event is running at an interval, for example, once every second.\n+     *\/\n+    INTERVAL,\n+    \/**\n+     * Event is running at the end of a chunk rotation.\n+     *\/\n+    END_CHUNK\n+}\n\\ No newline at end of file\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/periodic\/PeriodicType.java","additions":40,"deletions":0,"binary":false,"changes":40,"status":"added"},{"patch":"@@ -0,0 +1,87 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.internal.periodic;\n+\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import jdk.jfr.internal.LogLevel;\n+import jdk.jfr.internal.LogTag;\n+import jdk.jfr.internal.Logger;\n+import jdk.jfr.internal.PlatformEventType;\n+\n+\/**\n+ * Class that holds periodic tasks.\n+ * <p>\n+ * This class is thread safe.\n+ *\/\n+final class TaskRepository {\n+    \/\/ Keeps periodic tasks in the order they were added by the user\n+    private final Map<LookupKey, EventTask> lookup = new LinkedHashMap<>();\n+\n+    \/\/ An immutable copy that can be used to iterate over tasks.\n+    private List<EventTask> cache;\n+\n+    public synchronized List<EventTask> getTasks() {\n+        if (cache == null) {\n+            cache = List.copyOf(lookup.values());\n+        }\n+        return cache;\n+    }\n+\n+    public synchronized boolean removeTask(Runnable r) {\n+        EventTask pt = lookup.remove(new LookupKey(r));\n+        if (pt != null) {\n+            var eventType = pt.getEventType();\n+            \/\/ Invokes PeriodicEvents.setChanged()\n+            eventType.setEventHook(false);\n+            logTask(\"Removed\", eventType);\n+            cache = null;\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    public synchronized void add(EventTask task) {\n+        if (lookup.containsKey(task.getLookupKey())) {\n+            throw new IllegalArgumentException(\"Hook has already been added\");\n+        }\n+        lookup.put(task.getLookupKey(), task);\n+        var eventType = task.getEventType();\n+        \/\/ Invokes PeriodicEvents.setChanged()\n+        eventType.setEventHook(true);\n+        logTask(\"Added\", eventType);\n+        cache = null;\n+    }\n+\n+    private void logTask(String action, PlatformEventType type) {\n+        if (type.isSystem()) {\n+            Logger.log(LogTag.JFR_SYSTEM, LogLevel.INFO, action + \" periodic task for \" + type.getLogName());\n+        } else {\n+            Logger.log(LogTag.JFR, LogLevel.INFO, action + \" periodic task for \" + type.getLogName());\n+        }\n+    }\n+}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/periodic\/TaskRepository.java","additions":87,"deletions":0,"binary":false,"changes":87,"status":"added"},{"patch":"@@ -0,0 +1,71 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.internal.periodic;\n+\n+import java.security.AccessControlContext;\n+import java.security.AccessController;\n+import java.security.PrivilegedAction;\n+import java.util.Objects;\n+\n+import jdk.jfr.Event;\n+import jdk.jfr.internal.LogLevel;\n+import jdk.jfr.internal.LogTag;\n+import jdk.jfr.internal.Logger;\n+\n+\/**\n+ * Class to be used with user-defined events that runs untrusted code.\n+ * <p>\n+ * This class can be removed once the Security Manager is no longer supported.\n+ *\/\n+final class UserEventTask extends JavaEventTask {\n+    @SuppressWarnings(\"removal\")\n+    private final AccessControlContext controlContext;\n+\n+    public UserEventTask(@SuppressWarnings(\"removal\") AccessControlContext controlContext, Class<? extends Event> eventClass, Runnable runnable) {\n+        super(eventClass, runnable);\n+        this.controlContext = Objects.requireNonNull(controlContext);\n+    }\n+\n+    @SuppressWarnings(\"removal\")\n+    @Override\n+    public void execute(long timestamp, PeriodicType periodicType) {\n+        AccessController.doPrivileged((PrivilegedAction<Void>) () -> {\n+            execute();\n+            return null;\n+        }, controlContext);\n+    }\n+\n+    private void execute() {\n+        try {\n+            getRunnable().run();\n+            if (Logger.shouldLog(LogTag.JFR_EVENT, LogLevel.DEBUG)) {\n+                Logger.log(LogTag.JFR_EVENT, LogLevel.DEBUG, \"Executed periodic task for \" + getEventType().getLogName());\n+            }\n+        } catch (Throwable t) {\n+            \/\/ Prevent malicious user to propagate exception callback in the wrong context\n+            Logger.log(LogTag.JFR_EVENT, LogLevel.WARN, \"Exception occurred during execution of period task for \" + getEventType().getLogName());\n+        }\n+    }\n+}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/periodic\/UserEventTask.java","additions":71,"deletions":0,"binary":false,"changes":71,"status":"added"}]}