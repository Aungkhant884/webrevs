{"files":[{"patch":"@@ -4,1 +4,0 @@\n-import java.util.ArrayList;\n@@ -6,1 +5,0 @@\n-import java.util.List;\n@@ -143,0 +141,3 @@\n+        System.out.println(\"context used words \" + usageMeasured + \", committed words \" + committedMeasured\n+                + \".\");\n+\n","filename":"test\/hotspot\/jtreg\/runtime\/Metaspace\/elastic\/MetaspaceTestContext.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -86,0 +86,13 @@\n+        \/\/ At this point a large number of Arenas will have died (see above), but we probably still have\n+        \/\/  some live arenas left. The chunk freelist will be full of free chunks. Maybe a bit fragmented,\n+        \/\/  with a healthy mixture of larger and smaller chunks, since we still have live arenas.\n+        \/\/ These chunks are all committed still, since we did nothing to reclaim the storage. We now purge\n+        \/\/  the context manually to uncommit those chunks, in order to get a realistic number for\n+        \/\/  committed words (see checkStatistics()).\n+        \/\/ Note: In real metaspace, this happens as part of the same GC which removes class loaders and\n+        \/\/  frees their metaspace arenas. All within CLDG::purge(). But since this test isolates the metaspace\n+        \/\/  context and does test it separately, GC and CLDG are not involved here. We need to purge manually.\n+        \/\/\n+        \/\/ Purging uncommits all free chunks >= 64K\/16K (MetaspaceReclaimPolicy=standard\/aggressive).\n+        context.purge();\n+\n","filename":"test\/hotspot\/jtreg\/runtime\/Metaspace\/elastic\/MetaspaceTestManyArenasManyThreads.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"}]}