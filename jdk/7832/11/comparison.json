{"files":[{"patch":"@@ -876,0 +876,2 @@\n+    case 0x10: \/\/ movups\n+    case 0x11: \/\/ movups\n@@ -2541,0 +2543,11 @@\n+void Assembler::movddup(XMMRegister dst, Address src) {\n+  NOT_LP64(assert(VM_Version::supports_sse3(), \"\"));\n+  InstructionMark im(this);\n+  InstructionAttr attributes(AVX_128bit, \/* rex_w *\/ VM_Version::supports_evex(), \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_DUP, \/* input_size_in_bits *\/ EVEX_64bit);\n+  attributes.set_rex_vex_w_reverted();\n+  simd_prefix(dst, xnoreg, src, VEX_SIMD_F2, VEX_OPCODE_0F, &attributes);\n+  emit_int8(0x12);\n+  emit_operand(dst, src);\n+}\n+\n@@ -2545,0 +2558,1 @@\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_DUP, \/* input_size_in_bits *\/ EVEX_64bit);\n@@ -3485,0 +3499,40 @@\n+void Assembler::movups(XMMRegister dst, Address src) {\n+  NOT_LP64(assert(VM_Version::supports_sse(), \"\"));\n+  InstructionMark im(this);\n+  InstructionAttr attributes(AVX_128bit, \/* rex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FVM, \/* input_size_in_bits *\/ EVEX_32bit);\n+  simd_prefix(dst, xnoreg, src, VEX_SIMD_NONE, VEX_OPCODE_0F, &attributes);\n+  emit_int8(0x10);\n+  emit_operand(dst, src);\n+}\n+\n+void Assembler::vmovups(XMMRegister dst, Address src, int vector_len) {\n+  assert(vector_len == AVX_512bit ? VM_Version::supports_evex() : VM_Version::supports_avx(), \"\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(vector_len, \/* rex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FVM, \/* input_size_in_bits *\/ EVEX_32bit);\n+  simd_prefix(dst, xnoreg, src, VEX_SIMD_NONE, VEX_OPCODE_0F, &attributes);\n+  emit_int8(0x10);\n+  emit_operand(dst, src);\n+}\n+\n+void Assembler::movups(Address dst, XMMRegister src) {\n+  NOT_LP64(assert(VM_Version::supports_sse(), \"\"));\n+  InstructionMark im(this);\n+  InstructionAttr attributes(AVX_128bit, \/* rex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FVM, \/* input_size_in_bits *\/ EVEX_32bit);\n+  simd_prefix(src, xnoreg, dst, VEX_SIMD_NONE, VEX_OPCODE_0F, &attributes);\n+  emit_int8(0x11);\n+  emit_operand(src, dst);\n+}\n+\n+void Assembler::vmovups(Address dst, XMMRegister src, int vector_len) {\n+  assert(vector_len == AVX_512bit ? VM_Version::supports_evex() : VM_Version::supports_avx(), \"\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(vector_len, \/* rex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ true);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_FVM, \/* input_size_in_bits *\/ EVEX_32bit);\n+  simd_prefix(src, xnoreg, dst, VEX_SIMD_NONE, VEX_OPCODE_0F, &attributes);\n+  emit_int8(0x11);\n+  emit_operand(src, dst);\n+}\n+\n@@ -5136,1 +5190,1 @@\n-void Assembler::pshufpd(XMMRegister dst, XMMRegister src, int imm8) {\n+void Assembler::shufpd(XMMRegister dst, XMMRegister src, int imm8) {\n@@ -5144,1 +5198,1 @@\n-void Assembler::vpshufpd(XMMRegister dst, XMMRegister nds, XMMRegister src, int imm8, int vector_len) {\n+void Assembler::vshufpd(XMMRegister dst, XMMRegister nds, XMMRegister src, int imm8, int vector_len) {\n@@ -5151,1 +5205,1 @@\n-void Assembler::pshufps(XMMRegister dst, XMMRegister src, int imm8) {\n+void Assembler::shufps(XMMRegister dst, XMMRegister src, int imm8) {\n@@ -5159,1 +5213,1 @@\n-void Assembler::vpshufps(XMMRegister dst, XMMRegister nds, XMMRegister src, int imm8, int vector_len) {\n+void Assembler::vshufps(XMMRegister dst, XMMRegister nds, XMMRegister src, int imm8, int vector_len) {\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.cpp","additions":58,"deletions":4,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -1480,0 +1480,1 @@\n+  void movddup(XMMRegister dst, Address src);\n@@ -1651,0 +1652,5 @@\n+  void movups(XMMRegister dst, Address src);\n+  void vmovups(XMMRegister dst, Address src, int vector_len);\n+  void movups(Address dst, XMMRegister src);\n+  void vmovups(Address dst, XMMRegister src, int vector_len);\n+\n@@ -1930,4 +1936,4 @@\n-  void pshufps(XMMRegister, XMMRegister, int);\n-  void pshufpd(XMMRegister, XMMRegister, int);\n-  void vpshufps(XMMRegister, XMMRegister, XMMRegister, int, int);\n-  void vpshufpd(XMMRegister, XMMRegister, XMMRegister, int, int);\n+  void shufps(XMMRegister, XMMRegister, int);\n+  void shufpd(XMMRegister, XMMRegister, int);\n+  void vshufps(XMMRegister, XMMRegister, XMMRegister, int, int);\n+  void vshufpd(XMMRegister, XMMRegister, XMMRegister, int, int);\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.hpp","additions":10,"deletions":4,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -1646,6 +1646,6 @@\n-  case 4:  movdl(dst, src);   break;\n-  case 8:  movq(dst, src);    break;\n-  case 16: movdqu(dst, src);  break;\n-  case 32: vmovdqu(dst, src); break;\n-  case 64: evmovdquq(dst, src, Assembler::AVX_512bit); break;\n-  default: ShouldNotReachHere();\n+    case 4:  movdl(dst, src);   break;\n+    case 8:  movq(dst, src);    break;\n+    case 16: movdqu(dst, src);  break;\n+    case 32: vmovdqu(dst, src); break;\n+    case 64: evmovdqul(dst, src, Assembler::AVX_512bit); break;\n+    default: ShouldNotReachHere();\n@@ -2320,1 +2320,1 @@\n-        pshufps(dst, dst, eindex);\n+        shufps(dst, dst, eindex);\n@@ -2322,1 +2322,1 @@\n-        vpshufps(dst, src, src, eindex, Assembler::AVX_128bit);\n+        vshufps(dst, src, src, eindex, Assembler::AVX_128bit);\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2735,0 +2735,9 @@\n+void MacroAssembler::movddup(XMMRegister dst, AddressLiteral src, Register rscratch) {\n+  if (reachable(src)) {\n+    Assembler::movddup(dst, as_Address(src));\n+  } else {\n+    lea(rscratch, src);\n+    Assembler::movddup(dst, Address(rscratch, 0));\n+  }\n+}\n+\n@@ -3291,3 +3300,7 @@\n-void MacroAssembler::vpbroadcastw(XMMRegister dst, XMMRegister src, int vector_len) {\n-  assert(((dst->encoding() < 16 && src->encoding() < 16) || VM_Version::supports_avx512vlbw()),\"XMM register should be 0-15\");\n-  Assembler::vpbroadcastw(dst, src, vector_len);\n+void MacroAssembler::vpbroadcastd(XMMRegister dst, AddressLiteral src, int vector_len, Register rscratch) {\n+  if (reachable(src)) {\n+    Assembler::vpbroadcastd(dst, as_Address(src), vector_len);\n+  } else {\n+    lea(rscratch, src);\n+    Assembler::vpbroadcastd(dst, Address(rscratch, 0), vector_len);\n+  }\n@@ -3314,0 +3327,9 @@\n+void MacroAssembler::vbroadcastss(XMMRegister dst, AddressLiteral src, int vector_len, Register rscratch) {\n+  if (reachable(src)) {\n+    Assembler::vbroadcastss(dst, as_Address(src), vector_len);\n+  } else {\n+    lea(rscratch, src);\n+    Assembler::vbroadcastss(dst, Address(rscratch, 0), vector_len);\n+  }\n+}\n+\n@@ -4367,0 +4389,2 @@\n+    \/\/ Only pcmpeq has dependency breaking treatment (i.e the execution can begin without\n+    \/\/ waiting for the previous result on dst), not vpcmpeqd, so just use vpternlog\n@@ -4368,0 +4392,2 @@\n+  } else if (VM_Version::supports_avx()) {\n+    vpcmpeqd(dst, dst, dst, vector_len);\n@@ -4369,2 +4395,2 @@\n-    assert(UseAVX > 0, \"\");\n-    vpcmpeqb(dst, dst, dst, vector_len);\n+    assert(VM_Version::supports_sse2(), \"\");\n+    pcmpeqd(dst, dst);\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":31,"deletions":5,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -1125,0 +1125,6 @@\n+  using Assembler::vbroadcastsd;\n+  void vbroadcastsd(XMMRegister dst, AddressLiteral src, int vector_len, Register rscratch = rscratch1);\n+\n+  using Assembler::vbroadcastss;\n+  void vbroadcastss(XMMRegister dst, AddressLiteral src, int vector_len, Register rscratch = rscratch1);\n+\n@@ -1161,0 +1167,5 @@\n+  using Assembler::movddup;\n+  void movddup(XMMRegister dst, AddressLiteral src, Register rscratch = rscratch1);\n+  using Assembler::vmovddup;\n+  void vmovddup(XMMRegister dst, AddressLiteral src, int vector_len, Register rscratch = rscratch1);\n+\n@@ -1168,1 +1179,0 @@\n-\n@@ -1240,3 +1250,0 @@\n-  using Assembler::vmovddup;\n-  void vmovddup(XMMRegister dst, AddressLiteral src, int vector_len, Register rscratch = rscratch1);\n-\n@@ -1348,2 +1355,2 @@\n-  void vpbroadcastw(XMMRegister dst, XMMRegister src, int vector_len);\n-  void vpbroadcastw(XMMRegister dst, Address src, int vector_len) { Assembler::vpbroadcastw(dst, src, vector_len); }\n+  using Assembler::vpbroadcastd;\n+  void vpbroadcastd(XMMRegister dst, AddressLiteral src, int vector_len, Register rscratch = rscratch1);\n@@ -1351,2 +1358,1 @@\n-  using Assembler::vbroadcastsd;\n-  void vbroadcastsd(XMMRegister dst, AddressLiteral src, int vector_len, Register rscratch = rscratch1);\n+  using Assembler::vpbroadcastq;\n@@ -1354,4 +1360,0 @@\n-  void vpbroadcastq(XMMRegister dst, XMMRegister src, int vector_len) { Assembler::vpbroadcastq(dst, src, vector_len); }\n-  void vpbroadcastq(XMMRegister dst, Address src, int vector_len) { Assembler::vpbroadcastq(dst, src, vector_len); }\n-\n-\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":14,"deletions":12,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -4110,1 +4110,2 @@\n-instruct ReplB_reg(vec dst, rRegI src) %{\n+instruct vReplB_reg(vec dst, rRegI src) %{\n+  predicate(UseAVX >= 2);\n@@ -4115,0 +4116,1 @@\n+    int vlen_enc = vector_length_encoding(this);\n@@ -4117,1 +4119,0 @@\n-      int vlen_enc = vector_length_encoding(this);\n@@ -4119,4 +4120,0 @@\n-    } else if (VM_Version::supports_avx2()) {\n-      int vlen_enc = vector_length_encoding(this);\n-      __ movdl($dst$$XMMRegister, $src$$Register);\n-      __ vpbroadcastb($dst$$XMMRegister, $dst$$XMMRegister, vlen_enc);\n@@ -4125,9 +4122,1 @@\n-      __ punpcklbw($dst$$XMMRegister, $dst$$XMMRegister);\n-      __ pshuflw($dst$$XMMRegister, $dst$$XMMRegister, 0x00);\n-      if (vlen >= 16) {\n-        __ punpcklqdq($dst$$XMMRegister, $dst$$XMMRegister);\n-        if (vlen >= 32) {\n-          assert(vlen == 32, \"sanity\");\n-          __ vinserti128_high($dst$$XMMRegister, $dst$$XMMRegister);\n-        }\n-      }\n+      __ vpbroadcastb($dst$$XMMRegister, $dst$$XMMRegister, vlen_enc);\n@@ -4139,4 +4128,4 @@\n-instruct ReplB_mem(vec dst, memory mem) %{\n-  predicate(VM_Version::supports_avx2());\n-  match(Set dst (ReplicateB (LoadB mem)));\n-  format %{ \"replicateB $dst,$mem\" %}\n+instruct ReplB_reg(vec dst, rRegI src) %{\n+  predicate(UseAVX < 2);\n+  match(Set dst (ReplicateB src));\n+  format %{ \"replicateB $dst,$src\" %}\n@@ -4144,2 +4133,8 @@\n-    int vlen_enc = vector_length_encoding(this);\n-    __ vpbroadcastb($dst$$XMMRegister, $mem$$Address, vlen_enc);\n+    uint vlen = Matcher::vector_length(this);\n+    __ movdl($dst$$XMMRegister, $src$$Register);\n+    __ punpcklbw($dst$$XMMRegister, $dst$$XMMRegister);\n+    __ pshuflw($dst$$XMMRegister, $dst$$XMMRegister, 0x00);\n+    if (vlen >= 16) {\n+      assert(vlen == 16, \"\");\n+      __ punpcklqdq($dst$$XMMRegister, $dst$$XMMRegister);\n+    }\n@@ -4150,3 +4145,4 @@\n-instruct ReplB_imm(vec dst, immI con) %{\n-  match(Set dst (ReplicateB con));\n-  format %{ \"replicateB $dst,$con\" %}\n+instruct ReplB_mem(vec dst, memory mem) %{\n+  predicate(UseAVX >= 2);\n+  match(Set dst (ReplicateB (LoadB mem)));\n+  format %{ \"replicateB $dst,$mem\" %}\n@@ -4154,2 +4150,2 @@\n-    InternalAddress addr = $constantaddress(T_BYTE, vreplicate_imm(T_BYTE, $con$$constant, Matcher::vector_length(this)));\n-    __ load_vector($dst$$XMMRegister, addr, Matcher::vector_length_in_bytes(this));\n+    int vlen_enc = vector_length_encoding(this);\n+    __ vpbroadcastb($dst$$XMMRegister, $mem$$Address, vlen_enc);\n@@ -4162,1 +4158,2 @@\n-instruct ReplS_reg(vec dst, rRegI src) %{\n+instruct vReplS_reg(vec dst, rRegI src) %{\n+  predicate(UseAVX >= 2);\n@@ -4167,0 +4164,1 @@\n+    int vlen_enc = vector_length_encoding(this);\n@@ -4169,1 +4167,0 @@\n-      int vlen_enc = vector_length_encoding(this);\n@@ -4171,4 +4168,0 @@\n-    } else if (VM_Version::supports_avx2()) {\n-      int vlen_enc = vector_length_encoding(this);\n-      __ movdl($dst$$XMMRegister, $src$$Register);\n-      __ vpbroadcastw($dst$$XMMRegister, $dst$$XMMRegister, vlen_enc);\n@@ -4177,8 +4170,1 @@\n-      __ pshuflw($dst$$XMMRegister, $dst$$XMMRegister, 0x00);\n-      if (vlen >= 8) {\n-        __ punpcklqdq($dst$$XMMRegister, $dst$$XMMRegister);\n-        if (vlen >= 16) {\n-          assert(vlen == 16, \"sanity\");\n-          __ vinserti128_high($dst$$XMMRegister, $dst$$XMMRegister);\n-        }\n-      }\n+      __ vpbroadcastw($dst$$XMMRegister, $dst$$XMMRegister, vlen_enc);\n@@ -4190,4 +4176,4 @@\n-instruct ReplS_mem(vec dst, memory mem) %{\n-  predicate(VM_Version::supports_avx2());\n-  match(Set dst (ReplicateS (LoadS mem)));\n-  format %{ \"replicateS $dst,$mem\" %}\n+instruct ReplS_reg(vec dst, rRegI src) %{\n+  predicate(UseAVX < 2);\n+  match(Set dst (ReplicateS src));\n+  format %{ \"replicateS $dst,$src\" %}\n@@ -4195,0 +4181,1 @@\n+    uint vlen = Matcher::vector_length(this);\n@@ -4196,1 +4183,6 @@\n-    __ vpbroadcastw($dst$$XMMRegister, $mem$$Address, vlen_enc);\n+    __ movdl($dst$$XMMRegister, $src$$Register);\n+    __ pshuflw($dst$$XMMRegister, $dst$$XMMRegister, 0x00);\n+    if (vlen >= 8) {\n+      assert(vlen == 8, \"\");\n+      __ punpcklqdq($dst$$XMMRegister, $dst$$XMMRegister);\n+    }\n@@ -4201,3 +4193,4 @@\n-instruct ReplS_imm(vec dst, immI con) %{\n-  match(Set dst (ReplicateS con));\n-  format %{ \"replicateS $dst,$con\" %}\n+instruct ReplS_mem(vec dst, memory mem) %{\n+  predicate(UseAVX >= 2);\n+  match(Set dst (ReplicateS (LoadS mem)));\n+  format %{ \"replicateS $dst,$mem\" %}\n@@ -4205,2 +4198,2 @@\n-    InternalAddress addr = $constantaddress(T_SHORT, vreplicate_imm(T_SHORT, $con$$constant, Matcher::vector_length(this)));\n-    __ load_vector($dst$$XMMRegister, addr, Matcher::vector_length_in_bytes(this));\n+    int vlen_enc = vector_length_encoding(this);\n+    __ vpbroadcastw($dst$$XMMRegister, $mem$$Address, vlen_enc);\n@@ -4218,0 +4211,1 @@\n+    int vlen_enc = vector_length_encoding(this);\n@@ -4219,1 +4213,0 @@\n-      int vlen_enc = vector_length_encoding(this);\n@@ -4222,1 +4215,0 @@\n-      int vlen_enc = vector_length_encoding(this);\n@@ -4228,4 +4220,0 @@\n-      if (vlen >= 8) {\n-        assert(vlen == 8, \"sanity\");\n-        __ vinserti128_high($dst$$XMMRegister, $dst$$XMMRegister);\n-      }\n@@ -4241,2 +4229,4 @@\n-    uint vlen = Matcher::vector_length(this);\n-    if (vlen <= 4) {\n+    int vlen_enc = vector_length_encoding(this);\n+    if (VM_Version::supports_avx()) {\n+      __ vbroadcastss($dst$$XMMRegister, $mem$$Address, vlen_enc);\n+    } else {\n@@ -4245,4 +4235,0 @@\n-    } else {\n-      assert(VM_Version::supports_avx2(), \"sanity\");\n-      int vlen_enc = vector_length_encoding(this);\n-      __ vpbroadcastd($dst$$XMMRegister, $mem$$Address, vlen_enc);\n@@ -4255,0 +4241,2 @@\n+  match(Set dst (ReplicateB con));\n+  match(Set dst (ReplicateS con));\n@@ -4258,2 +4246,16 @@\n-    InternalAddress addr = $constantaddress(T_INT, vreplicate_imm(T_INT, $con$$constant, Matcher::vector_length(this)));\n-    __ load_vector($dst$$XMMRegister, addr, Matcher::vector_length_in_bytes(this));\n+    InternalAddress addr = $constantaddress(Matcher::vector_element_basic_type(this),\n+        vreplicate_imm(Matcher::vector_element_basic_type(this), $con$$constant,\n+            (VM_Version::supports_sse3() ? (VM_Version::supports_avx() ? 4 : 8) : 8) \/\n+                type2aelembytes(Matcher::vector_element_basic_type(this))));\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    int vlen_enc = vector_length_encoding(this);\n+    if (VM_Version::supports_avx()) {\n+      __ vbroadcastss($dst$$XMMRegister, addr, vlen_enc);\n+    } else if (VM_Version::supports_sse3()) {\n+      __ movddup($dst$$XMMRegister, addr);\n+    } else {\n+      __ movq($dst$$XMMRegister, addr);\n+      if (Matcher::vector_length_in_bytes(this) >= 16) {\n+        __ punpcklqdq($dst$$XMMRegister, $dst$$XMMRegister);\n+      }\n+    }\n@@ -4271,5 +4273,2 @@\n-    uint vsize = Matcher::vector_length_in_bytes(this);\n-    if (vsize <= 16) {\n-      __ pxor($dst$$XMMRegister, $dst$$XMMRegister);\n-    } else {\n-      int vlen_enc = vector_length_encoding(this);\n+    int vlen_enc = vector_length_encoding(this);\n+    if (VM_Version::supports_evex() && !VM_Version::supports_avx512vl()) {\n@@ -4277,0 +4276,2 @@\n+    } else {\n+      __ pxor($dst$$XMMRegister, $dst$$XMMRegister);\n@@ -4283,1 +4284,1 @@\n-  predicate(UseAVX > 0 && Matcher::vector_length_in_bytes(n) >= 16);\n+  predicate(UseSSE >= 2);\n@@ -4287,1 +4288,0 @@\n-  effect(TEMP dst);\n@@ -4304,6 +4304,3 @@\n-    uint vlen = Matcher::vector_length(this);\n-    if (vlen == 2) {\n-      __ movdq($dst$$XMMRegister, $src$$Register);\n-      __ punpcklqdq($dst$$XMMRegister, $dst$$XMMRegister);\n-    } else if (vlen == 8 || VM_Version::supports_avx512vl()) { \/\/ AVX512VL for <512bit operands\n-      int vlen_enc = vector_length_encoding(this);\n+    int vlen = Matcher::vector_length(this);\n+    int vlen_enc = vector_length_encoding(this);\n+    if (vlen == 8 || VM_Version::supports_avx512vl()) { \/\/ AVX512VL for <512bit operands\n@@ -4312,2 +4309,0 @@\n-      assert(vlen == 4, \"sanity\");\n-      int vlen_enc = vector_length_encoding(this);\n@@ -4317,1 +4312,0 @@\n-      assert(vlen == 4, \"sanity\");\n@@ -4320,1 +4314,0 @@\n-      __ vinserti128_high($dst$$XMMRegister, $dst$$XMMRegister);\n@@ -4385,2 +4378,6 @@\n-    uint vlen = Matcher::vector_length(this);\n-    if (vlen == 2) {\n+    int vlen_enc = vector_length_encoding(this);\n+    if (VM_Version::supports_avx2()) {\n+      __ vpbroadcastq($dst$$XMMRegister, $mem$$Address, vlen_enc);\n+    } else if (VM_Version::supports_sse3()) {\n+      __ movddup($dst$$XMMRegister, $mem$$Address);\n+    } else {\n@@ -4389,4 +4386,0 @@\n-    } else {\n-      assert(VM_Version::supports_avx2(), \"sanity\");\n-      int vlen_enc = vector_length_encoding(this);\n-      __ vpbroadcastq($dst$$XMMRegister, $mem$$Address, vlen_enc);\n@@ -4403,2 +4396,12 @@\n-    InternalAddress addr = $constantaddress(T_LONG, vreplicate_imm(T_LONG, $con$$constant, Matcher::vector_length(this)));\n-    __ load_vector($dst$$XMMRegister, addr, Matcher::vector_length_in_bytes(this));\n+    InternalAddress addr = $constantaddress(T_LONG, vreplicate_imm(T_LONG, $con$$constant, 1));\n+    int vlen_enc = vector_length_encoding(this);\n+    if (VM_Version::supports_avx2()) {\n+      __ vpbroadcastq($dst$$XMMRegister, addr, vlen_enc);\n+    } else if (VM_Version::supports_sse3()) {\n+      __ movddup($dst$$XMMRegister, addr);\n+    } else {\n+      __ movq($dst$$XMMRegister, addr);\n+      if (Matcher::vector_length_in_bytes(this) >= 16) {\n+        __ punpcklqdq($dst$$XMMRegister, $dst$$XMMRegister);\n+      }\n+    }\n@@ -4413,5 +4416,2 @@\n-    int vlen = Matcher::vector_length(this);\n-    if (vlen == 2) {\n-      __ pxor($dst$$XMMRegister, $dst$$XMMRegister);\n-    } else {\n-      int vlen_enc = vector_length_encoding(this);\n+    int vlen_enc = vector_length_encoding(this);\n+    if (VM_Version::supports_evex() && !VM_Version::supports_avx512vl()) {\n@@ -4419,0 +4419,2 @@\n+    } else {\n+      __ pxor($dst$$XMMRegister, $dst$$XMMRegister);\n@@ -4425,1 +4427,1 @@\n-  predicate(UseAVX > 0);\n+  predicate(UseSSE >= 2);\n@@ -4427,1 +4429,0 @@\n-  effect(TEMP dst);\n@@ -4438,1 +4439,2 @@\n-instruct ReplF_reg(vec dst, vlRegF src) %{\n+instruct vReplF_reg(vec dst, vlRegF src) %{\n+  predicate(UseAVX > 0);\n@@ -4443,0 +4445,1 @@\n+    int vlen_enc = vector_length_encoding(this);\n@@ -4444,3 +4447,2 @@\n-      __ pshufd($dst$$XMMRegister, $src$$XMMRegister, 0x00);\n-   } else if (VM_Version::supports_avx2()) {\n-      int vlen_enc = vector_length_encoding(this);\n+      __ vpermilps($dst$$XMMRegister, $src$$XMMRegister, 0x00, Assembler::AVX_128bit);\n+    } else if (VM_Version::supports_avx2()) {\n@@ -4450,1 +4452,1 @@\n-      __ pshufd($dst$$XMMRegister, $src$$XMMRegister, 0x00);\n+      __ vpermilps($dst$$XMMRegister, $src$$XMMRegister, 0x00, Assembler::AVX_128bit);\n@@ -4457,0 +4459,10 @@\n+instruct ReplF_reg(vec dst, vlRegF src) %{\n+  predicate(UseAVX == 0);\n+  match(Set dst (ReplicateF src));\n+  format %{ \"replicateF $dst,$src\" %}\n+  ins_encode %{\n+    __ pshufd($dst$$XMMRegister, $src$$XMMRegister, 0x00);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n@@ -4458,0 +4470,1 @@\n+  predicate(UseAVX > 0);\n@@ -4461,9 +4474,2 @@\n-    uint vlen = Matcher::vector_length(this);\n-    if (vlen <= 4) {\n-      __ movdl($dst$$XMMRegister, $mem$$Address);\n-      __ pshufd($dst$$XMMRegister, $dst$$XMMRegister, 0x00);\n-    } else {\n-      assert(VM_Version::supports_avx(), \"sanity\");\n-      int vlen_enc = vector_length_encoding(this);\n-      __ vbroadcastss($dst$$XMMRegister, $mem$$Address, vlen_enc);\n-    }\n+    int vlen_enc = vector_length_encoding(this);\n+    __ vbroadcastss($dst$$XMMRegister, $mem$$Address, vlen_enc);\n@@ -4479,2 +4485,13 @@\n-    InternalAddress addr = $constantaddress(T_FLOAT, vreplicate_imm(T_FLOAT, $con$$constant, Matcher::vector_length(this)));\n-    __ load_vector($dst$$XMMRegister, addr, Matcher::vector_length_in_bytes(this));\n+    InternalAddress addr = $constantaddress(T_FLOAT, vreplicate_imm(T_FLOAT, $con$$constant,\n+        VM_Version::supports_sse3() ? (VM_Version::supports_avx() ? 1 : 2) : 2));\n+    int vlen_enc = vector_length_encoding(this);\n+    if (VM_Version::supports_avx()) {\n+      __ vbroadcastss($dst$$XMMRegister, addr, vlen_enc);\n+    } else if (VM_Version::supports_sse3()) {\n+      __ movddup($dst$$XMMRegister, addr);\n+    } else {\n+      __ movq($dst$$XMMRegister, addr);\n+      if (Matcher::vector_length_in_bytes(this) >= 16) {\n+        __ punpcklqdq($dst$$XMMRegister, $dst$$XMMRegister);\n+      }\n+    }\n@@ -4489,3 +4506,3 @@\n-    uint vlen = Matcher::vector_length(this);\n-    if (vlen <= 4) {\n-      __ xorps($dst$$XMMRegister, $dst$$XMMRegister);\n+    int vlen_enc = vector_length_encoding(this);\n+    if (VM_Version::supports_evex() && !VM_Version::supports_avx512vldq()) {\n+      __ vpxor($dst$$XMMRegister, $dst$$XMMRegister, $dst$$XMMRegister, vlen_enc);\n@@ -4493,2 +4510,1 @@\n-      int vlen_enc = vector_length_encoding(this);\n-      __ vpxor($dst$$XMMRegister,$dst$$XMMRegister, $dst$$XMMRegister, vlen_enc); \/\/ 512bit vxorps requires AVX512DQ\n+      __ xorps($dst$$XMMRegister, $dst$$XMMRegister);\n@@ -4503,1 +4519,2 @@\n-instruct ReplD_reg(vec dst, vlRegD src) %{\n+instruct vReplD_reg(vec dst, vlRegD src) %{\n+  predicate(UseSSE >= 3);\n@@ -4508,2 +4525,3 @@\n-    if (vlen == 2) {\n-      __ pshufd($dst$$XMMRegister, $src$$XMMRegister, 0x44);\n+    int vlen_enc = vector_length_encoding(this);\n+    if (vlen <= 2) {\n+      __ movddup($dst$$XMMRegister, $src$$XMMRegister);\n@@ -4511,1 +4529,0 @@\n-      int vlen_enc = vector_length_encoding(this);\n@@ -4515,1 +4532,1 @@\n-      __ pshufd($dst$$XMMRegister, $src$$XMMRegister, 0x44);\n+      __ movddup($dst$$XMMRegister, $src$$XMMRegister);\n@@ -4522,0 +4539,10 @@\n+instruct ReplD_reg(vec dst, vlRegD src) %{\n+  predicate(UseSSE < 3);\n+  match(Set dst (ReplicateD src));\n+  format %{ \"replicateD $dst,$src\" %}\n+  ins_encode %{\n+    __ pshufd($dst$$XMMRegister, $src$$XMMRegister, 0x44);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n@@ -4523,0 +4550,1 @@\n+  predicate(UseSSE >= 3);\n@@ -4526,6 +4554,1 @@\n-    uint vlen = Matcher::vector_length(this);\n-    if (vlen == 2) {\n-      __ movq($dst$$XMMRegister, $mem$$Address);\n-      __ pshufd($dst$$XMMRegister, $dst$$XMMRegister, 0x44);\n-    } else {\n-      assert(VM_Version::supports_avx(), \"sanity\");\n+    if (Matcher::vector_length(this) >= 4) {\n@@ -4534,0 +4557,2 @@\n+    } else {\n+      __ movddup($dst$$XMMRegister, $mem$$Address);\n@@ -4544,2 +4569,12 @@\n-    InternalAddress addr = $constantaddress(T_DOUBLE, vreplicate_imm(T_DOUBLE, $con$$constant, Matcher::vector_length(this)));\n-    __ load_vector($dst$$XMMRegister, addr, Matcher::vector_length_in_bytes(this));\n+    InternalAddress addr = $constantaddress(T_DOUBLE, vreplicate_imm(T_DOUBLE, $con$$constant, 1));\n+    int vlen_enc = vector_length_encoding(this);\n+    if (Matcher::vector_length(this) >= 4) {\n+      __ vbroadcastsd($dst$$XMMRegister, addr, vlen_enc);\n+    } else if (VM_Version::supports_sse3()) {\n+      __ movddup($dst$$XMMRegister, addr);\n+    } else {\n+      __ movq($dst$$XMMRegister, addr);\n+      if (Matcher::vector_length_in_bytes(this) >= 16) {\n+        __ punpcklqdq($dst$$XMMRegister, $dst$$XMMRegister);\n+      }\n+    }\n@@ -4554,3 +4589,3 @@\n-    uint vlen = Matcher::vector_length(this);\n-    if (vlen == 2) {\n-      __ xorpd($dst$$XMMRegister, $dst$$XMMRegister);\n+    int vlen_enc = vector_length_encoding(this);\n+    if (VM_Version::supports_evex() && !VM_Version::supports_avx512vldq()) {\n+      __ vpxor($dst$$XMMRegister, $dst$$XMMRegister, $dst$$XMMRegister, vlen_enc);\n@@ -4558,2 +4593,1 @@\n-      int vlen_enc = vector_length_encoding(this);\n-      __ vpxor($dst$$XMMRegister, $dst$$XMMRegister, $dst$$XMMRegister, vlen_enc); \/\/ 512bit vxorps requires AVX512DQ\n+      __ xorps($dst$$XMMRegister, $dst$$XMMRegister);\n@@ -8338,1 +8372,1 @@\n-    __ vpshufps($dst$$XMMRegister, $src$$XMMRegister, $src$$XMMRegister, 0x88, Assembler::AVX_256bit);\n+    __ vshufps($dst$$XMMRegister, $src$$XMMRegister, $src$$XMMRegister, 0x88, Assembler::AVX_256bit);\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":170,"deletions":136,"binary":false,"changes":306,"status":"modified"},{"patch":"@@ -3337,1 +3337,1 @@\n-      next_char();\n+      next_char_or_line();\n@@ -3343,1 +3343,1 @@\n-      next_char();\n+      next_char_or_line();\n@@ -3350,1 +3350,1 @@\n-        next_char();\n+        next_char_or_line();\n","filename":"src\/hotspot\/share\/adlc\/adlparse.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -68,1 +68,1 @@\n-    _is_mach_constant(false),\n+    _is_mach_constant(instr->_is_mach_constant),\n@@ -4095,6 +4095,0 @@\n-        strcmp(opType,\"ReplicateB\")==0 ||\n-        strcmp(opType,\"ReplicateS\")==0 ||\n-        strcmp(opType,\"ReplicateI\")==0 ||\n-        strcmp(opType,\"ReplicateL\")==0 ||\n-        strcmp(opType,\"ReplicateF\")==0 ||\n-        strcmp(opType,\"ReplicateD\")==0 ||\n@@ -4116,1 +4110,1 @@\n-        0 \/* 0 to line up columns nicely *\/ )\n+        0 \/* 0 to line up columns nicely *\/ ) {\n@@ -4118,0 +4112,1 @@\n+    }\n","filename":"src\/hotspot\/share\/adlc\/formssel.cpp","additions":3,"deletions":8,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -432,1 +432,1 @@\n-  address array_constant(BasicType bt, GrowableArray<jvalue>* c) {\n+  address array_constant(BasicType bt, GrowableArray<jvalue>* c, int alignment) {\n@@ -436,1 +436,1 @@\n-    address ptr = start_a_const(size, MIN2(round_up_power_of_2(size), 8));\n+    address ptr = start_a_const(size, alignment);\n","filename":"src\/hotspot\/share\/asm\/assembler.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -39,1 +39,24 @@\n-    return is_array() && other.is_array() && _v._array == other._v._array;\n+    if (is_array() != other.is_array() ||\n+        get_array()->length() != other.get_array()->length()) {\n+      return false;\n+    }\n+    for (int i = 0; i < get_array()->length(); i++) {\n+      jvalue ele1 = get_array()->at(i);\n+      jvalue ele2 = other.get_array()->at(i);\n+      bool is_eq;\n+      switch (type()) {\n+        case T_BOOLEAN: is_eq = ele1.z == ele2.z; break;\n+        case T_BYTE:    is_eq = ele1.b == ele2.b; break;\n+        case T_CHAR:    is_eq = ele1.c == ele2.c; break;\n+        case T_SHORT:   is_eq = ele1.s == ele2.s; break;\n+        case T_INT:     is_eq = ele1.i == ele2.i; break;\n+        case T_LONG:    is_eq = ele1.j == ele2.j; break;\n+        case T_FLOAT:   is_eq = jint_cast(ele1.f)  == jint_cast(ele2.f);  break;\n+        case T_DOUBLE:  is_eq = jlong_cast(ele1.d) == jlong_cast(ele2.d); break;\n+        default: ShouldNotReachHere(); is_eq = false;\n+      }\n+      if (!is_eq) {\n+        return false;\n+      }\n+    }\n+    return true;\n@@ -107,1 +130,1 @@\n-    offset = align_up(offset, MIN2(round_up_power_of_2(typesize), 8));\n+    offset = align_up(offset, con->alignment());\n@@ -130,1 +153,1 @@\n-      constant_addr = _masm.array_constant(con.type(), con.get_array());\n+      constant_addr = _masm.array_constant(con.type(), con.get_array(), con.alignment());\n@@ -232,2 +255,3 @@\n-ConstantTable::Constant ConstantTable::add(MachConstantNode* n, BasicType bt, GrowableArray<jvalue>* array) {\n-  Constant con(bt, array);\n+ConstantTable::Constant ConstantTable::add(MachConstantNode* n, BasicType bt,\n+                                           GrowableArray<jvalue>* array, int alignment) {\n+  Constant con(bt, array, alignment);\n@@ -238,0 +262,5 @@\n+ConstantTable::Constant ConstantTable::add(MachConstantNode* n, BasicType bt,\n+                                           GrowableArray<jvalue>* array) {\n+  return add(n, bt, array, array->length() * type2aelembytes(bt));\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/constantTable.cpp","additions":34,"deletions":5,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+    int _alignment;\n@@ -52,1 +53,1 @@\n-    Constant() : _type(T_ILLEGAL), _is_array(false), _offset(-1), _freq(0.0f), _can_be_reused(true) { _v._value.l = 0; }\n+    Constant() : _type(T_ILLEGAL), _is_array(false), _alignment(-1), _offset(-1), _freq(0.0f), _can_be_reused(true) { _v._value.l = 0; }\n@@ -62,0 +63,1 @@\n+      _alignment = type == T_VOID ? sizeof(jobject) : type2aelembytes(type);\n@@ -66,0 +68,1 @@\n+      _alignment(sizeof(Metadata*)),\n@@ -72,1 +75,1 @@\n-    Constant(BasicType type, GrowableArray<jvalue>* array) :\n+    Constant(BasicType type, GrowableArray<jvalue>* array, int alignment, bool can_be_reused = true) :\n@@ -75,0 +78,1 @@\n+      _alignment(alignment),\n@@ -77,1 +81,1 @@\n-      _can_be_reused(false)\n+      _can_be_reused(can_be_reused)\n@@ -80,0 +84,1 @@\n+      assert(is_power_of_2(alignment), \"invalid alignment %d\", alignment);\n@@ -90,0 +95,1 @@\n+    int alignment()       const    { return _alignment; }\n@@ -148,0 +154,1 @@\n+  Constant add(MachConstantNode* n, BasicType bt, GrowableArray<jvalue>* array, int alignment);\n","filename":"src\/hotspot\/share\/opto\/constantTable.hpp","additions":10,"deletions":3,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -477,1 +477,2 @@\n-  if (req() > 2) {\n+  \/\/ A MachContant has the last input being the constant base\n+  if (req() > (is_MachConstant() ? 3U : 2U)) {\n@@ -481,1 +482,1 @@\n-  if (req() == 2 && in(1) && in(1)->ideal_reg() == Op_RegFlags) {\n+  if (req() >= 2 && in(1) && in(1)->ideal_reg() == Op_RegFlags) {\n@@ -484,1 +485,1 @@\n-    if (in(1)->req() > 2) {\n+    if (in(1)->req() > (in(1)->is_MachConstant() ? 3U : 2U)) {\n@@ -494,1 +495,1 @@\n-    if (rm.is_bound(ideal_reg())) {\n+    if (rm.is_NotEmpty() && rm.is_bound(ideal_reg())) {\n","filename":"src\/hotspot\/share\/opto\/machnode.cpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,119 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.jdk.incubator.vector;\n+\n+import java.util.concurrent.TimeUnit;\n+import jdk.incubator.vector.DoubleVector;\n+import jdk.incubator.vector.FloatVector;\n+import jdk.incubator.vector.IntVector;\n+import jdk.incubator.vector.LongVector;\n+import org.openjdk.jmh.annotations.*;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Fork(1)\n+public class SpiltReplicate {\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public long broadcastInt() {\n+        var species = IntVector.SPECIES_PREFERRED;\n+        var sum = IntVector.zero(species);\n+        return sum.add(1).add(2).add(3).add(4).add(5).add(6).add(7).add(8)\n+                .add(9).add(10).add(11).add(12).add(13).add(14).add(15).add(16)\n+                .add(17).add(18).add(19).add(20).add(21).add(22).add(23).add(24)\n+                .add(25).add(26).add(27).add(28).add(29).add(30).add(31).add(32)\n+                .add(1).add(2).add(3).add(4).add(5).add(6).add(7).add(8)\n+                .add(9).add(10).add(11).add(12).add(13).add(14).add(15).add(16)\n+                .add(17).add(18).add(19).add(20).add(21).add(22).add(23).add(24)\n+                .add(25).add(26).add(27).add(28).add(29).add(30).add(31).add(32)\n+                .reinterpretAsLongs()\n+                .lane(0);\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public long broadcastLong() {\n+        var species = LongVector.SPECIES_PREFERRED;\n+        var sum = LongVector.zero(species);\n+        return sum.add(1).add(2).add(3).add(4).add(5).add(6).add(7).add(8)\n+                .add(9).add(10).add(11).add(12).add(13).add(14).add(15).add(16)\n+                .add(17).add(18).add(19).add(20).add(21).add(22).add(23).add(24)\n+                .add(25).add(26).add(27).add(28).add(29).add(30).add(31).add(32)\n+                .add(1).add(2).add(3).add(4).add(5).add(6).add(7).add(8)\n+                .add(9).add(10).add(11).add(12).add(13).add(14).add(15).add(16)\n+                .add(17).add(18).add(19).add(20).add(21).add(22).add(23).add(24)\n+                .add(25).add(26).add(27).add(28).add(29).add(30).add(31).add(32)\n+                .reinterpretAsLongs()\n+                .lane(0);\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public long broadcastFloat() {\n+        var species = FloatVector.SPECIES_PREFERRED;\n+        var sum = FloatVector.zero(species);\n+        return sum.add(1).add(2).add(3).add(4).add(5).add(6).add(7).add(8)\n+                .add(9).add(10).add(11).add(12).add(13).add(14).add(15).add(16)\n+                .add(17).add(18).add(19).add(20).add(21).add(22).add(23).add(24)\n+                .add(25).add(26).add(27).add(28).add(29).add(30).add(31).add(32)\n+                .add(1).add(2).add(3).add(4).add(5).add(6).add(7).add(8)\n+                .add(9).add(10).add(11).add(12).add(13).add(14).add(15).add(16)\n+                .add(17).add(18).add(19).add(20).add(21).add(22).add(23).add(24)\n+                .add(25).add(26).add(27).add(28).add(29).add(30).add(31).add(32)\n+                .reinterpretAsLongs()\n+                .lane(0);\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public long broadcastDouble() {\n+        var species = DoubleVector.SPECIES_PREFERRED;\n+        var sum = DoubleVector.zero(species);\n+        return sum.add(1).add(2).add(3).add(4).add(5).add(6).add(7).add(8)\n+                .add(9).add(10).add(11).add(12).add(13).add(14).add(15).add(16)\n+                .add(17).add(18).add(19).add(20).add(21).add(22).add(23).add(24)\n+                .add(25).add(26).add(27).add(28).add(29).add(30).add(31).add(32)\n+                .add(1).add(2).add(3).add(4).add(5).add(6).add(7).add(8)\n+                .add(9).add(10).add(11).add(12).add(13).add(14).add(15).add(16)\n+                .add(17).add(18).add(19).add(20).add(21).add(22).add(23).add(24)\n+                .add(25).add(26).add(27).add(28).add(29).add(30).add(31).add(32)\n+                .reinterpretAsLongs()\n+                .lane(0);\n+    }\n+\n+    @Benchmark\n+    public void testInt() {\n+        broadcastInt();\n+    }\n+\n+    @Benchmark\n+    public void testLong() {\n+        broadcastLong();\n+    }\n+\n+    @Benchmark\n+    public void testFloat() {\n+        broadcastFloat();\n+    }\n+\n+    @Benchmark\n+    public void testDouble() {\n+        broadcastDouble();\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/SpiltReplicate.java","additions":119,"deletions":0,"binary":false,"changes":119,"status":"added"}]}