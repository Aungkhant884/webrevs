{"files":[{"patch":"@@ -39,1 +39,24 @@\n-    return is_array() && other.is_array() && _v._array == other._v._array;\n+    if (is_array() != other.is_array() ||\n+        get_array()->length() != other.get_array()->length()) {\n+      return false;\n+    }\n+    for (int i = 0; i < get_array()->length(); i++) {\n+      jvalue ele1 = get_array()->at(i);\n+      jvalue ele2 = other.get_array()->at(i);\n+      bool is_eq;\n+      switch (type()) {\n+        case T_BOOLEAN: is_eq = ele1.z == ele2.z; break;\n+        case T_BYTE:    is_eq = ele1.b == ele2.b; break;\n+        case T_CHAR:    is_eq = ele1.c == ele2.c; break;\n+        case T_SHORT:   is_eq = ele1.s == ele2.s; break;\n+        case T_INT:     is_eq = ele1.i == ele2.i; break;\n+        case T_LONG:    is_eq = ele1.j == ele2.j; break;\n+        case T_FLOAT:   is_eq = ele1.f == ele2.f; break;\n+        case T_DOUBLE:  is_eq = ele1.d == ele2.d; break;\n+        default: ShouldNotReachHere(); is_eq = false;\n+      }\n+      if (!is_eq) {\n+        return false;\n+      }\n+    }\n+    return true;\n","filename":"src\/hotspot\/share\/opto\/constantTable.cpp","additions":24,"deletions":1,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -75,1 +75,1 @@\n-    Constant(BasicType type, GrowableArray<jvalue>* array, int alignment) :\n+    Constant(BasicType type, GrowableArray<jvalue>* array, int alignment, bool can_be_reused = true) :\n@@ -81,1 +81,1 @@\n-      _can_be_reused(false)\n+      _can_be_reused(can_be_reused)\n","filename":"src\/hotspot\/share\/opto\/constantTable.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -494,1 +494,1 @@\n-    if (rm.is_bound(ideal_reg())) {\n+    if (rm.is_NotEmpty() && rm.is_bound(ideal_reg())) {\n","filename":"src\/hotspot\/share\/opto\/machnode.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}