{"files":[{"patch":"@@ -120,0 +120,10 @@\n+###############################################################################\n+# Evaluates platform specific overrides for build devkit variables.\n+# $1: Name of variable\n+AC_DEFUN([BASIC_EVAL_BUILD_DEVKIT_VARIABLE],\n+[\n+  if test \"x[$]$1\" = x; then\n+    eval $1=\"\\${$1_${OPENJDK_BUILD_CPU}}\"\n+  fi\n+])\n+\n","filename":"make\/autoconf\/basic.m4","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -669,1 +669,3 @@\n-    if test \"x$FLAGS_CPU\" = xx86_64; then\n+    if test \"x$FLAGS_CPU\" = xaarch64; then\n+      $1_DEFINES_CPU_JDK=\"${$1_DEFINES_CPU_JDK} -D_ARM64_ -Darm64\"\n+    elif test \"x$FLAGS_CPU\" = xx86_64; then\n","filename":"make\/autoconf\/flags-cflags.m4","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -168,4 +168,1 @@\n-    if test \"x${OPENJDK_$1_CPU}\" = \"xx86\"; then\n-      $1_CPU_LDFLAGS=\"-safeseh\"\n-      # NOTE: Old build added -machine. Probably not needed.\n-      $1_CPU_LDFLAGS_JVM_ONLY=\"-machine:I386\"\n+    if test \"x${OPENJDK_$1_CPU_BITS}\" = \"x32\"; then\n@@ -173,2 +170,1 @@\n-    else\n-      $1_CPU_LDFLAGS_JVM_ONLY=\"-machine:AMD64\"\n+    elif test \"x${OPENJDK_$1_CPU_BITS}\" = \"x64\"; then\n@@ -177,0 +173,3 @@\n+    if test \"x${OPENJDK_$1_CPU}\" = \"xx86\"; then\n+      $1_CPU_LDFLAGS=\"-safeseh\"\n+    fi\n","filename":"make\/autoconf\/flags-ldflags.m4","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -240,2 +240,3 @@\n-    if test \"x$OPENJDK_TARGET_CPU\" = \"xx86_64\" || \\\n-        test \"x$OPENJDK_TARGET_CPU\" = \"xaarch64\"; then\n+    if test \"x$OPENJDK_TARGET_CPU\" = \"xx86_64\"; then\n+      AC_MSG_RESULT([yes])\n+    elif test \"x$OPENJDK_TARGET_OS-$OPENJDK_TARGET_CPU\" = \"xlinux-aarch64\"; then\n@@ -306,2 +307,3 @@\n-    if test \"x$OPENJDK_TARGET_CPU\" = \"xx86_64\" || \\\n-        test \"x$OPENJDK_TARGET_CPU\" = \"xaarch64\" ; then\n+    if test \"x$OPENJDK_TARGET_CPU\" = \"xx86_64\"; then\n+      AC_MSG_RESULT([yes])\n+    elif test \"x$OPENJDK_TARGET_OS-$OPENJDK_TARGET_CPU\" = \"xlinux-aarch64\"; then\n@@ -339,2 +341,3 @@\n-    if test \"x$OPENJDK_TARGET_CPU\" = \"xx86_64\" || \\\n-        test \"x$OPENJDK_TARGET_CPU\" = \"xaarch64\" ; then\n+    if test \"x$OPENJDK_TARGET_CPU\" = \"xx86_64\"; then\n+      AC_MSG_RESULT([yes])\n+    elif test \"x$OPENJDK_TARGET_OS-$OPENJDK_TARGET_CPU\" = \"xlinux-aarch64\"; then\n","filename":"make\/autoconf\/jvm-features.m4","additions":9,"deletions":6,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -875,1 +875,1 @@\n-          BASIC_EVAL_DEVKIT_VARIABLE([BUILD_DEVKIT_NAME])\n+          BASIC_EVAL_BUILD_DEVKIT_VARIABLE([BUILD_DEVKIT_NAME])\n@@ -877,1 +877,1 @@\n-          BASIC_EVAL_DEVKIT_VARIABLE([BUILD_DEVKIT_EXTRA_PATH])\n+          BASIC_EVAL_BUILD_DEVKIT_VARIABLE([BUILD_DEVKIT_EXTRA_PATH])\n@@ -879,1 +879,1 @@\n-          BASIC_EVAL_DEVKIT_VARIABLE([BUILD_DEVKIT_TOOLCHAIN_PATH])\n+          BASIC_EVAL_BUILD_DEVKIT_VARIABLE([BUILD_DEVKIT_TOOLCHAIN_PATH])\n@@ -881,2 +881,6 @@\n-          BASIC_EVAL_DEVKIT_VARIABLE([BUILD_DEVKIT_SYSROOT])\n-          # Skip the Window specific parts\n+          BASIC_EVAL_BUILD_DEVKIT_VARIABLE([BUILD_DEVKIT_SYSROOT])\n+\n+          if test \"x$TOOLCHAIN_TYPE\" = xmicrosoft; then\n+            BASIC_EVAL_BUILD_DEVKIT_VARIABLE([BUILD_DEVKIT_VS_INCLUDE])\n+            BASIC_EVAL_BUILD_DEVKIT_VARIABLE([BUILD_DEVKIT_VS_LIB])\n+          fi\n@@ -892,3 +896,1 @@\n-        BUILD_SYSROOT=\"$BUILD_DEVKIT_SYSROOT\"\n-\n-         # Fallback default of just \/bin if DEVKIT_PATH is not defined\n+        # Fallback default of just \/bin if DEVKIT_PATH is not defined\n@@ -899,0 +901,9 @@\n+\n+        BUILD_SYSROOT=\"$BUILD_DEVKIT_SYSROOT\"\n+\n+        if test \"x$TOOLCHAIN_TYPE\" = xmicrosoft; then\n+          BUILD_VS_INCLUDE=\"$BUILD_DEVKIT_VS_INCLUDE\"\n+          BUILD_VS_LIB=\"$BUILD_DEVKIT_VS_LIB\"\n+\n+          TOOLCHAIN_SETUP_VISUAL_STUDIO_SYSROOT_FLAGS([BUILD_])\n+        fi\n@@ -924,3 +935,31 @@\n-    # Just like for the target compiler, use the compiler as linker\n-    BUILD_LD=\"$BUILD_CC\"\n-    BUILD_LDCXX=\"$BUILD_CXX\"\n+    if test \"x$TOOLCHAIN_TYPE\" = xmicrosoft; then\n+      # In the Microsoft toolchain we have a separate LD command \"link\".\n+      # Make sure we reject \/usr\/bin\/link (as determined in CYGWIN_LINK), which is\n+      # a cygwin program for something completely different.\n+      AC_CHECK_PROG([BUILD_LD], [link$EXE_SUFFIX],[link$EXE_SUFFIX],,, [$CYGWIN_LINK])\n+      UTIL_FIXUP_EXECUTABLE(BUILD_LD)\n+      # Verify that we indeed succeeded with this trick.\n+      AC_MSG_CHECKING([if the found link.exe is actually the Visual Studio linker])\n+\n+      # Reset PATH since it can contain a mix of WSL\/linux paths and Windows paths from VS,\n+      # which, in combination with WSLENV, will make the WSL layer complain\n+      old_path=\"$PATH\"\n+      PATH=\n+\n+      \"$BUILD_LD\" --version > \/dev\/null\n+\n+      if test $? -eq 0 ; then\n+        AC_MSG_RESULT([no])\n+        AC_MSG_ERROR([This is the Cygwin link tool. Please check your PATH and rerun configure.])\n+      else\n+        AC_MSG_RESULT([yes])\n+      fi\n+\n+      PATH=\"$old_path\"\n+\n+      BUILD_LDCXX=\"$BUILD_LD\"\n+    else\n+      # Just like for the target compiler, use the compiler as linker\n+      BUILD_LD=\"$BUILD_CC\"\n+      BUILD_LDCXX=\"$BUILD_CXX\"\n+    fi\n@@ -977,0 +1016,4 @@\n+    elif test \"x$OPENJDK_TARGET_CPU\" = \"xaarch64\"; then\n+      if test \"x$COMPILER_CPU_TEST\" != \"xARM64\"; then\n+        AC_MSG_ERROR([Target CPU mismatch. We are building for $OPENJDK_TARGET_CPU but CL is for \"$COMPILER_CPU_TEST\"; expected \"arm64\".])\n+      fi\n","filename":"make\/autoconf\/toolchain.m4","additions":54,"deletions":11,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -82,1 +82,1 @@\n-      if test \"x$OPENJDK_TARGET_CPU_BITS\" = x32; then\n+      if test \"x$OPENJDK_TARGET_CPU\" = xx86; then\n@@ -84,1 +84,1 @@\n-      else\n+      elif test \"x$OPENJDK_TARGET_CPU\" = xx86_64; then\n@@ -87,0 +87,4 @@\n+      elif test \"x$OPENJDK_TARGET_CPU\" = xaarch64; then\n+        # for host x86-64, target aarch64\n+        VCVARSFILES=\"vc\/auxiliary\/build\/vcvarsamd64_arm64.bat \\\n+            vc\/auxiliary\/build\/vcvarsx86_arm64.bat\"\n@@ -126,1 +130,1 @@\n-        if test \"x$OPENJDK_TARGET_CPU_BITS\" = x32; then\n+        if test \"x$OPENJDK_TARGET_CPU\" = xx86; then\n@@ -128,1 +132,1 @@\n-        else\n+        elif test \"x$OPENJDK_TARGET_CPU\" = xx86_64; then\n@@ -130,0 +134,2 @@\n+        elif test \"x$OPENJDK_TARGET_CPU\" = xaarch64; then\n+          VS_ENV_ARGS=\"\/arm64\"\n@@ -523,35 +529,1 @@\n-      # Convert VS_INCLUDE into SYSROOT_CFLAGS\n-      OLDIFS=\"$IFS\"\n-      IFS=\";\"\n-      for i in $VS_INCLUDE; do\n-        ipath=$i\n-        # Only process non-empty elements\n-        if test \"x$ipath\" != x; then\n-          IFS=\"$OLDIFS\"\n-          # Check that directory exists before calling fixup_path\n-          testpath=$ipath\n-          UTIL_REWRITE_AS_UNIX_PATH([testpath])\n-          if test -d \"$testpath\"; then\n-            UTIL_FIXUP_PATH([ipath])\n-            SYSROOT_CFLAGS=\"$SYSROOT_CFLAGS -I$ipath\"\n-          fi\n-          IFS=\";\"\n-        fi\n-      done\n-      # Convert VS_LIB into SYSROOT_LDFLAGS\n-      for i in $VS_LIB; do\n-        libpath=$i\n-        # Only process non-empty elements\n-        if test \"x$libpath\" != x; then\n-          IFS=\"$OLDIFS\"\n-          # Check that directory exists before calling fixup_path\n-          testpath=$libpath\n-          UTIL_REWRITE_AS_UNIX_PATH([testpath])\n-          if test -d \"$testpath\"; then\n-            UTIL_FIXUP_PATH([libpath])\n-            SYSROOT_LDFLAGS=\"$SYSROOT_LDFLAGS -libpath:$libpath\"\n-          fi\n-          IFS=\";\"\n-        fi\n-      done\n-      IFS=\"$OLDIFS\"\n+      TOOLCHAIN_SETUP_VISUAL_STUDIO_SYSROOT_FLAGS\n@@ -596,1 +568,1 @@\n-      if test \"x$OPENJDK_TARGET_CPU_BITS\" = x32; then\n+      if test \"x$OPENJDK_TARGET_CPU\" = xx86; then\n@@ -598,1 +570,1 @@\n-      else\n+      elif test \"x$OPENJDK_TARGET_CPU\" = xx86_64; then\n@@ -600,0 +572,5 @@\n+      elif test \"x$OPENJDK_TARGET_CPU\" = xaarch64; then\n+        # The cygwin 'file' command only returns \"PE32+ executable (DLL) (console), for MS Windows\",\n+        # without specifying which architecture it is for specifically. This has been fixed upstream.\n+        # https:\/\/github.com\/file\/file\/commit\/b849b1af098ddd530094bf779b58431395db2e10#diff-ff2eced09e6860de75057dd731d092aeR142\n+        CORRECT_MSVCR_ARCH=\"PE32+ executable\"\n@@ -619,0 +596,8 @@\n+  if test \"x$OPENJDK_TARGET_CPU\" = xx86; then\n+    vs_target_cpu=x86\n+  elif test \"x$OPENJDK_TARGET_CPU\" = xx86_64; then\n+    vs_target_cpu=x64\n+  elif test \"x$OPENJDK_TARGET_CPU\" = xaarch64; then\n+    vs_target_cpu=arm64\n+  fi\n+\n@@ -625,5 +610,1 @@\n-        if test \"x$OPENJDK_TARGET_CPU_BITS\" = x64; then\n-          POSSIBLE_MSVC_DLL=\"$CYGWIN_VC_INSTALL_DIR\/redist\/x64\/Microsoft.VC${VS_VERSION_INTERNAL}.CRT\/$DLL_NAME\"\n-        else\n-          POSSIBLE_MSVC_DLL=\"$CYGWIN_VC_INSTALL_DIR\/redist\/x86\/Microsoft.VC${VS_VERSION_INTERNAL}.CRT\/$DLL_NAME\"\n-        fi\n+        POSSIBLE_MSVC_DLL=\"$CYGWIN_VC_INSTALL_DIR\/redist\/$vs_target_cpu\/Microsoft.VC${VS_VERSION_INTERNAL}.CRT\/$DLL_NAME\"\n@@ -634,5 +615,1 @@\n-        if test \"x$OPENJDK_TARGET_CPU_BITS\" = x64; then\n-          POSSIBLE_MSVC_DLL=\"`ls $CYGWIN_VC_TOOLS_REDIST_DIR\/x64\/Microsoft.VC${VS_VERSION_INTERNAL}.CRT\/$DLL_NAME`\"\n-        else\n-          POSSIBLE_MSVC_DLL=\"`ls $CYGWIN_VC_TOOLS_REDIST_DIR\/x86\/Microsoft.VC${VS_VERSION_INTERNAL}.CRT\/$DLL_NAME`\"\n-        fi\n+        POSSIBLE_MSVC_DLL=\"`ls $CYGWIN_VC_TOOLS_REDIST_DIR\/$vs_target_cpu\/Microsoft.VC${VS_VERSION_INTERNAL}.CRT\/$DLL_NAME`\"\n@@ -670,7 +647,2 @@\n-      if test \"x$OPENJDK_TARGET_CPU_BITS\" = x64; then\n-        POSSIBLE_MSVC_DLL=`$FIND \"$CYGWIN_VS_TOOLS_DIR\" -name $DLL_NAME \\\n-        | $GREP -i \/x64\/ | $HEAD --lines 1`\n-      else\n-        POSSIBLE_MSVC_DLL=`$FIND \"$CYGWIN_VS_TOOLS_DIR\" -name $DLL_NAME \\\n-        | $GREP -i \/x86\/ | $HEAD --lines 1`\n-      fi\n+      POSSIBLE_MSVC_DLL=`$FIND \"$CYGWIN_VS_TOOLS_DIR\" -name $DLL_NAME \\\n+        | $GREP -i \/$vs_target_cpu\/ | $HEAD --lines 1`\n@@ -686,1 +658,1 @@\n-      if test \"x$OPENJDK_TARGET_CPU_BITS\" = x64; then\n+      if test \"x$OPENJDK_TARGET_CPU\" = xx86; then\n@@ -688,4 +660,1 @@\n-        | $GREP x64 | $HEAD --lines 1`\n-      else\n-        POSSIBLE_MSVC_DLL=`$FIND \"$CYGWIN_VC_INSTALL_DIR\" -name $DLL_NAME \\\n-        | $GREP x86 | $GREP -v ia64 | $GREP -v x64 | $HEAD --lines 1`\n+        | $GREP x86 | $GREP -v ia64 | $GREP -v x64 | $GREP -v arm64 | $HEAD --lines 1`\n@@ -697,0 +666,3 @@\n+      else\n+        POSSIBLE_MSVC_DLL=`$FIND \"$CYGWIN_VC_INSTALL_DIR\" -name $DLL_NAME \\\n+          | $GREP $vs_target_cpu | $HEAD --lines 1`\n@@ -760,1 +732,1 @@\n-      [path to microsoft C++ runtime dll (vcruntime*_1.dll) (Windows only) @<:@probed@:>@])])\n+      [path to microsoft C++ runtime dll (vcruntime*_1.dll) (Windows 64-bits only) @<:@probed@:>@])])\n@@ -762,1 +734,1 @@\n-  if test \"x$VCRUNTIME_1_NAME\" != \"x\"; then\n+  if test \"x$VCRUNTIME_1_NAME\" != \"x\" -a \"x$OPENJDK_TARGET_CPU_BITS\" = x64; then\n@@ -804,2 +776,3 @@\n-      dll_subdir=$OPENJDK_TARGET_CPU\n-      if test \"x$dll_subdir\" = \"xx86_64\"; then\n+      if test \"x$OPENJDK_TARGET_CPU\" = \"xaarch64\"; then\n+        dll_subdir=\"arm64\"\n+      elif test \"x$OPENJDK_TARGET_CPU\" = \"xx86_64\"; then\n@@ -807,0 +780,2 @@\n+      elif test \"x$OPENJDK_TARGET_CPU\" = \"xx86\"; then\n+        dll_subdir=\"x86\"\n@@ -829,0 +804,46 @@\n+\n+# Setup the sysroot flags and add them to global CFLAGS and LDFLAGS so\n+# that configure can use them while detecting compilers.\n+# TOOLCHAIN_TYPE is available here.\n+# Param 1 - Optional prefix to all variables. (e.g BUILD_)\n+AC_DEFUN([TOOLCHAIN_SETUP_VISUAL_STUDIO_SYSROOT_FLAGS],\n+[\n+  OLDIFS=\"$IFS\"\n+  IFS=\";\"\n+  # Convert $1VS_INCLUDE into $1SYSROOT_CFLAGS\n+  for i in [$]$1VS_INCLUDE; do\n+    ipath=$i\n+    # Only process non-empty elements\n+    if test \"x$ipath\" != x; then\n+      IFS=\"$OLDIFS\"\n+      # Check that directory exists before calling fixup_path\n+      testpath=$ipath\n+      UTIL_REWRITE_AS_UNIX_PATH([testpath])\n+      if test -d \"$testpath\"; then\n+        UTIL_FIXUP_PATH([ipath])\n+        $1SYSROOT_CFLAGS=\"[$]$1SYSROOT_CFLAGS -I$ipath\"\n+      fi\n+      IFS=\";\"\n+    fi\n+  done\n+  # Convert $1VS_LIB into $1SYSROOT_LDFLAGS\n+  for i in [$]$1VS_LIB; do\n+    libpath=$i\n+    # Only process non-empty elements\n+    if test \"x$libpath\" != x; then\n+      IFS=\"$OLDIFS\"\n+      # Check that directory exists before calling fixup_path\n+      testpath=$libpath\n+      UTIL_REWRITE_AS_UNIX_PATH([testpath])\n+      if test -d \"$testpath\"; then\n+        UTIL_FIXUP_PATH([libpath])\n+        $1SYSROOT_LDFLAGS=\"[$]$1SYSROOT_LDFLAGS -libpath:$libpath\"\n+      fi\n+      IFS=\";\"\n+    fi\n+  done\n+  IFS=\"$OLDIFS\"\n+\n+  AC_SUBST($1SYSROOT_CFLAGS)\n+  AC_SUBST($1SYSROOT_LDFLAGS)\n+])\n","filename":"make\/autoconf\/toolchain_windows.m4","additions":88,"deletions":67,"binary":false,"changes":155,"status":"modified"},{"patch":"@@ -116,0 +116,1 @@\n+cp -r \"$VS_INSTALL_DIR\/${VC_SUBDIR}\/bin\/Hostx64\/arm64\" $DEVKIT_ROOT\/VC\/bin\/\n@@ -119,0 +120,1 @@\n+cp -r \"$VS_INSTALL_DIR\/${VC_SUBDIR}\/lib\/arm64\" $DEVKIT_ROOT\/VC\/lib\/\n@@ -123,0 +125,1 @@\n+cp -r \"$VS_INSTALL_DIR\/${VC_SUBDIR}\/atlmfc\/lib\/arm64\" $DEVKIT_ROOT\/VC\/atlmfc\/lib\/\n@@ -129,0 +132,1 @@\n+cp -r \"$VS_INSTALL_DIR\/$REDIST_SUBDIR\/arm64\" $DEVKIT_ROOT\/VC\/redist\/\n@@ -137,1 +141,3 @@\n-cp $DEVKIT_ROOT\/VC\/redist\/x64\/$MSVCP_DLL $DEVKIT_ROOT\/VC\/bin\/x64\n+cp $DEVKIT_ROOT\/VC\/redist\/x64\/$MSVCR_DLL $DEVKIT_ROOT\/VC\/bin\/x64\n+cp $DEVKIT_ROOT\/VC\/redist\/arm64\/$MSVCP_DLL $DEVKIT_ROOT\/VC\/bin\/arm64\n+cp $DEVKIT_ROOT\/VC\/redist\/arm64\/$MSVCP_DLL $DEVKIT_ROOT\/VC\/bin\/arm64\n@@ -155,0 +161,1 @@\n+cp -r \"$SDK_INSTALL_DIR\/lib\/$SDK_FULL_VERSION\/um\/arm64\" $DEVKIT_ROOT\/$SDK_VERSION\/lib\/\n@@ -157,0 +164,1 @@\n+cp -r \"$SDK_INSTALL_DIR\/lib\/$SDK_FULL_VERSION\/ucrt\/arm64\" $DEVKIT_ROOT\/$SDK_VERSION\/lib\/\n@@ -191,0 +199,7 @@\n+echo-info \"DEVKIT_TOOLCHAIN_PATH_aarch64=\\\"\\$DEVKIT_ROOT\/VC\/bin\/arm64:\\$DEVKIT_ROOT\/$SDK_VERSION\/bin\/x64:\\$DEVKIT_ROOT\/$SDK_VERSION\/bin\/x86\\\"\"\n+echo-info \"DEVKIT_VS_INCLUDE_aarch64=\\\"\\$DEVKIT_ROOT\/VC\/include;\\$DEVKIT_ROOT\/VC\/atlmfc\/include;\\$DEVKIT_ROOT\/$SDK_VERSION\/include\/shared;\\$DEVKIT_ROOT\/$SDK_VERSION\/include\/ucrt;\\$DEVKIT_ROOT\/$SDK_VERSION\/include\/um;\\$DEVKIT_ROOT\/$SDK_VERSION\/include\/winrt\\\"\"\n+echo-info \"DEVKIT_VS_LIB_aarch64=\\\"\\$DEVKIT_ROOT\/VC\/lib\/arm64;\\$DEVKIT_ROOT\/VC\/atlmfc\/lib\/arm64;\\$DEVKIT_ROOT\/$SDK_VERSION\/lib\/arm64\\\"\"\n+echo-info \"DEVKIT_MSVCR_DLL_aarch64=\\\"\\$DEVKIT_ROOT\/VC\/redist\/arm64\/$MSVCR_DLL\\\"\"\n+echo-info \"DEVKIT_MSVCP_DLL_aarch64=\\\"\\$DEVKIT_ROOT\/VC\/redist\/arm64\/$MSVCP_DLL\\\"\"\n+echo-info \"DEVKIT_UCRT_DLL_DIR_aarch64=\\\"\\$DEVKIT_ROOT\/10\/Redist\/ucrt\/DLLs\/arm64\\\"\"\n+echo-info \"\"\n","filename":"make\/devkit\/createWindowsDevkit2017.sh","additions":16,"deletions":1,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -120,0 +120,1 @@\n+cp -r \"$VS_INSTALL_DIR\/${VC_SUBDIR}\/bin\/Hostx64\/arm64\" $DEVKIT_ROOT\/VC\/bin\/\n@@ -123,0 +124,1 @@\n+cp -r \"$VS_INSTALL_DIR\/${VC_SUBDIR}\/lib\/arm64\" $DEVKIT_ROOT\/VC\/lib\/\n@@ -127,0 +129,1 @@\n+cp -r \"$VS_INSTALL_DIR\/${VC_SUBDIR}\/atlmfc\/lib\/arm64\" $DEVKIT_ROOT\/VC\/atlmfc\/lib\/\n@@ -133,0 +136,1 @@\n+cp -r \"$VS_INSTALL_DIR\/$REDIST_SUBDIR\/arm64\" $DEVKIT_ROOT\/VC\/redist\/\n@@ -142,0 +146,2 @@\n+cp $DEVKIT_ROOT\/VC\/redist\/arm64\/$MSVCR_DLL $DEVKIT_ROOT\/VC\/bin\/arm64\n+cp $DEVKIT_ROOT\/VC\/redist\/arm64\/$MSVCP_DLL $DEVKIT_ROOT\/VC\/bin\/arm64\n@@ -159,0 +165,1 @@\n+cp -r \"$SDK_INSTALL_DIR\/lib\/$SDK_FULL_VERSION\/um\/arm64\" $DEVKIT_ROOT\/$SDK_VERSION\/lib\/\n@@ -161,0 +168,1 @@\n+cp -r \"$SDK_INSTALL_DIR\/lib\/$SDK_FULL_VERSION\/ucrt\/arm64\" $DEVKIT_ROOT\/$SDK_VERSION\/lib\/\n@@ -196,0 +204,8 @@\n+echo-info \"DEVKIT_TOOLCHAIN_PATH_aarch64=\\\"\\$DEVKIT_ROOT\/VC\/bin\/arm64:\\$DEVKIT_ROOT\/$SDK_VERSION\/bin\/x64:\\$DEVKIT_ROOT\/$SDK_VERSION\/bin\/x86\\\"\"\n+echo-info \"DEVKIT_VS_INCLUDE_aarch64=\\\"\\$DEVKIT_ROOT\/VC\/include;\\$DEVKIT_ROOT\/VC\/atlmfc\/include;\\$DEVKIT_ROOT\/$SDK_VERSION\/include\/shared;\\$DEVKIT_ROOT\/$SDK_VERSION\/include\/ucrt;\\$DEVKIT_ROOT\/$SDK_VERSION\/include\/um;\\$DEVKIT_ROOT\/$SDK_VERSION\/include\/winrt\\\"\"\n+echo-info \"DEVKIT_VS_LIB_aarch64=\\\"\\$DEVKIT_ROOT\/VC\/lib\/arm64;\\$DEVKIT_ROOT\/VC\/atlmfc\/lib\/arm64;\\$DEVKIT_ROOT\/$SDK_VERSION\/lib\/arm64\\\"\"\n+echo-info \"DEVKIT_MSVCR_DLL_aarch64=\\\"\\$DEVKIT_ROOT\/VC\/redist\/arm64\/$MSVCR_DLL\\\"\"\n+echo-info \"DEVKIT_VCRUNTIME_1_DLL_aarch64=\\\"\\$DEVKIT_ROOT\/VC\/redist\/arm64\/$VCRUNTIME_1_DLL\\\"\"\n+echo-info \"DEVKIT_MSVCP_DLL_aarch64=\\\"\\$DEVKIT_ROOT\/VC\/redist\/arm64\/$MSVCP_DLL\\\"\"\n+echo-info \"DEVKIT_UCRT_DLL_DIR_aarch64=\\\"\\$DEVKIT_ROOT\/10\/Redist\/ucrt\/DLLs\/arm64\\\"\"\n+echo-info \"\"\n","filename":"make\/devkit\/createWindowsDevkit2019.sh","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -91,0 +91,7 @@\n+  else ifeq ($(call isTargetOs, windows), true)\n+    ifeq ($(call isTargetCpuBits, 64), true)\n+      ADLCFLAGS += -D_WIN64=1\n+    endif\n+    ifeq ($(HOTSPOT_TARGET_CPU_ARCH), aarch64)\n+      ADLCFLAGS += -DR18_RESERVED\n+    endif\n","filename":"make\/hotspot\/gensrc\/GensrcAdlc.gmk","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -63,0 +63,6 @@\n+\n+  ifeq ($(OPENJDK_TARGET_CPU),aarch64)\n+    # cl.exe does only recognize few file extensions as valid (ex: .c, .h, .cpp), so\n+    # make sure *.java.template files are recognized as valid input files\n+    CPP_FILEPREFIX = -Tc\n+  endif\n@@ -76,1 +82,1 @@\n-\t      $(CPP) $(CPP_FLAGS) $(SYSROOT_CFLAGS) $(CFLAGS_JDKLIB) $< \\\n+\t      $(CPP) $(CPP_FLAGS) $(SYSROOT_CFLAGS) $(CFLAGS_JDKLIB) $(CPP_FILEPREFIX) $< \\\n","filename":"make\/modules\/java.base\/gensrc\/GensrcMisc.gmk","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -16,0 +16,2 @@\n+        if self.number == 18:\n+            self.number = 17\n@@ -40,0 +42,2 @@\n+        if self.number == 18:\n+            self.number = 16\n@@ -57,0 +61,2 @@\n+        if self.number == 18:\n+            self.number = 15\n@@ -1334,1 +1340,1 @@\n-                        [\"st1d\",   \"__ sve_st1d(z0, __ D, p4, Address(r0, r18));\",       \"st1d\\t{z0.d}, p4, [x0, x18, LSL #3]\"],\n+                        [\"st1d\",   \"__ sve_st1d(z0, __ D, p4, Address(r0, r17));\",       \"st1d\\t{z0.d}, p4, [x0, x17, LSL #3]\"],\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64-asmtest.py","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -117,2 +117,2 @@\n-reg_def R18     ( SOC, SOC, Op_RegI, 18, r18->as_VMReg()        );\n-reg_def R18_H   ( SOC, SOC, Op_RegI, 18, r18->as_VMReg()->next());\n+reg_def R18     ( SOC, SOC, Op_RegI, 18, r18_tls->as_VMReg()        );\n+reg_def R18_H   ( SOC, SOC, Op_RegI, 18, r18_tls->as_VMReg()->next());\n@@ -719,0 +719,4 @@\n+#ifdef R18_RESERVED\n+    \/\/ See comment in register_aarch64.hpp\n+    R18,                        \/\/ tls on Windows\n+#endif\n@@ -726,0 +730,4 @@\n+#ifdef R18_RESERVED\n+    \/\/ See comment in register_aarch64.hpp\n+    R18, R18_H,                 \/\/ tls on Windows, platform register on macOS\n+#endif\n@@ -6289,1 +6297,1 @@\n-  max_instructions_per_bundle = 2;   \/\/ A53 = 2, A57 = 4\n+  max_instructions_per_bundle = 4;   \/\/ A53 = 2, A57 = 4\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":11,"deletions":3,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -104,1 +104,1 @@\n-    __ subw(r3, r13, r18, Assembler::ASR, 30);         \/\/       sub     w3, w13, w18, ASR #30\n+    __ subw(r3, r13, r17, Assembler::ASR, 30);         \/\/       sub     w3, w13, w17, ASR #30\n@@ -112,2 +112,2 @@\n-    __ orrw(r13, r18, r11, Assembler::LSR, 9);         \/\/       orr     w13, w18, w11, LSR #9\n-    __ eorw(r5, r5, r18, Assembler::LSR, 15);          \/\/       eor     w5, w5, w18, LSR #15\n+    __ orrw(r13, r17, r11, Assembler::LSR, 9);         \/\/       orr     w13, w17, w11, LSR #9\n+    __ eorw(r5, r5, r17, Assembler::LSR, 15);          \/\/       eor     w5, w5, w17, LSR #15\n@@ -138,1 +138,1 @@\n-    __ andsw(r7, r18, 1048576ull);                     \/\/       ands    w7, w18, #0x100000\n+    __ andsw(r7, r17, 1048576ull);                     \/\/       ands    w7, w17, #0x100000\n@@ -286,1 +286,1 @@\n-    __ ldxrw(r18, r0);                                 \/\/       ldxr    w18, [x0]\n+    __ ldxrw(r17, r0);                                 \/\/       ldxr    w17, [x0]\n@@ -314,1 +314,1 @@\n-    __ ldxpw(r18, r21, r13);                           \/\/       ldxp    w18, w21, [x13]\n+    __ ldxpw(r17, r21, r13);                           \/\/       ldxp    w17, w21, [x13]\n@@ -327,1 +327,1 @@\n-    __ ldrb(r18, Address(r23, -23));                   \/\/       ldrb    w18, [x23, -23]\n+    __ ldrb(r17, Address(r23, -23));                   \/\/       ldrb    w17, [x23, -23]\n@@ -378,1 +378,1 @@\n-    __ str(r10, Address(r18, r21, Address::sxtw(3)));  \/\/       str     x10, [x18, w21, sxtw #3]\n+    __ str(r10, Address(r17, r21, Address::sxtw(3)));  \/\/       str     x10, [x17, w21, sxtw #3]\n@@ -385,1 +385,1 @@\n-    __ ldrh(r9, Address(r4, r18, Address::uxtw(0)));   \/\/       ldrh    w9, [x4, w18, uxtw #0]\n+    __ ldrh(r9, Address(r4, r17, Address::uxtw(0)));   \/\/       ldrh    w9, [x4, w17, uxtw #0]\n@@ -442,1 +442,1 @@\n-    __ addw(r18, r24, r20, ext::uxtb, 2);              \/\/       add     w18, w24, w20, uxtb #2\n+    __ addw(r17, r24, r20, ext::uxtb, 2);              \/\/       add     w17, w24, w20, uxtb #2\n@@ -453,2 +453,2 @@\n-    __ ccmpw(r22, r18, 6u, Assembler::CC);             \/\/       ccmp    w22, w18, #6, CC\n-    __ ccmn(r18, r30, 14u, Assembler::VS);             \/\/       ccmn    x18, x30, #14, VS\n+    __ ccmpw(r22, r17, 6u, Assembler::CC);             \/\/       ccmp    w22, w17, #6, CC\n+    __ ccmn(r17, r30, 14u, Assembler::VS);             \/\/       ccmn    x17, x30, #14, VS\n@@ -479,1 +479,1 @@\n-    __ rbit(r18, r21);                                 \/\/       rbit    x18, x21\n+    __ rbit(r17, r21);                                 \/\/       rbit    x17, x21\n@@ -489,1 +489,1 @@\n-    __ lslvw(r3, r14, r18);                            \/\/       lslv    w3, w14, w18\n+    __ lslvw(r3, r14, r17);                            \/\/       lslv    w3, w14, w17\n@@ -494,1 +494,1 @@\n-    __ sdiv(r27, r16, r18);                            \/\/       sdiv    x27, x16, x18\n+    __ sdiv(r27, r16, r17);                            \/\/       sdiv    x27, x16, x17\n@@ -498,1 +498,1 @@\n-    __ rorv(r28, r2, r18);                             \/\/       rorv    x28, x2, x18\n+    __ rorv(r28, r2, r17);                             \/\/       rorv    x28, x2, x17\n@@ -543,1 +543,1 @@\n-    __ fsqrtd(v3, v18);                                \/\/       fsqrt   d3, d18\n+    __ fsqrtd(v3, v17);                                \/\/       fsqrt   d3, d17\n@@ -555,1 +555,1 @@\n-    __ fmovs(r18, v21);                                \/\/       fmov    w18, s21\n+    __ fmovs(r17, v21);                                \/\/       fmov    w17, s21\n@@ -557,1 +557,1 @@\n-    __ fmovs(v19, r18);                                \/\/       fmov    s19, w18\n+    __ fmovs(v19, r17);                                \/\/       fmov    s19, w17\n@@ -601,1 +601,1 @@\n-    __ ld2(v18, v19, __ T2D, Address(r10));            \/\/       ld2     {v18.2D, v19.2D}, [x10]\n+    __ ld2(v17, v18, __ T2D, Address(r10));            \/\/       ld2     {v17.2D, v18.2D}, [x10]\n@@ -603,1 +603,1 @@\n-    __ ld2r(v25, v26, __ T16B, Address(r18));          \/\/       ld2r    {v25.16B, v26.16B}, [x18]\n+    __ ld2r(v25, v26, __ T16B, Address(r17));          \/\/       ld2r    {v25.16B, v26.16B}, [x17]\n@@ -605,1 +605,1 @@\n-    __ ld2r(v16, v17, __ T2D, Address(__ post(r18, r9))); \/\/    ld2r    {v16.2D, v17.2D}, [x18], x9\n+    __ ld2r(v16, v17, __ T2D, Address(__ post(r17, r9))); \/\/    ld2r    {v16.2D, v17.2D}, [x17], x9\n@@ -613,1 +613,1 @@\n-    __ ld4r(v24, v25, v26, v27, __ T8B, Address(r18)); \/\/       ld4r    {v24.8B, v25.8B, v26.8B, v27.8B}, [x18]\n+    __ ld4r(v24, v25, v26, v27, __ T8B, Address(r17)); \/\/       ld4r    {v24.8B, v25.8B, v26.8B, v27.8B}, [x17]\n@@ -668,1 +668,1 @@\n-    __ sve_st1d(z0, __ D, p4, Address(r0, r18));       \/\/       st1d    {z0.d}, p4, [x0, x18, LSL #3]\n+    __ sve_st1d(z0, __ D, p4, Address(r0, r17));       \/\/       st1d    {z0.d}, p4, [x0, x17, LSL #3]\n@@ -719,1 +719,1 @@\n-    __ swpa(Assembler::xword, r18, r22, r16);          \/\/       swpa    x18, x22, [x16]\n+    __ swpa(Assembler::xword, r16, r22, r16);          \/\/       swpa    x16, x22, [x16]\n@@ -737,1 +737,1 @@\n-    __ lduminal(Assembler::xword, r11, r11, r18);      \/\/       lduminal        x11, x11, [x18]\n+    __ lduminal(Assembler::xword, r11, r11, r15);      \/\/       lduminal        x11, x11, [x15]\n@@ -744,1 +744,1 @@\n-    __ ldeorl(Assembler::xword, r19, r16, r18);        \/\/       ldeorl  x19, x16, [x18]\n+    __ ldeorl(Assembler::xword, r19, r16, r15);        \/\/       ldeorl  x19, x16, [x15]\n@@ -770,1 +770,1 @@\n-    __ ldumina(Assembler::word, r12, r18, sp);         \/\/       ldumina w12, w18, [sp]\n+    __ ldumina(Assembler::word, r12, r16, sp);         \/\/       ldumina w12, w16, [sp]\n@@ -780,1 +780,1 @@\n-    __ ldsmaxal(Assembler::word, r18, r9, r8);         \/\/       ldsmaxal        w18, w9, [x8]\n+    __ ldsmaxal(Assembler::word, r16, r9, r8);         \/\/       ldsmaxal        w16, w9, [x8]\n@@ -788,1 +788,1 @@\n-    __ ldeorl(Assembler::word, r10, r4, r18);          \/\/       ldeorl  w10, w4, [x18]\n+    __ ldeorl(Assembler::word, r10, r4, r15);          \/\/       ldeorl  w10, w4, [x15]\n@@ -820,1 +820,1 @@\n-    __ sve_frintm(z18, __ S, p5, z2);                  \/\/       frintm  z18.s, p5\/m, z2.s\n+    __ sve_frintm(z17, __ S, p5, z2);                  \/\/       frintm  z17.s, p5\/m, z2.s\n@@ -823,1 +823,1 @@\n-    __ sve_fsqrt(z18, __ S, p1, z17);                  \/\/       fsqrt   z18.s, p1\/m, z17.s\n+    __ sve_fsqrt(z17, __ S, p1, z17);                  \/\/       fsqrt   z17.s, p1\/m, z17.s\n@@ -829,1 +829,1 @@\n-    __ sve_mla(z2, __ H, p7, z26, z18);                \/\/       mla     z2.h, p7\/m, z26.h, z18.h\n+    __ sve_mla(z2, __ H, p7, z26, z17);                \/\/       mla     z2.h, p7\/m, z26.h, z17.h\n@@ -832,1 +832,1 @@\n-    __ sve_eor(z18, z12, z3);                          \/\/       eor     z18.d, z12.d, z3.d\n+    __ sve_eor(z17, z12, z3);                          \/\/       eor     z17.d, z12.d, z3.d\n@@ -860,1 +860,1 @@\n-  14:   4b9279a3        sub     w3, w13, w18, asr #30\n+  14:   4b9179a3        sub     w3, w13, w17, asr #30\n@@ -868,2 +868,2 @@\n-  34:   2a4b264d        orr     w13, w18, w11, lsr #9\n-  38:   4a523ca5        eor     w5, w5, w18, lsr #15\n+  34:   2a4b262d        orr     w13, w17, w11, lsr #9\n+  38:   4a513ca5        eor     w5, w5, w17, lsr #15\n@@ -890,1 +890,1 @@\n-  8c:   720c0247        ands    w7, w18, #0x100000\n+  8c:   720c0227        ands    w7, w17, #0x100000\n@@ -1012,1 +1012,1 @@\n- 274:   885f7c12        ldxr    w18, [x0]\n+ 274:   885f7c11        ldxr    w17, [x0]\n@@ -1032,1 +1032,1 @@\n- 2c4:   887f55b2        ldxp    w18, w21, [x13]\n+ 2c4:   887f55b1        ldxp    w17, w21, [x13]\n@@ -1042,1 +1042,1 @@\n- 2ec:   385e92f2        ldurb   w18, [x23, #-23]\n+ 2ec:   385e92f1        ldurb   w17, [x23, #-23]\n@@ -1084,1 +1084,1 @@\n- 394:   f835da4a        str     x10, [x18, w21, sxtw #3]\n+ 394:   f835da2a        str     x10, [x17, w21, sxtw #3]\n@@ -1091,1 +1091,1 @@\n- 3b0:   78724889        ldrh    w9, [x4, w18, uxtw]\n+ 3b0:   78714889        ldrh    w9, [x4, w17, uxtw]\n@@ -1130,1 +1130,1 @@\n- 44c:   0b340b12        add     w18, w24, w20, uxtb #2\n+ 44c:   0b340b11        add     w17, w24, w20, uxtb #2\n@@ -1139,2 +1139,2 @@\n- 470:   7a5232c6        ccmp    w22, w18, #0x6, cc  \/\/ cc = lo, ul, last\n- 474:   ba5e624e        ccmn    x18, x30, #0xe, vs\n+ 470:   7a5132c6        ccmp    w22, w17, #0x6, cc  \/\/ cc = lo, ul, last\n+ 474:   ba5e622e        ccmn    x17, x30, #0xe, vs\n@@ -1159,1 +1159,1 @@\n- 4c0:   dac002b2        rbit    x18, x21\n+ 4c0:   dac002b1        rbit    x17, x21\n@@ -1167,1 +1167,1 @@\n- 4e0:   1ad221c3        lsl     w3, w14, w18\n+ 4e0:   1ad121c3        lsl     w3, w14, w17\n@@ -1172,1 +1172,1 @@\n- 4f4:   9ad20e1b        sdiv    x27, x16, x18\n+ 4f4:   9ad10e1b        sdiv    x27, x16, x17\n@@ -1176,1 +1176,1 @@\n- 504:   9ad22c5c        ror     x28, x2, x18\n+ 504:   9ad12c5c        ror     x28, x2, x17\n@@ -1213,1 +1213,1 @@\n- 598:   1e61c243        fsqrt   d3, d18\n+ 598:   1e61c223        fsqrt   d3, d17\n@@ -1223,1 +1223,1 @@\n- 5c0:   1e2602b2        fmov    w18, s21\n+ 5c0:   1e2602b1        fmov    w17, s21\n@@ -1225,1 +1225,1 @@\n- 5c8:   1e270253        fmov    s19, w18\n+ 5c8:   1e270233        fmov    s19, w17\n@@ -1257,1 +1257,1 @@\n- 648:   4c408d52        ld2     {v18.2d, v19.2d}, [x10]\n+ 648:   4c408d51        ld2     {v17.2d, v18.2d}, [x10]\n@@ -1259,1 +1259,1 @@\n- 650:   4d60c259        ld2r    {v25.16b, v26.16b}, [x18]\n+ 650:   4d60c239        ld2r    {v25.16b, v26.16b}, [x17]\n@@ -1261,1 +1261,1 @@\n- 658:   4de9ce50        ld2r    {v16.2d, v17.2d}, [x18], x9\n+ 658:   4de9ce30        ld2r    {v16.2d, v17.2d}, [x17], x9\n@@ -1269,1 +1269,1 @@\n- 678:   0d60e258        ld4r    {v24.8b-v27.8b}, [x18]\n+ 678:   0d60e238        ld4r    {v24.8b-v27.8b}, [x17]\n@@ -1320,1 +1320,1 @@\n- 744:   e5f25000        st1d    {z0.d}, p4, [x0, x18, lsl #3]\n+ 744:   e5f15000        st1d    {z0.d}, p4, [x0, x17, lsl #3]\n@@ -1365,1 +1365,1 @@\n- 7f8:   f8b28216        swpa    x18, x22, [x16]\n+ 7f8:   f8b08216        swpa    x16, x22, [x16]\n@@ -1381,1 +1381,1 @@\n- 838:   f8eb724b        lduminal        x11, x11, [x18]\n+ 838:   f8eb71eb        lduminal        x11, x11, [x15]\n@@ -1386,1 +1386,1 @@\n- 84c:   f8732250        ldeorl  x19, x16, [x18]\n+ 84c:   f87321f0        ldeorl  x19, x16, [x15]\n@@ -1408,1 +1408,1 @@\n- 8a4:   b8ac73f2        ldumina w12, w18, [sp]\n+ 8a4:   b8ac73f0        ldumina w12, w16, [sp]\n@@ -1416,1 +1416,1 @@\n- 8c4:   b8f24109        ldsmaxal        w18, w9, [x8]\n+ 8c4:   b8f04109        ldsmaxal        w16, w9, [x8]\n@@ -1422,1 +1422,1 @@\n- 8dc:   b86a2244        ldeorl  w10, w4, [x18]\n+ 8dc:   b86a21e4        ldeorl  w10, w4, [x15]\n@@ -1452,1 +1452,1 @@\n- 954:   6582b452        frintm  z18.s, p5\/m, z2.s\n+ 954:   6582b451        frintm  z17.s, p5\/m, z2.s\n@@ -1455,1 +1455,1 @@\n- 960:   658da632        fsqrt   z18.s, p1\/m, z17.s\n+ 960:   658da631        fsqrt   z17.s, p1\/m, z17.s\n@@ -1461,1 +1461,1 @@\n- 978:   04525f42        mla     z2.h, p7\/m, z26.h, z18.h\n+ 978:   04515f42        mla     z2.h, p7\/m, z26.h, z17.h\n@@ -1464,1 +1464,1 @@\n- 984:   04a33192        eor     z18.d, z12.d, z3.d\n+ 984:   04a33191        eor     z17.d, z12.d, z3.d\n@@ -1480,1 +1480,1 @@\n-    0x0b9b3ec9,     0x4b9279a3,     0x2b88474e,     0x6b8c56c0,\n+    0x0b9b3ec9,     0x4b9179a3,     0x2b88474e,     0x6b8c56c0,\n@@ -1482,1 +1482,1 @@\n-    0x0a5d4a19,     0x2a4b264d,     0x4a523ca5,     0x6a9b6ae2,\n+    0x0a5d4a19,     0x2a4b262d,     0x4a513ca5,     0x6a9b6ae2,\n@@ -1487,1 +1487,1 @@\n-    0x120cb166,     0x321764bc,     0x52174681,     0x720c0247,\n+    0x120cb166,     0x321764bc,     0x52174681,     0x720c0227,\n@@ -1518,1 +1518,1 @@\n-    0x880bfcd0,     0x885f7c12,     0x885ffd44,     0x889ffed8,\n+    0x880bfcd0,     0x885f7c11,     0x885ffd44,     0x889ffed8,\n@@ -1523,1 +1523,1 @@\n-    0xc82cb5f0,     0x887f55b2,     0x887ff90b,     0x88382c2d,\n+    0xc82cb5f0,     0x887f55b1,     0x887ff90b,     0x88382c2d,\n@@ -1525,1 +1525,1 @@\n-    0x781ce322,     0xf850f044,     0xb85e129e,     0x385e92f2,\n+    0x781ce322,     0xf850f044,     0xb85e129e,     0x385e92f1,\n@@ -1536,1 +1536,1 @@\n-    0xbc1df408,     0xf835da4a,     0xb836d9a4,     0x3833580d,\n+    0xbc1df408,     0xf835da2a,     0xb836d9a4,     0x3833580d,\n@@ -1538,1 +1538,1 @@\n-    0x78724889,     0x38a7789b,     0x78beca2f,     0x78f6c810,\n+    0x78714889,     0x38a7789b,     0x78beca2f,     0x78f6c810,\n@@ -1547,1 +1547,1 @@\n-    0xba1e030c,     0xda0f0320,     0xfa030301,     0x0b340b12,\n+    0xba1e030c,     0xda0f0320,     0xfa030301,     0x0b340b11,\n@@ -1550,1 +1550,1 @@\n-    0x7a5232c6,     0xba5e624e,     0xfa53814c,     0x3a52d8c2,\n+    0x7a5132c6,     0xba5e622e,     0xfa53814c,     0x3a52d8c2,\n@@ -1555,1 +1555,1 @@\n-    0xdac002b2,     0xdac0061d,     0xdac00a95,     0xdac00e66,\n+    0xdac002b1,     0xdac0061d,     0xdac00a95,     0xdac00e66,\n@@ -1557,3 +1557,3 @@\n-    0x1ad221c3,     0x1ad825e7,     0x1ad92a3c,     0x1adc2f42,\n-    0x9ada0b25,     0x9ad20e1b,     0x9acc22a6,     0x9acc2480,\n-    0x9adc2a3b,     0x9ad22c5c,     0x9bce7dea,     0x9b597c6e,\n+    0x1ad121c3,     0x1ad825e7,     0x1ad92a3c,     0x1adc2f42,\n+    0x9ada0b25,     0x9ad10e1b,     0x9acc22a6,     0x9acc2480,\n+    0x9adc2a3b,     0x9ad12c5c,     0x9bce7dea,     0x9b597c6e,\n@@ -1568,1 +1568,1 @@\n-    0x1e60c027,     0x1e61400b,     0x1e61c243,     0x1e6240dc,\n+    0x1e60c027,     0x1e61400b,     0x1e61c223,     0x1e6240dc,\n@@ -1571,1 +1571,1 @@\n-    0x1e2602b2,     0x9e660299,     0x1e270253,     0x9e6703a2,\n+    0x1e2602b1,     0x9e660299,     0x1e270233,     0x9e6703a2,\n@@ -1579,2 +1579,2 @@\n-    0x4ddfcaf8,     0x0dd9ccaa,     0x4c408d52,     0x0cdf85ec,\n-    0x4d60c259,     0x0dffcbc1,     0x4de9ce50,     0x4cc24999,\n+    0x4ddfcaf8,     0x0dd9ccaa,     0x4c408d51,     0x0cdf85ec,\n+    0x4d60c239,     0x0dffcbc1,     0x4de9ce30,     0x4cc24999,\n@@ -1582,1 +1582,1 @@\n-    0x4cdf07b1,     0x0cc000fb,     0x0d60e258,     0x0dffe740,\n+    0x4cdf07b1,     0x0cc000fb,     0x0d60e238,     0x0dffe740,\n@@ -1595,1 +1595,1 @@\n-    0xe4a84fe0,     0xe5f25000,     0x858043e0,     0x85a043ff,\n+    0xe4a84fe0,     0xe5f15000,     0x858043e0,     0x85a043ff,\n@@ -1606,1 +1606,1 @@\n-    0xf82973b9,     0xf82b6194,     0xf8b28216,     0xf8b50358,\n+    0xf82973b9,     0xf82b6194,     0xf8b08216,     0xf8b50358,\n@@ -1610,2 +1610,2 @@\n-    0xf8fd513a,     0xf8fa41ec,     0xf8eb724b,     0xf8f96316,\n-    0xf8608171,     0xf86600dd,     0xf86512a5,     0xf8732250,\n+    0xf8fd513a,     0xf8fa41ec,     0xf8eb71eb,     0xf8f96316,\n+    0xf8608171,     0xf86600dd,     0xf86512a5,     0xf87321f0,\n@@ -1617,1 +1617,1 @@\n-    0xb8aa405a,     0xb8ac73f2,     0xb8a163ad,     0xb8e08193,\n+    0xb8aa405a,     0xb8ac73f0,     0xb8a163ad,     0xb8e08193,\n@@ -1619,2 +1619,2 @@\n-    0xb8e6535e,     0xb8f24109,     0xb8ec7280,     0xb8e16058,\n-    0xb8608309,     0xb87a03d0,     0xb86312ea,     0xb86a2244,\n+    0xb8e6535e,     0xb8f04109,     0xb8ec7280,     0xb8e16058,\n+    0xb8608309,     0xb87a03d0,     0xb86312ea,     0xb86a21e4,\n@@ -1628,4 +1628,4 @@\n-    0x04ddaebc,     0x6582b452,     0x6580ade6,     0x65c1b42c,\n-    0x658da632,     0x658195af,     0x65eb1f74,     0x65f723c3,\n-    0x65ba4b71,     0x65fe76c6,     0x04525f42,     0x04117056,\n-    0x04363338,     0x04a33192,     0x0470339d,     0x049a2b86,\n+    0x04ddaebc,     0x6582b451,     0x6580ade6,     0x65c1b42c,\n+    0x658da631,     0x658195af,     0x65eb1f74,     0x65f723c3,\n+    0x65ba4b71,     0x65fe76c6,     0x04515f42,     0x04117056,\n+    0x04363338,     0x04a33191,     0x0470339d,     0x049a2b86,\n@@ -1982,0 +1982,4 @@\n+\n+address Assembler::locate_next_instruction(address inst) {\n+  return inst + Assembler::instruction_size;\n+}\n","filename":"src\/hotspot\/cpu\/aarch64\/assembler_aarch64.cpp","additions":102,"deletions":98,"binary":false,"changes":200,"status":"modified"},{"patch":"@@ -31,0 +31,13 @@\n+#ifdef __GNUC__\n+\n+\/\/ __nop needs volatile so that compiler doesn't optimize it away\n+#define NOP() asm volatile (\"nop\");\n+\n+#elif defined(_MSC_VER)\n+\n+\/\/ Use MSVC instrinsic: https:\/\/docs.microsoft.com\/en-us\/cpp\/intrinsics\/arm64-intrinsics?view=vs-2019#I\n+#define NOP() __nop();\n+\n+#endif\n+\n+\n@@ -643,1 +656,1 @@\n-      asm volatile (\"nop\");\n+      NOP();\n@@ -683,0 +696,2 @@\n+  static address locate_next_instruction(address inst);\n+\n@@ -1558,0 +1573,5 @@\n+#ifdef _WIN64\n+\/\/ In MSVC, `mvn` is defined as a macro and it affects compilation\n+#undef mvn\n+#endif\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/assembler_aarch64.hpp","additions":21,"deletions":1,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-  pd_nof_caller_save_cpu_regs_frame_map = 19 - 2,  \/\/ number of registers killed by calls\n+  pd_nof_caller_save_cpu_regs_frame_map = 19 - 2 \/* rscratch1 and rscratch2 *\/ R18_RESERVED_ONLY(- 1),  \/\/ number of registers killed by calls\n@@ -50,2 +50,2 @@\n-  pd_first_callee_saved_reg = 19 - 2,\n-  pd_last_callee_saved_reg = 26 - 2,\n+  pd_first_callee_saved_reg = 19 - 2 \/* rscratch1 and rscratch2 *\/ R18_RESERVED_ONLY(- 1),\n+  pd_last_callee_saved_reg = 26 - 2 \/* rscratch1 and rscratch2 *\/ R18_RESERVED_ONLY(- 1),\n@@ -53,1 +53,1 @@\n-  pd_last_allocatable_cpu_reg = 16,\n+  pd_last_allocatable_cpu_reg = 16 R18_RESERVED_ONLY(- 1),\n@@ -63,1 +63,1 @@\n-  pd_last_cpu_reg = 16,\n+  pd_last_cpu_reg = 16 R18_RESERVED_ONLY(- 1),\n@@ -65,1 +65,1 @@\n-  pd_last_byte_reg = 16,\n+  pd_last_byte_reg = 16 R18_RESERVED_ONLY(- 1),\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_Defs_aarch64.hpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"precompiled.hpp\"\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_FpuStackSim_aarch64.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -184,1 +184,4 @@\n-  map_register(i, r18); r18_opr = LIR_OprFact::single_cpu(i); i++;\n+#ifndef R18_RESERVED\n+  \/\/ See comment in register_aarch64.hpp\n+  map_register(i, r18_tls); r18_opr = LIR_OprFact::single_cpu(i); i++;\n+#endif\n@@ -202,0 +205,5 @@\n+#ifdef R18_RESERVED\n+  \/\/ See comment in register_aarch64.hpp\n+  map_register(i, r18_tls); r18_opr = LIR_OprFact::single_cpu(i); i++;\n+#endif\n+\n@@ -230,0 +238,2 @@\n+#ifndef R18_RESERVED\n+  \/\/ See comment in register_aarch64.hpp\n@@ -231,0 +241,1 @@\n+#endif\n@@ -256,1 +267,1 @@\n-  r18_oop_opr = as_oop_opr(r18);\n+  r18_oop_opr = as_oop_opr(r18_tls);\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_FrameMap_aarch64.cpp","additions":13,"deletions":2,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -546,1 +546,1 @@\n-      DIFFERENCE, NEXT_WORD, SHORT_LOOP_TAIL, SHORT_LAST2, SHORT_LAST_INIT,\n+      DIFF, NEXT_WORD, SHORT_LOOP_TAIL, SHORT_LAST2, SHORT_LAST_INIT,\n@@ -637,1 +637,1 @@\n-    cbnz(rscratch2, DIFFERENCE);\n+    cbnz(rscratch2, DIFF);\n@@ -663,1 +663,1 @@\n-    b(DIFFERENCE);\n+    b(DIFF);\n@@ -666,1 +666,1 @@\n-    cbnz(rscratch2, DIFFERENCE);\n+    cbnz(rscratch2, DIFF);\n@@ -690,1 +690,1 @@\n-    bind(DIFFERENCE);\n+    bind(DIFF);\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"gc\/shenandoah\/shenandoahBarrierSet.hpp\"\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/shenandoah\/shenandoah_aarch64.ad","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -61,0 +61,9 @@\n+#if defined(_WIN64)\n+#define R18_RESERVED\n+#define R18_RESERVED_ONLY(code) code\n+#define NOT_R18_RESERVED(code)\n+#else\n+#define R18_RESERVED_ONLY(code)\n+#define NOT_R18_RESERVED(code) code\n+#endif\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/globalDefinitions_aarch64.hpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -29,14 +29,1 @@\n-\/\/ Interface for updating the instruction cache.  Whenever the VM\n-\/\/ modifies code, part of the processor instruction cache potentially\n-\/\/ has to be flushed.\n-\n-class ICache : public AbstractICache {\n- public:\n-  static void initialize();\n-  static void invalidate_word(address addr) {\n-    __builtin___clear_cache((char *)addr, (char *)(addr + 3));\n-  }\n-  static void invalidate_range(address start, int nbytes) {\n-    __builtin___clear_cache((char *)start, (char *)(start + nbytes));\n-  }\n-};\n+#include OS_CPU_HEADER(icache)\n","filename":"src\/hotspot\/cpu\/aarch64\/icache_aarch64.hpp","additions":1,"deletions":14,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -27,0 +27,3 @@\n+\n+#include \"precompiled.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n@@ -247,1 +250,4 @@\n-static void initLITables() __attribute__ ((constructor));\n+static void initLITables();\n+\/\/ Use an empty struct with a construtor as MSVC doesn't support `__attribute__ ((constructor))`\n+\/\/ See https:\/\/stackoverflow.com\/questions\/1113409\/attribute-constructor-equivalent-in-vc\n+static struct initLITables_t { initLITables_t(void) { initLITables(); } } _initLITables;\n","filename":"src\/hotspot\/cpu\/aarch64\/immediate_aarch64.cpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2654,0 +2654,8 @@\n+RegSet MacroAssembler::call_clobbered_registers() {\n+  RegSet regs = RegSet::range(r0, r17) - RegSet::of(rscratch1, rscratch2);\n+#ifndef R18_RESERVED\n+  regs += r18_tls;\n+#endif\n+  return regs;\n+}\n+\n@@ -2656,1 +2664,1 @@\n-  push(RegSet::range(r0, r18) - RegSet::of(rscratch1, rscratch2) - exclude, sp);\n+  push(call_clobbered_registers() - exclude, sp);\n@@ -2676,1 +2684,1 @@\n-  pop(RegSet::range(r0, r18) - RegSet::of(rscratch1, rscratch2) - exclude, sp);\n+  pop(call_clobbered_registers() - exclude, sp);\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -191,0 +191,7 @@\n+\/\/ Microsoft's MSVC team thinks that the __FUNCSIG__ is approximately (sympathy for calling conventions) equivalent to __PRETTY_FUNCTION__\n+\/\/ Also, from Clang patch: \"It is very similar to GCC's PRETTY_FUNCTION, except it prints the calling convention.\"\n+\/\/ https:\/\/reviews.llvm.org\/D3311\n+\n+#ifdef _WIN64\n+#define call_Unimplemented() _call_Unimplemented((address)__FUNCSIG__)\n+#else\n@@ -192,0 +199,1 @@\n+#endif\n@@ -199,1 +207,1 @@\n-  inline void cmp(Register Rd, unsigned imm) __attribute__ ((deprecated));\n+  inline void cmp(Register Rd, unsigned imm) = delete;\n@@ -473,0 +481,2 @@\n+  static RegSet call_clobbered_registers();\n+\n@@ -525,1 +535,1 @@\n-  void tbr(Condition cond, Register Rt, int bitpos, Label &dest, bool far = false) {\n+  void tbr(Condition cond, Register Rt, int bitpos, Label &dest, bool isfar = false) {\n@@ -528,1 +538,1 @@\n-    if (far)\n+    if (isfar)\n@@ -537,1 +547,1 @@\n-    if (far) {\n+    if (isfar) {\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":14,"deletions":4,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -692,1 +692,1 @@\n-      jz = r14, j = r15, twoOverPiBase = r16, i = r17, qBase = r18;\n+      jz = r14, j = r15, twoOverPiBase = r16, i = r17, qBase = r19;\n@@ -1424,0 +1424,6 @@\n+\n+  enter();\n+  \/\/ r19 is used in TemplateInterpreterGenerator::generate_math_entry\n+  RegSet saved_regs = RegSet::of(r19);\n+  push (saved_regs, sp);\n+\n@@ -1441,1 +1447,1 @@\n-      ret(lr);\n+      b(DONE);\n@@ -1448,1 +1454,1 @@\n-      ret(lr);\n+      b(DONE);\n@@ -1468,1 +1474,1 @@\n-      ret(lr);\n+      b(DONE);\n@@ -1477,1 +1483,1 @@\n-      ret(lr);\n+      b(DONE);\n@@ -1487,0 +1493,2 @@\n+    pop(saved_regs, sp);\n+    leave();\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64_trig.cpp","additions":13,"deletions":5,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-    \"r17\", \"r18\", \"r19\",\n+    \"r17\", \"r18_tls\", \"r19\",\n","filename":"src\/hotspot\/cpu\/aarch64\/register_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"utilities\/powerOfTwo.hpp\"\n@@ -94,1 +95,12 @@\n-CONSTANT_REGISTER_DECLARATION(Register, r18,  (18));\n+\n+\/\/ In the ABI for Windows+AArch64 the register r18 is used to store the pointer\n+\/\/ to the current thread's TEB (where TLS variables are stored). We could\n+\/\/ carefully save and restore r18 at key places, however Win32 Structured\n+\/\/ Exception Handling (SEH) is using TLS to unwind the stack. If r18 is used\n+\/\/ for any other purpose at the time of an exception happening, SEH would not\n+\/\/ be able to unwind the stack properly and most likely crash.\n+\/\/\n+\/\/ It's easier to avoid allocating r18 altogether.\n+\/\/\n+\/\/ See https:\/\/docs.microsoft.com\/en-us\/cpp\/build\/arm64-windows-abi-conventions?view=vs-2019#integer-registers\n+CONSTANT_REGISTER_DECLARATION(Register, r18_tls,  (18));\n@@ -295,0 +307,2 @@\n+class RegSetIterator;\n+\n@@ -353,0 +367,13 @@\n+\n+private:\n+\n+  Register first() {\n+    uint32_t first = _bitset & -_bitset;\n+    return first ? as_Register(exact_log2(first)) : noreg;\n+  }\n+\n+public:\n+\n+  friend class RegSetIterator;\n+\n+  RegSetIterator begin();\n@@ -355,0 +382,30 @@\n+class RegSetIterator {\n+  RegSet _regs;\n+\n+public:\n+  RegSetIterator(RegSet x): _regs(x) {}\n+  RegSetIterator(const RegSetIterator& mit) : _regs(mit._regs) {}\n+\n+  RegSetIterator& operator++() {\n+    Register r = _regs.first();\n+    if (r != noreg)\n+      _regs -= r;\n+    return *this;\n+  }\n+\n+  bool operator==(const RegSetIterator& rhs) const {\n+    return _regs.bits() == rhs._regs.bits();\n+  }\n+  bool operator!=(const RegSetIterator& rhs) const {\n+    return ! (rhs == *this);\n+  }\n+\n+  Register operator*() {\n+    return _regs.first();\n+  }\n+};\n+\n+inline RegSetIterator RegSet::begin() {\n+  return RegSetIterator(*this);\n+}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/register_aarch64.hpp","additions":58,"deletions":1,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n-REGISTER_DEFINITION(Register, r18);\n+REGISTER_DEFINITION(Register, r18_tls); \/\/ see comment in register_aarch64.hpp\n","filename":"src\/hotspot\/cpu\/aarch64\/register_definitions_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1095,1 +1095,1 @@\n-    const Register send = r17, dend = r18;\n+    const Register send = r17, dend = r16;\n@@ -1285,0 +1285,2 @@\n+    RegSet clobbered\n+      = MacroAssembler::call_clobbered_registers() - rscratch1;\n@@ -1287,2 +1289,3 @@\n-    for (Register r = r3; r <= r18; r++)\n-      if (r != rscratch1) __ mov(r, rscratch1);\n+    for (RegSetIterator it = clobbered.begin(); *it != noreg; ++it) {\n+      __ mov(*it, rscratch1);\n+    }\n@@ -1290,0 +1293,1 @@\n+\n@@ -1722,1 +1726,2 @@\n-    \/\/ Registers used as temps (r18, r19, r20 are save-on-entry)\n+    \/\/ Registers used as temps (r19, r20, r21, r22 are save-on-entry)\n+    const Register copied_oop  = r22;       \/\/ actual oop copied\n@@ -1725,1 +1730,0 @@\n-    const Register copied_oop  = r18;       \/\/ actual oop copied\n@@ -1762,2 +1766,1 @@\n-\n-    __ push(RegSet::of(r18, r19, r20, r21), sp);\n+    __ push(RegSet::of(r19, r20, r21, r22), sp);\n@@ -1832,1 +1835,1 @@\n-    __ pop(RegSet::of(r18, r19, r20, r21), sp);\n+    __ pop(RegSet::of(r19, r20, r21, r22), sp);\n@@ -2009,1 +2012,1 @@\n-    const Register lh                = r18; \/\/ layout helper\n+    const Register lh                = r15; \/\/ layout helper\n@@ -2080,1 +2083,1 @@\n-    const Register r18_elsize = lh; \/\/ element size\n+    const Register r15_elsize = lh; \/\/ element size\n@@ -2101,2 +2104,2 @@\n-    __ tbnz(r18_elsize, 1, L_copy_ints);\n-    __ tbnz(r18_elsize, 0, L_copy_shorts);\n+    __ tbnz(r15_elsize, 1, L_copy_ints);\n+    __ tbnz(r15_elsize, 0, L_copy_shorts);\n@@ -2115,1 +2118,1 @@\n-    __ tbnz(r18_elsize, 0, L_copy_longs);\n+    __ tbnz(r15_elsize, 0, L_copy_longs);\n@@ -2126,2 +2129,2 @@\n-      __ andw(lh, lh, Klass::_lh_log2_element_size_mask); \/\/ lh -> r18_elsize\n-      __ cmpw(r18_elsize, LogBytesPerLong);\n+      __ andw(lh, lh, Klass::_lh_log2_element_size_mask); \/\/ lh -> r15_elsize\n+      __ cmpw(r15_elsize, LogBytesPerLong);\n@@ -2145,2 +2148,2 @@\n-    __ load_klass(r18, dst);\n-    __ cmp(scratch_src_klass, r18); \/\/ usual case is exact equality\n+    __ load_klass(r15, dst);\n+    __ cmp(scratch_src_klass, r15); \/\/ usual case is exact equality\n@@ -2162,1 +2165,1 @@\n-    \/\/ live at this point:  scratch_src_klass, scratch_length, r18 (dst_klass)\n+    \/\/ live at this point:  scratch_src_klass, scratch_length, r15 (dst_klass)\n@@ -2165,1 +2168,1 @@\n-      __ ldrw(rscratch1, Address(r18, lh_offset));\n+      __ ldrw(rscratch1, Address(r15, lh_offset));\n@@ -2172,1 +2175,1 @@\n-                             r18, L_failed);\n+                             r15, L_failed);\n@@ -5069,2 +5072,2 @@\n-      Register reg = c_rarg0;\n-      Pa_base = reg;       \/\/ Argument registers\n+      RegSetIterator regs = (RegSet::range(r0, r26) - r18_tls).begin();\n+      Pa_base = *regs;       \/\/ Argument registers\n@@ -5074,5 +5077,5 @@\n-        Pb_base = ++reg;\n-      Pn_base = ++reg;\n-      Rlen= ++reg;\n-      inv = ++reg;\n-      Pm_base = ++reg;\n+        Pb_base = *++regs;\n+      Pn_base = *++regs;\n+      Rlen= *++regs;\n+      inv = *++regs;\n+      Pm_base = *++regs;\n@@ -5081,4 +5084,4 @@\n-      Ra =  ++reg;        \/\/ The current digit of a, b, n, and m.\n-      Rb =  ++reg;\n-      Rm =  ++reg;\n-      Rn =  ++reg;\n+      Ra =  *++regs;        \/\/ The current digit of a, b, n, and m.\n+      Rb =  *++regs;\n+      Rm =  *++regs;\n+      Rn =  *++regs;\n@@ -5086,4 +5089,4 @@\n-      Pa =  ++reg;        \/\/ Pointers to the current\/next digit of a, b, n, and m.\n-      Pb =  ++reg;\n-      Pm =  ++reg;\n-      Pn =  ++reg;\n+      Pa =  *++regs;        \/\/ Pointers to the current\/next digit of a, b, n, and m.\n+      Pb =  *++regs;\n+      Pm =  *++regs;\n+      Pn =  *++regs;\n@@ -5091,3 +5094,3 @@\n-      t0 =  ++reg;        \/\/ Three registers which form a\n-      t1 =  ++reg;        \/\/ triple-precision accumuator.\n-      t2 =  ++reg;\n+      t0 =  *++regs;        \/\/ Three registers which form a\n+      t1 =  *++regs;        \/\/ triple-precision accumuator.\n+      t2 =  *++regs;\n@@ -5095,2 +5098,2 @@\n-      Ri =  ++reg;        \/\/ Inner and outer loop indexes.\n-      Rj =  ++reg;\n+      Ri =  *++regs;        \/\/ Inner and outer loop indexes.\n+      Rj =  *++regs;\n@@ -5098,4 +5101,4 @@\n-      Rhi_ab = ++reg;     \/\/ Product registers: low and high parts\n-      Rlo_ab = ++reg;     \/\/ of a*b and m*n.\n-      Rhi_mn = ++reg;\n-      Rlo_mn = ++reg;\n+      Rhi_ab = *++regs;     \/\/ Product registers: low and high parts\n+      Rlo_ab = *++regs;     \/\/ of a*b and m*n.\n+      Rhi_mn = *++regs;\n+      Rlo_mn = *++regs;\n@@ -5104,1 +5107,1 @@\n-      _toSave = RegSet::range(r19, reg) + Pm_base;\n+      _toSave = RegSet::range(r19, *regs) + Pm_base;\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":48,"deletions":45,"binary":false,"changes":93,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+#include \"precompiled.hpp\"\n","filename":"src\/hotspot\/cpu\/aarch64\/vm_version_ext_aarch64.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"code\/nativeInst.hpp\"\n@@ -122,1 +123,3 @@\n-#ifdef _M_AMD64\n+#if defined(_M_ARM64)\n+  #define __CPU__ aarch64\n+#elif defined(_M_AMD64)\n@@ -128,1 +131,4 @@\n-#if INCLUDE_AOT\n+#if defined(USE_VECTORED_EXCEPTION_HANDLING)\n+PVOID  topLevelVectoredExceptionHandler = NULL;\n+LPTOP_LEVEL_EXCEPTION_FILTER previousUnhandledExceptionFilter = NULL;\n+#elif INCLUDE_AOT\n@@ -151,1 +157,1 @@\n-#if INCLUDE_AOT\n+#if defined(USE_VECTORED_EXCEPTION_HANDLING) || INCLUDE_AOT\n@@ -460,0 +466,6 @@\n+#ifdef USE_VECTORED_EXCEPTION_HANDLING\n+  \/\/ Any exception is caught by the Vectored Exception Handler, so VM can\n+  \/\/ generate error dump when an exception occurred in non-Java thread\n+  \/\/ (e.g. VM thread).\n+  thread->call_run();\n+#else\n@@ -469,0 +481,1 @@\n+#endif\n@@ -1431,1 +1444,2 @@\n-    {IMAGE_FILE_MACHINE_AMD64,     (char*)\"AMD 64\"}\n+    {IMAGE_FILE_MACHINE_AMD64,     (char*)\"AMD 64\"},\n+    {IMAGE_FILE_MACHINE_ARM64,     (char*)\"ARM 64\"}\n@@ -1433,1 +1447,3 @@\n-#if (defined _M_AMD64)\n+#if (defined _M_ARM64)\n+  static const uint16_t running_arch = IMAGE_FILE_MACHINE_ARM64;\n+#elif (defined _M_AMD64)\n@@ -1439,1 +1455,1 @@\n-         is defined :_M_AMD64 or _M_IX86\n+         is defined :_M_AMD64 or _M_IX86 or _M_ARM64\n@@ -1734,1 +1750,2 @@\n-  if (si.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_AMD64) {\n+  if ((si.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_AMD64) ||\n+      (si.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_ARM64)) {\n@@ -2142,1 +2159,8 @@\n-#ifdef _M_AMD64\n+#if defined(_M_ARM64)\n+  \/\/ Do not blow up if no thread info available.\n+  if (thread) {\n+    thread->as_Java_thread()->set_saved_exception_pc((address)(DWORD_PTR)exceptionInfo->ContextRecord->Pc);\n+  }\n+  \/\/ Set pc to handler\n+  exceptionInfo->ContextRecord->Pc = (DWORD64)handler;\n+#elif defined(_M_AMD64)\n@@ -2240,1 +2264,11 @@\n-#ifdef  _M_AMD64\n+#if defined(_M_ARM64)\n+  PCONTEXT ctx = exceptionInfo->ContextRecord;\n+  address pc = (address)ctx->Sp;\n+  assert(pc[0] == 0x83, \"not an sdiv opcode\"); \/\/Fixme did i get the right opcode?\n+  assert(ctx->X4 == min_jint, \"unexpected idiv exception\");\n+  \/\/ set correct result values and continue after idiv instruction\n+  ctx->Pc = (uint64_t)pc + 4;        \/\/ idiv reg, reg, reg  is 4 bytes\n+  ctx->X4 = (uint64_t)min_jint;      \/\/ result\n+  ctx->X5 = (uint64_t)0;             \/\/ remainder\n+  \/\/ Continue the execution\n+#elif defined(_M_AMD64)\n@@ -2271,0 +2305,1 @@\n+#if defined(_M_AMD64) || defined(_M_IX86)\n@@ -2316,0 +2351,1 @@\n+#endif\n@@ -2325,54 +2361,0 @@\n-bool os::win32::get_frame_at_stack_banging_point(JavaThread* thread,\n-        struct _EXCEPTION_POINTERS* exceptionInfo, address pc, frame* fr) {\n-  PEXCEPTION_RECORD exceptionRecord = exceptionInfo->ExceptionRecord;\n-  address addr = (address) exceptionRecord->ExceptionInformation[1];\n-  if (Interpreter::contains(pc)) {\n-    *fr = os::fetch_frame_from_context((void*)exceptionInfo->ContextRecord);\n-    if (!fr->is_first_java_frame()) {\n-      \/\/ get_frame_at_stack_banging_point() is only called when we\n-      \/\/ have well defined stacks so java_sender() calls do not need\n-      \/\/ to assert safe_for_sender() first.\n-      *fr = fr->java_sender();\n-    }\n-  } else {\n-    \/\/ more complex code with compiled code\n-    assert(!Interpreter::contains(pc), \"Interpreted methods should have been handled above\");\n-    CodeBlob* cb = CodeCache::find_blob(pc);\n-    if (cb == NULL || !cb->is_nmethod() || cb->is_frame_complete_at(pc)) {\n-      \/\/ Not sure where the pc points to, fallback to default\n-      \/\/ stack overflow handling\n-      return false;\n-    } else {\n-      *fr = os::fetch_frame_from_context((void*)exceptionInfo->ContextRecord);\n-      \/\/ in compiled code, the stack banging is performed just after the return pc\n-      \/\/ has been pushed on the stack\n-      *fr = frame(fr->sp() + 1, fr->fp(), (address)*(fr->sp()));\n-      if (!fr->is_java_frame()) {\n-        \/\/ See java_sender() comment above.\n-        *fr = fr->java_sender();\n-      }\n-    }\n-  }\n-  assert(fr->is_java_frame(), \"Safety check\");\n-  return true;\n-}\n-\n-#if INCLUDE_AOT\n-LONG WINAPI topLevelVectoredExceptionFilter(struct _EXCEPTION_POINTERS* exceptionInfo) {\n-  PEXCEPTION_RECORD exceptionRecord = exceptionInfo->ExceptionRecord;\n-  address addr = (address) exceptionRecord->ExceptionInformation[1];\n-  address pc = (address) exceptionInfo->ContextRecord->Rip;\n-\n-  \/\/ Handle the case where we get an implicit exception in AOT generated\n-  \/\/ code.  AOT DLL's loaded are not registered for structured exceptions.\n-  \/\/ If the exception occurred in the codeCache or AOT code, pass control\n-  \/\/ to our normal exception handler.\n-  CodeBlob* cb = CodeCache::find_blob(pc);\n-  if (cb != NULL) {\n-    return topLevelExceptionFilter(exceptionInfo);\n-  }\n-\n-  return EXCEPTION_CONTINUE_SEARCH;\n-}\n-#endif\n-\n@@ -2384,1 +2366,3 @@\n-#ifdef _M_AMD64\n+#if defined(_M_ARM64)\n+  address pc = (address) exceptionInfo->ContextRecord->Pc;\n+#elif defined(_M_AMD64)\n@@ -2467,0 +2451,1 @@\n+#if !defined(USE_VECTORED_EXCEPTION_HANDLING)\n@@ -2469,0 +2454,1 @@\n+#endif\n@@ -2474,0 +2460,1 @@\n+#if defined(_M_AMD64) || defined(_M_IX86)\n@@ -2479,0 +2466,1 @@\n+#endif\n@@ -2509,0 +2497,1 @@\n+#if !defined(USE_VECTORED_EXCEPTION_HANDLING)\n@@ -2511,0 +2500,1 @@\n+#endif\n@@ -2566,0 +2556,1 @@\n+#if !defined(USE_VECTORED_EXCEPTION_HANDLING)\n@@ -2568,0 +2559,1 @@\n+#endif\n@@ -2590,0 +2582,13 @@\n+#ifdef _M_ARM64\n+    if (in_java &&\n+        (exception_code == EXCEPTION_ILLEGAL_INSTRUCTION ||\n+          exception_code == EXCEPTION_ILLEGAL_INSTRUCTION_2)) {\n+      if (nativeInstruction_at(pc)->is_sigill_zombie_not_entrant()) {\n+        if (TraceTraps) {\n+          tty->print_cr(\"trap: zombie_not_entrant\");\n+        }\n+        return Handle_Exception(exceptionInfo, SharedRuntime::get_handle_wrong_method_stub());\n+      }\n+    }\n+#endif\n+\n@@ -2600,0 +2605,2 @@\n+\n+#if defined(_M_AMD64) || defined(_M_IX86)\n@@ -2604,0 +2611,1 @@\n+#endif\n@@ -2606,0 +2614,1 @@\n+#if !defined(USE_VECTORED_EXCEPTION_HANDLING)\n@@ -2610,0 +2619,1 @@\n+#endif\n@@ -2613,0 +2623,51 @@\n+#if defined(USE_VECTORED_EXCEPTION_HANDLING) || INCLUDE_AOT\n+LONG WINAPI topLevelVectoredExceptionFilter(struct _EXCEPTION_POINTERS* exceptionInfo) {\n+  PEXCEPTION_RECORD exceptionRecord = exceptionInfo->ExceptionRecord;\n+#if defined(_M_ARM64)\n+  address pc = (address) exceptionInfo->ContextRecord->Pc;\n+#elif defined(_M_AMD64)\n+  address pc = (address) exceptionInfo->ContextRecord->Rip;\n+#else\n+  address pc = (address) exceptionInfo->ContextRecord->Eip;\n+#endif\n+\n+  \/\/ Fast path for code part of the code cache\n+  if (CodeCache::low_bound() <= pc && pc < CodeCache::high_bound()) {\n+    return topLevelExceptionFilter(exceptionInfo);\n+  }\n+\n+  \/\/ Handle the case where we get an implicit exception in AOT generated\n+  \/\/ code.  AOT DLL's loaded are not registered for structured exceptions.\n+  \/\/ If the exception occurred in the codeCache or AOT code, pass control\n+  \/\/ to our normal exception handler.\n+  CodeBlob* cb = CodeCache::find_blob(pc);\n+  if (cb != NULL) {\n+    return topLevelExceptionFilter(exceptionInfo);\n+  }\n+\n+  return EXCEPTION_CONTINUE_SEARCH;\n+}\n+#endif\n+\n+#if defined(USE_VECTORED_EXCEPTION_HANDLING)\n+LONG WINAPI topLevelUnhandledExceptionFilter(struct _EXCEPTION_POINTERS* exceptionInfo) {\n+  if (InterceptOSException) goto exit;\n+  DWORD exception_code = exceptionInfo->ExceptionRecord->ExceptionCode;\n+#if defined(_M_ARM64)\n+  address pc = (address)exceptionInfo->ContextRecord->Pc;\n+#elif defined(_M_AMD64)\n+  address pc = (address) exceptionInfo->ContextRecord->Rip;\n+#else\n+  address pc = (address) exceptionInfo->ContextRecord->Eip;\n+#endif\n+  Thread* t = Thread::current_or_null_safe();\n+\n+  if (exception_code != EXCEPTION_BREAKPOINT) {\n+    report_error(t, exception_code, pc, exceptionInfo->ExceptionRecord,\n+                exceptionInfo->ContextRecord);\n+  }\n+exit:\n+  return previousUnhandledExceptionFilter ? previousUnhandledExceptionFilter(exceptionInfo) : EXCEPTION_CONTINUE_SEARCH;\n+}\n+#endif\n+\n@@ -3459,0 +3520,4 @@\n+#ifdef _M_ARM64\n+  \/\/ AArch64 has a maximum addressable space of 48-bits\n+  return (char*)((1ull << 48) - 1);\n+#else\n@@ -3460,0 +3525,1 @@\n+#endif\n@@ -3983,1 +4049,4 @@\n-#if INCLUDE_AOT\n+#if defined(USE_VECTORED_EXCEPTION_HANDLING)\n+  topLevelVectoredExceptionHandler = AddVectoredExceptionHandler(1, topLevelVectoredExceptionFilter);\n+  previousUnhandledExceptionFilter = SetUnhandledExceptionFilter(topLevelUnhandledExceptionFilter);\n+#elif INCLUDE_AOT\n@@ -5450,1 +5519,1 @@\n-#elif defined (AMD64)\n+#elif defined(AMD64) || defined(_M_ARM64)\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":135,"deletions":66,"binary":false,"changes":201,"status":"modified"},{"patch":"@@ -0,0 +1,44 @@\n+\/*\n+ * Copyright (c) 1999, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef OS_CPU_LINUX_AARCH64_ICACHE_AARCH64_HPP\n+#define OS_CPU_LINUX_AARCH64_ICACHE_AARCH64_HPP\n+\n+\/\/ Interface for updating the instruction cache.  Whenever the VM\n+\/\/ modifies code, part of the processor instruction cache potentially\n+\/\/ has to be flushed.\n+\n+class ICache : public AbstractICache {\n+ public:\n+  static void initialize();\n+  static void invalidate_word(address addr) {\n+    __builtin___clear_cache((char *)addr, (char *)(addr + 4));\n+  }\n+  static void invalidate_range(address start, int nbytes) {\n+    __builtin___clear_cache((char *)start, (char *)(start + nbytes));\n+  }\n+};\n+\n+#endif \/\/ OS_CPU_LINUX_AARCH64_ICACHE_AARCH64_HPP\n\\ No newline at end of file\n","filename":"src\/hotspot\/os_cpu\/linux_aarch64\/icache_linux_aarch64.hpp","additions":44,"deletions":0,"binary":false,"changes":44,"status":"added"},{"patch":"@@ -0,0 +1,26 @@\n+\/*\n+ * Copyright (c) 2020, Microsoft Corporation. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/\/ nothing required here\n+#include \"precompiled.hpp\"\n","filename":"src\/hotspot\/os_cpu\/windows_aarch64\/assembler_windows_aarch64.cpp","additions":26,"deletions":0,"binary":false,"changes":26,"status":"added"},{"patch":"@@ -0,0 +1,111 @@\n+\/*\n+ * Copyright (c) 2020, Microsoft Corporation. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef OS_CPU_WINDOWS_AARCH64_ATOMIC_WINDOWS_AARCH64_HPP\n+#define OS_CPU_WINDOWS_AARCH64_ATOMIC_WINDOWS_AARCH64_HPP\n+\n+#include <intrin.h>\n+#include \"runtime\/os.hpp\"\n+#include \"runtime\/vm_version.hpp\"\n+\n+\n+\/\/ As per atomic.hpp all read-modify-write operations have to provide two-way\n+\/\/ barriers semantics. The memory_order parameter is ignored - we always provide\n+\/\/ the strongest\/most-conservative ordering\n+\/\/\n+\/\/ For AARCH64 we add explicit barriers in the stubs.\n+\n+template<size_t byte_size>\n+struct Atomic::PlatformAdd {\n+  template<typename D, typename I>\n+  D add_and_fetch(D volatile* dest, I add_value, atomic_memory_order order) const;\n+\n+  template<typename D, typename I>\n+  D fetch_and_add(D volatile* dest, I add_value, atomic_memory_order order) const {\n+    return add_and_fetch(dest, add_value, order) - add_value;\n+  }\n+};\n+\n+\/\/ The Interlocked* APIs only take long and will not accept __int32. That is\n+\/\/ acceptable on Windows, since long is a 32-bits integer type.\n+\n+#define DEFINE_INTRINSIC_ADD(IntrinsicName, IntrinsicType)                \\\n+  template<>                                                              \\\n+  template<typename D, typename I>                                        \\\n+  inline D Atomic::PlatformAdd<sizeof(IntrinsicType)>::add_and_fetch(D volatile* dest, \\\n+                                                                     I add_value, \\\n+                                                                     atomic_memory_order order) const { \\\n+    STATIC_ASSERT(sizeof(IntrinsicType) == sizeof(D));                    \\\n+    return PrimitiveConversions::cast<D>(                                 \\\n+      IntrinsicName(reinterpret_cast<IntrinsicType volatile *>(dest),     \\\n+                    PrimitiveConversions::cast<IntrinsicType>(add_value))); \\\n+  }\n+\n+DEFINE_INTRINSIC_ADD(InterlockedAdd,   long)\n+DEFINE_INTRINSIC_ADD(InterlockedAdd64, __int64)\n+\n+#undef DEFINE_INTRINSIC_ADD\n+\n+#define DEFINE_INTRINSIC_XCHG(IntrinsicName, IntrinsicType)               \\\n+  template<>                                                              \\\n+  template<typename T>                                                    \\\n+  inline T Atomic::PlatformXchg<sizeof(IntrinsicType)>::operator()(T volatile* dest, \\\n+                                                                   T exchange_value, \\\n+                                                                   atomic_memory_order order) const { \\\n+    STATIC_ASSERT(sizeof(IntrinsicType) == sizeof(T));                    \\\n+    return PrimitiveConversions::cast<T>(                                 \\\n+      IntrinsicName(reinterpret_cast<IntrinsicType volatile *>(dest),     \\\n+                    PrimitiveConversions::cast<IntrinsicType>(exchange_value))); \\\n+  }\n+\n+DEFINE_INTRINSIC_XCHG(InterlockedExchange,   long)\n+DEFINE_INTRINSIC_XCHG(InterlockedExchange64, __int64)\n+\n+#undef DEFINE_INTRINSIC_XCHG\n+\n+\/\/ Note: the order of the parameters is different between\n+\/\/ Atomic::PlatformCmpxchg<*>::operator() and the\n+\/\/ InterlockedCompareExchange* API.\n+\n+#define DEFINE_INTRINSIC_CMPXCHG(IntrinsicName, IntrinsicType)            \\\n+  template<>                                                              \\\n+  template<typename T>                                                    \\\n+  inline T Atomic::PlatformCmpxchg<sizeof(IntrinsicType)>::operator()(T volatile* dest, \\\n+                                                                      T compare_value, \\\n+                                                                      T exchange_value, \\\n+                                                                      atomic_memory_order order) const { \\\n+    STATIC_ASSERT(sizeof(IntrinsicType) == sizeof(T));                    \\\n+    return PrimitiveConversions::cast<T>(                                 \\\n+      IntrinsicName(reinterpret_cast<IntrinsicType volatile *>(dest),     \\\n+                    PrimitiveConversions::cast<IntrinsicType>(exchange_value), \\\n+                    PrimitiveConversions::cast<IntrinsicType>(compare_value))); \\\n+  }\n+\n+DEFINE_INTRINSIC_CMPXCHG(_InterlockedCompareExchange8, char) \/\/ Use the intrinsic as InterlockedCompareExchange8 does not exist\n+DEFINE_INTRINSIC_CMPXCHG(InterlockedCompareExchange,   long)\n+DEFINE_INTRINSIC_CMPXCHG(InterlockedCompareExchange64, __int64)\n+\n+#undef DEFINE_INTRINSIC_CMPXCHG\n+\n+#endif \/\/ OS_CPU_WINDOWS_AARCH64_ATOMIC_WINDOWS_AARCH64_HPP\n","filename":"src\/hotspot\/os_cpu\/windows_aarch64\/atomic_windows_aarch64.hpp","additions":111,"deletions":0,"binary":false,"changes":111,"status":"added"},{"patch":"@@ -0,0 +1,46 @@\n+\/*\n+ * Copyright (c) 2020, Microsoft Corporation. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef OS_CPU_WINDOWS_AARCH64_BYTES_WINDOWS_AARCH64_INLINE_HPP\n+#define OS_CPU_WINDOWS_AARCH64_BYTES_WINDOWS_AARCH64_INLINE_HPP\n+\n+#include <stdlib.h>\n+\n+\/\/ Efficient swapping of data bytes from Java byte\n+\/\/ ordering to native byte ordering and vice versa.\n+inline u2   Bytes::swap_u2(u2 x) {\n+  return _byteswap_ushort(x);\n+}\n+\n+inline u4   Bytes::swap_u4(u4 x) {\n+  return _byteswap_ulong(x);\n+}\n+\n+inline u8 Bytes::swap_u8(u8 x) {\n+  return _byteswap_uint64(x);\n+}\n+\n+#pragma warning(default: 4035) \/\/ Enable warning 4035: no return value\n+\n+#endif \/\/ OS_CPU_WINDOWS_AARCH64_BYTES_WINDOWS_AARCH64_INLINE_HPP\n","filename":"src\/hotspot\/os_cpu\/windows_aarch64\/bytes_windows_aarch64.inline.hpp","additions":46,"deletions":0,"binary":false,"changes":46,"status":"added"},{"patch":"@@ -0,0 +1,158 @@\n+\/*\n+ * Copyright (c) 2020, Microsoft Corporation. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef OS_CPU_WINDOWS_AARCH64_COPY_WINDOWS_AARCH64_INLINE_HPP\n+#define OS_CPU_WINDOWS_AARCH64_COPY_WINDOWS_AARCH64_INLINE_HPP\n+\n+#include <string.h>\n+\n+static void pd_conjoint_words(const HeapWord* from, HeapWord* to, size_t count) {\n+  (void)memmove(to, from, count * HeapWordSize);\n+}\n+\n+static void pd_disjoint_words(const HeapWord* from, HeapWord* to, size_t count) {\n+  switch (count) {\n+  case 8:  to[7] = from[7];\n+  case 7:  to[6] = from[6];\n+  case 6:  to[5] = from[5];\n+  case 5:  to[4] = from[4];\n+  case 4:  to[3] = from[3];\n+  case 3:  to[2] = from[2];\n+  case 2:  to[1] = from[1];\n+  case 1:  to[0] = from[0];\n+  case 0:  break;\n+  default:\n+    (void)memcpy(to, from, count * HeapWordSize);\n+    break;\n+  }\n+}\n+\n+static void pd_disjoint_words_atomic(const HeapWord* from, HeapWord* to, size_t count) {\n+  switch (count) {\n+  case 8:  to[7] = from[7];\n+  case 7:  to[6] = from[6];\n+  case 6:  to[5] = from[5];\n+  case 5:  to[4] = from[4];\n+  case 4:  to[3] = from[3];\n+  case 3:  to[2] = from[2];\n+  case 2:  to[1] = from[1];\n+  case 1:  to[0] = from[0];\n+  case 0:  break;\n+  default: while (count-- > 0) {\n+             *to++ = *from++;\n+           }\n+           break;\n+  }\n+}\n+\n+static void pd_aligned_conjoint_words(const HeapWord* from, HeapWord* to, size_t count) {\n+ \/\/ pd_conjoint_words(from, to, count);\n+  (void)memmove(to, from, count * HeapWordSize);\n+}\n+\n+static void pd_aligned_disjoint_words(const HeapWord* from, HeapWord* to, size_t count) {\n+  pd_disjoint_words(from, to, count);\n+}\n+\n+static void pd_conjoint_bytes(const void* from, void* to, size_t count) {\n+  (void)memmove(to, from, count);\n+}\n+\n+static void pd_conjoint_bytes_atomic(const void* from, void* to, size_t count) {\n+  pd_conjoint_bytes(from, to, count);\n+}\n+\n+static void pd_conjoint_jshorts_atomic(const jshort* from, jshort* to, size_t count) {\n+  if (from > to) {\n+    while (count-- > 0) {\n+      \/\/ Copy forwards\n+      *to++ = *from++;\n+    }\n+  } else {\n+    from += count - 1;\n+    to   += count - 1;\n+    while (count-- > 0) {\n+      \/\/ Copy backwards\n+      *to-- = *from--;\n+    }\n+  }\n+}\n+\n+static void pd_conjoint_jints_atomic(const jint* from, jint* to, size_t count) {\n+  if (from > to) {\n+    while (count-- > 0) {\n+      \/\/ Copy forwards\n+      *to++ = *from++;\n+    }\n+  } else {\n+    from += count - 1;\n+    to   += count - 1;\n+    while (count-- > 0) {\n+      \/\/ Copy backwards\n+      *to-- = *from--;\n+    }\n+  }\n+}\n+\n+static void pd_conjoint_jlongs_atomic(const jlong* from, jlong* to, size_t count) {\n+  pd_conjoint_oops_atomic((const oop*)from, (oop*)to, count);\n+}\n+\n+static void pd_conjoint_oops_atomic(const oop* from, oop* to, size_t count) {\n+ if (from > to) {\n+    while (count-- > 0) {\n+      \/\/ Copy forwards\n+      *to++ = *from++;\n+    }\n+  } else {\n+    from += count - 1;\n+    to   += count - 1;\n+    while (count-- > 0) {\n+      \/\/ Copy backwards\n+      *to-- = *from--;\n+    }\n+  }\n+}\n+\n+static void pd_arrayof_conjoint_bytes(const HeapWord* from, HeapWord* to, size_t count) {\n+  pd_conjoint_bytes_atomic(from, to, count);\n+}\n+\n+static void pd_arrayof_conjoint_jshorts(const HeapWord* from, HeapWord* to, size_t count) {\n+  pd_conjoint_jshorts_atomic((const jshort*)from, (jshort*)to, count);\n+}\n+\n+static void pd_arrayof_conjoint_jints(const HeapWord* from, HeapWord* to, size_t count) {\n+  pd_conjoint_jints_atomic((const jint*)from, (jint*)to, count);\n+}\n+\n+static void pd_arrayof_conjoint_jlongs(const HeapWord* from, HeapWord* to, size_t count) {\n+  pd_conjoint_jlongs_atomic((const jlong*)from, (jlong*)to, count);\n+}\n+\n+static void pd_arrayof_conjoint_oops(const HeapWord* from, HeapWord* to, size_t count) {\n+ pd_conjoint_oops_atomic((const oop*)from, (oop*)to, count);\n+}\n+\n+#endif \/\/ OS_CPU_WINDOWS_AARCH64_COPY_WINDOWS_AARCH64_INLINE_HPP\n","filename":"src\/hotspot\/os_cpu\/windows_aarch64\/copy_windows_aarch64.inline.hpp","additions":158,"deletions":0,"binary":false,"changes":158,"status":"added"},{"patch":"@@ -0,0 +1,50 @@\n+\/*\n+ * Copyright (c) 2020, Microsoft Corporation. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef OS_CPU_WINDOWS_AARCH64_GLOBALS_WINDOWS_AARCH64_HPP\n+#define OS_CPU_WINDOWS_AARCH64_GLOBALS_WINDOWS_AARCH64_HPP\n+\n+\/\/ Sets the default values for platform dependent flags used by the runtime system.\n+\/\/ (see globals.hpp)\n+\n+define_pd_global(bool, DontYieldALot,            false);\n+\n+\/\/ Default stack size on Windows is determined by the executable (java.exe\n+\/\/ has a default value of 320K\/1MB [32bit\/64bit]). Depending on Windows version, changing\n+\/\/ ThreadStackSize to non-zero may have significant impact on memory usage.\n+\/\/ See comments in os_windows.cpp.\n+define_pd_global(intx, ThreadStackSize,          0); \/\/ 0 => use system default\n+define_pd_global(intx, VMThreadStackSize,        0);\n+\n+#ifdef ASSERT\n+define_pd_global(intx, CompilerThreadStackSize,  1024);\n+#else\n+define_pd_global(intx, CompilerThreadStackSize,  0);\n+#endif\n+\n+define_pd_global(uintx,JVMInvokeMethodSlack,     8192);\n+\n+\/\/ Used on 64 bit platforms for UseCompressedOops base address\n+define_pd_global(uintx,HeapBaseMinAddress,       2*G);\n+#endif \/\/ OS_CPU_WINDOWS_AARCH64_GLOBALS_WINDOWS_AARCH64_HPP\n","filename":"src\/hotspot\/os_cpu\/windows_aarch64\/globals_windows_aarch64.hpp","additions":50,"deletions":0,"binary":false,"changes":50,"status":"added"},{"patch":"@@ -0,0 +1,44 @@\n+\/*\n+ * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef OS_CPU_WINDOWS_AARCH64_ICACHE_AARCH64_HPP\n+#define OS_CPU_WINDOWS_AARCH64_ICACHE_AARCH64_HPP\n+\n+\/\/ Interface for updating the instruction cache.  Whenever the VM\n+\/\/ modifies code, part of the processor instruction cache potentially\n+\/\/ has to be flushed.\n+\n+class ICache : public AbstractICache {\n+ public:\n+  static void initialize();\n+  static void invalidate_word(address addr) {\n+    invalidate_range(addr, 4);\n+  }\n+  static void invalidate_range(address start, int nbytes) {\n+    FlushInstructionCache((HANDLE)GetCurrentProcess(), start, (SIZE_T)(nbytes));\n+  }\n+};\n+\n+#endif \/\/ OS_CPU_WINDOWS_AARCH64_ICACHE_AARCH64_HPP\n","filename":"src\/hotspot\/os_cpu\/windows_aarch64\/icache_windows_aarch64.hpp","additions":44,"deletions":0,"binary":false,"changes":44,"status":"added"},{"patch":"@@ -0,0 +1,60 @@\n+\/*\n+ * Copyright (c) 2020, Microsoft Corporation. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef OS_CPU_WINDOWS_AARCH64_ORDERACCESS_WINDOWS_AARCH64_HPP\n+#define OS_CPU_WINDOWS_AARCH64_ORDERACCESS_WINDOWS_AARCH64_HPP\n+\n+\/\/ Included in orderAccess.hpp header file.\n+#include <atomic>\n+using std::atomic_thread_fence;\n+#include <intrin.h>\n+#include \"vm_version_aarch64.hpp\"\n+#include \"runtime\/vm_version.hpp\"\n+\n+\/\/ Implementation of class OrderAccess.\n+\n+inline void OrderAccess::loadload()   { acquire(); }\n+inline void OrderAccess::storestore() { release(); }\n+inline void OrderAccess::loadstore()  { acquire(); }\n+inline void OrderAccess::storeload()  { fence(); }\n+\n+#define READ_MEM_BARRIER atomic_thread_fence(std::memory_order_acquire);\n+#define WRITE_MEM_BARRIER atomic_thread_fence(std::memory_order_release);\n+#define FULL_MEM_BARRIER atomic_thread_fence(std::memory_order_seq_cst);\n+\n+inline void OrderAccess::acquire() {\n+  READ_MEM_BARRIER;\n+}\n+\n+inline void OrderAccess::release() {\n+  WRITE_MEM_BARRIER;\n+}\n+\n+inline void OrderAccess::fence() {\n+  FULL_MEM_BARRIER;\n+}\n+\n+inline void OrderAccess::cross_modify_fence() { }\n+\n+#endif \/\/ OS_CPU_WINDOWS_AARCH64_ORDERACCESS_WINDOWS_AARCH64_HPP\n","filename":"src\/hotspot\/os_cpu\/windows_aarch64\/orderAccess_windows_aarch64.hpp","additions":60,"deletions":0,"binary":false,"changes":60,"status":"added"},{"patch":"@@ -0,0 +1,311 @@\n+\/*\n+ * Copyright (c) 2020, Microsoft Corporation. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"jvm.h\"\n+#include \"asm\/macroAssembler.hpp\"\n+#include \"classfile\/classLoader.hpp\"\n+#include \"classfile\/systemDictionary.hpp\"\n+#include \"classfile\/vmSymbols.hpp\"\n+#include \"code\/codeCache.hpp\"\n+#include \"code\/icBuffer.hpp\"\n+#include \"code\/vtableStubs.hpp\"\n+#include \"code\/nativeInst.hpp\"\n+#include \"interpreter\/interpreter.hpp\"\n+#include \"memory\/allocation.inline.hpp\"\n+#include \"prims\/jniFastGetField.hpp\"\n+#include \"prims\/jvm_misc.hpp\"\n+#include \"runtime\/arguments.hpp\"\n+#include \"runtime\/frame.inline.hpp\"\n+#include \"runtime\/interfaceSupport.inline.hpp\"\n+#include \"runtime\/java.hpp\"\n+#include \"runtime\/javaCalls.hpp\"\n+#include \"runtime\/mutexLocker.hpp\"\n+#include \"runtime\/osThread.hpp\"\n+#include \"runtime\/sharedRuntime.hpp\"\n+#include \"runtime\/stubRoutines.hpp\"\n+#include \"runtime\/thread.inline.hpp\"\n+#include \"runtime\/timer.hpp\"\n+#include \"unwind_windows_aarch64.hpp\"\n+#include \"utilities\/debug.hpp\"\n+#include \"utilities\/events.hpp\"\n+#include \"utilities\/vmError.hpp\"\n+\n+\n+\/\/ put OS-includes here\n+# include <sys\/types.h>\n+# include <signal.h>\n+# include <errno.h>\n+# include <stdlib.h>\n+# include <stdio.h>\n+# include <intrin.h>\n+\n+void os::os_exception_wrapper(java_call_t f, JavaValue* value, const methodHandle& method, JavaCallArguments* args, Thread* thread) {\n+  f(value, method, args, thread);\n+}\n+\n+PRAGMA_DISABLE_MSVC_WARNING(4172)\n+\/\/ Returns an estimate of the current stack pointer. Result must be guaranteed\n+\/\/ to point into the calling threads stack, and be no lower than the current\n+\/\/ stack pointer.\n+address os::current_stack_pointer() {\n+  int dummy;\n+  address sp = (address)&dummy;\n+  return sp;\n+}\n+\n+address os::fetch_frame_from_context(const void* ucVoid,\n+                    intptr_t** ret_sp, intptr_t** ret_fp) {\n+  address  epc;\n+  CONTEXT* uc = (CONTEXT*)ucVoid;\n+\n+  if (uc != NULL) {\n+    epc = (address)uc->Pc;\n+    if (ret_sp) *ret_sp = (intptr_t*)uc->Sp;\n+    if (ret_fp) *ret_fp = (intptr_t*)uc->Fp;\n+  } else {\n+    \/\/ construct empty ExtendedPC for return value checking\n+    epc = NULL;\n+    if (ret_sp) *ret_sp = (intptr_t *)NULL;\n+    if (ret_fp) *ret_fp = (intptr_t *)NULL;\n+  }\n+  return epc;\n+}\n+\n+frame os::fetch_frame_from_context(const void* ucVoid) {\n+  intptr_t* sp;\n+  intptr_t* fp;\n+  address epc = fetch_frame_from_context(ucVoid, &sp, &fp);\n+  return frame(sp, fp, epc);\n+}\n+\n+bool os::win32::get_frame_at_stack_banging_point(JavaThread* thread,\n+        struct _EXCEPTION_POINTERS* exceptionInfo, address pc, frame* fr) {\n+  PEXCEPTION_RECORD exceptionRecord = exceptionInfo->ExceptionRecord;\n+  address addr = (address) exceptionRecord->ExceptionInformation[1];\n+  if (Interpreter::contains(pc)) {\n+    \/\/ interpreter performs stack banging after the fixed frame header has\n+    \/\/ been generated while the compilers perform it before. To maintain\n+    \/\/ semantic consistency between interpreted and compiled frames, the\n+    \/\/ method returns the Java sender of the current frame.\n+    *fr = os::fetch_frame_from_context((void*)exceptionInfo->ContextRecord);\n+    if (!fr->is_first_java_frame()) {\n+      assert(fr->safe_for_sender(thread), \"Safety check\");\n+      *fr = fr->java_sender();\n+    }\n+  } else {\n+    \/\/ more complex code with compiled code\n+    assert(!Interpreter::contains(pc), \"Interpreted methods should have been handled above\");\n+    CodeBlob* cb = CodeCache::find_blob(pc);\n+    if (cb == NULL || !cb->is_nmethod() || cb->is_frame_complete_at(pc)) {\n+      \/\/ Not sure where the pc points to, fallback to default\n+      \/\/ stack overflow handling\n+      return false;\n+    } else {\n+      \/\/ In compiled code, the stack banging is performed before LR\n+      \/\/ has been saved in the frame.  LR is live, and SP and FP\n+      \/\/ belong to the caller.\n+      intptr_t* fp = (intptr_t*)exceptionInfo->ContextRecord->Fp;\n+      intptr_t* sp = (intptr_t*)exceptionInfo->ContextRecord->Sp;\n+      address pc = (address)(exceptionInfo->ContextRecord->Lr\n+                         - NativeInstruction::instruction_size);\n+      *fr = frame(sp, fp, pc);\n+      if (!fr->is_java_frame()) {\n+        assert(fr->safe_for_sender(thread), \"Safety check\");\n+        assert(!fr->is_first_frame(), \"Safety check\");\n+        *fr = fr->java_sender();\n+      }\n+    }\n+  }\n+  assert(fr->is_java_frame(), \"Safety check\");\n+  return true;\n+}\n+\n+\/\/ By default, gcc always saves frame pointer rfp on this stack. This\n+\/\/ may get turned off by -fomit-frame-pointer.\n+frame os::get_sender_for_C_frame(frame* fr) {\n+  return frame(fr->link(), fr->link(), fr->sender_pc());\n+}\n+\n+frame os::current_frame() {\n+  typedef intptr_t*      get_fp_func           ();\n+  get_fp_func* func = CAST_TO_FN_PTR(get_fp_func*,\n+                                     StubRoutines::aarch64::get_previous_fp_entry());\n+  if (func == NULL) return frame();\n+  intptr_t* fp = (*func)();\n+  if (fp == NULL) {\n+    return frame();\n+  }\n+\n+  frame myframe((intptr_t*)os::current_stack_pointer(),\n+                (intptr_t*)fp,\n+                CAST_FROM_FN_PTR(address, os::current_frame));\n+  if (os::is_first_C_frame(&myframe)) {\n+\n+    \/\/ stack is not walkable\n+    return frame();\n+  } else {\n+    return os::get_sender_for_C_frame(&myframe);\n+  }\n+}\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\/\/ thread stack\n+\n+\/\/ Minimum usable stack sizes required to get to user code. Space for\n+\/\/ HotSpot guard pages is added later.\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\/\/ helper functions for fatal error handler\n+\n+void os::print_context(outputStream *st, const void *context) {\n+  if (context == NULL) return;\n+\n+  const CONTEXT* uc = (const CONTEXT*)context;\n+\n+  st->print_cr(\"Registers:\");\n+\n+  st->print(  \"X0 =\" INTPTR_FORMAT, uc->X0);\n+  st->print(\", X1 =\" INTPTR_FORMAT, uc->X1);\n+  st->print(\", X2 =\" INTPTR_FORMAT, uc->X2);\n+  st->print(\", X3 =\" INTPTR_FORMAT, uc->X3);\n+  st->cr();\n+  st->print(  \"X4 =\" INTPTR_FORMAT, uc->X4);\n+  st->print(\", X5 =\" INTPTR_FORMAT, uc->X5);\n+  st->print(\", X6 =\" INTPTR_FORMAT, uc->X6);\n+  st->print(\", X7 =\" INTPTR_FORMAT, uc->X7);\n+  st->cr();\n+  st->print(  \"X8 =\" INTPTR_FORMAT, uc->X8);\n+  st->print(\", X9 =\" INTPTR_FORMAT, uc->X9);\n+  st->print(\", X10=\" INTPTR_FORMAT, uc->X10);\n+  st->print(\", X11=\" INTPTR_FORMAT, uc->X11);\n+  st->cr();\n+  st->print(  \"X12=\" INTPTR_FORMAT, uc->X12);\n+  st->print(\", X13=\" INTPTR_FORMAT, uc->X13);\n+  st->print(\", X14=\" INTPTR_FORMAT, uc->X14);\n+  st->print(\", X15=\" INTPTR_FORMAT, uc->X15);\n+  st->cr();\n+  st->print(  \"X16=\" INTPTR_FORMAT, uc->X16);\n+  st->print(\", X17=\" INTPTR_FORMAT, uc->X17);\n+  st->print(\", X18=\" INTPTR_FORMAT, uc->X18);\n+  st->print(\", X19=\" INTPTR_FORMAT, uc->X19);\n+  st->cr();\n+  st->print(\", X20=\" INTPTR_FORMAT, uc->X20);\n+  st->print(\", X21=\" INTPTR_FORMAT, uc->X21);\n+  st->print(\", X22=\" INTPTR_FORMAT, uc->X22);\n+  st->print(\", X23=\" INTPTR_FORMAT, uc->X23);\n+  st->cr();\n+  st->print(\", X24=\" INTPTR_FORMAT, uc->X24);\n+  st->print(\", X25=\" INTPTR_FORMAT, uc->X25);\n+  st->print(\", X26=\" INTPTR_FORMAT, uc->X26);\n+  st->print(\", X27=\" INTPTR_FORMAT, uc->X27);\n+  st->print(\", X28=\" INTPTR_FORMAT, uc->X28);\n+  st->cr();\n+  st->cr();\n+\n+  intptr_t *sp = (intptr_t *)uc->Sp;\n+  st->print_cr(\"Top of Stack: (sp=\" PTR_FORMAT \")\", sp);\n+  print_hex_dump(st, (address)sp, (address)(sp + 32), sizeof(intptr_t));\n+  st->cr();\n+\n+  \/\/ Note: it may be unsafe to inspect memory near pc. For example, pc may\n+  \/\/ point to garbage if entry point in an nmethod is corrupted. Leave\n+  \/\/ this at the end, and hope for the best.\n+  address pc = (address)uc->Pc;\n+  st->print_cr(\"Instructions: (pc=\" PTR_FORMAT \")\", pc);\n+  print_hex_dump(st, pc - 32, pc + 32, sizeof(char));\n+  st->cr();\n+\n+}\n+\n+void os::print_register_info(outputStream *st, const void *context) {\n+ if (context == NULL) return;\n+\n+  const CONTEXT* uc = (const CONTEXT*)context;\n+\n+  st->print_cr(\"Register to memory mapping:\");\n+  st->cr();\n+  \/\/ this is only for the \"general purpose\" registers\n+  st->print(\" X0=\"); print_location(st, uc->X0);\n+  st->print(\" X1=\"); print_location(st, uc->X1);\n+  st->print(\" X2=\"); print_location(st, uc->X2);\n+  st->print(\" X3=\"); print_location(st, uc->X3);\n+  st->cr();\n+  st->print(\" X4=\"); print_location(st, uc->X4);\n+  st->print(\" X5=\"); print_location(st, uc->X5);\n+  st->print(\" X6=\"); print_location(st, uc->X6);\n+  st->print(\" X7=\"); print_location(st, uc->X7);\n+  st->cr();\n+  st->print(\" X8=\"); print_location(st, uc->X8);\n+  st->print(\" X9=\"); print_location(st, uc->X9);\n+  st->print(\"X10=\"); print_location(st, uc->X10);\n+  st->print(\"X11=\"); print_location(st, uc->X11);\n+  st->cr();\n+  st->print(\"X12=\"); print_location(st, uc->X12);\n+  st->print(\"X13=\"); print_location(st, uc->X13);\n+  st->print(\"X14=\"); print_location(st, uc->X14);\n+  st->print(\"X15=\"); print_location(st, uc->X15);\n+  st->cr();\n+  st->print(\"X16=\"); print_location(st, uc->X16);\n+  st->print(\"X17=\"); print_location(st, uc->X17);\n+  st->print(\"X18=\"); print_location(st, uc->X18);\n+  st->print(\"X19=\"); print_location(st, uc->X19);\n+  st->cr();\n+  st->print(\"X20=\"); print_location(st, uc->X20);\n+  st->print(\"X21=\"); print_location(st, uc->X21);\n+  st->print(\"X22=\"); print_location(st, uc->X22);\n+  st->print(\"X23=\"); print_location(st, uc->X23);\n+  st->cr();\n+  st->print(\"X24=\"); print_location(st, uc->X24);\n+  st->print(\"X25=\"); print_location(st, uc->X25);\n+  st->print(\"X26=\"); print_location(st, uc->X26);\n+  st->print(\"X27=\"); print_location(st, uc->X27);\n+  st->print(\"X28=\"); print_location(st, uc->X28);\n+\n+  st->cr();\n+}\n+\n+void os::setup_fpu() {\n+}\n+\n+bool os::supports_sse() {\n+  return true;\n+}\n+\n+#ifndef PRODUCT\n+void os::verify_stack_alignment() {\n+  assert(((intptr_t)os::current_stack_pointer() & (StackAlignmentInBytes-1)) == 0, \"incorrect stack alignment\");\n+}\n+#endif\n+\n+int os::extra_bang_size_in_bytes() {\n+  \/\/ AArch64 does not require the additional stack bang.\n+  return 0;\n+}\n+\n+extern \"C\" {\n+  int SpinPause() {\n+    return 0;\n+  }\n+};\n","filename":"src\/hotspot\/os_cpu\/windows_aarch64\/os_windows_aarch64.cpp","additions":311,"deletions":0,"binary":false,"changes":311,"status":"added"},{"patch":"@@ -0,0 +1,36 @@\n+\/*\n+ * Copyright (c) 2020, Microsoft Corporation. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef OS_CPU_WINDOWS_AARCH64_OS_WINDOWS_AARCH64_HPP\n+#define OS_CPU_WINDOWS_AARCH64_OS_WINDOWS_AARCH64_HPP\n+\n+  static void setup_fpu();\n+  static bool supports_sse();\n+\n+  static bool      register_code_area(char *low, char *high) {\n+    \/\/ Using Vectored Exception Handling\n+    return true;\n+  }\n+\n+#endif \/\/ OS_CPU_WINDOWS_AARCH64_OS_WINDOWS_AARCH64_HPP\n","filename":"src\/hotspot\/os_cpu\/windows_aarch64\/os_windows_aarch64.hpp","additions":36,"deletions":0,"binary":false,"changes":36,"status":"added"},{"patch":"@@ -0,0 +1,30 @@\n+\/*\n+ * Copyright (c) 2020, Microsoft Corporation. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef OS_CPU_WINDOWS_AARCH64_OS_WINDOWS_AARCH64_INLINE_HPP\n+#define OS_CPU_WINDOWS_AARCH64_OS_WINDOWS_AARCH64_INLINE_HPP\n+\n+#include \"runtime\/os.hpp\"\n+\n+#endif \/\/ OS_CPU_WINDOWS_AARCH64_OS_WINDOWS_AARCH64_INLINE_HPP\n","filename":"src\/hotspot\/os_cpu\/windows_aarch64\/os_windows_aarch64.inline.hpp","additions":30,"deletions":0,"binary":false,"changes":30,"status":"added"},{"patch":"@@ -0,0 +1,37 @@\n+\/*\n+ * Copyright (c) 2020, Microsoft Corporation. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef OS_CPU_WINDOWS_AARCH64_PREFETCH_WINDOWS_AARCH64_INLINE_HPP\n+#define OS_CPU_WINDOWS_AARCH64_PREFETCH_WINDOWS_AARCH64_INLINE_HPP\n+\n+#include \"runtime\/prefetch.hpp\"\n+\n+\n+inline void Prefetch::read (void *loc, intx interval) {\n+}\n+\n+inline void Prefetch::write(void *loc, intx interval) {\n+}\n+\n+#endif \/\/ OS_CPU_WINDOWS_AARCH64_PREFETCH_WINDOWS_AARCH64_INLINE_HPP\n","filename":"src\/hotspot\/os_cpu\/windows_aarch64\/prefetch_windows_aarch64.inline.hpp","additions":37,"deletions":0,"binary":false,"changes":37,"status":"added"},{"patch":"@@ -0,0 +1,100 @@\n+\/*\n+ * Copyright (c) 2020, Microsoft Corporation. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"memory\/metaspaceShared.hpp\"\n+#include \"runtime\/frame.inline.hpp\"\n+#include \"runtime\/thread.inline.hpp\"\n+\n+frame JavaThread::pd_last_frame() {\n+  assert(has_last_Java_frame(), \"must have last_Java_sp() when suspended\");\n+  vmassert(_anchor.last_Java_pc() != NULL, \"not walkable\");\n+  return frame(_anchor.last_Java_sp(), _anchor.last_Java_fp(), _anchor.last_Java_pc());\n+}\n+\n+\/\/ For Forte Analyzer AsyncGetCallTrace profiling support - thread is\n+\/\/ currently interrupted by SIGPROF\n+bool JavaThread::pd_get_top_frame_for_signal_handler(frame* fr_addr,\n+  void* ucontext, bool isInJava) {\n+\n+  assert(Thread::current() == this, \"caller must be current thread\");\n+  return pd_get_top_frame(fr_addr, ucontext, isInJava);\n+}\n+\n+bool JavaThread::pd_get_top_frame_for_profiling(frame* fr_addr, void* ucontext, bool isInJava) {\n+  return pd_get_top_frame(fr_addr, ucontext, isInJava);\n+}\n+\n+bool JavaThread::pd_get_top_frame(frame* fr_addr, void* ucontext, bool isInJava) {\n+\n+  assert(this->is_Java_thread(), \"must be JavaThread\");\n+\n+  JavaThread* jt = (JavaThread *)this;\n+\n+  \/\/ If we have a last_Java_frame, then we should use it even if\n+  \/\/ isInJava == true.  It should be more reliable than CONTEXT info.\n+  if (jt->has_last_Java_frame() && jt->frame_anchor()->walkable()) {\n+    *fr_addr = jt->pd_last_frame();\n+    return true;\n+  }\n+\n+  \/\/ At this point, we don't have a last_Java_frame, so\n+  \/\/ we try to glean some information out of the CONTEXT\n+  \/\/ if we were running Java code when SIGPROF came in.\n+  if (isInJava) {\n+    frame ret_frame = os::fetch_frame_from_context(ucontext);\n+    if (ret_frame.pc() == NULL || ret_frame.sp() == NULL ) {\n+      \/\/ CONTEXT wasn't useful\n+      return false;\n+    }\n+\n+    if (MetaspaceShared::is_in_trampoline_frame(ret_frame.pc())) {\n+      \/\/ In the middle of a trampoline call. Bail out for safety.\n+      \/\/ This happens rarely so shouldn't affect profiling.\n+      return false;\n+    }\n+\n+    if (!ret_frame.safe_for_sender(jt)) {\n+#if COMPILER2_OR_JVMCI\n+      \/\/ C2 and JVMCI use ebp as a general register see if NULL fp helps\n+      frame ret_frame2(ret_frame.sp(), NULL, ret_frame.pc());\n+      if (!ret_frame2.safe_for_sender(jt)) {\n+        \/\/ nothing else to try if the frame isn't good\n+        return false;\n+      }\n+      ret_frame = ret_frame2;\n+#else\n+      \/\/ nothing else to try if the frame isn't good\n+      return false;\n+#endif \/\/ COMPILER2_OR_JVMCI\n+    }\n+    *fr_addr = ret_frame;\n+    return true;\n+  }\n+\n+  \/\/ nothing else to try\n+  return false;\n+}\n+\n+void JavaThread::cache_global_variables() { }\n","filename":"src\/hotspot\/os_cpu\/windows_aarch64\/thread_windows_aarch64.cpp","additions":100,"deletions":0,"binary":false,"changes":100,"status":"added"},{"patch":"@@ -0,0 +1,63 @@\n+\/*\n+ * Copyright (c) 2020, Microsoft Corporation. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef OS_CPU_WINDOWS_AARCH64_THREAD_WINDOWS_AARCH64_HPP\n+#define OS_CPU_WINDOWS_AARCH64_THREAD_WINDOWS_AARCH64_HPP\n+\n+ private:\n+\n+#ifdef ASSERT\n+  \/\/ spill stack holds N callee-save registers at each Java call and\n+  \/\/ grows downwards towards limit\n+  \/\/ we need limit to check we have space for a spill and base so we\n+  \/\/ can identify all live spill frames at GC (eventually)\n+  address          _spill_stack;\n+  address          _spill_stack_base;\n+  address          _spill_stack_limit;\n+#endif \/\/ ASSERT\n+\n+  void pd_initialize() {\n+    _anchor.clear();\n+  }\n+\n+  frame pd_last_frame();\n+\n+ public:\n+  static ByteSize last_Java_fp_offset()          {\n+    return byte_offset_of(JavaThread, _anchor) + JavaFrameAnchor::last_Java_fp_offset();\n+  }\n+\n+  bool pd_get_top_frame_for_signal_handler(frame* fr_addr, void* ucontext,\n+    bool isInJava);\n+\n+  bool pd_get_top_frame_for_profiling(frame* fr_addr, void* ucontext, bool isInJava);\n+private:\n+  bool pd_get_top_frame(frame* fr_addr, void* ucontext, bool isInJava);\n+public:\n+\n+  static Thread *aarch64_get_thread_helper() {\n+     return Thread::current();\n+  }\n+\n+#endif \/\/ OS_CPU_WINDOWS_AARCH64_THREAD_WINDOWS_AARCH64_HPP\n","filename":"src\/hotspot\/os_cpu\/windows_aarch64\/thread_windows_aarch64.hpp","additions":63,"deletions":0,"binary":false,"changes":63,"status":"added"},{"patch":"@@ -0,0 +1,102 @@\n+\/*\n+ * Copyright (c) 2020, Microsoft Corporation. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef OS_CPU_WINDOWS_AARCH64_UNWIND_WINDOWS_AARCH64_HPP\n+#define OS_CPU_WINDOWS_AARCH64_UNWIND_WINDOWS_AARCH64_HPP\n+\n+\n+typedef unsigned char UBYTE;\n+\n+#if _MSC_VER < 1700\n+\n+\/* Not needed for VS2012 compiler, comes from winnt.h. *\/\n+#define UNW_FLAG_EHANDLER  0x01\n+#define UNW_FLAG_UHANDLER  0x02\n+#define UNW_FLAG_CHAININFO 0x04\n+\n+#endif\n+\n+\/\/ See https:\/\/docs.microsoft.com\/en-us\/cpp\/build\/arm64-exception-handling#xdata-records\n+typedef struct _UNWIND_INFO_EH_ONLY {\n+    DWORD FunctionLength : 18;\n+    DWORD Version        : 2;\n+    DWORD X              : 1; \/\/ = 1\n+    DWORD E              : 1; \/\/ = 1\n+    DWORD EpilogCount    : 5; \/\/ = 0\n+    DWORD CodeWords      : 5; \/\/ = 1\n+    DWORD UnwindCode0    : 8;\n+    DWORD UnwindCode1    : 8;\n+    DWORD UnwindCode2    : 8;\n+    DWORD UnwindCode3    : 8;\n+    DWORD ExceptionHandler;\n+} UNWIND_INFO_EH_ONLY, *PUNWIND_INFO_EH_ONLY;\n+\n+\/*\n+typedef struct _RUNTIME_FUNCTION {\n+    DWORD BeginAddress;\n+    union {\n+        DWORD UnwindData;\n+        struct {\n+            DWORD Flag : 2;\n+            DWORD FunctionLength : 11;\n+            DWORD RegF : 3;\n+            DWORD RegI : 4;\n+            DWORD H : 1;\n+            DWORD CR : 2;\n+            DWORD FrameSize : 9;\n+        } DUMMYSTRUCTNAME;\n+    } DUMMYUNIONNAME;\n+} RUNTIME_FUNCTION, *PRUNTIME_FUNCTION;\n+*\/\n+\n+#if _MSC_VER < 1700\n+\n+\/* Not needed for VS2012 compiler, comes from winnt.h. *\/\n+typedef struct _DISPATCHER_CONTEXT {\n+    ULONG64 ControlPc;\n+    ULONG64 ImageBase;\n+    PRUNTIME_FUNCTION FunctionEntry;\n+    ULONG64 EstablisherFrame;\n+    ULONG64 TargetIp;\n+    PCONTEXT ContextRecord;\n+\/\/    PEXCEPTION_ROUTINE LanguageHandler;\n+    char * LanguageHandler; \/\/ double dependency problem\n+    PVOID HandlerData;\n+} DISPATCHER_CONTEXT, *PDISPATCHER_CONTEXT;\n+\n+#endif\n+\n+#if _MSC_VER < 1500\n+\n+\/* Not needed for VS2008 compiler, comes from winnt.h. *\/\n+typedef EXCEPTION_DISPOSITION (*PEXCEPTION_ROUTINE) (\n+    IN PEXCEPTION_RECORD ExceptionRecord,\n+    IN ULONG64 EstablisherFrame,\n+    IN OUT PCONTEXT ContextRecord,\n+    IN OUT PDISPATCHER_CONTEXT DispatcherContext\n+);\n+\n+#endif\n+\n+#endif \/\/ OS_CPU_WINDOWS_AARCH64_UNWIND_WINDOWS_AARCH64_HPP\n","filename":"src\/hotspot\/os_cpu\/windows_aarch64\/unwind_windows_aarch64.hpp","additions":102,"deletions":0,"binary":false,"changes":102,"status":"added"},{"patch":"@@ -0,0 +1,49 @@\n+\/*\n+ * Copyright (c) 2020, Microsoft Corporation. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef OS_CPU_WINDOWS_AARCH64_VMSTRUCTS_WINDOWS_AARCH64_HPP\n+#define OS_CPU_WINDOWS_AARCH64_VMSTRUCTS_WINDOWS_AARCH64_HPP\n+\n+\/\/ These are the OS and CPU-specific fields, types and integer\n+\/\/ constants required by the Serviceability Agent. This file is\n+\/\/ referenced by vmStructs.cpp.\n+\n+#define VM_STRUCTS_OS_CPU(nonstatic_field, static_field, unchecked_nonstatic_field, volatile_nonstatic_field, nonproduct_nonstatic_field, c2_nonstatic_field, unchecked_c1_static_field, unchecked_c2_static_field) \\\n+                                                                                                                                     \\\n+  \/******************************\/                                                                                                   \\\n+  \/* Threads (NOTE: incomplete) *\/                                                                                                   \\\n+  \/******************************\/                                                                                                   \\\n+                                                                                                                                     \\\n+  nonstatic_field(OSThread,                    _thread_id,                                    OSThread::thread_id_t)                 \\\n+  unchecked_nonstatic_field(OSThread,          _thread_handle,                                sizeof(HANDLE)) \/* NOTE: no type *\/\n+\n+#define VM_TYPES_OS_CPU(declare_type, declare_toplevel_type, declare_oop_type, declare_integer_type, declare_unsigned_integer_type, declare_c1_toplevel_type, declare_c2_type, declare_c2_toplevel_type) \\\n+                                                                          \\\n+  declare_unsigned_integer_type(OSThread::thread_id_t)\n+\n+#define VM_INT_CONSTANTS_OS_CPU(declare_constant, declare_preprocessor_constant, declare_c1_constant, declare_c2_constant, declare_c2_preprocessor_constant)\n+\n+#define VM_LONG_CONSTANTS_OS_CPU(declare_constant, declare_preprocessor_constant, declare_c1_constant, declare_c2_constant, declare_c2_preprocessor_constant)\n+\n+#endif \/\/ OS_CPU_WINDOWS_AARCH64_VMSTRUCTS_WINDOWS_AARCH64_HPP\n","filename":"src\/hotspot\/os_cpu\/windows_aarch64\/vmStructs_windows_aarch64.hpp","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"},{"patch":"@@ -0,0 +1,99 @@\n+\/*\n+ * Copyright (c) 2020, Microsoft Corporation. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"runtime\/os.hpp\"\n+#include \"runtime\/vm_version.hpp\"\n+\n+int VM_Version::get_current_sve_vector_length() {\n+  assert(_features & CPU_SVE, \"should not call this\");\n+  ShouldNotReachHere();\n+  return 0;\n+}\n+\n+int VM_Version::set_and_get_current_sve_vector_lenght(int length) {\n+  assert(_features & CPU_SVE, \"should not call this\");\n+  ShouldNotReachHere();\n+  return 0;\n+}\n+\n+void VM_Version::get_os_cpu_info() {\n+\n+  if (IsProcessorFeaturePresent(PF_ARM_V8_CRC32_INSTRUCTIONS_AVAILABLE))   _features |= CPU_CRC32;\n+  if (IsProcessorFeaturePresent(PF_ARM_V8_CRYPTO_INSTRUCTIONS_AVAILABLE))  _features |= CPU_AES | CPU_SHA1 | CPU_SHA2;\n+  if (IsProcessorFeaturePresent(PF_ARM_VFP_32_REGISTERS_AVAILABLE))        _features |= CPU_ASIMD;\n+  \/\/ No check for CPU_PMULL, CPU_SVE, CPU_SVE2\n+\n+  __int64 dczid_el0 = _ReadStatusReg(0x5807 \/* ARM64_DCZID_EL0 *\/);\n+\n+  if (!(dczid_el0 & 0x10)) {\n+    _zva_length = 4 << (dczid_el0 & 0xf);\n+  }\n+\n+  {\n+    PSYSTEM_LOGICAL_PROCESSOR_INFORMATION buffer = NULL;\n+    DWORD returnLength = 0;\n+\n+    \/\/ See https:\/\/docs.microsoft.com\/en-us\/windows\/win32\/api\/sysinfoapi\/nf-sysinfoapi-getlogicalprocessorinformation\n+    GetLogicalProcessorInformation(NULL, &returnLength);\n+    assert(GetLastError() == ERROR_INSUFFICIENT_BUFFER, \"Unexpected return from GetLogicalProcessorInformation\");\n+\n+    buffer = (PSYSTEM_LOGICAL_PROCESSOR_INFORMATION)os::malloc(returnLength, mtInternal);\n+    BOOL rc = GetLogicalProcessorInformation(buffer, &returnLength);\n+    assert(rc, \"Unexpected return from GetLogicalProcessorInformation\");\n+\n+    _icache_line_size = _dcache_line_size = -1;\n+    for (PSYSTEM_LOGICAL_PROCESSOR_INFORMATION ptr = buffer; ptr < buffer + returnLength \/ sizeof(SYSTEM_LOGICAL_PROCESSOR_INFORMATION); ptr++) {\n+      switch (ptr->Relationship) {\n+      case RelationCache:\n+        \/\/ Cache data is in ptr->Cache, one CACHE_DESCRIPTOR structure for each cache.\n+        PCACHE_DESCRIPTOR Cache = &ptr->Cache;\n+        if (Cache->Level == 1) {\n+            _icache_line_size = _dcache_line_size = Cache->LineSize;\n+        }\n+        break;\n+      }\n+    }\n+    os::free(buffer);\n+  }\n+\n+  {\n+    char* buf = ::getenv(\"PROCESSOR_IDENTIFIER\");\n+    if (buf && strstr(buf, \"Ampere(TM)\") != NULL) {\n+      _cpu = CPU_AMCC;\n+    } else if (buf && strstr(buf, \"Cavium Inc.\") != NULL) {\n+      _cpu = CPU_CAVIUM;\n+    } else {\n+      log_info(os)(\"VM_Version: unknown CPU model\");\n+    }\n+\n+    if (_cpu) {\n+      SYSTEM_INFO si;\n+      GetSystemInfo(&si);\n+      _model = si.wProcessorLevel;\n+      _variant = si.wProcessorRevision \/ 0xFF;\n+      _revision = si.wProcessorRevision & 0xFF;\n+    }\n+  }\n+}\n","filename":"src\/hotspot\/os_cpu\/windows_aarch64\/vm_version_windows_aarch64.cpp","additions":99,"deletions":0,"binary":false,"changes":99,"status":"added"},{"patch":"@@ -357,0 +357,35 @@\n+bool os::win32::get_frame_at_stack_banging_point(JavaThread* thread,\n+        struct _EXCEPTION_POINTERS* exceptionInfo, address pc, frame* fr) {\n+  PEXCEPTION_RECORD exceptionRecord = exceptionInfo->ExceptionRecord;\n+  address addr = (address) exceptionRecord->ExceptionInformation[1];\n+  if (Interpreter::contains(pc)) {\n+    *fr = os::fetch_frame_from_context((void*)exceptionInfo->ContextRecord);\n+    if (!fr->is_first_java_frame()) {\n+      \/\/ get_frame_at_stack_banging_point() is only called when we\n+      \/\/ have well defined stacks so java_sender() calls do not need\n+      \/\/ to assert safe_for_sender() first.\n+      *fr = fr->java_sender();\n+    }\n+  } else {\n+    \/\/ more complex code with compiled code\n+    assert(!Interpreter::contains(pc), \"Interpreted methods should have been handled above\");\n+    CodeBlob* cb = CodeCache::find_blob(pc);\n+    if (cb == NULL || !cb->is_nmethod() || cb->is_frame_complete_at(pc)) {\n+      \/\/ Not sure where the pc points to, fallback to default\n+      \/\/ stack overflow handling\n+      return false;\n+    } else {\n+      \/\/ in compiled code, the stack banging is performed just after the return pc\n+      \/\/ has been pushed on the stack\n+      intptr_t* fp = (intptr_t*)exceptionInfo->ContextRecord->REG_FP;\n+      intptr_t* sp = (intptr_t*)exceptionInfo->ContextRecord->REG_SP;\n+      *fr = frame(sp + 1, fp, (address)*sp);\n+      if (!fr->is_java_frame()) {\n+        \/\/ See java_sender() comment above.\n+        *fr = fr->java_sender();\n+      }\n+    }\n+  }\n+  assert(fr->is_java_frame(), \"Safety check\");\n+  return true;\n+}\n","filename":"src\/hotspot\/os_cpu\/windows_x86\/os_windows_x86.cpp","additions":35,"deletions":0,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -35,0 +35,5 @@\n+#if defined(_M_ARM64)&& defined(_MSC_VER) && _MSC_VER <= 1927\n+  \/\/ workaround for MSCV ARM64 bug\n+  \/\/ https:\/\/developercommunity.visualstudio.com\/content\/problem\/1079221\/arm64-bad-code-generation-around-signed-char-arith.html\n+  typedef int32_t region_type_t;\n+#else\n@@ -36,0 +41,1 @@\n+#endif\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegionAttr.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -96,1 +96,1 @@\n-#ifdef _WIN32\n+#if defined(_WIN32) && !defined(USE_VECTORED_EXCEPTION_HANDLING)\n@@ -3844,1 +3844,1 @@\n-#ifdef _WIN32\n+#if defined(_WIN32) && !defined(USE_VECTORED_EXCEPTION_HANDLING)\n@@ -3848,1 +3848,1 @@\n-#ifdef _WIN32\n+#if defined(_WIN32) && !defined(USE_VECTORED_EXCEPTION_HANDLING)\n@@ -3916,1 +3916,1 @@\n-#ifdef _WIN32\n+#if defined(_WIN32) && !defined(USE_VECTORED_EXCEPTION_HANDLING)\n@@ -3920,1 +3920,1 @@\n-#ifdef _WIN32\n+#if defined(_WIN32) && !defined(USE_VECTORED_EXCEPTION_HANDLING)\n","filename":"src\/hotspot\/share\/prims\/jni.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -139,0 +139,4 @@\n+#ifdef _M_ARM64\n+#define USE_VECTORED_EXCEPTION_HANDLING\n+#endif\n+\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions_visCPP.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -572,0 +572,2 @@\n+#elif defined(_M_ARM64)\n+        sprops.os_arch = \"aarch64\";\n","filename":"src\/java.base\/windows\/native\/libjava\/java_props_md.c","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2011, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,1 +46,1 @@\n-        if (!arch.equals(\"x86\") && !arch.equals(\"amd64\")) {\n+        if (!arch.equals(\"x86\") && !arch.equals(\"amd64\") && !arch.equals(\"aarch64\")) {\n","filename":"src\/jdk.attach\/windows\/classes\/sun\/tools\/attach\/AttachProviderImpl.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -533,0 +533,2 @@\n+        } else if (cpu.equals(\"aarch64\")) {\n+            machDesc = new MachineDescriptionAArch64();\n@@ -534,1 +536,1 @@\n-            throw new DebuggerException(\"Win32 supported under x86 and amd64 only\");\n+            throw new DebuggerException(\"Win32 supported under x86, amd64 and aarch64 only\");\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/HotSpotAgent.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import sun.jvm.hotspot.debugger.aarch64.*;\n@@ -33,0 +34,1 @@\n+import sun.jvm.hotspot.debugger.windbg.aarch64.*;\n@@ -116,0 +118,2 @@\n+    } else if (cpu.equals(\"aarch64\")) {\n+      threadFactory = new WindbgAARCH64ThreadFactory(this);\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/debugger\/windbg\/WindbgDebuggerLocal.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,94 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Microsoft Corporation. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+package sun.jvm.hotspot.debugger.windbg.aarch64;\n+\n+import sun.jvm.hotspot.debugger.*;\n+import sun.jvm.hotspot.debugger.aarch64.*;\n+import sun.jvm.hotspot.debugger.windbg.*;\n+\n+class WindbgAARCH64Thread implements ThreadProxy {\n+  private WindbgDebugger debugger;\n+  private long           sysId;\n+  private boolean        gotID;\n+  private long           id;\n+\n+  \/\/ The address argument must be the address of the OSThread::_thread_id\n+  WindbgAARCH64Thread(WindbgDebugger debugger, Address addr) {\n+    this.debugger = debugger;\n+    this.sysId    = (long)addr.getCIntegerAt(0, 4, true);\n+    gotID         = false;\n+  }\n+\n+  WindbgAARCH64Thread(WindbgDebugger debugger, long sysId) {\n+    this.debugger = debugger;\n+    this.sysId    = sysId;\n+    gotID         = false;\n+  }\n+\n+  public ThreadContext getContext() throws IllegalThreadStateException {\n+    long[] data = debugger.getThreadIntegerRegisterSet(getThreadID());\n+    WindbgAARCH64ThreadContext context = new WindbgAARCH64ThreadContext(debugger);\n+    for (int i = 0; i < data.length; i++) {\n+      context.setRegister(i, data[i]);\n+    }\n+    return context;\n+  }\n+\n+  public boolean canSetContext() throws DebuggerException {\n+    return false;\n+  }\n+\n+  public void setContext(ThreadContext thrCtx)\n+    throws IllegalThreadStateException, DebuggerException {\n+    throw new DebuggerException(\"Unimplemented\");\n+  }\n+\n+  public boolean equals(Object obj) {\n+    if ((obj == null) || !(obj instanceof WindbgAARCH64Thread)) {\n+      return false;\n+    }\n+\n+    return (((WindbgAARCH64Thread) obj).getThreadID() == getThreadID());\n+  }\n+\n+  public int hashCode() {\n+    return (int) getThreadID();\n+  }\n+\n+  public String toString() {\n+    return Long.toString(getThreadID());\n+  }\n+\n+  \/** Retrieves the thread ID of this thread by examining the Thread\n+      Information Block. *\/\n+  private long getThreadID() {\n+    if (!gotID) {\n+       id = debugger.getThreadIdFromSysId(sysId);\n+    }\n+\n+    return id;\n+  }\n+}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/debugger\/windbg\/aarch64\/WindbgAARCH64Thread.java","additions":94,"deletions":0,"binary":false,"changes":94,"status":"added"},{"patch":"@@ -0,0 +1,47 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Microsoft Corporation. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+package sun.jvm.hotspot.debugger.windbg.aarch64;\n+\n+import sun.jvm.hotspot.debugger.*;\n+import sun.jvm.hotspot.debugger.aarch64.*;\n+import sun.jvm.hotspot.debugger.windbg.*;\n+\n+class WindbgAARCH64ThreadContext extends AARCH64ThreadContext {\n+  private WindbgDebugger debugger;\n+\n+  public WindbgAARCH64ThreadContext(WindbgDebugger debugger) {\n+    super();\n+    this.debugger = debugger;\n+  }\n+\n+  public void setRegisterAsAddress(int index, Address value) {\n+    setRegister(index, debugger.getAddressValue(value));\n+  }\n+\n+  public Address getRegisterAsAddress(int index) {\n+    return debugger.newAddress(getRegister(index));\n+  }\n+}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/debugger\/windbg\/aarch64\/WindbgAARCH64ThreadContext.java","additions":47,"deletions":0,"binary":false,"changes":47,"status":"added"},{"patch":"@@ -0,0 +1,45 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Microsoft Corporation. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+package sun.jvm.hotspot.debugger.windbg.aarch64;\n+\n+import sun.jvm.hotspot.debugger.*;\n+import sun.jvm.hotspot.debugger.windbg.*;\n+\n+public class WindbgAARCH64ThreadFactory implements WindbgThreadFactory {\n+  private WindbgDebugger debugger;\n+\n+  public WindbgAARCH64ThreadFactory(WindbgDebugger debugger) {\n+    this.debugger = debugger;\n+  }\n+\n+  public ThreadProxy createThreadWrapper(Address threadIdentifierAddr) {\n+    return new WindbgAARCH64Thread(debugger, threadIdentifierAddr);\n+  }\n+\n+  public ThreadProxy createThreadWrapper(long id) {\n+    return new WindbgAARCH64Thread(debugger, id);\n+  }\n+}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/debugger\/windbg\/aarch64\/WindbgAARCH64ThreadFactory.java","additions":45,"deletions":0,"binary":false,"changes":45,"status":"added"},{"patch":"@@ -31,1 +31,0 @@\n-import sun.jvm.hotspot.runtime.win32_amd64.Win32AMD64JavaThreadPDAccess;\n@@ -33,0 +32,2 @@\n+import sun.jvm.hotspot.runtime.win32_amd64.Win32AMD64JavaThreadPDAccess;\n+import sun.jvm.hotspot.runtime.win32_aarch64.Win32AARCH64JavaThreadPDAccess;\n@@ -102,0 +103,2 @@\n+            } else if (cpu.equals(\"aarch64\")) {\n+                access =  new Win32AARCH64JavaThreadPDAccess();\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/Threads.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,140 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Microsoft Corporation. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+package sun.jvm.hotspot.runtime.win32_aarch64;\n+\n+import java.io.*;\n+import java.util.*;\n+import sun.jvm.hotspot.debugger.*;\n+import sun.jvm.hotspot.debugger.aarch64.*;\n+import sun.jvm.hotspot.runtime.*;\n+import sun.jvm.hotspot.runtime.aarch64.*;\n+import sun.jvm.hotspot.types.*;\n+import sun.jvm.hotspot.utilities.*;\n+import sun.jvm.hotspot.utilities.Observable;\n+import sun.jvm.hotspot.utilities.Observer;\n+\n+\/** This class is only public to allow using the VMObjectFactory to\n+    instantiate these.\n+*\/\n+\n+public class Win32AARCH64JavaThreadPDAccess implements JavaThreadPDAccess {\n+  private static AddressField  lastJavaFPField;\n+  private static AddressField  osThreadField;\n+\n+  \/\/ Field from OSThread\n+  private static Field         osThreadThreadIDField;\n+\n+  \/\/ This is currently unneeded but is being kept in case we change\n+  \/\/ the currentFrameGuess algorithm\n+  private static final long GUESS_SCAN_RANGE = 128 * 1024;\n+\n+  static {\n+    VM.registerVMInitializedObserver(new Observer() {\n+        public void update(Observable o, Object data) {\n+          initialize(VM.getVM().getTypeDataBase());\n+        }\n+      });\n+  }\n+\n+  private static synchronized void initialize(TypeDataBase db) {\n+    Type type = db.lookupType(\"JavaThread\");\n+    osThreadField           = type.getAddressField(\"_osthread\");\n+\n+    Type anchorType = db.lookupType(\"JavaFrameAnchor\");\n+    lastJavaFPField         = anchorType.getAddressField(\"_last_Java_fp\");\n+\n+    Type osThreadType = db.lookupType(\"OSThread\");\n+    osThreadThreadIDField = osThreadType.getField(\"_thread_id\");\n+  }\n+\n+  public Address getLastJavaFP(Address addr) {\n+    return lastJavaFPField.getValue(addr.addOffsetTo(sun.jvm.hotspot.runtime.JavaThread.getAnchorField().getOffset()));\n+  }\n+\n+  public Address getLastJavaPC(Address addr) {\n+    return null;\n+  }\n+\n+  public Address getBaseOfStackPointer(Address addr) {\n+    return null;\n+  }\n+\n+  public Frame getLastFramePD(JavaThread thread, Address addr) {\n+    Address fp = thread.getLastJavaFP();\n+    if (fp == null) {\n+      return null; \/\/ no information\n+    }\n+    Address pc =  thread.getLastJavaPC();\n+    if ( pc != null ) {\n+      return new AARCH64Frame(thread.getLastJavaSP(), fp, pc);\n+    } else {\n+      return new AARCH64Frame(thread.getLastJavaSP(), fp);\n+    }\n+  }\n+\n+  public RegisterMap newRegisterMap(JavaThread thread, boolean updateMap) {\n+    return new AARCH64RegisterMap(thread, updateMap);\n+  }\n+\n+  public Frame getCurrentFrameGuess(JavaThread thread, Address addr) {\n+    ThreadProxy t = getThreadProxy(addr);\n+    AARCH64ThreadContext context = (AARCH64ThreadContext) t.getContext();\n+    AARCH64CurrentFrameGuess guesser = new AARCH64CurrentFrameGuess(context, thread);\n+    if (!guesser.run(GUESS_SCAN_RANGE)) {\n+      return null;\n+    }\n+    if (guesser.getPC() == null) {\n+      return new AARCH64Frame(guesser.getSP(), guesser.getFP());\n+    } else {\n+      return new AARCH64Frame(guesser.getSP(), guesser.getFP(), guesser.getPC());\n+    }\n+  }\n+\n+  public void printThreadIDOn(Address addr, PrintStream tty) {\n+    tty.print(getThreadProxy(addr));\n+  }\n+\n+  public void printInfoOn(Address threadAddr, PrintStream tty) {\n+  }\n+\n+  public Address getLastSP(Address addr) {\n+    ThreadProxy t = getThreadProxy(addr);\n+    AARCH64ThreadContext context = (AARCH64ThreadContext) t.getContext();\n+    return context.getRegisterAsAddress(AARCH64ThreadContext.SP);\n+  }\n+\n+  public ThreadProxy getThreadProxy(Address addr) {\n+    \/\/ Addr is the address of the JavaThread.\n+    \/\/ Fetch the OSThread (for now and for simplicity, not making a\n+    \/\/ separate \"OSThread\" class in this package)\n+    Address osThreadAddr = osThreadField.getValue(addr);\n+    \/\/ Get the address of the thread_id within the OSThread\n+    Address threadIdAddr = osThreadAddr.addOffsetTo(osThreadThreadIDField.getOffset());\n+\n+    JVMDebugger debugger = VM.getVM().getDebugger();\n+    return debugger.getThreadForIdentifierAddress(threadIdAddr);\n+  }\n+}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/win32_aarch64\/Win32AARCH64JavaThreadPDAccess.java","additions":140,"deletions":0,"binary":false,"changes":140,"status":"added"},{"patch":"@@ -39,0 +39,3 @@\n+#elif _M_ARM64\n+  #include \"sun_jvm_hotspot_debugger_aarch64_AARCH64ThreadContext.h\"\n+  #define NPRGREG sun_jvm_hotspot_debugger_aarch64_AARCH64ThreadContext_NPRGREG\n","filename":"src\/jdk.hotspot.agent\/windows\/native\/libsaproc\/sawindbg.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"}]}