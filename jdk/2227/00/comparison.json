{"files":[{"patch":"@@ -135,5 +135,0 @@\n-PerfCounter*    ClassLoader::_sync_systemLoaderLockContentionRate = NULL;\n-PerfCounter*    ClassLoader::_sync_nonSystemLoaderLockContentionRate = NULL;\n-PerfCounter*    ClassLoader::_sync_JVMFindLoadedClassLockFreeCounter = NULL;\n-PerfCounter*    ClassLoader::_sync_JVMDefineClassLockFreeCounter = NULL;\n-PerfCounter*    ClassLoader::_sync_JNIDefineClassLockFreeCounter = NULL;\n@@ -1465,19 +1460,1 @@\n-\n-    \/\/ The following performance counters are added for measuring the impact\n-    \/\/ of the bug fix of 6365597. They are mainly focused on finding out\n-    \/\/ the behavior of system & user-defined classloader lock, whether\n-    \/\/ ClassLoader.loadClass\/findClass is being called synchronized or not.\n-    NEWPERFEVENTCOUNTER(_sync_systemLoaderLockContentionRate, SUN_CLS,\n-                        \"systemLoaderLockContentionRate\");\n-    NEWPERFEVENTCOUNTER(_sync_nonSystemLoaderLockContentionRate, SUN_CLS,\n-                        \"nonSystemLoaderLockContentionRate\");\n-    NEWPERFEVENTCOUNTER(_sync_JVMFindLoadedClassLockFreeCounter, SUN_CLS,\n-                        \"jvmFindLoadedClassNoLockCalls\");\n-    NEWPERFEVENTCOUNTER(_sync_JVMDefineClassLockFreeCounter, SUN_CLS,\n-                        \"jvmDefineClassNoLockCalls\");\n-\n-    NEWPERFEVENTCOUNTER(_sync_JNIDefineClassLockFreeCounter, SUN_CLS,\n-                        \"jniDefineClassNoLockCalls\");\n-\n-    NEWPERFEVENTCOUNTER(_unsafe_defineClassCallCounter, SUN_CLS,\n-                        \"unsafeDefineClassCalls\");\n+    NEWPERFEVENTCOUNTER(_unsafe_defineClassCallCounter, SUN_CLS, \"unsafeDefineClassCalls\");\n","filename":"src\/hotspot\/share\/classfile\/classLoader.cpp","additions":1,"deletions":24,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -185,6 +185,0 @@\n-  static PerfCounter* _sync_systemLoaderLockContentionRate;\n-  static PerfCounter* _sync_nonSystemLoaderLockContentionRate;\n-  static PerfCounter* _sync_JVMFindLoadedClassLockFreeCounter;\n-  static PerfCounter* _sync_JVMDefineClassLockFreeCounter;\n-  static PerfCounter* _sync_JNIDefineClassLockFreeCounter;\n-\n@@ -308,25 +302,0 @@\n-  \/\/ Record how often system loader lock object is contended\n-  static PerfCounter* sync_systemLoaderLockContentionRate() {\n-    return _sync_systemLoaderLockContentionRate;\n-  }\n-\n-  \/\/ Record how often non system loader lock object is contended\n-  static PerfCounter* sync_nonSystemLoaderLockContentionRate() {\n-    return _sync_nonSystemLoaderLockContentionRate;\n-  }\n-\n-  \/\/ Record how many calls to JVM_FindLoadedClass w\/o holding a lock\n-  static PerfCounter* sync_JVMFindLoadedClassLockFreeCounter() {\n-    return _sync_JVMFindLoadedClassLockFreeCounter;\n-  }\n-\n-  \/\/ Record how many calls to JVM_DefineClass w\/o holding a lock\n-  static PerfCounter* sync_JVMDefineClassLockFreeCounter() {\n-    return _sync_JVMDefineClassLockFreeCounter;\n-  }\n-\n-  \/\/ Record how many calls to jni_DefineClass w\/o holding a lock\n-  static PerfCounter* sync_JNIDefineClassLockFreeCounter() {\n-    return _sync_JNIDefineClassLockFreeCounter;\n-  }\n-\n","filename":"src\/hotspot\/share\/classfile\/classLoader.hpp","additions":0,"deletions":31,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -195,16 +195,0 @@\n-\/\/ This method is added to check how often we have to wait to grab loader\n-\/\/ lock. The results are being recorded in the performance counters defined in\n-\/\/ ClassLoader::_sync_nonSystemLoaderLockContentionRate.\n-void SystemDictionary::check_loader_lock_contention(Thread* thread, Handle loader_lock) {\n-  if (!UsePerfData) {\n-    return;\n-  }\n-\n-  if (loader_lock.is_null()) return;\n-\n-  if (ObjectSynchronizer::query_lock_ownership(thread->as_Java_thread(), loader_lock)\n-      == ObjectSynchronizer::owner_other) {\n-    ClassLoader::sync_nonSystemLoaderLockContentionRate()->inc();\n-  }\n-}\n-\n@@ -734,1 +718,0 @@\n-  check_loader_lock_contention(THREAD, lockObject);\n@@ -1111,1 +1094,0 @@\n-  check_loader_lock_contention(THREAD, lockObject);\n@@ -1400,1 +1382,0 @@\n-    check_loader_lock_contention(THREAD, lockObject);\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":0,"deletions":19,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -613,1 +613,0 @@\n-  static void check_loader_lock_contention(Thread* thread, Handle loader_lock);\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -284,10 +284,0 @@\n-\n-  if (UsePerfData && !class_loader.is_null()) {\n-    \/\/ check whether the current caller thread holds the lock or not.\n-    \/\/ If not, increment the corresponding counter\n-    if (ObjectSynchronizer::\n-        query_lock_ownership(thread, class_loader) !=\n-        ObjectSynchronizer::owner_self) {\n-      ClassLoader::sync_JNIDefineClassLockFreeCounter()->inc();\n-    }\n-  }\n","filename":"src\/hotspot\/share\/prims\/jni.cpp","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -843,13 +843,0 @@\n-static void is_lock_held_by_thread(Handle loader, PerfCounter* counter, TRAPS) {\n-  if (loader.is_null()) {\n-    return;\n-  }\n-\n-  \/\/ check whether the current caller thread holds the lock or not.\n-  \/\/ If not, increment the corresponding counter\n-  if (ObjectSynchronizer::query_lock_ownership(THREAD->as_Java_thread(), loader) !=\n-      ObjectSynchronizer::owner_self) {\n-    counter->inc();\n-  }\n-}\n-\n@@ -884,5 +871,0 @@\n-  if (UsePerfData) {\n-    is_lock_held_by_thread(class_loader,\n-                           ClassLoader::sync_JVMDefineClassLockFreeCounter(),\n-                           THREAD);\n-  }\n@@ -1098,6 +1080,0 @@\n-  if (UsePerfData) {\n-    is_lock_held_by_thread(h_loader,\n-                           ClassLoader::sync_JVMFindLoadedClassLockFreeCounter(),\n-                           THREAD);\n-  }\n-\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":0,"deletions":24,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -1042,47 +1042,0 @@\n-\/\/ Be aware of this method could revoke bias of the lock object.\n-\/\/ This method queries the ownership of the lock handle specified by 'h_obj'.\n-\/\/ If the current thread owns the lock, it returns owner_self. If no\n-\/\/ thread owns the lock, it returns owner_none. Otherwise, it will return\n-\/\/ owner_other.\n-ObjectSynchronizer::LockOwnership ObjectSynchronizer::query_lock_ownership\n-(JavaThread *self, Handle h_obj) {\n-  \/\/ The caller must beware this method can revoke bias, and\n-  \/\/ revocation can result in a safepoint.\n-  assert(!SafepointSynchronize::is_at_safepoint(), \"invariant\");\n-  assert(self->thread_state() != _thread_blocked, \"invariant\");\n-\n-  \/\/ Possible mark states: neutral, biased, stack-locked, inflated\n-\n-  if (UseBiasedLocking && h_obj()->mark().has_bias_pattern()) {\n-    \/\/ CASE: biased\n-    BiasedLocking::revoke(h_obj, self);\n-    assert(!h_obj->mark().has_bias_pattern(),\n-           \"biases should be revoked by now\");\n-  }\n-\n-  assert(self == JavaThread::current(), \"Can only be called on current thread\");\n-  oop obj = h_obj();\n-  markWord mark = read_stable_mark(obj);\n-\n-  \/\/ CASE: stack-locked.  Mark points to a BasicLock on the owner's stack.\n-  if (mark.has_locker()) {\n-    return self->is_lock_owned((address)mark.locker()) ?\n-      owner_self : owner_other;\n-  }\n-\n-  \/\/ CASE: inflated. Mark (tagged pointer) points to an ObjectMonitor.\n-  if (mark.has_monitor()) {\n-    \/\/ The first stage of async deflation does not affect any field\n-    \/\/ used by this comparison so the ObjectMonitor* is usable here.\n-    ObjectMonitor* monitor = mark.monitor();\n-    void* owner = monitor->owner();\n-    if (owner == NULL) return owner_none;\n-    return (owner == self ||\n-            self->is_lock_owned((address)owner)) ? owner_self : owner_other;\n-  }\n-\n-  \/\/ CASE: neutral\n-  assert(mark.is_neutral(), \"sanity check\");\n-  return owner_none;           \/\/ it's unlocked\n-}\n-\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":0,"deletions":47,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -42,6 +42,0 @@\n-  typedef enum {\n-    owner_self,\n-    owner_none,\n-    owner_other\n-  } LockOwnership;\n-\n@@ -109,1 +103,0 @@\n-  static LockOwnership query_lock_ownership(JavaThread* self, Handle h_obj);\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.hpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"}]}