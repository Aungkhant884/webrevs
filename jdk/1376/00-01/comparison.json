{"files":[{"patch":"@@ -187,6 +187,0 @@\n-  \/\/ This check is racing with a call to Reference.clear() from the application.\n-  \/\/ If the application clears the reference after this check it will still end\n-  \/\/ up on the pending list, and there's nothing we can do about that without\n-  \/\/ changing the Reference.clear() API. This check is also racing with a call\n-  \/\/ to Reference.enqueue() from the application, which is unproblematic, since\n-  \/\/ the application wants the reference to be enqueued anyway.\n","filename":"src\/hotspot\/share\/gc\/z\/zReferenceProcessor.cpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -55,1 +55,5 @@\n-               !WB.isObjectInOldGen(testB)) {\n+               !WB.isObjectInOldGen(testB) ||\n+               !WB.isObjectInOldGen(refA1) ||\n+               !WB.isObjectInOldGen(refA2) ||\n+               !WB.isObjectInOldGen(refB1) ||\n+               !WB.isObjectInOldGen(refB2)) {\n@@ -65,1 +69,2 @@\n-            refA1.clear();      \/\/ Clear A1 early in marking.\n+            \/\/ Clear A1 early in marking, before reference discovery.\n+            refA1.clear();\n@@ -68,1 +73,2 @@\n-            refB1.clear();      \/\/ Clear B1 late in marking.\n+            \/\/ Clear B1 late in marking, after reference discovery.\n+            refB1.clear();\n","filename":"test\/hotspot\/jtreg\/gc\/TestReferenceClearDuringMarking.java","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -55,1 +55,2 @@\n-        while (!WB.isObjectInOldGen(testObject)) {\n+        while (!WB.isObjectInOldGen(testObject) ||\n+               !WB.isObjectInOldGen(ref)) {\n","filename":"test\/hotspot\/jtreg\/gc\/TestReferenceClearDuringReferenceProcessing.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"}]}