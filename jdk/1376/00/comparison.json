{"files":[{"patch":"@@ -180,0 +180,1 @@\n+JVM_ReferenceClear\n","filename":"make\/hotspot\/symbols\/symbols-unix","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -60,0 +60,4 @@\n+\n+void ZBreakpoint::at_after_reference_processing_started() {\n+  ConcurrentGCBreakpoints::at(\"AFTER CONCURRENT REFERENCE PROCESSING STARTED\");\n+}\n","filename":"src\/hotspot\/share\/gc\/z\/zBreakpoint.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+  static void at_after_reference_processing_started();\n","filename":"src\/hotspot\/share\/gc\/z\/zBreakpoint.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -325,0 +325,1 @@\n+  ZBreakpoint::at_after_reference_processing_started();\n","filename":"src\/hotspot\/share\/gc\/z\/zDriver.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -336,0 +336,3 @@\n+JNIEXPORT void JNICALL\n+JVM_ReferenceClear(JNIEnv *env, jobject ref);\n+\n","filename":"src\/hotspot\/share\/include\/jvm.h","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -3449,0 +3449,19 @@\n+JVM_ENTRY(void, JVM_ReferenceClear(JNIEnv* env, jobject ref))\n+  JVMWrapper(\"JVM_ReferenceClear\");\n+  oop ref_oop = JNIHandles::resolve_non_null(ref);\n+  \/\/ FinalReference has it's own implementation of clear().\n+  assert(!java_lang_ref_Reference::is_final(ref_oop), \"precondition\");\n+  if (java_lang_ref_Reference::unknown_referent_no_keepalive(ref_oop) == NULL) {\n+    \/\/ If the referent has already been cleared then done.\n+    \/\/ However, if the referent is dead but has not yet been cleared by\n+    \/\/ concurrent reference processing, it should NOT be cleared here.\n+    \/\/ Instead, clearing should be left to the GC.  Clearing it here could\n+    \/\/ detectably lose an expected notification, which is impossible with\n+    \/\/ STW reference processing.  The clearing in enqueue() doesn't have\n+    \/\/ this problem, since the enqueue covers the notification, but it's not\n+    \/\/ worth the effort to handle that case specially.\n+    return;\n+  }\n+  java_lang_ref_Reference::clear_referent(ref_oop);\n+JVM_END\n+\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,0 +37,16 @@\n+    \/* May only be called when the reference is inactive, so no longer weak. *\/\n+    @Override\n+    public T get() {\n+        \/\/ Cannot call super.get() when active, as the GC could\n+        \/\/ deactivate immediately after the test.\n+        return getFromInactiveFinalReference();\n+    }\n+\n+    \/* May only be called when the reference is inactive, so no longer weak.\n+     * Clearing while active would discard the finalization request.\n+     *\/\n+    @Override\n+    public void clear() {\n+        clearInactiveFinalReference();\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ref\/FinalReference.java","additions":17,"deletions":1,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -85,1 +85,1 @@\n-            Object finalizee = this.getInactive();\n+            Object finalizee = this.get();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ref\/Finalizer.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -103,1 +103,1 @@\n-     *                            clear\n+     *                            clear [2]\n@@ -106,1 +106,1 @@\n-     *          |                                 | enqueue [2]\n+     *          |                                 | enqueue\n@@ -117,1 +117,1 @@\n-     *          | poll\/remove                     |\n+     *          | poll\/remove                     | + clear [4]\n@@ -143,2 +143,2 @@\n-     * [pending\/enqueued] and [pending\/dequeued] unreachable, and\n-     * [inactive\/registered] terminal.\n+     * [pending\/enqueued], [pending\/dequeued], and [inactive\/registered]\n+     * unreachable.\n@@ -149,0 +149,2 @@\n+     *\n+     * [4] The queue handler for FinalReferences also clears the reference.\n@@ -345,16 +347,0 @@\n-    \/**\n-     * Load referent with strong semantics. Treating the referent\n-     * as strong referent is ok when the Reference is inactive,\n-     * because then the referent is switched to strong semantics\n-     * anyway.\n-     *\n-     * This is only used from Finalizer to bypass the intrinsic,\n-     * which might return a null referent, even though it is not\n-     * null, and would subsequently not finalize the referent\/finalizee.\n-     *\/\n-    T getInactive() {\n-        assert this instanceof FinalReference;\n-        assert next == this; \/\/ I.e. FinalReference is inactive\n-        return this.referent;\n-    }\n-\n@@ -386,0 +372,35 @@\n+        clear0();\n+    }\n+\n+    \/* Implementation of clear(), also used by enqueue().  A simple\n+     * assignment of the referent field won't do for some garbage\n+     * collectors.\n+     *\/\n+    private native void clear0();\n+\n+    \/* -- Operations on inactive FinalReferences -- *\/\n+\n+    \/* These functions are only used by FinalReference, and must only be\n+     * called after the reference becomes inactive. While active, a\n+     * FinalReference is considered weak but the referent is not normally\n+     * accessed. Once a FinalReference becomes inactive it is considered a\n+     * strong reference. These functions are used to bypass the\n+     * corresponding weak implementations, directly accessing the referent\n+     * field with strong semantics.\n+     *\/\n+\n+    \/**\n+     * Load referent with strong semantics.\n+     *\/\n+    T getFromInactiveFinalReference() {\n+        assert this instanceof FinalReference;\n+        assert next != null; \/\/ I.e. FinalReference is inactive\n+        return this.referent;\n+    }\n+\n+    \/**\n+     * Clear referent with strong semantics.\n+     *\/\n+    void clearInactiveFinalReference() {\n+        assert this instanceof FinalReference;\n+        assert next != null; \/\/ I.e. FinalReference is inactive\n@@ -416,1 +437,1 @@\n-        this.referent = null;\n+        clear0();               \/\/ Intentionally clear0() rather than clear()\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ref\/Reference.java","additions":43,"deletions":22,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -52,0 +52,6 @@\n+\n+JNIEXPORT void JNICALL\n+Java_java_lang_ref_Reference_clear0(JNIEnv *env, jobject ref)\n+{\n+    JVM_ReferenceClear(env, ref);\n+}\n","filename":"src\/java.base\/share\/native\/libjava\/Reference.c","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,90 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package gc;\n+\n+\/* @test\n+ * @bug 8240696\n+ * @library \/test\/lib\n+ * @build sun.hotspot.WhiteBox\n+ * @modules java.base\n+ * @run main ClassFileInstaller sun.hotspot.WhiteBox\n+ * @run main\/othervm\n+ *      -Xbootclasspath\/a:.\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *      gc.TestReferenceClearDuringMarking\n+ *\/\n+\n+import java.lang.ref.WeakReference;\n+import sun.hotspot.WhiteBox;\n+\n+public class TestReferenceClearDuringMarking {\n+    private static final WhiteBox WB = WhiteBox.getWhiteBox();\n+\n+    private static Object testA = new Object();\n+    private static Object testB = new Object();\n+\n+    private static final WeakReference<Object> refA1 = new WeakReference<Object>(testA);\n+    private static final WeakReference<Object> refA2 = new WeakReference<Object>(testA);\n+\n+    private static final WeakReference<Object> refB1 = new WeakReference<Object>(testB);\n+    private static final WeakReference<Object> refB2 = new WeakReference<Object>(testB);\n+\n+    private static void test() {\n+        while (!WB.isObjectInOldGen(testA) ||\n+               !WB.isObjectInOldGen(testB)) {\n+            WB.fullGC();\n+        }\n+\n+        WB.concurrentGCAcquireControl();\n+        try {\n+            testA = null;\n+            testB = null;\n+\n+            WB.concurrentGCRunTo(WB.AFTER_MARKING_STARTED);\n+            refA1.clear();      \/\/ Clear A1 early in marking.\n+\n+            WB.concurrentGCRunTo(WB.BEFORE_MARKING_COMPLETED);\n+            refB1.clear();      \/\/ Clear B1 late in marking.\n+\n+            WB.concurrentGCRunToIdle();\n+\n+            \/\/ Verify that A2 and B2 still cleared by GC, i.e. the preceding\n+            \/\/ clear operations did not extend the lifetime of the referents.\n+            if (!refA2.refersTo(null)) {\n+                throw new RuntimeException(\"refA2 not cleared\");\n+            }\n+            if (!refB2.refersTo(null)) {\n+                throw new RuntimeException(\"refB2 not cleared\");\n+            }\n+        } finally {\n+            WB.concurrentGCReleaseControl();\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        if (WB.supportsConcurrentGCBreakpoints()) {\n+            test();\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/gc\/TestReferenceClearDuringMarking.java","additions":90,"deletions":0,"binary":false,"changes":90,"status":"added"},{"patch":"@@ -0,0 +1,96 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package gc;\n+\n+\/* @test\n+ * @bug 8256517\n+ * @requires vm.gc.Z\n+ * @requires vm.gc != \"null\"\n+ * @library \/test\/lib\n+ * @build sun.hotspot.WhiteBox\n+ * @modules java.base\n+ * @run main ClassFileInstaller sun.hotspot.WhiteBox\n+ * @run main\/othervm\n+ *      -Xbootclasspath\/a:.\n+ *      -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *      gc.TestReferenceClearDuringReferenceProcessing\n+ *\/\n+\n+import java.lang.ref.Reference;\n+import java.lang.ref.ReferenceQueue;\n+import java.lang.ref.WeakReference;\n+import sun.hotspot.WhiteBox;\n+\n+public class TestReferenceClearDuringReferenceProcessing {\n+    private static final WhiteBox WB = WhiteBox.getWhiteBox();\n+\n+    private static Object testObject = new Object();\n+    private static final ReferenceQueue<Object> queue = new ReferenceQueue<Object>();\n+    private static final WeakReference<Object> ref = new WeakReference<Object>(testObject, queue);\n+\n+    private static final long TIMEOUT = 10000; \/\/ 10sec in millis\n+\n+    private static void test() {\n+        while (!WB.isObjectInOldGen(testObject)) {\n+            WB.fullGC();\n+        }\n+\n+        WB.concurrentGCAcquireControl();\n+        try {\n+            testObject = null;\n+            WB.concurrentGCRunTo(WB.AFTER_CONCURRENT_REFERENCE_PROCESSING_STARTED);\n+            if (!ref.refersTo(null)) {\n+                throw new RuntimeException(\"ref not apparently cleared\");\n+            }\n+\n+            ref.clear();\n+\n+            WB.concurrentGCRunToIdle();\n+\n+            Reference<? extends Object> enqueued = null;\n+\n+            try {\n+                enqueued = queue.remove(TIMEOUT);\n+            } catch (InterruptedException e) {\n+                throw new RuntimeException(\"queue.remove interrupted\");\n+            }\n+            if (enqueued == null) {\n+                throw new RuntimeException(\"ref not enqueued\");\n+            } else if (enqueued != ref) {\n+                throw new RuntimeException(\"some other ref enqeueued\");\n+            }\n+        } finally {\n+            WB.concurrentGCReleaseControl();\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        if (WB.supportsConcurrentGCBreakpoints()) {\n+            \/\/ Also requires concurrent reference processing, but we\n+            \/\/ don't have a predicate for that.  For now,\n+            \/\/ use @requires and CLA to limit the applicable collectors.\n+            test();\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/gc\/TestReferenceClearDuringReferenceProcessing.java","additions":96,"deletions":0,"binary":false,"changes":96,"status":"added"},{"patch":"@@ -453,0 +453,5 @@\n+  \/\/ Collectors supporting concurrent GC breakpoints that do reference\n+  \/\/ processing concurrently should provide the following breakpoint.\n+  public final String AFTER_CONCURRENT_REFERENCE_PROCESSING_STARTED =\n+    \"AFTER CONCURRENT REFERENCE PROCESSING STARTED\";\n+\n","filename":"test\/lib\/sun\/hotspot\/WhiteBox.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"}]}