{"files":[{"patch":"@@ -988,0 +988,209 @@\n+\n+    \/* expm1(x)\n+     * Returns exp(x)-1, the exponential of x minus 1.\n+     *\n+     * Method\n+     *   1. Argument reduction:\n+     *      Given x, find r and integer k such that\n+     *\n+     *               x = k*ln2 + r,  |r| <= 0.5*ln2 ~ 0.34658\n+     *\n+     *      Here a correction term c will be computed to compensate\n+     *      the error in r when rounded to a floating-point number.\n+     *\n+     *   2. Approximating expm1(r) by a special rational function on\n+     *      the interval [0,0.34658]:\n+     *      Since\n+     *          r*(exp(r)+1)\/(exp(r)-1) = 2+ r^2\/6 - r^4\/360 + ...\n+     *      we define R1(r*r) by\n+     *          r*(exp(r)+1)\/(exp(r)-1) = 2+ r^2\/6 * R1(r*r)\n+     *      That is,\n+     *          R1(r**2) = 6\/r *((exp(r)+1)\/(exp(r)-1) - 2\/r)\n+     *                   = 6\/r * ( 1 + 2.0*(1\/(exp(r)-1) - 1\/r))\n+     *                   = 1 - r^2\/60 + r^4\/2520 - r^6\/100800 + ...\n+     *      We use a special Reme algorithm on [0,0.347] to generate\n+     *      a polynomial of degree 5 in r*r to approximate R1. The\n+     *      maximum error of this polynomial approximation is bounded\n+     *      by 2**-61. In other words,\n+     *          R1(z) ~ 1.0 + Q1*z + Q2*z**2 + Q3*z**3 + Q4*z**4 + Q5*z**5\n+     *      where   Q1  =  -1.6666666666666567384E-2,\n+     *              Q2  =   3.9682539681370365873E-4,\n+     *              Q3  =  -9.9206344733435987357E-6,\n+     *              Q4  =   2.5051361420808517002E-7,\n+     *              Q5  =  -6.2843505682382617102E-9;\n+     *      (where z=r*r, and the values of Q1 to Q5 are listed below)\n+     *      with error bounded by\n+     *          |                  5           |     -61\n+     *          | 1.0+Q1*z+...+Q5*z   -  R1(z) | <= 2\n+     *          |                              |\n+     *\n+     *      expm1(r) = exp(r)-1 is then computed by the following\n+     *      specific way which minimize the accumulation rounding error:\n+     *                             2     3\n+     *                            r     r    [ 3 - (R1 + R1*r\/2)  ]\n+     *            expm1(r) = r + --- + --- * [--------------------]\n+     *                            2     2    [ 6 - r*(3 - R1*r\/2) ]\n+     *\n+     *      To compensate the error in the argument reduction, we use\n+     *              expm1(r+c) = expm1(r) + c + expm1(r)*c\n+     *                         ~ expm1(r) + c + r*c\n+     *      Thus c+r*c will be added in as the correction terms for\n+     *      expm1(r+c). Now rearrange the term to avoid optimization\n+     *      screw up:\n+     *                      (      2                                    2 )\n+     *                      ({  ( r    [ R1 -  (3 - R1*r\/2) ]  )  }    r  )\n+     *       expm1(r+c)~r - ({r*(--- * [--------------------]-c)-c} - --- )\n+     *                      ({  ( 2    [ 6 - r*(3 - R1*r\/2) ]  )  }    2  )\n+     *                      (                                             )\n+     *\n+     *                 = r - E\n+     *   3. Scale back to obtain expm1(x):\n+     *      From step 1, we have\n+     *         expm1(x) = either 2^k*[expm1(r)+1] - 1\n+     *                  = or     2^k*[expm1(r) + (1-2^-k)]\n+     *   4. Implementation notes:\n+     *      (A). To save one multiplication, we scale the coefficient Qi\n+     *           to Qi*2^i, and replace z by (x^2)\/2.\n+     *      (B). To achieve maximum accuracy, we compute expm1(x) by\n+     *        (i)   if x < -56*ln2, return -1.0, (raise inexact if x!=inf)\n+     *        (ii)  if k=0, return r-E\n+     *        (iii) if k=-1, return 0.5*(r-E)-0.5\n+     *        (iv)  if k=1 if r < -0.25, return 2*((r+0.5)- E)\n+     *                     else          return  1.0+2.0*(r-E);\n+     *        (v)   if (k<-2||k>56) return 2^k(1-(E-r)) - 1 (or exp(x)-1)\n+     *        (vi)  if k <= 20, return 2^k((1-2^-k)-(E-r)), else\n+     *        (vii) return 2^k(1-((E+2^-k)-r))\n+     *\n+     * Special cases:\n+     *      expm1(INF) is INF, expm1(NaN) is NaN;\n+     *      expm1(-INF) is -1, and\n+     *      for finite argument, only expm1(0)=0 is exact.\n+     *\n+     * Accuracy:\n+     *      according to an error analysis, the error is always less than\n+     *      1 ulp (unit in the last place).\n+     *\n+     * Misc. info.\n+     *      For IEEE double\n+     *          if x >  7.09782712893383973096e+02 then expm1(x) overflow\n+     *\n+     * Constants:\n+     * The hexadecimal values are the intended ones for the following\n+     * constants. The decimal values may be used, provided that the\n+     * compiler will convert from decimal to binary accurately enough\n+     * to produce the hexadecimal values shown.\n+     *\/\n+    static class Expm1 {\n+        private static final double one         =  1.0;\n+        private static final double huge        =  1.0e+300;\n+        private static final double tiny        =  1.0e-300;\n+        private static final double o_threshold =  0x1.62e42fefa39efp9;   \/\/  7.09782712893383973096e+02\n+        private static final double ln2_hi      =  0x1.62e42feep-1;       \/\/  6.93147180369123816490e-01\n+        private static final double ln2_lo      =  0x1.a39ef35793c76p-33; \/\/  1.90821492927058770002e-10\n+        private static final double invln2      =  0x1.71547652b82fep0;   \/\/  1.44269504088896338700e+00\n+        \/\/ scaled coefficients related to expm1\n+        private static final double Q1          = -0x1.11111111110f4p-5;  \/\/ -3.33333333333331316428e-02\n+        private static final double Q2          =  0x1.a01a019fe5585p-10; \/\/  1.58730158725481460165e-03\n+        private static final double Q3          = -0x1.4ce199eaadbb7p-14; \/\/ -7.93650757867487942473e-05\n+        private static final double Q4          =  0x1.0cfca86e65239p-18; \/\/  4.00821782732936239552e-06\n+        private static final double Q5          = -0x1.afdb76e09c32dp-23; \/\/ -2.01099218183624371326e-07\n+\n+        static double compute(double x) {\n+            double y, hi, lo, c=0, t, e, hxs, hfx, r1;\n+            int k, xsb;\n+            \/*unsigned*\/ int hx;\n+\n+            hx  = __HI(x);  \/\/ high word of x\n+            xsb = hx & 0x8000_0000;          \/\/ sign bit of x\n+            y = Math.abs(x);\n+            hx &= 0x7fff_ffff;               \/\/ high word of |x|\n+\n+            \/\/ filter out huge and non-finite argument\n+            if (hx >= 0x4043_687A) {                  \/\/ if |x| >= 56*ln2\n+                if (hx >= 0x4086_2E42) {              \/\/ if |x| >= 709.78...\n+                    if (hx >= 0x7ff_00000) {\n+                        if (((hx & 0xf_ffff) | __LO(x)) != 0) {\n+                            return x + x;     \/\/ NaN\n+                        } else {\n+                            return (xsb == 0)? x : -1.0; \/\/ exp(+-inf)={inf,-1}\n+                        }\n+                    }\n+                    if (x > o_threshold) {\n+                        return huge*huge; \/\/ overflow\n+                    }\n+                }\n+                if (xsb != 0) { \/\/ x < -56*ln2, return -1.0 with inexact\n+                    if (x + tiny < 0.0) {         \/\/ raise inexact\n+                        return tiny - one;        \/\/ return -1\n+                    }\n+                }\n+            }\n+\n+            \/\/ argument reduction\n+            if (hx > 0x3fd6_2e42) {         \/\/ if  |x| > 0.5 ln2\n+                if (hx < 0x3FF0_A2B2) {     \/\/ and |x| < 1.5 ln2\n+                    if (xsb == 0) {\n+                        hi = x - ln2_hi;\n+                        lo = ln2_lo;\n+                        k =  1;\n+                    } else {\n+                        hi = x + ln2_hi;\n+                        lo = -ln2_lo;\n+                        k = -1;\n+                    }\n+                } else {\n+                    k  = (int)(invln2*x + ((xsb == 0) ? 0.5 : -0.5));\n+                    t  = k;\n+                    hi = x - t*ln2_hi;      \/\/ t*ln2_hi is exact here\n+                    lo = t*ln2_lo;\n+                }\n+                x  = hi - lo;\n+                c  = (hi - x) - lo;\n+            } else if (hx < 0x3c90_0000) {  \/\/ when |x| < 2**-54, return x\n+                t = huge + x; \/\/ return x with inexact flags when x != 0\n+                return x - (t - (huge + x));\n+            } else {\n+                k = 0;\n+            }\n+\n+            \/\/ x is now in primary range\n+            hfx = 0.5*x;\n+            hxs = x*hfx;\n+            r1 = one + hxs*(Q1 + hxs*(Q2 + hxs*(Q3 + hxs*(Q4 + hxs*Q5))));\n+            t  = 3.0 - r1*hfx;\n+            e  = hxs *((r1 - t)\/(6.0 - x*t));\n+            if (k == 0) {\n+                return x - (x*e - hxs);          \/\/ c is 0\n+            } else {\n+                e  = (x*(e - c) - c);\n+                e -= hxs;\n+                if (k == -1) {\n+                    return 0.5*(x - e) - 0.5;\n+                }\n+                if (k == 1) {\n+                    if (x < -0.25) {\n+                        return -2.0*(e - (x + 0.5));\n+                    } else {\n+                        return one + 2.0*(x - e);\n+                    }\n+                }\n+                if (k <= -2 || k > 56) {   \/\/ suffice to return exp(x) - 1\n+                    y = one - (e - x);\n+                    y = __HI(y, __HI(y) + (k << 20));     \/\/ add k to y's exponent\n+                    return y - one;\n+                }\n+                t = one;\n+                if (k < 20) {\n+                    t = __HI(t, 0x3ff0_0000 - (0x2_00000 >> k));  \/\/ t = 1-2^-k\n+                    y = t - ( e - x);\n+                    y = __HI(y, __HI(y) + (k << 20));     \/\/ add k to y's exponent\n+                } else {\n+                    t = __HI(t, ((0x3ff - k) << 20));     \/\/ 2^-k\n+                    y = x - (e + t);\n+                    y += one;\n+                    y = __HI(y, __HI(y) + (k << 20));     \/\/ add k to y's exponent\n+                }\n+            }\n+            return y;\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/FdLibm.java","additions":209,"deletions":0,"binary":false,"changes":209,"status":"modified"},{"patch":"@@ -2096,1 +2096,3 @@\n-    public static native double expm1(double x);\n+    public static double expm1(double x) {\n+        return FdLibm.Expm1.compute(x);\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StrictMath.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,3 +26,7 @@\n- * @bug 4851638\n- * @summary Tests for StrictMath.expm1\n- * @compile -Xdiags:verbose Expm1Tests.java\n+ * @bug 4851638 8301396\n+ * @key randomness\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.RandomFactory\n+ * @build Tests\n+ * @build FdlibmTranslit\n+ * @build Expm1Tests\n@@ -30,0 +34,1 @@\n+ * @summary Tests for StrictMath.expm1\n@@ -31,0 +36,1 @@\n+import jdk.test.lib.RandomFactory;\n@@ -46,1 +52,84 @@\n-    static int testExpm1Case(double input, double expected) {\n+    public static void main(String... args) {\n+        int failures = 0;\n+\n+        failures += testAgainstTranslit();\n+        failures += testExpm1();\n+\n+        if (failures > 0) {\n+            System.err.println(\"Testing expm1 incurred \"\n+                               + failures + \" failures.\");\n+            throw new RuntimeException();\n+        }\n+    }\n+\n+    \/\/ Initialize shared random number generator\n+    private static java.util.Random random = RandomFactory.getRandom();\n+\n+    \/**\n+     * Test StrictMath.expm1 against transliteration port of expm1.\n+     *\/\n+    private static int testAgainstTranslit() {\n+        int failures = 0;\n+        double x;\n+\n+        \/\/ Test just above subnormal threshold...\n+        x = Double.MIN_NORMAL;\n+        failures += testRange(x, Math.ulp(x), 1000);\n+\n+        \/\/ ... and just below subnormal threshold ...\n+        x = Math.nextDown(Double.MIN_NORMAL);\n+        failures += testRange(x, -Math.ulp(x), 1000);\n+\n+        \/\/ ... and near 1.0 ...\n+        failures += testRangeMidpoint(1.0, Math.ulp(x), 2000);\n+        \/\/ (Note: probes every-other value less than 1.0 due to\n+        \/\/ change in the size of an ulp at 1.0.\n+\n+        \/\/ Probe near decision points in the FDLIBM algorithm.\n+        double LN2 = StrictMath.log(2.0);\n+        double[] decisionPoints = {\n+             7.09782712893383973096e+02, \/\/ overflow threshold\n+             56.0 * LN2,\n+            -56.0 * LN2,\n+             0.5 * LN2,\n+            -0.5 * LN2,\n+             1.5 * LN2,\n+            -1.5 * LN2,\n+             0x1.0p-54,\n+            -0x1.0p-54,\n+        };\n+\n+        for (double testPoint : decisionPoints) {\n+            failures += testRangeMidpoint(testPoint, Math.ulp(testPoint), 1000);\n+        }\n+\n+        x = Tests.createRandomDouble(random);\n+\n+        \/\/ Make the increment twice the ulp value in case the random\n+        \/\/ value is near an exponent threshold. Don't worry about test\n+        \/\/ elements overflowing to infinity if the starting value is\n+        \/\/ near Double.MAX_VALUE.\n+        failures += testRange(x, 2.0 * Math.ulp(x), 1000);\n+\n+        return failures;\n+    }\n+\n+    private static int testRange(double start, double increment, int count) {\n+        int failures = 0;\n+        double x = start;\n+        for (int i = 0; i < count; i++, x += increment) {\n+            failures += testExpm1Case(x, FdlibmTranslit.expm1(x));\n+        }\n+        return failures;\n+    }\n+\n+    private static int testRangeMidpoint(double midpoint, double increment, int count) {\n+        int failures = 0;\n+        double x = midpoint - increment*(count \/ 2) ;\n+        for (int i = 0; i < count; i++, x += increment) {\n+            failures += testExpm1Case(x, FdlibmTranslit.expm1(x));\n+        }\n+        return failures;\n+    }\n+\n+    private static int testExpm1Case(double input, double expected) {\n@@ -51,1 +140,1 @@\n-    static int testExpm1() {\n+    private static int testExpm1() {\n@@ -784,12 +873,0 @@\n-\n-    public static void main(String [] argv) {\n-        int failures = 0;\n-\n-        failures += testExpm1();\n-\n-        if (failures > 0) {\n-            System.err.println(\"Testing expm1 incurred \"\n-                               + failures + \" failures.\");\n-            throw new RuntimeException();\n-        }\n-    }\n","filename":"test\/jdk\/java\/lang\/StrictMath\/Expm1Tests.java","additions":95,"deletions":18,"binary":false,"changes":113,"status":"modified"},{"patch":"@@ -89,0 +89,4 @@\n+    public static double expm1(double x) {\n+        return Expm1.compute(x);\n+    }\n+\n@@ -614,0 +618,193 @@\n+\n+    \/* expm1(x)\n+     * Returns exp(x)-1, the exponential of x minus 1.\n+     *\n+     * Method\n+     *   1. Argument reduction:\n+     *      Given x, find r and integer k such that\n+     *\n+     *               x = k*ln2 + r,  |r| <= 0.5*ln2 ~ 0.34658\n+     *\n+     *      Here a correction term c will be computed to compensate\n+     *      the error in r when rounded to a floating-point number.\n+     *\n+     *   2. Approximating expm1(r) by a special rational function on\n+     *      the interval [0,0.34658]:\n+     *      Since\n+     *          r*(exp(r)+1)\/(exp(r)-1) = 2+ r^2\/6 - r^4\/360 + ...\n+     *      we define R1(r*r) by\n+     *          r*(exp(r)+1)\/(exp(r)-1) = 2+ r^2\/6 * R1(r*r)\n+     *      That is,\n+     *          R1(r**2) = 6\/r *((exp(r)+1)\/(exp(r)-1) - 2\/r)\n+     *                   = 6\/r * ( 1 + 2.0*(1\/(exp(r)-1) - 1\/r))\n+     *                   = 1 - r^2\/60 + r^4\/2520 - r^6\/100800 + ...\n+     *      We use a special Reme algorithm on [0,0.347] to generate\n+     *      a polynomial of degree 5 in r*r to approximate R1. The\n+     *      maximum error of this polynomial approximation is bounded\n+     *      by 2**-61. In other words,\n+     *          R1(z) ~ 1.0 + Q1*z + Q2*z**2 + Q3*z**3 + Q4*z**4 + Q5*z**5\n+     *      where   Q1  =  -1.6666666666666567384E-2,\n+     *              Q2  =   3.9682539681370365873E-4,\n+     *              Q3  =  -9.9206344733435987357E-6,\n+     *              Q4  =   2.5051361420808517002E-7,\n+     *              Q5  =  -6.2843505682382617102E-9;\n+     *      (where z=r*r, and the values of Q1 to Q5 are listed below)\n+     *      with error bounded by\n+     *          |                  5           |     -61\n+     *          | 1.0+Q1*z+...+Q5*z   -  R1(z) | <= 2\n+     *          |                              |\n+     *\n+     *      expm1(r) = exp(r)-1 is then computed by the following\n+     *      specific way which minimize the accumulation rounding error:\n+     *                             2     3\n+     *                            r     r    [ 3 - (R1 + R1*r\/2)  ]\n+     *            expm1(r) = r + --- + --- * [--------------------]\n+     *                            2     2    [ 6 - r*(3 - R1*r\/2) ]\n+     *\n+     *      To compensate the error in the argument reduction, we use\n+     *              expm1(r+c) = expm1(r) + c + expm1(r)*c\n+     *                         ~ expm1(r) + c + r*c\n+     *      Thus c+r*c will be added in as the correction terms for\n+     *      expm1(r+c). Now rearrange the term to avoid optimization\n+     *      screw up:\n+     *                      (      2                                    2 )\n+     *                      ({  ( r    [ R1 -  (3 - R1*r\/2) ]  )  }    r  )\n+     *       expm1(r+c)~r - ({r*(--- * [--------------------]-c)-c} - --- )\n+     *                      ({  ( 2    [ 6 - r*(3 - R1*r\/2) ]  )  }    2  )\n+     *                      (                                             )\n+     *\n+     *                 = r - E\n+     *   3. Scale back to obtain expm1(x):\n+     *      From step 1, we have\n+     *         expm1(x) = either 2^k*[expm1(r)+1] - 1\n+     *                  = or     2^k*[expm1(r) + (1-2^-k)]\n+     *   4. Implementation notes:\n+     *      (A). To save one multiplication, we scale the coefficient Qi\n+     *           to Qi*2^i, and replace z by (x^2)\/2.\n+     *      (B). To achieve maximum accuracy, we compute expm1(x) by\n+     *        (i)   if x < -56*ln2, return -1.0, (raise inexact if x!=inf)\n+     *        (ii)  if k=0, return r-E\n+     *        (iii) if k=-1, return 0.5*(r-E)-0.5\n+     *        (iv)  if k=1 if r < -0.25, return 2*((r+0.5)- E)\n+     *                     else          return  1.0+2.0*(r-E);\n+     *        (v)   if (k<-2||k>56) return 2^k(1-(E-r)) - 1 (or exp(x)-1)\n+     *        (vi)  if k <= 20, return 2^k((1-2^-k)-(E-r)), else\n+     *        (vii) return 2^k(1-((E+2^-k)-r))\n+     *\n+     * Special cases:\n+     *      expm1(INF) is INF, expm1(NaN) is NaN;\n+     *      expm1(-INF) is -1, and\n+     *      for finite argument, only expm1(0)=0 is exact.\n+     *\n+     * Accuracy:\n+     *      according to an error analysis, the error is always less than\n+     *      1 ulp (unit in the last place).\n+     *\n+     * Misc. info.\n+     *      For IEEE double\n+     *          if x >  7.09782712893383973096e+02 then expm1(x) overflow\n+     *\n+     * Constants:\n+     * The hexadecimal values are the intended ones for the following\n+     * constants. The decimal values may be used, provided that the\n+     * compiler will convert from decimal to binary accurately enough\n+     * to produce the hexadecimal values shown.\n+     *\/\n+    static class Expm1 {\n+        private static final double one             = 1.0;\n+        private static final double huge            = 1.0e+300;\n+        private static final double tiny            = 1.0e-300;\n+        private static final double o_threshold     = 7.09782712893383973096e+02; \/* 0x40862E42, 0xFEFA39EF *\/\n+        private static final double ln2_hi          = 6.93147180369123816490e-01; \/* 0x3fe62e42, 0xfee00000 *\/\n+        private static final double ln2_lo          = 1.90821492927058770002e-10; \/* 0x3dea39ef, 0x35793c76 *\/\n+        private static final double invln2          = 1.44269504088896338700e+00; \/* 0x3ff71547, 0x652b82fe *\/\n+        \/* scaled coefficients related to expm1 *\/\n+        private static final double Q1  =  -3.33333333333331316428e-02; \/* BFA11111 111110F4 *\/\n+        private static final double Q2  =   1.58730158725481460165e-03; \/* 3F5A01A0 19FE5585 *\/\n+        private static final double Q3  =  -7.93650757867487942473e-05; \/* BF14CE19 9EAADBB7 *\/\n+        private static final double Q4  =   4.00821782732936239552e-06; \/* 3ED0CFCA 86E65239 *\/\n+        private static final double Q5  =  -2.01099218183624371326e-07; \/* BE8AFDB7 6E09C32D *\/\n+\n+        static double compute(double x) {\n+            double y,hi,lo,c=0,t,e,hxs,hfx,r1;\n+            int k,xsb;\n+            \/*unsigned*\/ int hx;\n+\n+            hx  = __HI(x);  \/* high word of x *\/\n+            xsb = hx&0x80000000;            \/* sign bit of x *\/\n+            if(xsb==0) y=x; else y= -x;     \/* y = |x| *\/\n+            hx &= 0x7fffffff;               \/* high word of |x| *\/\n+\n+            \/* filter out huge and non-finite argument *\/\n+            if(hx >= 0x4043687A) {                  \/* if |x|>=56*ln2 *\/\n+                if(hx >= 0x40862E42) {              \/* if |x|>=709.78... *\/\n+                    if(hx>=0x7ff00000) {\n+                        if(((hx&0xfffff)|__LO(x))!=0)\n+                            return x+x;     \/* NaN *\/\n+                        else return (xsb==0)? x:-1.0;\/* exp(+-inf)={inf,-1} *\/\n+                    }\n+                    if(x > o_threshold) return huge*huge; \/* overflow *\/\n+                }\n+                if(xsb!=0) { \/* x < -56*ln2, return -1.0 with inexact *\/\n+                    if(x+tiny<0.0)          \/* raise inexact *\/\n+                        return tiny-one;        \/* return -1 *\/\n+                }\n+            }\n+\n+            \/* argument reduction *\/\n+            if(hx > 0x3fd62e42) {           \/* if  |x| > 0.5 ln2 *\/\n+                if(hx < 0x3FF0A2B2) {       \/* and |x| < 1.5 ln2 *\/\n+                    if(xsb==0)\n+                        {hi = x - ln2_hi; lo =  ln2_lo;  k =  1;}\n+                    else\n+                        {hi = x + ln2_hi; lo = -ln2_lo;  k = -1;}\n+                } else {\n+                    k  = (int)(invln2*x+((xsb==0)?0.5:-0.5));\n+                    t  = k;\n+                    hi = x - t*ln2_hi;      \/* t*ln2_hi is exact here *\/\n+                    lo = t*ln2_lo;\n+                }\n+                x  = hi - lo;\n+                c  = (hi-x)-lo;\n+            }\n+            else if(hx < 0x3c900000) {      \/* when |x|<2**-54, return x *\/\n+                t = huge+x; \/* return x with inexact flags when x!=0 *\/\n+                return x - (t-(huge+x));\n+            }\n+            else k = 0;\n+\n+            \/* x is now in primary range *\/\n+            hfx = 0.5*x;\n+            hxs = x*hfx;\n+            r1 = one+hxs*(Q1+hxs*(Q2+hxs*(Q3+hxs*(Q4+hxs*Q5))));\n+            t  = 3.0-r1*hfx;\n+            e  = hxs*((r1-t)\/(6.0 - x*t));\n+            if(k==0) return x - (x*e-hxs);          \/* c is 0 *\/\n+            else {\n+                e  = (x*(e-c)-c);\n+                e -= hxs;\n+                if(k== -1) return 0.5*(x-e)-0.5;\n+                if(k==1) {\n+                    if(x < -0.25) return -2.0*(e-(x+0.5));\n+                    else          return  one+2.0*(x-e);\n+                }\n+                if (k <= -2 || k>56) {   \/* suffice to return exp(x)-1 *\/\n+                    y = one-(e-x);\n+                    y = __HI(y,  __HI(y) + (k<<20));     \/* add k to y's exponent *\/\n+                    return y-one;\n+                }\n+                t = one;\n+                if(k<20) {\n+                    t = __HI(t, 0x3ff00000 - (0x200000>>k));  \/* t=1-2^-k *\/\n+                    y = t-(e-x);\n+                    y = __HI(y, __HI(y) + (k<<20));     \/* add k to y's exponent *\/\n+                } else {\n+                    t = __HI(t, ((0x3ff-k)<<20));     \/* 2^-k *\/\n+                    y = x-(e+t);\n+                    y += one;\n+                    y = __HI(y, __HI(y) + (k<<20));     \/* add k to y's exponent *\/\n+                }\n+            }\n+            return y;\n+        }\n+    }\n","filename":"test\/jdk\/java\/lang\/StrictMath\/FdlibmTranslit.java","additions":197,"deletions":0,"binary":false,"changes":197,"status":"modified"}]}