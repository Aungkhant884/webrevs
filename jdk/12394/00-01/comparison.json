{"files":[{"patch":"@@ -1091,1 +1091,1 @@\n-        \/* scaled coefficients related to expm1 *\/\n+        \/\/ scaled coefficients related to expm1\n@@ -1103,2 +1103,2 @@\n-            hx  = __HI(x);  \/* high word of x *\/\n-            xsb = hx & 0x8000_0000;            \/* sign bit of x *\/\n+            hx  = __HI(x);  \/\/ high word of x\n+            xsb = hx & 0x8000_0000;          \/\/ sign bit of x\n@@ -1106,1 +1106,1 @@\n-            hx &= 0x7fff_ffff;               \/* high word of |x| *\/\n+            hx &= 0x7fff_ffff;               \/\/ high word of |x|\n@@ -1108,3 +1108,3 @@\n-            \/* filter out huge and non-finite argument *\/\n-            if (hx >= 0x4043_687A) {                  \/* if |x| >= 56*ln2 *\/\n-                if (hx >= 0x4086_2E42) {              \/* if |x| >= 709.78... *\/\n+            \/\/ filter out huge and non-finite argument\n+            if (hx >= 0x4043_687A) {                  \/\/ if |x| >= 56*ln2\n+                if (hx >= 0x4086_2E42) {              \/\/ if |x| >= 709.78...\n@@ -1113,1 +1113,1 @@\n-                            return x + x;     \/* NaN *\/\n+                            return x + x;     \/\/ NaN\n@@ -1115,1 +1115,1 @@\n-                            return (xsb == 0)? x : -1.0; \/* exp(+-inf)={inf,-1} *\/\n+                            return (xsb == 0)? x : -1.0; \/\/ exp(+-inf)={inf,-1}\n@@ -1119,1 +1119,1 @@\n-                        return huge*huge; \/* overflow *\/\n+                        return huge*huge; \/\/ overflow\n@@ -1122,3 +1122,3 @@\n-                if (xsb != 0) { \/* x < -56*ln2, return -1.0 with inexact *\/\n-                    if (x + tiny < 0.0) {         \/* raise inexact *\/\n-                        return tiny - one;        \/* return -1 *\/\n+                if (xsb != 0) { \/\/ x < -56*ln2, return -1.0 with inexact\n+                    if (x + tiny < 0.0) {         \/\/ raise inexact\n+                        return tiny - one;        \/\/ return -1\n@@ -1129,3 +1129,3 @@\n-            \/* argument reduction *\/\n-            if (hx > 0x3fd6_2e42) {           \/* if  |x| > 0.5 ln2 *\/\n-                if (hx < 0x3FF0_A2B2) {       \/* and |x| < 1.5 ln2 *\/\n+            \/\/ argument reduction\n+            if (hx > 0x3fd6_2e42) {         \/\/ if  |x| > 0.5 ln2\n+                if (hx < 0x3FF0_A2B2) {     \/\/ and |x| < 1.5 ln2\n@@ -1134,3 +1134,3 @@\n-                        lo =  ln2_lo;\n-                        k =  1;}\n-                    else {\n+                        lo = ln2_lo;\n+                        k =  1;\n+                    } else {\n@@ -1144,1 +1144,1 @@\n-                    hi = x - t*ln2_hi;      \/* t*ln2_hi is exact here *\/\n+                    hi = x - t*ln2_hi;      \/\/ t*ln2_hi is exact here\n@@ -1149,2 +1149,2 @@\n-            } else if (hx < 0x3c90_0000) {      \/* when |x|<2**-54, return x *\/\n-                t = huge + x; \/* return x with inexact flags when x != 0 *\/\n+            } else if (hx < 0x3c90_0000) {  \/\/ when |x| < 2**-54, return x\n+                t = huge + x; \/\/ return x with inexact flags when x != 0\n@@ -1156,1 +1156,1 @@\n-            \/* x is now in primary range *\/\n+            \/\/ x is now in primary range\n@@ -1163,1 +1163,1 @@\n-                return x - (x*e - hxs);          \/* c is 0 *\/\n+                return x - (x*e - hxs);          \/\/ c is 0\n@@ -1171,1 +1171,1 @@\n-                    if(x < -0.25) {\n+                    if (x < -0.25) {\n@@ -1174,1 +1174,1 @@\n-                        return  one + 2.0*(x - e);\n+                        return one + 2.0*(x - e);\n@@ -1177,1 +1177,1 @@\n-                if (k <= -2 || k > 56) {   \/* suffice to return exp(x) - 1 *\/\n+                if (k <= -2 || k > 56) {   \/\/ suffice to return exp(x) - 1\n@@ -1179,1 +1179,1 @@\n-                    y = __HI(y, __HI(y) + (k << 20));     \/* add k to y's exponent *\/\n+                    y = __HI(y, __HI(y) + (k << 20));     \/\/ add k to y's exponent\n@@ -1184,1 +1184,1 @@\n-                    t = __HI(t, 0x3ff0_0000 - (0x2_00000 >> k));  \/* t=1-2^-k *\/\n+                    t = __HI(t, 0x3ff0_0000 - (0x2_00000 >> k));  \/\/ t = 1-2^-k\n@@ -1186,1 +1186,1 @@\n-                    y = __HI(y, __HI(y) + (k << 20));     \/* add k to y's exponent *\/\n+                    y = __HI(y, __HI(y) + (k << 20));     \/\/ add k to y's exponent\n@@ -1188,1 +1188,1 @@\n-                    t = __HI(t, ((0x3ff - k) << 20));     \/* 2^-k *\/\n+                    t = __HI(t, ((0x3ff - k) << 20));     \/\/ 2^-k\n@@ -1191,1 +1191,1 @@\n-                    y = __HI(y, __HI(y) + (k << 20));     \/* add k to y's exponent *\/\n+                    y = __HI(y, __HI(y) + (k << 20));     \/\/ add k to y's exponent\n","filename":"src\/java.base\/share\/classes\/java\/lang\/FdLibm.java","additions":32,"deletions":32,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -80,2 +80,2 @@\n-         x =  Math.nextDown(Double.MIN_NORMAL);\n-         failures += testRange(x, -Math.ulp(x), 1000);\n+        x = Math.nextDown(Double.MIN_NORMAL);\n+        failures += testRange(x, -Math.ulp(x), 1000);\n@@ -84,31 +84,31 @@\n-         failures += testRangeMidpoint(1.0, Math.ulp(x), 2000);\n-         \/\/ (Note: probes every-other value less than 1.0 due to\n-         \/\/ change in the size of an ulp at 1.0.\n-\n-         \/\/ Probe near decision points in the FDLIBM algorithm.\n-         double LN2 = StrictMath.log(2.0);\n-         double[] decisionPoints = {\n-               7.09782712893383973096e+02, \/\/ overflow threshold\n-               56.0 * LN2,\n-              -56.0 * LN2,\n-               0.5 * LN2,\n-              -0.5 * LN2,\n-               1.5 * LN2,\n-              -1.5 * LN2,\n-               0x1.0p-54,\n-              -0x1.0p-54,\n-         };\n-\n-         for (double testPoint : decisionPoints) {\n-             failures += testRangeMidpoint(testPoint, Math.ulp(testPoint), 1000);\n-         }\n-\n-         x = Tests.createRandomDouble(random);\n-\n-         \/\/ Make the increment twice the ulp value in case the random\n-         \/\/ value is near an exponent threshold. Don't worry about test\n-         \/\/ elements overflowing to infinity if the starting value is\n-         \/\/ near Double.MAX_VALUE.\n-         failures += testRange(x, 2.0 * Math.ulp(x), 1000);\n-\n-         return failures;\n+        failures += testRangeMidpoint(1.0, Math.ulp(x), 2000);\n+        \/\/ (Note: probes every-other value less than 1.0 due to\n+        \/\/ change in the size of an ulp at 1.0.\n+\n+        \/\/ Probe near decision points in the FDLIBM algorithm.\n+        double LN2 = StrictMath.log(2.0);\n+        double[] decisionPoints = {\n+             7.09782712893383973096e+02, \/\/ overflow threshold\n+             56.0 * LN2,\n+            -56.0 * LN2,\n+             0.5 * LN2,\n+            -0.5 * LN2,\n+             1.5 * LN2,\n+            -1.5 * LN2,\n+             0x1.0p-54,\n+            -0x1.0p-54,\n+        };\n+\n+        for (double testPoint : decisionPoints) {\n+            failures += testRangeMidpoint(testPoint, Math.ulp(testPoint), 1000);\n+        }\n+\n+        x = Tests.createRandomDouble(random);\n+\n+        \/\/ Make the increment twice the ulp value in case the random\n+        \/\/ value is near an exponent threshold. Don't worry about test\n+        \/\/ elements overflowing to infinity if the starting value is\n+        \/\/ near Double.MAX_VALUE.\n+        failures += testRange(x, 2.0 * Math.ulp(x), 1000);\n+\n+        return failures;\n","filename":"test\/jdk\/java\/lang\/StrictMath\/Expm1Tests.java","additions":33,"deletions":33,"binary":false,"changes":66,"status":"modified"}]}