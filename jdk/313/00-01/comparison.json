{"files":[{"patch":"@@ -50,0 +50,1 @@\n+import java.util.function.BooleanSupplier;\n@@ -58,0 +59,1 @@\n+import jdk.internal.vm.annotation.Stable;\n@@ -1157,0 +1159,2 @@\n+    private static final Object[] EMPTY_ARGS = new Object[0];\n+\n@@ -1244,2 +1248,7 @@\n-     *         <li>any of the given {@code args} does not match the parameter type of\n-     *             the default method to be invoked<\/li>\n+     *         <li>if length of given {@code args} array doesn't match the number of\n+     *             parameters of the method to be invoked or if {@code args} is null\n+     *             and the method to be invoked has parameters<\/li>\n+     *         <li>if any of the {@code args} elements can't be assigned to the\n+     *             boxed type of the corresponding method parameter or any of the\n+     *             {@code args} elements is null while the corresponding method\n+     *             parameter is of primitive type<\/li>\n@@ -1250,2 +1259,2 @@\n-     * @throws NullPointerException if {@code proxy} or {@code method} is\n-     *         {@code null}\n+     * @throws NullPointerException if {@code proxy} or {@code method} is {@code null}\n+     *\n@@ -1259,0 +1268,4 @@\n+        if (args == null) {\n+            \/\/ consistency with Method::invoke: null args array is equivalent to empty array\n+            args = EMPTY_ARGS;\n+        }\n@@ -1273,9 +1286,3 @@\n-        MethodType type = methodType(method.getReturnType(), method.getParameterTypes());\n-        if (superMH != null) {\n-            try {\n-                \/\/ make sure that the method type matches\n-                superMH.asType(type.insertParameterTypes(0, proxyClass));\n-            } catch (WrongMethodTypeException e) {\n-                throw new IllegalArgumentException(e.getMessage(), e);\n-            }\n-        } else {\n+        if (superMH == null) {\n+            MethodType type = methodType(method.getReturnType(), method.getParameterTypes());\n+            MethodHandles.Lookup lookup = MethodHandles.lookup();\n@@ -1283,0 +1290,1 @@\n+            MethodHandle mh0;\n@@ -1284,4 +1292,4 @@\n-                superMH = ((Proxy) proxy).proxyClassLookup(MethodHandles.lookup())\n-                                         .findSpecial(proxyInterface, method.getName(), type, proxyClass)\n-                                         .withVarargs(false);\n-            } catch (IllegalAccessException|NoSuchMethodException e) {\n+                mh0 = ((Proxy) proxy).proxyClassLookup(lookup)\n+                                     .findSpecial(proxyInterface, method.getName(), type, proxyClass)\n+                                     .withVarargs(false);\n+            } catch (IllegalAccessException | NoSuchMethodException e) {\n@@ -1291,0 +1299,21 @@\n+            \/\/ this check can be turned into assertion as it is guaranteed to succeed by the virtue of\n+            \/\/ looking up a default (instance) method declared or inherited by proxyInterface\n+            \/\/ while proxyClass implements (is a subtype of) proxyInterface ...\n+            assert ((BooleanSupplier) () -> {\n+                try {\n+                    \/\/ make sure that the method type matches\n+                    mh0.asType(type.insertParameterTypes(0, proxyClass));\n+                    return true;\n+                } catch (WrongMethodTypeException e) {\n+                    return false;\n+                }\n+            }).getAsBoolean() : \"Wrong method type\";\n+            \/\/ change return type to Object\n+            MethodHandle mh = mh0.asType(mh0.type().changeReturnType(Object.class));\n+            \/\/ wrap any exception thrown with InvocationTargetException\n+            mh = MethodHandles.catchException(mh, Throwable.class, wrapWithInvocationTargetExceptionMH());\n+            \/\/ spread array of arguments among parameters (skipping 1st parameter - target)\n+            mh = mh.asSpreader(1, Object[].class, type.parameterCount());\n+            \/\/ change target type to Object\n+            mh = mh.asType(MethodType.methodType(Object.class, Object.class, Object[].class));\n+\n@@ -1292,1 +1321,1 @@\n-            MethodHandle cached = methods.putIfAbsent(method, superMH);\n+            MethodHandle cached = methods.putIfAbsent(method, mh);\n@@ -1295,16 +1324,0 @@\n-            }\n-        }\n-\n-        \/\/ validate the arguments if they match the method type\n-        int numArgs = args != null ? args.length : 0;\n-        if (numArgs != type.parameterCount()) {\n-            throw new IllegalArgumentException(\"args not matching the formal parameter types: \" + type);\n-        }\n-        try {\n-            if (numArgs > 0) {\n-                Class<?>[] paramTypes = new Class<?>[numArgs];\n-                for (int i = 0; i < numArgs; i++) {\n-                    Object o = args[i];\n-                    paramTypes[i] = o != null ? o.getClass() : type.parameterType(i);\n-                }\n-                superMH.asType(methodType(type.returnType(), proxyClass, paramTypes));\n@@ -1312,1 +1325,1 @@\n-                superMH.asType(methodType(type.returnType(), proxyClass));\n+                superMH = mh;\n@@ -1314,2 +1327,0 @@\n-        } catch (WrongMethodTypeException e) {\n-            throw new IllegalArgumentException(e);\n@@ -1320,4 +1331,8 @@\n-            return superMH.asSpreader(1, Object[].class, type.parameterCount())\n-                          .invoke(proxy, args);\n-        } catch (Throwable t) {\n-            throw new InvocationTargetException(t);\n+            return superMH.invokeExact(proxy, args);\n+        } catch (ClassCastException | NullPointerException e) {\n+            throw new IllegalArgumentException(e.getMessage(), e);\n+        } catch (InvocationTargetException | RuntimeException | Error e) {\n+            throw e;\n+        } catch (Throwable e) {\n+            \/\/ should not reach here\n+            throw new InternalError(e);\n@@ -1327,1 +1342,1 @@\n-    \/*\n+    \/**\n@@ -1413,0 +1428,28 @@\n+\n+    \/**\n+     * Wraps given cause with InvocationTargetException and throws it.\n+     *\n+     * @throws InvocationTargetException wrapping given cause\n+     *\/\n+    private static Object wrapWithInvocationTargetException(Throwable cause) throws InvocationTargetException {\n+        throw new InvocationTargetException(cause, cause.toString());\n+    }\n+\n+    @Stable\n+    private static MethodHandle wrapWithInvocationTargetExceptionMH;\n+\n+    private static MethodHandle wrapWithInvocationTargetExceptionMH() {\n+        MethodHandle mh = wrapWithInvocationTargetExceptionMH;\n+        if (mh == null) {\n+            try {\n+                wrapWithInvocationTargetExceptionMH = mh = MethodHandles.lookup().findStatic(\n+                    Proxy.class,\n+                    \"wrapWithInvocationTargetException\",\n+                    MethodType.methodType(Object.class, Throwable.class)\n+                );\n+            } catch (NoSuchMethodException | IllegalAccessException e) {\n+                throw new InternalError(e);\n+            }\n+        }\n+        return mh;\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Proxy.java","additions":85,"deletions":42,"binary":false,"changes":127,"status":"modified"},{"patch":"@@ -24,0 +24,1 @@\n+import java.io.IOException;\n@@ -25,0 +26,1 @@\n+import java.lang.reflect.InvocationTargetException;\n@@ -90,0 +92,6 @@\n+    public interface IX {\n+        default void doThrow(Throwable exception) throws Throwable {\n+            throw exception;\n+        }\n+    }\n+\n@@ -116,9 +124,9 @@\n-        return new Object[][] {\n-                new Object[] { new Class<?>[] { I1.class, I2.class },  true, 10 },\n-                new Object[] { new Class<?>[] { I1.class, I3.class },  true, 10 },\n-                new Object[] { new Class<?>[] { I1.class, I12.class }, true, 10 },\n-                new Object[] { new Class<?>[] { I2.class, I12.class }, true, 20 },\n-                new Object[] { new Class<?>[] { I4.class },            true, 40 },\n-                new Object[] { new Class<?>[] { I4.class, I3.class },  true, 40 },\n-                new Object[] { new Class<?>[] { I12.class },                     false, -1 },\n-                new Object[] { new Class<?>[] { I12.class, I1.class, I2.class }, false, -1 },\n+        return new Object[][]{\n+            new Object[]{new Class<?>[]{I1.class, I2.class}, true, 10},\n+            new Object[]{new Class<?>[]{I1.class, I3.class}, true, 10},\n+            new Object[]{new Class<?>[]{I1.class, I12.class}, true, 10},\n+            new Object[]{new Class<?>[]{I2.class, I12.class}, true, 20},\n+            new Object[]{new Class<?>[]{I4.class}, true, 40},\n+            new Object[]{new Class<?>[]{I4.class, I3.class}, true, 40},\n+            new Object[]{new Class<?>[]{I12.class}, false, -1},\n+            new Object[]{new Class<?>[]{I12.class, I1.class, I2.class}, false, -1}\n@@ -158,22 +166,22 @@\n-        return new Object[][] {\n-                \/\/ invoke \"m\" implemented in the first proxy interface\n-                \/\/ same as the method passed to InvocationHandler::invoke\n-                new Object[]{new Class<?>[]{ I1.class }, I1.class, 10},\n-                new Object[]{new Class<?>[]{ I2.class }, I2.class, 20},\n-                new Object[]{new Class<?>[]{ I1.class, I2.class }, I1.class, 10},\n-                \/\/ \"m\" is implemented in I2, an indirect superinterface of I3\n-                new Object[]{new Class<?>[]{ I3.class }, I3.class, 20},\n-                \/\/ \"m\" is implemented in I1, I2 and overridden in I4\n-                new Object[]{new Class<?>[]{ I4.class }, I4.class, 40},\n-                \/\/ invoke \"m\" implemented in the second proxy interface\n-                \/\/ different from the method passed to InvocationHandler::invoke\n-                new Object[]{new Class<?>[]{ I1.class, I2.class }, I2.class, 20},\n-                new Object[]{new Class<?>[]{ I1.class, I3.class }, I3.class, 20},\n-                \/\/ I2::m is implemented in more than one proxy interface directly or indirectly\n-                \/\/ I3::m resolves to I2::m (indirect superinterface)\n-                \/\/ I2 is the superinterface of I4 and I4 overrides m\n-                \/\/ the proxy class can invoke I4::m and I2::m\n-                new Object[]{new Class<?>[]{ I3.class, I4.class }, I3.class, 20},\n-                new Object[]{new Class<?>[]{ I3.class, I4.class }, I4.class, 40},\n-                new Object[]{new Class<?>[]{ I4.class, I3.class }, I3.class, 20},\n-                new Object[]{new Class<?>[]{ I4.class, I3.class }, I4.class, 40},\n+        return new Object[][]{\n+            \/\/ invoke \"m\" implemented in the first proxy interface\n+            \/\/ same as the method passed to InvocationHandler::invoke\n+            new Object[]{new Class<?>[]{I1.class}, I1.class, 10},\n+            new Object[]{new Class<?>[]{I2.class}, I2.class, 20},\n+            new Object[]{new Class<?>[]{I1.class, I2.class}, I1.class, 10},\n+            \/\/ \"m\" is implemented in I2, an indirect superinterface of I3\n+            new Object[]{new Class<?>[]{I3.class}, I3.class, 20},\n+            \/\/ \"m\" is implemented in I1, I2 and overridden in I4\n+            new Object[]{new Class<?>[]{I4.class}, I4.class, 40},\n+            \/\/ invoke \"m\" implemented in the second proxy interface\n+            \/\/ different from the method passed to InvocationHandler::invoke\n+            new Object[]{new Class<?>[]{I1.class, I2.class}, I2.class, 20},\n+            new Object[]{new Class<?>[]{I1.class, I3.class}, I3.class, 20},\n+            \/\/ I2::m is implemented in more than one proxy interface directly or indirectly\n+            \/\/ I3::m resolves to I2::m (indirect superinterface)\n+            \/\/ I2 is the superinterface of I4 and I4 overrides m\n+            \/\/ the proxy class can invoke I4::m and I2::m\n+            new Object[]{new Class<?>[]{I3.class, I4.class}, I3.class, 20},\n+            new Object[]{new Class<?>[]{I3.class, I4.class}, I4.class, 40},\n+            new Object[]{new Class<?>[]{I4.class, I3.class}, I3.class, 20},\n+            new Object[]{new Class<?>[]{I4.class, I3.class}, I4.class, 40}\n@@ -294,13 +302,13 @@\n-        return new Object[][] {\n-                \/\/ I4::m overrides I1::m and I2::m\n-                new Object[] { new Class<?>[]{ I4.class },  I1.class, \"m\"},\n-                new Object[] { new Class<?>[]{ I4.class },  I2.class, \"m\"},\n-                \/\/ I12::m is not a default method\n-                new Object[] { new Class<?>[]{ I12.class }, I12.class, \"m\"},\n-                \/\/ non-proxy default method\n-                new Object[] { new Class<?>[]{ I3.class },  I1.class, \"m\"},\n-                \/\/ not a default method and not a proxy interface\n-                new Object[] { new Class<?>[]{ I12.class }, DefaultMethods.class, \"test\"},\n-                new Object[] { new Class<?>[]{ I12.class }, Runnable.class, \"run\"},\n-                \/\/ I2::privateMethod is a private method\n-                new Object[] { new Class<?>[]{ I3.class }, I2.class, \"privateMethod\"},\n+        return new Object[][]{\n+            \/\/ I4::m overrides I1::m and I2::m\n+            new Object[]{new Class<?>[]{I4.class}, I1.class, \"m\"},\n+            new Object[]{new Class<?>[]{I4.class}, I2.class, \"m\"},\n+            \/\/ I12::m is not a default method\n+            new Object[]{new Class<?>[]{I12.class}, I12.class, \"m\"},\n+            \/\/ non-proxy default method\n+            new Object[]{new Class<?>[]{I3.class}, I1.class, \"m\"},\n+            \/\/ not a default method and not a proxy interface\n+            new Object[]{new Class<?>[]{I12.class}, DefaultMethods.class, \"test\"},\n+            new Object[]{new Class<?>[]{I12.class}, Runnable.class, \"run\"},\n+            \/\/ I2::privateMethod is a private method\n+            new Object[]{new Class<?>[]{I3.class}, I2.class, \"privateMethod\"}\n@@ -311,1 +319,1 @@\n-    public void testIllegalArgument(Class<?>[] interfaces, Class<?> defc, String name)\n+    public void testNegativeCase(Class<?>[] interfaces, Class<?> defc, String name)\n@@ -325,2 +333,2 @@\n-    @DataProvider(name = \"arguments\")\n-    private Object[][] arguments() {\n+    @DataProvider(name = \"illegalArguments\")\n+    private Object[][] illegalArguments() {\n@@ -328,3 +336,6 @@\n-                new Object[] {},\n-                new Object[] { 100, \"foo\", 100 },\n-                new Object[] { \"foo\", 100},\n+            new Object[] {},\n+            new Object[] { 100 },\n+            new Object[] { 100, \"foo\", 100 },\n+            new Object[] { 100L, \"foo\" },\n+            new Object[] { \"foo\", 100},\n+            new Object[] { null, \"foo\" }\n@@ -334,2 +345,2 @@\n-    @Test(dataProvider = \"arguments\", expectedExceptions = {IllegalArgumentException.class})\n-    public void testWrongArguments(Object... args) throws Exception {\n+    @Test(dataProvider = \"illegalArguments\", expectedExceptions = {IllegalArgumentException.class})\n+    public void testIllegalArgument(Object... args) throws Exception {\n@@ -340,0 +351,4 @@\n+        if (args.length == 0) {\n+            \/\/ substitute empty args with null since @DataProvider doesn't allow null array\n+            args = null;\n+        }\n@@ -343,2 +358,14 @@\n-    @Test(expectedExceptions = {IllegalArgumentException.class})\n-    public void testNullArguments() throws Exception {\n+    @DataProvider(name = \"invocationTargetExceptions\")\n+    private Object[][] invocationTargetExceptions() {\n+        return new Object[][] {\n+            new Object[] { new IOException() },\n+            new Object[] { new IllegalArgumentException() },\n+            new Object[] { new ClassCastException() },\n+            new Object[] { new NullPointerException() },\n+            new Object[] { new AssertionError() },\n+            new Object[] { new Throwable() }\n+        };\n+    }\n+\n+    @Test(dataProvider = \"invocationTargetExceptions\")\n+    public void testInvocationTargetException(Throwable exception) throws Exception {\n@@ -346,4 +373,7 @@\n-        I4 proxy = (I4)Proxy.newProxyInstance(loader, new Class<?>[]{I4.class}, HANDLER);\n-        Method m = I4.class.getMethod(\"mix\", int.class, String.class);\n-        assertTrue(m.isDefault());\n-        Proxy.invokeDefaultMethod(proxy, m, (Object[])null);\n+        IX proxy = (IX)Proxy.newProxyInstance(loader, new Class<?>[]{IX.class}, HANDLER);\n+        Method m = IX.class.getMethod(\"doThrow\", Throwable.class);\n+        try {\n+            Proxy.invokeDefaultMethod(proxy, m, exception);\n+        } catch (InvocationTargetException e) {\n+            assertEquals(e.getCause(), exception);\n+        }\n","filename":"test\/jdk\/java\/lang\/reflect\/Proxy\/DefaultMethods.java","additions":88,"deletions":58,"binary":false,"changes":146,"status":"modified"}]}