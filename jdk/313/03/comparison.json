{"files":[{"patch":"@@ -2224,0 +2224,3 @@\n+            public void addExports(Module m, String pn) {\n+                m.implAddExports(pn);\n+            }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2006, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,13 @@\n+import jdk.internal.reflect.CallerSensitive;\n+import jdk.internal.reflect.Reflection;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.lang.invoke.WrongMethodTypeException;\n+import java.util.Objects;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.BooleanSupplier;\n+\n+import static java.lang.invoke.MethodType.methodType;\n+\n@@ -95,0 +108,224 @@\n+\n+    \/**\n+     * Invokes the specified default method on the given {@code proxy} instance with\n+     * the given parameters.  The given {@code method} must be a default method\n+     * declared in a proxy interface of the {@code proxy}'s class or inherited\n+     * from its superinterface directly or indirectly.\n+     * <p>\n+     * This method behaves as if called from an {@code invokespecial} instruction\n+     * from the proxy class as the caller equivalent to the invocation of\n+     * {@code X.super.m(A* a)} where {@code X} is a proxy interface and\n+     * the call to {@code X.super::m(A*)} is resolved to the given {@code method}.\n+     * <p>\n+     * For example, interface {@code A} and {@code B} both declare a default\n+     * implementation of method {@code m}. Interface {@code C} extends {@code A}\n+     * and it inherits the default method {@code m} from its superinterface {@code A}.\n+     *\n+     * <blockquote><pre>{@code\n+     * interface A {\n+     *     default T m(A a) { return t1; }\n+     * }\n+     * interface B {\n+     *     default T m(A a) { return t2; }\n+     * }\n+     * interface C extends A {}\n+     * }<\/pre><\/blockquote>\n+     *\n+     * The following creates a proxy instance that implements {@code A}\n+     * and invokes the default method {@code A::m}.\n+     *\n+     * <blockquote><pre>{@code\n+     * Object proxy = Proxy.newProxyInstance(loader, new Class<?>[] { A.class },\n+     *         (o, m, params) -> {\n+     *             assert m.getDeclaringClass() == A.class && m.isDefault();\n+     *             return InvocationHandler.invokeDefaultMethod(o, m, params);\n+     *         });\n+     * }<\/pre><\/blockquote>\n+     *\n+     * If a proxy instance implements both {@code A} and {@code B}, both\n+     * of which provides the default implementation of method {@code m},\n+     * the invocation handler can dispatch the method invocation to\n+     * {@code A::m} or {@code B::m} via the {@code invokeDefaultMethod} method.\n+     * For example, the following code delegates the method invocation\n+     * to {@code B::m}.\n+     *\n+     * <blockquote><pre>{@code\n+     * Object proxy = Proxy.newProxyInstance(loader, new Class<?>[] { A.class, B.class },\n+     *         (o, m, params) -> {\n+     *             \/\/ delegate to invoking B::m\n+     *             Method selectedMethod = B.class.getMethod(m.getName(), m.getParameterTypes());\n+     *             return InvocationHandler.invokeDefaultMethod(o, selectedMethod, params);\n+     *         });\n+     * }<\/pre><\/blockquote>\n+     *\n+     * If a proxy instance implements {@code C} that inherits the default\n+     * method {@code m} from its superinterface {@code A}, then\n+     * the interface method invocation on {@code \"m\"} is dispatched to\n+     * the invocation handler's {@link #invoke(Object, Method, Object[]) invoke}\n+     * method with the {@code Method} object argument representing the\n+     * default method {@code A::m}.\n+     *\n+     * <blockquote><pre>{@code\n+     * Object c = Proxy.newProxyInstance(loader, new Class<?>[] { C.class },\n+     *        (o, m, params) -> {\n+     *             assert m.isDefault();\n+     *             return InvocationHandler.invokeDefaultMethod(o, m, params);\n+     *        });\n+     * }<\/pre><\/blockquote>\n+     *\n+     * The invocation of method {@code \"m\"} on {@code c} will behave as if\n+     * {@code C.super::m} is called and that is resolved to invoking\n+     * {@code A::m}.\n+     * <p>\n+     * If {@code C} is modified to override {@code m} as below:\n+     *\n+     * <blockquote><pre>{@code\n+     * interface C extends A {\n+     *     default T m(A a) { return t3; }\n+     * }\n+     * }<\/pre><\/blockquote>\n+     *\n+     * {@code C.super::m} will be resolved to {@code C::m} instead.\n+     * The invocation of method {@code \"m\"} on {@code c} will behave\n+     * differently and result in invoking {@code C::m} instead of {@code A::m}.\n+     * <p>\n+     * If an invocation handler dispatches the method invocation by calling\n+     * the {@code invokeDefaultMethod} method with the {@code Method} object\n+     * representing {@code A::m}:\n+     *\n+     * <blockquote><pre>{@code\n+     * Object proxy = Proxy.newProxyInstance(loader, new Class<?>[] { C.class },\n+     *         (o, m, params) -> {\n+     *             \/\/ IllegalArgumentException thrown as {@code A::m} is not a method\n+     *             \/\/ inherited from its proxy interface C\n+     *             return InvocationHandler.invokeDefaultMethod(o, A.class.getMethod(\"m\"), params);\n+     *         });\n+     * }<\/pre><\/blockquote>\n+     *\n+     * The invocation on {@code \"m\"} with this proxy instance will result in\n+     * an {@code IllegalArgumentException} because {@code C} overrides the implementation\n+     * of the same method and {@code A::m} is not accessible by a proxy instance.\n+     *\n+     * @param proxy   the {@code Proxy} instance on which the default method to be invoked\n+     * @param method  the {@code Method} instance corresponding to a default method\n+     *                declared in a proxy interface of the proxy class or inherited\n+     *                from its superinterface directly or indirectly\n+     * @param args    the parameters used for the method invocation; can be {@code null}\n+     *                if the number of formal parameters required by the method is zero.\n+     * @return the value returned from the method invocation\n+     *\n+     * @throws IllegalArgumentException if any of the following conditions is {@code true}:\n+     *         <ul>\n+     *         <li>{@code proxy} is not {@linkplain Proxy#isProxyClass(Class)\n+     *             a proxy instance}; or<\/li>\n+     *         <li>the given {@code method} is not a default method declared\n+     *             in a proxy interface of the proxy class and not inherited from\n+     *             any of its superinterfaces; or<\/li>\n+     *         <li>the given {@code method} is overridden directly or indirectly by\n+     *             the proxy interfaces and the method reference to the named\n+     *             method never resolves to the given {@code method}; or<\/li>\n+     *         <li>the length of the given {@code args} array does not match the\n+     *             number of parameters of the method to be invoked; or<\/li>\n+     *         <li>any of the {@code args} elements fails the unboxing\n+     *             conversion if the corresponding method parameter type is\n+     *             a primitive type; or if, after possible unboxing, any of the\n+     *             {@code args} elements cannot be assigned to the corresponding\n+     *             method parameter type.<\/li>\n+     *         <\/ul>\n+     * @throws IllegalAccessException if the declaring class of the specified\n+     *         default method is inaccessible to the caller class\n+     * @throws InvocationTargetException if the invoked default method throws\n+     *         any exception, it is wrapped by {@code InvocationTargetException}\n+     *         and rethrown\n+     * @throws NullPointerException if {@code proxy} or {@code method} is {@code null}\n+     *\n+     * @since 16\n+     * @jvms 5.4.3. Method Resolution\n+     *\/\n+    @CallerSensitive\n+    public static Object invokeDefaultMethod(Object proxy, Method method, Object... args)\n+            throws IllegalAccessException, InvocationTargetException {\n+        Objects.requireNonNull(proxy);\n+        Objects.requireNonNull(method);\n+\n+        \/\/ verify that the object is actually a proxy instance\n+        Class<?> proxyClass = proxy.getClass();\n+        if (!Proxy.isProxyClass(proxyClass)) {\n+            throw new IllegalArgumentException(\"'proxy' is not a proxy instance\");\n+        }\n+        if (!method.isDefault()) {\n+            throw new IllegalArgumentException(\"\\\"\" + method + \"\\\" is not a default method\");\n+        }\n+        Class<?> intf = method.getDeclaringClass();\n+        \/\/ access check if it is a non-public proxy interface or not unconditionally exported\n+        if (!Modifier.isPublic(intf.getModifiers()) ||\n+                !intf.getModule().isExported(intf.getPackageName())) {\n+            \/\/ throw IAE if the caller class has no access to the default method\n+            \/\/ same access check to Method::invoke on the default method\n+            int modifiers = method.getModifiers();\n+            Class<?> caller = Reflection.getCallerClass();\n+            method.checkAccess(caller, intf, proxyClass, modifiers);\n+        }\n+\n+        \/\/ lookup the cached method handle\n+        ConcurrentHashMap<Method, MethodHandle> methods = Proxy.defaultMethodMap(proxyClass);\n+        MethodHandle superMH = methods.get(method);\n+\n+        if (superMH == null) {\n+            MethodType type = methodType(method.getReturnType(), method.getParameterTypes());\n+            MethodHandles.Lookup lookup = MethodHandles.lookup();\n+            Class<?> proxyInterface = Proxy.findProxyInterfaceOrElseThrow(proxyClass, method);\n+            MethodHandle dmh;\n+            try {\n+                dmh = Proxy.proxyClassLookup(lookup, proxyClass)\n+                           .findSpecial(proxyInterface, method.getName(), type, proxyClass)\n+                           .withVarargs(false);\n+            } catch (IllegalAccessException | NoSuchMethodException e) {\n+                \/\/ should not reach here\n+                throw new InternalError(e);\n+            }\n+            \/\/ this check can be turned into assertion as it is guaranteed to succeed by the virtue of\n+            \/\/ looking up a default (instance) method declared or inherited by proxyInterface\n+            \/\/ while proxyClass implements (is a subtype of) proxyInterface ...\n+            assert ((BooleanSupplier) () -> {\n+                try {\n+                    \/\/ make sure that the method type matches\n+                    dmh.asType(type.insertParameterTypes(0, proxyClass));\n+                    return true;\n+                } catch (WrongMethodTypeException e) {\n+                    return false;\n+                }\n+            }).getAsBoolean() : \"Wrong method type\";\n+            \/\/ change return type to Object\n+            MethodHandle mh = dmh.asType(dmh.type().changeReturnType(Object.class));\n+            \/\/ wrap any exception thrown with InvocationTargetException\n+            mh = MethodHandles.catchException(mh, Throwable.class, Proxy.wrapWithInvocationTargetExceptionMH());\n+            \/\/ spread array of arguments among parameters (skipping 1st parameter - target)\n+            mh = mh.asSpreader(1, Object[].class, type.parameterCount());\n+            \/\/ change target type to Object\n+            mh = mh.asType(MethodType.methodType(Object.class, Object.class, Object[].class));\n+\n+            \/\/ push MH into cache\n+            MethodHandle cached = methods.putIfAbsent(method, mh);\n+            if (cached != null) {\n+                superMH = cached;\n+            } else {\n+                superMH = mh;\n+            }\n+        }\n+\n+        \/\/ invoke the super method\n+        try {\n+            \/\/ the args array can be null if the number of formal parameters required by\n+            \/\/ the method is zero (consistent with Method::invoke)\n+            Object[] params = args != null ? args : Proxy.EMPTY_ARGS;\n+            return superMH.invokeExact(proxy, params);\n+        } catch (ClassCastException | NullPointerException e) {\n+            throw new IllegalArgumentException(e.getMessage(), e);\n+        } catch (InvocationTargetException | RuntimeException | Error e) {\n+            throw e;\n+        } catch (Throwable e) {\n+            \/\/ should not reach here\n+            throw new InternalError(e);\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/InvocationHandler.java","additions":238,"deletions":1,"binary":false,"changes":239,"status":"modified"},{"patch":"@@ -28,0 +28,4 @@\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodHandles.Lookup;\n+import java.lang.invoke.MethodType;\n@@ -31,0 +35,1 @@\n+import java.util.ArrayDeque;\n@@ -33,0 +38,1 @@\n+import java.util.Deque;\n@@ -40,0 +46,1 @@\n+import java.util.concurrent.ConcurrentHashMap;\n@@ -45,1 +52,0 @@\n-import jdk.internal.loader.BootLoader;\n@@ -51,0 +57,1 @@\n+import jdk.internal.vm.annotation.Stable;\n@@ -52,1 +59,0 @@\n-import sun.security.action.GetBooleanAction;\n@@ -58,1 +64,0 @@\n-\n@@ -147,0 +152,6 @@\n+ * <li>A proxy interface may define a default method or inherit\n+ * a default method from its superinterface directly or indirectly.\n+ * An invocation handler can invoke a default method of a proxy interface\n+ * by calling {@link InvocationHandler#invokeDefaultMethod(Object, Method, Object...)\n+ * InvocationHandler::invokeDefaultMethod}.\n+ *\n@@ -175,3 +186,2 @@\n- *     <em>public<\/em> in a package exported by the\n- *     {@linkplain ClassLoader#getUnnamedModule() unnamed module} of the specified\n- *     loader. The name of the package is unspecified.<\/li>\n+ *     <em>public<\/em> in an unconditionally exported but non-open package.\n+ *     The name of the package and the module are unspecified.<\/li>\n@@ -488,0 +498,1 @@\n+            boolean nonExported = false;\n@@ -505,0 +516,5 @@\n+                } else {\n+                    if (!intf.getModule().isExported(intf.getPackageName())) {\n+                        \/\/ module-private types\n+                        nonExported = true;\n+                    }\n@@ -509,3 +525,5 @@\n-                \/\/ all proxy interfaces are public\n-                proxyPkg = m.isNamed() ? PROXY_PACKAGE_PREFIX + \".\" + m.getName()\n-                                       : PROXY_PACKAGE_PREFIX;\n+                \/\/ all proxy interfaces are public and exported\n+                if (!m.isNamed())\n+                    throw new InternalError(\"ununamed module: \" + m);\n+                proxyPkg = nonExported ? PROXY_PACKAGE_PREFIX + \".\" + m.getName()\n+                                       : m.getName();\n@@ -649,0 +667,2 @@\n+            assert !module.isNamed() || module.isOpen(proxyClass.getPackageName(), Proxy.class.getModule());\n+\n@@ -745,3 +765,0 @@\n-         * If all proxy interfaces are public and in exported packages,\n-         * then the proxy class is in unnamed module.\n-         *\n@@ -751,0 +768,4 @@\n+         * If all proxy interfaces are public and in exported packages,\n+         * then the proxy class is in a dynamic module in an unconditionally\n+         * exported package.\n+         *\n@@ -753,2 +774,5 @@\n-         * non-exported package.  Reads edge and qualified exports are added\n-         * for dynamic module to access.\n+         * non-exported package.\n+         *\n+         * The package of proxy class is open to java.base for deep reflective access.\n+         *\n+         * Reads edge and qualified exports are added for dynamic module to access.\n@@ -759,1 +783,0 @@\n-            Map<Class<?>, Module> modulePrivateTypes = new HashMap<>();\n@@ -763,6 +786,1 @@\n-                if (Modifier.isPublic(intf.getModifiers())) {\n-                    \/\/ module-private types\n-                    if (!m.isExported(intf.getPackageName())) {\n-                        modulePrivateTypes.put(intf, m);\n-                    }\n-                } else {\n+                if (!Modifier.isPublic(intf.getModifiers())) {\n@@ -773,8 +791,0 @@\n-            \/\/ all proxy interfaces are public and exported, the proxy class\n-            \/\/ is in unnamed module.  Such proxy class is accessible to\n-            \/\/ any unnamed module and named module that can read unnamed module\n-            if (packagePrivateTypes.isEmpty() && modulePrivateTypes.isEmpty()) {\n-                return loader != null ? loader.getUnnamedModule()\n-                                      : BootLoader.getUnnamedModule();\n-            }\n-\n@@ -787,12 +797,10 @@\n-                if (packagePrivateTypes.size() > 1 &&\n-                        (packagePrivateTypes.keySet().stream()  \/\/ more than one package\n-                                 .map(Class::getPackageName).distinct().count() > 1 ||\n-                         packagePrivateTypes.values().stream()  \/\/ or more than one module\n-                                 .distinct().count() > 1)) {\n-                    throw new IllegalArgumentException(\n-                            \"non-public interfaces from different packages\");\n-                }\n-\n-                \/\/ all package-private types are in the same module (named or unnamed)\n-                Module target = null;\n-                for (Module m : packagePrivateTypes.values()) {\n+                Module targetModule = null;\n+                String targetPackageName = null;\n+                for (Map.Entry<Class<?>, Module> e : packagePrivateTypes.entrySet()) {\n+                    Class<?> intf = e.getKey();\n+                    Module m = e.getValue();\n+                    if ((targetModule != null && targetModule != m) ||\n+                        (targetPackageName != null && targetPackageName != intf.getPackageName())) {\n+                        throw new IllegalArgumentException(\n+                                \"cannot have non-public interfaces in different packages\");\n+                    }\n@@ -805,1 +813,3 @@\n-                    target = m;\n+\n+                    targetModule = m;\n+                    targetPackageName = e.getKey().getPackageName();\n@@ -811,1 +821,1 @@\n-                    if (m == target) continue;\n+                    if (m == targetModule) continue;\n@@ -813,2 +823,2 @@\n-                    if (!target.canRead(m) || !m.isExported(intf.getPackageName(), target)) {\n-                        throw new IllegalArgumentException(target + \" can't access \" + intf.getName());\n+                    if (!targetModule.canRead(m) || !m.isExported(intf.getPackageName(), targetModule)) {\n+                        throw new IllegalArgumentException(targetModule + \" can't access \" + intf.getName());\n@@ -818,0 +828,4 @@\n+                \/\/ opens the package of the non-public proxy class for java.base to access\n+                if (targetModule.isNamed()) {\n+                    Modules.addOpens(targetModule, targetPackageName, Proxy.class.getModule());\n+                }\n@@ -819,1 +833,1 @@\n-                return target;\n+                return targetModule;\n@@ -822,4 +836,3 @@\n-            \/\/ All proxy interfaces are public and at least one in a non-exported\n-            \/\/ package.  So maps to a dynamic proxy module and add reads edge\n-            \/\/ and qualified exports, if necessary\n-            Module target = getDynamicModule(loader);\n+            \/\/ All proxy interfaces are public.  So maps to a dynamic proxy module\n+            \/\/ and add reads edge and qualified exports, if necessary\n+            Module targetModule = getDynamicModule(loader);\n@@ -832,1 +845,1 @@\n-                ensureAccess(target, c);\n+                ensureAccess(targetModule, c);\n@@ -834,1 +847,1 @@\n-            return target;\n+            return targetModule;\n@@ -880,2 +893,3 @@\n-         * Define a dynamic module for the generated proxy classes in\n-         * a non-exported package named com.sun.proxy.$MODULE.\n+         * Define a dynamic module with a packge named $MODULE which\n+         * is unconditionally exported and another package named\n+         * com.sun.proxy.$MODULE which is encapsulated.\n@@ -891,3 +905,4 @@\n-                    ModuleDescriptor.newModule(mn, Set.of(SYNTHETIC))\n-                                    .packages(Set.of(pn))\n-                                    .build();\n+                        ModuleDescriptor.newModule(mn, Set.of(SYNTHETIC))\n+                                        .packages(Set.of(pn, mn))\n+                                        .exports(mn)\n+                                        .build();\n@@ -896,2 +911,4 @@\n-                \/\/ java.base to create proxy instance\n-                Modules.addExports(m, pn, Object.class.getModule());\n+                Modules.addExports(m, mn);\n+                \/\/ java.base to create proxy instance and access its Lookup instance\n+                Modules.addOpens(m, pn, Proxy.class.getModule());\n+                Modules.addOpens(m, mn, Proxy.class.getModule());\n@@ -1127,0 +1144,132 @@\n+\n+    \/**\n+     * A cache of Method -> MethodHandle for default methods.\n+     *\/\n+    private static final ClassValue<ConcurrentHashMap<Method, MethodHandle>>\n+            DEFAULT_METHODS_MAP = new ClassValue<>() {\n+        @Override\n+        protected ConcurrentHashMap<Method, MethodHandle> computeValue(Class<?> type) {\n+            return new ConcurrentHashMap<>(4);\n+        }\n+    };\n+\n+    static ConcurrentHashMap<Method, MethodHandle> defaultMethodMap(Class<?> proxyClass) {\n+        assert isProxyClass(proxyClass);\n+        return DEFAULT_METHODS_MAP.get(proxyClass);\n+    }\n+\n+    static final Object[] EMPTY_ARGS = new Object[0];\n+\n+    \/**\n+     * Finds the first proxy interface that declares the given method\n+     * directly or indirectly.\n+     *\n+     * @throws IllegalArgumentException if not found\n+     *\/\n+    static Class<?> findProxyInterfaceOrElseThrow(Class<?> proxyClass, Method method) {\n+        Class<?> declaringClass = method.getDeclaringClass();\n+        if (!declaringClass.isInterface()) {\n+            throw new IllegalArgumentException(\"\\\"\" + method +\n+                    \"\\\" is not a method declared in the proxy class\");\n+        }\n+\n+        List<Class<?>> proxyInterfaces = Arrays.asList(proxyClass.getInterfaces());\n+        \/\/ the method's declaring class is a proxy interface\n+        if (proxyInterfaces.contains(declaringClass))\n+            return declaringClass;\n+\n+        Deque<Class<?>> deque = new ArrayDeque<>();\n+        Set<Class<?>> visited = new HashSet<>();\n+        boolean indirectMethodRef = false;\n+        for (Class<?> intf : proxyInterfaces) {\n+            assert intf != declaringClass;\n+            visited.add(intf);\n+            deque.add(intf);\n+\n+            Class<?> c;\n+            while ((c = deque.poll()) != null) {\n+                if (c == declaringClass) {\n+                    try {\n+                        \/\/ check if this method is the resolved method if referenced from\n+                        \/\/ this proxy interface (i.e. this method is not implemented\n+                        \/\/ by any other superinterface)\n+                        Method m = intf.getMethod(method.getName(), method.getParameterTypes());\n+                        if (m.getDeclaringClass() == declaringClass) {\n+                            return intf;\n+                        }\n+                        indirectMethodRef = true;\n+                    } catch (NoSuchMethodException e) {}\n+\n+                    \/\/ skip traversing its superinterfaces\n+                    \/\/ another proxy interface may extend it and so\n+                    \/\/ the method's declaring class is left unvisited.\n+                    continue;\n+                }\n+                \/\/ visit all superinteraces of one proxy interface to find if\n+                \/\/ this proxy interface inherits the method directly or indirectly\n+                visited.add(c);\n+                for (Class<?> superIntf : c.getInterfaces()) {\n+                    if (!visited.contains(superIntf) && !deque.contains(superIntf)) {\n+                        if (superIntf == declaringClass) {\n+                            deque.addFirst(superIntf);\n+                        } else {\n+                            deque.add(superIntf);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        throw new IllegalArgumentException(\"\\\"\" + method + (indirectMethodRef\n+                ? \"\\\" is overridden directly or indirectly by the proxy interfaces\"\n+                : \"\\\" is not a method declared in the proxy class\"));\n+    }\n+\n+    \/**\n+     * Returns a Lookup object for the lookup class which is the class of this\n+     * proxy instance.\n+     *\n+     * @return a lookup for proxy class of this proxy instance\n+     *\/\n+    static Lookup proxyClassLookup(Lookup caller, Class<?> proxyClass) {\n+        return AccessController.doPrivileged(new PrivilegedAction<>() {\n+            @Override\n+            public Lookup run() {\n+                try {\n+                    Method m = proxyClass.getDeclaredMethod(\"proxyClassLookup\", Lookup.class);\n+                    m.setAccessible(true);\n+                    return (Lookup) m.invoke(null, caller);\n+                } catch (ReflectiveOperationException e) {\n+                    throw new InternalError(e);\n+                }\n+            }\n+        });\n+    }\n+\n+    \/**\n+     * Wraps given cause with InvocationTargetException and throws it.\n+     *\n+     * @throws InvocationTargetException wrapping given cause\n+     *\/\n+    private static Object wrapWithInvocationTargetException(Throwable cause) throws InvocationTargetException {\n+        throw new InvocationTargetException(cause, cause.toString());\n+    }\n+\n+    @Stable\n+    private static MethodHandle wrapWithInvocationTargetExceptionMH;\n+\n+    static MethodHandle wrapWithInvocationTargetExceptionMH() {\n+        MethodHandle mh = wrapWithInvocationTargetExceptionMH;\n+        if (mh == null) {\n+            try {\n+                wrapWithInvocationTargetExceptionMH = mh = MethodHandles.lookup().findStatic(\n+                    Proxy.class,\n+                    \"wrapWithInvocationTargetException\",\n+                    MethodType.methodType(Object.class, Throwable.class)\n+                );\n+            } catch (NoSuchMethodException | IllegalAccessException e) {\n+                throw new InternalError(e);\n+            }\n+        }\n+        return mh;\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Proxy.java","additions":208,"deletions":59,"binary":false,"changes":267,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import jdk.internal.org.objectweb.asm.Type;\n@@ -62,0 +63,2 @@\n+    private static final String JL_ILLEGAL_ACCESS_EX = \"java\/lang\/IllegalAccessException\";\n+\n@@ -65,0 +68,2 @@\n+    private static final String JLI_LOOKUP = \"java\/lang\/invoke\/MethodHandles$Lookup\";\n+    private static final String JLI_METHODHANDLES = \"java\/lang\/invoke\/MethodHandles\";\n@@ -78,0 +83,1 @@\n+    private static final String NAME_LOOKUP_ACCESSOR = \"proxyClassLookup\";\n@@ -496,1 +502,1 @@\n-\n+        generateLookupAccessor();\n@@ -628,0 +634,40 @@\n+    \/**\n+     * Generate the static lookup accessor method that returns the Lookup\n+     * on this proxy class if the caller's lookup class is java.lang.reflect.InvocationHandler;\n+     * otherwise, IllegalAccessException is thrown\n+     *\/\n+    private void generateLookupAccessor() {\n+        MethodVisitor mv = visitMethod(ACC_PRIVATE | ACC_STATIC, NAME_LOOKUP_ACCESSOR,\n+                \"(Ljava\/lang\/invoke\/MethodHandles$Lookup;)Ljava\/lang\/invoke\/MethodHandles$Lookup;\", null,\n+                new String[] { JL_ILLEGAL_ACCESS_EX });\n+        mv.visitCode();\n+        Label L_illegalAccess = new Label();\n+\n+        mv.visitVarInsn(ALOAD, 0);\n+        mv.visitMethodInsn(INVOKEVIRTUAL, JLI_LOOKUP, \"lookupClass\",\n+                \"()Ljava\/lang\/Class;\", false);\n+        mv.visitLdcInsn(Type.getType(InvocationHandler.class));\n+        mv.visitJumpInsn(IF_ACMPNE, L_illegalAccess);\n+        mv.visitVarInsn(ALOAD, 0);\n+        mv.visitMethodInsn(INVOKEVIRTUAL, JLI_LOOKUP, \"hasFullPrivilegeAccess\",\n+                \"()Z\", false);\n+        mv.visitJumpInsn(IFEQ, L_illegalAccess);\n+        mv.visitMethodInsn(INVOKESTATIC, JLI_METHODHANDLES, \"lookup\",\n+                \"()Ljava\/lang\/invoke\/MethodHandles$Lookup;\", false);\n+        mv.visitInsn(ARETURN);\n+\n+        mv.visitLabel(L_illegalAccess);\n+        mv.visitTypeInsn(Opcodes.NEW, JL_ILLEGAL_ACCESS_EX);\n+        mv.visitInsn(DUP);\n+        mv.visitVarInsn(ALOAD, 0);\n+        mv.visitMethodInsn(INVOKEVIRTUAL, JLI_LOOKUP, \"toString\",\n+                \"()Ljava\/lang\/String;\", false);\n+        mv.visitMethodInsn(INVOKESPECIAL, JL_ILLEGAL_ACCESS_EX,\n+                \"<init>\", \"(Ljava\/lang\/String;)V\", false);\n+        mv.visitInsn(ATHROW);\n+\n+        \/\/ Maxs computed by ClassWriter.COMPUTE_FRAMES, these arguments ignored\n+        mv.visitMaxs(-1, -1);\n+        mv.visitEnd();\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/ProxyGenerator.java","additions":47,"deletions":1,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -212,0 +212,5 @@\n+    \/**\n+     * Updates module m1 to export a package unconditionally.\n+     *\/\n+    void addExports(Module m1, String pkg);\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangAccess.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -108,0 +108,7 @@\n+    \/**\n+     * Updates module m to export a package unconditionally.\n+     *\/\n+    public static void addExports(Module m, String pn) {\n+        JLA.addExports(m, pn);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/module\/Modules.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -266,2 +266,1 @@\n-        String pkg = cls.getPackageName();\n-        return pkg == null || !pkg.startsWith(PROXY_PACKAGE);\n+        return !Modifier.isPublic(cls.getModifiers());\n","filename":"src\/java.base\/share\/classes\/sun\/reflect\/misc\/ReflectUtil.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,386 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.IOException;\n+import java.lang.reflect.InvocationHandler;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Proxy;\n+import java.util.Arrays;\n+\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.*;\n+\n+\/**\n+ * @test\n+ * @bug 8159746\n+ * @run testng DefaultMethods\n+ * @summary Basic tests for Proxy::invokeSuper default method\n+ *\/\n+\n+public class DefaultMethods {\n+    public interface I1 {\n+        default int m() {\n+            return 10;\n+        }\n+    }\n+\n+    public interface I2 {\n+        default int m() {\n+            return 20;\n+        }\n+\n+        private void privateMethod() {\n+            throw new Error(\"should not reach here\");\n+        }\n+    }\n+\n+    \/\/ I3::m inherits from I2:m\n+    public interface I3 extends I2 {\n+        default int m3(String... s) {\n+            return Arrays.stream(s).mapToInt(String::length).sum();\n+        }\n+    }\n+\n+    public interface I4 extends I1, I2 {\n+        default int m() {\n+            return 40;\n+        }\n+\n+        default int mix(int a, String b) {\n+            return 0;\n+        }\n+    }\n+\n+    public interface I12 extends I1, I2 {\n+        @Override\n+        int m();\n+\n+        default int sum(int a, int b) {\n+            return a + b;\n+        }\n+\n+        default Object[] concat(Object first, Object... rest) {\n+            Object[] result = new Object[1 + rest.length];\n+            result[0] = first;\n+            System.arraycopy(rest, 0, result, 1, rest.length);\n+            return result;\n+        }\n+    }\n+\n+    public interface IX {\n+        default void doThrow(Throwable exception) throws Throwable {\n+            throw exception;\n+        }\n+    }\n+\n+    private static Method findDefaultMethod(Class<?> refc, Method m) {\n+        try {\n+            assertTrue(refc.isInterface());\n+\n+            Method method = refc.getMethod(m.getName(), m.getParameterTypes());\n+            assertTrue(method.isDefault());\n+            return method;\n+        } catch (NoSuchMethodException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    @Test\n+    public void test() {\n+        ClassLoader loader = DefaultMethods.class.getClassLoader();\n+        Object proxy = Proxy.newProxyInstance(loader, new Class<?>[] { I1.class, I2.class},\n+                (o, method, params) -> {\n+                    return InvocationHandler.invokeDefaultMethod(o, findDefaultMethod(I2.class, method), params);\n+                });\n+        I1 i1 = (I1) proxy;\n+        assertEquals(i1.m(), 20);\n+    }\n+\n+    \/\/ a default method is declared in one of the proxy interfaces\n+    @DataProvider(name = \"defaultMethods\")\n+    private Object[][] defaultMethods() {\n+        return new Object[][]{\n+            new Object[]{new Class<?>[]{I1.class, I2.class}, true, 10},\n+            new Object[]{new Class<?>[]{I1.class, I3.class}, true, 10},\n+            new Object[]{new Class<?>[]{I1.class, I12.class}, true, 10},\n+            new Object[]{new Class<?>[]{I2.class, I12.class}, true, 20},\n+            new Object[]{new Class<?>[]{I4.class}, true, 40},\n+            new Object[]{new Class<?>[]{I4.class, I3.class}, true, 40},\n+            new Object[]{new Class<?>[]{I12.class}, false, -1},\n+            new Object[]{new Class<?>[]{I12.class, I1.class, I2.class}, false, -1}\n+        };\n+    }\n+\n+    @Test(dataProvider = \"defaultMethods\")\n+    public void testDefaultMethod(Class<?>[] intfs, boolean isDefault, int expected) throws Exception {\n+        InvocationHandler ih = (proxy, method, params) -> {\n+            System.out.format(\"invoking %s with parameters: %s%n\", method, Arrays.toString(params));\n+            switch (method.getName()) {\n+                case \"m\":\n+                    assertTrue(method.isDefault() == isDefault);\n+                    assertTrue(Arrays.stream(proxy.getClass().getInterfaces())\n+                                     .anyMatch(intf -> method.getDeclaringClass() == intf),\n+                               Arrays.toString(proxy.getClass().getInterfaces()));\n+                    if (method.isDefault()) {\n+                        return InvocationHandler.invokeDefaultMethod(proxy, method, params);\n+                    } else {\n+                        return -1;\n+                    }\n+                default:\n+                    throw new UnsupportedOperationException(method.toString());\n+            }\n+        };\n+\n+        Object proxy = Proxy.newProxyInstance(DefaultMethods.class.getClassLoader(), intfs, ih);\n+        Method m = proxy.getClass().getMethod(\"m\");\n+        int result = (int)m.invoke(proxy);\n+        assertEquals(result, expected);\n+    }\n+\n+    \/\/ a default method may be declared in a proxy interface or\n+    \/\/ inherited from a superinterface of a proxy interface\n+    @DataProvider(name = \"supers\")\n+    private Object[][] supers() {\n+        return new Object[][]{\n+            \/\/ invoke \"m\" implemented in the first proxy interface\n+            \/\/ same as the method passed to InvocationHandler::invoke\n+            new Object[]{new Class<?>[]{I1.class}, I1.class, 10},\n+            new Object[]{new Class<?>[]{I2.class}, I2.class, 20},\n+            new Object[]{new Class<?>[]{I1.class, I2.class}, I1.class, 10},\n+            \/\/ \"m\" is implemented in I2, an indirect superinterface of I3\n+            new Object[]{new Class<?>[]{I3.class}, I3.class, 20},\n+            \/\/ \"m\" is implemented in I1, I2 and overridden in I4\n+            new Object[]{new Class<?>[]{I4.class}, I4.class, 40},\n+            \/\/ invoke \"m\" implemented in the second proxy interface\n+            \/\/ different from the method passed to InvocationHandler::invoke\n+            new Object[]{new Class<?>[]{I1.class, I2.class}, I2.class, 20},\n+            new Object[]{new Class<?>[]{I1.class, I3.class}, I3.class, 20},\n+            \/\/ I2::m is implemented in more than one proxy interface directly or indirectly\n+            \/\/ I3::m resolves to I2::m (indirect superinterface)\n+            \/\/ I2 is the superinterface of I4 and I4 overrides m\n+            \/\/ the proxy class can invoke I4::m and I2::m\n+            new Object[]{new Class<?>[]{I3.class, I4.class}, I3.class, 20},\n+            new Object[]{new Class<?>[]{I3.class, I4.class}, I4.class, 40},\n+            new Object[]{new Class<?>[]{I4.class, I3.class}, I3.class, 20},\n+            new Object[]{new Class<?>[]{I4.class, I3.class}, I4.class, 40}\n+        };\n+    }\n+\n+    @Test(dataProvider = \"supers\")\n+    public void testSuper(Class<?>[] intfs, Class<?> proxyInterface, int expected) throws Exception {\n+        final InvocationHandler ih = (proxy, method, params) -> {\n+            switch (method.getName()) {\n+                case \"m\":\n+                    assertTrue(method.isDefault());\n+                    return InvocationHandler.invokeDefaultMethod(proxy, findDefaultMethod(proxyInterface, method), params);\n+                default:\n+                    throw new UnsupportedOperationException(method.toString());\n+            }\n+        };\n+        ClassLoader loader = proxyInterface.getClassLoader();\n+        Object proxy = Proxy.newProxyInstance(loader, intfs, ih);\n+        if (proxyInterface == I1.class) {\n+            I1 i1 = (I1) proxy;\n+            assertEquals(i1.m(), expected);\n+        } else if (proxyInterface == I2.class) {\n+            I2 i2 = (I2) proxy;\n+            assertEquals(i2.m(), expected);\n+        } else if (proxyInterface == I3.class) {\n+            I3 i3 = (I3) proxy;\n+            assertEquals(i3.m(), expected);\n+        } else if (proxyInterface == I4.class) {\n+            I4 i4 = (I4) proxy;\n+            assertEquals(i4.m(), expected);\n+        } else {\n+            throw new UnsupportedOperationException(proxyInterface.toString());\n+        }\n+        \/\/ invoke via InvocationHandler.invokeDefaultMethod directly\n+        assertEquals(InvocationHandler.invokeDefaultMethod(proxy, proxyInterface.getMethod(\"m\")), expected);\n+    }\n+\n+    \/\/ invoke I12 default methods with parameters and var args\n+    @Test\n+    public void testI12() throws Exception {\n+        final InvocationHandler ih = (proxy, method, params) -> {\n+            System.out.format(\"invoking %s with parameters: %s%n\", method, Arrays.toString(params));\n+            switch (method.getName()) {\n+                case \"sum\":\n+                case \"concat\":\n+                    assertTrue(method.isDefault());\n+                    return InvocationHandler.invokeDefaultMethod(proxy, method, params);\n+                default:\n+                    throw new UnsupportedOperationException(method.toString());\n+            }\n+        };\n+        ClassLoader loader = DefaultMethods.class.getClassLoader();\n+        I12 i12 = (I12) Proxy.newProxyInstance(loader, new Class<?>[] { I12.class }, ih);\n+        assertEquals(i12.sum(1, 2), 3);\n+        assertEquals(i12.concat(1, 2, 3, 4), new Object[]{1, 2, 3, 4});\n+        Method m = I12.class.getMethod(\"concat\", Object.class, Object[].class);\n+        assertTrue(m.isDefault());\n+        assertEquals(InvocationHandler.invokeDefaultMethod(i12, m, 100, new Object[] {\"foo\", true, \"bar\"}),\n+                     new Object[] {100, \"foo\", true, \"bar\"});\n+    }\n+\n+    \/\/ test a no-arg default method with and without arguments passed in the invocation\n+    @Test\n+    public void testEmptyArgument() throws Exception {\n+        ClassLoader loader = DefaultMethods.class.getClassLoader();\n+        Object proxy = Proxy.newProxyInstance(loader, new Class<?>[]{I4.class}, HANDLER);\n+        Method m1 = I4.class.getMethod(\"m\");\n+        assertTrue(m1.getDeclaringClass() == I4.class);\n+        assertTrue(m1.isDefault());\n+        InvocationHandler.invokeDefaultMethod(proxy, m1);\n+        InvocationHandler.invokeDefaultMethod(proxy, m1, new Object[0]);\n+\n+        Method m2 = I4.class.getMethod(\"mix\", int.class, String.class);\n+        assertTrue(m1.getDeclaringClass() == I4.class);\n+        assertTrue(m1.isDefault());\n+        InvocationHandler.invokeDefaultMethod(proxy, m2, Integer.valueOf(100), \"foo\");\n+    }\n+\n+    @Test\n+    public void testVarArgs() throws Exception {\n+        ClassLoader loader = DefaultMethods.class.getClassLoader();\n+        I3 proxy = (I3)Proxy.newProxyInstance(loader, new Class<?>[]{I3.class}, HANDLER);\n+        Method m = I3.class.getMethod(\"m3\", String[].class);\n+        assertTrue(m.isVarArgs() && m.isDefault());\n+        assertEquals(proxy.m3(\"a\", \"b\", \"cde\"), 5);\n+        assertEquals(InvocationHandler.invokeDefaultMethod(proxy, m, (Object)new String[] { \"a\", \"bc\" }), 3);\n+    }\n+\n+    \/*\n+     * Invoke I12::m which is an abstract method\n+     *\/\n+    @Test(expectedExceptions = {IllegalArgumentException.class})\n+    public void invokeAbstractMethod() throws Exception {\n+        ClassLoader loader = DefaultMethods.class.getClassLoader();\n+        I12 proxy = (I12) Proxy.newProxyInstance(loader, new Class<?>[]{I12.class}, HANDLER);\n+        Method method = I12.class.getMethod(\"m\");\n+        assertTrue(method.getDeclaringClass() == I12.class);\n+        assertFalse(method.isDefault());\n+        proxy.m();\n+    }\n+\n+    \/*\n+     * Invoke a non proxy (default) method with parameters\n+     *\/\n+    @Test(expectedExceptions = {IllegalArgumentException.class})\n+    public void invokeNonProxyMethod() throws Exception {\n+        ClassLoader loader = DefaultMethods.class.getClassLoader();\n+        I3 proxy = (I3) Proxy.newProxyInstance(loader, new Class<?>[]{I3.class}, HANDLER);\n+        Method m = I4.class.getMethod(\"mix\", int.class, String.class);\n+        assertTrue(m.isDefault());\n+        InvocationHandler.invokeDefaultMethod(proxy, m);\n+    }\n+\n+    \/\/ negative cases\n+    @DataProvider(name = \"negativeCases\")\n+    private Object[][] negativeCases() {\n+        return new Object[][]{\n+            \/\/ I4::m overrides I1::m and I2::m\n+            new Object[] { new Class<?>[]{I4.class}, I1.class, \"m\" },\n+            new Object[] { new Class<?>[]{I4.class}, I2.class, \"m\" },\n+            \/\/ I12::m is not a default method\n+            new Object[] { new Class<?>[]{I12.class}, I12.class, \"m\" },\n+            \/\/ non-proxy default method\n+            new Object[] { new Class<?>[]{I3.class}, I1.class, \"m\" },\n+            \/\/ not a default method and not a proxy interface\n+            new Object[] { new Class<?>[]{I12.class}, DefaultMethods.class, \"test\" },\n+            new Object[] { new Class<?>[]{I12.class}, Runnable.class, \"run\" },\n+            \/\/ I2::privateMethod is a private method\n+            new Object[] { new Class<?>[]{I3.class}, I2.class, \"privateMethod\" }\n+        };\n+    }\n+\n+    @Test(dataProvider = \"negativeCases\", expectedExceptions = {IllegalArgumentException.class})\n+    public void testNegativeCase(Class<?>[] interfaces, Class<?> defc, String name)\n+            throws Exception {\n+        ClassLoader loader = DefaultMethods.class.getClassLoader();\n+        Object proxy = Proxy.newProxyInstance(loader, interfaces, HANDLER);\n+        try {\n+            Method method = defc.getDeclaredMethod(name);\n+            InvocationHandler.invokeDefaultMethod(proxy, method);\n+        } catch (Throwable e) {\n+            System.out.format(\"%s method %s::%s exception thrown: %s%n\",\n+                              Arrays.toString(interfaces), defc.getName(), name, e.getMessage());\n+            throw e;\n+        }\n+    }\n+\n+    @DataProvider(name = \"illegalArguments\")\n+    private Object[][] illegalArguments() {\n+        return new Object[][] {\n+            new Object[] {},\n+            new Object[] { 100 },\n+            new Object[] { 100, \"foo\", 100 },\n+            new Object[] { 100L, \"foo\" },\n+            new Object[] { \"foo\", 100},\n+            new Object[] { null, \"foo\" }\n+        };\n+    }\n+\n+    @Test(dataProvider = \"illegalArguments\", expectedExceptions = {IllegalArgumentException.class})\n+    public void testIllegalArgument(Object... args) throws Exception {\n+        ClassLoader loader = DefaultMethods.class.getClassLoader();\n+        I4 proxy = (I4)Proxy.newProxyInstance(loader, new Class<?>[]{I4.class}, HANDLER);\n+        Method m = I4.class.getMethod(\"mix\", int.class, String.class);\n+        assertTrue(m.isDefault());\n+        if (args.length == 0) {\n+            \/\/ substitute empty args with null since @DataProvider doesn't allow null array\n+            args = null;\n+        }\n+        InvocationHandler.invokeDefaultMethod(proxy, m, args);\n+    }\n+\n+    @DataProvider(name = \"invocationTargetExceptions\")\n+    private Object[][] invocationTargetExceptions() {\n+        return new Object[][] {\n+            new Object[] { new IOException() },\n+            new Object[] { new IllegalArgumentException() },\n+            new Object[] { new ClassCastException() },\n+            new Object[] { new NullPointerException() },\n+            new Object[] { new AssertionError() },\n+            new Object[] { new Throwable() }\n+        };\n+    }\n+\n+    @Test(dataProvider = \"invocationTargetExceptions\")\n+    public void testInvocationTargetException(Throwable exception) throws Exception {\n+        ClassLoader loader = DefaultMethods.class.getClassLoader();\n+        IX proxy = (IX)Proxy.newProxyInstance(loader, new Class<?>[]{IX.class}, HANDLER);\n+        Method m = IX.class.getMethod(\"doThrow\", Throwable.class);\n+        try {\n+            InvocationHandler.invokeDefaultMethod(proxy, m, exception);\n+        } catch (InvocationTargetException e) {\n+            assertEquals(e.getCause(), exception);\n+        }\n+    }\n+\n+    private static final InvocationHandler HANDLER = (proxy, method, params) -> {\n+        System.out.format(\"invoking %s with parameters: %s%n\", method, Arrays.toString(params));\n+        return InvocationHandler.invokeDefaultMethod(proxy, method, params);\n+    };\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/Proxy\/DefaultMethods.java","additions":386,"deletions":0,"binary":false,"changes":386,"status":"added"},{"patch":"@@ -102,2 +102,3 @@\n-        assertFalse(proxyClass.getModule().isNamed());\n-        assertFalse(pkg.isSealed());\n+        assertTrue(proxyClass.getModule().isNamed());\n+        assertTrue(pkg.isSealed());\n+        assertTrue(proxyClass.getModule().isExported(pkg.getName()));\n@@ -135,0 +136,1 @@\n+        assertFalse(proxyClass.getModule().isExported(pkg.getName()));\n","filename":"test\/jdk\/java\/lang\/reflect\/Proxy\/ProxyLayerTest.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-        new ProxyModuleMapping(unnamed, Runnable.class).test();\n+        new ProxyModuleMapping(Runnable.class).test();\n@@ -82,1 +82,2 @@\n-            if (module.isNamed()) {\n+            \/\/ the exported package name is same as the module name\n+            if (!c.getPackageName().equals(module.getName())) {\n@@ -86,1 +87,2 @@\n-            if (!module.isNamed()) {\n+            \/\/ non-exported package from the dynamic module\n+            if (c.getPackageName().equals(module.getName())) {\n","filename":"test\/jdk\/java\/lang\/reflect\/Proxy\/ProxyModuleMapping.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -84,0 +84,16 @@\n+\n+    \/**\n+     * Tests invocation of default methods in exported and non-exported types\n+     * in a named module\n+     *\/\n+    @Test\n+    public void runDefaultMethodsTest() throws Exception {\n+        int exitValue = executeTestJava(\"-cp\", CPATH_DIR.toString(),\n+                \"--module-path\", MODS_DIR.toString(),\n+                \"-m\", \"test\/jdk.test.DefaultMethods\")\n+                .outputTo(System.out)\n+                .errorTo(System.out)\n+                .getExitValue();\n+\n+        assertTrue(exitValue == 0);\n+    }\n","filename":"test\/jdk\/java\/lang\/reflect\/Proxy\/ProxyTest.java","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -0,0 +1,124 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.reflect.*;\n+import java.util.Arrays;\n+import java.util.stream.Collectors;\n+\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.*;\n+\n+\/*\n+ * @test\n+ * @bug 8159746\n+ * @summary Test invoking a default method in a non-public proxy interface\n+ * @build p.Foo p.Bar p.DefaultMethodInvoker\n+ * @run testng DefaultMethodProxy\n+ *\/\n+public class DefaultMethodProxy {\n+    public interface I {\n+        default String m() { return \"I\"; }\n+    }\n+\n+    @Test\n+    public static void hasPackageAccess() throws Exception {\n+        Class<?> fooClass = Class.forName(\"p.Foo\");\n+        Class<?> barClass = Class.forName(\"p.Bar\");\n+\n+        \/\/ create a proxy instance of a non-public proxy interface\n+        makeProxy(IH, fooClass).testDefaultMethod(\"foo\");\n+        makeProxy(IH, barClass, fooClass).testDefaultMethod(\"bar\");\n+\n+        \/\/ create a proxy instance of a public proxy interface should succeed\n+        makeProxy(IH, I.class).testDefaultMethod(\"I\");\n+    }\n+\n+    @DataProvider(name = \"nonPublicIntfs\")\n+    private static Object[][] nonPublicIntfs() throws ClassNotFoundException {\n+        Class<?> fooClass = Class.forName(\"p.Foo\");\n+        Class<?> barClass = Class.forName(\"p.Bar\");\n+        return new Object[][]{\n+                new Object[]{new Class<?>[]{ fooClass }},\n+                new Object[]{new Class<?>[]{ barClass }},\n+                new Object[]{new Class<?>[]{ barClass, fooClass }},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"nonPublicIntfs\")\n+    public static void noPackageAccess(Class<?>[] intfs) throws Exception {\n+        makeProxy(IH_NO_ACCESS, intfs).testDefaultMethod(\"dummy\");\n+    }\n+\n+    final Object proxy;\n+    DefaultMethodProxy(Object proxy) {\n+        this.proxy = proxy;\n+    }\n+\n+    \/*\n+     * Verify if a default method \"m\" can be invoked successfully\n+     *\/\n+    void testDefaultMethod(String expected) throws ReflectiveOperationException {\n+        Method m = proxy.getClass().getDeclaredMethod(\"m\");\n+        m.setAccessible(true);\n+        String name = (String)m.invoke(proxy);\n+        if (!expected.equals(name)) {\n+            throw new RuntimeException(\"return value: \" + name + \" expected: \" + expected);\n+        }\n+    }\n+\n+    \/\/ invocation handler with access to the non-public interface in package p\n+    private static final InvocationHandler IH = (proxy, method, params) -> {\n+        System.out.format(\"Proxy for %s: invoking %s%n\",\n+                Arrays.stream(proxy.getClass().getInterfaces())\n+                      .map(Class::getName)\n+                      .collect(Collectors.joining(\", \")), method.getName());\n+        if (method.isDefault()) {\n+            return p.DefaultMethodInvoker.invoke(proxy, method, params);\n+        }\n+        throw new UnsupportedOperationException(method.toString());\n+    };\n+\n+    \/\/ invocation handler with no access to the non-public interface in package p\n+    \/\/ expect IllegalAccessException thrown\n+    private static final InvocationHandler IH_NO_ACCESS = (proxy, method, params) -> {\n+        System.out.format(\"Proxy for %s: invoking %s%n\",\n+                Arrays.stream(proxy.getClass().getInterfaces())\n+                        .map(Class::getName)\n+                        .collect(Collectors.joining(\", \")), method.getName());\n+        if (method.isDefault()) {\n+            try {\n+                InvocationHandler.invokeDefaultMethod(proxy, method, params);\n+                throw new RuntimeException(\"IAE not thrown in invoking: \" + method);\n+            } catch (IllegalAccessException e) {\n+                return \"dummy\";\n+            }\n+        }\n+        throw new UnsupportedOperationException(method.toString());\n+    };\n+\n+    private static DefaultMethodProxy makeProxy(InvocationHandler ih, Class<?>... intfs) {\n+        Object proxy = Proxy.newProxyInstance(DefaultMethodProxy.class.getClassLoader(), intfs, ih);\n+        return new DefaultMethodProxy(proxy);\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/Proxy\/nonPublicProxy\/DefaultMethodProxy.java","additions":124,"deletions":0,"binary":false,"changes":124,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2020, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/jdk\/java\/lang\/reflect\/Proxy\/nonPublicProxy\/NonPublicProxyClass.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+    default String m() { return \"bar\"; }\n","filename":"test\/jdk\/java\/lang\/reflect\/Proxy\/nonPublicProxy\/p\/Bar.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,32 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package p;\n+import java.lang.reflect.*;\n+\n+public class DefaultMethodInvoker {\n+     public static Object invoke(Object proxy, Method method, Object... args)\n+            throws IllegalAccessException, InvocationTargetException {\n+         return InvocationHandler.invokeDefaultMethod(proxy, method, args);\n+     }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/Proxy\/nonPublicProxy\/p\/DefaultMethodInvoker.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -26,0 +26,1 @@\n+    default String m() { return \"foo\"; }\n","filename":"test\/jdk\/java\/lang\/reflect\/Proxy\/nonPublicProxy\/p\/Foo.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+\n+    default int m() { return 1; }\n","filename":"test\/jdk\/java\/lang\/reflect\/Proxy\/src\/m1\/p\/one\/I.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+    default int m() { return 2; }\n","filename":"test\/jdk\/java\/lang\/reflect\/Proxy\/src\/m2\/p\/two\/internal\/C.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,0 +27,3 @@\n+    default int m() {\n+        throw new UnsupportedOperationException(\"Q::m is in a non-exported package\");\n+    }\n","filename":"test\/jdk\/java\/lang\/reflect\/Proxy\/src\/m3\/p\/three\/internal\/Q.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,97 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.test;\n+\n+import java.lang.reflect.InvocationHandler;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Proxy;\n+import java.lang.reflect.UndeclaredThrowableException;\n+\n+\/**\n+ * Tests invocation of default methods in exported types and inaccessible types\n+ * in a named module\n+ *\/\n+public class DefaultMethods {\n+    private final static Module TEST_MODULE = DefaultMethods.class.getModule();\n+    private final static InvocationHandler IH = (proxy, method, params) -> {\n+        return InvocationHandler.invokeDefaultMethod(proxy, method, params);\n+    };\n+\n+    public static void main(String... args) throws Exception {\n+        \/\/ exported types from m1\n+        testDefaultMethod(new Class<?>[] { p.one.I.class, p.two.A.class}, 1);\n+        \/\/ qualified-exported type from m2\n+        testDefaultMethod(new Class<?>[] { p.two.internal.C.class, p.two.A.class }, 2);\n+        \/\/ module-private type from test module\n+        testDefaultMethod(new Class<?>[] { jdk.test.internal.R.class }, 10);\n+        \/\/ non-public interface in the same runtime package\n+        testDefaultMethod(new Class<?>[] { Class.forName(\"jdk.test.NP\") }, 100);\n+\n+        \/\/ inaccessible type - not exported to test module\n+        Class<?> qType = Class.forName(\"p.three.internal.Q\");\n+        inaccessibleDefaultMethod(qType);\n+        \/\/ non-public interface in the same runtime package\n+        Class<?> nonPublicType = Class.forName(\"jdk.test.internal.NP\");\n+        inaccessibleDefaultMethod(nonPublicType);\n+    }\n+\n+    static void testDefaultMethod(Class<?>[] intfs, int expected) throws Exception {\n+        Object proxy = Proxy.newProxyInstance(TEST_MODULE.getClassLoader(), intfs, IH);\n+        if (!proxy.getClass().getModule().isNamed()) {\n+            throw new RuntimeException(proxy.getClass() + \" expected to be in a named module\");\n+        }\n+        Method m = intfs[0].getMethod(\"m\");\n+        int result = (int)m.invoke(proxy);\n+        if (result != expected) {\n+            throw new RuntimeException(\"return value: \" + result + \" expected: \" + expected);\n+        }\n+    }\n+\n+    static void inaccessibleDefaultMethod(Class<?> intf) throws Exception {\n+        Object proxy = Proxy.newProxyInstance(TEST_MODULE.getClassLoader(), new Class<?>[] { intf }, IH);\n+        if (!proxy.getClass().getModule().isNamed()) {\n+            throw new RuntimeException(proxy.getClass() + \" expected to be in a named module\");\n+        }\n+        Method m = intf.getMethod(\"m\");\n+        try {\n+            InvocationHandler.invokeDefaultMethod(proxy, m, null);\n+            throw new RuntimeException(\"IAE not thrown invoking: \" + m);\n+        } catch (IllegalAccessException e) {}\n+\n+        if (m.trySetAccessible()) {\n+            try {\n+                m.invoke(proxy);\n+                throw new RuntimeException(\"IAE not thrown invoking: \" + m);\n+            } catch (InvocationTargetException e) {\n+                \/\/ IAE wrapped by InvocationHandler::invoke with UndeclaredThrowableException\n+                \/\/ then wrapped by Method::invoke with InvocationTargetException\n+                assert e.getCause() instanceof UndeclaredThrowableException;\n+                Throwable cause = e.getCause().getCause();\n+                if (!(cause instanceof IllegalAccessException))\n+                    throw e;\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/Proxy\/src\/test\/jdk\/test\/DefaultMethods.java","additions":97,"deletions":0,"binary":false,"changes":97,"status":"added"},{"patch":"@@ -69,1 +69,0 @@\n-        Module unnamed = ld.getUnnamedModule();\n@@ -71,1 +70,0 @@\n-        Module unnamed2 = ld2.getUnnamedModule();\n@@ -74,11 +72,11 @@\n-            new Data(unnamed,  ld, Runnable.class),\n-            new Data(unnamed,  ld, p.one.I.class),\n-            new Data(unnamed,  ld, p.one.I.class, p.two.A.class),\n-            new Data(unnamed,  ld, p.one.I.class, unnamedModuleClass),\n-            new Data(unnamed2, ld2, Runnable.class),\n-            new Data(unnamed2, ld2, p.one.I.class),\n-            new Data(unnamed2, ld2, p.one.I.class, p.two.A.class),\n-            new Data(unnamed2, ld2, p.one.I.class, unnamedModuleClass),\n-            new Data(unnamed, m1.getClassLoader(), p.one.I.class),\n-            new Data(unnamed, m2.getClassLoader(), p.two.A.class),\n-            new Data(unnamed, m3.getClassLoader(), p.three.P.class),\n+            new Data(ld, Runnable.class),\n+            new Data(ld, p.one.I.class),\n+            new Data(ld, p.one.I.class, p.two.A.class),\n+            new Data(ld, p.one.I.class, unnamedModuleClass),\n+            new Data(ld2, Runnable.class),\n+            new Data(ld2, p.one.I.class),\n+            new Data(ld2, p.one.I.class, p.two.A.class),\n+            new Data(ld2, p.one.I.class, unnamedModuleClass),\n+            new Data(m1.getClassLoader(), p.one.I.class),\n+            new Data(m2.getClassLoader(), p.two.A.class),\n+            new Data(m3.getClassLoader(), p.three.P.class),\n","filename":"test\/jdk\/java\/lang\/reflect\/Proxy\/src\/test\/jdk\/test\/Main.java","additions":11,"deletions":13,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -31,0 +31,4 @@\n+\n+    default int m() {\n+        return 100;\n+    }\n","filename":"test\/jdk\/java\/lang\/reflect\/Proxy\/src\/test\/jdk\/test\/NP.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -99,1 +99,4 @@\n-            throw new RuntimeException(\"Expected IllegalAccessException: \" + proxyClass);\n+            \/\/ the exported package has the same name as the dynamic module\n+            if (!proxyClass.getPackageName().equals(m.getName())) {\n+                throw new RuntimeException(\"Expected IllegalAccessException: \" + proxyClass);\n+            }\n","filename":"test\/jdk\/java\/lang\/reflect\/Proxy\/src\/test\/jdk\/test\/ProxyTest.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,33 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.test.internal;\n+\n+\/*\n+ * Non-public interface\n+ *\/\n+interface NP {\n+    default int m() {\n+        throw new UnsupportedOperationException(\"non-public interface: \" + NP.class.getName());\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/Proxy\/src\/test\/jdk\/test\/internal\/NP.java","additions":33,"deletions":0,"binary":false,"changes":33,"status":"added"},{"patch":"@@ -34,0 +34,2 @@\n+\n+    default int m() { return 10; }\n","filename":"test\/jdk\/java\/lang\/reflect\/Proxy\/src\/test\/jdk\/test\/internal\/R.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -230,1 +230,1 @@\n-                        new StackTraceElement(\"com.sun.proxy.$Proxy0\", \"hashCode\", null, -1),\n+                        new StackTraceElement(\"jdk.proxy1.$Proxy0\", \"hashCode\", null, -1),\n","filename":"test\/langtools\/jdk\/jshell\/ExceptionsTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}