{"files":[{"patch":"@@ -2224,0 +2224,3 @@\n+            public void addExports(Module m, String pn) {\n+                m.implAddExports(pn);\n+            }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -28,0 +28,5 @@\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodHandles.Lookup;\n+import java.lang.invoke.MethodType;\n+import java.lang.invoke.WrongMethodTypeException;\n@@ -31,0 +36,1 @@\n+import java.util.ArrayDeque;\n@@ -33,0 +39,1 @@\n+import java.util.Deque;\n@@ -40,0 +47,1 @@\n+import java.util.concurrent.ConcurrentHashMap;\n@@ -45,1 +53,0 @@\n-import jdk.internal.loader.BootLoader;\n@@ -52,1 +59,0 @@\n-import sun.security.action.GetBooleanAction;\n@@ -57,1 +63,1 @@\n-\n+import static java.lang.invoke.MethodType.methodType;\n@@ -147,0 +153,6 @@\n+ * <li>A proxy interface may define a default method or inherit\n+ * a default method from its superinterface directly or indirectly.\n+ * An invocation handler can invoke a default method of a proxy interface\n+ * by calling {@link Proxy#invokeDefaultMethod(Object, Method, Object...)\n+ * Proxy::invokeDefaultMethod}.\n+ *\n@@ -175,3 +187,2 @@\n- *     <em>public<\/em> in a package exported by the\n- *     {@linkplain ClassLoader#getUnnamedModule() unnamed module} of the specified\n- *     loader. The name of the package is unspecified.<\/li>\n+ *     <em>public<\/em> in an unconditionally exported but non-open package.\n+ *     The name of the package and the module are unspecified.<\/li>\n@@ -488,0 +499,1 @@\n+            boolean nonExported = false;\n@@ -505,0 +517,5 @@\n+                } else {\n+                    if (!intf.getModule().isExported(intf.getPackageName())) {\n+                        \/\/ module-private types\n+                        nonExported = true;\n+                    }\n@@ -509,3 +526,5 @@\n-                \/\/ all proxy interfaces are public\n-                proxyPkg = m.isNamed() ? PROXY_PACKAGE_PREFIX + \".\" + m.getName()\n-                                       : PROXY_PACKAGE_PREFIX;\n+                \/\/ all proxy interfaces are public and exported\n+                if (!m.isNamed())\n+                    throw new InternalError(\"ununamed module: \" + m);\n+                proxyPkg = nonExported ? PROXY_PACKAGE_PREFIX + \".\" + m.getName()\n+                                       : m.getName();\n@@ -649,0 +668,2 @@\n+            assert !module.isNamed() || module.isOpen(proxyClass.getPackageName(), Proxy.class.getModule());\n+\n@@ -745,3 +766,0 @@\n-         * If all proxy interfaces are public and in exported packages,\n-         * then the proxy class is in unnamed module.\n-         *\n@@ -751,0 +769,4 @@\n+         * If all proxy interfaces are public and in exported packages,\n+         * then the proxy class is in a dynamic module in an unconditionally\n+         * exported package.\n+         *\n@@ -753,2 +775,5 @@\n-         * non-exported package.  Reads edge and qualified exports are added\n-         * for dynamic module to access.\n+         * non-exported package.\n+         *\n+         * The package of proxy class is open to java.base for deep reflective access.\n+         *\n+         * Reads edge and qualified exports are added for dynamic module to access.\n@@ -759,1 +784,0 @@\n-            Map<Class<?>, Module> modulePrivateTypes = new HashMap<>();\n@@ -763,6 +787,1 @@\n-                if (Modifier.isPublic(intf.getModifiers())) {\n-                    \/\/ module-private types\n-                    if (!m.isExported(intf.getPackageName())) {\n-                        modulePrivateTypes.put(intf, m);\n-                    }\n-                } else {\n+                if (!Modifier.isPublic(intf.getModifiers())) {\n@@ -773,8 +792,0 @@\n-            \/\/ all proxy interfaces are public and exported, the proxy class\n-            \/\/ is in unnamed module.  Such proxy class is accessible to\n-            \/\/ any unnamed module and named module that can read unnamed module\n-            if (packagePrivateTypes.isEmpty() && modulePrivateTypes.isEmpty()) {\n-                return loader != null ? loader.getUnnamedModule()\n-                                      : BootLoader.getUnnamedModule();\n-            }\n-\n@@ -787,12 +798,10 @@\n-                if (packagePrivateTypes.size() > 1 &&\n-                        (packagePrivateTypes.keySet().stream()  \/\/ more than one package\n-                                 .map(Class::getPackageName).distinct().count() > 1 ||\n-                         packagePrivateTypes.values().stream()  \/\/ or more than one module\n-                                 .distinct().count() > 1)) {\n-                    throw new IllegalArgumentException(\n-                            \"non-public interfaces from different packages\");\n-                }\n-\n-                \/\/ all package-private types are in the same module (named or unnamed)\n-                Module target = null;\n-                for (Module m : packagePrivateTypes.values()) {\n+                Module targetModule = null;\n+                String targetPackageName = null;\n+                for (Map.Entry<Class<?>, Module> e : packagePrivateTypes.entrySet()) {\n+                    Class<?> intf = e.getKey();\n+                    Module m = e.getValue();\n+                    if ((targetModule != null && targetModule != m) ||\n+                        (targetPackageName != null && targetPackageName != intf.getPackageName())) {\n+                        throw new IllegalArgumentException(\n+                                \"cannot have non-public interfaces in different packages\");\n+                    }\n@@ -805,1 +814,3 @@\n-                    target = m;\n+\n+                    targetModule = m;\n+                    targetPackageName = e.getKey().getPackageName();\n@@ -811,1 +822,1 @@\n-                    if (m == target) continue;\n+                    if (m == targetModule) continue;\n@@ -813,2 +824,2 @@\n-                    if (!target.canRead(m) || !m.isExported(intf.getPackageName(), target)) {\n-                        throw new IllegalArgumentException(target + \" can't access \" + intf.getName());\n+                    if (!targetModule.canRead(m) || !m.isExported(intf.getPackageName(), targetModule)) {\n+                        throw new IllegalArgumentException(targetModule + \" can't access \" + intf.getName());\n@@ -818,0 +829,4 @@\n+                \/\/ opens the package of the non-public proxy class for java.base to access\n+                if (targetModule.isNamed()) {\n+                    Modules.addOpens(targetModule, targetPackageName, Proxy.class.getModule());\n+                }\n@@ -819,1 +834,1 @@\n-                return target;\n+                return targetModule;\n@@ -822,4 +837,3 @@\n-            \/\/ All proxy interfaces are public and at least one in a non-exported\n-            \/\/ package.  So maps to a dynamic proxy module and add reads edge\n-            \/\/ and qualified exports, if necessary\n-            Module target = getDynamicModule(loader);\n+            \/\/ All proxy interfaces are public.  So maps to a dynamic proxy module\n+            \/\/ and add reads edge and qualified exports, if necessary\n+            Module targetModule = getDynamicModule(loader);\n@@ -832,1 +846,1 @@\n-                ensureAccess(target, c);\n+                ensureAccess(targetModule, c);\n@@ -834,1 +848,1 @@\n-            return target;\n+            return targetModule;\n@@ -880,2 +894,3 @@\n-         * Define a dynamic module for the generated proxy classes in\n-         * a non-exported package named com.sun.proxy.$MODULE.\n+         * Define a dynamic module with a packge named $MODULE which\n+         * is unconditionally exported and another package named\n+         * com.sun.proxy.$MODULE which is encapsulated.\n@@ -891,3 +906,4 @@\n-                    ModuleDescriptor.newModule(mn, Set.of(SYNTHETIC))\n-                                    .packages(Set.of(pn))\n-                                    .build();\n+                        ModuleDescriptor.newModule(mn, Set.of(SYNTHETIC))\n+                                        .packages(Set.of(pn, mn))\n+                                        .exports(mn)\n+                                        .build();\n@@ -896,2 +912,4 @@\n-                \/\/ java.base to create proxy instance\n-                Modules.addExports(m, pn, Object.class.getModule());\n+                Modules.addExports(m, mn);\n+                \/\/ java.base to create proxy instance and access its Lookup instance\n+                Modules.addOpens(m, pn, Proxy.class.getModule());\n+                Modules.addOpens(m, mn, Proxy.class.getModule());\n@@ -1127,0 +1145,268 @@\n+\n+    \/**\n+     * A cache of Method -> MethodHandle for default methods.\n+     *\/\n+    private static final ClassValue<ConcurrentHashMap<Method, MethodHandle>>\n+            DEFAULT_METHODS_MAP = new ClassValue<>() {\n+        @Override\n+        protected ConcurrentHashMap<Method, MethodHandle> computeValue(Class<?> type) {\n+            return new ConcurrentHashMap<>(4);\n+        }\n+    };\n+\n+    \/**\n+     * Invokes the specified default method on the given {@code proxy} instance with\n+     * the given parameters.  The given {@code method} must be a default method\n+     * declared in a proxy interface of the {@code proxy}'s class or inherited\n+     * from its superinterface directly or indirectly.\n+     * <p>\n+     * This method behaves as if {@code X.super.m(A* a)} is called from the proxy\n+     * class as the caller where {@code X} is a proxy interface and\n+     * the call to {@code X.super::m(A*)} is resolved to the given {@code method}.\n+     * <p>\n+     * For example, interface {@code A} and {@code B} both declare a default\n+     * implementation of method {@code m}. Interface {@code C} extends {@code A}\n+     * and it inherits the default method {@code m} from its superinterface {@code A}.\n+     *\n+     * <blockquote><pre>{@code\n+     * interface A {\n+     *     default T m(A a) { return t1; }\n+     * }\n+     * interface B {\n+     *     default T m(A a) { return t2; }\n+     * }\n+     * interface C extends A {}\n+     * }<\/pre><\/blockquote>\n+     *\n+     * The following creates a proxy instance that implements {@code C}.\n+     * When {@code proxy::m} is invoked, the {@code method} argument passed to\n+     * {@link InvocationHandler#invoke(Object, Method, Object[]) InvocationHandler::invoke}\n+     * would be {@code A::m} as {@code C} inherits \"{@code m}\" from {@code A}.\n+     * An invocation handler can directly invoke the default method via\n+     * {@code Proxy::invokeDefaultMethod}.\n+     *\n+     * <blockquote><pre>{@code\n+     * Object proxy = Proxy.newProxyInstance(loader, new Class<?>[] { C.class },\n+     *        (o, m, params) -> {\n+     *             assert m.getDeclaringClass() == A.class && m.isDefault();\n+     *             return Proxy.invokeDefaultMethod(o, m, params);\n+     *        });\n+     * }<\/pre><\/blockquote>\n+     *\n+     * The following creates a proxy instance that implements {@code A} and {@code B}\n+     * and the invocation handler delegates the method invocation to\n+     * invoking {@code B::m} via {@code Proxy::invokeDefaultMethod}.\n+     *\n+     * <blockquote><pre>{@code\n+     * Object proxy = Proxy.newProxyInstance(loader, new Class<?>[] { A.class, B.class },\n+     *         (o, m, params) -> {\n+     *             \/\/ delegate to calling B::m\n+     *             return Proxy.invokeDefaultMethod(o, B.class.getMethod(m.getName(), m.getParameterTypes()), params);\n+     *         });\n+     * }<\/pre><\/blockquote>\n+     *\n+     * If an interface {@code D} extends {@code A} and overrides {@code m},\n+     * the proxy class implementing {@code D} can invoke {@code D::m} default method\n+     * as if calling {@code D.super::m}.  As {@code D} has the implementation of\n+     * {@code m}, invoking {@code A::m} via {@code Proxy::invokeDefaultMethod}\n+     * will result in an {@code IllegalArgumentException} because {@code A::m}\n+     * is not inherited from any proxy interface.\n+     *\n+     * <blockquote><pre>{@code\n+     * interface D extends A {\n+     *     default T m(A a) { return t3; }\n+     * }\n+     *\n+     * Object proxy = Proxy.newProxyInstance(loader, new Class<?>[] { D.class },\n+     *         (o, m, params) -> {\n+     *             \/\/ IllegalArgumentException thrown as {@code A::m} is not a method\n+     *             \/\/ inherited from its proxy interface\n+     *             return Proxy.invokeDefaultMethod(o, A.class.getMethod(\"m\"), params);\n+     *         });\n+     * }<\/pre><\/blockquote>\n+     * @param proxy   the {@code Proxy} instance on which the default method to be invoked\n+     * @param method  the {@code Method} instance corresponding to a default method\n+     *                declared in a proxy interface of the proxy class or inherited\n+     *                from its superinterface directly or indirectly\n+     * @param args    the parameters used for the method invocation\n+     * @return the value returned from the method invocation\n+     *\n+     * @throws IllegalArgumentException if any of the following conditions is {@code true}:\n+     *         <ul>\n+     *         <li>{@code proxy} is not {@linkplain #isProxyClass(Class)\n+     *             a proxy instance}; or<\/li>\n+     *         <li>the given {@code method} is not a default method declared\n+     *             in a proxy interface of the proxy class and not inherited from\n+     *             any of its superinterfaces; or<\/li>\n+     *         <li>the given {@code method} is overridden directly or indirectly by\n+     *             the proxy interfaces and the method reference to the named\n+     *             method never resolves to the given {@code method}; or<\/li>\n+     *         <li>any of the given {@code args} does not match the parameter type of\n+     *             the default method to be invoked<\/li>\n+     *         <\/ul>\n+     * @throws InvocationTargetException if the invoked default method throws\n+     *         any exception, it is wrapped by {@code InvocationTargetException}\n+     *         and rethrown\n+     * @throws NullPointerException if {@code proxy} or {@code method} is\n+     *         {@code null}\n+     * @since 16\n+     * @jvms 5.4.3. Method Resolution\n+     *\/\n+    public static Object invokeDefaultMethod(Object proxy, Method method, Object... args)\n+            throws InvocationTargetException {\n+        Objects.requireNonNull(proxy);\n+        Objects.requireNonNull(method);\n+\n+        \/\/ verify that the object is actually a proxy instance\n+        Class<?> proxyClass = proxy.getClass();\n+        if (!isProxyClass(proxyClass)) {\n+            throw new IllegalArgumentException(\"'proxy' is not a proxy instance\");\n+        }\n+        if (!method.isDefault()) {\n+            throw new IllegalArgumentException(\"\\\"\" + method + \"\\\" is not a default method\");\n+        }\n+\n+        \/\/ lookup the cached method handle\n+        ConcurrentHashMap<Method, MethodHandle> methods = DEFAULT_METHODS_MAP.get(proxyClass);\n+        MethodHandle superMH = methods.get(method);\n+\n+        MethodType type = methodType(method.getReturnType(), method.getParameterTypes());\n+        if (superMH != null) {\n+            try {\n+                \/\/ make sure that the method type matches\n+                superMH.asType(type.insertParameterTypes(0, proxyClass));\n+            } catch (WrongMethodTypeException e) {\n+                throw new IllegalArgumentException(e.getMessage(), e);\n+            }\n+        } else {\n+            Class<?> proxyInterface = findProxyInterfaceOrElseThrow(proxyClass, method);\n+            try {\n+                superMH = ((Proxy) proxy).proxyClassLookup(MethodHandles.lookup())\n+                                         .findSpecial(proxyInterface, method.getName(), type, proxyClass)\n+                                         .withVarargs(false);\n+            } catch (IllegalAccessException|NoSuchMethodException e) {\n+                \/\/ should not reach here\n+                throw new InternalError(e);\n+            }\n+            \/\/ push MH into cache\n+            MethodHandle cached = methods.putIfAbsent(method, superMH);\n+            if (cached != null) {\n+                superMH = cached;\n+            }\n+        }\n+\n+        \/\/ validate the arguments if they match the method type\n+        int numArgs = args != null ? args.length : 0;\n+        if (numArgs != type.parameterCount()) {\n+            throw new IllegalArgumentException(\"args not matching the formal parameter types: \" + type);\n+        }\n+        try {\n+            if (numArgs > 0) {\n+                Class<?>[] paramTypes = new Class<?>[numArgs];\n+                for (int i = 0; i < numArgs; i++) {\n+                    Object o = args[i];\n+                    paramTypes[i] = o != null ? o.getClass() : type.parameterType(i);\n+                }\n+                superMH.asType(methodType(type.returnType(), proxyClass, paramTypes));\n+            } else {\n+                superMH.asType(methodType(type.returnType(), proxyClass));\n+            }\n+        } catch (WrongMethodTypeException e) {\n+            throw new IllegalArgumentException(e);\n+        }\n+\n+        \/\/ invoke the super method\n+        try {\n+            return superMH.asSpreader(1, Object[].class, type.parameterCount())\n+                          .invoke(proxy, args);\n+        } catch (Throwable t) {\n+            throw new InvocationTargetException(t);\n+        }\n+    }\n+\n+    \/*\n+     * Finds the first proxy interface that declares the given method\n+     * directly or indirectly.\n+     *\n+     * @throws IllegalArgumentException if not found\n+     *\/\n+    private static Class<?> findProxyInterfaceOrElseThrow(Class<?> proxyClass, Method method) {\n+        Class<?> declaringClass = method.getDeclaringClass();\n+        if (!declaringClass.isInterface()) {\n+            throw new IllegalArgumentException(\"\\\"\" + method +\n+                    \"\\\" is not a method declared in the proxy class\");\n+        }\n+\n+        List<Class<?>> proxyInterfaces = Arrays.asList(proxyClass.getInterfaces());\n+        \/\/ the method's declaring class is a proxy interface\n+        if (proxyInterfaces.contains(declaringClass))\n+            return declaringClass;\n+\n+        Deque<Class<?>> deque = new ArrayDeque<>();\n+        Set<Class<?>> visited = new HashSet<>();\n+        boolean indirectMethodRef = false;\n+        for (Class<?> intf : proxyInterfaces) {\n+            assert intf != declaringClass;\n+            visited.add(intf);\n+            deque.add(intf);\n+\n+            Class<?> c;\n+            while ((c = deque.poll()) != null) {\n+                if (c == declaringClass) {\n+                    try {\n+                        \/\/ check if this method is the resolved method if referenced from\n+                        \/\/ this proxy interface (i.e. this method is not implemented\n+                        \/\/ by any other superinterface)\n+                        Method m = intf.getMethod(method.getName(), method.getParameterTypes());\n+                        if (m.getDeclaringClass() == declaringClass) {\n+                            return intf;\n+                        }\n+                        indirectMethodRef = true;\n+                    } catch (NoSuchMethodException e) {}\n+\n+                    \/\/ skip traversing its superinterfaces\n+                    \/\/ another proxy interface may extend it and so\n+                    \/\/ the method's declaring class is left unvisited.\n+                    continue;\n+                }\n+                \/\/ visit all superinteraces of one proxy interface to find if\n+                \/\/ this proxy interface inherits the method directly or indirectly\n+                visited.add(c);\n+                for (Class<?> superIntf : c.getInterfaces()) {\n+                    if (!visited.contains(superIntf) && !deque.contains(superIntf)) {\n+                        if (superIntf == declaringClass) {\n+                            deque.addFirst(superIntf);\n+                        } else {\n+                            deque.add(superIntf);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        throw new IllegalArgumentException(\"\\\"\" + method + (indirectMethodRef\n+                ? \"\\\" is overridden directly or indirectly by the proxy interfaces\"\n+                : \"\\\" is not a method declared in the proxy class\"));\n+    }\n+\n+    \/**\n+     * Returns a Lookup object for the lookup class which is the class of this\n+     * proxy instance.\n+     *\n+     * @return a lookup for proxy class of this proxy instance\n+     *\/\n+    private Lookup proxyClassLookup(Lookup caller) {\n+        Class<?> proxyClass = this.getClass();\n+        return AccessController.doPrivileged(new PrivilegedAction<>() {\n+            @Override\n+            public Lookup run() {\n+                try {\n+                    Method m = proxyClass.getDeclaredMethod(\"proxyClassLookup\", Lookup.class);\n+                    m.setAccessible(true);\n+                    return (Lookup) m.invoke(null, caller);\n+                } catch (ReflectiveOperationException e) {\n+                    throw new InternalError(e);\n+                }\n+            }\n+        });\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Proxy.java","additions":345,"deletions":59,"binary":false,"changes":404,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import jdk.internal.org.objectweb.asm.Type;\n@@ -62,0 +63,2 @@\n+    private static final String JL_ILLEGAL_ACCESS_EX = \"java\/lang\/IllegalAccessException\";\n+\n@@ -65,0 +68,2 @@\n+    private static final String JLI_LOOKUP = \"java\/lang\/invoke\/MethodHandles$Lookup\";\n+    private static final String JLI_METHODHANDLES = \"java\/lang\/invoke\/MethodHandles\";\n@@ -78,0 +83,1 @@\n+    private static final String NAME_LOOKUP_ACCESSOR = \"proxyClassLookup\";\n@@ -496,1 +502,1 @@\n-\n+        generateLookupAccessor();\n@@ -628,0 +634,40 @@\n+    \/**\n+     * Generate the static lookup accessor method that returns the Lookup\n+     * on this proxy class if the caller's lookup class is java.lang.reflect.Proxy;\n+     * otherwise, IllegalAccessException is thrown\n+     *\/\n+    private void generateLookupAccessor() {\n+        MethodVisitor mv = visitMethod(ACC_PRIVATE | ACC_STATIC, NAME_LOOKUP_ACCESSOR,\n+                \"(Ljava\/lang\/invoke\/MethodHandles$Lookup;)Ljava\/lang\/invoke\/MethodHandles$Lookup;\", null,\n+                new String[] { JL_ILLEGAL_ACCESS_EX });\n+        mv.visitCode();\n+        Label L_illegalAccess = new Label();\n+\n+        mv.visitVarInsn(ALOAD, 0);\n+        mv.visitMethodInsn(INVOKEVIRTUAL, JLI_LOOKUP, \"lookupClass\",\n+                \"()Ljava\/lang\/Class;\", false);\n+        mv.visitLdcInsn(Type.getType(Proxy.class));\n+        mv.visitJumpInsn(IF_ACMPNE, L_illegalAccess);\n+        mv.visitVarInsn(ALOAD, 0);\n+        mv.visitMethodInsn(INVOKEVIRTUAL, JLI_LOOKUP, \"hasFullPrivilegeAccess\",\n+                \"()Z\", false);\n+        mv.visitJumpInsn(IFEQ, L_illegalAccess);\n+        mv.visitMethodInsn(INVOKESTATIC, JLI_METHODHANDLES, \"lookup\",\n+                \"()Ljava\/lang\/invoke\/MethodHandles$Lookup;\", false);\n+        mv.visitInsn(ARETURN);\n+\n+        mv.visitLabel(L_illegalAccess);\n+        mv.visitTypeInsn(Opcodes.NEW, JL_ILLEGAL_ACCESS_EX);\n+        mv.visitInsn(DUP);\n+        mv.visitVarInsn(ALOAD, 0);\n+        mv.visitMethodInsn(INVOKEVIRTUAL, JLI_LOOKUP, \"toString\",\n+                \"()Ljava\/lang\/String;\", false);\n+        mv.visitMethodInsn(INVOKESPECIAL, JL_ILLEGAL_ACCESS_EX,\n+                \"<init>\", \"(Ljava\/lang\/String;)V\", false);\n+        mv.visitInsn(ATHROW);\n+\n+        \/\/ Maxs computed by ClassWriter.COMPUTE_FRAMES, these arguments ignored\n+        mv.visitMaxs(-1, -1);\n+        mv.visitEnd();\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/ProxyGenerator.java","additions":47,"deletions":1,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -212,0 +212,5 @@\n+    \/**\n+     * Updates module m1 to export a package unconditionally.\n+     *\/\n+    void addExports(Module m1, String pkg);\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangAccess.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -108,0 +108,7 @@\n+    \/**\n+     * Updates module m to export a package unconditionally.\n+     *\/\n+    public static void addExports(Module m, String pn) {\n+        JLA.addExports(m, pn);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/module\/Modules.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -266,2 +266,1 @@\n-        String pkg = cls.getPackageName();\n-        return pkg == null || !pkg.startsWith(PROXY_PACKAGE);\n+        return !Modifier.isPublic(cls.getModifiers());\n","filename":"src\/java.base\/share\/classes\/sun\/reflect\/misc\/ReflectUtil.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,356 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.reflect.InvocationHandler;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Proxy;\n+import java.util.Arrays;\n+\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.*;\n+\n+\/**\n+ * @test\n+ * @bug 8159746\n+ * @run testng DefaultMethods\n+ * @summary Basic tests for Proxy::invokeSuper default method\n+ *\/\n+\n+public class DefaultMethods {\n+    public interface I1 {\n+        default int m() {\n+            return 10;\n+        }\n+    }\n+\n+    public interface I2 {\n+        default int m() {\n+            return 20;\n+        }\n+\n+        private void privateMethod() {\n+            throw new Error(\"should not reach here\");\n+        }\n+    }\n+\n+    \/\/ I3::m inherits from I2:m\n+    public interface I3 extends I2 {\n+        default int m3(String... s) {\n+            return Arrays.stream(s).mapToInt(String::length).sum();\n+        }\n+    }\n+\n+    public interface I4 extends I1, I2 {\n+        default int m() {\n+            return 40;\n+        }\n+\n+        default int mix(int a, String b) {\n+            return 0;\n+        }\n+    }\n+\n+    public interface I12 extends I1, I2 {\n+        @Override\n+        int m();\n+\n+        default int sum(int a, int b) {\n+            return a + b;\n+        }\n+\n+        default Object[] concat(Object first, Object... rest) {\n+            Object[] result = new Object[1 + rest.length];\n+            result[0] = first;\n+            System.arraycopy(rest, 0, result, 1, rest.length);\n+            return result;\n+        }\n+    }\n+\n+    private static Method findDefaultMethod(Class<?> refc, Method m) {\n+        try {\n+            assertTrue(refc.isInterface());\n+\n+            Method method = refc.getMethod(m.getName(), m.getParameterTypes());\n+            assertTrue(method.isDefault());\n+            return method;\n+        } catch (NoSuchMethodException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    @Test\n+    public void test() {\n+        ClassLoader loader = DefaultMethods.class.getClassLoader();\n+        Object proxy = Proxy.newProxyInstance(loader, new Class<?>[] { I1.class, I2.class},\n+                (o, method, params) -> {\n+                    return Proxy.invokeDefaultMethod(o, findDefaultMethod(I2.class, method), params);\n+                });\n+        I1 i1 = (I1) proxy;\n+        assertEquals(i1.m(), 20);\n+    }\n+\n+    \/\/ a default method is declared in one of the proxy interfaces\n+    @DataProvider(name = \"defaultMethods\")\n+    private Object[][] defaultMethods() {\n+        return new Object[][] {\n+                new Object[] { new Class<?>[] { I1.class, I2.class },  true, 10 },\n+                new Object[] { new Class<?>[] { I1.class, I3.class },  true, 10 },\n+                new Object[] { new Class<?>[] { I1.class, I12.class }, true, 10 },\n+                new Object[] { new Class<?>[] { I2.class, I12.class }, true, 20 },\n+                new Object[] { new Class<?>[] { I4.class },            true, 40 },\n+                new Object[] { new Class<?>[] { I4.class, I3.class },  true, 40 },\n+                new Object[] { new Class<?>[] { I12.class },                     false, -1 },\n+                new Object[] { new Class<?>[] { I12.class, I1.class, I2.class }, false, -1 },\n+        };\n+    }\n+\n+    @Test(dataProvider = \"defaultMethods\")\n+    public void testDefaultMethod(Class<?>[] intfs, boolean isDefault, int expected) throws Exception {\n+        InvocationHandler ih = (proxy, method, params) -> {\n+            System.out.format(\"invoking %s with parameters: %s%n\", method, Arrays.toString(params));\n+            switch (method.getName()) {\n+                case \"m\":\n+                    assertTrue(method.isDefault() == isDefault);\n+                    assertTrue(Arrays.stream(proxy.getClass().getInterfaces())\n+                                     .anyMatch(intf -> method.getDeclaringClass() == intf),\n+                               Arrays.toString(proxy.getClass().getInterfaces()));\n+                    if (method.isDefault()) {\n+                        return Proxy.invokeDefaultMethod(proxy, method, params);\n+                    } else {\n+                        return -1;\n+                    }\n+                default:\n+                    throw new UnsupportedOperationException(method.toString());\n+            }\n+        };\n+\n+        Object proxy = Proxy.newProxyInstance(DefaultMethods.class.getClassLoader(), intfs, ih);\n+        Method m = proxy.getClass().getMethod(\"m\");\n+        int result = (int)m.invoke(proxy);\n+        assertEquals(result, expected);\n+    }\n+\n+    \/\/ a default method may be declared in a proxy interface or\n+    \/\/ inherited from a superinterface of a proxy interface\n+    @DataProvider(name = \"supers\")\n+    private Object[][] supers() {\n+        return new Object[][] {\n+                \/\/ invoke \"m\" implemented in the first proxy interface\n+                \/\/ same as the method passed to InvocationHandler::invoke\n+                new Object[]{new Class<?>[]{ I1.class }, I1.class, 10},\n+                new Object[]{new Class<?>[]{ I2.class }, I2.class, 20},\n+                new Object[]{new Class<?>[]{ I1.class, I2.class }, I1.class, 10},\n+                \/\/ \"m\" is implemented in I2, an indirect superinterface of I3\n+                new Object[]{new Class<?>[]{ I3.class }, I3.class, 20},\n+                \/\/ \"m\" is implemented in I1, I2 and overridden in I4\n+                new Object[]{new Class<?>[]{ I4.class }, I4.class, 40},\n+                \/\/ invoke \"m\" implemented in the second proxy interface\n+                \/\/ different from the method passed to InvocationHandler::invoke\n+                new Object[]{new Class<?>[]{ I1.class, I2.class }, I2.class, 20},\n+                new Object[]{new Class<?>[]{ I1.class, I3.class }, I3.class, 20},\n+                \/\/ I2::m is implemented in more than one proxy interface directly or indirectly\n+                \/\/ I3::m resolves to I2::m (indirect superinterface)\n+                \/\/ I2 is the superinterface of I4 and I4 overrides m\n+                \/\/ the proxy class can invoke I4::m and I2::m\n+                new Object[]{new Class<?>[]{ I3.class, I4.class }, I3.class, 20},\n+                new Object[]{new Class<?>[]{ I3.class, I4.class }, I4.class, 40},\n+                new Object[]{new Class<?>[]{ I4.class, I3.class }, I3.class, 20},\n+                new Object[]{new Class<?>[]{ I4.class, I3.class }, I4.class, 40},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"supers\")\n+    public void testSuper(Class<?>[] intfs, Class<?> proxyInterface, int expected) throws Exception {\n+        InvocationHandler ih = (proxy, method, params) -> {\n+            switch (method.getName()) {\n+                case \"m\":\n+                    assertTrue(method.isDefault());\n+                    return Proxy.invokeDefaultMethod(proxy, findDefaultMethod(proxyInterface, method), params);\n+                default:\n+                    throw new UnsupportedOperationException(method.toString());\n+            }\n+        };\n+        ClassLoader loader = proxyInterface.getClassLoader();\n+        Object proxy = Proxy.newProxyInstance(loader, intfs, ih);\n+        if (proxyInterface == I1.class) {\n+            I1 i1 = (I1) proxy;\n+            assertEquals(i1.m(), expected);\n+        } else if (proxyInterface == I2.class) {\n+            I2 i2 = (I2) proxy;\n+            assertEquals(i2.m(), expected);\n+        } else if (proxyInterface == I3.class) {\n+            I3 i3 = (I3) proxy;\n+            assertEquals(i3.m(), expected);\n+        } else if (proxyInterface == I4.class) {\n+            I4 i4 = (I4) proxy;\n+            assertEquals(i4.m(), expected);\n+        } else {\n+            throw new UnsupportedOperationException(proxyInterface.toString());\n+        }\n+        \/\/ invoke via Proxy.invokeDefaultMethod directly\n+        assertEquals(Proxy.invokeDefaultMethod(proxy, proxyInterface.getMethod(\"m\")), expected);\n+    }\n+\n+    \/\/ invoke I12 default methods with parameters and var args\n+    @Test\n+    public void testI12() throws Exception {\n+        InvocationHandler ih = (proxy, method, params) -> {\n+            System.out.format(\"invoking %s with parameters: %s%n\", method, Arrays.toString(params));\n+            switch (method.getName()) {\n+                case \"sum\":\n+                case \"concat\":\n+                    assertTrue(method.isDefault());\n+                    return Proxy.invokeDefaultMethod(proxy, method, params);\n+                default:\n+                    throw new UnsupportedOperationException(method.toString());\n+            }\n+        };\n+        ClassLoader loader = DefaultMethods.class.getClassLoader();\n+        I12 i12 = (I12) Proxy.newProxyInstance(loader, new Class<?>[] { I12.class }, ih);\n+        assertEquals(i12.sum(1, 2), 3);\n+        assertEquals(i12.concat(1, 2, 3, 4), new Object[]{1, 2, 3, 4});\n+        Method m = I12.class.getMethod(\"concat\", Object.class, Object[].class);\n+        assertTrue(m.isDefault());\n+        assertEquals(Proxy.invokeDefaultMethod(i12, m, 100, new Object[] {\"foo\", true, \"bar\"}),\n+                     new Object[] {100, \"foo\", true, \"bar\"});\n+    }\n+\n+    \/\/ test a no-arg default method with and without arguments passed in the invocation\n+    @Test\n+    public void testEmptyArgument() throws Exception {\n+        ClassLoader loader = DefaultMethods.class.getClassLoader();\n+        Object proxy = Proxy.newProxyInstance(loader, new Class<?>[]{I4.class}, HANDLER);\n+        Method m1 = I4.class.getMethod(\"m\");\n+        assertTrue(m1.getDeclaringClass() == I4.class);\n+        assertTrue(m1.isDefault());\n+        Proxy.invokeDefaultMethod(proxy, m1);\n+        Proxy.invokeDefaultMethod(proxy, m1, new Object[0]);\n+\n+        Method m2 = I4.class.getMethod(\"mix\", int.class, String.class);\n+        assertTrue(m1.getDeclaringClass() == I4.class);\n+        assertTrue(m1.isDefault());\n+        Proxy.invokeDefaultMethod(proxy, m2, Integer.valueOf(100), \"foo\");\n+    }\n+\n+    @Test\n+    public void testVarArgs() throws Exception {\n+        ClassLoader loader = DefaultMethods.class.getClassLoader();\n+        I3 proxy = (I3)Proxy.newProxyInstance(loader, new Class<?>[]{I3.class}, HANDLER);\n+        Method m = I3.class.getMethod(\"m3\", String[].class);\n+        assertTrue(m.isVarArgs() && m.isDefault());\n+        assertEquals(proxy.m3(\"a\", \"b\", \"cde\"), 5);\n+        assertEquals(Proxy.invokeDefaultMethod(proxy, m, (Object)new String[] { \"a\", \"bc\" }), 3);\n+    }\n+\n+    \/*\n+     * Invoke I12::m which is an abstract method\n+     *\/\n+    @Test(expectedExceptions = {IllegalArgumentException.class})\n+    public void invokeAbstractMethod() throws Exception {\n+        ClassLoader loader = DefaultMethods.class.getClassLoader();\n+        I12 proxy = (I12) Proxy.newProxyInstance(loader, new Class<?>[]{I12.class}, HANDLER);\n+        Method method = I12.class.getMethod(\"m\");\n+        assertTrue(method.getDeclaringClass() == I12.class);\n+        assertFalse(method.isDefault());\n+        proxy.m();\n+    }\n+\n+    \/*\n+     * Invoke a non proxy (default) method with parameters\n+     *\/\n+    @Test(expectedExceptions = {IllegalArgumentException.class})\n+    public void invokeNonProxyMethod() throws Exception {\n+        ClassLoader loader = DefaultMethods.class.getClassLoader();\n+        I3 proxy = (I3) Proxy.newProxyInstance(loader, new Class<?>[]{I3.class}, HANDLER);\n+        Method m = I4.class.getMethod(\"mix\", int.class, String.class);\n+        assertTrue(m.isDefault());\n+        Proxy.invokeDefaultMethod(proxy, m);\n+    }\n+\n+    \/\/ negative cases\n+    @DataProvider(name = \"negativeCases\")\n+    private Object[][] negativeCases() {\n+        return new Object[][] {\n+                \/\/ I4::m overrides I1::m and I2::m\n+                new Object[] { new Class<?>[]{ I4.class },  I1.class, \"m\"},\n+                new Object[] { new Class<?>[]{ I4.class },  I2.class, \"m\"},\n+                \/\/ I12::m is not a default method\n+                new Object[] { new Class<?>[]{ I12.class }, I12.class, \"m\"},\n+                \/\/ non-proxy default method\n+                new Object[] { new Class<?>[]{ I3.class },  I1.class, \"m\"},\n+                \/\/ not a default method and not a proxy interface\n+                new Object[] { new Class<?>[]{ I12.class }, DefaultMethods.class, \"test\"},\n+                new Object[] { new Class<?>[]{ I12.class }, Runnable.class, \"run\"},\n+                \/\/ I2::privateMethod is a private method\n+                new Object[] { new Class<?>[]{ I3.class }, I2.class, \"privateMethod\"},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"negativeCases\", expectedExceptions = {IllegalArgumentException.class})\n+    public void testIllegalArgument(Class<?>[] interfaces, Class<?> defc, String name)\n+            throws Exception {\n+        ClassLoader loader = DefaultMethods.class.getClassLoader();\n+        Object proxy = Proxy.newProxyInstance(loader, interfaces, HANDLER);\n+        try {\n+            Method method = defc.getDeclaredMethod(name);\n+            Proxy.invokeDefaultMethod(proxy, method);\n+        } catch (Throwable e) {\n+            System.out.format(\"%s method %s::%s exception thrown: %s%n\",\n+                              Arrays.toString(interfaces), defc.getName(), name, e.getMessage());\n+            throw e;\n+        }\n+    }\n+\n+    @DataProvider(name = \"arguments\")\n+    private Object[][] arguments() {\n+        return new Object[][] {\n+                new Object[] {},\n+                new Object[] { 100, \"foo\", 100 },\n+                new Object[] { \"foo\", 100},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"arguments\", expectedExceptions = {IllegalArgumentException.class})\n+    public void testWrongArguments(Object... args) throws Exception {\n+        ClassLoader loader = DefaultMethods.class.getClassLoader();\n+        I4 proxy = (I4)Proxy.newProxyInstance(loader, new Class<?>[]{I4.class}, HANDLER);\n+        Method m = I4.class.getMethod(\"mix\", int.class, String.class);\n+        assertTrue(m.isDefault());\n+        Proxy.invokeDefaultMethod(proxy, m, args);\n+    }\n+\n+    @Test(expectedExceptions = {IllegalArgumentException.class})\n+    public void testNullArguments() throws Exception {\n+        ClassLoader loader = DefaultMethods.class.getClassLoader();\n+        I4 proxy = (I4)Proxy.newProxyInstance(loader, new Class<?>[]{I4.class}, HANDLER);\n+        Method m = I4.class.getMethod(\"mix\", int.class, String.class);\n+        assertTrue(m.isDefault());\n+        Proxy.invokeDefaultMethod(proxy, m, (Object[])null);\n+    }\n+\n+    private static final InvocationHandler HANDLER = (proxy, method, params) -> {\n+        System.out.format(\"invoking %s with parameters: %s%n\", method, Arrays.toString(params));\n+        return Proxy.invokeDefaultMethod(proxy, method, params);\n+    };\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/Proxy\/DefaultMethods.java","additions":356,"deletions":0,"binary":false,"changes":356,"status":"added"},{"patch":"@@ -102,2 +102,3 @@\n-        assertFalse(proxyClass.getModule().isNamed());\n-        assertFalse(pkg.isSealed());\n+        assertTrue(proxyClass.getModule().isNamed());\n+        assertTrue(pkg.isSealed());\n+        assertTrue(proxyClass.getModule().isExported(pkg.getName()));\n@@ -135,0 +136,1 @@\n+        assertFalse(proxyClass.getModule().isExported(pkg.getName()));\n","filename":"test\/jdk\/java\/lang\/reflect\/Proxy\/ProxyLayerTest.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-        new ProxyModuleMapping(unnamed, Runnable.class).test();\n+        new ProxyModuleMapping(Runnable.class).test();\n@@ -82,1 +82,2 @@\n-            if (module.isNamed()) {\n+            \/\/ the exported package name is same as the module name\n+            if (!c.getPackageName().equals(module.getName())) {\n@@ -86,1 +87,2 @@\n-            if (!module.isNamed()) {\n+            \/\/ non-exported package from the dynamic module\n+            if (c.getPackageName().equals(module.getName())) {\n","filename":"test\/jdk\/java\/lang\/reflect\/Proxy\/ProxyModuleMapping.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -84,0 +84,16 @@\n+\n+    \/**\n+     * Tests invocation of default methods in exported and non-exported types\n+     * in a named module\n+     *\/\n+    @Test\n+    public void runDefaultMethodsTest() throws Exception {\n+        int exitValue = executeTestJava(\"-cp\", CPATH_DIR.toString(),\n+                \"--module-path\", MODS_DIR.toString(),\n+                \"-m\", \"test\/jdk.test.DefaultMethods\")\n+                .outputTo(System.out)\n+                .errorTo(System.out)\n+                .getExitValue();\n+\n+        assertTrue(exitValue == 0);\n+    }\n","filename":"test\/jdk\/java\/lang\/reflect\/Proxy\/ProxyTest.java","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -37,0 +37,4 @@\n+    public interface I {\n+        default String m() { return \"I\"; }\n+    }\n+\n@@ -42,1 +46,4 @@\n-        makeProxy(loader, fooClass);\n+        \/\/ create a proxy instance of a non-public proxy interface\n+        \/\/ also test invocation of a default method\n+        makeProxy(loader, fooClass).testDefaultMethod(\"foo\");\n+        makeProxy(loader, barClass, fooClass).testDefaultMethod(\"bar\");\n@@ -44,0 +51,2 @@\n+        \/\/ verify security permission check\n+        Policy.setPolicy(new SimplePolicy());\n@@ -45,0 +54,2 @@\n+        \/\/ create a proxy instance of a public proxy interface should succeed\n+        makeProxy(loader, I.class).testDefaultMethod(\"I\");\n@@ -46,0 +57,1 @@\n+            \/\/ fail to create a proxy instance of a non-public proxy interface\n@@ -56,3 +68,2 @@\n-    private static void makeProxy(ClassLoader loader, Class<?> cls) {\n-        Class<?>[] intfs = new Class<?>[] { cls };\n-        Proxy.newProxyInstance(loader, intfs, new InvocationHandler() {\n+    private static SimpleProxy makeProxy(ClassLoader loader, Class<?>... intfs) {\n+        Object proxy = Proxy.newProxyInstance(loader, intfs, new InvocationHandler() {\n@@ -64,0 +75,3 @@\n+                if (method.getName().equals(\"m\")) {\n+                    return Proxy.invokeDefaultMethod(proxy, method, args);\n+                }\n@@ -67,0 +81,39 @@\n+        return new SimpleProxy(proxy);\n+    }\n+\n+    final Object proxy;\n+    SimpleProxy(Object proxy) {\n+        this.proxy = proxy;\n+    }\n+\n+    \/*\n+     * Verify if a default method \"m\" can be invoked successfully\n+     *\/\n+    void testDefaultMethod(String expected) throws ReflectiveOperationException {\n+        Method m = proxy.getClass().getDeclaredMethod(\"m\");\n+        m.setAccessible(true);\n+        String name = (String)m.invoke(proxy);\n+        if (!expected.equals(name)) {\n+            throw new RuntimeException(\"return value: \" + name + \" expected: \" + expected);\n+        }\n+    }\n+\n+    static class SimplePolicy extends Policy {\n+        static final Policy DEFAULT_POLICY = Policy.getPolicy();\n+        final PermissionCollection permissions = new Permissions();\n+        SimplePolicy() {\n+            permissions.add(new SecurityPermission(\"getPolicy\"));\n+            permissions.add(new ReflectPermission(\"suppressAccessChecks\"));\n+        }\n+        public PermissionCollection getPermissions(ProtectionDomain domain) {\n+            return permissions;\n+        }\n+\n+        public PermissionCollection getPermissions(CodeSource codesource) {\n+            return permissions;\n+        }\n+\n+        public boolean implies(ProtectionDomain domain, Permission perm) {\n+            return permissions.implies(perm) ||\n+                    DEFAULT_POLICY.implies(domain, perm);\n+        }\n","filename":"test\/jdk\/java\/lang\/reflect\/Proxy\/nonPublicProxy\/SimpleProxy.java","additions":57,"deletions":4,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+    default String m() { return \"bar\"; }\n","filename":"test\/jdk\/java\/lang\/reflect\/Proxy\/nonPublicProxy\/p\/Bar.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+    default String m() { return \"foo\"; }\n","filename":"test\/jdk\/java\/lang\/reflect\/Proxy\/nonPublicProxy\/p\/Foo.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+\n+    default int m() { return 1; }\n","filename":"test\/jdk\/java\/lang\/reflect\/Proxy\/src\/m1\/p\/one\/I.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+    default int m() { return 2; }\n","filename":"test\/jdk\/java\/lang\/reflect\/Proxy\/src\/m2\/p\/two\/internal\/C.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -69,1 +69,0 @@\n-        Module unnamed = ld.getUnnamedModule();\n@@ -71,1 +70,0 @@\n-        Module unnamed2 = ld2.getUnnamedModule();\n@@ -74,11 +72,11 @@\n-            new Data(unnamed,  ld, Runnable.class),\n-            new Data(unnamed,  ld, p.one.I.class),\n-            new Data(unnamed,  ld, p.one.I.class, p.two.A.class),\n-            new Data(unnamed,  ld, p.one.I.class, unnamedModuleClass),\n-            new Data(unnamed2, ld2, Runnable.class),\n-            new Data(unnamed2, ld2, p.one.I.class),\n-            new Data(unnamed2, ld2, p.one.I.class, p.two.A.class),\n-            new Data(unnamed2, ld2, p.one.I.class, unnamedModuleClass),\n-            new Data(unnamed, m1.getClassLoader(), p.one.I.class),\n-            new Data(unnamed, m2.getClassLoader(), p.two.A.class),\n-            new Data(unnamed, m3.getClassLoader(), p.three.P.class),\n+            new Data(ld, Runnable.class),\n+            new Data(ld, p.one.I.class),\n+            new Data(ld, p.one.I.class, p.two.A.class),\n+            new Data(ld, p.one.I.class, unnamedModuleClass),\n+            new Data(ld2, Runnable.class),\n+            new Data(ld2, p.one.I.class),\n+            new Data(ld2, p.one.I.class, p.two.A.class),\n+            new Data(ld2, p.one.I.class, unnamedModuleClass),\n+            new Data(m1.getClassLoader(), p.one.I.class),\n+            new Data(m2.getClassLoader(), p.two.A.class),\n+            new Data(m3.getClassLoader(), p.three.P.class),\n","filename":"test\/jdk\/java\/lang\/reflect\/Proxy\/src\/test\/jdk\/test\/Main.java","additions":11,"deletions":13,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -99,1 +99,4 @@\n-            throw new RuntimeException(\"Expected IllegalAccessException: \" + proxyClass);\n+            \/\/ the exported package has the same name as the dynamic module\n+            if (!proxyClass.getPackageName().equals(m.getName())) {\n+                throw new RuntimeException(\"Expected IllegalAccessException: \" + proxyClass);\n+            }\n","filename":"test\/jdk\/java\/lang\/reflect\/Proxy\/src\/test\/jdk\/test\/ProxyTest.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -34,0 +34,2 @@\n+\n+    default int m() { return 10; }\n","filename":"test\/jdk\/java\/lang\/reflect\/Proxy\/src\/test\/jdk\/test\/internal\/R.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -230,1 +230,1 @@\n-                        new StackTraceElement(\"com.sun.proxy.$Proxy0\", \"hashCode\", null, -1),\n+                        new StackTraceElement(\"jdk.proxy1.$Proxy0\", \"hashCode\", null, -1),\n","filename":"test\/langtools\/jdk\/jshell\/ExceptionsTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}