{"files":[{"patch":"@@ -32,3 +32,0 @@\n-import java.lang.invoke.MethodHandles;\n-import java.lang.invoke.MethodType;\n-import java.lang.invoke.WrongMethodTypeException;\n@@ -36,4 +33,0 @@\n-import java.util.concurrent.ConcurrentHashMap;\n-import java.util.function.BooleanSupplier;\n-\n-import static java.lang.invoke.MethodType.methodType;\n@@ -120,1 +113,1 @@\n-     * For example, interface {@code A} and {@code B} both declare a default\n+     * Examples: interface {@code A} and {@code B} both declare a default\n@@ -122,1 +115,1 @@\n-     * and it inherits the default method {@code m} from its superinterface {@code A}.\n+     * and inherits the default method {@code m} from its superinterface {@code A}.\n@@ -140,2 +133,4 @@\n-     *             assert m.getDeclaringClass() == A.class && m.isDefault();\n-     *             return InvocationHandler.invokeDefaultMethod(o, m, params);\n+     *             if (m.isDefault()) {\n+     *                 \/\/ if it's a default method, invoke it\n+     *                 return InvocationHandler.invokeDefault(o, m, params);\n+     *             }\n@@ -148,1 +143,1 @@\n-     * {@code A::m} or {@code B::m} via the {@code invokeDefaultMethod} method.\n+     * {@code A::m} or {@code B::m} via the {@code invokeDefault} method.\n@@ -155,3 +150,5 @@\n-     *             \/\/ delegate to invoking B::m\n-     *             Method selectedMethod = B.class.getMethod(m.getName(), m.getParameterTypes());\n-     *             return InvocationHandler.invokeDefaultMethod(o, selectedMethod, params);\n+     *             if (m.getName().equals(\"m\")) {\n+     *                 \/\/ invoke B::m instead of A::m\n+     *                 Method bMethod = B.class.getMethod(m.getName(), m.getParameterTypes());\n+     *                 return InvocationHandler.invokeDefault(o, bMethod, params);\n+     *             }\n@@ -169,1 +166,1 @@\n-     * Object c = Proxy.newProxyInstance(loader, new Class<?>[] { C.class },\n+     * Object proxy = Proxy.newProxyInstance(loader, new Class<?>[] { C.class },\n@@ -171,2 +168,4 @@\n-     *             assert m.isDefault();\n-     *             return InvocationHandler.invokeDefaultMethod(o, m, params);\n+     *             if (m.isDefault()) {\n+     *                 \/\/ behaves as if calling C.super.m(params)\n+     *                 return InvocationHandler.invokeDefault(o, m, params);\n+     *             }\n@@ -176,2 +175,2 @@\n-     * The invocation of method {@code \"m\"} on {@code c} will behave as if\n-     * {@code C.super::m} is called and that is resolved to invoking\n+     * The invocation of method {@code \"m\"} on this {@code proxy} will behave\n+     * as if {@code C.super::m} is called and that is resolved to invoking\n@@ -180,1 +179,6 @@\n-     * If {@code C} is modified to override {@code m} as below:\n+     * Adding a default method, or changing a method from abstract to default\n+     * may cause an exception if an existing code attempts to call {@code invokeDefault}\n+     * to invoke a default method.\n+     *\n+     * For example, if {@code C} is modified to implement a default method\n+     * {@code m}:\n@@ -188,3 +192,3 @@\n-     * {@code C.super::m} will be resolved to {@code C::m} instead.\n-     * The invocation of method {@code \"m\"} on {@code c} will behave\n-     * differently and result in invoking {@code C::m} instead of {@code A::m}.\n+     * The code above that creates proxy instance {@code proxy} with\n+     * the modified {@code C} will run with no exception and it will result in\n+     * calling {@code C::m} instead of {@code A::m}.\n@@ -192,3 +196,3 @@\n-     * If an invocation handler dispatches the method invocation by calling\n-     * the {@code invokeDefaultMethod} method with the {@code Method} object\n-     * representing {@code A::m}:\n+     * The following is another example that creates a proxy instance of {@code C}\n+     * and the invocation handler calls the {@code invokeDefault} method\n+     * to invoke {@code A::m}:\n@@ -197,1 +201,1 @@\n-     * Object proxy = Proxy.newProxyInstance(loader, new Class<?>[] { C.class },\n+     * C c = (C) Proxy.newProxyInstance(loader, new Class<?>[] { C.class },\n@@ -199,3 +203,6 @@\n-     *             \/\/ IllegalArgumentException thrown as {@code A::m} is not a method\n-     *             \/\/ inherited from its proxy interface C\n-     *             return InvocationHandler.invokeDefaultMethod(o, A.class.getMethod(\"m\"), params);\n+     *             if (m.getName().equals(\"m\")) {\n+     *                 \/\/ IllegalArgumentException thrown as {@code A::m} is not a method\n+     *                 \/\/ inherited from its proxy interface C\n+     *                 Method aMethod = A.class.getMethod(m.getName(), m.getParameterTypes());\n+     *                 return InvocationHandler.invokeDefault(o, aMethod params);\n+     *             }\n@@ -203,0 +210,1 @@\n+     * c.m(...);\n@@ -205,3 +213,11 @@\n-     * The invocation on {@code \"m\"} with this proxy instance will result in\n-     * an {@code IllegalArgumentException} because {@code C} overrides the implementation\n-     * of the same method and {@code A::m} is not accessible by a proxy instance.\n+     * The above code runs successfully with the old version of {@code C} and\n+     * {@code A::m} is invoked.  When running with the new version of {@code C},\n+     * the above code will fail with {@code IllegalArgumentException} because\n+     * {@code C} overrides the implementation of the same method and\n+     * {@code A::m} is not accessible by a proxy instance.\n+     *\n+     * @apiNote\n+     * The {@code proxy} parameter is of type {@code Object} rather than {@code Proxy}\n+     * to make it easy for {@link InvocationHandler#invoke(Object, Method, Object[])\n+     * InvocationHandler::invoke} implementation to call directly without the need\n+     * of casting.\n@@ -237,3 +253,0 @@\n-     * @throws InvocationTargetException if the invoked default method throws\n-     *         any exception, it is wrapped by {@code InvocationTargetException}\n-     *         and rethrown\n@@ -241,1 +254,2 @@\n-     *\n+     * @throws Throwable anything thrown by the default method\n+\n@@ -246,2 +260,2 @@\n-    public static Object invokeDefaultMethod(Object proxy, Method method, Object... args)\n-            throws IllegalAccessException, InvocationTargetException {\n+    public static Object invokeDefault(Object proxy, Method method, Object... args)\n+            throws Throwable {\n@@ -270,47 +284,1 @@\n-        \/\/ lookup the cached method handle\n-        ConcurrentHashMap<Method, MethodHandle> methods = Proxy.defaultMethodMap(proxyClass);\n-        MethodHandle superMH = methods.get(method);\n-\n-        if (superMH == null) {\n-            MethodType type = methodType(method.getReturnType(), method.getParameterTypes());\n-            MethodHandles.Lookup lookup = MethodHandles.lookup();\n-            Class<?> proxyInterface = Proxy.findProxyInterfaceOrElseThrow(proxyClass, method);\n-            MethodHandle dmh;\n-            try {\n-                dmh = Proxy.proxyClassLookup(lookup, proxyClass)\n-                           .findSpecial(proxyInterface, method.getName(), type, proxyClass)\n-                           .withVarargs(false);\n-            } catch (IllegalAccessException | NoSuchMethodException e) {\n-                \/\/ should not reach here\n-                throw new InternalError(e);\n-            }\n-            \/\/ this check can be turned into assertion as it is guaranteed to succeed by the virtue of\n-            \/\/ looking up a default (instance) method declared or inherited by proxyInterface\n-            \/\/ while proxyClass implements (is a subtype of) proxyInterface ...\n-            assert ((BooleanSupplier) () -> {\n-                try {\n-                    \/\/ make sure that the method type matches\n-                    dmh.asType(type.insertParameterTypes(0, proxyClass));\n-                    return true;\n-                } catch (WrongMethodTypeException e) {\n-                    return false;\n-                }\n-            }).getAsBoolean() : \"Wrong method type\";\n-            \/\/ change return type to Object\n-            MethodHandle mh = dmh.asType(dmh.type().changeReturnType(Object.class));\n-            \/\/ wrap any exception thrown with InvocationTargetException\n-            mh = MethodHandles.catchException(mh, Throwable.class, Proxy.wrapWithInvocationTargetExceptionMH());\n-            \/\/ spread array of arguments among parameters (skipping 1st parameter - target)\n-            mh = mh.asSpreader(1, Object[].class, type.parameterCount());\n-            \/\/ change target type to Object\n-            mh = mh.asType(MethodType.methodType(Object.class, Object.class, Object[].class));\n-\n-            \/\/ push MH into cache\n-            MethodHandle cached = methods.putIfAbsent(method, mh);\n-            if (cached != null) {\n-                superMH = cached;\n-            } else {\n-                superMH = mh;\n-            }\n-        }\n-\n+        MethodHandle mh = Proxy.defaultMethodHandle(proxyClass, method);\n@@ -322,1 +290,1 @@\n-            return superMH.invokeExact(proxy, params);\n+            return mh.invokeExact(proxy, params);\n@@ -325,5 +293,3 @@\n-        } catch (InvocationTargetException | RuntimeException | Error e) {\n-            throw e;\n-        } catch (Throwable e) {\n-            \/\/ should not reach here\n-            throw new InternalError(e);\n+        } catch (Proxy.InvocationException e) {\n+            \/\/ unwrap and throw the exception thrown by the default method\n+            throw e.getCause();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/InvocationHandler.java","additions":59,"deletions":93,"binary":false,"changes":152,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import java.lang.invoke.MethodHandles.Lookup;\n@@ -32,0 +31,1 @@\n+import java.lang.invoke.WrongMethodTypeException;\n@@ -49,0 +49,1 @@\n+import java.util.function.BooleanSupplier;\n@@ -62,0 +63,1 @@\n+import static java.lang.invoke.MethodType.methodType;\n@@ -155,2 +157,2 @@\n- * by calling {@link InvocationHandler#invokeDefaultMethod(Object, Method, Object...)\n- * InvocationHandler::invokeDefaultMethod}.\n+ * by calling {@link InvocationHandler#invokeDefault(Object, Method, Object...)\n+ * InvocationHandler::invokeDefault}.\n@@ -1156,1 +1158,1 @@\n-    static ConcurrentHashMap<Method, MethodHandle> defaultMethodMap(Class<?> proxyClass) {\n+    private static ConcurrentHashMap<Method, MethodHandle> defaultMethodMap(Class<?> proxyClass) {\n@@ -1163,0 +1165,49 @@\n+    static MethodHandle defaultMethodHandle(Class<?> proxyClass, Method method) {\n+        \/\/ lookup the cached method handle\n+        ConcurrentHashMap<Method, MethodHandle> methods = defaultMethodMap(proxyClass);\n+        MethodHandle superMH = methods.get(method);\n+        if (superMH == null) {\n+            MethodType type = methodType(method.getReturnType(), method.getParameterTypes());\n+            MethodHandles.Lookup lookup = MethodHandles.lookup();\n+            Class<?> proxyInterface = findProxyInterfaceOrElseThrow(proxyClass, method);\n+            MethodHandle dmh;\n+            try {\n+                dmh = proxyClassLookup(lookup, proxyClass)\n+                        .findSpecial(proxyInterface, method.getName(), type, proxyClass)\n+                        .withVarargs(false);\n+            } catch (IllegalAccessException | NoSuchMethodException e) {\n+                \/\/ should not reach here\n+                throw new InternalError(e);\n+            }\n+            \/\/ this check can be turned into assertion as it is guaranteed to succeed by the virtue of\n+            \/\/ looking up a default (instance) method declared or inherited by proxyInterface\n+            \/\/ while proxyClass implements (is a subtype of) proxyInterface ...\n+            assert ((BooleanSupplier) () -> {\n+                try {\n+                    \/\/ make sure that the method type matches\n+                    dmh.asType(type.insertParameterTypes(0, proxyClass));\n+                    return true;\n+                } catch (WrongMethodTypeException e) {\n+                    return false;\n+                }\n+            }).getAsBoolean() : \"Wrong method type\";\n+            \/\/ change return type to Object\n+            MethodHandle mh = dmh.asType(dmh.type().changeReturnType(Object.class));\n+            \/\/ wrap any exception thrown with InvocationTargetException\n+            mh = MethodHandles.catchException(mh, Throwable.class, InvocationException.wrapMH());\n+            \/\/ spread array of arguments among parameters (skipping 1st parameter - target)\n+            mh = mh.asSpreader(1, Object[].class, type.parameterCount());\n+            \/\/ change target type to Object\n+            mh = mh.asType(MethodType.methodType(Object.class, Object.class, Object[].class));\n+\n+            \/\/ push MH into cache\n+            MethodHandle cached = methods.putIfAbsent(method, mh);\n+            if (cached != null) {\n+                superMH = cached;\n+            } else {\n+                superMH = mh;\n+            }\n+        }\n+        return superMH;\n+    }\n+\n@@ -1169,1 +1220,1 @@\n-    static Class<?> findProxyInterfaceOrElseThrow(Class<?> proxyClass, Method method) {\n+    private static Class<?> findProxyInterfaceOrElseThrow(Class<?> proxyClass, Method method) {\n@@ -1234,1 +1285,1 @@\n-    static Lookup proxyClassLookup(Lookup caller, Class<?> proxyClass) {\n+    private static MethodHandles.Lookup proxyClassLookup(MethodHandles.Lookup caller, Class<?> proxyClass) {\n@@ -1237,1 +1288,1 @@\n-            public Lookup run() {\n+            public MethodHandles.Lookup run() {\n@@ -1239,1 +1290,1 @@\n-                    Method m = proxyClass.getDeclaredMethod(\"proxyClassLookup\", Lookup.class);\n+                    Method m = proxyClass.getDeclaredMethod(\"proxyClassLookup\", MethodHandles.Lookup.class);\n@@ -1241,1 +1292,1 @@\n-                    return (Lookup) m.invoke(null, caller);\n+                    return (MethodHandles.Lookup) m.invoke(null, caller);\n@@ -1249,0 +1300,1 @@\n+\n@@ -1250,3 +1302,3 @@\n-     * Wraps given cause with InvocationTargetException and throws it.\n-     *\n-     * @throws InvocationTargetException wrapping given cause\n+     * Internal exception type to wrap the exception thrown by the default method\n+     * so that it can distinguish CCE and NPE thrown due to the arguments\n+     * incompatible with the method signature.\n@@ -1254,3 +1306,3 @@\n-    private static Object wrapWithInvocationTargetException(Throwable cause) throws InvocationTargetException {\n-        throw new InvocationTargetException(cause, cause.toString());\n-    }\n+    static class InvocationException extends ReflectiveOperationException {\n+        @java.io.Serial\n+        private static final long serialVersionUID = 0L;\n@@ -1258,2 +1310,3 @@\n-    @Stable\n-    private static MethodHandle wrapWithInvocationTargetExceptionMH;\n+        InvocationException(Throwable cause) {\n+            super(cause);\n+        }\n@@ -1261,11 +1314,22 @@\n-    static MethodHandle wrapWithInvocationTargetExceptionMH() {\n-        MethodHandle mh = wrapWithInvocationTargetExceptionMH;\n-        if (mh == null) {\n-            try {\n-                wrapWithInvocationTargetExceptionMH = mh = MethodHandles.lookup().findStatic(\n-                    Proxy.class,\n-                    \"wrapWithInvocationTargetException\",\n-                    MethodType.methodType(Object.class, Throwable.class)\n-                );\n-            } catch (NoSuchMethodException | IllegalAccessException e) {\n-                throw new InternalError(e);\n+        \/**\n+         * Wraps given cause with InvocationException and throws it.\n+         *\/\n+        static Object wrap(Throwable cause) throws InvocationException {\n+            throw new InvocationException(cause);\n+        }\n+\n+        @Stable\n+        static MethodHandle wrapMethodHandle;\n+\n+        static MethodHandle wrapMH() {\n+            MethodHandle mh = wrapMethodHandle;\n+            if (mh == null) {\n+                try {\n+                    wrapMethodHandle = mh = MethodHandles.lookup().findStatic(\n+                            InvocationException.class,\n+                            \"wrap\",\n+                            MethodType.methodType(Object.class, Throwable.class)\n+                    );\n+                } catch (NoSuchMethodException | IllegalAccessException e) {\n+                    throw new InternalError(e);\n+                }\n@@ -1273,0 +1337,1 @@\n+            return mh;\n@@ -1274,1 +1339,0 @@\n-        return mh;\n@@ -1276,0 +1340,1 @@\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Proxy.java","additions":94,"deletions":29,"binary":false,"changes":123,"status":"modified"},{"patch":"@@ -636,1 +636,1 @@\n-     * on this proxy class if the caller's lookup class is java.lang.reflect.InvocationHandler;\n+     * on this proxy class if the caller's lookup class is java.lang.reflect.Proxy;\n@@ -649,1 +649,1 @@\n-        mv.visitLdcInsn(Type.getType(InvocationHandler.class));\n+        mv.visitLdcInsn(Type.getType(Proxy.class));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/ProxyGenerator.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -115,1 +115,1 @@\n-                    return InvocationHandler.invokeDefaultMethod(o, findDefaultMethod(I2.class, method), params);\n+                    return InvocationHandler.invokeDefault(o, findDefaultMethod(I2.class, method), params);\n@@ -137,1 +137,1 @@\n-    public void testDefaultMethod(Class<?>[] intfs, boolean isDefault, int expected) throws Exception {\n+    public void testDefaultMethod(Class<?>[] intfs, boolean isDefault, int expected) throws Throwable {\n@@ -147,1 +147,1 @@\n-                        return InvocationHandler.invokeDefaultMethod(proxy, method, params);\n+                        return InvocationHandler.invokeDefault(proxy, method, params);\n@@ -192,1 +192,1 @@\n-    public void testSuper(Class<?>[] intfs, Class<?> proxyInterface, int expected) throws Exception {\n+    public void testSuper(Class<?>[] intfs, Class<?> proxyInterface, int expected) throws Throwable {\n@@ -197,1 +197,1 @@\n-                    return InvocationHandler.invokeDefaultMethod(proxy, findDefaultMethod(proxyInterface, method), params);\n+                    return InvocationHandler.invokeDefault(proxy, findDefaultMethod(proxyInterface, method), params);\n@@ -220,1 +220,1 @@\n-        assertEquals(InvocationHandler.invokeDefaultMethod(proxy, proxyInterface.getMethod(\"m\")), expected);\n+        assertEquals(InvocationHandler.invokeDefault(proxy, proxyInterface.getMethod(\"m\")), expected);\n@@ -225,1 +225,1 @@\n-    public void testI12() throws Exception {\n+    public void testI12() throws Throwable {\n@@ -232,1 +232,1 @@\n-                    return InvocationHandler.invokeDefaultMethod(proxy, method, params);\n+                    return InvocationHandler.invokeDefault(proxy, method, params);\n@@ -243,1 +243,1 @@\n-        assertEquals(InvocationHandler.invokeDefaultMethod(i12, m, 100, new Object[] {\"foo\", true, \"bar\"}),\n+        assertEquals(InvocationHandler.invokeDefault(i12, m, 100, new Object[] {\"foo\", true, \"bar\"}),\n@@ -249,1 +249,1 @@\n-    public void testEmptyArgument() throws Exception {\n+    public void testEmptyArgument() throws Throwable {\n@@ -255,2 +255,2 @@\n-        InvocationHandler.invokeDefaultMethod(proxy, m1);\n-        InvocationHandler.invokeDefaultMethod(proxy, m1, new Object[0]);\n+        InvocationHandler.invokeDefault(proxy, m1);\n+        InvocationHandler.invokeDefault(proxy, m1, new Object[0]);\n@@ -261,1 +261,1 @@\n-        InvocationHandler.invokeDefaultMethod(proxy, m2, Integer.valueOf(100), \"foo\");\n+        InvocationHandler.invokeDefault(proxy, m2, Integer.valueOf(100), \"foo\");\n@@ -265,1 +265,1 @@\n-    public void testVarArgs() throws Exception {\n+    public void testVarArgs() throws Throwable {\n@@ -271,1 +271,1 @@\n-        assertEquals(InvocationHandler.invokeDefaultMethod(proxy, m, (Object)new String[] { \"a\", \"bc\" }), 3);\n+        assertEquals(InvocationHandler.invokeDefault(proxy, m, (Object)new String[] { \"a\", \"bc\" }), 3);\n@@ -291,1 +291,1 @@\n-    public void invokeNonProxyMethod() throws Exception {\n+    public void invokeNonProxyMethod() throws Throwable {\n@@ -296,1 +296,1 @@\n-        InvocationHandler.invokeDefaultMethod(proxy, m);\n+        InvocationHandler.invokeDefault(proxy, m);\n@@ -320,1 +320,1 @@\n-            throws Exception {\n+            throws Throwable {\n@@ -325,1 +325,1 @@\n-            InvocationHandler.invokeDefaultMethod(proxy, method);\n+            InvocationHandler.invokeDefault(proxy, method);\n@@ -346,1 +346,1 @@\n-    public void testIllegalArgument(Object... args) throws Exception {\n+    public void testIllegalArgument(Object... args) throws Throwable {\n@@ -355,1 +355,1 @@\n-        InvocationHandler.invokeDefaultMethod(proxy, m, args);\n+        InvocationHandler.invokeDefault(proxy, m, args);\n@@ -358,2 +358,2 @@\n-    @DataProvider(name = \"invocationTargetExceptions\")\n-    private Object[][] invocationTargetExceptions() {\n+    @DataProvider(name = \"throwables\")\n+    private Object[][] throwables() {\n@@ -370,2 +370,2 @@\n-    @Test(dataProvider = \"invocationTargetExceptions\")\n-    public void testInvocationTargetException(Throwable exception) throws Exception {\n+    @Test(dataProvider = \"throwables\")\n+    public void testInvocationException(Throwable exception) throws Throwable {\n@@ -376,3 +376,3 @@\n-            InvocationHandler.invokeDefaultMethod(proxy, m, exception);\n-        } catch (InvocationTargetException e) {\n-            assertEquals(e.getCause(), exception);\n+            InvocationHandler.invokeDefault(proxy, m, exception);\n+        } catch (Throwable e) {\n+            assertEquals(e, exception);\n@@ -384,1 +384,1 @@\n-        return InvocationHandler.invokeDefaultMethod(proxy, method, params);\n+        return InvocationHandler.invokeDefault(proxy, method, params);\n","filename":"test\/jdk\/java\/lang\/reflect\/Proxy\/DefaultMethods.java","additions":29,"deletions":29,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -90,1 +90,1 @@\n-    public void testNoReadAccess() throws Exception {\n+    public void testNoReadAccess() throws Throwable {\n@@ -107,1 +107,1 @@\n-    private void checkIAE(ClassLoader loader, Class<?>[] interfaces) {\n+    private void checkIAE(ClassLoader loader, Class<?>[] interfaces)  throws Throwable {\n","filename":"test\/jdk\/java\/lang\/reflect\/Proxy\/ProxyClassAccessTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import static org.testng.Assert.*;\n@@ -111,1 +110,1 @@\n-                InvocationHandler.invokeDefaultMethod(proxy, method, params);\n+                InvocationHandler.invokeDefault(proxy, method, params);\n","filename":"test\/jdk\/java\/lang\/reflect\/Proxy\/nonPublicProxy\/DefaultMethodProxy.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -29,2 +29,2 @@\n-            throws IllegalAccessException, InvocationTargetException {\n-         return InvocationHandler.invokeDefaultMethod(proxy, method, args);\n+            throws Throwable {\n+         return InvocationHandler.invokeDefault(proxy, method, args);\n","filename":"test\/jdk\/java\/lang\/reflect\/Proxy\/nonPublicProxy\/p\/DefaultMethodInvoker.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-        return InvocationHandler.invokeDefaultMethod(proxy, method, params);\n+        return InvocationHandler.invokeDefault(proxy, method, params);\n@@ -42,1 +42,1 @@\n-    public static void main(String... args) throws Exception {\n+    public static void main(String... args) throws Throwable {\n@@ -72,1 +72,1 @@\n-    static void inaccessibleDefaultMethod(Class<?> intf) throws Exception {\n+    static void inaccessibleDefaultMethod(Class<?> intf) throws Throwable {\n@@ -79,1 +79,1 @@\n-            InvocationHandler.invokeDefaultMethod(proxy, m, null);\n+            InvocationHandler.invokeDefault(proxy, m, null);\n","filename":"test\/jdk\/java\/lang\/reflect\/Proxy\/src\/test\/jdk\/test\/DefaultMethods.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -27,0 +27,12 @@\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Level;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n@@ -28,0 +40,1 @@\n+import java.lang.reflect.Method;\n@@ -29,1 +42,1 @@\n-import java.util.concurrent.Callable;\n+import java.util.concurrent.ThreadLocalRandom;\n@@ -32,3 +45,0 @@\n-@Warmup(iterations = 5)\n-@Measurement(iterations = 10)\n-@Fork(value = 1)\n@@ -36,0 +46,1 @@\n+@Fork(1)\n@@ -37,1 +48,3 @@\n-@State(Scope.Thread)\n+@Warmup(iterations = 5, time = 1)\n+@Measurement(iterations = 5, time = 2)\n+@State(Scope.Benchmark)\n@@ -39,0 +52,3 @@\n+    Interfaze implClass, implProxy;\n+    PpInterfaze ppImplClass, ppImplProxy;\n+    int a, b, c;\n@@ -40,17 +56,14 @@\n-    \/**\n-     * On Dell T7610:\n-     *\n-     * Benchmark w\/ the old ProxyGenerator\n-     * Benchmark                      Mode  Cnt   Score   Error  Units\n-     * ProxyBench.getProxyClass1i     avgt   10  20.472 +\/- 0.209  ns\/op\n-     * ProxyBench.getProxyClass4i     avgt   10  57.353 +\/- 0.461  ns\/op\n-     * ProxyBench.newProxyInstance1i  avgt   10  31.459 +\/- 0.516  ns\/op\n-     * ProxyBench.newProxyInstance4i  avgt   10  66.580 +\/- 0.983  ns\/op\n-     *\n-     * Benchmark w\/ the new ProxyGenerator using ASM\n-     * Benchmark                      Mode  Cnt   Score   Error  Units\n-     * ProxyBench.getProxyClass1i     avgt   10  21.291 +\/- 0.475  ns\/op\n-     * ProxyBench.getProxyClass4i     avgt   10  61.481 +\/- 4.709  ns\/op\n-     * ProxyBench.newProxyInstance1i  avgt   10  30.177 +\/- 0.761  ns\/op\n-     * ProxyBench.newProxyInstance4i  avgt   10  68.302 +\/- 1.344  ns\/op\n-     *\/\n+    @Setup(Level.Trial)\n+    public void setup() {\n+        implClass = new Clazz();\n+        implProxy = (Interfaze) Proxy.newProxyInstance(\n+                Interfaze.class.getClassLoader(),\n+                new Class<?>[]{Interfaze.class},\n+                new IHandler()\n+        );\n+        ppImplClass = new PpClazz();\n+        ppImplProxy = (PpInterfaze) Proxy.newProxyInstance(\n+                PpInterfaze.class.getClassLoader(),\n+                new Class<?>[]{PpInterfaze.class},\n+                new IHandler()\n+        );\n@@ -58,2 +71,4 @@\n-    interface PkgPrivate1 {\n-        void m1();\n+        ThreadLocalRandom tlr = ThreadLocalRandom.current();\n+        a = tlr.nextInt();\n+        b = tlr.nextInt();\n+        c = tlr.nextInt();\n@@ -62,2 +77,3 @@\n-    interface PkgPrivate2 {\n-        void m2();\n+    @Benchmark\n+    public int implClass() {\n+        return implClass.sum(a, b, c);\n@@ -66,9 +82,0 @@\n-    static final InvocationHandler handler = (proxy, method, args) -> null;\n-\n-    static final ClassLoader loader1 = null;\n-    static final Class<?>[] interfaces1 = {Runnable.class};\n-\n-    static final ClassLoader loader4 = PkgPrivate1.class.getClassLoader();\n-    static final Class<?>[] interfaces4 = {Runnable.class, Callable.class,\n-                                           PkgPrivate1.class, PkgPrivate2.class};\n-\n@@ -76,3 +83,2 @@\n-    @SuppressWarnings(\"deprecation\")\n-    public Class<?> getProxyClass1i() {\n-        return Proxy.getProxyClass(loader1, interfaces1);\n+    public int implProxy() {\n+        return implProxy.sum(a, b, c);\n@@ -82,3 +88,2 @@\n-    @SuppressWarnings(\"deprecation\")\n-    public Class<?> getProxyClass4i() {\n-        return Proxy.getProxyClass(loader4, interfaces4);\n+    public int ppImplClass() {\n+        return ppImplClass.sum(a, b, c);\n@@ -88,2 +93,2 @@\n-    public Object newProxyInstance1i() {\n-        return Proxy.newProxyInstance(loader1, interfaces1, handler);\n+    public int ppImplProxy() {\n+        return ppImplProxy.sum(a, b, c);\n@@ -92,3 +97,31 @@\n-    @Benchmark\n-    public Object newProxyInstance4i() {\n-        return Proxy.newProxyInstance(loader4, interfaces4, handler);\n+    public interface Interfaze {\n+        default int sum(int a, int b, int c) {\n+            return a + b + c;\n+        }\n+    }\n+\n+    static class Clazz implements Interfaze {\n+        @Override\n+        public int sum(int a, int b, int c) {\n+            return Interfaze.super.sum(a, b, c);\n+        }\n+    }\n+\n+    interface PpInterfaze {\n+        default int sum(int a, int b, int c) {\n+            return a + b + c;\n+        }\n+    }\n+\n+    static class PpClazz implements PpInterfaze {\n+        @Override\n+        public int sum(int a, int b, int c) {\n+            return PpInterfaze.super.sum(a, b, c);\n+        }\n+    }\n+\n+    static class IHandler implements InvocationHandler {\n+        @Override\n+        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n+            return InvocationHandler.invokeDefault(proxy, method, args);\n+        }\n@@ -96,1 +129,1 @@\n-}\n+}\n\\ No newline at end of file\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/reflect\/Proxy\/ProxyBench.java","additions":80,"deletions":47,"binary":false,"changes":127,"status":"modified"}]}