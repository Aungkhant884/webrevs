{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2006, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,13 @@\n+import jdk.internal.reflect.CallerSensitive;\n+import jdk.internal.reflect.Reflection;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.lang.invoke.WrongMethodTypeException;\n+import java.util.Objects;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.BooleanSupplier;\n+\n+import static java.lang.invoke.MethodType.methodType;\n+\n@@ -95,0 +108,224 @@\n+\n+    \/**\n+     * Invokes the specified default method on the given {@code proxy} instance with\n+     * the given parameters.  The given {@code method} must be a default method\n+     * declared in a proxy interface of the {@code proxy}'s class or inherited\n+     * from its superinterface directly or indirectly.\n+     * <p>\n+     * This method behaves as if called from an {@code invokespecial} instruction\n+     * from the proxy class as the caller equivalent to the invocation of\n+     * {@code X.super.m(A* a)} where {@code X} is a proxy interface and\n+     * the call to {@code X.super::m(A*)} is resolved to the given {@code method}.\n+     * <p>\n+     * For example, interface {@code A} and {@code B} both declare a default\n+     * implementation of method {@code m}. Interface {@code C} extends {@code A}\n+     * and it inherits the default method {@code m} from its superinterface {@code A}.\n+     *\n+     * <blockquote><pre>{@code\n+     * interface A {\n+     *     default T m(A a) { return t1; }\n+     * }\n+     * interface B {\n+     *     default T m(A a) { return t2; }\n+     * }\n+     * interface C extends A {}\n+     * }<\/pre><\/blockquote>\n+     *\n+     * The following creates a proxy instance that implements {@code A}\n+     * and invokes the default method {@code A::m}.\n+     *\n+     * <blockquote><pre>{@code\n+     * Object proxy = Proxy.newProxyInstance(loader, new Class<?>[] { A.class },\n+     *         (o, m, params) -> {\n+     *             assert m.getDeclaringClass() == A.class && m.isDefault();\n+     *             return InvocationHandler.invokeDefaultMethod(o, m, params);\n+     *         });\n+     * }<\/pre><\/blockquote>\n+     *\n+     * If a proxy instance implements both {@code A} and {@code B}, both\n+     * of which provides the default implementation of method {@code m},\n+     * the invocation handler can dispatch the method invocation to\n+     * {@code A::m} or {@code B::m} via the {@code invokeDefaultMethod} method.\n+     * For example, the following code delegates the method invocation\n+     * to {@code B::m}.\n+     *\n+     * <blockquote><pre>{@code\n+     * Object proxy = Proxy.newProxyInstance(loader, new Class<?>[] { A.class, B.class },\n+     *         (o, m, params) -> {\n+     *             \/\/ delegate to invoking B::m\n+     *             Method selectedMethod = B.class.getMethod(m.getName(), m.getParameterTypes());\n+     *             return InvocationHandler.invokeDefaultMethod(o, selectedMethod, params);\n+     *         });\n+     * }<\/pre><\/blockquote>\n+     *\n+     * If a proxy instance implements {@code C} that inherits the default\n+     * method {@code m} from its superinterface {@code A}, then\n+     * the interface method invocation on {@code \"m\"} is dispatched to\n+     * the invocation handler's {@link #invoke(Object, Method, Object[]) invoke}\n+     * method with the {@code Method} object argument representing the\n+     * default method {@code A::m}.\n+     *\n+     * <blockquote><pre>{@code\n+     * Object c = Proxy.newProxyInstance(loader, new Class<?>[] { C.class },\n+     *        (o, m, params) -> {\n+     *             assert m.isDefault();\n+     *             return InvocationHandler.invokeDefaultMethod(o, m, params);\n+     *        });\n+     * }<\/pre><\/blockquote>\n+     *\n+     * The invocation of method {@code \"m\"} on {@code c} will behave as if\n+     * {@code C.super::m} is called and that is resolved to invoking\n+     * {@code A::m}.\n+     * <p>\n+     * If {@code C} is modified to override {@code m} as below:\n+     *\n+     * <blockquote><pre>{@code\n+     * interface C extends A {\n+     *     default T m(A a) { return t3; }\n+     * }\n+     * }<\/pre><\/blockquote>\n+     *\n+     * {@code C.super::m} will be resolved to {@code C::m} instead.\n+     * The invocation of method {@code \"m\"} on {@code c} will behave\n+     * differently and result in invoking {@code C::m} instead of {@code A::m}.\n+     * <p>\n+     * If an invocation handler dispatches the method invocation by calling\n+     * the {@code invokeDefaultMethod} method with the {@code Method} object\n+     * representing {@code A::m}:\n+     *\n+     * <blockquote><pre>{@code\n+     * Object proxy = Proxy.newProxyInstance(loader, new Class<?>[] { C.class },\n+     *         (o, m, params) -> {\n+     *             \/\/ IllegalArgumentException thrown as {@code A::m} is not a method\n+     *             \/\/ inherited from its proxy interface C\n+     *             return InvocationHandler.invokeDefaultMethod(o, A.class.getMethod(\"m\"), params);\n+     *         });\n+     * }<\/pre><\/blockquote>\n+     *\n+     * The invocation on {@code \"m\"} with this proxy instance will result in\n+     * an {@code IllegalArgumentException} because {@code C} overrides the implementation\n+     * of the same method and {@code A::m} is not accessible by a proxy instance.\n+     *\n+     * @param proxy   the {@code Proxy} instance on which the default method to be invoked\n+     * @param method  the {@code Method} instance corresponding to a default method\n+     *                declared in a proxy interface of the proxy class or inherited\n+     *                from its superinterface directly or indirectly\n+     * @param args    the parameters used for the method invocation; can be {@code null}\n+     *                if the number of formal parameters required by the method is zero.\n+     * @return the value returned from the method invocation\n+     *\n+     * @throws IllegalArgumentException if any of the following conditions is {@code true}:\n+     *         <ul>\n+     *         <li>{@code proxy} is not {@linkplain Proxy#isProxyClass(Class)\n+     *             a proxy instance}; or<\/li>\n+     *         <li>the given {@code method} is not a default method declared\n+     *             in a proxy interface of the proxy class and not inherited from\n+     *             any of its superinterfaces; or<\/li>\n+     *         <li>the given {@code method} is overridden directly or indirectly by\n+     *             the proxy interfaces and the method reference to the named\n+     *             method never resolves to the given {@code method}; or<\/li>\n+     *         <li>the length of the given {@code args} array does not match the\n+     *             number of parameters of the method to be invoked; or<\/li>\n+     *         <li>any of the {@code args} elements fails the unboxing\n+     *             conversion if the corresponding method parameter type is\n+     *             a primitive type; or if, after possible unboxing, any of the\n+     *             {@code args} elements cannot be assigned to the corresponding\n+     *             method parameter type.<\/li>\n+     *         <\/ul>\n+     * @throws IllegalAccessException if the declaring class of the specified\n+     *         default method is inaccessible to the caller class\n+     * @throws InvocationTargetException if the invoked default method throws\n+     *         any exception, it is wrapped by {@code InvocationTargetException}\n+     *         and rethrown\n+     * @throws NullPointerException if {@code proxy} or {@code method} is {@code null}\n+     *\n+     * @since 16\n+     * @jvms 5.4.3. Method Resolution\n+     *\/\n+    @CallerSensitive\n+    public static Object invokeDefaultMethod(Object proxy, Method method, Object... args)\n+            throws IllegalAccessException, InvocationTargetException {\n+        Objects.requireNonNull(proxy);\n+        Objects.requireNonNull(method);\n+\n+        \/\/ verify that the object is actually a proxy instance\n+        Class<?> proxyClass = proxy.getClass();\n+        if (!Proxy.isProxyClass(proxyClass)) {\n+            throw new IllegalArgumentException(\"'proxy' is not a proxy instance\");\n+        }\n+        if (!method.isDefault()) {\n+            throw new IllegalArgumentException(\"\\\"\" + method + \"\\\" is not a default method\");\n+        }\n+        Class<?> intf = method.getDeclaringClass();\n+        \/\/ access check if it is a non-public proxy interface or not unconditionally exported\n+        if (!Modifier.isPublic(intf.getModifiers()) ||\n+                !intf.getModule().isExported(intf.getPackageName())) {\n+            \/\/ throw IAE if the caller class has no access to the default method\n+            \/\/ same access check to Method::invoke on the default method\n+            int modifiers = method.getModifiers();\n+            Class<?> caller = Reflection.getCallerClass();\n+            method.checkAccess(caller, intf, proxyClass, modifiers);\n+        }\n+\n+        \/\/ lookup the cached method handle\n+        ConcurrentHashMap<Method, MethodHandle> methods = Proxy.defaultMethodMap(proxyClass);\n+        MethodHandle superMH = methods.get(method);\n+\n+        if (superMH == null) {\n+            MethodType type = methodType(method.getReturnType(), method.getParameterTypes());\n+            MethodHandles.Lookup lookup = MethodHandles.lookup();\n+            Class<?> proxyInterface = Proxy.findProxyInterfaceOrElseThrow(proxyClass, method);\n+            MethodHandle dmh;\n+            try {\n+                dmh = Proxy.proxyClassLookup(lookup, proxyClass)\n+                           .findSpecial(proxyInterface, method.getName(), type, proxyClass)\n+                           .withVarargs(false);\n+            } catch (IllegalAccessException | NoSuchMethodException e) {\n+                \/\/ should not reach here\n+                throw new InternalError(e);\n+            }\n+            \/\/ this check can be turned into assertion as it is guaranteed to succeed by the virtue of\n+            \/\/ looking up a default (instance) method declared or inherited by proxyInterface\n+            \/\/ while proxyClass implements (is a subtype of) proxyInterface ...\n+            assert ((BooleanSupplier) () -> {\n+                try {\n+                    \/\/ make sure that the method type matches\n+                    dmh.asType(type.insertParameterTypes(0, proxyClass));\n+                    return true;\n+                } catch (WrongMethodTypeException e) {\n+                    return false;\n+                }\n+            }).getAsBoolean() : \"Wrong method type\";\n+            \/\/ change return type to Object\n+            MethodHandle mh = dmh.asType(dmh.type().changeReturnType(Object.class));\n+            \/\/ wrap any exception thrown with InvocationTargetException\n+            mh = MethodHandles.catchException(mh, Throwable.class, Proxy.wrapWithInvocationTargetExceptionMH());\n+            \/\/ spread array of arguments among parameters (skipping 1st parameter - target)\n+            mh = mh.asSpreader(1, Object[].class, type.parameterCount());\n+            \/\/ change target type to Object\n+            mh = mh.asType(MethodType.methodType(Object.class, Object.class, Object[].class));\n+\n+            \/\/ push MH into cache\n+            MethodHandle cached = methods.putIfAbsent(method, mh);\n+            if (cached != null) {\n+                superMH = cached;\n+            } else {\n+                superMH = mh;\n+            }\n+        }\n+\n+        \/\/ invoke the super method\n+        try {\n+            \/\/ the args array can be null if the number of formal parameters required by\n+            \/\/ the method is zero (consistent with Method::invoke)\n+            Object[] params = args != null ? args : Proxy.EMPTY_ARGS;\n+            return superMH.invokeExact(proxy, params);\n+        } catch (ClassCastException | NullPointerException e) {\n+            throw new IllegalArgumentException(e.getMessage(), e);\n+        } catch (InvocationTargetException | RuntimeException | Error e) {\n+            throw e;\n+        } catch (Throwable e) {\n+            \/\/ should not reach here\n+            throw new InternalError(e);\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/InvocationHandler.java","additions":238,"deletions":1,"binary":false,"changes":239,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import java.lang.invoke.WrongMethodTypeException;\n@@ -50,1 +49,0 @@\n-import java.util.function.BooleanSupplier;\n@@ -65,1 +63,0 @@\n-import static java.lang.invoke.MethodType.methodType;\n@@ -158,2 +155,2 @@\n- * by calling {@link Proxy#invokeDefaultMethod(Object, Method, Object...)\n- * Proxy::invokeDefaultMethod}.\n+ * by calling {@link InvocationHandler#invokeDefaultMethod(Object, Method, Object...)\n+ * InvocationHandler::invokeDefaultMethod}.\n@@ -1159,181 +1156,3 @@\n-    private static final Object[] EMPTY_ARGS = new Object[0];\n-\n-    \/**\n-     * Invokes the specified default method on the given {@code proxy} instance with\n-     * the given parameters.  The given {@code method} must be a default method\n-     * declared in a proxy interface of the {@code proxy}'s class or inherited\n-     * from its superinterface directly or indirectly.\n-     * <p>\n-     * This method behaves as if {@code X.super.m(A* a)} is called from the proxy\n-     * class as the caller where {@code X} is a proxy interface and\n-     * the call to {@code X.super::m(A*)} is resolved to the given {@code method}.\n-     * <p>\n-     * For example, interface {@code A} and {@code B} both declare a default\n-     * implementation of method {@code m}. Interface {@code C} extends {@code A}\n-     * and it inherits the default method {@code m} from its superinterface {@code A}.\n-     *\n-     * <blockquote><pre>{@code\n-     * interface A {\n-     *     default T m(A a) { return t1; }\n-     * }\n-     * interface B {\n-     *     default T m(A a) { return t2; }\n-     * }\n-     * interface C extends A {}\n-     * }<\/pre><\/blockquote>\n-     *\n-     * The following creates a proxy instance that implements {@code C}.\n-     * When {@code proxy::m} is invoked, the {@code method} argument passed to\n-     * {@link InvocationHandler#invoke(Object, Method, Object[]) InvocationHandler::invoke}\n-     * would be {@code A::m} as {@code C} inherits \"{@code m}\" from {@code A}.\n-     * An invocation handler can directly invoke the default method via\n-     * {@code Proxy::invokeDefaultMethod}.\n-     *\n-     * <blockquote><pre>{@code\n-     * Object proxy = Proxy.newProxyInstance(loader, new Class<?>[] { C.class },\n-     *        (o, m, params) -> {\n-     *             assert m.getDeclaringClass() == A.class && m.isDefault();\n-     *             return Proxy.invokeDefaultMethod(o, m, params);\n-     *        });\n-     * }<\/pre><\/blockquote>\n-     *\n-     * The following creates a proxy instance that implements {@code A} and {@code B}\n-     * and the invocation handler delegates the method invocation to\n-     * invoking {@code B::m} via {@code Proxy::invokeDefaultMethod}.\n-     *\n-     * <blockquote><pre>{@code\n-     * Object proxy = Proxy.newProxyInstance(loader, new Class<?>[] { A.class, B.class },\n-     *         (o, m, params) -> {\n-     *             \/\/ delegate to calling B::m\n-     *             return Proxy.invokeDefaultMethod(o, B.class.getMethod(m.getName(), m.getParameterTypes()), params);\n-     *         });\n-     * }<\/pre><\/blockquote>\n-     *\n-     * If an interface {@code D} extends {@code A} and overrides {@code m},\n-     * the proxy class implementing {@code D} can invoke {@code D::m} default method\n-     * as if calling {@code D.super::m}.  As {@code D} has the implementation of\n-     * {@code m}, invoking {@code A::m} via {@code Proxy::invokeDefaultMethod}\n-     * will result in an {@code IllegalArgumentException} because {@code A::m}\n-     * is not inherited from any proxy interface.\n-     *\n-     * <blockquote><pre>{@code\n-     * interface D extends A {\n-     *     default T m(A a) { return t3; }\n-     * }\n-     *\n-     * Object proxy = Proxy.newProxyInstance(loader, new Class<?>[] { D.class },\n-     *         (o, m, params) -> {\n-     *             \/\/ IllegalArgumentException thrown as {@code A::m} is not a method\n-     *             \/\/ inherited from its proxy interface\n-     *             return Proxy.invokeDefaultMethod(o, A.class.getMethod(\"m\"), params);\n-     *         });\n-     * }<\/pre><\/blockquote>\n-     * @param proxy   the {@code Proxy} instance on which the default method to be invoked\n-     * @param method  the {@code Method} instance corresponding to a default method\n-     *                declared in a proxy interface of the proxy class or inherited\n-     *                from its superinterface directly or indirectly\n-     * @param args    the parameters used for the method invocation; can be {@code null}\n-     *                if the number of formal parameters required by the method is zero.\n-     * @return the value returned from the method invocation\n-     *\n-     * @throws IllegalArgumentException if any of the following conditions is {@code true}:\n-     *         <ul>\n-     *         <li>{@code proxy} is not {@linkplain #isProxyClass(Class)\n-     *             a proxy instance}; or<\/li>\n-     *         <li>the given {@code method} is not a default method declared\n-     *             in a proxy interface of the proxy class and not inherited from\n-     *             any of its superinterfaces; or<\/li>\n-     *         <li>the given {@code method} is overridden directly or indirectly by\n-     *             the proxy interfaces and the method reference to the named\n-     *             method never resolves to the given {@code method}; or<\/li>\n-     *         <li>the length of the given {@code args} array does not match the\n-     *             number of parameters of the method to be invoked; or<\/li>\n-     *         <li>any of the {@code args} elements fails the unboxing\n-     *             conversion if the corresponding method parameter type is\n-     *             a primitive type; or if, after possible unboxing, any of the\n-     *             {@code args} elements cannot be assigned to the corresponding\n-     *             method parameter type.<\/li>\n-     *         <\/ul>\n-     * @throws InvocationTargetException if the invoked default method throws\n-     *         any exception, it is wrapped by {@code InvocationTargetException}\n-     *         and rethrown\n-     * @throws NullPointerException if {@code proxy} or {@code method} is {@code null}\n-     *\n-     * @since 16\n-     * @jvms 5.4.3. Method Resolution\n-     *\/\n-    public static Object invokeDefaultMethod(Object proxy, Method method, Object... args)\n-            throws InvocationTargetException {\n-        Objects.requireNonNull(proxy);\n-        Objects.requireNonNull(method);\n-\n-        \/\/ verify that the object is actually a proxy instance\n-        Class<?> proxyClass = proxy.getClass();\n-        if (!isProxyClass(proxyClass)) {\n-            throw new IllegalArgumentException(\"'proxy' is not a proxy instance\");\n-        }\n-        if (!method.isDefault()) {\n-            throw new IllegalArgumentException(\"\\\"\" + method + \"\\\" is not a default method\");\n-        }\n-\n-        \/\/ lookup the cached method handle\n-        ConcurrentHashMap<Method, MethodHandle> methods = DEFAULT_METHODS_MAP.get(proxyClass);\n-        MethodHandle superMH = methods.get(method);\n-\n-        if (superMH == null) {\n-            MethodType type = methodType(method.getReturnType(), method.getParameterTypes());\n-            MethodHandles.Lookup lookup = MethodHandles.lookup();\n-            Class<?> proxyInterface = findProxyInterfaceOrElseThrow(proxyClass, method);\n-            MethodHandle mh0;\n-            try {\n-                mh0 = ((Proxy) proxy).proxyClassLookup(lookup)\n-                                     .findSpecial(proxyInterface, method.getName(), type, proxyClass)\n-                                     .withVarargs(false);\n-            } catch (IllegalAccessException | NoSuchMethodException e) {\n-                \/\/ should not reach here\n-                throw new InternalError(e);\n-            }\n-            \/\/ this check can be turned into assertion as it is guaranteed to succeed by the virtue of\n-            \/\/ looking up a default (instance) method declared or inherited by proxyInterface\n-            \/\/ while proxyClass implements (is a subtype of) proxyInterface ...\n-            assert ((BooleanSupplier) () -> {\n-                try {\n-                    \/\/ make sure that the method type matches\n-                    mh0.asType(type.insertParameterTypes(0, proxyClass));\n-                    return true;\n-                } catch (WrongMethodTypeException e) {\n-                    return false;\n-                }\n-            }).getAsBoolean() : \"Wrong method type\";\n-            \/\/ change return type to Object\n-            MethodHandle mh = mh0.asType(mh0.type().changeReturnType(Object.class));\n-            \/\/ wrap any exception thrown with InvocationTargetException\n-            mh = MethodHandles.catchException(mh, Throwable.class, wrapWithInvocationTargetExceptionMH());\n-            \/\/ spread array of arguments among parameters (skipping 1st parameter - target)\n-            mh = mh.asSpreader(1, Object[].class, type.parameterCount());\n-            \/\/ change target type to Object\n-            mh = mh.asType(MethodType.methodType(Object.class, Object.class, Object[].class));\n-\n-            \/\/ push MH into cache\n-            MethodHandle cached = methods.putIfAbsent(method, mh);\n-            if (cached != null) {\n-                superMH = cached;\n-            } else {\n-                superMH = mh;\n-            }\n-        }\n-\n-        \/\/ invoke the super method\n-        try {\n-            \/\/ the args array can be null if the number of formal parameters required by\n-            \/\/ the method is zero (consistent with Method::invoke)\n-            Object[] params = args != null ? args : EMPTY_ARGS;\n-            return superMH.invokeExact(proxy, params);\n-        } catch (ClassCastException | NullPointerException e) {\n-            throw new IllegalArgumentException(e.getMessage(), e);\n-        } catch (InvocationTargetException | RuntimeException | Error e) {\n-            throw e;\n-        } catch (Throwable e) {\n-            \/\/ should not reach here\n-            throw new InternalError(e);\n-        }\n+    static ConcurrentHashMap<Method, MethodHandle> defaultMethodMap(Class<?> proxyClass) {\n+        assert isProxyClass(proxyClass);\n+        return DEFAULT_METHODS_MAP.get(proxyClass);\n@@ -1342,0 +1161,2 @@\n+    static final Object[] EMPTY_ARGS = new Object[0];\n+\n@@ -1348,1 +1169,1 @@\n-    private static Class<?> findProxyInterfaceOrElseThrow(Class<?> proxyClass, Method method) {\n+    static Class<?> findProxyInterfaceOrElseThrow(Class<?> proxyClass, Method method) {\n@@ -1413,2 +1234,1 @@\n-    private Lookup proxyClassLookup(Lookup caller) {\n-        Class<?> proxyClass = this.getClass();\n+    static Lookup proxyClassLookup(Lookup caller, Class<?> proxyClass) {\n@@ -1441,1 +1261,1 @@\n-    private static MethodHandle wrapWithInvocationTargetExceptionMH() {\n+    static MethodHandle wrapWithInvocationTargetExceptionMH() {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Proxy.java","additions":10,"deletions":190,"binary":false,"changes":200,"status":"modified"},{"patch":"@@ -636,1 +636,1 @@\n-     * on this proxy class if the caller's lookup class is java.lang.reflect.Proxy;\n+     * on this proxy class if the caller's lookup class is java.lang.reflect.InvocationHandler;\n@@ -649,1 +649,1 @@\n-        mv.visitLdcInsn(Type.getType(Proxy.class));\n+        mv.visitLdcInsn(Type.getType(InvocationHandler.class));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/ProxyGenerator.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -115,1 +115,1 @@\n-                    return Proxy.invokeDefaultMethod(o, findDefaultMethod(I2.class, method), params);\n+                    return InvocationHandler.invokeDefaultMethod(o, findDefaultMethod(I2.class, method), params);\n@@ -147,1 +147,1 @@\n-                        return Proxy.invokeDefaultMethod(proxy, method, params);\n+                        return InvocationHandler.invokeDefaultMethod(proxy, method, params);\n@@ -193,1 +193,1 @@\n-        InvocationHandler ih = (proxy, method, params) -> {\n+        final InvocationHandler ih = (proxy, method, params) -> {\n@@ -197,1 +197,1 @@\n-                    return Proxy.invokeDefaultMethod(proxy, findDefaultMethod(proxyInterface, method), params);\n+                    return InvocationHandler.invokeDefaultMethod(proxy, findDefaultMethod(proxyInterface, method), params);\n@@ -219,2 +219,2 @@\n-        \/\/ invoke via Proxy.invokeDefaultMethod directly\n-        assertEquals(Proxy.invokeDefaultMethod(proxy, proxyInterface.getMethod(\"m\")), expected);\n+        \/\/ invoke via InvocationHandler.invokeDefaultMethod directly\n+        assertEquals(InvocationHandler.invokeDefaultMethod(proxy, proxyInterface.getMethod(\"m\")), expected);\n@@ -226,1 +226,1 @@\n-        InvocationHandler ih = (proxy, method, params) -> {\n+        final InvocationHandler ih = (proxy, method, params) -> {\n@@ -232,1 +232,1 @@\n-                    return Proxy.invokeDefaultMethod(proxy, method, params);\n+                    return InvocationHandler.invokeDefaultMethod(proxy, method, params);\n@@ -243,1 +243,1 @@\n-        assertEquals(Proxy.invokeDefaultMethod(i12, m, 100, new Object[] {\"foo\", true, \"bar\"}),\n+        assertEquals(InvocationHandler.invokeDefaultMethod(i12, m, 100, new Object[] {\"foo\", true, \"bar\"}),\n@@ -255,2 +255,2 @@\n-        Proxy.invokeDefaultMethod(proxy, m1);\n-        Proxy.invokeDefaultMethod(proxy, m1, new Object[0]);\n+        InvocationHandler.invokeDefaultMethod(proxy, m1);\n+        InvocationHandler.invokeDefaultMethod(proxy, m1, new Object[0]);\n@@ -261,1 +261,1 @@\n-        Proxy.invokeDefaultMethod(proxy, m2, Integer.valueOf(100), \"foo\");\n+        InvocationHandler.invokeDefaultMethod(proxy, m2, Integer.valueOf(100), \"foo\");\n@@ -271,1 +271,1 @@\n-        assertEquals(Proxy.invokeDefaultMethod(proxy, m, (Object)new String[] { \"a\", \"bc\" }), 3);\n+        assertEquals(InvocationHandler.invokeDefaultMethod(proxy, m, (Object)new String[] { \"a\", \"bc\" }), 3);\n@@ -296,1 +296,1 @@\n-        Proxy.invokeDefaultMethod(proxy, m);\n+        InvocationHandler.invokeDefaultMethod(proxy, m);\n@@ -325,1 +325,1 @@\n-            Proxy.invokeDefaultMethod(proxy, method);\n+            InvocationHandler.invokeDefaultMethod(proxy, method);\n@@ -355,1 +355,1 @@\n-        Proxy.invokeDefaultMethod(proxy, m, args);\n+        InvocationHandler.invokeDefaultMethod(proxy, m, args);\n@@ -376,1 +376,1 @@\n-            Proxy.invokeDefaultMethod(proxy, m, exception);\n+            InvocationHandler.invokeDefaultMethod(proxy, m, exception);\n@@ -384,1 +384,1 @@\n-        return Proxy.invokeDefaultMethod(proxy, method, params);\n+        return InvocationHandler.invokeDefaultMethod(proxy, method, params);\n","filename":"test\/jdk\/java\/lang\/reflect\/Proxy\/DefaultMethods.java","additions":18,"deletions":18,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -0,0 +1,124 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.reflect.*;\n+import java.util.Arrays;\n+import java.util.stream.Collectors;\n+\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.*;\n+\n+\/*\n+ * @test\n+ * @bug 8159746\n+ * @summary Test invoking a default method in a non-public proxy interface\n+ * @build p.Foo p.Bar p.DefaultMethodInvoker\n+ * @run testng DefaultMethodProxy\n+ *\/\n+public class DefaultMethodProxy {\n+    public interface I {\n+        default String m() { return \"I\"; }\n+    }\n+\n+    @Test\n+    public static void hasPackageAccess() throws Exception {\n+        Class<?> fooClass = Class.forName(\"p.Foo\");\n+        Class<?> barClass = Class.forName(\"p.Bar\");\n+\n+        \/\/ create a proxy instance of a non-public proxy interface\n+        makeProxy(IH, fooClass).testDefaultMethod(\"foo\");\n+        makeProxy(IH, barClass, fooClass).testDefaultMethod(\"bar\");\n+\n+        \/\/ create a proxy instance of a public proxy interface should succeed\n+        makeProxy(IH, I.class).testDefaultMethod(\"I\");\n+    }\n+\n+    @DataProvider(name = \"nonPublicIntfs\")\n+    private static Object[][] nonPublicIntfs() throws ClassNotFoundException {\n+        Class<?> fooClass = Class.forName(\"p.Foo\");\n+        Class<?> barClass = Class.forName(\"p.Bar\");\n+        return new Object[][]{\n+                new Object[]{new Class<?>[]{ fooClass }},\n+                new Object[]{new Class<?>[]{ barClass }},\n+                new Object[]{new Class<?>[]{ barClass, fooClass }},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"nonPublicIntfs\")\n+    public static void noPackageAccess(Class<?>[] intfs) throws Exception {\n+        makeProxy(IH_NO_ACCESS, intfs).testDefaultMethod(\"dummy\");\n+    }\n+\n+    final Object proxy;\n+    DefaultMethodProxy(Object proxy) {\n+        this.proxy = proxy;\n+    }\n+\n+    \/*\n+     * Verify if a default method \"m\" can be invoked successfully\n+     *\/\n+    void testDefaultMethod(String expected) throws ReflectiveOperationException {\n+        Method m = proxy.getClass().getDeclaredMethod(\"m\");\n+        m.setAccessible(true);\n+        String name = (String)m.invoke(proxy);\n+        if (!expected.equals(name)) {\n+            throw new RuntimeException(\"return value: \" + name + \" expected: \" + expected);\n+        }\n+    }\n+\n+    \/\/ invocation handler with access to the non-public interface in package p\n+    private static final InvocationHandler IH = (proxy, method, params) -> {\n+        System.out.format(\"Proxy for %s: invoking %s%n\",\n+                Arrays.stream(proxy.getClass().getInterfaces())\n+                      .map(Class::getName)\n+                      .collect(Collectors.joining(\", \")), method.getName());\n+        if (method.isDefault()) {\n+            return p.DefaultMethodInvoker.invoke(proxy, method, params);\n+        }\n+        throw new UnsupportedOperationException(method.toString());\n+    };\n+\n+    \/\/ invocation handler with no access to the non-public interface in package p\n+    \/\/ expect IllegalAccessException thrown\n+    private static final InvocationHandler IH_NO_ACCESS = (proxy, method, params) -> {\n+        System.out.format(\"Proxy for %s: invoking %s%n\",\n+                Arrays.stream(proxy.getClass().getInterfaces())\n+                        .map(Class::getName)\n+                        .collect(Collectors.joining(\", \")), method.getName());\n+        if (method.isDefault()) {\n+            try {\n+                InvocationHandler.invokeDefaultMethod(proxy, method, params);\n+                throw new RuntimeException(\"IAE not thrown in invoking: \" + method);\n+            } catch (IllegalAccessException e) {\n+                return \"dummy\";\n+            }\n+        }\n+        throw new UnsupportedOperationException(method.toString());\n+    };\n+\n+    private static DefaultMethodProxy makeProxy(InvocationHandler ih, Class<?>... intfs) {\n+        Object proxy = Proxy.newProxyInstance(DefaultMethodProxy.class.getClassLoader(), intfs, ih);\n+        return new DefaultMethodProxy(proxy);\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/Proxy\/nonPublicProxy\/DefaultMethodProxy.java","additions":124,"deletions":0,"binary":false,"changes":124,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2020, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/jdk\/java\/lang\/reflect\/Proxy\/nonPublicProxy\/NonPublicProxyClass.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -37,4 +37,0 @@\n-    public interface I {\n-        default String m() { return \"I\"; }\n-    }\n-\n@@ -46,4 +42,1 @@\n-        \/\/ create a proxy instance of a non-public proxy interface\n-        \/\/ also test invocation of a default method\n-        makeProxy(loader, fooClass).testDefaultMethod(\"foo\");\n-        makeProxy(loader, barClass, fooClass).testDefaultMethod(\"bar\");\n+        makeProxy(loader, fooClass);\n@@ -51,2 +44,0 @@\n-        \/\/ verify security permission check\n-        Policy.setPolicy(new SimplePolicy());\n@@ -54,2 +45,0 @@\n-        \/\/ create a proxy instance of a public proxy interface should succeed\n-        makeProxy(loader, I.class).testDefaultMethod(\"I\");\n@@ -57,1 +46,0 @@\n-            \/\/ fail to create a proxy instance of a non-public proxy interface\n@@ -68,2 +56,3 @@\n-    private static SimpleProxy makeProxy(ClassLoader loader, Class<?>... intfs) {\n-        Object proxy = Proxy.newProxyInstance(loader, intfs, new InvocationHandler() {\n+    private static void makeProxy(ClassLoader loader, Class<?> cls) {\n+        Class<?>[] intfs = new Class<?>[] { cls };\n+        Proxy.newProxyInstance(loader, intfs, new InvocationHandler() {\n@@ -75,3 +64,0 @@\n-                if (method.getName().equals(\"m\")) {\n-                    return Proxy.invokeDefaultMethod(proxy, method, args);\n-                }\n@@ -81,39 +67,0 @@\n-        return new SimpleProxy(proxy);\n-    }\n-\n-    final Object proxy;\n-    SimpleProxy(Object proxy) {\n-        this.proxy = proxy;\n-    }\n-\n-    \/*\n-     * Verify if a default method \"m\" can be invoked successfully\n-     *\/\n-    void testDefaultMethod(String expected) throws ReflectiveOperationException {\n-        Method m = proxy.getClass().getDeclaredMethod(\"m\");\n-        m.setAccessible(true);\n-        String name = (String)m.invoke(proxy);\n-        if (!expected.equals(name)) {\n-            throw new RuntimeException(\"return value: \" + name + \" expected: \" + expected);\n-        }\n-    }\n-\n-    static class SimplePolicy extends Policy {\n-        static final Policy DEFAULT_POLICY = Policy.getPolicy();\n-        final PermissionCollection permissions = new Permissions();\n-        SimplePolicy() {\n-            permissions.add(new SecurityPermission(\"getPolicy\"));\n-            permissions.add(new ReflectPermission(\"suppressAccessChecks\"));\n-        }\n-        public PermissionCollection getPermissions(ProtectionDomain domain) {\n-            return permissions;\n-        }\n-\n-        public PermissionCollection getPermissions(CodeSource codesource) {\n-            return permissions;\n-        }\n-\n-        public boolean implies(ProtectionDomain domain, Permission perm) {\n-            return permissions.implies(perm) ||\n-                    DEFAULT_POLICY.implies(domain, perm);\n-        }\n","filename":"test\/jdk\/java\/lang\/reflect\/Proxy\/nonPublicProxy\/SimpleProxy.java","additions":4,"deletions":57,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -0,0 +1,32 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package p;\n+import java.lang.reflect.*;\n+\n+public class DefaultMethodInvoker {\n+     public static Object invoke(Object proxy, Method method, Object... args)\n+            throws IllegalAccessException, InvocationTargetException {\n+         return InvocationHandler.invokeDefaultMethod(proxy, method, args);\n+     }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/Proxy\/nonPublicProxy\/p\/DefaultMethodInvoker.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -27,0 +27,3 @@\n+    default int m() {\n+        throw new UnsupportedOperationException(\"Q::m is in a non-exported package\");\n+    }\n","filename":"test\/jdk\/java\/lang\/reflect\/Proxy\/src\/m3\/p\/three\/internal\/Q.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,97 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.test;\n+\n+import java.lang.reflect.InvocationHandler;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Proxy;\n+import java.lang.reflect.UndeclaredThrowableException;\n+\n+\/**\n+ * Tests invocation of default methods in exported types and inaccessible types\n+ * in a named module\n+ *\/\n+public class DefaultMethods {\n+    private final static Module TEST_MODULE = DefaultMethods.class.getModule();\n+    private final static InvocationHandler IH = (proxy, method, params) -> {\n+        return InvocationHandler.invokeDefaultMethod(proxy, method, params);\n+    };\n+\n+    public static void main(String... args) throws Exception {\n+        \/\/ exported types from m1\n+        testDefaultMethod(new Class<?>[] { p.one.I.class, p.two.A.class}, 1);\n+        \/\/ qualified-exported type from m2\n+        testDefaultMethod(new Class<?>[] { p.two.internal.C.class, p.two.A.class }, 2);\n+        \/\/ module-private type from test module\n+        testDefaultMethod(new Class<?>[] { jdk.test.internal.R.class }, 10);\n+        \/\/ non-public interface in the same runtime package\n+        testDefaultMethod(new Class<?>[] { Class.forName(\"jdk.test.NP\") }, 100);\n+\n+        \/\/ inaccessible type - not exported to test module\n+        Class<?> qType = Class.forName(\"p.three.internal.Q\");\n+        inaccessibleDefaultMethod(qType);\n+        \/\/ non-public interface in the same runtime package\n+        Class<?> nonPublicType = Class.forName(\"jdk.test.internal.NP\");\n+        inaccessibleDefaultMethod(nonPublicType);\n+    }\n+\n+    static void testDefaultMethod(Class<?>[] intfs, int expected) throws Exception {\n+        Object proxy = Proxy.newProxyInstance(TEST_MODULE.getClassLoader(), intfs, IH);\n+        if (!proxy.getClass().getModule().isNamed()) {\n+            throw new RuntimeException(proxy.getClass() + \" expected to be in a named module\");\n+        }\n+        Method m = intfs[0].getMethod(\"m\");\n+        int result = (int)m.invoke(proxy);\n+        if (result != expected) {\n+            throw new RuntimeException(\"return value: \" + result + \" expected: \" + expected);\n+        }\n+    }\n+\n+    static void inaccessibleDefaultMethod(Class<?> intf) throws Exception {\n+        Object proxy = Proxy.newProxyInstance(TEST_MODULE.getClassLoader(), new Class<?>[] { intf }, IH);\n+        if (!proxy.getClass().getModule().isNamed()) {\n+            throw new RuntimeException(proxy.getClass() + \" expected to be in a named module\");\n+        }\n+        Method m = intf.getMethod(\"m\");\n+        try {\n+            InvocationHandler.invokeDefaultMethod(proxy, m, null);\n+            throw new RuntimeException(\"IAE not thrown invoking: \" + m);\n+        } catch (IllegalAccessException e) {}\n+\n+        if (m.trySetAccessible()) {\n+            try {\n+                m.invoke(proxy);\n+                throw new RuntimeException(\"IAE not thrown invoking: \" + m);\n+            } catch (InvocationTargetException e) {\n+                \/\/ IAE wrapped by InvocationHandler::invoke with UndeclaredThrowableException\n+                \/\/ then wrapped by Method::invoke with InvocationTargetException\n+                assert e.getCause() instanceof UndeclaredThrowableException;\n+                Throwable cause = e.getCause().getCause();\n+                if (!(cause instanceof IllegalAccessException))\n+                    throw e;\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/Proxy\/src\/test\/jdk\/test\/DefaultMethods.java","additions":97,"deletions":0,"binary":false,"changes":97,"status":"added"},{"patch":"@@ -31,0 +31,4 @@\n+\n+    default int m() {\n+        return 100;\n+    }\n","filename":"test\/jdk\/java\/lang\/reflect\/Proxy\/src\/test\/jdk\/test\/NP.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,33 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.test.internal;\n+\n+\/*\n+ * Non-public interface\n+ *\/\n+interface NP {\n+    default int m() {\n+        throw new UnsupportedOperationException(\"non-public interface: \" + NP.class.getName());\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/Proxy\/src\/test\/jdk\/test\/internal\/NP.java","additions":33,"deletions":0,"binary":false,"changes":33,"status":"added"}]}