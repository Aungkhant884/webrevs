{"files":[{"patch":"@@ -0,0 +1,145 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+#include \"precompiled.hpp\"\n+\n+#ifdef COMPILER2\n+\n+#include \"peephole_x86_64.hpp\"\n+\n+\/\/ This function transforms the shapes\n+\/\/ mov d, s1; add d, s2 into\n+\/\/ lea d, [s1 + s2]     and\n+\/\/ mov d, s1; shl d, s2 into\n+\/\/ lea d, [s1 << s2]    with s2 = 1, 2, 3\n+bool lea_coalesce_helper(Block* block, int block_index, PhaseCFG* cfg_, PhaseRegAlloc* ra_,\n+                         MachNode* (*new_root)(), uint inst0_rule, bool imm) {\n+  MachNode* inst0 = block->get_node(block_index)->as_Mach();\n+  assert(inst0->rule() == inst0_rule, \"sanity\");\n+\n+  OptoReg::Name dst = ra_->get_reg_first(inst0);\n+  MachNode* inst1 = nullptr;\n+  OptoReg::Name src1 = OptoReg::Bad;\n+\n+  if (inst0->in(1)->is_MachSpillCopy()) {\n+    OptoReg::Name in = ra_->get_reg_first(inst0->in(1)->in(1));\n+    if (OptoReg::is_reg(in) && OptoReg::as_VMReg(in)->is_Register()) {\n+      inst1 = inst0->in(1)->as_Mach();\n+      src1 = in;\n+    }\n+  }\n+  if (inst1 == nullptr) {\n+    return false;\n+  }\n+  assert(dst != src1, \"\");\n+\n+  \/\/ Only coalesce if inst1 is immediately followed by inst0\n+  \/\/ Can be improved for more general cases\n+  if (block_index < 1 || block->get_node(block_index - 1) != inst1) {\n+    return false;\n+  }\n+  int inst1_index = block_index - 1;\n+  Node* inst2;\n+  if (imm) {\n+    inst2 = nullptr;\n+  } else {\n+    inst2 = inst0->in(2);\n+    if (inst2 == inst1) {\n+      inst2 = inst2->in(1);\n+    }\n+  }\n+\n+  \/\/ See VM_Version::supports_fast_3op_lea()\n+  if (!imm) {\n+    Register rsrc1 = OptoReg::as_VMReg(src1)->as_Register();\n+    Register rsrc2 = OptoReg::as_VMReg(ra_->get_reg_first(inst2))->as_Register();\n+    if ((rsrc1 == rbp || rsrc1 == r13) && (rsrc2 == rbp || rsrc2 == r13)) {\n+      return false;\n+    }\n+  }\n+\n+  \/\/ Go down the block to find the output proj node (the flag output) of inst0\n+  int proj_index = -1;\n+  Node* proj = nullptr;\n+  for (uint pos = block_index + 1; pos < block->number_of_nodes(); pos++) {\n+    Node* curr = block->get_node(pos);\n+    if (curr->is_MachProj() && curr->in(0) == inst0) {\n+      proj_index = pos;\n+      proj = curr;\n+      break;\n+    }\n+  }\n+  assert(proj != nullptr, \"\");\n+  \/\/ If some node uses the flag, cannot remove\n+  if (proj->outcnt() > 0) {\n+    return false;\n+  }\n+\n+  MachNode* root = new_root();\n+  \/\/ Assign register for the newly allocated node\n+  ra_->set_oop(root, ra_->is_oop(inst0));\n+  ra_->set_pair(root->_idx, ra_->get_reg_second(inst0), ra_->get_reg_first(inst0));\n+\n+  \/\/ Set input and output for the node\n+  root->add_req(inst0->in(0));\n+  root->add_req(inst1->in(1));\n+  \/\/ No input for constant after matching\n+  if (!imm) {\n+    root->add_req(inst2);\n+  }\n+  inst0->replace_by(root);\n+  proj->set_req(0, inst0);\n+\n+  \/\/ Initialize the operand array\n+  root->_opnds[0] = inst0->_opnds[0]->clone();\n+  root->_opnds[1] = inst0->_opnds[1]->clone();\n+  root->_opnds[2] = inst0->_opnds[2]->clone();\n+\n+  \/\/ Modify the block\n+  inst0->set_removed();\n+  inst1->set_removed();\n+  block->remove_node(proj_index);\n+  block->remove_node(block_index);\n+  block->remove_node(inst1_index);\n+  block->insert_node(root, block_index - 1);\n+\n+  \/\/ Modify the CFG\n+  cfg_->map_node_to_block(inst0, nullptr);\n+  cfg_->map_node_to_block(inst1, nullptr);\n+  cfg_->map_node_to_block(proj, nullptr);\n+  cfg_->map_node_to_block(root, block);\n+\n+  return true;\n+}\n+\n+bool Peephole::lea_coalesce_reg(Block* block, int block_index, PhaseCFG* cfg_, PhaseRegAlloc* ra_,\n+                                MachNode* (*new_root)(), uint inst0_rule) {\n+  return lea_coalesce_helper(block, block_index, cfg_, ra_, new_root, inst0_rule, false);\n+}\n+\n+bool Peephole::lea_coalesce_imm(Block* block, int block_index, PhaseCFG* cfg_, PhaseRegAlloc* ra_,\n+                                MachNode* (*new_root)(), uint inst0_rule) {\n+  return lea_coalesce_helper(block, block_index, cfg_, ra_, new_root, inst0_rule, true);\n+}\n+\n+#endif \/\/ COMPILER2\n","filename":"src\/hotspot\/cpu\/x86\/peephole_x86_64.cpp","additions":145,"deletions":0,"binary":false,"changes":145,"status":"added"},{"patch":"@@ -0,0 +1,39 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef CPU_X86_PEEPHOLE_X86_64_HPP\n+#define CPU_X86_PEEPHOLE_X86_64_HPP\n+\n+#include \"opto\/machnode.hpp\"\n+#include \"opto\/regalloc.hpp\"\n+\n+class Peephole {\n+public:\n+  static bool lea_coalesce_reg(Block* block, int block_index, PhaseCFG* cfg_, PhaseRegAlloc* ra_,\n+                               MachNode* (*new_root)(), uint inst0_rule);\n+  static bool lea_coalesce_imm(Block* block, int block_index, PhaseCFG* cfg_, PhaseRegAlloc* ra_,\n+                               MachNode* (*new_root)(), uint inst0_rule);\n+};\n+\n+#endif \/\/ CPU_X86_PEEPHOLE_X86_64_HPP\n","filename":"src\/hotspot\/cpu\/x86\/peephole_x86_64.hpp","additions":39,"deletions":0,"binary":false,"changes":39,"status":"added"},{"patch":"@@ -660,2 +660,2 @@\n-    st->print(\"CMPL     rsp, poll_offset[thread]  \\n\\t\"\n-              \"JA       #safepoint_stub\\t\"\n+    st->print(\"CMPL    rsp, poll_offset[thread]  \\n\\t\"\n+              \"JA      #safepoint_stub\\t\"\n","filename":"src\/hotspot\/cpu\/x86\/x86_32.ad","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -322,0 +322,8 @@\n+\n+source_hpp %{\n+\n+#include \"peephole_x86_64.hpp\"\n+\n+%}\n+\n+\/\/ Register masks\n@@ -964,2 +972,2 @@\n-    st->print_cr(\"cmpq     rsp, poll_offset[r15_thread] \\n\\t\"\n-                 \"ja       #safepoint_stub\\t\"\n+    st->print_cr(\"cmpq    rsp, poll_offset[r15_thread] \\n\\t\"\n+                 \"ja      #safepoint_stub\\t\"\n@@ -9004,0 +9012,13 @@\n+\/\/ Shift Left by one, two, three\n+instruct salI_rReg_immI2(rRegI dst, immI2 shift, rFlagsReg cr)\n+%{\n+  match(Set dst (LShiftI dst shift));\n+  effect(KILL cr);\n+\n+  format %{ \"sall    $dst, $shift\" %}\n+  ins_encode %{\n+    __ sall($dst$$Register, $shift$$constant);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n@@ -9238,0 +9259,13 @@\n+\/\/ Shift Left by one, two, three\n+instruct salL_rReg_immI2(rRegL dst, immI2 shift, rFlagsReg cr)\n+%{\n+  match(Set dst (LShiftL dst shift));\n+  effect(KILL cr);\n+\n+  format %{ \"salq    $dst, $shift\" %}\n+  ins_encode %{\n+    __ salq($dst$$Register, $shift$$constant);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n@@ -13544,0 +13578,3 @@\n+\/\/ peeppredicate ( rule_predicate );\n+\/\/ \/\/ the predicate unless which the peephole rule will be ignored\n+\/\/\n@@ -13546,0 +13583,10 @@\n+\/\/ peepprocedure ( procedure_name );\n+\/\/ \/\/ provide a procedure name to perform the optimization, the procedure should\n+\/\/ \/\/ reside in the architecture dependent peephole file, the method has the\n+\/\/ \/\/ signature of MachNode* (Block*, int, PhaseRegAlloc*, (MachNode*)(*)(), int...)\n+\/\/ \/\/ with the arguments being the basic block, the current node index inside the\n+\/\/ \/\/ block, the register allocator, the functions upon invoked return a new node\n+\/\/ \/\/ defined in peepreplace, and the rules of the nodes appearing in the\n+\/\/ \/\/ corresponding peepmatch, the function return true if successful, else\n+\/\/ \/\/ return false\n+\/\/\n@@ -13566,4 +13613,1 @@\n-\/\/ Only match adjacent instructions in same basic block\n-\/\/ Only equality constraints\n-\/\/ Only constraints between operands, not (0.dest_reg == RAX_enc)\n-\/\/ Only one replacement instruction\n+\/\/ Only transformations inside a basic block (do we need more for peephole)\n@@ -13585,0 +13629,11 @@\n+\/\/ instruct leaI_rReg_immI(rRegI dst, immI_1 src)\n+\/\/ %{\n+\/\/   match(Set dst (AddI dst src));\n+\/\/ %}\n+\/\/\n+\/\/ 1. Simple replacement\n+\/\/ - Only match adjacent instructions in same basic block\n+\/\/ - Only equality constraints\n+\/\/ - Only constraints between operands, not (0.dest_reg == RAX_enc)\n+\/\/ - Only one replacement instruction\n+\/\/\n@@ -13587,0 +13642,2 @@\n+\/\/   \/\/ lea should only be emitted when beneficial\n+\/\/   peeppredicate( VM_Version::supports_fast_2op_lea() );\n@@ -13597,3 +13654,6 @@\n-\n-\/\/ Implementation no longer uses movX instructions since\n-\/\/ machine-independent system no longer uses CopyX nodes.\n+\/\/ 2. Procedural replacement\n+\/\/ - More flexible finding relevent nodes\n+\/\/ - More flexible constraints\n+\/\/ - More flexible transformations\n+\/\/ - May utilise architecture-dependent API more effectively\n+\/\/ - Currently only one replacement instruction due to adlc parsing capabilities\n@@ -13601,5 +13661,11 @@\n-\/\/ peephole\n-\/\/ %{\n-\/\/   peepmatch (incI_rReg movI);\n-\/\/   peepconstraint (0.dst == 1.dst);\n-\/\/   peepreplace (leaI_rReg_immI(0.dst 1.src 0.src));\n+\/\/ \/\/ Change (inc mov) to lea\n+\/\/ peephole %{\n+\/\/   \/\/ lea should only be emitted when beneficial\n+\/\/   peeppredicate( VM_Version::supports_fast_2op_lea() );\n+\/\/   \/\/ the rule numbers of these nodes inside are passed into the function below\n+\/\/   peepmatch ( incI_rReg movI );\n+\/\/   \/\/ the method that takes the responsibility of transformation\n+\/\/   peepprocedure ( inc_mov_to_lea );\n+\/\/   \/\/ the replacement is a leaI_rReg_immI, a lambda upon invoked creating this\n+\/\/   \/\/ node is passed into the function above\n+\/\/   peepreplace ( leaI_rReg_immI() );\n@@ -13608,6 +13674,19 @@\n-\/\/ peephole\n-\/\/ %{\n-\/\/   peepmatch (decI_rReg movI);\n-\/\/   peepconstraint (0.dst == 1.dst);\n-\/\/   peepreplace (leaI_rReg_immI(0.dst 1.src 0.src));\n-\/\/ %}\n+\/\/ These instructions is not matched by the matcher but used by the peephole\n+instruct leaI_rReg_rReg_peep(rRegI dst, rRegI src1, rRegI src2)\n+%{\n+  predicate(false);\n+  match(Set dst (AddI src1 src2));\n+  format %{ \"leal    $dst, [$src1 + $src2]\" %}\n+  ins_encode %{\n+    Register dst = $dst$$Register;\n+    Register src1 = $src1$$Register;\n+    Register src2 = $src2$$Register;\n+    if (src1 != rbp && src1 != r13) {\n+      __ leal(dst, Address(src1, src2, Address::times_1));\n+    } else {\n+      assert(src2 != rbp && src2 != r13, \"\");\n+      __ leal(dst, Address(src2, src1, Address::times_1));\n+    }\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n@@ -13615,6 +13694,10 @@\n-\/\/ peephole\n-\/\/ %{\n-\/\/   peepmatch (addI_rReg_imm movI);\n-\/\/   peepconstraint (0.dst == 1.dst);\n-\/\/   peepreplace (leaI_rReg_immI(0.dst 1.src 0.src));\n-\/\/ %}\n+instruct leaI_rReg_immI_peep(rRegI dst, rRegI src1, immI src2)\n+%{\n+  predicate(false);\n+  match(Set dst (AddI src1 src2));\n+  format %{ \"leal    $dst, [$src1 + $src2]\" %}\n+  ins_encode %{\n+    __ leal($dst$$Register, Address($src1$$Register, $src2$$constant));\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n@@ -13622,6 +13705,16 @@\n-\/\/ peephole\n-\/\/ %{\n-\/\/   peepmatch (incL_rReg movL);\n-\/\/   peepconstraint (0.dst == 1.dst);\n-\/\/   peepreplace (leaL_rReg_immL(0.dst 1.src 0.src));\n-\/\/ %}\n+instruct leaI_rReg_immI2_peep(rRegI dst, rRegI src, immI2 shift)\n+%{\n+  predicate(false);\n+  match(Set dst (LShiftI src shift));\n+  format %{ \"leal    $dst, [$src << $shift]\" %}\n+  ins_encode %{\n+    Address::ScaleFactor scale = static_cast<Address::ScaleFactor>($shift$$constant);\n+    Register src = $src$$Register;\n+    if (scale == Address::times_2 && src != rbp && src != r13) {\n+      __ leal($dst$$Register, Address(src, src, Address::times_1));\n+    } else {\n+      __ leal($dst$$Register, Address(noreg, src, scale));\n+    }\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n@@ -13629,6 +13722,18 @@\n-\/\/ peephole\n-\/\/ %{\n-\/\/   peepmatch (decL_rReg movL);\n-\/\/   peepconstraint (0.dst == 1.dst);\n-\/\/   peepreplace (leaL_rReg_immL(0.dst 1.src 0.src));\n-\/\/ %}\n+instruct leaL_rReg_rReg_peep(rRegL dst, rRegL src1, rRegL src2)\n+%{\n+  predicate(false);\n+  match(Set dst (AddL src1 src2));\n+  format %{ \"leaq    $dst, [$src1 + $src2]\" %}\n+  ins_encode %{\n+    Register dst = $dst$$Register;\n+    Register src1 = $src1$$Register;\n+    Register src2 = $src2$$Register;\n+    if (src1 != rbp && src1 != r13) {\n+      __ leaq(dst, Address(src1, src2, Address::times_1));\n+    } else {\n+      assert(src2 != rbp && src2 != r13, \"\");\n+      __ leaq(dst, Address(src2, src1, Address::times_1));\n+    }\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n@@ -13636,6 +13741,10 @@\n-\/\/ peephole\n-\/\/ %{\n-\/\/   peepmatch (addL_rReg_imm movL);\n-\/\/   peepconstraint (0.dst == 1.dst);\n-\/\/   peepreplace (leaL_rReg_immL(0.dst 1.src 0.src));\n-\/\/ %}\n+instruct leaL_rReg_immL32_peep(rRegL dst, rRegL src1, immL32 src2)\n+%{\n+  predicate(false);\n+  match(Set dst (AddL src1 src2));\n+  format %{ \"leaq    $dst, [$src1 + $src2]\" %}\n+  ins_encode %{\n+    __ leaq($dst$$Register, Address($src1$$Register, $src2$$constant));\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n@@ -13643,6 +13752,16 @@\n-\/\/ peephole\n-\/\/ %{\n-\/\/   peepmatch (addP_rReg_imm movP);\n-\/\/   peepconstraint (0.dst == 1.dst);\n-\/\/   peepreplace (leaP_rReg_imm(0.dst 1.src 0.src));\n-\/\/ %}\n+instruct leaL_rReg_immI2_peep(rRegL dst, rRegL src, immI2 shift)\n+%{\n+  predicate(false);\n+  match(Set dst (LShiftL src shift));\n+  format %{ \"leaq    $dst, [$src << $shift]\" %}\n+  ins_encode %{\n+    Address::ScaleFactor scale = static_cast<Address::ScaleFactor>($shift$$constant);\n+    Register src = $src$$Register;\n+    if (scale == Address::times_2 && src != rbp && src != r13) {\n+      __ leaq($dst$$Register, Address(src, src, Address::times_1));\n+    } else {\n+      __ leaq($dst$$Register, Address(noreg, src, scale));\n+    }\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n@@ -13650,11 +13769,63 @@\n-\/\/ \/\/ Change load of spilled value to only a spill\n-\/\/ instruct storeI(memory mem, rRegI src)\n-\/\/ %{\n-\/\/   match(Set mem (StoreI mem src));\n-\/\/ %}\n-\/\/\n-\/\/ instruct loadI(rRegI dst, memory mem)\n-\/\/ %{\n-\/\/   match(Set dst (LoadI mem));\n-\/\/ %}\n-\/\/\n+peephole\n+%{\n+  peeppredicate(VM_Version::supports_fast_2op_lea());\n+  peepmatch (addI_rReg);\n+  peepprocedure (lea_coalesce_reg);\n+  peepreplace (leaI_rReg_rReg_peep());\n+%}\n+\n+peephole\n+%{\n+  peeppredicate(VM_Version::supports_fast_2op_lea());\n+  peepmatch (addI_rReg_imm);\n+  peepprocedure (lea_coalesce_imm);\n+  peepreplace (leaI_rReg_immI_peep());\n+%}\n+\n+peephole\n+%{\n+  peeppredicate(VM_Version::supports_fast_2op_lea());\n+  peepmatch (incI_rReg);\n+  peepprocedure (lea_coalesce_imm);\n+  peepreplace (leaI_rReg_immI_peep());\n+%}\n+\n+peephole\n+%{\n+  peeppredicate(VM_Version::supports_fast_2op_lea());\n+  peepmatch (decI_rReg);\n+  peepprocedure (lea_coalesce_imm);\n+  peepreplace (leaI_rReg_immI_peep());\n+%}\n+\n+peephole\n+%{\n+  peeppredicate(VM_Version::supports_fast_2op_lea());\n+  peepmatch (salI_rReg_immI2);\n+  peepprocedure (lea_coalesce_imm);\n+  peepreplace (leaI_rReg_immI2_peep());\n+%}\n+\n+peephole\n+%{\n+  peeppredicate(VM_Version::supports_fast_2op_lea());\n+  peepmatch (addL_rReg);\n+  peepprocedure (lea_coalesce_reg);\n+  peepreplace (leaL_rReg_rReg_peep());\n+%}\n+\n+peephole\n+%{\n+  peeppredicate(VM_Version::supports_fast_2op_lea());\n+  peepmatch (addL_rReg_imm);\n+  peepprocedure (lea_coalesce_imm);\n+  peepreplace (leaL_rReg_immL32_peep());\n+%}\n+\n+peephole\n+%{\n+  peeppredicate(VM_Version::supports_fast_2op_lea());\n+  peepmatch (incL_rReg);\n+  peepprocedure (lea_coalesce_imm);\n+  peepreplace (leaL_rReg_immL32_peep());\n+%}\n@@ -13664,3 +13835,4 @@\n-  peepmatch (loadI storeI);\n-  peepconstraint (1.src == 0.dst, 1.mem == 0.mem);\n-  peepreplace (storeI(1.mem 1.mem 1.src));\n+  peeppredicate(VM_Version::supports_fast_2op_lea());\n+  peepmatch (decL_rReg);\n+  peepprocedure (lea_coalesce_imm);\n+  peepreplace (leaL_rReg_immL32_peep());\n@@ -13671,3 +13843,4 @@\n-  peepmatch (loadL storeL);\n-  peepconstraint (1.src == 0.dst, 1.mem == 0.mem);\n-  peepreplace (storeL(1.mem 1.mem 1.src));\n+  peeppredicate(VM_Version::supports_fast_2op_lea());\n+  peepmatch (salL_rReg_immI2);\n+  peepprocedure (lea_coalesce_imm);\n+  peepreplace (leaL_rReg_immI2_peep());\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":240,"deletions":67,"binary":false,"changes":307,"status":"modified"},{"patch":"@@ -2049,1 +2049,3 @@\n-      if (strcmp(token,\"peepmatch\")==0) {\n+      if (strcmp(token,\"peeppredicate\")==0) {\n+        peep_predicate_parse(*peep); }\n+      else if (strcmp(token,\"peepmatch\")==0) {\n@@ -2051,0 +2053,2 @@\n+      else if (strcmp(token, \"peepprocedure\")==0) {\n+        peep_procedure_parse(*peep); }\n@@ -2056,1 +2060,3 @@\n-        parse_err(SYNERR, \"expected peepmatch, peepconstraint, or peepreplace for identifier %s.\\n\", token);\n+        parse_err(SYNERR,\n+            \"expected peeppreddicate, peepmatch, peepprocedure, peepconstraint, peepreplace, received %s.\\n\",\n+            token);\n@@ -2540,0 +2546,25 @@\n+\/\/---------------------------peep-predicate-parse------------------------------\n+\/\/ Syntax for a peeppredicate rule\n+\/\/\n+\/\/ peeppredicate ( predicate );\n+\/\/\n+void ADLParser::peep_predicate_parse(Peephole& peep) {\n+\n+  skipws();\n+  char* rule = nullptr;\n+  if ( (rule = get_paren_expr(\"pred expression\", true)) == nullptr ) {\n+    parse_err(SYNERR, \"incorrect or missing expression for 'peeppredicate'\\n\");\n+    return;\n+  }\n+  if (_curchar != ';') {\n+    parse_err(SYNERR, \"missing ';' in peeppredicate definition\\n\");\n+    return;\n+  }\n+  next_char();   \/\/ skip ';'\n+  skipws();\n+\n+  \/\/ Construct PeepPredicate\n+  PeepPredicate* predicate = new PeepPredicate(rule);\n+  peep.add_predicate(predicate);\n+}\n+\n@@ -2586,0 +2617,40 @@\n+\/\/---------------------------peep-procedure-parse------------------------------\n+\/\/ Syntax for a peepprocedure rule\n+\/\/\n+\/\/ peeppredicate ( function_name );\n+\/\/\n+void ADLParser::peep_procedure_parse(Peephole& peep) {\n+\n+  skipws();\n+  \/\/ Check for open paren\n+  if (_curchar != '(') {\n+    parse_err(SYNERR, \"missing '(' at start of peepprocedure rule.\\n\");\n+    return;\n+  }\n+  next_char();   \/\/ skip '('\n+  skipws();\n+\n+  char* name = nullptr;\n+  if ( (name = get_ident_dup()) == nullptr ) {\n+    parse_err(SYNERR, \"incorrect or missing expression for 'peepprocedure'\\n\");\n+    return;\n+  }\n+\n+  skipws();\n+  if (_curchar != ')') {\n+    parse_err(SYNERR, \"peepprocedure should contain a single identifier only\\n\");\n+    return;\n+  }\n+  next_char();   \/\/ skip ')'\n+  if (_curchar != ';') {\n+    parse_err(SYNERR, \"missing ';' in peepprocedure definition\\n\");\n+    return;\n+  }\n+  next_char();   \/\/ skip ';'\n+  skipws();\n+\n+  \/\/ Construct PeepProcedure\n+  PeepProcedure* procedure = new PeepProcedure(name);\n+  peep.add_procedure(procedure);\n+}\n+\n@@ -2632,1 +2703,1 @@\n-    int right_inst;        \/\/ Right-instructions's number\n+    int right_inst;        \/\/ Right-instruction's number\n","filename":"src\/hotspot\/share\/adlc\/adlparse.cpp","additions":74,"deletions":3,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -65,0 +65,1 @@\n+class PeepPredicate;\n@@ -66,0 +67,1 @@\n+class PeepProcedure;\n@@ -139,0 +141,1 @@\n+  void peep_predicate_parse(Peephole &peep); \/\/ Parse the peephole predicate\n@@ -140,0 +143,1 @@\n+  void peep_procedure_parse(Peephole &peep); \/\/ Parse the peephole procedure\n","filename":"src\/hotspot\/share\/adlc\/adlparse.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -638,1 +638,2 @@\n-Peephole::Peephole() : _match(NULL), _constraint(NULL), _replace(NULL), _next(NULL) {\n+Peephole::Peephole() : _predicate(NULL), _match(NULL), _procedure(NULL),\n+                       _constraint(NULL), _replace(NULL), _next(NULL) {\n@@ -653,0 +654,6 @@\n+\/\/ Add a predicate to this peephole rule\n+void Peephole::add_predicate(PeepPredicate* predicate) {\n+  assert( _predicate == NULL, \"fatal()\" );\n+  _predicate = predicate;\n+}\n+\n@@ -659,0 +666,6 @@\n+\/\/ Add a procedure to this peephole rule\n+void Peephole::add_procedure(PeepProcedure* procedure) {\n+  assert( _procedure == NULL, \"fatal()\" );\n+  _procedure = procedure;\n+}\n+\n@@ -688,0 +701,18 @@\n+\/\/----------------------------PeepPredicate------------------------------------\n+PeepPredicate::PeepPredicate(const char* rule) : _rule(rule) {\n+}\n+PeepPredicate::~PeepPredicate() {\n+}\n+\n+const char* PeepPredicate::rule() const {\n+  return _rule;\n+}\n+\n+void PeepPredicate::dump() {\n+  output(stderr);\n+}\n+\n+void PeepPredicate::output(FILE* fp) {\n+  fprintf(fp, \"PeepPredicate\\n\");\n+}\n+\n@@ -694,1 +725,0 @@\n-\n@@ -744,0 +774,18 @@\n+\/\/----------------------------PeepProcedure------------------------------------\n+PeepProcedure::PeepProcedure(const char* name) : _name(name) {\n+}\n+PeepProcedure::~PeepProcedure() {\n+}\n+\n+const char* PeepProcedure::name() const {\n+  return _name;\n+}\n+\n+void PeepProcedure::dump() {\n+  output(stderr);\n+}\n+\n+void PeepProcedure::output(FILE* fp) {\n+  fprintf(fp, \"PeepProcedure\\n\");\n+}\n+\n","filename":"src\/hotspot\/share\/adlc\/formsopt.cpp","additions":50,"deletions":2,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,3 +50,0 @@\n-class Peephole;\n-class PeepMatch;\n-class PeepConstraint;\n@@ -70,0 +67,2 @@\n+class Peephole;\n+class PeepPredicate;\n@@ -71,0 +70,1 @@\n+class PeepProcedure;\n@@ -529,0 +529,1 @@\n+  PeepPredicate  *_predicate;      \/\/ Predicate to apply peep rule\n@@ -530,0 +531,1 @@\n+  PeepProcedure  *_procedure;      \/\/ The detailed procedure to perform the rule\n@@ -544,0 +546,1 @@\n+  void add_predicate(PeepPredicate *only_one_predicate);\n@@ -545,0 +548,1 @@\n+  void add_procedure(PeepProcedure *only_one_procedure);\n@@ -550,0 +554,1 @@\n+  PeepPredicate  *predicate()   { return _predicate; }\n@@ -551,0 +556,1 @@\n+  PeepProcedure  *procedure()   { return _procedure; }\n@@ -559,0 +565,13 @@\n+class PeepPredicate : public Form {\n+private:\n+  const char* _rule;\n+public:\n+  \/\/ Public Methods\n+  PeepPredicate(const char* rule);\n+  ~PeepPredicate();\n+\n+  const char* rule() const;\n+\n+  void dump();\n+  void output(FILE* fp);\n+};\n@@ -591,0 +610,13 @@\n+class PeepProcedure : public Form {\n+private:\n+  const char* _name;\n+public:\n+  \/\/ Public Methods\n+  PeepProcedure(const char* name);\n+  ~PeepProcedure();\n+\n+  const char* name() const;\n+\n+  void dump();\n+  void output(FILE* fp);\n+};\n","filename":"src\/hotspot\/share\/adlc\/formsopt.hpp","additions":36,"deletions":4,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -1268,1 +1268,2 @@\n-static void generate_peepreplace( FILE *fp, FormDict &globals, PeepMatch *pmatch, PeepConstraint *pconstraint, PeepReplace *preplace, int max_position ) {\n+static void generate_peepreplace( FILE *fp, FormDict &globals, int peephole_number, PeepMatch *pmatch,\n+                                  PeepConstraint *pconstraint, PeepReplace *preplace, int max_position ) {\n@@ -1317,1 +1318,0 @@\n-        fprintf(fp, \"        ra_->add_reference(root, inst%d);\\n\", inst_num);\n@@ -1343,0 +1343,3 @@\n+  \/\/ Set output of the new node\n+  fprintf(fp, \"        inst0->replace_by(root);\\n\");\n+  \/\/ Mark the node as removed because peephole does not remove nodes from the graph\n@@ -1345,0 +1348,1 @@\n+    fprintf(fp, \"        cfg_->map_node_to_block(inst%d, nullptr);\\n\", i);\n@@ -1346,3 +1350,7 @@\n-  \/\/ Return the new sub-tree\n-  fprintf(fp, \"        deleted = %d;\\n\", max_position+1 \/*zero to one based*\/);\n-  fprintf(fp, \"        return root;  \/\/ return new root;\\n\");\n+  for (int i = 0; i <= max_position; i++) {\n+    fprintf(fp, \"        block->remove_node(block_index - %d);\\n\", i);\n+  }\n+  fprintf(fp, \"        block->insert_node(root, block_index - %d);\\n\", max_position);\n+  fprintf(fp, \"        cfg_->map_node_to_block(root, block);\\n\");\n+  \/\/ Return the peephole index\n+  fprintf(fp, \"        return %d;  \/\/ return the peephole index;\\n\", peephole_number);\n@@ -1356,1 +1364,1 @@\n-  fprintf(fp, \"MachNode *%sNode::peephole(Block *block, int block_index, PhaseRegAlloc *ra_, int &deleted) {\\n\", node->_ident);\n+  fprintf(fp, \"int %sNode::peephole(Block* block, int block_index, PhaseCFG* cfg_, PhaseRegAlloc* ra_) {\\n\", node->_ident);\n@@ -1369,0 +1377,3 @@\n+    if (peep->procedure() != NULL) {\n+      continue;\n+    }\n@@ -1387,0 +1398,1 @@\n+    PeepPredicate  *ppredicate  = peep->predicate();\n@@ -1388,0 +1400,1 @@\n+    PeepProcedure  *pprocedure  = peep->procedure();\n@@ -1396,4 +1409,10 @@\n-    fprintf(fp, \"  if( (OptoPeepholeAt == -1) || (OptoPeepholeAt==%d) ) {\\n\", peephole_number);\n-    fprintf(fp, \"    matches = true;\\n\");\n-    \/\/ Scan the peepmatch and output a test for each instruction\n-    check_peepmatch_instruction_sequence( fp, pmatch, pconstraint );\n+    fprintf(fp, \"  if( ((OptoPeepholeAt == -1) || (OptoPeepholeAt==%d)) && ( %s ) ) {\\n\",\n+            peephole_number, ppredicate != NULL ? ppredicate->rule() : \"true\");\n+    if (pprocedure == NULL) {\n+      fprintf(fp, \"    matches = true;\\n\");\n+      \/\/ Scan the peepmatch and output a test for each instruction\n+      check_peepmatch_instruction_sequence( fp, pmatch, pconstraint );\n+\n+      \/\/ Check constraints and build replacement inside scope\n+      fprintf(fp, \"    \/\/ If instruction subtree matches\\n\");\n+      fprintf(fp, \"    if( matches ) {\\n\");\n@@ -1401,3 +1420,2 @@\n-    \/\/ Check constraints and build replacement inside scope\n-    fprintf(fp, \"    \/\/ If instruction subtree matches\\n\");\n-    fprintf(fp, \"    if( matches ) {\\n\");\n+      \/\/ Generate tests for the constraints\n+      check_peepconstraints( fp, _globalNames, pmatch, pconstraint );\n@@ -1405,2 +1423,2 @@\n-    \/\/ Generate tests for the constraints\n-    check_peepconstraints( fp, _globalNames, pmatch, pconstraint );\n+      \/\/ Construct the new sub-tree\n+      generate_peepreplace( fp, _globalNames, peephole_number, pmatch, pconstraint, preplace, max_position );\n@@ -1408,2 +1426,28 @@\n-    \/\/ Construct the new sub-tree\n-    generate_peepreplace( fp, _globalNames, pmatch, pconstraint, preplace, max_position );\n+      \/\/ End of scope for this peephole's constraints\n+      fprintf(fp, \"    }\\n\");\n+    } else {\n+      const char* replace_inst = NULL;\n+      preplace->next_instruction(replace_inst);\n+      \/\/ Generate the target instruction\n+      fprintf(fp, \"    auto replacing = [](){ return static_cast<MachNode*>(new %sNode()); };\\n\", replace_inst);\n+\n+      \/\/ Call the precedure\n+      fprintf(fp, \"    bool replacement = Peephole::%s(block, block_index, cfg_, ra_, replacing\", pprocedure->name());\n+\n+      int         parent        = -1;\n+      int         inst_position = 0;\n+      const char* inst_name     = NULL;\n+      int         input         = 0;\n+      pmatch->reset();\n+      for (pmatch->next_instruction(parent, inst_position, inst_name, input);\n+           inst_name != NULL;\n+           pmatch->next_instruction(parent, inst_position, inst_name, input)) {\n+        fprintf(fp, \", %s_rule\", inst_name);\n+      }\n+      fprintf(fp, \");\\n\");\n+\n+      \/\/ If substitution succeeded, return the new node\n+      fprintf(fp, \"    if (replacement) {\\n\");\n+      fprintf(fp, \"      return %d;\\n\", peephole_number);\n+      fprintf(fp, \"    }\\n\");\n+    }\n@@ -1411,2 +1455,0 @@\n-    \/\/ End of scope for this peephole's constraints\n-    fprintf(fp, \"    }\\n\");\n@@ -1418,1 +1460,1 @@\n-  fprintf(fp, \"  return NULL;  \/\/ No peephole rules matched\\n\");\n+  fprintf(fp, \"  return -1;  \/\/ No peephole rules matched\\n\");\n","filename":"src\/hotspot\/share\/adlc\/output_c.cpp","additions":62,"deletions":20,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -1706,1 +1706,1 @@\n-      fprintf(fp,\"  virtual MachNode      *peephole(Block *block, int block_index, PhaseRegAlloc *ra_, int &deleted);\\n\");\n+      fprintf(fp,\"  virtual int            peephole(Block* block, int block_index, PhaseCFG* cfg_, PhaseRegAlloc* ra_);\\n\");\n","filename":"src\/hotspot\/share\/adlc\/output_h.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -432,2 +432,2 @@\n-MachNode *MachNode::peephole(Block *block, int block_index, PhaseRegAlloc *ra_, int &deleted) {\n-  return NULL;\n+int MachNode::peephole(Block *block, int block_index, PhaseCFG* cfg_, PhaseRegAlloc *ra_) {\n+  return -1;\n","filename":"src\/hotspot\/share\/opto\/machnode.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -362,1 +362,1 @@\n-  virtual MachNode *peephole(Block *block, int block_index, PhaseRegAlloc *ra_, int &deleted);\n+  virtual int peephole(Block *block, int block_index, PhaseCFG* cfg_, PhaseRegAlloc *ra_);\n","filename":"src\/hotspot\/share\/opto\/machnode.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2153,11 +2153,11 @@\n-    \/\/ and each instruction within a block\n-    uint end_index = block->number_of_nodes();\n-    \/\/ block->end_idx() not valid after PhaseRegAlloc\n-    for( uint instruction_index = 1; instruction_index < end_index; ++instruction_index ) {\n-      Node     *n = block->get_node(instruction_index);\n-      if( n->is_Mach() ) {\n-        MachNode *m = n->as_Mach();\n-        int deleted_count = 0;\n-        \/\/ check for peephole opportunities\n-        MachNode *m2 = m->peephole(block, instruction_index, _regalloc, deleted_count);\n-        if( m2 != NULL ) {\n+    for (bool progress = true; progress;) {\n+      progress = false;\n+      \/\/ block->end_idx() not valid after PhaseRegAlloc\n+      uint end_index = block->number_of_nodes();\n+      for( uint instruction_index = end_index - 1; instruction_index > 0; --instruction_index ) {\n+        Node     *n = block->get_node(instruction_index);\n+        if( n->is_Mach() ) {\n+          MachNode *m = n->as_Mach();\n+          \/\/ check for peephole opportunities\n+          int result = m->peephole(block, instruction_index, &_cfg, _regalloc);\n+          if( result != -1 ) {\n@@ -2165,15 +2165,14 @@\n-          if( PrintOptoPeephole ) {\n-            \/\/ Print method, first time only\n-            if( C->method() && method_name_not_printed ) {\n-              C->method()->print_short_name(); tty->cr();\n-              method_name_not_printed = false;\n-            }\n-            \/\/ Print this block\n-            if( Verbose && block_not_printed) {\n-              tty->print_cr(\"in block\");\n-              block->dump();\n-              block_not_printed = false;\n-            }\n-            \/\/ Print instructions being deleted\n-            for( int i = (deleted_count - 1); i >= 0; --i ) {\n-              block->get_node(instruction_index-i)->as_Mach()->format(_regalloc); tty->cr();\n+            if( PrintOptoPeephole ) {\n+              \/\/ Print method, first time only\n+              if( C->method() && method_name_not_printed ) {\n+                C->method()->print_short_name(); tty->cr();\n+                method_name_not_printed = false;\n+              }\n+              \/\/ Print this block\n+              if( Verbose && block_not_printed) {\n+                tty->print_cr(\"in block\");\n+                block->dump();\n+                block_not_printed = false;\n+              }\n+              \/\/ Print the peephole number\n+              tty->print_cr(\"peephole number: %d\", result);\n@@ -2181,5 +2180,1 @@\n-            tty->print_cr(\"replaced with\");\n-            \/\/ Print new instruction\n-            m2->format(_regalloc);\n-            tty->print(\"\\n\\n\");\n-          }\n+            inc_peepholes();\n@@ -2187,7 +2182,3 @@\n-          \/\/ Remove old nodes from basic block and update instruction_index\n-          \/\/ (old nodes still exist and may have edges pointing to them\n-          \/\/  as register allocation info is stored in the allocator using\n-          \/\/  the node index to live range mappings.)\n-          uint safe_instruction_index = (instruction_index - deleted_count);\n-          for( ; (instruction_index > safe_instruction_index); --instruction_index ) {\n-            block->remove_node( instruction_index );\n+            \/\/ Set progress, start again\n+            progress = true;\n+            break;\n@@ -2195,4 +2186,0 @@\n-          \/\/ install new node after safe_instruction_index\n-          block->insert_node(m2, safe_instruction_index + 1);\n-          end_index = block->number_of_nodes() - 1; \/\/ Recompute new block size\n-          NOT_PRODUCT( inc_peepholes(); )\n","filename":"src\/hotspot\/share\/opto\/phaseX.cpp","additions":29,"deletions":42,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -0,0 +1,128 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.vm.compiler.x86;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Fork(value = 1)\n+@State(Scope.Thread)\n+public class LeaPeephole {\n+    static final int ITERATION = 1000;\n+\n+    int x, y;\n+\n+    @Benchmark\n+    public void B_I_int(Blackhole bh) {\n+        int x = this.x;\n+        int y = this.y;\n+        for (int i = 0; i < ITERATION; i++) {\n+            int x1 = x + y;\n+            x = x1 + y;\n+            y = x1 + x;\n+        }\n+        bh.consume(x);\n+        bh.consume(y);\n+    }\n+\n+    @Benchmark\n+    public void B_D_int(Blackhole bh) {\n+        int x = this.x;\n+        int y = this.y;\n+        for (int i = 0; i < ITERATION; i++) {\n+            bh.consume(x + 10);\n+            bh.consume(x + 20);\n+            bh.consume(x + 30);\n+            bh.consume(y + 10);\n+            bh.consume(y + 20);\n+            bh.consume(y + 30);\n+            x = x >> 1;\n+            y = y >> 2;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void I_S_int(Blackhole bh) {\n+        int x = this.x;\n+        int y = this.y;\n+        for (int i = 0; i < ITERATION; i++) {\n+            bh.consume(x << 1);\n+            bh.consume(x << 2);\n+            bh.consume(x << 3);\n+            bh.consume(y << 1);\n+            bh.consume(y << 2);\n+            bh.consume(y << 3);\n+            x = x >> 1;\n+            y = y >> 2;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void B_I_long(Blackhole bh) {\n+        long x = this.x;\n+        long y = this.y;\n+        for (int i = 0; i < ITERATION; i++) {\n+            long x1 = x + y;\n+            x = x1 + y;\n+            y = x1 + x;\n+        }\n+        bh.consume(x);\n+        bh.consume(y);\n+    }\n+\n+    @Benchmark\n+    public void B_D_long(Blackhole bh) {\n+        long x = this.x;\n+        long y = this.y;\n+        for (int i = 0; i < ITERATION; i++) {\n+            bh.consume(x + 10);\n+            bh.consume(x + 20);\n+            bh.consume(x + 30);\n+            bh.consume(y + 10);\n+            bh.consume(y + 20);\n+            bh.consume(y + 30);\n+            x = x >> 1;\n+            y = y >> 2;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void I_S_long(Blackhole bh) {\n+        long x = this.x;\n+        long y = this.y;\n+        for (int i = 0; i < ITERATION; i++) {\n+            bh.consume(x << 1);\n+            bh.consume(x << 2);\n+            bh.consume(x << 3);\n+            bh.consume(y << 1);\n+            bh.consume(y << 2);\n+            bh.consume(y << 3);\n+            x = x >> 1;\n+            y = y >> 2;\n+        }\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/x86\/LeaPeephole.java","additions":128,"deletions":0,"binary":false,"changes":128,"status":"added"}]}