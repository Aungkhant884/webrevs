{"files":[{"patch":"@@ -4309,0 +4309,14 @@\n+void Assembler::vmovmskps(Register dst, XMMRegister src, int vec_enc) {\n+  assert(VM_Version::supports_avx(), \"\");\n+  InstructionAttr attributes(vec_enc, \/* rex_w *\/ false, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F, &attributes);\n+  emit_int16(0x50, (0xC0 | encode));\n+}\n+\n+void Assembler::vmovmskpd(Register dst, XMMRegister src, int vec_enc) {\n+  assert(VM_Version::supports_avx(), \"\");\n+  InstructionAttr attributes(vec_enc, \/* rex_w *\/ true, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &attributes);\n+  emit_int16(0x50, (0xC0 | encode));\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.cpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -1777,0 +1777,2 @@\n+  void vmovmskps(Register dst, XMMRegister src, int vec_enc);\n+  void vmovmskpd(Register dst, XMMRegister src, int vec_enc);\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -4064,2 +4064,4 @@\n-                                              Register tmp, int masklen, int masksize,\n-                                              int vec_enc) {\n+                                              int masklen, int masksize, int vec_enc) {\n+  assert(VM_Version::supports_popcnt() &&\n+         VM_Version::supports_lzcnt()  &&\n+         VM_Version::supports_bmi1(), \"\");\n@@ -4067,1 +4069,1 @@\n-    kmovql(tmp, mask);\n+    kmovql(dst, mask);\n@@ -4070,1 +4072,1 @@\n-    kmovwl(tmp, mask);\n+    kmovwl(dst, mask);\n@@ -4072,2 +4074,5 @@\n-  if (masksize < 16) {\n-    andq(tmp, (((jlong)1 << masklen) - 1));\n+\n+  \/\/ Mask generated out of partial vector comparisons\/replicate\/mask manipulation\n+  \/\/ operations needs to be clipped.\n+  if (masksize < 16 && opc != Op_VectorMaskFirstTrue) {\n+    andq(dst, (1 << masklen) - 1);\n@@ -4075,0 +4080,1 @@\n+\n@@ -4077,1 +4083,1 @@\n-      popcntq(dst, tmp);\n+      popcntq(dst, dst);\n@@ -4080,3 +4086,3 @@\n-      mov64(dst, -1);\n-      bsrq(tmp, tmp);\n-      cmov(Assembler::notZero, dst, tmp);\n+      lzcntq(dst, dst);\n+      notl(dst);\n+      addl(dst, 64);\n@@ -4085,3 +4091,10 @@\n-      mov64(dst, masklen);\n-      bsfq(tmp, tmp);\n-      cmov(Assembler::notZero, dst, tmp);\n+      if (masklen < 32) {\n+        orl(dst, 1 << masklen);\n+        tzcntl(dst, dst);\n+      } else if (masklen == 32) {\n+        tzcntl(dst, dst);\n+      } else {\n+        tzcntq(dst, dst);\n+      }\n+      break;\n+    case Op_VectorMaskToLong:\n@@ -4094,8 +4107,44 @@\n-                                              XMMRegister xtmp1, Register tmp, int masklen, int masksize,\n-                                              int vec_enc) {\n-  assert(VM_Version::supports_avx(), \"\");\n-  vpxor(xtmp, xtmp, xtmp, vec_enc);\n-  vpsubb(xtmp, xtmp, mask, vec_enc);\n-  vpmovmskb(tmp, xtmp, vec_enc);\n-  if (masksize < 16) {\n-    andq(tmp, (((jlong)1 << masklen) - 1));\n+                                              Register tmp, int masklen, BasicType bt, int vec_enc) {\n+  assert(vec_enc == AVX_128bit && VM_Version::supports_avx() ||\n+         vec_enc == AVX_256bit && (VM_Version::supports_avx2() || type2aelembytes(bt) >= 4), \"\");\n+  assert(VM_Version::supports_popcnt(), \"\");\n+\n+  bool need_clip = false;\n+  switch(bt) {\n+    case T_BOOLEAN:\n+      \/\/ While masks of other types contain 0, -1; boolean masks contain lane values of 0, 1\n+      vpxor(xtmp, xtmp, xtmp, vec_enc);\n+      vpsubb(xtmp, xtmp, mask, vec_enc);\n+      vpmovmskb(tmp, xtmp, vec_enc);\n+      need_clip = masklen < 16;\n+      break;\n+    case T_BYTE:\n+      vpmovmskb(tmp, mask, vec_enc);\n+      need_clip = masklen < 16;\n+      break;\n+    case T_SHORT:\n+      vpacksswb(xtmp, mask, mask, vec_enc);\n+      if (masklen >= 16) {\n+        vpermpd(xtmp, xtmp, 8, vec_enc);\n+      }\n+      vpmovmskb(tmp, xtmp, Assembler::AVX_128bit);\n+      need_clip = masklen < 16;\n+      break;\n+    case T_INT:\n+    case T_FLOAT:\n+      vmovmskps(tmp, mask, vec_enc);\n+      need_clip = masklen < 4;\n+      break;\n+    case T_LONG:\n+    case T_DOUBLE:\n+      vmovmskpd(tmp, mask, vec_enc);\n+      need_clip = masklen < 2;\n+      break;\n+    default: assert(false, \"Unhandled type, %s\", type2name(bt));\n+  }\n+\n+  \/\/ Mask generated out of partial vector comparisons\/replicate\/mask manipulation\n+  \/\/ operations needs to be clipped.\n+  if (need_clip && opc != Op_VectorMaskFirstTrue) {\n+    \/\/ need_clip implies masklen < 32\n+    andq(tmp, (1 << masklen) - 1);\n@@ -4103,0 +4152,1 @@\n+\n@@ -4105,1 +4155,1 @@\n-      popcntq(dst, tmp);\n+      popcntl(dst, tmp);\n@@ -4108,3 +4158,9 @@\n-      mov64(dst, -1);\n-      bsrq(tmp, tmp);\n-      cmov(Assembler::notZero, dst, tmp);\n+      if (VM_Version::supports_lzcnt()) {\n+        lzcntl(tmp, tmp);\n+        movl(dst, 31);\n+        subl(dst, tmp);\n+      } else {\n+        movl(dst, -1);\n+        bsrl(tmp, tmp);\n+        cmov32(Assembler::notZero, dst, tmp);\n+      }\n@@ -4113,3 +4169,20 @@\n-      mov64(dst, masklen);\n-      bsfq(tmp, tmp);\n-      cmov(Assembler::notZero, dst, tmp);\n+      if (VM_Version::supports_bmi1()) {\n+        if (masklen < 32) {\n+          orl(tmp, 1 << masklen);\n+          tzcntl(dst, tmp);\n+        } else {\n+          tzcntl(dst, tmp);\n+        }\n+      } else {\n+        if (masklen < 32) {\n+          orl(tmp, 1 << masklen);\n+          bsfl(dst, tmp);\n+        } else {\n+          movl(dst, masklen);\n+          bsfl(tmp, tmp);\n+          cmov32(Assembler::notZero, dst, tmp);\n+        }\n+      }\n+      break;\n+    case Op_VectorMaskToLong:\n+      assert(dst == tmp, \"Dst and tmp should be the same for toLong operations\");\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":101,"deletions":28,"binary":false,"changes":129,"status":"modified"},{"patch":"@@ -227,1 +227,1 @@\n-  void vector_mask_operation(int opc, Register dst, KRegister mask, Register tmp, int masklen, int masksize, int vec_enc);\n+  void vector_mask_operation(int opc, Register dst, KRegister mask, int masklen, int masksize, int vec_enc);\n@@ -229,2 +229,2 @@\n-  void vector_mask_operation(int opc, Register dst, XMMRegister mask, XMMRegister xtmp, XMMRegister xtmp1,\n-                             Register tmp, int masklen, int masksize, int vec_enc);\n+  void vector_mask_operation(int opc, Register dst, XMMRegister mask, XMMRegister xtmp,\n+                             Register tmp, int masklen, BasicType bt, int vec_enc);\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -8650,1 +8650,1 @@\n-    int mask_len = Matcher::vector_length(this, $mask);\n+    int opcode = this->ideal_Opcode();\n@@ -8652,8 +8652,1 @@\n-    if (VM_Version::supports_avx512vlbw()) {\n-      __ kmovql($dst$$Register, $mask$$KRegister);\n-    } else {\n-      assert(mask_len <= 16, \"\");\n-      __ kmovwl($dst$$Register, $mask$$KRegister);\n-    }\n-    \/\/ Mask generated out of partial vector comparisons\/replicate\/mask manipulation\n-    \/\/ operations needs to be clipped.\n+    int mask_len = Matcher::vector_length(this, $mask);\n@@ -8661,3 +8654,3 @@\n-    if (mask_size < 16) {\n-      __ andq($dst$$Register, (((jlong)1 << mask_len) - 1));\n-    }\n+    int vlen_enc = vector_length_encoding(this, $mask);\n+    __ vector_mask_operation(opcode, $dst$$Register, $mask$$KRegister,\n+                             mask_len, mask_size, vlen_enc);\n@@ -8668,3 +8661,2 @@\n-instruct vmask_tolong_avx(rRegL dst, vec mask, vec xtmp, rFlagsReg cr) %{\n-  predicate(n->in(1)->bottom_type()->isa_vectmask() == NULL &&\n-            n->in(1)->bottom_type()->is_vect()->element_basic_type() == T_BOOLEAN);\n+instruct vmask_tolong_bool(rRegL dst, vec mask, vec xtmp, rFlagsReg cr) %{\n+  predicate(n->in(1)->bottom_type()->isa_vectmask() == NULL);\n@@ -8672,1 +8664,1 @@\n-  format %{ \"vector_tolong_avx $dst, $mask \\t! using $xtmp as TEMP\" %}\n+  format %{ \"vector_tolong_bool $dst, $mask \\t! using $xtmp as TEMP\" %}\n@@ -8675,0 +8667,2 @@\n+    int opcode = this->ideal_Opcode();\n+    BasicType mbt = Matcher::vector_element_basic_type(this, $mask);\n@@ -8676,0 +8670,14 @@\n+    int vlen_enc = vector_length_encoding(this, $mask);\n+    __ vector_mask_operation(opcode, $dst$$Register, $mask$$XMMRegister, $xtmp$$XMMRegister,\n+                             $dst$$Register, mask_len, mbt, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct vmask_tolong_avx(rRegL dst, vec mask, immI size, vec xtmp, rFlagsReg cr) %{\n+  predicate(n->in(1)->in(1)->bottom_type()->isa_vectmask() == NULL);\n+  match(Set dst (VectorMaskToLong (VectorStoreMask mask size)));\n+  format %{ \"vector_tolong_avx $dst, $mask \\t! using $xtmp as TEMP\" %}\n+  effect(TEMP_DEF dst, TEMP xtmp, KILL cr);\n+  ins_encode %{\n+    int opcode = this->ideal_Opcode();\n@@ -8677,0 +8685,1 @@\n+    int mask_len = Matcher::vector_length(this, $mask);\n@@ -8678,9 +8687,2 @@\n-    __ vpxor($xtmp$$XMMRegister, $xtmp$$XMMRegister, $xtmp$$XMMRegister, vlen_enc);\n-    __ vpsubb($xtmp$$XMMRegister, $xtmp$$XMMRegister, $mask$$XMMRegister, vlen_enc);\n-    __ vpmovmskb($dst$$Register, $xtmp$$XMMRegister, vlen_enc);\n-    \/\/ Mask generated out of partial vector comparisons\/replicate\/mask manipulation\n-    \/\/ operations needs to be clipped.\n-    int mask_size = mask_len * type2aelembytes(mbt);\n-    if (mask_size < 16) {\n-      __ andq($dst$$Register, (((jlong)1 << mask_len) - 1));\n-    }\n+    __ vector_mask_operation(opcode, $dst$$Register, $mask$$XMMRegister, $xtmp$$XMMRegister,\n+                             $dst$$Register, mask_len, mbt, vlen_enc);\n@@ -8691,1 +8693,1 @@\n-instruct vmask_truecount_evex(rRegI dst, kReg mask, rRegL tmp, rFlagsReg cr) %{\n+instruct vmask_truecount_evex(rRegI dst, kReg mask, rFlagsReg cr) %{\n@@ -8694,2 +8696,2 @@\n-  effect(TEMP_DEF dst, TEMP tmp, KILL cr);\n-  format %{ \"vector_truecount_evex $dst, $mask \\t! using $tmp as TEMP\" %}\n+  effect(TEMP_DEF dst, KILL cr);\n+  format %{ \"vector_truecount_evex $dst, $mask \\t! vector mask truecount\" %}\n@@ -8702,1 +8704,1 @@\n-    __ vector_mask_operation(opcode, $dst$$Register, $mask$$KRegister, $tmp$$Register,\n+    __ vector_mask_operation(opcode, $dst$$Register, $mask$$KRegister,\n@@ -8708,1 +8710,1 @@\n-instruct vmask_truecount_avx(rRegI dst, vec mask, rRegL tmp, vec xtmp, vec xtmp1, rFlagsReg cr) %{\n+instruct vmask_truecount_bool(rRegI dst, vec mask, rRegL tmp, vec xtmp, rFlagsReg cr) %{\n@@ -8711,2 +8713,18 @@\n-  effect(TEMP_DEF dst, TEMP tmp, TEMP xtmp, TEMP xtmp1, KILL cr);\n-  format %{ \"vector_truecount_avx $dst, $mask \\t! using $tmp, $xtmp and $xtmp1 as TEMP\" %}\n+  effect(TEMP_DEF dst, TEMP tmp, TEMP xtmp, KILL cr);\n+  format %{ \"vector_truecount_bool $dst, $mask \\t! using $tmp, $xtmp as TEMP\" %}\n+  ins_encode %{\n+    int opcode = this->ideal_Opcode();\n+    BasicType mbt = Matcher::vector_element_basic_type(this, $mask);\n+    int mask_len = Matcher::vector_length(this, $mask);\n+    int vlen_enc = vector_length_encoding(this, $mask);\n+    __ vector_mask_operation(opcode, $dst$$Register, $mask$$XMMRegister, $xtmp$$XMMRegister,\n+                             $tmp$$Register, mask_len, mbt, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct vmask_truecount_avx(rRegI dst, vec mask, immI size, rRegL tmp, vec xtmp, rFlagsReg cr) %{\n+  predicate(n->in(1)->in(1)->bottom_type()->isa_vectmask() == NULL);\n+  match(Set dst (VectorMaskTrueCount (VectorStoreMask mask size)));\n+  effect(TEMP_DEF dst, TEMP tmp, TEMP xtmp, KILL cr);\n+  format %{ \"vector_truecount_avx $dst, $mask \\t! using $tmp, $xtmp as TEMP\" %}\n@@ -8717,1 +8735,0 @@\n-    int mask_size = mask_len * type2aelembytes(mbt);\n@@ -8720,1 +8737,1 @@\n-                             $xtmp1$$XMMRegister, $tmp$$Register, mask_len, mask_size, vlen_enc);\n+                             $tmp$$Register, mask_len, mbt, vlen_enc);\n@@ -8725,1 +8742,1 @@\n-instruct vmask_first_or_last_true_evex(rRegI dst, kReg mask, rRegL tmp, rFlagsReg cr) %{\n+instruct vmask_first_or_last_true_evex(rRegI dst, kReg mask, rFlagsReg cr) %{\n@@ -8729,2 +8746,2 @@\n-  effect(TEMP_DEF dst, TEMP tmp, KILL cr);\n-  format %{ \"vector_mask_first_or_last_true_evex $dst, $mask \\t! using $tmp as TEMP\" %}\n+  effect(TEMP_DEF dst, KILL cr);\n+  format %{ \"vector_mask_first_or_last_true_evex $dst, $mask \\t! vector mask first or last true\" %}\n@@ -8737,2 +8754,2 @@\n-    __ vector_mask_operation(opcode, $dst$$Register, $mask$$KRegister, $tmp$$Register, mask_len,\n-                             mask_size, vlen_enc);\n+    __ vector_mask_operation(opcode, $dst$$Register, $mask$$KRegister,\n+                             mask_len, mask_size, vlen_enc);\n@@ -8743,1 +8760,1 @@\n-instruct vmask_first_or_last_true_avx(rRegI dst, vec mask, rRegL tmp, vec xtmp, vec xtmp1, rFlagsReg cr) %{\n+instruct vmask_first_or_last_true_bool(rRegI dst, vec mask, rRegL tmp, vec xtmp, rFlagsReg cr) %{\n@@ -8747,2 +8764,19 @@\n-  effect(TEMP_DEF dst, TEMP tmp, TEMP xtmp, TEMP xtmp1, KILL cr);\n-  format %{ \"vector_mask_first_or_last_true_avx $dst, $mask \\t! using $tmp, $xtmp and $xtmp1 as TEMP\" %}\n+  effect(TEMP_DEF dst, TEMP tmp, TEMP xtmp, KILL cr);\n+  format %{ \"vector_mask_first_or_last_true_bool $dst, $mask \\t! using $tmp, $xtmp as TEMP\" %}\n+  ins_encode %{\n+    int opcode = this->ideal_Opcode();\n+    BasicType mbt = Matcher::vector_element_basic_type(this, $mask);\n+    int mask_len = Matcher::vector_length(this, $mask);\n+    int vlen_enc = vector_length_encoding(this, $mask);\n+    __ vector_mask_operation(opcode, $dst$$Register, $mask$$XMMRegister, $xtmp$$XMMRegister,\n+                             $tmp$$Register, mask_len, mbt, vlen_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct vmask_first_or_last_true_avx(rRegI dst, vec mask, immI size, rRegL tmp, vec xtmp, rFlagsReg cr) %{\n+  predicate(n->in(1)->in(1)->bottom_type()->isa_vectmask() == NULL);\n+  match(Set dst (VectorMaskFirstTrue (VectorStoreMask mask size)));\n+  match(Set dst (VectorMaskLastTrue (VectorStoreMask mask size)));\n+  effect(TEMP_DEF dst, TEMP tmp, TEMP xtmp, KILL cr);\n+  format %{ \"vector_mask_first_or_last_true_avx $dst, $mask \\t! using $tmp, $xtmp as TEMP\" %}\n@@ -8753,1 +8787,0 @@\n-    int mask_size = mask_len * type2aelembytes(mbt);\n@@ -8756,1 +8789,1 @@\n-                             $xtmp1$$XMMRegister, $tmp$$Register, mask_len, mask_size, vlen_enc);\n+                             $tmp$$Register, mask_len, mbt, vlen_enc);\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":77,"deletions":44,"binary":false,"changes":121,"status":"modified"}]}