{"files":[{"patch":"@@ -3476,1 +3476,4 @@\n-        if(scale==0) {\n+        int scale = this.scale;\n+        long intCompact = this.intCompact;\n+\n+        if (scale == 0)\n@@ -3478,3 +3481,7 @@\n-        }\n-        if(this.scale<0) { \/\/ No decimal point\n-            if(signum()==0) {\n+        \/\/ currency fast path\n+        if (scale == 2 && intCompact != INFLATED)\n+            return ConcatHelper.scale2(intCompact);\n+\n+        int signum = signum();\n+        if (this.scale < 0) { \/\/ No decimal point\n+            if (signum == 0)\n@@ -3482,1 +3489,1 @@\n-            }\n+\n@@ -3485,3 +3492,3 @@\n-            if(intCompact!=INFLATED) {\n-                buf = new StringBuilder(20+trailingZeros);\n-                buf.append(intCompact);\n+            if (intCompact != INFLATED) {\n+                buf = new StringBuilder(20 + trailingZeros)\n+                        .append(intCompact);\n@@ -3490,5 +3497,2 @@\n-                buf = new StringBuilder(str.length()+trailingZeros);\n-                buf.append(str);\n-            }\n-            for (int i = 0; i < trailingZeros; i++) {\n-                buf.append('0');\n+                buf = new StringBuilder(str.length() + trailingZeros)\n+                        .append(str);\n@@ -3496,1 +3500,2 @@\n-            return buf.toString();\n+            return buf.repeat('0', trailingZeros)\n+                    .toString();\n@@ -3498,2 +3503,2 @@\n-        String str = unscaledAbsString();\n-        return getValueString(signum(), str, scale);\n+\n+        return layoutCharsPlain(signum, unscaledAbsString(), scale);\n@@ -3502,2 +3507,8 @@\n-    \/* Returns a digit.digit string *\/\n-    private String getValueString(int signum, String intString, int scale) {\n+    \/**\n+     *\n+     * @param signum\n+     * @param coeff the significand as an absolute value\n+     * @param scale\n+     * @return\n+     *\/\n+    private static String layoutCharsPlain(int signum, String coeff, int scale) {\n@@ -3505,0 +3516,5 @@\n+        int coeffLen = coeff.length();\n+        int insertionPoint = coeffLen - scale;\n+        if (insertionPoint == 0)  \/* Point goes right before intVal *\/\n+            return (signum < 0 ? \"-0.\" : \"0.\").concat(coeff);\n+\n@@ -3506,6 +3522,2 @@\n-        int insertionPoint = intString.length() - scale;\n-        if (insertionPoint == 0) {  \/* Point goes right before intVal *\/\n-            return (signum<0 ? \"-0.\" : \"0.\") + intString;\n-        } else if (insertionPoint > 0) { \/* Point goes inside intVal *\/\n-            buf = new StringBuilder(intString);\n-            buf.insert(insertionPoint, '.');\n+        if (insertionPoint > 0) { \/* Point goes inside intVal *\/\n+            buf = new StringBuilder();\n@@ -3513,1 +3525,3 @@\n-                buf.insert(0, '-');\n+                buf.append('-');\n+            buf.append(coeff)\n+               .insert(insertionPoint + (signum < 0 ? 1 : 0), '.');\n@@ -3515,6 +3529,4 @@\n-            buf = new StringBuilder(3-insertionPoint + intString.length());\n-            buf.append(signum<0 ? \"-0.\" : \"0.\");\n-            for (int i=0; i<-insertionPoint; i++) {\n-                buf.append('0');\n-            }\n-            buf.append(intString);\n+            buf = new StringBuilder(3 - insertionPoint + coeffLen)\n+                    .append(signum < 0 ? \"-0.\" : \"0.\")\n+                    .repeat('0', -insertionPoint)\n+                    .append(coeff);\n@@ -4144,3 +4156,4 @@\n-    static final class ConcatHelper {\n-        private static final MethodHandle NEGATIVE_ZERO_CHAR_CHAR;\n-        private static final MethodHandle LONG_DOT_CHAR_CHAR;\n+    private static final class ConcatHelper {\n+        static final MethodHandle NEGATIVE_ZERO_CHAR_CHAR;\n+        static final MethodHandle LONG_DOT_CHAR_CHAR;\n+        static final MethodHandle INT_DOT_CHAR_CHAR;\n@@ -4149,10 +4162,8 @@\n-                NEGATIVE_ZERO_CHAR_CHAR\n-                        = StringConcatFactory.makeConcatWithConstants(\n-                            MethodHandles.lookup(),\n-                            \"neg_zero_scale2\",\n-                            MethodType.methodType(String.class, char.class, char.class),\n-                            \"-0.\\1\\1\"\n-                        ).dynamicInvoker();\n-                LONG_DOT_CHAR_CHAR\n-                        = StringConcatFactory.makeConcatWithConstants(\n-                        MethodHandles.lookup(),\n+                MethodHandles.Lookup lookup = MethodHandles.lookup();\n+                NEGATIVE_ZERO_CHAR_CHAR = StringConcatFactory.makeConcatWithConstants(\n+                        lookup,\n+                        \"neg_zero_scale2\",\n+                        MethodType.methodType(String.class, char.class, char.class),\n+                        \"-0.\\1\\1\").dynamicInvoker();\n+                LONG_DOT_CHAR_CHAR = StringConcatFactory.makeConcatWithConstants(\n+                        lookup,\n@@ -4161,2 +4172,6 @@\n-                        \"\\1.\\1\\1\"\n-                ).dynamicInvoker();\n+                        \"\\1.\\1\\1\").dynamicInvoker();\n+                INT_DOT_CHAR_CHAR = StringConcatFactory.makeConcatWithConstants(\n+                        lookup,\n+                        \"scale2\",\n+                        MethodType.methodType(String.class, int.class, char.class, char.class),\n+                        \"\\1.\\1\\1\").dynamicInvoker();\n@@ -4174,1 +4189,1 @@\n-                if (highInt == 0 && intCompact < 0) {\n+                if (highInt == 0 && intCompact < 0)\n@@ -4176,1 +4191,3 @@\n-                }\n+\n+                if (highInt >= Integer.MIN_VALUE && highInt <= Integer.MAX_VALUE)\n+                    return (String) INT_DOT_CHAR_CHAR.invokeExact((int) highInt, c0, c1);\n@@ -4199,2 +4216,2 @@\n-        if (scale == 2 && intCompact != INFLATED) {\n-            \/\/ currency fast path\n+        \/\/ currency fast path\n+        if (scale == 2 && intCompact != INFLATED)\n@@ -4202,1 +4219,0 @@\n-        }\n@@ -4214,14 +4230,1 @@\n-            StringBuilder buf = new StringBuilder(32);\n-            if (signum() < 0)             \/\/ prefix '-' if negative\n-                buf.append('-');\n-            int pad = scale - coeffLen;         \/\/ count of padding zeros\n-            if (pad >= 0) {                     \/\/ 0.xxx form\n-                buf.append(\"0.\")\n-                   .repeat('0', pad)\n-                   .append(coeff, 0, coeffLen);\n-            } else {                         \/\/ xx.xx form\n-                buf.append(coeff, 0, -pad)\n-                   .append('.')\n-                   .append(coeff, -pad, coeffLen);\n-            }\n-            return buf.toString();\n+            return layoutCharsPlain(signum(), coeff, scale);\n@@ -4235,1 +4238,2 @@\n-        if (signum() < 0)             \/\/ prefix '-' if negative\n+        int signum = signum();\n+        if (signum < 0)                  \/\/ prefix '-' if negative\n@@ -4241,1 +4245,1 @@\n-                        .append(coeff, 1, coeffLen);\n+                   .append(coeff, 1, coeffLen);\n@@ -4249,1 +4253,1 @@\n-            if (signum() == 0) {\n+            if (signum == 0) {\n@@ -4265,1 +4269,1 @@\n-            } else if (sig >= coeffLen) {   \/\/ significand all in integer\n+            } else if (sig >= coeffLen) {\/\/ significand all in integer\n@@ -4267,1 +4271,1 @@\n-                        .repeat('0', sig - coeffLen); \/\/ may need some zeros, too\n+                   .repeat('0', sig - coeffLen); \/\/ may need some zeros, too\n@@ -4270,2 +4274,2 @@\n-                        .append('.')\n-                        .append(coeff, sig, coeffLen);\n+                   .append('.')\n+                   .append(coeff, sig, coeffLen);\n","filename":"src\/java.base\/share\/classes\/java\/math\/BigDecimal.java","additions":76,"deletions":72,"binary":false,"changes":148,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+import java.lang.invoke.*;\n@@ -48,1 +49,1 @@\n-@Fork(value = 3)\n+@Fork(value = 3, jvmArgsAppend = {\"--add-opens\", \"java.base\/java.math=ALL-UNNAMED\"})\n@@ -63,1 +64,3 @@\n-    private BigDecimal[] hugeArray, largeArray, smallArray;\n+    private BigDecimal[] hugeArray;\n+    private BigDecimal[] large2Array, small2Array;\n+    private BigDecimal[] large3Array, small3Array;\n@@ -99,3 +102,4 @@\n-        * Large numbers less than MAX_LONG but larger than MAX_INT\n-        *\/\n-        largeArray = new BigDecimal[TEST_SIZE];\n+         * Large numbers less than MAX_LONG but larger than MAX_INT\n+         *\/\n+        large2Array = new BigDecimal[TEST_SIZE];\n+        large3Array = new BigDecimal[TEST_SIZE];\n@@ -104,3 +108,4 @@\n-        * Small number less than MAX_INT\n-        *\/\n-        smallArray = new BigDecimal[TEST_SIZE];\n+         * Small number less than MAX_INT\n+         *\/\n+        small2Array = new BigDecimal[TEST_SIZE];\n+        small3Array = new BigDecimal[TEST_SIZE];\n@@ -113,2 +118,6 @@\n-            largeArray[i] = new BigDecimal(\"\" + ((long) value + (long) Integer.MAX_VALUE) + \".55\");\n-            smallArray[i] = new BigDecimal(\"\" + ((long) value \/ 1000) + \".55\");\n+\n+            large2Array[i] = new BigDecimal(\"\" + ((long) value + (long) Integer.MAX_VALUE) + \".55\");\n+            large3Array[i] = new BigDecimal(\"\" + ((long) value + (long) Integer.MAX_VALUE) + \".555\");\n+\n+            small2Array[i] = new BigDecimal(\"\" + ((long) value \/ 1000) + \".55\");\n+            small3Array[i] = new BigDecimal(\"\" + ((long) value \/ 1000) + \".555\");\n@@ -136,17 +145,0 @@\n-    \/** Invokes the toString method of BigDecimal with various different values. *\/\n-    @Benchmark\n-    @OperationsPerInvocation(TEST_SIZE)\n-    public void testToString(Blackhole bh) {\n-        for (BigDecimal s : bigDecimals) {\n-            bh.consume(s.toString());\n-        }\n-    }\n-\n-    @Benchmark\n-    @OperationsPerInvocation(TEST_SIZE)\n-    public void testToEngineeringString(Blackhole bh) {\n-        for (BigDecimal s : bigDecimals) {\n-            bh.consume(s.toEngineeringString());\n-        }\n-    }\n-\n@@ -215,1 +207,1 @@\n-    \/** Test BigDecimal.toString() with huge numbers larger than MAX_LONG *\/\n+    \/** Test BigDecimal.toString() with large numbers (scale 2) less than MAX_LONG but larger than MAX_INT *\/\n@@ -218,1 +210,1 @@\n-    public void testHugeToString(Blackhole bh) {\n+    public void hugeLayoutCharsToString(Blackhole bh) throws Throwable {\n@@ -220,1 +212,1 @@\n-            bh.consume(s.toString());\n+            bh.consume((String) BigDecimalAccess.layoutChars.invokeExact(s, true));\n@@ -224,0 +216,1 @@\n+    \/** Test BigDecimal.toEngineeringString() with huge numbers larger than MAX_LONG *\/\n@@ -226,1 +219,1 @@\n-    public void testHugeToEngineeringString(Blackhole bh) {\n+    public void hugeEngineeringToString(Blackhole bh) {\n@@ -232,1 +225,56 @@\n-    \/** Test BigDecimal.toString() with large numbers less than MAX_LONG but larger than MAX_INT *\/\n+    \/** Test BigDecimal.toEngineeringString() with huge numbers larger than MAX_LONG *\/\n+    @Benchmark\n+    @OperationsPerInvocation(TEST_SIZE)\n+    public void hugePlainToString(Blackhole bh) {\n+        for (BigDecimal s : hugeArray) {\n+            bh.consume(s.toPlainString());\n+        }\n+    }\n+\n+    \/** Test BigDecimal.toString() with large numbers (scale 2) less than MAX_LONG but larger than MAX_INT *\/\n+    @Benchmark\n+    @OperationsPerInvocation(TEST_SIZE)\n+    public void largeScale2LayoutCharsToString(Blackhole bh) throws Throwable {\n+        for (BigDecimal s : large2Array) {\n+            bh.consume((String) BigDecimalAccess.layoutChars.invokeExact(s, true));\n+        }\n+    }\n+\n+    \/** Test BigDecimal.toEngineeringString() with large numbers (scale 2) less than MAX_LONG but larger than MAX_INT *\/\n+    @Benchmark\n+    @OperationsPerInvocation(TEST_SIZE)\n+    public void largeScale2EngineeringToString(Blackhole bh) {\n+        for (BigDecimal s : large2Array) {\n+            bh.consume(s.toEngineeringString());\n+        }\n+    }\n+\n+    \/** Test BigDecimal.toPlainString() with large numbers (scale 2) less than MAX_LONG but larger than MAX_INT *\/\n+    @Benchmark\n+    @OperationsPerInvocation(TEST_SIZE)\n+    public void largeScale2PlainToString(Blackhole bh) {\n+        for (BigDecimal s : large2Array) {\n+            bh.consume(s.toPlainString());\n+        }\n+    }\n+\n+    \/** Test BigDecimal.toString() with large numbers (scale 3) less than MAX_LONG but larger than MAX_INT *\/\n+    @Benchmark\n+    @OperationsPerInvocation(TEST_SIZE)\n+    public void largeScale3LayoutCharsToString(Blackhole bh) throws Throwable {\n+        for (BigDecimal s : large3Array) {\n+            bh.consume((String) BigDecimalAccess.layoutChars.invokeExact(s, true));\n+        }\n+    }\n+\n+    \/** Test BigDecimal.toEngineeringString() with large numbers (scale 3) less than MAX_LONG but larger than MAX_INT *\/\n+    @Benchmark\n+    @OperationsPerInvocation(TEST_SIZE)\n+    public void largeScale3EngineeringToString(Blackhole bh) {\n+        for (BigDecimal s : large3Array) {\n+            bh.consume(s.toEngineeringString());\n+        }\n+    }\n+\n+\n+    \/** Test BigDecimal.toPlainString() with large numbers (scale 3) less than MAX_LONG but larger than MAX_INT *\/\n@@ -235,3 +283,3 @@\n-    public void testLargeToString(Blackhole bh) {\n-        for (BigDecimal s : largeArray) {\n-            bh.consume(s.toString());\n+    public void largeScale3PlainToString(Blackhole bh) {\n+        for (BigDecimal s : large3Array) {\n+            bh.consume(s.toPlainString());\n@@ -241,0 +289,1 @@\n+    \/** Test BigDecimal.toString() with small numbers (scale 2) less than MAX_INT *\/\n@@ -243,2 +292,11 @@\n-    public void testLargeToEngineeringString(Blackhole bh) {\n-        for (BigDecimal s : largeArray) {\n+    public void smallScale2LayoutCharsToString(Blackhole bh) throws Throwable {\n+        for (BigDecimal s : small2Array) {\n+            bh.consume((String) BigDecimalAccess.layoutChars.invokeExact(s, true));\n+        }\n+    }\n+\n+    \/** Test BigDecimal.toEngineeringString() with small numbers (scale 2) less than MAX_INT *\/\n+    @Benchmark\n+    @OperationsPerInvocation(TEST_SIZE)\n+    public void smallScale2EngineeringToString(Blackhole bh) {\n+        for (BigDecimal s : small2Array) {\n@@ -249,1 +307,1 @@\n-    \/** Test BigDecimal.toString() with small numbers less than MAX_INT *\/\n+    \/** Test BigDecimal.toPlainString() with small numbers (scale 3) less than MAX_INT *\/\n@@ -252,3 +310,3 @@\n-    public void testSmallToString(Blackhole bh) {\n-        for (BigDecimal s : smallArray) {\n-            bh.consume(s.toString());\n+    public void smallScale2PlainToString(Blackhole bh) {\n+        for (BigDecimal s : small2Array) {\n+            bh.consume(s.toPlainString());\n@@ -258,0 +316,1 @@\n+    \/** Test BigDecimal.toString() with small numbers (scale 3) less than MAX_INT *\/\n@@ -260,2 +319,11 @@\n-    public void testSmallToEngineeringString(Blackhole bh) {\n-        for (BigDecimal s : smallArray) {\n+    public void smallScale3LayoutCharsToString(Blackhole bh) throws Throwable {\n+        for (BigDecimal s : small3Array) {\n+            bh.consume((String) BigDecimalAccess.layoutChars.invokeExact(s, true));\n+        }\n+    }\n+\n+    \/** Test BigDecimal.toEngineeringString() with small numbers (scale 3) less than MAX_INT *\/\n+    @Benchmark\n+    @OperationsPerInvocation(TEST_SIZE)\n+    public void smallScale3EngineeringToString(Blackhole bh) {\n+        for (BigDecimal s : small3Array) {\n@@ -265,0 +333,21 @@\n+\n+    \/** Test BigDecimal.toPlainString() with small numbers (scale 3) less than MAX_INT *\/\n+    @Benchmark\n+    @OperationsPerInvocation(TEST_SIZE)\n+    public void smallScale3PlainToString(Blackhole bh) {\n+        for (BigDecimal s : small3Array) {\n+            bh.consume(s.toPlainString());\n+        }\n+    }\n+\n+    static class BigDecimalAccess {\n+        final static MethodHandle layoutChars;\n+        static {\n+            try {\n+                MethodHandles.Lookup lookup = MethodHandles.privateLookupIn(BigDecimal.class, MethodHandles.lookup());\n+                layoutChars = lookup.findVirtual(BigDecimal.class, \"layoutChars\", MethodType.methodType(String.class, boolean.class));\n+            } catch (Throwable e) {\n+                throw new AssertionError(e);\n+            }\n+        }\n+    }\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/math\/BigDecimals.java","additions":132,"deletions":43,"binary":false,"changes":175,"status":"modified"}]}