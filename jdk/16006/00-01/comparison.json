{"files":[{"patch":"@@ -749,35 +749,0 @@\n-    \/**\n-     * Appends the string representation of a subarray of the latin1 encoded\n-     * {@code byte} array argument to this sequence.\n-     * <p>\n-     * Characters of the {@code char} array {@code str}, starting at\n-     * index {@code offset}, are appended, in order, to the contents\n-     * of this sequence. The length of this sequence increases\n-     * by the value of {@code len}.\n-     * <p>\n-     * The overall effect is exactly as if the arguments were converted\n-     * to a string by the method {@link String#valueOf(char[],int,int)},\n-     * and the characters of that string were then\n-     * {@link #append(String) appended} to this character sequence.\n-     *\n-     * @param   str      the latin1 encoded characters to be appended.\n-     * @param   offset   the index of the first {@code char} to append.\n-     * @param   len      the number of {@code char}s to append.\n-     * @return  a reference to this object.\n-     * @throws IndexOutOfBoundsException\n-     *         if {@code offset < 0} or {@code len < 0}\n-     *         or {@code offset+len > str.length}\n-     *\/\n-    AbstractStringBuilder append(byte[] str, int off, int len) {\n-        int count = this.count;\n-        int spaceNeeded = count + len;\n-        ensureCapacityInternal(spaceNeeded);\n-        if (isLatin1()) {\n-            System.arraycopy(str, off, value, count, len);\n-        } else {\n-            StringLatin1.inflate(str, off, value, count, len);\n-        }\n-        this.count += len;\n-        return this;\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/AbstractStringBuilder.java","additions":0,"deletions":35,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -190,1 +190,1 @@\n-    static void writeDigitPair(byte[] buf, int charPos, int value) {\n+    private static void writeDigitPair(byte[] buf, int charPos, int value) {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StringLatin1.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2547,4 +2547,0 @@\n-            public void stringBuilderAppend(StringBuilder sb, byte[] str, int off, int len) {\n-                sb.append(str, off, len);\n-            }\n-\n@@ -2555,4 +2551,0 @@\n-            public int stringSize(long i) {\n-                return Long.stringSize(i);\n-            }\n-\n@@ -2563,8 +2555,0 @@\n-            public int getCharsLatin1(long i, int index, byte[] buf) {\n-                return StringLatin1.getChars(i, index, buf);\n-            }\n-\n-            public void writeDigitPairLatin1(byte[] buf, int charPos, int value) {\n-                StringLatin1.writeDigitPair(buf, charPos, value);\n-            }\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":0,"deletions":16,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+import jdk.internal.util.DecimalDigits;\n@@ -3481,5 +3482,1 @@\n-            if(intCompact!=INFLATED) {\n-                return Long.toString(intCompact);\n-            } else {\n-                return intVal.toString();\n-            }\n+            return unscaledString();\n@@ -3506,6 +3503,1 @@\n-        String str ;\n-        if(intCompact!=INFLATED) {\n-            str = Long.toString(Math.abs(intCompact));\n-        } else {\n-            str = intVal.abs().toString();\n-        }\n+        String str = unscaledAbsString();\n@@ -4157,39 +4149,0 @@\n-    \/\/ Private class to build a string representation for BigDecimal object. The\n-    \/\/ StringBuilder field acts as a buffer to hold the temporary representation\n-    \/\/ of BigDecimal. The cmpCharArray holds all the characters for the compact\n-    \/\/ representation of BigDecimal (except for '-' sign' if it is negative) if\n-    \/\/ its intCompact field is not INFLATED.\n-    static class StringBuilderHelper {\n-        final StringBuilder sb;    \/\/ Placeholder for BigDecimal string\n-        final byte[] cmpCharArray; \/\/ character array to place the intCompact\n-\n-        StringBuilderHelper() {\n-            sb = new StringBuilder(32);\n-            \/\/ All non negative longs can be made to fit into 19 character array.\n-            cmpCharArray = new byte[19];\n-        }\n-\n-        \/\/ Accessors.\n-        StringBuilder getStringBuilder() {\n-            sb.setLength(0);\n-            return sb;\n-        }\n-\n-        byte[] getCompactCharArray() {\n-            return cmpCharArray;\n-        }\n-\n-        \/**\n-         * Places characters representing the intCompact in {@code long} into\n-         * cmpCharArray and returns the offset to the array where the\n-         * representation starts.\n-         *\n-         * @param intCompact the number to put into the cmpCharArray.\n-         * @return offset to the array where the representation starts.\n-         * Note: intCompact must be greater or equal to zero.\n-         *\/\n-        int putIntCompact(long intCompact) {\n-            return JLA.getCharsLatin1(intCompact, cmpCharArray.length, cmpCharArray);\n-        }\n-    }\n-\n@@ -4206,0 +4159,2 @@\n+        int scale = this.scale;\n+        long intCompact = this.intCompact;\n@@ -4207,3 +4162,1 @@\n-            return (intCompact != INFLATED) ?\n-                Long.toString(intCompact):\n-                intVal.toString();\n+            return unscaledString();\n@@ -4213,0 +4166,1 @@\n+            int lowInt = (int)intCompact % 100;\n@@ -4214,1 +4168,0 @@\n-            int lowInt = (int) intCompact - highInt * 100;\n@@ -4219,1 +4172,4 @@\n-            JLA.writeDigitPairLatin1(buf, highIntSize + 1, lowInt);\n+            DecimalDigits.writeDigitPairLatin1(\n+                    buf,\n+                    highIntSize + 1,\n+                    (int) intCompact - highInt * 100);\n@@ -4227,3 +4183,0 @@\n-        StringBuilderHelper sbHelper = new StringBuilderHelper();\n-        byte[] coeff;\n-        int offset;  \/\/ offset is the starting index for coeff array\n@@ -4231,7 +4184,1 @@\n-        if (intCompact != INFLATED) {\n-            offset = sbHelper.putIntCompact(Math.abs(intCompact));\n-            coeff  = sbHelper.getCompactCharArray();\n-        } else {\n-            offset = 0;\n-            coeff = intVal.abs().toString().getBytes(StandardCharsets.ISO_8859_1);\n-        }\n+        String coeff = unscaledAbsString();\n@@ -4243,4 +4190,1 @@\n-        StringBuilder buf = sbHelper.getStringBuilder();\n-        if (signum() < 0)             \/\/ prefix '-' if negative\n-            buf.append('-');\n-        int coeffLen = coeff.length - offset;\n+        int coeffLen = coeff.length();\n@@ -4249,0 +4193,3 @@\n+            StringBuilder buf = new StringBuilder(32);\n+            if (signum() < 0)             \/\/ prefix '-' if negative\n+                buf.append('-');\n@@ -4251,6 +4198,3 @@\n-                buf.append('0');\n-                buf.append('.');\n-                for (; pad>0; pad--) {\n-                    buf.append('0');\n-                }\n-                JLA.stringBuilderAppend(buf, coeff, offset, coeffLen);\n+                buf.append(\"0.\")\n+                   .repeat('0', pad)\n+                   .append(coeff, 0, coeffLen);\n@@ -4258,3 +4202,3 @@\n-                JLA.stringBuilderAppend(buf, coeff, offset, -pad);\n-                buf.append('.');\n-                JLA.stringBuilderAppend(buf, coeff, -pad + offset, scale);\n+                buf.append(coeff, 0, -pad)\n+                   .append('.')\n+                   .append(coeff, -pad, coeffLen);\n@@ -4262,15 +4206,24 @@\n-        } else { \/\/ E-notation is needed\n-            if (sci) {                       \/\/ Scientific notation\n-                buf.append((char) coeff[offset]);   \/\/ first character\n-                if (coeffLen > 1) {          \/\/ more to come\n-                    buf.append('.');\n-                    JLA.stringBuilderAppend(buf, coeff, offset + 1, coeffLen - 1);\n-                }\n-            } else {                         \/\/ Engineering notation\n-                int sig = (int)(adjusted % 3);\n-                if (sig < 0)\n-                    sig += 3;                \/\/ [adjusted was negative]\n-                adjusted -= sig;             \/\/ now a multiple of 3\n-                sig++;\n-                if (signum() == 0) {\n-                    switch (sig) {\n+            return buf.toString();\n+        }\n+        \/\/ E-notation is needed\n+        return layoutCharsE(sci, coeff, coeffLen, adjusted);\n+    }\n+\n+    private String layoutCharsE(boolean sci, String coeff, int coeffLen, long adjusted) {\n+        StringBuilder buf = new StringBuilder(32);\n+        if (signum() < 0)             \/\/ prefix '-' if negative\n+            buf.append('-');\n+        if (sci) {                       \/\/ Scientific notation\n+            buf.append(coeff.charAt(0)); \/\/ first character\n+            if (coeffLen > 1) {          \/\/ more to come\n+                buf.append('.')\n+                        .append(coeff, 1, coeffLen);\n+            }\n+        } else {                         \/\/ Engineering notation\n+            int sig = (int)(adjusted % 3);\n+            if (sig < 0)\n+                sig += 3;                \/\/ [adjusted was negative]\n+            adjusted -= sig;             \/\/ now a multiple of 3\n+            sig++;\n+            if (signum() == 0) {\n+                switch (sig) {\n@@ -4290,11 +4243,0 @@\n-                    }\n-                } else if (sig >= coeffLen) {   \/\/ significand all in integer\n-                    JLA.stringBuilderAppend(buf, coeff, offset, coeffLen);\n-                    \/\/ may need some zeros, too\n-                    for (int i = sig - coeffLen; i > 0; i--) {\n-                        buf.append('0');\n-                    }\n-                } else {                     \/\/ xx.xxE form\n-                    JLA.stringBuilderAppend(buf, coeff, offset, sig);\n-                    buf.append('.');\n-                    JLA.stringBuilderAppend(buf, coeff, offset + sig, coeffLen - sig);\n@@ -4302,6 +4244,7 @@\n-            }\n-            if (adjusted != 0) {             \/\/ [!sci could have made 0]\n-                buf.append('E');\n-                if (adjusted > 0)            \/\/ force sign for positive\n-                    buf.append('+');\n-                buf.append(adjusted);\n+            } else if (sig >= coeffLen) {   \/\/ significand all in integer\n+                buf.append(coeff, 0, coeffLen)\n+                        .repeat('0', sig - coeffLen); \/\/ may need some zeros, too\n+            } else {                     \/\/ xx.xxE form\n+                buf.append(coeff, 0, sig)\n+                        .append('.')\n+                        .append(coeff, sig, coeffLen);\n@@ -4310,0 +4253,6 @@\n+        if (adjusted != 0) {             \/\/ [!sci could have made 0]\n+            buf.append('E');\n+            if (adjusted > 0)            \/\/ force sign for positive\n+                buf.append('+');\n+            buf.append(adjusted);\n+        }\n@@ -4313,0 +4262,15 @@\n+    \/**\n+     * Get the significand as an absolute value\n+     *\/\n+    private String unscaledAbsString() {\n+        return intCompact != INFLATED\n+                ? Long.toString(Math.abs(intCompact))\n+                : intVal.abs().toString();\n+    }\n+\n+    private String unscaledString() {\n+        return intCompact != INFLATED\n+                ? Long.toString(intCompact)\n+                : intVal.toString();\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/math\/BigDecimal.java","additions":74,"deletions":110,"binary":false,"changes":184,"status":"modified"},{"patch":"@@ -449,5 +449,0 @@\n-    \/**\n-     * Appends the string representation of a subarray of the latin1 encoded {@code byte} array argument to StringBuilder\n-     *\/\n-    void stringBuilderAppend(StringBuilder sb, byte[] str, int off, int len);\n-\n@@ -456,2 +451,0 @@\n-    int stringSize(long i);\n-\n@@ -460,4 +453,0 @@\n-    int getCharsLatin1(long i, int index, byte[] buf);\n-\n-    void writeDigitPairLatin1(byte[] buf, int charPos, int value);\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangAccess.java","additions":0,"deletions":11,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -162,0 +162,6 @@\n+\n+    public static void writeDigitPairLatin1(byte[] buf, int charPos, int value) {\n+        short pair = DIGITS[value];\n+        buf[charPos] = (byte)(pair);\n+        buf[charPos + 1] = (byte)(pair >> 8);\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/DecimalDigits.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"}]}