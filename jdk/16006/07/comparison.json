{"files":[{"patch":"@@ -33,0 +33,2 @@\n+import java.lang.invoke.*;\n+import java.nio.charset.StandardCharsets;\n@@ -41,0 +43,4 @@\n+import jdk.internal.util.DecimalDigits;\n+import jdk.internal.access.JavaLangAccess;\n+import jdk.internal.access.SharedSecrets;\n+\n@@ -310,0 +316,1 @@\n+    private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();\n@@ -3474,5 +3481,1 @@\n-            if(intCompact!=INFLATED) {\n-                return Long.toString(intCompact);\n-            } else {\n-                return intVal.toString();\n-            }\n+            return unscaledString();\n@@ -3499,6 +3502,1 @@\n-        String str ;\n-        if(intCompact!=INFLATED) {\n-            str = Long.toString(Math.abs(intCompact));\n-        } else {\n-            str = intVal.abs().toString();\n-        }\n+        String str = unscaledAbsString();\n@@ -4150,23 +4148,14 @@\n-    \/\/ Private class to build a string representation for BigDecimal object. The\n-    \/\/ StringBuilder field acts as a buffer to hold the temporary representation\n-    \/\/ of BigDecimal. The cmpCharArray holds all the characters for the compact\n-    \/\/ representation of BigDecimal (except for '-' sign' if it is negative) if\n-    \/\/ its intCompact field is not INFLATED.\n-    static class StringBuilderHelper {\n-        final StringBuilder sb;    \/\/ Placeholder for BigDecimal string\n-        final char[] cmpCharArray; \/\/ character array to place the intCompact\n-\n-        StringBuilderHelper() {\n-            sb = new StringBuilder(32);\n-            \/\/ All non negative longs can be made to fit into 19 character array.\n-            cmpCharArray = new char[19];\n-        }\n-\n-        \/\/ Accessors.\n-        StringBuilder getStringBuilder() {\n-            sb.setLength(0);\n-            return sb;\n-        }\n-\n-        char[] getCompactCharArray() {\n-            return cmpCharArray;\n+    static final class ConcatHelper {\n+        private static final MethodHandle LONG_DOT_CHAR_CHAR;\n+        static {\n+            try {\n+                LONG_DOT_CHAR_CHAR\n+                        = StringConcatFactory.makeConcatWithConstants(\n+                            MethodHandles.lookup(),\n+                            \"scale2\",\n+                            MethodType.methodType(String.class, long.class, char.class, char.class),\n+                            \"\\1.\\1\\1\"\n+                        ).dynamicInvoker();\n+            } catch (Exception e) {\n+                throw new Error(\"Bootstrap error\", e);\n+            }\n@@ -4175,26 +4164,13 @@\n-        \/**\n-         * Places characters representing the intCompact in {@code long} into\n-         * cmpCharArray and returns the offset to the array where the\n-         * representation starts.\n-         *\n-         * @param intCompact the number to put into the cmpCharArray.\n-         * @return offset to the array where the representation starts.\n-         * Note: intCompact must be greater or equal to zero.\n-         *\/\n-        int putIntCompact(long intCompact) {\n-            assert intCompact >= 0;\n-\n-            long q;\n-            int r;\n-            \/\/ since we start from the least significant digit, charPos points to\n-            \/\/ the last character in cmpCharArray.\n-            int charPos = cmpCharArray.length;\n-\n-            \/\/ Get 2 digits\/iteration using longs until quotient fits into an int\n-            while (intCompact > Integer.MAX_VALUE) {\n-                q = intCompact \/ 100;\n-                r = (int)(intCompact - q * 100);\n-                intCompact = q;\n-                cmpCharArray[--charPos] = DIGIT_ONES[r];\n-                cmpCharArray[--charPos] = DIGIT_TENS[r];\n-            }\n+        static String scale2(long intCompact) {\n+            long highInt = intCompact \/ 100;\n+            short pair = DecimalDigits.digitPair((int)(Math.abs(intCompact) % 100));\n+            try {\n+                if (highInt == 0 && intCompact < 0) {\n+                    byte[] buf = new byte[5];\n+                    buf[0] = '-';\n+                    buf[1] = '0';\n+                    buf[2] = '.';\n+                    buf[3] = (byte)(pair & 0xff);\n+                    buf[4] = (byte)(pair >> 8);\n+                    return JLA.newStringNoRepl(buf, StandardCharsets.ISO_8859_1);\n+                }\n@@ -4202,9 +4178,3 @@\n-            \/\/ Get 2 digits\/iteration using ints when i2 >= 100\n-            int q2;\n-            int i2 = (int)intCompact;\n-            while (i2 >= 100) {\n-                q2 = i2 \/ 100;\n-                r  = i2 - q2 * 100;\n-                i2 = q2;\n-                cmpCharArray[--charPos] = DIGIT_ONES[r];\n-                cmpCharArray[--charPos] = DIGIT_TENS[r];\n+                return (String) LONG_DOT_CHAR_CHAR.invokeExact(highInt, (char)(pair & 0xff), (char)(pair >> 8));\n+            } catch (Throwable e) {\n+                throw new AssertionError(e);\n@@ -4212,6 +4182,0 @@\n-\n-            cmpCharArray[--charPos] = DIGIT_ONES[i2];\n-            if (i2 >= 10)\n-                cmpCharArray[--charPos] = DIGIT_TENS[i2];\n-\n-            return charPos;\n@@ -4219,26 +4183,0 @@\n-\n-        static final char[] DIGIT_TENS = {\n-            '0', '0', '0', '0', '0', '0', '0', '0', '0', '0',\n-            '1', '1', '1', '1', '1', '1', '1', '1', '1', '1',\n-            '2', '2', '2', '2', '2', '2', '2', '2', '2', '2',\n-            '3', '3', '3', '3', '3', '3', '3', '3', '3', '3',\n-            '4', '4', '4', '4', '4', '4', '4', '4', '4', '4',\n-            '5', '5', '5', '5', '5', '5', '5', '5', '5', '5',\n-            '6', '6', '6', '6', '6', '6', '6', '6', '6', '6',\n-            '7', '7', '7', '7', '7', '7', '7', '7', '7', '7',\n-            '8', '8', '8', '8', '8', '8', '8', '8', '8', '8',\n-            '9', '9', '9', '9', '9', '9', '9', '9', '9', '9',\n-        };\n-\n-        static final char[] DIGIT_ONES = {\n-            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n-            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n-            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n-            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n-            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n-            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n-            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n-            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n-            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n-            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n-        };\n@@ -4257,0 +4195,2 @@\n+        int scale = this.scale;\n+        long intCompact = this.intCompact;\n@@ -4258,5 +4198,2 @@\n-            return (intCompact != INFLATED) ?\n-                Long.toString(intCompact):\n-                intVal.toString();\n-        if (scale == 2  &&\n-            intCompact >= 0 && intCompact < Integer.MAX_VALUE) {\n+            return unscaledString();\n+        if (scale == 2 && intCompact != INFLATED) {\n@@ -4264,5 +4201,1 @@\n-            int lowInt = (int)intCompact % 100;\n-            int highInt = (int)intCompact \/ 100;\n-            return (Integer.toString(highInt) + '.' +\n-                    StringBuilderHelper.DIGIT_TENS[lowInt] +\n-                    StringBuilderHelper.DIGIT_ONES[lowInt]) ;\n+            return ConcatHelper.scale2(intCompact);\n@@ -4271,3 +4204,0 @@\n-        StringBuilderHelper sbHelper = new StringBuilderHelper();\n-        char[] coeff;\n-        int offset;  \/\/ offset is the starting index for coeff array\n@@ -4275,7 +4205,1 @@\n-        if (intCompact != INFLATED) {\n-            offset = sbHelper.putIntCompact(Math.abs(intCompact));\n-            coeff  = sbHelper.getCompactCharArray();\n-        } else {\n-            offset = 0;\n-            coeff  = intVal.abs().toString().toCharArray();\n-        }\n+        String coeff = unscaledAbsString();\n@@ -4287,4 +4211,1 @@\n-        StringBuilder buf = sbHelper.getStringBuilder();\n-        if (signum() < 0)             \/\/ prefix '-' if negative\n-            buf.append('-');\n-        int coeffLen = coeff.length - offset;\n+        int coeffLen = coeff.length();\n@@ -4293,0 +4214,3 @@\n+            StringBuilder buf = new StringBuilder(32);\n+            if (signum() < 0)             \/\/ prefix '-' if negative\n+                buf.append('-');\n@@ -4295,6 +4219,3 @@\n-                buf.append('0');\n-                buf.append('.');\n-                for (; pad>0; pad--) {\n-                    buf.append('0');\n-                }\n-                buf.append(coeff, offset, coeffLen);\n+                buf.append(\"0.\")\n+                   .repeat('0', pad)\n+                   .append(coeff, 0, coeffLen);\n@@ -4302,3 +4223,3 @@\n-                buf.append(coeff, offset, -pad);\n-                buf.append('.');\n-                buf.append(coeff, -pad + offset, scale);\n+                buf.append(coeff, 0, -pad)\n+                   .append('.')\n+                   .append(coeff, -pad, coeffLen);\n@@ -4306,15 +4227,24 @@\n-        } else { \/\/ E-notation is needed\n-            if (sci) {                       \/\/ Scientific notation\n-                buf.append(coeff[offset]);   \/\/ first character\n-                if (coeffLen > 1) {          \/\/ more to come\n-                    buf.append('.');\n-                    buf.append(coeff, offset + 1, coeffLen - 1);\n-                }\n-            } else {                         \/\/ Engineering notation\n-                int sig = (int)(adjusted % 3);\n-                if (sig < 0)\n-                    sig += 3;                \/\/ [adjusted was negative]\n-                adjusted -= sig;             \/\/ now a multiple of 3\n-                sig++;\n-                if (signum() == 0) {\n-                    switch (sig) {\n+            return buf.toString();\n+        }\n+        \/\/ E-notation is needed\n+        return layoutCharsE(sci, coeff, coeffLen, adjusted);\n+    }\n+\n+    private String layoutCharsE(boolean sci, String coeff, int coeffLen, long adjusted) {\n+        StringBuilder buf = new StringBuilder(32);\n+        if (signum() < 0)             \/\/ prefix '-' if negative\n+            buf.append('-');\n+        if (sci) {                       \/\/ Scientific notation\n+            buf.append(coeff.charAt(0)); \/\/ first character\n+            if (coeffLen > 1) {          \/\/ more to come\n+                buf.append('.')\n+                        .append(coeff, 1, coeffLen);\n+            }\n+        } else {                         \/\/ Engineering notation\n+            int sig = (int)(adjusted % 3);\n+            if (sig < 0)\n+                sig += 3;                \/\/ [adjusted was negative]\n+            adjusted -= sig;             \/\/ now a multiple of 3\n+            sig++;\n+            if (signum() == 0) {\n+                switch (sig) {\n@@ -4334,11 +4264,0 @@\n-                    }\n-                } else if (sig >= coeffLen) {   \/\/ significand all in integer\n-                    buf.append(coeff, offset, coeffLen);\n-                    \/\/ may need some zeros, too\n-                    for (int i = sig - coeffLen; i > 0; i--) {\n-                        buf.append('0');\n-                    }\n-                } else {                     \/\/ xx.xxE form\n-                    buf.append(coeff, offset, sig);\n-                    buf.append('.');\n-                    buf.append(coeff, offset + sig, coeffLen - sig);\n@@ -4346,0 +4265,7 @@\n+            } else if (sig >= coeffLen) {   \/\/ significand all in integer\n+                buf.append(coeff, 0, coeffLen)\n+                        .repeat('0', sig - coeffLen); \/\/ may need some zeros, too\n+            } else {                     \/\/ xx.xxE form\n+                buf.append(coeff, 0, sig)\n+                        .append('.')\n+                        .append(coeff, sig, coeffLen);\n@@ -4347,6 +4273,6 @@\n-            if (adjusted != 0) {             \/\/ [!sci could have made 0]\n-                buf.append('E');\n-                if (adjusted > 0)            \/\/ force sign for positive\n-                    buf.append('+');\n-                buf.append(adjusted);\n-            }\n+        }\n+        if (adjusted != 0) {             \/\/ [!sci could have made 0]\n+            buf.append('E');\n+            if (adjusted > 0)            \/\/ force sign for positive\n+                buf.append('+');\n+            buf.append(adjusted);\n@@ -4357,0 +4283,15 @@\n+    \/**\n+     * Get the significand as an absolute value\n+     *\/\n+    private String unscaledAbsString() {\n+        return intCompact != INFLATED\n+                ? Long.toString(Math.abs(intCompact))\n+                : intVal.abs().toString();\n+    }\n+\n+    private String unscaledString() {\n+        return intCompact != INFLATED\n+                ? Long.toString(intCompact)\n+                : intVal.toString();\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/math\/BigDecimal.java","additions":107,"deletions":166,"binary":false,"changes":273,"status":"modified"},{"patch":"@@ -145,0 +145,8 @@\n+    @Benchmark\n+    @OperationsPerInvocation(TEST_SIZE)\n+    public void testToEngineeringString(Blackhole bh) {\n+        for (BigDecimal s : bigDecimals) {\n+            bh.consume(s.toEngineeringString());\n+        }\n+    }\n+\n@@ -216,0 +224,8 @@\n+    @Benchmark\n+    @OperationsPerInvocation(TEST_SIZE)\n+    public void testHugeToEngineeringString(Blackhole bh) {\n+        for (BigDecimal s : hugeArray) {\n+            bh.consume(s.toEngineeringString());\n+        }\n+    }\n+\n@@ -225,0 +241,8 @@\n+    @Benchmark\n+    @OperationsPerInvocation(TEST_SIZE)\n+    public void testLargeToEngineeringString(Blackhole bh) {\n+        for (BigDecimal s : largeArray) {\n+            bh.consume(s.toEngineeringString());\n+        }\n+    }\n+\n@@ -233,0 +257,8 @@\n+\n+    @Benchmark\n+    @OperationsPerInvocation(TEST_SIZE)\n+    public void testSmallToEngineeringString(Blackhole bh) {\n+        for (BigDecimal s : smallArray) {\n+            bh.consume(s.toEngineeringString());\n+        }\n+    }\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/math\/BigDecimals.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"modified"}]}