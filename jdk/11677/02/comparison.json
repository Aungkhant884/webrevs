{"files":[{"patch":"@@ -110,2 +110,0 @@\n-  \/\/ skip initial young cards\n-  for (; byte <= last_byte && *byte == G1CardTable::g1_young_card_val(); byte++);\n@@ -113,13 +111,21 @@\n-  if (byte <= last_byte) {\n-    OrderAccess::storeload();\n-    \/\/ Enqueue if necessary.\n-    Thread* thr = Thread::current();\n-    G1DirtyCardQueueSet& qset = G1BarrierSet::dirty_card_queue_set();\n-    G1DirtyCardQueue& queue = G1ThreadLocalData::dirty_card_queue(thr);\n-    for (; byte <= last_byte; byte++) {\n-      CardValue bv = *byte;\n-      if ((bv != G1CardTable::g1_young_card_val()) &&\n-          (bv != G1CardTable::dirty_card_val())) {\n-        *byte = G1CardTable::dirty_card_val();\n-        qset.enqueue(queue, byte);\n-      }\n+  \/\/ skip young gen cards\n+  if (*byte == G1CardTable::g1_young_card_val()) {\n+    \/\/ MemRegion should not span multiple regions for the young gen.\n+    DEBUG_ONLY(HeapRegion* containing_hr = G1CollectedHeap::heap()->heap_region_containing(mr.start());)\n+    assert(containing_hr->is_young(), \"it should be young\");\n+    assert(containing_hr->is_in(mr.start()), \"it should contain start\");\n+    assert(containing_hr->is_in(mr.last()), \"it should also contain last\");\n+    return;\n+  }\n+\n+  OrderAccess::storeload();\n+  \/\/ Enqueue if necessary.\n+  Thread* thr = Thread::current();\n+  G1DirtyCardQueueSet& qset = G1BarrierSet::dirty_card_queue_set();\n+  G1DirtyCardQueue& queue = G1ThreadLocalData::dirty_card_queue(thr);\n+  for (; byte <= last_byte; byte++) {\n+    CardValue bv = *byte;\n+    assert(bv != G1CardTable::g1_young_card_val(), \"Invalid card\");\n+    if (bv != G1CardTable::dirty_card_val()) {\n+      *byte = G1CardTable::dirty_card_val();\n+      qset.enqueue(queue, byte);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1BarrierSet.cpp","additions":21,"deletions":15,"binary":false,"changes":36,"status":"modified"}]}