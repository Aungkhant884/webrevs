{"files":[{"patch":"@@ -2853,0 +2853,4 @@\n+     * @implSpec\n+     * This method is equivalent to {@link #externalSubmit(ForkJoinTask)}\n+     * when called from a thread that is not in this pool.\n+     *\n@@ -2899,0 +2903,25 @@\n+    \/**\n+     * Submits the given task as if submitted from a non-{@code ForkJoinTask}\n+     * client. The task is added to a scheduling queue for submissions to the\n+     * pool even when called from a thread in the pool.\n+     *\n+     * @implSpec\n+     * This method is equivalent to {@link #submit(ForkJoinTask)} when called\n+     * from a thread that is not in this pool.\n+     *\n+     * @return the task\n+     * @param task the task to submit\n+     * @param <T> the type of the task's result\n+     * @throws NullPointerException if the task is null\n+     * @throws RejectedExecutionException if the task cannot be\n+     *         scheduled for execution\n+     * @since 20\n+     *\/\n+    public <T> ForkJoinTask<T> externalSubmit(ForkJoinTask<T> task) {\n+        U.storeStoreFence();  \/\/ ensure safely publishable\n+        task.markPoolSubmission();\n+        WorkQueue q = submissionQueue(true);\n+        q.push(task, this, true);\n+        return task;\n+    }\n+\n@@ -2910,0 +2939,3 @@\n+     * @throws NullPointerException if the task is null\n+     * @throws RejectedExecutionException if the task cannot be\n+     *         scheduled for execution\n@@ -3268,0 +3300,1 @@\n+     * @see ForkJoinWorkerThread#getQueuedTaskCount()\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ForkJoinPool.java","additions":33,"deletions":0,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -141,0 +141,11 @@\n+    \/**\n+     * {@return a (non-negative) estimate of the number of tasks in the\n+     * thread's queue}\n+     *\n+     * @since 20\n+     * @see ForkJoinPool#getQueuedTaskCount()\n+     *\/\n+    public int getQueuedTaskCount() {\n+        return workQueue.queueSize();\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ForkJoinWorkerThread.java","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -0,0 +1,219 @@\n+\/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * This file is available under and governed by the GNU General Public\n+ * License version 2 only, as published by the Free Software Foundation.\n+ * However, the following notice accompanied the original version of this\n+ * file:\n+ *\n+ * Written by Doug Lea with assistance from members of JCP JSR-166\n+ * Expert Group and released to the public domain, as explained at\n+ * http:\/\/creativecommons.org\/publicdomain\/zero\/1.0\/\n+ *\/\n+\n+import java.util.concurrent.ForkJoinPool;\n+import java.util.concurrent.ForkJoinTask;\n+import java.util.concurrent.ForkJoinWorkerThread;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.RejectedExecutionException;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.concurrent.locks.LockSupport;\n+\n+import junit.framework.Test;\n+import junit.framework.TestSuite;\n+\n+\/**\n+ * Tests for ForkJoinPool and ForkJoinWorkerThread additions in JDK 20.\n+ *\/\n+public class ForkJoinPool20Test extends JSR166TestCase {\n+    public static void main(String[] args) {\n+        main(suite(), args);\n+    }\n+\n+    public static Test suite() {\n+        return new TestSuite(ForkJoinPool20Test.class);\n+    }\n+\n+    \/**\n+     * Test that tasks submitted with externalSubmit execute.\n+     *\/\n+    public void testExternalSubmit1() throws Exception {\n+        try (var pool = new ForkJoinPool()) {\n+            \/\/ submit from external client\n+            var task1 = ForkJoinTask.adapt(() -> \"foo\");\n+            pool.externalSubmit(task1);\n+            assertEquals(task1.get(), \"foo\");\n+\n+            \/\/ submit from worker thread\n+            Future<Future<String>> task2 = pool.submit(() -> {\n+                return pool.externalSubmit(ForkJoinTask.adapt(() -> \"foo\"));\n+            });\n+            assertEquals(task2.get().get(), \"foo\");\n+        }\n+    }\n+\n+    \/**\n+     * Test that tasks submitted with externalSubmit are pushed to a submission queue.\n+     *\/\n+    public void testExternalSubmit2() throws Exception {\n+        try (var pool = new ForkJoinPool(1)) {\n+            pool.submit(() -> {\n+                assertTrue(pool.getQueuedTaskCount() == 0);\n+                assertTrue(pool.getQueuedSubmissionCount() == 0);\n+\n+                for (int count = 1; count <= 3; count++) {\n+                    var task = ForkJoinTask.adapt(() -> { });\n+                    pool.externalSubmit(task);\n+\n+                    assertTrue(pool.getQueuedTaskCount() == 0);\n+                    assertTrue(pool.getQueuedSubmissionCount() == count);\n+                }\n+            }).get();\n+        }\n+    }\n+\n+    \/**\n+     * Test externalSubmit return value.\n+     *\/\n+    public void testExternalSubmitReturnsTask() {\n+        try (var pool = new ForkJoinPool()) {\n+            var task = ForkJoinTask.adapt(() -> \"foo\");\n+            assertTrue(pool.externalSubmit(task) == task);\n+        }\n+    }\n+\n+    \/**\n+     * Test externalSubmit(null) throws NullPointerException.\n+     *\/\n+    public void testExternalSubmitWithNull() {\n+        try (var pool = new ForkJoinPool()) {\n+            assertThrows(NullPointerException.class, () -> pool.externalSubmit(null));\n+        }\n+    }\n+\n+    \/**\n+     * Test externalSubmit throws RejectedExecutionException when pool is shutdown.\n+     *\/\n+    public void testExternalSubmitWhenShutdown() {\n+        try (var pool = new ForkJoinPool()) {\n+            pool.shutdown();\n+            var task = ForkJoinTask.adapt(() -> { });\n+            assertThrows(RejectedExecutionException.class, () -> pool.externalSubmit(task));\n+        }\n+    }\n+\n+    \/**\n+     * Test that tasks submitted with submit(ForkJoinTask) are pushed to a\n+     * submission queue.\n+     *\/\n+    public void testSubmit() throws Exception {\n+        try (var pool = new ForkJoinPool(1)) {\n+            ForkJoinWorkerThread worker = submitBusyTask(pool);\n+            try {\n+                assertTrue(worker.getQueuedTaskCount() == 0);\n+                assertTrue(pool.getQueuedTaskCount() == 0);\n+                assertTrue(pool.getQueuedSubmissionCount() == 0);\n+\n+                for (int count = 1; count <= 3; count++) {\n+                    var task = ForkJoinTask.adapt(() -> { });\n+                    pool.submit(task);\n+\n+                    \/\/ task should be in submission queue\n+                    assertTrue(worker.getQueuedTaskCount() == 0);\n+                    assertTrue(pool.getQueuedTaskCount() == 0);\n+                    assertTrue(pool.getQueuedSubmissionCount() == count);\n+                }\n+            } finally {\n+                LockSupport.unpark(worker);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Test ForkJoinWorkerThread::getQueuedTaskCount returns the number of tasks in the\n+     * current thread's queue. This test runs with parallelism of 1 to ensure that tasks\n+     * aren't stolen.\n+     *\/\n+    public void testGetQueuedTaskCount1() throws Exception {\n+        try (var pool = new ForkJoinPool(1)) {\n+            pool.submit(() -> {\n+                var worker = (ForkJoinWorkerThread) Thread.currentThread();\n+                assertTrue(worker.getQueuedTaskCount() == 0);\n+\n+                for (int count = 1; count <= 3; count++) {\n+                    pool.submit(() -> { });\n+\n+                    \/\/ task should be in this thread's task queue\n+                    assertTrue(worker.getQueuedTaskCount() == count);\n+                    assertTrue(pool.getQueuedTaskCount() == count);\n+                    assertTrue(pool.getQueuedSubmissionCount() == 0);\n+                }\n+            }).get();\n+        }\n+    }\n+\n+    \/**\n+     * Test ForkJoinWorkerThread::getQueuedTaskCount returns the number of tasks in the\n+     * thread's queue. This test runs with parallelism of 2 and one worker active running\n+     * a task. This gives the test two task queues to sample.\n+     *\/\n+    public void testGetQueuedTaskCount2() throws Exception {\n+        try (var pool = new ForkJoinPool(2)) {\n+            \/\/ keep one worker thread active\n+            ForkJoinWorkerThread worker1 = submitBusyTask(pool);\n+            try {\n+                pool.submit(() -> {\n+                    var worker2 = (ForkJoinWorkerThread) Thread.currentThread();\n+                    for (int count = 1; count <= 3; count++) {\n+                        pool.submit(() -> { });\n+\n+                        \/\/ task should be in this thread's task queue\n+                        assertTrue(worker1.getQueuedTaskCount() == 0);\n+                        assertTrue(worker2.getQueuedTaskCount() == count);\n+                        assertTrue(pool.getQueuedTaskCount() == count);\n+                        assertTrue(pool.getQueuedSubmissionCount() == 0);\n+                    }\n+                }).get();\n+            } finally {\n+                LockSupport.unpark(worker1);  \/\/ release worker1\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Submits a task to the pool, returning the worker thread that runs the\n+     * task. The task runs until the thread is unparked.\n+     *\/\n+    static ForkJoinWorkerThread submitBusyTask(ForkJoinPool pool) throws Exception {\n+        var ref = new AtomicReference<ForkJoinWorkerThread>();\n+        pool.submit(() -> {\n+            ref.set((ForkJoinWorkerThread) Thread.currentThread());\n+            LockSupport.park();\n+        });\n+        ForkJoinWorkerThread worker;\n+        while ((worker = ref.get()) == null) {\n+            Thread.sleep(20);\n+        }\n+        return worker;\n+    }\n+}\n","filename":"test\/jdk\/java\/util\/concurrent\/tck\/ForkJoinPool20Test.java","additions":219,"deletions":0,"binary":false,"changes":219,"status":"added"},{"patch":"@@ -516,1 +516,2 @@\n-    public static boolean atLeastJava17() { return JAVA_CLASS_VERSION >= 61.0; }\n+    public static boolean atLeastJava19() { return JAVA_CLASS_VERSION >= 63.0; }\n+    public static boolean atLeastJava20() { return JAVA_CLASS_VERSION >= 64.0; }\n@@ -636,2 +637,2 @@\n-        if (atLeastJava17()) {\n-            String[] java17TestClassNames = {\n+        if (atLeastJava19()) {\n+            String[] java19TestClassNames = {\n@@ -640,1 +641,1 @@\n-            addNamedTestClasses(suite, java17TestClassNames);\n+            addNamedTestClasses(suite, java19TestClassNames);\n@@ -642,0 +643,8 @@\n+\n+        if (atLeastJava20()) {\n+            String[] java20TestClassNames = {\n+                \"ForkJoinPool20Test\",\n+            };\n+            addNamedTestClasses(suite, java20TestClassNames);\n+        }\n+\n","filename":"test\/jdk\/java\/util\/concurrent\/tck\/JSR166TestCase.java","additions":13,"deletions":4,"binary":false,"changes":17,"status":"modified"}]}