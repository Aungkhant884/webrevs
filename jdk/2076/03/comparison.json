{"files":[{"patch":"@@ -28,1 +28,0 @@\n-import sun.awt.geom.PathConsumer2D;\n@@ -30,1 +29,1 @@\n-final class CollinearSimplifier implements PathConsumer2D {\n+final class CollinearSimplifier implements DPathConsumer2D {\n@@ -37,1 +36,1 @@\n-    static final float EPS = 1e-4f; \/\/ aaime proposed 1e-3f\n+    static final double EPS = 1e-4d; \/\/ aaime proposed 1e-3d\n@@ -39,1 +38,1 @@\n-    PathConsumer2D delegate;\n+    DPathConsumer2D delegate;\n@@ -41,2 +40,2 @@\n-    float px1, py1, px2, py2;\n-    float pslope;\n+    double px1, py1, px2, py2;\n+    double pslope;\n@@ -47,1 +46,1 @@\n-    public CollinearSimplifier init(PathConsumer2D delegate) {\n+    public CollinearSimplifier init(DPathConsumer2D delegate) {\n@@ -74,1 +73,1 @@\n-    public void quadTo(float x1, float y1, float x2, float y2) {\n+    public void quadTo(double x1, double y1, double x2, double y2) {\n@@ -84,2 +83,2 @@\n-    public void curveTo(float x1, float y1, float x2, float y2,\n-                        float x3, float y3) {\n+    public void curveTo(double x1, double y1, double x2, double y2,\n+                        double x3, double y3) {\n@@ -95,1 +94,1 @@\n-    public void moveTo(float x, float y) {\n+    public void moveTo(double x, double y) {\n@@ -104,1 +103,1 @@\n-    public void lineTo(final float x, final float y) {\n+    public void lineTo(final double x, final double y) {\n@@ -121,1 +120,1 @@\n-                final float slope = getSlope(px2, py2, x, y);\n+                final double slope = getSlope(px2, py2, x, y);\n@@ -147,5 +146,5 @@\n-    private static float getSlope(float x1, float y1, float x2, float y2) {\n-        float dy = y2 - y1;\n-        if (dy == 0.0f) {\n-            return (x2 > x1) ? Float.POSITIVE_INFINITY\n-                   : Float.NEGATIVE_INFINITY;\n+    private static double getSlope(double x1, double y1, double x2, double y2) {\n+        double dy = y2 - y1;\n+        if (dy == 0.0d) {\n+            return (x2 > x1) ? Double.POSITIVE_INFINITY\n+                   : Double.NEGATIVE_INFINITY;\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/marlin\/CollinearSimplifier.java","additions":17,"deletions":18,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -30,2 +30,2 @@\n-    float ax, ay, bx, by, cx, cy, dx, dy;\n-    float dax, day, dbx, dby;\n+    double ax, ay, bx, by, cx, cy, dx, dy;\n+    double dax, day, dbx, dby;\n@@ -36,1 +36,1 @@\n-    void set(final float[] points, final int type) {\n+    void set(final double[] points, final int type) {\n@@ -53,4 +53,4 @@\n-    void set(final float x1, final float y1,\n-             final float x2, final float y2,\n-             final float x3, final float y3,\n-             final float x4, final float y4)\n+    void set(final double x1, final double y1,\n+             final double x2, final double y2,\n+             final double x3, final double y3,\n+             final double x4, final double y4)\n@@ -58,4 +58,4 @@\n-        final float dx32 = 3.0f * (x3 - x2);\n-        final float dy32 = 3.0f * (y3 - y2);\n-        final float dx21 = 3.0f * (x2 - x1);\n-        final float dy21 = 3.0f * (y2 - y1);\n+        final double dx32 = 3.0d * (x3 - x2);\n+        final double dy32 = 3.0d * (y3 - y2);\n+        final double dx21 = 3.0d * (x2 - x1);\n+        final double dy21 = 3.0d * (y2 - y1);\n@@ -70,4 +70,4 @@\n-        dax = 3.0f * ax;\n-        day = 3.0f * ay;\n-        dbx = 2.0f * bx;\n-        dby = 2.0f * by;\n+        dax = 3.0d * ax;\n+        day = 3.0d * ay;\n+        dbx = 2.0d * bx;\n+        dby = 2.0d * by;\n@@ -76,3 +76,3 @@\n-    void set(final float x1, final float y1,\n-             final float x2, final float y2,\n-             final float x3, final float y3)\n+    void set(final double x1, final double y1,\n+             final double x2, final double y2,\n+             final double x3, final double y3)\n@@ -80,4 +80,4 @@\n-        final float dx21 = (x2 - x1);\n-        final float dy21 = (y2 - y1);\n-        ax = 0.0f;              \/\/ A = 0\n-        ay = 0.0f;\n+        final double dx21 = (x2 - x1);\n+        final double dy21 = (y2 - y1);\n+        ax = 0.0d;              \/\/ A = 0\n+        ay = 0.0d;\n@@ -86,2 +86,2 @@\n-        cx = 2.0f * dx21;       \/\/ C = 2 (P2 - P1)\n-        cy = 2.0f * dy21;\n+        cx = 2.0d * dx21;       \/\/ C = 2 (P2 - P1)\n+        cy = 2.0d * dy21;\n@@ -90,4 +90,4 @@\n-        dax = 0.0f;\n-        day = 0.0f;\n-        dbx = 2.0f * bx;\n-        dby = 2.0f * by;\n+        dax = 0.0d;\n+        day = 0.0d;\n+        dbx = 2.0d * bx;\n+        dby = 2.0d * by;\n@@ -96,2 +96,2 @@\n-    void set(final float x1, final float y1,\n-             final float x2, final float y2)\n+    void set(final double x1, final double y1,\n+             final double x2, final double y2)\n@@ -99,6 +99,6 @@\n-        final float dx21 = (x2 - x1);\n-        final float dy21 = (y2 - y1);\n-        ax = 0.0f;              \/\/ A = 0\n-        ay = 0.0f;\n-        bx = 0.0f;              \/\/ B = 0\n-        by = 0.0f;\n+        final double dx21 = (x2 - x1);\n+        final double dy21 = (y2 - y1);\n+        ax = 0.0d;              \/\/ A = 0\n+        ay = 0.0d;\n+        bx = 0.0d;              \/\/ B = 0\n+        by = 0.0d;\n@@ -109,4 +109,4 @@\n-        dax = 0.0f;\n-        day = 0.0f;\n-        dbx = 0.0f;\n-        dby = 0.0f;\n+        dax = 0.0d;\n+        day = 0.0d;\n+        dbx = 0.0d;\n+        dby = 0.0d;\n@@ -115,1 +115,1 @@\n-    int dxRoots(final float[] roots, final int off) {\n+    int dxRoots(final double[] roots, final int off) {\n@@ -119,1 +119,1 @@\n-    int dyRoots(final float[] roots, final int off) {\n+    int dyRoots(final double[] roots, final int off) {\n@@ -123,1 +123,1 @@\n-    int infPoints(final float[] pts, final int off) {\n+    int infPoints(final double[] pts, final int off) {\n@@ -127,3 +127,3 @@\n-        final float a = dax * dby - dbx * day;\n-        final float b = 2.0f * (cy * dax - day * cx);\n-        final float c = cy * dbx - cx * dby;\n+        final double a = dax * dby - dbx * day;\n+        final double b = 2.0d * (cy * dax - day * cx);\n+        final double c = cy * dbx - cx * dby;\n@@ -134,1 +134,1 @@\n-    int xPoints(final float[] ts, final int off, final float x)\n+    int xPoints(final double[] ts, final int off, final double x)\n@@ -136,1 +136,1 @@\n-        return Helpers.cubicRootsInAB(ax, bx, cx, dx - x, ts, off, 0.0f, 1.0f);\n+        return Helpers.cubicRootsInAB(ax, bx, cx, dx - x, ts, off, 0.0d, 1.0d);\n@@ -139,1 +139,1 @@\n-    int yPoints(final float[] ts, final int off, final float y)\n+    int yPoints(final double[] ts, final int off, final double y)\n@@ -141,1 +141,1 @@\n-        return Helpers.cubicRootsInAB(ay, by, cy, dy - y, ts, off, 0.0f, 1.0f);\n+        return Helpers.cubicRootsInAB(ay, by, cy, dy - y, ts, off, 0.0d, 1.0d);\n@@ -147,1 +147,1 @@\n-    private int perpendiculardfddf(final float[] pts, final int off) {\n+    private int perpendiculardfddf(final double[] pts, final int off) {\n@@ -153,4 +153,4 @@\n-        final float a = 2.0f * (dax * dax + day * day);\n-        final float b = 3.0f * (dax * dbx + day * dby);\n-        final float c = 2.0f * (dax * cx  + day * cy) + dbx * dbx + dby * dby;\n-        final float d = dbx * cx + dby * cy;\n+        final double a = 2.0d * (dax * dax + day * day);\n+        final double b = 3.0d * (dax * dbx + day * dby);\n+        final double c = 2.0d * (dax * cx + day * cy) + dbx * dbx + dby * dby;\n+        final double d = dbx * cx + dby * cy;\n@@ -158,1 +158,1 @@\n-        return Helpers.cubicRootsInAB(a, b, c, d, pts, off, 0.0f, 1.0f);\n+        return Helpers.cubicRootsInAB(a, b, c, d, pts, off, 0.0d, 1.0d);\n@@ -174,1 +174,1 @@\n-    int rootsOfROCMinusW(final float[] roots, final int off, final float w2, final float err) {\n+    int rootsOfROCMinusW(final double[] roots, final int off, final double w2, final double err) {\n@@ -180,1 +180,1 @@\n-        roots[end] = 1.0f; \/\/ always check interval end points\n+        roots[end] = 1.0d; \/\/ always check interval end points\n@@ -182,1 +182,1 @@\n-        float t0 = 0.0f, ft0 = ROCsq(t0) - w2;\n+        double t0 = 0.0d, ft0 = ROCsq(t0) - w2;\n@@ -185,2 +185,2 @@\n-            float t1 = roots[i], ft1 = ROCsq(t1) - w2;\n-            if (ft0 == 0.0f) {\n+            double t1 = roots[i], ft1 = ROCsq(t1) - w2;\n+            if (ft0 == 0.0d) {\n@@ -188,1 +188,1 @@\n-            } else if (ft1 * ft0 < 0.0f) { \/\/ have opposite signs\n+            } else if (ft1 * ft0 < 0.0d) { \/\/ have opposite signs\n@@ -200,3 +200,3 @@\n-    private static float eliminateInf(final float x) {\n-        return (x == Float.POSITIVE_INFINITY ? Float.MAX_VALUE :\n-               (x == Float.NEGATIVE_INFINITY ? Float.MIN_VALUE : x));\n+    private static double eliminateInf(final double x) {\n+        return (x == Double.POSITIVE_INFINITY ? Double.MAX_VALUE :\n+               (x == Double.NEGATIVE_INFINITY ? Double.MIN_VALUE : x));\n@@ -212,2 +212,2 @@\n-    private float falsePositionROCsqMinusX(final float t0, final float t1,\n-                                           final float w2, final float err)\n+    private double falsePositionROCsqMinusX(final double t0, final double t1,\n+                                            final double w2, final double err)\n@@ -217,3 +217,3 @@\n-        float t = t1, ft = eliminateInf(ROCsq(t) - w2);\n-        float s = t0, fs = eliminateInf(ROCsq(s) - w2);\n-        float r = s, fr;\n+        double t = t1, ft = eliminateInf(ROCsq(t) - w2);\n+        double s = t0, fs = eliminateInf(ROCsq(s) - w2);\n+        double r = s, fr;\n@@ -232,1 +232,1 @@\n-            } else if (fr * fs > 0.0f) {\n+            } else if (fr * fs > 0.0d) {\n@@ -247,1 +247,1 @@\n-    private static boolean sameSign(final float x, final float y) {\n+    private static boolean sameSign(final double x, final double y) {\n@@ -249,1 +249,1 @@\n-        return (x < 0.0f && y < 0.0f) || (x > 0.0f && y > 0.0f);\n+        return (x < 0.0d && y < 0.0d) || (x > 0.0d && y > 0.0d);\n@@ -254,8 +254,8 @@\n-    private float ROCsq(final float t) {\n-        final float dx = t * (t * dax + dbx) + cx;\n-        final float dy = t * (t * day + dby) + cy;\n-        final float ddx = 2.0f * dax * t + dbx;\n-        final float ddy = 2.0f * day * t + dby;\n-        final float dx2dy2 = dx * dx + dy * dy;\n-        final float ddx2ddy2 = ddx * ddx + ddy * ddy;\n-        final float ddxdxddydy = ddx * dx + ddy * dy;\n+    private double ROCsq(final double t) {\n+        final double dx = t * (t * dax + dbx) + cx;\n+        final double dy = t * (t * day + dby) + cy;\n+        final double ddx = 2.0d * dax * t + dbx;\n+        final double ddy = 2.0d * day * t + dby;\n+        final double dx2dy2 = dx * dx + dy * dy;\n+        final double ddx2ddy2 = ddx * ddx + ddy * ddy;\n+        final double ddxdxddydy = ddx * dx + ddy * dy;\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/marlin\/Curve.java","additions":81,"deletions":81,"binary":false,"changes":162,"status":"modified"},{"patch":"@@ -1,154 +0,0 @@\n-\/*\n- * Copyright (c) 2015, 2017, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package sun.java2d.marlin;\n-\n-\n-final class DCollinearSimplifier implements DPathConsumer2D {\n-\n-    enum SimplifierState {\n-\n-        Empty, PreviousPoint, PreviousLine\n-    };\n-    \/\/ slope precision threshold\n-    static final double EPS = 1e-4d; \/\/ aaime proposed 1e-3d\n-\n-    DPathConsumer2D delegate;\n-    SimplifierState state;\n-    double px1, py1, px2, py2;\n-    double pslope;\n-\n-    DCollinearSimplifier() {\n-    }\n-\n-    public DCollinearSimplifier init(DPathConsumer2D delegate) {\n-        this.delegate = delegate;\n-        this.state = SimplifierState.Empty;\n-\n-        return this; \/\/ fluent API\n-    }\n-\n-    @Override\n-    public void pathDone() {\n-        emitStashedLine();\n-        state = SimplifierState.Empty;\n-        delegate.pathDone();\n-    }\n-\n-    @Override\n-    public void closePath() {\n-        emitStashedLine();\n-        state = SimplifierState.Empty;\n-        delegate.closePath();\n-    }\n-\n-    @Override\n-    public long getNativeConsumer() {\n-        return 0;\n-    }\n-\n-    @Override\n-    public void quadTo(double x1, double y1, double x2, double y2) {\n-        emitStashedLine();\n-        delegate.quadTo(x1, y1, x2, y2);\n-        \/\/ final end point:\n-        state = SimplifierState.PreviousPoint;\n-        px1 = x2;\n-        py1 = y2;\n-    }\n-\n-    @Override\n-    public void curveTo(double x1, double y1, double x2, double y2,\n-                        double x3, double y3) {\n-        emitStashedLine();\n-        delegate.curveTo(x1, y1, x2, y2, x3, y3);\n-        \/\/ final end point:\n-        state = SimplifierState.PreviousPoint;\n-        px1 = x3;\n-        py1 = y3;\n-    }\n-\n-    @Override\n-    public void moveTo(double x, double y) {\n-        emitStashedLine();\n-        delegate.moveTo(x, y);\n-        state = SimplifierState.PreviousPoint;\n-        px1 = x;\n-        py1 = y;\n-    }\n-\n-    @Override\n-    public void lineTo(final double x, final double y) {\n-        switch (state) {\n-            case Empty:\n-                delegate.lineTo(x, y);\n-                state = SimplifierState.PreviousPoint;\n-                px1 = x;\n-                py1 = y;\n-                return;\n-\n-            case PreviousPoint:\n-                state = SimplifierState.PreviousLine;\n-                px2 = x;\n-                py2 = y;\n-                pslope = getSlope(px1, py1, x, y);\n-                return;\n-\n-            case PreviousLine:\n-                final double slope = getSlope(px2, py2, x, y);\n-                \/\/ test for collinearity\n-                if ((slope == pslope) || (Math.abs(pslope - slope) < EPS)) {\n-                    \/\/ merge segments\n-                    px2 = x;\n-                    py2 = y;\n-                    return;\n-                }\n-                \/\/ emit previous segment\n-                delegate.lineTo(px2, py2);\n-                px1 = px2;\n-                py1 = py2;\n-                px2 = x;\n-                py2 = y;\n-                pslope = slope;\n-                return;\n-            default:\n-        }\n-    }\n-\n-    private void emitStashedLine() {\n-        if (state == SimplifierState.PreviousLine) {\n-            delegate.lineTo(px2, py2);\n-        }\n-    }\n-\n-    private static double getSlope(double x1, double y1, double x2, double y2) {\n-        double dy = y2 - y1;\n-        if (dy == 0.0d) {\n-            return (x2 > x1) ? Double.POSITIVE_INFINITY\n-                   : Double.NEGATIVE_INFINITY;\n-        }\n-        return (x2 - x1) \/ dy;\n-    }\n-}\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/marlin\/DCollinearSimplifier.java","additions":0,"deletions":154,"binary":false,"changes":154,"status":"deleted"},{"patch":"@@ -1,264 +0,0 @@\n-\/*\n- * Copyright (c) 2007, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package sun.java2d.marlin;\n-\n-final class DCurve {\n-\n-    double ax, ay, bx, by, cx, cy, dx, dy;\n-    double dax, day, dbx, dby;\n-\n-    DCurve() {\n-    }\n-\n-    void set(final double[] points, final int type) {\n-        \/\/ if instead of switch (perf + most probable cases first)\n-        if (type == 8) {\n-            set(points[0], points[1],\n-                points[2], points[3],\n-                points[4], points[5],\n-                points[6], points[7]);\n-        } else if (type == 4) {\n-            set(points[0], points[1],\n-                points[2], points[3]);\n-        } else {\n-            set(points[0], points[1],\n-                points[2], points[3],\n-                points[4], points[5]);\n-        }\n-    }\n-\n-    void set(final double x1, final double y1,\n-             final double x2, final double y2,\n-             final double x3, final double y3,\n-             final double x4, final double y4)\n-    {\n-        final double dx32 = 3.0d * (x3 - x2);\n-        final double dy32 = 3.0d * (y3 - y2);\n-        final double dx21 = 3.0d * (x2 - x1);\n-        final double dy21 = 3.0d * (y2 - y1);\n-        ax = (x4 - x1) - dx32;  \/\/ A = P3 - P0 - 3 (P2 - P1) = (P3 - P0) + 3 (P1 - P2)\n-        ay = (y4 - y1) - dy32;\n-        bx = (dx32 - dx21);     \/\/ B = 3 (P2 - P1) - 3(P1 - P0) = 3 (P2 + P0) - 6 P1\n-        by = (dy32 - dy21);\n-        cx = dx21;              \/\/ C = 3 (P1 - P0)\n-        cy = dy21;\n-        dx = x1;                \/\/ D = P0\n-        dy = y1;\n-        dax = 3.0d * ax;\n-        day = 3.0d * ay;\n-        dbx = 2.0d * bx;\n-        dby = 2.0d * by;\n-    }\n-\n-    void set(final double x1, final double y1,\n-             final double x2, final double y2,\n-             final double x3, final double y3)\n-    {\n-        final double dx21 = (x2 - x1);\n-        final double dy21 = (y2 - y1);\n-        ax = 0.0d;              \/\/ A = 0\n-        ay = 0.0d;\n-        bx = (x3 - x2) - dx21;  \/\/ B = P3 - P0 - 2 P2\n-        by = (y3 - y2) - dy21;\n-        cx = 2.0d * dx21;       \/\/ C = 2 (P2 - P1)\n-        cy = 2.0d * dy21;\n-        dx = x1;                \/\/ D = P1\n-        dy = y1;\n-        dax = 0.0d;\n-        day = 0.0d;\n-        dbx = 2.0d * bx;\n-        dby = 2.0d * by;\n-    }\n-\n-    void set(final double x1, final double y1,\n-             final double x2, final double y2)\n-    {\n-        final double dx21 = (x2 - x1);\n-        final double dy21 = (y2 - y1);\n-        ax = 0.0d;              \/\/ A = 0\n-        ay = 0.0d;\n-        bx = 0.0d;              \/\/ B = 0\n-        by = 0.0d;\n-        cx = dx21;              \/\/ C = (P2 - P1)\n-        cy = dy21;\n-        dx = x1;                \/\/ D = P1\n-        dy = y1;\n-        dax = 0.0d;\n-        day = 0.0d;\n-        dbx = 0.0d;\n-        dby = 0.0d;\n-    }\n-\n-    int dxRoots(final double[] roots, final int off) {\n-        return DHelpers.quadraticRoots(dax, dbx, cx, roots, off);\n-    }\n-\n-    int dyRoots(final double[] roots, final int off) {\n-        return DHelpers.quadraticRoots(day, dby, cy, roots, off);\n-    }\n-\n-    int infPoints(final double[] pts, final int off) {\n-        \/\/ inflection point at t if -f'(t)x*f''(t)y + f'(t)y*f''(t)x == 0\n-        \/\/ Fortunately, this turns out to be quadratic, so there are at\n-        \/\/ most 2 inflection points.\n-        final double a = dax * dby - dbx * day;\n-        final double b = 2.0d * (cy * dax - day * cx);\n-        final double c = cy * dbx - cx * dby;\n-\n-        return DHelpers.quadraticRoots(a, b, c, pts, off);\n-    }\n-\n-    int xPoints(final double[] ts, final int off, final double x)\n-    {\n-        return DHelpers.cubicRootsInAB(ax, bx, cx, dx - x, ts, off, 0.0d, 1.0d);\n-    }\n-\n-    int yPoints(final double[] ts, final int off, final double y)\n-    {\n-        return DHelpers.cubicRootsInAB(ay, by, cy, dy - y, ts, off, 0.0d, 1.0d);\n-    }\n-\n-    \/\/ finds points where the first and second derivative are\n-    \/\/ perpendicular. This happens when g(t) = f'(t)*f''(t) == 0 (where\n-    \/\/ * is a dot product). Unfortunately, we have to solve a cubic.\n-    private int perpendiculardfddf(final double[] pts, final int off) {\n-        assert pts.length >= off + 4;\n-\n-        \/\/ these are the coefficients of some multiple of g(t) (not g(t),\n-        \/\/ because the roots of a polynomial are not changed after multiplication\n-        \/\/ by a constant, and this way we save a few multiplications).\n-        final double a = 2.0d * (dax * dax + day * day);\n-        final double b = 3.0d * (dax * dbx + day * dby);\n-        final double c = 2.0d * (dax * cx + day * cy) + dbx * dbx + dby * dby;\n-        final double d = dbx * cx + dby * cy;\n-\n-        return DHelpers.cubicRootsInAB(a, b, c, d, pts, off, 0.0d, 1.0d);\n-    }\n-\n-    \/\/ Tries to find the roots of the function ROC(t)-w in [0, 1). It uses\n-    \/\/ a variant of the false position algorithm to find the roots. False\n-    \/\/ position requires that 2 initial values x0,x1 be given, and that the\n-    \/\/ function must have opposite signs at those values. To find such\n-    \/\/ values, we need the local extrema of the ROC function, for which we\n-    \/\/ need the roots of its derivative; however, it's harder to find the\n-    \/\/ roots of the derivative in this case than it is to find the roots\n-    \/\/ of the original function. So, we find all points where this curve's\n-    \/\/ first and second derivative are perpendicular, and we pretend these\n-    \/\/ are our local extrema. There are at most 3 of these, so we will check\n-    \/\/ at most 4 sub-intervals of (0,1). ROC has asymptotes at inflection\n-    \/\/ points, so roc-w can have at least 6 roots. This shouldn't be a\n-    \/\/ problem for what we're trying to do (draw a nice looking curve).\n-    int rootsOfROCMinusW(final double[] roots, final int off, final double w2, final double err) {\n-        \/\/ no OOB exception, because by now off<=6, and roots.length >= 10\n-        assert off <= 6 && roots.length >= 10;\n-\n-        int ret = off;\n-        final int end = off + perpendiculardfddf(roots, off);\n-        roots[end] = 1.0d; \/\/ always check interval end points\n-\n-        double t0 = 0.0d, ft0 = ROCsq(t0) - w2;\n-\n-        for (int i = off; i <= end; i++) {\n-            double t1 = roots[i], ft1 = ROCsq(t1) - w2;\n-            if (ft0 == 0.0d) {\n-                roots[ret++] = t0;\n-            } else if (ft1 * ft0 < 0.0d) { \/\/ have opposite signs\n-                \/\/ (ROC(t)^2 == w^2) == (ROC(t) == w) is true because\n-                \/\/ ROC(t) >= 0 for all t.\n-                roots[ret++] = falsePositionROCsqMinusX(t0, t1, w2, err);\n-            }\n-            t0 = t1;\n-            ft0 = ft1;\n-        }\n-\n-        return ret - off;\n-    }\n-\n-    private static double eliminateInf(final double x) {\n-        return (x == Double.POSITIVE_INFINITY ? Double.MAX_VALUE :\n-               (x == Double.NEGATIVE_INFINITY ? Double.MIN_VALUE : x));\n-    }\n-\n-    \/\/ A slight modification of the false position algorithm on wikipedia.\n-    \/\/ This only works for the ROCsq-x functions. It might be nice to have\n-    \/\/ the function as an argument, but that would be awkward in java6.\n-    \/\/ TODO: It is something to consider for java8 (or whenever lambda\n-    \/\/ expressions make it into the language), depending on how closures\n-    \/\/ and turn out. Same goes for the newton's method\n-    \/\/ algorithm in DHelpers.java\n-    private double falsePositionROCsqMinusX(final double t0, final double t1,\n-                                            final double w2, final double err)\n-    {\n-        final int iterLimit = 100;\n-        int side = 0;\n-        double t = t1, ft = eliminateInf(ROCsq(t) - w2);\n-        double s = t0, fs = eliminateInf(ROCsq(s) - w2);\n-        double r = s, fr;\n-\n-        for (int i = 0; i < iterLimit && Math.abs(t - s) > err * Math.abs(t + s); i++) {\n-            r = (fs * t - ft * s) \/ (fs - ft);\n-            fr = ROCsq(r) - w2;\n-            if (sameSign(fr, ft)) {\n-                ft = fr; t = r;\n-                if (side < 0) {\n-                    fs \/= (1 << (-side));\n-                    side--;\n-                } else {\n-                    side = -1;\n-                }\n-            } else if (fr * fs > 0.0d) {\n-                fs = fr; s = r;\n-                if (side > 0) {\n-                    ft \/= (1 << side);\n-                    side++;\n-                } else {\n-                    side = 1;\n-                }\n-            } else {\n-                break;\n-            }\n-        }\n-        return r;\n-    }\n-\n-    private static boolean sameSign(final double x, final double y) {\n-        \/\/ another way is to test if x*y > 0. This is bad for small x, y.\n-        return (x < 0.0d && y < 0.0d) || (x > 0.0d && y > 0.0d);\n-    }\n-\n-    \/\/ returns the radius of curvature squared at t of this curve\n-    \/\/ see http:\/\/en.wikipedia.org\/wiki\/Radius_of_curvature_(applications)\n-    private double ROCsq(final double t) {\n-        final double dx = t * (t * dax + dbx) + cx;\n-        final double dy = t * (t * day + dby) + cy;\n-        final double ddx = 2.0d * dax * t + dbx;\n-        final double ddy = 2.0d * day * t + dby;\n-        final double dx2dy2 = dx * dx + dy * dy;\n-        final double ddx2ddy2 = ddx * ddx + ddy * ddy;\n-        final double ddxdxddydy = ddx * dx + ddy * dy;\n-        return dx2dy2 * ((dx2dy2 * dx2dy2) \/ (dx2dy2 * ddx2ddy2 - ddxdxddydy * ddxdxddydy));\n-    }\n-}\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/marlin\/DCurve.java","additions":0,"deletions":264,"binary":false,"changes":264,"status":"deleted"},{"patch":"@@ -1,1123 +0,0 @@\n-\/*\n- * Copyright (c) 2007, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package sun.java2d.marlin;\n-\n-import java.util.Arrays;\n-import sun.java2d.marlin.DTransformingPathConsumer2D.CurveBasicMonotonizer;\n-import sun.java2d.marlin.DTransformingPathConsumer2D.CurveClipSplitter;\n-\n-\/**\n- * The <code>DDasher<\/code> class takes a series of linear commands\n- * (<code>moveTo<\/code>, <code>lineTo<\/code>, <code>close<\/code> and\n- * <code>end<\/code>) and breaks them into smaller segments according to a\n- * dash pattern array and a starting dash phase.\n- *\n- * <p> Issues: in J2Se, a zero length dash segment as drawn as a very\n- * short dash, whereas Pisces does not draw anything.  The PostScript\n- * semantics are unclear.\n- *\n- *\/\n-final class DDasher implements DPathConsumer2D, MarlinConst {\n-\n-    \/* huge circle with radius ~ 2E9 only needs 12 subdivision levels *\/\n-    static final int REC_LIMIT = 16;\n-    static final double CURVE_LEN_ERR = MarlinProperties.getCurveLengthError(); \/\/ 0.01 initial\n-    static final double MIN_T_INC = 1.0d \/ (1 << REC_LIMIT);\n-\n-    static final double EPS = 1e-6d;\n-\n-    \/\/ More than 24 bits of mantissa means we can no longer accurately\n-    \/\/ measure the number of times cycled through the dash array so we\n-    \/\/ punt and override the phase to just be 0 past that point.\n-    static final double MAX_CYCLES = 16000000.0d;\n-\n-    private DPathConsumer2D out;\n-    private double[] dash;\n-    private int dashLen;\n-    private double startPhase;\n-    private boolean startDashOn;\n-    private int startIdx;\n-\n-    private boolean starting;\n-    private boolean needsMoveTo;\n-\n-    private int idx;\n-    private boolean dashOn;\n-    private double phase;\n-\n-    \/\/ The starting point of the path\n-    private double sx0, sy0;\n-    \/\/ the current point\n-    private double cx0, cy0;\n-\n-    \/\/ temporary storage for the current curve\n-    private final double[] curCurvepts;\n-\n-    \/\/ per-thread renderer context\n-    final DRendererContext rdrCtx;\n-\n-    \/\/ flag to recycle dash array copy\n-    boolean recycleDashes;\n-\n-    \/\/ We don't emit the first dash right away. If we did, caps would be\n-    \/\/ drawn on it, but we need joins to be drawn if there's a closePath()\n-    \/\/ So, we store the path elements that make up the first dash in the\n-    \/\/ buffer below.\n-    private double[] firstSegmentsBuffer; \/\/ dynamic array\n-    private int firstSegidx;\n-\n-    \/\/ dashes ref (dirty)\n-    final DoubleArrayCache.Reference dashes_ref;\n-    \/\/ firstSegmentsBuffer ref (dirty)\n-    final DoubleArrayCache.Reference firstSegmentsBuffer_ref;\n-\n-    \/\/ Bounds of the drawing region, at pixel precision.\n-    private double[] clipRect;\n-\n-    \/\/ the outcode of the current point\n-    private int cOutCode = 0;\n-\n-    private boolean subdivide = DO_CLIP_SUBDIVIDER;\n-\n-    private final LengthIterator li = new LengthIterator();\n-\n-    private final CurveClipSplitter curveSplitter;\n-\n-    private double cycleLen;\n-    private boolean outside;\n-    private double totalSkipLen;\n-\n-    \/**\n-     * Constructs a <code>DDasher<\/code>.\n-     * @param rdrCtx per-thread renderer context\n-     *\/\n-    DDasher(final DRendererContext rdrCtx) {\n-        this.rdrCtx = rdrCtx;\n-\n-        dashes_ref = rdrCtx.newDirtyDoubleArrayRef(INITIAL_ARRAY); \/\/ 1K\n-\n-        firstSegmentsBuffer_ref = rdrCtx.newDirtyDoubleArrayRef(INITIAL_ARRAY); \/\/ 1K\n-        firstSegmentsBuffer     = firstSegmentsBuffer_ref.initial;\n-\n-        \/\/ we need curCurvepts to be able to contain 2 curves because when\n-        \/\/ dashing curves, we need to subdivide it\n-        curCurvepts = new double[8 * 2];\n-\n-        this.curveSplitter = rdrCtx.curveClipSplitter;\n-    }\n-\n-    \/**\n-     * Initialize the <code>DDasher<\/code>.\n-     *\n-     * @param out an output <code>DPathConsumer2D<\/code>.\n-     * @param dash an array of <code>double<\/code>s containing the dash pattern\n-     * @param dashLen length of the given dash array\n-     * @param phase a <code>double<\/code> containing the dash phase\n-     * @param recycleDashes true to indicate to recycle the given dash array\n-     * @return this instance\n-     *\/\n-    DDasher init(final DPathConsumer2D out, final double[] dash, final int dashLen,\n-                double phase, final boolean recycleDashes)\n-    {\n-        this.out = out;\n-\n-        \/\/ Normalize so 0 <= phase < dash[0]\n-        int sidx = 0;\n-        dashOn = true;\n-\n-        \/\/ note: BasicStroke constructor checks dash elements and sum > 0\n-        double sum = 0.0d;\n-        for (int i = 0; i < dashLen; i++) {\n-            sum += dash[i];\n-        }\n-        this.cycleLen = sum;\n-\n-        double cycles = phase \/ sum;\n-        if (phase < 0.0d) {\n-            if (-cycles >= MAX_CYCLES) {\n-                phase = 0.0d;\n-            } else {\n-                int fullcycles = FloatMath.floor_int(-cycles);\n-                if ((fullcycles & dashLen & 1) != 0) {\n-                    dashOn = !dashOn;\n-                }\n-                phase += fullcycles * sum;\n-                while (phase < 0.0d) {\n-                    if (--sidx < 0) {\n-                        sidx = dashLen - 1;\n-                    }\n-                    phase += dash[sidx];\n-                    dashOn = !dashOn;\n-                }\n-            }\n-        } else if (phase > 0.0d) {\n-            if (cycles >= MAX_CYCLES) {\n-                phase = 0.0d;\n-            } else {\n-                int fullcycles = FloatMath.floor_int(cycles);\n-                if ((fullcycles & dashLen & 1) != 0) {\n-                    dashOn = !dashOn;\n-                }\n-                phase -= fullcycles * sum;\n-                double d;\n-                while (phase >= (d = dash[sidx])) {\n-                    phase -= d;\n-                    sidx = (sidx + 1) % dashLen;\n-                    dashOn = !dashOn;\n-                }\n-            }\n-        }\n-\n-        this.dash = dash;\n-        this.dashLen = dashLen;\n-        this.phase = phase;\n-        this.startPhase = phase;\n-        this.startDashOn = dashOn;\n-        this.startIdx = sidx;\n-        this.starting = true;\n-        this.needsMoveTo = false;\n-        this.firstSegidx = 0;\n-\n-        this.recycleDashes = recycleDashes;\n-\n-        if (rdrCtx.doClip) {\n-            this.clipRect = rdrCtx.clipRect;\n-        } else {\n-            this.clipRect = null;\n-            this.cOutCode = 0;\n-        }\n-        return this; \/\/ fluent API\n-    }\n-\n-    \/**\n-     * Disposes this dasher:\n-     * clean up before reusing this instance\n-     *\/\n-    void dispose() {\n-        if (DO_CLEAN_DIRTY) {\n-            \/\/ Force zero-fill dirty arrays:\n-            Arrays.fill(curCurvepts, 0.0d);\n-        }\n-        \/\/ Return arrays:\n-        if (recycleDashes) {\n-            dash = dashes_ref.putArray(dash);\n-        }\n-        firstSegmentsBuffer = firstSegmentsBuffer_ref.putArray(firstSegmentsBuffer);\n-    }\n-\n-    double[] copyDashArray(final float[] dashes) {\n-        final int len = dashes.length;\n-        final double[] newDashes;\n-        if (len <= MarlinConst.INITIAL_ARRAY) {\n-            newDashes = dashes_ref.initial;\n-        } else {\n-            if (DO_STATS) {\n-                rdrCtx.stats.stat_array_dasher_dasher.add(len);\n-            }\n-            newDashes = dashes_ref.getArray(len);\n-        }\n-        for (int i = 0; i < len; i++) { newDashes[i] = dashes[i]; }\n-        return newDashes;\n-    }\n-\n-    @Override\n-    public void moveTo(final double x0, final double y0) {\n-        if (firstSegidx != 0) {\n-            out.moveTo(sx0, sy0);\n-            emitFirstSegments();\n-        }\n-        this.needsMoveTo = true;\n-        this.idx = startIdx;\n-        this.dashOn = this.startDashOn;\n-        this.phase = this.startPhase;\n-        this.cx0 = x0;\n-        this.cy0 = y0;\n-\n-        \/\/ update starting point:\n-        this.sx0 = x0;\n-        this.sy0 = y0;\n-        this.starting = true;\n-\n-        if (clipRect != null) {\n-            final int outcode = DHelpers.outcode(x0, y0, clipRect);\n-            this.cOutCode = outcode;\n-            this.outside = false;\n-            this.totalSkipLen = 0.0d;\n-        }\n-    }\n-\n-    private void emitSeg(double[] buf, int off, int type) {\n-        switch (type) {\n-        case 4:\n-            out.lineTo(buf[off], buf[off + 1]);\n-            return;\n-        case 8:\n-            out.curveTo(buf[off    ], buf[off + 1],\n-                        buf[off + 2], buf[off + 3],\n-                        buf[off + 4], buf[off + 5]);\n-            return;\n-        case 6:\n-            out.quadTo(buf[off    ], buf[off + 1],\n-                       buf[off + 2], buf[off + 3]);\n-            return;\n-        default:\n-        }\n-    }\n-\n-    private void emitFirstSegments() {\n-        final double[] fSegBuf = firstSegmentsBuffer;\n-\n-        for (int i = 0, len = firstSegidx; i < len; ) {\n-            int type = (int)fSegBuf[i];\n-            emitSeg(fSegBuf, i + 1, type);\n-            i += (type - 1);\n-        }\n-        firstSegidx = 0;\n-    }\n-\n-    \/\/ precondition: pts must be in relative coordinates (relative to x0,y0)\n-    private void goTo(final double[] pts, final int off, final int type,\n-                      final boolean on)\n-    {\n-        final int index = off + type;\n-        final double x = pts[index - 4];\n-        final double y = pts[index - 3];\n-\n-        if (on) {\n-            if (starting) {\n-                goTo_starting(pts, off, type);\n-            } else {\n-                if (needsMoveTo) {\n-                    needsMoveTo = false;\n-                    out.moveTo(cx0, cy0);\n-                }\n-                emitSeg(pts, off, type);\n-            }\n-        } else {\n-            if (starting) {\n-                \/\/ low probability test (hotspot)\n-                starting = false;\n-            }\n-            needsMoveTo = true;\n-        }\n-        this.cx0 = x;\n-        this.cy0 = y;\n-    }\n-\n-    private void goTo_starting(final double[] pts, final int off, final int type) {\n-        int len = type - 1; \/\/ - 2 + 1\n-        int segIdx = firstSegidx;\n-        double[] buf = firstSegmentsBuffer;\n-\n-        if (segIdx + len  > buf.length) {\n-            if (DO_STATS) {\n-                rdrCtx.stats.stat_array_dasher_firstSegmentsBuffer\n-                    .add(segIdx + len);\n-            }\n-            firstSegmentsBuffer = buf\n-                = firstSegmentsBuffer_ref.widenArray(buf, segIdx,\n-                                                     segIdx + len);\n-        }\n-        buf[segIdx++] = type;\n-        len--;\n-        \/\/ small arraycopy (2, 4 or 6) but with offset:\n-        System.arraycopy(pts, off, buf, segIdx, len);\n-        firstSegidx = segIdx + len;\n-    }\n-\n-    @Override\n-    public void lineTo(final double x1, final double y1) {\n-        final int outcode0 = this.cOutCode;\n-\n-        if (clipRect != null) {\n-            final int outcode1 = DHelpers.outcode(x1, y1, clipRect);\n-\n-            \/\/ Should clip\n-            final int orCode = (outcode0 | outcode1);\n-\n-            if (orCode != 0) {\n-                final int sideCode = outcode0 & outcode1;\n-\n-                \/\/ basic rejection criteria:\n-                if (sideCode == 0) {\n-                    \/\/ overlap clip:\n-                    if (subdivide) {\n-                        \/\/ avoid reentrance\n-                        subdivide = false;\n-                        \/\/ subdivide curve => callback with subdivided parts:\n-                        boolean ret = curveSplitter.splitLine(cx0, cy0, x1, y1,\n-                                                              orCode, this);\n-                        \/\/ reentrance is done:\n-                        subdivide = true;\n-                        if (ret) {\n-                            return;\n-                        }\n-                    }\n-                    \/\/ already subdivided so render it\n-                } else {\n-                    this.cOutCode = outcode1;\n-                    skipLineTo(x1, y1);\n-                    return;\n-                }\n-            }\n-\n-            this.cOutCode = outcode1;\n-\n-            if (this.outside) {\n-                this.outside = false;\n-                \/\/ Adjust current index, phase & dash:\n-                skipLen();\n-            }\n-        }\n-        _lineTo(x1, y1);\n-    }\n-\n-    private void _lineTo(final double x1, final double y1) {\n-        final double dx = x1 - cx0;\n-        final double dy = y1 - cy0;\n-\n-        double len = dx * dx + dy * dy;\n-        if (len == 0.0d) {\n-            return;\n-        }\n-        len = Math.sqrt(len);\n-\n-        \/\/ The scaling factors needed to get the dx and dy of the\n-        \/\/ transformed dash segments.\n-        final double cx = dx \/ len;\n-        final double cy = dy \/ len;\n-\n-        final double[] _curCurvepts = curCurvepts;\n-        final double[] _dash = dash;\n-        final int _dashLen = this.dashLen;\n-\n-        int _idx = idx;\n-        boolean _dashOn = dashOn;\n-        double _phase = phase;\n-\n-        double leftInThisDashSegment, rem;\n-\n-        while (true) {\n-            leftInThisDashSegment = _dash[_idx] - _phase;\n-            rem = len - leftInThisDashSegment;\n-\n-            if (rem <= EPS) {\n-                _curCurvepts[0] = x1;\n-                _curCurvepts[1] = y1;\n-\n-                goTo(_curCurvepts, 0, 4, _dashOn);\n-\n-                \/\/ Advance phase within current dash segment\n-                _phase += len;\n-\n-                \/\/ compare values using epsilon:\n-                if (Math.abs(rem) <= EPS) {\n-                    _phase = 0.0d;\n-                    _idx = (_idx + 1) % _dashLen;\n-                    _dashOn = !_dashOn;\n-                }\n-                break;\n-            }\n-\n-            _curCurvepts[0] = cx0 + leftInThisDashSegment * cx;\n-            _curCurvepts[1] = cy0 + leftInThisDashSegment * cy;\n-\n-            goTo(_curCurvepts, 0, 4, _dashOn);\n-\n-            len = rem;\n-            \/\/ Advance to next dash segment\n-            _idx = (_idx + 1) % _dashLen;\n-            _dashOn = !_dashOn;\n-            _phase = 0.0d;\n-        }\n-        \/\/ Save local state:\n-        idx = _idx;\n-        dashOn = _dashOn;\n-        phase = _phase;\n-    }\n-\n-    private void skipLineTo(final double x1, final double y1) {\n-        final double dx = x1 - cx0;\n-        final double dy = y1 - cy0;\n-\n-        double len = dx * dx + dy * dy;\n-        if (len != 0.0d) {\n-            len = Math.sqrt(len);\n-        }\n-\n-        \/\/ Accumulate skipped length:\n-        this.outside = true;\n-        this.totalSkipLen += len;\n-\n-        \/\/ Fix initial move:\n-        this.needsMoveTo = true;\n-        this.starting = false;\n-\n-        this.cx0 = x1;\n-        this.cy0 = y1;\n-    }\n-\n-    public void skipLen() {\n-        double len = this.totalSkipLen;\n-        this.totalSkipLen = 0.0d;\n-\n-        final double[] _dash = dash;\n-        final int _dashLen = this.dashLen;\n-\n-        int _idx = idx;\n-        boolean _dashOn = dashOn;\n-        double _phase = phase;\n-\n-        \/\/ -2 to ensure having 2 iterations of the post-loop\n-        \/\/ to compensate the remaining phase\n-        final long fullcycles = (long)Math.floor(len \/ cycleLen) - 2L;\n-\n-        if (fullcycles > 0L) {\n-            len -= cycleLen * fullcycles;\n-\n-            final long iterations = fullcycles * _dashLen;\n-            _idx = (int) (iterations + _idx) % _dashLen;\n-            _dashOn = (iterations + (_dashOn ? 1L : 0L) & 1L) == 1L;\n-        }\n-\n-        double leftInThisDashSegment, rem;\n-\n-        while (true) {\n-            leftInThisDashSegment = _dash[_idx] - _phase;\n-            rem = len - leftInThisDashSegment;\n-\n-            if (rem <= EPS) {\n-                \/\/ Advance phase within current dash segment\n-                _phase += len;\n-\n-                \/\/ compare values using epsilon:\n-                if (Math.abs(rem) <= EPS) {\n-                    _phase = 0.0d;\n-                    _idx = (_idx + 1) % _dashLen;\n-                    _dashOn = !_dashOn;\n-                }\n-                break;\n-            }\n-\n-            len = rem;\n-            \/\/ Advance to next dash segment\n-            _idx = (_idx + 1) % _dashLen;\n-            _dashOn = !_dashOn;\n-            _phase = 0.0d;\n-        }\n-        \/\/ Save local state:\n-        idx = _idx;\n-        dashOn = _dashOn;\n-        phase = _phase;\n-    }\n-\n-    \/\/ preconditions: curCurvepts must be an array of length at least 2 * type,\n-    \/\/ that contains the curve we want to dash in the first type elements\n-    private void somethingTo(final int type) {\n-        final double[] _curCurvepts = curCurvepts;\n-        if (pointCurve(_curCurvepts, type)) {\n-            return;\n-        }\n-        final LengthIterator _li = li;\n-        final double[] _dash = dash;\n-        final int _dashLen = this.dashLen;\n-\n-        _li.initializeIterationOnCurve(_curCurvepts, type);\n-\n-        int _idx = idx;\n-        boolean _dashOn = dashOn;\n-        double _phase = phase;\n-\n-        \/\/ initially the current curve is at curCurvepts[0...type]\n-        int curCurveoff = 0;\n-        double prevT = 0.0d;\n-        double t;\n-        double leftInThisDashSegment = _dash[_idx] - _phase;\n-\n-        while ((t = _li.next(leftInThisDashSegment)) < 1.0d) {\n-            if (t != 0.0d) {\n-                DHelpers.subdivideAt((t - prevT) \/ (1.0d - prevT),\n-                                    _curCurvepts, curCurveoff,\n-                                    _curCurvepts, 0, type);\n-                prevT = t;\n-                goTo(_curCurvepts, 2, type, _dashOn);\n-                curCurveoff = type;\n-            }\n-            \/\/ Advance to next dash segment\n-            _idx = (_idx + 1) % _dashLen;\n-            _dashOn = !_dashOn;\n-            _phase = 0.0d;\n-            leftInThisDashSegment = _dash[_idx];\n-        }\n-\n-        goTo(_curCurvepts, curCurveoff + 2, type, _dashOn);\n-\n-        _phase += _li.lastSegLen();\n-\n-        \/\/ compare values using epsilon:\n-        if (_phase + EPS >= _dash[_idx]) {\n-            _phase = 0.0d;\n-            _idx = (_idx + 1) % _dashLen;\n-            _dashOn = !_dashOn;\n-        }\n-        \/\/ Save local state:\n-        idx = _idx;\n-        dashOn = _dashOn;\n-        phase = _phase;\n-\n-        \/\/ reset LengthIterator:\n-        _li.reset();\n-    }\n-\n-    private void skipSomethingTo(final int type) {\n-        final double[] _curCurvepts = curCurvepts;\n-        if (pointCurve(_curCurvepts, type)) {\n-            return;\n-        }\n-        final LengthIterator _li = li;\n-\n-        _li.initializeIterationOnCurve(_curCurvepts, type);\n-\n-        \/\/ In contrary to somethingTo(),\n-        \/\/ just estimate properly the curve length:\n-        final double len = _li.totalLength();\n-\n-        \/\/ Accumulate skipped length:\n-        this.outside = true;\n-        this.totalSkipLen += len;\n-\n-        \/\/ Fix initial move:\n-        this.needsMoveTo = true;\n-        this.starting = false;\n-    }\n-\n-    private static boolean pointCurve(final double[] curve, final int type) {\n-        for (int i = 2; i < type; i++) {\n-            if (curve[i] != curve[i-2]) {\n-                return false;\n-            }\n-        }\n-        return true;\n-    }\n-\n-    \/\/ Objects of this class are used to iterate through curves. They return\n-    \/\/ t values where the left side of the curve has a specified length.\n-    \/\/ It does this by subdividing the input curve until a certain error\n-    \/\/ condition has been met. A recursive subdivision procedure would\n-    \/\/ return as many as 1<<limit curves, but this is an iterator and we\n-    \/\/ don't need all the curves all at once, so what we carry out a\n-    \/\/ lazy inorder traversal of the recursion tree (meaning we only move\n-    \/\/ through the tree when we need the next subdivided curve). This saves\n-    \/\/ us a lot of memory because at any one time we only need to store\n-    \/\/ limit+1 curves - one for each level of the tree + 1.\n-    \/\/ NOTE: the way we do things here is not enough to traverse a general\n-    \/\/ tree; however, the trees we are interested in have the property that\n-    \/\/ every non leaf node has exactly 2 children\n-    static final class LengthIterator {\n-        \/\/ Holds the curves at various levels of the recursion. The root\n-        \/\/ (i.e. the original curve) is at recCurveStack[0] (but then it\n-        \/\/ gets subdivided, the left half is put at 1, so most of the time\n-        \/\/ only the right half of the original curve is at 0)\n-        private final double[][] recCurveStack; \/\/ dirty\n-        \/\/ sidesRight[i] indicates whether the node at level i+1 in the path from\n-        \/\/ the root to the current leaf is a left or right child of its parent.\n-        private final boolean[] sidesRight; \/\/ dirty\n-        private int curveType;\n-        \/\/ lastT and nextT delimit the current leaf.\n-        private double nextT;\n-        private double lenAtNextT;\n-        private double lastT;\n-        private double lenAtLastT;\n-        private double lenAtLastSplit;\n-        private double lastSegLen;\n-        \/\/ the current level in the recursion tree. 0 is the root. limit\n-        \/\/ is the deepest possible leaf.\n-        private int recLevel;\n-        private boolean done;\n-\n-        \/\/ the lengths of the lines of the control polygon. Only its first\n-        \/\/ curveType\/2 - 1 elements are valid. This is an optimization. See\n-        \/\/ next() for more detail.\n-        private final double[] curLeafCtrlPolyLengths = new double[3];\n-\n-        LengthIterator() {\n-            this.recCurveStack = new double[REC_LIMIT + 1][8];\n-            this.sidesRight = new boolean[REC_LIMIT];\n-            \/\/ if any methods are called without first initializing this object\n-            \/\/ on a curve, we want it to fail ASAP.\n-            this.nextT = Double.MAX_VALUE;\n-            this.lenAtNextT = Double.MAX_VALUE;\n-            this.lenAtLastSplit = Double.MIN_VALUE;\n-            this.recLevel = Integer.MIN_VALUE;\n-            this.lastSegLen = Double.MAX_VALUE;\n-            this.done = true;\n-        }\n-\n-        \/**\n-         * Reset this LengthIterator.\n-         *\/\n-        void reset() {\n-            \/\/ keep data dirty\n-            \/\/ as it appears not useful to reset data:\n-            if (DO_CLEAN_DIRTY) {\n-                final int recLimit = recCurveStack.length - 1;\n-                for (int i = recLimit; i >= 0; i--) {\n-                    Arrays.fill(recCurveStack[i], 0.0d);\n-                }\n-                Arrays.fill(sidesRight, false);\n-                Arrays.fill(curLeafCtrlPolyLengths, 0.0d);\n-                Arrays.fill(nextRoots, 0.0d);\n-                Arrays.fill(flatLeafCoefCache, 0.0d);\n-                flatLeafCoefCache[2] = -1.0d;\n-            }\n-        }\n-\n-        void initializeIterationOnCurve(final double[] pts, final int type) {\n-            \/\/ optimize arraycopy (8 values faster than 6 = type):\n-            System.arraycopy(pts, 0, recCurveStack[0], 0, 8);\n-            this.curveType = type;\n-            this.recLevel = 0;\n-            this.lastT = 0.0d;\n-            this.lenAtLastT = 0.0d;\n-            this.nextT = 0.0d;\n-            this.lenAtNextT = 0.0d;\n-            goLeft(); \/\/ initializes nextT and lenAtNextT properly\n-            this.lenAtLastSplit = 0.0d;\n-            if (recLevel > 0) {\n-                this.sidesRight[0] = false;\n-                this.done = false;\n-            } else {\n-                \/\/ the root of the tree is a leaf so we're done.\n-                this.sidesRight[0] = true;\n-                this.done = true;\n-            }\n-            this.lastSegLen = 0.0d;\n-        }\n-\n-        \/\/ 0 == false, 1 == true, -1 == invalid cached value.\n-        private int cachedHaveLowAcceleration = -1;\n-\n-        private boolean haveLowAcceleration(final double err) {\n-            if (cachedHaveLowAcceleration == -1) {\n-                final double len1 = curLeafCtrlPolyLengths[0];\n-                final double len2 = curLeafCtrlPolyLengths[1];\n-                \/\/ the test below is equivalent to !within(len1\/len2, 1, err).\n-                \/\/ It is using a multiplication instead of a division, so it\n-                \/\/ should be a bit faster.\n-                if (!DHelpers.within(len1, len2, err * len2)) {\n-                    cachedHaveLowAcceleration = 0;\n-                    return false;\n-                }\n-                if (curveType == 8) {\n-                    final double len3 = curLeafCtrlPolyLengths[2];\n-                    \/\/ if len1 is close to 2 and 2 is close to 3, that probably\n-                    \/\/ means 1 is close to 3 so the second part of this test might\n-                    \/\/ not be needed, but it doesn't hurt to include it.\n-                    final double errLen3 = err * len3;\n-                    if (!(DHelpers.within(len2, len3, errLen3) &&\n-                          DHelpers.within(len1, len3, errLen3))) {\n-                        cachedHaveLowAcceleration = 0;\n-                        return false;\n-                    }\n-                }\n-                cachedHaveLowAcceleration = 1;\n-                return true;\n-            }\n-\n-            return (cachedHaveLowAcceleration == 1);\n-        }\n-\n-        \/\/ we want to avoid allocations\/gc so we keep this array so we\n-        \/\/ can put roots in it,\n-        private final double[] nextRoots = new double[4];\n-\n-        \/\/ caches the coefficients of the current leaf in its flattened\n-        \/\/ form (see inside next() for what that means). The cache is\n-        \/\/ invalid when it's third element is negative, since in any\n-        \/\/ valid flattened curve, this would be >= 0.\n-        private final double[] flatLeafCoefCache = new double[]{0.0d, 0.0d, -1.0d, 0.0d};\n-\n-        \/\/ returns the t value where the remaining curve should be split in\n-        \/\/ order for the left subdivided curve to have length len. If len\n-        \/\/ is >= than the length of the uniterated curve, it returns 1.\n-        double next(final double len) {\n-            final double targetLength = lenAtLastSplit + len;\n-            while (lenAtNextT < targetLength) {\n-                if (done) {\n-                    lastSegLen = lenAtNextT - lenAtLastSplit;\n-                    return 1.0d;\n-                }\n-                goToNextLeaf();\n-            }\n-            lenAtLastSplit = targetLength;\n-            final double leaflen = lenAtNextT - lenAtLastT;\n-            double t = (targetLength - lenAtLastT) \/ leaflen;\n-\n-            \/\/ cubicRootsInAB is a fairly expensive call, so we just don't do it\n-            \/\/ if the acceleration in this section of the curve is small enough.\n-            if (!haveLowAcceleration(0.05d)) {\n-                \/\/ We flatten the current leaf along the x axis, so that we're\n-                \/\/ left with a, b, c which define a 1D Bezier curve. We then\n-                \/\/ solve this to get the parameter of the original leaf that\n-                \/\/ gives us the desired length.\n-                final double[] _flatLeafCoefCache = flatLeafCoefCache;\n-\n-                if (_flatLeafCoefCache[2] < 0.0d) {\n-                    double x =     curLeafCtrlPolyLengths[0],\n-                           y = x + curLeafCtrlPolyLengths[1];\n-                    if (curveType == 8) {\n-                        double z = y + curLeafCtrlPolyLengths[2];\n-                        _flatLeafCoefCache[0] = 3.0d * (x - y) + z;\n-                        _flatLeafCoefCache[1] = 3.0d * (y - 2.0d * x);\n-                        _flatLeafCoefCache[2] = 3.0d * x;\n-                        _flatLeafCoefCache[3] = -z;\n-                    } else if (curveType == 6) {\n-                        _flatLeafCoefCache[0] = 0.0d;\n-                        _flatLeafCoefCache[1] = y - 2.0d * x;\n-                        _flatLeafCoefCache[2] = 2.0d * x;\n-                        _flatLeafCoefCache[3] = -y;\n-                    }\n-                }\n-                double a = _flatLeafCoefCache[0];\n-                double b = _flatLeafCoefCache[1];\n-                double c = _flatLeafCoefCache[2];\n-                double d = t * _flatLeafCoefCache[3];\n-\n-                \/\/ we use cubicRootsInAB here, because we want only roots in 0, 1,\n-                \/\/ and our quadratic root finder doesn't filter, so it's just a\n-                \/\/ matter of convenience.\n-                final int n = DHelpers.cubicRootsInAB(a, b, c, d, nextRoots, 0, 0.0d, 1.0d);\n-                if (n == 1 && !Double.isNaN(nextRoots[0])) {\n-                    t = nextRoots[0];\n-                }\n-            }\n-            \/\/ t is relative to the current leaf, so we must make it a valid parameter\n-            \/\/ of the original curve.\n-            t = t * (nextT - lastT) + lastT;\n-            if (t >= 1.0d) {\n-                t = 1.0d;\n-                done = true;\n-            }\n-            \/\/ even if done = true, if we're here, that means targetLength\n-            \/\/ is equal to, or very, very close to the total length of the\n-            \/\/ curve, so lastSegLen won't be too high. In cases where len\n-            \/\/ overshoots the curve, this method will exit in the while\n-            \/\/ loop, and lastSegLen will still be set to the right value.\n-            lastSegLen = len;\n-            return t;\n-        }\n-\n-        double totalLength() {\n-            while (!done) {\n-                goToNextLeaf();\n-            }\n-            \/\/ reset LengthIterator:\n-            reset();\n-\n-            return lenAtNextT;\n-        }\n-\n-        double lastSegLen() {\n-            return lastSegLen;\n-        }\n-\n-        \/\/ go to the next leaf (in an inorder traversal) in the recursion tree\n-        \/\/ preconditions: must be on a leaf, and that leaf must not be the root.\n-        private void goToNextLeaf() {\n-            \/\/ We must go to the first ancestor node that has an unvisited\n-            \/\/ right child.\n-            final boolean[] _sides = sidesRight;\n-            int _recLevel = recLevel;\n-            _recLevel--;\n-\n-            while(_sides[_recLevel]) {\n-                if (_recLevel == 0) {\n-                    recLevel = 0;\n-                    done = true;\n-                    return;\n-                }\n-                _recLevel--;\n-            }\n-\n-            _sides[_recLevel] = true;\n-            \/\/ optimize arraycopy (8 values faster than 6 = type):\n-            System.arraycopy(recCurveStack[_recLevel++], 0,\n-                             recCurveStack[_recLevel], 0, 8);\n-            recLevel = _recLevel;\n-            goLeft();\n-        }\n-\n-        \/\/ go to the leftmost node from the current node. Return its length.\n-        private void goLeft() {\n-            final double len = onLeaf();\n-            if (len >= 0.0d) {\n-                lastT = nextT;\n-                lenAtLastT = lenAtNextT;\n-                nextT += (1 << (REC_LIMIT - recLevel)) * MIN_T_INC;\n-                lenAtNextT += len;\n-                \/\/ invalidate caches\n-                flatLeafCoefCache[2] = -1.0d;\n-                cachedHaveLowAcceleration = -1;\n-            } else {\n-                DHelpers.subdivide(recCurveStack[recLevel],\n-                                   recCurveStack[recLevel + 1],\n-                                   recCurveStack[recLevel], curveType);\n-\n-                sidesRight[recLevel] = false;\n-                recLevel++;\n-                goLeft();\n-            }\n-        }\n-\n-        \/\/ this is a bit of a hack. It returns -1 if we're not on a leaf, and\n-        \/\/ the length of the leaf if we are on a leaf.\n-        private double onLeaf() {\n-            final double[] curve = recCurveStack[recLevel];\n-            final int _curveType = curveType;\n-            double polyLen = 0.0d;\n-\n-            double x0 = curve[0], y0 = curve[1];\n-            for (int i = 2; i < _curveType; i += 2) {\n-                final double x1 = curve[i], y1 = curve[i + 1];\n-                final double len = DHelpers.linelen(x0, y0, x1, y1);\n-                polyLen += len;\n-                curLeafCtrlPolyLengths[(i >> 1) - 1] = len;\n-                x0 = x1;\n-                y0 = y1;\n-            }\n-\n-            final double lineLen = DHelpers.linelen(curve[0], curve[1], x0, y0);\n-\n-            if ((polyLen - lineLen) < CURVE_LEN_ERR || recLevel == REC_LIMIT) {\n-                return (polyLen + lineLen) \/ 2.0d;\n-            }\n-            return -1.0d;\n-        }\n-    }\n-\n-    @Override\n-    public void curveTo(final double x1, final double y1,\n-                        final double x2, final double y2,\n-                        final double x3, final double y3)\n-    {\n-        final int outcode0 = this.cOutCode;\n-\n-        if (clipRect != null) {\n-            final int outcode1 = DHelpers.outcode(x1, y1, clipRect);\n-            final int outcode2 = DHelpers.outcode(x2, y2, clipRect);\n-            final int outcode3 = DHelpers.outcode(x3, y3, clipRect);\n-\n-            \/\/ Should clip\n-            final int orCode = (outcode0 | outcode1 | outcode2 | outcode3);\n-            if (orCode != 0) {\n-                final int sideCode = outcode0 & outcode1 & outcode2 & outcode3;\n-\n-                \/\/ basic rejection criteria:\n-                if (sideCode == 0) {\n-                    \/\/ overlap clip:\n-                    if (subdivide) {\n-                        \/\/ avoid reentrance\n-                        subdivide = false;\n-                        \/\/ subdivide curve => callback with subdivided parts:\n-                        boolean ret = curveSplitter.splitCurve(cx0, cy0, x1, y1, x2, y2, x3, y3,\n-                                                               orCode, this);\n-                        \/\/ reentrance is done:\n-                        subdivide = true;\n-                        if (ret) {\n-                            return;\n-                        }\n-                    }\n-                    \/\/ already subdivided so render it\n-                } else {\n-                    this.cOutCode = outcode3;\n-                    skipCurveTo(x1, y1, x2, y2, x3, y3);\n-                    return;\n-                }\n-            }\n-\n-            this.cOutCode = outcode3;\n-\n-            if (this.outside) {\n-                this.outside = false;\n-                \/\/ Adjust current index, phase & dash:\n-                skipLen();\n-            }\n-        }\n-        _curveTo(x1, y1, x2, y2, x3, y3);\n-    }\n-\n-    private void _curveTo(final double x1, final double y1,\n-                          final double x2, final double y2,\n-                          final double x3, final double y3)\n-    {\n-        final double[] _curCurvepts = curCurvepts;\n-\n-        \/\/ monotonize curve:\n-        final CurveBasicMonotonizer monotonizer\n-            = rdrCtx.monotonizer.curve(cx0, cy0, x1, y1, x2, y2, x3, y3);\n-\n-        final int nSplits = monotonizer.nbSplits;\n-        final double[] mid = monotonizer.middle;\n-\n-        for (int i = 0, off = 0; i <= nSplits; i++, off += 6) {\n-            \/\/ optimize arraycopy (8 values faster than 6 = type):\n-            System.arraycopy(mid, off, _curCurvepts, 0, 8);\n-\n-            somethingTo(8);\n-        }\n-    }\n-\n-    private void skipCurveTo(final double x1, final double y1,\n-                             final double x2, final double y2,\n-                             final double x3, final double y3)\n-    {\n-        final double[] _curCurvepts = curCurvepts;\n-        _curCurvepts[0] = cx0; _curCurvepts[1] = cy0;\n-        _curCurvepts[2] = x1;  _curCurvepts[3] = y1;\n-        _curCurvepts[4] = x2;  _curCurvepts[5] = y2;\n-        _curCurvepts[6] = x3;  _curCurvepts[7] = y3;\n-\n-        skipSomethingTo(8);\n-\n-        this.cx0 = x3;\n-        this.cy0 = y3;\n-    }\n-\n-    @Override\n-    public void quadTo(final double x1, final double y1,\n-                       final double x2, final double y2)\n-    {\n-        final int outcode0 = this.cOutCode;\n-\n-        if (clipRect != null) {\n-            final int outcode1 = DHelpers.outcode(x1, y1, clipRect);\n-            final int outcode2 = DHelpers.outcode(x2, y2, clipRect);\n-\n-            \/\/ Should clip\n-            final int orCode = (outcode0 | outcode1 | outcode2);\n-            if (orCode != 0) {\n-                final int sideCode = outcode0 & outcode1 & outcode2;\n-\n-                \/\/ basic rejection criteria:\n-                if (sideCode == 0) {\n-                    \/\/ overlap clip:\n-                    if (subdivide) {\n-                        \/\/ avoid reentrance\n-                        subdivide = false;\n-                        \/\/ subdivide curve => call lineTo() with subdivided curves:\n-                        boolean ret = curveSplitter.splitQuad(cx0, cy0, x1, y1,\n-                                                              x2, y2, orCode, this);\n-                        \/\/ reentrance is done:\n-                        subdivide = true;\n-                        if (ret) {\n-                            return;\n-                        }\n-                    }\n-                    \/\/ already subdivided so render it\n-                } else {\n-                    this.cOutCode = outcode2;\n-                    skipQuadTo(x1, y1, x2, y2);\n-                    return;\n-                }\n-            }\n-\n-            this.cOutCode = outcode2;\n-\n-            if (this.outside) {\n-                this.outside = false;\n-                \/\/ Adjust current index, phase & dash:\n-                skipLen();\n-            }\n-        }\n-        _quadTo(x1, y1, x2, y2);\n-    }\n-\n-    private void _quadTo(final double x1, final double y1,\n-                         final double x2, final double y2)\n-    {\n-        final double[] _curCurvepts = curCurvepts;\n-\n-        \/\/ monotonize quad:\n-        final CurveBasicMonotonizer monotonizer\n-            = rdrCtx.monotonizer.quad(cx0, cy0, x1, y1, x2, y2);\n-\n-        final int nSplits = monotonizer.nbSplits;\n-        final double[] mid = monotonizer.middle;\n-\n-        for (int i = 0, off = 0; i <= nSplits; i++, off += 4) {\n-            \/\/ optimize arraycopy (8 values faster than 6 = type):\n-            System.arraycopy(mid, off, _curCurvepts, 0, 8);\n-\n-            somethingTo(6);\n-        }\n-    }\n-\n-    private void skipQuadTo(final double x1, final double y1,\n-                            final double x2, final double y2)\n-    {\n-        final double[] _curCurvepts = curCurvepts;\n-        _curCurvepts[0] = cx0; _curCurvepts[1] = cy0;\n-        _curCurvepts[2] = x1;  _curCurvepts[3] = y1;\n-        _curCurvepts[4] = x2;  _curCurvepts[5] = y2;\n-\n-        skipSomethingTo(6);\n-\n-        this.cx0 = x2;\n-        this.cy0 = y2;\n-    }\n-\n-    @Override\n-    public void closePath() {\n-        if (cx0 != sx0 || cy0 != sy0) {\n-            lineTo(sx0, sy0);\n-        }\n-        if (firstSegidx != 0) {\n-            if (!dashOn || needsMoveTo) {\n-                out.moveTo(sx0, sy0);\n-            }\n-            emitFirstSegments();\n-        }\n-        moveTo(sx0, sy0);\n-    }\n-\n-    @Override\n-    public void pathDone() {\n-        if (firstSegidx != 0) {\n-            out.moveTo(sx0, sy0);\n-            emitFirstSegments();\n-        }\n-        out.pathDone();\n-\n-        \/\/ Dispose this instance:\n-        dispose();\n-    }\n-\n-    @Override\n-    public long getNativeConsumer() {\n-        throw new InternalError(\"DDasher does not use a native consumer\");\n-    }\n-}\n-\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/marlin\/DDasher.java","additions":0,"deletions":1123,"binary":false,"changes":1123,"status":"deleted"},{"patch":"@@ -1,967 +0,0 @@\n-\/*\n- * Copyright (c) 2007, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package sun.java2d.marlin;\n-\n-import java.util.Arrays;\n-import sun.java2d.marlin.stats.Histogram;\n-import sun.java2d.marlin.stats.StatLong;\n-\n-final class DHelpers implements MarlinConst {\n-\n-    private DHelpers() {\n-        throw new Error(\"This is a non instantiable class\");\n-    }\n-\n-    static boolean within(final double x, final double y, final double err) {\n-        final double d = y - x;\n-        return (d <= err && d >= -err);\n-    }\n-\n-    static double evalCubic(final double a, final double b,\n-                            final double c, final double d,\n-                            final double t)\n-    {\n-        return t * (t * (t * a + b) + c) + d;\n-    }\n-\n-    static double evalQuad(final double a, final double b,\n-                           final double c, final double t)\n-    {\n-        return t * (t * a + b) + c;\n-    }\n-\n-    static int quadraticRoots(final double a, final double b, final double c,\n-                              final double[] zeroes, final int off)\n-    {\n-        int ret = off;\n-        if (a != 0.0d) {\n-            final double dis = b*b - 4.0d * a * c;\n-            if (dis > 0.0d) {\n-                final double sqrtDis = Math.sqrt(dis);\n-                \/\/ depending on the sign of b we use a slightly different\n-                \/\/ algorithm than the traditional one to find one of the roots\n-                \/\/ so we can avoid adding numbers of different signs (which\n-                \/\/ might result in loss of precision).\n-                if (b >= 0.0d) {\n-                    zeroes[ret++] = (2.0d * c) \/ (-b - sqrtDis);\n-                    zeroes[ret++] = (-b - sqrtDis) \/ (2.0d * a);\n-                } else {\n-                    zeroes[ret++] = (-b + sqrtDis) \/ (2.0d * a);\n-                    zeroes[ret++] = (2.0d * c) \/ (-b + sqrtDis);\n-                }\n-            } else if (dis == 0.0d) {\n-                zeroes[ret++] = -b \/ (2.0d * a);\n-            }\n-        } else if (b != 0.0d) {\n-            zeroes[ret++] = -c \/ b;\n-        }\n-        return ret - off;\n-    }\n-\n-    \/\/ find the roots of g(t) = d*t^3 + a*t^2 + b*t + c in [A,B)\n-    static int cubicRootsInAB(final double d, double a, double b, double c,\n-                              final double[] pts, final int off,\n-                              final double A, final double B)\n-    {\n-        if (d == 0.0d) {\n-            final int num = quadraticRoots(a, b, c, pts, off);\n-            return filterOutNotInAB(pts, off, num, A, B) - off;\n-        }\n-        \/\/ From Graphics Gems:\n-        \/\/ https:\/\/github.com\/erich666\/GraphicsGems\/blob\/master\/gems\/Roots3And4.c\n-        \/\/ (also from awt.geom.CubicCurve2D. But here we don't need as\n-        \/\/ much accuracy and we don't want to create arrays so we use\n-        \/\/ our own customized version).\n-\n-        \/\/ normal form: x^3 + ax^2 + bx + c = 0\n-\n-        \/*\n-         * TODO: cleanup all that code after reading Roots3And4.c\n-         *\/\n-        a \/= d;\n-        b \/= d;\n-        c \/= d;\n-\n-        \/\/  substitute x = y - A\/3 to eliminate quadratic term:\n-        \/\/     x^3 +Px + Q = 0\n-        \/\/\n-        \/\/ Since we actually need P\/3 and Q\/2 for all of the\n-        \/\/ calculations that follow, we will calculate\n-        \/\/ p = P\/3\n-        \/\/ q = Q\/2\n-        \/\/ instead and use those values for simplicity of the code.\n-        final double sub = (1.0d \/ 3.0d) * a;\n-        final double sq_A = a * a;\n-        final double p = (1.0d \/ 3.0d) * ((-1.0d \/ 3.0d) * sq_A + b);\n-        final double q = (1.0d \/ 2.0d) * ((2.0d \/ 27.0d) * a * sq_A - sub * b + c);\n-\n-        \/\/ use Cardano's formula\n-\n-        final double cb_p = p * p * p;\n-        final double D = q * q + cb_p;\n-\n-        int num;\n-        if (D < 0.0d) {\n-            \/\/ see: http:\/\/en.wikipedia.org\/wiki\/Cubic_function#Trigonometric_.28and_hyperbolic.29_method\n-            final double phi = (1.0d \/ 3.0d) * Math.acos(-q \/ Math.sqrt(-cb_p));\n-            final double t = 2.0d * Math.sqrt(-p);\n-\n-            pts[off    ] = ( t * Math.cos(phi) - sub);\n-            pts[off + 1] = (-t * Math.cos(phi + (Math.PI \/ 3.0d)) - sub);\n-            pts[off + 2] = (-t * Math.cos(phi - (Math.PI \/ 3.0d)) - sub);\n-            num = 3;\n-        } else {\n-            final double sqrt_D = Math.sqrt(D);\n-            final double u =   Math.cbrt(sqrt_D - q);\n-            final double v = - Math.cbrt(sqrt_D + q);\n-\n-            pts[off    ] = (u + v - sub);\n-            num = 1;\n-\n-            if (within(D, 0.0d, 1e-8d)) {\n-                pts[off + 1] = ((-1.0d \/ 2.0d) * (u + v) - sub);\n-                num = 2;\n-            }\n-        }\n-\n-        return filterOutNotInAB(pts, off, num, A, B) - off;\n-    }\n-\n-    \/\/ returns the index 1 past the last valid element remaining after filtering\n-    static int filterOutNotInAB(final double[] nums, final int off, final int len,\n-                                final double a, final double b)\n-    {\n-        int ret = off;\n-        for (int i = off, end = off + len; i < end; i++) {\n-            if (nums[i] >= a && nums[i] < b) {\n-                nums[ret++] = nums[i];\n-            }\n-        }\n-        return ret;\n-    }\n-\n-    static double fastLineLen(final double x0, final double y0,\n-                              final double x1, final double y1)\n-    {\n-        final double dx = x1 - x0;\n-        final double dy = y1 - y0;\n-\n-        \/\/ use manhattan norm:\n-        return Math.abs(dx) + Math.abs(dy);\n-    }\n-\n-    static double linelen(final double x0, final double y0,\n-                          final double x1, final double y1)\n-    {\n-        final double dx = x1 - x0;\n-        final double dy = y1 - y0;\n-        return Math.sqrt(dx * dx + dy * dy);\n-    }\n-\n-    static double fastQuadLen(final double x0, final double y0,\n-                              final double x1, final double y1,\n-                              final double x2, final double y2)\n-    {\n-        final double dx1 = x1 - x0;\n-        final double dx2 = x2 - x1;\n-        final double dy1 = y1 - y0;\n-        final double dy2 = y2 - y1;\n-\n-        \/\/ use manhattan norm:\n-        return Math.abs(dx1) + Math.abs(dx2)\n-             + Math.abs(dy1) + Math.abs(dy2);\n-    }\n-\n-    static double quadlen(final double x0, final double y0,\n-                          final double x1, final double y1,\n-                          final double x2, final double y2)\n-    {\n-        return (linelen(x0, y0, x1, y1)\n-                + linelen(x1, y1, x2, y2)\n-                + linelen(x0, y0, x2, y2)) \/ 2.0d;\n-    }\n-\n-    static double fastCurvelen(final double x0, final double y0,\n-                               final double x1, final double y1,\n-                               final double x2, final double y2,\n-                               final double x3, final double y3)\n-    {\n-        final double dx1 = x1 - x0;\n-        final double dx2 = x2 - x1;\n-        final double dx3 = x3 - x2;\n-        final double dy1 = y1 - y0;\n-        final double dy2 = y2 - y1;\n-        final double dy3 = y3 - y2;\n-\n-        \/\/ use manhattan norm:\n-        return Math.abs(dx1) + Math.abs(dx2) + Math.abs(dx3)\n-             + Math.abs(dy1) + Math.abs(dy2) + Math.abs(dy3);\n-    }\n-\n-    static double curvelen(final double x0, final double y0,\n-                           final double x1, final double y1,\n-                           final double x2, final double y2,\n-                           final double x3, final double y3)\n-    {\n-        return (linelen(x0, y0, x1, y1)\n-              + linelen(x1, y1, x2, y2)\n-              + linelen(x2, y2, x3, y3)\n-              + linelen(x0, y0, x3, y3)) \/ 2.0d;\n-    }\n-\n-    \/\/ finds values of t where the curve in pts should be subdivided in order\n-    \/\/ to get good offset curves a distance of w away from the middle curve.\n-    \/\/ Stores the points in ts, and returns how many of them there were.\n-    static int findSubdivPoints(final DCurve c, final double[] pts,\n-                                final double[] ts, final int type,\n-                                final double w2)\n-    {\n-        final double x12 = pts[2] - pts[0];\n-        final double y12 = pts[3] - pts[1];\n-        \/\/ if the curve is already parallel to either axis we gain nothing\n-        \/\/ from rotating it.\n-        if ((y12 != 0.0d) && (x12 != 0.0d)) {\n-            \/\/ we rotate it so that the first vector in the control polygon is\n-            \/\/ parallel to the x-axis. This will ensure that rotated quarter\n-            \/\/ circles won't be subdivided.\n-            final double hypot = Math.sqrt(x12 * x12 + y12 * y12);\n-            final double cos = x12 \/ hypot;\n-            final double sin = y12 \/ hypot;\n-            final double x1 = cos * pts[0] + sin * pts[1];\n-            final double y1 = cos * pts[1] - sin * pts[0];\n-            final double x2 = cos * pts[2] + sin * pts[3];\n-            final double y2 = cos * pts[3] - sin * pts[2];\n-            final double x3 = cos * pts[4] + sin * pts[5];\n-            final double y3 = cos * pts[5] - sin * pts[4];\n-\n-            switch(type) {\n-            case 8:\n-                final double x4 = cos * pts[6] + sin * pts[7];\n-                final double y4 = cos * pts[7] - sin * pts[6];\n-                c.set(x1, y1, x2, y2, x3, y3, x4, y4);\n-                break;\n-            case 6:\n-                c.set(x1, y1, x2, y2, x3, y3);\n-                break;\n-            default:\n-            }\n-        } else {\n-            c.set(pts, type);\n-        }\n-\n-        int ret = 0;\n-        \/\/ we subdivide at values of t such that the remaining rotated\n-        \/\/ curves are monotonic in x and y.\n-        ret += c.dxRoots(ts, ret);\n-        ret += c.dyRoots(ts, ret);\n-\n-        \/\/ subdivide at inflection points.\n-        if (type == 8) {\n-            \/\/ quadratic curves can't have inflection points\n-            ret += c.infPoints(ts, ret);\n-        }\n-\n-        \/\/ now we must subdivide at points where one of the offset curves will have\n-        \/\/ a cusp. This happens at ts where the radius of curvature is equal to w.\n-        ret += c.rootsOfROCMinusW(ts, ret, w2, 0.0001d);\n-\n-        ret = filterOutNotInAB(ts, 0, ret, 0.0001d, 0.9999d);\n-        isort(ts, ret);\n-        return ret;\n-    }\n-\n-    \/\/ finds values of t where the curve in pts should be subdivided in order\n-    \/\/ to get intersections with the given clip rectangle.\n-    \/\/ Stores the points in ts, and returns how many of them there were.\n-    static int findClipPoints(final DCurve curve, final double[] pts,\n-                              final double[] ts, final int type,\n-                              final int outCodeOR,\n-                              final double[] clipRect)\n-    {\n-        curve.set(pts, type);\n-\n-        \/\/ clip rectangle (ymin, ymax, xmin, xmax)\n-        int ret = 0;\n-\n-        if ((outCodeOR & OUTCODE_LEFT) != 0) {\n-            ret += curve.xPoints(ts, ret, clipRect[2]);\n-        }\n-        if ((outCodeOR & OUTCODE_RIGHT) != 0) {\n-            ret += curve.xPoints(ts, ret, clipRect[3]);\n-        }\n-        if ((outCodeOR & OUTCODE_TOP) != 0) {\n-            ret += curve.yPoints(ts, ret, clipRect[0]);\n-        }\n-        if ((outCodeOR & OUTCODE_BOTTOM) != 0) {\n-            ret += curve.yPoints(ts, ret, clipRect[1]);\n-        }\n-        isort(ts, ret);\n-        return ret;\n-    }\n-\n-    static void subdivide(final double[] src,\n-                          final double[] left, final double[] right,\n-                          final int type)\n-    {\n-        switch(type) {\n-        case 8:\n-            subdivideCubic(src, left, right);\n-            return;\n-        case 6:\n-            subdivideQuad(src, left, right);\n-            return;\n-        default:\n-            throw new InternalError(\"Unsupported curve type\");\n-        }\n-    }\n-\n-    static void isort(final double[] a, final int len) {\n-        for (int i = 1, j; i < len; i++) {\n-            final double ai = a[i];\n-            j = i - 1;\n-            for (; j >= 0 && a[j] > ai; j--) {\n-                a[j + 1] = a[j];\n-            }\n-            a[j + 1] = ai;\n-        }\n-    }\n-\n-    \/\/ Most of these are copied from classes in java.awt.geom because we need\n-    \/\/ both single and double precision variants of these functions, and Line2D,\n-    \/\/ CubicCurve2D, QuadCurve2D don't provide them.\n-    \/**\n-     * Subdivides the cubic curve specified by the coordinates\n-     * stored in the <code>src<\/code> array at indices <code>srcoff<\/code>\n-     * through (<code>srcoff<\/code>&nbsp;+&nbsp;7) and stores the\n-     * resulting two subdivided curves into the two result arrays at the\n-     * corresponding indices.\n-     * Either or both of the <code>left<\/code> and <code>right<\/code>\n-     * arrays may be <code>null<\/code> or a reference to the same array\n-     * as the <code>src<\/code> array.\n-     * Note that the last point in the first subdivided curve is the\n-     * same as the first point in the second subdivided curve. Thus,\n-     * it is possible to pass the same array for <code>left<\/code>\n-     * and <code>right<\/code> and to use offsets, such as <code>rightoff<\/code>\n-     * equals (<code>leftoff<\/code> + 6), in order\n-     * to avoid allocating extra storage for this common point.\n-     * @param src the array holding the coordinates for the source curve\n-     * @param left the array for storing the coordinates for the first\n-     * half of the subdivided curve\n-     * @param right the array for storing the coordinates for the second\n-     * half of the subdivided curve\n-     * @since 1.7\n-     *\/\n-    static void subdivideCubic(final double[] src,\n-                               final double[] left,\n-                               final double[] right)\n-    {\n-        double  x1 = src[0];\n-        double  y1 = src[1];\n-        double cx1 = src[2];\n-        double cy1 = src[3];\n-        double cx2 = src[4];\n-        double cy2 = src[5];\n-        double  x2 = src[6];\n-        double  y2 = src[7];\n-\n-        left[0]  = x1;\n-        left[1]  = y1;\n-\n-        right[6] = x2;\n-        right[7] = y2;\n-\n-        x1 = (x1 + cx1) \/ 2.0d;\n-        y1 = (y1 + cy1) \/ 2.0d;\n-        x2 = (x2 + cx2) \/ 2.0d;\n-        y2 = (y2 + cy2) \/ 2.0d;\n-\n-        double cx = (cx1 + cx2) \/ 2.0d;\n-        double cy = (cy1 + cy2) \/ 2.0d;\n-\n-        cx1 = (x1 + cx) \/ 2.0d;\n-        cy1 = (y1 + cy) \/ 2.0d;\n-        cx2 = (x2 + cx) \/ 2.0d;\n-        cy2 = (y2 + cy) \/ 2.0d;\n-        cx  = (cx1 + cx2) \/ 2.0d;\n-        cy  = (cy1 + cy2) \/ 2.0d;\n-\n-        left[2] = x1;\n-        left[3] = y1;\n-        left[4] = cx1;\n-        left[5] = cy1;\n-        left[6] = cx;\n-        left[7] = cy;\n-\n-        right[0] = cx;\n-        right[1] = cy;\n-        right[2] = cx2;\n-        right[3] = cy2;\n-        right[4] = x2;\n-        right[5] = y2;\n-    }\n-\n-    static void subdivideCubicAt(final double t,\n-                                 final double[] src, final int offS,\n-                                 final double[] pts, final int offL, final int offR)\n-    {\n-        double  x1 = src[offS    ];\n-        double  y1 = src[offS + 1];\n-        double cx1 = src[offS + 2];\n-        double cy1 = src[offS + 3];\n-        double cx2 = src[offS + 4];\n-        double cy2 = src[offS + 5];\n-        double  x2 = src[offS + 6];\n-        double  y2 = src[offS + 7];\n-\n-        pts[offL    ] = x1;\n-        pts[offL + 1] = y1;\n-\n-        pts[offR + 6] = x2;\n-        pts[offR + 7] = y2;\n-\n-        x1 =  x1 + t * (cx1 - x1);\n-        y1 =  y1 + t * (cy1 - y1);\n-        x2 = cx2 + t * (x2 - cx2);\n-        y2 = cy2 + t * (y2 - cy2);\n-\n-        double cx = cx1 + t * (cx2 - cx1);\n-        double cy = cy1 + t * (cy2 - cy1);\n-\n-        cx1 =  x1 + t * (cx - x1);\n-        cy1 =  y1 + t * (cy - y1);\n-        cx2 =  cx + t * (x2 - cx);\n-        cy2 =  cy + t * (y2 - cy);\n-        cx  = cx1 + t * (cx2 - cx1);\n-        cy  = cy1 + t * (cy2 - cy1);\n-\n-        pts[offL + 2] = x1;\n-        pts[offL + 3] = y1;\n-        pts[offL + 4] = cx1;\n-        pts[offL + 5] = cy1;\n-        pts[offL + 6] = cx;\n-        pts[offL + 7] = cy;\n-\n-        pts[offR    ] = cx;\n-        pts[offR + 1] = cy;\n-        pts[offR + 2] = cx2;\n-        pts[offR + 3] = cy2;\n-        pts[offR + 4] = x2;\n-        pts[offR + 5] = y2;\n-    }\n-\n-    static void subdivideQuad(final double[] src,\n-                              final double[] left,\n-                              final double[] right)\n-    {\n-        double x1 = src[0];\n-        double y1 = src[1];\n-        double cx = src[2];\n-        double cy = src[3];\n-        double x2 = src[4];\n-        double y2 = src[5];\n-\n-        left[0]  = x1;\n-        left[1]  = y1;\n-\n-        right[4] = x2;\n-        right[5] = y2;\n-\n-        x1 = (x1 + cx) \/ 2.0d;\n-        y1 = (y1 + cy) \/ 2.0d;\n-        x2 = (x2 + cx) \/ 2.0d;\n-        y2 = (y2 + cy) \/ 2.0d;\n-        cx = (x1 + x2) \/ 2.0d;\n-        cy = (y1 + y2) \/ 2.0d;\n-\n-        left[2] = x1;\n-        left[3] = y1;\n-        left[4] = cx;\n-        left[5] = cy;\n-\n-        right[0] = cx;\n-        right[1] = cy;\n-        right[2] = x2;\n-        right[3] = y2;\n-    }\n-\n-    static void subdivideQuadAt(final double t,\n-                                final double[] src, final int offS,\n-                                final double[] pts, final int offL, final int offR)\n-    {\n-        double x1 = src[offS    ];\n-        double y1 = src[offS + 1];\n-        double cx = src[offS + 2];\n-        double cy = src[offS + 3];\n-        double x2 = src[offS + 4];\n-        double y2 = src[offS + 5];\n-\n-        pts[offL    ] = x1;\n-        pts[offL + 1] = y1;\n-\n-        pts[offR + 4] = x2;\n-        pts[offR + 5] = y2;\n-\n-        x1 = x1 + t * (cx - x1);\n-        y1 = y1 + t * (cy - y1);\n-        x2 = cx + t * (x2 - cx);\n-        y2 = cy + t * (y2 - cy);\n-        cx = x1 + t * (x2 - x1);\n-        cy = y1 + t * (y2 - y1);\n-\n-        pts[offL + 2] = x1;\n-        pts[offL + 3] = y1;\n-        pts[offL + 4] = cx;\n-        pts[offL + 5] = cy;\n-\n-        pts[offR    ] = cx;\n-        pts[offR + 1] = cy;\n-        pts[offR + 2] = x2;\n-        pts[offR + 3] = y2;\n-    }\n-\n-    static void subdivideLineAt(final double t,\n-                                final double[] src, final int offS,\n-                                final double[] pts, final int offL, final int offR)\n-    {\n-        double x1 = src[offS    ];\n-        double y1 = src[offS + 1];\n-        double x2 = src[offS + 2];\n-        double y2 = src[offS + 3];\n-\n-        pts[offL    ] = x1;\n-        pts[offL + 1] = y1;\n-\n-        pts[offR + 2] = x2;\n-        pts[offR + 3] = y2;\n-\n-        x1 = x1 + t * (x2 - x1);\n-        y1 = y1 + t * (y2 - y1);\n-\n-        pts[offL + 2] = x1;\n-        pts[offL + 3] = y1;\n-\n-        pts[offR    ] = x1;\n-        pts[offR + 1] = y1;\n-    }\n-\n-    static void subdivideAt(final double t,\n-                            final double[] src, final int offS,\n-                            final double[] pts, final int offL, final int type)\n-    {\n-        \/\/ if instead of switch (perf + most probable cases first)\n-        if (type == 8) {\n-            subdivideCubicAt(t, src, offS, pts, offL, offL + type);\n-        } else if (type == 4) {\n-            subdivideLineAt(t, src, offS, pts, offL, offL + type);\n-        } else {\n-            subdivideQuadAt(t, src, offS, pts, offL, offL + type);\n-        }\n-    }\n-\n-    \/\/ From sun.java2d.loops.GeneralRenderer:\n-\n-    static int outcode(final double x, final double y,\n-                       final double[] clipRect)\n-    {\n-        int code;\n-        if (y < clipRect[0]) {\n-            code = OUTCODE_TOP;\n-        } else if (y >= clipRect[1]) {\n-            code = OUTCODE_BOTTOM;\n-        } else {\n-            code = 0;\n-        }\n-        if (x < clipRect[2]) {\n-            code |= OUTCODE_LEFT;\n-        } else if (x >= clipRect[3]) {\n-            code |= OUTCODE_RIGHT;\n-        }\n-        return code;\n-    }\n-\n-    \/\/ a stack of polynomial curves where each curve shares endpoints with\n-    \/\/ adjacent ones.\n-    static final class PolyStack {\n-        private static final byte TYPE_LINETO  = (byte) 0;\n-        private static final byte TYPE_QUADTO  = (byte) 1;\n-        private static final byte TYPE_CUBICTO = (byte) 2;\n-\n-        \/\/ curves capacity = edges count (8192) = edges x 2 (coords)\n-        private static final int INITIAL_CURVES_COUNT = INITIAL_EDGES_COUNT << 1;\n-\n-        \/\/ types capacity = edges count (4096)\n-        private static final int INITIAL_TYPES_COUNT = INITIAL_EDGES_COUNT;\n-\n-        double[] curves;\n-        int end;\n-        byte[] curveTypes;\n-        int numCurves;\n-\n-        \/\/ curves ref (dirty)\n-        final DoubleArrayCache.Reference curves_ref;\n-        \/\/ curveTypes ref (dirty)\n-        final ByteArrayCache.Reference curveTypes_ref;\n-\n-        \/\/ used marks (stats only)\n-        int curveTypesUseMark;\n-        int curvesUseMark;\n-\n-        private final StatLong stat_polystack_types;\n-        private final StatLong stat_polystack_curves;\n-        private final Histogram hist_polystack_curves;\n-        private final StatLong stat_array_polystack_curves;\n-        private final StatLong stat_array_polystack_curveTypes;\n-\n-        PolyStack(final DRendererContext rdrCtx) {\n-            this(rdrCtx, null, null, null, null, null);\n-        }\n-\n-        PolyStack(final DRendererContext rdrCtx,\n-                  final StatLong stat_polystack_types,\n-                  final StatLong stat_polystack_curves,\n-                  final Histogram hist_polystack_curves,\n-                  final StatLong stat_array_polystack_curves,\n-                  final StatLong stat_array_polystack_curveTypes)\n-        {\n-            curves_ref = rdrCtx.newDirtyDoubleArrayRef(INITIAL_CURVES_COUNT); \/\/ 32K\n-            curves     = curves_ref.initial;\n-\n-            curveTypes_ref = rdrCtx.newDirtyByteArrayRef(INITIAL_TYPES_COUNT); \/\/ 4K\n-            curveTypes     = curveTypes_ref.initial;\n-            numCurves = 0;\n-            end = 0;\n-\n-            if (DO_STATS) {\n-                curveTypesUseMark = 0;\n-                curvesUseMark = 0;\n-            }\n-            this.stat_polystack_types = stat_polystack_types;\n-            this.stat_polystack_curves = stat_polystack_curves;\n-            this.hist_polystack_curves = hist_polystack_curves;\n-            this.stat_array_polystack_curves = stat_array_polystack_curves;\n-            this.stat_array_polystack_curveTypes = stat_array_polystack_curveTypes;\n-        }\n-\n-        \/**\n-         * Disposes this PolyStack:\n-         * clean up before reusing this instance\n-         *\/\n-        void dispose() {\n-            end = 0;\n-            numCurves = 0;\n-\n-            if (DO_STATS) {\n-                stat_polystack_types.add(curveTypesUseMark);\n-                stat_polystack_curves.add(curvesUseMark);\n-                hist_polystack_curves.add(curvesUseMark);\n-\n-                \/\/ reset marks\n-                curveTypesUseMark = 0;\n-                curvesUseMark = 0;\n-            }\n-\n-            \/\/ Return arrays:\n-            \/\/ curves and curveTypes are kept dirty\n-            curves     = curves_ref.putArray(curves);\n-            curveTypes = curveTypes_ref.putArray(curveTypes);\n-        }\n-\n-        private void ensureSpace(final int n) {\n-            \/\/ use substraction to avoid integer overflow:\n-            if (curves.length - end < n) {\n-                if (DO_STATS) {\n-                    stat_array_polystack_curves.add(end + n);\n-                }\n-                curves = curves_ref.widenArray(curves, end, end + n);\n-            }\n-            if (curveTypes.length <= numCurves) {\n-                if (DO_STATS) {\n-                    stat_array_polystack_curveTypes.add(numCurves + 1);\n-                }\n-                curveTypes = curveTypes_ref.widenArray(curveTypes,\n-                                                       numCurves,\n-                                                       numCurves + 1);\n-            }\n-        }\n-\n-        void pushCubic(double x0, double y0,\n-                       double x1, double y1,\n-                       double x2, double y2)\n-        {\n-            ensureSpace(6);\n-            curveTypes[numCurves++] = TYPE_CUBICTO;\n-            \/\/ we reverse the coordinate order to make popping easier\n-            final double[] _curves = curves;\n-            int e = end;\n-            _curves[e++] = x2;    _curves[e++] = y2;\n-            _curves[e++] = x1;    _curves[e++] = y1;\n-            _curves[e++] = x0;    _curves[e++] = y0;\n-            end = e;\n-        }\n-\n-        void pushQuad(double x0, double y0,\n-                      double x1, double y1)\n-        {\n-            ensureSpace(4);\n-            curveTypes[numCurves++] = TYPE_QUADTO;\n-            final double[] _curves = curves;\n-            int e = end;\n-            _curves[e++] = x1;    _curves[e++] = y1;\n-            _curves[e++] = x0;    _curves[e++] = y0;\n-            end = e;\n-        }\n-\n-        void pushLine(double x, double y) {\n-            ensureSpace(2);\n-            curveTypes[numCurves++] = TYPE_LINETO;\n-            curves[end++] = x;    curves[end++] = y;\n-        }\n-\n-        void pullAll(final DPathConsumer2D io) {\n-            final int nc = numCurves;\n-            if (nc == 0) {\n-                return;\n-            }\n-            if (DO_STATS) {\n-                \/\/ update used marks:\n-                if (numCurves > curveTypesUseMark) {\n-                    curveTypesUseMark = numCurves;\n-                }\n-                if (end > curvesUseMark) {\n-                    curvesUseMark = end;\n-                }\n-            }\n-            final byte[]  _curveTypes = curveTypes;\n-            final double[] _curves = curves;\n-            int e = 0;\n-\n-            for (int i = 0; i < nc; i++) {\n-                switch(_curveTypes[i]) {\n-                case TYPE_LINETO:\n-                    io.lineTo(_curves[e], _curves[e+1]);\n-                    e += 2;\n-                    continue;\n-                case TYPE_CUBICTO:\n-                    io.curveTo(_curves[e],   _curves[e+1],\n-                               _curves[e+2], _curves[e+3],\n-                               _curves[e+4], _curves[e+5]);\n-                    e += 6;\n-                    continue;\n-                case TYPE_QUADTO:\n-                    io.quadTo(_curves[e],   _curves[e+1],\n-                              _curves[e+2], _curves[e+3]);\n-                    e += 4;\n-                    continue;\n-                default:\n-                }\n-            }\n-            numCurves = 0;\n-            end = 0;\n-        }\n-\n-        void popAll(final DPathConsumer2D io) {\n-            int nc = numCurves;\n-            if (nc == 0) {\n-                return;\n-            }\n-            if (DO_STATS) {\n-                \/\/ update used marks:\n-                if (numCurves > curveTypesUseMark) {\n-                    curveTypesUseMark = numCurves;\n-                }\n-                if (end > curvesUseMark) {\n-                    curvesUseMark = end;\n-                }\n-            }\n-            final byte[]  _curveTypes = curveTypes;\n-            final double[] _curves = curves;\n-            int e  = end;\n-\n-            while (nc != 0) {\n-                switch(_curveTypes[--nc]) {\n-                case TYPE_LINETO:\n-                    e -= 2;\n-                    io.lineTo(_curves[e], _curves[e+1]);\n-                    continue;\n-                case TYPE_CUBICTO:\n-                    e -= 6;\n-                    io.curveTo(_curves[e],   _curves[e+1],\n-                               _curves[e+2], _curves[e+3],\n-                               _curves[e+4], _curves[e+5]);\n-                    continue;\n-                case TYPE_QUADTO:\n-                    e -= 4;\n-                    io.quadTo(_curves[e],   _curves[e+1],\n-                              _curves[e+2], _curves[e+3]);\n-                    continue;\n-                default:\n-                }\n-            }\n-            numCurves = 0;\n-            end = 0;\n-        }\n-\n-        @Override\n-        public String toString() {\n-            String ret = \"\";\n-            int nc = numCurves;\n-            int last = end;\n-            int len;\n-            while (nc != 0) {\n-                switch(curveTypes[--nc]) {\n-                case TYPE_LINETO:\n-                    len = 2;\n-                    ret += \"line: \";\n-                    break;\n-                case TYPE_QUADTO:\n-                    len = 4;\n-                    ret += \"quad: \";\n-                    break;\n-                case TYPE_CUBICTO:\n-                    len = 6;\n-                    ret += \"cubic: \";\n-                    break;\n-                default:\n-                    len = 0;\n-                }\n-                last -= len;\n-                ret += Arrays.toString(Arrays.copyOfRange(curves, last, last+len))\n-                                       + \"\\n\";\n-            }\n-            return ret;\n-        }\n-    }\n-\n-    \/\/ a stack of integer indices\n-    static final class IndexStack {\n-\n-        \/\/ integer capacity = edges count \/ 4 ~ 1024\n-        private static final int INITIAL_COUNT = INITIAL_EDGES_COUNT >> 2;\n-\n-        private int end;\n-        private int[] indices;\n-\n-        \/\/ indices ref (dirty)\n-        private final IntArrayCache.Reference indices_ref;\n-\n-        \/\/ used marks (stats only)\n-        private int indicesUseMark;\n-\n-        private final StatLong stat_idxstack_indices;\n-        private final Histogram hist_idxstack_indices;\n-        private final StatLong stat_array_idxstack_indices;\n-\n-        IndexStack(final DRendererContext rdrCtx) {\n-            this(rdrCtx, null, null, null);\n-        }\n-\n-        IndexStack(final DRendererContext rdrCtx,\n-                   final StatLong stat_idxstack_indices,\n-                   final Histogram hist_idxstack_indices,\n-                   final StatLong stat_array_idxstack_indices)\n-        {\n-            indices_ref = rdrCtx.newDirtyIntArrayRef(INITIAL_COUNT); \/\/ 4K\n-            indices     = indices_ref.initial;\n-            end = 0;\n-\n-            if (DO_STATS) {\n-                indicesUseMark = 0;\n-            }\n-            this.stat_idxstack_indices = stat_idxstack_indices;\n-            this.hist_idxstack_indices = hist_idxstack_indices;\n-            this.stat_array_idxstack_indices = stat_array_idxstack_indices;\n-        }\n-\n-        \/**\n-         * Disposes this PolyStack:\n-         * clean up before reusing this instance\n-         *\/\n-        void dispose() {\n-            end = 0;\n-\n-            if (DO_STATS) {\n-                stat_idxstack_indices.add(indicesUseMark);\n-                hist_idxstack_indices.add(indicesUseMark);\n-\n-                \/\/ reset marks\n-                indicesUseMark = 0;\n-            }\n-\n-            \/\/ Return arrays:\n-            \/\/ values is kept dirty\n-            indices = indices_ref.putArray(indices);\n-        }\n-\n-        boolean isEmpty() {\n-            return (end == 0);\n-        }\n-\n-        void reset() {\n-            end = 0;\n-        }\n-\n-        void push(final int v) {\n-            \/\/ remove redundant values (reverse order):\n-            int[] _values = indices;\n-            final int nc = end;\n-            if (nc != 0) {\n-                if (_values[nc - 1] == v) {\n-                    \/\/ remove both duplicated values:\n-                    end--;\n-                    return;\n-                }\n-            }\n-            if (_values.length <= nc) {\n-                if (DO_STATS) {\n-                    stat_array_idxstack_indices.add(nc + 1);\n-                }\n-                indices = _values = indices_ref.widenArray(_values, nc, nc + 1);\n-            }\n-            _values[end++] = v;\n-\n-            if (DO_STATS) {\n-                \/\/ update used marks:\n-                if (end > indicesUseMark) {\n-                    indicesUseMark = end;\n-                }\n-            }\n-        }\n-\n-        void pullAll(final double[] points, final DPathConsumer2D io) {\n-            final int nc = end;\n-            if (nc == 0) {\n-                return;\n-            }\n-            final int[] _values = indices;\n-\n-            for (int i = 0, j; i < nc; i++) {\n-                j = _values[i] << 1;\n-                io.lineTo(points[j], points[j + 1]);\n-            }\n-            end = 0;\n-        }\n-    }\n-}\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/marlin\/DHelpers.java","additions":0,"deletions":967,"binary":false,"changes":967,"status":"deleted"},{"patch":"@@ -68,1 +68,1 @@\n-            PathIterator getNormalizingPathIterator(final DRendererContext rdrCtx,\n+            PathIterator getNormalizingPathIterator(final RendererContext rdrCtx,\n@@ -77,1 +77,1 @@\n-            PathIterator getNormalizingPathIterator(final DRendererContext rdrCtx,\n+            PathIterator getNormalizingPathIterator(final RendererContext rdrCtx,\n@@ -86,1 +86,1 @@\n-            PathIterator getNormalizingPathIterator(final DRendererContext rdrCtx,\n+            PathIterator getNormalizingPathIterator(final RendererContext rdrCtx,\n@@ -94,1 +94,1 @@\n-        abstract PathIterator getNormalizingPathIterator(DRendererContext rdrCtx,\n+        abstract PathIterator getNormalizingPathIterator(RendererContext rdrCtx,\n@@ -132,1 +132,1 @@\n-        final DRendererContext rdrCtx = getRendererContext();\n+        final RendererContext rdrCtx = getRendererContext();\n@@ -154,1 +154,1 @@\n-            \/\/ recycle the DRendererContext instance\n+            \/\/ recycle the RendererContext instance\n@@ -252,1 +252,1 @@\n-        final DRendererContext rdrCtx = getRendererContext();\n+        final RendererContext rdrCtx = getRendererContext();\n@@ -287,1 +287,1 @@\n-            \/\/ recycle the DRendererContext instance\n+            \/\/ recycle the RendererContext instance\n@@ -292,1 +292,1 @@\n-    void strokeTo(final DRendererContext rdrCtx,\n+    void strokeTo(final RendererContext rdrCtx,\n@@ -393,1 +393,1 @@\n-    void strokeTo(final DRendererContext rdrCtx,\n+    void strokeTo(final RendererContext rdrCtx,\n@@ -497,1 +497,1 @@\n-        final DTransformingPathConsumer2D transformerPC2D = rdrCtx.transformerPC2D;\n+        final TransformingPathConsumer2D transformerPC2D = rdrCtx.transformerPC2D;\n@@ -532,1 +532,1 @@\n-        } else if (rdrCtx.doClip && (caps != Stroker.CAP_BUTT)) {\n+        } else if (rdrCtx.doClip && (caps != CAP_BUTT)) {\n@@ -727,1 +727,1 @@\n-    private static void pathTo(final DRendererContext rdrCtx, final PathIterator pi,\n+    private static void pathTo(final RendererContext rdrCtx, final PathIterator pi,\n@@ -913,1 +913,1 @@\n-        DRenderer r = null;\n+        Renderer r = null;\n@@ -915,1 +915,1 @@\n-        final DRendererContext rdrCtx = getRendererContext();\n+        final RendererContext rdrCtx = getRendererContext();\n@@ -922,2 +922,2 @@\n-                final double rdrOffX = DRenderer.RDR_OFFSET_X;\n-                final double rdrOffY = DRenderer.RDR_OFFSET_Y;\n+                final double rdrOffX = Renderer.RDR_OFFSET_X;\n+                final double rdrOffY = Renderer.RDR_OFFSET_Y;\n@@ -1036,1 +1036,1 @@\n-        DRenderer r = null;\n+        Renderer r = null;\n@@ -1038,1 +1038,1 @@\n-        final DRendererContext rdrCtx = getRendererContext();\n+        final RendererContext rdrCtx = getRendererContext();\n@@ -1107,2 +1107,2 @@\n-    \/\/ --- DRendererContext handling ---\n-    \/\/ use ThreadLocal or ConcurrentLinkedQueue to get one DRendererContext\n+    \/\/ --- RendererContext handling ---\n+    \/\/ use ThreadLocal or ConcurrentLinkedQueue to get one RendererContext\n@@ -1114,2 +1114,2 @@\n-    \/\/ Per-thread DRendererContext\n-    private static final ReentrantContextProvider<DRendererContext> RDR_CTX_PROVIDER;\n+    \/\/ Per-thread RendererContext\n+    private static final ReentrantContextProvider<RendererContext> RDR_CTX_PROVIDER;\n@@ -1139,1 +1139,1 @@\n-            RDR_CTX_PROVIDER = new ReentrantContextProviderTL<DRendererContext>(REF_TYPE)\n+            RDR_CTX_PROVIDER = new ReentrantContextProviderTL<RendererContext>(REF_TYPE)\n@@ -1142,2 +1142,2 @@\n-                    protected DRendererContext newContext() {\n-                        return DRendererContext.createContext();\n+                    protected RendererContext newContext() {\n+                        return RendererContext.createContext();\n@@ -1147,1 +1147,1 @@\n-            RDR_CTX_PROVIDER = new ReentrantContextProviderCLQ<DRendererContext>(REF_TYPE)\n+            RDR_CTX_PROVIDER = new ReentrantContextProviderCLQ<RendererContext>(REF_TYPE)\n@@ -1150,2 +1150,2 @@\n-                    protected DRendererContext newContext() {\n-                        return DRendererContext.createContext();\n+                    protected RendererContext newContext() {\n+                        return RendererContext.createContext();\n@@ -1270,3 +1270,3 @@\n-        logInfo(\"CUB_DEC_BND  = \" + DRenderer.CUB_DEC_BND);\n-        logInfo(\"CUB_INC_BND  = \" + DRenderer.CUB_INC_BND);\n-        logInfo(\"QUAD_DEC_BND = \" + DRenderer.QUAD_DEC_BND);\n+        logInfo(\"CUB_DEC_BND  = \" + Renderer.CUB_DEC_BND);\n+        logInfo(\"CUB_INC_BND  = \" + Renderer.CUB_INC_BND);\n+        logInfo(\"QUAD_DEC_BND = \" + Renderer.QUAD_DEC_BND);\n@@ -1277,1 +1277,1 @@\n-                + DRenderer.INITIAL_CROSSING_COUNT);\n+                + Renderer.INITIAL_CROSSING_COUNT);\n@@ -1284,2 +1284,2 @@\n-     * Get the DRendererContext instance dedicated to the current thread\n-     * @return DRendererContext instance\n+     * Get the RendererContext instance dedicated to the current thread\n+     * @return RendererContext instance\n@@ -1288,2 +1288,2 @@\n-    static DRendererContext getRendererContext() {\n-        final DRendererContext rdrCtx = RDR_CTX_PROVIDER.acquire();\n+    static RendererContext getRendererContext() {\n+        final RendererContext rdrCtx = RDR_CTX_PROVIDER.acquire();\n@@ -1297,2 +1297,2 @@\n-     * Reset and return the given DRendererContext instance for reuse\n-     * @param rdrCtx DRendererContext instance\n+     * Reset and return the given RendererContext instance for reuse\n+     * @param rdrCtx RendererContext instance\n@@ -1300,1 +1300,1 @@\n-    static void returnRendererContext(final DRendererContext rdrCtx) {\n+    static void returnRendererContext(final RendererContext rdrCtx) {\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/marlin\/DMarlinRenderingEngine.java","additions":40,"deletions":40,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -1,136 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package sun.java2d.marlin;\n-\n-final class DPathSimplifier implements DPathConsumer2D {\n-\n-    \/\/ distance threshold in pixels (device)\n-    private static final double PIX_THRESHOLD = MarlinProperties.getPathSimplifierPixelTolerance();\n-\n-    private static final double SQUARE_TOLERANCE = PIX_THRESHOLD * PIX_THRESHOLD;\n-\n-    \/\/ members:\n-    private DPathConsumer2D delegate;\n-    private double cx, cy;\n-\n-    DPathSimplifier() {\n-    }\n-\n-    DPathSimplifier init(final DPathConsumer2D delegate) {\n-        this.delegate = delegate;\n-        return this; \/\/ fluent API\n-    }\n-\n-    @Override\n-    public void pathDone() {\n-        delegate.pathDone();\n-    }\n-\n-    @Override\n-    public void closePath() {\n-        delegate.closePath();\n-    }\n-\n-    @Override\n-    public long getNativeConsumer() {\n-        return 0;\n-    }\n-\n-    @Override\n-    public void quadTo(final double x1, final double y1,\n-                       final double xe, final double ye)\n-    {\n-        \/\/ Test if curve is too small:\n-        double dx = (xe - cx);\n-        double dy = (ye - cy);\n-\n-        if ((dx * dx + dy * dy) <= SQUARE_TOLERANCE) {\n-            \/\/ check control points P1:\n-            dx = (x1 - cx);\n-            dy = (y1 - cy);\n-\n-            if ((dx * dx + dy * dy) <= SQUARE_TOLERANCE) {\n-                return;\n-            }\n-        }\n-        delegate.quadTo(x1, y1, xe, ye);\n-        \/\/ final end point:\n-        cx = xe;\n-        cy = ye;\n-    }\n-\n-    @Override\n-    public void curveTo(final double x1, final double y1,\n-                        final double x2, final double y2,\n-                        final double xe, final double ye)\n-    {\n-        \/\/ Test if curve is too small:\n-        double dx = (xe - cx);\n-        double dy = (ye - cy);\n-\n-        if ((dx * dx + dy * dy) <= SQUARE_TOLERANCE) {\n-            \/\/ check control points P1:\n-            dx = (x1 - cx);\n-            dy = (y1 - cy);\n-\n-            if ((dx * dx + dy * dy) <= SQUARE_TOLERANCE) {\n-                \/\/ check control points P2:\n-                dx = (x2 - cx);\n-                dy = (y2 - cy);\n-\n-                if ((dx * dx + dy * dy) <= SQUARE_TOLERANCE) {\n-                    return;\n-                }\n-            }\n-        }\n-        delegate.curveTo(x1, y1, x2, y2, xe, ye);\n-        \/\/ final end point:\n-        cx = xe;\n-        cy = ye;\n-    }\n-\n-    @Override\n-    public void moveTo(final double xe, final double ye) {\n-        delegate.moveTo(xe, ye);\n-        \/\/ starting point:\n-        cx = xe;\n-        cy = ye;\n-    }\n-\n-    @Override\n-    public void lineTo(final double xe, final double ye) {\n-        \/\/ Test if segment is too small:\n-        double dx = (xe - cx);\n-        double dy = (ye - cy);\n-\n-        if ((dx * dx + dy * dy) <= SQUARE_TOLERANCE) {\n-            return;\n-        }\n-        delegate.lineTo(xe, ye);\n-        \/\/ final end point:\n-        cx = xe;\n-        cy = ye;\n-    }\n-}\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/marlin\/DPathSimplifier.java","additions":0,"deletions":136,"binary":false,"changes":136,"status":"deleted"},{"patch":"@@ -1,1534 +0,0 @@\n-\/*\n- * Copyright (c) 2007, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package sun.java2d.marlin;\n-\n-import static sun.java2d.marlin.OffHeapArray.SIZE_INT;\n-import jdk.internal.misc.Unsafe;\n-\n-final class DRenderer implements DPathConsumer2D, MarlinRenderer {\n-\n-    static final boolean DISABLE_RENDER = false;\n-\n-    static final boolean ENABLE_BLOCK_FLAGS = MarlinProperties.isUseTileFlags();\n-    static final boolean ENABLE_BLOCK_FLAGS_HEURISTICS = MarlinProperties.isUseTileFlagsWithHeuristics();\n-\n-    private static final int ALL_BUT_LSB = 0xFFFFFFFE;\n-    private static final int ERR_STEP_MAX = 0x7FFFFFFF; \/\/ = 2^31 - 1\n-\n-    private static final double POWER_2_TO_32 = 0x1.0p32d;\n-\n-    \/\/ use double to make tosubpix methods faster (no int to double conversion)\n-    static final double SUBPIXEL_SCALE_X = SUBPIXEL_POSITIONS_X;\n-    static final double SUBPIXEL_SCALE_Y = SUBPIXEL_POSITIONS_Y;\n-    static final int SUBPIXEL_MASK_X = SUBPIXEL_POSITIONS_X - 1;\n-    static final int SUBPIXEL_MASK_Y = SUBPIXEL_POSITIONS_Y - 1;\n-\n-    static final double RDR_OFFSET_X = 0.5d \/ SUBPIXEL_SCALE_X;\n-    static final double RDR_OFFSET_Y = 0.5d \/ SUBPIXEL_SCALE_Y;\n-\n-    \/\/ number of subpixels corresponding to a tile line\n-    private static final int SUBPIXEL_TILE\n-        = TILE_H << SUBPIXEL_LG_POSITIONS_Y;\n-\n-    \/\/ 2176 pixels (height) x 8 subpixels = 68K\n-    static final int INITIAL_BUCKET_ARRAY\n-        = INITIAL_PIXEL_HEIGHT * SUBPIXEL_POSITIONS_Y;\n-\n-    \/\/ crossing capacity = edges count \/ 4 ~ 1024\n-    static final int INITIAL_CROSSING_COUNT = INITIAL_EDGES_COUNT >> 2;\n-\n-    \/\/ common to all types of input path segments.\n-    \/\/ OFFSET as bytes\n-    \/\/ only integer values:\n-    public static final long OFF_CURX_OR  = 0;\n-    public static final long OFF_ERROR    = OFF_CURX_OR  + SIZE_INT;\n-    public static final long OFF_BUMP_X   = OFF_ERROR    + SIZE_INT;\n-    public static final long OFF_BUMP_ERR = OFF_BUMP_X   + SIZE_INT;\n-    public static final long OFF_NEXT     = OFF_BUMP_ERR + SIZE_INT;\n-    public static final long OFF_YMAX     = OFF_NEXT     + SIZE_INT;\n-\n-    \/\/ size of one edge in bytes\n-    public static final int SIZEOF_EDGE_BYTES = (int)(OFF_YMAX + SIZE_INT);\n-\n-    \/\/ curve break into lines\n-    \/\/ cubic error in subpixels to decrement step\n-    private static final double CUB_DEC_ERR_SUBPIX\n-        = MarlinProperties.getCubicDecD2() * (SUBPIXEL_POSITIONS_X \/ 8.0d); \/\/ 1.0 \/ 8th pixel\n-    \/\/ cubic error in subpixels to increment step\n-    private static final double CUB_INC_ERR_SUBPIX\n-        = MarlinProperties.getCubicIncD1() * (SUBPIXEL_POSITIONS_X \/ 8.0d); \/\/ 0.4 \/ 8th pixel\n-    \/\/ scale factor for Y-axis contribution to quad \/ cubic errors:\n-    public static final double SCALE_DY = ((double) SUBPIXEL_POSITIONS_X) \/ SUBPIXEL_POSITIONS_Y;\n-\n-    \/\/ TestNonAARasterization (JDK-8170879): cubics\n-    \/\/ bad paths (59294\/100000 == 59,29%, 94335 bad pixels (avg = 1,59), 3966 warnings (avg = 0,07)\n-\/\/ 2018\n-    \/\/ 1.0 \/ 0.2: bad paths (67194\/100000 == 67,19%, 117394 bad pixels (avg = 1,75 - max =  9), 4042 warnings (avg = 0,06)\n-\n-    \/\/ cubic bind length to decrement step\n-    public static final double CUB_DEC_BND\n-        = 8.0d * CUB_DEC_ERR_SUBPIX;\n-    \/\/ cubic bind length to increment step\n-    public static final double CUB_INC_BND\n-        = 8.0d * CUB_INC_ERR_SUBPIX;\n-\n-    \/\/ cubic countlg\n-    public static final int CUB_COUNT_LG = 2;\n-    \/\/ cubic count = 2^countlg\n-    private static final int CUB_COUNT = 1 << CUB_COUNT_LG;\n-    \/\/ cubic count^2 = 4^countlg\n-    private static final int CUB_COUNT_2 = 1 << (2 * CUB_COUNT_LG);\n-    \/\/ cubic count^3 = 8^countlg\n-    private static final int CUB_COUNT_3 = 1 << (3 * CUB_COUNT_LG);\n-    \/\/ cubic dt = 1 \/ count\n-    private static final double CUB_INV_COUNT = 1.0d \/ CUB_COUNT;\n-    \/\/ cubic dt^2 = 1 \/ count^2 = 1 \/ 4^countlg\n-    private static final double CUB_INV_COUNT_2 = 1.0d \/ CUB_COUNT_2;\n-    \/\/ cubic dt^3 = 1 \/ count^3 = 1 \/ 8^countlg\n-    private static final double CUB_INV_COUNT_3 = 1.0d \/ CUB_COUNT_3;\n-\n-    \/\/ quad break into lines\n-    \/\/ quadratic error in subpixels\n-    private static final double QUAD_DEC_ERR_SUBPIX\n-        = MarlinProperties.getQuadDecD2() * (SUBPIXEL_POSITIONS_X \/ 8.0d); \/\/ 0.5 \/ 8th pixel\n-\n-    \/\/ TestNonAARasterization (JDK-8170879): quads\n-    \/\/ bad paths (62916\/100000 == 62,92%, 103818 bad pixels (avg = 1,65), 6514 warnings (avg = 0,10)\n-\/\/ 2018\n-    \/\/ 0.50px  = bad paths (62915\/100000 == 62,92%, 103810 bad pixels (avg = 1,65), 6512 warnings (avg = 0,10)\n-\n-    \/\/ quadratic bind length to decrement step\n-    public static final double QUAD_DEC_BND\n-        = 8.0d * QUAD_DEC_ERR_SUBPIX;\n-\n-\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\/\/  SCAN LINE\n-\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-    \/\/ crossings ie subpixel edge x coordinates\n-    private int[] crossings;\n-    \/\/ auxiliary storage for crossings (merge sort)\n-    private int[] aux_crossings;\n-\n-    \/\/ indices into the segment pointer lists. They indicate the \"active\"\n-    \/\/ sublist in the segment lists (the portion of the list that contains\n-    \/\/ all the segments that cross the next scan line).\n-    private int edgeCount;\n-    private int[] edgePtrs;\n-    \/\/ auxiliary storage for edge pointers (merge sort)\n-    private int[] aux_edgePtrs;\n-\n-    \/\/ max used for both edgePtrs and crossings (stats only)\n-    private int activeEdgeMaxUsed;\n-\n-    \/\/ crossings ref (dirty)\n-    private final IntArrayCache.Reference crossings_ref;\n-    \/\/ edgePtrs ref (dirty)\n-    private final IntArrayCache.Reference edgePtrs_ref;\n-    \/\/ merge sort initial arrays (large enough to satisfy most usages) (1024)\n-    \/\/ aux_crossings ref (dirty)\n-    private final IntArrayCache.Reference aux_crossings_ref;\n-    \/\/ aux_edgePtrs ref (dirty)\n-    private final IntArrayCache.Reference aux_edgePtrs_ref;\n-\n-\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\/\/  EDGE LIST\n-\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-    private int edgeMinY = Integer.MAX_VALUE;\n-    private int edgeMaxY = Integer.MIN_VALUE;\n-    private double edgeMinX = Double.POSITIVE_INFINITY;\n-    private double edgeMaxX = Double.NEGATIVE_INFINITY;\n-\n-    \/\/ edges [ints] stored in off-heap memory\n-    private final OffHeapArray edges;\n-\n-    private int[] edgeBuckets;\n-    private int[] edgeBucketCounts; \/\/ 2*newedges + (1 if pruning needed)\n-    \/\/ used range for edgeBuckets \/ edgeBucketCounts\n-    private int buckets_minY;\n-    private int buckets_maxY;\n-\n-    \/\/ edgeBuckets ref (clean)\n-    private final IntArrayCache.Reference edgeBuckets_ref;\n-    \/\/ edgeBucketCounts ref (clean)\n-    private final IntArrayCache.Reference edgeBucketCounts_ref;\n-\n-    \/\/ Flattens using adaptive forward differencing. This only carries out\n-    \/\/ one iteration of the AFD loop. All it does is update AFD variables (i.e.\n-    \/\/ X0, Y0, D*[X|Y], COUNT; not variables used for computing scanline crossings).\n-    private void quadBreakIntoLinesAndAdd(double x0, double y0,\n-                                          final DCurve c,\n-                                          final double x2, final double y2)\n-    {\n-        int count = 1; \/\/ dt = 1 \/ count\n-\n-        \/\/ maximum(ddX|Y) = norm(dbx, dby) * dt^2 (= 1)\n-        double maxDD = Math.abs(c.dbx) + Math.abs(c.dby) * SCALE_DY;\n-\n-        final double _DEC_BND = QUAD_DEC_BND;\n-\n-        while (maxDD >= _DEC_BND) {\n-            \/\/ divide step by half:\n-            maxDD \/= 4.0d; \/\/ error divided by 2^2 = 4\n-\n-            count <<= 1;\n-            if (DO_STATS) {\n-                rdrCtx.stats.stat_rdr_quadBreak_dec.add(count);\n-            }\n-        }\n-\n-        final int nL = count; \/\/ line count\n-\n-        if (count > 1) {\n-            final double icount = 1.0d \/ count; \/\/ dt\n-            final double icount2 = icount * icount; \/\/ dt^2\n-\n-            final double ddx = c.dbx * icount2;\n-            final double ddy = c.dby * icount2;\n-            double dx = c.bx * icount2 + c.cx * icount;\n-            double dy = c.by * icount2 + c.cy * icount;\n-\n-            \/\/ we use x0, y0 to walk the line\n-            for (double x1 = x0, y1 = y0; --count > 0; dx += ddx, dy += ddy) {\n-                x1 += dx;\n-                y1 += dy;\n-\n-                addLine(x0, y0, x1, y1);\n-                x0 = x1;\n-                y0 = y1;\n-            }\n-        }\n-        addLine(x0, y0, x2, y2);\n-\n-        if (DO_STATS) {\n-            rdrCtx.stats.stat_rdr_quadBreak.add(nL);\n-        }\n-    }\n-\n-    \/\/ x0, y0 and x3,y3 are the endpoints of the curve. We could compute these\n-    \/\/ using c.xat(0),c.yat(0) and c.xat(1),c.yat(1), but this might introduce\n-    \/\/ numerical errors, and our callers already have the exact values.\n-    \/\/ Another alternative would be to pass all the control points, and call\n-    \/\/ c.set here, but then too many numbers are passed around.\n-    private void curveBreakIntoLinesAndAdd(double x0, double y0,\n-                                           final DCurve c,\n-                                           final double x3, final double y3)\n-    {\n-        int count            = CUB_COUNT;\n-        final double icount  = CUB_INV_COUNT;   \/\/ dt\n-        final double icount2 = CUB_INV_COUNT_2; \/\/ dt^2\n-        final double icount3 = CUB_INV_COUNT_3; \/\/ dt^3\n-\n-        \/\/ the dx and dy refer to forward differencing variables, not the last\n-        \/\/ coefficients of the \"points\" polynomial\n-        double dddx, dddy, ddx, ddy, dx, dy;\n-        dddx = 2.0d * c.dax * icount3;\n-        dddy = 2.0d * c.day * icount3;\n-        ddx = dddx + c.dbx * icount2;\n-        ddy = dddy + c.dby * icount2;\n-        dx = c.ax * icount3 + c.bx * icount2 + c.cx * icount;\n-        dy = c.ay * icount3 + c.by * icount2 + c.cy * icount;\n-\n-        int nL = 0; \/\/ line count\n-\n-        final double _DEC_BND = CUB_DEC_BND;\n-        final double _INC_BND = CUB_INC_BND;\n-        final double _SCALE_DY = SCALE_DY;\n-\n-        \/\/ we use x0, y0 to walk the line\n-        for (double x1 = x0, y1 = y0; count > 0; ) {\n-            \/\/ inc \/ dec => ratio ~ 5 to minimize upscale \/ downscale but minimize edges\n-\n-            \/\/ double step:\n-            \/\/ can only do this on even \"count\" values, because we must divide count by 2\n-            while ((count % 2 == 0)\n-                    && ((Math.abs(ddx) + Math.abs(ddy) * _SCALE_DY) <= _INC_BND)) {\n-                dx = 2.0d * dx + ddx;\n-                dy = 2.0d * dy + ddy;\n-                ddx = 4.0d * (ddx + dddx);\n-                ddy = 4.0d * (ddy + dddy);\n-                dddx *= 8.0d;\n-                dddy *= 8.0d;\n-\n-                count >>= 1;\n-                if (DO_STATS) {\n-                    rdrCtx.stats.stat_rdr_curveBreak_inc.add(count);\n-                }\n-            }\n-\n-            \/\/ divide step by half:\n-            while ((Math.abs(ddx) + Math.abs(ddy) * _SCALE_DY) >= _DEC_BND) {\n-                dddx \/= 8.0d;\n-                dddy \/= 8.0d;\n-                ddx = ddx \/ 4.0d - dddx;\n-                ddy = ddy \/ 4.0d - dddy;\n-                dx = (dx - ddx) \/ 2.0d;\n-                dy = (dy - ddy) \/ 2.0d;\n-\n-                count <<= 1;\n-                if (DO_STATS) {\n-                    rdrCtx.stats.stat_rdr_curveBreak_dec.add(count);\n-                }\n-            }\n-            if (--count == 0) {\n-                break;\n-            }\n-\n-            x1 += dx;\n-            y1 += dy;\n-            dx += ddx;\n-            dy += ddy;\n-            ddx += dddx;\n-            ddy += dddy;\n-\n-            addLine(x0, y0, x1, y1);\n-            x0 = x1;\n-            y0 = y1;\n-        }\n-        addLine(x0, y0, x3, y3);\n-\n-        if (DO_STATS) {\n-            rdrCtx.stats.stat_rdr_curveBreak.add(nL + 1);\n-        }\n-    }\n-\n-    private void addLine(double x1, double y1, double x2, double y2) {\n-        if (DO_MONITORS) {\n-            rdrCtx.stats.mon_rdr_addLine.start();\n-        }\n-        if (DO_STATS) {\n-            rdrCtx.stats.stat_rdr_addLine.add(1);\n-        }\n-        int or = 1; \/\/ orientation of the line. 1 if y increases, 0 otherwise.\n-        if (y2 < y1) {\n-            or = 0;\n-            double tmp = y2;\n-            y2 = y1;\n-            y1 = tmp;\n-            tmp = x2;\n-            x2 = x1;\n-            x1 = tmp;\n-        }\n-\n-        \/\/ convert subpixel coordinates [double] into pixel positions [int]\n-\n-        \/\/ The index of the pixel that holds the next HPC is at ceil(trueY - 0.5)\n-        \/\/ Since y1 and y2 are biased by -0.5 in tosubpixy(), this is simply\n-        \/\/ ceil(y1) or ceil(y2)\n-        \/\/ upper integer (inclusive)\n-        final int firstCrossing = FloatMath.max(FloatMath.ceil_int(y1), boundsMinY);\n-\n-        \/\/ note: use boundsMaxY (last Y exclusive) to compute correct coverage\n-        \/\/ upper integer (exclusive)\n-        final int lastCrossing  = FloatMath.min(FloatMath.ceil_int(y2), boundsMaxY);\n-\n-        \/* skip horizontal lines in pixel space and clip edges\n-           out of y range [boundsMinY; boundsMaxY] *\/\n-        if (firstCrossing >= lastCrossing) {\n-            if (DO_MONITORS) {\n-                rdrCtx.stats.mon_rdr_addLine.stop();\n-            }\n-            if (DO_STATS) {\n-                rdrCtx.stats.stat_rdr_addLine_skip.add(1);\n-            }\n-            return;\n-        }\n-\n-        \/\/ edge min\/max X\/Y are in subpixel space (half-open interval):\n-        \/\/ note: Use integer crossings to ensure consistent range within\n-        \/\/ edgeBuckets \/ edgeBucketCounts arrays in case of NaN values (int = 0)\n-        if (firstCrossing < edgeMinY) {\n-            edgeMinY = firstCrossing;\n-        }\n-        if (lastCrossing > edgeMaxY) {\n-            edgeMaxY = lastCrossing;\n-        }\n-\n-        final double slope = (x1 - x2) \/ (y1 - y2);\n-\n-        if (slope >= 0.0d) { \/\/ <==> x1 < x2\n-            if (x1 < edgeMinX) {\n-                edgeMinX = x1;\n-            }\n-            if (x2 > edgeMaxX) {\n-                edgeMaxX = x2;\n-            }\n-        } else {\n-            if (x2 < edgeMinX) {\n-                edgeMinX = x2;\n-            }\n-            if (x1 > edgeMaxX) {\n-                edgeMaxX = x1;\n-            }\n-        }\n-\n-        \/\/ local variables for performance:\n-        final int _SIZEOF_EDGE_BYTES = SIZEOF_EDGE_BYTES;\n-\n-        final OffHeapArray _edges = edges;\n-\n-        \/\/ get free pointer (ie length in bytes)\n-        final int edgePtr = _edges.used;\n-\n-        \/\/ use substraction to avoid integer overflow:\n-        if (_edges.length - edgePtr < _SIZEOF_EDGE_BYTES) {\n-            \/\/ suppose _edges.length > _SIZEOF_EDGE_BYTES\n-            \/\/ so doubling size is enough to add needed bytes\n-            \/\/ note: throw IOOB if neededSize > 2Gb:\n-            final long edgeNewSize = ArrayCacheConst.getNewLargeSize(\n-                                        _edges.length,\n-                                        edgePtr + _SIZEOF_EDGE_BYTES);\n-\n-            if (DO_STATS) {\n-                rdrCtx.stats.stat_rdr_edges_resizes.add(edgeNewSize);\n-            }\n-            _edges.resize(edgeNewSize);\n-        }\n-\n-\n-        final Unsafe _unsafe = OffHeapArray.UNSAFE;\n-        final long SIZE_INT = 4L;\n-        long addr   = _edges.address + edgePtr;\n-\n-        \/\/ The x value must be bumped up to its position at the next HPC we will evaluate.\n-        \/\/ \"firstcrossing\" is the (sub)pixel number where the next crossing occurs\n-        \/\/ thus, the actual coordinate of the next HPC is \"firstcrossing + 0.5\"\n-        \/\/ so the Y distance we cover is \"firstcrossing + 0.5 - trueY\".\n-        \/\/ Note that since y1 (and y2) are already biased by -0.5 in tosubpixy(), we have\n-        \/\/ y1 = trueY - 0.5\n-        \/\/ trueY = y1 + 0.5\n-        \/\/ firstcrossing + 0.5 - trueY = firstcrossing + 0.5 - (y1 + 0.5)\n-        \/\/                             = firstcrossing - y1\n-        \/\/ The x coordinate at that HPC is then:\n-        \/\/ x1_intercept = x1 + (firstcrossing - y1) * slope\n-        \/\/ The next VPC is then given by:\n-        \/\/ VPC index = ceil(x1_intercept - 0.5), or alternately\n-        \/\/ VPC index = floor(x1_intercept - 0.5 + 1 - epsilon)\n-        \/\/ epsilon is hard to pin down in floating point, but easy in fixed point, so if\n-        \/\/ we convert to fixed point then these operations get easier:\n-        \/\/ long x1_fixed = x1_intercept * 2^32;  (fixed point 32.32 format)\n-        \/\/ curx = next VPC = fixed_floor(x1_fixed - 2^31 + 2^32 - 1)\n-        \/\/                 = fixed_floor(x1_fixed + 2^31 - 1)\n-        \/\/                 = fixed_floor(x1_fixed + 0x7FFFFFFF)\n-        \/\/ and error       = fixed_fract(x1_fixed + 0x7FFFFFFF)\n-        final double x1_intercept = x1 + (firstCrossing - y1) * slope;\n-\n-        \/\/ inlined scalb(x1_intercept, 32):\n-        final long x1_fixed_biased = ((long) (POWER_2_TO_32 * x1_intercept))\n-                                     + 0x7FFFFFFFL;\n-        \/\/ curx:\n-        \/\/ last bit corresponds to the orientation\n-        _unsafe.putInt(addr, (((int) (x1_fixed_biased >> 31L)) & ALL_BUT_LSB) | or);\n-        addr += SIZE_INT;\n-        _unsafe.putInt(addr,  ((int)  x1_fixed_biased) >>> 1);\n-        addr += SIZE_INT;\n-\n-        \/\/ inlined scalb(slope, 32):\n-        final long slope_fixed = (long) (POWER_2_TO_32 * slope);\n-\n-        \/\/ last bit set to 0 to keep orientation:\n-        _unsafe.putInt(addr, (((int) (slope_fixed >> 31L)) & ALL_BUT_LSB));\n-        addr += SIZE_INT;\n-        _unsafe.putInt(addr,  ((int)  slope_fixed) >>> 1);\n-        addr += SIZE_INT;\n-\n-        final int[] _edgeBuckets      = edgeBuckets;\n-        final int[] _edgeBucketCounts = edgeBucketCounts;\n-\n-        final int _boundsMinY = boundsMinY;\n-\n-        \/\/ each bucket is a linked list. this method adds ptr to the\n-        \/\/ start of the \"bucket\"th linked list.\n-        final int bucketIdx = firstCrossing - _boundsMinY;\n-\n-        \/\/ pointer from bucket\n-        _unsafe.putInt(addr, _edgeBuckets[bucketIdx]);\n-        addr += SIZE_INT;\n-        \/\/ y max (exclusive)\n-        _unsafe.putInt(addr,  lastCrossing);\n-\n-        \/\/ Update buckets:\n-        \/\/ directly the edge struct \"pointer\"\n-        _edgeBuckets[bucketIdx]       = edgePtr;\n-        _edgeBucketCounts[bucketIdx] += 2; \/\/ 1 << 1\n-        \/\/ last bit means edge end\n-        _edgeBucketCounts[lastCrossing - _boundsMinY] |= 0x1;\n-\n-        \/\/ update free pointer (ie length in bytes)\n-        _edges.used += _SIZEOF_EDGE_BYTES;\n-\n-        if (DO_MONITORS) {\n-            rdrCtx.stats.mon_rdr_addLine.stop();\n-        }\n-    }\n-\n-\/\/ END EDGE LIST\n-\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\n-    \/\/ Cache to store RLE-encoded coverage mask of the current primitive\n-    final MarlinCache cache;\n-\n-    \/\/ Bounds of the drawing region, at subpixel precision.\n-    private int boundsMinX, boundsMinY, boundsMaxX, boundsMaxY;\n-\n-    \/\/ Current winding rule\n-    private int windingRule;\n-\n-    \/\/ Current drawing position, i.e., final point of last segment\n-    private double x0, y0;\n-\n-    \/\/ Position of most recent 'moveTo' command\n-    private double sx0, sy0;\n-\n-    \/\/ per-thread renderer context\n-    final DRendererContext rdrCtx;\n-    \/\/ dirty curve\n-    private final DCurve curve;\n-\n-    \/\/ clean alpha array (zero filled)\n-    private int[] alphaLine;\n-\n-    \/\/ alphaLine ref (clean)\n-    private final IntArrayCache.Reference alphaLine_ref;\n-\n-    private boolean enableBlkFlags = false;\n-    private boolean prevUseBlkFlags = false;\n-\n-    \/* block flags (0|1) *\/\n-    private int[] blkFlags;\n-\n-    \/\/ blkFlags ref (clean)\n-    private final IntArrayCache.Reference blkFlags_ref;\n-\n-    DRenderer(final DRendererContext rdrCtx) {\n-        this.rdrCtx = rdrCtx;\n-        this.curve = rdrCtx.curve;\n-        this.cache = rdrCtx.cache;\n-\n-        this.edges = rdrCtx.newOffHeapArray(INITIAL_EDGES_CAPACITY); \/\/ 96K\n-\n-        edgeBuckets_ref      = rdrCtx.newCleanIntArrayRef(INITIAL_BUCKET_ARRAY); \/\/ 64K\n-        edgeBucketCounts_ref = rdrCtx.newCleanIntArrayRef(INITIAL_BUCKET_ARRAY); \/\/ 64K\n-\n-        edgeBuckets      = edgeBuckets_ref.initial;\n-        edgeBucketCounts = edgeBucketCounts_ref.initial;\n-\n-        \/\/ 4096 pixels large\n-        alphaLine_ref = rdrCtx.newCleanIntArrayRef(INITIAL_AA_ARRAY); \/\/ 16K\n-        alphaLine     = alphaLine_ref.initial;\n-\n-        crossings_ref     = rdrCtx.newDirtyIntArrayRef(INITIAL_CROSSING_COUNT); \/\/ 2K\n-        aux_crossings_ref = rdrCtx.newDirtyIntArrayRef(INITIAL_CROSSING_COUNT); \/\/ 2K\n-        edgePtrs_ref      = rdrCtx.newDirtyIntArrayRef(INITIAL_CROSSING_COUNT); \/\/ 2K\n-        aux_edgePtrs_ref  = rdrCtx.newDirtyIntArrayRef(INITIAL_CROSSING_COUNT); \/\/ 2K\n-\n-        crossings     = crossings_ref.initial;\n-        aux_crossings = aux_crossings_ref.initial;\n-        edgePtrs      = edgePtrs_ref.initial;\n-        aux_edgePtrs  = aux_edgePtrs_ref.initial;\n-\n-        blkFlags_ref = rdrCtx.newCleanIntArrayRef(INITIAL_ARRAY); \/\/ 1K = 1 tile line\n-        blkFlags     = blkFlags_ref.initial;\n-    }\n-\n-    DRenderer init(final int pix_boundsX, final int pix_boundsY,\n-                  final int pix_boundsWidth, final int pix_boundsHeight,\n-                  final int windingRule)\n-    {\n-        this.windingRule = windingRule;\n-\n-        \/\/ bounds as half-open intervals: minX <= x < maxX and minY <= y < maxY\n-        this.boundsMinX =  pix_boundsX << SUBPIXEL_LG_POSITIONS_X;\n-        this.boundsMaxX =\n-            (pix_boundsX + pix_boundsWidth) << SUBPIXEL_LG_POSITIONS_X;\n-        this.boundsMinY =  pix_boundsY << SUBPIXEL_LG_POSITIONS_Y;\n-        this.boundsMaxY =\n-            (pix_boundsY + pix_boundsHeight) << SUBPIXEL_LG_POSITIONS_Y;\n-\n-        if (DO_LOG_BOUNDS) {\n-            MarlinUtils.logInfo(\"boundsXY = [\" + boundsMinX + \" ... \"\n-                                + boundsMaxX + \"[ [\" + boundsMinY + \" ... \"\n-                                + boundsMaxY + \"[\");\n-        }\n-\n-        \/\/ see addLine: ceil(boundsMaxY) => boundsMaxY + 1\n-        \/\/ +1 for edgeBucketCounts\n-        final int edgeBucketsLength = (boundsMaxY - boundsMinY) + 1;\n-\n-        if (edgeBucketsLength > INITIAL_BUCKET_ARRAY) {\n-            if (DO_STATS) {\n-                rdrCtx.stats.stat_array_renderer_edgeBuckets\n-                    .add(edgeBucketsLength);\n-                rdrCtx.stats.stat_array_renderer_edgeBucketCounts\n-                    .add(edgeBucketsLength);\n-            }\n-            edgeBuckets = edgeBuckets_ref.getArray(edgeBucketsLength);\n-            edgeBucketCounts = edgeBucketCounts_ref.getArray(edgeBucketsLength);\n-        }\n-\n-        edgeMinY = Integer.MAX_VALUE;\n-        edgeMaxY = Integer.MIN_VALUE;\n-        edgeMinX = Double.POSITIVE_INFINITY;\n-        edgeMaxX = Double.NEGATIVE_INFINITY;\n-\n-        \/\/ reset used mark:\n-        edgeCount = 0;\n-        activeEdgeMaxUsed = 0;\n-        edges.used = 0;\n-\n-        return this; \/\/ fluent API\n-    }\n-\n-    \/**\n-     * Disposes this renderer and recycle it clean up before reusing this instance\n-     *\/\n-    void dispose() {\n-        if (DO_STATS) {\n-            rdrCtx.stats.stat_rdr_activeEdges.add(activeEdgeMaxUsed);\n-            rdrCtx.stats.stat_rdr_edges.add(edges.used);\n-            rdrCtx.stats.stat_rdr_edges_count.add(edges.used \/ SIZEOF_EDGE_BYTES);\n-            rdrCtx.stats.hist_rdr_edges_count.add(edges.used \/ SIZEOF_EDGE_BYTES);\n-            rdrCtx.stats.totalOffHeap += edges.length;\n-        }\n-        \/\/ Return arrays:\n-        crossings = crossings_ref.putArray(crossings);\n-        aux_crossings = aux_crossings_ref.putArray(aux_crossings);\n-\n-        edgePtrs = edgePtrs_ref.putArray(edgePtrs);\n-        aux_edgePtrs = aux_edgePtrs_ref.putArray(aux_edgePtrs);\n-\n-        alphaLine = alphaLine_ref.putArray(alphaLine, 0, 0); \/\/ already zero filled\n-        blkFlags  = blkFlags_ref.putArray(blkFlags, 0, 0); \/\/ already zero filled\n-\n-        if (edgeMinY != Integer.MAX_VALUE) {\n-            \/\/ if context is maked as DIRTY:\n-            if (rdrCtx.dirty) {\n-                \/\/ may happen if an exception if thrown in the pipeline processing:\n-                \/\/ clear completely buckets arrays:\n-                buckets_minY = 0;\n-                buckets_maxY = boundsMaxY - boundsMinY;\n-            }\n-            \/\/ clear only used part\n-            edgeBuckets = edgeBuckets_ref.putArray(edgeBuckets, buckets_minY,\n-                                                                buckets_maxY);\n-            edgeBucketCounts = edgeBucketCounts_ref.putArray(edgeBucketCounts,\n-                                                             buckets_minY,\n-                                                             buckets_maxY + 1);\n-        } else {\n-            \/\/ unused arrays\n-            edgeBuckets = edgeBuckets_ref.putArray(edgeBuckets, 0, 0);\n-            edgeBucketCounts = edgeBucketCounts_ref.putArray(edgeBucketCounts, 0, 0);\n-        }\n-\n-        \/\/ At last: resize back off-heap edges to initial size\n-        if (edges.length != INITIAL_EDGES_CAPACITY) {\n-            \/\/ note: may throw OOME:\n-            edges.resize(INITIAL_EDGES_CAPACITY);\n-        }\n-        if (DO_CLEAN_DIRTY) {\n-            \/\/ Force zero-fill dirty arrays:\n-            edges.fill(BYTE_0);\n-        }\n-        if (DO_MONITORS) {\n-            rdrCtx.stats.mon_rdr_endRendering.stop();\n-        }\n-        \/\/ recycle the RendererContext instance\n-        DMarlinRenderingEngine.returnRendererContext(rdrCtx);\n-    }\n-\n-    private static double tosubpixx(final double pix_x) {\n-        return SUBPIXEL_SCALE_X * pix_x;\n-    }\n-\n-    private static double tosubpixy(final double pix_y) {\n-        \/\/ shift y by -0.5 for fast ceil(y - 0.5):\n-        return SUBPIXEL_SCALE_Y * pix_y - 0.5d;\n-    }\n-\n-    @Override\n-    public void moveTo(final double pix_x0, final double pix_y0) {\n-        closePath();\n-        final double sx = tosubpixx(pix_x0);\n-        final double sy = tosubpixy(pix_y0);\n-        this.sx0 = sx;\n-        this.sy0 = sy;\n-        this.x0 = sx;\n-        this.y0 = sy;\n-    }\n-\n-    @Override\n-    public void lineTo(final double pix_x1, final double pix_y1) {\n-        final double x1 = tosubpixx(pix_x1);\n-        final double y1 = tosubpixy(pix_y1);\n-        addLine(x0, y0, x1, y1);\n-        x0 = x1;\n-        y0 = y1;\n-    }\n-\n-    @Override\n-    public void curveTo(final double pix_x1, final double pix_y1,\n-                        final double pix_x2, final double pix_y2,\n-                        final double pix_x3, final double pix_y3)\n-    {\n-        final double xe = tosubpixx(pix_x3);\n-        final double ye = tosubpixy(pix_y3);\n-        curve.set(x0, y0,\n-                tosubpixx(pix_x1), tosubpixy(pix_y1),\n-                tosubpixx(pix_x2), tosubpixy(pix_y2),\n-                xe, ye);\n-        curveBreakIntoLinesAndAdd(x0, y0, curve, xe, ye);\n-        x0 = xe;\n-        y0 = ye;\n-    }\n-\n-    @Override\n-    public void quadTo(final double pix_x1, final double pix_y1,\n-                       final double pix_x2, final double pix_y2)\n-    {\n-        final double xe = tosubpixx(pix_x2);\n-        final double ye = tosubpixy(pix_y2);\n-        curve.set(x0, y0,\n-                tosubpixx(pix_x1), tosubpixy(pix_y1),\n-                xe, ye);\n-        quadBreakIntoLinesAndAdd(x0, y0, curve, xe, ye);\n-        x0 = xe;\n-        y0 = ye;\n-    }\n-\n-    @Override\n-    public void closePath() {\n-        if (x0 != sx0 || y0 != sy0) {\n-            addLine(x0, y0, sx0, sy0);\n-            x0 = sx0;\n-            y0 = sy0;\n-        }\n-    }\n-\n-    @Override\n-    public void pathDone() {\n-        closePath();\n-    }\n-\n-    @Override\n-    public long getNativeConsumer() {\n-        throw new InternalError(\"Renderer does not use a native consumer.\");\n-    }\n-\n-    private void _endRendering(final int ymin, final int ymax) {\n-        if (DISABLE_RENDER) {\n-            return;\n-        }\n-\n-        \/\/ Get X bounds as true pixel boundaries to compute correct pixel coverage:\n-        final int bboxx0 = bbox_spminX;\n-        final int bboxx1 = bbox_spmaxX;\n-\n-        final boolean windingRuleEvenOdd = (windingRule == WIND_EVEN_ODD);\n-\n-        \/\/ Useful when processing tile line by tile line\n-        final int[] _alpha = alphaLine;\n-\n-        \/\/ local vars (performance):\n-        final MarlinCache _cache = cache;\n-        final OffHeapArray _edges = edges;\n-        final int[] _edgeBuckets = edgeBuckets;\n-        final int[] _edgeBucketCounts = edgeBucketCounts;\n-\n-        int[] _crossings = this.crossings;\n-        int[] _edgePtrs  = this.edgePtrs;\n-\n-        \/\/ merge sort auxiliary storage:\n-        int[] _aux_crossings = this.aux_crossings;\n-        int[] _aux_edgePtrs  = this.aux_edgePtrs;\n-\n-        \/\/ copy constants:\n-        final long _OFF_ERROR    = OFF_ERROR;\n-        final long _OFF_BUMP_X   = OFF_BUMP_X;\n-        final long _OFF_BUMP_ERR = OFF_BUMP_ERR;\n-\n-        final long _OFF_NEXT     = OFF_NEXT;\n-        final long _OFF_YMAX     = OFF_YMAX;\n-\n-        final int _ALL_BUT_LSB   = ALL_BUT_LSB;\n-        final int _ERR_STEP_MAX  = ERR_STEP_MAX;\n-\n-        \/\/ unsafe I\/O:\n-        final Unsafe _unsafe = OffHeapArray.UNSAFE;\n-        final long    addr0  = _edges.address;\n-        long addr;\n-        final int _SUBPIXEL_LG_POSITIONS_X = SUBPIXEL_LG_POSITIONS_X;\n-        final int _SUBPIXEL_LG_POSITIONS_Y = SUBPIXEL_LG_POSITIONS_Y;\n-        final int _SUBPIXEL_MASK_X = SUBPIXEL_MASK_X;\n-        final int _SUBPIXEL_MASK_Y = SUBPIXEL_MASK_Y;\n-        final int _SUBPIXEL_POSITIONS_X = SUBPIXEL_POSITIONS_X;\n-\n-        final int _MIN_VALUE = Integer.MIN_VALUE;\n-        final int _MAX_VALUE = Integer.MAX_VALUE;\n-\n-        \/\/ Now we iterate through the scanlines. We must tell emitRow the coord\n-        \/\/ of the first non-transparent pixel, so we must keep accumulators for\n-        \/\/ the first and last pixels of the section of the current pixel row\n-        \/\/ that we will emit.\n-        \/\/ We also need to accumulate pix_bbox, but the iterator does it\n-        \/\/ for us. We will just get the values from it once this loop is done\n-        int minX = _MAX_VALUE;\n-        int maxX = _MIN_VALUE;\n-\n-        int y = ymin;\n-        int bucket = y - boundsMinY;\n-\n-        int numCrossings = this.edgeCount;\n-        int edgePtrsLen = _edgePtrs.length;\n-        int crossingsLen = _crossings.length;\n-        int _arrayMaxUsed = activeEdgeMaxUsed;\n-        int ptrLen = 0, newCount, ptrEnd;\n-\n-        int bucketcount, i, j, ecur;\n-        int cross, lastCross;\n-        int x0, x1, tmp, sum, prev, curx, curxo, crorientation, err;\n-        int pix_x, pix_xmaxm1, pix_xmax;\n-\n-        int low, high, mid, prevNumCrossings;\n-        boolean useBinarySearch;\n-\n-        final int[] _blkFlags = blkFlags;\n-        final int _BLK_SIZE_LG = BLOCK_SIZE_LG;\n-        final int _BLK_SIZE = BLOCK_SIZE;\n-\n-        final boolean _enableBlkFlagsHeuristics = ENABLE_BLOCK_FLAGS_HEURISTICS && this.enableBlkFlags;\n-\n-        \/\/ Use block flags if large pixel span and few crossings:\n-        \/\/ ie mean(distance between crossings) is high\n-        boolean useBlkFlags = this.prevUseBlkFlags;\n-\n-        final int stroking = rdrCtx.stroking;\n-\n-        int lastY = -1; \/\/ last emited row\n-\n-\n-        \/\/ Iteration on scanlines\n-        for (; y < ymax; y++, bucket++) {\n-            \/\/ --- from former ScanLineIterator.next()\n-            bucketcount = _edgeBucketCounts[bucket];\n-\n-            \/\/ marker on previously sorted edges:\n-            prevNumCrossings = numCrossings;\n-\n-            \/\/ bucketCount indicates new edge \/ edge end:\n-            if (bucketcount != 0) {\n-                if (DO_STATS) {\n-                    rdrCtx.stats.stat_rdr_activeEdges_updates.add(numCrossings);\n-                }\n-\n-                \/\/ last bit set to 1 means that edges ends\n-                if ((bucketcount & 0x1) != 0) {\n-                    \/\/ eviction in active edge list\n-                    \/\/ cache edges[] address + offset\n-                    addr = addr0 + _OFF_YMAX;\n-\n-                    for (i = 0, newCount = 0; i < numCrossings; i++) {\n-                        \/\/ get the pointer to the edge\n-                        ecur = _edgePtrs[i];\n-                        \/\/ random access so use unsafe:\n-                        if (_unsafe.getInt(addr + ecur) > y) {\n-                            _edgePtrs[newCount++] = ecur;\n-                        }\n-                    }\n-                    \/\/ update marker on sorted edges minus removed edges:\n-                    prevNumCrossings = numCrossings = newCount;\n-                }\n-\n-                ptrLen = bucketcount >> 1; \/\/ number of new edge\n-\n-                if (ptrLen != 0) {\n-                    if (DO_STATS) {\n-                        rdrCtx.stats.stat_rdr_activeEdges_adds.add(ptrLen);\n-                        if (ptrLen > 10) {\n-                            rdrCtx.stats.stat_rdr_activeEdges_adds_high.add(ptrLen);\n-                        }\n-                    }\n-                    ptrEnd = numCrossings + ptrLen;\n-\n-                    if (edgePtrsLen < ptrEnd) {\n-                        if (DO_STATS) {\n-                            rdrCtx.stats.stat_array_renderer_edgePtrs.add(ptrEnd);\n-                        }\n-                        this.edgePtrs = _edgePtrs\n-                            = edgePtrs_ref.widenArray(_edgePtrs, numCrossings,\n-                                                      ptrEnd);\n-\n-                        edgePtrsLen = _edgePtrs.length;\n-                        \/\/ Get larger auxiliary storage:\n-                        aux_edgePtrs_ref.putArray(_aux_edgePtrs);\n-\n-                        \/\/ use ArrayCache.getNewSize() to use the same growing\n-                        \/\/ factor than widenArray():\n-                        if (DO_STATS) {\n-                            rdrCtx.stats.stat_array_renderer_aux_edgePtrs.add(ptrEnd);\n-                        }\n-                        this.aux_edgePtrs = _aux_edgePtrs\n-                            = aux_edgePtrs_ref.getArray(\n-                                ArrayCacheConst.getNewSize(numCrossings, ptrEnd)\n-                            );\n-                    }\n-\n-                    \/\/ cache edges[] address + offset\n-                    addr = addr0 + _OFF_NEXT;\n-\n-                    \/\/ add new edges to active edge list:\n-                    for (ecur = _edgeBuckets[bucket];\n-                         numCrossings < ptrEnd; numCrossings++)\n-                    {\n-                        \/\/ store the pointer to the edge\n-                        _edgePtrs[numCrossings] = ecur;\n-                        \/\/ random access so use unsafe:\n-                        ecur = _unsafe.getInt(addr + ecur);\n-                    }\n-\n-                    if (crossingsLen < numCrossings) {\n-                        \/\/ Get larger array:\n-                        crossings_ref.putArray(_crossings);\n-\n-                        if (DO_STATS) {\n-                            rdrCtx.stats.stat_array_renderer_crossings\n-                                .add(numCrossings);\n-                        }\n-                        this.crossings = _crossings\n-                            = crossings_ref.getArray(numCrossings);\n-\n-                        \/\/ Get larger auxiliary storage:\n-                        aux_crossings_ref.putArray(_aux_crossings);\n-\n-                        if (DO_STATS) {\n-                            rdrCtx.stats.stat_array_renderer_aux_crossings\n-                                .add(numCrossings);\n-                        }\n-                        this.aux_crossings = _aux_crossings\n-                            = aux_crossings_ref.getArray(numCrossings);\n-\n-                        crossingsLen = _crossings.length;\n-                    }\n-                    if (DO_STATS) {\n-                        \/\/ update max used mark\n-                        if (numCrossings > _arrayMaxUsed) {\n-                            _arrayMaxUsed = numCrossings;\n-                        }\n-                    }\n-                } \/\/ ptrLen != 0\n-            } \/\/ bucketCount != 0\n-\n-\n-            if (numCrossings != 0) {\n-                \/*\n-                 * thresholds to switch to optimized merge sort\n-                 * for newly added edges + final merge pass.\n-                 *\/\n-                if ((ptrLen < 10) || (numCrossings < 40)) {\n-                    if (DO_STATS) {\n-                        rdrCtx.stats.hist_rdr_crossings.add(numCrossings);\n-                        rdrCtx.stats.hist_rdr_crossings_adds.add(ptrLen);\n-                    }\n-\n-                    \/*\n-                     * threshold to use binary insertion sort instead of\n-                     * straight insertion sort (to reduce minimize comparisons).\n-                     *\/\n-                    useBinarySearch = (numCrossings >= 20);\n-\n-                    \/\/ if small enough:\n-                    lastCross = _MIN_VALUE;\n-\n-                    for (i = 0; i < numCrossings; i++) {\n-                        \/\/ get the pointer to the edge\n-                        ecur = _edgePtrs[i];\n-\n-                        \/* convert subpixel coordinates into pixel\n-                            positions for coming scanline *\/\n-                        \/* note: it is faster to always update edges even\n-                           if it is removed from AEL for coming or last scanline *\/\n-\n-                        \/\/ random access so use unsafe:\n-                        addr = addr0 + ecur; \/\/ ecur + OFF_F_CURX\n-\n-                        \/\/ get current crossing:\n-                        curx = _unsafe.getInt(addr);\n-\n-                        \/\/ update crossing with orientation at last bit:\n-                        cross = curx;\n-\n-                        \/\/ Increment x using DDA (fixed point):\n-                        curx += _unsafe.getInt(addr + _OFF_BUMP_X);\n-\n-                        \/\/ Increment error:\n-                        err  =  _unsafe.getInt(addr + _OFF_ERROR)\n-                              + _unsafe.getInt(addr + _OFF_BUMP_ERR);\n-\n-                        \/\/ Manual carry handling:\n-                        \/\/ keep sign and carry bit only and ignore last bit (preserve orientation):\n-                        _unsafe.putInt(addr,               curx - ((err >> 30) & _ALL_BUT_LSB));\n-                        _unsafe.putInt(addr + _OFF_ERROR, (err & _ERR_STEP_MAX));\n-\n-                        if (DO_STATS) {\n-                            rdrCtx.stats.stat_rdr_crossings_updates.add(numCrossings);\n-                        }\n-\n-                        \/\/ insertion sort of crossings:\n-                        if (cross < lastCross) {\n-                            if (DO_STATS) {\n-                                rdrCtx.stats.stat_rdr_crossings_sorts.add(i);\n-                            }\n-\n-                            \/* use binary search for newly added edges\n-                               in crossings if arrays are large enough *\/\n-                            if (useBinarySearch && (i >= prevNumCrossings)) {\n-                                if (DO_STATS) {\n-                                    rdrCtx.stats.stat_rdr_crossings_bsearch.add(i);\n-                                }\n-                                low = 0;\n-                                high = i - 1;\n-\n-                                do {\n-                                    \/\/ note: use signed shift (not >>>) for performance\n-                                    \/\/ as indices are small enough to exceed Integer.MAX_VALUE\n-                                    mid = (low + high) >> 1;\n-\n-                                    if (_crossings[mid] < cross) {\n-                                        low = mid + 1;\n-                                    } else {\n-                                        high = mid - 1;\n-                                    }\n-                                } while (low <= high);\n-\n-                                for (j = i - 1; j >= low; j--) {\n-                                    _crossings[j + 1] = _crossings[j];\n-                                    _edgePtrs [j + 1] = _edgePtrs[j];\n-                                }\n-                                _crossings[low] = cross;\n-                                _edgePtrs [low] = ecur;\n-\n-                            } else {\n-                                j = i - 1;\n-                                _crossings[i] = _crossings[j];\n-                                _edgePtrs[i] = _edgePtrs[j];\n-\n-                                while ((--j >= 0) && (_crossings[j] > cross)) {\n-                                    _crossings[j + 1] = _crossings[j];\n-                                    _edgePtrs [j + 1] = _edgePtrs[j];\n-                                }\n-                                _crossings[j + 1] = cross;\n-                                _edgePtrs [j + 1] = ecur;\n-                            }\n-\n-                        } else {\n-                            _crossings[i] = lastCross = cross;\n-                        }\n-                    }\n-                } else {\n-                    if (DO_STATS) {\n-                        rdrCtx.stats.stat_rdr_crossings_msorts.add(numCrossings);\n-                        rdrCtx.stats.hist_rdr_crossings_ratio\n-                            .add((1000 * ptrLen) \/ numCrossings);\n-                        rdrCtx.stats.hist_rdr_crossings_msorts.add(numCrossings);\n-                        rdrCtx.stats.hist_rdr_crossings_msorts_adds.add(ptrLen);\n-                    }\n-\n-                    \/\/ Copy sorted data in auxiliary arrays\n-                    \/\/ and perform insertion sort on almost sorted data\n-                    \/\/ (ie i < prevNumCrossings):\n-\n-                    lastCross = _MIN_VALUE;\n-\n-                    for (i = 0; i < numCrossings; i++) {\n-                        \/\/ get the pointer to the edge\n-                        ecur = _edgePtrs[i];\n-\n-                        \/* convert subpixel coordinates into pixel\n-                            positions for coming scanline *\/\n-                        \/* note: it is faster to always update edges even\n-                           if it is removed from AEL for coming or last scanline *\/\n-\n-                        \/\/ random access so use unsafe:\n-                        addr = addr0 + ecur; \/\/ ecur + OFF_F_CURX\n-\n-                        \/\/ get current crossing:\n-                        curx = _unsafe.getInt(addr);\n-\n-                        \/\/ update crossing with orientation at last bit:\n-                        cross = curx;\n-\n-                        \/\/ Increment x using DDA (fixed point):\n-                        curx += _unsafe.getInt(addr + _OFF_BUMP_X);\n-\n-                        \/\/ Increment error:\n-                        err  =  _unsafe.getInt(addr + _OFF_ERROR)\n-                              + _unsafe.getInt(addr + _OFF_BUMP_ERR);\n-\n-                        \/\/ Manual carry handling:\n-                        \/\/ keep sign and carry bit only and ignore last bit (preserve orientation):\n-                        _unsafe.putInt(addr,               curx - ((err >> 30) & _ALL_BUT_LSB));\n-                        _unsafe.putInt(addr + _OFF_ERROR, (err & _ERR_STEP_MAX));\n-\n-                        if (DO_STATS) {\n-                            rdrCtx.stats.stat_rdr_crossings_updates.add(numCrossings);\n-                        }\n-\n-                        if (i >= prevNumCrossings) {\n-                            \/\/ simply store crossing as edgePtrs is in-place:\n-                            \/\/ will be copied and sorted efficiently by mergesort later:\n-                            _crossings[i]     = cross;\n-\n-                        } else if (cross < lastCross) {\n-                            if (DO_STATS) {\n-                                rdrCtx.stats.stat_rdr_crossings_sorts.add(i);\n-                            }\n-\n-                            \/\/ (straight) insertion sort of crossings:\n-                            j = i - 1;\n-                            _aux_crossings[i] = _aux_crossings[j];\n-                            _aux_edgePtrs[i] = _aux_edgePtrs[j];\n-\n-                            while ((--j >= 0) && (_aux_crossings[j] > cross)) {\n-                                _aux_crossings[j + 1] = _aux_crossings[j];\n-                                _aux_edgePtrs [j + 1] = _aux_edgePtrs[j];\n-                            }\n-                            _aux_crossings[j + 1] = cross;\n-                            _aux_edgePtrs [j + 1] = ecur;\n-\n-                        } else {\n-                            \/\/ auxiliary storage:\n-                            _aux_crossings[i] = lastCross = cross;\n-                            _aux_edgePtrs [i] = ecur;\n-                        }\n-                    }\n-\n-                    \/\/ use Mergesort using auxiliary arrays (sort only right part)\n-                    MergeSort.mergeSortNoCopy(_crossings,     _edgePtrs,\n-                                              _aux_crossings, _aux_edgePtrs,\n-                                              numCrossings,   prevNumCrossings);\n-                }\n-\n-                \/\/ reset ptrLen\n-                ptrLen = 0;\n-                \/\/ --- from former ScanLineIterator.next()\n-\n-\n-                \/* note: bboxx0 and bboxx1 must be pixel boundaries\n-                   to have correct coverage computation *\/\n-\n-                \/\/ right shift on crossings to get the x-coordinate:\n-                curxo = _crossings[0];\n-                x0    = curxo >> 1;\n-                if (x0 < minX) {\n-                    minX = x0; \/\/ subpixel coordinate\n-                }\n-\n-                x1 = _crossings[numCrossings - 1] >> 1;\n-                if (x1 > maxX) {\n-                    maxX = x1; \/\/ subpixel coordinate\n-                }\n-\n-\n-                \/\/ compute pixel coverages\n-                prev = curx = x0;\n-                \/\/ to turn {0, 1} into {-1, 1}, multiply by 2 and subtract 1.\n-                \/\/ last bit contains orientation (0 or 1)\n-                crorientation = ((curxo & 0x1) << 1) - 1;\n-\n-                if (windingRuleEvenOdd) {\n-                    sum = crorientation;\n-\n-                    \/\/ Even Odd winding rule: take care of mask ie sum(orientations)\n-                    for (i = 1; i < numCrossings; i++) {\n-                        curxo = _crossings[i];\n-                        curx  =  curxo >> 1;\n-                        \/\/ to turn {0, 1} into {-1, 1}, multiply by 2 and subtract 1.\n-                        \/\/ last bit contains orientation (0 or 1)\n-                        crorientation = ((curxo & 0x1) << 1) - 1;\n-\n-                        if ((sum & 0x1) != 0) {\n-                            \/\/ TODO: perform line clipping on left-right sides\n-                            \/\/ to avoid such bound checks:\n-                            x0 = (prev > bboxx0) ? prev : bboxx0;\n-\n-                            if (curx < bboxx1) {\n-                                x1 = curx;\n-                            } else {\n-                                x1 = bboxx1;\n-                                \/\/ skip right side (fast exit loop):\n-                                i = numCrossings;\n-                            }\n-\n-                            if (x0 < x1) {\n-                                x0 -= bboxx0; \/\/ turn x0, x1 from coords to indices\n-                                x1 -= bboxx0; \/\/ in the alpha array.\n-\n-                                pix_x      =  x0      >> _SUBPIXEL_LG_POSITIONS_X;\n-                                pix_xmaxm1 = (x1 - 1) >> _SUBPIXEL_LG_POSITIONS_X;\n-\n-                                if (pix_x == pix_xmaxm1) {\n-                                    \/\/ Start and end in same pixel\n-                                    tmp = (x1 - x0); \/\/ number of subpixels\n-                                    _alpha[pix_x    ] += tmp;\n-                                    _alpha[pix_x + 1] -= tmp;\n-\n-                                    if (useBlkFlags) {\n-                                        \/\/ flag used blocks:\n-                                        \/\/ note: block processing handles extra pixel:\n-                                        _blkFlags[pix_x    >> _BLK_SIZE_LG] = 1;\n-                                    }\n-                                } else {\n-                                    tmp = (x0 & _SUBPIXEL_MASK_X);\n-                                    _alpha[pix_x    ]\n-                                        += (_SUBPIXEL_POSITIONS_X - tmp);\n-                                    _alpha[pix_x + 1]\n-                                        += tmp;\n-\n-                                    pix_xmax = x1 >> _SUBPIXEL_LG_POSITIONS_X;\n-\n-                                    tmp = (x1 & _SUBPIXEL_MASK_X);\n-                                    _alpha[pix_xmax    ]\n-                                        -= (_SUBPIXEL_POSITIONS_X - tmp);\n-                                    _alpha[pix_xmax + 1]\n-                                        -= tmp;\n-\n-                                    if (useBlkFlags) {\n-                                        \/\/ flag used blocks:\n-                                        \/\/ note: block processing handles extra pixel:\n-                                        _blkFlags[pix_x    >> _BLK_SIZE_LG] = 1;\n-                                        _blkFlags[pix_xmax >> _BLK_SIZE_LG] = 1;\n-                                    }\n-                                }\n-                            }\n-                        }\n-\n-                        sum += crorientation;\n-                        prev = curx;\n-                    }\n-                } else {\n-                    \/\/ Non-zero winding rule: optimize that case (default)\n-                    \/\/ and avoid processing intermediate crossings\n-                    for (i = 1, sum = 0;; i++) {\n-                        sum += crorientation;\n-\n-                        if (sum != 0) {\n-                            \/\/ prev = min(curx)\n-                            if (prev > curx) {\n-                                prev = curx;\n-                            }\n-                        } else {\n-                            \/\/ TODO: perform line clipping on left-right sides\n-                            \/\/ to avoid such bound checks:\n-                            x0 = (prev > bboxx0) ? prev : bboxx0;\n-\n-                            if (curx < bboxx1) {\n-                                x1 = curx;\n-                            } else {\n-                                x1 = bboxx1;\n-                                \/\/ skip right side (fast exit loop):\n-                                i = numCrossings;\n-                            }\n-\n-                            if (x0 < x1) {\n-                                x0 -= bboxx0; \/\/ turn x0, x1 from coords to indices\n-                                x1 -= bboxx0; \/\/ in the alpha array.\n-\n-                                pix_x      =  x0      >> _SUBPIXEL_LG_POSITIONS_X;\n-                                pix_xmaxm1 = (x1 - 1) >> _SUBPIXEL_LG_POSITIONS_X;\n-\n-                                if (pix_x == pix_xmaxm1) {\n-                                    \/\/ Start and end in same pixel\n-                                    tmp = (x1 - x0); \/\/ number of subpixels\n-                                    _alpha[pix_x    ] += tmp;\n-                                    _alpha[pix_x + 1] -= tmp;\n-\n-                                    if (useBlkFlags) {\n-                                        \/\/ flag used blocks:\n-                                        \/\/ note: block processing handles extra pixel:\n-                                        _blkFlags[pix_x    >> _BLK_SIZE_LG] = 1;\n-                                    }\n-                                } else {\n-                                    tmp = (x0 & _SUBPIXEL_MASK_X);\n-                                    _alpha[pix_x    ]\n-                                        += (_SUBPIXEL_POSITIONS_X - tmp);\n-                                    _alpha[pix_x + 1]\n-                                        += tmp;\n-\n-                                    pix_xmax = x1 >> _SUBPIXEL_LG_POSITIONS_X;\n-\n-                                    tmp = (x1 & _SUBPIXEL_MASK_X);\n-                                    _alpha[pix_xmax    ]\n-                                        -= (_SUBPIXEL_POSITIONS_X - tmp);\n-                                    _alpha[pix_xmax + 1]\n-                                        -= tmp;\n-\n-                                    if (useBlkFlags) {\n-                                        \/\/ flag used blocks:\n-                                        \/\/ note: block processing handles extra pixel:\n-                                        _blkFlags[pix_x    >> _BLK_SIZE_LG] = 1;\n-                                        _blkFlags[pix_xmax >> _BLK_SIZE_LG] = 1;\n-                                    }\n-                                }\n-                            }\n-                            prev = _MAX_VALUE;\n-                        }\n-\n-                        if (i == numCrossings) {\n-                            break;\n-                        }\n-\n-                        curxo = _crossings[i];\n-                        curx  =  curxo >> 1;\n-                        \/\/ to turn {0, 1} into {-1, 1}, multiply by 2 and subtract 1.\n-                        \/\/ last bit contains orientation (0 or 1)\n-                        crorientation = ((curxo & 0x1) << 1) - 1;\n-                    }\n-                }\n-            } \/\/ numCrossings > 0\n-\n-            \/\/ even if this last row had no crossings, alpha will be zeroed\n-            \/\/ from the last emitRow call. But this doesn't matter because\n-            \/\/ maxX < minX, so no row will be emitted to the MarlinCache.\n-            if ((y & _SUBPIXEL_MASK_Y) == _SUBPIXEL_MASK_Y) {\n-                lastY = y >> _SUBPIXEL_LG_POSITIONS_Y;\n-\n-                \/\/ convert subpixel to pixel coordinate within boundaries:\n-                minX = FloatMath.max(minX, bboxx0) >> _SUBPIXEL_LG_POSITIONS_X;\n-                maxX = FloatMath.min(maxX, bboxx1) >> _SUBPIXEL_LG_POSITIONS_X;\n-\n-                if (maxX >= minX) {\n-                    \/\/ note: alpha array will be zeroed by copyAARow()\n-                    \/\/ +1 because alpha [pix_minX; pix_maxX[\n-                    \/\/ fix range [x0; x1[\n-                    \/\/ note: if x1=bboxx1, then alpha is written up to bboxx1+1\n-                    \/\/ inclusive: alpha[bboxx1] ignored, alpha[bboxx1+1] == 0\n-                    \/\/ (normally so never cleared below)\n-                    copyAARow(_alpha, lastY, minX, maxX + 1, useBlkFlags);\n-\n-                    \/\/ speculative for next pixel row (scanline coherence):\n-                    if (_enableBlkFlagsHeuristics) {\n-                        \/\/ Use block flags if large pixel span and few crossings:\n-                        \/\/ ie mean(distance between crossings) is larger than\n-                        \/\/ 1 block size;\n-\n-                        \/\/ fast check width:\n-                        maxX -= minX;\n-\n-                        \/\/ if stroking: numCrossings \/= 2\n-                        \/\/ => shift numCrossings by 1\n-                        \/\/ condition = (width \/ (numCrossings - 1)) > blockSize\n-                        useBlkFlags = (maxX > _BLK_SIZE) && (maxX >\n-                            (((numCrossings >> stroking) - 1) << _BLK_SIZE_LG));\n-\n-                        if (DO_STATS) {\n-                            tmp = FloatMath.max(1,\n-                                    ((numCrossings >> stroking) - 1));\n-                            rdrCtx.stats.hist_tile_generator_encoding_dist\n-                                .add(maxX \/ tmp);\n-                        }\n-                    }\n-                } else {\n-                    _cache.clearAARow(lastY);\n-                }\n-                minX = _MAX_VALUE;\n-                maxX = _MIN_VALUE;\n-            }\n-        } \/\/ scan line iterator\n-\n-        \/\/ Emit final row\n-        y--;\n-        y >>= _SUBPIXEL_LG_POSITIONS_Y;\n-\n-        \/\/ convert subpixel to pixel coordinate within boundaries:\n-        minX = FloatMath.max(minX, bboxx0) >> _SUBPIXEL_LG_POSITIONS_X;\n-        maxX = FloatMath.min(maxX, bboxx1) >> _SUBPIXEL_LG_POSITIONS_X;\n-\n-        if (maxX >= minX) {\n-            \/\/ note: alpha array will be zeroed by copyAARow()\n-            \/\/ +1 because alpha [pix_minX; pix_maxX[\n-            \/\/ fix range [x0; x1[\n-            \/\/ note: if x1=bboxx1, then alpha is written up to bboxx1+1\n-            \/\/ inclusive: alpha[bboxx1] ignored then cleared and\n-            \/\/ alpha[bboxx1+1] == 0 (normally so never cleared after)\n-            copyAARow(_alpha, y, minX, maxX + 1, useBlkFlags);\n-        } else if (y != lastY) {\n-            _cache.clearAARow(y);\n-        }\n-\n-        \/\/ update member:\n-        edgeCount = numCrossings;\n-        prevUseBlkFlags = useBlkFlags;\n-\n-        if (DO_STATS) {\n-            \/\/ update max used mark\n-            activeEdgeMaxUsed = _arrayMaxUsed;\n-        }\n-    }\n-\n-    boolean endRendering() {\n-        if (DO_MONITORS) {\n-            rdrCtx.stats.mon_rdr_endRendering.start();\n-        }\n-        if (edgeMinY == Integer.MAX_VALUE) {\n-            return false; \/\/ undefined edges bounds\n-        }\n-\n-        \/\/ bounds as half-open intervals\n-        final int spminX = FloatMath.max(FloatMath.ceil_int(edgeMinX - 0.5d), boundsMinX);\n-        final int spmaxX = FloatMath.min(FloatMath.ceil_int(edgeMaxX - 0.5d), boundsMaxX);\n-\n-        \/\/ edge Min\/Max Y are already rounded to subpixels within bounds:\n-        final int spminY = edgeMinY;\n-        final int spmaxY = edgeMaxY;\n-\n-        buckets_minY = spminY - boundsMinY;\n-        buckets_maxY = spmaxY - boundsMinY;\n-\n-        if (DO_LOG_BOUNDS) {\n-            MarlinUtils.logInfo(\"edgesXY = [\" + edgeMinX + \" ... \" + edgeMaxX\n-                                + \"[ [\" + edgeMinY + \" ... \" + edgeMaxY + \"[\");\n-            MarlinUtils.logInfo(\"spXY    = [\" + spminX + \" ... \" + spmaxX\n-                                + \"[ [\" + spminY + \" ... \" + spmaxY + \"[\");\n-        }\n-\n-        \/\/ test clipping for shapes out of bounds\n-        if ((spminX >= spmaxX) || (spminY >= spmaxY)) {\n-            return false;\n-        }\n-\n-        \/\/ half open intervals\n-        \/\/ inclusive:\n-        final int pminX =  spminX                    >> SUBPIXEL_LG_POSITIONS_X;\n-        \/\/ exclusive:\n-        final int pmaxX = (spmaxX + SUBPIXEL_MASK_X) >> SUBPIXEL_LG_POSITIONS_X;\n-        \/\/ inclusive:\n-        final int pminY =  spminY                    >> SUBPIXEL_LG_POSITIONS_Y;\n-        \/\/ exclusive:\n-        final int pmaxY = (spmaxY + SUBPIXEL_MASK_Y) >> SUBPIXEL_LG_POSITIONS_Y;\n-\n-        \/\/ store BBox to answer ptg.getBBox():\n-        this.cache.init(pminX, pminY, pmaxX, pmaxY);\n-\n-        \/\/ Heuristics for using block flags:\n-        if (ENABLE_BLOCK_FLAGS) {\n-            enableBlkFlags = this.cache.useRLE;\n-            prevUseBlkFlags = enableBlkFlags && !ENABLE_BLOCK_FLAGS_HEURISTICS;\n-\n-            if (enableBlkFlags) {\n-                \/\/ ensure blockFlags array is large enough:\n-                \/\/ note: +2 to ensure enough space left at end\n-                final int blkLen = ((pmaxX - pminX) >> BLOCK_SIZE_LG) + 2;\n-                if (blkLen > INITIAL_ARRAY) {\n-                    blkFlags = blkFlags_ref.getArray(blkLen);\n-                }\n-            }\n-        }\n-\n-        \/\/ memorize the rendering bounding box:\n-        \/* note: bbox_spminX and bbox_spmaxX must be pixel boundaries\n-           to have correct coverage computation *\/\n-        \/\/ inclusive:\n-        bbox_spminX = pminX << SUBPIXEL_LG_POSITIONS_X;\n-        \/\/ exclusive:\n-        bbox_spmaxX = pmaxX << SUBPIXEL_LG_POSITIONS_X;\n-        \/\/ inclusive:\n-        bbox_spminY = spminY;\n-        \/\/ exclusive:\n-        bbox_spmaxY = spmaxY;\n-\n-        if (DO_LOG_BOUNDS) {\n-            MarlinUtils.logInfo(\"pXY       = [\" + pminX + \" ... \" + pmaxX\n-                                + \"[ [\" + pminY + \" ... \" + pmaxY + \"[\");\n-            MarlinUtils.logInfo(\"bbox_spXY = [\" + bbox_spminX + \" ... \"\n-                                + bbox_spmaxX + \"[ [\" + bbox_spminY + \" ... \"\n-                                + bbox_spmaxY + \"[\");\n-        }\n-\n-        \/\/ Prepare alpha line:\n-        \/\/ add 2 to better deal with the last pixel in a pixel row.\n-        final int width = (pmaxX - pminX) + 2;\n-\n-        \/\/ Useful when processing tile line by tile line\n-        if (width > INITIAL_AA_ARRAY) {\n-            if (DO_STATS) {\n-                rdrCtx.stats.stat_array_renderer_alphaline.add(width);\n-            }\n-            alphaLine = alphaLine_ref.getArray(width);\n-        }\n-\n-        \/\/ process first tile line:\n-        endRendering(pminY);\n-\n-        return true;\n-    }\n-\n-    private int bbox_spminX, bbox_spmaxX, bbox_spminY, bbox_spmaxY;\n-\n-    void endRendering(final int pminY) {\n-        if (DO_MONITORS) {\n-            rdrCtx.stats.mon_rdr_endRendering_Y.start();\n-        }\n-\n-        final int spminY       = pminY << SUBPIXEL_LG_POSITIONS_Y;\n-        final int fixed_spminY = FloatMath.max(bbox_spminY, spminY);\n-\n-        \/\/ avoid rendering for last call to nextTile()\n-        if (fixed_spminY < bbox_spmaxY) {\n-            \/\/ process a complete tile line ie scanlines for 32 rows\n-            final int spmaxY = FloatMath.min(bbox_spmaxY, spminY + SUBPIXEL_TILE);\n-\n-            \/\/ process tile line [0 - 32]\n-            cache.resetTileLine(pminY);\n-\n-            \/\/ Process only one tile line:\n-            _endRendering(fixed_spminY, spmaxY);\n-        }\n-        if (DO_MONITORS) {\n-            rdrCtx.stats.mon_rdr_endRendering_Y.stop();\n-        }\n-    }\n-\n-    void copyAARow(final int[] alphaRow,\n-                   final int pix_y, final int pix_from, final int pix_to,\n-                   final boolean useBlockFlags)\n-    {\n-        if (DO_MONITORS) {\n-            rdrCtx.stats.mon_rdr_copyAARow.start();\n-        }\n-        if (useBlockFlags) {\n-            if (DO_STATS) {\n-                rdrCtx.stats.hist_tile_generator_encoding.add(1);\n-            }\n-            cache.copyAARowRLE_WithBlockFlags(blkFlags, alphaRow, pix_y, pix_from, pix_to);\n-        } else {\n-            if (DO_STATS) {\n-                rdrCtx.stats.hist_tile_generator_encoding.add(0);\n-            }\n-            cache.copyAARowNoRLE(alphaRow, pix_y, pix_from, pix_to);\n-        }\n-        if (DO_MONITORS) {\n-            rdrCtx.stats.mon_rdr_copyAARow.stop();\n-        }\n-    }\n-}\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/marlin\/DRenderer.java","additions":0,"deletions":1534,"binary":false,"changes":1534,"status":"deleted"},{"patch":"@@ -1,282 +0,0 @@\n-\/*\n- * Copyright (c) 2015, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package sun.java2d.marlin;\n-\n-import java.awt.geom.Path2D;\n-import java.lang.ref.WeakReference;\n-import java.util.concurrent.atomic.AtomicInteger;\n-import sun.java2d.ReentrantContext;\n-import sun.java2d.marlin.ArrayCacheConst.CacheStats;\n-import sun.java2d.marlin.DMarlinRenderingEngine.NormalizingPathIterator;\n-import sun.java2d.marlin.DTransformingPathConsumer2D.CurveBasicMonotonizer;\n-import sun.java2d.marlin.DTransformingPathConsumer2D.CurveClipSplitter;\n-\n-\/**\n- * This class is a renderer context dedicated to a single thread\n- *\/\n-final class DRendererContext extends ReentrantContext implements IRendererContext {\n-\n-    \/\/ RendererContext creation counter\n-    private static final AtomicInteger CTX_COUNT = new AtomicInteger(1);\n-\n-    \/**\n-     * Create a new renderer context\n-     *\n-     * @return new RendererContext instance\n-     *\/\n-    static DRendererContext createContext() {\n-        return new DRendererContext(\"ctx\"\n-                       + Integer.toString(CTX_COUNT.getAndIncrement()));\n-    }\n-\n-    \/\/ Smallest object used as Cleaner's parent reference\n-    private final Object cleanerObj;\n-    \/\/ dirty flag indicating an exception occured during pipeline in pathTo()\n-    boolean dirty = false;\n-    \/\/ shared data\n-    final double[] double6 = new double[6];\n-    \/\/ shared curve (dirty) (Renderer \/ Stroker)\n-    final DCurve curve = new DCurve();\n-    \/\/ MarlinRenderingEngine NormalizingPathIterator NearestPixelCenter:\n-    final NormalizingPathIterator nPCPathIterator;\n-    \/\/ MarlinRenderingEngine NearestPixelQuarter NormalizingPathIterator:\n-    final NormalizingPathIterator nPQPathIterator;\n-    \/\/ MarlinRenderingEngine.TransformingPathConsumer2D\n-    final DTransformingPathConsumer2D transformerPC2D;\n-    \/\/ recycled Path2D instance (weak)\n-    private WeakReference<Path2D.Double> refPath2D = null;\n-    final DRenderer renderer;\n-    final DStroker stroker;\n-    \/\/ Simplifies out collinear lines\n-    final DCollinearSimplifier simplifier = new DCollinearSimplifier();\n-    \/\/ Simplifies path\n-    final DPathSimplifier pathSimplifier = new DPathSimplifier();\n-    final DDasher dasher;\n-    final MarlinTileGenerator ptg;\n-    final MarlinCache cache;\n-    \/\/ flag indicating the shape is stroked (1) or filled (0)\n-    int stroking = 0;\n-    \/\/ flag indicating to clip the shape\n-    boolean doClip = false;\n-    \/\/ flag indicating if the path is closed or not (in advance) to handle properly caps\n-    boolean closedPath = false;\n-    \/\/ clip rectangle (ymin, ymax, xmin, xmax):\n-    final double[] clipRect = new double[4];\n-    \/\/ clip inverse scale (mean) to adjust length checks\n-    double clipInvScale = 0.0d;\n-    \/\/ CurveBasicMonotonizer instance\n-    final CurveBasicMonotonizer monotonizer;\n-    \/\/ CurveClipSplitter instance\n-    final CurveClipSplitter curveClipSplitter;\n-\n-    \/\/ Array caches:\n-    \/* clean int[] cache (zero-filled) = 5 refs *\/\n-    private final IntArrayCache cleanIntCache = new IntArrayCache(true, 5);\n-    \/* dirty int[] cache = 5 refs *\/\n-    private final IntArrayCache dirtyIntCache = new IntArrayCache(false, 5);\n-    \/* dirty double[] cache = 4 refs (2 polystack) *\/\n-    private final DoubleArrayCache dirtyDoubleCache = new DoubleArrayCache(false, 4);\n-    \/* dirty byte[] cache = 2 ref (2 polystack) *\/\n-    private final ByteArrayCache dirtyByteCache = new ByteArrayCache(false, 2);\n-\n-    \/\/ RendererContext statistics\n-    final RendererStats stats;\n-\n-    final PathConsumer2DAdapter p2dAdapter = new PathConsumer2DAdapter();\n-\n-    \/**\n-     * Constructor\n-     *\n-     * @param name context name (debugging)\n-     *\/\n-    DRendererContext(final String name) {\n-        if (LOG_CREATE_CONTEXT) {\n-            MarlinUtils.logInfo(\"new RendererContext = \" + name);\n-        }\n-        this.cleanerObj = new Object();\n-\n-        \/\/ create first stats (needed by newOffHeapArray):\n-        if (DO_STATS || DO_MONITORS) {\n-            stats = RendererStats.createInstance(cleanerObj, name);\n-            \/\/ push cache stats:\n-            stats.cacheStats = new CacheStats[] { cleanIntCache.stats,\n-                dirtyIntCache.stats, dirtyDoubleCache.stats, dirtyByteCache.stats\n-            };\n-        } else {\n-            stats = null;\n-        }\n-\n-        \/\/ NormalizingPathIterator instances:\n-        nPCPathIterator = new NormalizingPathIterator.NearestPixelCenter(double6);\n-        nPQPathIterator  = new NormalizingPathIterator.NearestPixelQuarter(double6);\n-\n-        \/\/ curve monotonizer & clip subdivider (before transformerPC2D init)\n-        monotonizer = new CurveBasicMonotonizer(this);\n-        curveClipSplitter = new CurveClipSplitter(this);\n-\n-        \/\/ MarlinRenderingEngine.TransformingPathConsumer2D\n-        transformerPC2D = new DTransformingPathConsumer2D(this);\n-\n-        \/\/ Renderer:\n-        cache = new MarlinCache(this);\n-        renderer = new DRenderer(this); \/\/ needs MarlinCache from rdrCtx.cache\n-        ptg = new MarlinTileGenerator(stats, renderer, cache);\n-\n-        stroker = new DStroker(this);\n-        dasher = new DDasher(this);\n-    }\n-\n-    \/**\n-     * Disposes this renderer context:\n-     * clean up before reusing this context\n-     *\/\n-    void dispose() {\n-        if (DO_STATS) {\n-            if (stats.totalOffHeap > stats.totalOffHeapMax) {\n-                stats.totalOffHeapMax = stats.totalOffHeap;\n-            }\n-            stats.totalOffHeap = 0L;\n-        }\n-        stroking   = 0;\n-        doClip     = false;\n-        closedPath = false;\n-        clipInvScale = 0.0d;\n-\n-        \/\/ if context is maked as DIRTY:\n-        if (dirty) {\n-            \/\/ may happen if an exception if thrown in the pipeline processing:\n-            \/\/ force cleanup of all possible pipelined blocks (except Renderer):\n-\n-            \/\/ NormalizingPathIterator instances:\n-            this.nPCPathIterator.dispose();\n-            this.nPQPathIterator.dispose();\n-            \/\/ Dasher:\n-            this.dasher.dispose();\n-            \/\/ Stroker:\n-            this.stroker.dispose();\n-\n-            \/\/ mark context as CLEAN:\n-            dirty = false;\n-        }\n-    }\n-\n-    Path2D.Double getPath2D() {\n-        \/\/ resolve reference:\n-        Path2D.Double p2d = (refPath2D != null) ? refPath2D.get() : null;\n-\n-        \/\/ create a new Path2D ?\n-        if (p2d == null) {\n-            p2d = new Path2D.Double(WIND_NON_ZERO, INITIAL_EDGES_COUNT); \/\/ 32K\n-\n-            \/\/ update weak reference:\n-            refPath2D = new WeakReference<Path2D.Double>(p2d);\n-        }\n-        \/\/ reset the path anyway:\n-        p2d.reset();\n-        return p2d;\n-    }\n-\n-    @Override\n-    public RendererStats stats() {\n-        return stats;\n-    }\n-\n-    @Override\n-    public OffHeapArray newOffHeapArray(final long initialSize) {\n-        if (DO_STATS) {\n-            stats.totalOffHeapInitial += initialSize;\n-        }\n-        return new OffHeapArray(cleanerObj, initialSize);\n-    }\n-\n-    @Override\n-    public IntArrayCache.Reference newCleanIntArrayRef(final int initialSize) {\n-        return cleanIntCache.createRef(initialSize);\n-    }\n-\n-    IntArrayCache.Reference newDirtyIntArrayRef(final int initialSize) {\n-        return dirtyIntCache.createRef(initialSize);\n-    }\n-\n-    DoubleArrayCache.Reference newDirtyDoubleArrayRef(final int initialSize) {\n-        return dirtyDoubleCache.createRef(initialSize);\n-    }\n-\n-    ByteArrayCache.Reference newDirtyByteArrayRef(final int initialSize) {\n-        return dirtyByteCache.createRef(initialSize);\n-    }\n-\n-    static final class PathConsumer2DAdapter implements DPathConsumer2D {\n-        private sun.awt.geom.PathConsumer2D out;\n-\n-        PathConsumer2DAdapter() {}\n-\n-        PathConsumer2DAdapter init(sun.awt.geom.PathConsumer2D out) {\n-            this.out = out;\n-            return this;\n-        }\n-\n-        @Override\n-        public void moveTo(double x0, double y0) {\n-            out.moveTo((float)x0, (float)y0);\n-        }\n-\n-        @Override\n-        public void lineTo(double x1, double y1) {\n-            out.lineTo((float)x1, (float)y1);\n-        }\n-\n-        @Override\n-        public void closePath() {\n-            out.closePath();\n-        }\n-\n-        @Override\n-        public void pathDone() {\n-            out.pathDone();\n-        }\n-\n-        @Override\n-        public void curveTo(double x1, double y1,\n-                            double x2, double y2,\n-                            double x3, double y3)\n-        {\n-            out.curveTo((float)x1, (float)y1,\n-                    (float)x2, (float)y2,\n-                    (float)x3, (float)y3);\n-        }\n-\n-        @Override\n-        public void quadTo(double x1, double y1, double x2, double y2) {\n-            out.quadTo((float)x1, (float)y1, (float)x2, (float)y2);\n-        }\n-\n-        @Override\n-        public long getNativeConsumer() {\n-            throw new InternalError(\"Not using a native peer\");\n-        }\n-    }\n-}\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/marlin\/DRendererContext.java","additions":0,"deletions":282,"binary":false,"changes":282,"status":"deleted"},{"patch":"@@ -1,1329 +0,0 @@\n-\/*\n- * Copyright (c) 2007, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package sun.java2d.marlin;\n-\n-import java.util.Arrays;\n-import sun.java2d.marlin.DHelpers.PolyStack;\n-import sun.java2d.marlin.DTransformingPathConsumer2D.CurveBasicMonotonizer;\n-import sun.java2d.marlin.DTransformingPathConsumer2D.CurveClipSplitter;\n-\n-\/\/ TODO: some of the arithmetic here is too verbose and prone to hard to\n-\/\/ debug typos. We should consider making a small Point\/Vector class that\n-\/\/ has methods like plus(Point), minus(Point), dot(Point), cross(Point)and such\n-final class DStroker implements DPathConsumer2D, MarlinConst {\n-\n-    private static final int MOVE_TO = 0;\n-    private static final int DRAWING_OP_TO = 1; \/\/ ie. curve, line, or quad\n-    private static final int CLOSE = 2;\n-\n-    \/\/ round join threshold = 1 subpixel\n-    private static final double ERR_JOIN = (1.0f \/ MIN_SUBPIXELS);\n-    private static final double ROUND_JOIN_THRESHOLD = ERR_JOIN * ERR_JOIN;\n-\n-    \/\/ kappa = (4\/3) * (SQRT(2) - 1)\n-    private static final double C = (4.0d * (Math.sqrt(2.0d) - 1.0d) \/ 3.0d);\n-\n-    \/\/ SQRT(2)\n-    private static final double SQRT_2 = Math.sqrt(2.0d);\n-\n-    private DPathConsumer2D out;\n-\n-    private int capStyle;\n-    private int joinStyle;\n-\n-    private double lineWidth2;\n-    private double invHalfLineWidth2Sq;\n-\n-    private final double[] offset0 = new double[2];\n-    private final double[] offset1 = new double[2];\n-    private final double[] offset2 = new double[2];\n-    private final double[] miter = new double[2];\n-    private double miterLimitSq;\n-\n-    private int prev;\n-\n-    \/\/ The starting point of the path, and the slope there.\n-    private double sx0, sy0, sdx, sdy;\n-    \/\/ the current point and the slope there.\n-    private double cx0, cy0, cdx, cdy; \/\/ c stands for current\n-    \/\/ vectors that when added to (sx0,sy0) and (cx0,cy0) respectively yield the\n-    \/\/ first and last points on the left parallel path. Since this path is\n-    \/\/ parallel, it's slope at any point is parallel to the slope of the\n-    \/\/ original path (thought they may have different directions), so these\n-    \/\/ could be computed from sdx,sdy and cdx,cdy (and vice versa), but that\n-    \/\/ would be error prone and hard to read, so we keep these anyway.\n-    private double smx, smy, cmx, cmy;\n-\n-    private final PolyStack reverse;\n-\n-    private final double[] lp = new double[8];\n-    private final double[] rp = new double[8];\n-\n-    \/\/ per-thread renderer context\n-    final DRendererContext rdrCtx;\n-\n-    \/\/ dirty curve\n-    final DCurve curve;\n-\n-    \/\/ Bounds of the drawing region, at pixel precision.\n-    private double[] clipRect;\n-\n-    \/\/ the outcode of the current point\n-    private int cOutCode = 0;\n-\n-    \/\/ the outcode of the starting point\n-    private int sOutCode = 0;\n-\n-    \/\/ flag indicating if the path is opened (clipped)\n-    private boolean opened = false;\n-    \/\/ flag indicating if the starting point's cap is done\n-    private boolean capStart = false;\n-    \/\/ flag indicating to monotonize curves\n-    private boolean monotonize;\n-\n-    private boolean subdivide = false;\n-    private final CurveClipSplitter curveSplitter;\n-\n-    \/**\n-     * Constructs a <code>DStroker<\/code>.\n-     * @param rdrCtx per-thread renderer context\n-     *\/\n-    DStroker(final DRendererContext rdrCtx) {\n-        this.rdrCtx = rdrCtx;\n-\n-        this.reverse = (rdrCtx.stats != null) ?\n-            new PolyStack(rdrCtx,\n-                    rdrCtx.stats.stat_str_polystack_types,\n-                    rdrCtx.stats.stat_str_polystack_curves,\n-                    rdrCtx.stats.hist_str_polystack_curves,\n-                    rdrCtx.stats.stat_array_str_polystack_curves,\n-                    rdrCtx.stats.stat_array_str_polystack_types)\n-            : new PolyStack(rdrCtx);\n-\n-        this.curve = rdrCtx.curve;\n-        this.curveSplitter = rdrCtx.curveClipSplitter;\n-    }\n-\n-    \/**\n-     * Inits the <code>DStroker<\/code>.\n-     *\n-     * @param pc2d an output <code>DPathConsumer2D<\/code>.\n-     * @param lineWidth the desired line width in pixels\n-     * @param capStyle the desired end cap style, one of\n-     * <code>CAP_BUTT<\/code>, <code>CAP_ROUND<\/code> or\n-     * <code>CAP_SQUARE<\/code>.\n-     * @param joinStyle the desired line join style, one of\n-     * <code>JOIN_MITER<\/code>, <code>JOIN_ROUND<\/code> or\n-     * <code>JOIN_BEVEL<\/code>.\n-     * @param miterLimit the desired miter limit\n-     * @param subdivideCurves true to indicate to subdivide curves, false if dasher does\n-     * @return this instance\n-     *\/\n-    DStroker init(final DPathConsumer2D pc2d,\n-                  final double lineWidth,\n-                  final int capStyle,\n-                  final int joinStyle,\n-                  final double miterLimit,\n-                  final boolean subdivideCurves)\n-    {\n-        this.out = pc2d;\n-\n-        this.lineWidth2 = lineWidth \/ 2.0d;\n-        this.invHalfLineWidth2Sq = 1.0d \/ (2.0d * lineWidth2 * lineWidth2);\n-        this.monotonize = subdivideCurves;\n-\n-        this.capStyle = capStyle;\n-        this.joinStyle = joinStyle;\n-\n-        final double limit = miterLimit * lineWidth2;\n-        this.miterLimitSq = limit * limit;\n-\n-        this.prev = CLOSE;\n-\n-        rdrCtx.stroking = 1;\n-\n-        if (rdrCtx.doClip) {\n-            \/\/ Adjust the clipping rectangle with the stroker margin (miter limit, width)\n-            double margin = lineWidth2;\n-\n-            if (capStyle == CAP_SQUARE) {\n-                margin *= SQRT_2;\n-            }\n-            if ((joinStyle == JOIN_MITER) && (margin < limit)) {\n-                margin = limit;\n-            }\n-\n-            \/\/ bounds as half-open intervals: minX <= x < maxX and minY <= y < maxY\n-            \/\/ adjust clip rectangle (ymin, ymax, xmin, xmax):\n-            final double[] _clipRect = rdrCtx.clipRect;\n-            _clipRect[0] -= margin;\n-            _clipRect[1] += margin;\n-            _clipRect[2] -= margin;\n-            _clipRect[3] += margin;\n-            this.clipRect = _clipRect;\n-\n-            if (MarlinConst.DO_LOG_CLIP) {\n-                MarlinUtils.logInfo(\"clipRect (stroker): \"\n-                                    + Arrays.toString(rdrCtx.clipRect));\n-            }\n-\n-            \/\/ initialize curve splitter here for stroker & dasher:\n-            if (DO_CLIP_SUBDIVIDER) {\n-                subdivide = subdivideCurves;\n-                \/\/ adjust padded clip rectangle:\n-                curveSplitter.init();\n-            } else {\n-                subdivide = false;\n-            }\n-        } else {\n-            this.clipRect = null;\n-            this.cOutCode = 0;\n-            this.sOutCode = 0;\n-        }\n-        return this; \/\/ fluent API\n-    }\n-\n-    void disableClipping() {\n-        this.clipRect = null;\n-        this.cOutCode = 0;\n-        this.sOutCode = 0;\n-    }\n-\n-    \/**\n-     * Disposes this stroker:\n-     * clean up before reusing this instance\n-     *\/\n-    void dispose() {\n-        reverse.dispose();\n-\n-        opened   = false;\n-        capStart = false;\n-\n-        if (DO_CLEAN_DIRTY) {\n-            \/\/ Force zero-fill dirty arrays:\n-            Arrays.fill(offset0, 0.0d);\n-            Arrays.fill(offset1, 0.0d);\n-            Arrays.fill(offset2, 0.0d);\n-            Arrays.fill(miter, 0.0d);\n-            Arrays.fill(lp, 0.0d);\n-            Arrays.fill(rp, 0.0d);\n-        }\n-    }\n-\n-    private static void computeOffset(final double lx, final double ly,\n-                                      final double w, final double[] m)\n-    {\n-        double len = lx*lx + ly*ly;\n-        if (len == 0.0d) {\n-            m[0] = 0.0d;\n-            m[1] = 0.0d;\n-        } else {\n-            len = Math.sqrt(len);\n-            m[0] =  (ly * w) \/ len;\n-            m[1] = -(lx * w) \/ len;\n-        }\n-    }\n-\n-    \/\/ Returns true if the vectors (dx1, dy1) and (dx2, dy2) are\n-    \/\/ clockwise (if dx1,dy1 needs to be rotated clockwise to close\n-    \/\/ the smallest angle between it and dx2,dy2).\n-    \/\/ This is equivalent to detecting whether a point q is on the right side\n-    \/\/ of a line passing through points p1, p2 where p2 = p1+(dx1,dy1) and\n-    \/\/ q = p2+(dx2,dy2), which is the same as saying p1, p2, q are in a\n-    \/\/ clockwise order.\n-    \/\/ NOTE: \"clockwise\" here assumes coordinates with 0,0 at the bottom left.\n-    private static boolean isCW(final double dx1, final double dy1,\n-                                final double dx2, final double dy2)\n-    {\n-        return dx1 * dy2 <= dy1 * dx2;\n-    }\n-\n-    private void mayDrawRoundJoin(double cx, double cy,\n-                                  double omx, double omy,\n-                                  double mx, double my,\n-                                  boolean rev)\n-    {\n-        if ((omx == 0.0d && omy == 0.0d) || (mx == 0.0d && my == 0.0d)) {\n-            return;\n-        }\n-\n-        final double domx = omx - mx;\n-        final double domy = omy - my;\n-        final double lenSq = domx*domx + domy*domy;\n-\n-        if (lenSq < ROUND_JOIN_THRESHOLD) {\n-            return;\n-        }\n-\n-        if (rev) {\n-            omx = -omx;\n-            omy = -omy;\n-            mx  = -mx;\n-            my  = -my;\n-        }\n-        drawRoundJoin(cx, cy, omx, omy, mx, my, rev);\n-    }\n-\n-    private void drawRoundJoin(double cx, double cy,\n-                               double omx, double omy,\n-                               double mx, double my,\n-                               boolean rev)\n-    {\n-        \/\/ The sign of the dot product of mx,my and omx,omy is equal to the\n-        \/\/ the sign of the cosine of ext\n-        \/\/ (ext is the angle between omx,omy and mx,my).\n-        final double cosext = omx * mx + omy * my;\n-        \/\/ If it is >=0, we know that abs(ext) is <= 90 degrees, so we only\n-        \/\/ need 1 curve to approximate the circle section that joins omx,omy\n-        \/\/ and mx,my.\n-        if (cosext >= 0.0d) {\n-            drawBezApproxForArc(cx, cy, omx, omy, mx, my, rev);\n-        } else {\n-            \/\/ we need to split the arc into 2 arcs spanning the same angle.\n-            \/\/ The point we want will be one of the 2 intersections of the\n-            \/\/ perpendicular bisector of the chord (omx,omy)->(mx,my) and the\n-            \/\/ circle. We could find this by scaling the vector\n-            \/\/ (omx+mx, omy+my)\/2 so that it has length=lineWidth2 (and thus lies\n-            \/\/ on the circle), but that can have numerical problems when the angle\n-            \/\/ between omx,omy and mx,my is close to 180 degrees. So we compute a\n-            \/\/ normal of (omx,omy)-(mx,my). This will be the direction of the\n-            \/\/ perpendicular bisector. To get one of the intersections, we just scale\n-            \/\/ this vector that its length is lineWidth2 (this works because the\n-            \/\/ perpendicular bisector goes through the origin). This scaling doesn't\n-            \/\/ have numerical problems because we know that lineWidth2 divided by\n-            \/\/ this normal's length is at least 0.5 and at most sqrt(2)\/2 (because\n-            \/\/ we know the angle of the arc is > 90 degrees).\n-            double nx = my - omy, ny = omx - mx;\n-            double nlen = Math.sqrt(nx*nx + ny*ny);\n-            double scale = lineWidth2\/nlen;\n-            double mmx = nx * scale, mmy = ny * scale;\n-\n-            \/\/ if (isCW(omx, omy, mx, my) != isCW(mmx, mmy, mx, my)) then we've\n-            \/\/ computed the wrong intersection so we get the other one.\n-            \/\/ The test above is equivalent to if (rev).\n-            if (rev) {\n-                mmx = -mmx;\n-                mmy = -mmy;\n-            }\n-            drawBezApproxForArc(cx, cy, omx, omy, mmx, mmy, rev);\n-            drawBezApproxForArc(cx, cy, mmx, mmy, mx, my, rev);\n-        }\n-    }\n-\n-    \/\/ the input arc defined by omx,omy and mx,my must span <= 90 degrees.\n-    private void drawBezApproxForArc(final double cx, final double cy,\n-                                     final double omx, final double omy,\n-                                     final double mx, final double my,\n-                                     boolean rev)\n-    {\n-        final double cosext2 = (omx * mx + omy * my) * invHalfLineWidth2Sq;\n-\n-        \/\/ check round off errors producing cos(ext) > 1 and a NaN below\n-        \/\/ cos(ext) == 1 implies colinear segments and an empty join anyway\n-        if (cosext2 >= 0.5d) {\n-            \/\/ just return to avoid generating a flat curve:\n-            return;\n-        }\n-\n-        \/\/ cv is the length of P1-P0 and P2-P3 divided by the radius of the arc\n-        \/\/ (so, cv assumes the arc has radius 1). P0, P1, P2, P3 are the points that\n-        \/\/ define the bezier curve we're computing.\n-        \/\/ It is computed using the constraints that P1-P0 and P3-P2 are parallel\n-        \/\/ to the arc tangents at the endpoints, and that |P1-P0|=|P3-P2|.\n-        double cv = ((4.0d \/ 3.0d) * Math.sqrt(0.5d - cosext2) \/\n-                            (1.0d + Math.sqrt(cosext2 + 0.5d)));\n-        \/\/ if clockwise, we need to negate cv.\n-        if (rev) { \/\/ rev is equivalent to isCW(omx, omy, mx, my)\n-            cv = -cv;\n-        }\n-        final double x1 = cx + omx;\n-        final double y1 = cy + omy;\n-        final double x2 = x1 - cv * omy;\n-        final double y2 = y1 + cv * omx;\n-\n-        final double x4 = cx + mx;\n-        final double y4 = cy + my;\n-        final double x3 = x4 + cv * my;\n-        final double y3 = y4 - cv * mx;\n-\n-        emitCurveTo(x1, y1, x2, y2, x3, y3, x4, y4, rev);\n-    }\n-\n-    private void drawRoundCap(double cx, double cy, double mx, double my) {\n-        final double Cmx = C * mx;\n-        final double Cmy = C * my;\n-        emitCurveTo(cx + mx - Cmy, cy + my + Cmx,\n-                    cx - my + Cmx, cy + mx + Cmy,\n-                    cx - my,       cy + mx);\n-        emitCurveTo(cx - my - Cmx, cy + mx - Cmy,\n-                    cx - mx - Cmy, cy - my + Cmx,\n-                    cx - mx,       cy - my);\n-    }\n-\n-    \/\/ Return the intersection point of the lines (x0, y0) -> (x1, y1)\n-    \/\/ and (x0p, y0p) -> (x1p, y1p) in m[off] and m[off+1]\n-    private static void computeMiter(final double x0, final double y0,\n-                                     final double x1, final double y1,\n-                                     final double x0p, final double y0p,\n-                                     final double x1p, final double y1p,\n-                                     final double[] m)\n-    {\n-        double x10 = x1 - x0;\n-        double y10 = y1 - y0;\n-        double x10p = x1p - x0p;\n-        double y10p = y1p - y0p;\n-\n-        \/\/ if this is 0, the lines are parallel. If they go in the\n-        \/\/ same direction, there is no intersection so m[off] and\n-        \/\/ m[off+1] will contain infinity, so no miter will be drawn.\n-        \/\/ If they go in the same direction that means that the start of the\n-        \/\/ current segment and the end of the previous segment have the same\n-        \/\/ tangent, in which case this method won't even be involved in\n-        \/\/ miter drawing because it won't be called by drawMiter (because\n-        \/\/ (mx == omx && my == omy) will be true, and drawMiter will return\n-        \/\/ immediately).\n-        double den = x10*y10p - x10p*y10;\n-        double t = x10p*(y0-y0p) - y10p*(x0-x0p);\n-        t \/= den;\n-        m[0] = x0 + t*x10;\n-        m[1] = y0 + t*y10;\n-    }\n-\n-    \/\/ Return the intersection point of the lines (x0, y0) -> (x1, y1)\n-    \/\/ and (x0p, y0p) -> (x1p, y1p) in m[off] and m[off+1]\n-    private static void safeComputeMiter(final double x0, final double y0,\n-                                         final double x1, final double y1,\n-                                         final double x0p, final double y0p,\n-                                         final double x1p, final double y1p,\n-                                         final double[] m)\n-    {\n-        double x10 = x1 - x0;\n-        double y10 = y1 - y0;\n-        double x10p = x1p - x0p;\n-        double y10p = y1p - y0p;\n-\n-        \/\/ if this is 0, the lines are parallel. If they go in the\n-        \/\/ same direction, there is no intersection so m[off] and\n-        \/\/ m[off+1] will contain infinity, so no miter will be drawn.\n-        \/\/ If they go in the same direction that means that the start of the\n-        \/\/ current segment and the end of the previous segment have the same\n-        \/\/ tangent, in which case this method won't even be involved in\n-        \/\/ miter drawing because it won't be called by drawMiter (because\n-        \/\/ (mx == omx && my == omy) will be true, and drawMiter will return\n-        \/\/ immediately).\n-        double den = x10*y10p - x10p*y10;\n-        if (den == 0.0d) {\n-            m[2] = (x0 + x0p) \/ 2.0d;\n-            m[3] = (y0 + y0p) \/ 2.0d;\n-        } else {\n-            double t = x10p*(y0-y0p) - y10p*(x0-x0p);\n-            t \/= den;\n-            m[2] = x0 + t*x10;\n-            m[3] = y0 + t*y10;\n-        }\n-    }\n-\n-    private void drawMiter(final double pdx, final double pdy,\n-                           final double x0, final double y0,\n-                           final double dx, final double dy,\n-                           double omx, double omy,\n-                           double mx, double my,\n-                           boolean rev)\n-    {\n-        if ((mx == omx && my == omy) ||\n-            (pdx == 0.0d && pdy == 0.0d) ||\n-            (dx == 0.0d && dy == 0.0d))\n-        {\n-            return;\n-        }\n-\n-        if (rev) {\n-            omx = -omx;\n-            omy = -omy;\n-            mx  = -mx;\n-            my  = -my;\n-        }\n-\n-        computeMiter((x0 - pdx) + omx, (y0 - pdy) + omy, x0 + omx, y0 + omy,\n-                     (dx + x0) + mx, (dy + y0) + my, x0 + mx, y0 + my, miter);\n-\n-        final double miterX = miter[0];\n-        final double miterY = miter[1];\n-        double lenSq = (miterX-x0)*(miterX-x0) + (miterY-y0)*(miterY-y0);\n-\n-        \/\/ If the lines are parallel, lenSq will be either NaN or +inf\n-        \/\/ (actually, I'm not sure if the latter is possible. The important\n-        \/\/ thing is that -inf is not possible, because lenSq is a square).\n-        \/\/ For both of those values, the comparison below will fail and\n-        \/\/ no miter will be drawn, which is correct.\n-        if (lenSq < miterLimitSq) {\n-            emitLineTo(miterX, miterY, rev);\n-        }\n-    }\n-\n-    @Override\n-    public void moveTo(final double x0, final double y0) {\n-        _moveTo(x0, y0, cOutCode);\n-        \/\/ update starting point:\n-        this.sx0 = x0;\n-        this.sy0 = y0;\n-        this.sdx = 1.0d;\n-        this.sdy = 0.0d;\n-        this.opened   = false;\n-        this.capStart = false;\n-\n-        if (clipRect != null) {\n-            final int outcode = DHelpers.outcode(x0, y0, clipRect);\n-            this.cOutCode = outcode;\n-            this.sOutCode = outcode;\n-        }\n-    }\n-\n-    private void _moveTo(final double x0, final double y0,\n-                        final int outcode)\n-    {\n-        if (prev == MOVE_TO) {\n-            this.cx0 = x0;\n-            this.cy0 = y0;\n-        } else {\n-            if (prev == DRAWING_OP_TO) {\n-                finish(outcode);\n-            }\n-            this.prev = MOVE_TO;\n-            this.cx0 = x0;\n-            this.cy0 = y0;\n-            this.cdx = 1.0d;\n-            this.cdy = 0.0d;\n-        }\n-    }\n-\n-    @Override\n-    public void lineTo(final double x1, final double y1) {\n-        lineTo(x1, y1, false);\n-    }\n-\n-    private void lineTo(final double x1, final double y1,\n-                        final boolean force)\n-    {\n-        final int outcode0 = this.cOutCode;\n-\n-        if (!force && clipRect != null) {\n-            final int outcode1 = DHelpers.outcode(x1, y1, clipRect);\n-\n-            \/\/ Should clip\n-            final int orCode = (outcode0 | outcode1);\n-            if (orCode != 0) {\n-                final int sideCode = outcode0 & outcode1;\n-\n-                \/\/ basic rejection criteria:\n-                if (sideCode == 0) {\n-                    \/\/ overlap clip:\n-                    if (subdivide) {\n-                        \/\/ avoid reentrance\n-                        subdivide = false;\n-                        \/\/ subdivide curve => callback with subdivided parts:\n-                        boolean ret = curveSplitter.splitLine(cx0, cy0, x1, y1,\n-                                                              orCode, this);\n-                        \/\/ reentrance is done:\n-                        subdivide = true;\n-                        if (ret) {\n-                            return;\n-                        }\n-                    }\n-                    \/\/ already subdivided so render it\n-                } else {\n-                    this.cOutCode = outcode1;\n-                    _moveTo(x1, y1, outcode0);\n-                    opened = true;\n-                    return;\n-                }\n-            }\n-\n-            this.cOutCode = outcode1;\n-        }\n-\n-        double dx = x1 - cx0;\n-        double dy = y1 - cy0;\n-        if (dx == 0.0d && dy == 0.0d) {\n-            dx = 1.0d;\n-        }\n-        computeOffset(dx, dy, lineWidth2, offset0);\n-        final double mx = offset0[0];\n-        final double my = offset0[1];\n-\n-        drawJoin(cdx, cdy, cx0, cy0, dx, dy, cmx, cmy, mx, my, outcode0);\n-\n-        emitLineTo(cx0 + mx, cy0 + my);\n-        emitLineTo( x1 + mx,  y1 + my);\n-\n-        emitLineToRev(cx0 - mx, cy0 - my);\n-        emitLineToRev( x1 - mx,  y1 - my);\n-\n-        this.prev = DRAWING_OP_TO;\n-        this.cx0 = x1;\n-        this.cy0 = y1;\n-        this.cdx = dx;\n-        this.cdy = dy;\n-        this.cmx = mx;\n-        this.cmy = my;\n-    }\n-\n-    @Override\n-    public void closePath() {\n-        \/\/ distinguish empty path at all vs opened path ?\n-        if (prev != DRAWING_OP_TO && !opened) {\n-            if (prev == CLOSE) {\n-                return;\n-            }\n-            emitMoveTo(cx0, cy0 - lineWidth2);\n-\n-            this.sdx = 1.0d;\n-            this.sdy = 0.0d;\n-            this.cdx = 1.0d;\n-            this.cdy = 0.0d;\n-\n-            this.smx = 0.0d;\n-            this.smy = -lineWidth2;\n-            this.cmx = 0.0d;\n-            this.cmy = -lineWidth2;\n-\n-            finish(cOutCode);\n-            return;\n-        }\n-\n-        \/\/ basic acceptance criteria\n-        if ((sOutCode & cOutCode) == 0) {\n-            if (cx0 != sx0 || cy0 != sy0) {\n-                lineTo(sx0, sy0, true);\n-            }\n-\n-            drawJoin(cdx, cdy, cx0, cy0, sdx, sdy, cmx, cmy, smx, smy, sOutCode);\n-\n-            emitLineTo(sx0 + smx, sy0 + smy);\n-\n-            if (opened) {\n-                emitLineTo(sx0 - smx, sy0 - smy);\n-            } else {\n-                emitMoveTo(sx0 - smx, sy0 - smy);\n-            }\n-        }\n-        \/\/ Ignore caps like finish(false)\n-        emitReverse();\n-\n-        this.prev = CLOSE;\n-        this.cx0 = sx0;\n-        this.cy0 = sy0;\n-        this.cOutCode = sOutCode;\n-\n-        if (opened) {\n-            \/\/ do not emit close\n-            opened = false;\n-        } else {\n-            emitClose();\n-        }\n-    }\n-\n-    private void emitReverse() {\n-        reverse.popAll(out);\n-    }\n-\n-    @Override\n-    public void pathDone() {\n-        if (prev == DRAWING_OP_TO) {\n-            finish(cOutCode);\n-        }\n-\n-        out.pathDone();\n-\n-        \/\/ this shouldn't matter since this object won't be used\n-        \/\/ after the call to this method.\n-        this.prev = CLOSE;\n-\n-        \/\/ Dispose this instance:\n-        dispose();\n-    }\n-\n-    private void finish(final int outcode) {\n-        \/\/ Problem: impossible to guess if the path will be closed in advance\n-        \/\/          i.e. if caps must be drawn or not ?\n-        \/\/ Solution: use the ClosedPathDetector before Stroker to determine\n-        \/\/ if the path is a closed path or not\n-        if (rdrCtx.closedPath) {\n-            emitReverse();\n-        } else {\n-            if (outcode == 0) {\n-                \/\/ current point = end's cap:\n-                if (capStyle == CAP_ROUND) {\n-                    drawRoundCap(cx0, cy0, cmx, cmy);\n-                } else if (capStyle == CAP_SQUARE) {\n-                    emitLineTo(cx0 - cmy + cmx, cy0 + cmx + cmy);\n-                    emitLineTo(cx0 - cmy - cmx, cy0 + cmx - cmy);\n-                }\n-            }\n-            emitReverse();\n-\n-            if (!capStart) {\n-                capStart = true;\n-\n-                if (sOutCode == 0) {\n-                    \/\/ starting point = initial cap:\n-                    if (capStyle == CAP_ROUND) {\n-                        drawRoundCap(sx0, sy0, -smx, -smy);\n-                    } else if (capStyle == CAP_SQUARE) {\n-                        emitLineTo(sx0 + smy - smx, sy0 - smx - smy);\n-                        emitLineTo(sx0 + smy + smx, sy0 - smx + smy);\n-                    }\n-                }\n-            }\n-        }\n-        emitClose();\n-    }\n-\n-    private void emitMoveTo(final double x0, final double y0) {\n-        out.moveTo(x0, y0);\n-    }\n-\n-    private void emitLineTo(final double x1, final double y1) {\n-        out.lineTo(x1, y1);\n-    }\n-\n-    private void emitLineToRev(final double x1, final double y1) {\n-        reverse.pushLine(x1, y1);\n-    }\n-\n-    private void emitLineTo(final double x1, final double y1,\n-                            final boolean rev)\n-    {\n-        if (rev) {\n-            emitLineToRev(x1, y1);\n-        } else {\n-            emitLineTo(x1, y1);\n-        }\n-    }\n-\n-    private void emitQuadTo(final double x1, final double y1,\n-                            final double x2, final double y2)\n-    {\n-        out.quadTo(x1, y1, x2, y2);\n-    }\n-\n-    private void emitQuadToRev(final double x0, final double y0,\n-                               final double x1, final double y1)\n-    {\n-        reverse.pushQuad(x0, y0, x1, y1);\n-    }\n-\n-    private void emitCurveTo(final double x1, final double y1,\n-                             final double x2, final double y2,\n-                             final double x3, final double y3)\n-    {\n-        out.curveTo(x1, y1, x2, y2, x3, y3);\n-    }\n-\n-    private void emitCurveToRev(final double x0, final double y0,\n-                                final double x1, final double y1,\n-                                final double x2, final double y2)\n-    {\n-        reverse.pushCubic(x0, y0, x1, y1, x2, y2);\n-    }\n-\n-    private void emitCurveTo(final double x0, final double y0,\n-                             final double x1, final double y1,\n-                             final double x2, final double y2,\n-                             final double x3, final double y3, final boolean rev)\n-    {\n-        if (rev) {\n-            reverse.pushCubic(x0, y0, x1, y1, x2, y2);\n-        } else {\n-            out.curveTo(x1, y1, x2, y2, x3, y3);\n-        }\n-    }\n-\n-    private void emitClose() {\n-        out.closePath();\n-    }\n-\n-    private void drawJoin(double pdx, double pdy,\n-                          double x0, double y0,\n-                          double dx, double dy,\n-                          double omx, double omy,\n-                          double mx, double my,\n-                          final int outcode)\n-    {\n-        if (prev != DRAWING_OP_TO) {\n-            emitMoveTo(x0 + mx, y0 + my);\n-            if (!opened) {\n-                this.sdx = dx;\n-                this.sdy = dy;\n-                this.smx = mx;\n-                this.smy = my;\n-            }\n-        } else {\n-            final boolean cw = isCW(pdx, pdy, dx, dy);\n-            if (outcode == 0) {\n-                if (joinStyle == JOIN_MITER) {\n-                    drawMiter(pdx, pdy, x0, y0, dx, dy, omx, omy, mx, my, cw);\n-                } else if (joinStyle == JOIN_ROUND) {\n-                    mayDrawRoundJoin(x0, y0, omx, omy, mx, my, cw);\n-                }\n-            }\n-            emitLineTo(x0, y0, !cw);\n-        }\n-        prev = DRAWING_OP_TO;\n-    }\n-\n-    private static boolean within(final double x1, final double y1,\n-                                  final double x2, final double y2,\n-                                  final double err)\n-    {\n-        assert err > 0 : \"\";\n-        \/\/ compare taxicab distance. ERR will always be small, so using\n-        \/\/ true distance won't give much benefit\n-        return (DHelpers.within(x1, x2, err) && \/\/ we want to avoid calling Math.abs\n-                DHelpers.within(y1, y2, err));  \/\/ this is just as good.\n-    }\n-\n-    private void getLineOffsets(final double x1, final double y1,\n-                                final double x2, final double y2,\n-                                final double[] left, final double[] right)\n-    {\n-        computeOffset(x2 - x1, y2 - y1, lineWidth2, offset0);\n-        final double mx = offset0[0];\n-        final double my = offset0[1];\n-        left[0] = x1 + mx;\n-        left[1] = y1 + my;\n-        left[2] = x2 + mx;\n-        left[3] = y2 + my;\n-\n-        right[0] = x1 - mx;\n-        right[1] = y1 - my;\n-        right[2] = x2 - mx;\n-        right[3] = y2 - my;\n-    }\n-\n-    private int computeOffsetCubic(final double[] pts, final int off,\n-                                   final double[] leftOff,\n-                                   final double[] rightOff)\n-    {\n-        \/\/ if p1=p2 or p3=p4 it means that the derivative at the endpoint\n-        \/\/ vanishes, which creates problems with computeOffset. Usually\n-        \/\/ this happens when this stroker object is trying to widen\n-        \/\/ a curve with a cusp. What happens is that curveTo splits\n-        \/\/ the input curve at the cusp, and passes it to this function.\n-        \/\/ because of inaccuracies in the splitting, we consider points\n-        \/\/ equal if they're very close to each other.\n-        final double x1 = pts[off    ], y1 = pts[off + 1];\n-        final double x2 = pts[off + 2], y2 = pts[off + 3];\n-        final double x3 = pts[off + 4], y3 = pts[off + 5];\n-        final double x4 = pts[off + 6], y4 = pts[off + 7];\n-\n-        double dx4 = x4 - x3;\n-        double dy4 = y4 - y3;\n-        double dx1 = x2 - x1;\n-        double dy1 = y2 - y1;\n-\n-        \/\/ if p1 == p2 && p3 == p4: draw line from p1->p4, unless p1 == p4,\n-        \/\/ in which case ignore if p1 == p2\n-        final boolean p1eqp2 = within(x1, y1, x2, y2, 6.0d * Math.ulp(y2));\n-        final boolean p3eqp4 = within(x3, y3, x4, y4, 6.0d * Math.ulp(y4));\n-\n-        if (p1eqp2 && p3eqp4) {\n-            getLineOffsets(x1, y1, x4, y4, leftOff, rightOff);\n-            return 4;\n-        } else if (p1eqp2) {\n-            dx1 = x3 - x1;\n-            dy1 = y3 - y1;\n-        } else if (p3eqp4) {\n-            dx4 = x4 - x2;\n-            dy4 = y4 - y2;\n-        }\n-\n-        \/\/ if p2-p1 and p4-p3 are parallel, that must mean this curve is a line\n-        double dotsq = (dx1 * dx4 + dy1 * dy4);\n-        dotsq *= dotsq;\n-        double l1sq = dx1 * dx1 + dy1 * dy1, l4sq = dx4 * dx4 + dy4 * dy4;\n-\n-        if (DHelpers.within(dotsq, l1sq * l4sq, 4.0d * Math.ulp(dotsq))) {\n-            getLineOffsets(x1, y1, x4, y4, leftOff, rightOff);\n-            return 4;\n-        }\n-\n-\/\/      What we're trying to do in this function is to approximate an ideal\n-\/\/      offset curve (call it I) of the input curve B using a bezier curve Bp.\n-\/\/      The constraints I use to get the equations are:\n-\/\/\n-\/\/      1. The computed curve Bp should go through I(0) and I(1). These are\n-\/\/      x1p, y1p, x4p, y4p, which are p1p and p4p. We still need to find\n-\/\/      4 variables: the x and y components of p2p and p3p (i.e. x2p, y2p, x3p, y3p).\n-\/\/\n-\/\/      2. Bp should have slope equal in absolute value to I at the endpoints. So,\n-\/\/      (by the way, the operator || in the comments below means \"aligned with\".\n-\/\/      It is defined on vectors, so when we say I'(0) || Bp'(0) we mean that\n-\/\/      vectors I'(0) and Bp'(0) are aligned, which is the same as saying\n-\/\/      that the tangent lines of I and Bp at 0 are parallel. Mathematically\n-\/\/      this means (I'(t) || Bp'(t)) <==> (I'(t) = c * Bp'(t)) where c is some\n-\/\/      nonzero constant.)\n-\/\/      I'(0) || Bp'(0) and I'(1) || Bp'(1). Obviously, I'(0) || B'(0) and\n-\/\/      I'(1) || B'(1); therefore, Bp'(0) || B'(0) and Bp'(1) || B'(1).\n-\/\/      We know that Bp'(0) || (p2p-p1p) and Bp'(1) || (p4p-p3p) and the same\n-\/\/      is true for any bezier curve; therefore, we get the equations\n-\/\/          (1) p2p = c1 * (p2-p1) + p1p\n-\/\/          (2) p3p = c2 * (p4-p3) + p4p\n-\/\/      We know p1p, p4p, p2, p1, p3, and p4; therefore, this reduces the number\n-\/\/      of unknowns from 4 to 2 (i.e. just c1 and c2).\n-\/\/      To eliminate these 2 unknowns we use the following constraint:\n-\/\/\n-\/\/      3. Bp(0.5) == I(0.5). Bp(0.5)=(x,y) and I(0.5)=(xi,yi), and I should note\n-\/\/      that I(0.5) is *the only* reason for computing dxm,dym. This gives us\n-\/\/          (3) Bp(0.5) = (p1p + 3 * (p2p + p3p) + p4p)\/8, which is equivalent to\n-\/\/          (4) p2p + p3p = (Bp(0.5)*8 - p1p - p4p) \/ 3\n-\/\/      We can substitute (1) and (2) from above into (4) and we get:\n-\/\/          (5) c1*(p2-p1) + c2*(p4-p3) = (Bp(0.5)*8 - p1p - p4p)\/3 - p1p - p4p\n-\/\/      which is equivalent to\n-\/\/          (6) c1*(p2-p1) + c2*(p4-p3) = (4\/3) * (Bp(0.5) * 2 - p1p - p4p)\n-\/\/\n-\/\/      The right side of this is a 2D vector, and we know I(0.5), which gives us\n-\/\/      Bp(0.5), which gives us the value of the right side.\n-\/\/      The left side is just a matrix vector multiplication in disguise. It is\n-\/\/\n-\/\/      [x2-x1, x4-x3][c1]\n-\/\/      [y2-y1, y4-y3][c2]\n-\/\/      which, is equal to\n-\/\/      [dx1, dx4][c1]\n-\/\/      [dy1, dy4][c2]\n-\/\/      At this point we are left with a simple linear system and we solve it by\n-\/\/      getting the inverse of the matrix above. Then we use [c1,c2] to compute\n-\/\/      p2p and p3p.\n-\n-        double x = (x1 + 3.0d * (x2 + x3) + x4) \/ 8.0d;\n-        double y = (y1 + 3.0d * (y2 + y3) + y4) \/ 8.0d;\n-        \/\/ (dxm,dym) is some tangent of B at t=0.5. This means it's equal to\n-        \/\/ c*B'(0.5) for some constant c.\n-        double dxm = x3 + x4 - x1 - x2, dym = y3 + y4 - y1 - y2;\n-\n-        \/\/ this computes the offsets at t=0, 0.5, 1, using the property that\n-        \/\/ for any bezier curve the vectors p2-p1 and p4-p3 are parallel to\n-        \/\/ the (dx\/dt, dy\/dt) vectors at the endpoints.\n-        computeOffset(dx1, dy1, lineWidth2, offset0);\n-        computeOffset(dxm, dym, lineWidth2, offset1);\n-        computeOffset(dx4, dy4, lineWidth2, offset2);\n-        double x1p = x1 + offset0[0]; \/\/ start\n-        double y1p = y1 + offset0[1]; \/\/ point\n-        double xi  = x  + offset1[0]; \/\/ interpolation\n-        double yi  = y  + offset1[1]; \/\/ point\n-        double x4p = x4 + offset2[0]; \/\/ end\n-        double y4p = y4 + offset2[1]; \/\/ point\n-\n-        double invdet43 = 4.0d \/ (3.0d * (dx1 * dy4 - dy1 * dx4));\n-\n-        double two_pi_m_p1_m_p4x = 2.0d * xi - x1p - x4p;\n-        double two_pi_m_p1_m_p4y = 2.0d * yi - y1p - y4p;\n-        double c1 = invdet43 * (dy4 * two_pi_m_p1_m_p4x - dx4 * two_pi_m_p1_m_p4y);\n-        double c2 = invdet43 * (dx1 * two_pi_m_p1_m_p4y - dy1 * two_pi_m_p1_m_p4x);\n-\n-        double x2p, y2p, x3p, y3p;\n-        x2p = x1p + c1*dx1;\n-        y2p = y1p + c1*dy1;\n-        x3p = x4p + c2*dx4;\n-        y3p = y4p + c2*dy4;\n-\n-        leftOff[0] = x1p; leftOff[1] = y1p;\n-        leftOff[2] = x2p; leftOff[3] = y2p;\n-        leftOff[4] = x3p; leftOff[5] = y3p;\n-        leftOff[6] = x4p; leftOff[7] = y4p;\n-\n-        x1p = x1 - offset0[0]; y1p = y1 - offset0[1];\n-        xi = xi - 2.0d * offset1[0]; yi = yi - 2.0d * offset1[1];\n-        x4p = x4 - offset2[0]; y4p = y4 - offset2[1];\n-\n-        two_pi_m_p1_m_p4x = 2.0d * xi - x1p - x4p;\n-        two_pi_m_p1_m_p4y = 2.0d * yi - y1p - y4p;\n-        c1 = invdet43 * (dy4 * two_pi_m_p1_m_p4x - dx4 * two_pi_m_p1_m_p4y);\n-        c2 = invdet43 * (dx1 * two_pi_m_p1_m_p4y - dy1 * two_pi_m_p1_m_p4x);\n-\n-        x2p = x1p + c1*dx1;\n-        y2p = y1p + c1*dy1;\n-        x3p = x4p + c2*dx4;\n-        y3p = y4p + c2*dy4;\n-\n-        rightOff[0] = x1p; rightOff[1] = y1p;\n-        rightOff[2] = x2p; rightOff[3] = y2p;\n-        rightOff[4] = x3p; rightOff[5] = y3p;\n-        rightOff[6] = x4p; rightOff[7] = y4p;\n-        return 8;\n-    }\n-\n-    \/\/ compute offset curves using bezier spline through t=0.5 (i.e.\n-    \/\/ ComputedCurve(0.5) == IdealParallelCurve(0.5))\n-    \/\/ return the kind of curve in the right and left arrays.\n-    private int computeOffsetQuad(final double[] pts, final int off,\n-                                  final double[] leftOff,\n-                                  final double[] rightOff)\n-    {\n-        final double x1 = pts[off    ], y1 = pts[off + 1];\n-        final double x2 = pts[off + 2], y2 = pts[off + 3];\n-        final double x3 = pts[off + 4], y3 = pts[off + 5];\n-\n-        final double dx3 = x3 - x2;\n-        final double dy3 = y3 - y2;\n-        final double dx1 = x2 - x1;\n-        final double dy1 = y2 - y1;\n-\n-        \/\/ if p1=p2 or p3=p4 it means that the derivative at the endpoint\n-        \/\/ vanishes, which creates problems with computeOffset. Usually\n-        \/\/ this happens when this stroker object is trying to widen\n-        \/\/ a curve with a cusp. What happens is that curveTo splits\n-        \/\/ the input curve at the cusp, and passes it to this function.\n-        \/\/ because of inaccuracies in the splitting, we consider points\n-        \/\/ equal if they're very close to each other.\n-\n-        \/\/ if p1 == p2 && p3 == p4: draw line from p1->p4, unless p1 == p4,\n-        \/\/ in which case ignore.\n-        final boolean p1eqp2 = within(x1, y1, x2, y2, 6.0d * Math.ulp(y2));\n-        final boolean p2eqp3 = within(x2, y2, x3, y3, 6.0d * Math.ulp(y3));\n-\n-        if (p1eqp2 || p2eqp3) {\n-            getLineOffsets(x1, y1, x3, y3, leftOff, rightOff);\n-            return 4;\n-        }\n-\n-        \/\/ if p2-p1 and p4-p3 are parallel, that must mean this curve is a line\n-        double dotsq = (dx1 * dx3 + dy1 * dy3);\n-        dotsq *= dotsq;\n-        double l1sq = dx1 * dx1 + dy1 * dy1, l3sq = dx3 * dx3 + dy3 * dy3;\n-\n-        if (DHelpers.within(dotsq, l1sq * l3sq, 4.0d * Math.ulp(dotsq))) {\n-            getLineOffsets(x1, y1, x3, y3, leftOff, rightOff);\n-            return 4;\n-        }\n-\n-        \/\/ this computes the offsets at t=0, 0.5, 1, using the property that\n-        \/\/ for any bezier curve the vectors p2-p1 and p4-p3 are parallel to\n-        \/\/ the (dx\/dt, dy\/dt) vectors at the endpoints.\n-        computeOffset(dx1, dy1, lineWidth2, offset0);\n-        computeOffset(dx3, dy3, lineWidth2, offset1);\n-\n-        double x1p = x1 + offset0[0]; \/\/ start\n-        double y1p = y1 + offset0[1]; \/\/ point\n-        double x3p = x3 + offset1[0]; \/\/ end\n-        double y3p = y3 + offset1[1]; \/\/ point\n-        safeComputeMiter(x1p, y1p, x1p+dx1, y1p+dy1, x3p, y3p, x3p-dx3, y3p-dy3, leftOff);\n-        leftOff[0] = x1p; leftOff[1] = y1p;\n-        leftOff[4] = x3p; leftOff[5] = y3p;\n-\n-        x1p = x1 - offset0[0]; y1p = y1 - offset0[1];\n-        x3p = x3 - offset1[0]; y3p = y3 - offset1[1];\n-        safeComputeMiter(x1p, y1p, x1p+dx1, y1p+dy1, x3p, y3p, x3p-dx3, y3p-dy3, rightOff);\n-        rightOff[0] = x1p; rightOff[1] = y1p;\n-        rightOff[4] = x3p; rightOff[5] = y3p;\n-        return 6;\n-    }\n-\n-    @Override\n-    public void curveTo(final double x1, final double y1,\n-                        final double x2, final double y2,\n-                        final double x3, final double y3)\n-    {\n-        final int outcode0 = this.cOutCode;\n-\n-        if (clipRect != null) {\n-            final int outcode1 = DHelpers.outcode(x1, y1, clipRect);\n-            final int outcode2 = DHelpers.outcode(x2, y2, clipRect);\n-            final int outcode3 = DHelpers.outcode(x3, y3, clipRect);\n-\n-            \/\/ Should clip\n-            final int orCode = (outcode0 | outcode1 | outcode2 | outcode3);\n-            if (orCode != 0) {\n-                final int sideCode = outcode0 & outcode1 & outcode2 & outcode3;\n-\n-                \/\/ basic rejection criteria:\n-                if (sideCode == 0) {\n-                    \/\/ overlap clip:\n-                    if (subdivide) {\n-                        \/\/ avoid reentrance\n-                        subdivide = false;\n-                        \/\/ subdivide curve => callback with subdivided parts:\n-                        boolean ret = curveSplitter.splitCurve(cx0, cy0, x1, y1,\n-                                                               x2, y2, x3, y3,\n-                                                               orCode, this);\n-                        \/\/ reentrance is done:\n-                        subdivide = true;\n-                        if (ret) {\n-                            return;\n-                        }\n-                    }\n-                    \/\/ already subdivided so render it\n-                } else {\n-                    this.cOutCode = outcode3;\n-                    _moveTo(x3, y3, outcode0);\n-                    opened = true;\n-                    return;\n-                }\n-            }\n-\n-            this.cOutCode = outcode3;\n-        }\n-        _curveTo(x1, y1, x2, y2, x3, y3, outcode0);\n-    }\n-\n-    private void _curveTo(final double x1, final double y1,\n-                          final double x2, final double y2,\n-                          final double x3, final double y3,\n-                          final int outcode0)\n-    {\n-        \/\/ need these so we can update the state at the end of this method\n-        double dxs = x1 - cx0;\n-        double dys = y1 - cy0;\n-        double dxf = x3 - x2;\n-        double dyf = y3 - y2;\n-\n-        if ((dxs == 0.0d) && (dys == 0.0d)) {\n-            dxs = x2 - cx0;\n-            dys = y2 - cy0;\n-            if ((dxs == 0.0d) && (dys == 0.0d)) {\n-                dxs = x3 - cx0;\n-                dys = y3 - cy0;\n-            }\n-        }\n-        if ((dxf == 0.0d) && (dyf == 0.0d)) {\n-            dxf = x3 - x1;\n-            dyf = y3 - y1;\n-            if ((dxf == 0.0d) && (dyf == 0.0d)) {\n-                dxf = x3 - cx0;\n-                dyf = y3 - cy0;\n-            }\n-        }\n-        if ((dxs == 0.0d) && (dys == 0.0d)) {\n-            \/\/ this happens if the \"curve\" is just a point\n-            \/\/ fix outcode0 for lineTo() call:\n-            if (clipRect != null) {\n-                this.cOutCode = outcode0;\n-            }\n-            lineTo(cx0, cy0);\n-            return;\n-        }\n-\n-        \/\/ if these vectors are too small, normalize them, to avoid future\n-        \/\/ precision problems.\n-        if (Math.abs(dxs) < 0.1d && Math.abs(dys) < 0.1d) {\n-            final double len = Math.sqrt(dxs * dxs + dys * dys);\n-            dxs \/= len;\n-            dys \/= len;\n-        }\n-        if (Math.abs(dxf) < 0.1d && Math.abs(dyf) < 0.1d) {\n-            final double len = Math.sqrt(dxf * dxf + dyf * dyf);\n-            dxf \/= len;\n-            dyf \/= len;\n-        }\n-\n-        computeOffset(dxs, dys, lineWidth2, offset0);\n-        drawJoin(cdx, cdy, cx0, cy0, dxs, dys, cmx, cmy, offset0[0], offset0[1], outcode0);\n-\n-        int nSplits = 0;\n-        final double[] mid;\n-        final double[] l = lp;\n-\n-        if (monotonize) {\n-            \/\/ monotonize curve:\n-            final CurveBasicMonotonizer monotonizer\n-                = rdrCtx.monotonizer.curve(cx0, cy0, x1, y1, x2, y2, x3, y3);\n-\n-            nSplits = monotonizer.nbSplits;\n-            mid = monotonizer.middle;\n-        } else {\n-            \/\/ use left instead:\n-            mid = l;\n-            mid[0] = cx0; mid[1] = cy0;\n-            mid[2] = x1;  mid[3] = y1;\n-            mid[4] = x2;  mid[5] = y2;\n-            mid[6] = x3;  mid[7] = y3;\n-        }\n-        final double[] r = rp;\n-\n-        int kind = 0;\n-        for (int i = 0, off = 0; i <= nSplits; i++, off += 6) {\n-            kind = computeOffsetCubic(mid, off, l, r);\n-\n-            emitLineTo(l[0], l[1]);\n-\n-            switch(kind) {\n-            case 8:\n-                emitCurveTo(l[2], l[3], l[4], l[5], l[6], l[7]);\n-                emitCurveToRev(r[0], r[1], r[2], r[3], r[4], r[5]);\n-                break;\n-            case 4:\n-                emitLineTo(l[2], l[3]);\n-                emitLineToRev(r[0], r[1]);\n-                break;\n-            default:\n-            }\n-            emitLineToRev(r[kind - 2], r[kind - 1]);\n-        }\n-\n-        this.prev = DRAWING_OP_TO;\n-        this.cx0 = x3;\n-        this.cy0 = y3;\n-        this.cdx = dxf;\n-        this.cdy = dyf;\n-        this.cmx = (l[kind - 2] - r[kind - 2]) \/ 2.0d;\n-        this.cmy = (l[kind - 1] - r[kind - 1]) \/ 2.0d;\n-    }\n-\n-    @Override\n-    public void quadTo(final double x1, final double y1,\n-                       final double x2, final double y2)\n-    {\n-        final int outcode0 = this.cOutCode;\n-\n-        if (clipRect != null) {\n-            final int outcode1 = DHelpers.outcode(x1, y1, clipRect);\n-            final int outcode2 = DHelpers.outcode(x2, y2, clipRect);\n-\n-            \/\/ Should clip\n-            final int orCode = (outcode0 | outcode1 | outcode2);\n-            if (orCode != 0) {\n-                final int sideCode = outcode0 & outcode1 & outcode2;\n-\n-                \/\/ basic rejection criteria:\n-                if (sideCode == 0) {\n-                    \/\/ overlap clip:\n-                    if (subdivide) {\n-                        \/\/ avoid reentrance\n-                        subdivide = false;\n-                        \/\/ subdivide curve => call lineTo() with subdivided curves:\n-                        boolean ret = curveSplitter.splitQuad(cx0, cy0, x1, y1,\n-                                                              x2, y2, orCode, this);\n-                        \/\/ reentrance is done:\n-                        subdivide = true;\n-                        if (ret) {\n-                            return;\n-                        }\n-                    }\n-                    \/\/ already subdivided so render it\n-                } else {\n-                    this.cOutCode = outcode2;\n-                    _moveTo(x2, y2, outcode0);\n-                    opened = true;\n-                    return;\n-                }\n-            }\n-\n-            this.cOutCode = outcode2;\n-        }\n-        _quadTo(x1, y1, x2, y2, outcode0);\n-    }\n-\n-    private void _quadTo(final double x1, final double y1,\n-                         final double x2, final double y2,\n-                         final int outcode0)\n-    {\n-        \/\/ need these so we can update the state at the end of this method\n-        double dxs = x1 - cx0;\n-        double dys = y1 - cy0;\n-        double dxf = x2 - x1;\n-        double dyf = y2 - y1;\n-\n-        if (((dxs == 0.0d) && (dys == 0.0d)) || ((dxf == 0.0d) && (dyf == 0.0d))) {\n-            dxs = dxf = x2 - cx0;\n-            dys = dyf = y2 - cy0;\n-        }\n-        if ((dxs == 0.0d) && (dys == 0.0d)) {\n-            \/\/ this happens if the \"curve\" is just a point\n-            \/\/ fix outcode0 for lineTo() call:\n-            if (clipRect != null) {\n-                this.cOutCode = outcode0;\n-            }\n-            lineTo(cx0, cy0);\n-            return;\n-        }\n-        \/\/ if these vectors are too small, normalize them, to avoid future\n-        \/\/ precision problems.\n-        if (Math.abs(dxs) < 0.1d && Math.abs(dys) < 0.1d) {\n-            final double len = Math.sqrt(dxs * dxs + dys * dys);\n-            dxs \/= len;\n-            dys \/= len;\n-        }\n-        if (Math.abs(dxf) < 0.1d && Math.abs(dyf) < 0.1d) {\n-            final double len = Math.sqrt(dxf * dxf + dyf * dyf);\n-            dxf \/= len;\n-            dyf \/= len;\n-        }\n-        computeOffset(dxs, dys, lineWidth2, offset0);\n-        drawJoin(cdx, cdy, cx0, cy0, dxs, dys, cmx, cmy, offset0[0], offset0[1], outcode0);\n-\n-        int nSplits = 0;\n-        final double[] mid;\n-        final double[] l = lp;\n-\n-        if (monotonize) {\n-            \/\/ monotonize quad:\n-            final CurveBasicMonotonizer monotonizer\n-                = rdrCtx.monotonizer.quad(cx0, cy0, x1, y1, x2, y2);\n-\n-            nSplits = monotonizer.nbSplits;\n-            mid = monotonizer.middle;\n-        } else {\n-            \/\/ use left instead:\n-            mid = l;\n-            mid[0] = cx0; mid[1] = cy0;\n-            mid[2] = x1;  mid[3] = y1;\n-            mid[4] = x2;  mid[5] = y2;\n-        }\n-        final double[] r = rp;\n-\n-        int kind = 0;\n-        for (int i = 0, off = 0; i <= nSplits; i++, off += 4) {\n-            kind = computeOffsetQuad(mid, off, l, r);\n-\n-            emitLineTo(l[0], l[1]);\n-\n-            switch(kind) {\n-            case 6:\n-                emitQuadTo(l[2], l[3], l[4], l[5]);\n-                emitQuadToRev(r[0], r[1], r[2], r[3]);\n-                break;\n-            case 4:\n-                emitLineTo(l[2], l[3]);\n-                emitLineToRev(r[0], r[1]);\n-                break;\n-            default:\n-            }\n-            emitLineToRev(r[kind - 2], r[kind - 1]);\n-        }\n-\n-        this.prev = DRAWING_OP_TO;\n-        this.cx0 = x2;\n-        this.cy0 = y2;\n-        this.cdx = dxf;\n-        this.cdy = dyf;\n-        this.cmx = (l[kind - 2] - r[kind - 2]) \/ 2.0d;\n-        this.cmy = (l[kind - 1] - r[kind - 1]) \/ 2.0d;\n-    }\n-\n-    @Override public long getNativeConsumer() {\n-        throw new InternalError(\"Stroker doesn't use a native consumer\");\n-    }\n-}\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/marlin\/DStroker.java","additions":0,"deletions":1329,"binary":false,"changes":1329,"status":"deleted"},{"patch":"@@ -1,1215 +0,0 @@\n-\/*\n- * Copyright (c) 2007, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package sun.java2d.marlin;\n-\n-import java.awt.geom.AffineTransform;\n-import java.awt.geom.Path2D;\n-import java.util.Arrays;\n-import sun.java2d.marlin.DHelpers.IndexStack;\n-import sun.java2d.marlin.DHelpers.PolyStack;\n-\n-final class DTransformingPathConsumer2D {\n-\n-    \/\/ smaller uncertainty in double variant\n-    static final double CLIP_RECT_PADDING = 0.25d;\n-\n-    private final DRendererContext rdrCtx;\n-\n-    \/\/ recycled ClosedPathDetector instance from detectClosedPath()\n-    private final ClosedPathDetector   cpDetector;\n-\n-    \/\/ recycled PathClipFilter instance from pathClipper()\n-    private final PathClipFilter       pathClipper;\n-\n-    \/\/ recycled DPathConsumer2D instance from wrapPath2D()\n-    private final Path2DWrapper        wp_Path2DWrapper        = new Path2DWrapper();\n-\n-    \/\/ recycled DPathConsumer2D instances from deltaTransformConsumer()\n-    private final DeltaScaleFilter     dt_DeltaScaleFilter     = new DeltaScaleFilter();\n-    private final DeltaTransformFilter dt_DeltaTransformFilter = new DeltaTransformFilter();\n-\n-    \/\/ recycled DPathConsumer2D instances from inverseDeltaTransformConsumer()\n-    private final DeltaScaleFilter     iv_DeltaScaleFilter     = new DeltaScaleFilter();\n-    private final DeltaTransformFilter iv_DeltaTransformFilter = new DeltaTransformFilter();\n-\n-    \/\/ recycled PathTracer instances from tracer...() methods\n-    private final PathTracer tracerInput      = new PathTracer(\"[Input]\");\n-    private final PathTracer tracerCPDetector = new PathTracer(\"ClosedPathDetector\");\n-    private final PathTracer tracerFiller     = new PathTracer(\"Filler\");\n-    private final PathTracer tracerStroker    = new PathTracer(\"Stroker\");\n-    private final PathTracer tracerDasher     = new PathTracer(\"Dasher\");\n-\n-    DTransformingPathConsumer2D(final DRendererContext rdrCtx) {\n-        \/\/ used by RendererContext\n-        this.rdrCtx = rdrCtx;\n-        this.cpDetector = new ClosedPathDetector(rdrCtx);\n-        this.pathClipper = new PathClipFilter(rdrCtx);\n-    }\n-\n-    DPathConsumer2D wrapPath2D(Path2D.Double p2d) {\n-        return wp_Path2DWrapper.init(p2d);\n-    }\n-\n-    DPathConsumer2D traceInput(DPathConsumer2D out) {\n-        return tracerInput.init(out);\n-    }\n-\n-    DPathConsumer2D traceClosedPathDetector(DPathConsumer2D out) {\n-        return tracerCPDetector.init(out);\n-    }\n-\n-    DPathConsumer2D traceFiller(DPathConsumer2D out) {\n-        return tracerFiller.init(out);\n-    }\n-\n-    DPathConsumer2D traceStroker(DPathConsumer2D out) {\n-        return tracerStroker.init(out);\n-    }\n-\n-    DPathConsumer2D traceDasher(DPathConsumer2D out) {\n-        return tracerDasher.init(out);\n-    }\n-\n-    DPathConsumer2D detectClosedPath(DPathConsumer2D out) {\n-        return cpDetector.init(out);\n-    }\n-\n-    DPathConsumer2D pathClipper(DPathConsumer2D out) {\n-        return pathClipper.init(out);\n-    }\n-\n-    DPathConsumer2D deltaTransformConsumer(DPathConsumer2D out,\n-                                          AffineTransform at)\n-    {\n-        if (at == null) {\n-            return out;\n-        }\n-        final double mxx = at.getScaleX();\n-        final double mxy = at.getShearX();\n-        final double myx = at.getShearY();\n-        final double myy = at.getScaleY();\n-\n-        if (mxy == 0.0d && myx == 0.0d) {\n-            if (mxx == 1.0d && myy == 1.0d) {\n-                return out;\n-            } else {\n-                \/\/ Scale only\n-                if (rdrCtx.doClip) {\n-                    \/\/ adjust clip rectangle (ymin, ymax, xmin, xmax):\n-                    rdrCtx.clipInvScale = adjustClipScale(rdrCtx.clipRect,\n-                        mxx, myy);\n-                }\n-                return dt_DeltaScaleFilter.init(out, mxx, myy);\n-            }\n-        } else {\n-            if (rdrCtx.doClip) {\n-                \/\/ adjust clip rectangle (ymin, ymax, xmin, xmax):\n-                rdrCtx.clipInvScale = adjustClipInverseDelta(rdrCtx.clipRect,\n-                    mxx, mxy, myx, myy);\n-            }\n-            return dt_DeltaTransformFilter.init(out, mxx, mxy, myx, myy);\n-        }\n-    }\n-\n-    private static double adjustClipScale(final double[] clipRect,\n-                                          final double mxx, final double myy)\n-    {\n-        \/\/ Adjust the clipping rectangle (iv_DeltaScaleFilter):\n-        final double scaleY = 1.0d \/ myy;\n-        clipRect[0] *= scaleY;\n-        clipRect[1] *= scaleY;\n-\n-        if (clipRect[1] < clipRect[0]) {\n-            double tmp = clipRect[0];\n-            clipRect[0] = clipRect[1];\n-            clipRect[1] = tmp;\n-        }\n-\n-        final double scaleX = 1.0d \/ mxx;\n-        clipRect[2] *= scaleX;\n-        clipRect[3] *= scaleX;\n-\n-        if (clipRect[3] < clipRect[2]) {\n-            double tmp = clipRect[2];\n-            clipRect[2] = clipRect[3];\n-            clipRect[3] = tmp;\n-        }\n-\n-        if (MarlinConst.DO_LOG_CLIP) {\n-                MarlinUtils.logInfo(\"clipRect (ClipScale): \"\n-                                    + Arrays.toString(clipRect));\n-        }\n-        return 0.5d * (Math.abs(scaleX) + Math.abs(scaleY));\n-    }\n-\n-    private static double adjustClipInverseDelta(final double[] clipRect,\n-                                                 final double mxx, final double mxy,\n-                                                 final double myx, final double myy)\n-    {\n-        \/\/ Adjust the clipping rectangle (iv_DeltaTransformFilter):\n-        final double det = mxx * myy - mxy * myx;\n-        final double imxx =  myy \/ det;\n-        final double imxy = -mxy \/ det;\n-        final double imyx = -myx \/ det;\n-        final double imyy =  mxx \/ det;\n-\n-        double xmin, xmax, ymin, ymax;\n-        double x, y;\n-        \/\/ xmin, ymin:\n-        x = clipRect[2] * imxx + clipRect[0] * imxy;\n-        y = clipRect[2] * imyx + clipRect[0] * imyy;\n-\n-        xmin = xmax = x;\n-        ymin = ymax = y;\n-\n-        \/\/ xmax, ymin:\n-        x = clipRect[3] * imxx + clipRect[0] * imxy;\n-        y = clipRect[3] * imyx + clipRect[0] * imyy;\n-\n-        if (x < xmin) { xmin = x; } else if (x > xmax) { xmax = x; }\n-        if (y < ymin) { ymin = y; } else if (y > ymax) { ymax = y; }\n-\n-        \/\/ xmin, ymax:\n-        x = clipRect[2] * imxx + clipRect[1] * imxy;\n-        y = clipRect[2] * imyx + clipRect[1] * imyy;\n-\n-        if (x < xmin) { xmin = x; } else if (x > xmax) { xmax = x; }\n-        if (y < ymin) { ymin = y; } else if (y > ymax) { ymax = y; }\n-\n-        \/\/ xmax, ymax:\n-        x = clipRect[3] * imxx + clipRect[1] * imxy;\n-        y = clipRect[3] * imyx + clipRect[1] * imyy;\n-\n-        if (x < xmin) { xmin = x; } else if (x > xmax) { xmax = x; }\n-        if (y < ymin) { ymin = y; } else if (y > ymax) { ymax = y; }\n-\n-        clipRect[0] = ymin;\n-        clipRect[1] = ymax;\n-        clipRect[2] = xmin;\n-        clipRect[3] = xmax;\n-\n-        if (MarlinConst.DO_LOG_CLIP) {\n-                MarlinUtils.logInfo(\"clipRect (ClipInverseDelta): \"\n-                                    + Arrays.toString(clipRect));\n-        }\n-\n-        final double scaleX = Math.sqrt(imxx * imxx + imxy * imxy);\n-        final double scaleY = Math.sqrt(imyx * imyx + imyy * imyy);\n-\n-        return 0.5d * (scaleX + scaleY);\n-    }\n-\n-    DPathConsumer2D inverseDeltaTransformConsumer(DPathConsumer2D out,\n-                                                 AffineTransform at)\n-    {\n-        if (at == null) {\n-            return out;\n-        }\n-        double mxx = at.getScaleX();\n-        double mxy = at.getShearX();\n-        double myx = at.getShearY();\n-        double myy = at.getScaleY();\n-\n-        if (mxy == 0.0d && myx == 0.0d) {\n-            if (mxx == 1.0d && myy == 1.0d) {\n-                return out;\n-            } else {\n-                return iv_DeltaScaleFilter.init(out, 1.0d \/ mxx, 1.0d \/ myy);\n-            }\n-        } else {\n-            final double det = mxx * myy - mxy * myx;\n-            return iv_DeltaTransformFilter.init(out,\n-                                                myy \/ det,\n-                                               -mxy \/ det,\n-                                               -myx \/ det,\n-                                                mxx \/ det);\n-        }\n-    }\n-\n-    static final class DeltaScaleFilter implements DPathConsumer2D {\n-        private DPathConsumer2D out;\n-        private double sx, sy;\n-\n-        DeltaScaleFilter() {}\n-\n-        DeltaScaleFilter init(DPathConsumer2D out,\n-                              double mxx, double myy)\n-        {\n-            this.out = out;\n-            sx = mxx;\n-            sy = myy;\n-            return this; \/\/ fluent API\n-        }\n-\n-        @Override\n-        public void moveTo(double x0, double y0) {\n-            out.moveTo(x0 * sx, y0 * sy);\n-        }\n-\n-        @Override\n-        public void lineTo(double x1, double y1) {\n-            out.lineTo(x1 * sx, y1 * sy);\n-        }\n-\n-        @Override\n-        public void quadTo(double x1, double y1,\n-                           double x2, double y2)\n-        {\n-            out.quadTo(x1 * sx, y1 * sy,\n-                       x2 * sx, y2 * sy);\n-        }\n-\n-        @Override\n-        public void curveTo(double x1, double y1,\n-                            double x2, double y2,\n-                            double x3, double y3)\n-        {\n-            out.curveTo(x1 * sx, y1 * sy,\n-                        x2 * sx, y2 * sy,\n-                        x3 * sx, y3 * sy);\n-        }\n-\n-        @Override\n-        public void closePath() {\n-            out.closePath();\n-        }\n-\n-        @Override\n-        public void pathDone() {\n-            out.pathDone();\n-        }\n-\n-        @Override\n-        public long getNativeConsumer() {\n-            return 0;\n-        }\n-    }\n-\n-    static final class DeltaTransformFilter implements DPathConsumer2D {\n-        private DPathConsumer2D out;\n-        private double mxx, mxy, myx, myy;\n-\n-        DeltaTransformFilter() {}\n-\n-        DeltaTransformFilter init(DPathConsumer2D out,\n-                                  double mxx, double mxy,\n-                                  double myx, double myy)\n-        {\n-            this.out = out;\n-            this.mxx = mxx;\n-            this.mxy = mxy;\n-            this.myx = myx;\n-            this.myy = myy;\n-            return this; \/\/ fluent API\n-        }\n-\n-        @Override\n-        public void moveTo(double x0, double y0) {\n-            out.moveTo(x0 * mxx + y0 * mxy,\n-                       x0 * myx + y0 * myy);\n-        }\n-\n-        @Override\n-        public void lineTo(double x1, double y1) {\n-            out.lineTo(x1 * mxx + y1 * mxy,\n-                       x1 * myx + y1 * myy);\n-        }\n-\n-        @Override\n-        public void quadTo(double x1, double y1,\n-                           double x2, double y2)\n-        {\n-            out.quadTo(x1 * mxx + y1 * mxy,\n-                       x1 * myx + y1 * myy,\n-                       x2 * mxx + y2 * mxy,\n-                       x2 * myx + y2 * myy);\n-        }\n-\n-        @Override\n-        public void curveTo(double x1, double y1,\n-                            double x2, double y2,\n-                            double x3, double y3)\n-        {\n-            out.curveTo(x1 * mxx + y1 * mxy,\n-                        x1 * myx + y1 * myy,\n-                        x2 * mxx + y2 * mxy,\n-                        x2 * myx + y2 * myy,\n-                        x3 * mxx + y3 * mxy,\n-                        x3 * myx + y3 * myy);\n-        }\n-\n-        @Override\n-        public void closePath() {\n-            out.closePath();\n-        }\n-\n-        @Override\n-        public void pathDone() {\n-            out.pathDone();\n-        }\n-\n-        @Override\n-        public long getNativeConsumer() {\n-            return 0;\n-        }\n-    }\n-\n-    static final class Path2DWrapper implements DPathConsumer2D {\n-        private Path2D.Double p2d;\n-\n-        Path2DWrapper() {}\n-\n-        Path2DWrapper init(Path2D.Double p2d) {\n-            this.p2d = p2d;\n-            return this;\n-        }\n-\n-        @Override\n-        public void moveTo(double x0, double y0) {\n-            p2d.moveTo(x0, y0);\n-        }\n-\n-        @Override\n-        public void lineTo(double x1, double y1) {\n-            p2d.lineTo(x1, y1);\n-        }\n-\n-        @Override\n-        public void closePath() {\n-            p2d.closePath();\n-        }\n-\n-        @Override\n-        public void pathDone() {}\n-\n-        @Override\n-        public void curveTo(double x1, double y1,\n-                            double x2, double y2,\n-                            double x3, double y3)\n-        {\n-            p2d.curveTo(x1, y1, x2, y2, x3, y3);\n-        }\n-\n-        @Override\n-        public void quadTo(double x1, double y1, double x2, double y2) {\n-            p2d.quadTo(x1, y1, x2, y2);\n-        }\n-\n-        @Override\n-        public long getNativeConsumer() {\n-            throw new InternalError(\"Not using a native peer\");\n-        }\n-    }\n-\n-    static final class ClosedPathDetector implements DPathConsumer2D {\n-\n-        private final DRendererContext rdrCtx;\n-        private final PolyStack stack;\n-\n-        private DPathConsumer2D out;\n-\n-        ClosedPathDetector(final DRendererContext rdrCtx) {\n-            this.rdrCtx = rdrCtx;\n-            this.stack = (rdrCtx.stats != null) ?\n-                new PolyStack(rdrCtx,\n-                        rdrCtx.stats.stat_cpd_polystack_types,\n-                        rdrCtx.stats.stat_cpd_polystack_curves,\n-                        rdrCtx.stats.hist_cpd_polystack_curves,\n-                        rdrCtx.stats.stat_array_cpd_polystack_curves,\n-                        rdrCtx.stats.stat_array_cpd_polystack_types)\n-                : new PolyStack(rdrCtx);\n-        }\n-\n-        ClosedPathDetector init(DPathConsumer2D out) {\n-            this.out = out;\n-            return this; \/\/ fluent API\n-        }\n-\n-        \/**\n-         * Disposes this instance:\n-         * clean up before reusing this instance\n-         *\/\n-        void dispose() {\n-            stack.dispose();\n-        }\n-\n-        @Override\n-        public void pathDone() {\n-            \/\/ previous path is not closed:\n-            finish(false);\n-            out.pathDone();\n-\n-            \/\/ TODO: fix possible leak if exception happened\n-            \/\/ Dispose this instance:\n-            dispose();\n-        }\n-\n-        @Override\n-        public void closePath() {\n-            \/\/ path is closed\n-            finish(true);\n-            out.closePath();\n-        }\n-\n-        @Override\n-        public void moveTo(double x0, double y0) {\n-            \/\/ previous path is not closed:\n-            finish(false);\n-            out.moveTo(x0, y0);\n-        }\n-\n-        private void finish(final boolean closed) {\n-            rdrCtx.closedPath = closed;\n-            stack.pullAll(out);\n-        }\n-\n-        @Override\n-        public void lineTo(double x1, double y1) {\n-            stack.pushLine(x1, y1);\n-        }\n-\n-        @Override\n-        public void curveTo(double x3, double y3,\n-                            double x2, double y2,\n-                            double x1, double y1)\n-        {\n-            stack.pushCubic(x1, y1, x2, y2, x3, y3);\n-        }\n-\n-        @Override\n-        public void quadTo(double x2, double y2, double x1, double y1) {\n-            stack.pushQuad(x1, y1, x2, y2);\n-        }\n-\n-        @Override\n-        public long getNativeConsumer() {\n-            throw new InternalError(\"Not using a native peer\");\n-        }\n-    }\n-\n-    static final class PathClipFilter implements DPathConsumer2D {\n-\n-        private DPathConsumer2D out;\n-\n-        \/\/ Bounds of the drawing region, at pixel precision.\n-        private final double[] clipRect;\n-\n-        private final double[] corners = new double[8];\n-        private boolean init_corners = false;\n-\n-        private final IndexStack stack;\n-\n-        \/\/ the current outcode of the current sub path\n-        private int cOutCode = 0;\n-\n-        \/\/ the cumulated (and) outcode of the complete path\n-        private int gOutCode = MarlinConst.OUTCODE_MASK_T_B_L_R;\n-\n-        private boolean outside = false;\n-\n-        \/\/ The starting point of the path\n-        private double sx0, sy0;\n-\n-        \/\/ The current point (TODO stupid repeated info)\n-        private double cx0, cy0;\n-\n-        \/\/ The current point OUTSIDE\n-        private double cox0, coy0;\n-\n-        private boolean subdivide = MarlinConst.DO_CLIP_SUBDIVIDER;\n-        private final CurveClipSplitter curveSplitter;\n-\n-        PathClipFilter(final DRendererContext rdrCtx) {\n-            this.clipRect = rdrCtx.clipRect;\n-            this.curveSplitter = rdrCtx.curveClipSplitter;\n-\n-            this.stack = (rdrCtx.stats != null) ?\n-                new IndexStack(rdrCtx,\n-                        rdrCtx.stats.stat_pcf_idxstack_indices,\n-                        rdrCtx.stats.hist_pcf_idxstack_indices,\n-                        rdrCtx.stats.stat_array_pcf_idxstack_indices)\n-                : new IndexStack(rdrCtx);\n-        }\n-\n-        PathClipFilter init(final DPathConsumer2D out) {\n-            this.out = out;\n-\n-            if (MarlinConst.DO_CLIP_SUBDIVIDER) {\n-                \/\/ adjust padded clip rectangle:\n-                curveSplitter.init();\n-            }\n-\n-            this.init_corners = true;\n-            this.gOutCode = MarlinConst.OUTCODE_MASK_T_B_L_R;\n-\n-            return this; \/\/ fluent API\n-        }\n-\n-        \/**\n-         * Disposes this instance:\n-         * clean up before reusing this instance\n-         *\/\n-        void dispose() {\n-            stack.dispose();\n-        }\n-\n-        private void finishPath() {\n-            if (outside) {\n-                \/\/ criteria: inside or totally outside ?\n-                if (gOutCode == 0) {\n-                    finish();\n-                } else {\n-                    this.outside = false;\n-                    stack.reset();\n-                }\n-            }\n-        }\n-\n-        private void finish() {\n-            this.outside = false;\n-\n-            if (!stack.isEmpty()) {\n-                if (init_corners) {\n-                    init_corners = false;\n-\n-                    final double[] _corners = corners;\n-                    final double[] _clipRect = clipRect;\n-                    \/\/ Top Left (0):\n-                    _corners[0] = _clipRect[2];\n-                    _corners[1] = _clipRect[0];\n-                    \/\/ Bottom Left (1):\n-                    _corners[2] = _clipRect[2];\n-                    _corners[3] = _clipRect[1];\n-                    \/\/ Top right (2):\n-                    _corners[4] = _clipRect[3];\n-                    _corners[5] = _clipRect[0];\n-                    \/\/ Bottom Right (3):\n-                    _corners[6] = _clipRect[3];\n-                    _corners[7] = _clipRect[1];\n-                }\n-                stack.pullAll(corners, out);\n-            }\n-            out.lineTo(cox0, coy0);\n-            this.cx0 = cox0;\n-            this.cy0 = coy0;\n-        }\n-\n-        @Override\n-        public void pathDone() {\n-            finishPath();\n-\n-            out.pathDone();\n-\n-            \/\/ TODO: fix possible leak if exception happened\n-            \/\/ Dispose this instance:\n-            dispose();\n-        }\n-\n-        @Override\n-        public void closePath() {\n-            finishPath();\n-\n-            out.closePath();\n-\n-            \/\/ back to starting point:\n-            this.cOutCode = DHelpers.outcode(sx0, sy0, clipRect);\n-            this.cx0 = sx0;\n-            this.cy0 = sy0;\n-        }\n-\n-        @Override\n-        public void moveTo(final double x0, final double y0) {\n-            finishPath();\n-\n-            out.moveTo(x0, y0);\n-\n-            \/\/ update starting point:\n-            this.cOutCode = DHelpers.outcode(x0, y0, clipRect);\n-            this.cx0 = x0;\n-            this.cy0 = y0;\n-\n-            this.sx0 = x0;\n-            this.sy0 = y0;\n-        }\n-\n-        @Override\n-        public void lineTo(final double xe, final double ye) {\n-            final int outcode0 = this.cOutCode;\n-            final int outcode1 = DHelpers.outcode(xe, ye, clipRect);\n-\n-            \/\/ Should clip\n-            final int orCode = (outcode0 | outcode1);\n-            if (orCode != 0) {\n-                final int sideCode = (outcode0 & outcode1);\n-\n-                \/\/ basic rejection criteria:\n-                if (sideCode == 0) {\n-                    \/\/ overlap clip:\n-                    if (subdivide) {\n-                        \/\/ avoid reentrance\n-                        subdivide = false;\n-                        boolean ret;\n-                        \/\/ subdivide curve => callback with subdivided parts:\n-                        if (outside) {\n-                            ret = curveSplitter.splitLine(cox0, coy0, xe, ye,\n-                                                          orCode, this);\n-                        } else {\n-                            ret = curveSplitter.splitLine(cx0, cy0, xe, ye,\n-                                                          orCode, this);\n-                        }\n-                        \/\/ reentrance is done:\n-                        subdivide = true;\n-                        if (ret) {\n-                            return;\n-                        }\n-                    }\n-                    \/\/ already subdivided so render it\n-                } else {\n-                    this.cOutCode = outcode1;\n-                    this.gOutCode &= sideCode;\n-                    \/\/ keep last point coordinate before entering the clip again:\n-                    this.outside = true;\n-                    this.cox0 = xe;\n-                    this.coy0 = ye;\n-\n-                    clip(sideCode, outcode0, outcode1);\n-                    return;\n-                }\n-            }\n-\n-            this.cOutCode = outcode1;\n-            this.gOutCode = 0;\n-\n-            if (outside) {\n-                finish();\n-            }\n-            \/\/ clipping disabled:\n-            out.lineTo(xe, ye);\n-            this.cx0 = xe;\n-            this.cy0 = ye;\n-        }\n-\n-        private void clip(final int sideCode,\n-                          final int outcode0,\n-                          final int outcode1)\n-        {\n-            \/\/ corner or cross-boundary on left or right side:\n-            if ((outcode0 != outcode1)\n-                    && ((sideCode & MarlinConst.OUTCODE_MASK_L_R) != 0))\n-            {\n-                \/\/ combine outcodes:\n-                final int mergeCode = (outcode0 | outcode1);\n-                final int tbCode = mergeCode & MarlinConst.OUTCODE_MASK_T_B;\n-                final int lrCode = mergeCode & MarlinConst.OUTCODE_MASK_L_R;\n-                final int off = (lrCode == MarlinConst.OUTCODE_LEFT) ? 0 : 2;\n-\n-                \/\/ add corners to outside stack:\n-                switch (tbCode) {\n-                    case MarlinConst.OUTCODE_TOP:\n-                        stack.push(off); \/\/ top\n-                        return;\n-                    case MarlinConst.OUTCODE_BOTTOM:\n-                        stack.push(off + 1); \/\/ bottom\n-                        return;\n-                    default:\n-                        \/\/ both TOP \/ BOTTOM:\n-                        if ((outcode0 & MarlinConst.OUTCODE_TOP) != 0) {\n-                            \/\/ top to bottom\n-                            stack.push(off); \/\/ top\n-                            stack.push(off + 1); \/\/ bottom\n-                        } else {\n-                            \/\/ bottom to top\n-                            stack.push(off + 1); \/\/ bottom\n-                            stack.push(off); \/\/ top\n-                        }\n-                }\n-            }\n-        }\n-\n-        @Override\n-        public void curveTo(final double x1, final double y1,\n-                            final double x2, final double y2,\n-                            final double xe, final double ye)\n-        {\n-            final int outcode0 = this.cOutCode;\n-            final int outcode1 = DHelpers.outcode(x1, y1, clipRect);\n-            final int outcode2 = DHelpers.outcode(x2, y2, clipRect);\n-            final int outcode3 = DHelpers.outcode(xe, ye, clipRect);\n-\n-            \/\/ Should clip\n-            final int orCode = (outcode0 | outcode1 | outcode2 | outcode3);\n-            if (orCode != 0) {\n-                final int sideCode = outcode0 & outcode1 & outcode2 & outcode3;\n-\n-                \/\/ basic rejection criteria:\n-                if (sideCode == 0) {\n-                    \/\/ overlap clip:\n-                    if (subdivide) {\n-                        \/\/ avoid reentrance\n-                        subdivide = false;\n-                        \/\/ subdivide curve => callback with subdivided parts:\n-                        boolean ret;\n-                        if (outside) {\n-                            ret = curveSplitter.splitCurve(cox0, coy0, x1, y1,\n-                                                           x2, y2, xe, ye,\n-                                                           orCode, this);\n-                        } else {\n-                            ret = curveSplitter.splitCurve(cx0, cy0, x1, y1,\n-                                                           x2, y2, xe, ye,\n-                                                           orCode, this);\n-                        }\n-                        \/\/ reentrance is done:\n-                        subdivide = true;\n-                        if (ret) {\n-                            return;\n-                        }\n-                    }\n-                    \/\/ already subdivided so render it\n-                } else {\n-                    this.cOutCode = outcode3;\n-                    this.gOutCode &= sideCode;\n-                    \/\/ keep last point coordinate before entering the clip again:\n-                    this.outside = true;\n-                    this.cox0 = xe;\n-                    this.coy0 = ye;\n-\n-                    clip(sideCode, outcode0, outcode3);\n-                    return;\n-                }\n-            }\n-\n-            this.cOutCode = outcode3;\n-            this.gOutCode = 0;\n-\n-            if (outside) {\n-                finish();\n-            }\n-            \/\/ clipping disabled:\n-            out.curveTo(x1, y1, x2, y2, xe, ye);\n-            this.cx0 = xe;\n-            this.cy0 = ye;\n-        }\n-\n-        @Override\n-        public void quadTo(final double x1, final double y1,\n-                           final double xe, final double ye)\n-        {\n-            final int outcode0 = this.cOutCode;\n-            final int outcode1 = DHelpers.outcode(x1, y1, clipRect);\n-            final int outcode2 = DHelpers.outcode(xe, ye, clipRect);\n-\n-            \/\/ Should clip\n-            final int orCode = (outcode0 | outcode1 | outcode2);\n-            if (orCode != 0) {\n-                final int sideCode = outcode0 & outcode1 & outcode2;\n-\n-                \/\/ basic rejection criteria:\n-                if (sideCode == 0) {\n-                    \/\/ overlap clip:\n-                    if (subdivide) {\n-                        \/\/ avoid reentrance\n-                        subdivide = false;\n-                        \/\/ subdivide curve => callback with subdivided parts:\n-                        boolean ret;\n-                        if (outside) {\n-                            ret = curveSplitter.splitQuad(cox0, coy0, x1, y1,\n-                                                          xe, ye, orCode, this);\n-                        } else {\n-                            ret = curveSplitter.splitQuad(cx0, cy0, x1, y1,\n-                                                          xe, ye, orCode, this);\n-                        }\n-                        \/\/ reentrance is done:\n-                        subdivide = true;\n-                        if (ret) {\n-                            return;\n-                        }\n-                    }\n-                    \/\/ already subdivided so render it\n-                } else {\n-                    this.cOutCode = outcode2;\n-                    this.gOutCode &= sideCode;\n-                    \/\/ keep last point coordinate before entering the clip again:\n-                    this.outside = true;\n-                    this.cox0 = xe;\n-                    this.coy0 = ye;\n-\n-                    clip(sideCode, outcode0, outcode2);\n-                    return;\n-                }\n-            }\n-\n-            this.cOutCode = outcode2;\n-            this.gOutCode = 0;\n-\n-            if (outside) {\n-                finish();\n-            }\n-            \/\/ clipping disabled:\n-            out.quadTo(x1, y1, xe, ye);\n-            this.cx0 = xe;\n-            this.cy0 = ye;\n-        }\n-\n-        @Override\n-        public long getNativeConsumer() {\n-            throw new InternalError(\"Not using a native peer\");\n-        }\n-    }\n-\n-    static final class CurveClipSplitter {\n-\n-        static final double LEN_TH = MarlinProperties.getSubdividerMinLength();\n-        static final boolean DO_CHECK_LENGTH = (LEN_TH > 0.0d);\n-\n-        private static final boolean TRACE = false;\n-\n-        private static final int MAX_N_CURVES = 3 * 4;\n-\n-        private final DRendererContext rdrCtx;\n-\n-        \/\/ scaled length threshold:\n-        private double minLength;\n-\n-        \/\/ clip rectangle (ymin, ymax, xmin, xmax):\n-        final double[] clipRect;\n-\n-        \/\/ clip rectangle (ymin, ymax, xmin, xmax) including padding:\n-        final double[] clipRectPad = new double[4];\n-        private boolean init_clipRectPad = false;\n-\n-        \/\/ This is where the curve to be processed is put. We give it\n-        \/\/ enough room to store all curves.\n-        final double[] middle = new double[MAX_N_CURVES * 8 + 2];\n-        \/\/ t values at subdivision points\n-        private final double[] subdivTs = new double[MAX_N_CURVES];\n-\n-        \/\/ dirty curve\n-        private final DCurve curve;\n-\n-        CurveClipSplitter(final DRendererContext rdrCtx) {\n-            this.rdrCtx = rdrCtx;\n-            this.clipRect = rdrCtx.clipRect;\n-            this.curve = rdrCtx.curve;\n-        }\n-\n-        void init() {\n-            this.init_clipRectPad = true;\n-\n-            if (DO_CHECK_LENGTH) {\n-                this.minLength = (this.rdrCtx.clipInvScale == 0.0d) ? LEN_TH\n-                                    : (LEN_TH * this.rdrCtx.clipInvScale);\n-\n-                if (MarlinConst.DO_LOG_CLIP) {\n-                    MarlinUtils.logInfo(\"CurveClipSplitter.minLength = \"\n-                                            + minLength);\n-                }\n-            }\n-        }\n-\n-        private void initPaddedClip() {\n-            \/\/ bounds as half-open intervals: minX <= x < maxX and minY <= y < maxY\n-            \/\/ adjust padded clip rectangle (ymin, ymax, xmin, xmax):\n-            \/\/ add a rounding error (curve subdivision ~ 0.1px):\n-            final double[] _clipRect = clipRect;\n-            final double[] _clipRectPad = clipRectPad;\n-\n-            _clipRectPad[0] = _clipRect[0] - CLIP_RECT_PADDING;\n-            _clipRectPad[1] = _clipRect[1] + CLIP_RECT_PADDING;\n-            _clipRectPad[2] = _clipRect[2] - CLIP_RECT_PADDING;\n-            _clipRectPad[3] = _clipRect[3] + CLIP_RECT_PADDING;\n-\n-            if (TRACE) {\n-                MarlinUtils.logInfo(\"clip: X [\" + _clipRectPad[2] + \" .. \" + _clipRectPad[3] +\"] \"\n-                                        + \"Y [\" + _clipRectPad[0] + \" .. \" + _clipRectPad[1] +\"]\");\n-            }\n-        }\n-\n-        boolean splitLine(final double x0, final double y0,\n-                          final double x1, final double y1,\n-                          final int outCodeOR,\n-                          final DPathConsumer2D out)\n-        {\n-            if (TRACE) {\n-                MarlinUtils.logInfo(\"divLine P0(\" + x0 + \", \" + y0 + \") P1(\" + x1 + \", \" + y1 + \")\");\n-            }\n-\n-            if (DO_CHECK_LENGTH && DHelpers.fastLineLen(x0, y0, x1, y1) <= minLength) {\n-                return false;\n-            }\n-\n-            final double[] mid = middle;\n-            mid[0] = x0;  mid[1] = y0;\n-            mid[2] = x1;  mid[3] = y1;\n-\n-            return subdivideAtIntersections(4, outCodeOR, out);\n-        }\n-\n-        boolean splitQuad(final double x0, final double y0,\n-                          final double x1, final double y1,\n-                          final double x2, final double y2,\n-                          final int outCodeOR,\n-                          final DPathConsumer2D out)\n-        {\n-            if (TRACE) {\n-                MarlinUtils.logInfo(\"divQuad P0(\" + x0 + \", \" + y0 + \") P1(\" + x1 + \", \" + y1 + \") P2(\" + x2 + \", \" + y2 + \")\");\n-            }\n-\n-            if (DO_CHECK_LENGTH && DHelpers.fastQuadLen(x0, y0, x1, y1, x2, y2) <= minLength) {\n-                return false;\n-            }\n-\n-            final double[] mid = middle;\n-            mid[0] = x0;  mid[1] = y0;\n-            mid[2] = x1;  mid[3] = y1;\n-            mid[4] = x2;  mid[5] = y2;\n-\n-            return subdivideAtIntersections(6, outCodeOR, out);\n-        }\n-\n-        boolean splitCurve(final double x0, final double y0,\n-                           final double x1, final double y1,\n-                           final double x2, final double y2,\n-                           final double x3, final double y3,\n-                           final int outCodeOR,\n-                           final DPathConsumer2D out)\n-        {\n-            if (TRACE) {\n-                MarlinUtils.logInfo(\"divCurve P0(\" + x0 + \", \" + y0 + \") P1(\" + x1 + \", \" + y1 + \") P2(\" + x2 + \", \" + y2 + \") P3(\" + x3 + \", \" + y3 + \")\");\n-            }\n-\n-            if (DO_CHECK_LENGTH && DHelpers.fastCurvelen(x0, y0, x1, y1, x2, y2, x3, y3) <= minLength) {\n-                return false;\n-            }\n-\n-            final double[] mid = middle;\n-            mid[0] = x0;  mid[1] = y0;\n-            mid[2] = x1;  mid[3] = y1;\n-            mid[4] = x2;  mid[5] = y2;\n-            mid[6] = x3;  mid[7] = y3;\n-\n-            return subdivideAtIntersections(8, outCodeOR, out);\n-        }\n-\n-        private boolean subdivideAtIntersections(final int type, final int outCodeOR,\n-                                                 final DPathConsumer2D out)\n-        {\n-            final double[] mid = middle;\n-            final double[] subTs = subdivTs;\n-\n-            if (init_clipRectPad) {\n-                init_clipRectPad = false;\n-                initPaddedClip();\n-            }\n-\n-            final int nSplits = DHelpers.findClipPoints(curve, mid, subTs, type,\n-                                                        outCodeOR, clipRectPad);\n-\n-            if (TRACE) {\n-                MarlinUtils.logInfo(\"nSplits: \" + nSplits);\n-                MarlinUtils.logInfo(\"subTs: \" + Arrays.toString(Arrays.copyOfRange(subTs, 0, nSplits)));\n-            }\n-            if (nSplits == 0) {\n-                \/\/ only curve support shortcut\n-                return false;\n-            }\n-            double prevT = 0.0d;\n-\n-            for (int i = 0, off = 0; i < nSplits; i++, off += type) {\n-                final double t = subTs[i];\n-\n-                DHelpers.subdivideAt((t - prevT) \/ (1.0d - prevT),\n-                                     mid, off, mid, off, type);\n-                prevT = t;\n-            }\n-\n-            for (int i = 0, off = 0; i <= nSplits; i++, off += type) {\n-                if (TRACE) {\n-                    MarlinUtils.logInfo(\"Part Curve \" + Arrays.toString(Arrays.copyOfRange(mid, off, off + type)));\n-                }\n-                emitCurrent(type, mid, off, out);\n-            }\n-            return true;\n-        }\n-\n-        static void emitCurrent(final int type, final double[] pts,\n-                                final int off, final DPathConsumer2D out)\n-        {\n-            \/\/ if instead of switch (perf + most probable cases first)\n-            if (type == 8) {\n-                out.curveTo(pts[off + 2], pts[off + 3],\n-                            pts[off + 4], pts[off + 5],\n-                            pts[off + 6], pts[off + 7]);\n-            } else if (type == 4) {\n-                out.lineTo(pts[off + 2], pts[off + 3]);\n-            } else {\n-                out.quadTo(pts[off + 2], pts[off + 3],\n-                           pts[off + 4], pts[off + 5]);\n-            }\n-        }\n-    }\n-\n-    static final class CurveBasicMonotonizer {\n-\n-        private static final int MAX_N_CURVES = 11;\n-\n-        \/\/ squared half line width (for stroker)\n-        private double lw2;\n-\n-        \/\/ number of splitted curves\n-        int nbSplits;\n-\n-        \/\/ This is where the curve to be processed is put. We give it\n-        \/\/ enough room to store all curves.\n-        final double[] middle = new double[MAX_N_CURVES * 6 + 2];\n-        \/\/ t values at subdivision points\n-        private final double[] subdivTs = new double[MAX_N_CURVES - 1];\n-\n-        \/\/ dirty curve\n-        private final DCurve curve;\n-\n-        CurveBasicMonotonizer(final DRendererContext rdrCtx) {\n-            this.curve = rdrCtx.curve;\n-        }\n-\n-        void init(final double lineWidth) {\n-            this.lw2 = (lineWidth * lineWidth) \/ 4.0d;\n-        }\n-\n-        CurveBasicMonotonizer curve(final double x0, final double y0,\n-                                    final double x1, final double y1,\n-                                    final double x2, final double y2,\n-                                    final double x3, final double y3)\n-        {\n-            final double[] mid = middle;\n-            mid[0] = x0;  mid[1] = y0;\n-            mid[2] = x1;  mid[3] = y1;\n-            mid[4] = x2;  mid[5] = y2;\n-            mid[6] = x3;  mid[7] = y3;\n-\n-            final double[] subTs = subdivTs;\n-            final int nSplits = DHelpers.findSubdivPoints(curve, mid, subTs, 8, lw2);\n-\n-            double prevT = 0.0d;\n-            for (int i = 0, off = 0; i < nSplits; i++, off += 6) {\n-                final double t = subTs[i];\n-\n-                DHelpers.subdivideCubicAt((t - prevT) \/ (1.0d - prevT),\n-                                          mid, off, mid, off, off + 6);\n-                prevT = t;\n-            }\n-\n-            this.nbSplits = nSplits;\n-            return this;\n-        }\n-\n-        CurveBasicMonotonizer quad(final double x0, final double y0,\n-                                   final double x1, final double y1,\n-                                   final double x2, final double y2)\n-        {\n-            final double[] mid = middle;\n-            mid[0] = x0;  mid[1] = y0;\n-            mid[2] = x1;  mid[3] = y1;\n-            mid[4] = x2;  mid[5] = y2;\n-\n-            final double[] subTs = subdivTs;\n-            final int nSplits = DHelpers.findSubdivPoints(curve, mid, subTs, 6, lw2);\n-\n-            double prevt = 0.0d;\n-            for (int i = 0, off = 0; i < nSplits; i++, off += 4) {\n-                final double t = subTs[i];\n-                DHelpers.subdivideQuadAt((t - prevt) \/ (1.0d - prevt),\n-                                         mid, off, mid, off, off + 4);\n-                prevt = t;\n-            }\n-\n-            this.nbSplits = nSplits;\n-            return this;\n-        }\n-    }\n-\n-    static final class PathTracer implements DPathConsumer2D {\n-        private final String prefix;\n-        private DPathConsumer2D out;\n-\n-        PathTracer(String name) {\n-            this.prefix = name + \": \";\n-        }\n-\n-        PathTracer init(DPathConsumer2D out) {\n-            this.out = out;\n-            return this; \/\/ fluent API\n-        }\n-\n-        @Override\n-        public void moveTo(double x0, double y0) {\n-            log(\"p.moveTo(\" + x0 + \", \" + y0 + \");\");\n-            out.moveTo(x0, y0);\n-        }\n-\n-        @Override\n-        public void lineTo(double x1, double y1) {\n-            log(\"p.lineTo(\" + x1 + \", \" + y1 + \");\");\n-            out.lineTo(x1, y1);\n-        }\n-\n-        @Override\n-        public void curveTo(double x1, double y1,\n-                            double x2, double y2,\n-                            double x3, double y3)\n-        {\n-            log(\"p.curveTo(\" + x1 + \", \" + y1 + \", \" + x2 + \", \" + y2  + \", \" + x3 + \", \" + y3 + \");\");\n-            out.curveTo(x1, y1, x2, y2, x3, y3);\n-        }\n-\n-        @Override\n-        public void quadTo(double x1, double y1,\n-                           double x2, double y2) {\n-            log(\"p.quadTo(\" + x1 + \", \" + y1 + \", \" + x2 + \", \" + y2  + \");\");\n-            out.quadTo(x1, y1, x2, y2);\n-        }\n-\n-        @Override\n-        public void closePath() {\n-            log(\"p.closePath();\");\n-            out.closePath();\n-        }\n-\n-        @Override\n-        public void pathDone() {\n-            log(\"p.pathDone();\");\n-            out.pathDone();\n-        }\n-\n-        private void log(final String message) {\n-            MarlinUtils.logInfo(prefix + message);\n-        }\n-\n-        @Override\n-        public long getNativeConsumer() {\n-            throw new InternalError(\"Not using a native peer\");\n-        }\n-    }\n-}\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/marlin\/DTransformingPathConsumer2D.java","additions":0,"deletions":1215,"binary":false,"changes":1215,"status":"deleted"},{"patch":"@@ -29,1 +29,0 @@\n-import sun.awt.geom.PathConsumer2D;\n@@ -44,1 +43,1 @@\n-final class Dasher implements PathConsumer2D, MarlinConst {\n+final class Dasher implements DPathConsumer2D, MarlinConst {\n@@ -48,2 +47,2 @@\n-    static final float CURVE_LEN_ERR = MarlinProperties.getCurveLengthError(); \/\/ 0.01\n-    static final float MIN_T_INC = 1.0f \/ (1 << REC_LIMIT);\n+    static final double CURVE_LEN_ERR = MarlinProperties.getCurveLengthError(); \/\/ 0.01 initial\n+    static final double MIN_T_INC = 1.0d \/ (1 << REC_LIMIT);\n@@ -51,1 +50,1 @@\n-    static final float EPS = 1e-6f;\n+    static final double EPS = 1e-6d;\n@@ -56,1 +55,1 @@\n-    static final float MAX_CYCLES = 16000000.0f;\n+    static final double MAX_CYCLES = 16000000.0d;\n@@ -58,2 +57,2 @@\n-    private PathConsumer2D out;\n-    private float[] dash;\n+    private DPathConsumer2D out;\n+    private double[] dash;\n@@ -61,1 +60,1 @@\n-    private float startPhase;\n+    private double startPhase;\n@@ -70,1 +69,1 @@\n-    private float phase;\n+    private double phase;\n@@ -73,1 +72,1 @@\n-    private float sx0, sy0;\n+    private double sx0, sy0;\n@@ -75,1 +74,1 @@\n-    private float cx0, cy0;\n+    private double cx0, cy0;\n@@ -78,1 +77,1 @@\n-    private final float[] curCurvepts;\n+    private final double[] curCurvepts;\n@@ -90,1 +89,1 @@\n-    private float[] firstSegmentsBuffer; \/\/ dynamic array\n+    private double[] firstSegmentsBuffer; \/\/ dynamic array\n@@ -94,1 +93,1 @@\n-    final FloatArrayCache.Reference dashes_ref;\n+    final DoubleArrayCache.Reference dashes_ref;\n@@ -96,1 +95,1 @@\n-    final FloatArrayCache.Reference firstSegmentsBuffer_ref;\n+    final DoubleArrayCache.Reference firstSegmentsBuffer_ref;\n@@ -99,1 +98,1 @@\n-    private float[] clipRect;\n+    private double[] clipRect;\n@@ -110,1 +109,1 @@\n-    private float cycleLen;\n+    private double cycleLen;\n@@ -112,1 +111,1 @@\n-    private float totalSkipLen;\n+    private double totalSkipLen;\n@@ -121,1 +120,1 @@\n-        dashes_ref = rdrCtx.newDirtyFloatArrayRef(INITIAL_ARRAY); \/\/ 1K\n+        dashes_ref = rdrCtx.newDirtyDoubleArrayRef(INITIAL_ARRAY); \/\/ 1K\n@@ -123,1 +122,1 @@\n-        firstSegmentsBuffer_ref = rdrCtx.newDirtyFloatArrayRef(INITIAL_ARRAY); \/\/ 1K\n+        firstSegmentsBuffer_ref = rdrCtx.newDirtyDoubleArrayRef(INITIAL_ARRAY); \/\/ 1K\n@@ -128,1 +127,1 @@\n-        curCurvepts = new float[8 * 2];\n+        curCurvepts = new double[8 * 2];\n@@ -136,2 +135,2 @@\n-     * @param out an output <code>PathConsumer2D<\/code>.\n-     * @param dash an array of <code>float<\/code>s containing the dash pattern\n+     * @param out an output <code>DPathConsumer2D<\/code>.\n+     * @param dash an array of <code>double<\/code>s containing the dash pattern\n@@ -139,1 +138,1 @@\n-     * @param phase a <code>float<\/code> containing the dash phase\n+     * @param phase a <code>double<\/code> containing the dash phase\n@@ -143,2 +142,2 @@\n-    Dasher init(final PathConsumer2D out, final float[] dash, final int dashLen,\n-                float phase, final boolean recycleDashes)\n+    Dasher init(final DPathConsumer2D out, final double[] dash, final int dashLen,\n+                double phase, final boolean recycleDashes)\n@@ -153,1 +152,1 @@\n-        float sum = 0.0f;\n+        double sum = 0.0d;\n@@ -159,2 +158,2 @@\n-        float cycles = phase \/ sum;\n-        if (phase < 0.0f) {\n+        double cycles = phase \/ sum;\n+        if (phase < 0.0d) {\n@@ -162,1 +161,1 @@\n-                phase = 0.0f;\n+                phase = 0.0d;\n@@ -169,1 +168,1 @@\n-                while (phase < 0.0f) {\n+                while (phase < 0.0d) {\n@@ -177,1 +176,1 @@\n-        } else if (phase > 0.0f) {\n+        } else if (phase > 0.0d) {\n@@ -179,1 +178,1 @@\n-                phase = 0.0f;\n+                phase = 0.0d;\n@@ -186,1 +185,1 @@\n-                float d;\n+                double d;\n@@ -223,1 +222,1 @@\n-            Arrays.fill(curCurvepts, 0.0f);\n+            Arrays.fill(curCurvepts, 0.0d);\n@@ -232,1 +231,1 @@\n-    float[] copyDashArray(final float[] dashes) {\n+    double[] copyDashArray(final float[] dashes) {\n@@ -234,1 +233,1 @@\n-        final float[] newDashes;\n+        final double[] newDashes;\n@@ -243,1 +242,1 @@\n-        System.arraycopy(dashes, 0, newDashes, 0, len);\n+        for (int i = 0; i < len; i++) { newDashes[i] = dashes[i]; }\n@@ -248,1 +247,1 @@\n-    public void moveTo(final float x0, final float y0) {\n+    public void moveTo(final double x0, final double y0) {\n@@ -269,1 +268,1 @@\n-            this.totalSkipLen = 0.0f;\n+            this.totalSkipLen = 0.0d;\n@@ -273,1 +272,1 @@\n-    private void emitSeg(float[] buf, int off, int type) {\n+    private void emitSeg(double[] buf, int off, int type) {\n@@ -292,1 +291,1 @@\n-        final float[] fSegBuf = firstSegmentsBuffer;\n+        final double[] fSegBuf = firstSegmentsBuffer;\n@@ -303,1 +302,1 @@\n-    private void goTo(final float[] pts, final int off, final int type,\n+    private void goTo(final double[] pts, final int off, final int type,\n@@ -307,2 +306,2 @@\n-        final float x = pts[index - 4];\n-        final float y = pts[index - 3];\n+        final double x = pts[index - 4];\n+        final double y = pts[index - 3];\n@@ -331,1 +330,1 @@\n-    private void goTo_starting(final float[] pts, final int off, final int type) {\n+    private void goTo_starting(final double[] pts, final int off, final int type) {\n@@ -334,1 +333,1 @@\n-        float[] buf = firstSegmentsBuffer;\n+        double[] buf = firstSegmentsBuffer;\n@@ -353,1 +352,1 @@\n-    public void lineTo(final float x1, final float y1) {\n+    public void lineTo(final double x1, final double y1) {\n@@ -399,3 +398,3 @@\n-    private void _lineTo(final float x1, final float y1) {\n-        final float dx = x1 - cx0;\n-        final float dy = y1 - cy0;\n+    private void _lineTo(final double x1, final double y1) {\n+        final double dx = x1 - cx0;\n+        final double dy = y1 - cy0;\n@@ -403,2 +402,2 @@\n-        float len = dx * dx + dy * dy;\n-        if (len == 0.0f) {\n+        double len = dx * dx + dy * dy;\n+        if (len == 0.0d) {\n@@ -407,1 +406,1 @@\n-        len = (float) Math.sqrt(len);\n+        len = Math.sqrt(len);\n@@ -411,2 +410,2 @@\n-        final float cx = dx \/ len;\n-        final float cy = dy \/ len;\n+        final double cx = dx \/ len;\n+        final double cy = dy \/ len;\n@@ -414,2 +413,2 @@\n-        final float[] _curCurvepts = curCurvepts;\n-        final float[] _dash = dash;\n+        final double[] _curCurvepts = curCurvepts;\n+        final double[] _dash = dash;\n@@ -420,1 +419,1 @@\n-        float _phase = phase;\n+        double _phase = phase;\n@@ -422,1 +421,1 @@\n-        float leftInThisDashSegment, rem;\n+        double leftInThisDashSegment, rem;\n@@ -439,1 +438,1 @@\n-                    _phase = 0.0f;\n+                    _phase = 0.0d;\n@@ -455,1 +454,1 @@\n-            _phase = 0.0f;\n+            _phase = 0.0d;\n@@ -463,3 +462,3 @@\n-    private void skipLineTo(final float x1, final float y1) {\n-        final float dx = x1 - cx0;\n-        final float dy = y1 - cy0;\n+    private void skipLineTo(final double x1, final double y1) {\n+        final double dx = x1 - cx0;\n+        final double dy = y1 - cy0;\n@@ -467,3 +466,3 @@\n-        float len = dx * dx + dy * dy;\n-        if (len != 0.0f) {\n-            len = (float)Math.sqrt(len);\n+        double len = dx * dx + dy * dy;\n+        if (len != 0.0d) {\n+            len = Math.sqrt(len);\n@@ -485,2 +484,2 @@\n-        float len = this.totalSkipLen;\n-        this.totalSkipLen = 0.0f;\n+        double len = this.totalSkipLen;\n+        this.totalSkipLen = 0.0d;\n@@ -488,1 +487,1 @@\n-        final float[] _dash = dash;\n+        final double[] _dash = dash;\n@@ -493,1 +492,1 @@\n-        float _phase = phase;\n+        double _phase = phase;\n@@ -507,1 +506,1 @@\n-        float leftInThisDashSegment, rem;\n+        double leftInThisDashSegment, rem;\n@@ -519,1 +518,1 @@\n-                    _phase = 0.0f;\n+                    _phase = 0.0d;\n@@ -530,1 +529,1 @@\n-            _phase = 0.0f;\n+            _phase = 0.0d;\n@@ -541,1 +540,1 @@\n-        final float[] _curCurvepts = curCurvepts;\n+        final double[] _curCurvepts = curCurvepts;\n@@ -546,1 +545,1 @@\n-        final float[] _dash = dash;\n+        final double[] _dash = dash;\n@@ -553,1 +552,1 @@\n-        float _phase = phase;\n+        double _phase = phase;\n@@ -557,3 +556,3 @@\n-        float prevT = 0.0f;\n-        float t;\n-        float leftInThisDashSegment = _dash[_idx] - _phase;\n+        double prevT = 0.0d;\n+        double t;\n+        double leftInThisDashSegment = _dash[_idx] - _phase;\n@@ -561,3 +560,3 @@\n-        while ((t = _li.next(leftInThisDashSegment)) < 1.0f) {\n-            if (t != 0.0f) {\n-                Helpers.subdivideAt((t - prevT) \/ (1.0f - prevT),\n+        while ((t = _li.next(leftInThisDashSegment)) < 1.0d) {\n+            if (t != 0.0d) {\n+                Helpers.subdivideAt((t - prevT) \/ (1.0d - prevT),\n@@ -573,1 +572,1 @@\n-            _phase = 0.0f;\n+            _phase = 0.0d;\n@@ -583,1 +582,1 @@\n-            _phase = 0.0f;\n+            _phase = 0.0d;\n@@ -597,1 +596,1 @@\n-        final float[] _curCurvepts = curCurvepts;\n+        final double[] _curCurvepts = curCurvepts;\n@@ -607,1 +606,1 @@\n-        final float len = _li.totalLength();\n+        final double len = _li.totalLength();\n@@ -618,1 +617,1 @@\n-    private static boolean pointCurve(final float[] curve, final int type) {\n+    private static boolean pointCurve(final double[] curve, final int type) {\n@@ -645,1 +644,1 @@\n-        private final float[][] recCurveStack; \/\/ dirty\n+        private final double[][] recCurveStack; \/\/ dirty\n@@ -651,6 +650,6 @@\n-        private float nextT;\n-        private float lenAtNextT;\n-        private float lastT;\n-        private float lenAtLastT;\n-        private float lenAtLastSplit;\n-        private float lastSegLen;\n+        private double nextT;\n+        private double lenAtNextT;\n+        private double lastT;\n+        private double lenAtLastT;\n+        private double lenAtLastSplit;\n+        private double lastSegLen;\n@@ -665,1 +664,1 @@\n-        private final float[] curLeafCtrlPolyLengths = new float[3];\n+        private final double[] curLeafCtrlPolyLengths = new double[3];\n@@ -668,1 +667,1 @@\n-            this.recCurveStack = new float[REC_LIMIT + 1][8];\n+            this.recCurveStack = new double[REC_LIMIT + 1][8];\n@@ -672,3 +671,3 @@\n-            this.nextT = Float.MAX_VALUE;\n-            this.lenAtNextT = Float.MAX_VALUE;\n-            this.lenAtLastSplit = Float.MIN_VALUE;\n+            this.nextT = Double.MAX_VALUE;\n+            this.lenAtNextT = Double.MAX_VALUE;\n+            this.lenAtLastSplit = Double.MIN_VALUE;\n@@ -676,1 +675,1 @@\n-            this.lastSegLen = Float.MAX_VALUE;\n+            this.lastSegLen = Double.MAX_VALUE;\n@@ -689,1 +688,1 @@\n-                    Arrays.fill(recCurveStack[i], 0.0f);\n+                    Arrays.fill(recCurveStack[i], 0.0d);\n@@ -692,4 +691,4 @@\n-                Arrays.fill(curLeafCtrlPolyLengths, 0.0f);\n-                Arrays.fill(nextRoots, 0.0f);\n-                Arrays.fill(flatLeafCoefCache, 0.0f);\n-                flatLeafCoefCache[2] = -1.0f;\n+                Arrays.fill(curLeafCtrlPolyLengths, 0.0d);\n+                Arrays.fill(nextRoots, 0.0d);\n+                Arrays.fill(flatLeafCoefCache, 0.0d);\n+                flatLeafCoefCache[2] = -1.0d;\n@@ -699,1 +698,1 @@\n-        void initializeIterationOnCurve(final float[] pts, final int type) {\n+        void initializeIterationOnCurve(final double[] pts, final int type) {\n@@ -704,4 +703,4 @@\n-            this.lastT = 0.0f;\n-            this.lenAtLastT = 0.0f;\n-            this.nextT = 0.0f;\n-            this.lenAtNextT = 0.0f;\n+            this.lastT = 0.0d;\n+            this.lenAtLastT = 0.0d;\n+            this.nextT = 0.0d;\n+            this.lenAtNextT = 0.0d;\n@@ -709,1 +708,1 @@\n-            this.lenAtLastSplit = 0.0f;\n+            this.lenAtLastSplit = 0.0d;\n@@ -718,1 +717,1 @@\n-            this.lastSegLen = 0.0f;\n+            this.lastSegLen = 0.0d;\n@@ -724,1 +723,1 @@\n-        private boolean haveLowAcceleration(final float err) {\n+        private boolean haveLowAcceleration(final double err) {\n@@ -726,2 +725,2 @@\n-                final float len1 = curLeafCtrlPolyLengths[0];\n-                final float len2 = curLeafCtrlPolyLengths[1];\n+                final double len1 = curLeafCtrlPolyLengths[0];\n+                final double len2 = curLeafCtrlPolyLengths[1];\n@@ -736,1 +735,1 @@\n-                    final float len3 = curLeafCtrlPolyLengths[2];\n+                    final double len3 = curLeafCtrlPolyLengths[2];\n@@ -740,1 +739,1 @@\n-                    final float errLen3 = err * len3;\n+                    final double errLen3 = err * len3;\n@@ -756,1 +755,1 @@\n-        private final float[] nextRoots = new float[4];\n+        private final double[] nextRoots = new double[4];\n@@ -762,1 +761,1 @@\n-        private final float[] flatLeafCoefCache = new float[]{0.0f, 0.0f, -1.0f, 0.0f};\n+        private final double[] flatLeafCoefCache = new double[]{0.0d, 0.0d, -1.0d, 0.0d};\n@@ -767,2 +766,2 @@\n-        float next(final float len) {\n-            final float targetLength = lenAtLastSplit + len;\n+        double next(final double len) {\n+            final double targetLength = lenAtLastSplit + len;\n@@ -772,1 +771,1 @@\n-                    return 1.0f;\n+                    return 1.0d;\n@@ -777,2 +776,2 @@\n-            final float leaflen = lenAtNextT - lenAtLastT;\n-            float t = (targetLength - lenAtLastT) \/ leaflen;\n+            final double leaflen = lenAtNextT - lenAtLastT;\n+            double t = (targetLength - lenAtLastT) \/ leaflen;\n@@ -782,1 +781,1 @@\n-            if (!haveLowAcceleration(0.05f)) {\n+            if (!haveLowAcceleration(0.05d)) {\n@@ -787,1 +786,1 @@\n-                final float[] _flatLeafCoefCache = flatLeafCoefCache;\n+                final double[] _flatLeafCoefCache = flatLeafCoefCache;\n@@ -789,3 +788,3 @@\n-                if (_flatLeafCoefCache[2] < 0.0f) {\n-                    float x =     curLeafCtrlPolyLengths[0],\n-                          y = x + curLeafCtrlPolyLengths[1];\n+                if (_flatLeafCoefCache[2] < 0.0d) {\n+                    double x =     curLeafCtrlPolyLengths[0],\n+                           y = x + curLeafCtrlPolyLengths[1];\n@@ -793,4 +792,4 @@\n-                        float z = y + curLeafCtrlPolyLengths[2];\n-                        _flatLeafCoefCache[0] = 3.0f * (x - y) + z;\n-                        _flatLeafCoefCache[1] = 3.0f * (y - 2.0f * x);\n-                        _flatLeafCoefCache[2] = 3.0f * x;\n+                        double z = y + curLeafCtrlPolyLengths[2];\n+                        _flatLeafCoefCache[0] = 3.0d * (x - y) + z;\n+                        _flatLeafCoefCache[1] = 3.0d * (y - 2.0d * x);\n+                        _flatLeafCoefCache[2] = 3.0d * x;\n@@ -799,3 +798,3 @@\n-                        _flatLeafCoefCache[0] = 0.0f;\n-                        _flatLeafCoefCache[1] = y - 2.0f * x;\n-                        _flatLeafCoefCache[2] = 2.0f * x;\n+                        _flatLeafCoefCache[0] = 0.0d;\n+                        _flatLeafCoefCache[1] = y - 2.0d * x;\n+                        _flatLeafCoefCache[2] = 2.0d * x;\n@@ -805,4 +804,4 @@\n-                float a = _flatLeafCoefCache[0];\n-                float b = _flatLeafCoefCache[1];\n-                float c = _flatLeafCoefCache[2];\n-                float d = t * _flatLeafCoefCache[3];\n+                double a = _flatLeafCoefCache[0];\n+                double b = _flatLeafCoefCache[1];\n+                double c = _flatLeafCoefCache[2];\n+                double d = t * _flatLeafCoefCache[3];\n@@ -813,2 +812,2 @@\n-                final int n = Helpers.cubicRootsInAB(a, b, c, d, nextRoots, 0, 0.0f, 1.0f);\n-                if (n == 1 && !Float.isNaN(nextRoots[0])) {\n+                final int n = Helpers.cubicRootsInAB(a, b, c, d, nextRoots, 0, 0.0d, 1.0d);\n+                if (n == 1 && !Double.isNaN(nextRoots[0])) {\n@@ -821,2 +820,2 @@\n-            if (t >= 1.0f) {\n-                t = 1.0f;\n+            if (t >= 1.0d) {\n+                t = 1.0d;\n@@ -834,1 +833,1 @@\n-        float totalLength() {\n+        double totalLength() {\n@@ -844,1 +843,1 @@\n-        float lastSegLen() {\n+        double lastSegLen() {\n@@ -876,2 +875,2 @@\n-            final float len = onLeaf();\n-            if (len >= 0.0f) {\n+            final double len = onLeaf();\n+            if (len >= 0.0d) {\n@@ -883,1 +882,1 @@\n-                flatLeafCoefCache[2] = -1.0f;\n+                flatLeafCoefCache[2] = -1.0d;\n@@ -887,2 +886,2 @@\n-                                  recCurveStack[recLevel + 1],\n-                                  recCurveStack[recLevel], curveType);\n+                                   recCurveStack[recLevel + 1],\n+                                   recCurveStack[recLevel], curveType);\n@@ -898,2 +897,2 @@\n-        private float onLeaf() {\n-            final float[] curve = recCurveStack[recLevel];\n+        private double onLeaf() {\n+            final double[] curve = recCurveStack[recLevel];\n@@ -901,1 +900,1 @@\n-            float polyLen = 0.0f;\n+            double polyLen = 0.0d;\n@@ -903,1 +902,1 @@\n-            float x0 = curve[0], y0 = curve[1];\n+            double x0 = curve[0], y0 = curve[1];\n@@ -905,2 +904,2 @@\n-                final float x1 = curve[i], y1 = curve[i + 1];\n-                final float len = Helpers.linelen(x0, y0, x1, y1);\n+                final double x1 = curve[i], y1 = curve[i + 1];\n+                final double len = Helpers.linelen(x0, y0, x1, y1);\n@@ -913,1 +912,1 @@\n-            final float lineLen = Helpers.linelen(curve[0], curve[1], x0, y0);\n+            final double lineLen = Helpers.linelen(curve[0], curve[1], x0, y0);\n@@ -916,1 +915,1 @@\n-                return (polyLen + lineLen) \/ 2.0f;\n+                return (polyLen + lineLen) \/ 2.0d;\n@@ -918,1 +917,1 @@\n-            return -1.0f;\n+            return -1.0d;\n@@ -923,3 +922,3 @@\n-    public void curveTo(final float x1, final float y1,\n-                        final float x2, final float y2,\n-                        final float x3, final float y3)\n+    public void curveTo(final double x1, final double y1,\n+                        final double x2, final double y2,\n+                        final double x3, final double y3)\n@@ -973,3 +972,3 @@\n-    private void _curveTo(final float x1, final float y1,\n-                          final float x2, final float y2,\n-                          final float x3, final float y3)\n+    private void _curveTo(final double x1, final double y1,\n+                          final double x2, final double y2,\n+                          final double x3, final double y3)\n@@ -977,1 +976,1 @@\n-        final float[] _curCurvepts = curCurvepts;\n+        final double[] _curCurvepts = curCurvepts;\n@@ -984,1 +983,1 @@\n-        final float[] mid = monotonizer.middle;\n+        final double[] mid = monotonizer.middle;\n@@ -994,3 +993,3 @@\n-    private void skipCurveTo(final float x1, final float y1,\n-                             final float x2, final float y2,\n-                             final float x3, final float y3)\n+    private void skipCurveTo(final double x1, final double y1,\n+                             final double x2, final double y2,\n+                             final double x3, final double y3)\n@@ -998,1 +997,1 @@\n-        final float[] _curCurvepts = curCurvepts;\n+        final double[] _curCurvepts = curCurvepts;\n@@ -1011,2 +1010,2 @@\n-    public void quadTo(final float x1, final float y1,\n-                       final float x2, final float y2)\n+    public void quadTo(final double x1, final double y1,\n+                       final double x2, final double y2)\n@@ -1059,2 +1058,2 @@\n-    private void _quadTo(final float x1, final float y1,\n-                         final float x2, final float y2)\n+    private void _quadTo(final double x1, final double y1,\n+                         final double x2, final double y2)\n@@ -1062,1 +1061,1 @@\n-        final float[] _curCurvepts = curCurvepts;\n+        final double[] _curCurvepts = curCurvepts;\n@@ -1069,1 +1068,1 @@\n-        final float[] mid = monotonizer.middle;\n+        final double[] mid = monotonizer.middle;\n@@ -1079,2 +1078,2 @@\n-    private void skipQuadTo(final float x1, final float y1,\n-                            final float x2, final float y2)\n+    private void skipQuadTo(final double x1, final double y1,\n+                            final double x2, final double y2)\n@@ -1082,1 +1081,1 @@\n-        final float[] _curCurvepts = curCurvepts;\n+        final double[] _curCurvepts = curCurvepts;\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/marlin\/Dasher.java","additions":183,"deletions":184,"binary":false,"changes":367,"status":"modified"},{"patch":"@@ -1,269 +0,0 @@\n-\/*\n- * Copyright (c) 2015, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package sun.java2d.marlin;\n-\n-import static sun.java2d.marlin.ArrayCacheConst.ARRAY_SIZES;\n-import static sun.java2d.marlin.ArrayCacheConst.BUCKETS;\n-import static sun.java2d.marlin.ArrayCacheConst.MAX_ARRAY_SIZE;\n-import static sun.java2d.marlin.MarlinUtils.logInfo;\n-import static sun.java2d.marlin.MarlinUtils.logException;\n-\n-import java.lang.ref.WeakReference;\n-import java.util.Arrays;\n-\n-import sun.java2d.marlin.ArrayCacheConst.BucketStats;\n-import sun.java2d.marlin.ArrayCacheConst.CacheStats;\n-\n-\/*\n- * Note that the [BYTE\/INT\/FLOAT\/DOUBLE]ArrayCache files are nearly identical except\n- * for a few type and name differences. Typically, the [BYTE]ArrayCache.java file\n- * is edited manually and then [INT\/FLOAT\/DOUBLE]ArrayCache.java\n- * files are generated with the following command lines:\n- *\/\n-\/\/ % sed -e 's\/(b\\yte)[ ]*\/\/g' -e 's\/b\\yte\/int\/g' -e 's\/B\\yte\/Int\/g' < B\\yteArrayCache.java > IntArrayCache.java\n-\/\/ % sed -e 's\/(b\\yte)[ ]*0\/0.0f\/g' -e 's\/(b\\yte)[ ]*\/(float) \/g' -e 's\/b\\yte\/float\/g' -e 's\/B\\yte\/Float\/g' < B\\yteArrayCache.java > FloatArrayCache.java\n-\/\/ % sed -e 's\/(b\\yte)[ ]*0\/0.0d\/g' -e 's\/(b\\yte)[ ]*\/(double) \/g' -e 's\/b\\yte\/double\/g' -e 's\/B\\yte\/Double\/g' < B\\yteArrayCache.java > DoubleArrayCache.java\n-\n-final class FloatArrayCache implements MarlinConst {\n-\n-    final boolean clean;\n-    private final int bucketCapacity;\n-    private WeakReference<Bucket[]> refBuckets = null;\n-    final CacheStats stats;\n-\n-    FloatArrayCache(final boolean clean, final int bucketCapacity) {\n-        this.clean = clean;\n-        this.bucketCapacity = bucketCapacity;\n-        this.stats = (DO_STATS) ?\n-            new CacheStats(getLogPrefix(clean) + \"FloatArrayCache\") : null;\n-    }\n-\n-    Bucket getCacheBucket(final int length) {\n-        final int bucket = ArrayCacheConst.getBucket(length);\n-        return getBuckets()[bucket];\n-    }\n-\n-    private Bucket[] getBuckets() {\n-        \/\/ resolve reference:\n-        Bucket[] buckets = (refBuckets != null) ? refBuckets.get() : null;\n-\n-        \/\/ create a new buckets ?\n-        if (buckets == null) {\n-            buckets = new Bucket[BUCKETS];\n-\n-            for (int i = 0; i < BUCKETS; i++) {\n-                buckets[i] = new Bucket(clean, ARRAY_SIZES[i], bucketCapacity,\n-                        (DO_STATS) ? stats.bucketStats[i] : null);\n-            }\n-\n-            \/\/ update weak reference:\n-            refBuckets = new WeakReference<Bucket[]>(buckets);\n-        }\n-        return buckets;\n-    }\n-\n-    Reference createRef(final int initialSize) {\n-        return new Reference(this, initialSize);\n-    }\n-\n-    static final class Reference {\n-\n-        \/\/ initial array reference (direct access)\n-        final float[] initial;\n-        private final boolean clean;\n-        private final FloatArrayCache cache;\n-\n-        Reference(final FloatArrayCache cache, final int initialSize) {\n-            this.cache = cache;\n-            this.clean = cache.clean;\n-            this.initial = createArray(initialSize);\n-            if (DO_STATS) {\n-                cache.stats.totalInitial += initialSize;\n-            }\n-        }\n-\n-        float[] getArray(final int length) {\n-            if (length <= MAX_ARRAY_SIZE) {\n-                return cache.getCacheBucket(length).getArray();\n-            }\n-            if (DO_STATS) {\n-                cache.stats.oversize++;\n-            }\n-            if (DO_LOG_OVERSIZE) {\n-                logInfo(getLogPrefix(clean) + \"FloatArrayCache: \"\n-                        + \"getArray[oversize]: length=\\t\" + length);\n-            }\n-            return createArray(length);\n-        }\n-\n-        float[] widenArray(final float[] array, final int usedSize,\n-                          final int needSize)\n-        {\n-            final int length = array.length;\n-            if (DO_CHECKS && length >= needSize) {\n-                return array;\n-            }\n-            if (DO_STATS) {\n-                cache.stats.resize++;\n-            }\n-\n-            \/\/ maybe change bucket:\n-            \/\/ ensure getNewSize() > newSize:\n-            final float[] res = getArray(ArrayCacheConst.getNewSize(usedSize, needSize));\n-\n-            \/\/ use wrapper to ensure proper copy:\n-            System.arraycopy(array, 0, res, 0, usedSize); \/\/ copy only used elements\n-\n-            \/\/ maybe return current array:\n-            putArray(array, 0, usedSize); \/\/ ensure array is cleared\n-\n-            if (DO_LOG_WIDEN_ARRAY) {\n-                logInfo(getLogPrefix(clean) + \"FloatArrayCache: \"\n-                        + \"widenArray[\" + res.length\n-                        + \"]: usedSize=\\t\" + usedSize + \"\\tlength=\\t\" + length\n-                        + \"\\tneeded length=\\t\" + needSize);\n-            }\n-            return res;\n-        }\n-\n-        float[] putArray(final float[] array)\n-        {\n-            \/\/ dirty array helper:\n-            return putArray(array, 0, array.length);\n-        }\n-\n-        float[] putArray(final float[] array, final int fromIndex,\n-                        final int toIndex)\n-        {\n-            if (array.length <= MAX_ARRAY_SIZE) {\n-                if ((clean || DO_CLEAN_DIRTY) && (toIndex != 0)) {\n-                    \/\/ clean-up array of dirty part[fromIndex; toIndex[\n-                    fill(array, fromIndex, toIndex, 0.0f);\n-                }\n-                \/\/ ensure to never store initial arrays in cache:\n-                if (array != initial) {\n-                    cache.getCacheBucket(array.length).putArray(array);\n-                }\n-            }\n-            return initial;\n-        }\n-    }\n-\n-    static final class Bucket {\n-\n-        private int tail = 0;\n-        private final int arraySize;\n-        private final boolean clean;\n-        private final float[][] arrays;\n-        private final BucketStats stats;\n-\n-        Bucket(final boolean clean, final int arraySize,\n-               final int capacity, final BucketStats stats)\n-        {\n-            this.arraySize = arraySize;\n-            this.clean = clean;\n-            this.stats = stats;\n-            this.arrays = new float[capacity][];\n-        }\n-\n-        float[] getArray() {\n-            if (DO_STATS) {\n-                stats.getOp++;\n-            }\n-            \/\/ use cache:\n-            if (tail != 0) {\n-                final float[] array = arrays[--tail];\n-                arrays[tail] = null;\n-                return array;\n-            }\n-            if (DO_STATS) {\n-                stats.createOp++;\n-            }\n-            return createArray(arraySize);\n-        }\n-\n-        void putArray(final float[] array)\n-        {\n-            if (DO_CHECKS && (array.length != arraySize)) {\n-                logInfo(getLogPrefix(clean) + \"FloatArrayCache: \"\n-                        + \"bad length = \" + array.length);\n-                return;\n-            }\n-            if (DO_STATS) {\n-                stats.returnOp++;\n-            }\n-            \/\/ fill cache:\n-            if (arrays.length > tail) {\n-                arrays[tail++] = array;\n-\n-                if (DO_STATS) {\n-                    stats.updateMaxSize(tail);\n-                }\n-            } else if (DO_CHECKS) {\n-                logInfo(getLogPrefix(clean) + \"FloatArrayCache: \"\n-                        + \"array capacity exceeded !\");\n-            }\n-        }\n-    }\n-\n-    static float[] createArray(final int length) {\n-        return new float[length];\n-    }\n-\n-    static void fill(final float[] array, final int fromIndex,\n-                     final int toIndex, final float value)\n-    {\n-        \/\/ clear array data:\n-        Arrays.fill(array, fromIndex, toIndex, value);\n-        if (DO_CHECKS) {\n-            check(array, fromIndex, toIndex, value);\n-        }\n-    }\n-\n-    static void check(final float[] array, final int fromIndex,\n-                      final int toIndex, final float value)\n-    {\n-        if (DO_CHECKS) {\n-            \/\/ check zero on full array:\n-            for (int i = 0; i < array.length; i++) {\n-                if (array[i] != value) {\n-                    logException(\"Invalid value at: \" + i + \" = \" + array[i]\n-                            + \" from: \" + fromIndex + \" to: \" + toIndex + \"\\n\"\n-                            + Arrays.toString(array), new Throwable());\n-\n-                    \/\/ ensure array is correctly filled:\n-                    Arrays.fill(array, value);\n-\n-                    return;\n-                }\n-            }\n-        }\n-    }\n-\n-    static String getLogPrefix(final boolean clean) {\n-        return (clean) ? \"Clean\" : \"Dirty\";\n-    }\n-}\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/marlin\/FloatArrayCache.java","additions":0,"deletions":269,"binary":false,"changes":269,"status":"deleted"},{"patch":"@@ -29,1 +29,0 @@\n-import sun.awt.geom.PathConsumer2D;\n@@ -39,5 +38,0 @@\n-    static boolean within(final float x, final float y, final float err) {\n-        final float d = y - x;\n-        return (d <= err && d >= -err);\n-    }\n-\n@@ -49,3 +43,3 @@\n-    static float evalCubic(final float a, final float b,\n-                           final float c, final float d,\n-                           final float t)\n+    static double evalCubic(final double a, final double b,\n+                            final double c, final double d,\n+                            final double t)\n@@ -56,2 +50,2 @@\n-    static float evalQuad(final float a, final float b,\n-                          final float c, final float t)\n+    static double evalQuad(final double a, final double b,\n+                           final double c, final double t)\n@@ -62,2 +56,2 @@\n-    static int quadraticRoots(final float a, final float b, final float c,\n-                              final float[] zeroes, final int off)\n+    static int quadraticRoots(final double a, final double b, final double c,\n+                              final double[] zeroes, final int off)\n@@ -66,4 +60,4 @@\n-        if (a != 0.0f) {\n-            final float dis = b*b - 4.0f * a * c;\n-            if (dis > 0.0f) {\n-                final float sqrtDis = (float) Math.sqrt(dis);\n+        if (a != 0.0d) {\n+            final double dis = b*b - 4.0d * a * c;\n+            if (dis > 0.0d) {\n+                final double sqrtDis = Math.sqrt(dis);\n@@ -74,3 +68,3 @@\n-                if (b >= 0.0f) {\n-                    zeroes[ret++] = (2.0f * c) \/ (-b - sqrtDis);\n-                    zeroes[ret++] = (-b - sqrtDis) \/ (2.0f * a);\n+                if (b >= 0.0d) {\n+                    zeroes[ret++] = (2.0d * c) \/ (-b - sqrtDis);\n+                    zeroes[ret++] = (-b - sqrtDis) \/ (2.0d * a);\n@@ -78,2 +72,2 @@\n-                    zeroes[ret++] = (-b + sqrtDis) \/ (2.0f * a);\n-                    zeroes[ret++] = (2.0f * c) \/ (-b + sqrtDis);\n+                    zeroes[ret++] = (-b + sqrtDis) \/ (2.0d * a);\n+                    zeroes[ret++] = (2.0d * c) \/ (-b + sqrtDis);\n@@ -81,2 +75,2 @@\n-            } else if (dis == 0.0f) {\n-                zeroes[ret++] = -b \/ (2.0f * a);\n+            } else if (dis == 0.0d) {\n+                zeroes[ret++] = -b \/ (2.0d * a);\n@@ -84,1 +78,1 @@\n-        } else if (b != 0.0f) {\n+        } else if (b != 0.0d) {\n@@ -91,3 +85,3 @@\n-    static int cubicRootsInAB(final float d0, float a0, float b0, float c0,\n-                              final float[] pts, final int off,\n-                              final float A, final float B)\n+    static int cubicRootsInAB(final double d, double a, double b, double c,\n+                              final double[] pts, final int off,\n+                              final double A, final double B)\n@@ -95,2 +89,2 @@\n-        if (d0 == 0.0f) {\n-            final int num = quadraticRoots(a0, b0, c0, pts, off);\n+        if (d == 0.0d) {\n+            final int num = quadraticRoots(a, b, c, pts, off);\n@@ -107,1 +101,0 @@\n-        \/\/ 2018.1: Need double precision if d is very small (flat curve) !\n@@ -111,3 +104,3 @@\n-        final double a = ((double)a0) \/ d0;\n-        final double b = ((double)b0) \/ d0;\n-        final double c = ((double)c0) \/ d0;\n+        a \/= d;\n+        b \/= d;\n+        c \/= d;\n@@ -139,3 +132,3 @@\n-            pts[off    ] = (float) ( t * Math.cos(phi) - sub);\n-            pts[off + 1] = (float) (-t * Math.cos(phi + (Math.PI \/ 3.0d)) - sub);\n-            pts[off + 2] = (float) (-t * Math.cos(phi - (Math.PI \/ 3.0d)) - sub);\n+            pts[off    ] = ( t * Math.cos(phi) - sub);\n+            pts[off + 1] = (-t * Math.cos(phi + (Math.PI \/ 3.0d)) - sub);\n+            pts[off + 2] = (-t * Math.cos(phi - (Math.PI \/ 3.0d)) - sub);\n@@ -148,1 +141,1 @@\n-            pts[off    ] = (float) (u + v - sub);\n+            pts[off    ] = (u + v - sub);\n@@ -152,1 +145,1 @@\n-                pts[off + 1] = (float)((-1.0d \/ 2.0d) * (u + v) - sub);\n+                pts[off + 1] = ((-1.0d \/ 2.0d) * (u + v) - sub);\n@@ -161,2 +154,2 @@\n-    static int filterOutNotInAB(final float[] nums, final int off, final int len,\n-                                final float a, final float b)\n+    static int filterOutNotInAB(final double[] nums, final int off, final int len,\n+                                final double a, final double b)\n@@ -173,2 +166,2 @@\n-    static float fastLineLen(final float x0, final float y0,\n-                             final float x1, final float y1)\n+    static double fastLineLen(final double x0, final double y0,\n+                              final double x1, final double y1)\n@@ -176,2 +169,2 @@\n-        final float dx = x1 - x0;\n-        final float dy = y1 - y0;\n+        final double dx = x1 - x0;\n+        final double dy = y1 - y0;\n@@ -183,2 +176,2 @@\n-    static float linelen(final float x0, final float y0,\n-                         final float x1, final float y1)\n+    static double linelen(final double x0, final double y0,\n+                          final double x1, final double y1)\n@@ -186,3 +179,3 @@\n-        final float dx = x1 - x0;\n-        final float dy = y1 - y0;\n-        return (float) Math.sqrt(dx * dx + dy * dy);\n+        final double dx = x1 - x0;\n+        final double dy = y1 - y0;\n+        return Math.sqrt(dx * dx + dy * dy);\n@@ -191,3 +184,3 @@\n-    static float fastQuadLen(final float x0, final float y0,\n-                             final float x1, final float y1,\n-                             final float x2, final float y2)\n+    static double fastQuadLen(final double x0, final double y0,\n+                              final double x1, final double y1,\n+                              final double x2, final double y2)\n@@ -195,4 +188,4 @@\n-        final float dx1 = x1 - x0;\n-        final float dx2 = x2 - x1;\n-        final float dy1 = y1 - y0;\n-        final float dy2 = y2 - y1;\n+        final double dx1 = x1 - x0;\n+        final double dx2 = x2 - x1;\n+        final double dy1 = y1 - y0;\n+        final double dy2 = y2 - y1;\n@@ -205,3 +198,3 @@\n-    static float quadlen(final float x0, final float y0,\n-                         final float x1, final float y1,\n-                         final float x2, final float y2)\n+    static double quadlen(final double x0, final double y0,\n+                          final double x1, final double y1,\n+                          final double x2, final double y2)\n@@ -211,1 +204,1 @@\n-                + linelen(x0, y0, x2, y2)) \/ 2.0f;\n+                + linelen(x0, y0, x2, y2)) \/ 2.0d;\n@@ -214,5 +207,4 @@\n-\n-    static float fastCurvelen(final float x0, final float y0,\n-                              final float x1, final float y1,\n-                              final float x2, final float y2,\n-                              final float x3, final float y3)\n+    static double fastCurvelen(final double x0, final double y0,\n+                               final double x1, final double y1,\n+                               final double x2, final double y2,\n+                               final double x3, final double y3)\n@@ -220,6 +212,6 @@\n-        final float dx1 = x1 - x0;\n-        final float dx2 = x2 - x1;\n-        final float dx3 = x3 - x2;\n-        final float dy1 = y1 - y0;\n-        final float dy2 = y2 - y1;\n-        final float dy3 = y3 - y2;\n+        final double dx1 = x1 - x0;\n+        final double dx2 = x2 - x1;\n+        final double dx3 = x3 - x2;\n+        final double dy1 = y1 - y0;\n+        final double dy2 = y2 - y1;\n+        final double dy3 = y3 - y2;\n@@ -232,4 +224,4 @@\n-    static float curvelen(final float x0, final float y0,\n-                          final float x1, final float y1,\n-                          final float x2, final float y2,\n-                          final float x3, final float y3)\n+    static double curvelen(final double x0, final double y0,\n+                           final double x1, final double y1,\n+                           final double x2, final double y2,\n+                           final double x3, final double y3)\n@@ -240,1 +232,1 @@\n-              + linelen(x0, y0, x3, y3)) \/ 2.0f;\n+              + linelen(x0, y0, x3, y3)) \/ 2.0d;\n@@ -246,3 +238,3 @@\n-    static int findSubdivPoints(final Curve c, final float[] pts,\n-                                final float[] ts, final int type,\n-                                final float w2)\n+    static int findSubdivPoints(final Curve c, final double[] pts,\n+                                final double[] ts, final int type,\n+                                final double w2)\n@@ -250,2 +242,2 @@\n-        final float x12 = pts[2] - pts[0];\n-        final float y12 = pts[3] - pts[1];\n+        final double x12 = pts[2] - pts[0];\n+        final double y12 = pts[3] - pts[1];\n@@ -254,1 +246,1 @@\n-        if ((y12 != 0.0f) && (x12 != 0.0f)) {\n+        if ((y12 != 0.0d) && (x12 != 0.0d)) {\n@@ -258,9 +250,9 @@\n-            final float hypot = (float)Math.sqrt(x12 * x12 + y12 * y12);\n-            final float cos = x12 \/ hypot;\n-            final float sin = y12 \/ hypot;\n-            final float x1 = cos * pts[0] + sin * pts[1];\n-            final float y1 = cos * pts[1] - sin * pts[0];\n-            final float x2 = cos * pts[2] + sin * pts[3];\n-            final float y2 = cos * pts[3] - sin * pts[2];\n-            final float x3 = cos * pts[4] + sin * pts[5];\n-            final float y3 = cos * pts[5] - sin * pts[4];\n+            final double hypot = Math.sqrt(x12 * x12 + y12 * y12);\n+            final double cos = x12 \/ hypot;\n+            final double sin = y12 \/ hypot;\n+            final double x1 = cos * pts[0] + sin * pts[1];\n+            final double y1 = cos * pts[1] - sin * pts[0];\n+            final double x2 = cos * pts[2] + sin * pts[3];\n+            final double y2 = cos * pts[3] - sin * pts[2];\n+            final double x3 = cos * pts[4] + sin * pts[5];\n+            final double y3 = cos * pts[5] - sin * pts[4];\n@@ -270,2 +262,2 @@\n-                final float x4 = cos * pts[6] + sin * pts[7];\n-                final float y4 = cos * pts[7] - sin * pts[6];\n+                final double x4 = cos * pts[6] + sin * pts[7];\n+                final double y4 = cos * pts[7] - sin * pts[6];\n@@ -297,1 +289,1 @@\n-        ret += c.rootsOfROCMinusW(ts, ret, w2, 0.0001f);\n+        ret += c.rootsOfROCMinusW(ts, ret, w2, 0.0001d);\n@@ -299,1 +291,1 @@\n-        ret = filterOutNotInAB(ts, 0, ret, 0.0001f, 0.9999f);\n+        ret = filterOutNotInAB(ts, 0, ret, 0.0001d, 0.9999d);\n@@ -307,2 +299,2 @@\n-    static int findClipPoints(final Curve curve, final float[] pts,\n-                              final float[] ts, final int type,\n+    static int findClipPoints(final Curve curve, final double[] pts,\n+                              final double[] ts, final int type,\n@@ -310,1 +302,1 @@\n-                              final float[] clipRect)\n+                              final double[] clipRect)\n@@ -333,2 +325,2 @@\n-    static void subdivide(final float[] src,\n-                          final float[] left, final float[] right,\n+    static void subdivide(final double[] src,\n+                          final double[] left, final double[] right,\n@@ -349,1 +341,1 @@\n-    static void isort(final float[] a, final int len) {\n+    static void isort(final double[] a, final int len) {\n@@ -351,1 +343,1 @@\n-            final float ai = a[i];\n+            final double ai = a[i];\n@@ -385,3 +377,3 @@\n-    static void subdivideCubic(final float[] src,\n-                               final float[] left,\n-                               final float[] right)\n+    static void subdivideCubic(final double[] src,\n+                               final double[] left,\n+                               final double[] right)\n@@ -389,8 +381,8 @@\n-        float  x1 = src[0];\n-        float  y1 = src[1];\n-        float cx1 = src[2];\n-        float cy1 = src[3];\n-        float cx2 = src[4];\n-        float cy2 = src[5];\n-        float  x2 = src[6];\n-        float  y2 = src[7];\n+        double  x1 = src[0];\n+        double  y1 = src[1];\n+        double cx1 = src[2];\n+        double cy1 = src[3];\n+        double cx2 = src[4];\n+        double cy2 = src[5];\n+        double  x2 = src[6];\n+        double  y2 = src[7];\n@@ -404,4 +396,4 @@\n-        x1 = (x1 + cx1) \/ 2.0f;\n-        y1 = (y1 + cy1) \/ 2.0f;\n-        x2 = (x2 + cx2) \/ 2.0f;\n-        y2 = (y2 + cy2) \/ 2.0f;\n+        x1 = (x1 + cx1) \/ 2.0d;\n+        y1 = (y1 + cy1) \/ 2.0d;\n+        x2 = (x2 + cx2) \/ 2.0d;\n+        y2 = (y2 + cy2) \/ 2.0d;\n@@ -409,2 +401,2 @@\n-        float cx = (cx1 + cx2) \/ 2.0f;\n-        float cy = (cy1 + cy2) \/ 2.0f;\n+        double cx = (cx1 + cx2) \/ 2.0d;\n+        double cy = (cy1 + cy2) \/ 2.0d;\n@@ -412,6 +404,6 @@\n-        cx1 = (x1 + cx) \/ 2.0f;\n-        cy1 = (y1 + cy) \/ 2.0f;\n-        cx2 = (x2 + cx) \/ 2.0f;\n-        cy2 = (y2 + cy) \/ 2.0f;\n-        cx  = (cx1 + cx2) \/ 2.0f;\n-        cy  = (cy1 + cy2) \/ 2.0f;\n+        cx1 = (x1 + cx) \/ 2.0d;\n+        cy1 = (y1 + cy) \/ 2.0d;\n+        cx2 = (x2 + cx) \/ 2.0d;\n+        cy2 = (y2 + cy) \/ 2.0d;\n+        cx  = (cx1 + cx2) \/ 2.0d;\n+        cy  = (cy1 + cy2) \/ 2.0d;\n@@ -434,3 +426,3 @@\n-    static void subdivideCubicAt(final float t,\n-                                 final float[] src, final int offS,\n-                                 final float[] pts, final int offL, final int offR)\n+    static void subdivideCubicAt(final double t,\n+                                 final double[] src, final int offS,\n+                                 final double[] pts, final int offL, final int offR)\n@@ -438,8 +430,8 @@\n-        float  x1 = src[offS    ];\n-        float  y1 = src[offS + 1];\n-        float cx1 = src[offS + 2];\n-        float cy1 = src[offS + 3];\n-        float cx2 = src[offS + 4];\n-        float cy2 = src[offS + 5];\n-        float  x2 = src[offS + 6];\n-        float  y2 = src[offS + 7];\n+        double  x1 = src[offS    ];\n+        double  y1 = src[offS + 1];\n+        double cx1 = src[offS + 2];\n+        double cy1 = src[offS + 3];\n+        double cx2 = src[offS + 4];\n+        double cy2 = src[offS + 5];\n+        double  x2 = src[offS + 6];\n+        double  y2 = src[offS + 7];\n@@ -458,2 +450,2 @@\n-        float cx = cx1 + t * (cx2 - cx1);\n-        float cy = cy1 + t * (cy2 - cy1);\n+        double cx = cx1 + t * (cx2 - cx1);\n+        double cy = cy1 + t * (cy2 - cy1);\n@@ -483,3 +475,3 @@\n-    static void subdivideQuad(final float[] src,\n-                              final float[] left,\n-                              final float[] right)\n+    static void subdivideQuad(final double[] src,\n+                              final double[] left,\n+                              final double[] right)\n@@ -487,6 +479,6 @@\n-        float x1 = src[0];\n-        float y1 = src[1];\n-        float cx = src[2];\n-        float cy = src[3];\n-        float x2 = src[4];\n-        float y2 = src[5];\n+        double x1 = src[0];\n+        double y1 = src[1];\n+        double cx = src[2];\n+        double cy = src[3];\n+        double x2 = src[4];\n+        double y2 = src[5];\n@@ -500,6 +492,6 @@\n-        x1 = (x1 + cx) \/ 2.0f;\n-        y1 = (y1 + cy) \/ 2.0f;\n-        x2 = (x2 + cx) \/ 2.0f;\n-        y2 = (y2 + cy) \/ 2.0f;\n-        cx = (x1 + x2) \/ 2.0f;\n-        cy = (y1 + y2) \/ 2.0f;\n+        x1 = (x1 + cx) \/ 2.0d;\n+        y1 = (y1 + cy) \/ 2.0d;\n+        x2 = (x2 + cx) \/ 2.0d;\n+        y2 = (y2 + cy) \/ 2.0d;\n+        cx = (x1 + x2) \/ 2.0d;\n+        cy = (y1 + y2) \/ 2.0d;\n@@ -518,3 +510,3 @@\n-    static void subdivideQuadAt(final float t,\n-                                final float[] src, final int offS,\n-                                final float[] pts, final int offL, final int offR)\n+    static void subdivideQuadAt(final double t,\n+                                final double[] src, final int offS,\n+                                final double[] pts, final int offL, final int offR)\n@@ -522,6 +514,6 @@\n-        float x1 = src[offS    ];\n-        float y1 = src[offS + 1];\n-        float cx = src[offS + 2];\n-        float cy = src[offS + 3];\n-        float x2 = src[offS + 4];\n-        float y2 = src[offS + 5];\n+        double x1 = src[offS    ];\n+        double y1 = src[offS + 1];\n+        double cx = src[offS + 2];\n+        double cy = src[offS + 3];\n+        double x2 = src[offS + 4];\n+        double y2 = src[offS + 5];\n@@ -553,3 +545,3 @@\n-    static void subdivideLineAt(final float t,\n-                                final float[] src, final int offS,\n-                                final float[] pts, final int offL, final int offR)\n+    static void subdivideLineAt(final double t,\n+                                final double[] src, final int offS,\n+                                final double[] pts, final int offL, final int offR)\n@@ -557,4 +549,4 @@\n-        float x1 = src[offS    ];\n-        float y1 = src[offS + 1];\n-        float x2 = src[offS + 2];\n-        float y2 = src[offS + 3];\n+        double x1 = src[offS    ];\n+        double y1 = src[offS + 1];\n+        double x2 = src[offS + 2];\n+        double y2 = src[offS + 3];\n@@ -578,3 +570,3 @@\n-    static void subdivideAt(final float t,\n-                            final float[] src, final int offS,\n-                            final float[] pts, final int offL, final int type)\n+    static void subdivideAt(final double t,\n+                            final double[] src, final int offS,\n+                            final double[] pts, final int offL, final int type)\n@@ -594,2 +586,2 @@\n-    static int outcode(final float x, final float y,\n-                       final float[] clipRect)\n+    static int outcode(final double x, final double y,\n+                       final double[] clipRect)\n@@ -626,1 +618,1 @@\n-        float[] curves;\n+        double[] curves;\n@@ -632,1 +624,1 @@\n-        final FloatArrayCache.Reference curves_ref;\n+        final DoubleArrayCache.Reference curves_ref;\n@@ -657,1 +649,1 @@\n-            curves_ref = rdrCtx.newDirtyFloatArrayRef(INITIAL_CURVES_COUNT); \/\/ 32K\n+            curves_ref = rdrCtx.newDirtyDoubleArrayRef(INITIAL_CURVES_COUNT); \/\/ 32K\n@@ -718,3 +710,3 @@\n-        void pushCubic(float x0, float y0,\n-                       float x1, float y1,\n-                       float x2, float y2)\n+        void pushCubic(double x0, double y0,\n+                       double x1, double y1,\n+                       double x2, double y2)\n@@ -725,1 +717,1 @@\n-            final float[] _curves = curves;\n+            final double[] _curves = curves;\n@@ -733,2 +725,2 @@\n-        void pushQuad(float x0, float y0,\n-                      float x1, float y1)\n+        void pushQuad(double x0, double y0,\n+                      double x1, double y1)\n@@ -738,1 +730,1 @@\n-            final float[] _curves = curves;\n+            final double[] _curves = curves;\n@@ -745,1 +737,1 @@\n-        void pushLine(float x, float y) {\n+        void pushLine(double x, double y) {\n@@ -751,1 +743,1 @@\n-        void pullAll(final PathConsumer2D io) {\n+        void pullAll(final DPathConsumer2D io) {\n@@ -766,1 +758,1 @@\n-            final float[] _curves = curves;\n+            final double[] _curves = curves;\n@@ -793,1 +785,1 @@\n-        void popAll(final PathConsumer2D io) {\n+        void popAll(final DPathConsumer2D io) {\n@@ -808,1 +800,1 @@\n-            final float[] _curves = curves;\n+            final double[] _curves = curves;\n@@ -961,1 +953,1 @@\n-        void pullAll(final float[] points, final PathConsumer2D io) {\n+        void pullAll(final double[] points, final DPathConsumer2D io) {\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/marlin\/Helpers.java","additions":183,"deletions":191,"binary":false,"changes":374,"status":"modified"},{"patch":"@@ -1,36 +0,0 @@\n-\/*\n- * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package sun.java2d.marlin;\n-\n-interface IRendererContext extends MarlinConst {\n-\n-    public RendererStats stats();\n-\n-    public OffHeapArray newOffHeapArray(final long initialSize);\n-\n-    public IntArrayCache.Reference newCleanIntArrayRef(final int initialSize);\n-\n-}\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/marlin\/IRendererContext.java","additions":0,"deletions":36,"binary":false,"changes":36,"status":"deleted"},{"patch":"@@ -110,1 +110,1 @@\n-    MarlinCache(final IRendererContext rdrCtx) {\n+    MarlinCache(final RendererContext rdrCtx) {\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/marlin\/MarlinCache.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,30 +0,0 @@\n-\/*\n- * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package sun.java2d.marlin;\n-\n-public interface MarlinRenderer extends MarlinConst {\n-\n-}\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/marlin\/MarlinRenderer.java","additions":0,"deletions":30,"binary":false,"changes":30,"status":"deleted"},{"patch":"@@ -1,1305 +0,0 @@\n-\/*\n- * Copyright (c) 2007, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package sun.java2d.marlin;\n-\n-import java.awt.BasicStroke;\n-import java.awt.Shape;\n-import java.awt.geom.AffineTransform;\n-import java.awt.geom.Path2D;\n-import java.awt.geom.PathIterator;\n-import java.security.AccessController;\n-import java.util.Arrays;\n-import static sun.java2d.marlin.MarlinUtils.logInfo;\n-import sun.awt.geom.PathConsumer2D;\n-import sun.java2d.ReentrantContextProvider;\n-import sun.java2d.ReentrantContextProviderCLQ;\n-import sun.java2d.ReentrantContextProviderTL;\n-import sun.java2d.pipe.AATileGenerator;\n-import sun.java2d.pipe.Region;\n-import sun.java2d.pipe.RenderingEngine;\n-import sun.security.action.GetPropertyAction;\n-\n-\/**\n- * Marlin RendererEngine implementation (derived from Pisces)\n- *\/\n-public final class MarlinRenderingEngine extends RenderingEngine\n-                                         implements MarlinConst\n-{\n-    \/\/ slightly slower ~2% if enabled stroker clipping (lines) but skipping cap \/ join handling is few percents faster in specific cases\n-    static final boolean DISABLE_2ND_STROKER_CLIPPING = true;\n-\n-    static final boolean DO_TRACE_PATH = false;\n-\n-    static final boolean DO_CLIP = MarlinProperties.isDoClip();\n-    static final boolean DO_CLIP_FILL = true;\n-    static final boolean DO_CLIP_RUNTIME_ENABLE = MarlinProperties.isDoClipRuntimeFlag();\n-\n-    private static final float MIN_PEN_SIZE = 1.0f \/ MIN_SUBPIXELS;\n-\n-    static final float UPPER_BND = Float.MAX_VALUE \/ 2.0f;\n-    static final float LOWER_BND = -UPPER_BND;\n-\n-    private enum NormMode {\n-        ON_WITH_AA {\n-            @Override\n-            PathIterator getNormalizingPathIterator(final RendererContext rdrCtx,\n-                                                    final PathIterator src)\n-            {\n-                \/\/ NormalizingPathIterator NearestPixelCenter:\n-                return rdrCtx.nPCPathIterator.init(src);\n-            }\n-        },\n-        ON_NO_AA{\n-            @Override\n-            PathIterator getNormalizingPathIterator(final RendererContext rdrCtx,\n-                                                    final PathIterator src)\n-            {\n-                \/\/ NearestPixel NormalizingPathIterator:\n-                return rdrCtx.nPQPathIterator.init(src);\n-            }\n-        },\n-        OFF{\n-            @Override\n-            PathIterator getNormalizingPathIterator(final RendererContext rdrCtx,\n-                                                    final PathIterator src)\n-            {\n-                \/\/ return original path iterator if normalization is disabled:\n-                return src;\n-            }\n-        };\n-\n-        abstract PathIterator getNormalizingPathIterator(RendererContext rdrCtx,\n-                                                         PathIterator src);\n-    }\n-\n-    \/**\n-     * Public constructor\n-     *\/\n-    public MarlinRenderingEngine() {\n-        super();\n-        logSettings(MarlinRenderingEngine.class.getName());\n-    }\n-\n-    \/**\n-     * Create a widened path as specified by the parameters.\n-     * <p>\n-     * The specified {@code src} {@link Shape} is widened according\n-     * to the specified attribute parameters as per the\n-     * {@link BasicStroke} specification.\n-     *\n-     * @param src the source path to be widened\n-     * @param width the width of the widened path as per {@code BasicStroke}\n-     * @param caps the end cap decorations as per {@code BasicStroke}\n-     * @param join the segment join decorations as per {@code BasicStroke}\n-     * @param miterlimit the miter limit as per {@code BasicStroke}\n-     * @param dashes the dash length array as per {@code BasicStroke}\n-     * @param dashphase the initial dash phase as per {@code BasicStroke}\n-     * @return the widened path stored in a new {@code Shape} object\n-     * @since 1.7\n-     *\/\n-    @Override\n-    public Shape createStrokedShape(Shape src,\n-                                    float width,\n-                                    int caps,\n-                                    int join,\n-                                    float miterlimit,\n-                                    float[] dashes,\n-                                    float dashphase)\n-    {\n-        final RendererContext rdrCtx = getRendererContext();\n-        try {\n-            \/\/ initialize a large copyable Path2D to avoid a lot of array growing:\n-            final Path2D.Float p2d = rdrCtx.getPath2D();\n-\n-            strokeTo(rdrCtx,\n-                     src,\n-                     null,\n-                     width,\n-                     NormMode.OFF,\n-                     caps,\n-                     join,\n-                     miterlimit,\n-                     dashes,\n-                     dashphase,\n-                     rdrCtx.transformerPC2D.wrapPath2D(p2d)\n-                    );\n-\n-            \/\/ Use Path2D copy constructor (trim)\n-            return new Path2D.Float(p2d);\n-\n-        } finally {\n-            \/\/ recycle the RendererContext instance\n-            returnRendererContext(rdrCtx);\n-        }\n-    }\n-\n-    \/**\n-     * Sends the geometry for a widened path as specified by the parameters\n-     * to the specified consumer.\n-     * <p>\n-     * The specified {@code src} {@link Shape} is widened according\n-     * to the parameters specified by the {@link BasicStroke} object.\n-     * Adjustments are made to the path as appropriate for the\n-     * {@link java.awt.RenderingHints#VALUE_STROKE_NORMALIZE} hint if the\n-     * {@code normalize} boolean parameter is true.\n-     * Adjustments are made to the path as appropriate for the\n-     * {@link java.awt.RenderingHints#VALUE_ANTIALIAS_ON} hint if the\n-     * {@code antialias} boolean parameter is true.\n-     * <p>\n-     * The geometry of the widened path is forwarded to the indicated\n-     * {@link PathConsumer2D} object as it is calculated.\n-     *\n-     * @param src the source path to be widened\n-     * @param at the transform to be applied to the shape and the\n-     *           stroke attributes\n-     * @param bs the {@code BasicStroke} object specifying the\n-     *           decorations to be applied to the widened path\n-     * @param thin true if the transformed stroke attributes are smaller\n-     *             than the minimum dropout pen width\n-     * @param normalize indicates whether stroke normalization should\n-     *                  be applied\n-     * @param antialias indicates whether or not adjustments appropriate\n-     *                  to antialiased rendering should be applied\n-     * @param consumer the {@code PathConsumer2D} instance to forward\n-     *                 the widened geometry to\n-     * @since 1.7\n-     *\/\n-    @Override\n-    public void strokeTo(Shape src,\n-                         AffineTransform at,\n-                         BasicStroke bs,\n-                         boolean thin,\n-                         boolean normalize,\n-                         boolean antialias,\n-                         final PathConsumer2D consumer)\n-    {\n-        strokeTo(src, at, null, bs, thin, normalize, antialias, consumer);\n-    }\n-\n-    \/**\n-     * Sends the geometry for a widened path as specified by the parameters\n-     * to the specified consumer.\n-     * <p>\n-     * The specified {@code src} {@link Shape} is widened according\n-     * to the parameters specified by the {@link BasicStroke} object.\n-     * Adjustments are made to the path as appropriate for the\n-     * {@link java.awt.RenderingHints#VALUE_STROKE_NORMALIZE} hint if the\n-     * {@code normalize} boolean parameter is true.\n-     * Adjustments are made to the path as appropriate for the\n-     * {@link java.awt.RenderingHints#VALUE_ANTIALIAS_ON} hint if the\n-     * {@code antialias} boolean parameter is true.\n-     * <p>\n-     * The geometry of the widened path is forwarded to the indicated\n-     * {@link PathConsumer2D} object as it is calculated.\n-     *\n-     * @param src the source path to be widened\n-     * @param at the transform to be applied to the shape and the\n-     *           stroke attributes\n-     * @param clip the current clip in effect in device coordinates\n-     * @param bs the {@code BasicStroke} object specifying the\n-     *           decorations to be applied to the widened path\n-     * @param thin true if the transformed stroke attributes are smaller\n-     *             than the minimum dropout pen width\n-     * @param normalize indicates whether stroke normalization should\n-     *                  be applied\n-     * @param antialias indicates whether or not adjustments appropriate\n-     *                  to antialiased rendering should be applied\n-     * @param consumer the {@code PathConsumer2D} instance to forward\n-     *                 the widened geometry to\n-     * @since 17\n-     *\/\n-\/*    @Override (only for 17+) *\/\n-    public void strokeTo(Shape src,\n-                         AffineTransform at,\n-                         Region clip,\n-                         BasicStroke bs,\n-                         boolean thin,\n-                         boolean normalize,\n-                         boolean antialias,\n-                         final PathConsumer2D consumer)\n-    {\n-        \/\/ Test if at is identity:\n-        final AffineTransform _at = (at != null && !at.isIdentity()) ? at\n-                                    : null;\n-\n-        final NormMode norm = (normalize) ?\n-                ((antialias) ? NormMode.ON_WITH_AA : NormMode.ON_NO_AA)\n-                : NormMode.OFF;\n-\n-        final RendererContext rdrCtx = getRendererContext();\n-        try {\n-            if ((clip != null) &&\n-                    (DO_CLIP || (DO_CLIP_RUNTIME_ENABLE && MarlinProperties.isDoClipAtRuntime()))) {\n-                \/\/ Define the initial clip bounds:\n-                final float[] clipRect = rdrCtx.clipRect;\n-\n-                \/\/ Adjust the clipping rectangle with the renderer offsets\n-                final float rdrOffX = 0.25f; \/\/ LBO: is it correct for AA or non AA cases ?\n-                final float rdrOffY = 0.25f; \/\/ see NearestPixelQuarter (depends on normalization ?)\n-\n-                \/\/ add a small rounding error:\n-                final float margin = 1e-3f;\n-\n-                clipRect[0] = clip.getLoY()\n-                                - margin + rdrOffY;\n-                clipRect[1] = clip.getLoY() + clip.getHeight()\n-                                + margin + rdrOffY;\n-                clipRect[2] = clip.getLoX()\n-                                - margin + rdrOffX;\n-                clipRect[3] = clip.getLoX() + clip.getWidth()\n-                                + margin + rdrOffX;\n-\n-                if (MarlinConst.DO_LOG_CLIP) {\n-                    MarlinUtils.logInfo(\"clipRect (clip): \"\n-                                        + Arrays.toString(rdrCtx.clipRect));\n-                }\n-\n-                \/\/ Enable clipping:\n-                rdrCtx.doClip = true;\n-            }\n-\n-            strokeTo(rdrCtx, src, _at, bs, thin, norm, antialias, consumer);\n-        } finally {\n-            \/\/ recycle the RendererContext instance\n-            returnRendererContext(rdrCtx);\n-        }\n-    }\n-\n-    void strokeTo(final RendererContext rdrCtx,\n-                  Shape src,\n-                  AffineTransform at,\n-                  BasicStroke bs,\n-                  boolean thin,\n-                  NormMode normalize,\n-                  boolean antialias,\n-                  PathConsumer2D pc2d)\n-    {\n-        float lw;\n-        if (thin) {\n-            if (antialias) {\n-                lw = userSpaceLineWidth(at, MIN_PEN_SIZE);\n-            } else {\n-                lw = userSpaceLineWidth(at, 1.0f);\n-            }\n-        } else {\n-            lw = bs.getLineWidth();\n-        }\n-        strokeTo(rdrCtx,\n-                 src,\n-                 at,\n-                 lw,\n-                 normalize,\n-                 bs.getEndCap(),\n-                 bs.getLineJoin(),\n-                 bs.getMiterLimit(),\n-                 bs.getDashArray(),\n-                 bs.getDashPhase(),\n-                 pc2d);\n-    }\n-\n-    private float userSpaceLineWidth(AffineTransform at, float lw) {\n-\n-        float widthScale;\n-\n-        if (at == null) {\n-            widthScale = 1.0f;\n-        } else if ((at.getType() & (AffineTransform.TYPE_GENERAL_TRANSFORM  |\n-                                    AffineTransform.TYPE_GENERAL_SCALE)) != 0) {\n-            \/\/ Determinant may be negative (flip), use its absolute value:\n-            widthScale = (float)Math.sqrt(Math.abs(at.getDeterminant()));\n-        } else {\n-            \/\/ First calculate the \"maximum scale\" of this transform.\n-            double A = at.getScaleX();       \/\/ m00\n-            double C = at.getShearX();       \/\/ m01\n-            double B = at.getShearY();       \/\/ m10\n-            double D = at.getScaleY();       \/\/ m11\n-\n-            \/*\n-             * Given a 2 x 2 affine matrix [ A B ] such that\n-             *                             [ C D ]\n-             * v' = [x' y'] = [Ax + Cy, Bx + Dy], we want to\n-             * find the maximum magnitude (norm) of the vector v'\n-             * with the constraint (x^2 + y^2 = 1).\n-             * The equation to maximize is\n-             *     |v'| = sqrt((Ax+Cy)^2+(Bx+Dy)^2)\n-             * or  |v'| = sqrt((AA+BB)x^2 + 2(AC+BD)xy + (CC+DD)y^2).\n-             * Since sqrt is monotonic we can maximize |v'|^2\n-             * instead and plug in the substitution y = sqrt(1 - x^2).\n-             * Trigonometric equalities can then be used to get\n-             * rid of most of the sqrt terms.\n-             *\/\n-\n-            double EA = A*A + B*B;          \/\/ x^2 coefficient\n-            double EB = 2.0d * (A*C + B*D); \/\/ xy coefficient\n-            double EC = C*C + D*D;          \/\/ y^2 coefficient\n-\n-            \/*\n-             * There is a lot of calculus omitted here.\n-             *\n-             * Conceptually, in the interests of understanding the\n-             * terms that the calculus produced we can consider\n-             * that EA and EC end up providing the lengths along\n-             * the major axes and the hypot term ends up being an\n-             * adjustment for the additional length along the off-axis\n-             * angle of rotated or sheared ellipses as well as an\n-             * adjustment for the fact that the equation below\n-             * averages the two major axis lengths.  (Notice that\n-             * the hypot term contains a part which resolves to the\n-             * difference of these two axis lengths in the absence\n-             * of rotation.)\n-             *\n-             * In the calculus, the ratio of the EB and (EA-EC) terms\n-             * ends up being the tangent of 2*theta where theta is\n-             * the angle that the long axis of the ellipse makes\n-             * with the horizontal axis.  Thus, this equation is\n-             * calculating the length of the hypotenuse of a triangle\n-             * along that axis.\n-             *\/\n-\n-            double hypot = Math.sqrt(EB*EB + (EA-EC)*(EA-EC));\n-            \/\/ sqrt omitted, compare to squared limits below.\n-            double widthsquared = ((EA + EC + hypot) \/ 2.0d);\n-\n-            widthScale = (float)Math.sqrt(widthsquared);\n-        }\n-\n-        return (lw \/ widthScale);\n-    }\n-\n-    void strokeTo(final RendererContext rdrCtx,\n-                  Shape src,\n-                  AffineTransform at,\n-                  float width,\n-                  NormMode norm,\n-                  int caps,\n-                  int join,\n-                  float miterlimit,\n-                  float[] dashes,\n-                  float dashphase,\n-                  PathConsumer2D pc2d)\n-    {\n-        \/\/ We use strokerat so that in Stroker and Dasher we can work only\n-        \/\/ with the pre-transformation coordinates. This will repeat a lot of\n-        \/\/ computations done in the path iterator, but the alternative is to\n-        \/\/ work with transformed paths and compute untransformed coordinates\n-        \/\/ as needed. This would be faster but I do not think the complexity\n-        \/\/ of working with both untransformed and transformed coordinates in\n-        \/\/ the same code is worth it.\n-        \/\/ However, if a path's width is constant after a transformation,\n-        \/\/ we can skip all this untransforming.\n-\n-        \/\/ As pathTo() will check transformed coordinates for invalid values\n-        \/\/ (NaN \/ Infinity) to ignore such points, it is necessary to apply the\n-        \/\/ transformation before the path processing.\n-        AffineTransform strokerat = null;\n-\n-        int dashLen = -1;\n-        boolean recycleDashes = false;\n-\n-        if (at != null && !at.isIdentity()) {\n-            final double a = at.getScaleX();\n-            final double b = at.getShearX();\n-            final double c = at.getShearY();\n-            final double d = at.getScaleY();\n-            final double det = a * d - c * b;\n-\n-            if (Math.abs(det) <= (2.0f * Float.MIN_VALUE)) {\n-                \/\/ this rendering engine takes one dimensional curves and turns\n-                \/\/ them into 2D shapes by giving them width.\n-                \/\/ However, if everything is to be passed through a singular\n-                \/\/ transformation, these 2D shapes will be squashed down to 1D\n-                \/\/ again so, nothing can be drawn.\n-\n-                \/\/ Every path needs an initial moveTo and a pathDone. If these\n-                \/\/ are not there this causes a SIGSEGV in libawt.so (at the time\n-                \/\/ of writing of this comment (September 16, 2010)). Actually,\n-                \/\/ I am not sure if the moveTo is necessary to avoid the SIGSEGV\n-                \/\/ but the pathDone is definitely needed.\n-                pc2d.moveTo(0.0f, 0.0f);\n-                pc2d.pathDone();\n-                return;\n-            }\n-\n-            \/\/ If the transform is a constant multiple of an orthogonal transformation\n-            \/\/ then every length is just multiplied by a constant, so we just\n-            \/\/ need to transform input paths to stroker and tell stroker\n-            \/\/ the scaled width. This condition is satisfied if\n-            \/\/ a*b == -c*d && a*a+c*c == b*b+d*d. In the actual check below, we\n-            \/\/ leave a bit of room for error.\n-            if (nearZero(a*b + c*d) && nearZero(a*a + c*c - (b*b + d*d))) {\n-                final float scale = (float) Math.sqrt(a*a + c*c);\n-\n-                if (dashes != null) {\n-                    recycleDashes = true;\n-                    dashLen = dashes.length;\n-                    dashes = rdrCtx.dasher.copyDashArray(dashes);\n-                    for (int i = 0; i < dashLen; i++) {\n-                        dashes[i] *= scale;\n-                    }\n-                    dashphase *= scale;\n-                }\n-                width *= scale;\n-\n-                \/\/ by now strokerat == null. Input paths to\n-                \/\/ stroker (and maybe dasher) will have the full transform at\n-                \/\/ applied to them and nothing will happen to the output paths.\n-            } else {\n-                strokerat = at;\n-\n-                \/\/ by now strokerat == at. Input paths to\n-                \/\/ stroker (and maybe dasher) will have the full transform at\n-                \/\/ applied to them, then they will be normalized, and then\n-                \/\/ the inverse of *only the non translation part of at* will\n-                \/\/ be applied to the normalized paths. This won't cause problems\n-                \/\/ in stroker, because, suppose at = T*A, where T is just the\n-                \/\/ translation part of at, and A is the rest. T*A has already\n-                \/\/ been applied to Stroker\/Dasher's input. Then Ainv will be\n-                \/\/ applied. Ainv*T*A is not equal to T, but it is a translation,\n-                \/\/ which means that none of stroker's assumptions about its\n-                \/\/ input will be violated. After all this, A will be applied\n-                \/\/ to stroker's output.\n-            }\n-        } else {\n-            \/\/ either at is null or it's the identity. In either case\n-            \/\/ we don't transform the path.\n-            at = null;\n-        }\n-\n-        final TransformingPathConsumer2D transformerPC2D = rdrCtx.transformerPC2D;\n-\n-        if (DO_TRACE_PATH) {\n-            \/\/ trace Stroker:\n-            pc2d = transformerPC2D.traceStroker(pc2d);\n-        }\n-\n-        if (USE_SIMPLIFIER) {\n-            \/\/ Use simplifier after stroker before Renderer\n-            \/\/ to remove collinear segments (notably due to cap square)\n-            pc2d = rdrCtx.simplifier.init(pc2d);\n-        }\n-\n-        \/\/ deltaTransformConsumer may adjust the clip rectangle:\n-        pc2d = transformerPC2D.deltaTransformConsumer(pc2d, strokerat);\n-\n-        \/\/ stroker will adjust the clip rectangle (width \/ miter limit):\n-        pc2d = rdrCtx.stroker.init(pc2d, width, caps, join, miterlimit,\n-                (dashes == null));\n-\n-        \/\/ Curve Monotizer:\n-        rdrCtx.monotonizer.init(width);\n-\n-        if (dashes != null) {\n-            if (!recycleDashes) {\n-                dashLen = dashes.length;\n-            }\n-            if (DO_TRACE_PATH) {\n-                pc2d = transformerPC2D.traceDasher(pc2d);\n-            }\n-            pc2d = rdrCtx.dasher.init(pc2d, dashes, dashLen, dashphase,\n-                                      recycleDashes);\n-\n-            if (DISABLE_2ND_STROKER_CLIPPING) {\n-                \/\/ disable stoker clipping\n-                rdrCtx.stroker.disableClipping();\n-            }\n-\n-        } else if (rdrCtx.doClip && (caps != Stroker.CAP_BUTT)) {\n-            if (DO_TRACE_PATH) {\n-                pc2d = transformerPC2D.traceClosedPathDetector(pc2d);\n-            }\n-\n-            \/\/ If no dash and clip is enabled:\n-            \/\/ detect closedPaths (polygons) for caps\n-            pc2d = transformerPC2D.detectClosedPath(pc2d);\n-        }\n-        pc2d = transformerPC2D.inverseDeltaTransformConsumer(pc2d, strokerat);\n-\n-        if (DO_TRACE_PATH) {\n-            \/\/ trace Input:\n-            pc2d = transformerPC2D.traceInput(pc2d);\n-        }\n-\n-        final PathIterator pi = norm.getNormalizingPathIterator(rdrCtx,\n-                                         src.getPathIterator(at));\n-\n-        pathTo(rdrCtx, pi, pc2d);\n-\n-        \/*\n-         * Pipeline seems to be:\n-         * shape.getPathIterator(at)\n-         * -> (NormalizingPathIterator)\n-         * -> (inverseDeltaTransformConsumer)\n-         * -> (Dasher)\n-         * -> Stroker\n-         * -> (deltaTransformConsumer)\n-         *\n-         * -> (CollinearSimplifier) to remove redundant segments\n-         *\n-         * -> pc2d = Renderer (bounding box)\n-         *\/\n-    }\n-\n-    private static boolean nearZero(final double num) {\n-        return Math.abs(num) < 2.0d * Math.ulp(num);\n-    }\n-\n-    abstract static class NormalizingPathIterator implements PathIterator {\n-\n-        private PathIterator src;\n-\n-        \/\/ the adjustment applied to the current position.\n-        private float curx_adjust, cury_adjust;\n-        \/\/ the adjustment applied to the last moveTo position.\n-        private float movx_adjust, movy_adjust;\n-\n-        private final float[] tmp;\n-\n-        NormalizingPathIterator(final float[] tmp) {\n-            this.tmp = tmp;\n-        }\n-\n-        final NormalizingPathIterator init(final PathIterator src) {\n-            this.src = src;\n-            return this; \/\/ fluent API\n-        }\n-\n-        \/**\n-         * Disposes this path iterator:\n-         * clean up before reusing this instance\n-         *\/\n-        final void dispose() {\n-            \/\/ free source PathIterator:\n-            this.src = null;\n-        }\n-\n-        @Override\n-        public final int currentSegment(final float[] coords) {\n-            int lastCoord;\n-            final int type = src.currentSegment(coords);\n-\n-            switch(type) {\n-                case PathIterator.SEG_MOVETO:\n-                case PathIterator.SEG_LINETO:\n-                    lastCoord = 0;\n-                    break;\n-                case PathIterator.SEG_QUADTO:\n-                    lastCoord = 2;\n-                    break;\n-                case PathIterator.SEG_CUBICTO:\n-                    lastCoord = 4;\n-                    break;\n-                case PathIterator.SEG_CLOSE:\n-                    \/\/ we don't want to deal with this case later. We just exit now\n-                    curx_adjust = movx_adjust;\n-                    cury_adjust = movy_adjust;\n-                    return type;\n-                default:\n-                    throw new InternalError(\"Unrecognized curve type\");\n-            }\n-\n-            \/\/ normalize endpoint\n-            float coord, x_adjust, y_adjust;\n-\n-            coord = coords[lastCoord];\n-            x_adjust = normCoord(coord); \/\/ new coord\n-            coords[lastCoord] = x_adjust;\n-            x_adjust -= coord;\n-\n-            coord = coords[lastCoord + 1];\n-            y_adjust = normCoord(coord); \/\/ new coord\n-            coords[lastCoord + 1] = y_adjust;\n-            y_adjust -= coord;\n-\n-            \/\/ now that the end points are done, normalize the control points\n-            switch(type) {\n-                case PathIterator.SEG_MOVETO:\n-                    movx_adjust = x_adjust;\n-                    movy_adjust = y_adjust;\n-                    break;\n-                case PathIterator.SEG_LINETO:\n-                    break;\n-                case PathIterator.SEG_QUADTO:\n-                    coords[0] += (curx_adjust + x_adjust) \/ 2.0f;\n-                    coords[1] += (cury_adjust + y_adjust) \/ 2.0f;\n-                    break;\n-                case PathIterator.SEG_CUBICTO:\n-                    coords[0] += curx_adjust;\n-                    coords[1] += cury_adjust;\n-                    coords[2] += x_adjust;\n-                    coords[3] += y_adjust;\n-                    break;\n-                case PathIterator.SEG_CLOSE:\n-                    \/\/ handled earlier\n-                default:\n-            }\n-            curx_adjust = x_adjust;\n-            cury_adjust = y_adjust;\n-            return type;\n-        }\n-\n-        abstract float normCoord(final float coord);\n-\n-        @Override\n-        public final int currentSegment(final double[] coords) {\n-            final float[] _tmp = tmp; \/\/ dirty\n-            int type = this.currentSegment(_tmp);\n-            for (int i = 0; i < 6; i++) {\n-                coords[i] = _tmp[i];\n-            }\n-            return type;\n-        }\n-\n-        @Override\n-        public final int getWindingRule() {\n-            return src.getWindingRule();\n-        }\n-\n-        @Override\n-        public final boolean isDone() {\n-            if (src.isDone()) {\n-                \/\/ Dispose this instance:\n-                dispose();\n-                return true;\n-            }\n-            return false;\n-        }\n-\n-        @Override\n-        public final void next() {\n-            src.next();\n-        }\n-\n-        static final class NearestPixelCenter\n-                                extends NormalizingPathIterator\n-        {\n-            NearestPixelCenter(final float[] tmp) {\n-                super(tmp);\n-            }\n-\n-            @Override\n-            float normCoord(final float coord) {\n-                \/\/ round to nearest pixel center\n-                return FloatMath.floor_f(coord) + 0.5f;\n-            }\n-        }\n-\n-        static final class NearestPixelQuarter\n-                                extends NormalizingPathIterator\n-        {\n-            NearestPixelQuarter(final float[] tmp) {\n-                super(tmp);\n-            }\n-\n-            @Override\n-            float normCoord(final float coord) {\n-                \/\/ round to nearest (0.25, 0.25) pixel quarter\n-                return FloatMath.floor_f(coord + 0.25f) + 0.25f;\n-            }\n-        }\n-    }\n-\n-    private static void pathTo(final RendererContext rdrCtx, final PathIterator pi,\n-                               PathConsumer2D pc2d)\n-    {\n-        if (USE_PATH_SIMPLIFIER) {\n-            \/\/ Use path simplifier at the first step\n-            \/\/ to remove useless points\n-            pc2d = rdrCtx.pathSimplifier.init(pc2d);\n-        }\n-\n-        \/\/ mark context as DIRTY:\n-        rdrCtx.dirty = true;\n-\n-        pathToLoop(rdrCtx.float6, pi, pc2d);\n-\n-        \/\/ mark context as CLEAN:\n-        rdrCtx.dirty = false;\n-    }\n-\n-    private static void pathToLoop(final float[] coords, final PathIterator pi,\n-                                   final PathConsumer2D pc2d)\n-    {\n-        \/\/ ported from DuctusRenderingEngine.feedConsumer() but simplified:\n-        \/\/ - removed skip flag = !subpathStarted\n-        \/\/ - removed pathClosed (ie subpathStarted not set to false)\n-        boolean subpathStarted = false;\n-\n-        for (; !pi.isDone(); pi.next()) {\n-            switch (pi.currentSegment(coords)) {\n-            case PathIterator.SEG_MOVETO:\n-                \/* Checking SEG_MOVETO coordinates if they are out of the\n-                 * [LOWER_BND, UPPER_BND] range. This check also handles NaN\n-                 * and Infinity values. Skipping next path segment in case of\n-                 * invalid data.\n-                 *\/\n-                if (coords[0] < UPPER_BND && coords[0] > LOWER_BND &&\n-                    coords[1] < UPPER_BND && coords[1] > LOWER_BND)\n-                {\n-                    pc2d.moveTo(coords[0], coords[1]);\n-                    subpathStarted = true;\n-                }\n-                break;\n-            case PathIterator.SEG_LINETO:\n-                \/* Checking SEG_LINETO coordinates if they are out of the\n-                 * [LOWER_BND, UPPER_BND] range. This check also handles NaN\n-                 * and Infinity values. Ignoring current path segment in case\n-                 * of invalid data. If segment is skipped its endpoint\n-                 * (if valid) is used to begin new subpath.\n-                 *\/\n-                if (coords[0] < UPPER_BND && coords[0] > LOWER_BND &&\n-                    coords[1] < UPPER_BND && coords[1] > LOWER_BND)\n-                {\n-                    if (subpathStarted) {\n-                        pc2d.lineTo(coords[0], coords[1]);\n-                    } else {\n-                        pc2d.moveTo(coords[0], coords[1]);\n-                        subpathStarted = true;\n-                    }\n-                }\n-                break;\n-            case PathIterator.SEG_QUADTO:\n-                \/\/ Quadratic curves take two points\n-                \/* Checking SEG_QUADTO coordinates if they are out of the\n-                 * [LOWER_BND, UPPER_BND] range. This check also handles NaN\n-                 * and Infinity values. Ignoring current path segment in case\n-                 * of invalid endpoints's data. Equivalent to the SEG_LINETO\n-                 * if endpoint coordinates are valid but there are invalid data\n-                 * among other coordinates\n-                 *\/\n-                if (coords[2] < UPPER_BND && coords[2] > LOWER_BND &&\n-                    coords[3] < UPPER_BND && coords[3] > LOWER_BND)\n-                {\n-                    if (subpathStarted) {\n-                        if (coords[0] < UPPER_BND && coords[0] > LOWER_BND &&\n-                            coords[1] < UPPER_BND && coords[1] > LOWER_BND)\n-                        {\n-                            pc2d.quadTo(coords[0], coords[1],\n-                                        coords[2], coords[3]);\n-                        } else {\n-                            pc2d.lineTo(coords[2], coords[3]);\n-                        }\n-                    } else {\n-                        pc2d.moveTo(coords[2], coords[3]);\n-                        subpathStarted = true;\n-                    }\n-                }\n-                break;\n-            case PathIterator.SEG_CUBICTO:\n-                \/\/ Cubic curves take three points\n-                \/* Checking SEG_CUBICTO coordinates if they are out of the\n-                 * [LOWER_BND, UPPER_BND] range. This check also handles NaN\n-                 * and Infinity values. Ignoring current path segment in case\n-                 * of invalid endpoints's data. Equivalent to the SEG_LINETO\n-                 * if endpoint coordinates are valid but there are invalid data\n-                 * among other coordinates\n-                 *\/\n-                if (coords[4] < UPPER_BND && coords[4] > LOWER_BND &&\n-                    coords[5] < UPPER_BND && coords[5] > LOWER_BND)\n-                {\n-                    if (subpathStarted) {\n-                        if (coords[0] < UPPER_BND && coords[0] > LOWER_BND &&\n-                            coords[1] < UPPER_BND && coords[1] > LOWER_BND &&\n-                            coords[2] < UPPER_BND && coords[2] > LOWER_BND &&\n-                            coords[3] < UPPER_BND && coords[3] > LOWER_BND)\n-                        {\n-                            pc2d.curveTo(coords[0], coords[1],\n-                                         coords[2], coords[3],\n-                                         coords[4], coords[5]);\n-                        } else {\n-                            pc2d.lineTo(coords[4], coords[5]);\n-                        }\n-                    } else {\n-                        pc2d.moveTo(coords[4], coords[5]);\n-                        subpathStarted = true;\n-                    }\n-                }\n-                break;\n-            case PathIterator.SEG_CLOSE:\n-                if (subpathStarted) {\n-                    pc2d.closePath();\n-                    \/\/ do not set subpathStarted to false\n-                    \/\/ in case of missing moveTo() after close()\n-                }\n-                break;\n-            default:\n-            }\n-        }\n-        pc2d.pathDone();\n-    }\n-\n-    \/**\n-     * Construct an antialiased tile generator for the given shape with\n-     * the given rendering attributes and store the bounds of the tile\n-     * iteration in the bbox parameter.\n-     * The {@code at} parameter specifies a transform that should affect\n-     * both the shape and the {@code BasicStroke} attributes.\n-     * The {@code clip} parameter specifies the current clip in effect\n-     * in device coordinates and can be used to prune the data for the\n-     * operation, but the renderer is not required to perform any\n-     * clipping.\n-     * If the {@code BasicStroke} parameter is null then the shape\n-     * should be filled as is, otherwise the attributes of the\n-     * {@code BasicStroke} should be used to specify a draw operation.\n-     * The {@code thin} parameter indicates whether or not the\n-     * transformed {@code BasicStroke} represents coordinates smaller\n-     * than the minimum resolution of the antialiasing rasterizer as\n-     * specified by the {@code getMinimumAAPenWidth()} method.\n-     * <p>\n-     * Upon returning, this method will fill the {@code bbox} parameter\n-     * with 4 values indicating the bounds of the iteration of the\n-     * tile generator.\n-     * The iteration order of the tiles will be as specified by the\n-     * pseudo-code:\n-     * <pre>\n-     *     for (y = bbox[1]; y < bbox[3]; y += tileheight) {\n-     *         for (x = bbox[0]; x < bbox[2]; x += tilewidth) {\n-     *         }\n-     *     }\n-     * <\/pre>\n-     * If there is no output to be rendered, this method may return\n-     * null.\n-     *\n-     * @param s the shape to be rendered (fill or draw)\n-     * @param at the transform to be applied to the shape and the\n-     *           stroke attributes\n-     * @param clip the current clip in effect in device coordinates\n-     * @param bs if non-null, a {@code BasicStroke} whose attributes\n-     *           should be applied to this operation\n-     * @param thin true if the transformed stroke attributes are smaller\n-     *             than the minimum dropout pen width\n-     * @param normalize true if the {@code VALUE_STROKE_NORMALIZE}\n-     *                  {@code RenderingHint} is in effect\n-     * @param bbox returns the bounds of the iteration\n-     * @return the {@code AATileGenerator} instance to be consulted\n-     *         for tile coverages, or null if there is no output to render\n-     * @since 1.7\n-     *\/\n-    @Override\n-    public AATileGenerator getAATileGenerator(Shape s,\n-                                              AffineTransform at,\n-                                              Region clip,\n-                                              BasicStroke bs,\n-                                              boolean thin,\n-                                              boolean normalize,\n-                                              int[] bbox)\n-    {\n-        MarlinTileGenerator ptg = null;\n-        Renderer r = null;\n-\n-        final RendererContext rdrCtx = getRendererContext();\n-        try {\n-            if (DO_CLIP || (DO_CLIP_RUNTIME_ENABLE && MarlinProperties.isDoClipAtRuntime())) {\n-                \/\/ Define the initial clip bounds:\n-                final float[] clipRect = rdrCtx.clipRect;\n-\n-                \/\/ Adjust the clipping rectangle with the renderer offsets\n-                final float rdrOffX = Renderer.RDR_OFFSET_X;\n-                final float rdrOffY = Renderer.RDR_OFFSET_Y;\n-\n-                \/\/ add a small rounding error:\n-                final float margin = 1e-3f;\n-\n-                clipRect[0] = clip.getLoY()\n-                                - margin + rdrOffY;\n-                clipRect[1] = clip.getLoY() + clip.getHeight()\n-                                + margin + rdrOffY;\n-                clipRect[2] = clip.getLoX()\n-                                - margin + rdrOffX;\n-                clipRect[3] = clip.getLoX() + clip.getWidth()\n-                                + margin + rdrOffX;\n-\n-                if (MarlinConst.DO_LOG_CLIP) {\n-                    MarlinUtils.logInfo(\"clipRect (clip): \"\n-                                        + Arrays.toString(rdrCtx.clipRect));\n-                }\n-\n-                \/\/ Enable clipping:\n-                rdrCtx.doClip = true;\n-            }\n-\n-            \/\/ Test if at is identity:\n-            final AffineTransform _at = (at != null && !at.isIdentity()) ? at\n-                                        : null;\n-\n-            final NormMode norm = (normalize) ? NormMode.ON_WITH_AA : NormMode.OFF;\n-\n-            if (bs == null) {\n-                \/\/ fill shape:\n-                final PathIterator pi = norm.getNormalizingPathIterator(rdrCtx,\n-                                                 s.getPathIterator(_at));\n-\n-                \/\/ note: Winding rule may be EvenOdd ONLY for fill operations !\n-                r = rdrCtx.renderer.init(clip.getLoX(), clip.getLoY(),\n-                                         clip.getWidth(), clip.getHeight(),\n-                                         pi.getWindingRule());\n-\n-                PathConsumer2D pc2d = r;\n-\n-                if (DO_CLIP_FILL && rdrCtx.doClip) {\n-                    if (DO_TRACE_PATH) {\n-                        \/\/ trace Filler:\n-                        pc2d = rdrCtx.transformerPC2D.traceFiller(pc2d);\n-                    }\n-                    pc2d = rdrCtx.transformerPC2D.pathClipper(pc2d);\n-                }\n-\n-                if (DO_TRACE_PATH) {\n-                    \/\/ trace Input:\n-                    pc2d = rdrCtx.transformerPC2D.traceInput(pc2d);\n-                }\n-                pathTo(rdrCtx, pi, pc2d);\n-\n-            } else {\n-                \/\/ draw shape with given stroke:\n-                r = rdrCtx.renderer.init(clip.getLoX(), clip.getLoY(),\n-                                         clip.getWidth(), clip.getHeight(),\n-                                         WIND_NON_ZERO);\n-\n-                strokeTo(rdrCtx, s, _at, bs, thin, norm, true, r);\n-            }\n-            if (r.endRendering()) {\n-                ptg = rdrCtx.ptg.init();\n-                ptg.getBbox(bbox);\n-                \/\/ note: do not returnRendererContext(rdrCtx)\n-                \/\/ as it will be called later by MarlinTileGenerator.dispose()\n-                r = null;\n-            }\n-        } finally {\n-            if (r != null) {\n-                \/\/ dispose renderer and recycle the RendererContext instance:\n-                r.dispose();\n-            }\n-        }\n-\n-        \/\/ Return null to cancel AA tile generation (nothing to render)\n-        return ptg;\n-    }\n-\n-    @Override\n-    public AATileGenerator getAATileGenerator(double x, double y,\n-                                              double dx1, double dy1,\n-                                              double dx2, double dy2,\n-                                              double lw1, double lw2,\n-                                              Region clip,\n-                                              int[] bbox)\n-    {\n-        \/\/ REMIND: Deal with large coordinates!\n-        double ldx1, ldy1, ldx2, ldy2;\n-        boolean innerpgram = (lw1 > 0.0d && lw2 > 0.0d);\n-\n-        if (innerpgram) {\n-            ldx1 = dx1 * lw1;\n-            ldy1 = dy1 * lw1;\n-            ldx2 = dx2 * lw2;\n-            ldy2 = dy2 * lw2;\n-            x -= (ldx1 + ldx2) \/ 2.0d;\n-            y -= (ldy1 + ldy2) \/ 2.0d;\n-            dx1 += ldx1;\n-            dy1 += ldy1;\n-            dx2 += ldx2;\n-            dy2 += ldy2;\n-            if (lw1 > 1.0d && lw2 > 1.0d) {\n-                \/\/ Inner parallelogram was entirely consumed by stroke...\n-                innerpgram = false;\n-            }\n-        } else {\n-            ldx1 = ldy1 = ldx2 = ldy2 = 0.0d;\n-        }\n-\n-        MarlinTileGenerator ptg = null;\n-        Renderer r = null;\n-\n-        final RendererContext rdrCtx = getRendererContext();\n-        try {\n-            r = rdrCtx.renderer.init(clip.getLoX(), clip.getLoY(),\n-                                     clip.getWidth(), clip.getHeight(),\n-                                     WIND_EVEN_ODD);\n-\n-            r.moveTo((float) x, (float) y);\n-            r.lineTo((float) (x+dx1), (float) (y+dy1));\n-            r.lineTo((float) (x+dx1+dx2), (float) (y+dy1+dy2));\n-            r.lineTo((float) (x+dx2), (float) (y+dy2));\n-            r.closePath();\n-\n-            if (innerpgram) {\n-                x += ldx1 + ldx2;\n-                y += ldy1 + ldy2;\n-                dx1 -= 2.0d * ldx1;\n-                dy1 -= 2.0d * ldy1;\n-                dx2 -= 2.0d * ldx2;\n-                dy2 -= 2.0d * ldy2;\n-                r.moveTo((float) x, (float) y);\n-                r.lineTo((float) (x+dx1), (float) (y+dy1));\n-                r.lineTo((float) (x+dx1+dx2), (float) (y+dy1+dy2));\n-                r.lineTo((float) (x+dx2), (float) (y+dy2));\n-                r.closePath();\n-            }\n-            r.pathDone();\n-\n-            if (r.endRendering()) {\n-                ptg = rdrCtx.ptg.init();\n-                ptg.getBbox(bbox);\n-                \/\/ note: do not returnRendererContext(rdrCtx)\n-                \/\/ as it will be called later by MarlinTileGenerator.dispose()\n-                r = null;\n-            }\n-        } finally {\n-            if (r != null) {\n-                \/\/ dispose renderer and recycle the RendererContext instance:\n-                r.dispose();\n-            }\n-        }\n-\n-        \/\/ Return null to cancel AA tile generation (nothing to render)\n-        return ptg;\n-    }\n-\n-    \/**\n-     * Returns the minimum pen width that the antialiasing rasterizer\n-     * can represent without dropouts occuring.\n-     * @since 1.7\n-     *\/\n-    @Override\n-    public float getMinimumAAPenSize() {\n-        return MIN_PEN_SIZE;\n-    }\n-\n-    static {\n-        if (PathIterator.WIND_NON_ZERO != WIND_NON_ZERO ||\n-            PathIterator.WIND_EVEN_ODD != WIND_EVEN_ODD ||\n-            BasicStroke.JOIN_MITER != JOIN_MITER ||\n-            BasicStroke.JOIN_ROUND != JOIN_ROUND ||\n-            BasicStroke.JOIN_BEVEL != JOIN_BEVEL ||\n-            BasicStroke.CAP_BUTT != CAP_BUTT ||\n-            BasicStroke.CAP_ROUND != CAP_ROUND ||\n-            BasicStroke.CAP_SQUARE != CAP_SQUARE)\n-        {\n-            throw new InternalError(\"mismatched renderer constants\");\n-        }\n-    }\n-\n-    \/\/ --- RendererContext handling ---\n-    \/\/ use ThreadLocal or ConcurrentLinkedQueue to get one RendererContext\n-    private static final boolean USE_THREAD_LOCAL;\n-\n-    \/\/ reference type stored in either TL or CLQ\n-    static final int REF_TYPE;\n-\n-    \/\/ Per-thread RendererContext\n-    private static final ReentrantContextProvider<RendererContext> RDR_CTX_PROVIDER;\n-\n-    \/\/ Static initializer to use TL or CLQ mode\n-    static {\n-        USE_THREAD_LOCAL = MarlinProperties.isUseThreadLocal();\n-\n-        \/\/ Soft reference by default:\n-        final String refType = AccessController.doPrivileged(\n-                            new GetPropertyAction(\"sun.java2d.renderer.useRef\",\n-                            \"soft\"));\n-        switch (refType) {\n-            default:\n-            case \"soft\":\n-                REF_TYPE = ReentrantContextProvider.REF_SOFT;\n-                break;\n-            case \"weak\":\n-                REF_TYPE = ReentrantContextProvider.REF_WEAK;\n-                break;\n-            case \"hard\":\n-                REF_TYPE = ReentrantContextProvider.REF_HARD;\n-                break;\n-        }\n-\n-        if (USE_THREAD_LOCAL) {\n-            RDR_CTX_PROVIDER = new ReentrantContextProviderTL<RendererContext>(REF_TYPE)\n-                {\n-                    @Override\n-                    protected RendererContext newContext() {\n-                        return RendererContext.createContext();\n-                    }\n-                };\n-        } else {\n-            RDR_CTX_PROVIDER = new ReentrantContextProviderCLQ<RendererContext>(REF_TYPE)\n-                {\n-                    @Override\n-                    protected RendererContext newContext() {\n-                        return RendererContext.createContext();\n-                    }\n-                };\n-        }\n-    }\n-\n-    private static boolean SETTINGS_LOGGED = !ENABLE_LOGS;\n-\n-    private static void logSettings(final String reClass) {\n-        \/\/ log information at startup\n-        if (SETTINGS_LOGGED) {\n-            return;\n-        }\n-        SETTINGS_LOGGED = true;\n-\n-        String refType;\n-        switch (REF_TYPE) {\n-            default:\n-            case ReentrantContextProvider.REF_HARD:\n-                refType = \"hard\";\n-                break;\n-            case ReentrantContextProvider.REF_SOFT:\n-                refType = \"soft\";\n-                break;\n-            case ReentrantContextProvider.REF_WEAK:\n-                refType = \"weak\";\n-                break;\n-        }\n-\n-        logInfo(\"==========================================================\"\n-                + \"=====================\");\n-\n-        logInfo(\"Marlin software rasterizer           = ENABLED\");\n-        logInfo(\"Version                              = [\"\n-                + Version.getVersion() + \"]\");\n-        logInfo(\"sun.java2d.renderer                  = \"\n-                + reClass);\n-        logInfo(\"sun.java2d.renderer.useThreadLocal   = \"\n-                + USE_THREAD_LOCAL);\n-        logInfo(\"sun.java2d.renderer.useRef           = \"\n-                + refType);\n-\n-        logInfo(\"sun.java2d.renderer.edges            = \"\n-                + MarlinConst.INITIAL_EDGES_COUNT);\n-        logInfo(\"sun.java2d.renderer.pixelWidth       = \"\n-                + MarlinConst.INITIAL_PIXEL_WIDTH);\n-        logInfo(\"sun.java2d.renderer.pixelHeight      = \"\n-                + MarlinConst.INITIAL_PIXEL_HEIGHT);\n-\n-        logInfo(\"sun.java2d.renderer.subPixel_log2_X  = \"\n-                + MarlinConst.SUBPIXEL_LG_POSITIONS_X);\n-        logInfo(\"sun.java2d.renderer.subPixel_log2_Y  = \"\n-                + MarlinConst.SUBPIXEL_LG_POSITIONS_Y);\n-\n-        logInfo(\"sun.java2d.renderer.tileSize_log2    = \"\n-                + MarlinConst.TILE_H_LG);\n-        logInfo(\"sun.java2d.renderer.tileWidth_log2   = \"\n-                + MarlinConst.TILE_W_LG);\n-        logInfo(\"sun.java2d.renderer.blockSize_log2   = \"\n-                + MarlinConst.BLOCK_SIZE_LG);\n-\n-        \/\/ RLE \/ blockFlags settings\n-\n-        logInfo(\"sun.java2d.renderer.forceRLE         = \"\n-                + MarlinProperties.isForceRLE());\n-        logInfo(\"sun.java2d.renderer.forceNoRLE       = \"\n-                + MarlinProperties.isForceNoRLE());\n-        logInfo(\"sun.java2d.renderer.useTileFlags     = \"\n-                + MarlinProperties.isUseTileFlags());\n-        logInfo(\"sun.java2d.renderer.useTileFlags.useHeuristics = \"\n-                + MarlinProperties.isUseTileFlagsWithHeuristics());\n-        logInfo(\"sun.java2d.renderer.rleMinWidth      = \"\n-                + MarlinCache.RLE_MIN_WIDTH);\n-\n-        \/\/ optimisation parameters\n-        logInfo(\"sun.java2d.renderer.useSimplifier    = \"\n-                + MarlinConst.USE_SIMPLIFIER);\n-        logInfo(\"sun.java2d.renderer.usePathSimplifier= \"\n-                + MarlinConst.USE_PATH_SIMPLIFIER);\n-        logInfo(\"sun.java2d.renderer.pathSimplifier.pixTol = \"\n-                + MarlinProperties.getPathSimplifierPixelTolerance());\n-\n-        logInfo(\"sun.java2d.renderer.clip             = \"\n-                + MarlinProperties.isDoClip());\n-        logInfo(\"sun.java2d.renderer.clip.runtime.enable = \"\n-                + MarlinProperties.isDoClipRuntimeFlag());\n-\n-        logInfo(\"sun.java2d.renderer.clip.subdivider  = \"\n-                + MarlinProperties.isDoClipSubdivider());\n-        logInfo(\"sun.java2d.renderer.clip.subdivider.minLength = \"\n-                + MarlinProperties.getSubdividerMinLength());\n-\n-        \/\/ debugging parameters\n-        logInfo(\"sun.java2d.renderer.doStats          = \"\n-                + MarlinConst.DO_STATS);\n-        logInfo(\"sun.java2d.renderer.doMonitors       = \"\n-                + MarlinConst.DO_MONITORS);\n-        logInfo(\"sun.java2d.renderer.doChecks         = \"\n-                + MarlinConst.DO_CHECKS);\n-\n-        \/\/ logging parameters\n-        logInfo(\"sun.java2d.renderer.useLogger        = \"\n-                + MarlinConst.USE_LOGGER);\n-        logInfo(\"sun.java2d.renderer.logCreateContext = \"\n-                + MarlinConst.LOG_CREATE_CONTEXT);\n-        logInfo(\"sun.java2d.renderer.logUnsafeMalloc  = \"\n-                + MarlinConst.LOG_UNSAFE_MALLOC);\n-\n-        \/\/ quality settings\n-        logInfo(\"sun.java2d.renderer.curve_len_err    = \"\n-                + MarlinProperties.getCurveLengthError());\n-        logInfo(\"sun.java2d.renderer.cubic_dec_d2     = \"\n-                + MarlinProperties.getCubicDecD2());\n-        logInfo(\"sun.java2d.renderer.cubic_inc_d1     = \"\n-                + MarlinProperties.getCubicIncD1());\n-        logInfo(\"sun.java2d.renderer.quad_dec_d2      = \"\n-                + MarlinProperties.getQuadDecD2());\n-\n-        logInfo(\"Renderer settings:\");\n-        logInfo(\"CUB_DEC_BND  = \" + Renderer.CUB_DEC_BND);\n-        logInfo(\"CUB_INC_BND  = \" + Renderer.CUB_INC_BND);\n-        logInfo(\"QUAD_DEC_BND = \" + Renderer.QUAD_DEC_BND);\n-\n-        logInfo(\"INITIAL_EDGES_CAPACITY               = \"\n-                + MarlinConst.INITIAL_EDGES_CAPACITY);\n-        logInfo(\"INITIAL_CROSSING_COUNT               = \"\n-                + Renderer.INITIAL_CROSSING_COUNT);\n-\n-        logInfo(\"==========================================================\"\n-                + \"=====================\");\n-    }\n-\n-    \/**\n-     * Get the RendererContext instance dedicated to the current thread\n-     * @return RendererContext instance\n-     *\/\n-    @SuppressWarnings({\"unchecked\"})\n-    static RendererContext getRendererContext() {\n-        final RendererContext rdrCtx = RDR_CTX_PROVIDER.acquire();\n-        if (DO_MONITORS) {\n-            rdrCtx.stats.mon_pre_getAATileGenerator.start();\n-        }\n-        return rdrCtx;\n-    }\n-\n-    \/**\n-     * Reset and return the given RendererContext instance for reuse\n-     * @param rdrCtx RendererContext instance\n-     *\/\n-    static void returnRendererContext(final RendererContext rdrCtx) {\n-        rdrCtx.dispose();\n-\n-        if (DO_MONITORS) {\n-            rdrCtx.stats.mon_pre_getAATileGenerator.stop();\n-        }\n-        RDR_CTX_PROVIDER.release(rdrCtx);\n-    }\n-}\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/marlin\/MarlinRenderingEngine.java","additions":0,"deletions":1305,"binary":false,"changes":1305,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,2 +55,1 @@\n-    private final Renderer rdrF;\n-    private final DRenderer rdrD;\n+    private final Renderer renderer;\n@@ -63,1 +62,1 @@\n-    MarlinTileGenerator(final RendererStats stats, final MarlinRenderer r,\n+    MarlinTileGenerator(final RendererStats stats, final Renderer r,\n@@ -67,7 +66,1 @@\n-        if (r instanceof Renderer) {\n-            this.rdrF = (Renderer)r;\n-            this.rdrD = null;\n-        } else {\n-            this.rdrF = null;\n-            this.rdrD = (DRenderer)r;\n-        }\n+        this.renderer = r;\n@@ -97,6 +90,1 @@\n-        \/\/ bimorphic call optimization:\n-        if (rdrF != null) {\n-            rdrF.dispose();\n-        } else if (rdrD != null) {\n-            rdrD.dispose();\n-        }\n+        renderer.dispose();\n@@ -188,6 +176,1 @@\n-                \/\/ bimorphic call optimization:\n-                if (rdrF != null) {\n-                    rdrF.endRendering(y);\n-                } else if (rdrD != null) {\n-                    rdrD.endRendering(y);\n-                }\n+                renderer.endRendering(y);\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/marlin\/MarlinTileGenerator.java","additions":6,"deletions":23,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -27,3 +27,1 @@\n-import sun.awt.geom.PathConsumer2D;\n-\n-final class PathSimplifier implements PathConsumer2D {\n+final class PathSimplifier implements DPathConsumer2D {\n@@ -32,1 +30,1 @@\n-    private static final float PIX_THRESHOLD = MarlinProperties.getPathSimplifierPixelTolerance();\n+    private static final double PIX_THRESHOLD = MarlinProperties.getPathSimplifierPixelTolerance();\n@@ -34,1 +32,1 @@\n-    private static final float SQUARE_TOLERANCE = PIX_THRESHOLD * PIX_THRESHOLD;\n+    private static final double SQUARE_TOLERANCE = PIX_THRESHOLD * PIX_THRESHOLD;\n@@ -37,2 +35,2 @@\n-    private PathConsumer2D delegate;\n-    private float cx, cy;\n+    private DPathConsumer2D delegate;\n+    private double cx, cy;\n@@ -43,1 +41,1 @@\n-    PathSimplifier init(final PathConsumer2D delegate) {\n+    PathSimplifier init(final DPathConsumer2D delegate) {\n@@ -64,2 +62,2 @@\n-    public void quadTo(final float x1, final float y1,\n-                       final float xe, final float ye)\n+    public void quadTo(final double x1, final double y1,\n+                       final double xe, final double ye)\n@@ -68,2 +66,2 @@\n-        float dx = (xe - cx);\n-        float dy = (ye - cy);\n+        double dx = (xe - cx);\n+        double dy = (ye - cy);\n@@ -87,3 +85,3 @@\n-    public void curveTo(final float x1, final float y1,\n-                        final float x2, final float y2,\n-                        final float xe, final float ye)\n+    public void curveTo(final double x1, final double y1,\n+                        final double x2, final double y2,\n+                        final double xe, final double ye)\n@@ -92,2 +90,2 @@\n-        float dx = (xe - cx);\n-        float dy = (ye - cy);\n+        double dx = (xe - cx);\n+        double dy = (ye - cy);\n@@ -117,1 +115,1 @@\n-    public void moveTo(final float xe, final float ye) {\n+    public void moveTo(final double xe, final double ye) {\n@@ -125,1 +123,1 @@\n-    public void lineTo(final float xe, final float ye) {\n+    public void lineTo(final double xe, final double ye) {\n@@ -127,2 +125,2 @@\n-        float dx = (xe - cx);\n-        float dy = (ye - cy);\n+        double dx = (xe - cx);\n+        double dy = (ye - cy);\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/marlin\/PathSimplifier.java","additions":19,"deletions":21,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import sun.awt.geom.PathConsumer2D;\n@@ -32,1 +31,1 @@\n-final class Renderer implements PathConsumer2D, MarlinRenderer {\n+final class Renderer implements DPathConsumer2D, MarlinConst {\n@@ -44,3 +43,3 @@\n-    \/\/ use float to make tosubpix methods faster (no int to float conversion)\n-    static final float SUBPIXEL_SCALE_X = (float) SUBPIXEL_POSITIONS_X;\n-    static final float SUBPIXEL_SCALE_Y = (float) SUBPIXEL_POSITIONS_Y;\n+    \/\/ use double to make tosubpix methods faster (no int to double conversion)\n+    static final double SUBPIXEL_SCALE_X = SUBPIXEL_POSITIONS_X;\n+    static final double SUBPIXEL_SCALE_Y = SUBPIXEL_POSITIONS_Y;\n@@ -50,2 +49,2 @@\n-    static final float RDR_OFFSET_X = 0.5f \/ SUBPIXEL_SCALE_X;\n-    static final float RDR_OFFSET_Y = 0.5f \/ SUBPIXEL_SCALE_Y;\n+    static final double RDR_OFFSET_X = 0.5d \/ SUBPIXEL_SCALE_X;\n+    static final double RDR_OFFSET_Y = 0.5d \/ SUBPIXEL_SCALE_Y;\n@@ -79,2 +78,2 @@\n-    private static final float CUB_DEC_ERR_SUBPIX\n-        = MarlinProperties.getCubicDecD2() * (SUBPIXEL_POSITIONS_X \/ 8.0f); \/\/ 1.0 \/ 8th pixel\n+    private static final double CUB_DEC_ERR_SUBPIX\n+        = MarlinProperties.getCubicDecD2() * (SUBPIXEL_POSITIONS_X \/ 8.0d); \/\/ 1.0 \/ 8th pixel\n@@ -82,2 +81,2 @@\n-    private static final float CUB_INC_ERR_SUBPIX\n-        = MarlinProperties.getCubicIncD1() * (SUBPIXEL_POSITIONS_X \/ 8.0f); \/\/ 0.4 \/ 8th pixel\n+    private static final double CUB_INC_ERR_SUBPIX\n+        = MarlinProperties.getCubicIncD1() * (SUBPIXEL_POSITIONS_X \/ 8.0d); \/\/ 0.4 \/ 8th pixel\n@@ -85,1 +84,1 @@\n-    public static final float SCALE_DY = ((float) SUBPIXEL_POSITIONS_X) \/ SUBPIXEL_POSITIONS_Y;\n+    public static final double SCALE_DY = ((double) SUBPIXEL_POSITIONS_X) \/ SUBPIXEL_POSITIONS_Y;\n@@ -93,2 +92,2 @@\n-    public static final float CUB_DEC_BND\n-        = 8.0f * CUB_DEC_ERR_SUBPIX;\n+    public static final double CUB_DEC_BND\n+        = 8.0d * CUB_DEC_ERR_SUBPIX;\n@@ -96,2 +95,2 @@\n-    public static final float CUB_INC_BND\n-        = 8.0f * CUB_INC_ERR_SUBPIX;\n+    public static final double CUB_INC_BND\n+        = 8.0d * CUB_INC_ERR_SUBPIX;\n@@ -108,1 +107,1 @@\n-    private static final float CUB_INV_COUNT = 1.0f \/ CUB_COUNT;\n+    private static final double CUB_INV_COUNT = 1.0d \/ CUB_COUNT;\n@@ -110,1 +109,1 @@\n-    private static final float CUB_INV_COUNT_2 = 1.0f \/ CUB_COUNT_2;\n+    private static final double CUB_INV_COUNT_2 = 1.0d \/ CUB_COUNT_2;\n@@ -112,1 +111,1 @@\n-    private static final float CUB_INV_COUNT_3 = 1.0f \/ CUB_COUNT_3;\n+    private static final double CUB_INV_COUNT_3 = 1.0d \/ CUB_COUNT_3;\n@@ -116,2 +115,2 @@\n-    private static final float QUAD_DEC_ERR_SUBPIX\n-        = MarlinProperties.getQuadDecD2() * (SUBPIXEL_POSITIONS_X \/ 8.0f); \/\/ 0.5 \/ 8th pixel\n+    private static final double QUAD_DEC_ERR_SUBPIX\n+        = MarlinProperties.getQuadDecD2() * (SUBPIXEL_POSITIONS_X \/ 8.0d); \/\/ 0.5 \/ 8th pixel\n@@ -125,2 +124,2 @@\n-    public static final float QUAD_DEC_BND\n-        = 8.0f * QUAD_DEC_ERR_SUBPIX;\n+    public static final double QUAD_DEC_BND\n+        = 8.0d * QUAD_DEC_ERR_SUBPIX;\n@@ -162,2 +161,2 @@\n-    private float edgeMinX = Float.POSITIVE_INFINITY;\n-    private float edgeMaxX = Float.NEGATIVE_INFINITY;\n+    private double edgeMinX = Double.POSITIVE_INFINITY;\n+    private double edgeMaxX = Double.NEGATIVE_INFINITY;\n@@ -182,1 +181,1 @@\n-    private void quadBreakIntoLinesAndAdd(float x0, float y0,\n+    private void quadBreakIntoLinesAndAdd(double x0, double y0,\n@@ -184,1 +183,1 @@\n-                                          final float x2, final float y2)\n+                                          final double x2, final double y2)\n@@ -189,1 +188,1 @@\n-        float maxDD = Math.abs(c.dbx) + Math.abs(c.dby) * SCALE_DY;\n+        double maxDD = Math.abs(c.dbx) + Math.abs(c.dby) * SCALE_DY;\n@@ -191,1 +190,1 @@\n-        final float _DEC_BND = QUAD_DEC_BND;\n+        final double _DEC_BND = QUAD_DEC_BND;\n@@ -195,1 +194,1 @@\n-            maxDD \/= 4.0f; \/\/ error divided by 2^2 = 4\n+            maxDD \/= 4.0d; \/\/ error divided by 2^2 = 4\n@@ -206,2 +205,2 @@\n-            final float icount = 1.0f \/ count; \/\/ dt\n-            final float icount2 = icount * icount; \/\/ dt^2\n+            final double icount = 1.0d \/ count; \/\/ dt\n+            final double icount2 = icount * icount; \/\/ dt^2\n@@ -209,4 +208,4 @@\n-            final float ddx = c.dbx * icount2;\n-            final float ddy = c.dby * icount2;\n-            float dx = c.bx * icount2 + c.cx * icount;\n-            float dy = c.by * icount2 + c.cy * icount;\n+            final double ddx = c.dbx * icount2;\n+            final double ddy = c.dby * icount2;\n+            double dx = c.bx * icount2 + c.cx * icount;\n+            double dy = c.by * icount2 + c.cy * icount;\n@@ -215,1 +214,1 @@\n-            for (float x1 = x0, y1 = y0; --count > 0; dx += ddx, dy += ddy) {\n+            for (double x1 = x0, y1 = y0; --count > 0; dx += ddx, dy += ddy) {\n@@ -236,1 +235,1 @@\n-    private void curveBreakIntoLinesAndAdd(float x0, float y0,\n+    private void curveBreakIntoLinesAndAdd(double x0, double y0,\n@@ -238,1 +237,1 @@\n-                                           final float x3, final float y3)\n+                                           final double x3, final double y3)\n@@ -240,4 +239,4 @@\n-        int count           = CUB_COUNT;\n-        final float icount  = CUB_INV_COUNT;   \/\/ dt\n-        final float icount2 = CUB_INV_COUNT_2; \/\/ dt^2\n-        final float icount3 = CUB_INV_COUNT_3; \/\/ dt^3\n+        int count            = CUB_COUNT;\n+        final double icount  = CUB_INV_COUNT;   \/\/ dt\n+        final double icount2 = CUB_INV_COUNT_2; \/\/ dt^2\n+        final double icount3 = CUB_INV_COUNT_3; \/\/ dt^3\n@@ -247,3 +246,3 @@\n-        float dddx, dddy, ddx, ddy, dx, dy;\n-        dddx = 2.0f * c.dax * icount3;\n-        dddy = 2.0f * c.day * icount3;\n+        double dddx, dddy, ddx, ddy, dx, dy;\n+        dddx = 2.0d * c.dax * icount3;\n+        dddy = 2.0d * c.day * icount3;\n@@ -257,3 +256,3 @@\n-        final float _DEC_BND = CUB_DEC_BND;\n-        final float _INC_BND = CUB_INC_BND;\n-        final float _SCALE_DY = SCALE_DY;\n+        final double _DEC_BND = CUB_DEC_BND;\n+        final double _INC_BND = CUB_INC_BND;\n+        final double _SCALE_DY = SCALE_DY;\n@@ -262,1 +261,1 @@\n-        for (float x1 = x0, y1 = y0; count > 0; ) {\n+        for (double x1 = x0, y1 = y0; count > 0; ) {\n@@ -265,1 +264,1 @@\n-            \/\/ float step:\n+            \/\/ double step:\n@@ -269,6 +268,6 @@\n-                dx = 2.0f * dx + ddx;\n-                dy = 2.0f * dy + ddy;\n-                ddx = 4.0f * (ddx + dddx);\n-                ddy = 4.0f * (ddy + dddy);\n-                dddx *= 8.0f;\n-                dddy *= 8.0f;\n+                dx = 2.0d * dx + ddx;\n+                dy = 2.0d * dy + ddy;\n+                ddx = 4.0d * (ddx + dddx);\n+                ddy = 4.0d * (ddy + dddy);\n+                dddx *= 8.0d;\n+                dddy *= 8.0d;\n@@ -284,6 +283,6 @@\n-                dddx \/= 8.0f;\n-                dddy \/= 8.0f;\n-                ddx = ddx \/ 4.0f - dddx;\n-                ddy = ddy \/ 4.0f - dddy;\n-                dx = (dx - ddx) \/ 2.0f;\n-                dy = (dy - ddy) \/ 2.0f;\n+                dddx \/= 8.0d;\n+                dddy \/= 8.0d;\n+                ddx = ddx \/ 4.0d - dddx;\n+                ddy = ddy \/ 4.0d - dddy;\n+                dx = (dx - ddx) \/ 2.0d;\n+                dy = (dy - ddy) \/ 2.0d;\n@@ -318,1 +317,1 @@\n-    private void addLine(float x1, float y1, float x2, float y2) {\n+    private void addLine(double x1, double y1, double x2, double y2) {\n@@ -328,1 +327,1 @@\n-            float tmp = y2;\n+            double tmp = y2;\n@@ -336,1 +335,1 @@\n-        \/\/ convert subpixel coordinates [float] into pixel positions [int]\n+        \/\/ convert subpixel coordinates [double] into pixel positions [int]\n@@ -370,4 +369,1 @@\n-        \/\/ Use double-precision for improved accuracy:\n-        final double x1d   = x1;\n-        final double y1d   = y1;\n-        final double slope = (x1d - x2) \/ (y1d - y2);\n+        final double slope = (x1 - x2) \/ (y1 - y2);\n@@ -440,1 +436,1 @@\n-        final double x1_intercept = x1d + (firstCrossing - y1d) * slope;\n+        final double x1_intercept = x1 + (firstCrossing - y1) * slope;\n@@ -504,1 +500,1 @@\n-    private float x0, y0;\n+    private double x0, y0;\n@@ -507,1 +503,1 @@\n-    private float sx0, sy0;\n+    private double sx0, sy0;\n@@ -597,2 +593,2 @@\n-        edgeMinX = Float.POSITIVE_INFINITY;\n-        edgeMaxX = Float.NEGATIVE_INFINITY;\n+        edgeMinX = Double.POSITIVE_INFINITY;\n+        edgeMaxX = Double.NEGATIVE_INFINITY;\n@@ -662,1 +658,1 @@\n-        MarlinRenderingEngine.returnRendererContext(rdrCtx);\n+        DMarlinRenderingEngine.returnRendererContext(rdrCtx);\n@@ -665,1 +661,1 @@\n-    private static float tosubpixx(final float pix_x) {\n+    private static double tosubpixx(final double pix_x) {\n@@ -669,1 +665,1 @@\n-    private static float tosubpixy(final float pix_y) {\n+    private static double tosubpixy(final double pix_y) {\n@@ -671,1 +667,1 @@\n-        return SUBPIXEL_SCALE_Y * pix_y - 0.5f;\n+        return SUBPIXEL_SCALE_Y * pix_y - 0.5d;\n@@ -675,1 +671,1 @@\n-    public void moveTo(final float pix_x0, final float pix_y0) {\n+    public void moveTo(final double pix_x0, final double pix_y0) {\n@@ -677,2 +673,2 @@\n-        final float sx = tosubpixx(pix_x0);\n-        final float sy = tosubpixy(pix_y0);\n+        final double sx = tosubpixx(pix_x0);\n+        final double sy = tosubpixy(pix_y0);\n@@ -686,3 +682,3 @@\n-    public void lineTo(final float pix_x1, final float pix_y1) {\n-        final float x1 = tosubpixx(pix_x1);\n-        final float y1 = tosubpixy(pix_y1);\n+    public void lineTo(final double pix_x1, final double pix_y1) {\n+        final double x1 = tosubpixx(pix_x1);\n+        final double y1 = tosubpixy(pix_y1);\n@@ -695,3 +691,3 @@\n-    public void curveTo(final float pix_x1, final float pix_y1,\n-                        final float pix_x2, final float pix_y2,\n-                        final float pix_x3, final float pix_y3)\n+    public void curveTo(final double pix_x1, final double pix_y1,\n+                        final double pix_x2, final double pix_y2,\n+                        final double pix_x3, final double pix_y3)\n@@ -699,2 +695,2 @@\n-        final float xe = tosubpixx(pix_x3);\n-        final float ye = tosubpixy(pix_y3);\n+        final double xe = tosubpixx(pix_x3);\n+        final double ye = tosubpixy(pix_y3);\n@@ -711,2 +707,2 @@\n-    public void quadTo(final float pix_x1, final float pix_y1,\n-                       final float pix_x2, final float pix_y2)\n+    public void quadTo(final double pix_x1, final double pix_y1,\n+                       final double pix_x2, final double pix_y2)\n@@ -714,2 +710,2 @@\n-        final float xe = tosubpixx(pix_x2);\n-        final float ye = tosubpixy(pix_y2);\n+        final double xe = tosubpixx(pix_x2);\n+        final double ye = tosubpixy(pix_y2);\n@@ -1402,2 +1398,2 @@\n-        final int spminX = FloatMath.max(FloatMath.ceil_int(edgeMinX - 0.5f), boundsMinX);\n-        final int spmaxX = FloatMath.min(FloatMath.ceil_int(edgeMaxX - 0.5f), boundsMaxX);\n+        final int spminX = FloatMath.max(FloatMath.ceil_int(edgeMinX - 0.5d), boundsMinX);\n+        final int spmaxX = FloatMath.min(FloatMath.ceil_int(edgeMaxX - 0.5d), boundsMaxX);\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/marlin\/Renderer.java","additions":92,"deletions":96,"binary":false,"changes":188,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-import sun.java2d.marlin.MarlinRenderingEngine.NormalizingPathIterator;\n+import sun.java2d.marlin.DMarlinRenderingEngine.NormalizingPathIterator;\n@@ -40,1 +40,1 @@\n-final class RendererContext extends ReentrantContext implements IRendererContext {\n+final class RendererContext extends ReentrantContext implements MarlinConst {\n@@ -60,1 +60,1 @@\n-    final float[] float6 = new float[6];\n+    final double[] double6 = new double[6];\n@@ -70,1 +70,1 @@\n-    private WeakReference<Path2D.Float> refPath2D = null;\n+    private WeakReference<Path2D.Double> refPath2D = null;\n@@ -87,1 +87,1 @@\n-    final float[] clipRect = new float[4];\n+    final double[] clipRect = new double[4];\n@@ -89,1 +89,1 @@\n-    float clipInvScale = 0.0f;\n+    double clipInvScale = 0.0d;\n@@ -100,2 +100,2 @@\n-    \/* dirty float[] cache = 4 refs (2 polystack) *\/\n-    private final FloatArrayCache dirtyFloatCache = new FloatArrayCache(false, 4);\n+    \/* dirty double[] cache = 4 refs (2 polystack) *\/\n+    private final DoubleArrayCache dirtyDoubleCache = new DoubleArrayCache(false, 4);\n@@ -108,0 +108,2 @@\n+    final PathConsumer2DAdapter p2dAdapter = new PathConsumer2DAdapter();\n+\n@@ -124,1 +126,1 @@\n-                dirtyIntCache.stats, dirtyFloatCache.stats, dirtyByteCache.stats\n+                dirtyIntCache.stats, dirtyDoubleCache.stats, dirtyByteCache.stats\n@@ -131,2 +133,2 @@\n-        nPCPathIterator = new NormalizingPathIterator.NearestPixelCenter(float6);\n-        nPQPathIterator  = new NormalizingPathIterator.NearestPixelQuarter(float6);\n+        nPCPathIterator = new NormalizingPathIterator.NearestPixelCenter(double6);\n+        nPQPathIterator  = new NormalizingPathIterator.NearestPixelQuarter(double6);\n@@ -164,1 +166,1 @@\n-        clipInvScale = 0.0f;\n+        clipInvScale = 0.0d;\n@@ -184,1 +186,1 @@\n-    Path2D.Float getPath2D() {\n+    Path2D.Double getPath2D() {\n@@ -186,1 +188,1 @@\n-        Path2D.Float p2d = (refPath2D != null) ? refPath2D.get() : null;\n+        Path2D.Double p2d = (refPath2D != null) ? refPath2D.get() : null;\n@@ -190,1 +192,1 @@\n-            p2d = new Path2D.Float(WIND_NON_ZERO, INITIAL_EDGES_COUNT); \/\/ 32K\n+            p2d = new Path2D.Double(WIND_NON_ZERO, INITIAL_EDGES_COUNT); \/\/ 32K\n@@ -193,1 +195,1 @@\n-            refPath2D = new WeakReference<Path2D.Float>(p2d);\n+            refPath2D = new WeakReference<Path2D.Double>(p2d);\n@@ -200,2 +202,1 @@\n-    @Override\n-    public RendererStats stats() {\n+    RendererStats stats() {\n@@ -205,2 +206,1 @@\n-    @Override\n-    public OffHeapArray newOffHeapArray(final long initialSize) {\n+    OffHeapArray newOffHeapArray(final long initialSize) {\n@@ -213,2 +213,1 @@\n-    @Override\n-    public IntArrayCache.Reference newCleanIntArrayRef(final int initialSize) {\n+    IntArrayCache.Reference newCleanIntArrayRef(final int initialSize) {\n@@ -222,2 +221,2 @@\n-    FloatArrayCache.Reference newDirtyFloatArrayRef(final int initialSize) {\n-        return dirtyFloatCache.createRef(initialSize);\n+    DoubleArrayCache.Reference newDirtyDoubleArrayRef(final int initialSize) {\n+        return dirtyDoubleCache.createRef(initialSize);\n@@ -229,0 +228,51 @@\n+\n+    static final class PathConsumer2DAdapter implements DPathConsumer2D {\n+        private sun.awt.geom.PathConsumer2D out;\n+\n+        PathConsumer2DAdapter() {}\n+\n+        PathConsumer2DAdapter init(sun.awt.geom.PathConsumer2D out) {\n+            this.out = out;\n+            return this;\n+        }\n+\n+        @Override\n+        public void moveTo(double x0, double y0) {\n+            out.moveTo((float)x0, (float)y0);\n+        }\n+\n+        @Override\n+        public void lineTo(double x1, double y1) {\n+            out.lineTo((float)x1, (float)y1);\n+        }\n+\n+        @Override\n+        public void closePath() {\n+            out.closePath();\n+        }\n+\n+        @Override\n+        public void pathDone() {\n+            out.pathDone();\n+        }\n+\n+        @Override\n+        public void curveTo(double x1, double y1,\n+                            double x2, double y2,\n+                            double x3, double y3)\n+        {\n+            out.curveTo((float)x1, (float)y1,\n+                    (float)x2, (float)y2,\n+                    (float)x3, (float)y3);\n+        }\n+\n+        @Override\n+        public void quadTo(double x1, double y1, double x2, double y2) {\n+            out.quadTo((float)x1, (float)y1, (float)x2, (float)y2);\n+        }\n+\n+        @Override\n+        public long getNativeConsumer() {\n+            throw new InternalError(\"Not using a native peer\");\n+        }\n+    }\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/marlin\/RendererContext.java","additions":74,"deletions":24,"binary":false,"changes":98,"status":"modified"},{"patch":"@@ -29,2 +29,0 @@\n-\n-import sun.awt.geom.PathConsumer2D;\n@@ -38,1 +36,1 @@\n-final class Stroker implements PathConsumer2D, MarlinConst {\n+final class Stroker implements DPathConsumer2D, MarlinConst {\n@@ -45,2 +43,2 @@\n-    private static final float ERR_JOIN = (1.0f \/ MIN_SUBPIXELS);\n-    private static final float ROUND_JOIN_THRESHOLD = ERR_JOIN * ERR_JOIN;\n+    private static final double ERR_JOIN = (1.0f \/ MIN_SUBPIXELS);\n+    private static final double ROUND_JOIN_THRESHOLD = ERR_JOIN * ERR_JOIN;\n@@ -49,1 +47,1 @@\n-    private static final float C = (float)(4.0d * (Math.sqrt(2.0d) - 1.0d) \/ 3.0d);\n+    private static final double C = (4.0d * (Math.sqrt(2.0d) - 1.0d) \/ 3.0d);\n@@ -52,1 +50,1 @@\n-    private static final float SQRT_2 = (float)Math.sqrt(2.0d);\n+    private static final double SQRT_2 = Math.sqrt(2.0d);\n@@ -54,1 +52,1 @@\n-    private PathConsumer2D out;\n+    private DPathConsumer2D out;\n@@ -59,2 +57,2 @@\n-    private float lineWidth2;\n-    private float invHalfLineWidth2Sq;\n+    private double lineWidth2;\n+    private double invHalfLineWidth2Sq;\n@@ -62,5 +60,5 @@\n-    private final float[] offset0 = new float[2];\n-    private final float[] offset1 = new float[2];\n-    private final float[] offset2 = new float[2];\n-    private final float[] miter = new float[2];\n-    private float miterLimitSq;\n+    private final double[] offset0 = new double[2];\n+    private final double[] offset1 = new double[2];\n+    private final double[] offset2 = new double[2];\n+    private final double[] miter = new double[2];\n+    private double miterLimitSq;\n@@ -71,1 +69,1 @@\n-    private float sx0, sy0, sdx, sdy;\n+    private double sx0, sy0, sdx, sdy;\n@@ -73,1 +71,1 @@\n-    private float cx0, cy0, cdx, cdy; \/\/ c stands for current\n+    private double cx0, cy0, cdx, cdy; \/\/ c stands for current\n@@ -80,1 +78,1 @@\n-    private float smx, smy, cmx, cmy;\n+    private double smx, smy, cmx, cmy;\n@@ -84,2 +82,2 @@\n-    private final float[] lp = new float[8];\n-    private final float[] rp = new float[8];\n+    private final double[] lp = new double[8];\n+    private final double[] rp = new double[8];\n@@ -94,1 +92,1 @@\n-    private float[] clipRect;\n+    private double[] clipRect;\n@@ -109,1 +107,1 @@\n-    private boolean subdivide = DO_CLIP_SUBDIVIDER;\n+    private boolean subdivide = false;\n@@ -135,1 +133,1 @@\n-     * @param pc2d an output <code>PathConsumer2D<\/code>.\n+     * @param pc2d an output <code>DPathConsumer2D<\/code>.\n@@ -147,6 +145,6 @@\n-    Stroker init(final PathConsumer2D pc2d,\n-                 final float lineWidth,\n-                 final int capStyle,\n-                 final int joinStyle,\n-                 final float miterLimit,\n-                 final boolean subdivideCurves)\n+    Stroker init(final DPathConsumer2D pc2d,\n+                  final double lineWidth,\n+                  final int capStyle,\n+                  final int joinStyle,\n+                  final double miterLimit,\n+                  final boolean subdivideCurves)\n@@ -156,2 +154,2 @@\n-        this.lineWidth2 = lineWidth \/ 2.0f;\n-        this.invHalfLineWidth2Sq = 1.0f \/ (2.0f * lineWidth2 * lineWidth2);\n+        this.lineWidth2 = lineWidth \/ 2.0d;\n+        this.invHalfLineWidth2Sq = 1.0d \/ (2.0d * lineWidth2 * lineWidth2);\n@@ -163,1 +161,1 @@\n-        final float limit = miterLimit * lineWidth2;\n+        final double limit = miterLimit * lineWidth2;\n@@ -172,1 +170,1 @@\n-            float margin = lineWidth2;\n+            double margin = lineWidth2;\n@@ -183,1 +181,1 @@\n-            final float[] _clipRect = rdrCtx.clipRect;\n+            final double[] _clipRect = rdrCtx.clipRect;\n@@ -229,6 +227,6 @@\n-            Arrays.fill(offset0, 0.0f);\n-            Arrays.fill(offset1, 0.0f);\n-            Arrays.fill(offset2, 0.0f);\n-            Arrays.fill(miter, 0.0f);\n-            Arrays.fill(lp, 0.0f);\n-            Arrays.fill(rp, 0.0f);\n+            Arrays.fill(offset0, 0.0d);\n+            Arrays.fill(offset1, 0.0d);\n+            Arrays.fill(offset2, 0.0d);\n+            Arrays.fill(miter, 0.0d);\n+            Arrays.fill(lp, 0.0d);\n+            Arrays.fill(rp, 0.0d);\n@@ -238,2 +236,2 @@\n-    private static void computeOffset(final float lx, final float ly,\n-                                      final float w, final float[] m)\n+    private static void computeOffset(final double lx, final double ly,\n+                                      final double w, final double[] m)\n@@ -241,4 +239,4 @@\n-        float len = lx*lx + ly*ly;\n-        if (len == 0.0f) {\n-            m[0] = 0.0f;\n-            m[1] = 0.0f;\n+        double len = lx*lx + ly*ly;\n+        if (len == 0.0d) {\n+            m[0] = 0.0d;\n+            m[1] = 0.0d;\n@@ -246,1 +244,1 @@\n-            len = (float) Math.sqrt(len);\n+            len = Math.sqrt(len);\n@@ -260,2 +258,2 @@\n-    private static boolean isCW(final float dx1, final float dy1,\n-                                final float dx2, final float dy2)\n+    private static boolean isCW(final double dx1, final double dy1,\n+                                final double dx2, final double dy2)\n@@ -266,3 +264,3 @@\n-    private void mayDrawRoundJoin(float cx, float cy,\n-                                  float omx, float omy,\n-                                  float mx, float my,\n+    private void mayDrawRoundJoin(double cx, double cy,\n+                                  double omx, double omy,\n+                                  double mx, double my,\n@@ -271,1 +269,1 @@\n-        if ((omx == 0.0f && omy == 0.0f) || (mx == 0.0f && my == 0.0f)) {\n+        if ((omx == 0.0d && omy == 0.0d) || (mx == 0.0d && my == 0.0d)) {\n@@ -275,3 +273,3 @@\n-        final float domx = omx - mx;\n-        final float domy = omy - my;\n-        final float lenSq = domx*domx + domy*domy;\n+        final double domx = omx - mx;\n+        final double domy = omy - my;\n+        final double lenSq = domx*domx + domy*domy;\n@@ -292,3 +290,3 @@\n-    private void drawRoundJoin(float cx, float cy,\n-                               float omx, float omy,\n-                               float mx, float my,\n+    private void drawRoundJoin(double cx, double cy,\n+                               double omx, double omy,\n+                               double mx, double my,\n@@ -300,1 +298,1 @@\n-        final float cosext = omx * mx + omy * my;\n+        final double cosext = omx * mx + omy * my;\n@@ -304,1 +302,1 @@\n-        if (cosext >= 0.0f) {\n+        if (cosext >= 0.0d) {\n@@ -321,4 +319,4 @@\n-            float nx = my - omy, ny = omx - mx;\n-            float nlen = (float) Math.sqrt(nx*nx + ny*ny);\n-            float scale = lineWidth2\/nlen;\n-            float mmx = nx * scale, mmy = ny * scale;\n+            double nx = my - omy, ny = omx - mx;\n+            double nlen = Math.sqrt(nx*nx + ny*ny);\n+            double scale = lineWidth2\/nlen;\n+            double mmx = nx * scale, mmy = ny * scale;\n@@ -339,3 +337,3 @@\n-    private void drawBezApproxForArc(final float cx, final float cy,\n-                                     final float omx, final float omy,\n-                                     final float mx, final float my,\n+    private void drawBezApproxForArc(final double cx, final double cy,\n+                                     final double omx, final double omy,\n+                                     final double mx, final double my,\n@@ -344,1 +342,1 @@\n-        final float cosext2 = (omx * mx + omy * my) * invHalfLineWidth2Sq;\n+        final double cosext2 = (omx * mx + omy * my) * invHalfLineWidth2Sq;\n@@ -348,1 +346,1 @@\n-        if (cosext2 >= 0.5f) {\n+        if (cosext2 >= 0.5d) {\n@@ -358,1 +356,1 @@\n-        float cv = (float) ((4.0d \/ 3.0d) * Math.sqrt(0.5d - cosext2) \/\n+        double cv = ((4.0d \/ 3.0d) * Math.sqrt(0.5d - cosext2) \/\n@@ -364,4 +362,4 @@\n-        final float x1 = cx + omx;\n-        final float y1 = cy + omy;\n-        final float x2 = x1 - cv * omy;\n-        final float y2 = y1 + cv * omx;\n+        final double x1 = cx + omx;\n+        final double y1 = cy + omy;\n+        final double x2 = x1 - cv * omy;\n+        final double y2 = y1 + cv * omx;\n@@ -369,4 +367,4 @@\n-        final float x4 = cx + mx;\n-        final float y4 = cy + my;\n-        final float x3 = x4 + cv * my;\n-        final float y3 = y4 - cv * mx;\n+        final double x4 = cx + mx;\n+        final double y4 = cy + my;\n+        final double x3 = x4 + cv * my;\n+        final double y3 = y4 - cv * mx;\n@@ -377,3 +375,3 @@\n-    private void drawRoundCap(float cx, float cy, float mx, float my) {\n-        final float Cmx = C * mx;\n-        final float Cmy = C * my;\n+    private void drawRoundCap(double cx, double cy, double mx, double my) {\n+        final double Cmx = C * mx;\n+        final double Cmy = C * my;\n@@ -390,5 +388,5 @@\n-    private static void computeMiter(final float x0, final float y0,\n-                                     final float x1, final float y1,\n-                                     final float x0p, final float y0p,\n-                                     final float x1p, final float y1p,\n-                                     final float[] m)\n+    private static void computeMiter(final double x0, final double y0,\n+                                     final double x1, final double y1,\n+                                     final double x0p, final double y0p,\n+                                     final double x1p, final double y1p,\n+                                     final double[] m)\n@@ -396,4 +394,4 @@\n-        float x10 = x1 - x0;\n-        float y10 = y1 - y0;\n-        float x10p = x1p - x0p;\n-        float y10p = y1p - y0p;\n+        double x10 = x1 - x0;\n+        double y10 = y1 - y0;\n+        double x10p = x1p - x0p;\n+        double y10p = y1p - y0p;\n@@ -410,2 +408,2 @@\n-        float den = x10*y10p - x10p*y10;\n-        float t = x10p*(y0-y0p) - y10p*(x0-x0p);\n+        double den = x10*y10p - x10p*y10;\n+        double t = x10p*(y0-y0p) - y10p*(x0-x0p);\n@@ -419,5 +417,5 @@\n-    private static void safeComputeMiter(final float x0, final float y0,\n-                                         final float x1, final float y1,\n-                                         final float x0p, final float y0p,\n-                                         final float x1p, final float y1p,\n-                                         final float[] m)\n+    private static void safeComputeMiter(final double x0, final double y0,\n+                                         final double x1, final double y1,\n+                                         final double x0p, final double y0p,\n+                                         final double x1p, final double y1p,\n+                                         final double[] m)\n@@ -425,4 +423,4 @@\n-        float x10 = x1 - x0;\n-        float y10 = y1 - y0;\n-        float x10p = x1p - x0p;\n-        float y10p = y1p - y0p;\n+        double x10 = x1 - x0;\n+        double y10 = y1 - y0;\n+        double x10p = x1p - x0p;\n+        double y10p = y1p - y0p;\n@@ -439,4 +437,4 @@\n-        float den = x10*y10p - x10p*y10;\n-        if (den == 0.0f) {\n-            m[2] = (x0 + x0p) \/ 2.0f;\n-            m[3] = (y0 + y0p) \/ 2.0f;\n+        double den = x10*y10p - x10p*y10;\n+        if (den == 0.0d) {\n+            m[2] = (x0 + x0p) \/ 2.0d;\n+            m[3] = (y0 + y0p) \/ 2.0d;\n@@ -444,1 +442,1 @@\n-            float t = x10p*(y0-y0p) - y10p*(x0-x0p);\n+            double t = x10p*(y0-y0p) - y10p*(x0-x0p);\n@@ -451,5 +449,5 @@\n-    private void drawMiter(final float pdx, final float pdy,\n-                           final float x0, final float y0,\n-                           final float dx, final float dy,\n-                           float omx, float omy,\n-                           float mx, float my,\n+    private void drawMiter(final double pdx, final double pdy,\n+                           final double x0, final double y0,\n+                           final double dx, final double dy,\n+                           double omx, double omy,\n+                           double mx, double my,\n@@ -459,2 +457,2 @@\n-            (pdx == 0.0f && pdy == 0.0f) ||\n-            (dx == 0.0f && dy == 0.0f))\n+            (pdx == 0.0d && pdy == 0.0d) ||\n+            (dx == 0.0d && dy == 0.0d))\n@@ -475,3 +473,3 @@\n-        final float miterX = miter[0];\n-        final float miterY = miter[1];\n-        float lenSq = (miterX-x0)*(miterX-x0) + (miterY-y0)*(miterY-y0);\n+        final double miterX = miter[0];\n+        final double miterY = miter[1];\n+        double lenSq = (miterX-x0)*(miterX-x0) + (miterY-y0)*(miterY-y0);\n@@ -490,1 +488,1 @@\n-    public void moveTo(final float x0, final float y0) {\n+    public void moveTo(final double x0, final double y0) {\n@@ -495,2 +493,2 @@\n-        this.sdx = 1.0f;\n-        this.sdy = 0.0f;\n+        this.sdx = 1.0d;\n+        this.sdy = 0.0d;\n@@ -507,1 +505,1 @@\n-    private void _moveTo(final float x0, final float y0,\n+    private void _moveTo(final double x0, final double y0,\n@@ -520,2 +518,2 @@\n-            this.cdx = 1.0f;\n-            this.cdy = 0.0f;\n+            this.cdx = 1.0d;\n+            this.cdy = 0.0d;\n@@ -526,1 +524,1 @@\n-    public void lineTo(final float x1, final float y1) {\n+    public void lineTo(final double x1, final double y1) {\n@@ -530,1 +528,1 @@\n-    private void lineTo(final float x1, final float y1,\n+    private void lineTo(final double x1, final double y1,\n@@ -570,4 +568,4 @@\n-        float dx = x1 - cx0;\n-        float dy = y1 - cy0;\n-        if (dx == 0.0f && dy == 0.0f) {\n-            dx = 1.0f;\n+        double dx = x1 - cx0;\n+        double dy = y1 - cy0;\n+        if (dx == 0.0d && dy == 0.0d) {\n+            dx = 1.0d;\n@@ -576,2 +574,2 @@\n-        final float mx = offset0[0];\n-        final float my = offset0[1];\n+        final double mx = offset0[0];\n+        final double my = offset0[1];\n@@ -605,4 +603,4 @@\n-            this.sdx = 1.0f;\n-            this.sdy = 0.0f;\n-            this.cdx = 1.0f;\n-            this.cdy = 0.0f;\n+            this.sdx = 1.0d;\n+            this.sdy = 0.0d;\n+            this.cdx = 1.0d;\n+            this.cdy = 0.0d;\n@@ -610,1 +608,1 @@\n-            this.smx = 0.0f;\n+            this.smx = 0.0d;\n@@ -612,1 +610,1 @@\n-            this.cmx = 0.0f;\n+            this.cmx = 0.0d;\n@@ -707,1 +705,1 @@\n-    private void emitMoveTo(final float x0, final float y0) {\n+    private void emitMoveTo(final double x0, final double y0) {\n@@ -711,1 +709,1 @@\n-    private void emitLineTo(final float x1, final float y1) {\n+    private void emitLineTo(final double x1, final double y1) {\n@@ -715,1 +713,1 @@\n-    private void emitLineToRev(final float x1, final float y1) {\n+    private void emitLineToRev(final double x1, final double y1) {\n@@ -719,1 +717,1 @@\n-    private void emitLineTo(final float x1, final float y1,\n+    private void emitLineTo(final double x1, final double y1,\n@@ -729,2 +727,2 @@\n-    private void emitQuadTo(final float x1, final float y1,\n-                            final float x2, final float y2)\n+    private void emitQuadTo(final double x1, final double y1,\n+                            final double x2, final double y2)\n@@ -735,2 +733,2 @@\n-    private void emitQuadToRev(final float x0, final float y0,\n-                               final float x1, final float y1)\n+    private void emitQuadToRev(final double x0, final double y0,\n+                               final double x1, final double y1)\n@@ -741,3 +739,3 @@\n-    private void emitCurveTo(final float x1, final float y1,\n-                             final float x2, final float y2,\n-                             final float x3, final float y3)\n+    private void emitCurveTo(final double x1, final double y1,\n+                             final double x2, final double y2,\n+                             final double x3, final double y3)\n@@ -748,3 +746,3 @@\n-    private void emitCurveToRev(final float x0, final float y0,\n-                                final float x1, final float y1,\n-                                final float x2, final float y2)\n+    private void emitCurveToRev(final double x0, final double y0,\n+                                final double x1, final double y1,\n+                                final double x2, final double y2)\n@@ -755,4 +753,4 @@\n-    private void emitCurveTo(final float x0, final float y0,\n-                             final float x1, final float y1,\n-                             final float x2, final float y2,\n-                             final float x3, final float y3, final boolean rev)\n+    private void emitCurveTo(final double x0, final double y0,\n+                             final double x1, final double y1,\n+                             final double x2, final double y2,\n+                             final double x3, final double y3, final boolean rev)\n@@ -771,5 +769,5 @@\n-    private void drawJoin(float pdx, float pdy,\n-                          float x0, float y0,\n-                          float dx, float dy,\n-                          float omx, float omy,\n-                          float mx, float my,\n+    private void drawJoin(double pdx, double pdy,\n+                          double x0, double y0,\n+                          double dx, double dy,\n+                          double omx, double omy,\n+                          double mx, double my,\n@@ -800,3 +798,3 @@\n-    private static boolean within(final float x1, final float y1,\n-                                  final float x2, final float y2,\n-                                  final float err)\n+    private static boolean within(final double x1, final double y1,\n+                                  final double x2, final double y2,\n+                                  final double err)\n@@ -811,3 +809,3 @@\n-    private void getLineOffsets(final float x1, final float y1,\n-                                final float x2, final float y2,\n-                                final float[] left, final float[] right)\n+    private void getLineOffsets(final double x1, final double y1,\n+                                final double x2, final double y2,\n+                                final double[] left, final double[] right)\n@@ -816,2 +814,2 @@\n-        final float mx = offset0[0];\n-        final float my = offset0[1];\n+        final double mx = offset0[0];\n+        final double my = offset0[1];\n@@ -829,3 +827,3 @@\n-    private int computeOffsetCubic(final float[] pts, final int off,\n-                                   final float[] leftOff,\n-                                   final float[] rightOff)\n+    private int computeOffsetCubic(final double[] pts, final int off,\n+                                   final double[] leftOff,\n+                                   final double[] rightOff)\n@@ -840,4 +838,4 @@\n-        final float x1 = pts[off    ], y1 = pts[off + 1];\n-        final float x2 = pts[off + 2], y2 = pts[off + 3];\n-        final float x3 = pts[off + 4], y3 = pts[off + 5];\n-        final float x4 = pts[off + 6], y4 = pts[off + 7];\n+        final double x1 = pts[off    ], y1 = pts[off + 1];\n+        final double x2 = pts[off + 2], y2 = pts[off + 3];\n+        final double x3 = pts[off + 4], y3 = pts[off + 5];\n+        final double x4 = pts[off + 6], y4 = pts[off + 7];\n@@ -845,4 +843,4 @@\n-        float dx4 = x4 - x3;\n-        float dy4 = y4 - y3;\n-        float dx1 = x2 - x1;\n-        float dy1 = y2 - y1;\n+        double dx4 = x4 - x3;\n+        double dy4 = y4 - y3;\n+        double dx1 = x2 - x1;\n+        double dy1 = y2 - y1;\n@@ -852,2 +850,2 @@\n-        final boolean p1eqp2 = within(x1, y1, x2, y2, 6.0f * Math.ulp(y2));\n-        final boolean p3eqp4 = within(x3, y3, x4, y4, 6.0f * Math.ulp(y4));\n+        final boolean p1eqp2 = within(x1, y1, x2, y2, 6.0d * Math.ulp(y2));\n+        final boolean p3eqp4 = within(x3, y3, x4, y4, 6.0d * Math.ulp(y4));\n@@ -867,1 +865,1 @@\n-        float dotsq = (dx1 * dx4 + dy1 * dy4);\n+        double dotsq = (dx1 * dx4 + dy1 * dy4);\n@@ -869,1 +867,1 @@\n-        float l1sq = dx1 * dx1 + dy1 * dy1, l4sq = dx4 * dx4 + dy4 * dy4;\n+        double l1sq = dx1 * dx1 + dy1 * dy1, l4sq = dx4 * dx4 + dy4 * dy4;\n@@ -871,1 +869,1 @@\n-        if (Helpers.within(dotsq, l1sq * l4sq, 4.0f * Math.ulp(dotsq))) {\n+        if (Helpers.within(dotsq, l1sq * l4sq, 4.0d * Math.ulp(dotsq))) {\n@@ -923,2 +921,2 @@\n-        float x = (x1 + 3.0f * (x2 + x3) + x4) \/ 8.0f;\n-        float y = (y1 + 3.0f * (y2 + y3) + y4) \/ 8.0f;\n+        double x = (x1 + 3.0d * (x2 + x3) + x4) \/ 8.0d;\n+        double y = (y1 + 3.0d * (y2 + y3) + y4) \/ 8.0d;\n@@ -927,1 +925,1 @@\n-        float dxm = x3 + x4 - x1 - x2, dym = y3 + y4 - y1 - y2;\n+        double dxm = x3 + x4 - x1 - x2, dym = y3 + y4 - y1 - y2;\n@@ -935,6 +933,6 @@\n-        float x1p = x1 + offset0[0]; \/\/ start\n-        float y1p = y1 + offset0[1]; \/\/ point\n-        float xi  = x  + offset1[0]; \/\/ interpolation\n-        float yi  = y  + offset1[1]; \/\/ point\n-        float x4p = x4 + offset2[0]; \/\/ end\n-        float y4p = y4 + offset2[1]; \/\/ point\n+        double x1p = x1 + offset0[0]; \/\/ start\n+        double y1p = y1 + offset0[1]; \/\/ point\n+        double xi  = x  + offset1[0]; \/\/ interpolation\n+        double yi  = y  + offset1[1]; \/\/ point\n+        double x4p = x4 + offset2[0]; \/\/ end\n+        double y4p = y4 + offset2[1]; \/\/ point\n@@ -942,1 +940,1 @@\n-        float invdet43 = 4.0f \/ (3.0f * (dx1 * dy4 - dy1 * dx4));\n+        double invdet43 = 4.0d \/ (3.0d * (dx1 * dy4 - dy1 * dx4));\n@@ -944,4 +942,4 @@\n-        float two_pi_m_p1_m_p4x = 2.0f * xi - x1p - x4p;\n-        float two_pi_m_p1_m_p4y = 2.0f * yi - y1p - y4p;\n-        float c1 = invdet43 * (dy4 * two_pi_m_p1_m_p4x - dx4 * two_pi_m_p1_m_p4y);\n-        float c2 = invdet43 * (dx1 * two_pi_m_p1_m_p4y - dy1 * two_pi_m_p1_m_p4x);\n+        double two_pi_m_p1_m_p4x = 2.0d * xi - x1p - x4p;\n+        double two_pi_m_p1_m_p4y = 2.0d * yi - y1p - y4p;\n+        double c1 = invdet43 * (dy4 * two_pi_m_p1_m_p4x - dx4 * two_pi_m_p1_m_p4y);\n+        double c2 = invdet43 * (dx1 * two_pi_m_p1_m_p4y - dy1 * two_pi_m_p1_m_p4x);\n@@ -949,1 +947,1 @@\n-        float x2p, y2p, x3p, y3p;\n+        double x2p, y2p, x3p, y3p;\n@@ -961,1 +959,1 @@\n-        xi = xi - 2.0f * offset1[0]; yi = yi - 2.0f * offset1[1];\n+        xi = xi - 2.0d * offset1[0]; yi = yi - 2.0d * offset1[1];\n@@ -964,2 +962,2 @@\n-        two_pi_m_p1_m_p4x = 2.0f * xi - x1p - x4p;\n-        two_pi_m_p1_m_p4y = 2.0f * yi - y1p - y4p;\n+        two_pi_m_p1_m_p4x = 2.0d * xi - x1p - x4p;\n+        two_pi_m_p1_m_p4y = 2.0d * yi - y1p - y4p;\n@@ -984,3 +982,3 @@\n-    private int computeOffsetQuad(final float[] pts, final int off,\n-                                  final float[] leftOff,\n-                                  final float[] rightOff)\n+    private int computeOffsetQuad(final double[] pts, final int off,\n+                                  final double[] leftOff,\n+                                  final double[] rightOff)\n@@ -988,3 +986,3 @@\n-        final float x1 = pts[off    ], y1 = pts[off + 1];\n-        final float x2 = pts[off + 2], y2 = pts[off + 3];\n-        final float x3 = pts[off + 4], y3 = pts[off + 5];\n+        final double x1 = pts[off    ], y1 = pts[off + 1];\n+        final double x2 = pts[off + 2], y2 = pts[off + 3];\n+        final double x3 = pts[off + 4], y3 = pts[off + 5];\n@@ -992,4 +990,4 @@\n-        final float dx3 = x3 - x2;\n-        final float dy3 = y3 - y2;\n-        final float dx1 = x2 - x1;\n-        final float dy1 = y2 - y1;\n+        final double dx3 = x3 - x2;\n+        final double dy3 = y3 - y2;\n+        final double dx1 = x2 - x1;\n+        final double dy1 = y2 - y1;\n@@ -1007,2 +1005,2 @@\n-        final boolean p1eqp2 = within(x1, y1, x2, y2, 6.0f * Math.ulp(y2));\n-        final boolean p2eqp3 = within(x2, y2, x3, y3, 6.0f * Math.ulp(y3));\n+        final boolean p1eqp2 = within(x1, y1, x2, y2, 6.0d * Math.ulp(y2));\n+        final boolean p2eqp3 = within(x2, y2, x3, y3, 6.0d * Math.ulp(y3));\n@@ -1016,1 +1014,1 @@\n-        float dotsq = (dx1 * dx3 + dy1 * dy3);\n+        double dotsq = (dx1 * dx3 + dy1 * dy3);\n@@ -1018,1 +1016,1 @@\n-        float l1sq = dx1 * dx1 + dy1 * dy1, l3sq = dx3 * dx3 + dy3 * dy3;\n+        double l1sq = dx1 * dx1 + dy1 * dy1, l3sq = dx3 * dx3 + dy3 * dy3;\n@@ -1020,1 +1018,1 @@\n-        if (Helpers.within(dotsq, l1sq * l3sq, 4.0f * Math.ulp(dotsq))) {\n+        if (Helpers.within(dotsq, l1sq * l3sq, 4.0d * Math.ulp(dotsq))) {\n@@ -1031,4 +1029,4 @@\n-        float x1p = x1 + offset0[0]; \/\/ start\n-        float y1p = y1 + offset0[1]; \/\/ point\n-        float x3p = x3 + offset1[0]; \/\/ end\n-        float y3p = y3 + offset1[1]; \/\/ point\n+        double x1p = x1 + offset0[0]; \/\/ start\n+        double y1p = y1 + offset0[1]; \/\/ point\n+        double x3p = x3 + offset1[0]; \/\/ end\n+        double y3p = y3 + offset1[1]; \/\/ point\n@@ -1048,3 +1046,3 @@\n-    public void curveTo(final float x1, final float y1,\n-                        final float x2, final float y2,\n-                        final float x3, final float y3)\n+    public void curveTo(final double x1, final double y1,\n+                        final double x2, final double y2,\n+                        final double x3, final double y3)\n@@ -1094,3 +1092,3 @@\n-    private void _curveTo(final float x1, final float y1,\n-                          final float x2, final float y2,\n-                          final float x3, final float y3,\n+    private void _curveTo(final double x1, final double y1,\n+                          final double x2, final double y2,\n+                          final double x3, final double y3,\n@@ -1100,4 +1098,4 @@\n-        float dxs = x1 - cx0;\n-        float dys = y1 - cy0;\n-        float dxf = x3 - x2;\n-        float dyf = y3 - y2;\n+        double dxs = x1 - cx0;\n+        double dys = y1 - cy0;\n+        double dxf = x3 - x2;\n+        double dyf = y3 - y2;\n@@ -1105,1 +1103,1 @@\n-        if ((dxs == 0.0f) && (dys == 0.0f)) {\n+        if ((dxs == 0.0d) && (dys == 0.0d)) {\n@@ -1108,1 +1106,1 @@\n-            if ((dxs == 0.0f) && (dys == 0.0f)) {\n+            if ((dxs == 0.0d) && (dys == 0.0d)) {\n@@ -1113,1 +1111,1 @@\n-        if ((dxf == 0.0f) && (dyf == 0.0f)) {\n+        if ((dxf == 0.0d) && (dyf == 0.0d)) {\n@@ -1116,1 +1114,1 @@\n-            if ((dxf == 0.0f) && (dyf == 0.0f)) {\n+            if ((dxf == 0.0d) && (dyf == 0.0d)) {\n@@ -1121,1 +1119,1 @@\n-        if ((dxs == 0.0f) && (dys == 0.0f)) {\n+        if ((dxs == 0.0d) && (dys == 0.0d)) {\n@@ -1133,2 +1131,2 @@\n-        if (Math.abs(dxs) < 0.1f && Math.abs(dys) < 0.1f) {\n-            final float len = (float)Math.sqrt(dxs * dxs + dys * dys);\n+        if (Math.abs(dxs) < 0.1d && Math.abs(dys) < 0.1d) {\n+            final double len = Math.sqrt(dxs * dxs + dys * dys);\n@@ -1138,2 +1136,2 @@\n-        if (Math.abs(dxf) < 0.1f && Math.abs(dyf) < 0.1f) {\n-            final float len = (float)Math.sqrt(dxf * dxf + dyf * dyf);\n+        if (Math.abs(dxf) < 0.1d && Math.abs(dyf) < 0.1d) {\n+            final double len = Math.sqrt(dxf * dxf + dyf * dyf);\n@@ -1148,2 +1146,2 @@\n-        final float[] mid;\n-        final float[] l = lp;\n+        final double[] mid;\n+        final double[] l = lp;\n@@ -1166,1 +1164,1 @@\n-        final float[] r = rp;\n+        final double[] r = rp;\n@@ -1193,2 +1191,2 @@\n-        this.cmx = (l[kind - 2] - r[kind - 2]) \/ 2.0f;\n-        this.cmy = (l[kind - 1] - r[kind - 1]) \/ 2.0f;\n+        this.cmx = (l[kind - 2] - r[kind - 2]) \/ 2.0d;\n+        this.cmy = (l[kind - 1] - r[kind - 1]) \/ 2.0d;\n@@ -1198,2 +1196,2 @@\n-    public void quadTo(final float x1, final float y1,\n-                       final float x2, final float y2)\n+    public void quadTo(final double x1, final double y1,\n+                       final double x2, final double y2)\n@@ -1241,3 +1239,3 @@\n-    private void _quadTo(final float x1, final float y1,\n-                          final float x2, final float y2,\n-                          final int outcode0)\n+    private void _quadTo(final double x1, final double y1,\n+                         final double x2, final double y2,\n+                         final int outcode0)\n@@ -1246,4 +1244,4 @@\n-        float dxs = x1 - cx0;\n-        float dys = y1 - cy0;\n-        float dxf = x2 - x1;\n-        float dyf = y2 - y1;\n+        double dxs = x1 - cx0;\n+        double dys = y1 - cy0;\n+        double dxf = x2 - x1;\n+        double dyf = y2 - y1;\n@@ -1251,1 +1249,1 @@\n-        if (((dxs == 0.0f) && (dys == 0.0f)) || ((dxf == 0.0f) && (dyf == 0.0f))) {\n+        if (((dxs == 0.0d) && (dys == 0.0d)) || ((dxf == 0.0d) && (dyf == 0.0d))) {\n@@ -1255,1 +1253,1 @@\n-        if ((dxs == 0.0f) && (dys == 0.0f)) {\n+        if ((dxs == 0.0d) && (dys == 0.0d)) {\n@@ -1266,2 +1264,2 @@\n-        if (Math.abs(dxs) < 0.1f && Math.abs(dys) < 0.1f) {\n-            final float len = (float)Math.sqrt(dxs * dxs + dys * dys);\n+        if (Math.abs(dxs) < 0.1d && Math.abs(dys) < 0.1d) {\n+            final double len = Math.sqrt(dxs * dxs + dys * dys);\n@@ -1271,2 +1269,2 @@\n-        if (Math.abs(dxf) < 0.1f && Math.abs(dyf) < 0.1f) {\n-            final float len = (float)Math.sqrt(dxf * dxf + dyf * dyf);\n+        if (Math.abs(dxf) < 0.1d && Math.abs(dyf) < 0.1d) {\n+            final double len = Math.sqrt(dxf * dxf + dyf * dyf);\n@@ -1280,2 +1278,2 @@\n-        final float[] mid;\n-        final float[] l = lp;\n+        final double[] mid;\n+        final double[] l = lp;\n@@ -1297,1 +1295,1 @@\n-        final float[] r = rp;\n+        final double[] r = rp;\n@@ -1324,2 +1322,2 @@\n-        this.cmx = (l[kind - 2] - r[kind - 2]) \/ 2.0f;\n-        this.cmy = (l[kind - 1] - r[kind - 1]) \/ 2.0f;\n+        this.cmx = (l[kind - 2] - r[kind - 2]) \/ 2.0d;\n+        this.cmy = (l[kind - 1] - r[kind - 1]) \/ 2.0d;\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/marlin\/Stroker.java","additions":263,"deletions":265,"binary":false,"changes":528,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2018, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-import sun.awt.geom.PathConsumer2D;\n@@ -37,2 +36,2 @@\n-    \/\/ higher uncertainty in float variant for huge shapes > 10^7\n-    static final float CLIP_RECT_PADDING = 1.0f;\n+    \/\/ smaller uncertainty in double variant\n+    static final double CLIP_RECT_PADDING = 0.25d;\n@@ -48,1 +47,1 @@\n-    \/\/ recycled PathConsumer2D instance from wrapPath2D()\n+    \/\/ recycled DPathConsumer2D instance from wrapPath2D()\n@@ -51,1 +50,1 @@\n-    \/\/ recycled PathConsumer2D instances from deltaTransformConsumer()\n+    \/\/ recycled DPathConsumer2D instances from deltaTransformConsumer()\n@@ -55,1 +54,1 @@\n-    \/\/ recycled PathConsumer2D instances from inverseDeltaTransformConsumer()\n+    \/\/ recycled DPathConsumer2D instances from inverseDeltaTransformConsumer()\n@@ -73,1 +72,1 @@\n-    PathConsumer2D wrapPath2D(Path2D.Float p2d) {\n+    DPathConsumer2D wrapPath2D(Path2D.Double p2d) {\n@@ -77,1 +76,1 @@\n-    PathConsumer2D traceInput(PathConsumer2D out) {\n+    DPathConsumer2D traceInput(DPathConsumer2D out) {\n@@ -81,1 +80,1 @@\n-    PathConsumer2D traceClosedPathDetector(PathConsumer2D out) {\n+    DPathConsumer2D traceClosedPathDetector(DPathConsumer2D out) {\n@@ -85,1 +84,1 @@\n-    PathConsumer2D traceFiller(PathConsumer2D out) {\n+    DPathConsumer2D traceFiller(DPathConsumer2D out) {\n@@ -89,1 +88,1 @@\n-    PathConsumer2D traceStroker(PathConsumer2D out) {\n+    DPathConsumer2D traceStroker(DPathConsumer2D out) {\n@@ -93,1 +92,1 @@\n-    PathConsumer2D traceDasher(PathConsumer2D out) {\n+    DPathConsumer2D traceDasher(DPathConsumer2D out) {\n@@ -97,1 +96,1 @@\n-    PathConsumer2D detectClosedPath(PathConsumer2D out) {\n+    DPathConsumer2D detectClosedPath(DPathConsumer2D out) {\n@@ -101,1 +100,1 @@\n-    PathConsumer2D pathClipper(PathConsumer2D out) {\n+    DPathConsumer2D pathClipper(DPathConsumer2D out) {\n@@ -105,1 +104,1 @@\n-    PathConsumer2D deltaTransformConsumer(PathConsumer2D out,\n+    DPathConsumer2D deltaTransformConsumer(DPathConsumer2D out,\n@@ -111,4 +110,4 @@\n-        final float mxx = (float) at.getScaleX();\n-        final float mxy = (float) at.getShearX();\n-        final float myx = (float) at.getShearY();\n-        final float myy = (float) at.getScaleY();\n+        final double mxx = at.getScaleX();\n+        final double mxy = at.getShearX();\n+        final double myx = at.getShearY();\n+        final double myy = at.getScaleY();\n@@ -116,2 +115,2 @@\n-        if (mxy == 0.0f && myx == 0.0f) {\n-            if (mxx == 1.0f && myy == 1.0f) {\n+        if (mxy == 0.0d && myx == 0.0d) {\n+            if (mxx == 1.0d && myy == 1.0d) {\n@@ -138,2 +137,2 @@\n-    private static float adjustClipScale(final float[] clipRect,\n-                                         final float mxx, final float myy)\n+    private static double adjustClipScale(final double[] clipRect,\n+                                          final double mxx, final double myy)\n@@ -142,1 +141,1 @@\n-        final float scaleY = 1.0f \/ myy;\n+        final double scaleY = 1.0d \/ myy;\n@@ -147,1 +146,1 @@\n-            float tmp = clipRect[0];\n+            double tmp = clipRect[0];\n@@ -152,1 +151,1 @@\n-        final float scaleX = 1.0f \/ mxx;\n+        final double scaleX = 1.0d \/ mxx;\n@@ -157,1 +156,1 @@\n-            float tmp = clipRect[2];\n+            double tmp = clipRect[2];\n@@ -166,1 +165,1 @@\n-        return 0.5f * (Math.abs(scaleX) + Math.abs(scaleY));\n+        return 0.5d * (Math.abs(scaleX) + Math.abs(scaleY));\n@@ -169,3 +168,3 @@\n-    private static float adjustClipInverseDelta(final float[] clipRect,\n-                                                final float mxx, final float mxy,\n-                                                final float myx, final float myy)\n+    private static double adjustClipInverseDelta(final double[] clipRect,\n+                                                 final double mxx, final double mxy,\n+                                                 final double myx, final double myy)\n@@ -174,8 +173,8 @@\n-        final float det = mxx * myy - mxy * myx;\n-        final float imxx =  myy \/ det;\n-        final float imxy = -mxy \/ det;\n-        final float imyx = -myx \/ det;\n-        final float imyy =  mxx \/ det;\n-\n-        float xmin, xmax, ymin, ymax;\n-        float x, y;\n+        final double det = mxx * myy - mxy * myx;\n+        final double imxx =  myy \/ det;\n+        final double imxy = -mxy \/ det;\n+        final double imyx = -myx \/ det;\n+        final double imyy =  mxx \/ det;\n+\n+        double xmin, xmax, ymin, ymax;\n+        double x, y;\n@@ -220,2 +219,2 @@\n-        final float scaleX = (float) Math.sqrt(imxx * imxx + imxy * imxy);\n-        final float scaleY = (float) Math.sqrt(imyx * imyx + imyy * imyy);\n+        final double scaleX = Math.sqrt(imxx * imxx + imxy * imxy);\n+        final double scaleY = Math.sqrt(imyx * imyx + imyy * imyy);\n@@ -223,1 +222,1 @@\n-        return 0.5f * (scaleX + scaleY);\n+        return 0.5d * (scaleX + scaleY);\n@@ -226,1 +225,1 @@\n-    PathConsumer2D inverseDeltaTransformConsumer(PathConsumer2D out,\n+    DPathConsumer2D inverseDeltaTransformConsumer(DPathConsumer2D out,\n@@ -232,4 +231,4 @@\n-        float mxx = (float) at.getScaleX();\n-        float mxy = (float) at.getShearX();\n-        float myx = (float) at.getShearY();\n-        float myy = (float) at.getScaleY();\n+        double mxx = at.getScaleX();\n+        double mxy = at.getShearX();\n+        double myx = at.getShearY();\n+        double myy = at.getScaleY();\n@@ -237,2 +236,2 @@\n-        if (mxy == 0.0f && myx == 0.0f) {\n-            if (mxx == 1.0f && myy == 1.0f) {\n+        if (mxy == 0.0d && myx == 0.0d) {\n+            if (mxx == 1.0d && myy == 1.0d) {\n@@ -241,1 +240,1 @@\n-                return iv_DeltaScaleFilter.init(out, 1.0f \/ mxx, 1.0f \/ myy);\n+                return iv_DeltaScaleFilter.init(out, 1.0d \/ mxx, 1.0d \/ myy);\n@@ -244,1 +243,1 @@\n-            final float det = mxx * myy - mxy * myx;\n+            final double det = mxx * myy - mxy * myx;\n@@ -253,3 +252,3 @@\n-    static final class DeltaScaleFilter implements PathConsumer2D {\n-        private PathConsumer2D out;\n-        private float sx, sy;\n+    static final class DeltaScaleFilter implements DPathConsumer2D {\n+        private DPathConsumer2D out;\n+        private double sx, sy;\n@@ -259,2 +258,2 @@\n-        DeltaScaleFilter init(PathConsumer2D out,\n-                              float mxx, float myy)\n+        DeltaScaleFilter init(DPathConsumer2D out,\n+                              double mxx, double myy)\n@@ -269,1 +268,1 @@\n-        public void moveTo(float x0, float y0) {\n+        public void moveTo(double x0, double y0) {\n@@ -274,1 +273,1 @@\n-        public void lineTo(float x1, float y1) {\n+        public void lineTo(double x1, double y1) {\n@@ -279,2 +278,2 @@\n-        public void quadTo(float x1, float y1,\n-                           float x2, float y2)\n+        public void quadTo(double x1, double y1,\n+                           double x2, double y2)\n@@ -287,3 +286,3 @@\n-        public void curveTo(float x1, float y1,\n-                            float x2, float y2,\n-                            float x3, float y3)\n+        public void curveTo(double x1, double y1,\n+                            double x2, double y2,\n+                            double x3, double y3)\n@@ -312,3 +311,3 @@\n-    static final class DeltaTransformFilter implements PathConsumer2D {\n-        private PathConsumer2D out;\n-        private float mxx, mxy, myx, myy;\n+    static final class DeltaTransformFilter implements DPathConsumer2D {\n+        private DPathConsumer2D out;\n+        private double mxx, mxy, myx, myy;\n@@ -318,3 +317,3 @@\n-        DeltaTransformFilter init(PathConsumer2D out,\n-                                  float mxx, float mxy,\n-                                  float myx, float myy)\n+        DeltaTransformFilter init(DPathConsumer2D out,\n+                                  double mxx, double mxy,\n+                                  double myx, double myy)\n@@ -331,1 +330,1 @@\n-        public void moveTo(float x0, float y0) {\n+        public void moveTo(double x0, double y0) {\n@@ -337,1 +336,1 @@\n-        public void lineTo(float x1, float y1) {\n+        public void lineTo(double x1, double y1) {\n@@ -343,2 +342,2 @@\n-        public void quadTo(float x1, float y1,\n-                           float x2, float y2)\n+        public void quadTo(double x1, double y1,\n+                           double x2, double y2)\n@@ -353,3 +352,3 @@\n-        public void curveTo(float x1, float y1,\n-                            float x2, float y2,\n-                            float x3, float y3)\n+        public void curveTo(double x1, double y1,\n+                            double x2, double y2,\n+                            double x3, double y3)\n@@ -381,2 +380,2 @@\n-    static final class Path2DWrapper implements PathConsumer2D {\n-        private Path2D.Float p2d;\n+    static final class Path2DWrapper implements DPathConsumer2D {\n+        private Path2D.Double p2d;\n@@ -386,1 +385,1 @@\n-        Path2DWrapper init(Path2D.Float p2d) {\n+        Path2DWrapper init(Path2D.Double p2d) {\n@@ -392,1 +391,1 @@\n-        public void moveTo(float x0, float y0) {\n+        public void moveTo(double x0, double y0) {\n@@ -397,1 +396,1 @@\n-        public void lineTo(float x1, float y1) {\n+        public void lineTo(double x1, double y1) {\n@@ -410,3 +409,3 @@\n-        public void curveTo(float x1, float y1,\n-                            float x2, float y2,\n-                            float x3, float y3)\n+        public void curveTo(double x1, double y1,\n+                            double x2, double y2,\n+                            double x3, double y3)\n@@ -418,1 +417,1 @@\n-        public void quadTo(float x1, float y1, float x2, float y2) {\n+        public void quadTo(double x1, double y1, double x2, double y2) {\n@@ -428,1 +427,1 @@\n-    static final class ClosedPathDetector implements PathConsumer2D {\n+    static final class ClosedPathDetector implements DPathConsumer2D {\n@@ -433,1 +432,1 @@\n-        private PathConsumer2D out;\n+        private DPathConsumer2D out;\n@@ -447,1 +446,1 @@\n-        ClosedPathDetector init(PathConsumer2D out) {\n+        ClosedPathDetector init(DPathConsumer2D out) {\n@@ -479,1 +478,1 @@\n-        public void moveTo(float x0, float y0) {\n+        public void moveTo(double x0, double y0) {\n@@ -491,1 +490,1 @@\n-        public void lineTo(float x1, float y1) {\n+        public void lineTo(double x1, double y1) {\n@@ -496,3 +495,3 @@\n-        public void curveTo(float x3, float y3,\n-                            float x2, float y2,\n-                            float x1, float y1)\n+        public void curveTo(double x3, double y3,\n+                            double x2, double y2,\n+                            double x1, double y1)\n@@ -504,1 +503,1 @@\n-        public void quadTo(float x2, float y2, float x1, float y1) {\n+        public void quadTo(double x2, double y2, double x1, double y1) {\n@@ -514,1 +513,1 @@\n-    static final class PathClipFilter implements PathConsumer2D {\n+    static final class PathClipFilter implements DPathConsumer2D {\n@@ -516,1 +515,1 @@\n-        private PathConsumer2D out;\n+        private DPathConsumer2D out;\n@@ -519,1 +518,1 @@\n-        private final float[] clipRect;\n+        private final double[] clipRect;\n@@ -521,1 +520,1 @@\n-        private final float[] corners = new float[8];\n+        private final double[] corners = new double[8];\n@@ -535,1 +534,1 @@\n-        private float sx0, sy0;\n+        private double sx0, sy0;\n@@ -538,1 +537,1 @@\n-        private float cx0, cy0;\n+        private double cx0, cy0;\n@@ -541,1 +540,1 @@\n-        private float cox0, coy0;\n+        private double cox0, coy0;\n@@ -558,1 +557,1 @@\n-        PathClipFilter init(final PathConsumer2D out) {\n+        PathClipFilter init(final DPathConsumer2D out) {\n@@ -599,2 +598,2 @@\n-                    final float[] _corners = corners;\n-                    final float[] _clipRect = clipRect;\n+                    final double[] _corners = corners;\n+                    final double[] _clipRect = clipRect;\n@@ -645,1 +644,1 @@\n-        public void moveTo(final float x0, final float y0) {\n+        public void moveTo(final double x0, final double y0) {\n@@ -660,1 +659,1 @@\n-        public void lineTo(final float xe, final float ye) {\n+        public void lineTo(final double xe, final double ye) {\n@@ -754,3 +753,3 @@\n-        public void curveTo(final float x1, final float y1,\n-                            final float x2, final float y2,\n-                            final float xe, final float ye)\n+        public void curveTo(final double x1, final double y1,\n+                            final double x2, final double y2,\n+                            final double xe, final double ye)\n@@ -818,2 +817,2 @@\n-        public void quadTo(final float x1, final float y1,\n-                           final float xe, final float ye)\n+        public void quadTo(final double x1, final double y1,\n+                           final double xe, final double ye)\n@@ -883,1 +882,0 @@\n-    \/* note: CurveClipSplitter uses double-precision for higher accuracy *\/\n@@ -886,2 +884,2 @@\n-        static final float LEN_TH = MarlinProperties.getSubdividerMinLength();\n-        static final boolean DO_CHECK_LENGTH = (LEN_TH > 0.0f);\n+        static final double LEN_TH = MarlinProperties.getSubdividerMinLength();\n+        static final boolean DO_CHECK_LENGTH = (LEN_TH > 0.0d);\n@@ -896,1 +894,1 @@\n-        private float minLength;\n+        private double minLength;\n@@ -899,1 +897,1 @@\n-        final float[] clipRect;\n+        final double[] clipRect;\n@@ -912,1 +910,1 @@\n-        private final DCurve curve;\n+        private final Curve curve;\n@@ -917,1 +915,1 @@\n-            this.curve = \/* rdrCtx.curve *\/ new DCurve(); \/\/ double-precision curve\n+            this.curve = rdrCtx.curve;\n@@ -924,1 +922,1 @@\n-                this.minLength = (this.rdrCtx.clipInvScale == 0.0f) ? LEN_TH\n+                this.minLength = (this.rdrCtx.clipInvScale == 0.0d) ? LEN_TH\n@@ -938,1 +936,1 @@\n-            final float[] _clipRect = clipRect;\n+            final double[] _clipRect = clipRect;\n@@ -952,2 +950,2 @@\n-        boolean splitLine(final float x0, final float y0,\n-                          final float x1, final float y1,\n+        boolean splitLine(final double x0, final double y0,\n+                          final double x1, final double y1,\n@@ -955,1 +953,1 @@\n-                          final PathConsumer2D out)\n+                          final DPathConsumer2D out)\n@@ -972,3 +970,3 @@\n-        boolean splitQuad(final float x0, final float y0,\n-                          final float x1, final float y1,\n-                          final float x2, final float y2,\n+        boolean splitQuad(final double x0, final double y0,\n+                          final double x1, final double y1,\n+                          final double x2, final double y2,\n@@ -976,1 +974,1 @@\n-                          final PathConsumer2D out)\n+                          final DPathConsumer2D out)\n@@ -994,4 +992,4 @@\n-        boolean splitCurve(final float x0, final float y0,\n-                           final float x1, final float y1,\n-                           final float x2, final float y2,\n-                           final float x3, final float y3,\n+        boolean splitCurve(final double x0, final double y0,\n+                           final double x1, final double y1,\n+                           final double x2, final double y2,\n+                           final double x3, final double y3,\n@@ -999,1 +997,1 @@\n-                           final PathConsumer2D out)\n+                           final DPathConsumer2D out)\n@@ -1019,1 +1017,1 @@\n-                                                 final PathConsumer2D out)\n+                                                 final DPathConsumer2D out)\n@@ -1029,1 +1027,1 @@\n-            final int nSplits = DHelpers.findClipPoints(curve, mid, subTs, type,\n+            final int nSplits = Helpers.findClipPoints(curve, mid, subTs, type,\n@@ -1045,1 +1043,1 @@\n-                DHelpers.subdivideAt((t - prevT) \/ (1.0d - prevT),\n+                Helpers.subdivideAt((t - prevT) \/ (1.0d - prevT),\n@@ -1060,1 +1058,1 @@\n-                                final int off, final PathConsumer2D out)\n+                                final int off, final DPathConsumer2D out)\n@@ -1064,3 +1062,3 @@\n-                out.curveTo((float)pts[off + 2], (float)pts[off + 3],\n-                            (float)pts[off + 4], (float)pts[off + 5],\n-                            (float)pts[off + 6], (float)pts[off + 7]);\n+                out.curveTo(pts[off + 2], pts[off + 3],\n+                            pts[off + 4], pts[off + 5],\n+                            pts[off + 6], pts[off + 7]);\n@@ -1068,1 +1066,1 @@\n-                out.lineTo((float)pts[off + 2], (float)pts[off + 3]);\n+                out.lineTo(pts[off + 2], pts[off + 3]);\n@@ -1070,2 +1068,2 @@\n-                out.quadTo((float)pts[off + 2], (float)pts[off + 3],\n-                           (float)pts[off + 4], (float)pts[off + 5]);\n+                out.quadTo(pts[off + 2], pts[off + 3],\n+                           pts[off + 4], pts[off + 5]);\n@@ -1081,1 +1079,1 @@\n-        private float lw2;\n+        private double lw2;\n@@ -1088,1 +1086,1 @@\n-        final float[] middle = new float[MAX_N_CURVES * 6 + 2];\n+        final double[] middle = new double[MAX_N_CURVES * 6 + 2];\n@@ -1090,1 +1088,1 @@\n-        private final float[] subdivTs = new float[MAX_N_CURVES - 1];\n+        private final double[] subdivTs = new double[MAX_N_CURVES - 1];\n@@ -1099,2 +1097,2 @@\n-        void init(final float lineWidth) {\n-            this.lw2 = (lineWidth * lineWidth) \/ 4.0f;\n+        void init(final double lineWidth) {\n+            this.lw2 = (lineWidth * lineWidth) \/ 4.0d;\n@@ -1103,4 +1101,4 @@\n-        CurveBasicMonotonizer curve(final float x0, final float y0,\n-                                    final float x1, final float y1,\n-                                    final float x2, final float y2,\n-                                    final float x3, final float y3)\n+        CurveBasicMonotonizer curve(final double x0, final double y0,\n+                                    final double x1, final double y1,\n+                                    final double x2, final double y2,\n+                                    final double x3, final double y3)\n@@ -1108,1 +1106,1 @@\n-            final float[] mid = middle;\n+            final double[] mid = middle;\n@@ -1114,1 +1112,1 @@\n-            final float[] subTs = subdivTs;\n+            final double[] subTs = subdivTs;\n@@ -1117,1 +1115,1 @@\n-            float prevT = 0.0f;\n+            double prevT = 0.0d;\n@@ -1119,1 +1117,1 @@\n-                final float t = subTs[i];\n+                final double t = subTs[i];\n@@ -1121,1 +1119,1 @@\n-                Helpers.subdivideCubicAt((t - prevT) \/ (1.0f - prevT),\n+                Helpers.subdivideCubicAt((t - prevT) \/ (1.0d - prevT),\n@@ -1130,3 +1128,3 @@\n-        CurveBasicMonotonizer quad(final float x0, final float y0,\n-                                   final float x1, final float y1,\n-                                   final float x2, final float y2)\n+        CurveBasicMonotonizer quad(final double x0, final double y0,\n+                                   final double x1, final double y1,\n+                                   final double x2, final double y2)\n@@ -1134,1 +1132,1 @@\n-            final float[] mid = middle;\n+            final double[] mid = middle;\n@@ -1139,1 +1137,1 @@\n-            final float[] subTs = subdivTs;\n+            final double[] subTs = subdivTs;\n@@ -1142,1 +1140,1 @@\n-            float prevt = 0.0f;\n+            double prevt = 0.0d;\n@@ -1144,2 +1142,2 @@\n-                final float t = subTs[i];\n-                Helpers.subdivideQuadAt((t - prevt) \/ (1.0f - prevt),\n+                final double t = subTs[i];\n+                Helpers.subdivideQuadAt((t - prevt) \/ (1.0d - prevt),\n@@ -1155,1 +1153,1 @@\n-    static final class PathTracer implements PathConsumer2D {\n+    static final class PathTracer implements DPathConsumer2D {\n@@ -1157,1 +1155,1 @@\n-        private PathConsumer2D out;\n+        private DPathConsumer2D out;\n@@ -1163,1 +1161,1 @@\n-        PathTracer init(PathConsumer2D out) {\n+        PathTracer init(DPathConsumer2D out) {\n@@ -1169,1 +1167,1 @@\n-        public void moveTo(float x0, float y0) {\n+        public void moveTo(double x0, double y0) {\n@@ -1175,1 +1173,1 @@\n-        public void lineTo(float x1, float y1) {\n+        public void lineTo(double x1, double y1) {\n@@ -1181,3 +1179,3 @@\n-        public void curveTo(float x1, float y1,\n-                            float x2, float y2,\n-                            float x3, float y3)\n+        public void curveTo(double x1, double y1,\n+                            double x2, double y2,\n+                            double x3, double y3)\n@@ -1190,2 +1188,2 @@\n-        public void quadTo(float x1, float y1,\n-                           float x2, float y2) {\n+        public void quadTo(double x1, double y1,\n+                           double x2, double y2) {\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/marlin\/TransformingPathConsumer2D.java","additions":173,"deletions":175,"binary":false,"changes":348,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n-    private static final String VERSION = \"marlin-0.9.1.3-Unsafe-OpenJDK\";\n+    private static final String VERSION = \"marlin-0.9.1.4-Unsafe-OpenJDK\";\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/marlin\/Version.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -64,4 +64,0 @@\n- * @run main\/othervm\/timeout=300 -Dsun.java2d.renderer=sun.java2d.marlin.MarlinRenderingEngine ClipShapeTest -poly\n- * @run main\/othervm\/timeout=300 -Dsun.java2d.renderer=sun.java2d.marlin.MarlinRenderingEngine ClipShapeTest -poly -doDash\n- * @run main\/othervm\/timeout=300 -Dsun.java2d.renderer=sun.java2d.marlin.MarlinRenderingEngine ClipShapeTest -cubic\n- * @run main\/othervm\/timeout=300 -Dsun.java2d.renderer=sun.java2d.marlin.MarlinRenderingEngine ClipShapeTest -cubic -doDash\n@@ -136,1 +132,0 @@\n-    static final AtomicBoolean isMarlinFloat = new AtomicBoolean();\n@@ -153,2 +148,1 @@\n-                        isMarlin.set(msg.contains(\"MarlinRenderingEngine\"));\n-                        isMarlinFloat.set(!msg.contains(\"DMarlinRenderingEngine\"));\n+                        isMarlin.set(msg.contains(\"DMarlinRenderingEngine\"));\n@@ -297,4 +291,1 @@\n-                THRESHOLD_NBPIX = (USE_DASHES) ?\n-                    \/\/ float variant have higher uncertainty\n-                    ((isMarlinFloat.get()) ? 30 : 6) \/\/ low for double\n-                    : (isMarlinFloat.get()) ? 10 : 0;\n+                THRESHOLD_NBPIX = (USE_DASHES) ? 6 : 0;\n","filename":"test\/jdk\/sun\/java2d\/marlin\/ClipShapeTest.java","additions":3,"deletions":12,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -37,1 +37,0 @@\n- * @run main\/othervm\/timeout=10 -Dsun.java2d.renderer=sun.java2d.marlin.MarlinRenderingEngine StrokedLinePerf\n","filename":"test\/jdk\/sun\/java2d\/marlin\/StrokedLinePerf.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"}]}