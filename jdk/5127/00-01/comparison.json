{"files":[{"patch":"@@ -199,3 +199,4 @@\n-            selfCgroupLines.map(line -> line.split(\":\", 3))\n-                     .filter(tokens -> (tokens.length >= 3))\n-                     .forEach(action);\n+            \/\/ The limit value of 3 is because \/proc\/self\/cgroup contains three\n+            \/\/ colon-separated tokens per line. The last token, cgroup path, might\n+            \/\/ contain a ':'.\n+            selfCgroupLines.map(line -> line.split(\":\", 3)).forEach(action);\n","filename":"src\/java.base\/linux\/classes\/jdk\/internal\/platform\/CgroupSubsystemFactory.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -75,0 +75,1 @@\n+    private Path cgroupv1SelfColons;\n@@ -175,1 +176,18 @@\n-    private String cgroupv1SelfCgroupContent = \"11:memory:\/user.slice\/user-1000.slice\/user@1000.s:ervice\\n\" +\n+    private String cgroupv1SelfCgroupContent = \"11:memory:\/user.slice\/user-1000.slice\/user@1000.service\\n\" +\n+            \"10:hugetlb:\/\\n\" +\n+            \"9:cpuset:\/\\n\" +\n+            \"8:pids:\/user.slice\/user-1000.slice\/user@1000.service\\n\" +\n+            \"7:freezer:\/\\n\" +\n+            \"6:blkio:\/\\n\" +\n+            \"5:net_cls,net_prio:\/\\n\" +\n+            \"4:devices:\/user.slice\\n\" +\n+            \"3:perf_event:\/\\n\" +\n+            \"2:cpu,cpuacct:\/\\n\" +\n+            \"1:name=systemd:\/user.slice\/user-1000.slice\/user@1000.service\/apps.slice\/apps-org.gnome.Terminal.slice\/vte-spawn-3c00b338-5b65-439f-8e97-135e183d135d.scope\\n\" +\n+            \"0::\/user.slice\/user-1000.slice\/user@1000.service\/apps.slice\/apps-org.gnome.Terminal.slice\/vte-spawn-3c00b338-5b65-439f-8e97-135e183d135d.scope\\n\";\n+\n+    \/\/ `\/proc\/self\/cgroup` should contain **three** colon-separated fields,\n+    \/\/ `hierarchy-ID:controller-list:cgroup-path`. This cgroup-path intentionally\n+    \/\/ contains a colon to ensure that the correct path is being extracted by the\n+    \/\/ login in CgroupSubsystemFactory.\n+    private String cgroupv1SelfColonsContent = \"11:memory:\/system.slice\/containerd.service\/kubepods-burstable-podf65e797d_d5f9_4604_9773_94f4bb9946a0.slice:cri-containerd:86ac6260f9f8a9c1276748250f330ae9c2fcefe5ae809364ad1e45f3edf7e08a\\n\" +\n@@ -227,0 +245,3 @@\n+            cgroupv1SelfColons = Paths.get(existingDirectory.toString(), \"self_colons_cgv1\");\n+            Files.writeString(cgroupv1SelfColons, cgroupv1SelfColonsContent);\n+\n@@ -338,1 +359,1 @@\n-        assertEquals(\"\/user.slice\/user-1000.slice\/user@1000.s:ervice\", memoryInfo.getCgroupPath());\n+        assertEquals(\"\/user.slice\/user-1000.slice\/user@1000.service\", memoryInfo.getCgroupPath());\n@@ -343,0 +364,14 @@\n+    @Test\n+    public void testColonsCgroupsV1() throws IOException {\n+        String cgroups = cgroupv1CgInfoNonZeroHierarchy.toString();\n+        String mountInfo = cgroupv1MntInfoNonZeroHierarchy.toString();\n+        String selfCgroup = cgroupv1SelfColons.toString();\n+        Optional<CgroupTypeResult> result = CgroupSubsystemFactory.determineType(mountInfo, cgroups, selfCgroup);\n+\n+        assertTrue(\"Expected non-empty cgroup result\", result.isPresent());\n+        CgroupTypeResult res = result.get();\n+        CgroupInfo memoryInfo = res.getInfos().get(\"memory\");\n+        assertEquals(memoryInfo.getCgroupPath(), \"\/system.slice\/containerd.service\/kubepods-burstable-podf65e797d_d5f9_4604_9773_94f4bb9946a0.slice:cri-containerd:86ac6260f9f8a9c1276748250f330ae9c2fcefe5ae809364ad1e45f3edf7e08a\");\n+        assertEquals(memoryInfo.getMountRoot(), memoryInfo.getMountRoot());\n+    }\n+\n","filename":"test\/jdk\/jdk\/internal\/platform\/cgroup\/TestCgroupSubsystemFactory.java","additions":37,"deletions":2,"binary":false,"changes":39,"status":"modified"}]}