{"files":[{"patch":"@@ -25,2 +25,2 @@\n-#ifndef SHARE_UTILITIES_MOVE_BITS_HPP\n-#define SHARE_UTILITIES_MOVE_BITS_HPP\n+#ifndef SHARE_UTILITIES_MOVEBITS_HPP\n+#define SHARE_UTILITIES_MOVEBITS_HPP\n@@ -28,0 +28,2 @@\n+#include \"metaprogramming\/conditional.hpp\"\n+#include \"metaprogramming\/enableIf.hpp\"\n@@ -30,0 +32,1 @@\n+#include <type_traits>\n@@ -31,17 +34,3 @@\n-inline uint32_t reverse_bits_in_bytes_int(uint32_t x) {\n-  \/\/ Based on Hacker's Delight Section 7-1\n-  x = (x & 0x55555555) << 1 | (x & 0xAAAAAAAA) >> 1;\n-  x = (x & 0x33333333) << 2 | (x & 0xCCCCCCCC) >> 2;\n-  x = (x & 0x0F0F0F0F) << 4 | (x & 0xF0F0F0F0) >> 4;\n-  return x;\n-}\n-\n-inline uint32_t reverse_bytes_int(uint32_t x, size_t bw) {\n-  assert(bw == 16 || bw == 32, \"\");\n-  if (bw == 32) {\n-    \/\/ Based on Hacker's Delight Section 7-1\n-    return (x << 24) | ((x & 0xFF00) << 8) | ((x >> 8) & 0xFF00) | (x >> 24);\n-  } else {\n-    return (x & 0x00FF00FF) << 8 | (x & 0xFF00FF00) >> 8;\n-  }\n-}\n+template <typename T>\n+class ReverseBitsImpl {\n+  static const size_t S = sizeof(T);\n@@ -49,7 +38,1 @@\n-inline uint64_t reverse_bits_in_bytes_long(uint64_t x) {\n-  \/\/ Based on Hacker's Delight Section 7-1\n-  x = (x & CONST64(0x5555555555555555)) << 1 | (x & CONST64(0xAAAAAAAAAAAAAAAA)) >> 1;\n-  x = (x & CONST64(0x3333333333333333)) << 2 | (x & CONST64(0xCCCCCCCCCCCCCCCC)) >> 2;\n-  x = (x & CONST64(0x0F0F0F0F0F0F0F0F)) << 4 | (x & CONST64(0xF0F0F0F0F0F0F0F0)) >> 4;\n-  return x;\n-}\n+  static_assert((S == 1) || (S == 2) || (S == 4) || (S == 8), \"unsupported size\");\n@@ -57,4 +40,5 @@\n-inline uint64_t reverse_bytes_long(uint64_t x) {\n-  x = (x & CONST64(0x00FF00FF00FF00FF)) << 8 | (x >> 8) & CONST64(0x00FF00FF00FF00FF);\n-  return (x << 48) | ((x & 0xFFFF0000) << 16) | ((x >> 16) & 0xFFFF0000) | (x >> 48);\n-}\n+  static const uint64_t rep_5555 = UCONST64(0x5555555555555555);\n+  static const uint64_t rep_3333 = UCONST64(0x3333333333333333);\n+  static const uint64_t rep_0F0F = UCONST64(0x0F0F0F0F0F0F0F0F);\n+  static const uint64_t rep_00FF = UCONST64(0x00FF00FF00FF00FF);\n+  static const uint64_t rep_FFFF = UCONST64(0x0000FFFF0000FFFF);\n@@ -62,1 +46,1 @@\n-template <typename T, size_t S> struct ReverseBitsImpl {};\n+  using I = typename Conditional<S <= 4, uint32_t, uint64_t>::type;\n@@ -64,5 +48,5 @@\n-template <typename T> struct ReverseBitsImpl<T, 1> {\n-  static T doit(T v) {\n-    return reverse_bits_in_bytes_int(v);\n-  }\n-};\n+  \/\/ Avoid 32bit shift of uint32_t that some compilers might warn about even\n+  \/\/ though the relevant code will never be executed.  For example, gcc warns\n+  \/\/ about -Wshift-count-overflow.\n+  static constexpr uint32_t swap64(uint32_t x) { ShouldNotReachHere(); return x; }\n+  static constexpr uint64_t swap64(uint64_t x) { return (x << 32) | (x >> 32); }\n@@ -70,10 +54,1 @@\n-\/*****************************************************************************\n- * GCC and compatible (including Clang)\n- *****************************************************************************\/\n-#if defined(TARGET_COMPILER_gcc)\n-template <typename T> struct ReverseBitsImpl<T, 2> {\n-  static T doit(T v) {\n-    v = reverse_bits_in_bytes_int(v);\n-    return __builtin_bswap16(v);\n-  }\n-};\n+public:\n@@ -81,11 +56,7 @@\n-template <typename T> struct ReverseBitsImpl<T, 4> {\n-  static T doit(T v) {\n-    v = reverse_bits_in_bytes_int(v);\n-    return __builtin_bswap32(v);\n-  }\n-};\n-\n-template <typename T> struct ReverseBitsImpl<T, 8> {\n-  static T doit(T v) {\n-    v = reverse_bits_in_bytes_long(v);\n-    return __builtin_bswap64(v);\n+  static constexpr T reverse_bits_in_bytes(T v) {\n+    \/\/ Based on Hacker's Delight Section 7-1\n+    auto x = static_cast<I>(v);\n+    x = ((x & (I)rep_5555) << 1) | ((x >> 1) & (I)rep_5555);\n+    x = ((x & (I)rep_3333) << 2) | ((x >> 2) & (I)rep_3333);\n+    x = ((x & (I)rep_0F0F) << 4) | ((x >> 4) & (I)rep_0F0F);\n+    return x;\n@@ -93,1 +64,0 @@\n-};\n@@ -95,8 +65,15 @@\n-\/*****************************************************************************\n- * Fallback\n- *****************************************************************************\/\n-#else\n-template <typename T> struct ReverseBitsImpl<T, 2> {\n-  static T doit(T v) {\n-    v = reverse_bits_in_bytes_int(v);\n-    return reverse_bytes_int(r, 16);\n+  static constexpr T reverse_bytes(T v) {\n+    \/\/ Based on Hacker's Delight Section 7-1\n+    \/\/ NB: Compilers are good at recognizing byte-swap code and transforming\n+    \/\/ it into platform-specific instructions like x86 bswap.\n+    auto x = static_cast<I>(v);\n+    switch (S) {\n+    case 8:\n+      x = swap64(x);\n+    case 4:                     \/\/ fallthrough\n+      x = ((x & (I)rep_FFFF) << 16) | ((x >> 16) & (I)rep_FFFF);\n+    case 2:                     \/\/ fallthrough\n+      x = ((x & (I)rep_00FF) << 8)  | ((x >> 8)  & (I)rep_00FF);\n+    default:                    \/\/ fallthrough\n+      return x;\n+    }\n@@ -106,6 +83,5 @@\n-template <typename T> struct ReverseBitsImpl<T, 4> {\n-  static T doit(T v) {\n-    v = reverse_bits_in_bytes(v);\n-    return reverse_bytes_int(v, 32);\n-  }\n-};\n+\/\/ Performs byte reversal of an integral type up to 64 bits.\n+template <typename T, ENABLE_IF(std::is_integral<T>::value)>\n+constexpr T reverse_bytes(T x) {\n+  return ReverseBitsImpl<T>::reverse_bytes(x);\n+}\n@@ -113,7 +89,6 @@\n-template <typename T> struct ReverseBitsImpl<T, 8> {\n-  static T doit(T v) {\n-    v = reverse_bits_in_bytes(v);\n-    return reverse_bytes_long(r);\n-  }\n-};\n-#endif\n+\/\/ Performs bytewise bit reversal of each byte of an integral\n+\/\/ type up to 64 bits.\n+template <typename T, ENABLE_IF(std::is_integral<T>::value)>\n+constexpr T reverse_bits_in_bytes(T x) {\n+  return ReverseBitsImpl<T>::reverse_bits_in_bytes(x);\n+}\n@@ -121,4 +96,4 @@\n-\/\/ Performs bit reversal of a multi-byte type, we implement and support\n-\/\/ variants for 8, 16, 32 and 64 bit integral types.\n-template <typename T, ENABLE_IF(std::is_integral<T>::value)> inline T reverse_bits(T v) {\n-  return ReverseBitsImpl<T, sizeof(T)>::doit(v);\n+\/\/ Performs full bit reversal an integral type up to 64 bits.\n+template <typename T, ENABLE_IF(std::is_integral<T>::value)>\n+constexpr T reverse_bits(T x) {\n+  return reverse_bytes(reverse_bits_in_bytes(x));\n@@ -127,1 +102,1 @@\n-#endif \/\/ SHARE_UTILITIES_MOVE_BITS_HPP\n+#endif \/\/ SHARE_UTILITIES_MOVEBITS_HPP\n","filename":"src\/hotspot\/share\/utilities\/moveBits.hpp","additions":59,"deletions":84,"binary":false,"changes":143,"status":"modified"},{"patch":"@@ -0,0 +1,101 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/moveBits.hpp\"\n+#include \"unittest.hpp\"\n+\n+template<typename T>\n+inline void test_moveBits() {\n+  const int  NBIT = sizeof(T) * 8;\n+  const bool IS_U = (T)-1 > 0;\n+  const int XOR_REV_BITS = (NBIT - 1);\n+  const int XOR_REV_BITS_IN_BYTES = 7;  \/\/ only flip position in byte\n+  const int XOR_REV_BYTES = XOR_REV_BITS ^ XOR_REV_BITS_IN_BYTES;\n+  printf(\"testing %sint%d_t...\\n\", IS_U ? \"u\" : \"\", NBIT);\n+  ASSERT_EQ(reverse_bits((T)0), (T)0);\n+  ASSERT_EQ(reverse_bits((T)-1), (T)-1);\n+  ASSERT_EQ(reverse_bytes((T)0), (T)0);\n+  ASSERT_EQ(reverse_bytes((T)-1), (T)-1);\n+  ASSERT_EQ(reverse_bits_in_bytes((T)0), (T)0);\n+  ASSERT_EQ(reverse_bits_in_bytes((T)-1), (T)-1);\n+  for (int i1 = 0; i1 < NBIT; i1++) {\n+    T mask1 = (T)1 << i1;\n+    T revm1 = (T)1 << (i1 ^ XOR_REV_BITS);\n+    T rbym1 = (T)1 << (i1 ^ XOR_REV_BYTES);\n+    T ribm1 = (T)1 << (i1 ^ XOR_REV_BITS_IN_BYTES);\n+    for (int i2 = 0; i2 <= i1; i2++) {\n+      T mask2 = (T)1 << i2;\n+      T revm2 = (T)1 << (i2 ^ XOR_REV_BITS);\n+      T rbym2 = (T)1 << (i2 ^ XOR_REV_BYTES);\n+      T ribm2 = (T)1 << (i2 ^ XOR_REV_BITS_IN_BYTES);\n+      T mask = mask1|mask2;\n+#define STUFF (IS_U?\"u\":\"s\") << NBIT << \"@\" << i1 << \",\" << i2\n+      ASSERT_EQ(reverse_bits(mask), revm1|revm2) << STUFF;\n+      ASSERT_EQ((T)~reverse_bits((T)~mask), revm1|revm2) << STUFF;\n+      ASSERT_EQ(reverse_bytes(mask), rbym1|rbym2) << STUFF;\n+      ASSERT_EQ((T)~reverse_bytes((T)~mask), rbym1|rbym2) << STUFF;\n+      ASSERT_EQ(reverse_bits_in_bytes(mask), ribm1|ribm2) << STUFF;\n+      ASSERT_EQ((T)~reverse_bits_in_bytes((T)~mask), ribm1|ribm2) << STUFF;\n+    }\n+  }\n+}\n+\n+TEST_VM(opto, moveBits) {\n+  test_moveBits<int64_t>();\n+  test_moveBits<uint64_t>();\n+  test_moveBits<int32_t>();\n+  test_moveBits<uint32_t>();\n+  test_moveBits<int16_t>();\n+  test_moveBits<uint16_t>();\n+  test_moveBits<int8_t>();\n+  test_moveBits<uint8_t>();\n+}\n+\n+\/\/ here is some object code to look at:\n+\n+int32_t code_quality_reverse_bits_32(int32_t x) {\n+  return reverse_bits(x);\n+}\n+\n+int32_t code_quality_reverse_bytes_32(int32_t x) {\n+  return reverse_bytes(x);\n+}\n+\n+int32_t code_quality_reverse_bits_in_bytes_32(int32_t x) {\n+  return reverse_bits_in_bytes(x);\n+}\n+\n+int64_t code_quality_reverse_bits_64(int64_t x) {\n+  return reverse_bits(x);\n+}\n+\n+int64_t code_quality_reverse_bytes_64(int64_t x) {\n+  return reverse_bytes(x);\n+}\n+\n+int64_t code_quality_reverse_bits_in_bytes_64(int64_t x) {\n+  return reverse_bits_in_bytes(x);\n+}\n","filename":"test\/hotspot\/gtest\/opto\/test_moveBits.cpp","additions":101,"deletions":0,"binary":false,"changes":101,"status":"added"},{"patch":"@@ -1,36 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"precompiled.hpp\"\n-#include \"utilities\/moveBits.hpp\"\n-#include \"utilities\/globalDefinitions.hpp\"\n-#include \"unittest.hpp\"\n-\n-TEST_VM(opto, reverse_bits) {\n-  ASSERT_EQ(reverse_bits((jlong)-4LL), 4611686018427387903LL);\n-  ASSERT_EQ(reverse_bits((jint)-4), 1073741823);\n-  ASSERT_EQ(reverse_bits((jshort)(-4)), 16383);\n-  ASSERT_EQ(reverse_bits((jbyte)(-4)), 63);\n-}\n-\n","filename":"test\/hotspot\/gtest\/opto\/test_reverse_bits.cpp","additions":0,"deletions":36,"binary":false,"changes":36,"status":"deleted"}]}