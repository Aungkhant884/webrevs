{"files":[{"patch":"@@ -30,1 +30,0 @@\n-#include \"utilities\/debug.hpp\"\n@@ -36,1 +35,1 @@\n-  static const size_t S = sizeof(T);\n+  static const size_t NB = sizeof(T) * BitsPerByte;\n@@ -38,1 +37,2 @@\n-  static_assert((S == 1) || (S == 2) || (S == 4) || (S == 8), \"unsupported size\");\n+  static_assert((NB == 8) || (NB == 16) || (NB == 32) || (NB == 64),\n+                \"unsupported size\");\n@@ -40,5 +40,2 @@\n-  static const uint64_t rep_5555 = UCONST64(0x5555555555555555);\n-  static const uint64_t rep_3333 = UCONST64(0x3333333333333333);\n-  static const uint64_t rep_0F0F = UCONST64(0x0F0F0F0F0F0F0F0F);\n-  static const uint64_t rep_00FF = UCONST64(0x00FF00FF00FF00FF);\n-  static const uint64_t rep_FFFF = UCONST64(0x0000FFFF0000FFFF);\n+  \/\/ The unsigned integral type for calculations.\n+  using I = typename Conditional<NB <= 32, uint32_t, uint64_t>::type;\n@@ -46,7 +43,5 @@\n-  using I = typename Conditional<S <= 4, uint32_t, uint64_t>::type;\n-\n-  \/\/ Avoid 32bit shift of uint32_t that some compilers might warn about even\n-  \/\/ though the relevant code will never be executed.  For example, gcc warns\n-  \/\/ about -Wshift-count-overflow.\n-  static constexpr uint32_t swap64(uint32_t x) { ShouldNotReachHere(); return x; }\n-  static constexpr uint64_t swap64(uint64_t x) { return (x << 32) | (x >> 32); }\n+  static const I rep_5555 = static_cast<I>(UCONST64(0x5555555555555555));\n+  static const I rep_3333 = static_cast<I>(UCONST64(0x3333333333333333));\n+  static const I rep_0F0F = static_cast<I>(UCONST64(0x0F0F0F0F0F0F0F0F));\n+  static const I rep_00FF = static_cast<I>(UCONST64(0x00FF00FF00FF00FF));\n+  static const I rep_FFFF = static_cast<I>(UCONST64(0x0000FFFF0000FFFF));\n@@ -59,4 +54,4 @@\n-    x = ((x & (I)rep_5555) << 1) | ((x >> 1) & (I)rep_5555);\n-    x = ((x & (I)rep_3333) << 2) | ((x >> 2) & (I)rep_3333);\n-    x = ((x & (I)rep_0F0F) << 4) | ((x >> 4) & (I)rep_0F0F);\n-    return x;\n+    x = ((x & rep_5555) << 1) | ((x >> 1) & rep_5555);\n+    x = ((x & rep_3333) << 2) | ((x >> 2) & rep_3333);\n+    x = ((x & rep_0F0F) << 4) | ((x >> 4) & rep_0F0F);\n+    return static_cast<T>(x);\n@@ -70,7 +65,9 @@\n-    switch (S) {\n-    case 8:\n-      x = swap64(x);\n-    case 4:                     \/\/ fallthrough\n-      x = ((x & (I)rep_FFFF) << 16) | ((x >> 16) & (I)rep_FFFF);\n-    case 2:                     \/\/ fallthrough\n-      x = ((x & (I)rep_00FF) << 8)  | ((x >> 8)  & (I)rep_00FF);\n+    switch (NB) {\n+    case 64:\n+      \/\/ The use of NB\/2 rather than 32 avoids a warning in dead code when\n+      \/\/ I is uint32_t, because shifting a 32bit type by 32 is UB.\n+      x = (x << (NB\/2)) | (x >> (NB\/2));\n+    case 32:                    \/\/ fallthrough\n+      x = ((x & rep_FFFF) << 16) | ((x >> 16) & rep_FFFF);\n+    case 16:                    \/\/ fallthrough\n+      x = ((x & rep_00FF) << 8)  | ((x >> 8)  & rep_00FF);\n@@ -78,1 +75,1 @@\n-      return x;\n+      return static_cast<T>(x);\n","filename":"src\/hotspot\/share\/utilities\/moveBits.hpp","additions":24,"deletions":27,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -77,1 +77,13 @@\n-\/\/ here is some object code to look at:\n+\/\/ Here is some object code to look at if we want to do a manual\n+\/\/ study.  One could find the build file named test_moveBits.o.cmdline\n+\/\/ and hand-edit the command line to produce assembly code in\n+\/\/ test_moveBits.s.\n+\/\/\n+\/\/ Or, given the two empty \"fence functions\", one could do a\n+\/\/ quick scan like this:\n+\/\/\n+\/\/ $ objdump -D $(find build\/*release -name test_moveBits.o) \\\n+\/\/   | sed -n '\/start_code_quality\/,$p;\/end_code_quality\/q' \\\n+\/\/   | egrep -B10 bswap  # or grep -B20 cfi_endproc\n+\n+void start_code_quality_moveBits() { }\n","filename":"test\/hotspot\/gtest\/opto\/test_moveBits.cpp","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"}]}