{"files":[{"patch":"@@ -28,0 +28,1 @@\n+#include \"utilities\/moveBits.hpp\"\n@@ -32,6 +33,1 @@\n-  \/\/ Hacker's Delight, Figure 7-1\n-  i = (i & 0x55555555) << 1 | ((i >> 1) & 0x55555555);\n-  i = (i & 0x33333333) << 2 | ((i >> 2) & 0x33333333);\n-  i = (i & 0x0f0f0f0f) << 4 | ((i >> 4) & 0x0f0f0f0f);\n-  i = (i << 24) | ((i & 0xff00) << 8) | ((i >> 8) & 0xff00) | (i >> 24);\n-  return i;\n+  return reverse_bits(i);\n","filename":"src\/hotspot\/share\/code\/compressedStream.cpp","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+#include \"utilities\/moveBits.hpp\"\n@@ -1903,7 +1904,0 @@\n-static jlong reverse_bits(jlong val) {\n-  jlong res = ((val & 0xF0F0F0F0F0F0F0F0L) >> 4) | ((val & 0x0F0F0F0F0F0F0F0F) << 4);\n-  res = ((res & 0xCCCCCCCCCCCCCCCCL) >> 2) | ((res & 0x3333333333333333L) << 2);\n-  res = ((res & 0xAAAAAAAAAAAAAAAAL) >> 1) | ((res & 0x5555555555555555L) << 1);\n-  return res;\n-}\n-\n@@ -1920,1 +1914,1 @@\n-  return t1int;\n+  return bottom_type();\n@@ -1930,1 +1924,1 @@\n-    jint res = reverse_bits(t1long->get_con());\n+    jlong res = reverse_bits(t1long->get_con());\n@@ -1933,1 +1927,1 @@\n-  return t1long;\n+  return bottom_type();\n","filename":"src\/hotspot\/share\/opto\/subnode.cpp","additions":4,"deletions":10,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -0,0 +1,102 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_UTILITIES_MOVEBITS_HPP\n+#define SHARE_UTILITIES_MOVEBITS_HPP\n+\n+#include \"metaprogramming\/conditional.hpp\"\n+#include \"metaprogramming\/enableIf.hpp\"\n+#include \"utilities\/debug.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include <type_traits>\n+\n+template <typename T>\n+class ReverseBitsImpl {\n+  static const size_t S = sizeof(T);\n+\n+  static_assert((S == 1) || (S == 2) || (S == 4) || (S == 8), \"unsupported size\");\n+\n+  static const uint64_t rep_5555 = UCONST64(0x5555555555555555);\n+  static const uint64_t rep_3333 = UCONST64(0x3333333333333333);\n+  static const uint64_t rep_0F0F = UCONST64(0x0F0F0F0F0F0F0F0F);\n+  static const uint64_t rep_00FF = UCONST64(0x00FF00FF00FF00FF);\n+  static const uint64_t rep_FFFF = UCONST64(0x0000FFFF0000FFFF);\n+\n+  using I = typename Conditional<S <= 4, uint32_t, uint64_t>::type;\n+\n+  \/\/ Avoid 32bit shift of uint32_t that some compilers might warn about even\n+  \/\/ though the relevant code will never be executed.  For example, gcc warns\n+  \/\/ about -Wshift-count-overflow.\n+  static constexpr uint32_t swap64(uint32_t x) { ShouldNotReachHere(); return x; }\n+  static constexpr uint64_t swap64(uint64_t x) { return (x << 32) | (x >> 32); }\n+\n+public:\n+\n+  static constexpr T reverse_bits_in_bytes(T v) {\n+    \/\/ Based on Hacker's Delight Section 7-1\n+    auto x = static_cast<I>(v);\n+    x = ((x & (I)rep_5555) << 1) | ((x >> 1) & (I)rep_5555);\n+    x = ((x & (I)rep_3333) << 2) | ((x >> 2) & (I)rep_3333);\n+    x = ((x & (I)rep_0F0F) << 4) | ((x >> 4) & (I)rep_0F0F);\n+    return x;\n+  }\n+\n+  static constexpr T reverse_bytes(T v) {\n+    \/\/ Based on Hacker's Delight Section 7-1\n+    \/\/ NB: Compilers are good at recognizing byte-swap code and transforming\n+    \/\/ it into platform-specific instructions like x86 bswap.\n+    auto x = static_cast<I>(v);\n+    switch (S) {\n+    case 8:\n+      x = swap64(x);\n+    case 4:                     \/\/ fallthrough\n+      x = ((x & (I)rep_FFFF) << 16) | ((x >> 16) & (I)rep_FFFF);\n+    case 2:                     \/\/ fallthrough\n+      x = ((x & (I)rep_00FF) << 8)  | ((x >> 8)  & (I)rep_00FF);\n+    default:                    \/\/ fallthrough\n+      return x;\n+    }\n+  }\n+};\n+\n+\/\/ Performs byte reversal of an integral type up to 64 bits.\n+template <typename T, ENABLE_IF(std::is_integral<T>::value)>\n+constexpr T reverse_bytes(T x) {\n+  return ReverseBitsImpl<T>::reverse_bytes(x);\n+}\n+\n+\/\/ Performs bytewise bit reversal of each byte of an integral\n+\/\/ type up to 64 bits.\n+template <typename T, ENABLE_IF(std::is_integral<T>::value)>\n+constexpr T reverse_bits_in_bytes(T x) {\n+  return ReverseBitsImpl<T>::reverse_bits_in_bytes(x);\n+}\n+\n+\/\/ Performs full bit reversal an integral type up to 64 bits.\n+template <typename T, ENABLE_IF(std::is_integral<T>::value)>\n+constexpr T reverse_bits(T x) {\n+  return reverse_bytes(reverse_bits_in_bytes(x));\n+}\n+\n+#endif \/\/ SHARE_UTILITIES_MOVEBITS_HPP\n","filename":"src\/hotspot\/share\/utilities\/moveBits.hpp","additions":102,"deletions":0,"binary":false,"changes":102,"status":"added"},{"patch":"@@ -0,0 +1,101 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/moveBits.hpp\"\n+#include \"unittest.hpp\"\n+\n+template<typename T>\n+inline void test_moveBits() {\n+  const int  NBIT = sizeof(T) * 8;\n+  const bool IS_U = (T)-1 > 0;\n+  const int XOR_REV_BITS = (NBIT - 1);\n+  const int XOR_REV_BITS_IN_BYTES = 7;  \/\/ only flip position in byte\n+  const int XOR_REV_BYTES = XOR_REV_BITS ^ XOR_REV_BITS_IN_BYTES;\n+  printf(\"testing %sint%d_t...\\n\", IS_U ? \"u\" : \"\", NBIT);\n+  ASSERT_EQ(reverse_bits((T)0), (T)0);\n+  ASSERT_EQ(reverse_bits((T)-1), (T)-1);\n+  ASSERT_EQ(reverse_bytes((T)0), (T)0);\n+  ASSERT_EQ(reverse_bytes((T)-1), (T)-1);\n+  ASSERT_EQ(reverse_bits_in_bytes((T)0), (T)0);\n+  ASSERT_EQ(reverse_bits_in_bytes((T)-1), (T)-1);\n+  for (int i1 = 0; i1 < NBIT; i1++) {\n+    T mask1 = (T)1 << i1;\n+    T revm1 = (T)1 << (i1 ^ XOR_REV_BITS);\n+    T rbym1 = (T)1 << (i1 ^ XOR_REV_BYTES);\n+    T ribm1 = (T)1 << (i1 ^ XOR_REV_BITS_IN_BYTES);\n+    for (int i2 = 0; i2 <= i1; i2++) {\n+      T mask2 = (T)1 << i2;\n+      T revm2 = (T)1 << (i2 ^ XOR_REV_BITS);\n+      T rbym2 = (T)1 << (i2 ^ XOR_REV_BYTES);\n+      T ribm2 = (T)1 << (i2 ^ XOR_REV_BITS_IN_BYTES);\n+      T mask = mask1|mask2;\n+#define STUFF (IS_U?\"u\":\"s\") << NBIT << \"@\" << i1 << \",\" << i2\n+      ASSERT_EQ(reverse_bits(mask), revm1|revm2) << STUFF;\n+      ASSERT_EQ((T)~reverse_bits((T)~mask), revm1|revm2) << STUFF;\n+      ASSERT_EQ(reverse_bytes(mask), rbym1|rbym2) << STUFF;\n+      ASSERT_EQ((T)~reverse_bytes((T)~mask), rbym1|rbym2) << STUFF;\n+      ASSERT_EQ(reverse_bits_in_bytes(mask), ribm1|ribm2) << STUFF;\n+      ASSERT_EQ((T)~reverse_bits_in_bytes((T)~mask), ribm1|ribm2) << STUFF;\n+    }\n+  }\n+}\n+\n+TEST_VM(opto, moveBits) {\n+  test_moveBits<int64_t>();\n+  test_moveBits<uint64_t>();\n+  test_moveBits<int32_t>();\n+  test_moveBits<uint32_t>();\n+  test_moveBits<int16_t>();\n+  test_moveBits<uint16_t>();\n+  test_moveBits<int8_t>();\n+  test_moveBits<uint8_t>();\n+}\n+\n+\/\/ here is some object code to look at:\n+\n+int32_t code_quality_reverse_bits_32(int32_t x) {\n+  return reverse_bits(x);\n+}\n+\n+int32_t code_quality_reverse_bytes_32(int32_t x) {\n+  return reverse_bytes(x);\n+}\n+\n+int32_t code_quality_reverse_bits_in_bytes_32(int32_t x) {\n+  return reverse_bits_in_bytes(x);\n+}\n+\n+int64_t code_quality_reverse_bits_64(int64_t x) {\n+  return reverse_bits(x);\n+}\n+\n+int64_t code_quality_reverse_bytes_64(int64_t x) {\n+  return reverse_bytes(x);\n+}\n+\n+int64_t code_quality_reverse_bits_in_bytes_64(int64_t x) {\n+  return reverse_bits_in_bytes(x);\n+}\n","filename":"test\/hotspot\/gtest\/opto\/test_moveBits.cpp","additions":101,"deletions":0,"binary":false,"changes":101,"status":"added"},{"patch":"@@ -32,5 +32,0 @@\n-\n-java\/lang\/Integer\/BitTwiddle.java 8291649 generic-x64\n-java\/lang\/Long\/BitTwiddle.java    8291649 generic-x64\n-java\/util\/zip\/TestCRC32C.java     8291649 generic-x64\n-java\/util\/zip\/TestChecksum.java   8291649 generic-x64\n","filename":"test\/jdk\/ProblemList-Xcomp.txt","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"}]}