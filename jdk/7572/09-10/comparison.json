{"files":[{"patch":"@@ -875,0 +875,8 @@\n+\/\/------------------------------Idealize---------------------------------------\n+Node *UDivINode::Ideal(PhaseGVN *phase, bool can_reshape) {\n+  \/\/ Check for dead control input\n+  if (in(0) && remove_dead_region(phase, can_reshape))  return this;\n+  return NULL;\n+}\n+\n+\n@@ -906,0 +914,7 @@\n+\/\/------------------------------Idealize---------------------------------------\n+Node *UDivLNode::Ideal(PhaseGVN *phase, bool can_reshape) {\n+  \/\/ Check for dead control input\n+  if (in(0) && remove_dead_region(phase, can_reshape))  return this;\n+  return NULL;\n+}\n+\n@@ -1071,0 +1086,7 @@\n+\/\/=============================================================================\n+\/\/------------------------------Idealize---------------------------------------\n+Node *UModINode::Ideal(PhaseGVN *phase, bool can_reshape) {\n+  \/\/ Check for dead control input\n+  if( in(0) && remove_dead_region(phase, can_reshape) )  return this;\n+  return NULL;\n+}\n@@ -1282,0 +1304,8 @@\n+\/\/=============================================================================\n+\/\/------------------------------Idealize---------------------------------------\n+Node *UModLNode::Ideal(PhaseGVN *phase, bool can_reshape) {\n+  \/\/ Check for dead control input\n+  if( in(0) && remove_dead_region(phase, can_reshape) )  return this;\n+  return NULL;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/divnode.cpp","additions":30,"deletions":0,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -101,0 +101,1 @@\n+  virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);\n@@ -113,0 +114,1 @@\n+  virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);\n@@ -169,0 +171,1 @@\n+  virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);\n@@ -179,0 +182,1 @@\n+  virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);\n","filename":"src\/hotspot\/share\/opto\/divnode.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2202,4 +2202,21 @@\n-    case vmIntrinsics::_divideUnsigned_i:  n = new UDivINode(NULL, argument(0), argument(1));  break;\n-    case vmIntrinsics::_divideUnsigned_l:  n = new UDivLNode(NULL, argument(0), argument(2));  break;\n-    case vmIntrinsics::_remainderUnsigned_i: n = new UModINode(NULL, argument(0), argument(1));  break;\n-    case vmIntrinsics::_remainderUnsigned_l: n = new UModLNode(NULL, argument(0), argument(2));  break;\n+    case vmIntrinsics::_divideUnsigned_i:\n+      zero_check_int(argument(1));\n+      \/\/ Compile-time detect of null-exception?\n+      if (stopped()) return false;\n+      n = new UDivINode(NULL, argument(0), argument(1));\n+      break;\n+    case vmIntrinsics::_divideUnsigned_l:\n+      zero_check_long(argument(2));\n+      \/\/ Compile-time detect of null-exception?\n+      if (stopped()) return false;\n+      n = new UDivLNode(NULL, argument(0), argument(2));  break;\n+    case vmIntrinsics::_remainderUnsigned_i:\n+      zero_check_int(argument(1));\n+      \/\/ Compile-time detect of null-exception?\n+      if (stopped()) return false;\n+      n = new UModINode(NULL, argument(0), argument(1));  break;\n+    case vmIntrinsics::_remainderUnsigned_l:\n+      zero_check_long(argument(2));\n+      \/\/ Compile-time detect of null-exception?\n+      if (stopped()) return false;\n+      n = new UModLNode(NULL, argument(0), argument(2));  break;\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":21,"deletions":4,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -1,129 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n-* @test\n-* @summary Test x86_64 intrinsic for divideUnsigned() and remainderUnsigned() methods for Integer\n-* @requires os.arch==\"amd64\" | os.arch==\"x86_64\"\n-* @library \/test\/lib \/\n-* @run driver compiler.intrinsics.TestIntegerDivMod\n-*\/\n-\n-package compiler.intrinsics;\n-import compiler.lib.ir_framework.*;\n-import java.util.random.RandomGenerator;\n-import java.util.random.RandomGeneratorFactory;\n-\n-\n-public class TestIntegerDivMod {\n-    private final int BUFFER_SIZE = 1024;\n-    private int[] dividends = new int[BUFFER_SIZE];\n-    private int[] divisors = new int[BUFFER_SIZE];\n-    private int[] quotients =  new int[BUFFER_SIZE];\n-    private int[] remainders =  new int[BUFFER_SIZE];\n-    private RandomGenerator rng;\n-\n-    public static void main(String args[]) {\n-        TestFramework.run(TestIntegerDivMod.class);\n-    }\n-\n-    public TestIntegerDivMod() {\n-        rng = RandomGeneratorFactory.getDefault().create(0);\n-        for (int i = 0; i < BUFFER_SIZE; i++) {\n-            dividends[i] = rng.nextInt();\n-            divisors[i] = rng.nextInt();\n-        }\n-    }\n-\n-    @Test \/\/ needs to be run in (fast) debug mode\n-    @Warmup(10000)\n-    @IR(counts = {\"UDivI\", \">= 1\"}) \/\/ Atleast one UDivI node is generated if intrinsic is used\n-    public void testDivideUnsigned() {\n-        for (int i = 0; i < BUFFER_SIZE; i++) {\n-            quotients[i] = Integer.divideUnsigned(dividends[i], divisors[i]);\n-        }\n-        checkResult(\"divideUnsigned\");\n-    }\n-\n-    @Test \/\/ needs to be run in (fast) debug mode\n-    @Warmup(10000)\n-    @IR(counts = {\"UModI\", \">= 1\"}) \/\/ Atleast one UModI node is generated if intrinsic is used\n-    public void testRemainderUnsigned() {\n-        for (int i = 0; i < BUFFER_SIZE; i++) {\n-            remainders[i] = Integer.remainderUnsigned(dividends[i], divisors[i]);\n-        }\n-        checkResult(\"remainderUnsigned\");\n-    }\n-\n-\n-    @Test \/\/ needs to be run in (fast) debug mode\n-    @Warmup(10000)\n-    @IR(counts = {\"UDivModI\", \">= 1\"}) \/\/ Atleast one UDivModI node is generated if intrinsic is used\n-    public void testDivModUnsigned() {\n-        for (int i = 0; i < BUFFER_SIZE; i++) {\n-            divmod(dividends[i], divisors[i], i);\n-        }\n-        checkResult(\"divmodUnsigned\");\n-    }\n-\n-    private void divmod(int dividend, int divisor, int i) {\n-        quotients[i] = Integer.divideUnsigned(dividend, divisor);\n-        remainders[i] = Integer.remainderUnsigned(dividend, divisor);\n-    }\n-\n-    public void checkResult(String mode) {\n-        for (int i=0; i < BUFFER_SIZE; i++) {\n-            long dividend = Integer.toUnsignedLong(dividends[i]);\n-            long divisor = Integer.toUnsignedLong(divisors[i]);\n-\n-            int quo =  (int) (dividend \/ divisor);\n-            int rem = (int) (dividend % divisor);\n-            boolean mismatch;\n-            switch (mode) {\n-                case \"divideUnsigned\": mismatch = (quotients[i] != quo); break;\n-                case \"remainderUnsigned\": mismatch = (remainders[i] != rem); break;\n-                case \"divmodUnsigned\": mismatch = (quotients[i] != quo || remainders[i] != rem); break;\n-                default: throw new IllegalArgumentException(\"incorrect mode\");\n-            }\n-            if (mismatch) {\n-                throw new RuntimeException(errorMessage(mode, i, quo, rem));\n-            }\n-        }\n-    }\n-\n-    private String errorMessage(String mode, int i, int quo, int rem) {\n-        StringBuilder sb = new StringBuilder(mode);\n-        sb = sb.append(\" test error at index=\").append(i);\n-        sb = sb.append(\": dividend=\").append(dividends[i]);\n-        sb = sb.append(\"; divisor= \").append(divisors[i]);\n-        if (!mode.equals(\"remainderUnsigned\")) {\n-            sb = sb.append(\"; quotient (expected)= \").append(quo);\n-            sb = sb.append(\"; quotient (actual)= \").append(quotients[i]);\n-        }\n-        if (!mode.equals(\"divideUnsigned\")) {\n-            sb = sb.append(\"; remainder (expected)= \").append(rem);\n-            sb = sb.append(\"; remainder (actual)= \").append(remainders[i]);\n-        }\n-        return sb.toString();\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/TestIntegerDivMod.java","additions":0,"deletions":129,"binary":false,"changes":129,"status":"deleted"},{"patch":"@@ -0,0 +1,162 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+* @test\n+* @summary Test x86_64 intrinsic for divideUnsigned() and remainderUnsigned() methods for Integer\n+* @requires os.arch==\"amd64\" | os.arch==\"x86_64\"\n+* @library \/test\/lib \/\n+* @run driver compiler.intrinsics.TestIntegerUnsignedDivMod\n+*\/\n+\n+package compiler.intrinsics;\n+import compiler.lib.ir_framework.*;\n+import java.util.random.RandomGenerator;\n+import java.util.random.RandomGeneratorFactory;\n+\n+\n+public class TestIntegerUnsignedDivMod {\n+    private int BUFFER_SIZE;\n+    private int[] dividends;\n+    private int[] divisors;\n+    private int[] quotients;\n+    private int[] remainders;\n+    final long MAX_UNSIGNED_INT = Integer.toUnsignedLong(0xffff_ffff);\n+    long[] inRange = {\n+        \/\/0L,\n+        1L,\n+        2L,\n+        2147483646L,   \/\/ MAX_VALUE - 1\n+        2147483647L,   \/\/ MAX_VALUE\n+        2147483648L,   \/\/ MAX_VALUE + 1\n+        MAX_UNSIGNED_INT - 1L,\n+        MAX_UNSIGNED_INT,\n+    };\n+    private RandomGenerator rng;\n+\n+    public static void main(String args[]) {\n+        TestFramework.run(TestIntegerUnsignedDivMod.class);\n+    }\n+\n+    public TestIntegerUnsignedDivMod() {\n+        BUFFER_SIZE = inRange.length * inRange.length;\n+        dividends = new int[BUFFER_SIZE];\n+        divisors = new int[BUFFER_SIZE];\n+        quotients = new int[BUFFER_SIZE];\n+        remainders = new int[BUFFER_SIZE];\n+\n+        int idx = 0;\n+        for (int i = 0; i < inRange.length; i++) {\n+            for (int j = 0; j < inRange.length; j++){\n+                dividends[idx] = (int) inRange[i];\n+                divisors[idx] = (int) inRange[j];\n+                idx++;\n+            }\n+        }\n+    }\n+\n+    @Test \/\/ needs to be run in (fast) debug mode\n+    @Warmup(10000)\n+    @IR(counts = {\"UDivI\", \">= 1\"}) \/\/ Atleast one UDivI node is generated if intrinsic is used\n+    public void testDivideUnsigned() {\n+        for (int i = 0; i < BUFFER_SIZE; i++) {\n+            try {\n+                quotients[i] = Integer.divideUnsigned(dividends[i], divisors[i]);\n+            } catch(ArithmeticException ea) {\n+                ; \/\/ expected\n+            }\n+        }\n+        checkResult(\"divideUnsigned\");\n+    }\n+\n+    @Test \/\/ needs to be run in (fast) debug mode\n+    @Warmup(10000)\n+    @IR(counts = {\"UModI\", \">= 1\"}) \/\/ Atleast one UModI node is generated if intrinsic is used\n+    public void testRemainderUnsigned() {\n+        for (int i = 0; i < BUFFER_SIZE; i++) {\n+            try {\n+                remainders[i] = Integer.remainderUnsigned(dividends[i], divisors[i]);\n+            } catch(ArithmeticException ea) {\n+                ; \/\/ expected\n+            }\n+        }\n+        checkResult(\"remainderUnsigned\");\n+    }\n+\n+\n+    @Test \/\/ needs to be run in (fast) debug mode\n+    @Warmup(10000)\n+    @IR(counts = {\"UDivModI\", \">= 1\"}) \/\/ Atleast one UDivModI node is generated if intrinsic is used\n+    public void testDivModUnsigned() {\n+        for (int i = 0; i < BUFFER_SIZE; i++) {\n+            try {\n+                divmod(dividends[i], divisors[i], i);\n+            } catch(ArithmeticException ea) {\n+                ; \/\/ expected\n+            }\n+        }\n+        checkResult(\"divmodUnsigned\");\n+    }\n+\n+    private void divmod(int dividend, int divisor, int i) {\n+        quotients[i] = Integer.divideUnsigned(dividend, divisor);\n+        remainders[i] = Integer.remainderUnsigned(dividend, divisor);\n+    }\n+\n+    public void checkResult(String mode) {\n+        for (int i=0; i < BUFFER_SIZE; i++) {\n+            if (divisors[i] == 0) continue;\n+            long dividend = Integer.toUnsignedLong(dividends[i]);\n+            long divisor = Integer.toUnsignedLong(divisors[i]);\n+            int quo =  (int) (dividend \/ divisor);\n+            int rem = (int) (dividend % divisor);\n+            boolean mismatch;\n+            switch (mode) {\n+                case \"divideUnsigned\": mismatch = (quotients[i] != quo); break;\n+                case \"remainderUnsigned\": mismatch = (remainders[i] != rem); break;\n+                case \"divmodUnsigned\": mismatch = (quotients[i] != quo || remainders[i] != rem); break;\n+                default: throw new IllegalArgumentException(\"incorrect mode\");\n+            }\n+            if (mismatch) {\n+                throw new RuntimeException(errorMessage(mode, i, quo, rem));\n+            }\n+        }\n+    }\n+\n+    private String errorMessage(String mode, int i, int quo, int rem) {\n+        StringBuilder sb = new StringBuilder(mode);\n+        sb = sb.append(\" test error at index=\").append(i);\n+        sb = sb.append(\": dividend=\").append(dividends[i]);\n+        sb = sb.append(\"; divisor= \").append(divisors[i]);\n+        if (!mode.equals(\"remainderUnsigned\")) {\n+            sb = sb.append(\"; quotient (expected)= \").append(quo);\n+            sb = sb.append(\"; quotient (actual)= \").append(quotients[i]);\n+        }\n+        if (!mode.equals(\"divideUnsigned\")) {\n+            sb = sb.append(\"; remainder (expected)= \").append(rem);\n+            sb = sb.append(\"; remainder (actual)= \").append(remainders[i]);\n+        }\n+        return sb.toString();\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/TestIntegerUnsignedDivMod.java","additions":162,"deletions":0,"binary":false,"changes":162,"status":"added"},{"patch":"@@ -1,145 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n-* @test\n-* @summary Test x86_64 intrinsic for divideUnsigned() and remainderUnsigned() methods for Long\n-* @requires os.arch==\"amd64\" | os.arch==\"x86_64\"\n-* @library \/test\/lib \/\n-* @run driver compiler.intrinsics.TestLongDivMod\n-*\/\n-\n-package compiler.intrinsics;\n-import compiler.lib.ir_framework.*;\n-import java.util.random.RandomGenerator;\n-import java.util.random.RandomGeneratorFactory;\n-\n-\n-public class TestLongDivMod {\n-    private final int BUFFER_SIZE = 1024;\n-    private long[] dividends = new long[BUFFER_SIZE];\n-    private long[] divisors = new long[BUFFER_SIZE];\n-    private long[] quotients =  new long[BUFFER_SIZE];\n-    private long[] remainders =  new long[BUFFER_SIZE];\n-    private RandomGenerator rng;\n-\n-    public static void main(String args[]) {\n-        TestFramework.run(TestLongDivMod.class);\n-    }\n-\n-    public TestLongDivMod() {\n-        rng = RandomGeneratorFactory.getDefault().create(0);\n-        for (int i = 0; i < BUFFER_SIZE; i++) {\n-            dividends[i] = rng.nextLong();\n-            divisors[i] = rng.nextLong();\n-        }\n-    }\n-\n-    @Test \/\/ needs to be run in (fast) debug mode\n-    @Warmup(10000)\n-    @IR(counts = {\"UDivL\", \">= 1\"}) \/\/ Atleast one UDivL node is generated if intrinsic is used\n-    public void testDivideUnsigned() {\n-        for (int i = 0; i < BUFFER_SIZE; i++) {\n-            quotients[i] = Long.divideUnsigned(dividends[i], divisors[i]);\n-        }\n-        checkResult(\"divideUnsigned\");\n-    }\n-\n-    @Test \/\/ needs to be run in (fast) debug mode\n-    @Warmup(10000)\n-    @IR(counts = {\"UModL\", \">= 1\"}) \/\/ Atleast one UModL node is generated if intrinsic is used\n-    public void testRemainderUnsigned() {\n-        for (int i = 0; i < BUFFER_SIZE; i++) {\n-            remainders[i] = Long.remainderUnsigned(dividends[i], divisors[i]);\n-        }\n-        checkResult(\"remainderUnsigned\");\n-    }\n-\n-\n-    @Test \/\/ needs to be run in (fast) debug mode\n-    @Warmup(10000)\n-    @IR(counts = {\"UDivModL\", \">= 1\"}) \/\/ Atleast one UDivModL node is generated if intrinsic is used\n-    public void testDivModUnsigned() {\n-        for (int i = 0; i < BUFFER_SIZE; i++) {\n-            divmod(dividends[i], divisors[i], i);\n-        }\n-        checkResult(\"divmodUnsigned\");\n-    }\n-\n-    private void divmod(long dividend, long divisor, int i) {\n-        quotients[i] = Long.divideUnsigned(dividend, divisor);\n-        remainders[i] = Long.remainderUnsigned(dividend, divisor);\n-    }\n-\n-    public void checkResult(String mode) {\n-        for (int i=0; i < BUFFER_SIZE; i++) {\n-            long quo =  divideUnsigned(dividends[i], divisors[i]);\n-            long rem = remainderUnsigned(dividends[i], divisors[i]);\n-            boolean mismatch;\n-            switch (mode) {\n-                case \"divideUnsigned\": mismatch = (quotients[i] != quo); break;\n-                case \"remainderUnsigned\": mismatch = (remainders[i] != rem); break;\n-                case \"divmodUnsigned\": mismatch = (quotients[i] != quo || remainders[i] != rem); break;\n-                default: throw new IllegalArgumentException(\"incorrect mode\");\n-            }\n-            if (mismatch) {\n-                throw new RuntimeException(errorMessage(mode, i, quo, rem));\n-            }\n-        }\n-    }\n-\n-    private String errorMessage(String mode, int i, long quo, long rem) {\n-        StringBuilder sb = new StringBuilder(mode);\n-        sb = sb.append(\" test error at index=\").append(i);\n-        sb = sb.append(\": dividend=\").append(dividends[i]);\n-        sb = sb.append(\"; divisor= \").append(divisors[i]);\n-        if (!mode.equals(\"remainderUnsigned\")) {\n-            sb = sb.append(\"; quotient (expected)= \").append(quo);\n-            sb = sb.append(\"; quotient (actual)= \").append(quotients[i]);\n-        }\n-        if (!mode.equals(\"divideUnsigned\")) {\n-            sb = sb.append(\"; remainder (expected)= \").append(rem);\n-            sb = sb.append(\"; remainder (actual)= \").append(remainders[i]);\n-        }\n-        return sb.toString();\n-    }\n-\n-\n-    private long divideUnsigned(long dividend, long divisor) {\n-        if (divisor >= 0) {\n-            final long q = (dividend >>> 1) \/ divisor << 1;\n-            final long r = dividend - q * divisor;\n-            return q + ((r | ~(r - divisor)) >>> (Long.SIZE - 1));\n-        }\n-        return (dividend & ~(dividend - divisor)) >>> (Long.SIZE - 1);\n-    }\n-\n-    private long remainderUnsigned(long dividend, long divisor) {\n-        if (divisor >= 0) {\n-            final long q = (dividend >>> 1) \/ divisor << 1;\n-            final long r = dividend - q * divisor;\n-            return r - ((~(r - divisor) >> (Long.SIZE - 1)) & divisor);\n-        }\n-        return dividend - (((dividend & ~(dividend - divisor)) >> (Long.SIZE - 1)) & divisor);\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/TestLongDivMod.java","additions":0,"deletions":145,"binary":false,"changes":145,"status":"deleted"},{"patch":"@@ -0,0 +1,210 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+* @test\n+* @summary Test x86_64 intrinsic for divideUnsigned() and remainderUnsigned() methods for Long\n+* @requires os.arch==\"amd64\" | os.arch==\"x86_64\"\n+* @library \/test\/lib \/\n+* @run driver compiler.intrinsics.TestLongUnsignedDivMod\n+*\/\n+\n+package compiler.intrinsics;\n+import compiler.lib.ir_framework.*;\n+import java.math.*;\n+\n+public class TestLongUnsignedDivMod {\n+    private int BUFFER_SIZE;\n+    private long[] dividends;\n+    private long[] divisors;\n+    private long[] quotients;\n+    private long[] remainders;\n+    long TWO_31 = 1L << Integer.SIZE - 1;\n+        long TWO_32 = 1L << Integer.SIZE;\n+    long TWO_33 = 1L << Integer.SIZE + 1;\n+    BigInteger NINETEEN = BigInteger.valueOf(19L);\n+    BigInteger TWO_63 = BigInteger.ONE.shiftLeft(Long.SIZE - 1);\n+    BigInteger TWO_64 = BigInteger.ONE.shiftLeft(Long.SIZE);\n+    BigInteger[] inRange = {\n+            BigInteger.ZERO,\n+            BigInteger.ONE,\n+            BigInteger.TEN,\n+            NINETEEN,\n+\n+            BigInteger.valueOf(TWO_31 - 19L),\n+            BigInteger.valueOf(TWO_31 - 10L),\n+            BigInteger.valueOf(TWO_31 - 1L),\n+            BigInteger.valueOf(TWO_31),\n+            BigInteger.valueOf(TWO_31 + 1L),\n+            BigInteger.valueOf(TWO_31 + 10L),\n+            BigInteger.valueOf(TWO_31 + 19L),\n+\n+            BigInteger.valueOf(TWO_32 - 19L),\n+            BigInteger.valueOf(TWO_32 - 10L),\n+            BigInteger.valueOf(TWO_32 - 1L),\n+            BigInteger.valueOf(TWO_32),\n+            BigInteger.valueOf(TWO_32 + 1L),\n+            BigInteger.valueOf(TWO_32 + 10L),\n+            BigInteger.valueOf(TWO_32 - 19L),\n+\n+            BigInteger.valueOf(TWO_33 - 19L),\n+            BigInteger.valueOf(TWO_33 - 10L),\n+            BigInteger.valueOf(TWO_33 - 1L),\n+            BigInteger.valueOf(TWO_33),\n+            BigInteger.valueOf(TWO_33 + 1L),\n+            BigInteger.valueOf(TWO_33 + 10L),\n+            BigInteger.valueOf(TWO_33 + 19L),\n+\n+            TWO_63.subtract(NINETEEN),\n+            TWO_63.subtract(BigInteger.TEN),\n+            TWO_63.subtract(BigInteger.ONE),\n+            TWO_63,\n+            TWO_63.add(BigInteger.ONE),\n+            TWO_63.add(BigInteger.TEN),\n+            TWO_63.add(NINETEEN),\n+\n+            TWO_64.subtract(NINETEEN),\n+            TWO_64.subtract(BigInteger.TEN),\n+            TWO_64.subtract(BigInteger.ONE),\n+    };\n+\n+    public static void main(String args[]) {\n+        TestFramework.run(TestLongUnsignedDivMod.class);\n+    }\n+\n+    public TestLongUnsignedDivMod() {\n+        BUFFER_SIZE = inRange.length * inRange.length;\n+        dividends = new long[BUFFER_SIZE];\n+        divisors = new long[BUFFER_SIZE];\n+        quotients = new long[BUFFER_SIZE];\n+        remainders = new long[BUFFER_SIZE];\n+\n+        int idx = 0;\n+        for (int i = 0; i < inRange.length; i++) {\n+            for (int j = 0; j < inRange.length; j++){\n+                dividends[idx] = inRange[i].longValue();\n+                divisors[idx] = inRange[j].longValue();\n+                idx++;\n+            }\n+        }\n+    }\n+\n+    @Test \/\/ needs to be run in (fast) debug mode\n+    @Warmup(10000)\n+    @IR(counts = {\"UDivL\", \">= 1\"}) \/\/ Atleast one UDivL node is generated if intrinsic is used\n+    public void testDivideUnsigned() {\n+        for (int i = 0; i < BUFFER_SIZE; i++) {\n+            try {\n+                quotients[i] = Long.divideUnsigned(dividends[i], divisors[i]);\n+            } catch(ArithmeticException ea) {\n+                ; \/\/ expected\n+            }\n+        }\n+        checkResult(\"divideUnsigned\");\n+    }\n+\n+    @Test \/\/ needs to be run in (fast) debug mode\n+    @Warmup(10000)\n+    @IR(counts = {\"UModL\", \">= 1\"}) \/\/ Atleast one UModL node is generated if intrinsic is used\n+    public void testRemainderUnsigned() {\n+        for (int i = 0; i < BUFFER_SIZE; i++) {\n+            try {\n+                remainders[i] = Long.remainderUnsigned(dividends[i], divisors[i]);\n+            } catch(ArithmeticException ea) {\n+                ; \/\/ expected\n+            }\n+        }\n+        checkResult(\"remainderUnsigned\");\n+    }\n+\n+\n+    @Test \/\/ needs to be run in (fast) debug mode\n+    @Warmup(10000)\n+    @IR(counts = {\"UDivModL\", \">= 1\"}) \/\/ Atleast one UDivModL node is generated if intrinsic is used\n+    public void testDivModUnsigned() {\n+        for (int i = 0; i < BUFFER_SIZE; i++) {\n+            try {\n+                divmod(dividends[i], divisors[i], i);\n+            } catch(ArithmeticException ea) {\n+                ; \/\/ expected\n+            }\n+        }\n+        checkResult(\"divmodUnsigned\");\n+    }\n+\n+    private void divmod(long dividend, long divisor, int i) {\n+        quotients[i] = Long.divideUnsigned(dividend, divisor);\n+        remainders[i] = Long.remainderUnsigned(dividend, divisor);\n+    }\n+\n+    public void checkResult(String mode) {\n+        for (int i=0; i < BUFFER_SIZE; i++) {\n+            if (divisors[i] == 0) continue;\n+            BigInteger dividend = toUnsignedBigInteger(dividends[i]);\n+            BigInteger divisor = toUnsignedBigInteger(divisors[i]);\n+\n+            long quo = dividend.divide(divisor).longValue();\n+            long rem = dividend.remainder(divisor).longValue();\n+            boolean mismatch;\n+            switch (mode) {\n+                case \"divideUnsigned\": mismatch = (quotients[i] != quo); break;\n+                case \"remainderUnsigned\": mismatch = (remainders[i] != rem); break;\n+                case \"divmodUnsigned\": mismatch = (quotients[i] != quo || remainders[i] != rem); break;\n+                default: throw new IllegalArgumentException(\"incorrect mode\");\n+            }\n+            if (mismatch) {\n+                throw new RuntimeException(errorMessage(mode, i, quo, rem));\n+            }\n+        }\n+    }\n+\n+    private String errorMessage(String mode, int i, long quo, long rem) {\n+        StringBuilder sb = new StringBuilder(mode);\n+        sb = sb.append(\" test error at index=\").append(i);\n+        sb = sb.append(\": dividend=\").append(dividends[i]);\n+        sb = sb.append(\"; divisor= \").append(divisors[i]);\n+        if (!mode.equals(\"remainderUnsigned\")) {\n+            sb = sb.append(\"; quotient (expected)= \").append(quo);\n+            sb = sb.append(\"; quotient (actual)= \").append(quotients[i]);\n+        }\n+        if (!mode.equals(\"divideUnsigned\")) {\n+            sb = sb.append(\"; remainder (expected)= \").append(rem);\n+            sb = sb.append(\"; remainder (actual)= \").append(remainders[i]);\n+        }\n+        return sb.toString();\n+    }\n+\n+    private BigInteger toUnsignedBigInteger(long i) {\n+        if (i >= 0L)\n+            return BigInteger.valueOf(i);\n+        else {\n+            int upper = (int) (i >>> 32);\n+            int lower = (int) i;\n+\n+            \/\/ return (upper << 32) + lower\n+            return (BigInteger.valueOf(Integer.toUnsignedLong(upper))).shiftLeft(32).\n+                add(BigInteger.valueOf(Integer.toUnsignedLong(lower)));\n+        }\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/TestLongUnsignedDivMod.java","additions":210,"deletions":0,"binary":false,"changes":210,"status":"added"}]}