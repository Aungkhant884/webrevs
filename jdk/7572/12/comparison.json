{"files":[{"patch":"@@ -12369,0 +12369,5 @@\n+void Assembler::divq(Register src) {\n+  int encode = prefixq_and_encode(src->encoding());\n+  emit_int16((unsigned char)0xF7, (0xF0 | encode));\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1371,0 +1371,1 @@\n+  void divq(Register src); \/\/ Unsigned division\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -4537,0 +4537,164 @@\n+\n+void C2_MacroAssembler::udivI(Register rax, Register divisor, Register rdx) {\n+  Label done;\n+  Label neg_divisor_fastpath;\n+  cmpl(divisor, 0);\n+  jccb(Assembler::less, neg_divisor_fastpath);\n+  xorl(rdx, rdx);\n+  divl(divisor);\n+  jmpb(done);\n+  bind(neg_divisor_fastpath);\n+  \/\/ Fastpath for divisor < 0:\n+  \/\/ quotient = (dividend & ~(dividend - divisor)) >>> (Integer.SIZE - 1)\n+  \/\/ See Hacker's Delight (2nd ed), section 9.3 which is implemented in java.lang.Long.divideUnsigned()\n+  movl(rdx, rax);\n+  subl(rdx, divisor);\n+  if (VM_Version::supports_bmi1()) {\n+    andnl(rax, rdx, rax);\n+  } else {\n+    notl(rdx);\n+    andl(rax, rdx);\n+  }\n+  shrl(rax, 31);\n+  bind(done);\n+}\n+\n+void C2_MacroAssembler::umodI(Register rax, Register divisor, Register rdx) {\n+  Label done;\n+  Label neg_divisor_fastpath;\n+  cmpl(divisor, 0);\n+  jccb(Assembler::less, neg_divisor_fastpath);\n+  xorl(rdx, rdx);\n+  divl(divisor);\n+  jmpb(done);\n+  bind(neg_divisor_fastpath);\n+  \/\/ Fastpath when divisor < 0:\n+  \/\/ remainder = dividend - (((dividend & ~(dividend - divisor)) >> (Integer.SIZE - 1)) & divisor)\n+  \/\/ See Hacker's Delight (2nd ed), section 9.3 which is implemented in java.lang.Long.remainderUnsigned()\n+  movl(rdx, rax);\n+  subl(rax, divisor);\n+  if (VM_Version::supports_bmi1()) {\n+    andnl(rax, rax, rdx);\n+  } else {\n+    notl(rax);\n+    andl(rax, rdx);\n+  }\n+  sarl(rax, 31);\n+  andl(rax, divisor);\n+  subl(rdx, rax);\n+  bind(done);\n+}\n+\n+void C2_MacroAssembler::udivmodI(Register rax, Register divisor, Register rdx, Register tmp) {\n+  Label done;\n+  Label neg_divisor_fastpath;\n+\n+  cmpl(divisor, 0);\n+  jccb(Assembler::less, neg_divisor_fastpath);\n+  xorl(rdx, rdx);\n+  divl(divisor);\n+  jmpb(done);\n+  bind(neg_divisor_fastpath);\n+  \/\/ Fastpath for divisor < 0:\n+  \/\/ quotient = (dividend & ~(dividend - divisor)) >>> (Integer.SIZE - 1)\n+  \/\/ remainder = dividend - (((dividend & ~(dividend - divisor)) >> (Integer.SIZE - 1)) & divisor)\n+  \/\/ See Hacker's Delight (2nd ed), section 9.3 which is implemented in\n+  \/\/ java.lang.Long.divideUnsigned() and java.lang.Long.remainderUnsigned()\n+  movl(rdx, rax);\n+  subl(rax, divisor);\n+  if (VM_Version::supports_bmi1()) {\n+    andnl(rax, rax, rdx);\n+  } else {\n+    notl(rax);\n+    andl(rax, rdx);\n+  }\n+  movl(tmp, rax);\n+  shrl(rax, 31); \/\/ quotient\n+  sarl(tmp, 31);\n+  andl(tmp, divisor);\n+  subl(rdx, tmp); \/\/ remainder\n+  bind(done);\n+}\n+\n+#ifdef _LP64\n+void C2_MacroAssembler::udivL(Register rax, Register divisor, Register rdx) {\n+  Label done;\n+  Label neg_divisor_fastpath;\n+  cmpq(divisor, 0);\n+  jccb(Assembler::less, neg_divisor_fastpath);\n+  xorl(rdx, rdx);\n+  divq(divisor);\n+  jmpb(done);\n+  bind(neg_divisor_fastpath);\n+  \/\/ Fastpath for divisor < 0:\n+  \/\/ quotient = (dividend & ~(dividend - divisor)) >>> (Long.SIZE - 1)\n+  \/\/ See Hacker's Delight (2nd ed), section 9.3 which is implemented in java.lang.Long.divideUnsigned()\n+  movq(rdx, rax);\n+  subq(rdx, divisor);\n+  if (VM_Version::supports_bmi1()) {\n+    andnq(rax, rdx, rax);\n+  } else {\n+    notq(rdx);\n+    andq(rax, rdx);\n+  }\n+  shrq(rax, 63);\n+  bind(done);\n+}\n+\n+void C2_MacroAssembler::umodL(Register rax, Register divisor, Register rdx) {\n+  Label done;\n+  Label neg_divisor_fastpath;\n+  cmpq(divisor, 0);\n+  jccb(Assembler::less, neg_divisor_fastpath);\n+  xorq(rdx, rdx);\n+  divq(divisor);\n+  jmp(done);\n+  bind(neg_divisor_fastpath);\n+  \/\/ Fastpath when divisor < 0:\n+  \/\/ remainder = dividend - (((dividend & ~(dividend - divisor)) >> (Long.SIZE - 1)) & divisor)\n+  \/\/ See Hacker's Delight (2nd ed), section 9.3 which is implemented in java.lang.Long.remainderUnsigned()\n+  movq(rdx, rax);\n+  subq(rax, divisor);\n+  if (VM_Version::supports_bmi1()) {\n+    andnq(rax, rax, rdx);\n+  } else {\n+    notq(rax);\n+    andq(rax, rdx);\n+  }\n+  sarq(rax, 63);\n+  andq(rax, divisor);\n+  subq(rdx, rax);\n+  bind(done);\n+}\n+\n+void C2_MacroAssembler::udivmodL(Register rax, Register divisor, Register rdx, Register tmp) {\n+  Label done;\n+  Label neg_divisor_fastpath;\n+  cmpq(divisor, 0);\n+  jccb(Assembler::less, neg_divisor_fastpath);\n+  xorq(rdx, rdx);\n+  divq(divisor);\n+  jmp(done);\n+  bind(neg_divisor_fastpath);\n+  \/\/ Fastpath for divisor < 0:\n+  \/\/ quotient = (dividend & ~(dividend - divisor)) >>> (Long.SIZE - 1)\n+  \/\/ remainder = dividend - (((dividend & ~(dividend - divisor)) >> (Long.SIZE - 1)) & divisor)\n+  \/\/ See Hacker's Delight (2nd ed), section 9.3 which is implemented in\n+  \/\/ java.lang.Long.divideUnsigned() and java.lang.Long.remainderUnsigned()\n+  movq(rdx, rax);\n+  subq(rax, divisor);\n+  if (VM_Version::supports_bmi1()) {\n+    andnq(rax, rax, rdx);\n+  } else {\n+    notq(rax);\n+    andq(rax, rdx);\n+  }\n+  movq(tmp, rax);\n+  shrq(rax, 63); \/\/ quotient\n+  sarq(tmp, 63);\n+  andq(tmp, divisor);\n+  subq(rdx, tmp); \/\/ remainder\n+  bind(done);\n+}\n+#endif\n+\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":164,"deletions":0,"binary":false,"changes":164,"status":"modified"},{"patch":"@@ -343,0 +343,9 @@\n+  void udivI(Register rax, Register divisor, Register rdx);\n+  void umodI(Register rax, Register divisor, Register rdx);\n+  void udivmodI(Register rax, Register divisor, Register rdx, Register tmp);\n+\n+  #ifdef _LP64\n+  void udivL(Register rax, Register divisor, Register rdx);\n+  void umodL(Register rax, Register divisor, Register rdx);\n+  void udivmodL(Register rax, Register divisor, Register rdx, Register tmp);\n+  #endif\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.hpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -8691,0 +8691,26 @@\n+instruct udivI_rReg(rax_RegI rax, rdx_RegI rdx, no_rax_rdx_RegI div, rFlagsReg cr)\n+%{\n+  match(Set rax (UDivI rax div));\n+  effect(KILL rdx, KILL cr);\n+\n+  ins_cost(300);\n+  format %{ \"udivl $rax,$rax,$div\\t# UDivI\\n\" %}\n+  ins_encode %{\n+    __ udivI($rax$$Register, $div$$Register, $rdx$$Register);\n+  %}\n+  ins_pipe(ialu_reg_reg_alu0);\n+%}\n+\n+instruct udivL_rReg(rax_RegL rax, rdx_RegL rdx, no_rax_rdx_RegL div, rFlagsReg cr)\n+%{\n+  match(Set rax (UDivL rax div));\n+  effect(KILL rdx, KILL cr);\n+\n+  ins_cost(300);\n+  format %{ \"udivq $rax,$rax,$div\\t# UDivL\\n\" %}\n+  ins_encode %{\n+     __ udivL($rax$$Register, $div$$Register, $rdx$$Register);\n+  %}\n+  ins_pipe(ialu_reg_reg_alu0);\n+%}\n+\n@@ -8732,0 +8758,35 @@\n+\/\/ Unsigned integer DIVMOD with Register, both quotient and mod results\n+instruct udivModI_rReg_divmod(rax_RegI rax, no_rax_rdx_RegI tmp, rdx_RegI rdx,\n+                              no_rax_rdx_RegI div, rFlagsReg cr)\n+%{\n+  match(UDivModI rax div);\n+  effect(TEMP tmp, KILL cr);\n+\n+  ins_cost(300);\n+  format %{ \"udivl $rax,$rax,$div\\t# begin UDivModI\\n\\t\"\n+            \"umodl $rdx,$rax,$div\\t! using $tmp as TEMP # end UDivModI\\n\"\n+          %}\n+  ins_encode %{\n+    __ udivmodI($rax$$Register, $div$$Register, $rdx$$Register, $tmp$$Register);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ Unsigned long DIVMOD with Register, both quotient and mod results\n+instruct udivModL_rReg_divmod(rax_RegL rax, no_rax_rdx_RegL tmp, rdx_RegL rdx,\n+                              no_rax_rdx_RegL div, rFlagsReg cr)\n+%{\n+  match(UDivModL rax div);\n+  effect(TEMP tmp, KILL cr);\n+\n+  ins_cost(300);\n+  format %{ \"udivq $rax,$rax,$div\\t# begin UDivModL\\n\\t\"\n+            \"umodq $rdx,$rax,$div\\t! using $tmp as TEMP # end UDivModL\\n\"\n+          %}\n+  ins_encode %{\n+    __ udivmodL($rax$$Register, $div$$Register, $rdx$$Register, $tmp$$Register);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\n@@ -8835,0 +8896,26 @@\n+instruct umodI_rReg(rdx_RegI rdx, rax_RegI rax, no_rax_rdx_RegI div, rFlagsReg cr)\n+%{\n+  match(Set rdx (UModI rax div));\n+  effect(KILL rax, KILL cr);\n+\n+  ins_cost(300);\n+  format %{ \"umodl $rdx,$rax,$div\\t# UModI\\n\" %}\n+  ins_encode %{\n+    __ umodI($rax$$Register, $div$$Register, $rdx$$Register);\n+  %}\n+  ins_pipe(ialu_reg_reg_alu0);\n+%}\n+\n+instruct umodL_rReg(rdx_RegL rdx, rax_RegL rax, no_rax_rdx_RegL div, rFlagsReg cr)\n+%{\n+  match(Set rdx (UModL rax div));\n+  effect(KILL rax, KILL cr);\n+\n+  ins_cost(300);\n+  format %{ \"umodq $rdx,$rax,$div\\t# UModL\\n\" %}\n+  ins_encode %{\n+    __ umodL($rax$$Register, $div$$Register, $rdx$$Register);\n+  %}\n+  ins_pipe(ialu_reg_reg_alu0);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":87,"deletions":0,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -219,0 +219,6 @@\n+  do_intrinsic(_divideUnsigned_i,         java_lang_Integer,      divideUnsigned_name,     int2_int_signature,   F_S)   \\\n+  do_intrinsic(_remainderUnsigned_i,      java_lang_Integer,      remainderUnsigned_name,  int2_int_signature,   F_S)   \\\n+    do_name(    divideUnsigned_name,                                   \"divideUnsigned\")                                \\\n+  do_intrinsic(_divideUnsigned_l,         java_lang_Long,         divideUnsigned_name,     long2_long_signature, F_S)   \\\n+  do_intrinsic(_remainderUnsigned_l,      java_lang_Long,         remainderUnsigned_name,  long2_long_signature, F_S)   \\\n+    do_name(    remainderUnsigned_name,                                \"remainderUnsigned\")                             \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -270,0 +270,12 @@\n+  case vmIntrinsics::_divideUnsigned_i:\n+    if (!Matcher::match_rule_supported(Op_UDivI)) return false;\n+    break;\n+  case vmIntrinsics::_remainderUnsigned_i:\n+    if (!Matcher::match_rule_supported(Op_UModI)) return false;\n+    break;\n+  case vmIntrinsics::_divideUnsigned_l:\n+    if (!Matcher::match_rule_supported(Op_UDivL)) return false;\n+    break;\n+  case vmIntrinsics::_remainderUnsigned_l:\n+    if (!Matcher::match_rule_supported(Op_UModL)) return false;\n+    break;\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -165,0 +165,2 @@\n+macro(UDivI)\n+macro(UDivL)\n@@ -168,0 +170,2 @@\n+macro(UDivModI)\n+macro(UDivModL)\n@@ -234,0 +238,2 @@\n+macro(UModI)\n+macro(UModL)\n","filename":"src\/hotspot\/share\/opto\/classes.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -24,1 +24,0 @@\n-\n@@ -3503,0 +3502,30 @@\n+  case Op_UModI:\n+    if (UseDivMod) {\n+      \/\/ Check if a%b and a\/b both exist\n+      Node* d = n->find_similar(Op_UDivI);\n+      if (d) {\n+        \/\/ Replace them with a fused unsigned divmod if supported\n+        if (Matcher::has_match_rule(Op_UDivModI)) {\n+          UDivModINode* divmod = UDivModINode::make(n);\n+          d->subsume_by(divmod->div_proj(), this);\n+          n->subsume_by(divmod->mod_proj(), this);\n+        }\n+      }\n+    }\n+    break;\n+\n+  case Op_UModL:\n+    if (UseDivMod) {\n+      \/\/ Check if a%b and a\/b both exist\n+      Node* d = n->find_similar(Op_UDivL);\n+      if (d) {\n+        \/\/ Replace them with a fused unsigned divmod if supported\n+        if (Matcher::has_match_rule(Op_UDivModL)) {\n+          UDivModLNode* divmod = UDivModLNode::make(n);\n+          d->subsume_by(divmod->div_proj(), this);\n+          n->subsume_by(divmod->mod_proj(), this);\n+        }\n+      }\n+    }\n+    break;\n+\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":30,"deletions":1,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -844,0 +844,78 @@\n+\/\/=============================================================================\n+\/\/------------------------------Identity---------------------------------------\n+\/\/ If the divisor is 1, we are an identity on the dividend.\n+Node* UDivINode::Identity(PhaseGVN* phase) {\n+  return (phase->type( in(2) )->higher_equal(TypeInt::ONE)) ? in(1) : this;\n+}\n+\/\/------------------------------Value------------------------------------------\n+\/\/ A UDivINode divides its inputs.  The third input is a Control input, used to\n+\/\/ prevent hoisting the divide above an unsafe test.\n+const Type* UDivINode::Value(PhaseGVN* phase) const {\n+  \/\/ Either input is TOP ==> the result is TOP\n+  const Type *t1 = phase->type( in(1) );\n+  const Type *t2 = phase->type( in(2) );\n+  if( t1 == Type::TOP ) return Type::TOP;\n+  if( t2 == Type::TOP ) return Type::TOP;\n+\n+  \/\/ x\/x == 1 since we always generate the dynamic divisor check for 0.\n+  if (in(1) == in(2)) {\n+    return TypeInt::ONE;\n+  }\n+\n+  \/\/ Either input is BOTTOM ==> the result is the local BOTTOM\n+  const Type *bot = bottom_type();\n+  if( (t1 == bot) || (t2 == bot) ||\n+      (t1 == Type::BOTTOM) || (t2 == Type::BOTTOM) )\n+    return bot;\n+\n+  \/\/ Otherwise we give up all hope\n+  return TypeInt::INT;\n+}\n+\n+\/\/------------------------------Idealize---------------------------------------\n+Node *UDivINode::Ideal(PhaseGVN *phase, bool can_reshape) {\n+  \/\/ Check for dead control input\n+  if (in(0) && remove_dead_region(phase, can_reshape))  return this;\n+  return NULL;\n+}\n+\n+\n+\/\/=============================================================================\n+\/\/------------------------------Identity---------------------------------------\n+\/\/ If the divisor is 1, we are an identity on the dividend.\n+Node* UDivLNode::Identity(PhaseGVN* phase) {\n+  return (phase->type( in(2) )->higher_equal(TypeLong::ONE)) ? in(1) : this;\n+}\n+\/\/------------------------------Value------------------------------------------\n+\/\/ A UDivLNode divides its inputs.  The third input is a Control input, used to\n+\/\/ prevent hoisting the divide above an unsafe test.\n+const Type* UDivLNode::Value(PhaseGVN* phase) const {\n+  \/\/ Either input is TOP ==> the result is TOP\n+  const Type *t1 = phase->type( in(1) );\n+  const Type *t2 = phase->type( in(2) );\n+  if( t1 == Type::TOP ) return Type::TOP;\n+  if( t2 == Type::TOP ) return Type::TOP;\n+\n+  \/\/ x\/x == 1 since we always generate the dynamic divisor check for 0.\n+  if (in(1) == in(2)) {\n+    return TypeLong::ONE;\n+  }\n+\n+  \/\/ Either input is BOTTOM ==> the result is the local BOTTOM\n+  const Type *bot = bottom_type();\n+  if( (t1 == bot) || (t2 == bot) ||\n+      (t1 == Type::BOTTOM) || (t2 == Type::BOTTOM) )\n+    return bot;\n+\n+  \/\/ Otherwise we give up all hope\n+  return TypeLong::LONG;\n+}\n+\n+\/\/------------------------------Idealize---------------------------------------\n+Node *UDivLNode::Ideal(PhaseGVN *phase, bool can_reshape) {\n+  \/\/ Check for dead control input\n+  if (in(0) && remove_dead_region(phase, can_reshape))  return this;\n+  return NULL;\n+}\n+\n+\n@@ -1008,0 +1086,7 @@\n+\/\/=============================================================================\n+\/\/------------------------------Idealize---------------------------------------\n+Node *UModINode::Ideal(PhaseGVN *phase, bool can_reshape) {\n+  \/\/ Check for dead control input\n+  if( in(0) && remove_dead_region(phase, can_reshape) )  return this;\n+  return NULL;\n+}\n@@ -1219,0 +1304,8 @@\n+\/\/=============================================================================\n+\/\/------------------------------Idealize---------------------------------------\n+Node *UModLNode::Ideal(PhaseGVN *phase, bool can_reshape) {\n+  \/\/ Check for dead control input\n+  if( in(0) && remove_dead_region(phase, can_reshape) )  return this;\n+  return NULL;\n+}\n+\n@@ -1323,0 +1416,53 @@\n+\n+\/\/------------------------------make------------------------------------------\n+UDivModINode* UDivModINode::make(Node* div_or_mod) {\n+  Node* n = div_or_mod;\n+  assert(n->Opcode() == Op_UDivI || n->Opcode() == Op_UModI,\n+         \"only div or mod input pattern accepted\");\n+\n+  UDivModINode* divmod = new UDivModINode(n->in(0), n->in(1), n->in(2));\n+  Node*        dproj  = new ProjNode(divmod, DivModNode::div_proj_num);\n+  Node*        mproj  = new ProjNode(divmod, DivModNode::mod_proj_num);\n+  return divmod;\n+}\n+\n+\/\/------------------------------make------------------------------------------\n+UDivModLNode* UDivModLNode::make(Node* div_or_mod) {\n+  Node* n = div_or_mod;\n+  assert(n->Opcode() == Op_UDivL || n->Opcode() == Op_UModL,\n+         \"only div or mod input pattern accepted\");\n+\n+  UDivModLNode* divmod = new UDivModLNode(n->in(0), n->in(1), n->in(2));\n+  Node*        dproj  = new ProjNode(divmod, DivModNode::div_proj_num);\n+  Node*        mproj  = new ProjNode(divmod, DivModNode::mod_proj_num);\n+  return divmod;\n+}\n+\n+\/\/------------------------------match------------------------------------------\n+\/\/ return result(s) along with their RegMask info\n+Node* UDivModINode::match( const ProjNode *proj, const Matcher *match ) {\n+  uint ideal_reg = proj->ideal_reg();\n+  RegMask rm;\n+  if (proj->_con == div_proj_num) {\n+    rm = match->divI_proj_mask();\n+  } else {\n+    assert(proj->_con == mod_proj_num, \"must be div or mod projection\");\n+    rm = match->modI_proj_mask();\n+  }\n+  return new MachProjNode(this, proj->_con, rm, ideal_reg);\n+}\n+\n+\n+\/\/------------------------------match------------------------------------------\n+\/\/ return result(s) along with their RegMask info\n+Node* UDivModLNode::match( const ProjNode *proj, const Matcher *match ) {\n+  uint ideal_reg = proj->ideal_reg();\n+  RegMask rm;\n+  if (proj->_con == div_proj_num) {\n+    rm = match->divL_proj_mask();\n+  } else {\n+    assert(proj->_con == mod_proj_num, \"must be div or mod projection\");\n+    rm = match->modL_proj_mask();\n+  }\n+  return new MachProjNode(this, proj->_con, rm, ideal_reg);\n+}\n","filename":"src\/hotspot\/share\/opto\/divnode.cpp","additions":146,"deletions":0,"binary":false,"changes":146,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -93,0 +93,26 @@\n+\/\/------------------------------UDivINode---------------------------------------\n+\/\/ Unsigned integer division\n+class UDivINode : public Node {\n+public:\n+  UDivINode( Node *c, Node *dividend, Node *divisor ) : Node(c, dividend, divisor ) {}\n+  virtual int Opcode() const;\n+  virtual Node* Identity(PhaseGVN* phase);\n+  virtual const Type* Value(PhaseGVN* phase) const;\n+  virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);\n+  virtual const Type *bottom_type() const { return TypeInt::INT; }\n+  virtual uint ideal_reg() const { return Op_RegI; }\n+};\n+\n+\/\/------------------------------UDivLNode---------------------------------------\n+\/\/ Unsigned long division\n+class UDivLNode : public Node {\n+public:\n+  UDivLNode( Node *c, Node *dividend, Node *divisor ) : Node(c, dividend, divisor ) {}\n+  virtual int Opcode() const;\n+  virtual Node* Identity(PhaseGVN* phase);\n+  virtual const Type* Value(PhaseGVN* phase) const;\n+  virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);\n+  virtual const Type *bottom_type() const { return TypeLong::LONG; }\n+  virtual uint ideal_reg() const { return Op_RegL; }\n+};\n+\n@@ -139,0 +165,22 @@\n+\/\/------------------------------UModINode---------------------------------------\n+\/\/ Unsigned integer modulus\n+class UModINode : public Node {\n+public:\n+  UModINode( Node *c, Node *in1, Node *in2 ) : Node(c,in1, in2) {}\n+  virtual int Opcode() const;\n+  virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);\n+  virtual const Type *bottom_type() const { return TypeInt::INT; }\n+  virtual uint ideal_reg() const { return Op_RegI; }\n+};\n+\n+\/\/------------------------------UModLNode---------------------------------------\n+\/\/ Unsigned long modulus\n+class UModLNode : public Node {\n+public:\n+  UModLNode( Node *c, Node *in1, Node *in2 ) : Node(c,in1, in2) {}\n+  virtual int Opcode() const;\n+  virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);\n+  virtual const Type *bottom_type() const { return TypeLong::LONG; }\n+  virtual uint ideal_reg() const { return Op_RegL; }\n+};\n+\n@@ -187,0 +235,27 @@\n+\n+\/\/------------------------------UDivModINode---------------------------------------\n+\/\/ Unsigend integer division with remainder result.\n+class UDivModINode : public DivModNode {\n+public:\n+  UDivModINode( Node *c, Node *dividend, Node *divisor ) : DivModNode(c, dividend, divisor) {}\n+  virtual int Opcode() const;\n+  virtual const Type *bottom_type() const { return TypeTuple::INT_PAIR; }\n+  virtual Node *match( const ProjNode *proj, const Matcher *m );\n+\n+  \/\/ Make a divmod and associated projections from a div or mod.\n+  static UDivModINode* make(Node* div_or_mod);\n+};\n+\n+\/\/------------------------------UDivModLNode---------------------------------------\n+\/\/ Unsigned long division with remainder result.\n+class UDivModLNode : public DivModNode {\n+public:\n+  UDivModLNode( Node *c, Node *dividend, Node *divisor ) : DivModNode(c, dividend, divisor) {}\n+  virtual int Opcode() const;\n+  virtual const Type *bottom_type() const { return TypeTuple::LONG_PAIR; }\n+  virtual Node *match( const ProjNode *proj, const Matcher *m );\n+\n+  \/\/ Make a divmod and associated projections from a div or mod.\n+  static UDivModLNode* make(Node* div_or_mod);\n+};\n+\n","filename":"src\/hotspot\/share\/opto\/divnode.hpp","additions":76,"deletions":1,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -530,0 +530,5 @@\n+  case vmIntrinsics::_divideUnsigned_i:\n+  case vmIntrinsics::_divideUnsigned_l:\n+  case vmIntrinsics::_remainderUnsigned_i:\n+  case vmIntrinsics::_remainderUnsigned_l:      return inline_divmod_methods(intrinsic_id());\n+\n@@ -2191,0 +2196,33 @@\n+\/\/--------------------------inline_unsigned_divmod_methods-----------------------------\n+\/\/ inline int Integer.divideUnsigned(init, int)\n+\/\/ inline int Integer.remainderUnsigned(int, int)\n+bool LibraryCallKit::inline_divmod_methods(vmIntrinsics::ID id) {\n+  Node* n = NULL;\n+  switch(id) {\n+    case vmIntrinsics::_divideUnsigned_i:\n+      zero_check_int(argument(1));\n+      \/\/ Compile-time detect of null-exception?\n+      if (stopped()) return false;\n+      n = new UDivINode(control(), argument(0), argument(1));\n+      break;\n+    case vmIntrinsics::_divideUnsigned_l:\n+      zero_check_long(argument(2));\n+      \/\/ Compile-time detect of null-exception?\n+      if (stopped()) return false;\n+      n = new UDivLNode(control(), argument(0), argument(2));  break;\n+    case vmIntrinsics::_remainderUnsigned_i:\n+      zero_check_int(argument(1));\n+      \/\/ Compile-time detect of null-exception?\n+      if (stopped()) return false;\n+      n = new UModINode(control(), argument(0), argument(1));  break;\n+    case vmIntrinsics::_remainderUnsigned_l:\n+      zero_check_long(argument(2));\n+      \/\/ Compile-time detect of null-exception?\n+      if (stopped()) return false;\n+      n = new UModLNode(control(), argument(0), argument(2));  break;\n+    default:  fatal_unexpected_iid(id);  break;\n+  }\n+  set_result(_gvn.transform(n));\n+  return true;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":38,"deletions":0,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -267,0 +267,1 @@\n+  bool inline_divmod_methods(vmIntrinsics::ID id);\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1582,0 +1582,2 @@\n+  declare_c2_type(UDivINode, Node)                                        \\\n+  declare_c2_type(UDivLNode, Node)                                        \\\n@@ -1586,0 +1588,2 @@\n+  declare_c2_type(UModINode, Node)                                        \\\n+  declare_c2_type(UModLNode, Node)                                        \\\n@@ -1589,0 +1593,2 @@\n+  declare_c2_type(UDivModINode, DivModNode)                               \\\n+  declare_c2_type(UDivModLNode, DivModNode)                               \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1545,0 +1545,1 @@\n+    @IntrinsicCandidate\n@@ -1562,0 +1563,1 @@\n+    @IntrinsicCandidate\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Integer.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1666,0 +1666,1 @@\n+    @IntrinsicCandidate\n@@ -1688,0 +1689,1 @@\n+    @IntrinsicCandidate\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Long.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,158 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+* @test\n+* @summary Test x86_64 intrinsic for divideUnsigned() and remainderUnsigned() methods for Integer\n+* @requires os.arch==\"amd64\" | os.arch==\"x86_64\"\n+* @library \/test\/lib \/\n+* @run driver compiler.intrinsics.TestIntegerUnsignedDivMod\n+*\/\n+\n+package compiler.intrinsics;\n+import compiler.lib.ir_framework.*;\n+\n+public class TestIntegerUnsignedDivMod {\n+    private int BUFFER_SIZE;\n+    private int[] dividends;\n+    private int[] divisors;\n+    private int[] quotients;\n+    private int[] remainders;\n+    final long MAX_UNSIGNED_INT = Integer.toUnsignedLong(0xffff_ffff);\n+    long[] inRange = {\n+        0L,\n+        1L,\n+        2L,\n+        2147483646L,   \/\/ MAX_VALUE - 1\n+        2147483647L,   \/\/ MAX_VALUE\n+        2147483648L,   \/\/ MAX_VALUE + 1\n+        MAX_UNSIGNED_INT - 1L,\n+        MAX_UNSIGNED_INT,\n+    };\n+\n+    public static void main(String args[]) {\n+        TestFramework.run(TestIntegerUnsignedDivMod.class);\n+    }\n+\n+    public TestIntegerUnsignedDivMod() {\n+        BUFFER_SIZE = inRange.length * inRange.length;\n+        dividends = new int[BUFFER_SIZE];\n+        divisors = new int[BUFFER_SIZE];\n+        quotients = new int[BUFFER_SIZE];\n+        remainders = new int[BUFFER_SIZE];\n+\n+        int idx = 0;\n+        for (int i = 0; i < inRange.length; i++) {\n+            for (int j = 0; j < inRange.length; j++){\n+                dividends[idx] = (int) inRange[i];\n+                divisors[idx] = (int) inRange[j];\n+                idx++;\n+            }\n+        }\n+    }\n+\n+    @Test \/\/ needs to be run in (fast) debug mode\n+    @Warmup(10000)\n+    @IR(counts = {\"UDivI\", \">= 1\"}) \/\/ Atleast one UDivI node is generated if intrinsic is used\n+    public void testDivideUnsigned() {\n+        for (int i = 0; i < BUFFER_SIZE; i++) {\n+            try {\n+                quotients[i] = Integer.divideUnsigned(dividends[i], divisors[i]);\n+            } catch(ArithmeticException ea) {\n+                ; \/\/ expected\n+            }\n+        }\n+        checkResult(\"divideUnsigned\");\n+    }\n+\n+    @Test \/\/ needs to be run in (fast) debug mode\n+    @Warmup(10000)\n+    @IR(counts = {\"UModI\", \">= 1\"}) \/\/ Atleast one UModI node is generated if intrinsic is used\n+    public void testRemainderUnsigned() {\n+        for (int i = 0; i < BUFFER_SIZE; i++) {\n+            try {\n+                remainders[i] = Integer.remainderUnsigned(dividends[i], divisors[i]);\n+            } catch(ArithmeticException ea) {\n+                ; \/\/ expected\n+            }\n+        }\n+        checkResult(\"remainderUnsigned\");\n+    }\n+\n+\n+    @Test \/\/ needs to be run in (fast) debug mode\n+    @Warmup(10000)\n+    @IR(counts = {\"UDivModI\", \">= 1\"}) \/\/ Atleast one UDivModI node is generated if intrinsic is used\n+    public void testDivModUnsigned() {\n+        for (int i = 0; i < BUFFER_SIZE; i++) {\n+            try {\n+                divmod(dividends[i], divisors[i], i);\n+            } catch(ArithmeticException ea) {\n+                ; \/\/ expected\n+            }\n+        }\n+        checkResult(\"divmodUnsigned\");\n+    }\n+\n+    private void divmod(int dividend, int divisor, int i) {\n+        quotients[i] = Integer.divideUnsigned(dividend, divisor);\n+        remainders[i] = Integer.remainderUnsigned(dividend, divisor);\n+    }\n+\n+    public void checkResult(String mode) {\n+        for (int i=0; i < BUFFER_SIZE; i++) {\n+            if (divisors[i] == 0) continue;\n+            long dividend = Integer.toUnsignedLong(dividends[i]);\n+            long divisor = Integer.toUnsignedLong(divisors[i]);\n+            int quo =  (int) (dividend \/ divisor);\n+            int rem = (int) (dividend % divisor);\n+            boolean mismatch;\n+            switch (mode) {\n+                case \"divideUnsigned\": mismatch = (quotients[i] != quo); break;\n+                case \"remainderUnsigned\": mismatch = (remainders[i] != rem); break;\n+                case \"divmodUnsigned\": mismatch = (quotients[i] != quo || remainders[i] != rem); break;\n+                default: throw new IllegalArgumentException(\"incorrect mode\");\n+            }\n+            if (mismatch) {\n+                throw new RuntimeException(errorMessage(mode, i, quo, rem));\n+            }\n+        }\n+    }\n+\n+    private String errorMessage(String mode, int i, int quo, int rem) {\n+        StringBuilder sb = new StringBuilder(mode);\n+        sb = sb.append(\" test error at index=\").append(i);\n+        sb = sb.append(\": dividend=\").append(dividends[i]);\n+        sb = sb.append(\"; divisor= \").append(divisors[i]);\n+        if (!mode.equals(\"remainderUnsigned\")) {\n+            sb = sb.append(\"; quotient (expected)= \").append(quo);\n+            sb = sb.append(\"; quotient (actual)= \").append(quotients[i]);\n+        }\n+        if (!mode.equals(\"divideUnsigned\")) {\n+            sb = sb.append(\"; remainder (expected)= \").append(rem);\n+            sb = sb.append(\"; remainder (actual)= \").append(remainders[i]);\n+        }\n+        return sb.toString();\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/TestIntegerUnsignedDivMod.java","additions":158,"deletions":0,"binary":false,"changes":158,"status":"added"},{"patch":"@@ -0,0 +1,210 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+* @test\n+* @summary Test x86_64 intrinsic for divideUnsigned() and remainderUnsigned() methods for Long\n+* @requires os.arch==\"amd64\" | os.arch==\"x86_64\"\n+* @library \/test\/lib \/\n+* @run driver compiler.intrinsics.TestLongUnsignedDivMod\n+*\/\n+\n+package compiler.intrinsics;\n+import compiler.lib.ir_framework.*;\n+import java.math.*;\n+\n+public class TestLongUnsignedDivMod {\n+    private int BUFFER_SIZE;\n+    private long[] dividends;\n+    private long[] divisors;\n+    private long[] quotients;\n+    private long[] remainders;\n+    long TWO_31 = 1L << Integer.SIZE - 1;\n+        long TWO_32 = 1L << Integer.SIZE;\n+    long TWO_33 = 1L << Integer.SIZE + 1;\n+    BigInteger NINETEEN = BigInteger.valueOf(19L);\n+    BigInteger TWO_63 = BigInteger.ONE.shiftLeft(Long.SIZE - 1);\n+    BigInteger TWO_64 = BigInteger.ONE.shiftLeft(Long.SIZE);\n+    BigInteger[] inRange = {\n+            BigInteger.ZERO,\n+            BigInteger.ONE,\n+            BigInteger.TEN,\n+            NINETEEN,\n+\n+            BigInteger.valueOf(TWO_31 - 19L),\n+            BigInteger.valueOf(TWO_31 - 10L),\n+            BigInteger.valueOf(TWO_31 - 1L),\n+            BigInteger.valueOf(TWO_31),\n+            BigInteger.valueOf(TWO_31 + 1L),\n+            BigInteger.valueOf(TWO_31 + 10L),\n+            BigInteger.valueOf(TWO_31 + 19L),\n+\n+            BigInteger.valueOf(TWO_32 - 19L),\n+            BigInteger.valueOf(TWO_32 - 10L),\n+            BigInteger.valueOf(TWO_32 - 1L),\n+            BigInteger.valueOf(TWO_32),\n+            BigInteger.valueOf(TWO_32 + 1L),\n+            BigInteger.valueOf(TWO_32 + 10L),\n+            BigInteger.valueOf(TWO_32 - 19L),\n+\n+            BigInteger.valueOf(TWO_33 - 19L),\n+            BigInteger.valueOf(TWO_33 - 10L),\n+            BigInteger.valueOf(TWO_33 - 1L),\n+            BigInteger.valueOf(TWO_33),\n+            BigInteger.valueOf(TWO_33 + 1L),\n+            BigInteger.valueOf(TWO_33 + 10L),\n+            BigInteger.valueOf(TWO_33 + 19L),\n+\n+            TWO_63.subtract(NINETEEN),\n+            TWO_63.subtract(BigInteger.TEN),\n+            TWO_63.subtract(BigInteger.ONE),\n+            TWO_63,\n+            TWO_63.add(BigInteger.ONE),\n+            TWO_63.add(BigInteger.TEN),\n+            TWO_63.add(NINETEEN),\n+\n+            TWO_64.subtract(NINETEEN),\n+            TWO_64.subtract(BigInteger.TEN),\n+            TWO_64.subtract(BigInteger.ONE),\n+    };\n+\n+    public static void main(String args[]) {\n+        TestFramework.run(TestLongUnsignedDivMod.class);\n+    }\n+\n+    public TestLongUnsignedDivMod() {\n+        BUFFER_SIZE = inRange.length * inRange.length;\n+        dividends = new long[BUFFER_SIZE];\n+        divisors = new long[BUFFER_SIZE];\n+        quotients = new long[BUFFER_SIZE];\n+        remainders = new long[BUFFER_SIZE];\n+\n+        int idx = 0;\n+        for (int i = 0; i < inRange.length; i++) {\n+            for (int j = 0; j < inRange.length; j++){\n+                dividends[idx] = inRange[i].longValue();\n+                divisors[idx] = inRange[j].longValue();\n+                idx++;\n+            }\n+        }\n+    }\n+\n+    @Test \/\/ needs to be run in (fast) debug mode\n+    @Warmup(10000)\n+    @IR(counts = {\"UDivL\", \">= 1\"}) \/\/ Atleast one UDivL node is generated if intrinsic is used\n+    public void testDivideUnsigned() {\n+        for (int i = 0; i < BUFFER_SIZE; i++) {\n+            try {\n+                quotients[i] = Long.divideUnsigned(dividends[i], divisors[i]);\n+            } catch(ArithmeticException ea) {\n+                ; \/\/ expected\n+            }\n+        }\n+        checkResult(\"divideUnsigned\");\n+    }\n+\n+    @Test \/\/ needs to be run in (fast) debug mode\n+    @Warmup(10000)\n+    @IR(counts = {\"UModL\", \">= 1\"}) \/\/ Atleast one UModL node is generated if intrinsic is used\n+    public void testRemainderUnsigned() {\n+        for (int i = 0; i < BUFFER_SIZE; i++) {\n+            try {\n+                remainders[i] = Long.remainderUnsigned(dividends[i], divisors[i]);\n+            } catch(ArithmeticException ea) {\n+                ; \/\/ expected\n+            }\n+        }\n+        checkResult(\"remainderUnsigned\");\n+    }\n+\n+\n+    @Test \/\/ needs to be run in (fast) debug mode\n+    @Warmup(10000)\n+    @IR(counts = {\"UDivModL\", \">= 1\"}) \/\/ Atleast one UDivModL node is generated if intrinsic is used\n+    public void testDivModUnsigned() {\n+        for (int i = 0; i < BUFFER_SIZE; i++) {\n+            try {\n+                divmod(dividends[i], divisors[i], i);\n+            } catch(ArithmeticException ea) {\n+                ; \/\/ expected\n+            }\n+        }\n+        checkResult(\"divmodUnsigned\");\n+    }\n+\n+    private void divmod(long dividend, long divisor, int i) {\n+        quotients[i] = Long.divideUnsigned(dividend, divisor);\n+        remainders[i] = Long.remainderUnsigned(dividend, divisor);\n+    }\n+\n+    public void checkResult(String mode) {\n+        for (int i=0; i < BUFFER_SIZE; i++) {\n+            if (divisors[i] == 0) continue;\n+            BigInteger dividend = toUnsignedBigInteger(dividends[i]);\n+            BigInteger divisor = toUnsignedBigInteger(divisors[i]);\n+\n+            long quo = dividend.divide(divisor).longValue();\n+            long rem = dividend.remainder(divisor).longValue();\n+            boolean mismatch;\n+            switch (mode) {\n+                case \"divideUnsigned\": mismatch = (quotients[i] != quo); break;\n+                case \"remainderUnsigned\": mismatch = (remainders[i] != rem); break;\n+                case \"divmodUnsigned\": mismatch = (quotients[i] != quo || remainders[i] != rem); break;\n+                default: throw new IllegalArgumentException(\"incorrect mode\");\n+            }\n+            if (mismatch) {\n+                throw new RuntimeException(errorMessage(mode, i, quo, rem));\n+            }\n+        }\n+    }\n+\n+    private String errorMessage(String mode, int i, long quo, long rem) {\n+        StringBuilder sb = new StringBuilder(mode);\n+        sb = sb.append(\" test error at index=\").append(i);\n+        sb = sb.append(\": dividend=\").append(dividends[i]);\n+        sb = sb.append(\"; divisor= \").append(divisors[i]);\n+        if (!mode.equals(\"remainderUnsigned\")) {\n+            sb = sb.append(\"; quotient (expected)= \").append(quo);\n+            sb = sb.append(\"; quotient (actual)= \").append(quotients[i]);\n+        }\n+        if (!mode.equals(\"divideUnsigned\")) {\n+            sb = sb.append(\"; remainder (expected)= \").append(rem);\n+            sb = sb.append(\"; remainder (actual)= \").append(remainders[i]);\n+        }\n+        return sb.toString();\n+    }\n+\n+    private BigInteger toUnsignedBigInteger(long i) {\n+        if (i >= 0L)\n+            return BigInteger.valueOf(i);\n+        else {\n+            int upper = (int) (i >>> 32);\n+            int lower = (int) i;\n+\n+            \/\/ return (upper << 32) + lower\n+            return (BigInteger.valueOf(Integer.toUnsignedLong(upper))).shiftLeft(32).\n+                add(BigInteger.valueOf(Integer.toUnsignedLong(lower)));\n+        }\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/TestLongUnsignedDivMod.java","additions":210,"deletions":0,"binary":false,"changes":210,"status":"added"},{"patch":"@@ -0,0 +1,98 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Param;\n+import java.util.random.RandomGenerator;\n+import java.util.random.RandomGeneratorFactory;\n+import java.util.concurrent.TimeUnit;\n+\n+\/**\n+ * Tests unsigned division and modulus methods in java.lang.Integer\n+ *\/\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Thread)\n+public class IntegerDivMod {\n+\n+    RandomGenerator randomGenerator;\n+\n+    @Param({\"mixed\", \"positive\", \"negative\"})\n+    String divisorType;\n+    @Param({\"1024\"})\n+    int BUFFER_SIZE;\n+    int[] dividends, divisors, quotients, remainders;\n+\n+    @Setup\n+    public void setup() {\n+        dividends = new int[BUFFER_SIZE];\n+        divisors = new int[BUFFER_SIZE];\n+        quotients =  new int[BUFFER_SIZE];\n+        remainders =  new int[BUFFER_SIZE];\n+        RandomGenerator rng = RandomGeneratorFactory.getDefault().create(0);\n+        for (int i = 0; i < BUFFER_SIZE; i++) {\n+            dividends[i] = rng.nextInt();\n+            int divisor = rng.nextInt();\n+            if (divisorType.equals(\"positive\")) divisor = Math.abs(divisor);\n+            else if (divisorType.equals(\"negative\")) divisor = -Math.abs(divisor);\n+            divisors[i] = divisor;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void testDivideUnsigned() {\n+        for (int i = 0; i < BUFFER_SIZE; i++) {\n+            quotients[i] = Integer.divideUnsigned(dividends[i], divisors[i]);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void testRemainderUnsigned() {\n+        for (int i = 0; i < BUFFER_SIZE; i++) {\n+            remainders[i] = Integer.remainderUnsigned(dividends[i], divisors[i]);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void testDivideRemainderUnsigned() {\n+        for (int i = 0; i < BUFFER_SIZE; i++) {\n+            divmod(dividends[i], divisors[i], i);\n+        }\n+    }\n+\n+    public void divmod(int dividend, int divisor, int i) {\n+        quotients[i] = Integer.divideUnsigned(dividend, divisor);\n+        remainders[i] = Integer.remainderUnsigned(dividend, divisor);\n+    }\n+\n+}\n+\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/IntegerDivMod.java","additions":98,"deletions":0,"binary":false,"changes":98,"status":"added"},{"patch":"@@ -0,0 +1,98 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Param;\n+import java.util.random.RandomGenerator;\n+import java.util.random.RandomGeneratorFactory;\n+import java.util.concurrent.TimeUnit;\n+\n+\/**\n+ * Tests unsigned division and modulus methods in java.lang.Long\n+ *\/\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Thread)\n+public class LongDivMod {\n+\n+    RandomGenerator randomGenerator;\n+\n+    @Param({\"mixed\", \"positive\", \"negative\"})\n+    String divisorType;\n+    @Param({\"1024\"})\n+    int BUFFER_SIZE;\n+    long[] dividends, divisors, quotients, remainders;\n+\n+    @Setup\n+    public void setup() {\n+        dividends = new long[BUFFER_SIZE];\n+        divisors = new long[BUFFER_SIZE];\n+        quotients =  new long[BUFFER_SIZE];\n+        remainders =  new long[BUFFER_SIZE];\n+        RandomGenerator rng = RandomGeneratorFactory.getDefault().create(0);\n+        for (int i = 0; i < BUFFER_SIZE; i++) {\n+            dividends[i] = rng.nextLong();\n+            long divisor = rng.nextLong();\n+            if (divisorType.equals(\"positive\")) divisor = Math.abs(divisor);\n+            else if (divisorType.equals(\"negative\")) divisor = -Math.abs(divisor);\n+            divisors[i] = divisor;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void testDivideUnsigned() {\n+        for (int i = 0; i < BUFFER_SIZE; i++) {\n+            quotients[i] = Long.divideUnsigned(dividends[i], divisors[i]);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void testRemainderUnsigned() {\n+        for (int i = 0; i < BUFFER_SIZE; i++) {\n+            remainders[i] = Long.remainderUnsigned(dividends[i], divisors[i]);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void testDivideRemainderUnsigned() {\n+        for (int i = 0; i < BUFFER_SIZE; i++) {\n+            divmod(dividends[i], divisors[i], i);\n+        }\n+    }\n+\n+    public void divmod(long dividend, long divisor, int i) {\n+        quotients[i] = Long.divideUnsigned(dividend, divisor);\n+        remainders[i] = Long.remainderUnsigned(dividend, divisor);\n+    }\n+\n+}\n+\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/LongDivMod.java","additions":98,"deletions":0,"binary":false,"changes":98,"status":"added"}]}