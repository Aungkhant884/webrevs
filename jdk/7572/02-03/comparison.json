{"files":[{"patch":"@@ -4351,19 +4351,0 @@\n-void C2_MacroAssembler::udivL(Register rax, Register divisor, Register rdx) {\n-  Label done;\n-  Label neg_divisor_fastpath;\n-  cmpq(divisor, 0);\n-  jccb(Assembler::less, neg_divisor_fastpath);\n-  xorl(rdx, rdx);\n-  divq(divisor);\n-  jmp(done);\n-  bind(neg_divisor_fastpath);\n-  \/\/ Fastpath for divisor < 0:\n-  \/\/ quotient = (dividend & ~(dividend - divisor)) >>> (Long.SIZE - 1)\n-  \/\/ See Hacker's Delight (2nd ed), section 9.3 which is implemented in java.lang.Long.divideUnsigned()\n-  movq(rdx, rax);\n-  subq(rdx, divisor);\n-  andnq(rax, rdx, rax);\n-  shrq(rax, 63);\n-  bind(done);\n-}\n-\n@@ -4391,21 +4372,0 @@\n-void C2_MacroAssembler::umodL(Register rax, Register divisor, Register rdx) {\n-  Label done;\n-  Label neg_divisor_fastpath;\n-  cmpq(divisor, 0);\n-  jccb(Assembler::less, neg_divisor_fastpath);\n-  xorq(rdx, rdx);\n-  divq(divisor);\n-  jmp(done);\n-  bind(neg_divisor_fastpath);\n-  \/\/ Fastpath when divisor < 0:\n-  \/\/ remainder = dividend - (((dividend & ~(dividend - divisor)) >> (Long.SIZE - 1)) & divisor)\n-  \/\/ See Hacker's Delight (2nd ed), section 9.3 which is implemented in java.lang.Long.remainderUnsigned()\n-  movq(rdx, rax);\n-  subq(rax, divisor);\n-  andnq(rax, rax, rdx);\n-  sarq(rax, 63);\n-  andq(rax, divisor);\n-  subq(rdx, rax);\n-  bind(done);\n-}\n-\n@@ -4438,0 +4398,41 @@\n+#ifdef _LP64\n+void C2_MacroAssembler::udivL(Register rax, Register divisor, Register rdx) {\n+  Label done;\n+  Label neg_divisor_fastpath;\n+  cmpq(divisor, 0);\n+  jccb(Assembler::less, neg_divisor_fastpath);\n+  xorl(rdx, rdx);\n+  divq(divisor);\n+  jmp(done);\n+  bind(neg_divisor_fastpath);\n+  \/\/ Fastpath for divisor < 0:\n+  \/\/ quotient = (dividend & ~(dividend - divisor)) >>> (Long.SIZE - 1)\n+  \/\/ See Hacker's Delight (2nd ed), section 9.3 which is implemented in java.lang.Long.divideUnsigned()\n+  movq(rdx, rax);\n+  subq(rdx, divisor);\n+  andnq(rax, rdx, rax);\n+  shrq(rax, 63);\n+  bind(done);\n+}\n+\n+void C2_MacroAssembler::umodL(Register rax, Register divisor, Register rdx) {\n+  Label done;\n+  Label neg_divisor_fastpath;\n+  cmpq(divisor, 0);\n+  jccb(Assembler::less, neg_divisor_fastpath);\n+  xorq(rdx, rdx);\n+  divq(divisor);\n+  jmp(done);\n+  bind(neg_divisor_fastpath);\n+  \/\/ Fastpath when divisor < 0:\n+  \/\/ remainder = dividend - (((dividend & ~(dividend - divisor)) >> (Long.SIZE - 1)) & divisor)\n+  \/\/ See Hacker's Delight (2nd ed), section 9.3 which is implemented in java.lang.Long.remainderUnsigned()\n+  movq(rdx, rax);\n+  subq(rax, divisor);\n+  andnq(rax, rax, rdx);\n+  sarq(rax, 63);\n+  andq(rax, divisor);\n+  subq(rdx, rax);\n+  bind(done);\n+}\n+\n@@ -4462,0 +4463,2 @@\n+#endif\n+\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":43,"deletions":40,"binary":false,"changes":83,"status":"modified"},{"patch":"@@ -321,1 +321,0 @@\n-  void udivL(Register rax, Register divisor, Register rdx);\n@@ -323,1 +322,0 @@\n-  void umodL(Register rax, Register divisor, Register rdx);\n@@ -325,0 +323,4 @@\n+\n+  #ifdef _LP64\n+  void udivL(Register rax, Register divisor, Register rdx);\n+  void umodL(Register rax, Register divisor, Register rdx);\n@@ -326,0 +328,2 @@\n+  #endif\n+\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.hpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"}]}