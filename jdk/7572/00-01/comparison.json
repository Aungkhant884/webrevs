{"files":[{"patch":"@@ -4331,0 +4331,131 @@\n+\n+void C2_MacroAssembler::udivI(Register rax, Register divisor, Register rdx) {\n+  Label done;\n+  Label neg_divisor_fastpath;\n+  cmpl(divisor, 0);\n+  jccb(Assembler::less, neg_divisor_fastpath);\n+  xorl(rdx, rdx);\n+  divl(divisor);\n+  jmp(done);\n+  bind(neg_divisor_fastpath);\n+  \/\/ Fastpath for divisor < 0:\n+  \/\/ quotient = (dividend & ~(dividend - divisor)) >>> (Integer.SIZE - 1)\n+  \/\/ See Hacker's Delight (2nd ed), section 9.3 which is implemented in java.lang.Long.divideUnsigned()\n+  movl(rdx, rax);\n+  subl(rdx, divisor);\n+  andnl(rax, rdx, rax);\n+  shrl(rax, 31);\n+  bind(done);\n+}\n+\n+void C2_MacroAssembler::udivL(Register rax, Register divisor, Register rdx) {\n+  Label done;\n+  Label neg_divisor_fastpath;\n+  cmpq(divisor, 0);\n+  jccb(Assembler::less, neg_divisor_fastpath);\n+  xorl(rdx, rdx);\n+  divq(divisor);\n+  jmp(done);\n+  bind(neg_divisor_fastpath);\n+  \/\/ Fastpath for divisor < 0:\n+  \/\/ quotient = (dividend & ~(dividend - divisor)) >>> (Long.SIZE - 1)\n+  \/\/ See Hacker's Delight (2nd ed), section 9.3 which is implemented in java.lang.Long.divideUnsigned()\n+  movq(rdx, rax);\n+  subq(rdx, divisor);\n+  andnq(rax, rdx, rax);\n+  shrq(rax, 63);\n+  bind(done);\n+}\n+\n+void C2_MacroAssembler::umodI(Register rax, Register divisor, Register rdx) {\n+  Label done;\n+  Label neg_divisor_fastpath;\n+  cmpl(divisor, 0);\n+  jccb(Assembler::less, neg_divisor_fastpath);\n+  xorl(rdx, rdx);\n+  divl(divisor);\n+  jmp(done);\n+  bind(neg_divisor_fastpath);\n+  \/\/ Fastpath when divisor < 0:\n+  \/\/ remainder = dividend - (((dividend & ~(dividend - divisor)) >> (Integer.SIZE - 1)) & divisor)\n+  \/\/ See Hacker's Delight (2nd ed), section 9.3 which is implemented in java.lang.Long.remainderUnsigned()\n+  movl(rdx, rax);\n+  subl(rax, divisor);\n+  andnl(rax, rax, rdx);\n+  sarl(rax, 31);\n+  andl(rax, divisor);\n+  subl(rdx, rax);\n+  bind(done);\n+}\n+\n+void C2_MacroAssembler::umodL(Register rax, Register divisor, Register rdx) {\n+  Label done;\n+  Label neg_divisor_fastpath;\n+  cmpq(divisor, 0);\n+  jccb(Assembler::less, neg_divisor_fastpath);\n+  xorq(rdx, rdx);\n+  divq(divisor);\n+  jmp(done);\n+  bind(neg_divisor_fastpath);\n+  \/\/ Fastpath when divisor < 0:\n+  \/\/ remainder = dividend - (((dividend & ~(dividend - divisor)) >> (Long.SIZE - 1)) & divisor)\n+  \/\/ See Hacker's Delight (2nd ed), section 9.3 which is implemented in java.lang.Long.remainderUnsigned()\n+  movq(rdx, rax);\n+  subq(rax, divisor);\n+  andnq(rax, rax, rdx);\n+  sarq(rax, 63);\n+  andq(rax, divisor);\n+  subq(rdx, rax);\n+  bind(done);\n+}\n+\n+void C2_MacroAssembler::udivmodI(Register rax, Register divisor, Register rdx, Register tmp) {\n+  Label done;\n+  Label neg_divisor_fastpath;\n+\n+  cmpl(divisor, 0);\n+  jccb(Assembler::less, neg_divisor_fastpath);\n+  xorl(rdx, rdx);\n+  divl(divisor);\n+  jmp(done);\n+  bind(neg_divisor_fastpath);\n+  \/\/ Fastpath for divisor < 0:\n+  \/\/ quotient = (dividend & ~(dividend - divisor)) >>> (Integer.SIZE - 1)\n+  \/\/ remainder = dividend - (((dividend & ~(dividend - divisor)) >> (Integer.SIZE - 1)) & divisor)\n+  \/\/ See Hacker's Delight (2nd ed), section 9.3 which is implemented in\n+  \/\/ java.lang.Long.divideUnsigned() and java.lang.Long.remainderUnsigned()\n+  movl(rdx, rax);\n+  subl(rax, divisor);\n+  andnl(rax, rax, rdx);\n+  movl(tmp, rax);\n+  shrl(rax, 31); \/\/ quotient\n+  sarl(tmp, 31);\n+  andl(tmp, divisor);\n+  subl(rdx, tmp); \/\/ remainder\n+  bind(done);\n+}\n+\n+void C2_MacroAssembler::udivmodL(Register rax, Register divisor, Register rdx, Register tmp) {\n+  Label done;\n+  Label neg_divisor_fastpath;\n+  cmpq(divisor, 0);\n+  jccb(Assembler::less, neg_divisor_fastpath);\n+  xorq(rdx, rdx);\n+  divq(divisor);\n+  jmp(done);\n+  bind(neg_divisor_fastpath);\n+  \/\/ Fastpath for divisor < 0:\n+  \/\/ quotient = (dividend & ~(dividend - divisor)) >>> (Long.SIZE - 1)\n+  \/\/ remainder = dividend - (((dividend & ~(dividend - divisor)) >> (Long.SIZE - 1)) & divisor)\n+  \/\/ See Hacker's Delight (2nd ed), section 9.3 which is implemented in\n+  \/\/ java.lang.Long.divideUnsigned() and java.lang.Long.remainderUnsigned()\n+  movq(rdx, rax);\n+  subq(rax, divisor);\n+  andnq(rax, rax, rdx);\n+  movq(tmp, rax);\n+  shrq(rax, 63); \/\/ quotient\n+  sarq(tmp, 63);\n+  andq(tmp, divisor);\n+  subq(rdx, tmp); \/\/ remainder\n+  bind(done);\n+}\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":131,"deletions":0,"binary":false,"changes":131,"status":"modified"},{"patch":"@@ -320,1 +320,7 @@\n-#endif \/\/ CPU_X86_C2_MACROASSEMBLER_X86_HPP\n+  void udivI(Register rax, Register divisor, Register rdx);\n+  void udivL(Register rax, Register divisor, Register rdx);\n+  void umodI(Register rax, Register divisor, Register rdx);\n+  void umodL(Register rax, Register divisor, Register rdx);\n+  void udivmodI(Register rax, Register divisor, Register rdx, Register tmp);\n+  void udivmodL(Register rax, Register divisor, Register rdx, Register tmp);\n+#endif \/\/ CPU_X86_C2_MACROASSEMBLER_X86_HPP\n\\ No newline at end of file\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.hpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -8591,19 +8591,1 @@\n-    Label done;\n-    Label neg_divisor_fastpath;\n-    Register divisor = $div$$Register;\n-    Register tmp_rdx = $rdx$$Register; \n-    Register rax = $rax$$Register;\n-    __ cmpl(divisor, 0);\n-    __ jccb(Assembler::less, neg_divisor_fastpath);\n-    __ xorl(tmp_rdx, tmp_rdx);\n-    __ divl(divisor);\n-    __ jmp(done);\n-    __ bind(neg_divisor_fastpath); \n-    \/\/ Fastpath for divisor < 0: \n-    \/\/ quotient = (dividend & ~(dividend - divisor)) >>> (Integer.SIZE - 1)\n-    \/\/ See Hacker's Delight (2nd ed), section 9.3 which is implemented in java.lang.Long.divideUnsigned()\n-    __ movl(tmp_rdx, rax);\n-    __ subl(tmp_rdx, divisor);\n-    __ andnl(rax, tmp_rdx, rax);\n-    __ shrl(rax, 31);\n-    __ bind(done);\n+    __ udivI($rax$$Register, $div$$Register, $rdx$$Register);\n@@ -8622,19 +8604,1 @@\n-    Label done;\n-    Label neg_divisor_fastpath;\n-    Register divisor = $div$$Register;\n-    Register tmp_rdx = $rdx$$Register;;\n-    Register rax = $rax$$Register;;\n-    __ cmpq(divisor, 0);\n-    __ jccb(Assembler::less, neg_divisor_fastpath);\n-    __ xorl(tmp_rdx, tmp_rdx);\n-    __ divq(divisor);\n-    __ jmp(done);\n-    __ bind(neg_divisor_fastpath);\n-    \/\/ Fastpath for divisor < 0: \n-    \/\/ quotient = (dividend & ~(dividend - divisor)) >>> (Long.SIZE - 1)\n-    \/\/ See Hacker's Delight (2nd ed), section 9.3 which is implemented in java.lang.Long.divideUnsigned()\n-    __ movq(tmp_rdx, rax);\n-    __ subq(tmp_rdx, divisor);\n-    __ andnq(rax, tmp_rdx, rax);\n-    __ shrq(rax, 63);\n-    __ bind(done);\n+     __ udivL($rax$$Register, $div$$Register, $rdx$$Register);\n@@ -8698,27 +8662,1 @@\n-    Label done;\n-    Label neg_divisor_fastpath;\n-    Register divisor = $div$$Register;\n-    Register tmp = $tmp$$Register;\n-    Register rdx = $rdx$$Register;;\n-    Register rax = $rax$$Register;;\n-   \n-    __ cmpl(divisor, 0);\n-    __ jccb(Assembler::less, neg_divisor_fastpath);\n-    __ xorl(rdx, rdx);\n-    __ divl(divisor);\n-    __ jmp(done);\n-    __ bind(neg_divisor_fastpath);\n-    \/\/ Fastpath for divisor < 0: \n-    \/\/ quotient = (dividend & ~(dividend - divisor)) >>> (Integer.SIZE - 1)\n-    \/\/ remainder = dividend - (((dividend & ~(dividend - divisor)) >> (Integer.SIZE - 1)) & divisor)\n-    \/\/ See Hacker's Delight (2nd ed), section 9.3 which is implemented in \n-    \/\/ java.lang.Long.divideUnsigned() and java.lang.Long.remainderUnsigned()\n-    __ movl(rdx, rax);\n-    __ subl(rax, divisor);\n-    __ andnl(rax, rax, rdx);\n-    __ movl(tmp, rax);\n-    __ shrl(rax, 31); \/\/ quotient\n-    __ sarl(tmp, 31);\n-    __ andl(tmp, divisor);\n-    __ subl(rdx, tmp); \/\/ remainder\n-    __ bind(done);\n+    __ udivmodI($rax$$Register, $div$$Register, $rdx$$Register, $tmp$$Register);\n@@ -8741,27 +8679,1 @@\n-    Label done;\n-    Label neg_divisor_fastpath;\n-    Register divisor = $div$$Register;\n-    Register tmp = $tmp$$Register;\n-    Register rdx = $rdx$$Register;;\n-    Register rax = $rax$$Register;;\n-   \n-    __ cmpq(divisor, 0);\n-    __ jccb(Assembler::less, neg_divisor_fastpath);\n-    __ xorq(rdx, rdx);\n-    __ divq(divisor);\n-    __ jmp(done);\n-    __ bind(neg_divisor_fastpath);\n-    \/\/ Fastpath for divisor < 0: \n-    \/\/ quotient = (dividend & ~(dividend - divisor)) >>> (Long.SIZE - 1)\n-    \/\/ remainder = dividend - (((dividend & ~(dividend - divisor)) >> (Long.SIZE - 1)) & divisor)\n-    \/\/ See Hacker's Delight (2nd ed), section 9.3 which is implemented in \n-    \/\/ java.lang.Long.divideUnsigned() and java.lang.Long.remainderUnsigned()\n-    __ movq(rdx, rax);\n-    __ subq(rax, divisor);\n-    __ andnq(rax, rax, rdx);\n-    __ movq(tmp, rax);\n-    __ shrq(rax, 63); \/\/ quotient\n-    __ sarq(tmp, 63);\n-    __ andq(tmp, divisor);\n-    __ subq(rdx, tmp); \/\/ remainder\n-    __ bind(done);\n+    __ udivmodL($rax$$Register, $div$$Register, $rdx$$Register, $tmp$$Register);\n@@ -8881,1 +8793,1 @@\n-  ins_cost(300); \n+  ins_cost(300);\n@@ -8884,22 +8796,1 @@\n-    Label done;\n-    Label neg_divisor_fastpath;\n-    Register divisor = $div$$Register;\n-    Register rdx = $rdx$$Register;;\n-    Register tmp_rax = $rax$$Register;;\n-   \n-    __ cmpl(divisor, 0);\n-    __ jccb(Assembler::less, neg_divisor_fastpath);\n-    __ xorl(rdx, rdx);\n-    __ divl(divisor);\n-    __ jmp(done);\n-    __ bind(neg_divisor_fastpath);\n-    \/\/ Fastpath when divisor < 0: \n-    \/\/ remainder = dividend - (((dividend & ~(dividend - divisor)) >> (Integer.SIZE - 1)) & divisor)\n-    \/\/ See Hacker's Delight (2nd ed), section 9.3 which is implemented in java.lang.Long.remainderUnsigned()\n-    __ movl(rdx, tmp_rax);\n-    __ subl(tmp_rax, divisor);\n-    __ andnl(tmp_rax, tmp_rax, rdx);\n-    __ sarl(tmp_rax, 31);\n-    __ andl(tmp_rax, divisor);\n-    __ subl(rdx, tmp_rax);\n-    __ bind(done);\n+    __ umodI($rax$$Register, $div$$Register, $rdx$$Register);\n@@ -8918,22 +8809,1 @@\n-    Label done;\n-    Label neg_divisor_fastpath;\n-    Register divisor = $div$$Register;\n-    Register rdx = $rdx$$Register;;\n-    Register tmp_rax = $rax$$Register;;\n-   \n-    __ cmpq(divisor, 0);\n-    __ jccb(Assembler::less, neg_divisor_fastpath);\n-    __ xorq(rdx, rdx);\n-    __ divq(divisor);\n-    __ jmp(done);\n-    __ bind(neg_divisor_fastpath);\n-    \/\/ Fastpath when divisor < 0: \n-    \/\/ remainder = dividend - (((dividend & ~(dividend - divisor)) >> (Long.SIZE - 1)) & divisor)\n-    \/\/ See Hacker's Delight (2nd ed), section 9.3 which is implemented in java.lang.Long.remainderUnsigned()\n-    __ movq(rdx, tmp_rax);\n-    __ subq(tmp_rax, divisor);\n-    __ andnq(tmp_rax, tmp_rax, rdx);\n-    __ sarq(tmp_rax, 63);\n-    __ andq(tmp_rax, divisor);\n-    __ subq(rdx, tmp_rax);\n-    __ bind(done);\n+    __ umodL($rax$$Register, $div$$Register, $rdx$$Register);\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":7,"deletions":137,"binary":false,"changes":144,"status":"modified"},{"patch":"@@ -850,7 +850,0 @@\n-\n-\/\/------------------------------Idealize---------------------------------------\n-\/\/ Divides can be changed to multiplies and\/or shifts\n-Node* UDivINode::Ideal(PhaseGVN *phase, bool can_reshape) {\n-  return NULL;\n-}\n-\n@@ -888,7 +881,0 @@\n-\n-\/\/------------------------------Idealize---------------------------------------\n-\/\/ Divides can be changed to multiplies and\/or shifts\n-Node* UDivLNode::Ideal(PhaseGVN *phase, bool can_reshape) {\n-  return NULL;\n-}\n-\n@@ -1340,22 +1326,0 @@\n-\/\/=============================================================================\n-\/\/------------------------------UModINode---------------------------------------\n-\/\/ Unsigned integer modulus\n-  const Type* UModINode::Value(PhaseGVN* phase) const {\n-    return TypeInt::INT;\n-  }\n-\n-  Node* UModINode::Ideal(PhaseGVN *phase, bool can_reshape) {\n-    return NULL;\n-  }\n-\n-\/\/=============================================================================\n-\/\/------------------------------UModLNode---------------------------------------\n-\/\/ Unsigned long modulus\n-  const Type* UModLNode::Value(PhaseGVN* phase) const {\n-    return TypeLong::LONG;\n-  }\n-\n-  Node* UModLNode::Ideal(PhaseGVN *phase, bool can_reshape) {\n-    return NULL;\n-  }\n-\n","filename":"src\/hotspot\/share\/opto\/divnode.cpp","additions":0,"deletions":36,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -100,1 +100,0 @@\n-  virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);\n@@ -106,1 +105,1 @@\n-\/\/------------------------------DivLNode---------------------------------------\n+\/\/------------------------------UDivLNode---------------------------------------\n@@ -113,1 +112,0 @@\n-  virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);\n@@ -171,2 +169,0 @@\n-  virtual const Type* Value(PhaseGVN* phase) const;\n-  virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);\n@@ -183,2 +179,0 @@\n-  virtual const Type* Value(PhaseGVN* phase) const;\n-  virtual Node *Ideal(PhaseGVN *phase, bool can_reshape);\n","filename":"src\/hotspot\/share\/opto\/divnode.hpp","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -70,1 +70,1 @@\n-    public int[] testDivideUnsigned() {\n+    public void testDivideUnsigned() {\n@@ -74,1 +74,0 @@\n-        return quotients;\n@@ -78,1 +77,1 @@\n-    public int[] testRemainderUnsigned() {\n+    public void testRemainderUnsigned() {\n@@ -82,1 +81,0 @@\n-        return remainders;\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/IntegerDivMod.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -70,1 +70,1 @@\n-    public long[] testDivideUnsigned() {\n+    public void testDivideUnsigned() {\n@@ -74,1 +74,0 @@\n-        return quotients;\n@@ -78,1 +77,1 @@\n-    public long[] testRemainderUnsigned() {\n+    public void testRemainderUnsigned() {\n@@ -82,1 +81,0 @@\n-        return remainders;\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/LongDivMod.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"}]}