{"files":[{"patch":"@@ -12278,0 +12278,5 @@\n+void Assembler::divq(Register src) {\n+  int encode = prefixq_and_encode(src->encoding());\n+  emit_int16((unsigned char)0xF7, (0xF0 | encode));\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1370,0 +1370,1 @@\n+  void divq(Register src); \/\/ Unsigned division\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -4331,0 +4331,131 @@\n+\n+void C2_MacroAssembler::udivI(Register rax, Register divisor, Register rdx) {\n+  Label done;\n+  Label neg_divisor_fastpath;\n+  cmpl(divisor, 0);\n+  jccb(Assembler::less, neg_divisor_fastpath);\n+  xorl(rdx, rdx);\n+  divl(divisor);\n+  jmp(done);\n+  bind(neg_divisor_fastpath);\n+  \/\/ Fastpath for divisor < 0:\n+  \/\/ quotient = (dividend & ~(dividend - divisor)) >>> (Integer.SIZE - 1)\n+  \/\/ See Hacker's Delight (2nd ed), section 9.3 which is implemented in java.lang.Long.divideUnsigned()\n+  movl(rdx, rax);\n+  subl(rdx, divisor);\n+  andnl(rax, rdx, rax);\n+  shrl(rax, 31);\n+  bind(done);\n+}\n+\n+void C2_MacroAssembler::udivL(Register rax, Register divisor, Register rdx) {\n+  Label done;\n+  Label neg_divisor_fastpath;\n+  cmpq(divisor, 0);\n+  jccb(Assembler::less, neg_divisor_fastpath);\n+  xorl(rdx, rdx);\n+  divq(divisor);\n+  jmp(done);\n+  bind(neg_divisor_fastpath);\n+  \/\/ Fastpath for divisor < 0:\n+  \/\/ quotient = (dividend & ~(dividend - divisor)) >>> (Long.SIZE - 1)\n+  \/\/ See Hacker's Delight (2nd ed), section 9.3 which is implemented in java.lang.Long.divideUnsigned()\n+  movq(rdx, rax);\n+  subq(rdx, divisor);\n+  andnq(rax, rdx, rax);\n+  shrq(rax, 63);\n+  bind(done);\n+}\n+\n+void C2_MacroAssembler::umodI(Register rax, Register divisor, Register rdx) {\n+  Label done;\n+  Label neg_divisor_fastpath;\n+  cmpl(divisor, 0);\n+  jccb(Assembler::less, neg_divisor_fastpath);\n+  xorl(rdx, rdx);\n+  divl(divisor);\n+  jmp(done);\n+  bind(neg_divisor_fastpath);\n+  \/\/ Fastpath when divisor < 0:\n+  \/\/ remainder = dividend - (((dividend & ~(dividend - divisor)) >> (Integer.SIZE - 1)) & divisor)\n+  \/\/ See Hacker's Delight (2nd ed), section 9.3 which is implemented in java.lang.Long.remainderUnsigned()\n+  movl(rdx, rax);\n+  subl(rax, divisor);\n+  andnl(rax, rax, rdx);\n+  sarl(rax, 31);\n+  andl(rax, divisor);\n+  subl(rdx, rax);\n+  bind(done);\n+}\n+\n+void C2_MacroAssembler::umodL(Register rax, Register divisor, Register rdx) {\n+  Label done;\n+  Label neg_divisor_fastpath;\n+  cmpq(divisor, 0);\n+  jccb(Assembler::less, neg_divisor_fastpath);\n+  xorq(rdx, rdx);\n+  divq(divisor);\n+  jmp(done);\n+  bind(neg_divisor_fastpath);\n+  \/\/ Fastpath when divisor < 0:\n+  \/\/ remainder = dividend - (((dividend & ~(dividend - divisor)) >> (Long.SIZE - 1)) & divisor)\n+  \/\/ See Hacker's Delight (2nd ed), section 9.3 which is implemented in java.lang.Long.remainderUnsigned()\n+  movq(rdx, rax);\n+  subq(rax, divisor);\n+  andnq(rax, rax, rdx);\n+  sarq(rax, 63);\n+  andq(rax, divisor);\n+  subq(rdx, rax);\n+  bind(done);\n+}\n+\n+void C2_MacroAssembler::udivmodI(Register rax, Register divisor, Register rdx, Register tmp) {\n+  Label done;\n+  Label neg_divisor_fastpath;\n+\n+  cmpl(divisor, 0);\n+  jccb(Assembler::less, neg_divisor_fastpath);\n+  xorl(rdx, rdx);\n+  divl(divisor);\n+  jmp(done);\n+  bind(neg_divisor_fastpath);\n+  \/\/ Fastpath for divisor < 0:\n+  \/\/ quotient = (dividend & ~(dividend - divisor)) >>> (Integer.SIZE - 1)\n+  \/\/ remainder = dividend - (((dividend & ~(dividend - divisor)) >> (Integer.SIZE - 1)) & divisor)\n+  \/\/ See Hacker's Delight (2nd ed), section 9.3 which is implemented in\n+  \/\/ java.lang.Long.divideUnsigned() and java.lang.Long.remainderUnsigned()\n+  movl(rdx, rax);\n+  subl(rax, divisor);\n+  andnl(rax, rax, rdx);\n+  movl(tmp, rax);\n+  shrl(rax, 31); \/\/ quotient\n+  sarl(tmp, 31);\n+  andl(tmp, divisor);\n+  subl(rdx, tmp); \/\/ remainder\n+  bind(done);\n+}\n+\n+void C2_MacroAssembler::udivmodL(Register rax, Register divisor, Register rdx, Register tmp) {\n+  Label done;\n+  Label neg_divisor_fastpath;\n+  cmpq(divisor, 0);\n+  jccb(Assembler::less, neg_divisor_fastpath);\n+  xorq(rdx, rdx);\n+  divq(divisor);\n+  jmp(done);\n+  bind(neg_divisor_fastpath);\n+  \/\/ Fastpath for divisor < 0:\n+  \/\/ quotient = (dividend & ~(dividend - divisor)) >>> (Long.SIZE - 1)\n+  \/\/ remainder = dividend - (((dividend & ~(dividend - divisor)) >> (Long.SIZE - 1)) & divisor)\n+  \/\/ See Hacker's Delight (2nd ed), section 9.3 which is implemented in\n+  \/\/ java.lang.Long.divideUnsigned() and java.lang.Long.remainderUnsigned()\n+  movq(rdx, rax);\n+  subq(rax, divisor);\n+  andnq(rax, rax, rdx);\n+  movq(tmp, rax);\n+  shrq(rax, 63); \/\/ quotient\n+  sarq(tmp, 63);\n+  andq(tmp, divisor);\n+  subq(rdx, tmp); \/\/ remainder\n+  bind(done);\n+}\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":131,"deletions":0,"binary":false,"changes":131,"status":"modified"},{"patch":"@@ -320,1 +320,7 @@\n-#endif \/\/ CPU_X86_C2_MACROASSEMBLER_X86_HPP\n+  void udivI(Register rax, Register divisor, Register rdx);\n+  void udivL(Register rax, Register divisor, Register rdx);\n+  void umodI(Register rax, Register divisor, Register rdx);\n+  void umodL(Register rax, Register divisor, Register rdx);\n+  void udivmodI(Register rax, Register divisor, Register rdx, Register tmp);\n+  void udivmodL(Register rax, Register divisor, Register rdx, Register tmp);\n+#endif \/\/ CPU_X86_C2_MACROASSEMBLER_X86_HPP\n\\ No newline at end of file\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.hpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -8583,0 +8583,26 @@\n+instruct udivI_rReg(rax_RegI rax, no_rax_rdx_RegI div, rFlagsReg cr, rdx_RegI rdx)\n+%{\n+  match(Set rax (UDivI rax div));\n+  effect(KILL rdx, KILL cr);\n+\n+  ins_cost(300);\n+  format %{ \"udivl $rax,$rax,$div\\t# UDivI\\n\" %}\n+  ins_encode %{\n+    __ udivI($rax$$Register, $div$$Register, $rdx$$Register);\n+  %}\n+  ins_pipe(ialu_reg_reg_alu0);\n+%}\n+\n+instruct udivL_rReg(rax_RegL rax, no_rax_rdx_RegL div, rFlagsReg cr, rdx_RegL rdx)\n+%{\n+  match(Set rax (UDivL rax div));\n+  effect(KILL rdx, KILL cr);\n+\n+  ins_cost(300);\n+  format %{ \"udivq $rax,$rax,$div\\t# UDivL\\n\" %}\n+  ins_encode %{\n+     __ udivL($rax$$Register, $div$$Register, $rdx$$Register);\n+  %}\n+  ins_pipe(ialu_reg_reg_alu0);\n+%}\n+\n@@ -8624,0 +8650,35 @@\n+\/\/ Unsigned integer DIVMOD with Register, both quotient and mod results\n+instruct udivModI_rReg_divmod(rax_RegI rax, no_rax_rdx_RegI div, no_rax_rdx_RegI tmp, \n+              rFlagsReg cr, rdx_RegI rdx)\n+%{\n+  match(UDivModI rax div);\n+  effect(TEMP tmp, KILL cr);\n+\n+  ins_cost(300);\n+  format %{ \"udivl $rax,$rax,$div\\t# begin UDivModI\\n\\t\"\n+            \"umodl $rdx,$rax,$div\\t! using $tmp as TEMP # end UDivModI\\n\"\n+          %}\n+  ins_encode %{\n+    __ udivmodI($rax$$Register, $div$$Register, $rdx$$Register, $tmp$$Register);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ Unsigned long DIVMOD with Register, both quotient and mod results\n+instruct udivModL_rReg_divmod(rax_RegL rax, no_rax_rdx_RegL div, no_rax_rdx_RegL tmp, \n+                              rFlagsReg cr, rdx_RegL rdx)\n+%{\n+  match(UDivModL rax div);\n+  effect(TEMP tmp, KILL cr);\n+\n+  ins_cost(300);\n+  format %{ \"udivq $rax,$rax,$div\\t# begin UDivModL\\n\\t\"\n+            \"umodq $rdx,$rax,$div\\t! using $tmp as TEMP # end UDivModL\\n\"\n+          %}\n+  ins_encode %{\n+    __ udivmodL($rax$$Register, $div$$Register, $rdx$$Register, $tmp$$Register);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\n@@ -8727,0 +8788,26 @@\n+instruct umodI_rReg(rdx_RegI rdx, no_rax_rdx_RegI div, rFlagsReg cr, rax_RegI rax)\n+%{\n+  match(Set rdx (UModI rax div));\n+  effect(KILL rax, KILL cr);\n+\n+  ins_cost(300);\n+  format %{ \"umodl $rdx,$rax,$div\\t# UModI\\n\" %}\n+  ins_encode %{\n+    __ umodI($rax$$Register, $div$$Register, $rdx$$Register);\n+  %}\n+  ins_pipe(ialu_reg_reg_alu0);\n+%}\n+\n+instruct umodL_rReg(rdx_RegL rdx, no_rax_rdx_RegL div, rFlagsReg cr, rax_RegL rax)\n+%{\n+  match(Set rdx (UModL rax div));\n+  effect(KILL rax, KILL cr);\n+\n+  ins_cost(300);\n+  format %{ \"umodq $rdx,$rax,$div\\t# UModL\\n\" %}\n+  ins_encode %{\n+    __ umodL($rax$$Register, $div$$Register, $rdx$$Register);\n+  %}\n+  ins_pipe(ialu_reg_reg_alu0);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":87,"deletions":0,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -216,0 +216,6 @@\n+  do_intrinsic(_divideUnsigned_i,         java_lang_Integer,      divideUnsigned_name,     int2_int_signature,   F_S)   \\\n+  do_intrinsic(_remainderUnsigned_i,      java_lang_Integer,      remainderUnsigned_name,  int2_int_signature,   F_S)   \\\n+    do_name(    divideUnsigned_name,                                   \"divideUnsigned\")                                \\\n+  do_intrinsic(_divideUnsigned_l,         java_lang_Long,         divideUnsigned_name,     long2_long_signature, F_S)   \\\n+  do_intrinsic(_remainderUnsigned_l,      java_lang_Long,         remainderUnsigned_name,  long2_long_signature, F_S)   \\\n+    do_name(    remainderUnsigned_name,                                \"remainderUnsigned\")                             \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -270,0 +270,12 @@\n+  case vmIntrinsics::_divideUnsigned_i:\n+    if (!Matcher::match_rule_supported(Op_UDivI)) return false;\n+    break;\n+  case vmIntrinsics::_remainderUnsigned_i:\n+    if (!Matcher::match_rule_supported(Op_UModI)) return false;\n+    break;\n+  case vmIntrinsics::_divideUnsigned_l:\n+    if (!Matcher::match_rule_supported(Op_UDivL)) return false;\n+    break;\n+  case vmIntrinsics::_remainderUnsigned_l:\n+    if (!Matcher::match_rule_supported(Op_UModL)) return false;\n+    break;\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -165,0 +165,2 @@\n+macro(UDivI)\n+macro(UDivL)\n@@ -168,0 +170,2 @@\n+macro(UDivModI)\n+macro(UDivModL)\n@@ -235,0 +239,2 @@\n+macro(UModI)\n+macro(UModL)\n","filename":"src\/hotspot\/share\/opto\/classes.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -24,1 +24,0 @@\n-\n@@ -3495,0 +3494,30 @@\n+  case Op_UModI:\n+    if (UseDivMod) {\n+      \/\/ Check if a%b and a\/b both exist\n+      Node* d = n->find_similar(Op_UDivI);\n+      if (d) {\n+        \/\/ Replace them with a fused unsigned divmod if supported\n+        if (Matcher::has_match_rule(Op_UDivModI)) {\n+          UDivModINode* divmod = UDivModINode::make(n);\n+          d->subsume_by(divmod->div_proj(), this);\n+          n->subsume_by(divmod->mod_proj(), this);\n+        }\n+      }\n+    }\n+    break;\n+\n+  case Op_UModL:\n+    if (UseDivMod) {\n+      \/\/ Check if a%b and a\/b both exist\n+      Node* d = n->find_similar(Op_UDivL);\n+      if (d) {\n+        \/\/ Replace them with a fused unsigned divmod if supported\n+        if (Matcher::has_match_rule(Op_UDivModL)) {\n+          UDivModLNode* divmod = UDivModLNode::make(n);\n+          d->subsume_by(divmod->div_proj(), this);\n+          n->subsume_by(divmod->mod_proj(), this);\n+        }\n+      }\n+    }\n+    break;\n+\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":30,"deletions":1,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -844,0 +844,63 @@\n+\/\/=============================================================================\n+\/\/------------------------------Identity---------------------------------------\n+\/\/ If the divisor is 1, we are an identity on the dividend.\n+Node* UDivINode::Identity(PhaseGVN* phase) {\n+  return (phase->type( in(2) )->higher_equal(TypeInt::ONE)) ? in(1) : this;\n+}\n+\/\/------------------------------Value------------------------------------------\n+\/\/ A UDivINode divides its inputs.  The third input is a Control input, used to\n+\/\/ prevent hoisting the divide above an unsafe test.\n+const Type* UDivINode::Value(PhaseGVN* phase) const {\n+  \/\/ Either input is TOP ==> the result is TOP\n+  const Type *t1 = phase->type( in(1) );\n+  const Type *t2 = phase->type( in(2) );\n+  if( t1 == Type::TOP ) return Type::TOP;\n+  if( t2 == Type::TOP ) return Type::TOP;\n+\n+  \/\/ x\/x == 1 since we always generate the dynamic divisor check for 0.\n+  if (in(1) == in(2)) {\n+    return TypeInt::ONE;\n+  }\n+\n+  \/\/ Either input is BOTTOM ==> the result is the local BOTTOM\n+  const Type *bot = bottom_type();\n+  if( (t1 == bot) || (t2 == bot) ||\n+      (t1 == Type::BOTTOM) || (t2 == Type::BOTTOM) )\n+    return bot;\n+\n+  \/\/ Otherwise we give up all hope\n+  return TypeInt::INT;\n+}\n+\n+\/\/=============================================================================\n+\/\/------------------------------Identity---------------------------------------\n+\/\/ If the divisor is 1, we are an identity on the dividend.\n+Node* UDivLNode::Identity(PhaseGVN* phase) {\n+  return (phase->type( in(2) )->higher_equal(TypeLong::ONE)) ? in(1) : this;\n+}\n+\/\/------------------------------Value------------------------------------------\n+\/\/ A UDivLNode divides its inputs.  The third input is a Control input, used to\n+\/\/ prevent hoisting the divide above an unsafe test.\n+const Type* UDivLNode::Value(PhaseGVN* phase) const {\n+  \/\/ Either input is TOP ==> the result is TOP\n+  const Type *t1 = phase->type( in(1) );\n+  const Type *t2 = phase->type( in(2) );\n+  if( t1 == Type::TOP ) return Type::TOP;\n+  if( t2 == Type::TOP ) return Type::TOP;\n+\n+  \/\/ x\/x == 1 since we always generate the dynamic divisor check for 0.\n+  if (in(1) == in(2)) {\n+    return TypeLong::ONE;\n+  }\n+\n+  \/\/ Either input is BOTTOM ==> the result is the local BOTTOM\n+  const Type *bot = bottom_type();\n+  if( (t1 == bot) || (t2 == bot) ||\n+      (t1 == Type::BOTTOM) || (t2 == Type::BOTTOM) )\n+    return bot;\n+\n+  \/\/ Otherwise we give up all hope\n+  return TypeLong::LONG;\n+}\n+\n+\n@@ -1323,0 +1386,53 @@\n+\n+\/\/------------------------------make------------------------------------------\n+UDivModINode* UDivModINode::make(Node* div_or_mod) {\n+  Node* n = div_or_mod;\n+  assert(n->Opcode() == Op_UDivI || n->Opcode() == Op_UModI,\n+         \"only div or mod input pattern accepted\");\n+\n+  UDivModINode* divmod = new UDivModINode(n->in(0), n->in(1), n->in(2));\n+  Node*        dproj  = new ProjNode(divmod, DivModNode::div_proj_num);\n+  Node*        mproj  = new ProjNode(divmod, DivModNode::mod_proj_num);\n+  return divmod;\n+}\n+\n+\/\/------------------------------make------------------------------------------\n+UDivModLNode* UDivModLNode::make(Node* div_or_mod) {\n+  Node* n = div_or_mod;\n+  assert(n->Opcode() == Op_UDivL || n->Opcode() == Op_UModL,\n+         \"only div or mod input pattern accepted\");\n+\n+  UDivModLNode* divmod = new UDivModLNode(n->in(0), n->in(1), n->in(2));\n+  Node*        dproj  = new ProjNode(divmod, DivModNode::div_proj_num);\n+  Node*        mproj  = new ProjNode(divmod, DivModNode::mod_proj_num);\n+  return divmod;\n+}\n+\n+\/\/------------------------------match------------------------------------------\n+\/\/ return result(s) along with their RegMask info\n+Node* UDivModINode::match( const ProjNode *proj, const Matcher *match ) {\n+  uint ideal_reg = proj->ideal_reg();\n+  RegMask rm;\n+  if (proj->_con == div_proj_num) {\n+    rm = match->divI_proj_mask();\n+  } else {\n+    assert(proj->_con == mod_proj_num, \"must be div or mod projection\");\n+    rm = match->modI_proj_mask();\n+  }\n+  return new MachProjNode(this, proj->_con, rm, ideal_reg);\n+}\n+\n+\n+\/\/------------------------------match------------------------------------------\n+\/\/ return result(s) along with their RegMask info\n+Node* UDivModLNode::match( const ProjNode *proj, const Matcher *match ) {\n+  uint ideal_reg = proj->ideal_reg();\n+  RegMask rm;\n+  if (proj->_con == div_proj_num) {\n+    rm = match->divL_proj_mask();\n+  } else {\n+    assert(proj->_con == mod_proj_num, \"must be div or mod projection\");\n+    rm = match->modL_proj_mask();\n+  }\n+  return new MachProjNode(this, proj->_con, rm, ideal_reg);\n+}\n","filename":"src\/hotspot\/share\/opto\/divnode.cpp","additions":116,"deletions":0,"binary":false,"changes":116,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -93,0 +93,24 @@\n+\/\/------------------------------UDivINode---------------------------------------\n+\/\/ Unsigned integer division\n+class UDivINode : public Node {\n+public:\n+  UDivINode( Node *c, Node *dividend, Node *divisor ) : Node(c, dividend, divisor ) {}\n+  virtual int Opcode() const;\n+  virtual Node* Identity(PhaseGVN* phase);\n+  virtual const Type* Value(PhaseGVN* phase) const;\n+  virtual const Type *bottom_type() const { return TypeInt::INT; }\n+  virtual uint ideal_reg() const { return Op_RegI; }\n+};\n+\n+\/\/------------------------------UDivLNode---------------------------------------\n+\/\/ Unsigned long division\n+class UDivLNode : public Node {\n+public:\n+  UDivLNode( Node *c, Node *dividend, Node *divisor ) : Node(c, dividend, divisor ) {}\n+  virtual int Opcode() const;\n+  virtual Node* Identity(PhaseGVN* phase);\n+  virtual const Type* Value(PhaseGVN* phase) const;\n+  virtual const Type *bottom_type() const { return TypeLong::LONG; }\n+  virtual uint ideal_reg() const { return Op_RegL; }\n+};\n+\n@@ -139,0 +163,20 @@\n+\/\/------------------------------UModINode---------------------------------------\n+\/\/ Unsigned integer modulus\n+class UModINode : public Node {\n+public:\n+  UModINode( Node *c, Node *in1, Node *in2 ) : Node(c,in1, in2) {}\n+  virtual int Opcode() const;\n+  virtual const Type *bottom_type() const { return TypeInt::INT; }\n+  virtual uint ideal_reg() const { return Op_RegI; }\n+};\n+\n+\/\/------------------------------UModLNode---------------------------------------\n+\/\/ Unsigned long modulus\n+class UModLNode : public Node {\n+public:\n+  UModLNode( Node *c, Node *in1, Node *in2 ) : Node(c,in1, in2) {}\n+  virtual int Opcode() const;\n+  virtual const Type *bottom_type() const { return TypeLong::LONG; }\n+  virtual uint ideal_reg() const { return Op_RegL; }\n+};\n+\n@@ -187,0 +231,27 @@\n+\n+\/\/------------------------------UDivModINode---------------------------------------\n+\/\/ Unsigend integer division with remainder result.\n+class UDivModINode : public DivModNode {\n+public:\n+  UDivModINode( Node *c, Node *dividend, Node *divisor ) : DivModNode(c, dividend, divisor) {}\n+  virtual int Opcode() const;\n+  virtual const Type *bottom_type() const { return TypeTuple::INT_PAIR; }\n+  virtual Node *match( const ProjNode *proj, const Matcher *m );\n+\n+  \/\/ Make a divmod and associated projections from a div or mod.\n+  static UDivModINode* make(Node* div_or_mod);\n+};\n+\n+\/\/------------------------------UDivModLNode---------------------------------------\n+\/\/ Unsigned long division with remainder result.\n+class UDivModLNode : public DivModNode {\n+public:\n+  UDivModLNode( Node *c, Node *dividend, Node *divisor ) : DivModNode(c, dividend, divisor) {}\n+  virtual int Opcode() const;\n+  virtual const Type *bottom_type() const { return TypeTuple::LONG_PAIR; }\n+  virtual Node *match( const ProjNode *proj, const Matcher *m );\n+\n+  \/\/ Make a divmod and associated projections from a div or mod.\n+  static UDivModLNode* make(Node* div_or_mod);\n+};\n+\n","filename":"src\/hotspot\/share\/opto\/divnode.hpp","additions":72,"deletions":1,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -528,0 +528,5 @@\n+  case vmIntrinsics::_divideUnsigned_i:\n+  case vmIntrinsics::_divideUnsigned_l:\n+  case vmIntrinsics::_remainderUnsigned_i:\n+  case vmIntrinsics::_remainderUnsigned_l:      return inline_divmod_methods(intrinsic_id());\n+\n@@ -2184,0 +2189,16 @@\n+\/\/--------------------------inline_unsigned_divmod_methods-----------------------------\n+\/\/ inline int Integer.divideUnsigned(init, int)\n+\/\/ inline int Integer.remainderUnsigned(int, int)\n+bool LibraryCallKit::inline_divmod_methods(vmIntrinsics::ID id) {\n+  Node* n = NULL;\n+  switch(id) {\n+    case vmIntrinsics::_divideUnsigned_i:  n = new UDivINode(NULL, argument(0), argument(1));  break;\n+    case vmIntrinsics::_divideUnsigned_l:  n = new UDivLNode(NULL, argument(0), argument(2));  break;\n+    case vmIntrinsics::_remainderUnsigned_i: n = new UModINode(NULL, argument(0), argument(1));  break;\n+    case vmIntrinsics::_remainderUnsigned_l: n = new UModLNode(NULL, argument(0), argument(2));  break;\n+    default:  fatal_unexpected_iid(id);  break;\n+  }\n+  set_result(_gvn.transform(n));\n+  return true;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":21,"deletions":0,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -267,0 +267,1 @@\n+  bool inline_divmod_methods(vmIntrinsics::ID id);\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1584,0 +1584,2 @@\n+  declare_c2_type(UDivINode, Node)                                        \\\n+  declare_c2_type(UDivLNode, Node)                                        \\\n@@ -1588,0 +1590,2 @@\n+  declare_c2_type(UModINode, Node)                                        \\\n+  declare_c2_type(UModLNode, Node)                                        \\\n@@ -1591,0 +1595,2 @@\n+  declare_c2_type(UDivModINode, DivModNode)                               \\\n+  declare_c2_type(UDivModLNode, DivModNode)                               \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1545,0 +1545,1 @@\n+    @IntrinsicCandidate\n@@ -1562,0 +1563,1 @@\n+    @IntrinsicCandidate\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Integer.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1666,0 +1666,1 @@\n+    @IntrinsicCandidate\n@@ -1688,0 +1689,1 @@\n+    @IntrinsicCandidate\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Long.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,98 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Param;\n+import java.util.random.RandomGenerator;\n+import java.util.random.RandomGeneratorFactory;\n+import java.util.concurrent.TimeUnit;\n+\n+\/**\n+ * Tests unsigned division and modulus methods in java.lang.Integer\n+ *\/\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Thread)\n+public class IntegerDivMod {\n+\n+    RandomGenerator randomGenerator;\n+\n+    @Param({\"mixed\", \"positive\", \"negative\"})\n+    String divisorType;\n+    @Param({\"1024\"})\n+    int BUFFER_SIZE;\n+    int[] dividends, divisors, quotients, remainders;\n+\n+    @Setup\n+    public void setup() {\n+        dividends = new int[BUFFER_SIZE];\n+        divisors = new int[BUFFER_SIZE];\n+        quotients =  new int[BUFFER_SIZE];\n+        remainders =  new int[BUFFER_SIZE];\n+        RandomGenerator rng = RandomGeneratorFactory.getDefault().create(0);\n+        for (int i = 0; i < BUFFER_SIZE; i++) {\n+            dividends[i] = rng.nextInt();\n+            int divisor = rng.nextInt();\n+            if (divisorType.equals(\"positive\")) divisor = Math.abs(divisor);\n+            else if (divisorType.equals(\"negative\")) divisor = -Math.abs(divisor);\n+            divisors[i] = divisor;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void testDivideUnsigned() {\n+        for (int i = 0; i < BUFFER_SIZE; i++) {\n+            quotients[i] = Integer.divideUnsigned(dividends[i], divisors[i]);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void testRemainderUnsigned() {\n+        for (int i = 0; i < BUFFER_SIZE; i++) {\n+            remainders[i] = Integer.remainderUnsigned(dividends[i], divisors[i]);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void testDivideRemainderUnsigned() {\n+        for (int i = 0; i < BUFFER_SIZE; i++) {\n+            divmod(dividends[i], divisors[i], i);\n+        }\n+    }\n+\n+    public void divmod(int dividend, int divisor, int i) {\n+        quotients[i] = Integer.divideUnsigned(dividend, divisor);\n+        remainders[i] = Integer.remainderUnsigned(dividend, divisor);\n+    }\n+\n+}\n+\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/IntegerDivMod.java","additions":98,"deletions":0,"binary":false,"changes":98,"status":"added"},{"patch":"@@ -0,0 +1,98 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Param;\n+import java.util.random.RandomGenerator;\n+import java.util.random.RandomGeneratorFactory;\n+import java.util.concurrent.TimeUnit;\n+\n+\/**\n+ * Tests unsigned division and modulus methods in java.lang.Long\n+ *\/\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Thread)\n+public class LongDivMod {\n+\n+    RandomGenerator randomGenerator;\n+\n+    @Param({\"mixed\", \"positive\", \"negative\"})\n+    String divisorType;\n+    @Param({\"1024\"})\n+    int BUFFER_SIZE;\n+    long[] dividends, divisors, quotients, remainders;\n+\n+    @Setup\n+    public void setup() {\n+        dividends = new long[BUFFER_SIZE];\n+        divisors = new long[BUFFER_SIZE];\n+        quotients =  new long[BUFFER_SIZE];\n+        remainders =  new long[BUFFER_SIZE];\n+        RandomGenerator rng = RandomGeneratorFactory.getDefault().create(0);\n+        for (int i = 0; i < BUFFER_SIZE; i++) {\n+            dividends[i] = rng.nextLong();\n+            long divisor = rng.nextLong();\n+            if (divisorType.equals(\"positive\")) divisor = Math.abs(divisor);\n+            else if (divisorType.equals(\"negative\")) divisor = -Math.abs(divisor);\n+            divisors[i] = divisor;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void testDivideUnsigned() {\n+        for (int i = 0; i < BUFFER_SIZE; i++) {\n+            quotients[i] = Long.divideUnsigned(dividends[i], divisors[i]);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void testRemainderUnsigned() {\n+        for (int i = 0; i < BUFFER_SIZE; i++) {\n+            remainders[i] = Long.remainderUnsigned(dividends[i], divisors[i]);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void testDivideRemainderUnsigned() {\n+        for (int i = 0; i < BUFFER_SIZE; i++) {\n+            divmod(dividends[i], divisors[i], i);\n+        }\n+    }\n+\n+    public void divmod(long dividend, long divisor, int i) {\n+        quotients[i] = Long.divideUnsigned(dividend, divisor);\n+        remainders[i] = Long.remainderUnsigned(dividend, divisor);\n+    }\n+\n+}\n+\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/LongDivMod.java","additions":98,"deletions":0,"binary":false,"changes":98,"status":"added"}]}