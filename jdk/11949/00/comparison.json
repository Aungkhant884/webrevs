{"files":[{"patch":"@@ -1297,3 +1297,0 @@\n-    \/\/ The SEARCH_* bits are not for MN.flags but for the matchFlags argument of MHN.getMembers:\n-    MN_SEARCH_SUPERCLASSES   = 0x00100000, \/\/ walk super classes\n-    MN_SEARCH_INTERFACES     = 0x00200000, \/\/ walk implemented interfaces\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -141,2 +141,0 @@\n-  SEARCH_SUPERCLASSES  = java_lang_invoke_MemberName::MN_SEARCH_SUPERCLASSES,\n-  SEARCH_INTERFACES    = java_lang_invoke_MemberName::MN_SEARCH_INTERFACES,\n@@ -935,110 +933,0 @@\n-int MethodHandles::find_MemberNames(Klass* k,\n-                                    Symbol* name, Symbol* sig,\n-                                    int mflags, Klass* caller,\n-                                    int skip, objArrayHandle results, TRAPS) {\n-  \/\/ %%% take caller into account!\n-\n-  if (k == NULL || !k->is_instance_klass())  return -1;\n-\n-  int rfill = 0, rlimit = results->length(), rskip = skip;\n-  \/\/ overflow measurement:\n-  int overflow = 0, overflow_limit = MAX2(1000, rlimit);\n-\n-  int match_flags = mflags;\n-  bool search_superc = ((match_flags & SEARCH_SUPERCLASSES) != 0);\n-  bool search_intfc  = ((match_flags & SEARCH_INTERFACES)   != 0);\n-  bool local_only = !(search_superc | search_intfc);\n-\n-  if (name != NULL) {\n-    if (name->utf8_length() == 0)  return 0; \/\/ a match is not possible\n-  }\n-  if (sig != NULL) {\n-    if (sig->starts_with(JVM_SIGNATURE_FUNC))\n-      match_flags &= ~(IS_FIELD | IS_TYPE);\n-    else\n-      match_flags &= ~(IS_CONSTRUCTOR | IS_METHOD);\n-  }\n-\n-  if ((match_flags & IS_TYPE) != 0) {\n-    \/\/ NYI, and Core Reflection works quite well for this query\n-  }\n-\n-  if ((match_flags & IS_FIELD) != 0) {\n-    InstanceKlass* ik = InstanceKlass::cast(k);\n-    for (FieldStream st(ik, local_only, !search_intfc); !st.eos(); st.next()) {\n-      if (name != NULL && st.name() != name)\n-          continue;\n-      if (sig != NULL && st.signature() != sig)\n-        continue;\n-      \/\/ passed the filters\n-      if (rskip > 0) {\n-        --rskip;\n-      } else if (rfill < rlimit) {\n-        Handle result(THREAD, results->obj_at(rfill++));\n-        if (!java_lang_invoke_MemberName::is_instance(result()))\n-          return -99;  \/\/ caller bug!\n-        oop saved = MethodHandles::init_field_MemberName(result, st.field_descriptor());\n-        if (saved != result())\n-          results->obj_at_put(rfill-1, saved);  \/\/ show saved instance to user\n-      } else if (++overflow >= overflow_limit) {\n-        match_flags = 0; break; \/\/ got tired of looking at overflow\n-      }\n-    }\n-  }\n-\n-  if ((match_flags & (IS_METHOD | IS_CONSTRUCTOR)) != 0) {\n-    \/\/ watch out for these guys:\n-    Symbol* init_name   = vmSymbols::object_initializer_name();\n-    Symbol* clinit_name = vmSymbols::class_initializer_name();\n-    if (name == clinit_name)  clinit_name = NULL; \/\/ hack for exposing <clinit>\n-    bool negate_name_test = false;\n-    \/\/ fix name so that it captures the intention of IS_CONSTRUCTOR\n-    if (!(match_flags & IS_METHOD)) {\n-      \/\/ constructors only\n-      if (name == NULL) {\n-        name = init_name;\n-      } else if (name != init_name) {\n-        return 0;               \/\/ no constructors of this method name\n-      }\n-    } else if (!(match_flags & IS_CONSTRUCTOR)) {\n-      \/\/ methods only\n-      if (name == NULL) {\n-        name = init_name;\n-        negate_name_test = true; \/\/ if we see the name, we *omit* the entry\n-      } else if (name == init_name) {\n-        return 0;               \/\/ no methods of this constructor name\n-      }\n-    } else {\n-      \/\/ caller will accept either sort; no need to adjust name\n-    }\n-    InstanceKlass* ik = InstanceKlass::cast(k);\n-    for (MethodStream st(ik, local_only, !search_intfc); !st.eos(); st.next()) {\n-      Method* m = st.method();\n-      Symbol* m_name = m->name();\n-      if (m_name == clinit_name)\n-        continue;\n-      if (name != NULL && ((m_name != name) ^ negate_name_test))\n-          continue;\n-      if (sig != NULL && m->signature() != sig)\n-        continue;\n-      \/\/ passed the filters\n-      if (rskip > 0) {\n-        --rskip;\n-      } else if (rfill < rlimit) {\n-        Handle result(THREAD, results->obj_at(rfill++));\n-        if (!java_lang_invoke_MemberName::is_instance(result()))\n-          return -99;  \/\/ caller bug!\n-        CallInfo info(m, NULL, CHECK_0);\n-        oop saved = MethodHandles::init_method_MemberName(result, info);\n-        if (saved != result())\n-          results->obj_at_put(rfill-1, saved);  \/\/ show saved instance to user\n-      } else if (++overflow >= overflow_limit) {\n-        match_flags = 0; break; \/\/ got tired of looking at overflow\n-      }\n-    }\n-  }\n-\n-  \/\/ return number of elements we at leasted wanted to initialize\n-  return rfill + overflow;\n-}\n-\n@@ -1120,2 +1008,0 @@\n-    template(java_lang_invoke_MemberName,MN_SEARCH_SUPERCLASSES) \\\n-    template(java_lang_invoke_MemberName,MN_SEARCH_INTERFACES) \\\n@@ -1329,43 +1215,0 @@\n-\n-\n-\/\/  static native int getMembers(Class<?> defc, String matchName, String matchSig,\n-\/\/          int matchFlags, Class<?> caller, int skip, MemberName[] results);\n-JVM_ENTRY(jint, MHN_getMembers(JNIEnv *env, jobject igcls,\n-                               jclass clazz_jh, jstring name_jh, jstring sig_jh,\n-                               int mflags, jclass caller_jh, jint skip, jobjectArray results_jh)) {\n-  if (clazz_jh == NULL || results_jh == NULL)  return -1;\n-  Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(clazz_jh));\n-\n-  objArrayHandle results(THREAD, (objArrayOop) JNIHandles::resolve(results_jh));\n-  if (results.is_null() || !results->is_objArray())  return -1;\n-\n-  TempNewSymbol name = NULL;\n-  TempNewSymbol sig = NULL;\n-  if (name_jh != NULL) {\n-    name = java_lang_String::as_symbol_or_null(JNIHandles::resolve_non_null(name_jh));\n-    if (name == NULL)  return 0; \/\/ a match is not possible\n-  }\n-  if (sig_jh != NULL) {\n-    sig = java_lang_String::as_symbol_or_null(JNIHandles::resolve_non_null(sig_jh));\n-    if (sig == NULL)  return 0; \/\/ a match is not possible\n-  }\n-\n-  Klass* caller = NULL;\n-  if (caller_jh != NULL) {\n-    oop caller_oop = JNIHandles::resolve_non_null(caller_jh);\n-    if (!java_lang_Class::is_instance(caller_oop))  return -1;\n-    caller = java_lang_Class::as_Klass(caller_oop);\n-  }\n-\n-  if (name != NULL && sig != NULL && results.not_null()) {\n-    \/\/ try a direct resolve\n-    \/\/ %%% TO DO\n-  }\n-\n-  int res = MethodHandles::find_MemberNames(k, name, sig, mflags,\n-                                            caller, skip, results, CHECK_0);\n-  \/\/ TO DO: expand at least some of the MemberNames, to avoid massive callbacks\n-  return res;\n-}\n-JVM_END\n-\n@@ -1546,3 +1389,0 @@\n-  \/\/  static native int getMembers(Class<?> defc, String matchName, String matchSig,\n-  \/\/          int matchFlags, Class<?> caller, int skip, MemberName[] results);\n-  {CC \"getMembers\",                CC \"(\" CLS \"\" STRG \"\" STRG \"I\" CLS \"I[\" MEM \")I\", FN_PTR(MHN_getMembers)},\n","filename":"src\/hotspot\/share\/prims\/methodHandles.cpp","additions":0,"deletions":160,"binary":false,"changes":160,"status":"modified"},{"patch":"@@ -73,3 +73,0 @@\n-  static int find_MemberNames(Klass* k, Symbol* name, Symbol* sig,\n-                              int mflags, Klass* caller,\n-                              int skip, objArrayHandle results, TRAPS);\n","filename":"src\/hotspot\/share\/prims\/methodHandles.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -55,2 +55,0 @@\n-    static native int getMembers(Class<?> defc, String matchName, String matchSig,\n-            int matchFlags, Class<?> caller, int skip, MemberName[] results);\n@@ -122,4 +120,1 @@\n-            MN_REFERENCE_KIND_MASK = 0x0F000000 >> MN_REFERENCE_KIND_SHIFT,\n-            \/\/ The SEARCH_* bits are not for MN.flags but for the matchFlags argument of MHN.getMembers:\n-            MN_SEARCH_SUPERCLASSES = 0x00100000,\n-            MN_SEARCH_INTERFACES   = 0x00200000;\n+            MN_REFERENCE_KIND_MASK = 0x0F000000 >> MN_REFERENCE_KIND_SHIFT;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleNatives.java","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"}]}