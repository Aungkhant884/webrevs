{"files":[{"patch":"@@ -118,1 +118,6 @@\n-      _zero_count = (_zero_count == 0xFF) ? 0 : _zero_count;\n+      if (_zero_count == 0xFF) { \/\/ biggest zero chain length is 255\n+        _zero_count = 1;\n+        \/\/ for now, write it as an ordinary value (UNSINGED5 encodes zero int as a single byte)\n+        \/\/ the new zero sequence is started if there are more than two zero values in a raw\n+        return false;\n+      }\n","filename":"src\/hotspot\/share\/code\/compressedStream.hpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -106,1 +106,1 @@\n-    this.position = position;\n+    super.setPosition(position);\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/code\/CompressedReadStream.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,153 @@\n+\/*\n+ * Copyright (c) 2023, BELLSOFT. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"memory\/resourceArea.hpp\"\n+#include \"code\/debugInfo.hpp\"\n+#include \"unittest.hpp\"\n+\n+class CompressedSparseDataWriteStreamTest {\n+public:\n+  void check_read_write(int variant) {\n+    ResourceMark rm;\n+    DebugInfoWriteStream out(NULL, 100);\n+    u_char* buf1 = out.buffer();\n+\n+    for (int i = 0; i < 1024; i++) {\n+      for (int j = 0; j < i; j++) {\n+        out.write_int(0);\n+        \/\/ mix zeroes with position() calls or with other data\n+        if (variant == 1) {\n+          \/\/ position() call breaks zero sequence optimizaion\n+          out.position();\n+        } else if (variant == 2) {\n+          out.write_byte((jbyte)i);\n+        }\n+      }\n+      out.write_int(i);\n+    }\n+\n+    \/\/ 523776 zero values is written\n+    \/\/ optionally: 523776 position() calls\n+    \/\/ optionally: 523776 bytes is written\n+    \/\/ 1024 int values is written\n+    int expected_position = (variant == 0) ? 6982 : \n+                            (variant == 1) ? 525633 : 1049409;\n+    ASSERT_TRUE(out.position() == expected_position);\n+\n+    u_char* buf2 = out.buffer();\n+    \/\/ the initial buffer is small and must be replaced with a bigger one\n+    ASSERT_TRUE(buf1 != buf2);\n+    CompressedReadStream in(buf2, 0);\n+\n+    for (int i = 0; i < 1024; i++) {\n+      for (int j = 0; j < i; j++) {\n+        ASSERT_TRUE(in.read_int() == 0);\n+        if (variant == 2) {\n+          ASSERT_TRUE(in.read_byte() == (jbyte)i);\n+        }\n+      }\n+      ASSERT_TRUE(in.read_int() == i);\n+    }\n+  }\n+\n+  void check_read_write() {\n+    ResourceMark rm;\n+    DebugInfoWriteStream out(NULL, 100);\n+\n+    for (int i = 0; i < 1000*1000; i++) {\n+      out.write_int(i);\n+      out.write_bool((bool)i);\n+      out.write_byte((jbyte)i);\n+      out.write_signed_int((jint)i);\n+      out.write_double((jdouble)i);\n+      out.write_long((jlong)i);\n+    }\n+\n+    u_char* buf = out.buffer();\n+    CompressedReadStream in(buf, 0);\n+\n+    for (int i = 0; i < 1000*1000; i++) {\n+      ASSERT_TRUE(in.read_int() == i);\n+      ASSERT_TRUE(in.read_bool() == (jboolean)(bool)i);\n+      ASSERT_TRUE(in.read_byte() == (jbyte)i);\n+      ASSERT_TRUE(in.read_signed_int() == (jint)i);\n+      ASSERT_TRUE(in.read_double() == (jdouble)i);\n+      ASSERT_TRUE(in.read_long() == (jlong)i);\n+    }\n+  }\n+\n+  void check_int_encoding() {\n+    ResourceMark rm;\n+    DebugInfoWriteStream out(NULL, 100);\n+    const u_char* buf = out.buffer();\n+\n+    out.write_int(0);\n+    out.write_int(0);\n+    out.write_int(0);\n+    out.write_int(0);\n+    out.write_int(0);\n+    out.write_int(0);\n+    out.write_int(0);\n+    out.write_int(0);\n+    ASSERT_TRUE(out.position() == 2 && buf[0] == 0 && buf[1] == 8);\n+\n+    out.set_position(0);\n+    out.write_int(1);\n+    ASSERT_TRUE(out.position() == 1 && buf[0] == 0x2);\n+\n+    out.set_position(0);\n+    out.write_int(0xff);\n+    ASSERT_TRUE(out.position() == 2 && buf[0] == 0xC0 && buf[1] == 0x2);\n+\n+    out.set_position(0);\n+    out.write_int(0xffff);\n+    ASSERT_TRUE(out.position() == 3 && buf[0] == 0xC0 && buf[1] == 0xfe && buf[2] == 0xD);\n+\n+    out.set_position(0);\n+    out.write_int(0xffffffff);\n+    ASSERT_TRUE(out.position() == 5 && buf[0] == 0xC0 && buf[1] == 0xfe && buf[2] == 0xFD && buf[3] == 0xFD);\n+  }\n+\n+  void check_buffer_grow() {\n+    ResourceMark rm;\n+    DebugInfoWriteStream out(NULL, 100);\n+    for (int i = 0; i < 99; i++) { out.write_int(1); }\n+    out.write_int(0);\n+    out.write_int(1);\n+    out.write_int(2);\n+    const u_char* buf = out.buffer();\n+    ASSERT_TRUE(out.position() == 102 && buf[99] == 1 && buf[100] == 2 && buf[101] == 3);\n+  }\n+};\n+\n+TEST_VM(DebugInfo, basic_test)\n+{\n+  CompressedSparseDataWriteStreamTest test;\n+  test.check_read_write(0);\n+  test.check_read_write(1);\n+  test.check_read_write(2);\n+  test.check_read_write();\n+  test.check_int_encoding();\n+  test.check_buffer_grow();\n+}\n","filename":"test\/hotspot\/gtest\/code\/test_debugInfoCompression.cpp","additions":153,"deletions":0,"binary":false,"changes":153,"status":"added"},{"patch":"@@ -0,0 +1,116 @@\n+\/*\n+ * Copyright (c) 2023, BELLSOFT. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import sun.jvm.hotspot.code.*;\n+import sun.jvm.hotspot.debugger.*;\n+\n+\/**\n+ * @test\n+ * @library \/test\/lib\n+ * @requires vm.hasSA\n+ * @modules jdk.hotspot.agent\/sun.jvm.hotspot.debugger\n+ *          jdk.hotspot.agent\/sun.jvm.hotspot.code\n+ * @run main\/othervm -Xbootclasspath\/a:. TestCompressedReadStream\n+ *\/\n+public class TestCompressedReadStream {\n+\n+    public static void testReadInt() {\n+        byte data[] = { \n+            (byte)0, (byte)4, \/\/ zero zequence of four values\n+            (byte)33, \/\/ UNSIGNED5(32) = 33\n+            (byte)0, (byte)4  \/\/ zero zequence of four values\n+        };\n+        CompressedReadStream in = new CompressedReadStream(new Addr(data), 0);\n+        assertEquals(in.readInt(), 0);\n+        assertEquals(in.readInt(), 0);\n+        assertEquals(in.readInt(), 0);\n+        assertEquals(in.readInt(), 0);\n+        assertEquals(in.readInt(), 32);\n+        assertEquals(in.readInt(), 0);\n+        assertEquals(in.readInt(), 0);\n+        assertEquals(in.readInt(), 0);\n+        assertEquals(in.readInt(), 0);\n+\n+        in.setPosition(2); \/\/ rollback and read once again\n+        assertEquals(in.readInt(), 32);\n+    }\n+    \n+    public static void main(String[] args) {\n+        testReadInt();\n+    }\n+\n+    private static void assertEquals(int a, int b) {\n+        if (a != b) throw new RuntimeException(\"assert failed: \" + a + \" != \" + b);\n+    }\n+}\n+\n+class DummyAddr implements sun.jvm.hotspot.debugger.Address {\n+    public boolean    equals(Object arg)                { return false; }\n+    public int        hashCode()                        { return 0; }\n+    public long       getCIntegerAt      (long offset, long numBytes, boolean isUnsigned) { return 0; }\n+    public Address    getAddressAt       (long offset)  { return null; }\n+    public Address    getCompOopAddressAt (long offset) { return null; }\n+    public Address    getCompKlassAddressAt (long offset) { return null; }\n+    public boolean    getJBooleanAt      (long offset)  { return false; }\n+    public byte       getJByteAt         (long offset)  { return 0; }\n+    public char       getJCharAt         (long offset)  { return 0; }\n+    public double     getJDoubleAt       (long offset)  { return 0; }\n+    public float      getJFloatAt        (long offset)  { return 0; }\n+    public int        getJIntAt          (long offset)  { return 0; }\n+    public long       getJLongAt         (long offset)  { return 0; }\n+    public short      getJShortAt        (long offset)  { return 0; }\n+    public OopHandle  getOopHandleAt     (long offset)  { return null; }\n+    public OopHandle  getCompOopHandleAt (long offset)  { return null; }\n+    public void       setCIntegerAt      (long offset, long numBytes, long value) {}\n+    public void       setAddressAt       (long offset, Address value) {}\n+    public void       setJBooleanAt      (long offset, boolean value) {}\n+    public void       setJByteAt         (long offset, byte value)    {}\n+    public void       setJCharAt         (long offset, char value)    {}\n+    public void       setJDoubleAt       (long offset, double value)  {}\n+    public void       setJFloatAt        (long offset, float value)   {}\n+    public void       setJIntAt          (long offset, int value)     {}\n+    public void       setJLongAt         (long offset, long value)    {}\n+    public void       setJShortAt        (long offset, short value)   {}\n+    public void       setOopHandleAt     (long offset, OopHandle value) {}\n+    public Address    addOffsetTo        (long offset)  { return null; }\n+    public OopHandle  addOffsetToAsOopHandle(long offset)  { return null; }\n+    public long       minus              (Address arg)  { return 0; }\n+    public boolean    lessThan           (Address arg)  { return false; }\n+    public boolean    lessThanOrEqual    (Address arg)  { return false; }\n+    public boolean    greaterThan        (Address arg)  { return false; }\n+    public boolean    greaterThanOrEqual (Address arg)  { return false; }\n+    public Address    andWithMask        (long mask)    { return null; }\n+    public Address    orWithMask         (long mask)    { return null; }\n+    public Address    xorWithMask        (long mask)    { return null; }\n+    public long       asLongValue        ()             { return 0; }\n+}\n+\n+class Addr extends DummyAddr {\n+    byte data[];\n+    public Addr(byte data[]) {\n+        this.data = data;\n+    }\n+    public long getCIntegerAt(long offset, long numBytes, boolean isUnsigned) {\n+        return data[(int)offset];\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/sa\/TestCompressedReadStream.java","additions":116,"deletions":0,"binary":false,"changes":116,"status":"added"}]}