{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -113,4 +113,0 @@\n-  \/\/ Search entry in the linked list\n-  virtual LinkedListNode<E>* find_node(const E& e) = 0;\n-  virtual E* find(const E& e) = 0;\n-\n@@ -122,1 +118,0 @@\n-  virtual bool               remove(const E& e) = 0;\n@@ -207,2 +202,1 @@\n-\n-  virtual LinkedListNode<E>* find_node(const E& e) {\n+  LinkedListNode<E>* find_node(const E& e) {\n@@ -221,1 +215,0 @@\n-\n@@ -250,3 +243,3 @@\n-   \/\/ Remove an entry from the linked list.\n-   \/\/ Return true if the entry is successfully removed\n-   virtual bool remove(const E& e) {\n+  \/\/ Remove an entry from the linked list.\n+  \/\/ Return true if the entry is successfully removed\n+  bool remove(const E& e) {\n@@ -285,1 +278,1 @@\n-  virtual bool remove(LinkedListNode<E>* node) {\n+  bool remove(LinkedListNode<E>* node) {\n@@ -410,1 +403,20 @@\n-  virtual LinkedListNode<E>* find_node(const E& e) {\n+  \/\/ unhide base class's the overloaded member function\n+  \/\/ remove(LinkedListNode<E>* node), which has no reference.\n+  \/\/ remove the using statement we delete boo remove(LinkedListNode<E>* node).\n+  using LinkedListImpl<E, T, F, alloc_failmode>::remove;\n+\n+  bool remove(const E& e) {\n+     LinkedListNode<E>* tmp = this->head();\n+     LinkedListNode<E>* prev = NULL;\n+\n+     while (tmp != NULL) {\n+       if (0 == FUNC(*tmp->peek(), e)) {\n+         return this->remove_after(prev);\n+       }\n+       prev = tmp;\n+       tmp = tmp->next();\n+     }\n+     return false;\n+  }\n+\n+  LinkedListNode<E>* find_node(const E& e) {\n@@ -424,0 +436,5 @@\n+\n+  E* find(const E& e) {\n+    LinkedListNode<E>* node = find_node(e);\n+    return (node == NULL) ? NULL : node->data();\n+  }\n","filename":"src\/hotspot\/share\/utilities\/linkedlist.hpp","additions":31,"deletions":14,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -198,0 +198,44 @@\n+\n+\/\/ class Point doesn't define member function equals() deliberately.\n+\/\/ SortedLinkedList<Point> should be able to compile without it because\n+\/\/ remove\/find should use point_comparator.\n+class Point: public StackObj {\n+  int _x, _y;\n+\n+public:\n+  Point(int x, int y): _x(x), _y(y) {}\n+\n+  int x() const { return _x; }\n+  int y() const { return _y; }\n+};\n+\n+int point_comparator(const Point& p1, const Point& p2) {\n+  int res = p1.x() - p2.x();\n+  return res == 0 ? (p1.y() - p2.y()) : res;\n+}\n+\n+TEST(SortedLinkedList, point) {\n+  Point p1 {0, 0};\n+  Point p2 {1, 1};\n+  Point p3 {2, 2};\n+\n+  SortedLinkedList<Point, point_comparator, ResourceObj::C_HEAP, mtTest> sl;\n+  sl.add(p1);\n+  sl.add(p2);\n+\n+  EXPECT_TRUE(sl.remove(p1))           << \"remove(p1) failed without Point::equals()\";\n+  EXPECT_NE(sl.find(p2), nullptr)      << \"find(p2) failed without Point::equals()\";\n+  LinkedListNode<Point>* result = sl.find_node(p2);\n+  EXPECT_NE(result, nullptr);\n+  EXPECT_EQ(0, point_comparator(*result->peek(), p2)) <<  \"find_node(p2) doesn't work without Point::equals()\";\n+\n+  EXPECT_EQ(sl.find(p1), nullptr)      << \"find a deleted element failed!\";\n+  EXPECT_EQ(sl.find(p3), nullptr)      << \"find a non-existing element failed!\";\n+  EXPECT_FALSE(sl.remove(p3))          << \"remove a non-existing element failed!\";\n+\n+  \/\/ the following code is able to compile even Point::equals() is absent.\n+  \/\/ because LinkedListImpl<Point> invokes neither find() nor remove(). Those member functions\n+  \/\/ are not supposed to be instantiated.\n+  LinkedListImpl<Point, ResourceObj::C_HEAP, mtTest> ll;\n+  ll.add(p1);\n+}\n","filename":"test\/hotspot\/gtest\/utilities\/test_linkedlist.cpp","additions":45,"deletions":1,"binary":false,"changes":46,"status":"modified"}]}