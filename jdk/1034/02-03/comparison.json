{"files":[{"patch":"@@ -29,0 +29,1 @@\n+#include \"runtime\/atomic.hpp\"\n@@ -314,0 +315,2 @@\n+  ShouldNotReachHere();\n+  return 0; \/\/ Satisfy compiler\n@@ -409,72 +412,0 @@\n-\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\/\/ signal handling (except suspend\/resume)\n-\n-\/\/ This routine may be used by user applications as a \"hook\" to catch signals.\n-\/\/ The user-defined signal handler must pass unrecognized signals to this\n-\/\/ routine, and if it returns true (non-zero), then the signal handler must\n-\/\/ return immediately.  If the flag \"abort_if_unrecognized\" is true, then this\n-\/\/ routine will never retun false (zero), but instead will execute a VM panic\n-\/\/ routine kill the process.\n-\/\/\n-\/\/ If this routine returns false, it is OK to call it again.  This allows\n-\/\/ the user-defined signal handler to perform checks either before or after\n-\/\/ the VM performs its own checks.  Naturally, the user code would be making\n-\/\/ a serious error if it tried to handle an exception (such as a null check\n-\/\/ or breakpoint) that the VM was generating for its own correct operation.\n-\/\/\n-\/\/ This routine may recognize any of the following kinds of signals:\n-\/\/    SIGBUS, SIGSEGV, SIGILL, SIGFPE, SIGQUIT, SIGPIPE, SIGXFSZ, SIGUSR1.\n-\/\/ It should be consulted by handlers for any of those signals.\n-\/\/\n-\/\/ The caller of this routine must pass in the three arguments supplied\n-\/\/ to the function referred to in the \"sa_sigaction\" (not the \"sa_handler\")\n-\/\/ field of the structure passed to sigaction().  This routine assumes that\n-\/\/ the sa_flags field passed to sigaction() includes SA_SIGINFO and SA_RESTART.\n-\/\/\n-\/\/ Note that the VM will print warnings if it detects conflicting signal\n-\/\/ handlers, unless invoked with the option \"-XX:+AllowUserSignalHandlers\".\n-\/\/\n-\n-static void javaSignalHandler(int sig, siginfo_t* info, void* ucVoid);\n-static bool javaSignalHandler_inner(int sig, siginfo_t* info, void* ucVoid, bool abort_if_unrecognized);\n-\n-extern \"C\" JNIEXPORT int\n-#if defined(BSD)\n-JVM_handle_bsd_signal\n-#elif defined(AIX)\n-JVM_handle_aix_signal\n-#elif defined(LINUX)\n-JVM_handle_linux_signal\n-#else\n-#error who are you?\n-#endif\n-  (int signo, siginfo_t* siginfo, void* ucontext, int abort_if_unrecognized)\n-{\n-  int rc = 0;\n-  assert(AllowUserSignalHandlers, \"Only valid to call for -XX:+AllowUserSignalHandlers.\");\n-  \/\/ We only allow those signals which had been in the original \"contract\" (see comment above).\n-  switch (signo) {\n-    \/\/  Of those signals, we only pass those to the handler which it would\n-    \/\/  have gotten anyway had it been properly installed:\n-    case SIGSEGV:\n-    case SIGILL:\n-    case SIGBUS:\n-    case SIGFPE:\n-    case SIGPIPE:\n-    case SIGXFSZ:\n-    PPC64_ONLY(case SIGTRAP:)\n-      rc = javaSignalHandler_inner(signo, siginfo, ucontext, abort_if_unrecognized);\n-      break;\n-    \/\/ Ignore these to keep backward compatibility:\n-    case SIGQUIT:\n-    case SIGUSR1:\n-      rc = 0;\n-      break;\n-    \/\/ Invalid according to contract:\n-    default:\n-      ShouldNotReachHere();\n-      rc = 0;\n-  }\n-  return rc;\n-}\n-\n@@ -538,5 +469,32 @@\n-\/\/ Entry point for the hotspot signal handler.\n-static void javaSignalHandler(int sig, siginfo_t* info, void* ucVoid) {\n-  \/\/ Do not add any code here. Add code to javaSignalHandler_inner.\n-  (void)javaSignalHandler_inner(sig, info, ucVoid, true);\n-}\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\/\/ JVM_handle_(linux|aix|bsd)_signal()\n+\n+\/\/ This routine is the shared part of the central hotspot signal handler. It can\n+\/\/ also be called by a user application, if a user application prefers to do\n+\/\/ signal handling itself - in that case it needs to pass signals the hotspot\n+\/\/ internally uses on to the hotspot first.\n+\/\/\n+\/\/ The user-defined signal handler must pass unrecognized signals to this\n+\/\/ routine, and if it returns true (non-zero), then the signal handler must\n+\/\/ return immediately.  If the flag \"abort_if_unrecognized\" is true, then this\n+\/\/ routine will never retun false (zero), but instead will execute a VM panic\n+\/\/ routine kill the process.\n+\/\/\n+\/\/ If this routine returns false, it is OK to call it again.  This allows\n+\/\/ the user-defined signal handler to perform checks either before or after\n+\/\/ the VM performs its own checks.  Naturally, the user code would be making\n+\/\/ a serious error if it tried to handle an exception (such as a null check\n+\/\/ or breakpoint) that the VM was generating for its own correct operation.\n+\/\/\n+\/\/ This routine may recognize any of the following kinds of signals:\n+\/\/    SIGBUS, SIGSEGV, SIGILL, SIGFPE, SIGQUIT, SIGPIPE, SIGXFSZ, SIGUSR1.\n+\/\/ It should be consulted by handlers for any of those signals.\n+\/\/\n+\/\/ The caller of this routine must pass in the three arguments supplied\n+\/\/ to the function referred to in the \"sa_sigaction\" (not the \"sa_handler\")\n+\/\/ field of the structure passed to sigaction().  This routine assumes that\n+\/\/ the sa_flags field passed to sigaction() includes SA_SIGINFO and SA_RESTART.\n+\/\/\n+\/\/ Note that the VM will print warnings if it detects conflicting signal\n+\/\/ handlers, unless invoked with the option \"-XX:+AllowUserSignalHandlers\".\n+\/\/\n@@ -544,1 +502,14 @@\n-static bool javaSignalHandler_inner(int sig, siginfo_t* info, void* ucVoid, bool abort_if_unrecognized) {\n+#if defined(BSD)\n+#define JVM_HANDLE_XXX_SIGNAL JVM_handle_bsd_signal\n+#elif defined(AIX)\n+#define JVM_HANDLE_XXX_SIGNAL JVM_handle_aix_signal\n+#elif defined(LINUX)\n+#define JVM_HANDLE_XXX_SIGNAL JVM_handle_linux_signal\n+#else\n+#error who are you?\n+#endif\n+\n+extern \"C\" JNIEXPORT\n+int JVM_HANDLE_XXX_SIGNAL(int sig, siginfo_t* info,\n+                          void* ucVoid, int abort_if_unrecognized)\n+{\n@@ -563,1 +534,0 @@\n-  JavaThread* const jt = (t != NULL && t->is_Java_thread()) ? (JavaThread*) t : NULL;\n@@ -587,0 +557,1 @@\n+    JavaThread* const jt = (t != NULL && t->is_Java_thread()) ? (JavaThread*) t : NULL;\n@@ -610,1 +581,1 @@\n-    char buf[20];\n+    char buf[64];\n@@ -628,1 +599,0 @@\n-\n@@ -630,0 +600,1 @@\n+}\n@@ -631,0 +602,5 @@\n+\/\/ Entry point for the hotspot signal handler.\n+static void javaSignalHandler(int sig, siginfo_t* info, void* ucVoid) {\n+  \/\/ Do not add any code here!\n+  \/\/ Only add code to either JVM_HANDLE_XXX_SIGNAL or PosixSignals::pd_hotspot_signal_handler.\n+  (void)JVM_HANDLE_XXX_SIGNAL(sig, info, ucVoid, true);\n@@ -1186,1 +1162,1 @@\n-void set_signal_handler(int sig, bool set_installed) {\n+void set_signal_handler(int sig) {\n@@ -1197,1 +1173,1 @@\n-    if (AllowUserSignalHandlers || !set_installed) {\n+    if (AllowUserSignalHandlers) {\n@@ -1214,7 +1190,2 @@\n-  sigAct.sa_handler = SIG_DFL;\n-  if (!set_installed) {\n-    sigAct.sa_flags = SA_SIGINFO|SA_RESTART;\n-  } else {\n-    sigAct.sa_sigaction = javaSignalHandler;\n-    sigAct.sa_flags = SA_SIGINFO|SA_RESTART;\n-  }\n+  sigAct.sa_sigaction = javaSignalHandler;\n+  sigAct.sa_flags = SA_SIGINFO|SA_RESTART;\n@@ -1270,7 +1241,7 @@\n-  set_signal_handler(SIGSEGV, true);\n-  set_signal_handler(SIGPIPE, true);\n-  set_signal_handler(SIGBUS, true);\n-  set_signal_handler(SIGILL, true);\n-  set_signal_handler(SIGFPE, true);\n-  PPC64_ONLY(set_signal_handler(SIGTRAP, true);)\n-  set_signal_handler(SIGXFSZ, true);\n+  set_signal_handler(SIGSEGV);\n+  set_signal_handler(SIGPIPE);\n+  set_signal_handler(SIGBUS);\n+  set_signal_handler(SIGILL);\n+  set_signal_handler(SIGFPE);\n+  PPC64_ONLY(set_signal_handler(SIGTRAP);)\n+  set_signal_handler(SIGXFSZ);\n","filename":"src\/hotspot\/os\/posix\/signals_posix.cpp","additions":68,"deletions":97,"binary":false,"changes":165,"status":"modified"},{"patch":"@@ -2147,0 +2147,2 @@\n+  ShouldNotReachHere();\n+  return 0; \/\/ Satisfy compiler\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"}]}