{"files":[{"patch":"@@ -24,1 +24,1 @@\n-JVM_handle_linux_signal\n+JVM_handle_aix_signal\n","filename":"make\/hotspot\/symbols\/symbols-aix","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -74,4 +74,0 @@\n-\/\/ This boolean allows users to forward their own non-matching signals\n-\/\/ to JVM_handle_bsd_signal\/JVM_handle_linux_signal, harmlessly.\n-static bool signal_handlers_are_installed = false;\n-\n@@ -264,0 +260,2 @@\n+static const char* get_signal_name(int sig, char* out, size_t outlen);\n+\n@@ -440,0 +438,4 @@\n+static void javaSignalHandler(int sig, siginfo_t* info, void* ucVoid);\n+static bool javaSignalHandler_inner(int sig, siginfo_t* info, void* ucVoid, bool abort_if_unrecognized);\n+\n+extern \"C\" JNIEXPORT int\n@@ -441,3 +443,1 @@\n-extern \"C\" JNIEXPORT int JVM_handle_bsd_signal(int signo, siginfo_t* siginfo,\n-                                               void* ucontext,\n-                                               int abort_if_unrecognized);\n+JVM_handle_bsd_signal\n@@ -445,3 +445,3 @@\n-extern \"C\" JNIEXPORT int JVM_handle_aix_signal(int signo, siginfo_t* siginfo,\n-                                               void* ucontext,\n-                                               int abort_if_unrecognized);\n+JVM_handle_aix_signal\n+#elif defined(LINUX)\n+JVM_handle_linux_signal\n@@ -449,5 +449,31 @@\n-extern \"C\" JNIEXPORT int JVM_handle_linux_signal(int signo, siginfo_t* siginfo,\n-                                               void* ucontext,\n-                                               int abort_if_unrecognized);\n-#endif\n-\n+#error who are you?\n+#endif\n+  (int signo, siginfo_t* siginfo, void* ucontext, int abort_if_unrecognized)\n+{\n+  int rc = 0;\n+  assert(AllowUserSignalHandlers, \"Only valid to call for -XX:+AllowUserSignalHandlers.\");\n+  \/\/ We only allow those signals which had been in the original \"contract\" (see comment above).\n+  switch (signo) {\n+    \/\/  Of those signals, we only pass those to the handler which it would\n+    \/\/  have gotten anyway had it been properly installed:\n+    case SIGSEGV:\n+    case SIGILL:\n+    case SIGBUS:\n+    case SIGFPE:\n+    case SIGPIPE:\n+    case SIGXFSZ:\n+    PPC64_ONLY(case SIGTRAP:)\n+      rc = javaSignalHandler_inner(signo, siginfo, ucontext, abort_if_unrecognized);\n+      break;\n+    \/\/ Ignore these to keep backward compatibility:\n+    case SIGQUIT:\n+    case SIGUSR1:\n+      rc = 0;\n+      break;\n+    \/\/ Invalid according to contract:\n+    default:\n+      ShouldNotReachHere();\n+      rc = 0;\n+  }\n+  return rc;\n+}\n@@ -505,3 +531,22 @@\n-\/\/ Renamed from 'signalHandler' to avoid collision with other shared libs.\n-static void javaSignalHandler(int sig, siginfo_t* info, void* uc) {\n-  assert(info != NULL && uc != NULL, \"it must be old kernel\");\n+class ErrnoPreserver: public StackObj {\n+  const int _saved;\n+public:\n+  ErrnoPreserver() : _saved(errno) {}\n+  ~ErrnoPreserver() { errno = _saved; }\n+};\n+\n+\/\/ Entry point for the hotspot signal handler.\n+static void javaSignalHandler(int sig, siginfo_t* info, void* ucVoid) {\n+  \/\/ Do not add any code here. Add code to javaSignalHandler_inner.\n+  (void)javaSignalHandler_inner(sig, info, ucVoid, true);\n+}\n+\n+static bool javaSignalHandler_inner(int sig, siginfo_t* info, void* ucVoid, bool abort_if_unrecognized) {\n+  assert(info != NULL && ucVoid != NULL, \"sanity\");\n+\n+  \/\/ Note: it's not uncommon that JNI code uses signal\/sigset to install,\n+  \/\/ then restore certain signal handler (e.g. to temporarily block SIGPIPE,\n+  \/\/ or have a SIGILL handler when detecting CPU type). When that happens,\n+  \/\/ this handler might be invoked with junk info\/ucVoid. To avoid unnecessary\n+  \/\/ crash when libjsig is not preloaded, try handle signals that do not require\n+  \/\/ siginfo\/ucontext first.\n@@ -509,0 +554,5 @@\n+  \/\/ Preserve errno value over signal handler.\n+  \/\/  (note: RAII ok here, even with JFR thread crash protection, see below).\n+  ErrnoPreserver ep;\n+\n+  \/\/ Unblock all synchronous error signals (see JDK-8252533)\n@@ -511,5 +561,61 @@\n-  int orig_errno = errno;  \/\/ Preserve errno value over signal handler.\n-#if defined(BSD)\n-  JVM_handle_bsd_signal(sig, info, uc, true);\n-#elif defined(AIX)\n-  JVM_handle_aix_signal(sig, info, uc, true);\n+  ucontext_t* const uc = (ucontext_t*) ucVoid;\n+  Thread* const t = Thread::current_or_null_safe();\n+  JavaThread* const jt = (t != NULL && t->is_Java_thread()) ? (JavaThread*) t : NULL;\n+\n+  \/\/ Handle JFR thread crash protection.\n+  \/\/  Note: this may cause us to longjmp away. Do not use any code before this\n+  \/\/  point which really needs any form of epilogue code running, eg RAII objects.\n+  os::ThreadCrashProtection::check_crash_protection(sig, t);\n+\n+  bool signal_was_handled = false;\n+\n+  \/\/ Handle assertion poison page accesses.\n+#ifdef CAN_SHOW_REGISTERS_ON_ASSERT\n+  if ((sig == SIGSEGV || sig == SIGBUS) && info != NULL && info->si_addr == g_assert_poison) {\n+    signal_was_handled = handle_assert_poison_fault(ucVoid, info->si_addr);\n+  }\n+#endif\n+\n+  \/\/ Ignore SIGPIPE and SIGXFSZ (4229104, 6499219).\n+  if (sig == SIGPIPE || sig == SIGXFSZ) {\n+    PosixSignals::chained_handler(sig, info, ucVoid);\n+    signal_was_handled = true; \/\/ unconditionally.\n+  }\n+\n+  \/\/ Call platform dependent signal handler.\n+  if (!signal_was_handled) {\n+    signal_was_handled = PosixSignals::pd_hotspot_signal_handler(sig, info, uc, jt);\n+  }\n+\n+  \/\/ From here on, if the signal had not been handled, it is a fatal error.\n+\n+  \/\/ Give the chained signal handler - should it exist - a shot.\n+  if (!signal_was_handled) {\n+    signal_was_handled = PosixSignals::chained_handler(sig, info, ucVoid);\n+  }\n+\n+  \/\/ Invoke fatal error handling.\n+  if (!signal_was_handled && abort_if_unrecognized) {\n+    \/\/ Extract pc from context for the error handler to display.\n+    address pc = NULL;\n+    if (uc != NULL) {\n+      \/\/ prepare fault pc address for error reporting.\n+      if (S390_ONLY(sig == SIGILL || sig == SIGFPE) NOT_S390(false)) {\n+        pc = (address)info->si_addr;\n+      } else {\n+        pc = PosixSignals::ucontext_get_pc(uc);\n+      }\n+    }\n+#if defined(ZERO) && !defined(PRODUCT)\n+    char buf[20];\n+    VMError::report_and_die(t, sig, pc, info, ucVoid,\n+          \"\\n#\"\n+          \"\\n#    \/--------------------\\\\\"\n+          \"\\n#    |      %-7s       |\"\n+          \"\\n#    \\\\---\\\\ \/--------------\/\"\n+          \"\\n#        \/\"\n+          \"\\n#    [-]        |\\\\_\/|    \"\n+          \"\\n#    (+)=C      |o o|__  \"\n+          \"\\n#    | |        =-*-=__\\\\ \"\n+          \"\\n#    OOO        c_c_(___)\",\n+          get_signal_name(sig, buf, sizeof(buf)));\n@@ -517,1 +623,1 @@\n-  JVM_handle_linux_signal(sig, info, uc, true);\n+    VMError::report_and_die(t, sig, pc, info, ucVoid);\n@@ -519,1 +625,6 @@\n-  errno = orig_errno;\n+    \/\/ VMError should not return.\n+    ShouldNotReachHere();\n+  }\n+\n+  return signal_was_handled;\n+\n@@ -769,3 +880,1 @@\n-#if defined(PPC64)\n-  do_signal_check(SIGTRAP);\n-#endif\n+  PPC64_ONLY(do_signal_check(SIGTRAP);)\n@@ -938,1 +1047,0 @@\n-\/\/ Returned string is a constant. For unknown signals \"UNKNOWN\" is returned.\n@@ -1139,7 +1247,0 @@\n-\/\/ install signal handlers for signals that HotSpot needs to\n-\/\/ handle in order to support Java-level exception handling.\n-\n-bool PosixSignals::are_signal_handlers_installed() {\n-  return signal_handlers_are_installed;\n-}\n-\n@@ -1149,21 +1250,0 @@\n-  if (!signal_handlers_are_installed) {\n-    signal_handlers_are_installed = true;\n-\n-    \/\/ signal-chaining\n-    typedef void (*signal_setting_t)();\n-    signal_setting_t begin_signal_setting = NULL;\n-    signal_setting_t end_signal_setting = NULL;\n-    begin_signal_setting = CAST_TO_FN_PTR(signal_setting_t,\n-                                          dlsym(RTLD_DEFAULT, \"JVM_begin_signal_setting\"));\n-    if (begin_signal_setting != NULL) {\n-      end_signal_setting = CAST_TO_FN_PTR(signal_setting_t,\n-                                          dlsym(RTLD_DEFAULT, \"JVM_end_signal_setting\"));\n-      get_signal_action = CAST_TO_FN_PTR(get_signal_t,\n-                                         dlsym(RTLD_DEFAULT, \"JVM_get_signal_action\"));\n-      libjsig_is_loaded = true;\n-      assert(UseSignalChaining, \"should enable signal-chaining\");\n-    }\n-    if (libjsig_is_loaded) {\n-      \/\/ Tell libjsig jvm is setting signal handlers\n-      (*begin_signal_setting)();\n-    }\n@@ -1171,9 +1251,26 @@\n-    set_signal_handler(SIGSEGV, true);\n-    set_signal_handler(SIGPIPE, true);\n-    set_signal_handler(SIGBUS, true);\n-    set_signal_handler(SIGILL, true);\n-    set_signal_handler(SIGFPE, true);\n-#if defined(PPC64) || defined(AIX)\n-    set_signal_handler(SIGTRAP, true);\n-#endif\n-    set_signal_handler(SIGXFSZ, true);\n+  \/\/ signal-chaining\n+  typedef void (*signal_setting_t)();\n+  signal_setting_t begin_signal_setting = NULL;\n+  signal_setting_t end_signal_setting = NULL;\n+  begin_signal_setting = CAST_TO_FN_PTR(signal_setting_t,\n+                                        dlsym(RTLD_DEFAULT, \"JVM_begin_signal_setting\"));\n+  if (begin_signal_setting != NULL) {\n+    end_signal_setting = CAST_TO_FN_PTR(signal_setting_t,\n+                                        dlsym(RTLD_DEFAULT, \"JVM_end_signal_setting\"));\n+    get_signal_action = CAST_TO_FN_PTR(get_signal_t,\n+                                       dlsym(RTLD_DEFAULT, \"JVM_get_signal_action\"));\n+    libjsig_is_loaded = true;\n+    assert(UseSignalChaining, \"should enable signal-chaining\");\n+  }\n+  if (libjsig_is_loaded) {\n+    \/\/ Tell libjsig jvm is setting signal handlers\n+    (*begin_signal_setting)();\n+  }\n+\n+  set_signal_handler(SIGSEGV, true);\n+  set_signal_handler(SIGPIPE, true);\n+  set_signal_handler(SIGBUS, true);\n+  set_signal_handler(SIGILL, true);\n+  set_signal_handler(SIGFPE, true);\n+  PPC64_ONLY(set_signal_handler(SIGTRAP, true);)\n+  set_signal_handler(SIGXFSZ, true);\n@@ -1182,19 +1279,19 @@\n-    \/\/ In Mac OS X 10.4, CrashReporter will write a crash log for all 'fatal' signals, including\n-    \/\/ signals caught and handled by the JVM. To work around this, we reset the mach task\n-    \/\/ signal handler that's placed on our process by CrashReporter. This disables\n-    \/\/ CrashReporter-based reporting.\n-    \/\/\n-    \/\/ This work-around is not necessary for 10.5+, as CrashReporter no longer intercedes\n-    \/\/ on caught fatal signals.\n-    \/\/\n-    \/\/ Additionally, gdb installs both standard BSD signal handlers, and mach exception\n-    \/\/ handlers. By replacing the existing task exception handler, we disable gdb's mach\n-    \/\/ exception handling, while leaving the standard BSD signal handlers functional.\n-    kern_return_t kr;\n-    kr = task_set_exception_ports(mach_task_self(),\n-                                  EXC_MASK_BAD_ACCESS | EXC_MASK_ARITHMETIC,\n-                                  MACH_PORT_NULL,\n-                                  EXCEPTION_STATE_IDENTITY,\n-                                  MACHINE_THREAD_STATE);\n-\n-    assert(kr == KERN_SUCCESS, \"could not set mach task signal handler\");\n+  \/\/ In Mac OS X 10.4, CrashReporter will write a crash log for all 'fatal' signals, including\n+  \/\/ signals caught and handled by the JVM. To work around this, we reset the mach task\n+  \/\/ signal handler that's placed on our process by CrashReporter. This disables\n+  \/\/ CrashReporter-based reporting.\n+  \/\/\n+  \/\/ This work-around is not necessary for 10.5+, as CrashReporter no longer intercedes\n+  \/\/ on caught fatal signals.\n+  \/\/\n+  \/\/ Additionally, gdb installs both standard BSD signal handlers, and mach exception\n+  \/\/ handlers. By replacing the existing task exception handler, we disable gdb's mach\n+  \/\/ exception handling, while leaving the standard BSD signal handlers functional.\n+  kern_return_t kr;\n+  kr = task_set_exception_ports(mach_task_self(),\n+                                EXC_MASK_BAD_ACCESS | EXC_MASK_ARITHMETIC,\n+                                MACH_PORT_NULL,\n+                                EXCEPTION_STATE_IDENTITY,\n+                                MACHINE_THREAD_STATE);\n+\n+  assert(kr == KERN_SUCCESS, \"could not set mach task signal handler\");\n@@ -1203,0 +1300,9 @@\n+  if (libjsig_is_loaded) {\n+    \/\/ Tell libjsig jvm finishes setting signal handlers\n+    (*end_signal_setting)();\n+  }\n+\n+  \/\/ We don't activate signal checker if libjsig is in place, we trust ourselves\n+  \/\/ and if UserSignalHandler is installed all bets are off.\n+  \/\/ Log that signal checking is off only if -verbose:jni is specified.\n+  if (CheckJNICalls) {\n@@ -1204,2 +1310,2 @@\n-      \/\/ Tell libjsig jvm finishes setting signal handlers\n-      (*end_signal_setting)();\n+      log_debug(jni, resolve)(\"Info: libjsig is activated, all active signal checking is disabled\");\n+      check_signals = false;\n@@ -1207,13 +1313,3 @@\n-\n-    \/\/ We don't activate signal checker if libjsig is in place, we trust ourselves\n-    \/\/ and if UserSignalHandler is installed all bets are off.\n-    \/\/ Log that signal checking is off only if -verbose:jni is specified.\n-    if (CheckJNICalls) {\n-      if (libjsig_is_loaded) {\n-        log_debug(jni, resolve)(\"Info: libjsig is activated, all active signal checking is disabled\");\n-        check_signals = false;\n-      }\n-      if (AllowUserSignalHandlers) {\n-        log_debug(jni, resolve)(\"Info: AllowUserSignalHandlers is activated, all active signal checking is disabled\");\n-        check_signals = false;\n-      }\n+    if (AllowUserSignalHandlers) {\n+      log_debug(jni, resolve)(\"Info: AllowUserSignalHandlers is activated, all active signal checking is disabled\");\n+      check_signals = false;\n@@ -1357,3 +1453,1 @@\n-  #if defined(PPC64) || defined(AIX)\n-    sigaddset(&unblocked_sigs, SIGTRAP);\n-  #endif\n+  PPC64_ONLY(sigaddset(&unblocked_sigs, SIGTRAP);)\n","filename":"src\/hotspot\/os\/posix\/signals_posix.cpp","additions":197,"deletions":103,"binary":false,"changes":300,"status":"modified"},{"patch":"@@ -41,1 +41,5 @@\n-  static bool are_signal_handlers_installed();\n+  \/\/ The platform dependent parts of the central hotspot signal handler.\n+  \/\/ Returns true if the signal had been recognized and handled, false if not. If true, caller should\n+  \/\/ return from signal handling.\n+  static bool pd_hotspot_signal_handler(int sig, siginfo_t* info, ucontext_t* uc, JavaThread* thread);\n+\n","filename":"src\/hotspot\/os\/posix\/signals_posix.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -171,37 +171,2 @@\n-\/\/ Utility functions\n-\n-extern \"C\" JNIEXPORT int\n-JVM_handle_aix_signal(int sig, siginfo_t* info, void* ucVoid, int abort_if_unrecognized) {\n-\n-  ucontext_t* uc = (ucontext_t*) ucVoid;\n-\n-  Thread* t = Thread::current_or_null_safe();\n-\n-  \/\/ Note: it's not uncommon that JNI code uses signal\/sigset to install\n-  \/\/ then restore certain signal handler (e.g. to temporarily block SIGPIPE,\n-  \/\/ or have a SIGILL handler when detecting CPU type). When that happens,\n-  \/\/ JVM_handle_aix_signal() might be invoked with junk info\/ucVoid. To\n-  \/\/ avoid unnecessary crash when libjsig is not preloaded, try handle signals\n-  \/\/ that do not require siginfo\/ucontext first.\n-\n-  if (sig == SIGPIPE || sig == SIGXFSZ) {\n-    if (PosixSignals::chained_handler(sig, info, ucVoid)) {\n-      return 1;\n-    } else {\n-      \/\/ Ignoring SIGPIPE - see bugs 4229104\n-      return 1;\n-    }\n-  }\n-\n-  JavaThread* thread = NULL;\n-  VMThread* vmthread = NULL;\n-  if (PosixSignals::are_signal_handlers_installed()) {\n-    if (t != NULL) {\n-      if(t->is_Java_thread()) {\n-        thread = t->as_Java_thread();\n-      }\n-      else if(t->is_VM_thread()) {\n-        vmthread = (VMThread *)t;\n-      }\n-    }\n-  }\n+bool PosixSignals::pd_hotspot_signal_handler(int sig, siginfo_t* info,\n+                                             ucontext_t* uc, JavaThread* thread) {\n@@ -229,2 +194,2 @@\n-  if (info == NULL || uc == NULL || thread == NULL && vmthread == NULL) {\n-    goto run_chained_handler;\n+  if (info == NULL || uc == NULL) {\n+    return false; \/\/ Fatal error\n@@ -240,1 +205,1 @@\n-        return 1; \/\/ continue\n+        return true; \/\/ continue\n@@ -244,1 +209,1 @@\n-        goto report_and_die;\n+        return false; \/\/ Fatal error\n@@ -284,11 +249,0 @@\n-      \/\/ A VM-related SIGILL may only occur if we are not in the zero page.\n-      \/\/ On AIX, we get a SIGILL if we jump to 0x0 or to somewhere else\n-      \/\/ in the zero page, because it is filled with 0x0. We ignore\n-      \/\/ explicit SIGILLs in the zero page.\n-      if (sig == SIGILL && (pc < (address) 0x200)) {\n-        if (TraceTraps) {\n-          tty->print_raw_cr(\"SIGILL happened inside zero page.\");\n-        }\n-        goto report_and_die;\n-      }\n-\n@@ -387,4 +341,1 @@\n-        va_list detail_args;\n-        VMError::report_and_die(INTERNAL_ERROR, msg, detail_msg, detail_args, thread,\n-                                pc, info, ucVoid, NULL, 0, 0);\n-        va_end(detail_args);\n+        return false; \/\/ Fatal error\n@@ -406,1 +357,1 @@\n-          return 1;\n+          return true;\n@@ -431,1 +382,1 @@\n-        return 1;\n+        return true;\n@@ -453,1 +404,1 @@\n-    return 1;\n+    return true;\n@@ -456,23 +407,1 @@\n-run_chained_handler:\n-\n-  \/\/ signal-chaining\n-  if (PosixSignals::chained_handler(sig, info, ucVoid)) {\n-    return 1;\n-  }\n-  if (!abort_if_unrecognized) {\n-    \/\/ caller wants another chance, so give it to him\n-    return 0;\n-  }\n-\n-report_and_die:\n-\n-  \/\/ Use sigthreadmask instead of sigprocmask on AIX and unmask current signal.\n-  sigset_t newset;\n-  sigemptyset(&newset);\n-  sigaddset(&newset, sig);\n-  sigthreadmask(SIG_UNBLOCK, &newset, NULL);\n-\n-  VMError::report_and_die(t, sig, pc, info, ucVoid);\n-\n-  ShouldNotReachHere();\n-  return 0;\n+  return false; \/\/ Fatal error\n","filename":"src\/hotspot\/os_cpu\/aix_ppc\/os_aix_ppc.cpp","additions":11,"deletions":82,"binary":false,"changes":93,"status":"modified"},{"patch":"@@ -388,2 +388,0 @@\n-\/\/ Utility functions\n-\n@@ -395,30 +393,2 @@\n-extern \"C\" JNIEXPORT int\n-JVM_handle_bsd_signal(int sig,\n-                        siginfo_t* info,\n-                        void* ucVoid,\n-                        int abort_if_unrecognized) {\n-  ucontext_t* uc = (ucontext_t*) ucVoid;\n-\n-  Thread* t = Thread::current_or_null_safe();\n-\n-  \/\/ If crash protection is installed we may longjmp away and no destructors\n-  \/\/ for objects in this scope will be run.\n-  \/\/ So don't use any RAII utilities before crash protection is checked.\n-  os::ThreadCrashProtection::check_crash_protection(sig, t);\n-\n-  \/\/ Note: it's not uncommon that JNI code uses signal\/sigset to install\n-  \/\/ then restore certain signal handler (e.g. to temporarily block SIGPIPE,\n-  \/\/ or have a SIGILL handler when detecting CPU type). When that happens,\n-  \/\/ JVM_handle_bsd_signal() might be invoked with junk info\/ucVoid. To\n-  \/\/ avoid unnecessary crash when libjsig is not preloaded, try handle signals\n-  \/\/ that do not require siginfo\/ucontext first.\n-\n-  if (sig == SIGPIPE || sig == SIGXFSZ) {\n-    \/\/ allow chained handler to go first\n-    if (PosixSignals::chained_handler(sig, info, ucVoid)) {\n-      return true;\n-    } else {\n-      \/\/ Ignoring SIGPIPE\/SIGXFSZ - see bugs 4229104 or 6499219\n-      return true;\n-    }\n-  }\n+bool PosixSignals::pd_hotspot_signal_handler(int sig, siginfo_t* info,\n+                                             ucontext_t* uc, JavaThread* thread) {\n@@ -426,12 +396,0 @@\n-  JavaThread* thread = NULL;\n-  VMThread* vmthread = NULL;\n-  if (PosixSignals::are_signal_handlers_installed()) {\n-    if (t != NULL ){\n-      if(t->is_Java_thread()) {\n-        thread = t->as_Java_thread();\n-      }\n-      else if(t->is_VM_thread()){\n-        vmthread = (VMThread *)t;\n-      }\n-    }\n-  }\n@@ -458,1 +416,1 @@\n-      return 1;\n+      return true;\n@@ -469,1 +427,1 @@\n-          return 1; \/\/ continue\n+          return true; \/\/ continue\n@@ -681,23 +639,0 @@\n-  \/\/ signal-chaining\n-  if (PosixSignals::chained_handler(sig, info, ucVoid)) {\n-     return true;\n-  }\n-\n-  if (!abort_if_unrecognized) {\n-    \/\/ caller wants another chance, so give it to him\n-    return false;\n-  }\n-\n-  if (pc == NULL && uc != NULL) {\n-    pc = os::Bsd::ucontext_get_pc(uc);\n-  }\n-\n-  \/\/ unmask current signal\n-  sigset_t newset;\n-  sigemptyset(&newset);\n-  sigaddset(&newset, sig);\n-  sigprocmask(SIG_UNBLOCK, &newset, NULL);\n-\n-  VMError::report_and_die(t, sig, pc, info, ucVoid);\n-\n-  ShouldNotReachHere();\n","filename":"src\/hotspot\/os_cpu\/bsd_x86\/os_bsd_x86.cpp","additions":4,"deletions":69,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -118,6 +118,2 @@\n-extern \"C\" JNIEXPORT int\n-JVM_handle_bsd_signal(int sig,\n-                        siginfo_t* info,\n-                        void* ucVoid,\n-                        int abort_if_unrecognized) {\n-  ucontext_t* uc = (ucontext_t*) ucVoid;\n+bool PosixSignals::pd_hotspot_signal_handler(int sig, siginfo_t* info,\n+                                             ucontext_t* uc, JavaThread* thread) {\n@@ -125,3 +121,1 @@\n-  Thread* t = Thread::current_or_null_safe();\n-\n-  \/\/ handle SafeFetch faults\n+  \/\/ handle SafeFetch faults the zero way\n@@ -135,31 +129,0 @@\n-  \/\/ Note: it's not uncommon that JNI code uses signal\/sigset to\n-  \/\/ install then restore certain signal handler (e.g. to temporarily\n-  \/\/ block SIGPIPE, or have a SIGILL handler when detecting CPU\n-  \/\/ type). When that happens, JVM_handle_bsd_signal() might be\n-  \/\/ invoked with junk info\/ucVoid. To avoid unnecessary crash when\n-  \/\/ libjsig is not preloaded, try handle signals that do not require\n-  \/\/ siginfo\/ucontext first.\n-\n-  if (sig == SIGPIPE || sig == SIGXFSZ) {\n-    \/\/ allow chained handler to go first\n-    if (PosixSignals::chained_handler(sig, info, ucVoid)) {\n-      return true;\n-    } else {\n-      \/\/ Ignoring SIGPIPE\/SIGXFSZ - see bugs 4229104 or 6499219\n-      return true;\n-    }\n-  }\n-\n-  JavaThread* thread = NULL;\n-  VMThread* vmthread = NULL;\n-  if (PosixSignals::are_signal_handlers_installed()) {\n-    if (t != NULL ){\n-      if(t->is_Java_thread()) {\n-        thread = t->as_Java_thread();\n-      }\n-      else if(t->is_VM_thread()){\n-        vmthread = (VMThread *)t;\n-      }\n-    }\n-  }\n-\n@@ -205,30 +168,0 @@\n-  \/\/ signal-chaining\n-  if (PosixSignals::chained_handler(sig, info, ucVoid)) {\n-     return true;\n-  }\n-\n-  if (!abort_if_unrecognized) {\n-    \/\/ caller wants another chance, so give it to him\n-    return false;\n-  }\n-\n-#ifndef PRODUCT\n-  if (sig == SIGSEGV) {\n-    fatal(\"\\n#\"\n-          \"\\n#    \/--------------------\\\\\"\n-          \"\\n#    | segmentation fault |\"\n-          \"\\n#    \\\\---\\\\ \/--------------\/\"\n-          \"\\n#        \/\"\n-          \"\\n#    [-]        |\\\\_\/|    \"\n-          \"\\n#    (+)=C      |o o|__  \"\n-          \"\\n#    | |        =-*-=__\\\\ \"\n-          \"\\n#    OOO        c_c_(___)\");\n-  }\n-#endif \/\/ !PRODUCT\n-\n-  const char *fmt =\n-      \"caught unhandled signal \" INT32_FORMAT \" at address \" PTR_FORMAT;\n-  char buf[128];\n-\n-  sprintf(buf, fmt, sig, info->si_addr);\n-  fatal(buf);\n","filename":"src\/hotspot\/os_cpu\/bsd_zero\/os_bsd_zero.cpp","additions":3,"deletions":70,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -167,30 +167,2 @@\n-extern \"C\" JNIEXPORT int\n-JVM_handle_linux_signal(int sig,\n-                        siginfo_t* info,\n-                        void* ucVoid,\n-                        int abort_if_unrecognized) {\n-  ucontext_t* uc = (ucontext_t*) ucVoid;\n-\n-  Thread* t = Thread::current_or_null_safe();\n-\n-  \/\/ If crash protection is installed we may longjmp away and no destructors\n-  \/\/ for objects in this scope will be run.\n-  \/\/ So don't use any RAII utilities before crash protection is checked.\n-  os::ThreadCrashProtection::check_crash_protection(sig, t);\n-\n-  \/\/ Note: it's not uncommon that JNI code uses signal\/sigset to install\n-  \/\/ then restore certain signal handler (e.g. to temporarily block SIGPIPE,\n-  \/\/ or have a SIGILL handler when detecting CPU type). When that happens,\n-  \/\/ JVM_handle_linux_signal() might be invoked with junk info\/ucVoid. To\n-  \/\/ avoid unnecessary crash when libjsig is not preloaded, try handle signals\n-  \/\/ that do not require siginfo\/ucontext first.\n-\n-  if (sig == SIGPIPE || sig == SIGXFSZ) {\n-    \/\/ allow chained handler to go first\n-    if (PosixSignals::chained_handler(sig, info, ucVoid)) {\n-      return true;\n-    } else {\n-      \/\/ Ignoring SIGPIPE\/SIGXFSZ - see bugs 4229104 or 6499219\n-      return true;\n-    }\n-  }\n+bool PosixSignals::pd_hotspot_signal_handler(int sig, siginfo_t* info,\n+                                             ucontext_t* uc, JavaThread* thread) {\n@@ -198,20 +170,0 @@\n-#ifdef CAN_SHOW_REGISTERS_ON_ASSERT\n-  if ((sig == SIGSEGV || sig == SIGBUS) && info != NULL && info->si_addr == g_assert_poison) {\n-    if (handle_assert_poison_fault(ucVoid, info->si_addr)) {\n-      return 1;\n-    }\n-  }\n-#endif\n-\n-  JavaThread* thread = NULL;\n-  VMThread* vmthread = NULL;\n-  if (PosixSignals::are_signal_handlers_installed()) {\n-    if (t != NULL ){\n-      if(t->is_Java_thread()) {\n-        thread = t->as_Java_thread();\n-      }\n-      else if(t->is_VM_thread()){\n-        vmthread = (VMThread *)t;\n-      }\n-    }\n-  }\n@@ -238,1 +190,1 @@\n-      return 1;\n+      return true;\n@@ -253,1 +205,1 @@\n-          return 1; \/\/ continue\n+          return true; \/\/ continue\n@@ -296,4 +248,1 @@\n-        va_list detail_args;\n-        VMError::report_and_die(INTERNAL_ERROR, msg, detail_msg, detail_args, thread,\n-                                pc, info, ucVoid, NULL, 0, 0);\n-        va_end(detail_args);\n+        return false; \/\/ Fatal error\n@@ -345,21 +294,1 @@\n-  \/\/ signal-chaining\n-  if (PosixSignals::chained_handler(sig, info, ucVoid)) {\n-     return true;\n-  }\n-\n-  if (!abort_if_unrecognized) {\n-    \/\/ caller wants another chance, so give it to him\n-    return false;\n-  }\n-\n-  if (pc == NULL && uc != NULL) {\n-    pc = os::Linux::ucontext_get_pc(uc);\n-  }\n-\n-  \/\/ unmask current signal\n-  sigset_t newset;\n-  sigemptyset(&newset);\n-  sigaddset(&newset, sig);\n-  sigprocmask(SIG_UNBLOCK, &newset, NULL);\n-\n-  VMError::report_and_die(t, sig, pc, info, ucVoid);\n+  return false; \/\/ Mute compiler\n@@ -367,2 +296,0 @@\n-  ShouldNotReachHere();\n-  return true; \/\/ Mute compiler\n","filename":"src\/hotspot\/os_cpu\/linux_aarch64\/os_linux_aarch64.cpp","additions":6,"deletions":79,"binary":false,"changes":85,"status":"modified"},{"patch":"@@ -244,1 +244,0 @@\n-\/\/ Utility functions\n@@ -246,10 +245,2 @@\n-extern \"C\" int JVM_handle_linux_signal(int sig, siginfo_t* info,\n-                                       void* ucVoid, int abort_if_unrecognized) {\n-  ucontext_t* uc = (ucontext_t*) ucVoid;\n-\n-  Thread* t = Thread::current_or_null_safe();\n-\n-  \/\/ If crash protection is installed we may longjmp away and no destructors\n-  \/\/ for objects in this scope will be run.\n-  \/\/ So don't use any RAII utilities before crash protection is checked.\n-  os::ThreadCrashProtection::check_crash_protection(sig, t);\n+bool PosixSignals::pd_hotspot_signal_handler(int sig, siginfo_t* info,\n+                                             ucontext_t* uc, JavaThread* thread) {\n@@ -269,38 +260,0 @@\n-  \/\/ Note: it's not uncommon that JNI code uses signal\/sigset to install\n-  \/\/ then restore certain signal handler (e.g. to temporarily block SIGPIPE,\n-  \/\/ or have a SIGILL handler when detecting CPU type). When that happens,\n-  \/\/ JVM_handle_linux_signal() might be invoked with junk info\/ucVoid. To\n-  \/\/ avoid unnecessary crash when libjsig is not preloaded, try handle signals\n-  \/\/ that do not require siginfo\/ucontext first.\n-\n-  if (sig == SIGPIPE || sig == SIGXFSZ) {\n-    \/\/ allow chained handler to go first\n-    if (PosixSignals::chained_handler(sig, info, ucVoid)) {\n-      return true;\n-    } else {\n-      \/\/ Ignoring SIGPIPE\/SIGXFSZ - see bugs 4229104 or 6499219\n-      return true;\n-    }\n-  }\n-\n-#ifdef CAN_SHOW_REGISTERS_ON_ASSERT\n-  if ((sig == SIGSEGV || sig == SIGBUS) && info != NULL && info->si_addr == g_assert_poison) {\n-    if (handle_assert_poison_fault(ucVoid, info->si_addr)) {\n-      return 1;\n-    }\n-  }\n-#endif\n-\n-  JavaThread* thread = NULL;\n-  VMThread* vmthread = NULL;\n-  if (PosixSignals::are_signal_handlers_installed()) {\n-    if (t != NULL ){\n-      if(t->is_Java_thread()) {\n-        thread = t->as_Java_thread();\n-      }\n-      else if(t->is_VM_thread()){\n-        vmthread = (VMThread *)t;\n-      }\n-    }\n-  }\n-\n@@ -320,1 +273,1 @@\n-        return 1;\n+        return true;\n@@ -334,1 +287,1 @@\n-            return 1;\n+            return true;\n@@ -350,1 +303,1 @@\n-               return 1;\n+               return true;\n@@ -443,23 +396,0 @@\n-  \/\/ signal-chaining\n-  if (PosixSignals::chained_handler(sig, info, ucVoid)) {\n-     return true;\n-  }\n-\n-  if (!abort_if_unrecognized) {\n-    \/\/ caller wants another chance, so give it to him\n-    return false;\n-  }\n-\n-  if (pc == NULL && uc != NULL) {\n-    pc = os::Linux::ucontext_get_pc(uc);\n-  }\n-\n-  \/\/ unmask current signal\n-  sigset_t newset;\n-  sigemptyset(&newset);\n-  sigaddset(&newset, sig);\n-  sigprocmask(SIG_UNBLOCK, &newset, NULL);\n-\n-  VMError::report_and_die(t, sig, pc, info, ucVoid);\n-\n-  ShouldNotReachHere();\n@@ -467,0 +397,1 @@\n+\n","filename":"src\/hotspot\/os_cpu\/linux_arm\/os_linux_arm.cpp","additions":6,"deletions":75,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -191,26 +191,2 @@\n-\/\/ Utility functions\n-\n-extern \"C\" JNIEXPORT int\n-JVM_handle_linux_signal(int sig,\n-                        siginfo_t* info,\n-                        void* ucVoid,\n-                        int abort_if_unrecognized) {\n-  ucontext_t* uc = (ucontext_t*) ucVoid;\n-\n-  Thread* t = Thread::current_or_null_safe();\n-\n-  \/\/ Note: it's not uncommon that JNI code uses signal\/sigset to install\n-  \/\/ then restore certain signal handler (e.g. to temporarily block SIGPIPE,\n-  \/\/ or have a SIGILL handler when detecting CPU type). When that happens,\n-  \/\/ JVM_handle_linux_signal() might be invoked with junk info\/ucVoid. To\n-  \/\/ avoid unnecessary crash when libjsig is not preloaded, try handle signals\n-  \/\/ that do not require siginfo\/ucontext first.\n-\n-  if (sig == SIGPIPE || sig == SIGXFSZ) {\n-    if (PosixSignals::chained_handler(sig, info, ucVoid)) {\n-      return true;\n-    } else {\n-      \/\/ Ignoring SIGPIPE - see bugs 4229104\n-      return true;\n-    }\n-  }\n+bool PosixSignals::pd_hotspot_signal_handler(int sig, siginfo_t* info,\n+                                             ucontext_t* uc, JavaThread* thread) {\n@@ -240,20 +216,0 @@\n-#ifdef CAN_SHOW_REGISTERS_ON_ASSERT\n-  if ((sig == SIGSEGV || sig == SIGBUS) && info != NULL && info->si_addr == g_assert_poison) {\n-    if (handle_assert_poison_fault(ucVoid, info->si_addr)) {\n-      return 1;\n-    }\n-  }\n-#endif\n-\n-  JavaThread* thread = NULL;\n-  VMThread* vmthread = NULL;\n-  if (PosixSignals::are_signal_handlers_installed()) {\n-    if (t != NULL) {\n-      if(t->is_Java_thread()) {\n-        thread = t->as_Java_thread();\n-      } else if(t->is_VM_thread()) {\n-        vmthread = (VMThread *)t;\n-      }\n-    }\n-  }\n-\n@@ -300,1 +256,1 @@\n-          return 1; \/\/ continue\n+          return true; \/\/ continue\n@@ -309,11 +265,0 @@\n-      \/\/ A VM-related SIGILL may only occur if we are not in the zero page.\n-      \/\/ On AIX, we get a SIGILL if we jump to 0x0 or to somewhere else\n-      \/\/ in the zero page, because it is filled with 0x0. We ignore\n-      \/\/ explicit SIGILLs in the zero page.\n-      if (sig == SIGILL && (pc < (address) 0x200)) {\n-        if (TraceTraps) {\n-          tty->print_raw_cr(\"SIGILL happened inside zero page.\");\n-        }\n-        goto report_and_die;\n-      }\n-\n@@ -407,4 +352,1 @@\n-        va_list detail_args;\n-        VMError::report_and_die(INTERNAL_ERROR, msg, detail_msg, detail_args, thread,\n-                                pc, info, ucVoid, NULL, 0, 0);\n-        va_end(detail_args);\n+        return false; \/\/ Fatal error\n@@ -468,24 +410,0 @@\n-  \/\/ signal-chaining\n-  if (PosixSignals::chained_handler(sig, info, ucVoid)) {\n-    return true;\n-  }\n-\n-  if (!abort_if_unrecognized) {\n-    \/\/ caller wants another chance, so give it to him\n-    return false;\n-  }\n-\n-  if (pc == NULL && uc != NULL) {\n-    pc = os::Linux::ucontext_get_pc(uc);\n-  }\n-\n-report_and_die:\n-  \/\/ unmask current signal\n-  sigset_t newset;\n-  sigemptyset(&newset);\n-  sigaddset(&newset, sig);\n-  sigprocmask(SIG_UNBLOCK, &newset, NULL);\n-\n-  VMError::report_and_die(t, sig, pc, info, ucVoid);\n-\n-  ShouldNotReachHere();\n@@ -493,0 +411,1 @@\n+\n","filename":"src\/hotspot\/os_cpu\/linux_ppc\/os_linux_ppc.cpp","additions":5,"deletions":86,"binary":false,"changes":91,"status":"modified"},{"patch":"@@ -207,53 +207,2 @@\n-\/\/ Utility functions\n-\n-extern \"C\" JNIEXPORT int\n-JVM_handle_linux_signal(int sig,\n-                        siginfo_t* info,\n-                        void* ucVoid,\n-                        int abort_if_unrecognized) {\n-  ucontext_t* uc = (ucontext_t*) ucVoid;\n-\n-  Thread* t = Thread::current_or_null_safe();\n-\n-  \/\/ If crash protection is installed we may longjmp away and no destructors\n-  \/\/ for objects in this scope will be run.\n-  \/\/ So don't use any RAII utilities before crash protection is checked.\n-  os::ThreadCrashProtection::check_crash_protection(sig, t);\n-\n-  \/\/ Note: it's not uncommon that JNI code uses signal\/sigset to install\n-  \/\/ then restore certain signal handler (e.g. to temporarily block SIGPIPE,\n-  \/\/ or have a SIGILL handler when detecting CPU type). When that happens,\n-  \/\/ JVM_handle_linux_signal() might be invoked with junk info\/ucVoid. To\n-  \/\/ avoid unnecessary crash when libjsig is not preloaded, try handle signals\n-  \/\/ that do not require siginfo\/ucontext first.\n-\n-  if (sig == SIGPIPE || sig == SIGXFSZ) {\n-    if (PosixSignals::chained_handler(sig, info, ucVoid)) {\n-      return true;\n-    } else {\n-      if (PrintMiscellaneous && (WizardMode || Verbose)) {\n-        warning(\"Ignoring SIGPIPE - see bug 4229104\");\n-      }\n-      return true;\n-    }\n-  }\n-\n-#ifdef CAN_SHOW_REGISTERS_ON_ASSERT\n-  if ((sig == SIGSEGV || sig == SIGBUS) && info != NULL && info->si_addr == g_assert_poison) {\n-    if (handle_assert_poison_fault(ucVoid, info->si_addr)) {\n-      return 1;\n-    }\n-  }\n-#endif\n-\n-  JavaThread* thread = NULL;\n-  VMThread* vmthread = NULL;\n-  if (PosixSignals::are_signal_handlers_installed()) {\n-    if (t != NULL) {\n-      if(t->is_Java_thread()) {\n-        thread = t->as_Java_thread();\n-      } else if(t->is_VM_thread()) {\n-        vmthread = (VMThread *)t;\n-      }\n-    }\n-  }\n+bool PosixSignals::pd_hotspot_signal_handler(int sig, siginfo_t* info,\n+                                             ucontext_t* uc, JavaThread* thread) {\n@@ -297,1 +246,1 @@\n-          return 1; \/\/ continue\n+          return true; \/\/ continue\n@@ -421,31 +370,0 @@\n-  \/\/ signal-chaining\n-  if (PosixSignals::chained_handler(sig, info, ucVoid)) {\n-    return true;\n-  }\n-\n-  if (!abort_if_unrecognized) {\n-    \/\/ caller wants another chance, so give it to him\n-    return false;\n-  }\n-\n-  if (pc == NULL && uc != NULL) {\n-    pc = os::Linux::ucontext_get_pc(uc);\n-  }\n-\n-  \/\/ unmask current signal\n-  sigset_t newset;\n-  sigemptyset(&newset);\n-  sigaddset(&newset, sig);\n-  sigprocmask(SIG_UNBLOCK, &newset, NULL);\n-\n-  \/\/ Hand down correct pc for SIGILL, SIGFPE. pc from context\n-  \/\/ usually points to the instruction after the failing instruction.\n-  \/\/ Note: this should be combined with the trap_pc handling above,\n-  \/\/ because it handles the same issue.\n-  if (sig == SIGILL || sig == SIGFPE) {\n-    pc = (address)info->si_addr;\n-  }\n-\n-  VMError::report_and_die(t, sig, pc, info, ucVoid);\n-\n-  ShouldNotReachHere();\n@@ -453,0 +371,1 @@\n+\n","filename":"src\/hotspot\/os_cpu\/linux_s390\/os_linux_s390.cpp","additions":4,"deletions":85,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -203,30 +203,2 @@\n-extern \"C\" JNIEXPORT int\n-JVM_handle_linux_signal(int sig,\n-                        siginfo_t* info,\n-                        void* ucVoid,\n-                        int abort_if_unrecognized) {\n-  ucontext_t* uc = (ucontext_t*) ucVoid;\n-\n-  Thread* t = Thread::current_or_null_safe();\n-\n-  \/\/ If crash protection is installed we may longjmp away and no destructors\n-  \/\/ for objects in this scope will be run.\n-  \/\/ So don't use any RAII utilities before crash protection is checked.\n-  os::ThreadCrashProtection::check_crash_protection(sig, t);\n-\n-  \/\/ Note: it's not uncommon that JNI code uses signal\/sigset to install\n-  \/\/ then restore certain signal handler (e.g. to temporarily block SIGPIPE,\n-  \/\/ or have a SIGILL handler when detecting CPU type). When that happens,\n-  \/\/ JVM_handle_linux_signal() might be invoked with junk info\/ucVoid. To\n-  \/\/ avoid unnecessary crash when libjsig is not preloaded, try handle signals\n-  \/\/ that do not require siginfo\/ucontext first.\n-\n-  if (sig == SIGPIPE || sig == SIGXFSZ) {\n-    \/\/ allow chained handler to go first\n-    if (PosixSignals::chained_handler(sig, info, ucVoid)) {\n-      return true;\n-    } else {\n-      \/\/ Ignoring SIGPIPE\/SIGXFSZ - see bugs 4229104 or 6499219\n-      return true;\n-    }\n-  }\n+bool PosixSignals::pd_hotspot_signal_handler(int sig, siginfo_t* info,\n+                                             ucontext_t* uc, JavaThread* thread) {\n@@ -234,21 +206,1 @@\n-#ifdef CAN_SHOW_REGISTERS_ON_ASSERT\n-  if ((sig == SIGSEGV || sig == SIGBUS) && info != NULL && info->si_addr == g_assert_poison) {\n-    if (handle_assert_poison_fault(ucVoid, info->si_addr)) {\n-      return 1;\n-    }\n-  }\n-#endif\n-\n-  JavaThread* thread = NULL;\n-  VMThread* vmthread = NULL;\n-  if (PosixSignals::are_signal_handlers_installed()) {\n-    if (t != NULL ){\n-      if(t->is_Java_thread()) {\n-        thread = t->as_Java_thread();\n-      }\n-      else if(t->is_VM_thread()){\n-        vmthread = (VMThread *)t;\n-      }\n-    }\n-  }\n-\/*\n+  \/*\n@@ -274,1 +226,1 @@\n-      return 1;\n+      return true;\n@@ -295,1 +247,1 @@\n-          return 1; \/\/ continue\n+          return true; \/\/ continue\n@@ -472,24 +424,1 @@\n-  \/\/ signal-chaining\n-  if (PosixSignals::chained_handler(sig, info, ucVoid)) {\n-     return true;\n-  }\n-\n-  if (!abort_if_unrecognized) {\n-    \/\/ caller wants another chance, so give it to him\n-    return false;\n-  }\n-\n-  if (pc == NULL && uc != NULL) {\n-    pc = os::Linux::ucontext_get_pc(uc);\n-  }\n-\n-  \/\/ unmask current signal\n-  sigset_t newset;\n-  sigemptyset(&newset);\n-  sigaddset(&newset, sig);\n-  sigprocmask(SIG_UNBLOCK, &newset, NULL);\n-\n-  VMError::report_and_die(t, sig, pc, info, ucVoid);\n-\n-  ShouldNotReachHere();\n-  return true; \/\/ Mute compiler\n+  return false;\n","filename":"src\/hotspot\/os_cpu\/linux_x86\/os_linux_x86.cpp","additions":6,"deletions":77,"binary":false,"changes":83,"status":"modified"},{"patch":"@@ -114,8 +114,2 @@\n-extern \"C\" JNIEXPORT int\n-JVM_handle_linux_signal(int sig,\n-                        siginfo_t* info,\n-                        void* ucVoid,\n-                        int abort_if_unrecognized) {\n-  ucontext_t* uc = (ucontext_t*) ucVoid;\n-\n-  Thread* t = Thread::current_or_null_safe();\n+bool PosixSignals::pd_hotspot_signal_handler(int sig, siginfo_t* info,\n+                                             ucontext_t* uc, JavaThread* thread) {\n@@ -131,31 +125,0 @@\n-  \/\/ Note: it's not uncommon that JNI code uses signal\/sigset to\n-  \/\/ install then restore certain signal handler (e.g. to temporarily\n-  \/\/ block SIGPIPE, or have a SIGILL handler when detecting CPU\n-  \/\/ type). When that happens, JVM_handle_linux_signal() might be\n-  \/\/ invoked with junk info\/ucVoid. To avoid unnecessary crash when\n-  \/\/ libjsig is not preloaded, try handle signals that do not require\n-  \/\/ siginfo\/ucontext first.\n-\n-  if (sig == SIGPIPE || sig == SIGXFSZ) {\n-    \/\/ allow chained handler to go first\n-    if (PosixSignals::chained_handler(sig, info, ucVoid)) {\n-      return true;\n-    } else {\n-      \/\/ Ignoring SIGPIPE\/SIGXFSZ - see bugs 4229104 or 6499219\n-      return true;\n-    }\n-  }\n-\n-  JavaThread* thread = NULL;\n-  VMThread* vmthread = NULL;\n-  if (PosixSignals::are_signal_handlers_installed()) {\n-    if (t != NULL ){\n-      if(t->is_Java_thread()) {\n-        thread = t->as_Java_thread();\n-      }\n-      else if(t->is_VM_thread()){\n-        vmthread = (VMThread *)t;\n-      }\n-    }\n-  }\n-\n@@ -219,34 +182,1 @@\n-  \/\/ signal-chaining\n-  if (PosixSignals::chained_handler(sig, info, ucVoid)) {\n-     return true;\n-  }\n-\n-  if (!abort_if_unrecognized) {\n-    \/\/ caller wants another chance, so give it to him\n-    return false;\n-  }\n-\n-#ifndef PRODUCT\n-  if (sig == SIGSEGV) {\n-    fatal(\"\\n#\"\n-          \"\\n#    \/--------------------\\\\\"\n-          \"\\n#    | segmentation fault |\"\n-          \"\\n#    \\\\---\\\\ \/--------------\/\"\n-          \"\\n#        \/\"\n-          \"\\n#    [-]        |\\\\_\/|    \"\n-          \"\\n#    (+)=C      |o o|__  \"\n-          \"\\n#    | |        =-*-=__\\\\ \"\n-          \"\\n#    OOO        c_c_(___)\");\n-  }\n-#endif \/\/ !PRODUCT\n-\n-  char buf[128];\n-  char exc_buf[32];\n-\n-  if (os::exception_name(sig, exc_buf, sizeof(exc_buf))) {\n-    bool sent_by_kill = (info != NULL && os::signal_sent_by_kill(info));\n-    snprintf(buf, sizeof(buf), \"caught unhandled signal: %s %s\",\n-             exc_buf, sent_by_kill ? \"(sent by kill)\" : \"\");\n-  } else {\n-    snprintf(buf, sizeof(buf), \"caught unhandled signal: %d\", sig);\n-  }\n+  return false; \/\/ Fatal error\n@@ -254,6 +184,0 @@\n-\/\/ Silence -Wformat-security warning for fatal()\n-PRAGMA_DIAG_PUSH\n-PRAGMA_FORMAT_NONLITERAL_IGNORED\n-  fatal(buf);\n-PRAGMA_DIAG_POP\n-  return true; \/\/ silence compiler warnings\n","filename":"src\/hotspot\/os_cpu\/linux_zero\/os_linux_zero.cpp","additions":3,"deletions":79,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -761,1 +761,1 @@\n-          \"Do not complain if the application installs signal handlers \"    \\\n+          \"Application will install primary signal handlers for the JVM \"   \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -119,3 +119,0 @@\n-  static void report_and_die(Thread* thread, unsigned int sig, address pc, void* siginfo,\n-                             void* context, const char* detail_fmt, ...) ATTRIBUTE_PRINTF(6, 7);\n-\n@@ -149,0 +146,3 @@\n+  static void report_and_die(Thread* thread, unsigned int sig, address pc, void* siginfo,\n+                             void* context, const char* detail_fmt, ...) ATTRIBUTE_PRINTF(6, 7);\n+\n","filename":"src\/hotspot\/share\/utilities\/vmError.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"}]}