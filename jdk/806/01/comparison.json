{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,1 @@\n+  static size_t array_size(size_t length);\n@@ -37,0 +38,2 @@\n+  static size_t size(size_t length);\n+  static void* alloc(void* placement, size_t length);\n","filename":"src\/hotspot\/share\/gc\/z\/zAttachedArray.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,0 +36,16 @@\n+template <typename ObjectT, typename ArrayT>\n+inline size_t ZAttachedArray<ObjectT, ArrayT>::array_size(size_t length) {\n+  return sizeof(ArrayT) * length;\n+}\n+\n+template <typename ObjectT, typename ArrayT>\n+inline size_t ZAttachedArray<ObjectT, ArrayT>::size(size_t length) {\n+  return object_size() + array_size(length);\n+}\n+\n+template <typename ObjectT, typename ArrayT>\n+inline void* ZAttachedArray<ObjectT, ArrayT>::alloc(void* placement, size_t length) {\n+  ::new (reinterpret_cast<char*>(placement) + object_size()) ArrayT[length];\n+  return placement;\n+}\n+\n@@ -38,4 +54,2 @@\n-  const size_t array_size = sizeof(ArrayT) * length;\n-  char* const addr = AllocateHeap(object_size() + array_size, mtGC);\n-  ::new (addr + object_size()) ArrayT[length];\n-  return addr;\n+  void* const placement = AllocateHeap(size(length), mtGC);\n+  return alloc(placement, length);\n","filename":"src\/hotspot\/share\/gc\/z\/zAttachedArray.inline.hpp","additions":19,"deletions":5,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-#include \"gc\/z\/zPage.inline.hpp\"\n@@ -28,23 +27,0 @@\n-#include \"utilities\/powerOfTwo.hpp\"\n-\n-ZForwarding* ZForwarding::create(ZPage* page) {\n-  \/\/ Allocate table for linear probing. The size of the table must be\n-  \/\/ a power of two to allow for quick and inexpensive indexing\/masking.\n-  \/\/ The table is sized to have a load factor of 50%, i.e. sized to have\n-  \/\/ double the number of entries actually inserted.\n-  assert(page->live_objects() > 0, \"Invalid value\");\n-  const size_t nentries = round_up_power_of_2(page->live_objects() * 2);\n-  return ::new (AttachedArray::alloc(nentries)) ZForwarding(page, nentries);\n-}\n-\n-void ZForwarding::destroy(ZForwarding* forwarding) {\n-  AttachedArray::free(forwarding);\n-}\n-\n-ZForwarding::ZForwarding(ZPage* page, size_t nentries) :\n-    _virtual(page->virtual_memory()),\n-    _object_alignment_shift(page->object_alignment_shift()),\n-    _entries(nentries),\n-    _page(page),\n-    _refcount(1),\n-    _pinned(false) {}\n","filename":"src\/hotspot\/share\/gc\/z\/zForwarding.cpp","additions":0,"deletions":24,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+class ZForwardingAllocator;\n@@ -60,2 +61,1 @@\n-  static ZForwarding* create(ZPage* page);\n-  static void destroy(ZForwarding* forwarding);\n+  static ZForwarding* alloc(ZForwardingAllocator* allocator, ZPage* page);\n","filename":"src\/hotspot\/share\/gc\/z\/zForwarding.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"gc\/z\/zForwardingAllocator.inline.hpp\"\n@@ -31,0 +32,1 @@\n+#include \"gc\/z\/zPage.inline.hpp\"\n@@ -35,0 +37,14 @@\n+inline ZForwarding* ZForwarding::alloc(ZForwardingAllocator* allocator, ZPage* page) {\n+  const size_t nentries = page->forwarding_entries();\n+  void* const placement = allocator->alloc(AttachedArray::size(nentries));\n+  return ::new (AttachedArray::alloc(placement, nentries)) ZForwarding(page, nentries);\n+}\n+\n+inline ZForwarding::ZForwarding(ZPage* page, size_t nentries) :\n+    _virtual(page->virtual_memory()),\n+    _object_alignment_shift(page->object_alignment_shift()),\n+    _entries(nentries),\n+    _page(page),\n+    _refcount(1),\n+    _pinned(false) {}\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zForwarding.inline.hpp","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -0,0 +1,40 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"gc\/z\/zForwardingAllocator.hpp\"\n+#include \"memory\/allocation.inline.hpp\"\n+\n+ZForwardingAllocator::ZForwardingAllocator() :\n+    _start(NULL),\n+    _end(NULL),\n+    _top(NULL) {}\n+\n+ZForwardingAllocator::~ZForwardingAllocator() {\n+  FREE_C_HEAP_ARRAY(char, _start);\n+}\n+\n+void ZForwardingAllocator::reset(size_t size) {\n+  _start = _top = REALLOC_C_HEAP_ARRAY(char, _start, size, mtGC);\n+  _end = _start + size;\n+}\n","filename":"src\/hotspot\/share\/gc\/z\/zForwardingAllocator.cpp","additions":40,"deletions":0,"binary":false,"changes":40,"status":"added"},{"patch":"@@ -0,0 +1,45 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifndef SHARE_GC_Z_ZFORWARDINGALLOCATOR_HPP\n+#define SHARE_GC_Z_ZFORWARDINGALLOCATOR_HPP\n+\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+class ZForwardingAllocator {\n+private:\n+  char* _start;\n+  char* _end;\n+  char* _top;\n+\n+public:\n+  ZForwardingAllocator();\n+  ~ZForwardingAllocator();\n+\n+  void reset(size_t size);\n+  size_t size() const;\n+\n+  void* alloc(size_t size);\n+};\n+\n+#endif \/\/ SHARE_GC_Z_ZFORWARDINGALLOCATOR_HPP\n","filename":"src\/hotspot\/share\/gc\/z\/zForwardingAllocator.hpp","additions":45,"deletions":0,"binary":false,"changes":45,"status":"added"},{"patch":"@@ -0,0 +1,55 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifndef SHARE_GC_Z_ZFORWARDINGALLOCATOR_INLINE_HPP\n+#define SHARE_GC_Z_ZFORWARDINGALLOCATOR_INLINE_HPP\n+\n+#include \"gc\/z\/zForwardingAllocator.hpp\"\n+#include \"runtime\/atomic.hpp\"\n+\n+inline size_t ZForwardingAllocator::size() const {\n+  return _end - _start;\n+}\n+\n+inline void* ZForwardingAllocator::alloc(size_t size) {\n+  char* old_top = Atomic::load(&_top);\n+\n+  for (;;) {\n+    char* const new_top = old_top + size;\n+    if (new_top > _end) {\n+      \/\/ Not enough space left\n+      return 0;\n+    }\n+\n+    char* const prev_top = Atomic::cmpxchg(&_top, old_top, new_top);\n+    if (prev_top == old_top) {\n+      \/\/ Success\n+      return old_top;\n+    }\n+\n+    \/\/ Retry\n+    old_top = prev_top;\n+  }\n+}\n+\n+#endif \/\/ SHARE_GC_Z_ZFORWARDINGALLOCATOR_INLINE_HPP\n","filename":"src\/hotspot\/share\/gc\/z\/zForwardingAllocator.inline.hpp","additions":55,"deletions":0,"binary":false,"changes":55,"status":"added"},{"patch":"@@ -1,48 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include \"precompiled.hpp\"\n-#include \"gc\/z\/zForwarding.inline.hpp\"\n-#include \"gc\/z\/zForwardingTable.inline.hpp\"\n-#include \"gc\/z\/zGlobals.hpp\"\n-#include \"gc\/z\/zGranuleMap.inline.hpp\"\n-#include \"utilities\/debug.hpp\"\n-\n-ZForwardingTable::ZForwardingTable() :\n-    _map(ZAddressOffsetMax) {}\n-\n-void ZForwardingTable::insert(ZForwarding* forwarding) {\n-  const uintptr_t offset = forwarding->start();\n-  const size_t size = forwarding->size();\n-\n-  assert(_map.get(offset) == NULL, \"Invalid entry\");\n-  _map.put(offset, size, forwarding);\n-}\n-\n-void ZForwardingTable::remove(ZForwarding* forwarding) {\n-  const uintptr_t offset = forwarding->start();\n-  const size_t size = forwarding->size();\n-\n-  assert(_map.get(offset) == forwarding, \"Invalid entry\");\n-  _map.put(offset, size, NULL);\n-}\n","filename":"src\/hotspot\/share\/gc\/z\/zForwardingTable.cpp","additions":0,"deletions":48,"binary":false,"changes":48,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+#include \"gc\/z\/zForwarding.inline.hpp\"\n@@ -29,0 +30,1 @@\n+#include \"gc\/z\/zGlobals.hpp\"\n@@ -30,0 +32,4 @@\n+#include \"utilities\/debug.hpp\"\n+\n+inline ZForwardingTable::ZForwardingTable() :\n+    _map(ZAddressOffsetMax) {}\n@@ -36,0 +42,16 @@\n+inline void ZForwardingTable::insert(ZForwarding* forwarding) {\n+  const uintptr_t offset = forwarding->start();\n+  const size_t size = forwarding->size();\n+\n+  assert(_map.get(offset) == NULL, \"Invalid entry\");\n+  _map.put(offset, size, forwarding);\n+}\n+\n+inline void ZForwardingTable::remove(ZForwarding* forwarding) {\n+  const uintptr_t offset = forwarding->start();\n+  const size_t size = forwarding->size();\n+\n+  assert(_map.get(offset) == forwarding, \"Invalid entry\");\n+  _map.put(offset, size, NULL);\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zForwardingTable.inline.hpp","additions":23,"deletions":1,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"gc\/z\/zArray.inline.hpp\"\n@@ -68,1 +69,1 @@\n-    _relocation_set(),\n+    _relocation_set(&_workers),\n@@ -223,0 +224,11 @@\n+void ZHeap::free_pages(const ZArray<ZPage*>* pages, bool reclaimed) {\n+  \/\/ Remove page table entries\n+  ZArrayIterator<ZPage*> iter(pages);\n+  for (ZPage* page; iter.next(&page);) {\n+    _page_table.remove(page);\n+  }\n+\n+  \/\/ Free pages\n+  _page_allocator.free_pages(pages, reclaimed);\n+}\n+\n@@ -352,0 +364,10 @@\n+void ZHeap::free_garbage_pages(ZRelocationSetSelector* selector, int bulk) {\n+  \/\/ Freeing garbage pages in bulk is an optimization to avoid grabbing\n+  \/\/ the page allocator lock, and trying to satisfy stalled allocations\n+  \/\/ too frequently.\n+  if (selector->should_free_garbage_pages(bulk)) {\n+    free_pages(selector->garbage_pages(), true \/* reclaimed *\/);\n+    selector->clear_garbage_pages();\n+  }\n+}\n+\n@@ -372,2 +394,2 @@\n-      \/\/ Reclaim page immediately\n-      free_page(page, true \/* reclaimed *\/);\n+      \/\/ Reclaim garbage pages in bulk\n+      free_garbage_pages(&selector, 64 \/* bulk *\/);\n@@ -377,0 +399,3 @@\n+  \/\/ Reclaim remaining garbage pages\n+  free_garbage_pages(&selector, 0 \/* bulk *\/);\n+\n@@ -380,2 +405,5 @@\n-  \/\/ Select pages to relocate\n-  selector.select(&_relocation_set);\n+  \/\/ Select relocation set\n+  selector.select();\n+\n+  \/\/ Install relocation set\n+  _relocation_set.install(&selector);\n","filename":"src\/hotspot\/share\/gc\/z\/zHeap.cpp","additions":33,"deletions":5,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"gc\/z\/zArray.hpp\"\n@@ -43,0 +44,1 @@\n+class ZRelocationSetSelector;\n@@ -66,0 +68,2 @@\n+  void free_garbage_pages(ZRelocationSetSelector* selector, int bulk);\n+\n@@ -113,0 +117,1 @@\n+  void free_pages(const ZArray<ZPage*>* pages, bool reclaimed);\n","filename":"src\/hotspot\/share\/gc\/z\/zHeap.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -101,0 +101,1 @@\n+  uint32_t forwarding_entries() const;\n","filename":"src\/hotspot\/share\/gc\/z\/zPage.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+#include \"utilities\/powerOfTwo.hpp\"\n@@ -215,0 +216,12 @@\n+inline uint32_t ZPage::forwarding_entries() const {\n+  assert(live_objects() > 0, \"Invalid value\");\n+\n+  \/\/ The number returned by the function is used to size the hash table of\n+  \/\/ forwarding entries for this page. This hash table uses linear probing.\n+  \/\/ The size of the table must be a power of two to allow for quick and\n+  \/\/ inexpensive indexing\/masking. The table is also sized to have a load\n+  \/\/ factor of 50%, i.e. sized to have double the number of entries actually\n+  \/\/ inserted, to allow for good lookup\/insert performance.\n+  return round_up_power_of_2(live_objects() * 2);\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zPage.inline.hpp","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"gc\/z\/zArray.inline.hpp\"\n@@ -751,0 +752,13 @@\n+void ZPageAllocator::free_pages(const ZArray<ZPage*>* pages, bool reclaimed) {\n+  ZLocker<ZLock> locker(&_lock);\n+\n+  \/\/ Free pages\n+  ZArrayIterator<ZPage*> iter(pages);\n+  for (ZPage* page; iter.next(&page);) {\n+    free_page_inner(page, reclaimed);\n+  }\n+\n+  \/\/ Try satisfy stalled allocations\n+  satisfy_stalled();\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zPageAllocator.cpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"gc\/z\/zArray.hpp\"\n@@ -127,0 +128,1 @@\n+  void free_pages(const ZArray<ZPage*>* pages, bool reclaimed);\n","filename":"src\/hotspot\/share\/gc\/z\/zPageAllocator.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,1 +25,3 @@\n-#include \"gc\/z\/zForwarding.hpp\"\n+#include \"gc\/z\/zArray.inline.hpp\"\n+#include \"gc\/z\/zForwarding.inline.hpp\"\n+#include \"gc\/z\/zForwardingAllocator.inline.hpp\"\n@@ -27,1 +29,5 @@\n-#include \"memory\/allocation.hpp\"\n+#include \"gc\/z\/zRelocationSetSelector.inline.hpp\"\n+#include \"gc\/z\/zStat.hpp\"\n+#include \"gc\/z\/zTask.hpp\"\n+#include \"gc\/z\/zWorkers.hpp\"\n+#include \"runtime\/atomic.hpp\"\n@@ -29,3 +35,40 @@\n-ZRelocationSet::ZRelocationSet() :\n-    _forwardings(NULL),\n-    _nforwardings(0) {}\n+class ZRelocationSetInstallTask : public ZTask {\n+private:\n+  ZForwardingAllocator* const    _allocator;\n+  ZForwarding**                  _forwardings;\n+  const size_t                   _nforwardings;\n+  ZArrayParallelIterator<ZPage*> _small_iter;\n+  ZArrayParallelIterator<ZPage*> _medium_iter;\n+  volatile size_t                _small_next;\n+  volatile size_t                _medium_next;\n+\n+  void install(ZForwarding* forwarding, volatile size_t* next) {\n+    const size_t index = Atomic::fetch_and_add(next, 1u);\n+    _forwardings[index] = forwarding;\n+  }\n+\n+  void install_small(ZForwarding* forwarding) {\n+    install(forwarding, &_small_next);\n+  }\n+\n+  void install_medium(ZForwarding* forwarding) {\n+    install(forwarding, &_medium_next);\n+  }\n+\n+public:\n+  ZRelocationSetInstallTask(ZForwardingAllocator* allocator, const ZRelocationSetSelector* selector) :\n+      ZTask(\"ZRelocationSetInstallTask\"),\n+      _allocator(allocator),\n+      _forwardings(NULL),\n+      _nforwardings(selector->small()->length() + selector->medium()->length()),\n+      _small_iter(selector->small()),\n+      _medium_iter(selector->medium()),\n+      _small_next(selector->medium()->length()),\n+      _medium_next(0) {\n+\n+    \/\/ Reset the allocator to have room for the relocation\n+    \/\/ set, all forwardings, and all forwarding entries.\n+    const size_t relocation_set_size = _nforwardings * sizeof(ZForwarding*);\n+    const size_t forwardings_size = _nforwardings * sizeof(ZForwarding);\n+    const size_t forwarding_entries_size = selector->forwarding_entries() * sizeof(ZForwardingEntry);\n+    _allocator->reset(relocation_set_size + forwardings_size + forwarding_entries_size);\n@@ -33,4 +76,10 @@\n-void ZRelocationSet::populate(ZPage* const* group0, size_t ngroup0,\n-                              ZPage* const* group1, size_t ngroup1) {\n-  _nforwardings = ngroup0 + ngroup1;\n-  _forwardings = REALLOC_C_HEAP_ARRAY(ZForwarding*, _forwardings, _nforwardings, mtGC);\n+    \/\/ Allocate relocation set\n+    _forwardings = new (_allocator->alloc(relocation_set_size)) ZForwarding*[_nforwardings];\n+  }\n+\n+  virtual void work() {\n+    \/\/ Allocate and install forwardings for small pages\n+    for (ZPage* page; _small_iter.next(&page);) {\n+      ZForwarding* const forwarding = ZForwarding::alloc(_allocator, page);\n+      install_small(forwarding);\n+    }\n@@ -38,1 +87,6 @@\n-  size_t j = 0;\n+    \/\/ Allocate and install forwardings for medium pages\n+    for (ZPage* page; _medium_iter.next(&page);) {\n+      ZForwarding* const forwarding = ZForwarding::alloc(_allocator, page);\n+      install_medium(forwarding);\n+    }\n+  }\n@@ -40,3 +94,2 @@\n-  \/\/ Populate group 0\n-  for (size_t i = 0; i < ngroup0; i++) {\n-    _forwardings[j++] = ZForwarding::create(group0[i]);\n+  ZForwarding** forwardings() const {\n+    return _forwardings;\n@@ -45,3 +98,2 @@\n-  \/\/ Populate group 1\n-  for (size_t i = 0; i < ngroup1; i++) {\n-    _forwardings[j++] = ZForwarding::create(group1[i]);\n+  size_t nforwardings() const {\n+    return _nforwardings;\n@@ -49,0 +101,18 @@\n+};\n+\n+ZRelocationSet::ZRelocationSet(ZWorkers* workers) :\n+    _workers(workers),\n+    _allocator(),\n+    _forwardings(NULL),\n+    _nforwardings(0) {}\n+\n+void ZRelocationSet::install(const ZRelocationSetSelector* selector) {\n+  \/\/ Install relocation set\n+  ZRelocationSetInstallTask task(&_allocator, selector);\n+  _workers->run_concurrent(&task);\n+\n+  _forwardings = task.forwardings();\n+  _nforwardings = task.nforwardings();\n+\n+  \/\/ Update statistics\n+  ZStatRelocation::set_at_install_relocation_set(_allocator.size());\n@@ -52,4 +122,1 @@\n-  for (size_t i = 0; i < _nforwardings; i++) {\n-    ZForwarding::destroy(_forwardings[i]);\n-    _forwardings[i] = NULL;\n-  }\n+  _nforwardings = 0;\n","filename":"src\/hotspot\/share\/gc\/z\/zRelocationSet.cpp","additions":88,"deletions":21,"binary":false,"changes":109,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-#include \"memory\/allocation.hpp\"\n+#include \"gc\/z\/zForwardingAllocator.hpp\"\n@@ -31,1 +31,2 @@\n-class ZPage;\n+class ZRelocationSetSelector;\n+class ZWorkers;\n@@ -37,2 +38,4 @@\n-  ZForwarding** _forwardings;\n-  size_t        _nforwardings;\n+  ZWorkers*            _workers;\n+  ZForwardingAllocator _allocator;\n+  ZForwarding**        _forwardings;\n+  size_t               _nforwardings;\n@@ -41,1 +44,1 @@\n-  ZRelocationSet();\n+  ZRelocationSet(ZWorkers* workers);\n@@ -43,2 +46,1 @@\n-  void populate(ZPage* const* group0, size_t ngroup0,\n-                ZPage* const* group1, size_t ngroup1);\n+  void install(const ZRelocationSetSelector* selector);\n","filename":"src\/hotspot\/share\/gc\/z\/zRelocationSet.hpp","additions":9,"deletions":7,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-#include \"gc\/z\/zRelocationSet.hpp\"\n@@ -54,2 +53,1 @@\n-    _sorted_pages(NULL),\n-    _nselected(0),\n+    _forwarding_entries(0),\n@@ -58,29 +56,0 @@\n-ZRelocationSetSelectorGroup::~ZRelocationSetSelectorGroup() {\n-  FREE_C_HEAP_ARRAY(ZPage*, _sorted_pages);\n-}\n-\n-void ZRelocationSetSelectorGroup::register_live_page(ZPage* page) {\n-  const uint8_t type = page->type();\n-  const size_t size = page->size();\n-  const size_t live = page->live_bytes();\n-  const size_t garbage = size - live;\n-\n-  if (garbage > _fragmentation_limit) {\n-    _registered_pages.append(page);\n-  }\n-\n-  _stats._npages++;\n-  _stats._total += size;\n-  _stats._live += live;\n-  _stats._garbage += garbage;\n-}\n-\n-void ZRelocationSetSelectorGroup::register_garbage_page(ZPage* page) {\n-  const size_t size = page->size();\n-\n-  _stats._npages++;\n-  _stats._total += size;\n-  _stats._garbage += size;\n-  _stats._empty += size;\n-}\n-\n@@ -103,1 +72,0 @@\n-  const size_t npages = _registered_pages.length();\n@@ -106,6 +74,1 @@\n-  size_t partitions[npartitions];\n-\n-  \/\/ Allocate destination array\n-  assert(_sorted_pages == NULL, \"Already initialized\");\n-  _sorted_pages = NEW_C_HEAP_ARRAY(ZPage*, npages, mtGC);\n-  debug_only(memset(_sorted_pages, 0, npages * sizeof(ZPage*)));\n+  int partitions[npartitions] = { \/* zero initialize *\/ };\n@@ -114,1 +77,0 @@\n-  memset(partitions, 0, sizeof(partitions));\n@@ -122,1 +84,1 @@\n-  size_t finger = 0;\n+  int finger = 0;\n@@ -124,1 +86,1 @@\n-    const size_t slots = partitions[i];\n+    const int slots = partitions[i];\n@@ -129,0 +91,4 @@\n+  \/\/ Allocate destination array\n+  const int npages = _registered_pages.length();\n+  ZArray<ZPage*> sorted_pages(npages, npages, NULL);\n+\n@@ -133,3 +99,3 @@\n-    const size_t finger = partitions[index]++;\n-    assert(_sorted_pages[finger] == NULL, \"Invalid finger\");\n-    _sorted_pages[finger] = page;\n+    const int finger = partitions[index]++;\n+    assert(sorted_pages.at(finger) == NULL, \"Invalid finger\");\n+    sorted_pages.at_put(finger, page);\n@@ -137,0 +103,2 @@\n+\n+  _registered_pages.swap(&sorted_pages);\n@@ -143,4 +111,6 @@\n-  const size_t npages = _registered_pages.length();\n-  size_t selected_from = 0;\n-  size_t selected_to = 0;\n-  size_t from_size = 0;\n+  const int npages = _registered_pages.length();\n+  int selected_from = 0;\n+  int selected_to = 0;\n+  size_t selected_forwarding_entries = 0;\n+  size_t from_live_bytes = 0;\n+  size_t from_forwarding_entries = 0;\n@@ -150,1 +120,1 @@\n-  for (size_t from = 1; from <= npages; from++) {\n+  for (int from = 1; from <= npages; from++) {\n@@ -152,1 +122,3 @@\n-    from_size += _sorted_pages[from - 1]->live_bytes();\n+    ZPage* const page = _registered_pages.at(from - 1);\n+    from_live_bytes += page->live_bytes();\n+    from_forwarding_entries += page->forwarding_entries();\n@@ -158,1 +130,1 @@\n-    const size_t to = ceil((double)(from_size) \/ (double)(_page_size - _object_size_limit));\n+    const int to = ceil((double)(from_live_bytes) \/ (double)(_page_size - _object_size_limit));\n@@ -164,2 +136,2 @@\n-    const size_t diff_from = from - selected_from;\n-    const size_t diff_to = to - selected_to;\n+    const int diff_from = from - selected_from;\n+    const int diff_to = to - selected_to;\n@@ -170,0 +142,1 @@\n+      selected_forwarding_entries = from_forwarding_entries;\n@@ -172,3 +145,4 @@\n-    log_trace(gc, reloc)(\"Candidate Relocation Set (%s Pages): \"\n-                         SIZE_FORMAT \"->\" SIZE_FORMAT \", %.1f%% relative defragmentation, %s\",\n-                         _name, from, to, diff_reclaimable, (selected_from == from) ? \"Selected\" : \"Rejected\");\n+    log_trace(gc, reloc)(\"Candidate Relocation Set (%s Pages): %d->%d, \"\n+                         \"%.1f%% relative defragmentation, \" SIZE_FORMAT \" forwarding entries, %s\",\n+                         _name, from, to, diff_reclaimable, from_forwarding_entries,\n+                         (selected_from == from) ? \"Selected\" : \"Rejected\");\n@@ -178,1 +152,2 @@\n-  _nselected = selected_from;\n+  _registered_pages.trunc_to(selected_from);\n+  _forwarding_entries = selected_forwarding_entries;\n@@ -184,2 +159,2 @@\n-  log_trace(gc, reloc)(\"Relocation Set (%s Pages): \" SIZE_FORMAT \"->\" SIZE_FORMAT \", \" SIZE_FORMAT \" skipped\",\n-                       _name, selected_from, selected_to, npages - _nselected);\n+  log_trace(gc, reloc)(\"Relocation Set (%s Pages): %d->%d, %d skipped, \" SIZE_FORMAT \" forwarding entries\",\n+                       _name, selected_from, selected_to, npages - selected_from, selected_forwarding_entries);\n@@ -207,25 +182,2 @@\n-    _large(\"Large\", ZPageTypeLarge, 0 \/* page_size *\/, 0 \/* object_size_limit *\/) {}\n-\n-void ZRelocationSetSelector::register_live_page(ZPage* page) {\n-  const uint8_t type = page->type();\n-\n-  if (type == ZPageTypeSmall) {\n-    _small.register_live_page(page);\n-  } else if (type == ZPageTypeMedium) {\n-    _medium.register_live_page(page);\n-  } else {\n-    _large.register_live_page(page);\n-  }\n-}\n-\n-void ZRelocationSetSelector::register_garbage_page(ZPage* page) {\n-  const uint8_t type = page->type();\n-\n-  if (type == ZPageTypeSmall) {\n-    _small.register_garbage_page(page);\n-  } else if (type == ZPageTypeMedium) {\n-    _medium.register_garbage_page(page);\n-  } else {\n-    _large.register_garbage_page(page);\n-  }\n-}\n+    _large(\"Large\", ZPageTypeLarge, 0 \/* page_size *\/, 0 \/* object_size_limit *\/),\n+    _garbage_pages() {}\n@@ -233,1 +185,1 @@\n-void ZRelocationSetSelector::select(ZRelocationSet* relocation_set) {\n+void ZRelocationSetSelector::select() {\n@@ -247,4 +199,0 @@\n-  \/\/ Populate relocation set\n-  relocation_set->populate(_medium.selected(), _medium.nselected(),\n-                           _small.selected(), _small.nselected());\n-\n","filename":"src\/hotspot\/share\/gc\/z\/zRelocationSetSelector.cpp","additions":38,"deletions":90,"binary":false,"changes":128,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-class ZRelocationSet;\n@@ -78,1 +77,0 @@\n-\n@@ -80,2 +78,1 @@\n-  ZPage**                          _sorted_pages;\n-  size_t                           _nselected;\n+  size_t                           _forwarding_entries;\n@@ -94,1 +91,0 @@\n-  ~ZRelocationSetSelectorGroup();\n@@ -100,2 +96,2 @@\n-  ZPage* const* selected() const;\n-  size_t nselected() const;\n+  const ZArray<ZPage*>* selected() const;\n+  size_t forwarding_entries() const;\n@@ -111,0 +107,1 @@\n+  ZArray<ZPage*>              _garbage_pages;\n@@ -122,1 +119,10 @@\n-  void select(ZRelocationSet* relocation_set);\n+\n+  bool should_free_garbage_pages(int bulk) const;\n+  const ZArray<ZPage*>* garbage_pages() const;\n+  void clear_garbage_pages();\n+\n+  void select();\n+\n+  const ZArray<ZPage*>* small() const;\n+  const ZArray<ZPage*>* medium() const;\n+  size_t forwarding_entries() const;\n","filename":"src\/hotspot\/share\/gc\/z\/zRelocationSetSelector.hpp","additions":14,"deletions":8,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+#include \"gc\/z\/zArray.inline.hpp\"\n+#include \"gc\/z\/zPage.inline.hpp\"\n@@ -69,2 +71,27 @@\n-inline ZPage* const* ZRelocationSetSelectorGroup::selected() const {\n-  return _sorted_pages;\n+inline void ZRelocationSetSelectorGroup::register_live_page(ZPage* page) {\n+  const uint8_t type = page->type();\n+  const size_t size = page->size();\n+  const size_t live = page->live_bytes();\n+  const size_t garbage = size - live;\n+\n+  if (garbage > _fragmentation_limit) {\n+    _registered_pages.append(page);\n+  }\n+\n+  _stats._npages++;\n+  _stats._total += size;\n+  _stats._live += live;\n+  _stats._garbage += garbage;\n+}\n+\n+inline void ZRelocationSetSelectorGroup::register_garbage_page(ZPage* page) {\n+  const size_t size = page->size();\n+\n+  _stats._npages++;\n+  _stats._total += size;\n+  _stats._garbage += size;\n+  _stats._empty += size;\n+}\n+\n+inline const ZArray<ZPage*>* ZRelocationSetSelectorGroup::selected() const {\n+  return &_registered_pages;\n@@ -73,2 +100,2 @@\n-inline size_t ZRelocationSetSelectorGroup::nselected() const {\n-  return _nselected;\n+inline size_t ZRelocationSetSelectorGroup::forwarding_entries() const {\n+  return _forwarding_entries;\n@@ -81,0 +108,38 @@\n+inline void ZRelocationSetSelector::register_live_page(ZPage* page) {\n+  const uint8_t type = page->type();\n+\n+  if (type == ZPageTypeSmall) {\n+    _small.register_live_page(page);\n+  } else if (type == ZPageTypeMedium) {\n+    _medium.register_live_page(page);\n+  } else {\n+    _large.register_live_page(page);\n+  }\n+}\n+\n+inline void ZRelocationSetSelector::register_garbage_page(ZPage* page) {\n+  const uint8_t type = page->type();\n+\n+  if (type == ZPageTypeSmall) {\n+    _small.register_garbage_page(page);\n+  } else if (type == ZPageTypeMedium) {\n+    _medium.register_garbage_page(page);\n+  } else {\n+    _large.register_garbage_page(page);\n+  }\n+\n+  _garbage_pages.append(page);\n+}\n+\n+inline bool ZRelocationSetSelector::should_free_garbage_pages(int bulk) const {\n+  return _garbage_pages.length() >= bulk && _garbage_pages.is_nonempty();\n+}\n+\n+inline const ZArray<ZPage*>* ZRelocationSetSelector::garbage_pages() const {\n+  return &_garbage_pages;\n+}\n+\n+inline void ZRelocationSetSelector::clear_garbage_pages() {\n+  return _garbage_pages.clear();\n+}\n+\n@@ -97,0 +162,12 @@\n+inline const ZArray<ZPage*>* ZRelocationSetSelector::small() const {\n+  return _small.selected();\n+}\n+\n+inline const ZArray<ZPage*>* ZRelocationSetSelector::medium() const {\n+  return _medium.selected();\n+}\n+\n+inline size_t ZRelocationSetSelector::forwarding_entries() const {\n+  return _small.forwarding_entries() + _medium.forwarding_entries();\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zRelocationSetSelector.inline.hpp","additions":81,"deletions":4,"binary":false,"changes":85,"status":"modified"},{"patch":"@@ -1143,0 +1143,1 @@\n+size_t                      ZStatRelocation::_forwarding_usage;\n@@ -1149,0 +1150,4 @@\n+void ZStatRelocation::set_at_install_relocation_set(size_t forwarding_usage) {\n+  _forwarding_usage = forwarding_usage;\n+}\n+\n@@ -1172,0 +1177,1 @@\n+  log_info(gc, reloc)(\"Forwarding Usage: \" SIZE_FORMAT \"M\", _forwarding_usage \/ M);\n","filename":"src\/hotspot\/share\/gc\/z\/zStat.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -426,0 +426,1 @@\n+  static size_t                      _forwarding_usage;\n@@ -432,0 +433,1 @@\n+  static void set_at_install_relocation_set(size_t forwarding_usage);\n","filename":"src\/hotspot\/share\/gc\/z\/zStat.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"gc\/z\/zForwardingAllocator.inline.hpp\"\n@@ -160,0 +161,4 @@\n+    \/\/ Setup allocator\n+    ZForwardingAllocator allocator;\n+    allocator.reset((sizeof(ZForwarding)) + (page.forwarding_entries() * sizeof(ZForwardingEntry)));\n+\n@@ -161,1 +166,1 @@\n-    ZForwarding* const forwarding = ZForwarding::create(&page);\n+    ZForwarding* const forwarding = ZForwarding::alloc(&allocator, &page);\n@@ -165,3 +170,0 @@\n-\n-    \/\/ Teardown forwarding\n-    ZForwarding::destroy(forwarding);\n","filename":"test\/hotspot\/gtest\/gc\/z\/test_zForwarding.cpp","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"}]}