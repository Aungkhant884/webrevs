{"files":[{"patch":"@@ -27,0 +27,1 @@\n+#include \"gc\/z\/zArray.inline.hpp\"\n@@ -223,0 +224,11 @@\n+void ZHeap::free_pages(const ZArray<ZPage*>* pages, bool reclaimed) {\n+  \/\/ Remove page table entries\n+  ZArrayIterator<ZPage*> iter(pages);\n+  for (ZPage* page; iter.next(&page);) {\n+    _page_table.remove(page);\n+  }\n+\n+  \/\/ Free pages\n+  _page_allocator.free_pages(pages, reclaimed);\n+}\n+\n@@ -352,0 +364,10 @@\n+void ZHeap::free_garbage_pages(ZRelocationSetSelector* selector, int bulk) {\n+  \/\/ Freeing garbage pages in bulk is an optimization to avoid grabbing\n+  \/\/ the page allocator lock, and trying to satisfy stalled allocations\n+  \/\/ too frequently.\n+  if (selector->should_free_garbage_pages(bulk)) {\n+    free_pages(selector->garbage_pages(), true \/* reclaimed *\/);\n+    selector->clear_garbage_pages();\n+  }\n+}\n+\n@@ -372,2 +394,2 @@\n-      \/\/ Reclaim page immediately\n-      free_page(page, true \/* reclaimed *\/);\n+      \/\/ Reclaim garbage pages in bulk\n+      free_garbage_pages(&selector, 64 \/* bulk *\/);\n@@ -377,0 +399,3 @@\n+  \/\/ Reclaim remaining garbage pages\n+  free_garbage_pages(&selector, 0 \/* bulk *\/);\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zHeap.cpp","additions":27,"deletions":2,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"gc\/z\/zArray.hpp\"\n@@ -43,0 +44,1 @@\n+class ZRelocationSetSelector;\n@@ -66,0 +68,2 @@\n+  void free_garbage_pages(ZRelocationSetSelector* selector, int bulk);\n+\n@@ -113,0 +117,1 @@\n+  void free_pages(const ZArray<ZPage*>* pages, bool reclaimed);\n","filename":"src\/hotspot\/share\/gc\/z\/zHeap.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"gc\/z\/zArray.inline.hpp\"\n@@ -751,0 +752,13 @@\n+void ZPageAllocator::free_pages(const ZArray<ZPage*>* pages, bool reclaimed) {\n+  ZLocker<ZLock> locker(&_lock);\n+\n+  \/\/ Free pages\n+  ZArrayIterator<ZPage*> iter(pages);\n+  for (ZPage* page; iter.next(&page);) {\n+    free_page_inner(page, reclaimed);\n+  }\n+\n+  \/\/ Try satisfy stalled allocations\n+  satisfy_stalled();\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zPageAllocator.cpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"gc\/z\/zArray.hpp\"\n@@ -127,0 +128,1 @@\n+  void free_pages(const ZArray<ZPage*>* pages, bool reclaimed);\n","filename":"src\/hotspot\/share\/gc\/z\/zPageAllocator.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -57,25 +57,0 @@\n-void ZRelocationSetSelectorGroup::register_live_page(ZPage* page) {\n-  const uint8_t type = page->type();\n-  const size_t size = page->size();\n-  const size_t live = page->live_bytes();\n-  const size_t garbage = size - live;\n-\n-  if (garbage > _fragmentation_limit) {\n-    _registered_pages.append(page);\n-  }\n-\n-  _stats._npages++;\n-  _stats._total += size;\n-  _stats._live += live;\n-  _stats._garbage += garbage;\n-}\n-\n-void ZRelocationSetSelectorGroup::register_garbage_page(ZPage* page) {\n-  const size_t size = page->size();\n-\n-  _stats._npages++;\n-  _stats._total += size;\n-  _stats._garbage += size;\n-  _stats._empty += size;\n-}\n-\n@@ -208,25 +183,2 @@\n-    _large(\"Large\", ZPageTypeLarge, 0 \/* page_size *\/, 0 \/* object_size_limit *\/) {}\n-\n-void ZRelocationSetSelector::register_live_page(ZPage* page) {\n-  const uint8_t type = page->type();\n-\n-  if (type == ZPageTypeSmall) {\n-    _small.register_live_page(page);\n-  } else if (type == ZPageTypeMedium) {\n-    _medium.register_live_page(page);\n-  } else {\n-    _large.register_live_page(page);\n-  }\n-}\n-\n-void ZRelocationSetSelector::register_garbage_page(ZPage* page) {\n-  const uint8_t type = page->type();\n-\n-  if (type == ZPageTypeSmall) {\n-    _small.register_garbage_page(page);\n-  } else if (type == ZPageTypeMedium) {\n-    _medium.register_garbage_page(page);\n-  } else {\n-    _large.register_garbage_page(page);\n-  }\n-}\n+    _large(\"Large\", ZPageTypeLarge, 0 \/* page_size *\/, 0 \/* object_size_limit *\/),\n+    _garbage_pages() {}\n","filename":"src\/hotspot\/share\/gc\/z\/zRelocationSetSelector.cpp","additions":2,"deletions":50,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -107,0 +107,1 @@\n+  ZArray<ZPage*>              _garbage_pages;\n@@ -119,0 +120,4 @@\n+  bool should_free_garbage_pages(int bulk) const;\n+  const ZArray<ZPage*>* garbage_pages() const;\n+  void clear_garbage_pages();\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zRelocationSetSelector.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+#include \"gc\/z\/zArray.inline.hpp\"\n+#include \"gc\/z\/zPage.inline.hpp\"\n@@ -69,0 +71,25 @@\n+inline void ZRelocationSetSelectorGroup::register_live_page(ZPage* page) {\n+  const uint8_t type = page->type();\n+  const size_t size = page->size();\n+  const size_t live = page->live_bytes();\n+  const size_t garbage = size - live;\n+\n+  if (garbage > _fragmentation_limit) {\n+    _registered_pages.append(page);\n+  }\n+\n+  _stats._npages++;\n+  _stats._total += size;\n+  _stats._live += live;\n+  _stats._garbage += garbage;\n+}\n+\n+inline void ZRelocationSetSelectorGroup::register_garbage_page(ZPage* page) {\n+  const size_t size = page->size();\n+\n+  _stats._npages++;\n+  _stats._total += size;\n+  _stats._garbage += size;\n+  _stats._empty += size;\n+}\n+\n@@ -81,0 +108,38 @@\n+inline void ZRelocationSetSelector::register_live_page(ZPage* page) {\n+  const uint8_t type = page->type();\n+\n+  if (type == ZPageTypeSmall) {\n+    _small.register_live_page(page);\n+  } else if (type == ZPageTypeMedium) {\n+    _medium.register_live_page(page);\n+  } else {\n+    _large.register_live_page(page);\n+  }\n+}\n+\n+inline void ZRelocationSetSelector::register_garbage_page(ZPage* page) {\n+  const uint8_t type = page->type();\n+\n+  if (type == ZPageTypeSmall) {\n+    _small.register_garbage_page(page);\n+  } else if (type == ZPageTypeMedium) {\n+    _medium.register_garbage_page(page);\n+  } else {\n+    _large.register_garbage_page(page);\n+  }\n+\n+  _garbage_pages.append(page);\n+}\n+\n+inline bool ZRelocationSetSelector::should_free_garbage_pages(int bulk) const {\n+  return _garbage_pages.length() >= bulk && _garbage_pages.is_nonempty();\n+}\n+\n+inline const ZArray<ZPage*>* ZRelocationSetSelector::garbage_pages() const {\n+  return &_garbage_pages;\n+}\n+\n+inline void ZRelocationSetSelector::clear_garbage_pages() {\n+  return _garbage_pages.clear();\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zRelocationSetSelector.inline.hpp","additions":65,"deletions":0,"binary":false,"changes":65,"status":"modified"}]}