{"files":[{"patch":"@@ -1799,2 +1799,2 @@\n-      if (PhaseIdealLoop::find_parse_predicate(r->in(i)) != nullptr) {\n-        return nullptr;            \/\/ don't split loop entry path\n+      if (Node::may_be_loop_entry(r->in(i))) {\n+        return nullptr; \/\/ don't split loop entry path\n","filename":"src\/hotspot\/share\/opto\/cfgnode.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -455,0 +455,20 @@\n+\/\/ Special node that denotes a Parse Predicate added during parsing. A Parse Predicate serves as placeholder to later\n+\/\/ create Runtime Predicates above it. They all share the same uncommon trap. The Parse Predicate will follow the\n+\/\/ Runtime Predicates. Together they form a Regular Predicate Block. There are three kinds of Parse Predicates:\n+\/\/ Loop Parse Predicate, Profiled Loop Parse Predicate (both used by Loop Predication), and Loop Limit Check Parse\n+\/\/ Predicate (used for integer overflow checks when creating a counted loop).\n+\/\/ More information about predicates can be found in loopPredicate.cpp.\n+class ParsePredicateNode : public IfNode {\n+  Deoptimization::DeoptReason _deopt_reason;\n+ public:\n+  ParsePredicateNode(Node* control, Node* bol, Deoptimization::DeoptReason deopt_reason);\n+  virtual int Opcode() const;\n+  virtual uint size_of() const { return sizeof(*this); }\n+\n+  Deoptimization::DeoptReason deopt_reason() const {\n+    return _deopt_reason;\n+  }\n+\n+  NOT_PRODUCT(void dump_spec(outputStream* st) const;)\n+};\n+\n","filename":"src\/hotspot\/share\/opto\/cfgnode.hpp","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -287,0 +287,1 @@\n+macro(ParsePredicate)\n","filename":"src\/hotspot\/share\/opto\/classes.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -3998,6 +3998,7 @@\n-  Node* cont    = _gvn.intcon(1);\n-  Node* opq     = _gvn.transform(new Opaque1Node(C, cont));\n-  Node* bol     = _gvn.transform(new Conv2BNode(opq));\n-  IfNode* iff   = create_and_map_if(control(), bol, PROB_MAX, COUNT_UNKNOWN);\n-  Node* iffalse = _gvn.transform(new IfFalseNode(iff));\n-  C->add_parse_predicate_opaq(opq);\n+  Node* cont = _gvn.intcon(1);\n+  Node* opaq = _gvn.transform(new Opaque1Node(C, cont));\n+  C->add_parse_predicate_opaq(opaq);\n+  Node* bol = _gvn.transform(new Conv2BNode(opaq));\n+  ParsePredicateNode* parse_predicate = new ParsePredicateNode(control(), bol, reason);\n+  _gvn.set_type(parse_predicate, parse_predicate->Value(&_gvn));\n+  Node* if_false = _gvn.transform(new IfFalseNode(parse_predicate));\n@@ -4006,1 +4007,1 @@\n-    set_control(iffalse);\n+    set_control(if_false);\n@@ -4010,2 +4011,2 @@\n-  Node* iftrue = _gvn.transform(new IfTrueNode(iff));\n-  set_control(iftrue);\n+  Node* if_true = _gvn.transform(new IfTrueNode(parse_predicate));\n+  set_control(if_true);\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":10,"deletions":9,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -245,3 +245,2 @@\n-    Node* proj = PhaseIdealLoop::find_parse_predicate(r->in(ii));\n-    if (proj != nullptr) {\n-      \/\/ Bail out if splitting through a region with a predicate input (could\n+    if (Node::may_be_loop_entry(r->in(ii))) {\n+      \/\/ Bail out if splitting through a region with a Parse Predicate input (could\n@@ -1972,0 +1971,36 @@\n+\n+ParsePredicateNode::ParsePredicateNode(Node* control, Node* bol, Deoptimization::DeoptReason deopt_reason)\n+    : IfNode(control, bol, PROB_MAX, COUNT_UNKNOWN),\n+      _deopt_reason(deopt_reason) {\n+  init_class_id(Class_ParsePredicate);\n+  assert(bol->Opcode() == Op_Conv2B && bol->in(1) != nullptr && bol->in(1)->is_Opaque1(), \"wrong boolean input\");\n+#ifdef ASSERT\n+  switch (deopt_reason) {\n+    case Deoptimization::Reason_predicate:\n+    case Deoptimization::Reason_profile_predicate:\n+    case Deoptimization::Reason_loop_limit_check:\n+      break;\n+    default:\n+      assert(false, \"unsupported deoptimization reason for Parse Predicate\");\n+  }\n+#endif \/\/ ASSERT\n+}\n+\n+#ifndef PRODUCT\n+void ParsePredicateNode::dump_spec(outputStream* st) const {\n+  st->print(\" #\");\n+  switch (_deopt_reason) {\n+    case Deoptimization::DeoptReason::Reason_predicate:\n+      st->print(\"Loop \");\n+      break;\n+    case Deoptimization::DeoptReason::Reason_profile_predicate:\n+      st->print(\"Profiled_Loop \");\n+      break;\n+    case Deoptimization::DeoptReason::Reason_loop_limit_check:\n+      st->print(\"Loop_Limit_Check \");\n+      break;\n+    default:\n+      fatal(\"unknown kind\");\n+  }\n+}\n+#endif \/\/ NOT PRODUCT\n","filename":"src\/hotspot\/share\/opto\/ifnode.cpp","additions":38,"deletions":3,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -310,5 +310,12 @@\n-  if (opcode == Op_If) {\n-    new_iff = new IfNode(entry, iff->in(1), iff->_prob, iff->_fcnt);\n-  } else {\n-    assert(opcode == Op_RangeCheck, \"no other if variant here\");\n-    new_iff = new RangeCheckNode(entry, iff->in(1), iff->_prob, iff->_fcnt);\n+  switch (opcode) {\n+    case Op_If:\n+      new_iff = new IfNode(entry, iff->in(1), iff->_prob, iff->_fcnt);\n+      break;\n+    case Op_RangeCheck:\n+      new_iff = new RangeCheckNode(entry, iff->in(1), iff->_prob, iff->_fcnt);\n+      break;\n+    case Op_ParsePredicate:\n+      new_iff = new ParsePredicateNode(entry, iff->in(1), reason);\n+      break;\n+    default:\n+      fatal(\"no other If variant here\");\n@@ -473,1 +480,1 @@\n-  IfProjNode* new_predicate_proj = create_new_if_for_predicate(predicate_proj, new_entry, reason, Op_If,\n+  IfProjNode* new_predicate_proj = create_new_if_for_predicate(predicate_proj, new_entry, reason, Op_ParsePredicate,\n@@ -588,1 +595,0 @@\n-  bool clone_limit_check = !head->is_CountedLoop();\n@@ -591,22 +597,13 @@\n-  \/\/ Search original predicates\n-  ParsePredicateSuccessProj* limit_check_proj = nullptr;\n-  limit_check_proj = find_predicate_insertion_point(entry, Deoptimization::Reason_loop_limit_check);\n-  if (limit_check_proj != nullptr) {\n-    entry = skip_related_predicates(entry);\n-  }\n-  ParsePredicateSuccessProj* profile_predicate_proj = nullptr;\n-  ParsePredicateSuccessProj* predicate_proj = nullptr;\n-  if (UseProfiledLoopPredicate) {\n-    profile_predicate_proj = find_predicate_insertion_point(entry, Deoptimization::Reason_profile_predicate);\n-    if (profile_predicate_proj != nullptr) {\n-      entry = skip_related_predicates(entry);\n-    }\n-  }\n-  if (UseLoopPredicate) {\n-    predicate_proj = find_predicate_insertion_point(entry, Deoptimization::Reason_predicate);\n-  }\n-  if (predicate_proj != nullptr) { \/\/ right pattern that can be used by loop predication\n-    \/\/ clone predicate\n-    iffast_pred = clone_parse_predicate_to_unswitched_loop(predicate_proj, iffast_pred, Deoptimization::Reason_predicate, false);\n-    ifslow_pred = clone_parse_predicate_to_unswitched_loop(predicate_proj, ifslow_pred, Deoptimization::Reason_predicate, true);\n-    clone_assertion_predicates_to_unswitched_loop(loop, old_new, Deoptimization::Reason_predicate, predicate_proj,\n+  ParsePredicates parse_predicates(entry);\n+  ParsePredicateSuccessProj* loop_predicate_proj = parse_predicates.loop_predicate_proj();\n+  if (loop_predicate_proj != nullptr) {\n+    \/\/ Clone Parse Predicate and Template Assertion Predicates of the Loop Predicate Block.\n+    iffast_pred = clone_parse_predicate_to_unswitched_loop(loop_predicate_proj, iffast_pred,\n+                                                           Deoptimization::Reason_predicate, false);\n+    check_cloned_parse_predicate_for_unswitching(iffast_pred, true);\n+\n+    ifslow_pred = clone_parse_predicate_to_unswitched_loop(loop_predicate_proj, ifslow_pred,\n+                                                           Deoptimization::Reason_predicate, true);\n+    check_cloned_parse_predicate_for_unswitching(ifslow_pred, false);\n+\n+    clone_assertion_predicates_to_unswitched_loop(loop, old_new, Deoptimization::Reason_predicate, loop_predicate_proj,\n@@ -614,3 +611,0 @@\n-\n-    check_cloned_parse_predicate_for_unswitching(iffast_pred);\n-    check_cloned_parse_predicate_for_unswitching(ifslow_pred);\n@@ -618,4 +612,12 @@\n-  if (profile_predicate_proj != nullptr) { \/\/ right pattern that can be used by loop predication\n-    \/\/ clone predicate\n-    iffast_pred = clone_parse_predicate_to_unswitched_loop(profile_predicate_proj, iffast_pred,Deoptimization::Reason_profile_predicate, false);\n-    ifslow_pred = clone_parse_predicate_to_unswitched_loop(profile_predicate_proj, ifslow_pred,Deoptimization::Reason_profile_predicate, true);\n+\n+  ParsePredicateSuccessProj* profiled_loop_predicate_proj = parse_predicates.profiled_loop_predicate_proj();\n+  if (profiled_loop_predicate_proj != nullptr) {\n+    \/\/ Clone Parse Predicate and Template Assertion Predicates of the Profiled Loop Predicate Block.\n+    iffast_pred = clone_parse_predicate_to_unswitched_loop(profiled_loop_predicate_proj, iffast_pred,\n+                                                           Deoptimization::Reason_profile_predicate, false);\n+    check_cloned_parse_predicate_for_unswitching(iffast_pred, true);\n+\n+    ifslow_pred = clone_parse_predicate_to_unswitched_loop(profiled_loop_predicate_proj, ifslow_pred,\n+                                                           Deoptimization::Reason_profile_predicate, true);\n+    check_cloned_parse_predicate_for_unswitching(ifslow_pred, false);\n+\n@@ -623,1 +625,1 @@\n-                                                  profile_predicate_proj, iffast_pred, ifslow_pred);\n+                                                  profiled_loop_predicate_proj, iffast_pred, ifslow_pred);\n@@ -625,2 +627,0 @@\n-    check_cloned_parse_predicate_for_unswitching(iffast_pred);\n-    check_cloned_parse_predicate_for_unswitching(ifslow_pred);\n@@ -628,6 +628,0 @@\n-  if (limit_check_proj != nullptr && clone_limit_check) {\n-    \/\/ Clone loop limit check last to insert it before loop.\n-    \/\/ Don't clone a limit check which was already finalized\n-    \/\/ for this counted loop (only one limit check is needed).\n-    iffast_pred = clone_parse_predicate_to_unswitched_loop(limit_check_proj, iffast_pred,Deoptimization::Reason_loop_limit_check, false);\n-    ifslow_pred = clone_parse_predicate_to_unswitched_loop(limit_check_proj, ifslow_pred,Deoptimization::Reason_loop_limit_check, true);\n@@ -635,0 +629,7 @@\n+  ParsePredicateSuccessProj* loop_limit_check_predicate_proj = parse_predicates.loop_limit_check_predicate_proj();\n+  if (loop_limit_check_predicate_proj != nullptr && !head->is_CountedLoop()) {\n+    \/\/ Don't clone the Loop Limit Check Parse Predicate if we already have a counted loop (a Loop Limit Check Predicate\n+    \/\/ is only created when converting a LoopNode to a CountedLoopNode).\n+    iffast_pred = clone_parse_predicate_to_unswitched_loop(loop_limit_check_predicate_proj, iffast_pred,\n+                                                           Deoptimization::Reason_loop_limit_check, false);\n+    check_cloned_parse_predicate_for_unswitching(iffast_pred, true);\n@@ -636,2 +637,3 @@\n-    check_cloned_parse_predicate_for_unswitching(iffast_pred);\n-    check_cloned_parse_predicate_for_unswitching(ifslow_pred);\n+    ifslow_pred = clone_parse_predicate_to_unswitched_loop(loop_limit_check_predicate_proj, ifslow_pred,\n+                                                           Deoptimization::Reason_loop_limit_check, true);\n+    check_cloned_parse_predicate_for_unswitching(ifslow_pred, false);\n@@ -642,1 +644,1 @@\n-void PhaseIdealLoop::check_cloned_parse_predicate_for_unswitching(const Node* new_entry) {\n+void PhaseIdealLoop::check_cloned_parse_predicate_for_unswitching(const Node* new_entry, const bool is_fast_loop) {\n@@ -645,2 +647,2 @@\n-    tty->print(\"Loop Predicate cloned: \");\n-    debug_only(new_entry->in(0)->dump(););\n+    tty->print(\"Parse Predicate cloned to %s loop: \", is_fast_loop ? \"fast\" : \"slow\");\n+    new_entry->in(0)->dump();\n@@ -651,91 +653,0 @@\n-Node* PhaseIdealLoop::skip_related_predicates(Node* entry) {\n-  IfNode* iff = entry->in(0)->as_If();\n-  ProjNode* uncommon_proj = iff->proj_out(1 - entry->as_Proj()->_con);\n-  Node* rgn = uncommon_proj->unique_ctrl_out();\n-  assert(rgn->is_Region() || rgn->is_Call(), \"must be a region or call uct\");\n-  entry = entry->in(0)->in(0);\n-  while (entry != nullptr && entry->is_Proj() && entry->in(0)->is_If()) {\n-    uncommon_proj = entry->in(0)->as_If()->proj_out(1 - entry->as_Proj()->_con);\n-    if (uncommon_proj->unique_ctrl_out() != rgn)\n-      break;\n-    entry = entry->in(0)->in(0);\n-  }\n-  return entry;\n-}\n-\n-Node* PhaseIdealLoop::skip_all_predicates(Node* entry) {\n-  ParsePredicates parse_predicates(entry);\n-  return parse_predicates.get_first_predicate();\n-}\n-\n-\/\/--------------------------next_predicate---------------------------------\n-\/\/ Find next related predicate, useful for iterating over all related predicates\n-IfProjNode* PhaseIdealLoop::next_predicate(IfProjNode* predicate_proj) {\n-  IfNode* iff = predicate_proj->in(0)->as_If();\n-  ProjNode* uncommon_proj = iff->proj_out(1 - predicate_proj->_con);\n-  Node* rgn = uncommon_proj->unique_ctrl_out();\n-  assert(rgn->is_Region() || rgn->is_Call(), \"must be a region or call uct\");\n-  Node* next = iff->in(0);\n-  if (next != nullptr && next->is_IfProj() && next->in(0)->is_If()) {\n-    uncommon_proj = next->in(0)->as_If()->proj_out(1 - next->as_Proj()->_con);\n-    if (uncommon_proj->unique_ctrl_out() == rgn) { \/\/ lead into same region\n-      return next->as_IfProj();\n-    }\n-  }\n-  return nullptr;\n-}\n-\n-\/\/--------------------------find_predicate_insertion_point-------------------\n-\/\/ Find a good location to insert a predicate\n-ParsePredicateSuccessProj* PhaseIdealLoop::find_predicate_insertion_point(Node* start_c, Deoptimization::DeoptReason reason) {\n-  if (start_c == nullptr || !start_c->is_IfTrue())\n-    return nullptr;\n-  if (start_c->as_IfTrue()->is_uncommon_trap_if_pattern(reason)) {\n-    return start_c->as_IfTrue();\n-  }\n-  return nullptr;\n-}\n-\n-\/\/--------------------------Predicates::Predicates--------------------------\n-\/\/ given loop entry, find all predicates above loop\n-PhaseIdealLoop::ParsePredicates::ParsePredicates(Node* entry) {\n-  _loop_limit_check_predicate = find_predicate_insertion_point(entry, Deoptimization::Reason_loop_limit_check);\n-  if (_loop_limit_check_predicate != nullptr) {\n-    entry = skip_related_predicates(entry);\n-  }\n-  if (UseProfiledLoopPredicate) {\n-    _profiled_loop_predicate = find_predicate_insertion_point(entry, Deoptimization::Reason_profile_predicate);\n-    if (_profiled_loop_predicate != nullptr) {\n-      entry = skip_related_predicates(entry);\n-    }\n-  }\n-  if (UseLoopPredicate) {\n-    _loop_predicate = find_predicate_insertion_point(entry, Deoptimization::Reason_predicate);\n-    if (_loop_predicate != nullptr) {\n-      entry = skip_related_predicates(entry);\n-    }\n-  }\n-  _first_predicate = entry;\n-}\n-\n-Node* PhaseIdealLoop::find_parse_predicate(Node* entry) {\n-  Node* predicate = nullptr;\n-  predicate = find_predicate_insertion_point(entry, Deoptimization::Reason_loop_limit_check);\n-  if (predicate != nullptr) { \/\/ right pattern that can be used by loop predication\n-    return entry;\n-  }\n-  if (UseLoopPredicate) {\n-    predicate = find_predicate_insertion_point(entry, Deoptimization::Reason_predicate);\n-    if (predicate != nullptr) { \/\/ right pattern that can be used by loop predication\n-      return entry;\n-    }\n-  }\n-  if (UseProfiledLoopPredicate) {\n-    predicate = find_predicate_insertion_point(entry, Deoptimization::Reason_profile_predicate);\n-    if (predicate != nullptr) { \/\/ right pattern that can be used by loop predication\n-      return entry;\n-    }\n-  }\n-  return nullptr;\n-}\n-\n@@ -1584,2 +1495,1 @@\n-\/\/------------------------------ loop_predication_impl--------------------------\n-\/\/ Insert loop predicates for null checks and range checks\n+\/\/ Insert Hoisted Predicates for null checks and range checks and additional Template Assertion Predicates for range checks.\n@@ -1616,20 +1526,19 @@\n-  ParsePredicateSuccessProj* loop_limit_proj = nullptr;\n-  ParsePredicateSuccessProj* predicate_proj = nullptr;\n-  ParsePredicateSuccessProj* profile_predicate_proj = nullptr;\n-  \/\/ Loop limit check predicate should be near the loop.\n-  loop_limit_proj = find_predicate_insertion_point(entry, Deoptimization::Reason_loop_limit_check);\n-  if (loop_limit_proj != nullptr) {\n-    entry = skip_related_predicates(loop_limit_proj);\n-  }\n-  bool has_profile_predicates = false;\n-  profile_predicate_proj = find_predicate_insertion_point(entry, Deoptimization::Reason_profile_predicate);\n-  if (profile_predicate_proj != nullptr) {\n-    Node* n = skip_related_predicates(entry);\n-    \/\/ Check if predicates were already added to the profile predicate\n-    \/\/ block\n-    if (n != entry->in(0)->in(0) || n->outcnt() != 1) {\n-      has_profile_predicates = true;\n-    }\n-    entry = n;\n-  }\n-  predicate_proj = find_predicate_insertion_point(entry, Deoptimization::Reason_predicate);\n+  ParsePredicates parse_predicates(entry);\n+\n+  bool can_create_loop_predicates = true;\n+  \/\/ We cannot add Loop Predicates if:\n+  \/\/ - Already added Profiled Loop Predicates (Loop Predicates and Profiled Loop Predicates can be dependent\n+  \/\/   through a data node, and thus we should only add new Profiled Loop Predicates which are below Loop Predicates\n+  \/\/   in the graph).\n+  \/\/ - There are currently no Profiled Loop Predicates, but we have a data node with a control dependency on the Loop\n+  \/\/   Parse Predicate (could happen, for example, if we've removed an earlier created Profiled Loop Predicate with\n+  \/\/   dominated_by()). We should not create a Loop Predicate for a check that is dependent on this data node because\n+  \/\/   the Loop Predicate would end up above the data node with its dependency on the Loop Parse Predicate below. This\n+  \/\/   would become unschedulable. However, we can still hoist the check as Profiled Loop Predicate which would end up\n+  \/\/   below the Loop Parse Predicate.\n+  if (Predicates::has_profiled_loop_predicates(parse_predicates)\n+      || (parse_predicates.loop_predicate_proj() != nullptr && parse_predicates.loop_predicate_proj()->outcnt() != 1)) {\n+    can_create_loop_predicates = false;\n+  }\n+  ParsePredicateSuccessProj* loop_predicate_proj = parse_predicates.loop_predicate_proj();\n+  ParsePredicateSuccessProj* profiled_loop_predicate_proj = parse_predicates.profiled_loop_predicate_proj();\n@@ -1638,1 +1547,1 @@\n-  bool follow_branches = loop_predication_should_follow_branches(loop, profile_predicate_proj, loop_trip_cnt);\n+  bool follow_branches = loop_predication_should_follow_branches(loop, profiled_loop_predicate_proj, loop_trip_cnt);\n@@ -1641,1 +1550,1 @@\n-  if (predicate_proj == nullptr && !follow_branches) {\n+  if (loop_predicate_proj == nullptr && !follow_branches) {\n@@ -1682,1 +1591,1 @@\n-  if (!has_profile_predicates) {\n+  if (can_create_loop_predicates) {\n@@ -1711,2 +1620,3 @@\n-      if (predicate_proj != nullptr) {\n-        hoisted = loop_predication_impl_helper(loop, if_proj, predicate_proj, cl, zero, invar, Deoptimization::Reason_predicate) | hoisted;\n+      if (loop_predicate_proj != nullptr) {\n+        hoisted = loop_predication_impl_helper(loop, if_proj, loop_predicate_proj, cl, zero, invar,\n+                                               Deoptimization::Reason_predicate) | hoisted;\n@@ -1718,0 +1628,1 @@\n+    assert(profiled_loop_predicate_proj != nullptr, \"sanity check\");\n@@ -1727,1 +1638,2 @@\n-        hoisted = loop_predication_impl_helper(loop, if_proj->as_IfProj(), profile_predicate_proj, cl, zero, invar, Deoptimization::Reason_profile_predicate) | hoisted;\n+        hoisted = loop_predication_impl_helper(loop, if_proj->as_IfProj(), profiled_loop_predicate_proj, cl, zero, invar,\n+                                               Deoptimization::Reason_profile_predicate) | hoisted;\n@@ -1742,1 +1654,1 @@\n-      hoisted = loop_predication_impl_helper(loop, if_proj, profile_predicate_proj, cl, zero, invar, Deoptimization::Reason_profile_predicate) | hoisted;\n+      hoisted = loop_predication_impl_helper(loop, if_proj, profiled_loop_predicate_proj, cl, zero, invar, Deoptimization::Reason_profile_predicate) | hoisted;\n@@ -1780,0 +1692,137 @@\n+\n+\/\/ Skip over all predicates (all Regular Predicate Blocks) starting at the Parse Predicate projection 'node'. Return the\n+\/\/ first node that is not a predicate If node anymore (i.e. entry into the first predicate If on top) or 'node' if 'node'\n+\/\/ is not a Parse Predicate projection.\n+Node* Predicates::skip_all_predicates(Node* node) {\n+  ParsePredicates parse_predicates(node);\n+  if (parse_predicates.has_any()) {\n+    return skip_all_predicates(parse_predicates);\n+  } else {\n+    return node;\n+  }\n+}\n+\n+\/\/ Skip over all Runtime Predicates belonging to the given Parse Predicates. Return the first node that is not a predicate\n+\/\/ If node anymore (i.e. entry into the first predicate If on top).\n+Node* Predicates::skip_all_predicates(ParsePredicates& parse_predicates) {\n+  assert(parse_predicates.has_any(), \"must have at least one Parse Predicate\");\n+  return skip_predicates_in_block(parse_predicates.get_top_predicate_proj());\n+}\n+\n+\/\/ Skip over all predicates in a Regular Predicate Block starting at the Parse Predicate projection\n+\/\/ 'parse_predicate_success_proj'. Return the first node not belonging this block anymore (i.e. entry\n+\/\/ into this Regular Predicate Block).\n+Node* Predicates::skip_predicates_in_block(ParsePredicateSuccessProj* parse_predicate_success_proj) {\n+  IfProjNode* prev;\n+  IfProjNode* next = parse_predicate_success_proj;\n+  do {\n+    prev = next;\n+    next = next_predicate_proj_in_block(next);\n+  } while (next != nullptr);\n+  assert(prev->in(0)->is_If(), \"must be predicate If\");\n+  return prev->in(0)->in(0);\n+}\n+\n+\/\/ Find next Runtime Predicate projection in a Regular Predicate Block or return null if there is none.\n+IfProjNode* Predicates::next_predicate_proj_in_block(IfProjNode* proj) {\n+  IfNode* iff = proj->in(0)->as_If();\n+  ProjNode* uncommon_proj = iff->proj_out(1 - proj->_con);\n+  Node* rgn = uncommon_proj->unique_ctrl_out();\n+  assert(rgn->is_Region() || rgn->is_Call(), \"must be a region or call uct\");\n+  Node* next = iff->in(0);\n+  if (next != nullptr && next->is_Proj() && next->in(0)->is_If()) {\n+    uncommon_proj = next->in(0)->as_If()->proj_out(1 - next->as_Proj()->_con);\n+    if (uncommon_proj->unique_ctrl_out() == rgn) {\n+      \/\/ Same Runtime Predicate Block.\n+      return next->as_IfProj();\n+    }\n+  }\n+  return nullptr;\n+}\n+\n+\/\/ Is there at least one Profiled Loop Predicate?\n+bool Predicates::has_profiled_loop_predicates(ParsePredicates& parse_predicates) {\n+  ParsePredicateSuccessProj* profiled_loop_predicate = parse_predicates.profiled_loop_predicate_proj();\n+  if (profiled_loop_predicate == nullptr) {\n+    return false;\n+  }\n+  return Predicates::next_predicate_proj_in_block(profiled_loop_predicate) != nullptr;\n+}\n+\n+\/\/ Given a node 'starting_proj', check if it is a Parse Predicate success projection.\n+\/\/ If so, find all Parse Predicates above the loop.\n+ParsePredicates::ParsePredicates(Node* starting_proj) : _top_predicate_proj(nullptr), _starting_proj(nullptr) {\n+  if (starting_proj == nullptr || !starting_proj->is_IfTrue()) {\n+    return; \/\/ Not a predicate.\n+  }\n+  _starting_proj = starting_proj->as_IfTrue();\n+  find_parse_predicate_projections();\n+}\n+\n+void ParsePredicates::find_parse_predicate_projections() {\n+  Node* maybe_parse_predicate_proj = _starting_proj;\n+  for (int i = 0; i < 3; i++) { \/\/ At most 3 Parse Predicates for a loop\n+    if (!is_success_proj(maybe_parse_predicate_proj)) {\n+      break;\n+    }\n+    ParsePredicateSuccessProj* parse_predicate_proj = maybe_parse_predicate_proj->as_IfTrue();\n+    if (!assign_predicate_proj(parse_predicate_proj)) {\n+      \/\/ Found a Parse Predicate of another (already removed) loop.\n+      break;\n+    }\n+    _top_predicate_proj = parse_predicate_proj;\n+    maybe_parse_predicate_proj = Predicates::skip_predicates_in_block(parse_predicate_proj);\n+  }\n+}\n+\n+\/\/ Is 'node' a success (non-UCT) projection of a Parse Predicate?\n+bool ParsePredicates::is_success_proj(Node* node) {\n+  if (node == nullptr || !node->is_Proj()) {\n+    return false;\n+  }\n+  ParsePredicateNode* parse_predicate = get_parse_predicate_or_null(node);\n+  if (parse_predicate == nullptr) {\n+    return false;\n+  }\n+  return !is_uct_proj(node, parse_predicate->deopt_reason());\n+}\n+\n+\/\/ Is 'node' a UCT projection of a Parse Predicate of kind 'kind'?\n+bool ParsePredicates::is_uct_proj(Node* node, Deoptimization::DeoptReason deopt_reason) {\n+  return node->as_Proj()->is_uncommon_trap_proj(deopt_reason);\n+}\n+\n+\/\/ Check the parent of `parse_predicate_proj` is a ParsePredicateNode. If so return it. Otherwise, return null.\n+ParsePredicateNode* ParsePredicates::get_parse_predicate_or_null(Node* parse_predicate_proj) {\n+  return parse_predicate_proj->in(0)->isa_ParsePredicate();\n+}\n+\n+\/\/ Initialize the Parse Predicate projection field that matches the kind of the parent of `parse_predicate_proj`.\n+bool ParsePredicates::assign_predicate_proj(ParsePredicateSuccessProj* parse_predicate_proj) {\n+  ParsePredicateNode* parse_predicate = get_parse_predicate_or_null(parse_predicate_proj);\n+  assert(parse_predicate != nullptr, \"must exist\");\n+  Deoptimization::DeoptReason deopt_reason = parse_predicate->deopt_reason();\n+  switch (deopt_reason) {\n+    case Deoptimization::DeoptReason::Reason_predicate:\n+      if (_loop_predicate_proj != nullptr) {\n+        return false;\n+      }\n+      _loop_predicate_proj = parse_predicate_proj;\n+      break;\n+    case Deoptimization::DeoptReason::Reason_profile_predicate:\n+      if (_profiled_loop_predicate_proj != nullptr) {\n+        return false;\n+      }\n+      _profiled_loop_predicate_proj = parse_predicate_proj;\n+      break;\n+    case Deoptimization::DeoptReason::Reason_loop_limit_check:\n+      if (_loop_limit_check_predicate_proj != nullptr) {\n+        return false;\n+      }\n+      _loop_limit_check_predicate_proj = parse_predicate_proj;\n+      break;\n+    default:\n+      fatal(\"invalid case\");\n+  }\n+  return true;\n+}\n","filename":"src\/hotspot\/share\/opto\/loopPredicate.cpp","additions":219,"deletions":170,"binary":false,"changes":389,"status":"modified"},{"patch":"@@ -492,1 +492,2 @@\n-             test->Opcode() == Op_RangeCheck,\n+             test->Opcode() == Op_RangeCheck ||\n+             test->Opcode() == Op_ParsePredicate,\n@@ -781,1 +782,1 @@\n-    initialize_assertion_predicates_for_peeled_loop(parse_predicates.loop_predicate(),\n+    initialize_assertion_predicates_for_peeled_loop(parse_predicates.loop_predicate_proj(),\n@@ -785,1 +786,1 @@\n-    initialize_assertion_predicates_for_peeled_loop(parse_predicates.profiled_loop_predicate(),\n+    initialize_assertion_predicates_for_peeled_loop(parse_predicates.profiled_loop_predicate_proj(),\n@@ -1593,15 +1594,4 @@\n-    Node* predicate = nullptr;\n-    predicate = find_predicate_insertion_point(entry, Deoptimization::Reason_loop_limit_check);\n-    if (predicate != nullptr) {\n-      entry = skip_related_predicates(entry);\n-    }\n-    Node* profile_predicate = nullptr;\n-    if (UseProfiledLoopPredicate) {\n-      profile_predicate = find_predicate_insertion_point(entry, Deoptimization::Reason_profile_predicate);\n-      if (profile_predicate != nullptr) {\n-        entry = skip_related_predicates(entry);\n-      }\n-    }\n-    predicate = find_predicate_insertion_point(entry, Deoptimization::Reason_predicate);\n-    copy_assertion_predicates_to_main_loop_helper(predicate, init, stride, outer_loop, outer_main_head, dd_main_head,\n-                                                  idx_before_pre_post, idx_after_post_before_pre, zero_trip_guard_proj_main,\n+    ParsePredicates parse_predicates(entry);\n+    copy_assertion_predicates_to_main_loop_helper(parse_predicates.loop_predicate_proj(), init, stride, outer_loop,\n+                                                  outer_main_head, dd_main_head, idx_before_pre_post,\n+                                                  idx_after_post_before_pre, zero_trip_guard_proj_main,\n@@ -1609,2 +1599,3 @@\n-    copy_assertion_predicates_to_main_loop_helper(profile_predicate, init, stride, outer_loop, outer_main_head, dd_main_head,\n-                                                  idx_before_pre_post, idx_after_post_before_pre, zero_trip_guard_proj_main,\n+    copy_assertion_predicates_to_main_loop_helper(parse_predicates.profiled_loop_predicate_proj(), init, stride,\n+                                                  outer_loop, outer_main_head, dd_main_head, idx_before_pre_post,\n+                                                  idx_after_post_before_pre, zero_trip_guard_proj_main,\n@@ -2143,1 +2134,1 @@\n-  predicate_proj = next_predicate(predicate_proj);\n+  predicate_proj = Predicates::next_predicate_proj_in_block(predicate_proj);\n@@ -2169,1 +2160,1 @@\n-    predicate_proj = next_predicate(predicate_proj);\n+    predicate_proj = Predicates::next_predicate_proj_in_block(predicate_proj);\n@@ -3537,1 +3528,1 @@\n-    Node* in_ctrl = PhaseIdealLoop::skip_all_predicates(cl->skip_predicates());\n+    Node* in_ctrl = Predicates::skip_all_predicates(cl->skip_predicates());\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":14,"deletions":23,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -120,1 +120,0 @@\n-\n@@ -123,3 +122,1 @@\n-  if (find_predicate_insertion_point(entry, Deoptimization::Reason_loop_limit_check) != nullptr\n-      || (UseProfiledLoopPredicate && find_predicate_insertion_point(entry, Deoptimization::Reason_profile_predicate) != nullptr)\n-      || (UseLoopPredicate && find_predicate_insertion_point(entry, Deoptimization::Reason_predicate) != nullptr)) {\n+  if (ParsePredicates::is_success_proj(entry)) {\n@@ -157,2 +154,2 @@\n-  Node* parse_predicate = find_parse_predicate(entry);\n-  if (parse_predicate == nullptr) {\n+  ParsePredicates parse_predicates(entry);\n+  if (!parse_predicates.has_any()) {\n@@ -164,16 +161,4 @@\n-    \/\/ There is at least one Parse Predicate. When calling 'skip_related_predicates' on each found Parse Predicate,\n-    \/\/ we should end up at 'proj_true'.\n-    Node* proj_before_first_parse_predicate = skip_related_predicates(entry);\n-    if (UseProfiledLoopPredicate) {\n-      parse_predicate = find_parse_predicate(proj_before_first_parse_predicate);\n-      if (parse_predicate != nullptr) {\n-        proj_before_first_parse_predicate = skip_related_predicates(parse_predicate);\n-      }\n-    }\n-    if (UseLoopPredicate) {\n-      parse_predicate = find_parse_predicate(proj_before_first_parse_predicate);\n-      if (parse_predicate != nullptr) {\n-        proj_before_first_parse_predicate = skip_related_predicates(parse_predicate);\n-      }\n-    }\n-    assert(proj_true == proj_before_first_parse_predicate, \"must hold by construction if at least one predicate\");\n+    \/\/ There is at least one Parse Predicate. When skipping all predicates\/Regular Predicate Blocks, we should end up\n+    \/\/ at 'proj_true'.\n+    assert(proj_true == Predicates::skip_all_predicates(parse_predicates),\n+           \"must hold by construction if at least one Parse Predicate\");\n","filename":"src\/hotspot\/share\/opto\/loopUnswitch.cpp","additions":7,"deletions":22,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -564,4 +564,4 @@\n-    Node *cont = _igvn.intcon(1);\n-    Node* opq = new Opaque1Node(C, cont);\n-    _igvn.register_new_node_with_optimizer(opq);\n-    Node *bol = new Conv2BNode(opq);\n+    Node* cont = _igvn.intcon(1);\n+    Node* opaq = new Opaque1Node(C, cont);\n+    _igvn.register_new_node_with_optimizer(opaq);\n+    Node* bol = new Conv2BNode(opaq);\n@@ -570,1 +570,1 @@\n-    IfNode* iff = new IfNode(inner_head->in(LoopNode::EntryControl), bol, PROB_MAX, COUNT_UNKNOWN);\n+    ParsePredicateNode* iff = new ParsePredicateNode(inner_head->in(LoopNode::EntryControl), bol, reason);\n@@ -572,5 +572,5 @@\n-    Node* iffalse = new IfFalseNode(iff);\n-    register_control(iffalse, _ltree_root, iff);\n-    Node* iftrue = new IfTrueNode(iff);\n-    register_control(iftrue, loop, iff);\n-    C->add_parse_predicate_opaq(opq);\n+    Node* if_false = new IfFalseNode(iff);\n+    register_control(if_false, _ltree_root, iff);\n+    Node* if_true = new IfTrueNode(iff);\n+    register_control(if_true, loop, iff);\n+    C->add_parse_predicate_opaq(opaq);\n@@ -600,1 +600,1 @@\n-    unc->init_req(TypeFunc::Control, iffalse);\n+    unc->init_req(TypeFunc::Control, if_false);\n@@ -612,1 +612,1 @@\n-    register_control(unc, _ltree_root, iffalse);\n+    register_control(unc, _ltree_root, if_false);\n@@ -620,2 +620,2 @@\n-    _igvn.replace_input_of(inner_head, LoopNode::EntryControl, iftrue);\n-    set_idom(inner_head, iftrue, dom_depth(inner_head));\n+    _igvn.replace_input_of(inner_head, LoopNode::EntryControl, if_true);\n+    set_idom(inner_head, if_true, dom_depth(inner_head));\n@@ -1791,3 +1791,1 @@\n-    ParsePredicateSuccessProj* loop_limit_check_predicate_parse_proj =\n-        find_predicate_insertion_point(init_control, Deoptimization::Reason_loop_limit_check);\n-    if (loop_limit_check_predicate_parse_proj == nullptr) {\n+    if (!ParsePredicates::is_loop_limit_check_predicate_proj(init_control)) {\n@@ -1805,1 +1803,2 @@\n-    IfNode* check_iff = loop_limit_check_predicate_parse_proj->in(0)->as_If();\n+    ParsePredicateSuccessProj* loop_limit_check_parse_predicate_proj = init_control->as_IfTrue();\n+    ParsePredicateNode* parse_predicate = loop_limit_check_parse_predicate_proj->in(0)->as_ParsePredicate();\n@@ -1807,1 +1806,1 @@\n-    if (!is_dominator(get_ctrl(limit), check_iff->in(0))) {\n+    if (!is_dominator(get_ctrl(limit), parse_predicate->in(0))) {\n@@ -1822,1 +1821,1 @@\n-    insert_loop_limit_check_predicate(loop_limit_check_predicate_parse_proj, cmp_limit, bol);\n+    insert_loop_limit_check_predicate(loop_limit_check_parse_predicate_proj, cmp_limit, bol);\n@@ -1835,3 +1834,1 @@\n-      ParsePredicateSuccessProj* loop_limit_check_predicate_parse_proj =\n-          find_predicate_insertion_point(init_control, Deoptimization::Reason_loop_limit_check);\n-      if (loop_limit_check_predicate_parse_proj == nullptr) {\n+      if (!ParsePredicates::is_loop_limit_check_predicate_proj(init_control)) {\n@@ -1848,1 +1845,2 @@\n-      IfNode* check_iff = loop_limit_check_predicate_parse_proj->in(0)->as_If();\n+      ParsePredicateSuccessProj* loop_limit_check_parse_predicate_proj = init_control->as_IfTrue();\n+      ParsePredicateNode* parse_predicate = init_control->in(0)->as_ParsePredicate();\n@@ -1850,2 +1848,2 @@\n-      if (!is_dominator(get_ctrl(limit), check_iff->in(0)) ||\n-          !is_dominator(get_ctrl(init_trip), check_iff->in(0))) {\n+      if (!is_dominator(get_ctrl(limit), parse_predicate->in(0)) ||\n+          !is_dominator(get_ctrl(init_trip), parse_predicate->in(0))) {\n@@ -1866,1 +1864,1 @@\n-      insert_loop_limit_check_predicate(loop_limit_check_predicate_parse_proj, cmp_limit, bol);\n+      insert_loop_limit_check_predicate(loop_limit_check_parse_predicate_proj, cmp_limit, bol);\n@@ -3957,3 +3955,4 @@\n-  Node* entry = _head->is_Loop() ? _head->as_Loop()->skip_strip_mined(-1)->in(LoopNode::EntryControl) : _head->in(LoopNode::EntryControl);\n-  Node* predicate = PhaseIdealLoop::find_predicate_insertion_point(entry, Deoptimization::Reason_loop_limit_check);\n-  if (predicate != nullptr ) {\n+  Node* entry = _head->is_Loop() ? _head->as_Loop()->skip_strip_mined(-1)->in(LoopNode::EntryControl)\n+                                 : _head->in(LoopNode::EntryControl);\n+  ParsePredicates parse_predicates(entry);\n+  if (parse_predicates.loop_limit_check_predicate_proj() != nullptr) {\n@@ -3961,1 +3960,0 @@\n-    entry = PhaseIdealLoop::skip_related_predicates(entry);\n@@ -3963,6 +3961,2 @@\n-  if (UseProfiledLoopPredicate) {\n-    predicate = PhaseIdealLoop::find_predicate_insertion_point(entry, Deoptimization::Reason_profile_predicate);\n-    if (predicate != nullptr) {\n-      tty->print(\" profile_predicated\");\n-      entry = PhaseIdealLoop::skip_related_predicates(entry);\n-    }\n+  if (UseProfiledLoopPredicate && parse_predicates.profiled_loop_predicate_proj() != nullptr) {\n+    tty->print(\" profile_predicated\");\n@@ -3970,5 +3964,2 @@\n-  if (UseLoopPredicate) {\n-    predicate = PhaseIdealLoop::find_predicate_insertion_point(entry, Deoptimization::Reason_predicate);\n-    if (predicate != nullptr) {\n-      tty->print(\" predicated\");\n-    }\n+  if (UseLoopPredicate && parse_predicates.loop_predicate_proj() != nullptr) {\n+    tty->print(\" predicated\");\n@@ -4081,6 +4072,5 @@\n-\n-    Node* predicate = find_predicate_insertion_point(entry, Deoptimization::Reason_loop_limit_check);\n-    if (predicate != nullptr) { \/\/ right pattern that can be used by loop predication\n-      assert(entry->in(0)->in(1)->in(1)->Opcode() == Op_Opaque1, \"must be\");\n-      useful_predicates.push(entry->in(0)->in(1)->in(1)); \/\/ good one\n-      entry = skip_related_predicates(entry);\n+    ParsePredicates parse_predicates(entry);\n+    ProjNode* predicate_proj = parse_predicates.loop_limit_check_predicate_proj();\n+    if (predicate_proj != nullptr) { \/\/ right pattern that can be used by loop predication\n+      assert(predicate_proj->in(0)->in(1)->in(1)->Opcode() == Op_Opaque1, \"must be\");\n+      useful_predicates.push(predicate_proj->in(0)->in(1)->in(1)); \/\/ good one\n@@ -4089,5 +4079,4 @@\n-      predicate = find_predicate_insertion_point(entry, Deoptimization::Reason_profile_predicate);\n-      if (predicate != nullptr) { \/\/ right pattern that can be used by loop predication\n-        useful_predicates.push(entry->in(0)->in(1)->in(1)); \/\/ good one\n-        get_assertion_predicates(entry, useful_predicates, true);\n-        entry = skip_related_predicates(entry);\n+      predicate_proj = parse_predicates.profiled_loop_predicate_proj();\n+      if (predicate_proj != nullptr) { \/\/ right pattern that can be used by loop predication\n+        useful_predicates.push(predicate_proj->in(0)->in(1)->in(1)); \/\/ good one\n+        get_assertion_predicates(predicate_proj, useful_predicates, true);\n@@ -4098,4 +4087,4 @@\n-      predicate = find_predicate_insertion_point(entry, Deoptimization::Reason_predicate);\n-      if (predicate != nullptr) { \/\/ right pattern that can be used by loop predication\n-        useful_predicates.push(entry->in(0)->in(1)->in(1)); \/\/ good one\n-        get_assertion_predicates(entry, useful_predicates, true);\n+      predicate_proj = parse_predicates.loop_predicate_proj();\n+      if (predicate_proj != nullptr) { \/\/ right pattern that can be used by loop predication\n+        useful_predicates.push(predicate_proj->in(0)->in(1)->in(1)); \/\/ good one\n+        get_assertion_predicates(predicate_proj, useful_predicates, true);\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":46,"deletions":57,"binary":false,"changes":103,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+class ParsePredicates;\n@@ -1363,40 +1364,0 @@\n-  static Node* skip_all_predicates(Node* entry);\n-  static Node* skip_related_predicates(Node* entry);\n-  static IfProjNode* next_predicate(IfProjNode* predicate_proj);\n-\n-  \/\/ Find a good location to insert a predicate\n-  static ParsePredicateSuccessProj* find_predicate_insertion_point(Node* start_c, Deoptimization::DeoptReason reason);\n-\n-  class ParsePredicates {\n-   private:\n-    ParsePredicateSuccessProj* _loop_predicate = nullptr;\n-    ParsePredicateSuccessProj* _profiled_loop_predicate = nullptr;\n-    ParsePredicateSuccessProj* _loop_limit_check_predicate = nullptr;\n-    Node* _first_predicate = nullptr;\n-   public:\n-    \/\/ given loop entry, find all predicates above loop\n-    ParsePredicates(Node* entry);\n-\n-    \/\/ Proj of Loop Limit Check Parse Predicate.\n-    ParsePredicateSuccessProj* loop_limit_check_predicate() {\n-      return _loop_limit_check_predicate;\n-    }\n-\n-    \/\/ Proj of Profile Loop Parse Predicate.\n-    ParsePredicateSuccessProj* profiled_loop_predicate() {\n-      return _profiled_loop_predicate;\n-    }\n-\n-    \/\/ Proj of Loop Parse Predicate.\n-    ParsePredicateSuccessProj* loop_predicate() {\n-      return _loop_predicate;\n-    }\n-\n-    \/\/ Proj of first Parse Predicate when walking the graph down from root.\n-    Node* get_first_predicate() {\n-      return _first_predicate;\n-    }\n-  };\n-\n-  \/\/ Find a predicate\n-  static Node* find_parse_predicate(Node* entry);\n@@ -1680,1 +1641,1 @@\n-  static void check_cloned_parse_predicate_for_unswitching(const Node* new_entry) PRODUCT_RETURN;\n+  static void check_cloned_parse_predicate_for_unswitching(const Node* new_entry, bool is_fast_loop) PRODUCT_RETURN;\n@@ -1952,0 +1913,59 @@\n+\/\/ Utility class to work on predicates.\n+class Predicates {\n+ public:\n+  static Node* skip_all_predicates(Node* node);\n+  static Node* skip_all_predicates(ParsePredicates& parse_predicates);\n+  static Node* skip_predicates_in_block(ParsePredicateSuccessProj* parse_predicate_success_proj);\n+  static IfProjNode* next_predicate_proj_in_block(IfProjNode* proj);\n+  static bool has_profiled_loop_predicates(ParsePredicates& parse_predicates);\n+};\n+\n+\/\/ Class representing the Parse Predicates that are added during parsing with ParsePredicateNodes.\n+class ParsePredicates {\n+ private:\n+  ParsePredicateSuccessProj* _loop_predicate_proj = nullptr;\n+  ParsePredicateSuccessProj* _profiled_loop_predicate_proj = nullptr;\n+  ParsePredicateSuccessProj* _loop_limit_check_predicate_proj = nullptr;\n+  \/\/ The success projection of the Parse Predicate that comes first when starting from root.\n+  ParsePredicateSuccessProj* _top_predicate_proj;\n+  ParsePredicateSuccessProj* _starting_proj;\n+\n+  void find_parse_predicate_projections();\n+  static bool is_uct_proj(Node* node, Deoptimization::DeoptReason deopt_reason);\n+  static ParsePredicateNode* get_parse_predicate_or_null(Node* proj);\n+  bool assign_predicate_proj(ParsePredicateSuccessProj* parse_predicate_proj);\n+ public:\n+  ParsePredicates(Node* starting_proj);\n+\n+  \/\/ Success projection of Loop Parse Predicate.\n+  ParsePredicateSuccessProj* loop_predicate_proj() {\n+    return _loop_predicate_proj;\n+  }\n+\n+  \/\/ Success proj of Profiled Loop Parse Predicate.\n+  ParsePredicateSuccessProj* profiled_loop_predicate_proj() {\n+    return _profiled_loop_predicate_proj;\n+  }\n+\n+  \/\/ Success proj of Loop Limit Check Parse Predicate.\n+  ParsePredicateSuccessProj* loop_limit_check_predicate_proj() {\n+    return _loop_limit_check_predicate_proj;\n+  }\n+\n+  \/\/ Return the success projection of the Parse Predicate that comes first when starting from root.\n+  ParsePredicateSuccessProj* get_top_predicate_proj() {\n+    return _top_predicate_proj;\n+  }\n+\n+  static bool is_success_proj(Node* node);\n+\n+  \/\/ Are there any Parse Predicates?\n+  bool has_any() const {\n+    return _top_predicate_proj != nullptr;\n+  }\n+\n+  static bool is_loop_limit_check_predicate_proj(Node* node) {\n+    ParsePredicateNode* parse_predicate = get_parse_predicate_or_null(node);\n+    return parse_predicate != nullptr && parse_predicate->deopt_reason() == Deoptimization::DeoptReason::Reason_loop_limit_check;\n+  }\n+};\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":61,"deletions":41,"binary":false,"changes":102,"status":"modified"},{"patch":"@@ -264,1 +264,2 @@\n-         iff->Opcode() == Op_RangeCheck,\n+         iff->Opcode() == Op_RangeCheck ||\n+         iff->Opcode() == Op_ParsePredicate,\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -142,0 +142,1 @@\n+class ParsePredicateNode;\n@@ -669,0 +670,1 @@\n+          DEFINE_CLASS_ID(ParsePredicate,         If, 3)\n@@ -941,0 +943,1 @@\n+  DEFINE_CLASS_QUERY(ParsePredicate)\n@@ -1022,0 +1025,5 @@\n+  \/\/ Is 'n' possibly a loop entry (i.e. a Parse Predicate projection)?\n+  static bool may_be_loop_entry(Node* n) {\n+    return n != nullptr && n->is_IfProj() && n->in(0)->is_ParsePredicate();\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"}]}