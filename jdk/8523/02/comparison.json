{"files":[{"patch":"@@ -28,4 +28,0 @@\n-import java.util.*;\n-\n-import javax.lang.model.element.TypeElement;\n-\n@@ -33,1 +29,0 @@\n-import jdk.javadoc.internal.doclets.formats.html.markup.TagName;\n@@ -35,0 +30,1 @@\n+import jdk.javadoc.internal.doclets.formats.html.markup.TagName;\n@@ -37,0 +33,1 @@\n+import jdk.javadoc.internal.doclets.toolkit.util.ClassTree.Hierarchy;\n@@ -39,0 +36,5 @@\n+import javax.lang.model.element.TypeElement;\n+import java.util.Collection;\n+import java.util.SortedSet;\n+import java.util.TreeSet;\n+\n@@ -51,1 +53,1 @@\n-    protected final ClassTree classtree;\n+    protected final ClassTree classTree;\n@@ -54,2 +56,1 @@\n-     * Constructor initializes classtree variable. This constructor will be used\n-     * while generating global tree file \"overview-tree.html\".\n+     * Constructor. This constructor will be used while generating global tree file \"overview-tree.html\".\n@@ -59,1 +60,1 @@\n-     * @param classtree  Tree built by {@link ClassTree}.\n+     * @param classTree  Tree built by {@link ClassTree}.\n@@ -62,1 +63,1 @@\n-                                 DocPath filename, ClassTree classtree) {\n+                                 DocPath filename, ClassTree classTree) {\n@@ -64,1 +65,1 @@\n-        this.classtree = classtree;\n+        this.classTree = classTree;\n@@ -74,1 +75,1 @@\n-     * @param isEnum true if we are generating a tree for enums\n+     * @param hierarchy the hierarchy for which we are generating a tree\n@@ -78,1 +79,1 @@\n-            boolean isEnum, Content content) {\n+                                Hierarchy hierarchy, Content content) {\n@@ -86,2 +87,1 @@\n-                addLevelInfo(local, classtree.directSubClasses(local, isEnum),\n-                             isEnum, li);   \/\/ Recurse\n+                addLevelInfo(local, hierarchy.subtypes(local), hierarchy, li);   \/\/ Recurse\n@@ -95,2 +95,1 @@\n-     * Add the heading for the tree depending upon tree type if it's a\n-     * Class Tree or Interface tree.\n+     * Adds a class or interface hierarchy with a given heading to given content.\n@@ -98,4 +97,3 @@\n-     * @param sset classes which are at the most base level, all the\n-     * other classes in this run will derive from these classes\n-     * @param heading heading for the tree\n-     * @param content the content to which the tree will be added\n+     * @param hierarchy the hierarchy to add\n+     * @param heading   the heading\n+     * @param content   the content to which to add the hierarchy\n@@ -103,8 +101,4 @@\n-    protected void addTree(SortedSet<TypeElement> sset, String heading, Content content) {\n-        addTree(sset, heading, content, false);\n-    }\n-\n-    protected void addTree(SortedSet<TypeElement> sset, String heading,\n-                           Content content, boolean isEnums) {\n-        if (!sset.isEmpty()) {\n-            TypeElement firstTypeElement = sset.first();\n+    protected void addTree(Hierarchy hierarchy, String heading, Content content) {\n+        SortedSet<TypeElement> roots = hierarchy.roots();\n+        if (!roots.isEmpty()) {\n+            TypeElement firstTypeElement = roots.first();\n@@ -116,1 +110,1 @@\n-                    sset, isEnums, section);\n+                    roots, hierarchy, section);\n@@ -122,2 +116,1 @@\n-     * Add information regarding the classes which this class extends or\n-     * implements.\n+     * Add information regarding the classes which this class extends or implements.\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/AbstractTreeWriter.java","additions":25,"deletions":32,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -146,1 +146,1 @@\n-     * @param classtree the class tree hierarchy\n+     * @param classTree the class tree hierarchy\n@@ -149,2 +149,2 @@\n-    public static void generate(HtmlConfiguration configuration, ClassTree classtree) throws DocFileIOException  {\n-        ClassUseMapper mapper = new ClassUseMapper(configuration, classtree);\n+    public static void generate(HtmlConfiguration configuration, ClassTree classTree) throws DocFileIOException  {\n+        ClassUseMapper mapper = new ClassUseMapper(configuration, classTree);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/ClassUseWriter.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -80,1 +80,1 @@\n-    protected final ClassTree classtree;\n+    protected final ClassTree classTree;\n@@ -92,1 +92,1 @@\n-        this.classtree = classTree;\n+        this.classTree = classTree;\n@@ -288,1 +288,1 @@\n-            Set<TypeElement> subclasses = classtree.directSubClasses(typeElement, false);\n+            Set<TypeElement> subclasses = classTree.hierarchy(typeElement).subtypes(typeElement);\n@@ -301,1 +301,1 @@\n-            Set<TypeElement> subInterfaces = classtree.allSubClasses(typeElement, false);\n+            Set<TypeElement> subInterfaces = classTree.hierarchy(typeElement).allSubtypes(typeElement);\n@@ -321,1 +321,1 @@\n-        Set<TypeElement> implcl = classtree.implementingClasses(typeElement);\n+        Set<TypeElement> implcl = classTree.implementingClasses(typeElement);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/ClassWriterImpl.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -206,1 +206,1 @@\n-    protected void generateOtherFiles(ClassTree classtree)\n+    protected void generateOtherFiles(ClassTree classTree)\n@@ -208,1 +208,1 @@\n-        super.generateOtherFiles(classtree);\n+        super.generateOtherFiles(classTree);\n@@ -231,1 +231,1 @@\n-            ClassUseWriter.generate(configuration, classtree);\n+            ClassUseWriter.generate(configuration, classTree);\n@@ -235,1 +235,1 @@\n-            TreeWriter.generate(configuration, classtree);\n+            TreeWriter.generate(configuration, classTree);\n@@ -395,1 +395,1 @@\n-    protected void generatePackageFiles(ClassTree classtree) throws DocletException {\n+    protected void generatePackageFiles(ClassTree classTree) throws DocletException {\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/HtmlDoclet.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-import jdk.javadoc.internal.doclets.formats.html.markup.TagName;\n@@ -106,4 +105,5 @@\n-        addTree(classtree.baseClasses(), \"doclet.Class_Hierarchy\", mainContent);\n-        addTree(classtree.baseInterfaces(), \"doclet.Interface_Hierarchy\", mainContent);\n-        addTree(classtree.baseAnnotationTypes(), \"doclet.Annotation_Type_Hierarchy\", mainContent);\n-        addTree(classtree.baseEnums(), \"doclet.Enum_Hierarchy\", mainContent, true);\n+        addTree(classTree.classes(), \"doclet.Class_Hierarchy\", mainContent);\n+        addTree(classTree.interfaces(), \"doclet.Interface_Hierarchy\", mainContent);\n+        addTree(classTree.annotationInterfaces(), \"doclet.Annotation_Type_Hierarchy\", mainContent);\n+        addTree(classTree.enumClasses(), \"doclet.Enum_Hierarchy\", mainContent);\n+        addTree(classTree.recordClasses(), \"doclet.Record_Class_Hierarchy\", mainContent);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/PackageTreeWriter.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -69,1 +69,1 @@\n-     * @param classtree the tree being built.\n+     * @param classTree the tree being built.\n@@ -71,2 +71,2 @@\n-    public TreeWriter(HtmlConfiguration configuration, DocPath filename, ClassTree classtree) {\n-        super(configuration, filename, classtree);\n+    public TreeWriter(HtmlConfiguration configuration, DocPath filename, ClassTree classTree) {\n+        super(configuration, filename, classTree);\n@@ -83,1 +83,1 @@\n-     * @param classtree the class tree being documented.\n+     * @param classTree the class tree being documented.\n@@ -87,1 +87,1 @@\n-                                ClassTree classtree) throws DocFileIOException {\n+                                ClassTree classTree) throws DocFileIOException {\n@@ -89,1 +89,1 @@\n-        TreeWriter treegen = new TreeWriter(configuration, filename, classtree);\n+        TreeWriter treegen = new TreeWriter(configuration, filename, classTree);\n@@ -107,4 +107,5 @@\n-        addTree(classtree.baseClasses(), \"doclet.Class_Hierarchy\", mainContent);\n-        addTree(classtree.baseInterfaces(), \"doclet.Interface_Hierarchy\", mainContent);\n-        addTree(classtree.baseAnnotationTypes(), \"doclet.Annotation_Type_Hierarchy\", mainContent);\n-        addTree(classtree.baseEnums(), \"doclet.Enum_Hierarchy\", mainContent, true);\n+        addTree(classTree.classes(), \"doclet.Class_Hierarchy\", mainContent);\n+        addTree(classTree.interfaces(), \"doclet.Interface_Hierarchy\", mainContent);\n+        addTree(classTree.annotationInterfaces(), \"doclet.Annotation_Type_Hierarchy\", mainContent);\n+        addTree(classTree.enumClasses(), \"doclet.Enum_Hierarchy\", mainContent);\n+        addTree(classTree.recordClasses(), \"doclet.Record_Class_Hierarchy\", mainContent);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/TreeWriter.java","additions":11,"deletions":10,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+doclet.Record_Class_Hierarchy=Record Class Hierarchy\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/resources\/standard.properties","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -205,1 +205,1 @@\n-        ClassTree classtree = new ClassTree(configuration, configuration.getOptions().noDeprecated());\n+        ClassTree classTree = new ClassTree(configuration);\n@@ -207,1 +207,1 @@\n-        generateClassFiles(classtree);\n+        generateClassFiles(classTree);\n@@ -210,1 +210,1 @@\n-        generatePackageFiles(classtree);\n+        generatePackageFiles(classTree);\n@@ -213,1 +213,1 @@\n-        generateOtherFiles(classtree);\n+        generateOtherFiles(classTree);\n@@ -220,1 +220,1 @@\n-     * @param classtree the data structure representing the class tree\n+     * @param classTree the data structure representing the class tree\n@@ -223,1 +223,1 @@\n-    protected void generateOtherFiles(ClassTree classtree) throws DocletException {\n+    protected void generateOtherFiles(ClassTree classTree) throws DocletException {\n@@ -242,1 +242,1 @@\n-     * @param classtree the data structure representing the class tree\n+     * @param classTree the data structure representing the class tree\n@@ -245,1 +245,1 @@\n-    protected abstract void generatePackageFiles(ClassTree classtree) throws DocletException;\n+    protected abstract void generatePackageFiles(ClassTree classTree) throws DocletException;\n@@ -251,1 +251,1 @@\n-     * @param classtree the data structure representing the class tree\n+     * @param classTree the data structure representing the class tree\n@@ -254,1 +254,1 @@\n-    protected abstract void generateClassFiles(SortedSet<TypeElement> arr, ClassTree classtree)\n+    protected abstract void generateClassFiles(SortedSet<TypeElement> arr, ClassTree classTree)\n@@ -260,1 +260,1 @@\n-     * @param classtree the data structure representing the class tree\n+     * @param classTree the data structure representing the class tree\n@@ -263,1 +263,1 @@\n-    protected void generateClassFiles(ClassTree classtree)\n+    protected void generateClassFiles(ClassTree classTree)\n@@ -281,1 +281,1 @@\n-        generateClassFiles(classes, classtree);\n+        generateClassFiles(classes, classTree);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/AbstractDoclet.java","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import java.util.Collection;\n@@ -33,0 +32,1 @@\n+import java.util.EnumMap;\n@@ -34,1 +34,0 @@\n-import java.util.Iterator;\n@@ -45,1 +44,0 @@\n-import jdk.javadoc.doclet.DocletEnvironment;\n@@ -50,2 +48,1 @@\n- * Build Class Hierarchy for all the Classes. This class builds the Class\n- * Tree and the Interface Tree separately.\n+ * Class and interface hierarchies.\n@@ -56,1 +53,3 @@\n-     * List of base classes. Used to get the mapped listing of sub-classes.\n+     * The kind of hierarchy.\n+     * Currently, the kinds correspond to the kinds of declared types,\n+     * although other partitions could be possible.\n@@ -58,1 +57,3 @@\n-    private final SortedSet<TypeElement> baseClasses;\n+    private enum HierarchyKind {\n+        CLASSES, ENUM_CLASSES, RECORD_CLASSES, INTERFACES, ANNOTATION_INTERFACES\n+    }\n@@ -61,1 +62,2 @@\n-     * Mapping for each Class with their sub classes\n+     * A \"hierarchy\" provides the subtypes of all the supertypes of a set of leaf elements,\n+     * together with the root supertype(s).\n@@ -63,1 +65,60 @@\n-    private final Map<TypeElement, SortedSet<TypeElement>> subClasses = new HashMap<>();\n+    public static class Hierarchy {\n+        private final SortedSet<TypeElement> roots;\n+        private final SubtypeMap subtypes;\n+        private final Comparator<Element> comparator;\n+\n+        Hierarchy(Comparator<Element> comparator) {\n+            this.comparator = comparator;\n+            roots = new TreeSet<>(comparator);\n+            subtypes = new SubtypeMap(comparator);\n+        }\n+\n+        \/**\n+         * {@return the roots of the hierarchy}\n+         * The roots are the classes or interfaces with no superclass or superinterfaces.\n+         * If the hierarchy just contains classes, the root will be {@code java.lang.Object}.\n+         *\/\n+        public SortedSet<TypeElement> roots() {\n+            return roots;\n+        }\n+\n+        \/**\n+         * {@return a map containing the type elements in this hierarchy and their subtypes}\n+         *\/\n+        public Map<TypeElement, SortedSet<TypeElement>> subtypes() {\n+            return subtypes;\n+        }\n+\n+        \/**\n+         * {@return the immediate subtypes of the given type element, or an empty set if there are none}\n+         * @param typeElement the type element\n+         *\/\n+        public SortedSet<TypeElement> subtypes(TypeElement typeElement) {\n+            return subtypes.getOrDefault(typeElement, Collections.emptySortedSet());\n+        }\n+\n+        \/**\n+         * {@return the set of all subtypes of the given type element, or an empty set if there are none}\n+         *\n+         * The set of all subtypes is the transitive closure of the {@linkplain #subtypes() immediate subtypes}\n+         * of the given type element.\n+         *\n+         * @param typeElement the type element\n+         *\/\n+        public SortedSet<TypeElement> allSubtypes(TypeElement typeElement) {\n+            \/\/ new entries added to the collection are searched as well;\n+            \/\/ this is really a work queue.\n+            List<TypeElement> list = new ArrayList<>(subtypes(typeElement));\n+            for (int i = 0; i < list.size(); i++) {\n+                var subtypes = subtypes(list.get(i));\n+                for (var subtype : subtypes) {\n+                    if (!list.contains(subtype)) {\n+                        list.add(subtype);\n+                    }\n+                }\n+            }\n+            SortedSet<TypeElement> out = new TreeSet<>(comparator);\n+            out.addAll(list);\n+            return out;\n+        }\n+    }\n@@ -66,3 +127,4 @@\n-     * List of base-interfaces. Contains set of all the interfaces who do not\n-     * have super-interfaces. Can be used to get the mapped listing of\n-     * sub-interfaces.\n+     * A map giving the subtypes for each of a collection of type elements.\n+     * The subtypes may be subclasses or subinterfaces, depending on the context.\n+     *\n+     * The subtypes are recorded by calling {@link SubtypeMap#addSubtype(TypeElement, TypeElement) addSubtype}.\n@@ -70,1 +132,16 @@\n-    private final SortedSet<TypeElement> baseInterfaces;\n+    @SuppressWarnings(\"serial\")\n+    private static class SubtypeMap extends HashMap<TypeElement, SortedSet<TypeElement>> {\n+        private final Comparator<Element> comparator;\n+\n+        \/**\n+         * Creates a map to provide the subtypes of a type element,\n+         * sorted according to a given comparator.\n+         *\n+         * An alternate implementation would be to store the subtypes unsorted,\n+         * and to lazily sort them when needed, such as when generating documentation.\n+         *\n+         * @param comparator the comparator\n+         *\/\n+        SubtypeMap(Comparator<Element> comparator) {\n+            this.comparator = comparator;\n+        }\n@@ -72,4 +149,8 @@\n-   \/**\n-    * Mapping for each Interface with their SubInterfaces\n-    *\/\n-    private final Map<TypeElement, SortedSet<TypeElement>> subInterfaces = new HashMap<>();\n+        \/**\n+         * {@return the subtypes for a type element, or an empty set if there are none}\n+         *\n+         * @param typeElement the type element\n+         *\/\n+        SortedSet<TypeElement> getSubtypes(TypeElement typeElement) {\n+            return computeIfAbsent(typeElement, te -> new TreeSet<>(comparator));\n+        }\n@@ -77,2 +158,11 @@\n-    private final SortedSet<TypeElement> baseEnums;\n-    private final Map<TypeElement, SortedSet<TypeElement>> subEnums = new HashMap<>();\n+        \/**\n+         * Adds a subtype into the set of subtypes for a type element\n+         *\n+         * @param typeElement the type element\n+         * @param subtype the subtype\n+         * @return {@code true} if this set did not already contain the specified element\n+         *\/\n+        boolean addSubtype(TypeElement typeElement, TypeElement subtype) {\n+            return getSubtypes(typeElement).add(subtype);\n+        }\n+    }\n@@ -80,2 +170,4 @@\n-    private final SortedSet<TypeElement> baseAnnotationTypes;\n-    private final Map<TypeElement, SortedSet<TypeElement>> subAnnotationTypes = new HashMap<>();\n+    \/**\n+     * The collection of hierarchies, indexed by kind.\n+     *\/\n+    private final Map<HierarchyKind, Hierarchy> hierarchies;\n@@ -84,1 +176,1 @@\n-    * Mapping for each Interface with classes who implement it.\n+    * Mapping for each interface with classes that implement it.\n@@ -86,1 +178,1 @@\n-    private final Map<TypeElement, SortedSet<TypeElement>> implementingClasses = new HashMap<>();\n+    private final SubtypeMap implementingClasses;\n@@ -90,1 +182,0 @@\n-    private final Comparator<Element> comparator;\n@@ -93,1 +184,1 @@\n-     * Constructor. Build the Tree using the Root of this Javadoc run.\n+     * Constructor. Build the tree for all the included type elements.\n@@ -95,3 +186,1 @@\n-     * @param configuration the configuration of the doclet.\n-     * @param noDeprecated Don't add deprecated classes in the class tree, if\n-     * true.\n+     * @param configuration the configuration of the doclet\n@@ -99,1 +188,1 @@\n-    public ClassTree(BaseConfiguration configuration, boolean noDeprecated) {\n+    public ClassTree(BaseConfiguration configuration) {\n@@ -106,7 +195,7 @@\n-        comparator = utils.comparators.makeClassUseComparator();\n-        baseAnnotationTypes = new TreeSet<>(comparator);\n-        baseEnums = new TreeSet<>(comparator);\n-        baseClasses = new TreeSet<>(comparator);\n-        baseInterfaces = new TreeSet<>(comparator);\n-        buildTree(configuration.getIncludedTypeElements());\n-    }\n+        Comparator<Element> comparator = utils.comparators.makeClassUseComparator();\n+\n+        hierarchies = new EnumMap<>(HierarchyKind.class);\n+        for (var hk : HierarchyKind.values()) {\n+            hierarchies.put(hk, new Hierarchy(comparator));\n+        }\n+        implementingClasses = new SubtypeMap(comparator);\n@@ -114,14 +203,0 @@\n-    \/**\n-     * Constructor. Build the Tree using the Root of this Javadoc run.\n-     *\n-     * @param docEnv the DocletEnvironment.\n-     * @param configuration The current configuration of the doclet.\n-     *\/\n-    public ClassTree(DocletEnvironment docEnv, BaseConfiguration configuration) {\n-        this.configuration = configuration;\n-        this.utils = configuration.utils;\n-        comparator = utils.comparators.makeClassUseComparator();\n-        baseAnnotationTypes = new TreeSet<>(comparator);\n-        baseEnums = new TreeSet<>(comparator);\n-        baseClasses = new TreeSet<>(comparator);\n-        baseInterfaces = new TreeSet<>(comparator);\n@@ -132,1 +207,1 @@\n-     * Constructor. Build the tree for the given array of classes.\n+     * Constructor. Build the tree for the given collection of classes.\n@@ -137,1 +212,1 @@\n-    public ClassTree(SortedSet<TypeElement>classesSet, BaseConfiguration configuration) {\n+    public ClassTree(SortedSet<TypeElement> classesSet, BaseConfiguration configuration) {\n@@ -140,5 +215,9 @@\n-        comparator = utils.comparators.makeClassUseComparator();\n-        baseAnnotationTypes = new TreeSet<>(comparator);\n-        baseEnums = new TreeSet<>(comparator);\n-        baseClasses = new TreeSet<>(comparator);\n-        baseInterfaces = new TreeSet<>(comparator);\n+\n+        Comparator<Element> comparator = utils.comparators.makeClassUseComparator();\n+\n+        hierarchies = new EnumMap<>(HierarchyKind.class);\n+        for (var hk : HierarchyKind.values()) {\n+            hierarchies.put(hk, new Hierarchy(comparator));\n+        }\n+        implementingClasses = new SubtypeMap(comparator);\n+\n@@ -149,4 +228,1 @@\n-     * Generate mapping for the sub-classes for every class in this run.\n-     * Return the sub-class set for java.lang.Object which will be having\n-     * sub-class listing for itself and also for each sub-class itself will\n-     * have their own sub-class lists.\n+     * Generate the hierarchies for the given set of type elements.\n@@ -154,1 +230,1 @@\n-     * @param classes all the classes in this run.\n+     * @param typeElements the type elements\n@@ -156,2 +232,2 @@\n-    private void buildTree(Iterable<TypeElement> classes) {\n-        for (TypeElement aClass : classes) {\n+    private void buildTree(Iterable<TypeElement> typeElements) {\n+        for (TypeElement te : typeElements) {\n@@ -162,2 +238,2 @@\n-                    (utils.isDeprecated(aClass) ||\n-                    utils.isDeprecated(utils.containingPackage(aClass)))) {\n+                    (utils.isDeprecated(te) ||\n+                    utils.isDeprecated(utils.containingPackage(te)))) {\n@@ -167,1 +243,1 @@\n-            if (utils.hasHiddenTag(aClass)) {\n+            if (utils.hasHiddenTag(te)) {\n@@ -171,9 +247,10 @@\n-            if (utils.isEnum(aClass)) {\n-                processType(aClass, configuration, baseEnums, subEnums);\n-            } else if (utils.isClass(aClass)) {\n-                processType(aClass, configuration, baseClasses, subClasses);\n-            } else if (utils.isPlainInterface(aClass)) {\n-                processInterface(aClass);\n-            } else if (utils.isAnnotationInterface(aClass)) {\n-                processType(aClass, configuration, baseAnnotationTypes,\n-                    subAnnotationTypes);\n+            if (utils.isEnum(te)) {\n+                processType(te, hierarchies.get(HierarchyKind.ENUM_CLASSES));\n+            } else if (utils.isRecord(te)) {\n+                processType(te, hierarchies.get(HierarchyKind.RECORD_CLASSES));\n+            } else if (utils.isClass(te)) {\n+                processType(te, hierarchies.get(HierarchyKind.CLASSES));\n+            } else if (utils.isPlainInterface(te)) {\n+                processInterface(te);\n+            } else if (utils.isAnnotationInterface(te)) {\n+                processType(te, hierarchies.get(HierarchyKind.ANNOTATION_INTERFACES));\n@@ -185,7 +262,4 @@\n-     * For the class passed map it to its own sub-class listing.\n-     * For the Class passed, get the super class,\n-     * if superclass is non null, (it is not \"java.lang.Object\")\n-     * get the \"value\" from the hashmap for this key Class\n-     * if entry not found create one and get that.\n-     * add this Class as a sub class in the set\n-     * Recurse till hits java.lang.Object Null SuperClass.\n+     * Adds details for a type element into a given hierarchy.\n+     *\n+     * The subtypes are updated for the transitive closure of all supertypes of this type element.\n+     * If this type element has no superclass or superinterfaces, it is marked as a root.\n@@ -193,2 +267,2 @@\n-     * @param typeElement for which sub class mapping is to be generated.\n-     * @param configuration the current configuration of the doclet.\n+     * @param typeElement for which the hierarchy is to be generated\n+     * @param hierarchy the hierarchy\n@@ -196,2 +270,1 @@\n-    private void processType(TypeElement typeElement, BaseConfiguration configuration,\n-            Collection<TypeElement> bases, Map<TypeElement, SortedSet<TypeElement>> subs) {\n+    private void processType(TypeElement typeElement, Hierarchy hierarchy) {\n@@ -200,1 +273,1 @@\n-            if (!add(subs, superclass, typeElement)) {\n+            if (!hierarchy.subtypes.addSubtype(superclass, typeElement)) {\n@@ -203,1 +276,1 @@\n-                processType(superclass, configuration, bases, subs);\n+                processType(superclass, hierarchy);\n@@ -206,3 +279,1 @@\n-            if (!bases.contains(typeElement)) {\n-                bases.add(typeElement);\n-            }\n+            hierarchy.roots.add(typeElement);\n@@ -210,3 +281,4 @@\n-        Set<TypeMirror> intfacs = utils.getAllInterfaces(typeElement);\n-        for (TypeMirror intfac : intfacs) {\n-            add(implementingClasses, utils.asTypeElement(intfac), typeElement);\n+\n+        Set<TypeMirror> interfaces = utils.getAllInterfaces(typeElement);\n+        for (TypeMirror t : interfaces) {\n+            implementingClasses.addSubtype(utils.asTypeElement(t), typeElement);\n@@ -219,1 +291,1 @@\n-     * recursively. If a interface doesn't have super-interface just attach\n+     * recursively. If an interface doesn't have super-interface just attach\n@@ -225,4 +297,5 @@\n-        List<? extends TypeMirror> intfacs = typeElement.getInterfaces();\n-        if (!intfacs.isEmpty()) {\n-            for (TypeMirror intfac : intfacs) {\n-                if (!add(subInterfaces, utils.asTypeElement(intfac), typeElement)) {\n+        Hierarchy interfacesHierarchy = hierarchies.get(HierarchyKind.INTERFACES);\n+        List<? extends TypeMirror> interfaces = typeElement.getInterfaces();\n+        if (!interfaces.isEmpty()) {\n+            for (TypeMirror t : interfaces) {\n+                if (!interfacesHierarchy.subtypes.addSubtype(utils.asTypeElement(t), typeElement)) {\n@@ -231,1 +304,1 @@\n-                    processInterface(utils.asTypeElement(intfac));   \/\/ Recurse\n+                    processInterface(utils.asTypeElement(t));   \/\/ Recurse\n@@ -236,22 +309,2 @@\n-            \/\/ super-interfaces to baseInterfaces set to traverse them\n-            if (!baseInterfaces.contains(typeElement)) {\n-                baseInterfaces.add(typeElement);\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Adjust the Class Tree. Add the class interface  in to it's super classes\n-     * or super interface's sub-interface set.\n-     *\n-     * @param map the entire map.\n-     * @param superclass java.lang.Object or the super-interface.\n-     * @param typeElement sub-interface to be mapped.\n-     * @return true if class added, false if class already processed.\n-     *\/\n-    private boolean add(Map<TypeElement, SortedSet<TypeElement>> map, TypeElement superclass, TypeElement typeElement) {\n-        SortedSet<TypeElement> sset = map.computeIfAbsent(superclass, s ->  new TreeSet<>(comparator));\n-        if (sset.contains(typeElement)) {\n-            return false;\n-        } else {\n-            sset.add(typeElement);\n+            \/\/ super-interfaces to the root set to traverse them\n+            interfacesHierarchy.roots.add(typeElement);\n@@ -259,13 +312,0 @@\n-        return true;\n-    }\n-\n-    \/**\n-     * From the map return the set of sub-classes or sub-interfaces. If set\n-     * is null create a new one and return it.\n-     *\n-     * @param map The entire map.\n-     * @param typeElement class for which the sub-class set is requested.\n-     * @return a set of sub classes.\n-     *\/\n-    private SortedSet<TypeElement> get(Map<TypeElement, SortedSet<TypeElement>> map, TypeElement typeElement) {\n-        return map.computeIfAbsent(typeElement, t ->  new TreeSet<>(comparator));\n@@ -280,1 +320,1 @@\n-        return get(subClasses, typeElement);\n+        return hierarchies.get(HierarchyKind.CLASSES).subtypes(typeElement);\n@@ -289,1 +329,1 @@\n-        return get(subInterfaces, typeElement);\n+        return hierarchies.get(HierarchyKind.INTERFACES).subtypes(typeElement);\n@@ -298,2 +338,2 @@\n-        SortedSet<TypeElement> result = get(implementingClasses, typeElement);\n-        SortedSet<TypeElement> intfcs = allSubClasses(typeElement, false);\n+        SortedSet<TypeElement> result = implementingClasses.getSubtypes(typeElement);\n+        SortedSet<TypeElement> interfaces = hierarchy(typeElement).allSubtypes(typeElement);\n@@ -303,10 +343,2 @@\n-        Iterator<TypeElement> subInterfacesIter = intfcs.iterator();\n-        while (subInterfacesIter.hasNext()) {\n-            Iterator<TypeElement> implementingClassesIter\n-                    = implementingClasses(subInterfacesIter.next()).iterator();\n-            while (implementingClassesIter.hasNext()) {\n-                TypeElement c = implementingClassesIter.next();\n-                if (!result.contains(c)) {\n-                    result.add(c);\n-                }\n-            }\n+        for (TypeElement te : interfaces) {\n+            result.addAll(implementingClasses(te));\n@@ -317,23 +349,10 @@\n-    \/**\n-     * Return the sub-class\/interface set for the class\/interface passed.\n-     *\n-     * @param typeElement class\/interface whose sub-class\/interface set is required.\n-     * @param isEnum true if the subClasses should be forced to come from the\n-     * enum tree.\n-     *\/\n-    public SortedSet<TypeElement> directSubClasses(TypeElement typeElement, boolean isEnum) {\n-        return directSubClasses0(typeElement, isEnum);\n-    }\n-\n-    private SortedSet<TypeElement> directSubClasses0(TypeElement typeElement, boolean isEnum) {\n-        if (isEnum) {\n-            return get(subEnums, typeElement);\n-        } else if (utils.isAnnotationInterface(typeElement)) {\n-            return get(subAnnotationTypes, typeElement);\n-        } else if (utils.isPlainInterface(typeElement)) {\n-            return get(subInterfaces, typeElement);\n-        } else if (utils.isClass(typeElement)) {\n-            return get(subClasses, typeElement);\n-        } else {\n-            return Collections.emptySortedSet();\n-        }\n+    public Hierarchy hierarchy(TypeElement typeElement) {\n+        HierarchyKind hk = switch (typeElement.getKind()) {\n+            case CLASS -> HierarchyKind.CLASSES;\n+            case ENUM -> HierarchyKind.ENUM_CLASSES;\n+            case RECORD -> HierarchyKind.RECORD_CLASSES;\n+            case INTERFACE -> HierarchyKind.INTERFACES;\n+            case ANNOTATION_TYPE -> HierarchyKind.ANNOTATION_INTERFACES;\n+            default -> throw new IllegalArgumentException(typeElement.getKind().name() + \" \" + typeElement.getQualifiedName());\n+        };\n+        return hierarchies.get(hk);\n@@ -343,6 +362,1 @@\n-     * Return a set of all direct or indirect, sub-classes and subInterfaces\n-     * of the TypeElement argument.\n-     *\n-     * @param typeElement TypeElement whose sub-classes or sub-interfaces are requested.\n-     * @param isEnum true if the subClasses should be forced to come from the\n-     * enum tree.\n+     * {@return the hierarchy for which the leaf nodes are plain classes}\n@@ -350,16 +364,2 @@\n-    public SortedSet<TypeElement> allSubClasses(TypeElement typeElement, boolean isEnum) {\n-        \/\/ new entries added to the set are searched as well, this is\n-        \/\/ really a work queue.\n-        List<TypeElement> list = new ArrayList<>(directSubClasses(typeElement, isEnum));\n-        for (int i = 0; i < list.size(); i++) {\n-            TypeElement te = list.get(i);\n-            SortedSet<TypeElement> tset = directSubClasses0(te, isEnum);\n-            for (TypeElement tte : tset) {\n-                if (!list.contains(tte)) {\n-                    list.add(tte);\n-                }\n-            }\n-        }\n-        SortedSet<TypeElement> out = new TreeSet<>(comparator);\n-        out.addAll(list);\n-        return out;\n+    public Hierarchy classes() {\n+        return hierarchies.get(HierarchyKind.CLASSES);\n@@ -369,3 +369,1 @@\n-     * Return a set of base classes. This will have only one element namely\n-     * the TypeElement for java.lang.Object, since this is the base class for all\n-     * classes.\n+     * {@return the hierarchy for which the leaf nodes are enum classes}\n@@ -373,2 +371,2 @@\n-    public SortedSet<TypeElement> baseClasses() {\n-        return baseClasses;\n+    public Hierarchy enumClasses() {\n+        return hierarchies.get(HierarchyKind.ENUM_CLASSES);\n@@ -378,2 +376,1 @@\n-     * Return the set of base interfaces. This is the set of interfaces\n-     * which do not have super-interface.\n+     * {@return the hierarchy for which the leaf nodes are record classes}\n@@ -381,2 +378,2 @@\n-    public SortedSet<TypeElement> baseInterfaces() {\n-        return baseInterfaces;\n+    public Hierarchy recordClasses() {\n+        return hierarchies.get(HierarchyKind.RECORD_CLASSES);\n@@ -386,2 +383,1 @@\n-     * Return the set of base enums. This is the set of enums\n-     * which do not have super-enums.\n+     * {@return the hierarchy for which the leaf nodes are plain interfaces}\n@@ -389,2 +385,2 @@\n-    public SortedSet<TypeElement> baseEnums() {\n-        return baseEnums;\n+    public Hierarchy interfaces() {\n+        return hierarchies.get(HierarchyKind.INTERFACES);\n@@ -394,2 +390,1 @@\n-     * Return the set of base annotation types. This is the set\n-     * of annotation types which do not have super-annotation types.\n+     * {@return the hierarchy for which the leaf nodes are annotation interfaces}\n@@ -397,2 +392,2 @@\n-    public SortedSet<TypeElement> baseAnnotationTypes() {\n-        return baseAnnotationTypes;\n+    public Hierarchy annotationInterfaces() {\n+        return hierarchies.get(HierarchyKind.ANNOTATION_INTERFACES);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/ClassTree.java","additions":207,"deletions":212,"binary":false,"changes":419,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -63,1 +63,1 @@\n-    private final ClassTree classtree;\n+    private final ClassTree classTree;\n@@ -195,1 +195,1 @@\n-    public ClassUseMapper(BaseConfiguration configuration, ClassTree classtree) {\n+    public ClassUseMapper(BaseConfiguration configuration, ClassTree classTree) {\n@@ -201,1 +201,1 @@\n-        this.classtree = classtree;\n+        this.classTree = classTree;\n@@ -204,1 +204,1 @@\n-        for (TypeElement te : classtree.baseClasses()) {\n+        for (TypeElement te : classTree.classes().roots()) {\n@@ -207,1 +207,1 @@\n-        for (TypeElement intfc : classtree.baseInterfaces()) {\n+        for (TypeElement intfc : classTree.interfaces().roots()) {\n@@ -289,1 +289,1 @@\n-            Set<TypeElement> subs = classtree.subClasses(te);\n+            Set<TypeElement> subs = classTree.subClasses(te);\n@@ -308,1 +308,1 @@\n-            Set<TypeElement> subs = classtree.subInterfaces(te);\n+            Set<TypeElement> subs = classTree.subInterfaces(te);\n@@ -329,1 +329,1 @@\n-            Set<TypeElement> impl = classtree.implementingClasses(te);\n+            Set<TypeElement> impl = classTree.implementingClasses(te);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/ClassUseMapper.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug      8225055 8239804 8246774 8258338 8261976 8275199\n+ * @bug      8225055 8239804 8246774 8258338 8261976 8275199 8285939\n@@ -608,0 +608,37 @@\n+\n+    @Test\n+    public void testPackageTree(Path base) throws IOException {\n+        Path src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src,\n+                \"\"\"\n+                    package p;\n+                    \/**\n+                     * A point.\n+                     * @param x the x coord\n+                     * @param y the y coord\n+                     *\/\n+                    public record Point(int x, int y) { }\"\"\");\n+\n+        javadoc(\"-d\", base.resolve(\"out\").toString(),\n+                \"-quiet\", \"-noindex\", \"--no-platform-links\",\n+                \"-sourcepath\", src.toString(),\n+                \"p\");\n+        checkExit(Exit.OK);\n+\n+        checkOutput(\"p\/package-tree.html\", true,\n+                \"\"\"\n+                    <section class=\"hierarchy\">\n+                    <h2 title=\"Record Class Hierarchy\">Record Class Hierarchy<\/h2>\n+                    <ul>\n+                    <li class=\"circle\">java.lang.Object\n+                    <ul>\n+                    <li class=\"circle\">java.lang.Record\n+                    <ul>\n+                    <li class=\"circle\">p.<a href=\"Point.html\" class=\"type-name-link\" title=\"class in p\">Point<\/a><\/li>\n+                    <\/ul>\n+                    <\/li>\n+                    <\/ul>\n+                    <\/li>\n+                    <\/ul>\n+                    <\/section>\"\"\");\n+    }\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testRecordTypes\/TestRecordTypes.java","additions":39,"deletions":2,"binary":false,"changes":41,"status":"modified"}]}