{"files":[{"patch":"@@ -30,1 +30,1 @@\n-import sun.nio.ch.PollsetProvider;\n+import sun.nio.ch.Pollset;\n@@ -47,1 +47,1 @@\n-        PollsetProvider.init();\n+        Pollset.init();\n@@ -123,1 +123,1 @@\n-        this.pollset = PollsetProvider.pollsetCreate();\n+        this.pollset = Pollset.pollsetCreate();\n@@ -128,1 +128,1 @@\n-            PollsetProvider.socketpair(sv);\n+            Pollset.socketpair(sv);\n@@ -130,1 +130,1 @@\n-            PollsetProvider.pollsetCtl(pollset, PollsetProvider.PS_ADD, sv[0], Net.POLLIN);\n+            Pollset.pollsetCtl(pollset, Pollset.PS_ADD, sv[0], Net.POLLIN);\n@@ -132,1 +132,1 @@\n-            PollsetProvider.pollsetDestroy(pollset);\n+            Pollset.pollsetDestroy(pollset);\n@@ -140,1 +140,1 @@\n-            PollsetProvider.socketpair(sv);\n+            Pollset.socketpair(sv);\n@@ -142,1 +142,1 @@\n-            PollsetProvider.pollsetCtl(pollset, PollsetProvider.PS_ADD, sv[0], Net.POLLIN);\n+            Pollset.pollsetCtl(pollset, Pollset.PS_ADD, sv[0], Net.POLLIN);\n@@ -144,1 +144,1 @@\n-            PollsetProvider.pollsetDestroy(pollset);\n+            Pollset.pollsetDestroy(pollset);\n@@ -150,1 +150,1 @@\n-        this.address = PollsetProvider.allocatePollArray(PollsetProvider.MAX_POLL_EVENTS);\n+        this.address = Pollset.allocatePollArray(Pollset.MAX_POLL_EVENTS);\n@@ -154,1 +154,1 @@\n-        this.queue = new ArrayBlockingQueue<Event>(PollsetProvider.MAX_POLL_EVENTS);\n+        this.queue = new ArrayBlockingQueue<Event>(Pollset.MAX_POLL_EVENTS);\n@@ -172,6 +172,6 @@\n-        PollsetProvider.freePollArray(address);\n-        PollsetProvider.close0(sp[0]);\n-        PollsetProvider.close0(sp[1]);\n-        PollsetProvider.close0(ctlSp[0]);\n-        PollsetProvider.close0(ctlSp[1]);\n-        PollsetProvider.pollsetDestroy(pollset);\n+        Pollset.freePollArray(address);\n+        Pollset.close0(sp[0]);\n+        Pollset.close0(sp[1]);\n+        Pollset.close0(ctlSp[0]);\n+        Pollset.close0(ctlSp[1]);\n+        Pollset.pollsetDestroy(pollset);\n@@ -184,1 +184,1 @@\n-                PollsetProvider.interrupt(sp[1]);\n+                Pollset.interrupt(sp[1]);\n@@ -239,1 +239,1 @@\n-                PollsetProvider.interrupt(ctlSp[1]);\n+                Pollset.interrupt(ctlSp[1]);\n@@ -280,1 +280,1 @@\n-                PollsetProvider.pollsetCtl(pollset, PollsetProvider.PS_DELETE, ev.fd(), 0);\n+                Pollset.pollsetCtl(pollset, Pollset.PS_DELETE, ev.fd(), 0);\n@@ -282,1 +282,1 @@\n-                    ev.setError(PollsetProvider.pollsetCtl(pollset, PollsetProvider.PS_MOD, ev.fd(), ev.events()));\n+                    ev.setError(Pollset.pollsetCtl(pollset, Pollset.PS_MOD, ev.fd(), ev.events()));\n@@ -306,2 +306,2 @@\n-                        n = PollsetProvider.pollsetPoll(pollset, address,\n-                                     PollsetProvider.MAX_POLL_EVENTS, PollsetProvider.PS_NO_TIMEOUT);\n+                        n = Pollset.pollsetPoll(pollset, address,\n+                                     Pollset.MAX_POLL_EVENTS, Pollset.PS_NO_TIMEOUT);\n@@ -320,2 +320,2 @@\n-                            long eventAddress = PollsetProvider.getEvent(address, n);\n-                            int fd = PollsetProvider.getDescriptor(eventAddress);\n+                            long eventAddress = Pollset.getEvent(address, n);\n+                            int fd = Pollset.getDescriptor(eventAddress);\n@@ -327,1 +327,1 @@\n-                                    PollsetProvider.pollsetCtl(pollset, PollsetProvider.PS_DELETE, fd, 0);\n+                                    Pollset.pollsetCtl(pollset, Pollset.PS_DELETE, fd, 0);\n@@ -335,1 +335,1 @@\n-                                    PollsetProvider.drain1(sp[0]);\n+                                    Pollset.drain1(sp[0]);\n@@ -350,1 +350,1 @@\n-                                    PollsetProvider.drain1(ctlSp[0]);\n+                                    Pollset.drain1(ctlSp[0]);\n@@ -361,1 +361,1 @@\n-                                int events = PollsetProvider.getRevents(eventAddress);\n+                                int events = Pollset.getRevents(eventAddress);\n","filename":"src\/java.base\/aix\/classes\/sun\/nio\/ch\/AixPollPort.java","additions":29,"deletions":29,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-public class PollsetProvider {\n+public class Pollset {\n@@ -69,1 +69,1 @@\n-        return unsafe.allocateMemory(count * PollsetProvider.SIZEOF_POLLFD);\n+        return unsafe.allocateMemory(count * SIZEOF_POLLFD);\n","filename":"src\/java.base\/aix\/classes\/sun\/nio\/ch\/Pollset.java","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"src\/java.base\/aix\/classes\/sun\/nio\/ch\/PollsetProvider.java","status":"renamed"},{"patch":"@@ -30,1 +30,1 @@\n-import sun.nio.ch.PollsetProvider;\n+import sun.nio.ch.Pollset;\n@@ -38,1 +38,1 @@\n-    static { PollsetProvider.init(); \/* Dynamically loads pollset C functions *\/ }\n+    static { Pollset.init(); \/* Dynamically loads pollset C functions *\/ }\n@@ -46,1 +46,1 @@\n-        this.setid = PollsetProvider.pollsetCreate();\n+        this.setid = Pollset.pollsetCreate();\n@@ -56,2 +56,2 @@\n-        int ret = PollsetProvider.pollsetCtl(setid, PollsetProvider.PS_MOD, fd,\n-        PollsetProvider.PS_POLLPRI | (this.reading() ? Net.POLLIN : Net.POLLOUT));\n+        int ret = Pollset.pollsetCtl(setid, Pollset.PS_MOD, fd,\n+        Pollset.PS_POLLPRI | (this.reading() ? Net.POLLIN : Net.POLLOUT));\n@@ -67,1 +67,1 @@\n-        int ret = PollsetProvider.pollsetCtl(setid, PollsetProvider.PS_DELETE, fd, 0);\n+        int ret = Pollset.pollsetCtl(setid, Pollset.PS_DELETE, fd, 0);\n@@ -85,1 +85,1 @@\n-            case PollsetProvider.PS_NO_TIMEOUT:\n+            case Pollset.PS_NO_TIMEOUT:\n@@ -100,2 +100,2 @@\n-        long buffer = PollsetProvider.allocatePollArray(setsize > 0 ? setsize : 1);\n-        int n = PollsetProvider.pollsetPoll(setid, buffer, setsize, subInterval);\n+        long buffer = Pollset.allocatePollArray(setsize > 0 ? setsize : 1);\n+        int n = Pollset.pollsetPoll(setid, buffer, setsize, subInterval);\n@@ -103,2 +103,2 @@\n-            long eventAddress = PollsetProvider.getEvent(buffer, i);\n-            int fd = PollsetProvider.getDescriptor(eventAddress);\n+            long eventAddress = Pollset.getEvent(buffer, i);\n+            int fd = Pollset.getDescriptor(eventAddress);\n@@ -107,1 +107,1 @@\n-        PollsetProvider.freePollArray(buffer);\n+        Pollset.freePollArray(buffer);\n","filename":"src\/java.base\/aix\/classes\/sun\/nio\/ch\/PollsetPoller.java","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -0,0 +1,175 @@\n+\/*\n+ * Copyright (c) 2008, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012 SAP SE. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"jni.h\"\n+#include \"jni_util.h\"\n+#include \"jvm.h\"\n+#include \"jlong.h\"\n+\n+#include \"sun_nio_ch_Pollset.h\"\n+\n+#include <dlfcn.h>\n+#include <errno.h>\n+#include <fcntl.h>\n+#include <stddef.h>\n+#include <sys\/pollset.h>\n+#include <sys\/types.h>\n+#include <sys\/socket.h>\n+#include <unistd.h>\n+\n+\/* Initially copied from src\/solaris\/native\/sun\/nio\/ch\/nio_util.h *\/\n+#define RESTARTABLE(_cmd, _result) do { \\\n+  do { \\\n+    _result = _cmd; \\\n+  } while((_result == -1) && (errno == EINTR)); \\\n+} while(0)\n+\n+typedef pollset_t pollset_create_func(int maxfd);\n+typedef int pollset_destroy_func(pollset_t ps);\n+typedef int pollset_ctl_func(pollset_t ps, struct poll_ctl *pollctl_array, int array_length);\n+typedef int pollset_poll_func(pollset_t ps, struct pollfd *polldata_array, int array_length, int timeout);\n+static pollset_create_func* _pollset_create = NULL;\n+static pollset_destroy_func* _pollset_destroy = NULL;\n+static pollset_ctl_func* _pollset_ctl = NULL;\n+static pollset_poll_func* _pollset_poll = NULL;\n+\n+JNIEXPORT void JNICALL\n+Java_sun_nio_ch_Pollset_init(JNIEnv* env, jclass this) {\n+    _pollset_create = (pollset_create_func*) dlsym(RTLD_DEFAULT, \"pollset_create\");\n+    _pollset_destroy = (pollset_destroy_func*) dlsym(RTLD_DEFAULT, \"pollset_destroy\");\n+    _pollset_ctl = (pollset_ctl_func*) dlsym(RTLD_DEFAULT, \"pollset_ctl\");\n+    _pollset_poll = (pollset_poll_func*) dlsym(RTLD_DEFAULT, \"pollset_poll\");\n+    if (_pollset_create == NULL || _pollset_destroy == NULL ||\n+        _pollset_ctl == NULL || _pollset_poll == NULL) {\n+        JNU_ThrowInternalError(env, \"unable to get address of pollset functions\");\n+    }\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_sun_nio_ch_Pollset_eventSize(JNIEnv* env, jclass this) {\n+    return sizeof(struct pollfd);\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_sun_nio_ch_Pollset_eventsOffset(JNIEnv* env, jclass this) {\n+    return offsetof(struct pollfd, events);\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_sun_nio_ch_Pollset_reventsOffset(JNIEnv* env, jclass this) {\n+    return offsetof(struct pollfd, revents);\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_sun_nio_ch_Pollset_fdOffset(JNIEnv* env, jclass this) {\n+    return offsetof(struct pollfd, fd);\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_sun_nio_ch_Pollset_pollsetCreate(JNIEnv *env, jclass c) {\n+    \/* pollset_create can take the maximum number of fds, but we\n+     * cannot predict this number so we leave it at OPEN_MAX. *\/\n+    pollset_t ps = _pollset_create(-1);\n+    if (ps < 0) {\n+       JNU_ThrowIOExceptionWithLastError(env, \"pollset_create failed\");\n+    }\n+    return (int)ps;\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_sun_nio_ch_Pollset_pollsetCtl(JNIEnv *env, jclass c, jint ps,\n+                                       jint opcode, jint fd, jint events) {\n+    struct poll_ctl event;\n+    int res;\n+\n+    event.cmd = opcode;\n+    event.events = events;\n+    event.fd = fd;\n+\n+    RESTARTABLE(_pollset_ctl((pollset_t)ps, &event, 1 \/* length *\/), res);\n+\n+    return (res == 0) ? 0 : errno;\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_sun_nio_ch_Pollset_pollsetPoll(JNIEnv *env, jclass c,\n+                                        jint ps, jlong address, jint numfds, jint timeout) {\n+    struct pollfd *events = jlong_to_ptr(address);\n+    int res;\n+\n+    RESTARTABLE(_pollset_poll(ps, events, numfds, timeout), res);\n+    if (res < 0) {\n+        perror(\"pollset_poll failed\");\n+        JNU_ThrowIOExceptionWithLastError(env, \"pollset_poll failed\");\n+    }\n+    return res;\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_sun_nio_ch_Pollset_pollsetDestroy(JNIEnv *env, jclass c, jint ps) {\n+    int res;\n+    RESTARTABLE(_pollset_destroy((pollset_t)ps), res);\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_sun_nio_ch_Pollset_socketpair(JNIEnv* env, jclass clazz, jintArray sv) {\n+    int sp[2];\n+    if (socketpair(PF_UNIX, SOCK_STREAM, 0, sp) == -1) {\n+        JNU_ThrowIOExceptionWithLastError(env, \"socketpair failed\");\n+    } else {\n+        jint res[2];\n+        res[0] = (jint)sp[0];\n+        res[1] = (jint)sp[1];\n+        (*env)->SetIntArrayRegion(env, sv, 0, 2, &res[0]);\n+    }\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_sun_nio_ch_Pollset_interrupt(JNIEnv *env, jclass c, jint fd) {\n+    int res;\n+    int buf[1];\n+    buf[0] = 1;\n+    RESTARTABLE(write(fd, buf, 1), res);\n+    if (res < 0) {\n+        JNU_ThrowIOExceptionWithLastError(env, \"write failed\");\n+    }\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_sun_nio_ch_Pollset_drain1(JNIEnv *env, jclass cl, jint fd) {\n+    int res;\n+    char buf[1];\n+    RESTARTABLE(read(fd, buf, 1), res);\n+    if (res < 0) {\n+        JNU_ThrowIOExceptionWithLastError(env, \"drain1 failed\");\n+    }\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_sun_nio_ch_Pollset_close0(JNIEnv *env, jclass c, jint fd) {\n+    int res;\n+    RESTARTABLE(close(fd), res);\n+}\n","filename":"src\/java.base\/aix\/native\/libnio\/ch\/Pollset.c","additions":175,"deletions":0,"binary":false,"changes":175,"status":"added"},{"patch":"@@ -1,175 +0,0 @@\n-\/*\n- * Copyright (c) 2008, 2013, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2012 SAP SE. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include \"jni.h\"\n-#include \"jni_util.h\"\n-#include \"jvm.h\"\n-#include \"jlong.h\"\n-\n-#include \"sun_nio_ch_PollsetProvider.h\"\n-\n-#include <dlfcn.h>\n-#include <errno.h>\n-#include <fcntl.h>\n-#include <stddef.h>\n-#include <sys\/pollset.h>\n-#include <sys\/types.h>\n-#include <sys\/socket.h>\n-#include <unistd.h>\n-\n-\/* Initially copied from src\/solaris\/native\/sun\/nio\/ch\/nio_util.h *\/\n-#define RESTARTABLE(_cmd, _result) do { \\\n-  do { \\\n-    _result = _cmd; \\\n-  } while((_result == -1) && (errno == EINTR)); \\\n-} while(0)\n-\n-typedef pollset_t pollset_create_func(int maxfd);\n-typedef int pollset_destroy_func(pollset_t ps);\n-typedef int pollset_ctl_func(pollset_t ps, struct poll_ctl *pollctl_array, int array_length);\n-typedef int pollset_poll_func(pollset_t ps, struct pollfd *polldata_array, int array_length, int timeout);\n-static pollset_create_func* _pollset_create = NULL;\n-static pollset_destroy_func* _pollset_destroy = NULL;\n-static pollset_ctl_func* _pollset_ctl = NULL;\n-static pollset_poll_func* _pollset_poll = NULL;\n-\n-JNIEXPORT void JNICALL\n-Java_sun_nio_ch_PollsetProvider_init(JNIEnv* env, jclass this) {\n-    _pollset_create = (pollset_create_func*) dlsym(RTLD_DEFAULT, \"pollset_create\");\n-    _pollset_destroy = (pollset_destroy_func*) dlsym(RTLD_DEFAULT, \"pollset_destroy\");\n-    _pollset_ctl = (pollset_ctl_func*) dlsym(RTLD_DEFAULT, \"pollset_ctl\");\n-    _pollset_poll = (pollset_poll_func*) dlsym(RTLD_DEFAULT, \"pollset_poll\");\n-    if (_pollset_create == NULL || _pollset_destroy == NULL ||\n-        _pollset_ctl == NULL || _pollset_poll == NULL) {\n-        JNU_ThrowInternalError(env, \"unable to get address of pollset functions\");\n-    }\n-}\n-\n-JNIEXPORT jint JNICALL\n-Java_sun_nio_ch_PollsetProvider_eventSize(JNIEnv* env, jclass this) {\n-    return sizeof(struct pollfd);\n-}\n-\n-JNIEXPORT jint JNICALL\n-Java_sun_nio_ch_PollsetProvider_eventsOffset(JNIEnv* env, jclass this) {\n-    return offsetof(struct pollfd, events);\n-}\n-\n-JNIEXPORT jint JNICALL\n-Java_sun_nio_ch_PollsetProvider_reventsOffset(JNIEnv* env, jclass this) {\n-    return offsetof(struct pollfd, revents);\n-}\n-\n-JNIEXPORT jint JNICALL\n-Java_sun_nio_ch_PollsetProvider_fdOffset(JNIEnv* env, jclass this) {\n-    return offsetof(struct pollfd, fd);\n-}\n-\n-JNIEXPORT jint JNICALL\n-Java_sun_nio_ch_PollsetProvider_pollsetCreate(JNIEnv *env, jclass c) {\n-    \/* pollset_create can take the maximum number of fds, but we\n-     * cannot predict this number so we leave it at OPEN_MAX. *\/\n-    pollset_t ps = _pollset_create(-1);\n-    if (ps < 0) {\n-       JNU_ThrowIOExceptionWithLastError(env, \"pollset_create failed\");\n-    }\n-    return (int)ps;\n-}\n-\n-JNIEXPORT jint JNICALL\n-Java_sun_nio_ch_PollsetProvider_pollsetCtl(JNIEnv *env, jclass c, jint ps,\n-                                       jint opcode, jint fd, jint events) {\n-    struct poll_ctl event;\n-    int res;\n-\n-    event.cmd = opcode;\n-    event.events = events;\n-    event.fd = fd;\n-\n-    RESTARTABLE(_pollset_ctl((pollset_t)ps, &event, 1 \/* length *\/), res);\n-\n-    return (res == 0) ? 0 : errno;\n-}\n-\n-JNIEXPORT jint JNICALL\n-Java_sun_nio_ch_PollsetProvider_pollsetPoll(JNIEnv *env, jclass c,\n-                                        jint ps, jlong address, jint numfds, jint timeout) {\n-    struct pollfd *events = jlong_to_ptr(address);\n-    int res;\n-\n-    RESTARTABLE(_pollset_poll(ps, events, numfds, timeout), res);\n-    if (res < 0) {\n-        perror(\"pollset_poll failed\");\n-        JNU_ThrowIOExceptionWithLastError(env, \"pollset_poll failed\");\n-    }\n-    return res;\n-}\n-\n-JNIEXPORT void JNICALL\n-Java_sun_nio_ch_PollsetProvider_pollsetDestroy(JNIEnv *env, jclass c, jint ps) {\n-    int res;\n-    RESTARTABLE(_pollset_destroy((pollset_t)ps), res);\n-}\n-\n-JNIEXPORT void JNICALL\n-Java_sun_nio_ch_PollsetProvider_socketpair(JNIEnv* env, jclass clazz, jintArray sv) {\n-    int sp[2];\n-    if (socketpair(PF_UNIX, SOCK_STREAM, 0, sp) == -1) {\n-        JNU_ThrowIOExceptionWithLastError(env, \"socketpair failed\");\n-    } else {\n-        jint res[2];\n-        res[0] = (jint)sp[0];\n-        res[1] = (jint)sp[1];\n-        (*env)->SetIntArrayRegion(env, sv, 0, 2, &res[0]);\n-    }\n-}\n-\n-JNIEXPORT void JNICALL\n-Java_sun_nio_ch_PollsetProvider_interrupt(JNIEnv *env, jclass c, jint fd) {\n-    int res;\n-    int buf[1];\n-    buf[0] = 1;\n-    RESTARTABLE(write(fd, buf, 1), res);\n-    if (res < 0) {\n-        JNU_ThrowIOExceptionWithLastError(env, \"write failed\");\n-    }\n-}\n-\n-JNIEXPORT void JNICALL\n-Java_sun_nio_ch_PollsetProvider_drain1(JNIEnv *env, jclass cl, jint fd) {\n-    int res;\n-    char buf[1];\n-    RESTARTABLE(read(fd, buf, 1), res);\n-    if (res < 0) {\n-        JNU_ThrowIOExceptionWithLastError(env, \"drain1 failed\");\n-    }\n-}\n-\n-JNIEXPORT void JNICALL\n-Java_sun_nio_ch_PollsetProvider_close0(JNIEnv *env, jclass c, jint fd) {\n-    int res;\n-    RESTARTABLE(close(fd), res);\n-}\n","filename":"src\/java.base\/aix\/native\/libnio\/ch\/PollsetProvider.c","additions":0,"deletions":175,"binary":false,"changes":175,"status":"deleted"}]}