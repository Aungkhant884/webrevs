{"files":[{"patch":"@@ -46,1 +46,1 @@\n-  Unimplemented();\n+  \/\/ Nothing to do\n@@ -50,1 +50,1 @@\n-  Unimplemented();\n+  \/\/ Nothing to do\n","filename":"src\/hotspot\/cpu\/ppc\/continuationHelper_ppc.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -232,0 +232,1 @@\n+  AD.addInclude(AD._CPP_file, \"runtime\/continuation.hpp\");\n","filename":"src\/hotspot\/share\/adlc\/main.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+import sun.nio.ch.PollsetProvider;\n@@ -37,1 +38,0 @@\n-import jdk.internal.misc.Unsafe;\n@@ -45,2 +45,0 @@\n-    private static final Unsafe unsafe = Unsafe.getUnsafe();\n-\n@@ -49,1 +47,1 @@\n-        init();\n+        PollsetProvider.init();\n@@ -52,20 +50,0 @@\n-    \/**\n-     * struct pollfd {\n-     *     int fd;\n-     *     short events;\n-     *     short revents;\n-     * }\n-     *\/\n-    private static final int SIZEOF_POLLFD    = eventSize();\n-    private static final int OFFSETOF_EVENTS  = eventsOffset();\n-    private static final int OFFSETOF_REVENTS = reventsOffset();\n-    private static final int OFFSETOF_FD      = fdOffset();\n-\n-    \/\/ opcodes\n-    private static final int PS_ADD     = 0x0;\n-    private static final int PS_MOD     = 0x1;\n-    private static final int PS_DELETE  = 0x2;\n-\n-    \/\/ maximum number of events to poll at a time\n-    private static final int MAX_POLL_EVENTS = 512;\n-\n@@ -145,1 +123,1 @@\n-        this.pollset = pollsetCreate();\n+        this.pollset = PollsetProvider.pollsetCreate();\n@@ -150,1 +128,1 @@\n-            socketpair(sv);\n+            PollsetProvider.socketpair(sv);\n@@ -152,1 +130,1 @@\n-            pollsetCtl(pollset, PS_ADD, sv[0], Net.POLLIN);\n+            PollsetProvider.pollsetCtl(pollset, PollsetProvider.PS_ADD, sv[0], Net.POLLIN);\n@@ -154,1 +132,1 @@\n-            pollsetDestroy(pollset);\n+            PollsetProvider.pollsetDestroy(pollset);\n@@ -162,1 +140,1 @@\n-            socketpair(sv);\n+            PollsetProvider.socketpair(sv);\n@@ -164,1 +142,1 @@\n-            pollsetCtl(pollset, PS_ADD, sv[0], Net.POLLIN);\n+            PollsetProvider.pollsetCtl(pollset, PollsetProvider.PS_ADD, sv[0], Net.POLLIN);\n@@ -166,1 +144,1 @@\n-            pollsetDestroy(pollset);\n+            PollsetProvider.pollsetDestroy(pollset);\n@@ -172,1 +150,1 @@\n-        this.address = allocatePollArray(MAX_POLL_EVENTS);\n+        this.address = PollsetProvider.allocatePollArray(PollsetProvider.MAX_POLL_EVENTS);\n@@ -176,1 +154,1 @@\n-        this.queue = new ArrayBlockingQueue<Event>(MAX_POLL_EVENTS);\n+        this.queue = new ArrayBlockingQueue<Event>(PollsetProvider.MAX_POLL_EVENTS);\n@@ -194,6 +172,6 @@\n-        freePollArray(address);\n-        close0(sp[0]);\n-        close0(sp[1]);\n-        close0(ctlSp[0]);\n-        close0(ctlSp[1]);\n-        pollsetDestroy(pollset);\n+        PollsetProvider.freePollArray(address);\n+        PollsetProvider.close0(sp[0]);\n+        PollsetProvider.close0(sp[1]);\n+        PollsetProvider.close0(ctlSp[0]);\n+        PollsetProvider.close0(ctlSp[1]);\n+        PollsetProvider.pollsetDestroy(pollset);\n@@ -202,1 +180,1 @@\n-    private void wakeup() {\n+    void wakeup() {\n@@ -206,1 +184,1 @@\n-                interrupt(sp[1]);\n+                PollsetProvider.interrupt(sp[1]);\n@@ -261,1 +239,1 @@\n-                interrupt(ctlSp[1]);\n+                PollsetProvider.interrupt(ctlSp[1]);\n@@ -302,1 +280,1 @@\n-                pollsetCtl(pollset, PS_DELETE, ev.fd(), 0);\n+                PollsetProvider.pollsetCtl(pollset, PollsetProvider.PS_DELETE, ev.fd(), 0);\n@@ -304,1 +282,1 @@\n-                    ev.setError(pollsetCtl(pollset, PS_MOD, ev.fd(), ev.events()));\n+                    ev.setError(PollsetProvider.pollsetCtl(pollset, PollsetProvider.PS_MOD, ev.fd(), ev.events()));\n@@ -328,1 +306,2 @@\n-                        n = pollsetPoll(pollset, address, MAX_POLL_EVENTS);\n+                        n = PollsetProvider.pollsetPoll(pollset, address,\n+                                     PollsetProvider.MAX_POLL_EVENTS, PollsetProvider.PS_NO_TIMEOUT);\n@@ -341,2 +320,2 @@\n-                            long eventAddress = getEvent(address, n);\n-                            int fd = getDescriptor(eventAddress);\n+                            long eventAddress = PollsetProvider.getEvent(address, n);\n+                            int fd = PollsetProvider.getDescriptor(eventAddress);\n@@ -348,1 +327,1 @@\n-                                    pollsetCtl(pollset, PS_DELETE, fd, 0);\n+                                    PollsetProvider.pollsetCtl(pollset, PollsetProvider.PS_DELETE, fd, 0);\n@@ -356,1 +335,1 @@\n-                                    drain1(sp[0]);\n+                                    PollsetProvider.drain1(sp[0]);\n@@ -371,1 +350,1 @@\n-                                    drain1(ctlSp[0]);\n+                                    PollsetProvider.drain1(ctlSp[0]);\n@@ -382,1 +361,1 @@\n-                                int events = getRevents(eventAddress);\n+                                int events = PollsetProvider.getRevents(eventAddress);\n@@ -470,71 +449,0 @@\n-\n-    \/**\n-     * Allocates a poll array to handle up to {@code count} events.\n-     *\/\n-    private static long allocatePollArray(int count) {\n-        return unsafe.allocateMemory(count * SIZEOF_POLLFD);\n-    }\n-\n-    \/**\n-     * Free a poll array\n-     *\/\n-    private static void freePollArray(long address) {\n-        unsafe.freeMemory(address);\n-    }\n-\n-    \/**\n-     * Returns event[i];\n-     *\/\n-    private static long getEvent(long address, int i) {\n-        return address + (SIZEOF_POLLFD*i);\n-    }\n-\n-    \/**\n-     * Returns event->fd\n-     *\/\n-    private static int getDescriptor(long eventAddress) {\n-        return unsafe.getInt(eventAddress + OFFSETOF_FD);\n-    }\n-\n-    \/**\n-     * Returns event->events\n-     *\/\n-    private static int getEvents(long eventAddress) {\n-        return unsafe.getChar(eventAddress + OFFSETOF_EVENTS);\n-    }\n-\n-    \/**\n-     * Returns event->revents\n-     *\/\n-    private static int getRevents(long eventAddress) {\n-        return unsafe.getChar(eventAddress + OFFSETOF_REVENTS);\n-    }\n-\n-    \/\/ -- Native methods --\n-\n-    private static native void init();\n-\n-    private static native int eventSize();\n-\n-    private static native int eventsOffset();\n-\n-    private static native int reventsOffset();\n-\n-    private static native int fdOffset();\n-\n-    private static native int pollsetCreate() throws IOException;\n-\n-    private static native int pollsetCtl(int pollset, int opcode, int fd, int events);\n-\n-    private static native int pollsetPoll(int pollset, long pollAddress, int numfds)\n-        throws IOException;\n-\n-    private static native void pollsetDestroy(int pollset);\n-\n-    private static native void socketpair(int[] sv) throws IOException;\n-\n-    private static native void interrupt(int fd) throws IOException;\n-\n-    private static native void drain1(int fd) throws IOException;\n-\n-    private static native void close0(int fd);\n","filename":"src\/java.base\/aix\/classes\/sun\/nio\/ch\/AixPollPort.java","additions":31,"deletions":123,"binary":false,"changes":154,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+import java.time.Instant;\n+import sun.nio.ch.PollsetProvider;\n@@ -35,0 +37,5 @@\n+    static { PollsetProvider.init(); \/* Dynamically loads pollset C functions *\/ }\n+\n+    private int setid;\n+    private int setsize;\n+\n@@ -37,0 +44,2 @@\n+        this.setsize = 0;\n+        this.setid = PollsetProvider.pollsetCreate();\n@@ -41,2 +50,1 @@\n-        \/\/ Stub\n-        throw new UnsupportedOperationException(\"Unimplemented on AIX\");\n+        return setid;\n@@ -46,3 +54,7 @@\n-    void implRegister(int fdVal) throws IOException {\n-        \/\/ Stub\n-        throw new UnsupportedOperationException(\"Unimplemented on AIX\");\n+    void implRegister(int fd) throws IOException {\n+        int ret = PollsetProvider.pollsetCtl(setid, PollsetProvider.PS_MOD, fd,\n+        PollsetProvider.PS_POLLPRI | (this.reading() ? Net.POLLIN : Net.POLLOUT));\n+        if (ret != 0) {\n+            throw new IOException(\"Unable to register fd \" + fd);\n+        }\n+        setsize++;\n@@ -52,3 +64,5 @@\n-    void implDeregister(int fdVal) {\n-        \/\/ Stub\n-        throw new UnsupportedOperationException(\"Unimplemented on AIX\");\n+    void implDeregister(int fd) {\n+        assert (setsize > 0);\n+        int ret = PollsetProvider.pollsetCtl(setid, PollsetProvider.PS_DELETE, fd, 0);\n+        assert ret == 0;\n+        setsize--;\n@@ -57,0 +71,6 @@\n+    \/**\n+      * Main poll method. The AIX Pollset library does not appear to pick up changes to the pollset\n+      * (the set of fds being polled) while blocked on a call to this method. These changes happen\n+      * regularly in the poll-loop thread and update thread from Poller.java.\n+      * To address this difficulty, we break poll calls into 100ms sub-calls and emulate the timout.\n+      *\/\n@@ -59,2 +79,29 @@\n-        \/\/ Stub\n-        throw new UnsupportedOperationException(\"Unimplemented on AIX\");\n+        int n;\n+        switch (timeout) {\n+            case 0:\n+                n = pollInner(0);\n+                break;\n+            case PollsetProvider.PS_NO_TIMEOUT:\n+                do { n = pollInner(100); } while (n == 0);\n+                break;\n+            default:\n+                Instant end = Instant.now().plusMillis(timeout);\n+                do { n = pollInner(100); } while (n == 0 && Instant.now().isBefore(end));\n+                break;\n+        }\n+        return n;\n+    }\n+\n+    int pollInner(int subInterval) throws IOException {\n+        \/\/ The poll loop may start polling before any fds have been registered. But, if we use set\n+        \/\/ size 0 to allocatePollArray, it will return the null address and pollsetPoll will complain.\n+        \/\/ We avoid that by just passing set size 1, and letting poll block for subInterval.\n+        long buffer = PollsetProvider.allocatePollArray(setsize > 0 ? setsize : 1);\n+        int n = PollsetProvider.pollsetPoll(setid, buffer, setsize, subInterval);\n+        for(int i=0; i<n; i++) {\n+            long eventAddress = PollsetProvider.getEvent(buffer, i);\n+            int fd = PollsetProvider.getDescriptor(eventAddress);\n+            polled(fd);\n+        }\n+        PollsetProvider.freePollArray(buffer);\n+        return n;\n","filename":"src\/java.base\/aix\/classes\/sun\/nio\/ch\/PollsetPoller.java","additions":58,"deletions":11,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -0,0 +1,126 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.nio.ch;\n+\n+import java.io.IOException;\n+import jdk.internal.misc.Unsafe;\n+\n+public class PollsetProvider {\n+\n+    private static final Unsafe unsafe = Unsafe.getUnsafe();\n+\n+   \/**\n+     * struct pollfd {\n+     *     int fd;\n+     *     short events;\n+     *     short revents;\n+     * }\n+     *\/\n+    public static final int SIZEOF_POLLFD    = eventSize();\n+    public static final int OFFSETOF_EVENTS  = eventsOffset();\n+    public static final int OFFSETOF_REVENTS = reventsOffset();\n+    public static final int OFFSETOF_FD      = fdOffset();\n+\n+    \/\/ opcodes\n+    public static final int PS_ADD     = 0x0;\n+    public static final int PS_MOD     = 0x1;\n+    public static final int PS_DELETE  = 0x2;\n+\n+    \/\/ event\n+    public static final int PS_POLLPRI = 0x4;\n+\n+    \/\/ revent errcodes\n+    public static final char PS_POLLNVAL = 0x8000;\n+    public static final char PS_POLLERR  = 0x4000;\n+\n+    public static final int PS_NO_TIMEOUT = -1;\n+\n+    \/\/ maximum number of events to poll at a time\n+    public static final int MAX_POLL_EVENTS = 512;\n+\n+    \/**\n+     * Allocates a poll array to handle up to {@code count} events.\n+     *\/\n+    public static long allocatePollArray(int count) {\n+        return unsafe.allocateMemory(count * PollsetProvider.SIZEOF_POLLFD);\n+    }\n+\n+    \/**\n+     * Free a poll array\n+     *\/\n+    public static void freePollArray(long address) {\n+        unsafe.freeMemory(address);\n+    }\n+\n+    \/**\n+     * Returns event[i];\n+     *\/\n+    public static long getEvent(long address, int i) {\n+        return address + (SIZEOF_POLLFD*i);\n+    }\n+\n+    \/**\n+     * Returns event->fd\n+     *\/\n+    public static int getDescriptor(long eventAddress) {\n+        return unsafe.getInt(eventAddress + OFFSETOF_FD);\n+    }\n+\n+    \/**\n+     * Returns event->events\n+     *\/\n+    public static int getEvents(long eventAddress) {\n+        return unsafe.getChar(eventAddress + OFFSETOF_EVENTS);\n+    }\n+\n+    \/**\n+     * Returns event->revents\n+     *\/\n+    public static char getRevents(long eventAddress) {\n+        return unsafe.getChar(eventAddress + OFFSETOF_REVENTS);\n+    }\n+\n+    public static boolean isReventsError(long eventAddress) {\n+        char revents = getRevents(eventAddress);\n+        return (revents & PS_POLLNVAL) != 0 || (revents & PS_POLLERR) != 0;\n+    }\n+\n+    \/\/ -- Native methods --\n+    public static native int pollsetCreate() throws IOException;\n+    public static native int pollsetCtl(int pollset, int opcode, int fd, int events);\n+    public static native int pollsetPoll(int pollset, long pollAddress, int numfds, int timeout)\n+        throws IOException;\n+    public static native void pollsetDestroy(int pollset);\n+    public static native void init();\n+    public static native int eventSize();\n+    public static native int eventsOffset();\n+    public static native int reventsOffset();\n+    public static native int fdOffset();\n+    public static native void socketpair(int[] sv) throws IOException;\n+    public static native void interrupt(int fd) throws IOException;\n+    public static native void drain1(int fd) throws IOException;\n+    public static native void close0(int fd);\n+}\n","filename":"src\/java.base\/aix\/classes\/sun\/nio\/ch\/PollsetProvider.java","additions":126,"deletions":0,"binary":false,"changes":126,"status":"added"},{"patch":"@@ -1,175 +0,0 @@\n-\/*\n- * Copyright (c) 2008, 2013, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2012 SAP SE. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include \"jni.h\"\n-#include \"jni_util.h\"\n-#include \"jvm.h\"\n-#include \"jlong.h\"\n-\n-#include \"sun_nio_ch_AixPollPort.h\"\n-\n-#include <unistd.h>\n-#include <sys\/types.h>\n-#include <sys\/socket.h>\n-#include <poll.h>\n-#include <sys\/pollset.h>\n-#include <fcntl.h>\n-#include <stddef.h>\n-#include <dlfcn.h>\n-#include <errno.h>\n-\n-\/* Initially copied from src\/solaris\/native\/sun\/nio\/ch\/nio_util.h *\/\n-#define RESTARTABLE(_cmd, _result) do { \\\n-  do { \\\n-    _result = _cmd; \\\n-  } while((_result == -1) && (errno == EINTR)); \\\n-} while(0)\n-\n-typedef pollset_t pollset_create_func(int maxfd);\n-typedef int pollset_destroy_func(pollset_t ps);\n-typedef int pollset_ctl_func(pollset_t ps, struct poll_ctl *pollctl_array, int array_length);\n-typedef int pollset_poll_func(pollset_t ps, struct pollfd *polldata_array, int array_length, int timeout);\n-static pollset_create_func* _pollset_create = NULL;\n-static pollset_destroy_func* _pollset_destroy = NULL;\n-static pollset_ctl_func* _pollset_ctl = NULL;\n-static pollset_poll_func* _pollset_poll = NULL;\n-\n-JNIEXPORT void JNICALL\n-Java_sun_nio_ch_AixPollPort_init(JNIEnv* env, jclass this) {\n-    _pollset_create = (pollset_create_func*) dlsym(RTLD_DEFAULT, \"pollset_create\");\n-    _pollset_destroy = (pollset_destroy_func*) dlsym(RTLD_DEFAULT, \"pollset_destroy\");\n-    _pollset_ctl = (pollset_ctl_func*) dlsym(RTLD_DEFAULT, \"pollset_ctl\");\n-    _pollset_poll = (pollset_poll_func*) dlsym(RTLD_DEFAULT, \"pollset_poll\");\n-    if (_pollset_create == NULL || _pollset_destroy == NULL ||\n-        _pollset_ctl == NULL || _pollset_poll == NULL) {\n-        JNU_ThrowInternalError(env, \"unable to get address of pollset functions\");\n-    }\n-}\n-\n-JNIEXPORT jint JNICALL\n-Java_sun_nio_ch_AixPollPort_eventSize(JNIEnv* env, jclass this) {\n-    return sizeof(struct pollfd);\n-}\n-\n-JNIEXPORT jint JNICALL\n-Java_sun_nio_ch_AixPollPort_eventsOffset(JNIEnv* env, jclass this) {\n-    return offsetof(struct pollfd, events);\n-}\n-\n-JNIEXPORT jint JNICALL\n-Java_sun_nio_ch_AixPollPort_reventsOffset(JNIEnv* env, jclass this) {\n-    return offsetof(struct pollfd, revents);\n-}\n-\n-JNIEXPORT jint JNICALL\n-Java_sun_nio_ch_AixPollPort_fdOffset(JNIEnv* env, jclass this) {\n-    return offsetof(struct pollfd, fd);\n-}\n-\n-JNIEXPORT jint JNICALL\n-Java_sun_nio_ch_AixPollPort_pollsetCreate(JNIEnv *env, jclass c) {\n-    \/* pollset_create can take the maximum number of fds, but we\n-     * cannot predict this number so we leave it at OPEN_MAX. *\/\n-    pollset_t ps = _pollset_create(-1);\n-    if (ps < 0) {\n-       JNU_ThrowIOExceptionWithLastError(env, \"pollset_create failed\");\n-    }\n-    return (int)ps;\n-}\n-\n-JNIEXPORT jint JNICALL\n-Java_sun_nio_ch_AixPollPort_pollsetCtl(JNIEnv *env, jclass c, jint ps,\n-                                       jint opcode, jint fd, jint events) {\n-    struct poll_ctl event;\n-    int res;\n-\n-    event.cmd = opcode;\n-    event.events = events;\n-    event.fd = fd;\n-\n-    RESTARTABLE(_pollset_ctl((pollset_t)ps, &event, 1 \/* length *\/), res);\n-\n-    return (res == 0) ? 0 : errno;\n-}\n-\n-JNIEXPORT jint JNICALL\n-Java_sun_nio_ch_AixPollPort_pollsetPoll(JNIEnv *env, jclass c,\n-                                        jint ps, jlong address, jint numfds) {\n-    struct pollfd *events = jlong_to_ptr(address);\n-    int res;\n-\n-    RESTARTABLE(_pollset_poll(ps, events, numfds, -1), res);\n-    if (res < 0) {\n-        JNU_ThrowIOExceptionWithLastError(env, \"pollset_poll failed\");\n-    }\n-    return res;\n-}\n-\n-JNIEXPORT void JNICALL\n-Java_sun_nio_ch_AixPollPort_pollsetDestroy(JNIEnv *env, jclass c, jint ps) {\n-    int res;\n-    RESTARTABLE(_pollset_destroy((pollset_t)ps), res);\n-}\n-\n-JNIEXPORT void JNICALL\n-Java_sun_nio_ch_AixPollPort_socketpair(JNIEnv* env, jclass clazz, jintArray sv) {\n-    int sp[2];\n-    if (socketpair(PF_UNIX, SOCK_STREAM, 0, sp) == -1) {\n-        JNU_ThrowIOExceptionWithLastError(env, \"socketpair failed\");\n-    } else {\n-        jint res[2];\n-        res[0] = (jint)sp[0];\n-        res[1] = (jint)sp[1];\n-        (*env)->SetIntArrayRegion(env, sv, 0, 2, &res[0]);\n-    }\n-}\n-\n-JNIEXPORT void JNICALL\n-Java_sun_nio_ch_AixPollPort_interrupt(JNIEnv *env, jclass c, jint fd) {\n-    int res;\n-    int buf[1];\n-    buf[0] = 1;\n-    RESTARTABLE(write(fd, buf, 1), res);\n-    if (res < 0) {\n-        JNU_ThrowIOExceptionWithLastError(env, \"write failed\");\n-    }\n-}\n-\n-JNIEXPORT void JNICALL\n-Java_sun_nio_ch_AixPollPort_drain1(JNIEnv *env, jclass cl, jint fd) {\n-    int res;\n-    char buf[1];\n-    RESTARTABLE(read(fd, buf, 1), res);\n-    if (res < 0) {\n-        JNU_ThrowIOExceptionWithLastError(env, \"drain1 failed\");\n-    }\n-}\n-\n-JNIEXPORT void JNICALL\n-Java_sun_nio_ch_AixPollPort_close0(JNIEnv *env, jclass c, jint fd) {\n-    int res;\n-    RESTARTABLE(close(fd), res);\n-}\n","filename":"src\/java.base\/aix\/native\/libnio\/ch\/AixPollPort.c","additions":0,"deletions":175,"binary":false,"changes":175,"status":"deleted"},{"patch":"@@ -0,0 +1,175 @@\n+\/*\n+ * Copyright (c) 2008, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012 SAP SE. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"jni.h\"\n+#include \"jni_util.h\"\n+#include \"jvm.h\"\n+#include \"jlong.h\"\n+\n+#include \"sun_nio_ch_PollsetProvider.h\"\n+\n+#include <dlfcn.h>\n+#include <errno.h>\n+#include <fcntl.h>\n+#include <stddef.h>\n+#include <sys\/pollset.h>\n+#include <sys\/types.h>\n+#include <sys\/socket.h>\n+#include <unistd.h>\n+\n+\/* Initially copied from src\/solaris\/native\/sun\/nio\/ch\/nio_util.h *\/\n+#define RESTARTABLE(_cmd, _result) do { \\\n+  do { \\\n+    _result = _cmd; \\\n+  } while((_result == -1) && (errno == EINTR)); \\\n+} while(0)\n+\n+typedef pollset_t pollset_create_func(int maxfd);\n+typedef int pollset_destroy_func(pollset_t ps);\n+typedef int pollset_ctl_func(pollset_t ps, struct poll_ctl *pollctl_array, int array_length);\n+typedef int pollset_poll_func(pollset_t ps, struct pollfd *polldata_array, int array_length, int timeout);\n+static pollset_create_func* _pollset_create = NULL;\n+static pollset_destroy_func* _pollset_destroy = NULL;\n+static pollset_ctl_func* _pollset_ctl = NULL;\n+static pollset_poll_func* _pollset_poll = NULL;\n+\n+JNIEXPORT void JNICALL\n+Java_sun_nio_ch_PollsetProvider_init(JNIEnv* env, jclass this) {\n+    _pollset_create = (pollset_create_func*) dlsym(RTLD_DEFAULT, \"pollset_create\");\n+    _pollset_destroy = (pollset_destroy_func*) dlsym(RTLD_DEFAULT, \"pollset_destroy\");\n+    _pollset_ctl = (pollset_ctl_func*) dlsym(RTLD_DEFAULT, \"pollset_ctl\");\n+    _pollset_poll = (pollset_poll_func*) dlsym(RTLD_DEFAULT, \"pollset_poll\");\n+    if (_pollset_create == NULL || _pollset_destroy == NULL ||\n+        _pollset_ctl == NULL || _pollset_poll == NULL) {\n+        JNU_ThrowInternalError(env, \"unable to get address of pollset functions\");\n+    }\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_sun_nio_ch_PollsetProvider_eventSize(JNIEnv* env, jclass this) {\n+    return sizeof(struct pollfd);\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_sun_nio_ch_PollsetProvider_eventsOffset(JNIEnv* env, jclass this) {\n+    return offsetof(struct pollfd, events);\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_sun_nio_ch_PollsetProvider_reventsOffset(JNIEnv* env, jclass this) {\n+    return offsetof(struct pollfd, revents);\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_sun_nio_ch_PollsetProvider_fdOffset(JNIEnv* env, jclass this) {\n+    return offsetof(struct pollfd, fd);\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_sun_nio_ch_PollsetProvider_pollsetCreate(JNIEnv *env, jclass c) {\n+    \/* pollset_create can take the maximum number of fds, but we\n+     * cannot predict this number so we leave it at OPEN_MAX. *\/\n+    pollset_t ps = _pollset_create(-1);\n+    if (ps < 0) {\n+       JNU_ThrowIOExceptionWithLastError(env, \"pollset_create failed\");\n+    }\n+    return (int)ps;\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_sun_nio_ch_PollsetProvider_pollsetCtl(JNIEnv *env, jclass c, jint ps,\n+                                       jint opcode, jint fd, jint events) {\n+    struct poll_ctl event;\n+    int res;\n+\n+    event.cmd = opcode;\n+    event.events = events;\n+    event.fd = fd;\n+\n+    RESTARTABLE(_pollset_ctl((pollset_t)ps, &event, 1 \/* length *\/), res);\n+\n+    return (res == 0) ? 0 : errno;\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_sun_nio_ch_PollsetProvider_pollsetPoll(JNIEnv *env, jclass c,\n+                                        jint ps, jlong address, jint numfds, jint timeout) {\n+    struct pollfd *events = jlong_to_ptr(address);\n+    int res;\n+\n+    RESTARTABLE(_pollset_poll(ps, events, numfds, timeout), res);\n+    if (res < 0) {\n+        perror(\"pollset_poll failed\");\n+        JNU_ThrowIOExceptionWithLastError(env, \"pollset_poll failed\");\n+    }\n+    return res;\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_sun_nio_ch_PollsetProvider_pollsetDestroy(JNIEnv *env, jclass c, jint ps) {\n+    int res;\n+    RESTARTABLE(_pollset_destroy((pollset_t)ps), res);\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_sun_nio_ch_PollsetProvider_socketpair(JNIEnv* env, jclass clazz, jintArray sv) {\n+    int sp[2];\n+    if (socketpair(PF_UNIX, SOCK_STREAM, 0, sp) == -1) {\n+        JNU_ThrowIOExceptionWithLastError(env, \"socketpair failed\");\n+    } else {\n+        jint res[2];\n+        res[0] = (jint)sp[0];\n+        res[1] = (jint)sp[1];\n+        (*env)->SetIntArrayRegion(env, sv, 0, 2, &res[0]);\n+    }\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_sun_nio_ch_PollsetProvider_interrupt(JNIEnv *env, jclass c, jint fd) {\n+    int res;\n+    int buf[1];\n+    buf[0] = 1;\n+    RESTARTABLE(write(fd, buf, 1), res);\n+    if (res < 0) {\n+        JNU_ThrowIOExceptionWithLastError(env, \"write failed\");\n+    }\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_sun_nio_ch_PollsetProvider_drain1(JNIEnv *env, jclass cl, jint fd) {\n+    int res;\n+    char buf[1];\n+    RESTARTABLE(read(fd, buf, 1), res);\n+    if (res < 0) {\n+        JNU_ThrowIOExceptionWithLastError(env, \"drain1 failed\");\n+    }\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_sun_nio_ch_PollsetProvider_close0(JNIEnv *env, jclass c, jint fd) {\n+    int res;\n+    RESTARTABLE(close(fd), res);\n+}\n","filename":"src\/java.base\/aix\/native\/libnio\/ch\/PollsetProvider.c","additions":175,"deletions":0,"binary":false,"changes":175,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -100,1 +100,1 @@\n-            poll1(fdVal, nanos, supplier);\n+            pollDirect(fdVal, nanos, supplier);\n@@ -102,1 +102,1 @@\n-            poll2(fdVal, nanos, supplier);\n+            pollAsync(fdVal, nanos, supplier);\n@@ -110,1 +110,1 @@\n-    private void poll1(int fdVal, long nanos, BooleanSupplier supplier) throws IOException {\n+    private void pollDirect(int fdVal, long nanos, BooleanSupplier supplier) throws IOException {\n@@ -131,1 +131,1 @@\n-    private void poll2(int fdVal, long nanos, BooleanSupplier supplier) {\n+    private void pollAsync(int fdVal, long nanos, BooleanSupplier supplier) {\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/Poller.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n- * @run main\/othervm\/timeout=300 -Xmx1g Skynet\n+ * @run main\/othervm\/timeout=350 -Xmx1g Skynet\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/stress\/Skynet.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -62,0 +62,1 @@\n+import jdk.test.lib.Platform;\n@@ -194,1 +195,5 @@\n-                    fail(\"read \" + n);\n+                    if (!Platform.isAix()) {\n+                        fail(\"read \" + n);\n+                    } else {\n+                        assertTrue(n == -1);\n+                    }\n","filename":"test\/jdk\/java\/net\/vthread\/BlockingSocketOps.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"}]}