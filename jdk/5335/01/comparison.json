{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,2 @@\n- * @run main\/othervm -Djava.security.manager=allow ExecCommand\n+ * @requires (os.family == \"windows\")\n+ * @run testng\/othervm -Djava.security.manager=allow ExecCommand\n@@ -39,0 +40,1 @@\n+import java.nio.file.Path;\n@@ -40,0 +42,4 @@\n+import java.security.Permission;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Properties;\n@@ -41,0 +47,7 @@\n+import org.testng.Assert;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+\n+@SuppressWarnings(\"removal\")\n@@ -42,0 +55,4 @@\n+\n+    private static final String JDK_LANG_PROCESS_ALLOW_AMBIGUOUS_COMMANDS =\n+            \"jdk.lang.Process.allowAmbiguousCommands\";\n+\n@@ -71,0 +88,8 @@\n+        public void checkPermission(Permission perm) {\n+            if (perm instanceof RuntimePermission ||\n+                    perm instanceof java.lang.reflect.ReflectPermission)\n+                return;\n+            super.checkPermission(perm);\n+        };\n+        @Override public void checkRead(String file) {}       \/\/ TestNG reads files\n+        @Override public void checkWrite(String file) {}      \/\/ TestNG writes files\n@@ -72,1 +97,2 @@\n-        @Override public void checkRead(String file) {}\n+        @Override public void checkPropertiesAccess() {}\n+        @Override public void checkPropertyAccess(String name) {}  \/\/ TestNG reads properties\n@@ -75,13 +101,1 @@\n-    \/\/ Parameters for the Runtime.exec calls\n-    private static final String TEST_RTE_ARG[] = {\n-        \"cmd \/C dir > dirOut.txt\",\n-        \"cmd \/C dir > \\\".\\\\Program Files\\\\dirOut.txt\\\"\",\n-        \".\\\\Program Files\\\\do.cmd\",\n-        \"\\\".\\\\Program Files\\\\doNot.cmd\\\" arg\",\n-        \"\\\".\\\\Program Files\\\\do.cmd\\\" arg\",\n-        \/\/ compatibility\n-        \"\\\".\\\\Program.cmd\\\" arg\",\n-        \".\\\\Program.cmd arg\",\n-    };\n-\n-    private static final String doCmdCopy[] = {\n+    private static final List<String> doCmdCopy = List.of(\n@@ -90,2 +104,1 @@\n-        \".\\\\Program Files\\\\do.cmd\",\n-    };\n+        \".\\\\Program Files\\\\do.cmd\");\n@@ -93,40 +106,2 @@\n-    \/\/ Golden image for results\n-    private static final String TEST_RTE_GI[][] = {\n-                    \/\/Def Legacy mode, Enforced mode, Set Legacy mode, Set Legacy mode & SM\n-        \/\/ [cmd \/C dir > dirOut.txt]\n-        new String[]{\"Success\",\n-                     \"IOException\",  \/\/ [cmd \/C dir \">\" dirOut.txt] no redirection\n-                     \"Success\",\n-                     \"IOException\"}, \/\/SM - no legacy mode, bad command\n-\n-        \/\/ [cmd \/C dir > \".\\Program Files\\dirOut.txt\"]\n-        new String[]{\"Success\",\n-                     \"IOException\",  \/\/ [cmd \/C dir \">\" \".\\Program Files\\dirOut.txt\"] no redirection\n-                     \"Success\",\n-                     \"IOException\"}, \/\/SM - no legacy mode, bad command\n-\n-        \/\/ [.\\Program File\\do.cmd]\n-        new String[]{\"Success\",\n-                     \"IOException\",  \/\/ [.\\Program] not found\n-                     \"Success\",\n-                     \"IOException\"}, \/\/SM - no legacy mode [.\\Program] - OK\n-\n-        \/\/ [\".\\Program File\\doNot.cmd\" arg]\n-        new String[]{\"Success\",\n-                     \"Success\",\n-                     \"Success\",\n-                     \"AccessControlException\"}, \/\/SM   - [\".\\Program] - OK,\n-                                 \/\/     [.\\\\Program Files\\\\doNot.cmd] - Fail\n-\n-        \/\/ [\".\\Program File\\do.cmd\" arg]\n-        \/\/ AccessControlException\n-        new String[]{\"Success\",\n-                     \"Success\",\n-                     \"Success\",\n-                     \"Success\"}, \/\/SM - [\".\\Program] - OK,\n-                                 \/\/     [.\\\\Program Files\\\\do.cmd] - OK\n-\n-        \/\/ compatibility\n-        new String[]{\"Success\", \"Success\", \"Success\", \"Success\"}, \/\/[\".\\Program.cmd\"]\n-        new String[]{\"Success\", \"Success\", \"Success\", \"Success\"}  \/\/[.\\Program.cmd]\n-    };\n+    @BeforeClass\n+    void setup() throws Exception {\n@@ -134,18 +109,1 @@\n-    private static void deleteOut(String path) {\n-        try {\n-            Files.delete(FileSystems.getDefault().getPath(path));\n-        } catch (IOException ex) {\n-            \/\/that is OK\n-        }\n-    }\n-    private static void checkOut(String path) throws FileNotFoundException {\n-        if (Files.notExists(FileSystems.getDefault().getPath(path)))\n-            throw new FileNotFoundException(path);\n-    }\n-\n-    public static void main(String[] _args) throws Exception {\n-        if (!System.getProperty(\"os.name\").startsWith(\"Windows\")) {\n-            return;\n-        }\n-\n-        \/\/ tear up\n+        \/\/ Create files to be execute\n@@ -154,1 +112,1 @@\n-            for (int i = 0; i < doCmdCopy.length; ++i) {\n+            for (String cmdFile : doCmdCopy) {\n@@ -156,1 +114,1 @@\n-                             new FileWriter(doCmdCopy[i]))) {\n+                        new FileWriter(cmdFile))) {\n@@ -163,0 +121,12 @@\n+    }\n+\n+    \/**\n+     * Sequence of tests and test results in the TEST_RTE_ARGS DataProvider below.\n+     * The ordinals are used as indices in the lists of expected results.\n+     *\/\n+    private enum Mode {\n+        UNSET_NO_SM, \/\/ 0) no SM and default allowAmbiguousCommands; equivalent to true\n+        EMPTY_NO_SM, \/\/ 1) no SM and allowAmbiguousCommand is empty; equivalent to true\n+        FALSE_NO_SM, \/\/ 2) no SM and allowAmbiguousCommands = false\n+        EMPTY_SM,    \/\/ 3) SM and default allowAmbiguousCommands is empty; equivalent to false\n+    };\n@@ -164,16 +134,120 @@\n-        \/\/ action\n-        for (int k = 0; k < 4; ++k) {\n-            switch (k) {\n-            case 0:\n-                \/\/ the \"jdk.lang.Process.allowAmbiguousCommands\" is undefined\n-                \/\/ \"true\" by default with the legacy verification procedure\n-                break;\n-            case 1:\n-                System.setProperty(\"jdk.lang.Process.allowAmbiguousCommands\", \"false\");\n-                break;\n-            case 2:\n-                System.setProperty(\"jdk.lang.Process.allowAmbiguousCommands\", \"\");\n-                break;\n-            case 3:\n-                System.setSecurityManager( new SecurityMan() );\n-                break;\n+    \/**\n+     * The command for Runtime.exec calls to execute in each of 4 modes,\n+     * and the expected exception for each mode.\n+     * Modes above define the indices in the List of expected results for each mode.\n+     *\/\n+    @DataProvider(name = \"TEST_RTE_ARGS\")\n+    Object[][] TEST_RTE_ARGS() {\n+        return new Object[][]{\n+                {\"cmd \/C dir > dirOut.txt\",\n+                        \"dirOut.txt\",\n+                        Arrays.asList(null,\n+                                null,\n+                                FileNotFoundException.class,\n+                                FileNotFoundException.class)\n+                },\n+                {\"cmd \/C dir > \\\".\\\\Program Files\\\\dirOut.txt\\\"\",\n+                        \".\/Program Files\/dirOut.txt\",\n+                        Arrays.asList(null,\n+                                null,\n+                                FileNotFoundException.class,\n+                                FileNotFoundException.class)\n+                },\n+                {\".\\\\Program Files\\\\do.cmd\",\n+                        null,\n+                        Arrays.asList(null,\n+                                null,\n+                                IOException.class,\n+                                IOException.class)\n+                },\n+                {\"\\\".\\\\Program Files\\\\doNot.cmd\\\" arg\",\n+                        null,\n+                        Arrays.asList(null,\n+                                null,\n+                                null,\n+                                AccessControlException.class)\n+                },\n+                {\"\\\".\\\\Program Files\\\\do.cmd\\\" arg\",\n+                        null,\n+                        \/\/ AccessControlException\n+                        Arrays.asList(null, null, null, null)\n+                },\n+                {\"\\\".\\\\Program.cmd\\\" arg\",\n+                        null,\n+                        Arrays.asList(null, null, null, null)\n+                },\n+                {\".\\\\Program.cmd arg\",\n+                        null,\n+                        Arrays.asList(null, null, null, null)\n+                },\n+        };\n+    }\n+\n+    \/**\n+     * Test each command with no SM and default allowAmbiguousCommands.\n+     * @param command a command\n+     * @param perModeExpected an expected Exception class or null\n+     *\/\n+    @Test(dataProvider = \"TEST_RTE_ARGS\")\n+    void testCommandAmbiguousUnset(String command, String testFile, List<Class<Exception>> perModeExpected) {\n+        \/\/ the JDK_LANG_PROCESS_ALLOW_AMBIGUOUS_COMMANDS is undefined\n+        \/\/ \"true\" by default with the legacy verification procedure\n+        Properties props = System.getProperties();\n+        props.remove(JDK_LANG_PROCESS_ALLOW_AMBIGUOUS_COMMANDS);\n+        System.setSecurityManager(null);\n+\n+        testCommandMode(command, \"Ambiguous Unset\", testFile,\n+                perModeExpected.get(Mode.UNSET_NO_SM.ordinal()));\n+    }\n+\n+    \/**\n+     * Test each command with no SM and allowAmbiguousCommand is empty.\n+     * @param command a command\n+     * @param perModeExpected an expected Exception class or null\n+     *\/\n+    @Test(dataProvider = \"TEST_RTE_ARGS\")\n+    void testCommandAmbiguousEmpty(String command, String testFile, List<Class<Exception>> perModeExpected) {\n+        Properties props = System.getProperties();\n+        props.setProperty(JDK_LANG_PROCESS_ALLOW_AMBIGUOUS_COMMANDS, \"\");\n+        System.setSecurityManager(null);\n+        testCommandMode(command, \"Ambiguous Empty\", testFile,\n+                perModeExpected.get(Mode.EMPTY_NO_SM.ordinal()));\n+    }\n+\n+    \/**\n+     * Test each command with no SM and allowAmbiguousCommands = false.\n+     * @param command a command\n+     * @param perModeExpected an expected Exception class or null\n+     *\/\n+    @Test(dataProvider = \"TEST_RTE_ARGS\")\n+    void testCommandAmbiguousFalse(String command, String testFile, List<Class<Exception>> perModeExpected) {\n+        Properties props = System.getProperties();\n+        props.setProperty(JDK_LANG_PROCESS_ALLOW_AMBIGUOUS_COMMANDS, \"false\");\n+        System.setSecurityManager(null);\n+\n+        testCommandMode(command, \"Ambiguous false\", testFile,\n+                perModeExpected.get(Mode.FALSE_NO_SM.ordinal()));\n+    }\n+\n+    \/**\n+     * Test each command with SecurityManager and default allowAmbiguousCommands is empty.\n+     * @param command a command\n+     * @param perModeExpected an expected Exception class or null\n+     *\/\n+    @Test(dataProvider = \"TEST_RTE_ARGS\")\n+    void testCommandWithSM(String command, String testFile, List<Class<Exception>> perModeExpected) {\n+        Properties props = System.getProperties();\n+        props.setProperty(JDK_LANG_PROCESS_ALLOW_AMBIGUOUS_COMMANDS, \"\");\n+        System.setSecurityManager(new SecurityMan());\n+\n+        testCommandMode(command, \"SecurityManager and Ambiguous Empty\", testFile,\n+                perModeExpected.get(Mode.EMPTY_SM.ordinal()));\n+    }\n+\n+    private void testCommandMode(String command, String kind,\n+                                 String testFile,\n+                                 Class<Exception> perModeExpected) {\n+        try {\n+            \/\/ Ensure the file that will be created does not exist.\n+            if (testFile != null) {\n+                Files.deleteIfExists(Path.of(testFile));\n@@ -181,37 +255,0 @@\n-            for (int i = 0; i < TEST_RTE_ARG.length; ++i) {\n-                String outRes;\n-                try {\n-                    \/\/ tear up\n-                    switch (i) {\n-                    case 0:\n-                        \/\/ [cmd \/C dir > dirOut.txt]\n-                        deleteOut(\".\\\\dirOut.txt\");\n-                        break;\n-                    case 1:\n-                        \/\/ [cmd \/C dir > \".\\Program Files\\dirOut.txt\"]\n-                        deleteOut(\".\\\\Program Files\\\\dirOut.txt\");\n-                        break;\n-                    }\n-\n-                    Process exec = Runtime.getRuntime().exec(TEST_RTE_ARG[i]);\n-                    exec.waitFor();\n-\n-                    \/\/exteded check\n-                    switch (i) {\n-                    case 0:\n-                        \/\/ [cmd \/C dir > dirOut.txt]\n-                        checkOut(\".\\\\dirOut.txt\");\n-                        break;\n-                    case 1:\n-                        \/\/ [cmd \/C dir > \".\\Program Files\\dirOut.txt\"]\n-                        checkOut(\".\\\\Program Files\\\\dirOut.txt\");\n-                        break;\n-                    }\n-                    outRes = \"Success\";\n-                } catch (IOException ioe) {\n-                    outRes = \"IOException: \" + ioe.getMessage();\n-                } catch (IllegalArgumentException iae) {\n-                    outRes = \"IllegalArgumentException: \" + iae.getMessage();\n-                } catch (AccessControlException se) {\n-                    outRes = \"AccessControlException: \" + se.getMessage();\n-                }\n@@ -219,8 +256,15 @@\n-                if (!outRes.startsWith(TEST_RTE_GI[i][k])) {\n-                    throw new Error(\"Unexpected output! Step\" + k + \":\" + i\n-                                + \"\\nArgument: \" + TEST_RTE_ARG[i]\n-                                + \"\\nExpected: \" + TEST_RTE_GI[i][k]\n-                                + \"\\n  Output: \" + outRes);\n-                } else {\n-                    System.out.println(\"RTE OK:\" + TEST_RTE_ARG[i]);\n-                }\n+            Process exec = Runtime.getRuntime().exec(command);\n+            exec.waitFor();\n+\n+            \/\/ extended check\n+            if (testFile != null) {\n+                if (Files.notExists(FileSystems.getDefault().getPath(testFile)))\n+                    throw new FileNotFoundException(testFile);\n+            }\n+            Assert.assertNull(perModeExpected, \"Missing exception\");\n+        } catch (Exception ex) {\n+            if (!ex.getClass().equals(perModeExpected)) {\n+                Assert.fail(\"Unexpected exception! Step \" + kind + \":\"\n+                        + \"\\nArgument: \" + command\n+                        + \"\\nExpected: \" + perModeExpected\n+                        + \"\\n  Output: \" + ex, ex);\n","filename":"test\/jdk\/java\/lang\/RuntimeTests\/exec\/ExecCommand.java","additions":183,"deletions":139,"binary":false,"changes":322,"status":"modified"}]}