{"files":[{"patch":"@@ -295,0 +295,2 @@\n+     *\n+     * @since 21\n@@ -321,2 +323,2 @@\n-         * kl is the k for the leftmost product k delta in I.\n-         * kr is the k for the leftmost product k delta to the right of I.\n+         * kl is the smallest k such that k delta is inside I.\n+         * kr > kl is the smallest k such that k delta is outside I.\n","filename":"src\/java.base\/share\/classes\/java\/util\/random\/RandomGenerator.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,352 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.test.lib.RandomFactory;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import java.util.Iterator;\n+import java.util.TreeSet;\n+import java.util.random.RandomGenerator;\n+import java.util.stream.DoubleStream;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+import static org.junit.jupiter.params.provider.Arguments.arguments;\n+\n+\/**\n+ * @test\n+ * @bug 8302987\n+ * @key randomness\n+ *\n+ * @summary Check consistency of RandomGenerator::equiDoubles\n+ * @library \/test\/lib\n+ * @run junit EquiDoublesTest\n+ *\n+ *\/\n+\n+public class EquiDoublesTest {\n+\n+    private static final int SAMPLES = 100_000;\n+\n+    \/*\n+     * A factor to use in the tight*() tests to make sure that\n+     * all equidistant doubles are generated.\n+     *\/\n+    private static final long SAFETY_FACTOR = 100L;\n+\n+    private static double nextUp(double d, int steps) {\n+        for (int i = 0; i < steps; ++i) {\n+            d = Math.nextUp(d);\n+        }\n+        return d;\n+    }\n+\n+    private static double nextDown(double d, int steps) {\n+        for (int i = 0; i < steps; ++i) {\n+            d = Math.nextDown(d);\n+        }\n+        return d;\n+    }\n+\n+    private static RandomGenerator rnd() {\n+        return RandomFactory.getRandom();\n+    }\n+\n+    static Arguments[] equi() {\n+        return new Arguments[] {\n+                arguments(0.0, 1e-9),\n+                arguments(1.0, 1.1),\n+                arguments(1.0e23, 1.1e23),\n+                arguments(1.0e300, 1.1e300),\n+                arguments(-1.2, 1.1),\n+                arguments(-1.2e-30, 1.1e6),\n+                arguments(-Double.MIN_VALUE, Double.MIN_VALUE),\n+                arguments(-Double.MAX_VALUE, Double.MAX_VALUE),\n+        };\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource\n+    void equi(double l, double r) {\n+        double[] minmax = new double[2];\n+\n+        resetMinmax(minmax);\n+        DoubleStream equi = rnd().equiDoubles(l, r, true, false);\n+        equi.limit(SAMPLES).forEach(d -> updateMinmax(minmax, d));\n+        assertTrue(l <= minmax[0]);\n+        assertTrue(minmax[1] < r);\n+\n+        resetMinmax(minmax);\n+        equi = rnd().equiDoubles(l, r, true, true);\n+        equi.limit(SAMPLES).forEach(d -> updateMinmax(minmax, d));\n+        assertTrue(l <= minmax[0]);\n+        assertTrue(minmax[1] <= r);\n+\n+        resetMinmax(minmax);\n+        equi = rnd().equiDoubles(l, r, false, true);\n+        equi.limit(SAMPLES).forEach(d -> updateMinmax(minmax, d));\n+        assertTrue(l < minmax[0]);\n+        assertTrue(minmax[1] <= r);\n+\n+        resetMinmax(minmax);\n+        equi = rnd().equiDoubles(l, r, false, false);\n+        equi.limit(SAMPLES).forEach(d -> updateMinmax(minmax, d));\n+        assertTrue(l < minmax[0]);\n+        assertTrue(minmax[1] < r);\n+\n+        \/* with negated intervals *\/\n+        resetMinmax(minmax);\n+        equi = rnd().equiDoubles(-r, -l, true, false);\n+        equi.limit(SAMPLES).forEach(d -> updateMinmax(minmax, d));\n+        assertTrue(-r <= minmax[0]);\n+        assertTrue(minmax[1] < -l);\n+\n+        resetMinmax(minmax);\n+        equi = rnd().equiDoubles(-r, -l, true, true);\n+        equi.limit(SAMPLES).forEach(d -> updateMinmax(minmax, d));\n+        assertTrue(-r <= minmax[0]);\n+        assertTrue(minmax[1] <= -l);\n+\n+        resetMinmax(minmax);\n+        equi = rnd().equiDoubles(-r, -l, false, true);\n+        equi.limit(SAMPLES).forEach(d -> updateMinmax(minmax, d));\n+        assertTrue(-r < minmax[0]);\n+        assertTrue(minmax[1] <= -l);\n+\n+        resetMinmax(minmax);\n+        equi = rnd().equiDoubles(-r, -l, false, false);\n+        equi.limit(SAMPLES).forEach(d -> updateMinmax(minmax, d));\n+        assertTrue(-r < minmax[0]);\n+        assertTrue(minmax[1] < -l);\n+    }\n+\n+    private void resetMinmax(double[] minmax) {\n+        minmax[0] = Double.POSITIVE_INFINITY;\n+        minmax[1] = Double.NEGATIVE_INFINITY;\n+    }\n+\n+    private void updateMinmax(double[] minmax, double d) {\n+        if (d < minmax[0]) {\n+            minmax[0] = d;\n+        }\n+        if (d > minmax[1]) {\n+            minmax[1] = d;\n+        }\n+    }\n+\n+    static Arguments[] tight() {\n+        return new Arguments[] {\n+                arguments(0.0, (short) 100),\n+                arguments(1.0, (short) 100),\n+                arguments(1.1, (short) 100),\n+                arguments(1.0e23, (short) 100),\n+                arguments(1.0e300, (short) 100),\n+                arguments(-1.2, (short) 100),\n+                arguments(-1.2e-30, (short) 100),\n+                arguments(-Double.MIN_VALUE, (short) 100),\n+\n+                arguments(-Double.MIN_VALUE, (short) 2),\n+                arguments(-Double.MAX_VALUE, (short) 2),\n+        };\n+    }\n+\n+    \/*\n+     * All equidistant doubles in a tight range are expected to be generated.\n+     * The arguments must be chosen as to not overlap a value with irregular\n+     * spacing around it.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource\n+    void tight(double l, short steps) {\n+        double r = nextUp(l, steps);\n+\n+        TreeSet<Double> set = new TreeSet<>();\n+        DoubleStream equi = rnd().equiDoubles(l, r, true, false);\n+        equi.limit(SAFETY_FACTOR * steps).forEach(set::add);\n+        assertEquals(steps, set.size());\n+        checkEquidistance(set);\n+\n+        set.clear();\n+        equi = rnd().equiDoubles(l, r, true, true);\n+        equi.limit(SAFETY_FACTOR * steps).forEach(set::add);\n+        assertEquals(steps + 1, set.size());\n+        checkEquidistance(set);\n+\n+        set.clear();\n+        equi = rnd().equiDoubles(l, r, false, true);\n+        equi.limit(SAFETY_FACTOR * steps).forEach(set::add);\n+        assertEquals(steps, set.size());\n+        checkEquidistance(set);\n+\n+        set.clear();\n+        equi = rnd().equiDoubles(l, r, false, false);\n+        equi.limit(SAFETY_FACTOR * steps).forEach(set::add);\n+        assertEquals(steps - 1, set.size());\n+        checkEquidistance(set);\n+\n+        \/* with negated intervals *\/\n+        set.clear();\n+        equi = rnd().equiDoubles(-r, -l, true, true);\n+        equi.limit(SAFETY_FACTOR * steps).forEach(set::add);\n+        assertEquals(steps + 1, set.size());\n+        checkEquidistance(set);\n+\n+        set.clear();\n+        equi = rnd().equiDoubles(-r, -l, true, true);\n+        equi.limit(SAFETY_FACTOR * steps).forEach(set::add);\n+        assertEquals(steps + 1, set.size());\n+        checkEquidistance(set);\n+\n+        set.clear();\n+        equi = rnd().equiDoubles(-r, -l, false, true);\n+        equi.limit(SAFETY_FACTOR * steps).forEach(set::add);\n+        assertEquals(steps, set.size());\n+        checkEquidistance(set);\n+\n+        set.clear();\n+        equi = rnd().equiDoubles(-r, -l, false, false);\n+        equi.limit(SAFETY_FACTOR * steps).forEach(set::add);\n+        assertEquals(steps - 1, set.size());\n+        checkEquidistance(set);\n+    }\n+\n+    static Arguments[] tightWithIrregularSpacing() {\n+        return new Arguments[] {\n+                arguments(0x1p-1, (short) 15, (short) 23),\n+                arguments(0x1p0, (short) 17, (short) 5),\n+                arguments(0x1p1, (short) 7, (short) 8),\n+                arguments(0x1p-600, (short) 28, (short) 33),\n+                arguments(0x1p600, (short) 9, (short) 19),\n+        };\n+    }\n+\n+    \/*\n+     * m must be a power of 2 greater than Double.MIN_NORMAL\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource\n+    void tightWithIrregularSpacing(double m, short lSteps, short rSteps) {\n+        double l = nextDown(m, 2 * lSteps);\n+        double r = nextUp(m, rSteps);\n+        int steps = lSteps + rSteps;\n+\n+        TreeSet<Double> set = new TreeSet<>();\n+        DoubleStream equi = rnd().equiDoubles(l, r, true, false);\n+        equi.limit(SAFETY_FACTOR * steps).forEach(set::add);\n+        assertEquals(steps, set.size());\n+        checkEquidistance(set);\n+\n+        set.clear();\n+        equi = rnd().equiDoubles(l, r, true, true);\n+        equi.limit(SAFETY_FACTOR * steps).forEach(set::add);\n+        assertEquals(steps + 1, set.size());\n+        checkEquidistance(set);\n+\n+        set.clear();\n+        equi = rnd().equiDoubles(l, r, false, true);\n+        equi.limit(SAFETY_FACTOR * steps).forEach(set::add);\n+        assertEquals(steps, set.size());\n+        checkEquidistance(set);\n+\n+        set.clear();\n+        equi = rnd().equiDoubles(l, r, false, false);\n+        equi.limit(SAFETY_FACTOR * steps).forEach(set::add);\n+        assertEquals(steps - 1, set.size());\n+        checkEquidistance(set);\n+\n+        \/* with negated intervals *\/\n+        set.clear();\n+        equi = rnd().equiDoubles(-r, -l, true, true);\n+        equi.limit(SAFETY_FACTOR * steps).forEach(set::add);\n+        assertEquals(steps + 1, set.size());\n+        checkEquidistance(set);\n+\n+        set.clear();\n+        equi = rnd().equiDoubles(-r, -l, true, true);\n+        equi.limit(SAFETY_FACTOR * steps).forEach(set::add);\n+        assertEquals(steps + 1, set.size());\n+        checkEquidistance(set);\n+\n+        set.clear();\n+        equi = rnd().equiDoubles(-r, -l, false, true);\n+        equi.limit(SAFETY_FACTOR * steps).forEach(set::add);\n+        assertEquals(steps, set.size());\n+        checkEquidistance(set);\n+\n+        set.clear();\n+        equi = rnd().equiDoubles(-r, -l, false, false);\n+        equi.limit(SAFETY_FACTOR * steps).forEach(set::add);\n+        assertEquals(steps - 1, set.size());\n+        checkEquidistance(set);\n+    }\n+\n+    private void checkEquidistance(TreeSet<Double> set) {\n+        if (set.size() < 3) {\n+            return;\n+        }\n+        Iterator<Double> iter = set.iterator();\n+        double prev = iter.next();\n+        double curr = iter.next();\n+        double delta = curr - prev;\n+        while (iter.hasNext()) {\n+            prev = curr;\n+            curr = iter.next();\n+            assertEquals(delta, curr - prev);\n+        }\n+    }\n+\n+    static Arguments[] empty() {\n+        return new Arguments[] {\n+                arguments(1.0),\n+                arguments(-1.0),\n+                arguments(0.0),\n+                arguments(nextDown(Double.MAX_VALUE, 1)),\n+                arguments(nextUp(-Double.MAX_VALUE, 1)),\n+        };\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource\n+    void empty(double l) {\n+        assertThrows(IllegalArgumentException.class,\n+                () -> rnd().equiDoubles(l, l, true, false)\n+        );\n+        assertThrows(IllegalArgumentException.class,\n+                () -> rnd().equiDoubles(l, nextUp(l, 1), false, false)\n+        );\n+        assertThrows(IllegalArgumentException.class,\n+                () -> rnd().equiDoubles(nextDown(l, 1), l, false, false)\n+        );\n+        assertThrows(IllegalArgumentException.class,\n+                () -> rnd().equiDoubles(l, l, false, true)\n+        );\n+        assertThrows(IllegalArgumentException.class,\n+                () -> rnd().equiDoubles(l, nextDown(l, 1), true, true)\n+        );\n+        assertThrows(IllegalArgumentException.class,\n+                () -> rnd().equiDoubles(nextUp(l, 1), l, true, true)\n+        );\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/util\/Random\/EquiDoublesTest.java","additions":352,"deletions":0,"binary":false,"changes":352,"status":"added"}]}