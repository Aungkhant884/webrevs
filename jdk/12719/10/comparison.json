{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,0 @@\n-import jdk.internal.util.random.RandomSupport.*;\n@@ -40,0 +39,2 @@\n+import static java.lang.Math.*;\n+\n@@ -255,0 +256,168 @@\n+    \/**\n+     * Returns an effectively unlimited stream of pseudorandomly chosen\n+     * {@code double} values, where each value is between the specified\n+     * {@code left} boundary and the specified {@code right} boundary.\n+     * The {@code left} boundary is included as indicated by\n+     * {@code isLeftIncluded}; similarly, the {@code right} boundary is included\n+     * as indicated by {@code isRightIncluded}.\n+     *\n+     * <p>The stream potentially produces all multiples <i>k<\/i> &delta;\n+     * (<i>k<\/i> integer) lying in the interval specified by the parameters,\n+     * where &delta; > 0 is the smallest number for which all these multiples\n+     * are exact {@code double}s.\n+     * They are therefore all equidistant.\n+     * The uniformity of the distribution of the {@code double}s produced by\n+     * the stream depends on the quality of the underlying {@link #nextLong(long)}.\n+     *\n+     * @implSpec The default implementation first determines the &delta; above.\n+     * It then computes both the smallest integer <i>k<\/i><sub><i>l<\/i><\/sub>\n+     * such that <i>k<\/i><sub><i>l<\/i><\/sub> &delta; lies <em>inside<\/em>\n+     * the given interval, and the smallest integer <i>n<\/i> > 0 such that\n+     * (<i>k<\/i><sub><i>l<\/i><\/sub> + <i>n<\/i>) &delta; lies\n+     * <em>outside<\/em> the interval.\n+     * Finally, it returns a stream which generates the {@code double}s\n+     * according to (<i>k<\/i><sub><i>l<\/i><\/sub> + {@code nextLong(}<i>n<\/i>{@code )})\n+     * &delta;.\n+     * The stream never produces {@code -0.0}, although it may produce\n+     * {@code 0.0} if the specified interval contains 0.\n+     *\n+     * @param left the left boundary\n+     * @param right the right boundary\n+     * @param isLeftIncluded whether the {@code left} boundary is included\n+     * @param isRightIncluded whether the {@code right} boundary is included\n+     *\n+     * @return a stream of pseudorandomly chosen {@code double} values, each\n+     *         between {@code left} and {@code right}, as specified above.\n+     *\n+     * @throws IllegalArgumentException if {@code left} is not finite,\n+     *         or {@code right} is not finite, or if the specified interval\n+     *         is empty.\n+     *\n+     * @since 21\n+     *\/\n+    default DoubleStream equiDoubles(double left, double right,\n+        boolean isLeftIncluded, boolean isRightIncluded) {\n+        if (!(Double.NEGATIVE_INFINITY < left\n+                && right < Double.POSITIVE_INFINITY\n+                && (isLeftIncluded ? left : nextUp(left))\n+                    <= (isRightIncluded ? right : nextDown(right)))) {\n+            throw new IllegalArgumentException(\n+                    \"the boundaries must be finite and the interval must not be empty\");\n+        }\n+\n+        \/*\n+         * Inspired by\n+         *      Goualard, \"Drawing random floating-point numbers from an\n+         *      interval\", ACM TOMACS, 2022, 32 (3)\n+         *      (https:\/\/hal.science\/hal-03282794v4)\n+         * although implemented differently.\n+         *\n+         * It is assumed that left <= right.\n+         * Whether the boundaries of the interval I = <left, right> are included\n+         * is indicated by isLeftIncluded and isRightIncluded.\n+         *\n+         * delta > 0 is the smallest double such that every product k delta\n+         * (k integer) that lies in I is an exact double as well.\n+         * It turns out that delta is always a power of 2.\n+         *\n+         * kl is the smallest k such that k delta is inside I.\n+         * kr > kl is the smallest k such that k delta is outside I.\n+         * n is kr - kl\n+         *\/\n+        double delta;  \/\/ captured\n+        long kl;  \/\/ captured\n+        long kr;\n+        long n;  \/\/ captured\n+\n+        if (left <= -right) {\n+            \/*\n+             * Here,\n+             *      left <= 0,      left <= right <= -left\n+             *      P = Double.PRECISION\n+             *\n+             * delta is the distance from left to the next double in the\n+             * direction of positive infinity.\n+             * Most of the time, this is equivalent to the ulp of left, but not\n+             * always.\n+             * For example, Math.ulp(-1.0) == 2.220446049250313E-16, whereas\n+             * delta == 1.1102230246251565E-16.\n+             * \n+             * Every product k delta lying in [left, -left] is an exact double.\n+             * Thus, every product k delta lying in I is an exact double, too.\n+             * Any other positive eps < delta does not meet this property:\n+             * some product k eps lying in I is not an exact double.\n+             * On the other hand, any other eps > delta would generate more\n+             * sparse products k eps, that is, fewer doubles in I.\n+             * delta is therefore the best value to ensure the largest number\n+             * of equidistant doubles in the interval I.\n+             *\n+             * left \/ delta is an exact double and an exact integer with\n+             *      -2^P <= left \/ delta <= 0\n+             * Thus, kl is computed exactly.\n+             *\n+             * Mathematically,\n+             *      kr = ceil(right \/ delta),           if !isRightIncluded\n+             *      kr = floor(right \/ delta) + 1,      if isRightIncluded\n+             * The double division rd = right \/ delta never overflows and is\n+             * exact, except in the presence of underflows. But even underflows\n+             * do not affect the outcomes of ceil() and floor(), except,\n+             * in turn, when the result drops to 0, that is, rd = 0.\n+             *\n+             * crd is a corrected version of rd when rd is zero. It is simply\n+             * right \/ delta, but rounded away from 0 to preserve information\n+             * ensuring correct outcomes in ceil() and floor().\n+             *\n+             * We know that -2^P <= kl, so\n+             *      -2^P <= kl + nextLong(n)\n+             * Also, since right <= -left, we know that\n+             *      kr <= -kl + 1\n+             * so that\n+             *      0 < n <= -2 kl + 1\n+             * This implies\n+             *      kl + nextLong(n) <= kl + (-2 kl) = -kl <= 2^P\n+             * and thus\n+             *      -2^P <= kl + nextLong(n) <= 2^P\n+             * which shows that kl + nextLong(n) can be cast exactly to double.\n+             *\n+             * Further, if isLeftIncluded then left = kl delta, so that we get\n+             *      left = kl * delta <= (kl + nextLong(n)) * delta\n+             * For any other k < kl, when nextLong(n) = 0 we would have\n+             *      (k + nextLong(n)) * delta < left\n+             * Otherwise, left = (kl - 1) delta, and therefore\n+             *      left = (kl - 1) * delta < (kl + nextLong(n)) * delta\n+             * For any other k < kl, when nextLong(n) = 0 we would get\n+             *      (k + nextLong(n)) * delta <= left\n+             * Either way, the lhs expression would not belong to I.\n+             * That is, kl is the smallest integer such that kl delta always\n+             * lies in I (it is an exact double).\n+             *\n+             * Similar considerations show that kr is the smallest integer such\n+             * that kr delta lies to the right of I (it is an exact double).\n+             *\n+             * All the above means that (kl + nextLong(n)) * delta is an exact\n+             * double lying in I and that kl and kr, thus n, are the best\n+             * possible choices to ensure the largest number of equidistant\n+             * doubles in I. Uniform distribution relies on the guarantee\n+             * afforded by nextLong().\n+             *\/\n+            delta = nextUp(left) - left;\n+            double rd = right \/ delta;\n+            double crd = rd != 0 || right == 0 ? rd : copySign(Double.MIN_VALUE, right);\n+            kr = isRightIncluded ? (long) floor(crd) + 1 : (long) ceil(crd);\n+            kl = (long) (left \/ delta) + (isLeftIncluded ? 0 : 1);\n+        } else {\n+            \/* Here,\n+             *      right > 0,      -right < left <= right\n+             *\n+             * Considerations similar to the ones above apply here as well.\n+             *\/\n+            delta = right - nextDown(right);\n+            double ld = left \/ delta;\n+            double cld = ld != 0 || left == 0 ? ld : copySign(Double.MIN_VALUE, left);\n+            kl = isLeftIncluded ? (long) ceil(cld) : (long) floor(cld) + 1;\n+            kr = (long) (right \/ delta) + (isRightIncluded ? 1 : 0);\n+        }\n+        n = kr - kl;\n+        return DoubleStream.generate(() -> (kl + nextLong(n)) * delta).sequential();\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/util\/random\/RandomGenerator.java","additions":171,"deletions":2,"binary":false,"changes":173,"status":"modified"},{"patch":"@@ -0,0 +1,349 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.test.lib.RandomFactory;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import java.util.Iterator;\n+import java.util.TreeSet;\n+import java.util.random.RandomGenerator;\n+import java.util.stream.DoubleStream;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+import static org.junit.jupiter.params.provider.Arguments.arguments;\n+\n+\/**\n+ * @test\n+ * @bug 8302987\n+ * @key randomness\n+ *\n+ * @summary Check consistency of RandomGenerator::equiDoubles\n+ * @library \/test\/lib\n+ * @run junit EquiDoublesTest\n+ *\n+ *\/\n+\n+public class EquiDoublesTest {\n+\n+    private static final int SAMPLES = 100_000;\n+\n+    \/*\n+     * A factor to use in the tight*() tests to make sure that\n+     * all equidistant doubles are generated.\n+     *\/\n+    private static final long SAFETY_FACTOR = 100L;\n+    private static final RandomGenerator rnd = RandomFactory.getRandom();\n+\n+    private static double nextUp(double d, int steps) {\n+        for (int i = 0; i < steps; ++i) {\n+            d = Math.nextUp(d);\n+        }\n+        return d;\n+    }\n+\n+    private static double nextDown(double d, int steps) {\n+        for (int i = 0; i < steps; ++i) {\n+            d = Math.nextDown(d);\n+        }\n+        return d;\n+    }\n+\n+    static Arguments[] equi() {\n+        return new Arguments[] {\n+                arguments(0.0, 1e-9),\n+                arguments(1.0, 1.1),\n+                arguments(1.0e23, 1.1e23),\n+                arguments(1.0e300, 1.1e300),\n+                arguments(-1.2, 1.1),\n+                arguments(-1.2e-30, 1.1e6),\n+                arguments(-Double.MIN_VALUE, Double.MIN_VALUE),\n+                arguments(-Double.MAX_VALUE, Double.MAX_VALUE),\n+        };\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource\n+    void equi(double l, double r) {\n+        double[] minmax = new double[2];\n+\n+        resetMinmax(minmax);\n+        DoubleStream equi = rnd.equiDoubles(l, r, true, false);\n+        equi.limit(SAMPLES).forEach(d -> updateMinmax(minmax, d));\n+        assertTrue(l <= minmax[0]);\n+        assertTrue(minmax[1] < r);\n+\n+        resetMinmax(minmax);\n+        equi = rnd.equiDoubles(l, r, true, true);\n+        equi.limit(SAMPLES).forEach(d -> updateMinmax(minmax, d));\n+        assertTrue(l <= minmax[0]);\n+        assertTrue(minmax[1] <= r);\n+\n+        resetMinmax(minmax);\n+        equi = rnd.equiDoubles(l, r, false, true);\n+        equi.limit(SAMPLES).forEach(d -> updateMinmax(minmax, d));\n+        assertTrue(l < minmax[0]);\n+        assertTrue(minmax[1] <= r);\n+\n+        resetMinmax(minmax);\n+        equi = rnd.equiDoubles(l, r, false, false);\n+        equi.limit(SAMPLES).forEach(d -> updateMinmax(minmax, d));\n+        assertTrue(l < minmax[0]);\n+        assertTrue(minmax[1] < r);\n+\n+        \/* with negated intervals *\/\n+        resetMinmax(minmax);\n+        equi = rnd.equiDoubles(-r, -l, true, false);\n+        equi.limit(SAMPLES).forEach(d -> updateMinmax(minmax, d));\n+        assertTrue(-r <= minmax[0]);\n+        assertTrue(minmax[1] < -l);\n+\n+        resetMinmax(minmax);\n+        equi = rnd.equiDoubles(-r, -l, true, true);\n+        equi.limit(SAMPLES).forEach(d -> updateMinmax(minmax, d));\n+        assertTrue(-r <= minmax[0]);\n+        assertTrue(minmax[1] <= -l);\n+\n+        resetMinmax(minmax);\n+        equi = rnd.equiDoubles(-r, -l, false, true);\n+        equi.limit(SAMPLES).forEach(d -> updateMinmax(minmax, d));\n+        assertTrue(-r < minmax[0]);\n+        assertTrue(minmax[1] <= -l);\n+\n+        resetMinmax(minmax);\n+        equi = rnd.equiDoubles(-r, -l, false, false);\n+        equi.limit(SAMPLES).forEach(d -> updateMinmax(minmax, d));\n+        assertTrue(-r < minmax[0]);\n+        assertTrue(minmax[1] < -l);\n+    }\n+\n+    private void resetMinmax(double[] minmax) {\n+        minmax[0] = Double.POSITIVE_INFINITY;\n+        minmax[1] = Double.NEGATIVE_INFINITY;\n+    }\n+\n+    private void updateMinmax(double[] minmax, double d) {\n+        if (d < minmax[0]) {\n+            minmax[0] = d;\n+        }\n+        if (d > minmax[1]) {\n+            minmax[1] = d;\n+        }\n+    }\n+\n+    static Arguments[] tight() {\n+        return new Arguments[] {\n+                arguments(0.0, (short) 100),\n+                arguments(1.0, (short) 100),\n+                arguments(1.1, (short) 100),\n+                arguments(1.0e23, (short) 100),\n+                arguments(1.0e300, (short) 100),\n+                arguments(-1.2, (short) 100),\n+                arguments(-1.2e-30, (short) 100),\n+                arguments(-Double.MIN_VALUE, (short) 100),\n+\n+                arguments(-Double.MIN_VALUE, (short) 2),\n+                arguments(-Double.MAX_VALUE, (short) 2),\n+        };\n+    }\n+\n+    \/*\n+     * All equidistant doubles in a tight range are expected to be generated.\n+     * The arguments must be chosen as to not overlap a value with irregular\n+     * spacing around it.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource\n+    void tight(double l, short steps) {\n+        double r = nextUp(l, steps);\n+\n+        TreeSet<Double> set = new TreeSet<>();\n+        DoubleStream equi = rnd.equiDoubles(l, r, true, false);\n+        equi.limit(SAFETY_FACTOR * steps).forEach(set::add);\n+        assertEquals(steps, set.size());\n+        checkEquidistance(set);\n+\n+        set.clear();\n+        equi = rnd.equiDoubles(l, r, true, true);\n+        equi.limit(SAFETY_FACTOR * steps).forEach(set::add);\n+        assertEquals(steps + 1, set.size());\n+        checkEquidistance(set);\n+\n+        set.clear();\n+        equi = rnd.equiDoubles(l, r, false, true);\n+        equi.limit(SAFETY_FACTOR * steps).forEach(set::add);\n+        assertEquals(steps, set.size());\n+        checkEquidistance(set);\n+\n+        set.clear();\n+        equi = rnd.equiDoubles(l, r, false, false);\n+        equi.limit(SAFETY_FACTOR * steps).forEach(set::add);\n+        assertEquals(steps - 1, set.size());\n+        checkEquidistance(set);\n+\n+        \/* with negated intervals *\/\n+        set.clear();\n+        equi = rnd.equiDoubles(-r, -l, true, true);\n+        equi.limit(SAFETY_FACTOR * steps).forEach(set::add);\n+        assertEquals(steps + 1, set.size());\n+        checkEquidistance(set);\n+\n+        set.clear();\n+        equi = rnd.equiDoubles(-r, -l, true, true);\n+        equi.limit(SAFETY_FACTOR * steps).forEach(set::add);\n+        assertEquals(steps + 1, set.size());\n+        checkEquidistance(set);\n+\n+        set.clear();\n+        equi = rnd.equiDoubles(-r, -l, false, true);\n+        equi.limit(SAFETY_FACTOR * steps).forEach(set::add);\n+        assertEquals(steps, set.size());\n+        checkEquidistance(set);\n+\n+        set.clear();\n+        equi = rnd.equiDoubles(-r, -l, false, false);\n+        equi.limit(SAFETY_FACTOR * steps).forEach(set::add);\n+        assertEquals(steps - 1, set.size());\n+        checkEquidistance(set);\n+    }\n+\n+    static Arguments[] tightWithIrregularSpacing() {\n+        return new Arguments[] {\n+                arguments(0x1p-1, (short) 15, (short) 23),\n+                arguments(0x1p0, (short) 17, (short) 5),\n+                arguments(0x1p1, (short) 7, (short) 8),\n+                arguments(0x1p-600, (short) 28, (short) 33),\n+                arguments(0x1p600, (short) 9, (short) 19),\n+        };\n+    }\n+\n+    \/*\n+     * m must be a power of 2 greater than Double.MIN_NORMAL\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource\n+    void tightWithIrregularSpacing(double m, short lSteps, short rSteps) {\n+        double l = nextDown(m, 2 * lSteps);\n+        double r = nextUp(m, rSteps);\n+        int steps = lSteps + rSteps;\n+\n+        TreeSet<Double> set = new TreeSet<>();\n+        DoubleStream equi = rnd.equiDoubles(l, r, true, false);\n+        equi.limit(SAFETY_FACTOR * steps).forEach(set::add);\n+        assertEquals(steps, set.size());\n+        checkEquidistance(set);\n+\n+        set.clear();\n+        equi = rnd.equiDoubles(l, r, true, true);\n+        equi.limit(SAFETY_FACTOR * steps).forEach(set::add);\n+        assertEquals(steps + 1, set.size());\n+        checkEquidistance(set);\n+\n+        set.clear();\n+        equi = rnd.equiDoubles(l, r, false, true);\n+        equi.limit(SAFETY_FACTOR * steps).forEach(set::add);\n+        assertEquals(steps, set.size());\n+        checkEquidistance(set);\n+\n+        set.clear();\n+        equi = rnd.equiDoubles(l, r, false, false);\n+        equi.limit(SAFETY_FACTOR * steps).forEach(set::add);\n+        assertEquals(steps - 1, set.size());\n+        checkEquidistance(set);\n+\n+        \/* with negated intervals *\/\n+        set.clear();\n+        equi = rnd.equiDoubles(-r, -l, true, true);\n+        equi.limit(SAFETY_FACTOR * steps).forEach(set::add);\n+        assertEquals(steps + 1, set.size());\n+        checkEquidistance(set);\n+\n+        set.clear();\n+        equi = rnd.equiDoubles(-r, -l, true, true);\n+        equi.limit(SAFETY_FACTOR * steps).forEach(set::add);\n+        assertEquals(steps + 1, set.size());\n+        checkEquidistance(set);\n+\n+        set.clear();\n+        equi = rnd.equiDoubles(-r, -l, false, true);\n+        equi.limit(SAFETY_FACTOR * steps).forEach(set::add);\n+        assertEquals(steps, set.size());\n+        checkEquidistance(set);\n+\n+        set.clear();\n+        equi = rnd.equiDoubles(-r, -l, false, false);\n+        equi.limit(SAFETY_FACTOR * steps).forEach(set::add);\n+        assertEquals(steps - 1, set.size());\n+        checkEquidistance(set);\n+    }\n+\n+    private void checkEquidistance(TreeSet<Double> set) {\n+        if (set.size() < 3) {\n+            return;\n+        }\n+        Iterator<Double> iter = set.iterator();\n+        double prev = iter.next();\n+        double curr = iter.next();\n+        double delta = curr - prev;\n+        while (iter.hasNext()) {\n+            prev = curr;\n+            curr = iter.next();\n+            assertEquals(delta, curr - prev);\n+        }\n+    }\n+\n+    static Arguments[] empty() {\n+        return new Arguments[] {\n+                arguments(1.0),\n+                arguments(-1.0),\n+                arguments(0.0),\n+                arguments(nextDown(Double.MAX_VALUE, 1)),\n+                arguments(nextUp(-Double.MAX_VALUE, 1)),\n+        };\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource\n+    void empty(double l) {\n+        assertThrows(IllegalArgumentException.class,\n+                () -> rnd.equiDoubles(l, l, true, false)\n+        );\n+        assertThrows(IllegalArgumentException.class,\n+                () -> rnd.equiDoubles(l, nextUp(l, 1), false, false)\n+        );\n+        assertThrows(IllegalArgumentException.class,\n+                () -> rnd.equiDoubles(nextDown(l, 1), l, false, false)\n+        );\n+        assertThrows(IllegalArgumentException.class,\n+                () -> rnd.equiDoubles(l, l, false, true)\n+        );\n+        assertThrows(IllegalArgumentException.class,\n+                () -> rnd.equiDoubles(l, nextDown(l, 1), true, true)\n+        );\n+        assertThrows(IllegalArgumentException.class,\n+                () -> rnd.equiDoubles(nextUp(l, 1), l, true, true)\n+        );\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/util\/Random\/EquiDoublesTest.java","additions":349,"deletions":0,"binary":false,"changes":349,"status":"added"}]}