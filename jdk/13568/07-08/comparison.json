{"files":[{"patch":"@@ -188,2 +188,3 @@\n-             * Use an inexpensive approximation of the golden ratio\n-             * to select five sample elements and determine pivots.\n+             * Divide the given array into the golden ratio using\n+             * an inexpensive approximation to select five sample\n+             * elements and determine pivots.\n@@ -191,1 +192,1 @@\n-            int step = (size >> 2) + (size >> 3) + (size >> 8) + 1;\n+            int step = (size >> 2) + (size >> 3) + (size >> 7);\n@@ -208,1 +209,2 @@\n-             * Check large random data, taking into account parallel context.\n+             * Check if part is large and contains random\n+             * data, taking into account parallel context.\n@@ -215,1 +217,1 @@\n-             * Sort these elements in place by the combination\n+             * Sort these elements in-place by the combination\n@@ -218,7 +220,7 @@\n-             *    1  ------------o-----o------------\n-             *                   |     |\n-             *    2  ------o-----|-----o-----o------\n-             *             |     |           |\n-             *    4  ------|-----o-----o-----o------\n-             *             |           |\n-             *    5  ------o-----------o------------\n+             *   1 ----------o-------------o------------------\n+             *               |             |\n+             *   2 ----------|------o------o------o-----------\n+             *               |      |             |\n+             *   4 ----------o------|------o------o-----------\n+             *                      |      |\n+             *   5 -----------------o------o------------------\n@@ -226,1 +228,0 @@\n-            if (a[e2] > a[e5]) { int t = a[e2]; a[e2] = a[e5]; a[e5] = t; }\n@@ -228,1 +229,1 @@\n-            if (a[e1] > a[e2]) { int t = a[e1]; a[e1] = a[e2]; a[e2] = t; }\n+            if (a[e2] > a[e5]) { int t = a[e2]; a[e2] = a[e5]; a[e5] = t; }\n@@ -230,0 +231,1 @@\n+            if (a[e1] > a[e2]) { int t = a[e1]; a[e1] = a[e2]; a[e2] = t; }\n@@ -323,1 +325,1 @@\n-                    if (ak < pivot1) { \/\/ Move a[k] to the left side\n+                    if (ak < pivot1) { \/\/ Move a[k] to the left part\n@@ -336,1 +338,1 @@\n-                    } else if (ak > pivot2) { \/\/ Move a[k] to the right side\n+                    } else if (ak > pivot2) { \/\/ Move a[k] to the right part\n@@ -404,1 +406,1 @@\n-                        if (ak < pivot) { \/\/ Move a[k] to the left side\n+                        if (ak < pivot) { \/\/ Move a[k] to the left part\n@@ -411,1 +413,1 @@\n-                        } else { \/\/ ak > pivot - Move a[k] to the right side\n+                        } else { \/\/ ak > pivot - Move a[k] to the right part\n@@ -916,1 +918,1 @@\n-         * Check if we can skip given digit.\n+         * Check if we can skip the given digit.\n@@ -1046,2 +1048,3 @@\n-             * Use an inexpensive approximation of the golden ratio\n-             * to select five sample elements and determine pivots.\n+             * Divide the given array into the golden ratio using\n+             * an inexpensive approximation to select five sample\n+             * elements and determine pivots.\n@@ -1049,1 +1052,1 @@\n-            int step = (size >> 2) + (size >> 3) + (size >> 8) + 1;\n+            int step = (size >> 2) + (size >> 3) + (size >> 7);\n@@ -1066,1 +1069,2 @@\n-             * Check large random data, taking into account parallel context.\n+             * Check if part is large and contains random\n+             * data, taking into account parallel context.\n@@ -1073,1 +1077,1 @@\n-             * Sort these elements in place by the combination\n+             * Sort these elements in-place by the combination\n@@ -1076,7 +1080,7 @@\n-             *    1  ------------o-----o------------\n-             *                   |     |\n-             *    2  ------o-----|-----o-----o------\n-             *             |     |           |\n-             *    4  ------|-----o-----o-----o------\n-             *             |           |\n-             *    5  ------o-----------o------------\n+             *   1 ----------o-------------o------------------\n+             *               |             |\n+             *   2 ----------|------o------o------o-----------\n+             *               |      |             |\n+             *   4 ----------o------|------o------o-----------\n+             *                      |      |\n+             *   5 -----------------o------o------------------\n@@ -1084,1 +1088,0 @@\n-            if (a[e2] > a[e5]) { long t = a[e2]; a[e2] = a[e5]; a[e5] = t; }\n@@ -1086,1 +1089,1 @@\n-            if (a[e1] > a[e2]) { long t = a[e1]; a[e1] = a[e2]; a[e2] = t; }\n+            if (a[e2] > a[e5]) { long t = a[e2]; a[e2] = a[e5]; a[e5] = t; }\n@@ -1088,0 +1091,1 @@\n+            if (a[e1] > a[e2]) { long t = a[e1]; a[e1] = a[e2]; a[e2] = t; }\n@@ -1181,1 +1185,1 @@\n-                    if (ak < pivot1) { \/\/ Move a[k] to the left side\n+                    if (ak < pivot1) { \/\/ Move a[k] to the left part\n@@ -1194,1 +1198,1 @@\n-                    } else if (ak > pivot2) { \/\/ Move a[k] to the right side\n+                    } else if (ak > pivot2) { \/\/ Move a[k] to the right part\n@@ -1262,1 +1266,1 @@\n-                        if (ak < pivot) { \/\/ Move a[k] to the left side\n+                        if (ak < pivot) { \/\/ Move a[k] to the left part\n@@ -1269,1 +1273,1 @@\n-                        } else { \/\/ ak > pivot - Move a[k] to the right side\n+                        } else { \/\/ ak > pivot - Move a[k] to the right part\n@@ -2024,2 +2028,3 @@\n-             * Use an inexpensive approximation of the golden ratio\n-             * to select five sample elements and determine pivots.\n+             * Divide the given array into the golden ratio using\n+             * an inexpensive approximation to select five sample\n+             * elements and determine pivots.\n@@ -2027,1 +2032,1 @@\n-            int step = (size >> 2) + (size >> 3) + (size >> 8) + 1;\n+            int step = (size >> 2) + (size >> 3) + (size >> 7);\n@@ -2044,1 +2049,1 @@\n-             * Sort these elements in place by the combination\n+             * Sort these elements in-place by the combination\n@@ -2047,7 +2052,7 @@\n-             *    1  ------------o-----o------------\n-             *                   |     |\n-             *    2  ------o-----|-----o-----o------\n-             *             |     |           |\n-             *    4  ------|-----o-----o-----o------\n-             *             |           |\n-             *    5  ------o-----------o------------\n+             *   1 ----------o-------------o------------------\n+             *               |             |\n+             *   2 ----------|------o------o------o-----------\n+             *               |      |             |\n+             *   4 ----------o------|------o------o-----------\n+             *                      |      |\n+             *   5 -----------------o------o------------------\n@@ -2055,1 +2060,0 @@\n-            if (a[e2] > a[e5]) { char t = a[e2]; a[e2] = a[e5]; a[e5] = t; }\n@@ -2057,1 +2061,1 @@\n-            if (a[e1] > a[e2]) { char t = a[e1]; a[e1] = a[e2]; a[e2] = t; }\n+            if (a[e2] > a[e5]) { char t = a[e2]; a[e2] = a[e5]; a[e5] = t; }\n@@ -2059,0 +2063,1 @@\n+            if (a[e1] > a[e2]) { char t = a[e1]; a[e1] = a[e2]; a[e2] = t; }\n@@ -2135,1 +2140,1 @@\n-                    if (ak < pivot1) { \/\/ Move a[k] to the left side\n+                    if (ak < pivot1) { \/\/ Move a[k] to the left part\n@@ -2148,1 +2153,1 @@\n-                    } else if (ak > pivot2) { \/\/ Move a[k] to the right side\n+                    } else if (ak > pivot2) { \/\/ Move a[k] to the right part\n@@ -2211,1 +2216,1 @@\n-                        if (ak < pivot) { \/\/ Move a[k] to the left side\n+                        if (ak < pivot) { \/\/ Move a[k] to the left part\n@@ -2218,1 +2223,1 @@\n-                        } else { \/\/ ak > pivot - Move a[k] to the right side\n+                        } else { \/\/ ak > pivot - Move a[k] to the right part\n@@ -2351,2 +2356,3 @@\n-             * Use an inexpensive approximation of the golden ratio\n-             * to select five sample elements and determine pivots.\n+             * Divide the given array into the golden ratio using\n+             * an inexpensive approximation to select five sample\n+             * elements and determine pivots.\n@@ -2354,1 +2360,1 @@\n-            int step = (size >> 2) + (size >> 3) + (size >> 8) + 1;\n+            int step = (size >> 2) + (size >> 3) + (size >> 7);\n@@ -2371,1 +2377,1 @@\n-             * Sort these elements in place by the combination\n+             * Sort these elements in-place by the combination\n@@ -2374,7 +2380,7 @@\n-             *    1  ------------o-----o------------\n-             *                   |     |\n-             *    2  ------o-----|-----o-----o------\n-             *             |     |           |\n-             *    4  ------|-----o-----o-----o------\n-             *             |           |\n-             *    5  ------o-----------o------------\n+             *   1 ----------o-------------o------------------\n+             *               |             |\n+             *   2 ----------|------o------o------o-----------\n+             *               |      |             |\n+             *   4 ----------o------|------o------o-----------\n+             *                      |      |\n+             *   5 -----------------o------o------------------\n@@ -2382,1 +2388,0 @@\n-            if (a[e2] > a[e5]) { short t = a[e2]; a[e2] = a[e5]; a[e5] = t; }\n@@ -2384,1 +2389,1 @@\n-            if (a[e1] > a[e2]) { short t = a[e1]; a[e1] = a[e2]; a[e2] = t; }\n+            if (a[e2] > a[e5]) { short t = a[e2]; a[e2] = a[e5]; a[e5] = t; }\n@@ -2386,0 +2391,1 @@\n+            if (a[e1] > a[e2]) { short t = a[e1]; a[e1] = a[e2]; a[e2] = t; }\n@@ -2462,1 +2468,1 @@\n-                    if (ak < pivot1) { \/\/ Move a[k] to the left side\n+                    if (ak < pivot1) { \/\/ Move a[k] to the left part\n@@ -2475,1 +2481,1 @@\n-                    } else if (ak > pivot2) { \/\/ Move a[k] to the right side\n+                    } else if (ak > pivot2) { \/\/ Move a[k] to the right part\n@@ -2538,1 +2544,1 @@\n-                        if (ak < pivot) { \/\/ Move a[k] to the left side\n+                        if (ak < pivot) { \/\/ Move a[k] to the left part\n@@ -2545,1 +2551,1 @@\n-                        } else { \/\/ ak > pivot - Move a[k] to the right side\n+                        } else { \/\/ ak > pivot - Move a[k] to the right part\n@@ -2704,2 +2710,3 @@\n-             * Use an inexpensive approximation of the golden ratio\n-             * to select five sample elements and determine pivots.\n+             * Divide the given array into the golden ratio using\n+             * an inexpensive approximation to select five sample\n+             * elements and determine pivots.\n@@ -2707,1 +2714,1 @@\n-            int step = (size >> 2) + (size >> 3) + (size >> 8) + 1;\n+            int step = (size >> 2) + (size >> 3) + (size >> 7);\n@@ -2724,1 +2731,2 @@\n-             * Check large random data, taking into account parallel context.\n+             * Check if part is large and contains random\n+             * data, taking into account parallel context.\n@@ -2731,1 +2739,1 @@\n-             * Sort these elements in place by the combination\n+             * Sort these elements in-place by the combination\n@@ -2734,7 +2742,7 @@\n-             *    1  ------------o-----o------------\n-             *                   |     |\n-             *    2  ------o-----|-----o-----o------\n-             *             |     |           |\n-             *    4  ------|-----o-----o-----o------\n-             *             |           |\n-             *    5  ------o-----------o------------\n+             *   1 ----------o-------------o------------------\n+             *               |             |\n+             *   2 ----------|------o------o------o-----------\n+             *               |      |             |\n+             *   4 ----------o------|------o------o-----------\n+             *                      |      |\n+             *   5 -----------------o------o------------------\n@@ -2742,1 +2750,0 @@\n-            if (a[e2] > a[e5]) { float t = a[e2]; a[e2] = a[e5]; a[e5] = t; }\n@@ -2744,1 +2751,1 @@\n-            if (a[e1] > a[e2]) { float t = a[e1]; a[e1] = a[e2]; a[e2] = t; }\n+            if (a[e2] > a[e5]) { float t = a[e2]; a[e2] = a[e5]; a[e5] = t; }\n@@ -2746,0 +2753,1 @@\n+            if (a[e1] > a[e2]) { float t = a[e1]; a[e1] = a[e2]; a[e2] = t; }\n@@ -2839,1 +2847,1 @@\n-                    if (ak < pivot1) { \/\/ Move a[k] to the left side\n+                    if (ak < pivot1) { \/\/ Move a[k] to the left part\n@@ -2852,1 +2860,1 @@\n-                    } else if (ak > pivot2) { \/\/ Move a[k] to the right side\n+                    } else if (ak > pivot2) { \/\/ Move a[k] to the right part\n@@ -2920,1 +2928,1 @@\n-                        if (ak < pivot) { \/\/ Move a[k] to the left side\n+                        if (ak < pivot) { \/\/ Move a[k] to the left part\n@@ -2927,1 +2935,1 @@\n-                        } else { \/\/ ak > pivot - Move a[k] to the right side\n+                        } else { \/\/ ak > pivot - Move a[k] to the right part\n@@ -3592,2 +3600,3 @@\n-             * Use an inexpensive approximation of the golden ratio\n-             * to select five sample elements and determine pivots.\n+             * Divide the given array into the golden ratio using\n+             * an inexpensive approximation to select five sample\n+             * elements and determine pivots.\n@@ -3595,1 +3604,1 @@\n-            int step = (size >> 2) + (size >> 3) + (size >> 8) + 1;\n+            int step = (size >> 2) + (size >> 3) + (size >> 7);\n@@ -3612,1 +3621,2 @@\n-             * Check large random data, taking into account parallel context.\n+             * Check if part is large and contains random\n+             * data, taking into account parallel context.\n@@ -3619,1 +3629,1 @@\n-             * Sort these elements in place by the combination\n+             * Sort these elements in-place by the combination\n@@ -3622,7 +3632,7 @@\n-             *    1  ------------o-----o------------\n-             *                   |     |\n-             *    2  ------o-----|-----o-----o------\n-             *             |     |           |\n-             *    4  ------|-----o-----o-----o------\n-             *             |           |\n-             *    5  ------o-----------o------------\n+             *   1 ----------o-------------o------------------\n+             *               |             |\n+             *   2 ----------|------o------o------o-----------\n+             *               |      |             |\n+             *   4 ----------o------|------o------o-----------\n+             *                      |      |\n+             *   5 -----------------o------o------------------\n@@ -3630,1 +3640,0 @@\n-            if (a[e2] > a[e5]) { double t = a[e2]; a[e2] = a[e5]; a[e5] = t; }\n@@ -3632,1 +3641,1 @@\n-            if (a[e1] > a[e2]) { double t = a[e1]; a[e1] = a[e2]; a[e2] = t; }\n+            if (a[e2] > a[e5]) { double t = a[e2]; a[e2] = a[e5]; a[e5] = t; }\n@@ -3634,0 +3643,1 @@\n+            if (a[e1] > a[e2]) { double t = a[e1]; a[e1] = a[e2]; a[e2] = t; }\n@@ -3727,1 +3737,1 @@\n-                    if (ak < pivot1) { \/\/ Move a[k] to the left side\n+                    if (ak < pivot1) { \/\/ Move a[k] to the left part\n@@ -3740,1 +3750,1 @@\n-                    } else if (ak > pivot2) { \/\/ Move a[k] to the right side\n+                    } else if (ak > pivot2) { \/\/ Move a[k] to the right part\n@@ -3808,1 +3818,1 @@\n-                        if (ak < pivot) { \/\/ Move a[k] to the left side\n+                        if (ak < pivot) { \/\/ Move a[k] to the left part\n@@ -3815,1 +3825,1 @@\n-                        } else { \/\/ ak > pivot - Move a[k] to the right side\n+                        } else { \/\/ ak > pivot - Move a[k] to the right part\n","filename":"src\/java.base\/share\/classes\/java\/util\/DualPivotQuicksort.java","additions":117,"deletions":107,"binary":false,"changes":224,"status":"modified"}]}