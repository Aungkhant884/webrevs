{"files":[{"patch":"@@ -29,1 +29,0 @@\n-import java.util.concurrent.RecursiveTask;\n@@ -31,1 +30,0 @@\n-import jdk.internal.vm.annotation.IntrinsicCandidate;\n@@ -33,0 +31,1 @@\n+import jdk.internal.vm.annotation.IntrinsicCandidate;\n@@ -42,2 +41,3 @@\n- * Quicksort, such as mixed insertion sort, merging of runs and heap\n- * sort, counting sort and parallel merge sort.\n+ * Quicksort such as merging sort, sorting network, Radix sort, heap\n+ * sort, mixed (simple, pin, pair) insertion sort, counting sort and\n+ * parallel merge sort.\n@@ -50,1 +50,1 @@\n- * @version 2018.08.18\n+ * @version 2022.06.14\n@@ -52,1 +52,1 @@\n- * @since 1.7 * 14\n+ * @since 1.7 * 14 ^ 22\n@@ -61,0 +61,2 @@\n+    \/* ---------------- Insertion sort section ---------------- *\/\n+\n@@ -64,1 +66,1 @@\n-    private static final int MAX_MIXED_INSERTION_SORT_SIZE = 65;\n+    private static final int MAX_MIXED_INSERTION_SORT_SIZE = 124;\n@@ -71,4 +73,1 @@\n-    \/**\n-     * Min array size to perform sorting in parallel.\n-     *\/\n-    private static final int MIN_PARALLEL_SORT_SIZE = 4 << 10;\n+    \/* ----------------- Merging sort section ----------------- *\/\n@@ -77,1 +76,1 @@\n-     * Min array size to try merging of runs.\n+     * Min array size to use merging sort.\n@@ -79,1 +78,1 @@\n-    private static final int MIN_TRY_MERGE_SIZE = 4 << 10;\n+    private static final int MIN_MERGING_SORT_SIZE = 512;\n@@ -82,1 +81,1 @@\n-     * Min size of the first run to continue with scanning.\n+     * Min size of run to continue scanning.\n@@ -84,1 +83,1 @@\n-    private static final int MIN_FIRST_RUN_SIZE = 16;\n+    private static final int MIN_RUN_SIZE = 128;\n@@ -86,4 +85,1 @@\n-    \/**\n-     * Min factor for the first runs to continue scanning.\n-     *\/\n-    private static final int MIN_FIRST_RUNS_FACTOR = 7;\n+    \/* ------------------ Radix sort section ------------------ *\/\n@@ -92,1 +88,1 @@\n-     * Max capacity of the index array for tracking runs.\n+     * Min array size to use Radix sort.\n@@ -94,1 +90,3 @@\n-    private static final int MAX_RUN_CAPACITY = 5 << 10;\n+    private static final int MIN_RADIX_SORT_SIZE = 800;\n+\n+    \/* ------------------ Counting sort section --------------- *\/\n@@ -97,1 +95,1 @@\n-     * Min number of runs, required by parallel merging.\n+     * Min size of a byte array to use counting sort.\n@@ -99,1 +97,1 @@\n-    private static final int MIN_RUN_COUNT = 4;\n+    private static final int MIN_BYTE_COUNTING_SORT_SIZE = 36;\n@@ -102,1 +100,1 @@\n-     * Min array size to use parallel merging of parts.\n+     * Min size of a char array to use counting sort.\n@@ -104,1 +102,1 @@\n-    private static final int MIN_PARALLEL_MERGE_PARTS_SIZE = 4 << 10;\n+    private static final int MIN_CHAR_COUNTING_SORT_SIZE = 1700;\n@@ -107,1 +105,1 @@\n-     * Min size of a byte array to use counting sort.\n+     * Min size of a short array to use counting sort.\n@@ -109,1 +107,3 @@\n-    private static final int MIN_BYTE_COUNTING_SORT_SIZE = 64;\n+    private static final int MIN_SHORT_COUNTING_SORT_SIZE = 2100;\n+\n+    \/* -------------------- Common section -------------------- *\/\n@@ -112,1 +112,1 @@\n-     * Min size of a short or char array to use counting sort.\n+     * Min array size to perform sorting in parallel.\n@@ -114,1 +114,1 @@\n-    private static final int MIN_SHORT_OR_CHAR_COUNTING_SORT_SIZE = 1750;\n+    private static final int MIN_PARALLEL_SORT_SIZE = 768;\n@@ -117,1 +117,1 @@\n-     * Threshold of mixed insertion sort is incremented by this value.\n+     * Max recursive depth before switching to heap sort.\n@@ -119,1 +119,1 @@\n-    private static final int DELTA = 3 << 1;\n+    private static final int MAX_RECURSION_DEPTH = 64 << 1;\n@@ -122,1 +122,2 @@\n-     * Max recursive partitioning depth before using heap sort.\n+     * Max size of additional buffer in bytes,\n+     *      limited by max_heap \/ 16 or 2 GB max.\n@@ -124,1 +125,2 @@\n-    private static final int MAX_RECURSION_DEPTH = 64 * DELTA;\n+    private static final int MAX_BUFFER_SIZE =\n+            (int) Math.min(Runtime.getRuntime().maxMemory() >>> 4, Integer.MAX_VALUE);\n@@ -127,2 +129,2 @@\n-     * Represents a function that accepts the array and sorts the specified range\n-     * of the array into ascending order.\n+     * Represents a function that accepts the array and sorts\n+     * the specified range of the array into ascending order.\n@@ -131,1 +133,2 @@\n-    private static interface SortOperation<A> {\n+    private interface SortOperation<T> {\n+\n@@ -139,1 +142,1 @@\n-        void sort(A a, int low, int high);\n+        void sort(T a, int low, int high);\n@@ -146,4 +149,5 @@\n-     * @param array the array to be sorted\n-     * @param offset the relative offset, in bytes, from the base address of\n-     * the array to sort, otherwise if the array is {@code null},an absolute\n-     * address pointing to the first element to sort from.\n+     * @param a the array to be sorted\n+     * @param offset the relative offset, in bytes, from the base\n+     *        address of the array to partition, otherwise if the\n+     *        array is {@code null}, an absolute address pointing\n+     *        to the first element to partition from\n@@ -154,1 +158,0 @@\n-    @IntrinsicCandidate\n@@ -156,2 +159,4 @@\n-    private static <A> void sort(Class<?> elemType, A array, long offset, int low, int high, SortOperation<A> so) {\n-        so.sort(array, low, high);\n+    @IntrinsicCandidate\n+    private static <T> void sort(Class<?> elemType, T a, long offset,\n+                                 int low, int high, SortOperation<T> so) {\n+        so.sort(a, low, high);\n@@ -161,2 +166,2 @@\n-     * Represents a function that accepts the array and partitions the specified range\n-     * of the array using the pivots provided.\n+     * Represents a function that accepts the array and partitions\n+     * the specified range of the array using the given pivots.\n@@ -165,1 +170,2 @@\n-    interface PartitionOperation<A> {\n+    interface PartitionOperation<T> {\n+\n@@ -169,3 +175,3 @@\n-         * @param a the array to be partitioned\n-         * @param low the index of the first element, inclusive, to be partitioned\n-         * @param high the index of the last element, exclusive, to be partitioned\n+         * @param a the array for partitioning\n+         * @param low the index of the first element, inclusive, for partitioning\n+         * @param high the index of the last element, exclusive, for partitioning\n@@ -174,0 +180,1 @@\n+         * @return indices of parts after partitioning\n@@ -175,1 +182,1 @@\n-        int[] partition(A a, int low, int high, int pivotIndex1, int pivotIndex2);\n+        int[] partition(T a, int low, int high, int pivotIndex1, int pivotIndex2);\n@@ -179,1 +186,1 @@\n-     * Partitions the specified range of the array using the two pivots provided.\n+     * Partitions the specified range of the array using the given pivots.\n@@ -181,7 +188,8 @@\n-     * @param elemType the class of the array to be partitioned\n-     * @param array the array to be partitioned\n-     * @param offset the relative offset, in bytes, from the base address of\n-     * the array to partition, otherwise if the array is {@code null},an absolute\n-     * address pointing to the first element to partition from.\n-     * @param low the index of the first element, inclusive, to be partitioned\n-     * @param high the index of the last element, exclusive, to be partitioned\n+     * @param elemType the class of the array for partitioning\n+     * @param a the array for partitioning\n+     * @param offset the relative offset, in bytes, from the base\n+     *        address of the array to partition, otherwise if the\n+     *        array is {@code null}, an absolute address pointing\n+     *        to the first element to partition from\n+     * @param low the index of the first element, inclusive, for partitioning\n+     * @param high the index of the last element, exclusive, for partitioning\n@@ -191,0 +199,1 @@\n+     * @return indices of parts after partitioning\n@@ -192,1 +201,0 @@\n-    @IntrinsicCandidate\n@@ -194,19 +202,4 @@\n-    private static <A> int[] partition(Class<?> elemType, A array, long offset, int low, int high, int pivotIndex1, int pivotIndex2, PartitionOperation<A> po) {\n-        return po.partition(array, low, high, pivotIndex1, pivotIndex2);\n-    }\n-\n-    \/**\n-     * Calculates the double depth of parallel merging.\n-     * Depth is negative, if tasks split before sorting.\n-     *\n-     * @param parallelism the parallelism level\n-     * @param size the target size\n-     * @return the depth of parallel merging\n-     *\/\n-    private static int getDepth(int parallelism, int size) {\n-        int depth = 0;\n-\n-        while ((parallelism >>= 3) > 0 && (size >>= 2) > 0) {\n-            depth -= 2;\n-        }\n-        return depth;\n+    @IntrinsicCandidate\n+    private static <T> int[] partition(Class<?> elemType, T a, long offset,\n+                                       int low, int high, int pivotIndex1, int pivotIndex2, PartitionOperation<T> po) {\n+        return po.partition(a, low, high, pivotIndex1, pivotIndex2);\n@@ -231,6 +224,2 @@\n-        int size = high - low;\n-\n-        if (parallelism > 1 && size > MIN_PARALLEL_SORT_SIZE) {\n-            int depth = getDepth(parallelism, size >> 12);\n-            int[] b = depth == 0 ? null : new int[size];\n-            new Sorter(null, a, b, low, size, low, depth).invoke();\n+        if (parallelism > 1 && high - low > MIN_PARALLEL_SORT_SIZE) {\n+            new Sorter<>(a, parallelism, low, high - low, 0).invoke();\n@@ -243,2 +232,1 @@\n-     * Sorts the specified array using the Dual-Pivot Quicksort and\/or\n-     * other sorts in special-cases, possibly with parallel partitions.\n+     * Sorts the specified range of the array using Dual-Pivot Quicksort.\n@@ -249,1 +237,1 @@\n-     *        the right bit \"0\" indicates that array is the leftmost part\n+     *        the right bit \"0\" indicates that range is the leftmost part\n@@ -253,1 +241,1 @@\n-    static void sort(Sorter sorter, int[] a, int bits, int low, int high) {\n+    static void sort(Sorter<int[]> sorter, int[] a, int bits, int low, int high) {\n@@ -255,1 +243,2 @@\n-            int end = high - 1, size = high - low;\n+            int size = high - low;\n+\n@@ -257,1 +246,1 @@\n-             * Run mixed insertion sort on small non-leftmost parts.\n+             * Run adaptive mixed insertion sort on small non-leftmost parts.\n@@ -260,1 +249,2 @@\n-                sort(int.class, a, Unsafe.ARRAY_INT_BASE_OFFSET, low, high, DualPivotQuicksort::mixedInsertionSort);\n+                sort(int.class, a, Unsafe.ARRAY_INT_BASE_OFFSET,\n+                        low, high, DualPivotQuicksort::mixedInsertionSort);\n@@ -268,1 +258,2 @@\n-                sort(int.class, a, Unsafe.ARRAY_INT_BASE_OFFSET, low, high, DualPivotQuicksort::insertionSort);\n+                sort(int.class, a, Unsafe.ARRAY_INT_BASE_OFFSET,\n+                        low, high, DualPivotQuicksort::insertionSort);\n@@ -273,2 +264,1 @@\n-             * Check if the whole array or large non-leftmost\n-             * parts are nearly sorted and then merge runs.\n+             * Try merging sort on large part.\n@@ -276,2 +266,2 @@\n-            if ((bits == 0 || size > MIN_TRY_MERGE_SIZE && (bits & 1) > 0)\n-                    && tryMergeRuns(sorter, a, low, size)) {\n+            if (size > MIN_MERGING_SORT_SIZE * bits\n+                    && tryMergingSort(sorter, a, low, high)) {\n@@ -282,2 +272,3 @@\n-             * Switch to heap sort if execution\n-             * time is becoming quadratic.\n+             * Divide the given array into the golden ratio using\n+             * an inexpensive approximation to select five sample\n+             * elements and determine pivots.\n@@ -285,10 +276,1 @@\n-            if ((bits += DELTA) > MAX_RECURSION_DEPTH) {\n-                heapSort(a, low, high);\n-                return;\n-            }\n-\n-            \/*\n-             * Use an inexpensive approximation of the golden ratio\n-             * to select five sample elements and determine pivots.\n-             *\/\n-            int step = (size >> 3) * 3 + 3;\n+            int step = (size >> 2) + (size >> 3) + (size >> 7);\n@@ -303,1 +285,1 @@\n-            int e5 = end - step;\n+            int e5 = high - step;\n@@ -310,1 +292,10 @@\n-             * Sort these elements in place by the combination\n+             * Check if part is large and contains random\n+             * data, taking into account parallel context.\n+             *\/\n+            boolean isLargeRandom =\n+                    sorter != null && bits > 2 && size > MIN_RADIX_SORT_SIZE &&\n+\/\/              size > MIN_RADIX_SORT_SIZE && (sorter == null || bits > 0) &&\n+                            (a[e1] > a[e2] || a[e2] > a3 || a3 > a[e4] || a[e4] > a[e5]);\n+\n+            \/*\n+             * Sort these elements in-place by the combination\n@@ -313,7 +304,7 @@\n-             *    5 ------o-----------o------------\n-             *            |           |\n-             *    4 ------|-----o-----o-----o------\n-             *            |     |           |\n-             *    2 ------o-----|-----o-----o------\n-             *                  |     |\n-             *    1 ------------o-----o------------\n+             *   1 ---------o---------------o-----------------\n+             *              |               |\n+             *   2 ---------|-------o-------o-------o---------\n+             *              |       |               |\n+             *   4 ---------o-------|-------o-------o---------\n+             *                      |       |\n+             *   5 -----------------o-------o-----------------\n@@ -321,5 +312,5 @@\n-            if (a[e5] < a[e2]) { int t = a[e5]; a[e5] = a[e2]; a[e2] = t; }\n-            if (a[e4] < a[e1]) { int t = a[e4]; a[e4] = a[e1]; a[e1] = t; }\n-            if (a[e5] < a[e4]) { int t = a[e5]; a[e5] = a[e4]; a[e4] = t; }\n-            if (a[e2] < a[e1]) { int t = a[e2]; a[e2] = a[e1]; a[e1] = t; }\n-            if (a[e4] < a[e2]) { int t = a[e4]; a[e4] = a[e2]; a[e2] = t; }\n+            if (a[e1] > a[e4]) { int t = a[e1]; a[e1] = a[e4]; a[e4] = t; }\n+            if (a[e2] > a[e5]) { int t = a[e2]; a[e2] = a[e5]; a[e5] = t; }\n+            if (a[e4] > a[e5]) { int t = a[e4]; a[e4] = a[e5]; a[e5] = t; }\n+            if (a[e1] > a[e2]) { int t = a[e1]; a[e1] = a[e2]; a[e2] = t; }\n+            if (a[e2] > a[e4]) { int t = a[e2]; a[e2] = a[e4]; a[e4] = t; }\n@@ -327,0 +318,3 @@\n+            \/*\n+             * Insert the third element.\n+             *\/\n@@ -341,3 +335,8 @@\n-            \/\/ Pointers\n-            int lower; \/\/ The index of the last element of the left part\n-            int upper; \/\/ The index of the first element of the right part\n+            \/*\n+             * Try Radix sort on large fully random data.\n+             *\/\n+            if (isLargeRandom\n+                    && a[e2] < a[e3] && a[e3] < a[e4]\n+                    && tryRadixSort(sorter, a, low, high)) {\n+                return;\n+            }\n@@ -346,1 +345,1 @@\n-             * Partitioning with 2 pivots in case of different elements.\n+             * Switch to heap sort, if execution time is quadratic.\n@@ -348,9 +347,10 @@\n-            if (a[e1] < a[e2] && a[e2] < a[e3] && a[e3] < a[e4] && a[e4] < a[e5]) {\n-                \/*\n-                 * Use the first and fifth of the five sorted elements as\n-                 * the pivots. These values are inexpensive approximation\n-                 * of tertiles. Note, that pivot1 < pivot2.\n-                 *\/\n-                int[] pivotIndices = partition(int.class, a, Unsafe.ARRAY_INT_BASE_OFFSET, low, high, e1, e5, DualPivotQuicksort::partitionDualPivot);\n-                lower = pivotIndices[0];\n-                upper = pivotIndices[1];\n+            if ((bits += 2) > MAX_RECURSION_DEPTH) {\n+                heapSort(a, low, high);\n+                return;\n+            }\n+\n+            \/*\n+             * indices[0] - the index of the last element of the left part\n+             * indices[1] - the index of the first element of the right part\n+             *\/\n+            int[] indices;\n@@ -358,0 +358,4 @@\n+            \/*\n+             * Partitioning with two pivots on array of fully random elements.\n+             *\/\n+            if (a[e1] < a[e2] && a[e2] < a[e3] && a[e3] < a[e4] && a[e4] < a[e5]) {\n@@ -359,0 +363,2 @@\n+                indices = partition(int.class, a, Unsafe.ARRAY_INT_BASE_OFFSET,\n+                        low, high, e1, e5, DualPivotQuicksort::partitionWithTwoPivots);\n@@ -365,2 +371,2 @@\n-                    sorter.forkSorter(bits | 1, lower + 1, upper);\n-                    sorter.forkSorter(bits | 1, upper + 1, high);\n+                    sorter.fork(bits | 1, indices[0] + 1, indices[1]);\n+                    sorter.fork(bits | 1, indices[1] + 1, high);\n@@ -368,2 +374,2 @@\n-                    sort(sorter, a, bits | 1, lower + 1, upper);\n-                    sort(sorter, a, bits | 1, upper + 1, high);\n+                    sort(sorter, a, bits | 1, indices[0] + 1, indices[1]);\n+                    sort(sorter, a, bits | 1, indices[1] + 1, high);\n@@ -372,1 +378,4 @@\n-            } else { \/\/ Use single pivot in case of many equal elements\n+            } else { \/\/ Partitioning with one pivot\n+\n+                indices = partition(int.class, a, Unsafe.ARRAY_INT_BASE_OFFSET,\n+                        low, high, e3, e3, DualPivotQuicksort::partitionWithOnePivot);\n@@ -374,7 +383,0 @@\n-                \/*\n-                 * Use the third of the five sorted elements as the pivot.\n-                 * This value is inexpensive approximation of the median.\n-                 *\/\n-                int[] pivotIndices = partition(int.class, a, Unsafe.ARRAY_INT_BASE_OFFSET, low, high, e3, e3, DualPivotQuicksort::partitionSinglePivot);\n-                lower = pivotIndices[0];\n-                upper = pivotIndices[1];\n@@ -387,1 +389,1 @@\n-                    sorter.forkSorter(bits | 1, upper, high);\n+                    sorter.fork(bits | 1, indices[1], high);\n@@ -389,1 +391,1 @@\n-                    sort(sorter, a, bits | 1, upper, high);\n+                    sort(sorter, a, bits | 1, indices[1], high);\n@@ -392,1 +394,1 @@\n-            high = lower; \/\/ Iterate along the left part\n+            high = indices[0]; \/\/ Iterate along the left part\n@@ -397,1 +399,1 @@\n-     * Partitions the specified range of the array using the two pivots provided.\n+     * Partitions the specified range of the array using two given pivots.\n@@ -399,1 +401,1 @@\n-     * @param array the array to be partitioned\n+     * @param a the array for partitioning\n@@ -404,1 +406,1 @@\n-     *\n+     * @return indices of parts after partitioning\n@@ -406,3 +408,3 @@\n-    @ForceInline\n-    private static int[] partitionDualPivot(int[] a, int low, int high, int pivotIndex1, int pivotIndex2) {\n-        int end = high - 1;\n+    private static int[] partitionWithTwoPivots(\n+            int[] a, int low, int high, int pivotIndex1, int pivotIndex2) {\n+        int upper = --high;\n@@ -410,1 +412,0 @@\n-        int upper = end;\n@@ -412,4 +413,7 @@\n-        int e1 = pivotIndex1;\n-        int e5 = pivotIndex2;\n-        int pivot1 = a[e1];\n-        int pivot2 = a[e5];\n+        \/*\n+         * Use the first and fifth of the five sorted elements as\n+         * the pivots. These values are inexpensive approximation\n+         * of tertiles. Note, that pivot1 < pivot2.\n+         *\/\n+        int pivot1 = a[pivotIndex1];\n+        int pivot2 = a[pivotIndex2];\n@@ -424,2 +428,2 @@\n-        a[e1] = a[lower];\n-        a[e5] = a[upper];\n+        a[pivotIndex1] = a[lower];\n+        a[pivotIndex2] = a[upper];\n@@ -436,13 +440,7 @@\n-         *   left part                 central part          right part\n-         * +------------------------------------------------------------+\n-                  * |  < pivot1  |   ?   |  pivot1 <= && <= pivot2  |  > pivot2  |\n-         * +------------------------------------------------------------+\n-         *             ^       ^                            ^\n-         *             |       |                            |\n-         *           lower     k                          upper\n-         *\n-         * Invariants:\n-         *\n-         *              all in (low, lower] < pivot1\n-         *    pivot1 <= all in (k, upper)  <= pivot2\n-         *              all in [upper, end) > pivot2\n+         *     left part                     central part          right part\n+         * +-------------------------------------------------------------------+\n+         * |   < pivot1   |    ?     |  pivot1 <= .. <= pivot2  |   > pivot2   |\n+         * +-------------------------------------------------------------------+\n+         *               ^          ^                            ^\n+         *               |          |                            |\n+         *             lower        k                          upper\n@@ -451,0 +449,2 @@\n+         * Pointer lower is the last index of left part\n+         * Pointer upper is the first index of right part\n@@ -455,10 +455,3 @@\n-            if (ak < pivot1) { \/\/ Move a[k] to the left side\n-                while (lower < k) {\n-                    if (a[++lower] >= pivot1) {\n-                        if (a[lower] > pivot2) {\n-                            a[k] = a[--upper];\n-                            a[upper] = a[lower];\n-                        } else {\n-                            a[k] = a[lower];\n-                        }\n-                        a[lower] = ak;\n+            if (ak < pivot1) { \/\/ Move a[k] to the left part\n+                while (a[++lower] < pivot1) {\n+                    if (lower == k) {\n@@ -468,1 +461,8 @@\n-            } else if (ak > pivot2) { \/\/ Move a[k] to the right side\n+                if (a[lower] > pivot2) {\n+                    a[k] = a[--upper];\n+                    a[upper] = a[lower];\n+                } else {\n+                    a[k] = a[lower];\n+                }\n+                a[lower] = ak;\n+            } else if (ak > pivot2) { \/\/ Move a[k] to the right part\n@@ -477,2 +477,2 @@\n-        a[low] = a[lower]; a[lower] = pivot1;\n-        a[end] = a[upper]; a[upper] = pivot2;\n+        a[low]  = a[lower]; a[lower] = pivot1;\n+        a[high] = a[upper]; a[upper] = pivot2;\n@@ -480,1 +480,1 @@\n-        return new int[] {lower, upper};\n+        return new int[] { lower, upper };\n@@ -484,1 +484,1 @@\n-     * Partitions the specified range of the array using a single pivot provided.\n+     * Partitions the specified range of the array using one given pivot.\n@@ -486,1 +486,1 @@\n-     * @param array the array to be partitioned\n+     * @param a the array for partitioning\n@@ -489,3 +489,3 @@\n-     * @param pivotIndex1 the index of pivot1, the first pivot\n-     * @param pivotIndex2 the index of pivot2, the second pivot\n-     *\n+     * @param pivotIndex1 the index of single pivot\n+     * @param pivotIndex2 the index of single pivot\n+     * @return indices of parts after partitioning\n@@ -493,4 +493,3 @@\n-    @ForceInline\n-    private static int[] partitionSinglePivot(int[] a, int low, int high, int pivotIndex1, int pivotIndex2) {\n-\n-        int end = high - 1;\n+    private static int[] partitionWithOnePivot(\n+            int[] a, int low, int high, int pivotIndex1, int pivotIndex2) {\n+        int upper = high;\n@@ -498,3 +497,6 @@\n-        int upper = end;\n-        int e3 = pivotIndex1;\n-        int pivot = a[e3];\n+\n+        \/*\n+         * Use the third of the five sorted elements as the pivot.\n+         * This value is inexpensive approximation of the median.\n+         *\/\n+        int pivot = a[pivotIndex1];\n@@ -509,1 +511,1 @@\n-        a[e3] = a[lower];\n+        a[pivotIndex1] = a[lower];\n@@ -512,1 +514,1 @@\n-         * Traditional 3-way (Dutch National Flag) partitioning\n+         * Dutch National Flag partitioning\n@@ -514,1 +516,1 @@\n-         *   left part                 central part    right part\n+         *     left part               central part    right part\n@@ -516,1 +518,1 @@\n-         * |   < pivot   |     ?     |   == pivot   |   > pivot   |\n+         * |   < pivot    |    ?     |   == pivot   |   > pivot   |\n@@ -518,9 +520,3 @@\n-         *              ^           ^                ^\n-         *              |           |                |\n-         *            lower         k              upper\n-         *\n-         * Invariants:\n-         *\n-         *   all in (low, lower] < pivot\n-         *   all in (k, upper)  == pivot\n-         *   all in [upper, end] > pivot\n+         *               ^          ^                ^\n+         *               |          |                |\n+         *             lower        k              upper\n@@ -529,0 +525,2 @@\n+         * Pointer lower is the last index of left part\n+         * Pointer upper is the first index of right part\n@@ -530,1 +528,1 @@\n-        for (int k = ++upper; --k > lower; ) {\n+        for (int k = upper; --k > lower; ) {\n@@ -536,1 +534,1 @@\n-                if (ak < pivot) { \/\/ Move a[k] to the left side\n+                if (ak < pivot) { \/\/ Move a[k] to the left part\n@@ -543,1 +541,1 @@\n-                } else { \/\/ ak > pivot - Move a[k] to the right side\n+                } else { \/\/ ak > pivot - Move a[k] to the right part\n@@ -553,1 +551,2 @@\n-        return new int[] {lower, upper};\n+\n+        return new int[] { lower, upper };\n@@ -559,2 +558,2 @@\n-     * Mixed insertion sort is combination of simple insertion sort,\n-     * pin insertion sort and pair insertion sort.\n+     * Mixed insertion sort is combination of pin insertion sort,\n+     * simple insertion sort and pair insertion sort.\n@@ -572,4 +571,1 @@\n-    private static void mixedInsertionSort(int[] a, int low, int high) {\n-        int size = high - low;\n-        int end = high - 3 * ((size >> 5) << 3);\n-        if (end == high) {\n+    static void mixedInsertionSort(int[] a, int low, int high) {\n@@ -577,4 +573,10 @@\n-            \/*\n-             * Invoke simple insertion sort on tiny array.\n-             *\/\n-            for (int i; ++low < end; ) {\n+        \/*\n+         * Split part for pin and pair insertion sorts.\n+         *\/\n+        int end = high - 3 * ((high - low) >> 3 << 1);\n+\n+        \/*\n+         * Invoke simple insertion sort on small part.\n+         *\/\n+        if (end == high) {\n+            for (int i; ++low < high; ) {\n@@ -583,2 +585,2 @@\n-                while (ai < a[--i]) {\n-                    a[i + 1] = a[i];\n+                while (ai < a[i - 1]) {\n+                    a[i] = a[--i];\n@@ -586,1 +588,1 @@\n-                a[i + 1] = ai;\n+                a[i] = ai;\n@@ -588,1 +590,8 @@\n-        } else {\n+            return;\n+        }\n+\n+        \/*\n+         * Start with pin insertion sort.\n+         *\/\n+        for (int i, p = high; ++low < end; ) {\n+            int ai = a[i = low], pin = a[--p];\n@@ -591,7 +600,1 @@\n-             * Start with pin insertion sort on small part.\n-             *\n-             * Pin insertion sort is extended simple insertion sort.\n-             * The main idea of this sort is to put elements larger\n-             * than an element called pin to the end of array (the\n-             * proper area for such elements). It avoids expensive\n-             * movements of these elements through the whole array.\n+             * Swap larger element with pin.\n@@ -599,40 +602,3 @@\n-            int pin = a[end];\n-\n-            for (int i, p = high; ++low < end; ) {\n-                int ai = a[i = low];\n-\n-                if (ai < a[i - 1]) { \/\/ Small element\n-\n-                    \/*\n-                     * Insert small element into sorted part.\n-                     *\/\n-                    a[i] = a[--i];\n-\n-                    while (ai < a[--i]) {\n-                        a[i + 1] = a[i];\n-                    }\n-                    a[i + 1] = ai;\n-\n-                } else if (p > i && ai > pin) { \/\/ Large element\n-\n-                    \/*\n-                     * Find element smaller than pin.\n-                     *\/\n-                    while (a[--p] > pin);\n-\n-                    \/*\n-                     * Swap it with large element.\n-                     *\/\n-                    if (p > i) {\n-                        ai = a[p];\n-                        a[p] = a[i];\n-                    }\n-\n-                    \/*\n-                     * Insert small element into sorted part.\n-                     *\/\n-                    while (ai < a[--i]) {\n-                        a[i + 1] = a[i];\n-                    }\n-                    a[i + 1] = ai;\n-                }\n+            if (ai > pin) {\n+                ai = pin;\n+                a[p] = a[i];\n@@ -642,1 +608,1 @@\n-             * Continue with pair insertion sort on remain part.\n+             * Insert element into sorted part.\n@@ -644,2 +610,5 @@\n-            for (int i; low < high; ++low) {\n-                int a1 = a[i = low], a2 = a[++low];\n+            while (ai < a[i - 1]) {\n+                a[i] = a[--i];\n+            }\n+            a[i] = ai;\n+        }\n@@ -647,6 +616,5 @@\n-                \/*\n-                 * Insert two elements per iteration: at first, insert the\n-                 * larger element and then insert the smaller element, but\n-                 * from the position where the larger element was inserted.\n-                 *\/\n-                if (a1 > a2) {\n+        \/*\n+         * Finish with pair insertion sort.\n+         *\/\n+        for (int i; low < high; ++low) {\n+            int a1 = a[i = low], a2 = a[++low];\n@@ -654,4 +622,6 @@\n-                    while (a1 < a[--i]) {\n-                        a[i + 2] = a[i];\n-                    }\n-                    a[++i + 1] = a1;\n+            \/*\n+             * Insert two elements per iteration: at first, insert the\n+             * larger element and then insert the smaller element, but\n+             * from the position where the larger element was inserted.\n+             *\/\n+            if (a1 > a2) {\n@@ -659,4 +629,4 @@\n-                    while (a2 < a[--i]) {\n-                        a[i + 1] = a[i];\n-                    }\n-                    a[i + 1] = a2;\n+                while (a1 < a[--i]) {\n+                    a[i + 2] = a[i];\n+                }\n+                a[++i + 1] = a1;\n@@ -664,1 +634,4 @@\n-                } else if (a1 < a[i - 1]) {\n+                while (a2 < a[--i]) {\n+                    a[i + 1] = a[i];\n+                }\n+                a[i + 1] = a2;\n@@ -666,4 +639,1 @@\n-                    while (a2 < a[--i]) {\n-                        a[i + 2] = a[i];\n-                    }\n-                    a[++i + 1] = a2;\n+            } else if (a1 < a[i - 1]) {\n@@ -671,4 +641,7 @@\n-                    while (a1 < a[--i]) {\n-                        a[i + 1] = a[i];\n-                    }\n-                    a[i + 1] = a1;\n+                while (a2 < a[--i]) {\n+                    a[i + 2] = a[i];\n+                }\n+                a[++i + 1] = a2;\n+\n+                while (a1 < a[--i]) {\n+                    a[i + 1] = a[i];\n@@ -676,0 +649,1 @@\n+                a[i + 1] = a1;\n@@ -687,1 +661,1 @@\n-    private static void insertionSort(int[] a, int low, int high) {\n+    static void insertionSort(int[] a, int low, int high) {\n@@ -692,38 +666,3 @@\n-                while (--i >= low && ai < a[i]) {\n-                    a[i + 1] = a[i];\n-                }\n-                a[i + 1] = ai;\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Sorts the specified range of the array using heap sort.\n-     *\n-     * @param a the array to be sorted\n-     * @param low the index of the first element, inclusive, to be sorted\n-     * @param high the index of the last element, exclusive, to be sorted\n-     *\/\n-    private static void heapSort(int[] a, int low, int high) {\n-        for (int k = (low + high) >>> 1; k > low; ) {\n-            pushDown(a, --k, a[k], low, high);\n-        }\n-        while (--high > low) {\n-            int max = a[low];\n-            pushDown(a, low, a[high], low, high);\n-            a[high] = max;\n-        }\n-    }\n-\n-    \/**\n-     * Pushes specified element down during heap sort.\n-     *\n-     * @param a the given array\n-     * @param p the start index\n-     * @param value the given element\n-     * @param low the index of the first element, inclusive, to be sorted\n-     * @param high the index of the last element, exclusive, to be sorted\n-     *\/\n-    private static void pushDown(int[] a, int p, int value, int low, int high) {\n-        for (int k ;; a[p] = a[p = k]) {\n-            k = (p << 1) - low + 2; \/\/ Index of the right child\n+                do {\n+                    a[i] = a[--i];\n+                } while (i > low && ai < a[i - 1]);\n@@ -731,8 +670,1 @@\n-            if (k > high) {\n-                break;\n-            }\n-            if (k == high || a[k] < a[k - 1]) {\n-                --k;\n-            }\n-            if (a[k] <= value) {\n-                break;\n+                a[i ] = ai;\n@@ -741,1 +673,0 @@\n-        a[p] = value;\n@@ -745,1 +676,1 @@\n-     * Tries to sort the specified range of the array.\n+     * Tries to sort the specified range of the array using merging sort.\n@@ -749,3 +680,3 @@\n-     * @param low the index of the first element to be sorted\n-     * @param size the array size\n-     * @return true if finally sorted, false otherwise\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n+     * @return {@code true} if the array is finally sorted, otherwise {@code false}\n@@ -753,1 +684,1 @@\n-    private static boolean tryMergeRuns(Sorter sorter, int[] a, int low, int size) {\n+    static boolean tryMergingSort(Sorter<int[]> sorter, int[] a, int low, int high) {\n@@ -756,3 +687,2 @@\n-         * The run array is constructed only if initial runs are\n-         * long enough to continue, run[i] then holds start index\n-         * of the i-th sequence of elements in non-descending order.\n+         * The element run[i] holds the start index\n+         * of i-th sequence in non-descending order.\n@@ -760,0 +690,1 @@\n+        int count = 1;\n@@ -761,2 +692,0 @@\n-        int high = low + size;\n-        int count = 1, last = low;\n@@ -767,1 +696,1 @@\n-        for (int k = low + 1; k < high; ) {\n+        for (int k = low + 1, last = low; k < high; ) {\n@@ -770,1 +699,1 @@\n-             * Find the end index of the current run.\n+             * Find the next run.\n@@ -795,1 +724,8 @@\n-             * Check special cases.\n+             * Check if the runs are too long to continue scanning.\n+             *\/\n+            if (count > 6 && k - low < count * MIN_RUN_SIZE) {\n+                return false;\n+            }\n+\n+            \/*\n+             * Process the run.\n@@ -798,1 +734,0 @@\n-                if (k == high) {\n@@ -800,0 +735,1 @@\n+                if (k == high) {\n@@ -801,1 +737,1 @@\n-                     * The array is monotonous sequence,\n+                     * Array is monotonous sequence\n@@ -807,10 +743,1 @@\n-                if (k - low < MIN_FIRST_RUN_SIZE) {\n-\n-                    \/*\n-                     * The first run is too small\n-                     * to proceed with scanning.\n-                     *\/\n-                    return false;\n-                }\n-\n-                run = new int[((size >> 10) | 0x7F) & 0x3FF];\n+                run = new int[((high - low) >> 9) & 0x1FF | 0x3F];\n@@ -819,12 +746,1 @@\n-            } else if (a[last - 1] > a[last]) {\n-\n-                if (count > (k - low) >> MIN_FIRST_RUNS_FACTOR) {\n-\n-                    \/*\n-                     * The first runs are not long\n-                     * enough to continue scanning.\n-                     *\/\n-                    return false;\n-                }\n-\n-                if (++count == MAX_RUN_CAPACITY) {\n+            } else if (a[last - 1] > a[last]) { \/\/ Start the new run\n@@ -832,0 +748,1 @@\n+                if (++count == run.length) {\n@@ -837,0 +754,1 @@\n+            }\n@@ -838,1 +756,4 @@\n-                if (count == run.length) {\n+            \/*\n+             * Save the current run.\n+             *\/\n+            run[count] = (last = k);\n@@ -840,5 +761,5 @@\n-                    \/*\n-                     * Increase capacity of index array.\n-                     *\/\n-                    run = Arrays.copyOf(run, count << 1);\n-                }\n+            \/*\n+             * Check single-element run at the end.\n+             *\/\n+            if (++k == high) {\n+                --k;\n@@ -846,1 +767,0 @@\n-            run[count] = (last = k);\n@@ -850,1 +770,1 @@\n-         * Merge runs of highly structured array.\n+         * Merge all runs.\n@@ -855,3 +775,1 @@\n-            if (sorter == null || (b = (int[]) sorter.b) == null) {\n-                b = new int[size];\n-            } else {\n+            if (sorter != null && (b = sorter.b) != null) {\n@@ -859,0 +777,2 @@\n+            } else if ((b = tryAllocate(int[].class, high - low)) == null) {\n+                return false;\n@@ -879,1 +799,1 @@\n-            int aim, boolean parallel, int[] run, int lo, int hi) {\n+                                   int aim, boolean parallel, int[] run, int lo, int hi) {\n@@ -885,3 +805,1 @@\n-            for (int i = run[hi], j = i - offset, low = run[lo]; i > low;\n-                b[--j] = a[--i]\n-            );\n+            System.arraycopy(a, run[lo], b, run[lo] - offset, run[hi] - run[lo]);\n@@ -898,1 +816,1 @@\n-         * Merge the left and right parts.\n+         * Merge runs of each part.\n@@ -900,11 +818,2 @@\n-        int[] a1, a2;\n-\n-        if (parallel && hi - lo > MIN_RUN_COUNT) {\n-            RunMerger merger = new RunMerger(a, b, offset, 0, run, mi, hi).forkMe();\n-            a1 = mergeRuns(a, b, offset, -aim, true, run, lo, mi);\n-            a2 = (int[]) merger.getDestination();\n-        } else {\n-            a1 = mergeRuns(a, b, offset, -aim, false, run, lo, mi);\n-            a2 = mergeRuns(a, b, offset,    0, false, run, mi, hi);\n-        }\n-\n+        int[] a1 = mergeRuns(a, b, offset, -aim, parallel, run, lo, mi);\n+        int[] a2 = mergeRuns(a, b, offset,    0, parallel, run, mi, hi);\n@@ -919,2 +828,5 @@\n-        if (parallel) {\n-            new Merger(null, dst, k, a1, lo1, hi1, a2, lo2, hi2).invoke();\n+        \/*\n+         * Merge the left and right parts.\n+         *\/\n+        if (hi1 - lo1 > MIN_PARALLEL_SORT_SIZE && parallel) {\n+            new Merger<>(null, dst, k, a1, lo1, hi1, a2, lo2, hi2).invoke();\n@@ -940,2 +852,2 @@\n-    private static void mergeParts(Merger merger, int[] dst, int k,\n-            int[] a1, int lo1, int hi1, int[] a2, int lo2, int hi2) {\n+    private static void mergeParts(Merger<int[]> merger, int[] dst, int k,\n+                                   int[] a1, int lo1, int hi1, int[] a2, int lo2, int hi2) {\n@@ -943,0 +855,3 @@\n+        \/*\n+         * Merge sorted parts in parallel.\n+         *\/\n@@ -955,0 +870,8 @@\n+                \/*\n+                 * Terminate, if the second part is empty.\n+                 *\/\n+                if (lo2 == hi2) {\n+                    System.arraycopy(a1, lo1, dst, k, hi1 - lo1);\n+                    return;\n+                }\n+\n@@ -958,1 +881,1 @@\n-                if (hi1 - lo1 < MIN_PARALLEL_MERGE_PARTS_SIZE) {\n+                if (hi1 - lo1 < MIN_PARALLEL_SORT_SIZE) {\n@@ -970,1 +893,1 @@\n-                 * Partition the smaller part.\n+                 * Divide the smaller part.\n@@ -972,2 +895,2 @@\n-                for (int loo = lo2; loo < mi2; ) {\n-                    int t = (loo + mi2) >>> 1;\n+                for (int mi0 = lo2; mi0 < mi2; ) {\n+                    int m = (mi0 + mi2) >>> 1;\n@@ -975,2 +898,2 @@\n-                    if (key > a2[t]) {\n-                        loo = t + 1;\n+                    if (key > a2[m]) {\n+                        mi0 = m + 1;\n@@ -978,1 +901,1 @@\n-                        mi2 = t;\n+                        mi2 = m;\n@@ -982,1 +905,4 @@\n-                int d = mi2 - lo2 + mi1 - lo1;\n+                \/*\n+                 * Reserve space for the left parts.\n+                 *\/\n+                int space = mi2 - lo2 + mi1 - lo1;\n@@ -985,1 +911,1 @@\n-                 * Merge the right sub-parts in parallel.\n+                 * Merge other parts in parallel.\n@@ -987,1 +913,1 @@\n-                merger.forkMerger(dst, k + d, a1, mi1, hi1, a2, mi2, hi2);\n+                merger.fork(k + space, mi1, hi1, mi2, hi2);\n@@ -990,1 +916,1 @@\n-                 * Process the sub-left parts.\n+                 * Iterate along the left parts.\n@@ -1000,2 +926,4 @@\n-        while (lo1 < hi1 && lo2 < hi2) {\n-            dst[k++] = a1[lo1] < a2[lo2] ? a1[lo1++] : a2[lo2++];\n+        if (lo2 < hi2 && a1[hi1 - 1] > a2[lo2]) {\n+            while (lo1 < hi1 && lo2 < hi2) {\n+                dst[k++] = a1[lo1] < a2[lo2] ? a1[lo1++] : a2[lo2++];\n+            }\n@@ -1015,2 +943,0 @@\n-\/\/ [long]\n-\n@@ -1018,2 +944,2 @@\n-     * Sorts the specified range of the array using parallel merge\n-     * sort and\/or Dual-Pivot Quicksort.\n+     * Tries to sort the specified range of the array\n+     * using LSD (The Least Significant Digit) Radix sort.\n@@ -1021,3 +947,174 @@\n-     * To balance the faster splitting and parallelism of merge sort\n-     * with the faster element partitioning of Quicksort, ranges are\n-     * subdivided in tiers such that, if there is enough parallelism,\n+     * @param a the array to be sorted\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n+     * @return {@code true} if the array is finally sorted, otherwise {@code false}\n+     *\/\n+    static boolean tryRadixSort(Sorter<int[]> sorter, int[] a, int low, int high) {\n+        int[] b; int offset = low, size = high - low;\n+\n+        \/*\n+         * Allocate additional buffer.\n+         *\/\n+        if (sorter != null && (b = sorter.b) != null) {\n+            offset = sorter.offset;\n+        } else if ((b = tryAllocate(int[].class, size)) == null) {\n+            return false;\n+        }\n+\n+        int start = low - offset;\n+        int last = high - offset;\n+\n+        \/*\n+         * Count the number of all digits.\n+         *\/\n+        int[] count1 = new int[1024];\n+        int[] count2 = new int[2048];\n+        int[] count3 = new int[2048];\n+\n+        for (int i = low; i < high; ++i) {\n+            ++count1[ a[i]         & 0x3FF];\n+            ++count2[(a[i] >>> 10) & 0x7FF];\n+            ++count3[(a[i] >>> 21) ^ 0x400]; \/\/ Reverse the sign bit\n+        }\n+\n+        \/*\n+         * Detect digits to be processed.\n+         *\/\n+        boolean processDigit1 = processDigit(count1, size, low);\n+        boolean processDigit2 = processDigit(count2, size, low);\n+        boolean processDigit3 = processDigit(count3, size, low);\n+\n+        \/*\n+         * Process the 1-st digit.\n+         *\/\n+        if (processDigit1) {\n+            for (int i = high; i > low; ) {\n+                b[--count1[a[--i] & 0x3FF] - offset] = a[i];\n+            }\n+        }\n+\n+        \/*\n+         * Process the 2-nd digit.\n+         *\/\n+        if (processDigit2) {\n+            if (processDigit1) {\n+                for (int i = last; i > start; ) {\n+                    a[--count2[(b[--i] >>> 10) & 0x7FF]] = b[i];\n+                }\n+            } else {\n+                for (int i = high; i > low; ) {\n+                    b[--count2[(a[--i] >>> 10) & 0x7FF] - offset] = a[i];\n+                }\n+            }\n+        }\n+\n+        \/*\n+         * Process the 3-rd digit.\n+         *\/\n+        if (processDigit3) {\n+            if (processDigit1 ^ processDigit2) {\n+                for (int i = last; i > start; ) {\n+                    a[--count3[(b[--i] >>> 21) ^ 0x400]] = b[i];\n+                }\n+            } else {\n+                for (int i = high; i > low; ) {\n+                    b[--count3[(a[--i] >>> 21) ^ 0x400] - offset] = a[i];\n+                }\n+            }\n+        }\n+\n+        \/*\n+         * Copy the buffer to original array, if we process ood number of digits.\n+         *\/\n+        if (processDigit1 ^ processDigit2 ^ processDigit3) {\n+            System.arraycopy(b, low - offset, a, low, size);\n+        }\n+        return true;\n+    }\n+\n+    \/**\n+     * Checks the count array and then computes the histogram.\n+     *\n+     * @param count the count array\n+     * @param total the total number of elements\n+     * @param low the index of the first element, inclusive\n+     * @return {@code true} if the digit must be processed, otherwise {@code false}\n+     *\/\n+    private static boolean processDigit(int[] count, int total, int low) {\n+\n+        \/*\n+         * Check if we can skip the given digit.\n+         *\/\n+        for (int c : count) {\n+            if (c == total) {\n+                return false;\n+            }\n+            if (c > 0) {\n+                break;\n+            }\n+        }\n+\n+        \/*\n+         * Compute the histogram.\n+         *\/\n+        count[0] += low;\n+\n+        for (int i = 0; ++i < count.length; ) {\n+            count[i] += count[i - 1];\n+        }\n+        return true;\n+    }\n+\n+    \/**\n+     * Sorts the specified range of the array using heap sort.\n+     *\n+     * @param a the array to be sorted\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n+     *\/\n+    static void heapSort(int[] a, int low, int high) {\n+        for (int k = (low + high) >>> 1; k > low; ) {\n+            pushDown(a, --k, a[k], low, high);\n+        }\n+        while (--high > low) {\n+            int max = a[low];\n+            pushDown(a, low, a[high], low, high);\n+            a[high] = max;\n+        }\n+    }\n+\n+    \/**\n+     * Pushes specified element down during heap sort.\n+     *\n+     * @param a the given array\n+     * @param p the start index\n+     * @param value the given element\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n+     *\/\n+    private static void pushDown(int[] a, int p, int value, int low, int high) {\n+        for (int k ;; a[p] = a[p = k]) {\n+            k = (p << 1) - low + 2; \/\/ Index of the right child\n+\n+            if (k > high) {\n+                break;\n+            }\n+            if (k == high || a[k] < a[k - 1]) {\n+                --k;\n+            }\n+            if (a[k] <= value) {\n+                break;\n+            }\n+        }\n+        a[p] = value;\n+    }\n+\n+\/\/ #[long]\n+\n+    \/**\n+     * Sorts the specified range of the array using parallel merge\n+     * sort and\/or Dual-Pivot Quicksort.\n+     *\n+     * To balance the faster splitting and parallelism of merge sort\n+     * with the faster element partitioning of Quicksort, ranges are\n+     * subdivided in tiers such that, if there is enough parallelism,\n@@ -1033,6 +1130,2 @@\n-        int size = high - low;\n-\n-        if (parallelism > 1 && size > MIN_PARALLEL_SORT_SIZE) {\n-            int depth = getDepth(parallelism, size >> 12);\n-            long[] b = depth == 0 ? null : new long[size];\n-            new Sorter(null, a, b, low, size, low, depth).invoke();\n+        if (parallelism > 1 && high - low > MIN_PARALLEL_SORT_SIZE) {\n+            new Sorter<>(a, parallelism, low, high - low, 0).invoke();\n@@ -1045,2 +1138,1 @@\n-     * Sorts the specified array using the Dual-Pivot Quicksort and\/or\n-     * other sorts in special-cases, possibly with parallel partitions.\n+     * Sorts the specified range of the array using Dual-Pivot Quicksort.\n@@ -1051,1 +1143,1 @@\n-     *        the right bit \"0\" indicates that array is the leftmost part\n+     *        the right bit \"0\" indicates that range is the leftmost part\n@@ -1055,1 +1147,1 @@\n-    static void sort(Sorter sorter, long[] a, int bits, int low, int high) {\n+    static void sort(Sorter<long[]> sorter, long[] a, int bits, int low, int high) {\n@@ -1057,1 +1149,1 @@\n-            int end = high - 1, size = high - low;\n+            int size = high - low;\n@@ -1060,1 +1152,1 @@\n-             * Run mixed insertion sort on small non-leftmost parts.\n+             * Run adaptive mixed insertion sort on small non-leftmost parts.\n@@ -1063,1 +1155,2 @@\n-                sort(long.class, a, Unsafe.ARRAY_LONG_BASE_OFFSET, low, high, DualPivotQuicksort::mixedInsertionSort);\n+                sort(long.class, a, Unsafe.ARRAY_LONG_BASE_OFFSET,\n+                        low, high, DualPivotQuicksort::mixedInsertionSort);\n@@ -1071,1 +1164,2 @@\n-                sort(long.class, a, Unsafe.ARRAY_LONG_BASE_OFFSET, low, high, DualPivotQuicksort::insertionSort);\n+                sort(long.class, a, Unsafe.ARRAY_LONG_BASE_OFFSET,\n+                        low, high, DualPivotQuicksort::insertionSort);\n@@ -1076,2 +1170,1 @@\n-             * Check if the whole array or large non-leftmost\n-             * parts are nearly sorted and then merge runs.\n+             * Try merging sort on large part.\n@@ -1079,2 +1172,2 @@\n-            if ((bits == 0 || size > MIN_TRY_MERGE_SIZE && (bits & 1) > 0)\n-                    && tryMergeRuns(sorter, a, low, size)) {\n+            if (size > MIN_MERGING_SORT_SIZE * bits\n+                    && tryMergingSort(sorter, a, low, high)) {\n@@ -1085,2 +1178,3 @@\n-             * Switch to heap sort if execution\n-             * time is becoming quadratic.\n+             * Divide the given array into the golden ratio using\n+             * an inexpensive approximation to select five sample\n+             * elements and determine pivots.\n@@ -1088,10 +1182,1 @@\n-            if ((bits += DELTA) > MAX_RECURSION_DEPTH) {\n-                heapSort(a, low, high);\n-                return;\n-            }\n-\n-            \/*\n-             * Use an inexpensive approximation of the golden ratio\n-             * to select five sample elements and determine pivots.\n-             *\/\n-            int step = (size >> 3) * 3 + 3;\n+            int step = (size >> 2) + (size >> 3) + (size >> 7);\n@@ -1106,1 +1191,1 @@\n-            int e5 = end - step;\n+            int e5 = high - step;\n@@ -1113,1 +1198,10 @@\n-             * Sort these elements in place by the combination\n+             * Check if part is large and contains random\n+             * data, taking into account parallel context.\n+             *\/\n+            boolean isLargeRandom =\n+                    sorter != null && bits > 2 && size > MIN_RADIX_SORT_SIZE &&\n+\/\/              size > MIN_RADIX_SORT_SIZE && (sorter == null || bits > 0) &&\n+                            (a[e1] > a[e2] || a[e2] > a3 || a3 > a[e4] || a[e4] > a[e5]);\n+\n+            \/*\n+             * Sort these elements in-place by the combination\n@@ -1116,7 +1210,7 @@\n-             *    5 ------o-----------o------------\n-             *            |           |\n-             *    4 ------|-----o-----o-----o------\n-             *            |     |           |\n-             *    2 ------o-----|-----o-----o------\n-             *                  |     |\n-             *    1 ------------o-----o------------\n+             *   1 ---------o---------------o-----------------\n+             *              |               |\n+             *   2 ---------|-------o-------o-------o---------\n+             *              |       |               |\n+             *   4 ---------o-------|-------o-------o---------\n+             *                      |       |\n+             *   5 -----------------o-------o-----------------\n@@ -1124,5 +1218,5 @@\n-            if (a[e5] < a[e2]) { long t = a[e5]; a[e5] = a[e2]; a[e2] = t; }\n-            if (a[e4] < a[e1]) { long t = a[e4]; a[e4] = a[e1]; a[e1] = t; }\n-            if (a[e5] < a[e4]) { long t = a[e5]; a[e5] = a[e4]; a[e4] = t; }\n-            if (a[e2] < a[e1]) { long t = a[e2]; a[e2] = a[e1]; a[e1] = t; }\n-            if (a[e4] < a[e2]) { long t = a[e4]; a[e4] = a[e2]; a[e2] = t; }\n+            if (a[e1] > a[e4]) { long t = a[e1]; a[e1] = a[e4]; a[e4] = t; }\n+            if (a[e2] > a[e5]) { long t = a[e2]; a[e2] = a[e5]; a[e5] = t; }\n+            if (a[e4] > a[e5]) { long t = a[e4]; a[e4] = a[e5]; a[e5] = t; }\n+            if (a[e1] > a[e2]) { long t = a[e1]; a[e1] = a[e2]; a[e2] = t; }\n+            if (a[e2] > a[e4]) { long t = a[e2]; a[e2] = a[e4]; a[e4] = t; }\n@@ -1130,0 +1224,3 @@\n+            \/*\n+             * Insert the third element.\n+             *\/\n@@ -1144,3 +1241,22 @@\n-            \/\/ Pointers\n-            int lower; \/\/ The index of the last element of the left part\n-            int upper; \/\/ The index of the first element of the right part\n+            \/*\n+             * Try Radix sort on large fully random data.\n+             *\/\n+            if (isLargeRandom\n+                    && a[e2] < a[e3] && a[e3] < a[e4]\n+                    && tryRadixSort(sorter, a, low, high)) {\n+                return;\n+            }\n+\n+            \/*\n+             * Switch to heap sort, if execution time is quadratic.\n+             *\/\n+            if ((bits += 2) > MAX_RECURSION_DEPTH) {\n+                heapSort(a, low, high);\n+                return;\n+            }\n+\n+            \/*\n+             * indices[0] - the index of the last element of the left part\n+             * indices[1] - the index of the first element of the right part\n+             *\/\n+            int[] indices;\n@@ -1149,1 +1265,1 @@\n-             * Partitioning with 2 pivots in case of different elements.\n+             * Partitioning with two pivots on array of fully random elements.\n@@ -1153,8 +1269,3 @@\n-                \/*\n-                 * Use the first and fifth of the five sorted elements as\n-                 * the pivots. These values are inexpensive approximation\n-                 * of tertiles. Note, that pivot1 < pivot2.\n-                 *\/\n-                int[] pivotIndices = partition(long.class, a, Unsafe.ARRAY_LONG_BASE_OFFSET, low, high, e1, e5, DualPivotQuicksort::partitionDualPivot);\n-                lower = pivotIndices[0];\n-                upper = pivotIndices[1];\n+                indices = partition(long.class, a, Unsafe.ARRAY_LONG_BASE_OFFSET,\n+                        low, high, e1, e5, DualPivotQuicksort::partitionWithTwoPivots);\n+\n@@ -1166,2 +1277,2 @@\n-                    sorter.forkSorter(bits | 1, lower + 1, upper);\n-                    sorter.forkSorter(bits | 1, upper + 1, high);\n+                    sorter.fork(bits | 1, indices[0] + 1, indices[1]);\n+                    sorter.fork(bits | 1, indices[1] + 1, high);\n@@ -1169,2 +1280,2 @@\n-                    sort(sorter, a, bits | 1, lower + 1, upper);\n-                    sort(sorter, a, bits | 1, upper + 1, high);\n+                    sort(sorter, a, bits | 1, indices[0] + 1, indices[1]);\n+                    sort(sorter, a, bits | 1, indices[1] + 1, high);\n@@ -1173,1 +1284,4 @@\n-            } else { \/\/ Use single pivot in case of many equal elements\n+            } else { \/\/ Partitioning with one pivot\n+\n+                indices = partition(long.class, a, Unsafe.ARRAY_LONG_BASE_OFFSET,\n+                        low, high, e3, e3, DualPivotQuicksort::partitionWithOnePivot);\n@@ -1175,7 +1289,0 @@\n-                \/*\n-                 * Use the third of the five sorted elements as the pivot.\n-                 * This value is inexpensive approximation of the median.\n-                 *\/\n-                int[] pivotIndices = partition(long.class, a, Unsafe.ARRAY_LONG_BASE_OFFSET, low, high, e3, e3, DualPivotQuicksort::partitionSinglePivot);\n-                lower = pivotIndices[0];\n-                upper = pivotIndices[1];\n@@ -1188,1 +1295,1 @@\n-                    sorter.forkSorter(bits | 1, upper, high);\n+                    sorter.fork(bits | 1, indices[1], high);\n@@ -1190,1 +1297,1 @@\n-                    sort(sorter, a, bits | 1, upper, high);\n+                    sort(sorter, a, bits | 1, indices[1], high);\n@@ -1193,1 +1300,1 @@\n-            high = lower; \/\/ Iterate along the left part\n+            high = indices[0]; \/\/ Iterate along the left part\n@@ -1198,1 +1305,1 @@\n-     * Partitions the specified range of the array using the two pivots provided.\n+     * Partitions the specified range of the array using two given pivots.\n@@ -1200,1 +1307,1 @@\n-     * @param array the array to be partitioned\n+     * @param a the array for partitioning\n@@ -1205,1 +1312,1 @@\n-     *\n+     * @return indices of parts after partitioning\n@@ -1207,3 +1314,3 @@\n-    @ForceInline\n-    private static int[] partitionDualPivot(long[] a, int low, int high, int pivotIndex1, int pivotIndex2) {\n-        int end = high - 1;\n+    private static int[] partitionWithTwoPivots(\n+            long[] a, int low, int high, int pivotIndex1, int pivotIndex2) {\n+        int upper = --high;\n@@ -1211,1 +1318,0 @@\n-        int upper = end;\n@@ -1213,4 +1319,7 @@\n-        int e1 = pivotIndex1;\n-        int e5 = pivotIndex2;\n-        long pivot1 = a[e1];\n-        long pivot2 = a[e5];\n+        \/*\n+         * Use the first and fifth of the five sorted elements as\n+         * the pivots. These values are inexpensive approximation\n+         * of tertiles. Note, that pivot1 < pivot2.\n+         *\/\n+        long pivot1 = a[pivotIndex1];\n+        long pivot2 = a[pivotIndex2];\n@@ -1225,2 +1334,2 @@\n-        a[e1] = a[lower];\n-        a[e5] = a[upper];\n+        a[pivotIndex1] = a[lower];\n+        a[pivotIndex2] = a[upper];\n@@ -1237,13 +1346,7 @@\n-         *   left part                 central part          right part\n-         * +------------------------------------------------------------+\n-                  * |  < pivot1  |   ?   |  pivot1 <= && <= pivot2  |  > pivot2  |\n-         * +------------------------------------------------------------+\n-         *             ^       ^                            ^\n-         *             |       |                            |\n-         *           lower     k                          upper\n-         *\n-         * Invariants:\n-         *\n-         *              all in (low, lower] < pivot1\n-         *    pivot1 <= all in (k, upper)  <= pivot2\n-         *              all in [upper, end) > pivot2\n+         *     left part                     central part          right part\n+         * +-------------------------------------------------------------------+\n+         * |   < pivot1   |    ?     |  pivot1 <= .. <= pivot2  |   > pivot2   |\n+         * +-------------------------------------------------------------------+\n+         *               ^          ^                            ^\n+         *               |          |                            |\n+         *             lower        k                          upper\n@@ -1252,0 +1355,2 @@\n+         * Pointer lower is the last index of left part\n+         * Pointer upper is the first index of right part\n@@ -1256,10 +1361,3 @@\n-            if (ak < pivot1) { \/\/ Move a[k] to the left side\n-                while (lower < k) {\n-                    if (a[++lower] >= pivot1) {\n-                        if (a[lower] > pivot2) {\n-                            a[k] = a[--upper];\n-                            a[upper] = a[lower];\n-                        } else {\n-                            a[k] = a[lower];\n-                        }\n-                        a[lower] = ak;\n+            if (ak < pivot1) { \/\/ Move a[k] to the left part\n+                while (a[++lower] < pivot1) {\n+                    if (lower == k) {\n@@ -1269,1 +1367,8 @@\n-            } else if (ak > pivot2) { \/\/ Move a[k] to the right side\n+                if (a[lower] > pivot2) {\n+                    a[k] = a[--upper];\n+                    a[upper] = a[lower];\n+                } else {\n+                    a[k] = a[lower];\n+                }\n+                a[lower] = ak;\n+            } else if (ak > pivot2) { \/\/ Move a[k] to the right part\n@@ -1278,2 +1383,2 @@\n-        a[low] = a[lower]; a[lower] = pivot1;\n-        a[end] = a[upper]; a[upper] = pivot2;\n+        a[low]  = a[lower]; a[lower] = pivot1;\n+        a[high] = a[upper]; a[upper] = pivot2;\n@@ -1281,1 +1386,1 @@\n-        return new int[] {lower, upper};\n+        return new int[] { lower, upper };\n@@ -1285,1 +1390,1 @@\n-     * Partitions the specified range of the array using a single pivot provided.\n+     * Partitions the specified range of the array using one given pivot.\n@@ -1287,1 +1392,1 @@\n-     * @param array the array to be partitioned\n+     * @param a the array for partitioning\n@@ -1290,3 +1395,3 @@\n-     * @param pivotIndex1 the index of pivot1, the first pivot\n-     * @param pivotIndex2 the index of pivot2, the second pivot\n-     *\n+     * @param pivotIndex1 the index of single pivot\n+     * @param pivotIndex2 the index of single pivot\n+     * @return indices of parts after partitioning\n@@ -1294,4 +1399,3 @@\n-    @ForceInline\n-    private static int[] partitionSinglePivot(long[] a, int low, int high, int pivotIndex1, int pivotIndex2) {\n-\n-        int end = high - 1;\n+    private static int[] partitionWithOnePivot(\n+            long[] a, int low, int high, int pivotIndex1, int pivotIndex2) {\n+        int upper = high;\n@@ -1299,1 +1403,0 @@\n-        int upper = end;\n@@ -1301,2 +1404,5 @@\n-        int e3 = pivotIndex1;\n-        long pivot = a[e3];\n+        \/*\n+         * Use the third of the five sorted elements as the pivot.\n+         * This value is inexpensive approximation of the median.\n+         *\/\n+        long pivot = a[pivotIndex1];\n@@ -1311,1 +1417,1 @@\n-        a[e3] = a[lower];\n+        a[pivotIndex1] = a[lower];\n@@ -1314,1 +1420,1 @@\n-         * Traditional 3-way (Dutch National Flag) partitioning\n+         * Dutch National Flag partitioning\n@@ -1316,1 +1422,1 @@\n-         *   left part                 central part    right part\n+         *     left part               central part    right part\n@@ -1318,1 +1424,1 @@\n-         * |   < pivot   |     ?     |   == pivot   |   > pivot   |\n+         * |   < pivot    |    ?     |   == pivot   |   > pivot   |\n@@ -1320,9 +1426,3 @@\n-         *              ^           ^                ^\n-         *              |           |                |\n-         *            lower         k              upper\n-         *\n-         * Invariants:\n-         *\n-         *   all in (low, lower] < pivot\n-         *   all in (k, upper)  == pivot\n-         *   all in [upper, end] > pivot\n+         *               ^          ^                ^\n+         *               |          |                |\n+         *             lower        k              upper\n@@ -1331,0 +1431,2 @@\n+         * Pointer lower is the last index of left part\n+         * Pointer upper is the first index of right part\n@@ -1332,1 +1434,1 @@\n-        for (int k = ++upper; --k > lower; ) {\n+        for (int k = upper; --k > lower; ) {\n@@ -1338,1 +1440,1 @@\n-                if (ak < pivot) { \/\/ Move a[k] to the left side\n+                if (ak < pivot) { \/\/ Move a[k] to the left part\n@@ -1345,1 +1447,1 @@\n-                } else { \/\/ ak > pivot - Move a[k] to the right side\n+                } else { \/\/ ak > pivot - Move a[k] to the right part\n@@ -1355,1 +1457,2 @@\n-        return new int[] {lower, upper};\n+\n+        return new int[] { lower, upper };\n@@ -1361,2 +1464,2 @@\n-     * Mixed insertion sort is combination of simple insertion sort,\n-     * pin insertion sort and pair insertion sort.\n+     * Mixed insertion sort is combination of pin insertion sort,\n+     * simple insertion sort and pair insertion sort.\n@@ -1374,4 +1477,1 @@\n-    private static void mixedInsertionSort(long[] a, int low, int high) {\n-        int size = high - low;\n-        int end = high - 3 * ((size >> 5) << 3);\n-        if (end == high) {\n+    static void mixedInsertionSort(long[] a, int low, int high) {\n@@ -1379,4 +1479,10 @@\n-            \/*\n-             * Invoke simple insertion sort on tiny array.\n-             *\/\n-            for (int i; ++low < end; ) {\n+        \/*\n+         * Split part for pin and pair insertion sorts.\n+         *\/\n+        int end = high - 3 * ((high - low) >> 3 << 1);\n+\n+        \/*\n+         * Invoke simple insertion sort on small part.\n+         *\/\n+        if (end == high) {\n+            for (int i; ++low < high; ) {\n@@ -1385,2 +1491,2 @@\n-                while (ai < a[--i]) {\n-                    a[i + 1] = a[i];\n+                while (ai < a[i - 1]) {\n+                    a[i] = a[--i];\n@@ -1388,1 +1494,1 @@\n-                a[i + 1] = ai;\n+                a[i] = ai;\n@@ -1390,1 +1496,8 @@\n-        } else {\n+            return;\n+        }\n+\n+        \/*\n+         * Start with pin insertion sort.\n+         *\/\n+        for (int i, p = high; ++low < end; ) {\n+            long ai = a[i = low], pin = a[--p];\n@@ -1393,7 +1506,1 @@\n-             * Start with pin insertion sort on small part.\n-             *\n-             * Pin insertion sort is extended simple insertion sort.\n-             * The main idea of this sort is to put elements larger\n-             * than an element called pin to the end of array (the\n-             * proper area for such elements). It avoids expensive\n-             * movements of these elements through the whole array.\n+             * Swap larger element with pin.\n@@ -1401,40 +1508,3 @@\n-            long pin = a[end];\n-\n-            for (int i, p = high; ++low < end; ) {\n-                long ai = a[i = low];\n-\n-                if (ai < a[i - 1]) { \/\/ Small element\n-\n-                    \/*\n-                     * Insert small element into sorted part.\n-                     *\/\n-                    a[i] = a[--i];\n-\n-                    while (ai < a[--i]) {\n-                        a[i + 1] = a[i];\n-                    }\n-                    a[i + 1] = ai;\n-\n-                } else if (p > i && ai > pin) { \/\/ Large element\n-\n-                    \/*\n-                     * Find element smaller than pin.\n-                     *\/\n-                    while (a[--p] > pin);\n-\n-                    \/*\n-                     * Swap it with large element.\n-                     *\/\n-                    if (p > i) {\n-                        ai = a[p];\n-                        a[p] = a[i];\n-                    }\n-\n-                    \/*\n-                     * Insert small element into sorted part.\n-                     *\/\n-                    while (ai < a[--i]) {\n-                        a[i + 1] = a[i];\n-                    }\n-                    a[i + 1] = ai;\n-                }\n+            if (ai > pin) {\n+                ai = pin;\n+                a[p] = a[i];\n@@ -1444,1 +1514,1 @@\n-             * Continue with pair insertion sort on remain part.\n+             * Insert element into sorted part.\n@@ -1446,2 +1516,5 @@\n-            for (int i; low < high; ++low) {\n-                long a1 = a[i = low], a2 = a[++low];\n+            while (ai < a[i - 1]) {\n+                a[i] = a[--i];\n+            }\n+            a[i] = ai;\n+        }\n@@ -1449,6 +1522,5 @@\n-                \/*\n-                 * Insert two elements per iteration: at first, insert the\n-                 * larger element and then insert the smaller element, but\n-                 * from the position where the larger element was inserted.\n-                 *\/\n-                if (a1 > a2) {\n+        \/*\n+         * Finish with pair insertion sort.\n+         *\/\n+        for (int i; low < high; ++low) {\n+            long a1 = a[i = low], a2 = a[++low];\n@@ -1456,4 +1528,6 @@\n-                    while (a1 < a[--i]) {\n-                        a[i + 2] = a[i];\n-                    }\n-                    a[++i + 1] = a1;\n+            \/*\n+             * Insert two elements per iteration: at first, insert the\n+             * larger element and then insert the smaller element, but\n+             * from the position where the larger element was inserted.\n+             *\/\n+            if (a1 > a2) {\n@@ -1461,4 +1535,4 @@\n-                    while (a2 < a[--i]) {\n-                        a[i + 1] = a[i];\n-                    }\n-                    a[i + 1] = a2;\n+                while (a1 < a[--i]) {\n+                    a[i + 2] = a[i];\n+                }\n+                a[++i + 1] = a1;\n@@ -1466,1 +1540,4 @@\n-                } else if (a1 < a[i - 1]) {\n+                while (a2 < a[--i]) {\n+                    a[i + 1] = a[i];\n+                }\n+                a[i + 1] = a2;\n@@ -1468,4 +1545,1 @@\n-                    while (a2 < a[--i]) {\n-                        a[i + 2] = a[i];\n-                    }\n-                    a[++i + 1] = a2;\n+            } else if (a1 < a[i - 1]) {\n@@ -1473,4 +1547,7 @@\n-                    while (a1 < a[--i]) {\n-                        a[i + 1] = a[i];\n-                    }\n-                    a[i + 1] = a1;\n+                while (a2 < a[--i]) {\n+                    a[i + 2] = a[i];\n+                }\n+                a[++i + 1] = a2;\n+\n+                while (a1 < a[--i]) {\n+                    a[i + 1] = a[i];\n@@ -1478,0 +1555,1 @@\n+                a[i + 1] = a1;\n@@ -1489,1 +1567,1 @@\n-    private static void insertionSort(long[] a, int low, int high) {\n+    static void insertionSort(long[] a, int low, int high) {\n@@ -1494,38 +1572,3 @@\n-                while (--i >= low && ai < a[i]) {\n-                    a[i + 1] = a[i];\n-                }\n-                a[i + 1] = ai;\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Sorts the specified range of the array using heap sort.\n-     *\n-     * @param a the array to be sorted\n-     * @param low the index of the first element, inclusive, to be sorted\n-     * @param high the index of the last element, exclusive, to be sorted\n-     *\/\n-    private static void heapSort(long[] a, int low, int high) {\n-        for (int k = (low + high) >>> 1; k > low; ) {\n-            pushDown(a, --k, a[k], low, high);\n-        }\n-        while (--high > low) {\n-            long max = a[low];\n-            pushDown(a, low, a[high], low, high);\n-            a[high] = max;\n-        }\n-    }\n-\n-    \/**\n-     * Pushes specified element down during heap sort.\n-     *\n-     * @param a the given array\n-     * @param p the start index\n-     * @param value the given element\n-     * @param low the index of the first element, inclusive, to be sorted\n-     * @param high the index of the last element, exclusive, to be sorted\n-     *\/\n-    private static void pushDown(long[] a, int p, long value, int low, int high) {\n-        for (int k ;; a[p] = a[p = k]) {\n-            k = (p << 1) - low + 2; \/\/ Index of the right child\n+                do {\n+                    a[i] = a[--i];\n+                } while (i > low && ai < a[i - 1]);\n@@ -1533,8 +1576,1 @@\n-            if (k > high) {\n-                break;\n-            }\n-            if (k == high || a[k] < a[k - 1]) {\n-                --k;\n-            }\n-            if (a[k] <= value) {\n-                break;\n+                a[i ] = ai;\n@@ -1543,1 +1579,0 @@\n-        a[p] = value;\n@@ -1547,1 +1582,1 @@\n-     * Tries to sort the specified range of the array.\n+     * Tries to sort the specified range of the array using merging sort.\n@@ -1551,3 +1586,3 @@\n-     * @param low the index of the first element to be sorted\n-     * @param size the array size\n-     * @return true if finally sorted, false otherwise\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n+     * @return {@code true} if the array is finally sorted, otherwise {@code false}\n@@ -1555,1 +1590,1 @@\n-    private static boolean tryMergeRuns(Sorter sorter, long[] a, int low, int size) {\n+    static boolean tryMergingSort(Sorter<long[]> sorter, long[] a, int low, int high) {\n@@ -1558,3 +1593,2 @@\n-         * The run array is constructed only if initial runs are\n-         * long enough to continue, run[i] then holds start index\n-         * of the i-th sequence of elements in non-descending order.\n+         * The element run[i] holds the start index\n+         * of i-th sequence in non-descending order.\n@@ -1562,0 +1596,1 @@\n+        int count = 1;\n@@ -1563,2 +1598,0 @@\n-        int high = low + size;\n-        int count = 1, last = low;\n@@ -1569,1 +1602,1 @@\n-        for (int k = low + 1; k < high; ) {\n+        for (int k = low + 1, last = low; k < high; ) {\n@@ -1572,1 +1605,1 @@\n-             * Find the end index of the current run.\n+             * Find the next run.\n@@ -1597,1 +1630,1 @@\n-             * Check special cases.\n+             * Check if the runs are too long to continue scanning.\n@@ -1599,23 +1632,3 @@\n-            if (run == null) {\n-                if (k == high) {\n-\n-                    \/*\n-                     * The array is monotonous sequence,\n-                     * and therefore already sorted.\n-                     *\/\n-                    return true;\n-                }\n-\n-                if (k - low < MIN_FIRST_RUN_SIZE) {\n-\n-                    \/*\n-                     * The first run is too small\n-                     * to proceed with scanning.\n-                     *\/\n-                    return false;\n-                }\n-\n-                run = new int[((size >> 10) | 0x7F) & 0x3FF];\n-                run[0] = low;\n-\n-            } else if (a[last - 1] > a[last]) {\n+            if (count > 6 && k - low < count * MIN_RUN_SIZE) {\n+                return false;\n+            }\n@@ -1623,1 +1636,4 @@\n-                if (count > (k - low) >> MIN_FIRST_RUNS_FACTOR) {\n+            \/*\n+             * Process the run.\n+             *\/\n+            if (run == null) {\n@@ -1625,0 +1641,1 @@\n+                if (k == high) {\n@@ -1626,2 +1643,2 @@\n-                     * The first runs are not long\n-                     * enough to continue scanning.\n+                     * Array is monotonous sequence\n+                     * and therefore already sorted.\n@@ -1629,1 +1646,1 @@\n-                    return false;\n+                    return true;\n@@ -1632,1 +1649,4 @@\n-                if (++count == MAX_RUN_CAPACITY) {\n+                run = new int[((high - low) >> 9) & 0x1FF | 0x3F];\n+                run[0] = low;\n+\n+            } else if (a[last - 1] > a[last]) { \/\/ Start the new run\n@@ -1634,0 +1654,1 @@\n+                if (++count == run.length) {\n@@ -1639,0 +1660,1 @@\n+            }\n@@ -1640,1 +1662,4 @@\n-                if (count == run.length) {\n+            \/*\n+             * Save the current run.\n+             *\/\n+            run[count] = (last = k);\n@@ -1642,5 +1667,5 @@\n-                    \/*\n-                     * Increase capacity of index array.\n-                     *\/\n-                    run = Arrays.copyOf(run, count << 1);\n-                }\n+            \/*\n+             * Check single-element run at the end.\n+             *\/\n+            if (++k == high) {\n+                --k;\n@@ -1648,1 +1673,0 @@\n-            run[count] = (last = k);\n@@ -1652,1 +1676,1 @@\n-         * Merge runs of highly structured array.\n+         * Merge all runs.\n@@ -1657,3 +1681,1 @@\n-            if (sorter == null || (b = (long[]) sorter.b) == null) {\n-                b = new long[size];\n-            } else {\n+            if (sorter != null && (b = sorter.b) != null) {\n@@ -1661,0 +1683,2 @@\n+            } else if ((b = tryAllocate(long[].class, high - low)) == null) {\n+                return false;\n@@ -1681,1 +1705,1 @@\n-            int aim, boolean parallel, int[] run, int lo, int hi) {\n+                                    int aim, boolean parallel, int[] run, int lo, int hi) {\n@@ -1687,3 +1711,1 @@\n-            for (int i = run[hi], j = i - offset, low = run[lo]; i > low;\n-                b[--j] = a[--i]\n-            );\n+            System.arraycopy(a, run[lo], b, run[lo] - offset, run[hi] - run[lo]);\n@@ -1700,1 +1722,1 @@\n-         * Merge the left and right parts.\n+         * Merge runs of each part.\n@@ -1702,11 +1724,2 @@\n-        long[] a1, a2;\n-\n-        if (parallel && hi - lo > MIN_RUN_COUNT) {\n-            RunMerger merger = new RunMerger(a, b, offset, 0, run, mi, hi).forkMe();\n-            a1 = mergeRuns(a, b, offset, -aim, true, run, lo, mi);\n-            a2 = (long[]) merger.getDestination();\n-        } else {\n-            a1 = mergeRuns(a, b, offset, -aim, false, run, lo, mi);\n-            a2 = mergeRuns(a, b, offset,    0, false, run, mi, hi);\n-        }\n-\n+        long[] a1 = mergeRuns(a, b, offset, -aim, parallel, run, lo, mi);\n+        long[] a2 = mergeRuns(a, b, offset,    0, parallel, run, mi, hi);\n@@ -1721,2 +1734,5 @@\n-        if (parallel) {\n-            new Merger(null, dst, k, a1, lo1, hi1, a2, lo2, hi2).invoke();\n+        \/*\n+         * Merge the left and right parts.\n+         *\/\n+        if (hi1 - lo1 > MIN_PARALLEL_SORT_SIZE && parallel) {\n+            new Merger<>(null, dst, k, a1, lo1, hi1, a2, lo2, hi2).invoke();\n@@ -1742,2 +1758,2 @@\n-    private static void mergeParts(Merger merger, long[] dst, int k,\n-            long[] a1, int lo1, int hi1, long[] a2, int lo2, int hi2) {\n+    private static void mergeParts(Merger<long[]> merger, long[] dst, int k,\n+                                   long[] a1, int lo1, int hi1, long[] a2, int lo2, int hi2) {\n@@ -1745,0 +1761,3 @@\n+        \/*\n+         * Merge sorted parts in parallel.\n+         *\/\n@@ -1757,0 +1776,8 @@\n+                \/*\n+                 * Terminate, if the second part is empty.\n+                 *\/\n+                if (lo2 == hi2) {\n+                    System.arraycopy(a1, lo1, dst, k, hi1 - lo1);\n+                    return;\n+                }\n+\n@@ -1760,1 +1787,1 @@\n-                if (hi1 - lo1 < MIN_PARALLEL_MERGE_PARTS_SIZE) {\n+                if (hi1 - lo1 < MIN_PARALLEL_SORT_SIZE) {\n@@ -1772,1 +1799,1 @@\n-                 * Partition the smaller part.\n+                 * Divide the smaller part.\n@@ -1774,2 +1801,2 @@\n-                for (int loo = lo2; loo < mi2; ) {\n-                    int t = (loo + mi2) >>> 1;\n+                for (int mi0 = lo2; mi0 < mi2; ) {\n+                    int m = (mi0 + mi2) >>> 1;\n@@ -1777,2 +1804,2 @@\n-                    if (key > a2[t]) {\n-                        loo = t + 1;\n+                    if (key > a2[m]) {\n+                        mi0 = m + 1;\n@@ -1780,1 +1807,1 @@\n-                        mi2 = t;\n+                        mi2 = m;\n@@ -1784,1 +1811,4 @@\n-                int d = mi2 - lo2 + mi1 - lo1;\n+                \/*\n+                 * Reserve space for the left parts.\n+                 *\/\n+                int space = mi2 - lo2 + mi1 - lo1;\n@@ -1787,1 +1817,1 @@\n-                 * Merge the right sub-parts in parallel.\n+                 * Merge other parts in parallel.\n@@ -1789,1 +1819,1 @@\n-                merger.forkMerger(dst, k + d, a1, mi1, hi1, a2, mi2, hi2);\n+                merger.fork(k + space, mi1, hi1, mi2, hi2);\n@@ -1792,1 +1822,1 @@\n-                 * Process the sub-left parts.\n+                 * Iterate along the left parts.\n@@ -1802,2 +1832,4 @@\n-        while (lo1 < hi1 && lo2 < hi2) {\n-            dst[k++] = a1[lo1] < a2[lo2] ? a1[lo1++] : a2[lo2++];\n+        if (lo2 < hi2 && a1[hi1 - 1] > a2[lo2]) {\n+            while (lo1 < hi1 && lo2 < hi2) {\n+                dst[k++] = a1[lo1] < a2[lo2] ? a1[lo1++] : a2[lo2++];\n+            }\n@@ -1817,2 +1849,0 @@\n-\/\/ [byte]\n-\n@@ -1820,2 +1850,2 @@\n-     * Sorts the specified range of the array using\n-     * counting sort or insertion sort.\n+     * Tries to sort the specified range of the array\n+     * using LSD (The Least Significant Digit) Radix sort.\n@@ -1826,0 +1856,1 @@\n+     * @return {@code true} if the array is finally sorted, otherwise {@code false}\n@@ -1827,5 +1858,133 @@\n-    static void sort(byte[] a, int low, int high) {\n-        if (high - low > MIN_BYTE_COUNTING_SORT_SIZE) {\n-            countingSort(a, low, high);\n-        } else {\n-            insertionSort(a, low, high);\n+    static boolean tryRadixSort(Sorter<long[]> sorter, long[] a, int low, int high) {\n+        long[] b; int offset = low, size = high - low;\n+\n+        \/*\n+         * Allocate additional buffer.\n+         *\/\n+        if (sorter != null && (b = sorter.b) != null) {\n+            offset = sorter.offset;\n+        } else if ((b = tryAllocate(long[].class, size)) == null) {\n+            return false;\n+        }\n+\n+        int start = low - offset;\n+        int last = high - offset;\n+\n+        \/*\n+         * Count the number of all digits.\n+         *\/\n+        int[] count1 = new int[1024];\n+        int[] count2 = new int[2048];\n+        int[] count3 = new int[2048];\n+        int[] count4 = new int[2048];\n+        int[] count5 = new int[2048];\n+        int[] count6 = new int[1024];\n+\n+        for (int i = low; i < high; ++i) {\n+            ++count1[(int)  (a[i]         & 0x3FF)];\n+            ++count2[(int) ((a[i] >>> 10) & 0x7FF)];\n+            ++count3[(int) ((a[i] >>> 21) & 0x7FF)];\n+            ++count4[(int) ((a[i] >>> 32) & 0x7FF)];\n+            ++count5[(int) ((a[i] >>> 43) & 0x7FF)];\n+            ++count6[(int) ((a[i] >>> 54) ^ 0x200)]; \/\/ Reverse the sign bit\n+        }\n+\n+        \/*\n+         * Detect digits to be processed.\n+         *\/\n+        boolean processDigit1 = processDigit(count1, size, low);\n+        boolean processDigit2 = processDigit(count2, size, low);\n+        boolean processDigit3 = processDigit(count3, size, low);\n+        boolean processDigit4 = processDigit(count4, size, low);\n+        boolean processDigit5 = processDigit(count5, size, low);\n+        boolean processDigit6 = processDigit(count6, size, low);\n+\n+        \/*\n+         * Process the 1-st digit.\n+         *\/\n+        if (processDigit1) {\n+            for (int i = high; i > low; ) {\n+                b[--count1[(int) (a[--i] & 0x3FF)] - offset] = a[i];\n+            }\n+        }\n+\n+        \/*\n+         * Process the 2-nd digit.\n+         *\/\n+        if (processDigit2) {\n+            if (processDigit1) {\n+                for (int i = last; i > start; ) {\n+                    a[--count2[(int) ((b[--i] >>> 10) & 0x7FF)]] = b[i];\n+                }\n+            } else {\n+                for (int i = high; i > low; ) {\n+                    b[--count2[(int) ((a[--i] >>> 10) & 0x7FF)] - offset] = a[i];\n+                }\n+            }\n+        }\n+\n+        \/*\n+         * Process the 3-rd digit.\n+         *\/\n+        if (processDigit3) {\n+            if (processDigit1 ^ processDigit2) {\n+                for (int i = last; i > start; ) {\n+                    a[--count3[(int) ((b[--i] >>> 21) & 0x7FF)]] = b[i];\n+                }\n+            } else {\n+                for (int i = high; i > low; ) {\n+                    b[--count3[(int) ((a[--i] >>> 21) & 0x7FF)] - offset] = a[i];\n+                }\n+            }\n+        }\n+\n+        \/*\n+         * Process the 4-th digit.\n+         *\/\n+        if (processDigit4) {\n+            if (processDigit1 ^ processDigit2 ^ processDigit3) {\n+                for (int i = last; i > start; ) {\n+                    a[--count4[(int) ((b[--i] >>> 32) & 0x7FF)]] = b[i];\n+                }\n+            } else {\n+                for (int i = high; i > low; ) {\n+                    b[--count4[(int) ((a[--i] >>> 32) & 0x7FF)] - offset] = a[i];\n+                }\n+            }\n+        }\n+\n+        \/*\n+         * Process the 5-th digit.\n+         *\/\n+        if (processDigit5) {\n+            if (processDigit1 ^ processDigit2 ^ processDigit3 ^ processDigit4) {\n+                for (int i = last; i > start; ) {\n+                    a[--count5[(int) ((b[--i] >>> 43) & 0x7FF)]] = b[i];\n+                }\n+            } else {\n+                for (int i = high; i > low; ) {\n+                    b[--count5[(int) ((a[--i] >>> 43) & 0x7FF)] - offset] = a[i];\n+                }\n+            }\n+        }\n+\n+        \/*\n+         * Process the 6-th digit.\n+         *\/\n+        if (processDigit6) {\n+            if (processDigit1 ^ processDigit2 ^ processDigit3 ^ processDigit4 ^ processDigit5) {\n+                for (int i = last; i > start; ) {\n+                    a[--count6[(int) ((b[--i] >>> 54) ^ 0x200)]] = b[i];\n+                }\n+            } else {\n+                for (int i = high; i > low; ) {\n+                    b[--count6[(int) ((a[--i] >>> 54) ^ 0x200)] - offset] = a[i];\n+                }\n+            }\n+        }\n+\n+        \/*\n+         * Copy the buffer to original array, if we process ood number of digits.\n+         *\/\n+        if (processDigit1 ^ processDigit2 ^ processDigit3 ^ processDigit4 ^ processDigit5 ^ processDigit6) {\n+            System.arraycopy(b, low - offset, a, low, size);\n@@ -1833,0 +1992,1 @@\n+        return true;\n@@ -1836,1 +1996,1 @@\n-     * Sorts the specified range of the array using insertion sort.\n+     * Sorts the specified range of the array using heap sort.\n@@ -1842,3 +2002,10 @@\n-    private static void insertionSort(byte[] a, int low, int high) {\n-        for (int i, k = low; ++k < high; ) {\n-            byte ai = a[i = k];\n+    static void heapSort(long[] a, int low, int high) {\n+        for (int k = (low + high) >>> 1; k > low; ) {\n+            pushDown(a, --k, a[k], low, high);\n+        }\n+        while (--high > low) {\n+            long max = a[low];\n+            pushDown(a, low, a[high], low, high);\n+            a[high] = max;\n+        }\n+    }\n@@ -1846,5 +2013,21 @@\n-            if (ai < a[i - 1]) {\n-                while (--i >= low && ai < a[i]) {\n-                    a[i + 1] = a[i];\n-                }\n-                a[i + 1] = ai;\n+    \/**\n+     * Pushes specified element down during heap sort.\n+     *\n+     * @param a the given array\n+     * @param p the start index\n+     * @param value the given element\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n+     *\/\n+    private static void pushDown(long[] a, int p, long value, int low, int high) {\n+        for (int k ;; a[p] = a[p = k]) {\n+            k = (p << 1) - low + 2; \/\/ Index of the right child\n+\n+            if (k > high) {\n+                break;\n+            }\n+            if (k == high || a[k] < a[k - 1]) {\n+                --k;\n+            }\n+            if (a[k] <= value) {\n+                break;\n@@ -1853,0 +2036,1 @@\n+        a[p] = value;\n@@ -1855,0 +2039,2 @@\n+\/\/ #[byte]\n+\n@@ -1856,1 +2042,6 @@\n-     * The number of distinct byte values.\n+     * Sorts the specified range of the array using\n+     * counting sort or insertion sort.\n+     *\n+     * @param a the array to be sorted\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n@@ -1858,1 +2049,7 @@\n-    private static final int NUM_BYTE_VALUES = 1 << 8;\n+    static void sort(byte[] a, int low, int high) {\n+        if (high - low > MIN_BYTE_COUNTING_SORT_SIZE) {\n+            countingSort(a, low, high);\n+        } else {\n+            insertionSort(a, low, high);\n+        }\n+    }\n@@ -1861,1 +2058,1 @@\n-     * Max index of byte counter.\n+     * The number of distinct byte values.\n@@ -1863,1 +2060,1 @@\n-    private static final int MAX_BYTE_INDEX = Byte.MAX_VALUE + NUM_BYTE_VALUES + 1;\n+    private static final int NUM_BYTE_VALUES = 1 << 8;\n@@ -1876,1 +2073,1 @@\n-         * Compute a histogram with the number of each values.\n+         * Compute the histogram.\n@@ -1881,1 +2078,1 @@\n-         * Place values on their final positions.\n+         * Put values on their final positions.\n@@ -1883,3 +2080,2 @@\n-        if (high - low > NUM_BYTE_VALUES) {\n-            for (int i = MAX_BYTE_INDEX; --i > Byte.MAX_VALUE; ) {\n-                int value = i & 0xFF;\n+        for (int i = Byte.MAX_VALUE + 1; high > low; ) {\n+            while (count[--i & 0xFF] == 0);\n@@ -1887,7 +2083,7 @@\n-                for (low = high - count[value]; high > low;\n-                    a[--high] = (byte) value\n-                );\n-            }\n-        } else {\n-            for (int i = MAX_BYTE_INDEX; high > low; ) {\n-                while (count[--i & 0xFF] == 0);\n+            int num = count[i & 0xFF];\n+\n+            do {\n+                a[--high] = (byte) i;\n+            } while (--num > 0);\n+        }\n+    }\n@@ -1895,2 +2091,10 @@\n-                int value = i & 0xFF;\n-                int c = count[value];\n+    \/**\n+     * Sorts the specified range of the array using insertion sort.\n+     *\n+     * @param a the array to be sorted\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n+     *\/\n+    static void insertionSort(byte[] a, int low, int high) {\n+        for (int i, k = low; ++k < high; ) {\n+            byte ai = a[i = k];\n@@ -1898,0 +2102,1 @@\n+            if (ai < a[i - 1]) {\n@@ -1899,2 +2104,4 @@\n-                    a[--high] = (byte) value;\n-                } while (--c > 0);\n+                    a[i] = a[--i];\n+                } while (i > low && ai < a[i - 1]);\n+\n+                a[i ] = ai;\n@@ -1905,1 +2112,1 @@\n-\/\/ [char]\n+\/\/ #[char]\n@@ -1916,1 +2123,1 @@\n-        if (high - low > MIN_SHORT_OR_CHAR_COUNTING_SORT_SIZE) {\n+        if (high - low > MIN_CHAR_COUNTING_SORT_SIZE) {\n@@ -1924,2 +2131,43 @@\n-     * Sorts the specified array using the Dual-Pivot Quicksort and\/or\n-     * other sorts in special-cases, possibly with parallel partitions.\n+     * The number of distinct char values.\n+     *\/\n+    private static final int NUM_CHAR_VALUES = 1 << 16;\n+\n+    \/**\n+     * Sorts the specified range of the array using counting sort.\n+     *\n+     * @param a the array to be sorted\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n+     *\/\n+    private static void countingSort(char[] a, int low, int high) {\n+        int[] count = new int[NUM_CHAR_VALUES];\n+\n+        \/*\n+         * Compute the histogram.\n+         *\/\n+        for (int i = high; i > low; ++count[a[--i]]);\n+\n+        \/*\n+         * Put values on their final positions.\n+         *\/\n+        if (high - low > NUM_CHAR_VALUES) {\n+            for (int i = NUM_CHAR_VALUES; i > 0; ) {\n+                for (low = high - count[--i]; high > low; ) {\n+                    a[--high] = (char) i;\n+                }\n+            }\n+        } else {\n+            for (int i = NUM_CHAR_VALUES; high > low; ) {\n+                while (count[--i] == 0);\n+\n+                int num = count[i];\n+\n+                do {\n+                    a[--high] = (char) i;\n+                } while (--num > 0);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Sorts the specified range of the array using Dual-Pivot Quicksort.\n@@ -1929,1 +2177,1 @@\n-     *        the right bit \"0\" indicates that array is the leftmost part\n+     *        the right bit \"0\" indicates that range is the leftmost part\n@@ -1935,1 +2183,1 @@\n-            int end = high - 1, size = high - low;\n+            int size = high - low;\n@@ -1938,1 +2186,1 @@\n-             * Invoke insertion sort on small leftmost part.\n+             * Invoke insertion sort on small part.\n@@ -1946,2 +2194,1 @@\n-             * Switch to counting sort if execution\n-             * time is becoming quadratic.\n+             * Switch to counting sort, if execution time is quadratic.\n@@ -1949,1 +2196,1 @@\n-            if ((bits += DELTA) > MAX_RECURSION_DEPTH) {\n+            if ((bits += 2) > MAX_RECURSION_DEPTH) {\n@@ -1955,2 +2202,3 @@\n-             * Use an inexpensive approximation of the golden ratio\n-             * to select five sample elements and determine pivots.\n+             * Divide the given array into the golden ratio using\n+             * an inexpensive approximation to select five sample\n+             * elements and determine pivots.\n@@ -1958,1 +2206,1 @@\n-            int step = (size >> 3) * 3 + 3;\n+            int step = (size >> 2) + (size >> 3) + (size >> 7);\n@@ -1966,0 +2214,1 @@\n+            int end = high - 1;\n@@ -1974,1 +2223,1 @@\n-             * Sort these elements in place by the combination\n+             * Sort these elements in-place by the combination\n@@ -1977,7 +2226,7 @@\n-             *    5 ------o-----------o------------\n-             *            |           |\n-             *    4 ------|-----o-----o-----o------\n-             *            |     |           |\n-             *    2 ------o-----|-----o-----o------\n-             *                  |     |\n-             *    1 ------------o-----o------------\n+             *   1 ---------o---------------o-----------------\n+             *              |               |\n+             *   2 ---------|-------o-------o-------o---------\n+             *              |       |               |\n+             *   4 ---------o-------|-------o-------o---------\n+             *                      |       |\n+             *   5 -----------------o-------o-----------------\n@@ -1985,5 +2234,5 @@\n-            if (a[e5] < a[e2]) { char t = a[e5]; a[e5] = a[e2]; a[e2] = t; }\n-            if (a[e4] < a[e1]) { char t = a[e4]; a[e4] = a[e1]; a[e1] = t; }\n-            if (a[e5] < a[e4]) { char t = a[e5]; a[e5] = a[e4]; a[e4] = t; }\n-            if (a[e2] < a[e1]) { char t = a[e2]; a[e2] = a[e1]; a[e1] = t; }\n-            if (a[e4] < a[e2]) { char t = a[e4]; a[e4] = a[e2]; a[e2] = t; }\n+            if (a[e1] > a[e4]) { char t = a[e1]; a[e1] = a[e4]; a[e4] = t; }\n+            if (a[e2] > a[e5]) { char t = a[e2]; a[e2] = a[e5]; a[e5] = t; }\n+            if (a[e4] > a[e5]) { char t = a[e4]; a[e4] = a[e5]; a[e5] = t; }\n+            if (a[e1] > a[e2]) { char t = a[e1]; a[e1] = a[e2]; a[e2] = t; }\n+            if (a[e2] > a[e4]) { char t = a[e2]; a[e2] = a[e4]; a[e4] = t; }\n@@ -1991,0 +2240,3 @@\n+            \/*\n+             * Insert the third element.\n+             *\/\n@@ -2010,1 +2262,1 @@\n-             * Partitioning with 2 pivots in case of different elements.\n+             * Partitioning with two pivots on array of fully random elements.\n@@ -2041,13 +2293,7 @@\n-                 *   left part                 central part          right part\n-                 * +------------------------------------------------------------+\n-                 * |  < pivot1  |   ?   |  pivot1 <= && <= pivot2  |  > pivot2  |\n-                 * +------------------------------------------------------------+\n-                 *             ^       ^                            ^\n-                 *             |       |                            |\n-                 *           lower     k                          upper\n-                 *\n-                 * Invariants:\n-                 *\n-                 *              all in (low, lower] < pivot1\n-                 *    pivot1 <= all in (k, upper)  <= pivot2\n-                 *              all in [upper, end) > pivot2\n+                 *     left part                     central part          right part\n+                 * +-------------------------------------------------------------------+\n+                 * |   < pivot1   |    ?     |  pivot1 <= .. <= pivot2  |   > pivot2   |\n+                 * +-------------------------------------------------------------------+\n+                 *               ^          ^                            ^\n+                 *               |          |                            |\n+                 *             lower        k                          upper\n@@ -2056,0 +2302,2 @@\n+                 * Pointer lower is the last index of left part\n+                 * Pointer upper is the first index of right part\n@@ -2060,10 +2308,3 @@\n-                    if (ak < pivot1) { \/\/ Move a[k] to the left side\n-                        while (lower < k) {\n-                            if (a[++lower] >= pivot1) {\n-                                if (a[lower] > pivot2) {\n-                                    a[k] = a[--upper];\n-                                    a[upper] = a[lower];\n-                                } else {\n-                                    a[k] = a[lower];\n-                                }\n-                                a[lower] = ak;\n+                    if (ak < pivot1) { \/\/ Move a[k] to the left part\n+                        while (a[++lower] < pivot1) {\n+                            if (lower == k) {\n@@ -2073,1 +2314,8 @@\n-                    } else if (ak > pivot2) { \/\/ Move a[k] to the right side\n+                        if (a[lower] > pivot2) {\n+                            a[k] = a[--upper];\n+                            a[upper] = a[lower];\n+                        } else {\n+                            a[k] = a[lower];\n+                        }\n+                        a[lower] = ak;\n+                    } else if (ak > pivot2) { \/\/ Move a[k] to the right part\n@@ -2092,1 +2340,1 @@\n-            } else { \/\/ Use single pivot in case of many equal elements\n+            } else { \/\/ Partitioning with one pivot\n@@ -2110,1 +2358,1 @@\n-                 * Traditional 3-way (Dutch National Flag) partitioning\n+                 * Dutch National Flag partitioning\n@@ -2112,1 +2360,1 @@\n-                 *   left part                 central part    right part\n+                 *     left part               central part    right part\n@@ -2114,1 +2362,1 @@\n-                 * |   < pivot   |     ?     |   == pivot   |   > pivot   |\n+                 * |   < pivot    |    ?     |   == pivot   |   > pivot   |\n@@ -2116,9 +2364,3 @@\n-                 *              ^           ^                ^\n-                 *              |           |                |\n-                 *            lower         k              upper\n-                 *\n-                 * Invariants:\n-                 *\n-                 *   all in (low, lower] < pivot\n-                 *   all in (k, upper)  == pivot\n-                 *   all in [upper, end] > pivot\n+                 *               ^          ^                ^\n+                 *               |          |                |\n+                 *             lower        k              upper\n@@ -2127,0 +2369,2 @@\n+                 * Pointer lower is the last index of left part\n+                 * Pointer upper is the first index of right part\n@@ -2134,1 +2378,1 @@\n-                        if (ak < pivot) { \/\/ Move a[k] to the left side\n+                        if (ak < pivot) { \/\/ Move a[k] to the left part\n@@ -2141,1 +2385,1 @@\n-                        } else { \/\/ ak > pivot - Move a[k] to the right side\n+                        } else { \/\/ ak > pivot - Move a[k] to the right part\n@@ -2170,1 +2414,1 @@\n-    private static void insertionSort(char[] a, int low, int high) {\n+    static void insertionSort(char[] a, int low, int high) {\n@@ -2175,4 +2419,5 @@\n-                while (--i >= low && ai < a[i]) {\n-                    a[i + 1] = a[i];\n-                }\n-                a[i + 1] = ai;\n+                do {\n+                    a[i] = a[--i];\n+                } while (i > low && ai < a[i - 1]);\n+\n+                a[i ] = ai;\n@@ -2183,0 +2428,2 @@\n+\/\/ #[short]\n+\n@@ -2184,1 +2431,6 @@\n-     * The number of distinct char values.\n+     * Sorts the specified range of the array using\n+     * counting sort or Dual-Pivot Quicksort.\n+     *\n+     * @param a the array to be sorted\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n@@ -2186,1 +2438,12 @@\n-    private static final int NUM_CHAR_VALUES = 1 << 16;\n+    static void sort(short[] a, int low, int high) {\n+        if (high - low > MIN_SHORT_COUNTING_SORT_SIZE) {\n+            countingSort(a, low, high);\n+        } else {\n+            sort(a, 0, low, high);\n+        }\n+    }\n+\n+    \/**\n+     * The number of distinct short values.\n+     *\/\n+    private static final int NUM_SHORT_VALUES = 1 << 16;\n@@ -2195,2 +2458,2 @@\n-    private static void countingSort(char[] a, int low, int high) {\n-        int[] count = new int[NUM_CHAR_VALUES];\n+    private static void countingSort(short[] a, int low, int high) {\n+        int[] count = new int[NUM_SHORT_VALUES];\n@@ -2199,1 +2462,1 @@\n-         * Compute a histogram with the number of each values.\n+         * Compute the histogram.\n@@ -2201,1 +2464,1 @@\n-        for (int i = high; i > low; ++count[a[--i]]);\n+        for (int i = high; i > low; ++count[a[--i] & 0xFFFF]);\n@@ -2206,4 +2469,4 @@\n-        if (high - low > NUM_CHAR_VALUES) {\n-            for (int i = NUM_CHAR_VALUES; i > 0; ) {\n-                for (low = high - count[--i]; high > low;\n-                    a[--high] = (char) i\n+        if (high - low > NUM_SHORT_VALUES) {\n+            for (int i = Short.MAX_VALUE; i >= Short.MIN_VALUE; --i) {\n+                for (low = high - count[i & 0xFFFF]; high > low;\n+                     a[--high] = (short) i\n@@ -2213,3 +2476,4 @@\n-            for (int i = NUM_CHAR_VALUES; high > low; ) {\n-                while (count[--i] == 0);\n-                int c = count[i];\n+            for (int i = Short.MAX_VALUE + 1; high > low; ) {\n+                while (count[--i & 0xFFFF] == 0);\n+\n+                int num = count[i & 0xFFFF];\n@@ -2218,2 +2482,2 @@\n-                    a[--high] = (char) i;\n-                } while (--c > 0);\n+                    a[--high] = (short) i;\n+                } while (--num > 0);\n@@ -2224,18 +2488,0 @@\n-\/\/ [short]\n-\n-    \/**\n-     * Sorts the specified range of the array using\n-     * counting sort or Dual-Pivot Quicksort.\n-     *\n-     * @param a the array to be sorted\n-     * @param low the index of the first element, inclusive, to be sorted\n-     * @param high the index of the last element, exclusive, to be sorted\n-     *\/\n-    static void sort(short[] a, int low, int high) {\n-        if (high - low > MIN_SHORT_OR_CHAR_COUNTING_SORT_SIZE) {\n-            countingSort(a, low, high);\n-        } else {\n-            sort(a, 0, low, high);\n-        }\n-    }\n-\n@@ -2243,2 +2489,1 @@\n-     * Sorts the specified array using the Dual-Pivot Quicksort and\/or\n-     * other sorts in special-cases, possibly with parallel partitions.\n+     * Sorts the specified range of the array using Dual-Pivot Quicksort.\n@@ -2248,1 +2493,1 @@\n-     *        the right bit \"0\" indicates that array is the leftmost part\n+     *        the right bit \"0\" indicates that range is the leftmost part\n@@ -2254,1 +2499,1 @@\n-            int end = high - 1, size = high - low;\n+            int size = high - low;\n@@ -2257,1 +2502,1 @@\n-             * Invoke insertion sort on small leftmost part.\n+             * Invoke insertion sort on small part.\n@@ -2265,2 +2510,1 @@\n-             * Switch to counting sort if execution\n-             * time is becoming quadratic.\n+             * Switch to counting sort, if execution time is quadratic.\n@@ -2268,1 +2512,1 @@\n-            if ((bits += DELTA) > MAX_RECURSION_DEPTH) {\n+            if ((bits += 2) > MAX_RECURSION_DEPTH) {\n@@ -2274,2 +2518,3 @@\n-             * Use an inexpensive approximation of the golden ratio\n-             * to select five sample elements and determine pivots.\n+             * Divide the given array into the golden ratio using\n+             * an inexpensive approximation to select five sample\n+             * elements and determine pivots.\n@@ -2277,1 +2522,1 @@\n-            int step = (size >> 3) * 3 + 3;\n+            int step = (size >> 2) + (size >> 3) + (size >> 7);\n@@ -2285,0 +2530,1 @@\n+            int end = high - 1;\n@@ -2293,1 +2539,1 @@\n-             * Sort these elements in place by the combination\n+             * Sort these elements in-place by the combination\n@@ -2296,7 +2542,7 @@\n-             *    5 ------o-----------o------------\n-             *            |           |\n-             *    4 ------|-----o-----o-----o------\n-             *            |     |           |\n-             *    2 ------o-----|-----o-----o------\n-             *                  |     |\n-             *    1 ------------o-----o------------\n+             *   1 ---------o---------------o-----------------\n+             *              |               |\n+             *   2 ---------|-------o-------o-------o---------\n+             *              |       |               |\n+             *   4 ---------o-------|-------o-------o---------\n+             *                      |       |\n+             *   5 -----------------o-------o-----------------\n@@ -2304,5 +2550,5 @@\n-            if (a[e5] < a[e2]) { short t = a[e5]; a[e5] = a[e2]; a[e2] = t; }\n-            if (a[e4] < a[e1]) { short t = a[e4]; a[e4] = a[e1]; a[e1] = t; }\n-            if (a[e5] < a[e4]) { short t = a[e5]; a[e5] = a[e4]; a[e4] = t; }\n-            if (a[e2] < a[e1]) { short t = a[e2]; a[e2] = a[e1]; a[e1] = t; }\n-            if (a[e4] < a[e2]) { short t = a[e4]; a[e4] = a[e2]; a[e2] = t; }\n+            if (a[e1] > a[e4]) { short t = a[e1]; a[e1] = a[e4]; a[e4] = t; }\n+            if (a[e2] > a[e5]) { short t = a[e2]; a[e2] = a[e5]; a[e5] = t; }\n+            if (a[e4] > a[e5]) { short t = a[e4]; a[e4] = a[e5]; a[e5] = t; }\n+            if (a[e1] > a[e2]) { short t = a[e1]; a[e1] = a[e2]; a[e2] = t; }\n+            if (a[e2] > a[e4]) { short t = a[e2]; a[e2] = a[e4]; a[e4] = t; }\n@@ -2310,0 +2556,3 @@\n+            \/*\n+             * Insert the third element.\n+             *\/\n@@ -2329,1 +2578,1 @@\n-             * Partitioning with 2 pivots in case of different elements.\n+             * Partitioning with two pivots on array of fully random elements.\n@@ -2360,13 +2609,7 @@\n-                 *   left part                 central part          right part\n-                 * +------------------------------------------------------------+\n-                 * |  < pivot1  |   ?   |  pivot1 <= && <= pivot2  |  > pivot2  |\n-                 * +------------------------------------------------------------+\n-                 *             ^       ^                            ^\n-                 *             |       |                            |\n-                 *           lower     k                          upper\n-                 *\n-                 * Invariants:\n-                 *\n-                 *              all in (low, lower] < pivot1\n-                 *    pivot1 <= all in (k, upper)  <= pivot2\n-                 *              all in [upper, end) > pivot2\n+                 *     left part                     central part          right part\n+                 * +-------------------------------------------------------------------+\n+                 * |   < pivot1   |    ?     |  pivot1 <= .. <= pivot2  |   > pivot2   |\n+                 * +-------------------------------------------------------------------+\n+                 *               ^          ^                            ^\n+                 *               |          |                            |\n+                 *             lower        k                          upper\n@@ -2375,0 +2618,2 @@\n+                 * Pointer lower is the last index of left part\n+                 * Pointer upper is the first index of right part\n@@ -2379,10 +2624,3 @@\n-                    if (ak < pivot1) { \/\/ Move a[k] to the left side\n-                        while (lower < k) {\n-                            if (a[++lower] >= pivot1) {\n-                                if (a[lower] > pivot2) {\n-                                    a[k] = a[--upper];\n-                                    a[upper] = a[lower];\n-                                } else {\n-                                    a[k] = a[lower];\n-                                }\n-                                a[lower] = ak;\n+                    if (ak < pivot1) { \/\/ Move a[k] to the left part\n+                        while (a[++lower] < pivot1) {\n+                            if (lower == k) {\n@@ -2392,1 +2630,8 @@\n-                    } else if (ak > pivot2) { \/\/ Move a[k] to the right side\n+                        if (a[lower] > pivot2) {\n+                            a[k] = a[--upper];\n+                            a[upper] = a[lower];\n+                        } else {\n+                            a[k] = a[lower];\n+                        }\n+                        a[lower] = ak;\n+                    } else if (ak > pivot2) { \/\/ Move a[k] to the right part\n@@ -2411,1 +2656,1 @@\n-            } else { \/\/ Use single pivot in case of many equal elements\n+            } else { \/\/ Partitioning with one pivot\n@@ -2429,1 +2674,1 @@\n-                 * Traditional 3-way (Dutch National Flag) partitioning\n+                 * Dutch National Flag partitioning\n@@ -2431,1 +2676,1 @@\n-                 *   left part                 central part    right part\n+                 *     left part               central part    right part\n@@ -2433,1 +2678,1 @@\n-                 * |   < pivot   |     ?     |   == pivot   |   > pivot   |\n+                 * |   < pivot    |    ?     |   == pivot   |   > pivot   |\n@@ -2435,9 +2680,3 @@\n-                 *              ^           ^                ^\n-                 *              |           |                |\n-                 *            lower         k              upper\n-                 *\n-                 * Invariants:\n-                 *\n-                 *   all in (low, lower] < pivot\n-                 *   all in (k, upper)  == pivot\n-                 *   all in [upper, end] > pivot\n+                 *               ^          ^                ^\n+                 *               |          |                |\n+                 *             lower        k              upper\n@@ -2446,0 +2685,2 @@\n+                 * Pointer lower is the last index of left part\n+                 * Pointer upper is the first index of right part\n@@ -2453,1 +2694,1 @@\n-                        if (ak < pivot) { \/\/ Move a[k] to the left side\n+                        if (ak < pivot) { \/\/ Move a[k] to the left part\n@@ -2460,1 +2701,1 @@\n-                        } else { \/\/ ak > pivot - Move a[k] to the right side\n+                        } else { \/\/ ak > pivot - Move a[k] to the right part\n@@ -2489,1 +2730,1 @@\n-    private static void insertionSort(short[] a, int low, int high) {\n+    static void insertionSort(short[] a, int low, int high) {\n@@ -2494,51 +2735,0 @@\n-                while (--i >= low && ai < a[i]) {\n-                    a[i + 1] = a[i];\n-                }\n-                a[i + 1] = ai;\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * The number of distinct short values.\n-     *\/\n-    private static final int NUM_SHORT_VALUES = 1 << 16;\n-\n-    \/**\n-     * Max index of short counter.\n-     *\/\n-    private static final int MAX_SHORT_INDEX = Short.MAX_VALUE + NUM_SHORT_VALUES + 1;\n-\n-    \/**\n-     * Sorts the specified range of the array using counting sort.\n-     *\n-     * @param a the array to be sorted\n-     * @param low the index of the first element, inclusive, to be sorted\n-     * @param high the index of the last element, exclusive, to be sorted\n-     *\/\n-    private static void countingSort(short[] a, int low, int high) {\n-        int[] count = new int[NUM_SHORT_VALUES];\n-\n-        \/*\n-         * Compute a histogram with the number of each values.\n-         *\/\n-        for (int i = high; i > low; ++count[a[--i] & 0xFFFF]);\n-\n-        \/*\n-         * Place values on their final positions.\n-         *\/\n-        if (high - low > NUM_SHORT_VALUES) {\n-            for (int i = MAX_SHORT_INDEX; --i > Short.MAX_VALUE; ) {\n-                int value = i & 0xFFFF;\n-\n-                for (low = high - count[value]; high > low;\n-                    a[--high] = (short) value\n-                );\n-            }\n-        } else {\n-            for (int i = MAX_SHORT_INDEX; high > low; ) {\n-                while (count[--i & 0xFFFF] == 0);\n-\n-                int value = i & 0xFFFF;\n-                int c = count[value];\n-\n@@ -2546,2 +2736,4 @@\n-                    a[--high] = (short) value;\n-                } while (--c > 0);\n+                    a[i] = a[--i];\n+                } while (i > low && ai < a[i - 1]);\n+\n+                a[i ] = ai;\n@@ -2552,1 +2744,1 @@\n-\/\/ [float]\n+\/\/ #[float]\n@@ -2593,6 +2785,2 @@\n-        int size = high - low;\n-\n-        if (parallelism > 1 && size > MIN_PARALLEL_SORT_SIZE) {\n-            int depth = getDepth(parallelism, size >> 12);\n-            float[] b = depth == 0 ? null : new float[size];\n-            new Sorter(null, a, b, low, size, low, depth).invoke();\n+        if (parallelism > 1 && high - low > MIN_PARALLEL_SORT_SIZE) {\n+            new Sorter<>(a, parallelism, low, high - low, 0).invoke();\n@@ -2634,2 +2822,1 @@\n-     * Sorts the specified array using the Dual-Pivot Quicksort and\/or\n-     * other sorts in special-cases, possibly with parallel partitions.\n+     * Sorts the specified range of the array using Dual-Pivot Quicksort.\n@@ -2640,1 +2827,1 @@\n-     *        the right bit \"0\" indicates that array is the leftmost part\n+     *        the right bit \"0\" indicates that range is the leftmost part\n@@ -2644,1 +2831,1 @@\n-    static void sort(Sorter sorter, float[] a, int bits, int low, int high) {\n+    static void sort(Sorter<float[]> sorter, float[] a, int bits, int low, int high) {\n@@ -2646,1 +2833,1 @@\n-            int end = high - 1, size = high - low;\n+            int size = high - low;\n@@ -2649,1 +2836,1 @@\n-             * Run mixed insertion sort on small non-leftmost parts.\n+             * Run adaptive mixed insertion sort on small non-leftmost parts.\n@@ -2652,1 +2839,2 @@\n-                sort(float.class, a, Unsafe.ARRAY_FLOAT_BASE_OFFSET, low, high, DualPivotQuicksort::mixedInsertionSort);\n+                sort(float.class, a, Unsafe.ARRAY_FLOAT_BASE_OFFSET,\n+                        low, high, DualPivotQuicksort::mixedInsertionSort);\n@@ -2660,10 +2848,2 @@\n-                sort(float.class, a, Unsafe.ARRAY_FLOAT_BASE_OFFSET, low, high, DualPivotQuicksort::insertionSort);\n-                return;\n-            }\n-\n-            \/*\n-             * Check if the whole array or large non-leftmost\n-             * parts are nearly sorted and then merge runs.\n-             *\/\n-            if ((bits == 0 || size > MIN_TRY_MERGE_SIZE && (bits & 1) > 0)\n-                    && tryMergeRuns(sorter, a, low, size)) {\n+                sort(float.class, a, Unsafe.ARRAY_FLOAT_BASE_OFFSET,\n+                        low, high, DualPivotQuicksort::insertionSort);\n@@ -2674,2 +2854,1 @@\n-             * Switch to heap sort if execution\n-             * time is becoming quadratic.\n+             * Try merging sort on large part.\n@@ -2677,2 +2856,2 @@\n-            if ((bits += DELTA) > MAX_RECURSION_DEPTH) {\n-                heapSort(a, low, high);\n+            if (size > MIN_MERGING_SORT_SIZE * bits\n+                    && tryMergingSort(sorter, a, low, high)) {\n@@ -2683,2 +2862,3 @@\n-             * Use an inexpensive approximation of the golden ratio\n-             * to select five sample elements and determine pivots.\n+             * Divide the given array into the golden ratio using\n+             * an inexpensive approximation to select five sample\n+             * elements and determine pivots.\n@@ -2686,1 +2866,1 @@\n-            int step = (size >> 3) * 3 + 3;\n+            int step = (size >> 2) + (size >> 3) + (size >> 7);\n@@ -2695,1 +2875,1 @@\n-            int e5 = end - step;\n+            int e5 = high - step;\n@@ -2702,1 +2882,10 @@\n-             * Sort these elements in place by the combination\n+             * Check if part is large and contains random\n+             * data, taking into account parallel context.\n+             *\/\n+            boolean isLargeRandom =\n+                    sorter != null && bits > 2 && size > MIN_RADIX_SORT_SIZE &&\n+\/\/              size > MIN_RADIX_SORT_SIZE && (sorter == null || bits > 0) &&\n+                            (a[e1] > a[e2] || a[e2] > a3 || a3 > a[e4] || a[e4] > a[e5]);\n+\n+            \/*\n+             * Sort these elements in-place by the combination\n@@ -2705,7 +2894,7 @@\n-             *    5 ------o-----------o------------\n-             *            |           |\n-             *    4 ------|-----o-----o-----o------\n-             *            |     |           |\n-             *    2 ------o-----|-----o-----o------\n-             *                  |     |\n-             *    1 ------------o-----o------------\n+             *   1 ---------o---------------o-----------------\n+             *              |               |\n+             *   2 ---------|-------o-------o-------o---------\n+             *              |       |               |\n+             *   4 ---------o-------|-------o-------o---------\n+             *                      |       |\n+             *   5 -----------------o-------o-----------------\n@@ -2713,5 +2902,5 @@\n-            if (a[e5] < a[e2]) { float t = a[e5]; a[e5] = a[e2]; a[e2] = t; }\n-            if (a[e4] < a[e1]) { float t = a[e4]; a[e4] = a[e1]; a[e1] = t; }\n-            if (a[e5] < a[e4]) { float t = a[e5]; a[e5] = a[e4]; a[e4] = t; }\n-            if (a[e2] < a[e1]) { float t = a[e2]; a[e2] = a[e1]; a[e1] = t; }\n-            if (a[e4] < a[e2]) { float t = a[e4]; a[e4] = a[e2]; a[e2] = t; }\n+            if (a[e1] > a[e4]) { float t = a[e1]; a[e1] = a[e4]; a[e4] = t; }\n+            if (a[e2] > a[e5]) { float t = a[e2]; a[e2] = a[e5]; a[e5] = t; }\n+            if (a[e4] > a[e5]) { float t = a[e4]; a[e4] = a[e5]; a[e5] = t; }\n+            if (a[e1] > a[e2]) { float t = a[e1]; a[e1] = a[e2]; a[e2] = t; }\n+            if (a[e2] > a[e4]) { float t = a[e2]; a[e2] = a[e4]; a[e4] = t; }\n@@ -2719,0 +2908,3 @@\n+            \/*\n+             * Insert the third element.\n+             *\/\n@@ -2733,3 +2925,22 @@\n-            \/\/ Pointers\n-            int lower; \/\/ The index of the last element of the left part\n-            int upper; \/\/ The index of the first element of the right part\n+            \/*\n+             * Try Radix sort on large fully random data.\n+             *\/\n+            if (isLargeRandom\n+                    && a[e2] < a[e3] && a[e3] < a[e4]\n+                    && tryRadixSort(sorter, a, low, high)) {\n+                return;\n+            }\n+\n+            \/*\n+             * Switch to heap sort, if execution time is quadratic.\n+             *\/\n+            if ((bits += 2) > MAX_RECURSION_DEPTH) {\n+                heapSort(a, low, high);\n+                return;\n+            }\n+\n+            \/*\n+             * indices[0] - the index of the last element of the left part\n+             * indices[1] - the index of the first element of the right part\n+             *\/\n+            int[] indices;\n@@ -2738,1 +2949,1 @@\n-             * Partitioning with 2 pivots in case of different elements.\n+             * Partitioning with two pivots on array of fully random elements.\n@@ -2742,8 +2953,3 @@\n-                \/*\n-                 * Use the first and fifth of the five sorted elements as\n-                 * the pivots. These values are inexpensive approximation\n-                 * of tertiles. Note, that pivot1 < pivot2.\n-                 *\/\n-                int[] pivotIndices = partition(float.class, a, Unsafe.ARRAY_FLOAT_BASE_OFFSET, low, high, e1, e5, DualPivotQuicksort::partitionDualPivot);\n-                lower = pivotIndices[0];\n-                upper = pivotIndices[1];\n+                indices = partition(float.class, a, Unsafe.ARRAY_FLOAT_BASE_OFFSET,\n+                        low, high, e1, e5, DualPivotQuicksort::partitionWithTwoPivots);\n+\n@@ -2755,2 +2961,2 @@\n-                    sorter.forkSorter(bits | 1, lower + 1, upper);\n-                    sorter.forkSorter(bits | 1, upper + 1, high);\n+                    sorter.fork(bits | 1, indices[0] + 1, indices[1]);\n+                    sorter.fork(bits | 1, indices[1] + 1, high);\n@@ -2758,2 +2964,2 @@\n-                    sort(sorter, a, bits | 1, lower + 1, upper);\n-                    sort(sorter, a, bits | 1, upper + 1, high);\n+                    sort(sorter, a, bits | 1, indices[0] + 1, indices[1]);\n+                    sort(sorter, a, bits | 1, indices[1] + 1, high);\n@@ -2762,1 +2968,4 @@\n-            } else { \/\/ Use single pivot in case of many equal elements\n+            } else { \/\/ Partitioning with one pivot\n+\n+                indices = partition(float.class, a, Unsafe.ARRAY_FLOAT_BASE_OFFSET,\n+                        low, high, e3, e3, DualPivotQuicksort::partitionWithOnePivot);\n@@ -2764,7 +2973,0 @@\n-                \/*\n-                 * Use the third of the five sorted elements as the pivot.\n-                 * This value is inexpensive approximation of the median.\n-                 *\/\n-                int[] pivotIndices = partition(float.class, a, Unsafe.ARRAY_FLOAT_BASE_OFFSET, low, high, e3, e3, DualPivotQuicksort::partitionSinglePivot);\n-                lower = pivotIndices[0];\n-                upper = pivotIndices[1];\n@@ -2777,1 +2979,1 @@\n-                    sorter.forkSorter(bits | 1, upper, high);\n+                    sorter.fork(bits | 1, indices[1], high);\n@@ -2779,1 +2981,1 @@\n-                    sort(sorter, a, bits | 1, upper, high);\n+                    sort(sorter, a, bits | 1, indices[1], high);\n@@ -2782,1 +2984,1 @@\n-            high = lower; \/\/ Iterate along the left part\n+            high = indices[0]; \/\/ Iterate along the left part\n@@ -2787,1 +2989,1 @@\n-     * Partitions the specified range of the array using the two pivots provided.\n+     * Partitions the specified range of the array using two given pivots.\n@@ -2789,1 +2991,1 @@\n-     * @param array the array to be partitioned\n+     * @param a the array for partitioning\n@@ -2794,1 +2996,1 @@\n-     *\n+     * @return indices of parts after partitioning\n@@ -2796,3 +2998,3 @@\n-    @ForceInline\n-    private static int[] partitionDualPivot(float[] a, int low, int high, int pivotIndex1, int pivotIndex2) {\n-        int end = high - 1;\n+    private static int[] partitionWithTwoPivots(\n+            float[] a, int low, int high, int pivotIndex1, int pivotIndex2) {\n+        int upper = --high;\n@@ -2800,1 +3002,0 @@\n-        int upper = end;\n@@ -2802,4 +3003,7 @@\n-        int e1 = pivotIndex1;\n-        int e5 = pivotIndex2;\n-        float pivot1 = a[e1];\n-        float pivot2 = a[e5];\n+        \/*\n+         * Use the first and fifth of the five sorted elements as\n+         * the pivots. These values are inexpensive approximation\n+         * of tertiles. Note, that pivot1 < pivot2.\n+         *\/\n+        float pivot1 = a[pivotIndex1];\n+        float pivot2 = a[pivotIndex2];\n@@ -2814,2 +3018,2 @@\n-        a[e1] = a[lower];\n-        a[e5] = a[upper];\n+        a[pivotIndex1] = a[lower];\n+        a[pivotIndex2] = a[upper];\n@@ -2826,13 +3030,7 @@\n-         *   left part                 central part          right part\n-         * +------------------------------------------------------------+\n-                  * |  < pivot1  |   ?   |  pivot1 <= && <= pivot2  |  > pivot2  |\n-         * +------------------------------------------------------------+\n-         *             ^       ^                            ^\n-         *             |       |                            |\n-         *           lower     k                          upper\n-         *\n-         * Invariants:\n-         *\n-         *              all in (low, lower] < pivot1\n-         *    pivot1 <= all in (k, upper)  <= pivot2\n-         *              all in [upper, end) > pivot2\n+         *     left part                     central part          right part\n+         * +-------------------------------------------------------------------+\n+         * |   < pivot1   |    ?     |  pivot1 <= .. <= pivot2  |   > pivot2   |\n+         * +-------------------------------------------------------------------+\n+         *               ^          ^                            ^\n+         *               |          |                            |\n+         *             lower        k                          upper\n@@ -2841,0 +3039,2 @@\n+         * Pointer lower is the last index of left part\n+         * Pointer upper is the first index of right part\n@@ -2845,10 +3045,3 @@\n-            if (ak < pivot1) { \/\/ Move a[k] to the left side\n-                while (lower < k) {\n-                    if (a[++lower] >= pivot1) {\n-                        if (a[lower] > pivot2) {\n-                            a[k] = a[--upper];\n-                            a[upper] = a[lower];\n-                        } else {\n-                            a[k] = a[lower];\n-                        }\n-                        a[lower] = ak;\n+            if (ak < pivot1) { \/\/ Move a[k] to the left part\n+                while (a[++lower] < pivot1) {\n+                    if (lower == k) {\n@@ -2858,1 +3051,8 @@\n-            } else if (ak > pivot2) { \/\/ Move a[k] to the right side\n+                if (a[lower] > pivot2) {\n+                    a[k] = a[--upper];\n+                    a[upper] = a[lower];\n+                } else {\n+                    a[k] = a[lower];\n+                }\n+                a[lower] = ak;\n+            } else if (ak > pivot2) { \/\/ Move a[k] to the right part\n@@ -2867,2 +3067,2 @@\n-        a[low] = a[lower]; a[lower] = pivot1;\n-        a[end] = a[upper]; a[upper] = pivot2;\n+        a[low]  = a[lower]; a[lower] = pivot1;\n+        a[high] = a[upper]; a[upper] = pivot2;\n@@ -2870,1 +3070,1 @@\n-        return new int[] {lower, upper};\n+        return new int[] { lower, upper };\n@@ -2874,1 +3074,1 @@\n-     * Partitions the specified range of the array using a single pivot provided.\n+     * Partitions the specified range of the array using one given pivot.\n@@ -2876,1 +3076,1 @@\n-     * @param array the array to be partitioned\n+     * @param a the array for partitioning\n@@ -2879,3 +3079,3 @@\n-     * @param pivotIndex1 the index of pivot1, the first pivot\n-     * @param pivotIndex2 the index of pivot2, the second pivot\n-     *\n+     * @param pivotIndex1 the index of single pivot\n+     * @param pivotIndex2 the index of single pivot\n+     * @return indices of parts after partitioning\n@@ -2883,3 +3083,3 @@\n-    @ForceInline\n-    private static int[] partitionSinglePivot(float[] a, int low, int high, int pivotIndex1, int pivotIndex2) {\n-        int end = high - 1;\n+    private static int[] partitionWithOnePivot(\n+            float[] a, int low, int high, int pivotIndex1, int pivotIndex2) {\n+        int upper = high;\n@@ -2887,1 +3087,0 @@\n-        int upper = end;\n@@ -2889,2 +3088,5 @@\n-        int e3 = pivotIndex1;\n-        float pivot = a[e3];\n+        \/*\n+         * Use the third of the five sorted elements as the pivot.\n+         * This value is inexpensive approximation of the median.\n+         *\/\n+        float pivot = a[pivotIndex1];\n@@ -2899,1 +3101,1 @@\n-        a[e3] = a[lower];\n+        a[pivotIndex1] = a[lower];\n@@ -2902,1 +3104,1 @@\n-         * Traditional 3-way (Dutch National Flag) partitioning\n+         * Dutch National Flag partitioning\n@@ -2904,1 +3106,1 @@\n-         *   left part                 central part    right part\n+         *     left part               central part    right part\n@@ -2906,1 +3108,1 @@\n-         * |   < pivot   |     ?     |   == pivot   |   > pivot   |\n+         * |   < pivot    |    ?     |   == pivot   |   > pivot   |\n@@ -2908,9 +3110,3 @@\n-         *              ^           ^                ^\n-         *              |           |                |\n-         *            lower         k              upper\n-         *\n-         * Invariants:\n-         *\n-         *   all in (low, lower] < pivot\n-         *   all in (k, upper)  == pivot\n-         *   all in [upper, end] > pivot\n+         *               ^          ^                ^\n+         *               |          |                |\n+         *             lower        k              upper\n@@ -2919,0 +3115,2 @@\n+         * Pointer lower is the last index of left part\n+         * Pointer upper is the first index of right part\n@@ -2920,1 +3118,1 @@\n-        for (int k = ++upper; --k > lower; ) {\n+        for (int k = upper; --k > lower; ) {\n@@ -2926,1 +3124,1 @@\n-                if (ak < pivot) { \/\/ Move a[k] to the left side\n+                if (ak < pivot) { \/\/ Move a[k] to the left part\n@@ -2933,1 +3131,1 @@\n-                } else { \/\/ ak > pivot - Move a[k] to the right side\n+                } else { \/\/ ak > pivot - Move a[k] to the right part\n@@ -2943,1 +3141,2 @@\n-        return new int[] {lower, upper};\n+\n+        return new int[] { lower, upper };\n@@ -2949,2 +3148,2 @@\n-     * Mixed insertion sort is combination of simple insertion sort,\n-     * pin insertion sort and pair insertion sort.\n+     * Mixed insertion sort is combination of pin insertion sort,\n+     * simple insertion sort and pair insertion sort.\n@@ -2962,4 +3161,1 @@\n-    private static void mixedInsertionSort(float[] a, int low, int high) {\n-        int size = high - low;\n-        int end = high - 3 * ((size >> 5) << 3);\n-        if (end == high) {\n+    static void mixedInsertionSort(float[] a, int low, int high) {\n@@ -2967,4 +3163,10 @@\n-            \/*\n-             * Invoke simple insertion sort on tiny array.\n-             *\/\n-            for (int i; ++low < end; ) {\n+        \/*\n+         * Split part for pin and pair insertion sorts.\n+         *\/\n+        int end = high - 3 * ((high - low) >> 3 << 1);\n+\n+        \/*\n+         * Invoke simple insertion sort on small part.\n+         *\/\n+        if (end == high) {\n+            for (int i; ++low < high; ) {\n@@ -2973,2 +3175,2 @@\n-                while (ai < a[--i]) {\n-                    a[i + 1] = a[i];\n+                while (ai < a[i - 1]) {\n+                    a[i] = a[--i];\n@@ -2976,1 +3178,1 @@\n-                a[i + 1] = ai;\n+                a[i] = ai;\n@@ -2978,1 +3180,8 @@\n-        } else {\n+            return;\n+        }\n+\n+        \/*\n+         * Start with pin insertion sort.\n+         *\/\n+        for (int i, p = high; ++low < end; ) {\n+            float ai = a[i = low], pin = a[--p];\n@@ -2981,7 +3190,1 @@\n-             * Start with pin insertion sort on small part.\n-             *\n-             * Pin insertion sort is extended simple insertion sort.\n-             * The main idea of this sort is to put elements larger\n-             * than an element called pin to the end of array (the\n-             * proper area for such elements). It avoids expensive\n-             * movements of these elements through the whole array.\n+             * Swap larger element with pin.\n@@ -2989,40 +3192,3 @@\n-            float pin = a[end];\n-\n-            for (int i, p = high; ++low < end; ) {\n-                float ai = a[i = low];\n-\n-                if (ai < a[i - 1]) { \/\/ Small element\n-\n-                    \/*\n-                     * Insert small element into sorted part.\n-                     *\/\n-                    a[i] = a[--i];\n-\n-                    while (ai < a[--i]) {\n-                        a[i + 1] = a[i];\n-                    }\n-                    a[i + 1] = ai;\n-\n-                } else if (p > i && ai > pin) { \/\/ Large element\n-\n-                    \/*\n-                     * Find element smaller than pin.\n-                     *\/\n-                    while (a[--p] > pin);\n-\n-                    \/*\n-                     * Swap it with large element.\n-                     *\/\n-                    if (p > i) {\n-                        ai = a[p];\n-                        a[p] = a[i];\n-                    }\n-\n-                    \/*\n-                     * Insert small element into sorted part.\n-                     *\/\n-                    while (ai < a[--i]) {\n-                        a[i + 1] = a[i];\n-                    }\n-                    a[i + 1] = ai;\n-                }\n+            if (ai > pin) {\n+                ai = pin;\n+                a[p] = a[i];\n@@ -3032,1 +3198,1 @@\n-             * Continue with pair insertion sort on remain part.\n+             * Insert element into sorted part.\n@@ -3034,2 +3200,5 @@\n-            for (int i; low < high; ++low) {\n-                float a1 = a[i = low], a2 = a[++low];\n+            while (ai < a[i - 1]) {\n+                a[i] = a[--i];\n+            }\n+            a[i] = ai;\n+        }\n@@ -3037,6 +3206,5 @@\n-                \/*\n-                 * Insert two elements per iteration: at first, insert the\n-                 * larger element and then insert the smaller element, but\n-                 * from the position where the larger element was inserted.\n-                 *\/\n-                if (a1 > a2) {\n+        \/*\n+         * Finish with pair insertion sort.\n+         *\/\n+        for (int i; low < high; ++low) {\n+            float a1 = a[i = low], a2 = a[++low];\n@@ -3044,4 +3212,6 @@\n-                    while (a1 < a[--i]) {\n-                        a[i + 2] = a[i];\n-                    }\n-                    a[++i + 1] = a1;\n+            \/*\n+             * Insert two elements per iteration: at first, insert the\n+             * larger element and then insert the smaller element, but\n+             * from the position where the larger element was inserted.\n+             *\/\n+            if (a1 > a2) {\n@@ -3049,4 +3219,9 @@\n-                    while (a2 < a[--i]) {\n-                        a[i + 1] = a[i];\n-                    }\n-                    a[i + 1] = a2;\n+                while (a1 < a[--i]) {\n+                    a[i + 2] = a[i];\n+                }\n+                a[++i + 1] = a1;\n+\n+                while (a2 < a[--i]) {\n+                    a[i + 1] = a[i];\n+                }\n+                a[i + 1] = a2;\n@@ -3054,1 +3229,1 @@\n-                } else if (a1 < a[i - 1]) {\n+            } else if (a1 < a[i - 1]) {\n@@ -3056,4 +3231,4 @@\n-                    while (a2 < a[--i]) {\n-                        a[i + 2] = a[i];\n-                    }\n-                    a[++i + 1] = a2;\n+                while (a2 < a[--i]) {\n+                    a[i + 2] = a[i];\n+                }\n+                a[++i + 1] = a2;\n@@ -3061,4 +3236,2 @@\n-                    while (a1 < a[--i]) {\n-                        a[i + 1] = a[i];\n-                    }\n-                    a[i + 1] = a1;\n+                while (a1 < a[--i]) {\n+                    a[i + 1] = a[i];\n@@ -3066,0 +3239,1 @@\n+                a[i + 1] = a1;\n@@ -3077,1 +3251,1 @@\n-    private static void insertionSort(float[] a, int low, int high) {\n+    static void insertionSort(float[] a, int low, int high) {\n@@ -3082,38 +3256,3 @@\n-                while (--i >= low && ai < a[i]) {\n-                    a[i + 1] = a[i];\n-                }\n-                a[i + 1] = ai;\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Sorts the specified range of the array using heap sort.\n-     *\n-     * @param a the array to be sorted\n-     * @param low the index of the first element, inclusive, to be sorted\n-     * @param high the index of the last element, exclusive, to be sorted\n-     *\/\n-    private static void heapSort(float[] a, int low, int high) {\n-        for (int k = (low + high) >>> 1; k > low; ) {\n-            pushDown(a, --k, a[k], low, high);\n-        }\n-        while (--high > low) {\n-            float max = a[low];\n-            pushDown(a, low, a[high], low, high);\n-            a[high] = max;\n-        }\n-    }\n-\n-    \/**\n-     * Pushes specified element down during heap sort.\n-     *\n-     * @param a the given array\n-     * @param p the start index\n-     * @param value the given element\n-     * @param low the index of the first element, inclusive, to be sorted\n-     * @param high the index of the last element, exclusive, to be sorted\n-     *\/\n-    private static void pushDown(float[] a, int p, float value, int low, int high) {\n-        for (int k ;; a[p] = a[p = k]) {\n-            k = (p << 1) - low + 2; \/\/ Index of the right child\n+                do {\n+                    a[i] = a[--i];\n+                } while (i > low && ai < a[i - 1]);\n@@ -3121,8 +3260,1 @@\n-            if (k > high) {\n-                break;\n-            }\n-            if (k == high || a[k] < a[k - 1]) {\n-                --k;\n-            }\n-            if (a[k] <= value) {\n-                break;\n+                a[i ] = ai;\n@@ -3131,1 +3263,0 @@\n-        a[p] = value;\n@@ -3135,1 +3266,1 @@\n-     * Tries to sort the specified range of the array.\n+     * Tries to sort the specified range of the array using merging sort.\n@@ -3139,3 +3270,3 @@\n-     * @param low the index of the first element to be sorted\n-     * @param size the array size\n-     * @return true if finally sorted, false otherwise\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n+     * @return {@code true} if the array is finally sorted, otherwise {@code false}\n@@ -3143,1 +3274,1 @@\n-    private static boolean tryMergeRuns(Sorter sorter, float[] a, int low, int size) {\n+    static boolean tryMergingSort(Sorter<float[]> sorter, float[] a, int low, int high) {\n@@ -3146,3 +3277,2 @@\n-         * The run array is constructed only if initial runs are\n-         * long enough to continue, run[i] then holds start index\n-         * of the i-th sequence of elements in non-descending order.\n+         * The element run[i] holds the start index\n+         * of i-th sequence in non-descending order.\n@@ -3150,0 +3280,1 @@\n+        int count = 1;\n@@ -3151,2 +3282,0 @@\n-        int high = low + size;\n-        int count = 1, last = low;\n@@ -3157,1 +3286,1 @@\n-        for (int k = low + 1; k < high; ) {\n+        for (int k = low + 1, last = low; k < high; ) {\n@@ -3160,1 +3289,1 @@\n-             * Find the end index of the current run.\n+             * Find the next run.\n@@ -3185,1 +3314,8 @@\n-             * Check special cases.\n+             * Check if the runs are too long to continue scanning.\n+             *\/\n+            if (count > 6 && k - low < count * MIN_RUN_SIZE) {\n+                return false;\n+            }\n+\n+            \/*\n+             * Process the run.\n@@ -3188,1 +3324,0 @@\n-                if (k == high) {\n@@ -3190,0 +3325,1 @@\n+                if (k == high) {\n@@ -3191,1 +3327,1 @@\n-                     * The array is monotonous sequence,\n+                     * Array is monotonous sequence\n@@ -3197,10 +3333,1 @@\n-                if (k - low < MIN_FIRST_RUN_SIZE) {\n-\n-                    \/*\n-                     * The first run is too small\n-                     * to proceed with scanning.\n-                     *\/\n-                    return false;\n-                }\n-\n-                run = new int[((size >> 10) | 0x7F) & 0x3FF];\n+                run = new int[((high - low) >> 9) & 0x1FF | 0x3F];\n@@ -3209,12 +3336,1 @@\n-            } else if (a[last - 1] > a[last]) {\n-\n-                if (count > (k - low) >> MIN_FIRST_RUNS_FACTOR) {\n-\n-                    \/*\n-                     * The first runs are not long\n-                     * enough to continue scanning.\n-                     *\/\n-                    return false;\n-                }\n-\n-                if (++count == MAX_RUN_CAPACITY) {\n+            } else if (a[last - 1] > a[last]) { \/\/ Start the new run\n@@ -3222,0 +3338,1 @@\n+                if (++count == run.length) {\n@@ -3227,0 +3344,1 @@\n+            }\n@@ -3228,1 +3346,4 @@\n-                if (count == run.length) {\n+            \/*\n+             * Save the current run.\n+             *\/\n+            run[count] = (last = k);\n@@ -3230,5 +3351,5 @@\n-                    \/*\n-                     * Increase capacity of index array.\n-                     *\/\n-                    run = Arrays.copyOf(run, count << 1);\n-                }\n+            \/*\n+             * Check single-element run at the end.\n+             *\/\n+            if (++k == high) {\n+                --k;\n@@ -3236,1 +3357,0 @@\n-            run[count] = (last = k);\n@@ -3240,1 +3360,1 @@\n-         * Merge runs of highly structured array.\n+         * Merge all runs.\n@@ -3245,3 +3365,1 @@\n-            if (sorter == null || (b = (float[]) sorter.b) == null) {\n-                b = new float[size];\n-            } else {\n+            if (sorter != null && (b = sorter.b) != null) {\n@@ -3249,0 +3367,2 @@\n+            } else if ((b = tryAllocate(float[].class, high - low)) == null) {\n+                return false;\n@@ -3269,1 +3389,1 @@\n-            int aim, boolean parallel, int[] run, int lo, int hi) {\n+                                     int aim, boolean parallel, int[] run, int lo, int hi) {\n@@ -3275,3 +3395,1 @@\n-            for (int i = run[hi], j = i - offset, low = run[lo]; i > low;\n-                b[--j] = a[--i]\n-            );\n+            System.arraycopy(a, run[lo], b, run[lo] - offset, run[hi] - run[lo]);\n@@ -3288,1 +3406,1 @@\n-         * Merge the left and right parts.\n+         * Merge runs of each part.\n@@ -3290,11 +3408,2 @@\n-        float[] a1, a2;\n-\n-        if (parallel && hi - lo > MIN_RUN_COUNT) {\n-            RunMerger merger = new RunMerger(a, b, offset, 0, run, mi, hi).forkMe();\n-            a1 = mergeRuns(a, b, offset, -aim, true, run, lo, mi);\n-            a2 = (float[]) merger.getDestination();\n-        } else {\n-            a1 = mergeRuns(a, b, offset, -aim, false, run, lo, mi);\n-            a2 = mergeRuns(a, b, offset,    0, false, run, mi, hi);\n-        }\n-\n+        float[] a1 = mergeRuns(a, b, offset, -aim, parallel, run, lo, mi);\n+        float[] a2 = mergeRuns(a, b, offset,    0, parallel, run, mi, hi);\n@@ -3309,2 +3418,5 @@\n-        if (parallel) {\n-            new Merger(null, dst, k, a1, lo1, hi1, a2, lo2, hi2).invoke();\n+        \/*\n+         * Merge the left and right parts.\n+         *\/\n+        if (hi1 - lo1 > MIN_PARALLEL_SORT_SIZE && parallel) {\n+            new Merger<>(null, dst, k, a1, lo1, hi1, a2, lo2, hi2).invoke();\n@@ -3330,2 +3442,2 @@\n-    private static void mergeParts(Merger merger, float[] dst, int k,\n-            float[] a1, int lo1, int hi1, float[] a2, int lo2, int hi2) {\n+    private static void mergeParts(Merger<float[]> merger, float[] dst, int k,\n+                                   float[] a1, int lo1, int hi1, float[] a2, int lo2, int hi2) {\n@@ -3333,0 +3445,3 @@\n+        \/*\n+         * Merge sorted parts in parallel.\n+         *\/\n@@ -3345,0 +3460,8 @@\n+                \/*\n+                 * Terminate, if the second part is empty.\n+                 *\/\n+                if (lo2 == hi2) {\n+                    System.arraycopy(a1, lo1, dst, k, hi1 - lo1);\n+                    return;\n+                }\n+\n@@ -3348,1 +3471,1 @@\n-                if (hi1 - lo1 < MIN_PARALLEL_MERGE_PARTS_SIZE) {\n+                if (hi1 - lo1 < MIN_PARALLEL_SORT_SIZE) {\n@@ -3360,1 +3483,1 @@\n-                 * Partition the smaller part.\n+                 * Divide the smaller part.\n@@ -3362,2 +3485,2 @@\n-                for (int loo = lo2; loo < mi2; ) {\n-                    int t = (loo + mi2) >>> 1;\n+                for (int mi0 = lo2; mi0 < mi2; ) {\n+                    int m = (mi0 + mi2) >>> 1;\n@@ -3365,2 +3488,2 @@\n-                    if (key > a2[t]) {\n-                        loo = t + 1;\n+                    if (key > a2[m]) {\n+                        mi0 = m + 1;\n@@ -3368,1 +3491,1 @@\n-                        mi2 = t;\n+                        mi2 = m;\n@@ -3372,1 +3495,4 @@\n-                int d = mi2 - lo2 + mi1 - lo1;\n+                \/*\n+                 * Reserve space for the left parts.\n+                 *\/\n+                int space = mi2 - lo2 + mi1 - lo1;\n@@ -3375,1 +3501,1 @@\n-                 * Merge the right sub-parts in parallel.\n+                 * Merge other parts in parallel.\n@@ -3377,1 +3503,1 @@\n-                merger.forkMerger(dst, k + d, a1, mi1, hi1, a2, mi2, hi2);\n+                merger.fork(k + space, mi1, hi1, mi2, hi2);\n@@ -3380,1 +3506,1 @@\n-                 * Process the sub-left parts.\n+                 * Iterate along the left parts.\n@@ -3390,2 +3516,4 @@\n-        while (lo1 < hi1 && lo2 < hi2) {\n-            dst[k++] = a1[lo1] < a2[lo2] ? a1[lo1++] : a2[lo2++];\n+        if (lo2 < hi2 && a1[hi1 - 1] > a2[lo2]) {\n+            while (lo1 < hi1 && lo2 < hi2) {\n+                dst[k++] = a1[lo1] < a2[lo2] ? a1[lo1++] : a2[lo2++];\n+            }\n@@ -3405,1 +3533,148 @@\n-\/\/ [double]\n+    \/**\n+     * Tries to sort the specified range of the array\n+     * using LSD (The Least Significant Digit) Radix sort.\n+     *\n+     * @param a the array to be sorted\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n+     * @return {@code true} if the array is finally sorted, otherwise {@code false}\n+     *\/\n+    static boolean tryRadixSort(Sorter<float[]> sorter, float[] a, int low, int high) {\n+        float[] b; int offset = low, size = high - low;\n+\n+        \/*\n+         * Allocate additional buffer.\n+         *\/\n+        if (sorter != null && (b = sorter.b) != null) {\n+            offset = sorter.offset;\n+        } else if ((b = tryAllocate(float[].class, size)) == null) {\n+            return false;\n+        }\n+\n+        int start = low - offset;\n+        int last = high - offset;\n+\n+        \/*\n+         * Count the number of all digits.\n+         *\/\n+        int[] count1 = new int[1024];\n+        int[] count2 = new int[2048];\n+        int[] count3 = new int[2048];\n+\n+        for (int i = low; i < high; ++i) {\n+            ++count1[ fti(a[i])         & 0x3FF];\n+            ++count2[(fti(a[i]) >>> 10) & 0x7FF];\n+            ++count3[(fti(a[i]) >>> 21) & 0x7FF];\n+        }\n+\n+        \/*\n+         * Detect digits to be processed.\n+         *\/\n+        boolean processDigit1 = processDigit(count1, size, low);\n+        boolean processDigit2 = processDigit(count2, size, low);\n+        boolean processDigit3 = processDigit(count3, size, low);\n+\n+        \/*\n+         * Process the 1-st digit.\n+         *\/\n+        if (processDigit1) {\n+            for (int i = high; i > low; ) {\n+                b[--count1[fti(a[--i]) & 0x3FF] - offset] = a[i];\n+            }\n+        }\n+\n+        \/*\n+         * Process the 2-nd digit.\n+         *\/\n+        if (processDigit2) {\n+            if (processDigit1) {\n+                for (int i = last; i > start; ) {\n+                    a[--count2[(fti(b[--i]) >>> 10) & 0x7FF]] = b[i];\n+                }\n+            } else {\n+                for (int i = high; i > low; ) {\n+                    b[--count2[(fti(a[--i]) >>> 10) & 0x7FF] - offset] = a[i];\n+                }\n+            }\n+        }\n+\n+        \/*\n+         * Process the 3-rd digit.\n+         *\/\n+        if (processDigit3) {\n+            if (processDigit1 ^ processDigit2) {\n+                for (int i = last; i > start; ) {\n+                    a[--count3[(fti(b[--i]) >>> 21) & 0x7FF]] = b[i];\n+                }\n+            } else {\n+                for (int i = high; i > low; ) {\n+                    b[--count3[(fti(a[--i]) >>> 21) & 0x7FF] - offset] = a[i];\n+                }\n+            }\n+        }\n+\n+        \/*\n+         * Copy the buffer to original array, if we process ood number of digits.\n+         *\/\n+        if (processDigit1 ^ processDigit2 ^ processDigit3) {\n+            System.arraycopy(b, low - offset, a, low, size);\n+        }\n+        return true;\n+    }\n+\n+    \/**\n+     * Returns masked bits that represent the float value.\n+     *\n+     * @param f the given value\n+     * @return masked bits\n+     *\/\n+    private static int fti(float f) {\n+        int x = Float.floatToRawIntBits(f);\n+        return x ^ ((x >> 31) | 0x80000000);\n+    }\n+\n+    \/**\n+     * Sorts the specified range of the array using heap sort.\n+     *\n+     * @param a the array to be sorted\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n+     *\/\n+    static void heapSort(float[] a, int low, int high) {\n+        for (int k = (low + high) >>> 1; k > low; ) {\n+            pushDown(a, --k, a[k], low, high);\n+        }\n+        while (--high > low) {\n+            float max = a[low];\n+            pushDown(a, low, a[high], low, high);\n+            a[high] = max;\n+        }\n+    }\n+\n+    \/**\n+     * Pushes specified element down during heap sort.\n+     *\n+     * @param a the given array\n+     * @param p the start index\n+     * @param value the given element\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n+     *\/\n+    private static void pushDown(float[] a, int p, float value, int low, int high) {\n+        for (int k ;; a[p] = a[p = k]) {\n+            k = (p << 1) - low + 2; \/\/ Index of the right child\n+\n+            if (k > high) {\n+                break;\n+            }\n+            if (k == high || a[k] < a[k - 1]) {\n+                --k;\n+            }\n+            if (a[k] <= value) {\n+                break;\n+            }\n+        }\n+        a[p] = value;\n+    }\n+\n+\/\/ #[double]\n@@ -3446,6 +3721,2 @@\n-        int size = high - low;\n-\n-        if (parallelism > 1 && size > MIN_PARALLEL_SORT_SIZE) {\n-            int depth = getDepth(parallelism, size >> 12);\n-            double[] b = depth == 0 ? null : new double[size];\n-            new Sorter(null, a, b, low, size, low, depth).invoke();\n+        if (parallelism > 1 && high - low > MIN_PARALLEL_SORT_SIZE) {\n+            new Sorter<>(a, parallelism, low, high - low, 0).invoke();\n@@ -3487,2 +3758,1 @@\n-     * Sorts the specified array using the Dual-Pivot Quicksort and\/or\n-     * other sorts in special-cases, possibly with parallel partitions.\n+     * Sorts the specified range of the array using Dual-Pivot Quicksort.\n@@ -3493,1 +3763,1 @@\n-     *        the right bit \"0\" indicates that array is the leftmost part\n+     *        the right bit \"0\" indicates that range is the leftmost part\n@@ -3497,1 +3767,1 @@\n-    static void sort(Sorter sorter, double[] a, int bits, int low, int high) {\n+    static void sort(Sorter<double[]> sorter, double[] a, int bits, int low, int high) {\n@@ -3499,1 +3769,2 @@\n-            int end = high - 1, size = high - low;\n+            int size = high - low;\n+\n@@ -3501,1 +3772,1 @@\n-             * Run mixed insertion sort on small non-leftmost parts.\n+             * Run adaptive mixed insertion sort on small non-leftmost parts.\n@@ -3504,1 +3775,2 @@\n-                sort(double.class, a, Unsafe.ARRAY_DOUBLE_BASE_OFFSET, low, high, DualPivotQuicksort::mixedInsertionSort);\n+                sort(double.class, a, Unsafe.ARRAY_DOUBLE_BASE_OFFSET,\n+                        low, high, DualPivotQuicksort::mixedInsertionSort);\n@@ -3512,10 +3784,2 @@\n-                sort(double.class, a, Unsafe.ARRAY_DOUBLE_BASE_OFFSET, low, high, DualPivotQuicksort::insertionSort);\n-                return;\n-            }\n-\n-            \/*\n-             * Check if the whole array or large non-leftmost\n-             * parts are nearly sorted and then merge runs.\n-             *\/\n-            if ((bits == 0 || size > MIN_TRY_MERGE_SIZE && (bits & 1) > 0)\n-                    && tryMergeRuns(sorter, a, low, size)) {\n+                sort(double.class, a, Unsafe.ARRAY_DOUBLE_BASE_OFFSET,\n+                        low, high, DualPivotQuicksort::insertionSort);\n@@ -3526,2 +3790,1 @@\n-             * Switch to heap sort if execution\n-             * time is becoming quadratic.\n+             * Try merging sort on large part.\n@@ -3529,2 +3792,2 @@\n-            if ((bits += DELTA) > MAX_RECURSION_DEPTH) {\n-                heapSort(a, low, high);\n+            if (size > MIN_MERGING_SORT_SIZE * bits\n+                    && tryMergingSort(sorter, a, low, high)) {\n@@ -3535,2 +3798,3 @@\n-             * Use an inexpensive approximation of the golden ratio\n-             * to select five sample elements and determine pivots.\n+             * Divide the given array into the golden ratio using\n+             * an inexpensive approximation to select five sample\n+             * elements and determine pivots.\n@@ -3538,1 +3802,1 @@\n-            int step = (size >> 3) * 3 + 3;\n+            int step = (size >> 2) + (size >> 3) + (size >> 7);\n@@ -3547,1 +3811,1 @@\n-            int e5 = end - step;\n+            int e5 = high - step;\n@@ -3554,1 +3818,10 @@\n-             * Sort these elements in place by the combination\n+             * Check if part is large and contains random\n+             * data, taking into account parallel context.\n+             *\/\n+            boolean isLargeRandom =\n+                    sorter != null && bits > 2 && size > MIN_RADIX_SORT_SIZE &&\n+\/\/              size > MIN_RADIX_SORT_SIZE && (sorter == null || bits > 0) &&\n+                            (a[e1] > a[e2] || a[e2] > a3 || a3 > a[e4] || a[e4] > a[e5]);\n+\n+            \/*\n+             * Sort these elements in-place by the combination\n@@ -3557,7 +3830,7 @@\n-             *    5 ------o-----------o------------\n-             *            |           |\n-             *    4 ------|-----o-----o-----o------\n-             *            |     |           |\n-             *    2 ------o-----|-----o-----o------\n-             *                  |     |\n-             *    1 ------------o-----o------------\n+             *   1 ---------o---------------o-----------------\n+             *              |               |\n+             *   2 ---------|-------o-------o-------o---------\n+             *              |       |               |\n+             *   4 ---------o-------|-------o-------o---------\n+             *                      |       |\n+             *   5 -----------------o-------o-----------------\n@@ -3565,5 +3838,5 @@\n-            if (a[e5] < a[e2]) { double t = a[e5]; a[e5] = a[e2]; a[e2] = t; }\n-            if (a[e4] < a[e1]) { double t = a[e4]; a[e4] = a[e1]; a[e1] = t; }\n-            if (a[e5] < a[e4]) { double t = a[e5]; a[e5] = a[e4]; a[e4] = t; }\n-            if (a[e2] < a[e1]) { double t = a[e2]; a[e2] = a[e1]; a[e1] = t; }\n-            if (a[e4] < a[e2]) { double t = a[e4]; a[e4] = a[e2]; a[e2] = t; }\n+            if (a[e1] > a[e4]) { double t = a[e1]; a[e1] = a[e4]; a[e4] = t; }\n+            if (a[e2] > a[e5]) { double t = a[e2]; a[e2] = a[e5]; a[e5] = t; }\n+            if (a[e4] > a[e5]) { double t = a[e4]; a[e4] = a[e5]; a[e5] = t; }\n+            if (a[e1] > a[e2]) { double t = a[e1]; a[e1] = a[e2]; a[e2] = t; }\n+            if (a[e2] > a[e4]) { double t = a[e2]; a[e2] = a[e4]; a[e4] = t; }\n@@ -3571,0 +3844,3 @@\n+            \/*\n+             * Insert the third element.\n+             *\/\n@@ -3585,3 +3861,22 @@\n-            \/\/ Pointers\n-            int lower; \/\/ The index of the last element of the left part\n-            int upper; \/\/ The index of the first element of the right part\n+            \/*\n+             * Try Radix sort on large fully random data.\n+             *\/\n+            if (isLargeRandom\n+                    && a[e2] < a[e3] && a[e3] < a[e4]\n+                    && tryRadixSort(sorter, a, low, high)) {\n+                return;\n+            }\n+\n+            \/*\n+             * Switch to heap sort, if execution time is quadratic.\n+             *\/\n+            if ((bits += 2) > MAX_RECURSION_DEPTH) {\n+                heapSort(a, low, high);\n+                return;\n+            }\n+\n+            \/*\n+             * indices[0] - the index of the last element of the left part\n+             * indices[1] - the index of the first element of the right part\n+             *\/\n+            int[] indices;\n@@ -3590,1 +3885,1 @@\n-             * Partitioning with 2 pivots in case of different elements.\n+             * Partitioning with two pivots on array of fully random elements.\n@@ -3594,8 +3889,3 @@\n-                \/*\n-                * Use the first and fifth of the five sorted elements as\n-                * the pivots. These values are inexpensive approximation\n-                * of tertiles. Note, that pivot1 < pivot2.\n-                *\/\n-                int[] pivotIndices = partition(double.class, a, Unsafe.ARRAY_DOUBLE_BASE_OFFSET, low, high, e1, e5, DualPivotQuicksort::partitionDualPivot);\n-                lower = pivotIndices[0];\n-                upper = pivotIndices[1];\n+                indices = partition(double.class, a, Unsafe.ARRAY_DOUBLE_BASE_OFFSET,\n+                        low, high, e1, e5, DualPivotQuicksort::partitionWithTwoPivots);\n+\n@@ -3607,2 +3897,2 @@\n-                    sorter.forkSorter(bits | 1, lower + 1, upper);\n-                    sorter.forkSorter(bits | 1, upper + 1, high);\n+                    sorter.fork(bits | 1, indices[0] + 1, indices[1]);\n+                    sorter.fork(bits | 1, indices[1] + 1, high);\n@@ -3610,2 +3900,2 @@\n-                    sort(sorter, a, bits | 1, lower + 1, upper);\n-                    sort(sorter, a, bits | 1, upper + 1, high);\n+                    sort(sorter, a, bits | 1, indices[0] + 1, indices[1]);\n+                    sort(sorter, a, bits | 1, indices[1] + 1, high);\n@@ -3614,1 +3904,1 @@\n-            } else { \/\/ Use single pivot in case of many equal elements\n+            } else { \/\/ Partitioning with one pivot\n@@ -3616,7 +3906,2 @@\n-                \/*\n-                 * Use the third of the five sorted elements as the pivot.\n-                 * This value is inexpensive approximation of the median.\n-                 *\/\n-                int[] pivotIndices = partition(double.class, a, Unsafe.ARRAY_DOUBLE_BASE_OFFSET, low, high, e3, e3, DualPivotQuicksort::partitionSinglePivot);\n-                lower = pivotIndices[0];\n-                upper = pivotIndices[1];\n+                indices = partition(double.class, a, Unsafe.ARRAY_DOUBLE_BASE_OFFSET,\n+                        low, high, e3, e3, DualPivotQuicksort::partitionWithOnePivot);\n@@ -3630,1 +3915,1 @@\n-                    sorter.forkSorter(bits | 1, upper, high);\n+                    sorter.fork(bits | 1, indices[1], high);\n@@ -3632,1 +3917,1 @@\n-                    sort(sorter, a, bits | 1, upper, high);\n+                    sort(sorter, a, bits | 1, indices[1], high);\n@@ -3635,1 +3920,1 @@\n-            high = lower; \/\/ Iterate along the left part\n+            high = indices[0]; \/\/ Iterate along the left part\n@@ -3640,1 +3925,1 @@\n-     * Partitions the specified range of the array using the two pivots provided.\n+     * Partitions the specified range of the array using two given pivots.\n@@ -3642,1 +3927,1 @@\n-     * @param array the array to be partitioned\n+     * @param a the array for partitioning\n@@ -3647,1 +3932,1 @@\n-     *\n+     * @return indices of parts after partitioning\n@@ -3649,3 +3934,3 @@\n-    @ForceInline\n-    private static int[] partitionDualPivot(double[] a, int low, int high, int pivotIndex1, int pivotIndex2) {\n-        int end = high - 1;\n+    private static int[] partitionWithTwoPivots(\n+            double[] a, int low, int high, int pivotIndex1, int pivotIndex2) {\n+        int upper = --high;\n@@ -3653,1 +3938,0 @@\n-        int upper = end;\n@@ -3655,4 +3939,7 @@\n-        int e1 = pivotIndex1;\n-        int e5 = pivotIndex2;\n-        double pivot1 = a[e1];\n-        double pivot2 = a[e5];\n+        \/*\n+         * Use the first and fifth of the five sorted elements as\n+         * the pivots. These values are inexpensive approximation\n+         * of tertiles. Note, that pivot1 < pivot2.\n+         *\/\n+        double pivot1 = a[pivotIndex1];\n+        double pivot2 = a[pivotIndex2];\n@@ -3661,8 +3948,8 @@\n-        * The first and the last elements to be sorted are moved\n-        * to the locations formerly occupied by the pivots. When\n-        * partitioning is completed, the pivots are swapped back\n-        * into their final positions, and excluded from the next\n-        * subsequent sorting.\n-        *\/\n-        a[e1] = a[lower];\n-        a[e5] = a[upper];\n+         * The first and the last elements to be sorted are moved\n+         * to the locations formerly occupied by the pivots. When\n+         * partitioning is completed, the pivots are swapped back\n+         * into their final positions, and excluded from the next\n+         * subsequent sorting.\n+         *\/\n+        a[pivotIndex1] = a[lower];\n+        a[pivotIndex2] = a[upper];\n@@ -3671,2 +3958,2 @@\n-        * Skip elements, which are less or greater than the pivots.\n-        *\/\n+         * Skip elements, which are less or greater than the pivots.\n+         *\/\n@@ -3679,13 +3966,7 @@\n-         *   left part                 central part          right part\n-         * +------------------------------------------------------------+\n-                  * |  < pivot1  |   ?   |  pivot1 <= && <= pivot2  |  > pivot2  |\n-         * +------------------------------------------------------------+\n-         *             ^       ^                            ^\n-         *             |       |                            |\n-         *           lower     k                          upper\n-         *\n-         * Invariants:\n-         *\n-         *              all in (low, lower] < pivot1\n-         *    pivot1 <= all in (k, upper)  <= pivot2\n-         *              all in [upper, end) > pivot2\n+         *     left part                     central part          right part\n+         * +-------------------------------------------------------------------+\n+         * |   < pivot1   |    ?     |  pivot1 <= .. <= pivot2  |   > pivot2   |\n+         * +-------------------------------------------------------------------+\n+         *               ^          ^                            ^\n+         *               |          |                            |\n+         *             lower        k                          upper\n@@ -3694,0 +3975,2 @@\n+         * Pointer lower is the last index of left part\n+         * Pointer upper is the first index of right part\n@@ -3698,10 +3981,3 @@\n-            if (ak < pivot1) { \/\/ Move a[k] to the left side\n-                while (lower < k) {\n-                    if (a[++lower] >= pivot1) {\n-                        if (a[lower] > pivot2) {\n-                            a[k] = a[--upper];\n-                            a[upper] = a[lower];\n-                        } else {\n-                            a[k] = a[lower];\n-                        }\n-                        a[lower] = ak;\n+            if (ak < pivot1) { \/\/ Move a[k] to the left part\n+                while (a[++lower] < pivot1) {\n+                    if (lower == k) {\n@@ -3711,1 +3987,8 @@\n-            } else if (ak > pivot2) { \/\/ Move a[k] to the right side\n+                if (a[lower] > pivot2) {\n+                    a[k] = a[--upper];\n+                    a[upper] = a[lower];\n+                } else {\n+                    a[k] = a[lower];\n+                }\n+                a[lower] = ak;\n+            } else if (ak > pivot2) { \/\/ Move a[k] to the right part\n@@ -3720,2 +4003,2 @@\n-        a[low] = a[lower]; a[lower] = pivot1;\n-        a[end] = a[upper]; a[upper] = pivot2;\n+        a[low]  = a[lower]; a[lower] = pivot1;\n+        a[high] = a[upper]; a[upper] = pivot2;\n@@ -3723,1 +4006,1 @@\n-        return new int[] {lower, upper};\n+        return new int[] { lower, upper };\n@@ -3727,1 +4010,1 @@\n-     * Partitions the specified range of the array using a single pivot provided.\n+     * Partitions the specified range of the array using one given pivot.\n@@ -3729,1 +4012,1 @@\n-     * @param array the array to be partitioned\n+     * @param a the array for partitioning\n@@ -3732,2 +4015,3 @@\n-     * @param pivotIndex1 the index of pivot1, the first pivot\n-     * @param pivotIndex2 the index of pivot2, the second pivot\n+     * @param pivotIndex1 the index of single pivot\n+     * @param pivotIndex2 the index of single pivot\n+     * @return indices of parts after partitioning\n@@ -3735,4 +4019,3 @@\n-    @ForceInline\n-    private static int[] partitionSinglePivot(double[] a, int low, int high, int pivotIndex1, int pivotIndex2) {\n-\n-        int end = high - 1;\n+    private static int[] partitionWithOnePivot(\n+            double[] a, int low, int high, int pivotIndex1, int pivotIndex2) {\n+        int upper = high;\n@@ -3740,1 +4023,0 @@\n-        int upper = end;\n@@ -3742,2 +4024,5 @@\n-        int e3 = pivotIndex1;\n-        double pivot = a[e3];\n+        \/*\n+         * Use the third of the five sorted elements as the pivot.\n+         * This value is inexpensive approximation of the median.\n+         *\/\n+        double pivot = a[pivotIndex1];\n@@ -3746,7 +4031,7 @@\n-        * The first element to be sorted is moved to the\n-        * location formerly occupied by the pivot. After\n-        * completion of partitioning the pivot is swapped\n-        * back into its final position, and excluded from\n-        * the next subsequent sorting.\n-        *\/\n-        a[e3] = a[lower];\n+         * The first element to be sorted is moved to the\n+         * location formerly occupied by the pivot. After\n+         * completion of partitioning the pivot is swapped\n+         * back into its final position, and excluded from\n+         * the next subsequent sorting.\n+         *\/\n+        a[pivotIndex1] = a[lower];\n@@ -3755,1 +4040,1 @@\n-         * Traditional 3-way (Dutch National Flag) partitioning\n+         * Dutch National Flag partitioning\n@@ -3757,1 +4042,1 @@\n-         *   left part                 central part    right part\n+         *     left part               central part    right part\n@@ -3759,1 +4044,1 @@\n-         * |   < pivot   |     ?     |   == pivot   |   > pivot   |\n+         * |   < pivot    |    ?     |   == pivot   |   > pivot   |\n@@ -3761,9 +4046,3 @@\n-         *              ^           ^                ^\n-         *              |           |                |\n-         *            lower         k              upper\n-         *\n-         * Invariants:\n-         *\n-         *   all in (low, lower] < pivot\n-         *   all in (k, upper)  == pivot\n-         *   all in [upper, end] > pivot\n+         *               ^          ^                ^\n+         *               |          |                |\n+         *             lower        k              upper\n@@ -3772,0 +4051,2 @@\n+         * Pointer lower is the last index of left part\n+         * Pointer upper is the first index of right part\n@@ -3773,1 +4054,1 @@\n-        for (int k = ++upper; --k > lower; ) {\n+        for (int k = upper; --k > lower; ) {\n@@ -3779,1 +4060,1 @@\n-                if (ak < pivot) { \/\/ Move a[k] to the left side\n+                if (ak < pivot) { \/\/ Move a[k] to the left part\n@@ -3786,1 +4067,1 @@\n-                } else { \/\/ ak > pivot - Move a[k] to the right side\n+                } else { \/\/ ak > pivot - Move a[k] to the right part\n@@ -3796,1 +4077,2 @@\n-        return new int[] {lower, upper};\n+\n+        return new int[] { lower, upper };\n@@ -3802,2 +4084,2 @@\n-     * Mixed insertion sort is combination of simple insertion sort,\n-     * pin insertion sort and pair insertion sort.\n+     * Mixed insertion sort is combination of pin insertion sort,\n+     * simple insertion sort and pair insertion sort.\n@@ -3815,4 +4097,1 @@\n-    private static void mixedInsertionSort(double[] a, int low, int high) {\n-        int size = high - low;\n-        int end = high - 3 * ((size >> 5) << 3);\n-        if (end == high) {\n+    static void mixedInsertionSort(double[] a, int low, int high) {\n@@ -3820,4 +4099,10 @@\n-            \/*\n-             * Invoke simple insertion sort on tiny array.\n-             *\/\n-            for (int i; ++low < end; ) {\n+        \/*\n+         * Split part for pin and pair insertion sorts.\n+         *\/\n+        int end = high - 3 * ((high - low) >> 3 << 1);\n+\n+        \/*\n+         * Invoke simple insertion sort on small part.\n+         *\/\n+        if (end == high) {\n+            for (int i; ++low < high; ) {\n@@ -3826,2 +4111,2 @@\n-                while (ai < a[--i]) {\n-                    a[i + 1] = a[i];\n+                while (ai < a[i - 1]) {\n+                    a[i] = a[--i];\n@@ -3829,1 +4114,1 @@\n-                a[i + 1] = ai;\n+                a[i] = ai;\n@@ -3831,1 +4116,8 @@\n-        } else {\n+            return;\n+        }\n+\n+        \/*\n+         * Start with pin insertion sort.\n+         *\/\n+        for (int i, p = high; ++low < end; ) {\n+            double ai = a[i = low], pin = a[--p];\n@@ -3834,7 +4126,1 @@\n-             * Start with pin insertion sort on small part.\n-             *\n-             * Pin insertion sort is extended simple insertion sort.\n-             * The main idea of this sort is to put elements larger\n-             * than an element called pin to the end of array (the\n-             * proper area for such elements). It avoids expensive\n-             * movements of these elements through the whole array.\n+             * Swap larger element with pin.\n@@ -3842,31 +4128,4 @@\n-            double pin = a[end];\n-\n-            for (int i, p = high; ++low < end; ) {\n-                double ai = a[i = low];\n-\n-                if (ai < a[i - 1]) { \/\/ Small element\n-\n-                    \/*\n-                     * Insert small element into sorted part.\n-                     *\/\n-                    a[i] = a[--i];\n-\n-                    while (ai < a[--i]) {\n-                        a[i + 1] = a[i];\n-                    }\n-                    a[i + 1] = ai;\n-\n-                } else if (p > i && ai > pin) { \/\/ Large element\n-\n-                    \/*\n-                     * Find element smaller than pin.\n-                     *\/\n-                    while (a[--p] > pin);\n-\n-                    \/*\n-                     * Swap it with large element.\n-                     *\/\n-                    if (p > i) {\n-                        ai = a[p];\n-                        a[p] = a[i];\n-                    }\n+            if (ai > pin) {\n+                ai = pin;\n+                a[p] = a[i];\n+            }\n@@ -3874,8 +4133,5 @@\n-                    \/*\n-                     * Insert small element into sorted part.\n-                     *\/\n-                    while (ai < a[--i]) {\n-                        a[i + 1] = a[i];\n-                    }\n-                    a[i + 1] = ai;\n-                }\n+            \/*\n+             * Insert element into sorted part.\n+             *\/\n+            while (ai < a[i - 1]) {\n+                a[i] = a[--i];\n@@ -3883,0 +4139,8 @@\n+            a[i] = ai;\n+        }\n+\n+        \/*\n+         * Finish with pair insertion sort.\n+         *\/\n+        for (int i; low < high; ++low) {\n+            double a1 = a[i = low], a2 = a[++low];\n@@ -3885,1 +4149,3 @@\n-             * Continue with pair insertion sort on remain part.\n+             * Insert two elements per iteration: at first, insert the\n+             * larger element and then insert the smaller element, but\n+             * from the position where the larger element was inserted.\n@@ -3887,9 +4153,1 @@\n-            for (int i; low < high; ++low) {\n-                double a1 = a[i = low], a2 = a[++low];\n-\n-                \/*\n-                 * Insert two elements per iteration: at first, insert the\n-                 * larger element and then insert the smaller element, but\n-                 * from the position where the larger element was inserted.\n-                 *\/\n-                if (a1 > a2) {\n+            if (a1 > a2) {\n@@ -3897,4 +4155,4 @@\n-                    while (a1 < a[--i]) {\n-                        a[i + 2] = a[i];\n-                    }\n-                    a[++i + 1] = a1;\n+                while (a1 < a[--i]) {\n+                    a[i + 2] = a[i];\n+                }\n+                a[++i + 1] = a1;\n@@ -3902,4 +4160,4 @@\n-                    while (a2 < a[--i]) {\n-                        a[i + 1] = a[i];\n-                    }\n-                    a[i + 1] = a2;\n+                while (a2 < a[--i]) {\n+                    a[i + 1] = a[i];\n+                }\n+                a[i + 1] = a2;\n@@ -3907,1 +4165,1 @@\n-                } else if (a1 < a[i - 1]) {\n+            } else if (a1 < a[i - 1]) {\n@@ -3909,4 +4167,4 @@\n-                    while (a2 < a[--i]) {\n-                        a[i + 2] = a[i];\n-                    }\n-                    a[++i + 1] = a2;\n+                while (a2 < a[--i]) {\n+                    a[i + 2] = a[i];\n+                }\n+                a[++i + 1] = a2;\n@@ -3914,4 +4172,2 @@\n-                    while (a1 < a[--i]) {\n-                        a[i + 1] = a[i];\n-                    }\n-                    a[i + 1] = a1;\n+                while (a1 < a[--i]) {\n+                    a[i + 1] = a[i];\n@@ -3919,0 +4175,1 @@\n+                a[i + 1] = a1;\n@@ -3930,1 +4187,1 @@\n-    private static void insertionSort(double[] a, int low, int high) {\n+    static void insertionSort(double[] a, int low, int high) {\n@@ -3935,38 +4192,3 @@\n-                while (--i >= low && ai < a[i]) {\n-                    a[i + 1] = a[i];\n-                }\n-                a[i + 1] = ai;\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Sorts the specified range of the array using heap sort.\n-     *\n-     * @param a the array to be sorted\n-     * @param low the index of the first element, inclusive, to be sorted\n-     * @param high the index of the last element, exclusive, to be sorted\n-     *\/\n-    private static void heapSort(double[] a, int low, int high) {\n-        for (int k = (low + high) >>> 1; k > low; ) {\n-            pushDown(a, --k, a[k], low, high);\n-        }\n-        while (--high > low) {\n-            double max = a[low];\n-            pushDown(a, low, a[high], low, high);\n-            a[high] = max;\n-        }\n-    }\n-\n-    \/**\n-     * Pushes specified element down during heap sort.\n-     *\n-     * @param a the given array\n-     * @param p the start index\n-     * @param value the given element\n-     * @param low the index of the first element, inclusive, to be sorted\n-     * @param high the index of the last element, exclusive, to be sorted\n-     *\/\n-    private static void pushDown(double[] a, int p, double value, int low, int high) {\n-        for (int k ;; a[p] = a[p = k]) {\n-            k = (p << 1) - low + 2; \/\/ Index of the right child\n+                do {\n+                    a[i] = a[--i];\n+                } while (i > low && ai < a[i - 1]);\n@@ -3974,8 +4196,1 @@\n-            if (k > high) {\n-                break;\n-            }\n-            if (k == high || a[k] < a[k - 1]) {\n-                --k;\n-            }\n-            if (a[k] <= value) {\n-                break;\n+                a[i ] = ai;\n@@ -3984,1 +4199,0 @@\n-        a[p] = value;\n@@ -3988,1 +4202,1 @@\n-     * Tries to sort the specified range of the array.\n+     * Tries to sort the specified range of the array using merging sort.\n@@ -3992,3 +4206,3 @@\n-     * @param low the index of the first element to be sorted\n-     * @param size the array size\n-     * @return true if finally sorted, false otherwise\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n+     * @return {@code true} if the array is finally sorted, otherwise {@code false}\n@@ -3996,1 +4210,1 @@\n-    private static boolean tryMergeRuns(Sorter sorter, double[] a, int low, int size) {\n+    static boolean tryMergingSort(Sorter<double[]> sorter, double[] a, int low, int high) {\n@@ -3999,3 +4213,2 @@\n-         * The run array is constructed only if initial runs are\n-         * long enough to continue, run[i] then holds start index\n-         * of the i-th sequence of elements in non-descending order.\n+         * The element run[i] holds the start index\n+         * of i-th sequence in non-descending order.\n@@ -4003,0 +4216,1 @@\n+        int count = 1;\n@@ -4004,2 +4218,0 @@\n-        int high = low + size;\n-        int count = 1, last = low;\n@@ -4010,1 +4222,1 @@\n-        for (int k = low + 1; k < high; ) {\n+        for (int k = low + 1, last = low; k < high; ) {\n@@ -4013,1 +4225,1 @@\n-             * Find the end index of the current run.\n+             * Find the next run.\n@@ -4038,1 +4250,8 @@\n-             * Check special cases.\n+             * Check if the runs are too long to continue scanning.\n+             *\/\n+            if (count > 6 && k - low < count * MIN_RUN_SIZE) {\n+                return false;\n+            }\n+\n+            \/*\n+             * Process the run.\n@@ -4041,1 +4260,0 @@\n-                if (k == high) {\n@@ -4043,0 +4261,1 @@\n+                if (k == high) {\n@@ -4044,1 +4263,1 @@\n-                     * The array is monotonous sequence,\n+                     * Array is monotonous sequence\n@@ -4050,10 +4269,1 @@\n-                if (k - low < MIN_FIRST_RUN_SIZE) {\n-\n-                    \/*\n-                     * The first run is too small\n-                     * to proceed with scanning.\n-                     *\/\n-                    return false;\n-                }\n-\n-                run = new int[((size >> 10) | 0x7F) & 0x3FF];\n+                run = new int[((high - low) >> 9) & 0x1FF | 0x3F];\n@@ -4062,12 +4272,1 @@\n-            } else if (a[last - 1] > a[last]) {\n-\n-                if (count > (k - low) >> MIN_FIRST_RUNS_FACTOR) {\n-\n-                    \/*\n-                     * The first runs are not long\n-                     * enough to continue scanning.\n-                     *\/\n-                    return false;\n-                }\n-\n-                if (++count == MAX_RUN_CAPACITY) {\n+            } else if (a[last - 1] > a[last]) { \/\/ Start the new run\n@@ -4075,0 +4274,1 @@\n+                if (++count == run.length) {\n@@ -4080,0 +4280,1 @@\n+            }\n@@ -4081,1 +4282,4 @@\n-                if (count == run.length) {\n+            \/*\n+             * Save the current run.\n+             *\/\n+            run[count] = (last = k);\n@@ -4083,5 +4287,5 @@\n-                    \/*\n-                     * Increase capacity of index array.\n-                     *\/\n-                    run = Arrays.copyOf(run, count << 1);\n-                }\n+            \/*\n+             * Check single-element run at the end.\n+             *\/\n+            if (++k == high) {\n+                --k;\n@@ -4089,1 +4293,0 @@\n-            run[count] = (last = k);\n@@ -4093,1 +4296,1 @@\n-         * Merge runs of highly structured array.\n+         * Merge all runs.\n@@ -4098,3 +4301,1 @@\n-            if (sorter == null || (b = (double[]) sorter.b) == null) {\n-                b = new double[size];\n-            } else {\n+            if (sorter != null && (b = sorter.b) != null) {\n@@ -4102,0 +4303,2 @@\n+            } else if ((b = tryAllocate(double[].class, high - low)) == null) {\n+                return false;\n@@ -4122,1 +4325,1 @@\n-            int aim, boolean parallel, int[] run, int lo, int hi) {\n+                                      int aim, boolean parallel, int[] run, int lo, int hi) {\n@@ -4128,3 +4331,1 @@\n-            for (int i = run[hi], j = i - offset, low = run[lo]; i > low;\n-                b[--j] = a[--i]\n-            );\n+            System.arraycopy(a, run[lo], b, run[lo] - offset, run[hi] - run[lo]);\n@@ -4141,1 +4342,1 @@\n-         * Merge the left and right parts.\n+         * Merge runs of each part.\n@@ -4143,11 +4344,2 @@\n-        double[] a1, a2;\n-\n-        if (parallel && hi - lo > MIN_RUN_COUNT) {\n-            RunMerger merger = new RunMerger(a, b, offset, 0, run, mi, hi).forkMe();\n-            a1 = mergeRuns(a, b, offset, -aim, true, run, lo, mi);\n-            a2 = (double[]) merger.getDestination();\n-        } else {\n-            a1 = mergeRuns(a, b, offset, -aim, false, run, lo, mi);\n-            a2 = mergeRuns(a, b, offset,    0, false, run, mi, hi);\n-        }\n-\n+        double[] a1 = mergeRuns(a, b, offset, -aim, parallel, run, lo, mi);\n+        double[] a2 = mergeRuns(a, b, offset,    0, parallel, run, mi, hi);\n@@ -4162,2 +4354,5 @@\n-        if (parallel) {\n-            new Merger(null, dst, k, a1, lo1, hi1, a2, lo2, hi2).invoke();\n+        \/*\n+         * Merge the left and right parts.\n+         *\/\n+        if (hi1 - lo1 > MIN_PARALLEL_SORT_SIZE && parallel) {\n+            new Merger<>(null, dst, k, a1, lo1, hi1, a2, lo2, hi2).invoke();\n@@ -4183,2 +4378,2 @@\n-    private static void mergeParts(Merger merger, double[] dst, int k,\n-            double[] a1, int lo1, int hi1, double[] a2, int lo2, int hi2) {\n+    private static void mergeParts(Merger<double[]> merger, double[] dst, int k,\n+                                   double[] a1, int lo1, int hi1, double[] a2, int lo2, int hi2) {\n@@ -4186,0 +4381,3 @@\n+        \/*\n+         * Merge sorted parts in parallel.\n+         *\/\n@@ -4198,0 +4396,8 @@\n+                \/*\n+                 * Terminate, if the second part is empty.\n+                 *\/\n+                if (lo2 == hi2) {\n+                    System.arraycopy(a1, lo1, dst, k, hi1 - lo1);\n+                    return;\n+                }\n+\n@@ -4201,1 +4407,1 @@\n-                if (hi1 - lo1 < MIN_PARALLEL_MERGE_PARTS_SIZE) {\n+                if (hi1 - lo1 < MIN_PARALLEL_SORT_SIZE) {\n@@ -4213,1 +4419,1 @@\n-                 * Partition the smaller part.\n+                 * Divide the smaller part.\n@@ -4215,2 +4421,2 @@\n-                for (int loo = lo2; loo < mi2; ) {\n-                    int t = (loo + mi2) >>> 1;\n+                for (int mi0 = lo2; mi0 < mi2; ) {\n+                    int m = (mi0 + mi2) >>> 1;\n@@ -4218,2 +4424,2 @@\n-                    if (key > a2[t]) {\n-                        loo = t + 1;\n+                    if (key > a2[m]) {\n+                        mi0 = m + 1;\n@@ -4221,1 +4427,1 @@\n-                        mi2 = t;\n+                        mi2 = m;\n@@ -4225,1 +4431,4 @@\n-                int d = mi2 - lo2 + mi1 - lo1;\n+                \/*\n+                 * Reserve space for the left parts.\n+                 *\/\n+                int space = mi2 - lo2 + mi1 - lo1;\n@@ -4228,1 +4437,1 @@\n-                 * Merge the right sub-parts in parallel.\n+                 * Merge other parts in parallel.\n@@ -4230,1 +4439,1 @@\n-                merger.forkMerger(dst, k + d, a1, mi1, hi1, a2, mi2, hi2);\n+                merger.fork(k + space, mi1, hi1, mi2, hi2);\n@@ -4233,1 +4442,1 @@\n-                 * Process the sub-left parts.\n+                 * Iterate along the left parts.\n@@ -4243,2 +4452,4 @@\n-        while (lo1 < hi1 && lo2 < hi2) {\n-            dst[k++] = a1[lo1] < a2[lo2] ? a1[lo1++] : a2[lo2++];\n+        if (lo2 < hi2 && a1[hi1 - 1] > a2[lo2]) {\n+            while (lo1 < hi1 && lo2 < hi2) {\n+                dst[k++] = a1[lo1] < a2[lo2] ? a1[lo1++] : a2[lo2++];\n+            }\n@@ -4258,1 +4469,202 @@\n-\/\/ [class]\n+    \/**\n+     * Tries to sort the specified range of the array\n+     * using LSD (The Least Significant Digit) Radix sort.\n+     *\n+     * @param a the array to be sorted\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n+     * @return {@code true} if the array is finally sorted, otherwise {@code false}\n+     *\/\n+    static boolean tryRadixSort(Sorter<double[]> sorter, double[] a, int low, int high) {\n+        double[] b; int offset = low, size = high - low;\n+\n+        \/*\n+         * Allocate additional buffer.\n+         *\/\n+        if (sorter != null && (b = sorter.b) != null) {\n+            offset = sorter.offset;\n+        } else if ((b = tryAllocate(double[].class, size)) == null) {\n+            return false;\n+        }\n+\n+        int start = low - offset;\n+        int last = high - offset;\n+\n+        \/*\n+         * Count the number of all digits.\n+         *\/\n+        int[] count1 = new int[1024];\n+        int[] count2 = new int[2048];\n+        int[] count3 = new int[2048];\n+        int[] count4 = new int[2048];\n+        int[] count5 = new int[2048];\n+        int[] count6 = new int[1024];\n+\n+        for (int i = low; i < high; ++i) {\n+            ++count1[(int)  (dtl(a[i])         & 0x3FF)];\n+            ++count2[(int) ((dtl(a[i]) >>> 10) & 0x7FF)];\n+            ++count3[(int) ((dtl(a[i]) >>> 21) & 0x7FF)];\n+            ++count4[(int) ((dtl(a[i]) >>> 32) & 0x7FF)];\n+            ++count5[(int) ((dtl(a[i]) >>> 43) & 0x7FF)];\n+            ++count6[(int) ((dtl(a[i]) >>> 54) & 0x3FF)];\n+        }\n+\n+        \/*\n+         * Detect digits to be processed.\n+         *\/\n+        boolean processDigit1 = processDigit(count1, size, low);\n+        boolean processDigit2 = processDigit(count2, size, low);\n+        boolean processDigit3 = processDigit(count3, size, low);\n+        boolean processDigit4 = processDigit(count4, size, low);\n+        boolean processDigit5 = processDigit(count5, size, low);\n+        boolean processDigit6 = processDigit(count6, size, low);\n+\n+        \/*\n+         * Process the 1-st digit.\n+         *\/\n+        if (processDigit1) {\n+            for (int i = high; i > low; ) {\n+                b[--count1[(int) (dtl(a[--i]) & 0x3FF)] - offset] = a[i];\n+            }\n+        }\n+\n+        \/*\n+         * Process the 2-nd digit.\n+         *\/\n+        if (processDigit2) {\n+            if (processDigit1) {\n+                for (int i = last; i > start; ) {\n+                    a[--count2[(int) ((dtl(b[--i]) >>> 10) & 0x7FF)]] = b[i];\n+                }\n+            } else {\n+                for (int i = high; i > low; ) {\n+                    b[--count2[(int) ((dtl(a[--i]) >>> 10) & 0x7FF)] - offset] = a[i];\n+                }\n+            }\n+        }\n+\n+        \/*\n+         * Process the 3-rd digit.\n+         *\/\n+        if (processDigit3) {\n+            if (processDigit1 ^ processDigit2) {\n+                for (int i = last; i > start; ) {\n+                    a[--count3[(int) ((dtl(b[--i]) >>> 21) & 0x7FF)]] = b[i];\n+                }\n+            } else {\n+                for (int i = high; i > low; ) {\n+                    b[--count3[(int) ((dtl(a[--i]) >>> 21) & 0x7FF)] - offset] = a[i];\n+                }\n+            }\n+        }\n+\n+        \/*\n+         * Process the 4-th digit.\n+         *\/\n+        if (processDigit4) {\n+            if (processDigit1 ^ processDigit2 ^ processDigit3) {\n+                for (int i = last; i > start; ) {\n+                    a[--count4[(int) ((dtl(b[--i]) >>> 32) & 0x7FF)]] = b[i];\n+                }\n+            } else {\n+                for (int i = high; i > low; ) {\n+                    b[--count4[(int) ((dtl(a[--i]) >>> 32) & 0x7FF)] - offset] = a[i];\n+                }\n+            }\n+        }\n+\n+        \/*\n+         * Process the 5-th digit.\n+         *\/\n+        if (processDigit5) {\n+            if (processDigit1 ^ processDigit2 ^ processDigit3 ^ processDigit4) {\n+                for (int i = last; i > start; ) {\n+                    a[--count5[(int) ((dtl(b[--i]) >>> 43) & 0x7FF)]] = b[i];\n+                }\n+            } else {\n+                for (int i = high; i > low; ) {\n+                    b[--count5[(int) ((dtl(a[--i]) >>> 43) & 0x7FF)] - offset] = a[i];\n+                }\n+            }\n+        }\n+\n+        \/*\n+         * Process the 6-th digit.\n+         *\/\n+        if (processDigit6) {\n+            if (processDigit1 ^ processDigit2 ^ processDigit3 ^ processDigit4 ^ processDigit5) {\n+                for (int i = last; i > start; ) {\n+                    a[--count6[(int) ((dtl(b[--i]) >>> 54) & 0x3FF)]] = b[i];\n+                }\n+            } else {\n+                for (int i = high; i > low; ) {\n+                    b[--count6[(int) ((dtl(a[--i]) >>> 54) & 0x3FF)] - offset] = a[i];\n+                }\n+            }\n+        }\n+\n+        \/*\n+         * Copy the buffer to original array, if we process ood number of digits.\n+         *\/\n+        if (processDigit1 ^ processDigit2 ^ processDigit3 ^ processDigit4 ^ processDigit5 ^ processDigit6) {\n+            System.arraycopy(b, low - offset, a, low, size);\n+        }\n+        return true;\n+    }\n+\n+    \/**\n+     * Returns masked bits that represent the double value.\n+     *\n+     * @param d the given value\n+     * @return masked bits\n+     *\/\n+    private static long dtl(double d) {\n+        long x = Double.doubleToRawLongBits(d);\n+        return x ^ ((x >> 63) | 0x8000000000000000L);\n+    }\n+\n+    \/**\n+     * Sorts the specified range of the array using heap sort.\n+     *\n+     * @param a the array to be sorted\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n+     *\/\n+    static void heapSort(double[] a, int low, int high) {\n+        for (int k = (low + high) >>> 1; k > low; ) {\n+            pushDown(a, --k, a[k], low, high);\n+        }\n+        while (--high > low) {\n+            double max = a[low];\n+            pushDown(a, low, a[high], low, high);\n+            a[high] = max;\n+        }\n+    }\n+\n+    \/**\n+     * Pushes specified element down during heap sort.\n+     *\n+     * @param a the given array\n+     * @param p the start index\n+     * @param value the given element\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n+     *\/\n+    private static void pushDown(double[] a, int p, double value, int low, int high) {\n+        for (int k ;; a[p] = a[p = k]) {\n+            k = (p << 1) - low + 2; \/\/ Index of the right child\n+\n+            if (k > high) {\n+                break;\n+            }\n+            if (k == high || a[k] < a[k - 1]) {\n+                --k;\n+            }\n+            if (a[k] <= value) {\n+                break;\n+            }\n+        }\n+        a[p] = value;\n+    }\n+\n+\/\/ #[class]\n@@ -4263,4 +4675,5 @@\n-    private static final class Sorter extends CountedCompleter<Void> {\n-        private static final long serialVersionUID = 20180818L;\n-        @SuppressWarnings(\"serial\")\n-        private final Object a, b;\n+    private static final class Sorter<T> extends CountedCompleter<Void> {\n+\n+        private static final long serialVersionUID = 123456789L;\n+\n+        private final T a, b;\n@@ -4269,0 +4682,14 @@\n+        @SuppressWarnings(\"unchecked\")\n+        private Sorter(T a, int parallelism, int low, int size, int depth) {\n+            this.a = a;\n+            this.low = low;\n+            this.size = size;\n+            this.offset = low;\n+\n+            while ((parallelism >>= 2) > 0 && (size >>= 2) > 0) {\n+                depth -= 2;\n+            }\n+            this.b = (T) tryAllocate(a.getClass(), this.size);\n+            this.depth = b == null ? 0 : depth;\n+        }\n+\n@@ -4270,1 +4697,1 @@\n-                Object a, Object b, int low, int size, int offset, int depth) {\n+                       T a, T b, int low, int size, int offset, int depth) {\n@@ -4281,1 +4708,2 @@\n-        public final void compute() {\n+        @SuppressWarnings(\"unchecked\")\n+        public void compute() {\n@@ -4285,2 +4713,2 @@\n-                new Sorter(this, b, a, low, half, offset, depth + 1).fork();\n-                new Sorter(this, b, a, low + half, size - half, offset, depth + 1).compute();\n+                new Sorter<>(this, b, a, low, half, offset, depth + 1).fork();\n+                new Sorter<>(this, b, a, low + half, size - half, offset, depth + 1).compute();\n@@ -4289,1 +4717,1 @@\n-                    sort(this, (int[]) a, depth, low, low + size);\n+                    sort((Sorter<int[]>) this, (int[]) a, depth, low, low + size);\n@@ -4291,1 +4719,1 @@\n-                    sort(this, (long[]) a, depth, low, low + size);\n+                    sort((Sorter<long[]>) this, (long[]) a, depth, low, low + size);\n@@ -4293,1 +4721,1 @@\n-                    sort(this, (float[]) a, depth, low, low + size);\n+                    sort((Sorter<float[]>) this, (float[]) a, depth, low, low + size);\n@@ -4295,1 +4723,1 @@\n-                    sort(this, (double[]) a, depth, low, low + size);\n+                    sort((Sorter<double[]>) this, (double[]) a, depth, low, low + size);\n@@ -4297,2 +4725,1 @@\n-                    throw new IllegalArgumentException(\n-                        \"Unknown type of array: \" + a.getClass().getName());\n+                    throw new IllegalArgumentException(\"Unknown array: \" + a.getClass().getName());\n@@ -4305,1 +4732,1 @@\n-        public final void onCompletion(CountedCompleter<?> caller) {\n+        public void onCompletion(CountedCompleter<?> caller) {\n@@ -4310,9 +4737,9 @@\n-                new Merger(null,\n-                    a,\n-                    src ? low : low - offset,\n-                    b,\n-                    src ? low - offset : low,\n-                    src ? mi - offset : mi,\n-                    b,\n-                    src ? mi - offset : mi,\n-                    src ? low + size - offset : low + size\n+                new Merger<>(null,\n+                        a,\n+                        src ? low : low - offset,\n+                        b,\n+                        src ? low - offset : low,\n+                        src ? mi - offset : mi,\n+                        b,\n+                        src ? mi - offset : mi,\n+                        src ? low + size - offset : low + size\n@@ -4323,1 +4750,1 @@\n-        private void forkSorter(int depth, int low, int high) {\n+        private void fork(int depth, int low, int high) {\n@@ -4325,2 +4752,1 @@\n-            Object a = this.a; \/\/ Use local variable for performance\n-            new Sorter(this, a, b, low, high - low, offset, depth).fork();\n+            new Sorter<>(this, a, b, low, high - low, offset, depth).fork();\n@@ -4333,4 +4759,5 @@\n-    private static final class Merger extends CountedCompleter<Void> {\n-        private static final long serialVersionUID = 20180818L;\n-        @SuppressWarnings(\"serial\")\n-        private final Object dst, a1, a2;\n+    private static final class Merger<T> extends CountedCompleter<Void> {\n+\n+        private static final long serialVersionUID = 123456789L;\n+\n+        private final T dst, a1, a2;\n@@ -4339,2 +4766,2 @@\n-        private Merger(CountedCompleter<?> parent, Object dst, int k,\n-                Object a1, int lo1, int hi1, Object a2, int lo2, int hi2) {\n+        private Merger(CountedCompleter<?> parent, T dst, int k,\n+                       T a1, int lo1, int hi1, T a2, int lo2, int hi2) {\n@@ -4353,1 +4780,2 @@\n-        public final void compute() {\n+        @SuppressWarnings(\"unchecked\")\n+        public void compute() {\n@@ -4355,2 +4783,2 @@\n-                mergeParts(this, (int[]) dst, k,\n-                    (int[]) a1, lo1, hi1, (int[]) a2, lo2, hi2);\n+                mergeParts((Merger<int[]>) this, (int[]) dst, k,\n+                        (int[]) a1, lo1, hi1, (int[]) a2, lo2, hi2);\n@@ -4358,2 +4786,2 @@\n-                mergeParts(this, (long[]) dst, k,\n-                    (long[]) a1, lo1, hi1, (long[]) a2, lo2, hi2);\n+                mergeParts((Merger<long[]>) this, (long[]) dst, k,\n+                        (long[]) a1, lo1, hi1, (long[]) a2, lo2, hi2);\n@@ -4361,2 +4789,2 @@\n-                mergeParts(this, (float[]) dst, k,\n-                    (float[]) a1, lo1, hi1, (float[]) a2, lo2, hi2);\n+                mergeParts((Merger<float[]>) this, (float[]) dst, k,\n+                        (float[]) a1, lo1, hi1, (float[]) a2, lo2, hi2);\n@@ -4364,2 +4792,2 @@\n-                mergeParts(this, (double[]) dst, k,\n-                    (double[]) a1, lo1, hi1, (double[]) a2, lo2, hi2);\n+                mergeParts((Merger<double[]>) this, (double[]) dst, k,\n+                        (double[]) a1, lo1, hi1, (double[]) a2, lo2, hi2);\n@@ -4367,2 +4795,1 @@\n-                throw new IllegalArgumentException(\n-                    \"Unknown type of array: \" + dst.getClass().getName());\n+                throw new IllegalArgumentException(\"Unknown array: \" + dst.getClass().getName());\n@@ -4373,2 +4800,1 @@\n-        private void forkMerger(Object dst, int k,\n-                Object a1, int lo1, int hi1, Object a2, int lo2, int hi2) {\n+        private void fork(int k, int lo1, int hi1, int lo2, int hi2) {\n@@ -4376,1 +4802,1 @@\n-            new Merger(this, dst, k, a1, lo1, hi1, a2, lo2, hi2).fork();\n+            new Merger<>(this, dst, k, a1, lo1, hi1, a2, lo2, hi2).fork();\n@@ -4381,1 +4807,6 @@\n-     * This class implements parallel merging of runs.\n+     * Tries to allocate additional buffer.\n+     *\n+     * @param clazz the given array class\n+     * @param length the length of additional buffer\n+     * @return {@code null} if requested buffer is too big or there is not enough memory,\n+     *         otherwise created buffer\n@@ -4383,44 +4814,9 @@\n-    private static final class RunMerger extends RecursiveTask<Object> {\n-        private static final long serialVersionUID = 20180818L;\n-        @SuppressWarnings(\"serial\")\n-        private final Object a, b;\n-        private final int[] run;\n-        private final int offset, aim, lo, hi;\n-\n-        private RunMerger(Object a, Object b, int offset,\n-                int aim, int[] run, int lo, int hi) {\n-            this.a = a;\n-            this.b = b;\n-            this.offset = offset;\n-            this.aim = aim;\n-            this.run = run;\n-            this.lo = lo;\n-            this.hi = hi;\n-        }\n-\n-        @Override\n-        protected final Object compute() {\n-            if (a instanceof int[]) {\n-                return mergeRuns((int[]) a, (int[]) b, offset, aim, true, run, lo, hi);\n-            }\n-            if (a instanceof long[]) {\n-                return mergeRuns((long[]) a, (long[]) b, offset, aim, true, run, lo, hi);\n-            }\n-            if (a instanceof float[]) {\n-                return mergeRuns((float[]) a, (float[]) b, offset, aim, true, run, lo, hi);\n-            }\n-            if (a instanceof double[]) {\n-                return mergeRuns((double[]) a, (double[]) b, offset, aim, true, run, lo, hi);\n-            }\n-            throw new IllegalArgumentException(\n-                \"Unknown type of array: \" + a.getClass().getName());\n-        }\n-\n-        private RunMerger forkMe() {\n-            fork();\n-            return this;\n-        }\n-\n-        private Object getDestination() {\n-            join();\n-            return getRawResult();\n+    @SuppressWarnings(\"unchecked\")\n+    private static <T> T tryAllocate(Class<T> clazz, int length) {\n+        try {\n+            int maxLength = MAX_BUFFER_SIZE >>\n+                    (clazz == int[].class || clazz == float[].class ? 2 : 3);\n+            return length > maxLength ? null :\n+                    (T) U.allocateUninitializedArray(clazz.componentType(), length);\n+        } catch (OutOfMemoryError e) {\n+            return null;\n@@ -4429,0 +4825,2 @@\n+\n+    private static final Unsafe U = Unsafe.getUnsafe();\n","filename":"src\/java.base\/share\/classes\/java\/util\/DualPivotQuicksort.java","additions":2280,"deletions":1882,"binary":false,"changes":4162,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- * @bug 6880672 6896573 6899694 6976036 7013585 7018258 8003981 8226297\n+ * @bug 6880672 6896573 6899694 6976036 7013585 7018258 8003981 8226297 8266431\n@@ -39,1 +39,1 @@\n-import java.util.Comparator;\n+import java.util.Arrays;\n@@ -48,3 +48,3 @@\n-    \/\/ Array lengths used in a long run (default)\n-    private static final int[] LONG_RUN_LENGTHS = {\n-        1, 3, 8, 21, 55, 100, 1_000, 10_000, 100_000 };\n+    \/\/ Lengths of arrays for short run\n+    private static final int[] SHORT_RUN_LENGTHS =\n+            { 1, 2, 14, 100, 500, 1_000, 10_000 };\n@@ -52,3 +52,3 @@\n-    \/\/ Array lengths used in a short run\n-    private static final int[] SHORT_RUN_LENGTHS = {\n-        1, 8, 55, 100, 10_000 };\n+    \/\/ Lengths of arrays for long run (default)\n+    private static final int[] LONG_RUN_LENGTHS =\n+            { 1, 2, 14, 100, 500, 1_000, 10_000, 50_000 };\n@@ -56,3 +56,3 @@\n-    \/\/ Random initial values used in a long run (default)\n-    private static final TestRandom[] LONG_RUN_RANDOMS = {\n-        TestRandom.BABA, TestRandom.DEDA, TestRandom.C0FFEE };\n+    \/\/ Initial random values for short run\n+    private static final TestRandom[] SHORT_RUN_RANDOMS =\n+            { TestRandom.C0FFEE };\n@@ -60,3 +60,3 @@\n-    \/\/ Random initial values used in a short run\n-    private static final TestRandom[] SHORT_RUN_RANDOMS = {\n-        TestRandom.C0FFEE };\n+    \/\/ Initial random values for long run (default)\n+    private static final TestRandom[] LONG_RUN_RANDOMS =\n+            { TestRandom.DEDA, TestRandom.BABA, TestRandom.C0FFEE };\n@@ -64,1 +64,1 @@\n-    \/\/ Constants used in subarray sorting\n+    \/\/ Constant to fill the left part of array\n@@ -66,0 +66,2 @@\n+\n+    \/\/ Constant to fill the right part of array\n@@ -71,0 +73,1 @@\n+    private final boolean fix;\n@@ -81,0 +84,4 @@\n+        new Sorting(SortingHelper.MIXED_INSERTION_SORT, randoms).testBase();\n+        new Sorting(SortingHelper.MERGING_SORT, randoms, lengths).testStructured(512);\n+        new Sorting(SortingHelper.HEAP_SORT, randoms, lengths).testBase();\n+        new Sorting(SortingHelper.RADIX_SORT, randoms, lengths).testCore();\n@@ -83,1 +90,0 @@\n-        new Sorting(SortingHelper.HEAP_SORT, randoms, lengths).testBasic();\n@@ -88,1 +94,5 @@\n-        out.format(\"PASSED in %d sec.\\n\", (end - start) \/ 1000);\n+        out.format(\"PASSED in %d sec.\\n\", (end - start) \/ 1_000);\n+    }\n+\n+    private Sorting(SortingHelper sortingHelper, TestRandom[] randoms) {\n+        this(sortingHelper, randoms, SHORT_RUN_LENGTHS, true);\n@@ -92,0 +102,4 @@\n+        this(sortingHelper, randoms, lengths, false);\n+    }\n+\n+    private Sorting(SortingHelper sortingHelper, TestRandom[] randoms, int[] lengths, boolean fix) {\n@@ -95,0 +109,1 @@\n+        this.fix = fix;\n@@ -97,1 +112,2 @@\n-    private void testBasic() {\n+    private void testBase() {\n+        testStructured(0);\n@@ -102,3 +118,1 @@\n-            testBasic(length);\n-        }\n-    }\n+            testSubArray(length);\n@@ -106,5 +120,5 @@\n-    private void testBasic(int length) {\n-        for (TestRandom random : randoms) {\n-            testWithInsertionSort(length, random);\n-            testWithCheckSum(length, random);\n-            testWithScrambling(length, random);\n+            for (TestRandom random : randoms) {\n+                testWithCheckSum(length, random);\n+                testWithScrambling(length, random);\n+                testWithInsertionSort(length, random);\n+            }\n@@ -115,0 +129,2 @@\n+        testBase();\n+\n@@ -117,6 +133,0 @@\n-            testCore(length);\n-        }\n-    }\n-\n-    private void testCore(int length) {\n-        testBasic(length);\n@@ -124,5 +134,4 @@\n-        for (TestRandom random : randoms) {\n-            testMergingSort(length, random);\n-            testSubArray(length, random);\n-            testNegativeZero(length, random);\n-            testFloatingPointSorting(length, random);\n+            for (TestRandom random : randoms) {\n+                testNegativeZero(length, random);\n+                testFloatingPointSorting(length, random);\n+            }\n@@ -133,0 +142,2 @@\n+        testCore();\n+\n@@ -135,1 +146,1 @@\n-            testAll(length);\n+            testRange(length);\n@@ -139,6 +150,4 @@\n-    private void testAll(int length) {\n-        testCore(length);\n-\n-        for (TestRandom random : randoms) {\n-            testRange(length, random);\n-            testStability(length, random);\n+    private void testStructured(int min) {\n+        for (int length : lengths) {\n+            createData(length);\n+            testStructured(length, min);\n@@ -149,26 +158,0 @@\n-        testEmptyAndNullIntArray();\n-        testEmptyAndNullLongArray();\n-        testEmptyAndNullByteArray();\n-        testEmptyAndNullCharArray();\n-        testEmptyAndNullShortArray();\n-        testEmptyAndNullFloatArray();\n-        testEmptyAndNullDoubleArray();\n-    }\n-\n-    private void testStability(int length, TestRandom random) {\n-        printTestName(\"Test stability\", random, length);\n-\n-        Pair[] a = build(length, random);\n-        sortingHelper.sort(a);\n-        checkSorted(a);\n-        checkStable(a);\n-\n-        a = build(length, random);\n-        sortingHelper.sort(a, pairComparator);\n-        checkSorted(a);\n-        checkStable(a);\n-\n-        out.println();\n-    }\n-\n-    private void testEmptyAndNullIntArray() {\n@@ -178,15 +161,0 @@\n-        try {\n-            sortingHelper.sort(null);\n-        } catch (NullPointerException expected) {\n-            try {\n-                sortingHelper.sort(null, 0, 0);\n-            } catch (NullPointerException expected2) {\n-                return;\n-            }\n-            fail(sortingHelper + \"(int[],fromIndex,toIndex) shouldn't \" +\n-                \"catch null array\");\n-        }\n-        fail(sortingHelper + \"(int[]) shouldn't catch null array\");\n-    }\n-\n-    private void testEmptyAndNullLongArray() {\n@@ -196,15 +164,0 @@\n-        try {\n-            sortingHelper.sort(null);\n-        } catch (NullPointerException expected) {\n-            try {\n-                sortingHelper.sort(null, 0, 0);\n-            } catch (NullPointerException expected2) {\n-                return;\n-            }\n-            fail(sortingHelper + \"(long[],fromIndex,toIndex) shouldn't \" +\n-                \"catch null array\");\n-        }\n-        fail(sortingHelper + \"(long[]) shouldn't catch null array\");\n-    }\n-\n-    private void testEmptyAndNullByteArray() {\n@@ -214,15 +167,0 @@\n-        try {\n-            sortingHelper.sort(null);\n-        } catch (NullPointerException expected) {\n-            try {\n-                sortingHelper.sort(null, 0, 0);\n-            } catch (NullPointerException expected2) {\n-                return;\n-            }\n-            fail(sortingHelper + \"(byte[],fromIndex,toIndex) shouldn't \" +\n-                \"catch null array\");\n-        }\n-        fail(sortingHelper + \"(byte[]) shouldn't catch null array\");\n-    }\n-\n-    private void testEmptyAndNullCharArray() {\n@@ -232,15 +170,0 @@\n-        try {\n-            sortingHelper.sort(null);\n-        } catch (NullPointerException expected) {\n-            try {\n-                sortingHelper.sort(null, 0, 0);\n-            } catch (NullPointerException expected2) {\n-                return;\n-            }\n-            fail(sortingHelper + \"(char[],fromIndex,toIndex) shouldn't \" +\n-                \"catch null array\");\n-        }\n-        fail(sortingHelper + \"(char[]) shouldn't catch null array\");\n-    }\n-\n-    private void testEmptyAndNullShortArray() {\n@@ -250,15 +173,0 @@\n-        try {\n-            sortingHelper.sort(null);\n-        } catch (NullPointerException expected) {\n-            try {\n-                sortingHelper.sort(null, 0, 0);\n-            } catch (NullPointerException expected2) {\n-                return;\n-            }\n-            fail(sortingHelper + \"(short[],fromIndex,toIndex) shouldn't \" +\n-                \"catch null array\");\n-        }\n-        fail(sortingHelper + \"(short[]) shouldn't catch null array\");\n-    }\n-\n-    private void testEmptyAndNullFloatArray() {\n@@ -268,15 +176,0 @@\n-        try {\n-            sortingHelper.sort(null);\n-        } catch (NullPointerException expected) {\n-            try {\n-                sortingHelper.sort(null, 0, 0);\n-            } catch (NullPointerException expected2) {\n-                return;\n-            }\n-            fail(sortingHelper + \"(float[],fromIndex,toIndex) shouldn't \" +\n-                \"catch null array\");\n-        }\n-        fail(sortingHelper + \"(float[]) shouldn't catch null array\");\n-    }\n-\n-    private void testEmptyAndNullDoubleArray() {\n@@ -285,13 +178,0 @@\n-\n-        try {\n-            sortingHelper.sort(null);\n-        } catch (NullPointerException expected) {\n-            try {\n-                sortingHelper.sort(null, 0, 0);\n-            } catch (NullPointerException expected2) {\n-                return;\n-            }\n-            fail(sortingHelper + \"(double[],fromIndex,toIndex) shouldn't \" +\n-                \"catch null array\");\n-        }\n-        fail(sortingHelper + \"(double[]) shouldn't catch null array\");\n@@ -300,2 +180,2 @@\n-    private void testSubArray(int length, TestRandom random) {\n-        if (length < 4) {\n+    private void testSubArray(int length) {\n+        if (fix || length < 4) {\n@@ -305,1 +185,0 @@\n-            int fromIndex = m;\n@@ -308,1 +187,1 @@\n-            prepareSubArray((int[]) gold[0], fromIndex, toIndex);\n+            prepareSubArray((int[]) gold[0], m, toIndex);\n@@ -311,5 +190,5 @@\n-            for (int i = 0; i < test.length; i++) {\n-                printTestName(\"Test subarray\", random, length,\n-                    \", m = \" + m + \", \" + getType(i));\n-                sortingHelper.sort(test[i], fromIndex, toIndex);\n-                checkSubArray(test[i], fromIndex, toIndex);\n+            for (int i = 0; i < test.length; ++i) {\n+                printTestName(\"Test subarray\", length,\n+                        \", m = \" + m + \", \" + getType(i));\n+                sortingHelper.sort(test[i], m, toIndex);\n+                checkSubArray(test[i], m, toIndex);\n@@ -321,4 +200,1 @@\n-    private void testRange(int length, TestRandom random) {\n-        if (length < 2) {\n-            return;\n-        }\n+    private void testRange(int length) {\n@@ -326,2 +202,2 @@\n-            for (int i = 1; i <= length; i++) {\n-                ((int[]) gold[0]) [i - 1] = i % m + m % i;\n+            for (int i = 1; i <= length; ++i) {\n+                ((int[]) gold[0])[i - 1] = i % m + m % i;\n@@ -331,3 +207,3 @@\n-            for (int i = 0; i < test.length; i++) {\n-                printTestName(\"Test range check\", random, length,\n-                    \", m = \" + m + \", \" + getType(i));\n+            for (int i = 0; i < test.length; ++i) {\n+                printTestName(\"Test range check\", length,\n+                        \", m = \" + m + \", \" + getType(i));\n@@ -340,45 +216,0 @@\n-    private void checkSorted(Pair[] a) {\n-        for (int i = 0; i < a.length - 1; i++) {\n-            if (a[i].getKey() > a[i + 1].getKey()) {\n-                fail(\"Array is not sorted at \" + i + \"-th position: \" +\n-                    a[i].getKey() + \" and \" + a[i + 1].getKey());\n-            }\n-        }\n-    }\n-\n-    private void checkStable(Pair[] a) {\n-        for (int i = 0; i < a.length \/ 4; ) {\n-            int key1 = a[i].getKey();\n-            int value1 = a[i++].getValue();\n-            int key2 = a[i].getKey();\n-            int value2 = a[i++].getValue();\n-            int key3 = a[i].getKey();\n-            int value3 = a[i++].getValue();\n-            int key4 = a[i].getKey();\n-            int value4 = a[i++].getValue();\n-\n-            if (!(key1 == key2 && key2 == key3 && key3 == key4)) {\n-                fail(\"Keys are different \" + key1 + \", \" + key2 + \", \" +\n-                    key3 + \", \" + key4 + \" at position \" + i);\n-            }\n-            if (!(value1 < value2 && value2 < value3 && value3 < value4)) {\n-                fail(\"Sorting is not stable at position \" + i +\n-                    \". Second values have been changed: \" + value1 + \", \" +\n-                    value2 + \", \" + value3 + \", \" + value4);\n-            }\n-        }\n-    }\n-\n-    private Pair[] build(int length, Random random) {\n-        Pair[] a = new Pair[length * 4];\n-\n-        for (int i = 0; i < a.length; ) {\n-            int key = random.nextInt();\n-            a[i++] = new Pair(key, 1);\n-            a[i++] = new Pair(key, 2);\n-            a[i++] = new Pair(key, 3);\n-            a[i++] = new Pair(key, 4);\n-        }\n-        return a;\n-    }\n-\n@@ -386,1 +217,1 @@\n-        if (length > 1000) {\n+        if (length > 1_000) {\n@@ -394,1 +225,1 @@\n-                for (int i = 0; i < test.length; i++) {\n+                for (int i = 0; i < test.length; ++i) {\n@@ -396,1 +227,1 @@\n-                        \", m = \" + m + \", \" + getType(i) + \" \" + builder);\n+                            \", m = \" + m + \", \" + getType(i) + \" \" + builder);\n@@ -399,0 +230,1 @@\n+                    checkSorted(gold[i]);\n@@ -406,2 +238,2 @@\n-    private void testMergingSort(int length, TestRandom random) {\n-        if (length < (4 << 10)) { \/\/ DualPivotQuicksort.MIN_TRY_MERGE_SIZE\n+    private void testStructured(int length, int min) {\n+        if (length < min) {\n@@ -410,4 +242,2 @@\n-        final int PERIOD = 50;\n-\n-        for (int m = PERIOD - 2; m <= PERIOD + 2; m++) {\n-            for (MergingBuilder builder : MergingBuilder.values()) {\n+        for (int m = 1; m < 8; ++m) {\n+            for (StructuredBuilder builder : StructuredBuilder.values()) {\n@@ -417,3 +247,3 @@\n-                for (int i = 0; i < test.length; i++) {\n-                    printTestName(\"Test merging sort\", random, length,\n-                        \", m = \" + m + \", \" +  getType(i) + \" \" + builder);\n+                for (int i = 0; i < test.length; ++i) {\n+                    printTestName(\"Test structured\", length,\n+                            \", m = \" + m + \", \" +  getType(i) + \" \" + builder);\n@@ -429,0 +259,3 @@\n+        if (length > 1_000) {\n+            return;\n+        }\n@@ -434,1 +267,1 @@\n-                for (int i = 0; i < test.length; i++) {\n+                for (int i = 0; i < test.length; ++i) {\n@@ -436,1 +269,1 @@\n-                        \", m = \" + m + \", \" + getType(i) + \" \" + builder);\n+                            \", m = \" + m + \", \" + getType(i) + \" \" + builder);\n@@ -446,0 +279,3 @@\n+        if (fix) {\n+            return;\n+        }\n@@ -451,1 +287,1 @@\n-                for (int i = 0; i < test.length; i++) {\n+                for (int i = 0; i < test.length; ++i) {\n@@ -453,1 +289,1 @@\n-                        \", m = \" + m + \", \" + getType(i) + \" \" + builder);\n+                            \", m = \" + m + \", \" + getType(i) + \" \" + builder);\n@@ -464,1 +300,1 @@\n-        for (int i = 5; i < test.length; i++) {\n+        for (int i = 5; i < test.length; ++i) {\n@@ -467,1 +303,1 @@\n-            NegativeZeroBuilder builder = NegativeZeroBuilder.values() [i - 5];\n+            NegativeZeroBuilder builder = NegativeZeroBuilder.values()[i - 5];\n@@ -477,1 +313,1 @@\n-        if (length < 2) {\n+        if (length < 6) {\n@@ -480,1 +316,2 @@\n-        final int MAX = 13;\n+        final int MAX = 14;\n+        int s = 4;\n@@ -482,6 +319,6 @@\n-        for (int a = 0; a < MAX; a++) {\n-            for (int g = 0; g < MAX; g++) {\n-                for (int z = 0; z < MAX; z++) {\n-                    for (int n = 0; n < MAX; n++) {\n-                        for (int p = 0; p < MAX; p++) {\n-                            if (a + g + z + n + p != length) {\n+        for (int a = 0; a < MAX; ++a) {\n+            for (int g = 0; g < MAX; ++g) {\n+                for (int z = 0; z < MAX; ++z) {\n+                    for (int n = 0; n < MAX; ++n) {\n+                        for (int p = 0; p < MAX; ++p) {\n+                            if (a + g + z + n + p + s != length) {\n@@ -490,1 +327,1 @@\n-                            for (int i = 5; i < test.length; i++) {\n+                            for (int i = 5; i < test.length; ++i) {\n@@ -492,2 +329,2 @@\n-                                    \", a = \" + a + \", g = \" + g + \", z = \" + z +\n-                                    \", n = \" + n + \", p = \" + p + \", \" + getType(i));\n+                                        \", a = \" + a + \", g = \" + g + \", z = \" + z +\n+                                                \", n = \" + n + \", p = \" + p + \", \" + getType(i));\n@@ -499,1 +336,1 @@\n-                                compare(test[i], gold[i], a, n, g);\n+                                compare(test[i], gold[i], a, n + 2, g);\n@@ -506,0 +343,3 @@\n+        for (int m = MAX; m > 4; --m) {\n+            int g = length \/ m;\n+            int a = length - g - g - g - g - s;\n@@ -507,6 +347,1 @@\n-        for (int m = 13; m > 4; m--) {\n-            int t = length \/ m;\n-            int g = t, z = t, n = t, p = t;\n-            int a = length - g - z - n - p;\n-\n-            for (int i = 5; i < test.length; i++) {\n+            for (int i = 5; i < test.length; ++i) {\n@@ -514,4 +349,4 @@\n-                    \", a = \" + a + \", g = \" + g + \", z = \" + z +\n-                    \", n = \" + n + \", p = \" + p + \", \" + getType(i));\n-                FloatingPointBuilder builder = FloatingPointBuilder.values() [i - 5];\n-                builder.build(gold[i], a, g, z, n, p, random);\n+                        \", a = \" + a + \", g = \" + g + \", z = \" + g +\n+                                \", n = \" + g + \", p = \" + g + \", \" + getType(i));\n+                FloatingPointBuilder builder = FloatingPointBuilder.values()[i - 5];\n+                builder.build(gold[i], a, g, g, g, g, random);\n@@ -521,1 +356,1 @@\n-                compare(test[i], gold[i], a, n, g);\n+                compare(test[i], gold[i], a, g + 2, g);\n@@ -528,1 +363,1 @@\n-        for (int i = 0; i < fromIndex; i++) {\n+        for (int i = 0; i < fromIndex; ++i) {\n@@ -534,1 +369,1 @@\n-        for (int i = fromIndex; i < middle; i++) {\n+        for (int i = fromIndex; i < middle; ++i) {\n@@ -538,1 +373,1 @@\n-        for (int i = middle; i < toIndex; i++) {\n+        for (int i = middle; i < toIndex; ++i) {\n@@ -542,1 +377,1 @@\n-        for (int i = toIndex; i < a.length; i++) {\n+        for (int i = toIndex; i < a.length; ++i) {\n@@ -563,1 +398,1 @@\n-            fail(\"Unknown type of array: \" + a.getClass().getName());\n+            fail(a);\n@@ -568,1 +403,1 @@\n-        for (int i = 0; i < a.length * 7; i++) {\n+        for (int i = 0; i < a.length * 7; ++i) {\n@@ -574,1 +409,1 @@\n-        for (int i = 0; i < a.length * 7; i++) {\n+        for (int i = 0; i < a.length * 7; ++i) {\n@@ -580,1 +415,1 @@\n-        for (int i = 0; i < a.length * 7; i++) {\n+        for (int i = 0; i < a.length * 7; ++i) {\n@@ -586,1 +421,1 @@\n-        for (int i = 0; i < a.length * 7; i++) {\n+        for (int i = 0; i < a.length * 7; ++i) {\n@@ -592,1 +427,1 @@\n-        for (int i = 0; i < a.length * 7; i++) {\n+        for (int i = 0; i < a.length * 7; ++i) {\n@@ -598,1 +433,1 @@\n-        for (int i = 0; i < a.length * 7; i++) {\n+        for (int i = 0; i < a.length * 7; ++i) {\n@@ -604,1 +439,1 @@\n-        for (int i = 0; i < a.length * 7; i++) {\n+        for (int i = 0; i < a.length * 7; ++i) {\n@@ -642,0 +477,4 @@\n+    private void fail(Object object) {\n+        fail(\"Unknown type of array: \" + object.getClass().getName());\n+    }\n+\n@@ -653,1 +492,1 @@\n-            fail(\"Unknown type of array: \" + a.getClass().getName());\n+            fail(a);\n@@ -658,1 +497,1 @@\n-        for (int i = 0; i < a.length - 1; i++) {\n+        for (int i = 0; i < a.length - 1; ++i) {\n@@ -666,1 +505,1 @@\n-        for (int i = 0; i < a.length - 1; i++) {\n+        for (int i = 0; i < a.length - 1; ++i) {\n@@ -679,1 +518,1 @@\n-            fail(\"Unknown type of array: \" + a.getClass().getName());\n+            fail(a);\n@@ -684,1 +523,1 @@\n-        for (int i = a.length - numNaN; i < a.length; i++) {\n+        for (int i = a.length - numNaN; i < a.length; ++i) {\n@@ -691,1 +530,1 @@\n-        for (int i = numNeg; i < numNeg + numNegZero; i++) {\n+        for (int i = numNeg; i < numNeg + numNegZero; ++i) {\n@@ -697,1 +536,1 @@\n-        for (int i = 0; i < a.length - numNaN; i++) {\n+        for (int i = 0; i < a.length - numNaN; ++i) {\n@@ -705,1 +544,1 @@\n-        for (int i = a.length - numNaN; i < a.length; i++) {\n+        for (int i = a.length - numNaN; i < a.length; ++i) {\n@@ -712,1 +551,1 @@\n-        for (int i = numNeg; i < numNeg + numNegZero; i++) {\n+        for (int i = numNeg; i < numNeg + numNegZero; ++i) {\n@@ -718,1 +557,1 @@\n-        for (int i = 0; i < a.length - numNaN; i++) {\n+        for (int i = 0; i < a.length - numNaN; ++i) {\n@@ -741,1 +580,1 @@\n-            fail(\"Unknown type of array: \" + a.getClass().getName());\n+            fail(a);\n@@ -746,1 +585,1 @@\n-        for (int i = 0; i < a.length; i++) {\n+        for (int i = 0; i < a.length; ++i) {\n@@ -754,1 +593,1 @@\n-        for (int i = 0; i < a.length; i++) {\n+        for (int i = 0; i < a.length; ++i) {\n@@ -762,1 +601,1 @@\n-        for (int i = 0; i < a.length; i++) {\n+        for (int i = 0; i < a.length; ++i) {\n@@ -770,1 +609,1 @@\n-        for (int i = 0; i < a.length; i++) {\n+        for (int i = 0; i < a.length; ++i) {\n@@ -778,1 +617,1 @@\n-        for (int i = 0; i < a.length; i++) {\n+        for (int i = 0; i < a.length; ++i) {\n@@ -786,1 +625,1 @@\n-        for (int i = 0; i < a.length; i++) {\n+        for (int i = 0; i < a.length; ++i) {\n@@ -794,1 +633,1 @@\n-        for (int i = 0; i < a.length; i++) {\n+        for (int i = 0; i < a.length; ++i) {\n@@ -825,1 +664,1 @@\n-        fail(\"Unknown type of array: \" + a.getClass().getName());\n+        fail(a);\n@@ -845,1 +684,1 @@\n-            fail(\"Unknown type of array: \" + a.getClass().getName());\n+            fail(a);\n@@ -850,1 +689,1 @@\n-        for (int i = 0; i < a.length - 1; i++) {\n+        for (int i = 0; i < a.length - 1; ++i) {\n@@ -858,1 +697,1 @@\n-        for (int i = 0; i < a.length - 1; i++) {\n+        for (int i = 0; i < a.length - 1; ++i) {\n@@ -866,1 +705,1 @@\n-        for (int i = 0; i < a.length - 1; i++) {\n+        for (int i = 0; i < a.length - 1; ++i) {\n@@ -874,1 +713,1 @@\n-        for (int i = 0; i < a.length - 1; i++) {\n+        for (int i = 0; i < a.length - 1; ++i) {\n@@ -882,1 +721,1 @@\n-        for (int i = 0; i < a.length - 1; i++) {\n+        for (int i = 0; i < a.length - 1; ++i) {\n@@ -890,1 +729,1 @@\n-        for (int i = 0; i < a.length - 1; i++) {\n+        for (int i = 0; i < a.length - 1; ++i) {\n@@ -898,1 +737,1 @@\n-        for (int i = 0; i < a.length - 1; i++) {\n+        for (int i = 0; i < a.length - 1; ++i) {\n@@ -936,1 +775,1 @@\n-        fail(\"Unknown type of array: \" + a.getClass().getName());\n+        fail(a);\n@@ -964,1 +803,1 @@\n-        return (int) checkSum;\n+        return checkSum;\n@@ -973,1 +812,1 @@\n-        return (int) checkSum;\n+        return checkSum;\n@@ -982,1 +821,1 @@\n-        return (int) checkSum;\n+        return checkSum;\n@@ -1025,1 +864,1 @@\n-        fail(\"Unknown type of array: \" + a.getClass().getName());\n+        fail(a);\n@@ -1053,1 +892,1 @@\n-        return (int) checkSum;\n+        return checkSum;\n@@ -1062,1 +901,1 @@\n-        return (int) checkSum;\n+        return checkSum;\n@@ -1071,1 +910,1 @@\n-        return (int) checkSum;\n+        return checkSum;\n@@ -1093,94 +932,1 @@\n-        if (a instanceof int[]) {\n-            sortByInsertionSort((int[]) a);\n-        } else if (a instanceof long[]) {\n-            sortByInsertionSort((long[]) a);\n-        } else if (a instanceof byte[]) {\n-            sortByInsertionSort((byte[]) a);\n-        } else if (a instanceof char[]) {\n-            sortByInsertionSort((char[]) a);\n-        } else if (a instanceof short[]) {\n-            sortByInsertionSort((short[]) a);\n-        } else if (a instanceof float[]) {\n-            sortByInsertionSort((float[]) a);\n-        } else if (a instanceof double[]) {\n-            sortByInsertionSort((double[]) a);\n-        } else {\n-            fail(\"Unknown type of array: \" + a.getClass().getName());\n-        }\n-    }\n-\n-    private void sortByInsertionSort(int[] a) {\n-        for (int j, i = 1; i < a.length; i++) {\n-            int ai = a[i];\n-\n-            for (j = i - 1; j >= 0 && ai < a[j]; j--) {\n-                a[j + 1] = a[j];\n-            }\n-            a[j + 1] = ai;\n-        }\n-    }\n-\n-    private void sortByInsertionSort(long[] a) {\n-        for (int j, i = 1; i < a.length; i++) {\n-            long ai = a[i];\n-\n-            for (j = i - 1; j >= 0 && ai < a[j]; j--) {\n-                a[j + 1] = a[j];\n-            }\n-            a[j + 1] = ai;\n-        }\n-    }\n-\n-    private void sortByInsertionSort(byte[] a) {\n-        for (int j, i = 1; i < a.length; i++) {\n-            byte ai = a[i];\n-\n-            for (j = i - 1; j >= 0 && ai < a[j]; j--) {\n-                a[j + 1] = a[j];\n-            }\n-            a[j + 1] = ai;\n-        }\n-    }\n-\n-    private void sortByInsertionSort(char[] a) {\n-        for (int j, i = 1; i < a.length; i++) {\n-            char ai = a[i];\n-\n-            for (j = i - 1; j >= 0 && ai < a[j]; j--) {\n-                a[j + 1] = a[j];\n-            }\n-            a[j + 1] = ai;\n-        }\n-    }\n-\n-    private void sortByInsertionSort(short[] a) {\n-        for (int j, i = 1; i < a.length; i++) {\n-            short ai = a[i];\n-\n-            for (j = i - 1; j >= 0 && ai < a[j]; j--) {\n-                a[j + 1] = a[j];\n-            }\n-            a[j + 1] = ai;\n-        }\n-    }\n-\n-    private void sortByInsertionSort(float[] a) {\n-        for (int j, i = 1; i < a.length; i++) {\n-            float ai = a[i];\n-\n-            for (j = i - 1; j >= 0 && ai < a[j]; j--) {\n-                a[j + 1] = a[j];\n-            }\n-            a[j + 1] = ai;\n-        }\n-    }\n-\n-    private void sortByInsertionSort(double[] a) {\n-        for (int j, i = 1; i < a.length; i++) {\n-            double ai = a[i];\n-\n-            for (j = i - 1; j >= 0 && ai < a[j]; j--) {\n-                a[j + 1] = a[j];\n-            }\n-            a[j + 1] = ai;\n-        }\n+        SortingHelper.INSERTION_SORT.sort(a);\n@@ -1205,1 +951,1 @@\n-            fail(\"Unknown type of array: \" + a.getClass().getName());\n+            fail(a);\n@@ -1210,1 +956,1 @@\n-        for (int i = 0; i < fromIndex; i++) {\n+        for (int i = 0; i < fromIndex; ++i) {\n@@ -1216,1 +962,1 @@\n-        for (int i = fromIndex; i < toIndex - 1; i++) {\n+        for (int i = fromIndex; i < toIndex - 1; ++i) {\n@@ -1222,1 +968,1 @@\n-        for (int i = toIndex; i < a.length; i++) {\n+        for (int i = toIndex; i < a.length; ++i) {\n@@ -1230,1 +976,1 @@\n-        for (int i = 0; i < fromIndex; i++) {\n+        for (int i = 0; i < fromIndex; ++i) {\n@@ -1236,1 +982,1 @@\n-        for (int i = fromIndex; i < toIndex - 1; i++) {\n+        for (int i = fromIndex; i < toIndex - 1; ++i) {\n@@ -1242,1 +988,1 @@\n-        for (int i = toIndex; i < a.length; i++) {\n+        for (int i = toIndex; i < a.length; ++i) {\n@@ -1250,1 +996,1 @@\n-        for (int i = 0; i < fromIndex; i++) {\n+        for (int i = 0; i < fromIndex; ++i) {\n@@ -1256,1 +1002,1 @@\n-        for (int i = fromIndex; i < toIndex - 1; i++) {\n+        for (int i = fromIndex; i < toIndex - 1; ++i) {\n@@ -1262,1 +1008,1 @@\n-        for (int i = toIndex; i < a.length; i++) {\n+        for (int i = toIndex; i < a.length; ++i) {\n@@ -1270,1 +1016,1 @@\n-        for (int i = 0; i < fromIndex; i++) {\n+        for (int i = 0; i < fromIndex; ++i) {\n@@ -1276,1 +1022,1 @@\n-        for (int i = fromIndex; i < toIndex - 1; i++) {\n+        for (int i = fromIndex; i < toIndex - 1; ++i) {\n@@ -1282,1 +1028,1 @@\n-        for (int i = toIndex; i < a.length; i++) {\n+        for (int i = toIndex; i < a.length; ++i) {\n@@ -1290,1 +1036,1 @@\n-        for (int i = 0; i < fromIndex; i++) {\n+        for (int i = 0; i < fromIndex; ++i) {\n@@ -1296,1 +1042,1 @@\n-        for (int i = fromIndex; i < toIndex - 1; i++) {\n+        for (int i = fromIndex; i < toIndex - 1; ++i) {\n@@ -1302,1 +1048,1 @@\n-        for (int i = toIndex; i < a.length; i++) {\n+        for (int i = toIndex; i < a.length; ++i) {\n@@ -1310,1 +1056,1 @@\n-        for (int i = 0; i < fromIndex; i++) {\n+        for (int i = 0; i < fromIndex; ++i) {\n@@ -1316,1 +1062,1 @@\n-        for (int i = fromIndex; i < toIndex - 1; i++) {\n+        for (int i = fromIndex; i < toIndex - 1; ++i) {\n@@ -1322,1 +1068,1 @@\n-        for (int i = toIndex; i < a.length; i++) {\n+        for (int i = toIndex; i < a.length; ++i) {\n@@ -1330,1 +1076,1 @@\n-        for (int i = 0; i < fromIndex; i++) {\n+        for (int i = 0; i < fromIndex; ++i) {\n@@ -1336,1 +1082,1 @@\n-        for (int i = fromIndex; i < toIndex - 1; i++) {\n+        for (int i = fromIndex; i < toIndex - 1; ++i) {\n@@ -1342,1 +1088,1 @@\n-        for (int i = toIndex; i < a.length; i++) {\n+        for (int i = toIndex; i < a.length; ++i) {\n@@ -1365,1 +1111,1 @@\n-            fail(\"Unknown type of array: \" + a.getClass().getName());\n+            fail(a);\n@@ -1373,1 +1119,1 @@\n-                \"as expected: fromIndex = \" + (m + 1) + \" toIndex = \" + m);\n+                    \"as expected: fromIndex = \" + (m + 1) + \", toIndex = \" + m);\n@@ -1378,1 +1124,1 @@\n-                    \"as expected: fromIndex = \" + (-m));\n+                        \"as expected: fromIndex = \" + (-m));\n@@ -1383,1 +1129,1 @@\n-                        \"as expected: toIndex = \" + (a.length + m));\n+                            \"as expected: toIndex = \" + (a.length + m));\n@@ -1393,1 +1139,1 @@\n-                \"as expected: fromIndex = \" + (m + 1) + \" toIndex = \" + m);\n+                    \"as expected: fromIndex = \" + (m + 1) + \", toIndex = \" + m);\n@@ -1398,1 +1144,1 @@\n-                    \"as expected: fromIndex = \" + (-m));\n+                        \"as expected: fromIndex = \" + (-m));\n@@ -1403,1 +1149,1 @@\n-                        \"as expected: toIndex = \" + (a.length + m));\n+                            \"as expected: toIndex = \" + (a.length + m));\n@@ -1413,1 +1159,1 @@\n-                \"as expected: fromIndex = \" + (m + 1) + \" toIndex = \" + m);\n+                    \"as expected: fromIndex = \" + (m + 1) + \", toIndex = \" + m);\n@@ -1418,1 +1164,1 @@\n-                    \"as expected: fromIndex = \" + (-m));\n+                        \"as expected: fromIndex = \" + (-m));\n@@ -1423,1 +1169,1 @@\n-                        \"as expected: toIndex = \" + (a.length + m));\n+                            \"as expected: toIndex = \" + (a.length + m));\n@@ -1433,1 +1179,1 @@\n-                \"as expected: fromIndex = \" + (m + 1) + \" toIndex = \" + m);\n+                    \"as expected: fromIndex = \" + (m + 1) + \", toIndex = \" + m);\n@@ -1438,1 +1184,1 @@\n-                    \"as expected: fromIndex = \" + (-m));\n+                        \"as expected: fromIndex = \" + (-m));\n@@ -1443,1 +1189,1 @@\n-                        \"as expected: toIndex = \" + (a.length + m));\n+                            \"as expected: toIndex = \" + (a.length + m));\n@@ -1453,1 +1199,1 @@\n-                \"as expected: fromIndex = \" + (m + 1) + \" toIndex = \" + m);\n+                    \"as expected: fromIndex = \" + (m + 1) + \", toIndex = \" + m);\n@@ -1458,1 +1204,1 @@\n-                    \"as expected: fromIndex = \" + (-m));\n+                        \"as expected: fromIndex = \" + (-m));\n@@ -1463,1 +1209,1 @@\n-                        \"as expected: toIndex = \" + (a.length + m));\n+                            \"as expected: toIndex = \" + (a.length + m));\n@@ -1473,1 +1219,1 @@\n-                \"as expected: fromIndex = \" + (m + 1) + \" toIndex = \" + m);\n+                    \"as expected: fromIndex = \" + (m + 1) + \", toIndex = \" + m);\n@@ -1478,1 +1224,1 @@\n-                    \"as expected: fromIndex = \" + (-m));\n+                        \"as expected: fromIndex = \" + (-m));\n@@ -1483,1 +1229,1 @@\n-                        \"as expected: toIndex = \" + (a.length + m));\n+                            \"as expected: toIndex = \" + (a.length + m));\n@@ -1493,1 +1239,1 @@\n-                \"as expected: fromIndex = \" + (m + 1) + \" toIndex = \" + m);\n+                    \"as expected: fromIndex = \" + (m + 1) + \", toIndex = \" + m);\n@@ -1498,1 +1244,1 @@\n-                    \"as expected: fromIndex = \" + (-m));\n+                        \"as expected: fromIndex = \" + (-m));\n@@ -1503,1 +1249,1 @@\n-                        \"as expected: toIndex = \" + (a.length + m));\n+                            \"as expected: toIndex = \" + (a.length + m));\n@@ -1515,1 +1261,1 @@\n-            fail(\"Unknown type of array: \" + src.getClass().getName());\n+            fail(src);\n@@ -1527,4 +1273,0 @@\n-    private void printTestName(String test, TestRandom random, int length) {\n-        printTestName(test, random, length, \"\");\n-    }\n-\n@@ -1533,3 +1275,3 @@\n-            new int[length], new long[length],\n-            new byte[length], new char[length], new short[length],\n-            new float[length], new double[length]\n+                new int[length], new long[length],\n+                new byte[length], new char[length], new short[length],\n+                new float[length], new double[length]\n@@ -1539,3 +1281,3 @@\n-            new int[length], new long[length],\n-            new byte[length], new char[length], new short[length],\n-            new float[length], new double[length]\n+                new int[length], new long[length],\n+                new byte[length], new char[length], new short[length],\n+                new float[length], new double[length]\n@@ -1546,3 +1288,3 @@\n-        for (int i = 1; i < gold.length; i++) {\n-            TypeConverter converter = TypeConverter.values()[i - 1];\n-            converter.convert((int[])gold[0], gold[i]);\n+        for (int i = 0; i < gold.length; ++i) {\n+            TypeConverter converter = TypeConverter.values()[i];\n+            converter.convert((int[]) gold[0], gold[i], fix);\n@@ -1551,1 +1293,1 @@\n-        for (int i = 0; i < gold.length; i++) {\n+        for (int i = 0; i < gold.length; ++i) {\n@@ -1560,0 +1302,4 @@\n+    private void printTestName(String test, int length, String message) {\n+        out.println(\"[\" + sortingHelper + \"] '\" + test + \"' length = \" + length + message);\n+    }\n+\n@@ -1561,2 +1307,2 @@\n-        out.println( \"[\" + sortingHelper + \"] '\" + test +\n-            \"' length = \" + length + \", random = \" + random + message);\n+        out.println(\"[\" + sortingHelper + \"] '\" + test +\n+                \"' length = \" + length + \", random = \" + random + message);\n@@ -1565,1 +1311,11 @@\n-    private static enum TypeConverter {\n+    private enum TypeConverter {\n+\n+        INT {\n+            @Override\n+            void convert(int[] src, Object dst, boolean fix) {\n+                if (fix) {\n+                    src[0] = Integer.MIN_VALUE;\n+                }\n+            }\n+        },\n+\n@@ -1567,1 +1323,2 @@\n-            void convert(int[] src, Object dst) {\n+            @Override\n+            void convert(int[] src, Object dst, boolean fix) {\n@@ -1570,2 +1327,5 @@\n-                for (int i = 0; i < src.length; i++) {\n-                    b[i] = (long) src[i];\n+                for (int i = 0; i < src.length; ++i) {\n+                    b[i] = src[i];\n+                }\n+                if (fix) {\n+                    b[0] = Long.MIN_VALUE;\n@@ -1577,1 +1337,2 @@\n-            void convert(int[] src, Object dst) {\n+            @Override\n+            void convert(int[] src, Object dst, boolean fix) {\n@@ -1580,1 +1341,1 @@\n-                for (int i = 0; i < src.length; i++) {\n+                for (int i = 0; i < src.length; ++i) {\n@@ -1583,0 +1344,3 @@\n+                if (fix) {\n+                    b[0] = Byte.MIN_VALUE;\n+                }\n@@ -1587,1 +1351,2 @@\n-            void convert(int[] src, Object dst) {\n+            @Override\n+            void convert(int[] src, Object dst, boolean fix) {\n@@ -1590,1 +1355,1 @@\n-                for (int i = 0; i < src.length; i++) {\n+                for (int i = 0; i < src.length; ++i) {\n@@ -1593,0 +1358,3 @@\n+                if (fix) {\n+                    b[0] = Character.MIN_VALUE;\n+                }\n@@ -1597,1 +1365,2 @@\n-            void convert(int[] src, Object dst) {\n+            @Override\n+            void convert(int[] src, Object dst, boolean fix) {\n@@ -1600,1 +1369,1 @@\n-                for (int i = 0; i < src.length; i++) {\n+                for (int i = 0; i < src.length; ++i) {\n@@ -1603,0 +1372,3 @@\n+                if (fix) {\n+                    b[0] = Short.MIN_VALUE;\n+                }\n@@ -1607,1 +1379,2 @@\n-            void convert(int[] src, Object dst) {\n+            @Override\n+            void convert(int[] src, Object dst, boolean fix) {\n@@ -1610,1 +1383,1 @@\n-                for (int i = 0; i < src.length; i++) {\n+                for (int i = 0; i < src.length; ++i) {\n@@ -1613,0 +1386,3 @@\n+                if (fix) {\n+                    b[0] = Float.NEGATIVE_INFINITY;\n+                }\n@@ -1617,1 +1393,2 @@\n-            void convert(int[] src, Object dst) {\n+            @Override\n+            void convert(int[] src, Object dst, boolean fix) {\n@@ -1620,2 +1397,5 @@\n-                for (int i = 0; i < src.length; i++) {\n-                    b[i] = (double) src[i];\n+                for (int i = 0; i < src.length; ++i) {\n+                    b[i] = src[i];\n+                }\n+                if (fix) {\n+                    b[0] = Double.NEGATIVE_INFINITY;\n@@ -1626,1 +1406,1 @@\n-        abstract void convert(int[] src, Object dst);\n+        abstract void convert(int[] src, Object dst, boolean fix);\n@@ -1629,1 +1409,2 @@\n-    private static enum SortedBuilder {\n+    private enum SortedBuilder {\n+\n@@ -1631,0 +1412,1 @@\n+            @Override\n@@ -1632,1 +1414,1 @@\n-                for (int i = 0; i < m; i++) {\n+                for (int i = 0; i < m; ++i) {\n@@ -1636,1 +1418,1 @@\n-                for (int i = m; i < a.length; i++) {\n+                for (int i = m; i < a.length; ++i) {\n@@ -1645,1 +1427,2 @@\n-    private static enum UnsortedBuilder {\n+    private enum UnsortedBuilder {\n+\n@@ -1647,0 +1430,1 @@\n+            @Override\n@@ -1648,1 +1432,1 @@\n-                for (int i = 0; i < a.length; i++) {\n+                for (int i = 0; i < a.length; ++i) {\n@@ -1654,1 +1438,2 @@\n-        ASCENDING {\n+        PERMUTATION {\n+            @Override\n@@ -1656,2 +1441,8 @@\n-                for (int i = 0; i < a.length; i++) {\n-                    a[i] = m + i;\n+                int mask = ~(0x000000FF << (random.nextInt(4) * 2));\n+\n+                for (int i = 0; i < a.length; ++i) {\n+                    a[i] = i & mask;\n+                }\n+                for (int i = a.length; i > 1; --i) {\n+                    int k = random.nextInt(i);\n+                    int t = a[i - 1]; a[i - 1] = a[k]; a[k] = t;\n@@ -1662,1 +1453,2 @@\n-        DESCENDING {\n+        UNIFORM {\n+            @Override\n@@ -1664,2 +1456,4 @@\n-                for (int i = 0; i < a.length; i++) {\n-                    a[i] = a.length - m - i;\n+                int mask = (m << 15) - 1;\n+\n+                for (int i = 0; i < a.length; ++i) {\n+                    a[i] = random.nextInt() & mask;\n@@ -1670,1 +1464,2 @@\n-        EQUAL {\n+        REPEATED {\n+            @Override\n@@ -1672,2 +1467,11 @@\n-                for (int i = 0; i < a.length; i++) {\n-                    a[i] = m;\n+                for (int i = 0; i < a.length; ++i) {\n+                    a[i] = i % m;\n+                }\n+            }\n+        },\n+\n+        DUPLICATED {\n+            @Override\n+            void build(int[] a, int m, Random random) {\n+                for (int i = 0; i < a.length; ++i) {\n+                    a[i] = random.nextInt(m);\n@@ -1678,1 +1482,2 @@\n-        SAW {\n+        SAWTOOTH {\n+            @Override\n@@ -1686,1 +1491,1 @@\n-                    for (int k = 1; k <= period; k++) {\n+                    for (int k = 1; k <= period; ++k) {\n@@ -1694,1 +1499,1 @@\n-                    for (int k = 1; k <= period; k++) {\n+                    for (int k = 1; k <= period; ++k) {\n@@ -1705,1 +1510,2 @@\n-        REPEATED {\n+        SHUFFLE {\n+            @Override\n@@ -1707,2 +1513,16 @@\n-                for (int i = 0; i < a.length; i++) {\n-                    a[i] = i % m;\n+                for (int i = 0, j = 0, k = 1; i < a.length; ++i) {\n+                    a[i] = random.nextInt(m) > 0 ? (j += 2) : (k += 2);\n+                }\n+            }\n+        };\n+\n+        abstract void build(int[] a, int m, Random random);\n+    }\n+\n+    private enum StructuredBuilder {\n+\n+        ASCENDING {\n+            @Override\n+            void build(int[] a, int m) {\n+                for (int i = 0; i < a.length; ++i) {\n+                    a[i] = m + i;\n@@ -1713,4 +1533,23 @@\n-        DUPLICATED {\n-            void build(int[] a, int m, Random random) {\n-                for (int i = 0; i < a.length; i++) {\n-                    a[i] = random.nextInt(m);\n+        DESCENDING {\n+            @Override\n+            void build(int[] a, int m) {\n+                for (int i = 0; i < a.length; ++i) {\n+                    a[i] = a.length - m - i;\n+                }\n+            }\n+        },\n+\n+        EQUAL {\n+            @Override\n+            void build(int[] a, int m) {\n+                Arrays.fill(a, m);\n+            }\n+        },\n+\n+        MASKED {\n+            @Override\n+            void build(int[] a, int m) {\n+                int mask = (m << 15) - 1;\n+\n+                for (int i = 0; i < a.length; ++i) {\n+                    a[i] = (i ^ 0xFF) & mask;\n@@ -1722,1 +1561,2 @@\n-            void build(int[] a, int m, Random random) {\n+            @Override\n+            void build(int[] a, int m) {\n@@ -1725,1 +1565,1 @@\n-                for (int i = 0; i < middle; i++) {\n+                for (int i = 0; i < middle; ++i) {\n@@ -1729,1 +1569,1 @@\n-                for (int i = middle; i < a.length; i++) {\n+                for (int i = middle; i < a.length; ++i) {\n@@ -1736,2 +1576,3 @@\n-            void build(int[] a, int m, Random random) {\n-                for (int i = 0; i < a.length; i++) {\n+            @Override\n+            void build(int[] a, int m) {\n+                for (int i = 0; i < a.length; ++i) {\n@@ -1744,2 +1585,3 @@\n-            void build(int[] a, int m, Random random) {\n-                for (int i = 0; i < a.length; i++) {\n+            @Override\n+            void build(int[] a, int m) {\n+                for (int i = 0; i < a.length; ++i) {\n@@ -1751,10 +1593,0 @@\n-        SHUFFLE {\n-            void build(int[] a, int m, Random random) {\n-                int x = 0, y = 0;\n-\n-                for (int i = 0; i < a.length; i++) {\n-                    a[i] = random.nextBoolean() ? (x += 2) : (y += 2);\n-                }\n-            }\n-        },\n-\n@@ -1762,1 +1594,2 @@\n-            void build(int[] a, int m, Random random) {\n+            @Override\n+            void build(int[] a, int m) {\n@@ -1764,1 +1597,1 @@\n-                max = max < 2 ? 2 : max;\n+                max = Math.max(max, 2);\n@@ -1766,1 +1599,1 @@\n-                for (int i = 0; i < a.length; i++) {\n+                for (int i = 0; i < a.length; ++i) {\n@@ -1770,46 +1603,0 @@\n-        };\n-\n-        abstract void build(int[] a, int m, Random random);\n-    }\n-\n-    private static enum MergingBuilder {\n-        ASCENDING {\n-            void build(int[] a, int m) {\n-                int period = a.length \/ m;\n-                int v = 1, i = 0;\n-\n-                for (int k = 0; k < m; k++) {\n-                    v = 1;\n-\n-                    for (int p = 0; p < period; p++) {\n-                        a[i++] = v++;\n-                    }\n-                }\n-\n-                for (int j = i; j < a.length - 1; j++) {\n-                    a[j] = v++;\n-                }\n-\n-                a[a.length - 1] = 0;\n-            }\n-        },\n-\n-        DESCENDING {\n-            void build(int[] a, int m) {\n-                int period = a.length \/ m;\n-                int v = -1, i = 0;\n-\n-                for (int k = 0; k < m; k++) {\n-                    v = -1;\n-\n-                    for (int p = 0; p < period; p++) {\n-                        a[i++] = v--;\n-                    }\n-                }\n-\n-                for (int j = i; j < a.length - 1; j++) {\n-                    a[j] = v--;\n-                }\n-\n-                a[a.length - 1] = 0;\n-            }\n@@ -1819,0 +1606,1 @@\n+            @Override\n@@ -1820,3 +1608,1 @@\n-                for (int i = 0; i < a.length; i++) {\n-                    a[i] = 0;\n-                }\n+                Arrays.fill(a, 0);\n@@ -1828,0 +1614,1 @@\n+            @Override\n@@ -1829,1 +1616,1 @@\n-                for (int i = 0; i < a.length; i++) {\n+                for (int i = 0; i < a.length; ++i) {\n@@ -1832,1 +1619,1 @@\n-                reverse(a, 0, a.length - 1);\n+                reverse(a, m, a.length - 1);\n@@ -1837,0 +1624,1 @@\n+            @Override\n@@ -1838,1 +1626,1 @@\n-                for (int i = 0; i < a.length; i++) {\n+                for (int i = 0; i < a.length; ++i) {\n@@ -1841,1 +1629,1 @@\n-                reverse(a, 0, 2);\n+                reverse(a, 0, Math.min(m, a.length));\n@@ -1846,0 +1634,1 @@\n+            @Override\n@@ -1851,1 +1640,1 @@\n-                for (int i = 0, k = level; i < k1; i++) {\n+                for (int i = 0, k = level; i < k1; ++i) {\n@@ -1855,1 +1644,1 @@\n-                for (int i = k1; i < k2; i++) {\n+                for (int i = k1; i < k2; ++i) {\n@@ -1859,1 +1648,1 @@\n-                for (int i = k2, k = level; i < a.length; i++) {\n+                for (int i = k2, k = level; i < a.length; ++i) {\n@@ -1876,1 +1665,2 @@\n-    private static enum NegativeZeroBuilder {\n+    private enum NegativeZeroBuilder {\n+\n@@ -1878,0 +1668,1 @@\n+            @Override\n@@ -1881,1 +1672,1 @@\n-                for (int i = 0; i < a.length; i++) {\n+                for (int i = 0; i < a.length; ++i) {\n@@ -1888,0 +1679,1 @@\n+            @Override\n@@ -1891,1 +1683,1 @@\n-                for (int i = 0; i < a.length; i++) {\n+                for (int i = 0; i < a.length; ++i) {\n@@ -1900,1 +1692,2 @@\n-    private static enum FloatingPointBuilder {\n+    private enum FloatingPointBuilder {\n+\n@@ -1902,0 +1695,1 @@\n+            @Override\n@@ -1905,1 +1699,1 @@\n-                float[] x = (float[]) o;\n+                float[] data = (float[]) o;\n@@ -1908,1 +1702,7 @@\n-                writeValue(x, negativeValue, fromIndex, n);\n+                fillWithValue(data, Float.NEGATIVE_INFINITY, fromIndex, 1);\n+                fromIndex += 1;\n+\n+                fillWithValue(data, -Float.MAX_VALUE, fromIndex, 1);\n+                fromIndex += 1;\n+\n+                fillWithValue(data, negativeValue, fromIndex, n);\n@@ -1911,1 +1711,1 @@\n-                writeValue(x, -0.0f, fromIndex, g);\n+                fillWithValue(data, -0.0f, fromIndex, g);\n@@ -1914,1 +1714,1 @@\n-                writeValue(x, 0.0f, fromIndex, z);\n+                fillWithValue(data, 0.0f, fromIndex, z);\n@@ -1917,1 +1717,1 @@\n-                writeValue(x, positiveValue, fromIndex, p);\n+                fillWithValue(data, positiveValue, fromIndex, p);\n@@ -1920,1 +1720,7 @@\n-                writeValue(x, Float.NaN, fromIndex, a);\n+                fillWithValue(data, Float.MAX_VALUE, fromIndex, 1);\n+                fromIndex += 1;\n+\n+                fillWithValue(data, Float.POSITIVE_INFINITY, fromIndex, 1);\n+                fromIndex += 1;\n+\n+                fillWithValue(data, Float.NaN, fromIndex, a);\n@@ -1925,0 +1731,1 @@\n+            @Override\n@@ -1928,1 +1735,1 @@\n-                double[] x = (double[]) o;\n+                double[] data = (double[]) o;\n@@ -1931,1 +1738,7 @@\n-                writeValue(x, negativeValue, fromIndex, n);\n+                fillWithValue(data, Double.NEGATIVE_INFINITY, fromIndex, 1);\n+                fromIndex++;\n+\n+                fillWithValue(data, -Double.MAX_VALUE, fromIndex, 1);\n+                fromIndex++;\n+\n+                fillWithValue(data, negativeValue, fromIndex, n);\n@@ -1934,1 +1747,1 @@\n-                writeValue(x, -0.0d, fromIndex, g);\n+                fillWithValue(data, -0.0d, fromIndex, g);\n@@ -1937,1 +1750,1 @@\n-                writeValue(x, 0.0d, fromIndex, z);\n+                fillWithValue(data, 0.0d, fromIndex, z);\n@@ -1940,1 +1753,1 @@\n-                writeValue(x, positiveValue, fromIndex, p);\n+                fillWithValue(data, positiveValue, fromIndex, p);\n@@ -1943,1 +1756,7 @@\n-                writeValue(x, Double.NaN, fromIndex, a);\n+                fillWithValue(data, Double.MAX_VALUE, fromIndex, 1);\n+                fromIndex += 1;\n+\n+                fillWithValue(data, Double.POSITIVE_INFINITY, fromIndex, 1);\n+                fromIndex += 1;\n+\n+                fillWithValue(data, Double.NaN, fromIndex, a);\n@@ -1949,2 +1768,2 @@\n-        private static void writeValue(float[] a, float value, int fromIndex, int count) {\n-            for (int i = fromIndex; i < fromIndex + count; i++) {\n+        private static void fillWithValue(float[] a, float value, int fromIndex, int count) {\n+            for (int i = fromIndex; i < fromIndex + count; ++i) {\n@@ -1955,2 +1774,2 @@\n-        private static void writeValue(double[] a, double value, int fromIndex, int count) {\n-            for (int i = fromIndex; i < fromIndex + count; i++) {\n+        private static void fillWithValue(double[] a, double value, int fromIndex, int count) {\n+            for (int i = fromIndex; i < fromIndex + count; ++i) {\n@@ -1962,37 +1781,0 @@\n-    private static Comparator<Pair> pairComparator = new Comparator<Pair>() {\n-\n-        @Override\n-        public int compare(Pair p1, Pair p2) {\n-            return p1.compareTo(p2);\n-        }\n-    };\n-\n-    private static class Pair implements Comparable<Pair> {\n-\n-        private Pair(int key, int value) {\n-            this.key = key;\n-            this.value = value;\n-        }\n-\n-        int getKey() {\n-            return key;\n-        }\n-\n-        int getValue() {\n-            return value;\n-        }\n-\n-        @Override\n-        public int compareTo(Pair pair) {\n-            return Integer.compare(key, pair.key);\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return \"(\" + key + \", \" + value + \")\";\n-        }\n-\n-        private int key;\n-        private int value;\n-    }\n-\n@@ -2001,1 +1783,0 @@\n-        private static final TestRandom BABA = new TestRandom(0xBABA);\n@@ -2003,0 +1784,1 @@\n+        private static final TestRandom BABA = new TestRandom(0xBABA);\n@@ -2015,1 +1797,1 @@\n-        private String seed;\n+        private final String seed;\n","filename":"test\/jdk\/java\/util\/Arrays\/Sorting.java","additions":436,"deletions":654,"binary":false,"changes":1090,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,1 @@\n- * @version 2019.09.19\n+ * @version 2022.06.14\n@@ -34,1 +34,1 @@\n- * @since 14\n+ * @since 14 ^ 20\n@@ -39,0 +39,5 @@\n+        @Override\n+        public void sort(Object a, int low, int high) {\n+            sort(a, SEQUENTIAL, low, high);\n+        }\n+    },\n@@ -40,0 +45,1 @@\n+    PARALLEL_SORT(\"Parallel sort\") {\n@@ -41,18 +47,2 @@\n-        public void sort(Object a) {\n-            if (a instanceof int[]) {\n-                DualPivotQuicksort.sort((int[]) a, SEQUENTIAL, 0, ((int[]) a).length);\n-            } else if (a instanceof long[]) {\n-                DualPivotQuicksort.sort((long[]) a, SEQUENTIAL, 0, ((long[]) a).length);\n-            } else if (a instanceof byte[]) {\n-                DualPivotQuicksort.sort((byte[]) a, 0, ((byte[]) a).length);\n-            } else if (a instanceof char[]) {\n-                DualPivotQuicksort.sort((char[]) a, SEQUENTIAL, 0, ((char[]) a).length);\n-            } else if (a instanceof short[]) {\n-                DualPivotQuicksort.sort((short[]) a, SEQUENTIAL, 0, ((short[]) a).length);\n-            } else if (a instanceof float[]) {\n-                DualPivotQuicksort.sort((float[]) a, SEQUENTIAL, 0, ((float[]) a).length);\n-            } else if (a instanceof double[]) {\n-                DualPivotQuicksort.sort((double[]) a, SEQUENTIAL, 0, ((double[]) a).length);\n-            } else {\n-                fail(a);\n-            }\n+        public void sort(Object a, int low, int high) {\n+            sort(a, PARALLEL, low, high);\n@@ -60,0 +50,1 @@\n+    },\n@@ -61,0 +52,1 @@\n+    MIXED_INSERTION_SORT(\"Mixed insertion sort\") {\n@@ -64,1 +56,1 @@\n-                DualPivotQuicksort.sort((int[]) a, SEQUENTIAL, low, high);\n+                DualPivotQuicksort.mixedInsertionSort((int[]) a, low, high);\n@@ -66,1 +58,1 @@\n-                DualPivotQuicksort.sort((long[]) a, SEQUENTIAL, low, high);\n+                DualPivotQuicksort.mixedInsertionSort((long[]) a, low, high);\n@@ -70,1 +62,1 @@\n-                DualPivotQuicksort.sort((char[]) a, SEQUENTIAL, low, high);\n+                DualPivotQuicksort.sort((char[]) a, low, high);\n@@ -72,1 +64,1 @@\n-                DualPivotQuicksort.sort((short[]) a, SEQUENTIAL, low, high);\n+                DualPivotQuicksort.sort((short[]) a, low, high);\n@@ -74,1 +66,1 @@\n-                DualPivotQuicksort.sort((float[]) a, SEQUENTIAL, low, high);\n+                DualPivotQuicksort.mixedInsertionSort((float[]) a, low, high);\n@@ -76,1 +68,1 @@\n-                DualPivotQuicksort.sort((double[]) a, SEQUENTIAL, low, high);\n+                DualPivotQuicksort.mixedInsertionSort((double[]) a, low, high);\n@@ -81,10 +73,0 @@\n-\n-        @Override\n-        public void sort(Object[] a) {\n-            fail(a);\n-        }\n-\n-        @Override\n-        public void sort(Object[] a, Comparator comparator) {\n-            fail(a);\n-        }\n@@ -93,2 +75,1 @@\n-    PARALLEL_SORT(\"Parallel sort\") {\n-\n+    INSERTION_SORT(\"Insertion sort\") {\n@@ -96,1 +77,1 @@\n-        public void sort(Object a) {\n+        public void sort(Object a, int low, int high) {\n@@ -98,1 +79,1 @@\n-                DualPivotQuicksort.sort((int[]) a, PARALLEL, 0, ((int[]) a).length);\n+                DualPivotQuicksort.insertionSort((int[]) a, low, high);\n@@ -100,1 +81,1 @@\n-                DualPivotQuicksort.sort((long[]) a, PARALLEL, 0, ((long[]) a).length);\n+                DualPivotQuicksort.insertionSort((long[]) a, low, high);\n@@ -102,1 +83,1 @@\n-                DualPivotQuicksort.sort((byte[]) a, 0, ((byte[]) a).length);\n+                DualPivotQuicksort.insertionSort((byte[]) a, low, high);\n@@ -104,1 +85,1 @@\n-                DualPivotQuicksort.sort((char[]) a, PARALLEL, 0, ((char[]) a).length);\n+                DualPivotQuicksort.insertionSort((char[]) a, low, high);\n@@ -106,1 +87,1 @@\n-                DualPivotQuicksort.sort((short[]) a, PARALLEL, 0, ((short[]) a).length);\n+                DualPivotQuicksort.insertionSort((short[]) a, low, high);\n@@ -108,1 +89,1 @@\n-                DualPivotQuicksort.sort((float[]) a, PARALLEL, 0, ((float[]) a).length);\n+                DualPivotQuicksort.insertionSort((float[]) a, low, high);\n@@ -110,1 +91,1 @@\n-                DualPivotQuicksort.sort((double[]) a, PARALLEL, 0, ((double[]) a).length);\n+                DualPivotQuicksort.insertionSort((double[]) a, low, high);\n@@ -115,0 +96,1 @@\n+    },\n@@ -116,0 +98,1 @@\n+    MERGING_SORT(\"Merging sort\") {\n@@ -119,1 +102,1 @@\n-                DualPivotQuicksort.sort((int[]) a, PARALLEL, low, high);\n+                check(\"Merging\", DualPivotQuicksort.tryMergingSort(null, (int[]) a, low, high - low));\n@@ -121,1 +104,1 @@\n-                DualPivotQuicksort.sort((long[]) a, PARALLEL, low, high);\n+                check(\"Merging\", DualPivotQuicksort.tryMergingSort(null, (long[]) a, low, high - low));\n@@ -125,1 +108,1 @@\n-                DualPivotQuicksort.sort((char[]) a, PARALLEL, low, high);\n+                DualPivotQuicksort.sort((char[]) a, low, high);\n@@ -127,1 +110,1 @@\n-                DualPivotQuicksort.sort((short[]) a, PARALLEL, low, high);\n+                DualPivotQuicksort.sort((short[]) a, low, high);\n@@ -129,1 +112,1 @@\n-                DualPivotQuicksort.sort((float[]) a, PARALLEL, low, high);\n+                check(\"Merging\", DualPivotQuicksort.tryMergingSort(null, (float[]) a, low, high - low));\n@@ -131,1 +114,1 @@\n-                DualPivotQuicksort.sort((double[]) a, PARALLEL, low, high);\n+                check(\"Merging\", DualPivotQuicksort.tryMergingSort(null, (double[]) a, low, high - low));\n@@ -136,10 +119,0 @@\n-\n-        @Override\n-        public void sort(Object[] a) {\n-            fail(a);\n-        }\n-\n-        @Override\n-        public void sort(Object[] a, Comparator comparator) {\n-            fail(a);\n-        }\n@@ -148,2 +121,1 @@\n-    HEAP_SORT(\"Heap sort\") {\n-\n+    RADIX_SORT(\"Radix sort\") {\n@@ -151,1 +123,1 @@\n-        public void sort(Object a) {\n+        public void sort(Object a, int low, int high) {\n@@ -153,1 +125,1 @@\n-                DualPivotQuicksort.sort(null, (int[]) a, BIG_DEPTH, 0, ((int[]) a).length);\n+                check(\"Radix\", DualPivotQuicksort.tryRadixSort(null, (int[]) a, low, high));\n@@ -155,1 +127,1 @@\n-                DualPivotQuicksort.sort(null, (long[]) a, BIG_DEPTH, 0, ((long[]) a).length);\n+                check(\"Radix\", DualPivotQuicksort.tryRadixSort(null, (long[]) a, low, high));\n@@ -157,1 +129,1 @@\n-                DualPivotQuicksort.sort((byte[]) a, 0, ((byte[]) a).length);\n+                DualPivotQuicksort.sort((byte[]) a, low, high);\n@@ -159,1 +131,1 @@\n-                DualPivotQuicksort.sort((char[]) a, BIG_DEPTH, 0, ((char[]) a).length);\n+                DualPivotQuicksort.sort((char[]) a, low, high);\n@@ -161,1 +133,1 @@\n-                DualPivotQuicksort.sort((short[]) a, BIG_DEPTH, 0, ((short[]) a).length);\n+                DualPivotQuicksort.sort((short[]) a, low, high);\n@@ -163,1 +135,1 @@\n-                DualPivotQuicksort.sort(null, (float[]) a, BIG_DEPTH, 0, ((float[]) a).length);\n+                check(\"Radix\", DualPivotQuicksort.tryRadixSort(null, (float[]) a, low, high));\n@@ -165,1 +137,1 @@\n-                DualPivotQuicksort.sort(null, (double[]) a, BIG_DEPTH, 0, ((double[]) a).length);\n+                check(\"Radix\", DualPivotQuicksort.tryRadixSort(null, (double[]) a, low, high));\n@@ -170,0 +142,1 @@\n+    },\n@@ -171,0 +144,1 @@\n+    HEAP_SORT(\"Heap sort\") {\n@@ -174,1 +148,1 @@\n-                DualPivotQuicksort.sort(null, (int[]) a, BIG_DEPTH, low, high);\n+                DualPivotQuicksort.heapSort((int[]) a, low, high);\n@@ -176,1 +150,1 @@\n-                DualPivotQuicksort.sort(null, (long[]) a, BIG_DEPTH, low, high);\n+                DualPivotQuicksort.heapSort((long[]) a, low, high);\n@@ -180,1 +154,1 @@\n-                DualPivotQuicksort.sort((char[]) a, BIG_DEPTH, low, high);\n+                DualPivotQuicksort.sort((char[]) a, low, high);\n@@ -182,1 +156,1 @@\n-                DualPivotQuicksort.sort((short[]) a, BIG_DEPTH, low, high);\n+                DualPivotQuicksort.sort((short[]) a, low, high);\n@@ -184,1 +158,1 @@\n-                DualPivotQuicksort.sort(null, (float[]) a, BIG_DEPTH, low, high);\n+                DualPivotQuicksort.heapSort((float[]) a, low, high);\n@@ -186,1 +160,1 @@\n-                DualPivotQuicksort.sort(null, (double[]) a, BIG_DEPTH, low, high);\n+                DualPivotQuicksort.heapSort((double[]) a, low, high);\n@@ -191,10 +165,0 @@\n-\n-        @Override\n-        public void sort(Object[] a) {\n-            fail(a);\n-        }\n-\n-        @Override\n-        public void sort(Object[] a, Comparator comparator) {\n-            fail(a);\n-        }\n@@ -204,1 +168,0 @@\n-\n@@ -246,11 +209,0 @@\n-\n-        @Override\n-        public void sort(Object[] a) {\n-            Arrays.sort(a);\n-        }\n-\n-        @Override\n-        @SuppressWarnings(\"unchecked\")\n-        public void sort(Object[] a, Comparator comparator) {\n-            Arrays.sort(a, comparator);\n-        }\n@@ -260,1 +212,0 @@\n-\n@@ -302,12 +253,0 @@\n-\n-        @Override\n-        @SuppressWarnings(\"unchecked\")\n-        public void sort(Object[] a) {\n-            Arrays.parallelSort((Comparable[]) a);\n-        }\n-\n-        @Override\n-        @SuppressWarnings(\"unchecked\")\n-        public void sort(Object[] a, Comparator comparator) {\n-            Arrays.parallelSort(a, comparator);\n-        }\n@@ -316,2 +255,0 @@\n-    abstract public void sort(Object a);\n-\n@@ -320,3 +257,19 @@\n-    abstract public void sort(Object[] a);\n-\n-    abstract public void sort(Object[] a, Comparator comparator);\n+    public void sort(Object a) {\n+        if (a instanceof int[]) {\n+            sort(a, 0, ((int[]) a).length);\n+        } else if (a instanceof long[]) {\n+            sort(a, 0, ((long[]) a).length);\n+        } else if (a instanceof byte[]) {\n+            sort(a, 0, ((byte[]) a).length);\n+        } else if (a instanceof char[]) {\n+            sort(a, 0, ((char[]) a).length);\n+        } else if (a instanceof short[]) {\n+            sort(a, 0, ((short[]) a).length);\n+        } else if (a instanceof float[]) {\n+            sort(a, 0, ((float[]) a).length);\n+        } else if (a instanceof double[]) {\n+            sort(a, 0, ((double[]) a).length);\n+        } else {\n+            fail(a);\n+        }\n+    }\n@@ -324,1 +277,1 @@\n-    private SortingHelper(String name) {\n+    SortingHelper(String name) {\n@@ -333,0 +286,26 @@\n+    static void sort(Object a, int parallelism, int low, int high) {\n+        if (a instanceof int[]) {\n+            DualPivotQuicksort.sort((int[]) a, parallelism, low, high);\n+        } else if (a instanceof long[]) {\n+            DualPivotQuicksort.sort((long[]) a, parallelism, low, high);\n+        } else if (a instanceof byte[]) {\n+            DualPivotQuicksort.sort((byte[]) a, low, high);\n+        } else if (a instanceof char[]) {\n+            DualPivotQuicksort.sort((char[]) a, low, high);\n+        } else if (a instanceof short[]) {\n+            DualPivotQuicksort.sort((short[]) a, low, high);\n+        } else if (a instanceof float[]) {\n+            DualPivotQuicksort.sort((float[]) a, parallelism, low, high);\n+        } else if (a instanceof double[]) {\n+            DualPivotQuicksort.sort((double[]) a, parallelism, low, high);\n+        } else {\n+            fail(a);\n+        }\n+    }\n+\n+    private static void check(String name, boolean result) {\n+        if (!result) {\n+            fail(name + \" sort must return true\");\n+        }\n+    }\n+\n@@ -334,1 +313,5 @@\n-        throw new RuntimeException(\"Unexpected type of array: \" + a.getClass().getName());\n+        fail(\"Unknown array: \" + a.getClass().getName());\n+    }\n+\n+    private static void fail(String message) {\n+        throw new RuntimeException(message);\n@@ -337,1 +320,1 @@\n-    private String name;\n+    private final String name;\n@@ -340,1 +323,1 @@\n-     * Parallelism level for sequential and parallel sorting.\n+     * Parallelism level for sequential sorting.\n@@ -343,1 +326,0 @@\n-    private static final int PARALLEL = 87;\n@@ -346,2 +328,1 @@\n-     * Heap sort will be invoked, if recursion depth is too big.\n-     * Value is taken from DualPivotQuicksort.MAX_RECURSION_DEPTH.\n+     * Parallelism level for parallel sorting.\n@@ -349,1 +330,1 @@\n-    private static final int BIG_DEPTH = 64 * (3 << 1);\n+    private static final int PARALLEL = 88;\n","filename":"test\/jdk\/java\/util\/Arrays\/java.base\/java\/util\/SortingHelper.java","additions":108,"deletions":127,"binary":false,"changes":235,"status":"modified"},{"patch":"@@ -23,1 +23,6 @@\n-package org.openjdk.bench.java.lang;\n+\n+package org.openjdk.bench.java.util;\n+\n+import java.util.Arrays;\n+import java.util.Random;\n+import java.util.concurrent.TimeUnit;\n@@ -28,0 +33,1 @@\n+import org.openjdk.jmh.annotations.Level;\n@@ -30,1 +36,0 @@\n-import org.openjdk.jmh.annotations.OperationsPerInvocation;\n@@ -36,1 +41,0 @@\n-import org.openjdk.jmh.annotations.Level;\n@@ -38,8 +42,0 @@\n-import org.openjdk.jmh.infra.Blackhole;\n-import java.util.Arrays;\n-import java.util.Random;\n-import java.util.concurrent.TimeUnit;\n-import java.io.UnsupportedEncodingException;\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.MethodHandles;\n-import java.lang.reflect.Method;\n@@ -48,1 +44,7 @@\n- * Performance test of Arrays.sort() methods\n+ * Microbenchmark for Arrays.sort() and Arrays.parallelSort().\n+ *\n+ * @author Vladimir Yaroslavskiy\n+ *\n+ * @version 2022.06.14\n+ *\n+ * @since 22\n@@ -50,1 +52,1 @@\n-@Fork(value=1, jvmArgsAppend={\"-XX:CompileThreshold=1\", \"-XX:-TieredCompilation\"})\n+@State(Scope.Benchmark)\n@@ -53,3 +55,3 @@\n-@State(Scope.Thread)\n-@Warmup(iterations = 3, time=5)\n-@Measurement(iterations = 3, time=3)\n+@Warmup(iterations = 2, time = 3, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 4, time = 3, timeUnit = TimeUnit.SECONDS)\n+@Fork(value=1, jvmArgsAppend={\"-XX:CompileThreshold=1\", \"-XX:-TieredCompilation\"})\n@@ -58,43 +60,7 @@\n-    @Param({\"10\",\"25\",\"50\",\"75\",\"100\", \"1000\", \"10000\", \"100000\", \"1000000\"})\n-    private int size;\n-\n-    private int[] ints_unsorted;\n-    private long[] longs_unsorted;\n-    private float[] floats_unsorted;\n-    private double[] doubles_unsorted;\n-\n-    private int[] ints_sorted;\n-    private long[] longs_sorted;\n-    private float[] floats_sorted;\n-    private double[] doubles_sorted;\n-\n-\n-    public void initialize() {\n-        Random rnd = new Random(42);\n-\n-        ints_unsorted = new int[size];\n-        longs_unsorted = new long[size];\n-        floats_unsorted = new float[size];\n-        doubles_unsorted = new double[size];\n-\n-        int[] intSpecialCases = {Integer.MIN_VALUE, Integer.MAX_VALUE};\n-        long[] longSpecialCases = {Long.MIN_VALUE, Long.MAX_VALUE};\n-        float[] floatSpecialCases = {+0.0f, -0.0f, Float.POSITIVE_INFINITY, Float.NEGATIVE_INFINITY, Float.NaN};\n-        double[] doubleSpecialCases = {+0.0, -0.0, Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY, Double.NaN};\n-\n-        for (int i = 0; i < size; i++) {\n-            ints_unsorted[i] = rnd.nextInt();\n-            longs_unsorted[i] = rnd.nextLong();\n-            if (i % 10 != 0) {\n-                ints_unsorted[i] = rnd.nextInt();\n-                longs_unsorted[i] = rnd.nextLong();\n-                floats_unsorted[i] = rnd.nextFloat();\n-                doubles_unsorted[i] = rnd.nextDouble();\n-            } else {\n-                ints_unsorted[i] = intSpecialCases[rnd.nextInt(intSpecialCases.length)];\n-                longs_unsorted[i] = longSpecialCases[rnd.nextInt(longSpecialCases.length)];\n-                floats_unsorted[i] = floatSpecialCases[rnd.nextInt(floatSpecialCases.length)];\n-                doubles_unsorted[i] = doubleSpecialCases[rnd.nextInt(doubleSpecialCases.length)];\n-            }\n-        }\n-    }\n+    @Param({ \"600\", \"9000\", \"20000\", \"400000\", \"3000000\" })\n+    int size;\n+\n+    @Param\n+    Builder builder;\n+\n+    int[] b;\n@@ -103,2 +69,2 @@\n-    public void setup() throws UnsupportedEncodingException, ClassNotFoundException, NoSuchMethodException, Throwable {\n-        initialize();\n+    public void init() {\n+        b = new int[size];\n@@ -107,7 +73,1 @@\n-    @Setup(Level.Invocation)\n-    public void clear() {\n-        ints_sorted = ints_unsorted.clone();\n-        longs_sorted = longs_unsorted.clone();\n-        floats_sorted = floats_unsorted.clone();\n-        doubles_sorted = doubles_unsorted.clone();\n-    }\n+    public enum Builder {\n@@ -115,5 +75,21 @@\n-    @Benchmark\n-    public int[] intSort() throws Throwable {\n-        Arrays.sort(ints_sorted);\n-        return ints_sorted;\n-    }\n+        RANDOM {\n+            @Override\n+            void build(int[] b) {\n+                Random random = new Random(0x888);\n+\n+                for (int i = 0; i < b.length; ++i) {\n+                    b[i] = random.nextInt();\n+                }\n+            }\n+        },\n+\n+        REPEATED {\n+            @Override\n+            void build(int[] b) {\n+                Random random = new Random(0x555);\n+\n+                for (int i = 0; i < b.length; ++i) {\n+                    b[i] = random.nextInt(5);\n+                }\n+            }\n+        },\n@@ -121,4 +97,21 @@\n-    @Benchmark\n-    public int[] intParallelSort() throws Throwable {\n-        Arrays.parallelSort(ints_sorted);\n-        return ints_sorted;\n+        STAGGER {\n+            @Override\n+            void build(int[] b) {\n+                for (int i = 0; i < b.length; ++i) {\n+                    b[i] = (i * 7) % b.length;\n+                }\n+            }\n+        },\n+\n+        SHUFFLE {\n+            @Override\n+            void build(int[] b) {\n+                Random random = new Random(0x555);\n+\n+                for (int i = 0, j = 0, k = 1; i < b.length; ++i) {\n+                    b[i] = random.nextInt(8) > 0 ? (j += 2) : (k += 2);\n+                }\n+            }\n+        };\n+\n+        abstract void build(int[] b);\n@@ -127,4 +120,16 @@\n-    @Benchmark\n-    public long[] longSort() throws Throwable {\n-        Arrays.sort(longs_sorted);\n-        return longs_sorted;\n+    public static class Int extends ArraysSort {\n+\n+        @Setup(Level.Invocation)\n+        public void build() {\n+            builder.build(b);\n+        }\n+\n+        @Benchmark\n+        public void testSort() {\n+            Arrays.sort(b);\n+        }\n+\n+        @Benchmark\n+        public void testParallelSort() {\n+            Arrays.parallelSort(b);\n+        }\n@@ -133,4 +138,27 @@\n-    @Benchmark\n-    public long[] longParallelSort() throws Throwable {\n-        Arrays.parallelSort(longs_sorted);\n-        return longs_sorted;\n+    public static class Long extends ArraysSort {\n+\n+        long[] a;\n+\n+        @Setup\n+        public void setup() {\n+            a = new long[size];\n+        }\n+\n+        @Setup(Level.Invocation)\n+        public void build() {\n+            builder.build(b);\n+\n+            for (int i = 0; i < size; ++i) {\n+                a[i] = b[i];\n+            }\n+        }\n+\n+        @Benchmark\n+        public void testSort() {\n+            Arrays.sort(a);\n+        }\n+\n+        @Benchmark\n+        public void testParallelSort() {\n+            Arrays.parallelSort(a);\n+        }\n@@ -139,4 +167,27 @@\n-    @Benchmark\n-    public float[] floatSort() throws Throwable {\n-        Arrays.sort(floats_sorted);\n-        return floats_sorted;\n+    public static class Byte extends ArraysSort {\n+\n+        byte[] a;\n+\n+        @Setup\n+        public void setup() {\n+            a = new byte[size];\n+        }\n+\n+        @Setup(Level.Invocation)\n+        public void build() {\n+            builder.build(b);\n+\n+            for (int i = 0; i < size; ++i) {\n+                a[i] = (byte) b[i];\n+            }\n+        }\n+\n+        @Benchmark\n+        public void testSort() {\n+            Arrays.sort(a);\n+        }\n+\n+        @Benchmark\n+        public void testParallelSort() {\n+            Arrays.parallelSort(a);\n+        }\n@@ -145,4 +196,27 @@\n-    @Benchmark\n-    public float[] floatParallelSort() throws Throwable {\n-        Arrays.parallelSort(floats_sorted);\n-        return floats_sorted;\n+    public static class Char extends ArraysSort {\n+\n+        char[] a;\n+\n+        @Setup\n+        public void setup() {\n+            a = new char[size];\n+        }\n+\n+        @Setup(Level.Invocation)\n+        public void build() {\n+            builder.build(b);\n+\n+            for (int i = 0; i < size; ++i) {\n+                a[i] = (char) b[i];\n+            }\n+        }\n+\n+        @Benchmark\n+        public void testSort() {\n+            Arrays.sort(a);\n+        }\n+\n+        @Benchmark\n+        public void testParallelSort() {\n+            Arrays.parallelSort(a);\n+        }\n@@ -151,4 +225,27 @@\n-    @Benchmark\n-    public double[] doubleSort() throws Throwable {\n-        Arrays.sort(doubles_sorted);\n-        return doubles_sorted;\n+    public static class Short extends ArraysSort {\n+\n+        short[] a;\n+\n+        @Setup\n+        public void setup() {\n+            a = new short[size];\n+        }\n+\n+        @Setup(Level.Invocation)\n+        public void build() {\n+            builder.build(b);\n+\n+            for (int i = 0; i < size; ++i) {\n+                a[i] = (short) b[i];\n+            }\n+        }\n+\n+        @Benchmark\n+        public void testSort() {\n+            Arrays.sort(a);\n+        }\n+\n+        @Benchmark\n+        public void testParallelSort() {\n+            Arrays.parallelSort(a);\n+        }\n@@ -157,4 +254,27 @@\n-    @Benchmark\n-    public double[] doubleParallelSort() throws Throwable {\n-        Arrays.parallelSort(doubles_sorted);\n-        return doubles_sorted;\n+    public static class Float extends ArraysSort {\n+\n+        float[] a;\n+\n+        @Setup\n+        public void setup() {\n+            a = new float[size];\n+        }\n+\n+        @Setup(Level.Invocation)\n+        public void build() {\n+            builder.build(b);\n+\n+            for (int i = 0; i < size; ++i) {\n+                a[i] = b[i];\n+            }\n+        }\n+\n+        @Benchmark\n+        public void testSort() {\n+            Arrays.sort(a);\n+        }\n+\n+        @Benchmark\n+        public void testParallelSort() {\n+            Arrays.parallelSort(a);\n+        }\n@@ -163,0 +283,28 @@\n+    public static class Double extends ArraysSort {\n+\n+        double[] a;\n+\n+        @Setup\n+        public void setup() {\n+            a = new double[size];\n+        }\n+\n+        @Setup(Level.Invocation)\n+        public void build() {\n+            builder.build(b);\n+\n+            for (int i = 0; i < size; ++i) {\n+                a[i] = b[i];\n+            }\n+        }\n+\n+        @Benchmark\n+        public void testSort() {\n+            Arrays.sort(a);\n+        }\n+\n+        @Benchmark\n+        public void testParallelSort() {\n+            Arrays.parallelSort(a);\n+        }\n+    }\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/ArraysSort.java","additions":249,"deletions":101,"binary":false,"changes":350,"status":"modified"}]}