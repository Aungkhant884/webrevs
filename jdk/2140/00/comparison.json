{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -1211,0 +1211,16 @@\n+void PhaseCFG::verify_memory_writer_placement(const Block* b, const Node* n) const {\n+#ifdef ASSERT\n+  assert(n->is_memory_writer(), \"n must be a memory writer\");\n+  CFGLoop* home_or_ancestor = find_block_for_node(n->in(0))->_loop;\n+  bool found = false;\n+  do {\n+    if (b->_loop == home_or_ancestor) {\n+      found = true;\n+      break;\n+    }\n+    home_or_ancestor = home_or_ancestor->parent();\n+  } while (home_or_ancestor != NULL);\n+  assert(found, \"block b is not in n's home loop or an ancestor of it\");\n+#endif\n+}\n+\n@@ -1224,0 +1240,3 @@\n+      if (n->is_memory_writer()) {\n+        verify_memory_writer_placement(block, n);\n+      }\n","filename":"src\/hotspot\/share\/opto\/block.cpp","additions":20,"deletions":1,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -623,0 +623,2 @@\n+  \/\/ Check that block b is in the home loop (or an ancestor) of memory writer n.\n+  void verify_memory_writer_placement(const Block* b, const Node* n) const;\n@@ -722,0 +724,1 @@\n+  int depth() { return _depth; }\n","filename":"src\/hotspot\/share\/opto\/block.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -1166,0 +1166,12 @@\n+    if (self->is_memory_writer() &&\n+        (LCA->_loop->depth() > early->_loop->depth())) {\n+      \/\/ LCA is an invalid placement for a memory writer: choosing it would\n+      \/\/ cause memory interference, as illustrated in schedule_late().\n+      continue;\n+    }\n+#ifdef ASSERT\n+    if (self->is_memory_writer()) {\n+      verify_memory_writer_placement(LCA, self);\n+    }\n+#endif\n+\n@@ -1253,0 +1265,11 @@\n+#ifdef ASSERT\n+    \/\/ Assert that memory writers (e.g. stores) have a \"home\" block (the block\n+    \/\/ given by their control input), and that this block corresponds to their\n+    \/\/ earliest possible placement. This guarantees that\n+    \/\/ hoist_to_cheaper_block() will always have at least one valid choice.\n+    if (self->is_memory_writer()) {\n+      assert(find_block_for_node(self->in(0)) == early,\n+             \"The home of a memory writer must also be its earliest placement\");\n+    }\n+#endif\n+\n@@ -1277,5 +1300,4 @@\n-      if (C->has_irreducible_loop() && self->bottom_type()->has_memory()) {\n-        \/\/ If the CFG is irreducible, keep memory-writing nodes as close as\n-        \/\/ possible to their original block (given by the control input). This\n-        \/\/ prevents PhaseCFG::hoist_to_cheaper_block() from placing such nodes\n-        \/\/ into descendants of their original loop, as in the following example:\n+      if (C->has_irreducible_loop() && self->is_memory_writer()) {\n+        \/\/ If the CFG is irreducible, place memory writers in their home block.\n+        \/\/ This prevents hoist_to_cheaper_block() from accidentally placing such\n+        \/\/ nodes into deeper loops, as in the following example:\n@@ -1283,1 +1305,1 @@\n-        \/\/ Original placement of store in B1 (loop L1):\n+        \/\/ Home placement of store in B1 (loop L1):\n@@ -1304,3 +1326,7 @@\n-        \/\/ This \"hoist inversion\" can happen due to CFGLoop::compute_freq()'s\n-        \/\/ inaccurate estimation of frequencies for irreducible CFGs, which can\n-        \/\/ lead to for example assigning B1 and B3 a higher frequency than B2.\n+        \/\/ This \"hoist inversion\" can happen due to different factors such as\n+        \/\/ inaccurate estimation of frequencies for irreducible CFGs, and loops\n+        \/\/ with always-taken exits in reducible CFGs. In the reducible case,\n+        \/\/ hoist inversion is prevented by discarding invalid blocks (those in\n+        \/\/ deeper loops than the home block). In the irreducible case, the\n+        \/\/ invalid blocks cannot be identified due to incomplete loop nesting\n+        \/\/ information, hence a conservative solution is taken.\n@@ -1309,1 +1335,1 @@\n-          tty->print_cr(\"# Irreducible loops: schedule in earliest block B%d:\",\n+          tty->print_cr(\"# Irreducible loops: schedule in home block B%d:\",\n@@ -1362,0 +1388,12 @@\n+    if (self->is_memory_writer()) {\n+      \/\/ If the LCA of a memory writer is a descendant of its home loop, hoist\n+      \/\/ it into a valid placement.\n+      while (LCA->_loop->depth() > early->_loop->depth()) {\n+        LCA = LCA->_idom;\n+      }\n+#ifdef ASSERT\n+      assert(LCA != NULL, \"a valid LCA must exist\");\n+      verify_memory_writer_placement(LCA, self);\n+#endif\n+    }\n+\n","filename":"src\/hotspot\/share\/opto\/gcm.cpp","additions":49,"deletions":11,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -104,1 +104,1 @@\n-  store_to_memory(NULL, adr_sp, last_sp, T_ADDRESS, NoAlias, MemNode::unordered);\n+  store_to_memory(control(), adr_sp, last_sp, T_ADDRESS, NoAlias, MemNode::unordered);\n@@ -225,1 +225,1 @@\n-  store_to_memory(NULL, adr_sp, null(), T_ADDRESS, NoAlias, MemNode::unordered);\n+  store_to_memory(control(), adr_sp, null(), T_ADDRESS, NoAlias, MemNode::unordered);\n@@ -227,1 +227,1 @@\n-  store_to_memory(NULL, adr_last_Java_pc, null(), T_ADDRESS, NoAlias, MemNode::unordered);\n+  store_to_memory(control(), adr_last_Java_pc, null(), T_ADDRESS, NoAlias, MemNode::unordered);\n@@ -230,1 +230,1 @@\n-  store_to_memory(NULL, adr_last_Java_fp, null(), T_ADDRESS, NoAlias, MemNode::unordered);\n+  store_to_memory(control(), adr_last_Java_fp, null(), T_ADDRESS, NoAlias, MemNode::unordered);\n@@ -241,1 +241,1 @@\n-    store_to_memory(NULL, adr, null(), T_ADDRESS, NoAlias, MemNode::unordered);\n+    store_to_memory(control(), adr, null(), T_ADDRESS, NoAlias, MemNode::unordered);\n","filename":"src\/hotspot\/share\/opto\/generateOptoStub.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1151,0 +1151,3 @@\n+  \/\/ Whether this is a memory-writing machine node.\n+  bool is_memory_writer() const { return is_Mach() && bottom_type()->has_memory(); }\n+\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,2 +30,3 @@\n- * @bug 8255763\n- * @summary Tests GCM's store placement for reducible and irreducible CFGs.\n+ * @bug 8255763 8258894\n+ * @summary Tests GCM's store placement in different scenarios (regular and OSR\n+ *          compilations, reducible and irreducible CFGs).\n@@ -33,2 +34,7 @@\n- * @run main\/othervm -Xbatch compiler.codegen.TestGCMStorePlacement reducible\n- * @run main\/othervm -Xbatch compiler.codegen.TestGCMStorePlacement irreducible\n+ * @run main\/othervm -Xbatch compiler.codegen.TestGCMStorePlacement regularReducible1\n+ * @run main\/othervm -Xcomp -XX:-TieredCompilation -XX:CompileOnly=compiler.codegen.TestGCMStorePlacement:: compiler.codegen.TestGCMStorePlacement regularReducible2\n+ * @run main\/othervm -Xcomp -XX:CompileOnly=compiler.codegen.TestGCMStorePlacement:: compiler.codegen.TestGCMStorePlacement regularReducible3\n+ * @run main\/othervm -Xcomp -XX:CompileOnly=compiler.codegen.TestGCMStorePlacement:: compiler.codegen.TestGCMStorePlacement regularReducible4\n+ * @run main\/othervm -Xcomp -XX:-TieredCompilation -XX:CompileOnly=compiler.codegen.TestGCMStorePlacement:: compiler.codegen.TestGCMStorePlacement osrReducible1\n+ * @run main\/othervm -Xcomp -XX:-TieredCompilation -XX:CompileOnly=compiler.codegen.TestGCMStorePlacement:: compiler.codegen.TestGCMStorePlacement osrReducible2\n+ * @run main\/othervm -Xbatch compiler.codegen.TestGCMStorePlacement osrIrreducible1\n@@ -39,1 +45,2 @@\n-    static int counter;\n+    static int intCounter;\n+    static long longCounter;\n@@ -41,3 +48,3 @@\n-    \/\/ Reducible case: counter++ should not be placed into the loop.\n-    static void testReducible() {\n-        counter++;\n+    static void testRegularReducible1() {\n+        \/\/ This should not be placed into the loop.\n+        intCounter++;\n@@ -53,3 +60,98 @@\n-    \/\/ Irreducible case (due to OSR compilation): counter++ should not be placed\n-    \/\/ outside its switch case block.\n-    static void testIrreducible() {\n+    static void testRegularReducible2() {\n+        int i;\n+        for (i = 22; i < 384; i++)\n+            longCounter += 1;\n+        switch (i % 9) {\n+        case 49:\n+            int i17 = 70;\n+            while (i17 > 0) {\n+                longCounter = 42;\n+                switch (9) {\n+                case 97:\n+                    break;\n+                case 11398:\n+                    for (int i18 = 1; ; );\n+                default:\n+                }\n+            }\n+        }\n+    }\n+\n+    static void testRegularReducible3() {\n+        int i = 0, i23, i27 = 184;\n+        for (int i21 = 0; i21 < 100; i21++) {\n+            i23 = 1;\n+            longCounter += 1;\n+            while (++i23 < 190)\n+                switch (i23 % 10) {\n+                case 86:\n+                    continue;\n+                case 0:\n+                    i += 76.854F;\n+                    for (; i27 < 1; i27++);\n+                }\n+        }\n+    }\n+\n+    static void testRegularReducible4() {\n+        int i16 = 0, i17;\n+        longCounter += 1;\n+        while (++i16 < 100) {\n+            i17 = 0;\n+            while (++i17 < 200) {\n+                switch ((i16 * 5) + 123) {\n+                case 129:\n+                    break;\n+                case 149:\n+                    break;\n+                default:\n+                }\n+            }\n+        }\n+    }\n+\n+    public static void bar() {\n+        int[] a = new int[0];\n+        long sum = 0;\n+        for (int j = 0; j < 0; j++) {\n+            sum += (a[j] \/ (j + 1) + a[j] % (j + 1));\n+        }\n+    }\n+    static void foo() {\n+        bar();\n+    }\n+\n+    static void testOsrReducible1() {\n+        int count = 100;\n+        for (int i = 0; i < 100; i++) {\n+            for (int j = 0; j < 100; j++) {\n+                foo();\n+                try {\n+                    count = (100000 \/ count);\n+                } catch (Exception e) {}\n+                switch (0) {\n+                case 0:\n+                    for (int k = 0; k < 2; k++) {\n+                        count = 0;\n+                    }\n+                    longCounter += 1;\n+                }\n+            }\n+        }\n+    }\n+\n+    static void testOsrReducible2() {\n+        System.out.println();\n+        boolean cond = false;\n+        for (int i = 0; i < 100; i++) {\n+            for (int j = 0; j < 100; j++) {\n+                intCounter = 42;\n+                if (cond) {\n+                    break;\n+                }\n+                for (int k = 0; k < 2; k++);\n+            }\n+        }\n+    }\n+\n+    static void testOsrIrreducible1() {\n@@ -66,1 +168,2 @@\n-                counter++;\n+                \/\/ This should not be placed outside the \"case 0\" block.\n+                intCounter++;\n@@ -79,2 +182,1 @@\n-        case \"reducible\":\n-            \/\/ Cause a regular C2 compilation of testReducible.\n+        case \"regularReducible1\":\n@@ -82,3 +184,15 @@\n-                counter = 0;\n-                testReducible();\n-                Asserts.assertEQ(counter, 1);\n+                intCounter = 0;\n+                testRegularReducible1();\n+                Asserts.assertEQ(intCounter, 1);\n+            }\n+            break;\n+        case \"regularReducible2\":\n+            longCounter = 0;\n+            testRegularReducible2();\n+            Asserts.assertEQ(longCounter, 362L);\n+            break;\n+        case \"regularReducible3\":\n+            for (int i = 0; i < 10; i++) {\n+                longCounter = 0;\n+                testRegularReducible3();\n+                Asserts.assertEQ(longCounter, 100L);\n@@ -87,5 +201,21 @@\n-        case \"irreducible\":\n-            \/\/ Cause an OSR C2 compilation of testIrreducible.\n-            counter = 0;\n-            testIrreducible();\n-            Asserts.assertEQ(counter, 10);\n+        case \"regularReducible4\":\n+            for (int i = 0; i < 10; i++) {\n+                longCounter = 0;\n+                testRegularReducible4();\n+                Asserts.assertEQ(longCounter, 1L);\n+            }\n+            break;\n+        case \"osrReducible1\":\n+            longCounter = 0;\n+            testOsrReducible1();\n+            Asserts.assertEQ(longCounter, 10000L);\n+            break;\n+        case \"osrReducible2\":\n+            intCounter = 0;\n+            testOsrReducible2();\n+            Asserts.assertEQ(intCounter, 42);\n+            break;\n+        case \"osrIrreducible1\":\n+            intCounter = 0;\n+            testOsrIrreducible1();\n+            Asserts.assertEQ(intCounter, 10);\n","filename":"test\/hotspot\/jtreg\/compiler\/codegen\/TestGCMStorePlacement.java","additions":153,"deletions":23,"binary":false,"changes":176,"status":"modified"}]}