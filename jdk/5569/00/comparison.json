{"files":[{"patch":"@@ -42,1 +42,1 @@\n-import static sun.security.pkcs11.wrapper.PKCS11Exception.*;\n+import static sun.security.pkcs11.wrapper.PKCS11Exception.RV.*;\n@@ -396,1 +396,1 @@\n-            if (e.getErrorCode() == CKR_MECHANISM_PARAM_INVALID) {\n+            if (e.match(CKR_MECHANISM_PARAM_INVALID)) {\n@@ -419,1 +419,1 @@\n-            if (e.getErrorCode() == CKR_OPERATION_NOT_INITIALIZED) {\n+            if (e.match(CKR_OPERATION_NOT_INITIALIZED)) {\n@@ -815,2 +815,1 @@\n-        long errorCode = e.getErrorCode();\n-        if (errorCode == CKR_BUFFER_TOO_SMALL) {\n+        if (e.match(CKR_BUFFER_TOO_SMALL)) {\n@@ -819,2 +818,2 @@\n-        } else if (errorCode == CKR_DATA_LEN_RANGE ||\n-                   errorCode == CKR_ENCRYPTED_DATA_LEN_RANGE) {\n+        } else if (e.match(CKR_DATA_LEN_RANGE) ||\n+                e.match(CKR_ENCRYPTED_DATA_LEN_RANGE)) {\n@@ -823,3 +822,3 @@\n-        } else if (errorCode == CKR_ENCRYPTED_DATA_INVALID ||\n-                \/\/ Solaris-specific\n-                errorCode == CKR_GENERAL_ERROR) {\n+        } else if (e.match(CKR_ENCRYPTED_DATA_INVALID) ||\n+                e.match(CKR_GENERAL_ERROR)) {\n+            \/\/ CKR_GENERAL_ERROR is Solaris-specific workaround\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11AEADCipher.java","additions":9,"deletions":10,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-import static sun.security.pkcs11.wrapper.PKCS11Exception.*;\n+import static sun.security.pkcs11.wrapper.PKCS11Exception.RV.*;\n@@ -459,1 +459,1 @@\n-            if (e.getErrorCode() == CKR_OPERATION_NOT_INITIALIZED) {\n+            if (e.match(CKR_OPERATION_NOT_INITIALIZED)) {\n@@ -659,1 +659,1 @@\n-            if (e.getErrorCode() == CKR_BUFFER_TOO_SMALL) {\n+            if (e.match(CKR_BUFFER_TOO_SMALL)) {\n@@ -783,1 +783,1 @@\n-            if (e.getErrorCode() == CKR_BUFFER_TOO_SMALL) {\n+            if (e.match(CKR_BUFFER_TOO_SMALL)) {\n@@ -965,2 +965,1 @@\n-        long errorCode = e.getErrorCode();\n-        if (errorCode == CKR_BUFFER_TOO_SMALL) {\n+        if (e.match(CKR_BUFFER_TOO_SMALL)) {\n@@ -969,2 +968,2 @@\n-        } else if (errorCode == CKR_DATA_LEN_RANGE ||\n-                   errorCode == CKR_ENCRYPTED_DATA_LEN_RANGE) {\n+        } else if (e.match(CKR_DATA_LEN_RANGE) ||\n+                e.match(CKR_ENCRYPTED_DATA_LEN_RANGE)) {\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11Cipher.java","additions":7,"deletions":8,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -30,1 +30,3 @@\n-\n+import java.util.Map;\n+import java.util.HashMap;\n+import java.util.Locale;\n@@ -32,0 +34,2 @@\n+import static sun.security.pkcs11.wrapper.PKCS11Constants.*;\n+\n@@ -58,0 +62,22 @@\n+    private static final Map<String,Long> keyTypes;\n+\n+    static {\n+        keyTypes = new HashMap<String,Long>();\n+        addKeyType(\"RSA\", CKK_RSA);\n+        addKeyType(\"DSA\", CKK_DSA);\n+        addKeyType(\"DH\",  CKK_DH);\n+        addKeyType(\"EC\",  CKK_EC);\n+    }\n+\n+    private static void addKeyType(String name, long id) {\n+        Long l = Long.valueOf(id);\n+        keyTypes.put(name, l);\n+        keyTypes.put(name.toUpperCase(Locale.ENGLISH), l);\n+    }\n+\n+    \/\/ returns the PKCS11 key type of the specified algorithm\n+    static long getPKCS11KeyType(String algorithm) {\n+        Long kt = keyTypes.get(algorithm);\n+        return (kt != null) ? kt.longValue() : -1;\n+    }\n+\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11KeyFactory.java","additions":27,"deletions":1,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -76,1 +76,1 @@\n-import static sun.security.pkcs11.wrapper.PKCS11Exception.*;\n+import static sun.security.pkcs11.wrapper.PKCS11Exception.RV.*;\n@@ -760,1 +760,1 @@\n-                if (pe.getErrorCode() == CKR_PIN_INCORRECT) {\n+                if (pe.match(CKR_PIN_INCORRECT)) {\n@@ -2333,1 +2333,1 @@\n-                    if (pe.getErrorCode() != CKR_ATTRIBUTE_TYPE_INVALID) {\n+                    if (!pe.match(CKR_ATTRIBUTE_TYPE_INVALID)) {\n@@ -2374,1 +2374,1 @@\n-                            if (pe.getErrorCode() == CKR_ATTRIBUTE_TYPE_INVALID) {\n+                            if (pe.match(CKR_ATTRIBUTE_TYPE_INVALID)) {\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11KeyStore.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,816 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package sun.security.pkcs11;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.Locale;\n+\n+import java.security.*;\n+import java.security.spec.*;\n+\n+import javax.crypto.*;\n+import javax.crypto.spec.*;\n+\n+import java.util.HexFormat;\n+\n+import sun.nio.ch.DirectBuffer;\n+import sun.security.jca.JCAUtil;\n+import sun.security.pkcs11.wrapper.*;\n+import static sun.security.pkcs11.wrapper.PKCS11Constants.*;\n+import static sun.security.pkcs11.wrapper.PKCS11Exception.RV.*;\n+import static sun.security.pkcs11.TemplateManager.*;\n+import static sun.security.pkcs11.P11Cipher.*;\n+\n+\/**\n+ * P11 KeyWrap Cipher implementation class for native impl which only support\n+ * single part encryption\/decryption through C_Encrypt\/C_Decrypt() and\n+ * key wrap\/unwrap through C_WrapKey\/C_UnwrapKey() calls.\n+ * This class currently supports only AES cipher in KW and KWP modes.\n+ *\n+ * For multi-part encryption\/decryption, this class has to buffer data until\n+ * doFinal() is called.\n+ *\n+ * @since   18\n+ *\/\n+final class P11KeyWrapCipher extends CipherSpi {\n+\n+    private static final int BLK_SIZE = 8;\n+\n+    \/\/ supported mode and padding with AES cipher\n+    private enum KeyWrapType {\n+        KW_NOPADDING(\"KW\", \"NOPADDING\"),\n+        KW_PKCS5PADDING(\"KW\", \"PKCS5PADDING\"),\n+        KWP_NOPADDING(\"KWP\", \"NOPADDING\");\n+\n+        private final String mode;\n+        private final String padding;\n+        private final byte[] defIv;\n+\n+        KeyWrapType(String mode, String padding) {\n+            this.mode = mode;\n+            this.padding = padding;\n+            if (mode.equalsIgnoreCase(\"KW\")) {\n+                this.defIv = new byte[] {\n+                        (byte)0xA6, (byte)0xA6, (byte)0xA6, (byte)0xA6,\n+                        (byte)0xA6, (byte)0xA6, (byte)0xA6, (byte)0xA6\n+                };\n+            } else {\n+                this.defIv = new byte[] {\n+                        (byte)0xA6, (byte)0x59, (byte)0x59, (byte)0xA6\n+                };\n+            }\n+        }\n+    }\n+\n+    \/\/ token instance\n+    private final Token token;\n+\n+    \/\/ mechanism id\n+    private final long mechanism;\n+\n+    \/\/ type of this KeyWrap cipher, one of Transformation enum above\n+    private final KeyWrapType type;\n+\n+    \/\/ acceptable key size in bytes, -1 if more than 1 key sizes are accepted\n+    private final int fixedKeySize;\n+\n+    \/\/ associated session, if any\n+    private Session session = null;\n+\n+    \/\/ key, if init() was called\n+    private P11Key p11Key = null;\n+\n+    \/\/ flag indicating whether an operation is initialized\n+    private boolean initialized = false;\n+\n+    private int opmode = Cipher.ENCRYPT_MODE;\n+\n+    \/\/ parameters\n+    private byte[] iv = null;\n+    private SecureRandom random = JCAUtil.getSecureRandom();\n+\n+    \/\/ dataBuffer for storing enc\/dec data; cleared upon doFinal calls\n+    private ByteArrayOutputStream dataBuffer = new ByteArrayOutputStream();\n+\n+    P11KeyWrapCipher(Token token, String algorithm, long mechanism)\n+            throws PKCS11Exception, NoSuchAlgorithmException {\n+        super();\n+        this.token = token;\n+        this.mechanism = mechanism;\n+\n+        String[] algoParts = algorithm.split(\"\/\");\n+\n+        if (algoParts[0].startsWith(\"AES\")) {\n+            \/\/ need 3 parts\n+            if (algoParts.length != 3) {\n+                throw new AssertionError(\"Invalid Transformation format: \" +\n+                        algorithm);\n+            }\n+            int index = algoParts[0].indexOf('_');\n+            fixedKeySize = (index == -1? -1 :\n+                \/\/ should be well-formed since we specify what we support\n+                Integer.parseInt(algoParts[0].substring(index+1)) >> 3);\n+            try {\n+                this.type = KeyWrapType.valueOf(algoParts[1].toUpperCase() +\n+                        \"_\" + algoParts[2].toUpperCase());\n+            } catch (IllegalArgumentException iae) {\n+                throw new NoSuchAlgorithmException(\"Unsupported algorithm \" +\n+                        algorithm);\n+            }\n+        } else {\n+            throw new NoSuchAlgorithmException(\"Unsupported algorithm \" +\n+                    algorithm);\n+        }\n+    }\n+\n+    @Override\n+    protected void engineSetMode(String mode) throws NoSuchAlgorithmException {\n+        if (!mode.toUpperCase(Locale.ENGLISH).equals(type.mode)) {\n+            throw new NoSuchAlgorithmException(\"Unsupported mode \" + mode);\n+        }\n+    }\n+\n+    \/\/ see JCE spec\n+    @Override\n+    protected void engineSetPadding(String padding)\n+            throws NoSuchPaddingException {\n+        if (!padding.toUpperCase(Locale.ENGLISH).equals(type.padding)) {\n+            throw new NoSuchPaddingException(\"Unsupported padding \" + padding);\n+        }\n+    }\n+\n+    \/\/ see JCE spec\n+    @Override\n+    protected int engineGetBlockSize() {\n+        return BLK_SIZE;\n+    }\n+\n+    \/\/ see JCE spec\n+    @Override\n+    protected int engineGetOutputSize(int inputLen) {\n+        return doFinalLength(inputLen);\n+    }\n+\n+    \/\/ see JCE spec\n+    @Override\n+    protected byte[] engineGetIV() {\n+        return (iv == null) ? null : iv.clone();\n+    }\n+\n+    \/\/ see JCE spec\n+    protected AlgorithmParameters engineGetParameters() {\n+        \/\/ KW and KWP uses but not require parameters, return the default\n+        \/\/ IV when no IV is supplied by caller\n+        byte[] iv = (this.iv == null? type.defIv : this.iv);\n+\n+        AlgorithmParameterSpec spec = new IvParameterSpec(iv);\n+        try {\n+            AlgorithmParameters params = AlgorithmParameters.getInstance(\"AES\");\n+            params.init(spec);\n+            return params;\n+        } catch (GeneralSecurityException e) {\n+            \/\/ NoSuchAlgorithmException, NoSuchProviderException\n+            \/\/ InvalidParameterSpecException\n+            throw new ProviderException(\"Could not encode parameters\", e);\n+        }\n+    }\n+\n+    \/\/ see JCE spec\n+    protected void engineInit(int opmode, Key key, SecureRandom sr)\n+            throws InvalidKeyException {\n+        try {\n+            implInit(opmode, key, null, sr);\n+        } catch (InvalidAlgorithmParameterException e) {\n+            throw new InvalidKeyException(\"init() failed\", e);\n+        }\n+    }\n+\n+    \/\/ see JCE spec\n+    protected void engineInit(int opmode, Key key,\n+            AlgorithmParameterSpec params, SecureRandom sr)\n+            throws InvalidKeyException, InvalidAlgorithmParameterException {\n+        if (params != null && !(params instanceof IvParameterSpec)) {\n+            throw new InvalidAlgorithmParameterException\n+                    (\"Only IvParameterSpec is supported\");\n+        }\n+\n+        byte[] ivValue = (params == null? null :\n+                ((IvParameterSpec)params).getIV());\n+\n+        implInit(opmode, key, ivValue, sr);\n+    }\n+\n+    \/\/ see JCE spec\n+    protected void engineInit(int opmode, Key key, AlgorithmParameters params,\n+            SecureRandom sr)\n+            throws InvalidKeyException, InvalidAlgorithmParameterException {\n+        AlgorithmParameterSpec paramSpec = null;\n+        if (params != null) {\n+            try {\n+                paramSpec = params.getParameterSpec(IvParameterSpec.class);\n+            } catch (InvalidParameterSpecException ex) {\n+                throw new InvalidAlgorithmParameterException(ex);\n+            }\n+        }\n+        engineInit(opmode, key, paramSpec, sr);\n+    }\n+\n+    \/\/ actual init() implementation\n+    private void implInit(int opmode, Key key, byte[] iv, SecureRandom sr)\n+        throws InvalidKeyException, InvalidAlgorithmParameterException {\n+        reset(true);\n+        if (fixedKeySize != -1) {\n+            int keySize;\n+            if (key instanceof P11Key) {\n+                keySize = ((P11Key) key).length() >> 3;\n+            } else {\n+                byte[] encoding = key.getEncoded();\n+                Arrays.fill(encoding, (byte) 0);\n+                keySize = encoding.length;\n+            }\n+            if (keySize != fixedKeySize) {\n+                throw new InvalidKeyException(\"Key size is invalid\");\n+            }\n+        }\n+\n+        P11Key newKey = P11SecretKeyFactory.convertKey(token, key, \"AES\");\n+        this.opmode = opmode;\n+\n+        if (iv == null) {\n+            iv = type.defIv;\n+        } else {\n+            if (type == KeyWrapType.KWP_NOPADDING &&\n+                    !Arrays.equals(iv, type.defIv)) {\n+                throw new InvalidAlgorithmParameterException\n+                        (\"For KWP mode, IV must has value 0x\" +\n+                        HexFormat.of().withUpperCase().formatHex(type.defIv));\n+            } else if (iv.length != type.defIv.length) {\n+                throw new InvalidAlgorithmParameterException\n+                        (\"Wrong IV length, expected \" + type.defIv.length +\n+                        \" but got \" + iv.length);\n+            }\n+        }\n+        this.iv = iv;\n+        this.p11Key = newKey;\n+        if (sr != null) {\n+            this.random = sr;\n+        }\n+        try {\n+            initialize();\n+        } catch (PKCS11Exception e) {\n+            if (e.match(CKR_MECHANISM_PARAM_INVALID)) {\n+                throw new InvalidAlgorithmParameterException(\"Bad params\", e);\n+            }\n+            throw new InvalidKeyException(\"Could not initialize cipher\", e);\n+        }\n+    }\n+\n+    private void cancelOperation() {\n+        \/\/ cancel operation by finishing it; avoid killSession as some\n+        \/\/ hardware vendors may require re-login\n+        byte[] in = dataBuffer.toByteArray();\n+        int inLen = in.length;\n+        int bufLen = doFinalLength(0);\n+        byte[] buffer = new byte[bufLen];\n+\n+        try {\n+            if (opmode == Cipher.ENCRYPT_MODE) {\n+                token.p11.C_Encrypt(session.id(), 0, in, 0, inLen,\n+                        0, buffer, 0, bufLen);\n+            } else if (opmode == Cipher.DECRYPT_MODE) {\n+                token.p11.C_Decrypt(session.id(), 0, in, 0, inLen,\n+                        0, buffer, 0, bufLen);\n+            }\n+        } catch (PKCS11Exception e) {\n+            if (e.match(CKR_OPERATION_NOT_INITIALIZED)) {\n+                \/\/ Cancel Operation may be invoked after an error on a PKCS#11\n+                \/\/ call. If the operation inside the token was already\n+                \/\/ cancelled, do not fail here. This is part of a defensive\n+                \/\/ mechanism for PKCS#11 libraries that do not strictly follow\n+                \/\/ the standard.\n+                return;\n+            }\n+            \/\/ ignore failure for en\/decryption since it's likely to fail\n+            \/\/ due to the minimum length requirement\n+        }\n+    }\n+\n+    private void ensureInitialized() throws PKCS11Exception {\n+        if (!initialized) {\n+            initialize();\n+        }\n+    }\n+\n+    private void initialize() throws PKCS11Exception {\n+        if (p11Key == null) {\n+            throw new ProviderException(\"Operation cannot be performed without\"\n+                    + \" calling engineInit first\");\n+        }\n+\n+        token.ensureValid();\n+        dataBuffer.reset();\n+\n+        if (opmode == Cipher.ENCRYPT_MODE || opmode == Cipher.DECRYPT_MODE) {\n+            long p11KeyID = p11Key.getKeyID();\n+            try {\n+                CK_MECHANISM mechWithParams = new CK_MECHANISM(mechanism, iv);\n+\n+                if (session == null) {\n+                    session = token.getOpSession();\n+                }\n+                switch (opmode) {\n+                case Cipher.ENCRYPT_MODE:\n+                    token.p11.C_EncryptInit(session.id(), mechWithParams,\n+                            p11KeyID);\n+                break;\n+                case Cipher.DECRYPT_MODE:\n+                    token.p11.C_DecryptInit(session.id(), mechWithParams,\n+                            p11KeyID);\n+                break;\n+                }\n+            } catch (PKCS11Exception e) {\n+                session = token.releaseSession(session);\n+                throw e;\n+            } finally {\n+                p11Key.releaseKeyID();\n+            }\n+        }\n+        initialized = true;\n+    }\n+\n+    \/\/ if doFinal(inLen) is called, how big does the output buffer have to be?\n+    private int doFinalLength(int inLen) {\n+        if (inLen < 0) {\n+            throw new ProviderException(\"Invalid negative input length\");\n+        }\n+\n+        int result = inLen + dataBuffer.size();\n+        boolean encrypt = (opmode == Cipher.ENCRYPT_MODE ||\n+            opmode == Cipher.WRAP_MODE);\n+        if (encrypt) {\n+            if (type == KeyWrapType.KW_PKCS5PADDING) {\n+                \/\/ add potential pad length, i.e. 1-8\n+                result += (BLK_SIZE - (result & (BLK_SIZE - 1)));\n+            } else if (type == KeyWrapType.KWP_NOPADDING &&\n+                    (result & (BLK_SIZE - 1)) != 0) {\n+                \/\/ add potential pad length, i.e. 0-7\n+                result += (BLK_SIZE - (result & (BLK_SIZE - 1)));\n+            }\n+            result += BLK_SIZE; \/\/ add the leading block including the ICV\n+        } else {\n+            result -= BLK_SIZE; \/\/ minus the leading block including the ICV\n+        }\n+        return (result > 0? result : 0);\n+    }\n+\n+    \/\/ reset the states to the pre-initialized values\n+    \/\/ set initialized to false, cancel operation, release session, and\n+    \/\/ reset dataBuffer\n+    private void reset(boolean doCancel) {\n+        if (!initialized) {\n+            return;\n+        }\n+        initialized = false;\n+\n+        try {\n+            if (session == null) {\n+                return;\n+            }\n+\n+            if (doCancel && token.explicitCancel) {\n+                cancelOperation();\n+            }\n+        } finally {\n+            session = token.releaseSession(session);\n+            dataBuffer.reset();\n+        }\n+    }\n+\n+    \/\/ see JCE spec\n+    protected byte[] engineUpdate(byte[] in, int inOfs, int inLen) {\n+        int n = implUpdate(in, inOfs, inLen);\n+        return new byte[0];\n+    }\n+\n+    \/\/ see JCE spec\n+    protected int engineUpdate(byte[] in, int inOfs, int inLen, byte[] out,\n+            int outOfs) throws ShortBufferException {\n+        implUpdate(in, inOfs, inLen);\n+        return 0;\n+    }\n+\n+    \/\/ see JCE spec\n+    @Override\n+    protected int engineUpdate(ByteBuffer inBuffer, ByteBuffer outBuffer)\n+            throws ShortBufferException {\n+        implUpdate(inBuffer);\n+        return 0;\n+    }\n+\n+    \/\/ see JCE spec\n+    protected byte[] engineDoFinal(byte[] in, int inOfs, int inLen)\n+            throws IllegalBlockSizeException, BadPaddingException {\n+        int minOutLen = doFinalLength(inLen);\n+        try {\n+            byte[] out = new byte[minOutLen];\n+            int n = engineDoFinal(in, inOfs, inLen, out, 0);\n+            return P11Util.convert(out, 0, n);\n+        } catch (ShortBufferException e) {\n+            \/\/ convert since the output length is calculated by doFinalLength()\n+            throw new ProviderException(e);\n+        }\n+    }\n+    \/\/ see JCE spec\n+    protected int engineDoFinal(byte[] in, int inOfs, int inLen, byte[] out,\n+            int outOfs) throws ShortBufferException, IllegalBlockSizeException,\n+            BadPaddingException {\n+        return implDoFinal(in, inOfs, inLen, out, outOfs, out.length - outOfs);\n+    }\n+\n+    \/\/ see JCE spec\n+    @Override\n+    protected int engineDoFinal(ByteBuffer inBuffer, ByteBuffer outBuffer)\n+            throws ShortBufferException, IllegalBlockSizeException,\n+            BadPaddingException {\n+        return implDoFinal(inBuffer, outBuffer);\n+    }\n+\n+    private int implUpdate(byte[] in, int inOfs, int inLen) {\n+        if (inLen > 0) {\n+            try {\n+                ensureInitialized();\n+            } catch (PKCS11Exception e) {\n+                reset(false);\n+                throw new ProviderException(\"update() failed\", e);\n+            }\n+            dataBuffer.write(in, inOfs, inLen);\n+        }\n+        \/\/ always 0 as NSS only supports single-part encryption\/decryption\n+        return 0;\n+    }\n+\n+    private int implUpdate(ByteBuffer inBuf) {\n+        int inLen = inBuf.remaining();\n+        if (inLen > 0) {\n+            try {\n+                ensureInitialized();\n+            } catch (PKCS11Exception e) {\n+                reset(false);\n+                throw new ProviderException(\"update() failed\", e);\n+            }\n+            byte[] data = new byte[inLen];\n+            inBuf.get(data);\n+            dataBuffer.write(data, 0, data.length);\n+        }\n+        \/\/ always 0 as NSS only supports single-part encryption\/decryption\n+        return 0;\n+    }\n+\n+    private int implDoFinal(byte[] in, int inOfs, int inLen,\n+            byte[] out, int outOfs, int outLen)\n+            throws ShortBufferException, IllegalBlockSizeException,\n+            BadPaddingException {\n+        int requiredOutLen = doFinalLength(inLen);\n+        if (outLen < requiredOutLen) {\n+            throw new ShortBufferException();\n+        }\n+\n+        boolean doCancel = true;\n+        int k = 0;\n+        try {\n+            ensureInitialized();\n+\n+            if (dataBuffer.size() > 0) {\n+                if (in != null && inLen > 0) {\n+                    dataBuffer.write(in, inOfs, inLen);\n+                }\n+                in = dataBuffer.toByteArray();\n+                inOfs = 0;\n+                inLen = in.length;\n+            }\n+\n+            if (opmode == Cipher.ENCRYPT_MODE) {\n+                k = token.p11.C_Encrypt(session.id(), 0, in, inOfs, inLen,\n+                        0, out, outOfs, outLen);\n+                doCancel = false;\n+            } else {\n+                \/\/ Special handling to match SunJCE provider behavior\n+                if (inLen == 0) {\n+                    return 0;\n+                }\n+                k = token.p11.C_Decrypt(session.id(), 0, in, inOfs, inLen,\n+                        0, out, outOfs, outLen);\n+                doCancel = false;\n+            }\n+        } catch (PKCS11Exception e) {\n+            \/\/ As per the PKCS#11 standard, C_Encrypt and C_Decrypt may only\n+            \/\/ keep the operation active on CKR_BUFFER_TOO_SMALL errors or\n+            \/\/ successful calls to determine the output length. However,\n+            \/\/ these cases are not expected here because the output length\n+            \/\/ is checked in the OpenJDK side before making the PKCS#11 call.\n+            \/\/ Thus, doCancel can safely be 'false'.\n+            doCancel = false;\n+            handleEncException(\"doFinal() failed\", e);\n+        } finally {\n+            reset(doCancel);\n+        }\n+        return k;\n+    }\n+\n+    private int implDoFinal(ByteBuffer inBuffer, ByteBuffer outBuffer)\n+            throws ShortBufferException, IllegalBlockSizeException,\n+            BadPaddingException {\n+        int outLen = outBuffer.remaining();\n+        int inLen = inBuffer.remaining();\n+\n+        int requiredOutLen = doFinalLength(inLen);\n+        if (outLen < requiredOutLen) {\n+            throw new ShortBufferException();\n+        }\n+\n+        boolean doCancel = true;\n+        int k = 0;\n+        try {\n+            ensureInitialized();\n+\n+            long inAddr = 0;\n+            byte[] in = null;\n+            int inOfs = 0;\n+\n+            if (dataBuffer.size() > 0) {\n+                if (inBuffer != null && inLen > 0) {\n+                    byte[] temp = new byte[inLen];\n+                    inBuffer.get(temp);\n+                    dataBuffer.write(temp, 0, temp.length);\n+                }\n+\n+                in = dataBuffer.toByteArray();\n+                inOfs = 0;\n+                inLen = in.length;\n+            } else {\n+                if (inBuffer instanceof DirectBuffer) {\n+                    inAddr = ((DirectBuffer) inBuffer).address();\n+                    inOfs = inBuffer.position();\n+                } else {\n+                    if (inBuffer.hasArray()) {\n+                        in = inBuffer.array();\n+                        inOfs = inBuffer.position() + inBuffer.arrayOffset();\n+                    } else {\n+                        in = new byte[inLen];\n+                        inBuffer.get(in);\n+                    }\n+                }\n+            }\n+            long outAddr = 0;\n+            byte[] outArray = null;\n+            int outOfs = 0;\n+            if (outBuffer instanceof DirectBuffer) {\n+                outAddr = ((DirectBuffer) outBuffer).address();\n+                outOfs = outBuffer.position();\n+            } else {\n+                if (outBuffer.hasArray()) {\n+                    outArray = outBuffer.array();\n+                    outOfs = outBuffer.position() + outBuffer.arrayOffset();\n+                } else {\n+                    outArray = new byte[outLen];\n+                }\n+            }\n+\n+            if (opmode == Cipher.ENCRYPT_MODE) {\n+                k = token.p11.C_Encrypt(session.id(), inAddr, in, inOfs, inLen,\n+                        outAddr, outArray, outOfs, outLen);\n+                doCancel = false;\n+            } else {\n+                \/\/ Special handling to match SunJCE provider behavior\n+                if (inLen == 0) {\n+                    return 0;\n+                }\n+                k = token.p11.C_Decrypt(session.id(), inAddr, in, inOfs, inLen,\n+                        outAddr, outArray, outOfs, outLen);\n+                doCancel = false;\n+            }\n+            inBuffer.position(inBuffer.limit());\n+            outBuffer.position(outBuffer.position() + k);\n+        } catch (PKCS11Exception e) {\n+            \/\/ As per the PKCS#11 standard, C_Encrypt and C_Decrypt may only\n+            \/\/ keep the operation active on CKR_BUFFER_TOO_SMALL errors or\n+            \/\/ successful calls to determine the output length. However,\n+            \/\/ these cases are not expected here because the output length\n+            \/\/ is checked in the OpenJDK side before making the PKCS#11 call.\n+            \/\/ Thus, doCancel can safely be 'false'.\n+            doCancel = false;\n+            handleEncException(\"doFinal() failed\", e);\n+        } finally {\n+            reset(doCancel);\n+        }\n+        return k;\n+    }\n+\n+    private void handleEncException(String msg, PKCS11Exception e)\n+            throws IllegalBlockSizeException, ShortBufferException,\n+            ProviderException {\n+        if (e.match(CKR_DATA_LEN_RANGE) ||\n+                e.match(CKR_ENCRYPTED_DATA_LEN_RANGE)) {\n+            throw (IllegalBlockSizeException)\n+                    (new IllegalBlockSizeException(msg).initCause(e));\n+        } else if (e.match(CKR_BUFFER_TOO_SMALL)) {\n+            throw (ShortBufferException)\n+                    (new ShortBufferException(msg).initCause(e));\n+        } else {\n+            throw new ProviderException(msg, e);\n+        }\n+    }\n+\n+    \/\/ see JCE spec\n+    protected byte[] engineWrap(Key tbwKey) throws IllegalBlockSizeException,\n+            InvalidKeyException {\n+        try {\n+            ensureInitialized();\n+        } catch (PKCS11Exception e) {\n+            reset(false);\n+            throw new ProviderException(\"wrap() failed\", e);\n+        }\n+\n+        \/\/ convert the specified key into P11Key handle\n+        P11Key tbwP11Key = null;\n+        if (!(tbwKey instanceof P11Key)) {\n+            try {\n+                tbwP11Key = (tbwKey instanceof SecretKey?\n+                        P11SecretKeyFactory.convertKey(token, tbwKey,\n+                                tbwKey.getAlgorithm()) :\n+                        P11KeyFactory.convertKey(token, tbwKey,\n+                                tbwKey.getAlgorithm()));\n+            } catch (ProviderException pe) {\n+                throw new InvalidKeyException(\"Cannot convert to PKCS11 key\",\n+                        pe);\n+            } catch (InvalidKeyException ike) {\n+                \/\/ could be algorithms NOT supported by PKCS11 library\n+                \/\/ try single part encryption instead\n+            }\n+        } else {\n+            tbwP11Key = (P11Key) tbwKey;\n+        }\n+\n+        long p11KeyID = 0;\n+        try {\n+            if (session == null) {\n+                session = token.getOpSession();\n+            }\n+\n+            p11KeyID = p11Key.getKeyID();\n+            CK_MECHANISM mechWithParams = new CK_MECHANISM(mechanism, iv);\n+            if (tbwP11Key != null) {\n+                long tbwP11KeyID = tbwP11Key.getKeyID();\n+                try {\n+                    return token.p11.C_WrapKey(session.id(), mechWithParams,\n+                            p11KeyID, tbwP11KeyID);\n+                } finally {\n+                    tbwP11Key.releaseKeyID();\n+                }\n+            } else {\n+                byte[] in = tbwKey.getEncoded();\n+                try {\n+                    token.p11.C_EncryptInit(session.id(), mechWithParams,\n+                            p11KeyID);\n+\n+                    int bufLen = doFinalLength(in.length);\n+                    byte[] buffer = new byte[bufLen];\n+\n+                    token.p11.C_Encrypt(session.id(), 0, in, 0, in.length,\n+                            0, buffer, 0, bufLen);\n+                    return buffer;\n+                } finally {\n+                    Arrays.fill(in, (byte)0);\n+                }\n+            }\n+        } catch (PKCS11Exception e) {\n+            String msg = \"wrap() failed\";\n+            if (e.match(CKR_KEY_SIZE_RANGE) || e.match(CKR_DATA_LEN_RANGE)) {\n+                throw (IllegalBlockSizeException)\n+                        (new IllegalBlockSizeException(msg).initCause(e));\n+            } else if (e.match(CKR_KEY_NOT_WRAPPABLE) ||\n+                    e.match(CKR_KEY_UNEXTRACTABLE) ||\n+                    e.match(CKR_KEY_HANDLE_INVALID)) {\n+                throw new InvalidKeyException(msg, e);\n+            } else if (e.match(CKR_MECHANISM_INVALID)) {\n+                throw new UnsupportedOperationException(msg, e);\n+            } else {\n+                throw new ProviderException(msg, e);\n+            }\n+        } finally {\n+            if (p11KeyID != 0) p11Key.releaseKeyID();\n+            reset(false);\n+        }\n+    }\n+\n+    \/\/ see JCE spec\n+    protected Key engineUnwrap(byte[] wrappedKey, String wrappedKeyAlgo,\n+            int wrappedKeyType)\n+            throws InvalidKeyException, NoSuchAlgorithmException {\n+\n+        try {\n+            ensureInitialized();\n+        } catch (PKCS11Exception e) {\n+            reset(false);\n+            throw new ProviderException(\"unwrap() failed\", e);\n+        }\n+\n+        long keyClass;\n+        long keyType;\n+        switch (wrappedKeyType) {\n+            case Cipher.PRIVATE_KEY:\n+                keyClass = CKO_PRIVATE_KEY;\n+                keyType = P11KeyFactory.getPKCS11KeyType(wrappedKeyAlgo);\n+                break;\n+            case Cipher.SECRET_KEY:\n+                keyClass = CKO_SECRET_KEY;\n+                keyType = P11SecretKeyFactory.getPKCS11KeyType(wrappedKeyAlgo);\n+                break;\n+            case Cipher.PUBLIC_KEY:\n+                throw new UnsupportedOperationException\n+                        (\"cannot unwrap public keys\");\n+            default: \/\/ should never happen\n+                throw new AssertionError();\n+        };\n+\n+        CK_ATTRIBUTE[] attributes;\n+        try {\n+            attributes = new CK_ATTRIBUTE[] {\n+                    new CK_ATTRIBUTE(CKA_CLASS, keyClass),\n+                    new CK_ATTRIBUTE(CKA_KEY_TYPE, keyType),\n+            };\n+            attributes = token.getAttributes\n+                    (O_IMPORT, keyClass, keyType, attributes);\n+        } catch (PKCS11Exception e) {\n+            reset(false);\n+            throw new ProviderException(\"unwrap() failed\", e);\n+        }\n+\n+        CK_MECHANISM mechParams = new CK_MECHANISM(mechanism, iv);\n+\n+        long p11KeyID = 0;\n+        try {\n+            if (session == null) {\n+                session = token.getOpSession();\n+            }\n+\n+            p11KeyID = p11Key.getKeyID();\n+            long unwrappedKeyID = token.p11.C_UnwrapKey(session.id(),\n+                mechParams, p11KeyID, wrappedKey, attributes);\n+\n+            return (switch(wrappedKeyType) {\n+                case Cipher.PRIVATE_KEY -> P11Key.privateKey\n+                    (session, unwrappedKeyID, wrappedKeyAlgo, -1, attributes);\n+                case Cipher.SECRET_KEY ->  P11Key.secretKey\n+                    (session, unwrappedKeyID, wrappedKeyAlgo, -1, attributes);\n+                default -> null;\n+            });\n+        } catch (PKCS11Exception e) {\n+            String msg = \"unwrap() failed\";\n+            if (e.match(CKR_UNWRAPPING_KEY_SIZE_RANGE) ||\n+                    e.match(CKR_WRAPPED_KEY_INVALID) ||\n+                    e.match(CKR_WRAPPED_KEY_LEN_RANGE) ||\n+                    e.match(CKR_UNWRAPPING_KEY_HANDLE_INVALID) ||\n+                    e.match(CKR_UNWRAPPING_KEY_TYPE_INCONSISTENT)) {\n+                throw new InvalidKeyException(msg, e);\n+            } else if (e.match(CKR_MECHANISM_INVALID)) {\n+                throw new UnsupportedOperationException(msg, e);\n+            } else {\n+                throw new ProviderException(msg, e);\n+            }\n+        } finally {\n+            if (p11KeyID != 0) p11Key.releaseKeyID();\n+            reset(false);\n+        }\n+    }\n+\n+    \/\/ see JCE spec\n+    @Override\n+    protected int engineGetKeySize(Key key) throws InvalidKeyException {\n+        return P11SecretKeyFactory.convertKey(token, key, \"AES\").length();\n+    }\n+}\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11KeyWrapCipher.java","additions":816,"deletions":0,"binary":false,"changes":816,"status":"added"},{"patch":"@@ -39,1 +39,1 @@\n-import static sun.security.pkcs11.wrapper.PKCS11Exception.*;\n+import static sun.security.pkcs11.wrapper.PKCS11Exception.RV.*;\n@@ -155,1 +155,1 @@\n-            if (e.getErrorCode() == CKR_OPERATION_NOT_INITIALIZED) {\n+            if (e.match(CKR_OPERATION_NOT_INITIALIZED)) {\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11Mac.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-import static sun.security.pkcs11.wrapper.PKCS11Exception.*;\n+import static sun.security.pkcs11.wrapper.PKCS11Exception.RV.*;\n@@ -301,1 +301,1 @@\n-            if (e.getErrorCode() == CKR_OPERATION_NOT_INITIALIZED) {\n+            if (e.match(CKR_OPERATION_NOT_INITIALIZED)) {\n@@ -708,10 +708,3 @@\n-            long errorCode = pe.getErrorCode();\n-            if (errorCode == CKR_SIGNATURE_INVALID) {\n-                return false;\n-            }\n-            if (errorCode == CKR_SIGNATURE_LEN_RANGE) {\n-                \/\/ return false rather than throwing an exception\n-                return false;\n-            }\n-            \/\/ ECF bug?\n-            if (errorCode == CKR_DATA_LEN_RANGE) {\n+            if (pe.match(CKR_SIGNATURE_INVALID) ||\n+                    pe.match(CKR_SIGNATURE_LEN_RANGE) ||\n+                    pe.match(CKR_DATA_LEN_RANGE)) {\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11PSSSignature.java","additions":5,"deletions":12,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-import static sun.security.pkcs11.wrapper.PKCS11Exception.*;\n+import static sun.security.pkcs11.wrapper.PKCS11Exception.RV.*;\n@@ -318,1 +318,1 @@\n-            if (e.getErrorCode() == CKR_OPERATION_NOT_INITIALIZED) {\n+            if (e.match(CKR_OPERATION_NOT_INITIALIZED)) {\n@@ -326,3 +326,2 @@\n-                long errorCode = e.getErrorCode();\n-                if ((errorCode == CKR_SIGNATURE_INVALID) ||\n-                     (errorCode == CKR_SIGNATURE_LEN_RANGE)) {\n+                if (e.match(CKR_SIGNATURE_INVALID) ||\n+                         e.match(CKR_SIGNATURE_LEN_RANGE)) {\n@@ -730,10 +729,3 @@\n-            long errorCode = pe.getErrorCode();\n-            if (errorCode == CKR_SIGNATURE_INVALID) {\n-                return false;\n-            }\n-            if (errorCode == CKR_SIGNATURE_LEN_RANGE) {\n-                \/\/ return false rather than throwing an exception\n-                return false;\n-            }\n-            \/\/ ECF bug?\n-            if (errorCode == CKR_DATA_LEN_RANGE) {\n+            if (pe.match(CKR_SIGNATURE_INVALID) ||\n+                    pe.match(CKR_SIGNATURE_LEN_RANGE) ||\n+                    pe.match(CKR_DATA_LEN_RANGE)) { \/\/ ECF bug?\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11Signature.java","additions":7,"deletions":15,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n-import static sun.security.pkcs11.wrapper.PKCS11Exception.*;\n+import static sun.security.pkcs11.wrapper.PKCS11Exception.RV.*;\n@@ -526,0 +526,1 @@\n+        String P11KeyWrapCipher    = \"sun.security.pkcs11.P11KeyWrapCipher\";\n@@ -712,1 +713,1 @@\n-        dA(CIP, \"AES_128\/CBC\/NoPadding\",          P11Cipher,\n+        dA(CIP, \"AES_128\/CBC\/NoPadding\",        P11Cipher,\n@@ -714,1 +715,1 @@\n-        dA(CIP, \"AES_192\/CBC\/NoPadding\",          P11Cipher,\n+        dA(CIP, \"AES_192\/CBC\/NoPadding\",        P11Cipher,\n@@ -716,1 +717,1 @@\n-        dA(CIP, \"AES_256\/CBC\/NoPadding\",          P11Cipher,\n+        dA(CIP, \"AES_256\/CBC\/NoPadding\",        P11Cipher,\n@@ -722,1 +723,1 @@\n-        dA(CIP, \"AES_128\/ECB\/NoPadding\",          P11Cipher,\n+        dA(CIP, \"AES_128\/ECB\/NoPadding\",        P11Cipher,\n@@ -724,1 +725,1 @@\n-        dA(CIP, \"AES_192\/ECB\/NoPadding\",          P11Cipher,\n+        dA(CIP, \"AES_192\/ECB\/NoPadding\",        P11Cipher,\n@@ -726,1 +727,1 @@\n-        dA(CIP, \"AES_256\/ECB\/NoPadding\",          P11Cipher,\n+        dA(CIP, \"AES_256\/ECB\/NoPadding\",        P11Cipher,\n@@ -733,0 +734,24 @@\n+        dA(CIP, \"AES\/KW\/NoPadding\",             P11KeyWrapCipher,\n+                m(CKM_AES_KEY_WRAP));\n+        dA(CIP, \"AES_128\/KW\/NoPadding\",         P11KeyWrapCipher,\n+                m(CKM_AES_KEY_WRAP));\n+        dA(CIP, \"AES_192\/KW\/NoPadding\",         P11KeyWrapCipher,\n+                m(CKM_AES_KEY_WRAP));\n+        dA(CIP, \"AES_256\/KW\/NoPadding\",         P11KeyWrapCipher,\n+                m(CKM_AES_KEY_WRAP));\n+        d(CIP, \"AES\/KW\/PKCS5Padding\",           P11KeyWrapCipher,\n+                m(CKM_AES_KEY_WRAP_PAD));\n+        d(CIP, \"AES_128\/KW\/PKCS5Padding\",       P11KeyWrapCipher,\n+                m(CKM_AES_KEY_WRAP_PAD));\n+        d(CIP, \"AES_192\/KW\/PKCS5Padding\",       P11KeyWrapCipher,\n+                m(CKM_AES_KEY_WRAP_PAD));\n+        d(CIP, \"AES_256\/KW\/PKCS5Padding\",       P11KeyWrapCipher,\n+                m(CKM_AES_KEY_WRAP_PAD));\n+        dA(CIP, \"AES\/KWP\/NoPadding\",            P11KeyWrapCipher,\n+                m(CKM_AES_KEY_WRAP_KWP));\n+        dA(CIP, \"AES_128\/KWP\/NoPadding\",        P11KeyWrapCipher,\n+                m(CKM_AES_KEY_WRAP_KWP));\n+        dA(CIP, \"AES_192\/KWP\/NoPadding\",        P11KeyWrapCipher,\n+                m(CKM_AES_KEY_WRAP_KWP));\n+        dA(CIP, \"AES_256\/KWP\/NoPadding\",        P11KeyWrapCipher,\n+                m(CKM_AES_KEY_WRAP_KWP));\n@@ -736,1 +761,1 @@\n-        dA(CIP, \"AES_128\/GCM\/NoPadding\",          P11AEADCipher,\n+        dA(CIP, \"AES_128\/GCM\/NoPadding\",        P11AEADCipher,\n@@ -738,1 +763,1 @@\n-        dA(CIP, \"AES_192\/GCM\/NoPadding\",          P11AEADCipher,\n+        dA(CIP, \"AES_192\/GCM\/NoPadding\",        P11AEADCipher,\n@@ -740,1 +765,1 @@\n-        dA(CIP, \"AES_256\/GCM\/NoPadding\",          P11AEADCipher,\n+        dA(CIP, \"AES_256\/GCM\/NoPadding\",        P11AEADCipher,\n@@ -1247,0 +1272,3 @@\n+                } else if (algorithm.indexOf(\"\/KW\/\") != -1 ||\n+                        algorithm.indexOf(\"\/KWP\/\") != -1) {\n+                    return new P11KeyWrapCipher(token, algorithm, mechanism);\n@@ -1501,1 +1529,1 @@\n-            if (pe.getErrorCode() == CKR_USER_ALREADY_LOGGED_IN) {\n+            if (pe.match(CKR_USER_ALREADY_LOGGED_IN)) {\n@@ -1507,1 +1535,1 @@\n-            } else if (pe.getErrorCode() == CKR_PIN_INCORRECT) {\n+            } else if (pe.match(CKR_PIN_INCORRECT)) {\n@@ -1586,1 +1614,1 @@\n-            if (pe.getErrorCode() == CKR_USER_NOT_LOGGED_IN) {\n+            if (pe.match(CKR_USER_NOT_LOGGED_IN)) {\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/SunPKCS11.java","additions":41,"deletions":13,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-import static sun.security.pkcs11.wrapper.PKCS11Exception.*;\n+import static sun.security.pkcs11.wrapper.PKCS11Exception.RV.*;\n@@ -393,1 +393,1 @@\n-                if (e.getErrorCode() != CKR_MECHANISM_INVALID) {\n+                if (!e.match(CKR_MECHANISM_INVALID)) {\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/Token.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -60,1 +60,1 @@\n-import static sun.security.pkcs11.wrapper.PKCS11Exception.*;\n+import static sun.security.pkcs11.wrapper.PKCS11Exception.RV.*;\n@@ -172,1 +172,1 @@\n-                    if (e.getErrorCode() != CKR_CRYPTOKI_ALREADY_INITIALIZED) {\n+                    if (!e.match(CKR_CRYPTOKI_ALREADY_INITIALIZED)) {\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/wrapper\/PKCS11.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -75,29 +75,0 @@\n-    public static final long CKR_GENERAL_ERROR = RV.CKR_GENERAL_ERROR.value;\n-    public static final long CKR_ATTRIBUTE_TYPE_INVALID =\n-            RV.CKR_ATTRIBUTE_TYPE_INVALID.value;\n-    public static final long CKR_DATA_LEN_RANGE = RV.CKR_DATA_LEN_RANGE.value;\n-    public static final long CKR_ENCRYPTED_DATA_INVALID =\n-            RV.CKR_ENCRYPTED_DATA_INVALID.value;\n-    public static final long CKR_ENCRYPTED_DATA_LEN_RANGE =\n-            RV.CKR_ENCRYPTED_DATA_LEN_RANGE.value;\n-    public static final long CKR_MECHANISM_INVALID =\n-            RV.CKR_MECHANISM_INVALID.value;\n-    public static final long CKR_MECHANISM_PARAM_INVALID =\n-            RV.CKR_MECHANISM_PARAM_INVALID.value;\n-    public static final long CKR_OPERATION_NOT_INITIALIZED =\n-            RV.CKR_OPERATION_NOT_INITIALIZED.value;\n-    public static final long CKR_PIN_INCORRECT =\n-            RV.CKR_PIN_INCORRECT.value;\n-    public static final long CKR_SIGNATURE_INVALID =\n-            RV.CKR_SIGNATURE_INVALID.value;\n-    public static final long CKR_SIGNATURE_LEN_RANGE =\n-            RV.CKR_SIGNATURE_LEN_RANGE.value;\n-    public static final long CKR_USER_ALREADY_LOGGED_IN =\n-            RV.CKR_USER_ALREADY_LOGGED_IN.value;\n-    public static final long CKR_USER_NOT_LOGGED_IN =\n-            RV.CKR_USER_NOT_LOGGED_IN.value;\n-    public static final long CKR_BUFFER_TOO_SMALL =\n-            RV.CKR_BUFFER_TOO_SMALL.value;\n-    public static final long CKR_CRYPTOKI_ALREADY_INITIALIZED =\n-            RV.CKR_CRYPTOKI_ALREADY_INITIALIZED.value;\n-\n@@ -105,1 +76,1 @@\n-    static enum RV {\n+    public static enum RV {\n@@ -258,0 +229,10 @@\n+\n+    \/**\n+     * Returns true if the error code matches the the specified enum value.\n+     * @return true if the error code matches the the specified enum value.\n+     * @preconditions\n+     * @postconditions\n+     *\/\n+    public boolean match(RV errorEnum) {\n+        return (errorCode == errorEnum.value);\n+    }\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/wrapper\/PKCS11Exception.java","additions":11,"deletions":30,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -0,0 +1,395 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8264849\n+ * @library \/test\/lib ..\/..\n+ * @run main\/othervm NISTWrapKAT\n+ * @summary Verify that the AES-Key-Wrap and AES-Key-Wrap-Pad ciphers\n+ * work as expected using NIST test vectors.\n+ *\/\n+import java.security.Key;\n+import java.security.AlgorithmParameters;\n+import java.security.Provider;\n+import javax.crypto.*;\n+import javax.crypto.spec.*;\n+import java.util.Arrays;\n+import java.math.BigInteger;\n+\n+\/\/ adapted from com\/sun\/crypto\/provider\/Cipher\/KeyWrap\/NISTWrapKAT.java\n+public class NISTWrapKAT extends PKCS11Test {\n+\n+    private static final String KEK =\n+        \"000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f\";\n+    private static final String DATA =\n+        \"00112233445566778899aabbccddeeff000102030405060708090a0b0c0d0e0f\";\n+    \/\/ from RFC 3394 sec4\n+    private static String KW_AES128_128 =\n+        \"1fa68b0a8112b447aef34bd8fb5a7b829d3e862371d2cfe5\";\n+    private static String KW_AES192_128 =\n+        \"96778b25ae6ca435f92b5b97c050aed2468ab8a17ad84e5d\";\n+    private static String KW_AES192_192 =\n+        \"031d33264e15d33268f24ec260743edce1c6c7ddee725a936ba814915c6762d2\";\n+    private static String KW_AES256_128 =\n+        \"64e8c3f9ce0f5ba263e9777905818a2a93c8191e7d6e8ae7\";\n+    private static String KW_AES256_192 =\n+        \"a8f9bc1612c68b3ff6e6f4fbe30e71e4769c8b80a32cb8958cd5d17d6b254da1\";\n+    private static String KW_AES256_256 =\n+        \"28c9f404c4b810f4cbccb35cfb87f8263f5786e2d80ed326cbc7f0e71a99f43bfb988b9b7a02dd21\";\n+\n+    private static String KWP_AES128_56 = \"1B1D4BC2A90B1FA389412B3D40FECB20\";\n+    private static String KWP_AES128_112 =\n+            \"EA0BFDE8AF063E8918E811A05D2A4C23A367B45315716B5B\";\n+    private static String KWP_AES192_56 = \"87CE2C5C2D7196E09381056B319D91E9\";\n+    private static String KWP_AES192_112 =\n+            \"900484950F84EB6ED74CE81DCDACA26E72BB29D4A6F7AC74\";\n+    private static String KWP_AES192_168 =\n+            \"A402348F1956DB968FDDFD8976420F9DDEB7183CF16B91B0AEB74CAB196C343E\";\n+    private static String KWP_AES256_56 = \"809BB1864A18938529E97EFCD9544E9A\";\n+    private static String KWP_AES256_112 =\n+            \"C68168173F141E6D5767611574A941259090DA78D7DF9DF7\";\n+    private static String KWP_AES256_168 =\n+            \"308D49692B5F8CF638D54BB4B985633504237329964C76EBB3F669870A708DBC\";\n+    private static String KWP_AES256_224 =\n+            \"0942747DB07032A3F04CDB2E7DE1CBA038F92BC355393AE9A0E4AE8C901912AC3D3AF0F16D240607\";\n+     \/\/ from RFC 5649 sec6\n+     private static String KEK2 = \"5840DF6E29B02AF1AB493B705BF16EA1AE8338F4DCC176A8\";\n+\n+    private static byte[] toBytes(String hex, int hexLen) {\n+        if (hexLen < hex.length()) {\n+            hex = hex.substring(0, hexLen);\n+        } else {\n+            hexLen = hex.length();\n+        }\n+        int outLen = hexLen >> 1;\n+        BigInteger temp = new BigInteger(hex, 16);\n+        byte[] val = temp.toByteArray();\n+        if (val.length == outLen) {\n+            return val;\n+        } else {\n+            byte[] out = new byte[outLen];\n+            if (val.length < outLen) {\n+                \/\/ enlarge\n+                System.arraycopy(val, 0, out, outLen - val.length, val.length);\n+            } else {\n+                \/\/ truncate\n+                System.arraycopy(val, val.length - outLen, out, 0, outLen);\n+            }\n+            return out;\n+        }\n+    }\n+\n+    \/\/@DataProvider\n+    public Object[][] testData() {\n+        return new Object[][] {\n+            { \"AESWrap\", KEK, 16, DATA, 16, KW_AES128_128 },\n+            { \"AESWrap\", KEK, 24, DATA, 16, KW_AES192_128 },\n+            { \"AESWrap\", KEK, 24, DATA, 24, KW_AES192_192 },\n+            { \"AESWrap\", KEK, 32, DATA, 16, KW_AES256_128 },\n+            { \"AESWrap\", KEK, 32, DATA, 24, KW_AES256_192 },\n+            { \"AESWrap\", KEK, 32, DATA, 32, KW_AES256_256 },\n+            { \"AESWrap_128\", KEK, 16, DATA, 16, KW_AES128_128 },\n+            { \"AESWrap_192\", KEK, 24, DATA, 16, KW_AES192_128 },\n+            { \"AESWrap_256\", KEK, 32, DATA, 16, KW_AES256_128 },\n+            { \"AES\/KW\/NoPadding\", KEK, 16, DATA, 16, KW_AES128_128 },\n+            { \"AES\/KW\/NoPadding\", KEK, 24, DATA, 16, KW_AES192_128 },\n+            { \"AES\/KW\/NoPadding\", KEK, 24, DATA, 24, KW_AES192_192 },\n+            { \"AES\/KW\/NoPadding\", KEK, 32, DATA, 16, KW_AES256_128 },\n+            { \"AES\/KW\/NoPadding\", KEK, 32, DATA, 24, KW_AES256_192 },\n+            { \"AES\/KW\/NoPadding\", KEK, 32, DATA, 32, KW_AES256_256 },\n+            { \"AESWrapPad\", KEK, 16, DATA, 7, KWP_AES128_56 },\n+            { \"AESWrapPad\", KEK, 16, DATA, 14, KWP_AES128_112 },\n+            { \"AESWrapPad\", KEK, 24, DATA, 7, KWP_AES192_56 },\n+            { \"AESWrapPad\", KEK, 24, DATA, 14, KWP_AES192_112 },\n+            { \"AESWrapPad\", KEK, 24, DATA, 21, KWP_AES192_168 },\n+            { \"AESWrapPad\", KEK, 32, DATA, 7, KWP_AES256_56 },\n+            { \"AESWrapPad\", KEK, 32, DATA, 14, KWP_AES256_112 },\n+            { \"AESWrapPad\", KEK, 32, DATA, 21, KWP_AES256_168 },\n+            { \"AESWrapPad\", KEK, 32, DATA, 28, KWP_AES256_224 },\n+            { \"AESWrapPad_128\", KEK, 16, DATA, 7, KWP_AES128_56 },\n+            { \"AESWrapPad_192\", KEK, 24, DATA, 7, KWP_AES192_56 },\n+            { \"AESWrapPad_256\", KEK, 32, DATA, 7, KWP_AES256_56 },\n+            { \"AES\/KWP\/NoPadding\", KEK, 16, DATA, 7, KWP_AES128_56 },\n+            { \"AES\/KWP\/NoPadding\", KEK, 16, DATA, 14, KWP_AES128_112 },\n+            { \"AES\/KWP\/NoPadding\", KEK, 24, DATA, 7, KWP_AES192_56 },\n+            { \"AES\/KWP\/NoPadding\", KEK, 24, DATA, 14, KWP_AES192_112 },\n+            { \"AES\/KWP\/NoPadding\", KEK, 24, DATA, 21, KWP_AES192_168 },\n+            { \"AES\/KWP\/NoPadding\", KEK, 32, DATA, 7, KWP_AES256_56 },\n+            { \"AES\/KWP\/NoPadding\", KEK, 32, DATA, 14, KWP_AES256_112 },\n+            { \"AES\/KWP\/NoPadding\", KEK, 32, DATA, 21, KWP_AES256_168 },\n+            { \"AES\/KWP\/NoPadding\", KEK, 32, DATA, 28, KWP_AES256_224 },\n+            { \"AES\/KWP\/NoPadding\", KEK2, 24, \"466F7250617369\", 7,\n+              \"AFBEB0F07DFBF5419200F2CCB50BB24F\" },\n+            { \"AES\/KWP\/NoPadding\", KEK2, 24,\n+              \"C37B7E6492584340BED12207808941155068F738\", 20,\n+              \"138BDEAA9B8FA7FC61F97742E72248EE5AE6AE5360D1AE6A5F54F373FA543B6A\" },\n+            \/\/ some more test vectors for KW and KWP\n+            \/\/ from csrc.nist.gov\/groups\/STM\/cavp\/documents\/mac\/kwtestvectors.zip\n+            { \"AES\/KW\/NoPadding\", \"7575da3a93607cc2bfd8cec7aadfd9a6\", 16,\n+              \"42136d3c384a3eeac95a066fd28fed3f\", 16,\n+              \"031f6bd7e61e643df68594816f64caa3f56fabea2548f5fb\" },\n+            { \"AES\/KW\/NoPadding\", \"e5d058e7f1c22c016c4e1cc9b26b9f8f\", 16,\n+              \"7f604e9b8d39d3c91e193fe6f196c1e3da6211a7c9a33b8873b64b138d1803\" +\n+              \"e4\", 32,\n+              \"60b9f8ac797c56e01e9b5f84d65816a980777869f67991a0e6dc19b8cd75c9\" +\n+              \"b54db4a38456bbd6f3\" },\n+            { \"AES\/KW\/NoPadding\", \"67ae4270bcdd31e8326b7e7f94c80276\", 16,\n+              \"57e748b62fbc37ba25e904ee973d01b136cf7c1d0c8c5c87\", 24,\n+              \"96cec0e3272a21faa550a857957aa38ce3c1cf06f0dd9f5b5c5c422cef6c69\" +\n+              \"a1\" },\n+            { \"AES\/KW\/NoPadding\", \"d7aa53aefad65cd95b57c8eee7b0a906\", 16,\n+              \"4a8daee6774751fc4489e837b8f7fba6896c70bb3d5e53053c92eb58046ee4\" +\n+              \"a7002e542311253b97\", 40,\n+              \"84ebd38cf06c674dcf186977de4a40c6dde3e7f49361a43420a887d2931b29\" +\n+              \"c23e2db72e95e4107001da925181bb7097\" },\n+            { \"AES\/KW\/NoPadding\", \"98311985c4661d7e811ee56070e6fecf\", 16,\n+              \"18840c96813864ef3093b48cdde6ac5d78248b96d4a2cd1f15f0b56f98213d\" +\n+              \"bf87e1ccad04e0d4f1954c233ea3e48fdad8f2b1156e54e19e3b5f4a66d2e9\" +\n+              \"149032b876c51249165fe8c28e112a685b2d228a8ac308017574274af36a4e\" +\n+              \"a3877bcc9850bafe8fc0e0a712faca0dea98396f9143bc5819fe4933a806e9\" +\n+              \"b965133e3c695a45f0fbd6961798c400d7477287df64798b651e0d3009c13f\" +\n+              \"7a2246c28f983509b9e5339919f2cdffcdfc550693cba9491c00334c4a62d8\" +\n+              \"78c4d0ca57b1104bc0174968ea8e3730b9e68db49678b23cd508ebe3e12e94\" +\n+              \"b0ad3791023a8ef95473f0b32f906738f34e94e45a4480ad768072e1853adb\" +\n+              \"63996b9ac27a1dade70804b82290a2274c6dcc3ccd40a8b38a56a5eb03f590\" +\n+              \"75de015e8f9096f53549f6374e02da947fb849287a447f757cc340b6bded71\" +\n+              \"d480988b6d2fcd984fba841470519830304667fef0a577b4cf84f76aef9deb\" +\n+              \"84dde36abfbd76673c17113dbea7a3e24bf9b57a8fd17173a1ef91497b732b\" +\n+              \"3fa8889bed58a503a0d3e20bc27ec4dbf5d13a93cbad05495e3df15e1fe34a\" +\n+              \"3a6d6f648ea4aa60b2f114f30944ae593675dac2db188f90a3c483fb82cec0\" +\n+              \"f0d295544d798b62cdcb51c6c036af1a341d78babf87b92609c1d866e311a4\" +\n+              \"6abccc8ba8c6a41420359bb061d7e752c0ed25990eef57c9f9e190572203f8\" +\n+              \"c473edf8cfc8c26d34e37240f45ded97\", 512,\n+              \"625aea9122b7b57b9f36446f9053acc42c6435a7f69d91b41547026f833291\" +\n+              \"d488e477c7ccba698c143633a304f463d6af4a3e72c189234fcfc360013e65\" +\n+              \"b07b7f7a36c529d3fdbbdbd6224bf100c14bc5354893b44790f54c739a2b1f\" +\n+              \"5bda82d70fb600ed9b0606dbddea52e508b492b72d8779856274aaaaddc0a3\" +\n+              \"edb6cfc788b603101bedfcc3f44baa62336bd950c2e349d5daf04f2e23ec26\" +\n+              \"28893d214e277569c565e5e6aa8b72ffa14118a3b57f814b4deb179980b5ee\" +\n+              \"efa4fd93f1751850466e929be537801babc2120f3ff1ffe5fea813ec7788ea\" +\n+              \"f43f5ef657e5af48395c3ad11aaf741549090b58670695f7c95c68e00576ca\" +\n+              \"18ef0313f2b4b757219fc8db3dc2db28721d6f912547ebfebcd96935c3100a\" +\n+              \"a4e4df9955acae1b4e2c10df1166d46c4285ab631c6d2ce58ad3ae99c07c01\" +\n+              \"9dcd15958694055281ccd6f803af290431f188cc4c429e84a4c30fd9c63968\" +\n+              \"dfd0951c417efb71921c207de172a9546bdd3e2bb35b45e140892c649f88c3\" +\n+              \"1a438f864e801a69f8010aa3d77a26601a7a89067c81b0f7e70d8e82f21f88\" +\n+              \"c7d0bb0c8ca0db875d6c3f8c6f6d709bbb31c7da2e31f3571daa2c5ab13bfc\" +\n+              \"16624cf35abd526e84269fb45bbd2fcd8c383d6fbb700bc4b5205b3ef8c432\" +\n+              \"3dc0d9e0370e56a3d1e5e76aa4de082e4c2a0afd092845bd5dab52a4594318\" +\n+              \"1461b76e3984b95f48bea80a94944241d04b5634c86274e7\" },\n+            { \"AES\/KWP\/NoPadding\", \"6decf10a1caf8e3b80c7a4be8c9c84e8\", 16,\n+              \"49\", 1, \"01a7d657fc4a5b216f261cca4d052c2b\" },\n+            { \"AES\/KWP\/NoPadding\", \"a8e06da625a65b25cf5030826830b661\", 16,\n+              \"43acff293120dd5d\", 8, \"b6f967616dd8d772e9fea295a456dba7\" },\n+            { \"AES\/KWP\/NoPadding\", \"7865e20f3c21659ab4690b629cdf3cc4\", 16,\n+              \"bd6843d420378dc896\", 9,\n+              \"41eca956d4aa047eb5cf4efe659661e74db6f8c564e23500\" },\n+            { \"AES\/KWP\/NoPadding\", \"be96dc195ec034d616486ed70e97fe83\", 16,\n+              \"85b5437b6335ebba7635903a4493d12a77d9357a9e0dbc013456d85f1d3201\",\n+              31,\n+              \"974769b3a7b4d5d32985f87fddf9990631e5610fbfb278387b58b1f48e05c7\" +\n+              \"7d2fb7575c5169eb0e\" },\n+            { \"AES\/KWP\/NoPadding\", \"0e54956a24c7d4a343f90269fb18a17f\", 16,\n+              \"817ddabdc5d215eee233adff97e92193c6beec52a71340477f70243a794ce9\" +\n+              \"54af51e356c9940e4ab198f0e68c543355f65ad179cb2d60dd369eaeb9ed14\" +\n+              \"1fb18c9e4054ac7fdc83506896990a4d20833d2d6e9a34938796ee67c9d7d2\" +\n+              \"3058544a4a35f2954103ce443a95a7e785602075ca0a73da37899e4568106b\" +\n+              \"b2dbf1f901377d4d3380c70fa5175ebc550481ac6f15986a4407fde5c23ff3\" +\n+              \"17e37544c0a25f87117506597db5bb79850c86247b73a5d0090417d63e4c25\" +\n+              \"7ea0220c2c04db07a34f0ab7954e1dfa2007a1466795c4d0c2aa09ca3986c0\" +\n+              \"28185b43a466526594afc9c891c263a7c608304bc1957c9873f544dc71e6f8\" +\n+              \"47c48d32026ed03b2333825452ee7e12a50e1cd7d678319264c65f78001996\" +\n+              \"d37fae7f9861fbd21cb506c2f8a3b0ee53c7debe17111b6e3f78a5c5677857\" +\n+              \"b082c2c4943dfd1edf6337fea98a44fc25928361156ef38d865948b979cf6f\" +\n+              \"4b46bd2119f12f0891cef7fc9d0638fd105fc05f9968d16948d1cb820751e8\" +\n+              \"2e44cb68e99d4f072ffd1577da6c0631b5827bec7e1b9ec72d18b74cf5f233\" +\n+              \"e85013c1668ceb5d7a1f5e0f016b0ff726a0a9d41e2cea8e14a2f56492b146\" +\n+              \"06d3fafd8ac141335f39f90d56863735628e8f17be90e100ef0785f3cd57db\" +\n+              \"8b9d89a6b2189dc2ea00c285d2657983f8bd7883c215477e67a55556401f1d\" +\n+              \"8b27d4e0d541c7fb7ace370c2e428884\", 512,\n+              \"876f3e53ba9cf4f6a521ac198bc813d0ede0f862ab6082e3e0a06ad82b4f27\" +\n+              \"9582f7c43bb63574608446bc2a05f401a68f74086cf2776b4b3df6b3679c2e\" +\n+              \"dfb91c024db54c6831e0752ae6f86c7596462de905ee0be908c1b9d043ecaf\" +\n+              \"e2ad1cbddb904e18ebc9b7a107031be3a87059516a3d1257812d9c801b0b9f\" +\n+              \"21539e70c47150c128d87c5e58fa6e4371aedde69c7b5cd16b73ac42267632\" +\n+              \"8131f3ac48c602bb6e0741805aad9d23b33b3523b86cf0588cdf9dc6c4d5f9\" +\n+              \"fa43d88ca17976eaf48fb37a41a598266da04144373df5631cc5126341c200\" +\n+              \"a0c8499b29ae96e6e6e6c2bdf8d8903da62bf8ddae970569b695240e77f8ac\" +\n+              \"5b191da5034008b6ef21936858e69bac372bbafd8794f6b03711503c187552\" +\n+              \"8a9348681844edb199a0664d740f0f0b1f866c4248c80fe8b5700a3c4134cd\" +\n+              \"ddb17676e0cd37d6d81831a0f4adfba071bb0935502480eccd48b28be5954e\" +\n+              \"a6c7d873b51b8bd2b709c5b6132ed31296510915073c18f7012f0eff6a9aad\" +\n+              \"5340a19fd5e372d35260b718d9e4807b1954c24e6a4fd48e4dbb8f395474e9\" +\n+              \"9ab577367d2ab5ccaa18c947331047dc3986e213a878b41089aa221019dad4\" +\n+              \"191a4feefd095f8606c2700a46d71cbb13efb6957df925ec26071c04d04d5a\" +\n+              \"94e138e5fc5d1f059236aad76208077dcc607b1dd2086f9c04e33f955822b4\" +\n+              \"57eecd68bd5f24836ecedbac675e6ed93d8a787cb57ad68e\" },\n+        };\n+    }\n+\n+    \/\/@Test(dataProvider = \"testData\")\n+    public void testKeyWrap(String algo, String key, int keyLen,\n+            String data, int dataLen, String expected, Provider p)\n+            throws Exception {\n+        System.out.println(\"Testing \" +  algo + \" Cipher with wrapping \" +\n+            dataLen + \"-byte key with \" + 8*keyLen + \"-bit KEK\");\n+        int allowed = Cipher.getMaxAllowedKeyLength(\"AES\");\n+        if (keyLen > allowed) {\n+            System.out.println(\"=> skip, exceeds max allowed size \" + allowed);\n+            return;\n+        }\n+        Cipher c1 = Cipher.getInstance(algo, \"SunJCE\");\n+        Cipher c2 = Cipher.getInstance(algo, \"SunJCE\");\n+        Cipher c3 = Cipher.getInstance(algo, \"SunJCE\");\n+\n+        byte[] keyVal = toBytes(key, keyLen << 1);\n+        byte[] dataVal = toBytes(data, dataLen << 1);\n+\n+        SecretKey cipherKey = new SecretKeySpec(keyVal, \"AES\");\n+        SecretKey toBeWrappedKey = new SecretKeySpec(dataVal, \"AES\");\n+\n+        c1.init(Cipher.WRAP_MODE, cipherKey);\n+        IvParameterSpec ivSpec = new IvParameterSpec(c1.getIV());\n+        c2.init(Cipher.WRAP_MODE, cipherKey, ivSpec);\n+        AlgorithmParameters params = AlgorithmParameters.getInstance(\"AES\");\n+        params.init(ivSpec);\n+        c3.init(Cipher.WRAP_MODE, cipherKey, params);\n+\n+        \/\/ first test WRAP with known values\n+        byte[] wrapped = c1.wrap(toBeWrappedKey);\n+        byte[] wrapped2 = c2.wrap(toBeWrappedKey);\n+        byte[] wrapped3 = c3.wrap(toBeWrappedKey);\n+\n+        byte[] expectedVal = toBytes(expected, expected.length());\n+\n+        if (!Arrays.equals(wrapped, expectedVal) ||\n+                !Arrays.equals(wrapped2, expectedVal) ||\n+                !Arrays.equals(wrapped3, expectedVal)) {\n+            throw new Exception(\"Wrap test failed; got different result\");\n+        }\n+\n+        \/\/ then test UNWRAP and compare with the initial values\n+        c1.init(Cipher.UNWRAP_MODE, cipherKey);\n+        ivSpec = new IvParameterSpec(c1.getIV());\n+        c2.init(Cipher.UNWRAP_MODE, cipherKey, ivSpec);\n+        params = AlgorithmParameters.getInstance(\"AES\");\n+        params.init(ivSpec);\n+        c3.init(Cipher.UNWRAP_MODE, cipherKey, params);\n+\n+        Key unwrapped = c1.unwrap(wrapped, \"AES\", Cipher.SECRET_KEY);\n+        Key unwrapped2 = c2.unwrap(wrapped, \"AES\", Cipher.SECRET_KEY);\n+        Key unwrapped3 = c3.unwrap(wrapped, \"AES\", Cipher.SECRET_KEY);\n+\n+        if (!Arrays.equals(unwrapped.getEncoded(), dataVal) ||\n+                !Arrays.equals(unwrapped2.getEncoded(), dataVal) ||\n+                !Arrays.equals(unwrapped3.getEncoded(), dataVal)) {\n+            throw new Exception(\"Unwrap failed; got different result\");\n+        }\n+    }\n+\n+    \/\/@Test(dataProvider = \"testData\")\n+    public void testEnc(String algo, String key, int keyLen, String data,\n+            int dataLen, String expected, Provider p)\n+            throws Exception {\n+        System.out.println(\"Testing \" +  algo + \" Cipher with enc \" +\n+            dataLen + \"-byte data with \" + 8*keyLen + \"-bit KEK\");\n+        int allowed = Cipher.getMaxAllowedKeyLength(\"AES\");\n+        if (keyLen > allowed) {\n+            System.out.println(\"=> skip, exceeds max allowed size \" + allowed);\n+            return;\n+        }\n+        Cipher c1 = Cipher.getInstance(algo, \"SunJCE\");\n+        Cipher c2 = Cipher.getInstance(algo, \"SunJCE\");\n+        Cipher c3 = Cipher.getInstance(algo, \"SunJCE\");\n+\n+        byte[] keyVal = toBytes(key, keyLen << 1);\n+        byte[] dataVal = toBytes(data, dataLen << 1);\n+\n+        SecretKey cipherKey = new SecretKeySpec(keyVal, \"AES\");\n+        c1.init(Cipher.ENCRYPT_MODE, cipherKey);\n+        IvParameterSpec ivSpec = new IvParameterSpec(c1.getIV());\n+        c2.init(Cipher.ENCRYPT_MODE, cipherKey, ivSpec);\n+        AlgorithmParameters params = AlgorithmParameters.getInstance(\"AES\");\n+        params.init(ivSpec);\n+        c3.init(Cipher.ENCRYPT_MODE, cipherKey, params);\n+\n+        \/\/ first test encryption with known values\n+        byte[] ct11 = c1.update(dataVal);\n+        byte[] ct12 = c1.doFinal();\n+        byte[] ct2 = c1.doFinal(dataVal);\n+        byte[] ct22 = c2.doFinal(dataVal);\n+        byte[] ct32 = c3.doFinal(dataVal);\n+\n+        byte[] expectedVal = toBytes(expected, expected.length());\n+\n+        if (ct11 != null || !Arrays.equals(ct12, ct2) ||\n+                !Arrays.equals(ct2, expectedVal) ||\n+                !Arrays.equals(ct22, expectedVal) ||\n+                !Arrays.equals(ct32, expectedVal)) {\n+            throw new Exception(\"Encryption failed; got different result\");\n+        }\n+\n+        \/\/ then test decryption and compare with the initial values\n+        c1.init(Cipher.DECRYPT_MODE, cipherKey);\n+        ivSpec = new IvParameterSpec(c1.getIV());\n+        c2.init(Cipher.DECRYPT_MODE, cipherKey, ivSpec);\n+        params = AlgorithmParameters.getInstance(\"AES\");\n+        params.init(ivSpec);\n+        c3.init(Cipher.DECRYPT_MODE, cipherKey, params);\n+\n+        byte[] pt11 = c1.update(ct12);\n+        byte[] pt12 = c1.doFinal();\n+        byte[] pt2 = c1.doFinal(ct2);\n+        byte[] pt22 = c2.doFinal(ct2);\n+        byte[] pt32 = c3.doFinal(ct2);\n+\n+        if (pt11 != null || !Arrays.equals(pt12, pt2) ||\n+                !Arrays.equals(pt2, dataVal) || !Arrays.equals(pt22, dataVal) ||\n+                !Arrays.equals(pt32, dataVal)) {\n+            throw new Exception(\"Decryption failed; got different result\");\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        main(new NISTWrapKAT(), args);\n+    }\n+\n+    @Override\n+    public void main(Provider p) throws Exception {\n+        Object[][] testDatum = testData();\n+        for (int i = 0; i < testDatum.length; i++) {\n+            Object[] td = testDatum[i];\n+            String algo = (String) td[0];\n+            if (p.getService(\"Cipher\", algo) == null) {\n+                System.out.println(\"Skip, due to no support:  \" + algo);\n+                continue;\n+            }\n+            testKeyWrap(algo, (String)td[1], (int)td[2], (String)td[3],\n+                    (int)td[4], (String)td[5], p);\n+            testEnc(algo, (String)td[1], (int)td[2], (String)td[3],\n+                    (int)td[4], (String)td[5], p);\n+        }\n+        System.out.println(\"Test Passed\");\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/pkcs11\/Cipher\/KeyWrap\/NISTWrapKAT.java","additions":395,"deletions":0,"binary":false,"changes":395,"status":"added"},{"patch":"@@ -0,0 +1,179 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import static java.lang.System.out;\n+\n+import java.lang.Integer;\n+import java.lang.String;\n+import java.lang.System;\n+import java.security.AlgorithmParameters;\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.InvalidKeyException;\n+import java.security.Key;\n+import java.security.KeyPair;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.KeyPairGenerator;\n+import java.security.Provider;\n+import java.security.Security;\n+import java.security.spec.AlgorithmParameterSpec;\n+import java.security.spec.InvalidKeySpecException;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Random;\n+\n+import javax.crypto.IllegalBlockSizeException;\n+import javax.crypto.NoSuchPaddingException;\n+import javax.crypto.SecretKey;\n+import javax.crypto.Cipher;\n+import javax.crypto.KeyGenerator;\n+import javax.crypto.SecretKeyFactory;\n+import javax.crypto.spec.PBEKeySpec;\n+import javax.crypto.spec.PBEParameterSpec;\n+import javax.crypto.spec.SecretKeySpec;\n+\n+\/*\n+ * @test\n+ * @bug 8264849\n+ * @summary Tests for key wrap and unwrap operations\n+ * @library \/test\/lib ..\/..\n+ * @run main\/othervm TestCipherKeyWrapperTest\n+ *\/\n+\/\/ adapted from\n+\/\/ com\/sun\/crypto\/provider\/Cipher\/KeyWrap\/TestCipherKeyWrapperTest.java\n+public class TestCipherKeyWrapperTest extends PKCS11Test {\n+    private static final int LINIMITED_KEYSIZE = 128;\n+\n+    private static final byte[] DATA_32 =\n+            Arrays.copyOf(\"1234567890123456789012345678901234\".getBytes(), 32);\n+\n+    private enum TestVector {\n+        AESWrap(\"AES\", \"AESWrap\", -1),\n+        AESWrap_128(\"AES\", \"AESWrap_128\", 128),\n+        AESWrap_192(\"AES\", \"AESWrap_192\", 192),\n+        AESWrap_256(\"AES\", \"AESWrap_256\", 256),\n+        AESWrapPad(\"AES\", \"AESWrapPad\", -1),\n+        AESWrapPad_128(\"AES\", \"AESWrapPad_128\", 128),\n+        AESWrapPad_192(\"AES\", \"AESWrapPad_192\", 192),\n+        AESWrapPad_256(\"AES\", \"AESWrapPad_256\", 256);\n+\n+        final String algo;\n+        final String wrapperAlgo;\n+        final int keySize; \/\/ -1 means no restriction\n+        final SecretKey wrapperKey;\n+\n+        private TestVector(String algo, String wrapperAlgo, int kSize) {\n+            this.algo = algo;\n+            this.wrapperAlgo = wrapperAlgo;\n+            this.keySize = kSize;\n+            if (kSize == -1) {\n+                this.wrapperKey = new SecretKeySpec(DATA_32, \"AES\");\n+            } else {\n+                this.wrapperKey = new SecretKeySpec(DATA_32, 0, kSize >> 3,\n+                        \"AES\");\n+            }\n+        }\n+    };\n+\n+    public static void main(String[] args) throws Exception {\n+        main(new TestCipherKeyWrapperTest(), args);\n+    }\n+\n+    @Override\n+    public void main(Provider p) throws Exception {\n+        for (TestVector tv : TestVector.values()) {\n+            if (p.getService(\"Cipher\", tv.wrapperAlgo) == null) {\n+                System.out.println(\"Skip, due to no support:  \" +\n+                        tv.wrapperAlgo);\n+                continue;\n+            }\n+\n+            \/\/ only run the tests on longer key lengths if unlimited\n+            \/\/ version of JCE jurisdiction policy files are installed\n+            if (!(Cipher.getMaxAllowedKeyLength(tv.algo) == Integer.MAX_VALUE)\n+                    && tv.keySize > LINIMITED_KEYSIZE) {\n+                out.println(tv.algo + \" will not run if unlimited version of\"\n+                        + \" JCE jurisdiction policy files are installed\");\n+                continue;\n+            }\n+            wrapperSecretKeyTest(p, tv.wrapperAlgo, tv.wrapperKey, tv.algo);\n+            wrapperPrivateKeyTest(p, tv.wrapperAlgo, tv.wrapperKey, \"RSA\");\n+        }\n+    }\n+\n+    private void wrapperSecretKeyTest(Provider p, String wrapAlgo,\n+            SecretKey key, String algo)\n+              throws Exception {\n+        \/\/ Initialization\n+        KeyGenerator kg = KeyGenerator.getInstance(algo, p);\n+        SecretKey skey = kg.generateKey();\n+        wrapTest(p, wrapAlgo, key, skey, Cipher.SECRET_KEY);\n+    }\n+\n+    private void wrapperPrivateKeyTest(Provider p, String wrapAlgo,\n+            SecretKey key, String algo)\n+              throws Exception {\n+        \/\/ Key pair generated\n+        KeyPairGenerator kpg = KeyPairGenerator.getInstance(algo, p);\n+        kpg.initialize(2048);\n+        System.out.println(\"Generate key pair (algorithm: \" + algo\n+                + \", provider: \" + kpg.getProvider().getName() + \")\");\n+\n+        KeyPair kp = kpg.genKeyPair();\n+        \/\/ key generated\n+        wrapTest(p, wrapAlgo, key, kp.getPrivate(), Cipher.PRIVATE_KEY);\n+    }\n+\n+    private void wrapTest(Provider p, String wrapAlgo, SecretKey initKey,\n+            Key tbwKey, int keyType)\n+            throws Exception {\n+        AlgorithmParameters aps = null;\n+\n+        out.println(\"Testing \" + wrapAlgo + \" cipher wrap\/unwrap\");\n+\n+        Cipher wrapCI = Cipher.getInstance(wrapAlgo, p);\n+\n+        byte[] keyEncoding = tbwKey.getEncoded();\n+        if (wrapAlgo.indexOf(\"Pad\") == -1 &&\n+                (keyEncoding.length % wrapCI.getBlockSize() != 0)) {\n+            System.out.println(\"Skip due to key length: \" +\n+                    keyEncoding.length);\n+            return;\n+        }\n+        \/\/ Wrap & Unwrap operation\n+        System.out.println(\"calling wrap()\");\n+        wrapCI.init(Cipher.WRAP_MODE, initKey);\n+        aps = wrapCI.getParameters();\n+        byte[] keyWrapped = wrapCI.wrap(tbwKey);\n+\n+        wrapCI.init(Cipher.UNWRAP_MODE, initKey, aps);\n+        Key unwrappedKey = wrapCI.unwrap(keyWrapped, tbwKey.getAlgorithm(),\n+                keyType);\n+        \/\/ Comparison\n+        if (!Arrays.equals(tbwKey.getEncoded(), unwrappedKey.getEncoded())) {\n+            out.println(\"key encoding len : \" + tbwKey.getEncoded().length);\n+            throw new RuntimeException(\"Comparation failed testing \"\n+                    + wrapAlgo + \":\" + keyType);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/pkcs11\/Cipher\/KeyWrap\/TestCipherKeyWrapperTest.java","additions":179,"deletions":0,"binary":false,"changes":179,"status":"added"},{"patch":"@@ -0,0 +1,334 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8264849\n+ * @summary Verify general properties of the AES\/KW\/NoPadding,\n+ *     AES\/KW\/PKCS5Padding, and AES\/KWP\/NoPadding impls of SunPKCS11 provider.\n+ * @library \/test\/lib ..\/..\n+ * @run main\/othervm TestGeneral\n+ *\/\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.HexFormat;\n+import java.security.*;\n+import javax.crypto.*;\n+import javax.crypto.spec.*;\n+\n+\/\/ adapted from com\/sun\/crypto\/provider\/Cipher\/KeyWrap\/TestGeneral.java\n+public class TestGeneral extends PKCS11Test {\n+\n+    private static final byte[] DATA_32 =\n+            Arrays.copyOf(\"1234567890123456789012345678901234\".getBytes(), 32);\n+    private static final SecretKey KEY =\n+            new SecretKeySpec(DATA_32, 0, 16, \"AES\");\n+    private static final int KW_IV_LEN = 8;\n+    private static final int KWP_IV_LEN = 4;\n+    private static final int MAX_KW_PKCS5PAD_LEN = 8; \/\/ 1-8\n+    private static final int MAX_KWP_PAD_LEN = 7; \/\/ 0-7\n+\n+    public static void testEnc(Cipher c, byte[] in, int startLen, int inc,\n+            IvParameterSpec[] ivs, int maxPadLen) throws Exception {\n+\n+        System.out.println(\"testEnc, input len=\" + startLen + \" w\/ inc=\" +\n+                inc);\n+        for (IvParameterSpec iv : ivs) {\n+            System.out.print(\"\\t=> w\/ iv=\" + iv);\n+\n+            for (int inLen = startLen; inLen < in.length; inLen+=inc) {\n+                c.init(Cipher.ENCRYPT_MODE, KEY, iv);\n+\n+                int estOutLen = c.getOutputSize(inLen);\n+                System.out.println(\", inLen=\" + inLen);\n+                byte[] out = c.doFinal(in, 0, inLen);\n+\n+                \/\/ check the length of encryption output\n+                if (estOutLen != out.length || (out.length % 8 != 0) ||\n+                        (out.length - inLen < 8)) {\n+                    System.out.println(\"=> estimated: \" + estOutLen);\n+                    System.out.println(\"=> actual: \" + out.length);\n+                    throw new RuntimeException(\"Failed enc output len check\");\n+                }\n+\n+                \/\/System.out.println(\"enc out.length=\" + out.length);\n+                c.init(Cipher.DECRYPT_MODE, KEY, iv);\n+                estOutLen = c.getOutputSize(out.length);\n+                byte[] recovered = new byte[estOutLen];\n+\n+                \/\/ do decryption using ByteBuffer and multi-part\n+                ByteBuffer outBB = ByteBuffer.wrap(out);\n+                ByteBuffer recoveredBB = ByteBuffer.wrap(recovered);\n+                int len = c.update(outBB, recoveredBB);\n+                len += c.doFinal(outBB, recoveredBB);\n+\n+                \/\/ check the length of decryption output\n+                if (estOutLen < len || (estOutLen - len) > maxPadLen) {\n+                    System.out.println(\"=> estimated: \" + estOutLen);\n+                    System.out.println(\"=> actual: \" + len);\n+                    throw new RuntimeException(\"Failed dec output len check\");\n+                }\n+\n+                if (!Arrays.equals(in, 0, inLen, recovered, 0, len)) {\n+                    throw new RuntimeException(\"Failed decrypted data check\");\n+                }\n+            }\n+        }\n+    }\n+\n+    public static void testKAT(Cipher c, String keyStr, String inStr,\n+            String expectedStr) throws Exception {\n+\n+        System.out.println(\"testKAT, input len: \" + inStr.length()\/2);\n+\n+        byte[] keyVal = HexFormat.of().parseHex(keyStr);\n+        byte[] in = HexFormat.of().parseHex(inStr);\n+        byte[] expected = HexFormat.of().parseHex(expectedStr);\n+\n+        c.init(Cipher.ENCRYPT_MODE, new SecretKeySpec(keyVal, \"AES\"));\n+\n+        byte[] out = c.doFinal(in);\n+\n+        if (!Arrays.equals(out, expected)) {\n+            System.out.println(\"=> expected: \" +\n+                    HexFormat.of().withUpperCase().formatHex(expected));\n+            System.out.println(\"=> actual: \" +\n+                    HexFormat.of().withUpperCase().formatHex(out));\n+            throw new RuntimeException(\"Failed KAT check\");\n+        }\n+    }\n+\n+    public static void testWrap(Cipher c, Key[] inKeys, IvParameterSpec[] ivs,\n+            int maxPadLen) throws Exception {\n+\n+        for (Key inKey : inKeys) {\n+            System.out.println(\"testWrap, key: \" + inKey);\n+            for (IvParameterSpec iv : ivs) {\n+                System.out.println(\"\\t=> w\/ iv \" + iv);\n+\n+                c.init(Cipher.WRAP_MODE, KEY, iv);\n+\n+                byte[] out = c.wrap(inKey);\n+\n+                \/\/ output should always be multiple of cipher block size\n+                if (out.length % c.getBlockSize() != 0) {\n+                    throw new RuntimeException(\"Invalid wrap len: \" +\n+                            out.length);\n+                }\n+\n+                c.init(Cipher.UNWRAP_MODE, KEY, iv);\n+\n+                \/\/ SecretKey or PrivateKey\n+                int keyType = (inKey instanceof SecretKey? Cipher.SECRET_KEY :\n+                        Cipher.PRIVATE_KEY);\n+\n+                int estOutLen = c.getOutputSize(out.length);\n+                Key key2 = c.unwrap(out, inKey.getAlgorithm(), keyType);\n+\n+                if ((keyType == Cipher.SECRET_KEY &&\n+                        !(key2 instanceof SecretKey)) ||\n+                        (keyType == Cipher.PRIVATE_KEY &&\n+                        !(key2 instanceof PrivateKey))) {\n+                    throw new RuntimeException(\"Failed unwrap type check\");\n+                }\n+\n+                byte[] in2 = key2.getEncoded();\n+                \/\/ check decryption output length\n+                if (estOutLen < in2.length ||\n+                        (estOutLen - in2.length) > maxPadLen) {\n+                    System.out.println(\"=> estimated: \" + estOutLen);\n+                    System.out.println(\"=> actual: \" + in2.length);\n+                    throw new RuntimeException(\"Failed unwrap len check\");\n+                }\n+\n+                if (!Arrays.equals(inKey.getEncoded(), in2) ||\n+                        !(inKey.getAlgorithm().equalsIgnoreCase\n+                        (key2.getAlgorithm()))) {\n+                    throw new RuntimeException(\"Failed unwrap key check\");\n+                }\n+            }\n+        }\n+    }\n+\n+    public static void testIv(Cipher c, int defIvLen, boolean allowCustomIv)\n+            throws Exception {\n+\n+        System.out.println(\"testIv: defIvLen = \" + defIvLen +\n+                \" allowCustomIv = \" + allowCustomIv);\n+\n+        \/\/ get a fresh Cipher instance so we can test iv with pre-init state\n+        c = Cipher.getInstance(c.getAlgorithm(), c.getProvider());\n+        if (c.getIV() != null) {\n+            throw new RuntimeException(\"Expects null iv\");\n+        }\n+\n+        AlgorithmParameters ivParams = c.getParameters();\n+        if (ivParams == null) {\n+            throw new RuntimeException(\"Expects non-null default parameters\");\n+        }\n+        IvParameterSpec ivSpec =\n+                ivParams.getParameterSpec(IvParameterSpec.class);\n+        byte[] iv = ivSpec.getIV();\n+        \/\/ try through all opmodes\n+        c.init(Cipher.ENCRYPT_MODE, KEY);\n+        c.init(Cipher.DECRYPT_MODE, KEY);\n+        c.init(Cipher.WRAP_MODE, KEY);\n+        c.init(Cipher.UNWRAP_MODE, KEY);\n+\n+        byte[] defIv = c.getIV();\n+\n+        \/\/ try again through all opmodes\n+        c.init(Cipher.ENCRYPT_MODE, KEY);\n+        c.init(Cipher.DECRYPT_MODE, KEY);\n+        c.init(Cipher.WRAP_MODE, KEY);\n+        c.init(Cipher.UNWRAP_MODE, KEY);\n+\n+        byte[] defIv2 = c.getIV();\n+        if (iv.length != defIvLen || !Arrays.equals(iv, defIv) ||\n+                !Arrays.equals(defIv, defIv2)) {\n+            throw new RuntimeException(\"Failed default iv check\");\n+        }\n+        if (defIv == defIv2) {\n+            throw new RuntimeException(\"Failed getIV copy check\");\n+        }\n+\n+        \/\/ try init w\/ an iv w\/ invalid length\n+        try {\n+            c.init(Cipher.ENCRYPT_MODE, KEY, new IvParameterSpec(defIv, 0,\n+                    defIv.length\/2));\n+            throw new RuntimeException(\"Invalid iv accepted\");\n+        } catch (InvalidAlgorithmParameterException iape) {\n+            System.out.println(\"Invalid IV rejected as expected\");\n+        }\n+\n+        if (allowCustomIv) {\n+            Arrays.fill(defIv, (byte) 0xFF);\n+            \/\/ try through all opmodes\n+            c.init(Cipher.ENCRYPT_MODE, KEY, new IvParameterSpec(defIv));\n+            c.init(Cipher.DECRYPT_MODE, KEY, new IvParameterSpec(defIv));\n+            c.init(Cipher.WRAP_MODE, KEY, new IvParameterSpec(defIv));\n+            c.init(Cipher.UNWRAP_MODE, KEY, new IvParameterSpec(defIv));\n+\n+            if (!Arrays.equals(defIv, c.getIV())) {\n+                throw new RuntimeException(\"Failed set iv check\");\n+            }\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        main(new TestGeneral(), args);\n+    }\n+\n+    @Override\n+    public void main(Provider p) throws Exception {\n+        byte[] data = DATA_32;\n+\n+        SecretKey aes256 = new SecretKeySpec(DATA_32, \"AES\");\n+        SecretKey any256 = new SecretKeySpec(DATA_32, \"ANY\");\n+        PrivateKey priv = KeyPairGenerator.getInstance\n+                (\"RSA\", \"SunRsaSign\").generateKeyPair().getPrivate();\n+\n+        String[] algos = {\n+            \"AES\/KW\/PKCS5Padding\", \"AES\/KW\/NoPadding\", \"AES\/KWP\/NoPadding\"\n+        };\n+        for (String a : algos) {\n+            if (p.getService(\"Cipher\", a) == null) {\n+                System.out.println(\"Skip, due to no support:  \" + a);\n+                continue;\n+            }\n+\n+            System.out.println(\"Testing \" + a);\n+            Cipher c = Cipher.getInstance(a, p);\n+\n+            int blkSize = c.getBlockSize();\n+\n+            \/\/ set the default based on AES\/KWP\/NoPadding, the other two\n+            \/\/ override as needed\n+            int startLen = data.length - blkSize;\n+            int inc = 1;\n+            IvParameterSpec[] ivs = new IvParameterSpec[] { null };\n+            int padLen = MAX_KWP_PAD_LEN;\n+            Key[] keys = new Key[] { aes256, any256, priv };\n+            int ivLen = KWP_IV_LEN;\n+            boolean allowCustomIv = false;\n+\n+            switch (a) {\n+            case \"AES\/KW\/PKCS5Padding\":\n+                ivs = new IvParameterSpec[] {\n+                        null, new IvParameterSpec(DATA_32, 0, KW_IV_LEN) };\n+                padLen = MAX_KW_PKCS5PAD_LEN;\n+                ivLen = KW_IV_LEN;\n+                allowCustomIv = true;\n+                break;\n+            case \"AES\/KW\/NoPadding\":\n+                testKAT(c, \"000102030405060708090A0B0C0D0E0F\",\n+                        \"00112233445566778899AABBCCDDEEFF\",\n+                        \"1FA68B0A8112B447AEF34BD8FB5A7B829D3E862371D2CFE5\");\n+                testKAT(c, \"000102030405060708090A0B0C0D0E0F1011121314151617\",\n+                        \"00112233445566778899AABBCCDDEEFF\",\n+                        \"96778B25AE6CA435F92B5B97C050AED2468AB8A17AD84E5D\");\n+                testKAT(c, \"000102030405060708090A0B0C0D0E0F1011121314151617\" +\n+                        \"18191A1B1C1D1E1F\",\n+                        \"00112233445566778899AABBCCDDEEFF\",\n+                        \"64E8C3F9CE0F5BA263E9777905818A2A93C8191E7D6E8AE7\");\n+                testKAT(c, \"000102030405060708090A0B0C0D0E0F1011121314151617\",\n+                        \"00112233445566778899AABBCCDDEEFF0001020304050607\",\n+                        \"031D33264E15D33268F24EC260743EDCE1C6C7DDEE725A936BA\" +\n+                        \"814915C6762D2\");\n+                testKAT(c, \"000102030405060708090A0B0C0D0E0F1011121314151617\" +\n+                        \"18191A1B1C1D1E1F\",\n+                        \"00112233445566778899AABBCCDDEEFF0001020304050607\",\n+                        \"A8F9BC1612C68B3FF6E6F4FBE30E71E4769C8B80A32CB8958CD\" +\n+                        \"5D17D6B254DA1\");\n+                testKAT(c, \"000102030405060708090A0B0C0D0E0F1011121314151617\" +\n+                        \"18191A1B1C1D1E1F\",\n+                        \"00112233445566778899AABBCCDDEEFF0001020304050607080\" +\n+                        \"90A0B0C0D0E0F\",\n+                        \"28C9F404C4B810F4CBCCB35CFB87F8263F5786E2D80ED326CBC\" +\n+                        \"7F0E71A99F43BFB988B9B7A02DD21\");\n+                startLen = data.length >> 1;\n+                inc = blkSize;\n+                ivs = new IvParameterSpec[] {\n+                        null, new IvParameterSpec(DATA_32, 0, KW_IV_LEN) };\n+                padLen = 0;\n+                keys = new Key[] { aes256, any256 };\n+                ivLen = KW_IV_LEN;\n+                allowCustomIv = true;\n+                break;\n+            case \"AES\/KWP\/NoPadding\":\n+                testKAT(c, \"5840df6e29b02af1ab493b705bf16ea1ae8338f4dcc176a8\",\n+                        \"c37b7e6492584340bed12207808941155068f738\",\n+                        \"138bdeaa9b8fa7fc61f97742e72248ee5ae6ae5360d1ae6a5f54f373fa543b6a\");\n+                testKAT(c, \"5840df6e29b02af1ab493b705bf16ea1ae8338f4dcc176a8\",\n+                        \"466f7250617369\", \"afbeb0f07dfbf5419200f2ccb50bb24f\");\n+\n+                break;\n+            }\n+            \/\/ now test based on the configured arguments\n+            testEnc(c, data, startLen, inc, ivs, padLen);\n+            testWrap(c, keys, ivs, padLen);\n+            testIv(c, ivLen, allowCustomIv);\n+        }\n+        System.out.println(\"All Tests Passed\");\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/pkcs11\/Cipher\/KeyWrap\/TestGeneral.java","additions":334,"deletions":0,"binary":false,"changes":334,"status":"added"},{"patch":"@@ -0,0 +1,103 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8264849\n+ * @summary Verify cipher key size restriction is enforced properly with IKE\n+ * @library \/test\/lib ..\/..\n+ * @run main\/othervm TestKeySizeCheck\n+ *\/\n+import java.util.Arrays;\n+import java.security.*;\n+import javax.crypto.*;\n+import javax.crypto.spec.*;\n+\n+\/\/ adapted from com\/sun\/crypto\/provider\/Cipher\/KeyWrap\/TestKeySizeCheck.java\n+public class TestKeySizeCheck extends PKCS11Test {\n+\n+    private static final byte[] BYTES_32 =\n+            Arrays.copyOf(\"1234567890123456789012345678901234\".getBytes(), 32);\n+\n+    private static SecretKey getKey(int sizeInBytes) {\n+        if (sizeInBytes <= BYTES_32.length) {\n+            return new SecretKeySpec(BYTES_32, 0, sizeInBytes, \"AES\");\n+        } else {\n+            return new SecretKeySpec(new byte[sizeInBytes], \"AES\");\n+        }\n+    }\n+\n+    private static String getModeStr(int mode) {\n+        return (mode == Cipher.ENCRYPT_MODE? \"ENC\" : \"WRAP\");\n+    }\n+\n+    public static void test(Provider p, String algo, int[] invalidKeySizes)\n+            throws Exception {\n+\n+        Cipher c = Cipher.getInstance(algo, p);\n+        System.out.println(\"Testing \" + algo);\n+\n+        int[] modes = { Cipher.ENCRYPT_MODE, Cipher.WRAP_MODE };\n+        for (int ks : invalidKeySizes) {\n+            System.out.println(\"keysize: \" + ks);\n+            SecretKey key = getKey(ks);\n+\n+            for (int m : modes) {\n+                try {\n+                    c.init(m, key);\n+                    throw new RuntimeException(\"Expected IKE not thrown for \"\n+                            + getModeStr(m));\n+                } catch (InvalidKeyException ike) {\n+                    System.out.println(\" => expected IKE thrown for \"\n+                            + getModeStr(m));\n+                }\n+            }\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        main(new TestKeySizeCheck(), args);\n+    }\n+\n+    @Override\n+    public void main(Provider p) throws Exception {\n+        String[] algos = {\n+            \"AESWrap\", \"AESWrapPad\",\n+            \"AES\/KW\/PKCS5Padding\", \"AES\/KW\/NoPadding\", \"AES\/KWP\/NoPadding\"\n+        };\n+        int[] keySizes = { 128, 192, 256 };\n+\n+        for (String a : algos) {\n+            if (p.getService(\"Cipher\", a) == null) {\n+                System.out.println(\"Skip, due to no support:  \" + a);\n+                continue;\n+            }\n+            test(p, a, new int[] { 120, 264 });\n+            String from = (a == \"AESWrap\" || a == \"AESWrapPad\"? a : \"AES\");\n+            test(p, a.replace(from, from + \"_128\"), new int[] {192, 256 });\n+            test(p, a.replace(from, from + \"_192\"), new int[] {128, 256 });\n+            test(p, a.replace(from, from + \"_256\"), new int[] {128, 192 });\n+        }\n+        System.out.println(\"All Tests Passed\");\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/pkcs11\/Cipher\/KeyWrap\/TestKeySizeCheck.java","additions":103,"deletions":0,"binary":false,"changes":103,"status":"added"},{"patch":"@@ -0,0 +1,151 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8264849\n+ * @summary Verify that the key wrap cipher \"AESWrap\" work as expected.\n+ * @library \/test\/lib ..\/..\n+ * @run main\/othervm XMLEncKAT\n+ *\/\n+import java.util.Base64;\n+import java.security.Key;\n+import java.security.AlgorithmParameters;\n+import java.security.Provider;\n+import javax.crypto.*;\n+import javax.crypto.spec.*;\n+import java.io.UnsupportedEncodingException;\n+import java.io.IOException;\n+\n+\/\/ adapted from com\/sun\/crypto\/provider\/Cipher\/KeyWrap\/XMLEncKAT.java\n+public class XMLEncKAT extends PKCS11Test {\n+\n+    private static byte[] aes128Key_1;\n+    private static byte[] aes192Key_1;\n+    private static byte[] aes256Key_1;\n+    private static byte[] aes128Key_2;\n+    private static byte[] aes192Key_2;\n+    private static byte[] aes256Key_2;\n+\n+    private static Base64.Decoder base64D = Base64.getDecoder();\n+    private static Base64.Encoder base64E = Base64.getEncoder();\n+\n+    static {\n+        try {\n+            aes128Key_1 = \"abcdefghijklmnop\".getBytes(\"ASCII\");\n+            aes192Key_1 = \"abcdefghijklmnopqrstuvwx\".getBytes(\"ASCII\");\n+            aes256Key_1 = \"abcdefghijklmnopqrstuvwxyz012345\".getBytes(\"ASCII\");\n+        } catch (UnsupportedEncodingException uee) {\n+            \/\/ should never happen\n+        }\n+\n+        aes128Key_2 = base64D.decode(\"01+yuQ2huPS1+Qv0LH+zaQ==\");\n+        aes192Key_2 = base64D.decode(\"IlfuS40LvStVU0Mj8ePrrGHVhAb48y++\");\n+        aes256Key_2 = base64D.decode\n+            (\"ZhZ4v3RlwTlCEOpIrHfLKVyJOBDtEJOOQDat\/4xR1bA=\");\n+    }\n+    private static String[] aes128WrappedKey_1 = {\n+        \"dV45TUpJbidb9iKa34xj1WVtTZ036cnqvym2TBJWR5c=\",\n+        \"rPnY\/XoSGCbuwy7vpslf29rs9dbvSCmGFOjEs3LT6g\/qyZjfDA+2fQ==\"\n+    };\n+    private static String[] aes128WrappedKey_2 = {\n+        \"GPl6bneL1jKl0\/lGnf9gejlYHRI6XxFz\"\n+    };\n+    private static String[] aes192WrappedKey_1 = {\n+        \"IbjZH7Mq564oMybpvCHWYM\/5ER3eFsAV\",\n+        \"19D633XVohP6UJvaVRAhJek+ahtM3gOiVs6nZyAasDEb+WCUQOcWZw==\"\n+    };\n+    private static String[] aes192WrappedKey_2 = {\n+        \"5+GpVUQNTAT3uY8pPedEg\/PpftiX+fJsTCun+fgmIz0=\",\n+        \"iuZvvGBWScikHld9TtNIOz0Sm7Srg5AcxOBMA8qIvQY=\",\n+        \"PeDwjnCsg6xWzs3SmzUtc2nyUz28nGu7\"\n+    };\n+    private static String[] aes256WrappedKey_1 = {\n+        \"4AAgyi3M7xNdBimbQZKdGJLn3\/cS4Yv8QKuA01+gUnY=\",\n+        \"tPCC89jQShB+WDINCdRfKgf8wTlAx8xRXD73RmEHPBfix8zS1N82KQ==\",\n+        \"bsL63D0hPN6EOyzdgfEmKsAAvoJiGM+Wp9a9KZM92IKdl7s3YSntRg==\"\n+    };\n+    private static String[] aes256WrappedKey_2 = {\n+        \"IbnoS1cvuIFIGB46jj1V1FGftc92irrCwcC7BoBvxwQ=\",\n+        \"ic+Om6\/3ZKcThVN3iv9lUEankNkDv3Et\",\n+        \"jOvQe4SxDqEMvAHcmb3Z+\/Uedj23pvL6BRQsl2sjJlQ=\",\n+        \"IMwdsyg89IZ4Txf1SYYZNKUOKuYdDoIi\/zEKXCjj4j9PM6BdkZligA==\"\n+    };\n+\n+    private void testKeyWrap(Provider p, String cAlg, byte[] cKeyVal,\n+        String cKeyAlg, String[] base64Wrapped) throws Exception {\n+        System.out.println(\"Testing \" + cAlg + \" Cipher with \" +\n+            8*cKeyVal.length + \"-bit key\");\n+        Cipher c = Cipher.getInstance(cAlg, p);\n+        SecretKey cKey = new SecretKeySpec(cKeyVal, cKeyAlg);\n+        c.init(Cipher.UNWRAP_MODE, cKey);\n+        Key[] key = new SecretKey[base64Wrapped.length];\n+        IvParameterSpec[] params =\n+            new IvParameterSpec[base64Wrapped.length];\n+        \/\/ first test UNWRAP with known values\n+        for (int i = 0; i < base64Wrapped.length; i++) {\n+            byte[] wrappedKey = base64D.decode(base64Wrapped[i]);\n+            key[i] = c.unwrap(wrappedKey, \"AES\", Cipher.SECRET_KEY);\n+            if (c.getIV() != null) {\n+                params[i] = new IvParameterSpec(c.getIV());\n+            }\n+        }\n+        \/\/ then test WRAP and compare with the known values\n+        for (int i = 0; i < key.length; i++) {\n+            c.init(Cipher.WRAP_MODE, cKey, params[i]);\n+            byte[] wrapped2 = c.wrap(key[i]);\n+            String out = base64E.encodeToString(wrapped2);\n+            if (!out.equalsIgnoreCase(base64Wrapped[i])) {\n+                throw new Exception(\"Wrap failed; got \" + out + \", expect \" +\n+                                   base64Wrapped[i]);\n+            }\n+        }\n+    }\n+\n+    public static void main(String[] argv) throws Exception {\n+        main(new XMLEncKAT(), argv);\n+    }\n+\n+    @Override\n+    public void main(Provider p) throws Exception {\n+        String wrapAlg = \"AESWrap\";\n+\n+        if (p.getService(\"Cipher\", wrapAlg) == null) {\n+            System.out.println(\"Skip, due to no support:  \" + wrapAlg);\n+            return;\n+        }\n+\n+        String keyAlg = \"AES\";\n+        testKeyWrap(p, wrapAlg, aes128Key_1, keyAlg, aes128WrappedKey_1);\n+        testKeyWrap(p, wrapAlg, aes128Key_2, keyAlg, aes128WrappedKey_2);\n+        \/\/ only run the tests on longer key lengths if unlimited version\n+        \/\/ of JCE jurisdiction policy files are installed\n+        if (Cipher.getMaxAllowedKeyLength(keyAlg) == Integer.MAX_VALUE) {\n+            testKeyWrap(p, wrapAlg, aes192Key_1, keyAlg, aes192WrappedKey_1);\n+            testKeyWrap(p, wrapAlg, aes192Key_2, keyAlg, aes192WrappedKey_2);\n+            testKeyWrap(p, wrapAlg, aes256Key_1, keyAlg, aes256WrappedKey_1);\n+            testKeyWrap(p, wrapAlg, aes256Key_2, keyAlg, aes256WrappedKey_2);\n+        }\n+        System.out.println(\"All Tests Passed\");\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/pkcs11\/Cipher\/KeyWrap\/XMLEncKAT.java","additions":151,"deletions":0,"binary":false,"changes":151,"status":"added"}]}