{"files":[{"patch":"@@ -1463,0 +1463,1 @@\n+  _regions_failed_evacuation(NULL),\n@@ -1755,0 +1756,2 @@\n+  _regions_failed_evacuation = NEW_C_HEAP_ARRAY(volatile bool, max_regions(), mtGC);\n+\n@@ -3472,0 +3475,2 @@\n+  memset((void*)_regions_failed_evacuation, false, sizeof(bool) * max_regions());\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -870,0 +870,2 @@\n+  \/\/ Records for every region on the heap whether evacuation failed for it.\n+  volatile bool* _regions_failed_evacuation;\n@@ -1147,0 +1149,4 @@\n+  \/\/ True iff the given region encountered an evacuation failure in the most-recent\n+  \/\/ collection.\n+  inline bool evacuation_failed(uint region_idx) const;\n+\n@@ -1148,3 +1154,4 @@\n-  \/\/ Notify that the garbage collection encountered an evacuation failure in a\n-  \/\/ region. Should only be called once per region.\n-  inline void notify_region_failed_evacuation();\n+  \/\/ Notify that the garbage collection encountered an evacuation failure in the\n+  \/\/ given region. Returns whether this has been the first occurrence of an evacuation\n+  \/\/ failure in that region.\n+  inline bool notify_region_failed_evacuation(uint const region_idx);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":10,"deletions":3,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -197,0 +197,6 @@\n+bool G1CollectedHeap::evacuation_failed(uint region_idx) const {\n+  assert(region_idx < max_regions(), \"Invalid region index %u\", region_idx);\n+\n+  return Atomic::load(&_regions_failed_evacuation[region_idx]);\n+}\n+\n@@ -201,2 +207,9 @@\n-void G1CollectedHeap::notify_region_failed_evacuation() {\n-  Atomic::inc(&_num_regions_failed_evacuation, memory_order_relaxed);\n+bool G1CollectedHeap::notify_region_failed_evacuation(uint const region_idx) {\n+  assert(region_idx < max_regions(), \"Invalid region index %u\", region_idx);\n+\n+  volatile bool* region_failed_addr = &_regions_failed_evacuation[region_idx];\n+  bool result = !Atomic::load(region_failed_addr) && !Atomic::cmpxchg(region_failed_addr, false, true, memory_order_relaxed);\n+  if (result) {\n+    Atomic::inc(&_num_regions_failed_evacuation, memory_order_relaxed);\n+  }\n+  return result;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.inline.hpp","additions":15,"deletions":2,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -240,1 +240,1 @@\n-    if (hr->evacuation_failed()) {\n+    if (_g1h->evacuation_failed(hr->hrm_index())) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1EvacFailure.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -608,2 +608,1 @@\n-    if (r->set_evacuation_failed()) {\n-      _g1h->notify_region_failed_evacuation();\n+    if (_g1h->notify_region_failed_evacuation(r->hrm_index())) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -268,1 +268,1 @@\n-    \/\/ A region will be freed by free_collection_set if the region is in the\n+    \/\/ A region will be freed by during the FreeCollectionSet phase if the region is in the\n@@ -270,1 +270,1 @@\n-    return _g1h->is_in_cset(hr) && !hr->evacuation_failed();\n+    return _g1h->is_in_cset(hr) && !_g1h->evacuation_failed(hr->hrm_index());\n@@ -382,2 +382,2 @@\n-      size_t used = r->used();\n-      assert(used > 0, \"region %u %s zero used\", r->hrm_index(), r->get_short_type_str());\n+    size_t used = r->used();\n+    assert(used > 0, \"region %u %s zero used\", r->hrm_index(), r->get_short_type_str());\n@@ -434,1 +434,1 @@\n-  void assert_in_cset(HeapRegion* r) {\n+  void assert_tracks_surviving_words(HeapRegion* r) {\n@@ -489,1 +489,0 @@\n-    _g1h->clear_region_attr(r);\n@@ -493,1 +492,1 @@\n-      assert_in_cset(r);\n+      assert_tracks_surviving_words(r);\n@@ -497,1 +496,1 @@\n-    if (r->evacuation_failed()) {\n+    if (_g1h->evacuation_failed(r->hrm_index())) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungGCPostEvacuateTasks.cpp","additions":7,"deletions":8,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -107,1 +107,0 @@\n-  reset_evacuation_failed();\n@@ -121,2 +120,0 @@\n-  assert(!in_collection_set(),\n-         \"Should not clear heap region %u in the collection set\", hrm_index());\n@@ -137,1 +134,0 @@\n-  Atomic::store(&_evacuation_failed, false);\n@@ -245,1 +241,0 @@\n-  _evacuation_failed(false),\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -213,3 +213,0 @@\n-  \/\/ True iff an attempt to evacuate an object in the region failed.\n-  volatile bool _evacuation_failed;\n-\n@@ -501,9 +498,0 @@\n-  \/\/ Returns the \"evacuation_failed\" property of the region.\n-  inline bool evacuation_failed() const;\n-\n-  \/\/ Sets the \"evacuation_failed\" property of the region, returning true if this\n-  \/\/ has been the first call, false otherwise.\n-  inline bool set_evacuation_failed();\n-\n-  inline void reset_evacuation_failed();\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.hpp","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -455,12 +455,0 @@\n-inline bool HeapRegion::evacuation_failed() const {\n-  return Atomic::load(&_evacuation_failed);\n-}\n-\n-inline bool HeapRegion::set_evacuation_failed() {\n-  return !Atomic::load(&_evacuation_failed) && !Atomic::cmpxchg(&_evacuation_failed, false, true, memory_order_relaxed);\n-}\n-\n-inline void HeapRegion::reset_evacuation_failed() {\n-  Atomic::store(&_evacuation_failed, false);\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.inline.hpp","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"}]}