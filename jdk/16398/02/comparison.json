{"files":[{"patch":"@@ -786,0 +786,1 @@\n+  TempNewSymbol::drain_cleanup_delay_queue();\n","filename":"src\/hotspot\/share\/classfile\/symbolTable.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,0 +30,20 @@\n+#include \"utilities\/nonblockingQueue.inline.hpp\"\n+\n+class SymbolBufferQueueNode : public CHeapObj<mtSymbol> {\n+  private:\n+    Symbol* const _val;\n+    SymbolBufferQueueNode* volatile _next;\n+\n+  public:\n+    static SymbolBufferQueueNode* volatile* next(SymbolBufferQueueNode& node) {\n+      return &node._next;\n+    }\n+\n+    SymbolBufferQueueNode(Symbol* val) : _val(val), _next(nullptr) {\n+      _val->increment_refcount();\n+    }\n+\n+    ~SymbolBufferQueueNode() {\n+      _val->decrement_refcount();\n+    }\n+};\n@@ -46,0 +66,4 @@\n+  static NonblockingQueue<SymbolBufferQueueNode, &SymbolBufferQueueNode::next> _cleanup_delay;\n+  static volatile int32_t _cleanup_delay_len;\n+  static const int32_t CLEANUP_DELAY_QUEUE_LEN = 100;\n+\n@@ -56,0 +80,7 @@\n+      return;\n+    }\n+\n+    \/\/ Delay cleanup for temp symbols. But don't requeue existing entries,\n+    \/\/ or entries that are held elsewhere - it's a waste of effort.\n+    if (s != nullptr && s->refcount() == 1) {\n+      add_to_cleanup_delay_queue(s);\n@@ -79,0 +110,19 @@\n+  \/\/ Keep this symbol alive for some time to allow for reuse.\n+  \/\/ Temp symbols for the same string can often be created in quick succession,\n+  \/\/ and this queue allows them to be reused instead of churning.\n+  void add_to_cleanup_delay_queue(Symbol* sym) {\n+    if (sym == nullptr) return;\n+\n+    SymbolBufferQueueNode* node = new SymbolBufferQueueNode(sym);\n+    _cleanup_delay.push(*node);\n+\n+    \/\/ If the queue is now full, implement a one-in, one-out policy.\n+    if (Atomic::add(&_cleanup_delay_len, 1, memory_order_relaxed) >= CLEANUP_DELAY_QUEUE_LEN) {\n+      SymbolBufferQueueNode* result = _cleanup_delay.pop();\n+      if (result != nullptr) {\n+        delete result;\n+        Atomic::dec(&_cleanup_delay_len);\n+      }\n+    }\n+  }\n+\n@@ -87,0 +137,8 @@\n+\n+  static void drain_cleanup_delay_queue() {\n+    SymbolBufferQueueNode* curr;\n+    while ((curr = _cleanup_delay.pop()) != nullptr) {\n+      delete curr;\n+      Atomic::dec(&_cleanup_delay_len);\n+    }\n+  }\n@@ -89,0 +147,5 @@\n+template<bool TEMP>\n+NonblockingQueue<SymbolBufferQueueNode, &SymbolBufferQueueNode::next> SymbolHandleBase<TEMP>::_cleanup_delay;\n+template<bool TEMP>\n+volatile int32_t SymbolHandleBase<TEMP>::_cleanup_delay_len = 0;\n+\n","filename":"src\/hotspot\/share\/oops\/symbolHandle.hpp","additions":63,"deletions":0,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -86,1 +86,1 @@\n-  inline ~NonblockingQueue() NOT_DEBUG(= default);\n+  inline ~NonblockingQueue() = default;\n","filename":"src\/hotspot\/share\/utilities\/nonblockingQueue.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -45,8 +45,0 @@\n-#ifdef ASSERT\n-template<typename T, T* volatile* (*next_ptr)(T&)>\n-NonblockingQueue<T, next_ptr>::~NonblockingQueue() {\n-  assert(_head == nullptr, \"precondition\");\n-  assert(_tail == nullptr, \"precondition\");\n-}\n-#endif\n-\n","filename":"src\/hotspot\/share\/utilities\/nonblockingQueue.inline.hpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -42,2 +42,2 @@\n-  TempNewSymbol A = SymbolTable::new_symbol(\"abc2_8_2023_class\");\n-  TempNewSymbol D = SymbolTable::new_symbol(\"def2_8_2023_class\");\n+  Symbol* A = SymbolTable::new_symbol(\"abc2_8_2023_class\");\n+  Symbol* D = SymbolTable::new_symbol(\"def2_8_2023_class\");\n@@ -45,1 +45,1 @@\n-  TempNewSymbol interf = SymbolTable::new_symbol(\"interface2_8_2023_supername\");\n+  Symbol* interf = SymbolTable::new_symbol(\"interface2_8_2023_supername\");\n","filename":"test\/hotspot\/gtest\/classfile\/test_placeholders.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -40,1 +40,2 @@\n-  ASSERT_EQ(ss->refcount(), abccount) << \"only one abc\";\n+  \/\/ TODO: properly account for Symbol cleanup delay queue\n+  ASSERT_EQ(ss->refcount(), abccount + 1) << \"only one abc\";\n@@ -50,2 +51,2 @@\n-  ASSERT_EQ(s1->refcount(), efgcount) << \"one efg\";\n-  ASSERT_EQ(s2->refcount(), hijcount) << \"one hij\";\n+  ASSERT_EQ(s1->refcount(), efgcount + 1) << \"one efg\";\n+  ASSERT_EQ(s2->refcount(), hijcount + 1) << \"one hij\";\n@@ -55,2 +56,2 @@\n-  ASSERT_EQ(hij->refcount(), hijcount + 1) << \"should be two hij\";\n-  ASSERT_EQ(efg->refcount(), efgcount - 1) << \"should be no efg\";\n+  ASSERT_EQ(hij->refcount(), hijcount + 2) << \"should be two hij\";\n+  ASSERT_EQ(efg->refcount(), efgcount) << \"should be no efg\";\n@@ -59,2 +60,2 @@\n-  ASSERT_EQ(s1->refcount(), abccount + 1) << \"should be two abc (s1 and ss)\";\n-  ASSERT_EQ(hij->refcount(), hijcount) << \"should only have one hij now (s2)\";\n+  ASSERT_EQ(s1->refcount(), abccount + 2) << \"should be two abc (s1 and ss)\";\n+  ASSERT_EQ(hij->refcount(), hijcount + 1) << \"should only have one hij now (s2)\";\n@@ -63,1 +64,1 @@\n-  ASSERT_EQ(s1->refcount(), abccount + 1) << \"should still be two abc (s1 and ss)\";\n+  ASSERT_EQ(s1->refcount(), abccount + 2) << \"should still be two abc (s1 and ss)\";\n@@ -69,1 +70,1 @@\n-  ASSERT_EQ(s3->refcount(), klmcount) << \"only one klm now\";\n+  ASSERT_EQ(s3->refcount(), klmcount + 1) << \"only one klm now\";\n@@ -76,1 +77,1 @@\n-  ASSERT_EQ(xyz->refcount(), xyzcount - 1)\n+  ASSERT_EQ(xyz->refcount(), xyzcount)\n","filename":"test\/hotspot\/gtest\/classfile\/test_symbolTable.cpp","additions":11,"deletions":10,"binary":false,"changes":21,"status":"modified"}]}