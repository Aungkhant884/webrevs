{"files":[{"patch":"@@ -32,9 +32,4 @@\n-class SymbolBufferQueueNode : public CHeapObj<mtSymbol> {\n-  private:\n-    Symbol* const _val;\n-    SymbolBufferQueueNode* volatile _next;\n-\n-  public:\n-    static SymbolBufferQueueNode* volatile* next(SymbolBufferQueueNode& node) {\n-      return &node._next;\n-    }\n+class TempSymbolDelayQueueNode : public CHeapObj<mtSymbol> {\n+private:\n+  Symbol* const _val;\n+  TempSymbolDelayQueueNode* volatile _next;\n@@ -42,3 +37,4 @@\n-    SymbolBufferQueueNode(Symbol* val) : _val(val), _next(nullptr) {\n-      _val->increment_refcount();\n-    }\n+public:\n+  static TempSymbolDelayQueueNode* volatile* next(TempSymbolDelayQueueNode& node) {\n+    return &node._next;\n+  }\n@@ -46,3 +42,7 @@\n-    ~SymbolBufferQueueNode() {\n-      _val->decrement_refcount();\n-    }\n+  TempSymbolDelayQueueNode(Symbol* val) : _val(val), _next(nullptr) {\n+    _val->increment_refcount();\n+  }\n+\n+  ~TempSymbolDelayQueueNode() {\n+    _val->decrement_refcount();\n+  }\n@@ -51,0 +51,2 @@\n+typedef NonblockingQueue<TempSymbolDelayQueueNode, &TempSymbolDelayQueueNode::next> TempSymbolDelayQueue;\n+\n@@ -66,1 +68,1 @@\n-  static NonblockingQueue<SymbolBufferQueueNode, &SymbolBufferQueueNode::next> _cleanup_delay;\n+  static TempSymbolDelayQueue _cleanup_delay;\n@@ -68,1 +70,1 @@\n-  static const int32_t CLEANUP_DELAY_QUEUE_LEN = 100;\n+  static volatile int32_t _cleanup_delay_max_entries;\n@@ -83,2 +85,3 @@\n-    \/\/ Delay cleanup for temp symbols. But don't requeue existing entries,\n-    \/\/ or entries that are held elsewhere - it's a waste of effort.\n+    \/\/ Delay cleanup for temp symbols. Refcount is incremented while in\n+    \/\/ queue. But don't requeue existing entries, or entries that are held\n+    \/\/ elsewhere - it's a waste of effort.\n@@ -114,3 +117,1 @@\n-    if (sym == nullptr) return;\n-\n-    SymbolBufferQueueNode* node = new SymbolBufferQueueNode(sym);\n+    TempSymbolDelayQueueNode* node = new TempSymbolDelayQueueNode(sym);\n@@ -120,2 +121,2 @@\n-    if (Atomic::add(&_cleanup_delay_len, 1, memory_order_relaxed) >= CLEANUP_DELAY_QUEUE_LEN) {\n-      SymbolBufferQueueNode* result = _cleanup_delay.pop();\n+    if (Atomic::add(&_cleanup_delay_len, 1, memory_order_relaxed) > _cleanup_delay_max_entries) {\n+      TempSymbolDelayQueueNode* result = _cleanup_delay.pop();\n@@ -139,1 +140,1 @@\n-    SymbolBufferQueueNode* curr;\n+    TempSymbolDelayQueueNode* curr;\n@@ -145,0 +146,6 @@\n+\n+  \/\/ Useful for testing.\n+  static void set_cleanup_delay_max_entries(int32_t val) {\n+    _cleanup_delay_max_entries = val;\n+    drain_cleanup_delay_queue();\n+  }\n@@ -148,1 +155,1 @@\n-NonblockingQueue<SymbolBufferQueueNode, &SymbolBufferQueueNode::next> SymbolHandleBase<TEMP>::_cleanup_delay;\n+TempSymbolDelayQueue SymbolHandleBase<TEMP>::_cleanup_delay;\n@@ -151,0 +158,2 @@\n+template<bool TEMP>\n+volatile int32_t SymbolHandleBase<TEMP>::_cleanup_delay_max_entries = 100;\n","filename":"src\/hotspot\/share\/oops\/symbolHandle.hpp","additions":35,"deletions":26,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -36,0 +36,2 @@\n+  \/\/ Disable the temp symbol cleanup delay queue because it increases refcounts.\n+  TempNewSymbol::set_cleanup_delay_max_entries(0);\n@@ -40,2 +42,1 @@\n-  \/\/ TODO: properly account for Symbol cleanup delay queue\n-  ASSERT_EQ(ss->refcount(), abccount + 1) << \"only one abc\";\n+  ASSERT_EQ(ss->refcount(), abccount) << \"only one abc\";\n@@ -51,2 +52,2 @@\n-  ASSERT_EQ(s1->refcount(), efgcount + 1) << \"one efg\";\n-  ASSERT_EQ(s2->refcount(), hijcount + 1) << \"one hij\";\n+  ASSERT_EQ(s1->refcount(), efgcount) << \"one efg\";\n+  ASSERT_EQ(s2->refcount(), hijcount) << \"one hij\";\n@@ -56,2 +57,2 @@\n-  ASSERT_EQ(hij->refcount(), hijcount + 2) << \"should be two hij\";\n-  ASSERT_EQ(efg->refcount(), efgcount) << \"should be no efg\";\n+  ASSERT_EQ(hij->refcount(), hijcount + 1) << \"should be two hij\";\n+  ASSERT_EQ(efg->refcount(), efgcount - 1) << \"should be no efg\";\n@@ -60,2 +61,2 @@\n-  ASSERT_EQ(s1->refcount(), abccount + 2) << \"should be two abc (s1 and ss)\";\n-  ASSERT_EQ(hij->refcount(), hijcount + 1) << \"should only have one hij now (s2)\";\n+  ASSERT_EQ(s1->refcount(), abccount + 1) << \"should be two abc (s1 and ss)\";\n+  ASSERT_EQ(hij->refcount(), hijcount) << \"should only have one hij now (s2)\";\n@@ -64,1 +65,1 @@\n-  ASSERT_EQ(s1->refcount(), abccount + 2) << \"should still be two abc (s1 and ss)\";\n+  ASSERT_EQ(s1->refcount(), abccount + 1) << \"should still be two abc (s1 and ss)\";\n@@ -70,1 +71,1 @@\n-  ASSERT_EQ(s3->refcount(), klmcount + 1) << \"only one klm now\";\n+  ASSERT_EQ(s3->refcount(), klmcount) << \"only one klm now\";\n@@ -77,1 +78,1 @@\n-  ASSERT_EQ(xyz->refcount(), xyzcount)\n+  ASSERT_EQ(xyz->refcount(), xyzcount - 1)\n@@ -143,0 +144,21 @@\n+\n+TEST_VM(SymbolTable, test_cleanup_delay) {\n+  \/\/ Check that new temp symbols have an extra refcount increment, which is then\n+  \/\/ decremented when the queue spills over.\n+\n+  \/\/ Fill up the queue\n+  TempNewSymbol::set_cleanup_delay_max_entries(3);\n+  TempNewSymbol s1 = SymbolTable::new_symbol(\"temp-s1\");\n+  ASSERT_EQ(s1->refcount(), 2) << \"TempNewSymbol refcount just created is 2\";\n+  TempNewSymbol s2 = SymbolTable::new_symbol(\"temp-s2\");\n+  ASSERT_EQ(s2->refcount(), 2) << \"TempNewSymbol refcount just created is 2\";\n+  TempNewSymbol s3 = SymbolTable::new_symbol(\"temp-s3\");\n+  ASSERT_EQ(s3->refcount(), 2) << \"TempNewSymbol refcount just created is 2\";\n+\n+  \/\/ Add one more\n+  TempNewSymbol s4 = SymbolTable::new_symbol(\"temp-s4-spillover\");\n+  ASSERT_EQ(s4->refcount(), 2) << \"TempNewSymbol refcount just created is 2\";\n+\n+  \/\/ The first symbol should have been removed from the queue and decremented\n+  ASSERT_EQ(s1->refcount(), 1) << \"TempNewSymbol off queue refcount is 1\";\n+}\n","filename":"test\/hotspot\/gtest\/classfile\/test_symbolTable.cpp","additions":33,"deletions":11,"binary":false,"changes":44,"status":"modified"}]}