{"files":[{"patch":"@@ -786,0 +786,1 @@\n+  TempNewSymbol::drain_cleanup_delay_queue();\n","filename":"src\/hotspot\/share\/classfile\/symbolTable.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,0 +30,20 @@\n+#include \"utilities\/nonblockingQueue.inline.hpp\"\n+\n+class SymbolBufferQueueNode : public CHeapObj<mtSymbol> {\n+  private:\n+    Symbol* const _val;\n+    SymbolBufferQueueNode* volatile _next;\n+\n+  public:\n+    static SymbolBufferQueueNode* volatile* next(SymbolBufferQueueNode& node) {\n+      return &node._next;\n+    }\n+\n+    SymbolBufferQueueNode(Symbol* val) : _val(val), _next(nullptr) {\n+      _val->increment_refcount();\n+    }\n+\n+    ~SymbolBufferQueueNode() {\n+      _val->decrement_refcount();\n+    }\n+};\n@@ -46,0 +66,4 @@\n+  static NonblockingQueue<SymbolBufferQueueNode, &SymbolBufferQueueNode::next> _cleanup_delay;\n+  static volatile int32_t _cleanup_delay_len;\n+  static const int32_t CLEANUP_DELAY_QUEUE_LEN = 100;\n+\n@@ -56,0 +80,7 @@\n+      return;\n+    }\n+\n+    \/\/ Delay cleanup for temp symbols. But don't requeue existing entries,\n+    \/\/ or entries that are held elsewhere - it's a waste of effort.\n+    if (s != nullptr && s->refcount() == 1) {\n+      add_to_cleanup_delay_queue(s);\n@@ -79,0 +110,19 @@\n+  \/\/ Keep this symbol alive for some time to allow for reuse.\n+  \/\/ Temp symbols for the same string can often be created in quick succession,\n+  \/\/ and this queue allows them to be reused instead of churning.\n+  void add_to_cleanup_delay_queue(Symbol* sym) {\n+    if (sym == nullptr) return;\n+\n+    SymbolBufferQueueNode* node = new SymbolBufferQueueNode(sym);\n+    _cleanup_delay.push(*node);\n+\n+    \/\/ If the queue is now full, implement a one-in, one-out policy.\n+    if (Atomic::add(&_cleanup_delay_len, 1, memory_order_relaxed) >= CLEANUP_DELAY_QUEUE_LEN) {\n+      SymbolBufferQueueNode* result = _cleanup_delay.pop();\n+      if (result != nullptr) {\n+        delete result;\n+        Atomic::dec(&_cleanup_delay_len);\n+      }\n+    }\n+  }\n+\n@@ -87,0 +137,8 @@\n+\n+  static void drain_cleanup_delay_queue() {\n+    SymbolBufferQueueNode* curr;\n+    while ((curr = _cleanup_delay.pop()) != nullptr) {\n+      delete curr;\n+      Atomic::dec(&_cleanup_delay_len);\n+    }\n+  }\n@@ -89,0 +147,5 @@\n+template<bool TEMP>\n+NonblockingQueue<SymbolBufferQueueNode, &SymbolBufferQueueNode::next> SymbolHandleBase<TEMP>::_cleanup_delay;\n+template<bool TEMP>\n+volatile int32_t SymbolHandleBase<TEMP>::_cleanup_delay_len = 0;\n+\n","filename":"src\/hotspot\/share\/oops\/symbolHandle.hpp","additions":63,"deletions":0,"binary":false,"changes":63,"status":"modified"}]}