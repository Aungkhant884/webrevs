{"files":[{"patch":"@@ -786,0 +786,1 @@\n+  TempNewSymbol::drain_cleanup_delay_queue();\n","filename":"src\/hotspot\/share\/classfile\/symbolTable.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,0 +30,22 @@\n+#include \"utilities\/nonblockingQueue.inline.hpp\"\n+\n+class TempSymbolDelayQueueNode : public CHeapObj<mtSymbol> {\n+private:\n+  Symbol* const _val;\n+  TempSymbolDelayQueueNode* volatile _next;\n+\n+public:\n+  static TempSymbolDelayQueueNode* volatile* next(TempSymbolDelayQueueNode& node) {\n+    return &node._next;\n+  }\n+\n+  TempSymbolDelayQueueNode(Symbol* val) : _val(val), _next(nullptr) {\n+    _val->increment_refcount();\n+  }\n+\n+  ~TempSymbolDelayQueueNode() {\n+    _val->decrement_refcount();\n+  }\n+};\n+\n+typedef NonblockingQueue<TempSymbolDelayQueueNode, &TempSymbolDelayQueueNode::next> TempSymbolDelayQueue;\n@@ -46,0 +68,4 @@\n+  static TempSymbolDelayQueue _cleanup_delay;\n+  static volatile int32_t _cleanup_delay_len;\n+  static volatile int32_t _cleanup_delay_max_entries;\n+\n@@ -56,0 +82,8 @@\n+      return;\n+    }\n+\n+    \/\/ Delay cleanup for temp symbols. Refcount is incremented while in\n+    \/\/ queue. But don't requeue existing entries, or entries that are held\n+    \/\/ elsewhere - it's a waste of effort.\n+    if (s != nullptr && s->refcount() == 1) {\n+      add_to_cleanup_delay_queue(s);\n@@ -79,0 +113,17 @@\n+  \/\/ Keep this symbol alive for some time to allow for reuse.\n+  \/\/ Temp symbols for the same string can often be created in quick succession,\n+  \/\/ and this queue allows them to be reused instead of churning.\n+  void add_to_cleanup_delay_queue(Symbol* sym) {\n+    TempSymbolDelayQueueNode* node = new TempSymbolDelayQueueNode(sym);\n+    _cleanup_delay.push(*node);\n+\n+    \/\/ If the queue is now full, implement a one-in, one-out policy.\n+    if (Atomic::add(&_cleanup_delay_len, 1, memory_order_relaxed) > _cleanup_delay_max_entries) {\n+      TempSymbolDelayQueueNode* result = _cleanup_delay.pop();\n+      if (result != nullptr) {\n+        delete result;\n+        Atomic::dec(&_cleanup_delay_len);\n+      }\n+    }\n+  }\n+\n@@ -87,0 +138,14 @@\n+\n+  static void drain_cleanup_delay_queue() {\n+    TempSymbolDelayQueueNode* curr;\n+    while ((curr = _cleanup_delay.pop()) != nullptr) {\n+      delete curr;\n+      Atomic::dec(&_cleanup_delay_len);\n+    }\n+  }\n+\n+  \/\/ Useful for testing.\n+  static void set_cleanup_delay_max_entries(int32_t val) {\n+    _cleanup_delay_max_entries = val;\n+    drain_cleanup_delay_queue();\n+  }\n@@ -89,0 +154,7 @@\n+template<bool TEMP>\n+TempSymbolDelayQueue SymbolHandleBase<TEMP>::_cleanup_delay;\n+template<bool TEMP>\n+volatile int32_t SymbolHandleBase<TEMP>::_cleanup_delay_len = 0;\n+template<bool TEMP>\n+volatile int32_t SymbolHandleBase<TEMP>::_cleanup_delay_max_entries = 100;\n+\n","filename":"src\/hotspot\/share\/oops\/symbolHandle.hpp","additions":72,"deletions":0,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -86,1 +86,1 @@\n-  inline ~NonblockingQueue() NOT_DEBUG(= default);\n+  inline ~NonblockingQueue() = default;\n","filename":"src\/hotspot\/share\/utilities\/nonblockingQueue.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -45,8 +45,0 @@\n-#ifdef ASSERT\n-template<typename T, T* volatile* (*next_ptr)(T&)>\n-NonblockingQueue<T, next_ptr>::~NonblockingQueue() {\n-  assert(_head == nullptr, \"precondition\");\n-  assert(_tail == nullptr, \"precondition\");\n-}\n-#endif\n-\n","filename":"src\/hotspot\/share\/utilities\/nonblockingQueue.inline.hpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -42,2 +42,2 @@\n-  TempNewSymbol A = SymbolTable::new_symbol(\"abc2_8_2023_class\");\n-  TempNewSymbol D = SymbolTable::new_symbol(\"def2_8_2023_class\");\n+  Symbol* A = SymbolTable::new_symbol(\"abc2_8_2023_class\");\n+  Symbol* D = SymbolTable::new_symbol(\"def2_8_2023_class\");\n@@ -45,1 +45,1 @@\n-  TempNewSymbol interf = SymbolTable::new_symbol(\"interface2_8_2023_supername\");\n+  Symbol* interf = SymbolTable::new_symbol(\"interface2_8_2023_supername\");\n","filename":"test\/hotspot\/gtest\/classfile\/test_placeholders.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -36,0 +36,2 @@\n+  \/\/ Disable the temp symbol cleanup delay queue because it increases refcounts.\n+  TempNewSymbol::set_cleanup_delay_max_entries(0);\n@@ -142,0 +144,21 @@\n+\n+TEST_VM(SymbolTable, test_cleanup_delay) {\n+  \/\/ Check that new temp symbols have an extra refcount increment, which is then\n+  \/\/ decremented when the queue spills over.\n+\n+  \/\/ Fill up the queue\n+  TempNewSymbol::set_cleanup_delay_max_entries(3);\n+  TempNewSymbol s1 = SymbolTable::new_symbol(\"temp-s1\");\n+  ASSERT_EQ(s1->refcount(), 2) << \"TempNewSymbol refcount just created is 2\";\n+  TempNewSymbol s2 = SymbolTable::new_symbol(\"temp-s2\");\n+  ASSERT_EQ(s2->refcount(), 2) << \"TempNewSymbol refcount just created is 2\";\n+  TempNewSymbol s3 = SymbolTable::new_symbol(\"temp-s3\");\n+  ASSERT_EQ(s3->refcount(), 2) << \"TempNewSymbol refcount just created is 2\";\n+\n+  \/\/ Add one more\n+  TempNewSymbol s4 = SymbolTable::new_symbol(\"temp-s4-spillover\");\n+  ASSERT_EQ(s4->refcount(), 2) << \"TempNewSymbol refcount just created is 2\";\n+\n+  \/\/ The first symbol should have been removed from the queue and decremented\n+  ASSERT_EQ(s1->refcount(), 1) << \"TempNewSymbol off queue refcount is 1\";\n+}\n","filename":"test\/hotspot\/gtest\/classfile\/test_symbolTable.cpp","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"}]}