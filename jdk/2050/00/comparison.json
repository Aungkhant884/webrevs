{"files":[{"patch":"@@ -135,1 +135,0 @@\n-  TRACE_CALL(result_type, jvmci_ ## name signature)  \\\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -90,1 +90,0 @@\n-#include \"utilities\/histogram.hpp\"\n@@ -264,43 +263,0 @@\n-\/\/ Wrapper to trace JNI functions\n-\n-#ifdef ASSERT\n-  Histogram* JNIHistogram;\n-  static volatile int JNIHistogram_lock = 0;\n-\n-  class JNIHistogramElement : public HistogramElement {\n-    public:\n-     JNIHistogramElement(const char* name);\n-  };\n-\n-  JNIHistogramElement::JNIHistogramElement(const char* elementName) {\n-    _name = elementName;\n-    uintx count = 0;\n-\n-    while (Atomic::cmpxchg(&JNIHistogram_lock, 0, 1) != 0) {\n-      while (Atomic::load_acquire(&JNIHistogram_lock) != 0) {\n-        count +=1;\n-        if ( (WarnOnStalledSpinLock > 0)\n-          && (count % WarnOnStalledSpinLock == 0)) {\n-          warning(\"JNIHistogram_lock seems to be stalled\");\n-        }\n-      }\n-     }\n-\n-\n-    if(JNIHistogram == NULL)\n-      JNIHistogram = new Histogram(\"JNI Call Counts\",100);\n-\n-    JNIHistogram->add_element(this);\n-    Atomic::dec(&JNIHistogram_lock);\n-  }\n-\n-  #define JNICountWrapper(arg)                                     \\\n-     static JNIHistogramElement* e = new JNIHistogramElement(arg); \\\n-      \/* There is a MT-race condition in VC++. So we need to make sure that that e has been initialized *\/ \\\n-     if (e != NULL) e->increment_count()\n-  #define JNIWrapper(arg) JNICountWrapper(arg);\n-#else\n-  #define JNIWrapper(arg)\n-#endif\n-\n-\n@@ -314,2 +270,0 @@\n-  JNIWrapper(\"DefineClass\");\n-\n@@ -360,2 +314,0 @@\n-  JNIWrapper(\"FindClass\");\n-\n@@ -416,2 +368,0 @@\n-  JNIWrapper(\"FromReflectedMethod\");\n-\n@@ -449,2 +399,0 @@\n-  JNIWrapper(\"FromReflectedField\");\n-\n@@ -491,2 +439,0 @@\n-  JNIWrapper(\"ToReflectedMethod\");\n-\n@@ -514,2 +460,0 @@\n-  JNIWrapper(\"GetSuperclass\");\n-\n@@ -545,2 +489,0 @@\n-  JNIWrapper(\"IsSubclassOf\");\n-\n@@ -573,2 +515,0 @@\n-  JNIWrapper(\"Throw\");\n-\n@@ -590,2 +530,0 @@\n-  JNIWrapper(\"ThrowNew\");\n-\n@@ -622,2 +560,0 @@\n-  JNIWrapper(\"ExceptionOccurred\");\n-\n@@ -636,2 +572,0 @@\n-  JNIWrapper(\"ExceptionDescribe\");\n-\n@@ -680,2 +614,0 @@\n-  JNIWrapper(\"ExceptionClear\");\n-\n@@ -697,2 +629,0 @@\n-  JNIWrapper(\"FatalError\");\n-\n@@ -708,2 +638,0 @@\n-  JNIWrapper(\"PushLocalFrame\");\n-\n@@ -730,2 +658,0 @@\n-  JNIWrapper(\"PopLocalFrame\");\n-\n@@ -754,2 +680,0 @@\n-  JNIWrapper(\"NewGlobalRef\");\n-\n@@ -767,2 +691,0 @@\n-  JNIWrapper(\"DeleteGlobalRef\");\n-\n@@ -777,2 +699,0 @@\n-  JNIWrapper(\"DeleteLocalRef\");\n-\n@@ -787,2 +707,0 @@\n-  JNIWrapper(\"IsSameObject\");\n-\n@@ -799,2 +717,0 @@\n-  JNIWrapper(\"NewLocalRef\");\n-\n@@ -811,2 +727,0 @@\n-  JNIWrapper(\"EnsureLocalCapacity\");\n-\n@@ -829,2 +743,0 @@\n-  JNIWrapper(\"GetObjectRefType\");\n-\n@@ -1055,2 +967,0 @@\n-  JNIWrapper(\"AllocObject\");\n-\n@@ -1071,2 +981,0 @@\n-  JNIWrapper(\"NewObjectA\");\n-\n@@ -1091,2 +999,0 @@\n-  JNIWrapper(\"NewObjectV\");\n-\n@@ -1111,2 +1017,0 @@\n-  JNIWrapper(\"NewObject\");\n-\n@@ -1131,2 +1035,0 @@\n-  JNIWrapper(\"GetObjectClass\");\n-\n@@ -1144,2 +1046,0 @@\n-  JNIWrapper(\"IsInstanceOf\");\n-\n@@ -1219,1 +1119,0 @@\n-  JNIWrapper(\"GetMethodID\");\n@@ -1229,1 +1128,0 @@\n-  JNIWrapper(\"GetStaticMethodID\");\n@@ -1251,1 +1149,0 @@\n-  JNIWrapper(\"Call\" XSTR(Result) \"Method\"); \\\n@@ -1307,1 +1204,0 @@\n-  JNIWrapper(\"Call\" XSTR(Result) \"MethodV\"); \\\n@@ -1360,1 +1256,0 @@\n-  JNIWrapper(\"Call\" XSTR(Result) \"MethodA\"); \\\n@@ -1410,1 +1305,0 @@\n-  JNIWrapper(\"CallVoidMethod\");\n@@ -1424,1 +1318,0 @@\n-  JNIWrapper(\"CallVoidMethodV\");\n@@ -1435,1 +1328,0 @@\n-  JNIWrapper(\"CallVoidMethodA\");\n@@ -1454,1 +1346,0 @@\n-  JNIWrapper(\"CallNonvitual\" XSTR(Result) \"Method\"); \\\n@@ -1510,1 +1401,0 @@\n-  JNIWrapper(\"CallNonvitual\" XSTR(Result) \"MethodV\"); \\\n@@ -1563,1 +1453,0 @@\n-  JNIWrapper(\"CallNonvitual\" XSTR(Result) \"MethodA\"); \\\n@@ -1616,2 +1505,0 @@\n-  JNIWrapper(\"CallNonvirtualVoidMethod\");\n-\n@@ -1631,2 +1518,0 @@\n-  JNIWrapper(\"CallNonvirtualVoidMethodV\");\n-\n@@ -1644,1 +1529,0 @@\n-  JNIWrapper(\"CallNonvirtualVoidMethodA\");\n@@ -1663,1 +1547,0 @@\n-  JNIWrapper(\"CallStatic\" XSTR(Result) \"Method\"); \\\n@@ -1719,1 +1602,0 @@\n-  JNIWrapper(\"CallStatic\" XSTR(Result) \"MethodV\"); \\\n@@ -1776,1 +1658,0 @@\n-  JNIWrapper(\"CallStatic\" XSTR(Result) \"MethodA\"); \\\n@@ -1829,1 +1710,0 @@\n-  JNIWrapper(\"CallStaticVoidMethod\");\n@@ -1843,1 +1723,0 @@\n-  JNIWrapper(\"CallStaticVoidMethodV\");\n@@ -1854,1 +1733,0 @@\n-  JNIWrapper(\"CallStaticVoidMethodA\");\n@@ -1874,1 +1752,0 @@\n-  JNIWrapper(\"GetFieldID\");\n@@ -1909,1 +1786,0 @@\n-  JNIWrapper(\"GetObjectField\");\n@@ -1934,1 +1810,0 @@\n-  JNIWrapper(\"Get\" XSTR(Result) \"Field\"); \\\n@@ -2003,1 +1878,0 @@\n-  JNIWrapper(\"SetObjectField\");\n@@ -2023,1 +1897,0 @@\n-  JNIWrapper(\"Set\" XSTR(Result) \"Field\"); \\\n@@ -2071,1 +1944,0 @@\n-  JNIWrapper(\"ToReflectedField\");\n@@ -2107,1 +1979,0 @@\n-  JNIWrapper(\"GetStaticFieldID\");\n@@ -2142,1 +2013,0 @@\n-  JNIWrapper(\"GetStaticObjectField\");\n@@ -2167,1 +2037,0 @@\n-  JNIWrapper(\"GetStatic\" XSTR(Result) \"Field\"); \\\n@@ -2202,1 +2071,0 @@\n-  JNIWrapper(\"SetStaticObjectField\");\n@@ -2223,1 +2091,0 @@\n-  JNIWrapper(\"SetStatic\" XSTR(Result) \"Field\"); \\\n@@ -2276,1 +2143,0 @@\n-  JNIWrapper(\"NewString\");\n@@ -2287,1 +2153,0 @@\n-  JNIWrapper(\"GetStringLength\");\n@@ -2299,1 +2164,0 @@\n-  JNIWrapper(\"GetStringChars\");\n@@ -2333,1 +2197,0 @@\n-  JNIWrapper(\"ReleaseStringChars\");\n@@ -2351,1 +2214,0 @@\n-  JNIWrapper(\"NewStringUTF\");\n@@ -2363,1 +2225,0 @@\n-  JNIWrapper(\"GetStringUTFLength\");\n@@ -2373,1 +2234,0 @@\n-  JNIWrapper(\"GetStringUTFChars\");\n@@ -2395,1 +2255,0 @@\n-  JNIWrapper(\"ReleaseStringUTFChars\");\n@@ -2405,1 +2264,0 @@\n-  JNIWrapper(\"GetArrayLength\");\n@@ -2423,1 +2281,0 @@\n-  JNIWrapper(\"NewObjectArray\");\n@@ -2445,1 +2302,0 @@\n-  JNIWrapper(\"GetObjectArrayElement\");\n@@ -2465,1 +2321,0 @@\n-  JNIWrapper(\"SetObjectArrayElement\");\n@@ -2505,1 +2360,0 @@\n-  JNIWrapper(\"New\" XSTR(Result) \"Array\"); \\\n@@ -2563,1 +2417,0 @@\n-  JNIWrapper(\"Get\" XSTR(Result) \"ArrayElements\"); \\\n@@ -2626,1 +2479,0 @@\n-  JNIWrapper(\"Release\" XSTR(Result) \"ArrayElements\"); \\\n@@ -2688,1 +2540,0 @@\n-  JNIWrapper(\"Get\" XSTR(Result) \"ArrayRegion\"); \\\n@@ -2732,1 +2583,0 @@\n-  JNIWrapper(\"Set\" XSTR(Result) \"ArrayRegion\"); \\\n@@ -2774,1 +2624,0 @@\n-  JNIWrapper(\"RegisterNatives\");\n@@ -2841,1 +2690,0 @@\n-  JNIWrapper(\"UnregisterNatives\");\n@@ -2909,1 +2757,0 @@\n-  JNIWrapper(\"GetStringRegion\");\n@@ -2936,1 +2783,0 @@\n-  JNIWrapper(\"GetStringUTFRegion\");\n@@ -2979,1 +2825,0 @@\n-  JNIWrapper(\"GetPrimitiveArrayCritical\");\n@@ -2999,1 +2844,0 @@\n-  JNIWrapper(\"ReleasePrimitiveArrayCritical\");\n@@ -3007,1 +2851,0 @@\n-  JNIWrapper(\"GetStringCritical\");\n@@ -3036,1 +2879,0 @@\n-  JNIWrapper(\"ReleaseStringCritical\");\n@@ -3052,1 +2894,0 @@\n-  JNIWrapper(\"jni_NewWeakGlobalRef\");\n@@ -3065,1 +2906,0 @@\n-  JNIWrapper(\"jni_DeleteWeakGlobalRef\");\n@@ -3073,1 +2913,0 @@\n-  JNIWrapper(\"jni_ExceptionCheck\");\n@@ -3183,1 +3022,0 @@\n-  JNIWrapper(\"jni_NewDirectByteBuffer\");\n@@ -3211,1 +3049,0 @@\n-  JNIWrapper(\"jni_GetDirectBufferAddress\");\n@@ -3238,1 +3075,0 @@\n-  JNIWrapper(\"jni_GetDirectBufferCapacity\");\n@@ -3265,1 +3101,0 @@\n-  JNIWrapper(\"GetVersion\");\n@@ -3274,1 +3109,0 @@\n-  JNIWrapper(\"jni_GetJavaVM\");\n@@ -3283,1 +3117,0 @@\n-  JNIWrapper(\"GetModule\");\n@@ -3592,1 +3425,1 @@\n-  if (UseFastJNIAccessors && !VerifyJNIFields && !CountJNICalls && !CheckJNICalls) {\n+  if (UseFastJNIAccessors && !VerifyJNIFields && !CheckJNICalls) {\n@@ -3861,3 +3694,0 @@\n-  \/\/ See bug 4367188, the wrapper can sometimes cause VM crashes\n-  \/\/ JNIWrapper(\"GetCreatedJavaVMs\");\n-\n@@ -3891,1 +3721,0 @@\n-  JNIWrapper(\"DestroyJavaVM\");\n@@ -4053,1 +3882,0 @@\n-  JNIWrapper(\"AttachCurrentThread\");\n@@ -4067,2 +3895,0 @@\n-  JNIWrapper(\"DetachCurrentThread\");\n-\n@@ -4176,1 +4002,0 @@\n-  JNIWrapper(\"AttachCurrentThreadAsDaemon\");\n","filename":"src\/hotspot\/share\/prims\/jni.cpp","additions":1,"deletions":176,"binary":false,"changes":177,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -97,1 +97,0 @@\n-#include \"utilities\/histogram.hpp\"\n@@ -117,2 +116,0 @@\n-          JVMWrapper(\"JVM_GetClassDeclaredFields\");\n-\n@@ -232,41 +229,0 @@\n-\/\/ Wrapper to trace JVM functions\n-\n-#ifdef ASSERT\n-  Histogram* JVMHistogram;\n-  volatile int JVMHistogram_lock = 0;\n-\n-  class JVMHistogramElement : public HistogramElement {\n-    public:\n-     JVMHistogramElement(const char* name);\n-  };\n-\n-  JVMHistogramElement::JVMHistogramElement(const char* elementName) {\n-    _name = elementName;\n-    uintx count = 0;\n-\n-    while (Atomic::cmpxchg(&JVMHistogram_lock, 0, 1) != 0) {\n-      while (Atomic::load_acquire(&JVMHistogram_lock) != 0) {\n-        count +=1;\n-        if ( (WarnOnStalledSpinLock > 0)\n-          && (count % WarnOnStalledSpinLock == 0)) {\n-          warning(\"JVMHistogram_lock seems to be stalled\");\n-        }\n-      }\n-     }\n-\n-    if(JVMHistogram == NULL)\n-      JVMHistogram = new Histogram(\"JVM Call Counts\",100);\n-\n-    JVMHistogram->add_element(this);\n-    Atomic::dec(&JVMHistogram_lock);\n-  }\n-\n-  #define JVMCountWrapper(arg) \\\n-      static JVMHistogramElement* e = new JVMHistogramElement(arg); \\\n-      if (e != NULL) e->increment_count();  \/\/ Due to bug in VC++, we need a NULL check here eventhough it should never happen!\n-\n-  #define JVMWrapper(arg) JVMCountWrapper(arg);\n-#else\n-  #define JVMWrapper(arg)\n-#endif\n-\n@@ -286,1 +242,0 @@\n-  JVMWrapper(\"JVM_CurrentTimeMillis\");\n@@ -291,1 +246,0 @@\n-  JVMWrapper(\"JVM_NanoTime\");\n@@ -303,1 +257,0 @@\n-  JVMWrapper(\"JVM_GetNanoTimeAdjustment\");\n@@ -340,1 +293,0 @@\n-  JVMWrapper(\"JVM_ArrayCopy\");\n@@ -379,1 +331,0 @@\n-  JVMWrapper(\"JVM_GetProperties\");\n@@ -468,1 +419,0 @@\n-  JVMWrapper(\"JVM_GetTemporaryDirectory\");\n@@ -481,1 +431,0 @@\n-  JVMWrapper(\"JVM_BeforeHalt\");\n@@ -501,1 +450,0 @@\n-  JVMWrapper(\"JVM_GC\");\n@@ -509,1 +457,0 @@\n-  JVMWrapper(\"JVM_MaxObjectInspectionAge\");\n@@ -521,1 +468,0 @@\n-  JVMWrapper(\"JVM_TotalMemory\");\n@@ -528,1 +474,0 @@\n-  JVMWrapper(\"JVM_FreeMemory\");\n@@ -535,1 +480,0 @@\n-  JVMWrapper(\"JVM_MaxMemory\");\n@@ -542,1 +486,0 @@\n-  JVMWrapper(\"JVM_ActiveProcessorCount\");\n@@ -547,1 +490,0 @@\n-  JVMWrapper(\"JVM_IsUseContainerSupport\");\n@@ -559,1 +501,0 @@\n-  JVMWrapper(\"JVM_FillInStackTrace\");\n@@ -594,1 +535,0 @@\n-  JVMWrapper(\"JVM_InitStackTraceElementArray\");\n@@ -604,1 +544,0 @@\n-  JVMWrapper(\"JVM_InitStackTraceElement\");\n@@ -617,1 +556,0 @@\n-  JVMWrapper(\"JVM_CallStackWalk\");\n@@ -644,2 +582,0 @@\n-  JVMWrapper(\"JVM_MoreStackWalk\");\n-\n@@ -666,1 +602,0 @@\n-  JVMWrapper(\"JVM_IHashCode\");\n@@ -673,1 +608,0 @@\n-  JVMWrapper(\"JVM_MonitorWait\");\n@@ -690,1 +624,0 @@\n-  JVMWrapper(\"JVM_MonitorNotify\");\n@@ -697,1 +630,0 @@\n-  JVMWrapper(\"JVM_MonitorNotifyAll\");\n@@ -704,1 +636,0 @@\n-  JVMWrapper(\"JVM_Clone\");\n@@ -758,1 +689,0 @@\n-  JVMWrapper(\"JVM_NativePath\");\n@@ -767,2 +697,0 @@\n-  JVMWrapper(\"JVM_GetCallerClass\");\n-\n@@ -808,1 +736,0 @@\n-  JVMWrapper(\"JVM_FindPrimitiveClass\");\n@@ -827,2 +754,0 @@\n-  JVMWrapper(\"JVM_FindClassFromBootLoader\");\n-\n@@ -853,2 +778,0 @@\n-  JVMWrapper(\"JVM_FindClassFromCaller throws ClassNotFoundException\");\n-\n@@ -885,1 +808,0 @@\n-  JVMWrapper(\"JVM_FindClassFromClass\");\n@@ -1114,2 +1036,0 @@\n-  JVMWrapper(\"JVM_DefineClass\");\n-\n@@ -1132,1 +1052,0 @@\n-  JVMWrapper(\"JVM_LookupDefineClass\");\n@@ -1144,1 +1063,0 @@\n-  JVMWrapper(\"JVM_DefineClassWithSource\");\n@@ -1150,1 +1068,0 @@\n-  JVMWrapper(\"JVM_FindLoadedClass\");\n@@ -1205,1 +1122,0 @@\n-  JVMWrapper(\"JVM_DefineModule\");\n@@ -1210,1 +1126,0 @@\n-  JVMWrapper(\"JVM_SetBootLoaderUnnamedModule\");\n@@ -1215,1 +1130,0 @@\n-  JVMWrapper(\"JVM_AddModuleExports\");\n@@ -1220,1 +1134,0 @@\n-  JVMWrapper(\"JVM_AddModuleExportsToAllUnnamed\");\n@@ -1225,1 +1138,0 @@\n-  JVMWrapper(\"JVM_AddModuleExportsToAll\");\n@@ -1230,1 +1142,0 @@\n-  JVMWrapper(\"JVM_AddReadsModule\");\n@@ -1235,1 +1146,0 @@\n-  JVMWrapper(\"JVM_DefineArchivedModules\");\n@@ -1243,1 +1153,0 @@\n-  JVMWrapper(\"JVM_InitClassName\");\n@@ -1254,1 +1163,0 @@\n-  JVMWrapper(\"JVM_GetClassInterfaces\");\n@@ -1295,1 +1203,0 @@\n-  JVMWrapper(\"JVM_IsInterface\");\n@@ -1310,1 +1217,0 @@\n-  JVMWrapper(\"JVM_IsHiddenClass\");\n@@ -1320,1 +1226,0 @@\n-  JVMWrapper(\"JVM_GetClassSigners\");\n@@ -1347,1 +1252,0 @@\n-  JVMWrapper(\"JVM_SetClassSigners\");\n@@ -1362,1 +1266,0 @@\n-  JVMWrapper(\"JVM_GetProtectionDomain\");\n@@ -1380,1 +1283,0 @@\n-  JVMWrapper(\"JVM_GetInheritedAccessControlContext\");\n@@ -1386,1 +1288,0 @@\n-  JVMWrapper(\"JVM_GetStackAccessControlContext\");\n@@ -1463,1 +1364,0 @@\n-  JVMWrapper(\"JVM_IsArrayClass\");\n@@ -1470,1 +1370,0 @@\n-  JVMWrapper(\"JVM_IsPrimitiveClass\");\n@@ -1477,1 +1376,0 @@\n-  JVMWrapper(\"JVM_GetClassModifiers\");\n@@ -1606,1 +1504,0 @@\n-  JVMWrapper(\"JVM_GetClassSignature\");\n@@ -1626,1 +1523,0 @@\n-  JVMWrapper(\"JVM_GetClassAnnotations\");\n@@ -1696,1 +1592,0 @@\n-  JVMWrapper(\"JVM_GetClassTypeAnnotations\");\n@@ -1714,2 +1609,0 @@\n-  JVMWrapper(\"JVM_GetMethodTypeAnnotations\");\n-\n@@ -1733,2 +1626,0 @@\n-  JVMWrapper(\"JVM_GetFieldTypeAnnotations\");\n-\n@@ -1752,1 +1643,0 @@\n-  JVMWrapper(\"JVM_GetMethodParameters\");\n@@ -1806,1 +1696,0 @@\n-  JVMWrapper(\"JVM_GetClassDeclaredFields\");\n@@ -1858,1 +1747,0 @@\n-  JVMWrapper(\"JVM_IsRecord\");\n@@ -1876,1 +1764,0 @@\n-  JVMWrapper(\"JVM_GetRecordComponents\");\n@@ -1984,1 +1871,0 @@\n-  JVMWrapper(\"JVM_GetClassDeclaredMethods\");\n@@ -1993,1 +1879,0 @@\n-  JVMWrapper(\"JVM_GetClassDeclaredConstructors\");\n@@ -2002,1 +1887,0 @@\n-  JVMWrapper(\"JVM_GetClassAccessFlags\");\n@@ -2016,1 +1900,0 @@\n-  JVMWrapper(\"JVM_AreNestMates\");\n@@ -2030,1 +1913,0 @@\n-  JVMWrapper(\"JVM_GetNestHost\");\n@@ -2043,1 +1925,0 @@\n-  JVMWrapper(\"JVM_GetNestMembers\");\n@@ -2123,1 +2004,0 @@\n-  JVMWrapper(\"JVM_GetPermittedSubclasses\");\n@@ -2187,1 +2067,0 @@\n-  JVMWrapper(\"JVM_GetClassConstantPool\");\n@@ -2207,1 +2086,0 @@\n-  JVMWrapper(\"JVM_ConstantPoolGetSize\");\n@@ -2216,1 +2094,0 @@\n-  JVMWrapper(\"JVM_ConstantPoolGetClassAt\");\n@@ -2230,1 +2107,0 @@\n-  JVMWrapper(\"JVM_ConstantPoolGetClassAtIfLoaded\");\n@@ -2274,1 +2150,0 @@\n-  JVMWrapper(\"JVM_ConstantPoolGetMethodAt\");\n@@ -2285,1 +2160,0 @@\n-  JVMWrapper(\"JVM_ConstantPoolGetMethodAtIfLoaded\");\n@@ -2321,1 +2195,0 @@\n-  JVMWrapper(\"JVM_ConstantPoolGetFieldAt\");\n@@ -2332,1 +2205,0 @@\n-  JVMWrapper(\"JVM_ConstantPoolGetFieldAtIfLoaded\");\n@@ -2343,1 +2215,0 @@\n-  JVMWrapper(\"JVM_ConstantPoolGetMemberRefInfoAt\");\n@@ -2369,1 +2240,0 @@\n-  JVMWrapper(\"JVM_ConstantPoolGetClassRefIndexAt\");\n@@ -2383,1 +2253,0 @@\n-  JVMWrapper(\"JVM_ConstantPoolGetNameAndTypeRefIndexAt\");\n@@ -2397,1 +2266,0 @@\n-  JVMWrapper(\"JVM_ConstantPoolGetNameAndTypeRefInfoAt\");\n@@ -2419,1 +2287,0 @@\n-  JVMWrapper(\"JVM_ConstantPoolGetIntAt\");\n@@ -2432,1 +2299,0 @@\n-  JVMWrapper(\"JVM_ConstantPoolGetLongAt\");\n@@ -2445,1 +2311,0 @@\n-  JVMWrapper(\"JVM_ConstantPoolGetFloatAt\");\n@@ -2458,1 +2323,0 @@\n-  JVMWrapper(\"JVM_ConstantPoolGetDoubleAt\");\n@@ -2471,1 +2335,0 @@\n-  JVMWrapper(\"JVM_ConstantPoolGetStringAt\");\n@@ -2485,1 +2348,0 @@\n-  JVMWrapper(\"JVM_ConstantPoolGetUTF8At\");\n@@ -2501,1 +2363,0 @@\n-  JVMWrapper(\"JVM_ConstantPoolGetTagAt\");\n@@ -2527,1 +2388,0 @@\n-  JVMWrapper(\"JVM_DesiredAssertionStatus\");\n@@ -2549,1 +2409,0 @@\n-  JVMWrapper(\"JVM_AssertionStatusDirectives\");\n@@ -2568,1 +2427,0 @@\n-  JVMWrapper(\"JVM_GetClassNameUTF\");\n@@ -2576,1 +2434,0 @@\n-  JVMWrapper(\"JVM_GetClassCPTypes\");\n@@ -2592,1 +2449,0 @@\n-  JVMWrapper(\"JVM_GetClassCPEntriesCount\");\n@@ -2600,1 +2456,0 @@\n-  JVMWrapper(\"JVM_GetClassFieldsCount\");\n@@ -2608,1 +2463,0 @@\n-  JVMWrapper(\"JVM_GetClassMethodsCount\");\n@@ -2621,1 +2475,0 @@\n-  JVMWrapper(\"JVM_GetMethodIxExceptionIndexes\");\n@@ -2636,1 +2489,0 @@\n-  JVMWrapper(\"JVM_GetMethodIxExceptionsCount\");\n@@ -2645,1 +2497,0 @@\n-  JVMWrapper(\"JVM_GetMethodIxByteCode\");\n@@ -2654,1 +2505,0 @@\n-  JVMWrapper(\"JVM_GetMethodIxByteCodeLength\");\n@@ -2663,1 +2513,0 @@\n-  JVMWrapper(\"JVM_GetMethodIxExceptionTableEntry\");\n@@ -2676,1 +2525,0 @@\n-  JVMWrapper(\"JVM_GetMethodIxExceptionTableLength\");\n@@ -2685,1 +2533,0 @@\n-  JVMWrapper(\"JVM_GetMethodIxModifiers\");\n@@ -2694,1 +2541,0 @@\n-  JVMWrapper(\"JVM_GetFieldIxModifiers\");\n@@ -2702,1 +2548,0 @@\n-  JVMWrapper(\"JVM_GetMethodIxLocalsCount\");\n@@ -2711,1 +2556,0 @@\n-  JVMWrapper(\"JVM_GetMethodIxArgsSize\");\n@@ -2720,1 +2564,0 @@\n-  JVMWrapper(\"JVM_GetMethodIxMaxStack\");\n@@ -2729,1 +2572,0 @@\n-  JVMWrapper(\"JVM_IsConstructorIx\");\n@@ -2739,1 +2581,0 @@\n-  JVMWrapper(\"JVM_IsVMGeneratedMethodIx\");\n@@ -2748,1 +2589,0 @@\n-  JVMWrapper(\"JVM_GetMethodIxIxUTF\");\n@@ -2757,1 +2597,0 @@\n-  JVMWrapper(\"JVM_GetMethodIxSignatureUTF\");\n@@ -2773,1 +2612,0 @@\n-  JVMWrapper(\"JVM_GetCPFieldNameUTF\");\n@@ -2789,1 +2627,0 @@\n-  JVMWrapper(\"JVM_GetCPMethodNameUTF\");\n@@ -2806,1 +2643,0 @@\n-  JVMWrapper(\"JVM_GetCPMethodSignatureUTF\");\n@@ -2823,1 +2659,0 @@\n-  JVMWrapper(\"JVM_GetCPFieldSignatureUTF\");\n@@ -2839,1 +2674,0 @@\n-  JVMWrapper(\"JVM_GetCPClassNameUTF\");\n@@ -2849,1 +2683,0 @@\n-  JVMWrapper(\"JVM_GetCPFieldClassNameUTF\");\n@@ -2868,1 +2701,0 @@\n-  JVMWrapper(\"JVM_GetCPMethodClassNameUTF\");\n@@ -2888,1 +2720,0 @@\n-  JVMWrapper(\"JVM_GetCPFieldModifiers\");\n@@ -2916,1 +2747,0 @@\n-  JVMWrapper(\"JVM_GetCPMethodModifiers\");\n@@ -2953,1 +2783,0 @@\n-  JVMWrapper(\"JVM_IsSameClassPackage\");\n@@ -3053,1 +2882,0 @@\n-  JVMWrapper(\"JVM_StartThread\");\n@@ -3141,2 +2969,0 @@\n-  JVMWrapper(\"JVM_StopThread\");\n-\n@@ -3180,2 +3006,0 @@\n-  JVMWrapper(\"JVM_IsThreadAlive\");\n-\n@@ -3188,2 +3012,0 @@\n-  JVMWrapper(\"JVM_SuspendThread\");\n-\n@@ -3225,2 +3047,0 @@\n-  JVMWrapper(\"JVM_ResumeThread\");\n-\n@@ -3254,2 +3074,0 @@\n-  JVMWrapper(\"JVM_SetThreadPriority\");\n-\n@@ -3273,1 +3091,0 @@\n-  JVMWrapper(\"JVM_Yield\");\n@@ -3287,2 +3104,0 @@\n-  JVMWrapper(\"JVM_Sleep\");\n-\n@@ -3332,1 +3147,0 @@\n-  JVMWrapper(\"JVM_CurrentThread\");\n@@ -3339,2 +3153,0 @@\n-  JVMWrapper(\"JVM_Interrupt\");\n-\n@@ -3354,1 +3166,0 @@\n-  JVMWrapper(\"JVM_HoldsLock\");\n@@ -3364,1 +3175,0 @@\n-  JVMWrapper(\"JVM_DumpAllStacks\");\n@@ -3373,2 +3183,0 @@\n-  JVMWrapper(\"JVM_SetNativeThreadName\");\n-\n@@ -3392,1 +3200,0 @@\n-  JVMWrapper(\"JVM_GetClassContext\");\n@@ -3434,1 +3241,0 @@\n-  JVMWrapper(\"JVM_GetSystemPackage\");\n@@ -3444,1 +3250,0 @@\n-  JVMWrapper(\"JVM_GetSystemPackages\");\n@@ -3455,2 +3260,0 @@\n-  JVMWrapper(\"JVM_GetAndClearReferencePendingList\");\n-\n@@ -3466,1 +3269,0 @@\n-  JVMWrapper(\"JVM_HasReferencePendingList\");\n@@ -3472,1 +3274,0 @@\n-  JVMWrapper(\"JVM_WaitForReferencePendingList\");\n@@ -3480,1 +3281,0 @@\n-  JVMWrapper(\"JVM_ReferenceRefersTo\");\n@@ -3487,1 +3287,0 @@\n-  JVMWrapper(\"JVM_ReferenceClear\");\n@@ -3510,1 +3309,0 @@\n-  JVMWrapper(\"JVM_PhantomReferenceRefersTo\");\n@@ -3553,1 +3351,0 @@\n-  JVMWrapper(\"JVM_GetArrayLength\");\n@@ -3560,1 +3357,0 @@\n-  JVMWrapper(\"JVM_Array_Get\");\n@@ -3571,1 +3367,0 @@\n-  JVMWrapper(\"JVM_GetPrimitiveArrayElement\");\n@@ -3586,1 +3381,0 @@\n-  JVMWrapper(\"JVM_SetArrayElement\");\n@@ -3603,1 +3397,0 @@\n-  JVMWrapper(\"JVM_SetPrimitiveArrayElement\");\n@@ -3612,1 +3405,0 @@\n-  JVMWrapper(\"JVM_NewArray\");\n@@ -3621,1 +3413,0 @@\n-  JVMWrapper(\"JVM_NewMultiArray\");\n@@ -3635,1 +3426,0 @@\n-  JVMWrapper(\"JVM_LoadLibrary\");\n@@ -3662,1 +3452,0 @@\n-  JVMWrapper(\"JVM_UnloadLibrary\");\n@@ -3669,1 +3458,0 @@\n-  JVMWrapper(\"JVM_FindLibraryEntry\");\n@@ -3681,1 +3469,0 @@\n-  JVMWrapper(\"JVM_IsSupportedJNIVersion\");\n@@ -3689,1 +3476,0 @@\n-  JVMWrapper(\"JVM_InternString\");\n@@ -3709,1 +3495,0 @@\n-  JVMWrapper(\"JVM_RawMonitorCreate\");\n@@ -3716,1 +3501,0 @@\n-  JVMWrapper(\"JVM_RawMonitorDestroy\");\n@@ -3723,1 +3507,0 @@\n-  JVMWrapper(\"JVM_RawMonitorEnter\");\n@@ -3731,1 +3514,0 @@\n-  JVMWrapper(\"JVM_RawMonitorExit\");\n@@ -3760,1 +3542,0 @@\n-  JVMWrapper(\"JVM_InvokeMethod\");\n@@ -3785,1 +3566,0 @@\n-  JVMWrapper(\"JVM_NewInstanceFromConstructor\");\n@@ -3799,1 +3579,0 @@\n-  JVMWrapper(\"JVM_SupportsCX8\");\n@@ -3804,1 +3583,0 @@\n-  JVMWrapper(\"JVM_InitializeFromArchive\");\n@@ -3818,1 +3596,0 @@\n-  JVMWrapper(\"JVM_RegisterLambdaProxyClassForArchiving\");\n@@ -3866,1 +3643,0 @@\n-  JVMWrapper(\"JVM_LookupLambdaProxyClassFromArchive\");\n@@ -3909,1 +3685,0 @@\n-    JVMWrapper(\"JVM_IsCDSDumpingEnabled\");\n@@ -3914,1 +3689,0 @@\n-    JVMWrapper(\"JVM_IsSharingEnable\");\n@@ -3919,1 +3693,0 @@\n-  JVMWrapper(\"JVM_GetRandomSeedForDumping\");\n@@ -3942,1 +3715,0 @@\n-  JVMWrapper(\"JVM_IsDumpingClassList\");\n@@ -3951,1 +3723,0 @@\n-  JVMWrapper(\"JVM_LogLambdaFormInvoker\");\n@@ -3989,1 +3760,0 @@\n-  JVMWrapper(\"JVM_DumpThreads\");\n@@ -4036,1 +3806,0 @@\n-  JVMWrapper(\"JVM_InitAgentProperties\");\n@@ -4049,1 +3818,0 @@\n-  JVMWrapper(\"JVM_GetEnclosingMethodInfo\");\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":1,"deletions":233,"binary":false,"changes":234,"status":"modified"},{"patch":"@@ -660,3 +660,0 @@\n-  notproduct(uintx, WarnOnStalledSpinLock, 0,                               \\\n-          \"Print warnings for stalled SpinLocks\")                           \\\n-                                                                            \\\n@@ -1192,13 +1189,0 @@\n-  notproduct(bool, CountRuntimeCalls, false,                                \\\n-          \"Count VM runtime calls\")                                         \\\n-                                                                            \\\n-  develop(bool, CountJNICalls, false,                                       \\\n-          \"Count jni method invocations\")                                   \\\n-                                                                            \\\n-  notproduct(bool, CountJVMCalls, false,                                    \\\n-          \"Count jvm method invocations\")                                   \\\n-                                                                            \\\n-  notproduct(bool, CountRemovableExceptions, false,                         \\\n-          \"Count exceptions that could be replaced by branches due to \"     \\\n-          \"inlining\")                                                       \\\n-                                                                            \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":0,"deletions":16,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -81,25 +81,0 @@\n-Histogram* RuntimeHistogram;\n-\n-RuntimeHistogramElement::RuntimeHistogramElement(const char* elementName) {\n-  static volatile int RuntimeHistogram_lock = 0;\n-  _name = elementName;\n-  uintx count = 0;\n-\n-  while (Atomic::cmpxchg(&RuntimeHistogram_lock, 0, 1) != 0) {\n-    while (Atomic::load_acquire(&RuntimeHistogram_lock) != 0) {\n-      count +=1;\n-      if ( (WarnOnStalledSpinLock > 0)\n-        && (count % WarnOnStalledSpinLock == 0)) {\n-        warning(\"RuntimeHistogram_lock seems to be stalled\");\n-      }\n-    }\n-  }\n-\n-  if (RuntimeHistogram == NULL) {\n-    RuntimeHistogram = new Histogram(\"VM Runtime Call Counts\",200);\n-  }\n-\n-  RuntimeHistogram->add_element(this);\n-  Atomic::dec(&RuntimeHistogram_lock);\n-}\n-\n","filename":"src\/hotspot\/share\/runtime\/interfaceSupport.cpp","additions":1,"deletions":26,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -38,1 +38,0 @@\n-#include \"utilities\/histogram.hpp\"\n@@ -333,15 +332,0 @@\n-class RuntimeHistogramElement : public HistogramElement {\n-  public:\n-   RuntimeHistogramElement(const char* name);\n-};\n-#endif \/\/ ASSERT\n-\n-#ifdef ASSERT\n-#define TRACE_CALL(result_type, header)                            \\\n-  if (CountRuntimeCalls) {                                         \\\n-    static RuntimeHistogramElement* e = new RuntimeHistogramElement(#header); \\\n-    if (e != NULL) e->increment_count();                           \\\n-  }\n-#else\n-#define TRACE_CALL(result_type, header)                            \\\n-  \/* do nothing *\/\n@@ -350,1 +334,0 @@\n-\n@@ -354,1 +337,0 @@\n-  TRACE_CALL(result_type, header)                                    \\\n@@ -360,1 +342,0 @@\n-  TRACE_CALL(result_type, header)                                    \\\n@@ -371,1 +352,0 @@\n-  TRACE_CALL(result_type, header)                                    \\\n@@ -414,1 +394,0 @@\n-    TRACE_CALL(result_type, header)                                  \\\n","filename":"src\/hotspot\/share\/runtime\/interfaceSupport.inline.hpp","additions":0,"deletions":21,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -79,1 +79,0 @@\n-#include \"utilities\/histogram.hpp\"\n@@ -209,19 +208,0 @@\n-#ifdef ASSERT\n-\n-  if (CountRuntimeCalls) {\n-    extern Histogram *RuntimeHistogram;\n-    RuntimeHistogram->print();\n-  }\n-\n-  if (CountJNICalls) {\n-    extern Histogram *JNIHistogram;\n-    JNIHistogram->print();\n-  }\n-\n-  if (CountJVMCalls) {\n-    extern Histogram *JVMHistogram;\n-    JVMHistogram->print();\n-  }\n-\n-#endif\n-\n","filename":"src\/hotspot\/share\/runtime\/java.cpp","additions":1,"deletions":21,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -154,1 +154,0 @@\n-int SharedRuntime::_nof_removable_exceptions = 0;\n@@ -2164,7 +2163,0 @@\n-  if (CountRemovableExceptions) {\n-    if (_nof_removable_exceptions > 0) {\n-      Unimplemented(); \/\/ this counter is not yet incremented\n-      tty->print_cr(\"Removable exceptions: %d\", _nof_removable_exceptions);\n-    }\n-  }\n-\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":1,"deletions":9,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -578,2 +578,0 @@\n-  \/\/ stats for runtime exceptions\n-  static int     _nof_removable_exceptions;      \/\/ total # of exceptions that could be replaced by branches due to inlining\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,102 +0,0 @@\n-\/*\n- * Copyright (c) 1998, 2016, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"precompiled.hpp\"\n-#include \"oops\/oop.inline.hpp\"\n-#include \"runtime\/atomic.hpp\"\n-#include \"utilities\/histogram.hpp\"\n-\n-#ifdef ASSERT\n-\n-\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ HistogramElement \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\n-HistogramElement::HistogramElement() {\n-  _count = 0;\n-}\n-\n-int HistogramElement::count() {\n-  return _count;\n-}\n-\n-const char* HistogramElement::name() {\n-  return _name;\n-}\n-\n-void HistogramElement::increment_count() {\n-  \/\/ We can't use the accessor :-(.\n-  Atomic::inc(&_count);\n-}\n-\n-int HistogramElement::compare(HistogramElement* e1,HistogramElement* e2) {\n-  if(e1->count() > e2->count()) {\n-    return -1;\n-  } else if(e1->count() < e2->count()) {\n-    return 1;\n-  }\n-  return 0;\n-}\n-\n-void HistogramElement::print_on(outputStream* st) const {\n-  st->print(\"%10d   \",((HistogramElement*)this)->count());\n-  st->print_cr(\"%s\",((HistogramElement*)this)->name());\n-}\n-\n-\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ Histogram \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\n-int Histogram::sort_helper(HistogramElement** e1, HistogramElement** e2) {\n-  return (*e1)->compare(*e1,*e2);\n-}\n-\n-Histogram::Histogram(const char* title,int estimatedCount) {\n-  _title = title;\n-  _elements = new (ResourceObj::C_HEAP, mtServiceability) GrowableArray<HistogramElement*>(estimatedCount, mtServiceability);\n-}\n-\n-void Histogram::add_element(HistogramElement* element) {\n-  \/\/ Note, we need to add locking !\n-  elements()->append(element);\n-}\n-\n-void Histogram::print_header(outputStream* st) {\n-  st->print_cr(\"%s\",title());\n-  st->print_cr(\"--------------------------------------------------\");\n-}\n-\n-void Histogram::print_elements(outputStream* st) {\n-  elements()->sort(Histogram::sort_helper);\n-  jint total = 0;\n-  for(int i=0; i < elements()->length(); i++) {\n-    elements()->at(i)->print();\n-    total += elements()->at(i)->count();\n-  }\n-  st->print(\"%10d   \", total);\n-  st->print_cr(\"Total\");\n-}\n-\n-void Histogram::print_on(outputStream* st) const {\n-  ((Histogram*)this)->print_header(st);\n-  ((Histogram*)this)->print_elements(st);\n-}\n-\n-#endif\n","filename":"src\/hotspot\/share\/utilities\/histogram.cpp","additions":0,"deletions":102,"binary":false,"changes":102,"status":"deleted"},{"patch":"@@ -1,100 +0,0 @@\n-\/*\n- * Copyright (c) 1998, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_UTILITIES_HISTOGRAM_HPP\n-#define SHARE_UTILITIES_HISTOGRAM_HPP\n-\n-#include \"memory\/allocation.hpp\"\n-#include \"runtime\/os.hpp\"\n-#include \"utilities\/growableArray.hpp\"\n-\n-\/\/ This class provides a framework for collecting various statistics.\n-\/\/ The current implementation is oriented towards counting invocations\n-\/\/ of various types, but that can be easily changed.\n-\/\/\n-\/\/ To use it, you need to declare a Histogram*, and a subtype of\n-\/\/ HistogramElement:\n-\/\/\n-\/\/  HistogramElement* MyHistogram;\n-\/\/\n-\/\/  class MyHistogramElement : public HistogramElement {\n-\/\/    public:\n-\/\/      MyHistogramElement(char* name);\n-\/\/  };\n-\/\/\n-\/\/  MyHistogramElement::MyHistogramElement(char* elementName) {\n-\/\/    _name = elementName;\n-\/\/\n-\/\/    if(MyHistogram == NULL)\n-\/\/      MyHistogram = new Histogram(\"My Call Counts\",100);\n-\/\/\n-\/\/    MyHistogram->add_element(this);\n-\/\/  }\n-\/\/\n-\/\/  #define MyCountWrapper(arg) static MyHistogramElement* e = new MyHistogramElement(arg); e->increment_count()\n-\/\/\n-\/\/ This gives you a simple way to count invocations of specfic functions:\n-\/\/\n-\/\/ void a_function_that_is_being_counted() {\n-\/\/   MyCountWrapper(\"FunctionName\");\n-\/\/   ...\n-\/\/ }\n-\/\/\n-\/\/ To print the results, invoke print() on your Histogram*.\n-\n-#ifdef ASSERT\n-\n-class HistogramElement : public CHeapObj<mtInternal> {\n- protected:\n-  jint _count;\n-  const char* _name;\n-\n- public:\n-  HistogramElement();\n-  virtual int count();\n-  virtual const char* name();\n-  virtual void increment_count();\n-  void print_on(outputStream* st) const;\n-  virtual int compare(HistogramElement* e1,HistogramElement* e2);\n-};\n-\n-class Histogram : public CHeapObj<mtInternal> {\n- protected:\n-  GrowableArray<HistogramElement*>* _elements;\n-  GrowableArray<HistogramElement*>* elements() { return _elements; }\n-  const char* _title;\n-  const char* title() { return _title; }\n-  static int sort_helper(HistogramElement** e1,HistogramElement** e2);\n-  virtual void print_header(outputStream* st);\n-  virtual void print_elements(outputStream* st);\n-\n- public:\n-  Histogram(const char* title,int estimatedSize);\n-  virtual void add_element(HistogramElement* element);\n-  void print_on(outputStream* st) const;\n-};\n-\n-#endif\n-\n-#endif \/\/ SHARE_UTILITIES_HISTOGRAM_HPP\n","filename":"src\/hotspot\/share\/utilities\/histogram.hpp","additions":0,"deletions":100,"binary":false,"changes":100,"status":"deleted"}]}