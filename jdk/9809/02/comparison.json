{"files":[{"patch":"@@ -403,7 +403,1 @@\n-    for (int i = 0; i < _modules->table_size(); i++) {\n-      for (ModuleEntry* entry = _modules->bucket(i);\n-           entry != NULL;\n-           entry = entry->next()) {\n-        f(entry);\n-      }\n-    }\n+    _modules->modules_do(f);\n@@ -595,1 +589,1 @@\n-      modules = new ModuleEntryTable(ModuleEntryTable::_moduletable_entry_size);\n+      modules = new ModuleEntryTable();\n@@ -718,1 +712,1 @@\n-    _unnamed_module->delete_unnamed_module();\n+    delete _unnamed_module;\n@@ -1043,0 +1037,4 @@\n+\n+  if (_modules != NULL) {\n+    _modules->verify();\n+  }\n","filename":"src\/hotspot\/share\/classfile\/classLoaderData.cpp","additions":7,"deletions":9,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -84,2 +84,5 @@\n-  for (int i = 0; i < met->table_size(); i++) {\n-    for (ModuleEntry* m = met->bucket(i); m != NULL;) {\n+  class Process : public ModuleClosure {\n+    JavaThread* _current;\n+   public:\n+    Process(JavaThread* current) : _current(current) {}\n+    void do_module(ModuleEntry* m) {\n@@ -89,1 +92,1 @@\n-        ClassLoader::setup_module_search_path(current, path);\n+        ClassLoader::setup_module_search_path(_current, path);\n@@ -91,1 +94,0 @@\n-      m = m->next();\n@@ -93,1 +95,3 @@\n-  }\n+  };\n+  Process process(current);\n+  met->modules_do(&process);\n@@ -95,0 +99,1 @@\n+\n","filename":"src\/hotspot\/share\/classfile\/classLoaderExt.cpp","additions":11,"deletions":6,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -54,5 +54,3 @@\n-  if (_location != NULL) {\n-    \/\/ _location symbol's refcounts are managed by ModuleEntry,\n-    \/\/ must decrement the old one before updating.\n-    _location->decrement_refcount();\n-  }\n+  \/\/ _location symbol's refcounts are managed by ModuleEntry,\n+  \/\/ must decrement the old one before updating.\n+  Symbol::maybe_decrement_refcount(_location);\n@@ -101,5 +99,3 @@\n-  if (_version != NULL) {\n-    \/\/ _version symbol's refcounts are managed by ModuleEntry,\n-    \/\/ must decrement the old one before updating.\n-    _version->decrement_refcount();\n-  }\n+  \/\/ _version symbol's refcounts are managed by ModuleEntry,\n+  \/\/ must decrement the old one before updating.\n+  Symbol::maybe_decrement_refcount(_version);\n@@ -109,3 +105,1 @@\n-  if (version != NULL) {\n-    version->increment_refcount();\n-  }\n+  Symbol::maybe_increment_refcount(version);\n@@ -265,0 +259,53 @@\n+ModuleEntry::ModuleEntry(Handle module_handle,\n+                         bool is_open, Symbol* name,\n+                         Symbol* version, Symbol* location,\n+                         ClassLoaderData* loader_data) :\n+    _name(name),\n+    _loader_data(loader_data),\n+    _reads(nullptr),\n+    _version(nullptr),\n+    _location(nullptr),\n+    CDS_ONLY(_shared_path_index(-1) COMMA)\n+    _can_read_all_unnamed(false),\n+    _has_default_read_edges(false),\n+    _must_walk_reads(false),\n+    _is_open(is_open),\n+    _is_patched(false) {\n+\n+  \/\/ Initialize fields specific to a ModuleEntry\n+  if (_name == nullptr) {\n+    \/\/ Unnamed modules can read all other unnamed modules.\n+    set_can_read_all_unnamed();\n+  } else {\n+    _name->increment_refcount();\n+  }\n+\n+  if (!module_handle.is_null()) {\n+    _module = loader_data->add_handle(module_handle);\n+  }\n+\n+  set_version(version);\n+\n+  \/\/ may need to add CDS info\n+  set_location(location);\n+\n+  if (name != nullptr && ClassLoader::is_in_patch_mod_entries(name)) {\n+    set_is_patched();\n+    if (log_is_enabled(Trace, module, patch)) {\n+      ResourceMark rm;\n+      log_trace(module, patch)(\"Marked module %s as patched from --patch-module\",\n+                               name != NULL ? name->as_C_string() : UNNAMED_MODULE);\n+    }\n+  }\n+\n+  JFR_ONLY(INIT_ID(this);)\n+}\n+\n+ModuleEntry::~ModuleEntry() {\n+  \/\/ Clean out the C heap allocated reads list first before freeing the entry\n+  delete_reads();\n+  Symbol::maybe_decrement_refcount(_name);\n+  Symbol::maybe_decrement_refcount(_version);\n+  Symbol::maybe_decrement_refcount(_location);\n+}\n+\n@@ -298,9 +345,0 @@\n-  ModuleEntry* entry = NEW_C_HEAP_OBJ(ModuleEntry, mtModule);\n-\n-  \/\/ Initialize everything BasicHashtable would\n-  entry->set_next(NULL);\n-  entry->set_hash(0);\n-  entry->set_literal(NULL);\n-\n-  \/\/ Initialize fields specific to a ModuleEntry\n-  entry->init();\n@@ -308,0 +346,3 @@\n+  ModuleEntry* entry = new ModuleEntry(module_handle, \/*is_open*\/true, \/*name*\/nullptr,\n+                                       \/*version*\/ nullptr, \/*location*\/ nullptr,\n+                                       cld);\n@@ -309,11 +350,1 @@\n-  entry->set_can_read_all_unnamed();\n-\n-  if (!module_handle.is_null()) {\n-    entry->set_module(cld->add_handle(module_handle));\n-  }\n-\n-  entry->set_loader_data(cld);\n-  entry->_is_open = true;\n-\n-  JFR_ONLY(INIT_ID(entry);)\n-\n+  assert(entry->can_read_all_unnamed(), \"constructor set that\");\n@@ -323,18 +354,1 @@\n-void ModuleEntry::delete_unnamed_module() {\n-  \/\/ Do not need unlink_entry() since the unnamed module is not in the hashtable\n-  FREE_C_HEAP_OBJ(this);\n-}\n-\n-ModuleEntryTable::ModuleEntryTable(int table_size)\n-  : Hashtable<Symbol*, mtModule>(table_size, sizeof(ModuleEntry))\n-{\n-}\n-\n-ModuleEntryTable::~ModuleEntryTable() {\n-  \/\/ Walk through all buckets and all entries in each bucket,\n-  \/\/ freeing each entry.\n-  for (int i = 0; i < table_size(); ++i) {\n-    for (ModuleEntry* m = bucket(i); m != NULL;) {\n-      ModuleEntry* to_remove = m;\n-      \/\/ read next before freeing.\n-      m = m->next();\n+ModuleEntryTable::ModuleEntryTable() { }\n@@ -342,0 +356,4 @@\n+class ModuleEntryTableDeleter : public StackObj {\n+ public:\n+  bool do_entry(const Symbol*& name, ModuleEntry*& entry) {\n+    if (log_is_enabled(Info, module, unload) || log_is_enabled(Debug, module)) {\n@@ -343,18 +361,3 @@\n-      if (to_remove->name() != NULL) {\n-        log_info(module, unload)(\"unloading module %s\", to_remove->name()->as_C_string());\n-      }\n-      log_debug(module)(\"ModuleEntryTable: deleting module: %s\", to_remove->name() != NULL ?\n-                        to_remove->name()->as_C_string() : UNNAMED_MODULE);\n-\n-      \/\/ Clean out the C heap allocated reads list first before freeing the entry\n-      to_remove->delete_reads();\n-      if (to_remove->name() != NULL) {\n-        to_remove->name()->decrement_refcount();\n-      }\n-      if (to_remove->version() != NULL) {\n-        to_remove->version()->decrement_refcount();\n-      }\n-      if (to_remove->location() != NULL) {\n-        to_remove->location()->decrement_refcount();\n-      }\n-      BasicHashtable<mtModule>::free_entry(to_remove);\n+      const char* str = name->as_C_string();\n+      log_info(module, unload)(\"unloading module %s\", str);\n+      log_debug(module)(\"ModuleEntryTable: deleting module: %s\", str);\n@@ -362,0 +365,2 @@\n+    delete entry;\n+    return true;\n@@ -363,1 +368,7 @@\n-  assert(number_of_entries() == 0, \"should have removed all entries\");\n+};\n+\n+ModuleEntryTable::~ModuleEntryTable() {\n+  ModuleEntryTableDeleter deleter;\n+  _table.unlink(&deleter);\n+  assert(_table.number_of_entries() == 0, \"should have removed all entries\");\n+\n@@ -432,1 +443,1 @@\n-  closure->push(literal_addr()); \/\/ name\n+  closure->push(&_name);\n@@ -440,2 +451,0 @@\n-  set_next(NULL);\n-  set_hash(0x0);        \/\/ re-init at runtime\n@@ -444,3 +453,3 @@\n-  if (literal() != NULL) {\n-    set_literal(ArchiveBuilder::get_relocated_symbol(literal()));\n-    ArchivePtrMarker::mark_pointer((address*)literal_addr());\n+  if (name() != NULL) {\n+    _name = ArchiveBuilder::get_relocated_symbol(_name);\n+    ArchivePtrMarker::mark_pointer((address*)&_name);\n@@ -506,2 +515,1 @@\n-  for (int i = 0; i < table_size(); ++i) {\n-    for (ModuleEntry* m = bucket(i); m != NULL; m = m->next()) {\n+  auto syms = [&] (const Symbol*& key, ModuleEntry*& m) {\n@@ -509,2 +517,2 @@\n-    }\n-  }\n+  };\n+  _table.iterate_all(syms);\n@@ -514,1 +522,1 @@\n-  Array<ModuleEntry*>* archived_modules = ArchiveBuilder::new_rw_array<ModuleEntry*>(number_of_entries());\n+  Array<ModuleEntry*>* archived_modules = ArchiveBuilder::new_rw_array<ModuleEntry*>(_table.number_of_entries());\n@@ -516,5 +524,5 @@\n-  for (int i = 0; i < table_size(); ++i) {\n-    for (ModuleEntry* m = bucket(i); m != NULL; m = m->next()) {\n-      archived_modules->at_put(n++, m);\n-    }\n-  }\n+  auto grab = [&] (const Symbol*& key, ModuleEntry*& m) {\n+    archived_modules->at_put(n++, m);\n+  };\n+  _table.iterate_all(grab);\n+\n@@ -555,4 +563,1 @@\n-\n-    unsigned int hash = compute_hash(archived_entry->name());\n-    archived_entry->set_hash(hash);\n-    add_entry(hash_to_index(hash), archived_entry);\n+    _table.put(archived_entry->name(), archived_entry);\n@@ -571,44 +576,0 @@\n-ModuleEntry* ModuleEntryTable::new_entry(unsigned int hash, Handle module_handle,\n-                                         bool is_open, Symbol* name,\n-                                         Symbol* version, Symbol* location,\n-                                         ClassLoaderData* loader_data) {\n-  assert(Module_lock->owned_by_self(), \"should have the Module_lock\");\n-  ModuleEntry* entry = (ModuleEntry*)Hashtable<Symbol*, mtModule>::new_entry(hash, name);\n-\n-  \/\/ Initialize fields specific to a ModuleEntry\n-  entry->init();\n-  if (name != NULL) {\n-    name->increment_refcount();\n-  } else {\n-    \/\/ Unnamed modules can read all other unnamed modules.\n-    entry->set_can_read_all_unnamed();\n-  }\n-\n-  if (!module_handle.is_null()) {\n-    entry->set_module(loader_data->add_handle(module_handle));\n-  }\n-\n-  entry->set_loader_data(loader_data);\n-  entry->set_version(version);\n-  entry->set_location(location);\n-  entry->set_is_open(is_open);\n-\n-  if (ClassLoader::is_in_patch_mod_entries(name)) {\n-    entry->set_is_patched();\n-    if (log_is_enabled(Trace, module, patch)) {\n-      ResourceMark rm;\n-      log_trace(module, patch)(\"Marked module %s as patched from --patch-module\",\n-                               name != NULL ? name->as_C_string() : UNNAMED_MODULE);\n-    }\n-  }\n-\n-  JFR_ONLY(INIT_ID(entry);)\n-\n-  return entry;\n-}\n-\n-void ModuleEntryTable::add_entry(int index, ModuleEntry* new_entry) {\n-  assert(Module_lock->owned_by_self(), \"should have the Module_lock\");\n-  Hashtable<Symbol*, mtModule>::add_entry(index, (HashtableEntry<Symbol*, mtModule>*)new_entry);\n-}\n-\n@@ -627,3 +588,4 @@\n-  ModuleEntry* entry = new_entry(compute_hash(module_name), module_handle, is_open, module_name,\n-                                 module_version, module_location, loader_data);\n-  add_entry(index_for(module_name), entry);\n+  ModuleEntry* entry = new ModuleEntry(module_handle, is_open, module_name,\n+                                       module_version, module_location, loader_data);\n+  bool created = _table.put(module_name, entry);\n+  assert(created, \"should be\");\n@@ -635,0 +597,1 @@\n+  assert_locked_or_safepoint(Module_lock);\n@@ -636,7 +599,2 @@\n-  int index = index_for(name);\n-  for (ModuleEntry* m = bucket(index); m != NULL; m = m->next()) {\n-    if (m->name()->fast_compare(name) == 0) {\n-      return m;\n-    }\n-  }\n-  return NULL;\n+  ModuleEntry** entry = _table.get(name);\n+  return (entry == nullptr) ? nullptr : *entry;\n@@ -649,7 +607,4 @@\n-  for (int i = 0; i < table_size(); i++) {\n-    for (ModuleEntry* entry = bucket(i);\n-                      entry != NULL;\n-                      entry = entry->next()) {\n-      entry->purge_reads();\n-    }\n-  }\n+  auto purge = [&] (const Symbol*& key, ModuleEntry*& entry) {\n+    entry->purge_reads();\n+  };\n+  _table.iterate_all(purge);\n@@ -718,0 +673,4 @@\n+  ResourceMark rm;\n+  auto printer = [&] (const Symbol*& name, ModuleEntry*& entry) {\n+    entry->print(st);\n+  };\n@@ -719,8 +678,17 @@\n-               table_size(), number_of_entries());\n-  for (int i = 0; i < table_size(); i++) {\n-    for (ModuleEntry* probe = bucket(i);\n-                              probe != NULL;\n-                              probe = probe->next()) {\n-      probe->print(st);\n-    }\n-  }\n+               _table.table_size(), _table.number_of_entries());\n+  assert_locked_or_safepoint(Module_lock);\n+  _table.iterate_all(printer);\n+}\n+\n+void ModuleEntryTable::modules_do(void f(ModuleEntry*)) {\n+  auto do_f = [&] (const Symbol*& key, ModuleEntry*& entry) {\n+    f(entry);\n+  };\n+  _table.iterate_all(do_f);\n+}\n+\n+void ModuleEntryTable::modules_do(ModuleClosure* closure) {\n+  auto do_f = [&] (const Symbol*& key, ModuleEntry*& entry) {\n+    closure->do_module(entry);\n+  };\n+  _table.iterate_all(do_f);\n@@ -730,2 +698,1 @@\n-  ResourceMark rm;\n-  st->print_cr(\"entry \" PTR_FORMAT \" name %s module \" PTR_FORMAT \" loader %s version %s location %s strict %s next \" PTR_FORMAT,\n+  st->print_cr(\"entry \" PTR_FORMAT \" name %s module \" PTR_FORMAT \" loader %s version %s location %s strict %s\",\n@@ -738,1 +705,1 @@\n-               BOOL_TO_STR(!can_read_all_unnamed()), p2i(next()));\n+               BOOL_TO_STR(!can_read_all_unnamed()));\n@@ -742,1 +709,5 @@\n-  verify_table<ModuleEntry>(\"Module Entry Table\");\n+  auto do_f = [&] (const Symbol*& key, ModuleEntry*& entry) {\n+    entry->verify();\n+  };\n+  assert_locked_or_safepoint(Module_lock);\n+  _table.iterate_all(do_f);\n","filename":"src\/hotspot\/share\/classfile\/moduleEntry.cpp","additions":135,"deletions":164,"binary":false,"changes":299,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-#include \"utilities\/hashtable.hpp\"\n@@ -36,0 +35,1 @@\n+#include \"utilities\/resourceHash.hpp\"\n@@ -62,2 +62,2 @@\n-\/\/ data structure.\n-class ModuleEntry : public HashtableEntry<Symbol*, mtModule> {\n+\/\/ data structure.  This lock must be taken on all accesses to either table.\n+class ModuleEntry : public CHeapObj<mtModule> {\n@@ -68,0 +68,1 @@\n+  Symbol*          _name;              \/\/ name of this module\n@@ -84,14 +85,4 @@\n-  void init() {\n-    _module = OopHandle();\n-    _shared_pd = OopHandle();\n-    _loader_data = NULL;\n-    _reads = NULL;\n-    _version = NULL;\n-    _location = NULL;\n-    _can_read_all_unnamed = false;\n-    _has_default_read_edges = false;\n-    _must_walk_reads = false;\n-    _is_patched = false;\n-    _is_open = false;\n-    CDS_ONLY(_shared_path_index = -1);\n-  }\n+  ModuleEntry(Handle module_handle,\n+              bool is_open, Symbol* name,\n+              Symbol* version, Symbol* location,\n+              ClassLoaderData* loader_data);\n@@ -99,2 +90,1 @@\n-  Symbol*          name() const                        { return literal(); }\n-  void             set_name(Symbol* n)                 { set_literal(n); }\n+  ~ModuleEntry();\n@@ -102,0 +92,1 @@\n+  Symbol*          name() const                        { return _name; }\n@@ -132,1 +123,1 @@\n-  bool             is_named() const                    { return (name() != NULL); }\n+  bool             is_named() const                    { return (_name != NULL); }\n@@ -163,7 +154,0 @@\n-  ModuleEntry* next() const {\n-    return (ModuleEntry*)HashtableEntry<Symbol*, mtModule>::next();\n-  }\n-  ModuleEntry** next_addr() {\n-    return (ModuleEntry**)HashtableEntry<Symbol*, mtModule>::next_addr();\n-  }\n-\n@@ -181,1 +165,0 @@\n-  void delete_unnamed_module();\n@@ -222,9 +205,1 @@\n-\/\/ The ModuleEntryTable's lookup is lock free.\n-\/\/\n-class ModuleEntryTable : public Hashtable<Symbol*, mtModule> {\n-  friend class VMStructs;\n-public:\n-  enum Constants {\n-    _moduletable_entry_size  = 109 \/\/ number of entries in module entry table\n-  };\n-\n+class ModuleEntryTable : public CHeapObj<mtModule> {\n@@ -233,13 +208,2 @@\n-\n-  ModuleEntry* new_entry(unsigned int hash, Handle module_handle, bool is_open,\n-                         Symbol* name, Symbol* version, Symbol* location, ClassLoaderData* loader_data);\n-  void add_entry(int index, ModuleEntry* new_entry);\n-\n-  int entry_size() const { return BasicHashtable<mtModule>::entry_size(); }\n-\n-  ModuleEntry** bucket_addr(int i) {\n-    return (ModuleEntry**)Hashtable<Symbol*, mtModule>::bucket_addr(i);\n-  }\n-\n-  static unsigned int compute_hash(Symbol* name) { return ((name == NULL) ? 0 : (unsigned int)(name->identity_hash())); }\n-  int index_for(Symbol* name) const              { return hash_to_index(compute_hash(name)); }\n+  ResourceHashtable<const Symbol*, ModuleEntry*, 109, ResourceObj::C_HEAP, mtModule,\n+                    Symbol::compute_hash> _table;\n@@ -248,1 +212,1 @@\n-  ModuleEntryTable(int table_size);\n+  ModuleEntryTable();\n@@ -251,4 +215,0 @@\n-  ModuleEntry* bucket(int i) {\n-    return (ModuleEntry*)Hashtable<Symbol*, mtModule>::bucket(i);\n-  }\n-\n@@ -264,1 +224,1 @@\n-  \/\/ Only lookup module within loader's module entry table.  The table read is lock-free.\n+  \/\/ Only lookup module within loader's module entry table.\n@@ -282,0 +242,3 @@\n+  void modules_do(void f(ModuleEntry*));\n+  void modules_do(ModuleClosure* closure);\n+\n","filename":"src\/hotspot\/share\/classfile\/moduleEntry.hpp","additions":19,"deletions":56,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -434,3 +434,7 @@\n-  ModuleEntry* const jdk_jfr_module = table->lookup_only(jdk_jfr_module_symbol);\n-  if (jdk_jfr_module == NULL) {\n-    return false;\n+  ModuleEntry* jdk_jfr_module;\n+  {\n+    MutexLocker ml(Module_lock);\n+    jdk_jfr_module = table->lookup_only(jdk_jfr_module_symbol);\n+    if (jdk_jfr_module == NULL) {\n+      return false;\n+    }\n","filename":"src\/hotspot\/share\/jfr\/instrumentation\/jfrEventClassTransformer.cpp","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -300,0 +300,4 @@\n+  static unsigned int compute_hash(const Symbol* const& name) {\n+    return (unsigned int) name->identity_hash();\n+  }\n+\n","filename":"src\/hotspot\/share\/oops\/symbol.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -286,1 +286,0 @@\n-template void BasicHashtable<mtModule>::verify_table<ModuleEntry>(char const*);\n","filename":"src\/hotspot\/share\/utilities\/hashtable.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -65,2 +65,0 @@\n-        \".*Hashtable.*new_entry.*\\n\" +\n-        \".*ModuleEntryTable.*new_entry.*\\n\" +\n@@ -70,9 +68,0 @@\n-    \/* Alternate stacktrace that we check if the default fails, because\n-       new_entry may be inlined.\n-    *\/\n-    private static String stackTraceAlternate =\n-        \".*Hashtable.*new_entry.*\\n\" +\n-        \".*ModuleEntryTable.*locked_create_entry.*\\n\" +\n-        \".*Modules.*define_module.*\\n\" +\n-        \".*JVM_DefineModule.*\\n\";\n-\n@@ -86,1 +75,0 @@\n-        \".*ModuleEntryTable.*new_entry.*\\n\" +\n@@ -152,7 +140,1 @@\n-            if (!stackTraceMatches(stackTraceDefault, output)) {\n-                System.out.println(\"Looking for alternate stack matching:\");\n-                System.out.print(stackTraceAlternate);\n-                if (stackTraceMatches(stackTraceAlternate, output)) {\n-                    return;\n-                }\n-            } else {\n+            if (stackTraceMatches(stackTraceDefault, output)) {\n","filename":"test\/hotspot\/jtreg\/runtime\/NMT\/CheckForProperDetailStackTrace.java","additions":1,"deletions":19,"binary":false,"changes":20,"status":"modified"}]}