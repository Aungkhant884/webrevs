{"files":[{"patch":"@@ -3819,196 +3819,0 @@\n-  enc_class aarch64_enc_fast_lock(iRegP object, iRegP box, iRegP tmp, iRegP tmp2) %{\n-    C2_MacroAssembler _masm(&cbuf);\n-    Register oop = as_Register($object$$reg);\n-    Register box = as_Register($box$$reg);\n-    Register disp_hdr = as_Register($tmp$$reg);\n-    Register tmp = as_Register($tmp2$$reg);\n-    Label cont;\n-    Label object_has_monitor;\n-    Label count, no_count;\n-\n-    assert_different_registers(oop, box, tmp, disp_hdr);\n-\n-    \/\/ Load markWord from object into displaced_header.\n-    __ ldr(disp_hdr, Address(oop, oopDesc::mark_offset_in_bytes()));\n-\n-    if (DiagnoseSyncOnValueBasedClasses != 0) {\n-      __ load_klass(tmp, oop);\n-      __ ldrw(tmp, Address(tmp, Klass::access_flags_offset()));\n-      __ tstw(tmp, JVM_ACC_IS_VALUE_BASED_CLASS);\n-      __ br(Assembler::NE, cont);\n-    }\n-\n-    \/\/ Check for existing monitor\n-    __ tbnz(disp_hdr, exact_log2(markWord::monitor_value), object_has_monitor);\n-\n-    if (LockingMode == LM_MONITOR) {\n-      __ tst(oop, oop); \/\/ Set NE to indicate 'failure' -> take slow-path. We know that oop != 0.\n-      __ b(cont);\n-    } else if (LockingMode == LM_LEGACY) {\n-      \/\/ Set tmp to be (markWord of object | UNLOCK_VALUE).\n-      __ orr(tmp, disp_hdr, markWord::unlocked_value);\n-\n-      \/\/ Initialize the box. (Must happen before we update the object mark!)\n-      __ str(tmp, Address(box, BasicLock::displaced_header_offset_in_bytes()));\n-\n-      \/\/ Compare object markWord with an unlocked value (tmp) and if\n-      \/\/ equal exchange the stack address of our box with object markWord.\n-      \/\/ On failure disp_hdr contains the possibly locked markWord.\n-      __ cmpxchg(oop, tmp, box, Assembler::xword, \/*acquire*\/ true,\n-                 \/*release*\/ true, \/*weak*\/ false, disp_hdr);\n-      __ br(Assembler::EQ, cont);\n-\n-      assert(oopDesc::mark_offset_in_bytes() == 0, \"offset of _mark is not 0\");\n-\n-      \/\/ If the compare-and-exchange succeeded, then we found an unlocked\n-      \/\/ object, will have now locked it will continue at label cont\n-\n-      \/\/ Check if the owner is self by comparing the value in the\n-      \/\/ markWord of object (disp_hdr) with the stack pointer.\n-      __ mov(rscratch1, sp);\n-      __ sub(disp_hdr, disp_hdr, rscratch1);\n-      __ mov(tmp, (address) (~(os::vm_page_size()-1) | markWord::lock_mask_in_place));\n-      \/\/ If condition is true we are cont and hence we can store 0 as the\n-      \/\/ displaced header in the box, which indicates that it is a recursive lock.\n-      __ ands(tmp\/*==0?*\/, disp_hdr, tmp);   \/\/ Sets flags for result\n-      __ str(tmp\/*==0, perhaps*\/, Address(box, BasicLock::displaced_header_offset_in_bytes()));\n-      __ b(cont);\n-    } else {\n-      assert(LockingMode == LM_LIGHTWEIGHT, \"must be\");\n-      __ fast_lock(oop, disp_hdr, tmp, rscratch1, no_count);\n-      __ b(count);\n-    }\n-\n-    \/\/ Handle existing monitor.\n-    __ bind(object_has_monitor);\n-\n-    \/\/ The object's monitor m is unlocked iff m->owner == NULL,\n-    \/\/ otherwise m->owner may contain a thread or a stack address.\n-    \/\/\n-    \/\/ Try to CAS m->owner from NULL to current thread.\n-    __ add(tmp, disp_hdr, (in_bytes(ObjectMonitor::owner_offset())-markWord::monitor_value));\n-    __ cmpxchg(tmp, zr, rthread, Assembler::xword, \/*acquire*\/ true,\n-               \/*release*\/ true, \/*weak*\/ false, rscratch1); \/\/ Sets flags for result\n-\n-    if (LockingMode != LM_LIGHTWEIGHT) {\n-      \/\/ Store a non-null value into the box to avoid looking like a re-entrant\n-      \/\/ lock. The fast-path monitor unlock code checks for\n-      \/\/ markWord::monitor_value so use markWord::unused_mark which has the\n-      \/\/ relevant bit set, and also matches ObjectSynchronizer::enter.\n-      __ mov(tmp, (address)markWord::unused_mark().value());\n-      __ str(tmp, Address(box, BasicLock::displaced_header_offset_in_bytes()));\n-    }\n-    __ br(Assembler::EQ, cont); \/\/ CAS success means locking succeeded\n-\n-    __ cmp(rscratch1, rthread);\n-    __ br(Assembler::NE, cont); \/\/ Check for recursive locking\n-\n-    \/\/ Recursive lock case\n-    __ increment(Address(disp_hdr, in_bytes(ObjectMonitor::recursions_offset()) - markWord::monitor_value), 1);\n-    \/\/ flag == EQ still from the cmp above, checking if this is a reentrant lock\n-\n-    __ bind(cont);\n-    \/\/ flag == EQ indicates success\n-    \/\/ flag == NE indicates failure\n-    __ br(Assembler::NE, no_count);\n-\n-    __ bind(count);\n-    __ increment(Address(rthread, JavaThread::held_monitor_count_offset()));\n-\n-    __ bind(no_count);\n-  %}\n-\n-  enc_class aarch64_enc_fast_unlock(iRegP object, iRegP box, iRegP tmp, iRegP tmp2) %{\n-    C2_MacroAssembler _masm(&cbuf);\n-    Register oop = as_Register($object$$reg);\n-    Register box = as_Register($box$$reg);\n-    Register disp_hdr = as_Register($tmp$$reg);\n-    Register tmp = as_Register($tmp2$$reg);\n-    Label cont;\n-    Label object_has_monitor;\n-    Label count, no_count;\n-\n-    assert_different_registers(oop, box, tmp, disp_hdr);\n-\n-    if (LockingMode == LM_LEGACY) {\n-      \/\/ Find the lock address and load the displaced header from the stack.\n-      __ ldr(disp_hdr, Address(box, BasicLock::displaced_header_offset_in_bytes()));\n-\n-      \/\/ If the displaced header is 0, we have a recursive unlock.\n-      __ cmp(disp_hdr, zr);\n-      __ br(Assembler::EQ, cont);\n-    }\n-\n-    \/\/ Handle existing monitor.\n-    __ ldr(tmp, Address(oop, oopDesc::mark_offset_in_bytes()));\n-    __ tbnz(tmp, exact_log2(markWord::monitor_value), object_has_monitor);\n-\n-    if (LockingMode == LM_MONITOR) {\n-      __ tst(oop, oop); \/\/ Set NE to indicate 'failure' -> take slow-path. We know that oop != 0.\n-      __ b(cont);\n-    } else if (LockingMode == LM_LEGACY) {\n-      \/\/ Check if it is still a light weight lock, this is is true if we\n-      \/\/ see the stack address of the basicLock in the markWord of the\n-      \/\/ object.\n-\n-      __ cmpxchg(oop, box, disp_hdr, Assembler::xword, \/*acquire*\/ false,\n-                 \/*release*\/ true, \/*weak*\/ false, tmp);\n-      __ b(cont);\n-    } else {\n-      assert(LockingMode == LM_LIGHTWEIGHT, \"must be\");\n-      __ fast_unlock(oop, tmp, box, disp_hdr, no_count);\n-      __ b(count);\n-    }\n-\n-    assert(oopDesc::mark_offset_in_bytes() == 0, \"offset of _mark is not 0\");\n-\n-    \/\/ Handle existing monitor.\n-    __ bind(object_has_monitor);\n-    STATIC_ASSERT(markWord::monitor_value <= INT_MAX);\n-    __ add(tmp, tmp, -(int)markWord::monitor_value); \/\/ monitor\n-\n-    if (LockingMode == LM_LIGHTWEIGHT) {\n-      \/\/ If the owner is anonymous, we need to fix it -- in an outline stub.\n-      Register tmp2 = disp_hdr;\n-      __ ldr(tmp2, Address(tmp, ObjectMonitor::owner_offset()));\n-      \/\/ We cannot use tbnz here, the target might be too far away and cannot\n-      \/\/ be encoded.\n-      __ tst(tmp2, (uint64_t)ObjectMonitor::ANONYMOUS_OWNER);\n-      C2HandleAnonOMOwnerStub* stub = new (Compile::current()->comp_arena()) C2HandleAnonOMOwnerStub(tmp, tmp2);\n-      Compile::current()->output()->add_stub(stub);\n-      __ br(Assembler::NE, stub->entry());\n-      __ bind(stub->continuation());\n-    }\n-\n-    __ ldr(disp_hdr, Address(tmp, ObjectMonitor::recursions_offset()));\n-\n-    Label notRecursive;\n-    __ cbz(disp_hdr, notRecursive);\n-\n-    \/\/ Recursive lock\n-    __ sub(disp_hdr, disp_hdr, 1u);\n-    __ str(disp_hdr, Address(tmp, ObjectMonitor::recursions_offset()));\n-    __ cmp(disp_hdr, disp_hdr); \/\/ Sets flags for result\n-    __ b(cont);\n-\n-    __ bind(notRecursive);\n-    __ ldr(rscratch1, Address(tmp, ObjectMonitor::EntryList_offset()));\n-    __ ldr(disp_hdr, Address(tmp, ObjectMonitor::cxq_offset()));\n-    __ orr(rscratch1, rscratch1, disp_hdr); \/\/ Will be 0 if both are 0.\n-    __ cmp(rscratch1, zr); \/\/ Sets flags for result\n-    __ cbnz(rscratch1, cont);\n-    \/\/ need a release store here\n-    __ lea(tmp, Address(tmp, ObjectMonitor::owner_offset()));\n-    __ stlr(zr, tmp); \/\/ set unowned\n-\n-    __ bind(cont);\n-    \/\/ flag == EQ indicates success\n-    \/\/ flag == NE indicates failure\n-    __ br(Assembler::NE, no_count);\n-\n-    __ bind(count);\n-    __ decrement(Address(rthread, JavaThread::held_monitor_count_offset()));\n-\n-    __ bind(no_count);\n-  %}\n-\n@@ -16629,1 +16433,3 @@\n-  ins_encode(aarch64_enc_fast_lock(object, box, tmp, tmp2));\n+  ins_encode %{\n+    __ fast_lock($object$$Register, $box$$Register, $tmp$$Register, $tmp2$$Register);\n+  %}\n@@ -16642,1 +16448,3 @@\n-  ins_encode(aarch64_enc_fast_unlock(object, box, tmp, tmp2));\n+  ins_encode %{\n+    __ fast_unlock($object$$Register, $box$$Register, $tmp$$Register, $tmp2$$Register);\n+  %}\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":6,"deletions":198,"binary":false,"changes":204,"status":"modified"},{"patch":"@@ -86,1 +86,1 @@\n-    fast_lock(obj, hdr, rscratch1, rscratch2, slow_case);\n+    lightweight_lock(obj, hdr, rscratch1, rscratch2, slow_case);\n@@ -152,1 +152,1 @@\n-    fast_unlock(obj, hdr, rscratch1, rscratch2, slow_case);\n+    lightweight_unlock(obj, hdr, rscratch1, rscratch2, slow_case);\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_MacroAssembler_aarch64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -48,0 +48,196 @@\n+void C2_MacroAssembler::fast_lock(Register objectReg, Register boxReg, Register tmpReg,\n+                                  Register tmp2Reg) {\n+  Register oop = objectReg;\n+  Register box = boxReg;\n+  Register disp_hdr = tmpReg;\n+  Register tmp = tmp2Reg;\n+  Label cont;\n+  Label object_has_monitor;\n+  Label count, no_count;\n+\n+  assert_different_registers(oop, box, tmp, disp_hdr);\n+\n+  \/\/ Load markWord from object into displaced_header.\n+  ldr(disp_hdr, Address(oop, oopDesc::mark_offset_in_bytes()));\n+\n+  if (DiagnoseSyncOnValueBasedClasses != 0) {\n+    load_klass(tmp, oop);\n+    ldrw(tmp, Address(tmp, Klass::access_flags_offset()));\n+    tstw(tmp, JVM_ACC_IS_VALUE_BASED_CLASS);\n+    br(Assembler::NE, cont);\n+  }\n+\n+  \/\/ Check for existing monitor\n+  tbnz(disp_hdr, exact_log2(markWord::monitor_value), object_has_monitor);\n+\n+  if (LockingMode == LM_MONITOR) {\n+    tst(oop, oop); \/\/ Set NE to indicate 'failure' -> take slow-path. We know that oop != 0.\n+    b(cont);\n+  } else if (LockingMode == LM_LEGACY) {\n+    \/\/ Set tmp to be (markWord of object | UNLOCK_VALUE).\n+    orr(tmp, disp_hdr, markWord::unlocked_value);\n+\n+    \/\/ Initialize the box. (Must happen before we update the object mark!)\n+    str(tmp, Address(box, BasicLock::displaced_header_offset_in_bytes()));\n+\n+    \/\/ Compare object markWord with an unlocked value (tmp) and if\n+    \/\/ equal exchange the stack address of our box with object markWord.\n+    \/\/ On failure disp_hdr contains the possibly locked markWord.\n+    cmpxchg(oop, tmp, box, Assembler::xword, \/*acquire*\/ true,\n+            \/*release*\/ true, \/*weak*\/ false, disp_hdr);\n+    br(Assembler::EQ, cont);\n+\n+    assert(oopDesc::mark_offset_in_bytes() == 0, \"offset of _mark is not 0\");\n+\n+    \/\/ If the compare-and-exchange succeeded, then we found an unlocked\n+    \/\/ object, will have now locked it will continue at label cont\n+\n+    \/\/ Check if the owner is self by comparing the value in the\n+    \/\/ markWord of object (disp_hdr) with the stack pointer.\n+    mov(rscratch1, sp);\n+    sub(disp_hdr, disp_hdr, rscratch1);\n+    mov(tmp, (address) (~(os::vm_page_size()-1) | markWord::lock_mask_in_place));\n+    \/\/ If condition is true we are cont and hence we can store 0 as the\n+    \/\/ displaced header in the box, which indicates that it is a recursive lock.\n+    ands(tmp\/*==0?*\/, disp_hdr, tmp);   \/\/ Sets flags for result\n+    str(tmp\/*==0, perhaps*\/, Address(box, BasicLock::displaced_header_offset_in_bytes()));\n+    b(cont);\n+  } else {\n+    assert(LockingMode == LM_LIGHTWEIGHT, \"must be\");\n+    lightweight_lock(oop, disp_hdr, tmp, rscratch1, no_count);\n+    b(count);\n+  }\n+\n+  \/\/ Handle existing monitor.\n+  bind(object_has_monitor);\n+\n+  \/\/ The object's monitor m is unlocked iff m->owner == NULL,\n+  \/\/ otherwise m->owner may contain a thread or a stack address.\n+  \/\/\n+  \/\/ Try to CAS m->owner from NULL to current thread.\n+  add(tmp, disp_hdr, (in_bytes(ObjectMonitor::owner_offset())-markWord::monitor_value));\n+  cmpxchg(tmp, zr, rthread, Assembler::xword, \/*acquire*\/ true,\n+          \/*release*\/ true, \/*weak*\/ false, rscratch1); \/\/ Sets flags for result\n+\n+  if (LockingMode != LM_LIGHTWEIGHT) {\n+    \/\/ Store a non-null value into the box to avoid looking like a re-entrant\n+    \/\/ lock. The fast-path monitor unlock code checks for\n+    \/\/ markWord::monitor_value so use markWord::unused_mark which has the\n+    \/\/ relevant bit set, and also matches ObjectSynchronizer::enter.\n+    mov(tmp, (address)markWord::unused_mark().value());\n+    str(tmp, Address(box, BasicLock::displaced_header_offset_in_bytes()));\n+  }\n+  br(Assembler::EQ, cont); \/\/ CAS success means locking succeeded\n+\n+  cmp(rscratch1, rthread);\n+  br(Assembler::NE, cont); \/\/ Check for recursive locking\n+\n+  \/\/ Recursive lock case\n+  increment(Address(disp_hdr, in_bytes(ObjectMonitor::recursions_offset()) - markWord::monitor_value), 1);\n+  \/\/ flag == EQ still from the cmp above, checking if this is a reentrant lock\n+\n+  bind(cont);\n+  \/\/ flag == EQ indicates success\n+  \/\/ flag == NE indicates failure\n+  br(Assembler::NE, no_count);\n+\n+  bind(count);\n+  increment(Address(rthread, JavaThread::held_monitor_count_offset()));\n+\n+  bind(no_count);\n+}\n+\n+void C2_MacroAssembler::fast_unlock(Register objectReg, Register boxReg, Register tmpReg,\n+                                    Register tmp2Reg) {\n+  Register oop = objectReg;\n+  Register box = boxReg;\n+  Register disp_hdr = tmpReg;\n+  Register tmp = tmp2Reg;\n+  Label cont;\n+  Label object_has_monitor;\n+  Label count, no_count;\n+\n+  assert_different_registers(oop, box, tmp, disp_hdr);\n+\n+  if (LockingMode == LM_LEGACY) {\n+    \/\/ Find the lock address and load the displaced header from the stack.\n+    ldr(disp_hdr, Address(box, BasicLock::displaced_header_offset_in_bytes()));\n+\n+    \/\/ If the displaced header is 0, we have a recursive unlock.\n+    cmp(disp_hdr, zr);\n+    br(Assembler::EQ, cont);\n+  }\n+\n+  \/\/ Handle existing monitor.\n+  ldr(tmp, Address(oop, oopDesc::mark_offset_in_bytes()));\n+  tbnz(tmp, exact_log2(markWord::monitor_value), object_has_monitor);\n+\n+  if (LockingMode == LM_MONITOR) {\n+    tst(oop, oop); \/\/ Set NE to indicate 'failure' -> take slow-path. We know that oop != 0.\n+    b(cont);\n+  } else if (LockingMode == LM_LEGACY) {\n+    \/\/ Check if it is still a light weight lock, this is is true if we\n+    \/\/ see the stack address of the basicLock in the markWord of the\n+    \/\/ object.\n+\n+    cmpxchg(oop, box, disp_hdr, Assembler::xword, \/*acquire*\/ false,\n+            \/*release*\/ true, \/*weak*\/ false, tmp);\n+    b(cont);\n+  } else {\n+    assert(LockingMode == LM_LIGHTWEIGHT, \"must be\");\n+    lightweight_unlock(oop, tmp, box, disp_hdr, no_count);\n+    b(count);\n+  }\n+\n+  assert(oopDesc::mark_offset_in_bytes() == 0, \"offset of _mark is not 0\");\n+\n+  \/\/ Handle existing monitor.\n+  bind(object_has_monitor);\n+  STATIC_ASSERT(markWord::monitor_value <= INT_MAX);\n+  add(tmp, tmp, -(int)markWord::monitor_value); \/\/ monitor\n+\n+  if (LockingMode == LM_LIGHTWEIGHT) {\n+    \/\/ If the owner is anonymous, we need to fix it -- in an outline stub.\n+    Register tmp2 = disp_hdr;\n+    ldr(tmp2, Address(tmp, ObjectMonitor::owner_offset()));\n+    \/\/ We cannot use tbnz here, the target might be too far away and cannot\n+    \/\/ be encoded.\n+    tst(tmp2, (uint64_t)ObjectMonitor::ANONYMOUS_OWNER);\n+    C2HandleAnonOMOwnerStub* stub = new (Compile::current()->comp_arena()) C2HandleAnonOMOwnerStub(tmp, tmp2);\n+    Compile::current()->output()->add_stub(stub);\n+    br(Assembler::NE, stub->entry());\n+    bind(stub->continuation());\n+  }\n+\n+  ldr(disp_hdr, Address(tmp, ObjectMonitor::recursions_offset()));\n+\n+  Label notRecursive;\n+  cbz(disp_hdr, notRecursive);\n+\n+  \/\/ Recursive lock\n+  sub(disp_hdr, disp_hdr, 1u);\n+  str(disp_hdr, Address(tmp, ObjectMonitor::recursions_offset()));\n+  cmp(disp_hdr, disp_hdr); \/\/ Sets flags for result\n+  b(cont);\n+\n+  bind(notRecursive);\n+  ldr(rscratch1, Address(tmp, ObjectMonitor::EntryList_offset()));\n+  ldr(disp_hdr, Address(tmp, ObjectMonitor::cxq_offset()));\n+  orr(rscratch1, rscratch1, disp_hdr); \/\/ Will be 0 if both are 0.\n+  cmp(rscratch1, zr); \/\/ Sets flags for result\n+  cbnz(rscratch1, cont);\n+  \/\/ need a release store here\n+  lea(tmp, Address(tmp, ObjectMonitor::owner_offset()));\n+  stlr(zr, tmp); \/\/ set unowned\n+\n+  bind(cont);\n+  \/\/ flag == EQ indicates success\n+  \/\/ flag == NE indicates failure\n+  br(Assembler::NE, no_count);\n+\n+  bind(count);\n+  decrement(Address(rthread, JavaThread::held_monitor_count_offset()));\n+\n+  bind(no_count);\n+}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.cpp","additions":196,"deletions":0,"binary":false,"changes":196,"status":"modified"},{"patch":"@@ -38,0 +38,5 @@\n+  \/\/ Code used by cmpFastLock and cmpFastUnlock mach instructions in .ad file.\n+  \/\/ See full description in macroAssembler_aarch64.cpp.\n+  void fast_lock(Register object, Register box, Register tmp, Register tmp2);\n+  void fast_unlock(Register object, Register box, Register tmp, Register tmp2);\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -770,1 +770,1 @@\n-      fast_lock(obj_reg, tmp, rscratch1, rscratch2, slow_case);\n+      lightweight_lock(obj_reg, tmp, rscratch1, rscratch2, slow_case);\n@@ -901,1 +901,1 @@\n-      fast_unlock(obj_reg, header_reg, swap_reg, rscratch1, slow_case);\n+      lightweight_unlock(obj_reg, header_reg, swap_reg, rscratch1, slow_case);\n","filename":"src\/hotspot\/cpu\/aarch64\/interp_masm_aarch64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -6317,1 +6317,1 @@\n-\/\/ Implements fast-locking.\n+\/\/ Implements lightweight-locking.\n@@ -6324,1 +6324,1 @@\n-void MacroAssembler::fast_lock(Register obj, Register hdr, Register t1, Register t2, Label& slow) {\n+void MacroAssembler::lightweight_lock(Register obj, Register hdr, Register t1, Register t2, Label& slow) {\n@@ -6349,1 +6349,1 @@\n-\/\/ Implements fast-unlocking.\n+\/\/ Implements lightweight-unlocking.\n@@ -6356,1 +6356,1 @@\n-void MacroAssembler::fast_unlock(Register obj, Register hdr, Register t1, Register t2, Label& slow) {\n+void MacroAssembler::lightweight_unlock(Register obj, Register hdr, Register t1, Register t2, Label& slow) {\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1595,2 +1595,2 @@\n-  void fast_lock(Register obj, Register hdr, Register t1, Register t2, Label& slow);\n-  void fast_unlock(Register obj, Register hdr, Register t1, Register t2, Label& slow);\n+  void lightweight_lock(Register obj, Register hdr, Register t1, Register t2, Label& slow);\n+  void lightweight_unlock(Register obj, Register hdr, Register t1, Register t2, Label& slow);\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1815,1 +1815,1 @@\n-      __ fast_lock(obj_reg, swap_reg, tmp, rscratch1, slow_path_lock);\n+      __ lightweight_lock(obj_reg, swap_reg, tmp, rscratch1, slow_path_lock);\n@@ -1956,1 +1956,1 @@\n-      __ fast_unlock(obj_reg, old_hdr, swap_reg, rscratch1, slow_path_unlock);\n+      __ lightweight_unlock(obj_reg, old_hdr, swap_reg, rscratch1, slow_path_unlock);\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -222,1 +222,1 @@\n-    fast_lock_2(obj \/* obj *\/, t1, t2, t3, 1 \/* savemask - save t1 *\/, slow_case);\n+    lightweight_lock(obj \/* obj *\/, t1, t2, t3, 1 \/* savemask - save t1 *\/, slow_case);\n@@ -285,2 +285,2 @@\n-    fast_unlock_2(obj \/* object *\/, t1, t2, t3, 1 \/* savemask (save t1) *\/,\n-                    slow_case);\n+    lightweight_unlock(obj \/* object *\/, t1, t2, t3, 1 \/* savemask (save t1) *\/,\n+                       slow_case);\n","filename":"src\/hotspot\/cpu\/arm\/c1_MacroAssembler_arm.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -96,2 +96,2 @@\n-    fast_lock_2(Roop \/* obj *\/, Rbox \/* t1 *\/, Rscratch \/* t2 *\/, Rscratch2 \/* t3 *\/,\n-                1 \/* savemask (save t1) *\/, done);\n+    lightweight_lock(Roop \/* obj *\/, Rbox \/* t1 *\/, Rscratch \/* t2 *\/, Rscratch2 \/* t3 *\/,\n+                     1 \/* savemask (save t1) *\/, done);\n@@ -146,2 +146,2 @@\n-    fast_unlock_2(Roop \/* obj *\/, Rbox \/* t1 *\/, Rscratch \/* t2 *\/, Rscratch2 \/* t3 *\/,\n-                  1 \/* savemask (save t1) *\/, done);\n+    lightweight_unlock(Roop \/* obj *\/, Rbox \/* t1 *\/, Rscratch \/* t2 *\/, Rscratch2 \/* t3 *\/,\n+                       1 \/* savemask (save t1) *\/, done);\n","filename":"src\/hotspot\/cpu\/arm\/c2_MacroAssembler_arm.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -915,1 +915,1 @@\n-      fast_lock_2(Robj, R0 \/* t1 *\/, Rmark \/* t2 *\/, Rtemp \/* t3 *\/, 0 \/* savemask *\/, slow_case);\n+      lightweight_lock(Robj, R0 \/* t1 *\/, Rmark \/* t2 *\/, Rtemp \/* t3 *\/, 0 \/* savemask *\/, slow_case);\n@@ -1037,2 +1037,2 @@\n-      fast_unlock_2(Robj \/* obj *\/, Rlock \/* t1 *\/, Rmark \/* t2 *\/, Rtemp \/* t3 *\/,\n-                    1 \/* savemask (save t1) *\/, slow_case);\n+      lightweight_unlock(Robj \/* obj *\/, Rlock \/* t1 *\/, Rmark \/* t2 *\/, Rtemp \/* t3 *\/,\n+                         1 \/* savemask (save t1) *\/, slow_case);\n","filename":"src\/hotspot\/cpu\/arm\/interp_masm_arm.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1751,1 +1751,1 @@\n-\/\/ Attempt to fast-lock an object\n+\/\/ Attempt to lightweight-lock an object\n@@ -1758,1 +1758,1 @@\n-void MacroAssembler::fast_lock_2(Register obj, Register t1, Register t2, Register t3, unsigned savemask, Label& slow) {\n+void MacroAssembler::lightweight_lock(Register obj, Register t1, Register t2, Register t3, unsigned savemask, Label& slow) {\n@@ -1809,1 +1809,1 @@\n-\/\/ Attempt to fast-unlock an object\n+\/\/ Attempt to lightweight-unlock an object\n@@ -1816,1 +1816,1 @@\n-void MacroAssembler::fast_unlock_2(Register obj, Register t1, Register t2, Register t3, unsigned savemask, Label& slow) {\n+void MacroAssembler::lightweight_unlock(Register obj, Register t1, Register t2, Register t3, unsigned savemask, Label& slow) {\n","filename":"src\/hotspot\/cpu\/arm\/macroAssembler_arm.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1012,1 +1012,1 @@\n-  \/\/ Attempt to fast-lock an object\n+  \/\/ Attempt to lightweight-lock an object\n@@ -1019,1 +1019,1 @@\n-  void fast_lock_2(Register obj, Register t1, Register t2, Register t3, unsigned savemask, Label& slow);\n+  void lightweight_lock(Register obj, Register t1, Register t2, Register t3, unsigned savemask, Label& slow);\n@@ -1021,1 +1021,1 @@\n-  \/\/ Attempt to fast-unlock an object\n+  \/\/ Attempt to lightweight-unlock an object\n@@ -1028,1 +1028,1 @@\n-  void fast_unlock_2(Register obj, Register t1, Register t2, Register t3, unsigned savemask, Label& slow);\n+  void lightweight_unlock(Register obj, Register t1, Register t2, Register t3, unsigned savemask, Label& slow);\n","filename":"src\/hotspot\/cpu\/arm\/macroAssembler_arm.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1158,2 +1158,2 @@\n-      __ fast_lock_2(sync_obj \/* object *\/, disp_hdr \/* t1 *\/, tmp \/* t2 *\/, Rtemp \/* t3 *\/,\n-                     0x7 \/* savemask *\/, slow_lock);\n+      __ lightweight_lock(sync_obj \/* object *\/, disp_hdr \/* t1 *\/, tmp \/* t2 *\/, Rtemp \/* t3 *\/,\n+                          0x7 \/* savemask *\/, slow_lock);\n@@ -1245,2 +1245,2 @@\n-      __ fast_unlock_2(sync_obj, R2 \/* t1 *\/, tmp \/* t2 *\/, Rtemp \/* t3 *\/,\n-                       7 \/* savemask *\/, slow_unlock);\n+      __ lightweight_unlock(sync_obj, R2 \/* t1 *\/, tmp \/* t2 *\/, Rtemp \/* t3 *\/,\n+                            7 \/* savemask *\/, slow_unlock);\n","filename":"src\/hotspot\/cpu\/arm\/sharedRuntime_arm.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -118,1 +118,1 @@\n-    fast_lock(Roop, Rmark, Rscratch, slow_int);\n+    lightweight_lock(Roop, Rmark, Rscratch, slow_int);\n@@ -184,1 +184,1 @@\n-    fast_unlock(Roop, Rmark, slow_int);\n+    lightweight_unlock(Roop, Rmark, slow_int);\n","filename":"src\/hotspot\/cpu\/ppc\/c1_MacroAssembler_ppc.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -990,1 +990,1 @@\n-      fast_lock(object, \/* mark word *\/ header, tmp, slow_case);\n+      lightweight_lock(object, \/* mark word *\/ header, tmp, slow_case);\n@@ -1140,1 +1140,1 @@\n-      fast_unlock(object, header, slow_case);\n+      lightweight_unlock(object, header, slow_case);\n","filename":"src\/hotspot\/cpu\/ppc\/interp_masm_ppc_64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2253,1 +2253,1 @@\n-    fast_lock(oop, displaced_header, temp, failure);\n+    lightweight_lock(oop, displaced_header, temp, failure);\n@@ -2337,1 +2337,1 @@\n-    fast_unlock(oop, current_header, failure);\n+    lightweight_unlock(oop, current_header, failure);\n@@ -3996,1 +3996,1 @@\n-\/\/ Implements fast-locking.\n+\/\/ Implements lightweight-locking.\n@@ -4003,1 +4003,1 @@\n-void MacroAssembler::fast_lock(Register obj, Register hdr, Register t1, Label& slow) {\n+void MacroAssembler::lightweight_lock(Register obj, Register hdr, Register t1, Label& slow) {\n@@ -4029,1 +4029,1 @@\n-\/\/ Implements fast-unlocking.\n+\/\/ Implements lightweight-unlocking.\n@@ -4035,1 +4035,1 @@\n-void MacroAssembler::fast_unlock(Register obj, Register hdr, Label& slow) {\n+void MacroAssembler::lightweight_unlock(Register obj, Register hdr, Label& slow) {\n","filename":"src\/hotspot\/cpu\/ppc\/macroAssembler_ppc.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -609,2 +609,2 @@\n-  void fast_lock(Register obj, Register hdr, Register t1, Label& slow);\n-  void fast_unlock(Register obj, Register hdr, Label& slow);\n+  void lightweight_lock(Register obj, Register hdr, Register t1, Label& slow);\n+  void lightweight_unlock(Register obj, Register hdr, Label& slow);\n","filename":"src\/hotspot\/cpu\/ppc\/macroAssembler_ppc.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -76,1 +76,1 @@\n-    fast_lock(obj, hdr, t0, t1, slow_case);\n+    lightweight_lock(obj, hdr, t0, t1, slow_case);\n@@ -140,1 +140,1 @@\n-    fast_unlock(obj, hdr, t0, t1, slow_case);\n+    lightweight_unlock(obj, hdr, t0, t1, slow_case);\n","filename":"src\/hotspot\/cpu\/riscv\/c1_MacroAssembler_riscv.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -46,0 +46,217 @@\n+void C2_MacroAssembler::fast_lock(Register objectReg, Register boxReg, Register tmp1Reg,\n+                                  Register tmp2Reg) {\n+  \/\/ Use cr register to indicate the fast_lock result: zero for success; non-zero for failure.\n+  Register flag = t1;\n+  Register oop = objectReg;\n+  Register box = boxReg;\n+  Register disp_hdr = tmp1Reg;\n+  Register tmp = tmp2Reg;\n+  Label cont;\n+  Label object_has_monitor;\n+  Label count, no_count;\n+\n+  assert_different_registers(oop, box, tmp, disp_hdr, t0);\n+\n+  \/\/ Load markWord from object into displaced_header.\n+  ld(disp_hdr, Address(oop, oopDesc::mark_offset_in_bytes()));\n+\n+  if (DiagnoseSyncOnValueBasedClasses != 0) {\n+    load_klass(flag, oop);\n+    lwu(flag, Address(flag, Klass::access_flags_offset()));\n+    test_bit(flag, flag, exact_log2(JVM_ACC_IS_VALUE_BASED_CLASS), tmp \/* tmp *\/);\n+    bnez(flag, cont, true \/* is_far *\/);\n+  }\n+\n+  \/\/ Check for existing monitor\n+  test_bit(t0, disp_hdr, exact_log2(markWord::monitor_value));\n+  bnez(t0, object_has_monitor);\n+\n+  if (LockingMode == LM_MONITOR) {\n+    mv(flag, 1); \/\/ Set non-zero flag to indicate 'failure' -> take slow-path\n+    j(cont);\n+  } else if (LockingMode == LM_LEGACY) {\n+    \/\/ Set tmp to be (markWord of object | UNLOCK_VALUE).\n+    ori(tmp, disp_hdr, markWord::unlocked_value);\n+\n+    \/\/ Initialize the box. (Must happen before we update the object mark!)\n+    sd(tmp, Address(box, BasicLock::displaced_header_offset_in_bytes()));\n+\n+    \/\/ Compare object markWord with an unlocked value (tmp) and if\n+    \/\/ equal exchange the stack address of our box with object markWord.\n+    \/\/ On failure disp_hdr contains the possibly locked markWord.\n+    cmpxchg(\/*memory address*\/oop, \/*expected value*\/tmp, \/*new value*\/box, Assembler::int64, Assembler::aq,\n+            Assembler::rl, \/*result*\/disp_hdr);\n+    mv(flag, zr);\n+    beq(disp_hdr, tmp, cont); \/\/ prepare zero flag and goto cont if we won the cas\n+\n+    assert(oopDesc::mark_offset_in_bytes() == 0, \"offset of _mark is not 0\");\n+\n+    \/\/ If the compare-and-exchange succeeded, then we found an unlocked\n+    \/\/ object, will have now locked it will continue at label cont\n+    \/\/ We did not see an unlocked object so try the fast recursive case.\n+\n+    \/\/ Check if the owner is self by comparing the value in the\n+    \/\/ markWord of object (disp_hdr) with the stack pointer.\n+    sub(disp_hdr, disp_hdr, sp);\n+    mv(tmp, (intptr_t) (~(os::vm_page_size()-1) | (uintptr_t)markWord::lock_mask_in_place));\n+    \/\/ If (mark & lock_mask) == 0 and mark - sp < page_size, we are stack-locking and goto cont,\n+    \/\/ hence we can store 0 as the displaced header in the box, which indicates that it is a\n+    \/\/ recursive lock.\n+    andr(tmp\/*==0?*\/, disp_hdr, tmp);\n+    sd(tmp\/*==0, perhaps*\/, Address(box, BasicLock::displaced_header_offset_in_bytes()));\n+    mv(flag, tmp); \/\/ we can use the value of tmp as the result here\n+    j(cont);\n+  } else {\n+    assert(LockingMode == LM_LIGHTWEIGHT, \"\");\n+    Label slow;\n+    lightweight_lock(oop, disp_hdr, tmp, t0, slow);\n+\n+    \/\/ Indicate success on completion.\n+    mv(flag, zr);\n+    j(count);\n+    bind(slow);\n+    mv(flag, 1); \/\/ Set non-zero flag to indicate 'failure' -> take slow-path\n+    j(no_count);\n+  }\n+\n+  \/\/ Handle existing monitor.\n+  bind(object_has_monitor);\n+  \/\/ The object's monitor m is unlocked iff m->owner == NULL,\n+  \/\/ otherwise m->owner may contain a thread or a stack address.\n+  \/\/\n+  \/\/ Try to CAS m->owner from NULL to current thread.\n+  add(tmp, disp_hdr, (in_bytes(ObjectMonitor::owner_offset()) - markWord::monitor_value));\n+  cmpxchg(\/*memory address*\/tmp, \/*expected value*\/zr, \/*new value*\/xthread, Assembler::int64, Assembler::aq,\n+          Assembler::rl, \/*result*\/flag); \/\/ cas succeeds if flag == zr(expected)\n+\n+  if (LockingMode != LM_LIGHTWEIGHT) {\n+    \/\/ Store a non-null value into the box to avoid looking like a re-entrant\n+    \/\/ lock. The fast-path monitor unlock code checks for\n+    \/\/ markWord::monitor_value so use markWord::unused_mark which has the\n+    \/\/ relevant bit set, and also matches ObjectSynchronizer::slow_enter.\n+    mv(tmp, (address)markWord::unused_mark().value());\n+    sd(tmp, Address(box, BasicLock::displaced_header_offset_in_bytes()));\n+  }\n+\n+  beqz(flag, cont); \/\/ CAS success means locking succeeded\n+\n+  bne(flag, xthread, cont); \/\/ Check for recursive locking\n+\n+  \/\/ Recursive lock case\n+  mv(flag, zr);\n+  increment(Address(disp_hdr, in_bytes(ObjectMonitor::recursions_offset()) - markWord::monitor_value), 1, t0, tmp);\n+\n+  bind(cont);\n+  \/\/ zero flag indicates success\n+  \/\/ non-zero flag indicates failure\n+  bnez(flag, no_count);\n+\n+  bind(count);\n+  increment(Address(xthread, JavaThread::held_monitor_count_offset()), 1, t0, tmp);\n+\n+  bind(no_count);\n+}\n+\n+void C2_MacroAssembler::fast_unlock(Register objectReg, Register boxReg, Register tmp1Reg,\n+                                    Register tmp2Reg) {\n+  \/\/ Use cr register to indicate the fast_unlock result: zero for success; non-zero for failure.\n+  Register flag = t1;\n+  Register oop = objectReg;\n+  Register box = boxReg;\n+  Register disp_hdr = tmp1Reg;\n+  Register tmp = tmp2Reg;\n+  Label cont;\n+  Label object_has_monitor;\n+  Label count, no_count;\n+\n+  assert_different_registers(oop, box, tmp, disp_hdr, flag);\n+\n+  if (LockingMode == LM_LEGACY) {\n+    \/\/ Find the lock address and load the displaced header from the stack.\n+    ld(disp_hdr, Address(box, BasicLock::displaced_header_offset_in_bytes()));\n+\n+    \/\/ If the displaced header is 0, we have a recursive unlock.\n+    mv(flag, disp_hdr);\n+    beqz(disp_hdr, cont);\n+  }\n+\n+  \/\/ Handle existing monitor.\n+  ld(tmp, Address(oop, oopDesc::mark_offset_in_bytes()));\n+  test_bit(t0, tmp, exact_log2(markWord::monitor_value));\n+  bnez(t0, object_has_monitor);\n+\n+  if (LockingMode == LM_MONITOR) {\n+    mv(flag, 1); \/\/ Set non-zero flag to indicate 'failure' -> take slow path\n+    j(cont);\n+  } else if (LockingMode == LM_LEGACY) {\n+    \/\/ Check if it is still a light weight lock, this is true if we\n+    \/\/ see the stack address of the basicLock in the markWord of the\n+    \/\/ object.\n+\n+    cmpxchg(\/*memory address*\/oop, \/*expected value*\/box, \/*new value*\/disp_hdr, Assembler::int64, Assembler::relaxed,\n+            Assembler::rl, \/*result*\/tmp);\n+    xorr(flag, box, tmp); \/\/ box == tmp if cas succeeds\n+    j(cont);\n+  } else {\n+    assert(LockingMode == LM_LIGHTWEIGHT, \"\");\n+    Label slow;\n+    lightweight_unlock(oop, tmp, box, disp_hdr, slow);\n+\n+    \/\/ Indicate success on completion.\n+    mv(flag, zr);\n+    j(count);\n+    bind(slow);\n+    mv(flag, 1); \/\/ Set non-zero flag to indicate 'failure' -> take slow path\n+    j(no_count);\n+  }\n+\n+  assert(oopDesc::mark_offset_in_bytes() == 0, \"offset of _mark is not 0\");\n+\n+  \/\/ Handle existing monitor.\n+  bind(object_has_monitor);\n+  STATIC_ASSERT(markWord::monitor_value <= INT_MAX);\n+  add(tmp, tmp, -(int)markWord::monitor_value); \/\/ monitor\n+\n+  if (LockingMode == LM_LIGHTWEIGHT) {\n+    \/\/ If the owner is anonymous, we need to fix it -- in an outline stub.\n+    Register tmp2 = disp_hdr;\n+    ld(tmp2, Address(tmp, ObjectMonitor::owner_offset()));\n+    test_bit(t0, tmp2, exact_log2(ObjectMonitor::ANONYMOUS_OWNER));\n+    C2HandleAnonOMOwnerStub* stub = new (Compile::current()->comp_arena()) C2HandleAnonOMOwnerStub(tmp, tmp2);\n+    Compile::current()->output()->add_stub(stub);\n+    bnez(t0, stub->entry(), \/* is_far *\/ true);\n+    bind(stub->continuation());\n+  }\n+\n+  ld(disp_hdr, Address(tmp, ObjectMonitor::recursions_offset()));\n+\n+  Label notRecursive;\n+  beqz(disp_hdr, notRecursive); \/\/ Will be 0 if not recursive.\n+\n+  \/\/ Recursive lock\n+  addi(disp_hdr, disp_hdr, -1);\n+  sd(disp_hdr, Address(tmp, ObjectMonitor::recursions_offset()));\n+  mv(flag, zr);\n+  j(cont);\n+\n+  bind(notRecursive);\n+  ld(flag, Address(tmp, ObjectMonitor::EntryList_offset()));\n+  ld(disp_hdr, Address(tmp, ObjectMonitor::cxq_offset()));\n+  orr(flag, flag, disp_hdr); \/\/ Will be 0 if both are 0.\n+  bnez(flag, cont);\n+  \/\/ need a release store here\n+  la(tmp, Address(tmp, ObjectMonitor::owner_offset()));\n+  membar(MacroAssembler::LoadStore | MacroAssembler::StoreStore);\n+  sd(zr, Address(tmp)); \/\/ set unowned\n+\n+  bind(cont);\n+  \/\/ zero flag indicates success\n+  \/\/ non-zero flag indicates failure\n+  bnez(flag, no_count);\n+\n+  bind(count);\n+  decrement(Address(xthread, JavaThread::held_monitor_count_offset()), 1, t0, tmp);\n+\n+  bind(no_count);\n+}\n+\n","filename":"src\/hotspot\/cpu\/riscv\/c2_MacroAssembler_riscv.cpp","additions":217,"deletions":0,"binary":false,"changes":217,"status":"modified"},{"patch":"@@ -42,0 +42,5 @@\n+  \/\/ Code used by cmpFastLock and cmpFastUnlock mach instructions in .ad file.\n+  \/\/ See full description in macroAssembler_riscv.cpp.\n+  void fast_lock(Register object, Register box, Register tmp1, Register tmp2);\n+  void fast_unlock(Register object, Register box, Register tmp1, Register tmp2);\n+\n","filename":"src\/hotspot\/cpu\/riscv\/c2_MacroAssembler_riscv.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -839,1 +839,1 @@\n-      fast_lock(obj_reg, tmp, t0, t1, slow_case);\n+      lightweight_lock(obj_reg, tmp, t0, t1, slow_case);\n@@ -952,1 +952,1 @@\n-      fast_unlock(obj_reg, header_reg, swap_reg, t0, slow_case);\n+      lightweight_unlock(obj_reg, header_reg, swap_reg, t0, slow_case);\n","filename":"src\/hotspot\/cpu\/riscv\/interp_masm_riscv.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -4648,1 +4648,1 @@\n-\/\/ Implements fast-locking.\n+\/\/ Implements lightweight-locking.\n@@ -4655,1 +4655,1 @@\n-void MacroAssembler::fast_lock(Register obj, Register hdr, Register tmp1, Register tmp2, Label& slow) {\n+void MacroAssembler::lightweight_lock(Register obj, Register hdr, Register tmp1, Register tmp2, Label& slow) {\n@@ -4682,1 +4682,1 @@\n-\/\/ Implements fast-unlocking.\n+\/\/ Implements ligthweight-unlocking.\n@@ -4689,1 +4689,1 @@\n-void MacroAssembler::fast_unlock(Register obj, Register hdr, Register tmp1, Register tmp2, Label& slow) {\n+void MacroAssembler::lightweight_unlock(Register obj, Register hdr, Register tmp1, Register tmp2, Label& slow) {\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1460,2 +1460,2 @@\n-  void fast_lock(Register obj, Register hdr, Register tmp1, Register tmp2, Label& slow);\n-  void fast_unlock(Register obj, Register hdr, Register tmp1, Register tmp2, Label& slow);\n+  void lightweight_lock(Register obj, Register hdr, Register tmp1, Register tmp2, Label& slow);\n+  void lightweight_unlock(Register obj, Register hdr, Register tmp1, Register tmp2, Label& slow);\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2439,217 +2439,0 @@\n-  \/\/ Use cr register to indicate the fast_lock result: zero for success; non-zero for failure.\n-  enc_class riscv_enc_fast_lock(iRegP object, iRegP box, iRegPNoSp tmp1, iRegPNoSp tmp2) %{\n-    C2_MacroAssembler _masm(&cbuf);\n-    Register flag = t1;\n-    Register oop = as_Register($object$$reg);\n-    Register box = as_Register($box$$reg);\n-    Register disp_hdr = as_Register($tmp1$$reg);\n-    Register tmp = as_Register($tmp2$$reg);\n-    Label cont;\n-    Label object_has_monitor;\n-    Label count, no_count;\n-\n-    assert_different_registers(oop, box, tmp, disp_hdr, t0);\n-\n-    \/\/ Load markWord from object into displaced_header.\n-    __ ld(disp_hdr, Address(oop, oopDesc::mark_offset_in_bytes()));\n-\n-    if (DiagnoseSyncOnValueBasedClasses != 0) {\n-      __ load_klass(flag, oop);\n-      __ lwu(flag, Address(flag, Klass::access_flags_offset()));\n-      __ test_bit(flag, flag, exact_log2(JVM_ACC_IS_VALUE_BASED_CLASS), tmp \/* tmp *\/);\n-      __ bnez(flag, cont, true \/* is_far *\/);\n-    }\n-\n-    \/\/ Check for existing monitor\n-    __ test_bit(t0, disp_hdr, exact_log2(markWord::monitor_value));\n-    __ bnez(t0, object_has_monitor);\n-\n-    if (LockingMode == LM_MONITOR) {\n-      __ mv(flag, 1); \/\/ Set non-zero flag to indicate 'failure' -> take slow-path\n-      __ j(cont);\n-    } else if (LockingMode == LM_LEGACY) {\n-      \/\/ Set tmp to be (markWord of object | UNLOCK_VALUE).\n-      __ ori(tmp, disp_hdr, markWord::unlocked_value);\n-\n-      \/\/ Initialize the box. (Must happen before we update the object mark!)\n-      __ sd(tmp, Address(box, BasicLock::displaced_header_offset_in_bytes()));\n-\n-      \/\/ Compare object markWord with an unlocked value (tmp) and if\n-      \/\/ equal exchange the stack address of our box with object markWord.\n-      \/\/ On failure disp_hdr contains the possibly locked markWord.\n-      __ cmpxchg(\/*memory address*\/oop, \/*expected value*\/tmp, \/*new value*\/box, Assembler::int64, Assembler::aq,\n-                 Assembler::rl, \/*result*\/disp_hdr);\n-      __ mv(flag, zr);\n-      __ beq(disp_hdr, tmp, cont); \/\/ prepare zero flag and goto cont if we won the cas\n-\n-      assert(oopDesc::mark_offset_in_bytes() == 0, \"offset of _mark is not 0\");\n-\n-      \/\/ If the compare-and-exchange succeeded, then we found an unlocked\n-      \/\/ object, will have now locked it will continue at label cont\n-      \/\/ We did not see an unlocked object so try the fast recursive case.\n-\n-      \/\/ Check if the owner is self by comparing the value in the\n-      \/\/ markWord of object (disp_hdr) with the stack pointer.\n-      __ sub(disp_hdr, disp_hdr, sp);\n-      __ mv(tmp, (intptr_t) (~(os::vm_page_size()-1) | (uintptr_t)markWord::lock_mask_in_place));\n-      \/\/ If (mark & lock_mask) == 0 and mark - sp < page_size, we are stack-locking and goto cont,\n-      \/\/ hence we can store 0 as the displaced header in the box, which indicates that it is a\n-      \/\/ recursive lock.\n-      __ andr(tmp\/*==0?*\/, disp_hdr, tmp);\n-      __ sd(tmp\/*==0, perhaps*\/, Address(box, BasicLock::displaced_header_offset_in_bytes()));\n-      __ mv(flag, tmp); \/\/ we can use the value of tmp as the result here\n-      __ j(cont);\n-    } else {\n-      assert(LockingMode == LM_LIGHTWEIGHT, \"\");\n-      Label slow;\n-      __ fast_lock(oop, disp_hdr, tmp, t0, slow);\n-\n-      \/\/ Indicate success on completion.\n-      __ mv(flag, zr);\n-      __ j(count);\n-      __ bind(slow);\n-      __ mv(flag, 1); \/\/ Set non-zero flag to indicate 'failure' -> take slow-path\n-      __ j(no_count);\n-    }\n-\n-    \/\/ Handle existing monitor.\n-    __ bind(object_has_monitor);\n-    \/\/ The object's monitor m is unlocked iff m->owner == NULL,\n-    \/\/ otherwise m->owner may contain a thread or a stack address.\n-    \/\/\n-    \/\/ Try to CAS m->owner from NULL to current thread.\n-    __ add(tmp, disp_hdr, (in_bytes(ObjectMonitor::owner_offset()) - markWord::monitor_value));\n-    __ cmpxchg(\/*memory address*\/tmp, \/*expected value*\/zr, \/*new value*\/xthread, Assembler::int64, Assembler::aq,\n-             Assembler::rl, \/*result*\/flag); \/\/ cas succeeds if flag == zr(expected)\n-\n-    if (LockingMode != LM_LIGHTWEIGHT) {\n-      \/\/ Store a non-null value into the box to avoid looking like a re-entrant\n-      \/\/ lock. The fast-path monitor unlock code checks for\n-      \/\/ markWord::monitor_value so use markWord::unused_mark which has the\n-      \/\/ relevant bit set, and also matches ObjectSynchronizer::slow_enter.\n-      __ mv(tmp, (address)markWord::unused_mark().value());\n-      __ sd(tmp, Address(box, BasicLock::displaced_header_offset_in_bytes()));\n-    }\n-\n-    __ beqz(flag, cont); \/\/ CAS success means locking succeeded\n-\n-    __ bne(flag, xthread, cont); \/\/ Check for recursive locking\n-\n-    \/\/ Recursive lock case\n-    __ mv(flag, zr);\n-    __ increment(Address(disp_hdr, in_bytes(ObjectMonitor::recursions_offset()) - markWord::monitor_value), 1, t0, tmp);\n-\n-    __ bind(cont);\n-    \/\/ zero flag indicates success\n-    \/\/ non-zero flag indicates failure\n-    __ bnez(flag, no_count);\n-\n-    __ bind(count);\n-    __ increment(Address(xthread, JavaThread::held_monitor_count_offset()), 1, t0, tmp);\n-\n-    __ bind(no_count);\n-  %}\n-\n-  \/\/ Use cr register to indicate the fast_unlock result: zero for success; non-zero for failure.\n-  enc_class riscv_enc_fast_unlock(iRegP object, iRegP box, iRegPNoSp tmp1, iRegPNoSp tmp2) %{\n-    C2_MacroAssembler _masm(&cbuf);\n-    Register flag = t1;\n-    Register oop = as_Register($object$$reg);\n-    Register box = as_Register($box$$reg);\n-    Register disp_hdr = as_Register($tmp1$$reg);\n-    Register tmp = as_Register($tmp2$$reg);\n-    Label cont;\n-    Label object_has_monitor;\n-    Label count, no_count;\n-\n-    assert_different_registers(oop, box, tmp, disp_hdr, flag);\n-\n-    if (LockingMode == LM_LEGACY) {\n-      \/\/ Find the lock address and load the displaced header from the stack.\n-      __ ld(disp_hdr, Address(box, BasicLock::displaced_header_offset_in_bytes()));\n-\n-      \/\/ If the displaced header is 0, we have a recursive unlock.\n-      __ mv(flag, disp_hdr);\n-      __ beqz(disp_hdr, cont);\n-    }\n-\n-    \/\/ Handle existing monitor.\n-    __ ld(tmp, Address(oop, oopDesc::mark_offset_in_bytes()));\n-    __ test_bit(t0, tmp, exact_log2(markWord::monitor_value));\n-    __ bnez(t0, object_has_monitor);\n-\n-    if (LockingMode == LM_MONITOR) {\n-      __ mv(flag, 1); \/\/ Set non-zero flag to indicate 'failure' -> take slow path\n-      __ j(cont);\n-    } else if (LockingMode == LM_LEGACY) {\n-      \/\/ Check if it is still a light weight lock, this is true if we\n-      \/\/ see the stack address of the basicLock in the markWord of the\n-      \/\/ object.\n-\n-      __ cmpxchg(\/*memory address*\/oop, \/*expected value*\/box, \/*new value*\/disp_hdr, Assembler::int64, Assembler::relaxed,\n-                 Assembler::rl, \/*result*\/tmp);\n-      __ xorr(flag, box, tmp); \/\/ box == tmp if cas succeeds\n-      __ j(cont);\n-    } else {\n-      assert(LockingMode == LM_LIGHTWEIGHT, \"\");\n-      Label slow;\n-      __ fast_unlock(oop, tmp, box, disp_hdr, slow);\n-\n-      \/\/ Indicate success on completion.\n-      __ mv(flag, zr);\n-      __ j(count);\n-      __ bind(slow);\n-      __ mv(flag, 1); \/\/ Set non-zero flag to indicate 'failure' -> take slow path\n-      __ j(no_count);\n-    }\n-\n-    assert(oopDesc::mark_offset_in_bytes() == 0, \"offset of _mark is not 0\");\n-\n-    \/\/ Handle existing monitor.\n-    __ bind(object_has_monitor);\n-    STATIC_ASSERT(markWord::monitor_value <= INT_MAX);\n-    __ add(tmp, tmp, -(int)markWord::monitor_value); \/\/ monitor\n-\n-    if (LockingMode == LM_LIGHTWEIGHT) {\n-      \/\/ If the owner is anonymous, we need to fix it -- in an outline stub.\n-      Register tmp2 = disp_hdr;\n-      __ ld(tmp2, Address(tmp, ObjectMonitor::owner_offset()));\n-      __ test_bit(t0, tmp2, exact_log2(ObjectMonitor::ANONYMOUS_OWNER));\n-      C2HandleAnonOMOwnerStub* stub = new (Compile::current()->comp_arena()) C2HandleAnonOMOwnerStub(tmp, tmp2);\n-      Compile::current()->output()->add_stub(stub);\n-      __ bnez(t0, stub->entry(), \/* is_far *\/ true);\n-      __ bind(stub->continuation());\n-    }\n-\n-    __ ld(disp_hdr, Address(tmp, ObjectMonitor::recursions_offset()));\n-\n-    Label notRecursive;\n-    __ beqz(disp_hdr, notRecursive); \/\/ Will be 0 if not recursive.\n-\n-    \/\/ Recursive lock\n-    __ addi(disp_hdr, disp_hdr, -1);\n-    __ sd(disp_hdr, Address(tmp, ObjectMonitor::recursions_offset()));\n-    __ mv(flag, zr);\n-    __ j(cont);\n-\n-    __ bind(notRecursive);\n-    __ ld(flag, Address(tmp, ObjectMonitor::EntryList_offset()));\n-    __ ld(disp_hdr, Address(tmp, ObjectMonitor::cxq_offset()));\n-    __ orr(flag, flag, disp_hdr); \/\/ Will be 0 if both are 0.\n-    __ bnez(flag, cont);\n-    \/\/ need a release store here\n-    __ la(tmp, Address(tmp, ObjectMonitor::owner_offset()));\n-    __ membar(MacroAssembler::LoadStore | MacroAssembler::StoreStore);\n-    __ sd(zr, Address(tmp)); \/\/ set unowned\n-\n-    __ bind(cont);\n-    \/\/ zero flag indicates success\n-    \/\/ non-zero flag indicates failure\n-    __ bnez(flag, no_count);\n-\n-    __ bind(count);\n-    __ decrement(Address(xthread, JavaThread::held_monitor_count_offset()), 1, t0, tmp);\n-\n-    __ bind(no_count);\n-  %}\n-\n@@ -10419,1 +10202,3 @@\n-  ins_encode(riscv_enc_fast_lock(object, box, tmp1, tmp2));\n+  ins_encode %{\n+    __ fast_lock($object$$Register, $box$$Register, $tmp1$$Register, $tmp2$$Register);\n+  %}\n@@ -10433,1 +10218,3 @@\n-  ins_encode(riscv_enc_fast_unlock(object, box, tmp1, tmp2));\n+  ins_encode %{\n+    __ fast_unlock($object$$Register, $box$$Register, $tmp1$$Register, $tmp2$$Register);\n+  %}\n","filename":"src\/hotspot\/cpu\/riscv\/riscv.ad","additions":6,"deletions":219,"binary":false,"changes":225,"status":"modified"},{"patch":"@@ -1704,1 +1704,1 @@\n-      __ fast_lock(obj_reg, swap_reg, tmp, t0, slow_path_lock);\n+      __ lightweight_lock(obj_reg, swap_reg, tmp, t0, slow_path_lock);\n@@ -1832,1 +1832,1 @@\n-      __ fast_unlock(obj_reg, old_hdr, swap_reg, t0, slow_path_unlock);\n+      __ lightweight_unlock(obj_reg, old_hdr, swap_reg, t0, slow_path_unlock);\n","filename":"src\/hotspot\/cpu\/riscv\/sharedRuntime_riscv.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -73,1 +73,1 @@\n-    fast_lock_impl(obj, hdr, thread, tmp, slow_case);\n+    lightweight_lock(obj, hdr, thread, tmp, slow_case);\n@@ -139,1 +139,1 @@\n-    fast_unlock_impl(obj, disp_hdr, hdr, slow_case);\n+    lightweight_unlock(obj, disp_hdr, hdr, slow_case);\n","filename":"src\/hotspot\/cpu\/x86\/c1_MacroAssembler_x86.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -625,1 +625,1 @@\n-    fast_lock_impl(objReg, tmpReg, thread, scrReg, NO_COUNT);\n+    lightweight_lock(objReg, tmpReg, thread, scrReg, NO_COUNT);\n@@ -929,1 +929,1 @@\n-      fast_unlock_impl(objReg, boxReg, tmpReg, NO_COUNT);\n+      lightweight_unlock(objReg, boxReg, tmpReg, NO_COUNT);\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1239,1 +1239,1 @@\n-      fast_lock_impl(obj_reg, swap_reg, thread, tmp_reg, slow_case);\n+      lightweight_lock(obj_reg, swap_reg, thread, tmp_reg, slow_case);\n@@ -1369,1 +1369,1 @@\n-      fast_unlock_impl(obj_reg, swap_reg, header_reg, slow_case);\n+      lightweight_unlock(obj_reg, swap_reg, header_reg, slow_case);\n","filename":"src\/hotspot\/cpu\/x86\/interp_masm_x86.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -9792,1 +9792,1 @@\n-\/\/ Implements fast-locking.\n+\/\/ Implements lightweight-locking.\n@@ -9800,1 +9800,1 @@\n-void MacroAssembler::fast_lock_impl(Register obj, Register hdr, Register thread, Register tmp, Label& slow) {\n+void MacroAssembler::lightweight_lock(Register obj, Register hdr, Register thread, Register tmp, Label& slow) {\n@@ -9828,1 +9828,1 @@\n-\/\/ Implements fast-unlocking.\n+\/\/ Implements lightweight-unlocking.\n@@ -9835,1 +9835,1 @@\n-void MacroAssembler::fast_unlock_impl(Register obj, Register hdr, Register tmp, Label& slow) {\n+void MacroAssembler::lightweight_unlock(Register obj, Register hdr, Register tmp, Label& slow) {\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2026,2 +2026,2 @@\n-  void fast_lock_impl(Register obj, Register hdr, Register thread, Register tmp, Label& slow);\n-  void fast_unlock_impl(Register obj, Register hdr, Register tmp, Label& slow);\n+  void lightweight_lock(Register obj, Register hdr, Register thread, Register tmp, Label& slow);\n+  void lightweight_unlock(Register obj, Register hdr, Register tmp, Label& slow);\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1720,1 +1720,1 @@\n-      __ fast_lock_impl(obj_reg, swap_reg, thread, lock_reg, slow_path_lock);\n+      __ lightweight_lock(obj_reg, swap_reg, thread, lock_reg, slow_path_lock);\n@@ -1879,1 +1879,1 @@\n-      __ fast_unlock_impl(obj_reg, swap_reg, lock_reg, slow_path_unlock);\n+      __ lightweight_unlock(obj_reg, swap_reg, lock_reg, slow_path_unlock);\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_32.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2191,1 +2191,1 @@\n-      __ fast_lock_impl(obj_reg, swap_reg, r15_thread, rscratch1, slow_path_lock);\n+      __ lightweight_lock(obj_reg, swap_reg, r15_thread, rscratch1, slow_path_lock);\n@@ -2335,1 +2335,1 @@\n-      __ fast_unlock_impl(obj_reg, swap_reg, lock_reg, slow_path_unlock);\n+      __ lightweight_unlock(obj_reg, swap_reg, lock_reg, slow_path_unlock);\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}