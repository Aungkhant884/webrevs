{"files":[{"patch":"@@ -1299,3 +1299,2 @@\n-  Label profile_cast_success, profile_cast_failure;\n-  Label *success_target = should_profile ? &profile_cast_success : success;\n-  Label *failure_target = should_profile ? &profile_cast_failure : failure;\n+  Label *success_target = success;\n+  Label *failure_target = failure;\n@@ -1317,18 +1316,32 @@\n-    if (should_profile) {\n-      Label not_null;\n-      __ cbnz(obj, not_null);\n-      \/\/ Object is null; update MDO and exit\n-      Register mdo  = klass_RInfo;\n-      __ mov_metadata(mdo, md->constant_encoding());\n-      Address data_addr\n-        = __ form_address(rscratch2, mdo,\n-                          md->byte_offset_of_slot(data, DataLayout::flags_offset()),\n-                          0);\n-      __ ldrb(rscratch1, data_addr);\n-      __ orr(rscratch1, rscratch1, BitData::null_seen_byte_constant());\n-      __ strb(rscratch1, data_addr);\n-      __ b(*obj_is_null);\n-      __ bind(not_null);\n-    } else {\n-      __ cbz(obj, *obj_is_null);\n-    }\n+  if (should_profile) {\n+    Register mdo  = klass_RInfo;\n+    __ mov_metadata(mdo, md->constant_encoding());\n+    Label not_null;\n+    __ cbnz(obj, not_null);\n+    \/\/ Object is null; update MDO and exit\n+    Address data_addr\n+      = __ form_address(rscratch2, mdo,\n+                        md->byte_offset_of_slot(data, DataLayout::flags_offset()),\n+                        0);\n+    __ ldrb(rscratch1, data_addr);\n+    __ orr(rscratch1, rscratch1, BitData::null_seen_byte_constant());\n+    __ strb(rscratch1, data_addr);\n+    __ b(*obj_is_null);\n+    __ bind(not_null);\n+\n+    Label update_done;\n+    Register recv = k_RInfo;\n+    __ load_klass(recv, obj);\n+    type_profile_helper(mdo, md, data, recv, &update_done);\n+    Address nonprofiled_receiver_count_addr\n+      = __ form_address(rscratch2, mdo,\n+                        md->byte_offset_of_slot(data, CounterData::count_offset()),\n+                        0);\n+    __ ldr(rscratch1, nonprofiled_receiver_count_addr);\n+    __ add(rscratch1, rscratch1, DataLayout::counter_increment);\n+    __ str(rscratch1, nonprofiled_receiver_count_addr);\n+\n+    __ bind(update_done);\n+  } else {\n+    __ cbz(obj, *obj_is_null);\n+  }\n@@ -1388,20 +1401,0 @@\n-  if (should_profile) {\n-    Register mdo  = klass_RInfo, recv = k_RInfo;\n-    __ bind(profile_cast_success);\n-    __ mov_metadata(mdo, md->constant_encoding());\n-    __ load_klass(recv, obj);\n-    Label update_done;\n-    type_profile_helper(mdo, md, data, recv, success);\n-    __ b(*success);\n-\n-    __ bind(profile_cast_failure);\n-    __ mov_metadata(mdo, md->constant_encoding());\n-    Address counter_addr\n-      = __ form_address(rscratch2, mdo,\n-                        md->byte_offset_of_slot(data, CounterData::count_offset()),\n-                        0);\n-    __ ldr(rscratch1, counter_addr);\n-    __ sub(rscratch1, rscratch1, DataLayout::counter_increment);\n-    __ str(rscratch1, counter_addr);\n-    __ b(*failure);\n-  }\n@@ -1439,3 +1432,3 @@\n-    Label profile_cast_success, profile_cast_failure, done;\n-    Label *success_target = should_profile ? &profile_cast_success : &done;\n-    Label *failure_target = should_profile ? &profile_cast_failure : stub->entry();\n+    Label done;\n+    Label *success_target = &done;\n+    Label *failure_target = stub->entry();\n@@ -1445,2 +1438,0 @@\n-      __ cbnz(value, not_null);\n-      \/\/ Object is null; update MDO and exit\n@@ -1449,0 +1440,2 @@\n+      __ cbnz(value, not_null);\n+      \/\/ Object is null; update MDO and exit\n@@ -1458,0 +1451,10 @@\n+\n+      Label update_done;\n+      Register recv = k_RInfo;\n+      __ load_klass(recv, value);\n+      type_profile_helper(mdo, md, data, recv, &update_done);\n+      Address counter_addr(mdo, md->byte_offset_of_slot(data, CounterData::count_offset()));\n+      __ ldr(rscratch1, counter_addr);\n+      __ add(rscratch1, rscratch1, DataLayout::counter_increment);\n+      __ str(rscratch1, counter_addr);\n+      __ bind(update_done);\n@@ -1478,19 +1481,0 @@\n-    if (should_profile) {\n-      Register mdo  = klass_RInfo, recv = k_RInfo;\n-      __ bind(profile_cast_success);\n-      __ mov_metadata(mdo, md->constant_encoding());\n-      __ load_klass(recv, value);\n-      Label update_done;\n-      type_profile_helper(mdo, md, data, recv, &done);\n-      __ b(done);\n-\n-      __ bind(profile_cast_failure);\n-      __ mov_metadata(mdo, md->constant_encoding());\n-      Address counter_addr(mdo, md->byte_offset_of_slot(data, CounterData::count_offset()));\n-      __ lea(rscratch2, counter_addr);\n-      __ ldr(rscratch1, Address(rscratch2));\n-      __ sub(rscratch1, rscratch1, DataLayout::counter_increment);\n-      __ str(rscratch1, Address(rscratch2));\n-      __ b(*stub->entry());\n-    }\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRAssembler_aarch64.cpp","additions":49,"deletions":65,"binary":false,"changes":114,"status":"modified"},{"patch":"@@ -328,3 +328,0 @@\n-\n-  \/\/ Profile the failure of the check.\n-  profile_typecheck_failed(r2); \/\/ blows r2\n@@ -1216,1 +1213,1 @@\n-    record_klass_in_profile(receiver, mdp, reg2, true);\n+    record_klass_in_profile(receiver, mdp, reg2);\n@@ -1239,1 +1236,1 @@\n-                                        Label& done, bool is_virtual_call) {\n+                                        Label& done) {\n@@ -1241,8 +1238,1 @@\n-    if (is_virtual_call) {\n-      increment_mdp_data_at(mdp, in_bytes(CounterData::count_offset()));\n-    }\n-#if INCLUDE_JVMCI\n-    else if (EnableJVMCI) {\n-      increment_mdp_data_at(mdp, in_bytes(ReceiverTypeData::nonprofiled_receiver_count_offset()));\n-    }\n-#endif \/\/ INCLUDE_JVMCI\n+    increment_mdp_data_at(mdp, in_bytes(CounterData::count_offset()));\n@@ -1250,10 +1240,0 @@\n-    int non_profiled_offset = -1;\n-    if (is_virtual_call) {\n-      non_profiled_offset = in_bytes(CounterData::count_offset());\n-    }\n-#if INCLUDE_JVMCI\n-    else if (EnableJVMCI) {\n-      non_profiled_offset = in_bytes(ReceiverTypeData::nonprofiled_receiver_count_offset());\n-    }\n-#endif \/\/ INCLUDE_JVMCI\n-\n@@ -1261,1 +1241,1 @@\n-        &VirtualCallData::receiver_offset, &VirtualCallData::receiver_count_offset, non_profiled_offset);\n+        &VirtualCallData::receiver_offset, &VirtualCallData::receiver_count_offset);\n@@ -1267,2 +1247,1 @@\n-                                        OffsetFunction item_offset_fn, OffsetFunction item_count_offset_fn,\n-                                        int non_profiled_offset) {\n+                                        OffsetFunction item_offset_fn, OffsetFunction item_count_offset_fn) {\n@@ -1299,10 +1278,6 @@\n-        if (non_profiled_offset >= 0) {\n-          cbz(reg2, found_null);\n-          \/\/ Item did not match any saved item and there is no empty row for it.\n-          \/\/ Increment total counter to indicate polymorphic case.\n-          increment_mdp_data_at(mdp, non_profiled_offset);\n-          b(done);\n-          bind(found_null);\n-        } else {\n-          cbnz(reg2, done);\n-        }\n+        cbz(reg2, found_null);\n+        \/\/ Item did not match any saved item and there is no empty row for it.\n+        \/\/ Increment total counter to indicate polymorphic case.\n+        increment_mdp_data_at(mdp, in_bytes(CounterData::count_offset()));\n+        b(done);\n+        bind(found_null);\n@@ -1316,1 +1291,1 @@\n-        item_offset_fn, item_count_offset_fn, non_profiled_offset);\n+        item_offset_fn, item_count_offset_fn);\n@@ -1363,2 +1338,1 @@\n-                                                        Register mdp, Register reg2,\n-                                                        bool is_virtual_call) {\n+                                                        Register mdp, Register reg2) {\n@@ -1368,1 +1342,1 @@\n-  record_klass_in_profile_helper(receiver, mdp, reg2, 0, done, is_virtual_call);\n+  record_klass_in_profile_helper(receiver, mdp, reg2, 0, done);\n@@ -1430,18 +1404,0 @@\n-void InterpreterMacroAssembler::profile_typecheck_failed(Register mdp) {\n-  if (ProfileInterpreter && TypeProfileCasts) {\n-    Label profile_continue;\n-\n-    \/\/ If no method data exists, go to profile_continue.\n-    test_method_data_pointer(mdp, profile_continue);\n-\n-    int count_offset = in_bytes(CounterData::count_offset());\n-    \/\/ Back up the address, since we have already bumped the mdp.\n-    count_offset -= in_bytes(VirtualCallData::virtual_call_data_size());\n-\n-    \/\/ *Decrement* the counter.  We expect to see zero or small negatives.\n-    increment_mdp_data_at(mdp, count_offset, true);\n-\n-    bind (profile_continue);\n-  }\n-}\n-\n@@ -1461,1 +1417,1 @@\n-      record_klass_in_profile(klass, mdp, reg2, false);\n+      record_klass_in_profile(klass, mdp, reg2);\n","filename":"src\/hotspot\/cpu\/aarch64\/interp_masm_aarch64.cpp","additions":15,"deletions":59,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -267,1 +267,1 @@\n-                               Register reg2, bool is_virtual_call);\n+                               Register reg2);\n@@ -270,1 +270,1 @@\n-                                      Label& done, bool is_virtual_call);\n+                                      Label& done);\n@@ -273,2 +273,1 @@\n-                                     OffsetFunction item_offset_fn, OffsetFunction item_count_offset_fn,\n-                                     int non_profiled_offset);\n+                                     OffsetFunction item_offset_fn, OffsetFunction item_count_offset_fn);\n","filename":"src\/hotspot\/cpu\/aarch64\/interp_masm_aarch64.hpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1698,3 +1698,2 @@\n-  Label profile_cast_success, profile_cast_failure;\n-  Label *success_target = op->should_profile() ? &profile_cast_success : success;\n-  Label *failure_target = op->should_profile() ? &profile_cast_failure : failure;\n+  Label *success_target = success;\n+  Label *failure_target = failure;\n@@ -1719,2 +1718,0 @@\n-    __ jccb(Assembler::notEqual, not_null);\n-    \/\/ Object is null; update MDO and exit\n@@ -1723,0 +1720,2 @@\n+    __ jccb(Assembler::notEqual, not_null);\n+    \/\/ Object is null; update MDO and exit\n@@ -1728,0 +1727,10 @@\n+\n+    Label update_done;\n+    Register recv = k_RInfo;\n+    __ load_klass(recv, obj, tmp_load_klass);\n+    type_profile_helper(mdo, md, data, recv, &update_done);\n+\n+    Address nonprofiled_receiver_count_addr(mdo, md->byte_offset_of_slot(data, CounterData::count_offset()));\n+    __ addptr(nonprofiled_receiver_count_addr, DataLayout::counter_increment);\n+\n+    __ bind(update_done);\n@@ -1814,14 +1823,0 @@\n-  if (op->should_profile()) {\n-    Register mdo  = klass_RInfo, recv = k_RInfo;\n-    __ bind(profile_cast_success);\n-    __ mov_metadata(mdo, md->constant_encoding());\n-    __ load_klass(recv, obj, tmp_load_klass);\n-    type_profile_helper(mdo, md, data, recv, success);\n-    __ jmp(*success);\n-\n-    __ bind(profile_cast_failure);\n-    __ mov_metadata(mdo, md->constant_encoding());\n-    Address counter_addr(mdo, md->byte_offset_of_slot(data, CounterData::count_offset()));\n-    __ subptr(counter_addr, DataLayout::counter_increment);\n-    __ jmp(*failure);\n-  }\n@@ -1858,3 +1853,3 @@\n-    Label profile_cast_success, profile_cast_failure, done;\n-    Label *success_target = op->should_profile() ? &profile_cast_success : &done;\n-    Label *failure_target = op->should_profile() ? &profile_cast_failure : stub->entry();\n+    Label done;\n+    Label *success_target = &done;\n+    Label *failure_target = stub->entry();\n@@ -1865,2 +1860,0 @@\n-      __ jccb(Assembler::notEqual, not_null);\n-      \/\/ Object is null; update MDO and exit\n@@ -1869,0 +1862,2 @@\n+      __ jccb(Assembler::notEqual, not_null);\n+      \/\/ Object is null; update MDO and exit\n@@ -1874,0 +1869,9 @@\n+\n+      Label update_done;\n+      Register recv = k_RInfo;\n+      __ load_klass(recv, value, tmp_load_klass);\n+      type_profile_helper(mdo, md, data, recv, &update_done);\n+\n+      Address counter_addr(mdo, md->byte_offset_of_slot(data, CounterData::count_offset()));\n+      __ addptr(counter_addr, DataLayout::counter_increment);\n+      __ bind(update_done);\n@@ -1897,15 +1901,0 @@\n-    if (op->should_profile()) {\n-      Register mdo  = klass_RInfo, recv = k_RInfo;\n-      __ bind(profile_cast_success);\n-      __ mov_metadata(mdo, md->constant_encoding());\n-      __ load_klass(recv, value, tmp_load_klass);\n-      type_profile_helper(mdo, md, data, recv, &done);\n-      __ jmpb(done);\n-\n-      __ bind(profile_cast_failure);\n-      __ mov_metadata(mdo, md->constant_encoding());\n-      Address counter_addr(mdo, md->byte_offset_of_slot(data, CounterData::count_offset()));\n-      __ subptr(counter_addr, DataLayout::counter_increment);\n-      __ jmp(*stub->entry());\n-    }\n-\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRAssembler_x86.cpp","additions":28,"deletions":39,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -570,3 +570,0 @@\n-\n-  \/\/ Profile the failure of the check.\n-  profile_typecheck_failed(rcx); \/\/ blows rcx\n@@ -1714,8 +1711,1 @@\n-    if (is_virtual_call) {\n-      increment_mdp_data_at(mdp, in_bytes(CounterData::count_offset()));\n-    }\n-#if INCLUDE_JVMCI\n-    else if (EnableJVMCI) {\n-      increment_mdp_data_at(mdp, in_bytes(ReceiverTypeData::nonprofiled_receiver_count_offset()));\n-    }\n-#endif \/\/ INCLUDE_JVMCI\n+    increment_mdp_data_at(mdp, in_bytes(CounterData::count_offset()));\n@@ -1723,9 +1713,1 @@\n-    int non_profiled_offset = -1;\n-    if (is_virtual_call) {\n-      non_profiled_offset = in_bytes(CounterData::count_offset());\n-    }\n-#if INCLUDE_JVMCI\n-    else if (EnableJVMCI) {\n-      non_profiled_offset = in_bytes(ReceiverTypeData::nonprofiled_receiver_count_offset());\n-    }\n-#endif \/\/ INCLUDE_JVMCI\n+    int non_profiled_offset = in_bytes(CounterData::count_offset());\n@@ -1734,1 +1716,1 @@\n-        &VirtualCallData::receiver_offset, &VirtualCallData::receiver_count_offset, non_profiled_offset);\n+                                  &VirtualCallData::receiver_offset, &VirtualCallData::receiver_count_offset);\n@@ -1738,4 +1720,4 @@\n-void InterpreterMacroAssembler::record_item_in_profile_helper(Register item, Register mdp,\n-                                        Register reg2, int start_row, Label& done, int total_rows,\n-                                        OffsetFunction item_offset_fn, OffsetFunction item_count_offset_fn,\n-                                        int non_profiled_offset) {\n+void InterpreterMacroAssembler::record_item_in_profile_helper(Register item, Register mdp, Register reg2, int start_row,\n+                                                              Label& done, int total_rows,\n+                                                              OffsetFunction item_offset_fn,\n+                                                              OffsetFunction item_count_offset_fn) {\n@@ -1772,11 +1754,7 @@\n-        if (non_profiled_offset >= 0) {\n-          Label found_null;\n-          jccb(Assembler::zero, found_null);\n-          \/\/ Item did not match any saved item and there is no empty row for it.\n-          \/\/ Increment total counter to indicate polymorphic case.\n-          increment_mdp_data_at(mdp, non_profiled_offset);\n-          jmp(done);\n-          bind(found_null);\n-        } else {\n-          jcc(Assembler::notZero, done);\n-        }\n+        Label found_null;\n+        jccb(Assembler::zero, found_null);\n+        \/\/ Item did not match any saved item and there is no empty row for it.\n+        \/\/ Increment total counter to indicate polymorphic case.\n+        increment_mdp_data_at(mdp, in_bytes(CounterData::count_offset()));\n+        jmp(done);\n+        bind(found_null);\n@@ -1791,1 +1769,1 @@\n-        item_offset_fn, item_count_offset_fn, non_profiled_offset);\n+                                    item_offset_fn, item_count_offset_fn);\n@@ -1907,19 +1885,0 @@\n-void InterpreterMacroAssembler::profile_typecheck_failed(Register mdp) {\n-  if (ProfileInterpreter && TypeProfileCasts) {\n-    Label profile_continue;\n-\n-    \/\/ If no method data exists, go to profile_continue.\n-    test_method_data_pointer(mdp, profile_continue);\n-\n-    int count_offset = in_bytes(CounterData::count_offset());\n-    \/\/ Back up the address, since we have already bumped the mdp.\n-    count_offset -= in_bytes(VirtualCallData::virtual_call_data_size());\n-\n-    \/\/ *Decrement* the counter.  We expect to see zero or small negatives.\n-    increment_mdp_data_at(mdp, count_offset, true);\n-\n-    bind (profile_continue);\n-  }\n-}\n-\n-\n","filename":"src\/hotspot\/cpu\/x86\/interp_masm_x86.cpp","additions":15,"deletions":56,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -260,4 +260,4 @@\n-  void record_item_in_profile_helper(Register item, Register mdp,\n-                                     Register reg2, int start_row, Label& done, int total_rows,\n-                                     OffsetFunction item_offset_fn, OffsetFunction item_count_offset_fn,\n-                                     int non_profiled_offset);\n+  void record_item_in_profile_helper(Register item, Register mdp, Register reg2, int start_row,\n+                                     Label& done, int total_rows,\n+                                     OffsetFunction item_offset_fn,\n+                                     OffsetFunction item_count_offset_fn);\n@@ -280,1 +280,1 @@\n-  void profile_typecheck_failed(Register mdp);\n+\n","filename":"src\/hotspot\/cpu\/x86\/interp_masm_x86.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -437,2 +437,1 @@\n-\/\/ For invoke* it will turn negative values into max_jint,\n-\/\/ and for checkcast\/aastore\/instanceof turn positive values into min_jint.\n+\/\/ It will turn negative values into max_jint,\n@@ -440,11 +439,3 @@\n-  switch (code) {\n-    case Bytecodes::_aastore:    \/\/ fall-through\n-    case Bytecodes::_checkcast:  \/\/ fall-through\n-    case Bytecodes::_instanceof: {\n-      return (c > 0 ? min_jint : c); \/\/ always non-positive\n-    }\n-    default: {\n-      assert(Bytecodes::is_invoke(code), \"%s\", Bytecodes::name(code));\n-      return (c < 0 ? max_jint : c); \/\/ always non-negative\n-    }\n-  }\n+  assert(Bytecodes::is_invoke(code) || code == Bytecodes::_aastore || code == Bytecodes::_checkcast ||\n+         code == Bytecodes::_instanceof, \"%s\", Bytecodes::name(code));\n+  return (c < 0 ? max_jint : c); \/\/ always non-negative\n","filename":"src\/hotspot\/share\/ci\/ciMethod.cpp","additions":4,"deletions":13,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -721,1 +721,0 @@\n-  declare_constant(ReceiverTypeData::nonprofiled_count_off_set)           \\\n","filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -421,3 +421,0 @@\n-#if INCLUDE_JVMCI\n-  st->print_cr(\"count(%u) nonprofiled_count(%u) entries(%u)\", count(), nonprofiled_count(), entries);\n-#else\n@@ -425,1 +422,0 @@\n-#endif\n","filename":"src\/hotspot\/share\/oops\/methodData.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1091,6 +1091,0 @@\n-#if INCLUDE_JVMCI\n-    \/\/ Description of the different counters\n-    \/\/ ReceiverTypeData for instanceof\/checkcast\/aastore:\n-    \/\/   count is decremented for failed type checks\n-    \/\/   JVMCI only: nonprofiled_count is incremented on type overflow\n-    \/\/ VirtualCallData for invokevirtual\/invokeinterface:\n@@ -1098,6 +1092,0 @@\n-    \/\/   JVMCI only: nonprofiled_count is incremented on method overflow\n-\n-    \/\/ JVMCI is interested in knowing the percentage of type checks involving a type not explicitly in the profile\n-    nonprofiled_count_off_set = counter_cell_count,\n-    receiver0_offset,\n-#else\n@@ -1105,1 +1093,0 @@\n-#endif\n@@ -1120,1 +1107,1 @@\n-    return counter_cell_count + (uint) TypeProfileWidth * receiver_type_row_cell_count JVMCI_ONLY(+ 1);\n+    return counter_cell_count + (uint) TypeProfileWidth * receiver_type_row_cell_count;\n@@ -1182,7 +1169,0 @@\n-#if INCLUDE_JVMCI\n-    if (!this->is_VirtualCallData()) {\n-      \/\/ if this is a ReceiverTypeData for JVMCI, the nonprofiled_count\n-      \/\/ must also be reset (see \"Description of the different counters\" above)\n-      set_nonprofiled_count(0);\n-    }\n-#endif\n@@ -1198,11 +1178,0 @@\n-#if INCLUDE_JVMCI\n-  static ByteSize nonprofiled_receiver_count_offset() {\n-    return cell_offset(nonprofiled_count_off_set);\n-  }\n-  uint nonprofiled_count() const {\n-    return uint_at(nonprofiled_count_off_set);\n-  }\n-  void set_nonprofiled_count(uint count) {\n-    set_uint_at(nonprofiled_count_off_set, count);\n-  }\n-#endif \/\/ INCLUDE_JVMCI\n","filename":"src\/hotspot\/share\/oops\/methodData.hpp","additions":1,"deletions":32,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -774,0 +774,6 @@\n+                                                                            \\\n+  product(intx, TypeProfileSubTypeCheckCommonThreshold, 50,                 \\\n+          \"Use profile data at type check if together profiled types\"       \\\n+          \"account for more than this threshold\")                           \\\n+          range(0, 100)                                                     \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/opto\/c2_globals.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -340,1 +340,1 @@\n-  Node* search_identical(int dist);\n+  Node* search_identical(int dist, PhaseIterGVN* igvn);\n@@ -439,0 +439,2 @@\n+\n+  bool same_condition(const Node* dom, PhaseIterGVN* igvn) const;\n","filename":"src\/hotspot\/share\/opto\/cfgnode.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2680,1 +2680,2 @@\n-Node* Phase::gen_subtype_check(Node* subklass, Node* superklass, Node** ctrl, Node* mem, PhaseGVN& gvn) {\n+Node* Phase::gen_subtype_check(Node* subklass, Node* superklass, Node** ctrl, Node* mem, PhaseGVN& gvn,\n+                               Node_List* profile_entries) {\n@@ -2737,1 +2738,3 @@\n-  bool might_be_cache = (gvn.find_int_con(chk_off, cacheoff_con) == cacheoff_con);\n+  const TypeInt* chk_off_t = chk_off->Value(&gvn)->isa_int();\n+  int chk_off_con = (chk_off_t != nullptr && chk_off_t->is_con()) ? chk_off_t->get_con() : cacheoff_con;\n+  bool might_be_cache = (chk_off_con == cacheoff_con);\n@@ -2765,1 +2768,1 @@\n-  if( superklass == nkls )\n+  if (superklass == nkls) {\n@@ -2767,0 +2770,44 @@\n+  }\n+\n+  \/\/ Gather the various success & failures here\n+  RegionNode *r_not_subtype = new RegionNode(3);\n+  gvn.record_for_igvn(r_not_subtype);\n+  RegionNode *r_ok_subtype = new RegionNode(4);\n+  gvn.record_for_igvn(r_ok_subtype);\n+\n+  \/\/ If we might perform an expensive check, first try to take advantage of profile data that was attached to the\n+  \/\/ SubTypeCheck node\n+  if (might_be_cache && profile_entries != nullptr) {\n+    assert(profile_entries->size() % 2 == 0, \"\");\n+    float total_prob = 0;\n+    for (uint i = 0; i < profile_entries->size(); i += 2) {\n+      Node* prob = profile_entries->at(i + 1);\n+      float p = prob->bottom_type()->getf();\n+      total_prob += p;\n+    }\n+\n+    if (total_prob * 100. >= TypeProfileSubTypeCheckCommonThreshold) {\n+      const TypeKlassPtr* superk = gvn.type(superklass)->is_klassptr();\n+      for (uint i = 0; i < profile_entries->size(); i += 2) {\n+        Node* klass = profile_entries->at(i);\n+        const TypeKlassPtr* klass_t = gvn.type(klass)->is_klassptr();\n+        Node* prob = profile_entries->at(i + 1);\n+\n+        Compile::SubTypeCheckResult result = C->static_subtype_check(superk, klass_t);\n+        if (result != Compile::SSC_always_true && result != Compile::SSC_always_false) {\n+          continue;\n+        }\n+        float p = prob->bottom_type()->getf();\n+        IfNode* iff = gen_subtype_check_compare(*ctrl, subklass, klass, BoolTest::eq, p, gvn, T_ADDRESS);\n+        Node* iftrue = gvn.transform(new IfTrueNode(iff));\n+\n+        if (result == Compile::SSC_always_true) {\n+          r_ok_subtype->add_req(iftrue);\n+        } else {\n+          assert(result == Compile::SSC_always_false, \"\");\n+          r_not_subtype->add_req(iftrue);\n+        }\n+        *ctrl = gvn.transform(new IfFalseNode(iff));\n+      }\n+    }\n+  }\n@@ -2782,0 +2829,5 @@\n+    PhaseIterGVN* igvn = gvn.is_IterGVN();\n+    if (igvn != nullptr) {\n+      igvn->remove_globally_dead_node(r_ok_subtype);\n+      igvn->remove_globally_dead_node(r_not_subtype);\n+    }\n@@ -2785,6 +2837,0 @@\n-  \/\/ Gather the various success & failures here\n-  RegionNode *r_ok_subtype = new RegionNode(4);\n-  gvn.record_for_igvn(r_ok_subtype);\n-  RegionNode *r_not_subtype = new RegionNode(3);\n-  gvn.record_for_igvn(r_not_subtype);\n-\n@@ -2854,1 +2900,1 @@\n-    Node* n = Phase::gen_subtype_check(subklass, superklass, &ctrl, mem, _gvn);\n+    Node* n = Phase::gen_subtype_check(subklass, superklass, &ctrl, mem, _gvn, nullptr);\n@@ -2859,1 +2905,17 @@\n-  Node* check = _gvn.transform(new SubTypeCheckNode(C, obj_or_subklass, superklass));\n+  SubTypeCheckNode* subtypecheck = new SubTypeCheckNode(C, obj_or_subklass, superklass);\n+  const TypeKlassPtr* superklass_t = _gvn.type(superklass)->is_klassptr();\n+  \/\/ attach profile data to the SubTypeCheckNode\n+  ciCallProfile profile = method()->call_profile_at_bci(bci());\n+  for (int i = 0; ; ++i) {\n+    if (!profile.has_receiver(i)) {\n+      break;\n+    }\n+    ciKlass* klass = profile.receiver(i);\n+    const TypeKlassPtr* klass_t = TypeKlassPtr::make(klass);\n+    ConNode* klass_node = _gvn.makecon(klass_t);\n+    subtypecheck->add_req(klass_node);\n+    float prob = profile.receiver_prob(i);\n+    ConNode* prob_node = _gvn.makecon(TypeF::make(prob));\n+    subtypecheck->add_req(prob_node);\n+  }\n+  Node* check = _gvn.transform(subtypecheck);\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":73,"deletions":11,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -412,2 +412,1 @@\n-    if (profile.count() >= 0 &&         \/\/ no cast failures here\n-        profile.has_receiver(0) &&\n+    if (profile.has_receiver(0) &&\n","filename":"src\/hotspot\/share\/opto\/graphKit.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+#include \"opto\/subtypenode.hpp\"\n@@ -1478,1 +1479,1 @@\n-  Node* prev_dom = search_identical(dist);\n+  Node* prev_dom = search_identical(dist, igvn);\n@@ -1553,1 +1554,1 @@\n-Node* IfNode::search_identical(int dist) {\n+Node* IfNode::search_identical(int dist, PhaseIterGVN* igvn) {\n@@ -1559,2 +1560,2 @@\n-  while (dom->Opcode() != op    ||  \/\/ Not same opcode?\n-         dom->in(1)    != in(1) ||  \/\/ Not same input 1?\n+  while (dom->Opcode() != op ||  \/\/ Not same opcode?\n+         !same_condition(dom, igvn) ||  \/\/ Not same input 1?\n@@ -1584,0 +1585,30 @@\n+bool IfNode::same_condition(const Node* dom, PhaseIterGVN* igvn) const {\n+  Node* dom_bool = dom->in(1);\n+  Node* this_bool = in(1);\n+  if (dom_bool == this_bool) {\n+    return true;\n+  }\n+  \/\/ If the comparison is a subtype check, then SubTypeCheck nodes may have profile data attached to them and may be\n+  \/\/ different nodes even-though they perform the same subtype check\n+  if (dom_bool == nullptr || !dom_bool->is_Bool() ||\n+      this_bool == nullptr || !this_bool->is_Bool()) {\n+    return false;\n+  }\n+  Node* dom_cmp = dom_bool->in(1);\n+  Node* this_cmp = this_bool->in(1);\n+\n+  if (dom_cmp == nullptr || !dom_cmp->is_SubTypeCheck() ||\n+      this_cmp == nullptr || !this_cmp->is_SubTypeCheck() ||\n+      (dom_cmp->req() == 3 && this_cmp->req() == 3)) {\n+    return false;\n+  }\n+\n+  if (dom_cmp->in(1) != this_cmp->in(1) ||\n+      dom_cmp->in(2) != this_cmp->in(2) ||\n+      dom_bool->as_Bool()->_test._test != this_bool->as_Bool()->_test._test) {\n+    return false;\n+  }\n+\n+  return true;\n+}\n+\n@@ -1961,1 +1992,1 @@\n-    prev_dom = search_identical(4);\n+    prev_dom = search_identical(4, igvn);\n","filename":"src\/hotspot\/share\/opto\/ifnode.cpp","additions":36,"deletions":5,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -1231,1 +1231,1 @@\n-  if (!dom->is_If() || dom->in(1) != n->in(1)) {\n+  if (!dom->is_If() ||  !n->as_If()->same_condition(dom, &_igvn)) {\n@@ -1418,1 +1418,1 @@\n-    if (max > 1 && bol->is_Bool()) {\n+    if (bol->is_Bool() && (max > 1 || bol->in(1)->is_SubTypeCheck())) {\n@@ -1420,1 +1420,2 @@\n-      Node *cutoff = get_ctrl(bol);\n+      Node* cmp = bol->in(1);\n+      Node *cutoff = cmp->is_SubTypeCheck() ? dom_lca(get_ctrl(cmp->in(1)), get_ctrl(cmp->in(2))) : get_ctrl(bol);\n@@ -1426,1 +1427,1 @@\n-        if (dom->req() > 1 && dom->in(1) == bol && prevdom->in(0) == dom &&\n+        if (dom->req() > 1 && n->as_If()->same_condition(dom, &_igvn) && prevdom->in(0) == dom &&\n@@ -1482,0 +1483,4 @@\n+    if (n->in(1) != dom_if->in(1)) {\n+      assert(n->in(1)->in(1)->is_SubTypeCheck() && (n->in(1)->in(1)->req() > 3 || dom_if->in(1)->in(1)->req() > 3), \"only for subtype checks with profile data attached\");\n+      _igvn.replace_input_of(n, 1, dom_if->in(1));\n+    }\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":9,"deletions":4,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2287,1 +2287,6 @@\n-    Node* not_subtype_ctrl = Phase::gen_subtype_check(subklass, superklass, &ctrl, nullptr, _igvn);\n+    Node_List profile_entries;\n+    for (uint j = SubTypeCheckNode::ProfileEntry; j < check->req(); ++j) {\n+      profile_entries.push(check->in(j));\n+    }\n+\n+    Node* not_subtype_ctrl = Phase::gen_subtype_check(subklass, superklass, &ctrl, nullptr, _igvn, &profile_entries);\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -636,1 +636,1 @@\n-      Node* not_subtype_ctrl = Phase::gen_subtype_check(src_klass, dest_klass, ctrl, mem, _igvn);\n+      Node* not_subtype_ctrl = Phase::gen_subtype_check(src_klass, dest_klass, ctrl, mem, _igvn, nullptr);\n","filename":"src\/hotspot\/share\/opto\/macroArrayCopy.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+class Node_List;\n@@ -143,1 +144,1 @@\n-  static Node* gen_subtype_check(Node* subklass, Node* superklass, Node** ctrl, Node* mem, PhaseGVN& gvn);\n+  static Node* gen_subtype_check(Node* subklass, Node* superklass, Node** ctrl, Node* mem, PhaseGVN& gvn, Node_List* profile_entries);\n","filename":"src\/hotspot\/share\/opto\/phase.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -35,1 +35,2 @@\n-    SuperKlass\n+    SuperKlass,\n+    ProfileEntry, \/\/ profile data can be attached to the node\n","filename":"src\/hotspot\/share\/opto\/subtypenode.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -66,1 +66,0 @@\n-        final int nonprofiledCountOffset = cellIndexToOffset(config.receiverTypeDataNonprofiledCountOffset);\n@@ -511,4 +510,0 @@\n-        public int getNonprofiledCount(HotSpotMethodData data, int position) {\n-            return data.readUnsignedIntAsSignedInt(position, state.nonprofiledCountOffset);\n-        }\n-\n@@ -549,2 +544,2 @@\n-            sb.append(format(\"count(%d) null_seen(%s) exception_seen(%s) nonprofiled_count(%d) entries(%d)\", getCounterValue(data, pos), nullSeen, exceptionSeen,\n-                            getNonprofiledCount(data, pos), profile.entries));\n+            sb.append(format(\"count(%d) null_seen(%s) exception_seen(%s) entries(%d)\", getCounterValue(data, pos), nullSeen, exceptionSeen,\n+                            profile.entries));\n@@ -574,1 +569,0 @@\n-        @Override\n@@ -576,1 +570,1 @@\n-            return getNonprofiledCount(data, position);\n+            return getCounterValue(data, position);\n@@ -603,9 +597,0 @@\n-        @Override\n-        protected long getTypesNotRecordedExecutionCount(HotSpotMethodData data, int position) {\n-            return getCounterValue(data, position);\n-        }\n-\n-        private long getMethodsNotRecordedExecutionCount(HotSpotMethodData data, int position) {\n-            return data.readUnsignedIntAsSignedInt(position, state.nonprofiledCountOffset);\n-        }\n-\n@@ -637,2 +622,0 @@\n-            totalCount += getMethodsNotRecordedExecutionCount(data, position);\n-\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotMethodData.java","additions":3,"deletions":20,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -383,1 +383,0 @@\n-    final int receiverTypeDataNonprofiledCountOffset = getConstant(\"ReceiverTypeData::nonprofiled_count_off_set\", Integer.class);\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotVMConfig.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,345 @@\n+\/*\n+ * Copyright (c) 2023, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.c2.irTests;\n+\n+import compiler.lib.ir_framework.*;\n+import jdk.test.lib.Platform;\n+\n+\/*\n+ * @test\n+ * bug 8308869\n+ * @summary C2: use profile data in subtype checks when profile has more than one class\n+ * @library \/test\/lib \/\n+ * @requires vm.compiler2.enabled\n+ * @run driver compiler.c2.irTests.ProfileAtTypeCheck\n+ *\/\n+\n+public class ProfileAtTypeCheck {\n+    public static void main(String[] args) {\n+        if (Platform.is32bit()) {\n+            TestFramework.runWithFlags(\"-XX:TypeProfileSubTypeCheckCommonThreshold=90\");\n+        } else {\n+            TestFramework.runWithFlags(\"-XX:-UseCompressedClassPointers\", \"-XX:TypeProfileSubTypeCheckCommonThreshold=90\");\n+        }\n+    }\n+\n+    @DontInline\n+    static void dummyA(A a) {\n+    }\n+\n+    @DontInline\n+    static void dummyB(B b) {\n+    }\n+\n+    @DontInline\n+    static void dummyI(I i) {\n+    }\n+\n+    \/\/ profile reports many classes\n+\n+    @Test\n+    @IR(phase = { CompilePhase.AFTER_PARSING }, counts = { IRNode.SUBTYPE_CHECK, \"1\" })\n+    @IR(phase = { CompilePhase.MACRO_EXPANSION }, counts = { IRNode.CMP_P, \"2\", IRNode.LOAD_KLASS, \"2\" })\n+    public static void test1(Object o) {\n+        dummyA((A)o);\n+    }\n+\n+    @Run(test = \"test1\")\n+    @Warmup(10000)\n+    private void test1Runner() {\n+        test1(a);\n+        test1(b);\n+        test1(c);\n+        test1(d);\n+    }\n+\n+    \/\/ profile reports a single class\n+\n+    @Test\n+    @IR(phase = { CompilePhase.AFTER_PARSING }, failOn = { IRNode.SUBTYPE_CHECK })\n+    @IR(phase = { CompilePhase.AFTER_PARSING }, counts = { IRNode.CMP_P, \"2\", IRNode.LOAD_KLASS, \"1\" })\n+    public static void test2(Object o) {\n+        dummyA((A)o);\n+    }\n+\n+    @Run(test = \"test2\")\n+    @Warmup(10000)\n+    private void test2Runner() {\n+        test2(a);\n+    }\n+\n+    \/\/ \"easy\" test because B has no subclass\n+\n+    @Test\n+    @IR(phase = { CompilePhase.AFTER_PARSING }, counts = { IRNode.SUBTYPE_CHECK, \"1\" })\n+    @IR(phase = { CompilePhase.MACRO_EXPANSION }, counts = { IRNode.CMP_P, \"2\", IRNode.LOAD_KLASS, \"1\" })\n+    public static void test3(Object o) {\n+        if (o instanceof B) {\n+            dummyB((B)o);\n+        }\n+    }\n+\n+    @Run(test = \"test3\")\n+    @Warmup(10000)\n+    private void test3Runner() {\n+        test3(b);\n+        test3(c);\n+        test3(d);\n+    }\n+\n+    \/\/ full subtype check\n+    @Test\n+    @IR(phase = { CompilePhase.AFTER_PARSING }, counts = { IRNode.SUBTYPE_CHECK, \"1\" })\n+    @IR(phase = { CompilePhase.MACRO_EXPANSION }, counts = { IRNode.CMP_P, \"3\", IRNode.LOAD_KLASS, \"2\", IRNode.PARTIAL_SUBTYPE_CHECK, \"1\" })\n+    public static void test4(Object o) {\n+        dummyI((I)o);\n+    }\n+\n+    @Run(test = \"test4\")\n+    @Warmup(10000)\n+    private void test4Runner() {\n+        test4(a);\n+        test4(b);\n+        test4(c);\n+        test4(d);\n+    }\n+\n+    \/\/ full subtype check + profile use for success path\n+    @Test\n+    @IR(phase = { CompilePhase.AFTER_PARSING }, counts = { IRNode.SUBTYPE_CHECK, \"1\" })\n+    @IR(phase = { CompilePhase.MACRO_EXPANSION }, counts = { IRNode.CMP_P, \"5\", IRNode.LOAD_KLASS, \"2\", IRNode.PARTIAL_SUBTYPE_CHECK, \"1\" })\n+    public static void test5(Object o) {\n+        dummyI((I)o);\n+    }\n+\n+    @Run(test = \"test5\")\n+    @Warmup(10000)\n+    private void test5Runner() {\n+        test5(a);\n+        test5(b);\n+    }\n+\n+    \/\/ Check primary super\n+    @Test\n+    @IR(phase = { CompilePhase.AFTER_PARSING }, counts = { IRNode.SUBTYPE_CHECK, \"1\" })\n+    @IR(phase = { CompilePhase.MACRO_EXPANSION }, counts = { IRNode.CMP_P, \"2\", IRNode.LOAD_KLASS, \"2\" }, failOn = { IRNode.PARTIAL_SUBTYPE_CHECK })\n+    public static void test6(Object o) {\n+        dummyA((A)o);\n+    }\n+\n+    @Run(test = \"test6\")\n+    @Warmup(10000)\n+    private void test6Runner() {\n+        test6(b);\n+        test6(c);\n+        test6(d);\n+    }\n+\n+    \/\/ full subtype check + profile use for both success and failure paths\n+    @Test\n+    @IR(phase = { CompilePhase.AFTER_PARSING }, counts = { IRNode.SUBTYPE_CHECK, \"1\" })\n+    @IR(phase = { CompilePhase.MACRO_EXPANSION }, counts = { IRNode.CMP_P, \"5\", IRNode.LOAD_KLASS, \"2\", IRNode.PARTIAL_SUBTYPE_CHECK, \"1\" })\n+    public static boolean test7(Object o) {\n+        return o instanceof I;\n+    }\n+\n+    @Run(test = \"test7\")\n+    @Warmup(10000)\n+    private void test7Runner() {\n+        test7(a);\n+        test7(e);\n+    }\n+\n+    \/\/ full subtype check + profile use for success path (profile has unrecorded entries)\n+    @Test\n+    @IR(phase = { CompilePhase.AFTER_PARSING }, counts = { IRNode.SUBTYPE_CHECK, \"1\" })\n+    @IR(phase = { CompilePhase.MACRO_EXPANSION }, counts = { IRNode.CMP_P, \"5\", IRNode.LOAD_KLASS, \"2\", IRNode.PARTIAL_SUBTYPE_CHECK, \"1\" })\n+    public static void test8(Object o) {\n+        dummyI((I)o);\n+    }\n+\n+    @Run(test = \"test8\")\n+    @Warmup(10000)\n+    private void test8Runner() {\n+        for (int i = 0; i < 40; i++) {\n+            test8(a); \/\/ 95% of profile is A\n+        }\n+        \/\/ plus some B and C\n+        test8(b);\n+        test8(c);\n+    }\n+\n+    \/\/ test that split if triggers\n+    @Test\n+    @IR(phase = { CompilePhase.AFTER_PARSING }, counts = { IRNode.SUBTYPE_CHECK, \"1\" })\n+    @IR(phase = { CompilePhase.PHASEIDEALLOOP1 }, counts = { IRNode.SUBTYPE_CHECK, \"2\" })\n+    public static void test9(boolean flag1, boolean flag2, Object o1, Object o2) {\n+        if (o1 == null) {\n+            throw new RuntimeException();\n+        }\n+        if (o2 == null) {\n+            throw new RuntimeException();\n+        }\n+        Object o;\n+        if (flag1) {\n+            o = a;\n+            if (o == null) {\n+            }\n+        } else {\n+            if (flag2) {\n+                o = o1;\n+            } else {\n+                o = o2;\n+            }\n+        }\n+        dummyI((I)o);\n+    }\n+\n+    @Run(test = \"test9\")\n+    @Warmup(10_000)\n+    private void test9Runner() {\n+        test9(true, true, a, a);\n+        test9(false, true, c, c);\n+        test9(false, false, d, d);\n+    }\n+\n+    \/\/ test that dominating subtype check is removed\n+    static Object fieldTest10;\n+    @Test\n+    @IR(phase = { CompilePhase.AFTER_PARSING }, counts = { IRNode.SUBTYPE_CHECK, \"2\" })\n+    @IR(phase = { CompilePhase.ITER_GVN1 }, counts = { IRNode.SUBTYPE_CHECK, \"1\" })\n+    public static void test10(boolean flag) {\n+        if (fieldTest10 instanceof I) {\n+            if (flag) {\n+                dummyI((I)fieldTest10);\n+            }\n+        }\n+    }\n+\n+    @Run(test = \"test10\")\n+    @Warmup(10_000)\n+    private void test10Runner() {\n+        fieldTest10 = a;\n+        test10(true);\n+        fieldTest10 = b;\n+        test10(false);\n+        fieldTest10 = c;\n+        test10(true);\n+        fieldTest10 = d;\n+        test10(false);\n+    }\n+\n+    static Object fieldTest11;\n+    @Test\n+    @IR(phase = { CompilePhase.AFTER_PARSING }, counts = { IRNode.SUBTYPE_CHECK, \"2\" })\n+    @IR(phase = { CompilePhase.PHASEIDEALLOOP_ITERATIONS }, counts = { IRNode.SUBTYPE_CHECK, \"1\" })\n+    public static void test11(boolean flag1, boolean flag2) {\n+        if (fieldTest11 instanceof I) {\n+            if (flag1) {\n+                for (int i = 1; i < 10; i *= 2) {\n+                }\n+            }\n+            if (flag2) {\n+                dummyI((I)fieldTest11);\n+            }\n+        }\n+    }\n+\n+    @Run(test = \"test11\")\n+    @Warmup(10_000)\n+    private void test11Runner() {\n+        fieldTest11 = a;\n+        test11(true, true);\n+        fieldTest11 = b;\n+        test11(false, false);\n+        fieldTest11 = c;\n+        test11(true, true);\n+        fieldTest11 = d;\n+        test11(false, false);\n+    }\n+\n+    static Object fieldTest12;\n+    @Test\n+    @IR(phase = { CompilePhase.AFTER_PARSING }, counts = { IRNode.SUBTYPE_CHECK, \"3\" })\n+    @IR(phase = { CompilePhase.PHASEIDEALLOOP_ITERATIONS }, counts = { IRNode.SUBTYPE_CHECK, \"1\" })\n+    public static void test12() {\n+        test12Helper(true);\n+    }\n+\n+    public static void test12Helper(boolean flag) {\n+        if (fieldTest12 instanceof I) {\n+            for (int i = 1; i < 10; i *= 2) {\n+            }\n+        }\n+        if (flag) {\n+            if (fieldTest12 instanceof I) {\n+                dummyI((I)fieldTest12);\n+            }\n+        }\n+    }\n+\n+    @Run(test = \"test12\")\n+    @Warmup(10_000)\n+    private void test12Runner() {\n+        fieldTest12 = a;\n+        test12();\n+        test12Helper(false);\n+        fieldTest12 = b;\n+        test12();\n+        test12Helper(false);\n+        fieldTest12 = c;\n+        test12();\n+        test12Helper(true);\n+        fieldTest12 = d;\n+        test12();\n+        test12Helper(true);\n+        fieldTest12 = e;\n+        test12();\n+    }\n+\n+    interface I {\n+    }\n+\n+\n+    static A a = new A();\n+    static B b = new B();\n+    static C c = new C();\n+    static D d = new D();\n+    static E e = new E();\n+\n+    static class A implements I {\n+    }\n+\n+    static class B extends A {\n+    }\n+\n+    static class C extends A {\n+    }\n+\n+    static class D extends A {\n+    }\n+\n+    static class E {\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/ProfileAtTypeCheck.java","additions":345,"deletions":0,"binary":false,"changes":345,"status":"added"},{"patch":"@@ -337,0 +337,5 @@\n+    public static final String CMP_P = PREFIX + \"CMP_P\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(CMP_P, \"CmpP\");\n+    }\n+\n@@ -843,0 +848,5 @@\n+    public static final String PARTIAL_SUBTYPE_CHECK = PREFIX + \"PARTIAL_SUBTYPE_CHECK\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(PARTIAL_SUBTYPE_CHECK, \"PartialSubtypeCheck\");\n+    }\n+\n@@ -1191,0 +1201,5 @@\n+    public static final String SUBTYPE_CHECK = PREFIX + \"SUBTYPE_CHECK\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(SUBTYPE_CHECK, \"SubTypeCheck\");\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"}]}