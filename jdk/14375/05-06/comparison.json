{"files":[{"patch":"@@ -2681,1 +2681,1 @@\n-                               Node_List* profile_entries) {\n+                               ciMethod* method, int bci) {\n@@ -2780,2 +2780,2 @@\n-  if (might_be_cache && profile_entries != nullptr) {\n-    assert(profile_entries->size() % 2 == 0, \"\");\n+  if (might_be_cache && method != nullptr) {\n+    ciCallProfile profile = method->call_profile_at_bci(bci);\n@@ -2783,4 +2783,6 @@\n-    for (uint i = 0; i < profile_entries->size(); i += 2) {\n-      Node* prob = profile_entries->at(i + 1);\n-      float p = prob->bottom_type()->getf();\n-      total_prob += p;\n+    for (int i = 0; ; ++i) {\n+      if (!profile.has_receiver(i)) {\n+        break;\n+      }\n+      float prob = profile.receiver_prob(i);\n+      total_prob += prob;\n@@ -2788,1 +2790,0 @@\n-\n@@ -2791,5 +2792,6 @@\n-      for (uint i = 0; i < profile_entries->size(); i += 2) {\n-        Node* klass = profile_entries->at(i);\n-        const TypeKlassPtr* klass_t = gvn.type(klass)->is_klassptr();\n-        Node* prob = profile_entries->at(i + 1);\n-\n+      for (int i = 0; ; ++i) {\n+        if (!profile.has_receiver(i)) {\n+          break;\n+        }\n+        ciKlass* klass = profile.receiver(i);\n+        const TypeKlassPtr* klass_t = TypeKlassPtr::make(klass);\n@@ -2800,2 +2802,3 @@\n-        float p = prob->bottom_type()->getf();\n-        IfNode* iff = gen_subtype_check_compare(*ctrl, subklass, klass, BoolTest::eq, p, gvn, T_ADDRESS);\n+        float prob = profile.receiver_prob(i);\n+        ConNode* klass_node = gvn.makecon(klass_t);\n+        IfNode* iff = gen_subtype_check_compare(*ctrl, subklass, klass_node, BoolTest::eq, prob, gvn, T_ADDRESS);\n@@ -2900,1 +2903,1 @@\n-    Node* n = Phase::gen_subtype_check(subklass, superklass, &ctrl, mem, _gvn, nullptr);\n+    Node* n = Phase::gen_subtype_check(subklass, superklass, &ctrl, mem, _gvn, method(), bci());\n@@ -2905,17 +2908,1 @@\n-  SubTypeCheckNode* subtypecheck = new SubTypeCheckNode(C, obj_or_subklass, superklass);\n-  const TypeKlassPtr* superklass_t = _gvn.type(superklass)->is_klassptr();\n-  \/\/ attach profile data to the SubTypeCheckNode\n-  ciCallProfile profile = method()->call_profile_at_bci(bci());\n-  for (int i = 0; ; ++i) {\n-    if (!profile.has_receiver(i)) {\n-      break;\n-    }\n-    ciKlass* klass = profile.receiver(i);\n-    const TypeKlassPtr* klass_t = TypeKlassPtr::make(klass);\n-    ConNode* klass_node = _gvn.makecon(klass_t);\n-    subtypecheck->add_req(klass_node);\n-    float prob = profile.receiver_prob(i);\n-    ConNode* prob_node = _gvn.makecon(TypeF::make(prob));\n-    subtypecheck->add_req(prob_node);\n-  }\n-  Node* check = _gvn.transform(subtypecheck);\n+  Node* check = _gvn.transform(new SubTypeCheckNode(C, obj_or_subklass, superklass, method(), bci()));\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":20,"deletions":33,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -1601,2 +1601,1 @@\n-      this_cmp == nullptr || !this_cmp->is_SubTypeCheck() ||\n-      (dom_cmp->req() == 3 && this_cmp->req() == 3)) {\n+      this_cmp == nullptr || !this_cmp->is_SubTypeCheck()) {\n","filename":"src\/hotspot\/share\/opto\/ifnode.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1740,0 +1740,2 @@\n+\n+  Node* similar_subtype_check(const Node* x, Node* r_in);\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -141,0 +141,3 @@\n+        if (y == nullptr) {\n+          y = similar_subtype_check(x, region->in(i));\n+        }\n@@ -218,0 +221,24 @@\n+\/\/ Subtype checks that carry profile data don't common so look for a replacement by following edges\n+Node* PhaseIdealLoop::similar_subtype_check(const Node* x, Node* r_in) {\n+  if (x->is_SubTypeCheck()) {\n+    Node* in1 = x->in(1);\n+    for (DUIterator_Fast imax, i = in1->fast_outs(imax); i < imax; i++) {\n+      Node* u = in1->fast_out(i);\n+      if (u != x && u->is_SubTypeCheck() && u->in(1) == x->in(1) && u->in(2) == x->in(2)) {\n+        for (DUIterator_Fast jmax, j = u->fast_outs(jmax); j < jmax; j++) {\n+          Node* bol = u->fast_out(j);\n+          for (DUIterator_Fast kmax, k = bol->fast_outs(kmax); k < kmax; k++) {\n+            Node* iff = bol->fast_out(k);\n+            \/\/ Only dominating subtype checks are interesting: otherwise we risk replacing a subtype check by another with\n+            \/\/ unrelated profile\n+            if (iff->is_If() && is_dominator(iff, r_in)) {\n+              return u;\n+            }\n+          }\n+        }\n+      }\n+    }\n+  }\n+  return nullptr;\n+}\n+\n@@ -1484,1 +1511,3 @@\n-      assert(n->in(1)->in(1)->is_SubTypeCheck() && (n->in(1)->in(1)->req() > 3 || dom_if->in(1)->in(1)->req() > 3), \"only for subtype checks with profile data attached\");\n+      assert(n->in(1)->in(1)->is_SubTypeCheck() &&\n+             (n->in(1)->in(1)->as_SubTypeCheck()->method() != nullptr ||\n+              dom_if->in(1)->in(1)->as_SubTypeCheck()->method() != nullptr), \"only for subtype checks with profile data attached\");\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":30,"deletions":1,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -2287,6 +2287,1 @@\n-    Node_List profile_entries;\n-    for (uint j = SubTypeCheckNode::ProfileEntry; j < check->req(); ++j) {\n-      profile_entries.push(check->in(j));\n-    }\n-\n-    Node* not_subtype_ctrl = Phase::gen_subtype_check(subklass, superklass, &ctrl, nullptr, _igvn, &profile_entries);\n+    Node* not_subtype_ctrl = Phase::gen_subtype_check(subklass, superklass, &ctrl, nullptr, _igvn, check->method(), check->bci());\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -636,1 +636,1 @@\n-      Node* not_subtype_ctrl = Phase::gen_subtype_check(src_klass, dest_klass, ctrl, mem, _igvn, nullptr);\n+      Node* not_subtype_ctrl = Phase::gen_subtype_check(src_klass, dest_klass, ctrl, mem, _igvn, nullptr, -1);\n","filename":"src\/hotspot\/share\/opto\/macroArrayCopy.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-class Node_List;\n@@ -144,1 +143,1 @@\n-  static Node* gen_subtype_check(Node* subklass, Node* superklass, Node** ctrl, Node* mem, PhaseGVN& gvn, Node_List* profile_entries);\n+  static Node* gen_subtype_check(Node* subklass, Node* superklass, Node** ctrl, Node* mem, PhaseGVN& gvn, ciMethod* method, int bci);\n","filename":"src\/hotspot\/share\/opto\/phase.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -228,1 +228,0 @@\n-\n@@ -230,0 +229,21 @@\n+\n+uint SubTypeCheckNode::size_of() const {\n+  return sizeof(*this);\n+}\n+\n+uint SubTypeCheckNode::hash() const {\n+  if (_method != nullptr) {\n+    return NO_HASH;\n+  }\n+  return Node::hash();\n+}\n+\n+#ifndef PRODUCT\n+void SubTypeCheckNode::dump_spec(outputStream* st) const {\n+  if (_method != nullptr) {\n+    st->print(\" profiled at: \");\n+    _method->print_short_name(st);\n+    st->print(\":%d\", _bci);\n+  }\n+}\n+#endif\n\\ No newline at end of file\n","filename":"src\/hotspot\/share\/opto\/subtypenode.cpp","additions":21,"deletions":1,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -35,2 +35,1 @@\n-    SuperKlass,\n-    ProfileEntry, \/\/ profile data can be attached to the node\n+    SuperKlass\n@@ -39,2 +38,2 @@\n-  SubTypeCheckNode(Compile* C, Node* obj_or_subklass, Node* superklass)\n-    : CmpNode(obj_or_subklass, superklass) {\n+  SubTypeCheckNode(Compile* C, Node* obj_or_subklass, Node* superklass, ciMethod* method, int bci)\n+    : CmpNode(obj_or_subklass, superklass), _method(method), _bci(bci) {\n@@ -52,1 +51,11 @@\n-  bool depends_only_on_test() const { return false; };\n+  bool depends_only_on_test() const { return false; }\n+\n+  ciMethod* method() const { return _method; }\n+  int bci() const { return _bci; }\n+\n+  uint size_of() const;\n+  uint hash() const;\n+\n+#ifndef PRODUCT\n+  void dump_spec(outputStream* st) const;\n+#endif\n@@ -54,1 +63,0 @@\n-#ifdef ASSERT\n@@ -56,0 +64,3 @@\n+  ciMethod* _method;\n+  int _bci;\n+#ifdef ASSERT\n@@ -60,1 +71,0 @@\n-#endif \/\/ ASSERT\n@@ -63,0 +73,1 @@\n+#endif \/\/ ASSERT\n","filename":"src\/hotspot\/share\/opto\/subtypenode.hpp","additions":18,"deletions":7,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.util.ArrayList;\n@@ -40,4 +41,4 @@\n-        if (Platform.is32bit()) {\n-            TestFramework.runWithFlags(\"-XX:TypeProfileSubTypeCheckCommonThreshold=90\");\n-        } else {\n-            TestFramework.runWithFlags(\"-XX:-UseCompressedClassPointers\", \"-XX:TypeProfileSubTypeCheckCommonThreshold=90\");\n+        ArrayList<String> flags = new ArrayList<>();\n+        flags.add(\"-XX:TypeProfileSubTypeCheckCommonThreshold=90\");\n+        if (!Platform.is32bit()) {\n+            flags.add(\"-XX:-UseCompressedClassPointers\");\n@@ -45,0 +46,3 @@\n+        flags.add(\"-XX:+IgnoreUnrecognizedVMOptions\");\n+        flags.add(\"-XX:+UseParallelGC\");\n+        TestFramework.runWithFlags(flags.toArray(new String[0]));\n@@ -321,0 +325,63 @@\n+    \/\/ Test that subtype checks with different profile don't common\n+    @Test\n+    @IR(phase = { CompilePhase.ITER_GVN1 }, counts = { IRNode.SUBTYPE_CHECK, \"2\" })\n+    public static void test13(boolean flag, Object o) {\n+        if (o == null) {\n+            throw new RuntimeException();\n+        }\n+        if (flag) {\n+            dummyI((I)o);\n+        } else {\n+            dummyI((I)o);\n+        }\n+    }\n+\n+    @Run(test = \"test13\")\n+    @Warmup(10_000)\n+    private void test13Runner() {\n+        test13(true, a);\n+        test13(true, b);\n+        test13(false, c);\n+        test13(false, d);\n+    }\n+\n+    static Object fieldTest14_1;\n+    static Object fieldTest14_2;\n+    \/\/ test that split if triggers\n+    @Test\n+    @IR(phase = { CompilePhase.AFTER_PARSING }, counts = { IRNode.SUBTYPE_CHECK, \"2\" })\n+    @IR(applyIf = { \"UseParallelGC\", \"true\" }, phase = { CompilePhase.PHASEIDEALLOOP1 }, counts = { IRNode.SUBTYPE_CHECK, \"3\" })\n+    public static void test14(boolean flag1, boolean flag2, Object o1, Object o2, Object o3) {\n+        if (o1 == null) {\n+            throw new RuntimeException();\n+        }\n+        if (o2 == null) {\n+            throw new RuntimeException();\n+        }\n+        if (o3 == null) {\n+            throw new RuntimeException();\n+        }\n+        Object o;\n+        if (flag1) {\n+            fieldTest14_1 = o3;\n+            fieldTest14_2 = (I)o3;\n+            o = fieldTest14_1;\n+        } else {\n+            if (flag2) {\n+                o = o1;\n+            } else {\n+                o = o2;\n+            }\n+        }\n+        dummyI((I)o);\n+    }\n+\n+    @Run(test = \"test14\")\n+    @Warmup(10_000)\n+    private void test14Runner() {\n+        test14(true, true, a, a, a);\n+        test14(true, true, b, b, b);\n+        test14(false, true, c, c, c);\n+        test14(false, false, d, d, d);\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/ProfileAtTypeCheck.java","additions":71,"deletions":4,"binary":false,"changes":75,"status":"modified"}]}