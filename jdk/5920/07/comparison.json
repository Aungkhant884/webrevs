{"files":[{"patch":"@@ -41,0 +41,1 @@\n+  IMAGE_HSDIS_DIR := $(JDK_IMAGE_DIR)\/bin\n@@ -58,0 +59,1 @@\n+      CXX := $(MINGW_BASE)-g++, \\\n@@ -104,0 +106,1 @@\n+  IMAGE_HSDIS_DIR := $(JDK_IMAGE_DIR)\/lib\n@@ -109,0 +112,20 @@\n+\n+  ifeq ($(HSDIS_BACKEND), llvm)\n+    # Use C++ instead of C\n+    HSDIS_TOOLCHAIN_CFLAGS := $(CXXFLAGS_JDKLIB)\n+    HSDIS_TOOLCHAIN := TOOLCHAIN_LINK_CXX\n+  endif\n+endif\n+\n+ifeq ($(HSDIS_BACKEND), llvm)\n+  ifeq ($(call isTargetOs, linux), true)\n+    LLVM_OS := pc-linux-gnu\n+  else ifeq ($(call isTargetOs, macosx), true)\n+    LLVM_OS := apple-darwin\n+  else ifeq ($(call isTargetOs, windows), true)\n+    LLVM_OS := pc-windows-msvc\n+  else\n+    $(error No support for LLVM on this platform)\n+  endif\n+\n+  HSDIS_CFLAGS += -DLLVM_DEFAULT_TRIPLET='\"$(OPENJDK_TARGET_CPU)-$(LLVM_OS)\"'\n@@ -114,1 +137,2 @@\n-    SRC := $(TOPDIR)\/src\/utils\/hsdis, \\\n+    SRC := $(TOPDIR)\/src\/utils\/hsdis\/$(HSDIS_BACKEND), \\\n+    EXTRA_HEADER_DIRS := $(TOPDIR)\/src\/utils\/hsdis, \\\n@@ -121,1 +145,1 @@\n-    LDFLAGS := $(HSDIS_TOOLCHAIN_LDFLAGS) $(SHARED_LIBRARY_FLAGS), \\\n+    LDFLAGS := $(HSDIS_TOOLCHAIN_LDFLAGS) $(HSDIS_LDFLAGS) $(SHARED_LIBRARY_FLAGS), \\\n@@ -132,0 +156,1 @@\n+INSTALLED_HSDIS_IMAGE := $(IMAGE_HSDIS_DIR)\/$(INSTALLED_HSDIS_NAME)\n@@ -134,1 +159,6 @@\n-\t$(call LogWarn, NOTE: The resulting build might not be redistributable. Seek legal advice before distibuting.)\n+ifeq ($(HSDIS_BACKEND), binutils)\n+\t$(call LogWarn, NOTE: The resulting build might not be redistributable. Seek legal advice before distributing.)\n+endif\n+\t$(install-file)\n+\n+$(INSTALLED_HSDIS_IMAGE): $(INSTALLED_HSDIS)\n@@ -138,1 +168,1 @@\n-install: $(INSTALLED_HSDIS)\n+install: $(INSTALLED_HSDIS_IMAGE)\n","filename":"make\/Hsdis.gmk","additions":34,"deletions":4,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -814,1 +814,1 @@\n-      [what hsdis backend to use ('none', 'binutils') @<:@none@:>@])])\n+      [what hsdis backend to use ('none', 'binutils', 'llvm') @<:@none@:>@])])\n@@ -822,0 +822,3 @@\n+  AC_ARG_WITH([llvm], [AS_HELP_STRING([--with-llvm],\n+      [where to find LLVM, needed for hsdis\/llvm])])\n+\n@@ -856,0 +859,1 @@\n+        HSDIS_LDFLAGS=\"\"\n@@ -891,0 +895,27 @@\n+  elif test \"x$with_hsdis\" = xllvm; then\n+    HSDIS_BACKEND=llvm\n+    AC_MSG_RESULT(['llvm'])\n+\n+    if test \"x$with_llvm\" != x; then\n+      LLVM_DIR=\"$with_llvm\"\n+    fi\n+\n+    if test \"x$LLVM_DIR\" != x; then\n+      UTIL_LOOKUP_PROGS(LLVM_CONFIG, llvm-config, [$LLVM_DIR\/bin])\n+      if test \"x$LLVM_CONFIG\" = x; then\n+        AC_MSG_NOTICE([Cannot locate llvm-config in $LLVM_DIR. Check your --with-llvm argument.])\n+        AC_MSG_ERROR([Cannot continue])\n+      fi\n+    else\n+      # Macs with homebrew can have llvm in different places\n+      UTIL_LOOKUP_PROGS(LLVM_CONFIG, llvm-config, [$PATH:\/usr\/local\/opt\/llvm\/bin:\/opt\/homebrew\/opt\/llvm\/bin])\n+      if test \"x$LLVM_CONFIG\" = x; then\n+        AC_MSG_NOTICE([Cannot locate llvm-config which is needed for hsdis\/llvm. Try using --with-llvm=<LLVM home>.])\n+        AC_MSG_ERROR([Cannot continue])\n+      fi\n+    fi\n+\n+    # We need the LLVM flags and libs, and llvm-config provides them for us.\n+    HSDIS_CFLAGS=`$LLVM_CONFIG --cflags`\n+    HSDIS_LDFLAGS=`$LLVM_CONFIG --ldflags`\n+    HSDIS_LIBS=`$LLVM_CONFIG --libs $OPENJDK_TARGET_CPU_ARCH ${OPENJDK_TARGET_CPU_ARCH}disassembler`\n@@ -898,0 +929,1 @@\n+  AC_SUBST(HSDIS_LDFLAGS)\n","filename":"make\/autoconf\/jdk-options.m4","additions":33,"deletions":1,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -364,0 +364,1 @@\n+HSDIS_LDFLAGS := @HSDIS_LDFLAGS@\n","filename":"make\/autoconf\/spec.gmk.in","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-Copyright (c) 2008, 2021, Oracle and\/or its affiliates. All rights reserved.\n+Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,1 +50,4 @@\n-* Building\n+hsdis is an interface exposed by Hotspot. There are several backends that\n+implement this interface, using different disassembly engines. Included in the\n+JDK is support for building hsdis with LLVM or GNU binutils.The interface is\n+fairly straightforward and easy to implement using other backends.\n@@ -52,3 +55,30 @@\n-To build this project you need a copy of GNU binutils to build against. It is\n-known to work with binutils 2.37. Building against versions older than 2.29 is\n-not supported. Download a copy of the software from\n+* Building and installing\n+\n+To compile hsdis, you need to activate hsdis support, and select the proper\n+backend to use. This is done with the configure switch --with-hsdis=<backend>,\n+where <backend> is either \"llvm\" or \"binutils\". For details, see the sections on\n+the respective backends below.\n+\n+To build the hsdis library, run \"make build-hsdis\". This will build the library\n+in a separate directory, but not make it available to the JDK in the\n+configuration. To actually install it in the JDK, run \"make install-hsdis\".\n+\n+NOTE: If you do this using the binutils backend, he resulting build may not be\n+distributable. Please get legal advice if you intend to distribute the result of\n+your build.\n+\n+* Using the library\n+\n+The hsdis library will be automatically loaded by Hotspot when you use the\n+diagnostic option \"-XX:+PrintAssembly\". Note that since this is a diagnostic\n+option, you need to unlock these first, so in practice you activate it using\n+\"-XX:+UnlockDiagnosticVMOptions -XX:+PrintAssembly\".\n+\n+More information is available at the wiki\n+[https:\/\/wiki.openjdk.java.net\/display\/HotSpot\/PrintAssembly].\n+\n+* Building with binutils\n+\n+To build this project using binutils you need a copy of GNU binutils to build\n+against. It is known to work with binutils 2.37. Building against versions older\n+than 2.29 is not supported. Download a copy of the software from\n@@ -74,4 +104,1 @@\n-When you have created a proper configuration, you can then build the hsdis\n-library using \"make build-hsdis\".\n-\n-* Building on Windows\n+* Building with binutils on Windows\n@@ -85,1 +112,1 @@\n-* Installing\n+* Building with LLVM\n@@ -87,3 +114,3 @@\n-To build the hsdis library, run \"make build-hsdis\". This will build the library\n-in a separate directory, but not make it available to the JDK in the\n-configuration. To actually install it in the JDK, run \"make install-hsdis\".\n+To build this project using LLVM you need to have LLVM installed. Typical ways\n+of installation can be \"sudo apt install llvm\" (on Debian and derivatives),\n+or \"brew install llvm\" (on macOS with Homebrew).\n@@ -91,2 +118,2 @@\n-Note: The resulting build may not be distributable. Please get legal advice if\n-you intend to distribute the result of your build.\n+This has been tested with LLVM v13.0.0, but earlier (and later) versions are\n+also likely to work.\n@@ -94,1 +121,2 @@\n-* Using the library\n+To build hsdis using LLVM, you must enable it in configure by \"bash configure\n+--with-hsdis=llvm\".\n@@ -96,7 +124,3 @@\n-The hsdis library will be automatically loaded by Hotspot when you use the\n-diagnostic option \"-XX:+PrintAssembly\". Note that since this is a diagnostic\n-option, you need to unlock these first, so in practice you activate it using\n-\"-XX:+UnlockDiagnosticVMOptions -XX:+PrintAssembly\".\n-\n-More information is available at the wiki\n-[https:\/\/wiki.openjdk.java.net\/display\/HotSpot\/PrintAssembly].\n+If llvm-config is not in your path, you will need to specify the LLVM home using\n+\"--with-llvm=<LLVM home>\". If your llvm-config is in ~\/my-llvm\/bin, then you\n+should use \"--with-llvm=~\/my-llvm\".\n","filename":"src\/utils\/hsdis\/README","additions":47,"deletions":23,"binary":false,"changes":70,"status":"modified"},{"patch":"","filename":"src\/utils\/hsdis\/binutils\/hsdis-binutils.c","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"src\/utils\/hsdis\/hsdis.c","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2012, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -75,0 +75,5 @@\n+#ifdef __cplusplus\n+extern \"C\"\n+{\n+#endif\n+\n@@ -76,2 +81,2 @@\n-#ifdef DLL_EXPORT\n-  DLL_EXPORT\n+#ifdef _WIN32\n+__declspec(dllexport)\n@@ -90,2 +95,2 @@\n-#ifdef DLL_ENTRY\n-  DLL_ENTRY\n+#ifdef _WIN32\n+__declspec(dllexport)\n@@ -118,0 +123,5 @@\n+\n+#ifdef __cplusplus\n+}\n+#endif\n+\n","filename":"src\/utils\/hsdis\/hsdis.h","additions":15,"deletions":5,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -0,0 +1,358 @@\n+\/*\n+ * Copyright (c) 2008, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The Universal Permissive License (UPL), Version 1.0\n+ *\n+ * Subject to the condition set forth below, permission is hereby granted to\n+ * any person obtaining a copy of this software, associated documentation\n+ * and\/or data (collectively the \"Software\"), free of charge and under any\n+ * and all copyright rights in the Software, and any and all patent rights\n+ * owned or freely licensable by each licensor hereunder covering either (i)\n+ * the unmodified Software as contributed to or provided by such licensor,\n+ * or (ii) the Larger Works (as defined below), to deal in both\n+ *\n+ * (a) the Software, and\n+ *\n+ * (b) any piece of software and\/or hardware listed in the lrgrwrks.txt file\n+ * if one is included with the Software (each a \"Larger Work\" to which the\n+ * Software is contributed by such licensors),\n+ *\n+ * without restriction, including without limitation the rights to copy,\n+ * create derivative works of, display, perform, and distribute the Software\n+ * and make, use, sell, offer for sale, import, export, have made, and have\n+ * sold the Software and the Larger Work(s), and to sublicense the foregoing\n+ * rights on either these or other terms.\n+ *\n+ * This license is subject to the following condition:\n+ *\n+ * The above copyright notice and either this complete permission notice or\n+ * at a minimum a reference to the UPL must be included in all copies or\n+ * substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n+ * NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n+ * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n+ * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n+ * USE OR OTHER DEALINGS IN THE SOFTWARE.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/* hsdis.cpp -- dump a range of addresses as native instructions\n+   This implements the plugin protocol required by the\n+   HotSpot PrintAssembly option.\n+*\/\n+\n+#include <stdlib.h>\n+#include <stdio.h>\n+#include <errno.h>\n+#include <inttypes.h>\n+#include <string.h>\n+\n+#include <llvm-c\/Disassembler.h>\n+#include <llvm-c\/DisassemblerTypes.h>\n+#include <llvm-c\/Target.h>\n+#include <llvm-c\/TargetMachine.h>\n+\n+#include \"hsdis.h\"\n+\n+\/* short names for stuff in hsdis.h *\/\n+typedef decode_instructions_event_callback_ftype  event_callback_t;\n+typedef decode_instructions_printf_callback_ftype printf_callback_t;\n+\n+class hsdis_backend_base {\n+ protected:\n+  uintptr_t         _start_va;\n+  uintptr_t         _end_va;\n+  unsigned char*    _buffer;\n+  uintptr_t         _length;\n+  event_callback_t  _event_callback;\n+  void*             _event_stream;\n+  printf_callback_t _printf_callback;\n+  void*             _printf_stream;\n+  int               _do_newline;\n+\n+  bool              _losing;\n+  const char*       _arch_name;\n+\n+  virtual void print_help(const char* msg, const char* arg) = 0;\n+  virtual void print_insns_config() = 0;\n+  virtual size_t decode_instruction(uintptr_t p, uintptr_t start, uintptr_t end) = 0;\n+  virtual const char* format_insn_close(const char* close, char* buf, size_t bufsize) = 0;\n+\n+ private:\n+  \/* ignore all events, return a null *\/\n+  static void* null_event_callback(void* ignore_stream, const char* ignore_event, void* arg) {\n+    return NULL;\n+  }\n+\n+  \/* print all events as XML markup *\/\n+  static void* xml_event_callback(void* stream, const char* event, void* arg) {\n+    FILE* fp = (FILE*) stream;\n+#define NS_PFX \"dis:\"\n+    if (event[0] != '\/') {\n+      \/* issue the tag, with or without a formatted argument *\/\n+      fprintf(fp, \"<\" NS_PFX);\n+      fprintf(fp, event, arg);\n+      fprintf(fp, \">\");\n+    } else {\n+      ++event;                    \/* skip slash *\/\n+      const char* argp = strchr(event, ' ');\n+      if (argp == NULL) {\n+        \/* no arguments; just issue the closing tag *\/\n+        fprintf(fp, \"<\/\" NS_PFX \"%s>\", event);\n+      } else {\n+        \/* split out the closing attributes as <dis:foo_done attr='val'\/> *\/\n+        int event_prefix = (argp - event);\n+        fprintf(fp, \"<\" NS_PFX \"%.*s_done\", event_prefix, event);\n+        fprintf(fp, argp, arg);\n+        fprintf(fp, \"\/><\/\" NS_PFX \"%.*s>\", event_prefix, event);\n+      }\n+    }\n+#undef NS_PFX\n+    return NULL;\n+  }\n+\n+protected:\n+  hsdis_backend_base(uintptr_t start_va, uintptr_t end_va,\n+                     unsigned char* buffer, uintptr_t length,\n+                     event_callback_t  event_callback,  void* event_stream,\n+                     printf_callback_t printf_callback, void* printf_stream,\n+                     int do_newline) :\n+      _start_va(start_va), _end_va(end_va),\n+      _buffer(buffer), _length(length),\n+      _event_callback(event_callback), _event_stream(event_stream),\n+      _printf_callback(printf_callback), _printf_stream(printf_stream),\n+      _do_newline(do_newline),\n+      _losing(false), _arch_name(NULL)\n+  {\n+    \/* Make reasonable defaults for null callbacks.\n+      A non-null stream for a null callback is assumed to be a FILE* for output.\n+      Events are rendered as XML.\n+    *\/\n+    if (_printf_callback == NULL) {\n+      int (*fprintf_callback)(FILE*, const char*, ...) = &fprintf;\n+      FILE* fprintf_stream = stdout;\n+      _printf_callback = (printf_callback_t) fprintf_callback;\n+      if (_printf_stream == NULL)\n+        _printf_stream   = (void*)           fprintf_stream;\n+    }\n+    if (_event_callback == NULL) {\n+      if (_event_stream == NULL)\n+        _event_callback = (event_callback_t)&null_event_callback;\n+      else\n+        _event_callback = (event_callback_t)&xml_event_callback;\n+    }\n+  }\n+\n+ public:\n+  void* decode() {\n+    uintptr_t start = _start_va;\n+    uintptr_t end   = _end_va;\n+    uintptr_t p     = start;\n+\n+    (*_event_callback)(_event_stream, \"insns\", (void*)start);\n+\n+    print_insns_config();\n+\n+    while (p < end && !_losing) {\n+      (*_event_callback)(_event_stream, \"insn\", (void*) p);\n+\n+      size_t size = decode_instruction(p, start, end);\n+      if (size > 0)  p += size;\n+      else           _losing = true;\n+\n+      if (!_losing) {\n+        char buf[128];\n+        const char* insn_close = format_insn_close(\"\/insn\", buf, sizeof(buf));\n+        (*_event_callback)(_event_stream, insn_close, (void*) p);\n+\n+        if (_do_newline) {\n+          \/* follow each complete insn by a nice newline *\/\n+          (*_printf_callback)(_printf_stream, \"\\n\");\n+        }\n+      }\n+    }\n+\n+    if (_losing) (*_event_callback)(_event_stream, \"\/insns\", (void*) p);\n+    return (void*) p;\n+  }\n+};\n+\n+\n+class hsdis_backend : public hsdis_backend_base {\n+ private:\n+  LLVMDisasmContextRef      _dcontext;\n+  char                      _target_triple[128];\n+\n+  void parse_caller_options(const char* options) {\n+    memset(&_target_triple, 0, sizeof(_target_triple));\n+    const char* p;\n+    for (p = options; p != NULL; ) {\n+      const char* q = strchr(p, ',');\n+      size_t plen = (q == NULL) ? strlen(p) : ((q++) - p);\n+      if (plen == 4 && strncmp(p, \"help\", plen) == 0) {\n+        print_help(NULL, NULL);\n+      } else if (plen > 6 && strncmp(p, \"hsdis-\", 6) == 0) {\n+        \/\/ do not pass these to the next level\n+      } else if (plen >= 14 && strncmp(p, \"target_triple=\", 14) == 0) {\n+        char*  target_triple = _target_triple;\n+        size_t target_triple_size   = sizeof(_target_triple);\n+        target_triple_size -= 1;           \/*leave room for the null*\/\n+        if (plen > target_triple_size)  plen = target_triple_size;\n+        strncpy(target_triple, p, plen);\n+        target_triple[plen] = '\\0';\n+      }\n+      p = q;\n+    }\n+  }\n+\n+  const char* native_target_triple() {\n+    return LLVM_DEFAULT_TRIPLET;\n+  }\n+\n+ public:\n+  hsdis_backend(uintptr_t start_va, uintptr_t end_va,\n+                unsigned char* buffer, uintptr_t length,\n+                event_callback_t  event_callback,  void* event_stream,\n+                printf_callback_t printf_callback, void* printf_stream,\n+                const char* options, int newline)\n+    : hsdis_backend_base(start_va, end_va,\n+                         buffer, length,\n+                         event_callback, event_stream,\n+                         printf_callback, printf_stream,\n+                         newline),\n+      _dcontext(NULL) {\n+    \/* Look into _options for anything interesting. *\/\n+    if (options != NULL)\n+      parse_caller_options(options);\n+\n+    \/* Discover which architecture we are going to disassemble. *\/\n+    _arch_name = &_target_triple[0];\n+    if (_arch_name[0] == '\\0')\n+      _arch_name = native_target_triple();\n+\n+    if (LLVMInitializeNativeTarget() != 0) {\n+      static bool complained = false;\n+      if (!complained)\n+        (*_printf_callback)(_printf_stream, \"failed to initialize LLVM native target\\n\");\n+      complained = true;\n+      \/* must bail out *\/\n+      _losing = true;\n+      return;\n+    }\n+    if (LLVMInitializeNativeAsmPrinter() != 0) {\n+      static bool complained = false;\n+      if (!complained)\n+        (*_printf_callback)(_printf_stream, \"failed to initialize LLVM native asm printer\\n\");\n+      complained = true;\n+      \/* must bail out *\/\n+      _losing = true;\n+      return;\n+    }\n+    if (LLVMInitializeNativeDisassembler() != 0) {\n+      static bool complained = false;\n+      if (!complained)\n+        (*_printf_callback)(_printf_stream, \"failed to initialize LLVM native disassembler\\n\");\n+      complained = true;\n+      \/* must bail out *\/\n+      _losing = true;\n+      return;\n+    }\n+    if ((_dcontext = LLVMCreateDisasm(_arch_name, NULL, 0, NULL, NULL)) == NULL) {\n+      static bool complained = false;\n+      const char* bad = _arch_name;\n+      if (bad == &_target_triple[0])\n+        print_help(\"bad target_triple=%s\", bad);\n+      else if (!complained)\n+        print_help(\"bad native target_triple=%s; please port hsdis to this platform\", bad);\n+      complained = true;\n+      \/* must bail out *\/\n+      _losing = true;\n+      return;\n+    }\n+\n+    LLVMSetDisasmOptions(_dcontext, LLVMDisassembler_Option_PrintImmHex);\n+  }\n+\n+  ~hsdis_backend() {\n+    if (_dcontext != NULL) {\n+      LLVMDisasmDispose(_dcontext);\n+    }\n+  }\n+\n+ protected:\n+  virtual void print_help(const char* msg, const char* arg) {\n+    if (msg != NULL) {\n+      (*_printf_callback)(_printf_stream, \"hsdis: \");\n+      (*_printf_callback)(_printf_stream, msg, arg);\n+      (*_printf_callback)(_printf_stream, \"\\n\");\n+    }\n+    (*_printf_callback)(_printf_stream, \"hsdis output options:\\n\");\n+    (*_printf_callback)(_printf_stream, \"  target_triple=<triple> select disassembly target\\n\");\n+    (*_printf_callback)(_printf_stream, \"  help          print this message\\n\");\n+  }\n+\n+  virtual void print_insns_config() {\n+    (*_event_callback)(_event_stream, \"target_triple name='%s'\",\n+                      (void*) _arch_name);\n+  }\n+\n+  virtual size_t decode_instruction(uintptr_t p, uintptr_t start, uintptr_t end) {\n+    char buf[128];\n+    size_t size = LLVMDisasmInstruction(_dcontext, (uint8_t*)p, (uint64_t)(end - start), (uint64_t)p, buf, sizeof(buf));\n+    if (size > 0) {\n+      (*_printf_callback)(_printf_stream, \"%s\", buf);\n+    } else {\n+      \/\/ LLVM encountered an unknown instruction\n+      if (end - start >= 4) {\n+        \/\/ Print the following word and skip past it\n+        snprintf(buf, sizeof(buf), \"\\t.inst\\t#0x%08x ; undefined\", *(uint32_t*)p);\n+        size = 4;\n+      } else {\n+        snprintf(buf, sizeof(buf), \"\\t<invalid instruction, aborting hsdis>\");\n+      }\n+    }\n+    return size;\n+  }\n+\n+  virtual const char* format_insn_close(const char* close, char* buf, size_t bufsize) {\n+    return close;\n+  }\n+};\n+\n+\n+void* decode_instructions_virtual(uintptr_t start_va, uintptr_t end_va,\n+                            unsigned char* buffer, uintptr_t length,\n+                            event_callback_t  event_callback_arg,  void* event_stream_arg,\n+                            printf_callback_t printf_callback_arg, void* printf_stream_arg,\n+                            const char* options, int newline) {\n+  return hsdis_backend(start_va, end_va,\n+                       buffer, length,\n+                       event_callback_arg, event_stream_arg,\n+                       printf_callback_arg, printf_stream_arg,\n+                       options, newline == 0 ? false : true)\n+          .decode();\n+}\n+\n+\/* This is the compatability interface for older version of hotspot *\/\n+void* decode_instructions(void* start_pv, void* end_pv,\n+                    event_callback_t  event_callback_arg,  void* event_stream_arg,\n+                    printf_callback_t printf_callback_arg, void* printf_stream_arg,\n+                    const char* options) {\n+  return decode_instructions_virtual((uintptr_t)start_pv,\n+                                     (uintptr_t)end_pv,\n+                                     (unsigned char*)start_pv,\n+                                     (uintptr_t)end_pv - (uintptr_t)start_pv,\n+                                     event_callback_arg,\n+                                     event_stream_arg,\n+                                     printf_callback_arg,\n+                                     printf_stream_arg,\n+                                     options, false);\n+}\n","filename":"src\/utils\/hsdis\/llvm\/hsdis-llvm.cpp","additions":358,"deletions":0,"binary":false,"changes":358,"status":"added"}]}