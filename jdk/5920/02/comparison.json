{"files":[{"patch":"@@ -58,0 +58,1 @@\n+      CXX := $(MINGW_BASE)-g++, \\\n@@ -109,0 +110,20 @@\n+\n+  ifeq ($(HSDIS_BACKEND), llvm)\n+    # Use C++ instead of C\n+    HSDIS_TOOLCHAIN_CFLAGS := $(CXXFLAGS_JDKLIB)\n+    HSDIS_TOOLCHAIN := TOOLCHAIN_LINK_CXX\n+  endif\n+endif\n+\n+ifeq ($(HSDIS_BACKEND), llvm)\n+  ifeq ($(call isTargetOs, linux), true)\n+    LLVM_OS := pc-linux-gnu\n+  else ifeq ($(call isTargetOs, macosx), true)\n+    LLVM_OS := apple-darwin\n+  else ifeq ($(call isTargetOs, windows), true)\n+    LLVM_OS := pc-windows-msvc\n+  else\n+    $(error No support for LLVM on this platform)\n+  endif\n+\n+  HSDIS_CFLAGS += -DLLVM_DEFAULT_TRIPLET='\"$(OPENJDK_TARGET_CPU)-$(LLVM_OS)\"'\n@@ -114,1 +135,2 @@\n-    SRC := $(TOPDIR)\/src\/utils\/hsdis, \\\n+    SRC := $(TOPDIR)\/src\/utils\/hsdis\/$(HSDIS_BACKEND), \\\n+    EXTRA_HEADER_DIRS := $(TOPDIR)\/src\/utils\/hsdis, \\\n@@ -121,1 +143,1 @@\n-    LDFLAGS := $(HSDIS_TOOLCHAIN_LDFLAGS) $(SHARED_LIBRARY_FLAGS), \\\n+    LDFLAGS := $(HSDIS_TOOLCHAIN_LDFLAGS) $(HSDIS_LDFLAGS) $(SHARED_LIBRARY_FLAGS), \\\n","filename":"make\/Hsdis.gmk","additions":24,"deletions":2,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -814,1 +814,1 @@\n-      [what hsdis backend to use ('none', 'binutils') @<:@none@:>@])])\n+      [what hsdis backend to use ('none', 'binutils', 'llvm') @<:@none@:>@])])\n@@ -856,0 +856,1 @@\n+        HSDIS_LDFLAGS=\"\"\n@@ -891,0 +892,14 @@\n+  elif test \"x$with_hsdis\" = xllvm; then\n+    HSDIS_BACKEND=llvm\n+    AC_MSG_RESULT(['llvm'])\n+    # Macs with homebrew can have llvm in different places\n+    UTIL_LOOKUP_PROGS(LLVM_CONFIG, llvm-config, [$PATH:\/usr\/local\/opt\/llvm\/bin:\/opt\/homebrew\/opt\/llvm\/bin])\n+    if test \"x$LLVM_CONFIG\" = x; then\n+      AC_MSG_NOTICE([Cannot locate llvm-config which is needed for hsdis\/llvm. Try using LLVM_CONFIG=<path>.])\n+      AC_MSG_ERROR([Cannot continue])\n+    fi\n+\n+    # We need the LLVM flags and libs, and llvm-config provides them for us.\n+    HSDIS_CFLAGS=`$LLVM_CONFIG --cflags`\n+    HSDIS_LDFLAGS=`$LLVM_CONFIG --ldflags`\n+    HSDIS_LIBS=`$LLVM_CONFIG --libs $OPENJDK_TARGET_CPU_ARCH ${OPENJDK_TARGET_CPU_ARCH}disassembler`\n@@ -898,0 +913,1 @@\n+  AC_SUBST(HSDIS_LDFLAGS)\n","filename":"make\/autoconf\/jdk-options.m4","additions":17,"deletions":1,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -364,0 +364,1 @@\n+HSDIS_LDFLAGS := @HSDIS_LDFLAGS@\n","filename":"make\/autoconf\/spec.gmk.in","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"","filename":"src\/utils\/hsdis\/binutils\/hsdis-binutils.c","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"src\/utils\/hsdis\/hsdis.c","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2012, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -75,0 +75,5 @@\n+#ifdef __cplusplus\n+extern \"C\"\n+{\n+#endif\n+\n@@ -76,2 +81,2 @@\n-#ifdef DLL_EXPORT\n-  DLL_EXPORT\n+#ifdef _WIN32\n+__declspec(dllexport)\n@@ -90,2 +95,2 @@\n-#ifdef DLL_ENTRY\n-  DLL_ENTRY\n+#ifdef _WIN32\n+__declspec(dllexport)\n@@ -118,0 +123,5 @@\n+\n+#ifdef __cplusplus\n+}\n+#endif\n+\n","filename":"src\/utils\/hsdis\/hsdis.h","additions":15,"deletions":5,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -0,0 +1,349 @@\n+\/*\n+ * Copyright (c) 2008, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The Universal Permissive License (UPL), Version 1.0\n+ *\n+ * Subject to the condition set forth below, permission is hereby granted to\n+ * any person obtaining a copy of this software, associated documentation\n+ * and\/or data (collectively the \"Software\"), free of charge and under any\n+ * and all copyright rights in the Software, and any and all patent rights\n+ * owned or freely licensable by each licensor hereunder covering either (i)\n+ * the unmodified Software as contributed to or provided by such licensor,\n+ * or (ii) the Larger Works (as defined below), to deal in both\n+ *\n+ * (a) the Software, and\n+ *\n+ * (b) any piece of software and\/or hardware listed in the lrgrwrks.txt file\n+ * if one is included with the Software (each a \"Larger Work\" to which the\n+ * Software is contributed by such licensors),\n+ *\n+ * without restriction, including without limitation the rights to copy,\n+ * create derivative works of, display, perform, and distribute the Software\n+ * and make, use, sell, offer for sale, import, export, have made, and have\n+ * sold the Software and the Larger Work(s), and to sublicense the foregoing\n+ * rights on either these or other terms.\n+ *\n+ * This license is subject to the following condition:\n+ *\n+ * The above copyright notice and either this complete permission notice or\n+ * at a minimum a reference to the UPL must be included in all copies or\n+ * substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n+ * NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n+ * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n+ * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n+ * USE OR OTHER DEALINGS IN THE SOFTWARE.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/* hsdis.cpp -- dump a range of addresses as native instructions\n+   This implements the plugin protocol required by the\n+   HotSpot PrintAssembly option.\n+*\/\n+\n+#include <stdlib.h>\n+#include <stdio.h>\n+#include <errno.h>\n+#include <inttypes.h>\n+#include <string.h>\n+\n+#include <llvm-c\/Disassembler.h>\n+#include <llvm-c\/DisassemblerTypes.h>\n+#include <llvm-c\/Target.h>\n+#include <llvm-c\/TargetMachine.h>\n+\n+#include \"hsdis.h\"\n+\n+\/* short names for stuff in hsdis.h *\/\n+typedef decode_instructions_event_callback_ftype  event_callback_t;\n+typedef decode_instructions_printf_callback_ftype printf_callback_t;\n+\n+class hsdis_backend_base {\n+ protected:\n+  uintptr_t         _start_va;\n+  uintptr_t         _end_va;\n+  unsigned char*    _buffer;\n+  uintptr_t         _length;\n+  event_callback_t  _event_callback;\n+  void*             _event_stream;\n+  printf_callback_t _printf_callback;\n+  void*             _printf_stream;\n+  int               _do_newline;\n+\n+  bool              _losing;\n+  const char*       _arch_name;\n+\n+  virtual void print_help(const char* msg, const char* arg) = 0;\n+  virtual void print_insns_config() = 0;\n+  virtual size_t decode_instruction(uintptr_t p, uintptr_t start, uintptr_t end) = 0;\n+  virtual const char* format_insn_close(const char* close, char* buf, size_t bufsize) = 0;\n+\n+ private:\n+  \/* ignore all events, return a null *\/\n+  static void* null_event_callback(void* ignore_stream, const char* ignore_event, void* arg) {\n+    return NULL;\n+  }\n+\n+  \/* print all events as XML markup *\/\n+  static void* xml_event_callback(void* stream, const char* event, void* arg) {\n+    FILE* fp = (FILE*) stream;\n+#define NS_PFX \"dis:\"\n+    if (event[0] != '\/') {\n+      \/* issue the tag, with or without a formatted argument *\/\n+      fprintf(fp, \"<\" NS_PFX);\n+      fprintf(fp, event, arg);\n+      fprintf(fp, \">\");\n+    } else {\n+      ++event;                    \/* skip slash *\/\n+      const char* argp = strchr(event, ' ');\n+      if (argp == NULL) {\n+        \/* no arguments; just issue the closing tag *\/\n+        fprintf(fp, \"<\/\" NS_PFX \"%s>\", event);\n+      } else {\n+        \/* split out the closing attributes as <dis:foo_done attr='val'\/> *\/\n+        int event_prefix = (argp - event);\n+        fprintf(fp, \"<\" NS_PFX \"%.*s_done\", event_prefix, event);\n+        fprintf(fp, argp, arg);\n+        fprintf(fp, \"\/><\/\" NS_PFX \"%.*s>\", event_prefix, event);\n+      }\n+    }\n+#undef NS_PFX\n+    return NULL;\n+  }\n+\n+protected:\n+  hsdis_backend_base(uintptr_t start_va, uintptr_t end_va,\n+                     unsigned char* buffer, uintptr_t length,\n+                     event_callback_t  event_callback,  void* event_stream,\n+                     printf_callback_t printf_callback, void* printf_stream,\n+                     int do_newline) :\n+      _start_va(start_va), _end_va(end_va),\n+      _buffer(buffer), _length(length),\n+      _event_callback(event_callback), _event_stream(event_stream),\n+      _printf_callback(printf_callback), _printf_stream(printf_stream),\n+      _do_newline(do_newline),\n+      _losing(false), _arch_name(NULL)\n+  {\n+    \/* Make reasonable defaults for null callbacks.\n+      A non-null stream for a null callback is assumed to be a FILE* for output.\n+      Events are rendered as XML.\n+    *\/\n+    if (_printf_callback == NULL) {\n+      int (*fprintf_callback)(FILE*, const char*, ...) = &fprintf;\n+      FILE* fprintf_stream = stdout;\n+      _printf_callback = (printf_callback_t) fprintf_callback;\n+      if (_printf_stream == NULL)\n+        _printf_stream   = (void*)           fprintf_stream;\n+    }\n+    if (_event_callback == NULL) {\n+      if (_event_stream == NULL)\n+        _event_callback = (event_callback_t)&null_event_callback;\n+      else\n+        _event_callback = (event_callback_t)&xml_event_callback;\n+    }\n+  }\n+\n+ public:\n+  void* decode() {\n+    uintptr_t start = _start_va;\n+    uintptr_t end   = _end_va;\n+    uintptr_t p     = start;\n+\n+    (*_event_callback)(_event_stream, \"insns\", (void*)start);\n+\n+    print_insns_config();\n+\n+    while (p < end && !_losing) {\n+      (*_event_callback)(_event_stream, \"insn\", (void*) p);\n+\n+      size_t size = decode_instruction(p, start, end);\n+      if (size > 0)  p += size;\n+      else           _losing = true;\n+\n+      if (!_losing) {\n+        char buf[128];\n+        const char* insn_close = format_insn_close(\"\/insn\", buf, sizeof(buf));\n+        (*_event_callback)(_event_stream, insn_close, (void*) p);\n+\n+        if (_do_newline) {\n+          \/* follow each complete insn by a nice newline *\/\n+          (*_printf_callback)(_printf_stream, \"\\n\");\n+        }\n+      }\n+    }\n+\n+    if (_losing) (*_event_callback)(_event_stream, \"\/insns\", (void*) p);\n+    return (void*) p;\n+  }\n+};\n+\n+\n+class hsdis_backend : public hsdis_backend_base {\n+ private:\n+  LLVMDisasmContextRef      _dcontext;\n+  char                      _target_triple[128];\n+\n+  void parse_caller_options(const char* options) {\n+    memset(&_target_triple, 0, sizeof(_target_triple));\n+    const char* p;\n+    for (p = options; p != NULL; ) {\n+      const char* q = strchr(p, ',');\n+      size_t plen = (q == NULL) ? strlen(p) : ((q++) - p);\n+      if (plen == 4 && strncmp(p, \"help\", plen) == 0) {\n+        print_help(NULL, NULL);\n+      } else if (plen > 6 && strncmp(p, \"hsdis-\", 6) == 0) {\n+        \/\/ do not pass these to the next level\n+      } else if (plen >= 14 && strncmp(p, \"target_triple=\", 14) == 0) {\n+        char*  target_triple = _target_triple;\n+        size_t target_triple_size   = sizeof(_target_triple);\n+        target_triple_size -= 1;           \/*leave room for the null*\/\n+        if (plen > target_triple_size)  plen = target_triple_size;\n+        strncpy(target_triple, p, plen);\n+        target_triple[plen] = '\\0';\n+      }\n+      p = q;\n+    }\n+  }\n+\n+  const char* native_target_triple() {\n+    return LLVM_DEFAULT_TRIPLET;\n+  }\n+\n+ public:\n+  hsdis_backend(uintptr_t start_va, uintptr_t end_va,\n+                unsigned char* buffer, uintptr_t length,\n+                event_callback_t  event_callback,  void* event_stream,\n+                printf_callback_t printf_callback, void* printf_stream,\n+                const char* options, int newline)\n+    : hsdis_backend_base(start_va, end_va,\n+                         buffer, length,\n+                         event_callback, event_stream,\n+                         printf_callback, printf_stream,\n+                         newline),\n+      _dcontext(NULL) {\n+    \/* Look into _options for anything interesting. *\/\n+    if (options != NULL)\n+      parse_caller_options(options);\n+\n+    \/* Discover which architecture we are going to disassemble. *\/\n+    _arch_name = &_target_triple[0];\n+    if (_arch_name[0] == '\\0')\n+      _arch_name = native_target_triple();\n+\n+    if (LLVMInitializeNativeTarget() != 0) {\n+      static bool complained = false;\n+      if (!complained)\n+        (*_printf_callback)(_printf_stream, \"failed to initialize LLVM native target\\n\");\n+      complained = true;\n+      \/* must bail out *\/\n+      _losing = true;\n+      return;\n+    }\n+    if (LLVMInitializeNativeAsmPrinter() != 0) {\n+      static bool complained = false;\n+      if (!complained)\n+        (*_printf_callback)(_printf_stream, \"failed to initialize LLVM native asm printer\\n\");\n+      complained = true;\n+      \/* must bail out *\/\n+      _losing = true;\n+      return;\n+    }\n+    if (LLVMInitializeNativeDisassembler() != 0) {\n+      static bool complained = false;\n+      if (!complained)\n+        (*_printf_callback)(_printf_stream, \"failed to initialize LLVM native disassembler\\n\");\n+      complained = true;\n+      \/* must bail out *\/\n+      _losing = true;\n+      return;\n+    }\n+    if ((_dcontext = LLVMCreateDisasm(_arch_name, NULL, 0, NULL, NULL)) == NULL) {\n+      static bool complained = false;\n+      const char* bad = _arch_name;\n+      if (bad == &_target_triple[0])\n+        print_help(\"bad target_triple=%s\", bad);\n+      else if (!complained)\n+        print_help(\"bad native target_triple=%s; please port hsdis to this platform\", bad);\n+      complained = true;\n+      \/* must bail out *\/\n+      _losing = true;\n+      return;\n+    }\n+\n+    LLVMSetDisasmOptions(_dcontext, LLVMDisassembler_Option_PrintImmHex);\n+  }\n+\n+  ~hsdis_backend() {\n+    if (_dcontext != NULL) {\n+      LLVMDisasmDispose(_dcontext);\n+    }\n+  }\n+\n+ protected:\n+  virtual void print_help(const char* msg, const char* arg) {\n+    if (msg != NULL) {\n+      (*_printf_callback)(_printf_stream, \"hsdis: \");\n+      (*_printf_callback)(_printf_stream, msg, arg);\n+      (*_printf_callback)(_printf_stream, \"\\n\");\n+    }\n+    (*_printf_callback)(_printf_stream, \"hsdis output options:\\n\");\n+    (*_printf_callback)(_printf_stream, \"  target_triple=<triple> select disassembly target\\n\");\n+    (*_printf_callback)(_printf_stream, \"  help          print this message\\n\");\n+  }\n+\n+  virtual void print_insns_config() {\n+    (*_event_callback)(_event_stream, \"target_triple name='%s'\",\n+                      (void*) _arch_name);\n+  }\n+\n+  virtual size_t decode_instruction(uintptr_t p, uintptr_t start, uintptr_t end) {\n+    char buf[128];\n+    size_t size = LLVMDisasmInstruction(_dcontext, (uint8_t*)p, (uint64_t)(end - start), (uint64_t)p, buf, sizeof(buf));\n+    if (size > 0) {\n+      (*_printf_callback)(_printf_stream, \"%s\", buf);\n+    }\n+    return size;\n+  }\n+\n+  virtual const char* format_insn_close(const char* close, char* buf, size_t bufsize) {\n+    return close;\n+  }\n+};\n+\n+\n+void* decode_instructions_virtual(uintptr_t start_va, uintptr_t end_va,\n+                            unsigned char* buffer, uintptr_t length,\n+                            event_callback_t  event_callback_arg,  void* event_stream_arg,\n+                            printf_callback_t printf_callback_arg, void* printf_stream_arg,\n+                            const char* options, int newline) {\n+  return hsdis_backend(start_va, end_va,\n+                       buffer, length,\n+                       event_callback_arg, event_stream_arg,\n+                       printf_callback_arg, printf_stream_arg,\n+                       options, newline == 0 ? false : true)\n+          .decode();\n+}\n+\n+\/* This is the compatability interface for older version of hotspot *\/\n+void* decode_instructions(void* start_pv, void* end_pv,\n+                    event_callback_t  event_callback_arg,  void* event_stream_arg,\n+                    printf_callback_t printf_callback_arg, void* printf_stream_arg,\n+                    const char* options) {\n+  return decode_instructions_virtual((uintptr_t)start_pv,\n+                                     (uintptr_t)end_pv,\n+                                     (unsigned char*)start_pv,\n+                                     (uintptr_t)end_pv - (uintptr_t)start_pv,\n+                                     event_callback_arg,\n+                                     event_stream_arg,\n+                                     printf_callback_arg,\n+                                     printf_stream_arg,\n+                                     options, false);\n+}\n","filename":"src\/utils\/hsdis\/llvm\/hsdis-llvm.cpp","additions":349,"deletions":0,"binary":false,"changes":349,"status":"added"}]}