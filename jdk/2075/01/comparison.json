{"files":[{"patch":"@@ -568,0 +568,1 @@\n+                  _skeleton_predicate_opaqs (comp_arena(), 8, 0, NULL),\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -318,0 +318,1 @@\n+  GrowableArray<Node*>  _skeleton_predicate_opaqs; \/\/ List of Opaque4 nodes for the loop skeleton predicates.\n@@ -660,1 +661,2 @@\n-  int           predicate_count()         const { return _predicate_opaqs.length();}\n+  int           predicate_count()         const { return _predicate_opaqs.length(); }\n+  int           skeleton_predicate_count() const { return _skeleton_predicate_opaqs.length(); }\n@@ -664,1 +666,3 @@\n-  Node*         predicate_opaque1_node(int idx) const { return _predicate_opaqs.at(idx);}\n+  Node*         predicate_opaque1_node(int idx) const { return _predicate_opaqs.at(idx); }\n+  Node*         skeleton_predicate_opaque4_node(int idx) const { return _skeleton_predicate_opaqs.at(idx); }\n+  void          remove_skeleton_predicate_opaque4_node(int idx) { _skeleton_predicate_opaqs.remove_at(idx); }\n@@ -692,0 +696,4 @@\n+  void add_skeleton_predicate_opaq(Node* n) {\n+    assert(!_skeleton_predicate_opaqs.contains(n), \"duplicate entry in skeleton predicate opaque4 list\");\n+    _skeleton_predicate_opaqs.append(n);\n+  }\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -234,1 +234,0 @@\n-  IfNode* iff = old_predicate_proj->in(0)->as_If();\n@@ -236,5 +235,3 @@\n-  ProjNode* uncommon_proj = iff->proj_out(1 - old_predicate_proj->as_Proj()->_con);\n-  Node* rgn = uncommon_proj->unique_ctrl_out();\n-  assert(rgn->is_Region() || rgn->is_Call(), \"must be a region or call uct\");\n-  assert(iff->in(1)->in(1)->Opcode() == Op_Opaque1, \"unexpected predicate shape\");\n-  Node* predicate = iff->in(0);\n+  \/\/ Only need to clone range check predicates as those can be changed and duplicated by inserting pre\/main\/post loops\n+  \/\/ and doing loop unrolling. Push the original predicates on a list to later process them in reverse order to keep the\n+  \/\/ original predicate order.\n@@ -242,13 +239,1 @@\n-  while (predicate != NULL && predicate->is_Proj() && predicate->in(0)->is_If()) {\n-    iff = predicate->in(0)->as_If();\n-    uncommon_proj = iff->proj_out(1 - predicate->as_Proj()->_con);\n-    if (uncommon_proj->unique_ctrl_out() != rgn)\n-      break;\n-    if (iff->in(1)->Opcode() == Op_Opaque4 && skeleton_predicate_has_opaque(iff)) {\n-      \/\/ Only need to clone range check predicates as those can be changed and duplicated by inserting pre\/main\/post loops\n-      \/\/ and doing loop unrolling. Push the original predicates on a list to later process them in reverse order to keep the\n-      \/\/ original predicate order.\n-      list.push(predicate);\n-    }\n-    predicate = predicate->in(0)->in(0);\n-  }\n+  get_skeleton_predicates(old_predicate_proj, list);\n@@ -257,0 +242,2 @@\n+  IfNode* iff = old_predicate_proj->in(0)->as_If();\n+  ProjNode* uncommon_proj = iff->proj_out(1 - old_predicate_proj->as_Proj()->_con);\n@@ -260,1 +247,1 @@\n-    predicate = list.at(i);\n+    Node* predicate = list.at(i);\n@@ -291,0 +278,28 @@\n+\/\/ Put all skeleton predicate projections on a list, starting at 'predicate' and going up in the tree. If 'get_opaque'\n+\/\/ is set, then the Opaque4 nodes of the skeleton predicates are put on the list instead of the projections.\n+void PhaseIdealLoop::get_skeleton_predicates(Node* predicate, Unique_Node_List& list, bool get_opaque) {\n+  IfNode* iff = predicate->in(0)->as_If();\n+  ProjNode* uncommon_proj = iff->proj_out(1 - predicate->as_Proj()->_con);\n+  Node* rgn = uncommon_proj->unique_ctrl_out();\n+  assert(rgn->is_Region() || rgn->is_Call(), \"must be a region or call uct\");\n+  assert(iff->in(1)->in(1)->Opcode() == Op_Opaque1, \"unexpected predicate shape\");\n+  predicate = iff->in(0);\n+  while (predicate != NULL && predicate->is_Proj() && predicate->in(0)->is_If()) {\n+    iff = predicate->in(0)->as_If();\n+    uncommon_proj = iff->proj_out(1 - predicate->as_Proj()->_con);\n+    if (uncommon_proj->unique_ctrl_out() != rgn) {\n+      break;\n+    }\n+    if (iff->in(1)->Opcode() == Op_Opaque4 && skeleton_predicate_has_opaque(iff)) {\n+      if (get_opaque) {\n+        \/\/ Collect the predicate Opaque4 node.\n+        list.push(iff->in(1));\n+      } else {\n+        \/\/ Collect the predicate projection.\n+        list.push(predicate);\n+      }\n+    }\n+    predicate = predicate->in(0)->in(0);\n+  }\n+}\n+\n@@ -1244,0 +1259,1 @@\n+  C->add_skeleton_predicate_opaq(opaque_bol);\n@@ -1261,0 +1277,1 @@\n+  C->add_skeleton_predicate_opaq(opaque_bol);\n","filename":"src\/hotspot\/share\/opto\/loopPredicate.cpp","additions":37,"deletions":20,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -3533,2 +3533,1 @@\n-void PhaseIdealLoop::collect_potentially_useful_predicates(\n-                         IdealLoopTree * loop, Unique_Node_List &useful_predicates) {\n+void PhaseIdealLoop::collect_potentially_useful_predicates(IdealLoopTree* loop, Unique_Node_List &useful_predicates) {\n@@ -3545,2 +3544,3 @@\n-    Node* predicate_proj = find_predicate(entry); \/\/ loop_limit_check first\n-    if (predicate_proj != NULL) { \/\/ right pattern that can be used by loop predication\n+\n+    Node* predicate = find_predicate_insertion_point(entry, Deoptimization::Reason_loop_limit_check);\n+    if (predicate != NULL) { \/\/ right pattern that can be used by loop predication\n@@ -3552,2 +3552,2 @@\n-      predicate_proj = find_predicate(entry); \/\/ Predicate\n-      if (predicate_proj != NULL) {\n+      predicate = find_predicate_insertion_point(entry, Deoptimization::Reason_profile_predicate);\n+      if (predicate != NULL) { \/\/ right pattern that can be used by loop predication\n@@ -3555,0 +3555,1 @@\n+        get_skeleton_predicates(entry, useful_predicates, true);\n@@ -3558,3 +3559,7 @@\n-    predicate_proj = find_predicate(entry); \/\/ Predicate\n-    if (predicate_proj != NULL) {\n-      useful_predicates.push(entry->in(0)->in(1)->in(1)); \/\/ good one\n+\n+    if (UseLoopPredicate) {\n+      predicate = find_predicate_insertion_point(entry, Deoptimization::Reason_predicate);\n+      if (predicate != NULL) { \/\/ right pattern that can be used by loop predication\n+        useful_predicates.push(entry->in(0)->in(1)->in(1)); \/\/ good one\n+        get_skeleton_predicates(entry, useful_predicates, true);\n+      }\n@@ -3574,1 +3579,1 @@\n-  if (C->predicate_count() == 0)\n+  if (C->predicate_count() == 0 && C->skeleton_predicate_count() == 0) {\n@@ -3576,0 +3581,1 @@\n+  }\n@@ -3583,1 +3589,1 @@\n-     Node * n = C->predicate_opaque1_node(i-1);\n+     Node* n = C->predicate_opaque1_node(i - 1);\n@@ -3589,0 +3595,10 @@\n+\n+  for (int i = C->skeleton_predicate_count(); i > 0; i--) {\n+    const int idx = i - 1;\n+    Node* n = C->skeleton_predicate_opaque4_node(idx);\n+    assert(n->Opcode() == Op_Opaque4, \"must be\");\n+    if (!useful_predicates.member(n)) { \/\/ not in the useful list\n+      C->remove_skeleton_predicate_opaque4_node(idx);\n+      _igvn.replace_node(n, n->in(2));\n+    }\n+  }\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":27,"deletions":11,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -917,1 +917,2 @@\n-  bool skeleton_predicate_has_opaque(IfNode* iff);\n+  static bool skeleton_predicate_has_opaque(IfNode* iff);\n+  static void get_skeleton_predicates(Node* predicate, Unique_Node_List& list, bool get_opaque = false);\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"}]}