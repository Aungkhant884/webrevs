{"files":[{"patch":"@@ -2833,0 +2833,10 @@\n+\/\/ Note that the value for MAP_FIXED_NOREPLACE differs between architectures, but all architectures\n+\/\/ supported by OpenJDK share the same flag value.\n+#define MAP_FIXED_NOREPLACE_value 0x100000\n+#ifndef MAP_FIXED_NOREPLACE\n+  #define MAP_FIXED_NOREPLACE MAP_FIXED_NOREPLACE_value\n+#else\n+  \/\/ Sanity-check our assumed default value if we build with a new enough libc.\n+  static_assert(MAP_FIXED_NOREPLACE == MAP_FIXED_NOREPLACE_value);\n+#endif\n+\n@@ -3473,2 +3483,17 @@\n-  \/\/ MAP_FIXED is intentionally left out, to leave existing mappings intact.\n-  const int flags = MAP_PRIVATE | MAP_NORESERVE | MAP_ANONYMOUS;\n+  \/\/ If a requested address was given:\n+  \/\/\n+  \/\/ The POSIX-conforming way is to *omit* MAP_FIXED. This will leave existing mappings intact.\n+  \/\/ If the requested mapping area is blocked by a pre-existing mapping, the kernel will map\n+  \/\/ somewhere else. On Linux, that alternative address appears to have no relation to the\n+  \/\/ requested address.\n+  \/\/ Unfortunately, this is not what we need - if we requested a specific address, we'd want\n+  \/\/ to map there and nowhere else. Therefore we will unmap the block again, which means we\n+  \/\/ just executed a needless mmap->munmap cycle.\n+  \/\/ Since Linux 4.17, the kernel offers MAP_FIXED_NOREPLACE. With this flag, if a pre-\n+  \/\/ existing mapping exists, the kernel will not map at an alternative point but instead\n+  \/\/ return an error. We can therefore save that unnecessary mmap-munmap cycle.\n+  \/\/\n+  \/\/ Backward compatibility: Older kernels will ignore the unknown flag; so mmap will behave\n+  \/\/ as in mode (a).\n+  const int flags = MAP_PRIVATE | MAP_NORESERVE | MAP_ANONYMOUS |\n+                    ((requested_addr != nullptr) ? MAP_FIXED_NOREPLACE : 0);\n@@ -4214,0 +4239,1 @@\n+    log_trace(os, map)(\"Kernel rejected \" PTR_FORMAT \", offered \" PTR_FORMAT \".\", p2i(requested_addr), p2i(addr));\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":28,"deletions":2,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -929,0 +929,21 @@\n+\n+TEST_VM(os, reserve_at_wish_address_shall_not_replace_mappings_smallpages) {\n+  char* p1 = os::reserve_memory(M, false, mtTest);\n+  ASSERT_NE(p1, nullptr);\n+  char* p2 = os::attempt_reserve_memory_at(p1, M);\n+  ASSERT_EQ(p2, nullptr); \/\/ should have failed\n+  os::release_memory(p1, M);\n+}\n+\n+TEST_VM(os, reserve_at_wish_address_shall_not_replace_mappings_largepages) {\n+  if (UseLargePages && !os::can_commit_large_page_memory()) { \/\/ aka special\n+    const size_t lpsz = os::large_page_size();\n+    char* p1 = os::reserve_memory_aligned(lpsz, lpsz, false);\n+    ASSERT_NE(p1, nullptr);\n+    char* p2 = os::reserve_memory_special(lpsz, lpsz, lpsz, p1, false);\n+    ASSERT_EQ(p2, nullptr); \/\/ should have failed\n+    os::release_memory(p1, M);\n+  } else {\n+    tty->print_cr(\"Skipped.\");\n+  }\n+}\n","filename":"test\/hotspot\/gtest\/runtime\/test_os.cpp","additions":21,"deletions":0,"binary":false,"changes":21,"status":"modified"}]}