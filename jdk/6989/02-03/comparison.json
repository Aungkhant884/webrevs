{"files":[{"patch":"@@ -762,1 +762,1 @@\n-  if (!phase->is_scaled_iv_plus_offset(cmp->in(1), iv, &scale, &offset, bt)) {\n+  if (!phase->is_scaled_iv_plus_offset(cmp->in(1), iv, bt, &scale, &offset)) {\n","filename":"src\/hotspot\/share\/opto\/loopPredicate.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1129,2 +1129,2 @@\n-        if (!phase->is_scaled_iv_plus_offset(cmp->in(1), trip_counter, NULL, NULL, bt) &&\n-            !phase->is_scaled_iv_plus_offset(cmp->in(2), trip_counter, NULL, NULL, bt)) {\n+        if (!phase->is_scaled_iv_plus_offset(cmp->in(1), trip_counter, bt, NULL, NULL) &&\n+            !phase->is_scaled_iv_plus_offset(cmp->in(2), trip_counter, bt, NULL, NULL)) {\n@@ -1150,1 +1150,1 @@\n-        if (!phase->is_scaled_iv_plus_offset(rc_exp, trip_counter, NULL, NULL, bt)) {\n+        if (!phase->is_scaled_iv_plus_offset(rc_exp, trip_counter, bt, NULL, NULL)) {\n@@ -2525,0 +2525,4 @@\n+\/\/----------------------------------is_iv------------------------------------\n+\/\/ Return true if exp is the value (of type bt) of the given induction var.\n+\/\/ This grammar of cases is recognized, where X is I|L according to bt:\n+\/\/    VIV[iv] = iv | (CastXX VIV[iv]) | (ConvI2X VIV[iv])\n@@ -2526,1 +2530,2 @@\n-  if (exp == iv) {\n+  exp = exp->uncast();\n+  if (exp == iv && iv->bottom_type()->isa_integer(bt)) {\n@@ -2530,1 +2535,1 @@\n-  if (bt == T_LONG && iv->bottom_type()->isa_int() && exp->Opcode() == Op_ConvI2L && exp->in(1) == iv) {\n+  if (bt == T_LONG && iv->bottom_type()->isa_int() && exp->Opcode() == Op_ConvI2L && exp->in(1)->uncast() == iv) {\n@@ -2537,5 +2542,14 @@\n-\/\/ Return true if exp is a constant times an induction var\n-bool PhaseIdealLoop::is_scaled_iv(Node* exp, Node* iv, jlong* p_scale, BasicType bt) {\n-  exp = exp->uncast();\n-  assert(bt == T_INT || bt == T_LONG, \"unexpected int type\");\n-  if (is_iv(exp, iv, bt)) {\n+\/\/ Return true if exp is a constant times the given induction var (of type bt).\n+\/\/ The multiplication must be done in full precision (exactly of type bt).\n+\/\/ This grammar of cases is recognized, where X is I|L according to bt:\n+\/\/    SIV[iv] = VIV[iv] | (CastXX SIV[iv])\n+\/\/            | (MulX SIV[iv] ConX) | (MulX ConX SIV[iv])\n+\/\/            | (LShiftX SIV[iv] ConI)\n+\/\/            | (SubX 0 SIV[iv])  -- same as MulX(iv, -1)\n+\/\/            | VIV[iv] | (ConvI2X VIV[iv])  -- from is_iv() above\n+\/\/ On success, the constant scale value is stored back to ret_scale.\n+bool PhaseIdealLoop::is_scaled_iv(Node* exp, Node* iv, BasicType bt, jlong* p_scale, bool* p_short_scale, int depth) {\n+  BasicType exp_bt = bt;\n+  exp = exp->uncast();  \/\/strip casts\n+  assert(exp_bt == T_INT || exp_bt == T_LONG, \"unexpected int type\");\n+  if (is_iv(exp, iv, exp_bt)) {\n@@ -2547,0 +2561,4 @@\n+  if (exp_bt == T_LONG && iv->bottom_type()->isa_int() && exp->Opcode() == Op_ConvI2L) {\n+    exp = exp->in(1);\n+    exp_bt = T_INT;\n+  }\n@@ -2548,0 +2566,1 @@\n+  int which = 0;  \/\/ this is which subexpression we find the iv in\n@@ -2549,2 +2568,8 @@\n-  if (opc == Op_Mul(bt)) {\n-    if (is_iv(exp->in(1)->uncast(), iv, bt) && exp->in(2)->is_Con()) {\n+  if (opc == Op_Mul(exp_bt)) {\n+    if (is_iv(exp->in(which = 1), iv, exp_bt) && exp->in(2)->is_Con() ||\n+        is_iv(exp->in(which = 2), iv, exp_bt) && exp->in(1)->is_Con()) {\n+      Node* factor = exp->in(which == 1 ? 2 : 1);  \/\/ the other argument\n+      jlong scale = factor->find_integer_as_long(exp_bt, 0);\n+      if (scale == 0) {\n+        return false;  \/\/ might be top\n+      }\n@@ -2552,1 +2577,5 @@\n-        *p_scale = exp->in(2)->get_integer_as_long(bt);\n+        *p_scale = scale;\n+      }\n+      if (p_short_scale != NULL) {\n+        \/\/ (ConvI2L (MulI iv K)) can be 64-bit linear if iv is kept small enough...\n+        *p_short_scale = (exp_bt != bt && scale != 1);\n@@ -2556,1 +2585,12 @@\n-    if (is_iv(exp->in(2)->uncast(), iv, bt) && exp->in(1)->is_Con()) {\n+  } else if (opc == Op_LShift(exp_bt)) {\n+    if (is_iv(exp->in(1), iv, exp_bt) && exp->in(2)->is_Con()) {\n+      jint shift_amount = exp->in(2)->find_int_con(min_jint);\n+      if (shift_amount == min_jint) {\n+        return false;  \/\/ might be top\n+      }\n+      jlong scale;\n+      if (exp_bt == T_INT) {\n+        scale = java_shift_left((jint)1, (juint)shift_amount);\n+      } else if (exp_bt == T_LONG) {\n+        scale = java_shift_left((jlong)1, (julong)shift_amount);\n+      }\n@@ -2558,1 +2598,5 @@\n-        *p_scale = exp->in(1)->get_integer_as_long(bt);\n+        *p_scale = scale;\n+      }\n+      if (p_short_scale != NULL) {\n+        \/\/ (ConvI2L (MulI iv K)) can be 64-bit linear if iv is kept small enough...\n+        *p_short_scale = (exp_bt != bt && scale != 1);\n@@ -2562,2 +2606,10 @@\n-  } else if (opc == Op_LShift(bt)) {\n-    if (is_iv(exp->in(1)->uncast(), iv, bt) && exp->in(2)->is_Con()) {\n+  } else if (opc == Op_Sub(exp_bt) &&\n+             exp->in(1)->find_integer_as_long(exp_bt, -1) == 0) {\n+    jlong scale = 0;\n+    if (depth == 0 && is_scaled_iv(exp->in(2), iv, exp_bt, &scale, p_short_scale, depth + 1)) {\n+      \/\/ SubX(0, iv*K) => iv*(-K)\n+      if (scale == min_signed_integer(exp_bt)) {\n+        \/\/ This should work even if -K overflows, but let's not.\n+        return false;\n+      }\n+      scale = java_multiply(scale, (jlong)-1);\n@@ -2565,6 +2617,5 @@\n-        jint shift_amount = exp->in(2)->get_int();\n-        if (bt == T_INT) {\n-          *p_scale = java_shift_left((jint)1, (juint)shift_amount);\n-        } else if (bt == T_LONG) {\n-          *p_scale = java_shift_left((jlong)1, (julong)shift_amount);\n-        }\n+        *p_scale = scale;\n+      }\n+      if (p_short_scale != NULL) {\n+        \/\/ (ConvI2L (MulI iv K)) can be 64-bit linear if iv is kept small enough...\n+        *p_short_scale = (exp_bt != bt && scale != 1);\n@@ -2575,0 +2626,1 @@\n+  \/\/ We could also recognize (iv*K1)*K2, even with overflow, but let's not.\n@@ -2578,3 +2630,17 @@\n-\/\/-----------------------------is_scaled_iv_plus_offset------------------------------\n-\/\/ Return true if exp is a simple induction variable expression: k1*iv + (invar + k2)\n-bool PhaseIdealLoop::is_scaled_iv_plus_offset(Node* exp, Node* iv, jlong* p_scale, Node** p_offset, BasicType bt, bool* p_converted, int depth) {\n+\/\/-------------------------is_scaled_iv_plus_offset--------------------------\n+\/\/ Return true if exp is a simple linear transform of the given induction var.\n+\/\/ The scale must be constant and the addition tree (if any) must be simple.\n+\/\/ This grammar of cases is recognized, where X is I|L according to bt:\n+\/\/\n+\/\/    OIV[iv] = SIV[iv] | (CastXX OIV[iv])\n+\/\/            | (AddX SIV[iv] E) | (AddX E SIV[iv])\n+\/\/            | (SubX SIV[iv] E) | (SubX E SIV[iv])\n+\/\/    SSIV[iv] = (ConvI2X SIV[iv])  -- a \"short scale\" might occur here\n+\/\/    SIV[iv] = [see is_scaled_iv() above]\n+\/\/\n+\/\/ On success, the constant scale value is stored back to *p_scale unless null.\n+\/\/ Likewise, the addend (perhaps a synthetic AddX node) is stored to *p_offset.\n+\/\/ Also, (*p_short_scale) reports if a ConvI2L conversion was seen after a MulI,\n+\/\/ meaning bt is T_LONG but iv was scaled using 32-bit arithmetic.\n+\/\/ To avoid looping, the match is depth-limited, and so may fail to match the grammar to complex expressions.\n+bool PhaseIdealLoop::is_scaled_iv_plus_offset(Node* exp, Node* iv, BasicType bt, jlong* p_scale, Node** p_offset, bool* p_short_scale, int depth) {\n@@ -2582,0 +2648,1 @@\n+  jlong scale = 0;  \/\/ to catch result from is_scaled_iv()\n@@ -2583,5 +2650,5 @@\n-  if (bt == T_LONG && iv->bottom_type()->isa_int() && exp->Opcode() == Op_ConvI2L) {\n-    exp = exp->in(1);\n-    exp_bt = T_INT;\n-  }\n-  if (is_scaled_iv(exp, iv, p_scale, exp_bt)) {\n+  exp = exp->uncast();\n+  if (is_scaled_iv(exp, iv, exp_bt, &scale, p_short_scale)) {\n+    if (p_scale != NULL) {\n+      *p_scale = scale;\n+    }\n@@ -2593,3 +2660,0 @@\n-    if (p_converted != NULL) {\n-      *p_converted = exp_bt != bt;\n-    }\n@@ -2598,1 +2662,7 @@\n-  exp = exp->uncast();\n+  if (exp_bt != bt) {\n+    \/\/ We would now be matching inputs like (ConvI2L exp:(AddI (MulI iv S) E)).\n+    \/\/ It's hard to make 32-bit arithmetic linear if it overflows.  Although we do\n+    \/\/ cope with overflowing multiplication by S, it would be even more work to\n+    \/\/ handle overflowing addition of E.  So we bail out here on ConvI2L input.\n+    return false;\n+  }\n@@ -2600,7 +2670,9 @@\n-  if (opc == Op_Add(exp_bt) && bt == exp_bt) {\n-    if (is_scaled_iv(exp->in(1), iv, p_scale, exp_bt)) {\n-      if (p_offset != NULL) {\n-        *p_offset = exp->in(2);\n-      }\n-      if (p_converted != NULL) {\n-        *p_converted = false;\n+  int which = 0;  \/\/ this is which subexpression we find the iv in\n+  Node* offset = NULL;\n+  if (opc == Op_Add(exp_bt)) {\n+    \/\/ Check for a scaled IV in (AddX (MulX iv S) E) or (AddX E (MulX iv S)).\n+    if (is_scaled_iv(exp->in(which = 1), iv, bt, &scale, p_short_scale) ||\n+        is_scaled_iv(exp->in(which = 2), iv, bt, &scale, p_short_scale)) {\n+      offset = exp->in(which == 1 ? 2 : 1);  \/\/ the other argument\n+      if (p_scale != NULL) {\n+        *p_scale = scale;\n@@ -2608,3 +2680,0 @@\n-      return true;\n-    }\n-    if (is_scaled_iv(exp->in(2), iv, p_scale, exp_bt)) {\n@@ -2612,11 +2681,1 @@\n-        *p_offset = exp->in(1);\n-      }\n-      if (p_converted != NULL) {\n-        *p_converted = false;\n-      }\n-      return true;\n-    }\n-    bool converted  = false;\n-    if (is_scaled_iv_plus_extra_offset(exp->in(1), exp->in(2), iv, p_scale, p_offset, exp_bt, converted, depth)) {\n-      if (p_converted != NULL) {\n-        *p_converted = converted;\n+        *p_offset = offset;\n@@ -2626,4 +2685,3 @@\n-    if (is_scaled_iv_plus_extra_offset(exp->in(2), exp->in(1), iv, p_scale, p_offset, exp_bt, converted, depth)) {\n-      if (p_converted != NULL) {\n-        *p_converted = converted;\n-      }\n+    \/\/ Check for more addends, like (AddX (AddX (MulX iv S) E1) E2), etc.\n+    if (is_scaled_iv_plus_extra_offset(exp->in(1), exp->in(2), iv, bt, p_scale, p_offset, p_short_scale, depth) ||\n+        is_scaled_iv_plus_extra_offset(exp->in(2), exp->in(1), iv, bt, p_scale, p_offset, p_short_scale, depth)) {\n@@ -2633,20 +2691,6 @@\n-    if (exp_bt == bt && is_scaled_iv(exp->in(1), iv, p_scale, exp_bt)) {\n-      if (p_offset != NULL) {\n-        Node *zero = _igvn.integercon(0, exp_bt);\n-        set_ctrl(zero, C->root());\n-        Node *ctrl_off = get_ctrl(exp->in(2));\n-        Node* offset = SubNode::make(zero, exp->in(2), exp_bt);\n-        register_new_node(offset, ctrl_off);\n-        *p_offset = offset;\n-      }\n-      return true;\n-    }\n-    jlong scale;\n-    if (is_scaled_iv(exp->in(2), iv, &scale, exp_bt)) {\n-      if (scale == min_signed_integer(exp_bt)) {\n-        return false;\n-      }\n-      if (exp_bt != bt && _igvn.find_int_con(exp->in(1), -1) != 0) {\n-        return false;\n-      }\n-      if (p_offset != NULL) {\n+    if (is_scaled_iv(exp->in(which = 1), iv, bt, &scale, p_short_scale) ||\n+        is_scaled_iv(exp->in(which = 2), iv, bt, &scale, p_short_scale)) {\n+      \/\/ Match (SubX SIV[iv] E) as if (AddX SIV[iv] (SubX 0 E)), and\n+      \/\/ match (SubX E SIV[iv]) as if (AddX E (SubX 0 SIV[iv])).\n+      offset = exp->in(which == 1 ? 2 : 1);  \/\/ the other argument\n+      if (which == 2) {\n@@ -2654,6 +2698,2 @@\n-        scale *= -1;\n-        if (exp_bt != bt) {\n-          *p_offset = _igvn.zerocon(bt);\n-          set_ctrl(*p_offset, C->root());\n-        } else {\n-          *p_offset = exp->in(1);\n+        if (scale == min_signed_integer(bt)) {\n+          return false;   \/\/ cannot negate the scale of the iv\n@@ -2661,0 +2701,1 @@\n+        scale = java_multiply(scale, (jlong)-1);\n@@ -2665,2 +2706,9 @@\n-      if (p_converted != NULL) {\n-        *p_converted = exp_bt != bt;\n+      if (p_offset != NULL) {\n+        if (which == 1) {  \/\/ must negate the extracted offset\n+          Node *zero = _igvn.integercon(0, exp_bt);\n+          set_ctrl(zero, C->root());\n+          Node *ctrl_off = get_ctrl(offset);\n+          offset = SubNode::make(zero, offset, exp_bt);\n+          register_new_node(offset, ctrl_off);\n+        }\n+        *p_offset = offset;\n@@ -2674,2 +2722,11 @@\n-bool PhaseIdealLoop::is_scaled_iv_plus_extra_offset(Node* exp1, Node* exp2, Node* iv, jlong* p_scale, Node** p_offset,\n-                                                    BasicType bt, bool& converted, int depth) {\n+\/\/ Helper for is_scaled_iv_plus_offset(), not called separately.\n+\/\/ The caller encountered (AddX exp1 offset3) or (AddX offset3 exp1).\n+\/\/ Here, exp1 is inspected to see if it is a simple linear transform of iv.\n+\/\/ If so, the offset3 is combined with any other offset2 from inside exp1.\n+bool PhaseIdealLoop::is_scaled_iv_plus_extra_offset(Node* exp1, Node* offset3, Node* iv,\n+                                                    BasicType bt,\n+                                                    jlong* p_scale, Node** p_offset,\n+                                                    bool* p_short_scale, int depth) {\n+  \/\/ By the time we reach here, it is unlikely that exp1 is a simple iv*K.\n+  \/\/ If is a linear iv transform, it is probably an add or subtract.\n+  \/\/ Let's collect the internal offset2 from it.\n@@ -2677,4 +2734,4 @@\n-  if (depth < 2 &&\n-      is_scaled_iv_plus_offset(exp1, iv, p_scale,\n-                               &offset2, bt, &converted, depth+1) &&\n-      offset2->is_Con()) {\n+  if (offset3->is_Con() &&\n+      depth < 2 &&\n+      is_scaled_iv_plus_offset(exp1, iv, bt, p_scale,\n+                               &offset2, p_short_scale, depth+1)) {\n@@ -2683,1 +2740,1 @@\n-      Node* offset = AddNode::make(offset2, exp2, bt);\n+      Node* offset = AddNode::make(offset2, offset3, bt);\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":152,"deletions":95,"binary":false,"changes":247,"status":"modified"},{"patch":"@@ -1279,2 +1279,2 @@\n-    bool converted = false;\n-    bool ok = is_scaled_iv_plus_offset(rc_cmp->in(1), iv_add, &scale, &offset, T_LONG, &converted);\n+    bool short_scale = false;\n+    bool ok = is_scaled_iv_plus_offset(rc_cmp->in(1), iv_add, T_LONG, &scale, &offset, &short_scale);\n@@ -1292,1 +1292,1 @@\n-    if (converted) {\n+    if (short_scale) {\n@@ -1294,1 +1294,1 @@\n-      \/\/ i*K + L <u64 R\n+      \/\/ (int)i*K + L <u64 R\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1265,1 +1265,1 @@\n-  bool is_scaled_iv(Node* exp, Node* iv, jlong* p_scale, BasicType bt);\n+  bool is_scaled_iv(Node* exp, Node* iv, BasicType bt, jlong* p_scale, bool* p_short_scale, int depth = 0);\n@@ -1270,1 +1270,1 @@\n-  bool is_scaled_iv_plus_offset(Node* exp, Node* iv, jlong* p_scale, Node** p_offset, BasicType bt, bool* p_converted = NULL, int depth = 0);\n+  bool is_scaled_iv_plus_offset(Node* exp, Node* iv, BasicType bt, jlong* p_scale, Node** p_offset, bool* p_short_scale = NULL, int depth = 0);\n@@ -1273,1 +1273,1 @@\n-    if (is_scaled_iv_plus_offset(exp, iv, &long_scale, p_offset, T_INT)) {\n+    if (is_scaled_iv_plus_offset(exp, iv, T_INT, &long_scale, p_offset)) {\n@@ -1282,0 +1282,6 @@\n+  \/\/ Helper for finding more complex matches to is_scaled_iv_plus_offset.\n+  bool is_scaled_iv_plus_extra_offset(Node* exp1, Node* offset2, Node* iv,\n+                                      BasicType bt,\n+                                      jlong* p_scale, Node** p_offset,\n+                                      bool* p_short_scale, int depth);\n+\n@@ -1659,3 +1665,0 @@\n-  bool is_scaled_iv_plus_extra_offset(Node* exp1, Node* exp2, Node* iv, jlong* p_scale, Node** p_offset, BasicType bt,\n-                                      bool& converted, int depth);\n-\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":9,"deletions":6,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -1153,1 +1153,6 @@\n-    guarantee(t != NULL, \"must be con\");\n+    guarantee(t != NULL && t->is_con(), \"must be con\");\n+    return t->get_con_as_long(bt);\n+  }\n+  jlong find_integer_as_long(BasicType bt, jlong value_if_unknown) const {\n+    const TypeInteger* t = find_integer_type(bt);\n+    if (t == NULL || !t->is_con())  return value_if_unknown;\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"}]}