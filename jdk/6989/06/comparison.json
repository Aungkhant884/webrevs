{"files":[{"patch":"@@ -762,1 +762,1 @@\n-  if (!phase->is_scaled_iv_plus_offset(cmp->in(1), iv, &scale, &offset, bt)) {\n+  if (!phase->is_scaled_iv_plus_offset(cmp->in(1), iv, bt, &scale, &offset)) {\n","filename":"src\/hotspot\/share\/opto\/loopPredicate.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1124,2 +1124,0 @@\n-      Node *rc_exp = cmp->in(1);\n-      Node *limit = cmp->in(2);\n@@ -1131,2 +1129,2 @@\n-        if (!phase->is_scaled_iv_plus_offset(cmp->in(1), trip_counter, NULL, NULL, bt) &&\n-            !phase->is_scaled_iv_plus_offset(cmp->in(2), trip_counter, NULL, NULL, bt)) {\n+        if (!phase->is_scaled_iv_plus_offset(cmp->in(1), trip_counter, bt, NULL, NULL) &&\n+            !phase->is_scaled_iv_plus_offset(cmp->in(2), trip_counter, bt, NULL, NULL)) {\n@@ -1136,0 +1134,2 @@\n+        Node *rc_exp = cmp->in(1);\n+        Node *limit = cmp->in(2);\n@@ -1150,1 +1150,1 @@\n-        if (!phase->is_scaled_iv_plus_offset(rc_exp, trip_counter, NULL, NULL, bt)) {\n+        if (!phase->is_scaled_iv_plus_offset(rc_exp, trip_counter, bt, NULL, NULL)) {\n@@ -2525,0 +2525,4 @@\n+\/\/----------------------------------is_iv------------------------------------\n+\/\/ Return true if exp is the value (of type bt) of the given induction var.\n+\/\/ This grammar of cases is recognized, where X is I|L according to bt:\n+\/\/    VIV[iv] = iv | (CastXX VIV[iv]) | (ConvI2X VIV[iv])\n@@ -2526,1 +2530,2 @@\n-  if (exp == iv) {\n+  exp = exp->uncast();\n+  if (exp == iv && iv->bottom_type()->isa_integer(bt)) {\n@@ -2530,1 +2535,1 @@\n-  if (bt == T_LONG && iv->bottom_type()->isa_int() && exp->Opcode() == Op_ConvI2L && exp->in(1) == iv) {\n+  if (bt == T_LONG && iv->bottom_type()->isa_int() && exp->Opcode() == Op_ConvI2L && exp->in(1)->uncast() == iv) {\n@@ -2537,5 +2542,17 @@\n-\/\/ Return true if exp is a constant times an induction var\n-bool PhaseIdealLoop::is_scaled_iv(Node* exp, Node* iv, jlong* p_scale, BasicType bt, bool* converted) {\n-  exp = exp->uncast();\n-  assert(bt == T_INT || bt == T_LONG, \"unexpected int type\");\n-  if (is_iv(exp, iv, bt)) {\n+\/\/ Return true if exp is a constant times the given induction var (of type bt).\n+\/\/ The multiplication is either done in full precision (exactly of type bt),\n+\/\/ or else bt is T_LONG but iv is scaled using 32-bit arithmetic followed by a ConvI2L.\n+\/\/ This grammar of cases is recognized, where X is I|L according to bt:\n+\/\/    SIV[iv] = VIV[iv] | (CastXX SIV[iv])\n+\/\/            | (MulX VIV[iv] ConX) | (MulX ConX VIV[iv])\n+\/\/            | (LShiftX VIV[iv] ConI)\n+\/\/            | (ConvI2L SIV[iv])  -- a \"short-scale\" can occur here; note recursion\n+\/\/            | (SubX 0 SIV[iv])  -- same as MulX(iv, -scale); note recursion\n+\/\/    VIV[iv] = [either iv or its value converted; see is_iv() above]\n+\/\/ On success, the constant scale value is stored back to *p_scale.\n+\/\/ The value (*p_short_scale) reports if such a ConvI2L conversion was present.\n+bool PhaseIdealLoop::is_scaled_iv(Node* exp, Node* iv, BasicType bt, jlong* p_scale, bool* p_short_scale, int depth) {\n+  BasicType exp_bt = bt;\n+  exp = exp->uncast();  \/\/strip casts\n+  assert(exp_bt == T_INT || exp_bt == T_LONG, \"unexpected int type\");\n+  if (is_iv(exp, iv, exp_bt)) {\n@@ -2545,0 +2562,3 @@\n+    if (p_short_scale != NULL) {\n+      *p_short_scale = false;\n+    }\n@@ -2547,1 +2567,1 @@\n-  if (bt == T_LONG && iv->bottom_type()->isa_int() && exp->Opcode() == Op_ConvI2L) {\n+  if (exp_bt == T_LONG && iv->bottom_type()->isa_int() && exp->Opcode() == Op_ConvI2L) {\n@@ -2549,4 +2569,1 @@\n-    bt = T_INT;\n-    if (converted != NULL) {\n-      *converted = true;\n-    }\n+    exp_bt = T_INT;\n@@ -2555,0 +2572,1 @@\n+  int which = 0;  \/\/ this is which subexpression we find the iv in\n@@ -2556,2 +2574,8 @@\n-  if (opc == Op_Mul(bt)) {\n-    if (is_iv(exp->in(1)->uncast(), iv, bt) && exp->in(2)->is_Con()) {\n+  if (opc == Op_Mul(exp_bt)) {\n+    if ((is_iv(exp->in(which = 1), iv, exp_bt) && exp->in(2)->is_Con()) ||\n+        (is_iv(exp->in(which = 2), iv, exp_bt) && exp->in(1)->is_Con())) {\n+      Node* factor = exp->in(which == 1 ? 2 : 1);  \/\/ the other argument\n+      jlong scale = factor->find_integer_as_long(exp_bt, 0);\n+      if (scale == 0) {\n+        return false;  \/\/ might be top\n+      }\n@@ -2559,1 +2583,5 @@\n-        *p_scale = exp->in(2)->get_integer_as_long(bt);\n+        *p_scale = scale;\n+      }\n+      if (p_short_scale != NULL) {\n+        \/\/ (ConvI2L (MulI iv K)) can be 64-bit linear if iv is kept small enough...\n+        *p_short_scale = (exp_bt != bt && scale != 1);\n@@ -2563,1 +2591,12 @@\n-    if (is_iv(exp->in(2)->uncast(), iv, bt) && exp->in(1)->is_Con()) {\n+  } else if (opc == Op_LShift(exp_bt)) {\n+    if (is_iv(exp->in(1), iv, exp_bt) && exp->in(2)->is_Con()) {\n+      jint shift_amount = exp->in(2)->find_int_con(min_jint);\n+      if (shift_amount == min_jint) {\n+        return false;  \/\/ might be top\n+      }\n+      jlong scale;\n+      if (exp_bt == T_INT) {\n+        scale = java_shift_left((jint)1, (juint)shift_amount);\n+      } else if (exp_bt == T_LONG) {\n+        scale = java_shift_left((jlong)1, (julong)shift_amount);\n+      }\n@@ -2565,1 +2604,5 @@\n-        *p_scale = exp->in(1)->get_integer_as_long(bt);\n+        *p_scale = scale;\n+      }\n+      if (p_short_scale != NULL) {\n+        \/\/ (ConvI2L (MulI iv K)) can be 64-bit linear if iv is kept small enough...\n+        *p_short_scale = (exp_bt != bt && scale != 1);\n@@ -2569,2 +2612,10 @@\n-  } else if (opc == Op_LShift(bt)) {\n-    if (is_iv(exp->in(1)->uncast(), iv, bt) && exp->in(2)->is_Con()) {\n+  } else if (opc == Op_Sub(exp_bt) &&\n+             exp->in(1)->find_integer_as_long(exp_bt, -1) == 0) {\n+    jlong scale = 0;\n+    if (depth == 0 && is_scaled_iv(exp->in(2), iv, exp_bt, &scale, p_short_scale, depth + 1)) {\n+      \/\/ SubX(0, iv*K) => iv*(-K)\n+      if (scale == min_signed_integer(exp_bt)) {\n+        \/\/ This should work even if -K overflows, but let's not.\n+        return false;\n+      }\n+      scale = java_multiply(scale, (jlong)-1);\n@@ -2572,6 +2623,5 @@\n-        jint shift_amount = exp->in(2)->get_int();\n-        if (bt == T_INT) {\n-          *p_scale = java_shift_left((jint)1, (juint)shift_amount);\n-        } else if (bt == T_LONG) {\n-          *p_scale = java_shift_left((jlong)1, (julong)shift_amount);\n-        }\n+        *p_scale = scale;\n+      }\n+      if (p_short_scale != NULL) {\n+        \/\/ (ConvI2L (MulI iv K)) can be 64-bit linear if iv is kept small enough...\n+        *p_short_scale = *p_short_scale || (exp_bt != bt && scale != 1);\n@@ -2582,0 +2632,1 @@\n+  \/\/ We could also recognize (iv*K1)*K2, even with overflow, but let's not.\n@@ -2585,3 +2636,17 @@\n-\/\/-----------------------------is_scaled_iv_plus_offset------------------------------\n-\/\/ Return true if exp is a simple induction variable expression: k1*iv + (invar + k2)\n-bool PhaseIdealLoop::is_scaled_iv_plus_offset(Node* exp, Node* iv, jlong* p_scale, Node** p_offset, BasicType bt, bool* converted, int depth) {\n+\/\/-------------------------is_scaled_iv_plus_offset--------------------------\n+\/\/ Return true if exp is a simple linear transform of the given induction var.\n+\/\/ The scale must be constant and the addition tree (if any) must be simple.\n+\/\/ This grammar of cases is recognized, where X is I|L according to bt:\n+\/\/\n+\/\/    OIV[iv] = SIV[iv] | (CastXX OIV[iv])\n+\/\/            | (AddX SIV[iv] E) | (AddX E SIV[iv])\n+\/\/            | (SubX SIV[iv] E) | (SubX E SIV[iv])\n+\/\/    SSIV[iv] = (ConvI2X SIV[iv])  -- a \"short scale\" might occur here\n+\/\/    SIV[iv] = [a possibly scaled value of iv; see is_scaled_iv() above]\n+\/\/\n+\/\/ On success, the constant scale value is stored back to *p_scale unless null.\n+\/\/ Likewise, the addend (perhaps a synthetic AddX node) is stored to *p_offset.\n+\/\/ Also, (*p_short_scale) reports if a ConvI2L conversion was seen after a MulI,\n+\/\/ meaning bt is T_LONG but iv was scaled using 32-bit arithmetic.\n+\/\/ To avoid looping, the match is depth-limited, and so may fail to match the grammar to complex expressions.\n+bool PhaseIdealLoop::is_scaled_iv_plus_offset(Node* exp, Node* iv, BasicType bt, jlong* p_scale, Node** p_offset, bool* p_short_scale, int depth) {\n@@ -2589,1 +2654,7 @@\n-  if (is_scaled_iv(exp, iv, p_scale, bt, converted)) {\n+  jlong scale = 0;  \/\/ to catch result from is_scaled_iv()\n+  BasicType exp_bt = bt;\n+  exp = exp->uncast();\n+  if (is_scaled_iv(exp, iv, exp_bt, &scale, p_short_scale)) {\n+    if (p_scale != NULL) {\n+      *p_scale = scale;\n+    }\n@@ -2591,1 +2662,1 @@\n-      Node *zero = _igvn.integercon(0, bt);\n+      Node *zero = _igvn.zerocon(bt);\n@@ -2597,1 +2668,7 @@\n-  exp = exp->uncast();\n+  if (exp_bt != bt) {\n+    \/\/ We would now be matching inputs like (ConvI2L exp:(AddI (MulI iv S) E)).\n+    \/\/ It's hard to make 32-bit arithmetic linear if it overflows.  Although we do\n+    \/\/ cope with overflowing multiplication by S, it would be even more work to\n+    \/\/ handle overflowing addition of E.  So we bail out here on ConvI2L input.\n+    return false;\n+  }\n@@ -2599,2 +2676,10 @@\n-  if (opc == Op_Add(bt)) {\n-    if (is_scaled_iv(exp->in(1), iv, p_scale, bt, converted)) {\n+  int which = 0;  \/\/ this is which subexpression we find the iv in\n+  Node* offset = NULL;\n+  if (opc == Op_Add(exp_bt)) {\n+    \/\/ Check for a scaled IV in (AddX (MulX iv S) E) or (AddX E (MulX iv S)).\n+    if (is_scaled_iv(exp->in(which = 1), iv, bt, &scale, p_short_scale) ||\n+        is_scaled_iv(exp->in(which = 2), iv, bt, &scale, p_short_scale)) {\n+      offset = exp->in(which == 1 ? 2 : 1);  \/\/ the other argument\n+      if (p_scale != NULL) {\n+        *p_scale = scale;\n+      }\n@@ -2602,1 +2687,1 @@\n-        *p_offset = exp->in(2);\n+        *p_offset = offset;\n@@ -2606,4 +2691,3 @@\n-    if (is_scaled_iv(exp->in(2), iv, p_scale, bt, converted)) {\n-      if (p_offset != NULL) {\n-        *p_offset = exp->in(1);\n-      }\n+    \/\/ Check for more addends, like (AddX (AddX (MulX iv S) E1) E2), etc.\n+    if (is_scaled_iv_plus_extra_offset(exp->in(1), exp->in(2), iv, bt, p_scale, p_offset, p_short_scale, depth) ||\n+        is_scaled_iv_plus_extra_offset(exp->in(2), exp->in(1), iv, bt, p_scale, p_offset, p_short_scale, depth)) {\n@@ -2612,10 +2696,10 @@\n-    if (exp->in(2)->is_Con()) {\n-      Node* offset2 = NULL;\n-      if (depth < 2 &&\n-          is_scaled_iv_plus_offset(exp->in(1), iv, p_scale,\n-                                   p_offset != NULL ? &offset2 : NULL, bt, converted, depth+1)) {\n-        if (p_offset != NULL) {\n-          Node *ctrl_off2 = get_ctrl(offset2);\n-          Node* offset = AddNode::make(offset2, exp->in(2), bt);\n-          register_new_node(offset, ctrl_off2);\n-          *p_offset = offset;\n+  } else if (opc == Op_Sub(exp_bt)) {\n+    if (is_scaled_iv(exp->in(which = 1), iv, bt, &scale, p_short_scale) ||\n+        is_scaled_iv(exp->in(which = 2), iv, bt, &scale, p_short_scale)) {\n+      \/\/ Match (SubX SIV[iv] E) as if (AddX SIV[iv] (SubX 0 E)), and\n+      \/\/ match (SubX E SIV[iv]) as if (AddX E (SubX 0 SIV[iv])).\n+      offset = exp->in(which == 1 ? 2 : 1);  \/\/ the other argument\n+      if (which == 2) {\n+        \/\/ We can't handle a scale of min_jint (or min_jlong) here as -1 * min_jint = min_jint\n+        if (scale == min_signed_integer(bt)) {\n+          return false;   \/\/ cannot negate the scale of the iv\n@@ -2623,1 +2707,1 @@\n-        return true;\n+        scale = java_multiply(scale, (jlong)-1);\n@@ -2625,10 +2709,2 @@\n-    }\n-  } else if (opc == Op_Sub(bt)) {\n-    if (is_scaled_iv(exp->in(1), iv, p_scale, bt, converted)) {\n-      if (p_offset != NULL) {\n-        Node *zero = _igvn.integercon(0, bt);\n-        set_ctrl(zero, C->root());\n-        Node *ctrl_off = get_ctrl(exp->in(2));\n-        Node* offset = SubNode::make(zero, exp->in(2), bt);\n-        register_new_node(offset, ctrl_off);\n-        *p_offset = offset;\n+      if (p_scale != NULL) {\n+        *p_scale = scale;\n@@ -2636,3 +2712,0 @@\n-      return true;\n-    }\n-    if (is_scaled_iv(exp->in(2), iv, p_scale, bt, converted)) {\n@@ -2640,3 +2713,6 @@\n-        \/\/ We can't handle a scale of min_jint (or min_jlong) here as -1 * min_jint = min_jint\n-        if (*p_scale == min_signed_integer(bt)) {\n-          return false;\n+        if (which == 1) {  \/\/ must negate the extracted offset\n+          Node *zero = _igvn.integercon(0, exp_bt);\n+          set_ctrl(zero, C->root());\n+          Node *ctrl_off = get_ctrl(offset);\n+          offset = SubNode::make(zero, offset, exp_bt);\n+          register_new_node(offset, ctrl_off);\n@@ -2644,2 +2720,1 @@\n-        *p_scale *= -1;\n-        *p_offset = exp->in(1);\n+        *p_offset = offset;\n@@ -2653,0 +2728,27 @@\n+\/\/ Helper for is_scaled_iv_plus_offset(), not called separately.\n+\/\/ The caller encountered (AddX exp1 offset3) or (AddX offset3 exp1).\n+\/\/ Here, exp1 is inspected to see if it is a simple linear transform of iv.\n+\/\/ If so, the offset3 is combined with any other offset2 from inside exp1.\n+bool PhaseIdealLoop::is_scaled_iv_plus_extra_offset(Node* exp1, Node* offset3, Node* iv,\n+                                                    BasicType bt,\n+                                                    jlong* p_scale, Node** p_offset,\n+                                                    bool* p_short_scale, int depth) {\n+  \/\/ By the time we reach here, it is unlikely that exp1 is a simple iv*K.\n+  \/\/ If is a linear iv transform, it is probably an add or subtract.\n+  \/\/ Let's collect the internal offset2 from it.\n+  Node* offset2 = NULL;\n+  if (offset3->is_Con() &&\n+      depth < 2 &&\n+      is_scaled_iv_plus_offset(exp1, iv, bt, p_scale,\n+                               &offset2, p_short_scale, depth+1)) {\n+    if (p_offset != NULL) {\n+      Node* ctrl_off2 = get_ctrl(offset2);\n+      Node* offset = AddNode::make(offset2, offset3, bt);\n+      register_new_node(offset, ctrl_off2);\n+      *p_offset = offset;\n+    }\n+    return true;\n+  }\n+  return false;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":174,"deletions":72,"binary":false,"changes":246,"status":"modified"},{"patch":"@@ -1125,3 +1125,0 @@\n-  if (stride_con < 0) { \/\/ only for stride_con > 0 && scale > 0 for now\n-    return iters_limit;\n-  }\n@@ -1142,1 +1139,0 @@\n-            scale > 0 && \/\/ only for stride_con > 0 && scale > 0 for now\n@@ -1157,2 +1153,1 @@\n-\/\/ i is never Z.  It will be B=Z-1 if S=1, or B=Z+1 if S=-1.  If |S|>1 the formula for the last value requires a floor\n-\/\/ operation, specifically B=floor((Z-sgn(S)-A)\/S)*S+A.  Thus i ranges as i:[A,B] or i:[A,Z) or i:[A,Z-U) for some U<S.\n+\/\/ i is never Z.  It will be B=Z-1 if S=1, or B=Z+1 if S=-1.\n@@ -1160,3 +1155,3 @@\n-\/\/ N.B. We handle only the case of positive S currently, so comments about S<0 are not operative at present.  Also,\n-\/\/ we only support positive index scale value (K > 0) to simplify the logic for clamping 32-bit bounds (L_2, R_2).\n-\/\/ For restrictions on S and K, see the guards in extract_long_range_checks.\n+\/\/ If |S|>1 the formula for the last value B would require a floor operation, specifically B=floor((Z-sgn(S)-A)\/S)*S+A,\n+\/\/ which is B=Z-sgn(S)U for some U in [1,|S|].  So when S>0, i ranges as i:[A,Z) or i:[A,B=Z-U], or else (in reverse)\n+\/\/ as i:(Z,A] or i:[B=Z+U,A].  It will become important to reason about this inclusive range [A,B] or [B,A].\n@@ -1166,1 +1161,1 @@\n-\/\/ Because R is never negative, this check can always be simplified to an unsigned check i*K+L <u R.\n+\/\/ Because R is never negative (see below), this check can always be simplified to an unsigned check i*K+L <u R.\n@@ -1169,3 +1164,3 @@\n-\/\/ variable j (inner_iv), j ranges over a shorter interval j:[0,Z_2), where the limit is chosen to prevent various cases\n-\/\/ of 32-bit overflow (including multiplications j*K below).  In the sub-loop the logical value i is offset from j by a\n-\/\/ 64-bit constant C, so i ranges in i:C+[0,Z_2).\n+\/\/ variable j (inner_iv), j ranges over a shorter interval j:[0,B_2] or [0,Z_2) (assuming S > 0), where the limit is\n+\/\/ chosen to prevent various cases of 32-bit overflow (including multiplications j*K below).  In the sub-loop the\n+\/\/ logical value i is offset from j by a 64-bit constant C, so i ranges in i:C+[0,Z_2).\n@@ -1173,3 +1168,2 @@\n-\/\/ The union of all the C+[0,Z_2) ranges from the sub-loops must be identical to the whole range [A,B].  Assuming S>0,\n-\/\/ the first C must be A itself, and the next C value is the previous C+Z_2.  In each sub-loop, j counts up from zero\n-\/\/ and exits just before i=C+Z_2.\n+\/\/ For S<0, j ranges (in reverse!) through j:[-|B_2|,0] or (-|Z_2|,0].  For either sign of S, we can say i=j+C and j\n+\/\/ ranges through 32-bit ranges [A_2,B_2] or [B_2,A_2] (A_2=0 of course).\n@@ -1177,1 +1171,5 @@\n-\/\/ (N.B. If S<0 the formulas are different, because all the loops count downward.)\n+\/\/ The disjoint union of all the C+[A_2,B_2] ranges from the sub-loops must be identical to the whole range [A,B].\n+\/\/ Assuming S>0, the first C must be A itself, and the next C value is the previous C+B_2, plus S.  If |S|=1, the next\n+\/\/ C value is also the previous C+Z_2.  In each sub-loop, j counts from j=A_2=0 and i counts from C+0 and exits at\n+\/\/ j=B_2 (i=C+B_2), just before it gets to i=C+Z_2.  Both i and j count up (from C and 0) if S>0; otherwise they count\n+\/\/ down (from C and 0 again).\n@@ -1197,4 +1195,3 @@\n-\/\/ For each R.C. j*K+Q <u32 R, the range of mathematical values of j*K+Q in the sub-loop is [Q_min, Q_max), where\n-\/\/ Q_min=Q and Q_max=Z_2*K+Q.  Making the upper limit Q_max be exclusive helps it integrate correctly with the strict\n-\/\/ comparisons against R and R_2.  Sometimes a very high R will be replaced by an R_2 derived from the more moderate\n-\/\/ Q_max, and replacing one exclusive limit by another exclusive limit avoids off-by-one complexities.\n+\/\/ For each R.C. j*K+Q <u32 R, the range of mathematical values of j*K+Q in the sub-loop is [Q_min, Q_max], where\n+\/\/ Q_min=Q and Q_max=B_2*K+Q (if S>0 and K>0), Q_min=A_2*K+Q and Q_max=Q (if S<0 and K>0),\n+\/\/ Q_min=B_2*K+Q and Q_max=Q if (S>0 and K<0), Q_min=Q and Q_max=A_2*K+Q (if S<0 and K<0)\n@@ -1202,2 +1199,3 @@\n-\/\/ N.B. If (S*K)<0 then the formulas for Q_min and Q_max may differ; the values may need to be swapped and adjusted to\n-\/\/ the correct type of bound (inclusive or exclusive).\n+\/\/ Note that the first R.C. value is always Q=(S*K>0 ? Q_min : Q_max).  Also Q_{min,max} = Q + {min,max}(A_2*K,B_2*K).\n+\/\/ If S*K>0 then, as the loop iterations progress, each R.C. value i*K+L = j*K+Q goes up from Q=Q_min towards Q_max.\n+\/\/ If S*K<0 then j*K+Q starts at Q=Q_max and goes down towards Q_min.\n@@ -1209,0 +1207,1 @@\n+\/\/ |    .     .    .    .    R=0  R<   R<   R<    R<   |  (against R values)\n@@ -1210,0 +1209,3 @@\n+\/\/ |    .     .    .    .    R    R    R<   R<    R<   |  (against R values)\n+\/\/\n+\/\/ R values which are out of range (>Q_max+1) are reduced to max(0,Q_max+1).  They are marked on the number line as R<.\n@@ -1211,2 +1213,5 @@\n-\/\/ if Q_min <s64 0, then use this test:\n-\/\/ j*K + s32_trunc(Q_min) <u32 clamp(R, 0, Q_max)\n+\/\/ So, if Q_min <s64 0, then use this test:\n+\/\/ j*K + s32_trunc(Q_min) <u32 clamp(R, 0, Q_max+1) if S*K>0 (R.C.E. steps upward)\n+\/\/ j*K + s32_trunc(Q_max) <u32 clamp(R, 0, Q_max+1) if S*K<0 (R.C.E. steps downward)\n+\/\/ Both formulas reduce to adding j*K to the 32-bit truncated value of the first R.C. expression value, Q:\n+\/\/ j*K + s32_trunc(Q) <u32 clamp(R, 0, Q_max+1) for all S,K\n@@ -1214,1 +1219,1 @@\n-\/\/ If the 32-bit truncation loses information, no harm is done, since certainly the clamp also returns R_2=zero.\n+\/\/ If the 32-bit truncation loses information, no harm is done, since certainly the clamp also will return R_2=zero.\n@@ -1220,0 +1225,1 @@\n+\/\/ |    .     .    .    .    R>   R    R    R<    R<   |  (against R values)\n@@ -1221,0 +1227,4 @@\n+\/\/ |    .     .    .    .    R>   R>   R    R     R<   |  (against R values)\n+\/\/\n+\/\/ R values which are out of range (<Q_min or >Q_max+1) are reduced as marked: R> up to Q_min, R< down to Q_max+1.\n+\/\/ Then the whole comparison is shifted left by Q_min, so it can take place at zero, which is a nice 32-bit value.\n@@ -1222,4 +1232,4 @@\n-\/\/ if both Q_min, Q_max >=s64 0, then use this test:\n-\/\/ j*K + 0 <u32 clamp(R, Q_min, Q_max) - Q_min\n-\/\/ or equivalently:\n-\/\/ j*K + 0 <u32 clamp(R - Q_min, 0, Q_max - Q_min)\n+\/\/ So, if both Q_min, Q_max+1 >=s64 0, then use this test:\n+\/\/ j*K + 0         <u32 clamp(R, Q_min, Q_max+1) - Q_min if S*K>0\n+\/\/ More generally:\n+\/\/ j*K + Q - Q_min <u32 clamp(R, Q_min, Q_max+1) - Q_min for all S,K\n@@ -1230,0 +1240,10 @@\n+\/\/ |    .     .    .    .    R>   R>   R>   R>    R    |  (against R values)\n+\/\/\n+\/\/ In this case, Q_min >s64 Q_max+1, even though the mathematical values of Q_min and Q_max+1 are correctly ordered.\n+\/\/ The formulas from the previous case can be used, except that the bad upper bound Q_max is replaced by max_jlong.\n+\/\/ (In fact, we could use any replacement bound from R to max_jlong inclusive, as the input to the clamp function.)\n+\/\/\n+\/\/ So if Q_min >=s64 0 but Q_max+1 <s64 0, use this test:\n+\/\/ j*K + 0         <u32 clamp(R, Q_min, max_jlong) - Q_min if S*K>0\n+\/\/ More generally:\n+\/\/ j*K + Q - Q_min <u32 clamp(R, Q_min, max_jlong) - Q_min for all S,K\n@@ -1231,6 +1251,2 @@\n-\/\/ if Q_min >=s64 0 but Q_max <s64 0, then use this test:\n-\/\/ j*K + 0 <u32 clamp(R, Q_min, R) - Q_min\n-\/\/ or equivalently:\n-\/\/ j*K + 0 <u32 clamp(R - Q_min, 0, R - Q_min)\n-\/\/ or also equivalently:\n-\/\/ j*K + 0 <u32 max(0, R - Q_min)\n+\/\/ Dropping the bad bound means only Q_min is used to reduce the range of R:\n+\/\/ j*K + Q - Q_min <u32 max(Q_min, R) - Q_min for all S,K\n@@ -1238,2 +1254,2 @@\n-\/\/ Here the clamp function is a simple 64-bit min\/max:\n-\/\/ clamp(X, L, H) := max(L, min(X, H))\n+\/\/ Here the clamp function is a 64-bit min\/max that reduces the dynamic range of its R operand to the required [L,H]:\n+\/\/     clamp(X, L, H) := max(L, min(X, H))\n@@ -1242,6 +1258,23 @@\n-\/\/ Tests above can be merged into a single one:\n-\/\/ L_clamp = Q_min < 0 ? 0 : Q_min\n-\/\/ H_clamp = Q_max < Q_min ? R : Q_max\n-\/\/ j*K + Q_min - L_clamp <u32 clamp(R, L_clamp, H_clamp) - L_clamp\n-\/\/ or equivalently:\n-\/\/ j*K + Q_min - L_clamp <u32 clamp(R - L_clamp, 0, H_clamp - L_clamp)\n+\/\/ All of the formulas above can be merged into a single one:\n+\/\/     L_clamp = Q_min < 0 ? 0 : Q_min        --whether and how far to left-shift\n+\/\/     H_clamp = Q_max+1 < Q_min ? max_jlong : Q_max+1\n+\/\/             = Q_max+1 < 0 && Q_min >= 0 ? max_jlong : Q_max+1\n+\/\/     Q_first = Q = (S*K>0 ? Q_min : Q_max) = (C*K+L)\n+\/\/     R_clamp = clamp(R, L_clamp, H_clamp)   --reduced dynamic range\n+\/\/     replacement R.C.:\n+\/\/       j*K + Q_first - L_clamp <u32 R_clamp - L_clamp\n+\/\/     or equivalently:\n+\/\/       j*K + L_2 <u32 R_2\n+\/\/     where\n+\/\/       L_2 = Q_first - L_clamp\n+\/\/       R_2 = R_clamp - L_clamp\n+\/\/\n+\/\/ Note on why R is never negative:\n+\/\/\n+\/\/ Various details of this transformation would break badly if R could be negative, so this transformation only\n+\/\/ operates after obtaining hard evidence that R<0 is impossible.  For example, if R comes from a LoadRange node, we\n+\/\/ know R cannot be negative.  For explicit checks (of both int and long) a proof is constructed in\n+\/\/ inline_preconditions_checkIndex, which triggers an uncommon trap if R<0, then wraps R in a ConstraintCastNode with a\n+\/\/ non-negative type.  Later on, when IdealLoopTree::is_range_check_if looks for an optimizable R.C., it checks that\n+\/\/ the type of that R node is non-negative.  Any \"wild\" R node that could be negative is not treated as an optimizable\n+\/\/ R.C., but R values from a.length and inside checkIndex are good to go.\n@@ -1249,2 +1282,0 @@\n-\/\/ Readers may find the equivalent forms easier to reason about, but the forms given first generate better code.\n-\n@@ -1256,0 +1287,6 @@\n+  Node* int_zero = _igvn.intcon(0);\n+  set_ctrl(int_zero, this->C->root());\n+  Node* long_one = _igvn.longcon(1);\n+  set_ctrl(long_one, this->C->root());\n+  Node* int_stride = _igvn.intcon(checked_cast<int>(stride_con));\n+  set_ctrl(int_stride, this->C->root());\n@@ -1269,2 +1306,2 @@\n-    bool converted = false;\n-    bool ok = is_scaled_iv_plus_offset(rc_cmp->in(1), iv_add, &scale, &offset, T_LONG, &converted);\n+    bool short_scale = false;\n+    bool ok = is_scaled_iv_plus_offset(rc_cmp->in(1), iv_add, T_LONG, &scale, &offset, &short_scale);\n@@ -1282,1 +1319,1 @@\n-    if (converted) {\n+    if (short_scale) {\n@@ -1284,1 +1321,1 @@\n-      \/\/ i*K + L <u64 R\n+      \/\/ (int)i*K + L <u64 R\n@@ -1287,1 +1324,1 @@\n-      \/\/ to protect against an overflow of i*K\n+      \/\/ to protect against an overflow of (int)i*K\n@@ -1289,7 +1326,6 @@\n-      \/\/ Because if i*K overflows, there are K,L where:\n-      \/\/ i*K + L <u64 R is false\n-      \/\/ when\n-      \/\/ i*(long)K is > (long)max_jint and < R\n-      \/\/ and so i*(long)K + L <u64 R is true\n-      \/\/ As a consequence simply converting:\n-      \/\/ i*K + L <u64 R to i*(long)K + L <u64 R could cause incorrect execution\n+      \/\/ Because if (int)i*K overflows, there are K,L where:\n+      \/\/ (int)i*K + L <u64 R is false because (int)i*K+L overflows to a negative which becomes a huge u64 value.\n+      \/\/ But if i*(long)K + L is >u64 (long)max_jint and still is <u64 R, then\n+      \/\/ i*(long)K + L <u64 R is true.\n+      \/\/\n+      \/\/ As a consequence simply converting i*K + L <u64 R to i*(long)K + L <u64 R could cause incorrect execution.\n@@ -1298,2 +1334,2 @@\n-      \/\/ i*K <u64 (long)max_jint + 1\n-      \/\/ which implies i*K + L <u64 (long)max_jint + 1 + L\n+      \/\/ (int)i*K <u64 (long)max_jint + 1\n+      \/\/ which implies (int)i*K + L <u64 (long)max_jint + 1 + L\n@@ -1304,1 +1340,1 @@\n-      \/\/ Note, there are K,L where i*K overflows and\n+      \/\/ Note, there are also K,L where i*K overflows and\n@@ -1308,1 +1344,2 @@\n-      \/\/ (but not incorrect execution) for unlikely corner cases with overflow\n+      \/\/ (but not incorrect execution) for unlikely corner cases with overflow.\n+      \/\/ If this causes problems in practice, we could maybe direct excution to a post-loop, instead of deoptimizing.\n@@ -1318,2 +1355,0 @@\n-    Node* Z_2 = new ConvI2LNode(inner_iters_actual_int, TypeLong::LONG);\n-    register_new_node(Z_2, entry_control);\n@@ -1324,10 +1359,19 @@\n-    \/\/   j*K + L_2 <u64 R    where L_2 = C*K+L\n-    Node* L_2 = new MulLNode(C, K);\n-    register_new_node(L_2, entry_control);\n-    L_2 = new AddLNode(L_2, L);\n-    register_new_node(L_2, entry_control);\n-\n-    \/\/ Compute endpoints of the range of values j*K.\n-    \/\/  Q_min = (j=0)*K + L_2;  Q_max = (j=Z_2)*K + L_2\n-    Node* Q_min = L_2;\n-    Node* Q_max = new MulLNode(Z_2, K);\n+    \/\/   j*K + Q <u64 R    where Q = Q_first = C*K+L\n+    Node* Q_first = new MulLNode(C, K);\n+    register_new_node(Q_first, entry_control);\n+    Q_first = new AddLNode(Q_first, L);\n+    register_new_node(Q_first, entry_control);\n+\n+    \/\/ Compute endpoints of the range of values j*K + Q.\n+    \/\/  Q_min = (j=0)*K + Q;  Q_max = (j=B_2)*K + Q\n+    Node* Q_min = Q_first;\n+\n+    \/\/ Compute the exact ending value B_2 (which is really A_2 if S < 0)\n+    Node* B_2 = new LoopLimitNode(this->C, int_zero, inner_iters_actual_int, int_stride);\n+    register_new_node(B_2, entry_control);\n+    B_2 = new SubINode(B_2, int_stride);\n+    register_new_node(B_2, entry_control);\n+    B_2 = new ConvI2LNode(B_2);\n+    register_new_node(B_2, entry_control);\n+\n+    Node* Q_max = new MulLNode(B_2, K);\n@@ -1335,1 +1379,1 @@\n-    Q_max = new AddLNode(Q_max, L_2);\n+    Q_max = new AddLNode(Q_max, Q_first);\n@@ -1338,0 +1382,5 @@\n+    if (scale * stride_con < 0) {\n+      swap(Q_min, Q_max);\n+    }\n+    \/\/ Now, mathematically, Q_max > Q_min, and they are close enough so that (Q_max-Q_min) fits in 32 bits.\n+\n@@ -1345,0 +1394,4 @@\n+    \/\/ (This could also be coded bitwise as L_clamp = Q_min & ~(Q_min>>63).)\n+\n+    Node* Q_max_plus_one = new AddLNode(Q_max, long_one);\n+    register_new_node(Q_max_plus_one, entry_control);\n@@ -1346,2 +1399,5 @@\n-    \/\/ H_clamp = Q_max < Q_min ? R : Q_max\n-    Node* Q_max_cmp = new CmpLNode(Q_max, Q_min);\n+    \/\/ H_clamp = Q_max+1 < Q_min ? max_jlong : Q_max+1\n+    \/\/ (Because Q_min and Q_max are close, the overflow check could also be encoded as Q_max+1 < 0 & Q_min >= 0.)\n+    Node* max_jlong_long = _igvn.longcon(max_jlong);\n+    set_ctrl(max_jlong_long, this->C->root());\n+    Node* Q_max_cmp = new CmpLNode(Q_max_plus_one, Q_min);\n@@ -1351,1 +1407,1 @@\n-    Node* H_clamp = new CMoveLNode(Q_max_bool, Q_max, R, TypeLong::LONG);\n+    Node* H_clamp = new CMoveLNode(Q_max_bool, Q_max_plus_one, max_jlong_long, TypeLong::LONG);\n@@ -1353,0 +1409,1 @@\n+    \/\/ (This could also be coded bitwise as H_clamp = ((Q_max+1)<<1 | M)>>>1 where M = (Q_max+1)>>63 & ~Q_min>>63.)\n@@ -1355,2 +1412,4 @@\n-    \/\/ that is: R_2 = clamp(R, L_clamp, H_clamp) if Q_min < 0\n-    \/\/ or:      R_2 = clamp(R, L_clamp, H_clamp) - Q_min if Q_min > 0\n+    \/\/ that is:  R_2 = clamp(R, L_clamp=0, H_clamp=Q_max)      if Q_min < 0\n+    \/\/ or else:  R_2 = clamp(R, L_clamp,   H_clamp) - Q_min    if Q_min >= 0\n+    \/\/ and also: R_2 = clamp(R, L_clamp,   Q_max+1) - L_clamp  if Q_min < Q_max+1 (no overflow)\n+    \/\/ or else:  R_2 = clamp(R, L_clamp, *no limit*)- L_clamp  if Q_max+1 < Q_min (overflow)\n@@ -1363,7 +1422,8 @@\n-    \/\/ Q = Q_min - L_clamp\n-    \/\/ that is: Q = Q_min - 0 if Q_min < 0\n-    \/\/ or:      Q = Q_min - Q_min = 0 if Q_min > 0\n-    Node* Q = new SubLNode(Q_min, L_clamp);\n-    register_new_node(Q, entry_control);\n-    Q = new ConvL2INode(Q, TypeInt::INT);\n-    register_new_node(Q, entry_control);\n+    \/\/ L_2 = Q_first - L_clamp\n+    \/\/ We are subtracting L_clamp from both sides of the <u32 comparison.\n+    \/\/ If S*K>0, then Q_first == 0 and the R.C. expression at -L_clamp and steps upward to Q_max-L_clamp.\n+    \/\/ If S*K<0, then Q_first != 0 and the R.C. expression starts high and steps downward to Q_min-L_clamp.\n+    Node* L_2 = new SubLNode(Q_first, L_clamp);\n+    register_new_node(L_2, entry_control);\n+    L_2 = new ConvL2INode(L_2, TypeInt::INT);\n+    register_new_node(L_2, entry_control);\n@@ -1371,1 +1431,5 @@\n-    \/\/ Transform the range check\n+    \/\/ Transform the range check using the computed values L_2\/R_2\n+    \/\/ from:   i*K + L   <u64 R\n+    \/\/ to:     j*K + L_2 <u32 R_2\n+    \/\/ that is:\n+    \/\/   (j*K + Q_first) - L_clamp <u32 clamp(R, L_clamp, H_clamp) - L_clamp\n@@ -1376,1 +1440,1 @@\n-    Node* scaled_iv_plus_offset = scaled_iv_plus_offset = new AddINode(scaled_iv, Q);\n+    Node* scaled_iv_plus_offset = scaled_iv_plus_offset = new AddINode(scaled_iv, L_2);\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":153,"deletions":89,"binary":false,"changes":242,"status":"modified"},{"patch":"@@ -1268,1 +1268,1 @@\n-  bool is_scaled_iv(Node* exp, Node* iv, jlong* p_scale, BasicType bt, bool* converted);\n+  bool is_scaled_iv(Node* exp, Node* iv, BasicType bt, jlong* p_scale, bool* p_short_scale, int depth = 0);\n@@ -1273,1 +1273,1 @@\n-  bool is_scaled_iv_plus_offset(Node* exp, Node* iv, jlong* p_scale, Node** p_offset, BasicType bt, bool* converted = NULL, int depth = 0);\n+  bool is_scaled_iv_plus_offset(Node* exp, Node* iv, BasicType bt, jlong* p_scale, Node** p_offset, bool* p_short_scale = NULL, int depth = 0);\n@@ -1276,1 +1276,1 @@\n-    if (is_scaled_iv_plus_offset(exp, iv, &long_scale, p_offset, T_INT)) {\n+    if (is_scaled_iv_plus_offset(exp, iv, T_INT, &long_scale, p_offset)) {\n@@ -1285,0 +1285,6 @@\n+  \/\/ Helper for finding more complex matches to is_scaled_iv_plus_offset.\n+  bool is_scaled_iv_plus_extra_offset(Node* exp1, Node* offset2, Node* iv,\n+                                      BasicType bt,\n+                                      jlong* p_scale, Node** p_offset,\n+                                      bool* p_short_scale, int depth);\n+\n@@ -1661,0 +1667,1 @@\n+\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":10,"deletions":3,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -1156,1 +1156,6 @@\n-    guarantee(t != NULL, \"must be con\");\n+    guarantee(t != NULL && t->is_con(), \"must be con\");\n+    return t->get_con_as_long(bt);\n+  }\n+  jlong find_integer_as_long(BasicType bt, jlong value_if_unknown) const {\n+    const TypeInteger* t = find_integer_type(bt);\n+    if (t == NULL || !t->is_con())  return value_if_unknown;\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -99,0 +99,146 @@\n+\n+    @Test\n+    @IR(counts = { IRNode.LOOP, \"1\"})\n+    @IR(failOn = { IRNode.COUNTEDLOOP})\n+    public static void testStrideNegScaleNeg(long start, long stop, long length, long offset) {\n+        final long scale = -1;\n+        final long stride = 1;\n+        for (long i = stop; i > start; i -= stride) {\n+            Objects.checkIndex(scale * i + offset, length);\n+        }\n+    }\n+\n+    @Run(test = \"testStrideNegScaleNeg\")\n+    private void testStrideNegScaleNeg_runner() {\n+        testStrideNegScaleNeg(0, 100, 100, 100);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.LOOP, \"1\" })\n+    @IR(failOn = { IRNode.COUNTEDLOOP })\n+    public static void testStrideNegScaleNegInIntLoop1(int start, int stop, long length, long offset) {\n+        final long scale = -2;\n+        final int stride = 1;\n+\n+        for (int i = stop; i > start; i -= stride) {\n+            Objects.checkIndex(scale * i + offset, length);\n+        }\n+    }\n+\n+    @Run(test = \"testStrideNegScaleNegInIntLoop1\")\n+    private void testStrideNegScaleNegInIntLoop1_runner() {\n+        testStrideNegScaleNegInIntLoop1(0, 100, 200, 200);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.LOOP, \"1\" })\n+    @IR(failOn = { IRNode.COUNTEDLOOP })\n+    public static void testStrideNegScaleNegInIntLoop2(int start, int stop, long length, long offset) {\n+        final int scale = -2;\n+        final int stride = 1;\n+\n+        for (int i = stop; i > start; i -= stride) {\n+            Objects.checkIndex(scale * i + offset, length);\n+        }\n+    }\n+\n+    @Run(test = \"testStrideNegScaleNegInIntLoop2\")\n+    private void testStrideNegScaleNegInIntLoop2_runner() {\n+        testStrideNegScaleNegInIntLoop2(0, 100, 200, 200);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.LOOP, \"1\"})\n+    @IR(failOn = { IRNode.COUNTEDLOOP})\n+    public static void testStrideNegScalePos(long start, long stop, long length, long offset) {\n+        final long scale = 1;\n+        final long stride = 1;\n+        for (long i = stop-1; i >= start; i -= stride) {\n+            Objects.checkIndex(scale * i + offset, length);\n+        }\n+    }\n+\n+    @Run(test = \"testStrideNegScalePos\")\n+    private void testStrideNegScalePos_runner() {\n+        testStrideNegScalePos(0, 100, 100, 0);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.LOOP, \"1\" })\n+    @IR(failOn = { IRNode.COUNTEDLOOP })\n+    public static void testStrideNegScalePosInIntLoop1(int start, int stop, long length, long offset) {\n+        final long scale = 2;\n+        final int stride = 1;\n+        for (int i = stop-1; i >= start; i -= stride) {\n+            Objects.checkIndex(scale * i + offset, length);\n+        }\n+    }\n+\n+    @Run(test = \"testStrideNegScalePosInIntLoop1\")\n+    private void testStrideNegScalePosInIntLoop1_runner() {\n+        testStrideNegScalePosInIntLoop1(0, 100, 200, 0);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.LOOP, \"1\" })\n+    @IR(failOn = { IRNode.COUNTEDLOOP })\n+    public static void testStrideNegScalePosInIntLoop2(int start, int stop, long length, long offset) {\n+        final int scale = 2;\n+        final int stride = 1;\n+        for (int i = stop-1; i >= start; i -= stride) {\n+            Objects.checkIndex(scale * i + offset, length);\n+        }\n+    }\n+\n+    @Run(test = \"testStrideNegScalePosInIntLoop2\")\n+    private void testStrideNegScalePosInIntLoop2_runner() {\n+        testStrideNegScalePosInIntLoop1(0, 100, 200, 0);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.LOOP, \"1\"})\n+    @IR(failOn = { IRNode.COUNTEDLOOP})\n+    public static void testStridePosScaleNeg(long start, long stop, long length, long offset) {\n+        final long scale = -1;\n+        final long stride = 1;\n+        for (long i = start; i < stop; i += stride) {\n+            Objects.checkIndex(scale * i + offset, length);\n+        }\n+    }\n+\n+    @Run(test = \"testStridePosScaleNeg\")\n+    private void testStridePosScaleNeg_runner() {\n+        testStridePosScaleNeg(0, 100, 100, 99);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.LOOP, \"1\"})\n+    @IR(failOn = { IRNode.COUNTEDLOOP})\n+    public static void testStridePosScaleNegInIntLoop1(int start, int stop, long length, long offset) {\n+        final long scale = -2;\n+        final int stride = 1;\n+        for (int i = start; i < stop; i += stride) {\n+            Objects.checkIndex(scale * i + offset, length);\n+        }\n+    }\n+\n+    @Run(test = \"testStridePosScaleNegInIntLoop1\")\n+    private void testStridePosScaleNegInIntLoop1_runner() {\n+        testStridePosScaleNegInIntLoop1(0, 100, 200, 198);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.LOOP, \"1\"})\n+    @IR(failOn = { IRNode.COUNTEDLOOP})\n+    public static void testStridePosScaleNegInIntLoop2(int start, int stop, long length, long offset) {\n+        final int scale = -2;\n+        final int stride = 1;\n+        for (int i = start; i < stop; i += stride) {\n+            Objects.checkIndex(scale * i + offset, length);\n+        }\n+    }\n+\n+    @Run(test = \"testStridePosScaleNegInIntLoop2\")\n+    private void testStridePosScaleNegInIntLoop2_runner() {\n+        testStridePosScaleNegInIntLoop1(0, 100, 200, 198);\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestLongRangeChecks.java","additions":146,"deletions":0,"binary":false,"changes":146,"status":"modified"},{"patch":"@@ -130,0 +130,67 @@\n+    private static void testOverflow(String method, long start, long stop, long length, long offset0, long offset1) throws Exception {\n+        Method m = newClassLoader().loadClass(\"TestLongRangeCheck\").getDeclaredMethod(method, long.class, long.class, long.class, long.class);\n+        m.invoke(null, start, stop, length, offset0);\n+        compile(m);\n+\n+        m.invoke(null, start, stop, length, offset0);\n+        assertIsCompiled(m);\n+        try {\n+            m.invoke(null, start, stop, length, offset1);\n+            throw new RuntimeException(\"should have thrown\");\n+        } catch(InvocationTargetException e) {\n+            if (!(e.getCause() instanceof IndexOutOfBoundsException)) {\n+                throw new RuntimeException(\"unexpected exception\");\n+            }\n+        }\n+        assertIsNotCompiled(m);\n+    }\n+\n+    private static void testConditional(String method, long start, long stop, long length, long offset0, long offset1, long start1, long stop1) throws Exception {\n+        Method m;\n+\n+        if (start1 != start) {\n+            m = newClassLoader().loadClass(\"TestLongRangeCheck\").getDeclaredMethod(method, long.class, long.class, long.class, long.class, long.class, long.class);\n+            m.invoke(null, start, stop, length, offset0, start, stop);\n+            compile(m);\n+\n+            m.invoke(null, start, stop, length, offset0, start, stop);\n+            assertIsCompiled(m);\n+            try {\n+                m.invoke(null, start, stop, length, offset1, start1-1, stop1);\n+                throw new RuntimeException(\"should have thrown\");\n+            } catch(InvocationTargetException e) {\n+                if (!(e.getCause() instanceof IndexOutOfBoundsException)) {\n+                    throw new RuntimeException(\"unexpected exception\");\n+                }\n+            }\n+            assertIsNotCompiled(m);\n+        }\n+\n+        if (stop1 != stop) {\n+            m = newClassLoader().loadClass(\"TestLongRangeCheck\").getDeclaredMethod(method, long.class, long.class, long.class, long.class, long.class, long.class);\n+            m.invoke(null, start, stop, length, offset0, start, stop);\n+            compile(m);\n+\n+            m.invoke(null, start, stop, length, offset0, start, stop);\n+            assertIsCompiled(m);\n+            try {\n+                m.invoke(null, start, stop, length, offset1, start1, stop1+1);\n+                throw new RuntimeException(\"should have thrown\");\n+            } catch(InvocationTargetException e) {\n+                if (!(e.getCause() instanceof IndexOutOfBoundsException)) {\n+                    throw new RuntimeException(\"unexpected exception\");\n+                }\n+            }\n+            assertIsNotCompiled(m);\n+        }\n+\n+        m = newClassLoader().loadClass(\"TestLongRangeCheck\").getDeclaredMethod(method, long.class, long.class, long.class, long.class, long.class, long.class);\n+        m.invoke(null, start, stop, length, offset0, start, stop);\n+        compile(m);\n+\n+        m.invoke(null, start, stop, length, offset0, start, stop);\n+        assertIsCompiled(m);\n+\n+        m.invoke(null, start, stop, length, offset1, start1, stop1);\n+        assertIsCompiled(m);\n+    }\n@@ -160,18 +227,4 @@\n-\n-        {\n-            Method m = newClassLoader().loadClass(\"TestLongRangeCheck\").getDeclaredMethod(\"testStridePosScalePos\", long.class, long.class, long.class, long.class);\n-            m.invoke(null, 0, 100, 100, 0);\n-            compile(m);\n-\n-            m.invoke(null, 0, 100, 100, 0);\n-            assertIsCompiled(m);\n-            try {\n-                m.invoke(null, 0, 100, 100, Long.MAX_VALUE - 50);\n-                throw new RuntimeException(\"should have thrown\");\n-            } catch(InvocationTargetException e) {\n-                if (!(e.getCause() instanceof IndexOutOfBoundsException)) {\n-                    throw new RuntimeException(\"unexpected exception\");\n-                }\n-            }\n-            assertIsNotCompiled(m);\n-        }\n+        testOverflow(\"testStridePosScalePos\", 0, 100, 100, 0, Long.MAX_VALUE - 50);\n+        testOverflow(\"testStrideNegScaleNeg\", 0, 100, 100, 100, Long.MIN_VALUE + 50);\n+        testOverflow(\"testStrideNegScalePos\", 0, 100, 100, 0, Long.MAX_VALUE - 50);\n+        testOverflow(\"testStridePosScaleNeg\", 0, 100, 100, 99, Long.MIN_VALUE + 50);\n@@ -180,16 +233,8 @@\n-        {\n-            Method m = newClassLoader().loadClass(\"TestLongRangeCheck\").getDeclaredMethod(\"testStridePosScalePosConditional\", long.class, long.class, long.class, long.class, long.class, long.class);\n-            m.invoke(null, 0, 100, 100, 0, 0, 100);\n-            compile(m);\n-\n-            m.invoke(null, 0, 100, 100, -50, 50, 100);\n-            assertIsCompiled(m);\n-        }\n-        {\n-            Method m = newClassLoader().loadClass(\"TestLongRangeCheck\").getDeclaredMethod(\"testStridePosScalePosConditional\", long.class, long.class, long.class, long.class, long.class, long.class);\n-            m.invoke(null, 0, 100, 100, 0, 0, 100);\n-            compile(m);\n-\n-            m.invoke(null, 0, 100, Long.MAX_VALUE, Long.MAX_VALUE - 50, 0, 50);\n-            assertIsCompiled(m);\n-        }\n+        testConditional(\"testStridePosScalePosConditional\", 0, 100, 100, 0, -50, 50, 100);\n+        testConditional(\"testStridePosScalePosConditional\", 0, 100, Long.MAX_VALUE, 0, Long.MAX_VALUE - 50, 0, 50);\n+        testConditional(\"testStrideNegScaleNegConditional\", 0, 100, 100, 100, 50, 0, 51);\n+        testConditional(\"testStrideNegScaleNegConditional\", 0, 100, Long.MAX_VALUE, 100, Long.MIN_VALUE + 50, 52, 100);\n+        testConditional(\"testStrideNegScalePosConditional\", 0, 100, 100, 0, -50, 50, 100);\n+        testConditional(\"testStrideNegScalePosConditional\", 0, 100, Long.MAX_VALUE, 100, Long.MAX_VALUE - 50, 0, 50);\n+        testConditional(\"testStridePosScaleNegConditional\", 0, 100, 100, 99, 50, 0, 51);\n+        testConditional(\"testStridePosScaleNegConditional\", 0, 100, Long.MAX_VALUE, 99, Long.MIN_VALUE + 50, 52, 100);\n@@ -224,17 +269,4 @@\n-        {\n-            Method m = newClassLoader().loadClass(\"TestLongRangeCheck\").getDeclaredMethod(\"testStridePosScalePosInIntLoop\", long.class, long.class, long.class, long.class);\n-            m.invoke(null, 0, 100, 100, 0);\n-            compile(m);\n-\n-            m.invoke(null, 0, 100, 100, 0);\n-            assertIsCompiled(m);\n-            try {\n-                m.invoke(null, 0, 100, 100, Long.MAX_VALUE - 50);\n-                throw new RuntimeException(\"should have thrown\");\n-            } catch(InvocationTargetException e) {\n-                if (!(e.getCause() instanceof IndexOutOfBoundsException)) {\n-                    throw new RuntimeException(\"unexpected exception\");\n-                }\n-            }\n-            assertIsNotCompiled(m);\n-        }\n+        testOverflow(\"testStridePosScalePosInIntLoop\", 0, 100, 100, 0, Long.MAX_VALUE - 50);\n+        testOverflow(\"testStrideNegScaleNegInIntLoop\", 0, 100, 100, 100, Long.MIN_VALUE + 50);\n+        testOverflow(\"testStrideNegScalePosInIntLoop\", 0, 100, 100, 0, Long.MAX_VALUE - 50);\n+        testOverflow(\"testStridePosScaleNegInIntLoop\", 0, 100, 100, 99, Long.MIN_VALUE + 50);\n@@ -242,16 +274,8 @@\n-        {\n-            Method m = newClassLoader().loadClass(\"TestLongRangeCheck\").getDeclaredMethod(\"testStridePosScalePosConditional\", long.class, long.class, long.class, long.class, long.class, long.class);\n-            m.invoke(null, 0, 100, 100, 0, 0, 100);\n-            compile(m);\n-\n-            m.invoke(null, 0, 100, 100, -50, 50, 100);\n-            assertIsCompiled(m);\n-        }\n-        {\n-            Method m = newClassLoader().loadClass(\"TestLongRangeCheck\").getDeclaredMethod(\"testStridePosScalePosConditional\", long.class, long.class, long.class, long.class, long.class, long.class);\n-            m.invoke(null, 0, 100, 100, 0, 0, 100);\n-            compile(m);\n-\n-            m.invoke(null, 0, 100, Long.MAX_VALUE, Long.MAX_VALUE - 50, 0, 50);\n-            assertIsCompiled(m);\n-        }\n+        testConditional(\"testStridePosScalePosConditionalInIntLoop\", 0, 100, 100, 0, -50, 50, 100);\n+        testConditional(\"testStridePosScalePosConditionalInIntLoop\", 0, 100, Long.MAX_VALUE, 0, Long.MAX_VALUE - 50, 0, 50);\n+        testConditional(\"testStrideNegScaleNegConditionalInIntLoop\", 0, 100, 100, 100, 50, 0, 51);\n+        testConditional(\"testStrideNegScaleNegConditionalInIntLoop\", 0, 100, Long.MAX_VALUE, 100, Long.MIN_VALUE + 50, 52, 100);\n+        testConditional(\"testStrideNegScalePosConditionalInIntLoop\", 0, 100, 100, 0, -50, 50, 100);\n+        testConditional(\"testStrideNegScalePosConditionalInIntLoop\", 0, 100, Long.MAX_VALUE, 100, Long.MAX_VALUE - 50, 0, 50);\n+        testConditional(\"testStridePosScaleNegConditionalInIntLoop\", 0, 100, 100, 99, 50, 0, 51);\n+        testConditional(\"testStridePosScaleNegConditionalInIntLoop\", 0, 100, Long.MAX_VALUE, 99, Long.MIN_VALUE + 50, 52, 100);\n@@ -414,0 +438,30 @@\n+    public static void testStrideNegScaleNegConditional(long start, long stop, long length, long offset, long start2, long stop2) {\n+        final long scale = -1;\n+        final long stride = 1;\n+        for (long i = stop; i > start; i -= stride) {\n+            if (i >= start2 && i < stop2) {\n+                Preconditions.checkIndex(scale * i + offset, length, null);\n+            }\n+        }\n+    }\n+\n+    public static void testStrideNegScalePosConditional(long start, long stop, long length, long offset, long start2, long stop2) {\n+        final long scale = 1;\n+        final long stride = 1;\n+        for (long i = stop-1; i >= start; i -= stride) {\n+            if (i >= start2 && i < stop2) {\n+                Preconditions.checkIndex(scale * i + offset, length, null);\n+            }\n+        }\n+    }\n+\n+    public static void testStridePosScaleNegConditional(long start, long stop, long length, long offset, long start2, long stop2) {\n+        final long scale = -1;\n+        final long stride = 1;\n+        for (long i = start; i < stop; i += stride) {\n+            if (i >= start2 && i < stop2) {\n+                Preconditions.checkIndex(scale * i + offset, length, null);\n+            }\n+        }\n+    }\n+\n@@ -532,1 +586,0 @@\n-        Preconditions.checkIndex(0, length, null);\n@@ -535,0 +588,33 @@\n+        for (int i = (int)start; i < (int)stop; i += stride) {\n+            if (i >= (int)start2 && i < (int)stop2) {\n+                Preconditions.checkIndex(scale * i + offset, length, null);\n+            }\n+        }\n+    }\n+\n+    public static void testStrideNegScaleNegConditionalInIntLoop(long start, long stop, long length, long offset, long start2, long stop2) {\n+        checkInputs(start, stop, start2, stop2);\n+        final long scale = -1;\n+        final int stride = 1;\n+        for (int i = (int)stop; i > (int)start; i -= stride) {\n+            if (i >= (int)start2 && i < (int)stop2) {\n+                Preconditions.checkIndex(scale * i + offset, length, null);\n+            }\n+        }\n+    }\n+\n+    public static void testStrideNegScalePosConditionalInIntLoop(long start, long stop, long length, long offset, long start2, long stop2) {\n+        checkInputs(start, stop, start2, stop2);\n+        final long scale = 1;\n+        final int stride = 1;\n+        for (int i = (int)(stop-1); i >= (int)start; i -= stride) {\n+            if (i >= (int)start2 && i < (int)stop2) {\n+                Preconditions.checkIndex(scale * i + offset, length, null);\n+            }\n+        }\n+    }\n+\n+    public static void testStridePosScaleNegConditionalInIntLoop(long start, long stop, long length, long offset, long start2, long stop2) {\n+        checkInputs(start, stop, start2, stop2);\n+        final long scale = -1;\n+        final int stride = 1;\n","filename":"test\/hotspot\/jtreg\/compiler\/rangechecks\/TestLongRangeCheck.java","additions":154,"deletions":68,"binary":false,"changes":222,"status":"modified"}]}