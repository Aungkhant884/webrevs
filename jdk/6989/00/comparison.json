{"files":[{"patch":"@@ -1112,2 +1112,0 @@\n-      Node *rc_exp = cmp->in(1);\n-      Node *limit = cmp->in(2);\n@@ -1124,0 +1122,2 @@\n+        Node *rc_exp = cmp->in(1);\n+        Node *limit = cmp->in(2);\n@@ -2526,1 +2526,1 @@\n-bool PhaseIdealLoop::is_scaled_iv(Node* exp, Node* iv, jlong* p_scale, BasicType bt, bool* converted) {\n+bool PhaseIdealLoop::is_scaled_iv(Node* exp, Node* iv, jlong* p_scale, BasicType bt) {\n@@ -2535,7 +2535,0 @@\n-  if (bt == T_LONG && iv->bottom_type()->isa_int() && exp->Opcode() == Op_ConvI2L) {\n-    exp = exp->in(1);\n-    bt = T_INT;\n-    if (converted != NULL) {\n-      *converted = true;\n-    }\n-  }\n@@ -2575,1 +2568,2 @@\n-bool PhaseIdealLoop::is_scaled_iv_plus_offset(Node* exp, Node* iv, jlong* p_scale, Node** p_offset, BasicType bt, bool* converted, int depth) {\n+bool PhaseIdealLoop::is_scaled_iv_plus_offset(Node* exp, Node* iv, jlong* p_scale, Node** p_offset, BasicType bt, bool* p_converted, int depth) {\n+  bool converted = false;\n@@ -2577,1 +2571,6 @@\n-  if (is_scaled_iv(exp, iv, p_scale, bt, converted)) {\n+  if (bt == T_LONG && iv->bottom_type()->isa_int() && exp->Opcode() == Op_ConvI2L) {\n+    exp = exp->in(1);\n+    bt = T_INT;\n+    converted = true;\n+  }\n+  if (is_scaled_iv(exp, iv, p_scale, bt)) {\n@@ -2583,0 +2582,3 @@\n+    if (p_converted != NULL) {\n+      *p_converted = converted;\n+    }\n@@ -2588,1 +2590,1 @@\n-    if (is_scaled_iv(exp->in(1), iv, p_scale, bt, converted)) {\n+    if (is_scaled_iv(exp->in(1), iv, p_scale, bt)) {\n@@ -2592,0 +2594,3 @@\n+      if (p_converted != NULL) {\n+        *p_converted = converted;\n+      }\n@@ -2594,1 +2599,1 @@\n-    if (is_scaled_iv(exp->in(2), iv, p_scale, bt, converted)) {\n+    if (is_scaled_iv(exp->in(2), iv, p_scale, bt)) {\n@@ -2598,0 +2603,3 @@\n+      if (p_converted != NULL) {\n+        *p_converted = converted;\n+      }\n@@ -2600,12 +2608,3 @@\n-    if (exp->in(2)->is_Con()) {\n-      Node* offset2 = NULL;\n-      if (depth < 2 &&\n-          is_scaled_iv_plus_offset(exp->in(1), iv, p_scale,\n-                                   p_offset != NULL ? &offset2 : NULL, bt, converted, depth+1)) {\n-        if (p_offset != NULL) {\n-          Node *ctrl_off2 = get_ctrl(offset2);\n-          Node* offset = AddNode::make(offset2, exp->in(2), bt);\n-          register_new_node(offset, ctrl_off2);\n-          *p_offset = offset;\n-        }\n-        return true;\n+    if (is_scaled_iv_plus_extra_offset(exp->in(1), exp->in(2), iv, p_scale, p_offset, bt, converted, depth)) {\n+      if (p_converted != NULL) {\n+        *p_converted = converted;\n@@ -2613,0 +2612,7 @@\n+      return true;\n+    }\n+    if (is_scaled_iv_plus_extra_offset(exp->in(2), exp->in(1), iv, p_scale, p_offset, bt, converted, depth)) {\n+      if (p_converted != NULL) {\n+        *p_converted = converted;\n+      }\n+      return true;\n@@ -2615,1 +2621,1 @@\n-    if (is_scaled_iv(exp->in(1), iv, p_scale, bt, converted)) {\n+    if (is_scaled_iv(exp->in(1), iv, p_scale, bt)) {\n@@ -2624,0 +2630,3 @@\n+      if (p_converted != NULL) {\n+        *p_converted = converted;\n+      }\n@@ -2626,1 +2635,5 @@\n-    if (is_scaled_iv(exp->in(2), iv, p_scale, bt, converted)) {\n+    jlong scale;\n+    if (is_scaled_iv(exp->in(2), iv, &scale, bt)) {\n+      if (scale == min_signed_integer(bt)) {\n+        return false;\n+      }\n@@ -2629,4 +2642,1 @@\n-        if (*p_scale == min_signed_integer(bt)) {\n-          return false;\n-        }\n-        *p_scale *= -1;\n+        scale *= -1;\n@@ -2635,0 +2645,6 @@\n+      if (p_scale != NULL) {\n+        *p_scale = scale;\n+      }\n+      if (p_converted != NULL) {\n+        *p_converted = converted;\n+      }\n@@ -2641,0 +2657,26 @@\n+bool PhaseIdealLoop::is_scaled_iv_plus_extra_offset(Node* exp1, Node* exp2, Node* iv, jlong* p_scale, Node** p_offset,\n+                                                    BasicType bt, bool& converted, int depth) {\n+  Node* offset2 = NULL;\n+  if (depth < 2 &&\n+          is_scaled_iv_plus_offset(exp1, iv, p_scale,\n+                               &offset2, bt, &converted, depth+1)) {\n+    if (bt == T_LONG && _igvn.type(offset2)->isa_int() &&\n+        (!_igvn.type(offset2)->is_int()->is_con() || _igvn.type(offset2)->is_int()->get_con() != 0)) {\n+      return false;\n+    }\n+    if (p_offset != NULL) {\n+      Node* ctrl_off2 = get_ctrl(offset2);\n+      if (bt == T_LONG && _igvn.type(offset2)->isa_int()) {\n+        offset2 = new ConvI2LNode(offset2);\n+        register_new_node(offset2, ctrl_off2);\n+      }\n+      Node* ctrl_exp2 = get_ctrl(exp2);\n+      Node* offset = AddNode::make(offset2, exp2, bt);\n+      register_new_node(offset, get_early_ctrl(offset));\n+      *p_offset = offset;\n+    }\n+    return true;\n+  }\n+  return false;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":74,"deletions":32,"binary":false,"changes":106,"status":"modified"},{"patch":"@@ -1129,3 +1129,0 @@\n-  if (stride_con < 0) { \/\/ only for stride_con > 0 && scale > 0 for now\n-    return iters_limit;\n-  }\n@@ -1146,1 +1143,0 @@\n-            scale > 0 && \/\/ only for stride_con > 0 && scale > 0 for now\n@@ -1164,4 +1160,0 @@\n-\/\/ N.B. We handle only the case of positive S currently, so comments about S<0 are not operative at present.  Also,\n-\/\/ we only support positive index scale value (K > 0) to simplify the logic for clamping 32-bit bounds (L_2, R_2).\n-\/\/ For restrictions on S and K, see the guards in extract_long_range_checks.\n-\n@@ -1173,3 +1165,3 @@\n-\/\/ variable j (inner_iv), j ranges over a shorter interval j:[0,Z_2), where the limit is chosen to prevent various cases\n-\/\/ of 32-bit overflow (including multiplications j*K below).  In the sub-loop the logical value i is offset from j by a\n-\/\/ 64-bit constant C, so i ranges in i:C+[0,Z_2).\n+\/\/ variable j (inner_iv), j ranges over a shorter interval j:[0, B_2] or [0,Z_2) (assuming S > 0), where the limit is\n+\/\/ chosen to prevent various cases of 32-bit overflow (including multiplications j*K below).  In the sub-loop the\n+\/\/ logical value i is offset from j by a 64-bit constant C, so i ranges in i:C+[0,Z_2).\n@@ -1181,1 +1173,2 @@\n-\/\/ (N.B. If S<0 the formulas are different, because all the loops count downward.)\n+\/\/ If S<0, j iterates over [A_2, 0]. The union of the sub-loops must be identical to the whole range [A, B] in this case\n+\/\/ as well.\n@@ -1201,4 +1194,3 @@\n-\/\/ For each R.C. j*K+Q <u32 R, the range of mathematical values of j*K+Q in the sub-loop is [Q_min, Q_max), where\n-\/\/ Q_min=Q and Q_max=Z_2*K+Q.  Making the upper limit Q_max be exclusive helps it integrate correctly with the strict\n-\/\/ comparisons against R and R_2.  Sometimes a very high R will be replaced by an R_2 derived from the more moderate\n-\/\/ Q_max, and replacing one exclusive limit by another exclusive limit avoids off-by-one complexities.\n+\/\/ For each R.C. j*K+Q <u32 R, the range of mathematical values of j*K+Q in the sub-loop is [Q_min, Q_max], where\n+\/\/ Q_min=Q and Q_max=B_2*K+Q (if S>0 and K>0), Q_min=A_2*K+Q and Q_max=Q (if S<0 and K>0),\n+\/\/ Q_min=B_2*K+Q and Q_max=Q if (S>0 and K<0), Q_min=Q and Q_max=A_2*K+Q (if S<0 and K<0)\n@@ -1206,2 +1198,2 @@\n-\/\/ N.B. If (S*K)<0 then the formulas for Q_min and Q_max may differ; the values may need to be swapped and adjusted to\n-\/\/ the correct type of bound (inclusive or exclusive).\n+\/\/ If S*K>0 then, as the loop iterations progress, j*K+Q goes from Q_min towards Q_max.\n+\/\/ If S*K<0 then j*K+Q starts at Q_max and goes towards Q_min.\n@@ -1216,1 +1208,2 @@\n-\/\/ j*K + s32_trunc(Q_min) <u32 clamp(R, 0, Q_max)\n+\/\/ j*K + s32_trunc(Q_min) <u32 clamp'(R, 0, Q_max) if S*K>0\n+\/\/ j*K + s32_trunc(Q_max) <u32 clamp'(R, 0, Q_max) if S*K<0\n@@ -1227,1 +1220,1 @@\n-\/\/ j*K + 0 <u32 clamp(R, Q_min, Q_max) - Q_min\n+\/\/ j*K + 0 <u32 clamp'(R, Q_min, Q_max) - Q_min if S*K>0\n@@ -1229,1 +1222,3 @@\n-\/\/ j*K + 0 <u32 clamp(R - Q_min, 0, Q_max - Q_min)\n+\/\/ j*K + 0 <u32 clamp'(R - Q_min, 0, Q_max - Q_min)\n+\/\/\n+\/\/ j*K + Q_max - Q_min <u32 clamp'(R, Q_min, Q_max) - Q_min if S*K<0\n@@ -1236,1 +1231,1 @@\n-\/\/ j*K + 0 <u32 clamp(R, Q_min, R) - Q_min\n+\/\/ j*K + 0 <u32 clamp(R, Q_min, R) - Q_min if S*K>0\n@@ -1242,0 +1237,2 @@\n+\/\/ j*K + Q_max - Q_min <u32 clamp(R, Q_min, R) - Q_min if S*K<0\n+\/\/\n@@ -1244,0 +1241,1 @@\n+\/\/ clamp'(X, L, H) := max(L, min(X-1, H)+1) (in case H is inclusive but X is not)\n@@ -1248,2 +1246,2 @@\n-\/\/ H_clamp = Q_max < Q_min ? R : Q_max\n-\/\/ j*K + Q_min - L_clamp <u32 clamp(R, L_clamp, H_clamp) - L_clamp\n+\/\/ H_clamp = Q_max+1 < Q_min ? R : Q_max+1\n+\/\/ j*K + Q_min - L_clamp <u32 clamp(R, L_clamp, H_clamp) - L_clamp if S*K>0\n@@ -1253,0 +1251,2 @@\n+\/\/ j*K + Q_max - L_clamp <u32 clamp(R, L_clamp, H_clamp) - L_clamp if S*K>0\n+\/\/\n@@ -1260,0 +1260,6 @@\n+  Node* int_zero = _igvn.intcon(0);\n+  set_ctrl(int_zero, this->C->root());\n+  Node* long_one = _igvn.longcon(1);\n+  set_ctrl(long_one, this->C->root());\n+  Node* int_stride = _igvn.intcon(checked_cast<int>(stride_con));\n+  set_ctrl(int_stride, this->C->root());\n@@ -1322,2 +1328,0 @@\n-    Node* Z_2 = new ConvI2LNode(inner_iters_actual_int, TypeLong::LONG);\n-    register_new_node(Z_2, entry_control);\n@@ -1337,1 +1341,10 @@\n-    Node* Q_max = new MulLNode(Z_2, K);\n+\n+    \/\/ A_2 if S < 0\n+    Node* B_2 = new LoopLimitNode(this->C, int_zero, inner_iters_actual_int, int_stride);\n+    register_new_node(B_2, entry_control);\n+    B_2 = new SubINode(B_2, int_stride);\n+    register_new_node(B_2, entry_control);\n+    B_2 = new ConvI2LNode(B_2);\n+    register_new_node(B_2, entry_control);\n+\n+    Node* Q_max = new MulLNode(B_2, K);\n@@ -1342,0 +1355,4 @@\n+    if (scale * stride_con < 0) {\n+      swap(Q_min, Q_max);\n+    }\n+\n@@ -1350,2 +1367,5 @@\n-    \/\/ H_clamp = Q_max < Q_min ? R : Q_max\n-    Node* Q_max_cmp = new CmpLNode(Q_max, Q_min);\n+    Node* Q_max_plus_one = new AddLNode(Q_max, long_one);\n+    register_new_node(Q_max_plus_one, entry_control);\n+\n+    \/\/ H_clamp = Q_max+1 < Q_min ? R : Q_max+1\n+    Node* Q_max_cmp = new CmpLNode(Q_max_plus_one, Q_min);\n@@ -1355,1 +1375,1 @@\n-    Node* H_clamp = new CMoveLNode(Q_max_bool, Q_max, R, TypeLong::LONG);\n+    Node* H_clamp = new CMoveLNode(Q_max_bool, Q_max_plus_one, R, TypeLong::LONG);\n@@ -1367,5 +1387,12 @@\n-    \/\/ Q = Q_min - L_clamp\n-    \/\/ that is: Q = Q_min - 0 if Q_min < 0\n-    \/\/ or:      Q = Q_min - Q_min = 0 if Q_min > 0\n-    Node* Q = new SubLNode(Q_min, L_clamp);\n-    register_new_node(Q, entry_control);\n+    Node* Q = NULL;\n+    if (scale * stride_con > 0) {\n+      \/\/ Q = Q_min - L_clamp\n+      \/\/ that is: Q = Q_min - 0 if Q_min < 0\n+      \/\/ or:      Q = Q_min - Q_min = 0 if Q_min > 0\n+      Q = new SubLNode(Q_min, L_clamp);\n+      register_new_node(Q, entry_control);\n+    } else {\n+      Q = new SubLNode(Q_max, L_clamp);\n+      register_new_node(Q, entry_control);\n+    }\n+\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":62,"deletions":35,"binary":false,"changes":97,"status":"modified"},{"patch":"@@ -1258,1 +1258,1 @@\n-  bool is_scaled_iv(Node* exp, Node* iv, jlong* p_scale, BasicType bt, bool* converted);\n+  bool is_scaled_iv(Node* exp, Node* iv, jlong* p_scale, BasicType bt);\n@@ -1650,0 +1650,3 @@\n+\n+  bool is_scaled_iv_plus_extra_offset(Node* exp1, Node* exp2, Node* iv, jlong* p_scale, Node** p_offset, BasicType bt,\n+                                      bool& converted, int depth);\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -99,0 +99,146 @@\n+\n+    @Test\n+    @IR(counts = { IRNode.LOOP, \"1\"})\n+    @IR(failOn = { IRNode.COUNTEDLOOP})\n+    public static void testStrideNegScaleNeg(long start, long stop, long length, long offset) {\n+        final long scale = -1;\n+        final long stride = 1;\n+        for (long i = stop; i > start; i -= stride) {\n+            Objects.checkIndex(scale * i + offset, length);\n+        }\n+    }\n+\n+    @Run(test = \"testStrideNegScaleNeg\")\n+    private void testStrideNegScaleNeg_runner() {\n+        testStrideNegScaleNeg(0, 100, 100, 100);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.LOOP, \"1\" })\n+    @IR(failOn = { IRNode.COUNTEDLOOP })\n+    public static void testStrideNegScaleNegInIntLoop1(int start, int stop, long length, long offset) {\n+        final long scale = -2;\n+        final int stride = 1;\n+\n+        for (int i = stop; i > start; i -= stride) {\n+            Objects.checkIndex(scale * i + offset, length);\n+        }\n+    }\n+\n+    @Run(test = \"testStrideNegScaleNegInIntLoop1\")\n+    private void testStrideNegScaleNegInIntLoop1_runner() {\n+        testStrideNegScaleNegInIntLoop1(0, 100, 200, 200);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.LOOP, \"1\" })\n+    @IR(failOn = { IRNode.COUNTEDLOOP })\n+    public static void testStrideNegScaleNegInIntLoop2(int start, int stop, long length, long offset) {\n+        final int scale = -2;\n+        final int stride = 1;\n+\n+        for (int i = stop; i > start; i -= stride) {\n+            Objects.checkIndex(scale * i + offset, length);\n+        }\n+    }\n+\n+    @Run(test = \"testStrideNegScaleNegInIntLoop2\")\n+    private void testStrideNegScaleNegInIntLoop2_runner() {\n+        testStrideNegScaleNegInIntLoop2(0, 100, 200, 200);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.LOOP, \"1\"})\n+    @IR(failOn = { IRNode.COUNTEDLOOP})\n+    public static void testStrideNegScalePos(long start, long stop, long length, long offset) {\n+        final long scale = 1;\n+        final long stride = 1;\n+        for (long i = stop-1; i >= start; i -= stride) {\n+            Objects.checkIndex(scale * i + offset, length);\n+        }\n+    }\n+\n+    @Run(test = \"testStrideNegScalePos\")\n+    private void testStrideNegScalePos_runner() {\n+        testStrideNegScalePos(0, 100, 100, 0);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.LOOP, \"1\" })\n+    @IR(failOn = { IRNode.COUNTEDLOOP })\n+    public static void testStrideNegScalePosInIntLoop1(int start, int stop, long length, long offset) {\n+        final long scale = 2;\n+        final int stride = 1;\n+        for (int i = stop-1; i >= start; i -= stride) {\n+            Objects.checkIndex(scale * i + offset, length);\n+        }\n+    }\n+\n+    @Run(test = \"testStrideNegScalePosInIntLoop1\")\n+    private void testStrideNegScalePosInIntLoop1_runner() {\n+        testStrideNegScalePosInIntLoop1(0, 100, 200, 0);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.LOOP, \"1\" })\n+    @IR(failOn = { IRNode.COUNTEDLOOP })\n+    public static void testStrideNegScalePosInIntLoop2(int start, int stop, long length, long offset) {\n+        final int scale = 2;\n+        final int stride = 1;\n+        for (int i = stop-1; i >= start; i -= stride) {\n+            Objects.checkIndex(scale * i + offset, length);\n+        }\n+    }\n+\n+    @Run(test = \"testStrideNegScalePosInIntLoop2\")\n+    private void testStrideNegScalePosInIntLoop2_runner() {\n+        testStrideNegScalePosInIntLoop1(0, 100, 200, 0);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.LOOP, \"1\"})\n+    @IR(failOn = { IRNode.COUNTEDLOOP})\n+    public static void testStridePosScaleNeg(long start, long stop, long length, long offset) {\n+        final long scale = -1;\n+        final long stride = 1;\n+        for (long i = start; i < stop; i += stride) {\n+            Objects.checkIndex(scale * i + offset, length);\n+        }\n+    }\n+\n+    @Run(test = \"testStridePosScaleNeg\")\n+    private void testStridePosScaleNeg_runner() {\n+        testStridePosScaleNeg(0, 100, 100, 99);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.LOOP, \"1\"})\n+    @IR(failOn = { IRNode.COUNTEDLOOP})\n+    public static void testStridePosScaleNegInIntLoop1(int start, int stop, long length, long offset) {\n+        final long scale = -2;\n+        final int stride = 1;\n+        for (int i = start; i < stop; i += stride) {\n+            Objects.checkIndex(scale * i + offset, length);\n+        }\n+    }\n+\n+    @Run(test = \"testStridePosScaleNegInIntLoop1\")\n+    private void testStridePosScaleNegInIntLoop1_runner() {\n+        testStridePosScaleNegInIntLoop1(0, 100, 200, 198);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.LOOP, \"1\"})\n+    @IR(failOn = { IRNode.COUNTEDLOOP})\n+    public static void testStridePosScaleNegInIntLoop2(int start, int stop, long length, long offset) {\n+        final int scale = -2;\n+        final int stride = 1;\n+        for (int i = start; i < stop; i += stride) {\n+            Objects.checkIndex(scale * i + offset, length);\n+        }\n+    }\n+\n+    @Run(test = \"testStridePosScaleNegInIntLoop2\")\n+    private void testStridePosScaleNegInIntLoop2_runner() {\n+        testStridePosScaleNegInIntLoop1(0, 100, 200, 198);\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestLongRangeChecks.java","additions":146,"deletions":0,"binary":false,"changes":146,"status":"modified"},{"patch":"@@ -130,0 +130,67 @@\n+    private static void testOverflow(String method, long start, long stop, long length, long offset0, long offset1) throws Exception {\n+        Method m = newClassLoader().loadClass(\"TestLongRangeCheck\").getDeclaredMethod(method, long.class, long.class, long.class, long.class);\n+        m.invoke(null, start, stop, length, offset0);\n+        compile(m);\n+\n+        m.invoke(null, start, stop, length, offset0);\n+        assertIsCompiled(m);\n+        try {\n+            m.invoke(null, start, stop, length, offset1);\n+            throw new RuntimeException(\"should have thrown\");\n+        } catch(InvocationTargetException e) {\n+            if (!(e.getCause() instanceof IndexOutOfBoundsException)) {\n+                throw new RuntimeException(\"unexpected exception\");\n+            }\n+        }\n+        assertIsNotCompiled(m);\n+    }\n+\n+    private static void testConditional(String method, long start, long stop, long length, long offset0, long offset1, long start1, long stop1) throws Exception {\n+        Method m;\n+\n+        if (start1 != start) {\n+            m = newClassLoader().loadClass(\"TestLongRangeCheck\").getDeclaredMethod(method, long.class, long.class, long.class, long.class, long.class, long.class);\n+            m.invoke(null, start, stop, length, offset0, start, stop);\n+            compile(m);\n+\n+            m.invoke(null, start, stop, length, offset0, start, stop);\n+            assertIsCompiled(m);\n+            try {\n+                m.invoke(null, start, stop, length, offset1, start1-1, stop1);\n+                throw new RuntimeException(\"should have thrown\");\n+            } catch(InvocationTargetException e) {\n+                if (!(e.getCause() instanceof IndexOutOfBoundsException)) {\n+                    throw new RuntimeException(\"unexpected exception\");\n+                }\n+            }\n+            assertIsNotCompiled(m);\n+        }\n+\n+        if (stop1 != stop) {\n+            m = newClassLoader().loadClass(\"TestLongRangeCheck\").getDeclaredMethod(method, long.class, long.class, long.class, long.class, long.class, long.class);\n+            m.invoke(null, start, stop, length, offset0, start, stop);\n+            compile(m);\n+\n+            m.invoke(null, start, stop, length, offset0, start, stop);\n+            assertIsCompiled(m);\n+            try {\n+                m.invoke(null, start, stop, length, offset1, start1, stop1+1);\n+                throw new RuntimeException(\"should have thrown\");\n+            } catch(InvocationTargetException e) {\n+                if (!(e.getCause() instanceof IndexOutOfBoundsException)) {\n+                    throw new RuntimeException(\"unexpected exception\");\n+                }\n+            }\n+            assertIsNotCompiled(m);\n+        }\n+\n+        m = newClassLoader().loadClass(\"TestLongRangeCheck\").getDeclaredMethod(method, long.class, long.class, long.class, long.class, long.class, long.class);\n+        m.invoke(null, start, stop, length, offset0, start, stop);\n+        compile(m);\n+\n+        m.invoke(null, start, stop, length, offset0, start, stop);\n+        assertIsCompiled(m);\n+\n+        m.invoke(null, start, stop, length, offset1, start1, stop1);\n+        assertIsCompiled(m);\n+    }\n@@ -160,18 +227,4 @@\n-\n-        {\n-            Method m = newClassLoader().loadClass(\"TestLongRangeCheck\").getDeclaredMethod(\"testStridePosScalePos\", long.class, long.class, long.class, long.class);\n-            m.invoke(null, 0, 100, 100, 0);\n-            compile(m);\n-\n-            m.invoke(null, 0, 100, 100, 0);\n-            assertIsCompiled(m);\n-            try {\n-                m.invoke(null, 0, 100, 100, Long.MAX_VALUE - 50);\n-                throw new RuntimeException(\"should have thrown\");\n-            } catch(InvocationTargetException e) {\n-                if (!(e.getCause() instanceof IndexOutOfBoundsException)) {\n-                    throw new RuntimeException(\"unexpected exception\");\n-                }\n-            }\n-            assertIsNotCompiled(m);\n-        }\n+        testOverflow(\"testStridePosScalePos\", 0, 100, 100, 0, Long.MAX_VALUE - 50);\n+        testOverflow(\"testStrideNegScaleNeg\", 0, 100, 100, 100, Long.MIN_VALUE + 50);\n+        testOverflow(\"testStrideNegScalePos\", 0, 100, 100, 0, Long.MAX_VALUE - 50);\n+        testOverflow(\"testStridePosScaleNeg\", 0, 100, 100, 99, Long.MIN_VALUE + 50);\n@@ -180,16 +233,8 @@\n-        {\n-            Method m = newClassLoader().loadClass(\"TestLongRangeCheck\").getDeclaredMethod(\"testStridePosScalePosConditional\", long.class, long.class, long.class, long.class, long.class, long.class);\n-            m.invoke(null, 0, 100, 100, 0, 0, 100);\n-            compile(m);\n-\n-            m.invoke(null, 0, 100, 100, -50, 50, 100);\n-            assertIsCompiled(m);\n-        }\n-        {\n-            Method m = newClassLoader().loadClass(\"TestLongRangeCheck\").getDeclaredMethod(\"testStridePosScalePosConditional\", long.class, long.class, long.class, long.class, long.class, long.class);\n-            m.invoke(null, 0, 100, 100, 0, 0, 100);\n-            compile(m);\n-\n-            m.invoke(null, 0, 100, Long.MAX_VALUE, Long.MAX_VALUE - 50, 0, 50);\n-            assertIsCompiled(m);\n-        }\n+        testConditional(\"testStridePosScalePosConditional\", 0, 100, 100, 0, -50, 50, 100);\n+        testConditional(\"testStridePosScalePosConditional\", 0, 100, Long.MAX_VALUE, 0, Long.MAX_VALUE - 50, 0, 50);\n+        testConditional(\"testStrideNegScaleNegConditional\", 0, 100, 100, 100, 50, 0, 51);\n+        testConditional(\"testStrideNegScaleNegConditional\", 0, 100, Long.MAX_VALUE, 100, Long.MIN_VALUE + 50, 52, 100);\n+        testConditional(\"testStrideNegScalePosConditional\", 0, 100, 100, 0, -50, 50, 100);\n+        testConditional(\"testStrideNegScalePosConditional\", 0, 100, Long.MAX_VALUE, 100, Long.MAX_VALUE - 50, 0, 50);\n+        testConditional(\"testStridePosScaleNegConditional\", 0, 100, 100, 99, 50, 0, 51);\n+        testConditional(\"testStridePosScaleNegConditional\", 0, 100, Long.MAX_VALUE, 99, Long.MIN_VALUE + 50, 52, 100);\n@@ -224,17 +269,4 @@\n-        {\n-            Method m = newClassLoader().loadClass(\"TestLongRangeCheck\").getDeclaredMethod(\"testStridePosScalePosInIntLoop\", long.class, long.class, long.class, long.class);\n-            m.invoke(null, 0, 100, 100, 0);\n-            compile(m);\n-\n-            m.invoke(null, 0, 100, 100, 0);\n-            assertIsCompiled(m);\n-            try {\n-                m.invoke(null, 0, 100, 100, Long.MAX_VALUE - 50);\n-                throw new RuntimeException(\"should have thrown\");\n-            } catch(InvocationTargetException e) {\n-                if (!(e.getCause() instanceof IndexOutOfBoundsException)) {\n-                    throw new RuntimeException(\"unexpected exception\");\n-                }\n-            }\n-            assertIsNotCompiled(m);\n-        }\n+        testOverflow(\"testStridePosScalePosInIntLoop\", 0, 100, 100, 0, Long.MAX_VALUE - 50);\n+        testOverflow(\"testStrideNegScaleNegInIntLoop\", 0, 100, 100, 100, Long.MIN_VALUE + 50);\n+        testOverflow(\"testStrideNegScalePosInIntLoop\", 0, 100, 100, 0, Long.MAX_VALUE - 50);\n+        testOverflow(\"testStridePosScaleNegInIntLoop\", 0, 100, 100, 99, Long.MIN_VALUE + 50);\n@@ -242,16 +274,8 @@\n-        {\n-            Method m = newClassLoader().loadClass(\"TestLongRangeCheck\").getDeclaredMethod(\"testStridePosScalePosConditional\", long.class, long.class, long.class, long.class, long.class, long.class);\n-            m.invoke(null, 0, 100, 100, 0, 0, 100);\n-            compile(m);\n-\n-            m.invoke(null, 0, 100, 100, -50, 50, 100);\n-            assertIsCompiled(m);\n-        }\n-        {\n-            Method m = newClassLoader().loadClass(\"TestLongRangeCheck\").getDeclaredMethod(\"testStridePosScalePosConditional\", long.class, long.class, long.class, long.class, long.class, long.class);\n-            m.invoke(null, 0, 100, 100, 0, 0, 100);\n-            compile(m);\n-\n-            m.invoke(null, 0, 100, Long.MAX_VALUE, Long.MAX_VALUE - 50, 0, 50);\n-            assertIsCompiled(m);\n-        }\n+        testConditional(\"testStridePosScalePosConditionalInIntLoop\", 0, 100, 100, 0, -50, 50, 100);\n+        testConditional(\"testStridePosScalePosConditionalInIntLoop\", 0, 100, Long.MAX_VALUE, 0, Long.MAX_VALUE - 50, 0, 50);\n+        testConditional(\"testStrideNegScaleNegConditionalInIntLoop\", 0, 100, 100, 100, 50, 0, 51);\n+        testConditional(\"testStrideNegScaleNegConditionalInIntLoop\", 0, 100, Long.MAX_VALUE, 100, Long.MIN_VALUE + 50, 52, 100);\n+        testConditional(\"testStrideNegScalePosConditionalInIntLoop\", 0, 100, 100, 0, -50, 50, 100);\n+        testConditional(\"testStrideNegScalePosConditionalInIntLoop\", 0, 100, Long.MAX_VALUE, 100, Long.MAX_VALUE - 50, 0, 50);\n+        testConditional(\"testStridePosScaleNegConditionalInIntLoop\", 0, 100, 100, 99, 50, 0, 51);\n+        testConditional(\"testStridePosScaleNegConditionalInIntLoop\", 0, 100, Long.MAX_VALUE, 99, Long.MIN_VALUE + 50, 52, 100);\n@@ -414,0 +438,30 @@\n+    public static void testStrideNegScaleNegConditional(long start, long stop, long length, long offset, long start2, long stop2) {\n+        final long scale = -1;\n+        final long stride = 1;\n+        for (long i = stop; i > start; i -= stride) {\n+            if (i >= start2 && i < stop2) {\n+                Preconditions.checkIndex(scale * i + offset, length, null);\n+            }\n+        }\n+    }\n+\n+    public static void testStrideNegScalePosConditional(long start, long stop, long length, long offset, long start2, long stop2) {\n+        final long scale = 1;\n+        final long stride = 1;\n+        for (long i = stop-1; i >= start; i -= stride) {\n+            if (i >= start2 && i < stop2) {\n+                Preconditions.checkIndex(scale * i + offset, length, null);\n+            }\n+        }\n+    }\n+\n+    public static void testStridePosScaleNegConditional(long start, long stop, long length, long offset, long start2, long stop2) {\n+        final long scale = -1;\n+        final long stride = 1;\n+        for (long i = start; i < stop; i += stride) {\n+            if (i >= start2 && i < stop2) {\n+                Preconditions.checkIndex(scale * i + offset, length, null);\n+            }\n+        }\n+    }\n+\n@@ -532,1 +586,0 @@\n-        Preconditions.checkIndex(0, length, null);\n@@ -535,0 +588,33 @@\n+        for (int i = (int)start; i < (int)stop; i += stride) {\n+            if (i >= (int)start2 && i < (int)stop2) {\n+                Preconditions.checkIndex(scale * i + offset, length, null);\n+            }\n+        }\n+    }\n+\n+    public static void testStrideNegScaleNegConditionalInIntLoop(long start, long stop, long length, long offset, long start2, long stop2) {\n+        checkInputs(start, stop, start2, stop2);\n+        final long scale = -1;\n+        final int stride = 1;\n+        for (int i = (int)stop; i > (int)start; i -= stride) {\n+            if (i >= (int)start2 && i < (int)stop2) {\n+                Preconditions.checkIndex(scale * i + offset, length, null);\n+            }\n+        }\n+    }\n+\n+    public static void testStrideNegScalePosConditionalInIntLoop(long start, long stop, long length, long offset, long start2, long stop2) {\n+        checkInputs(start, stop, start2, stop2);\n+        final long scale = 1;\n+        final int stride = 1;\n+        for (int i = (int)(stop-1); i >= (int)start; i -= stride) {\n+            if (i >= (int)start2 && i < (int)stop2) {\n+                Preconditions.checkIndex(scale * i + offset, length, null);\n+            }\n+        }\n+    }\n+\n+    public static void testStridePosScaleNegConditionalInIntLoop(long start, long stop, long length, long offset, long start2, long stop2) {\n+        checkInputs(start, stop, start2, stop2);\n+        final long scale = -1;\n+        final int stride = 1;\n","filename":"test\/hotspot\/jtreg\/compiler\/rangechecks\/TestLongRangeCheck.java","additions":154,"deletions":68,"binary":false,"changes":222,"status":"modified"}]}