{"files":[{"patch":"@@ -762,1 +762,1 @@\n-  if (!phase->is_scaled_iv_plus_offset(cmp->in(1), iv, &scale, &offset, bt)) {\n+  if (!phase->is_scaled_iv_plus_offset(cmp->in(1), iv, bt, &scale, &offset)) {\n","filename":"src\/hotspot\/share\/opto\/loopPredicate.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1124,2 +1124,0 @@\n-      Node *rc_exp = cmp->in(1);\n-      Node *limit = cmp->in(2);\n@@ -1131,2 +1129,2 @@\n-        if (!phase->is_scaled_iv_plus_offset(cmp->in(1), trip_counter, NULL, NULL, bt) &&\n-            !phase->is_scaled_iv_plus_offset(cmp->in(2), trip_counter, NULL, NULL, bt)) {\n+        if (!phase->is_scaled_iv_plus_offset(cmp->in(1), trip_counter, bt, NULL, NULL) &&\n+            !phase->is_scaled_iv_plus_offset(cmp->in(2), trip_counter, bt, NULL, NULL)) {\n@@ -1136,0 +1134,2 @@\n+        Node *rc_exp = cmp->in(1);\n+        Node *limit = cmp->in(2);\n@@ -1150,1 +1150,1 @@\n-        if (!phase->is_scaled_iv_plus_offset(rc_exp, trip_counter, NULL, NULL, bt)) {\n+        if (!phase->is_scaled_iv_plus_offset(rc_exp, trip_counter, bt, NULL, NULL)) {\n@@ -2525,0 +2525,4 @@\n+\/\/----------------------------------is_iv------------------------------------\n+\/\/ Return true if exp is the value (of type bt) of the given induction var.\n+\/\/ This grammar of cases is recognized, where X is I|L according to bt:\n+\/\/    VIV[iv] = iv | (CastXX VIV[iv]) | (ConvI2X VIV[iv])\n@@ -2526,1 +2530,2 @@\n-  if (exp == iv) {\n+  exp = exp->uncast();\n+  if (exp == iv && iv->bottom_type()->isa_integer(bt)) {\n@@ -2530,1 +2535,1 @@\n-  if (bt == T_LONG && iv->bottom_type()->isa_int() && exp->Opcode() == Op_ConvI2L && exp->in(1) == iv) {\n+  if (bt == T_LONG && iv->bottom_type()->isa_int() && exp->Opcode() == Op_ConvI2L && exp->in(1)->uncast() == iv) {\n@@ -2537,5 +2542,16 @@\n-\/\/ Return true if exp is a constant times an induction var\n-bool PhaseIdealLoop::is_scaled_iv(Node* exp, Node* iv, jlong* p_scale, BasicType bt, bool* converted) {\n-  exp = exp->uncast();\n-  assert(bt == T_INT || bt == T_LONG, \"unexpected int type\");\n-  if (is_iv(exp, iv, bt)) {\n+\/\/ Return true if exp is a constant times the given induction var (of type bt).\n+\/\/ The multiplication is either done in full precision (exactly of type bt),\n+\/\/ or else bt is T_LONG but iv is scaled using 32-bit arithmetic followed by a ConvI2L.\n+\/\/ This grammar of cases is recognized, where X is I|L according to bt:\n+\/\/    SIV[iv] = VIV[iv] | (CastXX SIV[iv])\n+\/\/            | (MulX VIV[iv] ConX) | (MulX ConX VIV[iv])\n+\/\/            | (LShiftX VIV[iv] ConI)\n+\/\/            | (ConvI2L SIV[iv])  -- a \"short-scale\" can occur here; note recursion\n+\/\/            | (SubX 0 SIV[iv])  -- same as MulX(iv, -scale); note recursion\n+\/\/ On success, the constant scale value is stored back to *p_scale.\n+\/\/ The value (*p_short_scale) reports if such a ConvI2L conversion was present.\n+bool PhaseIdealLoop::is_scaled_iv(Node* exp, Node* iv, BasicType bt, jlong* p_scale, bool* p_short_scale, int depth) {\n+  BasicType exp_bt = bt;\n+  exp = exp->uncast();  \/\/strip casts\n+  assert(exp_bt == T_INT || exp_bt == T_LONG, \"unexpected int type\");\n+  if (is_iv(exp, iv, exp_bt)) {\n@@ -2545,0 +2561,3 @@\n+    if (p_short_scale != NULL) {\n+      *p_short_scale = false;\n+    }\n@@ -2547,1 +2566,1 @@\n-  if (bt == T_LONG && iv->bottom_type()->isa_int() && exp->Opcode() == Op_ConvI2L) {\n+  if (exp_bt == T_LONG && iv->bottom_type()->isa_int() && exp->Opcode() == Op_ConvI2L) {\n@@ -2549,4 +2568,1 @@\n-    bt = T_INT;\n-    if (converted != NULL) {\n-      *converted = true;\n-    }\n+    exp_bt = T_INT;\n@@ -2555,0 +2571,1 @@\n+  int which = 0;  \/\/ this is which subexpression we find the iv in\n@@ -2556,2 +2573,8 @@\n-  if (opc == Op_Mul(bt)) {\n-    if (is_iv(exp->in(1)->uncast(), iv, bt) && exp->in(2)->is_Con()) {\n+  if (opc == Op_Mul(exp_bt)) {\n+    if (is_iv(exp->in(which = 1), iv, exp_bt) && exp->in(2)->is_Con() ||\n+        is_iv(exp->in(which = 2), iv, exp_bt) && exp->in(1)->is_Con()) {\n+      Node* factor = exp->in(which == 1 ? 2 : 1);  \/\/ the other argument\n+      jlong scale = factor->find_integer_as_long(exp_bt, 0);\n+      if (scale == 0) {\n+        return false;  \/\/ might be top\n+      }\n@@ -2559,1 +2582,5 @@\n-        *p_scale = exp->in(2)->get_integer_as_long(bt);\n+        *p_scale = scale;\n+      }\n+      if (p_short_scale != NULL) {\n+        \/\/ (ConvI2L (MulI iv K)) can be 64-bit linear if iv is kept small enough...\n+        *p_short_scale = (exp_bt != bt && scale != 1);\n@@ -2563,1 +2590,12 @@\n-    if (is_iv(exp->in(2)->uncast(), iv, bt) && exp->in(1)->is_Con()) {\n+  } else if (opc == Op_LShift(exp_bt)) {\n+    if (is_iv(exp->in(1), iv, exp_bt) && exp->in(2)->is_Con()) {\n+      jint shift_amount = exp->in(2)->find_int_con(min_jint);\n+      if (shift_amount == min_jint) {\n+        return false;  \/\/ might be top\n+      }\n+      jlong scale;\n+      if (exp_bt == T_INT) {\n+        scale = java_shift_left((jint)1, (juint)shift_amount);\n+      } else if (exp_bt == T_LONG) {\n+        scale = java_shift_left((jlong)1, (julong)shift_amount);\n+      }\n@@ -2565,1 +2603,5 @@\n-        *p_scale = exp->in(1)->get_integer_as_long(bt);\n+        *p_scale = scale;\n+      }\n+      if (p_short_scale != NULL) {\n+        \/\/ (ConvI2L (MulI iv K)) can be 64-bit linear if iv is kept small enough...\n+        *p_short_scale = (exp_bt != bt && scale != 1);\n@@ -2569,2 +2611,10 @@\n-  } else if (opc == Op_LShift(bt)) {\n-    if (is_iv(exp->in(1)->uncast(), iv, bt) && exp->in(2)->is_Con()) {\n+  } else if (opc == Op_Sub(exp_bt) &&\n+             exp->in(1)->find_integer_as_long(exp_bt, -1) == 0) {\n+    jlong scale = 0;\n+    if (depth == 0 && is_scaled_iv(exp->in(2), iv, exp_bt, &scale, p_short_scale, depth + 1)) {\n+      \/\/ SubX(0, iv*K) => iv*(-K)\n+      if (scale == min_signed_integer(exp_bt)) {\n+        \/\/ This should work even if -K overflows, but let's not.\n+        return false;\n+      }\n+      scale = java_multiply(scale, (jlong)-1);\n@@ -2572,6 +2622,5 @@\n-        jint shift_amount = exp->in(2)->get_int();\n-        if (bt == T_INT) {\n-          *p_scale = java_shift_left((jint)1, (juint)shift_amount);\n-        } else if (bt == T_LONG) {\n-          *p_scale = java_shift_left((jlong)1, (julong)shift_amount);\n-        }\n+        *p_scale = scale;\n+      }\n+      if (p_short_scale != NULL) {\n+        \/\/ (ConvI2L (MulI iv K)) can be 64-bit linear if iv is kept small enough...\n+        *p_short_scale = *p_short_scale || (exp_bt != bt && scale != 1);\n@@ -2582,0 +2631,1 @@\n+  \/\/ We could also recognize (iv*K1)*K2, even with overflow, but let's not.\n@@ -2585,3 +2635,17 @@\n-\/\/-----------------------------is_scaled_iv_plus_offset------------------------------\n-\/\/ Return true if exp is a simple induction variable expression: k1*iv + (invar + k2)\n-bool PhaseIdealLoop::is_scaled_iv_plus_offset(Node* exp, Node* iv, jlong* p_scale, Node** p_offset, BasicType bt, bool* converted, int depth) {\n+\/\/-------------------------is_scaled_iv_plus_offset--------------------------\n+\/\/ Return true if exp is a simple linear transform of the given induction var.\n+\/\/ The scale must be constant and the addition tree (if any) must be simple.\n+\/\/ This grammar of cases is recognized, where X is I|L according to bt:\n+\/\/\n+\/\/    OIV[iv] = SIV[iv] | (CastXX OIV[iv])\n+\/\/            | (AddX SIV[iv] E) | (AddX E SIV[iv])\n+\/\/            | (SubX SIV[iv] E) | (SubX E SIV[iv])\n+\/\/    SSIV[iv] = (ConvI2X SIV[iv])  -- a \"short scale\" might occur here\n+\/\/    SIV[iv] = [see is_scaled_iv() above]\n+\/\/\n+\/\/ On success, the constant scale value is stored back to *p_scale unless null.\n+\/\/ Likewise, the addend (perhaps a synthetic AddX node) is stored to *p_offset.\n+\/\/ Also, (*p_short_scale) reports if a ConvI2L conversion was seen after a MulI,\n+\/\/ meaning bt is T_LONG but iv was scaled using 32-bit arithmetic.\n+\/\/ To avoid looping, the match is depth-limited, and so may fail to match the grammar to complex expressions.\n+bool PhaseIdealLoop::is_scaled_iv_plus_offset(Node* exp, Node* iv, BasicType bt, jlong* p_scale, Node** p_offset, bool* p_short_scale, int depth) {\n@@ -2589,1 +2653,7 @@\n-  if (is_scaled_iv(exp, iv, p_scale, bt, converted)) {\n+  jlong scale = 0;  \/\/ to catch result from is_scaled_iv()\n+  BasicType exp_bt = bt;\n+  exp = exp->uncast();\n+  if (is_scaled_iv(exp, iv, exp_bt, &scale, p_short_scale)) {\n+    if (p_scale != NULL) {\n+      *p_scale = scale;\n+    }\n@@ -2591,1 +2661,1 @@\n-      Node *zero = _igvn.integercon(0, bt);\n+      Node *zero = _igvn.zerocon(bt);\n@@ -2597,1 +2667,7 @@\n-  exp = exp->uncast();\n+  if (exp_bt != bt) {\n+    \/\/ We would now be matching inputs like (ConvI2L exp:(AddI (MulI iv S) E)).\n+    \/\/ It's hard to make 32-bit arithmetic linear if it overflows.  Although we do\n+    \/\/ cope with overflowing multiplication by S, it would be even more work to\n+    \/\/ handle overflowing addition of E.  So we bail out here on ConvI2L input.\n+    return false;\n+  }\n@@ -2599,2 +2675,10 @@\n-  if (opc == Op_Add(bt)) {\n-    if (is_scaled_iv(exp->in(1), iv, p_scale, bt, converted)) {\n+  int which = 0;  \/\/ this is which subexpression we find the iv in\n+  Node* offset = NULL;\n+  if (opc == Op_Add(exp_bt)) {\n+    \/\/ Check for a scaled IV in (AddX (MulX iv S) E) or (AddX E (MulX iv S)).\n+    if (is_scaled_iv(exp->in(which = 1), iv, bt, &scale, p_short_scale) ||\n+        is_scaled_iv(exp->in(which = 2), iv, bt, &scale, p_short_scale)) {\n+      offset = exp->in(which == 1 ? 2 : 1);  \/\/ the other argument\n+      if (p_scale != NULL) {\n+        *p_scale = scale;\n+      }\n@@ -2602,1 +2686,1 @@\n-        *p_offset = exp->in(2);\n+        *p_offset = offset;\n@@ -2606,4 +2690,3 @@\n-    if (is_scaled_iv(exp->in(2), iv, p_scale, bt, converted)) {\n-      if (p_offset != NULL) {\n-        *p_offset = exp->in(1);\n-      }\n+    \/\/ Check for more addends, like (AddX (AddX (MulX iv S) E1) E2), etc.\n+    if (is_scaled_iv_plus_extra_offset(exp->in(1), exp->in(2), iv, bt, p_scale, p_offset, p_short_scale, depth) ||\n+        is_scaled_iv_plus_extra_offset(exp->in(2), exp->in(1), iv, bt, p_scale, p_offset, p_short_scale, depth)) {\n@@ -2612,10 +2695,10 @@\n-    if (exp->in(2)->is_Con()) {\n-      Node* offset2 = NULL;\n-      if (depth < 2 &&\n-          is_scaled_iv_plus_offset(exp->in(1), iv, p_scale,\n-                                   p_offset != NULL ? &offset2 : NULL, bt, converted, depth+1)) {\n-        if (p_offset != NULL) {\n-          Node *ctrl_off2 = get_ctrl(offset2);\n-          Node* offset = AddNode::make(offset2, exp->in(2), bt);\n-          register_new_node(offset, ctrl_off2);\n-          *p_offset = offset;\n+  } else if (opc == Op_Sub(exp_bt)) {\n+    if (is_scaled_iv(exp->in(which = 1), iv, bt, &scale, p_short_scale) ||\n+        is_scaled_iv(exp->in(which = 2), iv, bt, &scale, p_short_scale)) {\n+      \/\/ Match (SubX SIV[iv] E) as if (AddX SIV[iv] (SubX 0 E)), and\n+      \/\/ match (SubX E SIV[iv]) as if (AddX E (SubX 0 SIV[iv])).\n+      offset = exp->in(which == 1 ? 2 : 1);  \/\/ the other argument\n+      if (which == 2) {\n+        \/\/ We can't handle a scale of min_jint (or min_jlong) here as -1 * min_jint = min_jint\n+        if (scale == min_signed_integer(bt)) {\n+          return false;   \/\/ cannot negate the scale of the iv\n@@ -2623,1 +2706,1 @@\n-        return true;\n+        scale = java_multiply(scale, (jlong)-1);\n@@ -2625,10 +2708,2 @@\n-    }\n-  } else if (opc == Op_Sub(bt)) {\n-    if (is_scaled_iv(exp->in(1), iv, p_scale, bt, converted)) {\n-      if (p_offset != NULL) {\n-        Node *zero = _igvn.integercon(0, bt);\n-        set_ctrl(zero, C->root());\n-        Node *ctrl_off = get_ctrl(exp->in(2));\n-        Node* offset = SubNode::make(zero, exp->in(2), bt);\n-        register_new_node(offset, ctrl_off);\n-        *p_offset = offset;\n+      if (p_scale != NULL) {\n+        *p_scale = scale;\n@@ -2636,3 +2711,0 @@\n-      return true;\n-    }\n-    if (is_scaled_iv(exp->in(2), iv, p_scale, bt, converted)) {\n@@ -2640,3 +2712,6 @@\n-        \/\/ We can't handle a scale of min_jint (or min_jlong) here as -1 * min_jint = min_jint\n-        if (*p_scale == min_signed_integer(bt)) {\n-          return false;\n+        if (which == 1) {  \/\/ must negate the extracted offset\n+          Node *zero = _igvn.integercon(0, exp_bt);\n+          set_ctrl(zero, C->root());\n+          Node *ctrl_off = get_ctrl(offset);\n+          offset = SubNode::make(zero, offset, exp_bt);\n+          register_new_node(offset, ctrl_off);\n@@ -2644,2 +2719,1 @@\n-        *p_scale *= -1;\n-        *p_offset = exp->in(1);\n+        *p_offset = offset;\n@@ -2653,0 +2727,27 @@\n+\/\/ Helper for is_scaled_iv_plus_offset(), not called separately.\n+\/\/ The caller encountered (AddX exp1 offset3) or (AddX offset3 exp1).\n+\/\/ Here, exp1 is inspected to see if it is a simple linear transform of iv.\n+\/\/ If so, the offset3 is combined with any other offset2 from inside exp1.\n+bool PhaseIdealLoop::is_scaled_iv_plus_extra_offset(Node* exp1, Node* offset3, Node* iv,\n+                                                    BasicType bt,\n+                                                    jlong* p_scale, Node** p_offset,\n+                                                    bool* p_short_scale, int depth) {\n+  \/\/ By the time we reach here, it is unlikely that exp1 is a simple iv*K.\n+  \/\/ If is a linear iv transform, it is probably an add or subtract.\n+  \/\/ Let's collect the internal offset2 from it.\n+  Node* offset2 = NULL;\n+  if (offset3->is_Con() &&\n+      depth < 2 &&\n+      is_scaled_iv_plus_offset(exp1, iv, bt, p_scale,\n+                               &offset2, p_short_scale, depth+1)) {\n+    if (p_offset != NULL) {\n+      Node* ctrl_off2 = get_ctrl(offset2);\n+      Node* offset = AddNode::make(offset2, offset3, bt);\n+      register_new_node(offset, ctrl_off2);\n+      *p_offset = offset;\n+    }\n+    return true;\n+  }\n+  return false;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":173,"deletions":72,"binary":false,"changes":245,"status":"modified"},{"patch":"@@ -1129,3 +1129,0 @@\n-  if (stride_con < 0) { \/\/ only for stride_con > 0 && scale > 0 for now\n-    return iters_limit;\n-  }\n@@ -1146,1 +1143,0 @@\n-            scale > 0 && \/\/ only for stride_con > 0 && scale > 0 for now\n@@ -1164,4 +1160,0 @@\n-\/\/ N.B. We handle only the case of positive S currently, so comments about S<0 are not operative at present.  Also,\n-\/\/ we only support positive index scale value (K > 0) to simplify the logic for clamping 32-bit bounds (L_2, R_2).\n-\/\/ For restrictions on S and K, see the guards in extract_long_range_checks.\n-\n@@ -1173,3 +1165,3 @@\n-\/\/ variable j (inner_iv), j ranges over a shorter interval j:[0,Z_2), where the limit is chosen to prevent various cases\n-\/\/ of 32-bit overflow (including multiplications j*K below).  In the sub-loop the logical value i is offset from j by a\n-\/\/ 64-bit constant C, so i ranges in i:C+[0,Z_2).\n+\/\/ variable j (inner_iv), j ranges over a shorter interval j:[0, B_2] or [0,Z_2) (assuming S > 0), where the limit is\n+\/\/ chosen to prevent various cases of 32-bit overflow (including multiplications j*K below).  In the sub-loop the\n+\/\/ logical value i is offset from j by a 64-bit constant C, so i ranges in i:C+[0,Z_2).\n@@ -1181,1 +1173,2 @@\n-\/\/ (N.B. If S<0 the formulas are different, because all the loops count downward.)\n+\/\/ If S<0, j iterates over [A_2, 0]. The union of the sub-loops must be identical to the whole range [A, B] in this case\n+\/\/ as well.\n@@ -1201,4 +1194,3 @@\n-\/\/ For each R.C. j*K+Q <u32 R, the range of mathematical values of j*K+Q in the sub-loop is [Q_min, Q_max), where\n-\/\/ Q_min=Q and Q_max=Z_2*K+Q.  Making the upper limit Q_max be exclusive helps it integrate correctly with the strict\n-\/\/ comparisons against R and R_2.  Sometimes a very high R will be replaced by an R_2 derived from the more moderate\n-\/\/ Q_max, and replacing one exclusive limit by another exclusive limit avoids off-by-one complexities.\n+\/\/ For each R.C. j*K+Q <u32 R, the range of mathematical values of j*K+Q in the sub-loop is [Q_min, Q_max], where\n+\/\/ Q_min=Q and Q_max=B_2*K+Q (if S>0 and K>0), Q_min=A_2*K+Q and Q_max=Q (if S<0 and K>0),\n+\/\/ Q_min=B_2*K+Q and Q_max=Q if (S>0 and K<0), Q_min=Q and Q_max=A_2*K+Q (if S<0 and K<0)\n@@ -1206,2 +1198,2 @@\n-\/\/ N.B. If (S*K)<0 then the formulas for Q_min and Q_max may differ; the values may need to be swapped and adjusted to\n-\/\/ the correct type of bound (inclusive or exclusive).\n+\/\/ If S*K>0 then, as the loop iterations progress, j*K+Q goes from Q_min towards Q_max.\n+\/\/ If S*K<0 then j*K+Q starts at Q_max and goes towards Q_min.\n@@ -1216,1 +1208,2 @@\n-\/\/ j*K + s32_trunc(Q_min) <u32 clamp(R, 0, Q_max)\n+\/\/ j*K + s32_trunc(Q_min) <u32 clamp'(R, 0, Q_max) if S*K>0\n+\/\/ j*K + s32_trunc(Q_max) <u32 clamp'(R, 0, Q_max) if S*K<0\n@@ -1227,1 +1220,1 @@\n-\/\/ j*K + 0 <u32 clamp(R, Q_min, Q_max) - Q_min\n+\/\/ j*K + 0 <u32 clamp'(R, Q_min, Q_max) - Q_min if S*K>0\n@@ -1229,1 +1222,3 @@\n-\/\/ j*K + 0 <u32 clamp(R - Q_min, 0, Q_max - Q_min)\n+\/\/ j*K + 0 <u32 clamp'(R - Q_min, 0, Q_max - Q_min)\n+\/\/\n+\/\/ j*K + Q_max - Q_min <u32 clamp'(R, Q_min, Q_max) - Q_min if S*K<0\n@@ -1236,1 +1231,1 @@\n-\/\/ j*K + 0 <u32 clamp(R, Q_min, R) - Q_min\n+\/\/ j*K + 0 <u32 clamp(R, Q_min, R) - Q_min if S*K>0\n@@ -1242,0 +1237,2 @@\n+\/\/ j*K + Q_max - Q_min <u32 clamp(R, Q_min, R) - Q_min if S*K<0\n+\/\/\n@@ -1244,0 +1241,1 @@\n+\/\/ clamp'(X, L, H) := max(L, min(X-1, H)+1) (in case H is inclusive but X is not)\n@@ -1248,2 +1246,2 @@\n-\/\/ H_clamp = Q_max < Q_min ? R : Q_max\n-\/\/ j*K + Q_min - L_clamp <u32 clamp(R, L_clamp, H_clamp) - L_clamp\n+\/\/ H_clamp = Q_max+1 < Q_min ? R : Q_max+1\n+\/\/ j*K + Q_min - L_clamp <u32 clamp(R, L_clamp, H_clamp) - L_clamp if S*K>0\n@@ -1253,0 +1251,2 @@\n+\/\/ j*K + Q_max - L_clamp <u32 clamp(R, L_clamp, H_clamp) - L_clamp if S*K>0\n+\/\/\n@@ -1260,0 +1260,6 @@\n+  Node* int_zero = _igvn.intcon(0);\n+  set_ctrl(int_zero, this->C->root());\n+  Node* long_one = _igvn.longcon(1);\n+  set_ctrl(long_one, this->C->root());\n+  Node* int_stride = _igvn.intcon(checked_cast<int>(stride_con));\n+  set_ctrl(int_stride, this->C->root());\n@@ -1273,2 +1279,2 @@\n-    bool converted = false;\n-    bool ok = is_scaled_iv_plus_offset(rc_cmp->in(1), iv_add, &scale, &offset, T_LONG, &converted);\n+    bool short_scale = false;\n+    bool ok = is_scaled_iv_plus_offset(rc_cmp->in(1), iv_add, T_LONG, &scale, &offset, &short_scale);\n@@ -1286,1 +1292,1 @@\n-    if (converted) {\n+    if (short_scale) {\n@@ -1288,1 +1294,1 @@\n-      \/\/ i*K + L <u64 R\n+      \/\/ (int)i*K + L <u64 R\n@@ -1322,2 +1328,0 @@\n-    Node* Z_2 = new ConvI2LNode(inner_iters_actual_int, TypeLong::LONG);\n-    register_new_node(Z_2, entry_control);\n@@ -1337,1 +1341,10 @@\n-    Node* Q_max = new MulLNode(Z_2, K);\n+\n+    \/\/ A_2 if S < 0\n+    Node* B_2 = new LoopLimitNode(this->C, int_zero, inner_iters_actual_int, int_stride);\n+    register_new_node(B_2, entry_control);\n+    B_2 = new SubINode(B_2, int_stride);\n+    register_new_node(B_2, entry_control);\n+    B_2 = new ConvI2LNode(B_2);\n+    register_new_node(B_2, entry_control);\n+\n+    Node* Q_max = new MulLNode(B_2, K);\n@@ -1342,0 +1355,4 @@\n+    if (scale * stride_con < 0) {\n+      swap(Q_min, Q_max);\n+    }\n+\n@@ -1350,2 +1367,5 @@\n-    \/\/ H_clamp = Q_max < Q_min ? R : Q_max\n-    Node* Q_max_cmp = new CmpLNode(Q_max, Q_min);\n+    Node* Q_max_plus_one = new AddLNode(Q_max, long_one);\n+    register_new_node(Q_max_plus_one, entry_control);\n+\n+    \/\/ H_clamp = Q_max+1 < Q_min ? R : Q_max+1\n+    Node* Q_max_cmp = new CmpLNode(Q_max_plus_one, Q_min);\n@@ -1355,1 +1375,1 @@\n-    Node* H_clamp = new CMoveLNode(Q_max_bool, Q_max, R, TypeLong::LONG);\n+    Node* H_clamp = new CMoveLNode(Q_max_bool, Q_max_plus_one, R, TypeLong::LONG);\n@@ -1367,5 +1387,12 @@\n-    \/\/ Q = Q_min - L_clamp\n-    \/\/ that is: Q = Q_min - 0 if Q_min < 0\n-    \/\/ or:      Q = Q_min - Q_min = 0 if Q_min > 0\n-    Node* Q = new SubLNode(Q_min, L_clamp);\n-    register_new_node(Q, entry_control);\n+    Node* Q = NULL;\n+    if (scale * stride_con > 0) {\n+      \/\/ Q = Q_min - L_clamp\n+      \/\/ that is: Q = Q_min - 0 if Q_min < 0\n+      \/\/ or:      Q = Q_min - Q_min = 0 if Q_min > 0\n+      Q = new SubLNode(Q_min, L_clamp);\n+      register_new_node(Q, entry_control);\n+    } else {\n+      Q = new SubLNode(Q_max, L_clamp);\n+      register_new_node(Q, entry_control);\n+    }\n+\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":66,"deletions":39,"binary":false,"changes":105,"status":"modified"},{"patch":"@@ -1265,1 +1265,1 @@\n-  bool is_scaled_iv(Node* exp, Node* iv, jlong* p_scale, BasicType bt, bool* converted);\n+  bool is_scaled_iv(Node* exp, Node* iv, BasicType bt, jlong* p_scale, bool* p_short_scale, int depth = 0);\n@@ -1270,1 +1270,1 @@\n-  bool is_scaled_iv_plus_offset(Node* exp, Node* iv, jlong* p_scale, Node** p_offset, BasicType bt, bool* converted = NULL, int depth = 0);\n+  bool is_scaled_iv_plus_offset(Node* exp, Node* iv, BasicType bt, jlong* p_scale, Node** p_offset, bool* p_short_scale = NULL, int depth = 0);\n@@ -1273,1 +1273,1 @@\n-    if (is_scaled_iv_plus_offset(exp, iv, &long_scale, p_offset, T_INT)) {\n+    if (is_scaled_iv_plus_offset(exp, iv, T_INT, &long_scale, p_offset)) {\n@@ -1282,0 +1282,6 @@\n+  \/\/ Helper for finding more complex matches to is_scaled_iv_plus_offset.\n+  bool is_scaled_iv_plus_extra_offset(Node* exp1, Node* offset2, Node* iv,\n+                                      BasicType bt,\n+                                      jlong* p_scale, Node** p_offset,\n+                                      bool* p_short_scale, int depth);\n+\n@@ -1658,0 +1664,1 @@\n+\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":10,"deletions":3,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -1153,1 +1153,6 @@\n-    guarantee(t != NULL, \"must be con\");\n+    guarantee(t != NULL && t->is_con(), \"must be con\");\n+    return t->get_con_as_long(bt);\n+  }\n+  jlong find_integer_as_long(BasicType bt, jlong value_if_unknown) const {\n+    const TypeInteger* t = find_integer_type(bt);\n+    if (t == NULL || !t->is_con())  return value_if_unknown;\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -99,0 +99,146 @@\n+\n+    @Test\n+    @IR(counts = { IRNode.LOOP, \"1\"})\n+    @IR(failOn = { IRNode.COUNTEDLOOP})\n+    public static void testStrideNegScaleNeg(long start, long stop, long length, long offset) {\n+        final long scale = -1;\n+        final long stride = 1;\n+        for (long i = stop; i > start; i -= stride) {\n+            Objects.checkIndex(scale * i + offset, length);\n+        }\n+    }\n+\n+    @Run(test = \"testStrideNegScaleNeg\")\n+    private void testStrideNegScaleNeg_runner() {\n+        testStrideNegScaleNeg(0, 100, 100, 100);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.LOOP, \"1\" })\n+    @IR(failOn = { IRNode.COUNTEDLOOP })\n+    public static void testStrideNegScaleNegInIntLoop1(int start, int stop, long length, long offset) {\n+        final long scale = -2;\n+        final int stride = 1;\n+\n+        for (int i = stop; i > start; i -= stride) {\n+            Objects.checkIndex(scale * i + offset, length);\n+        }\n+    }\n+\n+    @Run(test = \"testStrideNegScaleNegInIntLoop1\")\n+    private void testStrideNegScaleNegInIntLoop1_runner() {\n+        testStrideNegScaleNegInIntLoop1(0, 100, 200, 200);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.LOOP, \"1\" })\n+    @IR(failOn = { IRNode.COUNTEDLOOP })\n+    public static void testStrideNegScaleNegInIntLoop2(int start, int stop, long length, long offset) {\n+        final int scale = -2;\n+        final int stride = 1;\n+\n+        for (int i = stop; i > start; i -= stride) {\n+            Objects.checkIndex(scale * i + offset, length);\n+        }\n+    }\n+\n+    @Run(test = \"testStrideNegScaleNegInIntLoop2\")\n+    private void testStrideNegScaleNegInIntLoop2_runner() {\n+        testStrideNegScaleNegInIntLoop2(0, 100, 200, 200);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.LOOP, \"1\"})\n+    @IR(failOn = { IRNode.COUNTEDLOOP})\n+    public static void testStrideNegScalePos(long start, long stop, long length, long offset) {\n+        final long scale = 1;\n+        final long stride = 1;\n+        for (long i = stop-1; i >= start; i -= stride) {\n+            Objects.checkIndex(scale * i + offset, length);\n+        }\n+    }\n+\n+    @Run(test = \"testStrideNegScalePos\")\n+    private void testStrideNegScalePos_runner() {\n+        testStrideNegScalePos(0, 100, 100, 0);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.LOOP, \"1\" })\n+    @IR(failOn = { IRNode.COUNTEDLOOP })\n+    public static void testStrideNegScalePosInIntLoop1(int start, int stop, long length, long offset) {\n+        final long scale = 2;\n+        final int stride = 1;\n+        for (int i = stop-1; i >= start; i -= stride) {\n+            Objects.checkIndex(scale * i + offset, length);\n+        }\n+    }\n+\n+    @Run(test = \"testStrideNegScalePosInIntLoop1\")\n+    private void testStrideNegScalePosInIntLoop1_runner() {\n+        testStrideNegScalePosInIntLoop1(0, 100, 200, 0);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.LOOP, \"1\" })\n+    @IR(failOn = { IRNode.COUNTEDLOOP })\n+    public static void testStrideNegScalePosInIntLoop2(int start, int stop, long length, long offset) {\n+        final int scale = 2;\n+        final int stride = 1;\n+        for (int i = stop-1; i >= start; i -= stride) {\n+            Objects.checkIndex(scale * i + offset, length);\n+        }\n+    }\n+\n+    @Run(test = \"testStrideNegScalePosInIntLoop2\")\n+    private void testStrideNegScalePosInIntLoop2_runner() {\n+        testStrideNegScalePosInIntLoop1(0, 100, 200, 0);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.LOOP, \"1\"})\n+    @IR(failOn = { IRNode.COUNTEDLOOP})\n+    public static void testStridePosScaleNeg(long start, long stop, long length, long offset) {\n+        final long scale = -1;\n+        final long stride = 1;\n+        for (long i = start; i < stop; i += stride) {\n+            Objects.checkIndex(scale * i + offset, length);\n+        }\n+    }\n+\n+    @Run(test = \"testStridePosScaleNeg\")\n+    private void testStridePosScaleNeg_runner() {\n+        testStridePosScaleNeg(0, 100, 100, 99);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.LOOP, \"1\"})\n+    @IR(failOn = { IRNode.COUNTEDLOOP})\n+    public static void testStridePosScaleNegInIntLoop1(int start, int stop, long length, long offset) {\n+        final long scale = -2;\n+        final int stride = 1;\n+        for (int i = start; i < stop; i += stride) {\n+            Objects.checkIndex(scale * i + offset, length);\n+        }\n+    }\n+\n+    @Run(test = \"testStridePosScaleNegInIntLoop1\")\n+    private void testStridePosScaleNegInIntLoop1_runner() {\n+        testStridePosScaleNegInIntLoop1(0, 100, 200, 198);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.LOOP, \"1\"})\n+    @IR(failOn = { IRNode.COUNTEDLOOP})\n+    public static void testStridePosScaleNegInIntLoop2(int start, int stop, long length, long offset) {\n+        final int scale = -2;\n+        final int stride = 1;\n+        for (int i = start; i < stop; i += stride) {\n+            Objects.checkIndex(scale * i + offset, length);\n+        }\n+    }\n+\n+    @Run(test = \"testStridePosScaleNegInIntLoop2\")\n+    private void testStridePosScaleNegInIntLoop2_runner() {\n+        testStridePosScaleNegInIntLoop1(0, 100, 200, 198);\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestLongRangeChecks.java","additions":146,"deletions":0,"binary":false,"changes":146,"status":"modified"},{"patch":"@@ -130,0 +130,67 @@\n+    private static void testOverflow(String method, long start, long stop, long length, long offset0, long offset1) throws Exception {\n+        Method m = newClassLoader().loadClass(\"TestLongRangeCheck\").getDeclaredMethod(method, long.class, long.class, long.class, long.class);\n+        m.invoke(null, start, stop, length, offset0);\n+        compile(m);\n+\n+        m.invoke(null, start, stop, length, offset0);\n+        assertIsCompiled(m);\n+        try {\n+            m.invoke(null, start, stop, length, offset1);\n+            throw new RuntimeException(\"should have thrown\");\n+        } catch(InvocationTargetException e) {\n+            if (!(e.getCause() instanceof IndexOutOfBoundsException)) {\n+                throw new RuntimeException(\"unexpected exception\");\n+            }\n+        }\n+        assertIsNotCompiled(m);\n+    }\n+\n+    private static void testConditional(String method, long start, long stop, long length, long offset0, long offset1, long start1, long stop1) throws Exception {\n+        Method m;\n+\n+        if (start1 != start) {\n+            m = newClassLoader().loadClass(\"TestLongRangeCheck\").getDeclaredMethod(method, long.class, long.class, long.class, long.class, long.class, long.class);\n+            m.invoke(null, start, stop, length, offset0, start, stop);\n+            compile(m);\n+\n+            m.invoke(null, start, stop, length, offset0, start, stop);\n+            assertIsCompiled(m);\n+            try {\n+                m.invoke(null, start, stop, length, offset1, start1-1, stop1);\n+                throw new RuntimeException(\"should have thrown\");\n+            } catch(InvocationTargetException e) {\n+                if (!(e.getCause() instanceof IndexOutOfBoundsException)) {\n+                    throw new RuntimeException(\"unexpected exception\");\n+                }\n+            }\n+            assertIsNotCompiled(m);\n+        }\n+\n+        if (stop1 != stop) {\n+            m = newClassLoader().loadClass(\"TestLongRangeCheck\").getDeclaredMethod(method, long.class, long.class, long.class, long.class, long.class, long.class);\n+            m.invoke(null, start, stop, length, offset0, start, stop);\n+            compile(m);\n+\n+            m.invoke(null, start, stop, length, offset0, start, stop);\n+            assertIsCompiled(m);\n+            try {\n+                m.invoke(null, start, stop, length, offset1, start1, stop1+1);\n+                throw new RuntimeException(\"should have thrown\");\n+            } catch(InvocationTargetException e) {\n+                if (!(e.getCause() instanceof IndexOutOfBoundsException)) {\n+                    throw new RuntimeException(\"unexpected exception\");\n+                }\n+            }\n+            assertIsNotCompiled(m);\n+        }\n+\n+        m = newClassLoader().loadClass(\"TestLongRangeCheck\").getDeclaredMethod(method, long.class, long.class, long.class, long.class, long.class, long.class);\n+        m.invoke(null, start, stop, length, offset0, start, stop);\n+        compile(m);\n+\n+        m.invoke(null, start, stop, length, offset0, start, stop);\n+        assertIsCompiled(m);\n+\n+        m.invoke(null, start, stop, length, offset1, start1, stop1);\n+        assertIsCompiled(m);\n+    }\n@@ -160,18 +227,4 @@\n-\n-        {\n-            Method m = newClassLoader().loadClass(\"TestLongRangeCheck\").getDeclaredMethod(\"testStridePosScalePos\", long.class, long.class, long.class, long.class);\n-            m.invoke(null, 0, 100, 100, 0);\n-            compile(m);\n-\n-            m.invoke(null, 0, 100, 100, 0);\n-            assertIsCompiled(m);\n-            try {\n-                m.invoke(null, 0, 100, 100, Long.MAX_VALUE - 50);\n-                throw new RuntimeException(\"should have thrown\");\n-            } catch(InvocationTargetException e) {\n-                if (!(e.getCause() instanceof IndexOutOfBoundsException)) {\n-                    throw new RuntimeException(\"unexpected exception\");\n-                }\n-            }\n-            assertIsNotCompiled(m);\n-        }\n+        testOverflow(\"testStridePosScalePos\", 0, 100, 100, 0, Long.MAX_VALUE - 50);\n+        testOverflow(\"testStrideNegScaleNeg\", 0, 100, 100, 100, Long.MIN_VALUE + 50);\n+        testOverflow(\"testStrideNegScalePos\", 0, 100, 100, 0, Long.MAX_VALUE - 50);\n+        testOverflow(\"testStridePosScaleNeg\", 0, 100, 100, 99, Long.MIN_VALUE + 50);\n@@ -180,16 +233,8 @@\n-        {\n-            Method m = newClassLoader().loadClass(\"TestLongRangeCheck\").getDeclaredMethod(\"testStridePosScalePosConditional\", long.class, long.class, long.class, long.class, long.class, long.class);\n-            m.invoke(null, 0, 100, 100, 0, 0, 100);\n-            compile(m);\n-\n-            m.invoke(null, 0, 100, 100, -50, 50, 100);\n-            assertIsCompiled(m);\n-        }\n-        {\n-            Method m = newClassLoader().loadClass(\"TestLongRangeCheck\").getDeclaredMethod(\"testStridePosScalePosConditional\", long.class, long.class, long.class, long.class, long.class, long.class);\n-            m.invoke(null, 0, 100, 100, 0, 0, 100);\n-            compile(m);\n-\n-            m.invoke(null, 0, 100, Long.MAX_VALUE, Long.MAX_VALUE - 50, 0, 50);\n-            assertIsCompiled(m);\n-        }\n+        testConditional(\"testStridePosScalePosConditional\", 0, 100, 100, 0, -50, 50, 100);\n+        testConditional(\"testStridePosScalePosConditional\", 0, 100, Long.MAX_VALUE, 0, Long.MAX_VALUE - 50, 0, 50);\n+        testConditional(\"testStrideNegScaleNegConditional\", 0, 100, 100, 100, 50, 0, 51);\n+        testConditional(\"testStrideNegScaleNegConditional\", 0, 100, Long.MAX_VALUE, 100, Long.MIN_VALUE + 50, 52, 100);\n+        testConditional(\"testStrideNegScalePosConditional\", 0, 100, 100, 0, -50, 50, 100);\n+        testConditional(\"testStrideNegScalePosConditional\", 0, 100, Long.MAX_VALUE, 100, Long.MAX_VALUE - 50, 0, 50);\n+        testConditional(\"testStridePosScaleNegConditional\", 0, 100, 100, 99, 50, 0, 51);\n+        testConditional(\"testStridePosScaleNegConditional\", 0, 100, Long.MAX_VALUE, 99, Long.MIN_VALUE + 50, 52, 100);\n@@ -224,17 +269,4 @@\n-        {\n-            Method m = newClassLoader().loadClass(\"TestLongRangeCheck\").getDeclaredMethod(\"testStridePosScalePosInIntLoop\", long.class, long.class, long.class, long.class);\n-            m.invoke(null, 0, 100, 100, 0);\n-            compile(m);\n-\n-            m.invoke(null, 0, 100, 100, 0);\n-            assertIsCompiled(m);\n-            try {\n-                m.invoke(null, 0, 100, 100, Long.MAX_VALUE - 50);\n-                throw new RuntimeException(\"should have thrown\");\n-            } catch(InvocationTargetException e) {\n-                if (!(e.getCause() instanceof IndexOutOfBoundsException)) {\n-                    throw new RuntimeException(\"unexpected exception\");\n-                }\n-            }\n-            assertIsNotCompiled(m);\n-        }\n+        testOverflow(\"testStridePosScalePosInIntLoop\", 0, 100, 100, 0, Long.MAX_VALUE - 50);\n+        testOverflow(\"testStrideNegScaleNegInIntLoop\", 0, 100, 100, 100, Long.MIN_VALUE + 50);\n+        testOverflow(\"testStrideNegScalePosInIntLoop\", 0, 100, 100, 0, Long.MAX_VALUE - 50);\n+        testOverflow(\"testStridePosScaleNegInIntLoop\", 0, 100, 100, 99, Long.MIN_VALUE + 50);\n@@ -242,16 +274,8 @@\n-        {\n-            Method m = newClassLoader().loadClass(\"TestLongRangeCheck\").getDeclaredMethod(\"testStridePosScalePosConditional\", long.class, long.class, long.class, long.class, long.class, long.class);\n-            m.invoke(null, 0, 100, 100, 0, 0, 100);\n-            compile(m);\n-\n-            m.invoke(null, 0, 100, 100, -50, 50, 100);\n-            assertIsCompiled(m);\n-        }\n-        {\n-            Method m = newClassLoader().loadClass(\"TestLongRangeCheck\").getDeclaredMethod(\"testStridePosScalePosConditional\", long.class, long.class, long.class, long.class, long.class, long.class);\n-            m.invoke(null, 0, 100, 100, 0, 0, 100);\n-            compile(m);\n-\n-            m.invoke(null, 0, 100, Long.MAX_VALUE, Long.MAX_VALUE - 50, 0, 50);\n-            assertIsCompiled(m);\n-        }\n+        testConditional(\"testStridePosScalePosConditionalInIntLoop\", 0, 100, 100, 0, -50, 50, 100);\n+        testConditional(\"testStridePosScalePosConditionalInIntLoop\", 0, 100, Long.MAX_VALUE, 0, Long.MAX_VALUE - 50, 0, 50);\n+        testConditional(\"testStrideNegScaleNegConditionalInIntLoop\", 0, 100, 100, 100, 50, 0, 51);\n+        testConditional(\"testStrideNegScaleNegConditionalInIntLoop\", 0, 100, Long.MAX_VALUE, 100, Long.MIN_VALUE + 50, 52, 100);\n+        testConditional(\"testStrideNegScalePosConditionalInIntLoop\", 0, 100, 100, 0, -50, 50, 100);\n+        testConditional(\"testStrideNegScalePosConditionalInIntLoop\", 0, 100, Long.MAX_VALUE, 100, Long.MAX_VALUE - 50, 0, 50);\n+        testConditional(\"testStridePosScaleNegConditionalInIntLoop\", 0, 100, 100, 99, 50, 0, 51);\n+        testConditional(\"testStridePosScaleNegConditionalInIntLoop\", 0, 100, Long.MAX_VALUE, 99, Long.MIN_VALUE + 50, 52, 100);\n@@ -414,0 +438,30 @@\n+    public static void testStrideNegScaleNegConditional(long start, long stop, long length, long offset, long start2, long stop2) {\n+        final long scale = -1;\n+        final long stride = 1;\n+        for (long i = stop; i > start; i -= stride) {\n+            if (i >= start2 && i < stop2) {\n+                Preconditions.checkIndex(scale * i + offset, length, null);\n+            }\n+        }\n+    }\n+\n+    public static void testStrideNegScalePosConditional(long start, long stop, long length, long offset, long start2, long stop2) {\n+        final long scale = 1;\n+        final long stride = 1;\n+        for (long i = stop-1; i >= start; i -= stride) {\n+            if (i >= start2 && i < stop2) {\n+                Preconditions.checkIndex(scale * i + offset, length, null);\n+            }\n+        }\n+    }\n+\n+    public static void testStridePosScaleNegConditional(long start, long stop, long length, long offset, long start2, long stop2) {\n+        final long scale = -1;\n+        final long stride = 1;\n+        for (long i = start; i < stop; i += stride) {\n+            if (i >= start2 && i < stop2) {\n+                Preconditions.checkIndex(scale * i + offset, length, null);\n+            }\n+        }\n+    }\n+\n@@ -532,1 +586,0 @@\n-        Preconditions.checkIndex(0, length, null);\n@@ -535,0 +588,33 @@\n+        for (int i = (int)start; i < (int)stop; i += stride) {\n+            if (i >= (int)start2 && i < (int)stop2) {\n+                Preconditions.checkIndex(scale * i + offset, length, null);\n+            }\n+        }\n+    }\n+\n+    public static void testStrideNegScaleNegConditionalInIntLoop(long start, long stop, long length, long offset, long start2, long stop2) {\n+        checkInputs(start, stop, start2, stop2);\n+        final long scale = -1;\n+        final int stride = 1;\n+        for (int i = (int)stop; i > (int)start; i -= stride) {\n+            if (i >= (int)start2 && i < (int)stop2) {\n+                Preconditions.checkIndex(scale * i + offset, length, null);\n+            }\n+        }\n+    }\n+\n+    public static void testStrideNegScalePosConditionalInIntLoop(long start, long stop, long length, long offset, long start2, long stop2) {\n+        checkInputs(start, stop, start2, stop2);\n+        final long scale = 1;\n+        final int stride = 1;\n+        for (int i = (int)(stop-1); i >= (int)start; i -= stride) {\n+            if (i >= (int)start2 && i < (int)stop2) {\n+                Preconditions.checkIndex(scale * i + offset, length, null);\n+            }\n+        }\n+    }\n+\n+    public static void testStridePosScaleNegConditionalInIntLoop(long start, long stop, long length, long offset, long start2, long stop2) {\n+        checkInputs(start, stop, start2, stop2);\n+        final long scale = -1;\n+        final int stride = 1;\n","filename":"test\/hotspot\/jtreg\/compiler\/rangechecks\/TestLongRangeCheck.java","additions":154,"deletions":68,"binary":false,"changes":222,"status":"modified"}]}