{"files":[{"patch":"@@ -39,1 +39,1 @@\n-#include \"classfile\/classLoaderDataGraph.hpp\"\n+#include \"classfile\/classLoaderDataGraph.inline.hpp\"\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -323,39 +323,0 @@\n-\n-\/\/ Iterating over the CLDG needs to be locked because\n-\/\/ unloading can remove entries concurrently soon.\n-template <bool keep_alive = true>\n-class ClassLoaderDataGraphIteratorBase : public StackObj {\n-  ClassLoaderData* _next;\n-  Thread*          _thread;\n-  HandleMark       _hm;  \/\/ clean up handles when this is done.\n-  NoSafepointVerifier _nsv; \/\/ No safepoints allowed in this scope\n-                            \/\/ unless verifying at a safepoint.\n-\n-public:\n-  ClassLoaderDataGraphIteratorBase() : _next(ClassLoaderDataGraph::_head), _thread(Thread::current()), _hm(_thread) {\n-    if (keep_alive) {\n-      assert_locked_or_safepoint(ClassLoaderDataGraph_lock);\n-    } else {\n-      assert_at_safepoint();\n-    }\n-  }\n-\n-  ClassLoaderData* get_next() {\n-    ClassLoaderData* cld = _next;\n-    \/\/ Skip already unloaded CLD for concurrent unloading.\n-    while (cld != NULL && !cld->is_alive()) {\n-      cld = cld->next();\n-    }\n-    if (cld != NULL) {\n-      if (keep_alive) {\n-        \/\/ Keep cld that is being returned alive.\n-        Handle(_thread, cld->holder());\n-      }\n-      _next = cld->next();\n-    } else {\n-      _next = NULL;\n-    }\n-    return cld;\n-  }\n-};\n-\n@@ -365,7 +326,0 @@\n-void ClassLoaderDataGraph::loaded_cld_do(CLDClosure* cl) {\n-  ClassLoaderDataGraphIterator iter;\n-  while (ClassLoaderData* cld = iter.get_next()) {\n-    cl->do_cld(cld);\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/classfile\/classLoaderDataGraph.cpp","additions":0,"deletions":46,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"runtime\/safepointVerifiers.hpp\"\n@@ -76,0 +77,1 @@\n+  template <bool keep_alive = true>\n@@ -77,0 +79,1 @@\n+\n@@ -146,0 +149,15 @@\n+\/\/ Iterating over the CLDG needs to be locked because\n+\/\/ unloading can remove entries concurrently soon.\n+template <bool keep_alive = true>\n+class ClassLoaderDataGraphIteratorBase : public StackObj {\n+  ClassLoaderData*    _next;\n+  Thread*             _thread;\n+  HandleMark          _hm;  \/\/ clean up handles when this is done.\n+  NoSafepointVerifier _nsv; \/\/ No safepoints allowed in this scope\n+                            \/\/ unless verifying at a safepoint.\n+\n+public:\n+  ClassLoaderDataGraphIteratorBase();\n+  ClassLoaderData* get_next();\n+};\n+\n","filename":"src\/hotspot\/share\/classfile\/classLoaderDataGraph.hpp","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -33,0 +33,2 @@\n+#include \"runtime\/handles.inline.hpp\"\n+#include \"runtime\/mutexLocker.hpp\"\n@@ -34,0 +36,40 @@\n+#include \"runtime\/safepoint.hpp\"\n+\n+template<bool keep_alive>\n+inline ClassLoaderDataGraphIteratorBase<keep_alive>::ClassLoaderDataGraphIteratorBase() :\n+    _next(ClassLoaderDataGraph::_head),\n+    _thread(Thread::current()),\n+    _hm(_thread) {\n+  if (keep_alive) {\n+    assert_locked_or_safepoint(ClassLoaderDataGraph_lock);\n+  } else {\n+    assert_at_safepoint();\n+  }\n+}\n+\n+template<bool keep_alive>\n+inline ClassLoaderData* ClassLoaderDataGraphIteratorBase<keep_alive>::get_next() {\n+  ClassLoaderData* cld = _next;\n+  \/\/ Skip already unloaded CLD for concurrent unloading.\n+  while (cld != NULL && !cld->is_alive()) {\n+    cld = cld->next();\n+  }\n+  if (cld != NULL) {\n+    if (keep_alive) {\n+      \/\/ Keep cld that is being returned alive.\n+      Handle(_thread, cld->holder());\n+    }\n+    _next = cld->next();\n+  } else {\n+    _next = NULL;\n+  }\n+  return cld;\n+}\n+\n+template<bool keep_alive>\n+inline void ClassLoaderDataGraph::loaded_cld_do(CLDClosure* cl) {\n+  ClassLoaderDataGraphIteratorBase<keep_alive> iter;\n+  while (ClassLoaderData* cld = iter.get_next()) {\n+    cl->do_cld(cld);\n+  }\n+}\n","filename":"src\/hotspot\/share\/classfile\/classLoaderDataGraph.inline.hpp","additions":42,"deletions":0,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-#include \"classfile\/classLoaderDataGraph.hpp\"\n+#include \"classfile\/classLoaderDataGraph.inline.hpp\"\n@@ -31,0 +31,1 @@\n+#include \"classfile\/javaClasses.inline.hpp\"\n","filename":"src\/hotspot\/share\/classfile\/classLoaderHierarchyDCmd.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-#include \"classfile\/classLoaderDataGraph.hpp\"\n+#include \"classfile\/classLoaderDataGraph.inline.hpp\"\n@@ -29,0 +29,1 @@\n+#include \"classfile\/javaClasses.inline.hpp\"\n@@ -49,1 +50,4 @@\n-  oop cl = cld->class_loader();\n+  \/\/ Class loaders are not kept alive so this closure must only be\n+  \/\/ used during a safepoint.\n+  assert_at_safepoint();\n+  oop cl = cld->class_loader_no_keepalive();\n@@ -66,1 +70,1 @@\n-    cls->_parent = java_lang_ClassLoader::parent(cl);\n+    cls->_parent = java_lang_ClassLoader::parent<AS_NO_KEEPALIVE>(cl);\n@@ -152,1 +156,1 @@\n-      cls->_parent = java_lang_ClassLoader::parent(cl);\n+      cls->_parent = java_lang_ClassLoader::parent<AS_NO_KEEPALIVE>(cl);\n@@ -157,1 +161,1 @@\n-    cl = java_lang_ClassLoader::parent(cl);\n+    cl = java_lang_ClassLoader::parent<AS_NO_KEEPALIVE>(cl);\n@@ -164,1 +168,1 @@\n-  ClassLoaderDataGraph::loaded_cld_do(&clsc);\n+  ClassLoaderDataGraph::loaded_cld_do<false>(&clsc);\n","filename":"src\/hotspot\/share\/classfile\/classLoaderStats.cpp","additions":10,"deletions":6,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -4667,5 +4667,0 @@\n-oop java_lang_ClassLoader::parent(oop loader) {\n-  assert(is_instance(loader), \"loader must be oop\");\n-  return loader->obj_field(_parent_offset);\n-}\n-\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"oops\/accessDecorators.hpp\"\n@@ -1478,0 +1479,1 @@\n+  template <DecoratorSet decorators = DECORATORS_NONE>\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -313,0 +313,6 @@\n+template <DecoratorSet decorators>\n+inline oop java_lang_ClassLoader::parent(oop loader) {\n+  assert(is_instance(loader), \"loader must be oop\");\n+  return loader->obj_field_access<decorators>(_parent_offset);\n+}\n+\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.inline.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-#include \"classfile\/classLoaderDataGraph.hpp\"\n+#include \"classfile\/classLoaderDataGraph.inline.hpp\"\n","filename":"src\/hotspot\/share\/classfile\/protectionDomainCache.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-#include \"classfile\/classLoaderDataGraph.hpp\"\n+#include \"classfile\/classLoaderDataGraph.inline.hpp\"\n","filename":"src\/hotspot\/share\/jfr\/periodic\/jfrPeriodic.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-#include \"classfile\/classLoaderDataGraph.hpp\"\n+#include \"classfile\/classLoaderDataGraph.inline.hpp\"\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/jfrTypeSet.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-#include \"classfile\/classLoaderDataGraph.hpp\"\n+#include \"classfile\/classLoaderDataGraph.inline.hpp\"\n","filename":"src\/hotspot\/share\/memory\/metaspace\/metaspaceReporter.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-#include \"classfile\/javaClasses.hpp\"\n+#include \"classfile\/javaClasses.inline.hpp\"\n","filename":"src\/hotspot\/share\/oops\/klass.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"classfile\/classLoaderStats.hpp\"\n@@ -1824,0 +1825,6 @@\n+WB_ENTRY(void, WB_ForceClassLoaderStatsSafepoint(JNIEnv* env, jobject wb))\n+  nullStream dev_null;\n+  ClassLoaderStatsVMOperation force_op(&dev_null);\n+  VMThread::execute(&force_op);\n+WB_END\n+\n@@ -2680,0 +2687,1 @@\n+  {CC\"forceClassLoaderStatsSafepoint\", CC\"()V\",       (void*)&WB_ForceClassLoaderStatsSafepoint },\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,141 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test Class unloading test while triggering execution of ClassLoaderStats VM operations\n+ * @summary Make sure class unloading occur even if ClassLoaderStats VM operations are executed\n+ * @requires vm.opt.final.ClassUnloading\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @library classes\n+ * @build jdk.test.whitebox.WhiteBox test.Empty test.LoadInParent test.LoadInChild\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xlog:gc*,class+unload=debug UnloadTestDuringClassLoaderStatsVMOperation\n+ *\/\n+import jdk.test.whitebox.WhiteBox;\n+\n+import java.net.URLClassLoader;\n+\n+import jdk.test.lib.classloader.ClassUnloadCommon;\n+\n+public class UnloadTestDuringClassLoaderStatsVMOperation {\n+    private static final WhiteBox wb = WhiteBox.getWhiteBox();\n+\n+    private static String className = \"test.Empty\";\n+    private static String parentClassName = \"test.LoadInParent\";\n+    private static String childClassName = \"test.LoadInChild\";\n+\n+    public static void main(String args[]) throws Exception {\n+        \/\/ Create a thread forcing ClassLoaderStats VM operations.\n+        Runnable task = () -> {\n+            while (true) {\n+                wb.forceClassLoaderStatsSafepoint();\n+            }\n+        };\n+        var clsThread = new Thread(task);\n+        clsThread.setDaemon(true);\n+        clsThread.start();\n+\n+        \/\/ Make sure classes can be unloaded even though the class loader\n+        \/\/ stats VM operation is running.\n+        testClassIsUnloaded();\n+        testClassLoadedInParentIsUnloaded();\n+    }\n+\n+    public static void testClassIsUnloaded() throws Exception {\n+        ClassUnloadCommon.failIf(wb.isClassAlive(className), className + \" is not expected to be alive yet\");\n+\n+        \/\/ Load a test class and verify that it gets unloaded once we do a major collection.\n+        var classLoader = ClassUnloadCommon.newClassLoader();\n+        var loaded = classLoader.loadClass(className);\n+        var object = loaded.getDeclaredConstructor().newInstance();\n+\n+        ClassUnloadCommon.failIf(!wb.isClassAlive(className), className + \" should be loaded and live\");\n+        System.out.println(\"testClassIsUnloaded loaded klass: \" + className);\n+\n+        \/\/ Make class unloadable.\n+        classLoader = null;\n+        loaded = null;\n+        object = null;\n+\n+        \/\/ Full\/Major collection should always unload classes.\n+        wb.fullGC();\n+        ClassUnloadCommon.failIf(wb.isClassAlive(className), className + \" should have been unloaded\");\n+    }\n+\n+    public static void testClassLoadedInParentIsUnloaded() throws Exception {\n+        ClassUnloadCommon.failIf(wb.isClassAlive(parentClassName), parentClassName + \" is not expected to be alive yet\");\n+        ClassUnloadCommon.failIf(wb.isClassAlive(childClassName), childClassName + \" is not expected to be alive yet\");\n+\n+        \/\/ Create two class loaders and load a test class in the parent and\n+        \/\/ verify that it gets unloaded once we do a major collection.\n+        var parentClassLoader = ClassUnloadCommon.newClassLoader();\n+        var childClassLoader =  new ChildURLClassLoader((URLClassLoader) parentClassLoader);\n+        var loadedParent = parentClassLoader.loadClass(parentClassName);\n+        var loadedChild = childClassLoader.loadClass(childClassName);\n+        var parent = loadedParent.getDeclaredConstructor().newInstance();\n+        var child = loadedChild.getDeclaredConstructor().newInstance();\n+\n+        ClassUnloadCommon.failIf(!wb.isClassAlive(parentClassName), parentClassName + \" should be loaded and live\");\n+        ClassUnloadCommon.failIf(!wb.isClassAlive(childClassName), childClassName + \" should be loaded and live\");\n+        System.out.println(\"testClassLoadedInParentIsUnloaded loaded klass: \" + loadedParent);\n+        System.out.println(\"testClassLoadedInParentIsUnloaded loaded klass: \" + loadedChild);\n+\n+        \/\/ Clear to allow unloading.\n+        parentClassLoader = null;\n+        childClassLoader = null;\n+        loadedParent = null;\n+        loadedChild = null;\n+        parent = null;\n+        child = null;\n+\n+        \/\/ Full\/Major collection should always unload classes.\n+        wb.fullGC();\n+        ClassUnloadCommon.failIf(wb.isClassAlive(parentClassName), parentClassName + \" should have been unloaded\");\n+        ClassUnloadCommon.failIf(wb.isClassAlive(childClassName), childClassName + \" should have been unloaded\");\n+    }\n+\n+    static class ChildURLClassLoader extends URLClassLoader {\n+        public ChildURLClassLoader(URLClassLoader parent) {\n+            super(\"ChildURLClassLoader\", parent.getURLs(), parent);\n+        }\n+\n+        @Override\n+        public Class<?> loadClass(String cn, boolean resolve) throws ClassNotFoundException {\n+            synchronized (getClassLoadingLock(cn)) {\n+                Class<?> c = findLoadedClass(cn);\n+                if (c == null) {\n+                    try {\n+                        c = findClass(cn);\n+                    } catch (ClassNotFoundException e) {\n+                        c = getParent().loadClass(cn);\n+                    }\n+                }\n+                if (resolve) {\n+                    resolveClass(c);\n+                }\n+                return c;\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/ClassUnload\/UnloadTestDuringClassLoaderStatsVMOperation.java","additions":141,"deletions":0,"binary":false,"changes":141,"status":"added"},{"patch":"@@ -0,0 +1,29 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+package test;\n+\n+public class LoadInChild {\n+    public String toString() { return \"Load In Child\"; }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/ClassUnload\/classes\/test\/LoadInChild.java","additions":29,"deletions":0,"binary":false,"changes":29,"status":"added"},{"patch":"@@ -0,0 +1,29 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+package test;\n+\n+public class LoadInParent {\n+    public String toString() { return \"Load In Parent\"; }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/ClassUnload\/classes\/test\/LoadInParent.java","additions":29,"deletions":0,"binary":false,"changes":29,"status":"added"},{"patch":"@@ -124,0 +124,2 @@\n+  public native void forceClassLoaderStatsSafepoint();\n+\n","filename":"test\/lib\/jdk\/test\/whitebox\/WhiteBox.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"}]}