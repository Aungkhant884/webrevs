{"files":[{"patch":"@@ -869,1 +869,0 @@\n-  vmTestbase\/nsk\/jvmti\/Breakpoint\/breakpoint001\/TestDescription.java \\\n@@ -879,2 +878,0 @@\n-  vmTestbase\/nsk\/jvmti\/ClassLoad\/classload001\/TestDescription.java \\\n-  vmTestbase\/nsk\/jvmti\/ClassPrepare\/classprep001\/TestDescription.java \\\n@@ -898,8 +895,0 @@\n-  vmTestbase\/nsk\/jvmti\/Exception\/exception001\/TestDescription.java \\\n-  vmTestbase\/nsk\/jvmti\/ExceptionCatch\/excatch001\/TestDescription.java \\\n-  vmTestbase\/nsk\/jvmti\/FieldAccess\/fieldacc001\/TestDescription.java \\\n-  vmTestbase\/nsk\/jvmti\/FieldAccess\/fieldacc002\/TestDescription.java \\\n-  vmTestbase\/nsk\/jvmti\/FieldAccess\/fieldacc003\/TestDescription.java \\\n-  vmTestbase\/nsk\/jvmti\/FieldAccess\/fieldacc004\/TestDescription.java \\\n-  vmTestbase\/nsk\/jvmti\/FieldModification\/fieldmod001\/TestDescription.java \\\n-  vmTestbase\/nsk\/jvmti\/FieldModification\/fieldmod002\/TestDescription.java \\\n@@ -908,2 +897,0 @@\n-  vmTestbase\/nsk\/jvmti\/FramePop\/framepop001\/TestDescription.java \\\n-  vmTestbase\/nsk\/jvmti\/FramePop\/framepop002\/TestDescription.java \\\n@@ -942,3 +929,0 @@\n-  vmTestbase\/nsk\/jvmti\/GetCurrentContendedMonitor\/contmon001\/TestDescription.java \\\n-  vmTestbase\/nsk\/jvmti\/GetCurrentContendedMonitor\/contmon002\/TestDescription.java \\\n-  vmTestbase\/nsk\/jvmti\/GetCurrentContendedMonitor\/contmon003\/TestDescription.java \\\n@@ -960,5 +944,0 @@\n-  vmTestbase\/nsk\/jvmti\/GetFrameCount\/framecnt001\/TestDescription.java \\\n-  vmTestbase\/nsk\/jvmti\/GetFrameCount\/framecnt002\/TestDescription.java \\\n-  vmTestbase\/nsk\/jvmti\/GetFrameCount\/framecnt003\/TestDescription.java \\\n-  vmTestbase\/nsk\/jvmti\/GetFrameLocation\/frameloc002\/TestDescription.java \\\n-  vmTestbase\/nsk\/jvmti\/GetFrameLocation\/frameloc003\/TestDescription.java \\\n@@ -1020,9 +999,0 @@\n-  vmTestbase\/nsk\/jvmti\/GetStackTrace\/getstacktr001\/TestDescription.java \\\n-  vmTestbase\/nsk\/jvmti\/GetStackTrace\/getstacktr002\/TestDescription.java \\\n-  vmTestbase\/nsk\/jvmti\/GetStackTrace\/getstacktr003\/TestDescription.java \\\n-  vmTestbase\/nsk\/jvmti\/GetStackTrace\/getstacktr004\/TestDescription.java \\\n-  vmTestbase\/nsk\/jvmti\/GetStackTrace\/getstacktr005\/TestDescription.java \\\n-  vmTestbase\/nsk\/jvmti\/GetStackTrace\/getstacktr006\/TestDescription.java \\\n-  vmTestbase\/nsk\/jvmti\/GetStackTrace\/getstacktr007\/TestDescription.java \\\n-  vmTestbase\/nsk\/jvmti\/GetStackTrace\/getstacktr008\/TestDescription.java \\\n-  vmTestbase\/nsk\/jvmti\/GetStackTrace\/getstacktr009\/TestDescription.java \\\n@@ -1036,2 +1006,0 @@\n-  vmTestbase\/nsk\/jvmti\/GetThreadInfo\/thrinfo001\/TestDescription.java \\\n-  vmTestbase\/nsk\/jvmti\/GetThreadInfo\/thrinfo002\/TestDescription.java \\\n@@ -1090,11 +1058,0 @@\n-  vmTestbase\/nsk\/jvmti\/MethodEntry\/mentry001\/TestDescription.java \\\n-  vmTestbase\/nsk\/jvmti\/MethodEntry\/mentry002\/TestDescription.java \\\n-  vmTestbase\/nsk\/jvmti\/MethodExit\/mexit002\/TestDescription.java \\\n-  vmTestbase\/nsk\/jvmti\/MonitorContendedEnter\/mcontenter001\/TestDescription.java \\\n-  vmTestbase\/nsk\/jvmti\/MonitorContendedEntered\/mcontentered001\/TestDescription.java \\\n-  vmTestbase\/nsk\/jvmti\/MonitorWait\/monitorwait001\/TestDescription.java \\\n-  vmTestbase\/nsk\/jvmti\/MonitorWaited\/monitorwaited001\/TestDescription.java \\\n-  vmTestbase\/nsk\/jvmti\/NativeMethodBind\/nativemethbind001\/TestDescription.java \\\n-  vmTestbase\/nsk\/jvmti\/NativeMethodBind\/nativemethbind002\/TestDescription.java \\\n-  vmTestbase\/nsk\/jvmti\/NativeMethodBind\/nativemethbind003\/TestDescription.java \\\n-  vmTestbase\/nsk\/jvmti\/NativeMethodBind\/nativemethbind004\/TestDescription.java \\\n@@ -1215,2 +1172,0 @@\n-  vmTestbase\/nsk\/jvmti\/SingleStep\/singlestep001\/TestDescription.java \\\n-  vmTestbase\/nsk\/jvmti\/SingleStep\/singlestep003\/TestDescription.java \\\n@@ -1221,5 +1176,0 @@\n-  vmTestbase\/nsk\/jvmti\/ThreadEnd\/threadend001\/TestDescription.java \\\n-  vmTestbase\/nsk\/jvmti\/ThreadEnd\/threadend002\/TestDescription.java \\\n-  vmTestbase\/nsk\/jvmti\/ThreadStart\/threadstart001\/TestDescription.java \\\n-  vmTestbase\/nsk\/jvmti\/ThreadStart\/threadstart002\/TestDescription.java \\\n-  vmTestbase\/nsk\/jvmti\/ThreadStart\/threadstart003\/TestDescription.java \\\n@@ -1228,1 +1178,0 @@\n-  vmTestbase\/nsk\/jvmti\/VMObjectAlloc\/vmobjalloc001\/TestDescription.java \\\n","filename":"test\/hotspot\/jtreg\/TEST.quick-groups","additions":0,"deletions":51,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -52,2 +52,2 @@\n-    native static void getReady();\n-    native static int check();\n+    native static void getReady(Thread thread);\n+    native static int check(Thread thread);\n@@ -62,1 +62,1 @@\n-            getReady();\n+            getReady(Thread.currentThread());\n@@ -64,1 +64,1 @@\n-            result = check();\n+            result = check(Thread.currentThread());\n@@ -77,1 +77,7 @@\n-        getReady();\n+        Thread otherThread = new Thread(() -> {\n+            new TestClass2().run();\n+        });\n+\n+        getReady(Thread.currentThread());\n+\n+        \/\/ should generate the events\n@@ -79,1 +85,8 @@\n-        result = check();\n+\n+        \/\/ loading classes on other thread should not generate the events\n+        otherThread.start();\n+        try {\n+            otherThread.join();\n+        } catch (InterruptedException e) {\n+        }\n+        result = check(Thread.currentThread());\n@@ -91,1 +104,1 @@\n-     static class TestClass implements TestInterface {\n+    static class TestClass implements TestInterface {\n@@ -119,0 +132,3 @@\n+    interface TestInterface2 {\n+        void run();\n+    }\n@@ -120,0 +136,4 @@\n+    static class TestClass2 implements TestInterface2 {\n+        public void run() {\n+        }\n+    }\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/ClassPrepare\/classprep01\/classprep01.java","additions":27,"deletions":7,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -66,0 +66,7 @@\n+\/\/ These classes are loaded on a different thread.\n+\/\/ We should not get ClassPrepare events for them.\n+static const class_info unexpectedClasses[] = {\n+    { (char *)\"Lclassprep01$TestInterface2;\", 0, 0, 0, 0 },\n+    { (char *)\"Lclassprep01$TestClass2;\", 0, 0, 0, 0}\n+};\n+\n@@ -90,0 +97,11 @@\n+const size_t NOT_FOUND = (size_t)(-1);\n+\n+size_t findClass(const char *classSig, const class_info *arr, int size) {\n+    for (int i = 0; i < size; i++) {\n+        if (strcmp(classSig, arr[i].sig) == 0) {\n+            return i;\n+        }\n+    }\n+    return NOT_FOUND;\n+}\n+\n@@ -186,3 +204,15 @@\n-  if (eventsCount >= eventsExpected) {\n-    LOG(\"(#%\" PRIuPTR \") too many events: %\" PRIuPTR \", expected: %\" PRIuPTR \"\\n\",\n-        eventsCount, eventsCount + 1, eventsExpected);\n+  size_t expectedClassIdx = findClass(inf.sig, classes, 2);\n+  \/\/ Test classes loading may cause system classes loading - skip them.\n+  if (expectedClassIdx == NOT_FOUND) {\n+    size_t unexpectedClassIdx = findClass(inf.sig, unexpectedClasses,\n+                                          sizeof(unexpectedClasses)\/sizeof(class_info));\n+    if (unexpectedClassIdx != NOT_FOUND) {\n+      printf(\"# wrong class: \\\"%s\\\"\\n\", inf.sig);\n+      result = STATUS_FAILED;\n+    }\n+    return;\n+  }\n+\n+  if (eventsCount != expectedClassIdx) {\n+    printf(\"(#%\" PRIuPTR \") unexpected order: %\" PRIuPTR \", expected: %\" PRIuPTR \"\\n\",\n+           eventsCount, expectedClassIdx, eventsCount);\n@@ -269,1 +299,1 @@\n-Java_classprep01_getReady(JNIEnv *jni, jclass cls) {\n+Java_classprep01_getReady(JNIEnv *jni, jclass cls, jthread thread) {\n@@ -271,1 +301,0 @@\n-  jthread prep_thread;\n@@ -278,6 +307,0 @@\n-  err = jvmti->GetCurrentThread(&prep_thread);\n-  if (err != JVMTI_ERROR_NONE) {\n-    LOG(\"Failed to get current thread: %s (%d)\\n\", TranslateError(err), err);\n-    result = STATUS_FAILED;\n-    return;\n-  }\n@@ -286,1 +309,1 @@\n-  if (jni->IsVirtualThread(prep_thread)) {\n+  if (jni->IsVirtualThread(thread)) {\n@@ -294,1 +317,1 @@\n-  print_thread_info(jvmti, jni, prep_thread);\n+  print_thread_info(jvmti, jni, thread);\n@@ -296,1 +319,1 @@\n-  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_CLASS_PREPARE, prep_thread);\n+  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_CLASS_PREPARE, thread);\n@@ -304,1 +327,1 @@\n-Java_classprep01_check(JNIEnv *jni, jclass cls) {\n+Java_classprep01_check(JNIEnv *jni, jclass cls, jthread thread) {\n@@ -306,1 +329,0 @@\n-  jthread prep_thread;\n@@ -313,6 +335,0 @@\n-  err = jvmti->GetCurrentThread(&prep_thread);\n-  if (err != JVMTI_ERROR_NONE) {\n-    LOG(\"Failed to get current thread: %s (%d)\\n\", TranslateError(err), err);\n-    return STATUS_FAILED;\n-  }\n-\n@@ -320,1 +336,1 @@\n-  print_thread_info(jvmti, jni, prep_thread);\n+  print_thread_info(jvmti, jni, thread);\n@@ -322,1 +338,1 @@\n-  err = jvmti->SetEventNotificationMode(JVMTI_DISABLE, JVMTI_EVENT_CLASS_PREPARE, prep_thread);\n+  err = jvmti->SetEventNotificationMode(JVMTI_DISABLE, JVMTI_EVENT_CLASS_PREPARE, thread);\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/ClassPrepare\/classprep01\/libclassprep01.cpp","additions":40,"deletions":24,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -1,88 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package nsk.jvmti.Breakpoint;\n-\n-import java.io.*;\n-\n-import nsk.share.*;\n-import nsk.share.jvmti.*;\n-\n-\/**\n- * This test exercises the JVMTI event <code>Breakpoint<\/code>.\n- * <br>It verifies that thread info, method info and location of\n- * received Breakpoint events will be the same with two breakpoints\n- * previously set on the methods <code>bpMethod()<\/code> and\n- * <code>bpMethod2()<\/code> via the function SetBreakpoint().\n- *\/\n-public class breakpoint001 {\n-    static {\n-        try {\n-            System.loadLibrary(\"breakpoint001\");\n-        } catch (UnsatisfiedLinkError ule) {\n-            System.err.println(\"Could not load \\\"breakpoint001\\\" library\");\n-            System.err.println(\"java.library.path:\"\n-                + System.getProperty(\"java.library.path\"));\n-            throw ule;\n-        }\n-    }\n-\n-    native int check();\n-\n-    public static void main(String[] argv) {\n-        argv = nsk.share.jvmti.JVMTITest.commonInit(argv);\n-\n-        \/\/ produce JCK-like exit status\n-        System.exit(run(argv, System.out) + Consts.JCK_STATUS_BASE);\n-    }\n-\n-    public static int run(String argv[], PrintStream out) {\n-        return new breakpoint001().runThis(argv, out);\n-    }\n-\n-    private int runThis(String argv[], PrintStream out) {\n-        ArgumentHandler argHandler = new ArgumentHandler(argv);\n-        Log log = new Log(out, argHandler);\n-        Thread.currentThread().setName(\"breakpoint001Thr\");\n-\n-        log.display(\"\\nReaching a breakpoint method ...\\n\");\n-        bpMethod();\n-        log.display(\"The breakpoint method leaved ...\");\n-\n-        return check();\n-    }\n-\n-    \/**\n-     * dummy method used only to reach breakpoint set in the agent\n-     *\/\n-    private void bpMethod() {\n-        int dummyVar = bpMethod2();\n-    }\n-\n-    \/**\n-     * dummy method used only to reach breakpoint set in the agent\n-     *\/\n-    private int bpMethod2() {\n-        return 0;\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/Breakpoint\/breakpoint001.java","additions":0,"deletions":88,"binary":false,"changes":88,"status":"deleted"},{"patch":"@@ -1,51 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/*\n- * @test\n- *\n- * @summary converted from VM Testbase nsk\/jvmti\/Breakpoint\/breakpoint001.\n- * VM Testbase keywords: [quick, jpda, jvmti, onload_only_caps, noras]\n- * VM Testbase readme:\n- * DESCRIPTION\n- *     This test exercises the JVMTI event Breakpoint.\n- *     It verifies that thread info, method info and location of received\n- *     Breakpoint events will be the same with two breakpoints previously\n- *     set on the methods 'bpMethod()' and 'bpMethod2()' via the function\n- *     SetBreakpoint().\n- * COMMENTS\n- *\n- * @library \/vmTestbase\n- *          \/test\/lib\n- *\n- * @comment make sure breakpoint001 is compiled with full debug info\n- * @build nsk.jvmti.Breakpoint.breakpoint001\n- * @clean nsk.jvmti.Breakpoint.breakpoint001\n- * @compile -g:lines,source,vars ..\/breakpoint001.java\n- *\n- * @run main\/othervm\/native\n- *      -agentlib:breakpoint001=-waittime=5\n- *      nsk.jvmti.Breakpoint.breakpoint001\n- *\/\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/Breakpoint\/breakpoint001\/TestDescription.java","additions":0,"deletions":51,"binary":false,"changes":51,"status":"deleted"},{"patch":"@@ -1,304 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include <stdio.h>\n-#include <string.h>\n-#include <jvmti.h>\n-#include \"agent_common.h\"\n-\n-#include \"nsk_tools.h\"\n-#include \"JVMTITools.h\"\n-#include \"jvmti_tools.h\"\n-#include \"jni_tools.h\"\n-\n-extern \"C\" {\n-\n-#define STATUS_FAILED 2\n-#define PASSED 0\n-\n-#define METH_NUM 2\n-static const char *METHODS[][2] = {\n-    { \"bpMethod\", \"()V\" },\n-    { \"bpMethod2\", \"()I\" }\n-};\n-\n-static const char *CLASS_SIG =\n-    \"Lnsk\/jvmti\/Breakpoint\/breakpoint001;\";\n-\n-static const char *THREAD_NAME = \"breakpoint001Thr\";\n-\n-static volatile int bpEvents[METH_NUM];\n-static volatile jint result = PASSED;\n-static jvmtiEnv *jvmti = NULL;\n-static jvmtiEventCallbacks callbacks;\n-\n-static volatile int callbacksEnabled = NSK_TRUE;\n-static jrawMonitorID agent_lock;\n-\n-static void initCounters() {\n-    int i;\n-\n-    for (i=0; i<METH_NUM; i++)\n-        bpEvents[i] = 0;\n-}\n-\n-static void setBP(jvmtiEnv *jvmti_env, JNIEnv *env, jclass klass) {\n-    jmethodID mid;\n-    int i;\n-\n-    for (i=0; i<METH_NUM; i++) {\n-        if (!NSK_JNI_VERIFY(env, (mid = env->GetMethodID(klass, METHODS[i][0], METHODS[i][1])) != NULL))\n-            env->FatalError(\"failed to get ID for the java method\\n\");\n-\n-        if (!NSK_JVMTI_VERIFY(jvmti_env->SetBreakpoint(mid, 0)))\n-            env->FatalError(\"failed to set breakpoint\\n\");\n-    }\n-}\n-\n-\/** callback functions **\/\n-void JNICALL\n-ClassLoad(jvmtiEnv *jvmti_env, JNIEnv *env, jthread thread, jclass klass) {\n-    char *sig, *generic;\n-\n-    jvmti->RawMonitorEnter(agent_lock);\n-\n-    if (callbacksEnabled) {\n-        \/\/ GetClassSignature may be called only during the start or the live phase\n-        if (!NSK_JVMTI_VERIFY(jvmti_env->GetClassSignature(klass, &sig, &generic)))\n-            env->FatalError(\"failed to obtain a class signature\\n\");\n-\n-        if (sig != NULL && (strcmp(sig, CLASS_SIG) == 0)) {\n-            NSK_DISPLAY1(\n-                \"ClassLoad event received for the class \\\"%s\\\"\\n\"\n-                \"\\tsetting breakpoints ...\\n\",\n-                sig);\n-            setBP(jvmti_env, env, klass);\n-        }\n-    }\n-\n-    jvmti->RawMonitorExit(agent_lock);\n-}\n-\n-void JNICALL\n-Breakpoint(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,\n-        jmethodID method, jlocation location) {\n-    jclass klass;\n-    char *clsSig, *generic, *methNam, *methSig;\n-    jvmtiThreadInfo thr_info;\n-    int checkStatus = PASSED;\n-    int i;\n-\n-    NSK_DISPLAY0(\">>>> Breakpoint event received\\n\");\n-\n-    \/* checking thread info *\/\n-    if (!NSK_JVMTI_VERIFY(jvmti_env->GetThreadInfo(thread, &thr_info))) {\n-        result = STATUS_FAILED;\n-        NSK_COMPLAIN0(\"TEST FAILED: unable to get thread info during Breakpoint callback\\n\\n\");\n-        return;\n-    }\n-    if (thr_info.name == NULL ||\n-            strcmp(thr_info.name,THREAD_NAME) != 0 ||\n-            thr_info.is_daemon == JNI_TRUE) {\n-        result = checkStatus = STATUS_FAILED;\n-        NSK_COMPLAIN2(\n-            \"TEST FAILED: Breakpoint event with unexpected thread info:\\n\"\n-            \"\\tname: \\\"%s\\\"\\ttype: %s thread\\n\\n\",\n-            (thr_info.name == NULL) ? \"NULL\" : thr_info.name,\n-            (thr_info.is_daemon == JNI_TRUE) ? \"deamon\" : \"user\");\n-    }\n-    else\n-        NSK_DISPLAY2(\"CHECK PASSED: thread name: \\\"%s\\\"\\ttype: %s thread\\n\",\n-            thr_info.name, (thr_info.is_daemon == JNI_TRUE) ? \"deamon\" : \"user\");\n-\n-    \/* checking location *\/\n-    if (location != 0) {\n-        result = checkStatus = STATUS_FAILED;\n-        NSK_COMPLAIN1(\"TEST FAILED: Breakpoint event with unexpected location %ld:\\n\\n\",\n-            (long) location);\n-    }\n-    else\n-        NSK_DISPLAY1(\"CHECK PASSED: location: %ld as expected\\n\",\n-            (long) location);\n-\n-    \/* checking method info *\/\n-    if (!NSK_JVMTI_VERIFY(jvmti_env->GetMethodDeclaringClass(method, &klass))) {\n-        result = checkStatus = STATUS_FAILED;\n-        NSK_COMPLAIN0(\"TEST FAILED: unable to get method declaring class during Breakpoint callback\\n\\n\");\n-        return;\n-    }\n-    if (!NSK_JVMTI_VERIFY(jvmti_env->GetClassSignature(klass, &clsSig, &generic))) {\n-        result = checkStatus = STATUS_FAILED;\n-        NSK_COMPLAIN0(\"TEST FAILED: unable to obtain a class signature during Breakpoint callback\\n\\n\");\n-        return;\n-    }\n-    if (clsSig == NULL ||\n-            strcmp(clsSig,CLASS_SIG) != 0) {\n-        result = checkStatus = STATUS_FAILED;\n-        NSK_COMPLAIN1(\n-            \"TEST FAILED: Breakpoint event with unexpected class signature:\\n\"\n-            \"\\t\\\"%s\\\"\\n\\n\",\n-            (clsSig == NULL) ? \"NULL\" : clsSig);\n-    }\n-    else\n-        NSK_DISPLAY1(\"CHECK PASSED: class signature: \\\"%s\\\"\\n\",\n-            clsSig);\n-\n-    if (!NSK_JVMTI_VERIFY(jvmti_env->GetMethodName(method, &methNam, &methSig, NULL))) {\n-        result = checkStatus = STATUS_FAILED;\n-        NSK_COMPLAIN0(\"TEST FAILED: unable to get method name during Breakpoint callback\\n\\n\");\n-        return;\n-    }\n-\n-    for (i=0; i<METH_NUM; i++)\n-        if (strcmp(methNam, METHODS[i][0]) == 0 &&\n-                strcmp(methSig, METHODS[i][1]) == 0) {\n-            NSK_DISPLAY2(\"CHECK PASSED: method name: \\\"%s\\\"\\tsignature: \\\"%s\\\"\\n\",\n-                methNam, methSig);\n-            if (checkStatus == PASSED)\n-                bpEvents[i]++;\n-            break;\n-        }\n-\n-    if (!NSK_JVMTI_VERIFY(jvmti_env->Deallocate((unsigned char*) methNam))) {\n-        result = STATUS_FAILED;\n-        NSK_COMPLAIN0(\"TEST FAILED: unable to deallocate memory pointed to method name\\n\\n\");\n-    }\n-    if (!NSK_JVMTI_VERIFY(jvmti_env->Deallocate((unsigned char*) methSig))) {\n-        result = STATUS_FAILED;\n-        NSK_COMPLAIN0(\"TEST FAILED: unable to deallocate memory pointed to method signature\\n\\n\");\n-    }\n-\n-    NSK_DISPLAY0(\"<<<<\\n\\n\");\n-}\n-\n-\n-void JNICALL\n-VMStart(jvmtiEnv *jvmti_env, JNIEnv* jni_env) {\n-    jvmti->RawMonitorEnter(agent_lock);\n-\n-    callbacksEnabled = NSK_TRUE;\n-\n-    jvmti->RawMonitorExit(agent_lock);\n-}\n-\n-\n-void JNICALL\n-VMDeath(jvmtiEnv *jvmti_env, JNIEnv* jni_env) {\n-    jvmti->RawMonitorEnter(agent_lock);\n-\n-    callbacksEnabled = NSK_FALSE;\n-\n-    jvmti->RawMonitorExit(agent_lock);\n-}\n-\/************************\/\n-\n-JNIEXPORT jint JNICALL\n-Java_nsk_jvmti_Breakpoint_breakpoint001_check(\n-        JNIEnv *env, jobject obj) {\n-    int i;\n-\n-    for (i=0; i<METH_NUM; i++) {\n-        if (bpEvents[i] != 1) {\n-            result = STATUS_FAILED;\n-            NSK_COMPLAIN3(\n-                \"TEST FAILED: wrong number of Breakpoint events\\n\"\n-                \"\\tfor the method \\\"%s %s\\\":\\n\"\n-                \"\\t\\tgot: %d\\texpected: 1\\n\",\n-                METHODS[i][0], METHODS[i][1], bpEvents[i]);\n-        }\n-        else\n-            NSK_DISPLAY3(\"CHECK PASSED: %d Breakpoint event(s) for the method \\\"%s %s\\\" as expected\\n\",\n-                bpEvents[i], METHODS[i][0], METHODS[i][1]);\n-    }\n-\n-    return result;\n-}\n-\n-#ifdef STATIC_BUILD\n-JNIEXPORT jint JNICALL Agent_OnLoad_breakpoint001(JavaVM *jvm, char *options, void *reserved) {\n-    return Agent_Initialize(jvm, options, reserved);\n-}\n-JNIEXPORT jint JNICALL Agent_OnAttach_breakpoint001(JavaVM *jvm, char *options, void *reserved) {\n-    return Agent_Initialize(jvm, options, reserved);\n-}\n-JNIEXPORT jint JNI_OnLoad_breakpoint001(JavaVM *jvm, char *options, void *reserved) {\n-    return JNI_VERSION_1_8;\n-}\n-#endif\n-jint Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {\n-    jvmtiCapabilities caps;\n-\n-    \/* init framework and parse options *\/\n-    if (!NSK_VERIFY(nsk_jvmti_parseOptions(options)))\n-        return JNI_ERR;\n-\n-    \/* create JVMTI environment *\/\n-    if (!NSK_VERIFY((jvmti =\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n-        return JNI_ERR;\n-\n-    initCounters();\n-\n-    \/* add capability to generate compiled method events *\/\n-    memset(&caps, 0, sizeof(jvmtiCapabilities));\n-    caps.can_generate_breakpoint_events = 1;\n-    if (!NSK_JVMTI_VERIFY(jvmti->AddCapabilities(&caps)))\n-        return JNI_ERR;\n-\n-    if (!NSK_JVMTI_VERIFY(jvmti->GetCapabilities(&caps)))\n-        return JNI_ERR;\n-\n-    if (!caps.can_generate_single_step_events)\n-        NSK_DISPLAY0(\"Warning: generation of single step events is not implemented\\n\");\n-\n-    \/* set event callback *\/\n-    NSK_DISPLAY0(\"setting event callbacks ...\\n\");\n-    (void) memset(&callbacks, 0, sizeof(callbacks));\n-    callbacks.ClassLoad = &ClassLoad;\n-    callbacks.Breakpoint = &Breakpoint;\n-    callbacks.VMStart = &VMStart;\n-    callbacks.VMDeath = &VMDeath;\n-\n-    if (!NSK_JVMTI_VERIFY(jvmti->SetEventCallbacks(&callbacks, sizeof(callbacks))))\n-        return JNI_ERR;\n-\n-    NSK_DISPLAY0(\"setting event callbacks done\\nenabling JVMTI events ...\\n\");\n-\n-    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_START, NULL)))\n-        return JNI_ERR;\n-    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_DEATH, NULL)))\n-        return JNI_ERR;\n-    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_CLASS_LOAD, NULL)))\n-        return JNI_ERR;\n-    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_BREAKPOINT, NULL)))\n-        return JNI_ERR;\n-    NSK_DISPLAY0(\"enabling the events done\\n\\n\");\n-\n-    if (jvmti->CreateRawMonitor(\"agent_lock\", &agent_lock) != JVMTI_ERROR_NONE) {\n-        return JNI_ERR;\n-    }\n-\n-    return JNI_OK;\n-}\n-\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/Breakpoint\/breakpoint001\/breakpoint001.cpp","additions":0,"deletions":304,"binary":false,"changes":304,"status":"deleted"},{"patch":"@@ -1,33 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include \"native_thread.cpp\"\n-#include \"nsk_tools.cpp\"\n-#include \"jni_tools.cpp\"\n-#include \"jvmti_tools.cpp\"\n-#include \"agent_tools.cpp\"\n-#include \"jvmti_FollowRefObjects.cpp\"\n-#include \"Injector.cpp\"\n-#include \"JVMTITools.cpp\"\n-#include \"agent_common.cpp\"\n-#include \"breakpoint001.cpp\"\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/Breakpoint\/breakpoint001\/libbreakpoint001.cpp","additions":0,"deletions":33,"binary":false,"changes":33,"status":"deleted"},{"patch":"@@ -1,100 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package nsk.jvmti.ClassLoad;\n-\n-import java.io.*;\n-import java.util.*;\n-import nsk.share.*;\n-\n-\/**\n- * The test exercises the JVMTI event Class Load.<br>\n- * It verifies that the event will be sent for the auxiliary class\n- * <code>TestedClass<\/code> and array of type <code>TestedClass<\/code>\n- * and vise versa for primitive classes and arrays of primitive types\n- * in accordance with the ClassLoad spec:<br>\n- * <code>Arrays of non-primitive types have class load events. Arrays of\n- * primitive types do not have class load events. Primitive classes (for\n- * example, java.lang.Integer.TYPE) do not have class load events.<\/code>\n- *\/\n-public class classload001 {\n-    static {\n-        try {\n-            System.loadLibrary(\"classload001\");\n-        } catch (UnsatisfiedLinkError ule) {\n-            System.err.println(\"Could not load \\\"classload001\\\" library\");\n-            System.err.println(\"java.library.path:\"\n-                + System.getProperty(\"java.library.path\"));\n-            throw ule;\n-        }\n-    }\n-\n-    native int check();\n-\n-    public static void main(String args[]) {\n-        args = nsk.share.jvmti.JVMTITest.commonInit(args);\n-\n-        \/\/ produce JCK-like exit status.\n-        System.exit(run(args, System.out) + Consts.JCK_STATUS_BASE);\n-    }\n-\n-    public static int run(String args[], PrintStream out) {\n-        return new classload001().runIt(args, out);\n-    }\n-\n-    private int runIt(String args[], PrintStream out) {\n-        return check();\n-    }\n-\n-    \/\/ classes & arrays used to verify an assertion in the agent\n-    Class boolCls = Boolean.TYPE;\n-    Class byteCls = Byte.TYPE;\n-    Class charCls = Character.TYPE;\n-    Class doubleCls = Double.TYPE;\n-    Class floatCls = Float.TYPE;\n-    Class intCls = Integer.TYPE;\n-    Class longCls = Long.TYPE;\n-    Class shortCls = Short.TYPE;\n-\n-    Class boolClArr[] = {Boolean.TYPE, Boolean.TYPE};\n-    Class byteClArr[] = {Byte.TYPE, Byte.TYPE};\n-    Class charClArr[] = {Character.TYPE};\n-    Class doubleClArr[] = {Double.TYPE};\n-    Class floatClArr[] = {Float.TYPE, Float.TYPE};\n-    Class intClArr[] = {Integer.TYPE};\n-    Class longClArr[] = {Long.TYPE};\n-    Class shortClArr[] = {Short.TYPE, Short.TYPE};\n-\n-    boolean boolArr[] = {false, true};\n-    byte byteArr[] = {Byte.MAX_VALUE};\n-    char charArr[] = {'a'};\n-    double doubleArr[] = {Double.MIN_VALUE};\n-    float floatArr[] = {Float.MAX_VALUE};\n-    int intArr[] = {Integer.MIN_VALUE};\n-    long longArr[] = {Long.MAX_VALUE};\n-    short shortArr[] = {Short.MIN_VALUE};\n-\n-    TestedClass testedCls[] = {new TestedClass()};\n-\n-    class TestedClass {}\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/ClassLoad\/classload001.java","additions":0,"deletions":100,"binary":false,"changes":100,"status":"deleted"},{"patch":"@@ -1,47 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/*\n- * @test\n- *\n- * @summary converted from VM Testbase nsk\/jvmti\/ClassLoad\/classload001.\n- * VM Testbase keywords: [quick, jpda, jvmti, onload_only_logic, noras]\n- * VM Testbase readme:\n- * DESCRIPTION\n- *     The test exercises the JVMTI event Class Load.\n- *     It verifies that the event will be sent for the auxiliary class\n- *     'TestedClass' and not sent for array of type 'TestedClass' and for\n- *     primitive classes and arrays of primitive types in accordance with\n- *     the ClassLoad spec:\n- *        \"Array class creation does not generate a class load event. The\n- *         creation of a primitive class (for example, java.lang.Integer.TYPE)\n- *         does not generate a class load event.\"\n- * COMMENTS\n- *     Fixed the 5031200 bug.\n- *\n- * @library \/vmTestbase\n- *          \/test\/lib\n- * @run main\/othervm\/native -agentlib:classload001=-waittime=5 nsk.jvmti.ClassLoad.classload001\n- *\/\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/ClassLoad\/classload001\/TestDescription.java","additions":0,"deletions":47,"binary":false,"changes":47,"status":"deleted"},{"patch":"@@ -1,206 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include <stdio.h>\n-#include <stdarg.h>\n-#include <stdlib.h>\n-#include <string.h>\n-\n-#include <jvmti.h>\n-#include \"agent_common.h\"\n-\n-#include \"nsk_tools.h\"\n-#include \"JVMTITools.h\"\n-#include \"jvmti_tools.h\"\n-\n-extern \"C\" {\n-\n-#define PASSED  0\n-#define STATUS_FAILED  2\n-\n-\/* classes which must have the class load event *\/\n-static const char *expSigs[] = {\n-    \"Lnsk\/jvmti\/ClassLoad\/classload001;\",\n-    \"Lnsk\/jvmti\/ClassLoad\/classload001$TestedClass;\"\n-};\n-#define EXP_SIG_NUM (sizeof(expSigs)\/sizeof(char*))\n-\n-\/* classes which must not have the class load event *\/\n-static const char *unexpSigs[] = {\n-    \"Z\", \/* boolean *\/\n-    \"B\", \/* byte *\/\n-    \"C\", \/* char *\/\n-    \"D\", \/* double *\/\n-    \"F\", \/* float *\/\n-    \"I\", \/* integer *\/\n-    \"J\", \/* long *\/\n-    \"S\", \/* short *\/\n-\n-    \"[Z\", \/* boolean array *\/\n-    \"[B\", \/* byte array *\/\n-    \"[C\", \/* char array *\/\n-    \"[D\", \/* double array *\/\n-    \"[F\", \/* float array *\/\n-    \"[I\", \/* integer array *\/\n-    \"[J\", \/* long array *\/\n-    \"[S\", \/* short array *\/\n-    \"[Lnsk\/jvmti\/ClassLoad\/classload001$TestedClass;\"\n-};\n-#define UNEXP_SIG_NUM (sizeof(unexpSigs)\/sizeof(char*))\n-\n-static volatile int clsEvents[EXP_SIG_NUM];\n-static volatile int primClsEvents[UNEXP_SIG_NUM];\n-\n-static jint result = PASSED;\n-static jvmtiEnv *jvmti = NULL;\n-static jvmtiEventCallbacks callbacks;\n-static jrawMonitorID countLock;\n-\n-static void initCounters() {\n-    size_t i;\n-\n-    for (i=0; i<EXP_SIG_NUM; i++)\n-        clsEvents[i] = 0;\n-\n-    for (i=0; i<UNEXP_SIG_NUM; i++)\n-        primClsEvents[i] = 0;\n-}\n-\n-static int findSig(char *sig, int expected) {\n-    unsigned int i;\n-\n-    for (i=0; i<((expected == 1) ? EXP_SIG_NUM : UNEXP_SIG_NUM); i++)\n-        if (sig != NULL &&\n-                strcmp(((expected == 1) ? expSigs[i] : unexpSigs[i]), sig) == 0)\n-            return i; \/* the signature found, return index *\/\n-\n-    return -1; \/* the signature not found *\/\n-}\n-\n-static void lock(jvmtiEnv *jvmti_env, JNIEnv *jni_env) {\n-    if (!NSK_JVMTI_VERIFY(jvmti_env->RawMonitorEnter(countLock)))\n-        jni_env->FatalError(\"failed to enter a raw monitor\\n\");\n-}\n-\n-static void unlock(jvmtiEnv *jvmti_env, JNIEnv *jni_env) {\n-    if (!NSK_JVMTI_VERIFY(jvmti_env->RawMonitorExit(countLock)))\n-        jni_env->FatalError(\"failed to exit a raw monitor\\n\");\n-}\n-\n-\/** callback functions **\/\n-void JNICALL\n-ClassLoad(jvmtiEnv *jvmti_env, JNIEnv *env, jthread thread, jclass klass) {\n-    int i = 0;\n-    char *sig, *generic;\n-\n-    lock(jvmti_env, env);\n-\n-    if (!NSK_JVMTI_VERIFY(jvmti_env->GetClassSignature(klass, &sig, &generic))) {\n-        result = STATUS_FAILED;\n-        NSK_COMPLAIN0(\"TEST FAILURE: unable to obtain a class signature\\n\");\n-        unlock(jvmti_env, env);\n-        return;\n-    }\n-\n-    i = findSig(sig, 1);\n-    if (i != -1) {\n-        clsEvents[i]++;\n-        NSK_DISPLAY1(\"CHECK PASSED: ClassLoad event received for the class \\\"%s\\\" as expected\\n\",\n-            sig);\n-    }\n-    else {\n-      i = findSig(sig, 0);\n-      if (i != -1) {\n-        result = STATUS_FAILED;\n-        primClsEvents[i]++;\n-        NSK_COMPLAIN1(\n-            \"TEST FAILED: JVMTI_EVENT_CLASS_LOAD event received for\\n\"\n-            \"\\t a primitive class\/array of primitive types with the signature \\\"%s\\\"\\n\",\n-            sig);\n-      }\n-    }\n-\n-    unlock(jvmti_env, env);\n-}\n-\/************************\/\n-\n-JNIEXPORT jint JNICALL\n-Java_nsk_jvmti_ClassLoad_classload001_check(\n-        JNIEnv *env, jobject obj) {\n-    size_t i;\n-\n-    for (i=0; i<EXP_SIG_NUM; i++)\n-        if (clsEvents[i] != 1) {\n-            result = STATUS_FAILED;\n-            NSK_COMPLAIN2(\"TEST FAILED: wrong number of JVMTI_EVENT_CLASS_LOAD events for \\\"%s\\\":\\n\\tgot: %d\\texpected: 1\\n\",\n-                expSigs[i], clsEvents[i]);\n-        }\n-\n-    for (i=0; i<UNEXP_SIG_NUM; i++)\n-        if (primClsEvents[i] != 0)\n-            NSK_COMPLAIN0(\"TEST FAILED: there are JVMTI_EVENT_CLASS_LOAD events for the primitive classes\\n\");\n-\n-    return result;\n-}\n-\n-#ifdef STATIC_BUILD\n-JNIEXPORT jint JNICALL Agent_OnLoad_classload001(JavaVM *jvm, char *options, void *reserved) {\n-    return Agent_Initialize(jvm, options, reserved);\n-}\n-JNIEXPORT jint JNICALL Agent_OnAttach_classload001(JavaVM *jvm, char *options, void *reserved) {\n-    return Agent_Initialize(jvm, options, reserved);\n-}\n-JNIEXPORT jint JNI_OnLoad_classload001(JavaVM *jvm, char *options, void *reserved) {\n-    return JNI_VERSION_1_8;\n-}\n-#endif\n-jint Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {\n-    \/* init framework and parse options *\/\n-    if (!NSK_VERIFY(nsk_jvmti_parseOptions(options)))\n-        return JNI_ERR;\n-\n-    \/* create JVMTI environment *\/\n-    if (!NSK_VERIFY((jvmti =\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n-        return JNI_ERR;\n-\n-    initCounters();\n-\n-    if (!NSK_JVMTI_VERIFY(jvmti->CreateRawMonitor(\"_counter_lock\", &countLock)))\n-        return JNI_ERR;\n-\n-    NSK_DISPLAY0(\"setting event callbacks ...\\n\");\n-    (void) memset(&callbacks, 0, sizeof(callbacks));\n-    callbacks.ClassLoad = &ClassLoad;\n-    if (!NSK_JVMTI_VERIFY(jvmti->SetEventCallbacks(&callbacks, sizeof(callbacks))))\n-        return JNI_ERR;\n-\n-    NSK_DISPLAY0(\"setting event callbacks done\\nenabling ClassLoad event ...\\n\");\n-    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_CLASS_LOAD, NULL)))\n-        return JNI_ERR;\n-    NSK_DISPLAY0(\"the event enabled\\n\");\n-\n-    return JNI_OK;\n-}\n-\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/ClassLoad\/classload001\/classload001.cpp","additions":0,"deletions":206,"binary":false,"changes":206,"status":"deleted"},{"patch":"@@ -1,33 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include \"native_thread.cpp\"\n-#include \"nsk_tools.cpp\"\n-#include \"jni_tools.cpp\"\n-#include \"jvmti_tools.cpp\"\n-#include \"agent_tools.cpp\"\n-#include \"jvmti_FollowRefObjects.cpp\"\n-#include \"Injector.cpp\"\n-#include \"JVMTITools.cpp\"\n-#include \"agent_common.cpp\"\n-#include \"classload001.cpp\"\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/ClassLoad\/classload001\/libclassload001.cpp","additions":0,"deletions":33,"binary":false,"changes":33,"status":"deleted"},{"patch":"@@ -1,97 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package nsk.jvmti.ClassPrepare;\n-\n-import java.io.PrintStream;\n-\n-public class classprep001 {\n-\n-    final static int JCK_STATUS_BASE = 95;\n-\n-    static {\n-        try {\n-            System.loadLibrary(\"classprep001\");\n-        } catch (UnsatisfiedLinkError ule) {\n-            System.err.println(\"Could not load classprep001 library\");\n-            System.err.println(\"java.library.path:\"\n-                + System.getProperty(\"java.library.path\"));\n-            throw ule;\n-        }\n-    }\n-\n-    native static void getReady(Thread thread);\n-    native static int check(Thread thread);\n-\n-    public static void main(String args[]) {\n-        args = nsk.share.jvmti.JVMTITest.commonInit(args);\n-\n-        \/\/ produce JCK-like exit status.\n-        System.exit(run(args, System.out) + JCK_STATUS_BASE);\n-    }\n-\n-    public static int run(String args[], PrintStream out) {\n-        Thread otherThread = new Thread(() -> {\n-            new TestClass2().run();\n-        });\n-\n-        getReady(Thread.currentThread());\n-\n-        \/\/ should generate the events\n-        new TestClass().run();\n-\n-        \/\/ loading classes on other thread should not generate the events\n-        otherThread.start();\n-        try {\n-            otherThread.join();\n-        } catch (InterruptedException e) {\n-        }\n-\n-        return check(Thread.currentThread());\n-    }\n-\n-    interface TestInterface {\n-        int constant = Integer.parseInt(\"10\");\n-        void run();\n-    }\n-\n-    static class TestClass implements TestInterface {\n-        static int i = 0;\n-        int count = 0;\n-        static {\n-            i++;\n-        }\n-        public void run() {\n-            count++;\n-        }\n-    }\n-\n-    interface TestInterface2 {\n-        void run();\n-    }\n-\n-    static class TestClass2 implements TestInterface2 {\n-        public void run() {\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/ClassPrepare\/classprep001.java","additions":0,"deletions":97,"binary":false,"changes":97,"status":"deleted"},{"patch":"@@ -1,45 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/*\n- * @test\n- *\n- * @summary converted from VM Testbase nsk\/jvmti\/ClassPrepare\/classprep001.\n- * VM Testbase keywords: [quick, jpda, jvmti, noras]\n- * VM Testbase readme:\n- * DESCRIPTION\n- *     The test exercises JVMTI event callback function ClassPrepare.\n- *     The test checks if class prepare event is generated when\n- *     class preparation is complete, and, at this point, class\n- *     fields, methods, and implemented interfaces are available,\n- *     and no code from the class has been executed.\n- * COMMENTS\n- *     Fixed according to the bug 4651181.\n- *     Ported from JVMDI.\n- *\n- * @library \/vmTestbase\n- *          \/test\/lib\n- * @run main\/othervm\/native -agentlib:classprep001 nsk.jvmti.ClassPrepare.classprep001\n- *\/\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/ClassPrepare\/classprep001\/TestDescription.java","additions":0,"deletions":45,"binary":false,"changes":45,"status":"deleted"},{"patch":"@@ -1,336 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include <stdio.h>\n-#include <string.h>\n-#include <inttypes.h>\n-#include \"jvmti.h\"\n-#include \"agent_common.h\"\n-#include \"JVMTITools.h\"\n-\n-extern \"C\" {\n-\n-\n-#define PASSED 0\n-#define STATUS_FAILED 2\n-\n-#define EXP_STATUS (JVMTI_CLASS_STATUS_VERIFIED | JVMTI_CLASS_STATUS_PREPARED)\n-\n-typedef struct {\n-    char *sig;\n-    jint status;\n-    jint mcount;\n-    jint fcount;\n-    jint icount;\n-} writable_class_info;\n-\n-typedef struct {\n-    const char *sig;\n-    jint status;\n-    jint mcount;\n-    jint fcount;\n-    jint icount;\n-} class_info;\n-\n-static jvmtiEnv *jvmti = NULL;\n-static jvmtiEventCallbacks callbacks;\n-static jint result = PASSED;\n-static jboolean printdump = JNI_FALSE;\n-static size_t eventsCount = 0;\n-static size_t eventsExpected = 0;\n-static class_info classes[] = {\n-    { \"Lnsk\/jvmti\/ClassPrepare\/classprep001$TestInterface;\", EXP_STATUS, 2, 1, 0 },\n-    { \"Lnsk\/jvmti\/ClassPrepare\/classprep001$TestClass;\", EXP_STATUS, 3, 2, 1 }\n-};\n-\/\/ These classes are loaded on a different thread.\n-\/\/ We should not get ClassPrepare events for them.\n-static const class_info unexpectedClasses[] = {\n-    { \"Lnsk\/jvmti\/ClassPrepare\/classprep001$TestInterface2;\", 0, 0, 0, 0 },\n-    { \"Lnsk\/jvmti\/ClassPrepare\/classprep001$TestClass2;\", 0, 0, 0, 0}\n-};\n-\n-void printStatus(jint status) {\n-    int flags = 0;\n-    if ((status & JVMTI_CLASS_STATUS_VERIFIED) != 0) {\n-        printf(\"JVMTI_CLASS_STATUS_VERIFIED\");\n-        flags++;\n-    }\n-    if ((status & JVMTI_CLASS_STATUS_PREPARED) != 0) {\n-        if (flags > 0) printf(\" | \");\n-        printf(\"JVMTI_CLASS_STATUS_PREPARED\");\n-        flags++;\n-    }\n-    if ((status & JVMTI_CLASS_STATUS_INITIALIZED) != 0) {\n-        if (flags > 0) printf(\" | \");\n-        printf(\"JVMTI_CLASS_STATUS_INITIALIZED\");\n-        flags++;\n-    }\n-    if ((status & JVMTI_CLASS_STATUS_ERROR) != 0) {\n-        if (flags > 0) printf(\" | \");\n-        printf(\"JVMTI_CLASS_STATUS_ERROR\");\n-        flags++;\n-    }\n-    printf(\" (0x%x)\\n\", status);\n-}\n-\n-const size_t NOT_FOUND = (size_t)(-1);\n-\n-size_t findClass(const char *classSig, const class_info *arr, int size) {\n-    for (int i = 0; i < size; i++) {\n-        if (strcmp(classSig, arr[i].sig) == 0) {\n-            return i;\n-        }\n-    }\n-    return NOT_FOUND;\n-}\n-\n-void JNICALL ClassPrepare(jvmtiEnv *jvmti_env, JNIEnv *env,\n-        jthread thr, jclass cls) {\n-    jvmtiError err;\n-    writable_class_info inf;\n-    jmethodID *methods;\n-    jfieldID *fields;\n-    jclass *interfaces;\n-    char *name, *sig, *generic;\n-    int i;\n-\n-    err = jvmti_env->GetClassSignature(cls, &inf.sig, &generic);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(GetClassSignature#%\" PRIuPTR \") unexpected error: %s (%d)\\n\",\n-               eventsCount, TranslateError(err), err);\n-        result = STATUS_FAILED;\n-        return;\n-    }\n-    err = jvmti_env->GetClassStatus(cls, &inf.status);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(GetClassStatus#%\" PRIuPTR \") unexpected error: %s (%d)\\n\",\n-               eventsCount, TranslateError(err), err);\n-        result = STATUS_FAILED;\n-    }\n-    err = jvmti_env->GetClassMethods(cls, &inf.mcount, &methods);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(GetClassMethods#%\" PRIuPTR \") unexpected error: %s (%d)\\n\",\n-               eventsCount, TranslateError(err), err);\n-        result = STATUS_FAILED;\n-        return;\n-    }\n-    err = jvmti_env->GetClassFields(cls, &inf.fcount, &fields);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(GetClassMethods#%\" PRIuPTR \") unexpected error: %s (%d)\\n\",\n-               eventsCount, TranslateError(err), err);\n-        result = STATUS_FAILED;\n-        return;\n-    }\n-    err = jvmti_env->GetImplementedInterfaces(cls,\n-        &inf.icount, &interfaces);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(GetImplementedInterfaces#%\" PRIuPTR \") unexpected error: %s (%d)\\n\",\n-               eventsCount, TranslateError(err), err);\n-        result = STATUS_FAILED;\n-        return;\n-    }\n-\n-    if (printdump == JNI_TRUE) {\n-        printf(\">>> [class prepare event #%\" PRIuPTR \"]\", eventsCount);\n-        printf(\" \\\"%s\\\"\\n\", inf.sig);\n-        printf(\">>>   status: \");\n-        printStatus(inf.status);\n-        printf(\">>>   %d methods:\", inf.mcount);\n-        for (i = 0; i < inf.mcount; i++) {\n-            if (i > 0) printf(\",\");\n-            if (methods[i] == NULL) {\n-                printf(\" null\");\n-            } else {\n-                err = jvmti_env->GetMethodName(methods[i],\n-                    &name, &sig, &generic);\n-                if (err == JVMTI_ERROR_NONE) {\n-                    printf(\" \\\"%s%s\\\"\", name, sig);\n-                } else {\n-                    printf(\" ???\");\n-                }\n-            }\n-        }\n-        printf(\"\\n\");\n-        printf(\">>>   %d fields:\", inf.fcount);\n-        for (i = 0; i < inf.fcount; i++) {\n-            if (i > 0) printf(\",\");\n-            if (fields[i] == NULL) {\n-                printf(\" null\");\n-            } else {\n-                err = jvmti_env->GetFieldName(cls, fields[i],\n-                    &name, &sig, &generic);\n-                if (err == JVMTI_ERROR_NONE) {\n-                    printf(\" \\\"%s, %s\\\"\", name, sig);\n-                } else {\n-                    printf(\" ???\");\n-                }\n-            }\n-        }\n-        printf(\"\\n\");\n-        printf(\">>>   %d interfaces:\", inf.icount);\n-        for (i = 0; i < inf.icount; i++) {\n-            if (i > 0) printf(\",\");\n-            if (interfaces[i] == NULL) {\n-                printf(\" null\");\n-            } else {\n-                err = jvmti_env->GetClassSignature(\n-                    interfaces[i], &sig, &generic);\n-                if (err == JVMTI_ERROR_NONE) {\n-                    printf(\" \\\"%s\\\"\", sig);\n-                } else {\n-                    printf(\" ???\");\n-                }\n-            }\n-        }\n-        printf(\"\\n\");\n-    }\n-\n-    size_t expectedClassIdx = findClass(inf.sig, classes, sizeof(classes)\/sizeof(class_info));\n-    \/\/ Test classes loading may cause system classes loading - skip them.\n-    if (expectedClassIdx == NOT_FOUND) {\n-        size_t unexpectedClassIdx = findClass(inf.sig, unexpectedClasses,\n-                                              sizeof(unexpectedClasses)\/sizeof(class_info));\n-        if (unexpectedClassIdx != NOT_FOUND) {\n-            printf(\"# wrong class: \\\"%s\\\"\\n\", inf.sig);\n-            result = STATUS_FAILED;\n-        }\n-        return;\n-    }\n-\n-    if (eventsCount != expectedClassIdx) {\n-        printf(\"(#%\" PRIuPTR \") unexpected order: %\" PRIuPTR \", expected: %\" PRIuPTR \"\\n\",\n-               eventsCount, expectedClassIdx, eventsCount);\n-        result = STATUS_FAILED;\n-        return;\n-    }\n-\n-    if (inf.status != classes[eventsCount].status) {\n-        printf(\"(#%\" PRIuPTR \") wrong status: \", eventsCount);\n-        printStatus(inf.status);\n-        printf(\"     expected: \");\n-        printStatus(classes[eventsCount].status);\n-        result = STATUS_FAILED;\n-    }\n-    if (inf.mcount != classes[eventsCount].mcount) {\n-        printf(\"(#%\" PRIuPTR \") wrong number of methods: 0x%x\",\n-               eventsCount, inf.mcount);\n-        printf(\", expected: 0x%x\\n\", classes[eventsCount].mcount);\n-        result = STATUS_FAILED;\n-    }\n-    if (inf.fcount != classes[eventsCount].fcount) {\n-        printf(\"(#%\" PRIuPTR \") wrong number of fields: 0x%x\",\n-               eventsCount, inf.fcount);\n-        printf(\", expected: 0x%x\\n\", classes[eventsCount].fcount);\n-        result = STATUS_FAILED;\n-    }\n-    if (inf.icount != classes[eventsCount].icount) {\n-        printf(\"(#%\" PRIuPTR \") wrong number of interfaces: 0x%x\",\n-               eventsCount, inf.icount);\n-        printf(\", expected: 0x%x\\n\", classes[eventsCount].icount);\n-        result = STATUS_FAILED;\n-    }\n-    eventsCount++;\n-}\n-\n-#ifdef STATIC_BUILD\n-JNIEXPORT jint JNICALL Agent_OnLoad_classprep001(JavaVM *jvm, char *options, void *reserved) {\n-    return Agent_Initialize(jvm, options, reserved);\n-}\n-JNIEXPORT jint JNICALL Agent_OnAttach_classprep001(JavaVM *jvm, char *options, void *reserved) {\n-    return Agent_Initialize(jvm, options, reserved);\n-}\n-JNIEXPORT jint JNI_OnLoad_classprep001(JavaVM *jvm, char *options, void *reserved) {\n-    return JNI_VERSION_1_8;\n-}\n-#endif\n-jint Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {\n-    jvmtiError err;\n-    jint res;\n-\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n-        printdump = JNI_TRUE;\n-    }\n-\n-    res = jvm->GetEnv((void **) &jvmti, JVMTI_VERSION_1_1);\n-    if (res != JNI_OK || jvmti == NULL) {\n-        printf(\"Wrong result of a valid call to GetEnv!\\n\");\n-        return JNI_ERR;\n-    }\n-\n-    callbacks.ClassPrepare = &ClassPrepare;\n-    err = jvmti->SetEventCallbacks(&callbacks, sizeof(callbacks));\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(SetEventCallbacks) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        return JNI_ERR;\n-    }\n-\n-    return JNI_OK;\n-}\n-\n-JNIEXPORT void JNICALL\n-Java_nsk_jvmti_ClassPrepare_classprep001_getReady(JNIEnv *env, jclass cls, jthread thread) {\n-    jvmtiError err;\n-\n-    if (jvmti == NULL) {\n-        printf(\"JVMTI client was not properly loaded!\\n\");\n-        return;\n-    }\n-\n-    err = jvmti->SetEventNotificationMode(JVMTI_ENABLE,\n-            JVMTI_EVENT_CLASS_PREPARE, thread);\n-    if (err == JVMTI_ERROR_NONE) {\n-        eventsExpected = sizeof(classes)\/sizeof(class_info);\n-    } else {\n-        printf(\"Failed to enable JVMTI_EVENT_CLASS_PREPARE: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-    }\n-}\n-\n-JNIEXPORT jint JNICALL\n-Java_nsk_jvmti_ClassPrepare_classprep001_check(JNIEnv *env, jclass cls, jthread thread) {\n-    jvmtiError err;\n-\n-    if (jvmti == NULL) {\n-        printf(\"JVMTI client was not properly loaded!\\n\");\n-        return STATUS_FAILED;\n-    }\n-\n-    err = jvmti->SetEventNotificationMode(JVMTI_DISABLE,\n-            JVMTI_EVENT_CLASS_PREPARE, thread);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"Failed to disable JVMTI_EVENT_CLASS_PREPARE: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-    }\n-\n-    if (eventsCount != eventsExpected) {\n-        printf(\"Wrong number of class prepare events: %\" PRIuPTR \", expected: %\" PRIuPTR \"\\n\",\n-            eventsCount, eventsExpected);\n-        result = STATUS_FAILED;\n-    }\n-    return result;\n-}\n-\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/ClassPrepare\/classprep001\/classprep001.cpp","additions":0,"deletions":336,"binary":false,"changes":336,"status":"deleted"},{"patch":"@@ -1,33 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include \"native_thread.cpp\"\n-#include \"nsk_tools.cpp\"\n-#include \"jni_tools.cpp\"\n-#include \"jvmti_tools.cpp\"\n-#include \"agent_tools.cpp\"\n-#include \"jvmti_FollowRefObjects.cpp\"\n-#include \"Injector.cpp\"\n-#include \"JVMTITools.cpp\"\n-#include \"agent_common.cpp\"\n-#include \"classprep001.cpp\"\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/ClassPrepare\/classprep001\/libclassprep001.cpp","additions":0,"deletions":33,"binary":false,"changes":33,"status":"deleted"},{"patch":"@@ -1,55 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package nsk.jvmti.Exception;\n-\n-import java.io.PrintStream;\n-\n-public class exception001 {\n-\n-    final static int JCK_STATUS_BASE = 95;\n-\n-    static {\n-        try {\n-            System.loadLibrary(\"exception001\");\n-        } catch (UnsatisfiedLinkError ule) {\n-            System.err.println(\"Could not load exception001 library\");\n-            System.err.println(\"java.library.path:\"\n-                + System.getProperty(\"java.library.path\"));\n-            throw ule;\n-        }\n-    }\n-\n-    native static int check();\n-\n-    public static void main(String args[]) {\n-        args = nsk.share.jvmti.JVMTITest.commonInit(args);\n-\n-        \/\/ produce JCK-like exit status.\n-        System.exit(run(args, System.out) + JCK_STATUS_BASE);\n-    }\n-\n-    public static int run(String args[], PrintStream out) {\n-        return check();\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/Exception\/exception001.java","additions":0,"deletions":55,"binary":false,"changes":55,"status":"deleted"},{"patch":"@@ -1,46 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/*\n- * @test\n- *\n- * @summary converted from VM Testbase nsk\/jvmti\/Exception\/exception001.\n- * VM Testbase keywords: [quick, jpda, jvmti, noras]\n- * VM Testbase readme:\n- * DESCRIPTION\n- *     The test exercise JVMTI event callback function Exception.\n- *     The test checks if the parameters of the function contain\n- *     the expected values for the following exceptions thrown by Java methods:\n- *       - custom class exception001c extending Throwable\n- *       - ArithmeticException caused by division with zero devisor\n- *       - IndexOutOfBoundsException caused by using out of range array index\n- * COMMENTS\n- *     Ported from JVMDI.\n- *\n- * @library \/vmTestbase\n- *          \/test\/lib\n- * @compile exception001a.jasm\n- * @run main\/othervm\/native -agentlib:exception001 nsk.jvmti.Exception.exception001\n- *\/\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/Exception\/exception001\/TestDescription.java","additions":0,"deletions":46,"binary":false,"changes":46,"status":"deleted"},{"patch":"@@ -1,315 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include <stdio.h>\n-#include <string.h>\n-#include \"jvmti.h\"\n-#include \"agent_common.h\"\n-#include \"JVMTITools.h\"\n-\n-extern \"C\" {\n-\n-\n-#define PASSED 0\n-#define STATUS_FAILED 2\n-\n-typedef struct {\n-    char *name;\n-    char *t_cls;\n-    char *t_name;\n-    char *t_sig;\n-    jlocation t_loc;\n-    char *c_cls;\n-    char *c_name;\n-    char *c_sig;\n-    jlocation c_loc;\n-} writable_exceptionInfo;\n-\n-typedef struct {\n-    const char *name;\n-    const char *t_cls;\n-    const char *t_name;\n-    const char *t_sig;\n-    jlocation t_loc;\n-    const char *c_cls;\n-    const char *c_name;\n-    const char *c_sig;\n-    jlocation c_loc;\n-} exceptionInfo;\n-\n-static jvmtiEnv *jvmti = NULL;\n-static jvmtiCapabilities caps;\n-static jvmtiEventCallbacks callbacks;\n-static jint result = PASSED;\n-static jboolean printdump = JNI_FALSE;\n-static exceptionInfo exs[] = {\n-  { \"Lnsk\/jvmti\/Exception\/exception001c;\",\n-    \"Lnsk\/jvmti\/Exception\/exception001b;\", \"meth1\", \"()V\", 7,\n-    \"Lnsk\/jvmti\/Exception\/exception001a;\", \"run\", \"()V\", 14 },\n-  { \"Ljava\/lang\/ArithmeticException;\",\n-    \"Lnsk\/jvmti\/Exception\/exception001b;\", \"meth2\", \"(I)I\", 3,\n-    \"Lnsk\/jvmti\/Exception\/exception001a;\", \"run\", \"()V\", 24 },\n-  { \"Ljava\/lang\/ArrayIndexOutOfBoundsException;\",\n-    \"Lnsk\/jvmti\/Exception\/exception001b;\", \"meth3\", \"(I)I\", 10,\n-    \"Lnsk\/jvmti\/Exception\/exception001a;\", \"run\", \"()V\", 34 }\n-};\n-static int eventsCount = 0;\n-static int eventsExpected = 0;\n-\n-void JNICALL\n-Exception(jvmtiEnv *jvmti_env, JNIEnv *env, jthread thr,\n-        jmethodID method, jlocation location, jobject exception,\n-        jmethodID catch_method, jlocation catch_location) {\n-    jvmtiError err;\n-    writable_exceptionInfo ex;\n-    jclass cls;\n-    char *generic;\n-    size_t i;\n-\n-    if (printdump == JNI_TRUE) {\n-        printf(\">>> retrieving Exception info ...\\n\");\n-    }\n-    cls = env->GetObjectClass(exception);\n-    err = jvmti_env->GetClassSignature(cls, &ex.name, &generic);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(GetClassSignature) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-        return;\n-    }\n-    err = jvmti_env->GetMethodDeclaringClass(method, &cls);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(GetMethodDeclaringClass#t) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-        return;\n-    }\n-    err = jvmti_env->GetClassSignature(cls, &ex.t_cls, &generic);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(GetClassSignature#t) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-        return;\n-    }\n-    err = jvmti_env->GetMethodName(method,\n-        &ex.t_name, &ex.t_sig, &generic);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(GetMethodName#t) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-        return;\n-    }\n-    ex.t_loc = location;\n-    err = jvmti_env->GetMethodDeclaringClass(catch_method, &cls);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(GetMethodDeclaringClass#c) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-        return;\n-    }\n-    err = jvmti_env->GetClassSignature(cls, &ex.c_cls, &generic);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(GetClassSignature#c) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-        return;\n-    }\n-    err = jvmti_env->GetMethodName(catch_method,\n-        &ex.c_name, &ex.c_sig, &generic);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(GetMethodName#c) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-        return;\n-    }\n-    ex.c_loc = catch_location;\n-    if (printdump == JNI_TRUE) {\n-        printf(\">>> %s\\n\", ex.name);\n-        printf(\">>>   thrown at %s.%s%s:0x%x%08x\\n\",\n-               ex.t_cls, ex.t_name, ex.t_sig,\n-               (jint)(ex.t_loc >> 32), (jint)ex.t_loc);\n-        printf(\">>>    catch at %s.%s%s:0x%x%08x\\n\",\n-               ex.c_cls, ex.c_name, ex.c_sig,\n-               (jint)(ex.c_loc >> 32), (jint)ex.c_loc);\n-        printf(\">>> ... done\\n\");\n-    }\n-    for (i = 0; i < sizeof(exs)\/sizeof(exceptionInfo); i++) {\n-        if (ex.name != NULL && strcmp(ex.name, exs[i].name) == 0\n-         && ex.t_cls != NULL && strcmp(ex.t_cls, exs[i].t_cls) == 0\n-         && ex.t_name != NULL && strcmp(ex.t_name, exs[i].t_name) == 0\n-         && ex.t_sig != NULL && strcmp(ex.t_sig, exs[i].t_sig) == 0\n-         && ex.c_cls != NULL && strcmp(ex.c_cls, exs[i].c_cls) == 0\n-         && ex.c_name != NULL && strcmp(ex.c_name, exs[i].c_name) == 0\n-         && ex.c_sig != NULL && strcmp(ex.c_sig, exs[i].c_sig) == 0\n-         && ex.t_loc == exs[i].t_loc && ex.c_loc == exs[i].c_loc) {\n-            eventsCount++;\n-            break;\n-        }\n-    }\n-    if (i == sizeof(exs)\/sizeof(exceptionInfo)) {\n-        printf(\"Unexpected exception event:\\n\");\n-        printf(\"  %s\\n\", ex.name);\n-        printf(\"    thrown at %s.%s%s:0x%x%08x\\n\",\n-               ex.t_cls, ex.t_name, ex.t_sig,\n-               (jint)(ex.t_loc >> 32), (jint)ex.t_loc);\n-        printf(\"     catch at %s.%s%s:0x%x%08x\\n\",\n-               ex.c_cls, ex.c_name, ex.c_sig,\n-               (jint)(ex.c_loc >> 32), (jint)ex.c_loc);\n-        result = STATUS_FAILED;\n-    }\n-}\n-\n-#ifdef STATIC_BUILD\n-JNIEXPORT jint JNICALL Agent_OnLoad_exception001(JavaVM *jvm, char *options, void *reserved) {\n-    return Agent_Initialize(jvm, options, reserved);\n-}\n-JNIEXPORT jint JNICALL Agent_OnAttach_exception001(JavaVM *jvm, char *options, void *reserved) {\n-    return Agent_Initialize(jvm, options, reserved);\n-}\n-JNIEXPORT jint JNI_OnLoad_exception001(JavaVM *jvm, char *options, void *reserved) {\n-    return JNI_VERSION_1_8;\n-}\n-#endif\n-jint Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {\n-    jvmtiError err;\n-    jint res;\n-\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n-        printdump = JNI_TRUE;\n-    }\n-\n-    res = jvm->GetEnv((void **) &jvmti, JVMTI_VERSION_1_1);\n-    if (res != JNI_OK || jvmti == NULL) {\n-        printf(\"Wrong result of a valid call to GetEnv!\\n\");\n-        return JNI_ERR;\n-    }\n-\n-    err = jvmti->GetPotentialCapabilities(&caps);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(GetPotentialCapabilities) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        return JNI_ERR;\n-    }\n-\n-    err = jvmti->AddCapabilities(&caps);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(AddCapabilities) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        return JNI_ERR;\n-    }\n-\n-    err = jvmti->GetCapabilities(&caps);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(GetCapabilities) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        return JNI_ERR;\n-    }\n-\n-    if (caps.can_generate_exception_events) {\n-        callbacks.Exception = &Exception;\n-        err = jvmti->SetEventCallbacks(&callbacks, sizeof(callbacks));\n-        if (err != JVMTI_ERROR_NONE) {\n-            printf(\"(SetEventCallbacks) unexpected error: %s (%d)\\n\",\n-                   TranslateError(err), err);\n-            return JNI_ERR;\n-        }\n-    } else {\n-        printf(\"Warning: Exception event is not implemented\\n\");\n-    }\n-\n-    return JNI_OK;\n-}\n-\n-JNIEXPORT jint JNICALL\n-Java_nsk_jvmti_Exception_exception001_check(JNIEnv *env, jclass cls) {\n-    jvmtiError err;\n-    jthread thread;\n-    jclass clz;\n-    jmethodID mid;\n-\n-    if (jvmti == NULL) {\n-        printf(\"JVMTI client was not properly loaded!\\n\");\n-        return STATUS_FAILED;\n-    }\n-\n-    if (!caps.can_generate_exception_events) {\n-        return result;\n-    }\n-\n-    clz = env->FindClass(\"nsk\/jvmti\/Exception\/exception001c\");\n-    if (clz == NULL) {\n-        printf(\"Cannot find exception001c class!\\n\");\n-        return STATUS_FAILED;\n-    }\n-    clz = env->FindClass(\"nsk\/jvmti\/Exception\/exception001b\");\n-    if (clz == NULL) {\n-        printf(\"Cannot find exception001b class!\\n\");\n-        return STATUS_FAILED;\n-    }\n-    clz = env->FindClass(\"nsk\/jvmti\/Exception\/exception001a\");\n-    if (clz == NULL) {\n-        printf(\"Cannot find exception001a class!\\n\");\n-        return STATUS_FAILED;\n-    }\n-    mid = env->GetStaticMethodID(clz, \"run\", \"()V\");\n-    if (mid == NULL) {\n-        printf(\"Cannot find method run!\\n\");\n-        return STATUS_FAILED;\n-    }\n-\n-    err = jvmti->GetCurrentThread(&thread);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"Failed to get current thread: %s (%d)\\n\", TranslateError(err), err);\n-        result = STATUS_FAILED;\n-        return STATUS_FAILED;\n-    }\n-\n-    err = jvmti->SetEventNotificationMode(JVMTI_ENABLE,\n-            JVMTI_EVENT_EXCEPTION, thread);\n-    if (err == JVMTI_ERROR_NONE) {\n-        eventsExpected = sizeof(exs)\/sizeof(exceptionInfo);\n-    } else {\n-        printf(\"Failed to enable JVMTI_EVENT_EXCEPTION: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-    }\n-\n-    env->CallStaticVoidMethod(clz, mid);\n-\n-    err = jvmti->SetEventNotificationMode(JVMTI_DISABLE,\n-            JVMTI_EVENT_EXCEPTION, thread);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"Failed to disable JVMTI_EVENT_EXCEPTION: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-    }\n-\n-    if (eventsCount != eventsExpected) {\n-        printf(\"Wrong number of exception events: %d, expected: %d\\n\",\n-            eventsCount, eventsExpected);\n-        result = STATUS_FAILED;\n-    }\n-    return result;\n-}\n-\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/Exception\/exception001\/exception001.cpp","additions":0,"deletions":315,"binary":false,"changes":315,"status":"deleted"},{"patch":"@@ -1,156 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package nsk\/jvmti\/Exception;\n-\n-\/* Reassembled from the following Java pattern:\n- *\n- * public class exception001a {\n- *     public static void run() {\n- *         exception001b t = new exception001b();\n- *         try {\n- *             t.meth1();\n- *         } catch (Throwable e) {}\n- *         try {\n- *             t.meth2(0);\n- *         } catch (Throwable e) {}\n- *         try {\n- *             t.meth3(2);\n- *         } catch (Throwable e) {}\n- *     }\n- * }\n- *\n- * class exception001b {\n- *     public static void meth1() throws Throwable {\n- *         throw new exception001c();\n- *     }\n- *\n- *     public int meth2(int i) throws ArithmeticException {\n- *         return (10 \/ i);\n- *     }\n- *\n- *     public int meth3(int i) throws IndexOutOfBoundsException {\n- *         int arr[] = {1};\n- *         return arr[i];\n- *     }\n- * }\n- *\n- * class exception001c extends Throwable {\n- * }\n- *\n- *\/\n-\n-super public class exception001a {\n-\n-    public Method \"<init>\":\"()V\" stack 1 locals 1 {\n-        aload_0;\n-        invokespecial        Method java\/lang\/Object.\"<init>\":\"()V\";\n-        return;\n-    }\n-\n-    public static Method run:\"()V\" stack 2 locals 2 {\n-        new     class exception001b;\n-        dup;\n-        invokespecial Method exception001b.\"<init>\":\"()V\";\n-        astore_0;\n-    try t0;\n-        invokestatic Method exception001b.meth1:\"()V\";\n-    endtry t0;\n-        goto    L15;\n-    catch t0 java\/lang\/Throwable; \/\/ bci=14\n-        astore_1;\n-    try t1;\n-L15:    aload_0;\n-        iconst_0;\n-        invokevirtual Method exception001b.meth2:\"(I)I\";\n-        pop;\n-    endtry t1;\n-        goto    L25;\n-    catch t1 java\/lang\/Throwable; \/\/ bci=24\n-        astore_1;\n-    try t2;\n-L25:    aload_0;\n-        iconst_2;\n-        invokevirtual Method exception001b.meth3:\"(I)I\";\n-        pop;\n-    endtry t2;\n-        goto    L35;\n-    catch t2 java\/lang\/Throwable; \/\/ bci=34\n-        astore_1;\n-L35:    return;\n-    }\n-\n-}\n-\n-super class exception001b {\n-\n-    Method \"<init>\":\"()V\" stack 1 locals 1 {\n-        aload_0;\n-        invokespecial        Method java\/lang\/Object.\"<init>\":\"()V\";\n-        return;\n-    }\n-\n-    public static Method meth1:\"()V\"\n-    throws java\/lang\/Throwable\n-    stack 2 locals 0 {\n-        new     class exception001c;\n-        dup;\n-        invokespecial Method exception001c.\"<init>\":\"()V\";\n-        athrow; \/\/ bci=7\n-    }\n-\n-    public Method meth2:\"(I)I\"\n-    throws java\/lang\/ArithmeticException\n-    stack 2 locals 2 {\n-        bipush  10;\n-        iload_1;\n-        idiv;   \/\/ bci=3\n-        ireturn;\n-    }\n-\n-    public Method meth3:\"(I)I\"\n-    throws java\/lang\/IndexOutOfBoundsException\n-    stack 4 locals 3 {\n-        iconst_1;\n-        newarray int;\n-        dup;\n-        iconst_0;\n-        iconst_1;\n-        iastore;\n-        astore_2;\n-        aload_2;\n-        iload_1;\n-        iaload;  \/\/ bci=10\n-        ireturn;\n-    }\n-}\n-\n-super class exception001c extends java\/lang\/Throwable {\n-\n-    Method \"<init>\":\"()V\" stack 1 locals 1 {\n-        aload_0;\n-        invokespecial Method java\/lang\/Throwable.\"<init>\":\"()V\";\n-        return;\n-    }\n-\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/Exception\/exception001\/exception001a.jasm","additions":0,"deletions":156,"binary":false,"changes":156,"status":"deleted"},{"patch":"@@ -1,33 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include \"native_thread.cpp\"\n-#include \"nsk_tools.cpp\"\n-#include \"jni_tools.cpp\"\n-#include \"jvmti_tools.cpp\"\n-#include \"agent_tools.cpp\"\n-#include \"jvmti_FollowRefObjects.cpp\"\n-#include \"Injector.cpp\"\n-#include \"JVMTITools.cpp\"\n-#include \"agent_common.cpp\"\n-#include \"exception001.cpp\"\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/Exception\/exception001\/libexception001.cpp","additions":0,"deletions":33,"binary":false,"changes":33,"status":"deleted"},{"patch":"@@ -1,55 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package nsk.jvmti.ExceptionCatch;\n-\n-import java.io.PrintStream;\n-\n-public class excatch001 {\n-\n-    final static int JCK_STATUS_BASE = 95;\n-\n-    static {\n-        try {\n-            System.loadLibrary(\"excatch001\");\n-        } catch (UnsatisfiedLinkError ule) {\n-            System.err.println(\"Could not load excatch001 library\");\n-            System.err.println(\"java.library.path:\"\n-                + System.getProperty(\"java.library.path\"));\n-            throw ule;\n-        }\n-    }\n-\n-    native static int check();\n-\n-    public static void main(String args[]) {\n-        args = nsk.share.jvmti.JVMTITest.commonInit(args);\n-\n-        \/\/ produce JCK-like exit status.\n-        System.exit(run(args, System.out) + JCK_STATUS_BASE);\n-    }\n-\n-    public static int run(String args[], PrintStream out) {\n-        return check();\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/ExceptionCatch\/excatch001.java","additions":0,"deletions":55,"binary":false,"changes":55,"status":"deleted"},{"patch":"@@ -1,46 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/*\n- * @test\n- *\n- * @summary converted from VM Testbase nsk\/jvmti\/ExceptionCatch\/excatch001.\n- * VM Testbase keywords: [quick, jpda, jvmti, noras]\n- * VM Testbase readme:\n- * DESCRIPTION\n- *     The test exercise JVMTI event callback function ExceptionCatch.\n- *     The test checks if the parameters of the function contain the\n- *     expected values for the following exceptions thrown by Java methods:\n- *       - custom class exception001c extending Throwable\n- *       - ArithmeticException caused by division with zero devisor\n- *       - IndexOutOfBoundsException caused by using out of range array index\n- * COMMENTS\n- *     Ported from JVMDI.\n- *\n- * @library \/vmTestbase\n- *          \/test\/lib\n- * @compile excatch001a.jasm\n- * @run main\/othervm\/native -agentlib:excatch001 nsk.jvmti.ExceptionCatch.excatch001\n- *\/\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/ExceptionCatch\/excatch001\/TestDescription.java","additions":0,"deletions":46,"binary":false,"changes":46,"status":"deleted"},{"patch":"@@ -1,263 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include <stdio.h>\n-#include <string.h>\n-#include \"jvmti.h\"\n-#include \"agent_common.h\"\n-#include \"JVMTITools.h\"\n-\n-extern \"C\" {\n-\n-\n-#define PASSED 0\n-#define STATUS_FAILED 2\n-\n-typedef struct {\n-    char *name;\n-    char *c_cls;\n-    char *c_name;\n-    char *c_sig;\n-    jlocation c_loc;\n-} writable_exceptionInfo;\n-\n-typedef struct {\n-    const char *name;\n-    const char *c_cls;\n-    const char *c_name;\n-    const char *c_sig;\n-    jlocation c_loc;\n-} exceptionInfo;\n-\n-static jvmtiEnv *jvmti = NULL;\n-static jvmtiCapabilities caps;\n-static jvmtiEventCallbacks callbacks;\n-static jint result = PASSED;\n-static jboolean printdump = JNI_FALSE;\n-static exceptionInfo exs[] = {\n-  { \"Lnsk\/jvmti\/ExceptionCatch\/excatch001c;\",\n-    \"Lnsk\/jvmti\/ExceptionCatch\/excatch001a;\", \"run\", \"()V\", 14 },\n-  { \"Ljava\/lang\/ArithmeticException;\",\n-    \"Lnsk\/jvmti\/ExceptionCatch\/excatch001a;\", \"run\", \"()V\", 24 },\n-  { \"Ljava\/lang\/ArrayIndexOutOfBoundsException;\",\n-    \"Lnsk\/jvmti\/ExceptionCatch\/excatch001a;\", \"run\", \"()V\", 34 }\n-};\n-static int eventsCount = 0;\n-static int eventsExpected = 0;\n-\n-void JNICALL\n-ExceptionCatch(jvmtiEnv *jvmti_env, JNIEnv *env, jthread thr,\n-        jmethodID method, jlocation location, jobject exception) {\n-    jvmtiError err;\n-    jclass cls;\n-    writable_exceptionInfo ex;\n-    char *generic;\n-    size_t i;\n-\n-    if (printdump == JNI_TRUE) {\n-        printf(\">>> retrieving ExceptionCatch info ...\\n\");\n-    }\n-    cls = env->GetObjectClass(exception);\n-    err = jvmti_env->GetClassSignature(cls, &ex.name, &generic);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(GetClassSignature#e) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-        return;\n-    }\n-    err = jvmti_env->GetMethodDeclaringClass(method, &cls);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(GetMethodDeclaringClass) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-        return;\n-    }\n-    err = jvmti_env->GetClassSignature(cls, &ex.c_cls, &generic);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(GetClassSignature#c) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-        return;\n-    }\n-    err = jvmti_env->GetMethodName(method,\n-        &ex.c_name, &ex.c_sig, &generic);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(GetMethodName) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-        return;\n-    }\n-    ex.c_loc = location;\n-    if (printdump == JNI_TRUE) {\n-        printf(\">>> %s\\n\", ex.name);\n-        printf(\">>>    catch at %s.%s%s:0x%x%08x\\n\",\n-               ex.c_cls, ex.c_name, ex.c_sig,\n-               (jint)(ex.c_loc >> 32), (jint)ex.c_loc);\n-        printf(\">>> ... done\\n\");\n-    }\n-    for (i = 0; i < sizeof(exs)\/sizeof(exceptionInfo); i++) {\n-        if (ex.name != NULL && strcmp(ex.name, exs[i].name) == 0\n-         && ex.c_cls != NULL && strcmp(ex.c_cls, exs[i].c_cls) == 0\n-         && ex.c_name != NULL && strcmp(ex.c_name, exs[i].c_name) == 0\n-         && ex.c_sig != NULL && strcmp(ex.c_sig, exs[i].c_sig) == 0\n-         && ex.c_loc == exs[i].c_loc) {\n-            eventsCount++;\n-            break;\n-        }\n-    }\n-    if (i == sizeof(exs)\/sizeof(exceptionInfo)) {\n-        printf(\"Unexpected exception catch event:\\n\");\n-        printf(\"  %s\\n\", ex.name);\n-        printf(\"     catch at %s.%s%s:0x%x%08x\\n\",\n-               ex.c_cls, ex.c_name, ex.c_sig,\n-               (jint)(ex.c_loc >> 32), (jint)ex.c_loc);\n-        result = STATUS_FAILED;\n-    }\n-}\n-\n-#ifdef STATIC_BUILD\n-JNIEXPORT jint JNICALL Agent_OnLoad_excatch001(JavaVM *jvm, char *options, void *reserved) {\n-    return Agent_Initialize(jvm, options, reserved);\n-}\n-JNIEXPORT jint JNICALL Agent_OnAttach_excatch001(JavaVM *jvm, char *options, void *reserved) {\n-    return Agent_Initialize(jvm, options, reserved);\n-}\n-JNIEXPORT jint JNI_OnLoad_excatch001(JavaVM *jvm, char *options, void *reserved) {\n-    return JNI_VERSION_1_8;\n-}\n-#endif\n-jint Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {\n-    jvmtiError err;\n-    jint res;\n-\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n-        printdump = JNI_TRUE;\n-    }\n-\n-    res = jvm->GetEnv((void **) &jvmti, JVMTI_VERSION_1_1);\n-    if (res != JNI_OK || jvmti == NULL) {\n-        printf(\"Wrong result of a valid call to GetEnv!\\n\");\n-        return JNI_ERR;\n-    }\n-\n-    err = jvmti->GetPotentialCapabilities(&caps);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(GetPotentialCapabilities) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        return JNI_ERR;\n-    }\n-\n-    err = jvmti->AddCapabilities(&caps);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(AddCapabilities) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        return JNI_ERR;\n-    }\n-\n-    err = jvmti->GetCapabilities(&caps);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(GetCapabilities) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        return JNI_ERR;\n-    }\n-\n-    if (caps.can_generate_exception_events) {\n-        callbacks.ExceptionCatch = &ExceptionCatch;\n-        err = jvmti->SetEventCallbacks(&callbacks, sizeof(callbacks));\n-        if (err != JVMTI_ERROR_NONE) {\n-            printf(\"(SetEventCallbacks) unexpected error: %s (%d)\\n\",\n-                   TranslateError(err), err);\n-            return JNI_ERR;\n-        }\n-    } else {\n-        printf(\"Warning: Exception event is not implemented\\n\");\n-    }\n-\n-    return JNI_OK;\n-}\n-\n-JNIEXPORT jint JNICALL\n-Java_nsk_jvmti_ExceptionCatch_excatch001_check(JNIEnv *env, jclass cls) {\n-    jvmtiError err;\n-    jclass clz;\n-    jmethodID mid;\n-\n-    if (jvmti == NULL) {\n-        printf(\"JVMTI client was not properly loaded!\\n\");\n-        return STATUS_FAILED;\n-    }\n-\n-    if (!caps.can_generate_exception_events) {\n-        return result;\n-    }\n-\n-    clz = env->FindClass(\"nsk\/jvmti\/ExceptionCatch\/excatch001c\");\n-    if (clz == NULL) {\n-        printf(\"Cannot find excatch001c class!\\n\");\n-        return STATUS_FAILED;\n-    }\n-    clz = env->FindClass(\"nsk\/jvmti\/ExceptionCatch\/excatch001b\");\n-    if (clz == NULL) {\n-        printf(\"Cannot find excatch001b class!\\n\");\n-        return STATUS_FAILED;\n-    }\n-    clz = env->FindClass(\"nsk\/jvmti\/ExceptionCatch\/excatch001a\");\n-    if (clz == NULL) {\n-        printf(\"Cannot find excatch001a class!\\n\");\n-        return STATUS_FAILED;\n-    }\n-    mid = env->GetStaticMethodID(clz, \"run\", \"()V\");\n-    if (mid == NULL) {\n-        printf(\"Cannot find method run!\\n\");\n-        return STATUS_FAILED;\n-    }\n-\n-    err = jvmti->SetEventNotificationMode(JVMTI_ENABLE,\n-            JVMTI_EVENT_EXCEPTION_CATCH, NULL);\n-    if (err == JVMTI_ERROR_NONE) {\n-        eventsExpected = sizeof(exs)\/sizeof(exceptionInfo);\n-    } else {\n-        printf(\"Failed to enable JVMTI_EVENT_EXCEPTION_CATCH: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-    }\n-\n-    env->CallStaticVoidMethod(clz, mid);\n-\n-    err = jvmti->SetEventNotificationMode(JVMTI_DISABLE,\n-            JVMTI_EVENT_EXCEPTION_CATCH, NULL);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"Failed to disable JVMTI_EVENT_EXCEPTION_CATCH: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-    }\n-\n-    if (eventsCount != eventsExpected) {\n-        printf(\"Wrong number of exception catch events: %d, expected: %d\\n\",\n-            eventsCount, eventsExpected);\n-        result = STATUS_FAILED;\n-    }\n-    return result;\n-}\n-\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/ExceptionCatch\/excatch001\/excatch001.cpp","additions":0,"deletions":263,"binary":false,"changes":263,"status":"deleted"},{"patch":"@@ -1,156 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package nsk\/jvmti\/ExceptionCatch;\n-\n-\/* Reassembled from the following Java pattern:\n- *\n- * public class excatch001a {\n- *     public static void run() {\n- *         excatch001b t = new excatch001b();\n- *         try {\n- *             t.meth1();\n- *         } catch (Throwable e) {}\n- *         try {\n- *             t.meth2(0);\n- *         } catch (Throwable e) {}\n- *         try {\n- *             t.meth3(2);\n- *         } catch (Throwable e) {}\n- *     }\n- * }\n- *\n- * class excatch001b {\n- *     public static void meth1() throws Throwable {\n- *         throw new excatch001c();\n- *     }\n- *\n- *     public int meth2(int i) throws ArithmeticException {\n- *         return (10 \/ i);\n- *     }\n- *\n- *     public int meth3(int i) throws IndexOutOfBoundsException {\n- *         int arr[] = {1};\n- *         return arr[i];\n- *     }\n- * }\n- *\n- * class excatch001c extends Throwable {\n- * }\n- *\n- *\/\n-\n-super public class excatch001a {\n-\n-    public Method \"<init>\":\"()V\" stack 1 locals 1 {\n-        aload_0;\n-        invokespecial        Method java\/lang\/Object.\"<init>\":\"()V\";\n-        return;\n-    }\n-\n-    public static Method run:\"()V\" stack 2 locals 2 {\n-        new     class excatch001b;\n-        dup;\n-        invokespecial Method excatch001b.\"<init>\":\"()V\";\n-        astore_0;\n-    try t0;\n-        invokestatic Method excatch001b.meth1:\"()V\";\n-    endtry t0;\n-        goto    L15;\n-    catch t0 java\/lang\/Throwable; \/\/ bci=14\n-        astore_1;\n-    try t1;\n-L15:    aload_0;\n-        iconst_0;\n-        invokevirtual Method excatch001b.meth2:\"(I)I\";\n-        pop;\n-    endtry t1;\n-        goto    L25;\n-    catch t1 java\/lang\/Throwable; \/\/ bci=24\n-        astore_1;\n-    try t2;\n-L25:    aload_0;\n-        iconst_2;\n-        invokevirtual Method excatch001b.meth3:\"(I)I\";\n-        pop;\n-    endtry t2;\n-        goto    L35;\n-    catch t2 java\/lang\/Throwable; \/\/ bci=34\n-        astore_1;\n-L35:    return;\n-    }\n-\n-}\n-\n-super class excatch001b {\n-\n-    Method \"<init>\":\"()V\" stack 1 locals 1 {\n-        aload_0;\n-        invokespecial        Method java\/lang\/Object.\"<init>\":\"()V\";\n-        return;\n-    }\n-\n-    public static Method meth1:\"()V\"\n-    throws java\/lang\/Throwable\n-    stack 2 locals 0 {\n-        new     class excatch001c;\n-        dup;\n-        invokespecial Method excatch001c.\"<init>\":\"()V\";\n-        athrow; \/\/ bci=7\n-    }\n-\n-    public Method meth2:\"(I)I\"\n-    throws java\/lang\/ArithmeticException\n-    stack 2 locals 2 {\n-        bipush  10;\n-        iload_1;\n-        idiv;   \/\/ bci=3\n-        ireturn;\n-    }\n-\n-    public Method meth3:\"(I)I\"\n-    throws java\/lang\/IndexOutOfBoundsException\n-    stack 4 locals 3 {\n-        iconst_1;\n-        newarray int;\n-        dup;\n-        iconst_0;\n-        iconst_1;\n-        iastore;\n-        astore_2;\n-        aload_2;\n-        iload_1;\n-        iaload;  \/\/ bci=10\n-        ireturn;\n-    }\n-}\n-\n-super class excatch001c extends java\/lang\/Throwable {\n-\n-    Method \"<init>\":\"()V\" stack 1 locals 1 {\n-        aload_0;\n-        invokespecial Method java\/lang\/Throwable.\"<init>\":\"()V\";\n-        return;\n-    }\n-\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/ExceptionCatch\/excatch001\/excatch001a.jasm","additions":0,"deletions":156,"binary":false,"changes":156,"status":"deleted"},{"patch":"@@ -1,33 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include \"native_thread.cpp\"\n-#include \"nsk_tools.cpp\"\n-#include \"jni_tools.cpp\"\n-#include \"jvmti_tools.cpp\"\n-#include \"agent_tools.cpp\"\n-#include \"jvmti_FollowRefObjects.cpp\"\n-#include \"Injector.cpp\"\n-#include \"JVMTITools.cpp\"\n-#include \"agent_common.cpp\"\n-#include \"excatch001.cpp\"\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/ExceptionCatch\/excatch001\/libexcatch001.cpp","additions":0,"deletions":33,"binary":false,"changes":33,"status":"deleted"},{"patch":"@@ -1,59 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package nsk.jvmti.FieldAccess;\n-\n-import java.io.PrintStream;\n-\n-public class fieldacc001 {\n-\n-    final static int JCK_STATUS_BASE = 95;\n-\n-    static {\n-        try {\n-            System.loadLibrary(\"fieldacc001\");\n-        } catch (UnsatisfiedLinkError ule) {\n-            System.err.println(\"Could not load fieldacc001 library\");\n-            System.err.println(\"java.library.path:\"\n-                + System.getProperty(\"java.library.path\"));\n-            throw ule;\n-        }\n-    }\n-\n-    native static void getReady();\n-    native static int check();\n-\n-    public static void main(String args[]) {\n-        args = nsk.share.jvmti.JVMTITest.commonInit(args);\n-\n-        \/\/ produce JCK-like exit status.\n-        System.exit(run(args, System.out) + JCK_STATUS_BASE);\n-    }\n-\n-    public static int run(String args[], PrintStream out) {\n-        getReady();\n-        fieldacc001a t = new fieldacc001a();\n-        t.run();\n-        return check();\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/FieldAccess\/fieldacc001.java","additions":0,"deletions":59,"binary":false,"changes":59,"status":"deleted"},{"patch":"@@ -1,44 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/*\n- * @test\n- *\n- * @summary converted from VM Testbase nsk\/jvmti\/FieldAccess\/fieldacc001.\n- * VM Testbase keywords: [quick, jpda, jvmti, noras]\n- * VM Testbase readme:\n- * DESCRIPTION\n- *     The test exercise JVMTI event callback function FieldAccess.\n- *     The test checks if the parameters of the function contain the\n- *     expected values.\n- * COMMENTS\n- *     Fixed according to 4669812 bug.\n- *     Ported from JVMDI.\n- *\n- * @library \/vmTestbase\n- *          \/test\/lib\n- * @compile fieldacc001a.jasm\n- * @run main\/othervm\/native -agentlib:fieldacc001 nsk.jvmti.FieldAccess.fieldacc001\n- *\/\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/FieldAccess\/fieldacc001\/TestDescription.java","additions":0,"deletions":44,"binary":false,"changes":44,"status":"deleted"},{"patch":"@@ -1,360 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include <stdio.h>\n-#include <string.h>\n-#include <inttypes.h>\n-#include \"jvmti.h\"\n-#include \"agent_common.h\"\n-#include \"JVMTITools.h\"\n-\n-extern \"C\" {\n-\n-\n-#define PASSED 0\n-#define STATUS_FAILED 2\n-\n-typedef struct {\n-    jfieldID fid;\n-    char *m_cls;\n-    char *m_name;\n-    char *m_sig;\n-    jlocation loc;\n-    char *f_cls;\n-    char *f_name;\n-    char *f_sig;\n-    jboolean is_static;\n-} writable_watch_info;\n-\n-typedef struct {\n-    jfieldID fid;\n-    const char *m_cls;\n-    const char *m_name;\n-    const char *m_sig;\n-    jlocation loc;\n-    const char *f_cls;\n-    const char *f_name;\n-    const char *f_sig;\n-    jboolean is_static;\n-} watch_info;\n-\n-static jvmtiEnv *jvmti;\n-static jvmtiEventCallbacks callbacks;\n-static jvmtiCapabilities caps;\n-static jint result = PASSED;\n-static jboolean printdump = JNI_FALSE;\n-static int eventsExpected = 0;\n-static int eventsCount = 0;\n-static watch_info watches[] = {\n-    { NULL, \"Lnsk\/jvmti\/FieldAccess\/fieldacc001a;\", \"run\", \"()I\", 2,\n-      \"Lnsk\/jvmti\/FieldAccess\/fieldacc001a;\", \"staticBoolean\", \"Z\", JNI_TRUE },\n-    { NULL, \"Lnsk\/jvmti\/FieldAccess\/fieldacc001a;\", \"run\", \"()I\", 6,\n-      \"Lnsk\/jvmti\/FieldAccess\/fieldacc001a;\", \"instanceBoolean\", \"Z\", JNI_FALSE },\n-    { NULL, \"Lnsk\/jvmti\/FieldAccess\/fieldacc001a;\", \"run\", \"()I\", 15,\n-      \"Lnsk\/jvmti\/FieldAccess\/fieldacc001a;\", \"staticByte\", \"B\", JNI_TRUE },\n-    { NULL, \"Lnsk\/jvmti\/FieldAccess\/fieldacc001a;\", \"run\", \"()I\", 19,\n-      \"Lnsk\/jvmti\/FieldAccess\/fieldacc001a;\", \"instanceByte\", \"B\", JNI_FALSE },\n-    { NULL, \"Lnsk\/jvmti\/FieldAccess\/fieldacc001a;\", \"run\", \"()I\", 28,\n-      \"Lnsk\/jvmti\/FieldAccess\/fieldacc001a;\", \"staticShort\", \"S\", JNI_TRUE },\n-    { NULL, \"Lnsk\/jvmti\/FieldAccess\/fieldacc001a;\", \"run\", \"()I\", 32,\n-      \"Lnsk\/jvmti\/FieldAccess\/fieldacc001a;\", \"instanceShort\", \"S\", JNI_FALSE },\n-    { NULL, \"Lnsk\/jvmti\/FieldAccess\/fieldacc001a;\", \"run\", \"()I\", 41,\n-      \"Lnsk\/jvmti\/FieldAccess\/fieldacc001a;\", \"staticInt\", \"I\", JNI_TRUE },\n-    { NULL, \"Lnsk\/jvmti\/FieldAccess\/fieldacc001a;\", \"run\", \"()I\", 45,\n-      \"Lnsk\/jvmti\/FieldAccess\/fieldacc001a;\", \"instanceInt\", \"I\", JNI_FALSE },\n-    { NULL, \"Lnsk\/jvmti\/FieldAccess\/fieldacc001a;\", \"run\", \"()I\", 54,\n-      \"Lnsk\/jvmti\/FieldAccess\/fieldacc001a;\", \"staticLong\", \"J\", JNI_TRUE },\n-    { NULL, \"Lnsk\/jvmti\/FieldAccess\/fieldacc001a;\", \"run\", \"()I\", 58,\n-      \"Lnsk\/jvmti\/FieldAccess\/fieldacc001a;\", \"instanceLong\", \"J\", JNI_FALSE },\n-    { NULL, \"Lnsk\/jvmti\/FieldAccess\/fieldacc001a;\", \"run\", \"()I\", 68,\n-      \"Lnsk\/jvmti\/FieldAccess\/fieldacc001a;\", \"staticFloat\", \"F\", JNI_TRUE },\n-    { NULL, \"Lnsk\/jvmti\/FieldAccess\/fieldacc001a;\", \"run\", \"()I\", 72,\n-      \"Lnsk\/jvmti\/FieldAccess\/fieldacc001a;\", \"instanceFloat\", \"F\", JNI_FALSE },\n-    { NULL, \"Lnsk\/jvmti\/FieldAccess\/fieldacc001a;\", \"run\", \"()I\", 82,\n-      \"Lnsk\/jvmti\/FieldAccess\/fieldacc001a;\", \"staticDouble\", \"D\", JNI_TRUE },\n-    { NULL, \"Lnsk\/jvmti\/FieldAccess\/fieldacc001a;\", \"run\", \"()I\", 86,\n-      \"Lnsk\/jvmti\/FieldAccess\/fieldacc001a;\", \"instanceDouble\", \"D\", JNI_FALSE },\n-    { NULL, \"Lnsk\/jvmti\/FieldAccess\/fieldacc001a;\", \"run\", \"()I\", 96,\n-      \"Lnsk\/jvmti\/FieldAccess\/fieldacc001a;\", \"staticChar\", \"C\", JNI_TRUE },\n-    { NULL, \"Lnsk\/jvmti\/FieldAccess\/fieldacc001a;\", \"run\", \"()I\", 100,\n-      \"Lnsk\/jvmti\/FieldAccess\/fieldacc001a;\", \"instanceChar\", \"C\", JNI_FALSE },\n-    { NULL, \"Lnsk\/jvmti\/FieldAccess\/fieldacc001a;\", \"run\", \"()I\", 109,\n-      \"Lnsk\/jvmti\/FieldAccess\/fieldacc001a;\", \"staticObject\", \"Ljava\/lang\/Object;\", JNI_TRUE },\n-    { NULL, \"Lnsk\/jvmti\/FieldAccess\/fieldacc001a;\", \"run\", \"()I\", 113,\n-      \"Lnsk\/jvmti\/FieldAccess\/fieldacc001a;\", \"instanceObject\", \"Ljava\/lang\/Object;\", JNI_FALSE },\n-    { NULL, \"Lnsk\/jvmti\/FieldAccess\/fieldacc001a;\", \"run\", \"()I\", 122,\n-      \"Lnsk\/jvmti\/FieldAccess\/fieldacc001a;\", \"staticArrInt\", \"[I\", JNI_TRUE },\n-    { NULL, \"Lnsk\/jvmti\/FieldAccess\/fieldacc001a;\", \"run\", \"()I\", 128,\n-      \"Lnsk\/jvmti\/FieldAccess\/fieldacc001a;\", \"instanceArrInt\", \"[I\", JNI_FALSE }\n-};\n-\n-\n-void JNICALL FieldAccess(jvmtiEnv *jvmti_env, JNIEnv *env,\n-        jthread thr, jmethodID method,\n-        jlocation location, jclass field_klass, jobject obj, jfieldID field) {\n-    jvmtiError err;\n-    jclass cls;\n-    writable_watch_info watch;\n-    char *generic;\n-    size_t i;\n-\n-    eventsCount++;\n-    if (printdump == JNI_TRUE) {\n-        printf(\">>> retrieving access watch info ...\\n\");\n-    }\n-    watch.fid = field;\n-    watch.loc = location;\n-    watch.is_static = (obj == NULL) ? JNI_TRUE : JNI_FALSE;\n-    err = jvmti_env->GetMethodDeclaringClass(method, &cls);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(GetMethodDeclaringClass) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-        return;\n-    }\n-    err = jvmti_env->GetClassSignature(cls,\n-        &watch.m_cls, &generic);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(GetClassSignature) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-        return;\n-    }\n-    err = jvmti_env->GetMethodName(method,\n-        &watch.m_name, &watch.m_sig, &generic);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(GetMethodName) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-        return;\n-    }\n-    err = jvmti_env->GetClassSignature(field_klass,\n-        &watch.f_cls, &generic);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(GetClassSignature) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-        return;\n-    }\n-    err = jvmti_env->GetFieldName(field_klass, field,\n-        &watch.f_name, &watch.f_sig, &generic);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(GetFieldName) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-        return;\n-    }\n-    if (printdump == JNI_TRUE) {\n-        printf(\">>>      class: \\\"%s\\\"\\n\", watch.m_cls);\n-        printf(\">>>     method: \\\"%s%s\\\"\\n\", watch.m_name, watch.m_sig);\n-        printf(\">>>   location: 0x%x%08x\\n\",\n-            (jint)(watch.loc >> 32), (jint)watch.loc);\n-        printf(\">>>  field cls: \\\"%s\\\"\\n\", watch.f_cls);\n-        printf(\">>>      field: \\\"%s:%s\\\"\\n\", watch.f_name, watch.f_sig);\n-        printf(\">>>     object: 0x%p\\n\", obj);\n-        printf(\">>> ... done\\n\");\n-    }\n-    for (i = 0; i < sizeof(watches)\/sizeof(watch_info); i++) {\n-        if (watch.fid == watches[i].fid) {\n-            if (watch.m_cls == NULL ||\n-                    strcmp(watch.m_cls, watches[i].m_cls) != 0) {\n-                printf(\"(watch#%\" PRIuPTR \") wrong class: \\\"%s\\\", expected: \\\"%s\\\"\\n\",\n-                       i, watch.m_cls, watches[i].m_cls);\n-                result = STATUS_FAILED;\n-            }\n-            if (watch.m_name == NULL ||\n-                    strcmp(watch.m_name, watches[i].m_name) != 0) {\n-                printf(\"(watch#%\" PRIuPTR \") wrong method name: \\\"%s\\\"\",\n-                       i, watch.m_name);\n-                printf(\", expected: \\\"%s\\\"\\n\", watches[i].m_name);\n-                result = STATUS_FAILED;\n-            }\n-            if (watch.m_sig == NULL ||\n-                    strcmp(watch.m_sig, watches[i].m_sig) != 0) {\n-                printf(\"(watch#%\" PRIuPTR \") wrong method sig: \\\"%s\\\"\",\n-                       i, watch.m_sig);\n-                printf(\", expected: \\\"%s\\\"\\n\", watches[i].m_sig);\n-                result = STATUS_FAILED;\n-            }\n-            if (watch.loc != watches[i].loc) {\n-                printf(\"(watch#%\" PRIuPTR \") wrong location: 0x%x%08x\",\n-                       i, (jint)(watch.loc >> 32), (jint)watch.loc);\n-                printf(\", expected: 0x%x%08x\\n\",\n-                       (jint)(watches[i].loc >> 32), (jint)watches[i].loc);\n-                result = STATUS_FAILED;\n-            }\n-            if (watch.f_name == NULL ||\n-                    strcmp(watch.f_name, watches[i].f_name) != 0) {\n-                printf(\"(watch#%\" PRIuPTR \") wrong field name: \\\"%s\\\"\",\n-                       i, watch.f_name);\n-                printf(\", expected: \\\"%s\\\"\\n\", watches[i].f_name);\n-                result = STATUS_FAILED;\n-            }\n-            if (watch.f_sig == NULL ||\n-                    strcmp(watch.f_sig, watches[i].f_sig) != 0) {\n-                printf(\"(watch#%\" PRIuPTR \") wrong field sig: \\\"%s\\\"\",\n-                       i, watch.f_sig);\n-                printf(\", expected: \\\"%s\\\"\\n\", watches[i].f_sig);\n-                result = STATUS_FAILED;\n-            }\n-            if (watch.is_static != watches[i].is_static) {\n-                printf(\"(watch#%\" PRIuPTR \") wrong field type: %s\", i,\n-                    (watch.is_static == JNI_TRUE) ? \"static\" : \"instance\");\n-                printf(\", expected: %s\\n\",\n-                    (watches[i].is_static == JNI_TRUE) ? \"static\" : \"instance\");\n-                result = STATUS_FAILED;\n-            }\n-            return;\n-        }\n-    }\n-    printf(\"Unexpected field access catched: 0x%p\\n\", watch.fid);\n-    result = STATUS_FAILED;\n-}\n-\n-#ifdef STATIC_BUILD\n-JNIEXPORT jint JNICALL Agent_OnLoad_fieldacc001(JavaVM *jvm, char *options, void *reserved) {\n-    return Agent_Initialize(jvm, options, reserved);\n-}\n-JNIEXPORT jint JNICALL Agent_OnAttach_fieldacc001(JavaVM *jvm, char *options, void *reserved) {\n-    return Agent_Initialize(jvm, options, reserved);\n-}\n-JNIEXPORT jint JNI_OnLoad_fieldacc001(JavaVM *jvm, char *options, void *reserved) {\n-    return JNI_VERSION_1_8;\n-}\n-#endif\n-jint Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {\n-    jvmtiError err;\n-    jint res;\n-\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n-        printdump = JNI_TRUE;\n-    }\n-\n-    res = jvm->GetEnv((void **) &jvmti, JVMTI_VERSION_1_1);\n-    if (res != JNI_OK || jvmti == NULL) {\n-        printf(\"Wrong result of a valid call to GetEnv!\\n\");\n-        return JNI_ERR;\n-    }\n-\n-    err = jvmti->GetPotentialCapabilities(&caps);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(GetPotentialCapabilities) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        return JNI_ERR;\n-    }\n-\n-    err = jvmti->AddCapabilities(&caps);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(AddCapabilities) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        return JNI_ERR;\n-    }\n-\n-    err = jvmti->GetCapabilities(&caps);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(GetCapabilities) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        return JNI_ERR;\n-    }\n-\n-    if (caps.can_generate_field_access_events) {\n-        callbacks.FieldAccess = &FieldAccess;\n-        err = jvmti->SetEventCallbacks(&callbacks, sizeof(callbacks));\n-        if (err != JVMTI_ERROR_NONE) {\n-            printf(\"(SetEventCallbacks) unexpected error: %s (%d)\\n\",\n-                   TranslateError(err), err);\n-            return JNI_ERR;\n-        }\n-\n-        err = jvmti->SetEventNotificationMode(JVMTI_ENABLE,\n-                JVMTI_EVENT_FIELD_ACCESS, NULL);\n-        if (err != JVMTI_ERROR_NONE) {\n-            printf(\"Failed to enable JVMTI_EVENT_FIELD_ACCESS: %s (%d)\\n\",\n-                   TranslateError(err), err);\n-            return JNI_ERR;\n-        }\n-    } else {\n-        printf(\"Warning: FieldAccess watch is not implemented\\n\");\n-    }\n-\n-    return JNI_OK;\n-}\n-\n-\n-JNIEXPORT void JNICALL\n-Java_nsk_jvmti_FieldAccess_fieldacc001_getReady(JNIEnv *env, jclass klass) {\n-    jvmtiError err;\n-    jclass cls;\n-    size_t i;\n-\n-    if (!caps.can_generate_field_access_events) {\n-        return;\n-    }\n-\n-    if (printdump == JNI_TRUE) {\n-        printf(\">>> setting field access watches ...\\n\");\n-    }\n-    cls = env->FindClass(\"nsk\/jvmti\/FieldAccess\/fieldacc001a\");\n-    if (cls == NULL) {\n-        printf(\"Cannot find fieldacc001a class!\\n\");\n-        result = STATUS_FAILED;\n-        return;\n-    }\n-    for (i = 0; i < sizeof(watches)\/sizeof(watch_info); i++) {\n-        if (watches[i].is_static == JNI_TRUE) {\n-            watches[i].fid = env->GetStaticFieldID(\n-                cls, watches[i].f_name, watches[i].f_sig);\n-        } else {\n-            watches[i].fid = env->GetFieldID(\n-                cls, watches[i].f_name, watches[i].f_sig);\n-        }\n-        if (watches[i].fid == NULL) {\n-            printf(\"Cannot find field \\\"%s\\\"!\\n\", watches[i].f_name);\n-            result = STATUS_FAILED;\n-            return;\n-        }\n-        err = jvmti->SetFieldAccessWatch(cls, watches[i].fid);\n-        if (err == JVMTI_ERROR_NONE) {\n-            eventsExpected++;\n-        } else {\n-            printf(\"(SetFieldAccessWatch#%\" PRIuPTR \") unexpected error: %s (%d)\\n\",\n-                   i, TranslateError(err), err);\n-            result = STATUS_FAILED;\n-        }\n-    }\n-    if (printdump == JNI_TRUE) {\n-        printf(\">>> ... done\\n\");\n-    }\n-}\n-\n-JNIEXPORT jint JNICALL\n-Java_nsk_jvmti_FieldAccess_fieldacc001_check(JNIEnv *env, jclass cls) {\n-    if (eventsCount != eventsExpected) {\n-        printf(\"Wrong number of field access events: %d, expected: %d\\n\",\n-            eventsCount, eventsExpected);\n-        result = STATUS_FAILED;\n-    }\n-    return result;\n-}\n-\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/FieldAccess\/fieldacc001\/fieldacc001.cpp","additions":0,"deletions":360,"binary":false,"changes":360,"status":"deleted"},{"patch":"@@ -1,193 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package nsk\/jvmti\/FieldAccess;\n-\n-super public class fieldacc001a {\n-\n-    static Field staticBoolean:Z;\n-    static Field staticByte:B;\n-    static Field staticShort:S;\n-    static Field staticInt:I;\n-    static Field staticLong:J;\n-    static Field staticFloat:F;\n-    static Field staticDouble:D;\n-    static Field staticChar:C;\n-    static Field staticObject:\"Ljava\/lang\/Object;\";\n-    static Field staticArrInt:\"[I\";\n-    Field instanceBoolean:Z;\n-    Field instanceByte:B;\n-    Field instanceShort:S;\n-    Field instanceInt:I;\n-    Field instanceLong:J;\n-    Field instanceFloat:F;\n-    Field instanceDouble:D;\n-    Field instanceChar:C;\n-    Field instanceObject:\"Ljava\/lang\/Object;\";\n-    Field instanceArrInt:\"[I\";\n-\n-    public Method \"<init>\":\"()V\" stack 5 locals 1 {\n-        aload_0;\n-        invokespecial Method java\/lang\/Object.\"<init>\":\"()V\";\n-        aload_0;\n-        iconst_0;\n-        putfield    Field instanceBoolean:\"Z\";\n-        aload_0;\n-        bipush      10;\n-        putfield    Field instanceByte:\"B\";\n-        aload_0;\n-        bipush      20;\n-        putfield    Field instanceShort:\"S\";\n-        aload_0;\n-        bipush      30;\n-        putfield    Field instanceInt:\"I\";\n-        aload_0;\n-        ldc2_w      long 40l;\n-        putfield    Field instanceLong:\"J\";\n-        aload_0;\n-        ldc         float 0.05f;\n-        putfield    Field instanceFloat:\"F\";\n-        aload_0;\n-        ldc2_w      double 0.06d;\n-        putfield    Field instanceDouble:\"D\";\n-        aload_0;\n-        bipush      122;\n-        putfield    Field instanceChar:\"C\";\n-        aload_0;\n-        new class java\/lang\/Object;\n-        dup;\n-        invokespecial Method java\/lang\/Object.\"<init>\":\"()V\";\n-        putfield    Field instanceObject:\"Ljava\/lang\/Object;\";\n-        aload_0;\n-        iconst_2;\n-        newarray    int;\n-        dup;\n-        iconst_0;\n-        bipush      70;\n-        iastore;\n-        dup;\n-        iconst_1;\n-        bipush      80;\n-        iastore;\n-        putfield    Field instanceArrInt:\"[I\";\n-        return;\n-    }\n-\n-    public Method run:\"()I\" stack 4 locals 2 {\n-        iconst_0;\n-        istore_1;\n-        getstatic   Field staticBoolean:\"Z\";    \/\/ bci=2\n-        aload_0;\n-        getfield    Field instanceBoolean:\"Z\";  \/\/ bci=6\n-        if_icmpne   L15;\n-        iinc        1, 1;\n-L15:    getstatic   Field staticByte:\"B\";       \/\/ bci=15\n-        aload_0;\n-        getfield    Field instanceByte:\"B\";     \/\/ bci=19\n-        if_icmpne   L28;\n-        iinc        1, 1;\n-L28:    getstatic   Field staticShort:\"S\";      \/\/ bci=28\n-        aload_0;\n-        getfield    Field instanceShort:\"S\";    \/\/ bci=32\n-        if_icmpne   L41;\n-        iinc        1, 1;\n-L41:    getstatic   Field staticInt:\"I\";        \/\/ bci=41\n-        aload_0;\n-        getfield    Field instanceInt:\"I\";      \/\/ bci=45\n-        if_icmpne   L54;\n-        iinc        1, 1;\n-L54:    getstatic   Field staticLong:\"J\";       \/\/ bci=54\n-        aload_0;\n-        getfield    Field instanceLong:\"J\";     \/\/ bci=58\n-        lcmp;\n-        ifne        L68;\n-        iinc        1, 1;\n-L68:    getstatic   Field staticFloat:\"F\";      \/\/ bci=68\n-        aload_0;\n-        getfield    Field instanceFloat:\"F\";    \/\/ bci=72\n-        fcmpl;\n-        ifne        L82;\n-        iinc        1, 1;\n-L82:    getstatic   Field staticDouble:\"D\";     \/\/ bci=82\n-        aload_0;\n-        getfield    Field instanceDouble:\"D\";   \/\/ bci=86\n-        dcmpl;\n-        ifne    L96;\n-        iinc        1, 1;\n-L96:    getstatic   Field staticChar:\"C\";       \/\/ bci=96\n-        aload_0;\n-        getfield    Field instanceChar:\"C\";     \/\/ bci=100\n-        if_icmpne   L109;\n-        iinc        1, 1;\n-L109:   getstatic   Field staticObject:\"Ljava\/lang\/Object;\"; \/\/ bci=109\n-        aload_0;\n-        getfield    Field instanceObject:\"Ljava\/lang\/Object;\"; \/\/ bci=113\n-        if_acmpne   L122;\n-        iinc        1, 1;\n-L122:   getstatic   Field staticArrInt:\"[I\";    \/\/ bci=122\n-        iconst_0;\n-        iaload;\n-        aload_0;\n-        getfield    Field instanceArrInt:\"[I\";  \/\/ bci=128\n-        iconst_1;\n-        iaload;\n-        if_icmpne   L139;\n-        iinc        1, 1;\n-L139:   iload_1;\n-        ireturn;\n-    }\n-\n-    static Method \"<clinit>\":\"()V\" stack 4 locals 0 {\n-        iconst_1;\n-        putstatic   Field staticBoolean:\"Z\";\n-        iconst_1;\n-        putstatic   Field staticByte:\"B\";\n-        iconst_2;\n-        putstatic   Field staticShort:\"S\";\n-        iconst_3;\n-        putstatic   Field staticInt:\"I\";\n-        ldc2_w      long 4l;\n-        putstatic   Field staticLong:\"J\";\n-        ldc         float 0.5f;\n-        putstatic   Field staticFloat:\"F\";\n-        ldc2_w      double 0.6d;\n-        putstatic   Field staticDouble:\"D\";\n-        bipush      97;\n-        putstatic   Field staticChar:\"C\";\n-        aconst_null;\n-        putstatic   Field staticObject:\"Ljava\/lang\/Object;\";\n-        iconst_2;\n-        newarray    int;\n-        dup;\n-        iconst_0;\n-        bipush      7;\n-        iastore;\n-        dup;\n-        iconst_1;\n-        bipush      8;\n-        iastore;\n-        putstatic   Field staticArrInt:\"[I\";\n-        return;\n-    }\n-\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/FieldAccess\/fieldacc001\/fieldacc001a.jasm","additions":0,"deletions":193,"binary":false,"changes":193,"status":"deleted"},{"patch":"@@ -1,33 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include \"native_thread.cpp\"\n-#include \"nsk_tools.cpp\"\n-#include \"jni_tools.cpp\"\n-#include \"jvmti_tools.cpp\"\n-#include \"agent_tools.cpp\"\n-#include \"jvmti_FollowRefObjects.cpp\"\n-#include \"Injector.cpp\"\n-#include \"JVMTITools.cpp\"\n-#include \"agent_common.cpp\"\n-#include \"fieldacc001.cpp\"\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/FieldAccess\/fieldacc001\/libfieldacc001.cpp","additions":0,"deletions":33,"binary":false,"changes":33,"status":"deleted"},{"patch":"@@ -1,82 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package nsk.jvmti.FieldAccess;\n-\n-import java.io.PrintStream;\n-\n-public class fieldacc002 {\n-\n-    final static int JCK_STATUS_BASE = 95;\n-\n-    static {\n-        try {\n-            System.loadLibrary(\"fieldacc002\");\n-        } catch (UnsatisfiedLinkError ule) {\n-            System.err.println(\"Could not load fieldacc002 library\");\n-            System.err.println(\"java.library.path:\"\n-                + System.getProperty(\"java.library.path\"));\n-            throw ule;\n-        }\n-    }\n-\n-    native static void getReady();\n-    native static int check(Object obj);\n-\n-    public static void main(String args[]) {\n-        args = nsk.share.jvmti.JVMTITest.commonInit(args);\n-\n-        \/\/ produce JCK-like exit status.\n-        System.exit(run(args, System.out) + JCK_STATUS_BASE);\n-    }\n-\n-    public static int run(String args[], PrintStream out) {\n-        fieldacc002a t = new fieldacc002a();\n-        getReady();\n-        return check(t);\n-    }\n-}\n-\n-class fieldacc002a {\n-    static boolean staticBoolean = true;\n-    static byte staticByte = 1;\n-    static short staticShort = 2;\n-    static int staticInt = 3;\n-    static long staticLong = 4;\n-    static float staticFloat = 0.5F;\n-    static double staticDouble = 0.6;\n-    static char staticChar = '\\u0007';\n-    static Object staticObject = new Object();\n-    static int staticArrInt[] = {8};\n-\n-    boolean instanceBoolean = false;\n-    byte instanceByte = 10;\n-    short instanceShort = 20;\n-    int instanceInt = 30;\n-    long instanceLong = 40;\n-    float instanceFloat = 0.05F;\n-    double instanceDouble = 0.06;\n-    char instanceChar = '\\u0070';\n-    Object instanceObject = new Object();\n-    int instanceArrInt[] = {80};\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/FieldAccess\/fieldacc002.java","additions":0,"deletions":82,"binary":false,"changes":82,"status":"deleted"},{"patch":"@@ -1,43 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/*\n- * @test\n- *\n- * @summary converted from VM Testbase nsk\/jvmti\/FieldAccess\/fieldacc002.\n- * VM Testbase keywords: [quick, jpda, jvmti, noras]\n- * VM Testbase readme:\n- * DESCRIPTION\n- *     The test exercise JVMTI event callback function FieldAccess.\n- *     The test checks if the parameters of the function contain the\n- *     expected values for fields accessed from JNI code.\n- * COMMENTS\n- *     Fixed according to 4669812 bug.\n- *     Ported from JVMDI.\n- *\n- * @library \/vmTestbase\n- *          \/test\/lib\n- * @run main\/othervm\/native -agentlib:fieldacc002 nsk.jvmti.FieldAccess.fieldacc002\n- *\/\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/FieldAccess\/fieldacc002\/TestDescription.java","additions":0,"deletions":43,"binary":false,"changes":43,"status":"deleted"},{"patch":"@@ -1,401 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include <stdio.h>\n-#include <string.h>\n-#include <inttypes.h>\n-#include \"jvmti.h\"\n-#include \"agent_common.h\"\n-#include \"JVMTITools.h\"\n-\n-extern \"C\" {\n-\n-\n-#define PASSED 0\n-#define STATUS_FAILED 2\n-\n-typedef struct {\n-    jfieldID fid;\n-    char *m_cls;\n-    char *m_name;\n-    char *m_sig;\n-    jlocation loc;\n-    char *f_cls;\n-    char *f_name;\n-    char *f_sig;\n-    jboolean is_static;\n-} writable_watch_info;\n-\n-typedef struct {\n-    jfieldID fid;\n-    const char *m_cls;\n-    const char *m_name;\n-    const char *m_sig;\n-    jlocation loc;\n-    const char *f_cls;\n-    const char *f_name;\n-    const char *f_sig;\n-    jboolean is_static;\n-} watch_info;\n-\n-static jvmtiEnv *jvmti;\n-static jvmtiEventCallbacks callbacks;\n-static jvmtiCapabilities caps;\n-static jint result = PASSED;\n-static jboolean printdump = JNI_FALSE;\n-static int eventsExpected = 0;\n-static int eventsCount = 0;\n-static watch_info watches[] = {\n-    { NULL, \"Lnsk\/jvmti\/FieldAccess\/fieldacc002;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n-      \"Lnsk\/jvmti\/FieldAccess\/fieldacc002a;\", \"staticBoolean\", \"Z\", JNI_TRUE },\n-    { NULL, \"Lnsk\/jvmti\/FieldAccess\/fieldacc002;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n-      \"Lnsk\/jvmti\/FieldAccess\/fieldacc002a;\", \"staticByte\", \"B\", JNI_TRUE },\n-    { NULL, \"Lnsk\/jvmti\/FieldAccess\/fieldacc002;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n-      \"Lnsk\/jvmti\/FieldAccess\/fieldacc002a;\", \"staticShort\", \"S\", JNI_TRUE },\n-    { NULL, \"Lnsk\/jvmti\/FieldAccess\/fieldacc002;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n-      \"Lnsk\/jvmti\/FieldAccess\/fieldacc002a;\", \"staticInt\", \"I\", JNI_TRUE },\n-    { NULL, \"Lnsk\/jvmti\/FieldAccess\/fieldacc002;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n-      \"Lnsk\/jvmti\/FieldAccess\/fieldacc002a;\", \"staticLong\", \"J\", JNI_TRUE },\n-    { NULL, \"Lnsk\/jvmti\/FieldAccess\/fieldacc002;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n-      \"Lnsk\/jvmti\/FieldAccess\/fieldacc002a;\", \"staticFloat\", \"F\", JNI_TRUE },\n-    { NULL, \"Lnsk\/jvmti\/FieldAccess\/fieldacc002;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n-      \"Lnsk\/jvmti\/FieldAccess\/fieldacc002a;\", \"staticDouble\", \"D\", JNI_TRUE },\n-    { NULL, \"Lnsk\/jvmti\/FieldAccess\/fieldacc002;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n-      \"Lnsk\/jvmti\/FieldAccess\/fieldacc002a;\", \"staticChar\", \"C\", JNI_TRUE },\n-    { NULL, \"Lnsk\/jvmti\/FieldAccess\/fieldacc002;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n-      \"Lnsk\/jvmti\/FieldAccess\/fieldacc002a;\", \"staticObject\", \"Ljava\/lang\/Object;\", JNI_TRUE },\n-    { NULL, \"Lnsk\/jvmti\/FieldAccess\/fieldacc002;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n-      \"Lnsk\/jvmti\/FieldAccess\/fieldacc002a;\", \"staticArrInt\", \"[I\", JNI_TRUE },\n-\n-    { NULL, \"Lnsk\/jvmti\/FieldAccess\/fieldacc002;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n-      \"Lnsk\/jvmti\/FieldAccess\/fieldacc002a;\", \"instanceBoolean\", \"Z\", JNI_FALSE },\n-    { NULL, \"Lnsk\/jvmti\/FieldAccess\/fieldacc002;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n-      \"Lnsk\/jvmti\/FieldAccess\/fieldacc002a;\", \"instanceByte\", \"B\", JNI_FALSE },\n-    { NULL, \"Lnsk\/jvmti\/FieldAccess\/fieldacc002;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n-      \"Lnsk\/jvmti\/FieldAccess\/fieldacc002a;\", \"instanceShort\", \"S\", JNI_FALSE },\n-    { NULL, \"Lnsk\/jvmti\/FieldAccess\/fieldacc002;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n-      \"Lnsk\/jvmti\/FieldAccess\/fieldacc002a;\", \"instanceInt\", \"I\", JNI_FALSE },\n-    { NULL, \"Lnsk\/jvmti\/FieldAccess\/fieldacc002;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n-      \"Lnsk\/jvmti\/FieldAccess\/fieldacc002a;\", \"instanceLong\", \"J\", JNI_FALSE },\n-    { NULL, \"Lnsk\/jvmti\/FieldAccess\/fieldacc002;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n-      \"Lnsk\/jvmti\/FieldAccess\/fieldacc002a;\", \"instanceFloat\", \"F\", JNI_FALSE },\n-    { NULL, \"Lnsk\/jvmti\/FieldAccess\/fieldacc002;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n-      \"Lnsk\/jvmti\/FieldAccess\/fieldacc002a;\", \"instanceDouble\", \"D\", JNI_FALSE },\n-    { NULL, \"Lnsk\/jvmti\/FieldAccess\/fieldacc002;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n-      \"Lnsk\/jvmti\/FieldAccess\/fieldacc002a;\", \"instanceChar\", \"C\", JNI_FALSE },\n-    { NULL, \"Lnsk\/jvmti\/FieldAccess\/fieldacc002;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n-      \"Lnsk\/jvmti\/FieldAccess\/fieldacc002a;\", \"instanceObject\", \"Ljava\/lang\/Object;\", JNI_FALSE },\n-    { NULL, \"Lnsk\/jvmti\/FieldAccess\/fieldacc002;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n-      \"Lnsk\/jvmti\/FieldAccess\/fieldacc002a;\", \"instanceArrInt\", \"[I\", JNI_FALSE }\n-};\n-\n-void JNICALL FieldAccess(jvmtiEnv *jvmti_env, JNIEnv *env,\n-        jthread thr, jmethodID method,\n-        jlocation location, jclass field_klass, jobject obj, jfieldID field) {\n-    jvmtiError err;\n-    jclass cls;\n-    writable_watch_info watch;\n-    char *generic;\n-    size_t i;\n-\n-    eventsCount++;\n-    if (printdump == JNI_TRUE) {\n-        printf(\">>> retrieving access watch info ...\\n\");\n-    }\n-    watch.fid = field;\n-    watch.loc = location;\n-    watch.is_static = (obj == NULL) ? JNI_TRUE : JNI_FALSE;\n-    err = jvmti_env->GetMethodDeclaringClass(method, &cls);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(GetMethodDeclaringClass) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-        return;\n-    }\n-    err = jvmti_env->GetClassSignature(cls,\n-        &watch.m_cls, &generic);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(GetClassSignature) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-        return;\n-    }\n-    err = jvmti_env->GetMethodName(method,\n-        &watch.m_name, &watch.m_sig, &generic);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(GetMethodName) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-        return;\n-    }\n-    err = jvmti_env->GetClassSignature(field_klass,\n-        &watch.f_cls, &generic);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(GetClassSignature) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-        return;\n-    }\n-    err = jvmti_env->GetFieldName(field_klass, field,\n-        &watch.f_name, &watch.f_sig, &generic);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(GetFieldName) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-        return;\n-    }\n-    if (printdump == JNI_TRUE) {\n-        printf(\">>>      class: \\\"%s\\\"\\n\", watch.m_cls);\n-        printf(\">>>     method: \\\"%s%s\\\"\\n\", watch.m_name, watch.m_sig);\n-        printf(\">>>   location: 0x%x%08x\\n\",\n-            (jint)(watch.loc >> 32), (jint)watch.loc);\n-        printf(\">>>  field cls: \\\"%s\\\"\\n\", watch.f_cls);\n-        printf(\">>>      field: \\\"%s:%s\\\"\\n\", watch.f_name, watch.f_sig);\n-        printf(\">>>     object: 0x%p\\n\", obj);\n-    }\n-    for (i = 0; i < sizeof(watches)\/sizeof(watch_info); i++) {\n-        if (watch.fid == watches[i].fid) {\n-            if (watch.m_cls == NULL ||\n-                    strcmp(watch.m_cls, watches[i].m_cls) != 0) {\n-                printf(\"(watch#%\" PRIuPTR \") wrong class: \\\"%s\\\", expected: \\\"%s\\\"\\n\",\n-                       i, watch.m_cls, watches[i].m_cls);\n-                result = STATUS_FAILED;\n-            }\n-            if (watch.m_name == NULL ||\n-                    strcmp(watch.m_name, watches[i].m_name) != 0) {\n-                printf(\"(watch#%\" PRIuPTR \") wrong method name: \\\"%s\\\"\",\n-                       i, watch.m_name);\n-                printf(\", expected: \\\"%s\\\"\\n\", watches[i].m_name);\n-                result = STATUS_FAILED;\n-            }\n-            if (watch.m_sig == NULL ||\n-                    strcmp(watch.m_sig, watches[i].m_sig) != 0) {\n-                printf(\"(watch#%\" PRIuPTR \") wrong method sig: \\\"%s\\\"\",\n-                       i, watch.m_sig);\n-                printf(\", expected: \\\"%s\\\"\\n\", watches[i].m_sig);\n-                result = STATUS_FAILED;\n-            }\n-            if (watch.loc != watches[i].loc) {\n-                printf(\"(watch#%\" PRIuPTR \") wrong location: 0x%x%08x\",\n-                       i, (jint)(watch.loc >> 32), (jint)watch.loc);\n-                printf(\", expected: 0x%x%08x\\n\",\n-                       (jint)(watches[i].loc >> 32), (jint)watches[i].loc);\n-                result = STATUS_FAILED;\n-            }\n-            if (watch.f_name == NULL ||\n-                    strcmp(watch.f_name, watches[i].f_name) != 0) {\n-                printf(\"(watch#%\" PRIuPTR \") wrong field name: \\\"%s\\\"\",\n-                       i, watch.f_name);\n-                printf(\", expected: \\\"%s\\\"\\n\", watches[i].f_name);\n-                result = STATUS_FAILED;\n-            }\n-            if (watch.f_sig == NULL ||\n-                    strcmp(watch.f_sig, watches[i].f_sig) != 0) {\n-                printf(\"(watch#%\" PRIuPTR \") wrong field sig: \\\"%s\\\"\",\n-                       i, watch.f_sig);\n-                printf(\", expected: \\\"%s\\\"\\n\", watches[i].f_sig);\n-                result = STATUS_FAILED;\n-            }\n-            if (watch.is_static != watches[i].is_static) {\n-                printf(\"(watch#%\" PRIuPTR \") wrong field type: %s\", i,\n-                    (watch.is_static == JNI_TRUE) ? \"static\" : \"instance\");\n-                printf(\", expected: %s\\n\",\n-                    (watches[i].is_static == JNI_TRUE) ? \"static\" : \"instance\");\n-                result = STATUS_FAILED;\n-            }\n-            return;\n-        }\n-    }\n-    printf(\"Unexpected field access catched: 0x%p\\n\", watch.fid);\n-    result = STATUS_FAILED;\n-}\n-\n-#ifdef STATIC_BUILD\n-JNIEXPORT jint JNICALL Agent_OnLoad_fieldacc002(JavaVM *jvm, char *options, void *reserved) {\n-    return Agent_Initialize(jvm, options, reserved);\n-}\n-JNIEXPORT jint JNICALL Agent_OnAttach_fieldacc002(JavaVM *jvm, char *options, void *reserved) {\n-    return Agent_Initialize(jvm, options, reserved);\n-}\n-JNIEXPORT jint JNI_OnLoad_fieldacc002(JavaVM *jvm, char *options, void *reserved) {\n-    return JNI_VERSION_1_8;\n-}\n-#endif\n-jint Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {\n-    jvmtiError err;\n-    jint res;\n-\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n-        printdump = JNI_TRUE;\n-    }\n-\n-    res = jvm->GetEnv((void **) &jvmti, JVMTI_VERSION_1_1);\n-    if (res != JNI_OK || jvmti == NULL) {\n-        printf(\"Wrong result of a valid call to GetEnv!\\n\");\n-        return JNI_ERR;\n-    }\n-\n-    err = jvmti->GetPotentialCapabilities(&caps);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(GetPotentialCapabilities) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        return JNI_ERR;\n-    }\n-\n-    err = jvmti->AddCapabilities(&caps);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(AddCapabilities) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        return JNI_ERR;\n-    }\n-\n-    err = jvmti->GetCapabilities(&caps);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(GetCapabilities) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        return JNI_ERR;\n-    }\n-\n-    if (caps.can_generate_field_access_events) {\n-        callbacks.FieldAccess = &FieldAccess;\n-        err = jvmti->SetEventCallbacks(&callbacks, sizeof(callbacks));\n-        if (err != JVMTI_ERROR_NONE) {\n-            printf(\"(SetEventCallbacks) unexpected error: %s (%d)\\n\",\n-                   TranslateError(err), err);\n-            return JNI_ERR;\n-        }\n-\n-        err = jvmti->SetEventNotificationMode(JVMTI_ENABLE,\n-                JVMTI_EVENT_FIELD_ACCESS, NULL);\n-        if (err != JVMTI_ERROR_NONE) {\n-            printf(\"Failed to enable JVMTI_EVENT_FIELD_ACCESS: %s (%d)\\n\",\n-                   TranslateError(err), err);\n-            return JNI_ERR;\n-        }\n-    } else {\n-        printf(\"Warning: FieldAccess watch is not implemented\\n\");\n-    }\n-\n-    return JNI_OK;\n-}\n-\n-JNIEXPORT void JNICALL Java_nsk_jvmti_FieldAccess_fieldacc002_getReady(JNIEnv *env, jclass clz) {\n-    jvmtiError err;\n-    jclass cls;\n-    size_t i;\n-\n-    if (!caps.can_generate_field_access_events) {\n-        return;\n-    }\n-\n-    if (printdump == JNI_TRUE) {\n-        printf(\">>> setting field access watches ...\\n\");\n-    }\n-\n-    cls = env->FindClass(\"nsk\/jvmti\/FieldAccess\/fieldacc002a\");\n-    if (cls == NULL) {\n-        printf(\"Cannot find fieldacc002a class!\\n\");\n-        result = STATUS_FAILED;\n-        return;\n-    }\n-    for (i = 0; i < sizeof(watches)\/sizeof(watch_info); i++) {\n-        if (watches[i].is_static == JNI_TRUE) {\n-            watches[i].fid = env->GetStaticFieldID(\n-                cls, watches[i].f_name, watches[i].f_sig);\n-        } else {\n-            watches[i].fid = env->GetFieldID(\n-                cls, watches[i].f_name, watches[i].f_sig);\n-        }\n-        if (watches[i].fid == NULL) {\n-            printf(\"Cannot find field \\\"%s\\\"!\\n\", watches[i].f_name);\n-            result = STATUS_FAILED;\n-            return;\n-        }\n-        err = jvmti->SetFieldAccessWatch(cls, watches[i].fid);\n-        if (err == JVMTI_ERROR_NONE) {\n-            eventsExpected++;\n-        } else {\n-            printf(\"(SetFieldAccessWatch#%\" PRIuPTR \") unexpected error: %s (%d)\\n\",\n-                   i, TranslateError(err), err);\n-            result = STATUS_FAILED;\n-        }\n-    }\n-\n-    if (printdump == JNI_TRUE) {\n-        printf(\">>> ... done\\n\");\n-    }\n-}\n-\n-JNIEXPORT jint JNICALL\n-Java_nsk_jvmti_FieldAccess_fieldacc002_check(JNIEnv *env, jclass clz, jobject obj) {\n-    jclass cls;\n-\n-    if (!caps.can_generate_field_access_events) {\n-        return result;\n-    }\n-\n-    if (printdump == JNI_TRUE) {\n-        printf(\">>> accessing fields ...\\n\");\n-    }\n-\n-    cls = env->FindClass(\"nsk\/jvmti\/FieldAccess\/fieldacc002a\");\n-    if (cls == NULL) {\n-        printf(\"Cannot find fieldacc002a class!\\n\");\n-        return STATUS_FAILED;\n-    }\n-\n-    env->GetStaticBooleanField(cls, watches[0].fid);\n-    env->GetStaticByteField(cls, watches[1].fid);\n-    env->GetStaticShortField(cls, watches[2].fid);\n-    env->GetStaticIntField(cls, watches[3].fid);\n-    env->GetStaticLongField(cls, watches[4].fid);\n-    env->GetStaticFloatField(cls, watches[5].fid);\n-    env->GetStaticDoubleField(cls, watches[6].fid);\n-    env->GetStaticCharField(cls, watches[7].fid);\n-    env->GetStaticObjectField(cls, watches[8].fid);\n-    env->GetStaticObjectField(cls, watches[9].fid);\n-\n-    env->GetBooleanField(obj, watches[10].fid);\n-    env->GetByteField(obj, watches[11].fid);\n-    env->GetShortField(obj, watches[12].fid);\n-    env->GetIntField(obj, watches[13].fid);\n-    env->GetLongField(obj, watches[14].fid);\n-    env->GetFloatField(obj, watches[15].fid);\n-    env->GetDoubleField(obj, watches[16].fid);\n-    env->GetCharField(obj, watches[17].fid);\n-    env->GetObjectField(obj, watches[18].fid);\n-    env->GetObjectField(obj, watches[19].fid);\n-\n-    if (printdump == JNI_TRUE) {\n-        printf(\">>> ... done\\n\");\n-    }\n-\n-    if (eventsCount != eventsExpected) {\n-        printf(\"Wrong number of field access events: %d, expected: %d\\n\",\n-            eventsCount, eventsExpected);\n-        result = STATUS_FAILED;\n-    }\n-    return result;\n-}\n-\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/FieldAccess\/fieldacc002\/fieldacc002.cpp","additions":0,"deletions":401,"binary":false,"changes":401,"status":"deleted"},{"patch":"@@ -1,33 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include \"native_thread.cpp\"\n-#include \"nsk_tools.cpp\"\n-#include \"jni_tools.cpp\"\n-#include \"jvmti_tools.cpp\"\n-#include \"agent_tools.cpp\"\n-#include \"jvmti_FollowRefObjects.cpp\"\n-#include \"Injector.cpp\"\n-#include \"JVMTITools.cpp\"\n-#include \"agent_common.cpp\"\n-#include \"fieldacc002.cpp\"\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/FieldAccess\/fieldacc002\/libfieldacc002.cpp","additions":0,"deletions":33,"binary":false,"changes":33,"status":"deleted"},{"patch":"@@ -1,89 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package nsk.jvmti.FieldAccess;\n-\n-import java.io.PrintStream;\n-\n-public class fieldacc003 {\n-\n-    final static int JCK_STATUS_BASE = 95;\n-\n-    static {\n-        try {\n-            System.loadLibrary(\"fieldacc003\");\n-        } catch (UnsatisfiedLinkError ule) {\n-            System.err.println(\"Could not load fieldacc003 library\");\n-            System.err.println(\"java.library.path:\"\n-                + System.getProperty(\"java.library.path\"));\n-            throw ule;\n-        }\n-    }\n-\n-    native static void getReady();\n-    native static int check();\n-\n-    public static void main(String args[]) {\n-        args = nsk.share.jvmti.JVMTITest.commonInit(args);\n-\n-        \/\/ produce JCK-like exit status.\n-        System.exit(run(args, System.out) + JCK_STATUS_BASE);\n-    }\n-\n-    public static int run(String args[], PrintStream out) {\n-        getReady();\n-        fieldacc003a t = new fieldacc003a();\n-        t.run();\n-        return check();\n-    }\n-}\n-\n-class fieldacc003e {\n-    boolean extendsBoolean = false;\n-    byte extendsByte = 10;\n-    short extendsShort = 20;\n-    int extendsInt = 30;\n-    long extendsLong = 40;\n-    float extendsFloat = 0.05F;\n-    double extendsDouble = 0.06;\n-    char extendsChar = 'D';\n-    Object extendsObject = new Object();\n-    int extendsArrInt[] = {70, 80};\n-}\n-\n-class fieldacc003a extends fieldacc003e {\n-    public int run() {\n-        int i = 0;\n-        if (extendsBoolean == true) i++;\n-        if (extendsByte == 1) i++;\n-        if (extendsShort == 2) i++;\n-        if (extendsInt == 3) i++;\n-        if (extendsLong == 4) i++;\n-        if (extendsFloat == 0.5F) i++;\n-        if (extendsDouble == 0.6) i++;\n-        if (extendsChar == 'C') i++;\n-        if (extendsObject == this) i++;\n-        if (extendsArrInt[1] == 7) i++;\n-        return i;\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/FieldAccess\/fieldacc003.java","additions":0,"deletions":89,"binary":false,"changes":89,"status":"deleted"},{"patch":"@@ -1,44 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/*\n- * @test\n- *\n- * @summary converted from VM Testbase nsk\/jvmti\/FieldAccess\/fieldacc003.\n- * VM Testbase keywords: [quick, jpda, jvmti, noras]\n- * VM Testbase readme:\n- * DESCRIPTION\n- *     The test exercise JVMTI event callback function FieldAccess.\n- *     The test sets access watches on fields which are defined in\n- *     superclass, then triggers access watch events on these fields\n- *     and checks if clazz, method, location, field_clazz, field and\n- *     object parameters the function contain the expected values.\n- * COMMENTS\n- *     Ported from JVMDI.\n- *\n- * @library \/vmTestbase\n- *          \/test\/lib\n- * @run main\/othervm\/native -agentlib:fieldacc003 nsk.jvmti.FieldAccess.fieldacc003\n- *\/\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/FieldAccess\/fieldacc003\/TestDescription.java","additions":0,"deletions":44,"binary":false,"changes":44,"status":"deleted"},{"patch":"@@ -1,339 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include <stdio.h>\n-#include <string.h>\n-#include <inttypes.h>\n-#include \"jvmti.h\"\n-#include \"agent_common.h\"\n-#include \"JVMTITools.h\"\n-\n-extern \"C\" {\n-\n-\n-#define PASSED 0\n-#define STATUS_FAILED 2\n-\n-typedef struct {\n-    jfieldID fid;\n-    char *m_cls;\n-    char *m_name;\n-    char *m_sig;\n-    jlocation loc;\n-    char *f_cls;\n-    char *f_name;\n-    char *f_sig;\n-    jboolean is_static;\n-} writable_watch_info;\n-\n-typedef struct {\n-    jfieldID fid;\n-    const char *m_cls;\n-    const char *m_name;\n-    const char *m_sig;\n-    jlocation loc;\n-    const char *f_cls;\n-    const char *f_name;\n-    const char *f_sig;\n-    jboolean is_static;\n-} watch_info;\n-\n-static jvmtiEnv *jvmti;\n-static jvmtiEventCallbacks callbacks;\n-static jvmtiCapabilities caps;\n-static jint result = PASSED;\n-static jboolean printdump = JNI_FALSE;\n-static int eventsExpected = 0;\n-static int eventsCount = 0;\n-static watch_info watches[] = {\n-    { NULL, \"Lnsk\/jvmti\/FieldAccess\/fieldacc003a;\", \"run\", \"()I\", 3,\n-      \"Lnsk\/jvmti\/FieldAccess\/fieldacc003a;\", \"extendsBoolean\", \"Z\", JNI_FALSE },\n-    { NULL, \"Lnsk\/jvmti\/FieldAccess\/fieldacc003a;\", \"run\", \"()I\", 14,\n-      \"Lnsk\/jvmti\/FieldAccess\/fieldacc003a;\", \"extendsByte\", \"B\", JNI_FALSE },\n-    { NULL, \"Lnsk\/jvmti\/FieldAccess\/fieldacc003a;\", \"run\", \"()I\", 25,\n-      \"Lnsk\/jvmti\/FieldAccess\/fieldacc003a;\", \"extendsShort\", \"S\", JNI_FALSE },\n-    { NULL, \"Lnsk\/jvmti\/FieldAccess\/fieldacc003a;\", \"run\", \"()I\", 36,\n-      \"Lnsk\/jvmti\/FieldAccess\/fieldacc003a;\", \"extendsInt\", \"I\", JNI_FALSE },\n-    { NULL, \"Lnsk\/jvmti\/FieldAccess\/fieldacc003a;\", \"run\", \"()I\", 47,\n-      \"Lnsk\/jvmti\/FieldAccess\/fieldacc003a;\", \"extendsLong\", \"J\", JNI_FALSE },\n-    { NULL, \"Lnsk\/jvmti\/FieldAccess\/fieldacc003a;\", \"run\", \"()I\", 61,\n-      \"Lnsk\/jvmti\/FieldAccess\/fieldacc003a;\", \"extendsFloat\", \"F\", JNI_FALSE },\n-    { NULL, \"Lnsk\/jvmti\/FieldAccess\/fieldacc003a;\", \"run\", \"()I\", 74,\n-      \"Lnsk\/jvmti\/FieldAccess\/fieldacc003a;\", \"extendsDouble\", \"D\", JNI_FALSE },\n-    { NULL, \"Lnsk\/jvmti\/FieldAccess\/fieldacc003a;\", \"run\", \"()I\", 88,\n-      \"Lnsk\/jvmti\/FieldAccess\/fieldacc003a;\", \"extendsChar\", \"C\", JNI_FALSE },\n-    { NULL, \"Lnsk\/jvmti\/FieldAccess\/fieldacc003a;\", \"run\", \"()I\", 100,\n-      \"Lnsk\/jvmti\/FieldAccess\/fieldacc003a;\", \"extendsObject\", \"Ljava\/lang\/Object;\", JNI_FALSE },\n-    { NULL, \"Lnsk\/jvmti\/FieldAccess\/fieldacc003a;\", \"run\", \"()I\", 111,\n-      \"Lnsk\/jvmti\/FieldAccess\/fieldacc003a;\", \"extendsArrInt\", \"[I\", JNI_FALSE }\n-};\n-\n-void JNICALL FieldAccess(jvmtiEnv *jvmti_env, JNIEnv *env,\n-        jthread thr, jmethodID method,\n-        jlocation location, jclass field_klass, jobject obj, jfieldID field) {\n-    jvmtiError err;\n-    jclass cls;\n-    writable_watch_info watch;\n-    char *generic;\n-    size_t i;\n-\n-    eventsCount++;\n-    if (printdump == JNI_TRUE) {\n-        printf(\">>> retrieving access watch info ...\\n\");\n-    }\n-    watch.fid = field;\n-    watch.loc = location;\n-    watch.is_static = (obj == NULL) ? JNI_TRUE : JNI_FALSE;\n-    err = jvmti_env->GetMethodDeclaringClass(method, &cls);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(GetMethodDeclaringClass) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-        return;\n-    }\n-    err = jvmti_env->GetClassSignature(cls,\n-        &watch.m_cls, &generic);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(GetClassSignature) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-        return;\n-    }\n-    err = jvmti_env->GetMethodName(method,\n-        &watch.m_name, &watch.m_sig, &generic);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(GetMethodName) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-        return;\n-    }\n-    err = jvmti_env->GetClassSignature(field_klass,\n-        &watch.f_cls,  &generic);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(GetClassSignature) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-        return;\n-    }\n-    err = jvmti_env->GetFieldName(field_klass, field,\n-        &watch.f_name, &watch.f_sig, &generic);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(GetFieldName) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-        return;\n-    }\n-    if (printdump == JNI_TRUE) {\n-        printf(\">>>      class: \\\"%s\\\"\\n\", watch.m_cls);\n-        printf(\">>>     method: \\\"%s%s\\\"\\n\", watch.m_name, watch.m_sig);\n-        printf(\">>>   location: 0x%x%08x\\n\",\n-            (jint)(watch.loc >> 32), (jint)watch.loc);\n-        printf(\">>>  field cls: \\\"%s\\\"\\n\", watch.f_cls);\n-        printf(\">>>      field: \\\"%s:%s\\\"\\n\", watch.f_name, watch.f_sig);\n-        printf(\">>>     object: 0x%p\\n\", obj);\n-        printf(\">>> ... done\\n\");\n-    }\n-    for (i = 0; i < sizeof(watches)\/sizeof(watch_info); i++) {\n-        if (watch.fid == watches[i].fid) {\n-            if (watch.m_cls == NULL ||\n-                    strcmp(watch.m_cls, watches[i].m_cls) != 0) {\n-                printf(\"(watch#%\" PRIuPTR \") wrong class: \\\"%s\\\", expected: \\\"%s\\\"\\n\",\n-                       i, watch.m_cls, watches[i].m_cls);\n-                result = STATUS_FAILED;\n-            }\n-            if (watch.m_name == NULL ||\n-                    strcmp(watch.m_name, watches[i].m_name) != 0) {\n-                printf(\"(watch#%\" PRIuPTR \") wrong method name: \\\"%s\\\"\",\n-                       i, watch.m_name);\n-                printf(\", expected: \\\"%s\\\"\\n\", watches[i].m_name);\n-                result = STATUS_FAILED;\n-            }\n-            if (watch.m_sig == NULL ||\n-                    strcmp(watch.m_sig, watches[i].m_sig) != 0) {\n-                printf(\"(watch#%\" PRIuPTR \") wrong method sig: \\\"%s\\\"\",\n-                       i, watch.m_sig);\n-                printf(\", expected: \\\"%s\\\"\\n\", watches[i].m_sig);\n-                result = STATUS_FAILED;\n-            }\n-            if (watch.loc != watches[i].loc) {\n-                printf(\"(watch#%\" PRIuPTR \") wrong location: 0x%x%08x\",\n-                       i, (jint)(watch.loc >> 32), (jint)watch.loc);\n-                printf(\", expected: 0x%x%08x\\n\",\n-                       (jint)(watches[i].loc >> 32), (jint)watches[i].loc);\n-                result = STATUS_FAILED;\n-            }\n-            if (watch.f_name == NULL ||\n-                    strcmp(watch.f_name, watches[i].f_name) != 0) {\n-                printf(\"(watch#%\" PRIuPTR \") wrong field name: \\\"%s\\\"\",\n-                       i, watch.f_name);\n-                printf(\", expected: \\\"%s\\\"\\n\", watches[i].f_name);\n-                result = STATUS_FAILED;\n-            }\n-            if (watch.f_sig == NULL ||\n-                    strcmp(watch.f_sig, watches[i].f_sig) != 0) {\n-                printf(\"(watch#%\" PRIuPTR \") wrong field sig: \\\"%s\\\"\",\n-                       i, watch.f_sig);\n-                printf(\", expected: \\\"%s\\\"\\n\", watches[i].f_sig);\n-                result = STATUS_FAILED;\n-            }\n-            if (watch.is_static != watches[i].is_static) {\n-                printf(\"(watch#%\" PRIuPTR \") wrong field type: %s\", i,\n-                    (watch.is_static == JNI_TRUE) ? \"static\" : \"instance\");\n-                printf(\", expected: %s\\n\",\n-                    (watches[i].is_static == JNI_TRUE) ? \"static\" : \"instance\");\n-                result = STATUS_FAILED;\n-            }\n-            return;\n-        }\n-    }\n-    printf(\"Unexpected field access catched: 0x%p\\n\", watch.fid);\n-    result = STATUS_FAILED;\n-}\n-\n-#ifdef STATIC_BUILD\n-JNIEXPORT jint JNICALL Agent_OnLoad_fieldacc003(JavaVM *jvm, char *options, void *reserved) {\n-    return Agent_Initialize(jvm, options, reserved);\n-}\n-JNIEXPORT jint JNICALL Agent_OnAttach_fieldacc003(JavaVM *jvm, char *options, void *reserved) {\n-    return Agent_Initialize(jvm, options, reserved);\n-}\n-JNIEXPORT jint JNI_OnLoad_fieldacc003(JavaVM *jvm, char *options, void *reserved) {\n-    return JNI_VERSION_1_8;\n-}\n-#endif\n-jint Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {\n-    jvmtiError err;\n-    jint res;\n-\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n-        printdump = JNI_TRUE;\n-    }\n-\n-    res = jvm->GetEnv((void **) &jvmti, JVMTI_VERSION_1_1);\n-    if (res != JNI_OK || jvmti == NULL) {\n-        printf(\"Wrong result of a valid call to GetEnv!\\n\");\n-        return JNI_ERR;\n-    }\n-\n-    err = jvmti->GetPotentialCapabilities(&caps);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(GetPotentialCapabilities) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        return JNI_ERR;\n-    }\n-\n-    err = jvmti->AddCapabilities(&caps);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(AddCapabilities) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        return JNI_ERR;\n-    }\n-\n-    err = jvmti->GetCapabilities(&caps);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(GetCapabilities) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        return JNI_ERR;\n-    }\n-\n-    if (caps.can_generate_field_access_events) {\n-        callbacks.FieldAccess = &FieldAccess;\n-        err = jvmti->SetEventCallbacks(&callbacks, sizeof(callbacks));\n-        if (err != JVMTI_ERROR_NONE) {\n-            printf(\"(SetEventCallbacks) unexpected error: %s (%d)\\n\",\n-                   TranslateError(err), err);\n-            return JNI_ERR;\n-        }\n-\n-        err = jvmti->SetEventNotificationMode(JVMTI_ENABLE,\n-                JVMTI_EVENT_FIELD_ACCESS, NULL);\n-        if (err != JVMTI_ERROR_NONE) {\n-            printf(\"Failed to enable JVMTI_EVENT_FIELD_ACCESS: %s (%d)\\n\",\n-                   TranslateError(err), err);\n-            return JNI_ERR;\n-        }\n-    } else {\n-        printf(\"Warning: FieldAccess watch is not implemented\\n\");\n-    }\n-\n-    return JNI_OK;\n-}\n-\n-JNIEXPORT void JNICALL\n-Java_nsk_jvmti_FieldAccess_fieldacc003_getReady(JNIEnv *env, jclass klass) {\n-    jvmtiError err;\n-    jclass cls;\n-    size_t i;\n-\n-    if (!caps.can_generate_field_access_events) {\n-        return;\n-    }\n-\n-    if (printdump == JNI_TRUE) {\n-        printf(\">>> setting field access watches ...\\n\");\n-    }\n-    for (i = 0; i < sizeof(watches)\/sizeof(watch_info); i++) {\n-        cls = env->FindClass(watches[i].f_cls);\n-        if (cls == NULL) {\n-            printf(\"Cannot find %s class!\\n\", watches[i].f_cls);\n-            result = STATUS_FAILED;\n-            return;\n-        }\n-        if (watches[i].is_static == JNI_TRUE) {\n-            watches[i].fid = env->GetStaticFieldID(\n-                cls, watches[i].f_name, watches[i].f_sig);\n-        } else {\n-            watches[i].fid = env->GetFieldID(\n-                cls, watches[i].f_name, watches[i].f_sig);\n-        }\n-        if (watches[i].fid == NULL) {\n-            printf(\"Cannot get field ID for \\\"%s:%s\\\"\\n\",\n-                   watches[i].f_name, watches[i].f_sig);\n-            result = STATUS_FAILED;\n-            return;\n-        }\n-        err = jvmti->SetFieldAccessWatch(cls, watches[i].fid);\n-        if (err == JVMTI_ERROR_NONE) {\n-            eventsExpected++;\n-        } else {\n-            printf(\"(SetFieldAccessWatch#%\" PRIuPTR \") unexpected error: %s (%d)\\n\",\n-                   i, TranslateError(err), err);\n-            result = STATUS_FAILED;\n-        }\n-    }\n-    if (printdump == JNI_TRUE) {\n-        printf(\">>> ... done\\n\");\n-    }\n-}\n-\n-JNIEXPORT jint JNICALL\n-Java_nsk_jvmti_FieldAccess_fieldacc003_check(JNIEnv *env, jclass cls) {\n-    if (eventsCount != eventsExpected) {\n-        printf(\"Wrong number of field access events: %d, expected: %d\\n\",\n-            eventsCount, eventsExpected);\n-        result = STATUS_FAILED;\n-    }\n-    return result;\n-}\n-\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/FieldAccess\/fieldacc003\/fieldacc003.cpp","additions":0,"deletions":339,"binary":false,"changes":339,"status":"deleted"},{"patch":"@@ -1,33 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include \"native_thread.cpp\"\n-#include \"nsk_tools.cpp\"\n-#include \"jni_tools.cpp\"\n-#include \"jvmti_tools.cpp\"\n-#include \"agent_tools.cpp\"\n-#include \"jvmti_FollowRefObjects.cpp\"\n-#include \"Injector.cpp\"\n-#include \"JVMTITools.cpp\"\n-#include \"agent_common.cpp\"\n-#include \"fieldacc003.cpp\"\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/FieldAccess\/fieldacc003\/libfieldacc003.cpp","additions":0,"deletions":33,"binary":false,"changes":33,"status":"deleted"},{"patch":"@@ -1,73 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package nsk.jvmti.FieldAccess;\n-\n-import java.io.PrintStream;\n-\n-public class fieldacc004 {\n-\n-    final static int JCK_STATUS_BASE = 95;\n-\n-    static {\n-        try {\n-            System.loadLibrary(\"fieldacc004\");\n-        } catch (UnsatisfiedLinkError ule) {\n-            System.err.println(\"Could not load fieldacc004 library\");\n-            System.err.println(\"java.library.path:\"\n-                + System.getProperty(\"java.library.path\"));\n-            throw ule;\n-        }\n-    }\n-\n-    native static void getReady();\n-    native static int check();\n-\n-    public static void main(String args[]) {\n-        args = nsk.share.jvmti.JVMTITest.commonInit(args);\n-\n-        \/\/ produce JCK-like exit status.\n-        System.exit(run(args, System.out) + JCK_STATUS_BASE);\n-    }\n-\n-    public static int run(String args[], PrintStream out) {\n-        getReady();\n-        fieldacc004a t = new fieldacc004a();\n-        t.run();\n-        return check();\n-    }\n-}\n-\n-interface fieldacc004i {\n-    static Object interfaceObject = new Object();\n-    static int interfaceArrInt[] = {1, 2};\n-}\n-\n-class fieldacc004a implements fieldacc004i {\n-    public int run() {\n-        int i = 0;\n-        if (interfaceObject == this) i++;\n-        if (interfaceArrInt[0] == 3) i++;\n-        return i;\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/FieldAccess\/fieldacc004.java","additions":0,"deletions":73,"binary":false,"changes":73,"status":"deleted"},{"patch":"@@ -1,44 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/*\n- * @test\n- *\n- * @summary converted from VM Testbase nsk\/jvmti\/FieldAccess\/fieldacc004.\n- * VM Testbase keywords: [quick, jpda, jvmti, noras]\n- * VM Testbase readme:\n- * DESCRIPTION\n- *     The test exercise JVMTI event callback function FieldAccess.\n- *     The test sets access watches on fields which are defined in\n- *     superinterface, then triggers access watch events on these fields\n- *     and checks if clazz, method, location, field_clazz, field and\n- *     object parameters of the function contain the expected values.\n- * COMMENTS\n- *     Ported from JVMDI.\n- *\n- * @library \/vmTestbase\n- *          \/test\/lib\n- * @run main\/othervm\/native -agentlib:fieldacc004 nsk.jvmti.FieldAccess.fieldacc004\n- *\/\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/FieldAccess\/fieldacc004\/TestDescription.java","additions":0,"deletions":44,"binary":false,"changes":44,"status":"deleted"},{"patch":"@@ -1,325 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include <stdio.h>\n-#include <string.h>\n-#include <inttypes.h>\n-#include \"jvmti.h\"\n-#include \"agent_common.h\"\n-#include \"JVMTITools.h\"\n-\n-extern \"C\" {\n-\n-\n-#define PASSED 0\n-#define STATUS_FAILED 2\n-\n-typedef struct {\n-    jfieldID fid;\n-    char *m_cls;\n-    char *m_name;\n-    char *m_sig;\n-    jlocation loc;\n-    char *f_cls;\n-    char *f_name;\n-    char *f_sig;\n-    jboolean is_static;\n-} writable_watch_info;\n-\n-typedef struct {\n-    jfieldID fid;\n-    const char *m_cls;\n-    const char *m_name;\n-    const char *m_sig;\n-    jlocation loc;\n-    const char *f_cls;\n-    const char *f_name;\n-    const char *f_sig;\n-    jboolean is_static;\n-} watch_info;\n-\n-static jvmtiEnv *jvmti;\n-static jvmtiEventCallbacks callbacks;\n-static jvmtiCapabilities caps;\n-static jint result = PASSED;\n-static jboolean printdump = JNI_FALSE;\n-static int eventsExpected = 0;\n-static int eventsCount = 0;\n-static watch_info watches[] = {\n-    { NULL, \"Lnsk\/jvmti\/FieldAccess\/fieldacc004a;\", \"run\", \"()I\", 2,\n-      \"Lnsk\/jvmti\/FieldAccess\/fieldacc004a;\", \"interfaceObject\",\n-      \"Ljava\/lang\/Object;\", JNI_TRUE },\n-    { NULL, \"Lnsk\/jvmti\/FieldAccess\/fieldacc004a;\", \"run\", \"()I\", 12,\n-      \"Lnsk\/jvmti\/FieldAccess\/fieldacc004a;\", \"interfaceArrInt\",\n-      \"[I\", JNI_TRUE }\n-};\n-\n-void JNICALL FieldAccess(jvmtiEnv *jvmti_env, JNIEnv *env,\n-        jthread thr, jmethodID method,\n-        jlocation location, jclass field_klass, jobject obj, jfieldID field) {\n-    jvmtiError err;\n-    jclass cls;\n-    writable_watch_info watch;\n-    char *generic;\n-    size_t i;\n-\n-    eventsCount++;\n-    if (printdump == JNI_TRUE) {\n-        printf(\">>> retrieving access watch info ...\\n\");\n-    }\n-    watch.fid = field;\n-    watch.loc = location;\n-    watch.is_static = (obj == NULL) ? JNI_TRUE : JNI_FALSE;\n-    err = jvmti_env->GetMethodDeclaringClass(method, &cls);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(GetMethodDeclaringClass) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-        return;\n-    }\n-    err = jvmti_env->GetClassSignature(cls,\n-        &watch.m_cls, &generic);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(GetClassSignature) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-        return;\n-    }\n-    err = jvmti_env->GetMethodName(method,\n-        &watch.m_name, &watch.m_sig, &generic);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(GetMethodName) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-        return;\n-    }\n-    err = jvmti_env->GetClassSignature(field_klass,\n-        &watch.f_cls, &generic);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(GetClassSignature) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-        return;\n-    }\n-    err = jvmti_env->GetFieldName(field_klass, field,\n-        &watch.f_name, &watch.f_sig, &generic);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(GetFieldName) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-        return;\n-    }\n-    if (printdump == JNI_TRUE) {\n-        printf(\">>>      class: \\\"%s\\\"\\n\", watch.m_cls);\n-        printf(\">>>     method: \\\"%s%s\\\"\\n\", watch.m_name, watch.m_sig);\n-        printf(\">>>   location: 0x%x%08x\\n\",\n-            (jint)(watch.loc >> 32), (jint)watch.loc);\n-        printf(\">>>  field cls: \\\"%s\\\"\\n\", watch.f_cls);\n-        printf(\">>>      field: \\\"%s:%s\\\"\\n\", watch.f_name, watch.f_sig);\n-        printf(\">>>     object: 0x%p\\n\", obj);\n-        printf(\">>> ... done\\n\");\n-    }\n-    for (i = 0; i < sizeof(watches)\/sizeof(watch_info); i++) {\n-        if (watch.fid == watches[i].fid) {\n-            if (watch.m_cls == NULL ||\n-                    strcmp(watch.m_cls, watches[i].m_cls) != 0) {\n-                printf(\"(watch#%\" PRIuPTR \") wrong class: \\\"%s\\\", expected: \\\"%s\\\"\\n\",\n-                       i, watch.m_cls, watches[i].m_cls);\n-                result = STATUS_FAILED;\n-            }\n-            if (watch.m_name == NULL ||\n-                    strcmp(watch.m_name, watches[i].m_name) != 0) {\n-                printf(\"(watch#%\" PRIuPTR \") wrong method name: \\\"%s\\\"\",\n-                       i, watch.m_name);\n-                printf(\", expected: \\\"%s\\\"\\n\", watches[i].m_name);\n-                result = STATUS_FAILED;\n-            }\n-            if (watch.m_sig == NULL ||\n-                    strcmp(watch.m_sig, watches[i].m_sig) != 0) {\n-                printf(\"(watch#%\" PRIuPTR \") wrong method sig: \\\"%s\\\"\",\n-                       i, watch.m_sig);\n-                printf(\", expected: \\\"%s\\\"\\n\", watches[i].m_sig);\n-                result = STATUS_FAILED;\n-            }\n-            if (watch.loc != watches[i].loc) {\n-                printf(\"(watch#%\" PRIuPTR \") wrong location: 0x%x%08x\",\n-                       i, (jint)(watch.loc >> 32), (jint)watch.loc);\n-                printf(\", expected: 0x%x%08x\\n\",\n-                       (jint)(watches[i].loc >> 32), (jint)watches[i].loc);\n-                result = STATUS_FAILED;\n-            }\n-            if (watch.f_name == NULL ||\n-                    strcmp(watch.f_name, watches[i].f_name) != 0) {\n-                printf(\"(watch#%\" PRIuPTR \") wrong field name: \\\"%s\\\"\",\n-                       i, watch.f_name);\n-                printf(\", expected: \\\"%s\\\"\\n\", watches[i].f_name);\n-                result = STATUS_FAILED;\n-            }\n-            if (watch.f_sig == NULL ||\n-                    strcmp(watch.f_sig, watches[i].f_sig) != 0) {\n-                printf(\"(watch#%\" PRIuPTR \") wrong field sig: \\\"%s\\\"\",\n-                       i, watch.f_sig);\n-                printf(\", expected: \\\"%s\\\"\\n\", watches[i].f_sig);\n-                result = STATUS_FAILED;\n-            }\n-            if (watch.is_static != watches[i].is_static) {\n-                printf(\"(watch#%\" PRIuPTR \") wrong field type: %s\", i,\n-                    (watch.is_static == JNI_TRUE) ? \"static\" : \"instance\");\n-                printf(\", expected: %s\\n\",\n-                    (watches[i].is_static == JNI_TRUE) ? \"static\" : \"instance\");\n-                result = STATUS_FAILED;\n-            }\n-            return;\n-        }\n-    }\n-    printf(\"Unexpected field access catched: 0x%p\\n\", watch.fid);\n-    result = STATUS_FAILED;\n-}\n-\n-#ifdef STATIC_BUILD\n-JNIEXPORT jint JNICALL Agent_OnLoad_fieldacc004(JavaVM *jvm, char *options, void *reserved) {\n-    return Agent_Initialize(jvm, options, reserved);\n-}\n-JNIEXPORT jint JNICALL Agent_OnAttach_fieldacc004(JavaVM *jvm, char *options, void *reserved) {\n-    return Agent_Initialize(jvm, options, reserved);\n-}\n-JNIEXPORT jint JNI_OnLoad_fieldacc004(JavaVM *jvm, char *options, void *reserved) {\n-    return JNI_VERSION_1_8;\n-}\n-#endif\n-jint Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {\n-    jvmtiError err;\n-    jint res;\n-\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n-        printdump = JNI_TRUE;\n-    }\n-\n-    res = jvm->GetEnv((void **) &jvmti, JVMTI_VERSION_1_1);\n-    if (res != JNI_OK || jvmti == NULL) {\n-        printf(\"Wrong result of a valid call to GetEnv!\\n\");\n-        return JNI_ERR;\n-    }\n-\n-    err = jvmti->GetPotentialCapabilities(&caps);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(GetPotentialCapabilities) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        return JNI_ERR;\n-    }\n-\n-    err = jvmti->AddCapabilities(&caps);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(AddCapabilities) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        return JNI_ERR;\n-    }\n-\n-    err = jvmti->GetCapabilities(&caps);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(GetCapabilities) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        return JNI_ERR;\n-    }\n-\n-    if (caps.can_generate_field_access_events) {\n-        callbacks.FieldAccess = &FieldAccess;\n-        err = jvmti->SetEventCallbacks(&callbacks, sizeof(callbacks));\n-        if (err != JVMTI_ERROR_NONE) {\n-            printf(\"(SetEventCallbacks) unexpected error: %s (%d)\\n\",\n-                   TranslateError(err), err);\n-            return JNI_ERR;\n-        }\n-\n-        err = jvmti->SetEventNotificationMode(JVMTI_ENABLE,\n-                JVMTI_EVENT_FIELD_ACCESS, NULL);\n-        if (err != JVMTI_ERROR_NONE) {\n-            printf(\"Failed to enable JVMTI_EVENT_FIELD_ACCESS: %s (%d)\\n\",\n-                   TranslateError(err), err);\n-            return JNI_ERR;\n-        }\n-    } else {\n-        printf(\"Warning: FieldAccess watch is not implemented\\n\");\n-    }\n-\n-    return JNI_OK;\n-}\n-\n-JNIEXPORT void JNICALL\n-Java_nsk_jvmti_FieldAccess_fieldacc004_getReady(JNIEnv *env, jclass klass) {\n-    jvmtiError err;\n-    jclass cls;\n-    size_t i;\n-\n-    if (!caps.can_generate_field_access_events) {\n-        return;\n-    }\n-\n-    if (printdump == JNI_TRUE) {\n-        printf(\">>> setting field access watches ...\\n\");\n-    }\n-    for (i = 0; i < sizeof(watches)\/sizeof(watch_info); i++) {\n-        cls = env->FindClass(watches[i].f_cls);\n-        if (cls == NULL) {\n-            printf(\"Cannot find %s class!\\n\", watches[i].f_cls);\n-            result = STATUS_FAILED;\n-            return;\n-        }\n-        if (watches[i].is_static == JNI_TRUE) {\n-            watches[i].fid = env->GetStaticFieldID(\n-                cls, watches[i].f_name, watches[i].f_sig);\n-        } else {\n-            watches[i].fid = env->GetFieldID(\n-                cls, watches[i].f_name, watches[i].f_sig);\n-        }\n-        if (watches[i].fid == NULL) {\n-            printf(\"Cannot get field ID for \\\"%s:%s\\\"\\n\",\n-                   watches[i].f_name, watches[i].f_sig);\n-            result = STATUS_FAILED;\n-            return;\n-        }\n-        err = jvmti->SetFieldAccessWatch(cls, watches[i].fid);\n-        if (err == JVMTI_ERROR_NONE) {\n-            eventsExpected++;\n-        } else {\n-            printf(\"(SetFieldAccessWatch#%\" PRIuPTR \") unexpected error: %s (%d)\\n\",\n-                   i, TranslateError(err), err);\n-            result = STATUS_FAILED;\n-        }\n-    }\n-    if (printdump == JNI_TRUE) {\n-        printf(\">>> ... done\\n\");\n-    }\n-}\n-\n-JNIEXPORT jint JNICALL\n-Java_nsk_jvmti_FieldAccess_fieldacc004_check(JNIEnv *env, jclass cls) {\n-    if (eventsCount != eventsExpected) {\n-        printf(\"Wrong number of field access events: %d, expected: %d\\n\",\n-            eventsCount, eventsExpected);\n-        result = STATUS_FAILED;\n-    }\n-    return result;\n-}\n-\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/FieldAccess\/fieldacc004\/fieldacc004.cpp","additions":0,"deletions":325,"binary":false,"changes":325,"status":"deleted"},{"patch":"@@ -1,33 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include \"native_thread.cpp\"\n-#include \"nsk_tools.cpp\"\n-#include \"jni_tools.cpp\"\n-#include \"jvmti_tools.cpp\"\n-#include \"agent_tools.cpp\"\n-#include \"jvmti_FollowRefObjects.cpp\"\n-#include \"Injector.cpp\"\n-#include \"JVMTITools.cpp\"\n-#include \"agent_common.cpp\"\n-#include \"fieldacc004.cpp\"\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/FieldAccess\/fieldacc004\/libfieldacc004.cpp","additions":0,"deletions":33,"binary":false,"changes":33,"status":"deleted"},{"patch":"@@ -1,64 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package nsk.jvmti.FieldModification;\n-\n-import java.io.PrintStream;\n-\n-public class fieldmod001 {\n-\n-    final static int JCK_STATUS_BASE = 95;\n-\n-    static {\n-        try {\n-            System.loadLibrary(\"fieldmod001\");\n-        } catch (UnsatisfiedLinkError ule) {\n-            System.err.println(\"Could not load fieldmod001 library\");\n-            System.err.println(\"java.library.path:\"\n-                + System.getProperty(\"java.library.path\"));\n-            throw ule;\n-        }\n-    }\n-\n-    native static void getReady(Object o1, Object o2, int a1[], int a2[]);\n-    native static int check();\n-\n-    static Object obj1 = new Object();\n-    static Object obj2 = new Object();\n-    static int arr1[] = new int[1];\n-    static int arr2[] = new int[2];\n-\n-    public static void main(String args[]) {\n-        args = nsk.share.jvmti.JVMTITest.commonInit(args);\n-\n-        \/\/ produce JCK-like exit status.\n-        System.exit(run(args, System.out) + JCK_STATUS_BASE);\n-    }\n-\n-    public static int run(String args[], PrintStream out) {\n-        getReady(obj1, obj2, arr1, arr2);\n-        fieldmod001a t = new fieldmod001a();\n-        t.run();\n-        return check();\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/FieldModification\/fieldmod001.java","additions":0,"deletions":64,"binary":false,"changes":64,"status":"deleted"},{"patch":"@@ -1,45 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/*\n- * @test\n- *\n- * @summary converted from VM Testbase nsk\/jvmti\/FieldModification\/fieldmod001.\n- * VM Testbase keywords: [quick, jpda, jvmti, noras, quarantine]\n- * VM Testbase comments: 8016181\n- * VM Testbase readme:\n- * DESCRIPTION\n- *     The test exercise JVMTI event callback function FieldModification.\n- *     The test checks if the parameters of the function contain the\n- *     expected values.\n- * COMMENTS\n- *     Fixed according to 4669812 bug.\n- *     Ported from JVMDI.\n- *\n- * @library \/vmTestbase\n- *          \/test\/lib\n- * @compile fieldmod001a.jasm\n- * @run main\/othervm\/native -agentlib:fieldmod001 nsk.jvmti.FieldModification.fieldmod001\n- *\/\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/FieldModification\/fieldmod001\/TestDescription.java","additions":0,"deletions":45,"binary":false,"changes":45,"status":"deleted"},{"patch":"@@ -1,460 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include <stdio.h>\n-#include <string.h>\n-#include <inttypes.h>\n-#include \"jvmti.h\"\n-#include \"agent_common.h\"\n-#include \"JVMTITools.h\"\n-\n-extern \"C\" {\n-\n-\n-#define PASSED 0\n-#define STATUS_FAILED 2\n-\n-typedef struct {\n-    jfieldID fid;\n-    char *m_cls;\n-    char *m_name;\n-    char *m_sig;\n-    jlocation loc;\n-    char *f_cls;\n-    char *f_name;\n-    char *f_sig;\n-    jboolean is_static;\n-    jvalue val;\n-} writable_watch_info;\n-\n-typedef struct {\n-    jfieldID fid;\n-    const char *m_cls;\n-    const char *m_name;\n-    const char *m_sig;\n-    jlocation loc;\n-    const char *f_cls;\n-    const char *f_name;\n-    const char *f_sig;\n-    const jboolean is_static;\n-    jvalue val;\n-} watch_info;\n-\n-static jvmtiEnv *jvmti;\n-static jvmtiEventCallbacks callbacks;\n-static jvmtiCapabilities caps;\n-static jint result = PASSED;\n-static jboolean printdump = JNI_FALSE;\n-static int eventsExpected = 0;\n-static int eventsCount = 0;\n-static watch_info watches[] = {\n-    { NULL, \"Lnsk\/jvmti\/FieldModification\/fieldmod001a;\", \"run\", \"()V\", 1,\n-      \"Lnsk\/jvmti\/FieldModification\/fieldmod001a;\", \"staticBoolean\", \"Z\", JNI_TRUE, {} },\n-    { NULL, \"Lnsk\/jvmti\/FieldModification\/fieldmod001a;\", \"run\", \"()V\", 5,\n-      \"Lnsk\/jvmti\/FieldModification\/fieldmod001a;\", \"staticByte\", \"B\", JNI_TRUE, {} },\n-    { NULL, \"Lnsk\/jvmti\/FieldModification\/fieldmod001a;\", \"run\", \"()V\", 9,\n-      \"Lnsk\/jvmti\/FieldModification\/fieldmod001a;\", \"staticShort\", \"S\", JNI_TRUE, {} },\n-    { NULL, \"Lnsk\/jvmti\/FieldModification\/fieldmod001a;\", \"run\", \"()V\", 13,\n-      \"Lnsk\/jvmti\/FieldModification\/fieldmod001a;\", \"staticInt\", \"I\", JNI_TRUE, {} },\n-    { NULL, \"Lnsk\/jvmti\/FieldModification\/fieldmod001a;\", \"run\", \"()V\", 19,\n-      \"Lnsk\/jvmti\/FieldModification\/fieldmod001a;\", \"staticLong\", \"J\", JNI_TRUE, {} },\n-    { NULL, \"Lnsk\/jvmti\/FieldModification\/fieldmod001a;\", \"run\", \"()V\", 24,\n-      \"Lnsk\/jvmti\/FieldModification\/fieldmod001a;\", \"staticFloat\", \"F\", JNI_TRUE, {} },\n-    { NULL, \"Lnsk\/jvmti\/FieldModification\/fieldmod001a;\", \"run\", \"()V\", 30,\n-      \"Lnsk\/jvmti\/FieldModification\/fieldmod001a;\", \"staticDouble\", \"D\", JNI_TRUE, {} },\n-    { NULL, \"Lnsk\/jvmti\/FieldModification\/fieldmod001a;\", \"run\", \"()V\", 35,\n-      \"Lnsk\/jvmti\/FieldModification\/fieldmod001a;\", \"staticChar\", \"C\", JNI_TRUE, {} },\n-    { NULL, \"Lnsk\/jvmti\/FieldModification\/fieldmod001a;\", \"run\", \"()V\", 41,\n-      \"Lnsk\/jvmti\/FieldModification\/fieldmod001a;\", \"staticObject\", \"Ljava\/lang\/Object;\", JNI_TRUE, {} },\n-    { NULL, \"Lnsk\/jvmti\/FieldModification\/fieldmod001a;\", \"run\", \"()V\", 47,\n-      \"Lnsk\/jvmti\/FieldModification\/fieldmod001a;\", \"staticArrInt\", \"[I\", JNI_TRUE, {} },\n-\n-    { NULL, \"Lnsk\/jvmti\/FieldModification\/fieldmod001a;\", \"run\", \"()V\", 52,\n-      \"Lnsk\/jvmti\/FieldModification\/fieldmod001a;\", \"instanceBoolean\", \"Z\", JNI_FALSE, {} },\n-    { NULL, \"Lnsk\/jvmti\/FieldModification\/fieldmod001a;\", \"run\", \"()V\", 58,\n-      \"Lnsk\/jvmti\/FieldModification\/fieldmod001a;\", \"instanceByte\", \"B\", JNI_FALSE, {} },\n-    { NULL, \"Lnsk\/jvmti\/FieldModification\/fieldmod001a;\", \"run\", \"()V\", 64,\n-      \"Lnsk\/jvmti\/FieldModification\/fieldmod001a;\", \"instanceShort\", \"S\", JNI_FALSE, {} },\n-    { NULL, \"Lnsk\/jvmti\/FieldModification\/fieldmod001a;\", \"run\", \"()V\", 70,\n-      \"Lnsk\/jvmti\/FieldModification\/fieldmod001a;\", \"instanceInt\", \"I\", JNI_FALSE, {} },\n-    { NULL, \"Lnsk\/jvmti\/FieldModification\/fieldmod001a;\", \"run\", \"()V\", 77,\n-      \"Lnsk\/jvmti\/FieldModification\/fieldmod001a;\", \"instanceLong\", \"J\", JNI_FALSE, {} },\n-    { NULL, \"Lnsk\/jvmti\/FieldModification\/fieldmod001a;\", \"run\", \"()V\", 83,\n-      \"Lnsk\/jvmti\/FieldModification\/fieldmod001a;\", \"instanceFloat\", \"F\", JNI_FALSE, {} },\n-    { NULL, \"Lnsk\/jvmti\/FieldModification\/fieldmod001a;\", \"run\", \"()V\", 90,\n-      \"Lnsk\/jvmti\/FieldModification\/fieldmod001a;\", \"instanceDouble\", \"D\", JNI_FALSE, {} },\n-    { NULL, \"Lnsk\/jvmti\/FieldModification\/fieldmod001a;\", \"run\", \"()V\", 96,\n-      \"Lnsk\/jvmti\/FieldModification\/fieldmod001a;\", \"instanceChar\", \"C\", JNI_FALSE, {} },\n-    { NULL, \"Lnsk\/jvmti\/FieldModification\/fieldmod001a;\", \"run\", \"()V\", 103,\n-      \"Lnsk\/jvmti\/FieldModification\/fieldmod001a;\", \"instanceObject\", \"Ljava\/lang\/Object;\", JNI_FALSE, {} },\n-    { NULL, \"Lnsk\/jvmti\/FieldModification\/fieldmod001a;\", \"run\", \"()V\", 110,\n-      \"Lnsk\/jvmti\/FieldModification\/fieldmod001a;\", \"instanceArrInt\", \"[I\", JNI_FALSE, {} }\n-};\n-\n-void printValue(jvalue val, char *sig) {\n-    switch (*sig) {\n-    case 'J':\n-        printf(\"0x%x%08x\", (jint)(val.j >> 32), (jint)val.j);\n-        break;\n-    case 'F':\n-        printf(\"%.3f\", (double)val.f);\n-        break;\n-    case 'D':\n-        printf(\"%f\", (double)val.d);\n-        break;\n-    case 'L':\n-    case '[':\n-        printf(\"0x%p\", val.l);\n-        break;\n-    case 'Z':\n-        printf(\"0x%x\", val.z);\n-        break;\n-    case 'B':\n-        printf(\"%d\", val.b);\n-        break;\n-    case 'S':\n-        printf(\"%d\", val.s);\n-        break;\n-    case 'C':\n-        printf(\"0x%x\", val.c);\n-        break;\n-    case 'I':\n-        printf(\"%d\", val.i);\n-        break;\n-    default:\n-        printf(\"0x%x%08x\", (jint)(val.j >> 32), (jint)val.j);\n-        break;\n-    }\n-}\n-\n-int isEqual(JNIEnv *env, char *sig, jvalue v1, jvalue v2) {\n-    switch (*sig) {\n-    case 'J':\n-        return (v1.j == v2.j);\n-    case 'F':\n-        return (v1.f == v2.f);\n-    case 'D':\n-        return (v1.d == v2.d);\n-    case 'L':\n-    case '[':\n-        return env->IsSameObject(v1.l, v2.l);\n-    case 'Z':\n-        return (v1.z == v2.z);\n-    case 'B':\n-        return (v1.b == v2.b);\n-    case 'S':\n-        return (v1.s == v2.s);\n-    case 'C':\n-        return (v1.c == v2.c);\n-    case 'I':\n-        return (v1.i == v2.i);\n-    default:\n-        return (1);\n-    }\n-}\n-\n-void JNICALL FieldModification(jvmtiEnv *jvmti_env, JNIEnv *env,\n-        jthread thr, jmethodID method, jlocation location,\n-        jclass field_klass, jobject obj,\n-        jfieldID field, char sig, jvalue new_value) {\n-    jvmtiError err;\n-    jclass cls;\n-    writable_watch_info watch;\n-    char *generic;\n-    size_t i;\n-\n-    eventsCount++;\n-    if (printdump == JNI_TRUE) {\n-        printf(\">>> retrieving modification watch info ...\\n\");\n-    }\n-    watch.fid = field;\n-    watch.loc = location;\n-    watch.val = new_value;\n-    watch.is_static = (obj == NULL) ? JNI_TRUE : JNI_FALSE;\n-    err = jvmti_env->GetMethodDeclaringClass(method, &cls);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(GetMethodDeclaringClass) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-        return;\n-    }\n-    err = jvmti_env->GetClassSignature(cls,\n-        &watch.m_cls, &generic);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(GetClassSignature) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-        return;\n-    }\n-    err = jvmti_env->GetMethodName(method,\n-        &watch.m_name, &watch.m_sig, &generic);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(GetMethodName) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-        return;\n-    }\n-    err = jvmti_env->GetClassSignature(field_klass,\n-        &watch.f_cls, &generic);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(GetClassSignature) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-        return;\n-    }\n-    err = jvmti_env->GetFieldName(field_klass, field,\n-        &watch.f_name, &watch.f_sig, &generic);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(GetFieldName) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-        return;\n-    }\n-    if (printdump == JNI_TRUE) {\n-        printf(\">>>      class: \\\"%s\\\"\\n\", watch.m_cls);\n-        printf(\">>>     method: \\\"%s%s\\\"\\n\", watch.m_name, watch.m_sig);\n-        printf(\">>>   location: 0x%x%08x\\n\",\n-            (jint)(watch.loc >> 32), (jint)watch.loc);\n-        printf(\">>>  field cls: \\\"%s\\\"\\n\", watch.f_cls);\n-        printf(\">>>      field: \\\"%s:%s\\\"\\n\", watch.f_name, watch.f_sig);\n-        printf(\">>>     object: 0x%p\\n\", obj);\n-        printf(\">>>  new value: \");\n-        printValue(watch.val, watch.f_sig);\n-        printf(\"\\n\");\n-    }\n-    for (i = 0; i < sizeof(watches)\/sizeof(watch_info); i++) {\n-        if (watch.fid == watches[i].fid) {\n-            if (watch.m_cls == NULL ||\n-                    strcmp(watch.m_cls, watches[i].m_cls) != 0) {\n-                printf(\"(watch#%\" PRIuPTR \") wrong class: \\\"%s\\\", expected: \\\"%s\\\"\\n\",\n-                       i, watch.m_cls, watches[i].m_cls);\n-                result = STATUS_FAILED;\n-            }\n-            if (watch.m_name == NULL ||\n-                    strcmp(watch.m_name, watches[i].m_name) != 0) {\n-                printf(\"(watch#%\" PRIuPTR \") wrong method name: \\\"%s\\\"\",\n-                       i, watch.m_name);\n-                printf(\", expected: \\\"%s\\\"\\n\", watches[i].m_name);\n-                result = STATUS_FAILED;\n-            }\n-            if (watch.m_sig == NULL ||\n-                    strcmp(watch.m_sig, watches[i].m_sig) != 0) {\n-                printf(\"(watch#%\" PRIuPTR \") wrong method sig: \\\"%s\\\"\",\n-                       i, watch.m_sig);\n-                printf(\", expected: \\\"%s\\\"\\n\", watches[i].m_sig);\n-                result = STATUS_FAILED;\n-            }\n-            if (watch.loc != watches[i].loc) {\n-                printf(\"(watch#%\" PRIuPTR \") wrong location: 0x%x%08x\",\n-                       i, (jint)(watch.loc >> 32), (jint)watch.loc);\n-                printf(\", expected: 0x%x%08x\\n\",\n-                       (jint)(watches[i].loc >> 32), (jint)watches[i].loc);\n-                result = STATUS_FAILED;\n-            }\n-            if (watch.f_name == NULL ||\n-                    strcmp(watch.f_name, watches[i].f_name) != 0) {\n-                printf(\"(watch#%\" PRIuPTR \") wrong field name: \\\"%s\\\"\",\n-                       i, watch.f_name);\n-                printf(\", expected: \\\"%s\\\"\\n\", watches[i].f_name);\n-                result = STATUS_FAILED;\n-            }\n-            if (watch.f_sig == NULL ||\n-                    strcmp(watch.f_sig, watches[i].f_sig) != 0) {\n-                printf(\"(watch#%\" PRIuPTR \") wrong field sig: \\\"%s\\\"\",\n-                       i, watch.f_sig);\n-                printf(\", expected: \\\"%s\\\"\\n\", watches[i].f_sig);\n-                result = STATUS_FAILED;\n-            }\n-            if (watch.is_static != watches[i].is_static) {\n-                printf(\"(watch#%\" PRIuPTR \") wrong field type: %s\", i,\n-                    (watch.is_static == JNI_TRUE) ? \"static\" : \"instance\");\n-                printf(\", expected: %s\\n\",\n-                    (watches[i].is_static == JNI_TRUE) ? \"static\" : \"instance\");\n-                result = STATUS_FAILED;\n-            }\n-            if (!isEqual((JNIEnv *)env, watch.f_sig, watch.val, watches[i].val)) {\n-                printf(\"(watch#%\" PRIuPTR \") wrong new value: \", i);\n-                printValue(watch.val, watch.f_sig);\n-                printf(\", expected: \");\n-                printValue(watches[i].val, watch.f_sig);\n-                printf(\"\\n\");\n-                result = STATUS_FAILED;\n-            }\n-            return;\n-        }\n-    }\n-    printf(\"Unexpected field modification catched: 0x%p\\n\", watch.fid);\n-    result = STATUS_FAILED;\n-}\n-\n-#ifdef STATIC_BUILD\n-JNIEXPORT jint JNICALL Agent_OnLoad_fieldmod001(JavaVM *jvm, char *options, void *reserved) {\n-    return Agent_Initialize(jvm, options, reserved);\n-}\n-JNIEXPORT jint JNICALL Agent_OnAttach_fieldmod001(JavaVM *jvm, char *options, void *reserved) {\n-    return Agent_Initialize(jvm, options, reserved);\n-}\n-JNIEXPORT jint JNI_OnLoad_fieldmod001(JavaVM *jvm, char *options, void *reserved) {\n-    return JNI_VERSION_1_8;\n-}\n-#endif\n-jint Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {\n-    jvmtiError err;\n-    jint res;\n-\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n-        printdump = JNI_TRUE;\n-    }\n-\n-    res = jvm->GetEnv((void **) &jvmti, JVMTI_VERSION_1_1);\n-    if (res != JNI_OK || jvmti == NULL) {\n-        printf(\"Wrong result of a valid call to GetEnv!\\n\");\n-        return JNI_ERR;\n-    }\n-\n-    err = jvmti->GetPotentialCapabilities(&caps);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(GetPotentialCapabilities) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        return JNI_ERR;\n-    }\n-\n-    err = jvmti->AddCapabilities(&caps);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(AddCapabilities) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        return JNI_ERR;\n-    }\n-\n-    err = jvmti->GetCapabilities(&caps);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(GetCapabilities) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        return JNI_ERR;\n-    }\n-\n-    if (caps.can_generate_field_modification_events) {\n-        callbacks.FieldModification = &FieldModification;\n-        err = jvmti->SetEventCallbacks(&callbacks, sizeof(callbacks));\n-        if (err != JVMTI_ERROR_NONE) {\n-            printf(\"(SetEventCallbacks) unexpected error: %s (%d)\\n\",\n-                   TranslateError(err), err);\n-            return JNI_ERR;\n-        }\n-\n-        err = jvmti->SetEventNotificationMode(JVMTI_ENABLE,\n-                JVMTI_EVENT_FIELD_MODIFICATION, NULL);\n-        if (err != JVMTI_ERROR_NONE) {\n-            printf(\"Failed to enable JVMTI_EVENT_FIELD_MODIFICATION: %s (%d)\\n\",\n-                   TranslateError(err), err);\n-            return JNI_ERR;\n-        }\n-    } else {\n-        printf(\"Warning: FieldModification watch is not implemented\\n\");\n-    }\n-\n-    return JNI_OK;\n-}\n-\n-JNIEXPORT void JNICALL\n-Java_nsk_jvmti_FieldModification_fieldmod001_getReady(JNIEnv *env, jclass klass,\n-        jobject obj1, jobject obj2, jobject arr1, jobject arr2) {\n-    jvmtiError err;\n-    jclass cls;\n-    size_t i;\n-\n-    if (!caps.can_generate_field_modification_events) {\n-        return;\n-    }\n-\n-    if (printdump == JNI_TRUE) {\n-        printf(\">>> setting field modification watches ...\\n\");\n-    }\n-    cls = env->FindClass(\"nsk\/jvmti\/FieldModification\/fieldmod001a\");\n-    if (cls == NULL) {\n-        printf(\"Cannot find fieldmod001a class!\\n\");\n-        result = STATUS_FAILED;\n-        return;\n-    }\n-    for (i = 0; i < sizeof(watches)\/sizeof(watch_info); i++) {\n-        if (watches[i].is_static == JNI_TRUE) {\n-            watches[i].fid = env->GetStaticFieldID(\n-                cls, watches[i].f_name, watches[i].f_sig);\n-        } else {\n-            watches[i].fid = env->GetFieldID(\n-                cls, watches[i].f_name, watches[i].f_sig);\n-        }\n-        if (watches[i].fid == NULL) {\n-            printf(\"Cannot get field ID for \\\"%s:%s\\\"\\n\",\n-                   watches[i].f_name, watches[i].f_sig);\n-            result = STATUS_FAILED;\n-            return;\n-        }\n-        err = jvmti->SetFieldModificationWatch(cls, watches[i].fid);\n-        if (err == JVMTI_ERROR_NONE) {\n-            eventsExpected++;\n-        } else {\n-            printf(\"(SetFieldModificationWatch#%\" PRIuPTR \") unexpected error: %s (%d)\\n\",\n-                   i, TranslateError(err), err);\n-            result = STATUS_FAILED;\n-        }\n-    }\n-\n-    watches[0].val.z = JNI_TRUE;\n-    watches[1].val.b = 1;\n-    watches[2].val.s = 2;\n-    watches[3].val.i = 3;\n-    watches[4].val.j = 4;\n-    watches[5].val.f = 0.5F;\n-    watches[6].val.d = 0.6;\n-    watches[7].val.c = 0x61;\n-    watches[8].val.l = env->NewGlobalRef(obj1);\n-    watches[9].val.l = env->NewGlobalRef(arr1);\n-\n-    watches[10].val.z = JNI_FALSE;\n-    watches[11].val.b = 10;\n-    watches[12].val.s = 20;\n-    watches[13].val.i = 30;\n-    watches[14].val.j = 40;\n-    watches[15].val.f = 0.05F;\n-    watches[16].val.d = 0.06;\n-    watches[17].val.c = 0x7a;\n-    watches[18].val.l = env->NewGlobalRef(obj2);\n-    watches[19].val.l = env->NewGlobalRef(arr2);\n-\n-    if (printdump == JNI_TRUE) {\n-        printf(\">>> ... done\\n\");\n-    }\n-}\n-\n-JNIEXPORT jint JNICALL\n-Java_nsk_jvmti_FieldModification_fieldmod001_check(JNIEnv *env, jclass cls) {\n-    if (eventsCount != eventsExpected) {\n-        printf(\"Wrong number of field modification events: %d, expected: %d\\n\",\n-            eventsCount, eventsExpected);\n-        result = STATUS_FAILED;\n-    }\n-    return result;\n-}\n-\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/FieldModification\/fieldmod001\/fieldmod001.cpp","additions":0,"deletions":460,"binary":false,"changes":460,"status":"deleted"},{"patch":"@@ -1,108 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package nsk\/jvmti\/FieldModification;\n-\n-super public class fieldmod001a {\n-\n-    static Field staticBoolean:Z;\n-    static Field staticByte:B;\n-    static Field staticShort:S;\n-    static Field staticInt:I;\n-    static Field staticLong:J;\n-    static Field staticFloat:F;\n-    static Field staticDouble:D;\n-    static Field staticChar:C;\n-    static Field staticObject:\"Ljava\/lang\/Object;\";\n-    static Field staticArrInt:\"[I\";\n-    Field instanceBoolean:Z;\n-    Field instanceByte:B;\n-    Field instanceShort:S;\n-    Field instanceInt:I;\n-    Field instanceLong:J;\n-    Field instanceFloat:F;\n-    Field instanceDouble:D;\n-    Field instanceChar:C;\n-    Field instanceObject:\"Ljava\/lang\/Object;\";\n-    Field instanceArrInt:\"[I\";\n-\n-    public Method \"<init>\":\"()V\" stack 1 locals 1 {\n-        aload_0;\n-        invokespecial Method java\/lang\/Object.\"<init>\":\"()V\";\n-        return;\n-    }\n-\n-    public Method run:\"()V\" stack 5 locals 1 {\n-        iconst_1;\n-        putstatic   Field staticBoolean:\"Z\";    \/\/ bci=1\n-        iconst_1;\n-        putstatic   Field staticByte:\"B\";       \/\/ bci=5\n-        iconst_2;\n-        putstatic   Field staticShort:\"S\";      \/\/ bci=9\n-        iconst_3;\n-        putstatic   Field staticInt:\"I\";        \/\/ bci=13\n-        ldc2_w      long 4l;\n-        putstatic   Field staticLong:\"J\";       \/\/ bci=19\n-        ldc         float 0.5f;\n-        putstatic   Field staticFloat:\"F\";      \/\/ bci=24\n-        ldc2_w      double 0.6d;\n-        putstatic   Field staticDouble:\"D\";     \/\/ bci=30\n-        bipush      97;\n-        putstatic   Field staticChar:\"C\";       \/\/ bci=35\n-        getstatic   Field fieldmod001.obj1:\"Ljava\/lang\/Object;\";\n-        putstatic   Field staticObject:\"Ljava\/lang\/Object;\"; \/\/ bci=41\n-        getstatic   Field fieldmod001.arr1:\"[I\";\n-        putstatic   Field staticArrInt:\"[I\";    \/\/ bci=47\n-        aload_0;\n-        iconst_0;\n-        putfield    Field instanceBoolean:\"Z\";  \/\/ bci=52\n-        aload_0;\n-        bipush      10;\n-        putfield    Field instanceByte:\"B\";     \/\/ bci=58\n-        aload_0;\n-        bipush      20;\n-        putfield    Field instanceShort:\"S\";    \/\/ bci=64\n-        aload_0;\n-        bipush      30;\n-        putfield    Field instanceInt:\"I\";      \/\/ bci=70\n-        aload_0;\n-        ldc2_w      long 40l;\n-        putfield    Field instanceLong:\"J\";     \/\/ bci=77\n-        aload_0;\n-        ldc         float 0.05f;\n-        putfield    Field instanceFloat:\"F\";    \/\/ bci=83\n-        aload_0;\n-        ldc2_w      double 0.06d;\n-        putfield    Field instanceDouble:\"D\";   \/\/ bci=90\n-        aload_0;\n-        bipush      122;\n-        putfield    Field instanceChar:\"C\";     \/\/ bci=96\n-        aload_0;\n-        getstatic   Field fieldmod001.obj2:\"Ljava\/lang\/Object;\";\n-        putfield    Field instanceObject:\"Ljava\/lang\/Object;\"; \/\/ bci=103\n-        aload_0;\n-        getstatic   Field fieldmod001.arr2:\"[I\";\n-        putfield    Field instanceArrInt:\"[I\";  \/\/ bci=110\n-        return;\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/FieldModification\/fieldmod001\/fieldmod001a.jasm","additions":0,"deletions":108,"binary":false,"changes":108,"status":"deleted"},{"patch":"@@ -1,33 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include \"native_thread.cpp\"\n-#include \"nsk_tools.cpp\"\n-#include \"jni_tools.cpp\"\n-#include \"jvmti_tools.cpp\"\n-#include \"agent_tools.cpp\"\n-#include \"jvmti_FollowRefObjects.cpp\"\n-#include \"Injector.cpp\"\n-#include \"JVMTITools.cpp\"\n-#include \"agent_common.cpp\"\n-#include \"fieldmod001.cpp\"\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/FieldModification\/fieldmod001\/libfieldmod001.cpp","additions":0,"deletions":33,"binary":false,"changes":33,"status":"deleted"},{"patch":"@@ -1,81 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package nsk.jvmti.FieldModification;\n-\n-import java.io.PrintStream;\n-\n-public class fieldmod002 {\n-\n-    final static int JCK_STATUS_BASE = 95;\n-\n-    static {\n-        try {\n-            System.loadLibrary(\"fieldmod002\");\n-        } catch (UnsatisfiedLinkError ule) {\n-            System.err.println(\"Could not load fieldmod002 library\");\n-            System.err.println(\"java.library.path:\"\n-                + System.getProperty(\"java.library.path\"));\n-            throw ule;\n-        }\n-    }\n-\n-    native static void getReady();\n-    native static int check(Object obj);\n-\n-    public static void main(String args[]) {\n-        args = nsk.share.jvmti.JVMTITest.commonInit(args);\n-\n-        \/\/ produce JCK-like exit status.\n-        System.exit(run(args, System.out) + JCK_STATUS_BASE);\n-    }\n-\n-    public static int run(String args[], PrintStream out) {\n-        fieldmod002a t = new fieldmod002a();\n-        getReady();\n-        return check(t);\n-    }\n-}\n-\n-class fieldmod002a {\n-    static boolean staticBoolean;\n-    static byte staticByte;\n-    static short staticShort;\n-    static int staticInt;\n-    static long staticLong;\n-    static float staticFloat;\n-    static double staticDouble;\n-    static char staticChar;\n-    static Object staticObject;\n-    static int staticArrInt[];\n-    boolean instanceBoolean;\n-    byte instanceByte;\n-    short instanceShort;\n-    int instanceInt;\n-    long instanceLong;\n-    float instanceFloat;\n-    double instanceDouble;\n-    char instanceChar;\n-    Object instanceObject;\n-    int instanceArrInt[];\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/FieldModification\/fieldmod002.java","additions":0,"deletions":81,"binary":false,"changes":81,"status":"deleted"},{"patch":"@@ -1,43 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/*\n- * @test\n- *\n- * @summary converted from VM Testbase nsk\/jvmti\/FieldModification\/fieldmod002.\n- * VM Testbase keywords: [quick, jpda, jvmti, noras]\n- * VM Testbase readme:\n- * DESCRIPTION\n- *     The test exercise JVMTI event callback function FieldModification.\n- *     The test checks if the parameters of the function contain the\n- *     expected values for fields modified from JNI code.\n- * COMMENTS\n- *     Fixed according to 4669812 bug.\n- *     Ported from JVMDI.\n- *\n- * @library \/vmTestbase\n- *          \/test\/lib\n- * @run main\/othervm\/native -agentlib:fieldmod002 nsk.jvmti.FieldModification.fieldmod002\n- *\/\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/FieldModification\/fieldmod002\/TestDescription.java","additions":0,"deletions":43,"binary":false,"changes":43,"status":"deleted"},{"patch":"@@ -1,510 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include <stdio.h>\n-#include <string.h>\n-#include <inttypes.h>\n-#include \"jvmti.h\"\n-#include \"agent_common.h\"\n-#include \"JVMTITools.h\"\n-\n-extern \"C\" {\n-\n-\n-#define PASSED 0\n-#define STATUS_FAILED 2\n-\n-typedef struct {\n-    jfieldID fid;\n-    char *m_cls;\n-    char *m_name;\n-    char *m_sig;\n-    jlocation loc;\n-    char *f_cls;\n-    char *f_name;\n-    char *f_sig;\n-    jboolean is_static;\n-    jvalue val;\n-} writable_watch_info;\n-\n-typedef struct {\n-    jfieldID fid;\n-    const char *m_cls;\n-    const char *m_name;\n-    const char *m_sig;\n-    jlocation loc;\n-    const char *f_cls;\n-    const char *f_name;\n-    const char *f_sig;\n-    jboolean is_static;\n-    jvalue val;\n-} watch_info;\n-\n-static jvmtiEnv *jvmti;\n-static jvmtiEventCallbacks callbacks;\n-static jvmtiCapabilities caps;\n-static jint result = PASSED;\n-static jboolean printdump = JNI_FALSE;\n-static int eventsExpected = 0;\n-static int eventsCount = 0;\n-static watch_info watches[] = {\n-    { NULL, \"Lnsk\/jvmti\/FieldModification\/fieldmod002;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n-      \"Lnsk\/jvmti\/FieldModification\/fieldmod002a;\", \"staticBoolean\", \"Z\", JNI_TRUE, {} },\n-    { NULL, \"Lnsk\/jvmti\/FieldModification\/fieldmod002;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n-      \"Lnsk\/jvmti\/FieldModification\/fieldmod002a;\", \"staticByte\", \"B\", JNI_TRUE, {} },\n-    { NULL, \"Lnsk\/jvmti\/FieldModification\/fieldmod002;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n-      \"Lnsk\/jvmti\/FieldModification\/fieldmod002a;\", \"staticShort\", \"S\", JNI_TRUE, {} },\n-    { NULL, \"Lnsk\/jvmti\/FieldModification\/fieldmod002;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n-      \"Lnsk\/jvmti\/FieldModification\/fieldmod002a;\", \"staticInt\", \"I\", JNI_TRUE, {} },\n-    { NULL, \"Lnsk\/jvmti\/FieldModification\/fieldmod002;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n-      \"Lnsk\/jvmti\/FieldModification\/fieldmod002a;\", \"staticLong\", \"J\", JNI_TRUE, {} },\n-    { NULL, \"Lnsk\/jvmti\/FieldModification\/fieldmod002;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n-      \"Lnsk\/jvmti\/FieldModification\/fieldmod002a;\", \"staticFloat\", \"F\", JNI_TRUE, {} },\n-    { NULL, \"Lnsk\/jvmti\/FieldModification\/fieldmod002;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n-      \"Lnsk\/jvmti\/FieldModification\/fieldmod002a;\", \"staticDouble\", \"D\", JNI_TRUE, {} },\n-    { NULL, \"Lnsk\/jvmti\/FieldModification\/fieldmod002;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n-      \"Lnsk\/jvmti\/FieldModification\/fieldmod002a;\", \"staticChar\", \"C\", JNI_TRUE, {} },\n-    { NULL, \"Lnsk\/jvmti\/FieldModification\/fieldmod002;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n-      \"Lnsk\/jvmti\/FieldModification\/fieldmod002a;\", \"staticObject\", \"Ljava\/lang\/Object;\", JNI_TRUE, {} },\n-    { NULL, \"Lnsk\/jvmti\/FieldModification\/fieldmod002;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n-      \"Lnsk\/jvmti\/FieldModification\/fieldmod002a;\", \"staticArrInt\", \"[I\", JNI_TRUE, {} },\n-\n-    { NULL, \"Lnsk\/jvmti\/FieldModification\/fieldmod002;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n-      \"Lnsk\/jvmti\/FieldModification\/fieldmod002a;\", \"instanceBoolean\", \"Z\", JNI_FALSE, {} },\n-    { NULL, \"Lnsk\/jvmti\/FieldModification\/fieldmod002;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n-      \"Lnsk\/jvmti\/FieldModification\/fieldmod002a;\", \"instanceByte\", \"B\", JNI_FALSE, {} },\n-    { NULL, \"Lnsk\/jvmti\/FieldModification\/fieldmod002;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n-      \"Lnsk\/jvmti\/FieldModification\/fieldmod002a;\", \"instanceShort\", \"S\", JNI_FALSE, {} },\n-    { NULL, \"Lnsk\/jvmti\/FieldModification\/fieldmod002;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n-      \"Lnsk\/jvmti\/FieldModification\/fieldmod002a;\", \"instanceInt\", \"I\", JNI_FALSE, {} },\n-    { NULL, \"Lnsk\/jvmti\/FieldModification\/fieldmod002;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n-      \"Lnsk\/jvmti\/FieldModification\/fieldmod002a;\", \"instanceLong\", \"J\", JNI_FALSE, {} },\n-    { NULL, \"Lnsk\/jvmti\/FieldModification\/fieldmod002;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n-      \"Lnsk\/jvmti\/FieldModification\/fieldmod002a;\", \"instanceFloat\", \"F\", JNI_FALSE, {} },\n-    { NULL, \"Lnsk\/jvmti\/FieldModification\/fieldmod002;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n-      \"Lnsk\/jvmti\/FieldModification\/fieldmod002a;\", \"instanceDouble\", \"D\", JNI_FALSE, {} },\n-    { NULL, \"Lnsk\/jvmti\/FieldModification\/fieldmod002;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n-      \"Lnsk\/jvmti\/FieldModification\/fieldmod002a;\", \"instanceChar\", \"C\", JNI_FALSE, {} },\n-    { NULL, \"Lnsk\/jvmti\/FieldModification\/fieldmod002;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n-      \"Lnsk\/jvmti\/FieldModification\/fieldmod002a;\", \"instanceObject\", \"Ljava\/lang\/Object;\", JNI_FALSE, {} },\n-    { NULL, \"Lnsk\/jvmti\/FieldModification\/fieldmod002;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n-      \"Lnsk\/jvmti\/FieldModification\/fieldmod002a;\", \"instanceArrInt\", \"[I\", JNI_FALSE, {} }\n-};\n-\n-void printValue(jvalue val, char *sig) {\n-    switch (*sig) {\n-    case 'J':\n-        printf(\"0x%x%08x\", (jint)(val.j >> 32), (jint)val.j);\n-        break;\n-    case 'F':\n-        printf(\"%.3f\", (double)val.f);\n-        break;\n-    case 'D':\n-        printf(\"%f\", (double)val.d);\n-        break;\n-    case 'L':\n-    case '[':\n-        printf(\"0x%p\", val.l);\n-        break;\n-    case 'Z':\n-        printf(\"0x%x\", val.z);\n-        break;\n-    case 'B':\n-        printf(\"%d\", val.b);\n-        break;\n-    case 'S':\n-        printf(\"%d\", val.s);\n-        break;\n-    case 'C':\n-        printf(\"0x%x\", val.c);\n-        break;\n-    case 'I':\n-        printf(\"%d\", val.i);\n-        break;\n-    default:\n-        printf(\"0x%x%08x\", (jint)(val.j >> 32), (jint)val.j);\n-        break;\n-    }\n-}\n-\n-int isEqual(JNIEnv *env, char *sig, jvalue v1, jvalue v2) {\n-    switch (*sig) {\n-    case 'J':\n-        return (v1.j == v2.j);\n-    case 'F':\n-        return (v1.f == v2.f);\n-    case 'D':\n-        return (v1.d == v2.d);\n-    case 'L':\n-    case '[':\n-        return env->IsSameObject(v1.l, v2.l);\n-    case 'Z':\n-        return (v1.z == v2.z);\n-    case 'B':\n-        return (v1.b == v2.b);\n-    case 'S':\n-        return (v1.s == v2.s);\n-    case 'C':\n-        return (v1.c == v2.c);\n-    case 'I':\n-        return (v1.i == v2.i);\n-    default:\n-        return (1);\n-    }\n-}\n-\n-void JNICALL FieldModification(jvmtiEnv *jvmti_env, JNIEnv *env,\n-        jthread thr, jmethodID method, jlocation location,\n-        jclass field_klass, jobject obj,\n-        jfieldID field, char sig, jvalue new_value) {\n-    jvmtiError err;\n-    jclass cls;\n-    writable_watch_info watch;\n-    char *generic;\n-    size_t i;\n-\n-    eventsCount++;\n-    if (printdump == JNI_TRUE) {\n-        printf(\">>> retrieving modification watch info ...\\n\");\n-    }\n-    watch.fid = field;\n-    watch.loc = location;\n-    watch.is_static = (obj == NULL) ? JNI_TRUE : JNI_FALSE;\n-    watch.val = new_value;\n-    err = jvmti_env->GetMethodDeclaringClass(method, &cls);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(GetMethodDeclaringClass) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-        return;\n-    }\n-    err = jvmti_env->GetClassSignature(cls,\n-        &watch.m_cls, &generic);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(GetClassSignature) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-        return;\n-    }\n-    err = jvmti_env->GetMethodName(method, &watch.m_name, &watch.m_sig, &generic);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(GetMethodName) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-        return;\n-    }\n-    err = jvmti_env->GetClassSignature(field_klass,\n-        &watch.f_cls, &generic);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(GetClassSignature) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-        return;\n-    }\n-    err = jvmti_env->GetFieldName(field_klass, field,\n-        &watch.f_name, &watch.f_sig, &generic);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(GetFieldName) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-        return;\n-    }\n-    if (printdump == JNI_TRUE) {\n-        printf(\">>>      class: \\\"%s\\\"\\n\", watch.m_cls);\n-        printf(\">>>     method: \\\"%s%s\\\"\\n\", watch.m_name, watch.m_sig);\n-        printf(\">>>   location: 0x%x%08x\\n\",\n-            (jint)(watch.loc >> 32), (jint)watch.loc);\n-        printf(\">>>  field cls: \\\"%s\\\"\\n\", watch.f_cls);\n-        printf(\">>>      field: \\\"%s:%s\\\"\\n\", watch.f_name, watch.f_sig);\n-        printf(\">>>     object: 0x%p\\n\", obj);\n-        printf(\">>>  new value: \");\n-        printValue(watch.val, watch.f_sig);\n-        printf(\"\\n\");\n-    }\n-    for (i = 0; i < sizeof(watches)\/sizeof(watch_info); i++) {\n-        if (watch.fid == watches[i].fid) {\n-            if (watch.m_cls == NULL ||\n-                    strcmp(watch.m_cls, watches[i].m_cls) != 0) {\n-                printf(\"(watch#%\" PRIuPTR \") wrong class: \\\"%s\\\", expected: \\\"%s\\\"\\n\",\n-                       i, watch.m_cls, watches[i].m_cls);\n-                result = STATUS_FAILED;\n-            }\n-            if (watch.m_name == NULL ||\n-                    strcmp(watch.m_name, watches[i].m_name) != 0) {\n-                printf(\"(watch#%\" PRIuPTR \") wrong method name: \\\"%s\\\"\",\n-                       i, watch.m_name);\n-                printf(\", expected: \\\"%s\\\"\\n\", watches[i].m_name);\n-                result = STATUS_FAILED;\n-            }\n-            if (watch.m_sig == NULL ||\n-                    strcmp(watch.m_sig, watches[i].m_sig) != 0) {\n-                printf(\"(watch#%\" PRIuPTR \") wrong method sig: \\\"%s\\\"\",\n-                       i, watch.m_sig);\n-                printf(\", expected: \\\"%s\\\"\\n\", watches[i].m_sig);\n-                result = STATUS_FAILED;\n-            }\n-            if (watch.loc != watches[i].loc) {\n-                printf(\"(watch#%\" PRIuPTR \") wrong location: 0x%x%08x\",\n-                       i, (jint)(watch.loc >> 32), (jint)watch.loc);\n-                printf(\", expected: 0x%x%08x\\n\",\n-                       (jint)(watches[i].loc >> 32), (jint)watches[i].loc);\n-                result = STATUS_FAILED;\n-            }\n-            if (watch.f_name == NULL ||\n-                    strcmp(watch.f_name, watches[i].f_name) != 0) {\n-                printf(\"(watch#%\" PRIuPTR \") wrong field name: \\\"%s\\\"\",\n-                       i, watch.f_name);\n-                printf(\", expected: \\\"%s\\\"\\n\", watches[i].f_name);\n-                result = STATUS_FAILED;\n-            }\n-            if (watch.f_sig == NULL ||\n-                    strcmp(watch.f_sig, watches[i].f_sig) != 0) {\n-                printf(\"(watch#%\" PRIuPTR \") wrong field sig: \\\"%s\\\"\",\n-                       i, watch.f_sig);\n-                printf(\", expected: \\\"%s\\\"\\n\", watches[i].f_sig);\n-                result = STATUS_FAILED;\n-            }\n-            if (watch.is_static != watches[i].is_static) {\n-                printf(\"(watch#%\" PRIuPTR \") wrong field type: %s\", i,\n-                    (watch.is_static == JNI_TRUE) ? \"static\" : \"instance\");\n-                printf(\", expected: %s\\n\",\n-                    (watches[i].is_static == JNI_TRUE) ? \"static\" : \"instance\");\n-                result = STATUS_FAILED;\n-            }\n-            if (!isEqual((JNIEnv *)env, watch.f_sig, watch.val, watches[i].val)) {\n-                printf(\"(watch#%\" PRIuPTR \") wrong new value: \", i);\n-                printValue(watch.val, watch.f_sig);\n-                printf(\", expected: \");\n-                printValue(watches[i].val, watch.f_sig);\n-                printf(\"\\n\");\n-                result = STATUS_FAILED;\n-            }\n-            return;\n-        }\n-    }\n-    printf(\"Unexpected field modification catched: 0x%p\\n\", watch.fid);\n-    result = STATUS_FAILED;\n-}\n-\n-#ifdef STATIC_BUILD\n-JNIEXPORT jint JNICALL Agent_OnLoad_fieldmod002(JavaVM *jvm, char *options, void *reserved) {\n-    return Agent_Initialize(jvm, options, reserved);\n-}\n-JNIEXPORT jint JNICALL Agent_OnAttach_fieldmod002(JavaVM *jvm, char *options, void *reserved) {\n-    return Agent_Initialize(jvm, options, reserved);\n-}\n-JNIEXPORT jint JNI_OnLoad_fieldmod002(JavaVM *jvm, char *options, void *reserved) {\n-    return JNI_VERSION_1_8;\n-}\n-#endif\n-jint Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {\n-    jvmtiError err;\n-    jint res;\n-\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n-        printdump = JNI_TRUE;\n-    }\n-\n-    res = jvm->GetEnv((void **) &jvmti, JVMTI_VERSION_1_1);\n-    if (res != JNI_OK || jvmti == NULL) {\n-        printf(\"Wrong result of a valid call to GetEnv!\\n\");\n-        return JNI_ERR;\n-    }\n-\n-    err = jvmti->GetPotentialCapabilities(&caps);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(GetPotentialCapabilities) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        return JNI_ERR;\n-    }\n-\n-    err = jvmti->AddCapabilities(&caps);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(AddCapabilities) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        return JNI_ERR;\n-    }\n-\n-    err = jvmti->GetCapabilities(&caps);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(GetCapabilities) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        return JNI_ERR;\n-    }\n-\n-    if (caps.can_generate_field_modification_events) {\n-        callbacks.FieldModification = &FieldModification;\n-        err = jvmti->SetEventCallbacks(&callbacks, sizeof(callbacks));\n-        if (err != JVMTI_ERROR_NONE) {\n-            printf(\"(SetEventCallbacks) unexpected error: %s (%d)\\n\",\n-                   TranslateError(err), err);\n-            return JNI_ERR;\n-        }\n-\n-        err = jvmti->SetEventNotificationMode(JVMTI_ENABLE,\n-                JVMTI_EVENT_FIELD_MODIFICATION, NULL);\n-        if (err != JVMTI_ERROR_NONE) {\n-            printf(\"Failed to enable JVMTI_EVENT_FIELD_MODIFICATION: %s (%d)\\n\",\n-                   TranslateError(err), err);\n-            return JNI_ERR;\n-        }\n-    } else {\n-        printf(\"Warning: FieldModification watch is not implemented\\n\");\n-    }\n-\n-    return JNI_OK;\n-}\n-\n-JNIEXPORT void JNICALL\n-Java_nsk_jvmti_FieldModification_fieldmod002_getReady(JNIEnv *env, jclass clz) {\n-    jvmtiError err;\n-    jclass cls;\n-    jmethodID ctor;\n-    jintArray arr1, arr2;\n-    jobject obj1, obj2;\n-    size_t i;\n-\n-    if (!caps.can_generate_field_modification_events) {\n-        return;\n-    }\n-\n-    if (printdump == JNI_TRUE) {\n-        printf(\">>> setting field modification watches ...\\n\");\n-    }\n-    cls = env->FindClass(\"nsk\/jvmti\/FieldModification\/fieldmod002a\");\n-    if (cls == NULL) {\n-        printf(\"Cannot find fieldmod001a class!\\n\");\n-        result = STATUS_FAILED;\n-        return;\n-    }\n-    for (i = 0; i < sizeof(watches)\/sizeof(watch_info); i++) {\n-        if (watches[i].is_static == JNI_TRUE) {\n-            watches[i].fid = env->GetStaticFieldID(\n-                cls, watches[i].f_name, watches[i].f_sig);\n-        } else {\n-            watches[i].fid = env->GetFieldID(\n-                cls, watches[i].f_name, watches[i].f_sig);\n-        }\n-        if (watches[i].fid == NULL) {\n-            printf(\"Cannot get field ID for \\\"%s:%s\\\"\\n\",\n-                   watches[i].f_name, watches[i].f_sig);\n-            result = STATUS_FAILED;\n-            return;\n-        }\n-        err = jvmti->SetFieldModificationWatch(cls, watches[i].fid);\n-        if (err == JVMTI_ERROR_NONE) {\n-            eventsExpected++;\n-        } else {\n-            printf(\"(SetFieldModificationWatch#%\" PRIuPTR \") unexpected error: %s (%d)\\n\",\n-                   i, TranslateError(err), err);\n-            result = STATUS_FAILED;\n-        }\n-    }\n-\n-    ctor = env->GetMethodID(cls, \"<init>\", \"()V\");\n-    obj1 = env->NewGlobalRef(env->NewObject(cls, ctor));\n-    obj2 = env->NewGlobalRef(env->NewObject(cls, ctor));\n-    arr1 = (jintArray) env->NewGlobalRef(env->NewIntArray((jsize) 1));\n-    arr2 = (jintArray) env->NewGlobalRef(env->NewIntArray((jsize) 1));\n-\n-    watches[0].val.z = JNI_TRUE;\n-    watches[1].val.b = 1;\n-    watches[2].val.s = 2;\n-    watches[3].val.i = 3;\n-    watches[4].val.j = 4;\n-    watches[5].val.f = 0.5F;\n-    watches[6].val.d = 0.6;\n-    watches[7].val.c = 0x7;\n-    watches[8].val.l = obj1;\n-    watches[9].val.l = arr1;\n-\n-    watches[10].val.z = JNI_FALSE;\n-    watches[11].val.b = 10;\n-    watches[12].val.s = 20;\n-    watches[13].val.i = 30;\n-    watches[14].val.j = 40;\n-    watches[15].val.f = 0.05F;\n-    watches[16].val.d = 0.06;\n-    watches[17].val.c = 0x70;\n-    watches[18].val.l = obj2;\n-    watches[19].val.l = arr2;\n-\n-    if (printdump == JNI_TRUE) {\n-        printf(\">>> ... done\\n\");\n-    }\n-}\n-\n-JNIEXPORT jint JNICALL\n-Java_nsk_jvmti_FieldModification_fieldmod002_check(JNIEnv *env,\n-        jclass clz, jobject obj) {\n-    jclass cls;\n-\n-    if (!caps.can_generate_field_modification_events) {\n-        return PASSED;\n-    }\n-\n-    if (printdump == JNI_TRUE) {\n-        printf(\">>> modifying fields ...\\n\");\n-    }\n-\n-    cls = env->FindClass(\"nsk\/jvmti\/FieldModification\/fieldmod002a\");\n-    if (cls == NULL) {\n-        printf(\"Cannot find fieldmod001a class!\\n\");\n-        return STATUS_FAILED;\n-    }\n-\n-    env->SetStaticBooleanField(cls, watches[0].fid, watches[0].val.z);\n-    env->SetStaticByteField(cls, watches[1].fid, watches[1].val.b);\n-    env->SetStaticShortField(cls, watches[2].fid, watches[2].val.s);\n-    env->SetStaticIntField(cls, watches[3].fid, watches[3].val.i);\n-    env->SetStaticLongField(cls, watches[4].fid, watches[4].val.j);\n-    env->SetStaticFloatField(cls, watches[5].fid, watches[5].val.f);\n-    env->SetStaticDoubleField(cls, watches[6].fid, watches[6].val.d);\n-    env->SetStaticCharField(cls, watches[7].fid, watches[7].val.c);\n-    env->SetStaticObjectField(cls, watches[8].fid, watches[8].val.l);\n-    env->SetStaticObjectField(cls, watches[9].fid, watches[9].val.l);\n-\n-    env->SetBooleanField(obj, watches[10].fid, watches[10].val.z);\n-    env->SetByteField(obj, watches[11].fid, watches[11].val.b);\n-    env->SetShortField(obj, watches[12].fid, watches[12].val.s);\n-    env->SetIntField(obj, watches[13].fid, watches[13].val.i);\n-    env->SetLongField(obj, watches[14].fid, watches[14].val.j);\n-    env->SetFloatField(obj, watches[15].fid, watches[15].val.f);\n-    env->SetDoubleField(obj, watches[16].fid, watches[16].val.d);\n-    env->SetCharField(obj, watches[17].fid, watches[17].val.c);\n-    env->SetObjectField(obj, watches[18].fid, watches[18].val.l);\n-    env->SetObjectField(obj, watches[19].fid, watches[19].val.l);\n-\n-    if (printdump == JNI_TRUE) {\n-        printf(\">>> ... done\\n\");\n-    }\n-\n-    if (eventsCount != eventsExpected) {\n-        printf(\"Wrong number of field modification events: %d, expected: %d\\n\",\n-            eventsCount, eventsExpected);\n-        result = STATUS_FAILED;\n-    }\n-    return result;\n-}\n-\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/FieldModification\/fieldmod002\/fieldmod002.cpp","additions":0,"deletions":510,"binary":false,"changes":510,"status":"deleted"},{"patch":"@@ -1,33 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include \"native_thread.cpp\"\n-#include \"nsk_tools.cpp\"\n-#include \"jni_tools.cpp\"\n-#include \"jvmti_tools.cpp\"\n-#include \"agent_tools.cpp\"\n-#include \"jvmti_FollowRefObjects.cpp\"\n-#include \"Injector.cpp\"\n-#include \"JVMTITools.cpp\"\n-#include \"agent_common.cpp\"\n-#include \"fieldmod002.cpp\"\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/FieldModification\/fieldmod002\/libfieldmod002.cpp","additions":0,"deletions":33,"binary":false,"changes":33,"status":"deleted"},{"patch":"@@ -1,58 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package nsk.jvmti.FramePop;\n-\n-import java.io.PrintStream;\n-\n-public class framepop001 {\n-\n-    final static int JCK_STATUS_BASE = 95;\n-\n-    static {\n-        try {\n-            System.loadLibrary(\"framepop001\");\n-        } catch (UnsatisfiedLinkError ule) {\n-            System.err.println(\"Could not load framepop001 library\");\n-            System.err.println(\"java.library.path:\"\n-                + System.getProperty(\"java.library.path\"));\n-            throw ule;\n-        }\n-    }\n-\n-    native static int check();\n-\n-    public static void main(String args[]) {\n-        args = nsk.share.jvmti.JVMTITest.commonInit(args);\n-\n-        \/\/ produce JCK-like exit status.\n-        System.exit(run(args, System.out) + JCK_STATUS_BASE);\n-    }\n-\n-    public static int run(String args[], PrintStream out) {\n-        return check();\n-    }\n-\n-    public static void chain() {\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/FramePop\/framepop001.java","additions":0,"deletions":58,"binary":false,"changes":58,"status":"deleted"},{"patch":"@@ -1,47 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/*\n- * @test\n- *\n- * @summary converted from VM Testbase nsk\/jvmti\/FramePop\/framepop001.\n- * VM Testbase keywords: [quick, jpda, jvmti, noras]\n- * VM Testbase readme:\n- * DESCRIPTION\n- *     The test exercises JVMTI event callback function FramePop.\n- *     The test checks the following:\n- *       - if clazz, method and frame parameters contain expected values\n- *         for event generated upon exit from single method in single frame\n- *         specified in call to NotifyFramePop.\n- *       - if GetFrameLocation indentifies the executable location\n- *         in the returning method, immediately prior to the return.\n- * COMMENTS\n- *     Ported from JVMDI.\n- *\n- * @library \/vmTestbase\n- *          \/test\/lib\n- * @compile framepop001a.jasm\n- * @run main\/othervm\/native -agentlib:framepop001 nsk.jvmti.FramePop.framepop001\n- *\/\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/FramePop\/framepop001\/TestDescription.java","additions":0,"deletions":47,"binary":false,"changes":47,"status":"deleted"},{"patch":"@@ -1,289 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include <stdio.h>\n-#include <string.h>\n-#include <inttypes.h>\n-#include \"jvmti.h\"\n-#include \"agent_common.h\"\n-#include \"JVMTITools.h\"\n-\n-extern \"C\" {\n-\n-\n-#define PASSED 0\n-#define STATUS_FAILED 2\n-\n-typedef struct {\n-    const char *cls_sig;\n-    const char *name;\n-    const char *sig;\n-    jlocation loc;\n-} pop_info;\n-\n-static jvmtiEnv *jvmti = NULL;\n-static jvmtiCapabilities caps;\n-static jvmtiEventCallbacks callbacks;\n-static jint result = PASSED;\n-static jboolean printdump = JNI_FALSE;\n-static size_t eventsExpected = 0;\n-static size_t eventsCount = 0;\n-static pop_info pops[] = {\n-    { \"Lnsk\/jvmti\/FramePop\/framepop001;\", \"chain\", \"()V\", 0 },\n-    { \"Lnsk\/jvmti\/FramePop\/framepop001a;\", \"dummy\", \"()V\", 3 },\n-};\n-\n-void JNICALL Breakpoint(jvmtiEnv *jvmti_env, JNIEnv *env,\n-        jthread thr, jmethodID method, jlocation location) {\n-    jvmtiError err;\n-\n-    err = jvmti_env->NotifyFramePop(thr, 0);\n-    if (err == JVMTI_ERROR_NONE) {\n-        eventsExpected++;\n-    } else {\n-        printf(\"(NotifyFramePop#0) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-    }\n-\n-    err = jvmti_env->NotifyFramePop(thr, 1);\n-    if (err == JVMTI_ERROR_NONE) {\n-        eventsExpected++;\n-    } else {\n-        printf(\"(NotifyFramePop#1) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-    }\n-}\n-\n-void JNICALL FramePop(jvmtiEnv *jvmti_env, JNIEnv *env,\n-        jthread thr, jmethodID method, jboolean wasPopedByException) {\n-    jvmtiError err;\n-    char *cls_sig, *name, *sig, *generic;\n-    jclass cls;\n-    jmethodID mid;\n-    jlocation loc;\n-\n-    if (printdump == JNI_TRUE) {\n-        printf(\">>> retrieving frame pop info ...\\n\");\n-    }\n-    err = jvmti_env->GetMethodDeclaringClass(method, &cls);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(GetMethodDeclaringClass) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-        return;\n-    }\n-    err = jvmti_env->GetClassSignature(cls, &cls_sig, &generic);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(GetClassSignature) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-        return;\n-    }\n-    err = jvmti_env->GetMethodName(method, &name, &sig, &generic);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(GetMethodName) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-        return;\n-    }\n-    err = jvmti_env->GetFrameLocation(thr, 0, &mid, &loc);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(GetFrameLocation) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-    }\n-    if (printdump == JNI_TRUE) {\n-        printf(\">>>      class: \\\"%s\\\"\\n\", cls_sig);\n-        printf(\">>>     method: \\\"%s%s\\\"\\n\", name, sig);\n-        printf(\">>>   location: 0x%x%08x\\n\",\n-            (jint)(loc >> 32), (jint)loc);\n-        printf(\">>> ... done\\n\");\n-    }\n-    if (eventsCount < sizeof(pops)\/sizeof(pop_info)) {\n-        if (cls_sig == NULL ||\n-                strcmp(cls_sig, pops[eventsCount].cls_sig) != 0) {\n-            printf(\"(pop#%\" PRIuPTR \") wrong class: \\\"%s\\\"\",\n-                   eventsCount, cls_sig);\n-            printf(\", expected: \\\"%s\\\"\\n\", pops[eventsCount].cls_sig);\n-            result = STATUS_FAILED;\n-        }\n-        if (name == NULL ||\n-                strcmp(name, pops[eventsCount].name) != 0) {\n-            printf(\"(pop#%\" PRIuPTR \") wrong method name: \\\"%s\\\"\",\n-                   eventsCount, name);\n-            printf(\", expected: \\\"%s\\\"\\n\", pops[eventsCount].name);\n-            result = STATUS_FAILED;\n-        }\n-        if (sig == NULL ||\n-                strcmp(sig, pops[eventsCount].sig) != 0) {\n-            printf(\"(pop#%\" PRIuPTR \") wrong method sig: \\\"%s\\\"\",\n-                   eventsCount, sig);\n-            printf(\", expected: \\\"%s\\\"\\n\", pops[eventsCount].sig);\n-            result = STATUS_FAILED;\n-        }\n-        if (loc != pops[eventsCount].loc) {\n-            printf(\"(pop#%\" PRIuPTR \") wrong location: 0x%x%08x\",\n-                   eventsCount, (jint)(loc >> 32), (jint)loc);\n-            printf(\", expected: 0x%x\\n\", (jint)pops[eventsCount].loc);\n-            result = STATUS_FAILED;\n-        }\n-    } else {\n-        printf(\"Unexpected frame pop catched:\");\n-        printf(\"     class: \\\"%s\\\"\\n\", cls_sig);\n-        printf(\"    method: \\\"%s%s\\\"\\n\", name, sig);\n-        printf(\"  location: 0x%x%08x\\n\", (jint)(loc >> 32), (jint)loc);\n-        result = STATUS_FAILED;\n-    }\n-    eventsCount++;\n-}\n-\n-#ifdef STATIC_BUILD\n-JNIEXPORT jint JNICALL Agent_OnLoad_framepop001(JavaVM *jvm, char *options, void *reserved) {\n-    return Agent_Initialize(jvm, options, reserved);\n-}\n-JNIEXPORT jint JNICALL Agent_OnAttach_framepop001(JavaVM *jvm, char *options, void *reserved) {\n-    return Agent_Initialize(jvm, options, reserved);\n-}\n-JNIEXPORT jint JNI_OnLoad_framepop001(JavaVM *jvm, char *options, void *reserved) {\n-    return JNI_VERSION_1_8;\n-}\n-#endif\n-jint Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {\n-    jvmtiError err;\n-    jint res;\n-\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n-        printdump = JNI_TRUE;\n-    }\n-\n-    res = jvm->GetEnv((void **) &jvmti, JVMTI_VERSION_1_1);\n-    if (res != JNI_OK || jvmti == NULL) {\n-        printf(\"Wrong result of a valid call to GetEnv!\\n\");\n-        return JNI_ERR;\n-    }\n-\n-    err = jvmti->GetPotentialCapabilities(&caps);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(GetPotentialCapabilities) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        return JNI_ERR;\n-    }\n-\n-    err = jvmti->AddCapabilities(&caps);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(AddCapabilities) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        return JNI_ERR;\n-    }\n-\n-    err = jvmti->GetCapabilities(&caps);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(GetCapabilities) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        return JNI_ERR;\n-    }\n-\n-    if (caps.can_generate_frame_pop_events &&\n-            caps.can_generate_breakpoint_events) {\n-        callbacks.Breakpoint = &Breakpoint;\n-        callbacks.FramePop = &FramePop;\n-        err = jvmti->SetEventCallbacks(&callbacks, sizeof(callbacks));\n-        if (err != JVMTI_ERROR_NONE) {\n-            printf(\"(SetEventCallbacks) unexpected error: %s (%d)\\n\",\n-                   TranslateError(err), err);\n-            return JNI_ERR;\n-        }\n-    } else {\n-        printf(\"Warning: FramePop or Breakpoint event is not implemented\\n\");\n-    }\n-\n-    return JNI_OK;\n-}\n-\n-JNIEXPORT jint JNICALL\n-Java_nsk_jvmti_FramePop_framepop001_check(JNIEnv *env, jclass cls) {\n-    jvmtiError err;\n-    jclass clz;\n-    jmethodID mid;\n-\n-    if (jvmti == NULL) {\n-        printf(\"JVMTI client was not properly loaded!\\n\");\n-        return STATUS_FAILED;\n-    }\n-\n-    if (!caps.can_generate_frame_pop_events ||\n-            !caps.can_generate_breakpoint_events) {\n-        return result;\n-    }\n-\n-    mid = env->GetStaticMethodID(cls, \"chain\", \"()V\");\n-    if (mid == 0) {\n-        printf(\"Cannot find Method ID for method chain\\n\");\n-        return STATUS_FAILED;\n-    }\n-    err = jvmti->SetBreakpoint(mid, 0);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"Failed to SetBreakpoint: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        return STATUS_FAILED;\n-    }\n-    err = jvmti->SetEventNotificationMode(JVMTI_ENABLE,\n-        JVMTI_EVENT_FRAME_POP, NULL);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"Failed to enable JVMTI_EVENT_FRAME_POP event: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-    }\n-    err = jvmti->SetEventNotificationMode(JVMTI_ENABLE,\n-        JVMTI_EVENT_BREAKPOINT, NULL);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"Failed to enable BREAKPOINT event: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-    }\n-\n-    clz = env->FindClass(\"nsk\/jvmti\/FramePop\/framepop001a\");\n-    if (clz == NULL) {\n-        printf(\"Cannot find framepop001a class!\\n\");\n-        result = STATUS_FAILED;\n-        return STATUS_FAILED;\n-    }\n-    mid = env->GetStaticMethodID(clz, \"dummy\", \"()V\");\n-    if (mid == 0) {\n-        printf(\"Cannot find Method ID for method dummy\\n\");\n-        return STATUS_FAILED;\n-    }\n-    env->CallStaticVoidMethod(clz, mid);\n-\n-    if (eventsCount != eventsExpected) {\n-        printf(\"Wrong number of frame pop events: %\" PRIuPTR \", expected: %\" PRIuPTR \"\\n\",\n-            eventsCount, eventsExpected);\n-        result = STATUS_FAILED;\n-    }\n-\n-    return result;\n-}\n-\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/FramePop\/framepop001\/framepop001.cpp","additions":0,"deletions":289,"binary":false,"changes":289,"status":"deleted"},{"patch":"@@ -1,38 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package nsk\/jvmti\/FramePop;\n-\n-super public class framepop001a {\n-\n-    public Method \"<init>\":\"()V\" stack 1 locals 1 {\n-        aload_0;\n-        invokespecial   Method java\/lang\/Object.\"<init>\":\"()V\";\n-        return;\n-    }\n-\n-    public static Method dummy:\"()V\" stack 0 locals 0 {\n-        invokestatic    Method framepop001.chain:\"()V\";\n-        return; \/\/ bci=3\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/FramePop\/framepop001\/framepop001a.jasm","additions":0,"deletions":38,"binary":false,"changes":38,"status":"deleted"},{"patch":"@@ -1,33 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include \"native_thread.cpp\"\n-#include \"nsk_tools.cpp\"\n-#include \"jni_tools.cpp\"\n-#include \"jvmti_tools.cpp\"\n-#include \"agent_tools.cpp\"\n-#include \"jvmti_FollowRefObjects.cpp\"\n-#include \"Injector.cpp\"\n-#include \"JVMTITools.cpp\"\n-#include \"agent_common.cpp\"\n-#include \"framepop001.cpp\"\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/FramePop\/framepop001\/libframepop001.cpp","additions":0,"deletions":33,"binary":false,"changes":33,"status":"deleted"},{"patch":"@@ -1,88 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package nsk.jvmti.FramePop;\n-\n-import java.io.PrintStream;\n-\n-public class framepop002 {\n-\n-    final static int JCK_STATUS_BASE = 95;\n-    final static int THREADS_LIMIT = 20;\n-    final static int NESTING_DEPTH = 100;\n-    final static String TEST_THREAD_NAME_BASE = \"Test Thread #\";\n-\n-    static {\n-        try {\n-            System.loadLibrary(\"framepop002\");\n-        } catch (UnsatisfiedLinkError ule) {\n-            System.err.println(\"Could not load framepop002 library\");\n-            System.err.println(\"java.library.path:\"\n-                + System.getProperty(\"java.library.path\"));\n-            throw ule;\n-        }\n-    }\n-\n-    native static void getReady();\n-    native static int check();\n-\n-    public static void main(String args[]) {\n-        args = nsk.share.jvmti.JVMTITest.commonInit(args);\n-\n-        \/\/ produce JCK-like exit status.\n-        System.exit(run(args, System.out) + JCK_STATUS_BASE);\n-    }\n-\n-    public static int run(String args[], PrintStream out) {\n-        TestThread[] t = new TestThread[THREADS_LIMIT];\n-        getReady();\n-        for (int i = 0; i < THREADS_LIMIT; i++) {\n-            t[i] = new TestThread(TEST_THREAD_NAME_BASE + i);\n-            t[i].start();\n-        }\n-        for (int i = 0; i < THREADS_LIMIT; i++) {\n-            try {\n-                t[i].join();\n-            } catch (InterruptedException e) {\n-                throw new Error(\"Unexpected: \" + e);\n-            }\n-        }\n-        return check();\n-    }\n-\n-    static class TestThread extends Thread {\n-        int nestingCount = 0;\n-\n-        \/\/ Constructor\n-        TestThread(String name) {\n-            super(name);\n-        }\n-\n-        public void run() {\n-            if (nestingCount < NESTING_DEPTH) {\n-                nestingCount++;\n-                run();\n-            }\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/FramePop\/framepop002.java","additions":0,"deletions":88,"binary":false,"changes":88,"status":"deleted"},{"patch":"@@ -1,46 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/*\n- * @test\n- *\n- * @summary converted from VM Testbase nsk\/jvmti\/FramePop\/framepop002.\n- * VM Testbase keywords: [quick, jpda, jvmti, noras]\n- * VM Testbase readme:\n- * DESCRIPTION\n- *     The test exercises JVMTI event callback function FramePop.\n- *     The test do some nesting\/recursive calls watching frame pop\n- *     events to be uniquely identified by thread\/class\/method\/frame_depth.\n- * COMMENTS\n- *     The test was created as a result of investigating the following bugs\n- *     intended to write a regression test:\n- *     4335224 Bug 4245697 not completely fixed jevent.u.frame.frame incorrect\n- *     4504077 java: dbx should not hold on to a frameid after thread suspension\n- *     Ported from JVMDI.\n- *\n- * @library \/vmTestbase\n- *          \/test\/lib\n- * @run main\/othervm\/native -agentlib:framepop002 nsk.jvmti.FramePop.framepop002\n- *\/\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/FramePop\/framepop002\/TestDescription.java","additions":0,"deletions":46,"binary":false,"changes":46,"status":"deleted"},{"patch":"@@ -1,477 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include <stdio.h>\n-#include <stdlib.h>\n-#include <string.h>\n-#include \"jvmti.h\"\n-#include \"agent_common.h\"\n-#include \"JVMTITools.h\"\n-#include \"jvmti_tools.h\"\n-\n-extern \"C\" {\n-\n-\n-#define PASSED 0\n-#define STATUS_FAILED 2\n-#define MAX_THREADS 32\n-\n-typedef struct item *item_t;\n-struct item {\n-    item_t next;\n-    jmethodID method;\n-    int depth;\n-} item;\n-\n-typedef struct thr {\n-    jthread thread;\n-    item_t tos;\n-} thr;\n-\n-static jvmtiEnv *jvmti = NULL;\n-static jvmtiCapabilities caps;\n-static jvmtiEventCallbacks callbacks;\n-static jrawMonitorID event_lock;\n-static jint result = PASSED;\n-static jboolean printdump = JNI_FALSE;\n-static jboolean watch_events = JNI_FALSE;\n-\n-static int pop_count = 0;\n-static int push_count = 0;\n-static int thr_count = 0;\n-static int max_depth = 0;\n-static thr threads[MAX_THREADS];\n-\n-static volatile int callbacksEnabled = NSK_FALSE;\n-static jrawMonitorID agent_lock;\n-\n-static\n-int isTestThread(jvmtiEnv *jvmti_env, jthread thr) {\n-    jvmtiError err;\n-    jvmtiThreadInfo inf;\n-    const char* TEST_THREAD_NAME_BASE = \"Test Thread\";\n-\n-    err = jvmti_env->GetThreadInfo(thr, &inf);\n-    if (err != JVMTI_ERROR_NONE) {\n-         printf(\"(GetThreadInfo) unexpected error: %s (%d)\\n\", TranslateError(err), err);\n-         result = STATUS_FAILED;\n-         return 0;\n-    }\n-    return strncmp(inf.name, TEST_THREAD_NAME_BASE, strlen(TEST_THREAD_NAME_BASE)) == 0;\n-}\n-\n-static\n-void printInfo(jvmtiEnv *jvmti_env, jthread thr, jmethodID method, int depth) {\n-    jvmtiError err;\n-    jvmtiThreadInfo inf;\n-    char *clsig, *name, *sig, *generic;\n-    jclass cls;\n-\n-    err = jvmti_env->GetThreadInfo(thr, &inf);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(GetThreadInfo) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-    }\n-\n-    err = jvmti_env->GetMethodDeclaringClass(method, &cls);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(GetMethodDeclaringClass) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-        return;\n-    }\n-\n-    err = jvmti_env->GetClassSignature(cls, &clsig, &generic);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(GetClassSignature) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-        return;\n-    }\n-\n-    err = jvmti_env->GetMethodName(method, &name, &sig, &generic);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(GetMethodName) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-        return;\n-    }\n-\n-    printf(\"  %s: %s.%s%s, depth = %d\\n\", inf.name, clsig, name, sig, depth);\n-\n-    jvmti_env->Deallocate((unsigned char *)sig);\n-    jvmti_env->Deallocate((unsigned char *)name);\n-    jvmti_env->Deallocate((unsigned char *)clsig);\n-    jvmti_env->Deallocate((unsigned char *)inf.name);\n-}\n-\n-static\n-void pop(jvmtiEnv *jvmti_env, JNIEnv *env, jthread thr, jmethodID method, int depth) {\n-    item_t old;\n-    int i, count = 0;\n-\n-    for (i = 0; i < thr_count; i++) {\n-        if (env->IsSameObject(threads[i].thread, thr)) {\n-            break;\n-        }\n-    }\n-\n-    if (i == thr_count) {\n-        watch_events = JNI_FALSE;\n-        printf(\"Unknown thread:\\n\");\n-        printInfo(jvmti_env, thr, method, depth);\n-        result = STATUS_FAILED;\n-        return;\n-    }\n-\n-    if (threads[i].tos == NULL) {\n-        watch_events = JNI_FALSE;\n-        printf(\"Stack underflow:\\n\");\n-        printInfo(jvmti_env, thr, method, depth);\n-        result = STATUS_FAILED;\n-        return;\n-    }\n-\n-    do {\n-        pop_count++;\n-        old = threads[i].tos;\n-        threads[i].tos = threads[i].tos->next;\n-        if (old->method == method && old->depth == depth) {\n-            free(old);\n-            return;\n-        }\n-        free(old);\n-    } while (threads[i].tos != NULL);\n-\n-    watch_events = JNI_FALSE;\n-    printf(\"Frame pop does not match any entry:\\n\");\n-    printInfo(jvmti_env, thr, method, depth);\n-    result = STATUS_FAILED;\n-}\n-\n-static\n-void push(JNIEnv *env, jthread thr, jmethodID method, int depth) {\n-    item_t new_item;\n-    int i;\n-\n-    for (i = 0; i < thr_count; i++) {\n-        if (env->IsSameObject(threads[i].thread, thr)) {\n-            break;\n-        }\n-    }\n-\n-    if (i == thr_count) {\n-        thr_count++;\n-        if (thr_count == MAX_THREADS) {\n-            watch_events = JNI_FALSE;\n-            printf(\"Out of threads\\n\");\n-            result = STATUS_FAILED;\n-            return;\n-        }\n-        threads[i].thread = env->NewGlobalRef(thr);\n-        threads[i].tos = NULL;\n-    }\n-\n-    new_item = (item_t)malloc(sizeof(item));\n-    if (new_item == NULL) {\n-        watch_events = JNI_FALSE;\n-        printf(\"Out of memory\\n\");\n-        result = STATUS_FAILED;\n-        return;\n-    }\n-\n-    new_item->next = threads[i].tos;\n-    new_item->method = method;\n-    new_item->depth = depth;\n-    threads[i].tos = new_item;\n-    push_count++;\n-    max_depth = (max_depth < depth) ? depth : max_depth;\n-}\n-\n-void JNICALL MethodEntry(jvmtiEnv *jvmti_env, JNIEnv *env,\n-        jthread thr, jmethodID method) {\n-    jvmtiError err;\n-    jboolean isNative;\n-    jint frameCount;\n-\n-    if (watch_events == JNI_FALSE) return;\n-\n-    jvmti->RawMonitorEnter(agent_lock);\n-\n-    if (!callbacksEnabled) {\n-        jvmti->RawMonitorExit(agent_lock);\n-        return;\n-    }\n-\n-    err = jvmti_env->GetFrameCount(thr, &frameCount);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(GetFrameCount#entry) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        printInfo(jvmti_env, thr, method, frameCount);\n-        result = STATUS_FAILED;\n-        jvmti->RawMonitorExit(agent_lock);\n-        return;\n-    }\n-\n-    err = jvmti_env->IsMethodNative(method, &isNative);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(IsMethodNative) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        printInfo(jvmti_env, thr, method, frameCount);\n-        result = STATUS_FAILED;\n-    }\n-\n-    if (isTestThread(jvmti_env, thr)) {\n-        if (printdump == JNI_TRUE) {\n-            printf(\">>> %sMethod entry\\n>>>\",\n-                   (isNative == JNI_TRUE) ? \"Native \" : \"\");\n-            printInfo(jvmti_env, thr, method, frameCount);\n-        }\n-        if (isNative == JNI_FALSE) {\n-            err = jvmti_env->RawMonitorEnter(event_lock);\n-            if (err != JVMTI_ERROR_NONE) {\n-                printf(\"(RawMonitorEnter) unexpected error: %s (%d)\\n\",\n-                       TranslateError(err), err);\n-                printInfo(jvmti_env, thr, method, frameCount);\n-                result = STATUS_FAILED;\n-            }\n-            push((JNIEnv *)env, thr, method, frameCount);\n-            err = jvmti_env->RawMonitorExit(event_lock);\n-            if (err != JVMTI_ERROR_NONE) {\n-                printf(\"(RawMonitorExit) unexpected error: %s (%d)\\n\",\n-                       TranslateError(err), err);\n-                printInfo(jvmti_env, thr, method, frameCount);\n-                result = STATUS_FAILED;\n-            }\n-            err = jvmti_env->NotifyFramePop(thr, 0);\n-            if (err != JVMTI_ERROR_NONE) {\n-                printf(\"(NotifyFramePop) unexpected error: %s (%d)\\n\",\n-                       TranslateError(err), err);\n-                printInfo(jvmti_env, thr, method, frameCount);\n-                result = STATUS_FAILED;\n-            }\n-        }\n-    }\n-\n-    jvmti->RawMonitorExit(agent_lock);\n-}\n-\n-void JNICALL VMStart(jvmtiEnv *jvmti_env, JNIEnv* jni_env) {\n-    jvmti->RawMonitorEnter(agent_lock);\n-\n-    callbacksEnabled = NSK_TRUE;\n-\n-    jvmti->RawMonitorExit(agent_lock);\n-}\n-\n-\n-void JNICALL VMDeath(jvmtiEnv *jvmti_env, JNIEnv* jni_env) {\n-    jvmti->RawMonitorEnter(agent_lock);\n-\n-    callbacksEnabled = NSK_FALSE;\n-\n-    jvmti->RawMonitorExit(agent_lock);\n-}\n-\n-void JNICALL FramePop(jvmtiEnv *jvmti_env, JNIEnv *env,\n-        jthread thr, jmethodID method, jboolean wasPopedByException) {\n-    jvmtiError err;\n-    jint frameCount;\n-\n-    jvmti->RawMonitorEnter(agent_lock);\n-\n-    if (!callbacksEnabled) {\n-        jvmti->RawMonitorExit(agent_lock);\n-        return;\n-    }\n-    err = jvmti_env->GetFrameCount(thr, &frameCount);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(GetFrameCount#entry) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        printInfo(jvmti_env, thr, method, frameCount);\n-        result = STATUS_FAILED;\n-        jvmti->RawMonitorExit(agent_lock);\n-        return;\n-    }\n-\n-    if (isTestThread(jvmti_env, thr)) {\n-        if (printdump == JNI_TRUE) {\n-            printf(\">>> Frame Pop\\n>>>\");\n-            printInfo(jvmti_env, thr, method, frameCount);\n-        }\n-        err = jvmti_env->RawMonitorEnter(event_lock);\n-        if (err != JVMTI_ERROR_NONE) {\n-            printf(\"(RawMonitorEnter) unexpected error: %s (%d)\\n\",\n-                   TranslateError(err), err);\n-            printInfo(jvmti_env, thr, method, frameCount);\n-            result = STATUS_FAILED;\n-        }\n-        pop(jvmti_env, (JNIEnv *)env, thr, method, frameCount);\n-        err = jvmti_env->RawMonitorExit(event_lock);\n-        if (err != JVMTI_ERROR_NONE) {\n-            printf(\"(RawMonitorExit) unexpected error: %s (%d)\\n\",\n-                   TranslateError(err), err);\n-            printInfo(jvmti_env, thr, method, frameCount);\n-            result = STATUS_FAILED;\n-        }\n-    }\n-\n-    jvmti->RawMonitorExit(agent_lock);\n-}\n-\n-#ifdef STATIC_BUILD\n-JNIEXPORT jint JNICALL Agent_OnLoad_framepop002(JavaVM *jvm, char *options, void *reserved) {\n-    return Agent_Initialize(jvm, options, reserved);\n-}\n-JNIEXPORT jint JNICALL Agent_OnAttach_framepop002(JavaVM *jvm, char *options, void *reserved) {\n-    return Agent_Initialize(jvm, options, reserved);\n-}\n-JNIEXPORT jint JNI_OnLoad_framepop002(JavaVM *jvm, char *options, void *reserved) {\n-    return JNI_VERSION_1_8;\n-}\n-#endif\n-jint Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {\n-    jvmtiError err;\n-    jint res;\n-\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n-        printdump = JNI_TRUE;\n-    }\n-\n-    res = jvm->GetEnv((void **) &jvmti, JVMTI_VERSION_1_1);\n-    if (res != JNI_OK || jvmti == NULL) {\n-        printf(\"Wrong result of a valid call to GetEnv!\\n\");\n-        return JNI_ERR;\n-    }\n-\n-    err = jvmti->CreateRawMonitor(\"_event_lock\", &event_lock);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(CreateRawMonitor) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        return JNI_ERR;\n-    }\n-\n-    err = jvmti->GetPotentialCapabilities(&caps);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(GetPotentialCapabilities) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        return JNI_ERR;\n-    }\n-\n-    err = jvmti->AddCapabilities(&caps);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(AddCapabilities) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        return JNI_ERR;\n-    }\n-\n-    err = jvmti->GetCapabilities(&caps);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(GetCapabilities) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        return JNI_ERR;\n-    }\n-\n-    if (caps.can_generate_frame_pop_events &&\n-            caps.can_generate_method_entry_events) {\n-        callbacks.MethodEntry = &MethodEntry;\n-        callbacks.FramePop = &FramePop;\n-        callbacks.VMStart = &VMStart;\n-        callbacks.VMDeath = &VMDeath;\n-\n-        err = jvmti->SetEventCallbacks(&callbacks, sizeof(callbacks));\n-        if (err != JVMTI_ERROR_NONE) {\n-            printf(\"(SetEventCallbacks) unexpected error: %s (%d)\\n\",\n-                   TranslateError(err), err);\n-            return JNI_ERR;\n-        }\n-        if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_START, NULL)))\n-            return JNI_ERR;\n-        if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_DEATH, NULL)))\n-            return JNI_ERR;\n-\n-        if (jvmti->CreateRawMonitor(\"agent_lock\", &agent_lock) != JVMTI_ERROR_NONE) {\n-            return JNI_ERR;\n-        }\n-\n-    } else {\n-        printf(\"Warning: FramePop or MethodEntry event is not implemented\\n\");\n-    }\n-\n-    return JNI_OK;\n-}\n-\n-JNIEXPORT void JNICALL Java_nsk_jvmti_FramePop_framepop002_getReady(JNIEnv *env, jclass cls) {\n-    jvmtiError err;\n-\n-    if (!caps.can_generate_frame_pop_events ||\n-            !caps.can_generate_method_entry_events) {\n-        return ;\n-    }\n-\n-    err = jvmti->SetEventNotificationMode(JVMTI_ENABLE,\n-         JVMTI_EVENT_METHOD_ENTRY, NULL);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"Failed to enable JVMTI_EVENT_METHOD_ENTRY event: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-    }\n-    err = jvmti->SetEventNotificationMode(JVMTI_ENABLE,\n-         JVMTI_EVENT_FRAME_POP, NULL);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"Failed to enable JVMTI_EVENT_FRAME_POP event: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-    }\n-    watch_events = JNI_TRUE;\n-}\n-\n-JNIEXPORT jint JNICALL Java_nsk_jvmti_FramePop_framepop002_check(JNIEnv *env, jclass cls) {\n-    jvmtiError err;\n-\n-    watch_events = JNI_FALSE;\n-    err = jvmti->SetEventNotificationMode(JVMTI_DISABLE,\n-         JVMTI_EVENT_FRAME_POP, NULL);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"Failed to disable JVMTI_EVENT_FRAME_POP event: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-    }\n-    err = jvmti->SetEventNotificationMode(JVMTI_DISABLE,\n-         JVMTI_EVENT_METHOD_ENTRY, NULL);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"Failed to disable JVMTI_EVENT_METHOD_ENTRY event: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-    }\n-\n-    if (printdump == JNI_TRUE) {\n-        printf(\"%d threads, %d method entrys, %d frame pops, max depth = %d\\n\",\n-               thr_count, push_count, pop_count, max_depth);\n-    }\n-\n-    return result;\n-}\n-\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/FramePop\/framepop002\/framepop002.cpp","additions":0,"deletions":477,"binary":false,"changes":477,"status":"deleted"},{"patch":"@@ -1,33 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include \"native_thread.cpp\"\n-#include \"nsk_tools.cpp\"\n-#include \"jni_tools.cpp\"\n-#include \"jvmti_tools.cpp\"\n-#include \"agent_tools.cpp\"\n-#include \"jvmti_FollowRefObjects.cpp\"\n-#include \"Injector.cpp\"\n-#include \"JVMTITools.cpp\"\n-#include \"agent_common.cpp\"\n-#include \"framepop002.cpp\"\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/FramePop\/framepop002\/libframepop002.cpp","additions":0,"deletions":33,"binary":false,"changes":33,"status":"deleted"},{"patch":"@@ -1,188 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package nsk.jvmti.GetCurrentContendedMonitor;\n-\n-import java.io.PrintStream;\n-\n-public class contmon001 {\n-\n-    native static void checkMon(int point, Thread thr, Object mon);\n-    native static int getRes();\n-\n-    static {\n-        try {\n-            System.loadLibrary(\"contmon001\");\n-        } catch (UnsatisfiedLinkError ule) {\n-            System.err.println(\"Could not load contmon001 library\");\n-            System.err.println(\"java.library.path:\"\n-                + System.getProperty(\"java.library.path\"));\n-            throw ule;\n-        }\n-    }\n-\n-    public static volatile boolean startingBarrier = true;\n-    public static volatile boolean waitingBarrier = true;\n-    static Object lockFld = new Object();\n-\n-    static boolean DEBUG_MODE = false;\n-    static PrintStream out;\n-\n-    public static void main(String[] args) {\n-        args = nsk.share.jvmti.JVMTITest.commonInit(args);\n-\n-        System.exit(run(args, System.out) + 95\/*STATUS_TEMP*\/);\n-    }\n-\n-    public static void doSleep() {\n-        try {\n-            Thread.sleep(10);\n-        } catch (Exception e) {\n-            throw new Error(\"Unexpected \" + e);\n-        }\n-    }\n-\n-    public static int run(String argv[], PrintStream ref) {\n-        out = ref;\n-        for (int i = 0; i < argv.length; i++) {\n-            if (argv[i].equals(\"-v\")) \/\/ verbose mode\n-                DEBUG_MODE = true;\n-        }\n-\n-        Object lock = new Object();\n-        Thread currThr = Thread.currentThread();\n-\n-        if (DEBUG_MODE)\n-            out.println(\"\\nCheck #1: verifying a contended monitor of current thread \\\"\"\n-                + currThr.getName() + \"\\\" ...\");\n-        synchronized (lock) {\n-            checkMon(1, currThr, null);\n-        }\n-        if (DEBUG_MODE)\n-            out.println(\"Check #1 done\");\n-\n-        contmon001a thr = new contmon001a();\n-\n-        thr.start();\n-        if (DEBUG_MODE)\n-            out.println(\"\\nWaiting for auxiliary thread ...\");\n-        while (startingBarrier) {\n-            doSleep();\n-        }\n-        if (DEBUG_MODE)\n-            out.println(\"Auxiliary thread is ready\");\n-\n-        if (DEBUG_MODE)\n-            out.println(\"\\nCheck #3: verifying a contended monitor of auxiliary thread ...\");\n-        checkMon(3, thr, null);\n-        if (DEBUG_MODE)\n-            out.println(\"Check #3 done\");\n-\n-        thr.letItGo();\n-\n-        while (waitingBarrier) {\n-            doSleep();\n-        }\n-        synchronized (lockFld) {\n-            if (DEBUG_MODE)\n-                out.println(\"\\nMain thread entered lockFld's monitor\"\n-                    + \"\\n\\tand calling lockFld.notifyAll() to awake auxiliary thread\");\n-            lockFld.notifyAll();\n-            if (DEBUG_MODE)\n-                out.println(\"\\nCheck #4: verifying a contended monitor of auxiliary thread ...\");\n-            checkMon(4, thr, lockFld);\n-            if (DEBUG_MODE)\n-                out.println(\"Check #4 done\");\n-        }\n-\n-        if (DEBUG_MODE)\n-            out.println(\"\\nMain thread released lockFld's monitor\"\n-                + \"\\n\\tand waiting for auxiliary thread death ...\");\n-\n-        try {\n-            thr.join();\n-        } catch (InterruptedException e) {\n-            throw new Error(\"Unexpected \" + e);\n-        }\n-        if (DEBUG_MODE)\n-            out.println(\"\\nCheck #5: verifying a contended monitor of dead auxiliary thread ...\");\n-        checkMon(5, thr, null);\n-        if (DEBUG_MODE)\n-            out.println(\"Check #5 done\");\n-\n-        return getRes();\n-    }\n-}\n-\n-\n-class contmon001a extends Thread {\n-    private volatile boolean flag = true;\n-\n-    public void run() {\n-        if (contmon001.DEBUG_MODE)\n-            contmon001.out.println(\"check #2: verifying a contended monitor of current auxiliary thread ...\");\n-        contmon001.checkMon(2, currentThread(), null);\n-        if (contmon001.DEBUG_MODE)\n-            contmon001.out.println(\"check #2 done\");\n-\n-        if (contmon001.DEBUG_MODE)\n-            contmon001.out.println(\"notifying main thread\");\n-        contmon001.startingBarrier = false;\n-\n-        if (contmon001.DEBUG_MODE)\n-            contmon001.out.println(\"thread is going to loop while <flag> is true ...\");\n-        int i = 0;\n-        int n = 1000;\n-        while (flag) {\n-            if (n <= 0) {\n-                n = 1000;\n-            }\n-            if (i > n) {\n-                i = 0;\n-                n--;\n-            }\n-            i++;\n-        }\n-        if (contmon001.DEBUG_MODE)\n-            contmon001.out.println(\"looping is done: <flag> is false\");\n-\n-        synchronized (contmon001.lockFld) {\n-            contmon001.waitingBarrier = false;\n-            if (contmon001.DEBUG_MODE)\n-                contmon001.out.println(\"\\nthread entered lockFld's monitor\"\n-                    + \"\\n\\tand releasing it through the lockFld.wait() call\");\n-            try {\n-                contmon001.lockFld.wait();\n-            } catch (InterruptedException e) {\n-                throw new Error(\"Unexpected \" + e);\n-            }\n-        }\n-\n-        if (contmon001.DEBUG_MODE)\n-            contmon001.out.println(\"thread exiting\");\n-    }\n-\n-    public void letItGo() {\n-        flag = false;\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetCurrentContendedMonitor\/contmon001.java","additions":0,"deletions":188,"binary":false,"changes":188,"status":"deleted"},{"patch":"@@ -1,66 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/*\n- * @test\n- *\n- * @summary converted from VM Testbase nsk\/jvmti\/GetCurrentContendedMonitor\/contmon001.\n- * VM Testbase keywords: [quick, jpda, jvmti, noras]\n- * VM Testbase readme:\n- * DESCRIPTION\n- *     The test exercises JVMTI function GetCurrentContendedMonitor.\n- *     The test cases include:\n- *       - current contended monitor: present or not;\n- *       - thread: current, non-current;\n- *       - thread waiting to enter a monitor or after wait();\n- *     Failing criteria for the test are:\n- *       - object returned by GetCurrentContendedMonitor is not the same\n- *         as expected;\n- *       - failures of used JVMTI functions.\n- * COMMENTS\n- *     By today, the test is referred from two bugs, 4327280 and 4463667\n- *     To fix bug 4463667, one code fragment with \"Thread.sleep(500);\"\n- *     is replaced with following one:\n- *         Object obj = new Object();\n- *             *\n- *             *\n- *         synchronized (obj) {\n- *             obj.wait(500);\n- *         }\n- *     Note. Until 4327280 gets fixing, the correction cannot be tested.\n- *     Fixed according to 4509016 bug.\n- *     Fixed according to 4669812 bug.\n- *     The test was fixed due to the following bug:\n- *         4762695 nsk\/jvmti\/GetCurrentContendedMonitor\/contmon001 has an\n- *                 incorrect test\n- *     Ported from JVMDI.\n- *     Fixed according to 4925857 bug:\n- *       - rearranged synchronization of tested thread\n- *       - enhanced descripton\n- *\n- * @library \/vmTestbase\n- *          \/test\/lib\n- * @run main\/othervm\/native -agentlib:contmon001 nsk.jvmti.GetCurrentContendedMonitor.contmon001\n- *\/\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetCurrentContendedMonitor\/contmon001\/TestDescription.java","additions":0,"deletions":66,"binary":false,"changes":66,"status":"deleted"},{"patch":"@@ -1,124 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include <stdio.h>\n-#include <string.h>\n-#include \"jvmti.h\"\n-#include \"agent_common.h\"\n-#include \"JVMTITools.h\"\n-\n-extern \"C\" {\n-\n-\n-#define PASSED 0\n-#define STATUS_FAILED 2\n-\n-static jvmtiEnv *jvmti = NULL;\n-static jvmtiCapabilities caps;\n-static jint result = PASSED;\n-\n-#ifdef STATIC_BUILD\n-JNIEXPORT jint JNICALL Agent_OnLoad_contmon001(JavaVM *jvm, char *options, void *reserved) {\n-    return Agent_Initialize(jvm, options, reserved);\n-}\n-JNIEXPORT jint JNICALL Agent_OnAttach_contmon001(JavaVM *jvm, char *options, void *reserved) {\n-    return Agent_Initialize(jvm, options, reserved);\n-}\n-JNIEXPORT jint JNI_OnLoad_contmon001(JavaVM *jvm, char *options, void *reserved) {\n-    return JNI_VERSION_1_8;\n-}\n-#endif\n-jint  Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {\n-    jvmtiError err;\n-    jint res;\n-\n-    res = jvm->GetEnv((void **) &jvmti, JVMTI_VERSION_1_1);\n-    if (res != JNI_OK || jvmti == NULL) {\n-        printf(\"Wrong result of a valid call to GetEnv !\\n\");\n-        return JNI_ERR;\n-    }\n-\n-    err = jvmti->GetCapabilities(&caps);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(GetCapabilities) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        return JNI_ERR;\n-    }\n-\n-    if (!caps.can_get_current_contended_monitor) {\n-        \/* GetCurrentContendedMonitor is not currently available, but\n-         * is it potentially available?\n-         *\/\n-        err = jvmti->GetPotentialCapabilities(&caps);\n-        if (err != JVMTI_ERROR_NONE) {\n-            printf(\"(GetPotentialCapabilities) unexpected error: %s (%d)\\n\",\n-                   TranslateError(err), err);\n-            return JNI_ERR;\n-        }\n-        if (caps.can_get_current_contended_monitor) {\n-            \/* Yes, GetCurrentContendedMonitor is potentially available.\n-             * Let's turn it on!\n-             *\/\n-            memset(&caps, 0, sizeof(jvmtiCapabilities));\n-            caps.can_get_current_contended_monitor = 1;\n-            err = jvmti->AddCapabilities(&caps);\n-            if (err != JVMTI_ERROR_NONE) {\n-                printf(\"(AddCapabilities) unexpected error: %s (%d)\\n\",\n-                       TranslateError(err), err);\n-                return JNI_ERR;\n-            }\n-        } else {\n-            printf(\"Warning: GetCurrentContendedMonitor is not implemented\\n\");\n-        }\n-    }\n-\n-    return JNI_OK;\n-}\n-\n-JNIEXPORT void JNICALL Java_nsk_jvmti_GetCurrentContendedMonitor_contmon001_checkMon(JNIEnv *env, jclass cls,\n-        jint point, jthread thr, jobject lock) {\n-    jvmtiError err;\n-    jobject mon = NULL;\n-\n-    err = jvmti->GetCurrentContendedMonitor(thr, &mon);\n-    if (err == JVMTI_ERROR_MUST_POSSESS_CAPABILITY &&\n-            !caps.can_get_current_contended_monitor) {\n-        \/* It's OK *\/\n-    } else if (err == JVMTI_ERROR_THREAD_NOT_ALIVE && point == 5) {\n-        return; \/* Ok, it must be a dead thread *\/\n-    } else if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(GetCurrentContendedMonitor#%d) unexpected error: %s (%d)\\n\",\n-               point, TranslateError(err), err);\n-        result = STATUS_FAILED;\n-    } else if (env->IsSameObject(lock, mon) == JNI_FALSE) {\n-        printf(\"(IsSameObject#%d) unexpected monitor object: 0x%p\\n\",\n-               point, mon);\n-        result = STATUS_FAILED;\n-    }\n-}\n-\n-JNIEXPORT jint JNICALL Java_nsk_jvmti_GetCurrentContendedMonitor_contmon001_getRes(JNIEnv *env, jclass cls) {\n-    return result;\n-}\n-\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetCurrentContendedMonitor\/contmon001\/contmon001.cpp","additions":0,"deletions":124,"binary":false,"changes":124,"status":"deleted"},{"patch":"@@ -1,33 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include \"native_thread.cpp\"\n-#include \"nsk_tools.cpp\"\n-#include \"jni_tools.cpp\"\n-#include \"jvmti_tools.cpp\"\n-#include \"agent_tools.cpp\"\n-#include \"jvmti_FollowRefObjects.cpp\"\n-#include \"Injector.cpp\"\n-#include \"JVMTITools.cpp\"\n-#include \"agent_common.cpp\"\n-#include \"contmon001.cpp\"\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetCurrentContendedMonitor\/contmon001\/libcontmon001.cpp","additions":0,"deletions":33,"binary":false,"changes":33,"status":"deleted"},{"patch":"@@ -1,106 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package nsk.jvmti.GetCurrentContendedMonitor;\n-\n-import java.io.PrintStream;\n-\n-public class contmon002 {\n-\n-    native static void checkMon(int point, Thread thr);\n-    native static int getRes();\n-\n-    static {\n-        try {\n-            System.loadLibrary(\"contmon002\");\n-        } catch (UnsatisfiedLinkError ule) {\n-            System.err.println(\"Could not load contmon002 library\");\n-            System.err.println(\"java.library.path:\"\n-                + System.getProperty(\"java.library.path\"));\n-            throw ule;\n-        }\n-    }\n-\n-    public static boolean startingBarrier = true;\n-\n-    public static void main(String[] args) {\n-        args = nsk.share.jvmti.JVMTITest.commonInit(args);\n-\n-        System.exit(run(args, System.out) + 95\/*STATUS_TEMP*\/);\n-    }\n-\n-    public static void doSleep() {\n-        try {\n-            Thread.sleep(10);\n-        } catch (Exception e) {\n-            throw new Error(\"Unexpected \" + e);\n-        }\n-    }\n-\n-    public static int run(String argv[], PrintStream ref) {\n-        checkMon(1, Thread.currentThread());\n-\n-        contmon002a thr = new contmon002a();\n-        thr.start();\n-        while (startingBarrier) {\n-            doSleep();\n-        }\n-        checkMon(2, thr);\n-        thr.letItGo();\n-        try {\n-            thr.join();\n-        } catch (InterruptedException e) {\n-            throw new Error(\"Unexpected \" + e);\n-        }\n-\n-        return getRes();\n-    }\n-}\n-\n-class contmon002a extends Thread {\n-    private volatile boolean flag = true;\n-\n-    private synchronized void meth() {\n-        contmon002.startingBarrier = false;\n-        int i = 0;\n-        int n = 1000;\n-        while (flag) {\n-            if (n <= 0) {\n-                n = 1000;\n-            }\n-            if (i > n) {\n-                i = 0;\n-                n--;\n-            }\n-            i++;\n-        }\n-    }\n-\n-    public void run() {\n-        meth();\n-    }\n-\n-    public void letItGo() {\n-        flag = false;\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetCurrentContendedMonitor\/contmon002.java","additions":0,"deletions":106,"binary":false,"changes":106,"status":"deleted"},{"patch":"@@ -1,48 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/*\n- * @test\n- *\n- * @summary converted from VM Testbase nsk\/jvmti\/GetCurrentContendedMonitor\/contmon002.\n- * VM Testbase keywords: [quick, jpda, jvmti, noras]\n- * VM Testbase readme:\n- * DESCRIPTION\n- *     The test checks if JVMTI function GetCurrentContendedMonitor returns\n- *     NULL when there is no current contended monitor.\n- *     Failing criteria for the test are:\n- *       - value returned by GetCurrentContendedMonitor is not NULL;\n- *       - failures of used JVMTI functions.\n- * COMMENTS\n- *     Fixed according to the bug 4509016.\n- *     Ported from JVMDI.\n- *     Fixed according to 4925857 bug:\n- *       - rearranged synchronization of tested thread\n- *       - enhanced descripton\n- *\n- * @library \/vmTestbase\n- *          \/test\/lib\n- * @run main\/othervm\/native -agentlib:contmon002 nsk.jvmti.GetCurrentContendedMonitor.contmon002\n- *\/\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetCurrentContendedMonitor\/contmon002\/TestDescription.java","additions":0,"deletions":48,"binary":false,"changes":48,"status":"deleted"},{"patch":"@@ -1,123 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include <stdio.h>\n-#include <string.h>\n-#include \"jvmti.h\"\n-#include \"agent_common.h\"\n-#include \"JVMTITools.h\"\n-\n-extern \"C\" {\n-\n-\n-#define PASSED 0\n-#define STATUS_FAILED 2\n-\n-static jvmtiEnv *jvmti;\n-static jvmtiCapabilities caps;\n-static jint result = PASSED;\n-\n-#ifdef STATIC_BUILD\n-JNIEXPORT jint JNICALL Agent_OnLoad_contmon002(JavaVM *jvm, char *options, void *reserved) {\n-    return Agent_Initialize(jvm, options, reserved);\n-}\n-JNIEXPORT jint JNICALL Agent_OnAttach_contmon002(JavaVM *jvm, char *options, void *reserved) {\n-    return Agent_Initialize(jvm, options, reserved);\n-}\n-JNIEXPORT jint JNI_OnLoad_contmon002(JavaVM *jvm, char *options, void *reserved) {\n-    return JNI_VERSION_1_8;\n-}\n-#endif\n-jint  Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {\n-    jint res;\n-    jvmtiError err;\n-\n-    res = jvm->GetEnv((void **) &jvmti, JVMTI_VERSION_1_1);\n-    if (res != JNI_OK || jvmti == NULL) {\n-        printf(\"Wrong result of a valid call to GetEnv !\\n\");\n-        return JNI_ERR;\n-    }\n-\n-    err = jvmti->GetCapabilities(&caps);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(GetCapabilities) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        return JNI_ERR;\n-    }\n-\n-    if (!caps.can_get_current_contended_monitor) {\n-        \/*\n-         * GetCurrentContendedMonitor is not currently available, but\n-         * is it potentially available?\n-         *\/\n-        err = jvmti->GetPotentialCapabilities(&caps);\n-        if (err != JVMTI_ERROR_NONE) {\n-            printf(\"(GetPotentialCapabilities) unexpected error: %s (%d)\\n\",\n-                   TranslateError(err), err);\n-            return JNI_ERR;\n-        }\n-        if (caps.can_get_current_contended_monitor) {\n-            \/*\n-             * Yes, GetCurrentContendedMonitor is potentially available.\n-             * Let's turn it on!\n-             *\/\n-            memset(&caps, 0, sizeof(jvmtiCapabilities));\n-            caps.can_get_current_contended_monitor = 1;\n-            err = jvmti->AddCapabilities(&caps);\n-            if (err != JVMTI_ERROR_NONE) {\n-                printf(\"(AddCapabilities) unexpected error: %s (%d)\\n\",\n-                       TranslateError(err), err);\n-                return JNI_ERR;\n-            }\n-        } else {\n-            printf(\"Warning: GetCurrentContendedMonitor is not implemented\\n\");\n-        }\n-    }\n-\n-    return JNI_OK;\n-}\n-\n-JNIEXPORT void JNICALL\n-Java_nsk_jvmti_GetCurrentContendedMonitor_contmon002_checkMon(JNIEnv *env, jclass cls, jint point, jthread thr) {\n-    jvmtiError err;\n-    jobject mon = NULL;\n-\n-    err = jvmti->GetCurrentContendedMonitor(thr, &mon);\n-    if (err == JVMTI_ERROR_MUST_POSSESS_CAPABILITY &&\n-            !caps.can_get_current_contended_monitor) {\n-        \/* It is OK *\/\n-    } else if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(GetCurrentContendedMonitor#%d) unexpected error: %s (%d)\\n\",\n-               point, TranslateError(err), err);\n-        result = STATUS_FAILED;\n-    } else if (mon != NULL) {\n-        printf(\"(#%d) unexpected monitor object: 0x%p\\n\", point, mon);\n-        result = STATUS_FAILED;\n-    }\n-}\n-\n-JNIEXPORT jint JNICALL Java_nsk_jvmti_GetCurrentContendedMonitor_contmon002_getRes(JNIEnv *env, jclass cls) {\n-    return result;\n-}\n-\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetCurrentContendedMonitor\/contmon002\/contmon002.cpp","additions":0,"deletions":123,"binary":false,"changes":123,"status":"deleted"},{"patch":"@@ -1,33 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include \"native_thread.cpp\"\n-#include \"nsk_tools.cpp\"\n-#include \"jni_tools.cpp\"\n-#include \"jvmti_tools.cpp\"\n-#include \"agent_tools.cpp\"\n-#include \"jvmti_FollowRefObjects.cpp\"\n-#include \"Injector.cpp\"\n-#include \"JVMTITools.cpp\"\n-#include \"agent_common.cpp\"\n-#include \"contmon002.cpp\"\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetCurrentContendedMonitor\/contmon002\/libcontmon002.cpp","additions":0,"deletions":33,"binary":false,"changes":33,"status":"deleted"},{"patch":"@@ -1,55 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package nsk.jvmti.GetCurrentContendedMonitor;\n-\n-import java.io.PrintStream;\n-\n-public class contmon003 {\n-\n-    final static int JCK_STATUS_BASE = 95;\n-\n-    static {\n-        try {\n-            System.loadLibrary(\"contmon003\");\n-        } catch (UnsatisfiedLinkError ule) {\n-            System.err.println(\"Could not load contmon003 library\");\n-            System.err.println(\"java.library.path:\"\n-                + System.getProperty(\"java.library.path\"));\n-            throw ule;\n-        }\n-    }\n-\n-    native static int check(Thread thr);\n-\n-    public static void main(String args[]) {\n-        args = nsk.share.jvmti.JVMTITest.commonInit(args);\n-\n-        \/\/ produce JCK-like exit status.\n-        System.exit(run(args, System.out) + JCK_STATUS_BASE);\n-    }\n-\n-    public static int run(String args[], PrintStream out) {\n-        return check(Thread.currentThread());\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetCurrentContendedMonitor\/contmon003.java","additions":0,"deletions":55,"binary":false,"changes":55,"status":"deleted"},{"patch":"@@ -1,44 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/*\n- * @test\n- *\n- * @summary converted from VM Testbase nsk\/jvmti\/GetCurrentContendedMonitor\/contmon003.\n- * VM Testbase keywords: [quick, jpda, jvmti, noras]\n- * VM Testbase readme:\n- * DESCRIPTION\n- *     The test exercises JVMTI function\n- *         GetCurrentContendedMonitor(thread, monitorPtr).\n- *     The test checks if the function returns:\n- *       - JVMTI_ERROR_INVALID_THREAD if thread is not a thread object\n- *       - JVMTI_ERROR_NULL_POINTER if monitorPtr is null\n- * COMMENTS\n- *     Ported from JVMDI.\n- *\n- * @library \/vmTestbase\n- *          \/test\/lib\n- * @run main\/othervm\/native -agentlib:contmon003 nsk.jvmti.GetCurrentContendedMonitor.contmon003\n- *\/\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetCurrentContendedMonitor\/contmon003\/TestDescription.java","additions":0,"deletions":44,"binary":false,"changes":44,"status":"deleted"},{"patch":"@@ -1,145 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include <stdio.h>\n-#include <string.h>\n-#include \"jvmti.h\"\n-#include \"agent_common.h\"\n-#include \"JVMTITools.h\"\n-\n-extern \"C\" {\n-\n-\n-#define PASSED 0\n-#define STATUS_FAILED 2\n-\n-static jvmtiEnv *jvmti = NULL;\n-static jvmtiCapabilities caps;\n-static jint result = PASSED;\n-static jboolean printdump = JNI_FALSE;\n-\n-#ifdef STATIC_BUILD\n-JNIEXPORT jint JNICALL Agent_OnLoad_contmon003(JavaVM *jvm, char *options, void *reserved) {\n-    return Agent_Initialize(jvm, options, reserved);\n-}\n-JNIEXPORT jint JNICALL Agent_OnAttach_contmon003(JavaVM *jvm, char *options, void *reserved) {\n-    return Agent_Initialize(jvm, options, reserved);\n-}\n-JNIEXPORT jint JNI_OnLoad_contmon003(JavaVM *jvm, char *options, void *reserved) {\n-    return JNI_VERSION_1_8;\n-}\n-#endif\n-jint Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {\n-    jint res;\n-    jvmtiError err;\n-\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n-        printdump = JNI_TRUE;\n-    }\n-\n-    res = jvm->GetEnv((void **) &jvmti, JVMTI_VERSION_1_1);\n-    if (res != JNI_OK || jvmti == NULL) {\n-        printf(\"Wrong result of a valid call to GetEnv!\\n\");\n-        return JNI_ERR;\n-    }\n-\n-    err = jvmti->GetCapabilities(&caps);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(GetCapabilities) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        return JNI_ERR;\n-    }\n-\n-    if (!caps.can_get_current_contended_monitor) {\n-        \/*\n-         * GetCurrentContendedMonitor is not currently available, but\n-         * is it potentially available?\n-         *\/\n-        err = jvmti->GetPotentialCapabilities(&caps);\n-        if (err != JVMTI_ERROR_NONE) {\n-            printf(\"(GetPotentialCapabilities) unexpected error: %s (%d)\\n\",\n-                   TranslateError(err), err);\n-            return JNI_ERR;\n-        }\n-        if (caps.can_get_current_contended_monitor) {\n-            \/*\n-             * Yes, GetCurrentContendedMonitor is potentially available.\n-             * Let's turn it on!\n-             *\/\n-            memset(&caps, 0, sizeof(jvmtiCapabilities));\n-            caps.can_get_current_contended_monitor = 1;\n-            err = jvmti->AddCapabilities(&caps);\n-            if (err != JVMTI_ERROR_NONE) {\n-                printf(\"(AddCapabilities) unexpected error: %s (%d)\\n\",\n-                       TranslateError(err), err);\n-                return JNI_ERR;\n-            }\n-        } else {\n-            printf(\"Warning: GetCurrentContendedMonitor is not implemented\\n\");\n-        }\n-    }\n-\n-    return JNI_OK;\n-}\n-\n-JNIEXPORT jint JNICALL\n-Java_nsk_jvmti_GetCurrentContendedMonitor_contmon003_check(JNIEnv *env,\n-        jclass cls, jthread thr) {\n-    jvmtiError err;\n-    jobject monitor;\n-\n-    if (jvmti == NULL) {\n-        printf(\"JVMTI client was not properly loaded!\\n\");\n-        return STATUS_FAILED;\n-    }\n-\n-    if (printdump == JNI_TRUE) {\n-        printf(\">>> invalid thread check ...\\n\");\n-    }\n-    err = jvmti->GetCurrentContendedMonitor(cls, &monitor);\n-    if (err == JVMTI_ERROR_MUST_POSSESS_CAPABILITY &&\n-            !caps.can_get_current_contended_monitor) {\n-        \/* It is OK *\/\n-    } else if (err != JVMTI_ERROR_INVALID_THREAD) {\n-        printf(\"Error expected: JVMTI_ERROR_INVALID_THREAD,\\n\");\n-        printf(\"           got: %s (%d)\\n\", TranslateError(err), err);\n-        result = STATUS_FAILED;\n-    }\n-\n-    if (printdump == JNI_TRUE) {\n-        printf(\">>> null pointer check ...\\n\");\n-    }\n-    err = jvmti->GetCurrentContendedMonitor(thr, NULL);\n-    if (err == JVMTI_ERROR_MUST_POSSESS_CAPABILITY &&\n-            !caps.can_get_current_contended_monitor) {\n-        \/* It is OK *\/\n-    } else if (err != JVMTI_ERROR_NULL_POINTER) {\n-        printf(\"Error expected: JVMTI_ERROR_NULL_POINTER,\\n\");\n-        printf(\"           got: %s (%d)\\n\", TranslateError(err), err);\n-        result = STATUS_FAILED;\n-    }\n-\n-    return result;\n-}\n-\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetCurrentContendedMonitor\/contmon003\/contmon003.cpp","additions":0,"deletions":145,"binary":false,"changes":145,"status":"deleted"},{"patch":"@@ -1,33 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include \"native_thread.cpp\"\n-#include \"nsk_tools.cpp\"\n-#include \"jni_tools.cpp\"\n-#include \"jvmti_tools.cpp\"\n-#include \"agent_tools.cpp\"\n-#include \"jvmti_FollowRefObjects.cpp\"\n-#include \"Injector.cpp\"\n-#include \"JVMTITools.cpp\"\n-#include \"agent_common.cpp\"\n-#include \"contmon003.cpp\"\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetCurrentContendedMonitor\/contmon003\/libcontmon003.cpp","additions":0,"deletions":33,"binary":false,"changes":33,"status":"deleted"},{"patch":"@@ -1,101 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package nsk.jvmti.GetFrameCount;\n-\n-import java.io.PrintStream;\n-\n-public class framecnt001 {\n-\n-    final static int JCK_STATUS_BASE = 95;\n-\n-    native static void checkFrames(Thread thr, int thr_num, int ans);\n-    native static int getRes();\n-\n-    static {\n-        try {\n-            System.loadLibrary(\"framecnt001\");\n-        } catch (UnsatisfiedLinkError ule) {\n-            System.err.println(\"Could not load framecnt001 library\");\n-            System.err.println(\"java.library.path:\"\n-                + System.getProperty(\"java.library.path\"));\n-            throw ule;\n-        }\n-    }\n-\n-    static Object flag1 = new Object();\n-    static Object flag2 = new Object();\n-    static Object check_flag = new Object();\n-\n-    public static void main(String args[]) {\n-        args = nsk.share.jvmti.JVMTITest.commonInit(args);\n-\n-        \/\/ produce JCK-like exit status.\n-        System.exit(run(args, System.out) + JCK_STATUS_BASE);\n-    }\n-\n-    public static int run(String argv[], PrintStream ref) {\n-        Thread currThread = Thread.currentThread();\n-        framecnt001a thr1 = new framecnt001a(\"thr1\", 0, flag1);\n-        framecnt001a thr2 = new framecnt001a(\"thr2\", 500, flag2);\n-        synchronized(check_flag) {\n-            synchronized(flag1) {\n-                synchronized(flag2) {\n-                    thr1.start();\n-                    thr2.start();\n-                    checkFrames(currThread, 0, 3);\n-                    try {\n-                        flag1.wait();\n-                        flag2.wait();\n-                    } catch(InterruptedException e) {}\n-                }\n-            }\n-            checkFrames(thr1, 1, 1);\n-            checkFrames(thr2, 2, 501);\n-        }\n-        return getRes();\n-    }\n-}\n-\n-class framecnt001a extends Thread {\n-    int steps;\n-    Object flag;\n-\n-    framecnt001a(String name, int steps, Object flag) {\n-        super(name);\n-        this.steps = steps;\n-        this.flag = flag;\n-    }\n-\n-    public void run() {\n-        if (steps > 0) {\n-            steps--;\n-            run();\n-        }\n-        synchronized(flag) {\n-            flag.notify();  \/\/ let main thread know that all frames are in place\n-        }\n-        synchronized(framecnt001.check_flag) {  \/\/ wait for the check done\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetFrameCount\/framecnt001.java","additions":0,"deletions":101,"binary":false,"changes":101,"status":"deleted"},{"patch":"@@ -1,46 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/*\n- * @test\n- *\n- * @summary converted from VM Testbase nsk\/jvmti\/GetFrameCount\/framecnt001.\n- * VM Testbase keywords: [quick, jpda, jvmti, noras]\n- * VM Testbase readme:\n- * DESCRIPTION\n- *     The test exercise JVMTI function GetFrameCount.\n- *     The function is called by a native method for the current thread\n- *     and for two more threads. The test suspends these two threads\n- *     before GetFrameCount invocation.\n- * COMMENTS\n- *     Ported from JVMDI.\n- *\n- * @library \/vmTestbase\n- *          \/test\/lib\n- * @build nsk.jvmti.GetFrameCount.framecnt001\n- * @run main\/othervm\/native ExecDriver --java\n- *      -agentlib:framecnt001\n- *      nsk.jvmti.GetFrameCount.framecnt001\n- *\/\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetFrameCount\/framecnt001\/TestDescription.java","additions":0,"deletions":46,"binary":false,"changes":46,"status":"deleted"},{"patch":"@@ -1,131 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include <stdio.h>\n-#include <string.h>\n-#include \"jvmti.h\"\n-#include \"agent_common.h\"\n-#include \"JVMTITools.h\"\n-\n-extern \"C\" {\n-\n-\n-#define PASSED 0\n-#define STATUS_FAILED 2\n-\n-static jvmtiEnv *jvmti = NULL;\n-static jvmtiCapabilities caps;\n-static jint result = PASSED;\n-\n-#ifdef STATIC_BUILD\n-JNIEXPORT jint JNICALL Agent_OnLoad_framecnt001(JavaVM *jvm, char *options, void *reserved) {\n-    return Agent_Initialize(jvm, options, reserved);\n-}\n-JNIEXPORT jint JNICALL Agent_OnAttach_framecnt001(JavaVM *jvm, char *options, void *reserved) {\n-    return Agent_Initialize(jvm, options, reserved);\n-}\n-JNIEXPORT jint JNI_OnLoad_framecnt001(JavaVM *jvm, char *options, void *reserved) {\n-    return JNI_VERSION_1_8;\n-}\n-#endif\n-jint  Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {\n-    jvmtiError err;\n-    jint res;\n-\n-    res = jvm->GetEnv((void **) &jvmti, JVMTI_VERSION_1_1);\n-    if (res != JNI_OK || jvmti == NULL) {\n-        printf(\"Wrong result of a valid call to GetEnv !\\n\");\n-        return JNI_ERR;\n-    }\n-\n-    err = jvmti->GetPotentialCapabilities(&caps);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(GetPotentialCapabilities) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        return JNI_ERR;\n-    }\n-\n-    err = jvmti->AddCapabilities(&caps);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(AddCapabilities) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        return JNI_ERR;\n-    }\n-\n-    err = jvmti->GetCapabilities(&caps);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(GetCapabilities) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        return JNI_ERR;\n-    }\n-\n-    if (!caps.can_suspend) {\n-        printf(\"Warning: suspend\/resume is not implemented\\n\");\n-    }\n-\n-    return JNI_OK;\n-}\n-\n-JNIEXPORT void JNICALL Java_nsk_jvmti_GetFrameCount_framecnt001_checkFrames(JNIEnv *env, jclass cls,\n-        jthread thr, jint thr_num, jint fnum) {\n-    jvmtiError err;\n-    jint frameCount;\n-\n-    if (!caps.can_suspend) {\n-        return;\n-    }\n-\n-    if (thr_num != 0) {\n-        err = jvmti->SuspendThread(thr);\n-        if (err != JVMTI_ERROR_NONE) {\n-            printf(\"(SuspendThread#%d) unexpected error: %s (%d)\\n\",\n-                   thr_num, TranslateError(err), err);\n-            result = STATUS_FAILED;\n-            return;\n-        }\n-    }\n-    err = jvmti->GetFrameCount(thr, &frameCount);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(GetFrameCount#%d) unexpected error: %s (%d)\\n\",\n-               thr_num, TranslateError(err), err);\n-        result = STATUS_FAILED;\n-    } else if (frameCount != fnum) {\n-        printf(\"Thread #%d: number of frames expected: %d, got: %d\\n\",\n-               thr_num, fnum, frameCount);\n-        result = STATUS_FAILED;\n-    }\n-    if (thr_num != 0) {\n-        err = jvmti->ResumeThread(thr);\n-        if (err != JVMTI_ERROR_NONE) {\n-            printf(\"(ResumeThread#%d) unexpected error: %s (%d)\\n\",\n-                   thr_num, TranslateError(err), err);\n-            result = STATUS_FAILED;\n-        }\n-    }\n-}\n-\n-JNIEXPORT jint JNICALL Java_nsk_jvmti_GetFrameCount_framecnt001_getRes(JNIEnv *env, jclass cls) {\n-    return result;\n-}\n-\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetFrameCount\/framecnt001\/framecnt001.cpp","additions":0,"deletions":131,"binary":false,"changes":131,"status":"deleted"},{"patch":"@@ -1,33 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include \"native_thread.cpp\"\n-#include \"nsk_tools.cpp\"\n-#include \"jni_tools.cpp\"\n-#include \"jvmti_tools.cpp\"\n-#include \"agent_tools.cpp\"\n-#include \"jvmti_FollowRefObjects.cpp\"\n-#include \"Injector.cpp\"\n-#include \"JVMTITools.cpp\"\n-#include \"agent_common.cpp\"\n-#include \"framecnt001.cpp\"\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetFrameCount\/framecnt001\/libframecnt001.cpp","additions":0,"deletions":33,"binary":false,"changes":33,"status":"deleted"},{"patch":"@@ -1,67 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package nsk.jvmti.GetFrameCount;\n-\n-import java.io.PrintStream;\n-\n-public class framecnt002 {\n-\n-    native static void checkFrames(Thread thr, int thr_num);\n-    native static int getRes();\n-\n-    static {\n-        try {\n-            System.loadLibrary(\"framecnt002\");\n-        } catch (UnsatisfiedLinkError ule) {\n-            System.err.println(\"Could not load framecnt002 library\");\n-            System.err.println(\"java.library.path:\"\n-                + System.getProperty(\"java.library.path\"));\n-            throw ule;\n-        }\n-    }\n-\n-    final static int JCK_STATUS_BASE = 95;\n-\n-    static int flag = 0;\n-\n-    public static void main(String args[]) {\n-        args = nsk.share.jvmti.JVMTITest.commonInit(args);\n-\n-        \/\/ produce JCK-like exit status.\n-        System.exit(run(args, System.out) + JCK_STATUS_BASE);\n-    }\n-\n-    public static int run(String argv[], PrintStream ref) {\n-        Thread currThread = Thread.currentThread();\n-        framecnt002a thr1 = new framecnt002a();\n-        checkFrames(thr1, 1);\n-        checkFrames(currThread, 0);\n-        return getRes();\n-    }\n-}\n-\n-class framecnt002a extends Thread {\n-    public void run() {\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetFrameCount\/framecnt002.java","additions":0,"deletions":67,"binary":false,"changes":67,"status":"deleted"},{"patch":"@@ -1,46 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/*\n- * @test\n- *\n- * @summary converted from VM Testbase nsk\/jvmti\/GetFrameCount\/framecnt002.\n- * VM Testbase keywords: [quick, jpda, jvmti, noras]\n- * VM Testbase readme:\n- * DESCRIPTION\n- *     The test checks that JVMTI function GetFrameCount returns proper\n- *     error codes when is called:\n- *       - with NULL passed as the second actual parameter,\n- *       - for a thread which is not is not alive.\n- * COMMENTS\n- *     Ported from JVMDI.\n- *     Updating test to meet JVMTI spec 0.2.30:\n- *     - check not alive thread\n- *     - check JVMTI_ERROR_THREAD_NOT_ALIVE instead of JVMTI_ERROR_THREAD_NOT_SUSPENDED\n- *\n- * @library \/vmTestbase\n- *          \/test\/lib\n- * @run main\/othervm\/native -agentlib:framecnt002 nsk.jvmti.GetFrameCount.framecnt002\n- *\/\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetFrameCount\/framecnt002\/TestDescription.java","additions":0,"deletions":46,"binary":false,"changes":46,"status":"deleted"},{"patch":"@@ -1,88 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include <stdio.h>\n-#include <string.h>\n-#include \"jvmti.h\"\n-#include \"agent_common.h\"\n-#include \"JVMTITools.h\"\n-\n-extern \"C\" {\n-\n-\n-#define PASSED 0\n-#define STATUS_FAILED 2\n-\n-static jvmtiEnv *jvmti = NULL;\n-static jint result = PASSED;\n-\n-#ifdef STATIC_BUILD\n-JNIEXPORT jint JNICALL Agent_OnLoad_framecnt002(JavaVM *jvm, char *options, void *reserved) {\n-    return Agent_Initialize(jvm, options, reserved);\n-}\n-JNIEXPORT jint JNICALL Agent_OnAttach_framecnt002(JavaVM *jvm, char *options, void *reserved) {\n-    return Agent_Initialize(jvm, options, reserved);\n-}\n-JNIEXPORT jint JNI_OnLoad_framecnt002(JavaVM *jvm, char *options, void *reserved) {\n-    return JNI_VERSION_1_8;\n-}\n-#endif\n-jint  Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {\n-    jint res;\n-\n-    res = jvm->GetEnv((void **) &jvmti, JVMTI_VERSION_1_1);\n-    if (res != JNI_OK || jvmti == NULL) {\n-        printf(\"Wrong result of a valid call to GetEnv !\\n\");\n-        return JNI_ERR;\n-    }\n-\n-    return JNI_OK;\n-}\n-\n-JNIEXPORT void JNICALL Java_nsk_jvmti_GetFrameCount_framecnt002_checkFrames(JNIEnv *env, jclass cls,\n-        jthread thr, jint thr_num) {\n-    jvmtiError err;\n-    jint frameCount;\n-\n-    if (thr_num == 0) {\n-        err = jvmti->GetFrameCount(thr, NULL);\n-        if (err != JVMTI_ERROR_NULL_POINTER) {\n-            printf(\"Error expected: JVMTI_ERROR_NULL_POINTER, got: %s (%d)\\n\",\n-                   TranslateError(err), err);\n-            result = STATUS_FAILED;\n-        }\n-    } else {\n-        err = jvmti->GetFrameCount(thr, &frameCount);\n-        if (err != JVMTI_ERROR_THREAD_NOT_ALIVE) {\n-            printf(\"Error expected: JVMTI_ERROR_THREAD_NOT_ALIVE, got: %s (%d)\\n\",\n-                   TranslateError(err), err);\n-            result = STATUS_FAILED;\n-        }\n-    }\n-}\n-\n-JNIEXPORT jint JNICALL Java_nsk_jvmti_GetFrameCount_framecnt002_getRes(JNIEnv *env, jclass cls) {\n-    return result;\n-}\n-\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetFrameCount\/framecnt002\/framecnt002.cpp","additions":0,"deletions":88,"binary":false,"changes":88,"status":"deleted"},{"patch":"@@ -1,33 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include \"native_thread.cpp\"\n-#include \"nsk_tools.cpp\"\n-#include \"jni_tools.cpp\"\n-#include \"jvmti_tools.cpp\"\n-#include \"agent_tools.cpp\"\n-#include \"jvmti_FollowRefObjects.cpp\"\n-#include \"Injector.cpp\"\n-#include \"JVMTITools.cpp\"\n-#include \"agent_common.cpp\"\n-#include \"framecnt002.cpp\"\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetFrameCount\/framecnt002\/libframecnt002.cpp","additions":0,"deletions":33,"binary":false,"changes":33,"status":"deleted"},{"patch":"@@ -1,55 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package nsk.jvmti.GetFrameCount;\n-\n-import java.io.PrintStream;\n-\n-public class framecnt003 {\n-\n-    final static int JCK_STATUS_BASE = 95;\n-\n-    static {\n-        try {\n-            System.loadLibrary(\"framecnt003\");\n-        } catch (UnsatisfiedLinkError ule) {\n-            System.err.println(\"Could not load framecnt003 library\");\n-            System.err.println(\"java.library.path:\"\n-                + System.getProperty(\"java.library.path\"));\n-            throw ule;\n-        }\n-    }\n-\n-    native static int check();\n-\n-    public static void main(String args[]) {\n-        args = nsk.share.jvmti.JVMTITest.commonInit(args);\n-\n-        \/\/ produce JCK-like exit status.\n-        System.exit(run(args, System.out) + JCK_STATUS_BASE);\n-    }\n-\n-    public static int run(String args[], PrintStream out) {\n-        return check();\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetFrameCount\/framecnt003.java","additions":0,"deletions":55,"binary":false,"changes":55,"status":"deleted"},{"patch":"@@ -1,42 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/*\n- * @test\n- *\n- * @summary converted from VM Testbase nsk\/jvmti\/GetFrameCount\/framecnt003.\n- * VM Testbase keywords: [quick, jpda, jvmti, noras]\n- * VM Testbase readme:\n- * DESCRIPTION\n- *     The test exercises JVMTI function GetFrameCount(thread, countPtr).\n- *     The test checks if the function returns JVMTI_ERROR_INVALID_THREAD\n- *     if thread is not a thread object.\n- * COMMENTS\n- *     Ported from JVMDI.\n- *\n- * @library \/vmTestbase\n- *          \/test\/lib\n- * @run main\/othervm\/native -agentlib:framecnt003 nsk.jvmti.GetFrameCount.framecnt003\n- *\/\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetFrameCount\/framecnt003\/TestDescription.java","additions":0,"deletions":42,"binary":false,"changes":42,"status":"deleted"},{"patch":"@@ -1,82 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include <stdio.h>\n-#include <string.h>\n-#include \"jvmti.h\"\n-#include \"agent_common.h\"\n-#include \"JVMTITools.h\"\n-\n-extern \"C\" {\n-\n-\n-#define PASSED 0\n-#define STATUS_FAILED 2\n-\n-static jvmtiEnv *jvmti = NULL;\n-static jint result = PASSED;\n-\n-#ifdef STATIC_BUILD\n-JNIEXPORT jint JNICALL Agent_OnLoad_framecnt003(JavaVM *jvm, char *options, void *reserved) {\n-    return Agent_Initialize(jvm, options, reserved);\n-}\n-JNIEXPORT jint JNICALL Agent_OnAttach_framecnt003(JavaVM *jvm, char *options, void *reserved) {\n-    return Agent_Initialize(jvm, options, reserved);\n-}\n-JNIEXPORT jint JNI_OnLoad_framecnt003(JavaVM *jvm, char *options, void *reserved) {\n-    return JNI_VERSION_1_8;\n-}\n-#endif\n-jint Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {\n-    jint res;\n-\n-    res = jvm->GetEnv((void **) &jvmti, JVMTI_VERSION_1_1);\n-    if (res != JNI_OK || jvmti == NULL) {\n-        printf(\"Wrong result of a valid call to GetEnv!\\n\");\n-        return JNI_ERR;\n-    }\n-\n-    return JNI_OK;\n-}\n-\n-JNIEXPORT jint JNICALL\n-Java_nsk_jvmti_GetFrameCount_framecnt003_check(JNIEnv *env, jclass cls) {\n-    jvmtiError err;\n-    jint countPtr;\n-\n-    if (jvmti == NULL) {\n-        printf(\"JVMTI client was not properly loaded!\\n\");\n-        return STATUS_FAILED;\n-    }\n-\n-    err = jvmti->GetFrameCount(cls, &countPtr);\n-    if (err != JVMTI_ERROR_INVALID_THREAD) {\n-        printf(\"Error expected: JVMTI_ERROR_INVALID_THREAD,\\n\");\n-        printf(\"        actual: %s (%d)\\n\", TranslateError(err), err);\n-        result = STATUS_FAILED;\n-    }\n-\n-    return result;\n-}\n-\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetFrameCount\/framecnt003\/framecnt003.cpp","additions":0,"deletions":82,"binary":false,"changes":82,"status":"deleted"},{"patch":"@@ -1,33 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include \"native_thread.cpp\"\n-#include \"nsk_tools.cpp\"\n-#include \"jni_tools.cpp\"\n-#include \"jvmti_tools.cpp\"\n-#include \"agent_tools.cpp\"\n-#include \"jvmti_FollowRefObjects.cpp\"\n-#include \"Injector.cpp\"\n-#include \"JVMTITools.cpp\"\n-#include \"agent_common.cpp\"\n-#include \"framecnt003.cpp\"\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetFrameCount\/framecnt003\/libframecnt003.cpp","additions":0,"deletions":33,"binary":false,"changes":33,"status":"deleted"},{"patch":"@@ -1,96 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package nsk.jvmti.GetFrameLocation;\n-\n-import java.io.PrintStream;\n-\n-public class frameloc001 {\n-\n-    final static int JCK_STATUS_BASE = 95;\n-\n-    static {\n-        try {\n-            System.loadLibrary(\"frameloc001\");\n-        } catch (UnsatisfiedLinkError ule) {\n-            System.err.println(\"Could not load frameloc001 library\");\n-            System.err.println(\"java.library.path:\"\n-                + System.getProperty(\"java.library.path\"));\n-            throw ule;\n-        }\n-    }\n-\n-    native static void getReady(Class cls);\n-    native static boolean checkFrame01(Thread thr, Class cls, boolean mustPass);\n-    native static int getRes();\n-\n-    static int fld = 0;\n-    static Object lock1 = new Object();\n-    static Object lock2 = new Object();\n-\n-    public static void main(String args[]) {\n-        args = nsk.share.jvmti.JVMTITest.commonInit(args);\n-\n-        \/\/ produce JCK-like exit status.\n-        System.exit(run(args, System.out) + JCK_STATUS_BASE);\n-    }\n-\n-    public static int run(String argv[], PrintStream ref) {\n-        frameloc001a thr = new frameloc001a();\n-\n-        getReady(frameloc001a.class);\n-        thr.meth01(2000);\n-\n-        synchronized (lock2) {\n-            synchronized (lock1) {\n-                thr.start();\n-                try {\n-                    lock1.wait();\n-                } catch (InterruptedException e) {\n-                    throw new Error(\"Unexpected \" + e);\n-                }\n-            }\n-            waitForChildThread(thr);\n-            checkFrame01(thr, frameloc001a.class, true);\n-        }\n-\n-        return getRes();\n-    }\n-\n-    private static void waitForChildThread(frameloc001a thr) {\n-        \/\/ Wait for child thread to reach expected position. Wait up to 5 seconds.\n-        final int MAX_WAIT_MS = 5000;\n-        int sumWaitMs = 0;\n-        while (!checkFrame01(thr, frameloc001a.class, false) && sumWaitMs <= MAX_WAIT_MS) {\n-            try {\n-                System.out.println(\"Waited: \" + sumWaitMs);\n-                final int sleepMs = 20;\n-                sumWaitMs += sleepMs;\n-                Thread.sleep(sleepMs);\n-            } catch (InterruptedException e) {\n-                e.printStackTrace();\n-                throw new Error(\"Unexpected \" + e);\n-            }\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetFrameLocation\/frameloc001.java","additions":0,"deletions":96,"binary":false,"changes":96,"status":"deleted"},{"patch":"@@ -1,51 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/*\n- * @test\n- *\n- * @summary converted from VM Testbase nsk\/jvmti\/GetFrameLocation\/frameloc001.\n- * VM Testbase keywords: [jpda, jvmti, noras]\n- * VM Testbase readme:\n- * DESCRIPTION\n- *     The test exercise JVMTI function GetFrameLocation.\n- *     The test debug agent calls the function from the hook\n- *     function and native method for the test cases:\n- *     - current and other threads;\n- *     - currently executing instructions:\n- *         1) astore_2 after catching exception (in frameloc001a.meth01)\n- *         2) monitorenter (in frameloc001a.run)\n- * COMMENTS\n- *     Fixed according to the rfe 4388972.\n- *     Tested bytecode was relocated to frameloc001a.jasm\n- *     adjusting the expected locations.\n- *     Fixed according to 4669812 bug.\n- *     Ported from JVMDI.\n- *\n- * @library \/vmTestbase\n- *          \/test\/lib\n- * @compile frameloc001a.jasm\n- * @run main\/othervm\/native -agentlib:frameloc001 nsk.jvmti.GetFrameLocation.frameloc001\n- *\/\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetFrameLocation\/frameloc001\/TestDescription.java","additions":0,"deletions":51,"binary":false,"changes":51,"status":"deleted"},{"patch":"@@ -1,228 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include <stdio.h>\n-#include <string.h>\n-#include \"jvmti.h\"\n-#include \"agent_common.h\"\n-#include \"JVMTITools.h\"\n-\n-extern \"C\" {\n-\n-\n-#define PASSED 0\n-#define STATUS_FAILED 2\n-\n-static jvmtiEnv *jvmti = NULL;\n-static jvmtiCapabilities caps;\n-static jvmtiEventCallbacks callbacks;\n-static jint result = PASSED;\n-static jmethodID mid1;\n-\n-\/\/ If mustPass is false we just check if we have reached the correct instruction location.\n-\/\/ This is used to wait for the child thread to reach the expected position.\n-jboolean checkFrame(jvmtiEnv *jvmti_env, JNIEnv *env,\n-        jthread thr, jmethodID exp_mid, jlocation exp_loc, jlocation exp_loc_alternative, jboolean mustPass) {\n-    jvmtiError err;\n-    jmethodID mid = NULL;\n-    jlocation loc = -1;\n-    char *meth, *sig, *generic;\n-    jboolean isOk = JNI_FALSE;\n-\n-    err = jvmti_env->GetMethodName(exp_mid, &meth, &sig, &generic);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(GetMethodName) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-    }\n-\n-    err = jvmti_env->GetFrameLocation(thr, 0, &mid, &loc);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(GetFrameLocation#%s) unexpected error: %s (%d)\\n\",\n-               meth, TranslateError(err), err);\n-        result = STATUS_FAILED;\n-    } else {\n-        if (exp_mid != mid) {\n-            printf(\"Method \\\"%s\\\" current frame's method ID\", meth);\n-            printf(\" expected: 0x%p, got: 0x%p\\n\", exp_mid, mid);\n-            result = STATUS_FAILED;\n-        }\n-        isOk = exp_loc == loc || exp_loc_alternative == loc;\n-        if (!isOk && mustPass) {\n-            printf(\"Method \\\"%s\\\" current frame's location\", meth);\n-            printf(\" expected: 0x%x or 0x%x, got: 0x%x%08x\\n\",\n-                   (jint)exp_loc, (jint)exp_loc_alternative, (jint)(loc >> 32), (jint)loc);\n-            result = STATUS_FAILED;\n-        }\n-    }\n-    return isOk && result == PASSED;\n-}\n-\n-void JNICALL\n-ExceptionCatch(jvmtiEnv *jvmti_env, JNIEnv *env, jthread thr,\n-        jmethodID method, jlocation location, jobject exception) {\n-    if (method == mid1) {\n-      checkFrame(jvmti_env, (JNIEnv *)env, thr, method, location, location, JNI_TRUE);\n-    }\n-}\n-\n-#ifdef STATIC_BUILD\n-JNIEXPORT jint JNICALL Agent_OnLoad_frameloc001(JavaVM *jvm, char *options, void *reserved) {\n-    return Agent_Initialize(jvm, options, reserved);\n-}\n-JNIEXPORT jint JNICALL Agent_OnAttach_frameloc001(JavaVM *jvm, char *options, void *reserved) {\n-    return Agent_Initialize(jvm, options, reserved);\n-}\n-JNIEXPORT jint JNI_OnLoad_frameloc001(JavaVM *jvm, char *options, void *reserved) {\n-    return JNI_VERSION_1_8;\n-}\n-#endif\n-jint  Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {\n-    jint res;\n-    jvmtiError err;\n-\n-    res = jvm->GetEnv((void **) &jvmti, JVMTI_VERSION_1_1);\n-    if (res != JNI_OK || jvmti == NULL) {\n-        printf(\"Wrong result of a valid call to GetEnv !\\n\");\n-        return JNI_ERR;\n-    }\n-\n-    err = jvmti->GetPotentialCapabilities(&caps);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(GetPotentialCapabilities) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        return JNI_ERR;\n-    }\n-\n-    err = jvmti->AddCapabilities(&caps);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(AddCapabilities) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        return JNI_ERR;\n-    }\n-\n-    err = jvmti->GetCapabilities(&caps);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(GetCapabilities) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        return JNI_ERR;\n-    }\n-\n-    if (!caps.can_suspend) {\n-        printf(\"Warning: suspend\/resume is not implemented\\n\");\n-    }\n-\n-    if (caps.can_generate_exception_events) {\n-        callbacks.ExceptionCatch = &ExceptionCatch;\n-        err = jvmti->SetEventCallbacks(&callbacks, sizeof(callbacks));\n-        if (err != JVMTI_ERROR_NONE) {\n-            printf(\"(SetEventCallbacks) unexpected error: %s (%d)\\n\",\n-                   TranslateError(err), err);\n-            return JNI_ERR;\n-        }\n-    } else {\n-        printf(\"Warning: ExceptionCatch event is not implemented\\n\");\n-    }\n-\n-    return JNI_OK;\n-}\n-\n-JNIEXPORT void JNICALL\n-Java_nsk_jvmti_GetFrameLocation_frameloc001_getReady(JNIEnv *env, jclass cls,\n-        jclass klass) {\n-    jvmtiError err;\n-\n-    if (jvmti == NULL) {\n-        printf(\"JVMTI client was not properly loaded!\\n\");\n-        result = STATUS_FAILED;\n-        return;\n-    }\n-\n-    if (!caps.can_generate_exception_events) {\n-        return;\n-    }\n-\n-    mid1 = env->GetMethodID(klass, \"meth01\", \"(I)V\");\n-    if (mid1 == NULL) {\n-        printf(\"Cannot get jmethodID for method \\\"meth01\\\"\\n\");\n-        result = STATUS_FAILED;\n-        return;\n-    }\n-\n-    err = jvmti->SetEventNotificationMode(JVMTI_ENABLE,\n-        JVMTI_EVENT_EXCEPTION_CATCH, NULL);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(SetEventNotificationMode) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-    }\n-}\n-\n-JNIEXPORT jboolean JNICALL\n-Java_nsk_jvmti_GetFrameLocation_frameloc001_checkFrame01(JNIEnv *env,\n-        jclass cls, jthread thr, jclass klass, jboolean mustPass) {\n-    jvmtiError err;\n-    jmethodID mid;\n-    jboolean isOk = JNI_FALSE;\n-\n-    if (jvmti == NULL || !caps.can_suspend) {\n-        return JNI_TRUE;\n-    }\n-\n-    mid = env->GetMethodID(klass, \"run\", \"()V\");\n-    if (mid == NULL) {\n-        printf(\"Cannot get jmethodID for method \\\"run\\\"\\n\");\n-        result = STATUS_FAILED;\n-        return JNI_TRUE;\n-    }\n-\n-    err = jvmti->SuspendThread(thr);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(SuspendThread) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-    }\n-\n-    \/\/ This tests the location of a throw\/catch statement.\n-    \/\/ The returned location may be either the throw or the catch statement.\n-    \/\/ It seems like the throw statement is returned in compiled code (-Xcomp),\n-    \/\/ but the catch statement is returned in interpreted code.\n-    \/\/ Both locations are valid.\n-    \/\/ See bug JDK-4527281.\n-    isOk = checkFrame(jvmti, env, thr, mid, 31, 32, mustPass);\n-\n-    err = jvmti->ResumeThread(thr);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(ResumeThread) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-    }\n-    return isOk && result == PASSED;\n-}\n-\n-JNIEXPORT jint JNICALL\n-Java_nsk_jvmti_GetFrameLocation_frameloc001_getRes(JNIEnv *env, jclass cls) {\n-    return result;\n-}\n-\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetFrameLocation\/frameloc001\/frameloc001.cpp","additions":0,"deletions":228,"binary":false,"changes":228,"status":"deleted"},{"patch":"@@ -1,117 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package nsk\/jvmti\/GetFrameLocation;\n-\n-\/* Reassembled from the following Java pattern:\n- *\n- *  class frameloc001a extends Thread {\n- *      public void meth01(int i) {\n- *      try {\n- *              if (i > 0) {\n- *                  throw new Throwable();\n- *              }\n- *          } catch (Throwable e) {}\n- *      }\n- *      public void run() {\n- *          int local = 2003;\n- *          synchronized (frameloc001.lock1) {\n- *              frameloc001.lock1.notify();\n- *          }\n- *          synchronized (frameloc001.lock2) {\n- *              frameloc001.fld = local;\n- *          }\n- *      }\n- *  }\n- *\n- *\/\n-\n-super class frameloc001a extends java\/lang\/Thread {\n-\n-\tMethod \"<init>\":\"()V\" stack 1 locals 1 {\n-\t\taload_0;\n-\t\tinvokespecial\tMethod java\/lang\/Thread.\"<init>\":\"()V\";\n-\t\treturn;\n-\t}\n-\n-\tpublic Method meth01:\"(I)V\" stack 2 locals 3 {\n-\ttry t0;\n-\t\tiload_1;\n-\t\tifle\tL12;\n-\t\tnew\tclass java\/lang\/Throwable;\n-\t\tdup;\n-\t\tinvokespecial\tMethod java\/lang\/Throwable.\"<init>\":\"()V\";\n-\t\tathrow;\n-\tendtry t0;\n-\tL12:\tgoto\tL16;\n-\tcatch t0 java\/lang\/Throwable;\n-\t\tastore_2;\t\/\/ bci=15, expected to be here\n-\tL16:\treturn;\n-\t}\n-\n-\tpublic Method run:\"()V\" stack 1 locals 5 {\n-\t\tsipush\t2003;\n-\t\tistore_1;\n-\t\tgetstatic\tField frameloc001.lock1:\"Ljava\/lang\/Object;\";\n-\t\tastore_2;\n-\t\taload_2;\n-\t\tmonitorenter;\n-\ttry t0;\n-\t\tgetstatic\tField frameloc001.lock1:\"Ljava\/lang\/Object;\";\n-\t\tinvokevirtual\tMethod java\/lang\/Object.notify:\"()V\";\n-\t\taload_2;\n-\t\tmonitorexit;\n-\tendtry t0;\n-\t\tgoto\tL26;\n-\tcatch t0 #0;\n-\tcatch t1 #0;\n-\ttry t1;\n-\t\tastore_3;\n-\t\taload_2;\n-\t\tmonitorexit;\n-\tendtry t1;\n-\t\taload_3;\n-\t\tathrow;\n-\tL26:\tgetstatic\tField frameloc001.lock2:\"Ljava\/lang\/Object;\";\n-\t\tastore_3;\n-\t\taload_3;\n-\t\tmonitorenter;\t\/\/ bci=31, expected to be here\n-\ttry t2;\n-\t\tiload_1;\n-\t\tputstatic\tField frameloc001.fld:\"I\";\n-\t\taload_3;\n-\t\tmonitorexit;\n-\tendtry t2;\n-\t\tgoto\tL48;\n-\tcatch t2 #0;\n-\tcatch t3 #0;\n-\ttry t3;\n-\t\tastore\t4;\n-\t\taload_3;\n-\t\tmonitorexit;\n-\tendtry t3;\n-\t\taload\t4;\n-\t\tathrow;\n-\tL48:\treturn;\n-\t}\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetFrameLocation\/frameloc001\/frameloc001a.jasm","additions":0,"deletions":117,"binary":false,"changes":117,"status":"deleted"},{"patch":"@@ -1,33 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include \"native_thread.cpp\"\n-#include \"nsk_tools.cpp\"\n-#include \"jni_tools.cpp\"\n-#include \"jvmti_tools.cpp\"\n-#include \"agent_tools.cpp\"\n-#include \"jvmti_FollowRefObjects.cpp\"\n-#include \"Injector.cpp\"\n-#include \"JVMTITools.cpp\"\n-#include \"agent_common.cpp\"\n-#include \"frameloc001.cpp\"\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetFrameLocation\/frameloc001\/libframeloc001.cpp","additions":0,"deletions":33,"binary":false,"changes":33,"status":"deleted"},{"patch":"@@ -1,55 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package nsk.jvmti.GetFrameLocation;\n-\n-import java.io.PrintStream;\n-\n-public class frameloc002 {\n-\n-    final static int JCK_STATUS_BASE = 95;\n-\n-    static {\n-        try {\n-            System.loadLibrary(\"frameloc002\");\n-        } catch (UnsatisfiedLinkError ule) {\n-            System.err.println(\"Could not load frameloc002 library\");\n-            System.err.println(\"java.library.path:\"\n-                + System.getProperty(\"java.library.path\"));\n-            throw ule;\n-        }\n-    }\n-\n-    native static int check(Thread thr);\n-\n-    public static void main(String args[]) {\n-        args = nsk.share.jvmti.JVMTITest.commonInit(args);\n-\n-        \/\/ produce JCK-like exit status.\n-        System.exit(run(args, System.out) + JCK_STATUS_BASE);\n-    }\n-\n-    public static int run(String args[], PrintStream out) {\n-        return check(Thread.currentThread());\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetFrameLocation\/frameloc002.java","additions":0,"deletions":55,"binary":false,"changes":55,"status":"deleted"},{"patch":"@@ -1,44 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/*\n- * @test\n- *\n- * @summary converted from VM Testbase nsk\/jvmti\/GetFrameLocation\/frameloc002.\n- * VM Testbase keywords: [quick, jpda, jvmti, noras]\n- * VM Testbase readme:\n- * DESCRIPTION\n- *     The test exercises JVMTI function GetFrameLocation.\n- *     The test checks if the function returns expected values\n- *     for a native (JNI) frame.\n- * COMMENTS\n- *     Fixed according to 4802866 bug.\n- *     Ported from JVMDI.\n- *     Fixed the 5004632 bug.\n- *\n- * @library \/vmTestbase\n- *          \/test\/lib\n- * @run main\/othervm\/native -agentlib:frameloc002 nsk.jvmti.GetFrameLocation.frameloc002\n- *\/\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetFrameLocation\/frameloc002\/TestDescription.java","additions":0,"deletions":44,"binary":false,"changes":44,"status":"deleted"},{"patch":"@@ -1,168 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include <stdio.h>\n-#include <string.h>\n-#include \"jvmti.h\"\n-#include \"agent_common.h\"\n-#include \"jni_tools.h\"\n-#include \"JVMTITools.h\"\n-\n-extern \"C\" {\n-\n-\n-#define PASSED 0\n-#define STATUS_FAILED 2\n-\n-typedef struct {\n-    const char *cls_sig;\n-    const char *name;\n-    const char *sig;\n-    jlocation loc;\n-} frame_info;\n-\n-static jvmtiEnv *jvmti = NULL;\n-static jint result = PASSED;\n-static jboolean printdump = JNI_FALSE;\n-static frame_info fi =\n-    { \"Lnsk\/jvmti\/GetFrameLocation\/frameloc002;\", \"check\",\n-      \"(Ljava\/lang\/Thread;)I\", -1 };\n-\n-#ifdef STATIC_BUILD\n-JNIEXPORT jint JNICALL Agent_OnLoad_frameloc002(JavaVM *jvm, char *options, void *reserved) {\n-    return Agent_Initialize(jvm, options, reserved);\n-}\n-JNIEXPORT jint JNICALL Agent_OnAttach_frameloc002(JavaVM *jvm, char *options, void *reserved) {\n-    return Agent_Initialize(jvm, options, reserved);\n-}\n-JNIEXPORT jint JNI_OnLoad_frameloc002(JavaVM *jvm, char *options, void *reserved) {\n-    return JNI_VERSION_1_8;\n-}\n-#endif\n-jint Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {\n-    jint res;\n-\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n-        printdump = JNI_TRUE;\n-    }\n-\n-    res = jvm->GetEnv((void **) &jvmti, JVMTI_VERSION_1_1);\n-    if (res != JNI_OK || jvmti == NULL) {\n-        printf(\"Wrong result of a valid call to GetEnv!\\n\");\n-        return JNI_ERR;\n-    }\n-\n-    return JNI_OK;\n-}\n-\n-JNIEXPORT jint JNICALL\n-Java_nsk_jvmti_GetFrameLocation_frameloc002_check(JNIEnv *env, jclass cls, jthread thr) {\n-    jvmtiError err;\n-    jclass klass;\n-    jmethodID mid;\n-    jlocation loc;\n-    char *cls_sig, *name, *sig, *generic;\n-    char buffer[32];\n-\n-    if (jvmti == NULL) {\n-        printf(\"JVMTI client was not properly loaded!\\n\");\n-        return STATUS_FAILED;\n-    }\n-\n-    if (printdump == JNI_TRUE) {\n-        printf(\">>> acquiring frame location ...\\n\");\n-    }\n-    err = jvmti->GetFrameLocation(thr, 0, &mid, &loc);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(GetFrameLocation) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-        return result;\n-    }\n-\n-    if (printdump == JNI_TRUE) {\n-        printf(\">>> retrieving class\/method info ...\\n\");\n-    }\n-    err = jvmti->GetMethodDeclaringClass(mid, &klass);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(GetMethodDeclaringClass) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-        return result;\n-    }\n-    err = jvmti->GetClassSignature(klass, &cls_sig, &generic);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(GetClassSignature) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-        return result;\n-    }\n-    err = jvmti->GetMethodName(mid, &name, &sig, &generic);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(GetMethodName) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-        return result;\n-    }\n-\n-    if (printdump == JNI_TRUE) {\n-        printf(\">>>      class: \\\"%s\\\"\\n\", cls_sig);\n-        printf(\">>>     method: \\\"%s%s\\\"\\n\", name, sig);\n-        printf(\">>>   location: %s\\n\",\n-               jlong_to_string(loc, buffer));\n-    }\n-\n-    if (cls_sig == NULL ||\n-            strcmp(cls_sig, fi.cls_sig) != 0) {\n-        printf(\"(GetFrameLocation) wrong class: \\\"%s\\\"\", cls_sig);\n-        printf(\", expected: \\\"%s\\\"\\n\", fi.cls_sig);\n-        result = STATUS_FAILED;\n-    }\n-    if (name == NULL ||\n-            strcmp(name, fi.name) != 0) {\n-        printf(\"(GetFrameLocation) wrong method name: \\\"%s\\\"\", name);\n-        printf(\", expected: \\\"%s\\\"\\n\", fi.name);\n-        result = STATUS_FAILED;\n-    }\n-    if (sig == NULL ||\n-            strcmp(sig, fi.sig) != 0) {\n-        printf(\"(GetFrameLocation) wrong method signature: \\\"%s\\\"\", sig);\n-        printf(\", expected: \\\"%s\\\"\\n\", fi.sig);\n-        result = STATUS_FAILED;\n-    }\n-    if (loc != fi.loc) {\n-        printf(\"(GetFrameLocation) wrong location: %s\",\n-               jlong_to_string(loc, buffer));\n-        printf(\", expected: %s\\n\",\n-               jlong_to_string(fi.loc, buffer));\n-        result = STATUS_FAILED;\n-    }\n-\n-    if (printdump == JNI_TRUE) {\n-        printf(\">>> ... done\\n\");\n-    }\n-\n-    return result;\n-}\n-\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetFrameLocation\/frameloc002\/frameloc002.cpp","additions":0,"deletions":168,"binary":false,"changes":168,"status":"deleted"},{"patch":"@@ -1,33 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include \"native_thread.cpp\"\n-#include \"nsk_tools.cpp\"\n-#include \"jni_tools.cpp\"\n-#include \"jvmti_tools.cpp\"\n-#include \"agent_tools.cpp\"\n-#include \"jvmti_FollowRefObjects.cpp\"\n-#include \"Injector.cpp\"\n-#include \"JVMTITools.cpp\"\n-#include \"agent_common.cpp\"\n-#include \"frameloc002.cpp\"\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetFrameLocation\/frameloc002\/libframeloc002.cpp","additions":0,"deletions":33,"binary":false,"changes":33,"status":"deleted"},{"patch":"@@ -1,96 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package nsk.jvmti.GetFrameLocation;\n-\n-import java.io.PrintStream;\n-\n-public class frameloc003 {\n-\n-    final static int JCK_STATUS_BASE = 95;\n-\n-    static {\n-        try {\n-            System.loadLibrary(\"frameloc003\");\n-        } catch (UnsatisfiedLinkError ule) {\n-            System.err.println(\"Could not load frameloc003 library\");\n-            System.err.println(\"java.library.path:\"\n-                + System.getProperty(\"java.library.path\"));\n-            throw ule;\n-        }\n-    }\n-\n-    native static int check(Thread thread);\n-\n-    public static void main(String args[]) {\n-        args = nsk.share.jvmti.JVMTITest.commonInit(args);\n-\n-        \/\/ produce JCK-like exit status.\n-        System.exit(run(args, System.out) + JCK_STATUS_BASE);\n-    }\n-\n-    public static Object lockStart = new Object();\n-    public static Object lockFinish = new Object();\n-\n-    public static int run(String args[], PrintStream out) {\n-        TestThread t = new TestThread();\n-\n-        synchronized (lockStart) {\n-            t.start();\n-            try {\n-                lockStart.wait();\n-            } catch (InterruptedException e) {\n-                throw new Error(\"Unexpected: \" + e);\n-            }\n-\n-        }\n-\n-        int res = check(t);\n-\n-        synchronized (lockFinish) {\n-            lockFinish.notify();\n-        }\n-        try {\n-            t.join();\n-        } catch (InterruptedException e) {\n-            throw new Error(\"Unexpected: \" + e);\n-        }\n-\n-        return res;\n-    }\n-\n-    static class TestThread extends Thread {\n-        public void run() {\n-            synchronized (lockFinish) {\n-                synchronized (lockStart) {\n-                    lockStart.notify();\n-                }\n-                try {\n-                    lockFinish.wait();\n-                } catch (InterruptedException e) {\n-                    throw new Error(\"Unexpected: \" + e);\n-                }\n-            }\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetFrameLocation\/frameloc003.java","additions":0,"deletions":96,"binary":false,"changes":96,"status":"deleted"},{"patch":"@@ -1,45 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/*\n- * @test\n- *\n- * @summary converted from VM Testbase nsk\/jvmti\/GetFrameLocation\/frameloc003.\n- * VM Testbase keywords: [quick, jpda, jvmti, noras]\n- * VM Testbase readme:\n- * DESCRIPTION\n- *     The test exercises JVMTI function\n- *         GetFrameLocation(thread, depth, methodPtr, locationPtr).\n- *     The test checks if the function returns:\n- *       - JVMTI_ERROR_INVALID_THREAD if thread is not a thread object\n- *       - JVMTI_ERROR_ILLEGAL_ARGUMENT if depth less than zero\n- *       - JVMTI_ERROR_NULL_POINTER if any of pointers is null\n- * COMMENTS\n- *     Ported from JVMDI.\n- *\n- * @library \/vmTestbase\n- *          \/test\/lib\n- * @run main\/othervm\/native -agentlib:frameloc003 nsk.jvmti.GetFrameLocation.frameloc003\n- *\/\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetFrameLocation\/frameloc003\/TestDescription.java","additions":0,"deletions":45,"binary":false,"changes":45,"status":"deleted"},{"patch":"@@ -1,170 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include <stdio.h>\n-#include <string.h>\n-#include \"jvmti.h\"\n-#include \"agent_common.h\"\n-#include \"JVMTITools.h\"\n-\n-extern \"C\" {\n-\n-\n-#define PASSED 0\n-#define STATUS_FAILED 2\n-\n-static jvmtiEnv *jvmti = NULL;\n-static jvmtiCapabilities caps;\n-static jint result = PASSED;\n-static jboolean printdump = JNI_FALSE;\n-\n-#ifdef STATIC_BUILD\n-JNIEXPORT jint JNICALL Agent_OnLoad_frameloc003(JavaVM *jvm, char *options, void *reserved) {\n-    return Agent_Initialize(jvm, options, reserved);\n-}\n-JNIEXPORT jint JNICALL Agent_OnAttach_frameloc003(JavaVM *jvm, char *options, void *reserved) {\n-    return Agent_Initialize(jvm, options, reserved);\n-}\n-JNIEXPORT jint JNI_OnLoad_frameloc003(JavaVM *jvm, char *options, void *reserved) {\n-    return JNI_VERSION_1_8;\n-}\n-#endif\n-jint Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {\n-    jvmtiError err;\n-    jint res;\n-\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n-        printdump = JNI_TRUE;\n-    }\n-\n-    res = jvm->GetEnv((void **) &jvmti, JVMTI_VERSION_1_1);\n-    if (res != JNI_OK || jvmti == NULL) {\n-        printf(\"Wrong result of a valid call to GetEnv!\\n\");\n-        return JNI_ERR;\n-    }\n-\n-    err = jvmti->GetPotentialCapabilities(&caps);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(GetPotentialCapabilities) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        return JNI_ERR;\n-    }\n-\n-    err = jvmti->AddCapabilities(&caps);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(AddCapabilities) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        return JNI_ERR;\n-    }\n-\n-    err = jvmti->GetCapabilities(&caps);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(GetCapabilities) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        return JNI_ERR;\n-    }\n-\n-    if (!caps.can_suspend) {\n-        printf(\"Warning: suspend\/resume is not implemented\\n\");\n-    }\n-\n-    return JNI_OK;\n-}\n-\n-JNIEXPORT jint JNICALL\n-Java_nsk_jvmti_GetFrameLocation_frameloc003_check(JNIEnv *env, jclass cls, jthread thr) {\n-    jvmtiError err;\n-    jmethodID mid;\n-    jlocation loc;\n-\n-    if (jvmti == NULL) {\n-        printf(\"JVMTI client was not properly loaded!\\n\");\n-        return STATUS_FAILED;\n-    }\n-\n-    if (printdump == JNI_TRUE) {\n-        printf(\">>> invalid thread check ...\\n\");\n-    }\n-    err = jvmti->GetFrameLocation(cls, 0, &mid, &loc);\n-    if (err != JVMTI_ERROR_INVALID_THREAD) {\n-        printf(\"Error expected: JVMTI_ERROR_INVALID_THREAD,\\n\");\n-        printf(\"        actual: %s (%d)\\n\", TranslateError(err), err);\n-        result = STATUS_FAILED;\n-    }\n-\n-    if (!caps.can_suspend) {\n-        return result;\n-    }\n-\n-    err = jvmti->SuspendThread(thr);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(SuspendThread) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-    }\n-\n-    if (printdump == JNI_TRUE) {\n-        printf(\">>> invalid depth check ...\\n\");\n-    }\n-    err = jvmti->GetFrameLocation(thr, -1, &mid, &loc);\n-    if (err != JVMTI_ERROR_ILLEGAL_ARGUMENT) {\n-        printf(\"Error expected: JVMTI_ERROR_ILLEGAL_ARGUMENT,\\n\");\n-        printf(\"        actual: %s (%d)\\n\", TranslateError(err), err);\n-        result = STATUS_FAILED;\n-    }\n-\n-    if (printdump == JNI_TRUE) {\n-        printf(\">>> (methodPtr) null pointer check ...\\n\");\n-    }\n-    err = jvmti->GetFrameLocation(thr, 0, NULL, &loc);\n-    if (err != JVMTI_ERROR_NULL_POINTER) {\n-        printf(\"Error expected: JVMTI_ERROR_NULL_POINTER,\\n\");\n-        printf(\"        actual: %s (%d)\\n\", TranslateError(err), err);\n-        result = STATUS_FAILED;\n-    }\n-\n-    if (printdump == JNI_TRUE) {\n-        printf(\">>> (locationPtr) null pointer check ...\\n\");\n-    }\n-    err = jvmti->GetFrameLocation(thr, 0, &mid, NULL);\n-    if (err != JVMTI_ERROR_NULL_POINTER) {\n-        printf(\"Error expected: JVMTI_ERROR_NULL_POINTER,\\n\");\n-        printf(\"        actual: %s (%d)\\n\", TranslateError(err), err);\n-        result = STATUS_FAILED;\n-    }\n-\n-    err = jvmti->ResumeThread(thr);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(ResumeThread) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-    }\n-\n-    if (printdump == JNI_TRUE) {\n-        printf(\">>> ... done\\n\");\n-    }\n-\n-    return result;\n-}\n-\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetFrameLocation\/frameloc003\/frameloc003.cpp","additions":0,"deletions":170,"binary":false,"changes":170,"status":"deleted"},{"patch":"@@ -1,33 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include \"native_thread.cpp\"\n-#include \"nsk_tools.cpp\"\n-#include \"jni_tools.cpp\"\n-#include \"jvmti_tools.cpp\"\n-#include \"agent_tools.cpp\"\n-#include \"jvmti_FollowRefObjects.cpp\"\n-#include \"Injector.cpp\"\n-#include \"JVMTITools.cpp\"\n-#include \"agent_common.cpp\"\n-#include \"frameloc003.cpp\"\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetFrameLocation\/frameloc003\/libframeloc003.cpp","additions":0,"deletions":33,"binary":false,"changes":33,"status":"deleted"},{"patch":"@@ -1,60 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package nsk.jvmti.GetStackTrace;\n-\n-import java.io.PrintStream;\n-\n-public class getstacktr001 {\n-\n-    final static int JCK_STATUS_BASE = 95;\n-\n-    static {\n-        try {\n-            System.loadLibrary(\"getstacktr001\");\n-        } catch (UnsatisfiedLinkError ule) {\n-            System.err.println(\"Could not load getstacktr001 library\");\n-            System.err.println(\"java.library.path:\"\n-                + System.getProperty(\"java.library.path\"));\n-            throw ule;\n-        }\n-    }\n-\n-    native static int chain();\n-    native static void check(Thread thread);\n-\n-    public static void main(String args[]) {\n-        args = nsk.share.jvmti.JVMTITest.commonInit(args);\n-\n-        \/\/ produce JCK-like exit status.\n-        System.exit(run(args, System.out) + JCK_STATUS_BASE);\n-    }\n-\n-    public static int run(String args[], PrintStream out) {\n-        return chain();\n-    }\n-\n-    public static void dummy() {\n-        check(Thread.currentThread());\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetStackTrace\/getstacktr001.java","additions":0,"deletions":60,"binary":false,"changes":60,"status":"deleted"},{"patch":"@@ -1,47 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/*\n- * @test\n- *\n- * @summary converted from VM Testbase nsk\/jvmti\/GetStackTrace\/getstacktr001.\n- * VM Testbase keywords: [quick, jpda, jvmti, noras]\n- * VM Testbase readme:\n- * DESCRIPTION\n- *     The test exercises JVMTI function GetStackTrace for the current thread.\n- *     The test checks the following:\n- *       - if function returns the expected frame of a Java method\n- *       - if function returns the expected frame of a JNI method\n- *       - if function returns the expected number of frames.\n- * COMMENTS\n- *     Ported from JVMDI.\n- *\n- * @library \/vmTestbase\n- *          \/test\/lib\n- * @build nsk.jvmti.GetStackTrace.getstacktr001\n- * @run main\/othervm\/native ExecDriver --java\n- *      -agentlib:getstacktr001\n- *      nsk.jvmti.GetStackTrace.getstacktr001\n- *\/\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetStackTrace\/getstacktr001\/TestDescription.java","additions":0,"deletions":47,"binary":false,"changes":47,"status":"deleted"},{"patch":"@@ -1,174 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include <stdio.h>\n-#include <string.h>\n-#include \"jvmti.h\"\n-#include \"agent_common.h\"\n-#include \"JVMTITools.h\"\n-\n-extern \"C\" {\n-\n-\n-#define PASSED 0\n-#define STATUS_FAILED 2\n-\n-typedef struct {\n-    const char *cls;\n-    const char *name;\n-    const char *sig;\n-} frame_info;\n-\n-static jvmtiEnv *jvmti = NULL;\n-static jint result = PASSED;\n-static jboolean printdump = JNI_FALSE;\n-static frame_info frames[] = {\n-    { \"Lnsk\/jvmti\/GetStackTrace\/getstacktr001;\", \"check\",\n-     \"(Ljava\/lang\/Thread;)V\" },\n-    { \"Lnsk\/jvmti\/GetStackTrace\/getstacktr001;\", \"dummy\", \"()V\" },\n-    { \"Lnsk\/jvmti\/GetStackTrace\/getstacktr001;\", \"chain\", \"()I\" },\n-    { \"Lnsk\/jvmti\/GetStackTrace\/getstacktr001;\", \"run\",\n-     \"([Ljava\/lang\/String;Ljava\/io\/PrintStream;)I\" },\n-    { \"Lnsk\/jvmti\/GetStackTrace\/getstacktr001;\", \"main\",\n-     \"([Ljava\/lang\/String;)V\" }\n-};\n-\n-#define NUMBER_OF_STACK_FRAMES ((int) (sizeof(frames)\/sizeof(frame_info)))\n-\n-#ifdef STATIC_BUILD\n-JNIEXPORT jint JNICALL Agent_OnLoad_getstacktr001(JavaVM *jvm, char *options, void *reserved) {\n-    return Agent_Initialize(jvm, options, reserved);\n-}\n-JNIEXPORT jint JNICALL Agent_OnAttach_getstacktr001(JavaVM *jvm, char *options, void *reserved) {\n-    return Agent_Initialize(jvm, options, reserved);\n-}\n-JNIEXPORT jint JNI_OnLoad_getstacktr001(JavaVM *jvm, char *options, void *reserved) {\n-    return JNI_VERSION_1_8;\n-}\n-#endif\n-jint Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {\n-    jint res;\n-\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n-        printdump = JNI_TRUE;\n-    }\n-\n-    res = jvm->GetEnv((void **) &jvmti, JVMTI_VERSION_1_1);\n-    if (res != JNI_OK || jvmti == NULL) {\n-        printf(\"Wrong result of a valid call to GetEnv!\\n\");\n-        return JNI_ERR;\n-    }\n-\n-    return JNI_OK;\n-}\n-\n-JNIEXPORT jint JNICALL\n-Java_nsk_jvmti_GetStackTrace_getstacktr001_chain(JNIEnv *env, jclass cls) {\n-    jmethodID mid;\n-\n-    mid = env->GetStaticMethodID(cls, \"dummy\", \"()V\");\n-    env->CallStaticVoidMethod(cls, mid);\n-\n-    return result;\n-}\n-\n-JNIEXPORT void JNICALL\n-Java_nsk_jvmti_GetStackTrace_getstacktr001_check(JNIEnv *env, jclass cls, jthread thread) {\n-    jvmtiError err;\n-    jvmtiFrameInfo f[NUMBER_OF_STACK_FRAMES + 1];\n-    jclass callerClass;\n-    char *sigClass, *name, *sig, *generic;\n-    jint i, count;\n-\n-    if (jvmti == NULL) {\n-        printf(\"JVMTI client was not properly loaded!\\n\");\n-        result = STATUS_FAILED;\n-        return;\n-    }\n-\n-    err = jvmti->GetStackTrace(thread, 0,\n-        NUMBER_OF_STACK_FRAMES + 1, f, &count);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(GetStackTrace) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-        return;\n-    }\n-    if (count != NUMBER_OF_STACK_FRAMES) {\n-        printf(\"Wrong number of frames: %d, expected: %d\\n\",\n-               count, NUMBER_OF_STACK_FRAMES);\n-        result = STATUS_FAILED;\n-    }\n-    for (i = 0; i < count; i++) {\n-        if (printdump == JNI_TRUE) {\n-            printf(\">>> checking frame#%d ...\\n\", i);\n-        }\n-        err = jvmti->GetMethodDeclaringClass(\n-            f[i].method, &callerClass);\n-        if (err != JVMTI_ERROR_NONE) {\n-            printf(\"(GetMethodDeclaringClass#%d) unexpected error: %s (%d)\\n\",\n-                   i, TranslateError(err), err);\n-            result = STATUS_FAILED;\n-            continue;\n-        }\n-        err = jvmti->GetClassSignature(callerClass,\n-            &sigClass, &generic);\n-        if (err != JVMTI_ERROR_NONE) {\n-            printf(\"(GetClassSignature#%d) unexpected error: %s (%d)\\n\",\n-                   i, TranslateError(err), err);\n-            result = STATUS_FAILED;\n-            continue;\n-        }\n-        err = jvmti->GetMethodName(f[i].method, &name, &sig, &generic);\n-        if (err != JVMTI_ERROR_NONE) {\n-            printf(\"(GetMethodName#%d) unexpected error: %s (%d)\\n\",\n-                   i, TranslateError(err), err);\n-            result = STATUS_FAILED;\n-            continue;\n-        }\n-        if (printdump == JNI_TRUE) {\n-            printf(\">>>   class:  \\\"%s\\\"\\n\", sigClass);\n-            printf(\">>>   method: \\\"%s%s\\\"\\n\", name, sig);\n-            printf(\">>>   %d ... done\\n\", i);\n-        }\n-        if (i < NUMBER_OF_STACK_FRAMES) {\n-            if (sigClass == NULL || strcmp(sigClass, frames[i].cls) != 0) {\n-                printf(\"(frame#%d) wrong class sig: \\\"%s\\\", expected: \\\"%s\\\"\\n\",\n-                       i, sigClass, frames[i].cls);\n-                result = STATUS_FAILED;\n-            }\n-            if (name == NULL || strcmp(name, frames[i].name) != 0) {\n-                printf(\"(frame#%d) wrong method name: \\\"%s\\\", expected: \\\"%s\\\"\\n\",\n-                       i, name, frames[i].name);\n-                result = STATUS_FAILED;\n-            }\n-            if (sig == NULL || strcmp(sig, frames[i].sig) != 0) {\n-                printf(\"(frame#%d) wrong method sig: \\\"%s\\\", expected: \\\"%s\\\"\\n\",\n-                       i, sig, frames[i].sig);\n-                result = STATUS_FAILED;\n-            }\n-        }\n-    }\n-}\n-\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetStackTrace\/getstacktr001\/getstacktr001.cpp","additions":0,"deletions":174,"binary":false,"changes":174,"status":"deleted"},{"patch":"@@ -1,33 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include \"native_thread.cpp\"\n-#include \"nsk_tools.cpp\"\n-#include \"jni_tools.cpp\"\n-#include \"jvmti_tools.cpp\"\n-#include \"agent_tools.cpp\"\n-#include \"jvmti_FollowRefObjects.cpp\"\n-#include \"Injector.cpp\"\n-#include \"JVMTITools.cpp\"\n-#include \"agent_common.cpp\"\n-#include \"getstacktr001.cpp\"\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetStackTrace\/getstacktr001\/libgetstacktr001.cpp","additions":0,"deletions":33,"binary":false,"changes":33,"status":"deleted"},{"patch":"@@ -1,55 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package nsk.jvmti.GetStackTrace;\n-\n-import java.io.PrintStream;\n-\n-public class getstacktr002 {\n-\n-    final static int JCK_STATUS_BASE = 95;\n-\n-    static {\n-        try {\n-            System.loadLibrary(\"getstacktr002\");\n-        } catch (UnsatisfiedLinkError ule) {\n-            System.err.println(\"Could not load getstacktr002 library\");\n-            System.err.println(\"java.library.path:\"\n-                + System.getProperty(\"java.library.path\"));\n-            throw ule;\n-        }\n-    }\n-\n-    native static int check(Thread thread);\n-\n-    public static void main(String args[]) {\n-        args = nsk.share.jvmti.JVMTITest.commonInit(args);\n-\n-        \/\/ produce JCK-like exit status.\n-        System.exit(run(args, System.out) + JCK_STATUS_BASE);\n-    }\n-\n-    public static int run(String args[], PrintStream out) {\n-        return check(Thread.currentThread());\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetStackTrace\/getstacktr002.java","additions":0,"deletions":55,"binary":false,"changes":55,"status":"deleted"},{"patch":"@@ -1,46 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/*\n- * @test\n- *\n- * @summary converted from VM Testbase nsk\/jvmti\/GetStackTrace\/getstacktr002.\n- * VM Testbase keywords: [quick, jpda, jvmti, noras]\n- * VM Testbase readme:\n- * DESCRIPTION\n- *     The test exercises JVMTI function\n- *         GetStackTrace(thread, start_depth, max_count, stack_buffer, count_ptr).\n- *     The test checks the following:\n- *       - if JVMTI_ERROR_INVALID_THREAD is returned when thread is a thread object\n- *       - if JVMTI_ERROR_ILLEGAL_ARGUMENT is returned when max_count is -1\n- *       - if JVMTI_ERROR_NULL_POINTER is returned when stack_buffer is null\n- *       - if JVMTI_ERROR_NULL_POINTER is returned when count_ptr is null\n- * COMMENTS\n- *     Ported from JVMDI.\n- *\n- * @library \/vmTestbase\n- *          \/test\/lib\n- * @run main\/othervm\/native -agentlib:getstacktr002 nsk.jvmti.GetStackTrace.getstacktr002\n- *\/\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetStackTrace\/getstacktr002\/TestDescription.java","additions":0,"deletions":46,"binary":false,"changes":46,"status":"deleted"},{"patch":"@@ -1,125 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include <stdio.h>\n-#include <string.h>\n-#include \"jvmti.h\"\n-#include \"agent_common.h\"\n-#include \"JVMTITools.h\"\n-\n-extern \"C\" {\n-\n-\n-#define PASSED 0\n-#define STATUS_FAILED 2\n-\n-static jvmtiEnv *jvmti = NULL;\n-static jint result = PASSED;\n-static jboolean printdump = JNI_FALSE;\n-\n-#ifdef STATIC_BUILD\n-JNIEXPORT jint JNICALL Agent_OnLoad_getstacktr002(JavaVM *jvm, char *options, void *reserved) {\n-    return Agent_Initialize(jvm, options, reserved);\n-}\n-JNIEXPORT jint JNICALL Agent_OnAttach_getstacktr002(JavaVM *jvm, char *options, void *reserved) {\n-    return Agent_Initialize(jvm, options, reserved);\n-}\n-JNIEXPORT jint JNI_OnLoad_getstacktr002(JavaVM *jvm, char *options, void *reserved) {\n-    return JNI_VERSION_1_8;\n-}\n-#endif\n-jint Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {\n-    jint res;\n-\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n-        printdump = JNI_TRUE;\n-    }\n-\n-    res = jvm->GetEnv((void **) &jvmti, JVMTI_VERSION_1_1);\n-    if (res != JNI_OK || jvmti == NULL) {\n-        printf(\"Wrong result of a valid call to GetEnv!\\n\");\n-        return JNI_ERR;\n-    }\n-\n-    return JNI_OK;\n-}\n-\n-JNIEXPORT jint JNICALL\n-Java_nsk_jvmti_GetStackTrace_getstacktr002_check(JNIEnv *env, jclass cls, jthread thread) {\n-    jvmtiError err;\n-    jvmtiFrameInfo frame;\n-    jint count;\n-\n-    if (jvmti == NULL) {\n-        printf(\"JVMTI client was not properly loaded!\\n\");\n-        return STATUS_FAILED;\n-    }\n-\n-    if (printdump == JNI_TRUE) {\n-        printf(\">>> Invalid thread check ...\\n\");\n-    }\n-    err = jvmti->GetStackTrace(cls, 0, 1, &frame, &count);\n-    if (err != JVMTI_ERROR_INVALID_THREAD) {\n-        printf(\"Error expected: JVMTI_ERROR_INVALID_THREAD, got: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-    }\n-\n-    if (printdump == JNI_TRUE) {\n-        printf(\">>> Illegal max_count argument check ...\\n\");\n-    }\n-    err = jvmti->GetStackTrace(thread, 0, -1, &frame, &count);\n-    if (err != JVMTI_ERROR_ILLEGAL_ARGUMENT) {\n-        printf(\"Error expected: JVMTI_ERROR_ILLEGAL_ARGUMENT, got: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-    }\n-\n-    if (printdump == JNI_TRUE) {\n-        printf(\">>> (stack_buffer) null pointer check ...\\n\");\n-    }\n-    err = jvmti->GetStackTrace(thread, 0, 1, NULL, &count);\n-    if (err != JVMTI_ERROR_NULL_POINTER) {\n-        printf(\"(stack_buffer) error expected: JVMTI_ERROR_NULL_POINTER,\");\n-        printf(\" got: %s (%d)\\n\", TranslateError(err), err);\n-        result = STATUS_FAILED;\n-    }\n-\n-    if (printdump == JNI_TRUE) {\n-        printf(\">>> (count_ptr) null pointer check ...\\n\");\n-    }\n-    err = jvmti->GetStackTrace(thread, 0, 1, &frame, NULL);\n-    if (err != JVMTI_ERROR_NULL_POINTER) {\n-        printf(\"(count_ptr) error expected: JVMTI_ERROR_NULL_POINTER,\");\n-        printf(\" got: %s (%d)\\n\", TranslateError(err), err);\n-        result = STATUS_FAILED;\n-    }\n-\n-    if (printdump == JNI_TRUE) {\n-        printf(\">>> ... done\\n\");\n-    }\n-\n-    return result;\n-}\n-\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetStackTrace\/getstacktr002\/getstacktr002.cpp","additions":0,"deletions":125,"binary":false,"changes":125,"status":"deleted"},{"patch":"@@ -1,33 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include \"native_thread.cpp\"\n-#include \"nsk_tools.cpp\"\n-#include \"jni_tools.cpp\"\n-#include \"jvmti_tools.cpp\"\n-#include \"agent_tools.cpp\"\n-#include \"jvmti_FollowRefObjects.cpp\"\n-#include \"Injector.cpp\"\n-#include \"JVMTITools.cpp\"\n-#include \"agent_common.cpp\"\n-#include \"getstacktr002.cpp\"\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetStackTrace\/getstacktr002\/libgetstacktr002.cpp","additions":0,"deletions":33,"binary":false,"changes":33,"status":"deleted"},{"patch":"@@ -1,102 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package nsk.jvmti.GetStackTrace;\n-\n-import java.io.PrintStream;\n-\n-public class getstacktr003 {\n-\n-    final static int JCK_STATUS_BASE = 95;\n-\n-    static {\n-        try {\n-            System.loadLibrary(\"getstacktr003\");\n-        } catch (UnsatisfiedLinkError ule) {\n-            System.err.println(\"Could not load getstacktr003 library\");\n-            System.err.println(\"java.library.path:\"\n-                    + System.getProperty(\"java.library.path\"));\n-            throw ule;\n-        }\n-    }\n-\n-    native static void chain();\n-    native static int check(Thread thread);\n-\n-    public static Object lockIn = new Object();\n-    public static Object lockOut = new Object();\n-\n-    public static void main(String args[]) {\n-        args = nsk.share.jvmti.JVMTITest.commonInit(args);\n-\n-        \/\/ produce JCK-like exit status.\n-        System.exit(run(args, System.out) + JCK_STATUS_BASE);\n-    }\n-\n-    public static int run(String args[], PrintStream out) {\n-        int res;\n-        TestThread thr = new TestThread();\n-\n-        synchronized (lockIn) {\n-            thr.start();\n-            try {\n-                lockIn.wait();\n-            } catch (InterruptedException e) {\n-                throw new Error(\"Unexpected \" + e);\n-            }\n-        }\n-\n-\n-        synchronized (lockOut) {\n-            res = check(thr);\n-            lockOut.notify();\n-        }\n-\n-        try {\n-            thr.join();\n-        } catch (InterruptedException e) {\n-            throw new Error(\"Unexpected \" + e);\n-        }\n-\n-        return res;\n-    }\n-\n-    static void dummy() {\n-        synchronized (lockOut) {\n-            synchronized (lockIn) {\n-                lockIn.notify();\n-            }\n-            try {\n-                lockOut.wait();\n-            } catch (InterruptedException e) {\n-                throw new Error(\"Unexpected \" + e);\n-            }\n-        }\n-    }\n-\n-    static class TestThread extends Thread {\n-        public void run() {\n-            chain();\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetStackTrace\/getstacktr003.java","additions":0,"deletions":102,"binary":false,"changes":102,"status":"deleted"},{"patch":"@@ -1,44 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/*\n- * @test\n- *\n- * @summary converted from VM Testbase nsk\/jvmti\/GetStackTrace\/getstacktr003.\n- * VM Testbase keywords: [quick, jpda, jvmti, noras]\n- * VM Testbase readme:\n- * DESCRIPTION\n- *     The test exercises JVMTI function GetStackTrace for a non current thread.\n- *     The test checks the following:\n- *       - if function returns the expected frame of a Java method\n- *       - if function returns the expected frame of a JNI method\n- *       - if function returns the expected number of frames.\n- * COMMENTS\n- *     Ported from JVMDI.\n- *\n- * @library \/vmTestbase\n- *          \/test\/lib\n- * @run main\/othervm\/native -agentlib:getstacktr003 nsk.jvmti.GetStackTrace.getstacktr003\n- *\/\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetStackTrace\/getstacktr003\/TestDescription.java","additions":0,"deletions":44,"binary":false,"changes":44,"status":"deleted"},{"patch":"@@ -1,223 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include <stdio.h>\n-#include <string.h>\n-#include \"jvmti.h\"\n-#include \"agent_common.h\"\n-#include \"JVMTITools.h\"\n-\n-extern \"C\" {\n-\n-\n-#define PASSED 0\n-#define STATUS_FAILED 2\n-\n-typedef struct {\n-    const char *cls;\n-    const char *name;\n-    const char *sig;\n-} frame_info;\n-\n-static jvmtiEnv *jvmti = NULL;\n-static jvmtiCapabilities caps;\n-static jint result = PASSED;\n-static jboolean printdump = JNI_FALSE;\n-static frame_info frames[] = {\n-    { \"Ljava\/lang\/Object;\", \"wait\", \"()V\" },\n-    { \"Lnsk\/jvmti\/GetStackTrace\/getstacktr003;\", \"dummy\", \"()V\" },\n-    { \"Lnsk\/jvmti\/GetStackTrace\/getstacktr003;\", \"chain\", \"()V\" },\n-    { \"Lnsk\/jvmti\/GetStackTrace\/getstacktr003$TestThread;\", \"run\", \"()V\" },\n-};\n-\n-#define NUMBER_OF_STACK_FRAMES ((int) (sizeof(frames)\/sizeof(frame_info)))\n-#define MAX_NUMBER_OF_FRAMES 32\n-\n-#ifdef STATIC_BUILD\n-JNIEXPORT jint JNICALL Agent_OnLoad_getstacktr003(JavaVM *jvm, char *options, void *reserved) {\n-    return Agent_Initialize(jvm, options, reserved);\n-}\n-JNIEXPORT jint JNICALL Agent_OnAttach_getstacktr003(JavaVM *jvm, char *options, void *reserved) {\n-    return Agent_Initialize(jvm, options, reserved);\n-}\n-JNIEXPORT jint JNI_OnLoad_getstacktr003(JavaVM *jvm, char *options, void *reserved) {\n-    return JNI_VERSION_1_8;\n-}\n-#endif\n-jint Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {\n-    jvmtiError err;\n-    jint res;\n-\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n-        printdump = JNI_TRUE;\n-    }\n-\n-    res = jvm->GetEnv((void **) &jvmti, JVMTI_VERSION_1_1);\n-    if (res != JNI_OK || jvmti == NULL) {\n-        printf(\"Wrong result of a valid call to GetEnv!\\n\");\n-        return JNI_ERR;\n-    }\n-\n-    err = jvmti->GetPotentialCapabilities(&caps);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(GetPotentialCapabilities) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        return JNI_ERR;\n-    }\n-\n-    err = jvmti->AddCapabilities(&caps);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(AddCapabilities) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        return JNI_ERR;\n-    }\n-\n-    err = jvmti->GetCapabilities(&caps);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(GetCapabilities) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        return JNI_ERR;\n-    }\n-\n-    if (!caps.can_suspend) {\n-        printf(\"Warning: suspend\/resume is not implemented\\n\");\n-    }\n-\n-    return JNI_OK;\n-}\n-\n-JNIEXPORT void JNICALL\n-Java_nsk_jvmti_GetStackTrace_getstacktr003_chain(JNIEnv *env, jclass cls) {\n-    jmethodID mid;\n-\n-    mid = env->GetStaticMethodID(cls, \"dummy\", \"()V\");\n-    if (mid == NULL) {\n-        printf(\"Could not find method ID for dummy()V!\\n\");\n-    } else {\n-        env->CallStaticVoidMethod(cls, mid);\n-    }\n-\n-    return;\n-}\n-\n-JNIEXPORT int JNICALL\n-Java_nsk_jvmti_GetStackTrace_getstacktr003_check(JNIEnv *env, jclass cls, jthread thread) {\n-    jvmtiError err;\n-    jvmtiFrameInfo f[MAX_NUMBER_OF_FRAMES];\n-    jclass callerClass;\n-    char *sigClass, *name, *sig, *generic;\n-    jint i, count;\n-\n-    if (jvmti == NULL) {\n-        printf(\"JVMTI client was not properly loaded!\\n\");\n-        return STATUS_FAILED;\n-    }\n-\n-    if (!caps.can_suspend) {\n-        return result;\n-    }\n-\n-    err = jvmti->SuspendThread(thread);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(SuspendThread) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-        return result;\n-    }\n-\n-    err = jvmti->GetStackTrace(thread,\n-        0, MAX_NUMBER_OF_FRAMES, f, &count);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(GetStackTrace) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-        return result;\n-    }\n-    if (count < NUMBER_OF_STACK_FRAMES) {\n-        printf(\"Number of frames: %d is less then expected: %d\\n\",\n-               count, NUMBER_OF_STACK_FRAMES);\n-        result = STATUS_FAILED;\n-    }\n-    for (i = 0; i < count; i++) {\n-        if (printdump == JNI_TRUE) {\n-            printf(\">>> checking frame#%d ...\\n\", count-1-i);\n-        }\n-        err = jvmti->GetMethodDeclaringClass(f[count-1-i].method,\n-            &callerClass);\n-        if (err != JVMTI_ERROR_NONE) {\n-            printf(\"(GetMethodDeclaringClass#%d) unexpected error: %s (%d)\\n\",\n-                   count-1-i, TranslateError(err), err);\n-            result = STATUS_FAILED;\n-            continue;\n-        }\n-        err = jvmti->GetClassSignature(callerClass,\n-            &sigClass, &generic);\n-        if (err != JVMTI_ERROR_NONE) {\n-            printf(\"(GetClassSignature#%d) unexpected error: %s (%d)\\n\",\n-                   count-1-i, TranslateError(err), err);\n-            result = STATUS_FAILED;\n-            continue;\n-        }\n-        err = jvmti->GetMethodName(f[count-1-i].method,\n-            &name, &sig, &generic);\n-        if (err != JVMTI_ERROR_NONE) {\n-            printf(\"(GetMethodName#%d) unexpected error: %s (%d)\\n\",\n-                   count-1-i, TranslateError(err), err);\n-            result = STATUS_FAILED;\n-            continue;\n-        }\n-        if (printdump == JNI_TRUE) {\n-            printf(\">>>   class:  \\\"%s\\\"\\n\", sigClass);\n-            printf(\">>>   method: \\\"%s%s\\\"\\n\", name, sig);\n-            printf(\">>>   %d ... done\\n\", i);\n-        }\n-        if (i < NUMBER_OF_STACK_FRAMES) {\n-            if (sigClass == NULL || strcmp(sigClass, frames[NUMBER_OF_STACK_FRAMES-1-i].cls) != 0) {\n-                printf(\"(frame#%d) wrong class sig: \\\"%s\\\", expected: \\\"%s\\\"\\n\",\n-                       NUMBER_OF_STACK_FRAMES-1-i, sigClass, frames[NUMBER_OF_STACK_FRAMES-1-i].cls);\n-                result = STATUS_FAILED;\n-            }\n-            if (name == NULL || strcmp(name, frames[NUMBER_OF_STACK_FRAMES-1-i].name) != 0) {\n-                printf(\"(frame#%d) wrong method name: \\\"%s\\\", expected: \\\"%s\\\"\\n\",\n-                       NUMBER_OF_STACK_FRAMES-1-i, name, frames[NUMBER_OF_STACK_FRAMES-1-i].name);\n-                result = STATUS_FAILED;\n-            }\n-            if (sig == NULL || strcmp(sig, frames[NUMBER_OF_STACK_FRAMES-1-i].sig) != 0) {\n-                printf(\"(frame#%d) wrong method sig: \\\"%s\\\", expected: \\\"%s\\\"\\n\",\n-                       NUMBER_OF_STACK_FRAMES-1-i, sig, frames[NUMBER_OF_STACK_FRAMES-1-i].sig);\n-                result = STATUS_FAILED;\n-            }\n-        }\n-    }\n-\n-    err = jvmti->ResumeThread(thread);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(ResumeThread) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-    }\n-\n-    return result;\n-}\n-\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetStackTrace\/getstacktr003\/getstacktr003.cpp","additions":0,"deletions":223,"binary":false,"changes":223,"status":"deleted"},{"patch":"@@ -1,33 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include \"native_thread.cpp\"\n-#include \"nsk_tools.cpp\"\n-#include \"jni_tools.cpp\"\n-#include \"jvmti_tools.cpp\"\n-#include \"agent_tools.cpp\"\n-#include \"jvmti_FollowRefObjects.cpp\"\n-#include \"Injector.cpp\"\n-#include \"JVMTITools.cpp\"\n-#include \"agent_common.cpp\"\n-#include \"getstacktr003.cpp\"\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetStackTrace\/getstacktr003\/libgetstacktr003.cpp","additions":0,"deletions":33,"binary":false,"changes":33,"status":"deleted"},{"patch":"@@ -1,94 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package nsk.jvmti.GetStackTrace;\n-\n-import java.io.PrintStream;\n-\n-public class getstacktr004 {\n-\n-    final static int FAILED = 2;\n-    final static int JCK_STATUS_BASE = 95;\n-\n-    static {\n-        try {\n-            System.loadLibrary(\"getstacktr004\");\n-        } catch (UnsatisfiedLinkError ule) {\n-            System.err.println(\"Could not load getstacktr004 library\");\n-            System.err.println(\"java.library.path:\"\n-                + System.getProperty(\"java.library.path\"));\n-            throw ule;\n-        }\n-    }\n-\n-    native static void getReady(Class clazz);\n-    native static int getRes();\n-\n-    public static void main(String args[]) {\n-        args = nsk.share.jvmti.JVMTITest.commonInit(args);\n-\n-        \/\/ produce JCK-like exit status.\n-        System.exit(run(args, System.out) + JCK_STATUS_BASE);\n-    }\n-\n-    public static int run(String args[], PrintStream out) {\n-        TestThread thr = new TestThread();\n-        getReady(TestThread.class);\n-\n-        thr.start();\n-        try {\n-            thr.join();\n-        } catch (InterruptedException ex) {\n-            out.println(\"# Unexpected \" + ex);\n-            return FAILED;\n-        }\n-\n-        return getRes();\n-    }\n-\n-    static class TestThread extends Thread {\n-        public void run() {\n-            chain1();\n-        }\n-\n-        void chain1() {\n-            chain2();\n-        }\n-\n-        void chain2() {\n-            chain3();\n-        }\n-\n-        void chain3() {\n-            chain4();\n-        }\n-\n-        void chain4() {\n-            checkPoint();\n-        }\n-\n-        \/\/ dummy method to be breakpointed in agent\n-        void checkPoint() {\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetStackTrace\/getstacktr004.java","additions":0,"deletions":94,"binary":false,"changes":94,"status":"deleted"},{"patch":"@@ -1,43 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/*\n- * @test\n- *\n- * @summary converted from VM Testbase nsk\/jvmti\/GetStackTrace\/getstacktr004.\n- * VM Testbase keywords: [quick, jpda, jvmti, noras]\n- * VM Testbase readme:\n- * DESCRIPTION\n- *     The test exercises JVMTI function GetStackTrace via breakpoint.\n- *     The test starts a new thread, does some nested calls, stops at breakpoint\n- *     and checks if the number of frames in the thread's stack is as expected\n- *     and the function returns all the expected frames.\n- * COMMENTS\n- *     Ported from JVMDI.\n- *\n- * @library \/vmTestbase\n- *          \/test\/lib\n- * @run main\/othervm\/native -agentlib:getstacktr004 nsk.jvmti.GetStackTrace.getstacktr004\n- *\/\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetStackTrace\/getstacktr004\/TestDescription.java","additions":0,"deletions":43,"binary":false,"changes":43,"status":"deleted"},{"patch":"@@ -1,248 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include <stdio.h>\n-#include <string.h>\n-#include \"jvmti.h\"\n-#include \"agent_common.h\"\n-#include \"JVMTITools.h\"\n-\n-extern \"C\" {\n-\n-\n-#define PASSED 0\n-#define STATUS_FAILED 2\n-\n-typedef struct {\n-    const char *cls;\n-    const char *name;\n-    const char *sig;\n-} frame_info;\n-\n-static jvmtiEnv *jvmti = NULL;\n-static jvmtiCapabilities caps;\n-static jvmtiEventCallbacks callbacks;\n-static jint result = PASSED;\n-static jboolean printdump = JNI_FALSE;\n-static jmethodID mid;\n-static frame_info frames[] = {\n-    { \"Lnsk\/jvmti\/GetStackTrace\/getstacktr004$TestThread;\", \"checkPoint\", \"()V\" },\n-    { \"Lnsk\/jvmti\/GetStackTrace\/getstacktr004$TestThread;\", \"chain4\", \"()V\" },\n-    { \"Lnsk\/jvmti\/GetStackTrace\/getstacktr004$TestThread;\", \"chain3\", \"()V\" },\n-    { \"Lnsk\/jvmti\/GetStackTrace\/getstacktr004$TestThread;\", \"chain2\", \"()V\" },\n-    { \"Lnsk\/jvmti\/GetStackTrace\/getstacktr004$TestThread;\", \"chain1\", \"()V\" },\n-    { \"Lnsk\/jvmti\/GetStackTrace\/getstacktr004$TestThread;\", \"run\", \"()V\" },\n-};\n-\n-#define NUMBER_OF_STACK_FRAMES ((int) (sizeof(frames)\/sizeof(frame_info)))\n-\n-void check(jvmtiEnv *jvmti_env, jthread thr) {\n-    jvmtiError err;\n-    jvmtiFrameInfo f[NUMBER_OF_STACK_FRAMES + 1];\n-    jclass callerClass;\n-    char *sigClass, *name, *sig, *generic;\n-    jint i, count;\n-\n-    err = jvmti_env->GetStackTrace(thr,\n-        0, NUMBER_OF_STACK_FRAMES + 1, f, &count);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(GetStackTrace) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-        return;\n-    }\n-    if (count != NUMBER_OF_STACK_FRAMES) {\n-        printf(\"Wrong frame count, expected: %d, actual: %d\\n\",\n-               NUMBER_OF_STACK_FRAMES, count);\n-        result = STATUS_FAILED;\n-    }\n-\n-    if (printdump == JNI_TRUE) {\n-            printf(\">>>   frame count: %d\\n\", count);\n-    }\n-    for (i = 0; i < count; i++) {\n-        if (printdump == JNI_TRUE) {\n-            printf(\">>> checking frame#%d ...\\n\", i);\n-        }\n-        err = jvmti_env->GetMethodDeclaringClass(f[i].method,\n-            &callerClass);\n-        if (err != JVMTI_ERROR_NONE) {\n-            printf(\"(GetMethodDeclaringClass#%d) unexpected error: %s (%d)\\n\",\n-                   i, TranslateError(err), err);\n-            result = STATUS_FAILED;\n-            continue;\n-        }\n-        err = jvmti_env->GetClassSignature(callerClass,\n-            &sigClass, &generic);\n-        if (err != JVMTI_ERROR_NONE) {\n-            printf(\"(GetClassSignature#%d) unexpected error: %s (%d)\\n\",\n-                   i, TranslateError(err), err);\n-            result = STATUS_FAILED;\n-            continue;\n-        }\n-        err = jvmti_env->GetMethodName(f[i].method,\n-            &name, &sig, &generic);\n-        if (err != JVMTI_ERROR_NONE) {\n-            printf(\"(GetMethodName#%d) unexpected error: %s (%d)\\n\",\n-                   i, TranslateError(err), err);\n-            result = STATUS_FAILED;\n-            continue;\n-        }\n-        if (printdump == JNI_TRUE) {\n-            printf(\">>>   class:  \\\"%s\\\"\\n\", sigClass);\n-            printf(\">>>   method: \\\"%s%s\\\"\\n\", name, sig);\n-        }\n-        if (i < NUMBER_OF_STACK_FRAMES) {\n-            if (sigClass == NULL || strcmp(sigClass, frames[i].cls) != 0) {\n-                printf(\"(frame#%d) wrong class sig: \\\"%s\\\", expected: \\\"%s\\\"\\n\",\n-                       i, sigClass, frames[i].cls);\n-                result = STATUS_FAILED;\n-            }\n-            if (name == NULL || strcmp(name, frames[i].name) != 0) {\n-                printf(\"(frame#%d) wrong method name: \\\"%s\\\", expected: \\\"%s\\\"\\n\",\n-                       i, name, frames[i].name);\n-                result = STATUS_FAILED;\n-            }\n-            if (sig == NULL || strcmp(sig, frames[i].sig) != 0) {\n-                printf(\"(frame#%d) wrong method sig: \\\"%s\\\", expected: \\\"%s\\\"\\n\",\n-                       i, sig, frames[i].sig);\n-                result = STATUS_FAILED;\n-            }\n-        }\n-    }\n-}\n-\n-void JNICALL Breakpoint(jvmtiEnv *jvmti_env, JNIEnv *env,\n-        jthread thr, jmethodID method, jlocation location) {\n-    if (mid != method) {\n-        printf(\"ERROR: didn't know where we got called from\");\n-        result = STATUS_FAILED;\n-        return;\n-    }\n-    check(jvmti_env, thr);\n-}\n-\n-#ifdef STATIC_BUILD\n-JNIEXPORT jint JNICALL Agent_OnLoad_getstacktr004(JavaVM *jvm, char *options, void *reserved) {\n-    return Agent_Initialize(jvm, options, reserved);\n-}\n-JNIEXPORT jint JNICALL Agent_OnAttach_getstacktr004(JavaVM *jvm, char *options, void *reserved) {\n-    return Agent_Initialize(jvm, options, reserved);\n-}\n-JNIEXPORT jint JNI_OnLoad_getstacktr004(JavaVM *jvm, char *options, void *reserved) {\n-    return JNI_VERSION_1_8;\n-}\n-#endif\n-jint Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {\n-    jvmtiError err;\n-    jint res;\n-\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n-        printdump = JNI_TRUE;\n-    }\n-\n-    res = jvm->GetEnv((void **) &jvmti, JVMTI_VERSION_1_1);\n-    if (res != JNI_OK || jvmti == NULL) {\n-        printf(\"Wrong result of a valid call to GetEnv!\\n\");\n-        return JNI_ERR;\n-    }\n-\n-    err = jvmti->GetPotentialCapabilities(&caps);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(GetPotentialCapabilities) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        return JNI_ERR;\n-    }\n-\n-    err = jvmti->AddCapabilities(&caps);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(AddCapabilities) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        return JNI_ERR;\n-    }\n-\n-    err = jvmti->GetCapabilities(&caps);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(GetCapabilities) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        return JNI_ERR;\n-    }\n-\n-    if (caps.can_generate_breakpoint_events) {\n-        callbacks.Breakpoint = &Breakpoint;\n-        err = jvmti->SetEventCallbacks(&callbacks, sizeof(callbacks));\n-        if (err != JVMTI_ERROR_NONE) {\n-            printf(\"(SetEventCallbacks) unexpected error: %s (%d)\\n\",\n-                   TranslateError(err), err);\n-            return JNI_ERR;\n-        }\n-    } else {\n-        printf(\"Warning: Breakpoint is not implemented\\n\");\n-    }\n-\n-    return JNI_OK;\n-}\n-\n-JNIEXPORT void JNICALL\n-Java_nsk_jvmti_GetStackTrace_getstacktr004_getReady(JNIEnv *env, jclass cls, jclass clazz) {\n-    jvmtiError err;\n-\n-    if (jvmti == NULL) {\n-        printf(\"JVMTI client was not properly loaded!\\n\");\n-        result = STATUS_FAILED;\n-        return;\n-    }\n-\n-    if (!caps.can_generate_breakpoint_events) {\n-        return;\n-    }\n-\n-    mid = env->GetMethodID(clazz, \"checkPoint\", \"()V\");\n-    if (mid == NULL) {\n-        printf(\"Cannot find Method ID for method checkPoint\\n\");\n-        result = STATUS_FAILED;\n-        return;\n-    }\n-    err = jvmti->SetBreakpoint(mid, 0);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(SetBreakpoint) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-        return;\n-    }\n-\n-    err = jvmti->SetEventNotificationMode(JVMTI_ENABLE,\n-        JVMTI_EVENT_BREAKPOINT, NULL);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"Failed to enable BREAKPOINT event: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-    }\n-}\n-\n-JNIEXPORT jint JNICALL\n-Java_nsk_jvmti_GetStackTrace_getstacktr004_getRes(JNIEnv *env, jclass cls) {\n-    return result;\n-}\n-\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetStackTrace\/getstacktr004\/getstacktr004.cpp","additions":0,"deletions":248,"binary":false,"changes":248,"status":"deleted"},{"patch":"@@ -1,33 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include \"native_thread.cpp\"\n-#include \"nsk_tools.cpp\"\n-#include \"jni_tools.cpp\"\n-#include \"jvmti_tools.cpp\"\n-#include \"agent_tools.cpp\"\n-#include \"jvmti_FollowRefObjects.cpp\"\n-#include \"Injector.cpp\"\n-#include \"JVMTITools.cpp\"\n-#include \"agent_common.cpp\"\n-#include \"getstacktr004.cpp\"\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetStackTrace\/getstacktr004\/libgetstacktr004.cpp","additions":0,"deletions":33,"binary":false,"changes":33,"status":"deleted"},{"patch":"@@ -1,94 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package nsk.jvmti.GetStackTrace;\n-\n-import java.io.PrintStream;\n-\n-public class getstacktr005 {\n-\n-    final static int FAILED = 2;\n-    final static int JCK_STATUS_BASE = 95;\n-\n-    static {\n-        try {\n-            System.loadLibrary(\"getstacktr005\");\n-        } catch (UnsatisfiedLinkError ule) {\n-            System.err.println(\"Could not load getstacktr005 library\");\n-            System.err.println(\"java.library.path:\"\n-                + System.getProperty(\"java.library.path\"));\n-            throw ule;\n-        }\n-    }\n-\n-    native static void getReady(Class clazz);\n-    native static int getRes();\n-\n-    public static void main(String args[]) {\n-        args = nsk.share.jvmti.JVMTITest.commonInit(args);\n-\n-        \/\/ produce JCK-like exit status.\n-        System.exit(run(args, System.out) + JCK_STATUS_BASE);\n-    }\n-\n-    public static int run(String args[], PrintStream out) {\n-        TestThread thr = new TestThread();\n-        getReady(TestThread.class);\n-\n-        thr.start();\n-        try {\n-            thr.join();\n-        } catch (InterruptedException ex) {\n-            out.println(\"# Unexpected \" + ex);\n-            return FAILED;\n-        }\n-\n-        return getRes();\n-    }\n-\n-    static class TestThread extends Thread {\n-        public void run() {\n-            chain1();\n-        }\n-\n-        void chain1() {\n-            chain2();\n-        }\n-\n-        void chain2() {\n-            chain3();\n-        }\n-\n-        void chain3() {\n-            chain4();\n-        }\n-\n-        void chain4() {\n-            checkPoint();\n-        }\n-\n-        \/\/ dummy method to be breakpointed in agent\n-        void checkPoint() {\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetStackTrace\/getstacktr005.java","additions":0,"deletions":94,"binary":false,"changes":94,"status":"deleted"},{"patch":"@@ -1,44 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/*\n- * @test\n- *\n- * @summary converted from VM Testbase nsk\/jvmti\/GetStackTrace\/getstacktr005.\n- * VM Testbase keywords: [quick, jpda, jvmti, noras]\n- * VM Testbase readme:\n- * DESCRIPTION\n- *     The test exercises JVMTI function GetStackTrace via breakpoint\n- *     and consequent step.\n- *     The test starts a new thread, does some nested calls, stops at breakpoint,\n- *     does single step and checks if the number of frames in the thread's\n- *     stack is as expected and the function returns all the expected frames.\n- * COMMENTS\n- *     Ported from JVMDI.\n- *\n- * @library \/vmTestbase\n- *          \/test\/lib\n- * @run main\/othervm\/native -agentlib:getstacktr005 nsk.jvmti.GetStackTrace.getstacktr005\n- *\/\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetStackTrace\/getstacktr005\/TestDescription.java","additions":0,"deletions":44,"binary":false,"changes":44,"status":"deleted"},{"patch":"@@ -1,300 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include <stdio.h>\n-#include <string.h>\n-#include \"jvmti.h\"\n-#include \"agent_common.h\"\n-#include \"JVMTITools.h\"\n-\n-extern \"C\" {\n-\n-\n-#define PASSED 0\n-#define STATUS_FAILED 2\n-\n-typedef struct {\n-    const char *cls;\n-    const char *name;\n-    const char *sig;\n-} frame_info;\n-\n-static jvmtiEnv *jvmti = NULL;\n-static jvmtiCapabilities caps;\n-static jvmtiEventCallbacks callbacks;\n-static jint result = PASSED;\n-static jboolean printdump = JNI_FALSE;\n-static jmethodID mid;\n-static frame_info frames[] = {\n-    { \"Lnsk\/jvmti\/GetStackTrace\/getstacktr005$TestThread;\", \"chain4\", \"()V\" },\n-    { \"Lnsk\/jvmti\/GetStackTrace\/getstacktr005$TestThread;\", \"chain3\", \"()V\" },\n-    { \"Lnsk\/jvmti\/GetStackTrace\/getstacktr005$TestThread;\", \"chain2\", \"()V\" },\n-    { \"Lnsk\/jvmti\/GetStackTrace\/getstacktr005$TestThread;\", \"chain1\", \"()V\" },\n-    { \"Lnsk\/jvmti\/GetStackTrace\/getstacktr005$TestThread;\", \"run\", \"()V\" },\n-};\n-\n-#define NUMBER_OF_STACK_FRAMES ((int) (sizeof(frames)\/sizeof(frame_info)))\n-\n-void check(jvmtiEnv *jvmti_env, jthread thr) {\n-    jvmtiError err;\n-    jvmtiFrameInfo f[NUMBER_OF_STACK_FRAMES + 1];\n-    jclass callerClass;\n-    char *sigClass, *name, *sig, *generic;\n-    jint i, count;\n-\n-    err = jvmti_env->GetStackTrace(thr,\n-        0, NUMBER_OF_STACK_FRAMES + 1, f, &count);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(GetStackTrace) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-        return;\n-    }\n-    if (count != NUMBER_OF_STACK_FRAMES) {\n-        printf(\"Wrong frame count, expected: %d, actual: %d\\n\",\n-               NUMBER_OF_STACK_FRAMES, count);\n-        result = STATUS_FAILED;\n-    }\n-\n-    if (printdump == JNI_TRUE) {\n-            printf(\">>>   frame count: %d\\n\", count);\n-    }\n-    for (i = 0; i < count; i++) {\n-        if (printdump == JNI_TRUE) {\n-            printf(\">>> checking frame#%d ...\\n\", i);\n-        }\n-        err = jvmti_env->GetMethodDeclaringClass(f[i].method,\n-            &callerClass);\n-        if (err != JVMTI_ERROR_NONE) {\n-            printf(\"(GetMethodDeclaringClass#%d) unexpected error: %s (%d)\\n\",\n-                   i, TranslateError(err), err);\n-            result = STATUS_FAILED;\n-            continue;\n-        }\n-        err = jvmti_env->GetClassSignature(callerClass,\n-            &sigClass, &generic);\n-        if (err != JVMTI_ERROR_NONE) {\n-            printf(\"(GetClassSignature#%d) unexpected error: %s (%d)\\n\",\n-                   i, TranslateError(err), err);\n-            result = STATUS_FAILED;\n-            continue;\n-        }\n-        err = jvmti_env->GetMethodName(f[i].method,\n-            &name, &sig, &generic);\n-        if (err != JVMTI_ERROR_NONE) {\n-            printf(\"(GetMethodName#%d) unexpected error: %s (%d)\\n\",\n-                   i, TranslateError(err), err);\n-            result = STATUS_FAILED;\n-            continue;\n-        }\n-        if (printdump == JNI_TRUE) {\n-            printf(\">>>   class:  \\\"%s\\\"\\n\", sigClass);\n-            printf(\">>>   method: \\\"%s%s\\\"\\n\", name, sig);\n-        }\n-        if (i < NUMBER_OF_STACK_FRAMES) {\n-            if (sigClass == NULL || strcmp(sigClass, frames[i].cls) != 0) {\n-                printf(\"(frame#%d) wrong class sig: \\\"%s\\\", expected: \\\"%s\\\"\\n\",\n-                       i, sigClass, frames[i].cls);\n-                result = STATUS_FAILED;\n-            }\n-            if (name == NULL || strcmp(name, frames[i].name) != 0) {\n-                printf(\"(frame#%d) wrong method name: \\\"%s\\\", expected: \\\"%s\\\"\\n\",\n-                       i, name, frames[i].name);\n-                result = STATUS_FAILED;\n-            }\n-            if (sig == NULL || strcmp(sig, frames[i].sig) != 0) {\n-                printf(\"(frame#%d) wrong method sig: \\\"%s\\\", expected: \\\"%s\\\"\\n\",\n-                       i, sig, frames[i].sig);\n-                result = STATUS_FAILED;\n-            }\n-        }\n-    }\n-}\n-\n-void JNICALL Breakpoint(jvmtiEnv *jvmti_env, JNIEnv *env,\n-        jthread thr, jmethodID method, jlocation location) {\n-    jvmtiError err;\n-    jint frameCount = 0;\n-\n-    if (mid != method) {\n-        printf(\"ERROR: didn't know where we got called from\");\n-        result = STATUS_FAILED;\n-        return;\n-    }\n-\n-    if (printdump == JNI_TRUE) {\n-        printf(\">>> (bp) checking frame count ...\\n\");\n-    }\n-\n-    err = jvmti->GetFrameCount(thr, &frameCount);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(GetFrameCount#bp) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-        return;\n-    }\n-\n-    if (frameCount != NUMBER_OF_STACK_FRAMES + 1) {\n-        printf(\"(bp) wrong frame count, expected: %d, actual: %d\\n\",\n-               NUMBER_OF_STACK_FRAMES + 1, frameCount);\n-        result = STATUS_FAILED;\n-    }\n-\n-    if (printdump == JNI_TRUE) {\n-            printf(\">>> (bp)   frameCount: %d\\n\", frameCount);\n-    }\n-\n-    err = jvmti->SetEventNotificationMode(JVMTI_ENABLE,\n-        JVMTI_EVENT_SINGLE_STEP, thr);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"Cannot enable step mode: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-    }\n-\n-    if (printdump == JNI_TRUE) {\n-        printf(\">>> stepping ...\\n\");\n-    }\n-}\n-\n-void JNICALL SingleStep(jvmtiEnv *jvmti_env, JNIEnv *env,\n-        jthread thr, jmethodID method, jlocation location) {\n-    jvmtiError err;\n-\n-    check(jvmti_env, thr);\n-    err = jvmti->SetEventNotificationMode(JVMTI_DISABLE,\n-        JVMTI_EVENT_SINGLE_STEP, thr);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"Cannot disable step mode: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-    }\n-}\n-\n-#ifdef STATIC_BUILD\n-JNIEXPORT jint JNICALL Agent_OnLoad_getstacktr005(JavaVM *jvm, char *options, void *reserved) {\n-    return Agent_Initialize(jvm, options, reserved);\n-}\n-JNIEXPORT jint JNICALL Agent_OnAttach_getstacktr005(JavaVM *jvm, char *options, void *reserved) {\n-    return Agent_Initialize(jvm, options, reserved);\n-}\n-JNIEXPORT jint JNI_OnLoad_getstacktr005(JavaVM *jvm, char *options, void *reserved) {\n-    return JNI_VERSION_1_8;\n-}\n-#endif\n-jint Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {\n-    jvmtiError err;\n-    jint res;\n-\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n-        printdump = JNI_TRUE;\n-    }\n-\n-    res = jvm->GetEnv((void **) &jvmti, JVMTI_VERSION_1_1);\n-    if (res != JNI_OK || jvmti == NULL) {\n-        printf(\"Wrong result of a valid call to GetEnv!\\n\");\n-        return JNI_ERR;\n-    }\n-\n-    err = jvmti->GetPotentialCapabilities(&caps);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(GetPotentialCapabilities) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        return JNI_ERR;\n-    }\n-\n-    err = jvmti->AddCapabilities(&caps);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(AddCapabilities) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        return JNI_ERR;\n-    }\n-\n-    err = jvmti->GetCapabilities(&caps);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(GetCapabilities) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        return JNI_ERR;\n-    }\n-\n-    if (caps.can_generate_breakpoint_events &&\n-            caps.can_generate_single_step_events) {\n-        callbacks.Breakpoint = &Breakpoint;\n-        callbacks.SingleStep = &SingleStep;\n-        err = jvmti->SetEventCallbacks(&callbacks, sizeof(callbacks));\n-        if (err != JVMTI_ERROR_NONE) {\n-            printf(\"(SetEventCallbacks) unexpected error: %s (%d)\\n\",\n-                   TranslateError(err), err);\n-            return JNI_ERR;\n-        }\n-    } else {\n-        printf(\"Warning: Breakpoint or SingleStep event is not implemented\\n\");\n-    }\n-\n-    return JNI_OK;\n-}\n-\n-JNIEXPORT void JNICALL\n-Java_nsk_jvmti_GetStackTrace_getstacktr005_getReady(JNIEnv *env, jclass cls, jclass clazz) {\n-    jvmtiError err;\n-\n-    if (jvmti == NULL) {\n-        printf(\"JVMTI client was not properly loaded!\\n\");\n-        result = STATUS_FAILED;\n-        return;\n-    }\n-\n-    if (!caps.can_generate_breakpoint_events ||\n-            !caps.can_generate_single_step_events) {\n-        return;\n-    }\n-\n-    mid = env->GetMethodID(clazz, \"checkPoint\", \"()V\");\n-    if (mid == NULL) {\n-        printf(\"Cannot find Method ID for method checkPoint\\n\");\n-        result = STATUS_FAILED;\n-        return;\n-    }\n-    err = jvmti->SetBreakpoint(mid, 0);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(SetBreakpoint) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-        return;\n-    }\n-\n-    err = jvmti->SetEventNotificationMode(JVMTI_ENABLE,\n-        JVMTI_EVENT_BREAKPOINT, NULL);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"Failed to enable BREAKPOINT event: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-    }\n-}\n-\n-JNIEXPORT jint JNICALL\n-Java_nsk_jvmti_GetStackTrace_getstacktr005_getRes(JNIEnv *env, jclass cls) {\n-    return result;\n-}\n-\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetStackTrace\/getstacktr005\/getstacktr005.cpp","additions":0,"deletions":300,"binary":false,"changes":300,"status":"deleted"},{"patch":"@@ -1,33 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include \"native_thread.cpp\"\n-#include \"nsk_tools.cpp\"\n-#include \"jni_tools.cpp\"\n-#include \"jvmti_tools.cpp\"\n-#include \"agent_tools.cpp\"\n-#include \"jvmti_FollowRefObjects.cpp\"\n-#include \"Injector.cpp\"\n-#include \"JVMTITools.cpp\"\n-#include \"agent_common.cpp\"\n-#include \"getstacktr005.cpp\"\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetStackTrace\/getstacktr005\/libgetstacktr005.cpp","additions":0,"deletions":33,"binary":false,"changes":33,"status":"deleted"},{"patch":"@@ -1,94 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package nsk.jvmti.GetStackTrace;\n-\n-import java.io.PrintStream;\n-\n-public class getstacktr006 {\n-\n-    final static int FAILED = 2;\n-    final static int JCK_STATUS_BASE = 95;\n-\n-    static {\n-        try {\n-            System.loadLibrary(\"getstacktr006\");\n-        } catch (UnsatisfiedLinkError ule) {\n-            System.err.println(\"Could not load getstacktr006 library\");\n-            System.err.println(\"java.library.path:\"\n-                + System.getProperty(\"java.library.path\"));\n-            throw ule;\n-        }\n-    }\n-\n-    native static void getReady(Class clazz);\n-    native static int getRes();\n-\n-    public static void main(String args[]) {\n-        args = nsk.share.jvmti.JVMTITest.commonInit(args);\n-\n-        \/\/ produce JCK-like exit status.\n-        System.exit(run(args, System.out) + JCK_STATUS_BASE);\n-    }\n-\n-    public static int run(String args[], PrintStream out) {\n-        TestThread thr = new TestThread();\n-        getReady(TestThread.class);\n-\n-        thr.start();\n-        try {\n-            thr.join();\n-        } catch (InterruptedException ex) {\n-            out.println(\"# Unexpected \" + ex);\n-            return FAILED;\n-        }\n-\n-        return getRes();\n-    }\n-\n-    static class TestThread extends Thread {\n-        public void run() {\n-            chain1();\n-        }\n-\n-        void chain1() {\n-            chain2();\n-        }\n-\n-        void chain2() {\n-            chain3();\n-        }\n-\n-        void chain3() {\n-            chain4();\n-        }\n-\n-        void chain4() {\n-            checkPoint();\n-        }\n-\n-        \/\/ dummy method to be breakpointed in agent\n-        void checkPoint() {\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetStackTrace\/getstacktr006.java","additions":0,"deletions":94,"binary":false,"changes":94,"status":"deleted"},{"patch":"@@ -1,45 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/*\n- * @test\n- *\n- * @summary converted from VM Testbase nsk\/jvmti\/GetStackTrace\/getstacktr006.\n- * VM Testbase keywords: [quick, jpda, jvmti, noras]\n- * VM Testbase readme:\n- * DESCRIPTION\n- *     The test exercises JVMTI function GetStackTrace via breakpoint\n- *     and consequent popping a frame.\n- *     The test starts a new thread, does some nested calls, stops at breakpoint,\n- *     pops frame, catches single step event and checks if the number of frames\n- *     in the thread's stack is as expected and the function returns all\n- *     the expected frames.\n- * COMMENTS\n- *     Ported from JVMDI.\n- *\n- * @library \/vmTestbase\n- *          \/test\/lib\n- * @run main\/othervm\/native -agentlib:getstacktr006 nsk.jvmti.GetStackTrace.getstacktr006\n- *\/\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetStackTrace\/getstacktr006\/TestDescription.java","additions":0,"deletions":45,"binary":false,"changes":45,"status":"deleted"},{"patch":"@@ -1,308 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include <stdio.h>\n-#include <string.h>\n-#include \"jvmti.h\"\n-#include \"agent_common.h\"\n-#include \"JVMTITools.h\"\n-\n-extern \"C\" {\n-\n-\n-#define PASSED 0\n-#define STATUS_FAILED 2\n-\n-typedef struct {\n-    const char *cls;\n-    const char *name;\n-    const char *sig;\n-} frame_info;\n-\n-static jvmtiEnv *jvmti = NULL;\n-static jvmtiCapabilities caps;\n-static jvmtiEventCallbacks callbacks;\n-static jint result = PASSED;\n-static jboolean printdump = JNI_FALSE;\n-static jmethodID mid;\n-static frame_info frames[] = {\n-    { \"Lnsk\/jvmti\/GetStackTrace\/getstacktr006$TestThread;\", \"chain4\", \"()V\" },\n-    { \"Lnsk\/jvmti\/GetStackTrace\/getstacktr006$TestThread;\", \"chain3\", \"()V\" },\n-    { \"Lnsk\/jvmti\/GetStackTrace\/getstacktr006$TestThread;\", \"chain2\", \"()V\" },\n-    { \"Lnsk\/jvmti\/GetStackTrace\/getstacktr006$TestThread;\", \"chain1\", \"()V\" },\n-    { \"Lnsk\/jvmti\/GetStackTrace\/getstacktr006$TestThread;\", \"run\", \"()V\" },\n-};\n-\n-#define NUMBER_OF_STACK_FRAMES ((int) (sizeof(frames)\/sizeof(frame_info)))\n-\n-void check(jvmtiEnv *jvmti_env, jthread thr) {\n-    jvmtiError err;\n-    jvmtiFrameInfo f[NUMBER_OF_STACK_FRAMES + 1];\n-    jclass callerClass;\n-    char *sigClass, *name, *sig, *generic;\n-    jint i, count;\n-\n-    err = jvmti_env->GetStackTrace(thr,\n-        0, NUMBER_OF_STACK_FRAMES + 1, f, &count);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(GetStackTrace) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-        return;\n-    }\n-    if (count != NUMBER_OF_STACK_FRAMES) {\n-        printf(\"Wrong frame count, expected: %d, actual: %d\\n\",\n-               NUMBER_OF_STACK_FRAMES, count);\n-        result = STATUS_FAILED;\n-    }\n-\n-    if (printdump == JNI_TRUE) {\n-            printf(\">>>   frame count: %d\\n\", count);\n-    }\n-    for (i = 0; i < count; i++) {\n-        if (printdump == JNI_TRUE) {\n-            printf(\">>> checking frame#%d ...\\n\", i);\n-        }\n-        err = jvmti_env->GetMethodDeclaringClass(f[i].method,\n-            &callerClass);\n-        if (err != JVMTI_ERROR_NONE) {\n-            printf(\"(GetMethodDeclaringClass#%d) unexpected error: %s (%d)\\n\",\n-                   i, TranslateError(err), err);\n-            result = STATUS_FAILED;\n-            continue;\n-        }\n-        err = jvmti_env->GetClassSignature(callerClass,\n-            &sigClass, &generic);\n-        if (err != JVMTI_ERROR_NONE) {\n-            printf(\"(GetClassSignature#%d) unexpected error: %s (%d)\\n\",\n-                   i, TranslateError(err), err);\n-            result = STATUS_FAILED;\n-            continue;\n-        }\n-        err = jvmti_env->GetMethodName(f[i].method,\n-            &name, &sig, &generic);\n-        if (err != JVMTI_ERROR_NONE) {\n-            printf(\"(GetMethodName#%d) unexpected error: %s (%d)\\n\",\n-                   i, TranslateError(err), err);\n-            result = STATUS_FAILED;\n-            continue;\n-        }\n-        if (printdump == JNI_TRUE) {\n-            printf(\">>>   class:  \\\"%s\\\"\\n\", sigClass);\n-            printf(\">>>   method: \\\"%s%s\\\"\\n\", name, sig);\n-        }\n-        if (i < NUMBER_OF_STACK_FRAMES) {\n-            if (sigClass == NULL || strcmp(sigClass, frames[i].cls) != 0) {\n-                printf(\"(frame#%d) wrong class sig: \\\"%s\\\", expected: \\\"%s\\\"\\n\",\n-                       i, sigClass, frames[i].cls);\n-                result = STATUS_FAILED;\n-            }\n-            if (name == NULL || strcmp(name, frames[i].name) != 0) {\n-                printf(\"(frame#%d) wrong method name: \\\"%s\\\", expected: \\\"%s\\\"\\n\",\n-                       i, name, frames[i].name);\n-                result = STATUS_FAILED;\n-            }\n-            if (sig == NULL || strcmp(sig, frames[i].sig) != 0) {\n-                printf(\"(frame#%d) wrong method sig: \\\"%s\\\", expected: \\\"%s\\\"\\n\",\n-                       i, sig, frames[i].sig);\n-                result = STATUS_FAILED;\n-            }\n-        }\n-    }\n-}\n-\n-void JNICALL Breakpoint(jvmtiEnv *jvmti_env, JNIEnv *env,\n-        jthread thr, jmethodID method, jlocation location) {\n-    jvmtiError err;\n-\n-    if (mid != method) {\n-        printf(\"ERROR: didn't know where we got called from\");\n-        result = STATUS_FAILED;\n-        return;\n-    }\n-\n-    err = jvmti->ClearBreakpoint(mid, 0);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(ClearBreakpoint) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-        return;\n-    }\n-\n-    if (!caps.can_pop_frame) {\n-        printf(\"PopFrame is not implemented\\n\");\n-        err = jvmti->SetEventNotificationMode(JVMTI_DISABLE,\n-            JVMTI_EVENT_SINGLE_STEP, thr);\n-        if (err != JVMTI_ERROR_NONE) {\n-            printf(\"Cannot disable step mode: %s (%d)\\n\",\n-                   TranslateError(err), err);\n-            result = STATUS_FAILED;\n-        }\n-        return;\n-    }\n-\n-    err = jvmti->SetEventNotificationMode(JVMTI_ENABLE,\n-        JVMTI_EVENT_SINGLE_STEP, thr);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"Cannot enable step mode: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-        return;\n-    }\n-\n-    if (printdump == JNI_TRUE) {\n-        printf(\">>> popping frame ...\\n\");\n-    }\n-\n-    err = jvmti->PopFrame(thr);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(PopFrame) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-        return;\n-    }\n-}\n-\n-void JNICALL SingleStep(jvmtiEnv *jvmti_env, JNIEnv *env,\n-        jthread thr, jmethodID method, jlocation location) {\n-    jvmtiError err;\n-\n-    err = jvmti->SetEventNotificationMode(JVMTI_DISABLE,\n-        JVMTI_EVENT_SINGLE_STEP, thr);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"Cannot disable step mode: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-    }\n-    check(jvmti_env, thr);\n-}\n-\n-#ifdef STATIC_BUILD\n-JNIEXPORT jint JNICALL Agent_OnLoad_getstacktr006(JavaVM *jvm, char *options, void *reserved) {\n-    return Agent_Initialize(jvm, options, reserved);\n-}\n-JNIEXPORT jint JNICALL Agent_OnAttach_getstacktr006(JavaVM *jvm, char *options, void *reserved) {\n-    return Agent_Initialize(jvm, options, reserved);\n-}\n-JNIEXPORT jint JNI_OnLoad_getstacktr006(JavaVM *jvm, char *options, void *reserved) {\n-    return JNI_VERSION_1_8;\n-}\n-#endif\n-jint Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {\n-    jvmtiError err;\n-    jint res;\n-\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n-        printdump = JNI_TRUE;\n-    }\n-\n-    res = jvm->GetEnv((void **) &jvmti, JVMTI_VERSION_1_1);\n-    if (res != JNI_OK || jvmti == NULL) {\n-        printf(\"Wrong result of a valid call to GetEnv!\\n\");\n-        return JNI_ERR;\n-    }\n-\n-    err = jvmti->GetPotentialCapabilities(&caps);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(GetPotentialCapabilities) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        return JNI_ERR;\n-    }\n-\n-    err = jvmti->AddCapabilities(&caps);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(AddCapabilities) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        return JNI_ERR;\n-    }\n-\n-    err = jvmti->GetCapabilities(&caps);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(GetCapabilities) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        return JNI_ERR;\n-    }\n-\n-    if (caps.can_generate_breakpoint_events &&\n-            caps.can_generate_single_step_events) {\n-        callbacks.Breakpoint = &Breakpoint;\n-        callbacks.SingleStep = &SingleStep;\n-        err = jvmti->SetEventCallbacks(&callbacks, sizeof(callbacks));\n-        if (err != JVMTI_ERROR_NONE) {\n-            printf(\"(SetEventCallbacks) unexpected error: %s (%d)\\n\",\n-                   TranslateError(err), err);\n-            return JNI_ERR;\n-        }\n-    } else {\n-        printf(\"Warning: Breakpoint or SingleStep event is not implemented\\n\");\n-    }\n-\n-    return JNI_OK;\n-}\n-\n-JNIEXPORT void JNICALL\n-Java_nsk_jvmti_GetStackTrace_getstacktr006_getReady(JNIEnv *env, jclass cls, jclass clazz) {\n-    jvmtiError err;\n-\n-    if (jvmti == NULL) {\n-        printf(\"JVMTI client was not properly loaded!\\n\");\n-        result = STATUS_FAILED;\n-        return;\n-    }\n-\n-    if (!caps.can_pop_frame ||\n-            !caps.can_generate_breakpoint_events ||\n-            !caps.can_generate_single_step_events) {\n-        return;\n-    }\n-\n-    mid = env->GetMethodID(clazz, \"checkPoint\", \"()V\");\n-    if (mid == NULL) {\n-        printf(\"Cannot find Method ID for method checkPoint\\n\");\n-        result = STATUS_FAILED;\n-        return;\n-    }\n-\n-    err = jvmti->SetBreakpoint(mid, 0);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(SetBreakpoint) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-        return;\n-    }\n-\n-    err = jvmti->SetEventNotificationMode(JVMTI_ENABLE,\n-        JVMTI_EVENT_BREAKPOINT, NULL);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"Failed to enable BREAKPOINT event: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-    }\n-}\n-\n-JNIEXPORT jint JNICALL\n-Java_nsk_jvmti_GetStackTrace_getstacktr006_getRes(JNIEnv *env, jclass cls) {\n-    return result;\n-}\n-\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetStackTrace\/getstacktr006\/getstacktr006.cpp","additions":0,"deletions":308,"binary":false,"changes":308,"status":"deleted"},{"patch":"@@ -1,33 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include \"native_thread.cpp\"\n-#include \"nsk_tools.cpp\"\n-#include \"jni_tools.cpp\"\n-#include \"jvmti_tools.cpp\"\n-#include \"agent_tools.cpp\"\n-#include \"jvmti_FollowRefObjects.cpp\"\n-#include \"Injector.cpp\"\n-#include \"JVMTITools.cpp\"\n-#include \"agent_common.cpp\"\n-#include \"getstacktr006.cpp\"\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetStackTrace\/getstacktr006\/libgetstacktr006.cpp","additions":0,"deletions":33,"binary":false,"changes":33,"status":"deleted"},{"patch":"@@ -1,115 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package nsk.jvmti.GetStackTrace;\n-\n-import java.io.*;\n-\n-public class getstacktr007 {\n-\n-    final static int FAILED = 2;\n-    final static int JCK_STATUS_BASE = 95;\n-    final static String fileName =\n-        TestThread.class.getName().replace('.', File.separatorChar) + \".class\";\n-\n-    static {\n-        try {\n-            System.loadLibrary(\"getstacktr007\");\n-        } catch (UnsatisfiedLinkError ule) {\n-            System.err.println(\"Could not load getstacktr007 library\");\n-            System.err.println(\"java.library.path:\"\n-                + System.getProperty(\"java.library.path\"));\n-            throw ule;\n-        }\n-    }\n-\n-    native static void getReady(Class clazz, byte bytes[]);\n-    native static int getRes();\n-\n-    public static void main(String args[]) {\n-        args = nsk.share.jvmti.JVMTITest.commonInit(args);\n-\n-        \/\/ produce JCK-like exit status.\n-        System.exit(run(args, System.out) + JCK_STATUS_BASE);\n-    }\n-\n-    public static int run(String args[], PrintStream out) {\n-        ClassLoader cl = getstacktr007.class.getClassLoader();\n-        TestThread thr = new TestThread();\n-\n-        \/\/ Read data from class\n-        byte[] bytes;\n-        try {\n-            InputStream in = cl.getSystemResourceAsStream(fileName);\n-            if (in == null) {\n-                out.println(\"# Class file \\\"\" + fileName + \"\\\" not found\");\n-                return FAILED;\n-            }\n-            bytes = new byte[in.available()];\n-            in.read(bytes);\n-            in.close();\n-        } catch (Exception ex) {\n-            out.println(\"# Unexpected exception while reading class file:\");\n-            out.println(\"# \" + ex);\n-            return FAILED;\n-        }\n-\n-        getReady(TestThread.class, bytes);\n-\n-        thr.start();\n-        try {\n-            thr.join();\n-        } catch (InterruptedException ex) {\n-            out.println(\"# Unexpected \" + ex);\n-            return FAILED;\n-        }\n-\n-        return getRes();\n-    }\n-\n-    static class TestThread extends Thread {\n-        public void run() {\n-            chain1();\n-        }\n-\n-        void chain1() {\n-            chain2();\n-        }\n-\n-        void chain2() {\n-            chain3();\n-        }\n-\n-        void chain3() {\n-            chain4();\n-        }\n-\n-        void chain4() {\n-            checkPoint();\n-        }\n-\n-        \/\/ dummy method to be breakpointed in agent\n-        void checkPoint() {\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetStackTrace\/getstacktr007.java","additions":0,"deletions":115,"binary":false,"changes":115,"status":"deleted"},{"patch":"@@ -1,44 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/*\n- * @test\n- *\n- * @summary converted from VM Testbase nsk\/jvmti\/GetStackTrace\/getstacktr007.\n- * VM Testbase keywords: [quick, jpda, jvmti, noras, redefine]\n- * VM Testbase readme:\n- * DESCRIPTION\n- *     The test exercises JVMTI function GetStackTrace via breakpoint\n- *     and consequent class redefinition.\n- *     The test starts a new thread, does some nested calls, stops at breakpoint,\n- *     redefines the class and checks if the number of frames in the thread's\n- *     stack is as expected and the function returns all the expected frames.\n- * COMMENTS\n- *     Ported from JVMDI.\n- *\n- * @library \/vmTestbase\n- *          \/test\/lib\n- * @run main\/othervm\/native -agentlib:getstacktr007 nsk.jvmti.GetStackTrace.getstacktr007\n- *\/\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetStackTrace\/getstacktr007\/TestDescription.java","additions":0,"deletions":44,"binary":false,"changes":44,"status":"deleted"},{"patch":"@@ -1,296 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include <stdio.h>\n-#include <string.h>\n-#include \"jvmti.h\"\n-#include \"agent_common.h\"\n-#include \"JVMTITools.h\"\n-\n-extern \"C\" {\n-\n-\n-#define PASSED 0\n-#define STATUS_FAILED 2\n-\n-typedef struct {\n-    const char *cls;\n-    const char *name;\n-    const char *sig;\n-} frame_info;\n-\n-static jvmtiEnv *jvmti = NULL;\n-static jvmtiCapabilities caps;\n-static jvmtiEventCallbacks callbacks;\n-static jint result = PASSED;\n-static jboolean printdump = JNI_FALSE;\n-static jmethodID mid;\n-static jbyteArray classBytes;\n-static frame_info frames[] = {\n-    { \"Lnsk\/jvmti\/GetStackTrace\/getstacktr007$TestThread;\", \"checkPoint\", \"()V\" },\n-    { \"Lnsk\/jvmti\/GetStackTrace\/getstacktr007$TestThread;\", \"chain4\", \"()V\" },\n-    { \"Lnsk\/jvmti\/GetStackTrace\/getstacktr007$TestThread;\", \"chain3\", \"()V\" },\n-    { \"Lnsk\/jvmti\/GetStackTrace\/getstacktr007$TestThread;\", \"chain2\", \"()V\" },\n-    { \"Lnsk\/jvmti\/GetStackTrace\/getstacktr007$TestThread;\", \"chain1\", \"()V\" },\n-    { \"Lnsk\/jvmti\/GetStackTrace\/getstacktr007$TestThread;\", \"run\", \"()V\" },\n-};\n-\n-#define NUMBER_OF_STACK_FRAMES ((int) (sizeof(frames)\/sizeof(frame_info)))\n-\n-void check(jvmtiEnv *jvmti_env, jthread thr) {\n-    jvmtiError err;\n-    jvmtiFrameInfo f[NUMBER_OF_STACK_FRAMES + 1];\n-    jclass callerClass;\n-    char *sigClass, *name, *sig, *generic;\n-    jint i, count;\n-\n-    err = jvmti_env->GetStackTrace(thr,\n-        0, NUMBER_OF_STACK_FRAMES + 1, f, &count);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(GetStackTrace) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-        return;\n-    }\n-    if (count != NUMBER_OF_STACK_FRAMES) {\n-        printf(\"Wrong frame count, expected: %d, actual: %d\\n\",\n-               NUMBER_OF_STACK_FRAMES, count);\n-        result = STATUS_FAILED;\n-    }\n-\n-    if (printdump == JNI_TRUE) {\n-            printf(\">>>   frame count: %d\\n\", count);\n-    }\n-    for (i = 0; i < count; i++) {\n-        if (printdump == JNI_TRUE) {\n-            printf(\">>> checking frame#%d ...\\n\", i);\n-        }\n-        err = jvmti_env->GetMethodDeclaringClass(f[i].method,\n-            &callerClass);\n-        if (err != JVMTI_ERROR_NONE) {\n-            printf(\"(GetMethodDeclaringClass#%d) unexpected error: %s (%d)\\n\",\n-                   i, TranslateError(err), err);\n-            result = STATUS_FAILED;\n-            continue;\n-        }\n-        err = jvmti_env->GetClassSignature(callerClass,\n-            &sigClass, &generic);\n-        if (err != JVMTI_ERROR_NONE) {\n-            printf(\"(GetClassSignature#%d) unexpected error: %s (%d)\\n\",\n-                   i, TranslateError(err), err);\n-            result = STATUS_FAILED;\n-            continue;\n-        }\n-        err = jvmti_env->GetMethodName(f[i].method,\n-            &name, &sig, &generic);\n-        if (err != JVMTI_ERROR_NONE) {\n-            printf(\"(GetMethodName#%d) unexpected error: %s (%d)\\n\",\n-                   i, TranslateError(err), err);\n-            result = STATUS_FAILED;\n-            continue;\n-        }\n-        if (printdump == JNI_TRUE) {\n-            printf(\">>>   class:  \\\"%s\\\"\\n\", sigClass);\n-            printf(\">>>   method: \\\"%s%s\\\"\\n\", name, sig);\n-        }\n-        if (i < NUMBER_OF_STACK_FRAMES) {\n-            if (sigClass == NULL || strcmp(sigClass, frames[i].cls) != 0) {\n-                printf(\"(frame#%d) wrong class sig: \\\"%s\\\", expected: \\\"%s\\\"\\n\",\n-                       i, sigClass, frames[i].cls);\n-                result = STATUS_FAILED;\n-            }\n-            if (name == NULL || strcmp(name, frames[i].name) != 0) {\n-                printf(\"(frame#%d) wrong method name: \\\"%s\\\", expected: \\\"%s\\\"\\n\",\n-                       i, name, frames[i].name);\n-                result = STATUS_FAILED;\n-            }\n-            if (sig == NULL || strcmp(sig, frames[i].sig) != 0) {\n-                printf(\"(frame#%d) wrong method sig: \\\"%s\\\", expected: \\\"%s\\\"\\n\",\n-                       i, sig, frames[i].sig);\n-                result = STATUS_FAILED;\n-            }\n-        }\n-    }\n-}\n-\n-void JNICALL Breakpoint(jvmtiEnv *jvmti_env, JNIEnv *env,\n-        jthread thr, jmethodID method, jlocation location) {\n-    jvmtiError err;\n-    jclass klass;\n-    jvmtiClassDefinition classDef;\n-\n-    if (mid != method) {\n-        printf(\"ERROR: don't know where we get called from\");\n-        result = STATUS_FAILED;\n-        return;\n-    }\n-\n-    if (!caps.can_redefine_classes) {\n-        printf(\"Redefine Classes is not implemented\\n\");\n-        return;\n-    }\n-\n-    if (classBytes == NULL) {\n-        printf(\"ERROR: don't have any bytes\");\n-        result = STATUS_FAILED;\n-        return;\n-    }\n-\n-    err = jvmti->GetMethodDeclaringClass(method, &klass);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(GetMethodDeclaringClass(bp) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-        return;\n-    }\n-\n-    if (printdump == JNI_TRUE) {\n-        printf(\">>> redefining class ...\\n\");\n-    }\n-\n-    classDef.klass = klass;\n-    classDef.class_byte_count =\n-        env->GetArrayLength(classBytes);\n-    classDef.class_bytes = (unsigned char*) env->GetByteArrayElements(classBytes, NULL);\n-\n-    err = jvmti->RedefineClasses(1, &classDef);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(RedefineClasses) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-        return;\n-    }\n-    env->DeleteGlobalRef(classBytes);\n-    classBytes = NULL;\n-\n-    check(jvmti_env, thr);\n-}\n-\n-#ifdef STATIC_BUILD\n-JNIEXPORT jint JNICALL Agent_OnLoad_getstacktr007(JavaVM *jvm, char *options, void *reserved) {\n-    return Agent_Initialize(jvm, options, reserved);\n-}\n-JNIEXPORT jint JNICALL Agent_OnAttach_getstacktr007(JavaVM *jvm, char *options, void *reserved) {\n-    return Agent_Initialize(jvm, options, reserved);\n-}\n-JNIEXPORT jint JNI_OnLoad_getstacktr007(JavaVM *jvm, char *options, void *reserved) {\n-    return JNI_VERSION_1_8;\n-}\n-#endif\n-jint Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {\n-    jvmtiError err;\n-    jint res;\n-\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n-        printdump = JNI_TRUE;\n-    }\n-\n-    res = jvm->GetEnv((void **) &jvmti, JVMTI_VERSION_1_1);\n-    if (res != JNI_OK || jvmti == NULL) {\n-        printf(\"Wrong result of a valid call to GetEnv!\\n\");\n-        return JNI_ERR;\n-    }\n-\n-    err = jvmti->GetPotentialCapabilities(&caps);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(GetPotentialCapabilities) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        return JNI_ERR;\n-    }\n-\n-    err = jvmti->AddCapabilities(&caps);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(AddCapabilities) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        return JNI_ERR;\n-    }\n-\n-    err = jvmti->GetCapabilities(&caps);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(GetCapabilities) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        return JNI_ERR;\n-    }\n-\n-    if (caps.can_generate_breakpoint_events) {\n-        callbacks.Breakpoint = &Breakpoint;\n-        err = jvmti->SetEventCallbacks(&callbacks, sizeof(callbacks));\n-        if (err != JVMTI_ERROR_NONE) {\n-            printf(\"(SetEventCallbacks) unexpected error: %s (%d)\\n\",\n-                   TranslateError(err), err);\n-            return JNI_ERR;\n-        }\n-    } else {\n-        printf(\"Warning: Breakpoint event is not implemented\\n\");\n-    }\n-\n-    return JNI_OK;\n-}\n-\n-JNIEXPORT void JNICALL\n-Java_nsk_jvmti_GetStackTrace_getstacktr007_getReady(JNIEnv *env, jclass cls,\n-                           jclass clazz, jbyteArray bytes) {\n-    jvmtiError err;\n-\n-    if (jvmti == NULL) {\n-        printf(\"JVMTI client was not properly loaded!\\n\");\n-        result = STATUS_FAILED;\n-        return;\n-    }\n-\n-    if (!caps.can_generate_breakpoint_events) {\n-        return;\n-    }\n-\n-    classBytes = (jbyteArray) env->NewGlobalRef(bytes);\n-\n-    mid = env->GetMethodID(clazz, \"checkPoint\", \"()V\");\n-    if (mid == NULL) {\n-        printf(\"Cannot find Method ID for method checkPoint\\n\");\n-        result = STATUS_FAILED;\n-        return;\n-    }\n-\n-    err = jvmti->SetBreakpoint(mid, 0);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(SetBreakpoint) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-        return;\n-    }\n-\n-    err = jvmti->SetEventNotificationMode(JVMTI_ENABLE,\n-        JVMTI_EVENT_BREAKPOINT, NULL);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"Failed to enable BREAKPOINT event: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-    }\n-}\n-\n-JNIEXPORT jint JNICALL\n-Java_nsk_jvmti_GetStackTrace_getstacktr007_getRes(JNIEnv *env, jclass cls) {\n-    return result;\n-}\n-\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetStackTrace\/getstacktr007\/getstacktr007.cpp","additions":0,"deletions":296,"binary":false,"changes":296,"status":"deleted"},{"patch":"@@ -1,33 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include \"native_thread.cpp\"\n-#include \"nsk_tools.cpp\"\n-#include \"jni_tools.cpp\"\n-#include \"jvmti_tools.cpp\"\n-#include \"agent_tools.cpp\"\n-#include \"jvmti_FollowRefObjects.cpp\"\n-#include \"Injector.cpp\"\n-#include \"JVMTITools.cpp\"\n-#include \"agent_common.cpp\"\n-#include \"getstacktr007.cpp\"\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetStackTrace\/getstacktr007\/libgetstacktr007.cpp","additions":0,"deletions":33,"binary":false,"changes":33,"status":"deleted"},{"patch":"@@ -1,120 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package nsk.jvmti.GetStackTrace;\n-\n-import java.io.*;\n-\n-public class getstacktr008 {\n-\n-    final static int FAILED = 2;\n-    final static int JCK_STATUS_BASE = 95;\n-    final static String fileName =\n-        TestThread.class.getName().replace('.', File.separatorChar) + \".class\";\n-\n-    static {\n-        try {\n-            System.loadLibrary(\"getstacktr008\");\n-        } catch (UnsatisfiedLinkError ule) {\n-            System.err.println(\"Could not load getstacktr008 library\");\n-            System.err.println(\"java.library.path:\"\n-                + System.getProperty(\"java.library.path\"));\n-            throw ule;\n-        }\n-    }\n-\n-    native static void getReady(Thread thr, byte bytes[]);\n-    native static void nativeChain();\n-    native static int getRes();\n-\n-    public static void main(String args[]) {\n-        args = nsk.share.jvmti.JVMTITest.commonInit(args);\n-\n-        \/\/ produce JCK-like exit status.\n-        System.exit(run(args, System.out) + JCK_STATUS_BASE);\n-    }\n-\n-    public static int run(String args[], PrintStream out) {\n-        ClassLoader cl = getstacktr008.class.getClassLoader();\n-        TestThread thr = new TestThread();\n-\n-        \/\/ Read data from class\n-        byte[] bytes;\n-        try {\n-            InputStream in = cl.getSystemResourceAsStream(fileName);\n-            if (in == null) {\n-                out.println(\"# Class file \\\"\" + fileName + \"\\\" not found\");\n-                return FAILED;\n-            }\n-            bytes = new byte[in.available()];\n-            in.read(bytes);\n-            in.close();\n-        } catch (Exception ex) {\n-            out.println(\"# Unexpected exception while reading class file:\");\n-            out.println(\"# \" + ex);\n-            return FAILED;\n-        }\n-\n-        getReady(thr, bytes);\n-\n-        thr.start();\n-        try {\n-            thr.join();\n-        } catch (InterruptedException ex) {\n-            out.println(\"# Unexpected \" + ex);\n-            return FAILED;\n-        }\n-\n-        return getRes();\n-    }\n-\n-    static class TestThread extends Thread {\n-        public void run() {\n-            chain1();\n-        }\n-\n-        static void chain1() {\n-            chain2();\n-        }\n-\n-        static void chain2() {\n-            chain3();\n-        }\n-\n-        static void chain3() {\n-            nativeChain();\n-        }\n-\n-        static void chain4() {\n-            chain5();\n-        }\n-\n-        static void chain5() {\n-            checkPoint();\n-        }\n-\n-        \/\/ dummy method to be breakpointed in agent\n-        static void checkPoint() {\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetStackTrace\/getstacktr008.java","additions":0,"deletions":120,"binary":false,"changes":120,"status":"deleted"},{"patch":"@@ -1,52 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/*\n- * @test\n- *\n- * @summary converted from VM Testbase nsk\/jvmti\/GetStackTrace\/getstacktr008.\n- * VM Testbase keywords: [quick, jpda, jvmti, noras, redefine]\n- * VM Testbase readme:\n- * DESCRIPTION\n- *     The test exercises JVMTI function GetStackTrace.\n- *     The test starts a new thread, does some nested calls with a native\n- *     call in the middle, and stops at breakpoint.\n- *     Then the test does the following:\n- *         - checks the stack on expected frames\n- *         - steps\n- *         - checks the stack on expected frames\n- *         - pops frame\n- *         - checks the stack on expected frames\n- *         - redefines class\n- *         - checks the stack on expected frames\n- *         - checks the stack on expected frames just before\n- *           returning from the native call.\n- * COMMENTS\n- *     Ported from JVMDI.\n- *\n- * @library \/vmTestbase\n- *          \/test\/lib\n- * @run main\/othervm\/native -agentlib:getstacktr008 nsk.jvmti.GetStackTrace.getstacktr008\n- *\/\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetStackTrace\/getstacktr008\/TestDescription.java","additions":0,"deletions":52,"binary":false,"changes":52,"status":"deleted"},{"patch":"@@ -1,389 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include <stdio.h>\n-#include <string.h>\n-#include \"jvmti.h\"\n-#include \"agent_common.h\"\n-#include \"JVMTITools.h\"\n-\n-extern \"C\" {\n-\n-\n-#define PASSED 0\n-#define STATUS_FAILED 2\n-\n-typedef struct {\n-    const char *cls;\n-    const char *name;\n-    const char *sig;\n-} frame_info;\n-\n-static jvmtiEnv *jvmti = NULL;\n-static jvmtiCapabilities caps;\n-static jvmtiEventCallbacks callbacks;\n-static jint result = PASSED;\n-static jboolean printdump = JNI_FALSE;\n-static jboolean wasFramePop = JNI_FALSE;\n-static jthread testedThread;\n-static jmethodID mid_checkPoint, mid_chain4;\n-static jbyteArray classBytes;\n-static frame_info frames[] = {\n-    { \"Lnsk\/jvmti\/GetStackTrace\/getstacktr008$TestThread;\", \"checkPoint\", \"()V\" },\n-    { \"Lnsk\/jvmti\/GetStackTrace\/getstacktr008$TestThread;\", \"chain5\", \"()V\" },\n-    { \"Lnsk\/jvmti\/GetStackTrace\/getstacktr008$TestThread;\", \"chain4\", \"()V\" },\n-    { \"Lnsk\/jvmti\/GetStackTrace\/getstacktr008;\", \"nativeChain\", \"()V\" },\n-    { \"Lnsk\/jvmti\/GetStackTrace\/getstacktr008$TestThread;\", \"chain3\", \"()V\" },\n-    { \"Lnsk\/jvmti\/GetStackTrace\/getstacktr008$TestThread;\", \"chain2\", \"()V\" },\n-    { \"Lnsk\/jvmti\/GetStackTrace\/getstacktr008$TestThread;\", \"chain1\", \"()V\" },\n-    { \"Lnsk\/jvmti\/GetStackTrace\/getstacktr008$TestThread;\", \"run\", \"()V\" },\n-};\n-\n-#define NUMBER_OF_STACK_FRAMES ((int) (sizeof(frames)\/sizeof(frame_info)))\n-\n-void check(jvmtiEnv *jvmti_env, jthread thr, int offset, const char *note) {\n-    jvmtiError err;\n-    jvmtiFrameInfo f[NUMBER_OF_STACK_FRAMES + 1];\n-    jclass callerClass;\n-    char *sigClass, *name, *sig, *generic;\n-    jint i, count;\n-\n-    if (printdump == JNI_TRUE) {\n-        printf(\">>> checking stack frame for %s ...\\n\", note);\n-    }\n-\n-    err = jvmti_env->GetStackTrace(thr,\n-        0, NUMBER_OF_STACK_FRAMES + 1, f, &count);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(%s, GetStackTrace) unexpected error: %s (%d)\\n\",\n-               note, TranslateError(err), err);\n-        result = STATUS_FAILED;\n-        return;\n-    }\n-\n-    if (printdump == JNI_TRUE) {\n-            printf(\">>>   frame count: %d\\n\", count);\n-    }\n-\n-    if (count != (jint)(NUMBER_OF_STACK_FRAMES - offset)) {\n-        printf(\"(%s) wrong frame count, expected: %d, actual: %d\\n\",\n-               note, NUMBER_OF_STACK_FRAMES, count);\n-        result = STATUS_FAILED;\n-    }\n-    for (i = 0; i < count; i++) {\n-        if (printdump == JNI_TRUE) {\n-            printf(\">>> checking frame#%d ...\\n\", i);\n-        }\n-        err = jvmti_env->GetMethodDeclaringClass(f[i].method,\n-            &callerClass);\n-        if (err != JVMTI_ERROR_NONE) {\n-            printf(\"(%s, GetMethodDeclaringClass#%d) unexpected error: %s (%d)\\n\",\n-                   note, i, TranslateError(err), err);\n-            result = STATUS_FAILED;\n-            continue;\n-        }\n-        err = jvmti_env->GetClassSignature(callerClass,\n-            &sigClass, &generic);\n-        if (err != JVMTI_ERROR_NONE) {\n-            printf(\"(%s, GetClassSignature#%d) unexpected error: %s (%d)\\n\",\n-                   note, i, TranslateError(err), err);\n-            result = STATUS_FAILED;\n-            continue;\n-        }\n-        err = jvmti_env->GetMethodName(f[i].method,\n-            &name, &sig, &generic);\n-        if (err != JVMTI_ERROR_NONE) {\n-            printf(\"(%s, GetMethodName#%d) unexpected error: %s (%d)\\n\",\n-                   note, i, TranslateError(err), err);\n-            result = STATUS_FAILED;\n-            continue;\n-        }\n-        if (printdump == JNI_TRUE) {\n-            printf(\">>>   class:  \\\"%s\\\"\\n\", sigClass);\n-            printf(\">>>   method: \\\"%s%s\\\"\\n\", name, sig);\n-        }\n-        if (i < NUMBER_OF_STACK_FRAMES) {\n-            if (sigClass == NULL ||\n-                    strcmp(sigClass, frames[i + offset].cls) != 0) {\n-                printf(\"(%s, frame#%d) wrong class sig: \\\"%s\\\",\\n\",\n-                       note, i, sigClass);\n-                printf(\" expected: \\\"%s\\\"\\n\", frames[i + offset].cls);\n-                result = STATUS_FAILED;\n-            }\n-            if (name == NULL ||\n-                    strcmp(name, frames[i + offset].name) != 0) {\n-                printf(\"(%s, frame#%d) wrong method name: \\\"%s\\\",\",\n-                       note, i, name);\n-                printf(\" expected: \\\"%s\\\"\\n\", frames[i + offset].name);\n-                result = STATUS_FAILED;\n-            }\n-            if (sig == NULL || strcmp(sig, frames[i + offset].sig) != 0) {\n-                printf(\"(%s, frame#%d) wrong method sig: \\\"%s\\\",\",\n-                       note, i, sig);\n-                printf(\" expected: \\\"%s\\\"\\n\", frames[i + offset].sig);\n-                result = STATUS_FAILED;\n-            }\n-        }\n-    }\n-}\n-\n-void JNICALL Breakpoint(jvmtiEnv *jvmti_env, JNIEnv *env,\n-        jthread thr, jmethodID method, jlocation location) {\n-    jvmtiError err;\n-\n-    if (mid_checkPoint != method) {\n-        printf(\"ERROR: don't know where we get called from\");\n-        result = STATUS_FAILED;\n-        return;\n-    }\n-    err = jvmti->ClearBreakpoint(mid_checkPoint, 0);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(ClearBreakpoint) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-        return;\n-    }\n-    check(jvmti_env, thr, 0, \"bp\");\n-    err = jvmti->SetEventNotificationMode(JVMTI_ENABLE,\n-        JVMTI_EVENT_SINGLE_STEP, thr);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"Cannot enable step mode: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-    }\n-    if (printdump == JNI_TRUE) {\n-        printf(\">>> stepping ...\\n\");\n-    }\n-}\n-\n-void JNICALL SingleStep(jvmtiEnv *jvmti_env, JNIEnv *env,\n-        jthread thread, jmethodID method, jlocation location) {\n-    jvmtiError err;\n-    jclass klass;\n-    jvmtiClassDefinition classDef;\n-\n-    if (wasFramePop == JNI_FALSE) {\n-        check(jvmti_env, thread, 1, \"step\");\n-\n-        if (!caps.can_pop_frame) {\n-            printf(\"Pop Frame is not implemented\\n\");\n-            err = jvmti->SetEventNotificationMode(JVMTI_DISABLE,\n-                JVMTI_EVENT_SINGLE_STEP, thread);\n-            if (err != JVMTI_ERROR_NONE) {\n-                printf(\"Cannot disable step mode: %s (%d)\\n\",\n-                       TranslateError(err), err);\n-                result = STATUS_FAILED;\n-            }\n-            return;\n-        }\n-        if (printdump == JNI_TRUE) {\n-            printf(\">>> popping frame ...\\n\");\n-        }\n-        err = jvmti->PopFrame(thread);\n-        if (err != JVMTI_ERROR_NONE) {\n-            printf(\"(PopFrame) unexpected error: %s (%d)\\n\",\n-                   TranslateError(err), err);\n-            result = STATUS_FAILED;\n-            return;\n-        }\n-        wasFramePop = JNI_TRUE;\n-    } else {\n-        err = jvmti->SetEventNotificationMode(JVMTI_DISABLE,\n-            JVMTI_EVENT_SINGLE_STEP, thread);\n-        if (err != JVMTI_ERROR_NONE) {\n-            printf(\"Cannot disable step mode: %s (%d)\\n\",\n-                   TranslateError(err), err);\n-            result = STATUS_FAILED;\n-        }\n-        check(jvmti_env, thread, 2, \"pop\");\n-\n-        if (!caps.can_redefine_classes) {\n-            printf(\"Redefine Classes is not implemented\\n\");\n-            return;\n-        }\n-        if (classBytes == NULL) {\n-            printf(\"ERROR: don't have any bytes\");\n-            result = STATUS_FAILED;\n-            return;\n-        }\n-        err = jvmti->GetMethodDeclaringClass(method, &klass);\n-        if (err != JVMTI_ERROR_NONE) {\n-            printf(\"(GetMethodDeclaringClass(bp) unexpected error: %s (%d)\\n\",\n-                   TranslateError(err), err);\n-            result = STATUS_FAILED;\n-            return;\n-        }\n-        if (printdump == JNI_TRUE) {\n-            printf(\">>> redefining class ...\\n\");\n-        }\n-        classDef.klass = klass;\n-        classDef.class_byte_count = env->GetArrayLength(classBytes);\n-        classDef.class_bytes = (unsigned char*) env->GetByteArrayElements(classBytes, NULL);\n-        err = jvmti->RedefineClasses(1, &classDef);\n-        if (err != JVMTI_ERROR_NONE) {\n-            printf(\"(RedefineClasses) unexpected error: %s (%d)\\n\",\n-                   TranslateError(err), err);\n-            result = STATUS_FAILED;\n-            return;\n-        }\n-        env->DeleteGlobalRef(classBytes);\n-        classBytes = NULL;\n-        check(jvmti_env, thread, 2, \"swap\");\n-    }\n-}\n-\n-#ifdef STATIC_BUILD\n-JNIEXPORT jint JNICALL Agent_OnLoad_getstacktr008(JavaVM *jvm, char *options, void *reserved) {\n-    return Agent_Initialize(jvm, options, reserved);\n-}\n-JNIEXPORT jint JNICALL Agent_OnAttach_getstacktr008(JavaVM *jvm, char *options, void *reserved) {\n-    return Agent_Initialize(jvm, options, reserved);\n-}\n-JNIEXPORT jint JNI_OnLoad_getstacktr008(JavaVM *jvm, char *options, void *reserved) {\n-    return JNI_VERSION_1_8;\n-}\n-#endif\n-jint Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {\n-    jvmtiError err;\n-    jint res;\n-\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n-        printdump = JNI_TRUE;\n-    }\n-\n-    res = jvm->GetEnv((void **) &jvmti, JVMTI_VERSION_1_1);\n-    if (res != JNI_OK || jvmti == NULL) {\n-        printf(\"Wrong result of a valid call to GetEnv!\\n\");\n-        return JNI_ERR;\n-    }\n-\n-    err = jvmti->GetPotentialCapabilities(&caps);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(GetPotentialCapabilities) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        return JNI_ERR;\n-    }\n-\n-    err = jvmti->AddCapabilities(&caps);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(AddCapabilities) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        return JNI_ERR;\n-    }\n-\n-    err = jvmti->GetCapabilities(&caps);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(GetCapabilities) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        return JNI_ERR;\n-    }\n-\n-    if (caps.can_generate_breakpoint_events &&\n-            caps.can_generate_single_step_events) {\n-        callbacks.Breakpoint = &Breakpoint;\n-        callbacks.SingleStep = &SingleStep;\n-        err = jvmti->SetEventCallbacks(&callbacks, sizeof(callbacks));\n-        if (err != JVMTI_ERROR_NONE) {\n-            printf(\"(SetEventCallbacks) unexpected error: %s (%d)\\n\",\n-                   TranslateError(err), err);\n-            return JNI_ERR;\n-        }\n-    } else {\n-        printf(\"Warning: Breakpoint or SingleStep event is not implemented\\n\");\n-    }\n-\n-    return JNI_OK;\n-}\n-\n-JNIEXPORT void JNICALL\n-Java_nsk_jvmti_GetStackTrace_getstacktr008_getReady(JNIEnv *env, jclass cls,\n-                           jthread thr, jbyteArray bytes) {\n-    jvmtiError err;\n-    jclass clazz;\n-\n-    if (jvmti == NULL) {\n-        printf(\"JVMTI client was not properly loaded!\\n\");\n-        result = STATUS_FAILED;\n-        return;\n-    }\n-\n-    testedThread = env->NewGlobalRef(thr);\n-\n-    if (!caps.can_generate_breakpoint_events ||\n-            !caps.can_generate_single_step_events) {\n-        return;\n-    }\n-\n-    classBytes = (jbyteArray) env->NewGlobalRef(bytes);\n-\n-    clazz = env->GetObjectClass(thr);\n-    if (clazz == NULL) {\n-        printf(\"Cannot get the class of thread object\\n\");\n-        result = STATUS_FAILED;\n-        return;\n-    }\n-\n-    mid_checkPoint = env->GetStaticMethodID(clazz, \"checkPoint\", \"()V\");\n-    if (mid_checkPoint == NULL) {\n-        printf(\"Cannot find Method ID for method \\\"checkPoint\\\"\\n\");\n-        result = STATUS_FAILED;\n-        return;\n-    }\n-\n-    mid_chain4 = env->GetStaticMethodID(clazz, \"chain4\", \"()V\");\n-    if (mid_chain4 == NULL) {\n-        printf(\"Cannot find Method ID for method \\\"chain4\\\"\\n\");\n-        result = STATUS_FAILED;\n-        return;\n-    }\n-\n-    err = jvmti->SetBreakpoint(mid_checkPoint, 0);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(SetBreakpoint) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-    }\n-\n-    err = jvmti->SetEventNotificationMode(JVMTI_ENABLE,\n-        JVMTI_EVENT_BREAKPOINT, NULL);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"Failed to enable BREAKPOINT event: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-    }\n-}\n-\n-JNIEXPORT void JNICALL\n-Java_nsk_jvmti_GetStackTrace_getstacktr008_nativeChain(JNIEnv *env, jclass cls) {\n-    if (mid_chain4 != NULL) {\n-        env->CallStaticVoidMethod(cls, mid_chain4);\n-    }\n-    check(jvmti, testedThread, 3, \"native\");\n-}\n-\n-JNIEXPORT jint JNICALL\n-Java_nsk_jvmti_GetStackTrace_getstacktr008_getRes(JNIEnv *env, jclass cls) {\n-    return result;\n-}\n-\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetStackTrace\/getstacktr008\/getstacktr008.cpp","additions":0,"deletions":389,"binary":false,"changes":389,"status":"deleted"},{"patch":"@@ -1,33 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include \"native_thread.cpp\"\n-#include \"nsk_tools.cpp\"\n-#include \"jni_tools.cpp\"\n-#include \"jvmti_tools.cpp\"\n-#include \"agent_tools.cpp\"\n-#include \"jvmti_FollowRefObjects.cpp\"\n-#include \"Injector.cpp\"\n-#include \"JVMTITools.cpp\"\n-#include \"agent_common.cpp\"\n-#include \"getstacktr008.cpp\"\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetStackTrace\/getstacktr008\/libgetstacktr008.cpp","additions":0,"deletions":33,"binary":false,"changes":33,"status":"deleted"},{"patch":"@@ -1,72 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package nsk.jvmti.GetStackTrace;\n-\n-import java.io.PrintStream;\n-\n-public class getstacktr009 {\n-\n-    final static int JCK_STATUS_BASE = 95;\n-    final static int FAILED = 2;\n-\n-    static {\n-        try {\n-            System.loadLibrary(\"getstacktr009\");\n-        } catch (UnsatisfiedLinkError ule) {\n-            System.err.println(\"Could not load getstacktr009 library\");\n-            System.err.println(\"java.library.path:\"\n-                + System.getProperty(\"java.library.path\"));\n-            throw ule;\n-        }\n-    }\n-\n-    native static int check(Thread thread1, Thread thread2);\n-\n-    public static void main(String args[]) {\n-        args = nsk.share.jvmti.JVMTITest.commonInit(args);\n-\n-        \/\/ produce JCK-like exit status.\n-        System.exit(run(args, System.out) + JCK_STATUS_BASE);\n-    }\n-\n-    public static int run(String args[], PrintStream out) {\n-        TestThread thr1 = new TestThread();\n-        TestThread thr2 = new TestThread();\n-\n-        thr2.start();\n-        try {\n-            thr2.join();\n-        } catch (InterruptedException ex) {\n-            out.println(\"# Unexpected \" + ex);\n-            return FAILED;\n-        }\n-\n-        return check(thr1, thr2);\n-    }\n-\n-    static class TestThread extends Thread {\n-        public void run() {\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetStackTrace\/getstacktr009.java","additions":0,"deletions":72,"binary":false,"changes":72,"status":"deleted"},{"patch":"@@ -1,44 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/*\n- * @test\n- *\n- * @summary converted from VM Testbase nsk\/jvmti\/GetStackTrace\/getstacktr009.\n- * VM Testbase keywords: [quick, jpda, jvmti, noras]\n- * VM Testbase readme:\n- * DESCRIPTION\n- *     The test exercises JVMTI function GetStackTrace.\n- *     The test checks if the function returns JVMTI_ERROR_THREAD_NOT_ALIVE\n- *     for not yet started and already finished thread.\n- * COMMENTS\n- *     Test adjusted for JVMTI spec 0.2.90:\n- *     - chack thread against specific error code JVMTI_ERROR_THREAD_NOT_ALIVE\n- *       instead of general JVMTI_ERROR_INVALID_THREAD\n- *\n- * @library \/vmTestbase\n- *          \/test\/lib\n- * @run main\/othervm\/native -agentlib:getstacktr009 nsk.jvmti.GetStackTrace.getstacktr009\n- *\/\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetStackTrace\/getstacktr009\/TestDescription.java","additions":0,"deletions":44,"binary":false,"changes":44,"status":"deleted"},{"patch":"@@ -1,108 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include <stdio.h>\n-#include <string.h>\n-#include \"jvmti.h\"\n-#include \"agent_common.h\"\n-#include \"JVMTITools.h\"\n-\n-extern \"C\" {\n-\n-\n-#define PASSED 0\n-#define STATUS_FAILED 2\n-\n-static jvmtiEnv *jvmti = NULL;\n-static jint result = PASSED;\n-static jboolean printdump = JNI_FALSE;\n-\n-#ifdef STATIC_BUILD\n-JNIEXPORT jint JNICALL Agent_OnLoad_getstacktr009(JavaVM *jvm, char *options, void *reserved) {\n-    return Agent_Initialize(jvm, options, reserved);\n-}\n-JNIEXPORT jint JNICALL Agent_OnAttach_getstacktr009(JavaVM *jvm, char *options, void *reserved) {\n-    return Agent_Initialize(jvm, options, reserved);\n-}\n-JNIEXPORT jint JNI_OnLoad_getstacktr009(JavaVM *jvm, char *options, void *reserved) {\n-    return JNI_VERSION_1_8;\n-}\n-#endif\n-jint Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {\n-    jint res;\n-\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n-        printdump = JNI_TRUE;\n-    }\n-\n-    res = jvm->GetEnv((void **) &jvmti, JVMTI_VERSION_1_1);\n-    if (res != JNI_OK || jvmti == NULL) {\n-        printf(\"Wrong result of a valid call to GetEnv!\\n\");\n-        return JNI_ERR;\n-    }\n-\n-    return JNI_OK;\n-}\n-\n-JNIEXPORT jint JNICALL\n-Java_nsk_jvmti_GetStackTrace_getstacktr009_check(JNIEnv *env, jclass cls,\n-        jthread thread1, jthread thread2) {\n-    jvmtiError err;\n-    jvmtiFrameInfo frame;\n-    jint count;\n-\n-    if (jvmti == NULL) {\n-        printf(\"JVMTI client was not properly loaded!\\n\");\n-        return STATUS_FAILED;\n-    }\n-\n-    if (printdump == JNI_TRUE) {\n-        printf(\">>> Not yet started thread check ...\\n\");\n-    }\n-    err = jvmti->GetStackTrace(thread1, 0, 1, &frame, &count);\n-    if (err != JVMTI_ERROR_THREAD_NOT_ALIVE) {\n-        printf(\"For not yet started thread:\\n\");\n-        printf(\"Error expected: JVMTI_ERROR_THREAD_NOT_ALIVE, got: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-    }\n-\n-    if (printdump == JNI_TRUE) {\n-        printf(\">>> Already finished thread check ...\\n\");\n-    }\n-    err = jvmti->GetStackTrace(thread2, 0, 1, &frame, &count);\n-    if (err != JVMTI_ERROR_THREAD_NOT_ALIVE) {\n-        printf(\"For already finished thread:\\n\");\n-        printf(\"Error expected: JVMTI_ERROR_THREAD_NOT_ALIVE, got: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-    }\n-\n-    if (printdump == JNI_TRUE) {\n-        printf(\">>> ... done\\n\");\n-    }\n-\n-    return result;\n-}\n-\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetStackTrace\/getstacktr009\/getstacktr009.cpp","additions":0,"deletions":108,"binary":false,"changes":108,"status":"deleted"},{"patch":"@@ -1,33 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include \"native_thread.cpp\"\n-#include \"nsk_tools.cpp\"\n-#include \"jni_tools.cpp\"\n-#include \"jvmti_tools.cpp\"\n-#include \"agent_tools.cpp\"\n-#include \"jvmti_FollowRefObjects.cpp\"\n-#include \"Injector.cpp\"\n-#include \"JVMTITools.cpp\"\n-#include \"agent_common.cpp\"\n-#include \"getstacktr009.cpp\"\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetStackTrace\/getstacktr009\/libgetstacktr009.cpp","additions":0,"deletions":33,"binary":false,"changes":33,"status":"deleted"},{"patch":"@@ -1,130 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package nsk.jvmti.GetThreadInfo;\n-\n-import java.io.PrintStream;\n-import java.util.concurrent.ThreadFactory;\n-\n-public class thrinfo001 {\n-\n-    final static int JCK_STATUS_BASE = 95;\n-\n-    static {\n-        try {\n-            System.loadLibrary(\"thrinfo001\");\n-        } catch (UnsatisfiedLinkError ule) {\n-            System.err.println(\"Could not load thrinfo001 library\");\n-            System.err.println(\"java.library.path:\"\n-                + System.getProperty(\"java.library.path\"));\n-            throw ule;\n-        }\n-    }\n-\n-    native static void checkInfo(Thread thr, ThreadGroup thr_group, int ind);\n-    native static int getRes();\n-\n-    public static void main(String args[]) {\n-        args = nsk.share.jvmti.JVMTITest.commonInit(args);\n-\n-        \/\/ produce JCK-like exit status.\n-        System.exit(run(args, System.out) + JCK_STATUS_BASE);\n-    }\n-\n-    public static int run(String argv[], PrintStream ref) {\n-        Thread currThr = Thread.currentThread();\n-        checkInfo(currThr, currThr.getThreadGroup(), 0);\n-\n-        ThreadGroup tg = new ThreadGroup(\"tg1\");\n-        thrinfo001a t_a = new thrinfo001a(tg, \"thread1\");\n-        t_a.setPriority(Thread.MIN_PRIORITY + 2);\n-        t_a.setDaemon(true);\n-        checkInfo(t_a, tg, 1);\n-        t_a.start();\n-        try {\n-            t_a.join();\n-        } catch (InterruptedException e) {}\n-        checkInfo(t_a, t_a.getThreadGroup(), 1);\n-\n-        thrinfo001b t_b = new thrinfo001b();\n-        t_b.setPriority(Thread.MIN_PRIORITY);\n-        t_b.setDaemon(true);\n-        checkInfo(t_b, t_b.getThreadGroup(), 2);\n-        t_b.start();\n-        try {\n-            t_b.join();\n-        } catch (InterruptedException e) {}\n-        checkInfo(t_b, t_b.getThreadGroup(), 2);\n-\n-\n-        Thread t_c = virtualThreadFactory().newThread(new thrinfo001c());\n-        t_c.setName(\"vthread\");\n-\n-        checkInfo(t_c, t_c.getThreadGroup(), 3);\n-        t_c.start();\n-        try {\n-            t_c.join();\n-        } catch (InterruptedException e) {}\n-        checkInfo(t_c, t_c.getThreadGroup(), 3);\n-\n-        return getRes();\n-    }\n-\n-    private static ThreadFactory virtualThreadFactory() {\n-        try {\n-            Object builder = Thread.class.getMethod(\"ofVirtual\").invoke(null);\n-            Class<?> clazz = Class.forName(\"java.lang.Thread$Builder\");\n-            java.lang.reflect.Method factory = clazz.getMethod(\"factory\");\n-            return (ThreadFactory) factory.invoke(builder);\n-        } catch (RuntimeException | Error e) {\n-            throw e;\n-        } catch (Exception e) {\n-            throw new RuntimeException(e);\n-        }\n-    }\n-}\n-\n-class thrinfo001a extends Thread {\n-    thrinfo001a(ThreadGroup tg, String name) {\n-        super(tg, name);\n-    }\n-\n-    public void run() {\n-        Thread currThr = Thread.currentThread();\n-        thrinfo001.checkInfo(currThr, currThr.getThreadGroup(), 1);\n-    }\n-}\n-\n-class thrinfo001b extends Thread {\n-    public void run() {\n-        Thread currThr = Thread.currentThread();\n-        thrinfo001.checkInfo(currThr, currThr.getThreadGroup(), 2);\n-    }\n-}\n-\n-class thrinfo001c implements Runnable {\n-    public void run() {\n-        Thread currThr = Thread.currentThread();\n-        thrinfo001.checkInfo(currThr, currThr.getThreadGroup(), 3);\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetThreadInfo\/thrinfo001.java","additions":0,"deletions":130,"binary":false,"changes":130,"status":"deleted"},{"patch":"@@ -1,53 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/*\n- * @test\n- *\n- * @summary converted from VM Testbase nsk\/jvmti\/GetThreadInfo\/thrinfo001.\n- * VM Testbase keywords: [quick, jpda, jvmti, noras]\n- * VM Testbase readme:\n- * DESCRIPTION\n- *     The test exercise JVMTI function GetThreadInfo.\n- *     The test cases include:\n- *     - user-defined and default thread name\n- *     - main thread\n- *     - user-defined and default thread group\n- *     - norm, min and min+2 priorities\n- *     - daemon and non-daemon threads\n- * COMMENTS\n- *     Fixed according to the 4387521 bug.\n- *     Fixed according to the 4480280 bug.\n- *     Ported from JVMDI.\n- *\n- * @requires vm.jvmti & vm.continuations\n- * @library \/vmTestbase\n- *          \/test\/lib\n- * @build nsk.jvmti.GetThreadInfo.thrinfo001\n- * @run main\/othervm\/native ExecDriver --java\n- *      --enable-preview\n- *      -agentlib:thrinfo001\n- *      nsk.jvmti.GetThreadInfo.thrinfo001\n- *\/\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetThreadInfo\/thrinfo001\/TestDescription.java","additions":0,"deletions":53,"binary":false,"changes":53,"status":"deleted"},{"patch":"@@ -1,33 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include \"native_thread.cpp\"\n-#include \"nsk_tools.cpp\"\n-#include \"jni_tools.cpp\"\n-#include \"jvmti_tools.cpp\"\n-#include \"agent_tools.cpp\"\n-#include \"jvmti_FollowRefObjects.cpp\"\n-#include \"Injector.cpp\"\n-#include \"JVMTITools.cpp\"\n-#include \"agent_common.cpp\"\n-#include \"thrinfo001.cpp\"\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetThreadInfo\/thrinfo001\/libthrinfo001.cpp","additions":0,"deletions":33,"binary":false,"changes":33,"status":"deleted"},{"patch":"@@ -1,120 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include <stdio.h>\n-#include <string.h>\n-#include \"jvmti.h\"\n-#include \"agent_common.h\"\n-#include \"JVMTITools.h\"\n-\n-extern \"C\" {\n-\n-\n-#define PASSED  0\n-#define STATUS_FAILED  2\n-\n-typedef struct {\n-    const char *name;\n-    int priority;\n-    int is_daemon;\n-} info;\n-\n-static jvmtiEnv *jvmti = NULL;\n-static jint result = PASSED;\n-static jvmtiThreadInfo inf;\n-static info threads[] = {\n-    { \"main\", JVMTI_THREAD_NORM_PRIORITY, 0 },\n-    { \"thread1\", JVMTI_THREAD_MIN_PRIORITY + 2, 1 },\n-    { \"Thread-\", JVMTI_THREAD_MIN_PRIORITY, 1 },\n-    { \"vthread\", JVMTI_THREAD_NORM_PRIORITY, 1 }\n-};\n-\n-#ifdef STATIC_BUILD\n-JNIEXPORT jint JNICALL Agent_OnLoad_thrinfo001(JavaVM *jvm, char *options, void *reserved) {\n-    return Agent_Initialize(jvm, options, reserved);\n-}\n-JNIEXPORT jint JNICALL Agent_OnAttach_thrinfo001(JavaVM *jvm, char *options, void *reserved) {\n-    return Agent_Initialize(jvm, options, reserved);\n-}\n-JNIEXPORT jint JNI_OnLoad_thrinfo001(JavaVM *jvm, char *options, void *reserved) {\n-    return JNI_VERSION_1_8;\n-}\n-#endif\n-jint  Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {\n-    jint res;\n-    jvmtiCapabilities caps;\n-\n-    res = jvm->GetEnv((void **) &jvmti, JVMTI_VERSION_1_1);\n-    if (res != JNI_OK || jvmti == NULL) {\n-        printf(\"Wrong result of a valid call to GetEnv !\\n\");\n-        return JNI_ERR;\n-    }\n-\n-    memset(&caps, 0, sizeof(caps));\n-    caps.can_support_virtual_threads = 1;\n-    res = jvmti->AddCapabilities(&caps);\n-    if (res != JVMTI_ERROR_NONE) {\n-      printf(\"error in JVMTI AddCapabilities: %d\\n\", res);\n-      return JNI_ERR;\n-    }\n-    return JNI_OK;\n-}\n-\n-JNIEXPORT void JNICALL Java_nsk_jvmti_GetThreadInfo_thrinfo001_checkInfo(JNIEnv *env, jclass cls,\n-        jthread thr, jthreadGroup group, jint ind) {\n-    jvmtiError err;\n-\n-    err = jvmti->GetThreadInfo(thr, &inf);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(GetThreadInfo#%d) unexpected error: %s (%d)\\n\",\n-            ind, TranslateError(err), err);\n-        result = STATUS_FAILED;\n-    }\n-\n-    if (inf.name == NULL ||\n-            strstr(inf.name, threads[ind].name) != inf.name ||\n-            (ind < 2 && strlen(inf.name) != strlen(threads[ind].name))) {\n-        printf(\"Thread %s: incorrect name: %s\\n\", threads[ind].name, inf.name);\n-        result = STATUS_FAILED;\n-    }\n-    if (inf.priority != threads[ind].priority) {\n-        printf(\"Thread %s: priority expected: %d, got: %d\\n\",\n-            threads[ind].name, threads[ind].priority, inf.priority);\n-        result = STATUS_FAILED;\n-    }\n-    if (inf.is_daemon != threads[ind].is_daemon) {\n-        printf(\"Thread %s: is_daemon expected: %d, got: %d\\n\",\n-           threads[ind].name, threads[ind].is_daemon, inf.is_daemon);\n-        result = STATUS_FAILED;\n-    }\n-    if (!env->IsSameObject(group, inf.thread_group)) {\n-        printf(\"Thread %s: invalid thread group\\n\", threads[ind].name);\n-        result = STATUS_FAILED;\n-    }\n-}\n-\n-JNIEXPORT jint JNICALL Java_nsk_jvmti_GetThreadInfo_thrinfo001_getRes(JNIEnv *env, jclass cls) {\n-    return result;\n-}\n-\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetThreadInfo\/thrinfo001\/thrinfo001.cpp","additions":0,"deletions":120,"binary":false,"changes":120,"status":"deleted"},{"patch":"@@ -1,55 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package nsk.jvmti.GetThreadInfo;\n-\n-import java.io.PrintStream;\n-\n-public class thrinfo002 {\n-\n-    final static int JCK_STATUS_BASE = 95;\n-\n-    static {\n-        try {\n-            System.loadLibrary(\"thrinfo002\");\n-        } catch (UnsatisfiedLinkError ule) {\n-            System.err.println(\"Could not load thrinfo002 library\");\n-            System.err.println(\"java.library.path:\"\n-                + System.getProperty(\"java.library.path\"));\n-            throw ule;\n-        }\n-    }\n-\n-    native static int check(Thread thr, ThreadGroup group);\n-\n-    public static void main(String args[]) {\n-        args = nsk.share.jvmti.JVMTITest.commonInit(args);\n-\n-        \/\/ produce JCK-like exit status.\n-        System.exit(run(args, System.out) + JCK_STATUS_BASE);\n-    }\n-\n-    public static int run(String args[], PrintStream out) {\n-        return check(Thread.currentThread(), Thread.currentThread().getThreadGroup());\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetThreadInfo\/thrinfo002.java","additions":0,"deletions":55,"binary":false,"changes":55,"status":"deleted"},{"patch":"@@ -1,46 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/*\n- * @test\n- *\n- * @summary converted from VM Testbase nsk\/jvmti\/GetThreadInfo\/thrinfo002.\n- * VM Testbase keywords: [quick, jpda, jvmti, noras]\n- * VM Testbase readme:\n- * DESCRIPTION\n- *     The test exercises JVMTI function GetThreadInfo(thread, infoPtr)\n- *     The test checks the following:\n- *       - if JVMTI_ERROR_INVALID_THREAD is returned when thread is null\n- *       - if JVMTI_ERROR_NULL_POINTER is returned when infoPtr is null\n- * COMMENTS\n- *     Ported from JVMDI.\n- *\n- * @library \/vmTestbase\n- *          \/test\/lib\n- * @build nsk.jvmti.GetThreadInfo.thrinfo002\n- * @run main\/othervm\/native ExecDriver --java\n- *      -agentlib:thrinfo002\n- *      nsk.jvmti.GetThreadInfo.thrinfo002\n- *\/\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetThreadInfo\/thrinfo002\/TestDescription.java","additions":0,"deletions":46,"binary":false,"changes":46,"status":"deleted"},{"patch":"@@ -1,33 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include \"native_thread.cpp\"\n-#include \"nsk_tools.cpp\"\n-#include \"jni_tools.cpp\"\n-#include \"jvmti_tools.cpp\"\n-#include \"agent_tools.cpp\"\n-#include \"jvmti_FollowRefObjects.cpp\"\n-#include \"Injector.cpp\"\n-#include \"JVMTITools.cpp\"\n-#include \"agent_common.cpp\"\n-#include \"thrinfo002.cpp\"\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetThreadInfo\/thrinfo002\/libthrinfo002.cpp","additions":0,"deletions":33,"binary":false,"changes":33,"status":"deleted"},{"patch":"@@ -1,120 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include <stdio.h>\n-#include <string.h>\n-#include \"jvmti.h\"\n-#include \"agent_common.h\"\n-#include \"JVMTITools.h\"\n-\n-extern \"C\" {\n-\n-\n-#define PASSED 0\n-#define STATUS_FAILED 2\n-\n-static jvmtiEnv *jvmti = NULL;\n-static jint result = PASSED;\n-static jboolean printdump = JNI_FALSE;\n-\n-#ifdef STATIC_BUILD\n-JNIEXPORT jint JNICALL Agent_OnLoad_thrinfo002(JavaVM *jvm, char *options, void *reserved) {\n-    return Agent_Initialize(jvm, options, reserved);\n-}\n-JNIEXPORT jint JNICALL Agent_OnAttach_thrinfo002(JavaVM *jvm, char *options, void *reserved) {\n-    return Agent_Initialize(jvm, options, reserved);\n-}\n-JNIEXPORT jint JNI_OnLoad_thrinfo002(JavaVM *jvm, char *options, void *reserved) {\n-    return JNI_VERSION_1_8;\n-}\n-#endif\n-jint Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {\n-    jint res;\n-\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n-        printdump = JNI_TRUE;\n-    }\n-\n-    res = jvm->GetEnv((void **) &jvmti, JVMTI_VERSION_1_1);\n-    if (res != JNI_OK || jvmti == NULL) {\n-        printf(\"Wrong result of a valid call to GetEnv!\\n\");\n-        return JNI_ERR;\n-    }\n-\n-    return JNI_OK;\n-}\n-\n-JNIEXPORT jint JNICALL\n-Java_nsk_jvmti_GetThreadInfo_thrinfo002_check(JNIEnv *env, jclass cls, jthread thr, jthreadGroup group) {\n-    jvmtiError err;\n-    jvmtiThreadInfo inf;\n-\n-\n-    if (jvmti == NULL) {\n-        printf(\"JVMTI client was not properly loaded!\\n\");\n-        return STATUS_FAILED;\n-    }\n-\n-    if (printdump == JNI_TRUE) {\n-        printf(\">>> invalid thread check ...\\n\");\n-    }\n-    err = jvmti->GetThreadInfo(NULL, &inf);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"Error expected: JVMTI_ERROR_NONE,\\n\");\n-        printf(\"           got: %s (%d)\\n\", TranslateError(err), err);\n-        result = STATUS_FAILED;\n-    }\n-\n-    if (inf.name == NULL || strcmp(inf.name, \"main\")) {\n-        printf(\"Thread %s: incorrect name: %s\\n\", \"main\", inf.name);\n-        result = STATUS_FAILED;\n-    }\n-    if (inf.priority != JVMTI_THREAD_NORM_PRIORITY) {\n-        printf(\"Thread %s: priority expected: %d, got: %d\\n\",\n-            \"main\", JVMTI_THREAD_NORM_PRIORITY, inf.priority);\n-        result = STATUS_FAILED;\n-    }\n-    if (inf.is_daemon != 0) {\n-        printf(\"Thread %s: is_daemon expected: %d, got: %d\\n\",\n-           \"main\", 0, inf.is_daemon);\n-        result = STATUS_FAILED;\n-    }\n-    if (!env->IsSameObject(group, inf.thread_group)) {\n-        printf(\"Thread %s: invalid thread group\\n\", \"main\");\n-        result = STATUS_FAILED;\n-    }\n-\n-    if (printdump == JNI_TRUE) {\n-        printf(\">>> null pointer check ...\\n\");\n-    }\n-    err = jvmti->GetThreadInfo(thr, NULL);\n-    if (err != JVMTI_ERROR_NULL_POINTER) {\n-        printf(\"Error expected: JVMTI_ERROR_NULL_POINTER,\\n\");\n-        printf(\"           got: %s (%d)\\n\", TranslateError(err), err);\n-        result = STATUS_FAILED;\n-    }\n-\n-    return result;\n-}\n-\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/GetThreadInfo\/thrinfo002\/thrinfo002.cpp","additions":0,"deletions":120,"binary":false,"changes":120,"status":"deleted"},{"patch":"@@ -1,62 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package nsk.jvmti.MethodEntry;\n-\n-import java.io.PrintStream;\n-\n-public class mentry001 {\n-\n-    final static int JCK_STATUS_BASE = 95;\n-\n-    static {\n-        try {\n-            System.loadLibrary(\"mentry001\");\n-        } catch (UnsatisfiedLinkError ule) {\n-            System.err.println(\"Could not load mentry001 library\");\n-            System.err.println(\"java.library.path:\"\n-                + System.getProperty(\"java.library.path\"));\n-            throw ule;\n-        }\n-    }\n-\n-    native static void enable();\n-    native static int check();\n-    native static void chain();\n-\n-    public static void main(String args[]) {\n-        args = nsk.share.jvmti.JVMTITest.commonInit(args);\n-\n-        \/\/ produce JCK-like exit status.\n-        System.exit(run(args, System.out) + JCK_STATUS_BASE);\n-    }\n-\n-    public static int run(String args[], PrintStream out) {\n-        enable();\n-        return check();\n-    }\n-\n-    public static void dummy() {\n-        chain();\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/MethodEntry\/mentry001.java","additions":0,"deletions":62,"binary":false,"changes":62,"status":"deleted"},{"patch":"@@ -1,47 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/*\n- * @test\n- *\n- * @summary converted from VM Testbase nsk\/jvmti\/MethodEntry\/mentry001.\n- * VM Testbase keywords: [quick, jpda, jvmti, noras]\n- * VM Testbase readme:\n- * DESCRIPTION\n- *     The test exercises JVMTI event callback function MethodEntry.\n- *     The test checks the following:\n- *       - if method and frame parameters of the function\n- *         contain expected values for events generated upon entry\n- *         of Java and native methods.\n- *       - if GetFrameLocation indentifies the initial executable\n- *         location in the method being entered.\n- * COMMENTS\n- *     Ported from JVMDI.\n- *     Fixed the 5004632 bug.\n- *\n- * @library \/vmTestbase\n- *          \/test\/lib\n- * @run main\/othervm\/native -agentlib:mentry001 nsk.jvmti.MethodEntry.mentry001\n- *\/\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/MethodEntry\/mentry001\/TestDescription.java","additions":0,"deletions":47,"binary":false,"changes":47,"status":"deleted"},{"patch":"@@ -1,33 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include \"native_thread.cpp\"\n-#include \"nsk_tools.cpp\"\n-#include \"jni_tools.cpp\"\n-#include \"jvmti_tools.cpp\"\n-#include \"agent_tools.cpp\"\n-#include \"jvmti_FollowRefObjects.cpp\"\n-#include \"Injector.cpp\"\n-#include \"JVMTITools.cpp\"\n-#include \"agent_common.cpp\"\n-#include \"mentry001.cpp\"\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/MethodEntry\/mentry001\/libmentry001.cpp","additions":0,"deletions":33,"binary":false,"changes":33,"status":"deleted"},{"patch":"@@ -1,270 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include <stdio.h>\n-#include <string.h>\n-#include <inttypes.h>\n-#include \"jvmti.h\"\n-#include \"agent_common.h\"\n-#include \"jni_tools.h\"\n-#include \"JVMTITools.h\"\n-\n-extern \"C\" {\n-\n-#define PASSED 0\n-#define STATUS_FAILED 2\n-\n-typedef struct {\n-    char *name;\n-    char *sig;\n-    jlocation loc;\n-} writable_entry_info;\n-\n-typedef struct {\n-    const char *name;\n-    const char *sig;\n-    const jlocation loc;\n-} entry_info;\n-\n-static jvmtiEnv *jvmti = NULL;\n-static jvmtiCapabilities caps;\n-static jvmtiEventCallbacks callbacks;\n-static jint result = PASSED;\n-static jboolean printdump = JNI_FALSE;\n-static size_t eventsExpected = 0;\n-static size_t eventsCount = 0;\n-static entry_info entries[] = {\n-    { \"check\", \"()I\", -1 },\n-    { \"dummy\", \"()V\", 0 },\n-    { \"chain\", \"()V\", -1 }\n-};\n-\n-void JNICALL MethodEntry(jvmtiEnv *jvmti_env, JNIEnv *env,\n-        jthread thr, jmethodID method) {\n-    jvmtiError err;\n-    char *cls_sig, *generic;\n-    writable_entry_info entry;\n-    jclass cls;\n-    jmethodID mid;\n-    char buffer[32];\n-\n-    err = jvmti_env->GetMethodDeclaringClass(method, &cls);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(GetMethodDeclaringClass) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-        return;\n-    }\n-    err = jvmti_env->GetClassSignature(cls, &cls_sig, &generic);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(GetClassSignature) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-        return;\n-    }\n-    if (cls_sig != NULL &&\n-            strcmp(cls_sig, \"Lnsk\/jvmti\/MethodEntry\/mentry001;\") == 0) {\n-        if (printdump == JNI_TRUE) {\n-            printf(\">>> retrieving method entry info ...\\n\");\n-        }\n-        err = jvmti_env->GetMethodName(method,\n-            &entry.name, &entry.sig, &generic);\n-        if (err != JVMTI_ERROR_NONE) {\n-            printf(\"(GetMethodName) unexpected error: %s (%d)\\n\",\n-                   TranslateError(err), err);\n-            result = STATUS_FAILED;\n-            return;\n-        }\n-        err = jvmti_env->GetFrameLocation(thr, 0, &mid, &entry.loc);\n-        if (err != JVMTI_ERROR_NONE) {\n-            printf(\"(GetFrameLocation) unexpected error: %s (%d)\\n\",\n-                   TranslateError(err), err);\n-            result = STATUS_FAILED;\n-            return;\n-        }\n-        if (printdump == JNI_TRUE) {\n-            printf(\">>>      class: \\\"%s\\\"\\n\", cls_sig);\n-            printf(\">>>     method: \\\"%s%s\\\"\\n\", entry.name, entry.sig);\n-            printf(\">>>   location: %s\\n\", jlong_to_string(entry.loc, buffer));\n-            printf(\">>> ... done\\n\");\n-        }\n-        if (eventsCount < sizeof(entries)\/sizeof(entry_info)) {\n-            if (entry.name == NULL ||\n-                    strcmp(entry.name, entries[eventsCount].name) != 0) {\n-                printf(\"(entry#%\" PRIuPTR \") wrong method name: \\\"%s\\\"\",\n-                       eventsCount, entry.name);\n-                printf(\", expected: \\\"%s\\\"\\n\", entries[eventsCount].name);\n-                result = STATUS_FAILED;\n-            }\n-            if (entry.sig == NULL ||\n-                    strcmp(entry.sig, entries[eventsCount].sig) != 0) {\n-                printf(\"(entry#%\" PRIuPTR \") wrong method sig: \\\"%s\\\"\",\n-                       eventsCount, entry.sig);\n-                printf(\", expected: \\\"%s\\\"\\n\", entries[eventsCount].sig);\n-                result = STATUS_FAILED;\n-            }\n-            if (entry.loc != entries[eventsCount].loc) {\n-                printf(\"(entry#%\" PRIuPTR \") wrong location: %s\",\n-                       eventsCount, jlong_to_string(entry.loc, buffer));\n-                printf(\", expected: %s\\n\",\n-                       jlong_to_string(entries[eventsCount].loc, buffer));\n-                result = STATUS_FAILED;\n-            }\n-        } else {\n-            printf(\"Unexpected method entry catched:\");\n-            printf(\"     class: \\\"%s\\\"\\n\", cls_sig);\n-            printf(\"    method: \\\"%s%s\\\"\\n\", entry.name, entry.sig);\n-            printf(\"  location: %s\\n\", jlong_to_string(entry.loc, buffer));\n-            result = STATUS_FAILED;\n-        }\n-        eventsCount++;\n-    }\n-}\n-\n-#ifdef STATIC_BUILD\n-JNIEXPORT jint JNICALL Agent_OnLoad_mentry001(JavaVM *jvm, char *options, void *reserved) {\n-    return Agent_Initialize(jvm, options, reserved);\n-}\n-JNIEXPORT jint JNICALL Agent_OnAttach_mentry001(JavaVM *jvm, char *options, void *reserved) {\n-    return Agent_Initialize(jvm, options, reserved);\n-}\n-JNIEXPORT jint JNI_OnLoad_mentry001(JavaVM *jvm, char *options, void *reserved) {\n-    return JNI_VERSION_1_8;\n-}\n-#endif\n-jint Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {\n-    jvmtiError err;\n-    jint res;\n-\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n-        printdump = JNI_TRUE;\n-    }\n-\n-    res = jvm->GetEnv((void **) &jvmti, JVMTI_VERSION_1_1);\n-    if (res != JNI_OK || jvmti == NULL) {\n-        printf(\"Wrong result of a valid call to GetEnv!\\n\");\n-        return JNI_ERR;\n-    }\n-\n-    err = jvmti->GetPotentialCapabilities(&caps);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(GetPotentialCapabilities) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        return JNI_ERR;\n-    }\n-\n-    err = jvmti->AddCapabilities(&caps);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(AddCapabilities) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        return JNI_ERR;\n-    }\n-\n-    err = jvmti->GetCapabilities(&caps);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(GetCapabilities) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        return JNI_ERR;\n-    }\n-\n-    if (caps.can_generate_method_entry_events) {\n-        callbacks.MethodEntry = &MethodEntry;\n-        err = jvmti->SetEventCallbacks(&callbacks, sizeof(callbacks));\n-        if (err != JVMTI_ERROR_NONE) {\n-            printf(\"(SetEventCallbacks) unexpected error: %s (%d)\\n\",\n-                   TranslateError(err), err);\n-            return JNI_ERR;\n-        }\n-    } else {\n-        printf(\"Warning: MethodEntry event is not implemented\\n\");\n-    }\n-\n-    return JNI_OK;\n-}\n-\n-JNIEXPORT void JNICALL\n-Java_nsk_jvmti_MethodEntry_mentry001_enable(JNIEnv *env, jclass cls) {\n-    jvmtiError err;\n-\n-    if (jvmti == NULL) {\n-        return;\n-    }\n-\n-    if (!caps.can_generate_method_entry_events) {\n-        return;\n-    }\n-\n-    err = jvmti->SetEventNotificationMode(JVMTI_ENABLE,\n-            JVMTI_EVENT_METHOD_ENTRY, NULL);\n-    if (err == JVMTI_ERROR_NONE) {\n-        eventsExpected = sizeof(entries)\/sizeof(entry_info);\n-    } else {\n-        printf(\"Failed to enable JVMTI_EVENT_METHOD_ENTRY event: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-    }\n-}\n-\n-JNIEXPORT jint JNICALL\n-Java_nsk_jvmti_MethodEntry_mentry001_check(JNIEnv *env, jclass cls) {\n-    jmethodID mid;\n-\n-    mid = env->GetStaticMethodID(cls, \"dummy\", \"()V\");\n-    if (mid == NULL) {\n-        printf(\"Cannot find metod \\\"dummy()\\\"!\\n\");\n-        return STATUS_FAILED;\n-    }\n-\n-    env->CallStaticVoidMethod(cls, mid);\n-    if (eventsCount != eventsExpected) {\n-        printf(\"Wrong number of MethodEntry events: %\" PRIuPTR \", expected: %\" PRIuPTR \"\\n\",\n-            eventsCount, eventsExpected);\n-        result = STATUS_FAILED;\n-    }\n-    return result;\n-}\n-\n-JNIEXPORT void JNICALL\n-Java_nsk_jvmti_MethodEntry_mentry001_chain(JNIEnv *env, jclass cls) {\n-    jvmtiError err;\n-\n-    if (jvmti == NULL) {\n-        printf(\"JVMTI client was not properly loaded!\\n\");\n-        result = STATUS_FAILED;\n-        return;\n-    }\n-\n-    if (!caps.can_generate_method_entry_events) {\n-        return;\n-    }\n-\n-    err = jvmti->SetEventNotificationMode(JVMTI_DISABLE,\n-            JVMTI_EVENT_METHOD_ENTRY, NULL);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"Failed to disable JVMTI_EVENT_METHOD_ENTRY event: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-    }\n-}\n-\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/MethodEntry\/mentry001\/mentry001.cpp","additions":0,"deletions":270,"binary":false,"changes":270,"status":"deleted"},{"patch":"@@ -1,67 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package nsk.jvmti.MethodEntry;\n-\n-import java.io.PrintStream;\n-\n-public class mentry002 {\n-\n-    final static int JCK_STATUS_BASE = 95;\n-    final static int MAX_LOOP = 100;\n-\n-    static {\n-        try {\n-            System.loadLibrary(\"mentry002\");\n-        } catch (UnsatisfiedLinkError ule) {\n-            System.err.println(\"Could not load mentry002 library\");\n-            System.err.println(\"java.library.path:\"\n-                + System.getProperty(\"java.library.path\"));\n-            throw ule;\n-        }\n-    }\n-\n-    native static void getReady(int i);\n-    native static int check();\n-\n-    public static void main(String args[]) {\n-        args = nsk.share.jvmti.JVMTITest.commonInit(args);\n-\n-        \/\/ produce JCK-like exit status.\n-        System.exit(run(args, System.out) + JCK_STATUS_BASE);\n-    }\n-\n-    public static int run(String argv[], PrintStream out) {\n-        int count;\n-\n-        getReady(MAX_LOOP);\n-\n-        for(int i = 0; i < MAX_LOOP; i++) {\n-            emptyMethod();\n-        }\n-\n-        return check();\n-    }\n-\n-    public static void emptyMethod() {}\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/MethodEntry\/mentry002.java","additions":0,"deletions":67,"binary":false,"changes":67,"status":"deleted"},{"patch":"@@ -1,45 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/*\n- * @test\n- *\n- * @summary converted from VM Testbase nsk\/jvmti\/MethodEntry\/mentry002.\n- * VM Testbase keywords: [quick, jpda, jvmti, noras]\n- * VM Testbase readme:\n- * DESCRIPTION\n- *     Regression test for bug\n- *         4248826 Method entry\/exit events are not created for empty methods\n- *         Release summary: 1.0_fcs\n- *         Hardware version: generic\n- *         O\/S version (unbundled products): generic\n- * COMMENTS\n- *     The test reproduced the bug on winNT 1.0fcs-E build.\n- *     Ported from JVMDI test \/nsk\/regression\/b4248826.\n- *\n- * @library \/vmTestbase\n- *          \/test\/lib\n- * @run main\/othervm\/native -agentlib:mentry002 nsk.jvmti.MethodEntry.mentry002\n- *\/\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/MethodEntry\/mentry002\/TestDescription.java","additions":0,"deletions":45,"binary":false,"changes":45,"status":"deleted"},{"patch":"@@ -1,33 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include \"native_thread.cpp\"\n-#include \"nsk_tools.cpp\"\n-#include \"jni_tools.cpp\"\n-#include \"jvmti_tools.cpp\"\n-#include \"agent_tools.cpp\"\n-#include \"jvmti_FollowRefObjects.cpp\"\n-#include \"Injector.cpp\"\n-#include \"JVMTITools.cpp\"\n-#include \"agent_common.cpp\"\n-#include \"mentry002.cpp\"\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/MethodEntry\/mentry002\/libmentry002.cpp","additions":0,"deletions":33,"binary":false,"changes":33,"status":"deleted"},{"patch":"@@ -1,186 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include <stdio.h>\n-#include <string.h>\n-#include \"jvmti.h\"\n-#include \"agent_common.h\"\n-#include \"JVMTITools.h\"\n-\n-extern \"C\" {\n-\n-\n-#define PASSED 0\n-#define STATUS_FAILED 2\n-\n-static jvmtiEnv *jvmti = NULL;\n-static jvmtiCapabilities caps;\n-static jvmtiEventCallbacks callbacks;\n-static jint result = PASSED;\n-static jboolean printdump = JNI_FALSE;\n-static int MethodEntriesExpected = 0;\n-static int MethodExitsExpected = 0;\n-static int MethodEntriesCount = 0;\n-static int MethodExitsCount = 0;\n-static jmethodID mid = NULL;\n-\n-void JNICALL MethodEntry(jvmtiEnv *jvmti_env, JNIEnv *env,\n-        jthread thr, jmethodID method) {\n-    if (mid == method) {\n-        MethodEntriesCount++;\n-    }\n-}\n-\n-void JNICALL MethodExit(jvmtiEnv *jvmti_env, JNIEnv *env,\n-        jthread thr, jmethodID method,\n-        jboolean was_poped_by_exc, jvalue return_value) {\n-    if (mid == method) {\n-        MethodExitsCount++;\n-    }\n-}\n-\n-#ifdef STATIC_BUILD\n-JNIEXPORT jint JNICALL Agent_OnLoad_mentry002(JavaVM *jvm, char *options, void *reserved) {\n-    return Agent_Initialize(jvm, options, reserved);\n-}\n-JNIEXPORT jint JNICALL Agent_OnAttach_mentry002(JavaVM *jvm, char *options, void *reserved) {\n-    return Agent_Initialize(jvm, options, reserved);\n-}\n-JNIEXPORT jint JNI_OnLoad_mentry002(JavaVM *jvm, char *options, void *reserved) {\n-    return JNI_VERSION_1_8;\n-}\n-#endif\n-jint  Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {\n-    jint res;\n-    jvmtiError err;\n-\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n-        printdump = JNI_TRUE;\n-    }\n-\n-    res = jvm->GetEnv((void **) &jvmti, JVMTI_VERSION_1_1);\n-    if (res != JNI_OK || jvmti == NULL) {\n-        printf(\"Wrong result of a valid call to GetEnv!\\n\");\n-        return JNI_ERR;\n-    }\n-\n-    err = jvmti->GetPotentialCapabilities(&caps);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(GetPotentialCapabilities) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        return JNI_ERR;\n-    }\n-\n-    err = jvmti->AddCapabilities(&caps);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(AddCapabilities) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        return JNI_ERR;\n-    }\n-\n-    err = jvmti->GetCapabilities(&caps);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(GetCapabilities) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        return JNI_ERR;\n-    }\n-\n-    if (caps.can_generate_method_entry_events &&\n-            caps.can_generate_method_exit_events) {\n-        callbacks.MethodEntry = &MethodEntry;\n-        callbacks.MethodExit = &MethodExit;\n-        err = jvmti->SetEventCallbacks(&callbacks, sizeof(callbacks));\n-        if (err != JVMTI_ERROR_NONE) {\n-            printf(\"(SetEventCallbacks) unexpected error: %s (%d)\\n\",\n-                   TranslateError(err), err);\n-            return JNI_ERR;\n-        }\n-    } else {\n-        printf(\"Warning: MethodEntry or MethodExit event is not implemented\\n\");\n-    }\n-\n-    return JNI_OK;\n-}\n-\n-JNIEXPORT void JNICALL\n-Java_nsk_jvmti_MethodEntry_mentry002_getReady(JNIEnv *env, jclass cls, jint i) {\n-    jvmtiError err;\n-\n-    if (jvmti == NULL) {\n-        printf(\"JVMTI client was not properly loaded!\\n\");\n-        return;\n-    }\n-\n-    if (!caps.can_generate_method_entry_events ||\n-            !caps.can_generate_method_exit_events) {\n-        return;\n-    }\n-\n-    mid = env->GetStaticMethodID(cls, \"emptyMethod\", \"()V\");\n-    if (mid == NULL) {\n-        printf(\"Cannot find Method ID for emptyMethod\\n\");\n-        result = STATUS_FAILED;\n-        return;\n-    }\n-\n-    err = jvmti->SetEventNotificationMode(JVMTI_ENABLE,\n-            JVMTI_EVENT_METHOD_ENTRY, NULL);\n-    if (err == JVMTI_ERROR_NONE) {\n-        MethodEntriesExpected = i;\n-    } else {\n-        printf(\"Failed to enable JVMTI_EVENT_METHOD_ENTRY event: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-    }\n-\n-    err = jvmti->SetEventNotificationMode(JVMTI_ENABLE,\n-            JVMTI_EVENT_METHOD_EXIT, NULL);\n-    if (err == JVMTI_ERROR_NONE) {\n-        MethodExitsExpected = i;\n-    } else {\n-        printf(\"Failed to enable JVMTI_EVENT_METHOD_EXIT event: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-    }\n-}\n-\n-JNIEXPORT jint JNICALL\n-Java_nsk_jvmti_MethodEntry_mentry002_check(JNIEnv *env, jclass cls) {\n-    if (printdump == JNI_TRUE) {\n-        printf(\">>> MethodEntry events: %d, MethodExit events: %d\\n\",\n-            MethodEntriesCount, MethodExitsCount);\n-    }\n-    if (MethodEntriesCount != MethodEntriesExpected) {\n-        printf(\"Wrong number of method entry events: %d, expected: %d\\n\",\n-            MethodEntriesCount, MethodEntriesExpected);\n-        result = STATUS_FAILED;\n-    }\n-    if (MethodExitsCount != MethodExitsExpected) {\n-        printf(\"Wrong number of method exit events: %d, expected: %d\\n\",\n-            MethodExitsCount, MethodExitsExpected);\n-        result = STATUS_FAILED;\n-    }\n-    return result;\n-}\n-\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/MethodEntry\/mentry002\/mentry002.cpp","additions":0,"deletions":186,"binary":false,"changes":186,"status":"deleted"},{"patch":"@@ -1,57 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package nsk.jvmti.MethodExit;\n-\n-import java.io.PrintStream;\n-\n-public class mexit001 {\n-\n-    final static int JCK_STATUS_BASE = 95;\n-\n-    static {\n-        try {\n-            System.loadLibrary(\"mexit001\");\n-        } catch (UnsatisfiedLinkError ule) {\n-            System.err.println(\"Could not load mexit001 library\");\n-            System.err.println(\"java.library.path:\"\n-                + System.getProperty(\"java.library.path\"));\n-            throw ule;\n-        }\n-    }\n-\n-    native static int check();\n-    native static int init0();\n-\n-    public static void main(String args[]) {\n-        args = nsk.share.jvmti.JVMTITest.commonInit(args);\n-\n-        \/\/ produce JCK-like exit status.\n-        System.exit(run(args, System.out) + JCK_STATUS_BASE);\n-    }\n-\n-    public static int run(String args[], PrintStream out) {\n-        init0();\n-        return check();\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/MethodExit\/mexit001.java","additions":0,"deletions":57,"binary":false,"changes":57,"status":"deleted"},{"patch":"@@ -1,48 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/*\n- * @test\n- *\n- * @summary converted from VM Testbase nsk\/jvmti\/MethodExit\/mexit001.\n- * VM Testbase keywords: [jpda, jvmti, noras]\n- * VM Testbase readme:\n- * DESCRIPTION\n- *     The test exercises JVMTI event callback function MethodExit.\n- *     The test checks the following:\n- *       - if method and frame parameters of the function\n- *         contain expected values for events generated upon exit\n- *         from Java and native methods.\n- *       - if GetFrameLocation indentifies the executable location\n- *         in the returning method, immediately prior to the return.\n- * COMMENTS\n- *     Ported from JVMDI.\n- *     Fixed the 5004632 bug.\n- *\n- * @library \/vmTestbase\n- *          \/test\/lib\n- * @compile mexit001a.jasm\n- * @run main\/othervm\/native -agentlib:mexit001 nsk.jvmti.MethodExit.mexit001\n- *\/\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/MethodExit\/mexit001\/TestDescription.java","additions":0,"deletions":48,"binary":false,"changes":48,"status":"deleted"},{"patch":"@@ -1,33 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include \"native_thread.cpp\"\n-#include \"nsk_tools.cpp\"\n-#include \"jni_tools.cpp\"\n-#include \"jvmti_tools.cpp\"\n-#include \"agent_tools.cpp\"\n-#include \"jvmti_FollowRefObjects.cpp\"\n-#include \"Injector.cpp\"\n-#include \"JVMTITools.cpp\"\n-#include \"agent_common.cpp\"\n-#include \"mexit001.cpp\"\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/MethodExit\/mexit001\/libmexit001.cpp","additions":0,"deletions":33,"binary":false,"changes":33,"status":"deleted"},{"patch":"@@ -1,280 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include <stdio.h>\n-#include <string.h>\n-#include <inttypes.h>\n-#include \"jvmti.h\"\n-#include \"agent_common.h\"\n-#include \"jni_tools.h\"\n-#include \"JVMTITools.h\"\n-\n-extern \"C\" {\n-\n-\n-#define PASSED 0\n-#define STATUS_FAILED 2\n-\n-typedef struct {\n-    const char *cls_sig;\n-    const char *name;\n-    const char *sig;\n-    jlocation loc;\n-} exit_info;\n-\n-static jvmtiEnv *jvmti = NULL;\n-static jvmtiCapabilities caps;\n-static jvmtiEventCallbacks callbacks;\n-static jint result = PASSED;\n-static jboolean printdump = JNI_FALSE;\n-static size_t eventsExpected = 0;\n-static size_t eventsCount = 0;\n-static exit_info exits[] = {\n-    { \"Lnsk\/jvmti\/MethodExit\/mexit001a;\", \"chain\", \"()V\", -1 },\n-    { \"Lnsk\/jvmti\/MethodExit\/mexit001a;\", \"dummy\", \"()V\", 3 }\n-};\n-\n-void JNICALL MethodExit(jvmtiEnv *jvmti_env, JNIEnv *env,\n-        jthread thr, jmethodID method,\n-        jboolean was_poped_by_exc, jvalue return_value) {\n-    jvmtiError err;\n-    char *cls_sig, *name, *sig, *generic;\n-    jclass cls;\n-    jmethodID mid;\n-    jlocation loc;\n-    char buffer[32];\n-\n-    err = jvmti_env->GetMethodDeclaringClass(method, &cls);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(GetMethodDeclaringClass) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-        return;\n-    }\n-    err = jvmti_env->GetClassSignature(cls, &cls_sig, &generic);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(GetClassSignature) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-        return;\n-    }\n-    if (cls_sig != NULL &&\n-            strcmp(cls_sig, \"Lnsk\/jvmti\/MethodExit\/mexit001a;\") == 0) {\n-        if (printdump == JNI_TRUE) {\n-            printf(\">>> retrieving method exit info ...\\n\");\n-        }\n-        err = jvmti_env->GetMethodName(method,\n-            &name, &sig, &generic);\n-        if (err != JVMTI_ERROR_NONE) {\n-            printf(\"(GetMethodName) unexpected error: %s (%d)\\n\",\n-                   TranslateError(err), err);\n-            result = STATUS_FAILED;\n-            return;\n-        }\n-        err = jvmti_env->GetFrameLocation(thr, 0, &mid, &loc);\n-        if (err != JVMTI_ERROR_NONE) {\n-            printf(\"(GetFrameLocation) unexpected error: %s (%d)\\n\",\n-                   TranslateError(err), err);\n-            result = STATUS_FAILED;\n-            return;\n-        }\n-        if (printdump == JNI_TRUE) {\n-            printf(\">>>      class: \\\"%s\\\"\\n\", cls_sig);\n-            printf(\">>>     method: \\\"%s%s\\\"\\n\", name, sig);\n-            printf(\">>>   location: %s\\n\", jlong_to_string(loc, buffer));\n-            printf(\">>> ... done\\n\");\n-        }\n-        if (eventsCount < sizeof(exits)\/sizeof(exit_info)) {\n-            if (cls_sig == NULL ||\n-                    strcmp(cls_sig, exits[eventsCount].cls_sig) != 0) {\n-                printf(\"(exit#%\" PRIuPTR \") wrong class: \\\"%s\\\"\",\n-                       eventsCount, cls_sig);\n-                printf(\", expected: \\\"%s\\\"\\n\", exits[eventsCount].cls_sig);\n-                result = STATUS_FAILED;\n-            }\n-            if (name == NULL ||\n-                    strcmp(name, exits[eventsCount].name) != 0) {\n-                printf(\"(exit#%\" PRIuPTR \") wrong method name: \\\"%s\\\"\",\n-                       eventsCount, name);\n-                printf(\", expected: \\\"%s\\\"\\n\", exits[eventsCount].name);\n-                result = STATUS_FAILED;\n-            }\n-            if (sig == NULL ||\n-                    strcmp(sig, exits[eventsCount].sig) != 0) {\n-                printf(\"(exit#%\" PRIuPTR \") wrong method sig: \\\"%s\\\"\",\n-                       eventsCount, sig);\n-                printf(\", expected: \\\"%s\\\"\\n\", exits[eventsCount].sig);\n-                result = STATUS_FAILED;\n-            }\n-            if (loc != exits[eventsCount].loc) {\n-                printf(\"(exit#%\" PRIuPTR \") wrong location: %s\",\n-                       eventsCount, jlong_to_string(loc, buffer));\n-                printf(\", expected: %s\\n\",\n-                       jlong_to_string(exits[eventsCount].loc, buffer));\n-                result = STATUS_FAILED;\n-            }\n-        } else {\n-            printf(\"Unexpected method exit catched:\");\n-            printf(\"     class: \\\"%s\\\"\\n\", cls_sig);\n-            printf(\"    method: \\\"%s%s\\\"\\n\", name, sig);\n-            printf(\"  location: %s\\n\", jlong_to_string(loc, buffer));\n-            result = STATUS_FAILED;\n-        }\n-        eventsCount++;\n-    }\n-}\n-\n-#ifdef STATIC_BUILD\n-JNIEXPORT jint JNICALL Agent_OnLoad_mexit001(JavaVM *jvm, char *options, void *reserved) {\n-    return Agent_Initialize(jvm, options, reserved);\n-}\n-JNIEXPORT jint JNICALL Agent_OnAttach_mexit001(JavaVM *jvm, char *options, void *reserved) {\n-    return Agent_Initialize(jvm, options, reserved);\n-}\n-JNIEXPORT jint JNI_OnLoad_mexit001(JavaVM *jvm, char *options, void *reserved) {\n-    return JNI_VERSION_1_8;\n-}\n-#endif\n-jint Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {\n-    jvmtiError err;\n-    jint res;\n-\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n-        printdump = JNI_TRUE;\n-    }\n-\n-    res = jvm->GetEnv((void **) &jvmti, JVMTI_VERSION_1_1);\n-    if (res != JNI_OK || jvmti == NULL) {\n-        printf(\"Wrong result of a valid call to GetEnv!\\n\");\n-        return JNI_ERR;\n-    }\n-\n-    err = jvmti->GetPotentialCapabilities(&caps);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(GetPotentialCapabilities) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        return JNI_ERR;\n-    }\n-\n-    err = jvmti->AddCapabilities(&caps);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(AddCapabilities) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        return JNI_ERR;\n-    }\n-\n-    err = jvmti->GetCapabilities(&caps);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(GetCapabilities) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        return JNI_ERR;\n-    }\n-\n-    if (caps.can_generate_method_exit_events) {\n-        callbacks.MethodExit = &MethodExit;\n-        err = jvmti->SetEventCallbacks(&callbacks, sizeof(callbacks));\n-        if (err != JVMTI_ERROR_NONE) {\n-            printf(\"(SetEventCallbacks) unexpected error: %s (%d)\\n\",\n-                   TranslateError(err), err);\n-            return JNI_ERR;\n-        }\n-    } else {\n-        printf(\"Warning: MethodExit event is not implemented\\n\");\n-    }\n-\n-    return JNI_OK;\n-}\n-\n-JNIEXPORT jint JNICALL\n-Java_nsk_jvmti_MethodExit_mexit001_init0(JNIEnv *env, jclass cls) {\n-    jvmtiError err;\n-    if (jvmti == NULL) {\n-        printf(\"JVMTI client was not properly loaded!\\n\");\n-        return STATUS_FAILED;\n-    }\n-\n-    err = jvmti->SetEventNotificationMode(JVMTI_ENABLE,\n-            JVMTI_EVENT_METHOD_EXIT, NULL);\n-    if (err == JVMTI_ERROR_NONE) {\n-        eventsExpected = sizeof(exits)\/sizeof(exit_info);\n-    } else {\n-        printf(\"Failed to enable JVMTI_EVENT_METHOD_EXIT event: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-    }\n-\n-    \/\/ TODO: should we return result instead?\n-    return PASSED;\n-}\n-\n-JNIEXPORT jint JNICALL\n-Java_nsk_jvmti_MethodExit_mexit001_check(JNIEnv *env, jclass cls) {\n-    jvmtiError err;\n-    jclass clz;\n-    jmethodID mid;\n-\n-    if (jvmti == NULL) {\n-        printf(\"JVMTI client was not properly loaded!\\n\");\n-        return STATUS_FAILED;\n-    }\n-\n-    if (!caps.can_generate_method_exit_events) {\n-        return result;\n-    }\n-\n-    clz = env->FindClass(\"nsk\/jvmti\/MethodExit\/mexit001a\");\n-    if (clz == NULL) {\n-        printf(\"Cannot find nsk.jvmti.MethodExit.mexit001a class!\\n\");\n-        return STATUS_FAILED;\n-    }\n-\n-    mid = env->GetStaticMethodID(clz, \"dummy\", \"()V\");\n-    if (mid == NULL) {\n-        printf(\"Cannot find metod \\\"dummy()\\\"!\\n\");\n-        return STATUS_FAILED;\n-    }\n-\n-    env->CallStaticVoidMethod(clz, mid);\n-\n-    err = jvmti->SetEventNotificationMode(JVMTI_DISABLE,\n-            JVMTI_EVENT_METHOD_EXIT, NULL);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"Failed to disable JVMTI_EVENT_METHOD_EXIT event: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-    }\n-\n-    if (eventsCount != eventsExpected) {\n-        printf(\"Wrong number of MethodExit events: %\" PRIuPTR \", expected: %\" PRIuPTR \"\\n\",\n-            eventsCount, eventsExpected);\n-        result = STATUS_FAILED;\n-    }\n-    return result;\n-}\n-\n-JNIEXPORT void JNICALL\n-Java_nsk_jvmti_MethodExit_mexit001a_chain(JNIEnv *env, jclass cls) {\n-    printf(\"Executing chain()\\n\");\n-}\n-\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/MethodExit\/mexit001\/mexit001.cpp","additions":0,"deletions":280,"binary":false,"changes":280,"status":"deleted"},{"patch":"@@ -1,40 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package nsk\/jvmti\/MethodExit;\n-\n-super public class mexit001a {\n-\n-    public Method \"<init>\":\"()V\" stack 1 locals 1 {\n-        aload_0;\n-        invokespecial   Method java\/lang\/Object.\"<init>\":\"()V\";\n-        return;\n-    }\n-\n-    static native Method chain:\"()V\";\n-\n-    public static Method dummy:\"()V\" stack 0 locals 0 {\n-        invokestatic    Method chain:\"()V\";\n-        return; \/\/ bci=3\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/MethodExit\/mexit001\/mexit001a.jasm","additions":0,"deletions":40,"binary":false,"changes":40,"status":"deleted"},{"patch":"@@ -1,55 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package nsk.jvmti.MethodExit;\n-\n-import java.io.PrintStream;\n-\n-public class mexit002 {\n-\n-    final static int JCK_STATUS_BASE = 95;\n-\n-    static {\n-        try {\n-            System.loadLibrary(\"mexit002\");\n-        } catch (UnsatisfiedLinkError ule) {\n-            System.err.println(\"Could not load mexit002 library\");\n-            System.err.println(\"java.library.path:\"\n-                + System.getProperty(\"java.library.path\"));\n-            throw ule;\n-        }\n-    }\n-\n-    native static int check();\n-\n-    public static void main(String args[]) {\n-        args = nsk.share.jvmti.JVMTITest.commonInit(args);\n-\n-        \/\/ produce JCK-like exit status.\n-        System.exit(run(args, System.out) + JCK_STATUS_BASE);\n-    }\n-\n-    public static int run(String args[], PrintStream out) {\n-        return check();\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/MethodExit\/mexit002.java","additions":0,"deletions":55,"binary":false,"changes":55,"status":"deleted"},{"patch":"@@ -1,51 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/*\n- * @test\n- *\n- * @summary converted from VM Testbase nsk\/jvmti\/MethodExit\/mexit002.\n- * VM Testbase keywords: [quick, jpda, jvmti, noras]\n- * VM Testbase readme:\n- * DESCRIPTION\n- *     The test exercises JVMTI event callback function MethodExit.\n- *     The test checks the following:\n- *       - if clazz, method and frame parameters of the function\n- *         contain expected values for events generated upon exit\n- *         from Java and native methods.\n- *       - if GetFrameLocation indentifies the executable location\n- *         in the returning method, immediately prior to the return.\n- *     The test is the same as mexit001 one. The only difference is\n- *     the METHOD_EXIT event enable is moved from method chain()\n- *     to method check().\n- * COMMENTS\n- *     Ported from JVMDI.\n- *     Fixed the 5004632 bug.\n- *\n- * @library \/vmTestbase\n- *          \/test\/lib\n- * @compile mexit002a.jasm\n- * @run main\/othervm\/native -agentlib:mexit002 nsk.jvmti.MethodExit.mexit002\n- *\/\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/MethodExit\/mexit002\/TestDescription.java","additions":0,"deletions":51,"binary":false,"changes":51,"status":"deleted"},{"patch":"@@ -1,33 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include \"native_thread.cpp\"\n-#include \"nsk_tools.cpp\"\n-#include \"jni_tools.cpp\"\n-#include \"jvmti_tools.cpp\"\n-#include \"agent_tools.cpp\"\n-#include \"jvmti_FollowRefObjects.cpp\"\n-#include \"Injector.cpp\"\n-#include \"JVMTITools.cpp\"\n-#include \"agent_common.cpp\"\n-#include \"mexit002.cpp\"\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/MethodExit\/mexit002\/libmexit002.cpp","additions":0,"deletions":33,"binary":false,"changes":33,"status":"deleted"},{"patch":"@@ -1,270 +0,0 @@\n- \/*\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include <stdio.h>\n-#include <string.h>\n-#include <inttypes.h>\n-#include \"jvmti.h\"\n-#include \"agent_common.h\"\n-#include \"jni_tools.h\"\n-#include \"JVMTITools.h\"\n-\n-extern \"C\" {\n-\n-\n-#define PASSED 0\n-#define STATUS_FAILED 2\n-\n-typedef struct {\n-    const char *cls_sig;\n-    const char *name;\n-    const char *sig;\n-    jlocation loc;\n-} exit_info;\n-\n-static jvmtiEnv *jvmti = NULL;\n-static jvmtiCapabilities caps;\n-static jvmtiEventCallbacks callbacks;\n-static jint result = PASSED;\n-static jboolean printdump = JNI_FALSE;\n-static size_t eventsExpected = 0;\n-static size_t eventsCount = 0;\n-static exit_info exits[] = {\n-    { \"Lnsk\/jvmti\/MethodExit\/mexit002a;\", \"chain\", \"()V\", -1 },\n-    { \"Lnsk\/jvmti\/MethodExit\/mexit002a;\", \"dummy\", \"()V\", 3 }\n-};\n-\n-void JNICALL MethodExit(jvmtiEnv *jvmti_env, JNIEnv *env,\n-        jthread thr, jmethodID method,\n-        jboolean was_poped_by_exc, jvalue return_value) {\n-    jvmtiError err;\n-    char *cls_sig, *name, *sig, *generic;\n-    jclass cls;\n-    jmethodID mid;\n-    jlocation loc;\n-    char buffer[32];\n-\n-    err = jvmti_env->GetMethodDeclaringClass(method, &cls);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(GetMethodDeclaringClass) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-        return;\n-    }\n-    err = jvmti_env->GetClassSignature(cls, &cls_sig, &generic);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(GetClassSignature) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-        return;\n-    }\n-    if (cls_sig != NULL &&\n-            strcmp(cls_sig, \"Lnsk\/jvmti\/MethodExit\/mexit002a;\") == 0) {\n-        if (printdump == JNI_TRUE) {\n-            printf(\">>> retrieving method exit info ...\\n\");\n-        }\n-        err = jvmti_env->GetMethodName(method,\n-            &name, &sig, &generic);\n-        if (err != JVMTI_ERROR_NONE) {\n-            printf(\"(GetMethodName) unexpected error: %s (%d)\\n\",\n-                   TranslateError(err), err);\n-            result = STATUS_FAILED;\n-            return;\n-        }\n-        err = jvmti_env->GetFrameLocation(thr, 0, &mid, &loc);\n-        if (err != JVMTI_ERROR_NONE) {\n-            printf(\"(GetFrameLocation) unexpected error: %s (%d)\\n\",\n-                   TranslateError(err), err);\n-            result = STATUS_FAILED;\n-            return;\n-        }\n-        if (printdump == JNI_TRUE) {\n-            printf(\">>>      class: \\\"%s\\\"\\n\", cls_sig);\n-            printf(\">>>     method: \\\"%s%s\\\"\\n\", name, sig);\n-            printf(\">>>   location: %s\\n\", jlong_to_string(loc, buffer));\n-            printf(\">>> ... done\\n\");\n-        }\n-        if (eventsCount < sizeof(exits)\/sizeof(exit_info)) {\n-            if (cls_sig == NULL ||\n-                    strcmp(cls_sig, exits[eventsCount].cls_sig) != 0) {\n-                printf(\"(exit#%\" PRIuPTR \") wrong class: \\\"%s\\\"\",\n-                       eventsCount, cls_sig);\n-                printf(\", expected: \\\"%s\\\"\\n\", exits[eventsCount].cls_sig);\n-                result = STATUS_FAILED;\n-            }\n-            if (name == NULL ||\n-                    strcmp(name, exits[eventsCount].name) != 0) {\n-                printf(\"(exit#%\" PRIuPTR \") wrong method name: \\\"%s\\\"\",\n-                       eventsCount, name);\n-                printf(\", expected: \\\"%s\\\"\\n\", exits[eventsCount].name);\n-                result = STATUS_FAILED;\n-            }\n-            if (sig == NULL ||\n-                    strcmp(sig, exits[eventsCount].sig) != 0) {\n-                printf(\"(exit#%\" PRIuPTR \") wrong method sig: \\\"%s\\\"\",\n-                       eventsCount, sig);\n-                printf(\", expected: \\\"%s\\\"\\n\", exits[eventsCount].sig);\n-                result = STATUS_FAILED;\n-            }\n-            if (loc != exits[eventsCount].loc) {\n-                printf(\"(exit#%\" PRIuPTR \") wrong location: %s\",\n-                       eventsCount, jlong_to_string(loc, buffer));\n-                printf(\", expected: %s\\n\",\n-                       jlong_to_string(exits[eventsCount].loc, buffer));\n-                result = STATUS_FAILED;\n-            }\n-        } else {\n-            printf(\"Unexpected method exit catched:\");\n-            printf(\"     class: \\\"%s\\\"\\n\", cls_sig);\n-            printf(\"    method: \\\"%s%s\\\"\\n\", name, sig);\n-            printf(\"  location: %s\\n\", jlong_to_string(loc, buffer));\n-            result = STATUS_FAILED;\n-        }\n-        eventsCount++;\n-    }\n-}\n-\n-#ifdef STATIC_BUILD\n-JNIEXPORT jint JNICALL Agent_OnLoad_mexit002(JavaVM *jvm, char *options, void *reserved) {\n-    return Agent_Initialize(jvm, options, reserved);\n-}\n-JNIEXPORT jint JNICALL Agent_OnAttach_mexit002(JavaVM *jvm, char *options, void *reserved) {\n-    return Agent_Initialize(jvm, options, reserved);\n-}\n-JNIEXPORT jint JNI_OnLoad_mexit002(JavaVM *jvm, char *options, void *reserved) {\n-    return JNI_VERSION_1_8;\n-}\n-#endif\n-jint Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {\n-    jvmtiError err;\n-    jint res;\n-\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n-        printdump = JNI_TRUE;\n-    }\n-\n-    res = jvm->GetEnv((void **) &jvmti, JVMTI_VERSION_1_1);\n-    if (res != JNI_OK || jvmti == NULL) {\n-        printf(\"Wrong result of a valid call to GetEnv!\\n\");\n-        return JNI_ERR;\n-    }\n-\n-    err = jvmti->GetPotentialCapabilities(&caps);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(GetPotentialCapabilities) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        return JNI_ERR;\n-    }\n-\n-    err = jvmti->AddCapabilities(&caps);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(AddCapabilities) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        return JNI_ERR;\n-    }\n-\n-    err = jvmti->GetCapabilities(&caps);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(GetCapabilities) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        return JNI_ERR;\n-    }\n-\n-    if (caps.can_generate_method_exit_events) {\n-        callbacks.MethodExit = &MethodExit;\n-        err = jvmti->SetEventCallbacks(&callbacks, sizeof(callbacks));\n-        if (err != JVMTI_ERROR_NONE) {\n-            printf(\"(SetEventCallbacks) unexpected error: %s (%d)\\n\",\n-                   TranslateError(err), err);\n-            return JNI_ERR;\n-        }\n-    } else {\n-        printf(\"Warning: MethodExit event is not implemented\\n\");\n-    }\n-\n-    return JNI_OK;\n-}\n-\n-JNIEXPORT jint JNICALL\n-Java_nsk_jvmti_MethodExit_mexit002_check(JNIEnv *env, jclass cls) {\n-    jvmtiError err;\n-    jclass clz;\n-    jmethodID mid;\n-\n-    if (jvmti == NULL) {\n-        printf(\"JVMTI client was not properly loaded!\\n\");\n-        return STATUS_FAILED;\n-    }\n-\n-    if (!caps.can_generate_method_exit_events) {\n-        return result;\n-    }\n-\n-    clz = env->FindClass(\"nsk\/jvmti\/MethodExit\/mexit002a\");\n-    if (clz == NULL) {\n-        printf(\"Failed to find class \\\"mexit002a\\\"!\\n\");\n-        return STATUS_FAILED;\n-    }\n-\n-    mid = env->GetStaticMethodID(clz, \"dummy\", \"()V\");\n-    if (mid == NULL) {\n-        printf(\"Failed to get method \\\"dummy\\\"!\\n\");\n-        return STATUS_FAILED;\n-    }\n-\n-    err = jvmti->SetEventNotificationMode(JVMTI_ENABLE,\n-            JVMTI_EVENT_METHOD_EXIT, NULL);\n-    if (err == JVMTI_ERROR_NONE) {\n-        eventsExpected = sizeof(exits)\/sizeof(exit_info);\n-    } else {\n-        printf(\"Failed to enable JVMTI_EVENT_METHOD_EXIT event: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-    }\n-\n-    env->CallStaticVoidMethod(clz, mid);\n-\n-    err = jvmti->SetEventNotificationMode(JVMTI_DISABLE,\n-            JVMTI_EVENT_METHOD_EXIT, NULL);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"Failed to disable JVMTI_EVENT_METHOD_EXIT event: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-    }\n-\n-    if (eventsCount != eventsExpected) {\n-        printf(\"Wrong number of method exit events: %\" PRIuPTR \", expected: %\" PRIuPTR \"\\n\",\n-            eventsCount, eventsExpected);\n-        result = STATUS_FAILED;\n-    }\n-    return result;\n-}\n-\n-JNIEXPORT void JNICALL\n-Java_nsk_jvmti_MethodExit_mexit002a_chain(JNIEnv *env, jclass cls) {\n-    if (printdump == JNI_TRUE) {\n-        printf(\">>> about to exit method chain ...\\n\");\n-    }\n-}\n-\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/MethodExit\/mexit002\/mexit002.cpp","additions":0,"deletions":270,"binary":false,"changes":270,"status":"deleted"},{"patch":"@@ -1,40 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package nsk\/jvmti\/MethodExit;\n-\n-super public class mexit002a {\n-\n-    public Method \"<init>\":\"()V\" stack 1 locals 1 {\n-        aload_0;\n-        invokespecial   Method java\/lang\/Object.\"<init>\":\"()V\";\n-        return;\n-    }\n-\n-    static native Method chain:\"()V\";\n-\n-    public static Method dummy:\"()V\" stack 0 locals 0 {\n-        invokestatic    Method chain:\"()V\";\n-        return; \/\/ bci=3\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/MethodExit\/mexit002\/mexit002a.jasm","additions":0,"deletions":40,"binary":false,"changes":40,"status":"deleted"},{"patch":"@@ -1,137 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package nsk.jvmti.MonitorContendedEnter;\n-\n-import java.io.PrintStream;\n-\n-import nsk.share.*;\n-import nsk.share.jvmti.*;\n-\n-public class mcontenter001 extends DebugeeClass {\n-\n-    \/\/ load native library if required\n-    static {\n-        loadLibrary(\"mcontenter001\");\n-    }\n-\n-    \/\/ run test from command line\n-    public static void main(String argv[]) {\n-        argv = nsk.share.jvmti.JVMTITest.commonInit(argv);\n-\n-        \/\/ JCK-compatible exit\n-        System.exit(run(argv, System.out) + Consts.JCK_STATUS_BASE);\n-    }\n-\n-    \/\/ run test from JCK-compatible environment\n-    public static int run(String argv[], PrintStream out) {\n-        return new mcontenter001().runIt(argv, out);\n-    }\n-\n-    \/* =================================================================== *\/\n-\n-    \/\/ scaffold objects\n-    ArgumentHandler argHandler = null;\n-    Log log = null;\n-    int status = Consts.TEST_PASSED;\n-    long timeout = 0;\n-\n-    \/\/ tested thread\n-    mcontenter001Thread thread = null;\n-\n-    \/\/ run debuggee\n-    public int runIt(String argv[], PrintStream out) {\n-        argHandler = new ArgumentHandler(argv);\n-        log = new Log(out, argHandler);\n-        timeout = argHandler.getWaitTime() * 60000; \/\/ milliseconds\n-        log.display(\"Timeout = \" + timeout + \" msc.\");\n-\n-        thread = new mcontenter001Thread(\"Debuggee Thread\");\n-\n-        synchronized (thread.endingMonitor) {\n-\n-            \/\/ run thread\n-            try {\n-                \/\/ start thread\n-                synchronized (thread.startingMonitor) {\n-                    thread.start();\n-                    thread.startingMonitor.wait(timeout);\n-                }\n-            } catch (InterruptedException e) {\n-                throw new Failure(e);\n-            }\n-\n-            int totalDelay = 0;\n-            while (getEventCount() < 1 && totalDelay < timeout) {\n-                try {\n-                    Thread.sleep(100);\n-                } catch (InterruptedException e) {\n-                    throw new Failure(e);\n-                }\n-                totalDelay += 100;\n-            }\n-\n-            Thread.yield();\n-            log.display(\"Thread started\");\n-        }\n-\n-        \/\/ wait for thread finish\n-        try {\n-            thread.join(timeout);\n-        } catch (InterruptedException e) {\n-            throw new Failure(e);\n-        }\n-\n-        log.display(\"Sync: thread finished\");\n-        status = checkStatus(status);\n-\n-        return status;\n-    }\n-\n-    private native int getEventCount();\n-}\n-\n-\/* =================================================================== *\/\n-\n-class mcontenter001Thread extends Thread {\n-    public Object startingMonitor = new Object();\n-    public Object endingMonitor = new Object();\n-\n-    public mcontenter001Thread(String name) {\n-        super(name);\n-    }\n-\n-    public void run() {\n-\n-        mcontenter001.checkStatus(Consts.TEST_PASSED);\n-\n-        \/\/ notify about starting\n-        synchronized (startingMonitor) {\n-            startingMonitor.notify();\n-        }\n-\n-        \/\/ wait until main thread release monitor\n-        synchronized (endingMonitor) {\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/MonitorContendedEnter\/mcontenter001.java","additions":0,"deletions":137,"binary":false,"changes":137,"status":"deleted"},{"patch":"@@ -1,49 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/*\n- * @test\n- *\n- * @summary converted from VM Testbase nsk\/jvmti\/MonitorContendedEnter\/mcontenter001.\n- * VM Testbase keywords: [quick, jpda, jvmti, noras]\n- * VM Testbase readme:\n- * DESCRIPTION\n- *     The test exercises JVMTI event callback function\n- *         MonitorContendedEnter(jni_env, thread, object).\n- *     The test checks if the thread and object parameters of the function\n- *     contain expected values for callback when a thread is attemping\n- *     to enter a Java language monitor already acquired by another thread.\n- * COMMENTS\n- *     The test updated to match new JVMTI spec 0.2.90:\n- *     - change signature of agentProc function\n- *       and save JNIEnv pointer now passed as argument.\n- *     1000 ms of sleep added to main thread to reduce probability of bad racing.\n- *\n- * @library \/vmTestbase\n- *          \/test\/lib\n- * @run main\/othervm\/native\n- *      -agentlib:mcontenter001=-waittime=5\n- *      nsk.jvmti.MonitorContendedEnter.mcontenter001\n- *\/\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/MonitorContendedEnter\/mcontenter001\/TestDescription.java","additions":0,"deletions":49,"binary":false,"changes":49,"status":"deleted"},{"patch":"@@ -1,33 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include \"native_thread.cpp\"\n-#include \"nsk_tools.cpp\"\n-#include \"jni_tools.cpp\"\n-#include \"jvmti_tools.cpp\"\n-#include \"agent_tools.cpp\"\n-#include \"jvmti_FollowRefObjects.cpp\"\n-#include \"Injector.cpp\"\n-#include \"JVMTITools.cpp\"\n-#include \"agent_common.cpp\"\n-#include \"mcontenter001.cpp\"\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/MonitorContendedEnter\/mcontenter001\/libmcontenter001.cpp","additions":0,"deletions":33,"binary":false,"changes":33,"status":"deleted"},{"patch":"@@ -1,255 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include <stdio.h>\n-#include <string.h>\n-#include \"jni_tools.h\"\n-#include \"agent_common.h\"\n-#include \"jvmti_tools.h\"\n-\n-extern \"C\" {\n-\n-\/* ========================================================================== *\/\n-\n-\/* scaffold objects *\/\n-static JNIEnv* jni = NULL;\n-static jvmtiEnv *jvmti = NULL;\n-static jlong timeout = 0;\n-\n-\/* test objects *\/\n-static jthread thread = NULL;\n-static jobject object = NULL;\n-static volatile int eventsCount = 0;\n-\n-\/* ========================================================================== *\/\n-\n-void JNICALL\n-MonitorContendedEnter(jvmtiEnv *jvmti, JNIEnv* jni, jthread thr, jobject obj) {\n-\n-    NSK_DISPLAY2(\"MonitorContendedEnter event:\\n\\tthread: %p, object: %p\\n\",\n-        thr, obj);\n-\n-    if (!NSK_VERIFY(thread != NULL)) {\n-        nsk_jvmti_setFailStatus();\n-        return;\n-    }\n-\n-    \/* check if event is for tested thread and for tested object *\/\n-    if (jni->IsSameObject(thread, thr) &&\n-        jni->IsSameObject(object, obj))\n-            eventsCount++;\n-}\n-\n-\/* ========================================================================== *\/\n-\n-static int prepare() {\n-    const char* THREAD_NAME = \"Debuggee Thread\";\n-    jclass klass = NULL;\n-    jfieldID field = NULL;\n-    jvmtiThreadInfo info;\n-    jthread *threads = NULL;\n-    jint threads_count = 0;\n-    int i;\n-\n-    NSK_DISPLAY0(\"Prepare: find tested thread\\n\");\n-\n-    \/* get all live threads *\/\n-    if (!NSK_JVMTI_VERIFY(jvmti->GetAllThreads(&threads_count, &threads)))\n-        return NSK_FALSE;\n-\n-    if (!NSK_VERIFY(threads_count > 0 && threads != NULL))\n-        return NSK_FALSE;\n-\n-    \/* find tested thread *\/\n-    for (i = 0; i < threads_count; i++) {\n-        if (!NSK_VERIFY(threads[i] != NULL))\n-            return NSK_FALSE;\n-\n-        \/* get thread information *\/\n-        if (!NSK_JVMTI_VERIFY(jvmti->GetThreadInfo(threads[i], &info)))\n-            return NSK_FALSE;\n-\n-        NSK_DISPLAY3(\"    thread #%d (%s): %p\\n\", i, info.name, threads[i]);\n-\n-        \/* find by name *\/\n-        if (info.name != NULL && (strcmp(info.name, THREAD_NAME) == 0)) {\n-            thread = threads[i];\n-        }\n-    }\n-\n-    \/* deallocate threads list *\/\n-    if (!NSK_JVMTI_VERIFY(jvmti->Deallocate((unsigned char*)threads)))\n-        return NSK_FALSE;\n-\n-    if (thread == NULL) {\n-        NSK_COMPLAIN0(\"Debuggee thread not found\");\n-        return NSK_FALSE;\n-    }\n-\n-    \/* make thread accessable for a long time *\/\n-    if (!NSK_JNI_VERIFY(jni, (thread = jni->NewGlobalRef(thread)) != NULL))\n-        return NSK_FALSE;\n-\n-    \/* get tested thread class *\/\n-    if (!NSK_JNI_VERIFY(jni, (klass = jni->GetObjectClass(thread)) != NULL))\n-        return NSK_FALSE;\n-\n-    \/* get tested thread field 'endingMonitor' *\/\n-    if (!NSK_JNI_VERIFY(jni, (field =\n-            jni->GetFieldID(klass, \"endingMonitor\", \"Ljava\/lang\/Object;\")) != NULL))\n-        return NSK_FALSE;\n-\n-    \/* get 'endingMonitor' object *\/\n-    if (!NSK_JNI_VERIFY(jni, (object = jni->GetObjectField(thread, field)) != NULL))\n-        return NSK_FALSE;\n-\n-    \/* make object accessable for a long time *\/\n-    if (!NSK_JNI_VERIFY(jni, (object = jni->NewGlobalRef(object)) != NULL))\n-        return NSK_FALSE;\n-\n-    \/* enable MonitorContendedEnter event *\/\n-    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE,\n-                                                          JVMTI_EVENT_MONITOR_CONTENDED_ENTER,\n-                                                          NULL)))\n-        return NSK_FALSE;\n-\n-    return NSK_TRUE;\n-}\n-\n-static int clean() {\n-\n-    \/* disable MonitorContendedEnter event *\/\n-    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_DISABLE,\n-                                                          JVMTI_EVENT_MONITOR_CONTENDED_ENTER,\n-                                                          NULL)))\n-        nsk_jvmti_setFailStatus();\n-\n-    return NSK_TRUE;\n-}\n-\n-\/* ========================================================================== *\/\n-\n-\/* agent algorithm\n- *\/\n-static void JNICALL\n-agentProc(jvmtiEnv* jvmti, JNIEnv* agentJNI, void* arg) {\n-    jni = agentJNI;\n-\n-    \/* wait for initial sync *\/\n-    if (!nsk_jvmti_waitForSync(timeout))\n-        return;\n-\n-    if (!prepare()) {\n-        nsk_jvmti_setFailStatus();\n-        return;\n-    }\n-\n-    \/* clear events count *\/\n-    eventsCount = 0;\n-\n-    \/* resume debugee to catch MonitorContendedEnter event *\/\n-    if (!(NSK_VERIFY(nsk_jvmti_resumeSync()) &&\n-          NSK_VERIFY(nsk_jvmti_waitForSync(timeout))))\n-        return;\n-\n-    NSK_DISPLAY1(\"Number of MonitorContendedEnter events: %d\\n\", eventsCount);\n-\n-    if (eventsCount == 0) {\n-        NSK_COMPLAIN0(\"No any MonitorContendedEnter event\\n\");\n-        nsk_jvmti_setFailStatus();\n-    }\n-\n-    if (!clean()) {\n-        nsk_jvmti_setFailStatus();\n-        return;\n-    }\n-\n-    \/* resume debugee after last sync *\/\n-    if (!nsk_jvmti_resumeSync())\n-        return;\n-}\n-\n-\/* ========================================================================== *\/\n-\n-\/* agent library initialization\n- *\/\n-#ifdef STATIC_BUILD\n-JNIEXPORT jint JNICALL Agent_OnLoad_mcontenter001(JavaVM *jvm, char *options, void *reserved) {\n-    return Agent_Initialize(jvm, options, reserved);\n-}\n-JNIEXPORT jint JNICALL Agent_OnAttach_mcontenter001(JavaVM *jvm, char *options, void *reserved) {\n-    return Agent_Initialize(jvm, options, reserved);\n-}\n-JNIEXPORT jint JNI_OnLoad_mcontenter001(JavaVM *jvm, char *options, void *reserved) {\n-    return JNI_VERSION_1_8;\n-}\n-#endif\n-jint Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {\n-    jvmtiCapabilities caps;\n-    jvmtiEventCallbacks callbacks;\n-\n-    \/* init framework and parse options *\/\n-    if (!NSK_VERIFY(nsk_jvmti_parseOptions(options)))\n-        return JNI_ERR;\n-\n-    timeout = nsk_jvmti_getWaitTime() * 60000;\n-    NSK_DISPLAY1(\"Timeout: %d msc\\n\", (int)timeout);\n-\n-    \/* create JVMTI environment *\/\n-    if (!NSK_VERIFY((jvmti =\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n-        return JNI_ERR;\n-\n-    if (!NSK_JVMTI_VERIFY(jvmti->GetPotentialCapabilities(&caps)))\n-        return JNI_ERR;\n-\n-    if (!NSK_JVMTI_VERIFY(jvmti->AddCapabilities(&caps)))\n-        return JNI_ERR;\n-\n-    if (!NSK_JVMTI_VERIFY(jvmti->GetCapabilities(&caps)))\n-        return JNI_ERR;\n-\n-    if (!NSK_VERIFY(caps.can_generate_monitor_events))\n-        return JNI_ERR;\n-\n-    memset(&callbacks, 0, sizeof(callbacks));\n-    callbacks.MonitorContendedEnter = &MonitorContendedEnter;\n-    if (!NSK_JVMTI_VERIFY(jvmti->SetEventCallbacks(&callbacks, sizeof(callbacks))))\n-        return JNI_ERR;\n-\n-    \/* register agent proc and arg *\/\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n-        return JNI_ERR;\n-\n-    return JNI_OK;\n-}\n-\n-JNIEXPORT jint JNICALL Java_nsk_jvmti_MonitorContendedEnter_mcontenter001_getEventCount\n-  (JNIEnv *env, jobject obj)\n-{\n-    return eventsCount;\n-}\n-\n-\/* ========================================================================== *\/\n-\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/MonitorContendedEnter\/mcontenter001\/mcontenter001.cpp","additions":0,"deletions":255,"binary":false,"changes":255,"status":"deleted"},{"patch":"@@ -1,138 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package nsk.jvmti.MonitorContendedEntered;\n-\n-import java.io.PrintStream;\n-\n-import nsk.share.*;\n-import nsk.share.jvmti.*;\n-\n-public class mcontentered001 extends DebugeeClass {\n-\n-    \/\/ load native library if required\n-    static {\n-        loadLibrary(\"mcontentered001\");\n-    }\n-\n-    \/\/ run test from command line\n-    public static void main(String argv[]) {\n-        argv = nsk.share.jvmti.JVMTITest.commonInit(argv);\n-\n-        \/\/ JCK-compatible exit\n-        System.exit(run(argv, System.out) + Consts.JCK_STATUS_BASE);\n-    }\n-\n-    \/\/ run test from JCK-compatible environment\n-    public static int run(String argv[], PrintStream out) {\n-        return new mcontentered001().runIt(argv, out);\n-    }\n-\n-    \/* =================================================================== *\/\n-\n-    \/\/ scaffold objects\n-    ArgumentHandler argHandler = null;\n-    Log log = null;\n-    int status = Consts.TEST_PASSED;\n-    long timeout = 0;\n-\n-    \/\/ tested thread\n-    mcontentered001Thread thread = null;\n-\n-    \/\/ run debuggee\n-    public int runIt(String argv[], PrintStream out) {\n-        argHandler = new ArgumentHandler(argv);\n-        log = new Log(out, argHandler);\n-        timeout = argHandler.getWaitTime() * 60000; \/\/ milliseconds\n-        log.display(\"Timeout = \" + timeout + \" msc.\");\n-\n-        thread = new mcontentered001Thread(\"Debuggee Thread\");\n-\n-        synchronized (thread.endingMonitor) {\n-\n-            \/\/ run thread\n-            try {\n-                \/\/ start thread\n-                synchronized (thread.startingMonitor) {\n-                    thread.start();\n-                    thread.startingMonitor.wait(timeout);\n-                }\n-            } catch (InterruptedException e) {\n-                throw new Failure(e);\n-            }\n-\n-            int totalDelay = 0;\n-            while (getEventCount() < 1 && totalDelay < timeout) {\n-                try {\n-                    Thread.sleep(100);\n-                } catch (InterruptedException e) {\n-                    throw new Failure(e);\n-                }\n-                totalDelay += 100;\n-            }\n-\n-            Thread.yield();\n-            log.display(\"Thread started\");\n-        }\n-\n-        \/\/ wait for thread finish\n-        try {\n-            thread.join(timeout);\n-        } catch (InterruptedException e) {\n-            throw new Failure(e);\n-        }\n-\n-        log.display(\"Sync: thread finished\");\n-        status = checkStatus(status);\n-\n-        return status;\n-    }\n-\n-    private native int getEventCount();\n-}\n-\n-\/* =================================================================== *\/\n-\n-class mcontentered001Thread extends Thread {\n-    public Object startingMonitor = new Object();\n-    public Object endingMonitor = new Object();\n-\n-    public mcontentered001Thread(String name) {\n-        super(name);\n-    }\n-\n-    public void run() {\n-\n-        mcontentered001.checkStatus(Consts.TEST_PASSED);\n-\n-        \/\/ notify about starting\n-        synchronized (startingMonitor) {\n-            startingMonitor.notify();\n-        }\n-\n-        \/\/ wait until main thread release monitor\n-        synchronized (endingMonitor) {\n-            endingMonitor.notify();\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/MonitorContendedEntered\/mcontentered001.java","additions":0,"deletions":138,"binary":false,"changes":138,"status":"deleted"},{"patch":"@@ -1,48 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/*\n- * @test\n- *\n- * @summary converted from VM Testbase nsk\/jvmti\/MonitorContendedEntered\/mcontentered001.\n- * VM Testbase keywords: [quick, jpda, jvmti, noras]\n- * VM Testbase readme:\n- * DESCRIPTION\n- *     The test exercises JVMTI event callback function\n- *         MonitorContendedEntered(jni_env, thread, object).\n- *     The test checks if the thread and object parameters of the function\n- *     contain expected values for callback when a thread enters a Java language\n- *     monitor after waiting for it to be released by another thread.\n- * COMMENTS\n- *     The test updated to match new JVMTI spec 0.2.90:\n- *     - change signature of agentProc function\n- *       and save JNIEnv pointer now passed as argument.\n- *\n- * @library \/vmTestbase\n- *          \/test\/lib\n- * @run main\/othervm\/native\n- *      -agentlib:mcontentered001=-waittime=5\n- *      nsk.jvmti.MonitorContendedEntered.mcontentered001\n- *\/\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/MonitorContendedEntered\/mcontentered001\/TestDescription.java","additions":0,"deletions":48,"binary":false,"changes":48,"status":"deleted"},{"patch":"@@ -1,33 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include \"native_thread.cpp\"\n-#include \"nsk_tools.cpp\"\n-#include \"jni_tools.cpp\"\n-#include \"jvmti_tools.cpp\"\n-#include \"agent_tools.cpp\"\n-#include \"jvmti_FollowRefObjects.cpp\"\n-#include \"Injector.cpp\"\n-#include \"JVMTITools.cpp\"\n-#include \"agent_common.cpp\"\n-#include \"mcontentered001.cpp\"\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/MonitorContendedEntered\/mcontentered001\/libmcontentered001.cpp","additions":0,"deletions":33,"binary":false,"changes":33,"status":"deleted"},{"patch":"@@ -1,283 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include <stdio.h>\n-#include <string.h>\n-#include \"jni_tools.h\"\n-#include \"agent_common.h\"\n-#include \"jvmti_tools.h\"\n-\n-extern \"C\" {\n-\n-\/* ========================================================================== *\/\n-\n-\/* scaffold objects *\/\n-static JNIEnv* jni = NULL;\n-static jvmtiEnv *jvmti = NULL;\n-static jlong timeout = 0;\n-\n-\/* test objects *\/\n-static jthread thread = NULL;\n-static jobject object = NULL;\n-static volatile int eventsCount = 0;\n-\n-\/* ========================================================================== *\/\n-\n-\/* Check GetPotentialCapabilities function\n- *\/\n-void JNICALL\n-MonitorContendedEntered(jvmtiEnv *jvmti, JNIEnv* jni, jthread thr, jobject obj) {\n-\n-    NSK_DISPLAY2(\"MonitorContendedEntered event:\\n\\tthread: %p, object: %p\\n\",\n-        thr, obj);\n-\n-    if (!NSK_VERIFY(thread != NULL)) {\n-        nsk_jvmti_setFailStatus();\n-        return;\n-    }\n-\n-    \/* check if event is for tested thread and for tested object *\/\n-    if (jni->IsSameObject(thread, thr) &&\n-        jni->IsSameObject(object, obj))\n-            eventsCount++;\n-}\n-\n-void JNICALL\n-MonitorContendedEnter(jvmtiEnv *jvmti, JNIEnv* jni, jthread thr, jobject obj) {\n-\n-    NSK_DISPLAY2(\"MonitorContendedEnter event:\\n\\tthread: %p, object: %p\\n\",\n-        thr, obj);\n-\n-    if (!NSK_VERIFY(thread != NULL)) {\n-        nsk_jvmti_setFailStatus();\n-        return;\n-    }\n-\n-    \/* check if event is for tested thread and for tested object *\/\n-    if (jni->IsSameObject(thread, thr) &&\n-        jni->IsSameObject(object, obj))\n-            eventsCount++;\n-}\n-\n-\n-\/* ========================================================================== *\/\n-\n-static int prepare() {\n-    const char* THREAD_NAME = \"Debuggee Thread\";\n-    jclass klass = NULL;\n-    jfieldID field = NULL;\n-    jvmtiThreadInfo info;\n-    jthread *threads = NULL;\n-    jint threads_count = 0;\n-    int i;\n-\n-    NSK_DISPLAY0(\"Prepare: find tested thread\\n\");\n-\n-    \/* get all live threads *\/\n-    if (!NSK_JVMTI_VERIFY(jvmti->GetAllThreads(&threads_count, &threads)))\n-        return NSK_FALSE;\n-\n-    if (!NSK_VERIFY(threads_count > 0 && threads != NULL))\n-        return NSK_FALSE;\n-\n-    \/* find tested thread *\/\n-    for (i = 0; i < threads_count; i++) {\n-        if (!NSK_VERIFY(threads[i] != NULL))\n-            return NSK_FALSE;\n-\n-        \/* get thread information *\/\n-        if (!NSK_JVMTI_VERIFY(jvmti->GetThreadInfo(threads[i], &info)))\n-            return NSK_FALSE;\n-\n-        NSK_DISPLAY3(\"    thread #%d (%s): %p\\n\", i, info.name, threads[i]);\n-\n-        \/* find by name *\/\n-        if (info.name != NULL && (strcmp(info.name, THREAD_NAME) == 0)) {\n-            thread = threads[i];\n-        }\n-    }\n-\n-    \/* deallocate threads list *\/\n-    if (!NSK_JVMTI_VERIFY(jvmti->Deallocate((unsigned char*)threads)))\n-        return NSK_FALSE;\n-\n-    if (thread == NULL) {\n-        NSK_COMPLAIN0(\"Debuggee thread not found\");\n-        return NSK_FALSE;\n-    }\n-\n-    \/* make thread accessable for a long time *\/\n-    if (!NSK_JNI_VERIFY(jni, (thread = jni->NewGlobalRef(thread)) != NULL))\n-        return NSK_FALSE;\n-\n-    \/* get tested thread class *\/\n-    if (!NSK_JNI_VERIFY(jni, (klass = jni->GetObjectClass(thread)) != NULL))\n-        return NSK_FALSE;\n-\n-    \/* get tested thread field 'endingMonitor' *\/\n-    if (!NSK_JNI_VERIFY(jni, (field =\n-            jni->GetFieldID(klass, \"endingMonitor\", \"Ljava\/lang\/Object;\")) != NULL))\n-        return NSK_FALSE;\n-\n-    \/* get 'endingMonitor' object *\/\n-    if (!NSK_JNI_VERIFY(jni, (object = jni->GetObjectField(thread, field)) != NULL))\n-        return NSK_FALSE;\n-\n-    \/* make object accessable for a long time *\/\n-    if (!NSK_JNI_VERIFY(jni, (object = jni->NewGlobalRef(object)) != NULL))\n-        return NSK_FALSE;\n-\n-    \/* enable MonitorContendedEntered event *\/\n-    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE,\n-                                                          JVMTI_EVENT_MONITOR_CONTENDED_ENTERED,\n-                                                          NULL)))\n-        return NSK_FALSE;\n-\n-    \/* enable MonitorContendedEnter event *\/\n-    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE,\n-                                                          JVMTI_EVENT_MONITOR_CONTENDED_ENTER,\n-                                                          NULL)))\n-        return NSK_FALSE;\n-\n-    return NSK_TRUE;\n-}\n-\n-static int clean() {\n-\n-    \/* disable MonitorContendedEntered event *\/\n-    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_DISABLE,\n-                                                          JVMTI_EVENT_MONITOR_CONTENDED_ENTERED,\n-                                                          NULL)))\n-        nsk_jvmti_setFailStatus();\n-\n-    return NSK_TRUE;\n-}\n-\n-\/* ========================================================================== *\/\n-\n-\/* agent algorithm\n- *\/\n-static void JNICALL\n-agentProc(jvmtiEnv* jvmti, JNIEnv* agentJNI, void* arg) {\n-    jni = agentJNI;\n-\n-    \/* wait for initial sync *\/\n-    if (!nsk_jvmti_waitForSync(timeout))\n-        return;\n-\n-    if (!prepare()) {\n-        nsk_jvmti_setFailStatus();\n-        return;\n-    }\n-\n-    \/* clear events count *\/\n-    eventsCount = 0;\n-\n-    \/* resume debugee to catch MonitorContendedEntered event *\/\n-    if (!(NSK_VERIFY(nsk_jvmti_resumeSync()) &&\n-          NSK_VERIFY(nsk_jvmti_waitForSync(timeout))))\n-        return;\n-\n-    NSK_DISPLAY1(\"Number of MonitorContendedEntered events: %d\\n\", eventsCount);\n-\n-    if (eventsCount == 0) {\n-        NSK_COMPLAIN0(\"No any MonitorContendedEntered event\\n\");\n-        nsk_jvmti_setFailStatus();\n-    }\n-\n-    if (!clean()) {\n-        nsk_jvmti_setFailStatus();\n-        return;\n-    }\n-\n-    \/* resume debugee after last sync *\/\n-    if (!nsk_jvmti_resumeSync())\n-        return;\n-}\n-\n-\/* ========================================================================== *\/\n-\n-\/* agent library initialization\n- *\/\n-#ifdef STATIC_BUILD\n-JNIEXPORT jint JNICALL Agent_OnLoad_mcontentered001(JavaVM *jvm, char *options, void *reserved) {\n-    return Agent_Initialize(jvm, options, reserved);\n-}\n-JNIEXPORT jint JNICALL Agent_OnAttach_mcontentered001(JavaVM *jvm, char *options, void *reserved) {\n-    return Agent_Initialize(jvm, options, reserved);\n-}\n-JNIEXPORT jint JNI_OnLoad_mcontentered001(JavaVM *jvm, char *options, void *reserved) {\n-    return JNI_VERSION_1_8;\n-}\n-#endif\n-jint Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {\n-    jvmtiCapabilities caps;\n-    jvmtiEventCallbacks callbacks;\n-\n-    \/* init framework and parse options *\/\n-    if (!NSK_VERIFY(nsk_jvmti_parseOptions(options)))\n-        return JNI_ERR;\n-\n-    timeout = nsk_jvmti_getWaitTime() * 60000;\n-    NSK_DISPLAY1(\"Timeout: %d msc\\n\", (int)timeout);\n-\n-    \/* create JVMTI environment *\/\n-    if (!NSK_VERIFY((jvmti =\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n-        return JNI_ERR;\n-\n-    if (!NSK_JVMTI_VERIFY(jvmti->GetPotentialCapabilities(&caps)))\n-        return JNI_ERR;\n-\n-    if (!NSK_JVMTI_VERIFY(jvmti->AddCapabilities(&caps)))\n-        return JNI_ERR;\n-\n-    if (!NSK_JVMTI_VERIFY(jvmti->GetCapabilities(&caps)))\n-        return JNI_ERR;\n-\n-    if (!NSK_VERIFY(caps.can_generate_monitor_events))\n-        return JNI_ERR;\n-\n-    memset(&callbacks, 0, sizeof(callbacks));\n-    callbacks.MonitorContendedEntered = &MonitorContendedEntered;\n-    callbacks.MonitorContendedEnter = &MonitorContendedEnter;\n-\n-    if (!NSK_JVMTI_VERIFY(jvmti->SetEventCallbacks(&callbacks, sizeof(callbacks))))\n-        return JNI_ERR;\n-\n-    \/* register agent proc and arg *\/\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n-        return JNI_ERR;\n-\n-    return JNI_OK;\n-}\n-\n-JNIEXPORT jint JNICALL Java_nsk_jvmti_MonitorContendedEntered_mcontentered001_getEventCount\n-  (JNIEnv *env, jobject obj)\n-{\n-    return eventsCount;\n-}\n-\n-\/* ========================================================================== *\/\n-\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/MonitorContendedEntered\/mcontentered001\/mcontentered001.cpp","additions":0,"deletions":283,"binary":false,"changes":283,"status":"deleted"},{"patch":"@@ -1,131 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package nsk.jvmti.MonitorWait;\n-\n-import java.io.PrintStream;\n-\n-import nsk.share.*;\n-import nsk.share.jvmti.*;\n-\n-public class monitorwait001 extends DebugeeClass {\n-\n-    \/\/ load native library if required\n-    static {\n-        loadLibrary(\"monitorwait001\");\n-    }\n-\n-    \/\/ run test from command line\n-    public static void main(String argv[]) {\n-        argv = nsk.share.jvmti.JVMTITest.commonInit(argv);\n-\n-        \/\/ JCK-compatible exit\n-        System.exit(run(argv, System.out) + Consts.JCK_STATUS_BASE);\n-    }\n-\n-    \/\/ run test from JCK-compatible environment\n-    public static int run(String argv[], PrintStream out) {\n-        return new monitorwait001().runIt(argv, out);\n-    }\n-\n-    \/* =================================================================== *\/\n-\n-    \/\/ scaffold objects\n-    ArgumentHandler argHandler = null;\n-    Log log = null;\n-    int status = Consts.TEST_PASSED;\n-    static long timeout = 0;\n-\n-    \/\/ tested thread\n-    monitorwait001Thread thread = null;\n-\n-    \/\/ run debuggee\n-    public int runIt(String argv[], PrintStream out) {\n-        argHandler = new ArgumentHandler(argv);\n-        log = new Log(out, argHandler);\n-        timeout = argHandler.getWaitTime() * 60000; \/\/ milliseconds\n-        log.display(\"Timeout = \" + timeout + \" msc.\");\n-\n-        thread = new monitorwait001Thread(\"Debuggee Thread\");\n-\n-        \/\/ run thread\n-        try {\n-            \/\/ start thread\n-            synchronized (thread.startingMonitor) {\n-                thread.start();\n-                thread.startingMonitor.wait(timeout);\n-            }\n-        } catch (InterruptedException e) {\n-            throw new Failure(e);\n-        }\n-\n-        Thread.yield();\n-        log.display(\"Thread started\");\n-\n-        synchronized (thread.waitingMonitor) {\n-            thread.waitingMonitor.notify();\n-        }\n-\n-        \/\/ wait for thread finish\n-        try {\n-            thread.join(timeout);\n-        } catch (InterruptedException e) {\n-            throw new Failure(e);\n-        }\n-\n-        log.display(\"Sync: thread finished\");\n-        status = checkStatus(status);\n-\n-        return status;\n-    }\n-}\n-\n-\/* =================================================================== *\/\n-\n-class monitorwait001Thread extends Thread {\n-    public Object startingMonitor = new Object();\n-    public Object waitingMonitor = new Object();\n-\n-    public monitorwait001Thread(String name) {\n-        super(name);\n-    }\n-\n-    public void run() {\n-        synchronized (waitingMonitor) {\n-\n-            monitorwait001.checkStatus(Consts.TEST_PASSED);\n-\n-            \/\/ notify about starting\n-            synchronized (startingMonitor) {\n-                startingMonitor.notify();\n-            }\n-\n-            \/\/ wait until main thread notify\n-            try {\n-                waitingMonitor.wait(monitorwait001.timeout);\n-            } catch (InterruptedException e) {\n-                throw new Failure(e);\n-            }\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/MonitorWait\/monitorwait001.java","additions":0,"deletions":131,"binary":false,"changes":131,"status":"deleted"},{"patch":"@@ -1,49 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/*\n- * @test\n- *\n- * @summary converted from VM Testbase nsk\/jvmti\/MonitorWait\/monitorwait001.\n- * VM Testbase keywords: [quick, jpda, jvmti, noras]\n- * VM Testbase readme:\n- * DESCRIPTION\n- *     The test exercises JVMTI event callback function\n- *         MonitorWait(jni_env, thread, object, timeout).\n- *     The test checks if the thread, object, and timeout parameters of\n- *     the function contain expected values for callback when a thread is\n- *     about to wait on an object.\n- * COMMENTS\n- *     The test updated to match new JVMTI spec 0.2.90:\n- *     - change signature of agentProc function\n- *       and save JNIEnv pointer now passed as argument.\n- *\n- * @library \/vmTestbase\n- *          \/test\/lib\n- * @run main\/othervm\/native\n- *      -agentlib:monitorwait001=-waittime=5\n- *      nsk.jvmti.MonitorWait.monitorwait001\n- *      -waittime=5\n- *\/\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/MonitorWait\/monitorwait001\/TestDescription.java","additions":0,"deletions":49,"binary":false,"changes":49,"status":"deleted"},{"patch":"@@ -1,33 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include \"native_thread.cpp\"\n-#include \"nsk_tools.cpp\"\n-#include \"jni_tools.cpp\"\n-#include \"jvmti_tools.cpp\"\n-#include \"agent_tools.cpp\"\n-#include \"jvmti_FollowRefObjects.cpp\"\n-#include \"Injector.cpp\"\n-#include \"JVMTITools.cpp\"\n-#include \"agent_common.cpp\"\n-#include \"monitorwait001.cpp\"\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/MonitorWait\/monitorwait001\/libmonitorwait001.cpp","additions":0,"deletions":33,"binary":false,"changes":33,"status":"deleted"},{"patch":"@@ -1,252 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include <stdio.h>\n-#include <string.h>\n-#include \"jni_tools.h\"\n-#include \"agent_common.h\"\n-#include \"jvmti_tools.h\"\n-\n-extern \"C\" {\n-\n-\/* ========================================================================== *\/\n-\n-\/* scaffold objects *\/\n-static JNIEnv* jni = NULL;\n-static jvmtiEnv *jvmti = NULL;\n-static jlong timeout = 0;\n-\n-\/* test objects *\/\n-static jthread thread = NULL;\n-static jobject object = NULL;\n-static volatile int eventsCount = 0;\n-\n-\/* ========================================================================== *\/\n-\n-void JNICALL\n-MonitorWait(jvmtiEnv *jvmti, JNIEnv* jni, jthread thr, jobject obj, jlong tout) {\n-\n-    NSK_DISPLAY3(\"MonitorWait event:\\n\\tthread: %p, object: %p, timeout: %ld\\n\",\n-        thr, obj, (int)tout);\n-\n-    if (!NSK_VERIFY(thread != NULL)) {\n-        nsk_jvmti_setFailStatus();\n-        return;\n-    }\n-\n-    \/* check if event is for tested thread and for tested object *\/\n-    if (jni->IsSameObject(thread, thr) &&\n-            jni->IsSameObject(object, obj)) {\n-        eventsCount++;\n-        if (tout != timeout) {\n-            NSK_COMPLAIN1(\"Unexpected timeout value: %d\\n\", (int)tout);\n-            nsk_jvmti_setFailStatus();\n-        }\n-    }\n-}\n-\n-\/* ========================================================================== *\/\n-\n-static int prepare() {\n-    const char* THREAD_NAME = \"Debuggee Thread\";\n-    jclass klass = NULL;\n-    jfieldID field = NULL;\n-    jvmtiThreadInfo info;\n-    jthread *threads = NULL;\n-    jint threads_count = 0;\n-    int i;\n-\n-    NSK_DISPLAY0(\"Prepare: find tested thread\\n\");\n-\n-    \/* get all live threads *\/\n-    if (!NSK_JVMTI_VERIFY(jvmti->GetAllThreads(&threads_count, &threads)))\n-        return NSK_FALSE;\n-\n-    if (!NSK_VERIFY(threads_count > 0 && threads != NULL))\n-        return NSK_FALSE;\n-\n-    \/* find tested thread *\/\n-    for (i = 0; i < threads_count; i++) {\n-        if (!NSK_VERIFY(threads[i] != NULL))\n-            return NSK_FALSE;\n-\n-        \/* get thread information *\/\n-        if (!NSK_JVMTI_VERIFY(jvmti->GetThreadInfo(threads[i], &info)))\n-            return NSK_FALSE;\n-\n-        NSK_DISPLAY3(\"    thread #%d (%s): %p\\n\", i, info.name, threads[i]);\n-\n-        \/* find by name *\/\n-        if (info.name != NULL && (strcmp(info.name, THREAD_NAME) == 0)) {\n-            thread = threads[i];\n-        }\n-    }\n-\n-    \/* deallocate threads list *\/\n-    if (!NSK_JVMTI_VERIFY(jvmti->Deallocate((unsigned char*)threads)))\n-        return NSK_FALSE;\n-\n-    if (thread == NULL) {\n-        NSK_COMPLAIN0(\"Debuggee thread not found\");\n-        return NSK_FALSE;\n-    }\n-\n-    \/* make thread accessable for a long time *\/\n-    if (!NSK_JNI_VERIFY(jni, (thread = jni->NewGlobalRef(thread)) != NULL))\n-        return NSK_FALSE;\n-\n-    \/* get tested thread class *\/\n-    if (!NSK_JNI_VERIFY(jni, (klass = jni->GetObjectClass(thread)) != NULL))\n-        return NSK_FALSE;\n-\n-    \/* get tested thread field 'waitingMonitor' *\/\n-    if (!NSK_JNI_VERIFY(jni, (field =\n-            jni->GetFieldID(klass, \"waitingMonitor\", \"Ljava\/lang\/Object;\")) != NULL))\n-        return NSK_FALSE;\n-\n-    \/* get 'waitingMonitor' object *\/\n-    if (!NSK_JNI_VERIFY(jni, (object = jni->GetObjectField(thread, field)) != NULL))\n-        return NSK_FALSE;\n-\n-    \/* make object accessable for a long time *\/\n-    if (!NSK_JNI_VERIFY(jni, (object = jni->NewGlobalRef(object)) != NULL))\n-        return NSK_FALSE;\n-\n-    \/* enable MonitorWait event *\/\n-    if (!NSK_JVMTI_VERIFY(\n-            jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_MONITOR_WAIT, NULL)))\n-        return NSK_FALSE;\n-\n-    return NSK_TRUE;\n-}\n-\n-static int clean() {\n-\n-    \/* disable MonitorWait event *\/\n-    if (!NSK_JVMTI_VERIFY(\n-            jvmti->SetEventNotificationMode(JVMTI_DISABLE, JVMTI_EVENT_MONITOR_WAIT, NULL)))\n-        nsk_jvmti_setFailStatus();\n-\n-    return NSK_TRUE;\n-}\n-\n-\/* ========================================================================== *\/\n-\n-\/* agent algorithm\n- *\/\n-static void JNICALL\n-agentProc(jvmtiEnv* jvmti, JNIEnv* agentJNI, void* arg) {\n-    jni = agentJNI;\n-\n-    \/* wait for initial sync *\/\n-    if (!nsk_jvmti_waitForSync(timeout))\n-        return;\n-\n-    if (!prepare()) {\n-        nsk_jvmti_setFailStatus();\n-        return;\n-    }\n-\n-    \/* clear events count *\/\n-    eventsCount = 0;\n-\n-    \/* resume debugee to catch MonitorWait event *\/\n-    if (!(NSK_VERIFY(nsk_jvmti_resumeSync()) &&\n-          NSK_VERIFY(nsk_jvmti_waitForSync(timeout))))\n-        return;\n-\n-    NSK_DISPLAY1(\"Number of MonitorWait events: %d\\n\", eventsCount);\n-\n-    if (eventsCount == 0) {\n-        NSK_COMPLAIN0(\"No any MonitorWait event\\n\");\n-        nsk_jvmti_setFailStatus();\n-    }\n-\n-    if (!clean()) {\n-        nsk_jvmti_setFailStatus();\n-        return;\n-    }\n-\n-    \/* resume debugee after last sync *\/\n-    if (!nsk_jvmti_resumeSync())\n-        return;\n-}\n-\n-\/* ========================================================================== *\/\n-\n-\/* agent library initialization\n- *\/\n-#ifdef STATIC_BUILD\n-JNIEXPORT jint JNICALL Agent_OnLoad_monitorwait001(JavaVM *jvm, char *options, void *reserved) {\n-    return Agent_Initialize(jvm, options, reserved);\n-}\n-JNIEXPORT jint JNICALL Agent_OnAttach_monitorwait001(JavaVM *jvm, char *options, void *reserved) {\n-    return Agent_Initialize(jvm, options, reserved);\n-}\n-JNIEXPORT jint JNI_OnLoad_monitorwait001(JavaVM *jvm, char *options, void *reserved) {\n-    return JNI_VERSION_1_8;\n-}\n-#endif\n-jint Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {\n-    jvmtiCapabilities caps;\n-    jvmtiEventCallbacks callbacks;\n-\n-    \/* init framework and parse options *\/\n-    if (!NSK_VERIFY(nsk_jvmti_parseOptions(options)))\n-        return JNI_ERR;\n-\n-    timeout = nsk_jvmti_getWaitTime() * 60000;\n-    NSK_DISPLAY1(\"Timeout: %d msc\\n\", (int)timeout);\n-\n-    \/* create JVMTI environment *\/\n-    if (!NSK_VERIFY((jvmti =\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n-        return JNI_ERR;\n-\n-    if (!NSK_JVMTI_VERIFY(jvmti->GetPotentialCapabilities(&caps)))\n-        return JNI_ERR;\n-\n-    if (!NSK_JVMTI_VERIFY(jvmti->AddCapabilities(&caps)))\n-        return JNI_ERR;\n-\n-    if (!NSK_JVMTI_VERIFY(jvmti->GetCapabilities(&caps)))\n-        return JNI_ERR;\n-\n-    if (!NSK_VERIFY(caps.can_generate_monitor_events))\n-        return JNI_ERR;\n-\n-    memset(&callbacks, 0, sizeof(callbacks));\n-    callbacks.MonitorWait = &MonitorWait;\n-    if (!NSK_JVMTI_VERIFY(jvmti->SetEventCallbacks(&callbacks, sizeof(callbacks))))\n-        return JNI_ERR;\n-\n-    \/* register agent proc and arg *\/\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n-        return JNI_ERR;\n-\n-    return JNI_OK;\n-}\n-\n-\/* ========================================================================== *\/\n-\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/MonitorWait\/monitorwait001\/monitorwait001.cpp","additions":0,"deletions":252,"binary":false,"changes":252,"status":"deleted"},{"patch":"@@ -1,131 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package nsk.jvmti.MonitorWaited;\n-\n-import java.io.PrintStream;\n-\n-import nsk.share.*;\n-import nsk.share.jvmti.*;\n-\n-public class monitorwaited001 extends DebugeeClass {\n-\n-    \/\/ load native library if required\n-    static {\n-        loadLibrary(\"monitorwaited001\");\n-    }\n-\n-    \/\/ run test from command line\n-    public static void main(String argv[]) {\n-        argv = nsk.share.jvmti.JVMTITest.commonInit(argv);\n-\n-        \/\/ JCK-compatible exit\n-        System.exit(run(argv, System.out) + Consts.JCK_STATUS_BASE);\n-    }\n-\n-    \/\/ run test from JCK-compatible environment\n-    public static int run(String argv[], PrintStream out) {\n-        return new monitorwaited001().runIt(argv, out);\n-    }\n-\n-    \/* =================================================================== *\/\n-\n-    \/\/ scaffold objects\n-    ArgumentHandler argHandler = null;\n-    Log log = null;\n-    int status = Consts.TEST_PASSED;\n-    static long timeout = 0;\n-\n-    \/\/ tested thread\n-    monitorwaited001Thread thread = null;\n-\n-    \/\/ run debuggee\n-    public int runIt(String argv[], PrintStream out) {\n-        argHandler = new ArgumentHandler(argv);\n-        log = new Log(out, argHandler);\n-        timeout = argHandler.getWaitTime() * 60000; \/\/ milliseconds\n-        log.display(\"Timeout = \" + timeout + \" msc.\");\n-\n-        thread = new monitorwaited001Thread(\"Debuggee Thread\");\n-\n-        \/\/ run thread\n-        try {\n-            \/\/ start thread\n-            synchronized (thread.startingMonitor) {\n-                thread.start();\n-                thread.startingMonitor.wait(timeout);\n-            }\n-        } catch (InterruptedException e) {\n-            throw new Failure(e);\n-        }\n-\n-        Thread.yield();\n-        log.display(\"Thread started\");\n-\n-        synchronized (thread.waitingMonitor) {\n-            thread.waitingMonitor.notify();\n-        }\n-\n-        \/\/ wait for thread finish\n-        try {\n-            thread.join(timeout);\n-        } catch (InterruptedException e) {\n-            throw new Failure(e);\n-        }\n-\n-        log.display(\"Sync: thread finished\");\n-        status = checkStatus(status);\n-\n-        return status;\n-    }\n-}\n-\n-\/* =================================================================== *\/\n-\n-class monitorwaited001Thread extends Thread {\n-    public Object startingMonitor = new Object();\n-    public Object waitingMonitor = new Object();\n-\n-    public monitorwaited001Thread(String name) {\n-        super(name);\n-    }\n-\n-    public void run() {\n-        synchronized (waitingMonitor) {\n-\n-            monitorwaited001.checkStatus(Consts.TEST_PASSED);\n-\n-            \/\/ notify about starting\n-            synchronized (startingMonitor) {\n-                startingMonitor.notify();\n-            }\n-\n-            \/\/ wait until main thread notify\n-            try {\n-                waitingMonitor.wait(monitorwaited001.timeout);\n-            } catch (InterruptedException e) {\n-                throw new Failure(e);\n-            }\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/MonitorWaited\/monitorwaited001.java","additions":0,"deletions":131,"binary":false,"changes":131,"status":"deleted"},{"patch":"@@ -1,48 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/*\n- * @test\n- *\n- * @summary converted from VM Testbase nsk\/jvmti\/MonitorWaited\/monitorwaited001.\n- * VM Testbase keywords: [quick, jpda, jvmti, noras]\n- * VM Testbase readme:\n- * DESCRIPTION\n- *     The test exercises JVMTI event callback function\n- *         MonitorWaited(jni_env, thread, object, timed_out).\n- *     The test checks if the thread, object, and timed_out parameters of\n- *     the function contain expected values for callback when a thread finishes\n- *     waiting on an object.\n- * COMMENTS\n- *     The test updated to match new JVMTI spec 0.2.90:\n- *     - change signature of agentProc function\n- *       and save JNIEnv pointer now passed as argument.\n- *\n- * @library \/vmTestbase\n- *          \/test\/lib\n- * @run main\/othervm\/native\n- *      -agentlib:monitorwaited001=-waittime=5\n- *      nsk.jvmti.MonitorWaited.monitorwaited001\n- *\/\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/MonitorWaited\/monitorwaited001\/TestDescription.java","additions":0,"deletions":48,"binary":false,"changes":48,"status":"deleted"},{"patch":"@@ -1,33 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include \"native_thread.cpp\"\n-#include \"nsk_tools.cpp\"\n-#include \"jni_tools.cpp\"\n-#include \"jvmti_tools.cpp\"\n-#include \"agent_tools.cpp\"\n-#include \"jvmti_FollowRefObjects.cpp\"\n-#include \"Injector.cpp\"\n-#include \"JVMTITools.cpp\"\n-#include \"agent_common.cpp\"\n-#include \"monitorwaited001.cpp\"\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/MonitorWaited\/monitorwaited001\/libmonitorwaited001.cpp","additions":0,"deletions":33,"binary":false,"changes":33,"status":"deleted"},{"patch":"@@ -1,253 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include <stdio.h>\n-#include <string.h>\n-#include \"jni_tools.h\"\n-#include \"agent_common.h\"\n-#include \"jvmti_tools.h\"\n-\n-extern \"C\" {\n-\n-\/* ========================================================================== *\/\n-\n-\/* scaffold objects *\/\n-static JNIEnv* jni = NULL;\n-static jvmtiEnv *jvmti = NULL;\n-static jlong timeout = 0;\n-\n-\/* test objects *\/\n-static jthread thread = NULL;\n-static jobject object = NULL;\n-static volatile int eventsCount = 0;\n-\n-\/* ========================================================================== *\/\n-\n-void JNICALL\n-MonitorWaited(jvmtiEnv *jvmti, JNIEnv* jni,\n-        jthread thr, jobject obj, jboolean timed_out) {\n-\n-    NSK_DISPLAY3(\"MonitorWaited event:\\n\\tthread: %p, object: %p, timed_out: %s\\n\",\n-        thr, obj, (timed_out == JNI_TRUE) ? \"true\" : \"false\");\n-\n-    if (!NSK_VERIFY(thread != NULL)) {\n-        nsk_jvmti_setFailStatus();\n-        return;\n-    }\n-\n-    \/* check if event is for tested thread and for tested object *\/\n-    if (jni->IsSameObject(thread, thr) &&\n-            jni->IsSameObject(object, obj)) {\n-        eventsCount++;\n-        if (timed_out == JNI_TRUE) {\n-            NSK_COMPLAIN0(\"Unexpected timed_out value: true\\n\");\n-            nsk_jvmti_setFailStatus();\n-        }\n-    }\n-}\n-\n-\/* ========================================================================== *\/\n-\n-static int prepare() {\n-    const char* THREAD_NAME = \"Debuggee Thread\";\n-    jclass klass = NULL;\n-    jfieldID field = NULL;\n-    jvmtiThreadInfo info;\n-    jthread *threads = NULL;\n-    jint threads_count = 0;\n-    int i;\n-\n-    NSK_DISPLAY0(\"Prepare: find tested thread\\n\");\n-\n-    \/* get all live threads *\/\n-    if (!NSK_JVMTI_VERIFY(jvmti->GetAllThreads(&threads_count, &threads)))\n-        return NSK_FALSE;\n-\n-    if (!NSK_VERIFY(threads_count > 0 && threads != NULL))\n-        return NSK_FALSE;\n-\n-    \/* find tested thread *\/\n-    for (i = 0; i < threads_count; i++) {\n-        if (!NSK_VERIFY(threads[i] != NULL))\n-            return NSK_FALSE;\n-\n-        \/* get thread information *\/\n-        if (!NSK_JVMTI_VERIFY(jvmti->GetThreadInfo(threads[i], &info)))\n-            return NSK_FALSE;\n-\n-        NSK_DISPLAY3(\"    thread #%d (%s): %p\\n\", i, info.name, threads[i]);\n-\n-        \/* find by name *\/\n-        if (info.name != NULL && (strcmp(info.name, THREAD_NAME) == 0)) {\n-            thread = threads[i];\n-        }\n-    }\n-\n-    \/* deallocate threads list *\/\n-    if (!NSK_JVMTI_VERIFY(jvmti->Deallocate((unsigned char*)threads)))\n-        return NSK_FALSE;\n-\n-    if (thread == NULL) {\n-        NSK_COMPLAIN0(\"Debuggee thread not found\");\n-        return NSK_FALSE;\n-    }\n-\n-    \/* make thread accessable for a long time *\/\n-    if (!NSK_JNI_VERIFY(jni, (thread = jni->NewGlobalRef(thread)) != NULL))\n-        return NSK_FALSE;\n-\n-    \/* get tested thread class *\/\n-    if (!NSK_JNI_VERIFY(jni, (klass = jni->GetObjectClass(thread)) != NULL))\n-        return NSK_FALSE;\n-\n-    \/* get tested thread field 'waitingMonitor' *\/\n-    if (!NSK_JNI_VERIFY(jni, (field =\n-            jni->GetFieldID(klass, \"waitingMonitor\", \"Ljava\/lang\/Object;\")) != NULL))\n-        return NSK_FALSE;\n-\n-    \/* get 'waitingMonitor' object *\/\n-    if (!NSK_JNI_VERIFY(jni, (object = jni->GetObjectField(thread, field)) != NULL))\n-        return NSK_FALSE;\n-\n-    \/* make object accessable for a long time *\/\n-    if (!NSK_JNI_VERIFY(jni, (object = jni->NewGlobalRef(object)) != NULL))\n-        return NSK_FALSE;\n-\n-    \/* enable MonitorWaited event *\/\n-    if (!NSK_JVMTI_VERIFY(\n-            jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_MONITOR_WAITED, NULL)))\n-        return NSK_FALSE;\n-\n-    return NSK_TRUE;\n-}\n-\n-static int clean() {\n-\n-    \/* disable MonitorWaited event *\/\n-    if (!NSK_JVMTI_VERIFY(\n-            jvmti->SetEventNotificationMode(JVMTI_DISABLE, JVMTI_EVENT_MONITOR_WAITED, NULL)))\n-        nsk_jvmti_setFailStatus();\n-\n-    return NSK_TRUE;\n-}\n-\n-\/* ========================================================================== *\/\n-\n-\/* agent algorithm\n- *\/\n-static void JNICALL\n-agentProc(jvmtiEnv* jvmti, JNIEnv* agentJNI, void* arg) {\n-    jni = agentJNI;\n-\n-    \/* wait for initial sync *\/\n-    if (!nsk_jvmti_waitForSync(timeout))\n-        return;\n-\n-    if (!prepare()) {\n-        nsk_jvmti_setFailStatus();\n-        return;\n-    }\n-\n-    \/* clear events count *\/\n-    eventsCount = 0;\n-\n-    \/* resume debugee to catch MonitorWaited event *\/\n-    if (!(NSK_VERIFY(nsk_jvmti_resumeSync()) &&\n-          NSK_VERIFY(nsk_jvmti_waitForSync(timeout))))\n-        return;\n-\n-    NSK_DISPLAY1(\"Number of MonitorWaited events: %d\\n\", eventsCount);\n-\n-    if (eventsCount == 0) {\n-        NSK_COMPLAIN0(\"No any MonitorWaited event\\n\");\n-        nsk_jvmti_setFailStatus();\n-    }\n-\n-    if (!clean()) {\n-        nsk_jvmti_setFailStatus();\n-        return;\n-    }\n-\n-    \/* resume debugee after last sync *\/\n-    if (!nsk_jvmti_resumeSync())\n-        return;\n-}\n-\n-\/* ========================================================================== *\/\n-\n-\/* agent library initialization\n- *\/\n-#ifdef STATIC_BUILD\n-JNIEXPORT jint JNICALL Agent_OnLoad_monitorwaited001(JavaVM *jvm, char *options, void *reserved) {\n-    return Agent_Initialize(jvm, options, reserved);\n-}\n-JNIEXPORT jint JNICALL Agent_OnAttach_monitorwaited001(JavaVM *jvm, char *options, void *reserved) {\n-    return Agent_Initialize(jvm, options, reserved);\n-}\n-JNIEXPORT jint JNI_OnLoad_monitorwaited001(JavaVM *jvm, char *options, void *reserved) {\n-    return JNI_VERSION_1_8;\n-}\n-#endif\n-jint Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {\n-    jvmtiCapabilities caps;\n-    jvmtiEventCallbacks callbacks;\n-\n-    \/* init framework and parse options *\/\n-    if (!NSK_VERIFY(nsk_jvmti_parseOptions(options)))\n-        return JNI_ERR;\n-\n-    timeout = nsk_jvmti_getWaitTime() * 60000;\n-    NSK_DISPLAY1(\"Timeout: %d msc\\n\", (int)timeout);\n-\n-    \/* create JVMTI environment *\/\n-    if (!NSK_VERIFY((jvmti =\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n-        return JNI_ERR;\n-\n-    if (!NSK_JVMTI_VERIFY(jvmti->GetPotentialCapabilities(&caps)))\n-        return JNI_ERR;\n-\n-    if (!NSK_JVMTI_VERIFY(jvmti->AddCapabilities(&caps)))\n-        return JNI_ERR;\n-\n-    if (!NSK_JVMTI_VERIFY(jvmti->GetCapabilities(&caps)))\n-        return JNI_ERR;\n-\n-    if (!NSK_VERIFY(caps.can_generate_monitor_events))\n-        return JNI_ERR;\n-\n-    memset(&callbacks, 0, sizeof(callbacks));\n-    callbacks.MonitorWaited = &MonitorWaited;\n-    if (!NSK_JVMTI_VERIFY(jvmti->SetEventCallbacks(&callbacks, sizeof(callbacks))))\n-        return JNI_ERR;\n-\n-    \/* register agent proc and arg *\/\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n-        return JNI_ERR;\n-\n-    return JNI_OK;\n-}\n-\n-\/* ========================================================================== *\/\n-\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/MonitorWaited\/monitorwaited001\/monitorwaited001.cpp","additions":0,"deletions":253,"binary":false,"changes":253,"status":"deleted"},{"patch":"@@ -1,96 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package nsk.jvmti.NativeMethodBind;\n-\n-import java.io.*;\n-\n-import nsk.share.*;\n-import nsk.share.jvmti.*;\n-\n-\/**\n- * This test exercises the JVMTI event <code>NativeMethodBind<\/code>.\n- * <br>It verifies that the event will be properly sent:\n- * <li>for the native method called for the first time\n- * <li>when the JNI RegisterNatives() is called.<p>\n- * The test works as follows. The java part invokes the native method\n- * <code>nativeMethod()<\/code> twice. At the first time that method\n- * registers another native method <code>anotherNativeMethod()<\/code> for\n- * the dummy class <code>TestedClass<\/code>. Registration is made through\n- * the JNI RegisterNatives() call. Being invoked at the second time, the\n- * nativeMethod() just returns.<br>\n- * In accordance with the spec, it is expected that the NativeMethodBind\n- * will be generated only one time for the nativeMethod(), and only one\n- * time for the anotherNativeMethod().\n- *\/\n-public class nativemethbind001 {\n-    static {\n-        try {\n-            System.loadLibrary(\"nativemethbind001\");\n-        } catch (UnsatisfiedLinkError ule) {\n-            System.err.println(\"Could not load \\\"nativemethbind001\\\" library\");\n-            System.err.println(\"java.library.path:\"\n-                + System.getProperty(\"java.library.path\"));\n-            throw ule;\n-        }\n-    }\n-\n-    native void nativeMethod(boolean registerNative);\n-\n-    native int check();\n-\n-    public static void main(String[] argv) {\n-        argv = nsk.share.jvmti.JVMTITest.commonInit(argv);\n-\n-        \/\/ produce JCK-like exit status\n-        System.exit(run(argv, System.out) + Consts.JCK_STATUS_BASE);\n-    }\n-\n-    public static int run(String argv[], PrintStream out) {\n-        return new nativemethbind001().runThis(argv, out);\n-    }\n-\n-    private int runThis(String argv[], PrintStream out) {\n-        ArgumentHandler argHandler = new ArgumentHandler(argv);\n-        Log log = new Log(out, argHandler);\n-\n-        log.display(\"\\nCalling native methods ...\\n\");\n-\n-        \/\/ dummy method used to provoke the NativeMethodBind event\n-        nativeMethod(true);\n-\n-        \/\/ call one more time to provoke the wrong NativeMethodBind\n-        \/\/ event\n-        nativeMethod(false);\n-\n-        return check();\n-    }\n-\n-   \/**\n-    * Dummy class used only to register native method\n-    * <code>anotherNativeMethod<\/code> with it\n-    *\/\n-    class TestedClass {\n-        native void anotherNativeMethod();\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/NativeMethodBind\/nativemethbind001.java","additions":0,"deletions":96,"binary":false,"changes":96,"status":"deleted"},{"patch":"@@ -1,54 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/*\n- * @test\n- *\n- * @summary converted from VM Testbase nsk\/jvmti\/NativeMethodBind\/nativemethbind001.\n- * VM Testbase keywords: [quick, jpda, jvmti, noras]\n- * VM Testbase readme:\n- * DESCRIPTION\n- *     This test exercises the JVMTI event NativeMethodBind.\n- *     It verifies that the event will be properly sent:\n- *         - for the native method called for the first time\n- *         - when the JNI RegisterNatives() is called.\n- *     The test works as follows. The java part invokes the native method\n- *     'nativeMethod()' twice. At the first time that method registers\n- *     another native method 'anotherNativeMethod()' for the dummy class\n- *     'TestedClass'. Registration is made through the JNI RegisterNatives()\n- *     call. Being invoked at the second time, the nativeMethod() just returns.\n- *     In accordance with the spec, it is expected that the NativeMethodBind\n- *     will be generated only one time for the nativeMethod(), and only one\n- *     time for the anotherNativeMethod().\n- * COMMENTS\n- *     The test has been fixed due to the bug 4967116.\n- *     Fixed the 4995867 bug.\n- *\n- * @library \/vmTestbase\n- *          \/test\/lib\n- * @run main\/othervm\/native\n- *      -agentlib:nativemethbind001=-waittime=5\n- *      nsk.jvmti.NativeMethodBind.nativemethbind001\n- *\/\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/NativeMethodBind\/nativemethbind001\/TestDescription.java","additions":0,"deletions":54,"binary":false,"changes":54,"status":"deleted"},{"patch":"@@ -1,33 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include \"native_thread.cpp\"\n-#include \"nsk_tools.cpp\"\n-#include \"jni_tools.cpp\"\n-#include \"jvmti_tools.cpp\"\n-#include \"agent_tools.cpp\"\n-#include \"jvmti_FollowRefObjects.cpp\"\n-#include \"Injector.cpp\"\n-#include \"JVMTITools.cpp\"\n-#include \"agent_common.cpp\"\n-#include \"nativemethbind001.cpp\"\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/NativeMethodBind\/nativemethbind001\/libnativemethbind001.cpp","additions":0,"deletions":33,"binary":false,"changes":33,"status":"deleted"},{"patch":"@@ -1,246 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include <stdio.h>\n-#include <string.h>\n-#include <jvmti.h>\n-#include \"agent_common.h\"\n-\n-#include \"nsk_tools.h\"\n-#include \"JVMTITools.h\"\n-#include \"jvmti_tools.h\"\n-#include \"jni_tools.h\"\n-\n-extern \"C\" {\n-\n-#define STATUS_FAILED 2\n-#define PASSED 0\n-\n-\/* tested methods *\/\n-#define METH_NUM 2\n-static const char *METHODS[][2] = {\n-    { \"nativeMethod\", \"(Z)V\" },\n-    { \"anotherNativeMethod\", \"()V\" },\n-};\n-\n-\/* event counters for the tested methods and expected numbers\n-   of the events *\/\n-static volatile int bindEv[][2] = {\n-    { 0, 1 },\n-    { 0, 1 }\n-};\n-\n-static const char *CLASS_SIG =\n-    \"Lnsk\/jvmti\/NativeMethodBind\/nativemethbind001$TestedClass;\";\n-\n-static volatile jint result = PASSED;\n-static jvmtiEnv *jvmti = NULL;\n-static jvmtiEventCallbacks callbacks;\n-static jrawMonitorID countLock;\n-\n-static void lock(jvmtiEnv *jvmti_env, JNIEnv *jni_env) {\n-    if (!NSK_JVMTI_VERIFY(jvmti_env->RawMonitorEnter(countLock)))\n-        jni_env->FatalError(\"failed to enter a raw monitor\\n\");\n-}\n-\n-static void unlock(jvmtiEnv *jvmti_env, JNIEnv *jni_env) {\n-    if (!NSK_JVMTI_VERIFY(jvmti_env->RawMonitorExit(countLock)))\n-        jni_env->FatalError(\"failed to exit a raw monitor\\n\");\n-}\n-\n-\/** callback functions **\/\n-void JNICALL\n-NativeMethodBind(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,\n-        jmethodID method, void *addr, void **new_addr) {\n-    jvmtiPhase phase;\n-    char *methNam, *methSig;\n-    int i;\n-\n-    lock(jvmti_env, jni_env);\n-\n-    NSK_DISPLAY0(\">>>> NativeMethodBind event received\\n\");\n-\n-    if (!NSK_JVMTI_VERIFY(jvmti_env->GetPhase(&phase))) {\n-        result = STATUS_FAILED;\n-        unlock(jvmti_env, jni_env);\n-        return;\n-    }\n-\n-    if (phase != JVMTI_PHASE_START && phase != JVMTI_PHASE_LIVE) {\n-        unlock(jvmti_env, jni_env);\n-        return;\n-    }\n-\n-    if (!NSK_JVMTI_VERIFY(jvmti_env->GetMethodName(method, &methNam, &methSig, NULL))) {\n-        result = STATUS_FAILED;\n-        NSK_COMPLAIN0(\"TEST FAILED: unable to get method name during NativeMethodBind callback\\n\\n\");\n-        unlock(jvmti_env, jni_env);\n-        return;\n-    }\n-\n-    NSK_DISPLAY2(\"method: \\\"%s %s\\\"\\n\", methNam, methSig);\n-\n-    for (i=0; i<METH_NUM; i++) {\n-        if ((strcmp(methNam,METHODS[i][0]) == 0) &&\n-                (strcmp(methSig,METHODS[i][1]) == 0)) {\n-            bindEv[i][0]++;\n-\n-            NSK_DISPLAY1(\n-                \"CHECK PASSED: NativeMethodBind event received for the method:\\n\"\n-                \"\\t\\\"%s\\\" as expected\\n\",\n-                methNam);\n-            break;\n-        }\n-    }\n-\n-    if (!NSK_JVMTI_VERIFY(jvmti_env->Deallocate((unsigned char*) methNam))) {\n-        result = STATUS_FAILED;\n-        NSK_COMPLAIN0(\"TEST FAILED: unable to deallocate memory pointed to method name\\n\\n\");\n-    }\n-    if (!NSK_JVMTI_VERIFY(jvmti_env->Deallocate((unsigned char*) methSig))) {\n-        result = STATUS_FAILED;\n-        NSK_COMPLAIN0(\"TEST FAILED: unable to deallocate memory pointed to method signature\\n\\n\");\n-    }\n-\n-    NSK_DISPLAY0(\"<<<<\\n\\n\");\n-\n-    unlock(jvmti_env, jni_env);\n-}\n-\/************************\/\n-\n-\/* dummy method used only to provoke NativeMethodBind event *\/\n-static void JNICALL\n-anotherNativeMethod(JNIEnv *env, jobject obj) {\n-    NSK_DISPLAY0(\"inside the anotherNativeMethod()\\n\");\n-}\n-\n-\/* dummy method used only to provoke NativeMethodBind event *\/\n-JNIEXPORT void JNICALL\n-Java_nsk_jvmti_NativeMethodBind_nativemethbind001_nativeMethod(\n-        JNIEnv *env, jobject obj, jboolean registerNative) {\n-    jclass testedCls = NULL;\n-    JNINativeMethod meth;\n-\n-    NSK_DISPLAY0(\"Inside the nativeMethod()\\n\");\n-\n-    if (registerNative == JNI_TRUE) {\n-        NSK_DISPLAY1(\"Finding class \\\"%s\\\" ...\\n\", CLASS_SIG);\n-        if (!NSK_JNI_VERIFY(env, (testedCls = env->FindClass(CLASS_SIG)) != NULL)) {\n-            result = STATUS_FAILED;\n-            NSK_COMPLAIN1(\"TEST FAILURE: unable to find class \\\"%s\\\"\\n\\n\",\n-                CLASS_SIG);\n-            return;\n-        }\n-\n-        meth.name = (char *) METHODS[1][0];\n-        meth.signature = (char *) METHODS[1][1];\n-        meth.fnPtr = (void *) &anotherNativeMethod;\n-\n-        NSK_DISPLAY3(\"Calling RegisterNatives() with \\\"%s %s\\\"\\n\"\n-                     \"\\tfor class \\\"%s\\\" ...\\n\",\n-            METHODS[1][0], METHODS[1][1], CLASS_SIG);\n-        if (!NSK_JNI_VERIFY_VOID(env, (env->RegisterNatives(testedCls, &meth, 1)) != 0)) {\n-            result = STATUS_FAILED;\n-            NSK_COMPLAIN3(\"TEST FAILURE: unable to RegisterNatives() \\\"%s %s\\\" for class \\\"%s\\\"\\n\\n\",\n-                METHODS[1][0], METHODS[1][1], CLASS_SIG);\n-        }\n-    }\n-}\n-\n-JNIEXPORT jint JNICALL\n-Java_nsk_jvmti_NativeMethodBind_nativemethbind001_check(\n-        JNIEnv *env, jobject obj) {\n-    int i;\n-\n-    for (i=0; i<METH_NUM; i++)\n-        if (bindEv[i][0] == bindEv[i][1]) {\n-            NSK_DISPLAY2(\"CHECK PASSED: %d NativeMethodBind event(s) for the method \\\"%s\\\" as expected\\n\",\n-                bindEv[i][0], METHODS[i][0]);\n-        }\n-        else {\n-            result = STATUS_FAILED;\n-            NSK_COMPLAIN3(\n-                \"TEST FAILED: wrong number of NativeMethodBind events for the method \\\"%s\\\":\\n\"\n-                \"got: %d\\texpected: %d\\n\\n\",\n-                METHODS[i][0], bindEv[i][0], bindEv[i][1]);\n-        }\n-\n-    return result;\n-}\n-\n-#ifdef STATIC_BUILD\n-JNIEXPORT jint JNICALL Agent_OnLoad_nativemethbind001(JavaVM *jvm, char *options, void *reserved) {\n-    return Agent_Initialize(jvm, options, reserved);\n-}\n-JNIEXPORT jint JNICALL Agent_OnAttach_nativemethbind001(JavaVM *jvm, char *options, void *reserved) {\n-    return Agent_Initialize(jvm, options, reserved);\n-}\n-JNIEXPORT jint JNI_OnLoad_nativemethbind001(JavaVM *jvm, char *options, void *reserved) {\n-    return JNI_VERSION_1_8;\n-}\n-#endif\n-jint Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {\n-    jvmtiCapabilities caps;\n-\n-    \/* init framework and parse options *\/\n-    if (!NSK_VERIFY(nsk_jvmti_parseOptions(options)))\n-        return JNI_ERR;\n-\n-    \/* create JVMTI environment *\/\n-    if (!NSK_VERIFY((jvmti =\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n-        return JNI_ERR;\n-\n-    \/* create a raw monitor *\/\n-    if (!NSK_JVMTI_VERIFY(jvmti->CreateRawMonitor(\"_counter_lock\", &countLock)))\n-        return JNI_ERR;\n-\n-    \/* add capability to generate compiled method events *\/\n-    memset(&caps, 0, sizeof(jvmtiCapabilities));\n-    caps.can_generate_native_method_bind_events = 1;\n-    if (!NSK_JVMTI_VERIFY(jvmti->AddCapabilities(&caps)))\n-        return JNI_ERR;\n-\n-    if (!NSK_JVMTI_VERIFY(jvmti->GetCapabilities(&caps)))\n-        return JNI_ERR;\n-    if (!caps.can_generate_native_method_bind_events)\n-        NSK_DISPLAY0(\"Warning: generation of native method bind events is not implemented\\n\");\n-\n-    \/* set event callback *\/\n-    NSK_DISPLAY0(\"setting event callbacks ...\\n\");\n-    (void) memset(&callbacks, 0, sizeof(callbacks));\n-    callbacks.NativeMethodBind = &NativeMethodBind;\n-    if (!NSK_JVMTI_VERIFY(jvmti->SetEventCallbacks(&callbacks, sizeof(callbacks))))\n-        return JNI_ERR;\n-\n-    NSK_DISPLAY0(\"setting event callbacks done\\nenabling JVMTI events ...\\n\");\n-    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE,\n-                                                          JVMTI_EVENT_NATIVE_METHOD_BIND,\n-                                                          NULL)))\n-        return JNI_ERR;\n-    NSK_DISPLAY0(\"enabling the events done\\n\\n\");\n-\n-    return JNI_OK;\n-}\n-\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/NativeMethodBind\/nativemethbind001\/nativemethbind001.cpp","additions":0,"deletions":246,"binary":false,"changes":246,"status":"deleted"},{"patch":"@@ -1,76 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package nsk.jvmti.NativeMethodBind;\n-\n-import java.io.*;\n-\n-import nsk.share.*;\n-import nsk.share.jvmti.*;\n-\n-\/**\n- * This test exercises the JVMTI event <code>NativeMethodBind<\/code>.\n- * <br>It verifies that the events will be sent only during the start\n- * and live phase of VM execution.<br>\n- * The test works as follows. The NativeMethodBind event is enabled on\n- * <code>OnLoad<\/code> phase. Then the VM phase is checked from the\n- * NativeMethodBind callback to be start or live one. The java part calls\n- * the dummy native method <code>nativeMethod<\/code> on exit in order to\n- * provoke the NativeMethodBind event near the dead phase.\n- *\/\n-public class nativemethbind002 {\n-    static {\n-        try {\n-            System.loadLibrary(\"nativemethbind002\");\n-        } catch (UnsatisfiedLinkError ule) {\n-            System.err.println(\"Could not load \\\"nativemethbind002\\\" library\");\n-            System.err.println(\"java.library.path:\"\n-                + System.getProperty(\"java.library.path\"));\n-            throw ule;\n-        }\n-    }\n-\n-    native int nativeMethod();\n-\n-    public static void main(String[] argv) {\n-        argv = nsk.share.jvmti.JVMTITest.commonInit(argv);\n-\n-        \/\/ produce JCK-like exit status\n-        System.exit(run(argv, System.out) + Consts.JCK_STATUS_BASE);\n-    }\n-\n-    public static int run(String argv[], PrintStream out) {\n-        return new nativemethbind002().runThis(argv, out);\n-    }\n-\n-    private int runThis(String argv[], PrintStream out) {\n-        ArgumentHandler argHandler = new ArgumentHandler(argv);\n-        Log log = new Log(out, argHandler);\n-\n-        log.display(\"\\nCalling a native method ...\\n\");\n-\n-        \/\/ dummy methods used to provoke the NativeMethodBind event\n-        \/\/ near the dead phase\n-        return nativeMethod();\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/NativeMethodBind\/nativemethbind002.java","additions":0,"deletions":76,"binary":false,"changes":76,"status":"deleted"},{"patch":"@@ -1,49 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/*\n- * @test\n- *\n- * @summary converted from VM Testbase nsk\/jvmti\/NativeMethodBind\/nativemethbind002.\n- * VM Testbase keywords: [quick, jpda, jvmti, noras]\n- * VM Testbase readme:\n- * DESCRIPTION\n- *     This test exercises the JVMTI event NativeMethodBind.\n- *     It verifies that the events will be sent only during the start\n- *     and live phase of VM execution.\n- *     The test works as follows. The NativeMethodBind event is enabled\n- *     on 'OnLoad' phase. Then the VM phase is checked from the\n- *     NativeMethodBind callback to be start or live one. The java part\n- *     calls the dummy native method 'nativeMethod' on exit in order to\n- *     provoke the NativeMethodBind event near the dead phase.\n- * COMMENTS\n- *     Fixed the 4995867 bug.\n- *\n- * @library \/vmTestbase\n- *          \/test\/lib\n- * @run main\/othervm\/native\n- *      -agentlib:nativemethbind002=-waittime=5\n- *      nsk.jvmti.NativeMethodBind.nativemethbind002\n- *\/\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/NativeMethodBind\/nativemethbind002\/TestDescription.java","additions":0,"deletions":49,"binary":false,"changes":49,"status":"deleted"},{"patch":"@@ -1,33 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include \"native_thread.cpp\"\n-#include \"nsk_tools.cpp\"\n-#include \"jni_tools.cpp\"\n-#include \"jvmti_tools.cpp\"\n-#include \"agent_tools.cpp\"\n-#include \"jvmti_FollowRefObjects.cpp\"\n-#include \"Injector.cpp\"\n-#include \"JVMTITools.cpp\"\n-#include \"agent_common.cpp\"\n-#include \"nativemethbind002.cpp\"\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/NativeMethodBind\/nativemethbind002\/libnativemethbind002.cpp","additions":0,"deletions":33,"binary":false,"changes":33,"status":"deleted"},{"patch":"@@ -1,180 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include <stdlib.h>\n-#include <string.h>\n-#include \"jni_tools.h\"\n-#include \"agent_common.h\"\n-#include \"jvmti_tools.h\"\n-\n-extern \"C\" {\n-\n-#define STATUS_FAILED 2\n-#define PASSED 0\n-\n-\/* counter for the wrong NativeMethodBind events\n-   received during non-start or non-live phase *\/\n-static volatile int wrongBindEv = 0;\n-\n-static volatile jint result = PASSED;\n-static jvmtiEnv *jvmti = NULL;\n-static jvmtiEventCallbacks callbacks;\n-static jrawMonitorID countLock;\n-\n-static void lock(jvmtiEnv *jvmti_env, JNIEnv *jni_env) {\n-    if (!NSK_JVMTI_VERIFY(jvmti_env->RawMonitorEnter(countLock)))\n-        jni_env->FatalError(\"failed to enter a raw monitor\\n\");\n-}\n-\n-static void unlock(jvmtiEnv *jvmti_env, JNIEnv *jni_env) {\n-    if (!NSK_JVMTI_VERIFY(jvmti_env->RawMonitorExit(countLock)))\n-        jni_env->FatalError(\"failed to exit a raw monitor\\n\");\n-}\n-\n-\/** callback functions **\/\n-void JNICALL\n-NativeMethodBind(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,\n-        jmethodID method, void *addr, void **new_addr) {\n-    jvmtiPhase phase;\n-    char *methNam = NULL, *methSig = NULL;\n-\n-    lock(jvmti_env, jni_env);\n-\n-    if (!NSK_JVMTI_VERIFY(jvmti_env->GetPhase(&phase))) {\n-        result = STATUS_FAILED;\n-        NSK_COMPLAIN0(\n-            \"TEST FAILED: unable to obtain phase of the VM execution\\n\"\n-            \"\\tduring NativeMethodBind callback\\n\\n\");\n-        unlock(jvmti_env, jni_env);\n-        return;\n-    }\n-\n-    if (phase != JVMTI_PHASE_LIVE && phase != JVMTI_PHASE_START) {\n-        unlock(jvmti_env, jni_env);\n-        return;\n-    }\n-\n-    if (!NSK_JVMTI_VERIFY(jvmti_env->GetMethodName(method, &methNam, &methSig, NULL))) {\n-        result = STATUS_FAILED;\n-        NSK_COMPLAIN0(\"TEST FAILED: unable to get method name during NativeMethodBind callback\\n\\n\");\n-    }\n-    else\n-        NSK_DISPLAY2(\"NativeMethodBind received for \\\"%s %s\\\"\\n\",\n-            methNam, methSig);\n-\n-    if (methNam != NULL)\n-        if (!NSK_JVMTI_VERIFY(jvmti_env->Deallocate((unsigned char*) methNam)))\n-            NSK_COMPLAIN0(\"TEST FAILED: unable to deallocate memory pointed to method name\\n\\n\");\n-    if (methSig != NULL)\n-        if (!NSK_JVMTI_VERIFY(jvmti_env->Deallocate((unsigned char*) methSig)))\n-            NSK_COMPLAIN0(\"TEST FAILED: unable to deallocate memory pointed to method signature\\n\\n\");\n-\n-    unlock(jvmti_env, jni_env);\n-}\n-\n-void JNICALL\n-VMDeath(jvmtiEnv *jvmti_env, JNIEnv *env) {\n-    NSK_DISPLAY0(\"VMDeath event received\\n\");\n-\n-    if (wrongBindEv != 0) {\n-        NSK_COMPLAIN1(\n-            \"TEST FAILED: there are %d NativeMethodBind events\\n\"\n-            \"sent during non-start or non-live phase of the VM execution\\n\",\n-            wrongBindEv);\n-    }\n-\n-    if (result == STATUS_FAILED)\n-        exit(95 + STATUS_FAILED);\n-}\n-\/************************\/\n-\n-\/* dummy method used only to provoke NativeMethodBind events *\/\n-JNIEXPORT jint JNICALL\n-Java_nsk_jvmti_NativeMethodBind_nativemethbind002_nativeMethod(\n-        JNIEnv *env, jobject obj) {\n-    NSK_DISPLAY0(\"inside the nativeMethod()\\n\\n\");\n-\n-    return PASSED;\n-}\n-\n-#ifdef STATIC_BUILD\n-JNIEXPORT jint JNICALL Agent_OnLoad_nativemethbind002(JavaVM *jvm, char *options, void *reserved) {\n-    return Agent_Initialize(jvm, options, reserved);\n-}\n-JNIEXPORT jint JNICALL Agent_OnAttach_nativemethbind002(JavaVM *jvm, char *options, void *reserved) {\n-    return Agent_Initialize(jvm, options, reserved);\n-}\n-JNIEXPORT jint JNI_OnLoad_nativemethbind002(JavaVM *jvm, char *options, void *reserved) {\n-    return JNI_VERSION_1_8;\n-}\n-#endif\n-jint Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {\n-    jvmtiCapabilities caps;\n-\n-    \/* init framework and parse options *\/\n-    if (!NSK_VERIFY(nsk_jvmti_parseOptions(options)))\n-        return JNI_ERR;\n-\n-    \/* create JVMTI environment *\/\n-    if (!NSK_VERIFY((jvmti =\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n-        return JNI_ERR;\n-\n-    \/* create a raw monitor *\/\n-    if (!NSK_JVMTI_VERIFY(jvmti->CreateRawMonitor(\"_counter_lock\", &countLock)))\n-        return JNI_ERR;\n-\n-    \/* add capability to generate compiled method events *\/\n-    memset(&caps, 0, sizeof(jvmtiCapabilities));\n-    caps.can_generate_native_method_bind_events = 1;\n-    if (!NSK_JVMTI_VERIFY(jvmti->AddCapabilities(&caps)))\n-        return JNI_ERR;\n-\n-    if (!NSK_JVMTI_VERIFY(jvmti->GetCapabilities(&caps)))\n-        return JNI_ERR;\n-    if (!caps.can_generate_native_method_bind_events)\n-        NSK_DISPLAY0(\"Warning: generation of native method bind events is not implemented\\n\");\n-\n-    \/* set event callback *\/\n-    NSK_DISPLAY0(\"setting event callbacks ...\\n\");\n-    (void) memset(&callbacks, 0, sizeof(callbacks));\n-    callbacks.NativeMethodBind = &NativeMethodBind;\n-    callbacks.VMDeath = &VMDeath;\n-    if (!NSK_JVMTI_VERIFY(jvmti->SetEventCallbacks(&callbacks, sizeof(callbacks))))\n-        return JNI_ERR;\n-\n-    NSK_DISPLAY0(\"setting event callbacks done\\nenabling JVMTI events ...\\n\");\n-    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE,\n-                                                          JVMTI_EVENT_NATIVE_METHOD_BIND,\n-                                                          NULL)))\n-        return JNI_ERR;\n-    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE,\n-                                                          JVMTI_EVENT_VM_DEATH,\n-                                                          NULL)))\n-        return JNI_ERR;\n-    NSK_DISPLAY0(\"enabling the events done\\n\\n\");\n-\n-    return JNI_OK;\n-}\n-\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/NativeMethodBind\/nativemethbind002\/nativemethbind002.cpp","additions":0,"deletions":180,"binary":false,"changes":180,"status":"deleted"},{"patch":"@@ -1,82 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package nsk.jvmti.NativeMethodBind;\n-\n-import java.io.*;\n-\n-import nsk.share.*;\n-import nsk.share.jvmti.*;\n-\n-\/**\n- * This test exercises the JVMTI event <code>NativeMethodBind<\/code>.\n- * <br>It verifies that the event will not be sent when the native\n- * method is unbound.<p>\n- * The test works as follows. The java part invokes the native method\n- * <code>registerNative()<\/code> which registers native method\n- * <code>nativeMethod()<\/code> for the dummy class <code>TestedClass<\/code>\n- * and then unregisters it. Registration\/unregistration is made through\n- * the JNI RegisterNatives()\/UnregisterNatives() calls.<br>\n- * In accordance with the spec, it is expected that the NativeMethodBind\n- * will be generated only one time for the nativeMethod().\n- *\/\n-public class nativemethbind003 {\n-    static {\n-        try {\n-            System.loadLibrary(\"nativemethbind003\");\n-        } catch (UnsatisfiedLinkError ule) {\n-            System.err.println(\"Could not load \\\"nativemethbind003\\\" library\");\n-            System.err.println(\"java.library.path:\"\n-                + System.getProperty(\"java.library.path\"));\n-            throw ule;\n-        }\n-    }\n-\n-    native void registerNative();\n-\n-    public static void main(String[] argv) {\n-        argv = nsk.share.jvmti.JVMTITest.commonInit(argv);\n-\n-        \/\/ produce JCK-like exit status\n-        System.exit(run(argv, System.out) + Consts.JCK_STATUS_BASE);\n-    }\n-\n-    public static int run(String argv[], PrintStream out) {\n-        return new nativemethbind003().runThis(argv, out);\n-    }\n-\n-    private int runThis(String argv[], PrintStream out) {\n-        \/\/ register native method 'nativeMethod' with 'TestedClass'\n-        registerNative();\n-\n-        return Consts.TEST_PASSED;\n-    }\n-\n-   \/**\n-    * Dummy class used only to register\/unregister native method\n-    * <code>nativeMethod<\/code> with it\n-    *\/\n-    class TestedClass {\n-        native void nativeMethod();\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/NativeMethodBind\/nativemethbind003.java","additions":0,"deletions":82,"binary":false,"changes":82,"status":"deleted"},{"patch":"@@ -1,52 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/*\n- * @test\n- *\n- * @summary converted from VM Testbase nsk\/jvmti\/NativeMethodBind\/nativemethbind003.\n- * VM Testbase keywords: [quick, jpda, jvmti, noras]\n- * VM Testbase readme:\n- * DESCRIPTION\n- *     This test exercises the JVMTI event NativeMethodBind.\n- *     It verifies that the event will not be sent when the native\n- *     method is unbound.\n- *     The test works as follows. The java part invokes the native method\n- *     'registerNative()' which registers native method 'nativeMethod()'\n- *     for the dummy class 'TestedClass' and then unregisters it.\n- *     Registration\/unregistration is made through the JNI\n- *     RegisterNatives()\/UnregisterNatives() calls.\n- *     In accordance with the spec, it is expected that the NativeMethodBind\n- *     will be generated only one time for the nativeMethod().\n- * COMMENTS\n- *     The test has been fixed due to the bug 4967116.\n- *     Fixed the 4995867 bug.\n- *\n- * @library \/vmTestbase\n- *          \/test\/lib\n- * @run main\/othervm\/native\n- *      -agentlib:nativemethbind003=-waittime=5\n- *      nsk.jvmti.NativeMethodBind.nativemethbind003\n- *\/\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/NativeMethodBind\/nativemethbind003\/TestDescription.java","additions":0,"deletions":52,"binary":false,"changes":52,"status":"deleted"},{"patch":"@@ -1,33 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include \"native_thread.cpp\"\n-#include \"nsk_tools.cpp\"\n-#include \"jni_tools.cpp\"\n-#include \"jvmti_tools.cpp\"\n-#include \"agent_tools.cpp\"\n-#include \"jvmti_FollowRefObjects.cpp\"\n-#include \"Injector.cpp\"\n-#include \"JVMTITools.cpp\"\n-#include \"agent_common.cpp\"\n-#include \"nativemethbind003.cpp\"\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/NativeMethodBind\/nativemethbind003\/libnativemethbind003.cpp","additions":0,"deletions":33,"binary":false,"changes":33,"status":"deleted"},{"patch":"@@ -1,244 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include <stdlib.h>\n-#include <string.h>\n-#include \"jni_tools.h\"\n-#include \"agent_common.h\"\n-#include \"jvmti_tools.h\"\n-\n-extern \"C\" {\n-\n-#define STATUS_FAILED 2\n-#define PASSED 0\n-\n-\/* tested method *\/\n-static const char *METHODS[] = {\n-    \"nativeMethod\", \"()V\"\n-};\n-\n-\/* event counter for the tested method and expected number\n-   of the events *\/\n-static volatile int bindEv[] = {\n-    0, 1\n-};\n-\n-static const char *CLASS_SIG =\n-    \"Lnsk\/jvmti\/NativeMethodBind\/nativemethbind003$TestedClass;\";\n-\n-static volatile jint result = PASSED;\n-static jvmtiEnv *jvmti = NULL;\n-static jvmtiEventCallbacks callbacks;\n-static jrawMonitorID countLock;\n-\n-static void lock(jvmtiEnv *jvmti_env, JNIEnv *jni_env) {\n-    if (!NSK_JVMTI_VERIFY(jvmti_env->RawMonitorEnter(countLock)))\n-        jni_env->FatalError(\"failed to enter a raw monitor\\n\");\n-}\n-\n-static void unlock(jvmtiEnv *jvmti_env, JNIEnv *jni_env) {\n-    if (!NSK_JVMTI_VERIFY(jvmti_env->RawMonitorExit(countLock)))\n-        jni_env->FatalError(\"failed to exit a raw monitor\\n\");\n-}\n-\n-\/** callback functions **\/\n-void JNICALL\n-NativeMethodBind(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,\n-        jmethodID method, void *addr, void **new_addr) {\n-    jvmtiPhase phase;\n-    char *methNam, *methSig;\n-\n-    lock(jvmti_env, jni_env);\n-\n-    NSK_DISPLAY0(\">>>> NativeMethodBind event received\\n\");\n-\n-    if (!NSK_JVMTI_VERIFY(jvmti_env->GetPhase(&phase))) {\n-        result = STATUS_FAILED;\n-        unlock(jvmti_env, jni_env);\n-        return;\n-    }\n-\n-    if (phase != JVMTI_PHASE_LIVE && phase != JVMTI_PHASE_START) {\n-        unlock(jvmti_env, jni_env);\n-        return;\n-    }\n-\n-    if (!NSK_JVMTI_VERIFY(jvmti_env->GetMethodName(method, &methNam, &methSig, NULL))) {\n-        result = STATUS_FAILED;\n-        NSK_COMPLAIN0(\"TEST FAILED: unable to get method name during NativeMethodBind callback\\n\\n\");\n-        unlock(jvmti_env, jni_env);\n-        return;\n-    }\n-\n-    if ((strcmp(methNam,METHODS[0]) == 0) &&\n-            (strcmp(methSig,METHODS[1]) == 0)) {\n-        bindEv[0]++;\n-\n-        NSK_DISPLAY2(\"\\tmethod: \\\"%s %s\\\"\\n\", methNam, methSig);\n-    }\n-\n-    if (!NSK_JVMTI_VERIFY(jvmti_env->Deallocate((unsigned char*) methNam))) {\n-        result = STATUS_FAILED;\n-        NSK_COMPLAIN0(\"TEST FAILED: unable to deallocate memory storing method name\\n\\n\");\n-    }\n-    if (!NSK_JVMTI_VERIFY(jvmti_env->Deallocate((unsigned char*) methSig))) {\n-        result = STATUS_FAILED;\n-        NSK_COMPLAIN0(\"TEST FAILED: unable to deallocate memory storing method signature\\n\\n\");\n-    }\n-\n-    NSK_DISPLAY0(\"<<<<\\n\\n\");\n-\n-    unlock(jvmti_env, jni_env);\n-}\n-\n-void JNICALL\n-VMDeath(jvmtiEnv *jvmti_env, JNIEnv *env) {\n-    NSK_DISPLAY0(\"VMDeath event received\\n\");\n-\n-    if (bindEv[0] != bindEv[1]) {\n-        result = STATUS_FAILED;\n-        NSK_COMPLAIN5(\n-            \"TEST FAILED: wrong NativeMethodBind events\\n\"\n-            \"\\tfor tested method \\\"%s %s\\\" bound with \\\"%s\\\":\\n\"\n-            \"\\tgot: %d\\texpected: %d\\n\\n\",\n-            METHODS[0], METHODS[1], CLASS_SIG, bindEv[0], bindEv[1]);\n-    } else {\n-        NSK_DISPLAY4(\n-            \"CHECK PASSED: %d NativeMethodBind event(s)\\n\"\n-            \"\\tfor tested method \\\"%s %s\\\" bound with \\\"%s\\\"\\n\"\n-            \"\\tas expected\\n\",\n-            bindEv[0], METHODS[0], METHODS[1], CLASS_SIG);\n-    }\n-\n-    if (result == STATUS_FAILED)\n-        exit(95 + STATUS_FAILED);\n-}\n-\/************************\/\n-\n-\/* dummy method used only to provoke NativeMethodBind event *\/\n-static void JNICALL\n-nativeMethod(JNIEnv *env, jobject obj) {\n-    NSK_DISPLAY0(\"inside the nativeMethod()\\n\");\n-}\n-\n-\/* dummy method used only to provoke NativeMethodBind event *\/\n-JNIEXPORT void JNICALL\n-Java_nsk_jvmti_NativeMethodBind_nativemethbind003_registerNative(\n-        JNIEnv *env, jobject obj) {\n-    jclass testedCls = NULL;\n-    JNINativeMethod meth;\n-\n-    NSK_DISPLAY1(\"Inside the registerNative()\\n\"\n-                 \"Finding class \\\"%s\\\" ...\\n\",\n-                 CLASS_SIG);\n-    if (!NSK_JNI_VERIFY(env, (testedCls = env->FindClass(CLASS_SIG)) != NULL)) {\n-        result = STATUS_FAILED;\n-        NSK_COMPLAIN1(\"TEST FAILURE: unable to find class \\\"%s\\\"\\n\\n\",\n-            CLASS_SIG);\n-        return;\n-    }\n-\n-    meth.name = (char*) METHODS[0];\n-    meth.signature = (char*) METHODS[1];\n-    meth.fnPtr = (void*) nativeMethod;\n-\n-    NSK_DISPLAY3(\n-        \"Calling RegisterNatives() with \\\"%s %s\\\"\\n\"\n-        \"\\tfor class \\\"%s\\\" ...\\n\",\n-        METHODS[0], METHODS[1], CLASS_SIG);\n-    if (!NSK_JNI_VERIFY_VOID(env, (env->RegisterNatives(testedCls, &meth, 1)) != 0)) {\n-        result = STATUS_FAILED;\n-        NSK_COMPLAIN3(\"TEST FAILURE: unable to RegisterNatives() \\\"%s %s\\\" for class \\\"%s\\\"\\n\\n\",\n-            METHODS[0], METHODS[1], CLASS_SIG);\n-    }\n-\n-    NSK_DISPLAY1(\"Calling UnregisterNatives() for class \\\"%s\\\" ...\\n\",\n-        CLASS_SIG);\n-    if (!NSK_JNI_VERIFY_VOID(env, (env->UnregisterNatives(testedCls)) != 0)) {\n-        result = STATUS_FAILED;\n-        NSK_COMPLAIN3(\"TEST FAILURE: unable to UnregisterNatives() \\\"%s %s\\\" for class \\\"%s\\\"\\n\\n\",\n-            METHODS[1][0], METHODS[1][1], CLASS_SIG);\n-    }\n-}\n-\n-#ifdef STATIC_BUILD\n-JNIEXPORT jint JNICALL Agent_OnLoad_nativemethbind003(JavaVM *jvm, char *options, void *reserved) {\n-    return Agent_Initialize(jvm, options, reserved);\n-}\n-JNIEXPORT jint JNICALL Agent_OnAttach_nativemethbind003(JavaVM *jvm, char *options, void *reserved) {\n-    return Agent_Initialize(jvm, options, reserved);\n-}\n-JNIEXPORT jint JNI_OnLoad_nativemethbind003(JavaVM *jvm, char *options, void *reserved) {\n-    return JNI_VERSION_1_8;\n-}\n-#endif\n-jint Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {\n-    jvmtiCapabilities caps;\n-\n-    \/* init framework and parse options *\/\n-    if (!NSK_VERIFY(nsk_jvmti_parseOptions(options)))\n-        return JNI_ERR;\n-\n-    \/* create JVMTI environment *\/\n-    if (!NSK_VERIFY((jvmti =\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n-        return JNI_ERR;\n-\n-    \/* create a raw monitor *\/\n-    if (!NSK_JVMTI_VERIFY(jvmti->CreateRawMonitor(\"_counter_lock\", &countLock)))\n-        return JNI_ERR;\n-\n-    \/* add capability to generate compiled method events *\/\n-    memset(&caps, 0, sizeof(jvmtiCapabilities));\n-    caps.can_generate_native_method_bind_events = 1;\n-    if (!NSK_JVMTI_VERIFY(jvmti->AddCapabilities(&caps)))\n-        return JNI_ERR;\n-\n-    if (!NSK_JVMTI_VERIFY(jvmti->GetCapabilities(&caps)))\n-        return JNI_ERR;\n-    if (!caps.can_generate_native_method_bind_events)\n-        NSK_DISPLAY0(\"Warning: generation of native method bind events is not implemented\\n\");\n-\n-    \/* set event callback *\/\n-    NSK_DISPLAY0(\"setting event callbacks ...\\n\");\n-    (void) memset(&callbacks, 0, sizeof(callbacks));\n-    callbacks.NativeMethodBind = &NativeMethodBind;\n-    callbacks.VMDeath = &VMDeath;\n-    if (!NSK_JVMTI_VERIFY(jvmti->SetEventCallbacks(&callbacks, sizeof(callbacks))))\n-        return JNI_ERR;\n-\n-    NSK_DISPLAY0(\"setting event callbacks done\\nenabling JVMTI events ...\\n\");\n-    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE,\n-                                                          JVMTI_EVENT_NATIVE_METHOD_BIND,\n-                                                          NULL)))\n-        return JNI_ERR;\n-    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE,\n-                                                          JVMTI_EVENT_VM_DEATH,\n-                                                          NULL)))\n-        return JNI_ERR;\n-    NSK_DISPLAY0(\"enabling the events done\\n\\n\");\n-\n-    return JNI_OK;\n-}\n-\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/NativeMethodBind\/nativemethbind003\/nativemethbind003.cpp","additions":0,"deletions":244,"binary":false,"changes":244,"status":"deleted"},{"patch":"@@ -1,77 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package nsk.jvmti.NativeMethodBind;\n-\n-import java.io.*;\n-\n-import nsk.share.*;\n-import nsk.share.jvmti.*;\n-\n-\/**\n- * This test exercises the JVMTI event <code>NativeMethodBind<\/code>.\n- * <br>It verifies that binding native method can be redirected during\n- * the event callback.<p>\n- * The test works as follows. An agent part enables the NativeMethodBind\n- * generation. Then the java part invokes the native method\n- * <code>nativeMethod()<\/code> which leads to the NativeMethodBind generation.\n- * In NativeMethodBind callback incoming address of the nativeMethod() is\n- * changed to the address of another native method\n- * <code>redirNativeMethod()<\/code>.\n- * Both functions nativeMethod() and redirNativeMethod() count their calls.<br>\n- * In accordance with the spec, the nativeMethod() should not be invoked\n- * and the redirNativeMethod() should be invoked once.\n- *\/\n-public class nativemethbind004 {\n-    static {\n-        try {\n-            System.loadLibrary(\"nativemethbind004\");\n-        } catch (UnsatisfiedLinkError ule) {\n-            System.err.println(\"Could not load \\\"nativemethbind004\\\" library\");\n-            System.err.println(\"java.library.path:\"\n-                + System.getProperty(\"java.library.path\"));\n-            throw ule;\n-        }\n-    }\n-\n-    native void nativeMethod();\n-    native int check();\n-\n-    public static void main(String[] argv) {\n-        argv = nsk.share.jvmti.JVMTITest.commonInit(argv);\n-\n-        \/\/ produce JCK-like exit status\n-        System.exit(run(argv, System.out) + Consts.JCK_STATUS_BASE);\n-    }\n-\n-    public static int run(String argv[], PrintStream out) {\n-        return new nativemethbind004().runThis(argv, out);\n-    }\n-\n-    private int runThis(String argv[], PrintStream out) {\n-        \/\/ invoke native method to be redirected\n-        nativeMethod();\n-\n-        return check();\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/NativeMethodBind\/nativemethbind004.java","additions":0,"deletions":77,"binary":false,"changes":77,"status":"deleted"},{"patch":"@@ -1,53 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/*\n- * @test\n- *\n- * @summary converted from VM Testbase nsk\/jvmti\/NativeMethodBind\/nativemethbind004.\n- * VM Testbase keywords: [quick, jpda, jvmti, noras]\n- * VM Testbase readme:\n- * DESCRIPTION\n- *     This test exercises the JVMTI event NativeMethodBind.\n- *     It verifies that binding native method can be redirected during\n- *     the event callback.\n- *     The test works as follows. An agent part enables the NativeMethodBind\n- *     generation. Then the java part invokes the native method 'nativeMethod()'\n- *     which leads to the NativeMethodBind generation. In NativeMethodBind\n- *     callback incoming address of the nativeMethod() is changed to the\n- *     address of another native method 'redirNativeMethod()'. Both functions\n- *     nativeMethod() and redirNativeMethod() count their calls.\n- *     In accordance with the spec, the nativeMethod() should not be invoked\n- *     and the redirNativeMethod() should be invoked once.\n- * COMMENTS\n- *     The test has been fixed due to the bug 4967116.\n- *     Fixed the 4995867 bug.\n- *\n- * @library \/vmTestbase\n- *          \/test\/lib\n- * @run main\/othervm\/native\n- *      -agentlib:nativemethbind004=-waittime=5\n- *      nsk.jvmti.NativeMethodBind.nativemethbind004\n- *\/\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/NativeMethodBind\/nativemethbind004\/TestDescription.java","additions":0,"deletions":53,"binary":false,"changes":53,"status":"deleted"},{"patch":"@@ -1,33 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include \"native_thread.cpp\"\n-#include \"nsk_tools.cpp\"\n-#include \"jni_tools.cpp\"\n-#include \"jvmti_tools.cpp\"\n-#include \"agent_tools.cpp\"\n-#include \"jvmti_FollowRefObjects.cpp\"\n-#include \"Injector.cpp\"\n-#include \"JVMTITools.cpp\"\n-#include \"agent_common.cpp\"\n-#include \"nativemethbind004.cpp\"\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/NativeMethodBind\/nativemethbind004\/libnativemethbind004.cpp","additions":0,"deletions":33,"binary":false,"changes":33,"status":"deleted"},{"patch":"@@ -1,217 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include <stdlib.h>\n-#include <string.h>\n-#include \"jni_tools.h\"\n-#include \"agent_common.h\"\n-#include \"jvmti_tools.h\"\n-\n-extern \"C\" {\n-\n-#define STATUS_FAILED 2\n-#define PASSED 0\n-\n-\/* tested method *\/\n-static const char *METHOD[] = {\n-    \"nativeMethod\", \"()V\"\n-};\n-\n-\/* counter for the original method calls *\/\n-static volatile int origCalls = 0;\n-\/* counter for the redirected method calls *\/\n-static volatile int redirCalls = 0;\n-\n-static volatile jint result = PASSED;\n-static jvmtiEnv *jvmti = NULL;\n-static jvmtiEventCallbacks callbacks;\n-static jrawMonitorID countLock;\n-\n-\/* method to be redirected used to check the native method redirection\n-   through the NativeMethodBind event *\/\n-JNIEXPORT void JNICALL\n-Java_nsk_jvmti_NativeMethodBind_nativemethbind004_nativeMethod(\n-        JNIEnv *env, jobject obj) {\n-    origCalls++;\n-    NSK_DISPLAY1(\"inside the nativeMethod(): calls=%d\\n\",\n-        origCalls);\n-}\n-\n-\/* redirected method used to check the native method redirection\n-   through the NativeMethodBind event *\/\n-static void JNICALL\n-redirNativeMethod(JNIEnv *env, jobject obj) {\n-    redirCalls++;\n-    NSK_DISPLAY1(\"inside the redirNativeMethod(): calls=%d\\n\",\n-        redirCalls);\n-}\n-\n-static void lock(jvmtiEnv *jvmti_env, JNIEnv *jni_env) {\n-    if (!NSK_JVMTI_VERIFY(jvmti_env->RawMonitorEnter(countLock)))\n-        jni_env->FatalError(\"failed to enter a raw monitor\\n\");\n-}\n-\n-static void unlock(jvmtiEnv *jvmti_env, JNIEnv *jni_env) {\n-    if (!NSK_JVMTI_VERIFY(jvmti_env->RawMonitorExit(countLock)))\n-        jni_env->FatalError(\"failed to exit a raw monitor\\n\");\n-}\n-\n-\/** callback functions **\/\n-void JNICALL\n-NativeMethodBind(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,\n-        jmethodID method, void *addr, void **new_addr) {\n-    jvmtiPhase phase;\n-    char *methNam, *methSig;\n-    lock(jvmti_env, jni_env);\n-\n-    NSK_DISPLAY0(\">>>> NativeMethodBind event received\\n\");\n-\n-    if (!NSK_JVMTI_VERIFY(jvmti_env->GetPhase(&phase))) {\n-        result = STATUS_FAILED;\n-        unlock(jvmti_env, jni_env);\n-        return;\n-    }\n-\n-    if (phase != JVMTI_PHASE_LIVE && phase != JVMTI_PHASE_START) {\n-        unlock(jvmti_env, jni_env);\n-        return;\n-    }\n-\n-    if (!NSK_JVMTI_VERIFY(jvmti_env->GetMethodName(method, &methNam, &methSig, NULL))) {\n-        result = STATUS_FAILED;\n-        NSK_COMPLAIN0(\"TEST FAILED: unable to get method name during NativeMethodBind callback\\n\\n\");\n-        unlock(jvmti_env, jni_env);\n-        return;\n-    }\n-\n-    if ((strcmp(methNam,METHOD[0]) == 0) &&\n-            (strcmp(methSig,METHOD[1]) == 0)) {\n-        NSK_DISPLAY4(\"\\tmethod: \\\"%s %s\\\"\\nRedirecting the method address from 0x%p to 0x%p ...\\n\",\n-            methNam, methSig, addr, (void*) redirNativeMethod);\n-\n-        *new_addr = (void*) redirNativeMethod;\n-    }\n-\n-    if (!NSK_JVMTI_VERIFY(jvmti_env->Deallocate((unsigned char*) methNam))) {\n-        result = STATUS_FAILED;\n-        NSK_COMPLAIN0(\"TEST FAILED: unable to deallocate memory storing method name\\n\\n\");\n-    }\n-    if (!NSK_JVMTI_VERIFY(jvmti_env->Deallocate((unsigned char*) methSig))) {\n-        result = STATUS_FAILED;\n-        NSK_COMPLAIN0(\"TEST FAILED: unable to deallocate memory storing method signature\\n\\n\");\n-    }\n-\n-    NSK_DISPLAY0(\"<<<<\\n\\n\");\n-\n-    unlock(jvmti_env, jni_env);\n-}\n-\/************************\/\n-\n-JNIEXPORT jint JNICALL\n-Java_nsk_jvmti_NativeMethodBind_nativemethbind004_check(\n-        JNIEnv *env, jobject obj) {\n-\n-    if (origCalls == 0) {\n-        NSK_DISPLAY0(\n-            \"CHECK PASSED: original nativeMethod() to be redirected\\n\"\n-            \"\\thas not been invoked as expected\\n\");\n-    } else {\n-        result = STATUS_FAILED;\n-        NSK_COMPLAIN1(\n-            \"TEST FAILED: nativeMethod() has not been redirected by the NativeMethodBind:\\n\"\n-            \"\\t%d calls\\texpected: 0\\n\\n\",\n-            origCalls);\n-    }\n-\n-    if (redirCalls == 1) {\n-        NSK_DISPLAY1(\n-            \"CHECK PASSED: nativeMethod() has been redirected by the NativeMethodBind:\\n\"\n-            \"\\t%d calls of redirected method as expected\\n\",\n-            redirCalls);\n-    } else {\n-        result = STATUS_FAILED;\n-        NSK_COMPLAIN1(\n-            \"TEST FAILED: nativeMethod() has not been redirected by the NativeMethodBind:\\n\"\n-            \"\\t%d calls of redirected method\\texpected: 1\\n\\n\",\n-            redirCalls);\n-    }\n-\n-    return result;\n-}\n-\n-#ifdef STATIC_BUILD\n-JNIEXPORT jint JNICALL Agent_OnLoad_nativemethbind004(JavaVM *jvm, char *options, void *reserved) {\n-    return Agent_Initialize(jvm, options, reserved);\n-}\n-JNIEXPORT jint JNICALL Agent_OnAttach_nativemethbind004(JavaVM *jvm, char *options, void *reserved) {\n-    return Agent_Initialize(jvm, options, reserved);\n-}\n-JNIEXPORT jint JNI_OnLoad_nativemethbind004(JavaVM *jvm, char *options, void *reserved) {\n-    return JNI_VERSION_1_8;\n-}\n-#endif\n-jint Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {\n-    jvmtiCapabilities caps;\n-\n-    \/* init framework and parse options *\/\n-    if (!NSK_VERIFY(nsk_jvmti_parseOptions(options)))\n-        return JNI_ERR;\n-\n-    \/* create JVMTI environment *\/\n-    if (!NSK_VERIFY((jvmti =\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n-        return JNI_ERR;\n-\n-    \/* create a raw monitor *\/\n-    if (!NSK_JVMTI_VERIFY(jvmti->CreateRawMonitor(\"_counter_lock\", &countLock)))\n-        return JNI_ERR;\n-\n-    \/* add capability to generate compiled method events *\/\n-    memset(&caps, 0, sizeof(jvmtiCapabilities));\n-    caps.can_generate_native_method_bind_events = 1;\n-    if (!NSK_JVMTI_VERIFY(jvmti->AddCapabilities(&caps)))\n-        return JNI_ERR;\n-\n-    if (!NSK_JVMTI_VERIFY(jvmti->GetCapabilities(&caps)))\n-        return JNI_ERR;\n-    if (!caps.can_generate_native_method_bind_events)\n-        NSK_DISPLAY0(\"Warning: generation of native method bind events is not implemented\\n\");\n-\n-    \/* set event callback *\/\n-    NSK_DISPLAY0(\"setting event callbacks ...\\n\");\n-    (void) memset(&callbacks, 0, sizeof(callbacks));\n-    callbacks.NativeMethodBind = &NativeMethodBind;\n-    if (!NSK_JVMTI_VERIFY(jvmti->SetEventCallbacks(&callbacks, sizeof(callbacks))))\n-        return JNI_ERR;\n-\n-    NSK_DISPLAY0(\"setting event callbacks done\\nenabling JVMTI events ...\\n\");\n-    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE,\n-                                                          JVMTI_EVENT_NATIVE_METHOD_BIND,\n-                                                          NULL)))\n-        return JNI_ERR;\n-    NSK_DISPLAY0(\"enabling the events done\\n\\n\");\n-\n-    return JNI_OK;\n-}\n-\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/NativeMethodBind\/nativemethbind004\/nativemethbind004.cpp","additions":0,"deletions":217,"binary":false,"changes":217,"status":"deleted"},{"patch":"@@ -1,88 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package nsk.jvmti.SingleStep;\n-\n-import java.io.*;\n-\n-import nsk.share.*;\n-import nsk.share.jvmti.*;\n-\n-\/**\n- * This test exercises the JVMTI event <code>SingleStep<\/code>.\n- * <br>It verifies that this event can be enabled and disabled\n- * during program execution.<br>\n- * The test works as follows. Breakpoint is set at special method\n- * <code>bpMethod()<\/code>. Upon reaching the breakpoint, agent\n- * enables <code>SingleStep<\/code> event generation. All the received\n- * events are counted. When the method <code>bpMethod()<\/code> is\n- * leaved and accordingly, the program returns to the calling method\n- * <code>runThis()<\/code>, the agent disables the event generation.<br>\n- * At least one <code>SingleStep<\/code> event must be received for\n- * the each methods mentioned above. Also after disabling the event\n- * no more event must be received.\n- *\/\n-public class singlestep001 {\n-    static {\n-        try {\n-            System.loadLibrary(\"singlestep001\");\n-        } catch (UnsatisfiedLinkError ule) {\n-            System.err.println(\"Could not load \\\"singlestep001\\\" library\");\n-            System.err.println(\"java.library.path:\"\n-                + System.getProperty(\"java.library.path\"));\n-            throw ule;\n-        }\n-    }\n-\n-    native int check();\n-\n-    public static void main(String[] argv) {\n-        argv = nsk.share.jvmti.JVMTITest.commonInit(argv);\n-\n-        \/\/ produce JCK-like exit status\n-        System.exit(run(argv, System.out) + Consts.JCK_STATUS_BASE);\n-    }\n-\n-    public static int run(String argv[], PrintStream out) {\n-        return new singlestep001().runThis(argv, out);\n-    }\n-\n-    private int runThis(String argv[], PrintStream out) {\n-        ArgumentHandler argHandler = new ArgumentHandler(argv);\n-        Log log = new Log(out, argHandler);\n-        Thread.currentThread().setName(\"singlestep001Thr\");\n-\n-        log.display(\"\\nReaching a breakpoint method ...\\n\");\n-        bpMethod();\n-        log.display(\"The breakpoint method leaved ...\");\n-\n-        return check();\n-    }\n-\n-    \/**\n-     * dummy method used only to reach breakpoint set in the agent\n-     *\/\n-    private void bpMethod() {\n-        int dummyVar = 0;\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/SingleStep\/singlestep001.java","additions":0,"deletions":88,"binary":false,"changes":88,"status":"deleted"},{"patch":"@@ -1,50 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/*\n- * @test\n- *\n- * @summary converted from VM Testbase nsk\/jvmti\/SingleStep\/singlestep001.\n- * VM Testbase keywords: [quick, jpda, jvmti, onload_only_caps, noras]\n- * VM Testbase readme:\n- * DESCRIPTION\n- *     This test exercises the JVMTI event SingleStep.\n- *     It verifies that this event can be enabled and disabled during\n- *     program execution.\n- *     The test works as follows. Breakpoint is set at special method\n- *     'bpMethod()'. Upon reaching the breakpoint, agent enables SingleStep\n- *     event generation. All the received events are counted. When the\n- *     method 'bpMethod()' is leaved and accordingly, the program returns\n- *     to the calling method 'runThis()', the agent disables the event\n- *     generation.\n- *     At least one SingleStep  event must be received for the each method\n- *     mentioned above. Also after disabling the event no more events\n- *     must be received.\n- * COMMENTS\n- *\n- * @library \/vmTestbase\n- *          \/test\/lib\n- * @run main\/othervm\/native -agentlib:singlestep001=-waittime=5 nsk.jvmti.SingleStep.singlestep001\n- *\/\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/SingleStep\/singlestep001\/TestDescription.java","additions":0,"deletions":50,"binary":false,"changes":50,"status":"deleted"},{"patch":"@@ -1,33 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include \"native_thread.cpp\"\n-#include \"nsk_tools.cpp\"\n-#include \"jni_tools.cpp\"\n-#include \"jvmti_tools.cpp\"\n-#include \"agent_tools.cpp\"\n-#include \"jvmti_FollowRefObjects.cpp\"\n-#include \"Injector.cpp\"\n-#include \"JVMTITools.cpp\"\n-#include \"agent_common.cpp\"\n-#include \"singlestep001.cpp\"\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/SingleStep\/singlestep001\/libsinglestep001.cpp","additions":0,"deletions":33,"binary":false,"changes":33,"status":"deleted"},{"patch":"@@ -1,302 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include <stdio.h>\n-#include <string.h>\n-#include <jvmti.h>\n-#include \"agent_common.h\"\n-\n-#include \"nsk_tools.h\"\n-#include \"JVMTITools.h\"\n-#include \"jvmti_tools.h\"\n-#include \"jni_tools.h\"\n-\n-extern \"C\" {\n-\n-#define STATUS_FAILED 2\n-#define PASSED 0\n-\n-#define METH_NUM 2\n-\n-static const char *METHODS[] = {\n-    \"bpMethod\",\n-    \"runThis\"\n-};\n-\n-static const char *METHOD_SIGS[] = {\n-    \"()V\",\n-    \"([Ljava\/lang\/String;Ljava\/io\/PrintStream;)I\"\n-};\n-\n-static volatile long stepEv[] = { 0, 0 };\n-\n-static const char *CLASS_SIG =\n-    \"Lnsk\/jvmti\/SingleStep\/singlestep001;\";\n-\n-static volatile jint result = PASSED;\n-static jvmtiEnv *jvmti = NULL;\n-static jvmtiEventCallbacks callbacks;\n-\n-static volatile int callbacksEnabled = NSK_FALSE;\n-static jrawMonitorID agent_lock;\n-\n-static void setBP(jvmtiEnv *jvmti_env, JNIEnv *env, jclass klass) {\n-    jmethodID mid;\n-\n-    if (!NSK_JNI_VERIFY(env, (mid = env->GetMethodID(klass, METHODS[0], METHOD_SIGS[0])) != NULL))\n-        env->FatalError(\"failed to get ID for the java method\\n\");\n-\n-    if (!NSK_JVMTI_VERIFY(jvmti_env->SetBreakpoint(mid, 0)))\n-        env->FatalError(\"failed to set breakpoint\\n\");\n-}\n-\n-\/** callback functions **\/\n-void JNICALL\n-ClassLoad(jvmtiEnv *jvmti_env, JNIEnv *env, jthread thread, jclass klass) {\n-    char *sig, *generic;\n-\n-    jvmti->RawMonitorEnter(agent_lock);\n-\n-    if (callbacksEnabled) {\n-        if (!NSK_JVMTI_VERIFY(jvmti_env->GetClassSignature(klass, &sig, &generic)))\n-            env->FatalError(\"failed to obtain a class signature\\n\");\n-\n-        if (sig != NULL && (strcmp(sig, CLASS_SIG) == 0)) {\n-            NSK_DISPLAY1(\n-                \"ClassLoad event received for the class \\\"%s\\\"\\n\"\n-                \"\\tsetting breakpoint ...\\n\",\n-                sig);\n-            setBP(jvmti_env, env, klass);\n-        }\n-    }\n-\n-    jvmti->RawMonitorExit(agent_lock);\n-}\n-\n-void JNICALL\n-Breakpoint(jvmtiEnv *jvmti_env, JNIEnv *env, jthread thr, jmethodID method,\n-        jlocation loc) {\n-    jclass klass;\n-    char *sig, *generic;\n-\n-    jvmti->RawMonitorEnter(agent_lock);\n-\n-    if (!callbacksEnabled) {\n-        jvmti->RawMonitorExit(agent_lock);\n-        return;\n-    }\n-\n-    NSK_DISPLAY0(\"Breakpoint event received\\n\");\n-    if (!NSK_JVMTI_VERIFY(jvmti_env->GetMethodDeclaringClass(method, &klass)))\n-        NSK_COMPLAIN0(\"TEST FAILURE: unable to get method declaring class\\n\\n\");\n-\n-    if (!NSK_JVMTI_VERIFY(jvmti_env->GetClassSignature(klass, &sig, &generic)))\n-        env->FatalError(\"Breakpoint: failed to obtain a class signature\\n\");\n-\n-    if (sig != NULL && (strcmp(sig, CLASS_SIG) == 0)) {\n-        NSK_DISPLAY1(\"method declaring class \\\"%s\\\"\\n\\tenabling SingleStep events ...\\n\",\n-            sig);\n-        if (!NSK_JVMTI_VERIFY(jvmti_env->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_SINGLE_STEP, thr))) {\n-            result = STATUS_FAILED;\n-            NSK_COMPLAIN0(\"TEST FAILURE: cannot enable SingleStep events\\n\\n\");\n-        }\n-    } else {\n-        result = STATUS_FAILED;\n-        NSK_COMPLAIN1(\"TEST FAILURE: unexpected breakpoint event in method of class \\\"%s\\\"\\n\\n\",\n-            sig);\n-    }\n-    jvmti->RawMonitorExit(agent_lock);\n-}\n-\n-void JNICALL\n-SingleStep(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,\n-        jmethodID method, jlocation location) {\n-    jclass klass;\n-    char *sig, *generic, *methNam, *methSig;\n-\n-    if (result == STATUS_FAILED) {\n-        return;\n-    }\n-\n-    NSK_DISPLAY0(\">>>> SingleStep event received\\n\");\n-\n-    if (!NSK_JVMTI_VERIFY(jvmti_env->GetMethodName(method, &methNam, &methSig, NULL))) {\n-        result = STATUS_FAILED;\n-        NSK_COMPLAIN0(\"TEST FAILED: unable to get method name during SingleStep callback\\n\\n\");\n-        return;\n-    }\n-    if (!NSK_JVMTI_VERIFY(jvmti_env->GetMethodDeclaringClass(method, &klass))) {\n-        result = STATUS_FAILED;\n-        NSK_COMPLAIN0(\"TEST FAILED: unable to get method declaring class during SingleStep callback\\n\\n\");\n-        return;\n-    }\n-    if (!NSK_JVMTI_VERIFY(jvmti_env->GetClassSignature(klass, &sig, &generic))) {\n-        result = STATUS_FAILED;\n-        NSK_COMPLAIN0(\"TEST FAILED: unable to obtain a class signature during SingleStep callback\\n\\n\");\n-        return;\n-    }\n-\n-    if (sig != NULL) {\n-        NSK_DISPLAY3(\n-            \"\\tmethod name: \\\"%s\\\"\\n\"\n-            \"\\tsignature: \\\"%s\\\"\\n\"\n-            \"\\tmethod declaring class: \\\"%s\\\"\\n\",\n-            methNam, methSig, sig);\n-\n-        if (stepEv[1] == 1) {\n-            result = STATUS_FAILED;\n-            NSK_COMPLAIN0(\"TEST FAILED: SingleStep event received after disabling the event generation\\n\\n\");\n-        }\n-        else if ((strcmp(methNam,METHODS[0]) == 0) &&\n-                (strcmp(methSig,METHOD_SIGS[0]) == 0) &&\n-                (strcmp(sig,CLASS_SIG) == 0)) {\n-            stepEv[0]++;\n-            NSK_DISPLAY1(\"CHECK PASSED: SingleStep event received for the method \\\"%s\\\" as expected\\n\",\n-                methNam);\n-        }\n-        else if ((strcmp(methNam,METHODS[1]) == 0) &&\n-                (strcmp(methSig,METHOD_SIGS[1]) == 0) &&\n-                (strcmp(sig,CLASS_SIG) == 0)) {\n-            stepEv[1]++;\n-            NSK_DISPLAY1(\n-                \"CHECK PASSED: SingleStep event received for the method \\\"%s\\\" as expected\\n\"\n-                \"\\tdisabling the event generation\\n\",\n-                methNam);\n-            if (!NSK_JVMTI_VERIFY(jvmti_env->SetEventNotificationMode(JVMTI_DISABLE, JVMTI_EVENT_SINGLE_STEP, thread))) {\n-                result = STATUS_FAILED;\n-                NSK_COMPLAIN0(\"TEST FAILED: cannot disable SingleStep events\\n\\n\");\n-            }\n-        }\n-    }\n-\n-    if (!NSK_JVMTI_VERIFY(jvmti_env->Deallocate((unsigned char*) methNam))) {\n-        result = STATUS_FAILED;\n-        NSK_COMPLAIN0(\"TEST FAILED: unable to deallocate memory pointed to method name\\n\\n\");\n-    }\n-    if (!NSK_JVMTI_VERIFY(jvmti_env->Deallocate((unsigned char*) methSig))) {\n-        result = STATUS_FAILED;\n-        NSK_COMPLAIN0(\"TEST FAILED: unable to deallocate memory pointed to method signature\\n\\n\");\n-    }\n-\n-    NSK_DISPLAY0(\"<<<<\\n\\n\");\n-}\n-\n-void JNICALL\n-VMStart(jvmtiEnv *jvmti_env, JNIEnv* jni_env) {\n-    jvmti->RawMonitorEnter(agent_lock);\n-\n-    callbacksEnabled = NSK_TRUE;\n-\n-    jvmti->RawMonitorExit(agent_lock);\n-}\n-\n-void JNICALL\n-VMDeath(jvmtiEnv *jvmti_env, JNIEnv* jni_env) {\n-    jvmti->RawMonitorEnter(agent_lock);\n-\n-    callbacksEnabled = NSK_FALSE;\n-\n-    jvmti->RawMonitorExit(agent_lock);\n-}\n-\/************************\/\n-\n-JNIEXPORT jint JNICALL\n-Java_nsk_jvmti_SingleStep_singlestep001_check(\n-        JNIEnv *env, jobject obj) {\n-    int i;\n-\n-    for (i=0; i<METH_NUM; i++)\n-        if (stepEv[i] == 0) {\n-            result = STATUS_FAILED;\n-            NSK_COMPLAIN1(\"TEST FAILED: no SingleStep events for the method \\\"%s\\\"\\n\\n\",\n-                METHODS[i]);\n-        }\n-\n-    return result;\n-}\n-\n-#ifdef STATIC_BUILD\n-JNIEXPORT jint JNICALL Agent_OnLoad_singlestep001(JavaVM *jvm, char *options, void *reserved) {\n-    return Agent_Initialize(jvm, options, reserved);\n-}\n-JNIEXPORT jint JNICALL Agent_OnAttach_singlestep001(JavaVM *jvm, char *options, void *reserved) {\n-    return Agent_Initialize(jvm, options, reserved);\n-}\n-JNIEXPORT jint JNI_OnLoad_singlestep001(JavaVM *jvm, char *options, void *reserved) {\n-    return JNI_VERSION_1_8;\n-}\n-#endif\n-jint Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {\n-    jvmtiCapabilities caps;\n-\n-    \/* init framework and parse options *\/\n-    if (!NSK_VERIFY(nsk_jvmti_parseOptions(options)))\n-        return JNI_ERR;\n-\n-    \/* create JVMTI environment *\/\n-    if (!NSK_VERIFY((jvmti =\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n-        return JNI_ERR;\n-\n-    \/* add capability to generate compiled method events *\/\n-    memset(&caps, 0, sizeof(jvmtiCapabilities));\n-    caps.can_generate_breakpoint_events = 1;\n-    caps.can_generate_single_step_events = 1;\n-    if (!NSK_JVMTI_VERIFY(jvmti->AddCapabilities(&caps)))\n-        return JNI_ERR;\n-\n-    if (!NSK_JVMTI_VERIFY(jvmti->GetCapabilities(&caps)))\n-        return JNI_ERR;\n-\n-    if (!caps.can_generate_single_step_events)\n-        NSK_DISPLAY0(\"Warning: generation of single step events is not implemented\\n\");\n-\n-    \/* set event callback *\/\n-    NSK_DISPLAY0(\"setting event callbacks ...\\n\");\n-    (void) memset(&callbacks, 0, sizeof(callbacks));\n-    callbacks.ClassLoad = &ClassLoad;\n-    callbacks.Breakpoint = &Breakpoint;\n-    callbacks.SingleStep = &SingleStep;\n-    callbacks.VMStart = &VMStart;\n-    callbacks.VMDeath = &VMDeath;\n-    if (!NSK_JVMTI_VERIFY(jvmti->SetEventCallbacks(&callbacks, sizeof(callbacks))))\n-        return JNI_ERR;\n-\n-    NSK_DISPLAY0(\"setting event callbacks done\\nenabling JVMTI events ...\\n\");\n-    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_START, NULL)))\n-        return JNI_ERR;\n-    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_DEATH, NULL)))\n-        return JNI_ERR;\n-    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_CLASS_LOAD, NULL)))\n-        return JNI_ERR;\n-    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_BREAKPOINT, NULL)))\n-        return JNI_ERR;\n-    NSK_DISPLAY0(\"enabling the events done\\n\\n\");\n-\n-    if (!NSK_JVMTI_VERIFY(jvmti->CreateRawMonitor(\"agent lock\", &agent_lock)))\n-        return JNI_ERR;\n-\n-    return JNI_OK;\n-}\n-\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/SingleStep\/singlestep001\/singlestep001.cpp","additions":0,"deletions":302,"binary":false,"changes":302,"status":"deleted"},{"patch":"@@ -1,68 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package nsk.jvmti.SingleStep;\n-\n-import java.io.*;\n-\n-import nsk.share.*;\n-import nsk.share.jvmti.*;\n-\n-\/**\n- * This test exercises the JVMTI event <code>SingleStep<\/code>.\n- * <br>It verifies that this event is sent only during the live\n- * phase of VM execution.<br>\n- * The test works as follows. The tested event is enabled in the\n- * <code>OnLoad<\/code> phase. Then all received <code>SingleStep<\/code>\n- * events is checked to be sent only during the live phase via\n- * the <code>GetPhase()<\/code> call.\n- *\/\n-public class singlestep002 {\n-    private Log log;\n-\n-    static {\n-        try {\n-            System.loadLibrary(\"singlestep002\");\n-        } catch (UnsatisfiedLinkError ule) {\n-            System.err.println(\"Could not load \\\"singlestep002\\\" library\");\n-            System.err.println(\"java.library.path:\"\n-                + System.getProperty(\"java.library.path\"));\n-            throw ule;\n-        }\n-    }\n-\n-    public static void main(String[] argv) {\n-        argv = nsk.share.jvmti.JVMTITest.commonInit(argv);\n-\n-        \/\/ produce JCK-like exit status\n-        System.exit(run(argv, System.out) + Consts.JCK_STATUS_BASE);\n-    }\n-\n-    public static int run(String argv[], PrintStream out) {\n-        return new singlestep002().runThis(argv, out);\n-    }\n-\n-    private int runThis(String argv[], PrintStream out) {\n-        return Consts.TEST_PASSED;\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/SingleStep\/singlestep002.java","additions":0,"deletions":68,"binary":false,"changes":68,"status":"deleted"},{"patch":"@@ -1,44 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/*\n- * @test\n- *\n- * @summary converted from VM Testbase nsk\/jvmti\/SingleStep\/singlestep002.\n- * VM Testbase keywords: [jpda, jvmti, onload_only_caps, noras]\n- * VM Testbase readme:\n- * DESCRIPTION\n- *     This test exercises the JVMTI event SingleStep.\n- *     It verifies that this event s sent only during the live phase\n- *     of VM execution.\n- *     The test works as follows. The tested event is enabled in the\n- *     'OnLoad' phase. Then all received SingleStep events is checked\n- *     to be sent only during the live phase via the GetPhase() call.\n- * COMMENTS\n- *\n- * @library \/vmTestbase\n- *          \/test\/lib\n- * @run main\/othervm\/native -agentlib:singlestep002=-waittime=5 nsk.jvmti.SingleStep.singlestep002\n- *\/\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/SingleStep\/singlestep002\/TestDescription.java","additions":0,"deletions":44,"binary":false,"changes":44,"status":"deleted"},{"patch":"@@ -1,33 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include \"native_thread.cpp\"\n-#include \"nsk_tools.cpp\"\n-#include \"jni_tools.cpp\"\n-#include \"jvmti_tools.cpp\"\n-#include \"agent_tools.cpp\"\n-#include \"jvmti_FollowRefObjects.cpp\"\n-#include \"Injector.cpp\"\n-#include \"JVMTITools.cpp\"\n-#include \"agent_common.cpp\"\n-#include \"singlestep002.cpp\"\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/SingleStep\/singlestep002\/libsinglestep002.cpp","additions":0,"deletions":33,"binary":false,"changes":33,"status":"deleted"},{"patch":"@@ -1,134 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include <stdio.h>\n-#include <stdlib.h>\n-#include <string.h>\n-#include <jvmti.h>\n-#include \"agent_common.h\"\n-\n-#include \"nsk_tools.h\"\n-#include \"JVMTITools.h\"\n-#include \"jvmti_tools.h\"\n-#include \"jni_tools.h\"\n-\n-extern \"C\" {\n-\n-#define STATUS_FAILED 2\n-#define PASSED 0\n-\n-static volatile jint result = PASSED;\n-static volatile long wrongStepEv = 0;\n-\n-static jvmtiEnv *jvmti = NULL;\n-static jvmtiEventCallbacks callbacks;\n-static jvmtiCapabilities caps;\n-\n-\/** callback functions **\/\n-void JNICALL\n-SingleStep(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,\n-        jmethodID method, jlocation location) {\n-    jvmtiPhase phase;\n-\n-    if (!NSK_JVMTI_VERIFY(jvmti_env->GetPhase(&phase))) {\n-        result = STATUS_FAILED;\n-        NSK_COMPLAIN0(\"TEST FAILED: unable to obtain phase of the VM execution during SingleStep callback\\n\\n\");\n-    }\n-    else {\n-        if (phase != JVMTI_PHASE_LIVE) {\n-            wrongStepEv++;\n-            result = STATUS_FAILED;\n-            NSK_COMPLAIN1(\"TEST FAILED: SingleStep event received during non-live phase %s\\n\",\n-                TranslatePhase(phase));\n-        }\n-    }\n-}\n-\n-void JNICALL\n-VMDeath(jvmtiEnv *jvmti_env, JNIEnv *env) {\n-    NSK_DISPLAY0(\"VMDeath event received\\n\");\n-\n-    if (wrongStepEv != 0) {\n-        NSK_COMPLAIN1(\n-            \"TEST FAILED: there are %d SingleStep events\\n\"\n-            \"sent during non-live phase of the VM execution\\n\",\n-            wrongStepEv);\n-    }\n-\n-    if (result == STATUS_FAILED)\n-        exit(95 + STATUS_FAILED);\n-}\n-\/************************\/\n-\n-#ifdef STATIC_BUILD\n-JNIEXPORT jint JNICALL Agent_OnLoad_singlestep002(JavaVM *jvm, char *options, void *reserved) {\n-    return Agent_Initialize(jvm, options, reserved);\n-}\n-JNIEXPORT jint JNICALL Agent_OnAttach_singlestep002(JavaVM *jvm, char *options, void *reserved) {\n-    return Agent_Initialize(jvm, options, reserved);\n-}\n-JNIEXPORT jint JNI_OnLoad_singlestep002(JavaVM *jvm, char *options, void *reserved) {\n-    return JNI_VERSION_1_8;\n-}\n-#endif\n-jint Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {\n-    \/* init framework and parse options *\/\n-    if (!NSK_VERIFY(nsk_jvmti_parseOptions(options)))\n-        return JNI_ERR;\n-\n-    \/* create JVMTI environment *\/\n-    if (!NSK_VERIFY((jvmti =\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n-        return JNI_ERR;\n-\n-    \/* add capability to generate compiled method events *\/\n-    memset(&caps, 0, sizeof(jvmtiCapabilities));\n-    caps.can_generate_single_step_events = 1;\n-    if (!NSK_JVMTI_VERIFY(jvmti->AddCapabilities(&caps)))\n-        return JNI_ERR;\n-\n-    if (!NSK_JVMTI_VERIFY(jvmti->GetCapabilities(&caps)))\n-        return JNI_ERR;\n-\n-    if (!caps.can_generate_single_step_events)\n-        NSK_DISPLAY0(\"Warning: generation of single step events is not implemented\\n\");\n-\n-    \/* set event callback *\/\n-    NSK_DISPLAY0(\"setting event callbacks ...\\n\");\n-    (void) memset(&callbacks, 0, sizeof(callbacks));\n-    callbacks.SingleStep = &SingleStep;\n-    callbacks.VMDeath = &VMDeath;\n-    if (!NSK_JVMTI_VERIFY(jvmti->SetEventCallbacks(&callbacks, sizeof(callbacks))))\n-        return JNI_ERR;\n-\n-    NSK_DISPLAY0(\"setting event callbacks done\\nenabling JVMTI events ...\\n\");\n-    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_SINGLE_STEP, NULL)))\n-        return JNI_ERR;\n-    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_DEATH, NULL)))\n-        return JNI_ERR;\n-    NSK_DISPLAY0(\"enabling the events done\\n\\n\");\n-\n-    return JNI_OK;\n-}\n-\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/SingleStep\/singlestep002\/singlestep002.cpp","additions":0,"deletions":134,"binary":false,"changes":134,"status":"deleted"},{"patch":"@@ -1,91 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package nsk.jvmti.SingleStep;\n-\n-import java.io.*;\n-\n-import nsk.share.*;\n-import nsk.share.jvmti.*;\n-\n-\/**\n- * This test exercises the JVMTI event <code>SingleStep<\/code>.\n- * <br>It verifies that no single step event will be generated from\n- * within native methods.<br>\n- * The test works as follows. Breakpoint is set at special method\n- * <code>bpMethod()<\/code>. Upon reaching the breakpoint, agent\n- * enables <code>SingleStep<\/code> event generation and checks the\n- * events. The java part calls native method <code>nativeMethod()<\/code>\n- * which calls another native <code>anotherNativeMethod()<\/code>\n- * in order to provoke the SingleStep events from within native\n- * methods. When <code>bpMethod()<\/code> is leaved and accordingly,\n- * the program returns to the calling method <code>runThis()<\/code>,\n- * the agent disables the event generation.\n- *\/\n-public class singlestep003 {\n-    static {\n-        try {\n-            System.loadLibrary(\"singlestep003\");\n-        } catch (UnsatisfiedLinkError ule) {\n-            System.err.println(\"Could not load \\\"singlestep003\\\" library\");\n-            System.err.println(\"java.library.path:\"\n-                + System.getProperty(\"java.library.path\"));\n-            throw ule;\n-        }\n-    }\n-\n-    native void nativeMethod();\n-    native void anotherNativeMethod(int i);\n-\n-    native int check();\n-\n-    public static void main(String[] argv) {\n-        argv = nsk.share.jvmti.JVMTITest.commonInit(argv);\n-\n-        \/\/ produce JCK-like exit status\n-        System.exit(run(argv, System.out) + Consts.JCK_STATUS_BASE);\n-    }\n-\n-    public static int run(String argv[], PrintStream out) {\n-        return new singlestep003().runThis(argv, out);\n-    }\n-\n-    private int runThis(String argv[], PrintStream out) {\n-        ArgumentHandler argHandler = new ArgumentHandler(argv);\n-        Log log = new Log(out, argHandler);\n-\n-        log.display(\"\\nReaching a breakpoint method ...\\n\");\n-        bpMethod();\n-        log.display(\"The breakpoint method leaved ...\");\n-\n-        return check();\n-    }\n-\n-    \/**\n-     * dummy method used to reach breakpoint, enable the SingleStep\n-     * event in the agent and provoke SingleStep for native method\n-     *\/\n-    private void bpMethod() {\n-        nativeMethod();\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/SingleStep\/singlestep003.java","additions":0,"deletions":91,"binary":false,"changes":91,"status":"deleted"},{"patch":"@@ -1,49 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/*\n- * @test\n- *\n- * @summary converted from VM Testbase nsk\/jvmti\/SingleStep\/singlestep003.\n- * VM Testbase keywords: [quick, jpda, jvmti, onload_only_caps, noras]\n- * VM Testbase readme:\n- * DESCRIPTION\n- *     This test exercises the JVMTI event SingleStep.\n- *     It verifies that no single step event will be generated from\n- *     within native methods.\n- *     The test works as follows. Breakpoint is set at special method\n- *     'bpMethod()'. Upon reaching the breakpoint, agent enables\n- *     SingleStep event generation and checks the events. The java part\n- *     calls native method 'nativeMethod()' which calls another native\n- *     'anotherNativeMethod()' in order to provoke the SingleStep events\n- *     from within native methods. When 'bpMethod()' is leaved and\n- *     accordingly, the program returns to the calling method 'runThis()',\n- *     the agent disables the event generation.\n- * COMMENTS\n- *\n- * @library \/vmTestbase\n- *          \/test\/lib\n- * @run main\/othervm\/native -agentlib:singlestep003=-waittime=5 nsk.jvmti.SingleStep.singlestep003\n- *\/\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/SingleStep\/singlestep003\/TestDescription.java","additions":0,"deletions":49,"binary":false,"changes":49,"status":"deleted"},{"patch":"@@ -1,33 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include \"native_thread.cpp\"\n-#include \"nsk_tools.cpp\"\n-#include \"jni_tools.cpp\"\n-#include \"jvmti_tools.cpp\"\n-#include \"agent_tools.cpp\"\n-#include \"jvmti_FollowRefObjects.cpp\"\n-#include \"Injector.cpp\"\n-#include \"JVMTITools.cpp\"\n-#include \"agent_common.cpp\"\n-#include \"singlestep003.cpp\"\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/SingleStep\/singlestep003\/libsinglestep003.cpp","additions":0,"deletions":33,"binary":false,"changes":33,"status":"deleted"},{"patch":"@@ -1,343 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include <stdio.h>\n-#include <string.h>\n-#include <jvmti.h>\n-#include \"agent_common.h\"\n-\n-#include \"nsk_tools.h\"\n-#include \"JVMTITools.h\"\n-#include \"jvmti_tools.h\"\n-#include \"jni_tools.h\"\n-\n-extern \"C\" {\n-\n-#define STATUS_FAILED 2\n-#define PASSED 0\n-\n-\/* tested methods *\/\n-#define METH_NUM 4\n-static const char *METHODS[][2] = {\n-    { \"bpMethod\", \"()V\" },\n-    { \"nativeMethod\", \"()V\" },\n-    { \"anotherNativeMethod\", \"(I)V\" },\n-    { \"runThis\", \"([Ljava\/lang\/String;Ljava\/io\/PrintStream;)I\" }\n-};\n-\n-\/* event counters for the tested methods and expected numbers\n- of the events *\/\n-static volatile long stepEv[][2] = {\n-    { 0, 1 },\n-    { 0, 0 },\n-    { 0, 0 },\n-    { 0, 1 }\n-};\n-\n-static const char *CLASS_SIG =\n-    \"Lnsk\/jvmti\/SingleStep\/singlestep003;\";\n-\n-static volatile jint result = PASSED;\n-static jvmtiEnv *jvmti = NULL;\n-static jvmtiEventCallbacks callbacks;\n-\n-static volatile int callbacksEnabled = NSK_FALSE;\n-static jrawMonitorID agent_lock;\n-\n-static void setBP(jvmtiEnv *jvmti_env, JNIEnv *env, jclass klass) {\n-    jmethodID mid;\n-\n-    if (!NSK_JNI_VERIFY(env, (mid = env->GetMethodID(klass, METHODS[0][0], METHODS[0][1])) != NULL))\n-        env->FatalError(\"failed to get ID for the java method\\n\");\n-\n-    if (!NSK_JVMTI_VERIFY(jvmti_env->SetBreakpoint(mid, 0)))\n-        env->FatalError(\"failed to set breakpoint\\n\");\n-}\n-\n-\/** callback functions **\/\n-void JNICALL\n-ClassLoad(jvmtiEnv *jvmti_env, JNIEnv *env, jthread thread, jclass klass) {\n-    char *sig, *generic;\n-\n-    jvmti->RawMonitorEnter(agent_lock);\n-\n-    if (!callbacksEnabled) {\n-        jvmti->RawMonitorExit(agent_lock);\n-        return;\n-    }\n-\n-    if (!NSK_JVMTI_VERIFY(jvmti_env->GetClassSignature(klass, &sig, &generic)))\n-        env->FatalError(\"failed to obtain a class signature\\n\");\n-\n-    if (sig != NULL && (strcmp(sig, CLASS_SIG) == 0)) {\n-        NSK_DISPLAY1(\n-            \"ClassLoad event received for the class \\\"%s\\\"\\n\"\n-            \"\\tsetting breakpoint ...\\n\",\n-            sig);\n-        setBP(jvmti_env, env, klass);\n-    }\n-\n-    jvmti->RawMonitorExit(agent_lock);\n-}\n-\n-void JNICALL\n-VMStart(jvmtiEnv *jvmti_env, JNIEnv* jni_env) {\n-    jvmti->RawMonitorEnter(agent_lock);\n-\n-    callbacksEnabled = NSK_TRUE;\n-\n-    jvmti->RawMonitorExit(agent_lock);\n-}\n-\n-\n-void JNICALL\n-VMDeath(jvmtiEnv *jvmti_env, JNIEnv* jni_env) {\n-    jvmti->RawMonitorEnter(agent_lock);\n-\n-    callbacksEnabled = NSK_FALSE;\n-\n-    jvmti->RawMonitorExit(agent_lock);\n-}\n-\n-void JNICALL\n-Breakpoint(jvmtiEnv *jvmti_env, JNIEnv *env, jthread thr, jmethodID method,\n-        jlocation loc) {\n-    jclass klass;\n-    char *sig, *generic;\n-\n-    jvmti->RawMonitorEnter(agent_lock);\n-\n-    if (!callbacksEnabled) {\n-        jvmti->RawMonitorExit(agent_lock);\n-        return;\n-    }\n-\n-    NSK_DISPLAY0(\"Breakpoint event received\\n\");\n-    if (!NSK_JVMTI_VERIFY(jvmti_env->GetMethodDeclaringClass(method, &klass)))\n-        NSK_COMPLAIN0(\"TEST FAILURE: unable to get method declaring class\\n\\n\");\n-\n-    if (!NSK_JVMTI_VERIFY(jvmti_env->GetClassSignature(klass, &sig, &generic)))\n-        env->FatalError(\"Breakpoint: failed to obtain a class signature\\n\");\n-\n-    if (sig != NULL && (strcmp(sig, CLASS_SIG) == 0)) {\n-        NSK_DISPLAY1(\"method declaring class \\\"%s\\\"\\n\\tenabling SingleStep events ...\\n\",\n-            sig);\n-        if (!NSK_JVMTI_VERIFY(jvmti_env->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_SINGLE_STEP, thr))) {\n-            result = STATUS_FAILED;\n-            NSK_COMPLAIN0(\"TEST FAILURE: cannot enable SingleStep events\\n\\n\");\n-        }\n-    } else {\n-        result = STATUS_FAILED;\n-        NSK_COMPLAIN1(\"TEST FAILURE: unexpected breakpoint event in method of class \\\"%s\\\"\\n\\n\",\n-            sig);\n-    }\n-\n-    jvmti->RawMonitorExit(agent_lock);\n-}\n-\n-void JNICALL\n-SingleStep(jvmtiEnv *jvmti_env, JNIEnv* jni_env, jthread thread,\n-        jmethodID method, jlocation location) {\n-    jclass klass;\n-    char *sig, *generic, *methNam, *methSig;\n-    int i;\n-\n-    if (result == STATUS_FAILED) {\n-        return;\n-    }\n-\n-    NSK_DISPLAY0(\">>>> SingleStep event received\\n\");\n-\n-    if (!NSK_JVMTI_VERIFY(jvmti_env->GetMethodName(method, &methNam, &methSig, NULL))) {\n-        result = STATUS_FAILED;\n-        NSK_COMPLAIN0(\"TEST FAILED: unable to get method name during SingleStep callback\\n\\n\");\n-        return;\n-    }\n-    if (!NSK_JVMTI_VERIFY(jvmti_env->GetMethodDeclaringClass(method, &klass))) {\n-        result = STATUS_FAILED;\n-        NSK_COMPLAIN0(\"TEST FAILED: unable to get method declaring class during SingleStep callback\\n\\n\");\n-        return;\n-    }\n-    if (!NSK_JVMTI_VERIFY(jvmti_env->GetClassSignature(klass, &sig, &generic))) {\n-        result = STATUS_FAILED;\n-        NSK_COMPLAIN0(\"TEST FAILED: unable to obtain a class signature during SingleStep callback\\n\\n\");\n-        return;\n-    }\n-\n-    if (sig != NULL) {\n-        if (stepEv[METH_NUM-1][0] == 1) {\n-            result = STATUS_FAILED;\n-            NSK_COMPLAIN0(\"TEST FAILED: SingleStep event received after disabling the event generation\\n\\n\");\n-            return;\n-        }\n-\n-        for (i=0; i<METH_NUM; i++) {\n-            if ((strcmp(methNam,METHODS[i][0]) == 0) &&\n-                    (strcmp(methSig,METHODS[i][1]) == 0) &&\n-                    (strcmp(sig,CLASS_SIG) == 0)) {\n-                stepEv[i][0]++;\n-\n-                if (stepEv[i][1] == 1) {\n-                    NSK_DISPLAY3(\n-                        \"CHECK PASSED: SingleStep event received for the method:\\n\"\n-                        \"\\t \\\"%s %s\\\" of class \\\"%s\\\"\\n\"\n-                        \"\\tas expected\\n\",\n-                        methNam, methSig, sig);\n-                } else {\n-                    result = STATUS_FAILED;\n-                    NSK_COMPLAIN3(\n-                        \"TEST FAILED: SingleStep event received for the method:\\n\"\n-                        \"\\t \\\"%s %s\\\" of class \\\"%s\\\"\\n\",\n-                        methNam, methSig, sig);\n-                }\n-\n-                if (i == (METH_NUM-1)) {\n-                    NSK_DISPLAY0(\"Disabling the single step event generation\\n\");\n-                    if (!NSK_JVMTI_VERIFY(jvmti_env->SetEventNotificationMode(JVMTI_DISABLE, JVMTI_EVENT_SINGLE_STEP, thread))) {\n-                        result = STATUS_FAILED;\n-                        NSK_COMPLAIN0(\"TEST FAILED: cannot disable SingleStep events\\n\\n\");\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    if (!NSK_JVMTI_VERIFY(jvmti_env->Deallocate((unsigned char*) methNam))) {\n-        result = STATUS_FAILED;\n-        NSK_COMPLAIN0(\"TEST FAILED: unable to deallocate memory pointed to method name\\n\\n\");\n-    }\n-    if (!NSK_JVMTI_VERIFY(jvmti_env->Deallocate((unsigned char*) methSig))) {\n-        result = STATUS_FAILED;\n-        NSK_COMPLAIN0(\"TEST FAILED: unable to deallocate memory pointed to method signature\\n\\n\");\n-    }\n-\n-    NSK_DISPLAY0(\"<<<<\\n\\n\");\n-}\n-\/************************\/\n-\n-\/* dummy method used only to provoke SingleStep events *\/\n-JNIEXPORT void JNICALL\n-Java_nsk_jvmti_SingleStep_singlestep003_anotherNativeMethod(\n-        JNIEnv *env, jobject obj, jint i) {\n-    NSK_DISPLAY0(\"inside the anotherNativeMethod()\\n\\n\");\n-}\n-\n-\/* dummy method used only to provoke SingleStep events *\/\n-JNIEXPORT void JNICALL\n-Java_nsk_jvmti_SingleStep_singlestep003_nativeMethod(\n-        JNIEnv *env, jobject obj) {\n-    jint i = 0;\n-\n-    NSK_DISPLAY0(\"inside the nativeMethod()\\n\\n\");\n-    i++;\n-\n-    Java_nsk_jvmti_SingleStep_singlestep003_anotherNativeMethod(env, obj, i);\n-}\n-\n-JNIEXPORT jint JNICALL\n-Java_nsk_jvmti_SingleStep_singlestep003_check(\n-        JNIEnv *env, jobject obj) {\n-    int i;\n-\n-    for (i=0; i<METH_NUM; i++)\n-        if (stepEv[i][0] == 0) {\n-            if (stepEv[i][1] == 0) {\n-                NSK_DISPLAY1(\"CHECK PASSED: no SingleStep events for the method \\\"%s\\\" as expected\\n\\n\",\n-                    METHODS[i][0]);\n-            }\n-            else {\n-                result = STATUS_FAILED;\n-                NSK_COMPLAIN1(\"TEST FAILED: no SingleStep events for the method \\\"%s\\\"\\n\\n\",\n-                    METHODS[i][0]);\n-            }\n-        }\n-\n-    return result;\n-}\n-\n-#ifdef STATIC_BUILD\n-JNIEXPORT jint JNICALL Agent_OnLoad_singlestep003(JavaVM *jvm, char *options, void *reserved) {\n-    return Agent_Initialize(jvm, options, reserved);\n-}\n-JNIEXPORT jint JNICALL Agent_OnAttach_singlestep003(JavaVM *jvm, char *options, void *reserved) {\n-    return Agent_Initialize(jvm, options, reserved);\n-}\n-JNIEXPORT jint JNI_OnLoad_singlestep003(JavaVM *jvm, char *options, void *reserved) {\n-    return JNI_VERSION_1_8;\n-}\n-#endif\n-jint Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {\n-    jvmtiCapabilities caps;\n-\n-    \/* init framework and parse options *\/\n-    if (!NSK_VERIFY(nsk_jvmti_parseOptions(options)))\n-        return JNI_ERR;\n-\n-    \/* create JVMTI environment *\/\n-    if (!NSK_VERIFY((jvmti =\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n-        return JNI_ERR;\n-\n-    \/* add capability to generate compiled method events *\/\n-    memset(&caps, 0, sizeof(jvmtiCapabilities));\n-    caps.can_generate_breakpoint_events = 1;\n-    caps.can_generate_single_step_events = 1;\n-    if (!NSK_JVMTI_VERIFY(jvmti->AddCapabilities(&caps)))\n-        return JNI_ERR;\n-\n-    if (!NSK_JVMTI_VERIFY(jvmti->GetCapabilities(&caps)))\n-        return JNI_ERR;\n-    if (!caps.can_generate_single_step_events)\n-        NSK_DISPLAY0(\"Warning: generation of single step events is not implemented\\n\");\n-\n-    \/* set event callback *\/\n-    NSK_DISPLAY0(\"setting event callbacks ...\\n\");\n-    (void) memset(&callbacks, 0, sizeof(callbacks));\n-    callbacks.ClassLoad = &ClassLoad;\n-    callbacks.Breakpoint = &Breakpoint;\n-    callbacks.SingleStep = &SingleStep;\n-    callbacks.VMStart = &VMStart;\n-    callbacks.VMDeath = &VMDeath;\n-\n-    if (!NSK_JVMTI_VERIFY(jvmti->SetEventCallbacks(&callbacks, sizeof(callbacks))))\n-        return JNI_ERR;\n-\n-    NSK_DISPLAY0(\"setting event callbacks done\\nenabling JVMTI events ...\\n\");\n-    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_START, NULL)))\n-        return JNI_ERR;\n-    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_DEATH, NULL)))\n-        return JNI_ERR;\n-    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_CLASS_LOAD, NULL)))\n-        return JNI_ERR;\n-    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_BREAKPOINT, NULL)))\n-        return JNI_ERR;\n-    NSK_DISPLAY0(\"enabling the events done\\n\\n\");\n-\n-    if (jvmti->CreateRawMonitor(\"agent_lock\", &agent_lock) != JVMTI_ERROR_NONE) {\n-        return JNI_ERR;\n-    }\n-\n-    return JNI_OK;\n-}\n-\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/SingleStep\/singlestep003\/singlestep003.cpp","additions":0,"deletions":343,"binary":false,"changes":343,"status":"deleted"},{"patch":"@@ -1,86 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package nsk.jvmti.ThreadEnd;\n-\n-import java.io.PrintStream;\n-\n-public class threadend001 {\n-\n-    final static int JCK_STATUS_BASE = 95;\n-    final static int THREADS_LIMIT = 100;\n-    final static String NAME_PREFIX = \"threadend001-\";\n-\n-    static {\n-        try {\n-            System.loadLibrary(\"threadend001\");\n-        } catch (UnsatisfiedLinkError ule) {\n-            System.err.println(\"Could not load threadend001 library\");\n-            System.err.println(\"java.library.path:\"\n-                + System.getProperty(\"java.library.path\"));\n-            throw ule;\n-        }\n-    }\n-\n-    native static void getReady(int i, String name);\n-    native static int check();\n-\n-    static volatile int thrCount = THREADS_LIMIT;\n-\n-    public static void main(String args[]) {\n-        args = nsk.share.jvmti.JVMTITest.commonInit(args);\n-\n-        \/\/ produce JCK-like exit status.\n-        System.exit(run(args, System.out) + JCK_STATUS_BASE);\n-    }\n-\n-    public static int run(String args[], PrintStream out) {\n-        TestThread t = new TestThread(NAME_PREFIX + thrCount);\n-        getReady(THREADS_LIMIT, NAME_PREFIX);\n-        t.start();\n-        try {\n-            t.join();\n-        } catch (InterruptedException e) {\n-            throw new Error(\"Unexpected: \" + e);\n-        }\n-        return check();\n-    }\n-\n-    static class TestThread extends Thread {\n-        public TestThread(String name) {\n-            super(name);\n-        }\n-        public void run() {\n-            thrCount--;\n-            if (thrCount > 0) {\n-                TestThread t = new TestThread(NAME_PREFIX + thrCount);\n-                t.start();\n-                try {\n-                    t.join();\n-                } catch (InterruptedException e) {\n-                    throw new Error(\"Unexpected: \" + e);\n-                }\n-            }\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/ThreadEnd\/threadend001.java","additions":0,"deletions":86,"binary":false,"changes":86,"status":"deleted"},{"patch":"@@ -1,42 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/*\n- * @test\n- *\n- * @summary converted from VM Testbase nsk\/jvmti\/ThreadEnd\/threadend001.\n- * VM Testbase keywords: [quick, jpda, jvmti, noras]\n- * VM Testbase readme:\n- * DESCRIPTION\n- *     The test exercises JVMTI event callback function ThreadEnd.\n- *     The test checks if the event is ganerated by a terminating\n- *     thread after its initial method has finished execution.\n- * COMMENTS\n- *     Ported from JVMDI.\n- *\n- * @library \/vmTestbase\n- *          \/test\/lib\n- * @run main\/othervm\/native -agentlib:threadend001 nsk.jvmti.ThreadEnd.threadend001\n- *\/\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/ThreadEnd\/threadend001\/TestDescription.java","additions":0,"deletions":42,"binary":false,"changes":42,"status":"deleted"},{"patch":"@@ -1,33 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include \"native_thread.cpp\"\n-#include \"nsk_tools.cpp\"\n-#include \"jni_tools.cpp\"\n-#include \"jvmti_tools.cpp\"\n-#include \"agent_tools.cpp\"\n-#include \"jvmti_FollowRefObjects.cpp\"\n-#include \"Injector.cpp\"\n-#include \"JVMTITools.cpp\"\n-#include \"agent_common.cpp\"\n-#include \"threadend001.cpp\"\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/ThreadEnd\/threadend001\/libthreadend001.cpp","additions":0,"deletions":33,"binary":false,"changes":33,"status":"deleted"},{"patch":"@@ -1,159 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include <stdio.h>\n-#include <string.h>\n-#include \"jvmti.h\"\n-#include \"agent_common.h\"\n-#include \"JVMTITools.h\"\n-\n-extern \"C\" {\n-\n-\n-#define PASSED 0\n-#define STATUS_FAILED 2\n-\n-static jvmtiEnv *jvmti = NULL;\n-static jvmtiEventCallbacks callbacks;\n-static jint result = PASSED;\n-static jboolean printdump = JNI_FALSE;\n-static int eventsCount = 0;\n-static int eventsExpected = 0;\n-static const char *prefix = NULL;\n-\n-void JNICALL ThreadEnd(jvmtiEnv *jvmti_env, JNIEnv *env, jthread thread) {\n-    jvmtiError err;\n-    jvmtiThreadInfo inf;\n-    char name[32];\n-\n-    err = jvmti_env->GetThreadInfo(thread, &inf);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(GetThreadInfo#%d) unexpected error: %s (%d)\\n\",\n-               eventsCount, TranslateError(err), err);\n-        result = STATUS_FAILED;\n-    }\n-    if (printdump == JNI_TRUE) {\n-        printf(\">>> %s\\n\", inf.name);\n-    }\n-    if (inf.name != NULL && strstr(inf.name, prefix) == inf.name) {\n-        eventsCount++;\n-        sprintf(name, \"%s%d\", prefix, eventsCount);\n-        if (inf.name == NULL || strcmp(name, inf.name) != 0) {\n-            printf(\"(#%d) wrong thread name: \\\"%s\\\"\",\n-                   eventsCount, inf.name);\n-            printf(\", expected: \\\"%s\\\"\\n\", name);\n-            result = STATUS_FAILED;\n-        }\n-    }\n-}\n-\n-#ifdef STATIC_BUILD\n-JNIEXPORT jint JNICALL Agent_OnLoad_threadend001(JavaVM *jvm, char *options, void *reserved) {\n-    return Agent_Initialize(jvm, options, reserved);\n-}\n-JNIEXPORT jint JNICALL Agent_OnAttach_threadend001(JavaVM *jvm, char *options, void *reserved) {\n-    return Agent_Initialize(jvm, options, reserved);\n-}\n-JNIEXPORT jint JNI_OnLoad_threadend001(JavaVM *jvm, char *options, void *reserved) {\n-    return JNI_VERSION_1_8;\n-}\n-#endif\n-jint Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {\n-    jvmtiError err;\n-    jint res;\n-\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n-        printdump = JNI_TRUE;\n-    }\n-\n-    res = jvm->GetEnv((void **) &jvmti, JVMTI_VERSION_1_1);\n-    if (res != JNI_OK || jvmti == NULL) {\n-        printf(\"Wrong result of a valid call to GetEnv!\\n\");\n-        return JNI_ERR;\n-    }\n-\n-    callbacks.ThreadEnd = &ThreadEnd;\n-    err = jvmti->SetEventCallbacks(&callbacks, sizeof(callbacks));\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(SetEventCallbacks) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        return JNI_ERR;\n-    }\n-\n-    return JNI_OK;\n-}\n-\n-JNIEXPORT void JNICALL\n-Java_nsk_jvmti_ThreadEnd_threadend001_getReady(JNIEnv *env,\n-        jclass cls, jint i, jstring name) {\n-    jvmtiError err;\n-\n-    if (jvmti == NULL) {\n-        printf(\"JVMTI client was not properly loaded!\\n\");\n-        return;\n-    }\n-\n-    prefix = env->GetStringUTFChars(name, NULL);\n-    if (prefix == NULL) {\n-        printf(\"Failed to copy UTF-8 string!\\n\");\n-        result = STATUS_FAILED;\n-        return;\n-    }\n-\n-    err = jvmti->SetEventNotificationMode(JVMTI_ENABLE,\n-            JVMTI_EVENT_THREAD_END, NULL);\n-    if (err == JVMTI_ERROR_NONE) {\n-        eventsExpected = i;\n-    } else {\n-        printf(\"Failed to enable JVMTI_EVENT_THREAD_END: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-    }\n-}\n-\n-JNIEXPORT jint JNICALL\n-Java_nsk_jvmti_ThreadEnd_threadend001_check(JNIEnv *env, jclass cls) {\n-    jvmtiError err;\n-\n-    if (jvmti == NULL) {\n-        printf(\"JVMTI client was not properly loaded!\\n\");\n-        return STATUS_FAILED;\n-    }\n-\n-    err = jvmti->SetEventNotificationMode(JVMTI_DISABLE,\n-            JVMTI_EVENT_THREAD_END, NULL);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"Failed to disable JVMTI_EVENT_THREAD_END: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-    }\n-\n-    if (eventsCount != eventsExpected) {\n-        printf(\"Wrong number of thread end events: %d, expected: %d\\n\",\n-            eventsCount, eventsExpected);\n-        result = STATUS_FAILED;\n-    }\n-    return result;\n-}\n-\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/ThreadEnd\/threadend001\/threadend001.cpp","additions":0,"deletions":159,"binary":false,"changes":159,"status":"deleted"},{"patch":"@@ -1,82 +0,0 @@\n-\/*\n- * Copyright (c) 2004, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package nsk.jvmti.ThreadEnd;\n-\n-import java.io.PrintStream;\n-\n-import nsk.share.jvmti.*;\n-import nsk.share.*;\n-\n-public class threadend002 extends DebugeeClass {\n-\n-    \/\/ run test from command line\n-    public static void main(String argv[]) {\n-        argv = nsk.share.jvmti.JVMTITest.commonInit(argv);\n-\n-        \/\/ JCK-compatible exit\n-        System.exit(run(argv, System.out) + Consts.JCK_STATUS_BASE);\n-    }\n-\n-    \/\/ run test from JCK-compatible environment\n-    public static int run(String argv[], PrintStream out) {\n-        return new threadend002().runIt(argv, out);\n-    }\n-\n-    Log.Logger logger;\n-\n-\n-    \/\/ run debuggee\n-    public int runIt(String argv[], PrintStream out) {\n-\n-        ArgumentHandler argHandler = new ArgumentHandler(argv);\n-        logger = new Log.Logger(new Log(out, argHandler), \"debuggee> \");\n-\n-        int status = threadend002.checkStatus(Consts.TEST_PASSED);\n-\n-        threadend002Thread thrd = new threadend002Thread();\n-        thrd.start();\n-\n-        try {\n-            thrd.join();\n-        } catch(InterruptedException e) {\n-            logger.complain(\"Unexpected exception \" + e);\n-            e.printStackTrace();\n-            return Consts.TEST_FAILED;\n-        }\n-\n-        int currStatus = threadend002.checkStatus(Consts.TEST_PASSED);\n-        if (currStatus != Consts.TEST_PASSED)\n-            status = currStatus;\n-\n-        return status;\n-    }\n-\n-    class threadend002Thread extends Thread {\n-\n-        public void run() {\n-            logger.display(\"thread finished\");\n-        }\n-    }\n-\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/ThreadEnd\/threadend002.java","additions":0,"deletions":82,"binary":false,"changes":82,"status":"deleted"},{"patch":"@@ -1,41 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/*\n- * @test\n- *\n- * @summary converted from VM Testbase nsk\/jvmti\/ThreadEnd\/threadend002.\n- * VM Testbase keywords: [quick, jpda, jvmti, noras]\n- * VM Testbase readme:\n- * DESCRIPTION\n- *     The test exercises JVMTI event callback function THREAD_END.\n- *     The test enables this event during OnLoad phase. The test fails\n- *     if no THREAD_END event is received\n- * COMMENTS\n- *\n- * @library \/vmTestbase\n- *          \/test\/lib\n- * @run main\/othervm\/native -agentlib:threadend002=-waittime=5 nsk.jvmti.ThreadEnd.threadend002\n- *\/\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/ThreadEnd\/threadend002\/TestDescription.java","additions":0,"deletions":41,"binary":false,"changes":41,"status":"deleted"},{"patch":"@@ -1,33 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include \"native_thread.cpp\"\n-#include \"nsk_tools.cpp\"\n-#include \"jni_tools.cpp\"\n-#include \"jvmti_tools.cpp\"\n-#include \"agent_tools.cpp\"\n-#include \"jvmti_FollowRefObjects.cpp\"\n-#include \"Injector.cpp\"\n-#include \"JVMTITools.cpp\"\n-#include \"agent_common.cpp\"\n-#include \"threadend002.cpp\"\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/ThreadEnd\/threadend002\/libthreadend002.cpp","additions":0,"deletions":33,"binary":false,"changes":33,"status":"deleted"},{"patch":"@@ -1,167 +0,0 @@\n-\/*\n- * Copyright (c) 2004, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include <string.h>\n-#include \"jvmti.h\"\n-#include \"agent_common.h\"\n-#include \"jni_tools.h\"\n-#include \"jvmti_tools.h\"\n-#include \"JVMTITools.h\"\n-\n-extern \"C\" {\n-\n-\/* ============================================================================= *\/\n-\n-\/* scaffold objects *\/\n-static jvmtiEnv *jvmti = NULL;\n-static jlong timeout = 0;\n-\n-static int eventCount = 0;\n-\n-\/* ============================================================================= *\/\n-\n-JNIEXPORT void JNICALL\n-cbThreadEnd(jvmtiEnv* jvmti, JNIEnv* jni_env, jthread thread) {\n-\n-    eventCount++;\n-}\n-\n-\/* ============================================================================= *\/\n-\n-static int\n-enableEvent(jvmtiEventMode enable, jvmtiEvent event) {\n-\n-    if (enable == JVMTI_ENABLE) {\n-        NSK_DISPLAY1(\"enabling %s\\n\", TranslateEvent(event));\n-    } else {\n-        NSK_DISPLAY1(\"disabling %s\\n\", TranslateEvent(event));\n-    }\n-\n-    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(enable, event, NULL))) {\n-        nsk_jvmti_setFailStatus();\n-        return NSK_FALSE;\n-    }\n-\n-    return NSK_TRUE;\n-}\n-\n-\/* ============================================================================= *\/\n-\n-int checkEvents() {\n-\n-    int result = NSK_TRUE;\n-\n-    if (eventCount == 0) {\n-        nsk_jvmti_setFailStatus();\n-        NSK_COMPLAIN0(\"Number of THREAD_END events must be greater than 0\\n\");\n-        nsk_jvmti_setFailStatus();\n-        result = NSK_FALSE;\n-    }\n-\n-    return result;\n-}\n-\n-\/* ============================================================================= *\/\n-\n-static int\n-setCallBacks() {\n-    jvmtiEventCallbacks eventCallbacks;\n-    memset(&eventCallbacks, 0, sizeof(eventCallbacks));\n-\n-    eventCallbacks.ThreadEnd = cbThreadEnd;\n-\n-    if (!NSK_JVMTI_VERIFY(jvmti->SetEventCallbacks(&eventCallbacks, sizeof(eventCallbacks))))\n-        return NSK_FALSE;\n-\n-    return NSK_TRUE;\n-}\n-\n-\/* ============================================================================= *\/\n-\n-\/** Agent algorithm. *\/\n-static void JNICALL\n-agentProc(jvmtiEnv* jvmti, JNIEnv* agentJNI, void* arg) {\n-\n-    NSK_DISPLAY0(\"Wait for debuggee to become ready\\n\");\n-    if (!nsk_jvmti_waitForSync(timeout))\n-        return;\n-\n-    NSK_DISPLAY0(\"Let debuggee to continue\\n\");\n-    if (!nsk_jvmti_resumeSync())\n-        return;\n-\n-    if (!nsk_jvmti_waitForSync(timeout))\n-        return;\n-\n-    if (!checkEvents()) {\n-        nsk_jvmti_setFailStatus();\n-    }\n-\n-    NSK_DISPLAY0(\"Let debuggee to finish\\n\");\n-    if (!nsk_jvmti_resumeSync())\n-        return;\n-\n-}\n-\n-\/* ============================================================================= *\/\n-\n-\/** Agent library initialization. *\/\n-#ifdef STATIC_BUILD\n-JNIEXPORT jint JNICALL Agent_OnLoad_threadend002(JavaVM *jvm, char *options, void *reserved) {\n-    return Agent_Initialize(jvm, options, reserved);\n-}\n-JNIEXPORT jint JNICALL Agent_OnAttach_threadend002(JavaVM *jvm, char *options, void *reserved) {\n-    return Agent_Initialize(jvm, options, reserved);\n-}\n-JNIEXPORT jint JNI_OnLoad_threadend002(JavaVM *jvm, char *options, void *reserved) {\n-    return JNI_VERSION_1_8;\n-}\n-#endif\n-jint Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {\n-\n-    if (!NSK_VERIFY(nsk_jvmti_parseOptions(options)))\n-        return JNI_ERR;\n-\n-    timeout = nsk_jvmti_getWaitTime() * 60 * 1000;\n-\n-    jvmti = nsk_jvmti_createJVMTIEnv(jvm, reserved);\n-    if (!NSK_VERIFY(jvmti != NULL))\n-        return JNI_ERR;\n-\n-    if (!setCallBacks()) {\n-        return JNI_ERR;\n-    }\n-\n-    if (!enableEvent(JVMTI_ENABLE, JVMTI_EVENT_THREAD_END)) {\n-        NSK_COMPLAIN0(\"Events could not be enabled\");\n-        nsk_jvmti_setFailStatus();\n-        return JNI_ERR;\n-    }\n-\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n-        return JNI_ERR;\n-\n-    return JNI_OK;\n-}\n-\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/ThreadEnd\/threadend002\/threadend002.cpp","additions":0,"deletions":167,"binary":false,"changes":167,"status":"deleted"},{"patch":"@@ -1,86 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package nsk.jvmti.ThreadStart;\n-\n-import java.io.PrintStream;\n-\n-public class threadstart001 {\n-\n-    final static int JCK_STATUS_BASE = 95;\n-    final static int THREADS_LIMIT = 100;\n-    final static String NAME_PREFIX = \"threadstart001-\";\n-\n-    static {\n-        try {\n-            System.loadLibrary(\"threadstart001\");\n-        } catch (UnsatisfiedLinkError ule) {\n-            System.err.println(\"Could not load threadstart001 library\");\n-            System.err.println(\"java.library.path:\"\n-                + System.getProperty(\"java.library.path\"));\n-            throw ule;\n-        }\n-    }\n-\n-    native static void getReady(int i, String name);\n-    native static int check();\n-\n-    static volatile int thrCount = 0;\n-\n-    public static void main(String args[]) {\n-        args = nsk.share.jvmti.JVMTITest.commonInit(args);\n-\n-        \/\/ produce JCK-like exit status.\n-        System.exit(run(args, System.out) + JCK_STATUS_BASE);\n-    }\n-\n-    public static int run(String args[], PrintStream out) {\n-        TestThread t = new TestThread(NAME_PREFIX + thrCount);\n-        getReady(THREADS_LIMIT, NAME_PREFIX);\n-        t.start();\n-        try {\n-            t.join();\n-        } catch (InterruptedException e) {\n-            throw new Error(\"Unexpected: \" + e);\n-        }\n-        return check();\n-    }\n-\n-    static class TestThread extends Thread {\n-        public TestThread(String name) {\n-            super(name);\n-        }\n-        public void run() {\n-            thrCount++;\n-            if (thrCount < THREADS_LIMIT) {\n-                TestThread t = new TestThread(NAME_PREFIX + thrCount);\n-                t.start();\n-                try {\n-                    t.join();\n-                } catch (InterruptedException e) {\n-                    throw new Error(\"Unexpected: \" + e);\n-                }\n-            }\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/ThreadStart\/threadstart001.java","additions":0,"deletions":86,"binary":false,"changes":86,"status":"deleted"},{"patch":"@@ -1,43 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/*\n- * @test\n- *\n- * @summary converted from VM Testbase nsk\/jvmti\/ThreadStart\/threadstart001.\n- * VM Testbase keywords: [quick, jpda, jvmti, noras, quarantine]\n- * VM Testbase comments: 8016181\n- * VM Testbase readme:\n- * DESCRIPTION\n- *     The test exercises JVMTI event callback function ThreadStart.\n- *     The test checks if the event is ganerated by a new\n- *     thread before its initial method executes.\n- * COMMENTS\n- *     Ported from JVMDI.\n- *\n- * @library \/vmTestbase\n- *          \/test\/lib\n- * @run main\/othervm\/native -agentlib:threadstart001 nsk.jvmti.ThreadStart.threadstart001\n- *\/\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/ThreadStart\/threadstart001\/TestDescription.java","additions":0,"deletions":43,"binary":false,"changes":43,"status":"deleted"},{"patch":"@@ -1,33 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include \"native_thread.cpp\"\n-#include \"nsk_tools.cpp\"\n-#include \"jni_tools.cpp\"\n-#include \"jvmti_tools.cpp\"\n-#include \"agent_tools.cpp\"\n-#include \"jvmti_FollowRefObjects.cpp\"\n-#include \"Injector.cpp\"\n-#include \"JVMTITools.cpp\"\n-#include \"agent_common.cpp\"\n-#include \"threadstart001.cpp\"\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/ThreadStart\/threadstart001\/libthreadstart001.cpp","additions":0,"deletions":33,"binary":false,"changes":33,"status":"deleted"},{"patch":"@@ -1,159 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include <stdio.h>\n-#include <string.h>\n-#include \"jvmti.h\"\n-#include \"agent_common.h\"\n-#include \"JVMTITools.h\"\n-\n-extern \"C\" {\n-\n-\n-#define PASSED 0\n-#define STATUS_FAILED 2\n-\n-static jvmtiEnv *jvmti = NULL;\n-static jvmtiEventCallbacks callbacks;\n-static jint result = PASSED;\n-static jboolean printdump = JNI_FALSE;\n-static int eventsCount = 0;\n-static int eventsExpected = 0;\n-static const char *prefix = NULL;\n-\n-void JNICALL ThreadStart(jvmtiEnv *jvmti_env, JNIEnv *env, jthread thread) {\n-    jvmtiError err;\n-    jvmtiThreadInfo inf;\n-    char name[32];\n-\n-    err = jvmti_env->GetThreadInfo(thread, &inf);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(GetThreadInfo#%d) unexpected error: %s (%d)\\n\",\n-               eventsCount, TranslateError(err), err);\n-        result = STATUS_FAILED;\n-    }\n-    if (printdump == JNI_TRUE) {\n-        printf(\">>> %s\\n\", inf.name);\n-    }\n-    if (inf.name != NULL && strstr(inf.name, prefix) == inf.name) {\n-        sprintf(name, \"%s%d\", prefix, eventsCount);\n-        if (strcmp(name, inf.name) != 0) {\n-            printf(\"(#%d) wrong thread name: \\\"%s\\\"\",\n-                   eventsCount, inf.name);\n-            printf(\", expected: \\\"%s\\\"\\n\", name);\n-            result = STATUS_FAILED;\n-        }\n-        eventsCount++;\n-    }\n-}\n-\n-#ifdef STATIC_BUILD\n-JNIEXPORT jint JNICALL Agent_OnLoad_threadstart001(JavaVM *jvm, char *options, void *reserved) {\n-    return Agent_Initialize(jvm, options, reserved);\n-}\n-JNIEXPORT jint JNICALL Agent_OnAttach_threadstart001(JavaVM *jvm, char *options, void *reserved) {\n-    return Agent_Initialize(jvm, options, reserved);\n-}\n-JNIEXPORT jint JNI_OnLoad_threadstart001(JavaVM *jvm, char *options, void *reserved) {\n-    return JNI_VERSION_1_8;\n-}\n-#endif\n-jint  Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {\n-    jvmtiError err;\n-    jint res;\n-\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n-        printdump = JNI_TRUE;\n-    }\n-\n-    res = jvm->GetEnv((void **) &jvmti, JVMTI_VERSION_1_1);\n-    if (res != JNI_OK || jvmti == NULL) {\n-        printf(\"Wrong result of a valid call to GetEnv!\\n\");\n-        return JNI_ERR;\n-    }\n-\n-    callbacks.ThreadStart = &ThreadStart;\n-    err = jvmti->SetEventCallbacks(&callbacks, sizeof(callbacks));\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(SetEventCallbacks) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        return JNI_ERR;\n-    }\n-\n-    return JNI_OK;\n-}\n-\n-JNIEXPORT void JNICALL\n-Java_nsk_jvmti_ThreadStart_threadstart001_getReady(JNIEnv *env,\n-        jclass cls, jint i, jstring name) {\n-    jvmtiError err;\n-\n-    if (jvmti == NULL) {\n-        printf(\"JVMTI client was not properly loaded!\\n\");\n-        return;\n-    }\n-\n-    prefix = env->GetStringUTFChars(name, NULL);\n-    if (prefix == NULL) {\n-        printf(\"Failed to copy UTF-8 string!\\n\");\n-        result = STATUS_FAILED;\n-        return;\n-    }\n-\n-    err = jvmti->SetEventNotificationMode(JVMTI_ENABLE,\n-            JVMTI_EVENT_THREAD_START, NULL);\n-    if (err == JVMTI_ERROR_NONE) {\n-        eventsExpected = i;\n-    } else {\n-        printf(\"Failed to enable JVMTI_EVENT_THREAD_START: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-    }\n-}\n-\n-JNIEXPORT jint JNICALL\n-Java_nsk_jvmti_ThreadStart_threadstart001_check(JNIEnv *env, jclass cls) {\n-    jvmtiError err;\n-\n-    if (jvmti == NULL) {\n-        printf(\"JVMTI client was not properly loaded!\\n\");\n-        return STATUS_FAILED;\n-    }\n-\n-    err = jvmti->SetEventNotificationMode(JVMTI_DISABLE,\n-            JVMTI_EVENT_THREAD_START, NULL);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"Failed to disable JVMTI_EVENT_THREAD_START: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-    }\n-\n-    if (eventsCount != eventsExpected) {\n-        printf(\"Wrong number of thread start events: %d, expected: %d\\n\",\n-            eventsCount, eventsExpected);\n-        result = STATUS_FAILED;\n-    }\n-    return result;\n-}\n-\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/ThreadStart\/threadstart001\/threadstart001.cpp","additions":0,"deletions":159,"binary":false,"changes":159,"status":"deleted"},{"patch":"@@ -1,87 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package nsk.jvmti.ThreadStart;\n-\n-import java.io.PrintStream;\n-\n-public class threadstart002 {\n-\n-    final static int JCK_STATUS_BASE = 95;\n-\n-    static {\n-    try {\n-        System.loadLibrary(\"threadstart002\");\n-    } catch (UnsatisfiedLinkError ule) {\n-        System.err.println(\"Could not load threadstart002 library\");\n-        System.err.println(\"java.library.path:\"\n-                + System.getProperty(\"java.library.path\"));\n-        throw ule;\n-    }\n-    }\n-\n-    native static int check();\n-\n-    public static int waitTime = 2;\n-\n-    public static void main(String args[]) {\n-        args = nsk.share.jvmti.JVMTITest.commonInit(args);\n-\n-        \/\/ produce JCK-like exit status.\n-        System.exit(run(args, System.out) + JCK_STATUS_BASE);\n-    }\n-\n-    public static int run(String args[], PrintStream out) {\n-        if (args.length > 0) {\n-            try {\n-                int i  = Integer.parseInt(args[0]);\n-                waitTime = i;\n-            } catch (NumberFormatException ex) {\n-                out.println(\"# Wrong argument \\\"\" + args[0]\n-                    + \"\\\", the default value is used\");\n-            }\n-        }\n-        out.println(\"# Waiting time = \" + waitTime + \" mins\");\n-\n-        TestThread t = new TestThread(\"TestThread_1\");\n-        t.start();\n-\n-        try {\n-            t.join(waitTime * 60000);\n-        } catch (InterruptedException e) {\n-            throw new Error(\"Unexpected: \" + e);\n-        }\n-\n-        return check();\n-    }\n-\n-    static class TestThread extends Thread {\n-\n-        TestThread(String name) {\n-            super(name);\n-        }\n-\n-        public void run() {\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/ThreadStart\/threadstart002.java","additions":0,"deletions":87,"binary":false,"changes":87,"status":"deleted"},{"patch":"@@ -1,65 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/*\n- * @test\n- *\n- * @summary converted from VM Testbase nsk\/jvmti\/ThreadStart\/threadstart002.\n- * VM Testbase keywords: [quick, jpda, jvmti, onload_only_logic, noras]\n- * VM Testbase readme:\n- * DESCRIPTION\n- *     This is a regression test for the following bug:\n- *         4432884 jdbx does not work with jdk 1.3.1 starting with\n- *                 rc1 build 19 onwards\n- *     The test runs a debugger agent in a separate thread that operates\n- *     on behalf of other threads, so when it gets a ThreadStart event,\n- *     the debugger agent suspends the new thread and then\n- *     calls jni_DeleteGlobalRef with a jnienv * for that new thread.\n- *     Then the test resumes the new thread and checks the thread\n- *     suspend status.\n- * COMMENTS\n- *     The test reproduces the bug on Solsparc with JDK 1.3.1-b19\n- *     with the following output:\n- *     java version \"1.3.1-rc1\"\n- *     Java(TM) 2 Runtime Environment, Standard Edition (build 1.3.1-rc1-b19)\n- *     Java HotSpot(TM) Client VM (build 1.3.1-rc1-b19, interpreted mode)\n- *     >>> debug agent created\n- *     >>> thread 0: Signal Dispatcher\n- *     >>> Signal Dispatcher suspended ...\n- *     >>> ... resumed\n- *     >>> agent: threadStatus=ffffffff, suspendStatus=1\n- *     \"Signal Dispatcher\" did not resume\n- *     FATAL ERROR in native method: could not recover\n- *     Exit Code: 1\n- *     Fixed according to 4668512 bug,\n- *     Ported from JVMDI.\n- *     Modified due to fix of the RFE\n- *     5001769 TEST_RFE: remove usage of deprecated GetThreadStatus function\n- *     Fixed according to 6221885 test bug.\n- *\n- * @library \/vmTestbase\n- *          \/test\/lib\n- * @run main\/othervm\/native -agentlib:threadstart002 nsk.jvmti.ThreadStart.threadstart002 5\n- *\/\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/ThreadStart\/threadstart002\/TestDescription.java","additions":0,"deletions":65,"binary":false,"changes":65,"status":"deleted"},{"patch":"@@ -1,33 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include \"native_thread.cpp\"\n-#include \"nsk_tools.cpp\"\n-#include \"jni_tools.cpp\"\n-#include \"jvmti_tools.cpp\"\n-#include \"agent_tools.cpp\"\n-#include \"jvmti_FollowRefObjects.cpp\"\n-#include \"Injector.cpp\"\n-#include \"JVMTITools.cpp\"\n-#include \"agent_common.cpp\"\n-#include \"threadstart002.cpp\"\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/ThreadStart\/threadstart002\/libthreadstart002.cpp","additions":0,"deletions":33,"binary":false,"changes":33,"status":"deleted"},{"patch":"@@ -1,546 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include <stdio.h>\n-#include <string.h>\n-\n-#include \"nsk_tools.h\"\n-#include \"JVMTITools.h\"\n-#include \"jvmti_tools.h\"\n-#include \"agent_common.h\"\n-#include \"jni_tools.h\"\n-\n-extern \"C\" {\n-\n-#define PASSED 0\n-#define STATUS_FAILED 2\n-#define WAIT_TIME 20000\n-\n-static jvmtiEnv *jvmti = NULL;\n-static jvmtiCapabilities caps;\n-static jvmtiEventCallbacks callbacks;\n-\/* volatile variables *\/\n-static jrawMonitorID agent_start_lock, thr_start_lock, thr_resume_lock, thr_event_lock;\n-static volatile jthread agent_thread = NULL;\n-static volatile jboolean terminate_debug_agent = JNI_FALSE;\n-static volatile jboolean debug_agent_timed_out = JNI_FALSE;\n-static volatile jboolean debug_agent_started = JNI_FALSE;\n-static volatile jthread next_thread = NULL;\n-static jvmtiThreadInfo inf;\n-static volatile int eventsCount = 0;\n-static volatile jint result = PASSED;\n-\n-\/*\n-    The agent runs special debugger agent (debug_agent) in a separate thread\n-    that operates on behalf of other threads.\n-    Upon receiving ThreadStart event, the debugger agent:\n-    - suspends the new thread\n-    - calls jni_DeleteGlobalRef with a jnienv * for that new thread\n-    - resumes the new thread\n-    Then the thread suspend status is checked in ThreadStart callback.\n-\n-    The following monitors are used to synchronize debugger thread with other\n-    threads:\n-    1. agent_start_lock\n-       used to notify VMInit callback as well as ThreadStart callback\n-       that agent thread has been started.\n-    2. thr_event_lock\n-       used to guarantee that only one ThreadStart event is proceeded at\n-       the time.\n-    3. thr_start_lock\n-       used to notify agent thread that new thread has been started.\n-    4. thr_resume_lock\n-       used to notify ThreadStart callback that agent thread finished\n-       suspending and resuming the thread.\n-\n-    So, the threads behaves as following:\n-\n-VMInit                  | debug_agent                 |   ThreadStart\n--------------------------------------------------------------------------\n-                        |                             |\n- agent_start_lock.enter |                             | agent_start_lock.enter\n-                        |                             |\n- ... create debug_agent | ... start                   |  while (!debug_agent)\n- agent_start_lock.wait  |                             |    agent_start_lock.wait\n-                        | agent_start_lock.enter      |\n-                        | agent_start_lock.notifyAll  |\n-                        | agent_start_lock.exit       |\n- agent_start_lock.exit  |                             |  agent_start_lock.exit\n-                        |                             |\n-                        |                             |  thr_event_lock.enter\n-                        |                             |\n-                        | thr_start_lock.enter        |  thr_start_lock.enter\n-                        | if (!next_thread)           |  thr_resume_lock.enter\n-                        |     thr_start_lock.wait     |\n-                        |                             |  ... next_thread = ...\n-                        |                             |  thr_start_lock.notify\n-                        |                             |  thr_start_lock.exit\n-                        |                             |\n-                        | ... suspend new thread      |  thr_resume_lock.wait\n-                        | ... resume new thread       |\n-                        |                             |\n-                        | thr_resume_lock.enter       |\n-                        | thr_resume_lock.notify      |\n-                        | thr_resume_lock.exit        |\n-                        |                             |  ... check next_thread state\n-                        |                             |  thr_resume_lock.exit\n-                        | thr_start_lock.exit         |\n-                                                      | thr_event_lock.exit\n-\n-\n-*\/\n-\n-static void JNICALL\n-debug_agent(jvmtiEnv* jvmti, JNIEnv* jni, void *p) {\n-    JNIEnv *env = jni;\n-    jint thrStat;\n-    jobject temp;\n-\n-    \/* Notify VMInit callback as well as ThreadStart callback (if any)\n-     * that agent thread has been started\n-     *\/\n-    if (!NSK_JVMTI_VERIFY(jvmti->RawMonitorEnter(agent_start_lock))) {\n-        result = STATUS_FAILED;\n-        NSK_COMPLAIN0(\"[agent] failed to acquire agent_start_lock\\n\");\n-    }\n-\n-    if (!NSK_JVMTI_VERIFY(jvmti->RawMonitorNotifyAll(agent_start_lock))) {\n-        result = STATUS_FAILED;\n-        NSK_COMPLAIN0(\"[agent] failed to notify about agent_start_lock\\n\");\n-    }\n-\n-    if (!NSK_JVMTI_VERIFY(jvmti->RawMonitorExit(agent_start_lock))) {\n-        result = STATUS_FAILED;\n-        NSK_COMPLAIN0(\"[agent] failed to release agent_start_lock\\n\");\n-    }\n-\n-    NSK_DISPLAY0(\">>> [agent] agent created\\n\");\n-\n-    debug_agent_started = JNI_TRUE;\n-\n-    if (!NSK_JVMTI_VERIFY(jvmti->RawMonitorEnter(thr_start_lock))) {\n-        result = STATUS_FAILED;\n-        NSK_COMPLAIN0(\"[agent] failed to enter thr_start_lock\\n\");\n-    }\n-\n-    while (terminate_debug_agent != JNI_TRUE) {\n-\n-        if (next_thread == NULL) {\n-            \/* wait till new thread will be created and started *\/\n-            if (!NSK_JVMTI_VERIFY(jvmti->RawMonitorWait(thr_start_lock, (jlong)0))) {\n-                result = STATUS_FAILED;\n-                NSK_COMPLAIN0(\"[agent] Failed while waiting thr_start_lock\\n\");\n-            }\n-        }\n-\n-        if (next_thread != NULL) {\n-            \/* hmm, why NewGlobalRef is called one more time???\n-             * next_thread = env->NewGlobalRef(next_thread);\n-             *\/\n-            if (!NSK_JVMTI_VERIFY(jvmti->SuspendThread(next_thread))) {\n-                result = STATUS_FAILED;\n-                NSK_COMPLAIN1(\"[agent] Failed to suspend thread#%d\\n\", eventsCount);\n-            }\n-\n-            NSK_DISPLAY2(\">>> [agent] thread#%d %s suspended ...\\n\", eventsCount, inf.name);\n-\n-            \/* these dummy calls provoke VM to hang *\/\n-            temp = env->NewGlobalRef(next_thread);\n-            env->DeleteGlobalRef(temp);\n-\n-            if (!NSK_JVMTI_VERIFY(jvmti->ResumeThread(next_thread))) {\n-                result = STATUS_FAILED;\n-                NSK_COMPLAIN1(\"[agent] Failed to resume thread#%d\\n\", eventsCount);\n-            }\n-\n-            NSK_DISPLAY2(\">>> [agent] thread#%d %s resumed ...\\n\", eventsCount, inf.name);\n-\n-            if (!NSK_JVMTI_VERIFY(jvmti->GetThreadState(next_thread, &thrStat))) {\n-                result = STATUS_FAILED;\n-                NSK_COMPLAIN1(\"[agent] Failed to get thread state for thread#%d\\n\", eventsCount);\n-            }\n-\n-            NSK_DISPLAY3(\">>> [agent] %s threadState=%s (%x)\\n\",\n-                    inf.name, TranslateState(thrStat), thrStat);\n-\n-            if (thrStat & JVMTI_THREAD_STATE_SUSPENDED) {\n-                NSK_COMPLAIN1(\"[agent] \\\"%s\\\" was not resumed\\n\", inf.name);\n-                env->FatalError(\"[agent] could not recover\");\n-            }\n-\n-            env->DeleteGlobalRef(next_thread);\n-            next_thread = NULL;\n-\n-            \/* Notify ThreadStart callback that thread has been resumed *\/\n-            if (!NSK_JVMTI_VERIFY(jvmti->RawMonitorEnter(thr_resume_lock))) {\n-                NSK_COMPLAIN0(\"[agent] Failed to acquire thr_resume_lock\\n\");\n-                result = STATUS_FAILED;\n-            }\n-\n-            debug_agent_timed_out = JNI_FALSE;\n-\n-            if (!NSK_JVMTI_VERIFY(jvmti->RawMonitorNotify(thr_resume_lock))) {\n-                NSK_COMPLAIN0(\"[agent] Failed to notifing about thr_resume_lock\\n\");\n-                result = STATUS_FAILED;\n-            }\n-\n-            if (!NSK_JVMTI_VERIFY(jvmti->RawMonitorExit(thr_resume_lock))) {\n-                NSK_COMPLAIN0(\"[agent] Failed to release thr_resume_lock\\n\");\n-                result = STATUS_FAILED;\n-            }\n-        }\n-    }\n-\n-    \/*\n-     * We don't call RawMonitorExit(thr_start_lock) in the loop so we don't\n-     * lose any notify calls.\n-     *\/\n-    if (!NSK_JVMTI_VERIFY(jvmti->RawMonitorExit(thr_start_lock))) {\n-        NSK_COMPLAIN0(\"[agent] Failed to release thr_start_lock\\n\");\n-        result = STATUS_FAILED;\n-    }\n-\n-    NSK_DISPLAY0(\">>> [agent] done.\\n\");\n-}\n-\n-void JNICALL ThreadStart(jvmtiEnv *jvmti_env, JNIEnv *env, jthread thread) {\n-    jint thrStat;\n-    jvmtiPhase phase;\n-\n-    NSK_DISPLAY0(\">>> [ThreadStart hook] start\\n\");\n-\n-    \/* skip if thread is 'agent thread' *\/\n-    if (env->IsSameObject(agent_thread, thread) == JNI_TRUE) {\n-        NSK_DISPLAY0(\">>> [ThreadStart hook] skip agent thread\\n\");\n-        NSK_DISPLAY0(\">>> [ThreadStart hook] end\\n\");\n-        return;\n-    }\n-\n-    \/* wait till agent thread is started\n-     * (otherwise can fail while waiting on thr_resume_thread due to timeout)\n-     *\/\n-    if (debug_agent_started != JNI_TRUE) {\n-        if (!NSK_JVMTI_VERIFY(jvmti_env->RawMonitorEnter(agent_start_lock))) {\n-            NSK_COMPLAIN0(\"[ThreadStart hook] Failed to acquire agent_start_lock\\n\");\n-            result = STATUS_FAILED;\n-        }\n-\n-        while (debug_agent_started != JNI_TRUE) {\n-            NSK_DISPLAY1(\">>> [ThreadStart hook] waiting %dms for agent thread to start\\n\", WAIT_TIME);\n-\n-            if (!NSK_JVMTI_VERIFY(jvmti_env->RawMonitorWait(agent_start_lock, (jlong)WAIT_TIME))) {\n-                NSK_COMPLAIN0(\"[ThreadStart hook] Failed to wait for agent_start_lock\\n\");\n-                result = STATUS_FAILED;\n-            }\n-        }\n-\n-        if (!NSK_JVMTI_VERIFY(jvmti_env->RawMonitorExit(agent_start_lock))) {\n-            NSK_COMPLAIN0(\"[ThreadStart hook] Failed to release agent_start_lock\\n\");\n-            result = STATUS_FAILED;\n-        }\n-    }\n-\n-\n-    \/* Acquire event lock,\n-     * so only one StartThread callback could be proceeded at the time\n-     *\/\n-    if (!NSK_JVMTI_VERIFY(jvmti_env->RawMonitorEnter(thr_event_lock))) {\n-        NSK_COMPLAIN0(\"[ThreadStart hook] Failed to acquire thr_event_lock\\n\");\n-        result = STATUS_FAILED;\n-    }\n-\n-    {\n-        \/* get JVMTI phase *\/\n-        if (!NSK_JVMTI_VERIFY(jvmti_env->GetPhase(&phase))) {\n-            NSK_COMPLAIN0(\"[ThreadStart hook] Failed to get JVMTI phase\\n\");\n-            result = STATUS_FAILED;\n-        }\n-\n-        \/* Get thread name *\/\n-        inf.name = (char*) \"UNKNOWN\";\n-        if (phase == JVMTI_PHASE_LIVE) {\n-            \/* GetThreadInfo may only be called during the live phase *\/\n-            if (!NSK_JVMTI_VERIFY(jvmti_env->GetThreadInfo(thread, &inf))) {\n-                NSK_COMPLAIN1(\"[ThreadStart hook] Failed to get thread infor for thread#%d\\n\", eventsCount);\n-                result = STATUS_FAILED;\n-            }\n-        }\n-\n-        NSK_DISPLAY2(\">>> [ThreadStart hook] thread#%d: %s\\n\", eventsCount, inf.name);\n-\n-        \/* Acquire thr_start_lock *\/\n-        if (!NSK_JVMTI_VERIFY(jvmti_env->RawMonitorEnter(thr_start_lock))) {\n-            NSK_COMPLAIN1(\"[ThreadStart hook] thread#%d failed to acquire thr_start_lock\\n\", eventsCount);\n-            result = STATUS_FAILED;\n-        }\n-\n-            \/* Acquire thr_resume_lock before we release thr_start_lock to prevent\n-             * debug agent from notifying us before we are ready.\n-         *\/\n-        if (!NSK_JVMTI_VERIFY(jvmti_env->RawMonitorEnter(thr_resume_lock))) {\n-            NSK_COMPLAIN1(\"[ThreadStart hook] thread#%d failed to acquire thr_resume_lock\\n\", eventsCount);\n-            result = STATUS_FAILED;\n-        }\n-\n-        \/* Store thread *\/\n-        next_thread = env->NewGlobalRef(thread);\n-        debug_agent_timed_out = JNI_TRUE;\n-\n-        \/* Notify agent thread about new started thread and let agent thread to work with it *\/\n-        if (!NSK_JVMTI_VERIFY(jvmti_env->RawMonitorNotify(thr_start_lock))) {\n-            NSK_COMPLAIN1(\"[ThreadStart hook] thread#%d failed to notify about thr_start_lock\\n\", eventsCount);\n-            result = STATUS_FAILED;\n-        }\n-\n-        if (!NSK_JVMTI_VERIFY(jvmti_env->RawMonitorExit(thr_start_lock))) {\n-            NSK_COMPLAIN1(\"[ThreadStart hook] thread#%d failed to release thr_start_lock\\n\", eventsCount);\n-            result = STATUS_FAILED;\n-        }\n-\n-        \/* Wait till this started thread will be resumed by agent thread *\/\n-        if (!NSK_JVMTI_VERIFY(jvmti_env->RawMonitorWait(thr_resume_lock, (jlong)WAIT_TIME))) {\n-            NSK_COMPLAIN1(\"[ThreadStart hook] thread#%d failed while waiting for thr_resume_lock\\n\", eventsCount);\n-            result = STATUS_FAILED;\n-        }\n-\n-        if (debug_agent_timed_out == JNI_TRUE) {\n-            NSK_COMPLAIN1(\"[ThreadStart hook] \\\"%s\\\": debug agent timed out\\n\", inf.name);\n-            env->FatalError(\"[ThreadStart hook] could not recover\");\n-        }\n-\n-        \/* Release thr_resume_lock lock *\/\n-        if (!NSK_JVMTI_VERIFY(jvmti_env->RawMonitorExit(thr_resume_lock))) {\n-            NSK_COMPLAIN1(\"[ThreadStart hook] thread#%d failed to release thr_resume_lock\\n\", eventsCount);\n-            result = STATUS_FAILED;\n-        }\n-\n-        \/* check that thread is not in SUSPENDED state *\/\n-        if (phase == JVMTI_PHASE_LIVE) {\n-            \/* GetThreadState may only be called during the live phase *\/\n-            if (!NSK_JVMTI_VERIFY(jvmti_env->GetThreadState(thread, &thrStat))) {\n-                NSK_COMPLAIN1(\"[ThreadStart hook] Failed to get thread state for thread#%d\\n\", eventsCount);\n-                result = STATUS_FAILED;\n-            }\n-\n-            NSK_DISPLAY2(\">>> [ThreadStart hook] threadState=%s (%x)\\n\",\n-                    TranslateState(thrStat), thrStat);\n-\n-            if (thrStat & JVMTI_THREAD_STATE_SUSPENDED) {\n-                NSK_COMPLAIN1(\"[ThreadStart hook] \\\"%s\\\" was self-suspended\\n\", inf.name);\n-                env->FatalError(\"[ThreadStart hook] could not recover\");\n-            }\n-        }\n-\n-        eventsCount++;\n-    }\n-\n-    if (!NSK_JVMTI_VERIFY(jvmti_env->RawMonitorExit(thr_event_lock))) {\n-        NSK_COMPLAIN0(\"[ThreadStart hook] Failed to release thr_event_lock\\n\");\n-        result = STATUS_FAILED;\n-    }\n-\n-    NSK_DISPLAY0(\">>> [ThreadStart hook] end\\n\");\n-}\n-\n-void JNICALL VMInit(jvmtiEnv *jvmti_env, JNIEnv *env, jthread thr) {\n-    jclass cls = NULL;\n-    jmethodID mid = NULL;\n-\n-    NSK_DISPLAY0(\">>> VMInit event: start\\n\");\n-\n-    if (!NSK_JVMTI_VERIFY(jvmti_env->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_THREAD_START, NULL))) {\n-        NSK_COMPLAIN0(\"TEST FAILED: failed to enable JVMTI_EVENT_THREAD_START\\n\");\n-        return;\n-    }\n-\n-    \/* Start agent thread *\/\n-    if (!NSK_VERIFY((cls = env->FindClass(\"java\/lang\/Thread\")) != NULL)) {\n-        result = STATUS_FAILED;\n-            NSK_COMPLAIN0(\"TEST FAILED: Cannot start agent thread: FindClass() failed\\n\");\n-        return;\n-    }\n-\n-\n-    if (!NSK_VERIFY((mid = env->GetMethodID(cls, \"<init>\", \"()V\")) != NULL)) {\n-        result = STATUS_FAILED;\n-            NSK_COMPLAIN0(\"TEST FAILED: Cannot start agent thread: GetMethodID() failed\\n\");\n-        return;\n-    }\n-\n-\n-    if (!NSK_VERIFY((agent_thread = env->NewObject(cls, mid)) != NULL)) {\n-        result = STATUS_FAILED;\n-            NSK_COMPLAIN0(\"Cannot start agent thread: NewObject() failed\\n\");\n-        return;\n-    }\n-\n-    agent_thread = (jthread) env->NewGlobalRef(agent_thread);\n-    if (agent_thread == NULL) {\n-        result = STATUS_FAILED;\n-        NSK_COMPLAIN0(\"Cannot create global reference for agent_thread\\n\");\n-        return;\n-    }\n-\n-    \/*\n-     * Grab agent_start_lock before launching debug_agent to prevent\n-     * debug_agent from notifying us before we are ready.\n-     *\/\n-\n-    if (!NSK_JVMTI_VERIFY(jvmti_env->RawMonitorEnter(agent_start_lock))) {\n-        result = STATUS_FAILED;\n-        NSK_COMPLAIN0(\"TEST FAILED: failed to enter agent_start_lock\\n\");\n-    }\n-\n-    if (!NSK_JVMTI_VERIFY(jvmti_env->RunAgentThread(agent_thread, debug_agent, NULL, JVMTI_THREAD_NORM_PRIORITY))) {\n-        result = STATUS_FAILED;\n-        NSK_COMPLAIN0(\"TEST FAILED: failed to create agent thread\\n\");\n-    }\n-\n-    if (!NSK_JVMTI_VERIFY(jvmti_env->RawMonitorWait(agent_start_lock, (jlong)0))) {\n-        result = STATUS_FAILED;\n-        NSK_COMPLAIN0(\"TEST FAILED: failed to wait agent_start_lock\\n\");\n-    }\n-\n-    if (!NSK_JVMTI_VERIFY(jvmti_env->RawMonitorExit(agent_start_lock))) {\n-        result = STATUS_FAILED;\n-        NSK_COMPLAIN0(\"TEST FAILED: failed to exit agent_start_lock\\n\");\n-    }\n-\n-    NSK_DISPLAY0(\">>> VMInit event: end\\n\");\n-}\n-\n-void JNICALL VMDeath(jvmtiEnv *jvmti_env, JNIEnv *env) {\n-    NSK_DISPLAY0(\">>> VMDeath event\\n\");\n-\n-    \/\/ Sync to prevent WRONG_PHASE error code in the middle of events.\n-    if (!NSK_JVMTI_VERIFY(jvmti_env->RawMonitorEnter(thr_event_lock))) {\n-        NSK_COMPLAIN0(\"[VMDeath hook] Failed to acquire thr_event_lock\\n\");\n-        result = STATUS_FAILED;\n-    }\n-    terminate_debug_agent = JNI_TRUE;\n-\n-    if (!NSK_JVMTI_VERIFY(jvmti_env->RawMonitorExit(thr_event_lock))) {\n-        NSK_COMPLAIN0(\"[VMDeath hook] Failed to release thr_event_lock\\n\");\n-        result = STATUS_FAILED;\n-    }\n-}\n-\n-#ifdef STATIC_BUILD\n-JNIEXPORT jint JNICALL Agent_OnLoad_threadstart002(JavaVM *jvm, char *options, void *reserved) {\n-    return Agent_Initialize(jvm, options, reserved);\n-}\n-JNIEXPORT jint JNICALL Agent_OnAttach_threadstart002(JavaVM *jvm, char *options, void *reserved) {\n-    return Agent_Initialize(jvm, options, reserved);\n-}\n-JNIEXPORT jint JNI_OnLoad_threadstart002(JavaVM *jvm, char *options, void *reserved) {\n-    return JNI_VERSION_1_8;\n-}\n-#endif\n-jint Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {\n-\n-    \/* init framework and parse options *\/\n-    if (!NSK_VERIFY(nsk_jvmti_parseOptions(options)))\n-        return JNI_ERR;\n-\n-    \/* create JVMTI environment *\/\n-    if (!NSK_VERIFY((jvmti =\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL)) {\n-        NSK_COMPLAIN0(\"TEST FAILED: failed to create JVMTIEnv\\n\");\n-        return JNI_ERR;\n-    }\n-\n-    if (!NSK_JVMTI_VERIFY(jvmti->GetPotentialCapabilities(&caps))) {\n-        NSK_COMPLAIN0(\"TEST FAILED: failed to get potential capabilities\\n\");\n-        return JNI_ERR;\n-    }\n-\n-    if (!NSK_JVMTI_VERIFY(jvmti->AddCapabilities(&caps))) {\n-        NSK_COMPLAIN0(\"TEST FAILED: failed to add capabilities during agent load\\n\");\n-        return JNI_ERR;\n-    }\n-\n-    if (!NSK_JVMTI_VERIFY(jvmti->GetCapabilities(&caps))) {\n-        NSK_COMPLAIN0(\"TEST FAILED: failed to get capabilities\\n\");\n-        return JNI_ERR;\n-    }\n-\n-    if (!caps.can_suspend) {\n-        NSK_DISPLAY0(\"WARNING: suspend\/resume is not implemented\\n\");\n-    }\n-\n-    \/* create raw monitors *\/\n-    if (!NSK_JVMTI_VERIFY(jvmti->CreateRawMonitor(\"_agent_start_lock\", &agent_start_lock))) {\n-        NSK_COMPLAIN0(\"TEST FAILED: failed to create agent_start_lock\\n\");\n-        return JNI_ERR;\n-    }\n-\n-    if (!NSK_JVMTI_VERIFY(jvmti->CreateRawMonitor(\"_thr_event_lock\", &thr_event_lock))) {\n-        NSK_COMPLAIN0(\"TEST FAILED: failed to create thr_event_lock\\n\");\n-        return JNI_ERR;\n-    }\n-\n-    if (!NSK_JVMTI_VERIFY(jvmti->CreateRawMonitor(\"_thr_start_lock\", &thr_start_lock))) {\n-        NSK_COMPLAIN0(\"TEST FAILED: failed to create thr_start_lock\\n\");\n-        return JNI_ERR;\n-    }\n-\n-    if (!NSK_JVMTI_VERIFY(jvmti->CreateRawMonitor(\"_thr_resume_lock\", &thr_resume_lock))) {\n-        NSK_COMPLAIN0(\"TEST FAILED: failed to create thr_resume_lock\\n\");\n-        return JNI_ERR;\n-    }\n-\n-    callbacks.VMInit = &VMInit;\n-    callbacks.VMDeath = &VMDeath;\n-    callbacks.ThreadStart = &ThreadStart;\n-\n-    if (!NSK_JVMTI_VERIFY(jvmti->SetEventCallbacks(&callbacks, sizeof(callbacks)))) {\n-        NSK_COMPLAIN0(\"TEST FAILED: failed to set event callbacks\\n\");\n-        return JNI_ERR;\n-    }\n-\n-    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_INIT, NULL))) {\n-        NSK_COMPLAIN0(\"TEST FAILED: failed to enable JVMTI_EVENT_VM_INIT\\n\");\n-        return JNI_ERR;\n-    }\n-\n-    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_DEATH, NULL))) {\n-        NSK_COMPLAIN0(\"TEST FAILED: failed to enable JVMTI_EVENT_VM_DEATH\\n\");\n-        return JNI_ERR;\n-    }\n-\n-    return JNI_OK;\n-}\n-\n-JNIEXPORT jint JNICALL\n-Java_nsk_jvmti_ThreadStart_threadstart002_check(JNIEnv *env, jclass cls) {\n-    if (eventsCount == 0) {\n-        NSK_COMPLAIN0(\"None of thread start events!\\n\");\n-        result = STATUS_FAILED;\n-    }\n-\n-    NSK_DISPLAY1(\">>> total of thread start events: %d\\n\", eventsCount);\n-\n-    return result;\n-}\n-\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/ThreadStart\/threadstart002\/threadstart002.cpp","additions":0,"deletions":546,"binary":false,"changes":546,"status":"deleted"},{"patch":"@@ -1,56 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package nsk.jvmti.ThreadStart;\n-\n-import java.io.PrintStream;\n-\n-public class threadstart003 {\n-\n-    final static int JCK_STATUS_BASE = 95;\n-    final static String ThreadName = \"testedThread\";\n-\n-    static {\n-        try {\n-            System.loadLibrary(\"threadstart003\");\n-        } catch (UnsatisfiedLinkError ule) {\n-            System.err.println(\"Could not load threadstart003 library\");\n-            System.err.println(\"java.library.path:\"\n-                + System.getProperty(\"java.library.path\"));\n-            throw ule;\n-        }\n-    }\n-\n-    native static int check(Thread thr, String name);\n-\n-    public static void main(String args[]) {\n-        args = nsk.share.jvmti.JVMTITest.commonInit(args);\n-\n-        \/\/ produce JCK-like exit status.\n-        System.exit(run(args, System.out) + JCK_STATUS_BASE);\n-    }\n-\n-    public static int run(String args[], PrintStream out) {\n-        return check(new Thread(ThreadName), ThreadName);\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/ThreadStart\/threadstart003.java","additions":0,"deletions":56,"binary":false,"changes":56,"status":"deleted"},{"patch":"@@ -1,45 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/*\n- * @test\n- *\n- * @summary converted from VM Testbase nsk\/jvmti\/ThreadStart\/threadstart003.\n- * VM Testbase keywords: [quick, jpda, jvmti, noras]\n- * VM Testbase readme:\n- * DESCRIPTION\n- *     Regression test for bug\n- *         4266590 Thread start events are sent from the wrong thread\n- *         Release summary: kestrel\n- *         Hardware version: generic\n- *         O\/S version (unbundled products): generic\n- * COMMENTS\n- *     The test reproduced the bug on winNT 1.3.0-E build.\n- *     Ported from JVMDI.\n- *\n- * @library \/vmTestbase\n- *          \/test\/lib\n- * @run main\/othervm\/native -agentlib:threadstart003 nsk.jvmti.ThreadStart.threadstart003\n- *\/\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/ThreadStart\/threadstart003\/TestDescription.java","additions":0,"deletions":45,"binary":false,"changes":45,"status":"deleted"},{"patch":"@@ -1,33 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include \"native_thread.cpp\"\n-#include \"nsk_tools.cpp\"\n-#include \"jni_tools.cpp\"\n-#include \"jvmti_tools.cpp\"\n-#include \"agent_tools.cpp\"\n-#include \"jvmti_FollowRefObjects.cpp\"\n-#include \"Injector.cpp\"\n-#include \"JVMTITools.cpp\"\n-#include \"agent_common.cpp\"\n-#include \"threadstart003.cpp\"\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/ThreadStart\/threadstart003\/libthreadstart003.cpp","additions":0,"deletions":33,"binary":false,"changes":33,"status":"deleted"},{"patch":"@@ -1,276 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include <stdio.h>\n-#include <string.h>\n-#include \"jvmti.h\"\n-#include \"agent_common.h\"\n-#include \"JVMTITools.h\"\n-\n-extern \"C\" {\n-\n-\n-#define PASSED 0\n-#define STATUS_FAILED 2\n-#define WAIT_TIME 1000\n-\n-static jvmtiEnv *jvmti = NULL;\n-static jvmtiEventCallbacks callbacks;\n-static jint result = PASSED;\n-static jboolean printdump = JNI_FALSE;\n-static jrawMonitorID wait_lock;\n-static const char *threadName = NULL;\n-static int startsCount = 0;\n-static int startsExpected = 0;\n-static int endsCount = 0;\n-static int endsExpected = 0;\n-\n-void JNICALL ThreadStart(jvmtiEnv *jvmti_env, JNIEnv *env, jthread thread) {\n-    jvmtiError err;\n-    jvmtiThreadInfo inf;\n-\n-    err = jvmti_env->GetThreadInfo(thread, &inf);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(GetThreadInfo, start) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-    }\n-    if (printdump == JNI_TRUE) {\n-        printf(\">>> start: %s\\n\", inf.name);\n-    }\n-    if (inf.name != NULL && strcmp(inf.name, threadName) == 0) {\n-        startsCount++;\n-    }\n-}\n-\n-void JNICALL ThreadEnd(jvmtiEnv *jvmti_env, JNIEnv *env, jthread thread) {\n-    jvmtiError err;\n-    jvmtiThreadInfo inf;\n-\n-    err = jvmti_env->GetThreadInfo(thread, &inf);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(GetThreadInfo, end) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-    }\n-    if (printdump == JNI_TRUE) {\n-        printf(\">>> end: %s\\n\", inf.name);\n-    }\n-    if (inf.name != NULL && strcmp(inf.name, threadName) == 0) {\n-        endsCount++;\n-    }\n-}\n-\n-#ifdef STATIC_BUILD\n-JNIEXPORT jint JNICALL Agent_OnLoad_threadstart003(JavaVM *jvm, char *options, void *reserved) {\n-    return Agent_Initialize(jvm, options, reserved);\n-}\n-JNIEXPORT jint JNICALL Agent_OnAttach_threadstart003(JavaVM *jvm, char *options, void *reserved) {\n-    return Agent_Initialize(jvm, options, reserved);\n-}\n-JNIEXPORT jint JNI_OnLoad_threadstart003(JavaVM *jvm, char *options, void *reserved) {\n-    return JNI_VERSION_1_8;\n-}\n-#endif\n-jint Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {\n-    jvmtiError err;\n-    jint res;\n-\n-    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n-        printdump = JNI_TRUE;\n-    }\n-\n-    res = jvm->GetEnv((void **) &jvmti, JVMTI_VERSION_1_1);\n-    if (res != JNI_OK || jvmti == NULL) {\n-        printf(\"Wrong result of a valid call to GetEnv!\\n\");\n-        return JNI_ERR;\n-    }\n-\n-    callbacks.ThreadStart = &ThreadStart;\n-    callbacks.ThreadEnd = &ThreadEnd;\n-    err = jvmti->SetEventCallbacks(&callbacks, sizeof(callbacks));\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(SetEventCallbacks) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        return JNI_ERR;\n-    }\n-\n-    return JNI_OK;\n-}\n-\n-static void JNICALL\n-threadProc(jvmtiEnv* jvmti, JNIEnv* jni, void *unused) {\n-    jvmtiError err;\n-\n-    err = jvmti->RawMonitorEnter(wait_lock);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(RawMonitorEnter) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-    }\n-    err = jvmti->RawMonitorNotify(wait_lock);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(RawMonitorNotify) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-    }\n-    err = jvmti->RawMonitorExit(wait_lock);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(RawMonitorExit) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-    }\n-}\n-\n-JNIEXPORT jint JNICALL\n-Java_nsk_jvmti_ThreadStart_threadstart003_check(JNIEnv *env,\n-        jclass cls, jthread thr, jstring name) {\n-    jvmtiError err;\n-\n-    if (jvmti == NULL) {\n-        printf(\"JVMTI client was not properly loaded!\\n\");\n-        return STATUS_FAILED;\n-    }\n-\n-    threadName = env->GetStringUTFChars(name, NULL);\n-    if (threadName == NULL) {\n-        printf(\"Failed to copy UTF-8 string!\\n\");\n-        return STATUS_FAILED;\n-    }\n-\n-    err = jvmti->CreateRawMonitor(\"_wait_lock\", &wait_lock);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(CreateRawMonitor) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        return STATUS_FAILED;\n-    }\n-\n-    err = jvmti->SetEventNotificationMode(JVMTI_ENABLE,\n-            JVMTI_EVENT_THREAD_START, NULL);\n-    if (err == JVMTI_ERROR_NONE) {\n-        startsExpected = 1;\n-    } else {\n-        printf(\"Failed to enable JVMTI_EVENT_THREAD_START: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-    }\n-\n-    err = jvmti->SetEventNotificationMode(JVMTI_ENABLE,\n-            JVMTI_EVENT_THREAD_END, NULL);\n-    if (err == JVMTI_ERROR_NONE) {\n-        endsExpected = 1;\n-    } else {\n-        printf(\"Failed to enable JVMTI_EVENT_THREAD_END: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-    }\n-\n-    if (printdump == JNI_TRUE) {\n-        printf(\">>> starting agent thread ...\\n\");\n-    }\n-    err = jvmti->RawMonitorEnter(wait_lock);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(RawMonitorEnter) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-    }\n-    err = jvmti->RunAgentThread(thr, threadProc,\n-        NULL, JVMTI_THREAD_MAX_PRIORITY);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(RunAgentThread) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-    }\n-    err = jvmti->RawMonitorWait(wait_lock, 0);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(RawMonitorWait) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-    }\n-    err = jvmti->RawMonitorExit(wait_lock);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(RawMonitorExit) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-    }\n-\n-    err = jvmti->RawMonitorEnter(wait_lock);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(RawMonitorEnter) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-    }\n-    \/\/ Wait for up to 3 seconds for the thread end event\n-    {\n-        int i;\n-        for (i = 0; i < 3 ; i++) {\n-            err = jvmti->RawMonitorWait(wait_lock, (jlong)WAIT_TIME);\n-            if (endsCount == endsExpected || err != JVMTI_ERROR_NONE) {\n-                break;\n-            }\n-        }\n-    }\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(RawMonitorWait) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-    }\n-    err = jvmti->RawMonitorExit(wait_lock);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"(RawMonitorExit) unexpected error: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-    }\n-\n-    err = jvmti->SetEventNotificationMode(JVMTI_DISABLE,\n-            JVMTI_EVENT_THREAD_START, NULL);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"Failed to disable JVMTI_EVENT_THREAD_START: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-    }\n-\n-    err = jvmti->SetEventNotificationMode(JVMTI_DISABLE,\n-            JVMTI_EVENT_THREAD_END, NULL);\n-    if (err != JVMTI_ERROR_NONE) {\n-        printf(\"Failed to disable JVMTI_EVENT_THREAD_END: %s (%d)\\n\",\n-               TranslateError(err), err);\n-        result = STATUS_FAILED;\n-    }\n-\n-    if (startsCount != startsExpected) {\n-        printf(\"Wrong number of thread start events: %d, expected: %d\\n\",\n-            startsCount, startsExpected);\n-        result = STATUS_FAILED;\n-    }\n-\n-    if (endsCount != endsExpected) {\n-        printf(\"Wrong number of thread end events: %d, expected: %d\\n\",\n-            endsCount, endsExpected);\n-        result = STATUS_FAILED;\n-    }\n-\n-    return result;\n-}\n-\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/ThreadStart\/threadstart003\/threadstart003.cpp","additions":0,"deletions":276,"binary":false,"changes":276,"status":"deleted"},{"patch":"@@ -1,62 +0,0 @@\n-\/*\n- * Copyright (c) 2004, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package nsk.jvmti.VMObjectAlloc;\n-\n-import java.io.PrintStream;\n-\n-import nsk.share.*;\n-import nsk.share.jvmti.*;\n-\n-public class vmobjalloc001 extends DebugeeClass {\n-\n-    \/\/ run test from command line\n-    public static void main(String argv[]) {\n-        argv = nsk.share.jvmti.JVMTITest.commonInit(argv);\n-\n-        \/\/ JCK-compatible exit\n-        System.exit(run(argv, System.out) + Consts.JCK_STATUS_BASE);\n-    }\n-\n-    \/\/ run test from JCK-compatible environment\n-    public static int run(String argv[], PrintStream out) {\n-        return new vmobjalloc001().runIt(argv, out);\n-    }\n-\n-    \/* =================================================================== *\/\n-\n-    \/\/ scaffold objects\n-    ArgumentHandler argHandler = null;\n-    Log log = null;\n-    int status = Consts.TEST_PASSED;\n-\n-    \/\/ run debuggee\n-    public int runIt(String argv[], PrintStream out) {\n-        argHandler = new ArgumentHandler(argv);\n-        log = new Log(out, argHandler);\n-\n-        log.display(\"Sync: debuggee started\");\n-\n-        return checkStatus(status);\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/VMObjectAlloc\/vmobjalloc001.java","additions":0,"deletions":62,"binary":false,"changes":62,"status":"deleted"},{"patch":"@@ -1,49 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/*\n- * @test\n- *\n- * @summary converted from VM Testbase nsk\/jvmti\/VMObjectAlloc\/vmobjalloc001.\n- * VM Testbase keywords: [quick, jpda, jvmti, noras]\n- * VM Testbase readme:\n- * DESCRIPTION\n- *     The test exercises JVMTI event callback function VMObjectAlloc.\n- *     The test enables the event and counts a number of received events.\n- *     There is no guarantee that VM allocates any special objects, so if\n- *     no JVMTI_EVENT_VM_OBJECT_ALLOC has been received then the test\n- *     just prints warning message and passes anyway.\n- * COMMENTS\n- *     Fixed the 5001806 bug.\n- *     Modified due to fix of the bug\n- *     5010571 TEST_BUG: jvmti tests with VMObjectAlloc callbacks should\n- *             be adjusted to new spec\n- *\n- * @library \/vmTestbase\n- *          \/test\/lib\n- * @run main\/othervm\/native\n- *      -agentlib:vmobjalloc001=-waittime=5\n- *      nsk.jvmti.VMObjectAlloc.vmobjalloc001\n- *\/\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/VMObjectAlloc\/vmobjalloc001\/TestDescription.java","additions":0,"deletions":49,"binary":false,"changes":49,"status":"deleted"},{"patch":"@@ -1,33 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include \"native_thread.cpp\"\n-#include \"nsk_tools.cpp\"\n-#include \"jni_tools.cpp\"\n-#include \"jvmti_tools.cpp\"\n-#include \"agent_tools.cpp\"\n-#include \"jvmti_FollowRefObjects.cpp\"\n-#include \"Injector.cpp\"\n-#include \"JVMTITools.cpp\"\n-#include \"agent_common.cpp\"\n-#include \"vmobjalloc001.cpp\"\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/VMObjectAlloc\/vmobjalloc001\/libvmobjalloc001.cpp","additions":0,"deletions":33,"binary":false,"changes":33,"status":"deleted"},{"patch":"@@ -1,155 +0,0 @@\n-\/*\n- * Copyright (c) 2004, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include <string.h>\n-#include \"jvmti.h\"\n-#include \"agent_common.h\"\n-#include \"jni_tools.h\"\n-#include \"jvmti_tools.h\"\n-\n-extern \"C\" {\n-\n-\/* ========================================================================== *\/\n-\n-\/* scaffold objects *\/\n-static jlong timeout = 0;\n-\n-\/* test objects *\/\n-static int eventsCount = 0;\n-\n-\/* ========================================================================== *\/\n-\n-\/* check if any VMObjectAlloc events received *\/\n-static int checkVMObjectAllocEvents() {\n-\n-    NSK_DISPLAY1(\"VMObjectAlloc events received: %d\\n\", eventsCount);\n-\n-    if (eventsCount == 0) {\n-        NSK_DISPLAY0(\"# WARNING: no VMObjectAlloc events\\n\");\n-        NSK_DISPLAY0(\"#    (VM might not allocate such objects at all)\\n\");\n-    }\n-\n-    return NSK_TRUE;\n-}\n-\n-\/* ========================================================================== *\/\n-\n-JNIEXPORT void JNICALL\n-VMObjectAlloc(jvmtiEnv *jvmti, JNIEnv* jni, jthread thread, jobject object,\n-              jclass object_klass, jlong size) {\n-    char *signature, *generic;\n-\n-    eventsCount++;\n-\n-    if (!NSK_JVMTI_VERIFY(jvmti->GetClassSignature(object_klass, &signature, &generic))) {\n-        nsk_jvmti_setFailStatus();\n-        return;\n-    }\n-\n-    NSK_DISPLAY2(\"VMObjectAlloc: \\\"%s\\\", size=%d\\n\", signature, size);\n-\n-    if (signature != NULL)\n-        jvmti->Deallocate((unsigned char*)signature);\n-\n-    if (generic != NULL)\n-        jvmti->Deallocate((unsigned char*)generic);\n-\n-}\n-\n-\/* ========================================================================== *\/\n-\n-\/* agent algorithm *\/\n-static void JNICALL\n-agentProc(jvmtiEnv* jvmti, JNIEnv* jni, void* arg) {\n-\n-    \/* wait for debuggee start *\/\n-    if (!nsk_jvmti_waitForSync(timeout))\n-        return;\n-\n-    \/* testcase #1: check if any VMObjectAlloc events received*\/\n-    NSK_DISPLAY0(\"Testcase #1: check if any VMObjectAlloc events received\\n\");\n-    if (!checkVMObjectAllocEvents())\n-        nsk_jvmti_setFailStatus();\n-\n-    \/* resume debugee after last sync *\/\n-    if (!nsk_jvmti_resumeSync())\n-        return;\n-}\n-\n-\/* ========================================================================== *\/\n-\n-\/* agent library initialization *\/\n-#ifdef STATIC_BUILD\n-JNIEXPORT jint JNICALL Agent_OnLoad_vmobjalloc001(JavaVM *jvm, char *options, void *reserved) {\n-    return Agent_Initialize(jvm, options, reserved);\n-}\n-JNIEXPORT jint JNICALL Agent_OnAttach_vmobjalloc001(JavaVM *jvm, char *options, void *reserved) {\n-    return Agent_Initialize(jvm, options, reserved);\n-}\n-JNIEXPORT jint JNI_OnLoad_vmobjalloc001(JavaVM *jvm, char *options, void *reserved) {\n-    return JNI_VERSION_1_8;\n-}\n-#endif\n-jint Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {\n-    jvmtiEnv* jvmti = NULL;\n-    jvmtiCapabilities caps;\n-    jvmtiEventCallbacks callbacks;\n-\n-    \/* init framework and parse options *\/\n-    if (!NSK_VERIFY(nsk_jvmti_parseOptions(options)))\n-        return JNI_ERR;\n-\n-    timeout = nsk_jvmti_getWaitTime() * 60000;\n-    NSK_DISPLAY1(\"Timeout: %d msc\\n\", (int)timeout);\n-\n-    \/* create JVMTI environment *\/\n-    if (!NSK_VERIFY((jvmti =\n-            nsk_jvmti_createJVMTIEnv(jvm, reserved)) != NULL))\n-        return JNI_ERR;\n-\n-    memset(&caps, 0, sizeof(caps));\n-    caps.can_generate_vm_object_alloc_events = 1;\n-    if (!NSK_JVMTI_VERIFY(jvmti->AddCapabilities(&caps))) {\n-        return JNI_ERR;\n-    }\n-\n-    memset(&callbacks, 0, sizeof(callbacks));\n-    callbacks.VMObjectAlloc= &VMObjectAlloc;\n-    if (!NSK_JVMTI_VERIFY(jvmti->SetEventCallbacks(&callbacks, sizeof(callbacks))))\n-        return JNI_ERR;\n-\n-    \/* enable VMObjectAlloc event *\/\n-    if (!NSK_JVMTI_VERIFY(\n-            jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_OBJECT_ALLOC, NULL)))\n-        return JNI_ERR;\n-\n-    \/* register agent proc and arg *\/\n-    if (!NSK_VERIFY(nsk_jvmti_setAgentProc(agentProc, NULL)))\n-        return JNI_ERR;\n-\n-    return JNI_OK;\n-}\n-\n-\/* ========================================================================== *\/\n-\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/VMObjectAlloc\/vmobjalloc001\/vmobjalloc001.cpp","additions":0,"deletions":155,"binary":false,"changes":155,"status":"deleted"}]}