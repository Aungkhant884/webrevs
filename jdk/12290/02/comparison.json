{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -58,0 +58,9 @@\n+    \/**\n+     * Return values for {@link #compare(String, byte[], int, int, boolean)}\n+     *\/\n+    enum Comparison {\n+        EXACT_MATCH,\n+        SLASH_MATCH,\n+        NO_MATCH\n+    }\n+\n@@ -187,0 +196,25 @@\n+    \/**\n+     * Compares a string with a second string which is encoded in a given\n+     * byte array range, as if the second string was first decoded from\n+     * bytes using this ZipCoder's charset.\n+     *\n+     * If the two strings match exactly, return {@link Comparison#EXACT_MATCH}.\n+     * If addSlash is true and the two strings only differ by the second string\n+     * having a trailing '\/', then return {@link Comparison#SLASH_MATCH}.\n+     * Otherwise, return {@link Comparison#NO_MATCH}\n+     *\n+     * While a general implementation will need to decode bytes into a\n+     * String for comparison, this can be avoided if the String coder\n+     * is known and matches the charset of this ZipCoder.\n+     *\/\n+    Comparison compare(String str, byte[] b, int off, int len, boolean addSlash) {\n+        String decoded = toString(b, off, len);\n+        if (decoded.equals(str)) {\n+            return Comparison.EXACT_MATCH;\n+        } else if (addSlash && decoded.length() == str.length() + 1\n+                && decoded.endsWith(\"\/\")) {\n+            return Comparison.SLASH_MATCH;\n+        } else {\n+            return Comparison.NO_MATCH;\n+        }\n+    }\n@@ -235,0 +269,17 @@\n+\n+        @Override\n+        Comparison compare(String str, byte[] b, int off, int len, boolean addSlash) {\n+            try {\n+                byte[] encoded = JLA.getBytesNoRepl(str, UTF_8.INSTANCE);\n+                int mismatch = Arrays.mismatch(encoded, 0, encoded.length, b, off, off+len);\n+                if (mismatch == -1) {\n+                    return Comparison.EXACT_MATCH;\n+                } else if (addSlash && len == mismatch + 1 && hasTrailingSlash(b, off + len)) {\n+                    return Comparison.SLASH_MATCH;\n+                } else {\n+                    return Comparison.NO_MATCH;\n+                }\n+            } catch (CharacterCodingException e) {\n+                return Comparison.NO_MATCH;\n+            }\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/ZipCoder.java","additions":52,"deletions":1,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1995, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1995, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -1636,0 +1636,2 @@\n+            int slashMatch = -1; \/\/ Position of secondary match \"name\/\"\n+\n@@ -1640,1 +1642,2 @@\n-                    \/\/ The CEN name must match the specified one\n+                    \/\/ Compare the lookup name with the name encoded in the CEN\n+\n@@ -1642,0 +1645,2 @@\n+                    int noff = pos + CENHDR;\n+                    int nlen = CENNAM(cen, pos);\n@@ -1643,11 +1648,5 @@\n-                    try {\n-                        ZipCoder zc = zipCoderForPos(pos);\n-                        String entry = zc.toString(cen, pos + CENHDR, CENNAM(cen, pos));\n-\n-                        \/\/ If addSlash is true we'll test for name+\/ in addition to\n-                        \/\/ name, unless name is the empty string or already ends with a\n-                        \/\/ slash\n-                        int entryLen = entry.length();\n-                        int nameLen = name.length();\n-                        if (entryLen == nameLen && entry.equals(name)) {\n-                            \/\/ Found our match\n+                    ZipCoder zc = zipCoderForPos(pos);\n+\n+                    switch (zc.compare(name, cen, noff, nlen, addSlash)) {\n+                        case EXACT_MATCH:\n+                            \/\/ Exact match for \"name\"\n@@ -1655,11 +1654,6 @@\n-                        }\n-                        \/\/ If addSlash is true we'll now test for name+\/ providing\n-                        if (addSlash && nameLen + 1 == entryLen\n-                                && entry.startsWith(name) &&\n-                                entry.charAt(entryLen - 1) == '\/') {\n-                            \/\/ Found the entry \"name+\/\", now find the CEN entry pos\n-                            int exactPos = getEntryPos(name, false);\n-                            return exactPos == -1 ? pos : exactPos;\n-                        }\n-                    } catch (IllegalArgumentException iae) {\n-                        \/\/ Ignore\n+                        case SLASH_MATCH:\n+                            \/\/ Match for \"name\/\", take note\n+                            slashMatch = pos;\n+                            break;\n+                        case NO_MATCH:\n+                            \/\/ Hash collision, continue search\n@@ -1670,1 +1664,2 @@\n-            return -1;\n+            \/\/ No exact match found, will return either slashMatch or -1\n+            return slashMatch;\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/ZipFile.java","additions":20,"deletions":25,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -0,0 +1,182 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+import org.testng.annotations.BeforeTest;\n+import org.testng.annotations.Test;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import java.nio.channels.FileChannel;\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipException;\n+import java.util.zip.ZipFile;\n+import java.util.zip.ZipOutputStream;\n+\n+import static org.testng.Assert.assertEquals;\n+\n+\/**\n+ * @test\n+ * @summary Validate that opening ZIP files files with invalid UTF-8\n+ * byte sequences in the name or comment fields fails with ZipException\n+ * @run testng\/othervm InvalidBytesInEntryNameOrComment\n+ *\/\n+public class InvalidBytesInEntryNameOrComment {\n+\n+    \/\/ Offsets for navigating the CEN fields\n+    private static final int EOC_OFF = 6;   \/\/ Offset from EOF to find CEN offset\n+    private static final int CEN_HDR = 45;  \/\/ Size of a CEN header\n+    private static final int NLEN = 28;     \/\/ Name length\n+    private static final int ELEN = 30;     \/\/ Extra length\n+    private static final int CLEN = 32;     \/\/ Comment length\n+\n+    \/\/ Example invalid UTF-8 byte sequence\n+    private static final byte[] INVALID_UTF8_BYTE_SEQUENCE = {(byte) 0xF0, (byte) 0xA4, (byte) 0xAD};\n+\n+    \/\/ Expected ZipException regex\n+    private static final String BAD_ENTRY_NAME_OR_COMMENT = \"invalid CEN header \\\\(bad entry name or comment\\\\)\";\n+\n+    \/\/ ZIP file with invalid name field\n+    private Path invalidName;\n+\n+    \/\/ ZIP file with invalid comment field\n+    private Path invalidComment;\n+\n+    @BeforeTest\n+    public void setup() throws IOException {\n+        \/\/ Create a ZIP file with valid name and comment fields\n+        byte[] templateZip = templateZIP();\n+\n+        \/\/ Create a ZIP with a CEN name field containing an invalid byte sequence\n+        invalidName = invalidName(\"invalid-name.zip\", templateZip);\n+\n+        \/\/ Create a ZIP with a CEN comment field containing an invalid byte sequence\n+        invalidComment = invalidComment(\"invalid-comment.zip\", templateZip);\n+    }\n+\n+    \/**\n+     * Opening a ZipFile with an invalid UTF-8 byte sequence in\n+     * the name field of a CEN file header should throw a\n+     * ZipException with \"bad entry name or comment\"\n+     *\/\n+    @Test(expectedExceptions = ZipException.class,\n+            expectedExceptionsMessageRegExp = BAD_ENTRY_NAME_OR_COMMENT)\n+    public void shouldRejectInvalidName() throws IOException {\n+        try (ZipFile zf = new ZipFile(invalidName.toFile())) {\n+            \/\/ Should throw ZipException\n+        }\n+    }\n+\n+    \/**\n+     * Opening a ZipFile with an invalid UTF-8 byte sequence in\n+     * the comment field of a CEN file header should throw a\n+     * ZipException with \"bad entry name or comment\"\n+     *\/\n+    @Test(expectedExceptions = ZipException.class,\n+            expectedExceptionsMessageRegExp = BAD_ENTRY_NAME_OR_COMMENT)\n+    public void shouldIgnoreInvalidComment() throws IOException {\n+        try (ZipFile zf = new ZipFile(invalidComment.toFile())) {\n+            \/\/ Should throw ZipException\n+        }\n+    }\n+\n+    \/**\n+     * Make a valid ZIP file used as a template for invalid files\n+     *\/\n+    private byte[] templateZIP() throws IOException {\n+        ByteArrayOutputStream bout = new ByteArrayOutputStream();\n+        try (ZipOutputStream zo = new ZipOutputStream(bout)) {\n+            ZipEntry commentEntry = new ZipEntry(\"file\");\n+            commentEntry.setComment(\"Comment\");\n+            zo.putNextEntry(commentEntry);\n+        }\n+        return bout.toByteArray();\n+    }\n+\n+    \/**\n+     * Make a ZIP with invalid bytes in the CEN name field\n+     *\/\n+    private Path invalidName(String name, byte[] template) throws IOException {\n+        ByteBuffer buffer = copyTemplate(template);\n+        int off = cenStart(buffer);\n+        \/\/ Name field starts here\n+        int noff = off + CEN_HDR;\n+\n+        \/\/ Write invalid bytes\n+        buffer.put(noff, INVALID_UTF8_BYTE_SEQUENCE, 0, INVALID_UTF8_BYTE_SEQUENCE.length);\n+        return writeFile(name, buffer);\n+\n+    }\n+\n+    \/**\n+     * Make a copy of the ZIP template and wrap it in a little-endian\n+     * ByteBuffer\n+     *\/\n+    private ByteBuffer copyTemplate(byte[] template) {\n+        return ByteBuffer.wrap(Arrays.copyOf(template, template.length))\n+                .order(ByteOrder.LITTLE_ENDIAN);\n+    }\n+\n+    \/**\n+     * Make a ZIP with invalid bytes in the CEN comment field\n+     *\/\n+    private Path invalidComment(String name, byte[] template) throws IOException {\n+        ByteBuffer buffer = copyTemplate(template);\n+        int off = cenStart(buffer);\n+        \/\/ Need to skip past the length of the name and extra fields\n+        int nlen = buffer.getShort(off + NLEN);\n+        int elen = buffer.getShort(off + ELEN);\n+\n+        \/\/ Comment field starts here\n+        int coff = off + CEN_HDR + nlen + elen;\n+\n+        \/\/ Write invalid bytes\n+        buffer.put(coff, INVALID_UTF8_BYTE_SEQUENCE, 0, INVALID_UTF8_BYTE_SEQUENCE.length);\n+        return writeFile(name, buffer);\n+    }\n+\n+\n+    \/**\n+     * Finds the offset of the start of the CEN directory\n+      *\/\n+    private int cenStart(ByteBuffer buffer) {\n+        return buffer.getInt(buffer.capacity() - EOC_OFF);\n+    }\n+\n+    \/**\n+     * Utility to write a ByteBuffer to disk\n+     *\/\n+    private Path writeFile(String name, ByteBuffer buffer) throws IOException {\n+        Path zip = Path.of(name);\n+        try (FileChannel ch = new FileOutputStream(zip.toFile()).getChannel()) {\n+            buffer.rewind();\n+            ch.write(buffer);\n+        }\n+        return zip;\n+    }\n+}\n","filename":"test\/jdk\/java\/util\/zip\/ZipFile\/InvalidBytesInEntryNameOrComment.java","additions":182,"deletions":0,"binary":false,"changes":182,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,0 +41,1 @@\n+import java.nio.charset.StandardCharsets;\n@@ -118,0 +119,17 @@\n+    @Test\n+    public void latin1NotAscii() throws IOException {\n+\n+        Path zip = Path.of(\"latin1-not-ascii.zip\");\n+\n+        \/\/ latin1, but not ASCII\n+        String entryName = \"smörgåsbord\";\n+\n+        try (ZipOutputStream z = new ZipOutputStream(Files.newOutputStream(zip))) {\n+            z.putNextEntry(new ZipEntry(entryName));\n+        }\n+\n+        try (ZipFile z = new ZipFile(zip.toFile())) {\n+            assertNotNull(z.getEntry(entryName));\n+        }\n+    }\n+\n","filename":"test\/jdk\/java\/util\/zip\/ZipFile\/TestZipFileEncodings.java","additions":19,"deletions":1,"binary":false,"changes":20,"status":"modified"}]}