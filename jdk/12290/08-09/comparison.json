{"files":[{"patch":"@@ -59,1 +59,4 @@\n-     * Return values for {@link #compare(String, byte[], int, int, boolean)}\n+     * This enum represents the three possible return values for\n+     * {@link #compare(String, byte[], int, int, boolean)} when\n+     * this method compares a lookup name to a string encoded in a\n+     * byte array range.\n@@ -62,0 +65,4 @@\n+        \/**\n+         * The lookup string is exactly equal to\n+         * the string encoded in the byte array.\n+          *\/\n@@ -63,1 +70,11 @@\n-        SLASH_MATCH,\n+        \/**\n+         * The lookup string and the string encoded in\n+         * the byte array differs only by the\n+         * latter having a trailing '\/' character.\n+         *\/\n+        DIRECTORY_MATCH,\n+        \/**\n+         * The lookup string and the string encoded in\n+         * the byte array do not match. (They are\n+         * neither an exact match or a directory match).\n+         *\/\n@@ -197,3 +214,17 @@\n-     * Compares a string with a second string which is encoded in a given\n-     * byte array range, as if the second string was first decoded from\n-     * bytes using this ZipCoder's charset.\n+     * This method is used by ZipFile.Source.getEntryPos when comparing the\n+     * name being looked up to candidate names encoded in the CEN byte\n+     * array.\n+     *\n+     * Since ZipCode.getEntry supports looking up a \"dir\/\" entry by\n+     * the name \"dir\", this method can optionally distinguish an\n+     * exact match from a partial \"directory match\" (where names only\n+     * differ by the encoded name having an additional trailing '\/')\n+     *\n+     * The return values of this method are as follows:\n+     *\n+     * If the lookup name is exactly equal to the encoded string, return\n+     * {@link Comparison#EXACT_MATCH}.\n+     * \n+     * If the parameter {@code matchDirectory} is {@code true} and the\n+     * two strings differ only by the encoded string having an extra\n+     * trailing '\/' character, then return {@link Comparison#DIRECTORY_MATCH}.\n@@ -201,3 +232,0 @@\n-     * If the two strings match exactly, return {@link Comparison#EXACT_MATCH}.\n-     * If addSlash is true and the two strings only differ by the second string\n-     * having a trailing '\/', then return {@link Comparison#SLASH_MATCH}.\n@@ -208,1 +236,9 @@\n-     * is known and matches the charset of this ZipCoder.\n+     * and this ZipCoder are known to encode strings to the same bytes.\n+     *\n+     * @param str The lookup string to compare with the encoded string.\n+     * @param b The byte array holding the encoded string\n+     * @param off The offset into the array where the encoded string starts\n+     * @param len The length of the encoded string in bytes\n+     * @param matchDirectory If {@code true} and the strings do not match exactly,\n+     *                      a directory match will also be tested\n+     *\n@@ -210,1 +246,1 @@\n-    Comparison compare(String str, byte[] b, int off, int len, boolean addSlash) {\n+    Comparison compare(String str, byte[] b, int off, int len, boolean matchDirectory) {\n@@ -215,1 +251,1 @@\n-            } else if (addSlash\n+            } else if (matchDirectory\n@@ -218,1 +254,1 @@\n-                return Comparison.SLASH_MATCH;\n+                return Comparison.DIRECTORY_MATCH;\n@@ -273,1 +309,1 @@\n-        Comparison compare(String str, byte[] b, int off, int len, boolean addSlash) {\n+        Comparison compare(String str, byte[] b, int off, int len, boolean matchDirectory) {\n@@ -279,2 +315,2 @@\n-                } else if (addSlash && len == mismatch + 1 && hasTrailingSlash(b, off + len)) {\n-                    return Comparison.SLASH_MATCH;\n+                } else if (matchDirectory && len == mismatch + 1 && hasTrailingSlash(b, off + len)) {\n+                    return Comparison.DIRECTORY_MATCH;\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/ZipCoder.java","additions":51,"deletions":15,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -1636,1 +1636,1 @@\n-            int slashMatch = -1; \/\/ Position of secondary match \"name\/\"\n+            int dirPos = -1; \/\/ Position of secondary match \"name\/\"\n@@ -1642,1 +1642,0 @@\n-                    \/\/ Compare the lookup name with the name encoded in the CEN\n@@ -1650,0 +1649,1 @@\n+                    \/\/ Compare the lookup name with the name encoded in the CEN\n@@ -1652,1 +1652,1 @@\n-                            \/\/ Exact match for \"name\"\n+                            \/\/ We found an exact match for \"name\"\n@@ -1654,3 +1654,4 @@\n-                        case SLASH_MATCH:\n-                            \/\/ Match for \"name\/\", take note\n-                            slashMatch = pos;\n+                        case DIRECTORY_MATCH:\n+                            \/\/ We found the directory \"name\/\"\n+                            \/\/ Track its position, then continue the search for \"name\"\n+                            dirPos = pos;\n@@ -1659,1 +1660,1 @@\n-                            \/\/ Hash collision, continue search\n+                            \/\/ Hash collision, continue searching\n@@ -1664,2 +1665,7 @@\n-            \/\/ No exact match found, will return either slashMatch or -1\n-            return slashMatch;\n+            \/\/ Reaching this point means we did not find \"name\".\n+            \/\/ Return the position of \"name\/\" if we found it\n+            if (dirPos != -1) {\n+                return dirPos;\n+            }\n+            \/\/ No entry found\n+            return -1;\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/ZipFile.java","additions":15,"deletions":9,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -127,0 +127,9 @@\n+    \/**\n+     * This test was added to catch a regression where UTFZipCoder incorrectly\n+     * treated latin1-encoded Strings as UTF8-compatible, while this actually only\n+     * holds for ASCII strings.\n+     *\n+     * The implementation of UTFZipCoder.compare was later changed to not depend on\n+     * the String's coder. Let's keep this test around anyway, since it provokes\n+     * a corner case which could be easily missed.\n+     *\/\n@@ -143,0 +152,11 @@\n+    \/**\n+     * This test was added to catch a regression where ZipCoder.compare did not\n+     * properly verify that the lookup name is a prefix of the entry name. Because of\n+     * this regression, any candidate name with identical lengths and a trailing\n+     * '\/' would be incorrectly considered a \"directory match\".\n+     *\n+     * Since this regression depends on both a hash collision and that the length of names\n+     * are equal, it is rarely found in the wild. Let's keep this test around\n+     * since it explicity provokes this rare condition.\n+     *\n+     *\/\n@@ -146,0 +166,1 @@\n+        \/\/ (found in a brute force search)\n@@ -149,1 +170,1 @@\n-        \/\/ Create a ZIP with the two entries\n+        \/\/ Create a ZIP containing the two directories\n@@ -154,0 +175,1 @@\n+            \/\/ Give the names different comments so they we can distinguish them\n@@ -163,2 +185,2 @@\n-        \/\/ Assert that \"slashless\" lookups returns correct entry,\n-        \/\/ even when when hashes collide and lengths are equal\n+        \/\/ Assert that \"slashless\" lookups returns the correct entry even\n+        \/\/ when the directory names have colliding hash codes and equal lengths\n@@ -167,1 +189,1 @@\n-            ZipEntry second = z.getEntry(two.substring(0, two.length() - 1));\n+            ZipEntry second = z.getEntry(\"_____-408231241\");\n@@ -170,1 +192,1 @@\n-            ZipEntry first = z.getEntry(one.substring(0, one.length() - 1));\n+            ZipEntry first = z.getEntry(\"_____1637461950\");\n@@ -307,1 +329,1 @@\n-            ze.setTime(1675862371399L);\n+            ze.setTime(System.currentTimeMillis());\n","filename":"test\/jdk\/java\/util\/zip\/ZipFile\/TestZipFileEncodings.java","additions":28,"deletions":6,"binary":false,"changes":34,"status":"modified"}]}