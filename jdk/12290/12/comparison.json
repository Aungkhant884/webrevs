{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -58,0 +58,26 @@\n+    \/**\n+     * This enum represents the three possible return values for\n+     * {@link #compare(String, byte[], int, int, boolean)} when\n+     * this method compares a lookup name to a string encoded in a\n+     * byte array range.\n+     *\/\n+    enum Comparison {\n+        \/**\n+         * The lookup string is exactly equal to\n+         * the string encoded in the byte array.\n+          *\/\n+        EXACT_MATCH,\n+        \/**\n+         * The lookup string and the string encoded in\n+         * the byte array differs only by the\n+         * latter having a trailing '\/' character.\n+         *\/\n+        DIRECTORY_MATCH,\n+        \/**\n+         * The lookup string and the string encoded in\n+         * the byte array do not match. (They are\n+         * neither an exact match or a directory match).\n+         *\/\n+        NO_MATCH\n+    }\n+\n@@ -187,0 +213,46 @@\n+    \/**\n+     * This method is used by ZipFile.Source.getEntryPos when comparing the\n+     * name being looked up to candidate names encoded in the CEN byte\n+     * array.\n+     *\n+     * Since ZipCode.getEntry supports looking up a \"dir\/\" entry by\n+     * the name \"dir\", this method can optionally distinguish an\n+     * exact match from a partial \"directory match\" (where names only\n+     * differ by the encoded name having an additional trailing '\/')\n+     *\n+     * The return values of this method are as follows:\n+     *\n+     * If the lookup name is exactly equal to the encoded string, return\n+     * {@link Comparison#EXACT_MATCH}.\n+     *\n+     * If the parameter {@code matchDirectory} is {@code true} and the\n+     * two strings differ only by the encoded string having an extra\n+     * trailing '\/' character, then return {@link Comparison#DIRECTORY_MATCH}.\n+     *\n+     * Otherwise, return {@link Comparison#NO_MATCH}\n+     *\n+     * While a general implementation will need to decode bytes into a\n+     * String for comparison, this can be avoided if the String coder\n+     * and this ZipCoder are known to encode strings to the same bytes.\n+     *\n+     * @param str The lookup string to compare with the encoded string.\n+     * @param b The byte array holding the encoded string\n+     * @param off The offset into the array where the encoded string starts\n+     * @param len The length of the encoded string in bytes\n+     * @param matchDirectory If {@code true} and the strings do not match exactly,\n+     *                      a directory match will also be tested\n+     *\n+     *\/\n+    Comparison compare(String str, byte[] b, int off, int len, boolean matchDirectory) {\n+        String decoded = toString(b, off, len);\n+        if (decoded.startsWith(str)) {\n+            if (decoded.length() == str.length()) {\n+                return Comparison.EXACT_MATCH;\n+            } else if (matchDirectory\n+                && decoded.length() == str.length() + 1\n+                && decoded.endsWith(\"\/\") ) {\n+                return Comparison.DIRECTORY_MATCH;\n+            }\n+        }\n+        return Comparison.NO_MATCH;\n+    }\n@@ -235,0 +307,17 @@\n+\n+        @Override\n+        Comparison compare(String str, byte[] b, int off, int len, boolean matchDirectory) {\n+            try {\n+                byte[] encoded = JLA.getBytesNoRepl(str, UTF_8.INSTANCE);\n+                int mismatch = Arrays.mismatch(encoded, 0, encoded.length, b, off, off+len);\n+                if (mismatch == -1) {\n+                    return Comparison.EXACT_MATCH;\n+                } else if (matchDirectory && len == mismatch + 1 && hasTrailingSlash(b, off + len)) {\n+                    return Comparison.DIRECTORY_MATCH;\n+                } else {\n+                    return Comparison.NO_MATCH;\n+                }\n+            } catch (CharacterCodingException e) {\n+                return Comparison.NO_MATCH;\n+            }\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/ZipCoder.java","additions":90,"deletions":1,"binary":false,"changes":91,"status":"modified"},{"patch":"@@ -1636,0 +1636,2 @@\n+            int dirPos = -1; \/\/ Position of secondary match \"name\/\"\n+\n@@ -1640,1 +1642,1 @@\n-                    \/\/ The CEN name must match the specified one\n+\n@@ -1642,0 +1644,2 @@\n+                    int noff = pos + CENHDR;\n+                    int nlen = CENNAM(cen, pos);\n@@ -1643,11 +1647,6 @@\n-                    try {\n-                        ZipCoder zc = zipCoderForPos(pos);\n-                        String entry = zc.toString(cen, pos + CENHDR, CENNAM(cen, pos));\n-\n-                        \/\/ If addSlash is true we'll test for name+\/ in addition to\n-                        \/\/ name, unless name is the empty string or already ends with a\n-                        \/\/ slash\n-                        int entryLen = entry.length();\n-                        int nameLen = name.length();\n-                        if (entryLen == nameLen && entry.equals(name)) {\n-                            \/\/ Found our match\n+                    ZipCoder zc = zipCoderForPos(pos);\n+\n+                    \/\/ Compare the lookup name with the name encoded in the CEN\n+                    switch (zc.compare(name, cen, noff, nlen, addSlash)) {\n+                        case EXACT_MATCH:\n+                            \/\/ We found an exact match for \"name\"\n@@ -1655,11 +1654,7 @@\n-                        }\n-                        \/\/ If addSlash is true we'll now test for name+\/ providing\n-                        if (addSlash && nameLen + 1 == entryLen\n-                                && entry.startsWith(name) &&\n-                                entry.charAt(entryLen - 1) == '\/') {\n-                            \/\/ Found the entry \"name+\/\", now find the CEN entry pos\n-                            int exactPos = getEntryPos(name, false);\n-                            return exactPos == -1 ? pos : exactPos;\n-                        }\n-                    } catch (IllegalArgumentException iae) {\n-                        \/\/ Ignore\n+                        case DIRECTORY_MATCH:\n+                            \/\/ We found the directory \"name\/\"\n+                            \/\/ Track its position, then continue the search for \"name\"\n+                            dirPos = pos;\n+                            break;\n+                        case NO_MATCH:\n+                            \/\/ Hash collision, continue searching\n@@ -1670,0 +1665,6 @@\n+            \/\/ Reaching this point means we did not find \"name\".\n+            \/\/ Return the position of \"name\/\" if we found it\n+            if (dirPos != -1) {\n+                return dirPos;\n+            }\n+            \/\/ No entry found\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/ZipFile.java","additions":24,"deletions":23,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -0,0 +1,183 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+import org.testng.annotations.BeforeTest;\n+import org.testng.annotations.Test;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import java.nio.channels.FileChannel;\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipException;\n+import java.util.zip.ZipFile;\n+import java.util.zip.ZipOutputStream;\n+\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.expectThrows;\n+\n+\/**\n+ * @test\n+ * @summary Validate that opening ZIP files files with invalid UTF-8\n+ * byte sequences in the name or comment fields fails with ZipException\n+ * @run testng\/othervm InvalidBytesInEntryNameOrComment\n+ *\/\n+public class InvalidBytesInEntryNameOrComment {\n+\n+    \/\/ Offsets for navigating the CEN fields\n+    private static final int EOC_OFF = 6;   \/\/ Offset from EOF to find CEN offset\n+    private static final int CEN_HDR = 45;  \/\/ Size of a CEN header\n+    private static final int NLEN = 28;     \/\/ Name length\n+    private static final int ELEN = 30;     \/\/ Extra length\n+    private static final int CLEN = 32;     \/\/ Comment length\n+\n+    \/\/ Example invalid UTF-8 byte sequence\n+    private static final byte[] INVALID_UTF8_BYTE_SEQUENCE = {(byte) 0xF0, (byte) 0xA4, (byte) 0xAD};\n+\n+    \/\/ Expected ZipException regex\n+    private static final String BAD_ENTRY_NAME_OR_COMMENT = \"invalid CEN header (bad entry name or comment)\";\n+\n+    \/\/ ZIP file with invalid name field\n+    private Path invalidName;\n+\n+    \/\/ ZIP file with invalid comment field\n+    private Path invalidComment;\n+\n+    @BeforeTest\n+    public void setup() throws IOException {\n+        \/\/ Create a ZIP file with valid name and comment fields\n+        byte[] templateZip = templateZIP();\n+\n+        \/\/ Create a ZIP with a CEN name field containing an invalid byte sequence\n+        invalidName = invalidName(\"invalid-name.zip\", templateZip);\n+\n+        \/\/ Create a ZIP with a CEN comment field containing an invalid byte sequence\n+        invalidComment = invalidComment(\"invalid-comment.zip\", templateZip);\n+    }\n+\n+    \/**\n+     * Opening a ZipFile with an invalid UTF-8 byte sequence in\n+     * the name field of a CEN file header should throw a\n+     * ZipException with \"bad entry name or comment\"\n+     *\/\n+    @Test\n+    public void shouldRejectInvalidName() throws IOException {\n+        ZipException ex = expectThrows(ZipException.class, () -> {\n+            new ZipFile(invalidName.toFile());\n+        });\n+        assertEquals(ex.getMessage(), BAD_ENTRY_NAME_OR_COMMENT);\n+    }\n+\n+    \/**\n+     * Opening a ZipFile with an invalid UTF-8 byte sequence in\n+     * the comment field of a CEN file header should throw a\n+     * ZipException with \"bad entry name or comment\"\n+     *\/\n+    @Test\n+    public void shouldRejectInvalidComment() throws IOException {\n+        ZipException ex = expectThrows(ZipException.class, () -> {\n+            new ZipFile(invalidName.toFile());\n+        });\n+        assertEquals(ex.getMessage(), BAD_ENTRY_NAME_OR_COMMENT);\n+    }\n+\n+    \/**\n+     * Make a valid ZIP file used as a template for invalid files\n+     *\/\n+    private byte[] templateZIP() throws IOException {\n+        ByteArrayOutputStream bout = new ByteArrayOutputStream();\n+        try (ZipOutputStream zo = new ZipOutputStream(bout)) {\n+            ZipEntry commentEntry = new ZipEntry(\"file\");\n+            commentEntry.setComment(\"Comment\");\n+            zo.putNextEntry(commentEntry);\n+        }\n+        return bout.toByteArray();\n+    }\n+\n+    \/**\n+     * Make a ZIP with invalid bytes in the CEN name field\n+     *\/\n+    private Path invalidName(String name, byte[] template) throws IOException {\n+        ByteBuffer buffer = copyTemplate(template);\n+        int off = cenStart(buffer);\n+        \/\/ Name field starts here\n+        int noff = off + CEN_HDR;\n+\n+        \/\/ Write invalid bytes\n+        buffer.put(noff, INVALID_UTF8_BYTE_SEQUENCE, 0, INVALID_UTF8_BYTE_SEQUENCE.length);\n+        return writeFile(name, buffer);\n+\n+    }\n+\n+    \/**\n+     * Make a copy of the ZIP template and wrap it in a little-endian\n+     * ByteBuffer\n+     *\/\n+    private ByteBuffer copyTemplate(byte[] template) {\n+        return ByteBuffer.wrap(Arrays.copyOf(template, template.length))\n+                .order(ByteOrder.LITTLE_ENDIAN);\n+    }\n+\n+    \/**\n+     * Make a ZIP with invalid bytes in the CEN comment field\n+     *\/\n+    private Path invalidComment(String name, byte[] template) throws IOException {\n+        ByteBuffer buffer = copyTemplate(template);\n+        int off = cenStart(buffer);\n+        \/\/ Need to skip past the length of the name and extra fields\n+        int nlen = buffer.getShort(off + NLEN);\n+        int elen = buffer.getShort(off + ELEN);\n+\n+        \/\/ Comment field starts here\n+        int coff = off + CEN_HDR + nlen + elen;\n+\n+        \/\/ Write invalid bytes\n+        buffer.put(coff, INVALID_UTF8_BYTE_SEQUENCE, 0, INVALID_UTF8_BYTE_SEQUENCE.length);\n+        return writeFile(name, buffer);\n+    }\n+\n+\n+    \/**\n+     * Finds the offset of the start of the CEN directory\n+      *\/\n+    private int cenStart(ByteBuffer buffer) {\n+        return buffer.getInt(buffer.capacity() - EOC_OFF);\n+    }\n+\n+    \/**\n+     * Utility to write a ByteBuffer to disk\n+     *\/\n+    private Path writeFile(String name, ByteBuffer buffer) throws IOException {\n+        Path zip = Path.of(name);\n+        try (FileChannel ch = new FileOutputStream(zip.toFile()).getChannel()) {\n+            buffer.rewind();\n+            ch.write(buffer);\n+        }\n+        return zip;\n+    }\n+}\n","filename":"test\/jdk\/java\/util\/zip\/ZipFile\/InvalidBytesInEntryNameOrComment.java","additions":183,"deletions":0,"binary":false,"changes":183,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,0 +41,1 @@\n+import java.nio.charset.StandardCharsets;\n@@ -56,0 +57,1 @@\n+import java.util.stream.Stream;\n@@ -98,0 +100,7 @@\n+    @DataProvider(name = \"all-charsets\")\n+    public Object[][] allCharsets() {\n+        return Stream.concat(Stream.of(nonUnicodeCharsets()),\n+                        Stream.of(unicodeCharsets()))\n+                .toArray(Object[][]::new);\n+    }\n+\n@@ -118,0 +127,70 @@\n+    \/**\n+     * This test was added to catch a regression where UTFZipCoder incorrectly\n+     * treated latin1-encoded Strings as UTF8-compatible, while this actually only\n+     * holds for ASCII strings.\n+     *\n+     * The implementation of UTFZipCoder.compare was later changed to not depend on\n+     * the String's coder. Let's keep this test around anyway, since it provokes\n+     * a corner case which could be easily missed.\n+     *\/\n+    @Test\n+    public void latin1NotAscii() throws IOException {\n+\n+        Path zip = Path.of(\"latin1-not-ascii.zip\");\n+\n+        \/\/ latin1, but not ASCII\n+        String entryName = \"smörgåsbord\";\n+\n+        try (ZipOutputStream z = new ZipOutputStream(Files.newOutputStream(zip))) {\n+            z.putNextEntry(new ZipEntry(entryName));\n+        }\n+\n+        try (ZipFile z = new ZipFile(zip.toFile())) {\n+            assertNotNull(z.getEntry(entryName));\n+        }\n+    }\n+    \/**\n+     * This test was added to catch a regression where ZipCoder.compare did not\n+     * properly verify that the lookup name is a prefix of the entry name. Because of\n+     * this regression, any candidate name with identical lengths and a trailing\n+     * '\/' would be incorrectly considered a \"directory match\".\n+     *\n+     * Since this regression depends on both a hash collision and that the length of names\n+     * are equal, it is rarely found in the wild. Let's keep this test around\n+     * since it explicity provokes this rare condition.\n+     *\n+     *\/\n+    @Test(dataProvider = \"all-charsets\")\n+    public void sameHashAndLengthDirLookup(String charsetName) throws IOException {\n+        \/\/ Two directory names with colliding hash codes and same length\n+        \/\/ (found in a brute force search)\n+        String one = \"_____1637461950\/\";\n+        String two = \"_____-408231241\/\";\n+\n+        \/\/ Create a ZIP containing the two directories\n+        Charset charset = Charset.forName(charsetName);\n+        Path zip = Path.of(\"hash-collision-slashmatch-utf16.zip\");\n+        try (ZipOutputStream z = new ZipOutputStream(Files.newOutputStream(zip), charset)) {\n+\n+            \/\/ Give the names different comments so they we can distinguish them\n+            ZipEntry first = new ZipEntry(one);\n+            first.setComment(\"Entry one\");\n+            z.putNextEntry(first);\n+\n+            ZipEntry second = new ZipEntry(two);\n+            second.setComment(\"Entry two\");\n+            z.putNextEntry(second);\n+        }\n+\n+        \/\/ Assert that \"slashless\" lookups returns the correct entry even\n+        \/\/ when the directory names have colliding hash codes and equal lengths\n+        try (ZipFile z = new ZipFile(zip.toFile(), charset)) {\n+\n+            ZipEntry second = z.getEntry(\"_____-408231241\");\n+            assertEquals(second.getComment(), \"Entry two\");\n+\n+            ZipEntry first = z.getEntry(\"_____1637461950\");\n+            assertEquals(first.getComment(), \"Entry one\");\n+        }\n+    }\n+\n","filename":"test\/jdk\/java\/util\/zip\/ZipFile\/TestZipFileEncodings.java","additions":80,"deletions":1,"binary":false,"changes":81,"status":"modified"}]}