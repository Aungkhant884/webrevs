{"files":[{"patch":"@@ -1459,0 +1459,77 @@\n+static errno_t convert_to_UTF16(char const* source_str, UINT source_encoding, LPWSTR* dest_utf16_str) {\n+  const int flag_source_str_is_null_terminated = -1;\n+  const int flag_estimate_chars_count = 0;\n+  int utf16_chars_count_estimated = MultiByteToWideChar(source_encoding,\n+                                                        MB_ERR_INVALID_CHARS,\n+                                                        source_str, flag_source_str_is_null_terminated,\n+                                                        NULL, flag_estimate_chars_count);\n+  if (utf16_chars_count_estimated == 0) {\n+    \/\/ Probably source_str contains characters that cannot be represented in the source_encoding given.\n+    *dest_utf16_str = NULL;\n+    return EINVAL;\n+  }\n+\n+  *dest_utf16_str = NEW_C_HEAP_ARRAY(WCHAR, utf16_chars_count_estimated, mtInternal);\n+\n+  int utf16_chars_count_real = MultiByteToWideChar(source_encoding,\n+                                                   MB_ERR_INVALID_CHARS,\n+                                                   source_str, flag_source_str_is_null_terminated,\n+                                                   *dest_utf16_str, utf16_chars_count_estimated);\n+  assert(utf16_chars_count_real == utf16_chars_count_estimated, \"length already checked above\");\n+\n+  return ERROR_SUCCESS;\n+}\n+\n+\/\/ Converts a string in the \"platform\" encoding to UTF16.\n+static errno_t convert_to_UTF16(char const* platform_str, LPWSTR* utf16_str) {\n+  return convert_to_UTF16(platform_str, CP_ACP, utf16_str);\n+}\n+\n+static errno_t convert_UTF8_to_UTF16(char const* utf8_str, LPWSTR* utf16_str) {\n+  return convert_to_UTF16(utf8_str, CP_UTF8, utf16_str);\n+}\n+\n+\/\/ Converts a wide-character string in UTF-16 encoding to the 8-bit \"platform\" encoding.\n+\/\/ Unless the platform encoding is UTF-8, not all characters in the source string can be represented in the dest string.\n+\/\/ The function succeeds in this case anyway and just replaces these with a certain character.\n+static errno_t convert_UTF16_to_platform(LPWSTR source_utf16_str, char*& dest_str) {\n+  const int flag_source_str_is_null_terminated = -1;\n+  const int flag_estimate_chars_count = 0;\n+  int chars_count_estimated = WideCharToMultiByte(CP_ACP,\n+                                                  0,\n+                                                  source_utf16_str, flag_source_str_is_null_terminated,\n+                                                  NULL, flag_estimate_chars_count, NULL, NULL);\n+  if (chars_count_estimated == 0) {\n+    dest_str = NULL;\n+    return EINVAL;\n+  }\n+\n+  dest_str = NEW_C_HEAP_ARRAY(CHAR, chars_count_estimated, mtInternal);\n+\n+  int chars_count_real = WideCharToMultiByte(CP_ACP,\n+                                             0,\n+                                             source_utf16_str, flag_source_str_is_null_terminated,\n+                                             dest_str, chars_count_estimated, NULL, NULL);\n+  assert(chars_count_real == chars_count_estimated, \"length already checked above\");\n+\n+  return ERROR_SUCCESS;\n+}\n+\n+class MemoryReleaserW : public StackObj {\n+private:\n+  WCHAR* _object_ptr;\n+\n+public:\n+  MemoryReleaserW(WCHAR * object_ptr) : _object_ptr(object_ptr) {}\n+  ~MemoryReleaserW() { if (_object_ptr != NULL) FREE_C_HEAP_ARRAY(WCHAR, _object_ptr); }\n+};\n+\n+class MemoryReleaser : public StackObj {\n+private:\n+  CHAR* _object_ptr;\n+\n+public:\n+  MemoryReleaser(CHAR * object_ptr) : _object_ptr(object_ptr) {}\n+  ~MemoryReleaser() { if (_object_ptr != NULL) FREE_C_HEAP_ARRAY(CHAR, _object_ptr); }\n+};\n+\n@@ -1462,2 +1539,16 @@\n-void * os::dll_load(const char *name, char *ebuf, int ebuflen) {\n-  log_info(os)(\"attempting shared library load of %s\", name);\n+void * os::dll_load(const char *utf8_name, char *ebuf, int ebuflen) {\n+  LPWSTR utf16_name = NULL;\n+  errno_t err = convert_UTF8_to_UTF16(utf8_name, &utf16_name);\n+  MemoryReleaserW release_utf16_name(utf16_name);\n+  if (err != ERROR_SUCCESS) {\n+    errno = err;\n+    return NULL;\n+  }\n+\n+  char* platform_name = NULL; \/\/ name of the library converted to the \"platform\" encoding for use in log messages\n+  errno_t ignored_err = convert_UTF16_to_platform(utf16_name, platform_name);\n+  MemoryReleaser release_platform_name(platform_name);\n+\n+  log_info(os)(\"attempting shared library load of %s\", platform_name);\n+\n+  void * result = LoadLibraryW(utf16_name);\n@@ -1465,1 +1556,0 @@\n-  void * result = LoadLibrary(name);\n@@ -1467,1 +1557,1 @@\n-    Events::log(NULL, \"Loaded shared library %s\", name);\n+    Events::log(NULL, \"Loaded shared library %s\", platform_name);\n@@ -1470,1 +1560,1 @@\n-    log_info(os)(\"shared library load of %s was successful\", name);\n+    log_info(os)(\"shared library load of %s was successful\", platform_name);\n@@ -1478,2 +1568,2 @@\n-  Events::log(NULL, \"Loading shared library %s failed, error code %lu\", name, errcode);\n-  log_info(os)(\"shared library load of %s failed, error code %lu\", name, errcode);\n+  Events::log(NULL, \"Loading shared library %s failed, error code %lu\", platform_name, errcode);\n+  log_info(os)(\"shared library load of %s failed, error code %lu\", platform_name, errcode);\n@@ -1492,1 +1582,1 @@\n-  int fd = ::open(name, O_RDONLY | O_BINARY, 0);\n+  int fd = ::wopen(utf16_name, O_RDONLY | O_BINARY, 0);\n@@ -4296,21 +4386,0 @@\n-static errno_t convert_to_unicode(char const* char_path, LPWSTR* unicode_path) {\n-  \/\/ Get required buffer size to convert to Unicode\n-  int unicode_path_len = MultiByteToWideChar(CP_ACP,\n-                                             MB_ERR_INVALID_CHARS,\n-                                             char_path, -1,\n-                                             NULL, 0);\n-  if (unicode_path_len == 0) {\n-    return EINVAL;\n-  }\n-\n-  *unicode_path = NEW_C_HEAP_ARRAY(WCHAR, unicode_path_len, mtInternal);\n-\n-  int result = MultiByteToWideChar(CP_ACP,\n-                                   MB_ERR_INVALID_CHARS,\n-                                   char_path, -1,\n-                                   *unicode_path, unicode_path_len);\n-  assert(result == unicode_path_len, \"length already checked above\");\n-\n-  return ERROR_SUCCESS;\n-}\n-\n@@ -4377,1 +4446,1 @@\n-  err = convert_to_unicode(buf, &unicode_path);\n+  err = convert_to_UTF16(buf, &unicode_path);\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":99,"deletions":30,"binary":false,"changes":129,"status":"modified"},{"patch":"@@ -3356,1 +3356,1 @@\n-JVM_ENTRY_NO_ENV(void*, JVM_LoadLibrary(const char* name))\n+JVM_ENTRY_NO_ENV(void*, JVM_LoadLibrary(const char* utf8_name))\n@@ -3362,1 +3362,1 @@\n-    load_result = os::dll_load(name, ebuf, sizeof ebuf);\n+    load_result = os::dll_load(utf8_name, ebuf, sizeof ebuf);\n@@ -3366,5 +3366,1 @@\n-    jio_snprintf(msg, sizeof msg, \"%s: %s\", name, ebuf);\n-    \/\/ Since 'ebuf' may contain a string encoded using\n-    \/\/ platform encoding scheme, we need to pass\n-    \/\/ Exceptions::unsafe_to_utf8 to the new_exception method\n-    \/\/ as the last argument. See bug 6367357.\n+    jio_snprintf(msg, sizeof msg, \"%s: %s\", utf8_name, ebuf);\n@@ -3374,1 +3370,1 @@\n-                                msg, Exceptions::unsafe_to_utf8);\n+                                msg);\n@@ -3378,1 +3374,1 @@\n-  log_info(library)(\"Loaded library %s, handle \" INTPTR_FORMAT, name, p2i(load_result));\n+  log_info(library)(\"Loaded library %s, handle \" INTPTR_FORMAT, utf8_name, p2i(load_result));\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":5,"deletions":9,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -115,0 +115,1 @@\n+#define wopen _wopen\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions_visCPP.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -118,1 +118,0 @@\n-    const char *cname;\n@@ -127,4 +126,9 @@\n-    cname = JNU_GetStringPlatformChars(env, name, 0);\n-    if (cname == 0)\n-        return JNI_FALSE;\n-    handle = isBuiltin ? procHandle : JVM_LoadLibrary(cname);\n+    const int utf8_len    = (*env)->GetStringUTFLength(env, name);\n+    const int chars_count = (*env)->GetStringLength(env, name);\n+    char * utf8_name = malloc(utf8_len + 1);\n+    if (utf8_name == NULL) {\n+      JNU_ThrowOutOfMemoryError(env, NULL);\n+      return JNI_FALSE;\n+    }\n+    (*env)->GetStringUTFRegion(env, name, 0, chars_count, utf8_name);\n+    handle = isBuiltin ? procHandle : JVM_LoadLibrary(utf8_name);\n@@ -135,1 +139,1 @@\n-                                                       isBuiltin ? cname : NULL,\n+                                                       isBuiltin ? utf8_name : NULL,\n@@ -160,1 +164,1 @@\n-                             jniVersion, cname);\n+                             jniVersion, utf8_name);\n@@ -182,1 +186,1 @@\n-    JNU_ReleaseStringPlatformChars(env, name, cname);\n+    free(utf8_name);\n","filename":"src\/java.base\/share\/native\/libjava\/NativeLibraries.c","additions":12,"deletions":8,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -0,0 +1,86 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, JetBrains s.r.o.. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+\n+import jdk.test.lib.Platform;\n+import jdk.test.lib.Asserts;\n+\n+public class LoadLibraryUnicode {\n+\n+    static native int giveANumber();\n+\n+    private static final String NON_LATIN_PATH_NAME = \"ka-\\u1889-omega-\\u03c9\";\n+\n+    public static void verifySystemLoad() throws Exception {\n+        String osDependentLibraryFileName = null;\n+        if (Platform.isLinux()) {\n+            osDependentLibraryFileName = \"libLoadLibraryUnicode.so\";\n+        } else if (Platform.isOSX()) {\n+            osDependentLibraryFileName = \"libLoadLibraryUnicode.dylib\";\n+        } else if (Platform.isWindows()) {\n+            osDependentLibraryFileName = \"LoadLibraryUnicode.dll\";\n+        } else {\n+            throw new Error(\"Unsupported OS\");\n+        }\n+\n+        String testNativePath = LoadLibraryUnicodeTest.getSystemProperty(\"test.nativepath\");\n+        Path origLibraryPath = Paths.get(testNativePath).resolve(osDependentLibraryFileName);\n+\n+        Path currentDirPath = Paths.get(\".\").toAbsolutePath();\n+        Path newLibraryPath = currentDirPath.resolve(NON_LATIN_PATH_NAME);\n+        Files.createDirectory(newLibraryPath);\n+        newLibraryPath = newLibraryPath.resolve(osDependentLibraryFileName);\n+\n+        System.out.println(String.format(\"Copying '%s' to '%s'\", origLibraryPath, newLibraryPath));\n+        Files.copy(origLibraryPath, newLibraryPath);\n+\n+        System.out.println(String.format(\"Loading '%s'\", newLibraryPath));\n+        System.load(newLibraryPath.toString());\n+\n+        final int retval = giveANumber();\n+        Asserts.assertEquals(retval, 42);\n+    }\n+\n+    public static void verifyExceptionMessage() throws Exception {\n+        Path currentDirPath = Paths.get(\".\").toAbsolutePath();\n+        Path newLibraryPath = currentDirPath.resolve(NON_LATIN_PATH_NAME).resolve(\"non-existent-library\");\n+\n+        System.out.println(String.format(\"Loading '%s'\", newLibraryPath));\n+        try {\n+            System.load(newLibraryPath.toString());\n+        } catch(UnsatisfiedLinkError e) {\n+            \/\/ The name of the library may have been corrupted by encoding\/decoding it improperly.\n+            \/\/ Verify that it is still the same.\n+            Asserts.assertTrue(e.getMessage().contains(NON_LATIN_PATH_NAME));\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        verifySystemLoad();\n+        verifyExceptionMessage();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/jni\/loadLibraryUnicode\/LoadLibraryUnicode.java","additions":86,"deletions":0,"binary":false,"changes":86,"status":"added"},{"patch":"@@ -0,0 +1,58 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, JetBrains s.r.o.. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @bug 8195129\n+ * @summary regression test for 8195129,\n+ *          verifies the ability to System.load() from a location containing non-Latin characters\n+ * @requires (os.family == \"windows\") | (os.family == \"mac\") | (os.family == \"linux\")\n+ * @library \/test\/lib\n+ * @build LoadLibraryUnicode\n+ * @run main\/native LoadLibraryUnicodeTest\n+ *\/\n+\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class LoadLibraryUnicodeTest {\n+\n+    public static void main(String args[]) throws Exception {\n+        String nativePathSetting = \"-Dtest.nativepath=\" + getSystemProperty(\"test.nativepath\");\n+        ProcessBuilder pb = ProcessTools.createTestJvm(nativePathSetting, LoadLibraryUnicode.class.getName());\n+        pb.environment().put(\"LC_ALL\", \"en_US.UTF-8\");\n+        ProcessTools.executeProcess(pb)\n+                    .outputTo(System.out)\n+                    .errorTo(System.err)\n+                    .shouldHaveExitValue(0);\n+    }\n+\n+    \/\/ Utility method to retrieve and validate system properties\n+    public static String getSystemProperty(String propertyName) throws Error {\n+        String systemProperty = System.getProperty(propertyName, \"\").trim();\n+        System.out.println(propertyName + \" = \" + systemProperty);\n+        if (systemProperty.isEmpty()) {\n+            throw new Error(\"TESTBUG: property \" + propertyName + \" is empty\");\n+        }\n+        return systemProperty;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/jni\/loadLibraryUnicode\/LoadLibraryUnicodeTest.java","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -0,0 +1,29 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, JetBrains s.r.o.. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+#include <jni.h>\n+\n+JNIEXPORT jint JNICALL\n+Java_LoadLibraryUnicode_giveANumber(JNIEnv *env) {\n+    return 42;\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/jni\/loadLibraryUnicode\/libLoadLibraryUnicode.c","additions":29,"deletions":0,"binary":false,"changes":29,"status":"added"}]}