{"files":[{"patch":"@@ -1459,0 +1459,80 @@\n+static errno_t convert_to_UTF16(char const* source_str, UINT source_encoding, LPWSTR* dest_utf16_str) {\n+  const int len_estimated = MultiByteToWideChar(source_encoding,\n+                                                MB_ERR_INVALID_CHARS,\n+                                                source_str,\n+                                                -1, \/\/ source is null-terminated\n+                                                NULL,\n+                                                0); \/\/ estimate characters count\n+  if (len_estimated == 0) {\n+    \/\/ Probably source_str contains characters that cannot be represented in the source_encoding given.\n+    *dest_utf16_str = NULL;\n+    return EINVAL;\n+  }\n+\n+  *dest_utf16_str = NEW_C_HEAP_ARRAY(WCHAR, len_estimated, mtInternal);\n+\n+  const int len_real = MultiByteToWideChar(source_encoding,\n+                                           MB_ERR_INVALID_CHARS,\n+                                           source_str,\n+                                           -1, \/\/ source is null-terminated\n+                                           *dest_utf16_str, len_estimated);\n+  assert(len_real == len_estimated, \"length already checked above\");\n+\n+  return ERROR_SUCCESS;\n+}\n+\n+\/\/ Converts a string in the \"platform\" encoding to UTF16.\n+static errno_t convert_to_UTF16(char const* platform_str, LPWSTR* utf16_str) {\n+  return convert_to_UTF16(platform_str, CP_ACP, utf16_str);\n+}\n+\n+static errno_t convert_UTF8_to_UTF16(char const* utf8_str, LPWSTR* utf16_str) {\n+  return convert_to_UTF16(utf8_str, CP_UTF8, utf16_str);\n+}\n+\n+\/\/ Converts a wide-character string in UTF-16 encoding to the 8-bit \"platform\" encoding.\n+\/\/ Unless the platform encoding is UTF-8, not all characters in the source string can be represented in the dest string.\n+\/\/ The function succeeds in this case anyway and just replaces these with a certain character.\n+static errno_t convert_UTF16_to_platform(LPWSTR source_utf16_str, char*& dest_str) {\n+  const int len_estimated = WideCharToMultiByte(CP_ACP,\n+                                                0,\n+                                                source_utf16_str,\n+                                                -1, \/\/ source is null-terminated\n+                                                NULL,\n+                                                0, \/\/ estimate characters count\n+                                                NULL, NULL);\n+  if (len_estimated == 0) {\n+    dest_str = NULL;\n+    return EINVAL;\n+  }\n+\n+  dest_str = NEW_C_HEAP_ARRAY(CHAR, len_estimated, mtInternal);\n+\n+  const int len_real = WideCharToMultiByte(CP_ACP,\n+                                           0,\n+                                           source_utf16_str,\n+                                           -1, \/\/ source is null-terminated\n+                                           dest_str, len_estimated, NULL, NULL);\n+  assert(len_real == len_estimated, \"length already checked above\");\n+\n+  return ERROR_SUCCESS;\n+}\n+\n+class MemoryReleaserW : public StackObj {\n+private:\n+  WCHAR* _object_ptr;\n+\n+public:\n+  MemoryReleaserW(WCHAR * object_ptr) : _object_ptr(object_ptr) {}\n+  ~MemoryReleaserW() { if (_object_ptr != NULL) FREE_C_HEAP_ARRAY(WCHAR, _object_ptr); }\n+};\n+\n+class MemoryReleaser : public StackObj {\n+private:\n+  CHAR* _object_ptr;\n+\n+public:\n+  MemoryReleaser(CHAR * object_ptr) : _object_ptr(object_ptr) {}\n+  ~MemoryReleaser() { if (_object_ptr != NULL) FREE_C_HEAP_ARRAY(CHAR, _object_ptr); }\n+};\n+\n@@ -1462,2 +1542,16 @@\n-void * os::dll_load(const char *name, char *ebuf, int ebuflen) {\n-  log_info(os)(\"attempting shared library load of %s\", name);\n+void * os::dll_load(const char *utf8_name, char *ebuf, int ebuflen) {\n+  LPWSTR utf16_name = NULL;\n+  errno_t err = convert_UTF8_to_UTF16(utf8_name, &utf16_name);\n+  MemoryReleaserW release_utf16_name(utf16_name);\n+  if (err != ERROR_SUCCESS) {\n+    errno = err;\n+    return NULL;\n+  }\n+\n+  char* platform_name = NULL; \/\/ name of the library converted to the \"platform\" encoding for use in log messages\n+  errno_t ignored_err = convert_UTF16_to_platform(utf16_name, platform_name);\n+  MemoryReleaser release_platform_name(platform_name);\n+\n+  log_info(os)(\"attempting shared library load of %s\", platform_name);\n+\n+  void * result = LoadLibraryW(utf16_name);\n@@ -1465,1 +1559,0 @@\n-  void * result = LoadLibrary(name);\n@@ -1467,1 +1560,1 @@\n-    Events::log(NULL, \"Loaded shared library %s\", name);\n+    Events::log(NULL, \"Loaded shared library %s\", platform_name);\n@@ -1470,1 +1563,1 @@\n-    log_info(os)(\"shared library load of %s was successful\", name);\n+    log_info(os)(\"shared library load of %s was successful\", platform_name);\n@@ -1478,2 +1571,2 @@\n-  Events::log(NULL, \"Loading shared library %s failed, error code %lu\", name, errcode);\n-  log_info(os)(\"shared library load of %s failed, error code %lu\", name, errcode);\n+  Events::log(NULL, \"Loading shared library %s failed, error code %lu\", platform_name, errcode);\n+  log_info(os)(\"shared library load of %s failed, error code %lu\", platform_name, errcode);\n@@ -1492,1 +1585,1 @@\n-  int fd = ::open(name, O_RDONLY | O_BINARY, 0);\n+  int fd = ::wopen(utf16_name, O_RDONLY | O_BINARY, 0);\n@@ -4296,21 +4389,0 @@\n-static errno_t convert_to_unicode(char const* char_path, LPWSTR* unicode_path) {\n-  \/\/ Get required buffer size to convert to Unicode\n-  int unicode_path_len = MultiByteToWideChar(CP_ACP,\n-                                             MB_ERR_INVALID_CHARS,\n-                                             char_path, -1,\n-                                             NULL, 0);\n-  if (unicode_path_len == 0) {\n-    return EINVAL;\n-  }\n-\n-  *unicode_path = NEW_C_HEAP_ARRAY(WCHAR, unicode_path_len, mtInternal);\n-\n-  int result = MultiByteToWideChar(CP_ACP,\n-                                   MB_ERR_INVALID_CHARS,\n-                                   char_path, -1,\n-                                   *unicode_path, unicode_path_len);\n-  assert(result == unicode_path_len, \"length already checked above\");\n-\n-  return ERROR_SUCCESS;\n-}\n-\n@@ -4377,1 +4449,1 @@\n-  err = convert_to_unicode(buf, &unicode_path);\n+  err = convert_to_UTF16(buf, &unicode_path);\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":102,"deletions":30,"binary":false,"changes":132,"status":"modified"},{"patch":"@@ -3356,1 +3356,1 @@\n-JVM_ENTRY_NO_ENV(void*, JVM_LoadLibrary(const char* name))\n+JVM_ENTRY_NO_ENV(void*, JVM_LoadLibrary(const char* utf8_name))\n@@ -3362,1 +3362,1 @@\n-    load_result = os::dll_load(name, ebuf, sizeof ebuf);\n+    load_result = os::dll_load(utf8_name, ebuf, sizeof ebuf);\n@@ -3366,5 +3366,1 @@\n-    jio_snprintf(msg, sizeof msg, \"%s: %s\", name, ebuf);\n-    \/\/ Since 'ebuf' may contain a string encoded using\n-    \/\/ platform encoding scheme, we need to pass\n-    \/\/ Exceptions::unsafe_to_utf8 to the new_exception method\n-    \/\/ as the last argument. See bug 6367357.\n+    jio_snprintf(msg, sizeof msg, \"%s: %s\", utf8_name, ebuf);\n@@ -3374,1 +3370,1 @@\n-                                msg, Exceptions::unsafe_to_utf8);\n+                                msg);\n@@ -3378,1 +3374,1 @@\n-  log_info(library)(\"Loaded library %s, handle \" INTPTR_FORMAT, name, p2i(load_result));\n+  log_info(library)(\"Loaded library %s, handle \" INTPTR_FORMAT, utf8_name, p2i(load_result));\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":5,"deletions":9,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -115,0 +115,1 @@\n+#define wopen _wopen\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions_visCPP.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -118,1 +118,0 @@\n-    const char *cname;\n@@ -127,4 +126,4 @@\n-    cname = JNU_GetStringPlatformChars(env, name, 0);\n-    if (cname == 0)\n-        return JNI_FALSE;\n-    handle = isBuiltin ? procHandle : JVM_LoadLibrary(cname);\n+    const char * utf8_name = GetStringUTF8Chars(env, name);\n+    if (utf8_name == NULL)\n+            return JNI_FALSE;\n+    handle = isBuiltin ? procHandle : JVM_LoadLibrary(utf8_name);\n@@ -135,1 +134,1 @@\n-                                                       isBuiltin ? cname : NULL,\n+                                                       isBuiltin ? utf8_name : NULL,\n@@ -160,1 +159,1 @@\n-                             jniVersion, cname);\n+                             jniVersion, utf8_name);\n@@ -182,1 +181,1 @@\n-    JNU_ReleaseStringPlatformChars(env, name, cname);\n+    ReleaseStringUTF8Chars(env, name, utf8_name);\n","filename":"src\/java.base\/share\/native\/libjava\/NativeLibraries.c","additions":7,"deletions":8,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -633,0 +633,1 @@\n+static jstring utf8Encoding = NULL;     \/* Java String \"UTF-8\" *\/\n@@ -642,1 +643,0 @@\n-static jboolean isJNUEncodingSupported = JNI_FALSE;\n@@ -644,0 +644,1 @@\n+    static jboolean isJNUEncodingSupported = JNI_FALSE;\n@@ -657,0 +658,24 @@\n+\/* Tests true if encoding by the name of \"UTF-8\" is supported by java.nio *\/\n+static jboolean utf8EncodingSupported(JNIEnv *env) {\n+    if (utf8Encoding == NULL) { \/\/ Cache jstring \"UTF-8\"\n+        jstring utf8Str = (*env)->NewStringUTF(env, \"UTF-8\");\n+        if (utf8Str == NULL) {\n+            return JNI_FALSE;\n+        }\n+        utf8Encoding = (jstring)(*env)->NewGlobalRef(env, utf8Str);\n+        (*env)->DeleteLocalRef(env, utf8Str);\n+    }\n+    static jboolean isUTF8EncodingSupported = JNI_FALSE;\n+    if (isUTF8EncodingSupported == JNI_TRUE) {\n+        return JNI_TRUE;\n+    }\n+    jboolean sawException;\n+    isUTF8EncodingSupported = (jboolean) JNU_CallStaticMethodByName (\n+            env, &sawException,\n+            \"java\/nio\/charset\/Charset\",\n+            \"isSupported\",\n+            \"(Ljava\/lang\/String;)Z\",\n+            utf8Encoding).z;\n+    return isUTF8EncodingSupported;\n+}\n+\n@@ -818,1 +843,5 @@\n-static const char* getStringBytes(JNIEnv *env, jstring jstr) {\n+\/* Convert the given Java string into a null-terminated byte sequence according\n+ * to the platform encoding (if needUTF8 is false) or to UTF-8 encoding (if\n+ * needUTF8 is true).\n+ *\/\n+static const char* getStringBytes(JNIEnv *env, jstring jstr, jboolean needUTF8) {\n@@ -825,1 +854,3 @@\n-    if (jnuEncodingSupported(env)) {\n+    if (needUTF8 && utf8EncodingSupported(env)) {\n+      hab = (*env)->CallObjectMethod(env, jstr, String_getBytes_ID, utf8Encoding);\n+    } else if (!needUTF8 && jnuEncodingSupported(env)) {\n@@ -866,1 +897,2 @@\n-        return getStringBytes(env, jstr);\n+        const jboolean forceUTF8 = (fastEncoding != FAST_UTF_8);\n+        return getStringBytes(env, jstr, forceUTF8);\n@@ -909,0 +941,12 @@\n+JNIEXPORT const char * JNICALL\n+GetStringUTF8Chars(JNIEnv *env, jstring jstr)\n+{\n+    return getStringUTF8(env, jstr);\n+}\n+\n+JNIEXPORT void\n+ReleaseStringUTF8Chars(JNIEnv* env, jstring jstr, const char *str)\n+{\n+    free((void *)str);\n+}\n+\n@@ -928,1 +972,1 @@\n-        return getStringBytes(env, jstr);\n+        return getStringBytes(env, jstr, JNI_FALSE \/* Need platform encoding *\/);\n","filename":"src\/java.base\/share\/native\/libjava\/jni_util.c","additions":49,"deletions":5,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -99,0 +99,7 @@\n+\/* Convert the Java string to UTF-8 (not \"modified UTF-8\") *\/\n+JNIEXPORT const char *\n+GetStringUTF8Chars(JNIEnv *env, jstring jstr);\n+\n+JNIEXPORT void\n+ReleaseStringUTF8Chars(JNIEnv* env, jstring jstr, const char *str);\n+\n","filename":"src\/java.base\/share\/native\/libjava\/jni_util.h","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,82 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, JetBrains s.r.o.. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+\n+import jdk.test.lib.Platform;\n+import jdk.test.lib.Asserts;\n+\n+public class LoadLibraryUnicode {\n+\n+    static native int giveANumber();\n+\n+    \/\/ Use non-Latin characters from basic (\\u1889) and supplementary (\\uD844\\uDDD9) Unicode planes\n+    private static final String NON_LATIN_PATH_NAME = \"ka-\\u1889-supp-\\uD844\\uDDD9\";\n+\n+    private static String toPlatformLibraryName(String name) {\n+        return (Platform.isWindows() ? \"\" : \"lib\") + name + \".\" + Platform.sharedLibraryExt();\n+    }\n+\n+    public static void verifySystemLoad() throws Exception {\n+        final String osDependentLibraryFileName = toPlatformLibraryName(\"LoadLibraryUnicode\");\n+\n+        String testNativePath = LoadLibraryUnicodeTest.getSystemProperty(\"test.nativepath\");\n+        Path origLibraryPath = Paths.get(testNativePath).resolve(osDependentLibraryFileName);\n+\n+        Path currentDirPath = Paths.get(\".\").toAbsolutePath();\n+        Path newLibraryPath = currentDirPath.resolve(NON_LATIN_PATH_NAME);\n+        Files.createDirectory(newLibraryPath);\n+        newLibraryPath = newLibraryPath.resolve(osDependentLibraryFileName);\n+\n+        System.out.println(String.format(\"Copying '%s' to '%s'\", origLibraryPath, newLibraryPath));\n+        Files.copy(origLibraryPath, newLibraryPath);\n+\n+        System.out.println(String.format(\"Loading '%s'\", newLibraryPath));\n+        System.load(newLibraryPath.toString());\n+\n+        final int retval = giveANumber();\n+        Asserts.assertEquals(retval, 42);\n+    }\n+\n+    public static void verifyExceptionMessage() throws Exception {\n+        Path currentDirPath = Paths.get(\".\").toAbsolutePath();\n+        Path newLibraryPath = currentDirPath.resolve(NON_LATIN_PATH_NAME).resolve(\"non-existent-library\");\n+\n+        System.out.println(String.format(\"Loading '%s'\", newLibraryPath));\n+        try {\n+            System.load(newLibraryPath.toString());\n+        } catch(UnsatisfiedLinkError e) {\n+            \/\/ The name of the library may have been corrupted by encoding\/decoding it improperly.\n+            \/\/ Verify that it is still the same.\n+            Asserts.assertTrue(e.getMessage().contains(NON_LATIN_PATH_NAME));\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        verifySystemLoad();\n+        verifyExceptionMessage();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/jni\/loadLibraryUnicode\/LoadLibraryUnicode.java","additions":82,"deletions":0,"binary":false,"changes":82,"status":"added"},{"patch":"@@ -0,0 +1,58 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, JetBrains s.r.o.. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @bug 8195129\n+ * @summary regression test for 8195129,\n+ *          verifies the ability to System.load() from a location containing non-Latin characters\n+ * @requires (os.family == \"windows\")\n+ * @library \/test\/lib\n+ * @build LoadLibraryUnicode\n+ * @run main\/native LoadLibraryUnicodeTest\n+ *\/\n+\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class LoadLibraryUnicodeTest {\n+\n+    public static void main(String args[]) throws Exception {\n+        String nativePathSetting = \"-Dtest.nativepath=\" + getSystemProperty(\"test.nativepath\");\n+        ProcessBuilder pb = ProcessTools.createTestJvm(nativePathSetting, LoadLibraryUnicode.class.getName());\n+        pb.environment().put(\"LC_ALL\", \"en_US.UTF-8\");\n+        ProcessTools.executeProcess(pb)\n+                    .outputTo(System.out)\n+                    .errorTo(System.err)\n+                    .shouldHaveExitValue(0);\n+    }\n+\n+    \/\/ Utility method to retrieve and validate system properties\n+    public static String getSystemProperty(String propertyName) throws Error {\n+        String systemProperty = System.getProperty(propertyName, \"\").trim();\n+        System.out.println(propertyName + \" = \" + systemProperty);\n+        if (systemProperty.isEmpty()) {\n+            throw new Error(\"TESTBUG: property \" + propertyName + \" is empty\");\n+        }\n+        return systemProperty;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/jni\/loadLibraryUnicode\/LoadLibraryUnicodeTest.java","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -0,0 +1,29 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, JetBrains s.r.o.. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+#include <jni.h>\n+\n+JNIEXPORT jint JNICALL\n+Java_LoadLibraryUnicode_giveANumber(JNIEnv *env) {\n+    return 42;\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/jni\/loadLibraryUnicode\/libLoadLibraryUnicode.c","additions":29,"deletions":0,"binary":false,"changes":29,"status":"added"}]}