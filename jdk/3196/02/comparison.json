{"files":[{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2016, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2016, 2019 SAP SE. All rights reserved.\n+ * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2021 SAP SE. All rights reserved.\n@@ -1331,0 +1331,4 @@\n+#define KMA_ZOPC    (unsigned  int)(0xb9 << 24 | 0x29 << 16)     \/\/ cipher\n+#define KMF_ZOPC    (unsigned  int)(0xb9 << 24 | 0x2a << 16)     \/\/ cipher\n+#define KMCTR_ZOPC  (unsigned  int)(0xb9 << 24 | 0x2d << 16)     \/\/ cipher\n+#define KMO_ZOPC    (unsigned  int)(0xb9 << 24 | 0x2b << 16)     \/\/ cipher\n@@ -2379,6 +2383,10 @@\n-  inline void z_cksm(Register r1, Register r2);                       \/\/ checksum. This is NOT CRC32\n-  inline void z_km(  Register r1, Register r2);                       \/\/ cipher message\n-  inline void z_kmc( Register r1, Register r2);                       \/\/ cipher message with chaining\n-  inline void z_kimd(Register r1, Register r2);                       \/\/ msg digest (SHA)\n-  inline void z_klmd(Register r1, Register r2);                       \/\/ msg digest (SHA)\n-  inline void z_kmac(Register r1, Register r2);                       \/\/ msg authentication code\n+  inline void z_cksm( Register r1, Register r2);                       \/\/ checksum. This is NOT CRC32\n+  inline void z_km(   Register r1, Register r2);                       \/\/ cipher message\n+  inline void z_kmc(  Register r1, Register r2);                       \/\/ cipher message with chaining\n+  inline void z_kma(  Register r1, Register r3, Register r2);          \/\/ cipher message with authentication\n+  inline void z_kmf(  Register r1, Register r2);                       \/\/ cipher message with cipher feedback\n+  inline void z_kmctr(Register r1, Register r3, Register r2);          \/\/ cipher message with counter\n+  inline void z_kmo(  Register r1, Register r2);                       \/\/ cipher message with output feedback\n+  inline void z_kimd( Register r1, Register r2);                       \/\/ msg digest (SHA)\n+  inline void z_klmd( Register r1, Register r2);                       \/\/ msg digest (SHA)\n+  inline void z_kmac( Register r1, Register r2);                       \/\/ msg authentication code\n@@ -3020,2 +3028,2 @@\n-  inline void z_bvaf(Label& L);   \/\/ not all false (mixed or all true)\n-  inline void z_bvnf(Label& L);   \/\/ all false\n+  inline void z_bvnf(Label& L);   \/\/ not all false (mixed or all true)\n+  inline void z_bvaf(Label& L);   \/\/ all false\n","filename":"src\/hotspot\/cpu\/s390\/assembler_s390.hpp","additions":18,"deletions":10,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2016, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2016, 2017 SAP SE. All rights reserved.\n+ * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2021 SAP SE. All rights reserved.\n@@ -93,1 +93,1 @@\n-inline void Assembler::z_strl(Register r1, int64_t i2)  { emit_48( STRL_ZOPC   | regt(r1, 8, 48) | simm32(i2, 16, 48)); }\n+inline void Assembler::z_strl( Register r1, int64_t i2) { emit_48( STRL_ZOPC   | regt(r1, 8, 48) | simm32(i2, 16, 48)); }\n@@ -96,6 +96,10 @@\n-inline void Assembler::z_cksm(Register r1, Register r2) { emit_32( CKSM_ZOPC   | regt(r1, 24, 32) | regt(r2, 28, 32)); }\n-inline void Assembler::z_km(  Register r1, Register r2) { emit_32( KM_ZOPC     | regt(r1, 24, 32) | regt(r2, 28, 32)); }\n-inline void Assembler::z_kmc( Register r1, Register r2) { emit_32( KMC_ZOPC    | regt(r1, 24, 32) | regt(r2, 28, 32)); }\n-inline void Assembler::z_kimd(Register r1, Register r2) { emit_32( KIMD_ZOPC   | regt(r1, 24, 32) | regt(r2, 28, 32)); }\n-inline void Assembler::z_klmd(Register r1, Register r2) { emit_32( KLMD_ZOPC   | regt(r1, 24, 32) | regt(r2, 28, 32)); }\n-inline void Assembler::z_kmac(Register r1, Register r2) { emit_32( KMAC_ZOPC   | regt(r1, 24, 32) | regt(r2, 28, 32)); }\n+inline void Assembler::z_cksm( Register r1, Register r2) { emit_32( CKSM_ZOPC   | regt(r1, 24, 32) | regt(r2, 28, 32)); }\n+inline void Assembler::z_km(   Register r1, Register r2) { emit_32( KM_ZOPC     | regt(r1, 24, 32) | regt(r2, 28, 32)); }\n+inline void Assembler::z_kmc(  Register r1, Register r2) { emit_32( KMC_ZOPC    | regt(r1, 24, 32) | regt(r2, 28, 32)); }\n+inline void Assembler::z_kma(  Register r1, Register r3, Register r2) { emit_32( KMA_ZOPC    | regt(r3, 16, 32) | regt(r1, 24, 32) | regt(r2, 28, 32)); }\n+inline void Assembler::z_kmf(  Register r1, Register r2) { emit_32( KMF_ZOPC    | regt(r1, 24, 32) | regt(r2, 28, 32)); }\n+inline void Assembler::z_kmctr(Register r1, Register r3, Register r2) { emit_32( KMCTR_ZOPC  | regt(r3, 16, 32) | regt(r1, 24, 32) | regt(r2, 28, 32)); }\n+inline void Assembler::z_kmo(  Register r1, Register r2) { emit_32( KMO_ZOPC    | regt(r1, 24, 32) | regt(r2, 28, 32)); }\n+inline void Assembler::z_kimd( Register r1, Register r2) { emit_32( KIMD_ZOPC   | regt(r1, 24, 32) | regt(r2, 28, 32)); }\n+inline void Assembler::z_klmd( Register r1, Register r2) { emit_32( KLMD_ZOPC   | regt(r1, 24, 32) | regt(r2, 28, 32)); }\n+inline void Assembler::z_kmac( Register r1, Register r2) { emit_32( KMAC_ZOPC   | regt(r1, 24, 32) | regt(r2, 28, 32)); }\n","filename":"src\/hotspot\/cpu\/s390\/assembler_s390.inline.hpp","additions":13,"deletions":9,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2016, 2020 SAP SE. All rights reserved.\n+ * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2021 SAP SE. All rights reserved.\n@@ -41,8 +41,16 @@\n-unsigned long VM_Version::_features[_features_buffer_len]           = {0, 0, 0, 0};\n-unsigned long VM_Version::_cipher_features[_features_buffer_len]    = {0, 0, 0, 0};\n-unsigned long VM_Version::_msgdigest_features[_features_buffer_len] = {0, 0, 0, 0};\n-unsigned int  VM_Version::_nfeatures                                = 0;\n-unsigned int  VM_Version::_ncipher_features                         = 0;\n-unsigned int  VM_Version::_nmsgdigest_features                      = 0;\n-unsigned int  VM_Version::_Dcache_lineSize                          = DEFAULT_CACHE_LINE_SIZE;\n-unsigned int  VM_Version::_Icache_lineSize                          = DEFAULT_CACHE_LINE_SIZE;\n+unsigned long VM_Version::_features[_features_buffer_len]              = {0, 0, 0, 0};\n+unsigned long VM_Version::_cipher_features_KM[_features_buffer_len]    = {0, 0, 0, 0};\n+unsigned long VM_Version::_cipher_features_KMA[_features_buffer_len]   = {0, 0, 0, 0};\n+unsigned long VM_Version::_cipher_features_KMF[_features_buffer_len]   = {0, 0, 0, 0};\n+unsigned long VM_Version::_cipher_features_KMCTR[_features_buffer_len] = {0, 0, 0, 0};\n+unsigned long VM_Version::_cipher_features_KMO[_features_buffer_len]   = {0, 0, 0, 0};\n+unsigned long VM_Version::_msgdigest_features[_features_buffer_len]    = {0, 0, 0, 0};\n+unsigned int  VM_Version::_nfeatures                                   = 0;\n+unsigned int  VM_Version::_ncipher_features_KM                         = 0;\n+unsigned int  VM_Version::_ncipher_features_KMA                        = 0;\n+unsigned int  VM_Version::_ncipher_features_KMF                        = 0;\n+unsigned int  VM_Version::_ncipher_features_KMCTR                      = 0;\n+unsigned int  VM_Version::_ncipher_features_KMO                        = 0;\n+unsigned int  VM_Version::_nmsgdigest_features                         = 0;\n+unsigned int  VM_Version::_Dcache_lineSize                             = DEFAULT_CACHE_LINE_SIZE;\n+unsigned int  VM_Version::_Icache_lineSize                             = DEFAULT_CACHE_LINE_SIZE;\n@@ -64,5 +72,16 @@\n-static const char* z_gen[]     = {\"  \", \"G1\",         \"G2\",         \"G3\",         \"G4\",         \"G5\",         \"G6\",         \"G7\",         \"G8\",         \"G9\"  };\n-static const char* z_machine[] = {\"  \", \"2064\",       \"2084\",       \"2094\",       \"2097\",       \"2817\",       \"2827\",       \"2964\",       \"3906\",       \"8561\" };\n-static const char* z_name[]    = {\"  \", \"z900\",       \"z990\",       \"z9 EC\",      \"z10 EC\",     \"z196 EC\",    \"ec12\",       \"z13\",        \"z14\",        \"z15\" };\n-static const char* z_WDFM[]    = {\"  \", \"2006-06-30\", \"2008-06-30\", \"2010-06-30\", \"2012-06-30\", \"2014-06-30\", \"2016-12-31\", \"2019-06-30\", \"2021-06-30\", \"tbd\" };\n-static const char* z_EOS[]     = {\"  \", \"2014-12-31\", \"2014-12-31\", \"2017-10-31\", \"2019-12-31\", \"2021-12-31\", \"tbd\",        \"tbd\",        \"tbd\",        \"tbd\" };\n+static const char* z_gen[]      = {\"  \", \"G1\",         \"G2\",         \"G3\",         \"G4\",         \"G5\",         \"G6\",         \"G7\",         \"G8\",         \"G9\"  };\n+static const char* z_machine[]  = {\"  \", \"2064\",       \"2084\",       \"2094\",       \"2097\",       \"2817\",       \"2827\",       \"2964\",       \"3906\",       \"8561\" };\n+static const char* z_name[]     = {\"  \", \"z900\",       \"z990\",       \"z9 EC\",      \"z10 EC\",     \"z196 EC\",    \"ec12\",       \"z13\",        \"z14\",        \"z15\" };\n+static const char* z_WDFM[]     = {\"  \", \"2006-06-30\", \"2008-06-30\", \"2010-06-30\", \"2012-06-30\", \"2014-06-30\", \"2016-12-31\", \"2019-06-30\", \"2021-06-30\", \"tbd\" };\n+static const char* z_EOS[]      = {\"  \", \"2014-12-31\", \"2014-12-31\", \"2017-10-31\", \"2019-12-31\", \"2021-12-31\", \"tbd\",        \"tbd\",        \"tbd\",        \"tbd\" };\n+static const char* z_features[] = {\"  \",\n+                                   \"system-z, g1-z900, ldisp\",\n+                                   \"system-z, g2-z990, ldisp_fast\",\n+                                   \"system-z, g3-z9, ldisp_fast, extimm\",\n+                                   \"system-z, g4-z10, ldisp_fast, extimm, pcrel_load\/store, cmpb\",\n+                                   \"system-z, g5-z196, ldisp_fast, extimm, pcrel_load\/store, cmpb, cond_load\/store, interlocked_update\",\n+                                   \"system-z, g6-ec12, ldisp_fast, extimm, pcrel_load\/store, cmpb, cond_load\/store, interlocked_update, txm\",\n+                                   \"system-z, g7-z13, ldisp_fast, extimm, pcrel_load\/store, cmpb, cond_load\/store, interlocked_update, txm, vectorinstr\",\n+                                   \"system-z, g8-z14, ldisp_fast, extimm, pcrel_load\/store, cmpb, cond_load\/store, interlocked_update, txm, vectorinstr, instrext2, venh1)\",\n+                                   \"system-z, g9-z15, ldisp_fast, extimm, pcrel_load\/store, cmpb, cond_load\/store, interlocked_update, txm, vectorinstr, instrext2, venh1, instrext3, VEnh2 )\"\n+                                  };\n@@ -74,2 +93,2 @@\n-  if (Verbose) {\n-    print_features();\n+  if (Verbose || PrintAssembly || PrintStubCode) {\n+    print_features_internal(\"CPU Version as detected internally:\", PrintAssembly || PrintStubCode);\n@@ -281,11 +300,8 @@\n-void VM_Version::set_features_string() {\n-  \/\/ A note on the _features_string format:\n-  \/\/   There are jtreg tests checking the _features_string for various properties.\n-  \/\/   For some strange reason, these tests require the string to contain\n-  \/\/   only _lowercase_ characters. Keep that in mind when being surprised\n-  \/\/   about the unusual notation of features - and when adding new ones.\n-  \/\/   Features may have one comma at the end.\n-  \/\/   Furthermore, use one, and only one, separator space between features.\n-  \/\/   Multiple spaces are considered separate tokens, messing up everything.\n-  unsigned int ambiguity = 0;\n-  unsigned int model_ix  = 0;\n+int VM_Version::get_model_index() {\n+  \/\/ returns the index used to access the various model-dependent strings.\n+  \/\/  > 0 valid (known) model detected.\n+  \/\/  = 0 model not recognized, maybe not yet supported.\n+  \/\/  < 0 model detection is ambiguous. The absolute value of the returned value\n+  \/\/      is the index of the oldest detected model.\n+  int ambiguity = 0;\n+  int model_ix  = 0;\n@@ -293,1 +309,0 @@\n-    _features_string = \"system-z g9-z15 ldisp_fast, extimm, pcrel_load\/store, cmpb, cond_load\/store, interlocked_update, txm, vectorinstr, instrext2, venh1, instrext3, VEnh2 )\";\n@@ -298,1 +313,0 @@\n-    _features_string = \"system-z g8-z14 ldisp_fast, extimm, pcrel_load\/store, cmpb, cond_load\/store, interlocked_update, txm, vectorinstr, instrext2, venh1)\";\n@@ -303,1 +317,0 @@\n-    _features_string = \"system-z, g7-z13, ldisp_fast, extimm, pcrel_load\/store, cmpb, cond_load\/store, interlocked_update, txm, vectorinstr\";\n@@ -308,1 +321,0 @@\n-    _features_string = \"system-z, g6-ec12, ldisp_fast, extimm, pcrel_load\/store, cmpb, cond_load\/store, interlocked_update, txm\";\n@@ -313,1 +325,0 @@\n-    _features_string = \"system-z, g5-z196, ldisp_fast, extimm, pcrel_load\/store, cmpb, cond_load\/store, interlocked_update\";\n@@ -318,1 +329,0 @@\n-    _features_string = \"system-z, g4-z10, ldisp_fast, extimm, pcrel_load\/store, cmpb\";\n@@ -323,1 +333,0 @@\n-    _features_string = \"system-z, g3-z9, ldisp_fast, extimm\";\n@@ -328,1 +337,0 @@\n-    _features_string = \"system-z, g2-z990, ldisp_fast\";\n@@ -333,1 +341,0 @@\n-    _features_string = \"system-z, g1-z900, ldisp\";\n@@ -338,0 +345,18 @@\n+  if (ambiguity > 1) {\n+    model_ix = -model_ix;\n+  }\n+  return model_ix;\n+}\n+\n+\n+void VM_Version::set_features_string() {\n+  \/\/ A note on the _features_string format:\n+  \/\/   There are jtreg tests checking the _features_string for various properties.\n+  \/\/   For some strange reason, these tests require the string to contain\n+  \/\/   only _lowercase_ characters. Keep that in mind when being surprised\n+  \/\/   about the unusual notation of features - and when adding new ones.\n+  \/\/   Features may have one comma at the end.\n+  \/\/   Furthermore, use one, and only one, separator space between features.\n+  \/\/   Multiple spaces are considered separate tokens, messing up everything.\n+\n+  int model_ix = get_model_index();\n@@ -339,1 +364,2 @@\n-  if (ambiguity == 0) {\n+  if (model_ix == 0) {\n+    _model_string = \"unknown model\";\n@@ -341,1 +367,1 @@\n-  } else if (ambiguity == 1) {\n+  } else if (model_ix > 0) {\n@@ -343,4 +369,5 @@\n-    jio_snprintf(buf, sizeof(buf), \"%s, out-of-support_as_of_\", _features_string, z_EOS[model_ix]);\n-  } else if (ambiguity > 1) {\n-    tty->print_cr(\"*** WARNING *** Ambiguous z\/Architecture detection, ambiguity = %d\", ambiguity);\n-    tty->print_cr(\"                oldest detected generation is %s\", _features_string);\n+    jio_snprintf(buf, sizeof(buf), \"%s, out-of-support_as_of_\", z_features[model_ix], z_EOS[model_ix]);\n+  } else if (model_ix < 0) {\n+    tty->print_cr(\"*** WARNING *** Ambiguous z\/Architecture detection!\");\n+    tty->print_cr(\"                oldest detected generation is %s\", z_features[-model_ix]);\n+    _model_string = \"unknown model\";\n@@ -401,5 +428,1 @@\n-  tty->print_cr(\"%s %s\",       text, features_string());\n-  tty->print(\"%s\", text);\n-  for (unsigned int i = 0; i < _nfeatures; i++) {\n-    tty->print(\"  0x%16.16lx\", _features[i]);\n-  }\n+  tty->print_cr(\"%s %s\", text, features_string());\n@@ -435,1 +458,1 @@\n-    if (has_ExtractCPUAttributes()     ) tty->print_cr(\"  available: %s\", \"Extract CPU Atributes\");\n+    if (has_ExtractCPUAttributes()     ) tty->print_cr(\"  available: %s\", \"Extract CPU Attributes\");\n@@ -451,1 +474,1 @@\n-    if (has_MiscInstrExt()             ) tty->print_cr(\"available: %s\", \"Miscelaneous Instruction Extensions\");\n+    if (has_MiscInstrExt()             ) tty->print_cr(\"available: %s\", \"Miscellaneous Instruction Extensions\");\n@@ -464,1 +487,1 @@\n-    if (has_MiscInstrExt2()            ) tty->print_cr(\"available: %s\", \"Miscelaneous Instruction Extensions 2\");\n+    if (has_MiscInstrExt2()            ) tty->print_cr(\"available: %s\", \"Miscellaneous Instruction Extensions 2\");\n@@ -468,1 +491,1 @@\n-    if (has_MiscInstrExt3()            ) tty->print_cr(\"available: %s\", \"Miscelaneous Instruction Extensions 3\");\n+    if (has_MiscInstrExt3()            ) tty->print_cr(\"available: %s\", \"Miscellaneous Instruction Extensions 3\");\n@@ -475,1 +498,1 @@\n-      if (test_feature_bit(&_cipher_features[0], -1, 2*Cipher::_featureBits)) {\n+      if (test_feature_bit(&_cipher_features_KM[0], -1, 2*Cipher::_featureBits)) {\n@@ -479,1 +502,2 @@\n-      if (test_feature_bit(&_cipher_features[0], -1, (int)Cipher::_featureBits)) {\n+\n+      if (test_feature_bit(&_cipher_features_KM[0], -1, (int)Cipher::_featureBits)) {\n@@ -482,1 +506,1 @@\n-          if (test_feature_bit(&_cipher_features[0], i, (int)Cipher::_featureBits)) {\n+          if (test_feature_bit(&_cipher_features_KM[0], i, (int)Cipher::_featureBits)) {\n@@ -506,1 +530,2 @@\n-      if (test_feature_bit(&_cipher_features[2], -1, (int)Cipher::_featureBits)) {\n+\n+      if (test_feature_bit(&_cipher_features_KM[2], -1, (int)Cipher::_featureBits)) {\n@@ -509,1 +534,1 @@\n-            if (test_feature_bit(&_cipher_features[2], i, (int)Cipher::_featureBits)) {\n+          if (test_feature_bit(&_cipher_features_KM[2], i, (int)Cipher::_featureBits)) {\n@@ -530,0 +555,50 @@\n+    }\n+\n+    if (has_CryptoExt4()) {\n+      if (test_feature_bit(&_cipher_features_KMF[0], -1, (int)Cipher::_featureBits)) {\n+        tty->print_cr(\"    available Crypto Features of KMF (Cipher Message with Cipher Feedback):\");\n+        for (unsigned int i = 0; i < Cipher::_featureBits; i++) {\n+          if (test_feature_bit(&_cipher_features_KMF[0], i, (int)Cipher::_featureBits)) {\n+            switch (i) {\n+              case Cipher::_Query:              tty->print_cr(\"      available: KMF  Query\");                  break;\n+              case Cipher::_DEA:                tty->print_cr(\"      available: KMF  DEA\");                    break;\n+              case Cipher::_TDEA128:            tty->print_cr(\"      available: KMF  TDEA-128\");               break;\n+              case Cipher::_TDEA192:            tty->print_cr(\"      available: KMF  TDEA-192\");               break;\n+              case Cipher::_EncryptedDEA:       tty->print_cr(\"      available: KMF  Encrypted DEA\");          break;\n+              case Cipher::_EncryptedDEA128:    tty->print_cr(\"      available: KMF  Encrypted DEA-128\");      break;\n+              case Cipher::_EncryptedDEA192:    tty->print_cr(\"      available: KMF  Encrypted DEA-192\");      break;\n+              case Cipher::_AES128:             tty->print_cr(\"      available: KMF  AES-128\");                break;\n+              case Cipher::_AES192:             tty->print_cr(\"      available: KMF  AES-192\");                break;\n+              case Cipher::_AES256:             tty->print_cr(\"      available: KMF  AES-256\");                break;\n+              case Cipher::_EnccryptedAES128:   tty->print_cr(\"      available: KMF  Encrypted-AES-128\");      break;\n+              case Cipher::_EnccryptedAES192:   tty->print_cr(\"      available: KMF  Encrypted-AES-192\");      break;\n+              case Cipher::_EnccryptedAES256:   tty->print_cr(\"      available: KMF  Encrypted-AES-256\");      break;\n+              default: tty->print_cr(\"      available: unknown KMF code %d\", i);      break;\n+            }\n+          }\n+        }\n+      }\n+\n+      if (test_feature_bit(&_cipher_features_KMCTR[0], -1, (int)Cipher::_featureBits)) {\n+        tty->print_cr(\"    available Crypto Features of KMCTR (Cipher Message with Counter):\");\n+        for (unsigned int i = 0; i < Cipher::_featureBits; i++) {\n+          if (test_feature_bit(&_cipher_features_KMCTR[0], i, (int)Cipher::_featureBits)) {\n+            switch (i) {\n+              case Cipher::_Query:              tty->print_cr(\"      available: KMCTR  Query\");                break;\n+              case Cipher::_DEA:                tty->print_cr(\"      available: KMCTR  DEA\");                  break;\n+              case Cipher::_TDEA128:            tty->print_cr(\"      available: KMCTR  TDEA-128\");             break;\n+              case Cipher::_TDEA192:            tty->print_cr(\"      available: KMCTR  TDEA-192\");             break;\n+              case Cipher::_EncryptedDEA:       tty->print_cr(\"      available: KMCTR  Encrypted DEA\");        break;\n+              case Cipher::_EncryptedDEA128:    tty->print_cr(\"      available: KMCTR  Encrypted DEA-128\");    break;\n+              case Cipher::_EncryptedDEA192:    tty->print_cr(\"      available: KMCTR  Encrypted DEA-192\");    break;\n+              case Cipher::_AES128:             tty->print_cr(\"      available: KMCTR  AES-128\");              break;\n+              case Cipher::_AES192:             tty->print_cr(\"      available: KMCTR  AES-192\");              break;\n+              case Cipher::_AES256:             tty->print_cr(\"      available: KMCTR  AES-256\");              break;\n+              case Cipher::_EnccryptedAES128:   tty->print_cr(\"      available: KMCTR  Encrypted-AES-128\");    break;\n+              case Cipher::_EnccryptedAES192:   tty->print_cr(\"      available: KMCTR  Encrypted-AES-192\");    break;\n+              case Cipher::_EnccryptedAES256:   tty->print_cr(\"      available: KMCTR  Encrypted-AES-256\");    break;\n+              default: tty->print_cr(\"      available: unknown KMCTR code %d\", i);      break;\n+            }\n+          }\n+        }\n+      }\n@@ -531,0 +606,46 @@\n+      if (test_feature_bit(&_cipher_features_KMO[0], -1, (int)Cipher::_featureBits)) {\n+        tty->print_cr(\"    available Crypto Features of KMO (Cipher Message with Output Feedback):\");\n+        for (unsigned int i = 0; i < Cipher::_featureBits; i++) {\n+          if (test_feature_bit(&_cipher_features_KMO[0], i, (int)Cipher::_featureBits)) {\n+            switch (i) {\n+              case Cipher::_Query:              tty->print_cr(\"      available: KMO  Query\");                  break;\n+              case Cipher::_DEA:                tty->print_cr(\"      available: KMO  DEA\");                    break;\n+              case Cipher::_TDEA128:            tty->print_cr(\"      available: KMO  TDEA-128\");               break;\n+              case Cipher::_TDEA192:            tty->print_cr(\"      available: KMO  TDEA-192\");               break;\n+              case Cipher::_EncryptedDEA:       tty->print_cr(\"      available: KMO  Encrypted DEA\");          break;\n+              case Cipher::_EncryptedDEA128:    tty->print_cr(\"      available: KMO  Encrypted DEA-128\");      break;\n+              case Cipher::_EncryptedDEA192:    tty->print_cr(\"      available: KMO  Encrypted DEA-192\");      break;\n+              case Cipher::_AES128:             tty->print_cr(\"      available: KMO  AES-128\");                break;\n+              case Cipher::_AES192:             tty->print_cr(\"      available: KMO  AES-192\");                break;\n+              case Cipher::_AES256:             tty->print_cr(\"      available: KMO  AES-256\");                break;\n+              case Cipher::_EnccryptedAES128:   tty->print_cr(\"      available: KMO  Encrypted-AES-128\");      break;\n+              case Cipher::_EnccryptedAES192:   tty->print_cr(\"      available: KMO  Encrypted-AES-192\");      break;\n+              case Cipher::_EnccryptedAES256:   tty->print_cr(\"      available: KMO  Encrypted-AES-256\");      break;\n+              default: tty->print_cr(\"      available: unknown KMO code %d\", i);      break;\n+            }\n+          }\n+        }\n+      }\n+    }\n+\n+    if (has_CryptoExt8()) {\n+      if (test_feature_bit(&_cipher_features_KMA[0], -1, (int)Cipher::_featureBits)) {\n+        tty->print_cr(\"    available Crypto Features of KMA (Cipher Message with Authentication):\");\n+        for (unsigned int i = 0; i < Cipher::_featureBits; i++) {\n+          if (test_feature_bit(&_cipher_features_KMA[0], i, (int)Cipher::_featureBits)) {\n+            switch (i) {\n+              case Cipher::_Query:              tty->print_cr(\"      available: KMA      Query\");              break;\n+              case Cipher::_AES128:             tty->print_cr(\"      available: KMA-GCM  AES-128\");            break;\n+              case Cipher::_AES192:             tty->print_cr(\"      available: KMA-GCM  AES-192\");            break;\n+              case Cipher::_AES256:             tty->print_cr(\"      available: KMA-GCM  AES-256\");            break;\n+              case Cipher::_EnccryptedAES128:   tty->print_cr(\"      available: KMA-GCM  Encrypted-AES-128\");  break;\n+              case Cipher::_EnccryptedAES192:   tty->print_cr(\"      available: KMA-GCM  Encrypted-AES-192\");  break;\n+              case Cipher::_EnccryptedAES256:   tty->print_cr(\"      available: KMA-GCM  Encrypted-AES-256\");  break;\n+              default: tty->print_cr(\"      available: unknown KMA code %d\", i);      break;\n+            }\n+          }\n+        }\n+      }\n+    }\n+\n+    if (has_Crypto()) {\n@@ -535,0 +656,1 @@\n+\n@@ -538,1 +660,1 @@\n-            if (test_feature_bit(&_msgdigest_features[0], i, (int)MsgDigest::_featureBits)) {\n+          if (test_feature_bit(&_msgdigest_features[0], i, (int)MsgDigest::_featureBits)) {\n@@ -540,5 +662,11 @@\n-              case MsgDigest::_Query:  tty->print_cr(\"      available: KIMD Query\");   break;\n-              case MsgDigest::_SHA1:   tty->print_cr(\"      available: KIMD SHA-1\");   break;\n-              case MsgDigest::_SHA256: tty->print_cr(\"      available: KIMD SHA-256\"); break;\n-              case MsgDigest::_SHA512: tty->print_cr(\"      available: KIMD SHA-512\"); break;\n-              case MsgDigest::_GHASH:  tty->print_cr(\"      available: KIMD GHASH\");   break;\n+              case MsgDigest::_Query:     tty->print_cr(\"      available: KIMD Query\");   break;\n+              case MsgDigest::_SHA1:      tty->print_cr(\"      available: KIMD SHA-1\");   break;\n+              case MsgDigest::_SHA256:    tty->print_cr(\"      available: KIMD SHA-256\"); break;\n+              case MsgDigest::_SHA512:    tty->print_cr(\"      available: KIMD SHA-512\"); break;\n+              case MsgDigest::_SHA3_224:  tty->print_cr(\"      available: KIMD SHA3-224\");  break;\n+              case MsgDigest::_SHA3_256:  tty->print_cr(\"      available: KIMD SHA3-256\");  break;\n+              case MsgDigest::_SHA3_384:  tty->print_cr(\"      available: KIMD SHA3-384\");  break;\n+              case MsgDigest::_SHA3_512:  tty->print_cr(\"      available: KIMD SHA3-512\");  break;\n+              case MsgDigest::_SHAKE_128: tty->print_cr(\"      available: KIMD SHAKE-128\"); break;\n+              case MsgDigest::_SHAKE_256: tty->print_cr(\"      available: KIMD SHAKE-256\"); break;\n+              case MsgDigest::_GHASH:     tty->print_cr(\"      available: KIMD GHASH\");   break;\n@@ -550,0 +678,1 @@\n+\n@@ -555,4 +684,10 @@\n-              case MsgDigest::_Query:  tty->print_cr(\"      available: KLMD Query\");   break;\n-              case MsgDigest::_SHA1:   tty->print_cr(\"      available: KLMD SHA-1\");   break;\n-              case MsgDigest::_SHA256: tty->print_cr(\"      available: KLMD SHA-256\"); break;\n-              case MsgDigest::_SHA512: tty->print_cr(\"      available: KLMD SHA-512\"); break;\n+              case MsgDigest::_Query:     tty->print_cr(\"      available: KLMD Query\");   break;\n+              case MsgDigest::_SHA1:      tty->print_cr(\"      available: KLMD SHA-1\");   break;\n+              case MsgDigest::_SHA256:    tty->print_cr(\"      available: KLMD SHA-256\"); break;\n+              case MsgDigest::_SHA512:    tty->print_cr(\"      available: KLMD SHA-512\"); break;\n+              case MsgDigest::_SHA3_224:  tty->print_cr(\"      available: KLMD SHA3-224\");  break;\n+              case MsgDigest::_SHA3_256:  tty->print_cr(\"      available: KLMD SHA3-256\");  break;\n+              case MsgDigest::_SHA3_384:  tty->print_cr(\"      available: KLMD SHA3-384\");  break;\n+              case MsgDigest::_SHA3_512:  tty->print_cr(\"      available: KLMD SHA3-512\");  break;\n+              case MsgDigest::_SHAKE_128: tty->print_cr(\"      available: KLMD SHAKE-128\"); break;\n+              case MsgDigest::_SHAKE_256: tty->print_cr(\"      available: KLMD SHAKE-256\"); break;\n@@ -746,0 +881,23 @@\n+\/\/ getFeatures call interface\n+\/\/ Z_ARG1 (R2) - feature bit buffer address.\n+\/\/               Must be DW aligned.\n+\/\/ Z_ARG2 (R3) -  > 0 feature bit buffer length (#DWs).\n+\/\/                    Implies request to store cpu feature list via STFLE.\n+\/\/                = 0 invalid\n+\/\/                < 0 function code (which feature information to retrieve)\n+\/\/                    Implies that a buffer of at least two DWs is passed in.\n+\/\/                =-1 - retrieve cache topology\n+\/\/                =-2 - basic cipher instruction capabilities\n+\/\/                =-3 - msg digest (secure hash) instruction capabilities\n+\/\/                =-4 - vector instruction OS support availability\n+\/\/               =-17 - cipher (KMF) support\n+\/\/               =-18 - cipher (KMCTR) support\n+\/\/               =-19 - cipher (KMO) support\n+\/\/               =-20 - cipher (KMA) support\n+\/\/ Z_ARG3 (R4) - feature code for ECAG instruction\n+\/\/\n+\/\/ Z_RET (R2)  - return value\n+\/\/                >  0: success: number of retrieved feature bit string words.\n+\/\/                <  0: failure: required number of feature bit string words (buffer too small).\n+\/\/                == 0: failure: operation aborted.\n+\/\/\n@@ -768,0 +926,8 @@\n+void VM_Version::clear_buffer(unsigned long* buffer, unsigned int len) {\n+  memset(buffer, 0, sizeof(buffer[0])*len);\n+}\n+\n+void VM_Version::copy_buffer(unsigned long* to, unsigned long* from, unsigned int len) {\n+  memcpy(to, from, sizeof(to[0])*len);\n+}\n+\n@@ -785,1 +951,5 @@\n-  Label    getCIPHERFEATURES;                \/\/ fcode = -2 (cipher)\n+  Label    getCIPHERFEATURES_KM;             \/\/ fcode = -2 (cipher)\n+  Label    getCIPHERFEATURES_KMA;            \/\/ fcode = -20 (cipher)\n+  Label    getCIPHERFEATURES_KMF;            \/\/ fcode = -17 (cipher)\n+  Label    getCIPHERFEATURES_KMCTR;          \/\/ fcode = -18 (cipher)\n+  Label    getCIPHERFEATURES_KMO;            \/\/ fcode = -19 (cipher)\n@@ -789,2 +959,2 @@\n-  a->z_ltgfr(Z_R0, Z_ARG2);                  \/\/ Buf len to r0 and test.\n-  a->z_brl(getFEATURES);                     \/\/ negative -> Get machine features not covered by facility list.\n+  a->z_ltgfr(Z_R0, Z_ARG2);                  \/\/ buf_len\/fcode to r0 and test.\n+  a->z_brl(getFEATURES);                     \/\/ negative -> Get machine features or instruction-specific features\n@@ -794,1 +964,7 @@\n-  a->z_aghi(Z_R0, -1);\n+  \/\/---<  store feature list  >---\n+  \/\/ We have three possible outcomes here:\n+  \/\/ success:    cc = 0 and first DW of feature bit array != 0\n+  \/\/             Z_R0 contains index of last stored DW (used_len - 1)\n+  \/\/ incomplete: cc = 3 and first DW of feature bit array != 0\n+  \/\/             Z_R0 contains index of last DW that would have been stored (required_len - 1)\n+  a->z_aghi(Z_R0, -1);                       \/\/ STFLE needs last index, not length, of feature bit array.\n@@ -796,3 +972,3 @@\n-  a->z_lg(Z_R1, 0, Z_ARG1);                  \/\/ Get first DW of facility list.\n-  a->z_lgr(Z_RET, Z_R0);                     \/\/ Calculate rtn value for success.\n-  a->z_la(Z_RET, 1, Z_RET);\n+  a->z_lg(Z_R1, Address(Z_ARG1, (intptr_t)0)); \/\/ Get first DW of facility list.\n+  a->z_lgr(Z_RET, Z_R0);                     \/\/ Calculate used\/required len\n+  a->z_la(Z_RET, 1, Z_RET);                  \/\/ don't destroy cc from stfle!\n@@ -800,1 +976,1 @@\n-  a->z_ltgr(Z_R1, Z_R1);                     \/\/ Instr failed if first DW == 0.\n+  a->z_ltgr(Z_R1, Z_R1);                     \/\/ Check if first DW of facility list was filled.\n@@ -803,0 +979,1 @@\n+  \/\/---<  error exit  >---\n@@ -804,2 +981,2 @@\n-  a->z_lngr(Z_RET, Z_RET);\n-  a->z_ltgr(Z_R1, Z_R1);\n+  a->z_lngr(Z_RET, Z_RET);                   \/\/ negative return value to indicate \"buffer too small\"\n+  a->z_ltgr(Z_R1, Z_R1);                     \/\/ Check if first DW of facility list was filled.\n@@ -814,1 +991,1 @@\n-  a->z_bre(getCIPHERFEATURES);\n+  a->z_bre(getCIPHERFEATURES_KM);\n@@ -820,0 +997,9 @@\n+  a->z_cghi(Z_R0, -17);                      \/\/ -17: Extract detailed crypto capabilities (cipher instructions).\n+  a->z_bre(getCIPHERFEATURES_KMF);\n+  a->z_cghi(Z_R0, -18);                      \/\/ -18: Extract detailed crypto capabilities (cipher instructions).\n+  a->z_bre(getCIPHERFEATURES_KMCTR);\n+  a->z_cghi(Z_R0, -19);                      \/\/ -19: Extract detailed crypto capabilities (cipher instructions).\n+  a->z_bre(getCIPHERFEATURES_KMO);\n+  a->z_cghi(Z_R0, -20);                      \/\/ -20: Extract detailed crypto capabilities (cipher instructions).\n+  a->z_bre(getCIPHERFEATURES_KMA);\n+\n@@ -827,1 +1013,1 @@\n-  a->z_kimd(Z_R2,Z_R2);                      \/\/ Get available KIMD functions (bit pattern in param blk).\n+  a->z_kimd(Z_R2,Z_R2);                      \/\/ Get available KIMD functions (bit pattern in param blk). Must use even regs.\n@@ -829,2 +1015,2 @@\n-  a->z_klmd(Z_R2,Z_R2);                      \/\/ Get available KLMD functions (bit pattern in param blk).\n-  a->z_lghi(Z_RET,4);\n+  a->z_klmd(Z_R2,Z_R4);                      \/\/ Get available KLMD functions (bit pattern in param blk). Must use distinct even regs.\n+  a->z_lghi(Z_RET,4);                        \/\/ #used words in output buffer\n@@ -834,1 +1020,1 @@\n-  a->bind(getCIPHERFEATURES);\n+  a->bind(getCIPHERFEATURES_KM);\n@@ -837,1 +1023,1 @@\n-  a->z_km(Z_R2,Z_R2);                        \/\/ get available KM functions\n+  a->z_km(Z_R2,Z_R2);                        \/\/ get available KM functions. Must use even regs.\n@@ -840,1 +1026,33 @@\n-  a->z_lghi(Z_RET,4);\n+  a->z_lghi(Z_RET,4);                        \/\/ #used words in output buffer\n+  a->z_br(Z_R14);\n+\n+  \/\/ Try KMA query function to get details about crypto instructions.\n+  a->bind(getCIPHERFEATURES_KMA);\n+  a->z_lghi(Z_R0,(int)Cipher::_Query);       \/\/ query function code\n+  a->z_lgr(Z_R1,Z_R2);                       \/\/ param block addr, 2*16 bytes min size (KIMD\/KLMD output)\n+  a->z_kma(Z_R2,Z_R4,Z_R6);                  \/\/ get available KMA functions. Must use distinct even regs.\n+  a->z_lghi(Z_RET,2);                        \/\/ #used words in output buffer\n+  a->z_br(Z_R14);\n+\n+  \/\/ Try KMF query function to get details about crypto instructions.\n+  a->bind(getCIPHERFEATURES_KMF);\n+  a->z_lghi(Z_R0,(int)Cipher::_Query);       \/\/ query function code\n+  a->z_lgr(Z_R1,Z_R2);                       \/\/ param block addr, 2*16 bytes min size (KIMD\/KLMD output)\n+  a->z_kmf(Z_R2,Z_R2);                       \/\/ get available KMA functions. Must use even regs.\n+  a->z_lghi(Z_RET,2);                        \/\/ #used words in output buffer\n+  a->z_br(Z_R14);\n+\n+  \/\/ Try KMCTR query function to get details about crypto instructions.\n+  a->bind(getCIPHERFEATURES_KMCTR);\n+  a->z_lghi(Z_R0,(int)Cipher::_Query);       \/\/ query function code\n+  a->z_lgr(Z_R1,Z_R2);                       \/\/ param block addr, 2*16 bytes min size (KIMD\/KLMD output)\n+  a->z_kmctr(Z_R2,Z_R2,Z_R2);                     \/\/ get available KMCTR functions. Must use even regs.\n+  a->z_lghi(Z_RET,2);                        \/\/ #used words in output buffer\n+  a->z_br(Z_R14);\n+\n+  \/\/ Try KMO query function to get details about crypto instructions.\n+  a->bind(getCIPHERFEATURES_KMO);\n+  a->z_lghi(Z_R0,(int)Cipher::_Query);       \/\/ query function code\n+  a->z_lgr(Z_R1,Z_R2);                       \/\/ param block addr, 2*16 bytes min size (KIMD\/KLMD output)\n+  a->z_kmo(Z_R2,Z_R2);                       \/\/ get available KMO functions. Must use even regs.\n+  a->z_lghi(Z_RET,2);                        \/\/ #used words in output buffer\n@@ -871,3 +1089,1 @@\n-  \/\/ Prepare for detection code execution and clear work buffer.\n-  _nfeatures        = 0;\n-  _ncipher_features = 0;\n+  \/\/ prepare work buffer\n@@ -875,4 +1091,1 @@\n-\n-  for (int i = 0; i < buf_len; i++) {\n-    buffer[i] = 0L;\n-  }\n+  clear_buffer(buffer, buf_len);\n@@ -886,1 +1099,1 @@\n-  if (used_len == 1) {\n+  if ((used_len > 0) && (used_len <= buf_len)) {\n@@ -888,9 +1101,3 @@\n-  } else if (used_len > 1) {\n-    unsigned int used_lenU = (unsigned int)used_len;\n-    ok = true;\n-    for (unsigned int i = 1; i < used_lenU; i++) {\n-      ok = ok && (buffer[i] == 0L);\n-    }\n-    if (printVerbose && !ok) {\n-      bool compact = false;\n-      tty->print_cr(\"Note: feature list has %d (i.e. more than one) array elements.\", used_lenU);\n+    if (printVerbose) {\n+      bool compact = Verbose;\n+      tty->print_cr(\"Note: feature list uses %ld array elements.\", used_len);\n@@ -899,2 +1106,4 @@\n-        for (unsigned int i = 0; i < used_lenU; i++) {\n-          tty->print(\"  [%d]: 0x%16.16lx\", i, buffer[i]);\n+        for (unsigned int k = 0; k < used_len; k++) {\n+          if (buffer[k] != 0) {\n+            tty->print(\"  [%d]: 0x%16.16lx\", k, buffer[k]);\n+          }\n@@ -904,2 +1113,2 @@\n-        for (unsigned int i = 0; i < used_lenU; i++) {\n-          tty->print_cr(\"non-zero feature list[%d]: 0x%16.16lx\", i, buffer[i]);\n+        for (unsigned int k = 0; k < used_len; k++) {\n+          tty->print_cr(\"non-zero feature list[%d]: 0x%16.16lx\", k, buffer[k]);\n@@ -911,1 +1120,1 @@\n-        for (unsigned int k = 0; k < used_lenU; k++) {\n+        for (unsigned int k = 0; k < used_len; k++) {\n@@ -916,1 +1125,1 @@\n-              bool bit  = test_feature_bit(buffer, i, used_lenU*sizeof(long)*8);\n+              bool bit  = test_feature_bit(buffer, i, used_len*sizeof(long)*8);\n@@ -920,0 +1129,1 @@\n+                  tty->fill_to(13);\n@@ -932,1 +1142,1 @@\n-        for (unsigned int k = 0; k < used_lenU; k++) {\n+        for (unsigned int k = 0; k < used_len; k++) {\n@@ -936,0 +1146,1 @@\n+            tty->fill_to(13);\n@@ -937,1 +1148,1 @@\n-              bool bit  = test_feature_bit(buffer, i, used_lenU*sizeof(long)*8);\n+              bool bit  = test_feature_bit(buffer, i, used_len*sizeof(long)*8);\n@@ -949,1 +1160,0 @@\n-    ok = true;\n@@ -951,0 +1161,1 @@\n+    ok = false;\n@@ -952,1 +1163,0 @@\n-      ok = false;\n@@ -958,27 +1168,1 @@\n-        tty->print_cr(\"feature list could not be retrieved. Running on z900 or z990? Trying to find out...\");\n-      }\n-      used_len = call_getFeatures(buffer, 0, 0);       \/\/ Must provide at least two DW buffer elements!!!!\n-\n-      ok = used_len > 0;\n-      if (ok) {\n-        if (buffer[1]*10 < buffer[0]) {\n-          set_features_z900();\n-        } else {\n-          set_features_z990();\n-        }\n-\n-        if (printVerbose) {\n-          tty->print_cr(\"Note: high-speed long displacement test used %ld iterations.\", used_len);\n-          tty->print_cr(\"      Positive displacement loads took %8.8lu microseconds.\", buffer[1]);\n-          tty->print_cr(\"      Negative displacement loads took %8.8lu microseconds.\", buffer[0]);\n-          if (has_long_displacement_fast()) {\n-            tty->print_cr(\"      assuming high-speed long displacement IS     available.\");\n-          } else {\n-            tty->print_cr(\"      assuming high-speed long displacement is NOT available.\");\n-          }\n-        }\n-      } else {\n-        if (printVerbose) {\n-          tty->print_cr(\"Note: high-speed long displacement test was not successful.\");\n-          tty->print_cr(\"      assuming long displacement is NOT available.\");\n-        }\n+        tty->print_cr(\"feature list could not be retrieved. Bad function code? Running on z900 or z990?\");\n@@ -986,1 +1170,0 @@\n-      return; \/\/ Do not copy buffer to _features, no test for cipher features.\n@@ -991,8 +1174,2 @@\n-    \/\/ Fill features buffer.\n-    \/\/ Clear work buffer.\n-    for (int i = 0; i < buf_len; i++) {\n-      _features[i]           = buffer[i];\n-      _cipher_features[i]    = 0;\n-      _msgdigest_features[i] = 0;\n-      buffer[i]              = 0L;\n-    }\n+    \/\/ Copy detected features to features buffer.\n+    copy_buffer(_features, buffer, buf_len);\n@@ -1001,6 +1178,2 @@\n-    for (int i = 0; i < buf_len; i++) {\n-      _features[i]           = 0;\n-      _cipher_features[i]    = 0;\n-      _msgdigest_features[i] = 0;\n-      buffer[i]              = 0L;\n-    }\n+    \/\/ Something went wrong with feature detection. Disable everything.\n+    clear_buffer(_features, buf_len);\n@@ -1012,0 +1185,1 @@\n+    \/\/ We will get a signal if not. Signal handler will disable vector facility\n@@ -1023,1 +1197,18 @@\n-  \/\/ Extract Crypto Facility details.\n+  \/\/ Clear all Cipher feature buffers and the work buffer.\n+  clear_buffer(_cipher_features_KM, buf_len);\n+  clear_buffer(_cipher_features_KMA, buf_len);\n+  clear_buffer(_cipher_features_KMF, buf_len);\n+  clear_buffer(_cipher_features_KMCTR, buf_len);\n+  clear_buffer(_cipher_features_KMO, buf_len);\n+  clear_buffer(_msgdigest_features, buf_len);\n+  _ncipher_features_KM    = 0;\n+  _ncipher_features_KMA   = 0;\n+  _ncipher_features_KMF   = 0;\n+  _ncipher_features_KMCTR = 0;\n+  _ncipher_features_KMO   = 0;\n+  _nmsgdigest_features    = 0;\n+\n+  \/\/---------------------------------------\n+  \/\/--  Extract Crypto Facility details  --\n+  \/\/---------------------------------------\n+\n@@ -1025,1 +1216,2 @@\n-    \/\/ Get cipher features.\n+    \/\/ Get features of KM\/KMC cipher instructions\n+    clear_buffer(buffer, buf_len);\n@@ -1027,4 +1219,2 @@\n-    for (int i = 0; i < buf_len; i++) {\n-      _cipher_features[i] = buffer[i];\n-    }\n-    _ncipher_features = used_len;\n+    copy_buffer(_cipher_features_KM, buffer, buf_len);\n+    _ncipher_features_KM = used_len;\n@@ -1033,0 +1223,1 @@\n+    clear_buffer(buffer, buf_len);\n@@ -1034,3 +1225,1 @@\n-    for (int i = 0; i < buf_len; i++) {\n-      _msgdigest_features[i] = buffer[i];\n-    }\n+    copy_buffer(_msgdigest_features, buffer, buf_len);\n@@ -1040,0 +1229,31 @@\n+  if (has_CryptoExt4()) {\n+    \/\/ Get features of KMF cipher instruction\n+    clear_buffer(buffer, buf_len);\n+    used_len = call_getFeatures(buffer, -17, 0);\n+    copy_buffer(_cipher_features_KMF, buffer, buf_len);\n+    _ncipher_features_KMF = used_len;\n+\n+    \/\/ Get features of KMCTR cipher instruction\n+    clear_buffer(buffer, buf_len);\n+    used_len = call_getFeatures(buffer, -18, 0);\n+    copy_buffer(_cipher_features_KMCTR, buffer, buf_len);\n+    _ncipher_features_KMCTR = used_len;\n+\n+    \/\/ Get features of KMO cipher instruction\n+    clear_buffer(buffer, buf_len);\n+    used_len = call_getFeatures(buffer, -19, 0);\n+    copy_buffer(_cipher_features_KMO, buffer, buf_len);\n+    _ncipher_features_KMO = used_len;\n+  }\n+\n+  if (has_CryptoExt8()) {\n+    \/\/ Get features of KMA cipher instruction\n+    clear_buffer(buffer, buf_len);\n+    used_len = call_getFeatures(buffer, -20, 0);\n+    copy_buffer(_cipher_features_KMA, buffer, buf_len);\n+    _ncipher_features_KMA = used_len;\n+  }\n+  if (printVerbose) {\n+    tty->print_cr(\"  Crypto capabilities retrieved.\");\n+  }\n+\n@@ -1273,1 +1493,0 @@\n-\n","filename":"src\/hotspot\/cpu\/s390\/vm_version_s390.cpp","additions":382,"deletions":163,"binary":false,"changes":545,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2016, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2016, 2019 SAP SE. All rights reserved.\n+ * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2021 SAP SE. All rights reserved.\n@@ -50,1 +50,1 @@\n-#define  CryptoFacilityMask             0x0000400000000000UL  \/\/ z990\n+#define  CryptoFacilityMask             0x0000400000000000UL  \/\/ z990 (aka message-security assist)\n@@ -99,1 +99,1 @@\n-#define  CryptoExtension4Mask           0x0004000000000000UL  \/\/ z196\n+#define  CryptoExtension4Mask           0x0004000000000000UL  \/\/ z196 (aka message-security assist extension 4, for KMF, KMCTR, KMO)\n@@ -112,1 +112,1 @@\n-#define  CryptoExtension8Mask           0x0000200000000040UL  \/\/ z14\n+#define  CryptoExtension8Mask           0x0000200000000000UL  \/\/ z14 (aka message-security assist extension 8, for KMA)\n@@ -115,2 +115,2 @@\n-#define  CryptoExtension9Mask           0x0000001000000040UL  \/\/ z15\n-#define  DeflateMask                    0x0000010000000040UL  \/\/ z15\n+#define  CryptoExtension9Mask           0x0000001000000000UL  \/\/ z15 (aka message-security assist extension 9)\n+#define  DeflateMask                    0x0000010000000000UL  \/\/ z15\n@@ -124,1 +124,5 @@\n-  static unsigned long _cipher_features[_features_buffer_len];\n+  static unsigned long _cipher_features_KM[_features_buffer_len];\n+  static unsigned long _cipher_features_KMA[_features_buffer_len];\n+  static unsigned long _cipher_features_KMF[_features_buffer_len];\n+  static unsigned long _cipher_features_KMCTR[_features_buffer_len];\n+  static unsigned long _cipher_features_KMO[_features_buffer_len];\n@@ -127,1 +131,5 @@\n-  static unsigned int  _ncipher_features;\n+  static unsigned int  _ncipher_features_KM;\n+  static unsigned int  _ncipher_features_KMA;\n+  static unsigned int  _ncipher_features_KMF;\n+  static unsigned int  _ncipher_features_KMCTR;\n+  static unsigned int  _ncipher_features_KMO;\n@@ -135,0 +143,1 @@\n+  static int  get_model_index();\n@@ -140,0 +149,2 @@\n+  static void clear_buffer(unsigned long* buffer, unsigned int len);\n+  static void copy_buffer(unsigned long* to, unsigned long* from, unsigned int len);\n@@ -270,6 +281,12 @@\n-        _Query            =   0,\n-        _SHA1             =   1,\n-        _SHA256           =   2,\n-        _SHA512           =   3,\n-        _GHASH            =  65,\n-        _featureBits      = 128,\n+        _Query                =   0,\n+        _SHA1                 =   1,\n+        _SHA256               =   2,\n+        _SHA512               =   3,\n+        _SHA3_224             =  32,\n+        _SHA3_256             =  33,\n+        _SHA3_384             =  34,\n+        _SHA3_512             =  35,\n+        _SHAKE_128            =  36,\n+        _SHAKE_256            =  37,\n+        _GHASH                =  65,\n+        _featureBits          = 128,\n@@ -278,5 +295,11 @@\n-        _Query_parmBlk_I  =  16,\n-        _SHA1_parmBlk_I   =  20,\n-        _SHA256_parmBlk_I =  32,\n-        _SHA512_parmBlk_I =  64,\n-        _GHASH_parmBlk_I  =  32,\n+        _Query_parmBlk_I      =  16,\n+        _SHA1_parmBlk_I       =  20,\n+        _SHA256_parmBlk_I     =  32,\n+        _SHA512_parmBlk_I     =  64,\n+        _SHA3_224_parmBlk_I   = 200,\n+        _SHA3_256_parmBlk_I   = 200,\n+        _SHA3_384_parmBlk_I   = 200,\n+        _SHA3_512_parmBlk_I   = 200,\n+        _SHAKE_128_parmBlk_I  = 200,\n+        _SHAKE_256_parmBlk_I  = 200,\n+        _GHASH_parmBlk_I      =  32,\n@@ -285,4 +308,10 @@\n-        _Query_parmBlk_L  =  16,\n-        _SHA1_parmBlk_L   =  28,\n-        _SHA256_parmBlk_L =  40,\n-        _SHA512_parmBlk_L =  80,\n+        _Query_parmBlk_L      =  16,\n+        _SHA1_parmBlk_L       =  28,\n+        _SHA256_parmBlk_L     =  40,\n+        _SHA512_parmBlk_L     =  80,\n+        _SHA3_224_parmBlk_L   = 200,\n+        _SHA3_256_parmBlk_L   = 200,\n+        _SHA3_384_parmBlk_L   = 200,\n+        _SHA3_512_parmBlk_L   = 200,\n+        _SHAKE_128_parmBlk_L  = 200,\n+        _SHAKE_256_parmBlk_L  = 200,\n@@ -291,5 +320,11 @@\n-        _Query_dataBlk    =   0,\n-        _SHA1_dataBlk     =  64,\n-        _SHA256_dataBlk   =  64,\n-        _SHA512_dataBlk   = 128,\n-        _GHASH_dataBlk    =  16\n+        _Query_dataBlk        =   0,\n+        _SHA1_dataBlk         =  64,\n+        _SHA256_dataBlk       =  64,\n+        _SHA512_dataBlk       = 128,\n+        _SHA3_224_dataBlk     = 144,\n+        _SHA3_256_dataBlk     = 136,\n+        _SHA3_384_dataBlk     = 104,\n+        _SHA3_512_dataBlk     =  72,\n+        _SHAKE_128_dataBlk    = 168,\n+        _SHAKE_256_dataBlk    = 136,\n+        _GHASH_dataBlk        =  16\n@@ -402,2 +437,0 @@\n-  static bool has_CryptoExt3()                { return  (_features[1] & CryptoExtension3Mask)          == CryptoExtension3Mask; }\n-  static bool has_CryptoExt4()                { return  (_features[1] & CryptoExtension4Mask)          == CryptoExtension4Mask; }\n@@ -416,0 +449,2 @@\n+  static bool has_CryptoExt3()                { return  (_features[1] & CryptoExtension3Mask)          == CryptoExtension3Mask; }\n+  static bool has_CryptoExt4()                { return  (_features[1] & CryptoExtension4Mask)          == CryptoExtension4Mask; }\n@@ -427,3 +462,3 @@\n-  static bool has_Crypto_AES128()             { return has_Crypto() && test_feature_bit(&_cipher_features[0], Cipher::_AES128, Cipher::_featureBits); }\n-  static bool has_Crypto_AES192()             { return has_Crypto() && test_feature_bit(&_cipher_features[0], Cipher::_AES192, Cipher::_featureBits); }\n-  static bool has_Crypto_AES256()             { return has_Crypto() && test_feature_bit(&_cipher_features[0], Cipher::_AES256, Cipher::_featureBits); }\n+  static bool has_Crypto_AES128()             { return has_Crypto() && test_feature_bit(&_cipher_features_KM[0], Cipher::_AES128, Cipher::_featureBits); }\n+  static bool has_Crypto_AES192()             { return has_Crypto() && test_feature_bit(&_cipher_features_KM[0], Cipher::_AES192, Cipher::_featureBits); }\n+  static bool has_Crypto_AES256()             { return has_Crypto() && test_feature_bit(&_cipher_features_KM[0], Cipher::_AES256, Cipher::_featureBits); }\n@@ -479,0 +514,1 @@\n+  static void set_has_LoadStoreConditional2()     { _features[0] |= LoadStoreConditional2Mask; }\n@@ -481,1 +517,0 @@\n-  static void set_has_LoadStoreConditional2()     { _features[0] |= LoadStoreConditional2Mask; }\n","filename":"src\/hotspot\/cpu\/s390\/vm_version_s390.hpp","additions":70,"deletions":35,"binary":false,"changes":105,"status":"modified"}]}