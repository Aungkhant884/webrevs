{"files":[{"patch":"@@ -282,1 +282,1 @@\n-\n+ *\n@@ -295,0 +295,16 @@\n+ * <h2><a id=algorithmicComplexity>Algorithmic Complexity<\/a><\/h2>\n+ * Operations on {@code BigDecimal} values have a range of algorithmic\n+ * complexities; in general, those complexities are a function of both\n+ * the size of the unscaled value as well as the size of the\n+ * scale. For example, an {@linkplain BigDecimal#multiply(BigDecimal)\n+ * exact multiply} of two {@code BigDecimal} values is subject to the\n+ * same {@linkplain BigInteger##algorithmicComplexity complexity\n+ * constraints} as {@code BigInteger} multiply of the unscaled\n+ * values. In contrast, a {@code BigDecimal} value with a compact\n+ * representation like {@code new BigDecimal(1E-1000000000)} has a\n+ * {@link toPlainString} result with over one billion characters.\n+ *\n+ * <p>Users of {@code BigDecimal} concerned with bounding the running\n+ * time of operations can screen out {@code BigDecimal} values with\n+ * unscaled values or scales above a chosen magnitude.\n+ *\n","filename":"src\/java.base\/share\/classes\/java\/math\/BigDecimal.java","additions":17,"deletions":1,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -121,0 +121,32 @@\n+ * @apiNote\n+ * <a id=algorithmicComplexity>As {@code BigInteger} values are\n+ * arbitrary precision integers, the algorithmic complexity of the\n+ * methods of this class varies and may be superlinear in the size of\n+ * the input. For example, a method like {@link intValue()} would be\n+ * expected to run in <i>O<\/i>(1), that is constant time, since with\n+ * the current internal presentation only a fixed-size component of\n+ * the {@code BigInteger} needs to be accessed to perform the\n+ * conversion to {@code int}. In contrast, a method like {@link not()}\n+ * would be expected to run in <i>O<\/i>(<i>n<\/i>) time where <i>n<\/i>\n+ * is size of the {@code BigInteger} in bits, that is, to run in time\n+ * proportional to the size of the input. For multiplying two {@code\n+ * BigInteger} values of size <i>n<\/i>, a naive multiply algorithm\n+ * would run in time <i>O<\/i>(<i>n<sup>2<\/sup><\/i>) and theoretical\n+ * results indicate a multiply algorithm for numbers using this\n+ * category of representation must run in <em>at least<\/em>\n+ * <i>O<\/i>(<i>n<\/i>&nbsp;log&nbsp;<i>n<\/i>). Common multiply\n+ * algorithms between the bounds of the naive and theoretical cases\n+ * include the Karatsuba multiplication\n+ * (<i>O<\/i>(<i>n<sup>1.585<\/sup><\/i>)) and 3-way Toom-Cook\n+ * multiplication (<i>O<\/i>(<i>n<sup>1.465<\/sup><\/i>)).<\/a>\n+ *\n+ * <p>A particular implementation of {@link multiply(BigInteger)\n+ * multiply} is free to switch between different algorithms for\n+ * different inputs, such as to improve actual running time to produce\n+ * the product by using simpler algorithms for smaller inputs even if\n+ * the simpler algorithm has a larger asymptotic complexity.\n+ *\n+ * <p>Users of {@code BigInteger} concerned with bounding the running\n+ * time of operations can screen out {@code BigInteger} values above a\n+ * chosen magnitude.\n+ *\n","filename":"src\/java.base\/share\/classes\/java\/math\/BigInteger.java","additions":33,"deletions":1,"binary":false,"changes":34,"status":"modified"}]}