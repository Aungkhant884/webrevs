{"files":[{"patch":"@@ -1864,3 +1864,2 @@\n-  if (OptimizeUnstableIf) {\n-    _unstable_if_traps.append(trap);\n-  }\n+  assert(OptimizeUnstableIf, \"only valid OptimizeUnstableIf is on.\");\n+  _unstable_if_traps.append(trap);\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -152,0 +152,2 @@\n+ friend class UnstableIfTrap;\n+\n@@ -170,0 +172,1 @@\n+    GrowableArray<UnstableIfTrap* > _unstable_if_traps;\n@@ -190,0 +193,3 @@\n+    void add_unstable_if_trap(UnstableIfTrap* trap) { _unstable_if_traps.append(trap); }\n+    GrowableArray<UnstableIfTrap* >& unstable_if_traps() { return _unstable_if_traps; }\n+\n@@ -458,0 +464,1 @@\n+  bool unstable_if_merge(Block* target, SafePointNode* newin);\n@@ -546,2 +553,1 @@\n-  void    adjust_map_after_if(BoolTest::mask btest, Node* c, float prob,\n-                              Block* path, Block* other_path);\n+  void    adjust_map_after_if(BoolTest::mask btest, Node* c, float prob, Block* path);\n@@ -609,0 +615,4 @@\n+  Parse::Block*  const _block;\n+  SafePointNode* const _sfpt;\n+  BoolTest::mask _btest;\n+  Node* const _cmp;\n@@ -613,1 +623,3 @@\n-  UnstableIfTrap(CallStaticJavaNode* call, Parse::Block* path): _unc(call), _modified(false) {\n+  UnstableIfTrap(CallStaticJavaNode* call, Parse::Block* target, Parse::Block* block, SafePointNode* sfpt,\n+                 BoolTest::mask btest, Node* cmp): _unc(call), _block(block), _sfpt(sfpt),\n+                                                   _btest(btest), _cmp(cmp), _modified(false), _next_bci(-1) {\n@@ -616,1 +628,4 @@\n-    _next_bci = path != nullptr ? path->start() : -1;\n+    if (target != nullptr) {\n+      _next_bci = target->start();\n+      target->add_unstable_if_trap(this);\n+    }\n@@ -633,0 +648,2 @@\n+  void suppress(Parse* parser, Parse::Block* path);\n+\n","filename":"src\/hotspot\/share\/opto\/parse.hpp","additions":21,"deletions":4,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -653,0 +653,9 @@\n+      if (OptimizeUnstableIf) {\n+        \/\/ C2 is about to parse block, so the unstable_if traps associated with it\n+        \/\/ are 'superficial'. suppress them.\n+        auto unstable_if_traps = block->unstable_if_traps();\n+        while (unstable_if_traps.length() > 0) {\n+          UnstableIfTrap* trap = unstable_if_traps.pop();\n+          trap->suppress(this, block);\n+        }\n+      }\n@@ -1828,0 +1837,49 @@\n+\/\/ determine if parser should merge the block of newin, which is optional.\n+bool Parse::unstable_if_merge(Parse::Block* target, SafePointNode* newin) {\n+  if (TraceOptoParse) {\n+    tty->print(\"UnstableIf Merging state at block #%d bci:%d\", target->rpo(), target->start());\n+  }\n+\n+  assert(target->is_merged(), \"No prior mapping at this bci\");\n+  bool result = true;\n+  Block* save_block = block(); \/\/ Hang on to incoming block;\n+  load_state_from(target);    \/\/ Get prior mapping\n+\n+  assert(newin->jvms()->locoff() == jvms()->locoff(), \"JVMS layouts agree\");\n+  assert(newin->jvms()->stkoff() == jvms()->stkoff(), \"JVMS layouts agree\");\n+  assert(newin->jvms()->monoff() == jvms()->monoff(), \"JVMS layouts agree\");\n+  assert(newin->jvms()->endoff() == jvms()->endoff(), \"JVMS layouts agree\");\n+\n+  assert(control()->is_Region(), \"must be merging to a region\");\n+  RegionNode* r = control()->as_Region();\n+  assert(TypeFunc::Parms == newin->jvms()->locoff(), \"parser map should contain only youngest jvms\");\n+\n+  for (uint j = 1; result && j < map()->req(); j++) {\n+    Node* m = map()->in(j);   \/\/ Current state of target.\n+    Node* n = newin->in(j);   \/\/ Incoming change to target state.\n+    PhiNode* phi = nullptr;\n+\n+    if (m->is_Phi() && m->as_Phi()->region() == r)\n+      phi = m->as_Phi();\n+\n+    if (m != n) {             \/\/ Different; must merge\n+      switch (j) {\n+      \/\/ Frame pointer and Return Address never changes\n+      case TypeFunc::FramePtr:\/\/ Drop m, use the original value\n+      case TypeFunc::ReturnAdr:\n+      case TypeFunc::Memory:  \/\/ Merge inputs to the MergeMem node\n+        break;\n+      default:                \/\/ All normal stuff\n+        \/\/ Parser needs to create a phi node and merge a constant m with n.\n+        \/\/ This clobbers constant folding, so drop out!\n+        if (phi == nullptr && m->is_Con() && m != top()) {\n+          result = false;\n+        }\n+        break;\n+      }\n+    }\n+  } \/\/ End of for all values to be merged\n+\n+  set_block(save_block);\n+  return result;\n+}\n","filename":"src\/hotspot\/share\/opto\/parse1.cpp","additions":58,"deletions":0,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -1413,1 +1413,1 @@\n-      adjust_map_after_if(btest, c, prob, branch_block, next_block);\n+      adjust_map_after_if(btest, c, prob, branch_block);\n@@ -1431,2 +1431,1 @@\n-    adjust_map_after_if(BoolTest(btest).negate(), c, 1.0-prob,\n-                        next_block, branch_block);\n+    adjust_map_after_if(BoolTest(btest).negate(), c, 1.0-prob, next_block);\n@@ -1526,1 +1525,1 @@\n-      adjust_map_after_if(taken_btest, c, prob, branch_block, next_block);\n+      adjust_map_after_if(taken_btest, c, prob, branch_block);\n@@ -1543,2 +1542,1 @@\n-    adjust_map_after_if(untaken_btest, c, untaken_prob,\n-                        next_block, branch_block);\n+    adjust_map_after_if(untaken_btest, c, untaken_prob, next_block);\n@@ -1574,2 +1572,1 @@\n-void Parse::adjust_map_after_if(BoolTest::mask btest, Node* c, float prob,\n-                                Block* path, Block* other_path) {\n+void Parse::adjust_map_after_if(BoolTest::mask btest, Node* c, float prob, Block* path) {\n@@ -1587,1 +1584,9 @@\n-  if (path_is_suitable_for_uncommon_trap(prob)) {\n+  \/\/ Refrain from generating uncommon_trap if path has been merged. It is a live block.\n+  \/\/ We don't know if path is live or dead yet if is_merge() returns false. We still generate\n+  \/\/ an uncommon_trap but take a record. We postpone decision to the parse-time of path.\n+  \/\/ If path is dead, it proves that this uncommon_trap does prune code. C2 will skip parsing\n+  \/\/ path and leave the uncommon_trap.\n+  if (path_is_suitable_for_uncommon_trap(prob) && (!OptimizeUnstableIf || !path->is_merged())) {\n+    sync_jvms();\n+    SafePointNode* sfpt = clone_map();\n+\n@@ -1590,3 +1595,2 @@\n-                  Deoptimization::Action_reinterpret,\n-                  NULL,\n-                  (is_fallthrough ? \"taken always\" : \"taken never\"));\n+                               Deoptimization::Action_reinterpret,\n+                               NULL, (is_fallthrough ? \"taken always\" : \"taken never\"));\n@@ -1594,2 +1598,3 @@\n-    if (call != nullptr) {\n-      C->record_unstable_if_trap(new UnstableIfTrap(call->as_CallStaticJava(), path));\n+    if (call != nullptr && OptimizeUnstableIf) {\n+      UnstableIfTrap* trap = new UnstableIfTrap(call->as_CallStaticJava(), path, block(), sfpt, btest, c);\n+      C->record_unstable_if_trap(trap);\n@@ -2771,0 +2776,16 @@\n+\n+void UnstableIfTrap::suppress(Parse* parser, Parse::Block* path) {\n+  if (parser->unstable_if_merge(path, _sfpt)) {\n+    int pnum = path->next_path_num();\n+\n+    parser->set_block(_block);\n+    parser->set_map(_sfpt);\n+    parser->set_sp(_sfpt->jvms()->sp());\n+    parser->adjust_map_after_if(_btest, _cmp, PROB_MAX, path);\n+    parser->merge_common(path, pnum);\n+    _next_bci = -1;\n+\n+    _unc->set_req(0, parser->top());\n+    parser->record_for_igvn(_unc);\n+  }\n+}\n","filename":"src\/hotspot\/share\/opto\/parse2.cpp","additions":35,"deletions":14,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -57,0 +57,40 @@\n+    \/\/ a custom \"boxing\" class\n+    public static class Value {\n+        public int _value;\n+\n+        public Value(int value) {\n+          this._value = value;\n+        }\n+    }\n+\n+    @Test\n+    @Arguments({Argument.TRUE, Argument.DEFAULT, Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.UNSTABLE_IF_TRAP})\n+    public static int superficial_if(boolean cond, int i, int j, int k) {\n+        Value x = new Value(i);\n+        Value y = new Value(j);\n+        Value z = new Value(k);\n+\n+        if (cond) { \/\/ likely\n+            i++;\n+        } \/\/ else section is superficial\n+\n+        return x._value + y._value + z._value + i;\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.TRUE})\n+    @IR(failOn = {IRNode.MUL})\n+    @IR(counts = {IRNode.UNSTABLE_IF_TRAP, \"1\"})\n+    public static int superfical_if_constant(int x, boolean cond) {\n+        int i = x;\n+        if (cond) { \/\/ likely\n+            i = 0;\n+        }\n+        \/\/ really complex iterations I made up\n+        int y  = 42;\n+        y = (int)(Math.sqrt(y) + (x * 0.1191837));\n+        \/\/ if constant folding works, y will be dead and return 0;\n+        return  i * y;\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestOptimizeUnstableIf.java","additions":40,"deletions":0,"binary":false,"changes":40,"status":"modified"}]}