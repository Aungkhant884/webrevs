{"files":[{"patch":"@@ -1864,3 +1864,2 @@\n-  if (OptimizeUnstableIf) {\n-    _unstable_if_traps.append(trap);\n-  }\n+  assert(OptimizeUnstableIf, \"only valid OptimizeUnstableIf is on.\");\n+  _unstable_if_traps.append(trap);\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -152,0 +152,2 @@\n+ friend class UnstableIfTrap;\n+\n@@ -170,0 +172,1 @@\n+    GrowableArray<UnstableIfTrap* > _unstable_if_traps;\n@@ -190,0 +193,3 @@\n+    void add_unstable_if_trap(UnstableIfTrap* trap) { _unstable_if_traps.append(trap); }\n+    GrowableArray<UnstableIfTrap* >& unstable_if_traps() { return _unstable_if_traps; }\n+\n@@ -546,2 +552,1 @@\n-  void    adjust_map_after_if(BoolTest::mask btest, Node* c, float prob,\n-                              Block* path, Block* other_path);\n+  void    adjust_map_after_if(BoolTest::mask btest, Node* c, float prob, Block* path);\n@@ -609,0 +614,4 @@\n+  Parse::Block*  const _block;\n+  SafePointNode* const _sfpt;\n+  BoolTest::mask _btest;\n+  Node* const _cmp;\n@@ -613,1 +622,3 @@\n-  UnstableIfTrap(CallStaticJavaNode* call, Parse::Block* path): _unc(call), _modified(false) {\n+  UnstableIfTrap(CallStaticJavaNode* call, Parse::Block* target, Parse::Block* block, SafePointNode* sfpt,\n+                 BoolTest::mask btest, Node* cmp): _unc(call), _block(block), _sfpt(sfpt),\n+                                                   _btest(btest), _cmp(cmp), _modified(false), _next_bci(-1) {\n@@ -616,1 +627,4 @@\n-    _next_bci = path != nullptr ? path->start() : -1;\n+    if (target != nullptr) {\n+      _next_bci = target->start();\n+      target->add_unstable_if_trap(this);\n+    }\n@@ -633,0 +647,2 @@\n+  void suppress(Parse* parser, Parse::Block* path);\n+\n","filename":"src\/hotspot\/share\/opto\/parse.hpp","additions":20,"deletions":4,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -653,0 +653,15 @@\n+      if (OptimizeUnstableIf) {\n+        \/\/ C2 is about to parse block, so the unstable_if traps associated with it\n+        \/\/ are 'superficial'. suppress them.\n+        auto unstable_if_traps = block->unstable_if_traps();\n+        while (unstable_if_traps.length() > 0) {\n+          UnstableIfTrap* trap = unstable_if_traps.pop();\n+\n+          trap->suppress(this, block);\n+          CallStaticJavaNode* unc = trap->uncommon_trap();\n+          unc->set_req(0, top());\n+          record_for_igvn(unc);\n+          \/\/tty->print(\"mark dead: \");\n+          \/\/unc->dump();\n+        }\n+      }\n","filename":"src\/hotspot\/share\/opto\/parse1.cpp","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -1413,1 +1413,1 @@\n-      adjust_map_after_if(btest, c, prob, branch_block, next_block);\n+      adjust_map_after_if(btest, c, prob, branch_block);\n@@ -1431,2 +1431,1 @@\n-    adjust_map_after_if(BoolTest(btest).negate(), c, 1.0-prob,\n-                        next_block, branch_block);\n+    adjust_map_after_if(BoolTest(btest).negate(), c, 1.0-prob, next_block);\n@@ -1526,1 +1525,1 @@\n-      adjust_map_after_if(taken_btest, c, prob, branch_block, next_block);\n+      adjust_map_after_if(taken_btest, c, prob, branch_block);\n@@ -1543,2 +1542,1 @@\n-    adjust_map_after_if(untaken_btest, c, untaken_prob,\n-                        next_block, branch_block);\n+    adjust_map_after_if(untaken_btest, c, untaken_prob, next_block);\n@@ -1574,2 +1572,1 @@\n-void Parse::adjust_map_after_if(BoolTest::mask btest, Node* c, float prob,\n-                                Block* path, Block* other_path) {\n+void Parse::adjust_map_after_if(BoolTest::mask btest, Node* c, float prob, Block* path) {\n@@ -1587,1 +1584,4 @@\n-  if (path_is_suitable_for_uncommon_trap(prob)) {\n+  if (path_is_suitable_for_uncommon_trap(prob) && (!OptimizeUnstableIf || !path->is_merged())) {\n+    sync_jvms();\n+    SafePointNode* sfpt = clone_map();\n+\n@@ -1590,3 +1590,2 @@\n-                  Deoptimization::Action_reinterpret,\n-                  NULL,\n-                  (is_fallthrough ? \"taken always\" : \"taken never\"));\n+                               Deoptimization::Action_reinterpret,\n+                               NULL, (is_fallthrough ? \"taken always\" : \"taken never\"));\n@@ -1594,2 +1593,3 @@\n-    if (call != nullptr) {\n-      C->record_unstable_if_trap(new UnstableIfTrap(call->as_CallStaticJava(), path));\n+    if (call != nullptr && OptimizeUnstableIf) {\n+      UnstableIfTrap* trap = new UnstableIfTrap(call->as_CallStaticJava(), path, block(), sfpt, btest, c);\n+      C->record_unstable_if_trap(trap);\n@@ -2771,0 +2771,11 @@\n+\n+void UnstableIfTrap::suppress(Parse* parser, Parse::Block* path) {\n+  parser->set_block(_block);\n+  parser->set_map(_sfpt);\n+  parser->set_sp(_sfpt->jvms()->sp());\n+  parser->adjust_map_after_if(_btest, _cmp, PROB_MAX, path);\n+\n+  int pnum = path->next_path_num();\n+  parser->merge_common(path, pnum);\n+  _next_bci = -1;\n+}\n","filename":"src\/hotspot\/share\/opto\/parse2.cpp","additions":25,"deletions":14,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -57,0 +57,24 @@\n+    \/\/ a custom \"boxing\" class\n+    public static class Value {\n+        public int _value;\n+\n+        public Value(int value) {\n+          this._value = value;\n+        }\n+    }\n+\n+    @Test\n+    @Arguments({Argument.TRUE, Argument.DEFAULT, Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    @IR(failOn = {IRNode.UNSTABLE_IF_TRAP})\n+    public static int superficial_if(boolean cond, int i, int j, int k) {\n+        Value x = new Value(i);\n+        Value y = new Value(j);\n+        Value z = new Value(k);\n+\n+        if (cond) { \/\/ likely\n+            i++;\n+        } \/\/ else section is superficial\n+\n+        return x._value + y._value + z._value + i;\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestOptimizeUnstableIf.java","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"}]}