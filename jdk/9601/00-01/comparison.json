{"files":[{"patch":"@@ -464,0 +464,1 @@\n+  bool unstable_if_merge(Block* target, SafePointNode* newin);\n","filename":"src\/hotspot\/share\/opto\/parse.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -659,1 +659,0 @@\n-\n@@ -661,5 +660,0 @@\n-          CallStaticJavaNode* unc = trap->uncommon_trap();\n-          unc->set_req(0, top());\n-          record_for_igvn(unc);\n-          \/\/tty->print(\"mark dead: \");\n-          \/\/unc->dump();\n@@ -1843,0 +1837,49 @@\n+\/\/ determine if parser should merge the block of newin, which is optional.\n+bool Parse::unstable_if_merge(Parse::Block* target, SafePointNode* newin) {\n+  if (TraceOptoParse) {\n+    tty->print(\"UnstableIf Merging state at block #%d bci:%d\", target->rpo(), target->start());\n+  }\n+\n+  assert(target->is_merged(), \"No prior mapping at this bci\");\n+  bool result = true;\n+  Block* save_block = block(); \/\/ Hang on to incoming block;\n+  load_state_from(target);    \/\/ Get prior mapping\n+\n+  assert(newin->jvms()->locoff() == jvms()->locoff(), \"JVMS layouts agree\");\n+  assert(newin->jvms()->stkoff() == jvms()->stkoff(), \"JVMS layouts agree\");\n+  assert(newin->jvms()->monoff() == jvms()->monoff(), \"JVMS layouts agree\");\n+  assert(newin->jvms()->endoff() == jvms()->endoff(), \"JVMS layouts agree\");\n+\n+  assert(control()->is_Region(), \"must be merging to a region\");\n+  RegionNode* r = control()->as_Region();\n+  assert(TypeFunc::Parms == newin->jvms()->locoff(), \"parser map should contain only youngest jvms\");\n+\n+  for (uint j = 1; result && j < map()->req(); j++) {\n+    Node* m = map()->in(j);   \/\/ Current state of target.\n+    Node* n = newin->in(j);   \/\/ Incoming change to target state.\n+    PhiNode* phi = nullptr;\n+\n+    if (m->is_Phi() && m->as_Phi()->region() == r)\n+      phi = m->as_Phi();\n+\n+    if (m != n) {             \/\/ Different; must merge\n+      switch (j) {\n+      \/\/ Frame pointer and Return Address never changes\n+      case TypeFunc::FramePtr:\/\/ Drop m, use the original value\n+      case TypeFunc::ReturnAdr:\n+      case TypeFunc::Memory:  \/\/ Merge inputs to the MergeMem node\n+        break;\n+      default:                \/\/ All normal stuff\n+        \/\/ Parser needs to create a phi node and merge a constant m with n.\n+        \/\/ This clobbers constant folding, so drop out!\n+        if (phi == nullptr && m->is_Con() && m != top()) {\n+          result = false;\n+        }\n+        break;\n+      }\n+    }\n+  } \/\/ End of for all values to be merged\n+\n+  set_block(save_block);\n+  return result;\n+}\n","filename":"src\/hotspot\/share\/opto\/parse1.cpp","additions":49,"deletions":6,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -1584,0 +1584,5 @@\n+  \/\/ Refrain from generating uncommon_trap if path has been merged. It is a live block.\n+  \/\/ We don't know if path is live or dead yet if is_merge() returns false. We still generate\n+  \/\/ an uncommon_trap but take a record. We postpone decision to the parse-time of path.\n+  \/\/ If path is dead, it proves that this uncommon_trap does prune code. C2 will skip parsing\n+  \/\/ path and leave the uncommon_trap.\n@@ -2773,8 +2778,13 @@\n-  parser->set_block(_block);\n-  parser->set_map(_sfpt);\n-  parser->set_sp(_sfpt->jvms()->sp());\n-  parser->adjust_map_after_if(_btest, _cmp, PROB_MAX, path);\n-\n-  int pnum = path->next_path_num();\n-  parser->merge_common(path, pnum);\n-  _next_bci = -1;\n+  if (parser->unstable_if_merge(path, _sfpt)) {\n+    int pnum = path->next_path_num();\n+\n+    parser->set_block(_block);\n+    parser->set_map(_sfpt);\n+    parser->set_sp(_sfpt->jvms()->sp());\n+    parser->adjust_map_after_if(_btest, _cmp, PROB_MAX, path);\n+    parser->merge_common(path, pnum);\n+    _next_bci = -1;\n+\n+    _unc->set_req(0, parser->top());\n+    parser->record_for_igvn(_unc);\n+  }\n","filename":"src\/hotspot\/share\/opto\/parse2.cpp","additions":18,"deletions":8,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -81,0 +81,16 @@\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.TRUE})\n+    @IR(failOn = {IRNode.MUL})\n+    @IR(counts = {IRNode.UNSTABLE_IF_TRAP, \"1\"})\n+    public static int superfical_if_constant(int x, boolean cond) {\n+        int i = x;\n+        if (cond) { \/\/ likely\n+            i = 0;\n+        }\n+        \/\/ really complex iterations I made up\n+        int y  = 42;\n+        y = (int)(Math.sqrt(y) + (x * 0.1191837));\n+        \/\/ if constant folding works, y will be dead and return 0;\n+        return  i * y;\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestOptimizeUnstableIf.java","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"}]}