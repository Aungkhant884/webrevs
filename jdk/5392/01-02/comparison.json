{"files":[{"patch":"@@ -407,1 +407,1 @@\n-      java_lang_Throwable::fill_in_stack_trace_of_implicit_exception(handle, gk);\n+      java_lang_Throwable::allocate_fill_stack_trace_of_implicit_exception(handle, gk);\n","filename":"src\/hotspot\/share\/ci\/ciEnv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2572,1 +2572,1 @@\n-void java_lang_Throwable::fill_in_stack_trace_of_implicit_exception(Handle throwable, GraphKit* gk) {\n+void java_lang_Throwable::allocate_fill_stack_trace_of_implicit_exception(Handle throwable, GraphKit* gk) {\n@@ -2578,2 +2578,2 @@\n-  java_lang_Throwable::allocate_backtrace(throwable, CHECK);\n-  objArrayHandle backtrace (THREAD, (objArrayOop)java_lang_Throwable::backtrace(throwable()));\n+  InstanceKlass* ik = vmClasses::StackTraceElement_klass();\n+  assert(ik != NULL, \"must be loaded in 1.4+\");\n@@ -2581,0 +2581,1 @@\n+  \/\/ Determin the number of available frames\n@@ -2582,8 +2583,3 @@\n-\n-  BacktraceBuilder bt(THREAD, backtrace);\n-\n-  \/\/ fill in as much stack trace as available\n-  int chunk_count = 1;\n-  Method* m = gk->method()->get_Method();\n-  assert(m != NULL, \"Method* of the ciMethod we're compiling should be set.\");\n-  bt.push(m, gk->bci(), CHECK);\n+  GrowableArray<JVMState*> call_chain;\n+  int depth = 1;\n+  call_chain.append(gk->jvms());\n@@ -2592,2 +2588,2 @@\n-    bt.push(caller->method()->get_Method(), caller->bci(), CHECK);\n-    chunk_count++;\n+    call_chain.append(caller);\n+    depth++;\n@@ -2596,1 +2592,11 @@\n-  set_depth(throwable(), chunk_count);\n+  \/\/ Allocate an array of java\/lang\/StackTraceElement object\n+  objArrayOop ste = oopFactory::new_objArray(ik, depth, CHECK);\n+  objArrayHandle backtrace(THREAD, ste);\n+  \/\/ Fill in as much stack trace as available\n+  for (int j = 0; j < depth; j++) {\n+    JVMState* call = call_chain.at(j);\n+    methodHandle mh(THREAD, call->method()->get_Method());\n+    oop element = java_lang_StackTraceElement::create(mh, j == 0 ? gk->bci() : call->bci(), CHECK);\n+    backtrace->obj_at_put(j, element);\n+  }\n+\n@@ -2598,2 +2604,3 @@\n-                       throwable->klass()->external_name(), chunk_count,\n-                       m->klass_name()->as_klass_external_name(), m->name()->as_C_string(), gk->bci());\n+                       throwable->klass()->external_name(), depth,\n+                       gk->method()->get_Method()->klass_name()->as_klass_external_name(),\n+                       gk->method()->get_Method()->name()->as_C_string(), gk->bci());\n@@ -2601,3 +2608,4 @@\n-  \/\/ We support the Throwable immutability protocol defined for Java 7.\n-  java_lang_Throwable::set_stacktrace(throwable(), java_lang_Throwable::unassigned_stacktrace());\n-  assert(java_lang_Throwable::unassigned_stacktrace() != NULL, \"not initialized\");\n+  set_depth(throwable(), depth);\n+  set_stacktrace(throwable(), backtrace());\n+  \/\/ Clear backtrace because the stacktrace should be used instead.\n+  set_backtrace(throwable(), NULL);\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":27,"deletions":19,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -561,1 +561,1 @@\n-  static void fill_in_stack_trace_of_implicit_exception(Handle throwable, GraphKit* gk);\n+  static void allocate_fill_stack_trace_of_implicit_exception(Handle throwable, GraphKit* gk);\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}