{"files":[{"patch":"@@ -83,0 +83,1 @@\n+#include \"opto\/compile.hpp\"\n@@ -395,1 +396,35 @@\n-ciInstance* ciEnv::ArrayIndexOutOfBoundsException_instance() {\n+\/\/ ------------------------------------------------------------------\n+\/\/ helper for implicit exception creation\n+#ifdef COMPILER2\n+ciInstance* ciEnv::create_implicit_exception(Symbol* name, GraphKit* gk) {\n+  VM_ENTRY_MARK;\n+  InstanceKlass* ik = SystemDictionary::find_instance_klass(name, Handle(), Handle());\n+  jobject objh = NULL;\n+  if (ik != NULL) {\n+    oop obj = ik->allocate_instance(THREAD);\n+    if (!HAS_PENDING_EXCEPTION) {\n+      Handle handle = Handle(THREAD, obj);\n+      java_lang_Throwable::fill_in_stack_trace_of_implicit_exception(handle, gk);\n+      \/\/ nmethods are no strong roots so we have to create a global JNI handle\n+      \/\/ for the created exception in order to keep it alive accross GCs.\n+      objh = JNIHandles::make_global(handle);\n+      Compile* C = (Compile*)compiler_data();\n+      \/\/ Record exception handle so we can free it later when the nmethod is unloaded (see nmethod::flush())\n+      C->add_implicit_exception(objh);\n+    }\n+  }\n+  if (HAS_PENDING_EXCEPTION) {\n+    CLEAR_PENDING_EXCEPTION;\n+    return NULL;\n+  } else {\n+    oop obj = JNIHandles::resolve(objh);\n+    return obj == NULL? NULL: get_object(obj)->as_instance();\n+  }\n+}\n+#endif\n+\n+ciInstance* ciEnv::ArrayIndexOutOfBoundsException_instance(GraphKit* gk) {\n+  if (StackFrameInFastThrow) {\n+    ciInstance* excp = create_implicit_exception(vmSymbols::java_lang_ArrayIndexOutOfBoundsException(), gk);\n+    if (excp != NULL) return excp;\n+  }\n@@ -403,1 +438,5 @@\n-ciInstance* ciEnv::ArrayStoreException_instance() {\n+ciInstance* ciEnv::ArrayStoreException_instance(GraphKit* gk) {\n+  if (StackFrameInFastThrow) {\n+    ciInstance* excp = create_implicit_exception(vmSymbols::java_lang_ArrayStoreException(), gk);\n+    if (excp != NULL) return excp;\n+  }\n@@ -411,1 +450,5 @@\n-ciInstance* ciEnv::ClassCastException_instance() {\n+ciInstance* ciEnv::ClassCastException_instance(GraphKit* gk) {\n+  if (StackFrameInFastThrow) {\n+    ciInstance* excp = create_implicit_exception(vmSymbols::java_lang_ClassCastException(), gk);\n+    if (excp != NULL) return excp;\n+  }\n@@ -420,0 +463,19 @@\n+ciInstance* ciEnv::NullPointerException_instance(GraphKit* gk) {\n+  if (StackFrameInFastThrow) {\n+    ciInstance* excp = create_implicit_exception(vmSymbols::java_lang_NullPointerException(), gk);\n+    if (excp != NULL)\n+      return excp;\n+  }\n+  assert(_NullPointerException_instance != NULL, \"initialization problem\");\n+  return _NullPointerException_instance;\n+}\n+ciInstance* ciEnv::ArithmeticException_instance(GraphKit* gk) {\n+  if (StackFrameInFastThrow) {\n+    ciInstance* excp = create_implicit_exception(vmSymbols::java_lang_ArithmeticException(), gk);\n+    if (excp != NULL)\n+      return excp;\n+  }\n+  assert(_ArithmeticException_instance != NULL, \"initialization problem\");\n+  return _ArithmeticException_instance;\n+}\n+\n@@ -1027,1 +1089,2 @@\n-                            const GrowableArrayView<RuntimeStub*>& native_invokers) {\n+                            const GrowableArrayView<RuntimeStub*>& native_invokers,\n+                            const GrowableArrayView<jobject>& implicit_exceptions) {\n@@ -1117,1 +1180,2 @@\n-                               native_invokers);\n+                               native_invokers,\n+                               implicit_exceptions);\n","filename":"src\/hotspot\/share\/ci\/ciEnv.cpp","additions":69,"deletions":5,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+class GraphKit;\n@@ -231,0 +232,2 @@\n+  ciInstance* create_implicit_exception(Symbol* name, GraphKit* gk) NOT_COMPILER2({ return NULL;});\n+\n@@ -383,1 +386,2 @@\n-                       const GrowableArrayView<RuntimeStub*>& native_invokers = GrowableArrayView<RuntimeStub*>::EMPTY);\n+                       const GrowableArrayView<RuntimeStub*>& native_invokers = GrowableArrayView<RuntimeStub*>::EMPTY,\n+                       const GrowableArrayView<jobject>& implicit_exceptions = GrowableArrayView<jobject>::EMPTY);\n@@ -394,8 +398,2 @@\n-  ciInstance* NullPointerException_instance() {\n-    assert(_NullPointerException_instance != NULL, \"initialization problem\");\n-    return _NullPointerException_instance;\n-  }\n-  ciInstance* ArithmeticException_instance() {\n-    assert(_ArithmeticException_instance != NULL, \"initialization problem\");\n-    return _ArithmeticException_instance;\n-  }\n+  ciInstance* NullPointerException_instance(GraphKit* gk);\n+  ciInstance* ArithmeticException_instance(GraphKit* gk);\n@@ -404,3 +402,3 @@\n-  ciInstance* ArrayIndexOutOfBoundsException_instance();\n-  ciInstance* ArrayStoreException_instance();\n-  ciInstance* ClassCastException_instance();\n+  ciInstance* ArrayIndexOutOfBoundsException_instance(GraphKit* gk);\n+  ciInstance* ArrayStoreException_instance(GraphKit* gk);\n+  ciInstance* ClassCastException_instance(GraphKit* gk);\n","filename":"src\/hotspot\/share\/ci\/ciEnv.hpp","additions":10,"deletions":12,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -85,0 +85,3 @@\n+#ifdef COMPILER2\n+#include \"opto\/graphKit.hpp\"\n+#endif\n@@ -2568,0 +2571,35 @@\n+#ifdef COMPILER2\n+void java_lang_Throwable::fill_in_stack_trace_of_implicit_exception(Handle throwable, GraphKit* gk) {\n+  \/\/ Fill in the stack frame(s) for an implicit exception, can cause GC\n+  assert(throwable->is_a(vmClasses::Throwable_klass()), \"sanity check\");\n+\n+  JavaThread* THREAD = JavaThread::current(); \/\/ For exception macros.\n+\n+  java_lang_Throwable::allocate_backtrace(throwable, CHECK);\n+  objArrayHandle backtrace (THREAD, (objArrayOop)java_lang_Throwable::backtrace(throwable()));\n+\n+  ResourceMark rm(THREAD);\n+\n+  BacktraceBuilder bt(THREAD, backtrace);\n+\n+  \/\/ fill in as much stack trace as available\n+  int chunk_count = 1;\n+  Method* m = gk->method()->get_Method();\n+  assert(m != NULL, \"Method* of the ciMethod we're compiling should be set.\");\n+  bt.push(m, gk->bci(), CHECK);\n+  JVMState* caller = gk->jvms()->caller();\n+  while (caller != NULL) {\n+    bt.push(caller->method()->get_Method(), caller->bci(), CHECK);\n+    chunk_count++;\n+    caller = caller->caller();\n+  }\n+  set_depth(throwable(), chunk_count);\n+  log_info(stacktrace)(\"Created implicit exception %s with %d stack frame(s) for %s::%s at bci %d\",\n+                       throwable->klass()->external_name(), chunk_count,\n+                       m->klass_name()->as_klass_external_name(), m->name()->as_C_string(), gk->bci());\n+\n+  \/\/ We support the Throwable immutability protocol defined for Java 7.\n+  java_lang_Throwable::set_stacktrace(throwable(), java_lang_Throwable::unassigned_stacktrace());\n+  assert(java_lang_Throwable::unassigned_stacktrace() != NULL, \"not initialized\");\n+}\n+#endif\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":38,"deletions":0,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+class GraphKit;\n@@ -558,0 +559,4 @@\n+  #ifdef COMPILER2\n+  \/\/ Fill in the stack frame(s) for an implicit exception, can cause GC\n+  static void fill_in_stack_trace_of_implicit_exception(Handle throwable, GraphKit* gk);\n+  #endif\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -125,0 +125,2 @@\n+  int native_invokers_size;\n+  int implicit_exceptions_size;\n@@ -136,12 +138,14 @@\n-    total_size          += nm->size();\n-    relocation_size     += nm->relocation_size();\n-    consts_size         += nm->consts_size();\n-    insts_size          += nm->insts_size();\n-    stub_size           += nm->stub_size();\n-    oops_size           += nm->oops_size();\n-    metadata_size       += nm->metadata_size();\n-    scopes_data_size    += nm->scopes_data_size();\n-    scopes_pcs_size     += nm->scopes_pcs_size();\n-    dependencies_size   += nm->dependencies_size();\n-    handler_table_size  += nm->handler_table_size();\n-    nul_chk_table_size  += nm->nul_chk_table_size();\n+    total_size               += nm->size();\n+    relocation_size          += nm->relocation_size();\n+    consts_size              += nm->consts_size();\n+    insts_size               += nm->insts_size();\n+    stub_size                += nm->stub_size();\n+    oops_size                += nm->oops_size();\n+    metadata_size            += nm->metadata_size();\n+    scopes_data_size         += nm->scopes_data_size();\n+    scopes_pcs_size          += nm->scopes_pcs_size();\n+    dependencies_size        += nm->dependencies_size();\n+    native_invokers_size     += nm->native_invokers_size();\n+    implicit_exceptions_size += nm->implicit_exceptions_size();\n+    handler_table_size       += nm->handler_table_size();\n+    nul_chk_table_size       += nm->nul_chk_table_size();\n@@ -149,2 +153,2 @@\n-    speculations_size   += nm->speculations_size();\n-    jvmci_data_size     += nm->jvmci_data_size();\n+    speculations_size        += nm->speculations_size();\n+    jvmci_data_size          += nm->jvmci_data_size();\n@@ -156,13 +160,15 @@\n-    if (total_size != 0)          tty->print_cr(\" total in heap  = %d\", total_size);\n-    if (nmethod_count != 0)       tty->print_cr(\" header         = \" SIZE_FORMAT, nmethod_count * sizeof(nmethod));\n-    if (relocation_size != 0)     tty->print_cr(\" relocation     = %d\", relocation_size);\n-    if (consts_size != 0)         tty->print_cr(\" constants      = %d\", consts_size);\n-    if (insts_size != 0)          tty->print_cr(\" main code      = %d\", insts_size);\n-    if (stub_size != 0)           tty->print_cr(\" stub code      = %d\", stub_size);\n-    if (oops_size != 0)           tty->print_cr(\" oops           = %d\", oops_size);\n-    if (metadata_size != 0)       tty->print_cr(\" metadata       = %d\", metadata_size);\n-    if (scopes_data_size != 0)    tty->print_cr(\" scopes data    = %d\", scopes_data_size);\n-    if (scopes_pcs_size != 0)     tty->print_cr(\" scopes pcs     = %d\", scopes_pcs_size);\n-    if (dependencies_size != 0)   tty->print_cr(\" dependencies   = %d\", dependencies_size);\n-    if (handler_table_size != 0)  tty->print_cr(\" handler table  = %d\", handler_table_size);\n-    if (nul_chk_table_size != 0)  tty->print_cr(\" nul chk table  = %d\", nul_chk_table_size);\n+    if (total_size != 0)               tty->print_cr(\" total in heap  = %d\", total_size);\n+    if (nmethod_count != 0)            tty->print_cr(\" header         = \" SIZE_FORMAT, nmethod_count * sizeof(nmethod));\n+    if (relocation_size != 0)          tty->print_cr(\" relocation     = %d\", relocation_size);\n+    if (consts_size != 0)              tty->print_cr(\" constants      = %d\", consts_size);\n+    if (insts_size != 0)               tty->print_cr(\" main code      = %d\", insts_size);\n+    if (stub_size != 0)                tty->print_cr(\" stub code      = %d\", stub_size);\n+    if (oops_size != 0)                tty->print_cr(\" oops           = %d\", oops_size);\n+    if (metadata_size != 0)            tty->print_cr(\" metadata       = %d\", metadata_size);\n+    if (scopes_data_size != 0)         tty->print_cr(\" scopes data    = %d\", scopes_data_size);\n+    if (scopes_pcs_size != 0)          tty->print_cr(\" scopes pcs     = %d\", scopes_pcs_size);\n+    if (dependencies_size != 0)        tty->print_cr(\" dependencies   = %d\", dependencies_size);\n+    if (native_invokers_size != 0)     tty->print_cr(\" native invkrs  = %d\", native_invokers_size);\n+    if (implicit_exceptions_size != 0) tty->print_cr(\" impl excepts   = %d\", implicit_exceptions_size);\n+    if (handler_table_size != 0)       tty->print_cr(\" handler table  = %d\", handler_table_size);\n+    if (nul_chk_table_size != 0)       tty->print_cr(\" nul chk table  = %d\", nul_chk_table_size);\n@@ -170,2 +176,2 @@\n-    if (speculations_size != 0)   tty->print_cr(\" speculations   = %d\", speculations_size);\n-    if (jvmci_data_size != 0)     tty->print_cr(\" JVMCI data     = %d\", jvmci_data_size);\n+    if (speculations_size != 0)        tty->print_cr(\" speculations   = %d\", speculations_size);\n+    if (jvmci_data_size != 0)          tty->print_cr(\" JVMCI data     = %d\", jvmci_data_size);\n@@ -505,1 +511,2 @@\n-  const GrowableArrayView<RuntimeStub*>& native_invokers\n+  const GrowableArrayView<RuntimeStub*>& native_invokers,\n+  const GrowableArrayView<jobject>& implicit_exceptions\n@@ -528,0 +535,1 @@\n+      + align_up(checked_cast<int>(implicit_exceptions.data_size_in_bytes()), oopSize)\n@@ -544,1 +552,2 @@\n-            native_invokers\n+            native_invokers,\n+            implicit_exceptions\n@@ -632,2 +641,3 @@\n-    _native_invokers_offset     = _dependencies_offset;\n-    _handler_table_offset    = _native_invokers_offset;\n+    _native_invokers_offset  = _dependencies_offset;\n+    _implicit_excepts_offset = _native_invokers_offset;\n+    _handler_table_offset    = _implicit_excepts_offset;\n@@ -730,1 +740,2 @@\n-  const GrowableArrayView<RuntimeStub*>& native_invokers\n+  const GrowableArrayView<RuntimeStub*>& native_invokers,\n+  const GrowableArrayView<jobject>& implicit_exceptions\n@@ -808,1 +819,2 @@\n-    _handler_table_offset    = _native_invokers_offset + align_up(checked_cast<int>(native_invokers.data_size_in_bytes()), oopSize);\n+    _implicit_excepts_offset = _native_invokers_offset + align_up(checked_cast<int>(native_invokers.data_size_in_bytes()), oopSize);\n+    _handler_table_offset    = _implicit_excepts_offset + align_up(checked_cast<int>(implicit_exceptions.data_size_in_bytes()), oopSize);\n@@ -834,0 +846,8 @@\n+    if (implicit_exceptions.is_nonempty()) {\n+      \/\/ Copy global handles for the implcit exceptions created for this\n+      \/\/ nmethod such that we can release them once the nmethod gets unloaded.\n+      memcpy(implicit_exceptions_begin(), implicit_exceptions.adr_at(0), implicit_exceptions.data_size_in_bytes());\n+      log_develop_debug(exceptions)(\"nmethod (%d) for %s::%s has %d implicit exception(s)\", compile_id,\n+                                    method->klass_name()->as_klass_external_name(), method->name()->as_C_string(),\n+                                    implicit_exceptions.length());\n+    }\n@@ -1525,0 +1545,11 @@\n+  \/\/ Release implicit exceptions which have been created for this nmethod\n+  jobject* implicit_exception = implicit_exceptions_begin();\n+  while (implicit_exception < implicit_exceptions_end()) {\n+    assert(*implicit_exception != NULL, \"Must be a valid globel JNI handle\");\n+    JNIHandles::destroy_global(*implicit_exception++);\n+  }\n+  if (implicit_exceptions_begin() < implicit_exceptions_end()) {\n+      log_develop_debug(exceptions)(\"Releasing \" SIZE_FORMAT \" implicit exception(s) for nmethod (%d)\",\n+                                    implicit_exceptions_end() - implicit_exceptions_begin(), _compile_id);\n+  }\n+\n@@ -2540,48 +2571,56 @@\n-  if (size              () > 0) st->print_cr(\" total in heap  [\" INTPTR_FORMAT \",\" INTPTR_FORMAT \"] = %d\",\n-                                             p2i(this),\n-                                             p2i(this) + size(),\n-                                             size());\n-  if (relocation_size   () > 0) st->print_cr(\" relocation     [\" INTPTR_FORMAT \",\" INTPTR_FORMAT \"] = %d\",\n-                                             p2i(relocation_begin()),\n-                                             p2i(relocation_end()),\n-                                             relocation_size());\n-  if (consts_size       () > 0) st->print_cr(\" constants      [\" INTPTR_FORMAT \",\" INTPTR_FORMAT \"] = %d\",\n-                                             p2i(consts_begin()),\n-                                             p2i(consts_end()),\n-                                             consts_size());\n-  if (insts_size        () > 0) st->print_cr(\" main code      [\" INTPTR_FORMAT \",\" INTPTR_FORMAT \"] = %d\",\n-                                             p2i(insts_begin()),\n-                                             p2i(insts_end()),\n-                                             insts_size());\n-  if (stub_size         () > 0) st->print_cr(\" stub code      [\" INTPTR_FORMAT \",\" INTPTR_FORMAT \"] = %d\",\n-                                             p2i(stub_begin()),\n-                                             p2i(stub_end()),\n-                                             stub_size());\n-  if (oops_size         () > 0) st->print_cr(\" oops           [\" INTPTR_FORMAT \",\" INTPTR_FORMAT \"] = %d\",\n-                                             p2i(oops_begin()),\n-                                             p2i(oops_end()),\n-                                             oops_size());\n-  if (metadata_size     () > 0) st->print_cr(\" metadata       [\" INTPTR_FORMAT \",\" INTPTR_FORMAT \"] = %d\",\n-                                             p2i(metadata_begin()),\n-                                             p2i(metadata_end()),\n-                                             metadata_size());\n-  if (scopes_data_size  () > 0) st->print_cr(\" scopes data    [\" INTPTR_FORMAT \",\" INTPTR_FORMAT \"] = %d\",\n-                                             p2i(scopes_data_begin()),\n-                                             p2i(scopes_data_end()),\n-                                             scopes_data_size());\n-  if (scopes_pcs_size   () > 0) st->print_cr(\" scopes pcs     [\" INTPTR_FORMAT \",\" INTPTR_FORMAT \"] = %d\",\n-                                             p2i(scopes_pcs_begin()),\n-                                             p2i(scopes_pcs_end()),\n-                                             scopes_pcs_size());\n-  if (dependencies_size () > 0) st->print_cr(\" dependencies   [\" INTPTR_FORMAT \",\" INTPTR_FORMAT \"] = %d\",\n-                                             p2i(dependencies_begin()),\n-                                             p2i(dependencies_end()),\n-                                             dependencies_size());\n-  if (handler_table_size() > 0) st->print_cr(\" handler table  [\" INTPTR_FORMAT \",\" INTPTR_FORMAT \"] = %d\",\n-                                             p2i(handler_table_begin()),\n-                                             p2i(handler_table_end()),\n-                                             handler_table_size());\n-  if (nul_chk_table_size() > 0) st->print_cr(\" nul chk table  [\" INTPTR_FORMAT \",\" INTPTR_FORMAT \"] = %d\",\n-                                             p2i(nul_chk_table_begin()),\n-                                             p2i(nul_chk_table_end()),\n-                                             nul_chk_table_size());\n+  if (size                    () > 0) st->print_cr(\" total in heap  [\" INTPTR_FORMAT \",\" INTPTR_FORMAT \"] = %d\",\n+                                                   p2i(this),\n+                                                   p2i(this) + size(),\n+                                                   size());\n+  if (relocation_size         () > 0) st->print_cr(\" relocation     [\" INTPTR_FORMAT \",\" INTPTR_FORMAT \"] = %d\",\n+                                                   p2i(relocation_begin()),\n+                                                   p2i(relocation_end()),\n+                                                   relocation_size());\n+  if (consts_size             () > 0) st->print_cr(\" constants      [\" INTPTR_FORMAT \",\" INTPTR_FORMAT \"] = %d\",\n+                                                   p2i(consts_begin()),\n+                                                   p2i(consts_end()),\n+                                                   consts_size());\n+  if (insts_size              () > 0) st->print_cr(\" main code      [\" INTPTR_FORMAT \",\" INTPTR_FORMAT \"] = %d\",\n+                                                   p2i(insts_begin()),\n+                                                   p2i(insts_end()),\n+                                                   insts_size());\n+  if (stub_size               () > 0) st->print_cr(\" stub code      [\" INTPTR_FORMAT \",\" INTPTR_FORMAT \"] = %d\",\n+                                                   p2i(stub_begin()),\n+                                                   p2i(stub_end()),\n+                                                   stub_size());\n+  if (oops_size               () > 0) st->print_cr(\" oops           [\" INTPTR_FORMAT \",\" INTPTR_FORMAT \"] = %d\",\n+                                                   p2i(oops_begin()),\n+                                                   p2i(oops_end()),\n+                                                   oops_size());\n+  if (metadata_size           () > 0) st->print_cr(\" metadata       [\" INTPTR_FORMAT \",\" INTPTR_FORMAT \"] = %d\",\n+                                                   p2i(metadata_begin()),\n+                                                   p2i(metadata_end()),\n+                                                   metadata_size());\n+  if (scopes_data_size        () > 0) st->print_cr(\" scopes data    [\" INTPTR_FORMAT \",\" INTPTR_FORMAT \"] = %d\",\n+                                                   p2i(scopes_data_begin()),\n+                                                   p2i(scopes_data_end()),\n+                                                   scopes_data_size());\n+  if (scopes_pcs_size         () > 0) st->print_cr(\" scopes pcs     [\" INTPTR_FORMAT \",\" INTPTR_FORMAT \"] = %d\",\n+                                                   p2i(scopes_pcs_begin()),\n+                                                   p2i(scopes_pcs_end()),\n+                                                   scopes_pcs_size());\n+  if (dependencies_size       () > 0) st->print_cr(\" dependencies   [\" INTPTR_FORMAT \",\" INTPTR_FORMAT \"] = %d\",\n+                                                   p2i(dependencies_begin()),\n+                                                   p2i(dependencies_end()),\n+                                                   dependencies_size());\n+  if (native_invokers_size    () > 0) st->print_cr(\" native invkrs  [\" INTPTR_FORMAT \",\" INTPTR_FORMAT \"] = %d\",\n+                                                   p2i(native_invokers_begin()),\n+                                                   p2i(native_invokers_end()),\n+                                                   native_invokers_size());\n+  if (implicit_exceptions_size() > 0) st->print_cr(\" impl excepts   [\" INTPTR_FORMAT \",\" INTPTR_FORMAT \"] = %d\",\n+                                                   p2i(implicit_exceptions_begin()),\n+                                                   p2i(implicit_exceptions_end()),\n+                                                   implicit_exceptions_size());\n+  if (handler_table_size      () > 0) st->print_cr(\" handler table  [\" INTPTR_FORMAT \",\" INTPTR_FORMAT \"] = %d\",\n+                                                   p2i(handler_table_begin()),\n+                                                   p2i(handler_table_end()),\n+                                                   handler_table_size());\n+  if (nul_chk_table_size      () > 0) st->print_cr(\" nul chk table  [\" INTPTR_FORMAT \",\" INTPTR_FORMAT \"] = %d\",\n+                                                   p2i(nul_chk_table_begin()),\n+                                                   p2i(nul_chk_table_end()),\n+                                                   nul_chk_table_size());\n@@ -2589,8 +2628,8 @@\n-  if (speculations_size () > 0) st->print_cr(\" speculations   [\" INTPTR_FORMAT \",\" INTPTR_FORMAT \"] = %d\",\n-                                             p2i(speculations_begin()),\n-                                             p2i(speculations_end()),\n-                                             speculations_size());\n-  if (jvmci_data_size   () > 0) st->print_cr(\" JVMCI data     [\" INTPTR_FORMAT \",\" INTPTR_FORMAT \"] = %d\",\n-                                             p2i(jvmci_data_begin()),\n-                                             p2i(jvmci_data_end()),\n-                                             jvmci_data_size());\n+  if (speculations_size       () > 0) st->print_cr(\" speculations   [\" INTPTR_FORMAT \",\" INTPTR_FORMAT \"] = %d\",\n+                                                   p2i(speculations_begin()),\n+                                                   p2i(speculations_end()),\n+                                                   speculations_size());\n+  if (jvmci_data_size         () > 0) st->print_cr(\" JVMCI data     [\" INTPTR_FORMAT \",\" INTPTR_FORMAT \"] = %d\",\n+                                                   p2i(jvmci_data_begin()),\n+                                                   p2i(jvmci_data_end()),\n+                                                   jvmci_data_size());\n","filename":"src\/hotspot\/share\/code\/nmethod.cpp","additions":130,"deletions":91,"binary":false,"changes":221,"status":"modified"},{"patch":"@@ -212,0 +212,1 @@\n+  int _implicit_excepts_offset;\n@@ -313,1 +314,2 @@\n-          const GrowableArrayView<RuntimeStub*>& native_invokers\n+          const GrowableArrayView<RuntimeStub*>& native_invokers,\n+          const GrowableArrayView<jobject>& implicit_exceptions\n@@ -362,1 +364,2 @@\n-                              const GrowableArrayView<RuntimeStub*>& native_invokers = GrowableArrayView<RuntimeStub*>::EMPTY\n+                              const GrowableArrayView<RuntimeStub*>& native_invokers = GrowableArrayView<RuntimeStub*>::EMPTY,\n+                              const GrowableArrayView<jobject>& implicit_exceptions = GrowableArrayView<jobject>::EMPTY\n@@ -413,1 +416,3 @@\n-  RuntimeStub** native_invokers_end  () const     { return (RuntimeStub**)(header_begin() + _handler_table_offset); }\n+  RuntimeStub** native_invokers_end  () const     { return (RuntimeStub**)(header_begin() + _implicit_excepts_offset); }\n+  jobject* implicit_exceptions_begin () const     { return (jobject*)(header_begin() + _implicit_excepts_offset) ; }\n+  jobject* implicit_exceptions_end   () const     { return (jobject*)(header_begin() + _handler_table_offset); }\n@@ -428,3 +433,5 @@\n-  int oops_size         () const                  { return (address)  oops_end         () - (address)  oops_begin         (); }\n-  int metadata_size     () const                  { return (address)  metadata_end     () - (address)  metadata_begin     (); }\n-  int dependencies_size () const                  { return            dependencies_end () -            dependencies_begin (); }\n+  int oops_size               () const            { return (address) oops_end               () - (address) oops_begin               (); }\n+  int metadata_size           () const            { return (address) metadata_end           () - (address) metadata_begin           (); }\n+  int dependencies_size       () const            { return           dependencies_end       () -           dependencies_begin       (); }\n+  int native_invokers_size    () const            { return (address) native_invokers_end    () - (address) native_invokers_begin    (); }\n+  int implicit_exceptions_size() const            { return (address) implicit_exceptions_end() - (address) implicit_exceptions_begin(); }\n@@ -432,2 +439,2 @@\n-  int speculations_size () const                  { return            speculations_end () -            speculations_begin (); }\n-  int jvmci_data_size   () const                  { return            jvmci_data_end   () -            jvmci_data_begin   (); }\n+  int speculations_size () const                  { return           speculations_end       () -           speculations_begin       (); }\n+  int jvmci_data_size   () const                  { return           jvmci_data_end         () -           jvmci_data_begin         (); }\n","filename":"src\/hotspot\/share\/code\/nmethod.hpp","additions":15,"deletions":8,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -1746,1 +1746,1 @@\n-                                 speculations, speculations_len,\n+                                 GrowableArrayView<jobject>::EMPTY, speculations, speculations_len,\n","filename":"src\/hotspot\/share\/jvmci\/jvmciRuntime.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -599,0 +599,1 @@\n+                  _implicit_exceptions(comp_arena(), 1, 0, NULL),\n@@ -4897,1 +4898,0 @@\n-\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -395,0 +395,2 @@\n+  GrowableArray<jobject>        _implicit_exceptions;\n+\n@@ -965,0 +967,4 @@\n+  void add_implicit_exception(jobject except) { _implicit_exceptions.append(except); }\n+\n+  const GrowableArray<jobject> implicit_exceptions() const { return _implicit_exceptions; }\n+\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -574,1 +574,1 @@\n-      ex_obj = env()->NullPointerException_instance();\n+      ex_obj = env()->NullPointerException_instance(this);\n@@ -577,1 +577,1 @@\n-      ex_obj = env()->ArithmeticException_instance();\n+      ex_obj = env()->ArithmeticException_instance(this);\n@@ -580,1 +580,1 @@\n-      ex_obj = env()->ArrayIndexOutOfBoundsException_instance();\n+      ex_obj = env()->ArrayIndexOutOfBoundsException_instance(this);\n@@ -584,1 +584,1 @@\n-        ex_obj = env()->ArrayStoreException_instance();\n+        ex_obj = env()->ArrayStoreException_instance(this);\n@@ -586,1 +586,1 @@\n-        ex_obj = env()->ClassCastException_instance();\n+        ex_obj = env()->ClassCastException_instance(this);\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -3397,1 +3397,2 @@\n-                                     C->native_invokers());\n+                                     C->native_invokers(),\n+                                     C->implicit_exceptions());\n","filename":"src\/hotspot\/share\/opto\/output.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -645,0 +645,4 @@\n+  product(bool, StackFrameInFastThrow, true,                                \\\n+          \"Create backtraces with at least the top stack frame for 'hot' \"  \\\n+          \"exceptions optimized by -XX:+OmitStackTraceInFastThrow\")         \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,250 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+ \/*\n+ * @test\n+ * @bug 9999999\n+ * @summary Test -XX:+\/-OmitStackTraceInFastThrow and -XX:+\/-StackFrameInFastThrow\n+ *\n+ * @requires vm.compiler2.enabled\n+ * @requires vm.compMode != \"Xcomp\"\n+ *\n+ * @library \/test\/lib\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   -XX:+UseSerialGC -Xbatch -XX:-UseOnStackReplacement -XX:-TieredCompilation\n+ *                   -XX:CompileCommand=inline,compiler.exceptions.StackFrameInFastThrow::throwImplicitException\n+ *                   -XX:CompileCommand=inline,compiler.exceptions.StackFrameInFastThrow::level2\n+ *                   -XX:PerMethodTrapLimit=0 compiler.exceptions.StackFrameInFastThrow\n+ *\/\n+\n+package compiler.exceptions;\n+\n+import java.lang.reflect.Method;\n+import java.util.HashMap;\n+\n+import jdk.test.lib.Asserts;\n+import jdk.test.whitebox.WhiteBox;\n+\n+public class StackFrameInFastThrow {\n+    public enum ImplicitException {\n+        NULL_POINTER_EXCEPTION,\n+        ARITHMETIC_EXCEPTION,\n+        ARRAY_INDEX_OUT_OF_BOUNDS_EXCEPTION,\n+        ARRAY_STORE_EXCEPTION,\n+        CLASS_CAST_EXCEPTION\n+    }\n+    public enum CompMode {\n+        INTERPRETED,\n+        C2,\n+        C2_RECOMPILED\n+    }\n+    public enum TestMode {\n+        STACKTRACES_IN_FASTTHROW,\n+        OMIT_STACKTRACES_IN_FASTTHROW,\n+        OMIT_STACKTRACES_IN_FASTTHROW_WITH_STACKFRAME\n+    }\n+\n+    private static final WhiteBox WB = WhiteBox.getWhiteBox();\n+    private static String[] string_a = new String[1];\n+    private static boolean DEBUG = Boolean.getBoolean(\"DEBUG\");\n+\n+    public static Object throwImplicitException(ImplicitException type, Object[] object_a) {\n+        switch (type) {\n+            case NULL_POINTER_EXCEPTION: {\n+                return object_a.length;\n+            }\n+            case ARITHMETIC_EXCEPTION: {\n+                return ((42 \/ (object_a.length - 1)) > 2) ? null : object_a[0];\n+            }\n+            case ARRAY_INDEX_OUT_OF_BOUNDS_EXCEPTION: {\n+                return object_a[5];\n+            }\n+            case ARRAY_STORE_EXCEPTION: {\n+                return (object_a[0] = new Object());\n+            }\n+            case CLASS_CAST_EXCEPTION: {\n+                return (ImplicitException[])object_a;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    public static Object level2(ImplicitException type, Object[] object_a) {\n+        return throwImplicitException(type, object_a);\n+    }\n+\n+    public static Object level1(ImplicitException type, Object[] object_a) {\n+        return level2(type, object_a);\n+    }\n+\n+    private static void compile(Method m) {\n+        Asserts.assertFalse(WB.isMethodCompiled(m), \"Method shouldn't be compiled.\");\n+        WB.enqueueMethodForCompilation(m, 4);\n+        Asserts.assertEQ(WB.getMethodCompilationLevel(m), 4, \"Method should be compiled at level 4.\");\n+    }\n+\n+    private static void unload(Method m) {\n+        Asserts.assertEQ(WB.getMethodCompilationLevel(m), 4, \"Method should be compiled at level 4.\");\n+        if (DEBUG) System.console().readLine();\n+        WB.deoptimizeMethod(m);  \/\/ Makes the nmethod \"not entrant\".\n+        WB.forceNMethodSweep();  \/\/ Makes all \"not entrant\" nmethods \"zombie\". This requires\n+        WB.forceNMethodSweep();  \/\/ two sweeps, see 'nmethod::can_convert_to_zombie()' for why.\n+        WB.forceNMethodSweep();  \/\/ Need third sweep to actually unload\/free all \"zombie\" nmethods.\n+        if (DEBUG) System.console().readLine();\n+        System.gc();\n+        if (DEBUG) System.console().readLine();\n+    }\n+\n+    private static void recompile(Method m) {\n+        unload(m);\n+        compile(m);\n+    }\n+\n+    private static boolean exceptionsEqual(Exception e1, Exception e2) {\n+        if (e1.getClass() == e2.getClass()) {\n+            if (e1.getMessage() == e2.getMessage() || e1.getMessage().equals(e2.getMessage())) {\n+                StackTraceElement[] ste1 = e1.getStackTrace();\n+                StackTraceElement[] ste2 = e2.getStackTrace();\n+                if (ste1.length == ste2.length) {\n+                    for (int i = 0; i < ste1.length; i++) {\n+                        if (!ste1[i].equals(ste2[i])) {\n+                            return false;\n+                        }\n+                    }\n+                    return true;\n+                }\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private static HashMap<ImplicitException, Exception> lastException = new HashMap<>();\n+\n+    private static void checkResult(ImplicitException implExcp, Exception catchedExcp, CompMode compMode, TestMode testMode) {\n+        catchedExcp.printStackTrace(System.out);\n+\n+        if (compMode == CompMode.INTERPRETED) {\n+            \/\/ Exception thrown by the interpreter should have the full stack trace\n+            Asserts.assertTrue(catchedExcp.getStackTrace()[3].getMethodName().equals(\"main\"),\n+                               \"Can't see main() in interpreter stack trace\");\n+            lastException.put(implExcp, catchedExcp);\n+        }\n+        if (compMode == CompMode.C2 || compMode == CompMode.C2_RECOMPILED) {\n+            switch (testMode) {\n+                case STACKTRACES_IN_FASTTHROW : {\n+                    Asserts.assertTrue(catchedExcp.getStackTrace()[3].getMethodName().equals(\"main\"),\n+                                       \"-XX:-OmitStackTraceInFastThrow should generate full stack trace\");\n+                    Asserts.assertTrue(exceptionsEqual(lastException.get(implExcp), catchedExcp),\n+                                       \"With -XX:-OmitStackTraceInFastThrow interpreter and C2 generated exceptions should be equal\");\n+                    break;\n+                }\n+                case OMIT_STACKTRACES_IN_FASTTHROW : {\n+                    Asserts.assertEQ(catchedExcp.getStackTrace().length, 0,\n+                                     \"-XX:+OmitStackTraceInFastThrow should generate an emtpy stack trace\");\n+                    if (compMode == CompMode.C2_RECOMPILED) {\n+                        Asserts.assertEQ(lastException.get(implExcp), catchedExcp,\n+                                         \"With -XX:+OmitStackTraceInFastThrow all exceptions should be the same singleton instance\");\n+                    }\n+                    break;\n+                }\n+                case OMIT_STACKTRACES_IN_FASTTHROW_WITH_STACKFRAME : {\n+                    Asserts.assertTrue(catchedExcp.getStackTrace()[2].getMethodName().equals(\"level1\"),\n+                                       \"-XX:+OmitStackTraceInFastThrow -XX:+StackFrameInFastThrow should generate a minimal stack trace\");\n+                    if (compMode == CompMode.C2_RECOMPILED) {\n+                        Asserts.assertTrue(exceptionsEqual(lastException.get(implExcp), catchedExcp),\n+                                                           \"With -XX:+OmitStackTraceInFastThrow -XX:+StackFrameInFastThrow C2 generated exceptions should be equal\");\n+                        Asserts.assertNE(lastException.get(implExcp), catchedExcp,\n+                                \"With -XX:+OmitStackTraceInFastThrow -XX:+StackFrameInFastThrow new exceptions should be generated for every nmethod\");\n+                    }\n+                    break;\n+                }\n+            }\n+            if (compMode == CompMode.C2_RECOMPILED) {\n+                lastException.put(implExcp, null);\n+            }\n+            else {\n+                lastException.put(implExcp, catchedExcp);\n+            }\n+        }\n+    }\n+\n+    private static void setFlags(TestMode testMode) {\n+        if (testMode == TestMode.STACKTRACES_IN_FASTTHROW) {\n+            WB.setBooleanVMFlag(\"OmitStackTraceInFastThrow\", false);\n+        }\n+        else {\n+            WB.setBooleanVMFlag(\"OmitStackTraceInFastThrow\", true);\n+            WB.setBooleanVMFlag(\"StackFrameInFastThrow\", false);\n+        }\n+        if (testMode == TestMode.OMIT_STACKTRACES_IN_FASTTHROW_WITH_STACKFRAME) {\n+            WB.setBooleanVMFlag(\"StackFrameInFastThrow\", true);\n+        }\n+        System.out.println(\"==========================================================\");\n+        System.out.println(\"testMode=\" + testMode +\n+                           \" OmitStackTraceInFastThrow=\" + WB.getBooleanVMFlag(\"OmitStackTraceInFastThrow\") +\n+                           \" StackFrameInFastThrow=\" + WB.getBooleanVMFlag(\"StackFrameInFastThrow\"));\n+        System.out.println(\"==========================================================\");\n+    }\n+\n+    private static void printCompMode(CompMode compMode) {\n+        System.out.println(\"----------------------------------------------------------\");\n+        System.out.println(\"compMode=\" + compMode);\n+        System.out.println(\"----------------------------------------------------------\");\n+\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        if (!WB.getBooleanVMFlag(\"ProfileTraps\")) {\n+            \/\/ The fast-throw optimzation only works if we're running with -XX:+ProfileTraps\n+            return;\n+        }\n+\n+        Method level1_m = StackFrameInFastThrow.class.getDeclaredMethod(\"level1\", new Class[] { ImplicitException.class, Object[].class});\n+\n+        for (TestMode testMode : TestMode.values()) {\n+            setFlags(testMode);\n+            for (CompMode compMode : CompMode.values()) {\n+                printCompMode(compMode);\n+                for (ImplicitException impExcp : ImplicitException.values()) {\n+                    try {\n+                        level1(impExcp, impExcp == ImplicitException.NULL_POINTER_EXCEPTION ? null : string_a);\n+                    } catch (Exception catchedExcp) {\n+                        checkResult(impExcp, catchedExcp, compMode, testMode);\n+                        continue;\n+                    }\n+                    throw new Exception(\"Should not happen\");\n+                }\n+                if (compMode == CompMode.INTERPRETED) {\n+                    compile(level1_m);\n+                }\n+                if (compMode == CompMode.C2) {\n+                    recompile(level1_m);\n+                }\n+            }\n+            unload(level1_m);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/exceptions\/StackFrameInFastThrow.java","additions":250,"deletions":0,"binary":false,"changes":250,"status":"added"}]}