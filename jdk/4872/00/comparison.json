{"files":[{"patch":"@@ -577,1 +577,6 @@\n-    assert(_frame.is_compiled_frame() || _frame.is_native_frame(), \"expected compiled Java frame\");\n+    compiledVFrame* cvf;\n+    if (_frame.is_native_frame()) {\n+      cvf = compiledVFrame::cast(vframe::new_vframe(&_frame, &_reg_map, _thread));\n+      assert(cvf->cb() == cb(), \"wrong code blob\");\n+    } else {\n+      assert(_frame.is_compiled_frame(), \"expected compiled Java frame\");\n@@ -579,4 +584,4 @@\n-    \/\/ lazy update to register map\n-    bool update_map = true;\n-    RegisterMap map(_thread, update_map);\n-    frame f = _prev_frame.sender(&map);\n+      \/\/ lazy update to register map\n+      bool update_map = true;\n+      RegisterMap map(_thread, update_map);\n+      frame f = _prev_frame.sender(&map);\n@@ -584,1 +589,1 @@\n-    assert(f.is_compiled_frame() || f.is_native_frame(), \"expected compiled Java frame\");\n+      assert(f.is_compiled_frame(), \"expected compiled Java frame\");\n@@ -586,1 +591,1 @@\n-    compiledVFrame* cvf = compiledVFrame::cast(vframe::new_vframe(&f, &map, _thread));\n+      cvf = compiledVFrame::cast(vframe::new_vframe(&f, &map, _thread));\n@@ -588,1 +593,1 @@\n-    assert(cvf->cb() == cb(), \"wrong code blob\");\n+      assert(cvf->cb() == cb(), \"wrong code blob\");\n@@ -590,4 +595,0 @@\n-    if (cvf->scope() == NULL) {\n-      \/\/ native nmethods have no scope\n-      assert(f.is_native_frame(), \"expected native frame\");\n-    } else {\n","filename":"src\/hotspot\/share\/runtime\/vframe.cpp","additions":13,"deletions":12,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -28,5 +28,1 @@\n- * @requires vm.jvmci & vm.compMode == \"Xmixed\"\n- * @requires vm.opt.final.EliminateAllocations == true\n- *\n- * @comment no \"-Xcomp -XX:-TieredCompilation\" combination allowed until JDK-8140018 is resolved\n- * @requires vm.opt.TieredCompilation == null | vm.opt.TieredCompilation == true\n+ * @requires vm.jvmci\n@@ -49,1 +45,0 @@\n- *                   -XX:+DoEscapeAnalysis -XX:-UseCounterDecay\n@@ -56,1 +51,0 @@\n-import compiler.testlibrary.CompilerUtils;\n@@ -59,1 +53,1 @@\n-import jdk.vm.ci.code.stack.InspectedFrame;\n+import jdk.vm.ci.code.stack.InspectedFrameVisitor;\n@@ -63,1 +57,0 @@\n-import jtreg.SkippedException;\n@@ -71,1 +64,2 @@\n-    private static final int COMPILE_THRESHOLD;\n+    private static final Method NATIVE_METHOD;\n+    private static final Method ITERATE_FRAMES_METHOD;\n@@ -76,1 +70,0 @@\n-        Method nativeMethod;\n@@ -80,1 +73,1 @@\n-            nativeMethod = IterateFramesNative.class.getDeclaredMethod(\"callerNative\",\n+            NATIVE_METHOD = IterateFramesNative.class.getDeclaredMethod(\"callerNative\",\n@@ -84,0 +77,6 @@\n+            ITERATE_FRAMES_METHOD = CompilerToVMHelper.CompilerToVMClass().getDeclaredMethod(\n+                    \"iterateFrames\",\n+                    ResolvedJavaMethod[].class,\n+                    ResolvedJavaMethod[].class,\n+                    int.class,\n+                    InspectedFrameVisitor.class);\n@@ -87,1 +86,1 @@\n-        NATIVE_METHOD_RESOLVED = CTVMUtilities.getResolvedMethod(nativeMethod);\n+        NATIVE_METHOD_RESOLVED = CTVMUtilities.getResolvedMethod(NATIVE_METHOD);\n@@ -89,3 +88,0 @@\n-        COMPILE_THRESHOLD = WB.getBooleanVMFlag(\"TieredCompilation\")\n-                ? CompilerWhiteBoxTest.THRESHOLD\n-                : CompilerWhiteBoxTest.THRESHOLD * 2;\n@@ -97,6 +93,0 @@\n-        int levels[] = CompilerUtils.getAvailableCompilationLevels();\n-        \/\/ we need compilation level 4 to use EscapeAnalysis\n-        if (levels.length < 1 || levels[levels.length - 1] != 4) {\n-            throw new SkippedException(\"Test needs compilation level 4\");\n-        }\n-\n@@ -119,0 +109,2 @@\n+    public static native void callerNative(Runnable runnable);\n+\n@@ -120,1 +112,2 @@\n-        Helper innerHelper = new Helper(\"foo\");\n+        Helper innerHelper = new Helper(str);\n+\n@@ -125,1 +118,0 @@\n-    }\n@@ -127,1 +119,7 @@\n-    public static native void callerNative(Runnable runnable);\n+        if (iteration == CompilerWhiteBoxTest.THRESHOLD) {\n+            Asserts.assertTrue(WB.isMethodCompiled(ITERATE_FRAMES_METHOD),\n+                \"Expected native method to be compiled: \" + ITERATE_FRAMES_METHOD);\n+            Asserts.assertTrue(WB.isMethodCompiled(NATIVE_METHOD),\n+                \"Expected native method to be compiled: \" + NATIVE_METHOD);\n+        }\n+    }\n@@ -130,0 +128,13 @@\n+        HotSpotStackFrameReference initialFrame = CompilerToVMHelper.iterateFrames(\n+            null,\n+            null,\n+            0,\n+            f -> {\n+                HotSpotStackFrameReference frame = (HotSpotStackFrameReference) f;\n+                Asserts.assertNotNull(frame, \"got null frame for native method\");\n+                return frame;\n+            });\n+        Asserts.assertNotNull(initialFrame, \"frame must not be null\");\n+        Asserts.assertEQ(initialFrame.getMethod().getName(), \"iterateFrames\",\n+            \"Expected initial frame method to be CompilerToVM.iterateFrames\");\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/compilerToVM\/IterateFramesNative.java","additions":36,"deletions":25,"binary":false,"changes":61,"status":"modified"}]}