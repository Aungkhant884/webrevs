{"files":[{"patch":"@@ -577,1 +577,6 @@\n-    assert(_frame.is_compiled_frame() || _frame.is_native_frame(), \"expected compiled Java frame\");\n+    compiledVFrame* cvf;\n+    if (_frame.is_native_frame()) {\n+      cvf = compiledVFrame::cast(vframe::new_vframe(&_frame, &_reg_map, _thread));\n+      assert(cvf->cb() == cb(), \"wrong code blob\");\n+    } else {\n+      assert(_frame.is_compiled_frame(), \"expected compiled Java frame\");\n@@ -579,4 +584,4 @@\n-    \/\/ lazy update to register map\n-    bool update_map = true;\n-    RegisterMap map(_thread, update_map);\n-    frame f = _prev_frame.sender(&map);\n+      \/\/ lazy update to register map\n+      bool update_map = true;\n+      RegisterMap map(_thread, update_map);\n+      frame f = _prev_frame.sender(&map);\n@@ -584,1 +589,1 @@\n-    assert(f.is_compiled_frame() || f.is_native_frame(), \"expected compiled Java frame\");\n+      assert(f.is_compiled_frame(), \"expected compiled Java frame\");\n@@ -586,1 +591,1 @@\n-    compiledVFrame* cvf = compiledVFrame::cast(vframe::new_vframe(&f, &map, _thread));\n+      cvf = compiledVFrame::cast(vframe::new_vframe(&f, &map, _thread));\n@@ -588,1 +593,1 @@\n-    assert(cvf->cb() == cb(), \"wrong code blob\");\n+      assert(cvf->cb() == cb(), \"wrong code blob\");\n@@ -590,4 +595,0 @@\n-    if (cvf->scope() == NULL) {\n-      \/\/ native nmethods have no scope\n-      assert(f.is_native_frame(), \"expected native frame\");\n-    } else {\n","filename":"src\/hotspot\/share\/runtime\/vframe.cpp","additions":13,"deletions":12,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -28,5 +28,1 @@\n- * @requires vm.jvmci & vm.compMode == \"Xmixed\"\n- * @requires vm.opt.final.EliminateAllocations == true\n- *\n- * @comment no \"-Xcomp -XX:-TieredCompilation\" combination allowed until JDK-8140018 is resolved\n- * @requires vm.opt.TieredCompilation == null | vm.opt.TieredCompilation == true\n+ * @requires vm.jvmci\n@@ -49,1 +45,7 @@\n- *                   -XX:+DoEscapeAnalysis -XX:-UseCounterDecay\n+ *                   compiler.jvmci.compilerToVM.IterateFramesNative\n+ * @run main\/othervm -Xcomp -Xbootclasspath\/a:.\n+ *                   -XX:CompileOnly=compiler.jvmci.compilerToVM.IterateFramesNative::callerNative\n+ *                   -XX:CompileOnly=jdk.vm.ci.hotspot.CompilerToVM::iterateFrames\n+ *                   -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI\n+ *                   -Dcompiler.jvmci.compilerToVM.IterateFramesNative.checkCompiled=true\n@@ -56,1 +58,0 @@\n-import compiler.testlibrary.CompilerUtils;\n@@ -59,1 +60,1 @@\n-import jdk.vm.ci.code.stack.InspectedFrame;\n+import jdk.vm.ci.code.stack.InspectedFrameVisitor;\n@@ -63,1 +64,0 @@\n-import jtreg.SkippedException;\n@@ -71,1 +71,2 @@\n-    private static final int COMPILE_THRESHOLD;\n+    private static final Method NATIVE_METHOD;\n+    private static final Method ITERATE_FRAMES_METHOD;\n@@ -74,0 +75,1 @@\n+    private static final boolean CHECK_COMPILED;\n@@ -76,1 +78,0 @@\n-        Method nativeMethod;\n@@ -80,1 +81,1 @@\n-            nativeMethod = IterateFramesNative.class.getDeclaredMethod(\"callerNative\",\n+            NATIVE_METHOD = IterateFramesNative.class.getDeclaredMethod(\"callerNative\",\n@@ -84,0 +85,6 @@\n+            ITERATE_FRAMES_METHOD = CompilerToVMHelper.CompilerToVMClass().getDeclaredMethod(\n+                    \"iterateFrames\",\n+                    ResolvedJavaMethod[].class,\n+                    ResolvedJavaMethod[].class,\n+                    int.class,\n+                    InspectedFrameVisitor.class);\n@@ -87,1 +94,1 @@\n-        NATIVE_METHOD_RESOLVED = CTVMUtilities.getResolvedMethod(nativeMethod);\n+        NATIVE_METHOD_RESOLVED = CTVMUtilities.getResolvedMethod(NATIVE_METHOD);\n@@ -89,3 +96,2 @@\n-        COMPILE_THRESHOLD = WB.getBooleanVMFlag(\"TieredCompilation\")\n-                ? CompilerWhiteBoxTest.THRESHOLD\n-                : CompilerWhiteBoxTest.THRESHOLD * 2;\n+        CHECK_COMPILED = Boolean.getBoolean(\n+                \"compiler.jvmci.compilerToVM.IterateFramesNative.checkCompiled\");\n@@ -97,6 +103,0 @@\n-        int levels[] = CompilerUtils.getAvailableCompilationLevels();\n-        \/\/ we need compilation level 4 to use EscapeAnalysis\n-        if (levels.length < 1 || levels[levels.length - 1] != 4) {\n-            throw new SkippedException(\"Test needs compilation level 4\");\n-        }\n-\n@@ -119,0 +119,2 @@\n+    public static native void callerNative(Runnable runnable);\n+\n@@ -120,1 +122,2 @@\n-        Helper innerHelper = new Helper(\"foo\");\n+        Helper innerHelper = new Helper(str);\n+\n@@ -125,1 +128,0 @@\n-    }\n@@ -127,1 +129,7 @@\n-    public static native void callerNative(Runnable runnable);\n+        if (CHECK_COMPILED) {\n+            Asserts.assertTrue(WB.isMethodCompiled(ITERATE_FRAMES_METHOD),\n+                \"Expected native method to be compiled: \" + ITERATE_FRAMES_METHOD);\n+            Asserts.assertTrue(WB.isMethodCompiled(NATIVE_METHOD),\n+                \"Expected native method to be compiled: \" + NATIVE_METHOD);\n+        }\n+    }\n@@ -130,0 +138,13 @@\n+        HotSpotStackFrameReference initialFrame = CompilerToVMHelper.iterateFrames(\n+            null,\n+            null,\n+            0,\n+            f -> {\n+                HotSpotStackFrameReference frame = (HotSpotStackFrameReference) f;\n+                Asserts.assertNotNull(frame, \"got null frame for native method\");\n+                return frame;\n+            });\n+        Asserts.assertNotNull(initialFrame, \"frame must not be null\");\n+        Asserts.assertEQ(initialFrame.getMethod().getName(), \"iterateFrames\",\n+            \"Expected initial frame method to be CompilerToVM.iterateFrames\");\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/compilerToVM\/IterateFramesNative.java","additions":46,"deletions":25,"binary":false,"changes":71,"status":"modified"}]}