{"files":[{"patch":"@@ -87,1 +87,0 @@\n-            info = maybeReBox(info);\n@@ -90,1 +89,5 @@\n-                result = invoke(bootstrapMethod, caller, name, type);\n+                if (type instanceof Class<?> c) {\n+                    result = bootstrapMethod.invoke(caller, name, c);\n+                } else {\n+                    result = bootstrapMethod.invoke(caller, name, (MethodType)type);\n+                }\n@@ -102,1 +105,6 @@\n-                    result = invoke(bootstrapMethod, caller, name, type, info);\n+                    info = maybeReBox(info);\n+                    if (type instanceof Class<?> c) {\n+                        result = bootstrapMethod.invoke(caller, name, c, info);\n+                    } else {\n+                        result = bootstrapMethod.invoke(caller, name, (MethodType)type, info);\n+                    }\n@@ -122,1 +130,0 @@\n-                maybeReBoxElements(argv);\n@@ -136,0 +143,1 @@\n+                    maybeReBoxElements(shiftedArgs);\n@@ -138,0 +146,1 @@\n+                    maybeReBoxElements(argv);\n@@ -140,30 +149,28 @@\n-                    switch (argv.length) {\n-                        case 0:\n-                            result = invoke(bootstrapMethod, caller, name, type);\n-                            break;\n-                        case 1:\n-                            result = invoke(bootstrapMethod, caller, name, type,\n-                                            argv[0]);\n-                            break;\n-                        case 2:\n-                            result = invoke(bootstrapMethod, caller, name, type,\n-                                            argv[0], argv[1]);\n-                            break;\n-                        case 3:\n-                            result = invoke(bootstrapMethod, caller, name, type,\n-                                            argv[0], argv[1], argv[2]);\n-                            break;\n-                        case 4:\n-                            result = invoke(bootstrapMethod, caller, name, type,\n-                                            argv[0], argv[1], argv[2], argv[3]);\n-                            break;\n-                        case 5:\n-                            result = invoke(bootstrapMethod, caller, name, type,\n-                                            argv[0], argv[1], argv[2], argv[3], argv[4]);\n-                            break;\n-                        case 6:\n-                            result = invoke(bootstrapMethod, caller, name, type,\n-                                            argv[0], argv[1], argv[2], argv[3], argv[4], argv[5]);\n-                            break;\n-                        default:\n-                            result = invokeWithManyArguments(bootstrapMethod, caller, name, type, argv);\n+                    maybeReBoxElements(argv);\n+                    if (argv.length > 6) {\n+                        result = invokeWithManyArguments(bootstrapMethod, caller, name, type, argv);\n+                    } else {\n+                        if (type instanceof Class<?> c) {\n+                            result = switch (argv.length) {\n+                                case 0 -> bootstrapMethod.invoke(caller, name, c);\n+                                case 1 -> bootstrapMethod.invoke(caller, name, c, argv[0]);\n+                                case 2 -> bootstrapMethod.invoke(caller, name, c, argv[0], argv[1]);\n+                                case 3 -> bootstrapMethod.invoke(caller, name, c, argv[0], argv[1], argv[2]);\n+                                case 4 -> bootstrapMethod.invoke(caller, name, c, argv[0], argv[1], argv[2], argv[3]);\n+                                case 5 -> bootstrapMethod.invoke(caller, name, c, argv[0], argv[1], argv[2], argv[3], argv[4]);\n+                                case 6 -> bootstrapMethod.invoke(caller, name, c, argv[0], argv[1], argv[2], argv[3], argv[4], argv[5]);\n+                                default -> throw new IllegalStateException(\"Unexpected value: \" + argv.length);\n+                            };\n+                        } else {\n+                            MethodType mt = (MethodType) type;\n+                            result = switch (argv.length) {\n+                                case 0 -> bootstrapMethod.invoke(caller, name, mt);\n+                                case 1 -> bootstrapMethod.invoke(caller, name, mt, argv[0]);\n+                                case 2 -> bootstrapMethod.invoke(caller, name, mt, argv[0], argv[1]);\n+                                case 3 -> bootstrapMethod.invoke(caller, name, mt, argv[0], argv[1], argv[2]);\n+                                case 4 -> bootstrapMethod.invoke(caller, name, mt, argv[0], argv[1], argv[2], argv[3]);\n+                                case 5 -> bootstrapMethod.invoke(caller, name, mt, argv[0], argv[1], argv[2], argv[3], argv[4]);\n+                                case 6 -> bootstrapMethod.invoke(caller, name, mt, argv[0], argv[1], argv[2], argv[3], argv[4], argv[5]);\n+                                default -> throw new IllegalStateException(\"Unexpected value: \" + argv.length);\n+                            };\n+                        }\n@@ -221,70 +228,0 @@\n-    \/\/ If we don't provide static type information for type, we'll generate runtime\n-    \/\/ checks. Let's try not to...\n-\n-    private static Object invoke(MethodHandle bootstrapMethod, Lookup caller,\n-                                 String name, Object type) throws Throwable {\n-        if (type instanceof Class) {\n-            return bootstrapMethod.invoke(caller, name, (Class<?>)type);\n-        } else {\n-            return bootstrapMethod.invoke(caller, name, (MethodType)type);\n-        }\n-    }\n-\n-    private static Object invoke(MethodHandle bootstrapMethod, Lookup caller,\n-                                 String name, Object type, Object arg0) throws Throwable {\n-        if (type instanceof Class) {\n-            return bootstrapMethod.invoke(caller, name, (Class<?>)type, arg0);\n-        } else {\n-            return bootstrapMethod.invoke(caller, name, (MethodType)type, arg0);\n-        }\n-    }\n-\n-    private static Object invoke(MethodHandle bootstrapMethod, Lookup caller, String name,\n-                                 Object type, Object arg0, Object arg1) throws Throwable {\n-        if (type instanceof Class) {\n-            return bootstrapMethod.invoke(caller, name, (Class<?>)type, arg0, arg1);\n-        } else {\n-            return bootstrapMethod.invoke(caller, name, (MethodType)type, arg0, arg1);\n-        }\n-    }\n-\n-    private static Object invoke(MethodHandle bootstrapMethod, Lookup caller, String name,\n-                                 Object type, Object arg0, Object arg1,\n-                                 Object arg2) throws Throwable {\n-        if (type instanceof Class) {\n-            return bootstrapMethod.invoke(caller, name, (Class<?>)type, arg0, arg1, arg2);\n-        } else {\n-            return bootstrapMethod.invoke(caller, name, (MethodType)type, arg0, arg1, arg2);\n-        }\n-    }\n-\n-    private static Object invoke(MethodHandle bootstrapMethod, Lookup caller, String name,\n-                                 Object type, Object arg0, Object arg1,\n-                                 Object arg2, Object arg3) throws Throwable {\n-        if (type instanceof Class) {\n-            return bootstrapMethod.invoke(caller, name, (Class<?>)type, arg0, arg1, arg2, arg3);\n-        } else {\n-            return bootstrapMethod.invoke(caller, name, (MethodType)type, arg0, arg1, arg2, arg3);\n-        }\n-    }\n-\n-    private static Object invoke(MethodHandle bootstrapMethod, Lookup caller,\n-                                 String name, Object type, Object arg0, Object arg1,\n-                                 Object arg2, Object arg3, Object arg4) throws Throwable {\n-        if (type instanceof Class) {\n-            return bootstrapMethod.invoke(caller, name, (Class<?>)type, arg0, arg1, arg2, arg3, arg4);\n-        } else {\n-            return bootstrapMethod.invoke(caller, name, (MethodType)type, arg0, arg1, arg2, arg3, arg4);\n-        }\n-    }\n-\n-    private static Object invoke(MethodHandle bootstrapMethod, Lookup caller,\n-                                 String name, Object type, Object arg0, Object arg1,\n-                                 Object arg2, Object arg3, Object arg4, Object arg5) throws Throwable {\n-        if (type instanceof Class) {\n-            return bootstrapMethod.invoke(caller, name, (Class<?>)type, arg0, arg1, arg2, arg3, arg4, arg5);\n-        } else {\n-            return bootstrapMethod.invoke(caller, name, (MethodType)type, arg0, arg1, arg2, arg3, arg4, arg5);\n-        }\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/BootstrapMethodInvoker.java","additions":41,"deletions":104,"binary":false,"changes":145,"status":"modified"},{"patch":"@@ -234,1 +234,1 @@\n-            sfx = \"0\"+sfx;\n+            sfx = \"0\" + sfx;\n@@ -268,4 +268,0 @@\n-        Class<?> c = arg.getClass();\n-        while (c.isArray()) {\n-            c = c.getComponentType();\n-        }\n@@ -273,1 +269,10 @@\n-        String name = \"_DATA_\" + c.getSimpleName() + \"_\" + classData.size();\n+        String name;\n+        if (DUMP_CLASS_FILES) {\n+            Class<?> c = arg.getClass();\n+            while (c.isArray()) {\n+                c = c.getComponentType();\n+            }\n+            name = \"_DATA_\" + c.getSimpleName() + \"_\" + classData.size();\n+        } else {\n+            name = \"_D_\" + classData.size();\n+        }\n@@ -276,1 +281,1 @@\n-        return cd.name();\n+        return name;\n@@ -280,5 +285,15 @@\n-        Object[] data = new Object[classData.size()];\n-        for (int i = 0; i < classData.size(); i++) {\n-            data[i] = classData.get(i).value;\n-        }\n-        return List.of(data);\n+        final List<ClassData> cd = classData;\n+        return switch(cd.size()) {\n+            case 0 -> List.of();\n+            case 1 -> List.of(cd.get(0).value);\n+            case 2 -> List.of(cd.get(0).value, cd.get(1).value);\n+            case 3 -> List.of(cd.get(0).value, cd.get(1).value, cd.get(2).value);\n+            case 4 -> List.of(cd.get(0).value, cd.get(1).value, cd.get(2).value, cd.get(3).value);\n+            default -> {\n+                Object[] data = new Object[classData.size()];\n+                for (int i = 0; i < classData.size(); i++) {\n+                    data[i] = classData.get(i).value;\n+                }\n+                yield List.of(data);\n+            }\n+        };\n@@ -298,15 +313,0 @@\n-    \/**\n-     * Extract the number of constant pool entries from a given class file.\n-     *\n-     * @param classFile the bytes of the class file in question.\n-     * @return the number of entries in the constant pool.\n-     *\/\n-    private static int getConstantPoolSize(byte[] classFile) {\n-        \/\/ The first few bytes:\n-        \/\/ u4 magic;\n-        \/\/ u2 minor_version;\n-        \/\/ u2 major_version;\n-        \/\/ u2 constant_pool_count;\n-        return ((classFile[8] & 0xFF) << 8) | (classFile[9] & 0xFF);\n-    }\n-\n@@ -342,2 +342,2 @@\n-                CLASS_PREFIX + className, null, INVOKER_SUPER_NAME, null);\n-        cw.visitSource(SOURCE_PREFIX + className, null);\n+                CLASS_PREFIX.concat(className), null, INVOKER_SUPER_NAME, null);\n+        cw.visitSource(SOURCE_PREFIX.concat(className), null);\n@@ -361,1 +361,1 @@\n-        return CLASS_PREFIX + className;\n+        return CLASS_PREFIX.concat(className);\n@@ -668,11 +668,9 @@\n-        int opcode;\n-        switch (type) {\n-        case I_TYPE:  opcode = Opcodes.IRETURN;  break;\n-        case J_TYPE:  opcode = Opcodes.LRETURN;  break;\n-        case F_TYPE:  opcode = Opcodes.FRETURN;  break;\n-        case D_TYPE:  opcode = Opcodes.DRETURN;  break;\n-        case L_TYPE:  opcode = Opcodes.ARETURN;  break;\n-        case V_TYPE:  opcode = Opcodes.RETURN;   break;\n-        default:\n-            throw new InternalError(\"unknown return type: \" + type);\n-        }\n+        int opcode = switch (type) {\n+            case I_TYPE -> Opcodes.IRETURN;\n+            case J_TYPE -> Opcodes.LRETURN;\n+            case F_TYPE -> Opcodes.FRETURN;\n+            case D_TYPE -> Opcodes.DRETURN;\n+            case L_TYPE -> Opcodes.ARETURN;\n+            case V_TYPE -> Opcodes.RETURN;\n+            default -> throw new InternalError(\"unknown return type: \" + type);\n+        };\n@@ -725,1 +723,1 @@\n-            case GENERIC_LINKER:            return resolveFrom(name, invokerType.basicType(), Invokers.Holder.class);\n+            case GENERIC_LINKER:            return resolveFrom(name, invokerType, Invokers.Holder.class);\n@@ -1694,2 +1692,4 @@\n-        } else if ((arg == null || arg instanceof String) && bptype == L_TYPE) {\n-            emitConst(arg);\n+        } else if (arg == null && bptype == L_TYPE) {\n+            mv.visitInsn(Opcodes.ACONST_NULL);\n+        } else if (arg instanceof String && bptype == L_TYPE) {\n+            mv.visitLdcInsn(arg);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/InvokerBytecodeGenerator.java","additions":44,"deletions":44,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -215,20 +215,0 @@\n-        static BasicType[] basicTypes(String types) {\n-            BasicType[] btypes = new BasicType[types.length()];\n-            for (int i = 0; i < btypes.length; i++) {\n-                btypes[i] = basicType(types.charAt(i));\n-            }\n-            return btypes;\n-        }\n-        static String basicTypeDesc(BasicType[] types) {\n-            if (types == null) {\n-                return null;\n-            }\n-            if (types.length == 0) {\n-                return \"\";\n-            }\n-            StringBuilder sb = new StringBuilder();\n-            for (BasicType bt : types) {\n-                sb.append(bt.basicTypeChar());\n-            }\n-            return sb.toString();\n-        }\n@@ -391,3 +371,0 @@\n-    LambdaForm(int arity, Name[] names, boolean forceInline) {\n-        this(arity, names, LAST_RESULT, forceInline, \/*customized=*\/null, Kind.GENERIC);\n-    }\n@@ -397,6 +374,0 @@\n-    LambdaForm(Name[] formals, Name[] temps, Name result) {\n-        this(formals.length, buildNames(formals, temps, result), LAST_RESULT, \/*forceInline=*\/true, \/*customized=*\/null);\n-    }\n-    LambdaForm(Name[] formals, Name[] temps, Name result, boolean forceInline) {\n-        this(formals.length, buildNames(formals, temps, result), LAST_RESULT, forceInline, \/*customized=*\/null);\n-    }\n@@ -632,1 +603,0 @@\n-        assert(n < arity);\n@@ -634,1 +604,1 @@\n-        assert(param.isParam());\n+        assert(n < arity && param.isParam());\n@@ -673,3 +643,0 @@\n-    static BasicType signatureReturn(String sig) {\n-        return basicType(sig.charAt(signatureArity(sig) + 1));\n-    }\n@@ -690,10 +657,0 @@\n-    static MethodType signatureType(String sig) {\n-        Class<?>[] ptypes = new Class<?>[signatureArity(sig)];\n-        for (int i = 0; i < ptypes.length; i++)\n-            ptypes[i] = basicType(sig.charAt(i)).btClass;\n-        Class<?> rtype = signatureReturn(sig).btClass;\n-        return MethodType.makeImpl(rtype, ptypes, true);\n-    }\n-    static MethodType basicMethodType(MethodType mt) {\n-        return signatureType(basicTypeSignature(mt));\n-    }\n@@ -1330,1 +1287,1 @@\n-                    buf.append(signature.substring(i - c1reps, len));\n+                    buf.append(signature, i - c1reps, len);\n@@ -1413,5 +1370,0 @@\n-        void resolve() {\n-            if (function != null)\n-                function.resolve();\n-        }\n-\n@@ -1609,4 +1561,0 @@\n-        boolean contains(Name n) {\n-            return this == n || lastUseIndex(n) >= 0;\n-        }\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/LambdaForm.java","additions":2,"deletions":54,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -202,8 +202,0 @@\n-    private static void checkRtype(Class<?> rtype) {\n-        Objects.requireNonNull(rtype);\n-    }\n-    private static void checkPtype(Class<?> ptype) {\n-        Objects.requireNonNull(ptype);\n-        if (ptype == void.class)\n-            throw newIllegalArgumentException(\"parameter type cannot be void\");\n-    }\n@@ -214,1 +206,3 @@\n-            checkPtype(ptype);\n+            Objects.requireNonNull(ptype);\n+            if (ptype == void.class)\n+                throw newIllegalArgumentException(\"parameter type cannot be void\");\n@@ -348,1 +342,1 @@\n-        MethodType.checkRtype(rtype);\n+        Objects.requireNonNull(rtype);\n@@ -418,1 +412,0 @@\n-        checkPtype(nptype);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodType.java","additions":4,"deletions":11,"binary":false,"changes":15,"status":"modified"}]}