{"files":[{"patch":"@@ -256,1 +256,1 @@\n-            \/* The thread better not be on runningThreads if the TLS lookup failed. *\/\n+            \/* The thread better not be on either list if the TLS lookup failed. *\/\n@@ -258,0 +258,1 @@\n+            JDI_ASSERT(!nonTlsSearch(getEnv(), &runningVThreads, thread));\n@@ -260,2 +261,3 @@\n-             * Search the runningThreads list. The TLS lookup may have failed because the\n-             * thread has terminated, but we never got the THREAD_END event.\n+             * Search the runningThreads and runningVThreads lists. The TLS lookup may have\n+             * failed because the thread has terminated, but we never got the THREAD_END event.\n+             * The big comment above explains why this can happen.\n@@ -267,0 +269,5 @@\n+                if ( node == NULL ) {\n+                    if ( list == NULL || list == &runningVThreads ) {\n+                        node = nonTlsSearch(getEnv(), &runningVThreads, thread);\n+                    }\n+                }\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/threadControl.c","additions":10,"deletions":3,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -713,0 +713,19 @@\n+\n+        \/\/ Make sure debuggee exits with no errors. Otherwise failures might go unnoticed.\n+        Process p = vm.process();\n+        try {\n+            p.waitFor(5, java.util.concurrent.TimeUnit.SECONDS);\n+        } catch (InterruptedException e) {\n+            throw new RuntimeException(e);\n+        }\n+        if (p.isAlive()) {\n+            throw new RuntimeException(\"Debuggee is still alive after disconnecting.\");\n+        } else {\n+            int res = p.exitValue();\n+            \/\/ Some tests purposefully exit with an exception, which produces exitValue\n+            \/\/ 1, so we have to allow it also.\n+            if (res != 0 && res != 1) {\n+                throw new RuntimeException(\"Non-zero debuggee exitValue: \" + res);\n+            }\n+        }\n+\n","filename":"test\/jdk\/com\/sun\/jdi\/TestScaffold.java","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -61,1 +61,1 @@\n-            Executors.defaultThreadFactory().newThread(() -> {\n+            TestScaffold.newThread(() -> {\n@@ -68,1 +68,10 @@\n-                        Thread.sleep(50);\n+                        String mainWrapper = System.getProperty(\"main.wrapper\");\n+                        if (\"Virtual\".equals(mainWrapper)) {\n+                            \/\/ Virtual thread creation tends to overwhelm the debugger,\n+                            \/\/ leading to high memory use for all the unprocessed events\n+                            \/\/ that get queued up, so we need to slow it down a bit more\n+                            \/\/ than we do for platform threads to avoid getting OOME.\n+                            Thread.sleep(100);\n+                        } else {\n+                            Thread.sleep(50);\n+                        }\n","filename":"test\/jdk\/com\/sun\/jdi\/ThreadMemoryLeakTest.java","additions":11,"deletions":2,"binary":false,"changes":13,"status":"modified"}]}