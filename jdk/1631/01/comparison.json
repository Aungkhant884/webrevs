{"files":[{"patch":"@@ -4930,2 +4930,2 @@\n-\/\/ clear memory of size 'cnt' qwords, starting at 'base' using XMM\/YMM registers\n-void MacroAssembler::xmm_clear_mem(Register base, Register cnt, XMMRegister xtmp) {\n+\/\/ clear memory of size 'cnt' qwords, starting at 'base' using XMM\/YMM\/ZMM registers\n+void MacroAssembler::xmm_clear_mem(Register base, Register cnt, Register rtmp, XMMRegister xtmp) {\n@@ -4935,1 +4935,4 @@\n-  if (UseAVX >= 2) {\n+  bool use64byteVector = UseAVX> 2 && MaxVectorSize > 32 && AVX3Threshold == 0;\n+  if (use64byteVector) {\n+    vpxor(xtmp, xtmp, xtmp, AVX_512bit);\n+  } else if (UseAVX > 0) {\n@@ -4943,3 +4946,2 @@\n-  if (UseAVX >= 2) {\n-    vmovdqu(Address(base,  0), xtmp);\n-    vmovdqu(Address(base, 32), xtmp);\n+  if (UseAVX > 0) {\n+    fill64_avx(base,  0, xtmp, use64byteVector);\n@@ -4957,8 +4959,16 @@\n-  addptr(cnt, 4);\n-  jccb(Assembler::less, L_tail);\n-  \/\/ Copy trailing 32 bytes\n-  if (UseAVX >= 2) {\n-    vmovdqu(Address(base, 0), xtmp);\n-  } else {\n-    movdqu(Address(base,  0), xtmp);\n-    movdqu(Address(base, 16), xtmp);\n+\n+  \/\/ Copy trailing 64 bytes\n+  if (use64byteVector) {\n+    addptr(cnt, 8);\n+    jccb(Assembler::equal, L_end);\n+    fill64_masked_avx(3, base, 0, xtmp, k2, cnt, rtmp, true);\n+    jmp(L_end);\n+  } else {\n+    addptr(cnt, 4);\n+    jccb(Assembler::less, L_tail);\n+    if (UseAVX > 0) {\n+      vmovdqu(Address(base, 0), xtmp);\n+    } else {\n+      movdqu(Address(base,  0), xtmp);\n+      movdqu(Address(base, 16), xtmp);\n+    }\n@@ -4972,1 +4982,4 @@\n-  decrement(cnt);\n+  if (UseAVX > 2 && VM_Version::supports_avx512vl()) {\n+    fill32_masked_avx(3, base, 0, xtmp, k2, cnt, rtmp);\n+  } else {\n+    decrement(cnt);\n@@ -4974,5 +4987,6 @@\n-  BIND(L_sloop);\n-  movq(Address(base, 0), xtmp);\n-  addptr(base, 8);\n-  decrement(cnt);\n-  jccb(Assembler::greaterEqual, L_sloop);\n+    BIND(L_sloop);\n+    movq(Address(base, 0), xtmp);\n+    addptr(base, 8);\n+    decrement(cnt);\n+    jccb(Assembler::greaterEqual, L_sloop);\n+  }\n@@ -4982,0 +4996,71 @@\n+\/\/ Clearing constant sized memory using YMM\/ZMM registers.\n+void MacroAssembler::clear_mem(Register base, int cnt, Register rtmp, XMMRegister xtmp) {\n+  assert(UseAVX > 2 && VM_Version::supports_avx512vlbw(), \"\");\n+  bool use64byteVector = MaxVectorSize > 32 && AVX3Threshold == 0;\n+\n+  int vector64_count = (cnt & (~0x7)) >> 3;\n+  cnt = cnt & 0x7;\n+\n+  \/\/ 64 byte initialization loop.\n+  vpxor(xtmp, xtmp, xtmp, use64byteVector ? AVX_512bit : AVX_256bit);\n+  for (int i = 0; i < vector64_count; i++) {\n+    fill64_avx(base, i * 64, xtmp, use64byteVector);\n+  }\n+\n+  \/\/ Clear remaining 64 byte tail.\n+  int disp = vector64_count * 64;\n+  if (cnt) {\n+    switch (cnt) {\n+      case 7:\n+        if (use64byteVector) {\n+          movl(rtmp, 0x7F);\n+          kmovwl(k2, rtmp);\n+          evmovdqu(T_LONG, k2, Address(base, disp), xtmp, Assembler::AVX_512bit);\n+        } else {\n+          evmovdqu(T_LONG, k0, Address(base, disp), xtmp, Assembler::AVX_256bit);\n+          movl(rtmp, 0x7);\n+          kmovwl(k2, rtmp);\n+          evmovdqu(T_LONG, k2, Address(base, disp + 32), xtmp, Assembler::AVX_256bit);\n+        }\n+        break;\n+      case 6:\n+        if (use64byteVector) {\n+          movl(rtmp, 0x3F);\n+          kmovwl(k2, rtmp);\n+          evmovdqu(T_LONG, k2, Address(base, disp), xtmp, Assembler::AVX_512bit);\n+        } else {\n+          evmovdqu(T_LONG, k0, Address(base, disp), xtmp, Assembler::AVX_256bit);\n+          evmovdqu(T_LONG, k0, Address(base, disp + 32), xtmp, Assembler::AVX_128bit);\n+        }\n+        break;\n+      case 5:\n+        if (use64byteVector) {\n+          movl(rtmp, 0x1F);\n+          kmovwl(k2, rtmp);\n+          evmovdqu(T_LONG, k2, Address(base, disp), xtmp, Assembler::AVX_512bit);\n+        } else {\n+          evmovdqu(T_LONG, k0, Address(base, disp), xtmp, Assembler::AVX_256bit);\n+          movq(Address(base, disp + 32), xtmp);\n+        }\n+        break;\n+      case 4:\n+        evmovdqu(T_LONG, k0, Address(base, disp), xtmp, Assembler::AVX_256bit);\n+        break;\n+      case 3:\n+        movl(rtmp, 0x7);\n+        kmovwl(k2, rtmp);\n+        evmovdqu(T_LONG, k2, Address(base, disp), xtmp, Assembler::AVX_256bit);\n+        break;\n+      case 2:\n+        evmovdqu(T_LONG, k0, Address(base, disp), xtmp, Assembler::AVX_128bit);\n+        break;\n+      case 1:\n+        movq(Address(base, disp), xtmp);\n+        break;\n+      default:\n+        fatal(\"Unexpected length : %d\\n\",cnt);\n+        break;\n+    }\n+  }\n+}\n+\n@@ -4983,2 +5068,2 @@\n-  \/\/ cnt - number of qwords (8-byte words).\n-  \/\/ base - start address, qword aligned.\n+  \/\/ cnt      - number of qwords (8-byte words).\n+  \/\/ base     - start address, qword aligned.\n@@ -4993,1 +5078,0 @@\n-\n@@ -5023,2 +5107,1 @@\n-    movptr(tmp, base);\n-    xmm_clear_mem(tmp, cnt, xtmp);\n+    xmm_clear_mem(base, cnt, tmp, xtmp);\n@@ -8052,0 +8135,52 @@\n+\/\/ Set memory operation for length \"less than\" 64 bytes.\n+void MacroAssembler::fill64_masked_avx(uint shift, Register dst, int disp,\n+                                       XMMRegister xmm, KRegister mask, Register length,\n+                                       Register temp, bool use64byteVector) {\n+  assert(MaxVectorSize >= 32, \"vector length should be >= 32\");\n+  assert(shift != 0, \"shift value should be 1 (short),2(int) or 3(long)\");\n+  BasicType type[] = { T_BYTE, T_SHORT,  T_INT,   T_LONG};\n+  if (!use64byteVector) {\n+    fill32_avx(dst, disp, xmm);\n+    subptr(length, 32 >> shift);\n+    fill32_masked_avx(shift, dst, disp + 32, xmm, mask, length, temp);\n+  } else {\n+    assert(MaxVectorSize == 64, \"vector length != 64\");\n+    movl(temp, 1);\n+    shlxl(temp, temp, length);\n+    subptr(temp, 1);\n+    kmovwl(mask, temp);\n+    evmovdqu(type[shift], mask, Address(dst, disp), xmm, Assembler::AVX_512bit);\n+  }\n+}\n+\n+\n+void MacroAssembler::fill32_masked_avx(uint shift, Register dst, int disp,\n+                                       XMMRegister xmm, KRegister mask, Register length,\n+                                       Register temp) {\n+  assert(MaxVectorSize >= 32, \"vector length should be >= 32\");\n+  assert(shift != 0, \"shift value should be 1 (short), 2(int) or 3(long)\");\n+  BasicType type[] = { T_BYTE, T_SHORT,  T_INT,   T_LONG};\n+  movl(temp, 1);\n+  shlxl(temp, temp, length);\n+  subptr(temp, 1);\n+  kmovwl(mask, temp);\n+  evmovdqu(type[shift], mask, Address(dst, disp), xmm, Assembler::AVX_256bit);\n+}\n+\n+\n+void MacroAssembler::fill32_avx(Register dst, int disp, XMMRegister xmm) {\n+  assert(MaxVectorSize >= 32, \"vector length should be >= 32\");\n+  vmovdqu(Address(dst, disp), xmm);\n+}\n+\n+\n+void MacroAssembler::fill64_avx(Register dst, int disp, XMMRegister xmm, bool use64byteVector) {\n+  assert(MaxVectorSize >= 32, \"vector length should be >= 32\");\n+  BasicType type[] = {T_BYTE,  T_SHORT,  T_INT,   T_LONG};\n+  if (!use64byteVector) {\n+    fill32_avx(dst, disp, xmm);\n+    fill32_avx(dst, disp + 32, xmm);\n+  } else {\n+    evmovdquq(Address(dst, disp), xmm, Assembler::AVX_512bit);\n+  }\n+}\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":160,"deletions":25,"binary":false,"changes":185,"status":"modified"},{"patch":"@@ -1683,0 +1683,3 @@\n+  \/\/ clear memory initialization sequence for constant size;\n+  void clear_mem(Register base, int cnt, Register rtmp, XMMRegister xtmp);\n+\n@@ -1684,1 +1687,1 @@\n-  void xmm_clear_mem(Register base, Register cnt, XMMRegister xtmp);\n+  void xmm_clear_mem(Register base, Register cnt, Register rtmp, XMMRegister xtmp);\n@@ -1803,0 +1806,12 @@\n+  void fill64_masked_avx(uint shift, Register dst, int disp,\n+                         XMMRegister xmm, KRegister mask, Register length,\n+                         Register temp, bool use64byteVector = false);\n+\n+  void fill32_masked_avx(uint shift, Register dst, int disp,\n+                         XMMRegister xmm, KRegister mask, Register length,\n+                         Register temp);\n+\n+  void fill32_avx(Register dst, int disp, XMMRegister xmm);\n+\n+  void fill64_avx(Register dst, int dis, XMMRegister xmm, bool use64byteVector = false);\n+\n@@ -1838,0 +1853,2 @@\n+\n+\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":18,"deletions":1,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -251,0 +251,1 @@\n+\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86_arrayCopy_avx3.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1604,0 +1604,1 @@\n+    case Op_ClearArray:\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -11442,1 +11442,1 @@\n-  predicate(!((ClearArrayNode*)n)->is_large());\n+  predicate(!((ClearArrayNode*)n)->is_large() && !n->in(2)->bottom_type()->is_int()->is_con());\n@@ -11549,0 +11549,12 @@\n+instruct rep_stos_im(immI cnt, eRegP base, regD tmp, rRegI zero, Universe dummy, eFlagsReg cr)\n+%{\n+  predicate(!((ClearArrayNode*)n)->is_large() && n->in(2)->bottom_type()->is_int()->is_con());\n+  match(Set dummy (ClearArray cnt base));\n+  effect(TEMP tmp,TEMP zero,  KILL cr);\n+  format %{ \"clear_mem_imm $base , $cnt  \\n\\t\" %}\n+  ins_encode %{\n+   __ clear_mem($base$$Register, $cnt$$constant, $zero$$Register, $tmp$$XMMRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/x86\/x86_32.ad","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -10750,1 +10750,1 @@\n-  predicate(!((ClearArrayNode*)n)->is_large());\n+  predicate(!((ClearArrayNode*)n)->is_large() && !n->in(2)->bottom_type()->is_long()->is_con());\n@@ -10856,0 +10856,12 @@\n+instruct rep_stos_im(immL cnt, rRegP base, regD tmp, rRegI zero, Universe dummy, rFlagsReg cr)\n+%{\n+  predicate(!((ClearArrayNode*)n)->is_large() && n->in(2)->bottom_type()->is_long()->is_con());\n+  match(Set dummy (ClearArray cnt base));\n+  effect(TEMP tmp,TEMP zero,  KILL cr);\n+  format %{ \"clear_mem_imm $base , $cnt  \\n\\t\" %}\n+  ins_encode %{\n+   __ clear_mem($base$$Register, $cnt$$constant, $zero$$Register, $tmp$$XMMRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -3055,0 +3055,2 @@\n+  } else if (size > 2 && Matcher::match_rule_supported_vector(Op_ClearArray, 4, T_LONG)) {\n+    return NULL;\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,148 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.vm.compiler;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Fork;\n+\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+@Fork(jvmArgsPrepend = {\"-XX:-EliminateAllocations\", \"-XX:-DoEscapeAnalysis\"})\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.SECONDS)\n+@State(Scope.Thread)\n+public class ClearMemory {\n+  class Payload7 {\n+    public long f0;\n+    public long f1;\n+    public long f2;\n+    public long f3;\n+    public long f4;\n+    public long f5;\n+    public long f6;\n+\n+    public Payload7() {\n+      this.f0 = 1;\n+    }\n+  }\n+\n+  class Payload6 {\n+    public long f0;\n+    public long f1;\n+    public long f2;\n+    public long f3;\n+    public long f4;\n+    public long f5;\n+\n+    public Payload6() {\n+      this.f0 = 1;\n+    }\n+  }\n+\n+  class Payload5 {\n+    public long f0;\n+    public long f1;\n+    public long f2;\n+    public long f3;\n+    public long f4;\n+\n+    public Payload5() {\n+      this.f0 = 1;\n+    }\n+  }\n+\n+  class Payload4 {\n+    public long f0;\n+    public long f1;\n+    public long f2;\n+    public long f3;\n+\n+    public Payload4() {\n+      this.f0 = 1;\n+    }\n+  }\n+\n+  class Payload3 {\n+    public long f0;\n+    public long f1;\n+    public long f2;\n+\n+    public Payload3() {\n+      this.f0 = 1;\n+    }\n+  }\n+\n+  @Setup\n+  public void Setup() {\n+  }\n+\n+  @Benchmark\n+  public void testClearMemory7(Blackhole bh)  {\n+    Payload7 [] objs = new Payload7[1000];\n+    for(int i = 0 ; i < objs.length ; i++) {\n+      objs[i] = new Payload7();\n+    }\n+    bh.consume(objs);\n+  }\n+  @Benchmark\n+  public void testClearMemory6(Blackhole bh)  {\n+    Payload6 [] objs = new Payload6[1000];\n+    for(int i = 0 ; i < objs.length ; i++) {\n+      objs[i] = new Payload6();\n+    }\n+    bh.consume(objs);\n+  }\n+  @Benchmark\n+  public void testClearMemory5(Blackhole bh)  {\n+    Payload5 [] objs = new Payload5[1000];\n+    for(int i = 0 ; i < objs.length ; i++) {\n+      objs[i] = new Payload5();\n+    }\n+    bh.consume(objs);\n+  }\n+  @Benchmark\n+  public void testClearMemory4(Blackhole bh)  {\n+    Payload4 [] objs = new Payload4[1000];\n+    for(int i = 0 ; i < objs.length ; i++) {\n+      objs[i] = new Payload4();\n+    }\n+    bh.consume(objs);\n+  }\n+  @Benchmark\n+  public void testClearMemory3(Blackhole bh)  {\n+    Payload3 [] objs = new Payload3[1000];\n+    for(int i = 0 ; i < objs.length ; i++) {\n+      objs[i] = new Payload3();\n+    }\n+    bh.consume(objs);\n+  }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/ClearMemory.java","additions":148,"deletions":0,"binary":false,"changes":148,"status":"added"}]}