{"files":[{"patch":"@@ -1085,0 +1085,79 @@\n+\/\/ Ideal transformations for MaxINode\n+Node* MaxINode::Ideal(PhaseGVN* phase, bool can_reshape) {\n+  \/\/ Force a right-spline graph\n+  Node* l = in(1);\n+  Node* r = in(2);\n+  \/\/ Transform  MaxI1(MaxI2(a,b), c)  into  MaxI1(a, MaxI2(b,c))\n+  \/\/ to force a right-spline graph for the rest of MaxINode::Ideal().\n+  if(l->Opcode() == Op_MaxI) {\n+    assert(l != l->in(1), \"dead loop in MaxINode::Ideal\");\n+    r = phase->transform(new MaxINode(l->in(2), r));\n+    l = l->in(1);\n+    set_req_X(1, l, phase);\n+    set_req_X(2, r, phase);\n+    return this;\n+  }\n+\n+  \/\/ Get left input & constant\n+  Node* x = l;\n+  jint x_off = 0;\n+  if(x->Opcode() == Op_AddI && \/\/ Check for \"x+c0\" and collect constant\n+      x->in(2)->is_Con()) {\n+    const Type* t = x->in(2)->bottom_type();\n+    if(t == Type::TOP) return NULL;  \/\/ No progress\n+    x_off = t->is_int()->get_con();\n+    x = x->in(1);\n+  }\n+\n+  \/\/ Scan a right-spline-tree for MAXs\n+  Node* y = r;\n+  jint y_off = 0;\n+  \/\/ Check final part of MAX tree\n+  if(y->Opcode() == Op_AddI && \/\/ Check for \"y+c1\" and collect constant\n+      y->in(2)->is_Con()) {\n+    const Type* t = y->in(2)->bottom_type();\n+    if(t == Type::TOP) return NULL;  \/\/ No progress\n+    y_off = t->is_int()->get_con();\n+    y = y->in(1);\n+  }\n+  if(x->_idx > y->_idx && r->Opcode() != Op_MaxI) {\n+    swap_edges(1, 2);\n+    return this;\n+  }\n+\n+  const TypeInt* tx = phase->type(x)->isa_int();\n+\n+  if(r->Opcode() == Op_MaxI) {\n+    assert(r != r->in(2), \"dead loop in MaxINode::Ideal\");\n+    y = r->in(1);\n+    \/\/ Check final part of MAX tree\n+    if(y->Opcode() == Op_AddI &&\/\/ Check for \"y+c1\" and collect constant\n+        y->in(2)->is_Con()) {\n+      const Type* t = y->in(2)->bottom_type();\n+      if(t == Type::TOP) return NULL;  \/\/ No progress\n+      y_off = t->is_int()->get_con();\n+      y = y->in(1);\n+    }\n+\n+    if(x->_idx > y->_idx)\n+      return new MaxINode(r->in(1), phase->transform(new MaxINode(l, r->in(2))));\n+\n+    \/\/ Transform MAX2(x + c0, MAX2(x + c1, z)) into MAX2(x + MAX2(c0, c1), z)\n+    \/\/ if x == y and the additions can't overflow.\n+    if (x == y && tx != NULL &&\n+        !can_overflow(tx, x_off) &&\n+        !can_overflow(tx, y_off)) {\n+      return new MaxINode(phase->transform(new AddINode(x, phase->intcon(MAX2(x_off, y_off)))), r->in(2));\n+    }\n+  } else {\n+    \/\/ Transform MAX2(x + c0, y + c1) into x + MAX2(c0, c1)\n+    \/\/ if x == y and the additions can't overflow.\n+    if (x == y && tx != NULL &&\n+        !can_overflow(tx, x_off) &&\n+        !can_overflow(tx, y_off)) {\n+      return new AddINode(x, phase->intcon(MAX2(x_off, y_off)));\n+    }\n+  }\n+ return NULL;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/addnode.cpp","additions":79,"deletions":0,"binary":false,"changes":79,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -302,0 +302,1 @@\n+  virtual Node* Ideal(PhaseGVN* phase, bool can_reshape);\n","filename":"src\/hotspot\/share\/opto\/addnode.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1840,8 +1840,0 @@\n-static bool is_simple_name(Node* n) {\n-  return (n->req() == 1         \/\/ constant\n-          || (n->is_Type() && n->as_Type()->type()->singleton())\n-          || n->is_Proj()       \/\/ parameter or return value\n-          || n->is_Phi()        \/\/ local of some sort\n-          );\n-}\n-\n@@ -1946,164 +1938,1 @@\n-  \/\/ These are the candidate return value:\n-  Node* xvalue = x0;\n-  Node* yvalue = y0;\n-\n-  if (xvalue == yvalue) {\n-    return xvalue;\n-  }\n-\n-  bool want_max = (id == vmIntrinsics::_max || id == vmIntrinsics::_max_strict);\n-\n-  const TypeInt* txvalue = _gvn.type(xvalue)->isa_int();\n-  const TypeInt* tyvalue = _gvn.type(yvalue)->isa_int();\n-  if (txvalue == NULL || tyvalue == NULL)  return top();\n-  \/\/ This is not really necessary, but it is consistent with a\n-  \/\/ hypothetical MaxINode::Value method:\n-  int widen = MAX2(txvalue->_widen, tyvalue->_widen);\n-\n-  \/\/ %%% This folding logic should (ideally) be in a different place.\n-  \/\/ Some should be inside IfNode, and there to be a more reliable\n-  \/\/ transformation of ?: style patterns into cmoves.  We also want\n-  \/\/ more powerful optimizations around cmove and min\/max.\n-\n-  \/\/ Try to find a dominating comparison of these guys.\n-  \/\/ It can simplify the index computation for Arrays.copyOf\n-  \/\/ and similar uses of System.arraycopy.\n-  \/\/ First, compute the normalized version of CmpI(x, y).\n-  int   cmp_op = Op_CmpI;\n-  Node* xkey = xvalue;\n-  Node* ykey = yvalue;\n-  Node* ideal_cmpxy = _gvn.transform(new CmpINode(xkey, ykey));\n-  if (ideal_cmpxy->is_Cmp()) {\n-    \/\/ E.g., if we have CmpI(length - offset, count),\n-    \/\/ it might idealize to CmpI(length, count + offset)\n-    cmp_op = ideal_cmpxy->Opcode();\n-    xkey = ideal_cmpxy->in(1);\n-    ykey = ideal_cmpxy->in(2);\n-  }\n-\n-  \/\/ Start by locating any relevant comparisons.\n-  Node* start_from = (xkey->outcnt() < ykey->outcnt()) ? xkey : ykey;\n-  Node* cmpxy = NULL;\n-  Node* cmpyx = NULL;\n-  for (DUIterator_Fast kmax, k = start_from->fast_outs(kmax); k < kmax; k++) {\n-    Node* cmp = start_from->fast_out(k);\n-    if (cmp->outcnt() > 0 &&            \/\/ must have prior uses\n-        cmp->in(0) == NULL &&           \/\/ must be context-independent\n-        cmp->Opcode() == cmp_op) {      \/\/ right kind of compare\n-      if (cmp->in(1) == xkey && cmp->in(2) == ykey)  cmpxy = cmp;\n-      if (cmp->in(1) == ykey && cmp->in(2) == xkey)  cmpyx = cmp;\n-    }\n-  }\n-\n-  const int NCMPS = 2;\n-  Node* cmps[NCMPS] = { cmpxy, cmpyx };\n-  int cmpn;\n-  for (cmpn = 0; cmpn < NCMPS; cmpn++) {\n-    if (cmps[cmpn] != NULL)  break;     \/\/ find a result\n-  }\n-  if (cmpn < NCMPS) {\n-    \/\/ Look for a dominating test that tells us the min and max.\n-    int depth = 0;                \/\/ Limit search depth for speed\n-    Node* dom = control();\n-    for (; dom != NULL; dom = IfNode::up_one_dom(dom, true)) {\n-      if (++depth >= 100)  break;\n-      Node* ifproj = dom;\n-      if (!ifproj->is_Proj())  continue;\n-      Node* iff = ifproj->in(0);\n-      if (!iff->is_If())  continue;\n-      Node* bol = iff->in(1);\n-      if (!bol->is_Bool())  continue;\n-      Node* cmp = bol->in(1);\n-      if (cmp == NULL)  continue;\n-      for (cmpn = 0; cmpn < NCMPS; cmpn++)\n-        if (cmps[cmpn] == cmp)  break;\n-      if (cmpn == NCMPS)  continue;\n-      BoolTest::mask btest = bol->as_Bool()->_test._test;\n-      if (ifproj->is_IfFalse())  btest = BoolTest(btest).negate();\n-      if (cmp->in(1) == ykey)    btest = BoolTest(btest).commute();\n-      \/\/ At this point, we know that 'x btest y' is true.\n-      switch (btest) {\n-      case BoolTest::eq:\n-        \/\/ They are proven equal, so we can collapse the min\/max.\n-        \/\/ Either value is the answer.  Choose the simpler.\n-        if (is_simple_name(yvalue) && !is_simple_name(xvalue))\n-          return yvalue;\n-        return xvalue;\n-      case BoolTest::lt:          \/\/ x < y\n-      case BoolTest::le:          \/\/ x <= y\n-        return (want_max ? yvalue : xvalue);\n-      case BoolTest::gt:          \/\/ x > y\n-      case BoolTest::ge:          \/\/ x >= y\n-        return (want_max ? xvalue : yvalue);\n-      default:\n-        break;\n-      }\n-    }\n-  }\n-\n-  \/\/ We failed to find a dominating test.\n-  \/\/ Let's pick a test that might GVN with prior tests.\n-  Node*          best_bol   = NULL;\n-  BoolTest::mask best_btest = BoolTest::illegal;\n-  for (cmpn = 0; cmpn < NCMPS; cmpn++) {\n-    Node* cmp = cmps[cmpn];\n-    if (cmp == NULL)  continue;\n-    for (DUIterator_Fast jmax, j = cmp->fast_outs(jmax); j < jmax; j++) {\n-      Node* bol = cmp->fast_out(j);\n-      if (!bol->is_Bool())  continue;\n-      BoolTest::mask btest = bol->as_Bool()->_test._test;\n-      if (btest == BoolTest::eq || btest == BoolTest::ne)  continue;\n-      if (cmp->in(1) == ykey)   btest = BoolTest(btest).commute();\n-      if (bol->outcnt() > (best_bol == NULL ? 0 : best_bol->outcnt())) {\n-        best_bol   = bol->as_Bool();\n-        best_btest = btest;\n-      }\n-    }\n-  }\n-\n-  Node* answer_if_true  = NULL;\n-  Node* answer_if_false = NULL;\n-  switch (best_btest) {\n-  default:\n-    if (cmpxy == NULL)\n-      cmpxy = ideal_cmpxy;\n-    best_bol = _gvn.transform(new BoolNode(cmpxy, BoolTest::lt));\n-    \/\/ and fall through:\n-  case BoolTest::lt:          \/\/ x < y\n-  case BoolTest::le:          \/\/ x <= y\n-    answer_if_true  = (want_max ? yvalue : xvalue);\n-    answer_if_false = (want_max ? xvalue : yvalue);\n-    break;\n-  case BoolTest::gt:          \/\/ x > y\n-  case BoolTest::ge:          \/\/ x >= y\n-    answer_if_true  = (want_max ? xvalue : yvalue);\n-    answer_if_false = (want_max ? yvalue : xvalue);\n-    break;\n-  }\n-\n-  jint hi, lo;\n-  if (want_max) {\n-    \/\/ We can sharpen the minimum.\n-    hi = MAX2(txvalue->_hi, tyvalue->_hi);\n-    lo = MAX2(txvalue->_lo, tyvalue->_lo);\n-  } else {\n-    \/\/ We can sharpen the maximum.\n-    hi = MIN2(txvalue->_hi, tyvalue->_hi);\n-    lo = MIN2(txvalue->_lo, tyvalue->_lo);\n-  }\n-\n-  \/\/ Use a flow-free graph structure, to avoid creating excess control edges\n-  \/\/ which could hinder other optimizations.\n-  \/\/ Since Math.min\/max is often used with arraycopy, we want\n-  \/\/ tightly_coupled_allocation to be able to see beyond min\/max expressions.\n-  Node* cmov = CMoveNode::make(NULL, best_bol,\n-                               answer_if_false, answer_if_true,\n-                               TypeInt::make(lo, hi, widen));\n-\n-  return _gvn.transform(cmov);\n-\n-  \/*\n-  \/\/ This is not as desirable as it may seem, since Min and Max\n-  \/\/ nodes do not have a full set of optimizations.\n-  \/\/ And they would interfere, anyway, with 'if' optimizations\n-  \/\/ and with CMoveI canonical forms.\n+  Node* result_val = NULL;\n@@ -2112,1 +1941,3 @@\n-    result_val = _gvn.transform(new (C, 3) MinINode(x,y)); break;\n+  case vmIntrinsics::_min_strict:\n+    result_val = _gvn.transform(new MinINode(x0, y0));\n+    break;\n@@ -2114,1 +1945,3 @@\n-    result_val = _gvn.transform(new (C, 3) MaxINode(x,y)); break;\n+  case vmIntrinsics::_max_strict:\n+    result_val = _gvn.transform(new MaxINode(x0, y0));\n+    break;\n@@ -2116,1 +1949,2 @@\n-    ShouldNotReachHere();\n+    fatal_unexpected_iid(id);\n+    break;\n@@ -2118,1 +1952,1 @@\n-  *\/\n+  return result_val;\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":10,"deletions":176,"binary":false,"changes":186,"status":"modified"},{"patch":"@@ -0,0 +1,92 @@\n+\/*\n+ * Copyright (c) 2022, Arm Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package compiler.c2.irTests;\n+\n+import jdk.test.lib.Asserts;\n+import compiler.lib.ir_framework.*;\n+\n+\/*\n+ * @test\n+ * @bug 8288107\n+ * @summary Test that Ideal transformations of MaxINode* are being performed as expected.\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.MaxINodeIdealizationTests\n+ *\/\n+\n+public class MaxINodeIdealizationTests {\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    @Run(test = {\"test1\", \"test2\", \"test3\"})\n+    public void runMethod() {\n+        int a = RunInfo.getRandom().nextInt();\n+        int min = Integer.MIN_VALUE;\n+        int max = Integer.MAX_VALUE;\n+\n+        assertResult(a);\n+        assertResult(0);\n+        assertResult(min);\n+        assertResult(max);\n+    }\n+\n+    @DontCompile\n+    public void assertResult(int a) {\n+        Asserts.assertEQ(Math.max(((a >> 1) + 100), Math.max(((a >> 1) + 150), 200)), test1(a));\n+        Asserts.assertEQ(Math.max(((a >> 1) + 10), ((a >> 1) + 11))                 , test2(a));\n+        Asserts.assertEQ(Math.max(a, a)                                             , test3(a));\n+    }\n+\n+    \/\/ The transformations in test1 and test2 can happen only if the compiler has enough information\n+    \/\/ to determine that the two addition operations can not overflow.\n+\n+    \/\/ Transform max(x + c0, max(y + c1, z)) to max(add(x, c2), z) if x == y, where c2 = MAX2(c0, c1).\n+    \/\/ c0,c1 and c2 are constants. x,y,z can be any valid c2 nodes. In this example, x and y are\n+    \/\/ RShiftI nodes and z is a ConI.\n+    @Test\n+    @IR(counts = {IRNode.Max_I, \"1\",\n+                  IRNode.ADD, \"1\",\n+                 })\n+    public int test1(int i) {\n+        return Math.max(((i >> 1) + 100), Math.max(((i >> 1) + 150), 200));\n+    }\n+\n+    \/\/ Transform max(x + c0, y + c1) to add(x, c2) if x == y, where c2 = MAX2(c0, c1).\n+    \/\/ c0,c1,c2 are constants. x and y can be any valid c2 nodes. If they are equal, this\n+    \/\/ transformation would take place. In this example, x and y are same RShiftI nodes.\n+    @Test\n+    @IR(failOn = {IRNode.Max_I})\n+    @IR(counts = {IRNode.ADD, \"1\"})\n+    public int test2(int i) {\n+        return Math.max((i >> 1) + 10, (i >> 1) + 11);\n+    }\n+\n+    \/\/ Do not perform a max operation when comparing the same node. As long as the same node is being\n+    \/\/ compared, a max operation will not be performed and instead the same node is returned. In this\n+    \/\/ test, an integer is being compared with itself but it can be any valid c2 node.\n+    @Test\n+    @IR(failOn = {IRNode.Max_I})\n+    public int test3(int i) {\n+        return Math.max(i, i);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/MaxINodeIdealizationTests.java","additions":92,"deletions":0,"binary":false,"changes":92,"status":"added"},{"patch":"@@ -212,0 +212,4 @@\n+    public static final String Max_I = START + \"MaxI\" + MID + END;\n+    public static final String Min_V = START + \"MinV\" + MID + END;\n+    public static final String Max_V = START + \"MaxV\" + MID + END;\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,114 @@\n+\/*\n+ * Copyright (c) 2022, Arm Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.c2.irTests;\n+\n+import compiler.lib.ir_framework.*;\n+import java.util.Random;\n+import jdk.test.lib.Utils;\n+\n+\/*\n+ * @test\n+ * @bug 8288107\n+ * @summary Auto-vectorization enhancement for integer Math.max\/Math.min operations\n+ * @library \/test\/lib \/\n+ * @requires vm.compiler2.enabled\n+ * @requires (os.simpleArch == \"x64\" & ((vm.cpu.features ~= \".*avx.*\")\n+ *           | (vm.cpu.features ~= \".*sse4.*\"))) | os.arch == \"aarch64\" | os.arch == \"riscv64\"\n+ * @run driver compiler.c2.irTests.TestAutoVecIntMinMax\n+ *\/\n+\n+public class TestAutoVecIntMinMax {\n+    private final static int LENGTH = 2000;\n+    private final static Random RANDOM = Utils.getRandomInstance();\n+\n+    private static int[] a;\n+    private static int[] b;\n+    private static int[] c;\n+\n+    static {\n+        a = new int[LENGTH];\n+        b = new int[LENGTH];\n+        c = new int[LENGTH];\n+        for(int i = 0; i < LENGTH; i++) {\n+            a[i] = RANDOM.nextInt();\n+            b[i] = RANDOM.nextInt();\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    \/\/ Test for auto-vectorization of Math.min operation on an array of integers\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR,  \" >0 \"})\n+    @IR(counts = {IRNode.Min_V,        \" >0 \"})\n+    @IR(counts = {IRNode.STORE_VECTOR, \" >0 \"})\n+    private static void testIntMin(int[] a, int[] b) {\n+        for(int i = 0; i < LENGTH; i++) {\n+            c[i] = Math.min(a[i], b[i]);\n+        }\n+    }\n+\n+    \/\/ Test for auto-vectorization of StrictMath.min operation on an array of integers\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR,  \" >0 \"})\n+    @IR(counts = {IRNode.Min_V,        \" >0 \"})\n+    @IR(counts = {IRNode.STORE_VECTOR, \" >0 \"})\n+    private static void testIntStrictMin(int[] a, int[] b) {\n+        for(int i = 0; i < LENGTH; i++) {\n+            c[i] = StrictMath.min(a[i], b[i]);\n+        }\n+    }\n+\n+    \/\/ Test for auto-vectorization of Math.max operation on an array of integers\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR,  \" >0 \"})\n+    @IR(counts = {IRNode.Max_V,        \" >0 \"})\n+    @IR(counts = {IRNode.STORE_VECTOR, \" >0 \"})\n+    private static void testIntMax(int[] a, int[] b) {\n+        for(int i = 0; i < LENGTH; i++) {\n+            c[i] = Math.max(a[i], b[i]);\n+        }\n+    }\n+\n+    \/\/ Test for auto-vectorization of StrictMath.max operation on an array of integers\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR,  \" >0 \"})\n+    @IR(counts = {IRNode.Max_V,        \" >0 \"})\n+    @IR(counts = {IRNode.STORE_VECTOR, \" >0 \"})\n+    private static void testIntStrictMax(int[] a, int[] b) {\n+        for(int i = 0; i < LENGTH; i++) {\n+            c[i] = StrictMath.max(a[i], b[i]);\n+        }\n+    }\n+\n+    @Run(test = {\"testIntMin\", \"testIntStrictMin\", \"testIntMax\", \"testIntStrictMax\"})\n+    private void testIntMinMax_runner() {\n+        testIntMin(a, b);\n+        testIntStrictMin(a, b);\n+        testIntMax(a, b);\n+        testIntStrictMax(a, b);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/TestAutoVecIntMinMax.java","additions":114,"deletions":0,"binary":false,"changes":114,"status":"added"},{"patch":"@@ -0,0 +1,89 @@\n+\/*\n+ * Copyright (c) 2022, Arm Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.vm.compiler;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.*;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.Random;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Thread)\n+public class VectorIntMinMax {\n+    @Param({\"2048\"})\n+    private int LENGTH;\n+\n+    private int[] ia;\n+    private int[] ib;\n+    private int[] ic;\n+\n+    @Param(\"0\")\n+    private int seed;\n+    private Random random = new Random(seed);\n+\n+    @Setup\n+    public void init() {\n+        ia = new int[LENGTH];\n+        ib = new int[LENGTH];\n+        ic = new int[LENGTH];\n+\n+        for (int i = 0; i < LENGTH; i++) {\n+            ia[i] = random.nextInt();\n+            ib[i] = random.nextInt();\n+        }\n+    }\n+\n+    \/\/ Test Math.max for int arrays\n+    @Benchmark\n+    public void testMaxInt() {\n+        for (int i = 0; i < LENGTH; i++) {\n+            ic[i] = Math.max(ia[i], ib[i]);\n+        }\n+    }\n+\n+    \/\/ Test Math.min for int arrays\n+    @Benchmark\n+    public void testMinInt() {\n+        for (int i = 0; i < LENGTH; i++) {\n+            ic[i] = Math.min(ia[i], ib[i]);\n+        }\n+    }\n+\n+    \/\/ Test StrictMath.min for int arrays\n+    @Benchmark\n+    public void testStrictMinInt() {\n+        for (int i = 0; i < LENGTH; i++) {\n+            ic[i] = StrictMath.min(ia[i], ib[i]);\n+        }\n+    }\n+\n+    \/\/ Test StrictMath.max for int arrays\n+    @Benchmark\n+    public void testStrictMaxInt() {\n+        for (int i = 0; i < LENGTH; i++) {\n+            ic[i] = StrictMath.max(ia[i], ib[i]);\n+        }\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/VectorIntMinMax.java","additions":89,"deletions":0,"binary":false,"changes":89,"status":"added"}]}