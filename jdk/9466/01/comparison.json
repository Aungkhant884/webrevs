{"files":[{"patch":"@@ -1840,8 +1840,0 @@\n-static bool is_simple_name(Node* n) {\n-  return (n->req() == 1         \/\/ constant\n-          || (n->is_Type() && n->as_Type()->type()->singleton())\n-          || n->is_Proj()       \/\/ parameter or return value\n-          || n->is_Phi()        \/\/ local of some sort\n-          );\n-}\n-\n@@ -1946,164 +1938,1 @@\n-  \/\/ These are the candidate return value:\n-  Node* xvalue = x0;\n-  Node* yvalue = y0;\n-\n-  if (xvalue == yvalue) {\n-    return xvalue;\n-  }\n-\n-  bool want_max = (id == vmIntrinsics::_max || id == vmIntrinsics::_max_strict);\n-\n-  const TypeInt* txvalue = _gvn.type(xvalue)->isa_int();\n-  const TypeInt* tyvalue = _gvn.type(yvalue)->isa_int();\n-  if (txvalue == NULL || tyvalue == NULL)  return top();\n-  \/\/ This is not really necessary, but it is consistent with a\n-  \/\/ hypothetical MaxINode::Value method:\n-  int widen = MAX2(txvalue->_widen, tyvalue->_widen);\n-\n-  \/\/ %%% This folding logic should (ideally) be in a different place.\n-  \/\/ Some should be inside IfNode, and there to be a more reliable\n-  \/\/ transformation of ?: style patterns into cmoves.  We also want\n-  \/\/ more powerful optimizations around cmove and min\/max.\n-\n-  \/\/ Try to find a dominating comparison of these guys.\n-  \/\/ It can simplify the index computation for Arrays.copyOf\n-  \/\/ and similar uses of System.arraycopy.\n-  \/\/ First, compute the normalized version of CmpI(x, y).\n-  int   cmp_op = Op_CmpI;\n-  Node* xkey = xvalue;\n-  Node* ykey = yvalue;\n-  Node* ideal_cmpxy = _gvn.transform(new CmpINode(xkey, ykey));\n-  if (ideal_cmpxy->is_Cmp()) {\n-    \/\/ E.g., if we have CmpI(length - offset, count),\n-    \/\/ it might idealize to CmpI(length, count + offset)\n-    cmp_op = ideal_cmpxy->Opcode();\n-    xkey = ideal_cmpxy->in(1);\n-    ykey = ideal_cmpxy->in(2);\n-  }\n-\n-  \/\/ Start by locating any relevant comparisons.\n-  Node* start_from = (xkey->outcnt() < ykey->outcnt()) ? xkey : ykey;\n-  Node* cmpxy = NULL;\n-  Node* cmpyx = NULL;\n-  for (DUIterator_Fast kmax, k = start_from->fast_outs(kmax); k < kmax; k++) {\n-    Node* cmp = start_from->fast_out(k);\n-    if (cmp->outcnt() > 0 &&            \/\/ must have prior uses\n-        cmp->in(0) == NULL &&           \/\/ must be context-independent\n-        cmp->Opcode() == cmp_op) {      \/\/ right kind of compare\n-      if (cmp->in(1) == xkey && cmp->in(2) == ykey)  cmpxy = cmp;\n-      if (cmp->in(1) == ykey && cmp->in(2) == xkey)  cmpyx = cmp;\n-    }\n-  }\n-\n-  const int NCMPS = 2;\n-  Node* cmps[NCMPS] = { cmpxy, cmpyx };\n-  int cmpn;\n-  for (cmpn = 0; cmpn < NCMPS; cmpn++) {\n-    if (cmps[cmpn] != NULL)  break;     \/\/ find a result\n-  }\n-  if (cmpn < NCMPS) {\n-    \/\/ Look for a dominating test that tells us the min and max.\n-    int depth = 0;                \/\/ Limit search depth for speed\n-    Node* dom = control();\n-    for (; dom != NULL; dom = IfNode::up_one_dom(dom, true)) {\n-      if (++depth >= 100)  break;\n-      Node* ifproj = dom;\n-      if (!ifproj->is_Proj())  continue;\n-      Node* iff = ifproj->in(0);\n-      if (!iff->is_If())  continue;\n-      Node* bol = iff->in(1);\n-      if (!bol->is_Bool())  continue;\n-      Node* cmp = bol->in(1);\n-      if (cmp == NULL)  continue;\n-      for (cmpn = 0; cmpn < NCMPS; cmpn++)\n-        if (cmps[cmpn] == cmp)  break;\n-      if (cmpn == NCMPS)  continue;\n-      BoolTest::mask btest = bol->as_Bool()->_test._test;\n-      if (ifproj->is_IfFalse())  btest = BoolTest(btest).negate();\n-      if (cmp->in(1) == ykey)    btest = BoolTest(btest).commute();\n-      \/\/ At this point, we know that 'x btest y' is true.\n-      switch (btest) {\n-      case BoolTest::eq:\n-        \/\/ They are proven equal, so we can collapse the min\/max.\n-        \/\/ Either value is the answer.  Choose the simpler.\n-        if (is_simple_name(yvalue) && !is_simple_name(xvalue))\n-          return yvalue;\n-        return xvalue;\n-      case BoolTest::lt:          \/\/ x < y\n-      case BoolTest::le:          \/\/ x <= y\n-        return (want_max ? yvalue : xvalue);\n-      case BoolTest::gt:          \/\/ x > y\n-      case BoolTest::ge:          \/\/ x >= y\n-        return (want_max ? xvalue : yvalue);\n-      default:\n-        break;\n-      }\n-    }\n-  }\n-\n-  \/\/ We failed to find a dominating test.\n-  \/\/ Let's pick a test that might GVN with prior tests.\n-  Node*          best_bol   = NULL;\n-  BoolTest::mask best_btest = BoolTest::illegal;\n-  for (cmpn = 0; cmpn < NCMPS; cmpn++) {\n-    Node* cmp = cmps[cmpn];\n-    if (cmp == NULL)  continue;\n-    for (DUIterator_Fast jmax, j = cmp->fast_outs(jmax); j < jmax; j++) {\n-      Node* bol = cmp->fast_out(j);\n-      if (!bol->is_Bool())  continue;\n-      BoolTest::mask btest = bol->as_Bool()->_test._test;\n-      if (btest == BoolTest::eq || btest == BoolTest::ne)  continue;\n-      if (cmp->in(1) == ykey)   btest = BoolTest(btest).commute();\n-      if (bol->outcnt() > (best_bol == NULL ? 0 : best_bol->outcnt())) {\n-        best_bol   = bol->as_Bool();\n-        best_btest = btest;\n-      }\n-    }\n-  }\n-\n-  Node* answer_if_true  = NULL;\n-  Node* answer_if_false = NULL;\n-  switch (best_btest) {\n-  default:\n-    if (cmpxy == NULL)\n-      cmpxy = ideal_cmpxy;\n-    best_bol = _gvn.transform(new BoolNode(cmpxy, BoolTest::lt));\n-    \/\/ and fall through:\n-  case BoolTest::lt:          \/\/ x < y\n-  case BoolTest::le:          \/\/ x <= y\n-    answer_if_true  = (want_max ? yvalue : xvalue);\n-    answer_if_false = (want_max ? xvalue : yvalue);\n-    break;\n-  case BoolTest::gt:          \/\/ x > y\n-  case BoolTest::ge:          \/\/ x >= y\n-    answer_if_true  = (want_max ? xvalue : yvalue);\n-    answer_if_false = (want_max ? yvalue : xvalue);\n-    break;\n-  }\n-\n-  jint hi, lo;\n-  if (want_max) {\n-    \/\/ We can sharpen the minimum.\n-    hi = MAX2(txvalue->_hi, tyvalue->_hi);\n-    lo = MAX2(txvalue->_lo, tyvalue->_lo);\n-  } else {\n-    \/\/ We can sharpen the maximum.\n-    hi = MIN2(txvalue->_hi, tyvalue->_hi);\n-    lo = MIN2(txvalue->_lo, tyvalue->_lo);\n-  }\n-\n-  \/\/ Use a flow-free graph structure, to avoid creating excess control edges\n-  \/\/ which could hinder other optimizations.\n-  \/\/ Since Math.min\/max is often used with arraycopy, we want\n-  \/\/ tightly_coupled_allocation to be able to see beyond min\/max expressions.\n-  Node* cmov = CMoveNode::make(NULL, best_bol,\n-                               answer_if_false, answer_if_true,\n-                               TypeInt::make(lo, hi, widen));\n-\n-  return _gvn.transform(cmov);\n-\n-  \/*\n-  \/\/ This is not as desirable as it may seem, since Min and Max\n-  \/\/ nodes do not have a full set of optimizations.\n-  \/\/ And they would interfere, anyway, with 'if' optimizations\n-  \/\/ and with CMoveI canonical forms.\n+  Node* result_val = NULL;\n@@ -2112,1 +1941,3 @@\n-    result_val = _gvn.transform(new (C, 3) MinINode(x,y)); break;\n+  case vmIntrinsics::_min_strict:\n+    result_val = _gvn.transform(new MinINode(x0, y0));\n+    break;\n@@ -2114,1 +1945,3 @@\n-    result_val = _gvn.transform(new (C, 3) MaxINode(x,y)); break;\n+  case vmIntrinsics::_max_strict:\n+    result_val = _gvn.transform(new MaxINode(x0, y0));\n+    break;\n@@ -2116,1 +1949,2 @@\n-    ShouldNotReachHere();\n+    fatal_unexpected_iid(id);\n+    break;\n@@ -2118,1 +1952,1 @@\n-  *\/\n+  return result_val;\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":10,"deletions":176,"binary":false,"changes":186,"status":"modified"},{"patch":"@@ -212,0 +212,3 @@\n+    public static final String Min_V = START + \"MinV\" + MID + END;\n+    public static final String Max_V = START + \"MaxV\" + MID + END;\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,114 @@\n+\/*\n+ * Copyright (c) 2022, Arm Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.c2.irTests;\n+\n+import compiler.lib.ir_framework.*;\n+import java.util.Random;\n+import jdk.test.lib.Utils;\n+\n+\/*\n+ * @test\n+ * @bug 8288107\n+ * @summary Auto-vectorization enhancement for integer Math.max\/Math.min operations\n+ * @library \/test\/lib \/\n+ * @requires vm.compiler2.enabled\n+ * @requires (os.simpleArch == \"x64\" & ((vm.cpu.features ~= \".*avx.*\")\n+ *           | (vm.cpu.features ~= \".*sse4.*\"))) | os.arch == \"aarch64\" | os.arch == \"riscv64\"\n+ * @run driver compiler.c2.irTests.TestAutoVecIntMinMax\n+ *\/\n+\n+public class TestAutoVecIntMinMax {\n+    private final static int LENGTH = 2000;\n+    private final static Random RANDOM = Utils.getRandomInstance();\n+\n+    private static int[] a;\n+    private static int[] b;\n+    private static int[] c;\n+\n+    static {\n+        a = new int[LENGTH];\n+        b = new int[LENGTH];\n+        c = new int[LENGTH];\n+        for(int i = 0; i < LENGTH; i++) {\n+            a[i] = RANDOM.nextInt();\n+            b[i] = RANDOM.nextInt();\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    \/\/ Test for auto-vectorization of Math.min operation on an array of integers\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR,  \" >0 \"})\n+    @IR(counts = {IRNode.Min_V,        \" >0 \"})\n+    @IR(counts = {IRNode.STORE_VECTOR, \" >0 \"})\n+    private static void testIntMin(int[] a, int[] b) {\n+        for(int i = 0; i < LENGTH; i++) {\n+            c[i] = Math.min(a[i], b[i]);\n+        }\n+    }\n+\n+    \/\/ Test for auto-vectorization of StrictMath.min operation on an array of integers\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR,  \" >0 \"})\n+    @IR(counts = {IRNode.Min_V,        \" >0 \"})\n+    @IR(counts = {IRNode.STORE_VECTOR, \" >0 \"})\n+    private static void testIntStrictMin(int[] a, int[] b) {\n+        for(int i = 0; i < LENGTH; i++) {\n+            c[i] = StrictMath.min(a[i], b[i]);\n+        }\n+    }\n+\n+    \/\/ Test for auto-vectorization of Math.max operation on an array of integers\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR,  \" >0 \"})\n+    @IR(counts = {IRNode.Max_V,        \" >0 \"})\n+    @IR(counts = {IRNode.STORE_VECTOR, \" >0 \"})\n+    private static void testIntMax(int[] a, int[] b) {\n+        for(int i = 0; i < LENGTH; i++) {\n+            c[i] = Math.max(a[i], b[i]);\n+        }\n+    }\n+\n+    \/\/ Test for auto-vectorization of StrictMath.max operation on an array of integers\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR,  \" >0 \"})\n+    @IR(counts = {IRNode.Max_V,        \" >0 \"})\n+    @IR(counts = {IRNode.STORE_VECTOR, \" >0 \"})\n+    private static void testIntStrictMax(int[] a, int[] b) {\n+        for(int i = 0; i < LENGTH; i++) {\n+            c[i] = StrictMath.max(a[i], b[i]);\n+        }\n+    }\n+\n+    @Run(test = {\"testIntMin\", \"testIntStrictMin\", \"testIntMax\", \"testIntStrictMax\"})\n+    private void testIntMinMax_runner() {\n+        testIntMin(a, b);\n+        testIntStrictMin(a, b);\n+        testIntMax(a, b);\n+        testIntStrictMax(a, b);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/TestAutoVecIntMinMax.java","additions":114,"deletions":0,"binary":false,"changes":114,"status":"added"},{"patch":"@@ -0,0 +1,89 @@\n+\/*\n+ * Copyright (c) 2022, Arm Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.vm.compiler;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.*;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.Random;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Thread)\n+public class VectorIntMinMax {\n+    @Param({\"2048\"})\n+    private int LENGTH;\n+\n+    private int[] ia;\n+    private int[] ib;\n+    private int[] ic;\n+\n+    @Param(\"0\")\n+    private int seed;\n+    private Random random = new Random(seed);\n+\n+    @Setup\n+    public void init() {\n+        ia = new int[LENGTH];\n+        ib = new int[LENGTH];\n+        ic = new int[LENGTH];\n+\n+        for (int i = 0; i < LENGTH; i++) {\n+            ia[i] = random.nextInt();\n+            ib[i] = random.nextInt();\n+        }\n+    }\n+\n+    \/\/ Test Math.max for int arrays\n+    @Benchmark\n+    public void testMaxInt() {\n+        for (int i = 0; i < LENGTH; i++) {\n+            ic[i] = Math.max(ia[i], ib[i]);\n+        }\n+    }\n+\n+    \/\/ Test Math.min for int arrays\n+    @Benchmark\n+    public void testMinInt() {\n+        for (int i = 0; i < LENGTH; i++) {\n+            ic[i] = Math.min(ia[i], ib[i]);\n+        }\n+    }\n+\n+    \/\/ Test StrictMath.min for int arrays\n+    @Benchmark\n+    public void testStrictMinInt() {\n+        for (int i = 0; i < LENGTH; i++) {\n+            ic[i] = StrictMath.min(ia[i], ib[i]);\n+        }\n+    }\n+\n+    \/\/ Test StrictMath.max for int arrays\n+    @Benchmark\n+    public void testStrictMaxInt() {\n+        for (int i = 0; i < LENGTH; i++) {\n+            ic[i] = StrictMath.max(ia[i], ib[i]);\n+        }\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/VectorIntMinMax.java","additions":89,"deletions":0,"binary":false,"changes":89,"status":"added"}]}