{"files":[{"patch":"@@ -216,0 +216,2 @@\n+     * @throws IllegalStateException if {@code scope} has been already closed, or if access occurs from a thread other\n+     * than the thread owning {@code scope}.\n@@ -300,0 +302,2 @@\n+     * @throws IllegalStateException if {@code scope} has been already closed, or if access occurs from a thread other\n+     * than the thread owning {@code scope}.\n@@ -339,0 +343,2 @@\n+     * @throws IllegalStateException if {@code scope} has been already closed, or if access occurs from a thread other\n+     * than the thread owning {@code scope}.\n@@ -576,0 +582,2 @@\n+         * @throws IllegalStateException if {@code scope} has been already closed, or if access occurs from a thread other\n+         * than the thread owning {@code scope}.\n@@ -652,0 +660,2 @@\n+         * @throws IllegalStateException if {@code scope} has been already closed, or if access occurs from a thread other\n+         * than the thread owning {@code scope}.\n@@ -675,0 +685,2 @@\n+         * @throws IllegalStateException if {@code scope} has been already closed, or if access occurs from a thread other\n+         * than the thread owning {@code scope}.\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/CLinker.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n- * byte order associated to a memory access var handle. The resulting memory access var handle can then be combined in various ways\n+ * byte order associated with a memory access var handle. The resulting memory access var handle can then be combined in various ways\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemoryHandles.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -194,1 +194,1 @@\n- * is the <em>layout name<\/em> (see {@link #LAYOUT_NAME}), a custom name that can be associated to memory layouts and that can be referred to when\n+ * is the <em>layout name<\/em> (see {@link #LAYOUT_NAME}), a custom name that can be associated with memory layouts and that can be referred to when\n@@ -270,1 +270,1 @@\n-     * @return a new layout which is the same as this layout, except for the <em>name<\/em> associated to it.\n+     * @return a new layout which is the same as this layout, except for the <em>name<\/em> associated with it.\n@@ -319,1 +319,1 @@\n-     * @return a new layout which is the same as this layout, except for the alignment constraint associated to it.\n+     * @return a new layout which is the same as this layout, except for the alignment constraint associated with it.\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemoryLayout.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -101,1 +101,1 @@\n- * Memory segments are associated to a resource scope (see {@link ResourceScope}), which can be accessed using\n+ * Memory segments are associated with a resource scope (see {@link ResourceScope}), which can be accessed using\n@@ -112,1 +112,1 @@\n- * Additionally, access to a memory segment in subject to the thread-confinement checks enforced by the owning scope; that is,\n+ * Additionally, access to a memory segment is subject to the thread-confinement checks enforced by the owning scope; that is,\n@@ -114,1 +114,1 @@\n- * scope, it can only be accessed by the thread which own the scope.\n+ * scope, it can only be accessed by the thread which owns the scope.\n@@ -135,1 +135,1 @@\n- * the same spatial and temporal access restrictions associated to the memory segment from which they originated.\n+ * the same spatial and temporal access restrictions associated with the memory segment from which they originated.\n@@ -677,1 +677,1 @@\n-     * and resource scope. A client is responsible make sure that the resource scope associated to the returned segment is closed\n+     * and resource scope. A client is responsible make sure that the resource scope associated with the returned segment is closed\n@@ -691,0 +691,2 @@\n+     * @throws IllegalStateException if {@code scope} has been already closed, or if access occurs from a thread other\n+     * than the thread owning {@code scope}.\n@@ -700,1 +702,1 @@\n-     * and resource scope. A client is responsible make sure that the resource scope associated to the returned segment is closed\n+     * and resource scope. A client is responsible make sure that the resource scope associated with the returned segment is closed\n@@ -714,0 +716,2 @@\n+     * @throws IllegalStateException if {@code scope} has been already closed, or if access occurs from a thread other\n+     * than the thread owning {@code scope}.\n@@ -722,1 +726,1 @@\n-     * scope associated to the returned segment is closed when the segment is no longer in use.\n+     * scope associated with the returned segment is closed when the segment is no longer in use.\n@@ -733,0 +737,2 @@\n+     * @throws IllegalStateException if {@code scope} has been already closed, or if access occurs from a thread other\n+     * than the thread owning {@code scope}.\n@@ -780,0 +786,2 @@\n+     * @throws IllegalStateException if {@code scope} has been already closed, or if access occurs from a thread other\n+     * than the thread owning {@code scope}.\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemorySegment.java","additions":15,"deletions":7,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -365,0 +365,3 @@\n+     * @throws IllegalArgumentException if {@code size <= 0}.\n+     * @throws IllegalStateException if {@code scope} has been already closed, or if access occurs from a thread other\n+     * than the thread owning {@code scope}.\n@@ -400,0 +403,2 @@\n+     * @throws IllegalStateException if {@code scope} has been already closed, or if access occurs from a thread other\n+     * than the thread owning {@code scope}.\n@@ -435,1 +440,1 @@\n-     * @param scope the resource scope associated to the segments created by the returned allocator.\n+     * @param scope the resource scope associated with the segments created by the returned allocator.\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/SegmentAllocator.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -57,0 +57,12 @@\n+    static Path tempPath;\n+\n+    static {\n+        try {\n+            File file = File.createTempFile(\"scopedBuffer\", \"txt\");\n+            file.deleteOnExit();\n+            tempPath = file.toPath();\n+        } catch (IOException ex) {\n+            throw new ExceptionInInitializerError(ex);\n+        }\n+    }\n+\n@@ -93,50 +105,63 @@\n-            \/\/ scope operations\n-            ScopedOperation.ofScope(scope -> scope.addCloseAction(() -> {}), \"ResourceScope::addOnClose\");\n-            ScopedOperation.ofScope(scope -> {\n-                ResourceScope.Handle handle = scope.acquire();\n-                scope.release(handle);\n-            }, \"ResourceScope::lock\");\n-            \/\/ segment operations\n-            ScopedOperation.ofSegment(MemorySegment::toByteArray, \"MemorySegment::toByteArray\");\n-            ScopedOperation.ofSegment(MemorySegment::toCharArray, \"MemorySegment::toCharArray\");\n-            ScopedOperation.ofSegment(MemorySegment::toShortArray, \"MemorySegment::toShortArray\");\n-            ScopedOperation.ofSegment(MemorySegment::toIntArray, \"MemorySegment::toIntArray\");\n-            ScopedOperation.ofSegment(MemorySegment::toFloatArray, \"MemorySegment::toFloatArray\");\n-            ScopedOperation.ofSegment(MemorySegment::toLongArray, \"MemorySegment::toLongArray\");\n-            ScopedOperation.ofSegment(MemorySegment::toDoubleArray, \"MemorySegment::toDoubleArray\");\n-            ScopedOperation.ofSegment(MemorySegment::address, \"MemorySegment::address\");\n-            ScopedOperation.ofSegment(s -> MemoryLayout.sequenceLayout(s.byteSize(), MemoryLayouts.JAVA_BYTE), \"MemorySegment::spliterator\");\n-            ScopedOperation.ofSegment(s -> s.copyFrom(s), \"MemorySegment::copyFrom\");\n-            ScopedOperation.ofSegment(s -> s.mismatch(s), \"MemorySegment::mismatch\");\n-            ScopedOperation.ofSegment(s -> s.fill((byte) 0), \"MemorySegment::fill\");\n-            \/\/ address operations\n-            ScopedOperation.ofAddress(a -> a.toRawLongValue(), \"MemoryAddress::toRawLongValue\");\n-            ScopedOperation.ofAddress(a -> a.asSegment(100, ResourceScope.globalScope()), \"MemoryAddress::asSegment\");\n-            \/\/ valist operations\n-            ScopedOperation.ofVaList(CLinker.VaList::address, \"VaList::address\");\n-            ScopedOperation.ofVaList(CLinker.VaList::copy, \"VaList::copy\");\n-            ScopedOperation.ofVaList(list -> list.vargAsAddress(MemoryLayouts.ADDRESS), \"VaList::vargAsAddress\");\n-            ScopedOperation.ofVaList(list -> list.vargAsInt(MemoryLayouts.JAVA_INT), \"VaList::vargAsInt\");\n-            ScopedOperation.ofVaList(list -> list.vargAsLong(MemoryLayouts.JAVA_LONG), \"VaList::vargAsLong\");\n-            ScopedOperation.ofVaList(list -> list.vargAsDouble(MemoryLayouts.JAVA_DOUBLE), \"VaList::vargAsDouble\");\n-            ScopedOperation.ofVaList(CLinker.VaList::skip, \"VaList::skip\");\n-            ScopedOperation.ofVaList(list -> list.vargAsSegment(MemoryLayout.structLayout(MemoryLayouts.JAVA_INT), ResourceScope.newImplicitScope()), \"VaList::vargAsSegment\/1\");\n-            \/\/ allocator operations\n-            ScopedOperation.ofAllocator(a -> a.allocate(1), \"NativeAllocator::allocate\/size\");\n-            ScopedOperation.ofAllocator(a -> a.allocate(1, 1), \"NativeAllocator::allocate\/size\/align\");\n-            ScopedOperation.ofAllocator(a -> a.allocate(MemoryLayouts.JAVA_BYTE), \"NativeAllocator::allocate\/layout\");\n-            ScopedOperation.ofAllocator(a -> a.allocate(MemoryLayouts.JAVA_BYTE, (byte)0), \"NativeAllocator::allocate\/byte\");\n-            ScopedOperation.ofAllocator(a -> a.allocate(MemoryLayouts.JAVA_CHAR, (char)0), \"NativeAllocator::allocate\/char\");\n-            ScopedOperation.ofAllocator(a -> a.allocate(MemoryLayouts.JAVA_SHORT, (short)0), \"NativeAllocator::allocate\/short\");\n-            ScopedOperation.ofAllocator(a -> a.allocate(MemoryLayouts.JAVA_INT, 0), \"NativeAllocator::allocate\/int\");\n-            ScopedOperation.ofAllocator(a -> a.allocate(MemoryLayouts.JAVA_FLOAT, 0f), \"NativeAllocator::allocate\/float\");\n-            ScopedOperation.ofAllocator(a -> a.allocate(MemoryLayouts.JAVA_LONG, 0L), \"NativeAllocator::allocate\/long\");\n-            ScopedOperation.ofAllocator(a -> a.allocate(MemoryLayouts.JAVA_DOUBLE, 0d), \"NativeAllocator::allocate\/double\");\n-            ScopedOperation.ofAllocator(a -> a.allocateArray(MemoryLayouts.JAVA_BYTE, 1L), \"NativeAllocator::allocateArray\/size\");\n-            ScopedOperation.ofAllocator(a -> a.allocateArray(MemoryLayouts.JAVA_BYTE, new byte[] { 0 }), \"NativeAllocator::allocateArray\/byte\");\n-            ScopedOperation.ofAllocator(a -> a.allocateArray(MemoryLayouts.JAVA_CHAR, new char[] { 0 }), \"NativeAllocator::allocateArray\/char\");\n-            ScopedOperation.ofAllocator(a -> a.allocateArray(MemoryLayouts.JAVA_SHORT, new short[] { 0 }), \"NativeAllocator::allocateArray\/short\");\n-            ScopedOperation.ofAllocator(a -> a.allocateArray(MemoryLayouts.JAVA_INT, new int[] { 0 }), \"NativeAllocator::allocateArray\/int\");\n-            ScopedOperation.ofAllocator(a -> a.allocateArray(MemoryLayouts.JAVA_FLOAT, new float[] { 0 }), \"NativeAllocator::allocateArray\/float\");\n-            ScopedOperation.ofAllocator(a -> a.allocateArray(MemoryLayouts.JAVA_LONG, new long[] { 0 }), \"NativeAllocator::allocateArray\/long\");\n-            ScopedOperation.ofAllocator(a -> a.allocateArray(MemoryLayouts.JAVA_DOUBLE, new double[] { 0 }), \"NativeAllocator::allocateArray\/double\");\n+        \/\/ scope operations\n+        ScopedOperation.ofScope(scope -> scope.addCloseAction(() -> {\n+        }), \"ResourceScope::addOnClose\");\n+        ScopedOperation.ofScope(scope -> {\n+            ResourceScope.Handle handle = scope.acquire();\n+            scope.release(handle);\n+        }, \"ResourceScope::lock\");\n+        ScopedOperation.ofScope(scope -> MemorySegment.allocateNative(100, scope), \"MemorySegment::allocateNative\");\n+        ScopedOperation.ofScope(scope -> {\n+            try {\n+                MemorySegment.mapFile(tempPath, 0, 10, FileChannel.MapMode.READ_WRITE, scope);\n+            } catch (IOException ex) {\n+                fail();\n+            }\n+        }, \"MemorySegment::mapFromFile\");\n+        ScopedOperation.ofScope(scope -> CLinker.VaList.make(b -> {}, scope), \"VaList::make\");\n+        ScopedOperation.ofScope(scope -> CLinker.VaList.ofAddress(MemoryAddress.ofLong(42), scope), \"VaList::make\");\n+        ScopedOperation.ofScope(scope -> CLinker.toCString(\"Hello\", scope), \"CLinker::toCString\");\n+        ScopedOperation.ofScope(SegmentAllocator::arenaAllocator, \"SegmentAllocator::arenaAllocator\");\n+        \/\/ segment operations\n+        ScopedOperation.ofSegment(MemorySegment::toByteArray, \"MemorySegment::toByteArray\");\n+        ScopedOperation.ofSegment(MemorySegment::toCharArray, \"MemorySegment::toCharArray\");\n+        ScopedOperation.ofSegment(MemorySegment::toShortArray, \"MemorySegment::toShortArray\");\n+        ScopedOperation.ofSegment(MemorySegment::toIntArray, \"MemorySegment::toIntArray\");\n+        ScopedOperation.ofSegment(MemorySegment::toFloatArray, \"MemorySegment::toFloatArray\");\n+        ScopedOperation.ofSegment(MemorySegment::toLongArray, \"MemorySegment::toLongArray\");\n+        ScopedOperation.ofSegment(MemorySegment::toDoubleArray, \"MemorySegment::toDoubleArray\");\n+        ScopedOperation.ofSegment(MemorySegment::address, \"MemorySegment::address\");\n+        ScopedOperation.ofSegment(s -> MemoryLayout.sequenceLayout(s.byteSize(), MemoryLayouts.JAVA_BYTE), \"MemorySegment::spliterator\");\n+        ScopedOperation.ofSegment(s -> s.copyFrom(s), \"MemorySegment::copyFrom\");\n+        ScopedOperation.ofSegment(s -> s.mismatch(s), \"MemorySegment::mismatch\");\n+        ScopedOperation.ofSegment(s -> s.fill((byte) 0), \"MemorySegment::fill\");\n+        \/\/ address operations\n+        ScopedOperation.ofAddress(a -> a.toRawLongValue(), \"MemoryAddress::toRawLongValue\");\n+        ScopedOperation.ofAddress(a -> a.asSegment(100, ResourceScope.globalScope()), \"MemoryAddress::asSegment\");\n+        \/\/ valist operations\n+        ScopedOperation.ofVaList(CLinker.VaList::address, \"VaList::address\");\n+        ScopedOperation.ofVaList(CLinker.VaList::copy, \"VaList::copy\");\n+        ScopedOperation.ofVaList(list -> list.vargAsAddress(MemoryLayouts.ADDRESS), \"VaList::vargAsAddress\");\n+        ScopedOperation.ofVaList(list -> list.vargAsInt(MemoryLayouts.JAVA_INT), \"VaList::vargAsInt\");\n+        ScopedOperation.ofVaList(list -> list.vargAsLong(MemoryLayouts.JAVA_LONG), \"VaList::vargAsLong\");\n+        ScopedOperation.ofVaList(list -> list.vargAsDouble(MemoryLayouts.JAVA_DOUBLE), \"VaList::vargAsDouble\");\n+        ScopedOperation.ofVaList(CLinker.VaList::skip, \"VaList::skip\");\n+        ScopedOperation.ofVaList(list -> list.vargAsSegment(MemoryLayout.structLayout(MemoryLayouts.JAVA_INT), ResourceScope.newImplicitScope()), \"VaList::vargAsSegment\/1\");\n+        \/\/ allocator operations\n+        ScopedOperation.ofAllocator(a -> a.allocate(1), \"NativeAllocator::allocate\/size\");\n+        ScopedOperation.ofAllocator(a -> a.allocate(1, 1), \"NativeAllocator::allocate\/size\/align\");\n+        ScopedOperation.ofAllocator(a -> a.allocate(MemoryLayouts.JAVA_BYTE), \"NativeAllocator::allocate\/layout\");\n+        ScopedOperation.ofAllocator(a -> a.allocate(MemoryLayouts.JAVA_BYTE, (byte) 0), \"NativeAllocator::allocate\/byte\");\n+        ScopedOperation.ofAllocator(a -> a.allocate(MemoryLayouts.JAVA_CHAR, (char) 0), \"NativeAllocator::allocate\/char\");\n+        ScopedOperation.ofAllocator(a -> a.allocate(MemoryLayouts.JAVA_SHORT, (short) 0), \"NativeAllocator::allocate\/short\");\n+        ScopedOperation.ofAllocator(a -> a.allocate(MemoryLayouts.JAVA_INT, 0), \"NativeAllocator::allocate\/int\");\n+        ScopedOperation.ofAllocator(a -> a.allocate(MemoryLayouts.JAVA_FLOAT, 0f), \"NativeAllocator::allocate\/float\");\n+        ScopedOperation.ofAllocator(a -> a.allocate(MemoryLayouts.JAVA_LONG, 0L), \"NativeAllocator::allocate\/long\");\n+        ScopedOperation.ofAllocator(a -> a.allocate(MemoryLayouts.JAVA_DOUBLE, 0d), \"NativeAllocator::allocate\/double\");\n+        ScopedOperation.ofAllocator(a -> a.allocateArray(MemoryLayouts.JAVA_BYTE, 1L), \"NativeAllocator::allocateArray\/size\");\n+        ScopedOperation.ofAllocator(a -> a.allocateArray(MemoryLayouts.JAVA_BYTE, new byte[]{0}), \"NativeAllocator::allocateArray\/byte\");\n+        ScopedOperation.ofAllocator(a -> a.allocateArray(MemoryLayouts.JAVA_CHAR, new char[]{0}), \"NativeAllocator::allocateArray\/char\");\n+        ScopedOperation.ofAllocator(a -> a.allocateArray(MemoryLayouts.JAVA_SHORT, new short[]{0}), \"NativeAllocator::allocateArray\/short\");\n+        ScopedOperation.ofAllocator(a -> a.allocateArray(MemoryLayouts.JAVA_INT, new int[]{0}), \"NativeAllocator::allocateArray\/int\");\n+        ScopedOperation.ofAllocator(a -> a.allocateArray(MemoryLayouts.JAVA_FLOAT, new float[]{0}), \"NativeAllocator::allocateArray\/float\");\n+        ScopedOperation.ofAllocator(a -> a.allocateArray(MemoryLayouts.JAVA_LONG, new long[]{0}), \"NativeAllocator::allocateArray\/long\");\n+        ScopedOperation.ofAllocator(a -> a.allocateArray(MemoryLayouts.JAVA_DOUBLE, new double[]{0}), \"NativeAllocator::allocateArray\/double\");\n","filename":"test\/jdk\/java\/foreign\/TestScopedOperations.java","additions":75,"deletions":50,"binary":false,"changes":125,"status":"modified"}]}