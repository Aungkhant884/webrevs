{"files":[{"patch":"@@ -87,0 +87,5 @@\n+\n+const CallRegs ForeignGlobals::parse_call_regs_impl(jobject jconv) const {\n+  ShouldNotCallThis();\n+  return {};\n+}\n","filename":"src\/hotspot\/cpu\/aarch64\/foreign_globals_aarch64.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -362,0 +362,10 @@\n+JavaFrameAnchor* OptimizedEntryBlob::jfa_for_frame(const frame& frame) const {\n+  ShouldNotCallThis();\n+  return nullptr;\n+}\n+\n+frame frame::sender_for_optimized_entry_frame(RegisterMap* map) const {\n+  ShouldNotCallThis();\n+  return {};\n+}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/frame_aarch64.cpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -881,1 +881,1 @@\n-static void move32_64(MacroAssembler* masm, VMRegPair src, VMRegPair dst) {\n+void SharedRuntime::move32_64(MacroAssembler* masm, VMRegPair src, VMRegPair dst) {\n@@ -982,1 +982,1 @@\n-static void float_move(MacroAssembler* masm, VMRegPair src, VMRegPair dst) {\n+void SharedRuntime::float_move(MacroAssembler* masm, VMRegPair src, VMRegPair dst) {\n@@ -1001,1 +1001,1 @@\n-static void long_move(MacroAssembler* masm, VMRegPair src, VMRegPair dst) {\n+void SharedRuntime::long_move(MacroAssembler* masm, VMRegPair src, VMRegPair dst) {\n@@ -1025,1 +1025,1 @@\n-static void double_move(MacroAssembler* masm, VMRegPair src, VMRegPair dst) {\n+void SharedRuntime::double_move(MacroAssembler* masm, VMRegPair src, VMRegPair dst) {\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -102,0 +102,9 @@\n+\n+address ProgrammableUpcallHandler::generate_optimized_upcall_stub(jobject mh, Method* entry, jobject jabi, jobject jconv) {\n+  ShouldNotCallThis();\n+  return nullptr;\n+}\n+\n+bool ProgrammableUpcallHandler::supports_optimized_upcalls() {\n+  return false;\n+}\n","filename":"src\/hotspot\/cpu\/aarch64\/universalUpcallHandler_aarch64.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -90,0 +90,29 @@\n+\n+const CallRegs ForeignGlobals::parse_call_regs_impl(jobject jconv) const {\n+  oop conv_oop = JNIHandles::resolve_non_null(jconv);\n+  objArrayOop arg_regs_oop = cast<objArrayOop>(conv_oop->obj_field(CallConvOffsets.arg_regs_offset));\n+  objArrayOop ret_regs_oop = cast<objArrayOop>(conv_oop->obj_field(CallConvOffsets.ret_regs_offset));\n+\n+  CallRegs result;\n+  result._args_length = arg_regs_oop->length();\n+  result._arg_regs = NEW_RESOURCE_ARRAY(VMReg, result._args_length);\n+\n+  result._rets_length = ret_regs_oop->length();\n+  result._ret_regs = NEW_RESOURCE_ARRAY(VMReg, result._rets_length);\n+\n+  for (int i = 0; i < result._args_length; i++) {\n+    oop storage = arg_regs_oop->obj_at(i);\n+    jint index = storage->int_field(VMS.index_offset);\n+    jint type = storage->int_field(VMS.type_offset);\n+    result._arg_regs[i] = VMRegImpl::vmStorageToVMReg(type, index);\n+  }\n+\n+  for (int i = 0; i < result._rets_length; i++) {\n+    oop storage = ret_regs_oop->obj_at(i);\n+    jint index = storage->int_field(VMS.index_offset);\n+    jint type = storage->int_field(VMS.type_offset);\n+    result._ret_regs[i] = VMRegImpl::vmStorageToVMReg(type, index);\n+  }\n+\n+  return result;\n+}\n","filename":"src\/hotspot\/cpu\/x86\/foreign_globals_x86.cpp","additions":29,"deletions":0,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -105,0 +105,2 @@\n+    } else if (is_optimized_entry_frame()) {\n+      return fp_safe;\n@@ -202,0 +204,2 @@\n+    } else if (sender_blob->is_optimized_entry_blob()) {\n+      return false;\n@@ -352,0 +356,26 @@\n+JavaFrameAnchor* OptimizedEntryBlob::jfa_for_frame(const frame& frame) const {\n+  \/\/ need unextended_sp here, since normal sp is wrong for interpreter callees\n+  return reinterpret_cast<JavaFrameAnchor*>(reinterpret_cast<char*>(frame.unextended_sp()) + in_bytes(jfa_sp_offset()));\n+}\n+\n+frame frame::sender_for_optimized_entry_frame(RegisterMap* map) const {\n+  assert(map != NULL, \"map must be set\");\n+  OptimizedEntryBlob* blob = _cb->as_optimized_entry_blob();\n+  \/\/ Java frame called from C; skip all C frames and return top C\n+  \/\/ frame of that chunk as the sender\n+  JavaFrameAnchor* jfa = blob->jfa_for_frame(*this);\n+  assert(jfa->last_Java_sp() > sp(), \"must be above this frame on stack\");\n+  \/\/ Since we are walking the stack now this nested anchor is obviously walkable\n+  \/\/ even if it wasn't when it was stacked.\n+  if (!jfa->walkable()) {\n+    \/\/ Capture _last_Java_pc (if needed) and mark anchor walkable.\n+    jfa->capture_last_Java_pc();\n+  }\n+  map->clear();\n+  assert(map->include_argument_oops(), \"should be set by clear\");\n+  vmassert(jfa->last_Java_pc() != NULL, \"not walkable\");\n+  frame fr(jfa->last_Java_sp(), jfa->last_Java_fp(), jfa->last_Java_pc());\n+\n+  return fr;\n+}\n+\n@@ -481,2 +511,3 @@\n-  if (is_entry_frame())       return sender_for_entry_frame(map);\n-  if (is_interpreted_frame()) return sender_for_interpreter_frame(map);\n+  if (is_entry_frame())        return sender_for_entry_frame(map);\n+  if (is_optimized_entry_frame()) return sender_for_optimized_entry_frame(map);\n+  if (is_interpreted_frame())  return sender_for_interpreter_frame(map);\n","filename":"src\/hotspot\/cpu\/x86\/frame_x86.cpp","additions":33,"deletions":2,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -73,2 +73,0 @@\n-private:\n-\n","filename":"src\/hotspot\/cpu\/x86\/javaFrameAnchor_x86.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1127,1 +1127,1 @@\n-static void float_move(MacroAssembler* masm, VMRegPair src, VMRegPair dst) {\n+void SharedRuntime::float_move(MacroAssembler* masm, VMRegPair src, VMRegPair dst) {\n@@ -1145,1 +1145,1 @@\n-static void long_move(MacroAssembler* masm, VMRegPair src, VMRegPair dst) {\n+void SharedRuntime::long_move(MacroAssembler* masm, VMRegPair src, VMRegPair dst) {\n@@ -1164,1 +1164,1 @@\n-static void double_move(MacroAssembler* masm, VMRegPair src, VMRegPair dst) {\n+void SharedRuntime::double_move(MacroAssembler* masm, VMRegPair src, VMRegPair dst) {\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_32.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1170,1 +1170,1 @@\n-static void move32_64(MacroAssembler* masm, VMRegPair src, VMRegPair dst) {\n+void SharedRuntime::move32_64(MacroAssembler* masm, VMRegPair src, VMRegPair dst) {\n@@ -1288,1 +1288,1 @@\n-static void float_move(MacroAssembler* masm, VMRegPair src, VMRegPair dst) {\n+void SharedRuntime::float_move(MacroAssembler* masm, VMRegPair src, VMRegPair dst) {\n@@ -1317,1 +1317,1 @@\n-static void long_move(MacroAssembler* masm, VMRegPair src, VMRegPair dst) {\n+void SharedRuntime::long_move(MacroAssembler* masm, VMRegPair src, VMRegPair dst) {\n@@ -1342,1 +1342,1 @@\n-static void double_move(MacroAssembler* masm, VMRegPair src, VMRegPair dst) {\n+void SharedRuntime::double_move(MacroAssembler* masm, VMRegPair src, VMRegPair dst) {\n@@ -1451,1 +1451,1 @@\n-  move32_64(masm, tmp, length_arg);\n+  SharedRuntime::move32_64(masm, tmp, length_arg);\n@@ -1457,1 +1457,1 @@\n-  move32_64(masm, tmp, length_arg);\n+  SharedRuntime::move32_64(masm, tmp, length_arg);\n@@ -1544,2 +1544,2 @@\n-  ComputeMoveOrder(int total_in_args, VMRegPair* in_regs, int total_c_args, VMRegPair* out_regs,\n-                    BasicType* in_sig_bt, GrowableArray<int>& arg_order, VMRegPair tmp_vmreg) {\n+  ComputeMoveOrder(int total_in_args, const VMRegPair* in_regs, int total_c_args, VMRegPair* out_regs,\n+                  const BasicType* in_sig_bt, GrowableArray<int>& arg_order, VMRegPair tmp_vmreg) {\n@@ -4090,0 +4090,10 @@\n+\n+void SharedRuntime::compute_move_order(const BasicType* in_sig_bt,\n+                                       int total_in_args, const VMRegPair* in_regs,\n+                                       int total_out_args, VMRegPair* out_regs,\n+                                       GrowableArray<int>& arg_order,\n+                                       VMRegPair tmp_vmreg) {\n+  ComputeMoveOrder order(total_in_args, in_regs,\n+                         total_out_args, out_regs,\n+                         in_sig_bt, arg_order, tmp_vmreg);\n+}\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_64.cpp","additions":18,"deletions":8,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -31,0 +31,9 @@\n+\n+address ProgrammableUpcallHandler::generate_optimized_upcall_stub(jobject mh, Method* entry, jobject jabi, jobject jconv) {\n+  ShouldNotCallThis();\n+  return nullptr;\n+}\n+\n+bool ProgrammableUpcallHandler::supports_optimized_upcalls() {\n+  return false;\n+}\n","filename":"src\/hotspot\/cpu\/x86\/universalUpcallHandler_x86_32.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -27,0 +27,4 @@\n+#include \"code\/codeBlob.hpp\"\n+#include \"code\/vmreg.inline.hpp\"\n+#include \"compiler\/disassembler.hpp\"\n+#include \"logging\/logStream.hpp\"\n@@ -29,0 +33,5 @@\n+#include \"runtime\/sharedRuntime.hpp\"\n+#include \"runtime\/signature.hpp\"\n+#include \"runtime\/stubRoutines.hpp\"\n+#include \"utilities\/formatBuffer.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n@@ -144,0 +153,698 @@\n+\n+struct ArgMove {\n+  BasicType bt;\n+  VMRegPair from;\n+  VMRegPair to;\n+\n+  bool is_identity() const {\n+      return from.first() == to.first() && from.second() == to.second();\n+  }\n+};\n+\n+static GrowableArray<ArgMove> compute_argument_shuffle(Method* entry, int& out_arg_size_bytes, const CallRegs& conv, BasicType& ret_type) {\n+  assert(entry->is_static(), \"\");\n+\n+  \/\/ Fill in the signature array, for the calling-convention call.\n+  const int total_out_args = entry->size_of_parameters();\n+  assert(total_out_args > 0, \"receiver arg \");\n+\n+  BasicType* out_sig_bt = NEW_RESOURCE_ARRAY(BasicType, total_out_args);\n+  VMRegPair* out_regs = NEW_RESOURCE_ARRAY(VMRegPair, total_out_args);\n+\n+  {\n+    int i = 0;\n+    SignatureStream ss(entry->signature());\n+    for (; !ss.at_return_type(); ss.next()) {\n+      out_sig_bt[i++] = ss.type();  \/\/ Collect remaining bits of signature\n+      if (ss.type() == T_LONG || ss.type() == T_DOUBLE)\n+        out_sig_bt[i++] = T_VOID;   \/\/ Longs & doubles take 2 Java slots\n+    }\n+    assert(i == total_out_args, \"\");\n+    ret_type = ss.type();\n+  }\n+\n+  int out_arg_slots = SharedRuntime::java_calling_convention(out_sig_bt, out_regs, total_out_args);\n+\n+  const int total_in_args = total_out_args - 1; \/\/ skip receiver\n+  BasicType* in_sig_bt  = NEW_RESOURCE_ARRAY(BasicType, total_in_args);\n+  VMRegPair* in_regs    = NEW_RESOURCE_ARRAY(VMRegPair, total_in_args);\n+\n+  for (int i = 0; i < total_in_args ; i++ ) {\n+    in_sig_bt[i] = out_sig_bt[i+1]; \/\/ skip receiver\n+  }\n+\n+  \/\/ Now figure out where the args must be stored and how much stack space they require.\n+  conv.calling_convention(in_sig_bt, in_regs, total_in_args);\n+\n+  GrowableArray<int> arg_order(2 * total_in_args);\n+\n+  VMRegPair tmp_vmreg;\n+  tmp_vmreg.set2(rbx->as_VMReg());\n+\n+  \/\/ Compute a valid move order, using tmp_vmreg to break any cycles\n+  SharedRuntime::compute_move_order(in_sig_bt,\n+                                    total_in_args, in_regs,\n+                                    total_out_args, out_regs,\n+                                    arg_order,\n+                                    tmp_vmreg);\n+\n+  GrowableArray<ArgMove> arg_order_vmreg(total_in_args); \/\/ conservative\n+\n+#ifdef ASSERT\n+  bool reg_destroyed[RegisterImpl::number_of_registers];\n+  bool freg_destroyed[XMMRegisterImpl::number_of_registers];\n+  for ( int r = 0 ; r < RegisterImpl::number_of_registers ; r++ ) {\n+    reg_destroyed[r] = false;\n+  }\n+  for ( int f = 0 ; f < XMMRegisterImpl::number_of_registers ; f++ ) {\n+    freg_destroyed[f] = false;\n+  }\n+#endif \/\/ ASSERT\n+\n+  for (int i = 0; i < arg_order.length(); i += 2) {\n+    int in_arg  = arg_order.at(i);\n+    int out_arg = arg_order.at(i + 1);\n+\n+    assert(in_arg != -1 || out_arg != -1, \"\");\n+    BasicType arg_bt = (in_arg != -1 ? in_sig_bt[in_arg] : out_sig_bt[out_arg]);\n+    switch (arg_bt) {\n+      case T_BOOLEAN:\n+      case T_BYTE:\n+      case T_SHORT:\n+      case T_CHAR:\n+      case T_INT:\n+      case T_FLOAT:\n+        break; \/\/ process\n+\n+      case T_LONG:\n+      case T_DOUBLE:\n+        assert(in_arg  == -1 || (in_arg  + 1 < total_in_args  &&  in_sig_bt[in_arg  + 1] == T_VOID), \"bad arg list: %d\", in_arg);\n+        assert(out_arg == -1 || (out_arg + 1 < total_out_args && out_sig_bt[out_arg + 1] == T_VOID), \"bad arg list: %d\", out_arg);\n+        break; \/\/ process\n+\n+      case T_VOID:\n+        continue; \/\/ skip\n+\n+      default:\n+        fatal(\"found in upcall args: %s\", type2name(arg_bt));\n+    }\n+\n+    ArgMove move;\n+    move.bt   = arg_bt;\n+    move.from = (in_arg != -1 ? in_regs[in_arg] : tmp_vmreg);\n+    move.to   = (out_arg != -1 ? out_regs[out_arg] : tmp_vmreg);\n+\n+    if(move.is_identity()) {\n+      continue; \/\/ useless move\n+    }\n+\n+#ifdef ASSERT\n+    if (in_arg != -1) {\n+      if (in_regs[in_arg].first()->is_Register()) {\n+        assert(!reg_destroyed[in_regs[in_arg].first()->as_Register()->encoding()], \"destroyed reg!\");\n+      } else if (in_regs[in_arg].first()->is_XMMRegister()) {\n+        assert(!freg_destroyed[in_regs[in_arg].first()->as_XMMRegister()->encoding()], \"destroyed reg!\");\n+      }\n+    }\n+    if (out_arg != -1) {\n+      if (out_regs[out_arg].first()->is_Register()) {\n+        reg_destroyed[out_regs[out_arg].first()->as_Register()->encoding()] = true;\n+      } else if (out_regs[out_arg].first()->is_XMMRegister()) {\n+        freg_destroyed[out_regs[out_arg].first()->as_XMMRegister()->encoding()] = true;\n+      }\n+    }\n+#endif \/* ASSERT *\/\n+\n+    arg_order_vmreg.push(move);\n+  }\n+\n+  int stack_slots = SharedRuntime::out_preserve_stack_slots() + out_arg_slots;\n+  out_arg_size_bytes = align_up(stack_slots * VMRegImpl::stack_slot_size, StackAlignmentInBytes);\n+\n+  return arg_order_vmreg;\n+}\n+\n+static const char* null_safe_string(const char* str) {\n+  return str == nullptr ? \"NULL\" : str;\n+}\n+\n+#ifdef ASSERT\n+static void print_arg_moves(const GrowableArray<ArgMove>& arg_moves, Method* entry) {\n+  LogTarget(Trace, foreign) lt;\n+  if (lt.is_enabled()) {\n+    ResourceMark rm;\n+    LogStream ls(lt);\n+    ls.print_cr(\"Argument shuffle for %s {\", entry->name_and_sig_as_C_string());\n+    for (int i = 0; i < arg_moves.length(); i++) {\n+      ArgMove arg_mv = arg_moves.at(i);\n+      BasicType arg_bt     = arg_mv.bt;\n+      VMRegPair from_vmreg = arg_mv.from;\n+      VMRegPair to_vmreg   = arg_mv.to;\n+\n+      ls.print(\"Move a %s from (\", null_safe_string(type2name(arg_bt)));\n+      from_vmreg.first()->print_on(&ls);\n+      ls.print(\",\");\n+      from_vmreg.second()->print_on(&ls);\n+      ls.print(\") to \");\n+      to_vmreg.first()->print_on(&ls);\n+      ls.print(\",\");\n+      to_vmreg.second()->print_on(&ls);\n+      ls.print_cr(\")\");\n+    }\n+    ls.print_cr(\"}\");\n+  }\n+}\n+#endif\n+\n+void save_java_frame_anchor(MacroAssembler* _masm, ByteSize store_offset, Register thread) {\n+  __ block_comment(\"{ save_java_frame_anchor \");\n+  \/\/ upcall->jfa._last_Java_fp = _thread->_anchor._last_Java_fp;\n+  __ movptr(rscratch1, Address(thread, JavaThread::last_Java_fp_offset()));\n+  __ movptr(Address(rsp, store_offset + JavaFrameAnchor::last_Java_fp_offset()), rscratch1);\n+\n+  \/\/ upcall->jfa._last_Java_pc = _thread->_anchor._last_Java_pc;\n+  __ movptr(rscratch1, Address(thread, JavaThread::last_Java_pc_offset()));\n+  __ movptr(Address(rsp, store_offset + JavaFrameAnchor::last_Java_pc_offset()), rscratch1);\n+\n+  \/\/ upcall->jfa._last_Java_sp = _thread->_anchor._last_Java_sp;\n+  __ movptr(rscratch1, Address(thread, JavaThread::last_Java_sp_offset()));\n+  __ movptr(Address(rsp, store_offset + JavaFrameAnchor::last_Java_sp_offset()), rscratch1);\n+  __ block_comment(\"} save_java_frame_anchor \");\n+}\n+\n+void restore_java_frame_anchor(MacroAssembler* _masm, ByteSize load_offset, Register thread) {\n+  __ block_comment(\"{ restore_java_frame_anchor \");\n+  \/\/ thread->_last_Java_sp = NULL\n+  __ movptr(Address(thread, JavaThread::last_Java_sp_offset()), NULL_WORD);\n+\n+  \/\/ ThreadStateTransition::transition_from_java(_thread, _thread_in_vm);\n+  \/\/ __ movl(Address(r15_thread, JavaThread::thread_state_offset()), _thread_in_native_trans);\n+  __ movl(Address(r15_thread, JavaThread::thread_state_offset()), _thread_in_native);\n+\n+  \/\/_thread->frame_anchor()->copy(&_anchor);\n+\/\/  _thread->_last_Java_fp = upcall->_last_Java_fp;\n+\/\/  _thread->_last_Java_pc = upcall->_last_Java_pc;\n+\/\/  _thread->_last_Java_sp = upcall->_last_Java_sp;\n+\n+  __ movptr(rscratch1, Address(rsp, load_offset + JavaFrameAnchor::last_Java_fp_offset()));\n+  __ movptr(Address(thread, JavaThread::last_Java_fp_offset()), rscratch1);\n+\n+  __ movptr(rscratch1, Address(rsp, load_offset + JavaFrameAnchor::last_Java_pc_offset()));\n+  __ movptr(Address(thread, JavaThread::last_Java_pc_offset()), rscratch1);\n+\n+  __ movptr(rscratch1, Address(rsp, load_offset + JavaFrameAnchor::last_Java_sp_offset()));\n+  __ movptr(Address(thread, JavaThread::last_Java_sp_offset()), rscratch1);\n+  __ block_comment(\"} restore_java_frame_anchor \");\n+}\n+\n+static void save_native_arguments(MacroAssembler* _masm, const CallRegs& conv, int arg_save_area_offset) {\n+  __ block_comment(\"{ save_native_args \");\n+  int store_offset = arg_save_area_offset;\n+  for (int i = 0; i < conv._args_length; i++) {\n+    VMReg reg = conv._arg_regs[i];\n+    if (reg->is_Register()) {\n+      __ movptr(Address(rsp, store_offset), reg->as_Register());\n+      store_offset += 8;\n+    } else if (reg->is_XMMRegister()) {\n+      \/\/ Java API doesn't support vector args\n+      __ movdqu(Address(rsp, store_offset), reg->as_XMMRegister());\n+      store_offset += 16;\n+    }\n+    \/\/ do nothing for stack\n+  }\n+  __ block_comment(\"} save_native_args \");\n+}\n+\n+static void restore_native_arguments(MacroAssembler* _masm, const CallRegs& conv, int arg_save_area_offset) {\n+  __ block_comment(\"{ restore_native_args \");\n+  int load_offset = arg_save_area_offset;\n+  for (int i = 0; i < conv._args_length; i++) {\n+    VMReg reg = conv._arg_regs[i];\n+    if (reg->is_Register()) {\n+      __ movptr(reg->as_Register(), Address(rsp, load_offset));\n+      load_offset += 8;\n+    } else if (reg->is_XMMRegister()) {\n+      \/\/ Java API doesn't support vector args\n+      __ movdqu(reg->as_XMMRegister(), Address(rsp, load_offset));\n+      load_offset += 16;\n+    }\n+    \/\/ do nothing for stack\n+  }\n+  __ block_comment(\"} restore_native_args \");\n+}\n+\n+static bool is_valid_XMM(XMMRegister reg) {\n+  return reg->is_valid() && (UseAVX >= 3 || (reg->encoding() < 16)); \/\/ why is this not covered by is_valid()?\n+}\n+\n+\/\/ for callee saved regs, according to the caller's ABI\n+static int compute_reg_save_area_size(const ABIDescriptor& abi) {\n+  int size = 0;\n+  for (Register reg = as_Register(0); reg->is_valid(); reg = reg->successor()) {\n+    if (reg == rbp || reg == rsp) continue; \/\/ saved\/restored by prologue\/epilogue\n+    if (!abi.is_volatile_reg(reg)) {\n+      size += 8; \/\/ bytes\n+    }\n+  }\n+\n+  for (XMMRegister reg = as_XMMRegister(0); is_valid_XMM(reg); reg = reg->successor()) {\n+    if (!abi.is_volatile_reg(reg)) {\n+      if (UseAVX >= 3) {\n+        size += 64; \/\/ bytes\n+      } else if (UseAVX >= 1) {\n+        size += 32;\n+      } else {\n+        size += 16;\n+      }\n+    }\n+  }\n+\n+#ifndef _WIN64\n+  \/\/ for mxcsr\n+  size += 8;\n+#endif\n+\n+  return size;\n+}\n+\n+static int compute_arg_save_area_size(const CallRegs& conv) {\n+  int result_size = 0;\n+  for (int i = 0; i < conv._args_length; i++) {\n+    VMReg reg = conv._arg_regs[i];\n+    if (reg->is_Register()) {\n+      result_size += 8;\n+    } else if (reg->is_XMMRegister()) {\n+      \/\/ Java API doesn't support vector args\n+      result_size += 16;\n+    }\n+    \/\/ do nothing for stack\n+  }\n+  return result_size;\n+}\n+\n+constexpr int MXCSR_MASK = 0xFFC0;  \/\/ Mask out any pending exceptions\n+\n+static void preserve_callee_saved_registers(MacroAssembler* _masm, const ABIDescriptor& abi, int reg_save_area_offset) {\n+  \/\/ 1. iterate all registers in the architecture\n+  \/\/     - check if they are volatile or not for the given abi\n+  \/\/     - if NOT, we need to save it here\n+  \/\/ 2. save mxcsr on non-windows platforms\n+\n+  int offset = reg_save_area_offset;\n+\n+  __ block_comment(\"{ preserve_callee_saved_regs \");\n+  for (Register reg = as_Register(0); reg->is_valid(); reg = reg->successor()) {\n+    if (reg == rbp || reg == rsp) continue; \/\/ saved\/restored by prologue\/epilogue\n+    if (!abi.is_volatile_reg(reg)) {\n+      __ movptr(Address(rsp, offset), reg);\n+      offset += 8;\n+    }\n+  }\n+\n+  for (XMMRegister reg = as_XMMRegister(0); is_valid_XMM(reg); reg = reg->successor()) {\n+    if (!abi.is_volatile_reg(reg)) {\n+      if (UseAVX >= 3) {\n+        __ evmovdqul(Address(rsp, offset), reg, Assembler::AVX_512bit);\n+        offset += 64;\n+      } else if (UseAVX >= 1) {\n+        __ vmovdqu(Address(rsp, offset), reg);\n+        offset += 32;\n+      } else {\n+        __ movdqu(Address(rsp, offset), reg);\n+        offset += 16;\n+      }\n+    }\n+  }\n+\n+#ifndef _WIN64\n+  {\n+    const Address mxcsr_save(rsp, offset);\n+    Label skip_ldmx;\n+    __ stmxcsr(mxcsr_save);\n+    __ movl(rax, mxcsr_save);\n+    __ andl(rax, MXCSR_MASK);    \/\/ Only check control and mask bits\n+    ExternalAddress mxcsr_std(StubRoutines::addr_mxcsr_std());\n+    __ cmp32(rax, mxcsr_std);\n+    __ jcc(Assembler::equal, skip_ldmx);\n+    __ ldmxcsr(mxcsr_std);\n+    __ bind(skip_ldmx);\n+  }\n+#endif\n+\n+  __ block_comment(\"} preserve_callee_saved_regs \");\n+}\n+\n+static void restore_callee_saved_registers(MacroAssembler* _masm, const ABIDescriptor& abi, int reg_save_area_offset) {\n+  \/\/ 1. iterate all registers in the architecture\n+  \/\/     - check if they are volatile or not for the given abi\n+  \/\/     - if NOT, we need to restore it here\n+  \/\/ 2. restore mxcsr on non-windows platforms\n+\n+  int offset = reg_save_area_offset;\n+\n+  __ block_comment(\"{ restore_callee_saved_regs \");\n+  for (Register reg = as_Register(0); reg->is_valid(); reg = reg->successor()) {\n+    if (reg == rbp || reg == rsp) continue; \/\/ saved\/restored by prologue\/epilogue\n+    if (!abi.is_volatile_reg(reg)) {\n+      __ movptr(reg, Address(rsp, offset));\n+      offset += 8;\n+    }\n+  }\n+\n+  for (XMMRegister reg = as_XMMRegister(0); is_valid_XMM(reg); reg = reg->successor()) {\n+    if (!abi.is_volatile_reg(reg)) {\n+      if (UseAVX >= 3) {\n+        __ evmovdqul(reg, Address(rsp, offset), Assembler::AVX_512bit);\n+        offset += 64;\n+      } else if (UseAVX >= 1) {\n+        __ vmovdqu(reg, Address(rsp, offset));\n+        offset += 32;\n+      } else {\n+        __ movdqu(reg, Address(rsp, offset));\n+        offset += 16;\n+      }\n+    }\n+  }\n+\n+#ifndef _WIN64\n+  const Address mxcsr_save(rsp, offset);\n+  __ ldmxcsr(mxcsr_save);\n+#endif\n+\n+  __ block_comment(\"} restore_callee_saved_regs \");\n+}\n+\n+static void shuffle_arguments(MacroAssembler* _masm, const GrowableArray<ArgMove>& arg_moves) {\n+  for (int i = 0; i < arg_moves.length(); i++) {\n+    ArgMove arg_mv = arg_moves.at(i);\n+    BasicType arg_bt     = arg_mv.bt;\n+    VMRegPair from_vmreg = arg_mv.from;\n+    VMRegPair to_vmreg   = arg_mv.to;\n+\n+    assert(\n+      !((from_vmreg.first()->is_Register() && to_vmreg.first()->is_XMMRegister())\n+      || (from_vmreg.first()->is_XMMRegister() && to_vmreg.first()->is_Register())),\n+       \"move between gp and fp reg not supported\");\n+\n+    __ block_comment(err_msg(\"bt=%s\", null_safe_string(type2name(arg_bt))));\n+    switch (arg_bt) {\n+      case T_BOOLEAN:\n+      case T_BYTE:\n+      case T_SHORT:\n+      case T_CHAR:\n+      case T_INT:\n+       SharedRuntime::move32_64(_masm, from_vmreg, to_vmreg);\n+       break;\n+\n+      case T_FLOAT:\n+        SharedRuntime::float_move(_masm, from_vmreg, to_vmreg);\n+        break;\n+\n+      case T_DOUBLE:\n+        SharedRuntime::double_move(_masm, from_vmreg, to_vmreg);\n+        break;\n+\n+      case T_LONG :\n+        SharedRuntime::long_move(_masm, from_vmreg, to_vmreg);\n+        break;\n+\n+      default:\n+        fatal(\"found in upcall args: %s\", type2name(arg_bt));\n+    }\n+  }\n+}\n+\n+struct AuxiliarySaves {\n+  JavaFrameAnchor jfa;\n+  uintptr_t thread;\n+  bool should_detach;\n+};\n+\n+address ProgrammableUpcallHandler::generate_optimized_upcall_stub(jobject receiver, Method* entry, jobject jabi, jobject jconv) {\n+  ResourceMark rm;\n+  const ABIDescriptor abi = ForeignGlobals::parse_abi_descriptor(jabi);\n+  const CallRegs conv = ForeignGlobals::parse_call_regs(jconv);\n+  assert(conv._rets_length <= 1, \"no multi reg returns\");\n+  CodeBuffer buffer(\"upcall_stub_linkToNative\", \/* code_size = *\/ 1024, \/* locs_size = *\/ 1024);\n+\n+  int register_size = sizeof(uintptr_t);\n+  int buffer_alignment = xmm_reg_size;\n+\n+  int out_arg_area = -1;\n+  BasicType ret_type;\n+  GrowableArray<ArgMove> arg_moves = compute_argument_shuffle(entry, out_arg_area, conv, ret_type);\n+  assert(out_arg_area != -1, \"Should have been set\");\n+  DEBUG_ONLY(print_arg_moves(arg_moves, entry);)\n+\n+  \/\/ out_arg_area (for stack arguments) doubles as shadow space for native calls.\n+  \/\/ make sure it is big enough.\n+  if (out_arg_area < frame::arg_reg_save_area_bytes) {\n+    out_arg_area = frame::arg_reg_save_area_bytes;\n+  }\n+\n+  int reg_save_area_size = compute_reg_save_area_size(abi);\n+  int arg_save_area_size = compute_arg_save_area_size(conv);\n+  \/\/ To spill receiver during deopt\n+  int deopt_spill_size = 1 * BytesPerWord;\n+\n+  int shuffle_area_offset    = 0;\n+  int deopt_spill_offset     = shuffle_area_offset    + out_arg_area;\n+  int arg_save_area_offset   = deopt_spill_offset     + deopt_spill_size;\n+  int reg_save_area_offset   = arg_save_area_offset   + arg_save_area_size;\n+  int auxiliary_saves_offset = reg_save_area_offset   + reg_save_area_size;\n+  int frame_bottom_offset    = auxiliary_saves_offset + sizeof(AuxiliarySaves);\n+\n+  ByteSize jfa_offset           = in_ByteSize(auxiliary_saves_offset) + byte_offset_of(AuxiliarySaves, jfa);\n+  ByteSize thread_offset        = in_ByteSize(auxiliary_saves_offset) + byte_offset_of(AuxiliarySaves, thread);\n+  ByteSize should_detach_offset = in_ByteSize(auxiliary_saves_offset) + byte_offset_of(AuxiliarySaves, should_detach);\n+\n+  int frame_size = frame_bottom_offset;\n+  frame_size = align_up(frame_size, StackAlignmentInBytes);\n+\n+  \/\/ Ok The space we have allocated will look like:\n+  \/\/\n+  \/\/\n+  \/\/ FP-> |                     |\n+  \/\/      |---------------------| = frame_bottom_offset = frame_size\n+  \/\/      |                     |\n+  \/\/      | AuxiliarySaves      |\n+  \/\/      |---------------------| = auxiliary_saves_offset\n+  \/\/      |                     |\n+  \/\/      | reg_save_area       |\n+  \/\/      |---------------------| = reg_save_are_offset\n+  \/\/      |                     |\n+  \/\/      | arg_save_area       |\n+  \/\/      |---------------------| = arg_save_are_offset\n+  \/\/      |                     |\n+  \/\/      | deopt_spill         |\n+  \/\/      |---------------------| = deopt_spill_offset\n+  \/\/      |                     |\n+  \/\/ SP-> | out_arg_area        |   needs to be at end for shadow space\n+  \/\/\n+  \/\/\n+\n+  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+  MacroAssembler* _masm = new MacroAssembler(&buffer);\n+  Label call_return;\n+  address start = __ pc();\n+  __ enter(); \/\/ set up frame\n+  if ((abi._stack_alignment_bytes % 16) != 0) {\n+    \/\/ stack alignment of caller is not a multiple of 16\n+    __ andptr(rsp, -StackAlignmentInBytes); \/\/ align stack\n+  }\n+  \/\/ allocate frame (frame_size is also aligned, so stack is still aligned)\n+  __ subptr(rsp, frame_size);\n+\n+  \/\/ we have to always spill args since we need to do a call to get the thread\n+  \/\/ (and maybe attach it).\n+  save_native_arguments(_masm, conv, arg_save_area_offset);\n+\n+  preserve_callee_saved_registers(_masm, abi, reg_save_area_offset);\n+\n+  __ block_comment(\"{ get_thread\");\n+  __ vzeroupper();\n+  __ lea(c_rarg0, Address(rsp, should_detach_offset));\n+  \/\/ stack already aligned\n+  __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, ProgrammableUpcallHandler::maybe_attach_and_get_thread)));\n+  __ movptr(r15_thread, rax);\n+  __ reinit_heapbase();\n+  __ movptr(Address(rsp, thread_offset), r15_thread);\n+  __ block_comment(\"} get_thread\");\n+\n+  \/\/ TODO:\n+  \/\/ We expect not to be coming from JNI code, but we might be.\n+  \/\/ We should figure out what our stance is on supporting that and then maybe add\n+  \/\/ some more handling here for:\n+  \/\/   - handle blocks\n+  \/\/   - check for active exceptions (and emit an error)\n+\n+  __ block_comment(\"{ safepoint poll\");\n+  __ movl(Address(r15_thread, JavaThread::thread_state_offset()), _thread_in_native_trans);\n+\n+  if (os::is_MP()) {\n+    __ membar(Assembler::Membar_mask_bits(\n+                Assembler::LoadLoad  | Assembler::StoreLoad |\n+                Assembler::LoadStore | Assembler::StoreStore));\n+   }\n+\n+  \/\/ check for safepoint operation in progress and\/or pending suspend requests\n+  Label L_after_safepoint_poll;\n+  Label L_safepoint_poll_slow_path;\n+\n+  __ safepoint_poll(L_safepoint_poll_slow_path, r15_thread, false \/* at_return *\/, false \/* in_nmethod *\/);\n+\n+  __ cmpl(Address(r15_thread, JavaThread::suspend_flags_offset()), 0);\n+  __ jcc(Assembler::notEqual, L_safepoint_poll_slow_path);\n+\n+  __ bind(L_after_safepoint_poll);\n+  __ block_comment(\"} safepoint poll\");\n+  \/\/ change thread state\n+  __ movl(Address(r15_thread, JavaThread::thread_state_offset()), _thread_in_Java);\n+\n+  __ block_comment(\"{ reguard stack check\");\n+  Label L_reguard;\n+  Label L_after_reguard;\n+  __ cmpl(Address(r15_thread, JavaThread::stack_guard_state_offset()), StackOverflow::stack_guard_yellow_reserved_disabled);\n+  __ jcc(Assembler::equal, L_reguard);\n+  __ bind(L_after_reguard);\n+  __ block_comment(\"} reguard stack check\");\n+\n+  __ block_comment(\"{ argument shuffle\");\n+  \/\/ TODO merge these somehow\n+  restore_native_arguments(_masm, conv, arg_save_area_offset);\n+  shuffle_arguments(_masm, arg_moves);\n+  __ block_comment(\"} argument shuffle\");\n+\n+  __ block_comment(\"{ receiver \");\n+  __ movptr(rscratch1, (intptr_t)receiver);\n+  __ resolve_jobject(rscratch1, r15_thread, rscratch2);\n+  __ movptr(j_rarg0, rscratch1);\n+  __ block_comment(\"} receiver \");\n+\n+  __ mov_metadata(rbx, entry);\n+  __ movptr(Address(r15_thread, JavaThread::callee_target_offset()), rbx); \/\/ just in case callee is deoptimized\n+  __ reinit_heapbase();\n+\n+  save_java_frame_anchor(_masm, jfa_offset, r15_thread);\n+  __ reset_last_Java_frame(r15_thread, true);\n+\n+  __ call(Address(rbx, Method::from_compiled_offset()));\n+\n+#ifdef ASSERT\n+  if (conv._rets_length == 1) { \/\/ 0 or 1\n+    VMReg j_expected_result_reg;\n+    switch (ret_type) {\n+      case T_BOOLEAN:\n+      case T_BYTE:\n+      case T_SHORT:\n+      case T_CHAR:\n+      case T_INT:\n+      case T_LONG:\n+       j_expected_result_reg = rax->as_VMReg();\n+       break;\n+      case T_FLOAT:\n+      case T_DOUBLE:\n+        j_expected_result_reg = xmm0->as_VMReg();\n+        break;\n+      default:\n+        fatal(\"unexpected return type: %s\", type2name(ret_type));\n+    }\n+    \/\/ No need to move for now, since CallArranger can pick a return type\n+    \/\/ that goes in the same reg for both CCs. But, at least assert they are the same\n+    assert(conv._ret_regs[0] == j_expected_result_reg,\n+     \"unexpected result register: %s != %s\", conv._ret_regs[0]->name(), j_expected_result_reg->name());\n+  }\n+#endif\n+\n+  __ bind(call_return);\n+\n+  \/\/ also sets last Java frame\n+  __ movptr(r15_thread, Address(rsp, thread_offset));\n+  \/\/ TODO corrupted thread pointer causes havoc. Can we verify it here?\n+  restore_java_frame_anchor(_masm, jfa_offset, r15_thread); \/\/ also transitions to native state\n+\n+  __ block_comment(\"{ maybe_detach_thread\");\n+  Label L_after_detach;\n+  __ cmpb(Address(rsp, should_detach_offset), 0);\n+  __ jcc(Assembler::equal, L_after_detach);\n+  __ vzeroupper();\n+  __ mov(c_rarg0, r15_thread);\n+  \/\/ stack already aligned\n+  __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, ProgrammableUpcallHandler::detach_thread)));\n+  __ reinit_heapbase();\n+  __ bind(L_after_detach);\n+  __ block_comment(\"} maybe_detach_thread\");\n+\n+  restore_callee_saved_registers(_masm, abi, reg_save_area_offset);\n+\n+  __ leave();\n+  __ ret(0);\n+\n+  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+  __ block_comment(\"{ L_safepoint_poll_slow_path\");\n+  __ bind(L_safepoint_poll_slow_path);\n+  __ vzeroupper();\n+  __ mov(c_rarg0, r15_thread);\n+  \/\/ stack already aligned\n+  __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, JavaThread::check_special_condition_for_native_trans)));\n+  __ reinit_heapbase();\n+  __ jmp(L_after_safepoint_poll);\n+  __ block_comment(\"} L_safepoint_poll_slow_path\");\n+\n+  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+  __ block_comment(\"{ L_reguard\");\n+  __ bind(L_reguard);\n+  __ vzeroupper();\n+  \/\/ stack already aligned\n+  __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, SharedRuntime::reguard_yellow_pages)));\n+  __ reinit_heapbase();\n+  __ jmp(L_after_reguard);\n+  __ block_comment(\"} L_reguard\");\n+\n+  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+  __ block_comment(\"{ exception handler\");\n+\n+  intptr_t exception_handler_offset = __ pc() - start;\n+\n+  \/\/ TODO: this is always the same, can we bypass and call handle_uncaught_exception directly?\n+\n+  \/\/ native caller has no idea how to handle exceptions\n+  \/\/ we just crash here. Up to callee to catch exceptions.\n+  __ verify_oop(rax);\n+  __ vzeroupper();\n+  __ mov(c_rarg0, rax);\n+  __ andptr(rsp, -StackAlignmentInBytes); \/\/ align stack as required by ABI\n+  __ subptr(rsp, frame::arg_reg_save_area_bytes); \/\/ windows (not really needed)\n+  __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, ProgrammableUpcallHandler::handle_uncaught_exception)));\n+  __ should_not_reach_here();\n+\n+  __ block_comment(\"} exception handler\");\n+\n+  _masm->flush();\n+\n+\n+#ifndef PRODUCT\n+  stringStream ss;\n+  ss.print(\"optimized_upcall_stub_%s\", entry->signature()->as_C_string());\n+  const char* name = _masm->code_string(ss.as_string());\n+#else \/\/ PRODUCT\n+  const char* name = \"optimized_upcall_stub\";\n+#endif \/\/ PRODUCT\n+\n+  OptimizedEntryBlob* blob = OptimizedEntryBlob::create(name, &buffer, exception_handler_offset, receiver, jfa_offset);\n+\n+  if (TraceOptimizedUpcallStubs) {\n+    blob->print_on(tty);\n+    Disassembler::decode(blob, tty);\n+  }\n+\n+  return blob->code_begin();\n+}\n+\n+bool ProgrammableUpcallHandler::supports_optimized_upcalls() {\n+  return true;\n+}\n","filename":"src\/hotspot\/cpu\/x86\/universalUpcallHandler_x86_64.cpp","additions":707,"deletions":0,"binary":false,"changes":707,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -63,5 +63,0 @@\n-address ciNativeEntryPoint::entry_point() const {\n-  VM_ENTRY_MARK;\n-  return jdk_internal_invoke_NativeEntryPoint::addr(get_oop());\n-}\n-\n","filename":"src\/hotspot\/share\/ci\/ciNativeEntryPoint.cpp","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,1 +47,0 @@\n-  address        entry_point() const;\n","filename":"src\/hotspot\/share\/ci\/ciNativeEntryPoint.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -3893,1 +3893,0 @@\n-int jdk_internal_invoke_NativeEntryPoint::_addr_offset;\n@@ -3902,1 +3901,0 @@\n-  macro(_addr_offset,            k, \"addr\",           long_signature, false); \\\n@@ -3925,4 +3923,0 @@\n-address jdk_internal_invoke_NativeEntryPoint::addr(oop entry) {\n-  return (address)entry->long_field(_addr_offset);\n-}\n-\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1046,1 +1046,0 @@\n-  static int _addr_offset;  \/\/ type is jlong\n@@ -1060,1 +1059,0 @@\n-  static address    addr(oop entry);\n@@ -1076,1 +1074,0 @@\n-  static int addr_offset_in_bytes()            { return _addr_offset;            }\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -349,1 +349,1 @@\n-  \/* Panama Support *\/                                                                                          \\\n+  \/* Foreign API Support *\/                                                                                          \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -712,0 +712,27 @@\n+\n+\/\/ Implementation of OptimizedEntryBlob\n+\n+OptimizedEntryBlob::OptimizedEntryBlob(const char* name, int size, CodeBuffer* cb, intptr_t exception_handler_offset,\n+                     jobject receiver, ByteSize jfa_sp_offset) :\n+  BufferBlob(name, size, cb),\n+  _exception_handler_offset(exception_handler_offset),\n+  _receiver(receiver),\n+  _jfa_sp_offset(jfa_sp_offset) {\n+  CodeCache::commit(this);\n+}\n+\n+OptimizedEntryBlob* OptimizedEntryBlob::create(const char* name, CodeBuffer* cb, intptr_t exception_handler_offset,\n+                             jobject receiver, ByteSize jfa_sp_offset) {\n+  ThreadInVMfromUnknown __tiv;  \/\/ get to VM state in case we block on CodeCache_lock\n+\n+  OptimizedEntryBlob* blob = nullptr;\n+  unsigned int size = CodeBlob::allocation_size(cb, sizeof(OptimizedEntryBlob));\n+  {\n+    MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);\n+    blob = new (size) OptimizedEntryBlob(name, size, cb, exception_handler_offset, receiver, jfa_sp_offset);\n+  }\n+  \/\/ Track memory usage statistic after releasing CodeCache_lock\n+  MemoryService::track_code_cache_memory_usage();\n+\n+  return blob;\n+}\n","filename":"src\/hotspot\/share\/code\/codeBlob.cpp","additions":27,"deletions":0,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -61,0 +61,1 @@\n+\/\/    OptimizedEntryBlob : Used for upcalls from native code\n@@ -78,0 +79,2 @@\n+class OptimizedEntryBlob; \/\/ for as_optimized_entry_blob()\n+class JavaFrameAnchor; \/\/ for EntryBlob::jfa_for_frame\n@@ -139,0 +142,1 @@\n+  virtual bool is_optimized_entry_blob() const                  { return false; }\n@@ -152,0 +156,1 @@\n+  OptimizedEntryBlob* as_optimized_entry_blob() const             { assert(is_optimized_entry_blob(), \"must be entry blob\"); return (OptimizedEntryBlob*) this; }\n@@ -382,0 +387,1 @@\n+  friend class OptimizedEntryBlob;\n@@ -721,0 +727,29 @@\n+\/\/----------------------------------------------------------------------------------------------------\n+\n+\/\/ For optimized upcall stubs\n+class OptimizedEntryBlob: public BufferBlob {\n+ private:\n+  intptr_t _exception_handler_offset;\n+  jobject _receiver;\n+  ByteSize _jfa_sp_offset;\n+\n+  OptimizedEntryBlob(const char* name, int size, CodeBuffer* cb, intptr_t exception_handler_offset,\n+            jobject receiver, ByteSize jfa_sp_offset);\n+\n+ public:\n+  \/\/ Creation\n+  static OptimizedEntryBlob* create(const char* name, CodeBuffer* cb,\n+                           intptr_t exception_handler_offset, jobject receiver,\n+                           ByteSize jfa_sp_offset);\n+\n+  address exception_handler() { return code_begin() + _exception_handler_offset; }\n+  jobject receiver() { return _receiver; }\n+  ByteSize jfa_sp_offset() const { return _jfa_sp_offset; }\n+\n+  \/\/ defined in frame_ARCH.cpp\n+  JavaFrameAnchor* jfa_for_frame(const frame& frame) const;\n+\n+  \/\/ Typing\n+  virtual bool is_optimized_entry_blob() const override { return true; }\n+};\n+\n","filename":"src\/hotspot\/share\/code\/codeBlob.hpp","additions":35,"deletions":0,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -76,0 +76,1 @@\n+  DEBUG_ONLY(LOG_TAG(foreign)) \\\n","filename":"src\/hotspot\/share\/logging\/logTag.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -421,2 +421,3 @@\n-  CallGenerator* cg = for_method_handle_inline(jvms, _caller, method(), allow_inline, _input_not_const);\n-  assert(!_input_not_const, \"sanity\"); \/\/ shouldn't have been scheduled for inlining in the first place\n+  bool input_not_const = true;\n+  CallGenerator* cg = for_method_handle_inline(jvms, _caller, method(), allow_inline, input_not_const);\n+  assert(!input_not_const, \"sanity\"); \/\/ shouldn't have been scheduled for inlining in the first place\n@@ -1057,0 +1058,1 @@\n+  address _call_addr;\n@@ -1059,2 +1061,2 @@\n-  NativeCallGenerator(ciMethod* m, ciNativeEntryPoint* nep)\n-   : CallGenerator(m), _nep(nep) {}\n+  NativeCallGenerator(ciMethod* m, address call_addr, ciNativeEntryPoint* nep)\n+   : CallGenerator(m), _call_addr(call_addr), _nep(nep) {}\n@@ -1068,1 +1070,1 @@\n-  Node* call = kit.make_native_call(tf(), method()->arg_size(), _nep); \/\/ -fallback, - nep\n+  Node* call = kit.make_native_call(_call_addr, tf(), method()->arg_size(), _nep); \/\/ -fallback, - nep\n@@ -1072,1 +1074,0 @@\n-  address addr = _nep->entry_point();\n@@ -1074,1 +1075,1 @@\n-    kit.C->log()->elem(\"l2n_intrinsification_success bci='%d' entry_point='\" INTPTR_FORMAT \"'\", jvms->bci(), p2i(addr));\n+    kit.C->log()->elem(\"l2n_intrinsification_success bci='%d' entry_point='\" INTPTR_FORMAT \"'\", jvms->bci(), p2i(_call_addr));\n@@ -1207,2 +1208,4 @@\n-      Node* nep = kit.argument(callee->arg_size() - 1);\n-      if (nep->Opcode() == Op_ConP) {\n+      Node* addr_n = kit.argument(1); \/\/ target address\n+      Node* nep_n = kit.argument(callee->arg_size() - 1); \/\/ NativeEntryPoint\n+      \/\/ This check needs to be kept in sync with the one in CallStaticJavaNode::Ideal\n+      if (addr_n->Opcode() == Op_ConL && nep_n->Opcode() == Op_ConP) {\n@@ -1210,3 +1213,5 @@\n-        const TypeOopPtr* oop_ptr = nep->bottom_type()->is_oopptr();\n-        ciNativeEntryPoint* nep = oop_ptr->const_oop()->as_native_entry_point();\n-        return new NativeCallGenerator(callee, nep);\n+        const TypeLong* addr_t = addr_n->bottom_type()->is_long();\n+        const TypeOopPtr* nep_t = nep_n->bottom_type()->is_oopptr();\n+        address addr = (address) addr_t->get_con();\n+        ciNativeEntryPoint* nep = nep_t->const_oop()->as_native_entry_point();\n+        return new NativeCallGenerator(callee, addr, nep);\n","filename":"src\/hotspot\/share\/opto\/callGenerator.cpp","additions":17,"deletions":12,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -1069,0 +1069,6 @@\n+    } else if (iid == vmIntrinsics::_linkToNative) {\n+      if (in(TypeFunc::Parms + callee->arg_size() - 1)->Opcode() == Op_ConP \/* NEP *\/\n+          && in(TypeFunc::Parms + 1)->Opcode() == Op_ConL \/* address *\/) {\n+        phase->C->prepend_late_inline(cg);\n+        set_generator(NULL);\n+      }\n","filename":"src\/hotspot\/share\/opto\/callnode.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2586,2 +2586,7 @@\n-Node* GraphKit::make_native_call(const TypeFunc* call_type, uint nargs, ciNativeEntryPoint* nep) {\n-  uint n_filtered_args = nargs - 2; \/\/ -fallback, -nep;\n+Node* GraphKit::make_native_call(address call_addr, const TypeFunc* call_type, uint nargs, ciNativeEntryPoint* nep) {\n+  \/\/ Select just the actual call args to pass on\n+  \/\/ [MethodHandle fallback, long addr, HALF addr, ... args , NativeEntryPoint nep]\n+  \/\/                                             |          |\n+  \/\/                                             V          V\n+  \/\/                                             [ ... args ]\n+  uint n_filtered_args = nargs - 4; \/\/ -fallback, -addr (2), -nep;\n@@ -2597,1 +2602,1 @@\n-      uint vm_unfiltered_arg_pos = vm_arg_pos + 1; \/\/ +1 to skip fallback handle argument\n+      uint vm_unfiltered_arg_pos = vm_arg_pos + 3; \/\/ +3 to skip fallback handle argument and addr (2 since long)\n@@ -2633,1 +2638,0 @@\n-  address call_addr = nep->entry_point();\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -805,1 +805,1 @@\n-  Node* make_native_call(const TypeFunc* call_type, uint nargs, ciNativeEntryPoint* nep);\n+  Node* make_native_call(address call_addr, const TypeFunc* call_type, uint nargs, ciNativeEntryPoint* nep);\n","filename":"src\/hotspot\/share\/opto\/graphKit.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -883,1 +883,1 @@\n-      \/\/ We use the c reg save policy here since Panama\n+      \/\/ We use the c reg save policy here since Foreign Linker\n","filename":"src\/hotspot\/share\/opto\/lcm.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -62,0 +62,4 @@\n+const CallRegs ForeignGlobals::parse_call_regs(jobject jconv) {\n+  return instance().parse_call_regs_impl(jconv);\n+}\n+\n@@ -68,5 +72,5 @@\n-  const char* strVMSArray = \"[[L\" FOREIGN_ABI \"VMStorage;\";\n-  Symbol* symVMSArray = SymbolTable::new_symbol(strVMSArray, (int)strlen(strVMSArray));\n-  ABI.inputStorage_offset = field_offset(k_ABI, \"inputStorage\", symVMSArray);\n-  ABI.outputStorage_offset = field_offset(k_ABI, \"outputStorage\", symVMSArray);\n-  ABI.volatileStorage_offset = field_offset(k_ABI, \"volatileStorage\", symVMSArray);\n+  const char* strVMSArrayArray = \"[[L\" FOREIGN_ABI \"VMStorage;\";\n+  Symbol* symVMSArrayArray = SymbolTable::new_symbol(strVMSArrayArray);\n+  ABI.inputStorage_offset = field_offset(k_ABI, \"inputStorage\", symVMSArrayArray);\n+  ABI.outputStorage_offset = field_offset(k_ABI, \"outputStorage\", symVMSArrayArray);\n+  ABI.volatileStorage_offset = field_offset(k_ABI, \"volatileStorage\", symVMSArrayArray);\n@@ -79,0 +83,1 @@\n+  VMS.type_offset = field_offset(k_VMS, \"type\", vmSymbols::int_signature());\n@@ -88,0 +93,37 @@\n+\n+  \/\/ CallRegs\n+  const char* strVMSArray = \"[L\" FOREIGN_ABI \"VMStorage;\";\n+  Symbol* symVMSArray = SymbolTable::new_symbol(strVMSArray);\n+  InstanceKlass* k_CC = find_InstanceKlass(FOREIGN_ABI \"ProgrammableUpcallHandler$CallRegs\", current_thread);\n+  CallConvOffsets.arg_regs_offset = field_offset(k_CC, \"argRegs\", symVMSArray);\n+  CallConvOffsets.ret_regs_offset = field_offset(k_CC, \"retRegs\", symVMSArray);\n+}\n+\n+void CallRegs::calling_convention(BasicType* sig_bt, VMRegPair *parm_regs, uint argcnt) const {\n+  int src_pos = 0;\n+  for (uint i = 0; i < argcnt; i++) {\n+    switch (sig_bt[i]) {\n+      case T_BOOLEAN:\n+      case T_CHAR:\n+      case T_BYTE:\n+      case T_SHORT:\n+      case T_INT:\n+      case T_FLOAT:\n+        assert(src_pos < _args_length, \"oob\");\n+        parm_regs[i].set1(_arg_regs[src_pos++]);\n+        break;\n+      case T_LONG:\n+      case T_DOUBLE:\n+        assert((i + 1) < argcnt && sig_bt[i + 1] == T_VOID, \"expecting half\");\n+        assert(src_pos < _args_length, \"oob\");\n+        parm_regs[i].set2(_arg_regs[src_pos++]);\n+        break;\n+      case T_VOID: \/\/ Halves of longs and doubles\n+        assert(i != 0 && (sig_bt[i - 1] == T_LONG || sig_bt[i - 1] == T_DOUBLE), \"expecting half\");\n+        parm_regs[i].set_bad();\n+        break;\n+      default:\n+        ShouldNotReachHere();\n+        break;\n+    }\n+  }\n","filename":"src\/hotspot\/share\/prims\/foreign_globals.cpp","additions":47,"deletions":5,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"code\/vmreg.hpp\"\n@@ -33,0 +34,10 @@\n+struct CallRegs {\n+  VMReg* _arg_regs;\n+  int _args_length;\n+\n+  VMReg* _ret_regs;\n+  int _rets_length;\n+\n+  void calling_convention(BasicType* sig_bt, VMRegPair *parm_regs, uint argcnt) const;\n+};\n+\n@@ -45,0 +56,1 @@\n+    int type_offset;\n@@ -56,0 +68,5 @@\n+  struct {\n+    int arg_regs_offset;\n+    int ret_regs_offset;\n+  } CallConvOffsets;\n+\n@@ -68,0 +85,1 @@\n+  const CallRegs parse_call_regs_impl(jobject jconv) const;\n@@ -71,0 +89,1 @@\n+  static const CallRegs parse_call_regs(jobject jconv);\n","filename":"src\/hotspot\/share\/prims\/foreign_globals.hpp","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -40,1 +40,2 @@\n-JNI_LEAF(void, JVM_RegisterNativeEntryPointMethods(JNIEnv *env, jclass NEP_class))\n+JNI_ENTRY(void, JVM_RegisterNativeEntryPointMethods(JNIEnv *env, jclass NEP_class))\n+  ThreadToNativeFromVM ttnfv(thread);\n","filename":"src\/hotspot\/share\/prims\/nativeEntryPoint.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -62,1 +62,2 @@\n-JNI_LEAF(void, JVM_RegisterProgrammableInvokerMethods(JNIEnv *env, jclass PI_class))\n+JNI_ENTRY(void, JVM_RegisterProgrammableInvokerMethods(JNIEnv *env, jclass PI_class))\n+  ThreadToNativeFromVM ttnfv(thread);\n","filename":"src\/hotspot\/share\/prims\/universalNativeInvoker.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+#include \"classfile\/javaClasses.hpp\"\n@@ -27,0 +28,1 @@\n+#include \"compiler\/compilationPolicy.hpp\"\n@@ -52,1 +54,1 @@\n-void ProgrammableUpcallHandler::attach_thread_and_do_upcall(jobject rec, address buff) {\n+Thread* ProgrammableUpcallHandler::maybe_attach_and_get_thread(bool* should_detach) {\n@@ -54,1 +56,0 @@\n-  bool should_detach = false;\n@@ -60,1 +61,1 @@\n-    should_detach = true;\n+    *should_detach = true;\n@@ -62,0 +63,2 @@\n+  } else {\n+    *should_detach = false;\n@@ -63,0 +66,11 @@\n+  return thread;\n+}\n+\n+void ProgrammableUpcallHandler::detach_thread(Thread* thread) {\n+  JavaVM_ *vm = (JavaVM *)(&main_vm);\n+  vm->functions->DetachCurrentThread(vm);\n+}\n+\n+void ProgrammableUpcallHandler::attach_thread_and_do_upcall(jobject rec, address buff) {\n+  bool should_detach = false;\n+  Thread* thread = maybe_attach_and_get_thread(&should_detach);\n@@ -70,2 +84,1 @@\n-    JavaVM_ *vm = (JavaVM *)(&main_vm);\n-    vm->functions->DetachCurrentThread(vm);\n+    detach_thread(thread);\n@@ -89,1 +102,1 @@\n-  upcall_method.sig = SymbolTable::new_symbol(\"(L\" FOREIGN_ABI \"ProgrammableUpcallHandler;J)V\");\n+  upcall_method.sig = SymbolTable::new_symbol(\"(Ljava\/lang\/invoke\/MethodHandle;J)V\");\n@@ -96,1 +109,8 @@\n-JNI_ENTRY(jlong, PUH_AllocateUpcallStub(JNIEnv *env, jobject rec, jobject abi, jobject buffer_layout))\n+void ProgrammableUpcallHandler::handle_uncaught_exception(oop exception) {\n+  \/\/ Based on CATCH macro\n+  tty->print_cr(\"Uncaught exception:\");\n+  exception->print();\n+  ShouldNotReachHere();\n+}\n+\n+JVM_ENTRY(jlong, PUH_AllocateUpcallStub(JNIEnv *env, jclass unused, jobject rec, jobject abi, jobject buffer_layout))\n@@ -102,0 +122,19 @@\n+JVM_ENTRY(jlong, PUH_AllocateOptimizedUpcallStub(JNIEnv *env, jclass unused, jobject mh, jobject abi, jobject conv))\n+  Handle mh_h(THREAD, JNIHandles::resolve(mh));\n+  jobject mh_j = JNIHandles::make_global(mh_h);\n+\n+  oop lform = java_lang_invoke_MethodHandle::form(mh_h());\n+  oop vmentry = java_lang_invoke_LambdaForm::vmentry(lform);\n+  Method* entry = java_lang_invoke_MemberName::vmtarget(vmentry);\n+  const methodHandle mh_entry(THREAD, entry);\n+\n+  assert(entry->method_holder()->is_initialized(), \"no clinit barrier\");\n+  CompilationPolicy::compile_if_required(mh_entry, CHECK_0);\n+\n+  return (jlong) ProgrammableUpcallHandler::generate_optimized_upcall_stub(mh_j, entry, abi, conv);\n+JVM_END\n+\n+JVM_ENTRY(jboolean, PUH_SupportsOptimizedUpcalls(JNIEnv *env, jclass unused))\n+  return (jboolean) ProgrammableUpcallHandler::supports_optimized_upcalls();\n+JVM_END\n+\n@@ -106,1 +145,3 @@\n-  {CC \"allocateUpcallStub\", CC \"(L\" FOREIGN_ABI \"ABIDescriptor;L\" FOREIGN_ABI \"BufferLayout;\" \")J\", FN_PTR(PUH_AllocateUpcallStub)},\n+  {CC \"allocateUpcallStub\", CC \"(\" \"Ljava\/lang\/invoke\/MethodHandle;\" \"L\" FOREIGN_ABI \"ABIDescriptor;\" \"L\" FOREIGN_ABI \"BufferLayout;\" \")J\", FN_PTR(PUH_AllocateUpcallStub)},\n+  {CC \"allocateOptimizedUpcallStub\", CC \"(\" \"Ljava\/lang\/invoke\/MethodHandle;\" \"L\" FOREIGN_ABI \"ABIDescriptor;\" \"L\" FOREIGN_ABI \"ProgrammableUpcallHandler$CallRegs;\" \")J\", FN_PTR(PUH_AllocateOptimizedUpcallStub)},\n+  {CC \"supportsOptimizedUpcalls\", CC \"()Z\", FN_PTR(PUH_SupportsOptimizedUpcalls)},\n@@ -112,1 +153,2 @@\n-JNI_LEAF(void, JVM_RegisterProgrammableUpcallHandlerMethods(JNIEnv *env, jclass PUH_class))\n+JNI_ENTRY(void, JVM_RegisterProgrammableUpcallHandlerMethods(JNIEnv *env, jclass PUH_class))\n+  ThreadToNativeFromVM ttnfv(thread);\n","filename":"src\/hotspot\/share\/prims\/universalUpcallHandler.cpp","additions":51,"deletions":9,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -48,0 +48,4 @@\n+\n+  static void handle_uncaught_exception(oop exception);\n+  static Thread* maybe_attach_and_get_thread(bool* should_detach);\n+  static void detach_thread(Thread* thread);\n@@ -49,0 +53,1 @@\n+  static address generate_optimized_upcall_stub(jobject mh, Method* entry, jobject jabi, jobject jconv);\n@@ -50,0 +55,1 @@\n+  static bool supports_optimized_upcalls();\n","filename":"src\/hotspot\/share\/prims\/universalUpcallHandler.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -39,2 +39,8 @@\n-  jobject* rec_ptr = (jobject*)(void*)cb -> content_begin();\n-  JNIHandles::destroy_global(*rec_ptr);\n+  jobject handle = NULL;\n+  if (cb->is_optimized_entry_blob()) {\n+    handle = ((OptimizedEntryBlob*)cb)->receiver();\n+  } else {\n+    jobject* handle_ptr = (jobject*)(void*)cb->content_begin();\n+    handle = *handle_ptr;\n+  }\n+  JNIHandles::destroy_global(handle);\n","filename":"src\/hotspot\/share\/prims\/upcallStubs.cpp","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2303,1 +2303,1 @@\n-WB_ENTRY(void, WB_VerifyFrames(JNIEnv* env, jobject wb, jboolean log))\n+WB_ENTRY(void, WB_VerifyFrames(JNIEnv* env, jobject wb, jboolean log, jboolean update_map))\n@@ -2309,1 +2309,1 @@\n-  for (StackFrameStream fst(JavaThread::current(), true, true); !fst.is_done(); fst.next()) {\n+  for (StackFrameStream fst(JavaThread::current(), update_map, true); !fst.is_done(); fst.next()) {\n@@ -2569,1 +2569,1 @@\n-  {CC\"verifyFrames\",                CC\"(Z)V\",            (void*)&WB_VerifyFrames },\n+  {CC\"verifyFrames\",                CC\"(ZZ)V\",            (void*)&WB_VerifyFrames },\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -312,0 +312,2 @@\n+#define ENABLE_NATIVE_ACCESS \"enable.native.access\"\n+#define ENABLE_NATIVE_ACCESS_LEN 20\n@@ -350,1 +352,2 @@\n-        matches_property_suffix(property_suffix, UPGRADE_PATH, UPGRADE_PATH_LEN)) {\n+        matches_property_suffix(property_suffix, UPGRADE_PATH, UPGRADE_PATH_LEN) ||\n+        matches_property_suffix(property_suffix, ENABLE_NATIVE_ACCESS, ENABLE_NATIVE_ACCESS_LEN)) {\n@@ -1968,0 +1971,1 @@\n+unsigned int enable_native_access_count = 0;\n@@ -2411,0 +2415,4 @@\n+    } else if (match_option(option, \"--enable-native-access=\", &tail)) {\n+      if (!create_numbered_module_property(\"jdk.module.enable.native.access\", tail, enable_native_access_count++)) {\n+        return JNI_ENOMEM;\n+      }\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -161,1 +161,1 @@\n-  \/\/ Unsafe to use the is_deoptimzed tester after changing pc\n+  \/\/ Unsafe to use the is_deoptimized tester after changing pc\n@@ -1070,0 +1070,4 @@\n+  } else if (is_optimized_entry_frame()) {\n+   \/\/ Nothing to do\n+   \/\/ receiver is a global ref\n+   \/\/ handle block is for JNI\n@@ -1108,1 +1112,3 @@\n-  oops_do_internal(&VerifyOopClosure::verify_oop, NULL, map, false, DerivedPointerIterationMode::_ignore);\n+  if (map->update_map()) { \/\/ The map has to be up-to-date for the current frame\n+    oops_do_internal(&VerifyOopClosure::verify_oop, NULL, map, false, DerivedPointerIterationMode::_ignore);\n+  }\n","filename":"src\/hotspot\/share\/runtime\/frame.cpp","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -141,0 +141,1 @@\n+  bool is_optimized_entry_frame()         const;\n@@ -175,0 +176,1 @@\n+  frame sender_for_optimized_entry_frame(RegisterMap* map) const;\n","filename":"src\/hotspot\/share\/runtime\/frame.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -55,0 +55,4 @@\n+inline bool frame::is_optimized_entry_frame() const {\n+  return _cb != NULL && _cb->is_optimized_entry_blob();\n+}\n+\n","filename":"src\/hotspot\/share\/runtime\/frame.inline.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2077,0 +2077,3 @@\n+                                                                            \\\n+  develop(bool, TraceOptimizedUpcallStubs, false,                              \\\n+                \"Trace optimized upcall stub generation\")                      \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -767,1 +767,0 @@\n-\n","filename":"src\/hotspot\/share\/runtime\/reflection.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -515,0 +515,3 @@\n+  if (blob != NULL && blob->is_optimized_entry_blob()) {\n+    return ((OptimizedEntryBlob*)blob)->exception_handler();\n+  }\n@@ -1443,1 +1446,1 @@\n-  assert(!caller_frame.is_interpreted_frame() && !caller_frame.is_entry_frame(), \"unexpected frame\");\n+  assert(!caller_frame.is_interpreted_frame() && !caller_frame.is_entry_frame() && !caller_frame.is_optimized_entry_frame(), \"unexpected frame\");\n@@ -1475,1 +1478,2 @@\n-      caller_frame.is_entry_frame()) {\n+      caller_frame.is_entry_frame() ||\n+      caller_frame.is_optimized_entry_frame()) {\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -465,0 +465,5 @@\n+  static void   move32_64(MacroAssembler* masm, VMRegPair src, VMRegPair dst);\n+  static void   long_move(MacroAssembler* masm, VMRegPair src, VMRegPair dst);\n+  static void  float_move(MacroAssembler* masm, VMRegPair src, VMRegPair dst);\n+  static void double_move(MacroAssembler* masm, VMRegPair src, VMRegPair dst);\n+\n@@ -516,0 +521,6 @@\n+  static void compute_move_order(const BasicType* in_sig_bt,\n+                                 int total_in_args, const VMRegPair* in_regs,\n+                                 int total_out_args, VMRegPair* out_regs,\n+                                 GrowableArray<int>& arg_order,\n+                                 VMRegPair tmp_vmreg);\n+\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.hpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -59,1 +59,0 @@\n-import jdk.internal.misc.VM;\n@@ -114,0 +113,2 @@\n+    \/\/ true, if this module allows restricted native access\n+    private volatile boolean enableNativeAccess;\n@@ -138,0 +139,4 @@\n+        if (loader == null || loader == ClassLoaders.platformClassLoader()) {\n+            \/\/ boot\/builtin modules are always native\n+            implAddEnableNativeAccess();\n+        }\n@@ -140,1 +145,0 @@\n-\n@@ -153,1 +157,0 @@\n-\n@@ -249,0 +252,24 @@\n+    \/**\n+     * Update this module to allow access to restricted methods.\n+     *\/\n+    Module implAddEnableNativeAccess() {\n+        enableNativeAccess = true;\n+        return this;\n+    }\n+\n+    \/**\n+     * Update all unnamed modules to allow access to restricted methods.\n+     *\/\n+    static void implAddEnableNativeAccessAllUnnamed() {\n+        ALL_UNNAMED_MODULE.enableNativeAccess = true;\n+    }\n+\n+    \/**\n+     * Returns true if module m can access restricted methods.\n+     *\/\n+    boolean implIsEnableNativeAccess() {\n+        return isNamed() ?\n+                enableNativeAccess :\n+                ALL_UNNAMED_MODULE.enableNativeAccess;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Module.java","additions":30,"deletions":3,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -65,1 +65,0 @@\n-\n@@ -2277,0 +2276,9 @@\n+            public Module addEnableNativeAccess(Module m) {\n+                return m.implAddEnableNativeAccess();\n+            }\n+            public void addEnableNativeAccessAllUnnamed() {\n+                Module.implAddEnableNativeAccessAllUnnamed();\n+            }\n+            public boolean isEnableNativeAccess(Module m) {\n+                return m.implIsEnableNativeAccess();\n+            }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1446,0 +1446,5 @@\n+            @Override\n+            public void ensureCustomized(MethodHandle mh) {\n+                mh.customize();\n+            }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleImpl.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -61,1 +61,1 @@\n-            throw new IllegalArgumentException(\"Type of fallback must match\");\n+            throw new IllegalArgumentException(\"Type of fallback must match: \" + type + \" != \" + fallback.type());\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/NativeMethodHandle.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,1 @@\n+import jdk.internal.misc.ScopedMemoryAccess.Scope;\n@@ -824,0 +825,12 @@\n+                @Override\n+                public Scope.Handle acquireScope(Buffer buffer, boolean async) {\n+                    var scope = buffer.scope();\n+                    if (scope == null) {\n+                        return null;\n+                    }\n+                    if (async && scope.ownerThread() != null) {\n+                        throw new IllegalStateException(\"Confined scope not supported\");\n+                    }\n+                    return scope.acquire();\n+                }\n+\n","filename":"src\/java.base\/share\/classes\/java\/nio\/Buffer.java","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -259,0 +259,15 @@\n+    \/**\n+     * Updates module m to allow access to restricted methods.\n+     *\/\n+    Module addEnableNativeAccess(Module m);\n+\n+    \/**\n+     * Updates all unnamed modules to allow access to restricted methods.\n+     *\/\n+    void addEnableNativeAccessAllUnnamed();\n+\n+    \/**\n+     * Returns true if module m can access restricted methods.\n+     *\/\n+    boolean isEnableNativeAccess(Module m);\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangAccess.java","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -135,0 +135,7 @@\n+\n+    \/**\n+     * Ensure given method handle is customized\n+     *\n+     * @param mh the method handle\n+     *\/\n+    void ensureCustomized(MethodHandle mh);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangInvokeAccess.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+import jdk.internal.misc.ScopedMemoryAccess.Scope;\n@@ -88,0 +89,8 @@\n+    \/**\n+     * Used by I\/O operations to make a buffer's resource scope non-closeable\n+     * (for the duration of the I\/O operation) by acquiring a new resource\n+     * scope handle. Null is returned if the buffer has no scope, or\n+     * acquiring is not required to guarantee safety.\n+     *\/\n+    Scope.Handle acquireScope(Buffer buffer, boolean async);\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaNioAccess.java","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,2 +40,0 @@\n-    private final long addr;\n-\n@@ -52,1 +50,1 @@\n-    private NativeEntryPoint(long addr, int shadowSpace, long[] argMoves, long[] returnMoves,\n+    private NativeEntryPoint(int shadowSpace, long[] argMoves, long[] returnMoves,\n@@ -54,1 +52,0 @@\n-        this.addr = addr;\n@@ -63,1 +60,2 @@\n-    public static NativeEntryPoint make(long addr, String name, ABIDescriptorProxy abi, VMStorageProxy[] argMoves, VMStorageProxy[] returnMoves,\n+    public static NativeEntryPoint make(String name, ABIDescriptorProxy abi,\n+                                        VMStorageProxy[] argMoves, VMStorageProxy[] returnMoves,\n@@ -69,2 +67,2 @@\n-        return new NativeEntryPoint(\n-            addr, abi.shadowSpaceBytes(), encodeVMStorages(argMoves), encodeVMStorages(returnMoves), needTransition, methodType, name);\n+        return new NativeEntryPoint(abi.shadowSpaceBytes(), encodeVMStorages(argMoves), encodeVMStorages(returnMoves),\n+                needTransition, methodType, name);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/invoke\/NativeEntryPoint.java","additions":6,"deletions":8,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -65,1 +65,3 @@\n-        UNNAMED_MODULE = SharedSecrets.getJavaLangAccess().defineUnnamedModule(null);\n+        JavaLangAccess jla = SharedSecrets.getJavaLangAccess();\n+        UNNAMED_MODULE = jla.defineUnnamedModule(null);\n+        jla.addEnableNativeAccess(UNNAMED_MODULE);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/loader\/BootLoader.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -74,1 +74,1 @@\n-    private static Unsafe UNSAFE = Unsafe.getUnsafe();\n+    private static final Unsafe UNSAFE = Unsafe.getUnsafe();\n@@ -100,0 +100,5 @@\n+\n+       interface Handle {\n+            Scope scope();\n+        }\n+\n@@ -104,0 +109,6 @@\n+        boolean isImplicit();\n+\n+        Handle acquire();\n+\n+        void release(Handle handle);\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/X-ScopedMemoryAccess.java.template","additions":13,"deletions":2,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -271,1 +271,3 @@\n-        Modules.defineModule(null, base.descriptor(), baseUri);\n+\n+        Module baseModule = Modules.defineModule(null, base.descriptor(), baseUri);\n+        JLA.addEnableNativeAccess(baseModule);\n@@ -471,0 +473,3 @@\n+        \/\/ add enable native access\n+        addEnableNativeAccess(bootLayer);\n+\n@@ -872,0 +877,41 @@\n+    \/**\n+     * Process the --enable-native-access option to grant access to restricted methods to selected modules.\n+     *\/\n+    private static void addEnableNativeAccess(ModuleLayer layer) {\n+        for (String name : decodeEnableNativeAccess()) {\n+            if (name.equals(\"ALL-UNNAMED\")) {\n+                JLA.addEnableNativeAccessAllUnnamed();\n+            } else {\n+                Optional<Module> module = layer.findModule(name);\n+                if (module.isPresent()) {\n+                    JLA.addEnableNativeAccess(module.get());\n+                } else {\n+                    warnUnknownModule(ENABLE_NATIVE_ACCESS, name);\n+                }\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Returns the set of module names specified by --enable-native-access options.\n+     *\/\n+    private static Set<String> decodeEnableNativeAccess() {\n+        String prefix = \"jdk.module.enable.native.access.\";\n+        int index = 0;\n+        \/\/ the system property is removed after decoding\n+        String value = getAndRemoveProperty(prefix + index);\n+        Set<String> modules = new HashSet<>();\n+        if (value == null) {\n+            return modules;\n+        }\n+        while (value != null) {\n+            for (String s : value.split(\",\")) {\n+                if (!s.isEmpty())\n+                    modules.add(s);\n+            }\n+            index++;\n+            value = getAndRemoveProperty(prefix + index);\n+        }\n+        return modules;\n+    }\n+\n@@ -995,1 +1041,1 @@\n-\n+    private static final String ENABLE_NATIVE_ACCESS = \"--enable-native-access\";\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/module\/ModuleBootstrap.java","additions":48,"deletions":2,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -109,0 +109,7 @@\n+    public static void ensureNativeAccess(Class<?> currentClass) {\n+        Module module = currentClass.getModule();\n+        if (!SharedSecrets.getJavaLangAccess().isEnableNativeAccess(module)) {\n+            throw new IllegalCallerException(\"Illegal native access from: \" + module);\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/Reflection.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -215,1 +215,2 @@\n-        jdk.jpackage;\n+        jdk.jpackage,\n+        jdk.incubator.foreign;\n@@ -231,1 +232,2 @@\n-        jdk.unsupported;\n+        jdk.unsupported,\n+        jdk.incubator.foreign;\n","filename":"src\/java.base\/share\/classes\/module-info.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -63,0 +63,3 @@\n+\\    --enable-native-access <module name>[,<module name>...]\\n\\\n+\\                  modules that are permitted to perform restricted native operations.\\n\\\n+\\                  <module name> can also be ALL-UNNAMED.\\n\\\n","filename":"src\/java.base\/share\/classes\/sun\/launcher\/resources\/launcher.properties","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,4 @@\n-\n+import java.util.Objects;\n+import jdk.internal.access.JavaNioAccess;\n+import jdk.internal.access.SharedSecrets;\n+import jdk.internal.misc.ScopedMemoryAccess.Scope;\n@@ -50,1 +53,8 @@\n-        return write(fd, src, position, false, -1, nd);\n+        return write(fd, src, position, false, false, -1, nd);\n+    }\n+\n+    static int write(FileDescriptor fd, ByteBuffer src, long position,\n+                     boolean async, NativeDispatcher nd)\n+        throws IOException\n+    {\n+        return write(fd, src, position, false, async, -1, nd);\n@@ -56,0 +66,8 @@\n+    {\n+        return write(fd, src, position, directIO, false, alignment, nd);\n+    }\n+\n+    static int write(FileDescriptor fd, ByteBuffer src, long position,\n+                     boolean directIO, boolean async, int alignment,\n+                     NativeDispatcher nd)\n+        throws IOException\n@@ -58,1 +76,1 @@\n-            return writeFromNativeBuffer(fd, src, position, directIO, alignment, nd);\n+            return writeFromNativeBuffer(fd, src, position, directIO, async, alignment, nd);\n@@ -79,1 +97,1 @@\n-            int n = writeFromNativeBuffer(fd, bb, position, directIO, alignment, nd);\n+            int n = writeFromNativeBuffer(fd, bb, position, directIO, async, alignment, nd);\n@@ -92,1 +110,2 @@\n-                                             int alignment, NativeDispatcher nd)\n+                                             boolean async, int alignment,\n+                                             NativeDispatcher nd)\n@@ -108,6 +127,9 @@\n-        if (position != -1) {\n-            written = nd.pwrite(fd,\n-                                ((DirectBuffer)bb).address() + pos,\n-                                rem, position);\n-        } else {\n-            written = nd.write(fd, ((DirectBuffer)bb).address() + pos, rem);\n+        var handle = acquireScope(bb, async);\n+        try {\n+            if (position != -1) {\n+                written = nd.pwrite(fd, bufferAddress(bb) + pos, rem, position);\n+            } else {\n+                written = nd.write(fd, bufferAddress(bb) + pos, rem);\n+            }\n+        } finally {\n+            releaseScope(handle);\n@@ -120,1 +142,2 @@\n-    static long write(FileDescriptor fd, ByteBuffer[] bufs, NativeDispatcher nd)\n+    static long write(FileDescriptor fd, ByteBuffer[] bufs, boolean async,\n+                      NativeDispatcher nd)\n@@ -123,1 +146,1 @@\n-        return write(fd, bufs, 0, bufs.length, false, -1, nd);\n+        return write(fd, bufs, 0, bufs.length, false, async, -1, nd);\n@@ -130,1 +153,1 @@\n-        return write(fd, bufs, offset, length, false, -1, nd);\n+        return write(fd, bufs, offset, length, false, false, -1, nd);\n@@ -134,1 +157,9 @@\n-                      boolean directIO, int alignment, NativeDispatcher nd)\n+                      boolean direct, int alignment, NativeDispatcher nd)\n+        throws IOException\n+    {\n+        return write(fd, bufs, offset, length, direct, false, alignment, nd);\n+    }\n+\n+    static long write(FileDescriptor fd, ByteBuffer[] bufs, int offset, int length,\n+                      boolean directIO, boolean async,\n+                      int alignment, NativeDispatcher nd)\n@@ -141,0 +172,1 @@\n+        Runnable handleReleasers = null;\n@@ -142,1 +174,0 @@\n-\n@@ -148,0 +179,4 @@\n+                var h = acquireScope(buf, async);\n+                if (h != null) {\n+                    handleReleasers = LinkedRunnable.of(Releaser.of(h), handleReleasers);\n+                }\n@@ -173,1 +208,1 @@\n-                    vec.putBase(iov_len, ((DirectBuffer)buf).address() + pos);\n+                    vec.putBase(iov_len, bufferAddress(buf) + pos);\n@@ -206,0 +241,1 @@\n+            releaseScopes(handleReleasers);\n@@ -223,1 +259,8 @@\n-        return read(fd, dst, position, false, -1, nd);\n+        return read(fd, dst, position, false, false, -1, nd);\n+    }\n+\n+    static int read(FileDescriptor fd, ByteBuffer dst, long position,\n+                    boolean async, NativeDispatcher nd)\n+        throws IOException\n+    {\n+        return read(fd, dst, position, false, async, -1, nd);\n@@ -229,0 +272,8 @@\n+    {\n+        return read(fd, dst, position, directIO, false, alignment, nd);\n+    }\n+\n+    static int read(FileDescriptor fd, ByteBuffer dst, long position,\n+                    boolean directIO, boolean async,\n+                    int alignment, NativeDispatcher nd)\n+        throws IOException\n@@ -233,1 +284,1 @@\n-            return readIntoNativeBuffer(fd, dst, position, directIO, alignment, nd);\n+            return readIntoNativeBuffer(fd, dst, position, directIO, async, alignment, nd);\n@@ -245,1 +296,1 @@\n-            int n = readIntoNativeBuffer(fd, bb, position, directIO, alignment,nd);\n+            int n = readIntoNativeBuffer(fd, bb, position, directIO, async, alignment, nd);\n@@ -257,1 +308,2 @@\n-                                            int alignment, NativeDispatcher nd)\n+                                            boolean async, int alignment,\n+                                            NativeDispatcher nd)\n@@ -273,4 +325,9 @@\n-        if (position != -1) {\n-            n = nd.pread(fd, ((DirectBuffer)bb).address() + pos, rem, position);\n-        } else {\n-            n = nd.read(fd, ((DirectBuffer)bb).address() + pos, rem);\n+        var handle = acquireScope(bb, async);\n+        try {\n+            if (position != -1) {\n+                n = nd.pread(fd, bufferAddress(bb) + pos, rem, position);\n+            } else {\n+                n = nd.read(fd, bufferAddress(bb) + pos, rem);\n+            }\n+        } finally {\n+            releaseScope(handle);\n@@ -286,1 +343,8 @@\n-        return read(fd, bufs, 0, bufs.length, false, -1, nd);\n+        return read(fd, bufs, 0, bufs.length, false, false, -1, nd);\n+    }\n+\n+    static long read(FileDescriptor fd, ByteBuffer[] bufs, boolean async,\n+                     NativeDispatcher nd)\n+        throws IOException\n+    {\n+        return read(fd, bufs, 0, bufs.length, false, async, -1, nd);\n@@ -293,1 +357,1 @@\n-        return read(fd, bufs, offset, length, false, -1, nd);\n+        return read(fd, bufs, offset, length, false, false, -1, nd);\n@@ -298,0 +362,10 @@\n+\n+        throws IOException\n+    {\n+        return read(fd, bufs, offset, length, directIO, false, alignment, nd);\n+    }\n+\n+    static long read(FileDescriptor fd, ByteBuffer[] bufs, int offset, int length,\n+                     boolean directIO, boolean async,\n+                     int alignment, NativeDispatcher nd)\n+\n@@ -304,0 +378,1 @@\n+        Runnable handleReleasers = null;\n@@ -305,1 +380,0 @@\n-\n@@ -313,0 +387,4 @@\n+                var h = acquireScope(buf, async);\n+                if (h != null) {\n+                    handleReleasers = LinkedRunnable.of(Releaser.of(h), handleReleasers);\n+                }\n@@ -337,1 +415,1 @@\n-                    vec.putBase(iov_len, ((DirectBuffer)buf).address() + pos);\n+                    vec.putBase(iov_len, bufferAddress(buf) + pos);\n@@ -374,0 +452,1 @@\n+            releaseScopes(handleReleasers);\n@@ -387,0 +466,77 @@\n+    private static final JavaNioAccess NIO_ACCESS = SharedSecrets.getJavaNioAccess();\n+\n+    static Scope.Handle acquireScope(ByteBuffer bb, boolean async) {\n+        return NIO_ACCESS.acquireScope(bb, async);\n+    }\n+\n+    private static void releaseScope(Scope.Handle handle) {\n+        if (handle == null)\n+            return;\n+        try {\n+            handle.scope().release(handle);\n+        } catch (Exception e) {\n+            throw new IllegalStateException(e);\n+        }\n+    }\n+\n+    static Runnable acquireScopes(ByteBuffer[] buffers) {\n+        return acquireScopes(null, buffers);\n+    }\n+\n+    static Runnable acquireScopes(ByteBuffer buf, ByteBuffer[] buffers) {\n+        if (buffers == null) {\n+            assert buf != null;\n+            return IOUtil.Releaser.ofNullable(IOUtil.acquireScope(buf, true));\n+        } else {\n+            assert buf == null;\n+            Runnable handleReleasers = null;\n+            for (var b : buffers) {\n+                var h = IOUtil.acquireScope(b, true);\n+                if (h != null) {\n+                    handleReleasers = IOUtil.LinkedRunnable.of(IOUtil.Releaser.of(h), handleReleasers);\n+                }\n+            }\n+            return handleReleasers;\n+        }\n+    }\n+\n+    static void releaseScopes(Runnable releasers) {\n+        if (releasers != null)\n+            releasers.run();\n+    }\n+\n+    static record LinkedRunnable(Runnable node, Runnable next)\n+        implements Runnable\n+    {\n+        LinkedRunnable {\n+            Objects.requireNonNull(node);\n+        }\n+        @Override\n+        public void run() {\n+            try {\n+                node.run();\n+            } finally {\n+                if (next != null)\n+                    next.run();\n+            }\n+        }\n+        static LinkedRunnable of(Runnable first, Runnable second) {\n+            return new LinkedRunnable(first, second);\n+        }\n+    }\n+\n+    static record Releaser(Scope.Handle handle) implements Runnable {\n+        Releaser { Objects.requireNonNull(handle) ; }\n+        @Override public void run() { releaseScope(handle); }\n+        static Runnable of(Scope.Handle handle) { return new Releaser(handle); }\n+        static Runnable ofNullable(Scope.Handle handle) {\n+            if (handle == null)\n+                return () -> { };\n+            return new Releaser(handle);\n+        }\n+    }\n+\n+    static long bufferAddress(ByteBuffer buf) {\n+        return NIO_ACCESS.getBufferAddress(buf);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/IOUtil.java","additions":186,"deletions":30,"binary":false,"changes":216,"status":"modified"},{"patch":"@@ -602,0 +602,1 @@\n+           JLI_StrCmp(name, \"--enable-native-access\") == 0 ||\n@@ -614,0 +615,1 @@\n+           JLI_StrCCmp(name, \"--enable-native-access=\") == 0 ||\n","filename":"src\/java.base\/share\/native\/libjli\/java.c","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -79,0 +79,1 @@\n+    private Runnable readScopeHandleReleasers;\n@@ -89,0 +90,1 @@\n+    private Runnable writeScopeHandleReleasers;\n@@ -395,1 +397,1 @@\n-                n = (int)IOUtil.read(fd, readBuffers, nd);\n+                n = (int)IOUtil.read(fd, readBuffers, true, nd);\n@@ -397,1 +399,1 @@\n-                n = IOUtil.read(fd, readBuffer, -1, nd);\n+                n = IOUtil.read(fd, readBuffer, -1, true, nd);\n@@ -412,0 +414,1 @@\n+            IOUtil.releaseScopes(readScopeHandleReleasers);\n@@ -519,1 +522,1 @@\n-                    n = (int)IOUtil.read(fd, dsts, nd);\n+                    n = (int)IOUtil.read(fd, dsts, true, nd);\n@@ -521,1 +524,1 @@\n-                    n = IOUtil.read(fd, dst, -1, nd);\n+                    n = IOUtil.read(fd, dst, -1, true, nd);\n@@ -529,0 +532,1 @@\n+                    this.readScopeHandleReleasers = IOUtil.acquireScopes(dst, dsts);\n@@ -595,1 +599,1 @@\n-                n = (int)IOUtil.write(fd, writeBuffers, nd);\n+                n = (int)IOUtil.write(fd, writeBuffers, true, nd);\n@@ -597,1 +601,1 @@\n-                n = IOUtil.write(fd, writeBuffer, -1, nd);\n+                n = IOUtil.write(fd, writeBuffer, -1, true, nd);\n@@ -612,0 +616,1 @@\n+            IOUtil.releaseScopes(writeScopeHandleReleasers);\n@@ -705,1 +710,1 @@\n-                    n = (int)IOUtil.write(fd, srcs, nd);\n+                    n = (int)IOUtil.write(fd, srcs, true, nd);\n@@ -707,1 +712,1 @@\n-                    n = IOUtil.write(fd, src, -1, nd);\n+                    n = IOUtil.write(fd, src, -1, true, nd);\n@@ -715,0 +720,1 @@\n+                    this.writeScopeHandleReleasers = IOUtil.acquireScopes(src, srcs);\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/ch\/UnixAsynchronousSocketChannelImpl.java","additions":15,"deletions":9,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -403,0 +403,1 @@\n+        private Runnable scopeHandleReleasers;\n@@ -419,0 +420,1 @@\n+            scopeHandleReleasers = IOUtil.acquireScopes(bufs);\n@@ -432,1 +434,1 @@\n-                    a = ((DirectBuffer)bb).address();\n+                    a = IOUtil.bufferAddress(bb);\n@@ -435,1 +437,1 @@\n-                    a = ((DirectBuffer)dst).address() + pos;\n+                    a = IOUtil.bufferAddress(dst) + pos;\n@@ -493,0 +495,1 @@\n+            IOUtil.releaseScopes(scopeHandleReleasers);\n@@ -674,0 +677,1 @@\n+        private Runnable scopeHandleReleasers;\n@@ -690,0 +694,1 @@\n+            scopeHandleReleasers = IOUtil.acquireScopes(bufs);\n@@ -706,1 +711,1 @@\n-                    a = ((DirectBuffer)bb).address();\n+                    a = IOUtil.bufferAddress(bb);\n@@ -709,1 +714,1 @@\n-                    a = ((DirectBuffer)src).address() + pos;\n+                    a = IOUtil.bufferAddress(src) + pos;\n@@ -757,0 +762,1 @@\n+            IOUtil.releaseScopes(scopeHandleReleasers);\n","filename":"src\/java.base\/windows\/classes\/sun\/nio\/ch\/WindowsAsynchronousSocketChannelImpl.java","additions":11,"deletions":5,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n-abstract class AbstractLayout implements MemoryLayout {\n+abstract non-sealed class AbstractLayout implements MemoryLayout {\n@@ -217,1 +217,1 @@\n-    static final MethodHandleDesc MH_PADDING = MethodHandleDesc.ofMethod(DirectMethodHandleDesc.Kind.INTERFACE_STATIC, CD_MEMORY_LAYOUT, \"ofPaddingBits\",\n+    static final MethodHandleDesc MH_PADDING = MethodHandleDesc.ofMethod(DirectMethodHandleDesc.Kind.INTERFACE_STATIC, CD_MEMORY_LAYOUT, \"paddingLayout\",\n@@ -220,1 +220,1 @@\n-    static final MethodHandleDesc MH_VALUE = MethodHandleDesc.ofMethod(DirectMethodHandleDesc.Kind.INTERFACE_STATIC, CD_MEMORY_LAYOUT, \"ofValueBits\",\n+    static final MethodHandleDesc MH_VALUE = MethodHandleDesc.ofMethod(DirectMethodHandleDesc.Kind.INTERFACE_STATIC, CD_MEMORY_LAYOUT, \"valueLayout\",\n@@ -223,1 +223,1 @@\n-    static final MethodHandleDesc MH_SIZED_SEQUENCE = MethodHandleDesc.ofMethod(DirectMethodHandleDesc.Kind.INTERFACE_STATIC, CD_MEMORY_LAYOUT, \"ofSequence\",\n+    static final MethodHandleDesc MH_SIZED_SEQUENCE = MethodHandleDesc.ofMethod(DirectMethodHandleDesc.Kind.INTERFACE_STATIC, CD_MEMORY_LAYOUT, \"sequenceLayout\",\n@@ -226,1 +226,1 @@\n-    static final MethodHandleDesc MH_UNSIZED_SEQUENCE = MethodHandleDesc.ofMethod(DirectMethodHandleDesc.Kind.INTERFACE_STATIC, CD_MEMORY_LAYOUT, \"ofSequence\",\n+    static final MethodHandleDesc MH_UNSIZED_SEQUENCE = MethodHandleDesc.ofMethod(DirectMethodHandleDesc.Kind.INTERFACE_STATIC, CD_MEMORY_LAYOUT, \"sequenceLayout\",\n@@ -229,1 +229,1 @@\n-    static final MethodHandleDesc MH_STRUCT = MethodHandleDesc.ofMethod(DirectMethodHandleDesc.Kind.INTERFACE_STATIC, CD_MEMORY_LAYOUT, \"ofStruct\",\n+    static final MethodHandleDesc MH_STRUCT = MethodHandleDesc.ofMethod(DirectMethodHandleDesc.Kind.INTERFACE_STATIC, CD_MEMORY_LAYOUT, \"structLayout\",\n@@ -232,1 +232,1 @@\n-    static final MethodHandleDesc MH_UNION = MethodHandleDesc.ofMethod(DirectMethodHandleDesc.Kind.INTERFACE_STATIC, CD_MEMORY_LAYOUT, \"ofUnion\",\n+    static final MethodHandleDesc MH_UNION = MethodHandleDesc.ofMethod(DirectMethodHandleDesc.Kind.INTERFACE_STATIC, CD_MEMORY_LAYOUT, \"unionLayout\",\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/AbstractLayout.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -31,6 +31,1 @@\n- * {@link MemoryAddress}, {@link LibraryLookup.Symbol} and {@link CLinker.VaList}.\n- *\n- * @apiNote In the future, if the Java language permits, {@link Addressable}\n- * may become a {@code sealed} interface, which would prohibit subclassing except by\n- * explicitly permitted types, such as {@link MemorySegment}, {@link MemoryAddress}, {@link LibraryLookup.Symbol}\n- * and {@link CLinker.VaList}.\n+ * {@link MemoryAddress} and {@link CLinker.VaList}.\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/Addressable.java","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import jdk.internal.foreign.AbstractCLinker;\n@@ -30,1 +31,0 @@\n-import jdk.internal.foreign.Utils;\n@@ -32,0 +32,5 @@\n+import jdk.internal.foreign.abi.aarch64.AArch64VaList;\n+import jdk.internal.foreign.abi.x64.sysv.SysVVaList;\n+import jdk.internal.foreign.abi.x64.windows.WinVaList;\n+import jdk.internal.reflect.CallerSensitive;\n+import jdk.internal.reflect.Reflection;\n@@ -39,1 +44,0 @@\n-import java.util.stream.Stream;\n@@ -68,1 +72,2 @@\n- * the method type and the function descriptor, respectively, used during the linking process, then it must be that:\n+ * the method type (obtained after dropping any prefix arguments) and the function descriptor, respectively,\n+ * used during the linking process, then it must be that:\n@@ -103,4 +108,0 @@\n- * @apiNote In the future, if the Java language permits, {@link CLinker}\n- * may become a {@code sealed} interface, which would prohibit subclassing except by\n- * explicitly permitted types.\n- *\n@@ -110,1 +111,1 @@\n-public interface CLinker {\n+public sealed interface CLinker permits AbstractCLinker {\n@@ -115,1 +116,2 @@\n-     * This method is <em>restricted<\/em>. Restricted method are unsafe, and, if used incorrectly, their use might crash\n+     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n+     * Restricted method are unsafe, and, if used incorrectly, their use might crash\n@@ -118,0 +120,1 @@\n+     *\n@@ -119,2 +122,3 @@\n-     * @throws IllegalAccessError if the runtime property {@code foreign.restricted} is not set to either\n-     * {@code permit}, {@code warn} or {@code debug} (the default value is set to {@code deny}).\n+     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n+     * {@code --enable-native-access} is either absent, or does not mention the module name {@code M}, or\n+     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n@@ -122,0 +126,1 @@\n+    @CallerSensitive\n@@ -123,1 +128,1 @@\n-        Utils.checkRestrictedAccess(\"CLinker.getInstance\");\n+        Reflection.ensureNativeAccess(Reflection.getCallerClass());\n@@ -128,2 +133,6 @@\n-     * Obtain a foreign method handle, with given type, which can be used to call a\n-     * target foreign function at a given address and featuring a given function descriptor.\n+     * Obtains a foreign method handle, with the given type and featuring the given function descriptor,\n+     * which can be used to call a target foreign function at the given address.\n+     * <p>\n+     * If the provided method type's return type is {@code MemorySegment}, then the resulting method handle features\n+     * an additional prefix parameter, of type {@link SegmentAllocator}, which will be used by the linker runtime\n+     * to allocate structs returned by-value.\n@@ -142,3 +151,39 @@\n-     * Allocates a native segment whose base address (see {@link MemorySegment#address}) can be\n-     * passed to other foreign functions (as a function pointer); calling such a function pointer\n-     * from native code will result in the execution of the provided method handle.\n+     * Obtain a foreign method handle, with the given type and featuring the given function descriptor,\n+     * which can be used to call a target foreign function at the given address.\n+     * <p>\n+     * If the provided method type's return type is {@code MemorySegment}, then the provided allocator will be used by\n+     * the linker runtime to allocate structs returned by-value.\n+     *\n+     * @see LibraryLookup#lookup(String)\n+     *\n+     * @param symbol    downcall symbol.\n+     * @param allocator the segment allocator.\n+     * @param type      the method type.\n+     * @param function  the function descriptor.\n+     * @return the downcall method handle.\n+     * @throws IllegalArgumentException in the case of a method type and function descriptor mismatch.\n+     *\/\n+    MethodHandle downcallHandle(Addressable symbol, SegmentAllocator allocator, MethodType type, FunctionDescriptor function);\n+\n+    \/**\n+     * Obtains a foreign method handle, with the given type and featuring the given function descriptor, which can be\n+     * used to call a target foreign function at an address.\n+     * The resulting method handle features a prefix parameter (as the first parameter) corresponding to the address, of\n+     * type {@link Addressable}.\n+     * <p>\n+     * If the provided method type's return type is {@code MemorySegment}, then the resulting method handle features an\n+     * additional prefix parameter (inserted immediately after the address parameter), of type {@link SegmentAllocator}),\n+     * which will be used by the linker runtime to allocate structs returned by-value.\n+     *\n+     * @see LibraryLookup#lookup(String)\n+     *\n+     * @param type     the method type.\n+     * @param function the function descriptor.\n+     * @return the downcall method handle.\n+     * @throws IllegalArgumentException in the case of a method type and function descriptor mismatch.\n+     *\/\n+    MethodHandle downcallHandle(MethodType type, FunctionDescriptor function);\n+\n+    \/**\n+     * Allocates a native stub with given scope which can be passed to other foreign functions (as a function pointer);\n+     * calling such a function pointer from native code will result in the execution of the provided method handle.\n@@ -146,3 +191,2 @@\n-     * <p>The returned segment is <a href=MemorySegment.html#thread-confinement>shared<\/a>, and it only features\n-     * the {@link MemorySegment#CLOSE} access mode. When the returned segment is closed,\n-     * the corresponding native stub will be deallocated.<\/p>\n+     * <p>The returned memory address is associated with the provided scope. When such scope is closed,\n+     * the corresponding native stub will be deallocated.\n@@ -152,0 +196,1 @@\n+     * @param scope the upcall stub scope.\n@@ -154,0 +199,2 @@\n+     * @throws IllegalStateException if {@code scope} has been already closed, or if access occurs from a thread other\n+     * than the thread owning {@code scope}.\n@@ -155,1 +202,1 @@\n-    MemorySegment upcallStub(MethodHandle target, FunctionDescriptor function);\n+    MemoryAddress upcallStub(MethodHandle target, FunctionDescriptor function, ResourceScope scope);\n@@ -208,2 +255,2 @@\n-     * Converts a Java string into a null-terminated C string, using the\n-     * platform's default charset, storing the result into a new native memory segment.\n+     * Converts a Java string into a null-terminated C string, using the platform's default charset,\n+     * storing the result into a native memory segment allocated using the provided allocator.\n@@ -217,0 +264,1 @@\n+     * @param allocator the allocator to be used for the native segment allocation.\n@@ -219,1 +267,1 @@\n-    static MemorySegment toCString(String str) {\n+    static MemorySegment toCString(String str, SegmentAllocator allocator) {\n@@ -221,1 +269,2 @@\n-        return toCString(str.getBytes());\n+        Objects.requireNonNull(allocator);\n+        return toCString(str.getBytes(), allocator);\n@@ -225,2 +274,2 @@\n-     * Converts a Java string into a null-terminated C string, using the given {@link java.nio.charset.Charset charset},\n-     * storing the result into a new native memory segment.\n+     * Converts a Java string into a null-terminated C string, using the platform's default charset,\n+     * storing the result into a native memory segment associated with the provided resource scope.\n@@ -234,1 +283,1 @@\n-     * @param charset The {@link java.nio.charset.Charset} to be used to compute the contents of the C string.\n+     * @param scope the resource scope to be associated with the returned segment.\n@@ -236,0 +285,2 @@\n+     * @throws IllegalStateException if {@code scope} has been already closed, or if access occurs from a thread other\n+     * than the thread owning {@code scope}.\n@@ -237,4 +288,2 @@\n-    static MemorySegment toCString(String str, Charset charset) {\n-        Objects.requireNonNull(str);\n-        Objects.requireNonNull(charset);\n-        return toCString(str.getBytes(charset));\n+    static MemorySegment toCString(String str, ResourceScope scope) {\n+        return toCString(str, SegmentAllocator.ofScope(scope));\n@@ -244,2 +293,2 @@\n-     * Converts a Java string into a null-terminated C string, using the platform's default charset,\n-     * storing the result into a native memory segment allocated using the provided scope.\n+     * Converts a Java string into a null-terminated C string, using the given {@linkplain java.nio.charset.Charset charset},\n+     * storing the result into a new native memory segment native memory segment allocated using the provided allocator.\n@@ -253,1 +302,2 @@\n-     * @param scope the scope to be used for the native segment allocation.\n+     * @param charset The {@link java.nio.charset.Charset} to be used to compute the contents of the C string.\n+     * @param allocator the allocator to be used for the native segment allocation.\n@@ -256,1 +306,1 @@\n-    static MemorySegment toCString(String str, NativeScope scope) {\n+    static MemorySegment toCString(String str, Charset charset, SegmentAllocator allocator) {\n@@ -258,2 +308,3 @@\n-        Objects.requireNonNull(scope);\n-        return toCString(str.getBytes(), scope);\n+        Objects.requireNonNull(charset);\n+        Objects.requireNonNull(allocator);\n+        return toCString(str.getBytes(charset), allocator);\n@@ -263,2 +314,2 @@\n-     * Converts a Java string into a null-terminated C string, using the given {@link java.nio.charset.Charset charset},\n-     * storing the result into a new native memory segment native memory segment allocated using the provided scope.\n+     * Converts a Java string into a null-terminated C string, using the given {@linkplain java.nio.charset.Charset charset},\n+     * storing the result into a native memory segment associated with the provided resource scope.\n@@ -273,1 +324,1 @@\n-     * @param scope the scope to be used for the native segment allocation.\n+     * @param scope the resource scope to be associated with the returned segment.\n@@ -275,0 +326,2 @@\n+     * @throws IllegalStateException if {@code scope} has been already closed, or if access occurs from a thread other\n+     * than the thread owning {@code scope}.\n@@ -276,5 +329,2 @@\n-    static MemorySegment toCString(String str, Charset charset, NativeScope scope) {\n-        Objects.requireNonNull(str);\n-        Objects.requireNonNull(charset);\n-        Objects.requireNonNull(scope);\n-        return toCString(str.getBytes(charset), scope);\n+    static MemorySegment toCString(String str, Charset charset, ResourceScope scope) {\n+        return toCString(str, charset, SegmentAllocator.ofScope(scope));\n@@ -291,1 +341,2 @@\n-     * This method is <em>restricted<\/em>. Restricted method are unsafe, and, if used incorrectly, their use might crash\n+     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n+     * Restricted method are unsafe, and, if used incorrectly, their use might crash\n@@ -294,0 +345,1 @@\n+     *\n@@ -297,0 +349,3 @@\n+     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n+     * {@code --enable-native-access} is either absent, or does not mention the module name {@code M}, or\n+     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n@@ -298,2 +353,3 @@\n-    static String toJavaStringRestricted(MemoryAddress addr) {\n-        Utils.checkRestrictedAccess(\"CLinker.toJavaStringRestricted\");\n+    @CallerSensitive\n+    static String toJavaString(MemoryAddress addr) {\n+        Reflection.ensureNativeAccess(Reflection.getCallerClass());\n@@ -305,1 +361,1 @@\n-     * Converts a null-terminated C string stored at given address into a Java string, using the given {@link java.nio.charset.Charset charset}.\n+     * Converts a null-terminated C string stored at given address into a Java string, using the given {@linkplain java.nio.charset.Charset charset}.\n@@ -312,1 +368,2 @@\n-     * This method is <em>restricted<\/em>. Restricted method are unsafe, and, if used incorrectly, their use might crash\n+     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n+     * Restricted method are unsafe, and, if used incorrectly, their use might crash\n@@ -315,0 +372,1 @@\n+     *\n@@ -319,0 +377,3 @@\n+     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n+     * {@code --enable-native-access} is either absent, or does not mention the module name {@code M}, or\n+     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n@@ -320,2 +381,3 @@\n-    static String toJavaStringRestricted(MemoryAddress addr, Charset charset) {\n-        Utils.checkRestrictedAccess(\"CLinker.toJavaStringRestricted\");\n+    @CallerSensitive\n+    static String toJavaString(MemoryAddress addr, Charset charset) {\n+        Reflection.ensureNativeAccess(Reflection.getCallerClass());\n@@ -346,1 +408,1 @@\n-     * Converts a null-terminated C string stored at given address into a Java string, using the given {@link java.nio.charset.Charset charset}.\n+     * Converts a null-terminated C string stored at given address into a Java string, using the given {@linkplain java.nio.charset.Charset charset}.\n@@ -371,8 +433,2 @@\n-    private static MemorySegment toCString(byte[] bytes) {\n-        MemorySegment segment = MemorySegment.allocateNative(bytes.length + 1, 1L);\n-        copy(segment, bytes);\n-        return segment;\n-    }\n-\n-    private static MemorySegment toCString(byte[] bytes, NativeScope scope) {\n-        MemorySegment addr = scope.allocate(bytes.length + 1, 1L);\n+    private static MemorySegment toCString(byte[] bytes, SegmentAllocator allocator) {\n+        MemorySegment addr = allocator.allocate(bytes.length + 1, 1L);\n@@ -386,1 +442,2 @@\n-     * This method is <em>restricted<\/em>. Restricted method are unsafe, and, if used incorrectly, their use might crash\n+     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n+     * Restricted method are unsafe, and, if used incorrectly, their use might crash\n@@ -393,0 +450,3 @@\n+     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n+     * {@code --enable-native-access} is either absent, or does not mention the module name {@code M}, or\n+     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n@@ -394,2 +454,3 @@\n-    static MemoryAddress allocateMemoryRestricted(long size) {\n-        Utils.checkRestrictedAccess(\"CLinker.allocateMemoryRestricted\");\n+    @CallerSensitive\n+    static MemoryAddress allocateMemory(long size) {\n+        Reflection.ensureNativeAccess(Reflection.getCallerClass());\n@@ -407,1 +468,2 @@\n-     * This method is <em>restricted<\/em>. Restricted method are unsafe, and, if used incorrectly, their use might crash\n+     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n+     * Restricted method are unsafe, and, if used incorrectly, their use might crash\n@@ -412,0 +474,3 @@\n+     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n+     * {@code --enable-native-access} is either absent, or does not mention the module name {@code M}, or\n+     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n@@ -413,2 +478,3 @@\n-    static void freeMemoryRestricted(MemoryAddress addr) {\n-        Utils.checkRestrictedAccess(\"CLinker.freeMemoryRestricted\");\n+    @CallerSensitive\n+    static void freeMemory(MemoryAddress addr) {\n+        Reflection.ensureNativeAccess(Reflection.getCallerClass());\n@@ -434,5 +500,0 @@\n-     *\n-     * @apiNote In the future, if the Java language permits, {@link VaList}\n-     * may become a {@code sealed} interface, which would prohibit subclassing except by\n-     * explicitly permitted types.\n-     *\n@@ -440,1 +501,1 @@\n-    interface VaList extends Addressable, AutoCloseable {\n+    sealed interface VaList extends Addressable permits WinVaList, SysVVaList, AArch64VaList, SharedUtils.EmptyVaList {\n@@ -447,2 +508,2 @@\n-         * @throws IllegalStateException if the C {@code va_list} associated with this instance is no longer valid\n-         * (see {@link #close()}).\n+         * @throws IllegalStateException if the resource scope associated with this instance has been closed\n+         * (see {@link #scope()}).\n@@ -458,2 +519,2 @@\n-         * @throws IllegalStateException if the C {@code va_list} associated with this instance is no longer valid\n-         * (see {@link #close()}).\n+         * @throws IllegalStateException if the resource scope associated with this instance has been closed\n+         * (see {@link #scope()}).\n@@ -469,2 +530,2 @@\n-         * @throws IllegalStateException if the C {@code va_list} associated with this instance is no longer valid\n-         * (see {@link #close()}).\n+         * @throws IllegalStateException if the resource scope associated with this instance has been closed\n+         * (see {@link #scope()}).\n@@ -480,2 +541,2 @@\n-         * @throws IllegalStateException if the C {@code va_list} associated with this instance is no longer valid\n-         * (see {@link #close()}).\n+         * @throws IllegalStateException if the resource scope associated with this instance has been closed\n+         * (see {@link #scope()}).\n@@ -489,2 +550,1 @@\n-         * The memory segment returned by this method will be allocated using\n-         * {@link MemorySegment#allocateNative(long, long)}, and will have to be closed separately.\n+         * The memory segment returned by this method will be allocated using the given {@link SegmentAllocator}.\n@@ -493,0 +553,1 @@\n+         * @param allocator the allocator to be used for the native segment allocation\n@@ -494,2 +555,2 @@\n-         * @throws IllegalStateException if the C {@code va_list} associated with this instance is no longer valid\n-         * (see {@link #close()}).\n+         * @throws IllegalStateException if the resource scope associated with this instance has been closed\n+         * (see {@link #scope()}).\n@@ -498,1 +559,1 @@\n-        MemorySegment vargAsSegment(MemoryLayout layout);\n+        MemorySegment vargAsSegment(MemoryLayout layout, SegmentAllocator allocator);\n@@ -503,1 +564,1 @@\n-         * The memory segment returned by this method will be allocated using the given {@code NativeScope}.\n+         * The memory segment returned by this method will be associated with the given {@link ResourceScope}.\n@@ -506,1 +567,1 @@\n-         * @param scope the scope to allocate the segment in\n+         * @param scope the resource scope to be associated with the returned segment\n@@ -508,2 +569,2 @@\n-         * @throws IllegalStateException if the C {@code va_list} associated with this instance is no longer valid\n-         * (see {@link #close()}).\n+         * @throws IllegalStateException if the resource scope associated with this instance has been closed\n+         * (see {@link #scope()}).\n@@ -511,0 +572,2 @@\n+         * @throws IllegalStateException if {@code scope} has been already closed, or if access occurs from a thread other\n+         * than the thread owning {@code scope}.\n@@ -512,1 +575,1 @@\n-        MemorySegment vargAsSegment(MemoryLayout layout, NativeScope scope);\n+        MemorySegment vargAsSegment(MemoryLayout layout, ResourceScope scope);\n@@ -518,2 +581,2 @@\n-         * @throws IllegalStateException if the C {@code va_list} associated with this instance is no longer valid\n-         * (see {@link #close()}).\n+         * @throws IllegalStateException if the resource scope associated with this instance has been closed\n+         * (see {@link #scope()}).\n@@ -524,16 +587,2 @@\n-         * A predicate used to check if the memory associated with the C {@code va_list} modelled\n-         * by this instance is still valid to use.\n-         *\n-         * @return true, if the memory associated with the C {@code va_list} modelled by this instance is still valid\n-         * @see #close()\n-         *\/\n-        boolean isAlive();\n-\n-        \/**\n-         * Releases the underlying C {@code va_list} modelled by this instance, and any native memory that is attached\n-         * to this va list that holds its elements (see {@link VaList#make(Consumer)}).\n-         * <p>\n-         * After calling this method, {@link #isAlive()} will return {@code false} and further attempts to read values\n-         * from this va list will result in an exception.\n-         *\n-         * @see #isAlive()\n+         * Returns the resource scope associated with this instance.\n+         * @return the resource scope associated with this instance.\n@@ -541,1 +590,1 @@\n-        void close();\n+        ResourceScope scope();\n@@ -548,3 +597,2 @@\n-         * If this method needs to allocate native memory for the copy, it will use\n-         * {@link MemorySegment#allocateNative(long, long)} to do so. {@link #close()} will have to be called on the\n-         * returned va list instance to release the allocated memory.\n+         * Any native resource required by the execution of this method will be allocated in the resource scope\n+         * associated with this instance (see {@link #scope()}).\n@@ -554,1 +602,1 @@\n-         * {@link #make(Consumer)} method, closing this va list will also release the native memory that holds its\n+         * {@link #make(Consumer, ResourceScope)} method, closing this va list will also release the native memory that holds its\n@@ -558,2 +606,2 @@\n-         * @throws IllegalStateException if the C {@code va_list} associated with this instance is no longer valid\n-         * (see {@link #close()}).\n+         * @throws IllegalStateException if the resource scope associated with this instance has been closed\n+         * (see {@link #scope()}).\n@@ -563,20 +611,0 @@\n-        \/**\n-         * Copies this C {@code va_list} at its current position. Copying is useful to traverse the va list's elements\n-         * starting from the current position, without affecting the state of the original va list, essentially\n-         * allowing the elements to be traversed multiple times.\n-         * <p>\n-         * If this method needs to allocate native memory for the copy, it will use\n-         * the given {@code NativeScope} to do so.\n-         * <p>\n-         * This method only copies the va list cursor itself and not the memory that may be attached to the\n-         * va list which holds its elements. That means that if this va list was created with the\n-         * {@link #make(Consumer)} method, closing this va list will also release the native memory that holds its\n-         * elements, making the copy unusable.\n-         *\n-         * @param scope the scope to allocate the copy in\n-         * @return a copy of this C {@code va_list}.\n-         * @throws IllegalStateException if the C {@code va_list} associated with this instance is no longer valid\n-         * (see {@link #close()}).\n-         *\/\n-        VaList copy(NativeScope scope);\n-\n@@ -585,0 +613,1 @@\n+         * The returned memory address is associated with same resource scope as that associated with this instance.\n@@ -592,1 +621,2 @@\n-         * Constructs a new {@code VaList} instance out of a memory address pointing to an existing C {@code va_list}.\n+         * Constructs a new {@code VaList} instance out of a memory address pointing to an existing C {@code va_list},\n+         * backed by the {@linkplain ResourceScope#globalScope() global} resource scope.\n@@ -594,1 +624,2 @@\n-         * This method is <em>restricted<\/em>. Restricted method are unsafe, and, if used incorrectly, their use might crash\n+         * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n+         * Restricted method are unsafe, and, if used incorrectly, their use might crash\n@@ -600,0 +631,3 @@\n+         * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n+         * {@code --enable-native-access} is either absent, or does not mention the module name {@code M}, or\n+         * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n@@ -601,4 +635,4 @@\n-        static VaList ofAddressRestricted(MemoryAddress address) {\n-            Utils.checkRestrictedAccess(\"VaList.ofAddressRestricted\");\n-            Objects.requireNonNull(address);\n-            return SharedUtils.newVaListOfAddress(address);\n+        @CallerSensitive\n+        static VaList ofAddress(MemoryAddress address) {\n+            Reflection.ensureNativeAccess(Reflection.getCallerClass());\n+            return SharedUtils.newVaListOfAddress(address, ResourceScope.globalScope());\n@@ -608,4 +642,2 @@\n-         * Constructs a new {@code VaList} using a builder (see {@link Builder}).\n-         * <p>\n-         * If this method needs to allocate native memory for the va list, it will use\n-         * {@link MemorySegment#allocateNative(long, long)} to do so.\n+         * Constructs a new {@code VaList} instance out of a memory address pointing to an existing C {@code va_list},\n+         * with given resource scope.\n@@ -613,6 +645,4 @@\n-         * This method will allocate native memory to hold the elements in the va list. This memory\n-         * will be 'attached' to the returned va list instance, and will be released when {@link VaList#close()}\n-         * is called.\n-         * <p>\n-         * Note that when there are no elements added to the created va list,\n-         * this method will return the same as {@link #empty()}.\n+         * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n+         * Restricted method are unsafe, and, if used incorrectly, their use might crash\n+         * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n+         * restricted methods, and use safe and supported functionalities, where possible.\n@@ -620,3 +650,8 @@\n-         * @param actions a consumer for a builder (see {@link Builder}) which can be used to specify the elements\n-         *                of the underlying C {@code va_list}.\n-         * @return a new {@code VaList} instance backed by a fresh C {@code va_list}.\n+         * @param address a memory address pointing to an existing C {@code va_list}.\n+         * @param scope the resource scope to be associated with the returned {@code VaList} instance.\n+         * @return a new {@code VaList} instance backed by the C {@code va_list} at {@code address}.\n+         * @throws IllegalStateException if {@code scope} has been already closed, or if access occurs from a thread other\n+         * than the thread owning {@code scope}.\n+         * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n+         * {@code --enable-native-access} is either absent, or does not mention the module name {@code M}, or\n+         * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n@@ -624,3 +659,6 @@\n-        static VaList make(Consumer<Builder> actions) {\n-            Objects.requireNonNull(actions);\n-            return SharedUtils.newVaList(actions, MemorySegment::allocateNative);\n+        @CallerSensitive\n+        static VaList ofAddress(MemoryAddress address, ResourceScope scope) {\n+            Reflection.ensureNativeAccess(Reflection.getCallerClass());\n+            Objects.requireNonNull(address);\n+            Objects.requireNonNull(scope);\n+            return SharedUtils.newVaListOfAddress(address, scope);\n@@ -630,4 +668,2 @@\n-         * Constructs a new {@code VaList} using a builder (see {@link Builder}).\n-         * <p>\n-         * If this method needs to allocate native memory for the va list, it will use\n-         * the given {@code NativeScope} to do so.\n+         * Constructs a new {@code VaList} using a builder (see {@link Builder}), associated with a given\n+         * {@linkplain ResourceScope resource scope}.\n@@ -635,2 +671,2 @@\n-         * This method will allocate native memory to hold the elements in the va list. This memory\n-         * will be managed by the given {@code NativeScope}, and will be released when the scope is closed.\n+         * If this method needs to allocate native memory, such memory will be managed by the given\n+         * {@linkplain ResourceScope resource scope}, and will be released when the resource scope is {@linkplain ResourceScope#close closed}.\n@@ -645,0 +681,2 @@\n+         * @throws IllegalStateException if {@code scope} has been already closed, or if access occurs from a thread other\n+         * than the thread owning {@code scope}.\n@@ -646,1 +684,1 @@\n-        static VaList make(Consumer<Builder> actions, NativeScope scope) {\n+        static VaList make(Consumer<Builder> actions, ResourceScope scope) {\n@@ -649,1 +687,1 @@\n-            return SharedUtils.newVaList(actions, SharedUtils.Allocator.ofScope(scope));\n+            return SharedUtils.newVaList(actions, scope);\n@@ -668,5 +706,0 @@\n-         *\n-         * @apiNote In the future, if the Java language permits, {@link Builder}\n-         * may become a {@code sealed} interface, which would prohibit subclassing except by\n-         * explicitly permitted types.\n-         *\n@@ -674,1 +707,1 @@\n-        interface Builder {\n+        sealed interface Builder permits WinVaList.Builder, SysVVaList.Builder, AArch64VaList.Builder {\n@@ -732,1 +765,1 @@\n-     * and {@link CLinker#upcallStub(MethodHandle, FunctionDescriptor)}.\n+     * and {@link CLinker#upcallStub(MethodHandle, FunctionDescriptor, ResourceScope)}.\n@@ -809,1 +842,1 @@\n-        public final static String ATTR_NAME = \"abi\/kind\";\n+        public static final String ATTR_NAME = \"abi\/kind\";\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/CLinker.java","additions":209,"deletions":176,"binary":false,"changes":385,"status":"modified"},{"patch":"@@ -45,2 +45,2 @@\n- * (see {@link MemoryLayout#ofStruct(MemoryLayout...)}); conversely, if all member layouts are laid out at the same starting offset,\n- * the resulting group layout is said to be a <em>union<\/em> (see {@link MemoryLayout#ofUnion(MemoryLayout...)}).\n+ * (see {@link MemoryLayout#structLayout(MemoryLayout...)}); conversely, if all member layouts are laid out at the same starting offset,\n+ * the resulting group layout is said to be a <em>union<\/em> (see {@link MemoryLayout#unionLayout(MemoryLayout...)}).\n@@ -61,1 +61,1 @@\n-public final class GroupLayout extends AbstractLayout {\n+public final class GroupLayout extends AbstractLayout implements MemoryLayout {\n@@ -121,2 +121,2 @@\n-     * been passed to one of the group layout factory methods (see {@link MemoryLayout#ofStruct(MemoryLayout...)},\n-     * {@link MemoryLayout#ofUnion(MemoryLayout...)}).\n+     * been passed to one of the group layout factory methods (see {@link MemoryLayout#structLayout(MemoryLayout...)},\n+     * {@link MemoryLayout#unionLayout(MemoryLayout...)}).\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/GroupLayout.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -29,0 +29,2 @@\n+import jdk.internal.reflect.CallerSensitive;\n+import jdk.internal.reflect.Reflection;\n@@ -40,11 +42,3 @@\n- * All symbol instances (see {@link LibraryLookup.Symbol}) generated by a given library lookup object contain a strong reference\n- * to said lookup object, therefore preventing library unloading; in turn method handle instances obtained from\n- * {@link CLinker#downcallHandle(Addressable, MethodType, FunctionDescriptor)}) also maintain a strong reference\n- * to the addressable parameter used for their construction. This means that there is always a strong reachability chain\n- * from a native method handle to a lookup object (the one that was used to lookup the native library symbol the method handle\n- * refers to); this is useful to prevent situations where a native library is unloaded in the middle of a native call.\n- * <p><a id = \"var-symbols\"><\/a><\/p>\n- * In cases where a client wants to create a memory segment out of a lookup symbol, the client might want to attach the\n- * lookup symbol to the newly created segment, so that the symbol will be kept reachable as long as the memory segment\n- * is reachable; this can be achieved by creating the segment using the {@link MemoryAddress#asSegmentRestricted(long, Runnable, Object)}\n- * restricted segment factory, as follows:\n+ * All instances generated by a given library lookup object contain a strong reference to said lookup object,\n+ * therefore preventing library unloading. For {@linkplain #lookup(String, MemoryLayout) memory segments} obtained from a library lookup object,\n+ * this means that clients can safely dereference memory associated with lookup symbols, as follows:\n@@ -52,3 +46,3 @@\n-LibraryLookup defaultLookup = LibraryLookup.defaultLookup();\n-LibraryLookup.Symbol errno = defaultLookup.lookup(\"errno\");\n-MemorySegment errnoSegment = errno.address().asRestrictedSegment(4, errno);\n+ * LibraryLookup defaultLookup = LibraryLookup.ofDefault();\n+ * MemorySegment errnoSegment = defaultLookup.lookup(\"errno\", MemoryLayouts.JAVA_INT).get();\n+ * int errno = MemoryAccess.getInt(errnoSegment);\n@@ -57,0 +51,7 @@\n+ * For {@linkplain #lookup(String) memory addresses} obtained from a library lookup object,\n+ * since {@linkplain CLinker#downcallHandle(Addressable, MethodType, FunctionDescriptor) native method handles}\n+ * also maintain a strong reference to the addressable parameter used for their construction, there is\n+ * always a strong reachability chain from a native method handle to a lookup object (the one that was used to lookup\n+ * the native library symbol the method handle refers to). This is useful to prevent situations where a native library\n+ * is unloaded in the middle of a native call.\n+ * <p>\n@@ -66,6 +67,1 @@\n-     * A symbol retrieved during a library lookup. A lookup symbol has a <em>name<\/em> and can be projected\n-     * into a memory address (see {@link #name()} and {@link #address()}, respectively).\n-     *\n-     * @apiNote In the future, if the Java language permits, {@link Symbol}\n-     * may become a {@code sealed} interface, which would prohibit subclassing except by\n-     * explicitly permitted types.\n+     * Looks up a symbol with given name in this library. The returned memory address maintains a strong reference to this lookup object.\n@@ -73,2 +69,2 @@\n-     * @implSpec\n-     * Implementations of this interface are immutable, thread-safe and <a href=\"{@docRoot}\/java.base\/java\/lang\/doc-files\/ValueBased.html\">value-based<\/a>.\n+     * @param name the symbol name.\n+     * @return the memory address associated with the library symbol (if any).\n@@ -76,16 +72,1 @@\n-    interface Symbol extends Addressable {\n-        \/**\n-         * The name of this lookup symbol.\n-         * @return the name of this lookup symbol.\n-         *\/\n-        String name();\n-\n-        \/**\n-         * The memory address of this lookup symbol. If the memory associated with this symbol needs to be dereferenced,\n-         * clients can obtain a segment from this symbol's address using the {@link MemoryAddress#asSegmentRestricted(long, Runnable, Object)},\n-         * and making sure that the created segment maintains a <a href=\"LibraryLookup.html#var-symbols\">strong reference<\/a> to this symbol, to prevent library unloading.\n-         * @return the memory address of this lookup symbol.\n-         *\/\n-        @Override\n-        MemoryAddress address();\n-    }\n+    Optional<MemoryAddress> lookup(String name);\n@@ -94,1 +75,4 @@\n-     * Looks up a symbol with given name in this library. The returned symbol maintains a strong reference to this lookup object.\n+     * Looks up a symbol with given name in this library. The returned memory segment has a size that matches that of\n+     * the specified layout, and maintains a strong reference to this lookup object. This method can be useful\n+     * to lookup global variable symbols in a foreign library.\n+     *\n@@ -96,1 +80,4 @@\n-     * @return the library symbol (if any).\n+     * @param layout the layout to be associated with the library symbol.\n+     * @return the memory segment associated with the library symbol (if any).\n+     * @throws IllegalArgumentException if the address associated with the lookup symbol do not match the\n+     * {@linkplain MemoryLayout#byteAlignment() alignment constraints} in {@code layout}.\n@@ -98,1 +85,1 @@\n-    Optional<Symbol> lookup(String name);\n+    Optional<MemorySegment> lookup(String name, MemoryLayout layout);\n@@ -102,0 +89,6 @@\n+     * <p>\n+     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n+     * Restricted method are unsafe, and, if used incorrectly, their use might crash\n+     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n+     * restricted methods, and use safe and supported functionalities, where possible.\n+     *\n@@ -103,0 +96,3 @@\n+     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n+     * {@code --enable-native-access} is either absent, or does not mention the module name {@code M}, or\n+     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n@@ -104,0 +100,1 @@\n+    @CallerSensitive\n@@ -105,0 +102,1 @@\n+        Reflection.ensureNativeAccess(Reflection.getCallerClass());\n@@ -114,0 +112,6 @@\n+     * <p>\n+     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n+     * Restricted method are unsafe, and, if used incorrectly, their use might crash\n+     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n+     * restricted methods, and use safe and supported functionalities, where possible.\n+     *\n@@ -118,0 +122,3 @@\n+     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n+     * {@code --enable-native-access} is either absent, or does not mention the module name {@code M}, or\n+     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n@@ -119,0 +126,1 @@\n+    @CallerSensitive\n@@ -120,0 +128,1 @@\n+        Reflection.ensureNativeAccess(Reflection.getCallerClass());\n@@ -137,0 +146,6 @@\n+     * <p>\n+     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n+     * Restricted method are unsafe, and, if used incorrectly, their use might crash\n+     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n+     * restricted methods, and use safe and supported functionalities, where possible.\n+     *\n@@ -139,0 +154,3 @@\n+     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n+     * {@code --enable-native-access} is either absent, or does not mention the module name {@code M}, or\n+     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n@@ -140,0 +158,1 @@\n+    @CallerSensitive\n@@ -141,0 +160,1 @@\n+        Reflection.ensureNativeAccess(Reflection.getCallerClass());\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/LibraryLookup.java","additions":61,"deletions":41,"binary":false,"changes":102,"status":"modified"},{"patch":"@@ -1,167 +0,0 @@\n-\/*\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.incubator.foreign;\n-\n-import jdk.internal.foreign.MappedMemorySegmentImpl;\n-\n-import java.io.UncheckedIOException;\n-import java.nio.MappedByteBuffer;\n-import java.util.Objects;\n-\n-\/**\n- * This class provides capabilities to manipulate mapped memory segments, such as {@link #force(MemorySegment)},\n- * and {@link #load(MemorySegment)}. The methods in these class are suitable replacements for some of the\n- * functionality in the {@link java.nio.MappedByteBuffer} class. Note that, while it is possible to map a segment\n- * into a byte buffer (see {@link MemorySegment#asByteBuffer()}), and call e.g. {@link MappedByteBuffer#force()} that way,\n- * this can only be done when the source segment is small enough, due to the size limitation inherent to the\n- * ByteBuffer API.\n- * <p>\n- * Clients requiring sophisticated, low-level control over mapped memory segments, should consider writing\n- * custom mapped memory segment factories; using JNI, e.g. on Linux, it is possible to call {@code mmap}\n- * with the desired parameters; the returned address can be easily wrapped into a memory segment, using\n- * {@link MemoryAddress#ofLong(long)} and {@link MemoryAddress#asSegmentRestricted(long, Runnable, Object)}.\n- *\n- * <p> Unless otherwise specified, passing a {@code null} argument, or an array argument containing one or more {@code null}\n- * elements to a method in this class causes a {@link NullPointerException NullPointerException} to be thrown. <\/p>\n- *\n- * @implNote\n- * The behavior of some the methods in this class (see {@link #load(MemorySegment)}, {@link #unload(MemorySegment)} and\n- * {@link #isLoaded(MemorySegment)}) is highly platform-dependent; as a result, calling these methods might\n- * be a no-op on certain platforms.\n- *\/\n-public final class MappedMemorySegments {\n-    private MappedMemorySegments() {\n-        \/\/ no thanks\n-    }\n-\n-    \/**\n-     * Tells whether or not the contents of the given segment is resident in physical\n-     * memory.\n-     *\n-     * <p> A return value of {@code true} implies that it is highly likely\n-     * that all of the data in the given segment is resident in physical memory and\n-     * may therefore be accessed without incurring any virtual-memory page\n-     * faults or I\/O operations.  A return value of {@code false} does not\n-     * necessarily imply that the segment's content is not resident in physical\n-     * memory.\n-     *\n-     * <p> The returned value is a hint, rather than a guarantee, because the\n-     * underlying operating system may have paged out some of the segment's data\n-     * by the time that an invocation of this method returns.  <\/p>\n-     *\n-     * @param segment the segment whose contents are to be tested.\n-     * @return  {@code true} if it is likely that the contents of the given segment\n-     *          is resident in physical memory\n-     *\n-     * @throws IllegalStateException if the given segment is not alive, or if the given segment is confined\n-     * and this method is called from a thread other than the segment's owner thread.\n-     * @throws UnsupportedOperationException if the given segment is not a mapped memory segment, e.g. if\n-     * {@code segment.isMapped() == false}.\n-     *\/\n-    public static boolean isLoaded(MemorySegment segment) {\n-        return toMappedSegment(segment).isLoaded();\n-    }\n-\n-    \/**\n-     * Loads the contents of the given segment into physical memory.\n-     *\n-     * <p> This method makes a best effort to ensure that, when it returns,\n-     * this contents of the given segment is resident in physical memory.  Invoking this\n-     * method may cause some number of page faults and I\/O operations to\n-     * occur. <\/p>\n-     *\n-     * @param segment the segment whose contents are to be loaded.\n-     *\n-     * @throws IllegalStateException if the given segment is not alive, or if the given segment is confined\n-     * and this method is called from a thread other than the segment's owner thread.\n-     * @throws UnsupportedOperationException if the given segment is not a mapped memory segment, e.g. if\n-     * {@code segment.isMapped() == false}.\n-     *\/\n-    public static void load(MemorySegment segment) {\n-        toMappedSegment(segment).load();\n-    }\n-\n-    \/**\n-     * Unloads the contents of the given segment from physical memory.\n-     *\n-     * <p> This method makes a best effort to ensure that the contents of the given segment are\n-     * are no longer resident in physical memory. Accessing this segment's contents\n-     * after invoking this method may cause some number of page faults and I\/O operations to\n-     * occur (as this segment's contents might need to be paged back in). <\/p>\n-     *\n-     * @param segment the segment whose contents are to be unloaded.\n-     *\n-     * @throws IllegalStateException if the given segment is not alive, or if the given segment is confined\n-     * and this method is called from a thread other than the segment's owner thread.\n-     * @throws UnsupportedOperationException if the given segment is not a mapped memory segment, e.g. if\n-     * {@code segment.isMapped() == false}.\n-     *\/\n-    public static void unload(MemorySegment segment) {\n-        toMappedSegment(segment).unload();\n-    }\n-\n-    \/**\n-     * Forces any changes made to the contents of the given segment to be written to the\n-     * storage device described by the mapped segment's file descriptor.\n-     *\n-     * <p> If this mapping's file descriptor resides on a local storage\n-     * device then when this method returns it is guaranteed that all changes\n-     * made to the segment since it was created, or since this method was last\n-     * invoked, will have been written to that device.\n-     *\n-     * <p> If this mapping's file descriptor does not reside on a local device then no such guarantee\n-     * is made.\n-     *\n-     * <p> If the given segment was not mapped in read\/write mode ({@link\n-     * java.nio.channels.FileChannel.MapMode#READ_WRITE}) then\n-     * invoking this method may have no effect. In particular, the\n-     * method has no effect for segments mapped in read-only or private\n-     * mapping modes. This method may or may not have an effect for\n-     * implementation-specific mapping modes.\n-     * <\/p>\n-     *\n-     * @param segment the segment whose contents are to be written to the storage device described by the\n-     *                segment's file descriptor.\n-     *\n-     * @throws IllegalStateException if the given segment is not alive, or if the given segment is confined\n-     * and this method is called from a thread other than the segment's owner thread.\n-     * @throws UnsupportedOperationException if the given segment is not a mapped memory segment, e.g. if\n-     * {@code segment.isMapped() == false}.\n-     * @throws UncheckedIOException if there is an I\/O error writing the contents of the segment to the associated storage device\n-     *\/\n-    public static void force(MemorySegment segment) {\n-        toMappedSegment(segment).force();\n-    }\n-\n-    static MappedMemorySegmentImpl toMappedSegment(MemorySegment segment) {\n-        Objects.requireNonNull(segment);\n-        if (segment instanceof MappedMemorySegmentImpl) {\n-            return (MappedMemorySegmentImpl)segment;\n-        } else {\n-            throw new UnsupportedOperationException(\"Not a mapped memory segment\");\n-        }\n-    }\n-}\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MappedMemorySegments.java","additions":0,"deletions":167,"binary":false,"changes":167,"status":"deleted"},{"patch":"@@ -29,1 +29,0 @@\n-import jdk.internal.foreign.AbstractMemorySegmentImpl;\n@@ -31,2 +30,2 @@\n-import jdk.internal.foreign.NativeMemorySegmentImpl;\n-import jdk.internal.foreign.Utils;\n+import jdk.internal.ref.CleanerFactory;\n+import jdk.internal.reflect.CallerSensitive;\n@@ -38,1 +37,5 @@\n- * {@link MemorySegment#address()} method, and can refer to either off-heap or on-heap memory.\n+ * {@link MemorySegment#address()} method, and can refer to either off-heap or on-heap memory. Off-heap memory\n+ * addresses are referred to as <em>native<\/em> memory addresses (see {@link #isNative()}). Native memory addresses\n+ * allow clients to obtain a raw memory address (expressed as a long value) which can then be used e.g. when interacting\n+ * with native code.\n+ * <p>\n@@ -42,0 +45,6 @@\n+ * A memory address is associated with a {@linkplain ResourceScope resource scope}; the resource scope determines the\n+ * lifecycle of the memory address, and whether the address can be used from multiple threads. Memory addresses\n+ * obtained from {@linkplain #ofLong(long) numeric values}, or from native code, are associated with the\n+ * {@linkplain ResourceScope#globalScope() global resource scope}. Memory addresses obtained from segments\n+ * are associated with the same scope as the segment from which they have been obtained.\n+ * <p>\n@@ -52,4 +61,0 @@\n- * @apiNote In the future, if the Java language permits, {@link MemoryAddress}\n- * may become a {@code sealed} interface, which would prohibit subclassing except by\n- * explicitly permitted types.\n- *\n@@ -59,1 +64,1 @@\n-public interface MemoryAddress extends Addressable {\n+public sealed interface MemoryAddress extends Addressable permits MemoryAddressImpl {\n@@ -73,0 +78,6 @@\n+    \/**\n+     * Returns the resource scope associated with this memory address.\n+     * @return the resource scope associated with this memory address.\n+     *\/\n+    ResourceScope scope();\n+\n@@ -75,1 +86,1 @@\n-     * base address and this address are off-heap addresses, the result is computed as\n+     * base address and this address are native addresses, the result is computed as\n@@ -89,1 +100,1 @@\n-     * when {@code segment} models an heap memory region, while this address models an off-heap memory address.\n+     * when {@code segment} models an heap memory region, while this address is a {@linkplain #isNative() native} address.\n@@ -94,6 +105,6 @@\n-     * Returns a new confined native memory segment with given size, and whose base address is this address; the returned segment has its own temporal\n-     * bounds, and can therefore be closed. This method can be useful when interacting with custom native memory sources (e.g. custom allocators),\n-     * where an address to some underlying memory region is typically obtained from native code (often as a plain {@code long} value).\n-     * <p>\n-     * The returned segment will feature all <a href=\"#access-modes\">access modes<\/a>\n-     * (see {@link MemorySegment#ALL_ACCESS}), and its confinement thread is the current thread (see {@link Thread#currentThread()}).\n+     Returns a new native memory segment with given size and resource scope (replacing the scope already associated\n+     * with this address), and whose base address is this address. This method can be useful when interacting with custom\n+     * native memory sources (e.g. custom allocators), where an address to some\n+     * underlying memory region is typically obtained from native code (often as a plain {@code long} value).\n+     * The returned segment is not read-only (see {@link MemorySegment#isReadOnly()}), and is associated with the\n+     * provided resource scope.\n@@ -105,2 +116,1 @@\n-     * Calling {@link MemorySegment#close()} on the returned segment will <em>not<\/em> result in releasing any\n-     * memory resources which might implicitly be associated with the segment. This method is equivalent to the following code:\n+     * This method is equivalent to the following code:\n@@ -108,1 +118,1 @@\n-    asSegmentRestricted(byteSize, null, null);\n+    asSegment(byteSize, null, scope);\n@@ -110,1 +120,3 @@\n-     * This method is <em>restricted<\/em>. Restricted methods are unsafe, and, if used incorrectly, their use might crash\n+     * <p>\n+     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n+     * Restricted method are unsafe, and, if used incorrectly, their use might crash\n@@ -115,1 +127,2 @@\n-     * @return a new confined native memory segment with given base address and size.\n+     * @param scope the native segment scope.\n+     * @return a new native memory segment with given base address, size and scope.\n@@ -117,3 +130,7 @@\n-     * @throws UnsupportedOperationException if this address is an heap address.\n-     * @throws IllegalAccessError if the runtime property {@code foreign.restricted} is not set to either\n-     * {@code permit}, {@code warn} or {@code debug} (the default value is set to {@code deny}).\n+     * @throws IllegalStateException if either the scope associated with this address or the provided scope\n+     * have been already closed, or if access occurs from a thread other than the thread owning either\n+     * scopes.\n+     * @throws UnsupportedOperationException if this address is not a {@linkplain #isNative() native} address.\n+     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n+     * {@code --enable-native-access} is either absent, or does not mention the module name {@code M}, or\n+     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n@@ -121,3 +138,2 @@\n-    default MemorySegment asSegmentRestricted(long bytesSize) {\n-        return asSegmentRestricted(bytesSize, null, null);\n-    }\n+    @CallerSensitive\n+    MemorySegment asSegment(long bytesSize, ResourceScope scope);\n@@ -126,8 +142,5 @@\n-     * Returns a new confined native memory segment with given size, and whose base address is this address; the returned segment has its own temporal\n-     * bounds, and can therefore be closed. This method can be useful when interacting with custom native memory sources (e.g. custom allocators),\n-     * where an address to some underlying memory region is typically obtained from native code (often as a plain {@code long} value).\n-     * <p>\n-     * The returned segment will feature all <a href=\"#access-modes\">access modes<\/a>\n-     * (see {@link MemorySegment#ALL_ACCESS}), and its confinement thread is the current thread (see {@link Thread#currentThread()}).\n-     * Moreover, the returned segment will keep a strong reference to the supplied attachment object (if any), which can\n-     * be useful in cases where the lifecycle of the segment is dependent on that of some other external resource.\n+     * Returns a new native memory segment with given size and resource scope (replacing the scope already associated\n+     * with this address), and whose base address is this address. This method can be useful when interacting with custom\n+     * native memory sources (e.g. custom allocators), where an address to some\n+     * underlying memory region is typically obtained from native code (often as a plain {@code long} value).\n+     * The returned segment is associated with the provided resource scope.\n@@ -139,6 +152,2 @@\n-     * Calling {@link MemorySegment#close()} on the returned segment will <em>not<\/em> result in releasing any\n-     * memory resources which might implicitly be associated with the segment, but will result in calling the\n-     * provided cleanup action (if any).\n-     * <p>\n-     * Both the cleanup action and the attachment object (if any) will be preserved under terminal operations such as\n-     * {@link MemorySegment#handoff(Thread)}, {@link MemorySegment#share()} and {@link MemorySegment#registerCleaner(Cleaner)}.\n+     * Calling {@link ResourceScope#close()} on the scope associated with the returned segment will result in calling\n+     * the provided cleanup action (if any).\n@@ -146,1 +155,2 @@\n-     * This method is <em>restricted<\/em>. Restricted methods are unsafe, and, if used incorrectly, their use might crash\n+     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n+     * Restricted method are unsafe, and, if used incorrectly, their use might crash\n@@ -152,2 +162,2 @@\n-     * @param attachment an attachment object that will be kept strongly reachable by the returned segment; can be {@code null}.\n-     * @return a new confined native memory segment with given base address and size.\n+     * @param scope the native segment scope.\n+     * @return a new native memory segment with given base address, size and scope.\n@@ -155,3 +165,14 @@\n-     * @throws UnsupportedOperationException if this address is an heap address.\n-     * @throws IllegalAccessError if the runtime property {@code foreign.restricted} is not set to either\n-     * {@code permit}, {@code warn} or {@code debug} (the default value is set to {@code deny}).\n+     * @throws IllegalStateException if either the scope associated with this address or the provided scope\n+     * have been already closed, or if access occurs from a thread other than the thread owning either\n+     * scopes.\n+     * @throws UnsupportedOperationException if this address is not a {@linkplain #isNative() native} address.\n+     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n+     * {@code --enable-native-access} is either absent, or does not mention the module name {@code M}, or\n+     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n+     *\/\n+    @CallerSensitive\n+    MemorySegment asSegment(long bytesSize, Runnable cleanupAction, ResourceScope scope);\n+\n+    \/**\n+     * Is this an off-heap memory address?\n+     * @return true, if this is an off-heap memory address.\n@@ -159,1 +180,1 @@\n-    MemorySegment asSegmentRestricted(long bytesSize, Runnable cleanupAction, Object attachment);\n+    boolean isNative();\n@@ -162,3 +183,5 @@\n-     * Returns the raw long value associated with this memory address.\n-     * @return The raw long value associated with this memory address.\n-     * @throws UnsupportedOperationException if this memory address is an heap address.\n+     * Returns the raw long value associated with this native memory address.\n+     * @return The raw long value associated with this native memory address.\n+     * @throws UnsupportedOperationException if this memory address is not a {@linkplain #isNative() native} address.\n+     * @throws IllegalStateException if the scope associated with this segment has been already closed,\n+     * or if access occurs from a thread other than the thread owning either segment.\n@@ -172,5 +195,4 @@\n-     * @apiNote two addresses might be considered equal despite their associated segments differ. This\n-     * can happen, for instance, if the segment associated with one address is a <em>slice<\/em>\n-     * (see {@link MemorySegment#asSlice(long, long)}) of the segment associated with the other address. Moreover,\n-     * two addresses might be considered equals despite differences in the temporal bounds associated with their\n-     * corresponding segments.\n+     * @apiNote two addresses might be considered equal despite their associated resource scopes differ. This\n+     * can happen, for instance, if the same memory address is used to create memory segments with different\n+     * scopes (using {@link #asSegment(long, ResourceScope)}), and the base address of the resulting segments is\n+     * then compared.\n@@ -192,1 +214,2 @@\n-     * The off-heap memory address instance modelling the {@code NULL} address.\n+     * The native memory address instance modelling the {@code NULL} address, associated\n+     * with the {@linkplain ResourceScope#globalScope() global} resource scope.\n@@ -194,1 +217,1 @@\n-    MemoryAddress NULL = new MemoryAddressImpl(null,  0L);\n+    MemoryAddress NULL = new MemoryAddressImpl(null, 0L);\n@@ -197,1 +220,2 @@\n-     * Obtain an off-heap memory address instance from given long address.\n+     * Obtain a native memory address instance from given long address. The returned address is associated\n+     * with the {@linkplain ResourceScope#globalScope() global} resource scope.\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemoryAddress.java","additions":84,"deletions":60,"binary":false,"changes":144,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n- * byte order associated to a memory access var handle. The resulting memory access var handle can then be combined in various ways\n+ * byte order associated with a memory access var handle. The resulting memory access var handle can then be combined in various ways\n@@ -54,3 +54,3 @@\n-GroupLayout seq = MemoryLayout.ofStruct(\n-        MemoryLayout.ofPaddingBits(32),\n-        MemoryLayout.ofValueBits(32, ByteOrder.BIG_ENDIAN).withName(\"value\")\n+GroupLayout seq = MemoryLayout.structLayout(\n+        MemoryLayout.paddingLayout(32),\n+        MemoryLayout.valueLayout(32, ByteOrder.BIG_ENDIAN).withName(\"value\")\n@@ -106,1 +106,1 @@\n-    private final static JavaLangInvokeAccess JLI = SharedSecrets.getJavaLangInvokeAccess();\n+    private static final JavaLangInvokeAccess JLI = SharedSecrets.getJavaLangInvokeAccess();\n@@ -257,1 +257,1 @@\n-    MemorySegment segment = MemorySegment.allocateNative(2);\n+    MemorySegment segment = MemorySegment.allocateNative(2, ResourceScope.newImplicitScope());\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemoryHandles.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n- * segment whose contents should be ignored, and which are primarily present for alignment reasons (see {@link MemoryLayout#ofPaddingBits(long)}).\n+ * segment whose contents should be ignored, and which are primarily present for alignment reasons (see {@link MemoryLayout#paddingLayout(long)}).\n@@ -71,5 +71,5 @@\n-SequenceLayout taggedValues = MemoryLayout.ofSequence(5,\n-    MemoryLayout.ofStruct(\n-        MemoryLayout.ofValueBits(8, ByteOrder.nativeOrder()).withName(\"kind\"),\n-        MemoryLayout.ofPaddingBits(24),\n-        MemoryLayout.ofValueBits(32, ByteOrder.nativeOrder()).withName(\"value\")\n+SequenceLayout taggedValues = MemoryLayout.sequenceLayout(5,\n+    MemoryLayout.structLayout(\n+        MemoryLayout.valueLayout(8, ByteOrder.nativeOrder()).withName(\"kind\"),\n+        MemoryLayout.paddingLayout(24),\n+        MemoryLayout.valueLayout(32, ByteOrder.nativeOrder()).withName(\"value\")\n@@ -147,1 +147,1 @@\n-MemoryLayout taggedValuesWithHole = taggedValues.map(l -> MemoryLayout.ofPadding(32),\n+MemoryLayout taggedValuesWithHole = taggedValues.map(l -> MemoryLayout.paddingLayout(32),\n@@ -153,5 +153,5 @@\n-MemoryLayout taggedValuesWithHole = MemoryLayout.ofSequence(5,\n-    MemoryLayout.ofStruct(\n-        MemoryLayout.ofValueBits(8, ByteOrder.nativeOrder()).withName(\"kind\").\n-        MemoryLayout.ofPaddingBits(32),\n-        MemoryLayout.ofPaddingBits(32)\n+MemoryLayout taggedValuesWithHole = MemoryLayout.sequenceLayout(5,\n+    MemoryLayout.structLayout(\n+        MemoryLayout.valueLayout(8, ByteOrder.nativeOrder()).withName(\"kind\"),\n+        MemoryLayout.paddingLayout(32),\n+        MemoryLayout.paddingLayout(32)\n@@ -194,1 +194,1 @@\n- * is the <em>layout name<\/em> (see {@link #LAYOUT_NAME}), a custom name that can be associated to memory layouts and that can be referred to when\n+ * is the <em>layout name<\/em> (see {@link #LAYOUT_NAME}), a custom name that can be associated with memory layouts and that can be referred to when\n@@ -197,4 +197,0 @@\n- * @apiNote In the future, if the Java language permits, {@link MemoryLayout}\n- * may become a {@code sealed} interface, which would prohibit subclassing except by\n- * explicitly permitted types.\n- *\n@@ -204,1 +200,1 @@\n-public interface MemoryLayout extends Constable {\n+public sealed interface MemoryLayout extends Constable permits AbstractLayout, SequenceLayout, GroupLayout, PaddingLayout, ValueLayout {\n@@ -221,1 +217,1 @@\n-     * Value layouts (see {@link ValueLayout}) and padding layouts (see {@link MemoryLayout#ofPaddingBits(long)})\n+     * Value layouts (see {@link ValueLayout}) and padding layouts (see {@link MemoryLayout#paddingLayout(long)})\n@@ -270,1 +266,1 @@\n-     * @return a new layout which is the same as this layout, except for the <em>name<\/em> associated to it.\n+     * @return a new layout which is the same as this layout, except for the <em>name<\/em> associated with it.\n@@ -319,1 +315,1 @@\n-     * @return a new layout which is the same as this layout, except for the alignment constraint associated to it.\n+     * @return a new layout which is the same as this layout, except for the alignment constraint associated with it.\n@@ -360,0 +356,2 @@\n+     * @throws NullPointerException if either {@code elements == null}, or if any of the elements\n+     * in {@code elements} is {@code null}.\n@@ -383,2 +381,3 @@\n-     * arguments, whereas {@code c_1}, {@code c_2}, ... {@code c_m} and {@code s_0}, {@code s_1}, ... {@code s_n} are\n-     * <em>static<\/em> stride constants which are derived from the layout path.\n+     * arguments, whereas {@code c_1}, {@code c_2}, ... {@code c_m} are <em>static<\/em> offset constants\n+     * and {@code s_0}, {@code s_1}, ... {@code s_n} are <em>static<\/em> stride constants which are derived from\n+     * the layout path.\n@@ -409,0 +408,2 @@\n+     * @throws NullPointerException if either {@code elements == null}, or if any of the elements\n+     * in {@code elements} is {@code null}.\n@@ -432,2 +433,3 @@\n-     * arguments, whereas {@code c_1}, {@code c_2}, ... {@code c_m} and {@code s_0}, {@code s_1}, ... {@code s_n} are\n-     * <em>static<\/em> stride constants which are derived from the layout path.\n+     * arguments, whereas {@code c_1}, {@code c_2}, ... {@code c_m} are <em>static<\/em> offset constants\n+     * and {@code s_0}, {@code s_1}, ... {@code s_n} are <em>static<\/em> stride constants which are derived from\n+     * the layout path.\n@@ -469,3 +471,4 @@\n-     * where {@code x_1}, {@code x_2}, ... {@code x_n} are <em>dynamic<\/em> values provided as optional {@code long}\n-     * access coordinates, whereas {@code c_1}, {@code c_2}, ... {@code c_m} and {@code s_0}, {@code s_1}, ... {@code s_n} are\n-     * <em>static<\/em> stride constants which are derived from the layout path.\n+     * where {@code x_1}, {@code x_2}, ... {@code x_n} are <em>dynamic<\/em> values provided as {@code long}\n+     * arguments, whereas {@code c_1}, {@code c_2}, ... {@code c_m} are <em>static<\/em> offset constants\n+     * and {@code s_0}, {@code s_1}, ... {@code s_n} are <em>static<\/em> stride constants which are derived from\n+     * the layout path.\n@@ -492,0 +495,44 @@\n+    \/**\n+     * Creates a method handle which, given a memory segment, returns a {@linkplain MemorySegment#asSlice(long,long) slice}\n+     * corresponding to the layout selected by a given layout path, where the path is considered rooted in this layout.\n+     *\n+     * <p>The returned method handle has a return type of {@code MemorySegment}, features a {@code MemorySegment}\n+     * parameter as leading parameter representing the segment to be sliced, and features as many trailing {@code long}\n+     * parameter types as there are free dimensions in the provided layout path (see {@link PathElement#sequenceElement()},\n+     * where the order of the parameters corresponds to the order of the path elements.\n+     * The returned method handle can be used to create a slice similar to using {@link MemorySegment#asSlice(long, long)},\n+     * but where the offset argument is dynamically compute based on indices specified when invoking the method handle.\n+     *\n+     * <p>The offset of the returned segment is computed as follows:\n+     *\n+     * <blockquote><pre>{@code\n+    bitOffset = c_1 + c_2 + ... + c_m + (x_1 * s_1) + (x_2 * s_2) + ... + (x_n * s_n)\n+    offset = bitOffset \/ 8\n+     * }<\/pre><\/blockquote>\n+     *\n+     * where {@code x_1}, {@code x_2}, ... {@code x_n} are <em>dynamic<\/em> values provided as {@code long}\n+     * arguments, whereas {@code c_1}, {@code c_2}, ... {@code c_m} are <em>static<\/em> offset constants\n+     * and {@code s_0}, {@code s_1}, ... {@code s_n} are <em>static<\/em> stride constants which are derived from\n+     * the layout path.\n+     *\n+     * <p>After the offset is computed, the returned segment is create as if by calling:\n+     * <blockquote><pre>{@code\n+    segment.asSlice(offset, layout.byteSize());\n+     * }<\/pre><\/blockquote>\n+     *\n+     * where {@code segment} is the segment to be sliced, and where {@code layout} is the layout selected by the given\n+     * layout path, as per {@link MemoryLayout#select(PathElement...)}.\n+     *\n+     * <p>The method handle will throw an {@link UnsupportedOperationException} if the computed\n+     * offset in bits is not a multiple of 8.\n+     *\n+     * @param elements the layout path elements.\n+     * @return a method handle which can be used to create a slice of the selected layout element, given a segment.\n+     * @throws UnsupportedOperationException if the size of the selected layout in bits is not a multiple of 8.\n+     *\/\n+    default MethodHandle sliceHandle(PathElement... elements) {\n+        return computePathOp(LayoutPath.rootPath(this, MemoryLayout::bitSize), LayoutPath::sliceHandle,\n+                Set.of(), elements);\n+    }\n+\n+\n@@ -538,1 +585,1 @@\n-     * Is this a padding layout (e.g. a layout created from {@link #ofPaddingBits(long)}) ?\n+     * Is this a padding layout (e.g. a layout created from {@link #paddingLayout(long)}) ?\n@@ -557,4 +604,0 @@\n-     * @apiNote In the future, if the Java language permits, {@link PathElement}\n-     * may become a {@code sealed} interface, which would prohibit subclassing except by\n-     * explicitly permitted types.\n-     *\n@@ -564,1 +607,1 @@\n-    interface PathElement {\n+    sealed interface PathElement permits LayoutPath.PathElementImpl {\n@@ -682,1 +725,1 @@\n-    static MemoryLayout ofPaddingBits(long size) {\n+    static MemoryLayout paddingLayout(long size) {\n@@ -695,1 +738,1 @@\n-    static ValueLayout ofValueBits(long size, ByteOrder order) {\n+    static ValueLayout valueLayout(long size, ByteOrder order) {\n@@ -709,1 +752,1 @@\n-    static SequenceLayout ofSequence(long elementCount, MemoryLayout elementLayout) {\n+    static SequenceLayout sequenceLayout(long elementCount, MemoryLayout elementLayout) {\n@@ -721,1 +764,1 @@\n-    static SequenceLayout ofSequence(MemoryLayout elementLayout) {\n+    static SequenceLayout sequenceLayout(MemoryLayout elementLayout) {\n@@ -731,1 +774,1 @@\n-    static GroupLayout ofStruct(MemoryLayout... elements) {\n+    static GroupLayout structLayout(MemoryLayout... elements) {\n@@ -745,1 +788,1 @@\n-    static GroupLayout ofUnion(MemoryLayout... elements) {\n+    static GroupLayout unionLayout(MemoryLayout... elements) {\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemoryLayout.java","additions":83,"deletions":40,"binary":false,"changes":123,"status":"modified"},{"patch":"@@ -49,1 +49,1 @@\n-    public static final ValueLayout BITS_8_LE = MemoryLayout.ofValueBits(8, ByteOrder.LITTLE_ENDIAN);\n+    public static final ValueLayout BITS_8_LE = MemoryLayout.valueLayout(8, ByteOrder.LITTLE_ENDIAN);\n@@ -54,1 +54,1 @@\n-    public static final ValueLayout BITS_16_LE = MemoryLayout.ofValueBits(16, ByteOrder.LITTLE_ENDIAN);\n+    public static final ValueLayout BITS_16_LE = MemoryLayout.valueLayout(16, ByteOrder.LITTLE_ENDIAN);\n@@ -59,1 +59,1 @@\n-    public static final ValueLayout BITS_32_LE = MemoryLayout.ofValueBits(32, ByteOrder.LITTLE_ENDIAN);\n+    public static final ValueLayout BITS_32_LE = MemoryLayout.valueLayout(32, ByteOrder.LITTLE_ENDIAN);\n@@ -64,1 +64,1 @@\n-    public static final ValueLayout BITS_64_LE = MemoryLayout.ofValueBits(64, ByteOrder.LITTLE_ENDIAN);\n+    public static final ValueLayout BITS_64_LE = MemoryLayout.valueLayout(64, ByteOrder.LITTLE_ENDIAN);\n@@ -69,1 +69,1 @@\n-    public static final ValueLayout BITS_8_BE = MemoryLayout.ofValueBits(8, ByteOrder.BIG_ENDIAN);\n+    public static final ValueLayout BITS_8_BE = MemoryLayout.valueLayout(8, ByteOrder.BIG_ENDIAN);\n@@ -74,1 +74,1 @@\n-    public static final ValueLayout BITS_16_BE = MemoryLayout.ofValueBits(16, ByteOrder.BIG_ENDIAN);\n+    public static final ValueLayout BITS_16_BE = MemoryLayout.valueLayout(16, ByteOrder.BIG_ENDIAN);\n@@ -79,1 +79,1 @@\n-    public static final ValueLayout BITS_32_BE = MemoryLayout.ofValueBits(32, ByteOrder.BIG_ENDIAN);\n+    public static final ValueLayout BITS_32_BE = MemoryLayout.valueLayout(32, ByteOrder.BIG_ENDIAN);\n@@ -84,1 +84,1 @@\n-    public static final ValueLayout BITS_64_BE = MemoryLayout.ofValueBits(64, ByteOrder.BIG_ENDIAN);\n+    public static final ValueLayout BITS_64_BE = MemoryLayout.valueLayout(64, ByteOrder.BIG_ENDIAN);\n@@ -89,1 +89,1 @@\n-    public static final MemoryLayout PAD_8 = MemoryLayout.ofPaddingBits(8);\n+    public static final MemoryLayout PAD_8 = MemoryLayout.paddingLayout(8);\n@@ -94,1 +94,1 @@\n-    public static final MemoryLayout PAD_16 = MemoryLayout.ofPaddingBits(16);\n+    public static final MemoryLayout PAD_16 = MemoryLayout.paddingLayout(16);\n@@ -99,1 +99,1 @@\n-    public static final MemoryLayout PAD_32 = MemoryLayout.ofPaddingBits(32);\n+    public static final MemoryLayout PAD_32 = MemoryLayout.paddingLayout(32);\n@@ -104,1 +104,1 @@\n-    public static final MemoryLayout PAD_64 = MemoryLayout.ofPaddingBits(64);\n+    public static final MemoryLayout PAD_64 = MemoryLayout.paddingLayout(64);\n@@ -109,1 +109,1 @@\n-    public static final ValueLayout ADDRESS = MemoryLayout.ofValueBits(Unsafe.ADDRESS_SIZE * 8, ByteOrder.nativeOrder());\n+    public static final ValueLayout ADDRESS = MemoryLayout.valueLayout(Unsafe.ADDRESS_SIZE * 8, ByteOrder.nativeOrder());\n@@ -114,1 +114,1 @@\n-    public static final ValueLayout JAVA_BYTE = MemoryLayout.ofValueBits(8, ByteOrder.nativeOrder());\n+    public static final ValueLayout JAVA_BYTE = MemoryLayout.valueLayout(8, ByteOrder.nativeOrder());\n@@ -119,1 +119,1 @@\n-    public static final ValueLayout JAVA_CHAR = MemoryLayout.ofValueBits(16, ByteOrder.nativeOrder());\n+    public static final ValueLayout JAVA_CHAR = MemoryLayout.valueLayout(16, ByteOrder.nativeOrder());\n@@ -124,1 +124,1 @@\n-    public static final ValueLayout JAVA_SHORT = MemoryLayout.ofValueBits(16, ByteOrder.nativeOrder());\n+    public static final ValueLayout JAVA_SHORT = MemoryLayout.valueLayout(16, ByteOrder.nativeOrder());\n@@ -129,1 +129,1 @@\n-    public static final ValueLayout JAVA_INT = MemoryLayout.ofValueBits(32, ByteOrder.nativeOrder());\n+    public static final ValueLayout JAVA_INT = MemoryLayout.valueLayout(32, ByteOrder.nativeOrder());\n@@ -139,1 +139,1 @@\n-    public static final ValueLayout JAVA_LONG = MemoryLayout.ofValueBits(64, ByteOrder.nativeOrder())\n+    public static final ValueLayout JAVA_LONG = MemoryLayout.valueLayout(64, ByteOrder.nativeOrder())\n@@ -145,1 +145,1 @@\n-    public static final ValueLayout JAVA_FLOAT = MemoryLayout.ofValueBits(32, ByteOrder.nativeOrder());\n+    public static final ValueLayout JAVA_FLOAT = MemoryLayout.valueLayout(32, ByteOrder.nativeOrder());\n@@ -155,1 +155,1 @@\n-    public static final ValueLayout JAVA_DOUBLE = MemoryLayout.ofValueBits(64, ByteOrder.nativeOrder())\n+    public static final ValueLayout JAVA_DOUBLE = MemoryLayout.valueLayout(64, ByteOrder.nativeOrder())\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemoryLayouts.java","additions":20,"deletions":20,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -29,2 +29,1 @@\n-import java.io.FileDescriptor;\n-import java.lang.ref.Cleaner;\n+import java.io.UncheckedIOException;\n@@ -36,0 +35,1 @@\n+import jdk.internal.foreign.ResourceScopeImpl;\n@@ -37,1 +37,2 @@\n-import jdk.internal.foreign.Utils;\n+import jdk.internal.reflect.CallerSensitive;\n+import jdk.internal.reflect.Reflection;\n@@ -43,1 +44,0 @@\n-import java.util.Optional;\n@@ -45,0 +45,1 @@\n+import java.util.stream.Stream;\n@@ -48,1 +49,1 @@\n- * and temporal bounds. Spatial bounds ensure that memory access operations on a memory segment cannot affect a memory location\n+ * and temporal bounds (e.g. a {@link ResourceScope}). Spatial bounds ensure that memory access operations on a memory segment cannot affect a memory location\n@@ -50,1 +51,1 @@\n- * operations on a segment cannot occur after a memory segment has been closed (see {@link MemorySegment#close()}).\n+ * operations on a segment cannot occur after the resource scope associated with a memory segment has been closed (see {@link ResourceScope#close()}).\n@@ -65,2 +66,2 @@\n- * be allocated using one of the many factory methods provided (see {@link MemorySegment#allocateNative(MemoryLayout)},\n- * {@link MemorySegment#allocateNative(long)} and {@link MemorySegment#allocateNative(long, long)}). Memory segments obtained\n+ * be allocated using one of the many factory methods provided (see {@link MemorySegment#allocateNative(MemoryLayout, ResourceScope)},\n+ * {@link MemorySegment#allocateNative(long, ResourceScope)} and {@link MemorySegment#allocateNative(long, long, ResourceScope)}). Memory segments obtained\n@@ -80,12 +81,0 @@\n- * <p>\n- * Finally, it is also possible to obtain a memory segment backed by a memory-mapped file using the factory method\n- * {@link MemorySegment#mapFile(Path, long, long, FileChannel.MapMode)}. Such memory segments are called <em>mapped memory segments<\/em>;\n- * mapped memory segments are associated with an underlying file descriptor. For more operations on mapped memory segments, please refer to the\n- * {@link MappedMemorySegments} class.\n- * <p>\n- * Array and buffer segments are effectively <em>views<\/em> over existing memory regions which might outlive the\n- * lifecycle of the segments derived from them, and can even be manipulated directly (e.g. via array access, or direct use\n- * of the {@link ByteBuffer} API) by other clients. As a result, while sharing array or buffer segments is possible,\n- * it is strongly advised that clients wishing to do so take extra precautions to make sure that the underlying memory sources\n- * associated with such segments remain inaccessible, and that said memory sources are never aliased by more than one segment\n- * at a time - e.g. so as to prevent concurrent modifications of the contents of an array, or buffer segment.\n@@ -93,1 +82,1 @@\n- * <h2>Explicit deallocation<\/h2>\n+ * <h2>Mapping memory segments from files<\/h2>\n@@ -95,3 +84,9 @@\n- * Memory segments are closed explicitly (see {@link MemorySegment#close()}). When a segment is closed, it is no longer\n- * <em>alive<\/em> (see {@link #isAlive()}, and subsequent operation on the segment (or on any {@link MemoryAddress} instance\n- * derived from it) will fail with {@link IllegalStateException}.\n+ * It is also possible to obtain a native memory segment backed by a memory-mapped file using the factory method\n+ * {@link MemorySegment#mapFile(Path, long, long, FileChannel.MapMode, ResourceScope)}. Such native memory segments are\n+ * called <em>mapped memory segments<\/em>; mapped memory segments are associated with an underlying file descriptor.\n+ * <p>\n+ * Contents of mapped memory segments can be {@linkplain #force() persisted} and {@linkplain #load() loaded} to and from the underlying file;\n+ * these capabilities are suitable replacements for some of the functionality in the {@link java.nio.MappedByteBuffer} class.\n+ * Note that, while it is possible to map a segment into a byte buffer (see {@link MemorySegment#asByteBuffer()}),\n+ * and then call e.g. {@link java.nio.MappedByteBuffer#force()} that way, this can only be done when the source segment\n+ * is small enough, due to the size limitation inherent to the ByteBuffer API.\n@@ -99,11 +94,4 @@\n- * Closing a segment might trigger the releasing of the underlying memory resources associated with said segment, depending on\n- * the kind of memory segment being considered:\n- * <ul>\n- *     <li>closing a native memory segment results in <em>freeing<\/em> the native memory associated with it<\/li>\n- *     <li>closing a mapped memory segment results in the backing memory-mapped file to be unmapped<\/li>\n- *     <li>closing a buffer, or a heap segment does not have any side-effect, other than marking the segment\n- *     as <em>not alive<\/em> (see {@link MemorySegment#isAlive()}). Also, since the buffer and heap segments might keep\n- *     strong references to the original buffer or array instance, it is the responsibility of clients to ensure that\n- *     these segments are discarded in a timely manner, so as not to prevent garbage collection to reclaim the underlying\n- *     objects.<\/li>\n- * <\/ul>\n+ * Clients requiring sophisticated, low-level control over mapped memory segments, should consider writing\n+ * custom mapped memory segment factories; using {@link CLinker}, e.g. on Linux, it is possible to call {@code mmap}\n+ * with the desired parameters; the returned address can be easily wrapped into a memory segment, using\n+ * {@link MemoryAddress#ofLong(long)} and {@link MemoryAddress#asSegment(long, Runnable, ResourceScope)}.\n@@ -111,1 +99,1 @@\n- * <h2><a id = \"access-modes\">Access modes<\/a><\/h2>\n+ * <h2>Lifecycle and confinement<\/h2>\n@@ -113,4 +101,14 @@\n- * Memory segments supports zero or more <em>access modes<\/em>. Supported access modes are {@link #READ},\n- * {@link #WRITE}, {@link #CLOSE}, {@link #SHARE} and {@link #HANDOFF}. The set of access modes supported by a segment alters the\n- * set of operations that are supported by that segment. For instance, attempting to call {@link #close()} on\n- * a segment which does not support the {@link #CLOSE} access mode will result in an exception.\n+ * Memory segments are associated with a resource scope (see {@link ResourceScope}), which can be accessed using\n+ * the {@link #scope()} method. As for all resources associated with a resource scope, a segment cannot be\n+ * accessed after its corresponding scope has been closed. For instance, the following code will result in an\n+ * exception:\n+ * <blockquote><pre>{@code\n+MemorySegment segment = null;\n+try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+    segment = MemorySegment.allocateNative(8, 1, scope);\n+}\n+MemoryAccess.getLong(segment); \/\/ already closed!\n+ * }<\/pre><\/blockquote>\n+ * Additionally, access to a memory segment is subject to the thread-confinement checks enforced by the owning scope; that is,\n+ * if the segment is associated with a shared scope, it can be accessed by multiple threads; if it is associated with a confined\n+ * scope, it can only be accessed by the thread which owns the scope.\n@@ -118,4 +116,2 @@\n- * The set of supported access modes can only be made stricter (by supporting <em>fewer<\/em> access modes). This means\n- * that restricting the set of access modes supported by a segment before sharing it with other clients\n- * is generally a good practice if the creator of the segment wants to retain some control over how the segment\n- * is going to be accessed.\n+ * Heap and buffer segments are always associated with a <em>global<\/em>, shared scope. This scope cannot be closed,\n+ * and can be considered as <em>always alive<\/em>.\n@@ -125,2 +121,1 @@\n- * Memory segments support <em>views<\/em>. For instance, it is possible to alter the set of supported access modes,\n- * by creating an <em>immutable<\/em> view of a memory segment, as follows:\n+ * Memory segments support <em>views<\/em>. For instance, it is possible to create an <em>immutable<\/em> view of a memory segment, as follows:\n@@ -129,1 +124,1 @@\n-MemorySegment roSegment = segment.withAccessModes(segment.accessModes() & ~WRITE);\n+MemorySegment roSegment = segment.asReadOnly();\n@@ -134,5 +129,2 @@\n- * Temporal bounds of the original segment are inherited by the view; that is, closing a segment view, such as a sliced\n- * view, will cause the original segment to be closed; as such special care must be taken when sharing views\n- * between multiple clients. If a client want to protect itself against early closure of a segment by\n- * another actor, it is the responsibility of that client to take protective measures, such as removing {@link #CLOSE}\n- * from the set of supported access modes, before sharing the view with another client.\n+ * Temporal bounds of the original segment are inherited by the views; that is, when the scope associated with a segment\n+ * is closed, all the views associated with that segment will also be rendered inaccessible.\n@@ -143,1 +135,1 @@\n- * the same spatial and temporal access restrictions associated to the memory segment from which they originated.\n+ * the same spatial and temporal access restrictions associated with the memory segment from which they originated.\n@@ -145,1 +137,1 @@\n- * <h2><a id = \"thread-confinement\">Thread confinement<\/a><\/h2>\n+ * <h2>Stream support<\/h2>\n@@ -147,12 +139,4 @@\n- * Memory segments support strong thread-confinement guarantees. Upon creation, they are assigned an <em>owner thread<\/em>,\n- * typically the thread which initiated the creation operation. After creation, only the owner thread will be allowed\n- * to directly manipulate the memory segment (e.g. close the memory segment) or access the underlying memory associated with\n- * the segment using a memory access var handle. Any attempt to perform such operations from a thread other than the\n- * owner thread will result in a runtime failure.\n- * <p>\n- * The {@link #handoff(Thread)} method can be used to change the thread-confinement properties of a memory segment.\n- * This method is, like {@link #close()}, a <em>terminal operation<\/em> which marks the original segment as not alive\n- * (see {@link #isAlive()}) and creates a <em>new<\/em> segment with the desired thread-confinement properties. Calling\n- * {@link #handoff(Thread)} is only possible if the segment features the corresponding {@link #HANDOFF} access mode.\n- * <p>\n- * For instance, if a client wants to transfer ownership of a segment to another (known) thread, it can do so as follows:\n+ * A client might obtain a {@link Stream} from a segment, which can then be used to slice the segment (according to a given\n+ * element layout) and even allow multiple threads to work in parallel on disjoint segment slices\n+ * (to do this, the segment has to be associated with a shared scope). The following code can be used to sum all int\n+ * values in a memory segment in parallel:\n@@ -161,26 +145,3 @@\n-MemorySegment segment = ...\n-MemorySegment aSegment = segment.handoff(threadA);\n- * }<\/pre><\/blockquote>\n- *\n- * By doing so, the original segment is marked as not alive, and a new segment is returned whose owner thread\n- * is {@code threadA}; this allows, for instance, for two threads {@code A} and {@code B} to share\n- * a segment in a controlled, cooperative and race-free fashion (also known as <em>serial thread confinement<\/em>).\n- * <p>\n- * Alternatively, the {@link #share()} method can be used to remove thread ownership altogether; this is only possible\n- * if the segment features the corresponding {@link #SHARE} access mode. The following code shows how clients can\n- * obtain a shared segment:\n- *\n- * <blockquote><pre>{@code\n-MemorySegment segment = ...\n-MemorySegment sharedSegment = segment.share();\n- * }<\/pre><\/blockquote>\n- *\n- * Again here, the original segment is marked as not alive, and a new <em>shared<\/em> segment is returned which features no owner\n- * thread (e.g. {@link #ownerThread()} returns {@code null}). This might be useful when multiple threads need to process\n- * the contents of the same memory segment concurrently (e.g. in the case of parallel processing). For instance, a client\n- * might obtain a {@link Spliterator} from a shared segment, which can then be used to slice the segment and allow multiple\n- * threads to work in parallel on disjoint segment slices. The following code can be used to sum all int values in a memory segment in parallel:\n- *\n- * <blockquote><pre>{@code\n-SequenceLayout SEQUENCE_LAYOUT = MemoryLayout.ofSequence(1024, MemoryLayouts.JAVA_INT);\n-try (MemorySegment segment = MemorySegment.allocateNative(SEQUENCE_LAYOUT).share()) {\n+try (ResourceScope scope = ResourceScope.newSharedScope()) {\n+    SequenceLayout SEQUENCE_LAYOUT = MemoryLayout.sequenceLayout(1024, MemoryLayouts.JAVA_INT);\n+    MemorySegment segment = MemorySegment.allocateNative(SEQUENCE_LAYOUT, scope);\n@@ -188,1 +149,1 @@\n-    int sum = StreamSupport.stream(segment.spliterator(SEQUENCE_LAYOUT), true)\n+    int sum = segment.elements(MemoryLayouts.JAVA_INT).parallel()\n@@ -194,29 +155,0 @@\n- * Once shared, a segment can be claimed back by a given thread (again using {@link #handoff(Thread)}); in fact, many threads\n- * can attempt to gain ownership of the same segment, concurrently, and only one of them is guaranteed to succeed.\n- * <p>\n- * When using shared segments, clients should make sure that no other thread is accessing the segment while\n- * the segment is being closed. If one or more threads attempts to access a segment concurrently while the\n- * segment is being closed, an exception might occur on both the accessing and the closing threads. Clients should\n- * refrain from attempting to close a segment repeatedly (e.g. keep calling {@link #close()} until no exception is thrown);\n- * such exceptions should instead be seen as an indication that the client code is lacking appropriate synchronization between the threads\n- * accessing\/closing the segment.\n- *\n- * <h2>Implicit deallocation<\/h2>\n- *\n- * Clients can register a memory segment against a {@link Cleaner}, to make sure that underlying resources associated with\n- * that segment will be released when the segment becomes <em>unreachable<\/em>, which can be useful to prevent native memory\n- * leaks. This can be achieved using the {@link #registerCleaner(Cleaner)} method, as follows:\n- *\n- * <blockquote><pre>{@code\n-MemorySegment segment = ...\n-MemorySegment gcSegment = segment.registerCleaner(cleaner);\n- * }<\/pre><\/blockquote>\n- *\n- * Here, the original segment is marked as not alive, and a new segment is returned (the owner thread of the returned\n- * segment set is set to that of the current thread, see {@link #ownerThread()}); the new segment\n- * will also be registered with the the {@link Cleaner} instance provided to the {@link #registerCleaner(Cleaner)} method;\n- * as such, if not closed explicitly (see {@link #close()}), the new segment will be automatically closed by the cleaner.\n- *\n- * @apiNote In the future, if the Java language permits, {@link MemorySegment}\n- * may become a {@code sealed} interface, which would prohibit subclassing except by other explicitly permitted subtypes.\n- *\n@@ -226,1 +158,1 @@\n-public interface MemorySegment extends Addressable, AutoCloseable {\n+public sealed interface MemorySegment extends Addressable permits AbstractMemorySegmentImpl {\n@@ -229,3 +161,2 @@\n-     * The base memory address associated with this memory segment. The returned address is\n-     * a <em>checked<\/em> memory address and can therefore be used in dereference operations\n-     * (see {@link MemoryAddress}).\n+     * The base memory address associated with this memory segment.\n+     * The returned memory address is associated with same resource scope as that associated with this segment.\n@@ -233,2 +164,0 @@\n-     * @throws IllegalStateException if this segment is not <em>alive<\/em>, or if access occurs from a thread other than the\n-     * thread owning this segment\n@@ -244,5 +173,5 @@\n-     * The returned spliterator splits this segment according to the specified sequence layout; that is,\n-     * if the supplied layout is a sequence layout whose element count is {@code N}, then calling {@link Spliterator#trySplit()}\n-     * will result in a spliterator serving approximatively {@code N\/2} elements (depending on whether N is even or not).\n-     * As such, splitting is possible as long as {@code N >= 2}. The spliterator returns segments that feature the same\n-     * <a href=\"#access-modes\">access modes<\/a> as the given segment less the {@link #CLOSE} access mode.\n+     * The returned spliterator splits this segment according to the specified element layout; that is,\n+     * if the supplied layout has size N, then calling {@link Spliterator#trySplit()} will result in a spliterator serving\n+     * approximately {@code S\/N\/2} elements (depending on whether N is even or not), where {@code S} is the size of\n+     * this segment. As such, splitting is possible as long as {@code S\/N >= 2}. The spliterator returns segments that feature the same\n+     * scope as this given segment.\n@@ -251,1 +180,1 @@\n-     * be processed in parallel by multiple threads (if the segment is shared).\n+     * be processed in parallel by multiple threads.\n@@ -253,1 +182,1 @@\n-     * @param layout the layout to be used for splitting.\n+     * @param elementLayout the layout to be used for splitting.\n@@ -255,8 +184,2 @@\n-     * @throws IllegalStateException if the segment is not <em>alive<\/em>, or if access occurs from a thread other than the\n-     * thread owning this segment\n-     *\/\n-    Spliterator<MemorySegment> spliterator(SequenceLayout layout);\n-\n-    \/**\n-     * The thread owning this segment.\n-     * @return the thread owning this segment.\n+     * @throws IllegalArgumentException if the {@code elementLayout} size is zero, or the segment size modulo the\n+     * {@code elementLayout} size is greater than zero.\n@@ -264,1 +187,1 @@\n-    Thread ownerThread();\n+    Spliterator<MemorySegment> spliterator(MemoryLayout elementLayout);\n@@ -267,14 +190,10 @@\n-     * The size (in bytes) of this memory segment.\n-     * @return The size (in bytes) of this memory segment.\n-     *\/\n-    long byteSize();\n-\n-    \/**\n-     * Obtains a segment view with specific <a href=\"#access-modes\">access modes<\/a>. Supported access modes are {@link #READ}, {@link #WRITE},\n-     * {@link #CLOSE}, {@link #SHARE} and {@link #HANDOFF}. It is generally not possible to go from a segment with stricter access modes\n-     * to one with less strict access modes. For instance, attempting to add {@link #WRITE} access mode to a read-only segment\n-     * will be met with an exception.\n-     * @param accessModes an ORed mask of zero or more access modes.\n-     * @return a segment view with specific access modes.\n-     * @throws IllegalArgumentException when {@code mask} is an access mask which is less strict than the one supported by this\n-     * segment, or when {@code mask} contains bits not associated with any of the supported access modes.\n+     * Returns a sequential {@code Stream} over disjoint slices (whose size matches that of the specified layout)\n+     * in this segment. Calling this method is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    StreamSupport.stream(segment.spliterator(elementLayout), false);\n+     * }<\/pre><\/blockquote>\n+     *\n+     * @param elementLayout the layout to be used for splitting.\n+     * @return a sequential {@code Stream} over disjoint slices in this segment.\n+     * @throws IllegalArgumentException if the {@code elementLayout} size is zero, or the segment size modulo the\n+     * {@code elementLayout} size is greater than zero.\n@@ -282,1 +201,1 @@\n-    MemorySegment withAccessModes(int accessModes);\n+    Stream<MemorySegment> elements(MemoryLayout elementLayout);\n@@ -285,4 +204,2 @@\n-     * Does this segment support a given set of access modes?\n-     * @param accessModes an ORed mask of zero or more access modes.\n-     * @return true, if the access modes in {@code accessModes} are stricter than the ones supported by this segment.\n-     * @throws IllegalArgumentException when {@code mask} contains bits not associated with any of the supported access modes.\n+     * Returns the resource scope associated with this memory segment.\n+     * @return the resource scope associated with this memory segment.\n@@ -290,1 +207,1 @@\n-    boolean hasAccessModes(int accessModes);\n+    ResourceScope scope();\n@@ -293,3 +210,2 @@\n-     * Returns the <a href=\"#access-modes\">access modes<\/a> associated with this segment; the result is represented as ORed values from\n-     * {@link #READ}, {@link #WRITE}, {@link #CLOSE}, {@link #SHARE} and {@link #HANDOFF}.\n-     * @return the access modes associated with this segment.\n+     * The size (in bytes) of this memory segment.\n+     * @return The size (in bytes) of this memory segment.\n@@ -297,1 +213,1 @@\n-    int accessModes();\n+    long byteSize();\n@@ -380,4 +296,3 @@\n-     * Is this a mapped segment? Returns true if this segment is a mapped memory segment,\n-     * created using the {@link #mapFile(Path, long, long, FileChannel.MapMode)} factory, or a buffer segment\n-     * derived from a {@link java.nio.MappedByteBuffer} using the {@link #ofByteBuffer(ByteBuffer)} factory.\n-     * @return {@code true} if this segment is a mapped segment.\n+     * Is this segment read-only?\n+     * @return {@code true}, if this segment is read-only.\n+     * @see #asReadOnly()\n@@ -385,1 +300,1 @@\n-    boolean isMapped();\n+    boolean isReadOnly();\n@@ -388,3 +303,4 @@\n-     * Is this segment alive?\n-     * @return true, if the segment is alive.\n-     * @see MemorySegment#close()\n+     * Obtains a read-only view of this segment. The resulting segment will be identical to this one, but\n+     * attempts to overwrite the contents of the returned segment will cause runtime exceptions.\n+     * @return a read-only view of this segment\n+     * @see #isReadOnly()\n@@ -392,1 +308,1 @@\n-    boolean isAlive();\n+    MemorySegment asReadOnly();\n@@ -395,18 +311,5 @@\n-     * Closes this memory segment. This is a <em>terminal operation<\/em>; as a side-effect, if this operation completes\n-     * without exceptions, this segment will be marked as <em>not alive<\/em>, and subsequent operations on this segment\n-     * will fail with {@link IllegalStateException}.\n-     * <p>\n-     * Depending on the kind of memory segment being closed, calling this method further triggers deallocation of all the resources\n-     * associated with the memory segment.\n-     *\n-     * @apiNote This operation is not idempotent; that is, closing an already closed segment <em>always<\/em> results in an\n-     * exception being thrown. This reflects a deliberate design choice: segment state transitions should be\n-     * manifest in the client code; a failure in any of these transitions reveals a bug in the underlying application\n-     * logic. This is especially useful when reasoning about the lifecycle of dependent segment views (see {@link #asSlice(MemoryAddress)},\n-     * where closing one segment might side-effect multiple segments. In such cases it might in fact not be obvious, looking\n-     * at the code, as to whether a given segment is alive or not.\n-     *\n-     * @throws IllegalStateException if this segment is not <em>alive<\/em>, or if access occurs from a thread other than the\n-     * thread owning this segment, or if this segment is shared and the segment is concurrently accessed while this method is\n-     * called.\n-     * @throws UnsupportedOperationException if this segment does not support the {@link #CLOSE} access mode.\n+     * Is this a native segment? Returns true if this segment is a native memory segment,\n+     * created using the {@link #allocateNative(long, ResourceScope)} (and related) factory, or a buffer segment\n+     * derived from a direct {@link java.nio.ByteBuffer} using the {@link #ofByteBuffer(ByteBuffer)} factory,\n+     * or if this is a {@linkplain #isMapped() mapped} segment.\n+     * @return {@code true} if this segment is native segment.\n@@ -414,1 +317,1 @@\n-    void close();\n+    boolean isNative();\n@@ -417,88 +320,4 @@\n-     * Obtains a new confined memory segment backed by the same underlying memory region as this segment. The returned segment will\n-     * be confined on the specified thread, and will feature the same spatial bounds and access modes (see {@link #accessModes()})\n-     * as this segment.\n-     * <p>\n-     * This is a <em>terminal operation<\/em>; as a side-effect, if this operation completes\n-     * without exceptions, this segment will be marked as <em>not alive<\/em>, and subsequent operations on this segment\n-     * will fail with {@link IllegalStateException}.\n-     * <p>\n-     * In case where the owner thread of the returned segment differs from that of this segment, write accesses to this\n-     * segment's content <a href=\"..\/..\/..\/java\/util\/concurrent\/package-summary.html#MemoryVisibility\"><i>happens-before<\/i><\/a>\n-     * hand-over from the current owner thread to the new owner thread, which in turn <i>happens before<\/i> read accesses\n-     * to the returned segment's contents on the new owner thread.\n-     *\n-     * @param thread the new owner thread\n-     * @return a new confined memory segment whose owner thread is set to {@code thread}.\n-     * @throws IllegalStateException if this segment is not <em>alive<\/em>, or if access occurs from a thread other than the\n-     * thread owning this segment.\n-     * @throws UnsupportedOperationException if this segment does not support the {@link #HANDOFF} access mode.\n-     *\/\n-    MemorySegment handoff(Thread thread);\n-\n-    \/**\n-     * Obtains a new confined memory segment backed by the same underlying memory region as this segment, but whose\n-     * temporal bounds are controlled by the provided {@link NativeScope} instance.\n-     * <p>\n-     * This is a <em>terminal operation<\/em>;\n-     * as a side-effect, this segment will be marked as <em>not alive<\/em>, and subsequent operations on this segment\n-     * will fail with {@link IllegalStateException}.\n-     * <p>\n-     * The returned segment will feature only {@link MemorySegment#READ} and {@link MemorySegment#WRITE} access modes\n-     * (assuming these were available in the original segment). As such the returned segment cannot be closed directly\n-     * using {@link MemorySegment#close()} - but it will be closed indirectly when this native scope is closed. The\n-     * returned segment will also be confined by the same thread as the provided native scope (see {@link NativeScope#ownerThread()}).\n-     * <p>\n-     * In case where the owner thread of the returned segment differs from that of this segment, write accesses to this\n-     * segment's content <a href=\"..\/..\/..\/java\/util\/concurrent\/package-summary.html#MemoryVisibility\"><i>happens-before<\/i><\/a>\n-     * hand-over from the current owner thread to the new owner thread, which in turn <i>happens before<\/i> read accesses\n-     * to the returned segment's contents on the new owner thread.\n-     *\n-     * @param nativeScope the native scope.\n-     * @return a new confined memory segment backed by the same underlying memory region as this segment, but whose life-cycle\n-     * is tied to that of {@code nativeScope}.\n-     * @throws IllegalStateException if this segment is not <em>alive<\/em>, or if access occurs from a thread other than the\n-     * thread owning this segment.\n-     * @throws UnsupportedOperationException if this segment does not support the {@link #HANDOFF} access mode.\n-     *\/\n-    MemorySegment handoff(NativeScope nativeScope);\n-\n-    \/**\n-     * Obtains a new shared memory segment backed by the same underlying memory region as this segment. The returned segment will\n-     * not be confined on any thread and can therefore be accessed concurrently from multiple threads; moreover, the\n-     * returned segment will feature the same spatial bounds and access modes (see {@link #accessModes()})\n-     * as this segment.\n-     * <p>\n-     * This is a <em>terminal operation<\/em>; as a side-effect, if this operation completes\n-     * without exceptions, this segment will be marked as <em>not alive<\/em>, and subsequent operations on this segment\n-     * will fail with {@link IllegalStateException}.\n-     * <p>\n-     * Write accesses to this segment's content <a href=\"..\/..\/..\/java\/util\/concurrent\/package-summary.html#MemoryVisibility\"><i>happens-before<\/i><\/a>\n-     * hand-over from the current owner thread to the new owner thread, which in turn <i>happens before<\/i> read accesses\n-     * to the returned segment's contents on a new thread.\n-     *\n-     * @return a new memory shared segment backed by the same underlying memory region as this segment.\n-     * @throws IllegalStateException if this segment is not <em>alive<\/em>, or if access occurs from a thread other than the\n-     * thread owning this segment.\n-     *\/\n-    MemorySegment share();\n-\n-    \/**\n-     * Register this memory segment instance against a {@link Cleaner} object, by returning a new memory segment backed\n-     * by the same underlying memory region as this segment. The returned segment will feature the same confinement,\n-     * spatial bounds and access modes (see {@link #accessModes()}) as this segment. Moreover, the returned segment\n-     * will be associated with the specified {@link Cleaner} object; this allows for the segment to be closed\n-     * as soon as it becomes <em>unreachable<\/em>, which might be helpful in preventing native memory leaks.\n-     * <p>\n-     * This is a <em>terminal operation<\/em>; as a side-effect, if this operation completes\n-     * without exceptions, this segment will be marked as <em>not alive<\/em>, and subsequent operations on this segment\n-     * will fail with {@link IllegalStateException}.\n-     * <p>\n-     * The implicit deallocation behavior associated with the returned segment will be preserved under terminal\n-     * operations such as {@link #handoff(Thread)} and {@link #share()}.\n-     *\n-     * @param cleaner the cleaner object, responsible for implicit deallocation of the returned segment.\n-     * @return a new memory segment backed by the same underlying memory region as this segment, which features\n-     * implicit deallocation.\n-     * @throws IllegalStateException if this segment is not <em>alive<\/em>, or if access occurs from a thread other than the\n-     * thread owning this segment, or if this segment is already associated with a cleaner.\n-     * @throws UnsupportedOperationException if this segment does not support the {@link #CLOSE} access mode.\n+     * Is this a mapped segment? Returns true if this segment is a mapped memory segment,\n+     * created using the {@link #mapFile(Path, long, long, FileChannel.MapMode, ResourceScope)} factory, or a buffer segment\n+     * derived from a {@link java.nio.MappedByteBuffer} using the {@link #ofByteBuffer(ByteBuffer)} factory.\n+     * @return {@code true} if this segment is a mapped segment.\n@@ -506,1 +325,1 @@\n-    MemorySegment registerCleaner(Cleaner cleaner);\n+    boolean isMapped();\n@@ -529,3 +348,3 @@\n-     * @throws IllegalStateException if this segment is not <em>alive<\/em>, or if access occurs from a thread other than the\n-     * thread owning this segment\n-     * @throws UnsupportedOperationException if this segment does not support the {@link #WRITE} access mode\n+     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n+     * a thread other than the thread owning that scope,\n+     * @throws UnsupportedOperationException if this segment is read-only (see {@link #isReadOnly()}).\n@@ -546,1 +365,1 @@\n-     * For example, this may occur if the same file is {@link MemorySegment#mapFile mapped} to two segments.\n+     * For example, this may occur if the same file is {@linkplain MemorySegment#mapFile mapped} to two segments.\n@@ -550,5 +369,4 @@\n-     * @throws IllegalStateException if either the source segment or this segment have been already closed,\n-     * or if access occurs from a thread other than the thread owning either segment.\n-     * @throws UnsupportedOperationException if either the source segment or this segment do not feature required access modes;\n-     * more specifically, {@code src} should feature at least the {@link MemorySegment#READ} access mode,\n-     * while this segment should feature at least the {@link MemorySegment#WRITE} access mode.\n+     * @throws IllegalStateException if either the scope associated with the source segment or the scope associated\n+     * with this segment have been already closed, or if access occurs from a thread other than the thread owning either\n+     * scopes.\n+     * @throws UnsupportedOperationException if this segment is read-only (see {@link #isReadOnly()}).\n@@ -561,2 +379,2 @@\n-     * {@link #address() base address} of each segment and will be in the\n-     * range of 0 (inclusive) up to the {@link #byteSize() size} (in bytes) of\n+     * {@linkplain #address() base address} of each segment and will be in the\n+     * range of 0 (inclusive) up to the {@linkplain #byteSize() size} (in bytes) of\n@@ -576,5 +394,3 @@\n-     * @throws IllegalStateException if either this segment of the other segment\n-     * have been already closed, or if access occurs from a thread other than the\n-     * thread owning either segment\n-     * @throws UnsupportedOperationException if either this segment or the other\n-     * segment does not feature at least the {@link MemorySegment#READ} access mode\n+     * @throws IllegalStateException if either the scope associated with this segment or the scope associated\n+     * with the {@code other} segment have been already closed, or if access occurs from a thread other than the thread\n+     * owning either scopes.\n@@ -584,0 +400,83 @@\n+    \/**\n+     * Tells whether or not the contents of this mapped segment is resident in physical\n+     * memory.\n+     *\n+     * <p> A return value of {@code true} implies that it is highly likely\n+     * that all of the data in this segment is resident in physical memory and\n+     * may therefore be accessed without incurring any virtual-memory page\n+     * faults or I\/O operations.  A return value of {@code false} does not\n+     * necessarily imply that this segment's content is not resident in physical\n+     * memory.\n+     *\n+     * <p> The returned value is a hint, rather than a guarantee, because the\n+     * underlying operating system may have paged out some of this segment's data\n+     * by the time that an invocation of this method returns.  <\/p>\n+     *\n+     * @return  {@code true} if it is likely that the contents of this segment\n+     *          is resident in physical memory\n+     *\n+     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n+     * a thread other than the thread owning that scope.\n+     * @throws UnsupportedOperationException if this segment is not a mapped memory segment, e.g. if\n+     * {@code isMapped() == false}.\n+     *\/\n+    boolean isLoaded();\n+\n+    \/**\n+     * Loads the contents of this mapped segment into physical memory.\n+     *\n+     * <p> This method makes a best effort to ensure that, when it returns,\n+     * this contents of this segment is resident in physical memory.  Invoking this\n+     * method may cause some number of page faults and I\/O operations to\n+     * occur. <\/p>\n+     *\n+     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n+     * a thread other than the thread owning that scope.\n+     * @throws UnsupportedOperationException if this segment is not a mapped memory segment, e.g. if\n+     * {@code isMapped() == false}.\n+     *\/\n+    void load();\n+\n+    \/**\n+     * Unloads the contents of this mapped segment from physical memory.\n+     *\n+     * <p> This method makes a best effort to ensure that the contents of this segment are\n+     * are no longer resident in physical memory. Accessing this segment's contents\n+     * after invoking this method may cause some number of page faults and I\/O operations to\n+     * occur (as this segment's contents might need to be paged back in). <\/p>\n+     *\n+     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n+     * a thread other than the thread owning that scope.\n+     * @throws UnsupportedOperationException if this segment is not a mapped memory segment, e.g. if\n+     * {@code isMapped() == false}.\n+     *\/\n+    void unload();\n+\n+    \/**\n+     * Forces any changes made to the contents of this mapped segment to be written to the\n+     * storage device described by the mapped segment's file descriptor.\n+     *\n+     * <p> If the file descriptor associated with this mapped segment resides on a local storage\n+     * device then when this method returns it is guaranteed that all changes\n+     * made to this segment since it was created, or since this method was last\n+     * invoked, will have been written to that device.\n+     *\n+     * <p> If the file descriptor associated with this mapped segment does not reside on a local device then\n+     * no such guarantee is made.\n+     *\n+     * <p> If this segment was not mapped in read\/write mode ({@link\n+     * java.nio.channels.FileChannel.MapMode#READ_WRITE}) then\n+     * invoking this method may have no effect. In particular, the\n+     * method has no effect for segments mapped in read-only or private\n+     * mapping modes. This method may or may not have an effect for\n+     * implementation-specific mapping modes.\n+     * <\/p>\n+     *\n+     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n+     * a thread other than the thread owning that scope.\n+     * @throws UnsupportedOperationException if this segment is not a mapped memory segment, e.g. if\n+     * {@code isMapped() == false}.\n+     * @throws UncheckedIOException if there is an I\/O error writing the contents of this segment to the associated storage device\n+     *\/\n+    void force();\n+\n@@ -587,1 +486,1 @@\n-     * (e.g. the segment has access mode {@link #READ} but not {@link #WRITE}), then the resulting buffer is <em>read-only<\/em>\n+     * (e.g. the segment is a read-only segment, see {@link #isReadOnly()}), then the resulting buffer is <em>read-only<\/em>\n@@ -596,3 +495,2 @@\n-     * The life-cycle of the returned buffer will be tied to that of this segment. That means that if the this segment\n-     * is closed (see {@link MemorySegment#close()}, accessing the returned\n-     * buffer will throw an {@link IllegalStateException}.\n+     * The life-cycle of the returned buffer will be tied to that of this segment. That is, accessing the returned buffer\n+     * after the scope associated with this segment has been closed (see {@link ResourceScope#close()}, will throw an {@link IllegalStateException}.\n@@ -600,4 +498,4 @@\n-     * If this segment is <em>shared<\/em>, calling certain I\/O operations on the resulting buffer might result in\n-     * an unspecified exception being thrown. Examples of such problematic operations are {@link FileChannel#read(ByteBuffer)},\n-     * {@link FileChannel#write(ByteBuffer)}, {@link java.nio.channels.SocketChannel#read(ByteBuffer)} and\n-     * {@link java.nio.channels.SocketChannel#write(ByteBuffer)}.\n+     * If this segment is associated with a confined scope, calling read\/write I\/O operations on the resulting buffer\n+     * might result in an unspecified exception being thrown. Examples of such problematic operations are\n+     * {@link java.nio.channels.AsynchronousSocketChannel#read(ByteBuffer)} and\n+     * {@link java.nio.channels.AsynchronousSocketChannel#write(ByteBuffer)}.\n@@ -611,1 +509,1 @@\n-     * than {@link Integer#MAX_VALUE}, or if the segment does not support the {@link #READ} access mode.\n+     * than {@link Integer#MAX_VALUE}.\n@@ -618,4 +516,3 @@\n-     * @throws UnsupportedOperationException if this segment does not feature the {@link #READ} access mode, or if this\n-     * segment's contents cannot be copied into a {@link byte[]} instance, e.g. its size is greater than {@link Integer#MAX_VALUE},\n-     * @throws IllegalStateException if this segment has been closed, or if access occurs from a thread other than the\n-     * thread owning this segment.\n+     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n+     * a thread other than the thread owning that scope, or if this segment's contents cannot be copied into a {@link byte[]} instance,\n+     * e.g. its size is greater than {@link Integer#MAX_VALUE}.\n@@ -628,5 +525,3 @@\n-     * @throws UnsupportedOperationException if this segment does not feature the {@link #READ} access mode, or if this\n-     * segment's contents cannot be copied into a {@link short[]} instance, e.g. because {@code byteSize() % 2 != 0},\n-     * or {@code byteSize() \/ 2 > Integer#MAX_VALUE}.\n-     * @throws IllegalStateException if this segment has been closed, or if access occurs from a thread other than the\n-     * thread owning this segment.\n+     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n+     * a thread other than the thread owning that scope, or if this segment's contents cannot be copied into a {@link short[]} instance,\n+     * e.g. because {@code byteSize() % 2 != 0}, or {@code byteSize() \/ 2 > Integer#MAX_VALUE}\n@@ -639,5 +534,3 @@\n-     * @throws UnsupportedOperationException if this segment does not feature the {@link #READ} access mode, or if this\n-     * segment's contents cannot be copied into a {@link char[]} instance, e.g. because {@code byteSize() % 2 != 0},\n-     * or {@code byteSize() \/ 2 > Integer#MAX_VALUE}.\n-     * @throws IllegalStateException if this segment has been closed, or if access occurs from a thread other than the\n-     * thread owning this segment.\n+     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n+     * a thread other than the thread owning that scope, or if this segment's contents cannot be copied into a {@link char[]} instance,\n+     * e.g. because {@code byteSize() % 2 != 0}, or {@code byteSize() \/ 2 > Integer#MAX_VALUE}.\n@@ -650,5 +543,3 @@\n-     * @throws UnsupportedOperationException if this segment does not feature the {@link #READ} access mode, or if this\n-     * segment's contents cannot be copied into a {@link int[]} instance, e.g. because {@code byteSize() % 4 != 0},\n-     * or {@code byteSize() \/ 4 > Integer#MAX_VALUE}.\n-     * @throws IllegalStateException if this segment has been closed, or if access occurs from a thread other than the\n-     * thread owning this segment.\n+     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n+     * a thread other than the thread owning that scope, or if this segment's contents cannot be copied into a {@link int[]} instance,\n+     * e.g. because {@code byteSize() % 4 != 0}, or {@code byteSize() \/ 4 > Integer#MAX_VALUE}.\n@@ -661,5 +552,3 @@\n-     * @throws UnsupportedOperationException if this segment does not feature the {@link #READ} access mode, or if this\n-     * segment's contents cannot be copied into a {@link float[]} instance, e.g. because {@code byteSize() % 4 != 0},\n-     * or {@code byteSize() \/ 4 > Integer#MAX_VALUE}.\n-     * @throws IllegalStateException if this segment has been closed, or if access occurs from a thread other than the\n-     * thread owning this segment.\n+     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n+     * a thread other than the thread owning that scope, or if this segment's contents cannot be copied into a {@link float[]} instance,\n+     * e.g. because {@code byteSize() % 4 != 0}, or {@code byteSize() \/ 4 > Integer#MAX_VALUE}.\n@@ -672,5 +561,3 @@\n-     * @throws UnsupportedOperationException if this segment does not feature the {@link #READ} access mode, or if this\n-     * segment's contents cannot be copied into a {@link long[]} instance, e.g. because {@code byteSize() % 8 != 0},\n-     * or {@code byteSize() \/ 8 > Integer#MAX_VALUE}.\n-     * @throws IllegalStateException if this segment has been closed, or if access occurs from a thread other than the\n-     * thread owning this segment.\n+     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n+     * a thread other than the thread owning that scope, or if this segment's contents cannot be copied into a {@link long[]} instance,\n+     * e.g. because {@code byteSize() % 8 != 0}, or {@code byteSize() \/ 8 > Integer#MAX_VALUE}.\n@@ -683,5 +570,3 @@\n-     * @throws UnsupportedOperationException if this segment does not feature the {@link #READ} access mode, or if this\n-     * segment's contents cannot be copied into a {@link double[]} instance, e.g. because {@code byteSize() % 8 != 0},\n-     * or {@code byteSize() \/ 8 > Integer#MAX_VALUE}.\n-     * @throws IllegalStateException if this segment has been closed, or if access occurs from a thread other than the\n-     * thread owning this segment.\n+     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n+     * a thread other than the thread owning that scope, or if this segment's contents cannot be copied into a {@link double[]} instance,\n+     * e.g. because {@code byteSize() % 8 != 0}, or {@code byteSize() \/ 8 > Integer#MAX_VALUE}.\n@@ -696,3 +581,4 @@\n-     * The segment will feature all <a href=\"#access-modes\">access modes<\/a> (see {@link #ALL_ACCESS}),\n-     * unless the given buffer is {@linkplain ByteBuffer#isReadOnly() read-only} in which case the segment will\n-     * not feature the {@link #WRITE} access mode, and its confinement thread is the current thread (see {@link Thread#currentThread()}).\n+     * If the buffer is {@link ByteBuffer#isReadOnly() read-only}, the resulting segment will also be\n+     * {@link ByteBuffer#isReadOnly() read-only}. The scope associated with this segment can either be the\n+     * {@linkplain ResourceScope#globalScope() global} resource scope, in case the buffer has been created independently,\n+     * or to some other (possibly closeable) resource scope, in case the buffer has been obtained using {@link #asByteBuffer()}.\n@@ -700,2 +586,1 @@\n-     * The resulting memory segment keeps a reference to the backing buffer, to ensure it remains <em>reachable<\/em>\n-     * for the life-time of the segment.\n+     * The resulting memory segment keeps a reference to the backing buffer, keeping it <em>reachable<\/em>.\n@@ -704,1 +589,1 @@\n-     * @return a new confined buffer memory segment.\n+     * @return a new buffer memory segment.\n@@ -712,4 +597,1 @@\n-     * <p>\n-     * The resulting memory segment keeps a reference to the backing array, to ensure it remains <em>reachable<\/em>\n-     * for the life-time of the segment. The segment will feature all <a href=\"#access-modes\">access modes<\/a>\n-     * (see {@link #ALL_ACCESS}), and its confinement thread is the current thread (see {@link Thread#currentThread()}).\n+     * The returned segment's resource scope is set to the {@linkplain ResourceScope#globalScope() global} resource scope.\n@@ -718,1 +600,1 @@\n-     * @return a new confined array memory segment.\n+     * @return a new array memory segment.\n@@ -726,4 +608,1 @@\n-     * <p>\n-     * The resulting memory segment keeps a reference to the backing array, to ensure it remains <em>reachable<\/em>\n-     * for the life-time of the segment. The segment will feature all <a href=\"#access-modes\">access modes<\/a>\n-     * (see {@link #ALL_ACCESS}), and its confinement thread is the current thread (see {@link Thread#currentThread()}).\n+     * The returned segment's resource scope is set to the {@linkplain ResourceScope#globalScope() global} resource scope.\n@@ -732,1 +611,1 @@\n-     * @return a new confined array memory segment.\n+     * @return a new array memory segment.\n@@ -740,4 +619,1 @@\n-     * <p>\n-     * The resulting memory segment keeps a reference to the backing array, to ensure it remains <em>reachable<\/em>\n-     * for the life-time of the segment. The segment will feature all <a href=\"#access-modes\">access modes<\/a>\n-     * (see {@link #ALL_ACCESS}), and its confinement thread is the current thread (see {@link Thread#currentThread()}).\n+     * The returned segment's resource scope is set to the {@linkplain ResourceScope#globalScope() global} resource scope.\n@@ -746,1 +622,1 @@\n-     * @return a new confined array memory segment.\n+     * @return a new array memory segment.\n@@ -754,4 +630,1 @@\n-     * <p>\n-     * The resulting memory segment keeps a reference to the backing array, to ensure it remains <em>reachable<\/em>\n-     * for the life-time of the segment. The segment will feature all <a href=\"#access-modes\">access modes<\/a>\n-     * (see {@link #ALL_ACCESS}), and its confinement thread is the current thread (see {@link Thread#currentThread()}).\n+     * The returned segment's resource scope is set to the {@linkplain ResourceScope#globalScope() global} resource scope.\n@@ -760,1 +633,1 @@\n-     * @return a new confined array memory segment.\n+     * @return a new array memory segment.\n@@ -768,4 +641,1 @@\n-     * <p>\n-     * The resulting memory segment keeps a reference to the backing array, to ensure it remains <em>reachable<\/em>\n-     * for the life-time of the segment. The segment will feature all <a href=\"#access-modes\">access modes<\/a>\n-     * (see {@link #ALL_ACCESS}), and its confinement thread is the current thread (see {@link Thread#currentThread()}).\n+     * The returned segment's resource scope is set to the {@linkplain ResourceScope#globalScope() global} resource scope.\n@@ -774,1 +644,1 @@\n-     * @return a new confined array memory segment.\n+     * @return a new array memory segment.\n@@ -782,4 +652,1 @@\n-     * <p>\n-     * The resulting memory segment keeps a reference to the backing array, to ensure it remains <em>reachable<\/em>\n-     * for the life-time of the segment. The segment will feature all <a href=\"#access-modes\">access modes<\/a>\n-     * (see {@link #ALL_ACCESS}), and its confinement thread is the current thread (see {@link Thread#currentThread()}).\n+     * The returned segment's resource scope is set to the {@linkplain ResourceScope#globalScope() global} resource scope.\n@@ -788,1 +655,1 @@\n-     * @return a new confined array memory segment.\n+     * @return a new array memory segment.\n@@ -796,4 +663,1 @@\n-     * <p>\n-     * The resulting memory segment keeps a reference to the backing array, to ensure it remains <em>reachable<\/em>\n-     * for the life-time of the segment. The segment will feature all <a href=\"#access-modes\">access modes<\/a>\n-     * (see {@link #ALL_ACCESS}).\n+     * The returned segment's resource scope is set to the {@linkplain ResourceScope#globalScope() global} resource scope.\n@@ -802,1 +666,1 @@\n-     * @return a new confined array memory segment.\n+     * @return a new array memory segment.\n@@ -809,1 +673,3 @@\n-     * Creates a new confined native memory segment that models a newly allocated block of off-heap memory with given layout.\n+     * Creates a new confined native memory segment that models a newly allocated block of off-heap memory with given layout\n+     * and resource scope. A client is responsible make sure that the resource scope associated with the returned segment is closed\n+     * when the segment is no longer in use. Failure to do so will result in off-heap memory leaks.\n@@ -813,1 +679,1 @@\n-    allocateNative(layout.bytesSize(), layout.bytesAlignment());\n+    allocateNative(layout.bytesSize(), layout.bytesAlignment(), scope);\n@@ -815,4 +681,2 @@\n-     *\n-     * @implNote The block of off-heap memory associated with the returned native memory segment is initialized to zero.\n-     * Moreover, a client is responsible to call the {@link MemorySegment#close()} on a native memory segment,\n-     * to make sure the backing off-heap memory block is deallocated accordingly. Failure to do so will result in off-heap memory leaks.\n+     * <p>\n+     * The block of off-heap memory associated with the returned native memory segment is initialized to zero.\n@@ -821,0 +685,1 @@\n+     * @param scope the segment scope.\n@@ -823,0 +688,2 @@\n+     * @throws IllegalStateException if {@code scope} has been already closed, or if access occurs from a thread other\n+     * than the thread owning {@code scope}.\n@@ -824,1 +691,2 @@\n-    static MemorySegment allocateNative(MemoryLayout layout) {\n+    static MemorySegment allocateNative(MemoryLayout layout, ResourceScope scope) {\n+        Objects.requireNonNull(scope);\n@@ -826,1 +694,1 @@\n-        return allocateNative(layout.byteSize(), layout.byteAlignment());\n+        return allocateNative(layout.byteSize(), layout.byteAlignment(), scope);\n@@ -830,1 +698,3 @@\n-     * Creates a new confined native memory segment that models a newly allocated block of off-heap memory with given size (in bytes).\n+     * Creates a new confined native memory segment that models a newly allocated block of off-heap memory with given size (in bytes)\n+     * and resource scope. A client is responsible make sure that the resource scope associated with the returned segment is closed\n+     * when the segment is no longer in use. Failure to do so will result in off-heap memory leaks.\n@@ -834,1 +704,1 @@\n-allocateNative(bytesSize, 1);\n+    allocateNative(bytesSize, 1, scope);\n@@ -836,0 +706,2 @@\n+     * <p>\n+     * The block of off-heap memory associated with the returned native memory segment is initialized to zero.\n@@ -837,3 +709,18 @@\n-     * @implNote The block of off-heap memory associated with the returned native memory segment is initialized to zero.\n-     * Moreover, a client is responsible to call the {@link MemorySegment#close()} on a native memory segment,\n-     * to make sure the backing off-heap memory block is deallocated accordingly. Failure to do so will result in off-heap memory leaks.\n+     * @param bytesSize the size (in bytes) of the off-heap memory block backing the native memory segment.\n+     * @param scope the segment scope.\n+     * @return a new native memory segment.\n+     * @throws IllegalArgumentException if {@code bytesSize <= 0}.\n+     * @throws IllegalStateException if {@code scope} has been already closed, or if access occurs from a thread other\n+     * than the thread owning {@code scope}.\n+     *\/\n+    static MemorySegment allocateNative(long bytesSize, ResourceScope scope) {\n+        return allocateNative(bytesSize, 1, scope);\n+    }\n+\n+    \/**\n+     * Creates a new confined native memory segment that models a newly allocated block of off-heap memory with given size\n+     * (in bytes), alignment constraint (in bytes) and resource scope. A client is responsible make sure that the resource\n+     * scope associated with the returned segment is closed when the segment is no longer in use.\n+     * Failure to do so will result in off-heap memory leaks.\n+     * <p>\n+     * The block of off-heap memory associated with the returned native memory segment is initialized to zero.\n@@ -842,2 +729,7 @@\n-     * @return a new confined native memory segment.\n-     * @throws IllegalArgumentException if {@code bytesSize < 0}.\n+     * @param alignmentBytes the alignment constraint (in bytes) of the off-heap memory block backing the native memory segment.\n+     * @param scope the segment scope.\n+     * @return a new native memory segment.\n+     * @throws IllegalArgumentException if {@code bytesSize <= 0}, {@code alignmentBytes <= 0}, or if {@code alignmentBytes}\n+     * is not a power of 2.\n+     * @throws IllegalStateException if {@code scope} has been already closed, or if access occurs from a thread other\n+     * than the thread owning {@code scope}.\n@@ -845,2 +737,12 @@\n-    static MemorySegment allocateNative(long bytesSize) {\n-        return allocateNative(bytesSize, 1);\n+    static MemorySegment allocateNative(long bytesSize, long alignmentBytes, ResourceScope scope) {\n+        Objects.requireNonNull(scope);\n+        if (bytesSize <= 0) {\n+            throw new IllegalArgumentException(\"Invalid allocation size : \" + bytesSize);\n+        }\n+\n+        if (alignmentBytes <= 0 ||\n+                ((alignmentBytes & (alignmentBytes - 1)) != 0L)) {\n+            throw new IllegalArgumentException(\"Invalid alignment constraint : \" + alignmentBytes);\n+        }\n+\n+        return NativeMemorySegmentImpl.makeNativeSegment(bytesSize, alignmentBytes, (ResourceScopeImpl) scope);\n@@ -850,1 +752,1 @@\n-     * Creates a new confined mapped memory segment that models a memory-mapped region of a file from a given path.\n+     * Creates a new mapped memory segment that models a memory-mapped region of a file from a given path.\n@@ -852,3 +754,2 @@\n-     * The segment will feature all <a href=\"#access-modes\">access modes<\/a> (see {@link #ALL_ACCESS}),\n-     * unless the given mapping mode is {@linkplain FileChannel.MapMode#READ_ONLY READ_ONLY}, in which case\n-     * the segment will not feature the {@link #WRITE} access mode, and its confinement thread is the current thread (see {@link Thread#currentThread()}).\n+     * If the specified mapping mode is {@linkplain FileChannel.MapMode#READ_ONLY READ_ONLY}, the resulting segment\n+     * will be read-only (see {@link #isReadOnly()}).\n@@ -877,1 +778,2 @@\n-     *                might affect the behavior of the returned memory mapped segment (see {@link MappedMemorySegments#force(MemorySegment)}).\n+     *                might affect the behavior of the returned memory mapped segment (see {@link #force()}).\n+     * @param scope the segment scope.\n@@ -881,0 +783,2 @@\n+     * @throws IllegalStateException if {@code scope} has been already closed, or if access occurs from a thread other\n+     * than the thread owning {@code scope}.\n@@ -888,2 +792,3 @@\n-    static MemorySegment mapFile(Path path, long bytesOffset, long bytesSize, FileChannel.MapMode mapMode) throws IOException {\n-        return MappedMemorySegmentImpl.makeMappedSegment(path, bytesOffset, bytesSize, mapMode);\n+    static MemorySegment mapFile(Path path, long bytesOffset, long bytesSize, FileChannel.MapMode mapMode, ResourceScope scope) throws IOException {\n+        Objects.requireNonNull(scope);\n+        return MappedMemorySegmentImpl.makeMappedSegment(path, bytesOffset, bytesSize, mapMode, (ResourceScopeImpl) scope);\n@@ -893,29 +798,1 @@\n-     * Creates a new confined native memory segment that models a newly allocated block of off-heap memory with given size and\n-     * alignment constraint (in bytes). The segment will feature all <a href=\"#access-modes\">access modes<\/a>\n-     * (see {@link #ALL_ACCESS}), and its confinement thread is the current thread (see {@link Thread#currentThread()}).\n-     *\n-     * @implNote The block of off-heap memory associated with the returned native memory segment is initialized to zero.\n-     * Moreover, a client is responsible to call the {@link MemorySegment#close()} on a native memory segment,\n-     * to make sure the backing off-heap memory block is deallocated accordingly. Failure to do so will result in off-heap memory leaks.\n-     *\n-     * @param bytesSize the size (in bytes) of the off-heap memory block backing the native memory segment.\n-     * @param alignmentBytes the alignment constraint (in bytes) of the off-heap memory block backing the native memory segment.\n-     * @return a new confined native memory segment.\n-     * @throws IllegalArgumentException if {@code bytesSize < 0}, {@code alignmentBytes < 0}, or if {@code alignmentBytes}\n-     * is not a power of 2.\n-     *\/\n-    static MemorySegment allocateNative(long bytesSize, long alignmentBytes) {\n-        if (bytesSize <= 0) {\n-            throw new IllegalArgumentException(\"Invalid allocation size : \" + bytesSize);\n-        }\n-\n-        if (alignmentBytes < 0 ||\n-                ((alignmentBytes & (alignmentBytes - 1)) != 0L)) {\n-            throw new IllegalArgumentException(\"Invalid alignment constraint : \" + alignmentBytes);\n-        }\n-\n-        return NativeMemorySegmentImpl.makeNativeSegment(bytesSize, alignmentBytes);\n-    }\n-\n-    \/**\n-     * Returns a shared native memory segment whose base address is {@link MemoryAddress#NULL} and whose size is {@link Long#MAX_VALUE}.\n+     * Returns a native memory segment whose base address is {@link MemoryAddress#NULL} and whose size is {@link Long#MAX_VALUE}.\n@@ -923,1 +800,1 @@\n-     * The segment will feature the {@link #READ} and {@link #WRITE} <a href=\"#access-modes\">access modes<\/a>.\n+     * The returned segment is associated with the <em>global<\/em> resource scope (see {@link ResourceScope#globalScope()}).\n@@ -926,3 +803,1 @@\n-    MemoryAddress.NULL.asSegmentRestricted(Long.MAX_VALUE)\n-                 .withOwnerThread(null)\n-                 .withAccessModes(READ | WRITE);\n+    MemoryAddress.NULL.asSegment(Long.MAX_VALUE)\n@@ -931,1 +806,2 @@\n-     * This method is <em>restricted<\/em>. Restricted methods are unsafe, and, if used incorrectly, their use might crash\n+     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n+     * Restricted method are unsafe, and, if used incorrectly, their use might crash\n@@ -936,2 +812,3 @@\n-     * @throws IllegalAccessError if the runtime property {@code foreign.restricted} is not set to either\n-     * {@code permit}, {@code warn} or {@code debug} (the default value is set to {@code deny}).\n+     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n+     * {@code --enable-native-access} is either absent, or does not mention the module name {@code M}, or\n+     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n@@ -939,2 +816,3 @@\n-    static MemorySegment ofNativeRestricted() {\n-        Utils.checkRestrictedAccess(\"MemorySegment.ofNativeRestricted\");\n+    @CallerSensitive\n+    static MemorySegment globalNativeSegment() {\n+        Reflection.ensureNativeAccess(Reflection.getCallerClass());\n@@ -943,45 +821,0 @@\n-\n-    \/\/ access mode masks\n-\n-    \/**\n-     * Read access mode; read operations are supported by a segment which supports this access mode.\n-     * @see MemorySegment#accessModes()\n-     * @see MemorySegment#withAccessModes(int)\n-     *\/\n-    int READ = 1;\n-\n-    \/**\n-     * Write access mode; write operations are supported by a segment which supports this access mode.\n-     * @see MemorySegment#accessModes()\n-     * @see MemorySegment#withAccessModes(int)\n-     *\/\n-    int WRITE = READ << 1;\n-\n-    \/**\n-     * Close access mode; calling {@link #close()} is supported by a segment which supports this access mode.\n-     * @see MemorySegment#accessModes()\n-     * @see MemorySegment#withAccessModes(int)\n-     *\/\n-    int CLOSE = WRITE << 1;\n-\n-    \/**\n-     * Share access mode; this segment support sharing with threads other than the owner thread (see {@link #share()}).\n-     * @see MemorySegment#accessModes()\n-     * @see MemorySegment#withAccessModes(int)\n-     *\/\n-    int SHARE = CLOSE << 1;\n-\n-    \/**\n-     * Handoff access mode; this segment support serial thread-confinement via thread ownership changes\n-     * (see {@link #handoff(NativeScope)} and {@link #handoff(Thread)}).\n-     * @see MemorySegment#accessModes()\n-     * @see MemorySegment#withAccessModes(int)\n-     *\/\n-    int HANDOFF = SHARE << 1;\n-\n-    \/**\n-     * Default access mode; this is a union of all the access modes supported by memory segments.\n-     * @see MemorySegment#accessModes()\n-     * @see MemorySegment#withAccessModes(int)\n-     *\/\n-    int ALL_ACCESS = READ | WRITE | CLOSE | SHARE | HANDOFF;\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemorySegment.java","additions":325,"deletions":492,"binary":false,"changes":817,"status":"modified"},{"patch":"@@ -1,472 +0,0 @@\n-\/*\n- *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.  Oracle designates this\n- *  particular file as subject to the \"Classpath\" exception as provided\n- *  by Oracle in the LICENSE file that accompanied this code.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\n- *\/\n-\n-package jdk.incubator.foreign;\n-\n-import jdk.internal.foreign.AbstractMemorySegmentImpl;\n-import jdk.internal.foreign.AbstractNativeScope;\n-import jdk.internal.foreign.Utils;\n-\n-import java.lang.invoke.VarHandle;\n-import java.lang.reflect.Array;\n-import java.nio.ByteOrder;\n-import java.util.Objects;\n-import java.util.OptionalLong;\n-import java.util.function.Function;\n-import java.util.stream.Stream;\n-\n-\/**\n- * A native scope is an abstraction which provides shared temporal bounds for one or more allocations, backed\n- * by off-heap memory. Native scopes can be either <em>bounded<\/em> or <em>unbounded<\/em>, depending on whether the size\n- * of the native scope is known statically. If an application knows before-hand how much memory it needs to allocate,\n- * then using a <em>bounded<\/em> native scope will typically provide better performance than independently allocating the memory\n- * for each value (e.g. using {@link MemorySegment#allocateNative(long)}), or using an <em>unbounded<\/em> native scope.\n- * For this reason, using a bounded native scope is recommended in cases where programs might need to emulate native stack allocation.\n- * <p>\n- * Allocation scopes are thread-confined (see {@link #ownerThread()}; as such, the resulting {@link MemorySegment} instances\n- * returned by the native scope will be backed by memory segments confined by the same owner thread as the native scope's\n- * owner thread.\n- * <p>\n- * To allow for more usability, it is possible for a native scope to reclaim ownership of an existing memory segment\n- * (see {@link MemorySegment#handoff(NativeScope)}). This might be useful to allow one or more segments which were independently\n- * created to share the same life-cycle as a given native scope - which in turns enables a client to group all memory\n- * allocation and usage under a single <em>try-with-resources block<\/em>.\n- *\n- * <p> Unless otherwise specified, passing a {@code null} argument, or an array argument containing one or more {@code null}\n- * elements to a method in this class causes a {@link NullPointerException NullPointerException} to be thrown. <\/p>\n- *\n- * @apiNote In the future, if the Java language permits, {@link NativeScope}\n- * may become a {@code sealed} interface, which would prohibit subclassing except by\n- * explicitly permitted types.\n- *\/\n-public interface NativeScope extends AutoCloseable {\n-\n-    \/**\n-     * If this native scope is bounded, returns the size, in bytes, of this native scope.\n-     * @return the size, in bytes, of this native scope (if available).\n-     *\/\n-    OptionalLong byteSize();\n-\n-    \/**\n-     * The thread owning this native scope.\n-     * @return the thread owning this native scope.\n-     *\/\n-    Thread ownerThread();\n-\n-    \/**\n-     * Returns the number of allocated bytes in this native scope.\n-     * @return the number of allocated bytes in this native scope.\n-     *\/\n-    long allocatedBytes();\n-\n-    \/**\n-     * Allocate a block of memory in this native scope with given layout and initialize it with given byte value.\n-     * The segment returned by this method is associated with a segment which cannot be closed. Moreover, the returned\n-     * segment must conform to the layout alignment constraints.\n-     * @param layout the layout of the block of memory to be allocated.\n-     * @param value the value to be set on the newly allocated memory block.\n-     * @return a segment for the newly allocated memory block.\n-     * @throws OutOfMemoryError if there is not enough space left in this native scope, that is, if this is a\n-     * bounded allocation scope, and {@code byteSize().getAsLong() - allocatedBytes() < layout.byteSize()}.\n-     * @throws IllegalArgumentException if {@code layout.byteSize()} does not conform to the size of a byte value.\n-     *\/\n-    default MemorySegment allocate(ValueLayout layout, byte value) {\n-        Objects.requireNonNull(layout);\n-        VarHandle handle = layout.varHandle(byte.class);\n-        MemorySegment addr = allocate(layout);\n-        handle.set(addr, value);\n-        return addr;\n-    }\n-\n-    \/**\n-     * Allocate a block of memory in this native scope with given layout and initialize it with given char value.\n-     * The segment returned by this method is associated with a segment which cannot be closed. Moreover, the returned\n-     * segment must conform to the layout alignment constraints.\n-     * @param layout the layout of the block of memory to be allocated.\n-     * @param value the value to be set on the newly allocated memory block.\n-     * @return a segment for the newly allocated memory block.\n-     * @throws OutOfMemoryError if there is not enough space left in this native scope, that is, if this is a\n-     * bounded allocation scope, and {@code byteSize().getAsLong() - allocatedBytes() < layout.byteSize()}.\n-     * @throws IllegalArgumentException if {@code layout.byteSize()} does not conform to the size of a char value.\n-     *\/\n-    default MemorySegment allocate(ValueLayout layout, char value) {\n-        Objects.requireNonNull(layout);\n-        VarHandle handle = layout.varHandle(char.class);\n-        MemorySegment addr = allocate(layout);\n-        handle.set(addr, value);\n-        return addr;\n-    }\n-\n-    \/**\n-     * Allocate a block of memory in this native scope with given layout and initialize it with given short value.\n-     * The segment returned by this method is associated with a segment which cannot be closed. Moreover, the returned\n-     * segment must conform to the layout alignment constraints.\n-     * @param layout the layout of the block of memory to be allocated.\n-     * @param value the value to be set on the newly allocated memory block.\n-     * @return a segment for the newly allocated memory block.\n-     * @throws OutOfMemoryError if there is not enough space left in this native scope, that is, if this is a\n-     * bounded allocation scope, and {@code byteSize().getAsLong() - allocatedBytes() < layout.byteSize()}.\n-     * @throws IllegalArgumentException if {@code layout.byteSize()} does not conform to the size of a short value.\n-     *\/\n-    default MemorySegment allocate(ValueLayout layout, short value) {\n-        Objects.requireNonNull(layout);\n-        VarHandle handle = layout.varHandle(short.class);\n-        MemorySegment addr = allocate(layout);\n-        handle.set(addr, value);\n-        return addr;\n-    }\n-\n-    \/**\n-     * Allocate a block of memory in this native scope with given layout and initialize it with given int value.\n-     * The segment returned by this method is associated with a segment which cannot be closed. Moreover, the returned\n-     * segment must conform to the layout alignment constraints.\n-     * @param layout the layout of the block of memory to be allocated.\n-     * @param value the value to be set on the newly allocated memory block.\n-     * @return a segment for the newly allocated memory block.\n-     * @throws OutOfMemoryError if there is not enough space left in this native scope, that is, if this is a\n-     * bounded allocation scope, and {@code byteSize().getAsLong() - allocatedBytes() < layout.byteSize()}.\n-     * @throws IllegalArgumentException if {@code layout.byteSize()} does not conform to the size of a int value.\n-     *\/\n-    default MemorySegment allocate(ValueLayout layout, int value) {\n-        Objects.requireNonNull(layout);\n-        VarHandle handle = layout.varHandle(int.class);\n-        MemorySegment addr = allocate(layout);\n-        handle.set(addr, value);\n-        return addr;\n-    }\n-\n-    \/**\n-     * Allocate a block of memory in this native scope with given layout and initialize it with given float value.\n-     * The segment returned by this method is associated with a segment which cannot be closed. Moreover, the returned\n-     * segment must conform to the layout alignment constraints.\n-     * @param layout the layout of the block of memory to be allocated.\n-     * @param value the value to be set on the newly allocated memory block.\n-     * @return a segment for the newly allocated memory block.\n-     * @throws OutOfMemoryError if there is not enough space left in this native scope, that is, if this is a\n-     * bounded allocation scope, and {@code byteSize().getAsLong() - allocatedBytes() < layout.byteSize()}.\n-     * @throws IllegalArgumentException if {@code layout.byteSize()} does not conform to the size of a float value.\n-     *\/\n-    default MemorySegment allocate(ValueLayout layout, float value) {\n-        Objects.requireNonNull(layout);\n-        VarHandle handle = layout.varHandle(float.class);\n-        MemorySegment addr = allocate(layout);\n-        handle.set(addr, value);\n-        return addr;\n-    }\n-\n-    \/**\n-     * Allocate a block of memory in this native scope with given layout and initialize it with given long value.\n-     * The segment returned by this method is associated with a segment which cannot be closed. Moreover, the returned\n-     * segment must conform to the layout alignment constraints.\n-     * @param layout the layout of the block of memory to be allocated.\n-     * @param value the value to be set on the newly allocated memory block.\n-     * @return a segment for the newly allocated memory block.\n-     * @throws OutOfMemoryError if there is not enough space left in this native scope, that is, if this is a\n-     * bounded allocation scope, and {@code byteSize().getAsLong() - allocatedBytes() < layout.byteSize()}.\n-     * @throws IllegalArgumentException if {@code layout.byteSize()} does not conform to the size of a long value.\n-     *\/\n-    default MemorySegment allocate(ValueLayout layout, long value) {\n-        Objects.requireNonNull(layout);\n-        VarHandle handle = layout.varHandle(long.class);\n-        MemorySegment addr = allocate(layout);\n-        handle.set(addr, value);\n-        return addr;\n-    }\n-\n-    \/**\n-     * Allocate a block of memory in this native scope with given layout and initialize it with given double value.\n-     * The segment returned by this method is associated with a segment which cannot be closed. Moreover, the returned\n-     * segment must conform to the layout alignment constraints.\n-     * @param layout the layout of the block of memory to be allocated.\n-     * @param value the value to be set on the newly allocated memory block.\n-     * @return a segment for the newly allocated memory block.\n-     * @throws OutOfMemoryError if there is not enough space left in this native scope, that is, if this is a\n-     * bounded allocation scope, and {@code byteSize().getAsLong() - allocatedBytes() < layout.byteSize()}.\n-     * @throws IllegalArgumentException if {@code layout.byteSize()} does not conform to the size of a double value.\n-     *\/\n-    default MemorySegment allocate(ValueLayout layout, double value) {\n-        Objects.requireNonNull(layout);\n-        VarHandle handle = layout.varHandle(double.class);\n-        MemorySegment addr = allocate(layout);\n-        handle.set(addr, value);\n-        return addr;\n-    }\n-\n-    \/**\n-     * Allocate a block of memory in this native scope with given layout and initialize it with given address value\n-     * (expressed as an {@link Addressable} instance).\n-     * The address value might be narrowed according to the platform address size (see {@link MemoryLayouts#ADDRESS}).\n-     * The segment returned by this method cannot be closed. Moreover, the returned\n-     * segment must conform to the layout alignment constraints.\n-     * @param layout the layout of the block of memory to be allocated.\n-     * @param value the value to be set on the newly allocated memory block.\n-     * @return a segment for the newly allocated memory block.\n-     * @throws OutOfMemoryError if there is not enough space left in this native scope, that is, if this is a\n-     * bounded allocation scope, and {@code byteSize().getAsLong() - allocatedBytes() < layout.byteSize()}.\n-     * @throws IllegalArgumentException if {@code layout.byteSize() != MemoryLayouts.ADDRESS.byteSize()}.\n-     *\/\n-    default MemorySegment allocate(ValueLayout layout, Addressable value) {\n-        Objects.requireNonNull(value);\n-        Objects.requireNonNull(layout);\n-        if (MemoryLayouts.ADDRESS.byteSize() != layout.byteSize()) {\n-            throw new IllegalArgumentException(\"Layout size mismatch - \" + layout.byteSize() + \" != \" + MemoryLayouts.ADDRESS.byteSize());\n-        }\n-        switch ((int)layout.byteSize()) {\n-            case 4: return allocate(layout, (int)value.address().toRawLongValue());\n-            case 8: return allocate(layout, value.address().toRawLongValue());\n-            default: throw new UnsupportedOperationException(\"Unsupported pointer size\"); \/\/ should not get here\n-        }\n-    }\n-\n-    \/**\n-     * Allocate a block of memory in this native scope with given layout and initialize it with given byte array.\n-     * The segment returned by this method is associated with a segment which cannot be closed. Moreover, the returned\n-     * segment must conform to the layout alignment constraints.\n-     * @param elementLayout the element layout of the array to be allocated.\n-     * @param array the array to be copied on the newly allocated memory block.\n-     * @return a segment for the newly allocated memory block.\n-     * @throws OutOfMemoryError if there is not enough space left in this native scope, that is, if this is a\n-     * bounded allocation scope, and {@code byteSize().getAsLong() - allocatedBytes() < (elementLayout.byteSize() * array.length)}.\n-     * @throws IllegalArgumentException if {@code elementLayout.byteSize()} does not conform to the size of a byte value.\n-     *\/\n-    default MemorySegment allocateArray(ValueLayout elementLayout, byte[] array) {\n-        return copyArrayWithSwapIfNeeded(array, elementLayout, MemorySegment::ofArray);\n-    }\n-\n-    \/**\n-     * Allocate a block of memory in this native scope with given layout and initialize it with given short array.\n-     * The segment returned by this method is associated with a segment which cannot be closed. Moreover, the returned\n-     * segment must conform to the layout alignment constraints.\n-     * @param elementLayout the element layout of the array to be allocated.\n-     * @param array the array to be copied on the newly allocated memory block.\n-     * @return a segment for the newly allocated memory block.\n-     * @throws OutOfMemoryError if there is not enough space left in this native scope, that is, if this is a\n-     * bounded allocation scope, and {@code byteSize().getAsLong() - allocatedBytes() < (elementLayout.byteSize() * array.length)}.\n-     * @throws IllegalArgumentException if {@code elementLayout.byteSize()} does not conform to the size of a short value.\n-     *\/\n-    default MemorySegment allocateArray(ValueLayout elementLayout, short[] array) {\n-        return copyArrayWithSwapIfNeeded(array, elementLayout, MemorySegment::ofArray);\n-    }\n-\n-    \/**\n-     * Allocate a block of memory in this native scope with given layout and initialize it with given char array.\n-     * The segment returned by this method is associated with a segment which cannot be closed. Moreover, the returned\n-     * segment must conform to the layout alignment constraints.\n-     * @param elementLayout the element layout of the array to be allocated.\n-     * @param array the array to be copied on the newly allocated memory block.\n-     * @return a segment for the newly allocated memory block.\n-     * @throws OutOfMemoryError if there is not enough space left in this native scope, that is, if this is a\n-     * bounded allocation scope, and {@code byteSize().getAsLong() - allocatedBytes() < (elementLayout.byteSize() * array.length)}.\n-     * @throws IllegalArgumentException if {@code elementLayout.byteSize()} does not conform to the size of a char value.\n-     *\/\n-    default MemorySegment allocateArray(ValueLayout elementLayout, char[] array) {\n-        return copyArrayWithSwapIfNeeded(array, elementLayout, MemorySegment::ofArray);\n-    }\n-\n-    \/**\n-     * Allocate a block of memory in this native scope with given layout and initialize it with given int array.\n-     * The segment returned by this method is associated with a segment which cannot be closed. Moreover, the returned\n-     * segment must conform to the layout alignment constraints.\n-     * @param elementLayout the element layout of the array to be allocated.\n-     * @param array the array to be copied on the newly allocated memory block.\n-     * @return a segment for the newly allocated memory block.\n-     * @throws OutOfMemoryError if there is not enough space left in this native scope, that is, if this is a\n-     * bounded allocation scope, and {@code byteSize().getAsLong() - allocatedBytes() < (elementLayout.byteSize() * array.length)}.\n-     * @throws IllegalArgumentException if {@code elementLayout.byteSize()} does not conform to the size of a int value.\n-     *\/\n-    default MemorySegment allocateArray(ValueLayout elementLayout, int[] array) {\n-        return copyArrayWithSwapIfNeeded(array, elementLayout, MemorySegment::ofArray);\n-    }\n-\n-    \/**\n-     * Allocate a block of memory in this native scope with given layout and initialize it with given float array.\n-     * The segment returned by this method is associated with a segment which cannot be closed. Moreover, the returned\n-     * segment must conform to the layout alignment constraints.\n-     * @param elementLayout the element layout of the array to be allocated.\n-     * @param array the array to be copied on the newly allocated memory block.\n-     * @return a segment for the newly allocated memory block.\n-     * @throws OutOfMemoryError if there is not enough space left in this native scope, that is, if this is a\n-     * bounded allocation scope, and {@code byteSize().getAsLong() - allocatedBytes() < (elementLayout.byteSize() * array.length)}.\n-     * @throws IllegalArgumentException if {@code elementLayout.byteSize()} does not conform to the size of a float value.\n-     *\/\n-    default MemorySegment allocateArray(ValueLayout elementLayout, float[] array) {\n-        return copyArrayWithSwapIfNeeded(array, elementLayout, MemorySegment::ofArray);\n-    }\n-\n-    \/**\n-     * Allocate a block of memory in this native scope with given layout and initialize it with given long array.\n-     * The segment returned by this method is associated with a segment which cannot be closed. Moreover, the returned\n-     * segment must conform to the layout alignment constraints.\n-     * @param elementLayout the element layout of the array to be allocated.\n-     * @param array the array to be copied on the newly allocated memory block.\n-     * @return a segment for the newly allocated memory block.\n-     * @throws OutOfMemoryError if there is not enough space left in this native scope, that is, if this is a\n-     * bounded allocation scope, and {@code byteSize().getAsLong() - allocatedBytes() < (elementLayout.byteSize() * array.length)}.\n-     * @throws IllegalArgumentException if {@code elementLayout.byteSize()} does not conform to the size of a long value.\n-     *\/\n-    default MemorySegment allocateArray(ValueLayout elementLayout, long[] array) {\n-        return copyArrayWithSwapIfNeeded(array, elementLayout, MemorySegment::ofArray);\n-    }\n-\n-    \/**\n-     * Allocate a block of memory in this native scope with given layout and initialize it with given double array.\n-     * The segment returned by this method is associated with a segment which cannot be closed. Moreover, the returned\n-     * segment must conform to the layout alignment constraints.\n-     * @param elementLayout the element layout of the array to be allocated.\n-     * @param array the array to be copied on the newly allocated memory block.\n-     * @return a segment for the newly allocated memory block.\n-     * @throws OutOfMemoryError if there is not enough space left in this native scope, that is, if this is a\n-     * bounded allocation scope, and {@code byteSize().getAsLong() - allocatedBytes() < (elementLayout.byteSize() * array.length)}.\n-     * @throws IllegalArgumentException if {@code elementLayout.byteSize()} does not conform to the size of a double value.\n-     *\/\n-    default MemorySegment allocateArray(ValueLayout elementLayout, double[] array) {\n-        return copyArrayWithSwapIfNeeded(array, elementLayout, MemorySegment::ofArray);\n-    }\n-\n-    \/**\n-     * Allocate a block of memory in this native scope with given layout and initialize it with given address array.\n-     * The address value of each array element might be narrowed according to the platform address size (see {@link MemoryLayouts#ADDRESS}).\n-     * The segment returned by this method is associated with a segment which cannot be closed. Moreover, the returned\n-     * segment must conform to the layout alignment constraints.\n-     * @param elementLayout the element layout of the array to be allocated.\n-     * @param array the array to be copied on the newly allocated memory block.\n-     * @return a segment for the newly allocated memory block.\n-     * @throws OutOfMemoryError if there is not enough space left in this native scope, that is, if this is a\n-     * bounded allocation scope, and {@code byteSize().getAsLong() - allocatedBytes() < (elementLayout.byteSize() * array.length)}.\n-     * @throws IllegalArgumentException if {@code layout.byteSize() != MemoryLayouts.ADDRESS.byteSize()}.\n-     *\/\n-    default MemorySegment allocateArray(ValueLayout elementLayout, Addressable[] array) {\n-        Objects.requireNonNull(elementLayout);\n-        Objects.requireNonNull(array);\n-        Stream.of(array).forEach(Objects::requireNonNull);\n-        if (MemoryLayouts.ADDRESS.byteSize() != elementLayout.byteSize()) {\n-            throw new IllegalArgumentException(\"Layout size mismatch - \" + elementLayout.byteSize() + \" != \" + MemoryLayouts.ADDRESS.byteSize());\n-        }\n-        switch ((int)elementLayout.byteSize()) {\n-            case 4: return copyArrayWithSwapIfNeeded(Stream.of(array)\n-                            .mapToInt(a -> (int)a.address().toRawLongValue()).toArray(),\n-                            elementLayout, MemorySegment::ofArray);\n-            case 8: return copyArrayWithSwapIfNeeded(Stream.of(array)\n-                            .mapToLong(a -> a.address().toRawLongValue()).toArray(),\n-                            elementLayout, MemorySegment::ofArray);\n-            default: throw new UnsupportedOperationException(\"Unsupported pointer size\"); \/\/ should not get here\n-        }\n-    }\n-\n-    private <Z> MemorySegment copyArrayWithSwapIfNeeded(Z array, ValueLayout elementLayout,\n-                                                        Function<Z, MemorySegment> heapSegmentFactory) {\n-        Objects.requireNonNull(array);\n-        Objects.requireNonNull(elementLayout);\n-        Utils.checkPrimitiveCarrierCompat(array.getClass().componentType(), elementLayout);\n-        MemorySegment addr = allocate(MemoryLayout.ofSequence(Array.getLength(array), elementLayout));\n-        if (elementLayout.byteSize() == 1 || (elementLayout.order() == ByteOrder.nativeOrder())) {\n-            addr.copyFrom(heapSegmentFactory.apply(array));\n-        } else {\n-            ((AbstractMemorySegmentImpl)addr).copyFromSwap(heapSegmentFactory.apply(array), elementLayout.byteSize());\n-        }\n-        return addr;\n-    }\n-\n-    \/**\n-     * Allocate a block of memory in this native scope with given layout. The segment returned by this method is\n-     * associated with a segment which cannot be closed. Moreover, the returned segment must conform to the layout alignment constraints.\n-     * @param layout the layout of the block of memory to be allocated.\n-     * @return a segment for the newly allocated memory block.\n-     * @throws OutOfMemoryError if there is not enough space left in this native scope, that is, if this is a\n-     * bounded allocation scope, and {@code byteSize().getAsLong() - allocatedBytes() < layout.byteSize()}.\n-     *\/\n-    default MemorySegment allocate(MemoryLayout layout) {\n-        Objects.requireNonNull(layout);\n-        return allocate(layout.byteSize(), layout.byteAlignment());\n-    }\n-\n-    \/**\n-     * Allocate a block of memory corresponding to an array with given element layout and size.\n-     * The segment returned by this method is associated with a segment which cannot be closed.\n-     * Moreover, the returned segment must conform to the layout alignment constraints. This is equivalent to the\n-     * following code:\n-     * <pre>{@code\n-    allocate(MemoryLayout.ofSequence(size, elementLayout));\n-     * }<\/pre>\n-     * @param elementLayout the array element layout.\n-     * @param count the array element count.\n-     * @return a segment for the newly allocated memory block.\n-     * @throws OutOfMemoryError if there is not enough space left in this native scope, that is, if this is a\n-     * bounded allocation scope, and {@code byteSize().getAsLong() - allocatedBytes() < (elementLayout.byteSize() * count)}.\n-     *\/\n-    default MemorySegment allocateArray(MemoryLayout elementLayout, long count) {\n-        Objects.requireNonNull(elementLayout);\n-        return allocate(MemoryLayout.ofSequence(count, elementLayout));\n-    }\n-\n-    \/**\n-     * Allocate a block of memory in this native scope with given size. The segment returned by this method is\n-     * associated with a segment which cannot be closed. Moreover, the returned segment must be aligned to {@code size}.\n-     * @param bytesSize the size (in bytes) of the block of memory to be allocated.\n-     * @return a segment for the newly allocated memory block.\n-     * @throws OutOfMemoryError if there is not enough space left in this native scope, that is, if\n-     * {@code limit() - size() < bytesSize}.\n-     *\/\n-    default MemorySegment allocate(long bytesSize) {\n-        return allocate(bytesSize, bytesSize);\n-    }\n-\n-    \/**\n-     * Allocate a block of memory in this native scope with given size and alignment constraint.\n-     * The segment returned by this method is associated with a segment which cannot be closed. Moreover,\n-     * the returned segment must be aligned to {@code alignment}.\n-     * @param bytesSize the size (in bytes) of the block of memory to be allocated.\n-     * @param bytesAlignment the alignment (in bytes) of the block of memory to be allocated.\n-     * @return a segment for the newly allocated memory block.\n-     * @throws OutOfMemoryError if there is not enough space left in this native scope, that is, if\n-     * {@code limit() - size() < bytesSize}.\n-     *\/\n-    MemorySegment allocate(long bytesSize, long bytesAlignment);\n-\n-    \/**\n-     * Close this native scope; calling this method will render any segment obtained through this native scope\n-     * unusable and might release any backing memory resources associated with this native scope.\n-     *\/\n-    @Override\n-    void close();\n-\n-    \/**\n-     * Creates a new bounded native scope, backed by off-heap memory.\n-     * @param size the size of the native scope.\n-     * @return a new bounded native scope, with given size (in bytes).\n-     *\/\n-    static NativeScope boundedScope(long size) {\n-        return new AbstractNativeScope.BoundedNativeScope(size);\n-    }\n-\n-    \/**\n-     * Creates a new unbounded native scope, backed by off-heap memory.\n-     * @return a new unbounded native scope.\n-     *\/\n-    static NativeScope unboundedScope() {\n-        return new AbstractNativeScope.UnboundedNativeScope();\n-    }\n-}\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/NativeScope.java","additions":0,"deletions":472,"binary":false,"changes":472,"status":"deleted"},{"patch":"@@ -0,0 +1,285 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.incubator.foreign;\n+\n+import jdk.internal.foreign.ResourceScopeImpl;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.ref.Cleaner;\n+import java.nio.channels.FileChannel;\n+import java.nio.file.Path;\n+import java.util.Objects;\n+import java.util.Spliterator;\n+\n+\/**\n+ * A resource scope manages the lifecycle of one or more resources. Resources (e.g. {@link MemorySegment}) associated\n+ * with a resource scope can only be accessed while the resource scope is <em>alive<\/em> (see {@link #isAlive()}),\n+ * and by the thread associated with the resource scope (if any).\n+ *\n+ * <h2>Explicit resource scopes<\/h2>\n+ *\n+ * Resource scopes obtained from {@link #newConfinedScope()}, {@link #newSharedScope()} support <em>deterministic deallocation<\/em>;\n+ * We call these resource scopes <em>explicit scopes<\/em>. Explicit resource scopes can be closed explicitly (see {@link ResourceScope#close()}).\n+ * When a resource scope is closed, it is no longer <em>alive<\/em> (see {@link #isAlive()}, and subsequent operations on\n+ * resources associated with that scope (e.g. attempting to access a {@link MemorySegment} instance) will fail with {@link IllegalStateException}.\n+ * <p>\n+ * Closing a resource scope will cause all the cleanup actions associated with that scope (see {@link #addCloseAction(Runnable)}) to be called.\n+ * Moreover, closing a resource scope might trigger the releasing of the underlying memory resources associated with said scope; for instance:\n+ * <ul>\n+ *     <li>closing the scope associated with a native memory segment results in <em>freeing<\/em> the native memory associated with it\n+ *     (see {@link MemorySegment#allocateNative(long, ResourceScope)}, or {@link SegmentAllocator#arenaAllocator(ResourceScope)})<\/li>\n+ *     <li>closing the scope associated with a mapped memory segment results in the backing memory-mapped file to be unmapped\n+ *     (see {@link MemorySegment#mapFile(Path, long, long, FileChannel.MapMode, ResourceScope)})<\/li>\n+ *     <li>closing the scope associated with an upcall stub results in releasing the stub\n+ *     (see {@link CLinker#upcallStub(MethodHandle, FunctionDescriptor, ResourceScope)}<\/li>\n+ * <\/ul>\n+ * <p>\n+ * Sometimes, explicit scopes can be associated with a {@link Cleaner} instance (see {@link #newConfinedScope(Cleaner)} and\n+ * {@link #newSharedScope(Cleaner)}). We call these resource scopes <em>managed<\/em> resource scopes. A managed resource scope\n+ * is closed automatically once the scope instance becomes <a href=\"..\/..\/..\/java\/lang\/ref\/package.html#reachability\">unreachable<\/a>.\n+ * <p>\n+ * Managed scopes can be useful to allow for predictable, deterministic resource deallocation, while still prevent accidental native memory leaks.\n+ * In case a managed resource scope is closed explicitly, no further action will be taken when the scope becomes unreachable;\n+ * that is, cleanup actions (see {@link #addCloseAction(Runnable)}) associated with a resource scope, whether managed or not,\n+ * are called <em>exactly once<\/em>.\n+ *\n+ * <h2>Implicit resource scopes<\/h2>\n+ *\n+ * Resource scopes obtained from {@link #newImplicitScope()} cannot be closed explicitly. We call these resource scopes\n+ * <em>implicit scopes<\/em>. Calling {@link #close()} on an implicit resource scope always results in an exception.\n+ * Resources associated with implicit scopes are released once the scope instance becomes\n+ * <a href=\"..\/..\/..\/java\/lang\/ref\/package.html#reachability\">unreachable<\/a>.\n+ * <p>\n+ * An important implicit resource scope is the so called {@linkplain #globalScope() global scope}; the global scope is\n+ * an implicit scope that is guaranteed to never become <a href=\"..\/..\/..\/java\/lang\/ref\/package.html#reachability\">unreachable<\/a>.\n+ * As a results, the global scope will never attempt to release resources associated with it. Such resources must, where\n+ * needed, be managed independently by clients.\n+ *\n+ * <h2><a id = \"thread-confinement\">Thread confinement<\/a><\/h2>\n+ *\n+ * Resource scopes can be further divided into two categories: <em>thread-confined<\/em> resource scopes, and <em>shared<\/em>\n+ * resource scopes.\n+ * <p>\n+ * Confined resource scopes (see {@link #newConfinedScope()}), support strong thread-confinement guarantees. Upon creation,\n+ * they are assigned an <em>owner thread<\/em>, typically the thread which initiated the creation operation (see {@link #ownerThread()}).\n+ * After creating a confined resource scope, only the owner thread will be allowed to directly manipulate the resources\n+ * associated with this resource scope. Any attempt to perform resource access from a thread other than the\n+ * owner thread will result in a runtime failure.\n+ * <p>\n+ * Shared resource scopes (see {@link #newSharedScope()} and {@link #newImplicitScope()}), on the other hand, have no owner thread;\n+ * as such resources associated with this shared resource scopes can be accessed by multiple threads.\n+ * This might be useful when multiple threads need to access the same resource concurrently (e.g. in the case of parallel processing).\n+ * For instance, a client might obtain a {@link Spliterator} from a shared segment, which can then be used to slice the\n+ * segment and allow multiple threads to work in parallel on disjoint segment slices. The following code can be used to sum\n+ * all int values in a memory segment in parallel:\n+ *\n+ * <blockquote><pre>{@code\n+SequenceLayout SEQUENCE_LAYOUT = MemoryLayout.sequenceLayout(1024, MemoryLayouts.JAVA_INT);\n+try (ResourceScope scope = ResourceScope.newSharedScope()) {\n+    MemorySegment segment = MemorySegment.allocateNative(SEQUENCE_LAYOUT, scope);\n+    VarHandle VH_int = SEQUENCE_LAYOUT.elementLayout().varHandle(int.class);\n+    int sum = StreamSupport.stream(segment.spliterator(SEQUENCE_LAYOUT), true)\n+        .mapToInt(s -> (int)VH_int.get(s.address()))\n+        .sum();\n+}\n+ * }<\/pre><\/blockquote>\n+ *\n+ * <p>\n+ * Explicit shared resource scopes, while powerful, must be used with caution: if one or more threads accesses\n+ * a resource associated with a shared scope while the scope is being closed from another thread, an exception might occur on both\n+ * the accessing and the closing threads. Clients should refrain from attempting to close a shared resource scope repeatedly\n+ * (e.g. keep calling {@link #close()} until no exception is thrown). Instead, clients of shared resource scopes\n+ * should always ensure that proper synchronization mechanisms (e.g. using resource scope handles, see below) are put in place\n+ * so that threads closing shared resource scopes can never race against threads accessing resources managed by same scopes.\n+ *\n+ * <h2>Resource scope handles<\/h2>\n+ *\n+ * Resource scopes can be made <em>non-closeable<\/em> by acquiring one or more resource scope <em>handles<\/em> (see\n+ * {@link #acquire()}. A resource scope handle can be used to make sure that resources associated with a given resource scope\n+ * (either explicit or implicit) cannot be released for a certain period of time - e.g. during a critical region of code\n+ * involving one or more resources associated with the scope. For instance, an explicit resource scope can only be closed\n+ * <em>after<\/em> all the handles acquired against that scope have been closed (see {@link Handle#close()}).\n+ * This can be useful when clients need to perform a critical operation on a memory segment, during which they have\n+ * to ensure that the segment will not be released; this can be done as follows:\n+ *\n+ * <blockquote><pre>{@code\n+MemorySegment segment = ...\n+ResourceScope.Handle segmentHandle = segment.scope().acquire()\n+try {\n+   <critical operation on segment>\n+} finally {\n+   segment.scope().release(segmentHandle);\n+}\n+ * }<\/pre><\/blockquote>\n+ *\n+ * Acquiring implicit resource scopes is also possible, but it is often unnecessary: since resources associated with\n+ * an implicit scope will only be released when the scope becomes <a href=\"..\/..\/..\/java\/lang\/ref\/package.html#reachability\">unreachable<\/a>,\n+ * clients can use e.g. {@link java.lang.ref.Reference#reachabilityFence(Object)} to make sure that resources associated\n+ * with implicit scopes are not released prematurely. That said, the above code snippet works (trivially) for implicit scopes too.\n+ *\n+ * @implSpec\n+ * Implementations of this interface are immutable, thread-safe and <a href=\"{@docRoot}\/java.base\/java\/lang\/doc-files\/ValueBased.html\">value-based<\/a>.\n+ *\/\n+public sealed interface ResourceScope extends AutoCloseable permits ResourceScopeImpl {\n+    \/**\n+     * Is this resource scope alive?\n+     * @return true, if this resource scope is alive.\n+     * @see ResourceScope#close()\n+     *\/\n+    boolean isAlive();\n+\n+    \/**\n+     * The thread owning this resource scope.\n+     * @return the thread owning this resource scope, or {@code null} if this resource scope is shared.\n+     *\/\n+    Thread ownerThread();\n+\n+    \/**\n+     * Is this resource scope an <em>implicit scope<\/em>?\n+     * @return true if this scope is an <em>implicit scope<\/em>.\n+     * @see #newImplicitScope()\n+     * @see #globalScope()\n+     *\/\n+    boolean isImplicit();\n+\n+    \/**\n+     * Closes this resource scope. As a side-effect, if this operation completes without exceptions, this scope will be marked\n+     * as <em>not alive<\/em>, and subsequent operations on resources associated with this scope will fail with {@link IllegalStateException}.\n+     * Additionally, upon successful closure, all native resources associated with this resource scope will be released.\n+     *\n+     * @apiNote This operation is not idempotent; that is, closing an already closed resource scope <em>always<\/em> results in an\n+     * exception being thrown. This reflects a deliberate design choice: resource scope state transitions should be\n+     * manifest in the client code; a failure in any of these transitions reveals a bug in the underlying application\n+     * logic.\n+     *\n+     * @throws IllegalStateException if one of the following condition is met:\n+     * <ul>\n+     *     <li>this resource scope is not <em>alive<\/em>\n+     *     <li>this resource scope is confined, and this method is called from a thread other than the thread owning this resource scope<\/li>\n+     *     <li>this resource scope is shared and a resource associated with this scope is accessed while this method is called<\/li>\n+     *     <li>one or more handles (see {@link #acquire()}) associated with this resource scope have not been {@linkplain #release(Handle) released}<\/li>\n+     * <\/ul>\n+     * @throws UnsupportedOperationException if this resource scope is {@linkplain #isImplicit() implicit}.\n+     *\/\n+    void close();\n+\n+    \/**\n+     * Add a custom cleanup action which will be executed when the resource scope is closed.\n+     * The order in which custom cleanup actions are invoked once the scope is closed is unspecified.\n+     * @param runnable the custom cleanup action to be associated with this scope.\n+     * @throws IllegalStateException if this scope has already been closed.\n+     *\/\n+    void addCloseAction(Runnable runnable);\n+\n+    \/**\n+     * Acquires a resource scope handle associated with this resource scope. An explicit resource scope cannot be\n+     * {@linkplain #close() closed} until all the resource scope handles acquired from it have been {@linkplain #release(Handle)} released}.\n+     * @return a resource scope handle.\n+     *\/\n+    Handle acquire();\n+\n+    \/**\n+     * Release the provided resource scope handle. This method is idempotent, that is, releasing the same handle\n+     * multiple times has no effect.\n+     * @param handle the resource scope handle to be released.\n+     * @throws IllegalArgumentException if the provided handle is not associated with this scope.\n+     *\/\n+    void release(Handle handle);\n+\n+    \/**\n+     * An abstraction modelling a resource scope handle. A resource scope handle is typically {@linkplain #acquire() acquired} by clients\n+     * in order to prevent an explicit resource scope from being closed while executing a certain operation.\n+     * Once obtained, resource scope handles can be {@linkplain #release(Handle)} released}; an explicit resource scope can\n+     * be closed only <em>after<\/em> all the resource scope handles acquired from it have been released.\n+     *\/\n+    sealed interface Handle permits ResourceScopeImpl.HandleImpl {\n+\n+        \/**\n+         * Returns the resource scope associated with this handle.\n+         * @return the resource scope associated with this handle.\n+         *\/\n+        ResourceScope scope();\n+    }\n+\n+    \/**\n+     * Create a new confined scope. The resulting scope is closeable, and is not managed by a {@link Cleaner}.\n+     * @return a new confined scope.\n+     *\/\n+    static ResourceScope newConfinedScope() {\n+        return ResourceScopeImpl.createConfined( null);\n+    }\n+\n+    \/**\n+     * Create a new confined scope managed by a {@link Cleaner}.\n+     * @param cleaner the cleaner to be associated with the returned scope.\n+     * @return a new confined scope, managed by {@code cleaner}.\n+     * @throws NullPointerException if {@code cleaner == null}.\n+     *\/\n+    static ResourceScope newConfinedScope(Cleaner cleaner) {\n+        Objects.requireNonNull(cleaner);\n+        return ResourceScopeImpl.createConfined( cleaner);\n+    }\n+\n+    \/**\n+     * Create a new shared scope. The resulting scope is closeable, and is not managed by a {@link Cleaner}.\n+     * @return a new shared scope.\n+     *\/\n+    static ResourceScope newSharedScope() {\n+        return ResourceScopeImpl.createShared(null);\n+    }\n+\n+    \/**\n+     * Create a new shared scope managed by a {@link Cleaner}.\n+     * @param cleaner the cleaner to be associated with the returned scope.\n+     * @return a new shared scope, managed by {@code cleaner}.\n+     * @throws NullPointerException if {@code cleaner == null}.\n+     *\/\n+    static ResourceScope newSharedScope(Cleaner cleaner) {\n+        Objects.requireNonNull(cleaner);\n+        return ResourceScopeImpl.createShared(cleaner);\n+    }\n+\n+    \/**\n+     * Create a new <em>implicit scope<\/em>. The implicit scope is a managed, shared, and non-closeable scope which only features\n+     * <a href=\"ResourceScope.html#implicit-closure\"><em>implicit closure<\/em><\/a>.\n+     * Since implicit scopes can only be closed implicitly by the garbage collector, it is recommended that implicit\n+     * scopes are only used in cases where deallocation performance is not a critical concern, to avoid unnecessary\n+     * memory pressure.\n+     *\n+     * @return a new implicit scope.\n+     *\/\n+    static ResourceScope newImplicitScope() {\n+        return ResourceScopeImpl.createImplicitScope();\n+    }\n+\n+    \/**\n+     * Returns an implicit scope which is assumed to be always alive.\n+     * @return the global scope.\n+     *\/\n+    static ResourceScope globalScope() {\n+        return ResourceScopeImpl.GLOBAL;\n+    }\n+}\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/ResourceScope.java","additions":285,"deletions":0,"binary":false,"changes":285,"status":"added"},{"patch":"@@ -0,0 +1,466 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.incubator.foreign;\n+\n+import jdk.internal.foreign.ArenaAllocator;\n+import jdk.internal.foreign.AbstractMemorySegmentImpl;\n+import jdk.internal.foreign.ResourceScopeImpl;\n+import jdk.internal.foreign.Utils;\n+\n+import java.lang.invoke.VarHandle;\n+import java.lang.reflect.Array;\n+import java.nio.ByteOrder;\n+import java.util.Objects;\n+import java.util.function.Function;\n+import java.util.stream.Stream;\n+\n+\/**\n+ * This interface models a memory allocator. Clients implementing this interface\n+ * must implement the {@link #allocate(long, long)} method. This interface defines several default methods\n+ * which can be useful to create segments from several kinds of Java values such as primitives and arrays.\n+ * This interface can be seen as a thin wrapper around the basic capabilities for creating native segments\n+ * (e.g. {@link MemorySegment#allocateNative(long, long, ResourceScope)}); since {@link SegmentAllocator} is a <em>functional interface<\/em>,\n+ * clients can easily obtain a native allocator by using either a lambda expression or a method reference.\n+ * <p>\n+ * This interface provides a factory, namely {@link SegmentAllocator#ofScope(ResourceScope)} which can be used to obtain\n+ * a <em>scoped<\/em> allocator, that is, an allocator which creates segment bound by a given scope. This can be useful\n+ * when working inside a <em>try-with-resources<\/em> construct:\n+ *\n+ * <blockquote><pre>{@code\n+try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+   SegmentAllocator allocator = SegmentAllocator.ofScope(scope);\n+   ...\n+}\n+ * }<\/pre><\/blockquote>\n+ *\n+ * In addition, this interface also defines factories for commonly used allocators; for instance {@link #arenaAllocator(ResourceScope)}\n+ * and {@link #arenaAllocator(long, ResourceScope)} are arena-style native allocators. Finally {@link #ofSegment(MemorySegment)}\n+ * returns an allocator which wraps a segment (either on-heap or off-heap) and recycles its content upon each new allocation request.\n+ *\/\n+@FunctionalInterface\n+public interface SegmentAllocator {\n+\n+    \/**\n+     * Allocate a block of memory with given layout and initialize it with given byte value.\n+     * @implSpec the default implementation for this method calls {@code this.allocate(layout)}.\n+     * @param layout the layout of the block of memory to be allocated.\n+     * @param value the value to be set on the newly allocated memory block.\n+     * @return a segment for the newly allocated memory block.\n+     * @throws IllegalArgumentException if {@code layout.byteSize()} does not conform to the size of a byte value.\n+     *\/\n+    default MemorySegment allocate(ValueLayout layout, byte value) {\n+        Objects.requireNonNull(layout);\n+        VarHandle handle = layout.varHandle(byte.class);\n+        MemorySegment addr = allocate(layout);\n+        handle.set(addr, value);\n+        return addr;\n+    }\n+\n+    \/**\n+     * Allocate a block of memory with given layout and initialize it with given char value.\n+     * @implSpec the default implementation for this method calls {@code this.allocate(layout)}.\n+     * @param layout the layout of the block of memory to be allocated.\n+     * @param value the value to be set on the newly allocated memory block.\n+     * @return a segment for the newly allocated memory block.\n+     * @throws IllegalArgumentException if {@code layout.byteSize()} does not conform to the size of a char value.\n+     *\/\n+    default MemorySegment allocate(ValueLayout layout, char value) {\n+        Objects.requireNonNull(layout);\n+        VarHandle handle = layout.varHandle(char.class);\n+        MemorySegment addr = allocate(layout);\n+        handle.set(addr, value);\n+        return addr;\n+    }\n+\n+    \/**\n+     * Allocate a block of memory with given layout and initialize it with given short value.\n+     * @implSpec the default implementation for this method calls {@code this.allocate(layout)}.\n+     * @param layout the layout of the block of memory to be allocated.\n+     * @param value the value to be set on the newly allocated memory block.\n+     * @return a segment for the newly allocated memory block.\n+     * @throws IllegalArgumentException if {@code layout.byteSize()} does not conform to the size of a short value.\n+     *\/\n+    default MemorySegment allocate(ValueLayout layout, short value) {\n+        Objects.requireNonNull(layout);\n+        VarHandle handle = layout.varHandle(short.class);\n+        MemorySegment addr = allocate(layout);\n+        handle.set(addr, value);\n+        return addr;\n+    }\n+\n+    \/**\n+     * Allocate a block of memory with given layout and initialize it with given int value.\n+     * @implSpec the default implementation for this method calls {@code this.allocate(layout)}.\n+     * @param layout the layout of the block of memory to be allocated.\n+     * @param value the value to be set on the newly allocated memory block.\n+     * @return a segment for the newly allocated memory block.\n+     * @throws IllegalArgumentException if {@code layout.byteSize()} does not conform to the size of a int value.\n+     *\/\n+    default MemorySegment allocate(ValueLayout layout, int value) {\n+        Objects.requireNonNull(layout);\n+        VarHandle handle = layout.varHandle(int.class);\n+        MemorySegment addr = allocate(layout);\n+        handle.set(addr, value);\n+        return addr;\n+    }\n+\n+    \/**\n+     * Allocate a block of memory with given layout and initialize it with given float value.\n+     * @implSpec the default implementation for this method calls {@code this.allocate(layout)}.\n+     * @param layout the layout of the block of memory to be allocated.\n+     * @param value the value to be set on the newly allocated memory block.\n+     * @return a segment for the newly allocated memory block.\n+     * @throws IllegalArgumentException if {@code layout.byteSize()} does not conform to the size of a float value.\n+     *\/\n+    default MemorySegment allocate(ValueLayout layout, float value) {\n+        Objects.requireNonNull(layout);\n+        VarHandle handle = layout.varHandle(float.class);\n+        MemorySegment addr = allocate(layout);\n+        handle.set(addr, value);\n+        return addr;\n+    }\n+\n+    \/**\n+     * Allocate a block of memory with given layout and initialize it with given long value.\n+     * @implSpec the default implementation for this method calls {@code this.allocate(layout)}.\n+     * @param layout the layout of the block of memory to be allocated.\n+     * @param value the value to be set on the newly allocated memory block.\n+     * @return a segment for the newly allocated memory block.\n+     * @throws IllegalArgumentException if {@code layout.byteSize()} does not conform to the size of a long value.\n+     *\/\n+    default MemorySegment allocate(ValueLayout layout, long value) {\n+        Objects.requireNonNull(layout);\n+        VarHandle handle = layout.varHandle(long.class);\n+        MemorySegment addr = allocate(layout);\n+        handle.set(addr, value);\n+        return addr;\n+    }\n+\n+    \/**\n+     * Allocate a block of memory with given layout and initialize it with given double value.\n+     * @implSpec the default implementation for this method calls {@code this.allocate(layout)}.\n+     * @param layout the layout of the block of memory to be allocated.\n+     * @param value the value to be set on the newly allocated memory block.\n+     * @return a segment for the newly allocated memory block.\n+     * @throws IllegalArgumentException if {@code layout.byteSize()} does not conform to the size of a double value.\n+     *\/\n+    default MemorySegment allocate(ValueLayout layout, double value) {\n+        Objects.requireNonNull(layout);\n+        VarHandle handle = layout.varHandle(double.class);\n+        MemorySegment addr = allocate(layout);\n+        handle.set(addr, value);\n+        return addr;\n+    }\n+\n+    \/**\n+     * Allocate a block of memory with given layout and initialize it with given address value\n+     * (expressed as an {@link Addressable} instance).\n+     * The address value might be narrowed according to the platform address size (see {@link MemoryLayouts#ADDRESS}).\n+     * @implSpec the default implementation for this method calls {@code this.allocate(layout)}.\n+     * @param layout the layout of the block of memory to be allocated.\n+     * @param value the value to be set on the newly allocated memory block.\n+     * @return a segment for the newly allocated memory block.\n+     * @throws IllegalArgumentException if {@code layout.byteSize() != MemoryLayouts.ADDRESS.byteSize()}.\n+     *\/\n+    default MemorySegment allocate(ValueLayout layout, Addressable value) {\n+        Objects.requireNonNull(value);\n+        Objects.requireNonNull(layout);\n+        if (MemoryLayouts.ADDRESS.byteSize() != layout.byteSize()) {\n+            throw new IllegalArgumentException(\"Layout size mismatch - \" + layout.byteSize() + \" != \" + MemoryLayouts.ADDRESS.byteSize());\n+        }\n+        return switch ((int)layout.byteSize()) {\n+            case 4 -> allocate(layout, (int)value.address().toRawLongValue());\n+            case 8 -> allocate(layout, value.address().toRawLongValue());\n+            default -> throw new UnsupportedOperationException(\"Unsupported pointer size\"); \/\/ should not get here\n+        };\n+    }\n+\n+    \/**\n+     * Allocate a block of memory with given layout and initialize it with given byte array.\n+     * @implSpec the default implementation for this method calls {@code this.allocateArray(layout, array.length)}.\n+     * @param elementLayout the element layout of the array to be allocated.\n+     * @param array the array to be copied on the newly allocated memory block.\n+     * @return a segment for the newly allocated memory block.\n+     * @throws IllegalArgumentException if {@code elementLayout.byteSize()} does not conform to the size of a byte value.\n+     *\/\n+    default MemorySegment allocateArray(ValueLayout elementLayout, byte[] array) {\n+        return copyArrayWithSwapIfNeeded(array, elementLayout, MemorySegment::ofArray);\n+    }\n+\n+    \/**\n+     * Allocate a block of memory with given layout and initialize it with given short array.\n+     * @implSpec the default implementation for this method calls {@code this.allocateArray(layout, array.length)}.\n+     * @param elementLayout the element layout of the array to be allocated.\n+     * @param array the array to be copied on the newly allocated memory block.\n+     * @return a segment for the newly allocated memory block.\n+     * @throws IllegalArgumentException if {@code elementLayout.byteSize()} does not conform to the size of a short value.\n+     *\/\n+    default MemorySegment allocateArray(ValueLayout elementLayout, short[] array) {\n+        return copyArrayWithSwapIfNeeded(array, elementLayout, MemorySegment::ofArray);\n+    }\n+\n+    \/**\n+     * Allocate a block of memory with given layout and initialize it with given char array.\n+     * @implSpec the default implementation for this method calls {@code this.allocateArray(layout, array.length)}.\n+     * @param elementLayout the element layout of the array to be allocated.\n+     * @param array the array to be copied on the newly allocated memory block.\n+     * @return a segment for the newly allocated memory block.\n+     * @throws IllegalArgumentException if {@code elementLayout.byteSize()} does not conform to the size of a char value.\n+     *\/\n+    default MemorySegment allocateArray(ValueLayout elementLayout, char[] array) {\n+        return copyArrayWithSwapIfNeeded(array, elementLayout, MemorySegment::ofArray);\n+    }\n+\n+    \/**\n+     * Allocate a block of memory with given layout and initialize it with given int array.\n+     * @implSpec the default implementation for this method calls {@code this.allocateArray(layout, array.length)}.\n+     * @param elementLayout the element layout of the array to be allocated.\n+     * @param array the array to be copied on the newly allocated memory block.\n+     * @return a segment for the newly allocated memory block.\n+     * @throws IllegalArgumentException if {@code elementLayout.byteSize()} does not conform to the size of a int value.\n+     *\/\n+    default MemorySegment allocateArray(ValueLayout elementLayout, int[] array) {\n+        return copyArrayWithSwapIfNeeded(array, elementLayout, MemorySegment::ofArray);\n+    }\n+\n+    \/**\n+     * Allocate a block of memory with given layout and initialize it with given float array.\n+     * @implSpec the default implementation for this method calls {@code this.allocateArray(layout, array.length)}.\n+     * @param elementLayout the element layout of the array to be allocated.\n+     * @param array the array to be copied on the newly allocated memory block.\n+     * @return a segment for the newly allocated memory block.\n+     * @throws IllegalArgumentException if {@code elementLayout.byteSize()} does not conform to the size of a float value.\n+     *\/\n+    default MemorySegment allocateArray(ValueLayout elementLayout, float[] array) {\n+        return copyArrayWithSwapIfNeeded(array, elementLayout, MemorySegment::ofArray);\n+    }\n+\n+    \/**\n+     * Allocate a block of memory with given layout and initialize it with given long array.\n+     * @implSpec the default implementation for this method calls {@code this.allocateArray(layout, array.length)}.\n+     * @param elementLayout the element layout of the array to be allocated.\n+     * @param array the array to be copied on the newly allocated memory block.\n+     * @return a segment for the newly allocated memory block.\n+     * @throws IllegalArgumentException if {@code elementLayout.byteSize()} does not conform to the size of a long value.\n+     *\/\n+    default MemorySegment allocateArray(ValueLayout elementLayout, long[] array) {\n+        return copyArrayWithSwapIfNeeded(array, elementLayout, MemorySegment::ofArray);\n+    }\n+\n+    \/**\n+     * Allocate a block of memory with given layout and initialize it with given double array.\n+     * @implSpec the default implementation for this method calls {@code this.allocateArray(layout, array.length)}.\n+     * @param elementLayout the element layout of the array to be allocated.\n+     * @param array the array to be copied on the newly allocated memory block.\n+     * @return a segment for the newly allocated memory block.\n+     * @throws IllegalArgumentException if {@code elementLayout.byteSize()} does not conform to the size of a double value.\n+     *\/\n+    default MemorySegment allocateArray(ValueLayout elementLayout, double[] array) {\n+        return copyArrayWithSwapIfNeeded(array, elementLayout, MemorySegment::ofArray);\n+    }\n+\n+    \/**\n+     * Allocate a block of memory with given layout and initialize it with given address array.\n+     * The address value of each array element might be narrowed according to the platform address size (see {@link MemoryLayouts#ADDRESS}).\n+     * @implSpec the default implementation for this method calls {@code this.allocateArray(layout, array.length)}.\n+     * @param elementLayout the element layout of the array to be allocated.\n+     * @param array the array to be copied on the newly allocated memory block.\n+     * @return a segment for the newly allocated memory block.\n+     * @throws IllegalArgumentException if {@code layout.byteSize() != MemoryLayouts.ADDRESS.byteSize()}.\n+     *\/\n+    default MemorySegment allocateArray(ValueLayout elementLayout, Addressable[] array) {\n+        Objects.requireNonNull(elementLayout);\n+        Objects.requireNonNull(array);\n+        Stream.of(array).forEach(Objects::requireNonNull);\n+        if (MemoryLayouts.ADDRESS.byteSize() != elementLayout.byteSize()) {\n+            throw new IllegalArgumentException(\"Layout size mismatch - \" + elementLayout.byteSize() + \" != \" + MemoryLayouts.ADDRESS.byteSize());\n+        }\n+        return switch ((int)elementLayout.byteSize()) {\n+            case 4 -> copyArrayWithSwapIfNeeded(Stream.of(array)\n+                            .mapToInt(a -> (int)a.address().toRawLongValue()).toArray(),\n+                    elementLayout, MemorySegment::ofArray);\n+            case 8 -> copyArrayWithSwapIfNeeded(Stream.of(array)\n+                            .mapToLong(a -> a.address().toRawLongValue()).toArray(),\n+                    elementLayout, MemorySegment::ofArray);\n+            default -> throw new UnsupportedOperationException(\"Unsupported pointer size\"); \/\/ should not get here\n+        };\n+    }\n+\n+    private <Z> MemorySegment copyArrayWithSwapIfNeeded(Z array, ValueLayout elementLayout,\n+                                                        Function<Z, MemorySegment> heapSegmentFactory) {\n+        Objects.requireNonNull(array);\n+        Objects.requireNonNull(elementLayout);\n+        Utils.checkPrimitiveCarrierCompat(array.getClass().componentType(), elementLayout);\n+        MemorySegment addr = allocate(MemoryLayout.sequenceLayout(Array.getLength(array), elementLayout));\n+        if (elementLayout.byteSize() == 1 || (elementLayout.order() == ByteOrder.nativeOrder())) {\n+            addr.copyFrom(heapSegmentFactory.apply(array));\n+        } else {\n+            ((AbstractMemorySegmentImpl)addr).copyFromSwap(heapSegmentFactory.apply(array), elementLayout.byteSize());\n+        }\n+        return addr;\n+    }\n+\n+    \/**\n+     * Allocate a block of memory  with given layout.\n+     * @implSpec the default implementation for this method calls {@code this.allocate(layout.byteSize(), layout.byteAlignment())}.\n+     * @param layout the layout of the block of memory to be allocated.\n+     * @return a segment for the newly allocated memory block.\n+     *\/\n+    default MemorySegment allocate(MemoryLayout layout) {\n+        Objects.requireNonNull(layout);\n+        return allocate(layout.byteSize(), layout.byteAlignment());\n+    }\n+\n+    \/**\n+     * Allocate a block of memory corresponding to an array with given element layout and size.\n+     * @implSpec the default implementation for this method calls {@code this.allocate(MemoryLayout.sequenceLayout(count, elementLayout))}.\n+     * @param elementLayout the array element layout.\n+     * @param count the array element count.\n+     * @return a segment for the newly allocated memory block.\n+     *\/\n+    default MemorySegment allocateArray(MemoryLayout elementLayout, long count) {\n+        Objects.requireNonNull(elementLayout);\n+        return allocate(MemoryLayout.sequenceLayout(count, elementLayout));\n+    }\n+\n+    \/**\n+     * Allocate a block of memory with given size, with default alignment (1-byte aligned).\n+     * @implSpec the default implementation for this method calls {@code this.allocate(bytesSize, 1)}.\n+     * @param bytesSize the size (in bytes) of the block of memory to be allocated.\n+     * @return a segment for the newly allocated memory block.\n+     *\/\n+    default MemorySegment allocate(long bytesSize) {\n+        return allocate(bytesSize, 1);\n+    }\n+\n+    \/**\n+     * Allocate a block of memory  with given size and alignment constraint.\n+     * @param bytesSize the size (in bytes) of the block of memory to be allocated.\n+     * @param bytesAlignment the alignment (in bytes) of the block of memory to be allocated.\n+     * @return a segment for the newly allocated memory block.\n+     *\/\n+    MemorySegment allocate(long bytesSize, long bytesAlignment);\n+\n+    \/**\n+     * Returns a native arena-based allocator which allocates a single memory segment, of given size (using malloc),\n+     * and then responds to allocation request by returning different slices of that same segment\n+     * (until no further allocation is possible).\n+     * This can be useful when clients want to perform multiple allocation requests while avoiding the cost associated\n+     * with allocating a new off-heap memory region upon each allocation request.\n+     * <p>\n+     * An allocator associated with a <em>shared<\/em> resource scope is thread-safe and allocation requests may be\n+     * performed concurrently; conversely, if the arena allocator is associated with a <em>confined<\/em> resource scope,\n+     * allocation requests can only occur from the thread owning the allocator's resource scope.\n+     * <p>\n+     * The returned allocator might throw an {@link OutOfMemoryError} if an incoming allocation request exceeds\n+     * the allocator capacity.\n+     *\n+     * @param size the size (in bytes) of the allocation arena.\n+     * @param scope the scope associated with the segments returned by this allocator.\n+     * @return a new bounded arena-based allocator\n+     * @throws IllegalArgumentException if {@code size <= 0}.\n+     * @throws IllegalStateException if {@code scope} has been already closed, or if access occurs from a thread other\n+     * than the thread owning {@code scope}.\n+     *\/\n+    static SegmentAllocator arenaAllocator(long size, ResourceScope scope) {\n+        Objects.requireNonNull(scope);\n+        return scope.ownerThread() == null ?\n+                new ArenaAllocator.BoundedSharedArenaAllocator(scope, size) :\n+                new ArenaAllocator.BoundedArenaAllocator(scope, size);\n+    }\n+\n+    \/**\n+     * Returns a native unbounded arena-based allocator.\n+     * <p>\n+     * The returned allocator allocates a memory segment {@code S} of a certain fixed size (using malloc) and then\n+     * responds to allocation requests in one of the following ways:\n+     * <ul>\n+     *     <li>if the size of the allocation requests is smaller than the size of {@code S}, and {@code S} has a <em>free<\/em>\n+     *     slice {@code S'} which fits that allocation request, return that {@code S'}.\n+     *     <li>if the size of the allocation requests is smaller than the size of {@code S}, and {@code S} has no <em>free<\/em>\n+     *     slices which fits that allocation request, allocate a new segment {@code S'} (using malloc), which has same size as {@code S}\n+     *     and set {@code S = S'}; the allocator then tries to respond to the same allocation request again.\n+     *     <li>if the size of the allocation requests is bigger than the size of {@code S}, allocate a new segment {@code S'}\n+     *     (using malloc), which has a sufficient size to satisfy the allocation request, and return {@code S'}.\n+     * <\/ul>\n+     * <p>\n+     * This segment allocator can be useful when clients want to perform multiple allocation requests while avoiding the\n+     * cost associated with allocating a new off-heap memory region upon each allocation request.\n+     * <p>\n+     * An allocator associated with a <em>shared<\/em> resource scope is thread-safe and allocation requests may be\n+     * performed concurrently; conversely, if the arena allocator is associated with a <em>confined<\/em> resource scope,\n+     * allocation requests can only occur from the thread owning the allocator's resource scope.\n+     * <p>\n+     * The returned allocator might throw an {@link OutOfMemoryError} if an incoming allocation request exceeds\n+     * the system capacity.\n+     *\n+     * @param scope the scope associated with the segments returned by this allocator.\n+     * @return a new unbounded arena-based allocator\n+     * @throws IllegalStateException if {@code scope} has been already closed, or if access occurs from a thread other\n+     * than the thread owning {@code scope}.\n+     *\/\n+    static SegmentAllocator arenaAllocator(ResourceScope scope) {\n+        Objects.requireNonNull(scope);\n+        return scope.ownerThread() == null ?\n+                new ArenaAllocator.UnboundedSharedArenaAllocator(scope) :\n+                new ArenaAllocator.UnboundedArenaAllocator(scope);\n+    }\n+\n+    \/**\n+     * Returns a segment allocator which responds to allocation requests by recycling a single segment; that is,\n+     * each new allocation request will return a new slice starting at the segment offset {@code 0} (alignment\n+     * constraints are ignored by this allocator). This can be useful to limit allocation requests in case a client\n+     * knows that they have fully processed the contents of the allocated segment before the subsequent allocation request\n+     * takes place.\n+     * <p>\n+     * While the allocator returned by this method is <em>thread-safe<\/em>, concurrent access on the same recycling\n+     * allocator might cause a thread to overwrite contents written to the underlying segment by a different thread.\n+     *\n+     * @param segment the memory segment to be recycled by the returned allocator.\n+     * @return an allocator which recycles an existing segment upon each new allocation request.\n+     *\/\n+    static SegmentAllocator ofSegment(MemorySegment segment) {\n+        Objects.requireNonNull(segment);\n+        return (size, align) -> segment.asSlice(0, size);\n+    }\n+\n+    \/**\n+     * Returns a native allocator which responds to allocation requests by allocating new segments\n+     * bound by the given resource scope, using the {@link MemorySegment#allocateNative(long, long, ResourceScope)}\n+     * factory. This code is equivalent (but likely more efficient) to the following:\n+     * <blockquote><pre>{@code\n+    Resource scope = ...\n+    SegmentAllocator scoped = (size, align) -> MemorySegment.allocateNative(size, align, scope);\n+     * }<\/pre><\/blockquote>\n+     *\n+     * @param scope the resource scope associated with the segments created by the returned allocator.\n+     * @return an allocator which allocates new memory segment bound by the provided resource scope.\n+     *\/\n+    static SegmentAllocator ofScope(ResourceScope scope) {\n+        Objects.requireNonNull(scope);\n+        return (ResourceScopeImpl)scope;\n+    }\n+}\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/SegmentAllocator.java","additions":466,"deletions":0,"binary":false,"changes":466,"status":"added"},{"patch":"@@ -35,1 +35,0 @@\n-import java.util.stream.LongStream;\n@@ -44,1 +43,1 @@\n-MemoryLayout.ofSequence(3, MemoryLayout.ofValueBits(32, ByteOrder.BIG_ENDIAN));\n+MemoryLayout.sequenceLayout(3, MemoryLayout.valueLayout(32, ByteOrder.BIG_ENDIAN));\n@@ -50,4 +49,4 @@\n-MemoryLayout.ofStruct(\n-    MemoryLayout.ofValueBits(32, ByteOrder.BIG_ENDIAN),\n-    MemoryLayout.ofValueBits(32, ByteOrder.BIG_ENDIAN),\n-    MemoryLayout.ofValueBits(32, ByteOrder.BIG_ENDIAN));\n+MemoryLayout.structLayout(\n+    MemoryLayout.valueLayout(32, ByteOrder.BIG_ENDIAN),\n+    MemoryLayout.valueLayout(32, ByteOrder.BIG_ENDIAN),\n+    MemoryLayout.valueLayout(32, ByteOrder.BIG_ENDIAN));\n@@ -70,1 +69,1 @@\n-public final class SequenceLayout extends AbstractLayout {\n+public final class SequenceLayout extends AbstractLayout implements MemoryLayout {\n@@ -126,1 +125,1 @@\n-    var seq = MemoryLayout.ofSequence(4, MemoryLayout.ofSequence(3, MemoryLayouts.JAVA_INT));\n+    var seq = MemoryLayout.sequenceLayout(4, MemoryLayout.sequenceLayout(3, MemoryLayouts.JAVA_INT));\n@@ -130,1 +129,1 @@\n-    var reshapeSeq = MemoryLayout.ofSequence(2, MemoryLayout.ofSequence(6, MemoryLayouts.JAVA_INT));\n+    var reshapeSeq = MemoryLayout.sequenceLayout(2, MemoryLayout.sequenceLayout(6, MemoryLayouts.JAVA_INT));\n@@ -190,1 +189,1 @@\n-            res = MemoryLayout.ofSequence(elementCounts[i], res);\n+            res = MemoryLayout.sequenceLayout(elementCounts[i], res);\n@@ -202,1 +201,1 @@\n-    var seq = MemoryLayout.ofSequence(4, MemoryLayout.ofSequence(3, MemoryLayouts.JAVA_INT));\n+    var seq = MemoryLayout.sequenceLayout(4, MemoryLayout.sequenceLayout(3, MemoryLayouts.JAVA_INT));\n@@ -206,1 +205,1 @@\n-    var flattenedSeq = MemoryLayout.ofSequence(12, MemoryLayouts.JAVA_INT);\n+    var flattenedSeq = MemoryLayout.sequenceLayout(12, MemoryLayouts.JAVA_INT);\n@@ -224,1 +223,1 @@\n-        return MemoryLayout.ofSequence(count, elemLayout);\n+        return MemoryLayout.sequenceLayout(count, elemLayout);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/SequenceLayout.java","additions":12,"deletions":13,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -48,4 +48,3 @@\n-try (MemorySegment segment = MemorySegment.allocateNative(10 * 4)) {\n-    for (int i = 0 ; i < 10 ; i++) {\n-       MemoryAccess.setIntAtIndex(segment, i);\n-    }\n+MemorySegment segment = MemorySegment.allocateNative(10 * 4, ResourceScope.newImplicitScope());\n+for (int i = 0 ; i < 10 ; i++) {\n+   MemoryAccess.setIntAtIndex(segment, i, 42);\n@@ -57,4 +56,1 @@\n- * The segment is created inside a <em>try-with-resources<\/em> construct: this idiom ensures that all the memory resources\n- * associated with the segment will be released at the end of the block, according to the semantics described in\n- * Section {@jls 14.20.3} of <cite>The Java Language Specification<\/cite>. Inside the try-with-resources block, we initialize\n- * the contents of the memory segment using the\n+ * Inside a loop, we then initialize the contents of the memory segment using the\n@@ -69,10 +65,19 @@\n- * crucial that the resources associated with a memory segment are released when the segment is no longer in use, by calling the {@link jdk.incubator.foreign.MemorySegment#close()}\n- * method either explicitly, or implicitly, by relying on try-with-resources construct (as demonstrated in the example above).\n- * Closing a given memory segment is an <em>atomic<\/em> operation which can either succeed - and result in the underlying\n- * memory associated with the segment to be released, or <em>fail<\/em> with an exception.\n- * <p>\n- * The deterministic deallocation model differs significantly from the implicit strategies adopted within other APIs, most\n- * notably the {@link java.nio.ByteBuffer} API: in that case, when a native byte buffer is created (see {@link java.nio.ByteBuffer#allocateDirect(int)}),\n- * the underlying memory is not released until the byte buffer reference becomes <em>unreachable<\/em>. While implicit deallocation\n- * models such as this can be very convenient - clients do not have to remember to <em>close<\/em> a direct buffer - such models can also make it\n- * hard for clients to ensure that the memory associated with a direct buffer has indeed been released.\n+ * often crucial that the resources associated with a memory segment are released when the segment is no longer in use,\n+ * and in a timely fashion. For this reason, there might be cases where waiting for the garbage collector to determine that a segment\n+ * is <a href=\"..\/..\/..\/java\/lang\/ref\/package.html#reachability\">unreachable<\/a> is not optimal.\n+ * Clients that operate under these assumptions might want to programmatically release the memory associated\n+ * with a memory segment. This can be done, using the {@link jdk.incubator.foreign.ResourceScope} abstraction, as shown below:\n+ *\n+ * <pre>{@code\n+try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+    MemorySegment segment = MemorySegment.allocateNative(10 * 4, scope);\n+    for (int i = 0 ; i < 10 ; i++) {\n+        MemoryAccess.setIntAtIndex(segment, i, 42);\n+    }\n+}\n+ * }<\/pre>\n+ *\n+ * This example is almost identical to the prior one; this time we first create a so called <em>resource scope<\/em>,\n+ * which is used to <em>bind<\/em> the life-cycle of the segment created immediately afterwards. Note the use of the\n+ * <em>try-with-resources<\/em> construct: this idiom ensures that all the memory resources associated with the segment will be released\n+ * at the end of the block, according to the semantics described in Section {@jls 14.20.3} of <cite>The Java Language Specification<\/cite>.\n@@ -89,8 +94,3 @@\n- * the segment being accessed has not been closed prematurely. We call this guarantee <em>temporal safety<\/em>. Note that,\n- * in the general case, guaranteeing temporal safety can be hard, as multiple threads could attempt to access and\/or close\n- * the same memory segment concurrently. The memory access API addresses this problem by imposing strong\n- * <em>thread-confinement<\/em> guarantees on memory segments: upon creation, a memory segment is associated with an owner thread,\n- * which is the only thread that can either access or close the segment.\n- * <p>\n- * Together, spatial and temporal safety ensure that each memory access operation either succeeds - and accesses a valid\n- * memory location - or fails.\n+ * the resource scope associated with the segment being accessed has not been closed prematurely.\n+ * We call this guarantee <em>temporal safety<\/em>. Together, spatial and temporal safety ensure that each memory access\n+ * operation either succeeds - and accesses a valid memory location - or fails.\n@@ -109,1 +109,1 @@\n-MethodHandle strlen = CLinker.getInstance().downcallHandle(\n+      MethodHandle strlen = CLinker.getInstance().downcallHandle(\n@@ -113,1 +113,1 @@\n-);\n+      );\n@@ -115,3 +115,4 @@\n-try (var cString = CLinker.toCString(\"Hello\")) {\n-    long len = strlen.invokeExact(cString.address()) \/\/ 5\n-}\n+      try (var scope = ResourceScope.newConfinedScope()) {\n+         var cString = CLinker.toCString(\"Hello\", scope);\n+         long len = (long)strlen.invokeExact(cString.address()); \/\/ 5\n+      }\n@@ -129,1 +130,1 @@\n- * native strings and viceversa (see {@link jdk.incubator.foreign.CLinker#toCString(java.lang.String)} and\n+ * native strings and viceversa (see {@link jdk.incubator.foreign.CLinker#toCString(java.lang.String, ResourceScope)} and\n@@ -149,1 +150,1 @@\n-MemorySegment segment = MemorySegment.allocateNative(100);\n+MemorySegment segment = MemorySegment.allocateNative(100, scope);\n@@ -156,1 +157,1 @@\n- * using the {@link jdk.incubator.foreign.MemoryAddress#asSegmentRestricted(long)} factory. This allows the client to\n+ * using the {@link jdk.incubator.foreign.MemoryAddress#asSegment(long, ResourceScope)} factory. This allows the client to\n@@ -161,0 +162,1 @@\n+ResourceScope scope = ... \/\/ initialize a resource scope object\n@@ -162,1 +164,1 @@\n-MemorySegment segment = addr.asSegmentRestricted(4); \/\/ segment is 4 bytes long\n+MemorySegment segment = addr.asSegment(4, scope); \/\/ segment is 4 bytes long\n@@ -167,1 +169,1 @@\n- * which covers the entire native heap. This segment can be obtained by calling the {@link jdk.incubator.foreign.MemorySegment#ofNativeRestricted()}\n+ * which covers the entire native heap. This segment can be obtained by calling the {@link jdk.incubator.foreign.MemorySegment#globalNativeSegment()}\n@@ -172,1 +174,1 @@\n-int x = MemoryAccess.getIntAtOffset(MemorySegment.ofNativeRestricted(), addr.toRawLongValue());\n+int x = MemoryAccess.getIntAtOffset(MemorySegment.globalNativeSegment(), addr.toRawLongValue());\n@@ -177,1 +179,1 @@\n- * to a Java method) into a native memory segment (see {@link jdk.incubator.foreign.MemorySegment}), so that Java code\n+ * to a Java method) into a native memory address (see {@link jdk.incubator.foreign.MemoryAddress}), so that Java code\n@@ -184,2 +186,2 @@\n-        return MemoryAccess.getIntAtOffset(MemorySegment.ofNativeRestricted(), addr1.toRawLongValue()) -\n-               MemoryAccess.getIntAtOffset(MemorySegment.ofNativeRestricted(), addr2.toRawLongValue());\n+        return MemoryAccess.getIntAtOffset(MemorySegment.globalNativeSegment(), addr1.toRawLongValue()) -\n+               MemoryAccess.getIntAtOffset(MemorySegment.globalNativeSegment(), addr2.toRawLongValue());\n@@ -200,1 +202,1 @@\n- * Now that we have a method handle instance, we can link it into a fresh native memory segment, using the {@link jdk.incubator.foreign.CLinker} interface, as follows:\n+ * Now that we have a method handle instance, we can link it into a fresh native memory address, using the {@link jdk.incubator.foreign.CLinker} interface, as follows:\n@@ -203,1 +205,2 @@\n-MemorySegment comparFunc = CLinker.getInstance().upcallStub(\n+ResourceScope scope = ...\n+MemoryAddress comparFunc = CLinker.getInstance().upcallStub(\n@@ -205,1 +208,2 @@\n-     FunctionDescriptor.of(C_INT, C_POINTER, C_POINTER)\n+     FunctionDescriptor.of(C_INT, C_POINTER, C_POINTER),\n+     scope\n@@ -212,1 +216,3 @@\n- * by the platform C ABI.\n+ * by the platform C ABI. The lifecycle of the memory address returned by\n+ * {@link jdk.incubator.foreign.CLinker#upcallStub(java.lang.invoke.MethodHandle, jdk.incubator.foreign.FunctionDescriptor, jdk.incubator.foreign.ResourceScope)}\n+ * is tied to the {@linkplain jdk.incubator.foreign.ResourceScope resource scope} parameter passed to that method.\n@@ -214,0 +220,1 @@\n+ * <a id=\"restricted\"><\/a>\n@@ -216,2 +223,2 @@\n- * foreign data and\/or functions to first-class Java API elements which can then be used directly by client. For instance\n- * the restricted method {@link jdk.incubator.foreign.MemoryAddress#asSegmentRestricted(long)} can be used to create\n+ * foreign data and\/or functions to first-class Java API elements which can then be used directly by clients. For instance\n+ * the restricted method {@link jdk.incubator.foreign.MemoryAddress#asSegment(long, ResourceScope)} can be used to create\n@@ -221,1 +228,1 @@\n- * For instance, in the case of {@link jdk.incubator.foreign.MemoryAddress#asSegmentRestricted(long)}, if the provided\n+ * For instance, in the case of {@link jdk.incubator.foreign.MemoryAddress#asSegment(long, ResourceScope)}, if the provided\n@@ -226,8 +233,2 @@\n- * Access to restricted methods is <em>disabled<\/em> by default; to enable restricted methods, the JDK property\n- * {@code foreign.restricted} must be set to a value other than {@code deny}. The possible values for this property are:\n- * <ul>\n- * <li>{@code deny}: issues a runtime exception on each restricted call. This is the default value;<\/li>\n- * <li>{@code permit}: allows restricted calls;<\/li>\n- * <li>{@code warn}: like permit, but also prints a one-line warning on each restricted call;<\/li>\n- * <li>{@code debug}: like permit, but also dumps the stack corresponding to any given restricted call.<\/li>\n- * <\/ul>\n+ * Access to restricted methods is <em>disabled<\/em> by default; to enable restricted methods, the command line option\n+ * {@code --enable-native-access} must mention the name of the caller's module.\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/package-info.java","additions":56,"deletions":55,"binary":false,"changes":111,"status":"modified"},{"patch":"@@ -0,0 +1,55 @@\n+\/*\n+ *  Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+package jdk.internal.foreign;\n+\n+import jdk.incubator.foreign.Addressable;\n+import jdk.incubator.foreign.CLinker;\n+import jdk.incubator.foreign.FunctionDescriptor;\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.SegmentAllocator;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.util.Objects;\n+\n+public abstract non-sealed class AbstractCLinker implements CLinker {\n+\n+    public final MethodHandle downcallHandle(Addressable symbol, MethodType type, FunctionDescriptor function) {\n+        Objects.requireNonNull(symbol);\n+        return MethodHandles.insertArguments(downcallHandle(type, function), 0, symbol);\n+    }\n+\n+    public final MethodHandle downcallHandle(Addressable symbol, SegmentAllocator allocator, MethodType type, FunctionDescriptor function) {\n+        Objects.requireNonNull(symbol);\n+        Objects.requireNonNull(allocator);\n+        MethodHandle downcall = MethodHandles.insertArguments(downcallHandle(type, function), 0, symbol);\n+        if (type.returnType().equals(MemorySegment.class)) {\n+            downcall = MethodHandles.insertArguments(downcall, 0, allocator);\n+        }\n+        return downcall;\n+    }\n+}\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/AbstractCLinker.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"added"},{"patch":"@@ -38,3 +38,0 @@\n-import java.io.FileDescriptor;\n-import java.lang.invoke.VarHandle;\n-import java.lang.ref.Cleaner;\n@@ -46,0 +43,2 @@\n+import java.util.stream.Stream;\n+import java.util.stream.StreamSupport;\n@@ -52,1 +51,1 @@\n- * than the owner thread. See {@link MemoryScope} for more details on management of temporal bounds. Subclasses\n+ * than the owner thread. See {@link ResourceScopeImpl} for more details on management of temporal bounds. Subclasses\n@@ -56,1 +55,1 @@\n-public abstract class AbstractMemorySegmentImpl extends MemorySegmentProxy implements MemorySegment {\n+public abstract non-sealed class AbstractMemorySegmentImpl extends MemorySegmentProxy implements MemorySegment {\n@@ -63,3 +62,3 @@\n-    final static int FIRST_RESERVED_FLAG = 1 << 16; \/\/ upper 16 bits are reserved\n-    final static int SMALL = FIRST_RESERVED_FLAG;\n-    final static long NONCE = new Random().nextLong();\n+    static final int READ_ONLY = 1;\n+    static final int SMALL = READ_ONLY << 1;\n+    static final long NONCE = new Random().nextLong();\n@@ -67,1 +66,1 @@\n-    final static JavaNioAccess nioAccess = SharedSecrets.getJavaNioAccess();\n+    static final JavaNioAccess nioAccess = SharedSecrets.getJavaNioAccess();\n@@ -71,1 +70,1 @@\n-    final MemoryScope scope;\n+    final ResourceScopeImpl scope;\n@@ -74,1 +73,1 @@\n-    AbstractMemorySegmentImpl(long length, int mask, MemoryScope scope) {\n+    AbstractMemorySegmentImpl(long length, int mask, ResourceScopeImpl scope) {\n@@ -84,1 +83,1 @@\n-    abstract AbstractMemorySegmentImpl dup(long offset, long size, int mask, MemoryScope scope);\n+    abstract AbstractMemorySegmentImpl dup(long offset, long size, int mask, ResourceScopeImpl scope);\n@@ -90,2 +89,11 @@\n-                ALL_ACCESS | SMALL :\n-                ALL_ACCESS;\n+                SMALL : 0;\n+    }\n+\n+    @Override\n+    public AbstractMemorySegmentImpl asReadOnly() {\n+        return dup(0, length, mask | READ_ONLY, scope);\n+    }\n+\n+    @Override\n+    public boolean isReadOnly() {\n+        return isSet(READ_ONLY);\n@@ -111,5 +119,7 @@\n-    public Spliterator<MemorySegment> spliterator(SequenceLayout sequenceLayout) {\n-        Objects.requireNonNull(sequenceLayout);\n-        checkValidState();\n-        if (sequenceLayout.byteSize() != byteSize()) {\n-            throw new IllegalArgumentException();\n+    public Spliterator<MemorySegment> spliterator(MemoryLayout elementLayout) {\n+        Objects.requireNonNull(elementLayout);\n+        if (elementLayout.byteSize() == 0) {\n+            throw new IllegalArgumentException(\"Element layout size cannot be zero\");\n+        }\n+        if (byteSize() % elementLayout.byteSize() != 0) {\n+            throw new IllegalArgumentException(\"Segment size is no a multiple of layout size\");\n@@ -117,2 +127,7 @@\n-        return new SegmentSplitter(sequenceLayout.elementLayout().byteSize(), sequenceLayout.elementCount().getAsLong(),\n-                withAccessModes(accessModes() & ~CLOSE));\n+        return new SegmentSplitter(elementLayout.byteSize(), byteSize() \/ elementLayout.byteSize(),\n+                this);\n+    }\n+\n+    @Override\n+    public Stream<MemorySegment> elements(MemoryLayout elementLayout) {\n+        return StreamSupport.stream(spliterator(elementLayout), false);\n@@ -188,4 +203,4 @@\n-    private static long vectorizedMismatchLargeForBytes(MemoryScope aScope, MemoryScope bScope,\n-                                                       Object a, long aOffset,\n-                                                       Object b, long bOffset,\n-                                                       long length) {\n+    private static long vectorizedMismatchLargeForBytes(ResourceScopeImpl aScope, ResourceScopeImpl bScope,\n+                                                        Object a, long aOffset,\n+                                                        Object b, long bOffset,\n+                                                        long length) {\n@@ -220,2 +235,1 @@\n-        checkValidState();\n-        return new MemoryAddressImpl(base(), min());\n+        return new MemoryAddressImpl(this, 0L);\n@@ -226,3 +240,0 @@\n-        if (!isSet(READ)) {\n-            throw unsupportedAccessMode(READ);\n-        }\n@@ -231,1 +242,1 @@\n-        if (!isSet(WRITE)) {\n+        if (isSet(READ_ONLY)) {\n@@ -238,5 +249,0 @@\n-    @Override\n-    public final int accessModes() {\n-        return mask & ALL_ACCESS;\n-    }\n-\n@@ -248,1 +254,0 @@\n-    @Override\n@@ -253,1 +258,0 @@\n-    @Override\n@@ -259,32 +263,2 @@\n-    public AbstractMemorySegmentImpl withAccessModes(int accessModes) {\n-        checkAccessModes(accessModes);\n-        if ((~accessModes() & accessModes) != 0) {\n-            throw new IllegalArgumentException(\"Cannot acquire more access modes\");\n-        }\n-        return dup(0, length, (mask & ~ALL_ACCESS) | accessModes, scope);\n-    }\n-\n-    @Override\n-    public boolean hasAccessModes(int accessModes) {\n-        checkAccessModes(accessModes);\n-        return (accessModes() & accessModes) == accessModes;\n-    }\n-\n-    private void checkAccessModes(int accessModes) {\n-        if ((accessModes & ~ALL_ACCESS) != 0) {\n-            throw new IllegalArgumentException(\"Invalid access modes\");\n-        }\n-    }\n-\n-    public MemorySegment handoff(Thread thread) {\n-        Objects.requireNonNull(thread);\n-        checkValidState();\n-        if (!isSet(HANDOFF)) {\n-            throw unsupportedAccessMode(HANDOFF);\n-        }\n-        try {\n-            return dup(0L, length, mask, scope.confineTo(thread));\n-        } finally {\n-            \/\/flush read\/writes to segment memory before returning the new segment\n-            VarHandle.fullFence();\n-        }\n+    public boolean isMapped() {\n+        return false;\n@@ -294,11 +268,2 @@\n-    public MemorySegment share() {\n-        checkValidState();\n-        if (!isSet(SHARE)) {\n-            throw unsupportedAccessMode(SHARE);\n-        }\n-        try {\n-            return dup(0L, length, mask, scope.share());\n-        } finally {\n-            \/\/flush read\/writes to segment memory before returning the new segment\n-            VarHandle.fullFence();\n-        }\n+    public boolean isNative() {\n+        return false;\n@@ -308,12 +273,2 @@\n-    public MemorySegment handoff(NativeScope scope) {\n-        Objects.requireNonNull(scope);\n-        checkValidState();\n-        if (!isSet(HANDOFF)) {\n-            throw unsupportedAccessMode(HANDOFF);\n-        }\n-        if (!isSet(CLOSE)) {\n-            throw unsupportedAccessMode(CLOSE);\n-        }\n-        MemorySegment dup = handoff(scope.ownerThread());\n-        ((AbstractNativeScope)scope).register(dup);\n-        return dup.withAccessModes(accessModes() & (READ | WRITE));\n+    public void load() {\n+        throw new UnsupportedOperationException(\"Not a mapped segment\");\n@@ -323,7 +278,2 @@\n-    public MemorySegment registerCleaner(Cleaner cleaner) {\n-        Objects.requireNonNull(cleaner);\n-        checkValidState();\n-        if (!isSet(CLOSE)) {\n-            throw unsupportedAccessMode(CLOSE);\n-        }\n-        return dup(0L, length, mask, scope.cleanable(cleaner));\n+    public void unload() {\n+        throw new UnsupportedOperationException(\"Not a mapped segment\");\n@@ -333,6 +283,2 @@\n-    public final void close() {\n-        checkValidState();\n-        if (!isSet(CLOSE)) {\n-            throw unsupportedAccessMode(CLOSE);\n-        }\n-        scope.close();\n+    public boolean isLoaded() {\n+        throw new UnsupportedOperationException(\"Not a mapped segment\");\n@@ -342,2 +288,2 @@\n-    public boolean isMapped() {\n-        return false;\n+    public void force() {\n+        throw new UnsupportedOperationException(\"Not a mapped segment\");\n@@ -396,4 +342,2 @@\n-        if (!readOnly && !isSet(WRITE)) {\n-            throw unsupportedAccessMode(WRITE);\n-        } else if (readOnly && !isSet(READ)) {\n-            throw unsupportedAccessMode(READ);\n+        if (!readOnly && isSet(READ_ONLY)) {\n+            throw new UnsupportedOperationException(\"Attempt to write a read-only segment\");\n@@ -404,6 +348,1 @@\n-    private void checkAccessAndScope(long offset, long length, boolean readOnly) {\n-        checkValidState();\n-        checkAccess(offset, length, readOnly);\n-    }\n-\n-    private void checkValidState() {\n+    void checkValidState() {\n@@ -435,1 +374,1 @@\n-            throw new UnsupportedOperationException(String.format(\"Segment size is not a multiple of %d. Size: %d\", elemSize, length));\n+            throw new IllegalStateException(String.format(\"Segment size is not a multiple of %d. Size: %d\", elemSize, length));\n@@ -439,1 +378,1 @@\n-            throw new UnsupportedOperationException(String.format(\"Segment is too large to wrap as %s. Size: %d\", typeName, length));\n+            throw new IllegalStateException(String.format(\"Segment is too large to wrap as %s. Size: %d\", typeName, length));\n@@ -445,1 +384,3 @@\n-        if (isSmall()) {\n+        if (isSmall() &&\n+                offset < Integer.MAX_VALUE && length < Integer.MAX_VALUE &&\n+                offset > Integer.MIN_VALUE && length > Integer.MIN_VALUE) {\n@@ -457,1 +398,1 @@\n-    public MemoryScope scope() {\n+    public ResourceScopeImpl scope() {\n@@ -469,25 +410,0 @@\n-    UnsupportedOperationException unsupportedAccessMode(int expected) {\n-        return new UnsupportedOperationException((String.format(\"Required access mode %s ; current access modes: %s\",\n-                modeStrings(expected).get(0), modeStrings(mask))));\n-    }\n-\n-    private List<String> modeStrings(int mode) {\n-        List<String> modes = new ArrayList<>();\n-        if ((mode & READ) != 0) {\n-            modes.add(\"READ\");\n-        }\n-        if ((mode & WRITE) != 0) {\n-            modes.add(\"WRITE\");\n-        }\n-        if ((mode & CLOSE) != 0) {\n-            modes.add(\"CLOSE\");\n-        }\n-        if ((mode & SHARE) != 0) {\n-            modes.add(\"SHARE\");\n-        }\n-        if ((mode & HANDOFF) != 0) {\n-            modes.add(\"HANDOFF\");\n-        }\n-        return modes;\n-    }\n-\n@@ -605,1 +521,1 @@\n-        final MemoryScope bufferScope;\n+        final ResourceScopeImpl bufferScope;\n@@ -611,1 +527,1 @@\n-            bufferScope = MemoryScope.createConfined(bb, MemoryScope.DUMMY_CLEANUP_ACTION, null);\n+            bufferScope = ResourceScopeImpl.GLOBAL;\n@@ -615,1 +531,1 @@\n-            modes &= ~WRITE;\n+            modes |= READ_ONLY;\n@@ -618,1 +534,1 @@\n-            return new HeapMemorySegmentImpl.OfByte(bbAddress + pos, (byte[])base, size, modes, bufferScope);\n+            return new HeapMemorySegmentImpl.OfByte(bbAddress + pos, (byte[])base, size, modes);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/AbstractMemorySegmentImpl.java","additions":67,"deletions":151,"binary":false,"changes":218,"status":"modified"},{"patch":"@@ -1,172 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.internal.foreign;\n-\n-import jdk.incubator.foreign.MemorySegment;\n-import jdk.incubator.foreign.NativeScope;\n-\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.OptionalLong;\n-\n-public abstract class AbstractNativeScope implements NativeScope {\n-\n-    private final List<MemorySegment> segments = new ArrayList<>();\n-    private final Thread ownerThread;\n-\n-    private static final int SCOPE_MASK = MemorySegment.READ | MemorySegment.WRITE; \/\/ no terminal operations allowed\n-\n-    AbstractNativeScope() {\n-        this.ownerThread = Thread.currentThread();\n-    }\n-\n-    @Override\n-    public Thread ownerThread() {\n-        return ownerThread;\n-    }\n-\n-    @Override\n-    public void close() {\n-        segments.forEach(MemorySegment::close);\n-    }\n-\n-    void checkOwnerThread() {\n-        if (Thread.currentThread() != ownerThread()) {\n-            throw new IllegalStateException(\"Attempt to access scope from different thread\");\n-        }\n-    }\n-\n-    MemorySegment newSegment(long size, long align) {\n-        MemorySegment segment = MemorySegment.allocateNative(size, align);\n-        segments.add(segment);\n-        return segment;\n-    }\n-\n-    MemorySegment newSegment(long size) {\n-        return newSegment(size, size);\n-    }\n-\n-    public void register(MemorySegment segment) {\n-        segments.add(segment);\n-    }\n-\n-    public static class UnboundedNativeScope extends AbstractNativeScope {\n-\n-        private static final long BLOCK_SIZE = 4 * 1024;\n-        private static final long MAX_ALLOC_SIZE = BLOCK_SIZE \/ 2;\n-\n-        private MemorySegment segment;\n-        private long sp = 0L;\n-        private long size = 0L;\n-\n-        @Override\n-        public OptionalLong byteSize() {\n-            return OptionalLong.empty();\n-        }\n-\n-        @Override\n-        public long allocatedBytes() {\n-            return size;\n-        }\n-\n-        public UnboundedNativeScope() {\n-            super();\n-            this.segment = newSegment(BLOCK_SIZE);\n-        }\n-\n-        @Override\n-        public MemorySegment allocate(long bytesSize, long bytesAlignment) {\n-            checkOwnerThread();\n-            if (Utils.alignUp(bytesSize, bytesAlignment) > MAX_ALLOC_SIZE) {\n-                MemorySegment segment = newSegment(bytesSize, bytesAlignment);\n-                return segment.withAccessModes(SCOPE_MASK);\n-            }\n-            \/\/ try to slice from current segment first...\n-            MemorySegment slice = trySlice(bytesSize, bytesAlignment);\n-            if (slice == null) {\n-                \/\/ ... if that fails, allocate a new segment and slice from there\n-                sp = 0L;\n-                segment = newSegment(BLOCK_SIZE, 1L);\n-                slice = trySlice(bytesSize, bytesAlignment);\n-                if (slice == null) {\n-                    \/\/ this should not be possible - allocations that do not fit in BLOCK_SIZE should get their own\n-                    \/\/ standalone segment (see above).\n-                    throw new AssertionError(\"Cannot get here!\");\n-                }\n-            }\n-            return slice;\n-        }\n-\n-        private MemorySegment trySlice(long bytesSize, long bytesAlignment) {\n-            long min = segment.address().toRawLongValue();\n-            long start = Utils.alignUp(min + sp, bytesAlignment) - min;\n-            if (segment.byteSize() - start < bytesSize) {\n-                return null;\n-            } else {\n-                MemorySegment slice = segment.asSlice(start, bytesSize)\n-                        .withAccessModes(SCOPE_MASK);\n-                sp = start + bytesSize;\n-                size += Utils.alignUp(bytesSize, bytesAlignment);\n-                return slice;\n-            }\n-        }\n-    }\n-\n-    public static class BoundedNativeScope extends AbstractNativeScope {\n-        private final MemorySegment segment;\n-        private long sp = 0L;\n-\n-        @Override\n-        public OptionalLong byteSize() {\n-            return OptionalLong.of(segment.byteSize());\n-        }\n-\n-        @Override\n-        public long allocatedBytes() {\n-            return sp;\n-        }\n-\n-        public BoundedNativeScope(long size) {\n-            super();\n-            this.segment = newSegment(size, 1);\n-        }\n-\n-        @Override\n-        public MemorySegment allocate(long bytesSize, long bytesAlignment) {\n-            checkOwnerThread();\n-            long min = segment.address().toRawLongValue();\n-            long start = Utils.alignUp(min + sp, bytesAlignment) - min;\n-            try {\n-                MemorySegment slice = segment.asSlice(start, bytesSize)\n-                        .withAccessModes(SCOPE_MASK);\n-                sp = start + bytesSize;\n-                return slice;\n-            } catch (IndexOutOfBoundsException ex) {\n-                throw new OutOfMemoryError(\"Not enough space left to allocate\");\n-            }\n-        }\n-    }\n-}\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/AbstractNativeScope.java","additions":0,"deletions":172,"binary":false,"changes":172,"status":"deleted"},{"patch":"@@ -0,0 +1,124 @@\n+package jdk.internal.foreign;\n+\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.SegmentAllocator;\n+import jdk.incubator.foreign.ResourceScope;\n+\n+public abstract class ArenaAllocator implements SegmentAllocator {\n+\n+    protected MemorySegment segment;\n+\n+    protected long sp = 0L;\n+\n+    ArenaAllocator(MemorySegment segment) {\n+        this.segment = segment;\n+    }\n+\n+    MemorySegment trySlice(long bytesSize, long bytesAlignment) {\n+        long min = segment.address().toRawLongValue();\n+        long start = Utils.alignUp(min + sp, bytesAlignment) - min;\n+        if (segment.byteSize() - start < bytesSize) {\n+            return null;\n+        } else {\n+            MemorySegment slice = segment.asSlice(start, bytesSize);\n+            sp = start + bytesSize;\n+            return slice;\n+        }\n+    }\n+\n+    void checkConfinementIfNeeded() {\n+        Thread ownerThread = scope().ownerThread();\n+        if (ownerThread != null && ownerThread != Thread.currentThread()) {\n+            throw new IllegalStateException(\"Attempt to allocate outside confinement thread\");\n+        }\n+    }\n+\n+    ResourceScope scope() {\n+        return segment.scope();\n+    }\n+\n+    public static class UnboundedArenaAllocator extends ArenaAllocator {\n+\n+        private static final long DEFAULT_BLOCK_SIZE = 4 * 1024;\n+\n+        public UnboundedArenaAllocator(ResourceScope scope) {\n+            super(MemorySegment.allocateNative(DEFAULT_BLOCK_SIZE, 1, scope));\n+        }\n+\n+        private MemorySegment newSegment(long size, long align) {\n+            return MemorySegment.allocateNative(size, align, segment.scope());\n+        }\n+\n+        @Override\n+        public MemorySegment allocate(long bytesSize, long bytesAlignment) {\n+            checkConfinementIfNeeded();\n+            \/\/ try to slice from current segment first...\n+            MemorySegment slice = trySlice(bytesSize, bytesAlignment);\n+            if (slice != null) {\n+                return slice;\n+            } else {\n+                long maxPossibleAllocationSize = bytesSize + bytesAlignment - 1;\n+                if (maxPossibleAllocationSize > DEFAULT_BLOCK_SIZE) {\n+                    \/\/ too big\n+                    return newSegment(bytesSize, bytesAlignment);\n+                } else {\n+                    \/\/ allocate a new segment and slice from there\n+                    sp = 0L;\n+                    segment = newSegment(DEFAULT_BLOCK_SIZE, 1L);\n+                    return trySlice(bytesSize, bytesAlignment);\n+                }\n+            }\n+        }\n+    }\n+\n+    public static class BoundedArenaAllocator extends ArenaAllocator {\n+\n+        public BoundedArenaAllocator(ResourceScope scope, long size) {\n+            super(MemorySegment.allocateNative(size, 1, scope));\n+        }\n+\n+        @Override\n+        public MemorySegment allocate(long bytesSize, long bytesAlignment) {\n+            checkConfinementIfNeeded();\n+            \/\/ try to slice from current segment first...\n+            MemorySegment slice = trySlice(bytesSize, bytesAlignment);\n+            if (slice != null) {\n+                return slice;\n+            } else {\n+                throw new OutOfMemoryError(\"Not enough space left to allocate\");\n+            }\n+        }\n+    }\n+\n+    public static class BoundedSharedArenaAllocator extends BoundedArenaAllocator {\n+        public BoundedSharedArenaAllocator(ResourceScope scope, long size) {\n+            super(scope, size);\n+        }\n+\n+        @Override\n+        public synchronized MemorySegment allocate(long bytesSize, long bytesAlignment) {\n+            return super.allocate(bytesSize, bytesAlignment);\n+        }\n+    }\n+\n+    public static class UnboundedSharedArenaAllocator implements SegmentAllocator {\n+\n+        final ResourceScope scope;\n+\n+        final ThreadLocal<ArenaAllocator> allocators = new ThreadLocal<>() {\n+            @Override\n+            protected ArenaAllocator initialValue() {\n+                return new UnboundedArenaAllocator(scope);\n+            }\n+        };\n+\n+        public UnboundedSharedArenaAllocator(ResourceScope scope) {\n+            this.scope = scope;\n+        }\n+\n+        @Override\n+        public MemorySegment allocate(long bytesSize, long bytesAlignment) {\n+            return allocators.get().allocate(bytesSize, bytesAlignment);\n+        }\n+    }\n+}\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/ArenaAllocator.java","additions":124,"deletions":0,"binary":false,"changes":124,"status":"added"},{"patch":"@@ -0,0 +1,133 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.foreign;\n+\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.internal.vm.annotation.ForceInline;\n+\n+import java.lang.ref.Cleaner;\n+import java.lang.ref.Reference;\n+\n+\/**\n+ * A confined scope, which features an owner thread. The liveness check features an additional\n+ * confinement check - that is, calling any operation on this scope from a thread other than the\n+ * owner thread will result in an exception. Because of this restriction, checking the liveness bit\n+ * can be performed in plain mode.\n+ *\/\n+final class ConfinedScope extends ResourceScopeImpl {\n+\n+    private boolean closed; \/\/ = false\n+    private int lockCount = 0;\n+    private final Thread owner;\n+\n+    public ConfinedScope(Thread owner, Cleaner cleaner) {\n+        super(cleaner, new ConfinedResourceList());\n+        this.owner = owner;\n+    }\n+\n+    @ForceInline\n+    public final void checkValidState() {\n+        if (owner != Thread.currentThread()) {\n+            throw new IllegalStateException(\"Attempted access outside owning thread\");\n+        }\n+        if (closed) {\n+            throw new IllegalStateException(\"Already closed\");\n+        }\n+    }\n+\n+    @Override\n+    public boolean isAlive() {\n+        return !closed;\n+    }\n+\n+    @Override\n+    public HandleImpl acquire() {\n+        checkValidState();\n+        lockCount++;\n+        return new ConfinedHandle();\n+    }\n+\n+    void justClose() {\n+        this.checkValidState();\n+        if (lockCount == 0) {\n+            closed = true;\n+        } else {\n+            throw new IllegalStateException(\"Scope is acquired by \" + lockCount + \" locks\");\n+        }\n+    }\n+\n+    @Override\n+    public Thread ownerThread() {\n+        return owner;\n+    }\n+\n+    \/**\n+     * A confined resource list; no races are possible here.\n+     *\/\n+    static final class ConfinedResourceList extends ResourceList {\n+        @Override\n+        void add(ResourceCleanup cleanup) {\n+            if (fst != ResourceCleanup.CLOSED_LIST) {\n+                cleanup.next = fst;\n+                fst = cleanup;\n+            } else {\n+                throw new IllegalStateException(\"Already closed!\");\n+            }\n+        }\n+\n+        @Override\n+        void cleanup() {\n+            if (fst != ResourceCleanup.CLOSED_LIST) {\n+                ResourceCleanup prev = fst;\n+                fst = ResourceCleanup.CLOSED_LIST;\n+                cleanup(prev);\n+            } else {\n+                throw new IllegalStateException(\"Attempt to cleanup an already closed resource list\");\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * A confined resource scope handle; no races are possible here.\n+     *\/\n+    final class ConfinedHandle implements HandleImpl {\n+        boolean released = false;\n+\n+        @Override\n+        public ResourceScopeImpl scope() {\n+            return ConfinedScope.this;\n+        }\n+\n+        @Override\n+        public void release() {\n+            checkValidState(); \/\/ thread check\n+            if (!released) {\n+                released = true;\n+                lockCount--;\n+            }\n+        }\n+    }\n+}\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/ConfinedScope.java","additions":133,"deletions":0,"binary":false,"changes":133,"status":"added"},{"patch":"@@ -37,1 +37,0 @@\n-import java.util.function.Supplier;\n@@ -55,2 +54,2 @@\n-    HeapMemorySegmentImpl(long offset, H base, long length, int mask, MemoryScope scope) {\n-        super(length, mask, scope);\n+    HeapMemorySegmentImpl(long offset, H base, long length, int mask) {\n+        super(length, mask, ResourceScopeImpl.GLOBAL);\n@@ -70,1 +69,1 @@\n-    abstract HeapMemorySegmentImpl<H> dup(long offset, long size, int mask, MemoryScope scope);\n+    abstract HeapMemorySegmentImpl<H> dup(long offset, long size, int mask, ResourceScopeImpl scope);\n@@ -78,1 +77,1 @@\n-        return nioAccess.newHeapByteBuffer((byte[]) base(), (int)min() - BYTE_ARR_BASE, (int) byteSize(), this);\n+        return nioAccess.newHeapByteBuffer((byte[]) base(), (int)min() - BYTE_ARR_BASE, (int) byteSize(), null);\n@@ -85,2 +84,2 @@\n-        OfByte(long offset, byte[] base, long length, int mask, MemoryScope scope) {\n-            super(offset, base, length, mask, scope);\n+        OfByte(long offset, byte[] base, long length, int mask) {\n+            super(offset, base, length, mask);\n@@ -90,2 +89,2 @@\n-        OfByte dup(long offset, long size, int mask, MemoryScope scope) {\n-            return new OfByte(this.offset + offset, base, size, mask, scope);\n+        OfByte dup(long offset, long size, int mask, ResourceScopeImpl scope) {\n+            return new OfByte(this.offset + offset, base, size, mask);\n@@ -102,2 +101,1 @@\n-            MemoryScope scope = MemoryScope.createConfined(null, MemoryScope.DUMMY_CLEANUP_ACTION, null);\n-            return new OfByte(Unsafe.ARRAY_BYTE_BASE_OFFSET, arr, byteSize, defaultAccessModes(byteSize), scope);\n+            return new OfByte(Unsafe.ARRAY_BYTE_BASE_OFFSET, arr, byteSize, defaultAccessModes(byteSize));\n@@ -109,2 +107,2 @@\n-        OfChar(long offset, char[] base, long length, int mask, MemoryScope scope) {\n-            super(offset, base, length, mask, scope);\n+        OfChar(long offset, char[] base, long length, int mask) {\n+            super(offset, base, length, mask);\n@@ -114,2 +112,2 @@\n-        OfChar dup(long offset, long size, int mask, MemoryScope scope) {\n-            return new OfChar(this.offset + offset, base, size, mask, scope);\n+        OfChar dup(long offset, long size, int mask, ResourceScopeImpl scope) {\n+            return new OfChar(this.offset + offset, base, size, mask);\n@@ -126,2 +124,1 @@\n-            MemoryScope scope = MemoryScope.createConfined(null, MemoryScope.DUMMY_CLEANUP_ACTION, null);\n-            return new OfChar(Unsafe.ARRAY_CHAR_BASE_OFFSET, arr, byteSize, defaultAccessModes(byteSize), scope);\n+            return new OfChar(Unsafe.ARRAY_CHAR_BASE_OFFSET, arr, byteSize, defaultAccessModes(byteSize));\n@@ -133,2 +130,2 @@\n-        OfShort(long offset, short[] base, long length, int mask, MemoryScope scope) {\n-            super(offset, base, length, mask, scope);\n+        OfShort(long offset, short[] base, long length, int mask) {\n+            super(offset, base, length, mask);\n@@ -138,2 +135,2 @@\n-        OfShort dup(long offset, long size, int mask, MemoryScope scope) {\n-            return new OfShort(this.offset + offset, base, size, mask, scope);\n+        OfShort dup(long offset, long size, int mask, ResourceScopeImpl scope) {\n+            return new OfShort(this.offset + offset, base, size, mask);\n@@ -150,2 +147,1 @@\n-            MemoryScope scope = MemoryScope.createConfined(null, MemoryScope.DUMMY_CLEANUP_ACTION, null);\n-            return new OfShort(Unsafe.ARRAY_SHORT_BASE_OFFSET, arr, byteSize, defaultAccessModes(byteSize), scope);\n+            return new OfShort(Unsafe.ARRAY_SHORT_BASE_OFFSET, arr, byteSize, defaultAccessModes(byteSize));\n@@ -157,2 +153,2 @@\n-        OfInt(long offset, int[] base, long length, int mask, MemoryScope scope) {\n-            super(offset, base, length, mask, scope);\n+        OfInt(long offset, int[] base, long length, int mask) {\n+            super(offset, base, length, mask);\n@@ -162,2 +158,2 @@\n-        OfInt dup(long offset, long size, int mask, MemoryScope scope) {\n-            return new OfInt(this.offset + offset, base, size, mask, scope);\n+        OfInt dup(long offset, long size, int mask, ResourceScopeImpl scope) {\n+            return new OfInt(this.offset + offset, base, size, mask);\n@@ -174,2 +170,1 @@\n-            MemoryScope scope = MemoryScope.createConfined(null, MemoryScope.DUMMY_CLEANUP_ACTION, null);\n-            return new OfInt(Unsafe.ARRAY_INT_BASE_OFFSET, arr, byteSize, defaultAccessModes(byteSize), scope);\n+            return new OfInt(Unsafe.ARRAY_INT_BASE_OFFSET, arr, byteSize, defaultAccessModes(byteSize));\n@@ -181,2 +176,2 @@\n-        OfLong(long offset, long[] base, long length, int mask, MemoryScope scope) {\n-            super(offset, base, length, mask, scope);\n+        OfLong(long offset, long[] base, long length, int mask) {\n+            super(offset, base, length, mask);\n@@ -186,2 +181,2 @@\n-        OfLong dup(long offset, long size, int mask, MemoryScope scope) {\n-            return new OfLong(this.offset + offset, base, size, mask, scope);\n+        OfLong dup(long offset, long size, int mask, ResourceScopeImpl scope) {\n+            return new OfLong(this.offset + offset, base, size, mask);\n@@ -198,2 +193,1 @@\n-            MemoryScope scope = MemoryScope.createConfined(null, MemoryScope.DUMMY_CLEANUP_ACTION, null);\n-            return new OfLong(Unsafe.ARRAY_LONG_BASE_OFFSET, arr, byteSize, defaultAccessModes(byteSize), scope);\n+            return new OfLong(Unsafe.ARRAY_LONG_BASE_OFFSET, arr, byteSize, defaultAccessModes(byteSize));\n@@ -205,2 +199,2 @@\n-        OfFloat(long offset, float[] base, long length, int mask, MemoryScope scope) {\n-            super(offset, base, length, mask, scope);\n+        OfFloat(long offset, float[] base, long length, int mask) {\n+            super(offset, base, length, mask);\n@@ -210,2 +204,2 @@\n-        OfFloat dup(long offset, long size, int mask, MemoryScope scope) {\n-            return new OfFloat(this.offset + offset, base, size, mask, scope);\n+        OfFloat dup(long offset, long size, int mask, ResourceScopeImpl scope) {\n+            return new OfFloat(this.offset + offset, base, size, mask);\n@@ -222,2 +216,1 @@\n-            MemoryScope scope = MemoryScope.createConfined(null, MemoryScope.DUMMY_CLEANUP_ACTION, null);\n-            return new OfFloat(Unsafe.ARRAY_FLOAT_BASE_OFFSET, arr, byteSize, defaultAccessModes(byteSize), scope);\n+            return new OfFloat(Unsafe.ARRAY_FLOAT_BASE_OFFSET, arr, byteSize, defaultAccessModes(byteSize));\n@@ -229,2 +222,2 @@\n-        OfDouble(long offset, double[] base, long length, int mask, MemoryScope scope) {\n-            super(offset, base, length, mask, scope);\n+        OfDouble(long offset, double[] base, long length, int mask) {\n+            super(offset, base, length, mask);\n@@ -234,2 +227,2 @@\n-        OfDouble dup(long offset, long size, int mask, MemoryScope scope) {\n-            return new OfDouble(this.offset + offset, base, size, mask, scope);\n+        OfDouble dup(long offset, long size, int mask, ResourceScopeImpl scope) {\n+            return new OfDouble(this.offset + offset, base, size, mask);\n@@ -246,2 +239,1 @@\n-            MemoryScope scope = MemoryScope.createConfined(null, MemoryScope.DUMMY_CLEANUP_ACTION, null);\n-            return new OfDouble(Unsafe.ARRAY_DOUBLE_BASE_OFFSET, arr, byteSize, defaultAccessModes(byteSize), scope);\n+            return new OfDouble(Unsafe.ARRAY_DOUBLE_BASE_OFFSET, arr, byteSize, defaultAccessModes(byteSize));\n@@ -250,0 +242,1 @@\n+\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/HeapMemorySegmentImpl.java","additions":40,"deletions":47,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -38,1 +38,0 @@\n-import sun.invoke.util.Wrapper;\n@@ -65,0 +64,1 @@\n+    private static final MethodHandle MH_SLICE;\n@@ -75,0 +75,2 @@\n+            MH_SLICE = lookup.findVirtual(MemorySegment.class, \"asSlice\",\n+                    MethodType.methodType(MemorySegment.class, long.class, long.class));\n@@ -203,0 +205,16 @@\n+    public MethodHandle sliceHandle() {\n+        if (strides.length == 0) {\n+            \/\/ trigger checks eagerly\n+            Utils.bitsToBytesOrThrow(offset, Utils.bitsToBytesThrowOffset);\n+        }\n+\n+        MethodHandle offsetHandle = offsetHandle(); \/\/ bit offset\n+        offsetHandle = MethodHandles.filterReturnValue(offsetHandle, Utils.MH_bitsToBytesOrThrowForOffset); \/\/ byte offset\n+\n+        MethodHandle sliceHandle = MH_SLICE; \/\/ (MS, long, long) -> MS\n+        sliceHandle = MethodHandles.insertArguments(sliceHandle, 2, layout.byteSize()); \/\/ (MS, long) -> MS\n+        sliceHandle = MethodHandles.collectArguments(sliceHandle, 1, offsetHandle); \/\/ (MS, ...) -> MS\n+\n+        return sliceHandle;\n+    }\n+\n@@ -214,1 +232,1 @@\n-                return enclosing.map(l -> dup(l, MemoryLayout.ofSequence(seq.elementCount().getAsLong(), newLayout)));\n+                return enclosing.map(l -> dup(l, MemoryLayout.sequenceLayout(seq.elementCount().getAsLong(), newLayout)));\n@@ -216,1 +234,1 @@\n-                return enclosing.map(l -> dup(l, MemoryLayout.ofSequence(newLayout)));\n+                return enclosing.map(l -> dup(l, MemoryLayout.sequenceLayout(newLayout)));\n@@ -224,1 +242,1 @@\n-                return enclosing.map(l -> dup(l, MemoryLayout.ofUnion(newElements.toArray(new MemoryLayout[0]))));\n+                return enclosing.map(l -> dup(l, MemoryLayout.unionLayout(newElements.toArray(new MemoryLayout[0]))));\n@@ -226,1 +244,1 @@\n-                return enclosing.map(l -> dup(l, MemoryLayout.ofStruct(newElements.toArray(new MemoryLayout[0]))));\n+                return enclosing.map(l -> dup(l, MemoryLayout.structLayout(newElements.toArray(new MemoryLayout[0]))));\n@@ -302,1 +320,1 @@\n-    public static class PathElementImpl implements MemoryLayout.PathElement, UnaryOperator<LayoutPath> {\n+    public static final class PathElementImpl implements MemoryLayout.PathElement, UnaryOperator<LayoutPath> {\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/LayoutPath.java","additions":24,"deletions":6,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -32,0 +32,3 @@\n+import jdk.incubator.foreign.MemoryLayout;\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ResourceScope;\n@@ -34,1 +37,0 @@\n-import jdk.internal.ref.CleanerFactory;\n@@ -36,4 +38,2 @@\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.util.Arrays;\n-import java.util.IdentityHashMap;\n+import java.lang.ref.Reference;\n+import java.lang.ref.WeakReference;\n@@ -43,1 +43,1 @@\n-import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.ConcurrentHashMap;\n@@ -49,1 +49,1 @@\n-    private final static NativeLibraries nativeLibraries =\n+    private static final NativeLibraries nativeLibraries =\n@@ -52,1 +52,1 @@\n-    private final static Map<NativeLibrary, AtomicInteger> loadedLibraries = new IdentityHashMap<>();\n+    private static final Map<NativeLibrary, WeakReference<ResourceScope>> loadedLibraries = new ConcurrentHashMap<>();\n@@ -79,8 +79,0 @@\n-    \/\/ return the absolute path of the library of given name by searching\n-    \/\/ in the given array of paths.\n-    private static Optional<Path> findLibraryPath(Path[] paths, String libName) {\n-         return Arrays.stream(paths).\n-              map(p -> p.resolve(System.mapLibraryName(libName))).\n-              filter(Files::isRegularFile).map(Path::toAbsolutePath).findFirst();\n-    }\n-\n@@ -91,1 +83,1 @@\n-    synchronized static LibraryLookupImpl lookup(Supplier<NativeLibrary> librarySupplier, String notFoundMsg) {\n+    static LibraryLookupImpl lookup(Supplier<NativeLibrary> librarySupplier, String notFoundMsg) {\n@@ -96,12 +88,14 @@\n-        AtomicInteger refCount = loadedLibraries.computeIfAbsent(library, lib -> new AtomicInteger());\n-        refCount.incrementAndGet();\n-        LibraryLookupImpl lookup = new LibraryLookupImpl(library);\n-        CleanerFactory.cleaner().register(lookup, () -> tryUnload(library));\n-        return lookup;\n-    }\n-\n-    synchronized static void tryUnload(NativeLibrary library) {\n-        AtomicInteger refCount = loadedLibraries.get(library);\n-        if (refCount.decrementAndGet() == 0) {\n-            loadedLibraries.remove(library);\n-            nativeLibraries.unload(library);\n+        ResourceScope[] holder = new ResourceScope[1];\n+        try {\n+            WeakReference<ResourceScope> scopeRef = loadedLibraries.computeIfAbsent(library, lib -> {\n+                ResourceScopeImpl s = ResourceScopeImpl.createImplicitScope();\n+                holder[0] = s; \/\/ keep the scope alive at least until the outer method returns\n+                s.addOrCleanupIfFail(ResourceScopeImpl.ResourceList.ResourceCleanup.ofRunnable(() -> {\n+                    nativeLibraries.unload(library);\n+                    loadedLibraries.remove(library);\n+                }));\n+                return new WeakReference<>(s);\n+            });\n+            return new LibraryLookupImpl(library, scopeRef.get());\n+        } finally {\n+            Reference.reachabilityFence(holder);\n@@ -111,1 +105,2 @@\n-    static class LibraryLookupImpl implements LibraryLookup {\n+    \/\/Todo: in principle we could expose a scope accessor, so that users could unload libraries at will\n+    static final class LibraryLookupImpl implements LibraryLookup {\n@@ -113,0 +108,1 @@\n+        final MemorySegment librarySegment;\n@@ -114,1 +110,1 @@\n-        LibraryLookupImpl(NativeLibrary library) {\n+        LibraryLookupImpl(NativeLibrary library, ResourceScope scope) {\n@@ -116,0 +112,12 @@\n+            this.librarySegment = MemoryAddress.NULL.asSegment(Long.MAX_VALUE, scope);\n+        }\n+\n+        @Override\n+        public final Optional<MemoryAddress> lookup(String name) {\n+            try {\n+                Objects.requireNonNull(name);\n+                MemoryAddress addr = MemoryAddress.ofLong(library.lookup(name));\n+                return Optional.of(librarySegment.asSlice(addr).address());\n+            } catch (NoSuchMethodException ex) {\n+                return Optional.empty();\n+            }\n@@ -119,1 +127,1 @@\n-        public Optional<Symbol> lookup(String name) {\n+        public final Optional<MemorySegment> lookup(String name, MemoryLayout layout) {\n@@ -122,0 +130,1 @@\n+                Objects.requireNonNull(layout);\n@@ -123,11 +132,4 @@\n-                return Optional.of(new Symbol() { \/\/ inner class - retains a link to enclosing lookup\n-                    @Override\n-                    public String name() {\n-                        return name;\n-                    }\n-\n-                    @Override\n-                    public MemoryAddress address() {\n-                        return addr;\n-                    }\n-                });\n+                if (addr.toRawLongValue() % layout.byteAlignment() != 0) {\n+                    throw new IllegalArgumentException(\"Bad layout alignment constraints: \" + layout.byteAlignment());\n+                }\n+                return Optional.of(librarySegment.asSlice(addr, layout.byteSize()));\n@@ -139,1 +141,1 @@\n-        static LibraryLookup DEFAULT_LOOKUP = new LibraryLookupImpl(NativeLibraries.defaultLibrary);\n+        static LibraryLookup DEFAULT_LOOKUP = new LibraryLookupImpl(NativeLibraries.defaultLibrary, ResourceScopeImpl.GLOBAL);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/LibrariesHelper.java","additions":46,"deletions":44,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.internal.misc.ExtendedMapMode;\n@@ -33,1 +34,0 @@\n-import java.io.FileDescriptor;\n@@ -43,1 +43,0 @@\n-import java.util.Optional;\n@@ -57,1 +56,1 @@\n-    MappedMemorySegmentImpl(long min, UnmapperProxy unmapper, long length, int mask, MemoryScope scope) {\n+    MappedMemorySegmentImpl(long min, UnmapperProxy unmapper, long length, int mask, ResourceScopeImpl scope) {\n@@ -64,1 +63,2 @@\n-        return nioAccess.newMappedByteBuffer(unmapper, min, (int)length, null, this);\n+        return nioAccess.newMappedByteBuffer(unmapper, min, (int)length, null,\n+                scope == ResourceScopeImpl.GLOBAL ? null : this);\n@@ -68,1 +68,1 @@\n-    MappedMemorySegmentImpl dup(long offset, long size, int mask, MemoryScope scope) {\n+    MappedMemorySegmentImpl dup(long offset, long size, int mask, ResourceScopeImpl scope) {\n@@ -80,5 +80,0 @@\n-    @Override\n-    public MappedMemorySegmentImpl withAccessModes(int accessModes) {\n-        return (MappedMemorySegmentImpl)super.withAccessModes(accessModes);\n-    }\n-\n@@ -114,1 +109,1 @@\n-    public static MemorySegment makeMappedSegment(Path path, long bytesOffset, long bytesSize, FileChannel.MapMode mapMode) throws IOException {\n+    public static MemorySegment makeMappedSegment(Path path, long bytesOffset, long bytesSize, FileChannel.MapMode mapMode, ResourceScopeImpl scope) throws IOException {\n@@ -117,0 +112,1 @@\n+        scope.checkValidStateSlow();\n@@ -128,1 +124,1 @@\n-                modes &= ~WRITE;\n+                modes |= READ_ONLY;\n@@ -131,2 +127,1 @@\n-                MemoryScope scope = MemoryScope.createConfined(null, unmapperProxy::unmap, null);\n-                return new MappedMemorySegmentImpl(unmapperProxy.address(), unmapperProxy, bytesSize,\n+                AbstractMemorySegmentImpl segment = new MappedMemorySegmentImpl(unmapperProxy.address(), unmapperProxy, bytesSize,\n@@ -134,0 +129,7 @@\n+                scope.addOrCleanupIfFail(new ResourceScopeImpl.ResourceList.ResourceCleanup() {\n+                    @Override\n+                    public void cleanup() {\n+                        unmapperProxy.unmap();\n+                    }\n+                });\n+                return segment;\n@@ -135,1 +137,1 @@\n-                return new EmptyMappedMemorySegmentImpl(modes);\n+                return new EmptyMappedMemorySegmentImpl(modes, scope);\n@@ -141,1 +143,2 @@\n-        if (mapMode == FileChannel.MapMode.READ_ONLY) {\n+        if (mapMode == FileChannel.MapMode.READ_ONLY ||\n+            mapMode == ExtendedMapMode.READ_ONLY_SYNC) {\n@@ -143,1 +146,3 @@\n-        } else if (mapMode == FileChannel.MapMode.READ_WRITE || mapMode == FileChannel.MapMode.PRIVATE) {\n+        } else if (mapMode == FileChannel.MapMode.READ_WRITE ||\n+                   mapMode == FileChannel.MapMode.PRIVATE ||\n+                   mapMode == ExtendedMapMode.READ_WRITE_SYNC) {\n@@ -152,3 +157,2 @@\n-        public EmptyMappedMemorySegmentImpl(int modes) {\n-            super(0, null, 0, modes,\n-                    MemoryScope.createConfined(null, MemoryScope.DUMMY_CLEANUP_ACTION, null));\n+        public EmptyMappedMemorySegmentImpl(int modes, ResourceScopeImpl scope) {\n+            super(0, null, 0, modes, scope);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/MappedMemorySegmentImpl.java","additions":24,"deletions":20,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -30,0 +30,2 @@\n+import jdk.internal.reflect.CallerSensitive;\n+import jdk.internal.reflect.Reflection;\n@@ -31,0 +33,1 @@\n+import jdk.incubator.foreign.ResourceScope;\n@@ -39,1 +42,1 @@\n-    private final Object base;\n+    private final AbstractMemorySegmentImpl segment;\n@@ -42,2 +45,2 @@\n-    public MemoryAddressImpl(Object base, long offset) {\n-        this.base = base;\n+    public MemoryAddressImpl(AbstractMemorySegmentImpl segment, long offset) {\n+        this.segment = segment;\n@@ -47,0 +50,9 @@\n+    Object base() {\n+        return segment != null ? segment.base() : null;\n+    }\n+\n+    long offset() {\n+        return segment != null ?\n+                segment.min() + offset : offset;\n+    }\n+\n@@ -49,0 +61,11 @@\n+    @Override\n+    public ResourceScope scope() {\n+        return segment != null ?\n+                segment.scope() : ResourceScope.globalScope();\n+    }\n+\n+    @Override\n+    public MemoryAddress addOffset(long offset) {\n+        return new MemoryAddressImpl(segment, this.offset + offset);\n+    }\n+\n@@ -53,2 +76,2 @@\n-        if (segmentImpl.base() != base) {\n-            throw new IllegalArgumentException(\"Invalid segment: \" + segment);\n+        if (segmentImpl.base() != base()) {\n+            throw new IllegalArgumentException(\"Incompatible segment: \" + segment);\n@@ -56,1 +79,1 @@\n-        return offset - segmentImpl.min();\n+        return offset() - segmentImpl.min();\n@@ -60,5 +83,2 @@\n-    public long toRawLongValue() {\n-        if (base != null) {\n-            throw new UnsupportedOperationException(\"Not a native address\");\n-        }\n-        return offset;\n+    public boolean isNative() {\n+        return base() == null;\n@@ -68,2 +88,8 @@\n-    public MemoryAddress addOffset(long bytes) {\n-        return new MemoryAddressImpl(base, offset + bytes);\n+    public long toRawLongValue() {\n+        if (segment != null) {\n+            if (segment.base() != null) {\n+                throw new UnsupportedOperationException(\"Not a native address\");\n+            }\n+            segment.checkValidState();\n+        }\n+        return offset();\n@@ -76,1 +102,1 @@\n-        return Objects.hash(base, offset);\n+        return Objects.hash(base(), offset());\n@@ -83,2 +109,2 @@\n-            return Objects.equals(base, addr.base) &&\n-                    offset == addr.offset;\n+            return Objects.equals(base(), addr.base()) &&\n+                    offset() == addr.offset();\n@@ -92,1 +118,1 @@\n-        return \"MemoryAddress{ base: \" + base + \" offset=0x\" + Long.toHexString(offset) + \" }\";\n+        return \"MemoryAddress{ base: \" + base() + \" offset=0x\" + Long.toHexString(offset()) + \" }\";\n@@ -96,2 +122,11 @@\n-    public MemorySegment asSegmentRestricted(long bytesSize, Runnable cleanupAction, Object attachment) {\n-        Utils.checkRestrictedAccess(\"MemoryAddress.asSegmentRestricted\");\n+    @CallerSensitive\n+    public final MemorySegment asSegment(long bytesSize, ResourceScope scope) {\n+        Reflection.ensureNativeAccess(Reflection.getCallerClass());\n+        return asSegment(bytesSize, null, scope);\n+    }\n+\n+    @Override\n+    @CallerSensitive\n+    public final MemorySegment asSegment(long bytesSize, Runnable cleanupAction, ResourceScope scope) {\n+        Reflection.ensureNativeAccess(Reflection.getCallerClass());\n+        Objects.requireNonNull(scope);\n@@ -101,1 +136,3 @@\n-        return NativeMemorySegmentImpl.makeNativeSegmentUnchecked(this, bytesSize, cleanupAction, attachment);\n+        return NativeMemorySegmentImpl.makeNativeSegmentUnchecked(this, bytesSize,\n+                cleanupAction,\n+                (ResourceScopeImpl) scope);\n@@ -108,0 +145,4 @@\n+    public static MemorySegment ofLongUnchecked(long value, long byteSize, ResourceScopeImpl resourceScope) {\n+        return NativeMemorySegmentImpl.makeNativeSegmentUnchecked(MemoryAddress.ofLong(value), byteSize, null, resourceScope);\n+    }\n+\n@@ -109,1 +150,1 @@\n-        return MemoryAddress.ofLong(value).asSegmentRestricted(byteSize).share();\n+        return NativeMemorySegmentImpl.makeNativeSegmentUnchecked(MemoryAddress.ofLong(value), byteSize, null, ResourceScopeImpl.GLOBAL);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/MemoryAddressImpl.java","additions":62,"deletions":21,"binary":false,"changes":83,"status":"modified"},{"patch":"@@ -1,307 +0,0 @@\n-\/*\n- *  Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.  Oracle designates this\n- *  particular file as subject to the \"Classpath\" exception as provided\n- *  by Oracle in the LICENSE file that accompanied this code.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\n- *\/\n-\n-package jdk.internal.foreign;\n-\n-import jdk.internal.misc.ScopedMemoryAccess;\n-import jdk.internal.ref.PhantomCleanable;\n-import jdk.internal.vm.annotation.ForceInline;\n-\n-import java.lang.invoke.MethodHandles;\n-import java.lang.invoke.VarHandle;\n-import java.lang.ref.Cleaner;\n-import java.lang.ref.Reference;\n-import java.util.Objects;\n-\n-\/**\n- * This class manages the temporal bounds associated with a memory segment as well\n- * as thread confinement. A scope has a liveness bit, which is updated when the scope is closed\n- * (this operation is triggered by {@link AbstractMemorySegmentImpl#close()}). This bit is consulted prior\n- * to memory access (see {@link #checkValidState()}).\n- * There are two kinds of memory scope: confined memory scope and shared memory scope.\n- * A confined memory scope has an associated owner thread that confines some operations to\n- * associated owner thread such as {@link #close()} or {@link #checkValidState()}.\n- * Shared scopes do not feature an owner thread - meaning their operations can be called, in a racy\n- * manner, by multiple threads. To guarantee temporal safety in the presence of concurrent thread,\n- * shared scopes use a more sophisticated synchronization mechanism, which guarantees that no concurrent\n- * access is possible when a scope is being closed (see {@link jdk.internal.misc.ScopedMemoryAccess}).\n- *\/\n-abstract class MemoryScope implements ScopedMemoryAccess.Scope {\n-\n-    static final Runnable DUMMY_CLEANUP_ACTION = () -> { };\n-\n-    private MemoryScope(Object ref, Runnable cleanupAction, Cleaner cleaner) {\n-        Objects.requireNonNull(cleanupAction);\n-        this.ref = ref;\n-        this.cleanupAction = cleanupAction;\n-        this.scopeCleanable = cleaner != null ?\n-                new ScopeCleanable(this, cleaner, cleanupAction) :\n-                null;\n-    }\n-\n-    \/**\n-     * Creates a confined memory scope with given attachment and cleanup action. The returned scope\n-     * is assumed to be confined on the current thread.\n-     * @param ref           an optional reference to an instance that needs to be kept reachable\n-     * @param cleanupAction a cleanup action to be executed when returned scope is closed\n-     * @return a confined memory scope\n-     *\/\n-    static MemoryScope createConfined(Object ref, Runnable cleanupAction, Cleaner cleaner) {\n-        return new ConfinedScope(Thread.currentThread(), ref, cleanupAction, cleaner);\n-    }\n-\n-    \/**\n-     * Creates a shared memory scope with given attachment and cleanup action.\n-     * @param ref           an optional reference to an instance that needs to be kept reachable\n-     * @param cleanupAction a cleanup action to be executed when returned scope is closed\n-     * @return a shared memory scope\n-     *\/\n-    static MemoryScope createShared(Object ref, Runnable cleanupAction, Cleaner cleaner) {\n-        return new SharedScope(ref, cleanupAction, cleaner);\n-    }\n-\n-    protected final Object ref;\n-    protected final ScopeCleanable scopeCleanable;\n-    protected final Runnable cleanupAction;\n-\n-    \/**\n-     * Closes this scope, executing any cleanup action (where provided).\n-     * @throws IllegalStateException if this scope is already closed or if this is\n-     * a confined scope and this method is called outside of the owner thread.\n-     *\/\n-    final void close() {\n-        try {\n-            justClose();\n-            cleanupAction.run();\n-            if (scopeCleanable != null) {\n-                scopeCleanable.clear();\n-            }\n-        } finally {\n-            Reference.reachabilityFence(this);\n-        }\n-    }\n-\n-    abstract void justClose();\n-\n-    \/**\n-     * Duplicates this scope with given new \"owner\" thread and {@link #close() closes} it.\n-     * @param newOwner new owner thread of the returned memory scope\n-     * @return a new confined scope, which is a duplicate of this scope, but with a new owner thread.\n-     * @throws IllegalStateException if this scope is already closed or if this is\n-     * a confined scope and this method is called outside of the owner thread.\n-     *\/\n-    final MemoryScope confineTo(Thread newOwner) {\n-        try {\n-            justClose();\n-            if (scopeCleanable != null) {\n-                scopeCleanable.clear();\n-            }\n-            return new ConfinedScope(newOwner, ref, cleanupAction, scopeCleanable != null ?\n-                    scopeCleanable.cleaner : null);\n-        } finally {\n-            Reference.reachabilityFence(this);\n-        }\n-    }\n-\n-    \/**\n-     * Duplicates this scope with given new \"owner\" thread and {@link #close() closes} it.\n-     * @return a new shared scope, which is a duplicate of this scope.\n-     * @throws IllegalStateException if this scope is already closed or if this is\n-     * a confined scope and this method is called outside of the owner thread,\n-     * or if this is already a shared scope.\n-     *\/\n-    final MemoryScope share() {\n-        try {\n-            justClose();\n-            if (scopeCleanable != null) {\n-                scopeCleanable.clear();\n-            }\n-            return new SharedScope(ref, cleanupAction, scopeCleanable != null ?\n-                    scopeCleanable.cleaner : null);\n-        } finally {\n-            Reference.reachabilityFence(this);\n-        }\n-    }\n-\n-    final MemoryScope cleanable(Cleaner cleaner) {\n-        if (scopeCleanable != null) {\n-            throw new IllegalStateException(\"Already registered with a cleaner\");\n-        }\n-        try {\n-            justClose();\n-            return ownerThread() == null ?\n-                    new SharedScope(ref, cleanupAction, cleaner) :\n-                    new ConfinedScope(ownerThread(), ref, cleanupAction, cleaner);\n-        } finally {\n-            Reference.reachabilityFence(this);\n-        }\n-    }\n-\n-    \/**\n-     * Returns \"owner\" thread of this scope.\n-     * @return owner thread (or null for a shared scope)\n-     *\/\n-    public abstract Thread ownerThread();\n-\n-    \/**\n-     * Returns true, if this scope is still alive. This method may be called in any thread.\n-     * @return {@code true} if this scope is not closed yet.\n-     *\/\n-    public abstract boolean isAlive();\n-\n-    \/**\n-     * Checks that this scope is still alive (see {@link #isAlive()}).\n-     * @throws IllegalStateException if this scope is already closed or if this is\n-     * a confined scope and this method is called outside of the owner thread.\n-     *\/\n-    public abstract void checkValidState();\n-\n-    @Override\n-    protected Object clone() throws CloneNotSupportedException {\n-        throw new CloneNotSupportedException();\n-    }\n-\n-    \/**\n-     * A confined scope, which features an owner thread. The liveness check features an additional\n-     * confinement check - that is, calling any operation on this scope from a thread other than the\n-     * owner thread will result in an exception. Because of this restriction, checking the liveness bit\n-     * can be performed in plain mode (see {@link #checkAliveRaw(MemoryScope)}).\n-     *\/\n-    static class ConfinedScope extends MemoryScope {\n-\n-        private boolean closed; \/\/ = false\n-        final Thread owner;\n-\n-        public ConfinedScope(Thread owner, Object ref, Runnable cleanupAction, Cleaner cleaner) {\n-            super(ref, cleanupAction, cleaner);\n-            this.owner = owner;\n-        }\n-\n-        @ForceInline\n-        public final void checkValidState() {\n-            if (owner != Thread.currentThread()) {\n-                throw new IllegalStateException(\"Attempted access outside owning thread\");\n-            }\n-            if (closed) {\n-                throw ScopedAccessError.INSTANCE;\n-            }\n-        }\n-\n-        @Override\n-        public boolean isAlive() {\n-            return !closed;\n-        }\n-\n-        void justClose() {\n-            checkValidState();\n-            closed = true;\n-        }\n-\n-        @Override\n-        public Thread ownerThread() {\n-            return owner;\n-        }\n-    }\n-\n-    \/**\n-     * A shared scope, which can be shared across multiple threads. Closing a shared scope has to ensure that\n-     * (i) only one thread can successfully close a scope (e.g. in a close vs. close race) and that\n-     * (ii) no other thread is accessing the memory associated with this scope while the segment is being\n-     * closed. To ensure the former condition, a CAS is performed on the liveness bit. Ensuring the latter\n-     * is trickier, and require a complex synchronization protocol (see {@link jdk.internal.misc.ScopedMemoryAccess}).\n-     * Since it is the responsibility of the closing thread to make sure that no concurrent access is possible,\n-     * checking the liveness bit upon access can be performed in plain mode (see {@link #checkAliveRaw(MemoryScope)}),\n-     * as in the confined case.\n-     *\/\n-    static class SharedScope extends MemoryScope {\n-\n-        static ScopedMemoryAccess SCOPED_MEMORY_ACCESS = ScopedMemoryAccess.getScopedMemoryAccess();\n-\n-        final static int ALIVE = 0;\n-        final static int CLOSING = 1;\n-        final static int CLOSED = 2;\n-\n-        int state = ALIVE;\n-\n-        private static final VarHandle STATE;\n-\n-        static {\n-            try {\n-                STATE = MethodHandles.lookup().findVarHandle(SharedScope.class, \"state\", int.class);\n-            } catch (Throwable ex) {\n-                throw new ExceptionInInitializerError(ex);\n-            }\n-        }\n-\n-        SharedScope(Object ref, Runnable cleanupAction, Cleaner cleaner) {\n-            super(ref, cleanupAction, cleaner);\n-        }\n-\n-        @Override\n-        public Thread ownerThread() {\n-            return null;\n-        }\n-\n-        @Override\n-        public void checkValidState() {\n-            if (state != ALIVE) {\n-                throw ScopedAccessError.INSTANCE;\n-            }\n-        }\n-\n-        void justClose() {\n-            if (!STATE.compareAndSet(this, ALIVE, CLOSING)) {\n-                throw new IllegalStateException(\"Already closed\");\n-            }\n-            boolean success = SCOPED_MEMORY_ACCESS.closeScope(this);\n-            STATE.setVolatile(this, success ? CLOSED : ALIVE);\n-            if (!success) {\n-                throw new IllegalStateException(\"Cannot close while another thread is accessing the segment\");\n-            }\n-        }\n-\n-        @Override\n-        public boolean isAlive() {\n-            return (int)STATE.getVolatile(this) != CLOSED;\n-        }\n-    }\n-\n-    static class ScopeCleanable extends PhantomCleanable<MemoryScope> {\n-        final Cleaner cleaner;\n-        final Runnable cleanupAction;\n-\n-        public ScopeCleanable(MemoryScope referent, Cleaner cleaner, Runnable cleanupAction) {\n-            super(referent, cleaner);\n-            this.cleaner = cleaner;\n-            this.cleanupAction = cleanupAction;\n-        }\n-\n-        @Override\n-        protected void performCleanup() {\n-            cleanupAction.run();\n-        }\n-    }\n-}\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/MemoryScope.java","additions":0,"deletions":307,"binary":false,"changes":307,"status":"deleted"},{"patch":"@@ -31,0 +31,2 @@\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.SegmentAllocator;\n@@ -44,3 +46,1 @@\n-    public static final MemorySegment EVERYTHING = makeNativeSegmentUnchecked(MemoryAddress.NULL, Long.MAX_VALUE, MemoryScope.DUMMY_CLEANUP_ACTION, null)\n-            .share()\n-            .withAccessModes(READ | WRITE);\n+    public static final MemorySegment EVERYTHING = makeNativeSegmentUnchecked(MemoryAddress.NULL, Long.MAX_VALUE, null, ResourceScopeImpl.GLOBAL);\n@@ -50,0 +50,2 @@\n+    public static final SegmentAllocator IMPLICIT_ALLOCATOR = (size, align) -> MemorySegment.allocateNative(size, align, ResourceScope.newImplicitScope());\n+\n@@ -52,1 +54,1 @@\n-    private final static long MAX_MALLOC_ALIGN = Unsafe.ADDRESS_SIZE == 4 ? 8 : 16;\n+    private static final long MAX_MALLOC_ALIGN = Unsafe.ADDRESS_SIZE == 4 ? 8 : 16;\n@@ -59,1 +61,1 @@\n-    NativeMemorySegmentImpl(long min, long length, int mask, MemoryScope scope) {\n+    NativeMemorySegmentImpl(long min, long length, int mask, ResourceScopeImpl scope) {\n@@ -65,1 +67,1 @@\n-    NativeMemorySegmentImpl dup(long offset, long size, int mask, MemoryScope scope) {\n+    NativeMemorySegmentImpl dup(long offset, long size, int mask, ResourceScopeImpl scope) {\n@@ -71,1 +73,7 @@\n-        return nioAccess.newDirectByteBuffer(min(), (int) this.length, null, this);\n+        return nioAccess.newDirectByteBuffer(min(), (int) this.length, null,\n+                scope == ResourceScopeImpl.GLOBAL ? null : this);\n+    }\n+\n+    @Override\n+    public boolean isNative() {\n+        return true;\n@@ -86,1 +94,2 @@\n-    public static MemorySegment makeNativeSegment(long bytesSize, long alignmentBytes) {\n+    public static MemorySegment makeNativeSegment(long bytesSize, long alignmentBytes, ResourceScopeImpl scope) {\n+        scope.checkValidStateSlow();\n@@ -101,1 +110,5 @@\n-        MemoryScope scope = MemoryScope.createConfined(null, () -> {\n+        AbstractMemorySegmentImpl segment = new NativeMemorySegmentImpl(buf, alignedSize,\n+                defaultAccessModes(alignedSize), scope);\n+        scope.addOrCleanupIfFail(new ResourceScopeImpl.ResourceList.ResourceCleanup() {\n+            @Override\n+            public void cleanup() {\n@@ -104,3 +117,2 @@\n-            }, null);\n-        MemorySegment segment = new NativeMemorySegmentImpl(buf, alignedSize,\n-                defaultAccessModes(alignedSize), scope);\n+            }\n+        });\n@@ -114,3 +126,7 @@\n-    public static MemorySegment makeNativeSegmentUnchecked(MemoryAddress min, long bytesSize, Runnable cleanupAction, Object ref) {\n-        return new NativeMemorySegmentImpl(min.toRawLongValue(), bytesSize, defaultAccessModes(bytesSize),\n-                MemoryScope.createConfined(ref, cleanupAction == null ? MemoryScope.DUMMY_CLEANUP_ACTION : cleanupAction, null));\n+    public static MemorySegment makeNativeSegmentUnchecked(MemoryAddress min, long bytesSize, Runnable cleanupAction, ResourceScopeImpl scope) {\n+        scope.checkValidStateSlow();\n+        AbstractMemorySegmentImpl segment = new NativeMemorySegmentImpl(min.toRawLongValue(), bytesSize, defaultAccessModes(bytesSize), scope);\n+        if (cleanupAction != null) {\n+            scope.addCloseAction(cleanupAction);\n+        }\n+        return segment;\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/NativeMemorySegmentImpl.java","additions":31,"deletions":15,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -35,1 +35,0 @@\n-import static jdk.incubator.foreign.MemoryLayouts.ADDRESS;\n@@ -54,1 +53,1 @@\n-        return MemoryLayout.ofValueBits(bitSize, order)\n+        return MemoryLayout.valueLayout(bitSize, order)\n@@ -59,1 +58,1 @@\n-        return MemoryLayout.ofValueBits(bitSize, order)\n+        return MemoryLayout.valueLayout(bitSize, order)\n@@ -64,1 +63,1 @@\n-        return MemoryLayout.ofValueBits(bitSize, order)\n+        return MemoryLayout.valueLayout(bitSize, order)\n@@ -69,1 +68,1 @@\n-        return MemoryLayout.ofValueBits(bitSize, order)\n+        return MemoryLayout.valueLayout(bitSize, order)\n@@ -74,1 +73,1 @@\n-        return MemoryLayout.ofValueBits(bitSize, order)\n+        return MemoryLayout.valueLayout(bitSize, order)\n@@ -79,1 +78,1 @@\n-        return MemoryLayout.ofValueBits(bitSize, order)\n+        return MemoryLayout.valueLayout(bitSize, order)\n@@ -84,1 +83,1 @@\n-        return MemoryLayout.ofValueBits(bitSize, order)\n+        return MemoryLayout.valueLayout(bitSize, order)\n@@ -89,1 +88,1 @@\n-        return MemoryLayout.ofValueBits(bitSize, order)\n+        return MemoryLayout.valueLayout(bitSize, order)\n@@ -165,1 +164,1 @@\n-        public final static String VARARGS_ATTRIBUTE_NAME = \"abi\/windows\/varargs\";\n+        public static final String VARARGS_ATTRIBUTE_NAME = \"abi\/windows\/varargs\";\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/PlatformLayouts.java","additions":9,"deletions":10,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -0,0 +1,322 @@\n+\/*\n+ *  Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+package jdk.internal.foreign;\n+\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.SegmentAllocator;\n+import jdk.internal.misc.ScopedMemoryAccess;\n+import jdk.internal.ref.CleanerFactory;\n+\n+import java.lang.ref.Cleaner;\n+import java.lang.ref.Reference;\n+import java.util.Objects;\n+\n+\/**\n+ * This class manages the temporal bounds associated with a memory segment as well\n+ * as thread confinement. A scope has a liveness bit, which is updated when the scope is closed\n+ * (this operation is triggered by {@link ResourceScope#close()}). This bit is consulted prior\n+ * to memory access (see {@link #checkValidState()}).\n+ * There are two kinds of memory scope: confined memory scope and shared memory scope.\n+ * A confined memory scope has an associated owner thread that confines some operations to\n+ * associated owner thread such as {@link #close()} or {@link #checkValidState()}.\n+ * Shared scopes do not feature an owner thread - meaning their operations can be called, in a racy\n+ * manner, by multiple threads. To guarantee temporal safety in the presence of concurrent thread,\n+ * shared scopes use a more sophisticated synchronization mechanism, which guarantees that no concurrent\n+ * access is possible when a scope is being closed (see {@link jdk.internal.misc.ScopedMemoryAccess}).\n+ *\/\n+public abstract non-sealed class ResourceScopeImpl implements ResourceScope, ScopedMemoryAccess.Scope, SegmentAllocator {\n+\n+    final ResourceList resourceList;\n+\n+    @Override\n+    public void addCloseAction(Runnable runnable) {\n+        Objects.requireNonNull(runnable);\n+        addInternal(ResourceList.ResourceCleanup.ofRunnable(runnable));\n+    }\n+\n+    @Override\n+    public boolean isImplicit() {\n+        return false;\n+    }\n+\n+    \/**\n+     * Add a cleanup action. If a failure occurred (because of a add vs. close race), call the cleanup action.\n+     * This semantics is useful when allocating new memory segments, since we first do a malloc\/mmap and _then_\n+     * we register the cleanup (free\/munmap) against the scope; so, if registration fails, we still have to\n+     * cleanup memory. From the perspective of the client, such a failure would manifest as a factory\n+     * returning a segment that is already \"closed\" - which is always possible anyway (e.g. if the scope\n+     * is closed _after_ the cleanup for the segment is registered but _before_ the factory returns the\n+     * new segment to the client). For this reason, it's not worth adding extra complexity to the segment\n+     * initialization logic here - and using an optimistic logic works well in practice.\n+     *\/\n+    public void addOrCleanupIfFail(ResourceList.ResourceCleanup resource) {\n+        try {\n+            addInternal(resource);\n+        } catch (Throwable ex) {\n+            resource.cleanup();\n+        }\n+    }\n+\n+    void addInternal(ResourceList.ResourceCleanup resource) {\n+        try {\n+            checkValidStateSlow();\n+            resourceList.add(resource);\n+        } catch (ScopedMemoryAccess.Scope.ScopedAccessError err) {\n+            throw new IllegalStateException(\"Already closed\");\n+        }\n+    }\n+\n+    protected ResourceScopeImpl(Cleaner cleaner, ResourceList resourceList) {\n+        this.resourceList = resourceList;\n+        if (cleaner != null) {\n+            cleaner.register(this, resourceList);\n+        }\n+    }\n+\n+    public static ResourceScopeImpl createImplicitScope() {\n+        return new ImplicitScopeImpl(CleanerFactory.cleaner());\n+    }\n+\n+    public static ResourceScopeImpl createConfined(Thread thread, Cleaner cleaner) {\n+        return new ConfinedScope(thread, cleaner);\n+    }\n+\n+    \/**\n+     * Creates a confined memory scope with given attachment and cleanup action. The returned scope\n+     * is assumed to be confined on the current thread.\n+     * @return a confined memory scope\n+     *\/\n+    public static ResourceScopeImpl createConfined(Cleaner cleaner) {\n+        return new ConfinedScope(Thread.currentThread(), cleaner);\n+    }\n+\n+    \/**\n+     * Creates a shared memory scope with given attachment and cleanup action.\n+     * @return a shared memory scope\n+     *\/\n+    public static ResourceScopeImpl createShared(Cleaner cleaner) {\n+        return new SharedScope(cleaner);\n+    }\n+\n+    private final void release0(HandleImpl handle) {\n+        try {\n+            Objects.requireNonNull(handle);\n+            if (handle.scope() != this) {\n+                throw new IllegalArgumentException(\"Cannot release an handle acquired from another scope\");\n+            }\n+            handle.release();\n+        } finally {\n+            Reference.reachabilityFence(this);\n+        }\n+    }\n+\n+    @Override\n+    public final void release(ResourceScope.Handle handle) {\n+        release0((HandleImpl)handle);\n+    }\n+\n+    @Override\n+    public final void release(ScopedMemoryAccess.Scope.Handle handle) {\n+        release0((HandleImpl)handle);\n+    }\n+\n+    @Override\n+    public abstract HandleImpl acquire();\n+\n+    \/**\n+     * Internal interface used to implement resource scope handles.\n+     *\/\n+    public non-sealed interface HandleImpl extends ResourceScope.Handle, ScopedMemoryAccess.Scope.Handle {\n+\n+        @Override\n+        ResourceScopeImpl scope();\n+\n+        void release();\n+    }\n+\n+    \/**\n+     * Closes this scope, executing any cleanup action (where provided).\n+     * @throws IllegalStateException if this scope is already closed or if this is\n+     * a confined scope and this method is called outside of the owner thread.\n+     *\/\n+    public void close() {\n+        try {\n+            justClose();\n+            resourceList.cleanup();\n+        } finally {\n+            Reference.reachabilityFence(this);\n+        }\n+    }\n+\n+    abstract void justClose();\n+\n+    \/**\n+     * Returns \"owner\" thread of this scope.\n+     * @return owner thread (or null for a shared scope)\n+     *\/\n+    public abstract Thread ownerThread();\n+\n+    \/**\n+     * Returns true, if this scope is still alive. This method may be called in any thread.\n+     * @return {@code true} if this scope is not closed yet.\n+     *\/\n+    public abstract boolean isAlive();\n+\n+\n+    \/**\n+     * This is a faster version of {@link #checkValidStateSlow()}, which is called upon memory access, and which\n+     * relies on invariants associated with the memory scope implementations (typically, volatile access\n+     * to the closed state bit is replaced with plain access, and ownership check is removed where not needed.\n+     * Should be used with care.\n+     *\/\n+    public abstract void checkValidState();\n+\n+    \/**\n+     * Checks that this scope is still alive (see {@link #isAlive()}).\n+     * @throws IllegalStateException if this scope is already closed or if this is\n+     * a confined scope and this method is called outside of the owner thread.\n+     *\/\n+    public final void checkValidStateSlow() {\n+        if (ownerThread() != null && Thread.currentThread() != ownerThread()) {\n+            throw new IllegalStateException(\"Attempted access outside owning thread\");\n+        } else if (!isAlive()) {\n+            throw new IllegalStateException(\"Already closed\");\n+        }\n+    }\n+\n+    @Override\n+    protected Object clone() throws CloneNotSupportedException {\n+        throw new CloneNotSupportedException();\n+    }\n+\n+    \/**\n+     * Allocates a segment using this scope. Used by {@link SegmentAllocator#ofScope(ResourceScope)}.\n+     *\/\n+    @Override\n+    public MemorySegment allocate(long bytesSize, long bytesAlignment) {\n+        return MemorySegment.allocateNative(bytesSize, bytesAlignment, this);\n+    }\n+\n+    \/**\n+     * A non-closeable, shared scope. Similar to a shared scope, but its {@link #close()} method throws unconditionally.\n+     * In addition, non-closeable scopes feature a much simpler scheme for generating resource scope handles, where\n+     * the scope itself also acts as a resource scope handle and is returned by {@link #acquire()}.\n+     *\/\n+    static class ImplicitScopeImpl extends SharedScope implements HandleImpl {\n+\n+        public ImplicitScopeImpl(Cleaner cleaner) {\n+            super(cleaner);\n+        }\n+\n+        @Override\n+        public HandleImpl acquire() {\n+            return this;\n+        }\n+\n+        @Override\n+        public boolean isImplicit() {\n+            return true;\n+        }\n+\n+        @Override\n+        public void close() {\n+            throw new UnsupportedOperationException(\"Scope cannot be closed\");\n+        }\n+\n+        @Override\n+        public void release() {\n+            \/\/ do nothing\n+        }\n+\n+        @Override\n+        public ResourceScopeImpl scope() {\n+            return this;\n+        }\n+    }\n+\n+    \/**\n+     * The global, always alive, non-closeable, shared scope. This is like a {@link ImplicitScopeImpl non-closeable scope},\n+     * except that the operation which adds new resources to the global scope does nothing: as the scope can never\n+     * become not-alive, there is nothing to track.\n+     *\/\n+    public static final ResourceScopeImpl GLOBAL = new ImplicitScopeImpl( null) {\n+        @Override\n+        void addInternal(ResourceList.ResourceCleanup resource) {\n+            \/\/ do nothing\n+        }\n+    };\n+\n+    \/**\n+     * A list of all cleanup actions associated with a resource scope. Cleanup actions are modelled as instances\n+     * of the {@link ResourceCleanup} class, and, together, form a linked list. Depending on whether a scope\n+     * is shared or confined, different implementations of this class will be used, see {@link ConfinedScope.ConfinedResourceList}\n+     * and {@link SharedScope.SharedResourceList}.\n+     *\/\n+    public abstract static class ResourceList implements Runnable {\n+        ResourceCleanup fst;\n+\n+        abstract void add(ResourceCleanup cleanup);\n+\n+        abstract void cleanup();\n+\n+        public final void run() {\n+            cleanup(); \/\/ cleaner interop\n+        }\n+\n+        static void cleanup(ResourceCleanup first) {\n+            ResourceCleanup current = first;\n+            while (current != null) {\n+                current.cleanup();\n+                current = current.next;\n+            }\n+        }\n+\n+        public static abstract class ResourceCleanup {\n+            ResourceCleanup next;\n+\n+            public abstract void cleanup();\n+\n+            static final ResourceCleanup CLOSED_LIST = new ResourceCleanup() {\n+                @Override\n+                public void cleanup() {\n+                    throw new IllegalStateException(\"This resource list has already been closed!\");\n+                }\n+            };\n+\n+            static ResourceCleanup ofRunnable(Runnable cleanupAction) {\n+                return new ResourceCleanup() {\n+                    @Override\n+                    public void cleanup() {\n+                        cleanupAction.run();\n+                    }\n+                };\n+            }\n+        }\n+\n+    }\n+}\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/ResourceScopeImpl.java","additions":322,"deletions":0,"binary":false,"changes":322,"status":"added"},{"patch":"@@ -0,0 +1,196 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.foreign;\n+\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.internal.misc.ScopedMemoryAccess;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.VarHandle;\n+import java.lang.ref.Cleaner;\n+import java.lang.ref.Reference;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+\/**\n+ * A shared scope, which can be shared across multiple threads. Closing a shared scope has to ensure that\n+ * (i) only one thread can successfully close a scope (e.g. in a close vs. close race) and that\n+ * (ii) no other thread is accessing the memory associated with this scope while the segment is being\n+ * closed. To ensure the former condition, a CAS is performed on the liveness bit. Ensuring the latter\n+ * is trickier, and require a complex synchronization protocol (see {@link jdk.internal.misc.ScopedMemoryAccess}).\n+ * Since it is the responsibility of the closing thread to make sure that no concurrent access is possible,\n+ * checking the liveness bit upon access can be performed in plain mode, as in the confined case.\n+ *\/\n+class SharedScope extends ResourceScopeImpl {\n+\n+    private static final ScopedMemoryAccess SCOPED_MEMORY_ACCESS = ScopedMemoryAccess.getScopedMemoryAccess();\n+\n+    private static final int ALIVE = 0;\n+    private static final int CLOSING = -1;\n+    private static final int CLOSED = -2;\n+    private static final int MAX_FORKS = Integer.MAX_VALUE;\n+\n+    private int state = ALIVE;\n+\n+    private static final VarHandle STATE;\n+\n+    static {\n+        try {\n+            STATE = MethodHandles.lookup().findVarHandle(jdk.internal.foreign.SharedScope.class, \"state\", int.class);\n+        } catch (Throwable ex) {\n+            throw new ExceptionInInitializerError(ex);\n+        }\n+    }\n+\n+    SharedScope(Cleaner cleaner) {\n+        super(cleaner, new SharedResourceList());\n+    }\n+\n+    @Override\n+    public Thread ownerThread() {\n+        return null;\n+    }\n+\n+    @Override\n+    public void checkValidState() {\n+        if (state < ALIVE) {\n+            throw ScopedAccessError.INSTANCE;\n+        }\n+    }\n+\n+    @Override\n+    public HandleImpl acquire() {\n+        int value;\n+        do {\n+            value = (int) STATE.getVolatile(this);\n+            if (value < ALIVE) {\n+                \/\/segment is not alive!\n+                throw new IllegalStateException(\"Already closed\");\n+            } else if (value == MAX_FORKS) {\n+                \/\/overflow\n+                throw new IllegalStateException(\"Segment acquire limit exceeded\");\n+            }\n+        } while (!STATE.compareAndSet(this, value, value + 1));\n+        return new SharedHandle();\n+    }\n+\n+    void justClose() {\n+        int prevState = (int) STATE.compareAndExchange(this, ALIVE, CLOSING);\n+        if (prevState < 0) {\n+            throw new IllegalStateException(\"Already closed\");\n+        } else if (prevState != ALIVE) {\n+            throw new IllegalStateException(\"Scope is acquired by \" + prevState + \" locks\");\n+        }\n+        boolean success = SCOPED_MEMORY_ACCESS.closeScope(this);\n+        STATE.setVolatile(this, success ? CLOSED : ALIVE);\n+        if (!success) {\n+            throw new IllegalStateException(\"Cannot close while another thread is accessing the segment\");\n+        }\n+    }\n+\n+    @Override\n+    public boolean isAlive() {\n+        return (int) STATE.getVolatile(this) != CLOSED;\n+    }\n+\n+    \/**\n+     * A shared resource list; this implementation has to handle add vs. add races, as well as add vs. cleanup races.\n+     *\/\n+    static class SharedResourceList extends ResourceList {\n+\n+        static final VarHandle FST;\n+\n+        static {\n+            try {\n+                FST = MethodHandles.lookup().findVarHandle(ResourceList.class, \"fst\", ResourceCleanup.class);\n+            } catch (Throwable ex) {\n+                throw new ExceptionInInitializerError();\n+            }\n+        }\n+\n+        @Override\n+        void add(ResourceCleanup cleanup) {\n+            while (true) {\n+                ResourceCleanup prev = (ResourceCleanup) FST.getAcquire(this);\n+                cleanup.next = prev;\n+                ResourceCleanup newSegment = (ResourceCleanup) FST.compareAndExchangeRelease(this, prev, cleanup);\n+                if (newSegment == ResourceCleanup.CLOSED_LIST) {\n+                    \/\/ too late\n+                    throw new IllegalStateException(\"Already closed\");\n+                } else if (newSegment == prev) {\n+                    return; \/\/victory\n+                }\n+                \/\/ keep trying\n+            }\n+        }\n+\n+        void cleanup() {\n+            \/\/ At this point we are only interested about add vs. close races - not close vs. close\n+            \/\/ (because MemoryScope::justClose ensured that this thread won the race to close the scope).\n+            \/\/ So, the only \"bad\" thing that could happen is that some other thread adds to this list\n+            \/\/ while we're closing it.\n+            if (FST.getAcquire(this) != ResourceCleanup.CLOSED_LIST) {\n+                \/\/ok now we're really closing down\n+                ResourceCleanup prev = null;\n+                while (true) {\n+                    prev = (ResourceCleanup) FST.getAcquire(this);\n+                    \/\/ no need to check for DUMMY, since only one thread can get here!\n+                    if (FST.weakCompareAndSetRelease(this, prev, ResourceCleanup.CLOSED_LIST)) {\n+                        break;\n+                    }\n+                }\n+                cleanup(prev);\n+            } else {\n+                throw new IllegalStateException(\"Attempt to cleanup an already closed resource list\");\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * A shared resource scope handle; this implementation has to handle close vs. close races.\n+     *\/\n+    class SharedHandle implements HandleImpl {\n+        final AtomicBoolean released = new AtomicBoolean(false);\n+\n+        @Override\n+        public ResourceScopeImpl scope() {\n+            return SharedScope.this;\n+        }\n+\n+        @Override\n+        public void release() {\n+            if (released.compareAndSet(false, true)) {\n+                int value;\n+                do {\n+                    value = (int) STATE.getVolatile(jdk.internal.foreign.SharedScope.this);\n+                    if (value <= ALIVE) {\n+                        \/\/cannot get here - we can't close segment twice\n+                        throw new IllegalStateException(\"Already closed\");\n+                    }\n+                } while (!STATE.compareAndSet(jdk.internal.foreign.SharedScope.this, value, value - 1));\n+            }\n+        }\n+    }\n+}\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/SharedScope.java","additions":196,"deletions":0,"binary":false,"changes":196,"status":"added"},{"patch":"@@ -47,1 +47,0 @@\n-\n@@ -52,3 +51,0 @@\n-    private static final String foreignRestrictedAccess = Optional.ofNullable(VM.getSavedProperty(\"foreign.restricted\"))\n-            .orElse(\"deny\");\n-\n@@ -110,21 +106,0 @@\n-    public static void checkRestrictedAccess(String method) {\n-        switch (foreignRestrictedAccess) {\n-            case \"deny\" -> throwIllegalAccessError(foreignRestrictedAccess, method);\n-            case \"warn\" -> System.err.println(\"WARNING: Accessing restricted foreign method: \" + method);\n-            case \"debug\" -> {\n-                StringBuilder sb = new StringBuilder(\"DEBUG: restricted foreign method: \\\" + method\");\n-                StackWalker.getInstance().forEach(f -> sb.append(System.lineSeparator())\n-                        .append(\"\\tat \")\n-                        .append(f));\n-                System.err.println(sb.toString());\n-            }\n-            case \"permit\" -> {}\n-            default -> throwIllegalAccessError(foreignRestrictedAccess, method);\n-        }\n-    }\n-\n-    private static void throwIllegalAccessError(String value, String method) {\n-        throw new IllegalAccessError(\"Illegal access to restricted foreign method: \" + method +\n-                \" ; system property 'foreign.restricted' is set to '\" + value + \"'\");\n-    }\n-\n@@ -153,1 +128,0 @@\n-\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/Utils.java","additions":0,"deletions":26,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,2 @@\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.SegmentAllocator;\n@@ -32,0 +34,1 @@\n+import jdk.internal.foreign.ResourceScopeImpl;\n@@ -35,1 +38,0 @@\n-import java.lang.invoke.MethodType;\n@@ -47,1 +49,0 @@\n-import static java.lang.invoke.MethodHandles.permuteArguments;\n@@ -221,1 +222,1 @@\n-                    methodType(MemorySegment.class, MemorySegment.class, long.class, long.class, SharedUtils.Allocator.class));\n+                    methodType(MemorySegment.class, MemorySegment.class, long.class, long.class, Context.class));\n@@ -223,1 +224,1 @@\n-                    methodType(MemorySegment.class, long.class, long.class, SharedUtils.Allocator.class));\n+                    methodType(MemorySegment.class, long.class, long.class, Context.class));\n@@ -225,1 +226,1 @@\n-                    methodType(MemorySegment.class, MemoryAddress.class, long.class));\n+                    methodType(MemorySegment.class, MemoryAddress.class, long.class, Context.class));\n@@ -231,0 +232,83 @@\n+    \/**\n+     * A binding context is used as an helper to carry out evaluation of certain bindings; for instance,\n+     * it helps {@link Allocate} bindings, by providing the {@link SegmentAllocator} that should be used for\n+     * the allocation operation, or {@link ToSegment} bindings, by providing the {@link ResourceScope} that\n+     * should be used to create an unsafe struct from a memory address.\n+     *\/\n+    public static class Context implements AutoCloseable {\n+        private final SegmentAllocator allocator;\n+        private final ResourceScope scope;\n+\n+        private Context(SegmentAllocator allocator, ResourceScope scope) {\n+            this.allocator = allocator;\n+            this.scope = scope;\n+        }\n+\n+        public SegmentAllocator allocator() {\n+            return allocator;\n+        }\n+\n+        public ResourceScope scope() {\n+            return scope;\n+        }\n+\n+        @Override\n+        public void close() {\n+            scope().close();\n+        }\n+\n+        \/**\n+         * Create a binding context from given native scope.\n+         *\/\n+        public static Context ofBoundedAllocator(long size) {\n+            ResourceScope scope = ResourceScope.newConfinedScope();\n+            return new Context(SegmentAllocator.arenaAllocator(size, scope), scope);\n+        }\n+\n+        \/**\n+         * Create a binding context from given segment allocator. The resulting context will throw when\n+         * the context's scope is accessed.\n+         *\/\n+        public static Context ofAllocator(SegmentAllocator allocator) {\n+            return new Context(allocator, null) {\n+                @Override\n+                public ResourceScope scope() {\n+                    throw new UnsupportedOperationException();\n+                }\n+            };\n+        }\n+\n+        \/**\n+         * Create a binding context from given scope. The resulting context will throw when\n+         * the context's allocator is accessed.\n+         *\/\n+        public static Context ofScope() {\n+            ResourceScope scope = ResourceScope.newConfinedScope();\n+            return new Context(null, scope) {\n+                @Override\n+                public SegmentAllocator allocator() { throw new UnsupportedOperationException(); }\n+            };\n+        }\n+\n+        \/**\n+         * Dummy binding context. Throws exceptions when attempting to access scope, return a throwing allocator, and has\n+         * an idempotent {@link #close()}.\n+         *\/\n+        public static final Context DUMMY = new Context(null, null) {\n+            @Override\n+            public SegmentAllocator allocator() {\n+                return SharedUtils.THROWING_ALLOCATOR;\n+            }\n+\n+            @Override\n+            public ResourceScope scope() {\n+                throw new UnsupportedOperationException();\n+            }\n+\n+            @Override\n+            public void close() {\n+                \/\/ do nothing\n+            }\n+        };\n+    }\n+\n@@ -258,1 +342,1 @@\n-                                   BindingInterpreter.LoadFunc loadFunc, SharedUtils.Allocator allocator);\n+                                   BindingInterpreter.LoadFunc loadFunc, Context context);\n@@ -262,21 +346,0 @@\n-    private static MethodHandle mergeArguments(MethodHandle mh, int sourceIndex, int destIndex) {\n-        MethodType oldType = mh.type();\n-        Class<?> sourceType = oldType.parameterType(sourceIndex);\n-        Class<?> destType = oldType.parameterType(destIndex);\n-        if (sourceType != destType) {\n-            \/\/ TODO meet?\n-            throw new IllegalArgumentException(\"Parameter types differ: \" + sourceType + \" != \" + destType);\n-        }\n-        MethodType newType = oldType.dropParameterTypes(destIndex, destIndex + 1);\n-        int[] reorder = new int[oldType.parameterCount()];\n-        assert destIndex > sourceIndex;\n-        for (int i = 0, index = 0; i < reorder.length; i++) {\n-            if (i != destIndex) {\n-                reorder[i] = index++;\n-            } else {\n-                reorder[i] = sourceIndex;\n-            }\n-        }\n-        return permuteArguments(mh, newType, reorder);\n-    }\n-\n@@ -480,1 +543,1 @@\n-                              BindingInterpreter.LoadFunc loadFunc, SharedUtils.Allocator allocator) {\n+                              BindingInterpreter.LoadFunc loadFunc, Context context) {\n@@ -515,1 +578,1 @@\n-                              BindingInterpreter.LoadFunc loadFunc, SharedUtils.Allocator allocator) {\n+                              BindingInterpreter.LoadFunc loadFunc, Context context) {\n@@ -567,1 +630,4 @@\n-            return MemoryHandles.insertCoordinates(MemoryHandles.varHandle(type, ByteOrder.nativeOrder()), 1, offset);\n+            \/\/ alignment is set to 1 byte here to avoid exceptions for cases where we do super word\n+            \/\/ copies of e.g. 2 int fields of a struct as a single long, while the struct is only\n+            \/\/ 4-byte-aligned (since it only contains ints)\n+            return MemoryHandles.insertCoordinates(MemoryHandles.varHandle(type, 1, ByteOrder.nativeOrder()), 1, offset);\n@@ -592,1 +658,1 @@\n-                              BindingInterpreter.LoadFunc loadFunc, SharedUtils.Allocator allocator) {\n+                              BindingInterpreter.LoadFunc loadFunc, Context context) {\n@@ -636,1 +702,1 @@\n-                              BindingInterpreter.LoadFunc loadFunc, SharedUtils.Allocator allocator) {\n+                              BindingInterpreter.LoadFunc loadFunc, Context context) {\n@@ -676,2 +742,2 @@\n-                                                    SharedUtils.Allocator allocator) {\n-            MemorySegment copy = allocator.allocate(size, alignment);\n+                                                    Context context) {\n+            MemorySegment copy = context.allocator().allocate(size, alignment);\n@@ -708,1 +774,1 @@\n-                              BindingInterpreter.LoadFunc loadFunc, SharedUtils.Allocator allocator) {\n+                              BindingInterpreter.LoadFunc loadFunc, Context context) {\n@@ -710,1 +776,1 @@\n-            MemorySegment copy = copyBuffer(operand, size, alignment, allocator);\n+            MemorySegment copy = copyBuffer(operand, size, alignment, context);\n@@ -718,1 +784,1 @@\n-            return mergeArguments(specializedHandle, allocatorPos, insertPos + 1);\n+            return SharedUtils.mergeArguments(specializedHandle, allocatorPos, insertPos + 1);\n@@ -751,2 +817,2 @@\n-        private static MemorySegment allocateBuffer(long size, long allignment, SharedUtils.Allocator allocator) {\n-            return allocator.allocate(size, allignment);\n+        private static MemorySegment allocateBuffer(long size, long allignment, Context context) {\n+            return context.allocator().allocate(size, allignment);\n@@ -779,2 +845,2 @@\n-                              BindingInterpreter.LoadFunc loadFunc, SharedUtils.Allocator allocator) {\n-            stack.push(allocateBuffer(size, alignment, allocator));\n+                              BindingInterpreter.LoadFunc loadFunc, Context context) {\n+            stack.push(allocateBuffer(size, alignment, context));\n@@ -787,1 +853,1 @@\n-            return mergeArguments(specializedHandle, allocatorPos, insertPos);\n+            return SharedUtils.mergeArguments(specializedHandle, allocatorPos, insertPos);\n@@ -826,1 +892,1 @@\n-                              BindingInterpreter.LoadFunc loadFunc, SharedUtils.Allocator allocator) {\n+                              BindingInterpreter.LoadFunc loadFunc, Context context) {\n@@ -842,1 +908,1 @@\n-     * Box_ADDRESS()\n+     * BOX_ADDRESS()\n@@ -861,1 +927,1 @@\n-                              BindingInterpreter.LoadFunc loadFunc, SharedUtils.Allocator allocator) {\n+                              BindingInterpreter.LoadFunc loadFunc, Context context) {\n@@ -896,1 +962,1 @@\n-                              BindingInterpreter.LoadFunc loadFunc, SharedUtils.Allocator allocator) {\n+                              BindingInterpreter.LoadFunc loadFunc, Context context) {\n@@ -912,2 +978,2 @@\n-     * BASE_ADDRESS([size])\n-     *   Pops a MemoryAddress from the operand stack, and takes the converts it to a MemorySegment\n+     * TO_SEGMENT([size])\n+     *   Pops a MemoryAddress from the operand stack, and converts it to a MemorySegment\n@@ -925,3 +991,2 @@\n-        \/\/ FIXME should register with scope\n-        private static MemorySegment toSegment(MemoryAddress operand, long size) {\n-            return MemoryAddressImpl.ofLongUnchecked(operand.toRawLongValue(), size);\n+        private static MemorySegment toSegment(MemoryAddress operand, long size, Context context) {\n+            return MemoryAddressImpl.ofLongUnchecked(operand.toRawLongValue(), size, (ResourceScopeImpl) context.scope);\n@@ -939,1 +1004,1 @@\n-                              BindingInterpreter.LoadFunc loadFunc, SharedUtils.Allocator allocator) {\n+                              BindingInterpreter.LoadFunc loadFunc, Context context) {\n@@ -941,1 +1006,1 @@\n-            MemorySegment segment = toSegment(operand, size);\n+            MemorySegment segment = toSegment(operand, size, context);\n@@ -948,1 +1013,2 @@\n-            return filterArguments(specializedHandle, insertPos, toSegmentHandle);\n+            specializedHandle = collectArguments(specializedHandle, insertPos, toSegmentHandle);\n+            return SharedUtils.mergeArguments(specializedHandle, allocatorPos, insertPos + 1);\n@@ -991,1 +1057,1 @@\n-                              BindingInterpreter.LoadFunc loadFunc, SharedUtils.Allocator allocator) {\n+                              BindingInterpreter.LoadFunc loadFunc, Context context) {\n@@ -1015,1 +1081,1 @@\n-            return mergeArguments(specializedHandle, insertPos, insertPos + 1);\n+            return SharedUtils.mergeArguments(specializedHandle, insertPos, insertPos + 1);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/Binding.java","additions":123,"deletions":57,"binary":false,"changes":180,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-    static void unbox(Object arg, List<Binding> bindings, StoreFunc storeFunc, SharedUtils.Allocator allocator) {\n+    static void unbox(Object arg, List<Binding> bindings, StoreFunc storeFunc, Binding.Context context) {\n@@ -38,1 +38,1 @@\n-            b.interpret(stack, storeFunc, null, allocator);\n+            b.interpret(stack, storeFunc, null, context);\n@@ -42,1 +42,1 @@\n-    static Object box(List<Binding> bindings, LoadFunc loadFunc, SharedUtils.Allocator allocator) {\n+    static Object box(List<Binding> bindings, LoadFunc loadFunc, Binding.Context context) {\n@@ -45,1 +45,1 @@\n-            b.interpret(stack, null, loadFunc, allocator);\n+            b.interpret(stack, null, loadFunc, context);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/BindingInterpreter.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import jdk.internal.foreign.MemoryAddressImpl;\n@@ -118,1 +119,1 @@\n-    private static void dumpValues(jdk.internal.foreign.abi.Architecture arch, MemorySegment buff, PrintStream stream,\n+    private void dumpValues(jdk.internal.foreign.abi.Architecture arch, MemorySegment buff, PrintStream stream,\n@@ -131,0 +132,8 @@\n+        long stack_ptr = (long) VH_LONG.get(buff.asSlice(stack_args));\n+        long stack_bytes = (long) VH_LONG.get(buff.asSlice(stack_args_bytes));\n+        MemorySegment stackArgs = MemoryAddressImpl.ofLongUnchecked(stack_ptr, stack_bytes);\n+        stream.println(\"Stack {\");\n+        for (int i = 0; i < stack_bytes \/ 8; i += 8) {\n+            stream.printf(\"    @%d: %s%n\", i, getLongString(stackArgs, i));\n+        }\n+        stream.println(\"}\");\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/BufferLayout.java","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import jdk.incubator.foreign.MemoryAddress;\n@@ -30,1 +31,2 @@\n-import jdk.incubator.foreign.NativeScope;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.SegmentAllocator;\n@@ -33,1 +35,0 @@\n-import jdk.internal.foreign.Utils;\n@@ -42,0 +43,1 @@\n+import java.lang.ref.Reference;\n@@ -46,2 +48,0 @@\n-import java.util.stream.Collectors;\n-import java.util.stream.IntStream;\n@@ -52,1 +52,0 @@\n-import static java.lang.invoke.MethodHandles.empty;\n@@ -56,1 +55,0 @@\n-import static java.lang.invoke.MethodHandles.tryFinally;\n@@ -58,2 +56,0 @@\n-import static jdk.internal.foreign.abi.SharedUtils.Allocator.THROWING_ALLOCATOR;\n-import static jdk.internal.foreign.abi.SharedUtils.DEFAULT_ALLOCATOR;\n@@ -81,4 +77,2 @@\n-\n-    private static final MethodHandle MH_MAKE_SCOPE;\n-    private static final MethodHandle MH_CLOSE_SCOPE;\n-    private static final MethodHandle MH_WRAP_SCOPE;\n+    private static final MethodHandle MH_ADDR_TO_LONG;\n+    private static final MethodHandle MH_WRAP_ALLOCATOR;\n@@ -88,0 +82,2 @@\n+    private static final MethodHandle EMPTY_OBJECT_ARRAY_HANDLE = MethodHandles.constant(Object[].class, new Object[0]);\n+\n@@ -92,1 +88,1 @@\n-                    methodType(Object.class, Object[].class, Binding.VMStore[].class, Binding.VMLoad[].class));\n+                    methodType(Object.class, long.class, Object[].class, Binding.VMStore[].class, Binding.VMLoad[].class));\n@@ -94,7 +90,8 @@\n-                    methodType(Object.class, Object[].class, MethodHandle.class, Map.class, Map.class));\n-            MH_MAKE_SCOPE = lookup.findStatic(NativeScope.class, \"boundedScope\",\n-                    methodType(NativeScope.class, long.class));\n-            MH_CLOSE_SCOPE = lookup.findVirtual(NativeScope.class, \"close\",\n-                    methodType(void.class));\n-            MH_WRAP_SCOPE = lookup.findStatic(SharedUtils.Allocator.class, \"ofScope\",\n-                    methodType(SharedUtils.Allocator.class, NativeScope.class));\n+                    methodType(Object.class, Addressable.class, SegmentAllocator.class, Object[].class, MethodHandle.class, Map.class, Map.class));\n+            MH_WRAP_ALLOCATOR = lookup.findStatic(Binding.Context.class, \"ofAllocator\",\n+                    methodType(Binding.Context.class, SegmentAllocator.class));\n+            MethodHandle MH_Addressable_address = lookup.findVirtual(Addressable.class, \"address\",\n+                    methodType(MemoryAddress.class));\n+            MethodHandle MH_MemoryAddress_toRawLongValue = lookup.findVirtual(MemoryAddress.class, \"toRawLongValue\",\n+                    methodType(long.class));\n+            MH_ADDR_TO_LONG = filterArguments(MH_MemoryAddress_toRawLongValue, 0, MH_Addressable_address);\n@@ -112,1 +109,0 @@\n-    private final Addressable addr;\n@@ -117,1 +113,1 @@\n-    public ProgrammableInvoker(ABIDescriptor abi, Addressable addr, CallingSequence callingSequence) {\n+    public ProgrammableInvoker(ABIDescriptor abi, CallingSequence callingSequence) {\n@@ -122,1 +118,0 @@\n-        this.addr = addr;\n@@ -131,18 +126,1 @@\n-        this.bufferCopySize = bufferCopySize(callingSequence);\n-    }\n-\n-    private static long bufferCopySize(CallingSequence callingSequence) {\n-        \/\/ FIXME: > 16 bytes alignment might need extra space since the\n-        \/\/ starting address of the allocator might be un-aligned.\n-        long size = 0;\n-        for (int i = 0; i < callingSequence.argumentCount(); i++) {\n-            List<Binding> bindings = callingSequence.argumentBindings(i);\n-            for (Binding b : bindings) {\n-                if (b instanceof Binding.Copy) {\n-                    Binding.Copy c = (Binding.Copy) b;\n-                    size = Utils.alignUp(size, c.alignment());\n-                    size += c.size();\n-                }\n-            }\n-        }\n-        return size;\n+        this.bufferCopySize = SharedUtils.bufferCopySize(callingSequence);\n@@ -163,0 +141,1 @@\n+        MethodType leafTypeWithAddress = leafType.insertParameterTypes(0, long.class);\n@@ -164,3 +143,4 @@\n-        MethodHandle handle = insertArguments(MH_INVOKE_MOVES.bindTo(this), 1, argMoves, retMoves)\n-                                            .asCollector(Object[].class, leafType.parameterCount())\n-                                            .asType(leafType);\n+        MethodHandle handle = insertArguments(MH_INVOKE_MOVES.bindTo(this), 2, argMoves, retMoves);\n+        MethodHandle collector = makeCollectorHandle(leafType);\n+        handle = collectArguments(handle, 1, collector);\n+        handle = handle.asType(leafTypeWithAddress);\n@@ -172,1 +152,0 @@\n-                addr.address().toRawLongValue(),\n@@ -178,1 +157,1 @@\n-                leafType\n+                leafTypeWithAddress\n@@ -183,0 +162,1 @@\n+        handle = filterArguments(handle, 0, MH_ADDR_TO_LONG);\n@@ -187,2 +167,2 @@\n-            Map<VMStorage, Integer> argIndexMap = indexMap(argMoves);\n-            Map<VMStorage, Integer> retIndexMap = indexMap(retMoves);\n+            Map<VMStorage, Integer> argIndexMap = SharedUtils.indexMap(argMoves);\n+            Map<VMStorage, Integer> retIndexMap = SharedUtils.indexMap(retMoves);\n@@ -190,3 +170,4 @@\n-            handle = insertArguments(MH_INVOKE_INTERP_BINDINGS.bindTo(this), 1, handle, argIndexMap, retIndexMap);\n-            handle = handle.asCollector(Object[].class, callingSequence.methodType().parameterCount())\n-                                             .asType(callingSequence.methodType());\n+            handle = insertArguments(MH_INVOKE_INTERP_BINDINGS.bindTo(this), 3, handle, argIndexMap, retIndexMap);\n+            MethodHandle collectorInterp = makeCollectorHandle(callingSequence.methodType());\n+            handle = collectArguments(handle, 2, collectorInterp);\n+            handle = handle.asType(handle.type().changeReturnType(callingSequence.methodType().returnType()));\n@@ -198,0 +179,9 @@\n+    \/\/ Funnel from type to Object[]\n+    private static MethodHandle makeCollectorHandle(MethodType type) {\n+        return type.parameterCount() == 0\n+            ? EMPTY_OBJECT_ARRAY_HANDLE\n+            : identity(Object[].class)\n+                .asCollector(Object[].class, type.parameterCount())\n+                .asType(type.changeReturnType(Object[].class));\n+    }\n+\n@@ -218,1 +208,0 @@\n-        MethodType leafType = leafHandle.type();\n@@ -220,1 +209,4 @@\n-        MethodHandle specializedHandle = leafHandle; \/\/ initial\n+        int argInsertPos = 1;\n+        int argContextPos = 1;\n+\n+        MethodHandle specializedHandle = dropArguments(leafHandle, argContextPos, Binding.Context.class);\n@@ -222,7 +214,0 @@\n-        int argInsertPos = -1;\n-        int argAllocatorPos = -1;\n-        if (bufferCopySize > 0) {\n-            argAllocatorPos = 0;\n-            specializedHandle = dropArguments(specializedHandle, argAllocatorPos, SharedUtils.Allocator.class);\n-            argInsertPos++;\n-        }\n@@ -238,1 +223,1 @@\n-                    specializedHandle = binding.specialize(specializedHandle, argInsertPos, argAllocatorPos);\n+                    specializedHandle = binding.specialize(specializedHandle, argInsertPos, argContextPos);\n@@ -245,1 +230,1 @@\n-            int retAllocatorPos = 0;\n+            int retContextPos = 0;\n@@ -247,1 +232,1 @@\n-            returnFilter = dropArguments(returnFilter, retAllocatorPos, SharedUtils.Allocator.class);\n+            returnFilter = dropArguments(returnFilter, retContextPos, Binding.Context.class);\n@@ -251,1 +236,1 @@\n-                returnFilter = binding.specialize(returnFilter, retInsertPos, retAllocatorPos);\n+                returnFilter = binding.specialize(returnFilter, retInsertPos, retContextPos);\n@@ -253,2 +238,7 @@\n-            returnFilter = insertArguments(returnFilter, retAllocatorPos, DEFAULT_ALLOCATOR);\n-            specializedHandle = MethodHandles.filterReturnValue(specializedHandle, returnFilter);\n+            returnFilter = MethodHandles.filterArguments(returnFilter, retContextPos, MH_WRAP_ALLOCATOR);\n+            \/\/ (SegmentAllocator, Addressable, Context, ...) -> ...\n+            specializedHandle = MethodHandles.collectArguments(returnFilter, retInsertPos, specializedHandle);\n+            \/\/ (Addressable, SegmentAllocator, Context, ...) -> ...\n+            specializedHandle = SharedUtils.swapArguments(specializedHandle, 0, 1); \/\/ normalize parameter order\n+        } else {\n+            specializedHandle = MethodHandles.dropArguments(specializedHandle, 1, SegmentAllocator.class);\n@@ -257,16 +247,1 @@\n-        if (bufferCopySize > 0) {\n-            \/\/ insert try-finally to close the NativeScope used for Binding.Copy\n-            MethodHandle closer = leafType.returnType() == void.class\n-                  \/\/ (Throwable, NativeScope) -> void\n-                ? collectArguments(empty(methodType(void.class, Throwable.class)), 1, MH_CLOSE_SCOPE)\n-                  \/\/ (Throwable, V, NativeScope) -> V\n-                : collectArguments(dropArguments(identity(specializedHandle.type().returnType()), 0, Throwable.class),\n-                                   2, MH_CLOSE_SCOPE);\n-            \/\/ Handle takes a SharedUtils.Allocator, so need to wrap our NativeScope\n-            specializedHandle = filterArguments(specializedHandle, argAllocatorPos, MH_WRAP_SCOPE);\n-            specializedHandle = tryFinally(specializedHandle, closer);\n-            MethodHandle makeScopeHandle = insertArguments(MH_MAKE_SCOPE, 0, bufferCopySize);\n-            specializedHandle = collectArguments(specializedHandle, argAllocatorPos, makeScopeHandle);\n-        }\n-        return specializedHandle;\n-    }\n+        \/\/ now bind the internal context parameter\n@@ -274,4 +249,3 @@\n-    private static Map<VMStorage, Integer> indexMap(Binding.Move[] moves) {\n-        return IntStream.range(0, moves.length)\n-                        .boxed()\n-                        .collect(Collectors.toMap(i -> moves[i].storage(), i -> i));\n+        argContextPos++; \/\/ skip over the return SegmentAllocator (inserted by the above code)\n+        specializedHandle = SharedUtils.wrapWithAllocator(specializedHandle, argContextPos, bufferCopySize, false);\n+        return specializedHandle;\n@@ -289,1 +263,1 @@\n-    Object invokeMoves(Object[] args, Binding.VMStore[] argBindings, Binding.VMLoad[] returnBindings) {\n+    Object invokeMoves(long addr, Object[] args, Binding.VMStore[] argBindings, Binding.VMLoad[] returnBindings) {\n@@ -291,1 +265,2 @@\n-        try (MemorySegment argBuffer = MemorySegment.allocateNative(layout.size, 64)) {\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            MemorySegment argBuffer = MemorySegment.allocateNative(layout.size, 64, scope);\n@@ -293,1 +268,1 @@\n-                stackArgsSeg = MemorySegment.allocateNative(stackArgsBytes, 8);\n+                stackArgsSeg = MemorySegment.allocateNative(stackArgsBytes, 8, scope);\n@@ -296,1 +271,1 @@\n-            VH_LONG.set(argBuffer.asSlice(layout.arguments_next_pc), addr.address().toRawLongValue());\n+            VH_LONG.set(argBuffer.asSlice(layout.arguments_next_pc), addr);\n@@ -336,4 +311,0 @@\n-        } finally {\n-            if (stackArgsSeg != null) {\n-                stackArgsSeg.close();\n-            }\n@@ -343,1 +314,1 @@\n-    Object invokeInterpBindings(Object[] args, MethodHandle leaf,\n+    Object invokeInterpBindings(Addressable address, SegmentAllocator allocator, Object[] args, MethodHandle leaf,\n@@ -346,4 +317,4 @@\n-        SharedUtils.Allocator unboxAllocator = bufferCopySize != 0\n-                ? SharedUtils.Allocator.ofScope(NativeScope.boundedScope(bufferCopySize))\n-                : THROWING_ALLOCATOR;\n-        try (unboxAllocator) {\n+        Binding.Context unboxContext = bufferCopySize != 0\n+                ? Binding.Context.ofBoundedAllocator(bufferCopySize)\n+                : Binding.Context.DUMMY;\n+        try (unboxContext) {\n@@ -351,1 +322,2 @@\n-            Object[] moves = new Object[leaf.type().parameterCount()];\n+            Object[] leafArgs = new Object[leaf.type().parameterCount()];\n+            leafArgs[0] = address; \/\/ addr\n@@ -356,2 +328,2 @@\n-                            moves[argIndexMap.get(storage)] = value;\n-                        }, unboxAllocator);\n+                            leafArgs[argIndexMap.get(storage) + 1] = value; \/\/ +1 to skip addr\n+                        }, unboxContext);\n@@ -361,1 +333,5 @@\n-            Object o = leaf.invokeWithArguments(moves);\n+            Object o = leaf.invokeWithArguments(leafArgs);\n+            \/\/ make sure arguments are reachable during the call\n+            \/\/ technically we only need to do all Addressable parameters here\n+            Reference.reachabilityFence(address);\n+            Reference.reachabilityFence(args);\n@@ -369,1 +345,1 @@\n-                        (storage, type) -> oArr[retIndexMap.get(storage)], DEFAULT_ALLOCATOR);\n+                        (storage, type) -> oArr[retIndexMap.get(storage)], Binding.Context.ofAllocator(allocator));\n@@ -372,1 +348,1 @@\n-                        DEFAULT_ALLOCATOR);\n+                        Binding.Context.ofAllocator(allocator));\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/ProgrammableInvoker.java","additions":82,"deletions":106,"binary":false,"changes":188,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import jdk.incubator.foreign.MemoryHandles;\n@@ -32,0 +31,4 @@\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.SegmentAllocator;\n+import jdk.internal.access.JavaLangInvokeAccess;\n+import jdk.internal.access.SharedSecrets;\n@@ -33,2 +36,1 @@\n-import jdk.internal.foreign.Utils;\n-import jdk.internal.vm.annotation.Stable;\n+import sun.security.action.GetPropertyAction;\n@@ -37,0 +39,1 @@\n+import java.lang.invoke.MethodHandles;\n@@ -39,2 +42,0 @@\n-import java.nio.ByteOrder;\n-import java.util.ArrayList;\n@@ -42,0 +43,2 @@\n+import java.util.List;\n+import java.util.Map;\n@@ -43,0 +46,1 @@\n+import java.util.stream.Stream;\n@@ -44,1 +48,7 @@\n-import static jdk.internal.foreign.abi.SharedUtils.DEFAULT_ALLOCATOR;\n+import static java.lang.invoke.MethodHandles.dropArguments;\n+import static java.lang.invoke.MethodHandles.filterReturnValue;\n+import static java.lang.invoke.MethodHandles.identity;\n+import static java.lang.invoke.MethodHandles.insertArguments;\n+import static java.lang.invoke.MethodHandles.lookup;\n+import static java.lang.invoke.MethodType.methodType;\n+import static jdk.internal.foreign.abi.SharedUtils.mergeArguments;\n@@ -52,2 +62,1 @@\n-public class ProgrammableUpcallHandler implements UpcallHandler {\n-\n+public class ProgrammableUpcallHandler {\n@@ -56,0 +65,6 @@\n+    private static final boolean USE_SPEC = Boolean.parseBoolean(\n+        GetPropertyAction.privilegedGetProperty(\"jdk.internal.foreign.ProgrammableUpcallHandler.USE_SPEC\", \"true\"));\n+    private static final boolean USE_INTRINSICS = Boolean.parseBoolean(\n+        GetPropertyAction.privilegedGetProperty(\"jdk.internal.foreign.ProgrammableUpcallHandler.USE_INTRINSICS\", \"true\"));\n+\n+    private static final JavaLangInvokeAccess JLI = SharedSecrets.getJavaLangInvokeAccess();\n@@ -59,16 +74,15 @@\n-    @Stable\n-    private final MethodHandle mh;\n-    private final MethodType type;\n-    private final CallingSequence callingSequence;\n-    private final long entryPoint;\n-\n-    private final ABIDescriptor abi;\n-    private final BufferLayout layout;\n-\n-    public ProgrammableUpcallHandler(ABIDescriptor abi, MethodHandle target, CallingSequence callingSequence) {\n-        this.abi = abi;\n-        this.layout = BufferLayout.of(abi);\n-        this.type = callingSequence.methodType();\n-        this.callingSequence = callingSequence;\n-        this.mh = target.asSpreader(Object[].class, callingSequence.methodType().parameterCount());\n-        this.entryPoint = allocateUpcallStub(abi, layout);\n+    private static final MethodHandle MH_invokeMoves;\n+    private static final MethodHandle MH_invokeInterpBindings;\n+\n+    static {\n+        try {\n+            MethodHandles.Lookup lookup = lookup();\n+            MH_invokeMoves = lookup.findStatic(ProgrammableUpcallHandler.class, \"invokeMoves\",\n+                    methodType(void.class, MemoryAddress.class, MethodHandle.class,\n+                               Binding.VMLoad[].class, Binding.VMStore[].class, ABIDescriptor.class, BufferLayout.class));\n+            MH_invokeInterpBindings = lookup.findStatic(ProgrammableUpcallHandler.class, \"invokeInterpBindings\",\n+                    methodType(Object.class, Object[].class, MethodHandle.class, Map.class, Map.class,\n+                            CallingSequence.class, long.class));\n+        } catch (ReflectiveOperationException e) {\n+            throw new InternalError(e);\n+        }\n@@ -77,3 +91,47 @@\n-    @Override\n-    public long entryPoint() {\n-        return entryPoint;\n+    public static UpcallHandler make(ABIDescriptor abi, MethodHandle target, CallingSequence callingSequence) {\n+        Binding.VMLoad[] argMoves = argMoveBindings(callingSequence);\n+        Binding.VMStore[] retMoves = retMoveBindings(callingSequence);\n+\n+        boolean isSimple = !(retMoves.length > 1);\n+\n+        Class<?> llReturn = !isSimple\n+            ? Object[].class\n+            : retMoves.length == 1\n+                ? retMoves[0].type()\n+                : void.class;\n+        Class<?>[] llParams = Arrays.stream(argMoves).map(Binding.Move::type).toArray(Class<?>[]::new);\n+        MethodType llType = MethodType.methodType(llReturn, llParams);\n+\n+        MethodHandle doBindings;\n+        long bufferCopySize = SharedUtils.bufferCopySize(callingSequence);\n+        if (USE_SPEC && isSimple) {\n+            doBindings = specializedBindingHandle(target, callingSequence, llReturn, bufferCopySize);\n+            assert doBindings.type() == llType;\n+        } else {\n+            Map<VMStorage, Integer> argIndices = SharedUtils.indexMap(argMoves);\n+            Map<VMStorage, Integer> retIndices = SharedUtils.indexMap(retMoves);\n+            target = target.asSpreader(Object[].class, callingSequence.methodType().parameterCount());\n+            doBindings = insertArguments(MH_invokeInterpBindings, 1, target, argIndices, retIndices, callingSequence,\n+                    bufferCopySize);\n+            doBindings = doBindings.asCollector(Object[].class, llType.parameterCount());\n+            doBindings = doBindings.asType(llType);\n+        }\n+\n+        long entryPoint;\n+        boolean usesStackArgs = argMoveBindingsStream(callingSequence)\n+                .map(Binding.VMLoad::storage)\n+                .anyMatch(s -> abi.arch.isStackType(s.type()));\n+        if (USE_INTRINSICS && isSimple && !usesStackArgs && supportsOptimizedUpcalls()) {\n+            checkPrimitive(doBindings.type());\n+            JLI.ensureCustomized(doBindings);\n+            VMStorage[] args = Arrays.stream(argMoves).map(Binding.Move::storage).toArray(VMStorage[]::new);\n+            VMStorage[] rets = Arrays.stream(retMoves).map(Binding.Move::storage).toArray(VMStorage[]::new);\n+            CallRegs conv = new CallRegs(args, rets);\n+            entryPoint = allocateOptimizedUpcallStub(doBindings, abi, conv);\n+        } else {\n+            BufferLayout layout = BufferLayout.of(abi);\n+            MethodHandle doBindingsErased = doBindings.asSpreader(Object[].class, doBindings.type().parameterCount());\n+            MethodHandle invokeMoves = insertArguments(MH_invokeMoves, 1, doBindingsErased, argMoves, retMoves, abi, layout);\n+            entryPoint = allocateUpcallStub(invokeMoves, abi, layout);\n+        }\n+        return () -> entryPoint;\n@@ -82,2 +140,4 @@\n-    public static void invoke(ProgrammableUpcallHandler handler, long address) {\n-        handler.invoke(MemoryAddress.ofLong(address));\n+    private static void checkPrimitive(MethodType type) {\n+        if (!type.returnType().isPrimitive()\n+                || type.parameterList().stream().anyMatch(p -> !p.isPrimitive()))\n+            throw new IllegalArgumentException(\"MethodHandle type must be primitive: \" + type);\n@@ -86,3 +146,5 @@\n-    private void invoke(MemoryAddress buffer) {\n-        try {\n-            MemorySegment bufferBase = MemoryAddressImpl.ofLongUnchecked(buffer.toRawLongValue(), layout.size);\n+    private static Stream<Binding.VMLoad> argMoveBindingsStream(CallingSequence callingSequence) {\n+        return callingSequence.argumentBindings()\n+                .filter(Binding.VMLoad.class::isInstance)\n+                .map(Binding.VMLoad.class::cast);\n+    }\n@@ -90,3 +152,31 @@\n-            if (DEBUG) {\n-                System.err.println(\"Buffer state before:\");\n-                layout.dump(abi.arch, bufferBase, System.err);\n+    private static Binding.VMLoad[] argMoveBindings(CallingSequence callingSequence) {\n+        return argMoveBindingsStream(callingSequence)\n+                .toArray(Binding.VMLoad[]::new);\n+    }\n+\n+    private static Binding.VMStore[] retMoveBindings(CallingSequence callingSequence) {\n+        return callingSequence.returnBindings().stream()\n+                .filter(Binding.VMStore.class::isInstance)\n+                .map(Binding.VMStore.class::cast)\n+                .toArray(Binding.VMStore[]::new);\n+    }\n+\n+    private static MethodHandle specializedBindingHandle(MethodHandle target, CallingSequence callingSequence,\n+                                                         Class<?> llReturn, long bufferCopySize) {\n+        MethodType highLevelType = callingSequence.methodType();\n+\n+        MethodHandle specializedHandle = target; \/\/ initial\n+\n+        int argAllocatorPos = 0;\n+        int argInsertPos = 1;\n+        specializedHandle = dropArguments(specializedHandle, argAllocatorPos, Binding.Context.class);\n+        for (int i = 0; i < highLevelType.parameterCount(); i++) {\n+            MethodHandle filter = identity(highLevelType.parameterType(i));\n+            int filterAllocatorPos = 0;\n+            int filterInsertPos = 1; \/\/ +1 for allocator\n+            filter = dropArguments(filter, filterAllocatorPos, Binding.Context.class);\n+\n+            List<Binding> bindings = callingSequence.argumentBindings(i);\n+            for (int j = bindings.size() - 1; j >= 0; j--) {\n+                Binding binding = bindings.get(j);\n+                filter = binding.specialize(filter, filterInsertPos, filterAllocatorPos);\n@@ -94,0 +184,4 @@\n+            specializedHandle = MethodHandles.collectArguments(specializedHandle, argInsertPos, filter);\n+            specializedHandle = mergeArguments(specializedHandle, argAllocatorPos, argInsertPos + filterAllocatorPos);\n+            argInsertPos += filter.type().parameterCount() - 1; \/\/ -1 for allocator\n+        }\n@@ -95,3 +189,79 @@\n-            MemorySegment stackArgsBase = MemoryAddressImpl.ofLongUnchecked((long)VH_LONG.get(bufferBase.asSlice(layout.stack_args)));\n-            Object[] args = new Object[type.parameterCount()];\n-            for (int i = 0 ; i < type.parameterCount() ; i++) {\n+        if (llReturn != void.class) {\n+            int retAllocatorPos = -1; \/\/ assumed not needed\n+            int retInsertPos = 0;\n+            MethodHandle filter = identity(llReturn);\n+            List<Binding> bindings = callingSequence.returnBindings();\n+            for (int j = bindings.size() - 1; j >= 0; j--) {\n+                Binding binding = bindings.get(j);\n+                filter = binding.specialize(filter, retInsertPos, retAllocatorPos);\n+            }\n+            specializedHandle = filterReturnValue(specializedHandle, filter);\n+        }\n+\n+        specializedHandle = SharedUtils.wrapWithAllocator(specializedHandle, argAllocatorPos, bufferCopySize, true);\n+\n+        return specializedHandle;\n+    }\n+\n+    public static void invoke(MethodHandle mh, long address) throws Throwable {\n+        mh.invokeExact(MemoryAddress.ofLong(address));\n+    }\n+\n+    private static void invokeMoves(MemoryAddress buffer, MethodHandle leaf,\n+                                    Binding.VMLoad[] argBindings, Binding.VMStore[] returnBindings,\n+                                    ABIDescriptor abi, BufferLayout layout) throws Throwable {\n+        MemorySegment bufferBase = MemoryAddressImpl.ofLongUnchecked(buffer.toRawLongValue(), layout.size);\n+\n+        if (DEBUG) {\n+            System.err.println(\"Buffer state before:\");\n+            layout.dump(abi.arch, bufferBase, System.err);\n+        }\n+\n+        MemorySegment stackArgsBase = MemoryAddressImpl.ofLongUnchecked((long)VH_LONG.get(bufferBase.asSlice(layout.stack_args)));\n+        Object[] moves = new Object[argBindings.length];\n+        for (int i = 0; i < moves.length; i++) {\n+            Binding.VMLoad binding = argBindings[i];\n+            VMStorage storage = binding.storage();\n+            MemorySegment ptr = abi.arch.isStackType(storage.type())\n+                ? stackArgsBase.asSlice(storage.index() * abi.arch.typeSize(abi.arch.stackType()))\n+                : bufferBase.asSlice(layout.argOffset(storage));\n+            moves[i] = SharedUtils.read(ptr, binding.type());\n+        }\n+\n+        \/\/ invokeInterpBindings, and then actual target\n+        Object o = leaf.invoke(moves);\n+\n+        if (o == null) {\n+            \/\/ nop\n+        } else if (o instanceof Object[] returns) {\n+            for (int i = 0; i < returnBindings.length; i++) {\n+                Binding.VMStore binding = returnBindings[i];\n+                VMStorage storage = binding.storage();\n+                MemorySegment ptr = bufferBase.asSlice(layout.retOffset(storage));\n+                SharedUtils.writeOverSized(ptr, binding.type(), returns[i]);\n+            }\n+        } else { \/\/ single Object\n+            Binding.VMStore binding = returnBindings[0];\n+            VMStorage storage = binding.storage();\n+            MemorySegment ptr = bufferBase.asSlice(layout.retOffset(storage));\n+            SharedUtils.writeOverSized(ptr, binding.type(), o);\n+        }\n+\n+        if (DEBUG) {\n+            System.err.println(\"Buffer state after:\");\n+            layout.dump(abi.arch, bufferBase, System.err);\n+        }\n+    }\n+\n+    private static Object invokeInterpBindings(Object[] moves, MethodHandle leaf,\n+                                               Map<VMStorage, Integer> argIndexMap,\n+                                               Map<VMStorage, Integer> retIndexMap,\n+                                               CallingSequence callingSequence,\n+                                               long bufferCopySize) throws Throwable {\n+        Binding.Context allocator = bufferCopySize != 0\n+                ? Binding.Context.ofBoundedAllocator(bufferCopySize)\n+                : Binding.Context.ofScope();\n+        try (allocator) {\n+            \/\/\/ Invoke interpreter, got array of high-level arguments back\n+            Object[] args = new Object[callingSequence.methodType().parameterCount()];\n+            for (int i = 0; i < args.length; i++) {\n@@ -99,6 +269,1 @@\n-                        (storage, type) -> {\n-                            MemorySegment ptr = abi.arch.isStackType(storage.type())\n-                                ? stackArgsBase.asSlice(storage.index() * abi.arch.typeSize(abi.arch.stackType()))\n-                                : bufferBase.asSlice(layout.argOffset(storage));\n-                            return SharedUtils.read(ptr, type);\n-                        }, DEFAULT_ALLOCATOR);\n+                        (storage, type) -> moves[argIndexMap.get(storage)], allocator);\n@@ -112,1 +277,2 @@\n-            Object o = mh.invoke(args);\n+            \/\/ invoke our target\n+            Object o = leaf.invoke(args);\n@@ -119,1 +285,2 @@\n-            if (mh.type().returnType() != void.class) {\n+            Object[] returnMoves = new Object[retIndexMap.size()];\n+            if (leaf.type().returnType() != void.class) {\n@@ -121,4 +288,1 @@\n-                        (storage, type, value) -> {\n-                            MemorySegment ptr = bufferBase.asSlice(layout.retOffset(storage));\n-                            SharedUtils.writeOverSized(ptr, type, value);\n-                        }, null);\n+                        (storage, type, value) -> returnMoves[retIndexMap.get(storage)] = value, null);\n@@ -127,3 +291,6 @@\n-            if (DEBUG) {\n-                System.err.println(\"Buffer state after:\");\n-                layout.dump(abi.arch, bufferBase, System.err);\n+            if (returnMoves.length == 0) {\n+                return null;\n+            } else if (returnMoves.length == 1) {\n+                return returnMoves[0];\n+            } else {\n+                return returnMoves;\n@@ -131,2 +298,0 @@\n-        } catch (Throwable t) {\n-            throw new IllegalStateException(t);\n@@ -136,1 +301,6 @@\n-    public native long allocateUpcallStub(ABIDescriptor abi, BufferLayout layout);\n+    \/\/ used for transporting data into native code\n+    private static record CallRegs(VMStorage[] argRegs, VMStorage[] retRegs) {}\n+\n+    static native long allocateOptimizedUpcallStub(MethodHandle mh, ABIDescriptor abi, CallRegs conv);\n+    static native long allocateUpcallStub(MethodHandle mh, ABIDescriptor abi, BufferLayout layout);\n+    static native boolean supportsOptimizedUpcalls();\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/ProgrammableUpcallHandler.java","additions":226,"deletions":56,"binary":false,"changes":282,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+import jdk.incubator.foreign.Addressable;\n@@ -35,1 +36,2 @@\n-import jdk.incubator.foreign.NativeScope;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.SegmentAllocator;\n@@ -50,0 +52,1 @@\n+import java.lang.ref.Reference;\n@@ -52,0 +55,1 @@\n+import java.util.Map;\n@@ -53,0 +57,1 @@\n+import java.util.stream.Collectors;\n@@ -56,0 +61,5 @@\n+import static java.lang.invoke.MethodHandles.constant;\n+import static java.lang.invoke.MethodHandles.dropArguments;\n+import static java.lang.invoke.MethodHandles.dropReturn;\n+import static java.lang.invoke.MethodHandles.empty;\n+import static java.lang.invoke.MethodHandles.filterArguments;\n@@ -59,0 +69,1 @@\n+import static java.lang.invoke.MethodHandles.tryFinally;\n@@ -67,2 +78,4 @@\n-\n-    static final Allocator DEFAULT_ALLOCATOR = MemorySegment::allocateNative;\n+    private static final MethodHandle MH_MAKE_CONTEXT_NO_ALLOCATOR;\n+    private static final MethodHandle MH_MAKE_CONTEXT_BOUNDED_ALLOCATOR;\n+    private static final MethodHandle MH_CLOSE_CONTEXT;\n+    private static final MethodHandle MH_REACHBILITY_FENCE;\n@@ -72,2 +85,2 @@\n-            var lookup = MethodHandles.lookup();\n-            MH_ALLOC_BUFFER = lookup.findStatic(SharedUtils.class, \"allocateNative\",\n+            MethodHandles.Lookup lookup = MethodHandles.lookup();\n+            MH_ALLOC_BUFFER = lookup.findVirtual(SegmentAllocator.class, \"allocate\",\n@@ -79,0 +92,8 @@\n+            MH_MAKE_CONTEXT_NO_ALLOCATOR = lookup.findStatic(Binding.Context.class, \"ofScope\",\n+                    methodType(Binding.Context.class));\n+            MH_MAKE_CONTEXT_BOUNDED_ALLOCATOR = lookup.findStatic(Binding.Context.class, \"ofBoundedAllocator\",\n+                    methodType(Binding.Context.class, long.class));\n+            MH_CLOSE_CONTEXT = lookup.findVirtual(Binding.Context.class, \"close\",\n+                    methodType(void.class));\n+            MH_REACHBILITY_FENCE = lookup.findStatic(Reference.class, \"reachabilityFence\",\n+                    methodType(void.class, Object.class));\n@@ -84,4 +105,2 @@\n-    \/\/ workaround for https:\/\/bugs.openjdk.java.net\/browse\/JDK-8239083\n-    private static MemorySegment allocateNative(MemoryLayout layout) {\n-        return MemorySegment.allocateNative(layout);\n-    }\n+    \/\/ this allocator should be used when no allocation is expected\n+    public static final SegmentAllocator THROWING_ALLOCATOR = (size, align) -> { throw new IllegalStateException(\"Cannot get here\"); };\n@@ -157,3 +176,3 @@\n-            throw new IllegalArgumentException(\"return expected to be void for in memory returns\");\n-        if (handle.type().parameterType(0) != MemoryAddress.class)\n-            throw new IllegalArgumentException(\"MemoryAddress expected as first param\");\n+            throw new IllegalArgumentException(\"return expected to be void for in memory returns: \" + handle.type());\n+        if (handle.type().parameterType(2) != MemoryAddress.class)\n+            throw new IllegalArgumentException(\"MemoryAddress expected as third param: \" + handle.type());\n@@ -164,9 +183,6 @@\n-        handle = collectArguments(ret, 1, handle); \/\/ (MemorySegment, MemoryAddress ...) MemorySegment\n-        handle = collectArguments(handle, 1, MH_BASEADDRESS); \/\/ (MemorySegment, MemorySegment ...) MemorySegment\n-        MethodType oldType = handle.type(); \/\/ (MemorySegment, MemorySegment, ...) MemorySegment\n-        MethodType newType = oldType.dropParameterTypes(0, 1); \/\/ (MemorySegment, ...) MemorySegment\n-        int[] reorder = IntStream.range(-1, newType.parameterCount()).toArray();\n-        reorder[0] = 0; \/\/ [0, 0, 1, 2, 3, ...]\n-        handle = permuteArguments(handle, newType, reorder); \/\/ (MemorySegment, ...) MemoryAddress\n-        handle = collectArguments(handle, 0, insertArguments(MH_ALLOC_BUFFER, 0, cDesc.returnLayout().get())); \/\/ (...) MemoryAddress\n-\n+        handle = collectArguments(ret, 1, handle); \/\/ (MemorySegment, Addressable, SegmentAllocator, MemoryAddress, ...) MemorySegment\n+        handle = collectArguments(handle, 3, MH_BASEADDRESS); \/\/ (MemorySegment, Addressable, SegmentAllocator, MemorySegment, ...) MemorySegment\n+        handle = mergeArguments(handle, 0, 3);  \/\/ (MemorySegment, Addressable, SegmentAllocator, ...) MemorySegment\n+        handle = collectArguments(handle, 0, insertArguments(MH_ALLOC_BUFFER, 1, cDesc.returnLayout().get())); \/\/ (SegmentAllocator, Addressable, SegmentAllocator, ...) MemoryAddress\n+        handle = mergeArguments(handle, 0, 2);  \/\/ (SegmentAllocator, Addressable, ...) MemoryAddress\n+        handle = swapArguments(handle, 0, 1); \/\/ (Addressable, SegmentAllocator, ...) MemoryAddress\n@@ -184,1 +200,1 @@\n-    public static MethodHandle adaptUpcallForIMR(MethodHandle target) {\n+    public static MethodHandle adaptUpcallForIMR(MethodHandle target, boolean dropReturn) {\n@@ -190,0 +206,4 @@\n+        if (dropReturn) { \/\/ no handling for return value, need to drop it\n+            target = dropReturn(target);\n+        }\n+\n@@ -226,9 +246,17 @@\n-    public static Class<?> primitiveCarrierForSize(long size) {\n-        if (size == 1) {\n-            return byte.class;\n-        } else if(size == 2) {\n-            return short.class;\n-        } else if (size <= 4) {\n-            return int.class;\n-        } else if (size <= 8) {\n-            return long.class;\n+    public static Class<?> primitiveCarrierForSize(long size, boolean useFloat) {\n+        if (useFloat) {\n+            if (size == 4) {\n+                return float.class;\n+            } else if (size == 8) {\n+                return double.class;\n+            }\n+        } else {\n+            if (size == 1) {\n+                return byte.class;\n+            } else if (size == 2) {\n+                return short.class;\n+            } else if (size <= 4) {\n+                return int.class;\n+            } else if (size <= 8) {\n+                return long.class;\n+            }\n@@ -237,1 +265,1 @@\n-        throw new IllegalArgumentException(\"Size too large: \" + size);\n+        throw new IllegalArgumentException(\"No type for size: \" + size + \" isFloat=\" + useFloat);\n@@ -267,0 +295,120 @@\n+    static long bufferCopySize(CallingSequence callingSequence) {\n+        \/\/ FIXME: > 16 bytes alignment might need extra space since the\n+        \/\/ starting address of the allocator might be un-aligned.\n+        long size = 0;\n+        for (int i = 0; i < callingSequence.argumentCount(); i++) {\n+            List<Binding> bindings = callingSequence.argumentBindings(i);\n+            for (Binding b : bindings) {\n+                if (b instanceof Binding.Copy) {\n+                    Binding.Copy c = (Binding.Copy) b;\n+                    size = Utils.alignUp(size, c.alignment());\n+                    size += c.size();\n+                } else if (b instanceof Binding.Allocate) {\n+                    Binding.Allocate c = (Binding.Allocate) b;\n+                    size = Utils.alignUp(size, c.alignment());\n+                    size += c.size();\n+                }\n+            }\n+        }\n+        return size;\n+    }\n+\n+    static Map<VMStorage, Integer> indexMap(Binding.Move[] moves) {\n+        return IntStream.range(0, moves.length)\n+                        .boxed()\n+                        .collect(Collectors.toMap(i -> moves[i].storage(), i -> i));\n+    }\n+\n+    static MethodHandle mergeArguments(MethodHandle mh, int sourceIndex, int destIndex) {\n+        MethodType oldType = mh.type();\n+        Class<?> sourceType = oldType.parameterType(sourceIndex);\n+        Class<?> destType = oldType.parameterType(destIndex);\n+        if (sourceType != destType) {\n+            \/\/ TODO meet?\n+            throw new IllegalArgumentException(\"Parameter types differ: \" + sourceType + \" != \" + destType);\n+        }\n+        MethodType newType = oldType.dropParameterTypes(destIndex, destIndex + 1);\n+        int[] reorder = new int[oldType.parameterCount()];\n+        assert destIndex > sourceIndex;\n+        for (int i = 0, index = 0; i < reorder.length; i++) {\n+            if (i != destIndex) {\n+                reorder[i] = index++;\n+            } else {\n+                reorder[i] = sourceIndex;\n+            }\n+        }\n+        return permuteArguments(mh, newType, reorder);\n+    }\n+\n+\n+    static MethodHandle swapArguments(MethodHandle mh, int firstArg, int secondArg) {\n+        MethodType mtype = mh.type();\n+        int[] perms = new int[mtype.parameterCount()];\n+        MethodType swappedType = MethodType.methodType(mtype.returnType());\n+        for (int i = 0 ; i < perms.length ; i++) {\n+            int dst = i;\n+            if (i == firstArg) dst = secondArg;\n+            if (i == secondArg) dst = firstArg;\n+            perms[i] = dst;\n+            swappedType = swappedType.appendParameterTypes(mtype.parameterType(dst));\n+        }\n+        return permuteArguments(mh, swappedType, perms);\n+    }\n+\n+    private static MethodHandle reachabilityFenceHandle(Class<?> type) {\n+        return MH_REACHBILITY_FENCE.asType(MethodType.methodType(void.class, type));\n+    }\n+\n+    static MethodHandle wrapWithAllocator(MethodHandle specializedHandle,\n+                                          int allocatorPos, long bufferCopySize,\n+                                          boolean upcall) {\n+        \/\/ insert try-finally to close the NativeScope used for Binding.Copy\n+        MethodHandle closer;\n+        int insertPos;\n+        if (specializedHandle.type().returnType() == void.class) {\n+            closer = empty(methodType(void.class, Throwable.class)); \/\/ (Throwable) -> void\n+            insertPos = 1;\n+        } else {\n+            closer = identity(specializedHandle.type().returnType()); \/\/ (V) -> V\n+            closer = dropArguments(closer, 0, Throwable.class); \/\/ (Throwable, V) -> V\n+            insertPos = 2;\n+        }\n+\n+        \/\/ downcalls get the leading Addressable\/SegmentAllocator param as well\n+        if (!upcall) {\n+            closer = collectArguments(closer, insertPos++, reachabilityFenceHandle(Addressable.class));\n+            closer = dropArguments(closer, insertPos++, SegmentAllocator.class); \/\/ (Throwable, V?, Addressable, SegmentAllocator) -> V\/void\n+        }\n+\n+        closer = collectArguments(closer, insertPos++, MH_CLOSE_CONTEXT); \/\/ (Throwable, V?, Addressable?, BindingContext) -> V\/void\n+\n+        if (!upcall) {\n+            \/\/ now for each Addressable parameter, add a reachability fence\n+            MethodType specType = specializedHandle.type();\n+            \/\/ skip 3 for address, segment allocator, and binding context\n+            for (int i = 3; i < specType.parameterCount(); i++) {\n+                Class<?> param = specType.parameterType(i);\n+                if (Addressable.class.isAssignableFrom(param)) {\n+                    closer = collectArguments(closer, insertPos++, reachabilityFenceHandle(param));\n+                } else {\n+                    closer = dropArguments(closer, insertPos++, param);\n+                }\n+            }\n+        }\n+\n+        MethodHandle contextFactory;\n+\n+        if (bufferCopySize > 0) {\n+            contextFactory = MethodHandles.insertArguments(MH_MAKE_CONTEXT_BOUNDED_ALLOCATOR, 0, bufferCopySize);\n+        } else if (upcall) {\n+            contextFactory = MH_MAKE_CONTEXT_NO_ALLOCATOR;\n+        } else {\n+            \/\/ this path is probably never used now, since ProgrammableInvoker never calls this routine with bufferCopySize == 0\n+            contextFactory = constant(Binding.Context.class, Binding.Context.DUMMY);\n+        }\n+\n+        specializedHandle = tryFinally(specializedHandle, closer);\n+        specializedHandle = collectArguments(specializedHandle, allocatorPos, contextFactory);\n+        return specializedHandle;\n+    }\n+\n@@ -270,1 +418,1 @@\n-        final static LibraryLookup LOOKUP = LibraryLookup.ofDefault();\n+        static final LibraryLookup LOOKUP = LibraryLookup.ofDefault();\n@@ -272,1 +420,1 @@\n-        final static MethodHandle MH_MALLOC = getSystemLinker().downcallHandle(LOOKUP.lookup(\"malloc\").get(),\n+        static final MethodHandle MH_MALLOC = getSystemLinker().downcallHandle(LOOKUP.lookup(\"malloc\").get(),\n@@ -276,1 +424,1 @@\n-        final static MethodHandle MH_FREE = getSystemLinker().downcallHandle(LOOKUP.lookup(\"free\").get(),\n+        static final MethodHandle MH_FREE = getSystemLinker().downcallHandle(LOOKUP.lookup(\"free\").get(),\n@@ -297,1 +445,1 @@\n-    public static VaList newVaList(Consumer<VaList.Builder> actions, Allocator allocator) {\n+    public static VaList newVaList(Consumer<VaList.Builder> actions, ResourceScope scope) {\n@@ -299,3 +447,3 @@\n-            case Win64 -> Windowsx64Linker.newVaList(actions, allocator);\n-            case SysV -> SysVx64Linker.newVaList(actions, allocator);\n-            case AArch64 -> AArch64Linker.newVaList(actions, allocator);\n+            case Win64 -> Windowsx64Linker.newVaList(actions, scope);\n+            case SysV -> SysVx64Linker.newVaList(actions, scope);\n+            case AArch64 -> AArch64Linker.newVaList(actions, scope);\n@@ -307,1 +455,1 @@\n-            ? MemoryHandles.asAddressVarHandle(layout.varHandle(primitiveCarrierForSize(layout.byteSize())))\n+            ? MemoryHandles.asAddressVarHandle(layout.varHandle(primitiveCarrierForSize(layout.byteSize(), false)))\n@@ -311,1 +459,1 @@\n-    public static VaList newVaListOfAddress(MemoryAddress ma) {\n+    public static VaList newVaListOfAddress(MemoryAddress ma, ResourceScope scope) {\n@@ -313,3 +461,3 @@\n-            case Win64 -> Windowsx64Linker.newVaListOfAddress(ma);\n-            case SysV -> SysVx64Linker.newVaListOfAddress(ma);\n-            case AArch64 -> AArch64Linker.newVaListOfAddress(ma);\n+            case Win64 -> Windowsx64Linker.newVaListOfAddress(ma, scope);\n+            case SysV -> SysVx64Linker.newVaListOfAddress(ma, scope);\n+            case AArch64 -> AArch64Linker.newVaListOfAddress(ma, scope);\n@@ -339,1 +487,1 @@\n-               handle = MethodHandles.filterArguments(handle, i, unboxer);\n+               handle = filterArguments(handle, i + 1, unboxer); \/\/ +1 for leading address\n@@ -349,1 +497,1 @@\n-               handle = MethodHandles.filterArguments(handle, i, boxer);\n+               handle = filterArguments(handle, i, boxer);\n@@ -368,31 +516,0 @@\n-    public interface Allocator extends AutoCloseable {\n-        Allocator THROWING_ALLOCATOR = (size, align) -> { throw new UnsupportedOperationException(\"Null allocator\"); };\n-\n-        default MemorySegment allocate(MemoryLayout layout) {\n-            return allocate(layout.byteSize(), layout.byteAlignment());\n-        }\n-\n-        default MemorySegment allocate(long size) {\n-            return allocate(size, 1);\n-        }\n-\n-        @Override\n-        default void close() {}\n-\n-        MemorySegment allocate(long size, long align);\n-\n-        static Allocator ofScope(NativeScope scope) {\n-            return new Allocator() {\n-                @Override\n-                public MemorySegment allocate(long size, long align) {\n-                    return scope.allocate(size, align);\n-                }\n-\n-                @Override\n-                public void close() {\n-                    scope.close();\n-                }\n-            };\n-        }\n-    }\n-\n@@ -412,1 +529,1 @@\n-                ? MemoryHandles.asAddressVarHandle(layout.varHandle(primitiveCarrierForSize(layout.byteSize())))\n+                ? MemoryHandles.asAddressVarHandle(layout.varHandle(primitiveCarrierForSize(layout.byteSize(), false)))\n@@ -417,1 +534,1 @@\n-    public static class EmptyVaList implements VaList {\n+    public static non-sealed class EmptyVaList implements VaList {\n@@ -450,1 +567,1 @@\n-        public MemorySegment vargAsSegment(MemoryLayout layout) {\n+        public MemorySegment vargAsSegment(MemoryLayout layout, SegmentAllocator allocator) {\n@@ -455,1 +572,1 @@\n-        public MemorySegment vargAsSegment(MemoryLayout layout, NativeScope scope) {\n+        public MemorySegment vargAsSegment(MemoryLayout layout, ResourceScope scope) {\n@@ -465,7 +582,2 @@\n-        public boolean isAlive() {\n-            return true;\n-        }\n-\n-        @Override\n-        public void close() {\n-            throw uoe();\n+        public ResourceScope scope() {\n+            return ResourceScope.globalScope();\n@@ -479,5 +591,0 @@\n-        @Override\n-        public VaList copy(NativeScope scope) {\n-            throw uoe();\n-        }\n-\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/SharedUtils.java","additions":201,"deletions":94,"binary":false,"changes":295,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-import jdk.internal.foreign.MemoryAddressImpl;\n+import jdk.internal.foreign.ResourceScopeImpl;\n@@ -34,1 +34,1 @@\n-    public static MemorySegment upcallAddress(UpcallHandler handler) {\n+    public static MemoryAddress upcallAddress(UpcallHandler handler, ResourceScopeImpl scope) {\n@@ -36,5 +36,3 @@\n-        return NativeMemorySegmentImpl.makeNativeSegmentUnchecked(\n-                MemoryAddress.ofLong(stubAddress), 0, () -> freeUpcallStub(stubAddress), null)\n-                .share()\n-                .withAccessModes(MemorySegment.CLOSE | MemorySegment.HANDOFF | MemorySegment.SHARE);\n-    };\n+        return NativeMemorySegmentImpl.makeNativeSegmentUnchecked(MemoryAddress.ofLong(stubAddress), 0,\n+                () -> freeUpcallStub(stubAddress), scope).address();\n+    }\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/UpcallStubs.java","additions":5,"deletions":7,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-import jdk.incubator.foreign.Addressable;\n@@ -31,1 +30,0 @@\n-import jdk.incubator.foreign.MemoryLayout;\n@@ -33,1 +31,3 @@\n-import jdk.incubator.foreign.CLinker;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.internal.foreign.AbstractCLinker;\n+import jdk.internal.foreign.ResourceScopeImpl;\n@@ -43,2 +43,0 @@\n-import static jdk.internal.foreign.PlatformLayouts.*;\n-\n@@ -49,1 +47,1 @@\n-public class AArch64Linker implements CLinker {\n+public final class AArch64Linker extends AbstractCLinker {\n@@ -62,2 +60,2 @@\n-            MH_boxVaList = lookup.findStatic(AArch64Linker.class, \"newVaListOfAddress\",\n-                MethodType.methodType(VaList.class, MemoryAddress.class));\n+            MH_boxVaList = MethodHandles.insertArguments(lookup.findStatic(AArch64Linker.class, \"newVaListOfAddress\",\n+                MethodType.methodType(VaList.class, MemoryAddress.class, ResourceScope.class)), 1, ResourceScope.globalScope());\n@@ -77,2 +75,1 @@\n-    public MethodHandle downcallHandle(Addressable symbol, MethodType type, FunctionDescriptor function) {\n-        Objects.requireNonNull(symbol);\n+    public final MethodHandle downcallHandle(MethodType type, FunctionDescriptor function) {\n@@ -82,1 +79,5 @@\n-        MethodHandle handle = CallArranger.arrangeDowncall(symbol, llMt, function);\n+        MethodHandle handle = CallArranger.arrangeDowncall(llMt, function);\n+        if (!type.returnType().equals(MemorySegment.class)) {\n+            \/\/ not returning segment, just insert a throwing allocator\n+            handle = MethodHandles.insertArguments(handle, 1, SharedUtils.THROWING_ALLOCATOR);\n+        }\n@@ -88,1 +89,2 @@\n-    public MemorySegment upcallStub(MethodHandle target, FunctionDescriptor function) {\n+    public final MemoryAddress upcallStub(MethodHandle target, FunctionDescriptor function, ResourceScope scope) {\n+        Objects.requireNonNull(scope);\n@@ -92,1 +94,1 @@\n-        return UpcallStubs.upcallAddress(CallArranger.arrangeUpcall(target, target.type(), function));\n+        return UpcallStubs.upcallAddress(CallArranger.arrangeUpcall(target, target.type(), function), (ResourceScopeImpl) scope);\n@@ -95,2 +97,2 @@\n-    public static VaList newVaList(Consumer<VaList.Builder> actions, SharedUtils.Allocator allocator) {\n-        AArch64VaList.Builder builder = AArch64VaList.builder(allocator);\n+    public static VaList newVaList(Consumer<VaList.Builder> actions, ResourceScope scope) {\n+        AArch64VaList.Builder builder = AArch64VaList.builder(scope);\n@@ -101,2 +103,2 @@\n-    public static VaList newVaListOfAddress(MemoryAddress ma) {\n-        return AArch64VaList.ofAddress(ma);\n+    public static VaList newVaListOfAddress(MemoryAddress ma, ResourceScope scope) {\n+        return AArch64VaList.ofAddress(ma, scope);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/AArch64Linker.java","additions":20,"deletions":18,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import jdk.internal.foreign.NativeMemorySegmentImpl;\n@@ -45,0 +44,1 @@\n+import static jdk.internal.foreign.abi.SharedUtils.THROWING_ALLOCATOR;\n@@ -49,1 +49,1 @@\n-public class AArch64VaList implements VaList {\n+public non-sealed class AArch64VaList implements VaList {\n@@ -65,1 +65,1 @@\n-    static final GroupLayout LAYOUT = MemoryLayout.ofStruct(\n+    static final GroupLayout LAYOUT = MemoryLayout.structLayout(\n@@ -74,1 +74,1 @@\n-        = MemoryLayout.ofValueBits(64, ByteOrder.nativeOrder());\n+        = MemoryLayout.valueLayout(64, ByteOrder.nativeOrder());\n@@ -76,1 +76,1 @@\n-        = MemoryLayout.ofValueBits(128, ByteOrder.nativeOrder());\n+        = MemoryLayout.valueLayout(128, ByteOrder.nativeOrder());\n@@ -79,1 +79,1 @@\n-        = MemoryLayout.ofSequence(MAX_REGISTER_ARGUMENTS, GP_REG);\n+        = MemoryLayout.sequenceLayout(MAX_REGISTER_ARGUMENTS, GP_REG);\n@@ -81,1 +81,1 @@\n-        = MemoryLayout.ofSequence(MAX_REGISTER_ARGUMENTS, FP_REG);\n+        = MemoryLayout.sequenceLayout(MAX_REGISTER_ARGUMENTS, FP_REG);\n@@ -107,1 +107,0 @@\n-    private final List<MemorySegment> attachedSegments;\n@@ -109,2 +108,1 @@\n-    private AArch64VaList(MemorySegment segment, MemorySegment gpRegsArea, MemorySegment fpRegsArea,\n-                          List<MemorySegment> attachedSegments) {\n+    private AArch64VaList(MemorySegment segment, MemorySegment gpRegsArea, MemorySegment fpRegsArea) {\n@@ -114,1 +112,0 @@\n-        this.attachedSegments = attachedSegments;\n@@ -118,2 +115,2 @@\n-        MemorySegment gpRegsArea = handoffIfNeeded(grTop(segment).addOffset(-MAX_GP_OFFSET)\n-                .asSegmentRestricted(MAX_GP_OFFSET), segment.ownerThread());\n+        MemorySegment gpRegsArea = grTop(segment).addOffset(-MAX_GP_OFFSET).asSegment(\n+                MAX_GP_OFFSET, segment.scope());\n@@ -121,3 +118,3 @@\n-        MemorySegment fpRegsArea = handoffIfNeeded(vrTop(segment).addOffset(-MAX_FP_OFFSET)\n-                .asSegmentRestricted(MAX_FP_OFFSET), segment.ownerThread());\n-        return new AArch64VaList(segment, gpRegsArea, fpRegsArea, List.of(gpRegsArea, fpRegsArea));\n+        MemorySegment fpRegsArea = vrTop(segment).addOffset(-MAX_FP_OFFSET).asSegment(\n+                MAX_FP_OFFSET, segment.scope());\n+        return new AArch64VaList(segment, gpRegsArea, fpRegsArea);\n@@ -128,4 +125,3 @@\n-        MemorySegment ms = MemoryAddress.ofLong(ptr)\n-                .asSegmentRestricted(LAYOUT.byteSize(), () -> U.freeMemory(ptr), null)\n-                .share();\n-        cleaner.register(AArch64VaList.class, ms::close);\n+        MemorySegment ms = MemoryAddress.ofLong(ptr).asSegment(\n+                LAYOUT.byteSize(), () -> U.freeMemory(ptr), ResourceScope.newSharedScope());\n+        cleaner.register(AArch64VaList.class, () -> ms.scope().close());\n@@ -237,2 +233,3 @@\n-    public MemorySegment vargAsSegment(MemoryLayout layout) {\n-        return (MemorySegment) read(MemorySegment.class, layout);\n+    public MemorySegment vargAsSegment(MemoryLayout layout, SegmentAllocator allocator) {\n+        Objects.requireNonNull(allocator);\n+        return (MemorySegment) read(MemorySegment.class, layout, allocator);\n@@ -242,3 +239,2 @@\n-    public MemorySegment vargAsSegment(MemoryLayout layout, NativeScope scope) {\n-        Objects.requireNonNull(scope);\n-        return (MemorySegment) read(MemorySegment.class, layout, SharedUtils.Allocator.ofScope(scope));\n+    public MemorySegment vargAsSegment(MemoryLayout layout, ResourceScope scope) {\n+        return vargAsSegment(layout, SegmentAllocator.ofScope(scope));\n@@ -248,1 +244,1 @@\n-        return read(carrier, layout, MemorySegment::allocateNative);\n+        return read(carrier, layout, THROWING_ALLOCATOR);\n@@ -251,1 +247,1 @@\n-    private Object read(Class<?> carrier, MemoryLayout layout, SharedUtils.Allocator allocator) {\n+    private Object read(Class<?> carrier, MemoryLayout layout, SegmentAllocator allocator) {\n@@ -260,7 +256,5 @@\n-                    try (MemorySegment slice = handoffIfNeeded(stackPtr()\n-                            .asSegmentRestricted(layout.byteSize()), segment.ownerThread())) {\n-                        MemorySegment seg = allocator.allocate(layout);\n-                        seg.copyFrom(slice);\n-                        postAlignStack(layout);\n-                        yield seg;\n-                    }\n+                    MemorySegment slice = stackPtr().asSegment(layout.byteSize(), scope());\n+                    MemorySegment seg = allocator.allocate(layout);\n+                    seg.copyFrom(slice);\n+                    postAlignStack(layout);\n+                    yield seg;\n@@ -270,6 +264,4 @@\n-                    try (MemorySegment slice = handoffIfNeeded(stackPtr()\n-                            .asSegmentRestricted(layout.byteSize()), segment.ownerThread())) {\n-                        Object res = reader.get(slice);\n-                        postAlignStack(layout);\n-                        yield res;\n-                    }\n+                    MemorySegment slice = stackPtr().asSegment(layout.byteSize(), scope());\n+                    Object res = reader.get(slice);\n+                    postAlignStack(layout);\n+                    yield res;\n@@ -317,6 +309,4 @@\n-                    try (MemorySegment slice = handoffIfNeeded(ptr\n-                            .asSegmentRestricted(layout.byteSize()), segment.ownerThread())) {\n-                        MemorySegment seg = allocator.allocate(layout);\n-                        seg.copyFrom(slice);\n-                        yield seg;\n-                    }\n+                    MemorySegment slice = ptr.asSegment(layout.byteSize(), scope());\n+                    MemorySegment seg = allocator.allocate(layout);\n+                    seg.copyFrom(slice);\n+                    yield seg;\n@@ -359,2 +349,2 @@\n-    static AArch64VaList.Builder builder(SharedUtils.Allocator allocator) {\n-        return new AArch64VaList.Builder(allocator);\n+    static AArch64VaList.Builder builder(ResourceScope scope) {\n+        return new AArch64VaList.Builder(scope);\n@@ -363,7 +353,2 @@\n-    public static VaList ofAddress(MemoryAddress ma) {\n-        return readFromSegment(ma.asSegmentRestricted(LAYOUT.byteSize()));\n-    }\n-\n-    @Override\n-    public boolean isAlive() {\n-        return segment.isAlive();\n+    public static VaList ofAddress(MemoryAddress ma, ResourceScope scope) {\n+        return readFromSegment(ma.asSegment(LAYOUT.byteSize(), scope));\n@@ -373,3 +358,2 @@\n-    public void close() {\n-        segment.close();\n-        attachedSegments.forEach(MemorySegment::close);\n+    public ResourceScope scope() {\n+        return segment.scope();\n@@ -380,11 +364,1 @@\n-        return copy(MemorySegment::allocateNative);\n-    }\n-\n-    @Override\n-    public VaList copy(NativeScope scope) {\n-        Objects.requireNonNull(scope);\n-        return copy(SharedUtils.Allocator.ofScope(scope));\n-    }\n-\n-    private VaList copy(SharedUtils.Allocator allocator) {\n-        MemorySegment copy = allocator.allocate(LAYOUT);\n+        MemorySegment copy = MemorySegment.allocateNative(LAYOUT, segment.scope());\n@@ -392,1 +366,1 @@\n-        return new AArch64VaList(copy, gpRegsArea, fpRegsArea, List.of());\n+        return new AArch64VaList(copy, gpRegsArea, fpRegsArea);\n@@ -426,2 +400,2 @@\n-    static class Builder implements VaList.Builder {\n-        private final SharedUtils.Allocator allocator;\n+    public static non-sealed class Builder implements VaList.Builder {\n+        private final ResourceScope scope;\n@@ -435,4 +409,4 @@\n-        Builder(SharedUtils.Allocator allocator) {\n-            this.allocator = allocator;\n-            this.gpRegs = allocator.allocate(LAYOUT_GP_REGS);\n-            this.fpRegs = allocator.allocate(LAYOUT_FP_REGS);\n+        Builder(ResourceScope scope) {\n+            this.scope = scope;\n+            this.gpRegs = MemorySegment.allocateNative(LAYOUT_GP_REGS, scope);\n+            this.fpRegs = MemorySegment.allocateNative(LAYOUT_FP_REGS, scope);\n@@ -537,0 +511,1 @@\n+            SegmentAllocator allocator = SegmentAllocator.arenaAllocator(scope);\n@@ -538,1 +513,0 @@\n-            List<MemorySegment> attachedSegments = new ArrayList<>();\n@@ -552,1 +526,0 @@\n-                attachedSegments.add(stackArgsSegment);\n@@ -561,5 +534,3 @@\n-            attachedSegments.add(gpRegs);\n-            attachedSegments.add(fpRegs);\n-            assert gpRegs.ownerThread() == vaListSegment.ownerThread();\n-            assert fpRegs.ownerThread() == vaListSegment.ownerThread();\n-            return new AArch64VaList(vaListSegment, gpRegs, fpRegs, attachedSegments);\n+            assert gpRegs.scope().ownerThread() == vaListSegment.scope().ownerThread();\n+            assert fpRegs.scope().ownerThread() == vaListSegment.scope().ownerThread();\n+            return new AArch64VaList(vaListSegment, gpRegs, fpRegs);\n@@ -568,5 +539,0 @@\n-\n-    private static MemorySegment handoffIfNeeded(MemorySegment segment, Thread thread) {\n-        return segment.ownerThread() == thread ?\n-                segment : segment.handoff(thread);\n-    }\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/AArch64VaList.java","additions":54,"deletions":88,"binary":false,"changes":142,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-import jdk.incubator.foreign.Addressable;\n@@ -34,1 +33,0 @@\n-import jdk.internal.foreign.PlatformLayouts;\n@@ -129,1 +127,1 @@\n-    public static MethodHandle arrangeDowncall(Addressable addr, MethodType mt, FunctionDescriptor cDesc) {\n+    public static MethodHandle arrangeDowncall(MethodType mt, FunctionDescriptor cDesc) {\n@@ -132,1 +130,1 @@\n-        MethodHandle handle = new ProgrammableInvoker(C, addr, bindings.callingSequence).getBoundMethodHandle();\n+        MethodHandle handle = new ProgrammableInvoker(C, bindings.callingSequence).getBoundMethodHandle();\n@@ -145,1 +143,1 @@\n-            target = SharedUtils.adaptUpcallForIMR(target);\n+            target = SharedUtils.adaptUpcallForIMR(target, true \/* drop return, since we don't have bindings for it *\/);\n@@ -148,1 +146,1 @@\n-        return new ProgrammableUpcallHandler(C, target, bindings.callingSequence);\n+        return ProgrammableUpcallHandler.make(C, target, bindings.callingSequence);\n@@ -235,1 +233,1 @@\n-                Class<?> type = SharedUtils.primitiveCarrierForSize(copy);\n+                Class<?> type = SharedUtils.primitiveCarrierForSize(copy, false);\n@@ -253,1 +251,1 @@\n-                Class<?> type = SharedUtils.primitiveCarrierForSize(copy);\n+                Class<?> type = SharedUtils.primitiveCarrierForSize(copy, false);\n@@ -294,1 +292,2 @@\n-                            Class<?> type = SharedUtils.primitiveCarrierForSize(copy);\n+                            boolean useFloat = storage.type() == StorageClasses.VECTOR;\n+                            Class<?> type = SharedUtils.primitiveCarrierForSize(copy, useFloat);\n@@ -327,1 +326,2 @@\n-                            Class<?> type = SharedUtils.primitiveCarrierForSize(size);\n+                            boolean useFloat = storage.type() == StorageClasses.VECTOR;\n+                            Class<?> type = SharedUtils.primitiveCarrierForSize(size, useFloat);\n@@ -396,1 +396,2 @@\n-                            Class<?> type = SharedUtils.primitiveCarrierForSize(copy);\n+                            boolean useFloat = storage.type() == StorageClasses.VECTOR;\n+                            Class<?> type = SharedUtils.primitiveCarrierForSize(copy, useFloat);\n@@ -413,3 +414,0 @@\n-                    \/\/ ASSERT SCOPE OF BOXED ADDRESS HERE\n-                    \/\/ caveat. buffer should instead go out of scope after call\n-                    bindings.copy(layout);\n@@ -429,1 +427,2 @@\n-                            Class<?> type = SharedUtils.primitiveCarrierForSize(size);\n+                            boolean useFloat = storage.type() == StorageClasses.VECTOR;\n+                            Class<?> type = SharedUtils.primitiveCarrierForSize(size, useFloat);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/CallArranger.java","additions":15,"deletions":16,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-import jdk.incubator.foreign.Addressable;\n@@ -34,1 +33,0 @@\n-import jdk.internal.foreign.PlatformLayouts;\n@@ -126,1 +124,1 @@\n-    public static MethodHandle arrangeDowncall(Addressable addr, MethodType mt, FunctionDescriptor cDesc) {\n+    public static MethodHandle arrangeDowncall(MethodType mt, FunctionDescriptor cDesc) {\n@@ -129,1 +127,1 @@\n-        MethodHandle handle = new ProgrammableInvoker(CSysV, addr, bindings.callingSequence).getBoundMethodHandle();\n+        MethodHandle handle = new ProgrammableInvoker(CSysV, bindings.callingSequence).getBoundMethodHandle();\n@@ -143,1 +141,1 @@\n-            target = SharedUtils.adaptUpcallForIMR(target);\n+            target = SharedUtils.adaptUpcallForIMR(target, true \/* drop return, since we don't have bindings for it *\/);\n@@ -146,1 +144,1 @@\n-        return new ProgrammableUpcallHandler(CSysV, target, bindings.callingSequence);\n+        return ProgrammableUpcallHandler.make(CSysV, target, bindings.callingSequence);\n@@ -273,1 +271,0 @@\n-                        Class<?> type = SharedUtils.primitiveCarrierForSize(copy);\n@@ -277,0 +274,2 @@\n+                        boolean useFloat = storage.type() == StorageClasses.VECTOR;\n+                        Class<?> type = SharedUtils.primitiveCarrierForSize(copy, useFloat);\n@@ -327,1 +326,2 @@\n-                        Class<?> type = SharedUtils.primitiveCarrierForSize(copy);\n+                        boolean useFloat = storage.type() == StorageClasses.VECTOR;\n+                        Class<?> type = SharedUtils.primitiveCarrierForSize(copy, useFloat);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/CallArranger.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import jdk.internal.foreign.NativeMemorySegmentImpl;\n@@ -45,0 +44,1 @@\n+import static jdk.internal.foreign.abi.SharedUtils.THROWING_ALLOCATOR;\n@@ -49,1 +49,1 @@\n-public class SysVVaList implements VaList {\n+public non-sealed class SysVVaList implements VaList {\n@@ -63,1 +63,1 @@\n-    static final GroupLayout LAYOUT = MemoryLayout.ofStruct(\n+    static final GroupLayout LAYOUT = MemoryLayout.structLayout(\n@@ -70,2 +70,2 @@\n-    private static final MemoryLayout GP_REG = MemoryLayout.ofValueBits(64, ByteOrder.nativeOrder());\n-    private static final MemoryLayout FP_REG = MemoryLayout.ofValueBits(128, ByteOrder.nativeOrder());\n+    private static final MemoryLayout GP_REG = MemoryLayout.valueLayout(64, ByteOrder.nativeOrder());\n+    private static final MemoryLayout FP_REG = MemoryLayout.valueLayout(128, ByteOrder.nativeOrder());\n@@ -73,1 +73,1 @@\n-    private static final GroupLayout LAYOUT_REG_SAVE_AREA = MemoryLayout.ofStruct(\n+    private static final GroupLayout LAYOUT_REG_SAVE_AREA = MemoryLayout.structLayout(\n@@ -120,1 +120,0 @@\n-    private final List<MemorySegment> attachedSegments;\n@@ -122,1 +121,1 @@\n-    private SysVVaList(MemorySegment segment, MemorySegment regSaveArea, List<MemorySegment> attachedSegments) {\n+    private SysVVaList(MemorySegment segment, MemorySegment regSaveArea) {\n@@ -125,1 +124,0 @@\n-        this.attachedSegments = attachedSegments;\n@@ -130,1 +128,1 @@\n-        return new SysVVaList(segment, regSaveArea, List.of(regSaveArea));\n+        return new SysVVaList(segment, regSaveArea);\n@@ -135,4 +133,3 @@\n-        MemorySegment base = MemoryAddress.ofLong(ptr)\n-                .asSegmentRestricted(LAYOUT.byteSize(), () -> U.freeMemory(ptr), null)\n-                .share();\n-        cleaner.register(SysVVaList.class, base::close);\n+        MemorySegment base = MemoryAddress.ofLong(ptr).asSegment(\n+                LAYOUT.byteSize(), () -> U.freeMemory(ptr), ResourceScope.newSharedScope());\n+        cleaner.register(SysVVaList.class, () -> base.scope().close());\n@@ -143,1 +140,1 @@\n-        return base.withAccessModes(0).address();\n+        return base.address();\n@@ -179,2 +176,2 @@\n-        return handoffIfNeeded(((MemoryAddress)VH_reg_save_area.get(segment))\n-                .asSegmentRestricted(LAYOUT_REG_SAVE_AREA.byteSize()), segment.ownerThread());\n+        return ((MemoryAddress)VH_reg_save_area.get(segment)).asSegment(\n+                LAYOUT_REG_SAVE_AREA.byteSize(), segment.scope());\n@@ -214,2 +211,3 @@\n-    public MemorySegment vargAsSegment(MemoryLayout layout) {\n-        return (MemorySegment) read(MemorySegment.class, layout);\n+    public MemorySegment vargAsSegment(MemoryLayout layout, SegmentAllocator allocator) {\n+        Objects.requireNonNull(allocator);\n+        return (MemorySegment) read(MemorySegment.class, layout, allocator);\n@@ -219,3 +217,2 @@\n-    public MemorySegment vargAsSegment(MemoryLayout layout, NativeScope scope) {\n-        Objects.requireNonNull(scope);\n-        return (MemorySegment) read(MemorySegment.class, layout, SharedUtils.Allocator.ofScope(scope));\n+    public MemorySegment vargAsSegment(MemoryLayout layout, ResourceScope scope) {\n+        return vargAsSegment(layout, SegmentAllocator.ofScope(scope));\n@@ -225,1 +222,1 @@\n-        return read(carrier, layout, MemorySegment::allocateNative);\n+        return read(carrier, layout, THROWING_ALLOCATOR);\n@@ -228,1 +225,1 @@\n-    private Object read(Class<?> carrier, MemoryLayout layout, SharedUtils.Allocator allocator) {\n+    private Object read(Class<?> carrier, MemoryLayout layout, SegmentAllocator allocator) {\n@@ -237,7 +234,5 @@\n-                    try (MemorySegment slice = handoffIfNeeded(stackPtr()\n-                            .asSegmentRestricted(layout.byteSize()), segment.ownerThread())) {\n-                        MemorySegment seg = allocator.allocate(layout);\n-                        seg.copyFrom(slice);\n-                        postAlignStack(layout);\n-                        yield seg;\n-                    }\n+                    MemorySegment slice = stackPtr().asSegment(layout.byteSize(), scope());\n+                    MemorySegment seg = allocator.allocate(layout);\n+                    seg.copyFrom(slice);\n+                    postAlignStack(layout);\n+                    yield seg;\n@@ -247,2 +242,2 @@\n-                    try (MemorySegment slice = handoffIfNeeded(stackPtr()\n-                            .asSegmentRestricted(layout.byteSize()), segment.ownerThread())) {\n+                    try (ResourceScope localScope = ResourceScope.newConfinedScope()) {\n+                        MemorySegment slice = stackPtr().asSegment(layout.byteSize(), localScope);\n@@ -308,6 +303,2 @@\n-    static SysVVaList.Builder builder(SharedUtils.Allocator allocator) {\n-        return new SysVVaList.Builder(allocator);\n-    }\n-\n-    public static VaList ofAddress(MemoryAddress ma) {\n-        return readFromSegment(ma.asSegmentRestricted(LAYOUT.byteSize()));\n+    static SysVVaList.Builder builder(ResourceScope scope) {\n+        return new SysVVaList.Builder(scope);\n@@ -316,3 +307,2 @@\n-    @Override\n-    public boolean isAlive() {\n-        return segment.isAlive();\n+    public static VaList ofAddress(MemoryAddress ma, ResourceScope scope) {\n+        return readFromSegment(ma.asSegment(LAYOUT.byteSize(), scope));\n@@ -322,3 +312,2 @@\n-    public void close() {\n-        segment.close();\n-        attachedSegments.forEach(MemorySegment::close);\n+    public ResourceScope scope() {\n+        return segment.scope();\n@@ -329,11 +318,1 @@\n-        return copy(MemorySegment::allocateNative);\n-    }\n-\n-    @Override\n-    public VaList copy(NativeScope scope) {\n-        Objects.requireNonNull(scope);\n-        return copy(SharedUtils.Allocator.ofScope(scope));\n-    }\n-\n-    private VaList copy(SharedUtils.Allocator allocator) {\n-        MemorySegment copy = allocator.allocate(LAYOUT);\n+        MemorySegment copy = MemorySegment.allocateNative(LAYOUT, segment.scope());\n@@ -341,1 +320,1 @@\n-        return new SysVVaList(copy, regSaveArea, List.of());\n+        return new SysVVaList(copy, regSaveArea);\n@@ -364,2 +343,2 @@\n-    static class Builder implements VaList.Builder {\n-        private final SharedUtils.Allocator allocator;\n+    public static non-sealed class Builder implements VaList.Builder {\n+        private final ResourceScope scope;\n@@ -371,3 +350,3 @@\n-        public Builder(SharedUtils.Allocator allocator) {\n-            this.allocator = allocator;\n-            this.reg_save_area = allocator.allocate(LAYOUT_REG_SAVE_AREA);\n+        public Builder(ResourceScope scope) {\n+            this.scope = scope;\n+            this.reg_save_area = MemorySegment.allocateNative(LAYOUT_REG_SAVE_AREA, scope);\n@@ -454,0 +433,1 @@\n+            SegmentAllocator allocator = SegmentAllocator.arenaAllocator(scope);\n@@ -455,1 +435,0 @@\n-            List<MemorySegment> attachedSegments = new ArrayList<>();\n@@ -474,1 +453,0 @@\n-                attachedSegments.add(stackArgsSegment);\n@@ -480,3 +458,2 @@\n-            attachedSegments.add(reg_save_area);\n-            assert reg_save_area.ownerThread() == vaListSegment.ownerThread();\n-            return new SysVVaList(vaListSegment, reg_save_area, attachedSegments);\n+            assert reg_save_area.scope().ownerThread() == vaListSegment.scope().ownerThread();\n+            return new SysVVaList(vaListSegment, reg_save_area);\n@@ -485,5 +462,0 @@\n-\n-    private static MemorySegment handoffIfNeeded(MemorySegment segment, Thread thread) {\n-        return segment.ownerThread() == thread ?\n-            segment : segment.handoff(thread);\n-    }\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/SysVVaList.java","additions":44,"deletions":72,"binary":false,"changes":116,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n-import jdk.incubator.foreign.Addressable;\n+\n@@ -30,1 +30,0 @@\n-import jdk.incubator.foreign.MemoryLayout;\n@@ -32,1 +31,3 @@\n-import jdk.incubator.foreign.CLinker;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.internal.foreign.AbstractCLinker;\n+import jdk.internal.foreign.ResourceScopeImpl;\n@@ -40,1 +41,0 @@\n-import java.util.Optional;\n@@ -43,2 +43,0 @@\n-import static jdk.internal.foreign.PlatformLayouts.*;\n-\n@@ -48,1 +46,1 @@\n-public class SysVx64Linker implements CLinker {\n+public final class SysVx64Linker extends AbstractCLinker {\n@@ -67,2 +65,2 @@\n-            MH_boxVaList = lookup.findStatic(SysVx64Linker.class, \"newVaListOfAddress\",\n-                MethodType.methodType(VaList.class, MemoryAddress.class));\n+            MH_boxVaList = MethodHandles.insertArguments(lookup.findStatic(SysVx64Linker.class, \"newVaListOfAddress\",\n+                MethodType.methodType(VaList.class, MemoryAddress.class, ResourceScope.class)), 1, ResourceScope.globalScope());\n@@ -81,2 +79,2 @@\n-    public static VaList newVaList(Consumer<VaList.Builder> actions, SharedUtils.Allocator allocator) {\n-        SysVVaList.Builder builder = SysVVaList.builder(allocator);\n+    public static VaList newVaList(Consumer<VaList.Builder> actions, ResourceScope scope) {\n+        SysVVaList.Builder builder = SysVVaList.builder(scope);\n@@ -88,2 +86,1 @@\n-    public MethodHandle downcallHandle(Addressable symbol, MethodType type, FunctionDescriptor function) {\n-        Objects.requireNonNull(symbol);\n+    public final MethodHandle downcallHandle(MethodType type, FunctionDescriptor function) {\n@@ -93,1 +90,5 @@\n-        MethodHandle handle = CallArranger.arrangeDowncall(symbol, llMt, function);\n+        MethodHandle handle = CallArranger.arrangeDowncall(llMt, function);\n+        if (!type.returnType().equals(MemorySegment.class)) {\n+            \/\/ not returning segment, just insert a throwing allocator\n+            handle = MethodHandles.insertArguments(handle, 1, SharedUtils.THROWING_ALLOCATOR);\n+        }\n@@ -99,1 +100,2 @@\n-    public MemorySegment upcallStub(MethodHandle target, FunctionDescriptor function) {\n+    public final MemoryAddress upcallStub(MethodHandle target, FunctionDescriptor function, ResourceScope scope) {\n+        Objects.requireNonNull(scope);\n@@ -103,1 +105,1 @@\n-        return UpcallStubs.upcallAddress(CallArranger.arrangeUpcall(target, target.type(), function));\n+        return UpcallStubs.upcallAddress(CallArranger.arrangeUpcall(target, target.type(), function), (ResourceScopeImpl) scope);\n@@ -106,2 +108,2 @@\n-    public static VaList newVaListOfAddress(MemoryAddress ma) {\n-        return SysVVaList.ofAddress(ma);\n+    public static VaList newVaListOfAddress(MemoryAddress ma, ResourceScope scope) {\n+        return SysVVaList.ofAddress(ma, scope);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/SysVx64Linker.java","additions":21,"deletions":19,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,0 @@\n-import jdk.incubator.foreign.Addressable;\n@@ -33,1 +32,0 @@\n-import jdk.internal.foreign.PlatformLayouts;\n@@ -127,1 +125,1 @@\n-    public static MethodHandle arrangeDowncall(Addressable addr, MethodType mt, FunctionDescriptor cDesc) {\n+    public static MethodHandle arrangeDowncall(MethodType mt, FunctionDescriptor cDesc) {\n@@ -130,1 +128,1 @@\n-        MethodHandle handle = new ProgrammableInvoker(CWindows, addr, bindings.callingSequence).getBoundMethodHandle();\n+        MethodHandle handle = new ProgrammableInvoker(CWindows, bindings.callingSequence).getBoundMethodHandle();\n@@ -143,1 +141,1 @@\n-            target = SharedUtils.adaptUpcallForIMR(target);\n+            target = SharedUtils.adaptUpcallForIMR(target, false \/* need the return value as well *\/);\n@@ -146,1 +144,1 @@\n-        return new ProgrammableUpcallHandler(CWindows, target, bindings.callingSequence);\n+        return ProgrammableUpcallHandler.make(CWindows, target, bindings.callingSequence);\n@@ -208,1 +206,1 @@\n-                    Class<?> type = SharedUtils.primitiveCarrierForSize(layout.byteSize());\n+                    Class<?> type = SharedUtils.primitiveCarrierForSize(layout.byteSize(), false);\n@@ -273,1 +271,1 @@\n-                    Class<?> type = SharedUtils.primitiveCarrierForSize(layout.byteSize());\n+                    Class<?> type = SharedUtils.primitiveCarrierForSize(layout.byteSize(), false);\n@@ -284,3 +282,0 @@\n-                    \/\/ ASSERT SCOPE OF BOXED ADDRESS HERE\n-                    \/\/ caveat. buffer should instead go out of scope after call\n-                    bindings.copy(layout);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/CallArranger.java","additions":7,"deletions":12,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.internal.foreign.ResourceScopeImpl;\n@@ -57,1 +58,1 @@\n-class WinVaList implements VaList {\n+public non-sealed class WinVaList implements VaList {\n@@ -65,2 +66,1 @@\n-    private final List<MemorySegment> attachedSegments;\n-    private final MemorySegment livenessCheck;\n+    private final ResourceScope scope;\n@@ -68,1 +68,1 @@\n-    private WinVaList(MemorySegment segment, List<MemorySegment> attachedSegments, MemorySegment livenessCheck) {\n+    private WinVaList(MemorySegment segment, ResourceScope scope) {\n@@ -70,2 +70,1 @@\n-        this.attachedSegments = attachedSegments;\n-        this.livenessCheck = livenessCheck;\n+        this.scope = scope;\n@@ -99,2 +98,3 @@\n-    public MemorySegment vargAsSegment(MemoryLayout layout) {\n-        return (MemorySegment) read(MemorySegment.class, layout);\n+    public MemorySegment vargAsSegment(MemoryLayout layout, SegmentAllocator allocator) {\n+        Objects.requireNonNull(allocator);\n+        return (MemorySegment) read(MemorySegment.class, layout, allocator);\n@@ -104,3 +104,2 @@\n-    public MemorySegment vargAsSegment(MemoryLayout layout, NativeScope scope) {\n-        Objects.requireNonNull(scope);\n-        return (MemorySegment) read(MemorySegment.class, layout, SharedUtils.Allocator.ofScope(scope));\n+    public MemorySegment vargAsSegment(MemoryLayout layout, ResourceScope scope) {\n+        return vargAsSegment(layout, SegmentAllocator.ofScope(scope));\n@@ -110,1 +109,1 @@\n-        return read(carrier, layout, MemorySegment::allocateNative);\n+        return read(carrier, layout, SharedUtils.THROWING_ALLOCATOR);\n@@ -113,1 +112,1 @@\n-    private Object read(Class<?> carrier, MemoryLayout layout, SharedUtils.Allocator allocator) {\n+    private Object read(Class<?> carrier, MemoryLayout layout, SegmentAllocator allocator) {\n@@ -122,6 +121,4 @@\n-                    try (MemorySegment struct = handoffIfNeeded(structAddr.asSegmentRestricted(layout.byteSize()),\n-                         segment.ownerThread())) {\n-                        MemorySegment seg = allocator.allocate(layout.byteSize());\n-                        seg.copyFrom(struct);\n-                        yield seg;\n-                    }\n+                    MemorySegment struct = structAddr.asSegment(layout.byteSize(), scope());\n+                    MemorySegment seg = allocator.allocate(layout);\n+                    seg.copyFrom(struct);\n+                    yield seg;\n@@ -151,3 +148,3 @@\n-    static WinVaList ofAddress(MemoryAddress addr) {\n-        MemorySegment segment = addr.asSegmentRestricted(Long.MAX_VALUE);\n-        return new WinVaList(segment, List.of(segment), null);\n+    static WinVaList ofAddress(MemoryAddress addr, ResourceScope scope) {\n+        MemorySegment segment = addr.asSegment(Long.MAX_VALUE, scope);\n+        return new WinVaList(segment, scope);\n@@ -156,2 +153,2 @@\n-    static Builder builder(SharedUtils.Allocator allocator) {\n-        return new Builder(allocator);\n+    static Builder builder(ResourceScope scope) {\n+        return new Builder(scope);\n@@ -161,4 +158,2 @@\n-    public void close() {\n-        if (livenessCheck != null)\n-            livenessCheck.close();\n-        attachedSegments.forEach(MemorySegment::close);\n+    public ResourceScope scope() {\n+        return scope;\n@@ -169,12 +164,2 @@\n-        MemorySegment liveness = handoffIfNeeded(MemoryAddress.NULL.asSegmentRestricted(1),\n-                segment.ownerThread());\n-        return new WinVaList(segment, List.of(), liveness);\n-    }\n-\n-    @Override\n-    public VaList copy(NativeScope scope) {\n-        Objects.requireNonNull(scope);\n-        MemorySegment liveness = handoffIfNeeded(MemoryAddress.NULL.asSegmentRestricted(1),\n-                segment.ownerThread());\n-        liveness = liveness.handoff(scope);\n-        return new WinVaList(segment, List.of(), liveness);\n+        ((ResourceScopeImpl)scope).checkValidStateSlow();\n+        return new WinVaList(segment, scope);\n@@ -188,8 +173,1 @@\n-    @Override\n-    public boolean isAlive() {\n-        if (livenessCheck != null)\n-            return livenessCheck.isAlive();\n-        return segment.isAlive();\n-    }\n-\n-    static class Builder implements VaList.Builder {\n+    public static non-sealed class Builder implements VaList.Builder {\n@@ -197,1 +175,1 @@\n-        private final SharedUtils.Allocator allocator;\n+        private final ResourceScope scope;\n@@ -200,2 +178,3 @@\n-        public Builder(SharedUtils.Allocator allocator) {\n-            this.allocator = allocator;\n+        public Builder(ResourceScope scope) {\n+            ((ResourceScopeImpl)scope).checkValidStateSlow();\n+            this.scope = scope;\n@@ -241,0 +220,1 @@\n+            SegmentAllocator allocator = SegmentAllocator.arenaAllocator(scope);\n@@ -270,1 +250,1 @@\n-            return new WinVaList(segment, attachedSegments, null);\n+            return new WinVaList(segment, scope);\n@@ -273,5 +253,0 @@\n-\n-    private static MemorySegment handoffIfNeeded(MemorySegment segment, Thread thread) {\n-        return segment.ownerThread() == thread ?\n-                segment : segment.handoff(thread);\n-    }\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/WinVaList.java","additions":32,"deletions":57,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,0 @@\n-import jdk.incubator.foreign.Addressable;\n@@ -30,1 +29,0 @@\n-import jdk.incubator.foreign.MemoryLayout;\n@@ -32,1 +30,3 @@\n-import jdk.incubator.foreign.CLinker;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.internal.foreign.AbstractCLinker;\n+import jdk.internal.foreign.ResourceScopeImpl;\n@@ -42,2 +42,0 @@\n-import static jdk.internal.foreign.PlatformLayouts.*;\n-\n@@ -47,1 +45,1 @@\n-public class Windowsx64Linker implements CLinker {\n+public final class Windowsx64Linker extends AbstractCLinker {\n@@ -68,2 +66,2 @@\n-            MH_boxVaList = lookup.findStatic(Windowsx64Linker.class, \"newVaListOfAddress\",\n-                MethodType.methodType(VaList.class, MemoryAddress.class));\n+            MH_boxVaList = MethodHandles.insertArguments(lookup.findStatic(Windowsx64Linker.class, \"newVaListOfAddress\",\n+                MethodType.methodType(VaList.class, MemoryAddress.class, ResourceScope.class)), 1, ResourceScope.globalScope());\n@@ -82,2 +80,2 @@\n-    public static VaList newVaList(Consumer<VaList.Builder> actions, SharedUtils.Allocator allocator) {\n-        WinVaList.Builder builder = WinVaList.builder(allocator);\n+    public static VaList newVaList(Consumer<VaList.Builder> actions, ResourceScope scope) {\n+        WinVaList.Builder builder = WinVaList.builder(scope);\n@@ -89,2 +87,1 @@\n-    public MethodHandle downcallHandle(Addressable symbol, MethodType type, FunctionDescriptor function) {\n-        Objects.requireNonNull(symbol);\n+    public final MethodHandle downcallHandle(MethodType type, FunctionDescriptor function) {\n@@ -94,1 +91,5 @@\n-        MethodHandle handle = CallArranger.arrangeDowncall(symbol, llMt, function);\n+        MethodHandle handle = CallArranger.arrangeDowncall(llMt, function);\n+        if (!type.returnType().equals(MemorySegment.class)) {\n+            \/\/ not returning segment, just insert a throwing allocator\n+            handle = MethodHandles.insertArguments(handle, 1, SharedUtils.THROWING_ALLOCATOR);\n+        }\n@@ -100,1 +101,2 @@\n-    public MemorySegment upcallStub(MethodHandle target, FunctionDescriptor function) {\n+    public final MemoryAddress upcallStub(MethodHandle target, FunctionDescriptor function, ResourceScope scope) {\n+        Objects.requireNonNull(scope);\n@@ -104,1 +106,1 @@\n-        return UpcallStubs.upcallAddress(CallArranger.arrangeUpcall(target, target.type(), function));\n+        return UpcallStubs.upcallAddress(CallArranger.arrangeUpcall(target, target.type(), function), (ResourceScopeImpl) scope);\n@@ -107,2 +109,2 @@\n-    public static VaList newVaListOfAddress(MemoryAddress ma) {\n-        return WinVaList.ofAddress(ma);\n+    public static VaList newVaListOfAddress(MemoryAddress ma, ResourceScope scope) {\n+        return WinVaList.ofAddress(ma, scope);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/Windowsx64Linker.java","additions":20,"deletions":18,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n- * @run main\/othervm -Dforeign.restricted=permit -XX:+UnlockDiagnosticVMOptions\n+ * @run main\/othervm --enable-native-access=ALL-UNNAMED -XX:+UnlockDiagnosticVMOptions\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/compiler\/TestLinkToNativeRBP.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -336,1 +336,2 @@\n-    java\/foreign\n+    java\/foreign \\\n+    -java\/foreign\/TestMatrix.java\n","filename":"test\/jdk\/TEST.groups","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -29,0 +29,2 @@\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.SegmentAllocator;\n@@ -46,0 +48,2 @@\n+    static SegmentAllocator IMPLICIT_ALLOCATOR = (size, align) -> MemorySegment.allocateNative(size, align, ResourceScope.newImplicitScope());\n+\n@@ -50,2 +54,0 @@\n-    static int functions = 0;\n-\n@@ -142,1 +144,1 @@\n-                        layouts.add(MemoryLayout.ofPaddingBits(padding));\n+                        layouts.add(MemoryLayout.paddingLayout(padding));\n@@ -148,1 +150,1 @@\n-                return MemoryLayout.ofStruct(layouts.toArray(new MemoryLayout[0]));\n+                return MemoryLayout.structLayout(layouts.toArray(new MemoryLayout[0]));\n@@ -185,0 +187,1 @@\n+        int functions = 0;\n@@ -196,0 +199,1 @@\n+                                int count = functions;\n@@ -198,1 +202,1 @@\n-                                downcalls.add(new Object[] { fName, r, ptypes, fields });\n+                                downcalls.add(new Object[] { count, fName, r, ptypes, fields });\n@@ -203,0 +207,1 @@\n+                        int count = functions;\n@@ -205,1 +210,1 @@\n-                        downcalls.add(new Object[] { fName, r, ptypes, List.of() });\n+                        downcalls.add(new Object[] { count, fName, r, ptypes, List.of() });\n@@ -360,1 +365,1 @@\n-    static Object makeArg(MemoryLayout layout, List<Consumer<Object>> checks, boolean check, List<MemorySegment> segments) throws ReflectiveOperationException {\n+    static Object makeArg(MemoryLayout layout, List<Consumer<Object>> checks, boolean check) throws ReflectiveOperationException {\n@@ -362,3 +367,2 @@\n-            MemorySegment segment = MemorySegment.allocateNative(layout);\n-            initStruct(segment, (GroupLayout)layout, checks, check, segments);\n-            segments.add(segment);\n+            MemorySegment segment = MemorySegment.allocateNative(layout, ResourceScope.newImplicitScope());\n+            initStruct(segment, (GroupLayout)layout, checks, check);\n@@ -367,2 +371,1 @@\n-            MemorySegment segment = MemorySegment.allocateNative(1);\n-            segments.add(segment);\n+            MemorySegment segment = MemorySegment.allocateNative(1, ResourceScope.newImplicitScope());\n@@ -372,1 +375,1 @@\n-                        assertEquals((MemoryAddress)o, segment.address());\n+                        assertEquals(o, segment.address());\n@@ -401,1 +404,1 @@\n-    static void initStruct(MemorySegment str, GroupLayout g, List<Consumer<Object>> checks, boolean check, List<MemorySegment> segments) throws ReflectiveOperationException {\n+    static void initStruct(MemorySegment str, GroupLayout g, List<Consumer<Object>> checks, boolean check) throws ReflectiveOperationException {\n@@ -406,1 +409,1 @@\n-            Object value = makeArg(l, fieldsCheck, check, segments);\n+            Object value = makeArg(l, fieldsCheck, check);\n","filename":"test\/jdk\/java\/foreign\/CallGeneratorHelper.java","additions":18,"deletions":15,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -27,0 +27,3 @@\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.SegmentAllocator;\n@@ -42,0 +45,34 @@\n+\n+    public static class NativeScope implements SegmentAllocator, AutoCloseable {\n+        final ResourceScope resourceScope;\n+        final ResourceScope.Handle scopeHandle;\n+        final SegmentAllocator allocator;\n+\n+        long allocatedBytes = 0;\n+\n+        public NativeScope() {\n+            this.resourceScope = ResourceScope.newConfinedScope();\n+            this.scopeHandle = resourceScope.acquire();\n+            this.allocator = SegmentAllocator.arenaAllocator(resourceScope);\n+        }\n+\n+        @Override\n+        public MemorySegment allocate(long bytesSize, long bytesAlignment) {\n+            allocatedBytes += bytesSize;\n+            return allocator.allocate(bytesSize, bytesAlignment);\n+        }\n+\n+        public ResourceScope scope() {\n+            return resourceScope;\n+        }\n+\n+        public long allocatedBytes() {\n+            return allocatedBytes;\n+        }\n+\n+        @Override\n+        public void close() {\n+            resourceScope.release(scopeHandle);\n+            resourceScope.close();\n+        }\n+    }\n","filename":"test\/jdk\/java\/foreign\/NativeTestHelper.java","additions":37,"deletions":0,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -0,0 +1,81 @@\n+\/*\n+ *  Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED SafeFunctionAccessTest\n+ *\/\n+\n+import jdk.incubator.foreign.CLinker;\n+import jdk.incubator.foreign.FunctionDescriptor;\n+import jdk.incubator.foreign.LibraryLookup;\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.MemoryLayout;\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ResourceScope;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodType;\n+\n+import org.testng.annotations.*;\n+import static org.testng.Assert.*;\n+\n+public class SafeFunctionAccessTest {\n+\n+    LibraryLookup lookup = LibraryLookup.ofLibrary(\"SafeAccess\");\n+\n+    static MemoryLayout POINT = MemoryLayout.structLayout(\n+            CLinker.C_INT, CLinker.C_INT\n+    );\n+\n+    @Test(expectedExceptions = IllegalStateException.class)\n+    public void testClosedStruct() throws Throwable {\n+        MemorySegment segment;\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            segment = MemorySegment.allocateNative(POINT, scope);\n+        }\n+        assertFalse(segment.scope().isAlive());\n+        MethodHandle handle = CLinker.getInstance().downcallHandle(\n+                lookup.lookup(\"struct_func\").get(),\n+                MethodType.methodType(void.class, MemorySegment.class),\n+                FunctionDescriptor.ofVoid(POINT));\n+\n+        handle.invokeExact(segment);\n+    }\n+\n+    @Test(expectedExceptions = IllegalStateException.class)\n+    public void testClosedPointer() throws Throwable {\n+        MemoryAddress address;\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            address = MemorySegment.allocateNative(POINT, scope).address();\n+        }\n+        assertFalse(address.scope().isAlive());\n+        MethodHandle handle = CLinker.getInstance().downcallHandle(\n+                lookup.lookup(\"addr_func\").get(),\n+                MethodType.methodType(void.class, MemoryAddress.class),\n+                FunctionDescriptor.ofVoid(CLinker.C_POINTER));\n+\n+        handle.invokeExact(address);\n+    }\n+}\n","filename":"test\/jdk\/java\/foreign\/SafeFunctionAccessTest.java","additions":81,"deletions":0,"binary":false,"changes":81,"status":"added"},{"patch":"@@ -27,1 +27,1 @@\n- * @run testng\/othervm -Dforeign.restricted=permit StdLibTest\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED StdLibTest\n@@ -43,1 +43,2 @@\n-import java.util.function.Consumer;\n+import java.util.function.BiConsumer;\n+import java.util.function.Function;\n@@ -194,1 +195,1 @@\n-        final static LibraryLookup.Symbol printfAddr = lookup.lookup(\"printf\").get();\n+        final static MemoryAddress printfAddr = lookup.lookup(\"printf\").get();\n@@ -209,2 +210,3 @@\n-            try (MemorySegment buf = MemorySegment.allocateNative(s1.length() + s2.length() + 1) ;\n-                 MemorySegment other = toCString(s2)) {\n+            try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+                MemorySegment buf = MemorySegment.allocateNative(s1.length() + s2.length() + 1, scope);\n+                MemorySegment other = toCString(s2, scope);\n@@ -216,1 +218,1 @@\n-                return toJavaStringRestricted(((MemoryAddress)strcat.invokeExact(buf.address(), other.address())));\n+                return toJavaString(((MemoryAddress)strcat.invokeExact(buf.address(), other.address())));\n@@ -221,2 +223,3 @@\n-            try (MemorySegment ns1 = toCString(s1) ;\n-                 MemorySegment ns2 = toCString(s2)) {\n+            try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+                MemorySegment ns1 = toCString(s1, scope);\n+                MemorySegment ns2 = toCString(s2, scope);\n@@ -228,1 +231,2 @@\n-            try (MemorySegment s = toCString(msg)) {\n+            try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+                MemorySegment s = toCString(msg, scope);\n@@ -234,1 +238,2 @@\n-            try (MemorySegment s = toCString(msg)) {\n+            try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+                MemorySegment s = toCString(msg, scope);\n@@ -240,1 +245,2 @@\n-            try (MemorySegment time = MemorySegment.allocateNative(8)) {\n+            try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+                MemorySegment time = MemorySegment.allocateNative(8, scope);\n@@ -254,1 +260,1 @@\n-                this.base = addr.asSegmentRestricted(SIZE);\n+                this.base = addr.asSegment(SIZE, ResourceScope.globalScope());\n@@ -289,3 +295,3 @@\n-            try (NativeScope scope = NativeScope.unboundedScope()) {\n-\n-                MemorySegment nativeArr = scope.allocateArray(C_INT, arr);\n+            try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+                SegmentAllocator allocator = SegmentAllocator.ofScope(scope);\n+                MemorySegment nativeArr = allocator.allocateArray(C_INT, arr);\n@@ -294,2 +300,1 @@\n-                MemorySegment qsortUpcallStub = abi.upcallStub(qsortCompar.bindTo(nativeArr), qsortComparFunction);\n-                qsortUpcallStub = qsortUpcallStub.handoff(scope);\n+                MemoryAddress qsortUpcallStub = abi.upcallStub(qsortCompar.bindTo(nativeArr), qsortComparFunction, scope);\n@@ -297,1 +302,1 @@\n-                qsort.invokeExact(nativeArr.address(), (long)arr.length, C_INT.byteSize(), qsortUpcallStub.address());\n+                qsort.invokeExact(nativeArr.address(), (long)arr.length, C_INT.byteSize(), qsortUpcallStub);\n@@ -314,1 +319,2 @@\n-            try (MemorySegment formatStr = toCString(format)) {\n+            try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+                MemorySegment formatStr = toCString(format, scope);\n@@ -316,1 +322,1 @@\n-                        args.stream().map(a -> a.nativeValue).toArray());\n+                        args.stream().map(a -> a.nativeValue(scope)).toArray());\n@@ -321,10 +327,4 @@\n-            try (MemorySegment formatStr = toCString(format)) {\n-                VaList vaList = VaList.make(b -> args.forEach(a -> a.accept(b)));\n-                int result = (int)vprintf.invokeExact(formatStr.address(), vaList);\n-                try {\n-                    vaList.close();\n-                }\n-                catch (UnsupportedOperationException e) {\n-                    assertEquals(e.getMessage(), \"Empty VaList\");\n-                }\n-                return result;\n+            try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+                MemorySegment formatStr = toCString(format, scope);\n+                VaList vaList = VaList.make(b -> args.forEach(a -> a.accept(b, scope)), scope);\n+                return (int)vprintf.invokeExact(formatStr.address(), vaList);\n@@ -401,1 +401,1 @@\n-    enum PrintfArg implements Consumer<VaList.Builder> {\n+    enum PrintfArg implements BiConsumer<VaList.Builder, ResourceScope> {\n@@ -403,4 +403,4 @@\n-        INTEGRAL(int.class, asVarArg(C_INT), \"%d\", 42, 42, VaList.Builder::vargFromInt),\n-        STRING(MemoryAddress.class, asVarArg(C_POINTER), \"%s\", toCString(\"str\").address(), \"str\", VaList.Builder::vargFromAddress),\n-        CHAR(byte.class, asVarArg(C_CHAR), \"%c\", (byte) 'h', 'h', (builder, layout, value) -> builder.vargFromInt(C_INT, (int)value)),\n-        DOUBLE(double.class, asVarArg(C_DOUBLE), \"%.4f\", 1.2345d, 1.2345d, VaList.Builder::vargFromDouble);\n+        INTEGRAL(int.class, asVarArg(C_INT), \"%d\", scope -> 42, 42, VaList.Builder::vargFromInt),\n+        STRING(MemoryAddress.class, asVarArg(C_POINTER), \"%s\", scope -> toCString(\"str\", scope).address(), \"str\", VaList.Builder::vargFromAddress),\n+        CHAR(byte.class, asVarArg(C_CHAR), \"%c\", scope -> (byte) 'h', 'h', (builder, layout, value) -> builder.vargFromInt(C_INT, (int)value)),\n+        DOUBLE(double.class, asVarArg(C_DOUBLE), \"%.4f\", scope ->1.2345d, 1.2345d, VaList.Builder::vargFromDouble);\n@@ -411,1 +411,1 @@\n-        final Object nativeValue;\n+        final Function<ResourceScope, ?> nativeValueFactory;\n@@ -416,1 +416,1 @@\n-        <Z> PrintfArg(Class<?> carrier, ValueLayout layout, String format, Z nativeValue, Object javaValue, VaListBuilderCall<Z> builderCall) {\n+        <Z> PrintfArg(Class<?> carrier, ValueLayout layout, String format, Function<ResourceScope, Z> nativeValueFactory, Object javaValue, VaListBuilderCall<Z> builderCall) {\n@@ -420,1 +420,1 @@\n-            this.nativeValue = nativeValue;\n+            this.nativeValueFactory = nativeValueFactory;\n@@ -427,2 +427,2 @@\n-        public void accept(VaList.Builder builder) {\n-            builderCall.build(builder, layout, nativeValue);\n+        public void accept(VaList.Builder builder, ResourceScope scope) {\n+            builderCall.build(builder, layout, nativeValueFactory.apply(scope));\n@@ -434,0 +434,4 @@\n+\n+        public Object nativeValue(ResourceScope scope) {\n+            return nativeValueFactory.apply(scope);\n+        }\n","filename":"test\/jdk\/java\/foreign\/StdLibTest.java","additions":44,"deletions":40,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-import jdk.incubator.foreign.MemoryAddress;\n@@ -38,0 +37,1 @@\n+import jdk.incubator.foreign.ResourceScope;\n@@ -89,1 +89,1 @@\n-    static final VarHandle intHandleIndexed = MemoryLayout.ofSequence(MemoryLayouts.JAVA_INT)\n+    static final VarHandle intHandleIndexed = MemoryLayout.sequenceLayout(MemoryLayouts.JAVA_INT)\n@@ -99,1 +99,1 @@\n-        MemorySegment segment = MemorySegment.allocateNative(layout);\n+        MemorySegment segment = MemorySegment.allocateNative(layout, ResourceScope.newImplicitScope());\n@@ -118,1 +118,1 @@\n-        MemorySegment segment = MemorySegment.allocateNative(layout);\n+        MemorySegment segment = MemorySegment.allocateNative(layout, ResourceScope.newImplicitScope());\n@@ -139,1 +139,1 @@\n-        MemorySegment segment = MemorySegment.allocateNative(layout);\n+        MemorySegment segment = MemorySegment.allocateNative(layout, ResourceScope.newImplicitScope());\n@@ -207,1 +207,1 @@\n-        MemorySegment segment = MemorySegment.allocateNative(layout);\n+        MemorySegment segment = MemorySegment.allocateNative(layout, ResourceScope.newImplicitScope());\n@@ -250,1 +250,1 @@\n-        MemorySegment segment = MemorySegment.allocateNative(layout);\n+        MemorySegment segment = MemorySegment.allocateNative(layout, ResourceScope.newImplicitScope());\n@@ -288,1 +288,1 @@\n-        MemorySegment segment = MemorySegment.allocateNative(layout);\n+        MemorySegment segment = MemorySegment.allocateNative(layout, ResourceScope.newImplicitScope());\n@@ -327,1 +327,1 @@\n-        MemorySegment segment = MemorySegment.allocateNative(layout);\n+        MemorySegment segment = MemorySegment.allocateNative(layout, ResourceScope.newImplicitScope());\n@@ -370,1 +370,1 @@\n-        MemorySegment segment = MemorySegment.allocateNative(layout);\n+        MemorySegment segment = MemorySegment.allocateNative(layout, ResourceScope.newImplicitScope());\n","filename":"test\/jdk\/java\/foreign\/TestAdaptVarHandles.java","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -65,1 +65,2 @@\n-        try (MemorySegment segment = MemorySegment.allocateNative(8)) {\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            MemorySegment segment = MemorySegment.allocateNative(8, scope);\n@@ -81,1 +82,2 @@\n-        try (MemorySegment segment = MemorySegment.allocateNative(8)) {\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            MemorySegment segment = MemorySegment.allocateNative(8, scope);\n","filename":"test\/jdk\/java\/foreign\/TestAddressHandle.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- * @run testng\/othervm -Dforeign.restricted=permit TestArrays\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED TestArrays\n@@ -35,0 +35,1 @@\n+import jdk.incubator.foreign.ResourceScope;\n@@ -45,1 +46,0 @@\n-import static jdk.incubator.foreign.MemorySegment.READ;\n@@ -50,1 +50,1 @@\n-    static SequenceLayout bytes = MemoryLayout.ofSequence(100,\n+    static SequenceLayout bytes = MemoryLayout.sequenceLayout(100,\n@@ -54,1 +54,1 @@\n-    static SequenceLayout chars = MemoryLayout.ofSequence(100,\n+    static SequenceLayout chars = MemoryLayout.sequenceLayout(100,\n@@ -58,1 +58,1 @@\n-    static SequenceLayout shorts = MemoryLayout.ofSequence(100,\n+    static SequenceLayout shorts = MemoryLayout.sequenceLayout(100,\n@@ -62,1 +62,1 @@\n-    static SequenceLayout ints = MemoryLayout.ofSequence(100,\n+    static SequenceLayout ints = MemoryLayout.sequenceLayout(100,\n@@ -66,1 +66,1 @@\n-    static SequenceLayout floats = MemoryLayout.ofSequence(100,\n+    static SequenceLayout floats = MemoryLayout.sequenceLayout(100,\n@@ -70,1 +70,1 @@\n-    static SequenceLayout longs = MemoryLayout.ofSequence(100,\n+    static SequenceLayout longs = MemoryLayout.sequenceLayout(100,\n@@ -74,1 +74,1 @@\n-    static SequenceLayout doubles = MemoryLayout.ofSequence(100,\n+    static SequenceLayout doubles = MemoryLayout.sequenceLayout(100,\n@@ -104,4 +104,4 @@\n-        try (MemorySegment segment = MemorySegment.allocateNative(layout)) {\n-            init.accept(segment);\n-            checker.accept(segment);\n-        }\n+        MemorySegment segment = MemorySegment.allocateNative(layout, ResourceScope.newImplicitScope());\n+        init.accept(segment);\n+        assertFalse(segment.isReadOnly());\n+        checker.accept(segment);\n@@ -111,1 +111,1 @@\n-            expectedExceptions = UnsupportedOperationException.class)\n+            expectedExceptions = IllegalStateException.class)\n@@ -113,1 +113,1 @@\n-        MemoryLayout seq = MemoryLayout.ofSequence((Integer.MAX_VALUE * layout.byteSize()) + 1, layout);\n+        MemoryLayout seq = MemoryLayout.sequenceLayout((Integer.MAX_VALUE * layout.byteSize()) + 1, layout);\n@@ -115,3 +115,2 @@\n-        try (MemorySegment segment = MemoryAddress.NULL.asSegmentRestricted(seq.byteSize())) {\n-            arrayFactory.apply(segment);\n-        }\n+        MemorySegment segment = MemoryAddress.NULL.asSegment(seq.byteSize(), ResourceScope.globalScope());\n+        arrayFactory.apply(segment);\n@@ -121,1 +120,1 @@\n-            expectedExceptions = UnsupportedOperationException.class)\n+            expectedExceptions = IllegalStateException.class)\n@@ -123,2 +122,3 @@\n-        if (layout.byteSize() == 1) throw new UnsupportedOperationException(); \/\/make it fail\n-        try (MemorySegment segment = MemorySegment.allocateNative(layout.byteSize() + 1)) {\n+        if (layout.byteSize() == 1) throw new IllegalStateException(); \/\/make it fail\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            MemorySegment segment = MemorySegment.allocateNative(layout.byteSize() + 1, layout.byteSize(), scope);\n@@ -132,2 +132,2 @@\n-        MemorySegment segment = MemorySegment.allocateNative(layout);\n-        segment.close();\n+        MemorySegment segment = MemorySegment.allocateNative(layout, ResourceScope.newConfinedScope());\n+        segment.scope().close();\n@@ -137,16 +137,0 @@\n-    @Test(dataProvider = \"elemLayouts\",\n-            expectedExceptions = UnsupportedOperationException.class)\n-    public void testArrayFromHeapSegmentWithoutAccess(MemoryLayout layout, Function<MemorySegment, Object> arrayFactory) {\n-        MemorySegment segment = MemorySegment.ofArray(new byte[(int)layout.byteSize()]);\n-        segment = segment.withAccessModes(MemorySegment.ALL_ACCESS & ~READ);\n-        arrayFactory.apply(segment);\n-    }\n-\n-    @Test(dataProvider = \"elemLayouts\",\n-            expectedExceptions = UnsupportedOperationException.class)\n-    public void testArrayFromNativeSegmentWithoutAccess(MemoryLayout layout, Function<MemorySegment, Object> arrayFactory) {\n-        try (MemorySegment segment = MemorySegment.allocateNative(layout).withAccessModes(MemorySegment.ALL_ACCESS & ~READ)) {\n-            arrayFactory.apply(segment);\n-        }\n-    }\n-\n","filename":"test\/jdk\/java\/foreign\/TestArrays.java","additions":23,"deletions":39,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n- * @run testng\/othervm -Dforeign.restricted=permit TestByteBuffer\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED TestByteBuffer\n@@ -31,2 +31,0 @@\n-\n-import jdk.incubator.foreign.MappedMemorySegments;\n@@ -39,0 +37,1 @@\n+import jdk.incubator.foreign.ResourceScope;\n@@ -46,0 +45,1 @@\n+import java.lang.ref.Cleaner;\n@@ -66,0 +66,1 @@\n+import java.util.Arrays;\n@@ -83,1 +84,1 @@\n-import static jdk.incubator.foreign.MemorySegment.*;\n+\n@@ -102,2 +103,2 @@\n-    static SequenceLayout tuples = MemoryLayout.ofSequence(500,\n-            MemoryLayout.ofStruct(\n+    static SequenceLayout tuples = MemoryLayout.sequenceLayout(500,\n+            MemoryLayout.structLayout(\n@@ -108,1 +109,1 @@\n-    static SequenceLayout bytes = MemoryLayout.ofSequence(100,\n+    static SequenceLayout bytes = MemoryLayout.sequenceLayout(100,\n@@ -112,1 +113,1 @@\n-    static SequenceLayout chars = MemoryLayout.ofSequence(100,\n+    static SequenceLayout chars = MemoryLayout.sequenceLayout(100,\n@@ -116,1 +117,1 @@\n-    static SequenceLayout shorts = MemoryLayout.ofSequence(100,\n+    static SequenceLayout shorts = MemoryLayout.sequenceLayout(100,\n@@ -120,1 +121,1 @@\n-    static SequenceLayout ints = MemoryLayout.ofSequence(100,\n+    static SequenceLayout ints = MemoryLayout.sequenceLayout(100,\n@@ -124,1 +125,1 @@\n-    static SequenceLayout floats = MemoryLayout.ofSequence(100,\n+    static SequenceLayout floats = MemoryLayout.sequenceLayout(100,\n@@ -128,1 +129,1 @@\n-    static SequenceLayout longs = MemoryLayout.ofSequence(100,\n+    static SequenceLayout longs = MemoryLayout.sequenceLayout(100,\n@@ -132,1 +133,1 @@\n-    static SequenceLayout doubles = MemoryLayout.ofSequence(100,\n+    static SequenceLayout doubles = MemoryLayout.sequenceLayout(100,\n@@ -189,1 +190,2 @@\n-        try (MemorySegment segment = MemorySegment.allocateNative(tuples)) {\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            MemorySegment segment = MemorySegment.allocateNative(tuples, scope);\n@@ -233,3 +235,3 @@\n-        try (MemorySegment segment = MemorySegment.mapFile(tempPath, 0L, 8, FileChannel.MapMode.READ_WRITE)) {\n-            assertTrue(segment.hasAccessModes(ALL_ACCESS));\n-            assertEquals(segment.accessModes(), ALL_ACCESS);\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            MemorySegment segment = MemorySegment.mapFile(tempPath, 0L, 8, FileChannel.MapMode.READ_WRITE, scope);\n+            assertFalse(segment.isReadOnly());\n@@ -238,3 +240,3 @@\n-        try (MemorySegment segment = MemorySegment.mapFile(tempPath, 0L, 8, FileChannel.MapMode.READ_ONLY)) {\n-            assertTrue(segment.hasAccessModes(ALL_ACCESS & ~WRITE));\n-            assertEquals(segment.accessModes(), ALL_ACCESS & ~WRITE);\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            MemorySegment segment = MemorySegment.mapFile(tempPath, 0L, 8, FileChannel.MapMode.READ_ONLY, scope);\n+            assertTrue(segment.isReadOnly());\n@@ -250,2 +252,3 @@\n-        \/\/write to channel\n-        try (MemorySegment segment = MemorySegment.mapFile(f.toPath(), 0L, tuples.byteSize(), FileChannel.MapMode.READ_WRITE)) {\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            \/\/write to channel\n+            MemorySegment segment = MemorySegment.mapFile(f.toPath(), 0L, tuples.byteSize(), FileChannel.MapMode.READ_WRITE, scope);\n@@ -253,1 +256,1 @@\n-            MappedMemorySegments.force(segment);\n+            segment.force();\n@@ -256,2 +259,3 @@\n-        \/\/read from channel\n-        try (MemorySegment segment = MemorySegment.mapFile(f.toPath(), 0L, tuples.byteSize(), FileChannel.MapMode.READ_ONLY)) {\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            \/\/read from channel\n+            MemorySegment segment = MemorySegment.mapFile(f.toPath(), 0L, tuples.byteSize(), FileChannel.MapMode.READ_ONLY, scope);\n@@ -262,1 +266,1 @@\n-    @Test(dataProvider = \"mappedOps\", expectedExceptions = IllegalStateException.class)\n+    @Test(dataProvider = \"mappedOps\", expectedExceptions = UnsupportedOperationException.class)\n@@ -268,1 +272,1 @@\n-        MemorySegment segment = MemorySegment.mapFile(f.toPath(), 0L, 8, FileChannel.MapMode.READ_WRITE);\n+        MemorySegment segment = MemorySegment.mapFile(f.toPath(), 0L, 8, FileChannel.MapMode.READ_WRITE, ResourceScope.newImplicitScope());\n@@ -270,1 +274,1 @@\n-        segment.close();\n+        segment.scope().close();\n@@ -284,2 +288,3 @@\n-            \/\/write to channel\n-            try (MemorySegment segment = MemorySegment.mapFile(f.toPath(), i, tuples.byteSize(), FileChannel.MapMode.READ_WRITE)) {\n+            try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+                \/\/write to channel\n+                MemorySegment segment = MemorySegment.mapFile(f.toPath(), i, tuples.byteSize(), FileChannel.MapMode.READ_WRITE, scope);\n@@ -287,1 +292,1 @@\n-                MappedMemorySegments.force(segment);\n+                segment.force();\n@@ -293,2 +298,3 @@\n-            \/\/read from channel\n-            try (MemorySegment segment = MemorySegment.mapFile(f.toPath(), 0L, tuples.byteSize(), FileChannel.MapMode.READ_ONLY)) {\n+            try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+                \/\/read from channel\n+                MemorySegment segment = MemorySegment.mapFile(f.toPath(), 0L, tuples.byteSize(), FileChannel.MapMode.READ_ONLY, scope);\n@@ -312,8 +318,9 @@\n-        try (MemorySegment segment = MemorySegment.mapFile(f.toPath(), 0, LARGE_SIZE, FileChannel.MapMode.READ_WRITE)) {\n-            MappedMemorySegments.isLoaded(segment);\n-            MappedMemorySegments.load(segment);\n-            MappedMemorySegments.isLoaded(segment);\n-            MappedMemorySegments.force(segment);\n-            MappedMemorySegments.isLoaded(segment);\n-            MappedMemorySegments.unload(segment);\n-            MappedMemorySegments.isLoaded(segment);\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            MemorySegment segment = MemorySegment.mapFile(f.toPath(), 0, LARGE_SIZE, FileChannel.MapMode.READ_WRITE, scope);\n+            segment.isLoaded();\n+            segment.load();\n+            segment.isLoaded();\n+            segment.force();\n+            segment.isLoaded();\n+            segment.unload();\n+            segment.isLoaded();\n@@ -345,1 +352,2 @@\n-        try (MemorySegment segment = MemorySegment.allocateNative(bytes)) {\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            MemorySegment segment = MemorySegment.allocateNative(bytes, scope);\n@@ -356,1 +364,1 @@\n-                assertTrue(ex.getCause().getMessage().contains(\"already closed\"));\n+                assertTrue(ex.getCause().getMessage().contains(\"Already closed\"));\n@@ -370,1 +378,2 @@\n-        try (MemorySegment segment = MemorySegment.allocateNative(bytes)) {\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            MemorySegment segment = MemorySegment.allocateNative(bytes, scope);\n@@ -392,1 +401,1 @@\n-                assertTrue(ex.getMessage().contains(\"already closed\"));\n+                assertTrue(ex.getMessage().contains(\"Already closed\"));\n@@ -403,1 +412,2 @@\n-        try (MemorySegment segment = MemorySegment.allocateNative(bytes)) {\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            MemorySegment segment = MemorySegment.allocateNative(bytes, scope);\n@@ -415,1 +425,2 @@\n-        try (MemorySegment segment = MemorySegment.allocateNative(seq)) {\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            MemorySegment segment = MemorySegment.allocateNative(seq, scope);\n@@ -452,1 +463,2 @@\n-        try (MemorySegment segment = MemorySegment.allocateNative(seq)) {\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            MemorySegment segment = MemorySegment.allocateNative(seq, scope);\n@@ -462,2 +474,2 @@\n-        try (MemorySegment segment = MemorySegment.allocateNative(bytes)) {\n-            leaked = segment;\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            leaked = MemorySegment.allocateNative(bytes, scope);\n@@ -469,1 +481,1 @@\n-    @Test(expectedExceptions = UnsupportedOperationException.class)\n+    @Test(expectedExceptions = IllegalStateException.class)\n@@ -471,3 +483,2 @@\n-        try (MemorySegment segment = MemoryAddress.NULL.asSegmentRestricted(Integer.MAX_VALUE + 10L)) {\n-            segment.asByteBuffer();\n-        }\n+        MemorySegment segment = MemoryAddress.NULL.asSegment(Integer.MAX_VALUE + 10L, ResourceScope.globalScope());\n+        segment.asByteBuffer();\n@@ -481,1 +492,1 @@\n-        MemorySegment.mapFile(f.toPath(), 0L, -1, FileChannel.MapMode.READ_WRITE);\n+        MemorySegment.mapFile(f.toPath(), 0L, -1, FileChannel.MapMode.READ_WRITE, ResourceScope.newImplicitScope());\n@@ -489,1 +500,1 @@\n-        MemorySegment.mapFile(f.toPath(), -1, 1, FileChannel.MapMode.READ_WRITE);\n+        MemorySegment.mapFile(f.toPath(), -1, 1, FileChannel.MapMode.READ_WRITE, ResourceScope.newImplicitScope());\n@@ -500,1 +511,2 @@\n-        try (MemorySegment segment = MemorySegment.mapFile(f.toPath(), 0, SIZE, FileChannel.MapMode.READ_WRITE)) {\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            MemorySegment segment = MemorySegment.mapFile(f.toPath(), 0, SIZE, FileChannel.MapMode.READ_WRITE, scope);\n@@ -504,1 +516,1 @@\n-            MappedMemorySegments.force(segment);\n+            segment.force();\n@@ -508,1 +520,2 @@\n-            try (MemorySegment segment = MemorySegment.mapFile(f.toPath(), offset, SIZE - offset, FileChannel.MapMode.READ_ONLY)) {\n+            try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+                MemorySegment segment = MemorySegment.mapFile(f.toPath(), offset, SIZE - offset, FileChannel.MapMode.READ_ONLY, scope);\n@@ -520,1 +533,2 @@\n-        try (MemorySegment segment = MemorySegment.mapFile(f.toPath(), 0L, 0L, FileChannel.MapMode.READ_WRITE)) {\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            MemorySegment segment = MemorySegment.mapFile(f.toPath(), 0L, 0L, FileChannel.MapMode.READ_WRITE, scope);\n@@ -523,5 +537,5 @@\n-            assertTrue((segment.accessModes() & (READ | WRITE)) == (READ | WRITE));\n-            MappedMemorySegments.force(segment);\n-            MappedMemorySegments.load(segment);\n-            MappedMemorySegments.isLoaded(segment);\n-            MappedMemorySegments.unload(segment);\n+            assertFalse(segment.isReadOnly());\n+            segment.force();\n+            segment.load();\n+            segment.isLoaded();\n+            segment.unload();\n@@ -530,1 +544,2 @@\n-        try (MemorySegment segment = MemorySegment.mapFile(f.toPath(), 0L, 0L, FileChannel.MapMode.READ_ONLY)) {\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            MemorySegment segment = MemorySegment.mapFile(f.toPath(), 0L, 0L, FileChannel.MapMode.READ_ONLY, scope);\n@@ -533,5 +548,5 @@\n-            assertTrue((segment.accessModes() & (READ | WRITE)) == READ);\n-            MappedMemorySegments.force(segment);\n-            MappedMemorySegments.load(segment);\n-            MappedMemorySegments.isLoaded(segment);\n-            MappedMemorySegments.unload(segment);\n+            assertTrue(segment.isReadOnly());\n+            segment.force();\n+            segment.load();\n+            segment.isLoaded();\n+            segment.unload();\n@@ -544,1 +559,1 @@\n-        MemorySegment.mapFile(path, 0L, 0L, FileChannel.MapMode.READ_WRITE);\n+        MemorySegment.mapFile(path, 0L, 0L, FileChannel.MapMode.READ_WRITE, ResourceScope.newImplicitScope());\n@@ -551,2 +566,3 @@\n-        try (MemorySegment nativeArray = MemorySegment.allocateNative(bytes);\n-             MemorySegment heapArray = MemorySegment.ofArray(new byte[bytes])) {\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            MemorySegment nativeArray = MemorySegment.allocateNative(bytes, 1, scope);\n+            MemorySegment heapArray = MemorySegment.ofArray(new byte[bytes]);\n@@ -563,2 +579,3 @@\n-        try (MemorySegment nativeArray = MemorySegment.allocateNative(seq);\n-             MemorySegment heapArray = MemorySegment.ofArray(new byte[bytes])) {\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            MemorySegment nativeArray = MemorySegment.allocateNative(seq, scope);\n+            MemorySegment heapArray = MemorySegment.ofArray(new byte[bytes]);\n@@ -574,3 +591,3 @@\n-        try (MemorySegment segment = MemorySegment.ofByteBuffer(rwBuffer)) {\n-            assertTrue(segment.hasAccessModes(ALL_ACCESS));\n-            assertEquals(segment.accessModes(), ALL_ACCESS);\n+        {\n+            MemorySegment segment = MemorySegment.ofByteBuffer(rwBuffer);\n+            assertFalse(segment.isReadOnly());\n@@ -579,4 +596,4 @@\n-        ByteBuffer roBuffer = rwBuffer.asReadOnlyBuffer();\n-        try (MemorySegment segment = MemorySegment.ofByteBuffer(roBuffer)) {\n-            assertTrue(segment.hasAccessModes(ALL_ACCESS & ~WRITE));\n-            assertEquals(segment.accessModes(), ALL_ACCESS & ~WRITE);\n+        {\n+            ByteBuffer roBuffer = rwBuffer.asReadOnlyBuffer();\n+            MemorySegment segment = MemorySegment.ofByteBuffer(roBuffer);\n+            assertTrue(segment.isReadOnly());\n@@ -589,1 +606,1 @@\n-        assertEquals(segment.hasAccessModes(MemorySegment.WRITE), !bb.isReadOnly());\n+        assertEquals(segment.isReadOnly(), bb.isReadOnly());\n@@ -592,1 +609,0 @@\n-        assertTrue(segmentChecker.test(segment.withAccessModes(MemorySegment.READ)));\n@@ -596,1 +612,1 @@\n-        assertEquals(segment.hasAccessModes(MemorySegment.WRITE), !bb.isReadOnly());\n+        assertEquals(segment.isReadOnly(), bb.isReadOnly());\n@@ -599,1 +615,0 @@\n-        assertTrue(segmentChecker.test(segment.withAccessModes(MemorySegment.READ)));\n@@ -605,6 +620,5 @@\n-        try (MemorySegment segment = MemorySegment.ofByteBuffer(bb)) {\n-            ByteBuffer buffer = segment.asByteBuffer();\n-            assertEquals(buffer.position(), 0);\n-            assertEquals(buffer.capacity(), segment.byteSize());\n-            assertEquals(buffer.limit(), segment.byteSize());\n-        }\n+        MemorySegment segment = MemorySegment.ofByteBuffer(bb);\n+        ByteBuffer buffer = segment.asByteBuffer();\n+        assertEquals(buffer.position(), 0);\n+        assertEquals(buffer.capacity(), segment.byteSize());\n+        assertEquals(buffer.limit(), segment.byteSize());\n@@ -615,2 +629,3 @@\n-        try(MemorySegment ms = MemorySegment.allocateNative(4)) {\n-            MemorySegment msNoAccess = ms.withAccessModes(MemorySegment.READ); \/\/ READ is required to make BB\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            MemorySegment ms = MemorySegment.allocateNative(4, 1, scope);\n+            MemorySegment msNoAccess = ms.asReadOnly();\n@@ -618,1 +633,1 @@\n-            assertEquals(msNoAccess.accessModes(), msRoundTrip.accessModes());\n+            assertEquals(msNoAccess.isReadOnly(), msRoundTrip.isReadOnly());\n@@ -624,1 +639,1 @@\n-        MemorySegment s1 = MemorySegment.allocateNative(MemoryLayouts.JAVA_INT);\n+        MemorySegment s1 = MemorySegment.allocateNative(MemoryLayouts.JAVA_INT, ResourceScope.newConfinedScope());\n@@ -627,1 +642,2 @@\n-        s1.close(); \/\/ memory freed\n+        \/\/ memory freed\n+        s1.scope().close();\n@@ -632,2 +648,2 @@\n-    @Test(expectedExceptions = UnsupportedOperationException.class)\n-    public void testIOOnSharedSegmentBuffer() throws IOException {\n+    @Test(dataProvider = \"allScopes\")\n+    public void testIOOnSegmentBuffer(Supplier<ResourceScope> scopeSupplier) throws IOException {\n@@ -636,2 +652,4 @@\n-        try (FileChannel channel = FileChannel.open(tmp.toPath(), StandardOpenOption.WRITE)) {\n-            MemorySegment segment = MemorySegment.allocateNative(10).share();\n+        ResourceScope scope;\n+        try (FileChannel channel = FileChannel.open(tmp.toPath(), StandardOpenOption.READ, StandardOpenOption.WRITE) ;\n+             ResourceScope scp = closeableScopeOrNull(scope = scopeSupplier.get())) {\n+            MemorySegment segment = MemorySegment.allocateNative(10, 1, scope);\n@@ -642,2 +660,5 @@\n-            segment.close();\n-            channel.write(bb);\n+            assertEquals(channel.write(bb), 10);\n+            segment.fill((byte)0x00);\n+            assertEquals(bb.clear(), ByteBuffer.wrap(new byte[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}));\n+            assertEquals(channel.position(0).read(bb.clear()), 10);\n+            assertEquals(bb.flip(), ByteBuffer.wrap(new byte[] {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}));\n@@ -647,14 +668,1 @@\n-    @Test(expectedExceptions = IllegalStateException.class)\n-    public void testIOOnClosedConfinedSegmentBuffer() throws IOException {\n-        File tmp = File.createTempFile(\"tmp\", \"txt\");\n-        tmp.deleteOnExit();\n-        try (FileChannel channel = FileChannel.open(tmp.toPath(), StandardOpenOption.WRITE)) {\n-            MemorySegment segment = MemorySegment.allocateNative(10);\n-            for (int i = 0; i < 10; i++) {\n-                MemoryAccess.setByteAtOffset(segment, i, (byte) i);\n-            }\n-            ByteBuffer bb = segment.asByteBuffer();\n-            segment.close();\n-            channel.write(bb);\n-        }\n-    }\n+    static final Class<IllegalStateException> ISE = IllegalStateException.class;\n@@ -662,2 +670,2 @@\n-    @Test\n-    public void testIOOnConfinedSegment() throws IOException {\n+    @Test(dataProvider = \"closeableScopes\")\n+    public void testIOOnClosedSegmentBuffer(Supplier<ResourceScope> scopeSupplier) throws IOException {\n@@ -666,2 +674,2 @@\n-        try (FileChannel channel = FileChannel.open(tmp.toPath(), StandardOpenOption.WRITE)) {\n-            MemorySegment segment = MemorySegment.allocateNative(10);\n+        try (FileChannel channel = FileChannel.open(tmp.toPath(), StandardOpenOption.READ, StandardOpenOption.WRITE)) {\n+            MemorySegment segment = MemorySegment.allocateNative(10, scopeSupplier.get());\n@@ -672,1 +680,7 @@\n-            channel.write(bb);\n+            segment.scope().close();\n+            assertThrows(ISE, () -> channel.read(bb));\n+            assertThrows(ISE, () -> channel.read(new ByteBuffer[] {bb}));\n+            assertThrows(ISE, () -> channel.read(new ByteBuffer[] {bb}, 0, 1));\n+            assertThrows(ISE, () -> channel.write(bb));\n+            assertThrows(ISE, () -> channel.write(new ByteBuffer[] {bb}));\n+            assertThrows(ISE, () -> channel.write(new ByteBuffer[] {bb}, 0 ,1));\n@@ -676,3 +690,4 @@\n-    @Test(dataProvider=\"segments\")\n-    public void buffersAndArraysFromSlices(Supplier<MemorySegment> segmentSupplier) {\n-        try (MemorySegment segment = segmentSupplier.get()) {\n+    @Test\n+    public void buffersAndArraysFromSlices() {\n+        try (ResourceScope scope = ResourceScope.newSharedScope()) {\n+            MemorySegment segment = MemorySegment.allocateNative(16, scope);\n@@ -693,3 +708,4 @@\n-    @Test(dataProvider=\"segments\")\n-    public void viewsFromSharedSegment(Supplier<MemorySegment> segmentSupplier) {\n-        try (MemorySegment segment = segmentSupplier.get().share()) {\n+    @Test\n+    public void viewsFromSharedSegment() {\n+        try (ResourceScope scope = ResourceScope.newSharedScope()) {\n+            MemorySegment segment = MemorySegment.allocateNative(16, scope);\n@@ -705,1 +721,1 @@\n-                { (Supplier<MemorySegment>) () -> MemorySegment.allocateNative(16) },\n+                { (Supplier<MemorySegment>) () -> MemorySegment.allocateNative(16, ResourceScope.newImplicitScope()) },\n@@ -710,0 +726,31 @@\n+    @DataProvider(name = \"closeableScopes\")\n+    public static Object[][] closeableScopes() {\n+        return new Object[][] {\n+                { (Supplier<ResourceScope>) () -> ResourceScope.newSharedScope()   },\n+                { (Supplier<ResourceScope>) () -> ResourceScope.newConfinedScope() },\n+                { (Supplier<ResourceScope>) () -> ResourceScope.newSharedScope(Cleaner.create())   },\n+                { (Supplier<ResourceScope>) () -> ResourceScope.newConfinedScope(Cleaner.create()) }\n+        };\n+    }\n+\n+    @DataProvider(name = \"implicitScopes\")\n+    public static Object[][] implicitScopes() {\n+        return new Object[][] {\n+                { (Supplier<ResourceScope>) ResourceScope::newImplicitScope },\n+                { (Supplier<ResourceScope>) ResourceScope::globalScope      },\n+        };\n+    }\n+\n+    @DataProvider(name = \"allScopes\")\n+    public static Object[][] allScopes() {\n+        return Stream.of(implicitScopes(), closeableScopes())\n+                .flatMap(Arrays::stream)\n+                .toArray(Object[][]::new);\n+    }\n+\n+    static ResourceScope closeableScopeOrNull(ResourceScope scope) {\n+        if (scope.isImplicit())\n+            return null;\n+        return scope;\n+    }\n+\n@@ -894,4 +941,4 @@\n-        LOAD(MappedMemorySegments::load),\n-        UNLOAD(MappedMemorySegments::unload),\n-        IS_LOADED(MappedMemorySegments::isLoaded),\n-        FORCE(MappedMemorySegments::force),\n+        LOAD(MemorySegment::load),\n+        UNLOAD(MemorySegment::unload),\n+        IS_LOADED(MemorySegment::isLoaded),\n+        FORCE(MemorySegment::force),\n","filename":"test\/jdk\/java\/foreign\/TestByteBuffer.java","additions":181,"deletions":134,"binary":false,"changes":315,"status":"modified"},{"patch":"@@ -1,185 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @modules java.base\/jdk.internal.ref\n- *          jdk.incubator.foreign\/jdk.incubator.foreign\n- * @run testng\/othervm -Dforeign.restricted=permit TestCleaner\n- *\/\n-\n-import jdk.incubator.foreign.MemorySegment;\n-import java.lang.ref.Cleaner;\n-import jdk.internal.ref.CleanerFactory;\n-\n-import org.testng.annotations.DataProvider;\n-import org.testng.annotations.Test;\n-import static org.testng.Assert.*;\n-\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.concurrent.atomic.AtomicInteger;\n-import java.util.function.Function;\n-import java.util.function.Supplier;\n-import java.util.stream.Stream;\n-\n-public class TestCleaner {\n-\n-    static class SegmentState {\n-        private AtomicInteger cleanupCalls = new AtomicInteger(0);\n-\n-        void cleanup() {\n-            cleanupCalls.incrementAndGet();\n-        }\n-\n-        int cleanupCalls() {\n-            return cleanupCalls.get();\n-        }\n-    }\n-\n-    @Test(dataProvider = \"cleaners\")\n-    public void testAtMostOnce(RegisterKind registerKind, Supplier<Cleaner> cleanerFactory, SegmentFunction segmentFunction) {\n-        SegmentState segmentState = new SegmentState();\n-        MemorySegment root = MemorySegment.allocateNative(10).share();\n-        MemorySegment segment = root.address().asSegmentRestricted(10, () -> {\n-            root.close();\n-            segmentState.cleanup();\n-        }, null);\n-\n-        if (registerKind == RegisterKind.BEFORE) {\n-            \/\/ register cleaners before\n-            segment = segment.registerCleaner(cleanerFactory.get());\n-        }\n-\n-        kickGCAndCheck(segmentState, segment);\n-\n-        segment = segmentFunction.apply(segment);\n-\n-        kickGCAndCheck(segmentState, segment);\n-\n-        if (segment.isAlive() && registerKind == RegisterKind.AFTER) {\n-            \/\/ register cleaners after\n-            segment = segment.registerCleaner(cleanerFactory.get());\n-        }\n-\n-        kickGCAndCheck(segmentState, segment);\n-        segment = null;\n-        while (segmentState.cleanupCalls() == 0) {\n-            byte[] b = new byte[100];\n-            System.gc();\n-            try {\n-                Thread.sleep(10);\n-            } catch (InterruptedException ex) {\n-                throw new AssertionError(ex);\n-            }\n-        }\n-        assertEquals(segmentState.cleanupCalls(), 1);\n-    }\n-\n-    private void kickGCAndCheck(SegmentState segmentState, MemorySegment segment) {\n-        for (int i = 0 ; i < 100 ; i++) {\n-            byte[] b = new byte[100];\n-            System.gc();\n-            Thread.onSpinWait();\n-        }\n-        \/\/check that cleanup has not been called by any cleaner yet!\n-        assertEquals(segmentState.cleanupCalls(), segment.isAlive() ? 0 : 1);\n-    }\n-\n-    @Test(dataProvider = \"segmentFunctions\")\n-    public void testBadDoubleRegister(Supplier<Cleaner> cleanerFactory, SegmentFunction segmentFunction) {\n-        MemorySegment segment = MemorySegment.allocateNative(10);\n-        segment = segment.registerCleaner(cleanerFactory.get());\n-        segment = segmentFunction.apply(segment);\n-        try {\n-            segment.registerCleaner(cleanerFactory.get()); \/\/ error here!\n-            fail();\n-        } catch (IllegalStateException ex) {\n-            if (!segment.isAlive()) {\n-                assertTrue(ex.getMessage().contains(\"This segment is already closed\"));\n-            } else {\n-                assertTrue(ex.getMessage().contains(\"Already registered with a cleaner\"));\n-            }\n-        }\n-    }\n-\n-    enum SegmentFunction implements Function<MemorySegment, MemorySegment> {\n-        IDENTITY(Function.identity()),\n-        CLOSE(s -> { s.close(); return s; }),\n-        SHARE(s -> { return s.share(); });\n-\n-        private final Function<MemorySegment, MemorySegment> segmentFunction;\n-\n-        SegmentFunction(Function<MemorySegment, MemorySegment> segmentFunction) {\n-            this.segmentFunction = segmentFunction;\n-        }\n-\n-        @Override\n-        public MemorySegment apply(MemorySegment segment) {\n-            return segmentFunction.apply(segment);\n-        }\n-    }\n-\n-    @DataProvider\n-    static Object[][] segmentFunctions() {\n-        Supplier<?>[] cleaners = {\n-                (Supplier<Cleaner>)Cleaner::create,\n-                (Supplier<Cleaner>)CleanerFactory::cleaner\n-        };\n-\n-        SegmentFunction[] segmentFunctions = SegmentFunction.values();\n-        Object[][] data = new Object[cleaners.length * segmentFunctions.length][3];\n-\n-        for (int cleaner = 0 ; cleaner < cleaners.length ; cleaner++) {\n-            for (int segmentFunction = 0 ; segmentFunction < segmentFunctions.length ; segmentFunction++) {\n-                data[cleaner + (cleaners.length * segmentFunction)] =\n-                        new Object[] { cleaners[cleaner], segmentFunctions[segmentFunction] };\n-            }\n-        }\n-\n-        return data;\n-    }\n-\n-    enum RegisterKind {\n-        BEFORE,\n-        AFTER;\n-    }\n-\n-    @DataProvider\n-    static Object[][] cleaners() {\n-        Supplier<?>[] cleaners = {\n-                (Supplier<Cleaner>)Cleaner::create,\n-                (Supplier<Cleaner>)CleanerFactory::cleaner\n-        };\n-\n-        List<Object[]> data = new ArrayList<>();\n-        for (RegisterKind kind : RegisterKind.values()) {\n-            for (Object cleaner : cleaners) {\n-                for (SegmentFunction segmentFunction : SegmentFunction.values()) {\n-                    data.add(new Object[] {kind, cleaner, segmentFunction});\n-                }\n-            }\n-        }\n-        return data.toArray(Object[][]::new);\n-    }\n-}\n","filename":"test\/jdk\/java\/foreign\/TestCleaner.java","additions":0,"deletions":185,"binary":false,"changes":185,"status":"deleted"},{"patch":"@@ -72,2 +72,2 @@\n-        testValues.add(MemoryLayout.ofStruct(constants));\n-        testValues.add(MemoryLayout.ofUnion(constants));\n+        testValues.add(MemoryLayout.structLayout(constants));\n+        testValues.add(MemoryLayout.unionLayout(constants));\n@@ -76,2 +76,2 @@\n-            testValues.add(MemoryLayout.ofSequence(ml));\n-            testValues.add(MemoryLayout.ofSequence(10, ml));\n+            testValues.add(MemoryLayout.sequenceLayout(ml));\n+            testValues.add(MemoryLayout.sequenceLayout(10, ml));\n","filename":"test\/jdk\/java\/foreign\/TestCondy.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -32,18 +32,1 @@\n- *   -Dforeign.restricted=permit\n- *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=false\n- *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=false\n- *   TestDowncall\n- * @run testng\/othervm\n- *   -Dforeign.restricted=permit\n- *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=true\n- *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=false\n- *   TestDowncall\n- * @run testng\/othervm\n- *   -Dforeign.restricted=permit\n- *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=false\n- *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=true\n- *   TestDowncall\n- * @run testng\/othervm\n- *   -Dforeign.restricted=permit\n- *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=true\n- *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=true\n+ *   --enable-native-access=ALL-UNNAMED\n@@ -56,0 +39,1 @@\n+import jdk.incubator.foreign.MemoryAddress;\n@@ -65,0 +49,1 @@\n+import jdk.incubator.foreign.SegmentAllocator;\n@@ -66,0 +51,1 @@\n+import static org.testng.Assert.*;\n@@ -72,0 +58,26 @@\n+    @Test(dataProvider=\"functions\", dataProviderClass=CallGeneratorHelper.class)\n+    public void testDowncall(int count, String fName, Ret ret, List<ParamType> paramTypes, List<StructFieldType> fields) throws Throwable {\n+        List<Consumer<Object>> checks = new ArrayList<>();\n+        MemoryAddress addr = lib.lookup(fName).get();\n+        MethodType mt = methodType(ret, paramTypes, fields);\n+        FunctionDescriptor descriptor = function(ret, paramTypes, fields);\n+        Object[] args = makeArgs(paramTypes, fields, checks);\n+        try (NativeScope scope = new NativeScope()) {\n+            boolean needsScope = mt.returnType().equals(MemorySegment.class);\n+            Object res = doCall(addr, scope, mt, descriptor, args);\n+            if (ret == Ret.NON_VOID) {\n+                checks.forEach(c -> c.accept(res));\n+                if (needsScope) {\n+                    \/\/ check that return struct has indeed been allocated in the native scope\n+                    assertEquals(((MemorySegment) res).scope(), scope.scope());\n+                    assertEquals(scope.allocatedBytes(), descriptor.returnLayout().get().byteSize());\n+                } else {\n+                    \/\/ if here, there should be no allocation through the scope!\n+                    assertEquals(scope.allocatedBytes(), 0L);\n+                }\n+            } else {\n+                \/\/ if here, there should be no allocation through the scope!\n+                assertEquals(scope.allocatedBytes(), 0L);\n+            }\n+        }\n+    }\n@@ -74,1 +86,1 @@\n-    public void testDowncall(String fName, Ret ret, List<ParamType> paramTypes, List<StructFieldType> fields) throws Throwable {\n+    public void testDowncallNoScope(int count, String fName, Ret ret, List<ParamType> paramTypes, List<StructFieldType> fields) throws Throwable {\n@@ -76,6 +88,9 @@\n-        List<MemorySegment> segments = new ArrayList<>();\n-        LibraryLookup.Symbol addr = lib.lookup(fName).get();\n-        MethodHandle mh = abi.downcallHandle(addr, methodType(ret, paramTypes, fields), function(ret, paramTypes, fields));\n-        Object[] args = makeArgs(paramTypes, fields, checks, segments);\n-        mh = mh.asSpreader(Object[].class, paramTypes.size());\n-        Object res = mh.invoke(args);\n+        MemoryAddress addr = lib.lookup(fName).get();\n+        MethodType mt = methodType(ret, paramTypes, fields);\n+        FunctionDescriptor descriptor = function(ret, paramTypes, fields);\n+        Object[] args = makeArgs(paramTypes, fields, checks);\n+        boolean needsScope = mt.returnType().equals(MemorySegment.class);\n+        if (count % 100 == 0) {\n+            System.gc();\n+        }\n+        Object res = doCall(addr, IMPLICIT_ALLOCATOR, mt, descriptor, args);\n@@ -84,0 +99,9 @@\n+            if (needsScope) {\n+                \/\/ check that return struct has indeed been allocated in the default scope\n+                try {\n+                    ((MemorySegment)res).scope().close(); \/\/ should throw\n+                    fail(\"Expected exception!\");\n+                } catch (UnsupportedOperationException ex) {\n+                    \/\/ ok\n+                }\n+            }\n@@ -85,1 +109,6 @@\n-        segments.forEach(MemorySegment::close);\n+    }\n+\n+    Object doCall(MemoryAddress addr, SegmentAllocator allocator, MethodType type, FunctionDescriptor descriptor, Object[] args) throws Throwable {\n+        MethodHandle mh = abi.downcallHandle(addr, allocator, type, descriptor);\n+        Object res = mh.invokeWithArguments(args);\n+        return res;\n@@ -104,1 +133,1 @@\n-    static Object[] makeArgs(List<ParamType> params, List<StructFieldType> fields, List<Consumer<Object>> checks, List<MemorySegment> segments) throws ReflectiveOperationException {\n+    static Object[] makeArgs(List<ParamType> params, List<StructFieldType> fields, List<Consumer<Object>> checks) throws ReflectiveOperationException {\n@@ -107,1 +136,1 @@\n-            args[i] = makeArg(params.get(i).layout(fields), checks, i == 0, segments);\n+            args[i] = makeArg(params.get(i).layout(fields), checks, i == 0);\n","filename":"test\/jdk\/java\/foreign\/TestDowncall.java","additions":57,"deletions":28,"binary":false,"changes":85,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n- * @run testng\/othervm -Dforeign.restricted=permit TestFree\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED TestFree\n@@ -36,0 +36,2 @@\n+import jdk.incubator.foreign.ResourceScope;\n+\n@@ -40,2 +42,2 @@\n-    private static MemorySegment asArrayRestricted(MemoryAddress addr, MemoryLayout layout, int numElements) {\n-        return addr.asSegmentRestricted(numElements * layout.byteSize());\n+    private static MemorySegment asArray(MemoryAddress addr, MemoryLayout layout, int numElements) {\n+        return addr.asSegment(numElements * layout.byteSize(), ResourceScope.globalScope());\n@@ -46,2 +48,2 @@\n-        MemoryAddress addr = allocateMemoryRestricted(str.length() + 1);\n-        MemorySegment seg = asArrayRestricted(addr, C_CHAR, str.length() + 1);\n+        MemoryAddress addr = allocateMemory(str.length() + 1);\n+        MemorySegment seg = asArray(addr, C_CHAR, str.length() + 1);\n@@ -51,1 +53,1 @@\n-        freeMemoryRestricted(addr);\n+        freeMemory(addr);\n","filename":"test\/jdk\/java\/foreign\/TestFree.java","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+import java.util.concurrent.atomic.AtomicBoolean;\n@@ -47,0 +48,1 @@\n+import jdk.incubator.foreign.ResourceScope;\n@@ -56,1 +58,1 @@\n-    static final int MAX_EXECUTOR_WAIT_SECONDS = 10;\n+    static final int MAX_EXECUTOR_WAIT_SECONDS = 20;\n@@ -62,0 +64,1 @@\n+    static final AtomicBoolean started = new AtomicBoolean();\n@@ -66,1 +69,2 @@\n-            MemorySegment segment = MemorySegment.allocateNative(SEGMENT_SIZE).share();\n+            ResourceScope scope = ResourceScope.newSharedScope();\n+            MemorySegment segment = MemorySegment.allocateNative(SEGMENT_SIZE, 1, scope);\n@@ -70,0 +74,1 @@\n+            started.set(false);\n@@ -76,1 +81,1 @@\n-            accessExecutor.execute(new Handshaker(segment));\n+            accessExecutor.execute(new Handshaker(scope));\n@@ -79,1 +84,1 @@\n-            assertTrue(!segment.isAlive());\n+            assertTrue(!segment.scope().isAlive());\n@@ -94,1 +99,2 @@\n-            outer: while (segment.isAlive()) {\n+            start(\"\\\"Accessor #\\\" + id\");\n+            outer: while (segment.scope().isAlive()) {\n@@ -99,1 +105,1 @@\n-                    System.out.println(\"Accessor #\" + id + \" suspending - delay (ms): \" + delay);\n+                    System.out.println(\"Accessor #\" + id + \" suspending - elapsed (ms): \" + delay);\n@@ -102,1 +108,1 @@\n-                    System.out.println(\"Accessor #\" + id + \" resuming - delay (ms): \" + delay);\n+                    System.out.println(\"Accessor #\" + id + \" resuming - elapsed (ms): \" + delay);\n@@ -107,2 +113,1 @@\n-            System.out.println(\"Accessor #\" + id + \" terminated - delay (ms): \" + delay);\n-            cleanup();\n+            System.out.println(\"Accessor #\" + id + \" terminated - elapsed (ms): \" + delay);\n@@ -113,2 +118,0 @@\n-        void cleanup() {}\n-\n@@ -124,0 +127,7 @@\n+    static void start(String name) {\n+        if (started.compareAndSet(false, true)) {\n+            long delay = System.currentTimeMillis() - start.get();\n+            System.out.println(\"Started first thread: \" + name + \" ; elapsed (ms): \" + delay);\n+        }\n+    }\n+\n@@ -184,1 +194,1 @@\n-            this.copy = MemorySegment.allocateNative(SEGMENT_SIZE).share();\n+            this.copy = MemorySegment.allocateNative(SEGMENT_SIZE, 1, segment.scope());\n@@ -193,5 +203,0 @@\n-\n-        @Override\n-        void cleanup() {\n-            copy.close();\n-        }\n@@ -234,1 +239,1 @@\n-        final MemorySegment segment;\n+        final ResourceScope scope;\n@@ -236,2 +241,2 @@\n-        Handshaker(MemorySegment segment) {\n-            this.segment = segment;\n+        Handshaker(ResourceScope scope) {\n+            this.scope = scope;\n@@ -242,0 +247,1 @@\n+            start(\"Handshaker\");\n@@ -244,1 +250,1 @@\n-                    segment.close();\n+                    scope.close();\n@@ -251,1 +257,1 @@\n-            System.out.println(\"Segment closed - delay (ms): \" + delay);\n+            System.out.println(\"Segment closed - elapsed (ms): \" + delay);\n","filename":"test\/jdk\/java\/foreign\/TestHandshake.java","additions":28,"deletions":22,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n- * @run testng\/othervm -Dforeign.restricted=permit TestIllegalLink\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED TestIllegalLink\n@@ -76,1 +76,1 @@\n-                FunctionDescriptor.ofVoid(MemoryLayout.ofPaddingBits(32)),\n+                FunctionDescriptor.ofVoid(MemoryLayout.paddingLayout(32)),\n@@ -91,1 +91,1 @@\n-                FunctionDescriptor.ofVoid(MemoryLayout.ofPaddingBits(64)),\n+                FunctionDescriptor.ofVoid(MemoryLayout.paddingLayout(64)),\n","filename":"test\/jdk\/java\/foreign\/TestIllegalLink.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n- *   -Dforeign.restricted=permit\n+ *   --enable-native-access=ALL-UNNAMED\n@@ -44,0 +44,1 @@\n+import jdk.incubator.foreign.MemoryAddress;\n@@ -57,8 +58,2 @@\n-    private static MethodHandle linkIndentity(String name, Class<?> carrier, MemoryLayout layout, boolean trivial) {\n-        LibraryLookup.Symbol ma = lookup.lookup(name).orElseThrow();\n-        MethodType mt = methodType(carrier, carrier);\n-        FunctionDescriptor fd = FunctionDescriptor.of(layout, layout);\n-        if (trivial) {\n-            fd = fd.withAttribute(TRIVIAL_ATTRIBUTE_NAME, true);\n-        }\n-        return abi.downcallHandle(ma, mt, fd);\n+    private interface RunnableX {\n+        void run() throws Throwable;\n@@ -74,8 +69,0 @@\n-    private interface RunnableX {\n-        void run() throws Throwable;\n-    }\n-\n-    private interface AddTest {\n-        void add(MethodHandle target, Object expectedResult, Object... args);\n-    }\n-\n@@ -85,0 +72,5 @@\n+\n+        interface AddTest {\n+            void add(MethodHandle target, Object expectedResult, Object... args);\n+        }\n+\n@@ -90,0 +82,14 @@\n+        interface AddIdentity {\n+            void add(String name, Class<?> carrier, MemoryLayout layout, Object arg);\n+        }\n+\n+        AddIdentity addIdentity = (name, carrier, layout, arg) -> {\n+            MemoryAddress ma = lookup.lookup(name).orElseThrow();\n+            MethodType mt = methodType(carrier, carrier);\n+            FunctionDescriptor fd = FunctionDescriptor.of(layout, layout);\n+\n+            tests.add(abi.downcallHandle(ma, mt, fd), arg, arg);\n+            tests.add(abi.downcallHandle(ma, mt, fd.withAttribute(TRIVIAL_ATTRIBUTE_NAME, true)), arg, arg);\n+            tests.add(abi.downcallHandle(mt, fd), arg, ma, arg);\n+        };\n+\n@@ -91,1 +97,1 @@\n-            LibraryLookup.Symbol ma = lookup.lookup(\"empty\").orElseThrow();\n+            MemoryAddress ma = lookup.lookup(\"empty\").orElseThrow();\n@@ -98,12 +104,6 @@\n-        tests.add(linkIndentity(\"identity_char\", byte.class, C_CHAR, false), (byte) 10, (byte) 10);\n-        tests.add(linkIndentity(\"identity_char\", byte.class, C_CHAR, true), (byte) 10, (byte) 10);\n-        tests.add(linkIndentity(\"identity_short\", short.class, C_SHORT, false), (short) 10, (short) 10);\n-        tests.add(linkIndentity(\"identity_short\", short.class, C_SHORT, true), (short) 10, (short) 10);\n-        tests.add(linkIndentity(\"identity_int\", int.class, C_INT, false), 10, 10);\n-        tests.add(linkIndentity(\"identity_int\", int.class, C_INT, true), 10, 10);\n-        tests.add(linkIndentity(\"identity_long\", long.class, C_LONG_LONG, false), 10L, 10L);\n-        tests.add(linkIndentity(\"identity_long\", long.class, C_LONG_LONG, true), 10L, 10L);\n-        tests.add(linkIndentity(\"identity_float\", float.class, C_FLOAT, false), 10F, 10F);\n-        tests.add(linkIndentity(\"identity_float\", float.class, C_FLOAT, true), 10F, 10F);\n-        tests.add(linkIndentity(\"identity_double\", double.class, C_DOUBLE, false), 10D, 10D);\n-        tests.add(linkIndentity(\"identity_double\", double.class, C_DOUBLE, true), 10D, 10D);\n+        addIdentity.add(\"identity_char\",   byte.class,   C_CHAR,   (byte) 10);\n+        addIdentity.add(\"identity_short\",  short.class,  C_SHORT, (short) 10);\n+        addIdentity.add(\"identity_int\",    int.class,    C_INT,           10);\n+        addIdentity.add(\"identity_long\",   long.class,   C_LONG_LONG,     10L);\n+        addIdentity.add(\"identity_float\",  float.class,  C_FLOAT,         10F);\n+        addIdentity.add(\"identity_double\", double.class, C_DOUBLE,        10D);\n@@ -112,1 +112,1 @@\n-            LibraryLookup.Symbol ma = lookup.lookup(\"identity_va\").orElseThrow();\n+            MemoryAddress ma = lookup.lookup(\"identity_va\").orElseThrow();\n@@ -127,1 +127,1 @@\n-                LibraryLookup.Symbol ma = lookup.lookup(\"invoke_high_arity\" + i).orElseThrow();\n+                MemoryAddress ma = lookup.lookup(\"invoke_high_arity\" + i).orElseThrow();\n","filename":"test\/jdk\/java\/foreign\/TestIntrinsics.java","additions":33,"deletions":33,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -70,4 +70,4 @@\n-                { MemoryLayout.ofSequence(MemoryLayouts.PAD_32) },\n-                { MemoryLayout.ofSequence(5, MemoryLayouts.PAD_32) },\n-                { MemoryLayout.ofStruct(MemoryLayouts.PAD_32, MemoryLayouts.PAD_32) },\n-                { MemoryLayout.ofUnion(MemoryLayouts.PAD_32, MemoryLayouts.PAD_32) },\n+                { MemoryLayout.sequenceLayout(MemoryLayouts.PAD_32) },\n+                { MemoryLayout.sequenceLayout(5, MemoryLayouts.PAD_32) },\n+                { MemoryLayout.structLayout(MemoryLayouts.PAD_32, MemoryLayouts.PAD_32) },\n+                { MemoryLayout.unionLayout(MemoryLayouts.PAD_32, MemoryLayouts.PAD_32) },\n@@ -76,1 +76,1 @@\n-                { MemoryLayout.ofStruct(\n+                { MemoryLayout.structLayout(\n@@ -79,1 +79,1 @@\n-                { MemoryLayout.ofUnion(\n+                { MemoryLayout.unionLayout(\n@@ -84,1 +84,1 @@\n-                { MemoryLayout.ofStruct(\n+                { MemoryLayout.structLayout(\n@@ -87,1 +87,1 @@\n-                { MemoryLayout.ofUnion(\n+                { MemoryLayout.unionLayout(\n@@ -91,1 +91,1 @@\n-                { MemoryLayout.ofStruct(\n+                { MemoryLayout.structLayout(\n@@ -93,1 +93,1 @@\n-                        MemoryLayout.ofStruct(\n+                        MemoryLayout.structLayout(\n@@ -96,1 +96,1 @@\n-                { MemoryLayout.ofUnion(\n+                { MemoryLayout.unionLayout(\n@@ -98,1 +98,1 @@\n-                        MemoryLayout.ofStruct(\n+                        MemoryLayout.structLayout(\n@@ -101,2 +101,2 @@\n-                { MemoryLayout.ofSequence(\n-                        MemoryLayout.ofStruct(\n+                { MemoryLayout.sequenceLayout(\n+                        MemoryLayout.structLayout(\n@@ -105,2 +105,2 @@\n-                { MemoryLayout.ofSequence(5,\n-                        MemoryLayout.ofStruct(\n+                { MemoryLayout.sequenceLayout(5,\n+                        MemoryLayout.structLayout(\n","filename":"test\/jdk\/java\/foreign\/TestLayoutConstants.java","additions":16,"deletions":16,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n-        ValueLayout newLayout = MemoryLayout.ofValueBits(layout.bitSize(), layout.order());\n+        ValueLayout newLayout = MemoryLayout.valueLayout(layout.bitSize(), layout.order());\n","filename":"test\/jdk\/java\/foreign\/TestLayoutEquality.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,0 +34,2 @@\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ResourceScope;\n@@ -36,0 +38,1 @@\n+import org.testng.SkipException;\n@@ -52,2 +55,2 @@\n-        SequenceLayout seq = MemoryLayout.ofSequence(JAVA_INT);\n-        seq.bitOffset(PathElement.groupElement(\"foo\"));\n+        SequenceLayout seq = MemoryLayout.sequenceLayout(JAVA_INT);\n+        seq.bitOffset(groupElement(\"foo\"));\n@@ -58,2 +61,2 @@\n-        SequenceLayout seq = MemoryLayout.ofSequence(JAVA_INT);\n-        seq.byteOffset(PathElement.groupElement(\"foo\"));\n+        SequenceLayout seq = MemoryLayout.sequenceLayout(JAVA_INT);\n+        seq.byteOffset(groupElement(\"foo\"));\n@@ -64,1 +67,1 @@\n-        GroupLayout g = MemoryLayout.ofStruct(JAVA_INT);\n+        GroupLayout g = MemoryLayout.structLayout(JAVA_INT);\n@@ -70,1 +73,1 @@\n-        GroupLayout g = MemoryLayout.ofStruct(JAVA_INT);\n+        GroupLayout g = MemoryLayout.structLayout(JAVA_INT);\n@@ -76,1 +79,1 @@\n-        SequenceLayout seq = MemoryLayout.ofSequence(JAVA_INT);\n+        SequenceLayout seq = MemoryLayout.sequenceLayout(JAVA_INT);\n@@ -82,1 +85,1 @@\n-        SequenceLayout seq = MemoryLayout.ofSequence(JAVA_INT);\n+        SequenceLayout seq = MemoryLayout.sequenceLayout(JAVA_INT);\n@@ -88,2 +91,2 @@\n-        GroupLayout g = MemoryLayout.ofStruct(JAVA_INT);\n-        g.bitOffset(PathElement.groupElement(\"foo\"));\n+        GroupLayout g = MemoryLayout.structLayout(JAVA_INT);\n+        g.bitOffset(groupElement(\"foo\"));\n@@ -94,2 +97,2 @@\n-        GroupLayout g = MemoryLayout.ofStruct(JAVA_INT);\n-        g.byteOffset(PathElement.groupElement(\"foo\"));\n+        GroupLayout g = MemoryLayout.structLayout(JAVA_INT);\n+        g.byteOffset(groupElement(\"foo\"));\n@@ -100,1 +103,1 @@\n-        SequenceLayout seq = MemoryLayout.ofSequence(5, JAVA_INT);\n+        SequenceLayout seq = MemoryLayout.sequenceLayout(5, JAVA_INT);\n@@ -106,1 +109,1 @@\n-        SequenceLayout seq = MemoryLayout.ofSequence(5, JAVA_INT);\n+        SequenceLayout seq = MemoryLayout.sequenceLayout(5, JAVA_INT);\n@@ -117,1 +120,1 @@\n-        SequenceLayout seq = MemoryLayout.ofSequence(5, JAVA_INT);\n+        SequenceLayout seq = MemoryLayout.sequenceLayout(5, JAVA_INT);\n@@ -123,1 +126,1 @@\n-        SequenceLayout seq = MemoryLayout.ofSequence(5, JAVA_INT);\n+        SequenceLayout seq = MemoryLayout.sequenceLayout(5, JAVA_INT);\n@@ -129,1 +132,1 @@\n-        SequenceLayout seq = MemoryLayout.ofSequence(5, JAVA_INT);\n+        SequenceLayout seq = MemoryLayout.sequenceLayout(5, JAVA_INT);\n@@ -140,1 +143,1 @@\n-        SequenceLayout seq = MemoryLayout.ofSequence(5, JAVA_INT);\n+        SequenceLayout seq = MemoryLayout.sequenceLayout(5, JAVA_INT);\n@@ -146,1 +149,1 @@\n-        SequenceLayout seq = MemoryLayout.ofSequence(5, JAVA_INT);\n+        SequenceLayout seq = MemoryLayout.sequenceLayout(5, JAVA_INT);\n@@ -152,1 +155,1 @@\n-        SequenceLayout seq = MemoryLayout.ofSequence(5, MemoryLayout.ofStruct(JAVA_INT));\n+        SequenceLayout seq = MemoryLayout.sequenceLayout(5, MemoryLayout.structLayout(JAVA_INT));\n@@ -158,1 +161,1 @@\n-        SequenceLayout seq = MemoryLayout.ofSequence(5, MemoryLayout.ofStruct(JAVA_INT));\n+        SequenceLayout seq = MemoryLayout.sequenceLayout(5, MemoryLayout.structLayout(JAVA_INT));\n@@ -164,1 +167,1 @@\n-        SequenceLayout seq = MemoryLayout.ofSequence(5, MemoryLayout.ofStruct(JAVA_INT));\n+        SequenceLayout seq = MemoryLayout.sequenceLayout(5, MemoryLayout.structLayout(JAVA_INT));\n@@ -170,2 +173,2 @@\n-        GroupLayout g = MemoryLayout.ofStruct(MemoryLayout.ofPaddingBits(3), JAVA_INT.withName(\"foo\"));\n-        g.byteOffset(PathElement.groupElement(\"foo\"));\n+        GroupLayout g = MemoryLayout.structLayout(MemoryLayout.paddingLayout(3), JAVA_INT.withName(\"foo\"));\n+        g.byteOffset(groupElement(\"foo\"));\n@@ -176,1 +179,1 @@\n-        MemoryLayout layout = MemoryLayout.ofSequence(MemoryLayout.ofSequence(JAVA_INT));\n+        MemoryLayout layout = MemoryLayout.sequenceLayout(MemoryLayout.sequenceLayout(JAVA_INT));\n@@ -182,1 +185,1 @@\n-        MemoryLayout layout = MemoryLayout.ofSequence(MemoryLayout.ofSequence(JAVA_INT));\n+        MemoryLayout layout = MemoryLayout.sequenceLayout(MemoryLayout.sequenceLayout(JAVA_INT));\n@@ -188,1 +191,1 @@\n-        MemoryLayout layout = MemoryLayout.ofSequence(MemoryLayout.ofSequence(JAVA_INT));\n+        MemoryLayout layout = MemoryLayout.sequenceLayout(MemoryLayout.sequenceLayout(JAVA_INT));\n@@ -194,1 +197,1 @@\n-        MemoryLayout layout = MemoryLayout.ofSequence(MemoryLayout.ofSequence(JAVA_INT));\n+        MemoryLayout layout = MemoryLayout.sequenceLayout(MemoryLayout.sequenceLayout(JAVA_INT));\n@@ -200,1 +203,1 @@\n-        MemoryLayout layout = MemoryLayout.ofStruct(MemoryLayout.ofPaddingBits(7), JAVA_INT.withName(\"x\"));\n+        MemoryLayout layout = MemoryLayout.structLayout(MemoryLayout.paddingLayout(7), JAVA_INT.withName(\"x\"));\n@@ -206,1 +209,1 @@\n-        MemoryLayout layout = MemoryLayout.ofStruct(MemoryLayout.ofPaddingBits(7), JAVA_INT.withName(\"x\"));\n+        MemoryLayout layout = MemoryLayout.structLayout(MemoryLayout.paddingLayout(7), JAVA_INT.withName(\"x\"));\n@@ -213,1 +216,1 @@\n-        GroupLayout g = MemoryLayout.ofStruct(JAVA_INT.withBitAlignment(16).withName(\"foo\")).withBitAlignment(8);\n+        GroupLayout g = MemoryLayout.structLayout(JAVA_INT.withBitAlignment(16).withName(\"foo\")).withBitAlignment(8);\n@@ -215,2 +218,2 @@\n-            g.bitOffset(PathElement.groupElement(\"foo\"));\n-            g.byteOffset(PathElement.groupElement(\"foo\"));\n+            g.bitOffset(groupElement(\"foo\"));\n+            g.byteOffset(groupElement(\"foo\"));\n@@ -221,1 +224,1 @@\n-            g.varHandle(int.class, PathElement.groupElement(\"foo\")); \/\/ok\n+            g.varHandle(int.class, groupElement(\"foo\")); \/\/ok\n@@ -232,1 +235,1 @@\n-        GroupLayout g = MemoryLayout.ofStruct(MemoryLayouts.PAD_8, JAVA_INT.withBitAlignment(16).withName(\"foo\"));\n+        GroupLayout g = MemoryLayout.structLayout(MemoryLayouts.PAD_8, JAVA_INT.withBitAlignment(16).withName(\"foo\"));\n@@ -234,2 +237,2 @@\n-            g.bitOffset(PathElement.groupElement(\"foo\"));\n-            g.byteOffset(PathElement.groupElement(\"foo\"));\n+            g.bitOffset(groupElement(\"foo\"));\n+            g.byteOffset(groupElement(\"foo\"));\n@@ -240,1 +243,1 @@\n-            g.varHandle(int.class, PathElement.groupElement(\"foo\")); \/\/ok\n+            g.varHandle(int.class, groupElement(\"foo\")); \/\/ok\n@@ -251,1 +254,1 @@\n-        SequenceLayout seq = MemoryLayout.ofSequence(10, JAVA_INT);\n+        SequenceLayout seq = MemoryLayout.sequenceLayout(10, JAVA_INT);\n@@ -271,1 +274,1 @@\n-        SequenceLayout seq = MemoryLayout.ofSequence(10, JAVA_INT);\n+        SequenceLayout seq = MemoryLayout.sequenceLayout(10, JAVA_INT);\n@@ -284,1 +287,1 @@\n-        SequenceLayout seq = MemoryLayout.ofSequence(10, JAVA_INT);\n+        SequenceLayout seq = MemoryLayout.sequenceLayout(10, JAVA_INT);\n@@ -298,1 +301,1 @@\n-        GroupLayout g = MemoryLayout.ofStruct(\n+        GroupLayout g = MemoryLayout.structLayout(\n@@ -308,1 +311,1 @@\n-            MemoryLayout selected = g.select(PathElement.groupElement(String.valueOf(i)));\n+            MemoryLayout selected = g.select(groupElement(String.valueOf(i)));\n@@ -315,1 +318,1 @@\n-            long bitOffset = g.bitOffset(PathElement.groupElement(String.valueOf(i)));\n+            long bitOffset = g.bitOffset(groupElement(String.valueOf(i)));\n@@ -317,1 +320,1 @@\n-            long byteOffset = g.byteOffset(PathElement.groupElement(String.valueOf(i)));\n+            long byteOffset = g.byteOffset(groupElement(String.valueOf(i)));\n@@ -324,1 +327,1 @@\n-            GroupLayout g2 = (GroupLayout)g.map(l -> MemoryLayouts.JAVA_DOUBLE, PathElement.groupElement(String.valueOf(i)));\n+            GroupLayout g2 = (GroupLayout)g.map(l -> MemoryLayouts.JAVA_DOUBLE, groupElement(String.valueOf(i)));\n@@ -339,1 +342,1 @@\n-        GroupLayout g = MemoryLayout.ofUnion(\n+        GroupLayout g = MemoryLayout.unionLayout(\n@@ -349,1 +352,1 @@\n-            MemoryLayout selected = g.select(PathElement.groupElement(String.valueOf(i)));\n+            MemoryLayout selected = g.select(groupElement(String.valueOf(i)));\n@@ -356,1 +359,1 @@\n-            long bitOffset = g.bitOffset(PathElement.groupElement(String.valueOf(i)));\n+            long bitOffset = g.bitOffset(groupElement(String.valueOf(i)));\n@@ -358,1 +361,1 @@\n-            long byteOffset = g.byteOffset(PathElement.groupElement(String.valueOf(i)));\n+            long byteOffset = g.byteOffset(groupElement(String.valueOf(i)));\n@@ -365,1 +368,1 @@\n-            GroupLayout g2 = (GroupLayout)g.map(l -> MemoryLayouts.JAVA_DOUBLE, PathElement.groupElement(String.valueOf(i)));\n+            GroupLayout g2 = (GroupLayout)g.map(l -> MemoryLayouts.JAVA_DOUBLE, groupElement(String.valueOf(i)));\n@@ -380,1 +383,1 @@\n-        SequenceLayout g = MemoryLayout.ofSequence(4, MemoryLayouts.JAVA_BYTE);\n+        SequenceLayout g = MemoryLayout.sequenceLayout(4, MemoryLayouts.JAVA_BYTE);\n@@ -402,1 +405,1 @@\n-    @Test(dataProvider =  \"offsetHandleCases\")\n+    @Test(dataProvider = \"testLayouts\")\n@@ -418,1 +421,1 @@\n-    public static Object[][] offsetHandleCases() {\n+    public static Object[][] testLayouts() {\n@@ -422,1 +425,1 @@\n-            MemoryLayout.ofSequence(10, JAVA_INT),\n+            MemoryLayout.sequenceLayout(10, JAVA_INT),\n@@ -428,1 +431,1 @@\n-            MemoryLayout.ofSequence(10, MemoryLayout.ofStruct(JAVA_INT, JAVA_INT.withName(\"y\"))),\n+            MemoryLayout.sequenceLayout(10, MemoryLayout.structLayout(JAVA_INT, JAVA_INT.withName(\"y\"))),\n@@ -434,1 +437,1 @@\n-            MemoryLayout.ofSequence(10, MemoryLayout.ofStruct(MemoryLayout.ofPaddingBits(5), JAVA_INT.withName(\"y\"))),\n+            MemoryLayout.sequenceLayout(10, MemoryLayout.structLayout(MemoryLayout.paddingLayout(5), JAVA_INT.withName(\"y\"))),\n@@ -440,1 +443,1 @@\n-            MemoryLayout.ofSequence(10, JAVA_INT),\n+            MemoryLayout.sequenceLayout(10, JAVA_INT),\n@@ -446,2 +449,2 @@\n-            MemoryLayout.ofStruct(\n-                MemoryLayout.ofSequence(10, JAVA_INT).withName(\"data\")\n+            MemoryLayout.structLayout(\n+                MemoryLayout.sequenceLayout(10, JAVA_INT).withName(\"data\")\n@@ -454,4 +457,4 @@\n-        MemoryLayout complexLayout = MemoryLayout.ofStruct(\n-            MemoryLayout.ofSequence(10,\n-                MemoryLayout.ofSequence(10,\n-                    MemoryLayout.ofStruct(\n+        MemoryLayout complexLayout = MemoryLayout.structLayout(\n+            MemoryLayout.sequenceLayout(10,\n+                MemoryLayout.sequenceLayout(10,\n+                    MemoryLayout.structLayout(\n@@ -493,0 +496,68 @@\n+    @Test(dataProvider = \"testLayouts\")\n+    public void testSliceHandle(MemoryLayout layout, PathElement[] pathElements, long[] indexes,\n+                                long expectedBitOffset) throws Throwable {\n+        if (expectedBitOffset % 8 != 0)\n+            throw new SkipException(\"Offset not a multiple of 8\");\n+\n+        MemoryLayout selected = layout.select(pathElements);\n+        MethodHandle sliceHandle = layout.sliceHandle(pathElements);\n+        sliceHandle = sliceHandle.asSpreader(long[].class, indexes.length);\n+\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            MemorySegment segment = MemorySegment.allocateNative(layout, scope);\n+            MemorySegment slice = (MemorySegment) sliceHandle.invokeExact(segment, indexes);\n+            assertEquals(slice.address().segmentOffset(segment), expectedBitOffset \/ 8);\n+            assertEquals(slice.byteSize(), selected.byteSize());\n+        }\n+    }\n+\n+    @Test(expectedExceptions = UnsupportedOperationException.class)\n+    public void testSliceHandleUOEInvalidSize() {\n+        MemoryLayout layout = MemoryLayout.structLayout(\n+            MemoryLayout.valueLayout(32, ByteOrder.nativeOrder()).withName(\"x\"),\n+            MemoryLayout.valueLayout(31, ByteOrder.nativeOrder()).withName(\"y\") \/\/ size not a multiple of 8\n+        );\n+\n+        layout.sliceHandle(groupElement(\"y\")); \/\/ should throw\n+    }\n+\n+    @Test(expectedExceptions = UnsupportedOperationException.class)\n+    public void testSliceHandleUOEInvalidOffsetEager() throws Throwable {\n+        MemoryLayout layout = MemoryLayout.structLayout(\n+            MemoryLayout.paddingLayout(5),\n+            MemoryLayout.valueLayout(32, ByteOrder.nativeOrder()).withName(\"y\") \/\/ offset not a multiple of 8\n+        );\n+\n+        layout.sliceHandle(groupElement(\"y\")); \/\/ should throw\n+    }\n+\n+    @Test(expectedExceptions = UnsupportedOperationException.class)\n+    public void testSliceHandleUOEInvalidOffsetLate() throws Throwable {\n+        MemoryLayout layout = MemoryLayout.sequenceLayout(3,\n+            MemoryLayout.structLayout(\n+                MemoryLayout.paddingLayout(4),\n+                MemoryLayout.valueLayout(32, ByteOrder.nativeOrder()).withName(\"y\") \/\/ offset not a multiple of 8\n+            )\n+        );\n+\n+        MethodHandle sliceHandle;\n+        try {\n+            sliceHandle = layout.sliceHandle(sequenceElement(), groupElement(\"y\")); \/\/ should work\n+        } catch (UnsupportedOperationException uoe) {\n+            fail(\"Unexpected exception\", uoe);\n+            return;\n+        }\n+\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            MemorySegment segment = MemorySegment.allocateNative(layout, scope);\n+\n+            try {\n+                sliceHandle.invokeExact(segment, 1); \/\/ should work\n+            } catch (UnsupportedOperationException uoe) {\n+                fail(\"Unexpected exception\", uoe);\n+                return;\n+            }\n+\n+            sliceHandle.invokeExact(segment, 0); \/\/ should throw\n+        }\n+    }\n","filename":"test\/jdk\/java\/foreign\/TestLayoutPaths.java","additions":135,"deletions":64,"binary":false,"changes":199,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n-        MemoryLayout layout = MemoryLayout.ofStruct(\n+        MemoryLayout layout = MemoryLayout.structLayout(\n@@ -55,2 +55,2 @@\n-                MemoryLayout.ofPaddingBits(32),\n-                MemoryLayout.ofSequence(MemoryLayouts.JAVA_DOUBLE).withName(\"arr\"));\n+                MemoryLayout.paddingLayout(32),\n+                MemoryLayout.sequenceLayout(MemoryLayouts.JAVA_DOUBLE).withName(\"arr\"));\n@@ -62,2 +62,3 @@\n-        try (MemorySegment segment = MemorySegment.allocateNative(\n-                layout.map(l -> ((SequenceLayout)l).withElementCount(4), MemoryLayout.PathElement.groupElement(\"arr\")))) {\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            MemorySegment segment = MemorySegment.allocateNative(\n+                    layout.map(l -> ((SequenceLayout)l).withElementCount(4), MemoryLayout.PathElement.groupElement(\"arr\")), scope);\n@@ -78,1 +79,1 @@\n-        MemoryLayout layout = MemoryLayout.ofStruct(\n+        MemoryLayout layout = MemoryLayout.structLayout(\n@@ -80,2 +81,2 @@\n-                MemoryLayout.ofPaddingBits(32),\n-                MemoryLayout.ofSequence(1, MemoryLayout.ofSequence(MemoryLayouts.JAVA_DOUBLE)).withName(\"arr\"));\n+                MemoryLayout.paddingLayout(32),\n+                MemoryLayout.sequenceLayout(1, MemoryLayout.sequenceLayout(MemoryLayouts.JAVA_DOUBLE)).withName(\"arr\"));\n@@ -88,2 +89,3 @@\n-        try (MemorySegment segment = MemorySegment.allocateNative(\n-                layout.map(l -> ((SequenceLayout)l).withElementCount(4), MemoryLayout.PathElement.groupElement(\"arr\"), MemoryLayout.PathElement.sequenceElement()))) {\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            MemorySegment segment = MemorySegment.allocateNative(\n+                    layout.map(l -> ((SequenceLayout)l).withElementCount(4), MemoryLayout.PathElement.groupElement(\"arr\"), MemoryLayout.PathElement.sequenceElement()), scope);\n@@ -104,2 +106,3 @@\n-        MemoryLayout seq = MemoryLayout.ofSequence(10, MemoryLayouts.JAVA_INT);\n-        try (MemorySegment segment = MemorySegment.allocateNative(seq)) {\n+        MemoryLayout seq = MemoryLayout.sequenceLayout(10, MemoryLayouts.JAVA_INT);\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            MemorySegment segment = MemorySegment.allocateNative(seq, scope);\n@@ -143,1 +146,1 @@\n-        SequenceLayout seq = MemoryLayout.ofSequence(MemoryLayouts.JAVA_INT);\n+        SequenceLayout seq = MemoryLayout.sequenceLayout(MemoryLayouts.JAVA_INT);\n@@ -149,1 +152,1 @@\n-        SequenceLayout seq = MemoryLayout.ofSequence(10, MemoryLayouts.JAVA_INT);\n+        SequenceLayout seq = MemoryLayout.sequenceLayout(10, MemoryLayouts.JAVA_INT);\n@@ -155,1 +158,1 @@\n-        MemoryLayout struct = MemoryLayout.ofStruct();\n+        MemoryLayout struct = MemoryLayout.structLayout();\n@@ -159,1 +162,1 @@\n-        MemoryLayout union = MemoryLayout.ofUnion();\n+        MemoryLayout union = MemoryLayout.unionLayout();\n@@ -166,2 +169,2 @@\n-        MemoryLayout struct = MemoryLayout.ofStruct(\n-                MemoryLayout.ofPaddingBits(8),\n+        MemoryLayout struct = MemoryLayout.structLayout(\n+                MemoryLayout.paddingLayout(8),\n@@ -179,1 +182,1 @@\n-        assertEquals(MemoryLayout.ofPaddingBits(layout.bitSize()).bitAlignment(), 1);\n+        assertEquals(MemoryLayout.paddingLayout(layout.bitSize()).bitAlignment(), 1);\n@@ -184,2 +187,2 @@\n-        MemoryLayout struct = MemoryLayout.ofStruct(\n-                layout, MemoryLayout.ofPaddingBits(128 - layout.bitSize()));\n+        MemoryLayout struct = MemoryLayout.structLayout(\n+                layout, MemoryLayout.paddingLayout(128 - layout.bitSize()));\n@@ -191,2 +194,2 @@\n-        MemoryLayout struct = MemoryLayout.ofUnion(\n-                layout, MemoryLayout.ofPaddingBits(128 - layout.bitSize()));\n+        MemoryLayout struct = MemoryLayout.unionLayout(\n+                layout, MemoryLayout.paddingLayout(128 - layout.bitSize()));\n@@ -198,1 +201,1 @@\n-        MemoryLayout struct = MemoryLayout.ofUnion(\n+        MemoryLayout struct = MemoryLayout.unionLayout(\n@@ -240,9 +243,9 @@\n-                { MemoryLayout.ofSequence(MemoryLayouts.JAVA_INT), 32 },\n-                { MemoryLayout.ofSequence(MemoryLayout.ofSequence(MemoryLayouts.JAVA_INT)), 32 },\n-                { MemoryLayout.ofSequence(4, MemoryLayout.ofSequence(MemoryLayouts.JAVA_INT)), 32 },\n-                { MemoryLayout.ofStruct(MemoryLayout.ofSequence(MemoryLayouts.JAVA_INT)), 32 },\n-                { MemoryLayout.ofStruct(MemoryLayout.ofSequence(MemoryLayout.ofSequence(MemoryLayouts.JAVA_INT))), 32 },\n-                { MemoryLayout.ofStruct(MemoryLayout.ofSequence(4, MemoryLayout.ofSequence(MemoryLayouts.JAVA_INT))), 32 },\n-                { MemoryLayout.ofUnion(MemoryLayout.ofSequence(MemoryLayouts.JAVA_INT)), 32 },\n-                { MemoryLayout.ofUnion(MemoryLayout.ofSequence(MemoryLayout.ofSequence(MemoryLayouts.JAVA_INT))), 32 },\n-                { MemoryLayout.ofUnion(MemoryLayout.ofSequence(4, MemoryLayout.ofSequence(MemoryLayouts.JAVA_INT))), 32 },\n+                { MemoryLayout.sequenceLayout(MemoryLayouts.JAVA_INT), 32 },\n+                { MemoryLayout.sequenceLayout(MemoryLayout.sequenceLayout(MemoryLayouts.JAVA_INT)), 32 },\n+                { MemoryLayout.sequenceLayout(4, MemoryLayout.sequenceLayout(MemoryLayouts.JAVA_INT)), 32 },\n+                { MemoryLayout.structLayout(MemoryLayout.sequenceLayout(MemoryLayouts.JAVA_INT)), 32 },\n+                { MemoryLayout.structLayout(MemoryLayout.sequenceLayout(MemoryLayout.sequenceLayout(MemoryLayouts.JAVA_INT))), 32 },\n+                { MemoryLayout.structLayout(MemoryLayout.sequenceLayout(4, MemoryLayout.sequenceLayout(MemoryLayouts.JAVA_INT))), 32 },\n+                { MemoryLayout.unionLayout(MemoryLayout.sequenceLayout(MemoryLayouts.JAVA_INT)), 32 },\n+                { MemoryLayout.unionLayout(MemoryLayout.sequenceLayout(MemoryLayout.sequenceLayout(MemoryLayouts.JAVA_INT))), 32 },\n+                { MemoryLayout.unionLayout(MemoryLayout.sequenceLayout(4, MemoryLayout.sequenceLayout(MemoryLayouts.JAVA_INT))), 32 },\n@@ -271,4 +274,4 @@\n-        VALUE_LE(size -> MemoryLayout.ofValueBits(size, ByteOrder.LITTLE_ENDIAN)),\n-        VALUE_BE(size -> MemoryLayout.ofValueBits(size, ByteOrder.BIG_ENDIAN)),\n-        PADDING(MemoryLayout::ofPaddingBits),\n-        SEQUENCE(size -> MemoryLayout.ofSequence(size, MemoryLayouts.PAD_8));\n+        VALUE_LE(size -> MemoryLayout.valueLayout(size, ByteOrder.LITTLE_ENDIAN)),\n+        VALUE_BE(size -> MemoryLayout.valueLayout(size, ByteOrder.BIG_ENDIAN)),\n+        PADDING(MemoryLayout::paddingLayout),\n+        SEQUENCE(size -> MemoryLayout.sequenceLayout(size, MemoryLayouts.PAD_8));\n@@ -291,3 +294,3 @@\n-        SEQUENCE(MemoryLayout.ofSequence(1, MemoryLayouts.PAD_8)),\n-        STRUCT(MemoryLayout.ofStruct(MemoryLayouts.PAD_8, MemoryLayouts.PAD_8)),\n-        UNION(MemoryLayout.ofUnion(MemoryLayouts.PAD_8, MemoryLayouts.PAD_8));\n+        SEQUENCE(MemoryLayout.sequenceLayout(1, MemoryLayouts.PAD_8)),\n+        STRUCT(MemoryLayout.structLayout(MemoryLayouts.PAD_8, MemoryLayouts.PAD_8)),\n+        UNION(MemoryLayout.unionLayout(MemoryLayouts.PAD_8, MemoryLayouts.PAD_8));\n@@ -319,1 +322,1 @@\n-            layoutsAndAlignments[i++] = new Object[] { MemoryLayout.ofSequence(4, l), l.bitAlignment() };\n+            layoutsAndAlignments[i++] = new Object[] { MemoryLayout.sequenceLayout(4, l), l.bitAlignment() };\n@@ -323,1 +326,1 @@\n-            layoutsAndAlignments[i++] = new Object[] { MemoryLayout.ofStruct(l), l.bitAlignment() };\n+            layoutsAndAlignments[i++] = new Object[] { MemoryLayout.structLayout(l), l.bitAlignment() };\n@@ -327,1 +330,1 @@\n-            layoutsAndAlignments[i++] = new Object[] { MemoryLayout.ofUnion(l), l.bitAlignment() };\n+            layoutsAndAlignments[i++] = new Object[] { MemoryLayout.unionLayout(l), l.bitAlignment() };\n","filename":"test\/jdk\/java\/foreign\/TestLayouts.java","additions":46,"deletions":43,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n- * @run testng\/othervm -Dforeign.restricted=permit TestLibraryLookup\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED TestLibraryLookup\n@@ -32,0 +32,1 @@\n+import jdk.incubator.foreign.MemoryAccess;\n@@ -33,0 +34,3 @@\n+import jdk.incubator.foreign.MemoryLayout;\n+import jdk.incubator.foreign.MemoryLayouts;\n+import jdk.incubator.foreign.MemorySegment;\n@@ -69,1 +73,1 @@\n-        LibraryLookup.Symbol symbol = null;\n+        MemoryAddress symbol = null;\n@@ -72,1 +76,0 @@\n-        assertEquals(symbol.name(), \"f\");\n@@ -81,1 +84,1 @@\n-        LibraryLookup.Symbol symbol = null;\n+        MemoryAddress symbol = null;\n@@ -90,0 +93,26 @@\n+    @Test\n+    public void testVariableSymbolLookup() throws Throwable {\n+        LibraryLookup lookup = LibraryLookup.ofLibrary(\"LookupTest\");\n+        MemorySegment segment = lookup.lookup(\"c\", MemoryLayouts.JAVA_INT).get();\n+        assertEquals(MemoryAccess.getInt(segment), 42);\n+        lookup = null;\n+        segment = null;\n+        waitUnload();\n+    }\n+\n+    @Test\n+    public void testBadVariableSymbolLookup() {\n+        LibraryLookup lookup = LibraryLookup.ofLibrary(\"LookupTest\");\n+        try {\n+            MemoryLayout layout = MemoryLayouts.JAVA_INT.withBitAlignment(1 << 16);\n+            MemorySegment segment = lookup.lookup(\"c\", layout).get();\n+            \/\/ no exception, check that address is aligned\n+            if ((segment.address().toRawLongValue() % layout.byteAlignment()) != 0) {\n+                fail(\"Unaligned address\");\n+            }\n+        } catch (IllegalArgumentException ex) {\n+            \/\/ ok, means address was not aligned\n+        }\n+\n+    }\n+\n@@ -92,1 +121,1 @@\n-        List<LibraryLookup.Symbol> symbols = new ArrayList<>();\n+        List<MemoryAddress> symbols = new ArrayList<>();\n@@ -96,1 +125,1 @@\n-            LibraryLookup.Symbol symbol = lookup.lookup(\"f\").get();\n+            MemoryAddress symbol = lookup.lookup(\"f\").get();\n@@ -154,1 +183,1 @@\n-        public static LibraryLookup.Symbol symbol;\n+        public static MemoryAddress symbol;\n","filename":"test\/jdk\/java\/foreign\/TestLibraryLookup.java","additions":36,"deletions":7,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -0,0 +1,259 @@\n+\/*\n+ * @test\n+ * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n+ * @modules jdk.incubator.foreign\/jdk.internal.foreign\n+ * @build NativeTestHelper CallGeneratorHelper TestUpcallHighArity TestUpcall TestDowncall\n+ *\n+ * @run testng\/othervm\/native\n+ *   --enable-native-access=ALL-UNNAMED\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=false\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=false\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_SPEC=true\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_INTRINSICS=true\n+ *   TestUpcallHighArity\n+ * @run testng\/othervm\/native\n+ *   --enable-native-access=ALL-UNNAMED\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=true\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=false\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_SPEC=true\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_INTRINSICS=true\n+ *   TestUpcallHighArity\n+ * @run testng\/othervm\/native\n+ *   --enable-native-access=ALL-UNNAMED\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=false\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=true\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_SPEC=true\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_INTRINSICS=true\n+ *   TestUpcallHighArity\n+ * @run testng\/othervm\/native\n+ *   --enable-native-access=ALL-UNNAMED\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=true\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=true\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_SPEC=true\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_INTRINSICS=true\n+ *   TestUpcallHighArity\n+ *\n+  * @run testng\/othervm\/native\n+ *   --enable-native-access=ALL-UNNAMED\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=false\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=false\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_SPEC=true\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_INTRINSICS=false\n+ *   TestUpcallHighArity\n+ * @run testng\/othervm\/native\n+ *   --enable-native-access=ALL-UNNAMED\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=true\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=false\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_SPEC=true\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_INTRINSICS=false\n+ *   TestUpcallHighArity\n+ * @run testng\/othervm\/native\n+ *   --enable-native-access=ALL-UNNAMED\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=false\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=true\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_SPEC=true\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_INTRINSICS=false\n+ *   TestUpcallHighArity\n+ * @run testng\/othervm\/native\n+ *   --enable-native-access=ALL-UNNAMED\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=true\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=true\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_SPEC=true\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_INTRINSICS=false\n+ *   TestUpcallHighArity\n+ *\n+ * @run testng\/othervm\/native\n+ *   --enable-native-access=ALL-UNNAMED\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=false\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=false\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_SPEC=false\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_INTRINSICS=true\n+ *   TestUpcallHighArity\n+ * @run testng\/othervm\/native\n+ *   --enable-native-access=ALL-UNNAMED\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=true\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=false\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_SPEC=false\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_INTRINSICS=true\n+ *   TestUpcallHighArity\n+ * @run testng\/othervm\/native\n+ *   --enable-native-access=ALL-UNNAMED\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=false\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=true\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_SPEC=false\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_INTRINSICS=true\n+ *   TestUpcallHighArity\n+ * @run testng\/othervm\/native\n+ *   --enable-native-access=ALL-UNNAMED\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=true\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=true\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_SPEC=false\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_INTRINSICS=true\n+ *   TestUpcallHighArity\n+ *\n+ * @run testng\/othervm\/native\n+ *   --enable-native-access=ALL-UNNAMED\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=false\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=false\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_SPEC=false\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_INTRINSICS=false\n+ *   TestUpcallHighArity\n+ * @run testng\/othervm\/native\n+ *   --enable-native-access=ALL-UNNAMED\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=true\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=false\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_SPEC=false\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_INTRINSICS=false\n+ *   TestUpcallHighArity\n+ * @run testng\/othervm\/native\n+ *   --enable-native-access=ALL-UNNAMED\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=false\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=true\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_SPEC=false\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_INTRINSICS=false\n+ *   TestUpcallHighArity\n+ * @run testng\/othervm\/native\n+ *   --enable-native-access=ALL-UNNAMED\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=true\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=true\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_SPEC=false\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_INTRINSICS=false\n+ *   TestUpcallHighArity\n+ *\n+ * @run testng\/othervm\n+ *   --enable-native-access=ALL-UNNAMED\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=false\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=false\n+ *   TestDowncall\n+ * @run testng\/othervm\n+ *   --enable-native-access=ALL-UNNAMED\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=true\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=false\n+ *   TestDowncall\n+ * @run testng\/othervm\n+ *   --enable-native-access=ALL-UNNAMED\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=false\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=true\n+ *   TestDowncall\n+ * @run testng\/othervm\n+ *   --enable-native-access=ALL-UNNAMED\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=true\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=true\n+ *   TestDowncall\n+ *\n+ * @run testng\/othervm\n+ *   --enable-native-access=ALL-UNNAMED\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=true\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=false\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_SPEC=true\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_INTRINSICS=true\n+ *   TestUpcall\n+ * @run testng\/othervm\n+ *   --enable-native-access=ALL-UNNAMED\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=true\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=false\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_SPEC=true\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_INTRINSICS=true\n+ *   TestUpcall\n+ * @run testng\/othervm\n+ *   --enable-native-access=ALL-UNNAMED\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=false\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=true\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_SPEC=true\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_INTRINSICS=true\n+ *   TestUpcall\n+ * @run testng\/othervm\n+ *   --enable-native-access=ALL-UNNAMED\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=true\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=true\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_SPEC=true\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_INTRINSICS=true\n+ *   TestUpcall\n+ *\n+ * @run testng\/othervm\n+ *   --enable-native-access=ALL-UNNAMED\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=true\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=false\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_SPEC=true\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_INTRINSICS=false\n+ *   TestUpcall\n+ * @run testng\/othervm\n+ *   --enable-native-access=ALL-UNNAMED\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=true\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=false\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_SPEC=true\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_INTRINSICS=false\n+ *   TestUpcall\n+ * @run testng\/othervm\n+ *   --enable-native-access=ALL-UNNAMED\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=false\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=true\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_SPEC=true\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_INTRINSICS=false\n+ *   TestUpcall\n+ * @run testng\/othervm\n+ *   --enable-native-access=ALL-UNNAMED\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=true\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=true\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_SPEC=true\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_INTRINSICS=false\n+ *   TestUpcall\n+ *\n+ * @run testng\/othervm\n+ *   --enable-native-access=ALL-UNNAMED\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=true\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=false\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_SPEC=false\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_INTRINSICS=true\n+ *   TestUpcall\n+ * @run testng\/othervm\n+ *   --enable-native-access=ALL-UNNAMED\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=true\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=false\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_SPEC=false\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_INTRINSICS=true\n+ *   TestUpcall\n+ * @run testng\/othervm\n+ *   --enable-native-access=ALL-UNNAMED\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=false\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=true\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_SPEC=false\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_INTRINSICS=true\n+ *   TestUpcall\n+ * @run testng\/othervm\n+ *   --enable-native-access=ALL-UNNAMED\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=true\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=true\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_SPEC=false\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_INTRINSICS=true\n+ *   TestUpcall\n+ *\n+ * @run testng\/othervm\n+ *   --enable-native-access=ALL-UNNAMED\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=true\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=false\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_SPEC=false\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_INTRINSICS=false\n+ *   TestUpcall\n+ * @run testng\/othervm\n+ *   --enable-native-access=ALL-UNNAMED\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=true\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=false\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_SPEC=false\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_INTRINSICS=false\n+ *   TestUpcall\n+ * @run testng\/othervm\n+ *   --enable-native-access=ALL-UNNAMED\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=false\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=true\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_SPEC=false\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_INTRINSICS=false\n+ *   TestUpcall\n+ * @run testng\/othervm\n+ *   --enable-native-access=ALL-UNNAMED\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=true\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=true\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_SPEC=false\n+ *   -Djdk.internal.foreign.ProgrammableUpcallHandler.USE_INTRINSICS=false\n+ *   TestUpcall\n+ *\/\n","filename":"test\/jdk\/java\/foreign\/TestMatrix.java","additions":259,"deletions":0,"binary":false,"changes":259,"status":"added"},{"patch":"@@ -37,0 +37,1 @@\n+import jdk.incubator.foreign.ResourceScope;\n@@ -56,1 +57,1 @@\n-        GroupLayout layout = MemoryLayout.ofStruct(MemoryLayout.ofPaddingBits(elemLayout.bitSize()), elemLayout.withName(\"elem\"));\n+        GroupLayout layout = MemoryLayout.structLayout(MemoryLayout.paddingLayout(elemLayout.bitSize()), elemLayout.withName(\"elem\"));\n@@ -62,1 +63,1 @@\n-        SequenceLayout layout = MemoryLayout.ofSequence(2, elemLayout);\n+        SequenceLayout layout = MemoryLayout.sequenceLayout(2, elemLayout);\n@@ -68,1 +69,1 @@\n-        SequenceLayout seq = MemoryLayout.ofSequence(10, elemLayout.withName(\"elem\"));\n+        SequenceLayout seq = MemoryLayout.sequenceLayout(10, elemLayout.withName(\"elem\"));\n@@ -74,1 +75,1 @@\n-        SequenceLayout seq = MemoryLayout.ofSequence(10, MemoryLayout.ofStruct(MemoryLayout.ofPaddingBits(elemLayout.bitSize()), elemLayout.withName(\"elem\")));\n+        SequenceLayout seq = MemoryLayout.sequenceLayout(10, MemoryLayout.structLayout(MemoryLayout.paddingLayout(elemLayout.bitSize()), elemLayout.withName(\"elem\")));\n@@ -80,1 +81,1 @@\n-        SequenceLayout seq = MemoryLayout.ofSequence(10, MemoryLayout.ofSequence(2, elemLayout));\n+        SequenceLayout seq = MemoryLayout.sequenceLayout(10, MemoryLayout.sequenceLayout(2, elemLayout));\n@@ -86,2 +87,3 @@\n-        try (MemorySegment segment = viewFactory.apply(MemorySegment.allocateNative(layout))) {\n-            boolean isRO = !segment.hasAccessModes(MemorySegment.WRITE);\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            MemorySegment segment = viewFactory.apply(MemorySegment.allocateNative(layout, scope));\n+            boolean isRO = segment.isReadOnly();\n@@ -117,2 +119,3 @@\n-        try (MemorySegment segment = viewFactory.apply(MemorySegment.allocateNative(seq))) {\n-            boolean isRO = !segment.hasAccessModes(MemorySegment.WRITE);\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            MemorySegment segment = viewFactory.apply(MemorySegment.allocateNative(seq, scope));\n+            boolean isRO = segment.isReadOnly();\n@@ -150,2 +153,2 @@\n-        SequenceLayout seq = MemoryLayout.ofSequence(20,\n-                MemoryLayout.ofSequence(10, elemLayout.withName(\"elem\")));\n+        SequenceLayout seq = MemoryLayout.sequenceLayout(20,\n+                MemoryLayout.sequenceLayout(10, elemLayout.withName(\"elem\")));\n@@ -158,2 +161,2 @@\n-        SequenceLayout seq = MemoryLayout.ofSequence(20,\n-                MemoryLayout.ofSequence(10, MemoryLayout.ofStruct(MemoryLayout.ofPaddingBits(elemLayout.bitSize()), elemLayout.withName(\"elem\"))));\n+        SequenceLayout seq = MemoryLayout.sequenceLayout(20,\n+                MemoryLayout.sequenceLayout(10, MemoryLayout.structLayout(MemoryLayout.paddingLayout(elemLayout.bitSize()), elemLayout.withName(\"elem\"))));\n@@ -168,2 +171,2 @@\n-        SequenceLayout seq = MemoryLayout.ofSequence(20,\n-                MemoryLayout.ofSequence(10, MemoryLayout.ofSequence(2, elemLayout)));\n+        SequenceLayout seq = MemoryLayout.sequenceLayout(20,\n+                MemoryLayout.sequenceLayout(10, MemoryLayout.sequenceLayout(2, elemLayout)));\n@@ -185,2 +188,3 @@\n-        try (MemorySegment segment = viewFactory.apply(MemorySegment.allocateNative(seq))) {\n-            boolean isRO = !segment.hasAccessModes(MemorySegment.WRITE);\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            MemorySegment segment = viewFactory.apply(MemorySegment.allocateNative(seq, scope));\n+            boolean isRO = segment.isReadOnly();\n@@ -220,1 +224,1 @@\n-    static Function<MemorySegment, MemorySegment> IMMUTABLE = ms -> ms.withAccessModes(MemorySegment.READ | MemorySegment.CLOSE);\n+    static Function<MemorySegment, MemorySegment> IMMUTABLE = MemorySegment::asReadOnly;\n","filename":"test\/jdk\/java\/foreign\/TestMemoryAccess.java","additions":22,"deletions":18,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import jdk.incubator.foreign.ResourceScope;\n@@ -52,1 +53,2 @@\n-        try (MemorySegment segment = MemorySegment.allocateNative(aligned)) {\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            MemorySegment segment = MemorySegment.allocateNative(aligned, scope);\n@@ -64,1 +66,1 @@\n-        MemoryLayout alignedGroup = MemoryLayout.ofStruct(MemoryLayouts.PAD_8, aligned);\n+        MemoryLayout alignedGroup = MemoryLayout.structLayout(MemoryLayouts.PAD_8, aligned);\n@@ -67,1 +69,2 @@\n-        try (MemorySegment segment = MemorySegment.allocateNative(alignedGroup)) {\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            MemorySegment segment = MemorySegment.allocateNative(alignedGroup, scope);\n@@ -79,1 +82,1 @@\n-        GroupLayout alignedGroup = MemoryLayout.ofStruct(MemoryLayouts.PAD_8, aligned);\n+        GroupLayout alignedGroup = MemoryLayout.structLayout(MemoryLayouts.PAD_8, aligned);\n@@ -90,1 +93,1 @@\n-        SequenceLayout layout = MemoryLayout.ofSequence(5, MemoryLayouts.BITS_32_BE.withBitAlignment(align));\n+        SequenceLayout layout = MemoryLayout.sequenceLayout(5, MemoryLayouts.BITS_32_BE.withBitAlignment(align));\n@@ -93,1 +96,2 @@\n-            try (MemorySegment segment = MemorySegment.allocateNative(layout)) {\n+            try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+                MemorySegment segment = MemorySegment.allocateNative(layout, scope);\n@@ -109,1 +113,1 @@\n-        GroupLayout g = MemoryLayout.ofStruct(vChar.withBitAlignment(8).withName(\"a\"),\n+        GroupLayout g = MemoryLayout.structLayout(vChar.withBitAlignment(8).withName(\"a\"),\n@@ -116,1 +120,2 @@\n-        try (MemorySegment segment = MemorySegment.allocateNative(g)) {\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            MemorySegment segment = MemorySegment.allocateNative(g, scope);\n","filename":"test\/jdk\/java\/foreign\/TestMemoryAlignment.java","additions":13,"deletions":8,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import jdk.incubator.foreign.ResourceScope;\n@@ -67,1 +68,1 @@\n-            NATIVE(MemorySegment::allocateNative),\n+            NATIVE(i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope())),\n","filename":"test\/jdk\/java\/foreign\/TestMemoryCopy.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n-import jdk.incubator.foreign.MemoryAddress;\n@@ -32,1 +31,0 @@\n-import java.nio.ByteOrder;\n@@ -36,0 +34,2 @@\n+\n+import jdk.incubator.foreign.ResourceScope;\n@@ -61,1 +61,2 @@\n-        try (MemorySegment segment = MemorySegment.allocateNative(layout)) {\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            MemorySegment segment = MemorySegment.allocateNative(layout, scope);\n@@ -83,1 +84,2 @@\n-        try (MemorySegment segment = MemorySegment.allocateNative(layout)) {\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            MemorySegment segment = MemorySegment.allocateNative(layout, scope);\n@@ -105,1 +107,2 @@\n-        try (MemorySegment segment = MemorySegment.allocateNative(layout)) {\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            MemorySegment segment = MemorySegment.allocateNative(layout, scope);\n@@ -127,1 +130,2 @@\n-        try (MemorySegment segment = MemorySegment.allocateNative(layout)) {\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            MemorySegment segment = MemorySegment.allocateNative(layout, scope);\n@@ -153,1 +157,2 @@\n-        try (MemorySegment segment = MemorySegment.allocateNative(layout)) {\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            MemorySegment segment = MemorySegment.allocateNative(layout, scope);\n@@ -163,1 +168,1 @@\n-        MemoryLayout layout = MemoryLayout.ofSequence(2, MemoryLayouts.BITS_8_BE);\n+        MemoryLayout layout = MemoryLayout.sequenceLayout(2, MemoryLayouts.BITS_8_BE);\n@@ -167,1 +172,2 @@\n-        try (MemorySegment segment = MemorySegment.allocateNative(layout)) {\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            MemorySegment segment = MemorySegment.allocateNative(layout, scope);\n@@ -181,1 +187,1 @@\n-            VarHandle byteHandle = MemoryLayout.ofSequence(MemoryLayouts.JAVA_BYTE)\n+            VarHandle byteHandle = MemoryLayout.sequenceLayout(MemoryLayouts.JAVA_BYTE)\n@@ -187,1 +193,1 @@\n-            VarHandle byteHandle = MemoryLayout.ofSequence(MemoryLayouts.JAVA_BYTE)\n+            VarHandle byteHandle = MemoryLayout.sequenceLayout(MemoryLayouts.JAVA_BYTE)\n","filename":"test\/jdk\/java\/foreign\/TestMemoryHandleAsUnsigned.java","additions":17,"deletions":11,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-import jdk.incubator.foreign.MemoryAddress;\n+\n@@ -37,0 +37,1 @@\n+import jdk.incubator.foreign.ResourceScope;\n@@ -40,1 +41,0 @@\n-import static jdk.incubator.foreign.MemorySegment.READ;\n@@ -104,1 +104,2 @@\n-        try (var nativeSegment = MemorySegment.allocateNative(4)) {\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            var nativeSegment = MemorySegment.allocateNative(4, 4, scope);\n@@ -115,2 +116,3 @@\n-            try (var s1 = MemorySegment.allocateNative((long) Integer.MAX_VALUE + 10L);\n-                 var s2 = MemorySegment.allocateNative((long) Integer.MAX_VALUE + 10L)) {\n+            try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+                var s1 = MemorySegment.allocateNative((long) Integer.MAX_VALUE + 10L, 8, scope);\n+                var s2 = MemorySegment.allocateNative((long) Integer.MAX_VALUE + 10L, 8, scope);\n@@ -152,3 +154,5 @@\n-        var s1 = MemorySegment.ofArray(new byte[4]);\n-        var s2 = MemorySegment.ofArray(new byte[4]);\n-        s1.close();\n+        MemorySegment s1, s2;\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            s1 = MemorySegment.allocateNative(4, 1, scope);\n+            s2 = MemorySegment.allocateNative(4, 1, scope);\n+        }\n@@ -160,12 +164,0 @@\n-    @Test\n-    public void testInsufficientAccessModes() {\n-        var s1 = MemorySegment.ofArray(new byte[4]);\n-        var s2 = MemorySegment.ofArray(new byte[4]);\n-        var s1WithoutRead = s1.withAccessModes(s1.accessModes() & ~READ);\n-        var s2WithoutRead = s2.withAccessModes(s2.accessModes() & ~READ);\n-\n-        assertThrows(UOE, () -> s1.mismatch(s2WithoutRead));\n-        assertThrows(UOE, () -> s1WithoutRead.mismatch(s2));\n-        assertThrows(UOE, () -> s1WithoutRead.mismatch(s2WithoutRead));\n-    }\n-\n@@ -174,8 +166,18 @@\n-        var segment = MemorySegment.ofArray(new byte[4]);\n-        {\n-            AtomicReference<RuntimeException> exception = new AtomicReference<>();\n-            Runnable action = () -> {\n-                try {\n-                    MemorySegment.ofArray(new byte[4]).mismatch(segment);\n-                } catch (RuntimeException e) {\n-                    exception.set(e);\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            var segment = MemorySegment.allocateNative(4, 1, scope);\n+            {\n+                AtomicReference<RuntimeException> exception = new AtomicReference<>();\n+                Runnable action = () -> {\n+                    try {\n+                        MemorySegment.ofArray(new byte[4]).mismatch(segment);\n+                    } catch (RuntimeException e) {\n+                        exception.set(e);\n+                    }\n+                };\n+                Thread thread = new Thread(action);\n+                thread.start();\n+                thread.join();\n+\n+                RuntimeException e = exception.get();\n+                if (!(e instanceof IllegalStateException)) {\n+                    throw e;\n@@ -183,8 +185,0 @@\n-            };\n-            Thread thread = new Thread(action);\n-            thread.start();\n-            thread.join();\n-\n-            RuntimeException e = exception.get();\n-            if (!(e instanceof IllegalStateException)) {\n-                throw e;\n@@ -192,8 +186,16 @@\n-        }\n-        {\n-            AtomicReference<RuntimeException> exception = new AtomicReference<>();\n-            Runnable action = () -> {\n-                try {\n-                    segment.mismatch(MemorySegment.ofArray(new byte[4]));\n-                } catch (RuntimeException e) {\n-                    exception.set(e);\n+            {\n+                AtomicReference<RuntimeException> exception = new AtomicReference<>();\n+                Runnable action = () -> {\n+                    try {\n+                        segment.mismatch(MemorySegment.ofArray(new byte[4]));\n+                    } catch (RuntimeException e) {\n+                        exception.set(e);\n+                    }\n+                };\n+                Thread thread = new Thread(action);\n+                thread.start();\n+                thread.join();\n+\n+                RuntimeException e = exception.get();\n+                if (!(e instanceof IllegalStateException)) {\n+                    throw e;\n@@ -201,8 +203,0 @@\n-            };\n-            Thread thread = new Thread(action);\n-            thread.start();\n-            thread.join();\n-\n-            RuntimeException e = exception.get();\n-            if (!(e instanceof IllegalStateException)) {\n-                throw e;\n@@ -214,1 +208,1 @@\n-        NATIVE(MemorySegment::allocateNative),\n+        NATIVE(i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope())),\n","filename":"test\/jdk\/java\/foreign\/TestMismatch.java","additions":47,"deletions":53,"binary":false,"changes":100,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n- * @run testng\/othervm -Dforeign.restricted=permit TestNative\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED TestNative\n@@ -39,0 +39,1 @@\n+import jdk.incubator.foreign.ResourceScope;\n@@ -57,1 +58,1 @@\n-import static jdk.incubator.foreign.MemorySegment.*;\n+\n@@ -62,1 +63,1 @@\n-    static SequenceLayout bytes = MemoryLayout.ofSequence(100,\n+    static SequenceLayout bytes = MemoryLayout.sequenceLayout(100,\n@@ -66,1 +67,1 @@\n-    static SequenceLayout chars = MemoryLayout.ofSequence(100,\n+    static SequenceLayout chars = MemoryLayout.sequenceLayout(100,\n@@ -70,1 +71,1 @@\n-    static SequenceLayout shorts = MemoryLayout.ofSequence(100,\n+    static SequenceLayout shorts = MemoryLayout.sequenceLayout(100,\n@@ -74,1 +75,1 @@\n-    static SequenceLayout ints = MemoryLayout.ofSequence(100,\n+    static SequenceLayout ints = MemoryLayout.sequenceLayout(100,\n@@ -78,1 +79,1 @@\n-    static SequenceLayout floats = MemoryLayout.ofSequence(100,\n+    static SequenceLayout floats = MemoryLayout.sequenceLayout(100,\n@@ -82,1 +83,1 @@\n-    static SequenceLayout longs = MemoryLayout.ofSequence(100,\n+    static SequenceLayout longs = MemoryLayout.sequenceLayout(100,\n@@ -86,1 +87,1 @@\n-    static SequenceLayout doubles = MemoryLayout.ofSequence(100,\n+    static SequenceLayout doubles = MemoryLayout.sequenceLayout(100,\n@@ -147,1 +148,1 @@\n-        return CLinker.allocateMemoryRestricted(size);\n+        return CLinker.allocateMemory(size);\n@@ -151,1 +152,1 @@\n-        CLinker.freeMemoryRestricted(addr);\n+        CLinker.freeMemory(addr);\n@@ -156,1 +157,2 @@\n-        try (MemorySegment segment = MemorySegment.allocateNative(seq)) {\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            MemorySegment segment = MemorySegment.allocateNative(seq, scope);\n@@ -165,1 +167,2 @@\n-        try (MemorySegment segment = MemorySegment.allocateNative(doubles)) {\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            MemorySegment segment = MemorySegment.allocateNative(doubles, scope);\n@@ -177,4 +180,3 @@\n-        MemorySegment mallocSegment = addr.asSegmentRestricted(12, () -> free(addr), null);\n-        try (MemorySegment segment = mallocSegment) {\n-            assertTrue(segment.hasAccessModes(ALL_ACCESS));\n-            assertEquals(segment.accessModes(), ALL_ACCESS);\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            MemorySegment mallocSegment = addr.asSegment(12, () -> free(addr), scope);\n+            assertFalse(mallocSegment.isReadOnly());\n@@ -186,3 +188,2 @@\n-        MemorySegment everything = MemorySegment.ofNativeRestricted();\n-        assertTrue(everything.hasAccessModes(READ | WRITE));\n-        assertEquals(everything.accessModes(), READ | WRITE);\n+        MemorySegment everything = MemorySegment.globalNativeSegment();\n+        assertFalse(everything.isReadOnly());\n@@ -194,4 +195,7 @@\n-        MemorySegment mallocSegment = addr.asSegmentRestricted(12, () -> free(addr), null);\n-        assertEquals(mallocSegment.byteSize(), 12);\n-        mallocSegment.close(); \/\/free here\n-        assertTrue(!mallocSegment.isAlive());\n+        MemorySegment mallocSegment = null;\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            mallocSegment = addr.asSegment(12, () -> free(addr), scope);\n+            assertEquals(mallocSegment.byteSize(), 12);\n+            \/\/free here\n+        }\n+        assertTrue(!mallocSegment.scope().isAlive());\n@@ -203,1 +207,1 @@\n-        MemorySegment everything = MemorySegment.ofNativeRestricted();\n+        MemorySegment everything = MemorySegment.globalNativeSegment();\n@@ -211,2 +215,3 @@\n-        try (MemorySegment segment = MemorySegment.allocateNative(4)) {\n-            segment.address().asSegmentRestricted(0);\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            MemorySegment segment = MemorySegment.allocateNative(4, 1, scope);\n+            segment.address().asSegment(0, ResourceScope.globalScope());\n","filename":"test\/jdk\/java\/foreign\/TestNative.java","additions":32,"deletions":27,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -1,536 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\n- *\/\n-\n-\/*\n- * @test\n- * @run testng\/othervm TestNativeScope\n- *\/\n-\n-import jdk.incubator.foreign.*;\n-\n-import org.testng.annotations.*;\n-\n-import java.lang.invoke.VarHandle;\n-import java.lang.reflect.Array;\n-import java.lang.reflect.InvocationTargetException;\n-import java.lang.reflect.Method;\n-import java.lang.reflect.Modifier;\n-import java.nio.ByteBuffer;\n-import java.nio.ByteOrder;\n-import java.nio.DoubleBuffer;\n-import java.nio.FloatBuffer;\n-import java.nio.IntBuffer;\n-import java.nio.LongBuffer;\n-import java.nio.ShortBuffer;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.List;\n-import java.util.concurrent.atomic.AtomicBoolean;\n-import java.util.function.Function;\n-import java.util.function.Predicate;\n-import java.util.stream.IntStream;\n-import java.util.stream.LongStream;\n-\n-import static jdk.incubator.foreign.MemorySegment.CLOSE;\n-import static jdk.incubator.foreign.MemorySegment.HANDOFF;\n-import static org.testng.Assert.*;\n-\n-public class TestNativeScope {\n-\n-    final static int ELEMS = 128;\n-    final static Class<?> ADDRESS_CARRIER = MemoryLayouts.ADDRESS.bitSize() == 64 ? long.class : int.class;\n-\n-    @Test(dataProvider = \"nativeScopes\")\n-    public <Z> void testAllocation(Z value, ScopeFactory scopeFactory, ValueLayout layout, AllocationFunction<Z> allocationFunction, Function<MemoryLayout, VarHandle> handleFactory) {\n-        ValueLayout[] layouts = {\n-                layout,\n-                layout.withBitAlignment(layout.bitAlignment() * 2),\n-                layout.withBitAlignment(layout.bitAlignment() * 4),\n-                layout.withBitAlignment(layout.bitAlignment() * 8)\n-        };\n-        for (ValueLayout alignedLayout : layouts) {\n-            List<MemorySegment> addressList = new ArrayList<>();\n-            int elems = ELEMS \/ ((int)alignedLayout.byteAlignment() \/ (int)layout.byteAlignment());\n-            try (NativeScope scope = scopeFactory.make((int)alignedLayout.byteSize() * ELEMS)) {\n-                for (int i = 0 ; i < elems ; i++) {\n-                    MemorySegment address = allocationFunction.allocate(scope, alignedLayout, value);\n-                    assertEquals(address.byteSize(), alignedLayout.byteSize());\n-                    addressList.add(address);\n-                    VarHandle handle = handleFactory.apply(alignedLayout);\n-                    assertEquals(value, handle.get(address));\n-                    try {\n-                        address.close();\n-                        fail();\n-                    } catch (UnsupportedOperationException uoe) {\n-                        \/\/failure is expected\n-                        assertTrue(true);\n-                    }\n-                }\n-                boolean isBound = scope.byteSize().isPresent();\n-                try {\n-                    allocationFunction.allocate(scope, alignedLayout, value); \/\/too much, should fail if bound\n-                    assertFalse(isBound);\n-                } catch (OutOfMemoryError ex) {\n-                    \/\/failure is expected if bound\n-                    assertTrue(isBound);\n-                }\n-            }\n-            \/\/ addresses should be invalid now\n-            for (MemorySegment address : addressList) {\n-                assertFalse(address.isAlive());\n-            }\n-        }\n-    }\n-\n-    static final int SIZE_256M = 1024 * 1024 * 256;\n-\n-    @Test\n-    public void testBigAllocationInUnboundedScope() {\n-        try (NativeScope scope = NativeScope.unboundedScope()) {\n-            for (int i = 8 ; i < SIZE_256M ; i *= 8) {\n-                MemorySegment address = scope.allocate(i);\n-                \/\/check size\n-                assertEquals(address.byteSize(), i);\n-                \/\/check alignment\n-                assertTrue(address.address().toRawLongValue() % i == 0);\n-            }\n-        }\n-    }\n-\n-    @Test\n-    public void testAttachClose() {\n-        MemorySegment s1 = MemorySegment.ofArray(new byte[1]);\n-        MemorySegment s2 = MemorySegment.ofArray(new byte[1]);\n-        MemorySegment s3 = MemorySegment.ofArray(new byte[1]);\n-        assertTrue(s1.isAlive());\n-        assertTrue(s2.isAlive());\n-        assertTrue(s3.isAlive());\n-        try (NativeScope scope = NativeScope.boundedScope(10)) {\n-            MemorySegment ss1 = s1.handoff(scope);\n-            assertFalse(s1.isAlive());\n-            assertTrue(ss1.isAlive());\n-            s1 = ss1;\n-            MemorySegment ss2 = s2.handoff(scope);\n-            assertFalse(s2.isAlive());\n-            assertTrue(ss2.isAlive());\n-            s2 = ss2;\n-            MemorySegment ss3 = s3.handoff(scope);\n-            assertFalse(s3.isAlive());\n-            assertTrue(ss3.isAlive());\n-            s3 = ss3;\n-        }\n-        assertFalse(s1.isAlive());\n-        assertFalse(s2.isAlive());\n-        assertFalse(s3.isAlive());\n-    }\n-\n-    @Test\n-    public void testNoTerminalOps() {\n-        try (NativeScope scope = NativeScope.boundedScope(10)) {\n-            MemorySegment s1 = MemorySegment.ofArray(new byte[1]);\n-            MemorySegment attached = s1.handoff(scope);\n-            int[] terminalOps = {CLOSE, HANDOFF};\n-            for (int mode : terminalOps) {\n-                if (attached.hasAccessModes(mode)) {\n-                    fail();\n-                }\n-            }\n-        }\n-    }\n-\n-    @Test(expectedExceptions = UnsupportedOperationException.class)\n-    public void testNoReattach() {\n-        MemorySegment s1 = MemorySegment.ofArray(new byte[1]);\n-        NativeScope scope1 = NativeScope.boundedScope(10);\n-        NativeScope scope2 = NativeScope.boundedScope(10);\n-        s1.handoff(scope1).handoff(scope2);\n-    }\n-\n-    @Test(expectedExceptions = IllegalStateException.class)\n-    public void testNotAliveClaim() {\n-        MemorySegment segment = MemorySegment.ofArray(new byte[1]);\n-        segment.close();\n-        segment.handoff(NativeScope.boundedScope(10));\n-    }\n-\n-    @Test\n-    public void testRegisterFromUnconfined() {\n-        MemorySegment unconfined = MemorySegment.allocateNative(10).share();\n-        NativeScope scope = NativeScope.boundedScope(10);\n-        MemorySegment registered = unconfined.handoff(scope);\n-        assertFalse(unconfined.isAlive());\n-        assertEquals(registered.ownerThread(), scope.ownerThread());\n-        scope.close();\n-        assertFalse(registered.isAlive());\n-    }\n-\n-    @Test(dataProvider = \"arrayScopes\")\n-    public <Z> void testArray(ScopeFactory scopeFactory, ValueLayout layout, AllocationFunction<Object> allocationFunction, ToArrayHelper<Z> arrayHelper) {\n-        Z arr = arrayHelper.array();\n-        try (NativeScope scope = scopeFactory.make(100)) {\n-            MemorySegment address = allocationFunction.allocate(scope, layout, arr);\n-            Z found = arrayHelper.toArray(address, layout);\n-            assertEquals(found, arr);\n-        }\n-    }\n-\n-    @DataProvider(name = \"nativeScopes\")\n-    static Object[][] nativeScopes() {\n-        return new Object[][] {\n-                { (byte)42, (ScopeFactory) NativeScope::boundedScope, MemoryLayouts.BITS_8_BE,\n-                        (AllocationFunction<Byte>) NativeScope::allocate,\n-                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(byte.class) },\n-                { (short)42, (ScopeFactory) NativeScope::boundedScope, MemoryLayouts.BITS_16_BE,\n-                        (AllocationFunction<Short>) NativeScope::allocate,\n-                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(short.class) },\n-                { (char)42, (ScopeFactory) NativeScope::boundedScope, MemoryLayouts.BITS_16_BE,\n-                        (AllocationFunction<Character>) NativeScope::allocate,\n-                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(char.class) },\n-                { 42, (ScopeFactory) NativeScope::boundedScope,\n-                        MemoryLayouts.BITS_32_BE,\n-                        (AllocationFunction<Integer>) NativeScope::allocate,\n-                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(int.class) },\n-                { 42f, (ScopeFactory) NativeScope::boundedScope, MemoryLayouts.BITS_32_BE,\n-                        (AllocationFunction<Float>) NativeScope::allocate,\n-                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(float.class) },\n-                { 42L, (ScopeFactory) NativeScope::boundedScope, MemoryLayouts.BITS_64_BE,\n-                        (AllocationFunction<Long>) NativeScope::allocate,\n-                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(long.class) },\n-                { 42d, (ScopeFactory) NativeScope::boundedScope, MemoryLayouts.BITS_64_BE,\n-                        (AllocationFunction<Double>) NativeScope::allocate,\n-                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(double.class) },\n-                { MemoryAddress.ofLong(42), (ScopeFactory) NativeScope::boundedScope, MemoryLayouts.ADDRESS.withOrder(ByteOrder.BIG_ENDIAN),\n-                        (AllocationFunction<MemoryAddress>) NativeScope::allocate,\n-                        (Function<MemoryLayout, VarHandle>)l -> MemoryHandles.asAddressVarHandle(l.varHandle(ADDRESS_CARRIER)) },\n-\n-                { (byte)42, (ScopeFactory) NativeScope::boundedScope, MemoryLayouts.BITS_8_LE,\n-                        (AllocationFunction<Byte>) NativeScope::allocate,\n-                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(byte.class) },\n-                { (short)42, (ScopeFactory) NativeScope::boundedScope, MemoryLayouts.BITS_16_LE,\n-                        (AllocationFunction<Short>) NativeScope::allocate,\n-                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(short.class) },\n-                { (char)42, (ScopeFactory) NativeScope::boundedScope, MemoryLayouts.BITS_16_LE,\n-                        (AllocationFunction<Character>) NativeScope::allocate,\n-                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(char.class) },\n-                { 42, (ScopeFactory) NativeScope::boundedScope,\n-                        MemoryLayouts.BITS_32_LE,\n-                        (AllocationFunction<Integer>) NativeScope::allocate,\n-                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(int.class) },\n-                { 42f, (ScopeFactory) NativeScope::boundedScope, MemoryLayouts.BITS_32_LE,\n-                        (AllocationFunction<Float>) NativeScope::allocate,\n-                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(float.class) },\n-                { 42L, (ScopeFactory) NativeScope::boundedScope, MemoryLayouts.BITS_64_LE,\n-                        (AllocationFunction<Long>) NativeScope::allocate,\n-                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(long.class) },\n-                { 42d, (ScopeFactory) NativeScope::boundedScope, MemoryLayouts.BITS_64_LE,\n-                        (AllocationFunction<Double>) NativeScope::allocate,\n-                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(double.class) },\n-                { MemoryAddress.ofLong(42), (ScopeFactory) NativeScope::boundedScope, MemoryLayouts.ADDRESS.withOrder(ByteOrder.LITTLE_ENDIAN),\n-                        (AllocationFunction<MemoryAddress>) NativeScope::allocate,\n-                        (Function<MemoryLayout, VarHandle>)l -> MemoryHandles.asAddressVarHandle(l.varHandle(ADDRESS_CARRIER)) },\n-\n-                { (byte)42, (ScopeFactory)size -> NativeScope.unboundedScope(), MemoryLayouts.BITS_8_BE,\n-                        (AllocationFunction<Byte>) NativeScope::allocate,\n-                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(byte.class) },\n-                { (short)42, (ScopeFactory)size -> NativeScope.unboundedScope(), MemoryLayouts.BITS_16_BE,\n-                        (AllocationFunction<Short>) NativeScope::allocate,\n-                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(short.class) },\n-                { (char)42, (ScopeFactory)size -> NativeScope.unboundedScope(), MemoryLayouts.BITS_16_BE,\n-                        (AllocationFunction<Character>) NativeScope::allocate,\n-                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(char.class) },\n-                { 42, (ScopeFactory)size -> NativeScope.unboundedScope(),\n-                        MemoryLayouts.BITS_32_BE,\n-                        (AllocationFunction<Integer>) NativeScope::allocate,\n-                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(int.class) },\n-                { 42f, (ScopeFactory)size -> NativeScope.unboundedScope(), MemoryLayouts.BITS_32_BE,\n-                        (AllocationFunction<Float>) NativeScope::allocate,\n-                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(float.class) },\n-                { 42L, (ScopeFactory)size -> NativeScope.unboundedScope(), MemoryLayouts.BITS_64_BE,\n-                        (AllocationFunction<Long>) NativeScope::allocate,\n-                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(long.class) },\n-                { 42d, (ScopeFactory)size -> NativeScope.unboundedScope(), MemoryLayouts.BITS_64_BE,\n-                        (AllocationFunction<Double>) NativeScope::allocate,\n-                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(double.class) },\n-                { MemoryAddress.ofLong(42), (ScopeFactory)size -> NativeScope.unboundedScope(), MemoryLayouts.ADDRESS.withOrder(ByteOrder.BIG_ENDIAN),\n-                        (AllocationFunction<MemoryAddress>) NativeScope::allocate,\n-                        (Function<MemoryLayout, VarHandle>)l -> MemoryHandles.asAddressVarHandle(l.varHandle(ADDRESS_CARRIER)) },\n-\n-                { (byte)42, (ScopeFactory)size -> NativeScope.unboundedScope(), MemoryLayouts.BITS_8_LE,\n-                        (AllocationFunction<Byte>) NativeScope::allocate,\n-                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(byte.class) },\n-                { (short)42, (ScopeFactory)size -> NativeScope.unboundedScope(), MemoryLayouts.BITS_16_LE,\n-                        (AllocationFunction<Short>) NativeScope::allocate,\n-                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(short.class) },\n-                { (char)42, (ScopeFactory)size -> NativeScope.unboundedScope(), MemoryLayouts.BITS_16_LE,\n-                        (AllocationFunction<Character>) NativeScope::allocate,\n-                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(char.class) },\n-                { 42, (ScopeFactory)size -> NativeScope.unboundedScope(),\n-                        MemoryLayouts.BITS_32_LE,\n-                        (AllocationFunction<Integer>) NativeScope::allocate,\n-                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(int.class) },\n-                { 42f, (ScopeFactory)size -> NativeScope.unboundedScope(), MemoryLayouts.BITS_32_LE,\n-                        (AllocationFunction<Float>) NativeScope::allocate,\n-                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(float.class) },\n-                { 42L, (ScopeFactory)size -> NativeScope.unboundedScope(), MemoryLayouts.BITS_64_LE,\n-                        (AllocationFunction<Long>) NativeScope::allocate,\n-                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(long.class) },\n-                { 42d, (ScopeFactory)size -> NativeScope.unboundedScope(), MemoryLayouts.BITS_64_LE,\n-                        (AllocationFunction<Double>) NativeScope::allocate,\n-                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(double.class) },\n-                { MemoryAddress.ofLong(42), (ScopeFactory)size -> NativeScope.unboundedScope(), MemoryLayouts.ADDRESS.withOrder(ByteOrder.LITTLE_ENDIAN),\n-                        (AllocationFunction<MemoryAddress>) NativeScope::allocate,\n-                        (Function<MemoryLayout, VarHandle>)l -> MemoryHandles.asAddressVarHandle(l.varHandle(ADDRESS_CARRIER)) },\n-        };\n-    }\n-\n-    @DataProvider(name = \"arrayScopes\")\n-    static Object[][] arrayScopes() {\n-        return new Object[][] {\n-                { (ScopeFactory) NativeScope::boundedScope, MemoryLayouts.BITS_8_LE,\n-                        (AllocationFunction<byte[]>) NativeScope::allocateArray,\n-                        ToArrayHelper.toByteArray },\n-                { (ScopeFactory) NativeScope::boundedScope, MemoryLayouts.BITS_16_LE,\n-                        (AllocationFunction<short[]>) NativeScope::allocateArray,\n-                        ToArrayHelper.toShortArray },\n-                { (ScopeFactory) NativeScope::boundedScope,\n-                        MemoryLayouts.BITS_32_LE,\n-                        (AllocationFunction<int[]>) NativeScope::allocateArray,\n-                        ToArrayHelper.toIntArray },\n-                { (ScopeFactory) NativeScope::boundedScope, MemoryLayouts.BITS_32_LE,\n-                        (AllocationFunction<float[]>) NativeScope::allocateArray,\n-                        ToArrayHelper.toFloatArray },\n-                { (ScopeFactory) NativeScope::boundedScope, MemoryLayouts.BITS_64_LE,\n-                        (AllocationFunction<long[]>) NativeScope::allocateArray,\n-                        ToArrayHelper.toLongArray },\n-                { (ScopeFactory) NativeScope::boundedScope, MemoryLayouts.BITS_64_LE,\n-                        (AllocationFunction<double[]>) NativeScope::allocateArray,\n-                        ToArrayHelper.toDoubleArray },\n-                { (ScopeFactory) NativeScope::boundedScope, MemoryLayouts.ADDRESS.withOrder(ByteOrder.LITTLE_ENDIAN),\n-                        (AllocationFunction<MemoryAddress[]>) NativeScope::allocateArray,\n-                        ToArrayHelper.toAddressArray },\n-\n-\n-                { (ScopeFactory) NativeScope::boundedScope, MemoryLayouts.BITS_8_BE,\n-                        (AllocationFunction<byte[]>) NativeScope::allocateArray,\n-                        ToArrayHelper.toByteArray },\n-                { (ScopeFactory) NativeScope::boundedScope, MemoryLayouts.BITS_16_BE,\n-                        (AllocationFunction<short[]>) NativeScope::allocateArray,\n-                        ToArrayHelper.toShortArray },\n-                { (ScopeFactory) NativeScope::boundedScope,\n-                        MemoryLayouts.BITS_32_BE,\n-                        (AllocationFunction<int[]>) NativeScope::allocateArray,\n-                        ToArrayHelper.toIntArray },\n-                { (ScopeFactory) NativeScope::boundedScope, MemoryLayouts.BITS_32_BE,\n-                        (AllocationFunction<float[]>) NativeScope::allocateArray,\n-                        ToArrayHelper.toFloatArray },\n-                { (ScopeFactory) NativeScope::boundedScope, MemoryLayouts.BITS_64_BE,\n-                        (AllocationFunction<long[]>) NativeScope::allocateArray,\n-                        ToArrayHelper.toLongArray },\n-                { (ScopeFactory) NativeScope::boundedScope, MemoryLayouts.BITS_64_BE,\n-                        (AllocationFunction<double[]>) NativeScope::allocateArray,\n-                        ToArrayHelper.toDoubleArray },\n-                { (ScopeFactory) NativeScope::boundedScope, MemoryLayouts.ADDRESS.withOrder(ByteOrder.BIG_ENDIAN),\n-                        (AllocationFunction<MemoryAddress[]>) NativeScope::allocateArray,\n-                        ToArrayHelper.toAddressArray },\n-\n-                { (ScopeFactory) size -> NativeScope.unboundedScope(), MemoryLayouts.BITS_8_LE,\n-                        (AllocationFunction<byte[]>) NativeScope::allocateArray,\n-                        ToArrayHelper.toByteArray },\n-                { (ScopeFactory) size -> NativeScope.unboundedScope(), MemoryLayouts.BITS_16_LE,\n-                        (AllocationFunction<short[]>) NativeScope::allocateArray,\n-                        ToArrayHelper.toShortArray },\n-                { (ScopeFactory) size -> NativeScope.unboundedScope(),\n-                        MemoryLayouts.BITS_32_LE,\n-                        (AllocationFunction<int[]>) NativeScope::allocateArray,\n-                        ToArrayHelper.toIntArray },\n-                { (ScopeFactory) size -> NativeScope.unboundedScope(), MemoryLayouts.BITS_32_LE,\n-                        (AllocationFunction<float[]>) NativeScope::allocateArray,\n-                        ToArrayHelper.toFloatArray },\n-                { (ScopeFactory) size -> NativeScope.unboundedScope(), MemoryLayouts.BITS_64_LE,\n-                        (AllocationFunction<long[]>) NativeScope::allocateArray,\n-                        ToArrayHelper.toLongArray },\n-                { (ScopeFactory) size -> NativeScope.unboundedScope(), MemoryLayouts.BITS_64_LE,\n-                        (AllocationFunction<double[]>) NativeScope::allocateArray,\n-                        ToArrayHelper.toDoubleArray },\n-                { (ScopeFactory)size -> NativeScope.unboundedScope(), MemoryLayouts.ADDRESS.withOrder(ByteOrder.LITTLE_ENDIAN),\n-                        (AllocationFunction<MemoryAddress[]>) NativeScope::allocateArray,\n-                        ToArrayHelper.toAddressArray },\n-\n-\n-                { (ScopeFactory) size -> NativeScope.unboundedScope(), MemoryLayouts.BITS_8_BE,\n-                        (AllocationFunction<byte[]>) NativeScope::allocateArray,\n-                        ToArrayHelper.toByteArray },\n-                { (ScopeFactory) size -> NativeScope.unboundedScope(), MemoryLayouts.BITS_16_BE,\n-                        (AllocationFunction<short[]>) NativeScope::allocateArray,\n-                        ToArrayHelper.toShortArray },\n-                { (ScopeFactory) size -> NativeScope.unboundedScope(),\n-                        MemoryLayouts.BITS_32_BE,\n-                        (AllocationFunction<int[]>) NativeScope::allocateArray,\n-                        ToArrayHelper.toIntArray },\n-                { (ScopeFactory) size -> NativeScope.unboundedScope(), MemoryLayouts.BITS_32_BE,\n-                        (AllocationFunction<float[]>) NativeScope::allocateArray,\n-                        ToArrayHelper.toFloatArray },\n-                { (ScopeFactory) size -> NativeScope.unboundedScope(), MemoryLayouts.BITS_64_BE,\n-                        (AllocationFunction<long[]>) NativeScope::allocateArray,\n-                        ToArrayHelper.toLongArray },\n-                { (ScopeFactory) size -> NativeScope.unboundedScope(), MemoryLayouts.BITS_64_BE,\n-                        (AllocationFunction<double[]>) NativeScope::allocateArray,\n-                        ToArrayHelper.toDoubleArray },\n-                { (ScopeFactory)size -> NativeScope.unboundedScope(), MemoryLayouts.ADDRESS.withOrder(ByteOrder.BIG_ENDIAN),\n-                        (AllocationFunction<MemoryAddress[]>) NativeScope::allocateArray,\n-                        ToArrayHelper.toAddressArray },\n-        };\n-    }\n-\n-    interface AllocationFunction<X> {\n-        MemorySegment allocate(NativeScope scope, ValueLayout layout, X value);\n-    }\n-\n-    interface ScopeFactory {\n-        NativeScope make(int size);\n-    }\n-\n-    interface ToArrayHelper<T> {\n-        T array();\n-        T toArray(MemorySegment segment, ValueLayout layout);\n-\n-        ToArrayHelper<byte[]> toByteArray = new ToArrayHelper<>() {\n-            @Override\n-            public byte[] array() {\n-                return new byte[] { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };\n-            }\n-\n-            @Override\n-            public byte[] toArray(MemorySegment segment, ValueLayout layout) {\n-                ByteBuffer buffer = segment.asByteBuffer().order(layout.order());\n-                byte[] found = new byte[buffer.limit()];\n-                buffer.get(found);\n-                return found;\n-            }\n-        };\n-\n-        ToArrayHelper<short[]> toShortArray = new ToArrayHelper<>() {\n-            @Override\n-            public short[] array() {\n-                return new short[] { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };\n-            }\n-\n-            @Override\n-            public short[] toArray(MemorySegment segment, ValueLayout layout) {\n-                ShortBuffer buffer = segment.asByteBuffer().order(layout.order()).asShortBuffer();\n-                short[] found = new short[buffer.limit()];\n-                buffer.get(found);\n-                return found;\n-            }\n-        };\n-\n-        ToArrayHelper<int[]> toIntArray = new ToArrayHelper<>() {\n-            @Override\n-            public int[] array() {\n-                return new int[] { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };\n-            }\n-\n-            @Override\n-            public int[] toArray(MemorySegment segment, ValueLayout layout) {\n-                IntBuffer buffer = segment.asByteBuffer().order(layout.order()).asIntBuffer();\n-                int[] found = new int[buffer.limit()];\n-                buffer.get(found);\n-                return found;\n-            }\n-        };\n-\n-        ToArrayHelper<float[]> toFloatArray = new ToArrayHelper<>() {\n-            @Override\n-            public float[] array() {\n-                return new float[] { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };\n-            }\n-\n-            @Override\n-            public float[] toArray(MemorySegment segment, ValueLayout layout) {\n-                FloatBuffer buffer = segment.asByteBuffer().order(layout.order()).asFloatBuffer();\n-                float[] found = new float[buffer.limit()];\n-                buffer.get(found);\n-                return found;\n-            }\n-        };\n-\n-        ToArrayHelper<long[]> toLongArray = new ToArrayHelper<>() {\n-            @Override\n-            public long[] array() {\n-                return new long[] { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };\n-            }\n-\n-            @Override\n-            public long[] toArray(MemorySegment segment, ValueLayout layout) {\n-                LongBuffer buffer = segment.asByteBuffer().order(layout.order()).asLongBuffer();\n-                long[] found = new long[buffer.limit()];\n-                buffer.get(found);\n-                return found;\n-            }\n-        };\n-\n-        ToArrayHelper<double[]> toDoubleArray = new ToArrayHelper<>() {\n-            @Override\n-            public double[] array() {\n-                return new double[] { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };\n-            }\n-\n-            @Override\n-            public double[] toArray(MemorySegment segment, ValueLayout layout) {\n-                DoubleBuffer buffer = segment.asByteBuffer().order(layout.order()).asDoubleBuffer();\n-                double[] found = new double[buffer.limit()];\n-                buffer.get(found);\n-                return found;\n-            }\n-        };\n-\n-        ToArrayHelper<MemoryAddress[]> toAddressArray = new ToArrayHelper<>() {\n-            @Override\n-            public MemoryAddress[] array() {\n-                return switch ((int)MemoryLayouts.ADDRESS.byteSize()) {\n-                    case 4 -> wrap(toIntArray.array());\n-                    case 8 -> wrap(toLongArray.array());\n-                    default -> throw new IllegalStateException(\"Cannot get here\");\n-                };\n-            }\n-\n-            @Override\n-            public MemoryAddress[] toArray(MemorySegment segment, ValueLayout layout) {\n-                return switch ((int)layout.byteSize()) {\n-                    case 4 -> wrap(toIntArray.toArray(segment, layout));\n-                    case 8 -> wrap(toLongArray.toArray(segment, layout));\n-                    default -> throw new IllegalStateException(\"Cannot get here\");\n-                };\n-            }\n-\n-            private MemoryAddress[] wrap(int[] ints) {\n-                return IntStream.of(ints).mapToObj(MemoryAddress::ofLong).toArray(MemoryAddress[]::new);\n-            }\n-\n-            private MemoryAddress[] wrap(long[] ints) {\n-                return LongStream.of(ints).mapToObj(MemoryAddress::ofLong).toArray(MemoryAddress[]::new);\n-            }\n-        };\n-    }\n-}\n","filename":"test\/jdk\/java\/foreign\/TestNativeScope.java","additions":0,"deletions":536,"binary":false,"changes":536,"status":"deleted"},{"patch":"@@ -24,9 +24,1 @@\n-\/*\n- * @test\n- * @run testng TestNoForeignUnsafeOverride\n- *\/\n-\n-import jdk.incubator.foreign.MemoryAddress;\n-\n-import jdk.incubator.foreign.MemorySegment;\n-import org.testng.annotations.Test;\n+package org.openjdk.foreigntest;\n@@ -34,4 +26,1 @@\n-public class TestNoForeignUnsafeOverride {\n-    static {\n-        System.setProperty(\"foreign.restricted\", \"permit\");\n-    }\n+import jdk.incubator.foreign.*;\n@@ -39,4 +28,6 @@\n-    @Test(expectedExceptions = IllegalAccessError.class)\n-    public void testUnsafeAccess() {\n-        MemorySegment.ofNativeRestricted();\n-    }\n+public class PanamaMain {\n+   public static void main(String[] args) {\n+       System.out.println(\"Trying to get CLinker\");\n+       CLinker.getInstance();\n+       System.out.println(\"Got CLinker\");\n+   }\n","filename":"test\/jdk\/java\/foreign\/TestNoForeignUnsafeOverride.java","additions":8,"deletions":17,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -29,1 +29,3 @@\n- * @run testng\/othervm -Dforeign.restricted=permit TestNulls\n+ * @run testng\/othervm\n+ *     --enable-native-access=ALL-UNNAMED\n+ *     TestNulls\n@@ -56,0 +58,1 @@\n+import java.util.function.Supplier;\n@@ -85,1 +88,0 @@\n-            MappedMemorySegments.class,\n@@ -88,1 +90,0 @@\n-            NativeScope.class,\n@@ -93,1 +94,3 @@\n-            LibraryLookup.class\n+            LibraryLookup.class,\n+            SegmentAllocator.class,\n+            ResourceScope.class\n@@ -98,2 +101,3 @@\n-            \"jdk.incubator.foreign.MemoryAddress\/asSegmentRestricted(long,java.lang.Runnable,java.lang.Object)\/1\/0\",\n-            \"jdk.incubator.foreign.MemoryAddress\/asSegmentRestricted(long,java.lang.Runnable,java.lang.Object)\/2\/0\",\n+            \"jdk.incubator.foreign.MemoryAddress\/asSegment(long,java.lang.Runnable,java.lang.Object)\/1\/0\",\n+            \"jdk.incubator.foreign.MemoryAddress\/asSegment(long,java.lang.Runnable,java.lang.Object)\/2\/0\",\n+            \"jdk.incubator.foreign.MemoryAddress\/asSegment(long,java.lang.Runnable,jdk.incubator.foreign.ResourceScope)\/1\/0\",\n@@ -125,0 +129,1 @@\n+        addDefaultMapping(boolean.class, true);\n@@ -147,2 +152,2 @@\n-        addDefaultMapping(GroupLayout.class, MemoryLayout.ofStruct(MemoryLayouts.JAVA_INT));\n-        addDefaultMapping(SequenceLayout.class, MemoryLayout.ofSequence(MemoryLayouts.JAVA_INT));\n+        addDefaultMapping(GroupLayout.class, MemoryLayout.structLayout(MemoryLayouts.JAVA_INT));\n+        addDefaultMapping(SequenceLayout.class, MemoryLayout.sequenceLayout(MemoryLayouts.JAVA_INT));\n@@ -150,1 +155,0 @@\n-        addDefaultMapping(NativeScope.class, NativeScope.boundedScope(10));\n@@ -156,0 +160,4 @@\n+        addDefaultMapping(ResourceScope.class, ResourceScope.newImplicitScope());\n+        addDefaultMapping(SegmentAllocator.class, (size, align) -> null);\n+        addDefaultMapping(Supplier.class, () -> null);\n+        addDefaultMapping(ResourceScope.Handle.class, ResourceScope.globalScope().acquire());\n@@ -167,1 +175,1 @@\n-            });\n+            }, ResourceScope.newImplicitScope());\n","filename":"test\/jdk\/java\/foreign\/TestNulls.java","additions":18,"deletions":10,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import jdk.incubator.foreign.MemoryLayouts;\n@@ -34,0 +33,1 @@\n+import jdk.incubator.foreign.ResourceScope;\n@@ -37,1 +37,0 @@\n-import java.lang.invoke.VarHandle;\n@@ -84,1 +83,1 @@\n-            NATIVE(MemorySegment::allocateNative),\n+            NATIVE(i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope())),\n","filename":"test\/jdk\/java\/foreign\/TestRebase.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-        SequenceLayout seq_flattened = MemoryLayout.ofSequence(flattenedSize, layout);\n+        SequenceLayout seq_flattened = MemoryLayout.sequenceLayout(flattenedSize, layout);\n@@ -57,1 +57,1 @@\n-        SequenceLayout seq = MemoryLayout.ofSequence(4, MemoryLayouts.JAVA_INT);\n+        SequenceLayout seq = MemoryLayout.sequenceLayout(4, MemoryLayouts.JAVA_INT);\n@@ -63,1 +63,1 @@\n-        SequenceLayout seq = MemoryLayout.ofSequence(4, MemoryLayouts.JAVA_INT);\n+        SequenceLayout seq = MemoryLayout.sequenceLayout(4, MemoryLayouts.JAVA_INT);\n@@ -69,1 +69,1 @@\n-        SequenceLayout seq = MemoryLayout.ofSequence(4, MemoryLayouts.JAVA_INT);\n+        SequenceLayout seq = MemoryLayout.sequenceLayout(4, MemoryLayouts.JAVA_INT);\n@@ -75,1 +75,1 @@\n-        SequenceLayout seq = MemoryLayout.ofSequence(4, MemoryLayouts.JAVA_INT);\n+        SequenceLayout seq = MemoryLayout.sequenceLayout(4, MemoryLayouts.JAVA_INT);\n@@ -81,1 +81,1 @@\n-        SequenceLayout seq = MemoryLayout.ofSequence(MemoryLayouts.JAVA_INT);\n+        SequenceLayout seq = MemoryLayout.sequenceLayout(MemoryLayouts.JAVA_INT);\n@@ -87,1 +87,1 @@\n-        SequenceLayout seq = MemoryLayout.ofSequence(MemoryLayouts.JAVA_INT);\n+        SequenceLayout seq = MemoryLayout.sequenceLayout(MemoryLayouts.JAVA_INT);\n@@ -93,1 +93,1 @@\n-        SequenceLayout seq = MemoryLayout.ofSequence(4, MemoryLayout.ofSequence(MemoryLayouts.JAVA_INT));\n+        SequenceLayout seq = MemoryLayout.sequenceLayout(4, MemoryLayout.sequenceLayout(MemoryLayouts.JAVA_INT));\n@@ -127,1 +127,1 @@\n-    static MemoryLayout POINT = MemoryLayout.ofStruct(\n+    static MemoryLayout POINT = MemoryLayout.structLayout(\n","filename":"test\/jdk\/java\/foreign\/TestReshape.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -0,0 +1,306 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @modules java.base\/jdk.internal.ref\n+ *          jdk.incubator.foreign\/jdk.incubator.foreign\n+ * @run testng\/othervm TestResourceScope\n+ *\/\n+\n+import java.lang.ref.Cleaner;\n+\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.internal.ref.CleanerFactory;\n+\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.*;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Supplier;\n+import java.util.stream.IntStream;\n+\n+public class TestResourceScope {\n+\n+    final static int N_THREADS = 10000;\n+\n+    @Test(dataProvider = \"cleaners\")\n+    public void testConfined(Supplier<Cleaner> cleanerSupplier) {\n+        AtomicInteger acc = new AtomicInteger();\n+        Cleaner cleaner = cleanerSupplier.get();\n+        ResourceScope scope = cleaner != null ?\n+                ResourceScope.newConfinedScope(cleaner) :\n+                ResourceScope.newConfinedScope();\n+        for (int i = 0 ; i < N_THREADS ; i++) {\n+            int delta = i;\n+            scope.addCloseAction(() -> acc.addAndGet(delta));\n+        }\n+        assertEquals(acc.get(), 0);\n+\n+        if (cleaner == null) {\n+            scope.close();\n+            assertEquals(acc.get(), IntStream.range(0, N_THREADS).sum());\n+        } else {\n+            scope = null;\n+            int expected = IntStream.range(0, N_THREADS).sum();\n+            while (acc.get() != expected) {\n+                kickGC();\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"cleaners\")\n+    public void testSharedSingleThread(Supplier<Cleaner> cleanerSupplier) {\n+        AtomicInteger acc = new AtomicInteger();\n+        Cleaner cleaner = cleanerSupplier.get();\n+        ResourceScope scope = cleaner != null ?\n+                ResourceScope.newSharedScope(cleaner) :\n+                ResourceScope.newSharedScope();\n+        for (int i = 0 ; i < N_THREADS ; i++) {\n+            int delta = i;\n+            scope.addCloseAction(() -> acc.addAndGet(delta));\n+        }\n+        assertEquals(acc.get(), 0);\n+\n+        if (cleaner == null) {\n+            scope.close();\n+            assertEquals(acc.get(), IntStream.range(0, N_THREADS).sum());\n+        } else {\n+            scope = null;\n+            int expected = IntStream.range(0, N_THREADS).sum();\n+            while (acc.get() != expected) {\n+                kickGC();\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"cleaners\")\n+    public void testSharedMultiThread(Supplier<Cleaner> cleanerSupplier) {\n+        AtomicInteger acc = new AtomicInteger();\n+        Cleaner cleaner = cleanerSupplier.get();\n+        List<Thread> threads = new ArrayList<>();\n+        ResourceScope scope = cleaner != null ?\n+                ResourceScope.newSharedScope(cleaner) :\n+                ResourceScope.newSharedScope();\n+        AtomicReference<ResourceScope> scopeRef = new AtomicReference<>(scope);\n+        for (int i = 0 ; i < N_THREADS ; i++) {\n+            int delta = i;\n+            Thread thread = new Thread(() -> {\n+                try {\n+                    scopeRef.get().addCloseAction(() -> {\n+                        acc.addAndGet(delta);\n+                    });\n+                } catch (IllegalStateException ex) {\n+                    \/\/ already closed - we need to call cleanup manually\n+                    acc.addAndGet(delta);\n+                }\n+            });\n+            threads.add(thread);\n+        }\n+        assertEquals(acc.get(), 0);\n+        threads.forEach(Thread::start);\n+\n+        \/\/ if no cleaner, close - not all segments might have been added to the scope!\n+        \/\/ if cleaner, don't unset the scope - after all, the scope is kept alive by threads\n+        if (cleaner == null) {\n+            scope.close();\n+        }\n+\n+        threads.forEach(t -> {\n+            try {\n+                t.join();\n+            } catch (InterruptedException ex) {\n+                fail();\n+            }\n+        });\n+\n+        if (cleaner == null) {\n+            assertEquals(acc.get(), IntStream.range(0, N_THREADS).sum());\n+        } else {\n+            scope = null;\n+            scopeRef.set(null);\n+            int expected = IntStream.range(0, N_THREADS).sum();\n+            while (acc.get() != expected) {\n+                kickGC();\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"cleaners\")\n+    public void testLockSingleThread(Supplier<Cleaner> cleanerSupplier) {\n+        Cleaner cleaner = cleanerSupplier.get();\n+        ResourceScope scope = cleaner != null ?\n+                ResourceScope.newConfinedScope(cleaner) :\n+                ResourceScope.newConfinedScope();\n+        List<ResourceScope.Handle> handles = new ArrayList<>();\n+        for (int i = 0 ; i < N_THREADS ; i++) {\n+            handles.add(scope.acquire());\n+        }\n+\n+        while (true) {\n+            try {\n+                scope.close();\n+                assertEquals(handles.size(), 0);\n+                break;\n+            } catch (IllegalStateException ex) {\n+                assertTrue(handles.size() > 0);\n+                ResourceScope.Handle handle = handles.remove(0);\n+                scope.release(handle);\n+                scope.release(handle); \/\/ make sure it's idempotent\n+                scope.release(handle); \/\/ make sure it's idempotent\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"cleaners\")\n+    public void testLockSharedMultiThread(Supplier<Cleaner> cleanerSupplier) {\n+        Cleaner cleaner = cleanerSupplier.get();\n+        ResourceScope scope = cleaner != null ?\n+                ResourceScope.newSharedScope(cleaner) :\n+                ResourceScope.newSharedScope();\n+        AtomicInteger lockCount = new AtomicInteger();\n+        for (int i = 0 ; i < N_THREADS ; i++) {\n+            new Thread(() -> {\n+                lockCount.incrementAndGet();\n+                try {\n+                    ResourceScope.Handle handle = scope.acquire();\n+                    waitSomeTime();\n+                    scope.release(handle);\n+                    scope.release(handle); \/\/ make sure it's idempotent\n+                    scope.release(handle); \/\/ make sure it's idempotent\n+                } catch (IllegalStateException ex) {\n+                    \/\/ might be already closed - do nothing\n+                } finally {\n+                    lockCount.decrementAndGet();\n+                }\n+            }).start();\n+        }\n+\n+        while (lockCount.get() > 0) {\n+            try {\n+                scope.close();\n+                assertEquals(lockCount.get(), 0);\n+                break;\n+            } catch (IllegalStateException ex) {\n+                waitSomeTime();\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testCloseEmptyConfinedScope() {\n+        ResourceScope.newConfinedScope().close();\n+    }\n+\n+    @Test\n+    public void testCloseEmptySharedScope() {\n+        ResourceScope.newSharedScope().close();\n+    }\n+\n+    @Test\n+    public void testCloseConfinedLock() {\n+        ResourceScope scope = ResourceScope.newConfinedScope();\n+        ResourceScope.Handle handle = scope.acquire();\n+        AtomicReference<Throwable> failure = new AtomicReference<>();\n+        Thread t = new Thread(() -> {\n+            try {\n+                scope.release(handle);\n+                scope.release(handle); \/\/ make sure it's idempotent\n+                scope.release(handle); \/\/ make sure it's idempotent\n+            } catch (Throwable ex) {\n+                failure.set(ex);\n+            }\n+        });\n+        t.start();\n+        try {\n+            t.join();\n+            assertNotNull(failure.get());\n+            assertEquals(failure.get().getClass(), IllegalStateException.class);\n+        } catch (Throwable ex) {\n+            throw new AssertionError(ex);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"scopes\")\n+    public void testScopeHandles(Supplier<ResourceScope> scopeFactory) {\n+        ResourceScope scope = scopeFactory.get();\n+        acquireRecursive(scope, 5);\n+        if (!scope.isImplicit()) {\n+            scope.close();\n+        }\n+    }\n+\n+    private void acquireRecursive(ResourceScope scope, int acquireCount) {\n+        ResourceScope.Handle handle = scope.acquire();\n+        assertEquals(handle.scope(), scope);\n+        if (acquireCount > 0) {\n+            \/\/ recursive acquire\n+            acquireRecursive(scope, acquireCount - 1);\n+        }\n+        if (!scope.isImplicit()) {\n+            assertThrows(IllegalStateException.class, scope::close);\n+        }\n+        scope.release(handle);\n+        scope.release(handle); \/\/ make sure it's idempotent\n+        scope.release(handle); \/\/ make sure it's idempotent\n+    }\n+\n+    private void waitSomeTime() {\n+        try {\n+            Thread.sleep(10);\n+        } catch (InterruptedException ex) {\n+            \/\/ ignore\n+        }\n+    }\n+\n+    private void kickGC() {\n+        for (int i = 0 ; i < 100 ; i++) {\n+            byte[] b = new byte[100];\n+            System.gc();\n+            Thread.onSpinWait();\n+        }\n+    }\n+\n+    @DataProvider\n+    static Object[][] cleaners() {\n+        return new Object[][] {\n+                { (Supplier<Cleaner>)() -> null },\n+                { (Supplier<Cleaner>)Cleaner::create },\n+                { (Supplier<Cleaner>)CleanerFactory::cleaner }\n+        };\n+    }\n+\n+    @DataProvider\n+    static Object[][] scopes() {\n+        return new Object[][] {\n+                { (Supplier<ResourceScope>)ResourceScope::newConfinedScope },\n+                { (Supplier<ResourceScope>)ResourceScope::newSharedScope },\n+                { (Supplier<ResourceScope>)ResourceScope::newImplicitScope },\n+                { (Supplier<ResourceScope>)ResourceScope::globalScope }\n+        };\n+    }\n+}\n","filename":"test\/jdk\/java\/foreign\/TestResourceScope.java","additions":306,"deletions":0,"binary":false,"changes":306,"status":"added"},{"patch":"@@ -0,0 +1,74 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ResourceScope;\n+import org.testng.annotations.Test;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.InvocationTargetException;\n+\n+\/*\n+ * @test\n+ * @run testng TestRestricted\n+ *\/\n+public class TestRestricted {\n+    @Test(expectedExceptions = InvocationTargetException.class)\n+    public void testReflection() throws Throwable {\n+        Method method = MemorySegment.class.getDeclaredMethod(\"globalNativeSegment\");\n+        method.invoke(null);\n+    }\n+\n+    @Test(expectedExceptions = IllegalCallerException.class)\n+    public void testInvoke() throws Throwable {\n+        var mh = MethodHandles.lookup().findStatic(MemorySegment.class,\n+                \"globalNativeSegment\", MethodType.methodType(MemorySegment.class));\n+        var seg = (MemorySegment)mh.invokeExact();\n+    }\n+\n+    @Test(expectedExceptions = IllegalCallerException.class)\n+    public void testDirectAccess() throws Throwable {\n+        MemorySegment.globalNativeSegment();\n+    }\n+\n+    @Test(expectedExceptions = InvocationTargetException.class)\n+    public void testReflection2() throws Throwable {\n+        Method method = MemoryAddress.class.getDeclaredMethod(\"asSegment\", long.class, ResourceScope.class);\n+        method.invoke(MemoryAddress.NULL, 4000L, ResourceScope.globalScope());\n+    }\n+\n+    @Test(expectedExceptions = IllegalCallerException.class)\n+    public void testInvoke2() throws Throwable {\n+        var mh = MethodHandles.lookup().findVirtual(MemoryAddress.class, \"asSegment\",\n+            MethodType.methodType(MemorySegment.class, long.class, ResourceScope.class));\n+        var seg = (MemorySegment)mh.invokeExact(MemoryAddress.NULL, 4000L, ResourceScope.globalScope());\n+    }\n+\n+    @Test(expectedExceptions = IllegalCallerException.class)\n+    public void testDirectAccess2() throws Throwable {\n+        MemoryAddress.NULL.asSegment(4000L, ResourceScope.globalScope());\n+    }\n+}\n","filename":"test\/jdk\/java\/foreign\/TestRestricted.java","additions":74,"deletions":0,"binary":false,"changes":74,"status":"added"},{"patch":"@@ -0,0 +1,273 @@\n+\/*\n+ *  Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED TestScopedOperations\n+ *\/\n+\n+import jdk.incubator.foreign.CLinker;\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.MemoryLayout;\n+import jdk.incubator.foreign.MemoryLayouts;\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.SegmentAllocator;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.channels.FileChannel;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertNotNull;\n+import static org.testng.Assert.assertTrue;\n+import static org.testng.Assert.fail;\n+\n+public class TestScopedOperations {\n+\n+    static Path tempPath;\n+\n+    static {\n+        try {\n+            File file = File.createTempFile(\"scopedBuffer\", \"txt\");\n+            file.deleteOnExit();\n+            tempPath = file.toPath();\n+        } catch (IOException ex) {\n+            throw new ExceptionInInitializerError(ex);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"scopedOperations\")\n+    public void testOpAfterClose(String name, ScopedOperation scopedOperation) {\n+        ResourceScope scope = ResourceScope.newConfinedScope();\n+        scope.close();\n+        try {\n+            scopedOperation.accept(scope);\n+            fail();\n+        } catch (IllegalStateException ex) {\n+            assertTrue(ex.getMessage().contains(\"closed\"));\n+        }\n+    }\n+\n+    @Test(dataProvider = \"scopedOperations\")\n+    public void testOpOutsideConfinement(String name, ScopedOperation scopedOperation) {\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            AtomicReference<Throwable> failed = new AtomicReference<>();\n+            Thread t = new Thread(() -> {\n+                try {\n+                    scopedOperation.accept(scope);\n+                } catch (Throwable ex) {\n+                    failed.set(ex);\n+                }\n+            });\n+            t.start();\n+            t.join();\n+            assertNotNull(failed.get());\n+            assertEquals(failed.get().getClass(), IllegalStateException.class);\n+            assertTrue(failed.get().getMessage().contains(\"outside\"));\n+        } catch (InterruptedException ex) {\n+            throw new AssertionError(ex);\n+        }\n+    }\n+\n+    static List<ScopedOperation> scopedOperations = new ArrayList<>();\n+\n+    static {\n+        \/\/ scope operations\n+        ScopedOperation.ofScope(scope -> scope.addCloseAction(() -> {\n+        }), \"ResourceScope::addOnClose\");\n+        ScopedOperation.ofScope(scope -> {\n+            ResourceScope.Handle handle = scope.acquire();\n+            scope.release(handle);\n+        }, \"ResourceScope::lock\");\n+        ScopedOperation.ofScope(scope -> MemorySegment.allocateNative(100, scope), \"MemorySegment::allocateNative\");\n+        ScopedOperation.ofScope(scope -> {\n+            try {\n+                MemorySegment.mapFile(tempPath, 0, 10, FileChannel.MapMode.READ_WRITE, scope);\n+            } catch (IOException ex) {\n+                fail();\n+            }\n+        }, \"MemorySegment::mapFromFile\");\n+        ScopedOperation.ofScope(scope -> CLinker.VaList.make(b -> {}, scope), \"VaList::make\");\n+        ScopedOperation.ofScope(scope -> CLinker.VaList.ofAddress(MemoryAddress.ofLong(42), scope), \"VaList::make\");\n+        ScopedOperation.ofScope(scope -> CLinker.toCString(\"Hello\", scope), \"CLinker::toCString\");\n+        ScopedOperation.ofScope(SegmentAllocator::arenaAllocator, \"SegmentAllocator::arenaAllocator\");\n+        \/\/ segment operations\n+        ScopedOperation.ofSegment(MemorySegment::toByteArray, \"MemorySegment::toByteArray\");\n+        ScopedOperation.ofSegment(MemorySegment::toCharArray, \"MemorySegment::toCharArray\");\n+        ScopedOperation.ofSegment(MemorySegment::toShortArray, \"MemorySegment::toShortArray\");\n+        ScopedOperation.ofSegment(MemorySegment::toIntArray, \"MemorySegment::toIntArray\");\n+        ScopedOperation.ofSegment(MemorySegment::toFloatArray, \"MemorySegment::toFloatArray\");\n+        ScopedOperation.ofSegment(MemorySegment::toLongArray, \"MemorySegment::toLongArray\");\n+        ScopedOperation.ofSegment(MemorySegment::toDoubleArray, \"MemorySegment::toDoubleArray\");\n+        ScopedOperation.ofSegment(MemorySegment::address, \"MemorySegment::address\");\n+        ScopedOperation.ofSegment(s -> MemoryLayout.sequenceLayout(s.byteSize(), MemoryLayouts.JAVA_BYTE), \"MemorySegment::spliterator\");\n+        ScopedOperation.ofSegment(s -> s.copyFrom(s), \"MemorySegment::copyFrom\");\n+        ScopedOperation.ofSegment(s -> s.mismatch(s), \"MemorySegment::mismatch\");\n+        ScopedOperation.ofSegment(s -> s.fill((byte) 0), \"MemorySegment::fill\");\n+        \/\/ address operations\n+        ScopedOperation.ofAddress(a -> a.toRawLongValue(), \"MemoryAddress::toRawLongValue\");\n+        ScopedOperation.ofAddress(a -> a.asSegment(100, ResourceScope.globalScope()), \"MemoryAddress::asSegment\");\n+        \/\/ valist operations\n+        ScopedOperation.ofVaList(CLinker.VaList::address, \"VaList::address\");\n+        ScopedOperation.ofVaList(CLinker.VaList::copy, \"VaList::copy\");\n+        ScopedOperation.ofVaList(list -> list.vargAsAddress(MemoryLayouts.ADDRESS), \"VaList::vargAsAddress\");\n+        ScopedOperation.ofVaList(list -> list.vargAsInt(MemoryLayouts.JAVA_INT), \"VaList::vargAsInt\");\n+        ScopedOperation.ofVaList(list -> list.vargAsLong(MemoryLayouts.JAVA_LONG), \"VaList::vargAsLong\");\n+        ScopedOperation.ofVaList(list -> list.vargAsDouble(MemoryLayouts.JAVA_DOUBLE), \"VaList::vargAsDouble\");\n+        ScopedOperation.ofVaList(CLinker.VaList::skip, \"VaList::skip\");\n+        ScopedOperation.ofVaList(list -> list.vargAsSegment(MemoryLayout.structLayout(MemoryLayouts.JAVA_INT), ResourceScope.newImplicitScope()), \"VaList::vargAsSegment\/1\");\n+        \/\/ allocator operations\n+        ScopedOperation.ofAllocator(a -> a.allocate(1), \"NativeAllocator::allocate\/size\");\n+        ScopedOperation.ofAllocator(a -> a.allocate(1, 1), \"NativeAllocator::allocate\/size\/align\");\n+        ScopedOperation.ofAllocator(a -> a.allocate(MemoryLayouts.JAVA_BYTE), \"NativeAllocator::allocate\/layout\");\n+        ScopedOperation.ofAllocator(a -> a.allocate(MemoryLayouts.JAVA_BYTE, (byte) 0), \"NativeAllocator::allocate\/byte\");\n+        ScopedOperation.ofAllocator(a -> a.allocate(MemoryLayouts.JAVA_CHAR, (char) 0), \"NativeAllocator::allocate\/char\");\n+        ScopedOperation.ofAllocator(a -> a.allocate(MemoryLayouts.JAVA_SHORT, (short) 0), \"NativeAllocator::allocate\/short\");\n+        ScopedOperation.ofAllocator(a -> a.allocate(MemoryLayouts.JAVA_INT, 0), \"NativeAllocator::allocate\/int\");\n+        ScopedOperation.ofAllocator(a -> a.allocate(MemoryLayouts.JAVA_FLOAT, 0f), \"NativeAllocator::allocate\/float\");\n+        ScopedOperation.ofAllocator(a -> a.allocate(MemoryLayouts.JAVA_LONG, 0L), \"NativeAllocator::allocate\/long\");\n+        ScopedOperation.ofAllocator(a -> a.allocate(MemoryLayouts.JAVA_DOUBLE, 0d), \"NativeAllocator::allocate\/double\");\n+        ScopedOperation.ofAllocator(a -> a.allocateArray(MemoryLayouts.JAVA_BYTE, 1L), \"NativeAllocator::allocateArray\/size\");\n+        ScopedOperation.ofAllocator(a -> a.allocateArray(MemoryLayouts.JAVA_BYTE, new byte[]{0}), \"NativeAllocator::allocateArray\/byte\");\n+        ScopedOperation.ofAllocator(a -> a.allocateArray(MemoryLayouts.JAVA_CHAR, new char[]{0}), \"NativeAllocator::allocateArray\/char\");\n+        ScopedOperation.ofAllocator(a -> a.allocateArray(MemoryLayouts.JAVA_SHORT, new short[]{0}), \"NativeAllocator::allocateArray\/short\");\n+        ScopedOperation.ofAllocator(a -> a.allocateArray(MemoryLayouts.JAVA_INT, new int[]{0}), \"NativeAllocator::allocateArray\/int\");\n+        ScopedOperation.ofAllocator(a -> a.allocateArray(MemoryLayouts.JAVA_FLOAT, new float[]{0}), \"NativeAllocator::allocateArray\/float\");\n+        ScopedOperation.ofAllocator(a -> a.allocateArray(MemoryLayouts.JAVA_LONG, new long[]{0}), \"NativeAllocator::allocateArray\/long\");\n+        ScopedOperation.ofAllocator(a -> a.allocateArray(MemoryLayouts.JAVA_DOUBLE, new double[]{0}), \"NativeAllocator::allocateArray\/double\");\n+    };\n+\n+    @DataProvider(name = \"scopedOperations\")\n+    static Object[][] scopedOperations() {\n+        return scopedOperations.stream().map(op -> new Object[] { op.name, op }).toArray(Object[][]::new);\n+    }\n+\n+    static class ScopedOperation implements Consumer<ResourceScope> {\n+\n+        final Consumer<ResourceScope> scopeConsumer;\n+        final String name;\n+\n+        private ScopedOperation(Consumer<ResourceScope> scopeConsumer, String name) {\n+            this.scopeConsumer = scopeConsumer;\n+            this.name = name;\n+        }\n+\n+        @Override\n+        public void accept(ResourceScope scope) {\n+            scopeConsumer.accept(scope);\n+        }\n+\n+        static void ofScope(Consumer<ResourceScope> scopeConsumer, String name) {\n+            scopedOperations.add(new ScopedOperation(scopeConsumer::accept, name));\n+        }\n+\n+        static void ofVaList(Consumer<CLinker.VaList> vaListConsumer, String name) {\n+            scopedOperations.add(new ScopedOperation(scope -> {\n+                CLinker.VaList vaList = CLinker.VaList.make((builder) -> {}, scope);\n+                vaListConsumer.accept(vaList);\n+            }, name));\n+        }\n+\n+        static void ofSegment(Consumer<MemorySegment> segmentConsumer, String name) {\n+            for (SegmentFactory segmentFactory : SegmentFactory.values()) {\n+                scopedOperations.add(new ScopedOperation(scope -> {\n+                    MemorySegment segment = segmentFactory.segmentFactory.apply(scope);\n+                    segmentConsumer.accept(segment);\n+                }, segmentFactory.name() + \"\/\" + name));\n+            }\n+        }\n+\n+        static void ofAddress(Consumer<MemoryAddress> addressConsumer, String name) {\n+            for (SegmentFactory segmentFactory : SegmentFactory.values()) {\n+                scopedOperations.add(new ScopedOperation(scope -> {\n+                    MemoryAddress segment = segmentFactory.segmentFactory.apply(scope).address();\n+                    addressConsumer.accept(segment);\n+                }, segmentFactory.name() + \"\/\" + name));\n+            }\n+        }\n+\n+        static void ofAllocator(Consumer<SegmentAllocator> allocatorConsumer, String name) {\n+            for (AllocatorFactory allocatorFactory : AllocatorFactory.values()) {\n+                scopedOperations.add(new ScopedOperation(scope -> {\n+                    SegmentAllocator allocator = allocatorFactory.allocatorFactory.apply(scope);\n+                    allocatorConsumer.accept(allocator);\n+                }, allocatorFactory.name() + \"\/\" + name));\n+            }\n+        }\n+\n+        enum SegmentFactory {\n+\n+            NATIVE(scope -> MemorySegment.allocateNative(10, scope)),\n+            MAPPED(scope -> {\n+                try {\n+                    return MemorySegment.mapFile(Path.of(\"foo.txt\"), 0, 10, FileChannel.MapMode.READ_WRITE, scope);\n+                } catch (IOException ex) {\n+                    throw new AssertionError(ex);\n+                }\n+            }),\n+            UNSAFE(scope -> MemoryAddress.NULL.asSegment(10, scope));\n+\n+            static {\n+                try {\n+                    File f = new File(\"foo.txt\");\n+                    f.createNewFile();\n+                    f.deleteOnExit();\n+                } catch (IOException ex) {\n+                    throw new ExceptionInInitializerError(ex);\n+                }\n+            }\n+\n+            final Function<ResourceScope, MemorySegment> segmentFactory;\n+\n+            SegmentFactory(Function<ResourceScope, MemorySegment> segmentFactory) {\n+                this.segmentFactory = segmentFactory;\n+            }\n+        }\n+\n+        enum AllocatorFactory {\n+            ARENA_BOUNDED(scope -> SegmentAllocator.arenaAllocator(1000, scope)),\n+            ARENA_UNBOUNDED(SegmentAllocator::arenaAllocator),\n+            FROM_SEGMENT(scope -> {\n+                MemorySegment segment = MemorySegment.allocateNative(10, scope);\n+                return SegmentAllocator.ofSegment(segment);\n+            }),\n+            FROM_SCOPE(SegmentAllocator::ofScope);\n+\n+            final Function<ResourceScope, SegmentAllocator> allocatorFactory;\n+\n+            AllocatorFactory(Function<ResourceScope, SegmentAllocator> allocatorFactory) {\n+                this.allocatorFactory = allocatorFactory;\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/foreign\/TestScopedOperations.java","additions":273,"deletions":0,"binary":false,"changes":273,"status":"added"},{"patch":"@@ -0,0 +1,502 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @run testng\/othervm TestSegmentAllocators\n+ *\/\n+\n+import jdk.incubator.foreign.*;\n+\n+import org.testng.annotations.*;\n+\n+import java.lang.invoke.VarHandle;\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import java.nio.DoubleBuffer;\n+import java.nio.FloatBuffer;\n+import java.nio.IntBuffer;\n+import java.nio.LongBuffer;\n+import java.nio.ShortBuffer;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+import java.util.stream.IntStream;\n+import java.util.stream.LongStream;\n+\n+import static org.testng.Assert.*;\n+\n+public class TestSegmentAllocators {\n+\n+    final static int ELEMS = 128;\n+    final static Class<?> ADDRESS_CARRIER = MemoryLayouts.ADDRESS.bitSize() == 64 ? long.class : int.class;\n+\n+    @Test(dataProvider = \"nativeScopes\")\n+    public <Z> void testAllocation(Z value, AllocationFactory allocationFactory, ValueLayout layout, AllocationFunction<Z> allocationFunction, Function<MemoryLayout, VarHandle> handleFactory) {\n+        ValueLayout[] layouts = {\n+                layout,\n+                layout.withBitAlignment(layout.bitAlignment() * 2),\n+                layout.withBitAlignment(layout.bitAlignment() * 4),\n+                layout.withBitAlignment(layout.bitAlignment() * 8)\n+        };\n+        for (ValueLayout alignedLayout : layouts) {\n+            List<MemorySegment> addressList = new ArrayList<>();\n+            int elems = ELEMS \/ ((int)alignedLayout.byteAlignment() \/ (int)layout.byteAlignment());\n+            ResourceScope[] scopes = {\n+                    ResourceScope.newConfinedScope(),\n+                    ResourceScope.newSharedScope()\n+            };\n+            for (ResourceScope scope : scopes) {\n+                try (scope) {\n+                    SegmentAllocator allocator = allocationFactory.allocator(alignedLayout.byteSize() * ELEMS, scope);\n+                    for (int i = 0; i < elems; i++) {\n+                        MemorySegment address = allocationFunction.allocate(allocator, alignedLayout, value);\n+                        assertEquals(address.byteSize(), alignedLayout.byteSize());\n+                        addressList.add(address);\n+                        VarHandle handle = handleFactory.apply(alignedLayout);\n+                        assertEquals(value, handle.get(address));\n+                    }\n+                    boolean isBound = allocationFactory.isBound();\n+                    try {\n+                        allocationFunction.allocate(allocator, alignedLayout, value); \/\/too much, should fail if bound\n+                        assertFalse(isBound);\n+                    } catch (OutOfMemoryError ex) {\n+                        \/\/failure is expected if bound\n+                        assertTrue(isBound);\n+                    }\n+                }\n+                \/\/ addresses should be invalid now\n+                for (MemorySegment address : addressList) {\n+                    assertFalse(address.scope().isAlive());\n+                }\n+            }\n+        }\n+    }\n+\n+    static final int SIZE_256M = 1024 * 1024 * 256;\n+\n+    @Test\n+    public void testBigAllocationInUnboundedScope() {\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            SegmentAllocator allocator = SegmentAllocator.arenaAllocator(scope);\n+            for (int i = 8 ; i < SIZE_256M ; i *= 8) {\n+                MemorySegment address = allocator.allocate(i, i);\n+                \/\/check size\n+                assertEquals(address.byteSize(), i);\n+                \/\/check alignment\n+                assertEquals(address.address().toRawLongValue() % i, 0);\n+            }\n+        }\n+    }\n+\n+    @Test(expectedExceptions = OutOfMemoryError.class)\n+    public void testTooBigForBoundedArena() {\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            SegmentAllocator allocator = SegmentAllocator.arenaAllocator(10, scope);\n+            allocator.allocate(12);\n+        }\n+    }\n+\n+    @Test\n+    public void testBiggerThanBlockForBoundedArena() {\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            SegmentAllocator allocator = SegmentAllocator.arenaAllocator(4 * 1024 * 2, scope);\n+            allocator.allocate(4 * 1024 + 1); \/\/ should be ok\n+        }\n+    }\n+\n+    @Test(dataProvider = \"arrayScopes\")\n+    public <Z> void testArray(AllocationFactory allocationFactory, ValueLayout layout, AllocationFunction<Object> allocationFunction, ToArrayHelper<Z> arrayHelper) {\n+        Z arr = arrayHelper.array();\n+        ResourceScope[] scopes = {\n+                ResourceScope.newConfinedScope(),\n+                ResourceScope.newSharedScope()\n+        };\n+        for (ResourceScope scope : scopes) {\n+            try (scope) {\n+                SegmentAllocator allocator = allocationFactory.allocator(100, scope);\n+                MemorySegment address = allocationFunction.allocate(allocator, layout, arr);\n+                Z found = arrayHelper.toArray(address, layout);\n+                assertEquals(found, arr);\n+            }\n+        }\n+    }\n+\n+    @DataProvider(name = \"nativeScopes\")\n+    static Object[][] nativeScopes() {\n+        return new Object[][] {\n+                { (byte)42, AllocationFactory.BOUNDED, MemoryLayouts.BITS_8_BE,\n+                        (AllocationFunction<Byte>) SegmentAllocator::allocate,\n+                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(byte.class) },\n+                { (short)42, AllocationFactory.BOUNDED, MemoryLayouts.BITS_16_BE,\n+                        (AllocationFunction<Short>) SegmentAllocator::allocate,\n+                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(short.class) },\n+                { (char)42, AllocationFactory.BOUNDED, MemoryLayouts.BITS_16_BE,\n+                        (AllocationFunction<Character>) SegmentAllocator::allocate,\n+                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(char.class) },\n+                { 42, AllocationFactory.BOUNDED,\n+                        MemoryLayouts.BITS_32_BE,\n+                        (AllocationFunction<Integer>) SegmentAllocator::allocate,\n+                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(int.class) },\n+                { 42f, AllocationFactory.BOUNDED, MemoryLayouts.BITS_32_BE,\n+                        (AllocationFunction<Float>) SegmentAllocator::allocate,\n+                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(float.class) },\n+                { 42L, AllocationFactory.BOUNDED, MemoryLayouts.BITS_64_BE,\n+                        (AllocationFunction<Long>) SegmentAllocator::allocate,\n+                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(long.class) },\n+                { 42d, AllocationFactory.BOUNDED, MemoryLayouts.BITS_64_BE,\n+                        (AllocationFunction<Double>) SegmentAllocator::allocate,\n+                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(double.class) },\n+                { MemoryAddress.ofLong(42), AllocationFactory.BOUNDED, MemoryLayouts.ADDRESS.withOrder(ByteOrder.BIG_ENDIAN),\n+                        (AllocationFunction<MemoryAddress>) SegmentAllocator::allocate,\n+                        (Function<MemoryLayout, VarHandle>)l -> MemoryHandles.asAddressVarHandle(l.varHandle(ADDRESS_CARRIER)) },\n+\n+                { (byte)42, AllocationFactory.BOUNDED, MemoryLayouts.BITS_8_LE,\n+                        (AllocationFunction<Byte>) SegmentAllocator::allocate,\n+                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(byte.class) },\n+                { (short)42, AllocationFactory.BOUNDED, MemoryLayouts.BITS_16_LE,\n+                        (AllocationFunction<Short>) SegmentAllocator::allocate,\n+                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(short.class) },\n+                { (char)42, AllocationFactory.BOUNDED, MemoryLayouts.BITS_16_LE,\n+                        (AllocationFunction<Character>) SegmentAllocator::allocate,\n+                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(char.class) },\n+                { 42, AllocationFactory.BOUNDED,\n+                        MemoryLayouts.BITS_32_LE,\n+                        (AllocationFunction<Integer>) SegmentAllocator::allocate,\n+                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(int.class) },\n+                { 42f, AllocationFactory.BOUNDED, MemoryLayouts.BITS_32_LE,\n+                        (AllocationFunction<Float>) SegmentAllocator::allocate,\n+                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(float.class) },\n+                { 42L, AllocationFactory.BOUNDED, MemoryLayouts.BITS_64_LE,\n+                        (AllocationFunction<Long>) SegmentAllocator::allocate,\n+                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(long.class) },\n+                { 42d, AllocationFactory.BOUNDED, MemoryLayouts.BITS_64_LE,\n+                        (AllocationFunction<Double>) SegmentAllocator::allocate,\n+                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(double.class) },\n+                { MemoryAddress.ofLong(42), AllocationFactory.BOUNDED, MemoryLayouts.ADDRESS.withOrder(ByteOrder.LITTLE_ENDIAN),\n+                        (AllocationFunction<MemoryAddress>) SegmentAllocator::allocate,\n+                        (Function<MemoryLayout, VarHandle>)l -> MemoryHandles.asAddressVarHandle(l.varHandle(ADDRESS_CARRIER)) },\n+\n+                { (byte)42, AllocationFactory.UNBOUNDED, MemoryLayouts.BITS_8_BE,\n+                        (AllocationFunction<Byte>) SegmentAllocator::allocate,\n+                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(byte.class) },\n+                { (short)42, AllocationFactory.UNBOUNDED, MemoryLayouts.BITS_16_BE,\n+                        (AllocationFunction<Short>) SegmentAllocator::allocate,\n+                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(short.class) },\n+                { (char)42, AllocationFactory.UNBOUNDED, MemoryLayouts.BITS_16_BE,\n+                        (AllocationFunction<Character>) SegmentAllocator::allocate,\n+                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(char.class) },\n+                { 42, AllocationFactory.UNBOUNDED,\n+                        MemoryLayouts.BITS_32_BE,\n+                        (AllocationFunction<Integer>) SegmentAllocator::allocate,\n+                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(int.class) },\n+                { 42f, AllocationFactory.UNBOUNDED, MemoryLayouts.BITS_32_BE,\n+                        (AllocationFunction<Float>) SegmentAllocator::allocate,\n+                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(float.class) },\n+                { 42L, AllocationFactory.UNBOUNDED, MemoryLayouts.BITS_64_BE,\n+                        (AllocationFunction<Long>) SegmentAllocator::allocate,\n+                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(long.class) },\n+                { 42d, AllocationFactory.UNBOUNDED, MemoryLayouts.BITS_64_BE,\n+                        (AllocationFunction<Double>) SegmentAllocator::allocate,\n+                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(double.class) },\n+                { MemoryAddress.ofLong(42), AllocationFactory.UNBOUNDED, MemoryLayouts.ADDRESS.withOrder(ByteOrder.BIG_ENDIAN),\n+                        (AllocationFunction<MemoryAddress>) SegmentAllocator::allocate,\n+                        (Function<MemoryLayout, VarHandle>)l -> MemoryHandles.asAddressVarHandle(l.varHandle(ADDRESS_CARRIER)) },\n+\n+                { (byte)42, AllocationFactory.UNBOUNDED, MemoryLayouts.BITS_8_LE,\n+                        (AllocationFunction<Byte>) SegmentAllocator::allocate,\n+                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(byte.class) },\n+                { (short)42, AllocationFactory.UNBOUNDED, MemoryLayouts.BITS_16_LE,\n+                        (AllocationFunction<Short>) SegmentAllocator::allocate,\n+                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(short.class) },\n+                { (char)42, AllocationFactory.UNBOUNDED, MemoryLayouts.BITS_16_LE,\n+                        (AllocationFunction<Character>) SegmentAllocator::allocate,\n+                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(char.class) },\n+                { 42, AllocationFactory.UNBOUNDED,\n+                        MemoryLayouts.BITS_32_LE,\n+                        (AllocationFunction<Integer>) SegmentAllocator::allocate,\n+                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(int.class) },\n+                { 42f, AllocationFactory.UNBOUNDED, MemoryLayouts.BITS_32_LE,\n+                        (AllocationFunction<Float>) SegmentAllocator::allocate,\n+                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(float.class) },\n+                { 42L, AllocationFactory.UNBOUNDED, MemoryLayouts.BITS_64_LE,\n+                        (AllocationFunction<Long>) SegmentAllocator::allocate,\n+                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(long.class) },\n+                { 42d, AllocationFactory.UNBOUNDED, MemoryLayouts.BITS_64_LE,\n+                        (AllocationFunction<Double>) SegmentAllocator::allocate,\n+                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(double.class) },\n+                { MemoryAddress.ofLong(42), AllocationFactory.UNBOUNDED, MemoryLayouts.ADDRESS.withOrder(ByteOrder.LITTLE_ENDIAN),\n+                        (AllocationFunction<MemoryAddress>) SegmentAllocator::allocate,\n+                        (Function<MemoryLayout, VarHandle>)l -> MemoryHandles.asAddressVarHandle(l.varHandle(ADDRESS_CARRIER)) },\n+        };\n+    }\n+\n+    @DataProvider(name = \"arrayScopes\")\n+    static Object[][] arrayScopes() {\n+        return new Object[][] {\n+                { AllocationFactory.BOUNDED, MemoryLayouts.BITS_8_LE,\n+                        (AllocationFunction<byte[]>) SegmentAllocator::allocateArray,\n+                        ToArrayHelper.toByteArray },\n+                { AllocationFactory.BOUNDED, MemoryLayouts.BITS_16_LE,\n+                        (AllocationFunction<short[]>) SegmentAllocator::allocateArray,\n+                        ToArrayHelper.toShortArray },\n+                { AllocationFactory.BOUNDED,\n+                        MemoryLayouts.BITS_32_LE,\n+                        (AllocationFunction<int[]>) SegmentAllocator::allocateArray,\n+                        ToArrayHelper.toIntArray },\n+                { AllocationFactory.BOUNDED, MemoryLayouts.BITS_32_LE,\n+                        (AllocationFunction<float[]>) SegmentAllocator::allocateArray,\n+                        ToArrayHelper.toFloatArray },\n+                { AllocationFactory.BOUNDED, MemoryLayouts.BITS_64_LE,\n+                        (AllocationFunction<long[]>) SegmentAllocator::allocateArray,\n+                        ToArrayHelper.toLongArray },\n+                { AllocationFactory.BOUNDED, MemoryLayouts.BITS_64_LE,\n+                        (AllocationFunction<double[]>) SegmentAllocator::allocateArray,\n+                        ToArrayHelper.toDoubleArray },\n+                { AllocationFactory.BOUNDED, MemoryLayouts.ADDRESS.withOrder(ByteOrder.LITTLE_ENDIAN),\n+                        (AllocationFunction<MemoryAddress[]>) SegmentAllocator::allocateArray,\n+                        ToArrayHelper.toAddressArray },\n+\n+\n+                { AllocationFactory.BOUNDED, MemoryLayouts.BITS_8_BE,\n+                        (AllocationFunction<byte[]>) SegmentAllocator::allocateArray,\n+                        ToArrayHelper.toByteArray },\n+                { AllocationFactory.BOUNDED, MemoryLayouts.BITS_16_BE,\n+                        (AllocationFunction<short[]>) SegmentAllocator::allocateArray,\n+                        ToArrayHelper.toShortArray },\n+                { AllocationFactory.BOUNDED,\n+                        MemoryLayouts.BITS_32_BE,\n+                        (AllocationFunction<int[]>) SegmentAllocator::allocateArray,\n+                        ToArrayHelper.toIntArray },\n+                { AllocationFactory.BOUNDED, MemoryLayouts.BITS_32_BE,\n+                        (AllocationFunction<float[]>) SegmentAllocator::allocateArray,\n+                        ToArrayHelper.toFloatArray },\n+                { AllocationFactory.BOUNDED, MemoryLayouts.BITS_64_BE,\n+                        (AllocationFunction<long[]>) SegmentAllocator::allocateArray,\n+                        ToArrayHelper.toLongArray },\n+                { AllocationFactory.BOUNDED, MemoryLayouts.BITS_64_BE,\n+                        (AllocationFunction<double[]>) SegmentAllocator::allocateArray,\n+                        ToArrayHelper.toDoubleArray },\n+                { AllocationFactory.BOUNDED, MemoryLayouts.ADDRESS.withOrder(ByteOrder.BIG_ENDIAN),\n+                        (AllocationFunction<MemoryAddress[]>) SegmentAllocator::allocateArray,\n+                        ToArrayHelper.toAddressArray },\n+\n+                { AllocationFactory.UNBOUNDED, MemoryLayouts.BITS_8_LE,\n+                        (AllocationFunction<byte[]>) SegmentAllocator::allocateArray,\n+                        ToArrayHelper.toByteArray },\n+                { AllocationFactory.UNBOUNDED, MemoryLayouts.BITS_16_LE,\n+                        (AllocationFunction<short[]>) SegmentAllocator::allocateArray,\n+                        ToArrayHelper.toShortArray },\n+                { AllocationFactory.UNBOUNDED,\n+                        MemoryLayouts.BITS_32_LE,\n+                        (AllocationFunction<int[]>) SegmentAllocator::allocateArray,\n+                        ToArrayHelper.toIntArray },\n+                { AllocationFactory.UNBOUNDED, MemoryLayouts.BITS_32_LE,\n+                        (AllocationFunction<float[]>) SegmentAllocator::allocateArray,\n+                        ToArrayHelper.toFloatArray },\n+                { AllocationFactory.UNBOUNDED, MemoryLayouts.BITS_64_LE,\n+                        (AllocationFunction<long[]>) SegmentAllocator::allocateArray,\n+                        ToArrayHelper.toLongArray },\n+                { AllocationFactory.UNBOUNDED, MemoryLayouts.BITS_64_LE,\n+                        (AllocationFunction<double[]>) SegmentAllocator::allocateArray,\n+                        ToArrayHelper.toDoubleArray },\n+                { AllocationFactory.UNBOUNDED, MemoryLayouts.ADDRESS.withOrder(ByteOrder.LITTLE_ENDIAN),\n+                        (AllocationFunction<MemoryAddress[]>) SegmentAllocator::allocateArray,\n+                        ToArrayHelper.toAddressArray },\n+\n+\n+                { AllocationFactory.UNBOUNDED, MemoryLayouts.BITS_8_BE,\n+                        (AllocationFunction<byte[]>) SegmentAllocator::allocateArray,\n+                        ToArrayHelper.toByteArray },\n+                { AllocationFactory.UNBOUNDED, MemoryLayouts.BITS_16_BE,\n+                        (AllocationFunction<short[]>) SegmentAllocator::allocateArray,\n+                        ToArrayHelper.toShortArray },\n+                { AllocationFactory.UNBOUNDED,\n+                        MemoryLayouts.BITS_32_BE,\n+                        (AllocationFunction<int[]>) SegmentAllocator::allocateArray,\n+                        ToArrayHelper.toIntArray },\n+                { AllocationFactory.UNBOUNDED, MemoryLayouts.BITS_32_BE,\n+                        (AllocationFunction<float[]>) SegmentAllocator::allocateArray,\n+                        ToArrayHelper.toFloatArray },\n+                { AllocationFactory.UNBOUNDED, MemoryLayouts.BITS_64_BE,\n+                        (AllocationFunction<long[]>) SegmentAllocator::allocateArray,\n+                        ToArrayHelper.toLongArray },\n+                { AllocationFactory.UNBOUNDED, MemoryLayouts.BITS_64_BE,\n+                        (AllocationFunction<double[]>) SegmentAllocator::allocateArray,\n+                        ToArrayHelper.toDoubleArray },\n+                { AllocationFactory.UNBOUNDED, MemoryLayouts.ADDRESS.withOrder(ByteOrder.BIG_ENDIAN),\n+                        (AllocationFunction<MemoryAddress[]>) SegmentAllocator::allocateArray,\n+                        ToArrayHelper.toAddressArray },\n+        };\n+    }\n+\n+    interface AllocationFunction<X> {\n+        MemorySegment allocate(SegmentAllocator allocator, ValueLayout layout, X value);\n+    }\n+\n+    static class AllocationFactory {\n+        private final boolean isBound;\n+        private final BiFunction<Long, ResourceScope, SegmentAllocator> factory;\n+\n+        private AllocationFactory(boolean isBound, BiFunction<Long, ResourceScope, SegmentAllocator> factory) {\n+            this.isBound = isBound;\n+            this.factory = factory;\n+        }\n+\n+        SegmentAllocator allocator(long size, ResourceScope scope) {\n+            return factory.apply(size, scope);\n+        }\n+\n+        public boolean isBound() {\n+            return isBound;\n+        }\n+\n+        static AllocationFactory BOUNDED = new AllocationFactory(true, SegmentAllocator::arenaAllocator);\n+        static AllocationFactory UNBOUNDED = new AllocationFactory(false, (size, scope) -> SegmentAllocator.arenaAllocator(scope));\n+    }\n+\n+    interface ToArrayHelper<T> {\n+        T array();\n+        T toArray(MemorySegment segment, ValueLayout layout);\n+\n+        ToArrayHelper<byte[]> toByteArray = new ToArrayHelper<>() {\n+            @Override\n+            public byte[] array() {\n+                return new byte[] { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };\n+            }\n+\n+            @Override\n+            public byte[] toArray(MemorySegment segment, ValueLayout layout) {\n+                ByteBuffer buffer = segment.asByteBuffer().order(layout.order());\n+                byte[] found = new byte[buffer.limit()];\n+                buffer.get(found);\n+                return found;\n+            }\n+        };\n+\n+        ToArrayHelper<short[]> toShortArray = new ToArrayHelper<>() {\n+            @Override\n+            public short[] array() {\n+                return new short[] { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };\n+            }\n+\n+            @Override\n+            public short[] toArray(MemorySegment segment, ValueLayout layout) {\n+                ShortBuffer buffer = segment.asByteBuffer().order(layout.order()).asShortBuffer();\n+                short[] found = new short[buffer.limit()];\n+                buffer.get(found);\n+                return found;\n+            }\n+        };\n+\n+        ToArrayHelper<int[]> toIntArray = new ToArrayHelper<>() {\n+            @Override\n+            public int[] array() {\n+                return new int[] { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };\n+            }\n+\n+            @Override\n+            public int[] toArray(MemorySegment segment, ValueLayout layout) {\n+                IntBuffer buffer = segment.asByteBuffer().order(layout.order()).asIntBuffer();\n+                int[] found = new int[buffer.limit()];\n+                buffer.get(found);\n+                return found;\n+            }\n+        };\n+\n+        ToArrayHelper<float[]> toFloatArray = new ToArrayHelper<>() {\n+            @Override\n+            public float[] array() {\n+                return new float[] { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };\n+            }\n+\n+            @Override\n+            public float[] toArray(MemorySegment segment, ValueLayout layout) {\n+                FloatBuffer buffer = segment.asByteBuffer().order(layout.order()).asFloatBuffer();\n+                float[] found = new float[buffer.limit()];\n+                buffer.get(found);\n+                return found;\n+            }\n+        };\n+\n+        ToArrayHelper<long[]> toLongArray = new ToArrayHelper<>() {\n+            @Override\n+            public long[] array() {\n+                return new long[] { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };\n+            }\n+\n+            @Override\n+            public long[] toArray(MemorySegment segment, ValueLayout layout) {\n+                LongBuffer buffer = segment.asByteBuffer().order(layout.order()).asLongBuffer();\n+                long[] found = new long[buffer.limit()];\n+                buffer.get(found);\n+                return found;\n+            }\n+        };\n+\n+        ToArrayHelper<double[]> toDoubleArray = new ToArrayHelper<>() {\n+            @Override\n+            public double[] array() {\n+                return new double[] { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };\n+            }\n+\n+            @Override\n+            public double[] toArray(MemorySegment segment, ValueLayout layout) {\n+                DoubleBuffer buffer = segment.asByteBuffer().order(layout.order()).asDoubleBuffer();\n+                double[] found = new double[buffer.limit()];\n+                buffer.get(found);\n+                return found;\n+            }\n+        };\n+\n+        ToArrayHelper<MemoryAddress[]> toAddressArray = new ToArrayHelper<>() {\n+            @Override\n+            public MemoryAddress[] array() {\n+                return switch ((int)MemoryLayouts.ADDRESS.byteSize()) {\n+                    case 4 -> wrap(toIntArray.array());\n+                    case 8 -> wrap(toLongArray.array());\n+                    default -> throw new IllegalStateException(\"Cannot get here\");\n+                };\n+            }\n+\n+            @Override\n+            public MemoryAddress[] toArray(MemorySegment segment, ValueLayout layout) {\n+                return switch ((int)layout.byteSize()) {\n+                    case 4 -> wrap(toIntArray.toArray(segment, layout));\n+                    case 8 -> wrap(toLongArray.toArray(segment, layout));\n+                    default -> throw new IllegalStateException(\"Cannot get here\");\n+                };\n+            }\n+\n+            private MemoryAddress[] wrap(int[] ints) {\n+                return IntStream.of(ints).mapToObj(MemoryAddress::ofLong).toArray(MemoryAddress[]::new);\n+            }\n+\n+            private MemoryAddress[] wrap(long[] ints) {\n+                return LongStream.of(ints).mapToObj(MemoryAddress::ofLong).toArray(MemoryAddress[]::new);\n+            }\n+        };\n+    }\n+}\n","filename":"test\/jdk\/java\/foreign\/TestSegmentAllocators.java","additions":502,"deletions":0,"binary":false,"changes":502,"status":"added"},{"patch":"@@ -30,1 +30,1 @@\n-import jdk.incubator.foreign.MappedMemorySegments;\n+import jdk.incubator.foreign.MemoryAccess;\n@@ -34,0 +34,1 @@\n+import jdk.incubator.foreign.ResourceScope;\n@@ -37,2 +38,0 @@\n-import java.io.File;\n-import java.io.IOException;\n@@ -40,3 +39,0 @@\n-import java.lang.reflect.InvocationTargetException;\n-import java.lang.reflect.Method;\n-import java.lang.reflect.Modifier;\n@@ -45,3 +41,0 @@\n-import java.nio.channels.FileChannel;\n-import java.nio.file.Path;\n-import java.util.ArrayList;\n@@ -49,1 +42,0 @@\n-import java.util.concurrent.atomic.AtomicBoolean;\n@@ -51,1 +43,0 @@\n-import java.util.function.Function;\n@@ -55,2 +46,1 @@\n-import java.util.stream.Stream;\n-import static jdk.incubator.foreign.MemorySegment.*;\n+\n@@ -63,1 +53,1 @@\n-        MemorySegment.allocateNative(size, align);\n+        MemorySegment.allocateNative(size, align, ResourceScope.newImplicitScope());\n@@ -68,1 +58,1 @@\n-        MemorySegment.allocateNative(layout);\n+        MemorySegment.allocateNative(layout, ResourceScope.newImplicitScope());\n@@ -74,35 +64,1 @@\n-        MemorySegment.allocateNative(Long.MAX_VALUE);\n-    }\n-\n-    @Test(dataProvider = \"segmentOperations\")\n-    public void testOpOutsideConfinement(SegmentMember member) throws Throwable {\n-        try (MemorySegment segment = MemorySegment.allocateNative(4)) {\n-            AtomicBoolean failed = new AtomicBoolean(false);\n-            Thread t = new Thread(() -> {\n-                try {\n-                    Object o = member.method.invoke(segment, member.params);\n-                } catch (ReflectiveOperationException ex) {\n-                    throw new IllegalStateException(ex);\n-                }\n-            });\n-            t.setUncaughtExceptionHandler((thread, ex) -> failed.set(true));\n-            t.start();\n-            t.join();\n-            assertEquals(failed.get(), member.isConfined());\n-        }\n-    }\n-\n-    @Test(dataProvider = \"segmentOperations\")\n-    public void testOpAfterClose(SegmentMember member) throws Throwable {\n-        MemorySegment segment = MemorySegment.allocateNative(4);\n-        segment.close();\n-        try {\n-            Object o = member.method.invoke(segment, member.params);\n-            assertFalse(member.isConfined());\n-        } catch (InvocationTargetException ex) {\n-            assertTrue(member.isConfined());\n-            Throwable target = ex.getTargetException();\n-            assertTrue(target instanceof NullPointerException ||\n-                          target instanceof UnsupportedOperationException ||\n-                          target instanceof IllegalStateException);\n-        }\n+        MemorySegment.allocateNative(Long.MAX_VALUE, ResourceScope.newImplicitScope());\n@@ -113,3 +69,1 @@\n-        try (MemorySegment segment = MemorySegment.allocateNative(1024 * 1024 * 8 * 2)) { \/\/ 2M\n-            \/\/ do nothing\n-        }\n+        MemorySegment segment = MemorySegment.allocateNative(1024 * 1024 * 8 * 2, ResourceScope.newImplicitScope()); \/\/ 2M\n@@ -120,1 +74,1 @@\n-        VarHandle byteHandle = MemoryLayout.ofSequence(MemoryLayouts.JAVA_BYTE)\n+        VarHandle byteHandle = MemoryLayout.sequenceLayout(MemoryLayouts.JAVA_BYTE)\n@@ -122,1 +76,2 @@\n-        try (MemorySegment segment = MemorySegment.allocateNative(1000)) {\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            MemorySegment segment = MemorySegment.allocateNative(1000, 1, scope);\n@@ -131,1 +86,1 @@\n-        VarHandle byteHandle = MemoryLayout.ofSequence(MemoryLayouts.JAVA_BYTE)\n+        VarHandle byteHandle = MemoryLayout.sequenceLayout(MemoryLayouts.JAVA_BYTE)\n@@ -133,1 +88,2 @@\n-        try (MemorySegment segment = MemorySegment.allocateNative(10)) {\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            MemorySegment segment = MemorySegment.allocateNative(10, 1, scope);\n@@ -150,0 +106,14 @@\n+    @Test(expectedExceptions = IndexOutOfBoundsException.class)\n+    public void testSmallSegmentMax() {\n+        long offset = (long)Integer.MAX_VALUE + (long)Integer.MAX_VALUE + 2L + 6L; \/\/ overflows to 6 when casted to int\n+        MemorySegment memorySegment = MemorySegment.allocateNative(10, ResourceScope.newImplicitScope());\n+        MemoryAccess.getIntAtOffset(memorySegment, offset);\n+    }\n+\n+    @Test(expectedExceptions = IndexOutOfBoundsException.class)\n+    public void testSmallSegmentMin() {\n+        long offset = ((long)Integer.MIN_VALUE * 2L) + 6L; \/\/ underflows to 6 when casted to int\n+        MemorySegment memorySegment = MemorySegment.allocateNative(10, ResourceScope.newImplicitScope());\n+        MemoryAccess.getIntAtOffset(memorySegment, offset);\n+    }\n+\n@@ -152,4 +122,3 @@\n-        try (MemorySegment segment = memorySegmentSupplier.get()) {\n-            assertTrue(segment.hasAccessModes(ALL_ACCESS));\n-            assertEquals(segment.accessModes(), ALL_ACCESS);\n-        }\n+        MemorySegment segment = memorySegmentSupplier.get();\n+        assertFalse(segment.isReadOnly());\n+        tryClose(segment);\n@@ -158,14 +127,3 @@\n-    @Test(dataProvider = \"accessModes\")\n-    public void testAccessModes(int accessModes) {\n-        int[] arr = new int[1];\n-        for (AccessActions action : AccessActions.values()) {\n-            MemorySegment segment = MemorySegment.ofArray(arr);\n-            MemorySegment restrictedSegment = segment.withAccessModes(accessModes);\n-            assertEquals(restrictedSegment.accessModes(), accessModes);\n-            boolean shouldFail = !restrictedSegment.hasAccessModes(action.accessMode);\n-            try {\n-                action.run(restrictedSegment);\n-                assertFalse(shouldFail);\n-            } catch (UnsupportedOperationException ex) {\n-                assertTrue(shouldFail);\n-            }\n+    static void tryClose(MemorySegment segment) {\n+        if (!segment.scope().isImplicit()) {\n+            segment.scope().close();\n@@ -185,3 +143,7 @@\n-                () -> MemorySegment.allocateNative(4),\n-                () -> MemorySegment.allocateNative(4, 8),\n-                () -> MemorySegment.allocateNative(MemoryLayout.ofValueBits(32, ByteOrder.nativeOrder()))\n+                () -> MemorySegment.allocateNative(4, ResourceScope.newImplicitScope()),\n+                () -> MemorySegment.allocateNative(4, 8, ResourceScope.newImplicitScope()),\n+                () -> MemorySegment.allocateNative(MemoryLayout.valueLayout(32, ByteOrder.nativeOrder()), ResourceScope.newImplicitScope()),\n+                () -> MemorySegment.allocateNative(4, ResourceScope.newConfinedScope()),\n+                () -> MemorySegment.allocateNative(4, 8, ResourceScope.newConfinedScope()),\n+                () -> MemorySegment.allocateNative(MemoryLayout.valueLayout(32, ByteOrder.nativeOrder()), ResourceScope.newConfinedScope())\n+\n@@ -194,1 +156,1 @@\n-        VarHandle byteHandle = MemoryLayout.ofSequence(MemoryLayouts.JAVA_BYTE)\n+        VarHandle byteHandle = MemoryLayout.sequenceLayout(MemoryLayouts.JAVA_BYTE)\n@@ -198,5 +160,5 @@\n-            try (MemorySegment segment = memorySegmentSupplier.get()) {\n-                segment.fill(value);\n-                for (long l = 0; l < segment.byteSize(); l++) {\n-                    assertEquals((byte) byteHandle.get(segment, l), value);\n-                }\n+            MemorySegment segment = memorySegmentSupplier.get();\n+            segment.fill(value);\n+            for (long l = 0; l < segment.byteSize(); l++) {\n+                assertEquals((byte) byteHandle.get(segment, l), value);\n+            }\n@@ -204,11 +166,9 @@\n-                \/\/ fill a slice\n-                var sliceSegment = segment.asSlice(1, segment.byteSize() - 2).fill((byte) ~value);\n-                for (long l = 0; l < sliceSegment.byteSize(); l++) {\n-                    assertEquals((byte) byteHandle.get(sliceSegment, l), ~value);\n-                }\n-                \/\/ assert enclosing slice\n-                assertEquals((byte) byteHandle.get(segment, 0L), value);\n-                for (long l = 1; l < segment.byteSize() - 2; l++) {\n-                    assertEquals((byte) byteHandle.get(segment, l), (byte) ~value);\n-                }\n-                assertEquals((byte) byteHandle.get(segment, segment.byteSize() - 1L), value);\n+            \/\/ fill a slice\n+            var sliceSegment = segment.asSlice(1, segment.byteSize() - 2).fill((byte) ~value);\n+            for (long l = 0; l < sliceSegment.byteSize(); l++) {\n+                assertEquals((byte) byteHandle.get(sliceSegment, l), ~value);\n+            }\n+            \/\/ assert enclosing slice\n+            assertEquals((byte) byteHandle.get(segment, 0L), value);\n+            for (long l = 1; l < segment.byteSize() - 2; l++) {\n+                assertEquals((byte) byteHandle.get(segment, l), (byte) ~value);\n@@ -216,0 +176,2 @@\n+            assertEquals((byte) byteHandle.get(segment, segment.byteSize() - 1L), value);\n+            tryClose(segment);\n@@ -219,1 +181,1 @@\n-    @Test(dataProvider = \"segmentFactories\", expectedExceptions = IllegalStateException.class)\n+    @Test(dataProvider = \"segmentFactories\")\n@@ -222,2 +184,23 @@\n-        segment.close();\n-        segment.fill((byte) 0xFF);\n+        tryClose(segment);\n+        if (!segment.scope().isAlive()) {\n+            try {\n+                segment.fill((byte) 0xFF);\n+                fail();\n+            } catch (IllegalStateException ex) {\n+                assertTrue(true);\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"segmentFactories\")\n+    public void testNativeSegments(Supplier<MemorySegment> memorySegmentSupplier) throws Exception {\n+        MemorySegment segment = memorySegmentSupplier.get();\n+        try {\n+            segment.address().toRawLongValue();\n+            assertTrue(segment.isNative());\n+            assertTrue(segment.address().isNative());\n+        } catch (UnsupportedOperationException exception) {\n+            assertFalse(segment.isNative());\n+            assertFalse(segment.address().isNative());\n+        }\n+        tryClose(segment);\n@@ -228,3 +211,3 @@\n-        try (MemorySegment segment = memorySegmentSupplier.get()) {\n-            segment.withAccessModes(segment.accessModes() & ~WRITE).fill((byte) 0xFF);\n-        }\n+        MemorySegment segment = memorySegmentSupplier.get();\n+        segment.asReadOnly().fill((byte) 0xFF);\n+        tryClose(segment);\n@@ -235,12 +218,12 @@\n-        try (MemorySegment segment = memorySegmentSupplier.get()) {\n-            AtomicReference<RuntimeException> exception = new AtomicReference<>();\n-            Runnable action = () -> {\n-                try {\n-                    segment.fill((byte) 0xBA);\n-                } catch (RuntimeException e) {\n-                    exception.set(e);\n-                }\n-            };\n-            Thread thread = new Thread(action);\n-            thread.start();\n-            thread.join();\n+        MemorySegment segment = memorySegmentSupplier.get();\n+        AtomicReference<RuntimeException> exception = new AtomicReference<>();\n+        Runnable action = () -> {\n+            try {\n+                segment.fill((byte) 0xBA);\n+            } catch (RuntimeException e) {\n+                exception.set(e);\n+            }\n+        };\n+        Thread thread = new Thread(action);\n+        thread.start();\n+        thread.join();\n@@ -248,0 +231,1 @@\n+        if (segment.scope().ownerThread() != null) {\n@@ -252,0 +236,2 @@\n+        } else {\n+            assertNull(exception.get());\n@@ -253,0 +239,1 @@\n+        tryClose(segment);\n@@ -262,21 +249,0 @@\n-    @Test(expectedExceptions = IllegalArgumentException.class)\n-    public void testWithAccessModesBadUnsupportedMode() {\n-        int[] arr = new int[1];\n-        MemorySegment segment = MemorySegment.ofArray(arr);\n-        segment.withAccessModes((1 << AccessActions.values().length) + 1);\n-    }\n-\n-    @Test(expectedExceptions = IllegalArgumentException.class)\n-    public void testBadWithAccessModesBadStrongerMode() {\n-        int[] arr = new int[1];\n-        MemorySegment segment = MemorySegment.ofArray(arr).withAccessModes(READ);\n-        segment.withAccessModes(WRITE);\n-    }\n-\n-    @Test(expectedExceptions = IllegalArgumentException.class)\n-    public void testBadHasAccessModes() {\n-        int[] arr = new int[1];\n-        MemorySegment segment = MemorySegment.ofArray(arr);\n-        segment.hasAccessModes((1 << AccessActions.values().length) + 1);\n-    }\n-\n@@ -304,1 +270,1 @@\n-            values[i * 2] = new Object[] { MemoryLayout.ofStruct(layoutFactories[i].make(7), MemoryLayout.ofPaddingBits(9)) }; \/\/ good size, bad align\n+            values[i * 2] = new Object[] { MemoryLayout.structLayout(layoutFactories[i].make(7), MemoryLayout.paddingLayout(9)) }; \/\/ good size, bad align\n@@ -311,3 +277,3 @@\n-        VALUE_BE(size -> MemoryLayout.ofValueBits(size, ByteOrder.BIG_ENDIAN)),\n-        VALUE_LE(size -> MemoryLayout.ofValueBits(size, ByteOrder.LITTLE_ENDIAN)),\n-        PADDING(MemoryLayout::ofPaddingBits);\n+        VALUE_BE(size -> MemoryLayout.valueLayout(size, ByteOrder.BIG_ENDIAN)),\n+        VALUE_LE(size -> MemoryLayout.valueLayout(size, ByteOrder.LITTLE_ENDIAN)),\n+        PADDING(MemoryLayout::paddingLayout);\n@@ -326,133 +292,0 @@\n-    @DataProvider(name = \"segmentOperations\")\n-    static Object[][] segmentMembers() {\n-        List<SegmentMember> members = new ArrayList<>();\n-        for (Method m : MemorySegment.class.getDeclaredMethods()) {\n-            \/\/skip defaults, statics and method declared in j.l.Object\n-            if (m.isDefault() ||\n-                    m.getDeclaringClass().equals(Object.class) ||\n-                    (m.getModifiers() & Modifier.STATIC) != 0) continue;\n-            Object[] args = Stream.of(m.getParameterTypes())\n-                    .map(TestSegments::defaultValue)\n-                    .toArray();\n-            members.add(new SegmentMember(m, args));\n-        }\n-        return members.stream().map(ms -> new Object[] { ms }).toArray(Object[][]::new);\n-    }\n-\n-    static class SegmentMember {\n-        final Method method;\n-        final Object[] params;\n-\n-        final static List<String> CONFINED_NAMES = List.of(\n-                \"address\",\n-                \"close\",\n-                \"share\",\n-                \"handoff\",\n-                \"registerCleaner\",\n-                \"fill\",\n-                \"spliterator\",\n-                \"copyFrom\",\n-                \"mismatch\",\n-                \"toByteArray\",\n-                \"toCharArray\",\n-                \"toShortArray\",\n-                \"toIntArray\",\n-                \"toFloatArray\",\n-                \"toLongArray\",\n-                \"toDoubleArray\"\n-        );\n-\n-        public SegmentMember(Method method, Object[] params) {\n-            this.method = method;\n-            this.params = params;\n-        }\n-\n-        boolean isConfined() {\n-            return CONFINED_NAMES.contains(method.getName());\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return method.getName();\n-        }\n-    }\n-\n-    static Object defaultValue(Class<?> c) {\n-        if (c.isPrimitive()) {\n-            if (c == char.class) {\n-                return (char)0;\n-            } else if (c == boolean.class) {\n-                return false;\n-            } else if (c == byte.class) {\n-                return (byte)0;\n-            } else if (c == short.class) {\n-                return (short)0;\n-            } else if (c == int.class) {\n-                return 0;\n-            } else if (c == long.class) {\n-                return 0L;\n-            } else if (c == float.class) {\n-                return 0f;\n-            } else if (c == double.class) {\n-                return 0d;\n-            } else {\n-                throw new IllegalStateException();\n-            }\n-        } else {\n-            return null;\n-        }\n-    }\n-\n-    @DataProvider(name = \"accessModes\")\n-    public Object[][] accessModes() {\n-        int nActions = AccessActions.values().length;\n-        Object[][] results = new Object[1 << nActions][];\n-        for (int accessModes = 0 ; accessModes < results.length ; accessModes++) {\n-            results[accessModes] = new Object[] { accessModes };\n-        }\n-        return results;\n-    }\n-\n-    enum AccessActions {\n-        SHARE(MemorySegment.SHARE) {\n-            @Override\n-            void run(MemorySegment segment) {\n-                segment.share();\n-            }\n-        },\n-        CLOSE(MemorySegment.CLOSE) {\n-            @Override\n-            void run(MemorySegment segment) {\n-                segment.close();\n-            }\n-        },\n-        READ(MemorySegment.READ) {\n-            @Override\n-            void run(MemorySegment segment) {\n-                INT_HANDLE.get(segment);\n-            }\n-        },\n-        WRITE(MemorySegment.WRITE) {\n-            @Override\n-            void run(MemorySegment segment) {\n-                INT_HANDLE.set(segment, 42);\n-            }\n-        },\n-        HANDOFF(MemorySegment.HANDOFF) {\n-            @Override\n-            void run(MemorySegment segment) {\n-                segment.handoff(new Thread());\n-            }\n-        };\n-\n-        final int accessMode;\n-\n-        static VarHandle INT_HANDLE = MemoryLayouts.JAVA_INT.varHandle(int.class);\n-\n-        AccessActions(int accessMode) {\n-            this.accessMode = accessMode;\n-        }\n-\n-        abstract void run(MemorySegment segment);\n-    }\n-\n","filename":"test\/jdk\/java\/foreign\/TestSegments.java","additions":104,"deletions":271,"binary":false,"changes":375,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- * @run testng\/othervm -Dforeign.restricted=permit TestSharedAccess\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED TestSharedAccess\n@@ -41,1 +41,0 @@\n-import java.util.concurrent.atomic.AtomicReference;\n@@ -49,26 +48,0 @@\n-    @Test\n-    public void testConfined() throws Throwable {\n-        Thread owner = Thread.currentThread();\n-        MemorySegment s = MemorySegment.allocateNative(4);\n-        AtomicReference<MemorySegment> confined = new AtomicReference<>(s);\n-        setInt(s, 42);\n-        assertEquals(getInt(s), 42);\n-        List<Thread> threads = new ArrayList<>();\n-        for (int i = 0 ; i < 1000 ; i++) {\n-            threads.add(new Thread(() -> {\n-                assertEquals(getInt(confined.get()), 42);\n-                confined.set(confined.get().handoff(owner));\n-            }));\n-        }\n-        threads.forEach(t -> {\n-            confined.set(confined.get().handoff(t));\n-            t.start();\n-            try {\n-                t.join();\n-            } catch (Throwable e) {\n-                throw new IllegalStateException(e);\n-            }\n-        });\n-        confined.get().close();\n-    }\n-\n@@ -77,2 +50,3 @@\n-        SequenceLayout layout = MemoryLayout.ofSequence(1024, MemoryLayouts.JAVA_INT);\n-        try (MemorySegment s = MemorySegment.allocateNative(layout).share()) {\n+        SequenceLayout layout = MemoryLayout.sequenceLayout(1024, MemoryLayouts.JAVA_INT);\n+        try (ResourceScope scope = ResourceScope.newSharedScope()) {\n+            MemorySegment s = MemorySegment.allocateNative(layout, scope);\n@@ -84,1 +58,1 @@\n-            spliterators.add(s.spliterator(layout));\n+            spliterators.add(s.spliterator(layout.elementLayout()));\n@@ -122,1 +96,2 @@\n-        try (MemorySegment s = MemorySegment.allocateNative(4)) {\n+        try (ResourceScope scope = ResourceScope.newSharedScope()) {\n+            MemorySegment s = MemorySegment.allocateNative(4, 1, scope);\n@@ -126,1 +101,1 @@\n-            MemorySegment sharedSegment = s.address().asSegmentRestricted(s.byteSize()).share();\n+            MemorySegment sharedSegment = s.address().asSegment(s.byteSize(), scope);\n@@ -143,28 +118,0 @@\n-    @Test\n-    public void testHandoffToSelf() {\n-        MemorySegment s1 = MemorySegment.ofArray(new int[4]);\n-        MemorySegment s2 = s1.handoff(Thread.currentThread());\n-        assertFalse(s1.isAlive());\n-        assertTrue(s2.isAlive());\n-    }\n-\n-    @Test\n-    public void testShareTwice() {\n-        MemorySegment s1 = MemorySegment.ofArray(new int[4]).share();\n-        MemorySegment s2 = s1.share();\n-        assertFalse(s1.isAlive());\n-        assertTrue(s2.isAlive());\n-    }\n-\n-    @Test(expectedExceptions=UnsupportedOperationException.class)\n-    public void testBadHandoffNoAccess() {\n-        MemorySegment.ofArray(new int[4])\n-            .withAccessModes(MemorySegment.CLOSE).handoff(new Thread());\n-    }\n-\n-    @Test(expectedExceptions=UnsupportedOperationException.class)\n-    public void testBadShareNoAccess() {\n-        MemorySegment.ofArray(new int[4])\n-                .withAccessModes(MemorySegment.CLOSE).share();\n-    }\n-\n@@ -176,1 +123,2 @@\n-        try (MemorySegment s1 = MemorySegment.allocateNative(MemoryLayout.ofSequence(2, MemoryLayouts.JAVA_INT))) {\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            MemorySegment s1 = MemorySegment.allocateNative(MemoryLayout.sequenceLayout(2, MemoryLayouts.JAVA_INT), scope);\n","filename":"test\/jdk\/java\/foreign\/TestSharedAccess.java","additions":10,"deletions":62,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n-import jdk.incubator.foreign.MemoryHandles;\n@@ -32,0 +31,1 @@\n+import jdk.incubator.foreign.ResourceScope;\n@@ -41,2 +41,2 @@\n-    static MemoryLayout LAYOUT = MemoryLayout.ofSequence(2,\n-            MemoryLayout.ofSequence(5, MemoryLayouts.JAVA_INT));\n+    static MemoryLayout LAYOUT = MemoryLayout.sequenceLayout(2,\n+            MemoryLayout.sequenceLayout(5, MemoryLayouts.JAVA_INT));\n@@ -49,1 +49,2 @@\n-        try (MemorySegment segment = MemorySegment.allocateNative(LAYOUT)) {\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            MemorySegment segment = MemorySegment.allocateNative(LAYOUT, scope);\n","filename":"test\/jdk\/java\/foreign\/TestSlices.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import jdk.incubator.foreign.ResourceScope;\n@@ -37,1 +38,0 @@\n-import java.util.Map;\n@@ -42,2 +42,0 @@\n-import java.util.function.Consumer;\n-import java.util.function.Supplier;\n@@ -48,1 +46,1 @@\n-import static jdk.incubator.foreign.MemorySegment.*;\n+\n@@ -53,1 +51,1 @@\n-    static final VarHandle INT_HANDLE = MemoryLayout.ofSequence(MemoryLayouts.JAVA_INT)\n+    static final VarHandle INT_HANDLE = MemoryLayout.sequenceLayout(MemoryLayouts.JAVA_INT)\n@@ -60,1 +58,1 @@\n-        SequenceLayout layout = MemoryLayout.ofSequence(size, MemoryLayouts.JAVA_INT);\n+        SequenceLayout layout = MemoryLayout.sequenceLayout(size, MemoryLayouts.JAVA_INT);\n@@ -63,3 +61,19 @@\n-        MemorySegment segment = MemorySegment.allocateNative(layout).share();\n-        for (int i = 0; i < layout.elementCount().getAsLong(); i++) {\n-            INT_HANDLE.set(segment, (long) i, i);\n+        try (ResourceScope scope = ResourceScope.newSharedScope()) {\n+            MemorySegment segment = MemorySegment.allocateNative(layout, scope);\n+            for (int i = 0; i < layout.elementCount().getAsLong(); i++) {\n+                INT_HANDLE.set(segment, (long) i, i);\n+            }\n+            long expected = LongStream.range(0, layout.elementCount().getAsLong()).sum();\n+            \/\/serial\n+            long serial = sum(0, segment);\n+            assertEquals(serial, expected);\n+            \/\/parallel counted completer\n+            long parallelCounted = new SumSegmentCounted(null, segment.spliterator(layout.elementLayout()), threshold).invoke();\n+            assertEquals(parallelCounted, expected);\n+            \/\/parallel recursive action\n+            long parallelRecursive = new SumSegmentRecursive(segment.spliterator(layout.elementLayout()), threshold).invoke();\n+            assertEquals(parallelRecursive, expected);\n+            \/\/parallel stream\n+            long streamParallel = segment.elements(layout.elementLayout()).parallel()\n+                    .reduce(0L, TestSpliterator::sumSingle, Long::sum);\n+            assertEquals(streamParallel, expected);\n@@ -67,15 +81,0 @@\n-        long expected = LongStream.range(0, layout.elementCount().getAsLong()).sum();\n-        \/\/serial\n-        long serial = sum(0, segment);\n-        assertEquals(serial, expected);\n-        \/\/parallel counted completer\n-        long parallelCounted = new SumSegmentCounted(null, segment.spliterator(layout), threshold).invoke();\n-        assertEquals(parallelCounted, expected);\n-        \/\/parallel recursive action\n-        long parallelRecursive = new SumSegmentRecursive(segment.spliterator(layout), threshold).invoke();\n-        assertEquals(parallelRecursive, expected);\n-        \/\/parallel stream\n-        long streamParallel = StreamSupport.stream(segment.spliterator(layout), true)\n-                .reduce(0L, TestSpliterator::sumSingle, Long::sum);\n-        assertEquals(streamParallel, expected);\n-        segment.close();\n@@ -84,0 +83,1 @@\n+    @Test\n@@ -85,1 +85,1 @@\n-        SequenceLayout layout = MemoryLayout.ofSequence(1024, MemoryLayouts.JAVA_INT);\n+        SequenceLayout layout = MemoryLayout.sequenceLayout(1024, MemoryLayouts.JAVA_INT);\n@@ -88,1 +88,1 @@\n-        MemorySegment segment = MemorySegment.allocateNative(layout);\n+        MemorySegment segment = MemorySegment.allocateNative(layout, ResourceScope.newImplicitScope());\n@@ -96,1 +96,1 @@\n-        segment.withAccessModes(MemorySegment.READ).spliterator(layout)\n+        segment.spliterator(layout.elementLayout())\n@@ -101,0 +101,30 @@\n+    @Test(expectedExceptions = IllegalArgumentException.class)\n+    public void testBadSpliteratorElementSizeTooBig() {\n+        MemorySegment.ofArray(new byte[2]).spliterator(MemoryLayouts.JAVA_INT);\n+    }\n+\n+    @Test(expectedExceptions = IllegalArgumentException.class)\n+    public void testBadStreamElementSizeTooBig() {\n+        MemorySegment.ofArray(new byte[2]).elements(MemoryLayouts.JAVA_INT);\n+    }\n+\n+    @Test(expectedExceptions = IllegalArgumentException.class)\n+    public void testBadSpliteratorElementSizeNotMultiple() {\n+        MemorySegment.ofArray(new byte[7]).spliterator(MemoryLayouts.JAVA_INT);\n+    }\n+\n+    @Test(expectedExceptions = IllegalArgumentException.class)\n+    public void testBadStreamElementSizeNotMultiple() {\n+        MemorySegment.ofArray(new byte[7]).elements(MemoryLayouts.JAVA_INT);\n+    }\n+\n+    @Test(expectedExceptions = IllegalArgumentException.class)\n+    public void testBadSpliteratorElementSizeZero() {\n+        MemorySegment.ofArray(new byte[7]).spliterator(MemoryLayout.sequenceLayout(0, MemoryLayouts.JAVA_INT));\n+    }\n+\n+    @Test(expectedExceptions = IllegalArgumentException.class)\n+    public void testBadStreamElementSizeZero() {\n+        MemorySegment.ofArray(new byte[7]).elements(MemoryLayout.sequenceLayout(0, MemoryLayouts.JAVA_INT));\n+    }\n+\n@@ -205,48 +235,0 @@\n-\n-    @DataProvider(name = \"accessScenarios\")\n-    public Object[][] accessScenarios() {\n-        SequenceLayout layout = MemoryLayout.ofSequence(16, MemoryLayouts.JAVA_INT);\n-        var mallocSegment = MemorySegment.allocateNative(layout);\n-\n-        Map<Supplier<Spliterator<MemorySegment>>,Integer> l = Map.of(\n-            () -> mallocSegment.withAccessModes(ALL_ACCESS).spliterator(layout), ALL_ACCESS,\n-            () -> mallocSegment.withAccessModes(0).spliterator(layout), 0,\n-            () -> mallocSegment.withAccessModes(READ).spliterator(layout), READ,\n-            () -> mallocSegment.withAccessModes(CLOSE).spliterator(layout), 0,\n-            () -> mallocSegment.withAccessModes(READ|WRITE).spliterator(layout), READ|WRITE,\n-            () -> mallocSegment.withAccessModes(READ|WRITE| SHARE).spliterator(layout), READ|WRITE| SHARE,\n-            () -> mallocSegment.withAccessModes(READ|WRITE| SHARE |HANDOFF).spliterator(layout), READ|WRITE| SHARE |HANDOFF\n-\n-        );\n-        return l.entrySet().stream().map(e -> new Object[] { e.getKey(), e.getValue() }).toArray(Object[][]::new);\n-    }\n-\n-    static Consumer<MemorySegment> assertAccessModes(int accessModes) {\n-        return segment -> {\n-            assertTrue(segment.hasAccessModes(accessModes & ~CLOSE));\n-            assertEquals(segment.accessModes(), accessModes & ~CLOSE);\n-        };\n-    }\n-\n-    @Test(dataProvider = \"accessScenarios\")\n-    public void testAccessModes(Supplier<Spliterator<MemorySegment>> spliteratorSupplier,\n-                                int expectedAccessModes) {\n-        Spliterator<MemorySegment> spliterator = spliteratorSupplier.get();\n-        spliterator.forEachRemaining(assertAccessModes(expectedAccessModes));\n-\n-        spliterator = spliteratorSupplier.get();\n-        do { } while (spliterator.tryAdvance(assertAccessModes(expectedAccessModes)));\n-\n-        splitOrConsume(spliteratorSupplier.get(), assertAccessModes(expectedAccessModes));\n-    }\n-\n-    static void splitOrConsume(Spliterator<MemorySegment> spliterator,\n-                               Consumer<MemorySegment> consumer) {\n-        var s1 = spliterator.trySplit();\n-        if (s1 != null) {\n-            splitOrConsume(s1, consumer);\n-            splitOrConsume(spliterator, consumer);\n-        } else {\n-            spliterator.forEachRemaining(consumer);\n-        }\n-    }\n","filename":"test\/jdk\/java\/foreign\/TestSpliterator.java","additions":57,"deletions":75,"binary":false,"changes":132,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import jdk.incubator.foreign.MemoryAddress;\n@@ -34,0 +33,1 @@\n+import jdk.incubator.foreign.ResourceScope;\n@@ -38,1 +38,0 @@\n-import java.nio.ByteOrder;\n@@ -48,1 +47,2 @@\n-        try (MemorySegment s = MemorySegment.allocateNative(8)) {\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            MemorySegment s = MemorySegment.allocateNative(8, 8, scope);\n@@ -55,1 +55,2 @@\n-        try (MemorySegment s = MemorySegment.allocateNative(8)) {\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            MemorySegment s = MemorySegment.allocateNative(8, 8, scope);\n@@ -62,1 +63,2 @@\n-        try (MemorySegment s = MemorySegment.allocateNative(8)) {\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            MemorySegment s = MemorySegment.allocateNative(8, 8, scope);\n@@ -69,1 +71,2 @@\n-        try (MemorySegment s = MemorySegment.allocateNative(8)) {\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            MemorySegment s = MemorySegment.allocateNative(8, 8, scope);\n@@ -76,1 +79,2 @@\n-        try (MemorySegment s = MemorySegment.allocateNative(8)) {\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            MemorySegment s = MemorySegment.allocateNative(8, 8, scope);\n@@ -83,1 +87,2 @@\n-        try (MemorySegment s = MemorySegment.allocateNative(8)) {\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            MemorySegment s = MemorySegment.allocateNative(8, 8, scope);\n","filename":"test\/jdk\/java\/foreign\/TestTypeAccess.java","additions":13,"deletions":8,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n- * @run testng\/othervm -Dforeign.restricted=permit TestUnsupportedPlatform\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED TestUnsupportedPlatform\n@@ -33,3 +33,0 @@\n-import jdk.incubator.foreign.MemoryLayout;\n-import jdk.incubator.foreign.NativeScope;\n-import org.testng.annotations.DataProvider;\n@@ -38,6 +35,0 @@\n-import java.lang.reflect.Field;\n-import java.util.ArrayList;\n-import java.util.List;\n-\n-import static jdk.incubator.foreign.MemoryAddress.NULL;\n-import static jdk.incubator.foreign.MemoryLayouts.JAVA_BYTE;\n","filename":"test\/jdk\/java\/foreign\/TestUnsupportedPlatform.java","additions":1,"deletions":10,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -32,18 +32,1 @@\n- *   -Dforeign.restricted=permit\n- *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=false\n- *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=false\n- *   TestUpcall\n- * @run testng\/othervm\n- *   -Dforeign.restricted=permit\n- *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=true\n- *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=false\n- *   TestUpcall\n- * @run testng\/othervm\n- *   -Dforeign.restricted=permit\n- *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=false\n- *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=true\n- *   TestUpcall\n- * @run testng\/othervm\n- *   -Dforeign.restricted=permit\n- *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=true\n- *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=true\n+ *   --enable-native-access=ALL-UNNAMED\n@@ -59,2 +42,3 @@\n-import jdk.incubator.foreign.ValueLayout;\n-import org.testng.annotations.AfterClass;\n+\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.SegmentAllocator;\n@@ -89,1 +73,2 @@\n-            PASS_AND_SAVE = MethodHandles.lookup().findStatic(TestUpcall.class, \"passAndSave\", MethodType.methodType(Object.class, Object[].class, AtomicReference.class));\n+            PASS_AND_SAVE = MethodHandles.lookup().findStatic(TestUpcall.class, \"passAndSave\",\n+                    MethodType.methodType(Object.class, Object[].class, AtomicReference.class));\n@@ -95,1 +80,1 @@\n-    static MemorySegment dummyStub;\n+    static MemoryAddress dummyStub;\n@@ -99,1 +84,1 @@\n-        dummyStub = abi.upcallStub(DUMMY, FunctionDescriptor.ofVoid());\n+        dummyStub = abi.upcallStub(DUMMY, FunctionDescriptor.ofVoid(), ResourceScope.newImplicitScope());\n@@ -102,3 +87,16 @@\n-    @AfterClass\n-    void teardown() {\n-        dummyStub.close();\n+    @Test(dataProvider=\"functions\", dataProviderClass=CallGeneratorHelper.class)\n+    public void testUpcalls(int count, String fName, Ret ret, List<ParamType> paramTypes, List<StructFieldType> fields) throws Throwable {\n+        List<Consumer<Object>> returnChecks = new ArrayList<>();\n+        List<Consumer<Object[]>> argChecks = new ArrayList<>();\n+        MemoryAddress addr = lib.lookup(fName).get();\n+        MethodType mtype = methodType(ret, paramTypes, fields);\n+        try (NativeScope scope = new NativeScope()) {\n+            MethodHandle mh = abi.downcallHandle(addr, scope, mtype, function(ret, paramTypes, fields));\n+            Object[] args = makeArgs(scope.scope(), ret, paramTypes, fields, returnChecks, argChecks);\n+            Object[] callArgs = args;\n+            Object res = mh.invokeWithArguments(callArgs);\n+            argChecks.forEach(c -> c.accept(args));\n+            if (ret == Ret.NON_VOID) {\n+                returnChecks.forEach(c -> c.accept(res));\n+            }\n+        }\n@@ -108,2 +106,1 @@\n-    public void testUpcalls(String fName, Ret ret, List<ParamType> paramTypes, List<StructFieldType> fields) throws Throwable {\n-        List<MemorySegment> segments = new ArrayList<>();\n+    public void testUpcallsNoScope(int count, String fName, Ret ret, List<ParamType> paramTypes, List<StructFieldType> fields) throws Throwable {\n@@ -112,5 +109,9 @@\n-        LibraryLookup.Symbol addr = lib.lookup(fName).get();\n-        MethodHandle mh = abi.downcallHandle(addr, methodType(ret, paramTypes, fields), function(ret, paramTypes, fields));\n-        Object[] args = makeArgs(ret, paramTypes, fields, returnChecks, argChecks, segments);\n-        mh = mh.asSpreader(Object[].class, paramTypes.size() + 1);\n-        Object res = mh.invoke(args);\n+        MemoryAddress addr = lib.lookup(fName).get();\n+        MethodType mtype = methodType(ret, paramTypes, fields);\n+        MethodHandle mh = abi.downcallHandle(addr, IMPLICIT_ALLOCATOR, mtype, function(ret, paramTypes, fields));\n+        Object[] args = makeArgs(ResourceScope.newImplicitScope(), ret, paramTypes, fields, returnChecks, argChecks);\n+        Object[] callArgs = args;\n+        if (count % 100 == 0) {\n+            System.gc();\n+        }\n+        Object res = mh.invokeWithArguments(callArgs);\n@@ -121,1 +122,0 @@\n-        segments.forEach(MemorySegment::close);\n@@ -143,1 +143,1 @@\n-    static Object[] makeArgs(Ret ret, List<ParamType> params, List<StructFieldType> fields, List<Consumer<Object>> checks, List<Consumer<Object[]>> argChecks, List<MemorySegment> segments) throws ReflectiveOperationException {\n+    static Object[] makeArgs(ResourceScope scope, Ret ret, List<ParamType> params, List<StructFieldType> fields, List<Consumer<Object>> checks, List<Consumer<Object[]>> argChecks) throws ReflectiveOperationException {\n@@ -146,1 +146,1 @@\n-            args[i] = makeArg(params.get(i).layout(fields), checks, i == 0, segments);\n+            args[i] = makeArg(params.get(i).layout(fields), checks, i == 0);\n@@ -148,1 +148,1 @@\n-        args[params.size()] = makeCallback(ret, params, fields, checks, argChecks, segments);\n+        args[params.size()] = makeCallback(scope, ret, params, fields, checks, argChecks);\n@@ -153,1 +153,1 @@\n-    static MemoryAddress makeCallback(Ret ret, List<ParamType> params, List<StructFieldType> fields, List<Consumer<Object>> checks, List<Consumer<Object[]>> argChecks, List<MemorySegment> segments) {\n+    static MemoryAddress makeCallback(ResourceScope scope, Ret ret, List<ParamType> params, List<StructFieldType> fields, List<Consumer<Object>> checks, List<Consumer<Object[]>> argChecks) {\n@@ -192,3 +192,1 @@\n-        MemorySegment stub = abi.upcallStub(mh, func);\n-        segments.add(stub);\n-        return stub.address();\n+        return abi.upcallStub(mh, func, scope);\n@@ -198,0 +196,8 @@\n+        for (int i = 0; i < o.length; i++) {\n+            if (o[i] instanceof MemorySegment) {\n+                MemorySegment ms = (MemorySegment) o[i];\n+                MemorySegment copy = MemorySegment.allocateNative(ms.byteSize(), ResourceScope.newImplicitScope());\n+                copy.copyFrom(ms);\n+                o[i] = copy;\n+            }\n+        }\n","filename":"test\/jdk\/java\/foreign\/TestUpcall.java","additions":47,"deletions":41,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -32,18 +32,1 @@\n- *   -Dforeign.restricted=permit\n- *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=false\n- *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=false\n- *   TestUpcallHighArity\n- * @run testng\/othervm\/native\n- *   -Dforeign.restricted=permit\n- *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=true\n- *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=false\n- *   TestUpcallHighArity\n- * @run testng\/othervm\/native\n- *   -Dforeign.restricted=permit\n- *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=false\n- *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=true\n- *   TestUpcallHighArity\n- * @run testng\/othervm\/native\n- *   -Dforeign.restricted=permit\n- *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=true\n- *   -Djdk.internal.foreign.ProgrammableInvoker.USE_INTRINSICS=true\n+ *   --enable-native-access=ALL-UNNAMED\n@@ -59,0 +42,1 @@\n+import jdk.incubator.foreign.ResourceScope;\n@@ -65,1 +49,0 @@\n-import java.util.ArrayList;\n@@ -68,1 +51,0 @@\n-import java.util.function.Consumer;\n@@ -79,1 +61,1 @@\n-    static final MemoryLayout S_PDI_LAYOUT = MemoryLayout.ofStruct(\n+    static final MemoryLayout S_PDI_LAYOUT = MemoryLayout.structLayout(\n@@ -109,0 +91,8 @@\n+        for (int i = 0; i < o.length; i++) {\n+            if (o[i] instanceof MemorySegment) {\n+                MemorySegment ms = (MemorySegment) o[i];\n+                MemorySegment copy = MemorySegment.allocateNative(ms.byteSize(), ResourceScope.newImplicitScope());\n+                copy.copyFrom(ms);\n+                o[i] = copy;\n+            }\n+        }\n@@ -119,2 +109,2 @@\n-        try (MemorySegment upcallStub = LINKER.upcallStub(target, upcallDescriptor)) {\n-            List<MemorySegment> segments = new ArrayList<>();\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            MemoryAddress upcallStub = LINKER.upcallStub(target, upcallDescriptor, scope);\n@@ -125,1 +115,1 @@\n-                args[i] = makeArg(argLayouts.get(i - 1), null, false, segments);\n+                args[i] = makeArg(argLayouts.get(i - 1), null, false);\n@@ -138,1 +128,0 @@\n-            segments.forEach(MemorySegment::close);\n","filename":"test\/jdk\/java\/foreign\/TestUpcallHighArity.java","additions":14,"deletions":25,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -0,0 +1,107 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n+ * @modules jdk.incubator.foreign\/jdk.internal.foreign\n+ *\n+ * @run testng\/othervm\/native\n+ *   --enable-native-access=ALL-UNNAMED\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=false\n+ *   TestUpcallStructScope\n+ * @run testng\/othervm\/native\n+ *   --enable-native-access=ALL-UNNAMED\n+ *   -Djdk.internal.foreign.ProgrammableInvoker.USE_SPEC=true\n+ *   TestUpcallStructScope\n+ *\/\n+\n+import jdk.incubator.foreign.CLinker;\n+import jdk.incubator.foreign.FunctionDescriptor;\n+import jdk.incubator.foreign.LibraryLookup;\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.MemoryLayout;\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ResourceScope;\n+import org.testng.annotations.Test;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Consumer;\n+\n+import static jdk.incubator.foreign.CLinker.C_DOUBLE;\n+import static jdk.incubator.foreign.CLinker.C_INT;\n+import static jdk.incubator.foreign.CLinker.C_POINTER;\n+import static org.testng.Assert.assertFalse;\n+\n+public class TestUpcallStructScope {\n+    static final MethodHandle MH_do_upcall;\n+    static final CLinker LINKER = CLinker.getInstance();\n+    static final MethodHandle MH_Consumer_accept;\n+\n+    \/\/ struct S_PDI { void* p0; double p1; int p2; };\n+    static final MemoryLayout S_PDI_LAYOUT = MemoryLayout.structLayout(\n+        C_POINTER.withName(\"p0\"),\n+        C_DOUBLE.withName(\"p1\"),\n+        C_INT.withName(\"p2\")\n+    );\n+\n+    static {\n+        LibraryLookup lookup = LibraryLookup.ofLibrary(\"TestUpcallStructScope\");\n+        MH_do_upcall = LINKER.downcallHandle(\n+            lookup.lookup(\"do_upcall\").orElseThrow(),\n+            MethodType.methodType(void.class, MemoryAddress.class, MemorySegment.class),\n+            FunctionDescriptor.ofVoid(C_POINTER, S_PDI_LAYOUT)\n+        );\n+\n+        try {\n+            MH_Consumer_accept = MethodHandles.publicLookup().findVirtual(Consumer.class, \"accept\",\n+                    MethodType.methodType(void.class, Object.class));\n+        } catch (NoSuchMethodException | IllegalAccessException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    private static MethodHandle methodHandle (Consumer<MemorySegment> callback) {\n+        return MH_Consumer_accept.bindTo(callback).asType(MethodType.methodType(void.class, MemorySegment.class));\n+    }\n+\n+    @Test\n+    public void testUpcall() throws Throwable {\n+        AtomicReference<MemorySegment> capturedSegment = new AtomicReference<>();\n+        MethodHandle target = methodHandle(capturedSegment::set);\n+        FunctionDescriptor upcallDesc = FunctionDescriptor.ofVoid(S_PDI_LAYOUT);\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            MemoryAddress upcallStub = LINKER.upcallStub(target, upcallDesc, scope);\n+            MemorySegment argSegment = MemorySegment.allocateNative(S_PDI_LAYOUT, scope);\n+            MH_do_upcall.invokeExact(upcallStub.address(), argSegment);\n+        }\n+\n+        MemorySegment captured = capturedSegment.get();\n+        assertFalse(captured.scope().isAlive());\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/foreign\/TestUpcallStructScope.java","additions":107,"deletions":0,"binary":false,"changes":107,"status":"added"},{"patch":"@@ -1,96 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\n- *\/\n-\n-\/*\n- * @test\n- * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n- * @run testng\/othervm -Dforeign.restricted=permit TestUpcallStubs\n- *\/\n-\n-import jdk.incubator.foreign.CLinker;\n-import jdk.incubator.foreign.FunctionDescriptor;\n-import jdk.incubator.foreign.MemoryAddress;\n-import jdk.incubator.foreign.MemorySegment;\n-import org.testng.annotations.*;\n-\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.MethodHandles;\n-import java.lang.invoke.MethodType;\n-import java.lang.invoke.VarHandle;\n-\n-import static jdk.incubator.foreign.MemoryLayouts.JAVA_INT;\n-import static org.testng.Assert.assertFalse;\n-\n-public class TestUpcallStubs {\n-\n-    static final CLinker abi = CLinker.getInstance();\n-    static final MethodHandle MH_dummy;\n-\n-    static {\n-        try {\n-            MH_dummy = MethodHandles.lookup()\n-                .findStatic(TestUpcallStubs.class, \"dummy\", MethodType.methodType(void.class));\n-        } catch (NoSuchMethodException | IllegalAccessException e) {\n-            throw new BootstrapMethodError(e);\n-        }\n-    }\n-\n-    private static MemorySegment getStub() {\n-        return abi.upcallStub(MH_dummy, FunctionDescriptor.ofVoid());\n-    }\n-\n-    @Test(expectedExceptions = UnsupportedOperationException.class)\n-    public void testNoAccess() {\n-        try (MemorySegment stub = getStub()) {\n-            VarHandle vh = JAVA_INT.varHandle(int.class);\n-            vh.set(stub, 10);\n-        }\n-    }\n-\n-    @Test\n-    public void testFree() {\n-        MemorySegment stub = getStub();\n-        stub.close();\n-        assertFalse(stub.isAlive());\n-    }\n-\n-    @Test(expectedExceptions = IllegalStateException.class)\n-    public void testAlreadyFreed() {\n-        MemorySegment stub = getStub();\n-        stub.close();\n-        stub.close(); \/\/ should fail\n-    }\n-\n-    @DataProvider\n-    public static Object[][] badAddresses() {\n-        return new Object[][]{\n-            { MemoryAddress.ofLong(42) \/* random address *\/ },\n-            { MemorySegment.ofArray(new int []{ 1, 2, 3 }).address() \/* heap address *\/ }\n-        };\n-    }\n-\n-    \/\/ where\n-    public static void dummy() {}\n-\n-}\n","filename":"test\/jdk\/java\/foreign\/TestUpcallStubs.java","additions":0,"deletions":96,"binary":false,"changes":96,"status":"deleted"},{"patch":"@@ -28,1 +28,1 @@\n- * @run testng\/othervm -Dforeign.restricted=permit TestVarArgs\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED TestVarArgs\n@@ -37,0 +37,1 @@\n+import jdk.incubator.foreign.ResourceScope;\n@@ -53,1 +54,1 @@\n-    static final MemoryLayout ML_CallInfo = MemoryLayout.ofStruct(\n+    static final MemoryLayout ML_CallInfo = MemoryLayout.structLayout(\n@@ -60,1 +61,1 @@\n-    static final VarHandle VH_IntArray = MemoryLayout.ofSequence(C_INT).varHandle(int.class, sequenceElement());\n+    static final VarHandle VH_IntArray = MemoryLayout.sequenceLayout(C_INT).varHandle(int.class, sequenceElement());\n@@ -63,1 +64,1 @@\n-    static final LibraryLookup.Symbol varargsAddr = LibraryLookup.ofLibrary(\"VarArgs\")\n+    static final MemoryAddress varargsAddr = LibraryLookup.ofLibrary(\"VarArgs\")\n@@ -70,3 +71,4 @@\n-        try (MemorySegment writeBack = MemorySegment.allocateNative(args.size() * WRITEBACK_BYTES_PER_ARG);\n-            MemorySegment callInfo = MemorySegment.allocateNative(ML_CallInfo);\n-            MemorySegment argIDs = MemorySegment.allocateNative(MemoryLayout.ofSequence(args.size(), C_INT))) {\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            MemorySegment writeBack = MemorySegment.allocateNative(args.size() * WRITEBACK_BYTES_PER_ARG, WRITEBACK_BYTES_PER_ARG, scope);\n+            MemorySegment callInfo = MemorySegment.allocateNative(ML_CallInfo, scope);\n+            MemorySegment argIDs = MemorySegment.allocateNative(MemoryLayout.sequenceLayout(args.size(), C_INT), scope);\n","filename":"test\/jdk\/java\/foreign\/TestVarArgs.java","additions":9,"deletions":7,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import jdk.incubator.foreign.ResourceScope;\n@@ -36,1 +37,0 @@\n-import java.lang.invoke.MethodHandles;\n@@ -77,1 +77,1 @@\n-        MemorySegment segment = MemorySegment.allocateNative(1, 2);\n+        MemorySegment segment = MemorySegment.allocateNative(1, 2, ResourceScope.newImplicitScope());\n@@ -111,1 +111,2 @@\n-        try (MemorySegment segment = MemorySegment.allocateNative(inner_size * outer_size * 8)) {\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            MemorySegment segment = MemorySegment.allocateNative(inner_size * outer_size * 8, 4, scope);\n","filename":"test\/jdk\/java\/foreign\/TestVarHandleCombinators.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -147,1 +147,1 @@\n-        MemoryLayout struct2 = MemoryLayout.ofStruct(C_INT, C_INT, C_DOUBLE, C_INT);\n+        MemoryLayout struct2 = MemoryLayout.structLayout(C_INT, C_INT, C_DOUBLE, C_INT);\n@@ -150,1 +150,1 @@\n-            { MemoryLayout.ofStruct(C_INT, C_INT, C_DOUBLE), new Binding[] {\n+            { MemoryLayout.structLayout(C_INT, C_INT, C_DOUBLE), new Binding[] {\n@@ -165,1 +165,1 @@\n-            { MemoryLayout.ofStruct(C_INT, C_INT, C_FLOAT, C_FLOAT), new Binding[] {\n+            { MemoryLayout.structLayout(C_INT, C_INT, C_FLOAT, C_FLOAT), new Binding[] {\n@@ -173,1 +173,1 @@\n-            { MemoryLayout.ofStruct(C_FLOAT, MemoryLayout.ofPaddingBits(32), C_DOUBLE),\n+            { MemoryLayout.structLayout(C_FLOAT, MemoryLayout.paddingLayout(32), C_DOUBLE),\n@@ -186,2 +186,2 @@\n-        MemoryLayout struct1 = MemoryLayout.ofStruct(C_INT, C_INT, C_DOUBLE, C_INT);\n-        MemoryLayout struct2 = MemoryLayout.ofStruct(C_LONG, C_LONG, C_LONG);\n+        MemoryLayout struct1 = MemoryLayout.structLayout(C_INT, C_INT, C_DOUBLE, C_INT);\n+        MemoryLayout struct2 = MemoryLayout.structLayout(C_LONG, C_LONG, C_LONG);\n@@ -219,1 +219,1 @@\n-        MemoryLayout struct = MemoryLayout.ofStruct(C_LONG, C_LONG, C_FLOAT);\n+        MemoryLayout struct = MemoryLayout.structLayout(C_LONG, C_LONG, C_FLOAT);\n@@ -242,1 +242,1 @@\n-        MemoryLayout struct = MemoryLayout.ofStruct(C_LONG, C_LONG);\n+        MemoryLayout struct = MemoryLayout.structLayout(C_LONG, C_LONG);\n@@ -268,1 +268,1 @@\n-        MemoryLayout hfa = MemoryLayout.ofStruct(C_FLOAT, C_FLOAT);\n+        MemoryLayout hfa = MemoryLayout.structLayout(C_FLOAT, C_FLOAT);\n@@ -284,4 +284,4 @@\n-                bufferLoad(0, int.class),\n-                vmStore(v1, int.class),\n-                bufferLoad(4, int.class),\n-                vmStore(v2, int.class)\n+                bufferLoad(0, float.class),\n+                vmStore(v1, float.class),\n+                bufferLoad(4, float.class),\n+                vmStore(v2, float.class)\n@@ -294,2 +294,2 @@\n-            vmLoad(v0, int.class),\n-            bufferStore(0, int.class),\n+            vmLoad(v0, float.class),\n+            bufferStore(0, float.class),\n@@ -297,2 +297,2 @@\n-            vmLoad(v1, int.class),\n-            bufferStore(4, int.class),\n+            vmLoad(v1, float.class),\n+            bufferStore(4, float.class),\n@@ -304,1 +304,1 @@\n-        MemoryLayout struct = MemoryLayout.ofStruct(C_FLOAT, C_FLOAT, C_FLOAT);\n+        MemoryLayout struct = MemoryLayout.structLayout(C_FLOAT, C_FLOAT, C_FLOAT);\n@@ -318,2 +318,2 @@\n-                bufferLoad(0, int.class),\n-                vmStore(v0, int.class),\n+                bufferLoad(0, float.class),\n+                vmStore(v0, float.class),\n@@ -321,4 +321,4 @@\n-                bufferLoad(4, int.class),\n-                vmStore(v1, int.class),\n-                bufferLoad(8, int.class),\n-                vmStore(v2, int.class)\n+                bufferLoad(4, float.class),\n+                vmStore(v1, float.class),\n+                bufferLoad(8, float.class),\n+                vmStore(v2, float.class)\n@@ -328,2 +328,2 @@\n-                bufferLoad(0, int.class),\n-                vmStore(v3, int.class),\n+                bufferLoad(0, float.class),\n+                vmStore(v3, float.class),\n@@ -331,4 +331,4 @@\n-                bufferLoad(4, int.class),\n-                vmStore(v4, int.class),\n-                bufferLoad(8, int.class),\n-                vmStore(v5, int.class)\n+                bufferLoad(4, float.class),\n+                vmStore(v4, float.class),\n+                bufferLoad(8, float.class),\n+                vmStore(v5, float.class)\n@@ -354,1 +354,1 @@\n-        MemoryLayout struct = MemoryLayout.ofStruct(C_INT, C_INT, C_DOUBLE, C_INT);\n+        MemoryLayout struct = MemoryLayout.structLayout(C_INT, C_INT, C_DOUBLE, C_INT);\n","filename":"test\/jdk\/java\/foreign\/callarranger\/TestAarch64CallArranger.java","additions":31,"deletions":31,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -78,1 +78,1 @@\n-        MemoryLayout POINT = MemoryLayout.ofStruct(\n+        MemoryLayout POINT = MemoryLayout.structLayout(\n@@ -80,1 +80,1 @@\n-                MemoryLayout.ofStruct(\n+                MemoryLayout.structLayout(\n@@ -107,1 +107,1 @@\n-        MemoryLayout POINT = MemoryLayout.ofStruct(\n+        MemoryLayout POINT = MemoryLayout.structLayout(\n@@ -109,3 +109,3 @@\n-                MemoryLayout.ofPaddingBits(32),\n-                MemoryLayout.ofUnion(\n-                        MemoryLayout.ofStruct(C_INT, C_INT),\n+                MemoryLayout.paddingLayout(32),\n+                MemoryLayout.unionLayout(\n+                        MemoryLayout.structLayout(C_INT, C_INT),\n@@ -137,1 +137,1 @@\n-        MemoryLayout POINT = MemoryLayout.ofStruct(\n+        MemoryLayout POINT = MemoryLayout.structLayout(\n@@ -139,1 +139,1 @@\n-                MemoryLayout.ofStruct(\n+                MemoryLayout.structLayout(\n@@ -166,1 +166,1 @@\n-        MemoryLayout POINT = MemoryLayout.ofStruct(\n+        MemoryLayout POINT = MemoryLayout.structLayout(\n@@ -168,2 +168,2 @@\n-                MemoryLayout.ofUnion(\n-                        MemoryLayout.ofStruct(C_INT, C_INT),\n+                MemoryLayout.unionLayout(\n+                        MemoryLayout.structLayout(C_INT, C_INT),\n@@ -312,1 +312,1 @@\n-        MemoryLayout struct = MemoryLayout.ofStruct(C_INT, C_INT, C_DOUBLE);\n+        MemoryLayout struct = MemoryLayout.structLayout(C_INT, C_INT, C_DOUBLE);\n@@ -332,1 +332,1 @@\n-                bufferLoad(8, long.class), vmStore(xmm0, long.class)\n+                bufferLoad(8, double.class), vmStore(xmm0, double.class)\n@@ -403,1 +403,1 @@\n-            { MemoryLayout.ofStruct(C_LONG), new Binding[]{\n+            { MemoryLayout.structLayout(C_LONG), new Binding[]{\n@@ -407,1 +407,1 @@\n-            { MemoryLayout.ofStruct(C_LONG, C_LONG), new Binding[]{\n+            { MemoryLayout.structLayout(C_LONG, C_LONG), new Binding[]{\n@@ -413,1 +413,1 @@\n-            { MemoryLayout.ofStruct(C_LONG, C_LONG, C_LONG), new Binding[]{\n+            { MemoryLayout.structLayout(C_LONG, C_LONG, C_LONG), new Binding[]{\n@@ -421,1 +421,1 @@\n-            { MemoryLayout.ofStruct(C_LONG, C_LONG, C_LONG, C_LONG), new Binding[]{\n+            { MemoryLayout.structLayout(C_LONG, C_LONG, C_LONG, C_LONG), new Binding[]{\n@@ -436,1 +436,1 @@\n-        MemoryLayout struct = MemoryLayout.ofStruct(C_LONG, C_LONG);\n+        MemoryLayout struct = MemoryLayout.structLayout(C_LONG, C_LONG);\n@@ -466,1 +466,1 @@\n-        MemoryLayout struct = MemoryLayout.ofStruct(C_LONG, C_LONG, C_LONG);\n+        MemoryLayout struct = MemoryLayout.structLayout(C_LONG, C_LONG, C_LONG);\n@@ -487,0 +487,24 @@\n+    @Test\n+    public void testFloatStructsUpcall() {\n+        MemoryLayout struct = MemoryLayout.structLayout(C_FLOAT); \/\/ should be passed in float regs\n+\n+        MethodType mt = MethodType.methodType(MemorySegment.class, MemorySegment.class);\n+        FunctionDescriptor fd = FunctionDescriptor.of(struct, struct);\n+        CallArranger.Bindings bindings = CallArranger.getBindings(mt, fd, true);\n+\n+        assertFalse(bindings.isInMemoryReturn);\n+        CallingSequence callingSequence = bindings.callingSequence;\n+        assertEquals(callingSequence.methodType(), mt);\n+        assertEquals(callingSequence.functionDesc(), fd);\n+\n+        checkArgumentBindings(callingSequence, new Binding[][]{\n+            { allocate(struct), dup(), vmLoad(xmm0, float.class), bufferStore(0, float.class) },\n+        });\n+\n+        checkReturnBindings(callingSequence, new Binding[] {\n+            bufferLoad(0, float.class), vmStore(xmm0, float.class)\n+        });\n+\n+        assertEquals(bindings.nVectorArgs, 1);\n+    }\n+\n","filename":"test\/jdk\/java\/foreign\/callarranger\/TestSysVCallArranger.java","additions":43,"deletions":19,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -140,1 +140,1 @@\n-        MemoryLayout structLayout = MemoryLayout.ofStruct(C_INT, C_INT, C_DOUBLE);\n+        MemoryLayout structLayout = MemoryLayout.structLayout(C_INT, C_INT, C_DOUBLE);\n@@ -211,1 +211,1 @@\n-        MemoryLayout struct = MemoryLayout.ofStruct(C_LONG_LONG);\n+        MemoryLayout struct = MemoryLayout.structLayout(C_LONG_LONG);\n@@ -240,1 +240,1 @@\n-        MemoryLayout struct = MemoryLayout.ofStruct(C_LONG_LONG, C_LONG_LONG);\n+        MemoryLayout struct = MemoryLayout.structLayout(C_LONG_LONG, C_LONG_LONG);\n@@ -291,1 +291,1 @@\n-        MemoryLayout struct = MemoryLayout.ofStruct(C_LONG_LONG);\n+        MemoryLayout struct = MemoryLayout.structLayout(C_LONG_LONG);\n@@ -313,1 +313,1 @@\n-        MemoryLayout struct = MemoryLayout.ofStruct(C_LONG_LONG, C_LONG_LONG);\n+        MemoryLayout struct = MemoryLayout.structLayout(C_LONG_LONG, C_LONG_LONG);\n@@ -333,1 +333,1 @@\n-        MemoryLayout struct = MemoryLayout.ofStruct(C_POINTER, C_DOUBLE, C_INT);\n+        MemoryLayout struct = MemoryLayout.structLayout(C_POINTER, C_DOUBLE, C_INT);\n","filename":"test\/jdk\/java\/foreign\/callarranger\/TestWindowsCallArranger.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,208 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.IOException;\n+import java.lang.ref.Cleaner;\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.Random;\n+import java.util.concurrent.ExecutionException;\n+import java.util.function.Supplier;\n+import java.util.stream.Stream;\n+import jdk.incubator.foreign.MemoryAccess;\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.test.lib.RandomFactory;\n+import org.testng.annotations.*;\n+import static org.testng.Assert.*;\n+\n+\/**\n+ * Not a test, but infra for channel tests.\n+ *\/\n+public class AbstractChannelsTest {\n+\n+    static final Class<IOException> IOE = IOException.class;\n+    static final Class<ExecutionException> EE = ExecutionException.class;\n+    static final Class<IllegalStateException> ISE = IllegalStateException.class;\n+\n+    @FunctionalInterface\n+    interface ThrowingConsumer<T, X extends Throwable> {\n+        void accept(T action) throws X;\n+    }\n+\n+    static ResourceScope closeableScopeOrNull(ResourceScope scope) {\n+        if (scope.isImplicit())\n+            return null;\n+        return scope;\n+    }\n+\n+    static long remaining(ByteBuffer[] buffers) {\n+        return Arrays.stream(buffers).mapToLong(ByteBuffer::remaining).sum();\n+    }\n+\n+    static ByteBuffer[] flip(ByteBuffer[] buffers) {\n+        Arrays.stream(buffers).forEach(ByteBuffer::flip);\n+        return buffers;\n+    }\n+\n+    static ByteBuffer[] clear(ByteBuffer[] buffers) {\n+        Arrays.stream(buffers).forEach(ByteBuffer::clear);\n+        return buffers;\n+    }\n+\n+    static final Random RANDOM = RandomFactory.getRandom();\n+\n+    static ByteBuffer segmentBufferOfSize(ResourceScope scope, int size) {\n+        var segment = MemorySegment.allocateNative(size, 1, scope);\n+        for (int i = 0; i < size; i++) {\n+            MemoryAccess.setByteAtOffset(segment, i, ((byte)RANDOM.nextInt()));\n+        }\n+        return segment.asByteBuffer();\n+    }\n+\n+    static ByteBuffer[] segmentBuffersOfSize(int len, ResourceScope scope, int size) {\n+        ByteBuffer[] bufs = new ByteBuffer[len];\n+        for (int i = 0; i < len; i++)\n+            bufs[i] = segmentBufferOfSize(scope, size);\n+        return bufs;\n+    }\n+\n+    \/**\n+     * Returns an array of mixed source byte buffers; both heap and direct,\n+     * where heap can be from the global scope or scope-less, and direct are\n+     * associated with the given scope.\n+     *\/\n+    static ByteBuffer[] mixedBuffersOfSize(int len, ResourceScope scope, int size) {\n+        ByteBuffer[] bufs;\n+        boolean atLeastOneScopeBuffer = false;\n+        do {\n+            bufs = new ByteBuffer[len];\n+            for (int i = 0; i < len; i++) {\n+                bufs[i] = switch (RANDOM.nextInt(3)) {\n+                    case 0 -> { byte[] b = new byte[size];\n+                                RANDOM.nextBytes(b);\n+                                yield ByteBuffer.wrap(b); }\n+                    case 1 -> { byte[] b = new byte[size];\n+                                RANDOM.nextBytes(b);\n+                                yield MemorySegment.ofArray(b).asByteBuffer(); }\n+                    case 2 -> { atLeastOneScopeBuffer = true;\n+                                yield segmentBufferOfSize(scope, size); }\n+                    default -> throw new AssertionError(\"cannot happen\");\n+                };\n+            }\n+        } while (!atLeastOneScopeBuffer);\n+        return bufs;\n+    }\n+\n+    static void assertMessage(Exception ex, String msg) {\n+        assertTrue(ex.getMessage().contains(msg), \"Expected [%s], in: [%s]\".formatted(msg, ex.getMessage()));\n+    }\n+\n+    static void assertCauses(Throwable ex, Class<? extends Exception>... exceptions) {\n+        for (var expectedClass : exceptions) {\n+            ex = ex.getCause();\n+            assertTrue(expectedClass.isInstance(ex), \"Expected %s, got: %s\".formatted(expectedClass, ex));\n+        }\n+    }\n+\n+    @DataProvider(name = \"confinedScopes\")\n+    public static Object[][] confinedScopes() {\n+        return new Object[][] {\n+                { ScopeSupplier.NEW_CONFINED          },\n+                { ScopeSupplier.NEW_CONFINED_EXPLICIT },\n+        };\n+    }\n+\n+    @DataProvider(name = \"sharedScopes\")\n+    public static Object[][] sharedScopes() {\n+        return new Object[][] {\n+                { ScopeSupplier.NEW_SHARED          },\n+                { ScopeSupplier.NEW_SHARED_EXPLICIT },\n+        };\n+    }\n+\n+    @DataProvider(name = \"closeableScopes\")\n+    public static Object[][] closeableScopes() {\n+        return Stream.of(sharedScopes(), confinedScopes())\n+                .flatMap(Arrays::stream)\n+                .toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider(name = \"implicitScopes\")\n+    public static Object[][] implicitScopes() {\n+        return new Object[][] {\n+                { ScopeSupplier.NEW_IMPLICIT },\n+                { ScopeSupplier.GLOBAL       },\n+        };\n+    }\n+\n+    @DataProvider(name = \"sharedAndImplicitScopes\")\n+    public static Object[][] sharedAndImplicitScopes() {\n+        return Stream.of(sharedScopes(), implicitScopes())\n+                .flatMap(Arrays::stream)\n+                .toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider(name = \"allScopes\")\n+    public static Object[][] allScopes() {\n+        return Stream.of(implicitScopes(), closeableScopes())\n+                .flatMap(Arrays::stream)\n+                .toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider(name = \"sharedScopesAndTimeouts\")\n+    public static Object[][] sharedScopesAndTimeouts() {\n+        return new Object[][] {\n+                { ScopeSupplier.NEW_SHARED          ,  0 },\n+                { ScopeSupplier.NEW_SHARED_EXPLICIT ,  0 },\n+                { ScopeSupplier.NEW_SHARED          , 30 },\n+                { ScopeSupplier.NEW_SHARED_EXPLICIT , 30 },\n+        };\n+    }\n+\n+    static class ScopeSupplier implements Supplier<ResourceScope> {\n+\n+        static final Supplier<ResourceScope> NEW_CONFINED =\n+                new ScopeSupplier(() -> ResourceScope.newConfinedScope(), \"newConfinedScope()\");\n+        static final Supplier<ResourceScope> NEW_CONFINED_EXPLICIT =\n+                new ScopeSupplier(() -> ResourceScope.newConfinedScope(Cleaner.create()), \"newConfinedScope(Cleaner)\");\n+        static final Supplier<ResourceScope> NEW_SHARED =\n+                new ScopeSupplier(() -> ResourceScope.newSharedScope(), \"newSharedScope()\");\n+        static final Supplier<ResourceScope> NEW_SHARED_EXPLICIT =\n+                new ScopeSupplier(() -> ResourceScope.newSharedScope(Cleaner.create()), \"newSharedScope(Cleaner)\");\n+        static final Supplier<ResourceScope> NEW_IMPLICIT =\n+                new ScopeSupplier(() -> ResourceScope.newImplicitScope(), \"newImplicitScope()\");\n+        static final Supplier<ResourceScope> GLOBAL =\n+                new ScopeSupplier(() -> ResourceScope.globalScope(), \"globalScope()\");\n+\n+        private final Supplier<ResourceScope> supplier;\n+        private final String str;\n+        private ScopeSupplier(Supplier<ResourceScope> supplier, String str) {\n+            this.supplier = supplier;\n+            this.str = str;\n+        }\n+        @Override public String toString() { return str; }\n+        @Override public ResourceScope get() { return supplier.get(); }\n+    }\n+}\n+\n","filename":"test\/jdk\/java\/foreign\/channels\/AbstractChannelsTest.java","additions":208,"deletions":0,"binary":false,"changes":208,"status":"added"},{"patch":"@@ -0,0 +1,387 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @library \/test\/lib\n+ * @modules java.base\/sun.nio.ch\n+ *          jdk.incubator.foreign\/jdk.internal.foreign\n+ * @key randomness\n+ * @run testng\/othervm TestAsyncSocketChannels\n+ * @run testng\/othervm -Dsun.nio.ch.disableSynchronousRead=true TestAsyncSocketChannels\n+ * @run testng\/othervm -Dsun.nio.ch.disableSynchronousRead=false TestAsyncSocketChannels\n+ *\/\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.AsynchronousServerSocketChannel;\n+import java.nio.channels.AsynchronousSocketChannel;\n+import java.nio.channels.CompletionHandler;\n+import java.util.List;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.Supplier;\n+import jdk.incubator.foreign.MemoryAccess;\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ResourceScope;\n+import org.testng.annotations.*;\n+import static java.lang.System.out;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static org.testng.Assert.*;\n+\n+\/**\n+ * Tests consisting of buffer views with asynchronous NIO network channels.\n+ *\/\n+public class TestAsyncSocketChannels extends AbstractChannelsTest {\n+\n+    static final Class<IOException> IOE = IOException.class;\n+    static final Class<ExecutionException> EE = ExecutionException.class;\n+    static final Class<IllegalStateException> ISE = IllegalStateException.class;\n+\n+    \/** Tests that confined scopes are not supported. *\/\n+    @Test(dataProvider = \"confinedScopes\")\n+    public void testWithConfined(Supplier<ResourceScope> scopeSupplier)\n+        throws Throwable\n+    {\n+        try (var channel = AsynchronousSocketChannel.open();\n+             var server = AsynchronousServerSocketChannel.open();\n+             var connectedChannel = connectChannels(server, channel);\n+             var scope = scopeSupplier.get()) {\n+            var segment = MemorySegment.allocateNative(10, 1, scope);\n+            var bb = segment.asByteBuffer();\n+            var bba = new ByteBuffer[] { bb };\n+            List<ThrowingConsumer<TestHandler,?>> ioOps = List.of(\n+                    handler -> handler.propagateHandlerFromFuture(channel.write(bb)),\n+                    handler -> handler.propagateHandlerFromFuture(channel.read(bb)),\n+                    handler -> channel.write(bb, null, handler),\n+                    handler -> channel.read( bb, null, handler),\n+                    handler -> channel.write(bb , 0L, SECONDS, null, handler),\n+                    handler -> channel.read( bb,  0L, SECONDS, null, handler),\n+                    handler -> channel.write(bba, 0, bba.length, 0L, SECONDS, null, handler),\n+                    handler -> channel.read( bba, 0, bba.length, 0L, SECONDS, null, handler)\n+            );\n+            for (var ioOp : ioOps) {\n+                out.println(\"testAsyncWithConfined - op\");\n+                var handler = new TestHandler();\n+                ioOp.accept(handler);\n+                handler.await()\n+                        .assertFailedWith(ISE)\n+                        .assertExceptionMessage(\"Confined scope not supported\");\n+            }\n+        }\n+    }\n+\n+    \/** Tests that I\/O with a closed scope throws a suitable exception. *\/\n+    @Test(dataProvider = \"sharedScopesAndTimeouts\")\n+    public void testIOWithClosedSharedScope(Supplier<ResourceScope> scopeSupplier, int timeout)\n+        throws Exception\n+    {\n+        try (var channel = AsynchronousSocketChannel.open();\n+             var server = AsynchronousServerSocketChannel.open();\n+             var connectedChannel = connectChannels(server, channel)) {\n+            ResourceScope scope = scopeSupplier.get();\n+            ByteBuffer bb = segmentBufferOfSize(scope, 64);\n+            ByteBuffer[] buffers = segmentBuffersOfSize(8, scope, 32);\n+            scope.close();\n+            {\n+                assertCauses(expectThrows(EE, () -> connectedChannel.read(bb).get()), IOE, ISE);\n+            }\n+            {\n+                var handler = new TestHandler<Integer>();\n+                connectedChannel.read(bb, null, handler);\n+                handler.await().assertFailedWith(ISE).assertExceptionMessage(\"Already closed\");\n+            }\n+            {\n+                var handler = new TestHandler<Integer>();\n+                connectedChannel.read(bb, timeout, SECONDS, null, handler);\n+                handler.await().assertFailedWith(ISE).assertExceptionMessage(\"Already closed\");\n+            }\n+            {\n+                var handler = new TestHandler<Long>();\n+                connectedChannel.read(buffers, 0, buffers.length, timeout, SECONDS, null, handler);\n+                handler.await().assertFailedWith(ISE).assertExceptionMessage(\"Already closed\");\n+            }\n+            {\n+                assertCauses(expectThrows(EE, () -> connectedChannel.write(bb).get()), IOE, ISE);\n+            }\n+            {\n+                var handler = new TestHandler<Integer>();\n+                connectedChannel.write(bb, null, handler);\n+                handler.await().assertFailedWith(ISE).assertExceptionMessage(\"Already closed\");\n+            }\n+            {\n+                var handler = new TestHandler<Integer>();\n+                connectedChannel.write(bb, timeout, SECONDS, null, handler);\n+                handler.await().assertFailedWith(ISE).assertExceptionMessage(\"Already closed\");\n+            }\n+            {\n+                var handler = new TestHandler<Long>();\n+                connectedChannel.write(buffers, 0, buffers.length, timeout, SECONDS, null, handler);\n+                handler.await().assertFailedWith(ISE).assertExceptionMessage(\"Already closed\");\n+            }\n+        }\n+    }\n+\n+    \/** Tests basic I\/O operations work with views over implicit and shared scopes. *\/\n+    @Test(dataProvider = \"sharedAndImplicitScopes\")\n+    public void testBasicIOWithSupportedScope(Supplier<ResourceScope> scopeSupplier)\n+        throws Exception\n+    {\n+        ResourceScope scope;\n+        try (var asc1 = AsynchronousSocketChannel.open();\n+             var assc = AsynchronousServerSocketChannel.open();\n+             var asc2 = connectChannels(assc, asc1);\n+             var scp = closeableScopeOrNull(scope = scopeSupplier.get())) {\n+            MemorySegment segment1 = MemorySegment.allocateNative(10, 1, scope);\n+            MemorySegment segment2 = MemorySegment.allocateNative(10, 1, scope);\n+            for (int i = 0; i < 10; i++) {\n+                MemoryAccess.setByteAtOffset(segment1, i, (byte) i);\n+            }\n+            {   \/\/ Future variants\n+                ByteBuffer bb1 = segment1.asByteBuffer();\n+                ByteBuffer bb2 = segment2.asByteBuffer();\n+                assertEquals((int)asc1.write(bb1).get(), 10);\n+                assertEquals((int)asc2.read(bb2).get(), 10);\n+                assertEquals(bb2.flip(), ByteBuffer.wrap(new byte[]{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}));\n+            }\n+            {   \/\/ CompletionHandler variants\n+                ByteBuffer bb1 = segment1.asByteBuffer();\n+                ByteBuffer bb2 = segment2.asByteBuffer();\n+                var writeHandler = new TestHandler();\n+                asc1.write(new ByteBuffer[]{bb1}, 0, 1, 30L, SECONDS, null, writeHandler);\n+                writeHandler.await().assertCompleteWith(10L);\n+                var readHandler = new TestHandler();\n+                asc2.read(new ByteBuffer[]{bb2}, 0, 1, 30L, SECONDS, null, readHandler);\n+                readHandler.await().assertCompleteWith(10L);\n+                assertEquals(bb2.flip(), ByteBuffer.wrap(new byte[]{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}));\n+            }\n+            {   \/\/ Gathering\/Scattering variants\n+                var writeBuffers = mixedBuffersOfSize(16, scope, 32);\n+                var readBuffers = mixedBuffersOfSize(16, scope, 32);\n+                long expectedCount = remaining(writeBuffers);\n+                var writeHandler = new TestHandler();\n+                asc1.write(writeBuffers, 0, 16, 30L, SECONDS, null, writeHandler);\n+                writeHandler.await().assertCompleteWith(expectedCount);\n+                var readHandler = new TestHandler();\n+                asc2.read(readBuffers, 0, 16, 30L, SECONDS, null, readHandler);\n+                readHandler.await().assertCompleteWith(expectedCount);\n+                assertEquals(flip(readBuffers), clear(writeBuffers));\n+            }\n+        }\n+    }\n+\n+    \/** Tests that a scope is not closeable when there is an outstanding read operation. *\/\n+    @Test(dataProvider = \"sharedScopesAndTimeouts\")\n+    public void testCloseWithOutstandingRead(Supplier<ResourceScope> scopeSupplier, int timeout)\n+        throws Throwable\n+    {\n+        try (var asc1 = AsynchronousSocketChannel.open();\n+             var assc = AsynchronousServerSocketChannel.open();\n+             var asc2 = connectChannels(assc, asc1);\n+             var scope = scopeSupplier.get()) {\n+            var segment = MemorySegment.allocateNative(10, 1, scope);\n+            var bb = segment.asByteBuffer();\n+            var bba = new ByteBuffer[] { bb };\n+            List<ThrowingConsumer<TestHandler,?>> readOps = List.of(\n+                    handler -> handler.propagateHandlerFromFuture(asc1.read(bb)),\n+                    handler -> asc1.read(bb, null, handler),\n+                    handler -> asc1.read(bb,  timeout, SECONDS, null, handler),\n+                    handler -> asc1.read(bba, 0, bba.length, timeout, SECONDS, null, handler)\n+            );\n+            for (var ioOp : readOps) {\n+                out.println(\"testCloseWithOutstandingRead - op\");\n+                var handler = new TestHandler<Long>();\n+                ioOp.accept(handler);\n+                assertFalse(handler.isDone());\n+                assertTrue(scope.isAlive());\n+                assertMessage(expectThrows(ISE, () -> scope.close()), \"Scope is acquired by\");\n+\n+                \/\/ write to allow the blocking read complete, which will\n+                \/\/ in turn unlock the scope and allow it to be closed.\n+                asc2.write(ByteBuffer.wrap(new byte[] { 0x01 })).get();\n+                handler.await().assertCompleteWith(1L);\n+                assertTrue(scope.isAlive());\n+            }\n+        }\n+    }\n+\n+    \/** Tests that a scope is not closeable when there is an outstanding write operation. *\/\n+    \/\/ Note: limited scenarios are checked, given the 5 sec sleep!\n+    @Test(dataProvider = \"sharedScopesAndTimeouts\")\n+    public void testCloseWithOutstandingWrite(Supplier<ResourceScope> scopeSupplier, int timeout)\n+         throws Throwable\n+    {\n+        try (var asc1 = AsynchronousSocketChannel.open();\n+             var assc = AsynchronousServerSocketChannel.open();\n+             var asc2 = connectChannels(assc, asc1);\n+             var scope = scopeSupplier.get()) {\n+\n+            \/\/ number of bytes written\n+            final AtomicLong bytesWritten = new AtomicLong(0);\n+            \/\/ set to true to signal that no more buffers should be written\n+            final AtomicBoolean continueWriting = new AtomicBoolean(true);\n+            final AtomicInteger outstandingWriteOps = new AtomicInteger(0);\n+\n+            \/\/ write until socket buffer is full so as to create the conditions\n+            \/\/ for when a write does not complete immediately\n+            var bba = segmentBuffersOfSize(32, scope, 128);\n+            TestHandler<Long> handler;\n+            outstandingWriteOps.getAndIncrement();\n+            asc1.write(bba, 0, bba.length, timeout, SECONDS, null,\n+                    (handler = new TestHandler<>() {\n+                        public void completed(Long result, Void att) {\n+                            super.completed(result, att);\n+                            bytesWritten.addAndGet(result);\n+                            if (continueWriting.get()) {\n+                                var bba = segmentBuffersOfSize(32, scope, 128);\n+                                outstandingWriteOps.getAndIncrement();\n+                                asc1.write(bba, 0, bba.length, timeout, SECONDS, null, this);\n+                            }\n+                            outstandingWriteOps.getAndDecrement();\n+                        }\n+                    }));\n+            \/\/ give time for socket buffer to fill up.\n+            Thread.sleep(5*1000);\n+\n+            assertMessage(expectThrows(ISE, () -> scope.close()), \"Scope is acquired by\");\n+            assertTrue(scope.isAlive());\n+\n+            \/\/ signal handler to stop further writing\n+            continueWriting.set(false);\n+\n+            \/\/ read to allow the outstanding write complete, which will\n+            \/\/ in turn unlock the scope and allow it to be closed.\n+            readNBytes(asc2, bytesWritten.get());\n+            assertTrue(scope.isAlive());\n+            out.println(\"outstanding writes: \" + outstandingWriteOps.get());\n+            while (outstandingWriteOps.get() > 0 )  {\n+                out.println(\"spinning\");\n+                Thread.onSpinWait();\n+            }\n+            handler.await();\n+        }\n+    }\n+\n+    \/** Completion handler that exposes conveniences to assert results. *\/\n+    static class TestHandler<V extends Number> implements CompletionHandler<V, Void> {\n+        volatile V result;\n+        volatile Throwable throwable;\n+        final CountDownLatch latch = new CountDownLatch(1);\n+\n+        \/** Starts a thread that complete the handled with the Future result. *\/\n+        TestHandler propagateHandlerFromFuture(Future<Integer> future) {\n+            Runnable runnable = () -> {\n+                try {\n+                    this.completed((V)future.get(), null);\n+                } catch (Throwable t) {\n+                    \/\/ assert and unwrap exception added by Future\n+                    assertTrue(ExecutionException.class.isInstance(t));\n+                    t = t.getCause();\n+                    assertTrue(IOException.class.isInstance(t));\n+                    t = t.getCause();\n+                    this.failed(t, null);\n+                }\n+            };\n+            Thread t = new Thread(runnable);\n+            t.start();\n+            return this;\n+        }\n+\n+        @Override\n+        public void completed(V result, Void att) {\n+            assert result.longValue() >= 0;\n+            this.result = result;\n+            latch.countDown();\n+        }\n+        @Override\n+        public void failed(Throwable exc, Void att){\n+            this.throwable = tolerateIOEOnWindows(exc);\n+            latch.countDown();\n+        }\n+\n+        TestHandler await() throws InterruptedException{\n+            latch.await();\n+            return this;\n+        }\n+\n+        TestHandler assertCompleteWith(V value) {\n+            assertEquals(result.longValue(), value.longValue());\n+            assertEquals(throwable, null);\n+            return this;\n+        }\n+\n+        TestHandler assertFailedWith(Class<? extends Exception> expectedException) {\n+            assertTrue(expectedException.isInstance(throwable),\n+                       \"Expected type:%s, got:%s\".formatted(expectedException, throwable) );\n+            assertEquals(result, null, \"Unexpected result: \" + result);\n+            return this;\n+        }\n+\n+        TestHandler assertExceptionMessage(String expectedMessage) {\n+            assertEquals(throwable.getMessage(), expectedMessage);\n+            return this;\n+        }\n+\n+        boolean isDone() {\n+            return latch.getCount() == 0;\n+        }\n+    }\n+\n+    static AsynchronousSocketChannel connectChannels(AsynchronousServerSocketChannel assc,\n+                                                     AsynchronousSocketChannel asc)\n+        throws Exception\n+    {\n+        assc.bind(new InetSocketAddress(InetAddress.getLoopbackAddress(), 0));\n+        asc.connect(assc.getLocalAddress()).get();\n+        return assc.accept().get();\n+    }\n+\n+    \/** Tolerate the additional level of IOException wrapping of unchecked exceptions\n+     * On Windows, when completing the completion handler with a failure. *\/\n+    static Throwable tolerateIOEOnWindows(Throwable t) {\n+        if (System.getProperty(\"os.name\").startsWith(\"Windows\")) {\n+            if (t instanceof IOException)\n+                return t.getCause();\n+        }\n+        return t;\n+    }\n+\n+    static void readNBytes(AsynchronousSocketChannel channel, long len)\n+        throws Exception\n+    {\n+        var buf = ByteBuffer.allocateDirect(4096);\n+        long total = 0L;\n+        do {\n+            int n = channel.read(buf).get();\n+            assertTrue(n > 0, \"got:\" + n);\n+            buf.clear();\n+            total += n;\n+        } while (total < len);\n+    }\n+}\n","filename":"test\/jdk\/java\/foreign\/channels\/TestAsyncSocketChannels.java","additions":387,"deletions":0,"binary":false,"changes":387,"status":"added"},{"patch":"@@ -0,0 +1,238 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @library \/test\/lib\n+ * @modules java.base\/sun.nio.ch\n+ *          jdk.incubator.foreign\/jdk.internal.foreign\n+ * @key randomness\n+ * @run testng\/othervm TestSocketChannels\n+ *\/\n+\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.ServerSocketChannel;\n+import java.nio.channels.SocketChannel;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Supplier;\n+import java.util.stream.Stream;\n+import jdk.incubator.foreign.MemoryAccess;\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ResourceScope;\n+import org.testng.annotations.*;\n+import static org.testng.Assert.*;\n+\n+\/**\n+ * Tests consisting of buffer views with synchronous NIO network channels.\n+ *\/\n+public class TestSocketChannels extends AbstractChannelsTest {\n+\n+    static final Class<IllegalStateException> ISE = IllegalStateException.class;\n+\n+    @Test(dataProvider = \"closeableScopes\")\n+    public void testBasicIOWithClosedSegment(Supplier<ResourceScope> scopeSupplier)\n+        throws Exception\n+    {\n+        try (var channel = SocketChannel.open();\n+             var server = ServerSocketChannel.open();\n+             var connectedChannel = connectChannels(server, channel)) {\n+            ResourceScope scope = scopeSupplier.get();\n+            ByteBuffer bb = segmentBufferOfSize(scope, 16);\n+            scope.close();\n+            assertMessage(expectThrows(ISE, () -> channel.read(bb)),                           \"Already closed\");\n+            assertMessage(expectThrows(ISE, () -> channel.read(new ByteBuffer[] {bb})),        \"Already closed\");\n+            assertMessage(expectThrows(ISE, () -> channel.read(new ByteBuffer[] {bb}, 0, 1)),  \"Already closed\");\n+            assertMessage(expectThrows(ISE, () -> channel.write(bb)),                          \"Already closed\");\n+            assertMessage(expectThrows(ISE, () -> channel.write(new ByteBuffer[] {bb})),       \"Already closed\");\n+            assertMessage(expectThrows(ISE, () -> channel.write(new ByteBuffer[] {bb}, 0 ,1)), \"Already closed\");\n+        }\n+    }\n+\n+    @Test(dataProvider = \"closeableScopes\")\n+    public void testScatterGatherWithClosedSegment(Supplier<ResourceScope> scopeSupplier)\n+        throws Exception\n+    {\n+        try (var channel = SocketChannel.open();\n+             var server = ServerSocketChannel.open();\n+             var connectedChannel = connectChannels(server, channel)) {\n+            ResourceScope scope = scopeSupplier.get();\n+            ByteBuffer[] buffers = segmentBuffersOfSize(8, scope, 16);\n+            scope.close();\n+            assertMessage(expectThrows(ISE, () -> channel.write(buffers)),       \"Already closed\");\n+            assertMessage(expectThrows(ISE, () -> channel.read(buffers)),        \"Already closed\");\n+            assertMessage(expectThrows(ISE, () -> channel.write(buffers, 0 ,8)), \"Already closed\");\n+            assertMessage(expectThrows(ISE, () -> channel.read(buffers, 0, 8)),  \"Already closed\");\n+        }\n+    }\n+\n+    @Test(dataProvider = \"allScopes\")\n+    public void testBasicIO(Supplier<ResourceScope> scopeSupplier)\n+        throws Exception\n+    {\n+        ResourceScope scope;\n+        try (var sc1 = SocketChannel.open();\n+             var ssc = ServerSocketChannel.open();\n+             var sc2 = connectChannels(ssc, sc1);\n+             var scp = closeableScopeOrNull(scope = scopeSupplier.get())) {\n+            MemorySegment segment1 = MemorySegment.allocateNative(10, 1, scope);\n+            MemorySegment segment2 = MemorySegment.allocateNative(10, 1, scope);\n+            for (int i = 0; i < 10; i++) {\n+                MemoryAccess.setByteAtOffset(segment1, i, (byte) i);\n+            }\n+            ByteBuffer bb1 = segment1.asByteBuffer();\n+            ByteBuffer bb2 = segment2.asByteBuffer();\n+            assertEquals(sc1.write(bb1), 10);\n+            assertEquals(sc2.read(bb2), 10);\n+            assertEquals(bb2.flip(), ByteBuffer.wrap(new byte[]{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}));\n+        }\n+    }\n+\n+    @Test\n+    public void testBasicHeapIOWithGlobalScope() throws Exception {\n+        try (var sc1 = SocketChannel.open();\n+             var ssc = ServerSocketChannel.open();\n+             var sc2 = connectChannels(ssc, sc1)) {\n+            var segment1 = MemorySegment.ofArray(new byte[10]);\n+            var segment2 = MemorySegment.ofArray(new byte[10]);\n+            for (int i = 0; i < 10; i++) {\n+                MemoryAccess.setByteAtOffset(segment1, i, (byte) i);\n+            }\n+            ByteBuffer bb1 = segment1.asByteBuffer();\n+            ByteBuffer bb2 = segment2.asByteBuffer();\n+            assertEquals(sc1.write(bb1), 10);\n+            assertEquals(sc2.read(bb2), 10);\n+            assertEquals(bb2.flip(), ByteBuffer.wrap(new byte[]{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}));\n+        }\n+    }\n+\n+    @Test(dataProvider = \"confinedScopes\")\n+    public void testIOOnConfinedFromAnotherThread(Supplier<ResourceScope> scopeSupplier)\n+        throws Exception\n+    {\n+        try (var channel = SocketChannel.open();\n+             var server = ServerSocketChannel.open();\n+             var connected = connectChannels(server, channel);\n+             var scope = scopeSupplier.get()) {\n+            var segment = MemorySegment.allocateNative(10, 1, scope);\n+            ByteBuffer bb = segment.asByteBuffer();\n+            List<ThrowingRunnable> ioOps = List.of(\n+                    () -> channel.write(bb),\n+                    () -> channel.read(bb),\n+                    () -> channel.write(new ByteBuffer[] {bb}),\n+                    () -> channel.read(new ByteBuffer[] {bb}),\n+                    () -> channel.write(new ByteBuffer[] {bb}, 0, 1),\n+                    () -> channel.read(new ByteBuffer[] {bb}, 0, 1)\n+            );\n+            for (var ioOp : ioOps) {\n+                AtomicReference<Exception> exception = new AtomicReference<>();\n+                Runnable task = () -> exception.set(expectThrows(ISE, ioOp));\n+                var t = new Thread(task);\n+                t.start();\n+                t.join();\n+                assertMessage(exception.get(), \"Attempted access outside owning thread\");\n+            }\n+        }\n+    }\n+\n+    @Test(dataProvider = \"allScopes\")\n+    public void testScatterGatherIO(Supplier<ResourceScope> scopeSupplier)\n+        throws Exception\n+    {\n+        ResourceScope scope;\n+        try (var sc1 = SocketChannel.open();\n+             var ssc = ServerSocketChannel.open();\n+             var sc2 = connectChannels(ssc, sc1);\n+             var scp = closeableScopeOrNull(scope = scopeSupplier.get())) {\n+            var writeBuffers = mixedBuffersOfSize(32, scope, 64);\n+            var readBuffers = mixedBuffersOfSize(32, scope, 64);\n+            long expectedCount = remaining(writeBuffers);\n+            assertEquals(writeNBytes(sc1, writeBuffers, 0, 32, expectedCount), expectedCount);\n+            assertEquals(readNBytes(sc2, readBuffers, 0, 32, expectedCount), expectedCount);\n+            assertEquals(flip(readBuffers), clear(writeBuffers));\n+        }\n+    }\n+\n+    @Test(dataProvider = \"closeableScopes\")\n+    public void testBasicIOWithDifferentScopes(Supplier<ResourceScope> scopeSupplier)\n+         throws Exception\n+    {\n+        try (var sc1 = SocketChannel.open();\n+             var ssc = ServerSocketChannel.open();\n+             var sc2 = connectChannels(ssc, sc1);\n+             var scope1 = scopeSupplier.get();\n+             var scope2 = scopeSupplier.get()) {\n+            var writeBuffers = Stream.of(mixedBuffersOfSize(16, scope1, 64), mixedBuffersOfSize(16, scope2, 64))\n+                                     .flatMap(Arrays::stream)\n+                                     .toArray(ByteBuffer[]::new);\n+            var readBuffers = Stream.of(mixedBuffersOfSize(16, scope1, 64), mixedBuffersOfSize(16, scope2, 64))\n+                                    .flatMap(Arrays::stream)\n+                                    .toArray(ByteBuffer[]::new);\n+\n+            long expectedCount = remaining(writeBuffers);\n+            assertEquals(writeNBytes(sc1, writeBuffers, 0, 32, expectedCount), expectedCount);\n+            assertEquals(readNBytes(sc2, readBuffers, 0, 32, expectedCount), expectedCount);\n+            assertEquals(flip(readBuffers), clear(writeBuffers));\n+        }\n+    }\n+\n+    static SocketChannel connectChannels(ServerSocketChannel ssc, SocketChannel sc)\n+        throws Exception\n+    {\n+        ssc.bind(new InetSocketAddress(InetAddress.getLoopbackAddress(), 0));\n+        sc.connect(ssc.getLocalAddress());\n+        return ssc.accept();\n+    }\n+\n+    static long writeNBytes(SocketChannel channel,\n+                            ByteBuffer[] buffers, int offset, int len,\n+                            long bytes)\n+        throws Exception\n+    {\n+        long total = 0L;\n+        do {\n+            long n = channel.write(buffers, offset, len);\n+            assertTrue(n > 0, \"got:\" + n);\n+            total += n;\n+        } while (total < bytes);\n+        return total;\n+    }\n+\n+    static long readNBytes(SocketChannel channel,\n+                           ByteBuffer[] buffers, int offset, int len,\n+                           long bytes)\n+        throws Exception\n+    {\n+        long total = 0L;\n+        do {\n+            long n = channel.read(buffers, offset, len);\n+            assertTrue(n > 0, \"got:\" + n);\n+            total += n;\n+        } while (total < bytes);\n+        return total;\n+    }\n+}\n+\n","filename":"test\/jdk\/java\/foreign\/channels\/TestSocketChannels.java","additions":238,"deletions":0,"binary":false,"changes":238,"status":"added"},{"patch":"@@ -0,0 +1,119 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+\/**\n+ * @test id=panama_enable_native_access\n+ * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n+ * @build panama_module\/*\n+ * @run main\/othervm --enable-native-access=panama_module panama_module\/org.openjdk.foreigntest.PanamaMain\n+ * @summary with --enable-native-access access to specific module Panama unsafe API succeeds\n+ *\/\n+\n+\/**\n+ * @test id=panama_enable_native_access_reflection\n+ * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n+ * @build panama_module\/*\n+ * @run main\/othervm --enable-native-access=panama_module panama_module\/org.openjdk.foreigntest.PanamaMainReflection\n+ * @summary with --enable-native-access access to specific module Panama unsafe API succeeds\n+ *\/\n+\n+\/**\n+ * @test id=panama_enable_native_access_invoke\n+ * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n+ * @build panama_module\/*\n+ * @run main\/othervm --enable-native-access=panama_module panama_module\/org.openjdk.foreigntest.PanamaMainInvoke\n+ * @summary with --enable-native-access access to specific module Panama unsafe API succeeds\n+ *\/\n+\n+\/**\n+ * @test id=panama_comma_separated_enable\n+ * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n+ * @build panama_module\/*\n+ * @run main\/othervm --enable-native-access=com.acme,panama_module panama_module\/org.openjdk.foreigntest.PanamaMain\n+ * @summary with --enable-native-access access to comma separated list of modules\n+ *\/\n+\n+\/**\n+ * @test id=panama_comma_separated_enable_reflection\n+ * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n+ * @build panama_module\/*\n+ * @run main\/othervm --enable-native-access=com.acme,panama_module panama_module\/org.openjdk.foreigntest.PanamaMainReflection\n+ * @summary with --enable-native-access access to comma separated list of modules\n+ *\/\n+\n+\/**\n+ * @test id=panama_comma_separated_enable_invoke\n+ * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n+ * @build panama_module\/*\n+ * @run main\/othervm --enable-native-access=com.acme,panama_module panama_module\/org.openjdk.foreigntest.PanamaMainInvoke\n+ * @summary with --enable-native-access access to comma separated list of modules\n+ *\/\n+\n+\/**\n+ * @test id=panama_no_enable_native_access_fail\n+ * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n+ * @build panama_module\/*\n+ * @run main\/othervm\/fail panama_module\/org.openjdk.foreigntest.PanamaMain\n+ * @summary without --enable-native-access access to Panama unsafe API fails\n+ *\/\n+\n+\/**\n+ * @test id=panama_no_enable_native_access_fail_reflection\n+ * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n+ * @build panama_module\/*\n+ * @run main\/othervm\/fail panama_module\/org.openjdk.foreigntest.PanamaMainReflection\n+ * @summary without --enable-native-access access to Panama unsafe API fails\n+ *\/\n+\n+\/**\n+ * @test id=panama_no_enable_native_access_fail_invoke\n+ * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n+ * @build panama_module\/*\n+ * @run main\/othervm\/fail panama_module\/org.openjdk.foreigntest.PanamaMainInvoke\n+ * @summary without --enable-native-access access to Panama unsafe API fails\n+ *\/\n+\n+\/**\n+ * @test id=panama_no_all_module_path_blanket_native_access\n+ * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n+ * @build panama_module\/*\n+ * @run main\/othervm\/fail --enable-native-access=ALL-MODULE-PATH panama_module\/org.openjdk.foreigntest.PanamaMain\n+ * @summary --enable-native-access does not work with ALL-MODULE-PATH\n+ *\/\n+\n+\/**\n+ * @test id=panama_no_unnamed_module_native_access\n+ * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n+ * @build org.openjdk.foreigntest.PanamaMainUnnamedModule\n+ * @run testng\/othervm\/fail org.openjdk.foreigntest.PanamaMainUnnamedModule\n+ * @summary --enable-native-access does not work without ALL-UNNAMED\n+ *\/\n+\n+\/**\n+ * @test id=panama_all_unnamed_module_native_access\n+ * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n+ * @build org.openjdk.foreigntest.PanamaMainUnnamedModule\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED org.openjdk.foreigntest.PanamaMainUnnamedModule\n+ * @summary --enable-native-access ALL-UNNAMED works\n+ *\/\n","filename":"test\/jdk\/java\/foreign\/enablenativeaccess\/TestDriver.java","additions":119,"deletions":0,"binary":false,"changes":119,"status":"added"},{"patch":"@@ -0,0 +1,57 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.foreigntest;\n+\n+import jdk.incubator.foreign.*;\n+import org.testng.annotations.Test;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.lang.reflect.Method;\n+\n+public class PanamaMainUnnamedModule {\n+   @Test\n+   public void testReflection() throws Throwable {\n+       Method method = CLinker.class.getDeclaredMethod(\"getInstance\");\n+       method.invoke(null);\n+   }\n+\n+   @Test\n+   public void testSetAccessible() throws Throwable {\n+       Method method = CLinker.class.getDeclaredMethod(\"getInstance\");\n+       method.setAccessible(true);\n+       method.invoke(null);\n+   }\n+\n+   @Test\n+   public void testInvoke() throws Throwable {\n+       var mh = MethodHandles.lookup().findStatic(CLinker.class, \"getInstance\",\n+           MethodType.methodType(CLinker.class));\n+       var linker = (CLinker)mh.invokeExact();\n+   }\n+\n+   @Test\n+   public void testDirectAccess() throws Throwable {\n+       CLinker.getInstance();\n+   }\n+}\n","filename":"test\/jdk\/java\/foreign\/enablenativeaccess\/org\/openjdk\/foreigntest\/PanamaMainUnnamedModule.java","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"},{"patch":"@@ -0,0 +1,27 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+module panama_module {\n+    requires jdk.incubator.foreign;\n+    exports org.openjdk.foreigntest;\n+}\n","filename":"test\/jdk\/java\/foreign\/enablenativeaccess\/panama_module\/module-info.java","additions":27,"deletions":0,"binary":false,"changes":27,"status":"added"},{"patch":"@@ -0,0 +1,34 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.foreigntest;\n+\n+import jdk.incubator.foreign.*;\n+\n+public class PanamaMain {\n+   public static void main(String[] args) {\n+       System.out.println(\"Trying to get CLinker\");\n+       CLinker.getInstance();\n+       System.out.println(\"Got CLinker\");\n+   }\n+}\n","filename":"test\/jdk\/java\/foreign\/enablenativeaccess\/panama_module\/org\/openjdk\/foreigntest\/PanamaMain.java","additions":34,"deletions":0,"binary":false,"changes":34,"status":"added"},{"patch":"@@ -0,0 +1,35 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.foreigntest;\n+\n+import java.lang.invoke.*;\n+import jdk.incubator.foreign.*;\n+\n+public class PanamaMainInvoke {\n+   public static void main(String[] args) throws Throwable {\n+       var mh = MethodHandles.lookup().findStatic(CLinker.class, \"getInstance\",\n+           MethodType.methodType(CLinker.class));\n+       var linker = (CLinker)mh.invokeExact();\n+   }\n+}\n","filename":"test\/jdk\/java\/foreign\/enablenativeaccess\/panama_module\/org\/openjdk\/foreigntest\/PanamaMainInvoke.java","additions":35,"deletions":0,"binary":false,"changes":35,"status":"added"},{"patch":"@@ -0,0 +1,34 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.foreigntest;\n+\n+import jdk.incubator.foreign.*;\n+import java.lang.reflect.Method;\n+\n+public class PanamaMainReflection {\n+   public static void main(String[] args) throws Throwable {\n+       Method method = CLinker.class.getDeclaredMethod(\"getInstance\");\n+       method.invoke(null);\n+   }\n+}\n","filename":"test\/jdk\/java\/foreign\/enablenativeaccess\/panama_module\/org\/openjdk\/foreigntest\/PanamaMainReflection.java","additions":34,"deletions":0,"binary":false,"changes":34,"status":"added"},{"patch":"@@ -0,0 +1,30 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n+ * @build invoker_module\/* lookup_module\/*\n+ * @run testng\/othervm --enable-native-access=invoker_module\n+                       lookup_module\/handle.lookup.MethodHandleLookup\n+ *\/\n","filename":"test\/jdk\/java\/foreign\/handles\/Driver.java","additions":30,"deletions":0,"binary":false,"changes":30,"status":"added"},{"patch":"@@ -0,0 +1,96 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package handle.invoker;\n+\n+import jdk.incubator.foreign.Addressable;\n+import jdk.incubator.foreign.CLinker;\n+import jdk.incubator.foreign.FunctionDescriptor;\n+import jdk.incubator.foreign.LibraryLookup;\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.MemoryLayout;\n+import jdk.incubator.foreign.MemoryLayouts;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.SegmentAllocator;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.nio.charset.Charset;\n+import java.nio.file.Path;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+public class MethodHandleInvoker {\n+    public void call(MethodHandle methodHandle) throws Throwable {\n+        try {\n+            Object[] args = makeArgs(methodHandle.type());\n+            methodHandle.invokeWithArguments(args);\n+            throw new AssertionError(\"Call to restricted method did not fail as expected!\");\n+        } catch (IllegalCallerException ex) {\n+            if (!ex.getMessage().contains(\"lookup_module\")) {\n+                throw new AssertionError(\"Caller module is not lookup_module!\");\n+            }\n+        } catch (Throwable ex) {\n+            throw new AssertionError(\"Call to restricted method did not fail as expected!\");\n+        }\n+    }\n+\n+    static final Map<Class<?>, Object> DEFAULT_VALUES = new HashMap<>();\n+\n+    static <Z> void addDefaultMapping(Class<Z> carrier, Z value) {\n+        DEFAULT_VALUES.put(carrier, value);\n+    }\n+\n+    static {\n+        addDefaultMapping(CLinker.class, CLinker.getInstance());\n+        addDefaultMapping(long.class, 0L);\n+        addDefaultMapping(Path.class, Path.of(\"nonExistent\"));\n+        addDefaultMapping(String.class, \"Hello!\");\n+        addDefaultMapping(Runnable.class, () -> {});\n+        addDefaultMapping(MethodHandle.class, MethodHandles.identity(int.class));\n+        addDefaultMapping(Charset.class, Charset.defaultCharset());\n+        addDefaultMapping(MethodType.class, MethodType.methodType(void.class));\n+        addDefaultMapping(MemoryAddress.class, MemoryAddress.NULL);\n+        addDefaultMapping(Addressable.class, MemoryAddress.NULL);\n+        addDefaultMapping(MemoryLayout.class, MemoryLayouts.JAVA_INT);\n+        addDefaultMapping(FunctionDescriptor.class, FunctionDescriptor.ofVoid());\n+        addDefaultMapping(LibraryLookup.class, LibraryLookup.ofDefault());\n+        addDefaultMapping(ResourceScope.class, ResourceScope.newImplicitScope());\n+        addDefaultMapping(SegmentAllocator.class, (size, align) -> null);\n+    }\n+\n+    static Object[] makeArgs(MethodType type) {\n+        return type.parameterList().stream()\n+                .map(MethodHandleInvoker::makeArg)\n+                .toArray();\n+    }\n+\n+    static Object makeArg(Class<?> clazz) {\n+        Object value = DEFAULT_VALUES.get(clazz);\n+        if (value == null) {\n+            throw new UnsupportedOperationException(clazz.getName());\n+        }\n+        return value;\n+    }\n+}\n","filename":"test\/jdk\/java\/foreign\/handles\/invoker_module\/handle\/invoker\/MethodHandleInvoker.java","additions":96,"deletions":0,"binary":false,"changes":96,"status":"added"},{"patch":"@@ -0,0 +1,27 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+module invoker_module {\n+    requires jdk.incubator.foreign;\n+    exports handle.invoker;\n+}\n","filename":"test\/jdk\/java\/foreign\/handles\/invoker_module\/module-info.java","additions":27,"deletions":0,"binary":false,"changes":27,"status":"added"},{"patch":"@@ -0,0 +1,100 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package handle.lookup;\n+\n+import jdk.incubator.foreign.Addressable;\n+import jdk.incubator.foreign.CLinker;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.nio.charset.Charset;\n+import java.nio.file.Path;\n+import java.util.Optional;\n+\n+import jdk.incubator.foreign.FunctionDescriptor;\n+import jdk.incubator.foreign.LibraryLookup;\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.MemoryLayout;\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.SegmentAllocator;\n+\n+import org.testng.annotations.*;\n+\n+public class MethodHandleLookup {\n+\n+    @Test(dataProvider = \"restrictedMethods\")\n+    public void testRestrictedHandles(MethodHandle handle, String testName) throws Throwable {\n+        new handle.invoker.MethodHandleInvoker().call(handle);\n+    }\n+\n+    @DataProvider(name = \"restrictedMethods\")\n+    static Object[][] restrictedMethods() {\n+        try {\n+            return new Object[][]{\n+                    { MethodHandles.lookup().findStatic(CLinker.class, \"getInstance\",\n+                            MethodType.methodType(CLinker.class)), \"CLinker::getInstance\" },\n+                    { MethodHandles.lookup().findStatic(CLinker.class, \"toJavaString\",\n+                            MethodType.methodType(String.class, MemoryAddress.class)),\n+                            \"CLinker::toJavaString\/1\" },\n+                    { MethodHandles.lookup().findStatic(CLinker.class, \"toJavaString\",\n+                            MethodType.methodType(String.class, MemoryAddress.class, Charset.class)),\n+                            \"CLinker::toJavaString\/2\" },\n+                    { MethodHandles.lookup().findStatic(CLinker.class, \"allocateMemory\",\n+                            MethodType.methodType(MemoryAddress.class, long.class)),\n+                            \"CLinker::allocateMemory\" },\n+                    { MethodHandles.lookup().findStatic(CLinker.class, \"freeMemory\",\n+                            MethodType.methodType(void.class, MemoryAddress.class)),\n+                            \"CLinker::freeMemory\" },\n+                    { MethodHandles.lookup().findStatic(CLinker.VaList.class, \"ofAddress\",\n+                            MethodType.methodType(CLinker.VaList.class, MemoryAddress.class)),\n+                            \"VaList::ofAddress\/1\" },\n+                    { MethodHandles.lookup().findStatic(CLinker.VaList.class, \"ofAddress\",\n+                            MethodType.methodType(CLinker.VaList.class, MemoryAddress.class, ResourceScope.class)),\n+                            \"VaList::ofAddress\/2\" },\n+                    { MethodHandles.lookup().findStatic(LibraryLookup.class, \"ofPath\",\n+                            MethodType.methodType(LibraryLookup.class, Path.class)),\n+                            \"LibraryLookup::ofPath\" },\n+                    { MethodHandles.lookup().findStatic(LibraryLookup.class, \"ofLibrary\",\n+                            MethodType.methodType(LibraryLookup.class, String.class)),\n+                            \"LibraryLookup::ofLibrary\" },\n+                    { MethodHandles.lookup().findStatic(LibraryLookup.class, \"ofDefault\",\n+                            MethodType.methodType(LibraryLookup.class)),\n+                            \"LibraryLookup::ofDefault\" },\n+                    { MethodHandles.lookup().findVirtual(MemoryAddress.class, \"asSegment\",\n+                            MethodType.methodType(MemorySegment.class, long.class, ResourceScope.class)),\n+                            \"MemoryAddress::asSegment\/1\" },\n+                    { MethodHandles.lookup().findVirtual(MemoryAddress.class, \"asSegment\",\n+                            MethodType.methodType(MemorySegment.class, long.class, Runnable.class, ResourceScope.class)),\n+                            \"MemoryAddress::asSegment\/2\" },\n+                    { MethodHandles.lookup().findStatic(MemorySegment.class, \"globalNativeSegment\",\n+                            MethodType.methodType(MemorySegment.class)),\n+                            \"MemoryAddress::globalNativeSegment\" }\n+            };\n+        } catch (Throwable ex) {\n+            throw new ExceptionInInitializerError((ex));\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/foreign\/handles\/lookup_module\/handle\/lookup\/MethodHandleLookup.java","additions":100,"deletions":0,"binary":false,"changes":100,"status":"added"},{"patch":"@@ -0,0 +1,29 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+open module lookup_module {\n+    requires testng;\n+    requires jdk.incubator.foreign;\n+    requires invoker_module;\n+    exports handle.lookup;\n+}\n","filename":"test\/jdk\/java\/foreign\/handles\/lookup_module\/module-info.java","additions":29,"deletions":0,"binary":false,"changes":29,"status":"added"},{"patch":"@@ -32,0 +32,1 @@\n+ EXPORT int c = 42;\n","filename":"test\/jdk\/java\/foreign\/libLookupTest.c","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,38 @@\n+\/*\n+ *  Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+#ifdef _WIN64\n+#define EXPORT __declspec(dllexport)\n+#else\n+#define EXPORT\n+#endif\n+\n+struct Point {\n+    int x;\n+    int y;\n+};\n+\n+EXPORT void struct_func(struct Point p) { }\n+\n+EXPORT void addr_func(struct Point* p) { }\n","filename":"test\/jdk\/java\/foreign\/libSafeAccess.c","additions":38,"deletions":0,"binary":false,"changes":38,"status":"added"},{"patch":"@@ -30,3 +30,1 @@\n-EXPORT void blank(void (*cb)(void)) {\n-    cb();\n-}\n+struct S_PDI { void* p0; double p1; int p2; };\n@@ -34,2 +32,2 @@\n-EXPORT int identity(int x, int (*cb)(int)) {\n-    return cb(x);\n+EXPORT void do_upcall(void (*cb)(struct S_PDI), struct S_PDI a0) {\n+    cb(a0);\n","filename":"test\/jdk\/java\/foreign\/libTestUpcallStructScope.c","additions":3,"deletions":5,"binary":false,"changes":8,"previous_filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/libUpcalls.c","status":"copied"},{"patch":"@@ -36,1 +36,1 @@\n- *   -Dforeign.restricted=permit\n+ *   --enable-native-access=ALL-UNNAMED\n@@ -45,1 +45,1 @@\n- *   -Dforeign.restricted=permit\n+ *   --enable-native-access=ALL-UNNAMED\n@@ -60,0 +60,1 @@\n+import jdk.incubator.foreign.ResourceScope;\n@@ -89,1 +90,2 @@\n-        try (MemorySegment stub = linker.upcallStub(MH_m, FunctionDescriptor.ofVoid())) {\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            MemoryAddress stub = linker.upcallStub(MH_m, FunctionDescriptor.ofVoid(), scope);\n@@ -108,1 +110,2 @@\n-            WB.verifyFrames(true);\n+            WB.verifyFrames(\/*log=*\/true, \/*updateRegisterMap=*\/true);\n+            WB.verifyFrames(\/*log=*\/true, \/*updateRegisterMap=*\/false); \/\/ triggers different code paths\n","filename":"test\/jdk\/java\/foreign\/stackwalk\/TestStackWalk.java","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ * @library ..\/\n@@ -33,1 +34,1 @@\n- * @run testng\/othervm -Dforeign.restricted=permit VaListTest\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED VaListTest\n@@ -38,1 +39,0 @@\n-import jdk.internal.foreign.abi.SharedUtils;\n@@ -50,3 +50,0 @@\n-import java.lang.reflect.InvocationTargetException;\n-import java.lang.reflect.Method;\n-import java.util.Arrays;\n@@ -70,1 +67,1 @@\n-public class VaListTest {\n+public class VaListTest extends NativeTestHelper {\n@@ -112,1 +109,1 @@\n-            = actions -> Windowsx64Linker.newVaList(actions, MemorySegment::allocateNative);\n+            = actions -> Windowsx64Linker.newVaList(actions, ResourceScope.newConfinedScope());\n@@ -114,1 +111,1 @@\n-            = actions -> SysVx64Linker.newVaList(actions, MemorySegment::allocateNative);\n+            = actions -> SysVx64Linker.newVaList(actions, ResourceScope.newConfinedScope());\n@@ -116,1 +113,1 @@\n-            = actions -> AArch64Linker.newVaList(actions, MemorySegment::allocateNative);\n+            = actions -> AArch64Linker.newVaList(actions, ResourceScope.newConfinedScope());\n@@ -118,1 +115,1 @@\n-            = VaList::make;\n+            = (builder) -> VaList.make(builder, ResourceScope.newConfinedScope());\n@@ -121,1 +118,1 @@\n-            = (actions, scope) -> Windowsx64Linker.newVaList(actions, SharedUtils.Allocator.ofScope(scope));\n+            = (builder, scope) -> Windowsx64Linker.newVaList(builder, scope.scope());\n@@ -123,1 +120,1 @@\n-            = (actions, scope) -> SysVx64Linker.newVaList(actions, SharedUtils.Allocator.ofScope(scope));\n+            = (builder, scope) -> SysVx64Linker.newVaList(builder, scope.scope());\n@@ -125,1 +122,1 @@\n-            = (actions, scope) -> AArch64Linker.newVaList(actions, SharedUtils.Allocator.ofScope(scope));\n+            = (builder, scope) -> AArch64Linker.newVaList(builder, scope.scope());\n@@ -127,1 +124,1 @@\n-            = VaList::make;\n+            = (builder, scope) -> VaList.make(builder, scope.scope());\n@@ -148,7 +145,7 @@\n-        try (VaList vaList = vaListFactory.apply(b ->\n-                b.vargFromInt(intLayout, 10)\n-                        .vargFromInt(intLayout, 15)\n-                        .vargFromInt(intLayout, 20))) {\n-            int x = sumInts.apply(3, vaList);\n-            assertEquals(x, 45);\n-        }\n+        VaList vaList = vaListFactory.apply(b ->\n+            b.vargFromInt(intLayout, 10)\n+                    .vargFromInt(intLayout, 15)\n+                    .vargFromInt(intLayout, 20));\n+        int x = sumInts.apply(3, vaList);\n+        assertEquals(x, 45);\n+        vaList.scope().close();\n@@ -176,7 +173,7 @@\n-        try (VaList vaList = vaListFactory.apply(b ->\n-                b.vargFromDouble(doubleLayout, 3.0D)\n-                        .vargFromDouble(doubleLayout, 4.0D)\n-                        .vargFromDouble(doubleLayout, 5.0D))) {\n-            double x = sumDoubles.apply(3, vaList);\n-            assertEquals(x, 12.0D);\n-        }\n+        VaList vaList = vaListFactory.apply(b ->\n+            b.vargFromDouble(doubleLayout, 3.0D)\n+                    .vargFromDouble(doubleLayout, 4.0D)\n+                    .vargFromDouble(doubleLayout, 5.0D));\n+        double x = sumDoubles.apply(3, vaList);\n+        assertEquals(x, 12.0D);\n+        vaList.scope().close();\n@@ -191,1 +188,1 @@\n-                    return MemoryAccess.getIntAtOffset(MemorySegment.ofNativeRestricted(), ma.toRawLongValue());\n+                    return MemoryAccess.getIntAtOffset(MemorySegment.globalNativeSegment(), ma.toRawLongValue());\n@@ -206,1 +203,2 @@\n-        try (MemorySegment msInt = MemorySegment.allocateNative(JAVA_INT)) {\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            MemorySegment msInt = MemorySegment.allocateNative(JAVA_INT, scope);\n@@ -208,4 +206,4 @@\n-            try (VaList vaList = vaListFactory.apply(b -> b.vargFromAddress(pointerLayout, msInt.address()))) {\n-                int x = getFromPointer.apply(vaList);\n-                assertEquals(x, 10);\n-            }\n+            VaList vaList = vaListFactory.apply(b -> b.vargFromAddress(pointerLayout, msInt.address()));\n+            int x = getFromPointer.apply(vaList);\n+            assertEquals(x, 10);\n+            vaList.scope().close();\n@@ -225,1 +223,1 @@\n-                    MemorySegment struct = list.vargAsSegment(pointLayout);\n+                    MemorySegment struct = list.vargAsSegment(pointLayout, ResourceScope.newImplicitScope());\n@@ -238,1 +236,1 @@\n-            GroupLayout pointLayout =  MemoryLayout.ofStruct(\n+            GroupLayout pointLayout =  MemoryLayout.structLayout(\n@@ -259,1 +257,2 @@\n-        try (MemorySegment struct = MemorySegment.allocateNative(Point_LAYOUT)) {\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            MemorySegment struct = MemorySegment.allocateNative(Point_LAYOUT, scope);\n@@ -263,4 +262,4 @@\n-            try (VaList vaList = vaListFactory.apply(b -> b.vargFromSegment(Point_LAYOUT, struct))) {\n-                int sum = sumStruct.apply(vaList);\n-                assertEquals(sum, 15);\n-            }\n+            VaList vaList = vaListFactory.apply(b -> b.vargFromSegment(Point_LAYOUT, struct));\n+            int sum = sumStruct.apply(vaList);\n+            assertEquals(sum, 15);\n+            vaList.scope().close();\n@@ -276,1 +275,1 @@\n-                    MemorySegment struct = list.vargAsSegment(BigPoint_LAYOUT);\n+                    MemorySegment struct = list.vargAsSegment(BigPoint_LAYOUT, ResourceScope.newImplicitScope());\n@@ -289,1 +288,1 @@\n-            GroupLayout BigPoint_LAYOUT =  MemoryLayout.ofStruct(\n+            GroupLayout BigPoint_LAYOUT =  MemoryLayout.structLayout(\n@@ -310,1 +309,2 @@\n-        try (MemorySegment struct = MemorySegment.allocateNative(BigPoint_LAYOUT)) {\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            MemorySegment struct = MemorySegment.allocateNative(BigPoint_LAYOUT, scope);\n@@ -314,4 +314,4 @@\n-            try (VaList vaList = vaListFactory.apply(b -> b.vargFromSegment(BigPoint_LAYOUT, struct))) {\n-                long sum = sumBigStruct.apply(vaList);\n-                assertEquals(sum, 15);\n-            }\n+            VaList vaList = vaListFactory.apply(b -> b.vargFromSegment(BigPoint_LAYOUT, struct));\n+            long sum = sumBigStruct.apply(vaList);\n+            assertEquals(sum, 15);\n+            vaList.scope().close();\n@@ -327,1 +327,1 @@\n-                    MemorySegment struct = list.vargAsSegment(FloatPoint_LAYOUT);\n+                    MemorySegment struct = list.vargAsSegment(FloatPoint_LAYOUT, ResourceScope.newImplicitScope());\n@@ -340,1 +340,1 @@\n-            GroupLayout FloatPoint_LAYOUT = MemoryLayout.ofStruct(\n+            GroupLayout FloatPoint_LAYOUT = MemoryLayout.structLayout(\n@@ -362,1 +362,2 @@\n-        try (MemorySegment struct = MemorySegment.allocateNative(FloatPoint_LAYOUT)) {\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            MemorySegment struct = MemorySegment.allocateNative(FloatPoint_LAYOUT, scope);\n@@ -366,4 +367,4 @@\n-            try (VaList vaList = vaListFactory.apply(b -> b.vargFromSegment(FloatPoint_LAYOUT, struct))) {\n-                float sum = sumFloatStruct.apply(vaList);\n-                assertEquals(sum, 4.376f, 0.00001f);\n-            }\n+            VaList vaList = vaListFactory.apply(b -> b.vargFromSegment(FloatPoint_LAYOUT, struct));\n+            float sum = sumFloatStruct.apply(vaList);\n+            assertEquals(sum, 4.376f, 0.00001f);\n+            vaList.scope().close();\n@@ -383,1 +384,1 @@\n-                    MemorySegment struct = list.vargAsSegment(HugePoint_LAYOUT);\n+                    MemorySegment struct = list.vargAsSegment(HugePoint_LAYOUT, ResourceScope.newImplicitScope());\n@@ -397,1 +398,1 @@\n-            GroupLayout HugePoint_LAYOUT = MemoryLayout.ofStruct(\n+            GroupLayout HugePoint_LAYOUT = MemoryLayout.structLayout(\n@@ -424,1 +425,2 @@\n-        try (MemorySegment struct = MemorySegment.allocateNative(HugePoint_LAYOUT)) {\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            MemorySegment struct = MemorySegment.allocateNative(HugePoint_LAYOUT, scope);\n@@ -429,4 +431,4 @@\n-            try (VaList vaList = vaListFactory.apply(b -> b.vargFromSegment(HugePoint_LAYOUT, struct))) {\n-                long sum = sumHugeStruct.apply(vaList);\n-                assertEquals(sum, 6);\n-            }\n+            VaList vaList = vaListFactory.apply(b -> b.vargFromSegment(HugePoint_LAYOUT, struct));\n+            long sum = sumHugeStruct.apply(vaList);\n+            assertEquals(sum, 6);\n+            vaList.scope().close();\n@@ -466,1 +468,1 @@\n-                { platformVaListFactory, sumStackNative, C_LONG_LONG,         C_DOUBLE         },\n+                { platformVaListFactory, sumStackNative,                                                C_LONG_LONG,         C_DOUBLE         },\n@@ -475,2 +477,3 @@\n-        try (MemorySegment longSum = MemorySegment.allocateNative(longLayout);\n-             MemorySegment doubleSum = MemorySegment.allocateNative(doubleLayout)) {\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            MemorySegment longSum = MemorySegment.allocateNative(longLayout, scope);\n+            MemorySegment doubleSum = MemorySegment.allocateNative(doubleLayout, scope);\n@@ -489,1 +492,1 @@\n-            try (list) {\n+            try {\n@@ -491,0 +494,2 @@\n+            } finally {\n+                list.scope().close();\n@@ -504,1 +509,2 @@\n-        try (MemorySegment stub = abi.upcallStub(callback, desc)) {\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            MemoryAddress stub = abi.upcallStub(callback, desc, scope);\n@@ -522,1 +528,1 @@\n-            expectedExceptionsMessageRegExp = \".*Empty VaList.*\",\n+            expectedExceptionsMessageRegExp = \".*Scope cannot be closed.*\",\n@@ -525,1 +531,1 @@\n-        emptyList.close();\n+        emptyList.scope().close();\n@@ -548,1 +554,1 @@\n-        try (NativeScope scope = NativeScope.unboundedScope()) {\n+        try (NativeScope scope = new NativeScope()) {\n@@ -556,1 +562,1 @@\n-        assertFalse(listLeaked.isAlive());\n+        assertFalse(listLeaked.scope().isAlive());\n@@ -564,2 +570,3 @@\n-        try (NativeScope scope = NativeScope.unboundedScope()) {\n-            try (MemorySegment pointIn = MemorySegment.allocateNative(Point_LAYOUT)) {\n+        try (NativeScope scope = new NativeScope()) {\n+            try (ResourceScope innerScope = ResourceScope.newConfinedScope()) {\n+                MemorySegment pointIn = MemorySegment.allocateNative(Point_LAYOUT, innerScope);\n@@ -568,6 +575,6 @@\n-                try (VaList list = vaListFactory.apply(b -> b.vargFromSegment(Point_LAYOUT, pointIn))) {\n-                    pointOut = list.vargAsSegment(Point_LAYOUT, scope);\n-                    assertEquals((int) VH_Point_x.get(pointOut), 3);\n-                    assertEquals((int) VH_Point_y.get(pointOut), 6);\n-                }\n-                assertTrue(pointOut.isAlive()); \/\/ after VaList freed\n+                VaList list = vaListFactory.apply(b -> b.vargFromSegment(Point_LAYOUT, pointIn));\n+                pointOut = list.vargAsSegment(Point_LAYOUT, scope);\n+                assertEquals((int) VH_Point_x.get(pointOut), 3);\n+                assertEquals((int) VH_Point_y.get(pointOut), 6);\n+                list.scope().close();\n+                assertTrue(pointOut.scope().isAlive()); \/\/ after VaList freed\n@@ -575,1 +582,1 @@\n-            assertTrue(pointOut.isAlive()); \/\/ after input MS freed\n+            assertTrue(pointOut.scope().isAlive()); \/\/ after inner scope freed\n@@ -577,1 +584,1 @@\n-        assertFalse(pointOut.isAlive()); \/\/ after scope freed\n+        assertFalse(pointOut.scope().isAlive()); \/\/ after outer scope freed\n@@ -591,13 +598,5 @@\n-        try (VaList list = vaListFactory.apply(b -> b.vargFromInt(intLayout, 4)\n-                .vargFromInt(intLayout, 8))) {\n-            VaList  copy = list.copy();\n-            assertEquals(copy.vargAsInt(intLayout), 4);\n-            assertEquals(copy.vargAsInt(intLayout), 8);\n-            copy.close();\n-\n-            assertFalse(copy.isAlive());\n-\n-            assertEquals(list.vargAsInt(intLayout), 4);\n-            assertEquals(list.vargAsInt(intLayout), 8);\n-        }\n-    }\n+        VaList list = vaListFactory.apply(b -> b.vargFromInt(intLayout, 4)\n+                .vargFromInt(intLayout, 8));\n+        VaList  copy = list.copy();\n+        assertEquals(copy.vargAsInt(intLayout), 4);\n+        assertEquals(copy.vargAsInt(intLayout), 8);\n@@ -605,12 +604,6 @@\n-    @Test(dataProvider = \"copy\")\n-    public void testScopedCopy(Function<Consumer<VaList.Builder>, VaList> vaListFactory, ValueLayout intLayout) {\n-        try (VaList list = vaListFactory.apply(b -> b.vargFromInt(intLayout, 4)\n-                .vargFromInt(intLayout, 8))) {\n-            VaList copy;\n-            try (NativeScope scope = NativeScope.unboundedScope()) {\n-                copy = list.copy(scope);\n-\n-                assertEquals(copy.vargAsInt(intLayout), 4);\n-                assertEquals(copy.vargAsInt(intLayout), 8);\n-            }\n-            assertFalse(copy.isAlive());\n+\/\/        try { \/\/ this logic only works on Windows!\n+\/\/            int x = copy.vargAsInt(intLayout);\n+\/\/            fail();\n+\/\/        } catch (IndexOutOfBoundsException ex) {\n+\/\/            \/\/ ok - we exhausted the list\n+\/\/        }\n@@ -618,3 +611,3 @@\n-            assertEquals(list.vargAsInt(intLayout), 4);\n-            assertEquals(list.vargAsInt(intLayout), 8);\n-        }\n+        assertEquals(list.vargAsInt(intLayout), 4);\n+        assertEquals(list.vargAsInt(intLayout), 8);\n+        list.scope().close();\n@@ -629,2 +622,2 @@\n-        try (VaList copy = list.copy()) {\n-            list.close();\n+        VaList copy = list.copy();\n+        list.scope().close();\n@@ -632,16 +625,1 @@\n-            copy.vargAsInt(intLayout); \/\/ should throw\n-        }\n-    }\n-\n-    @Test(dataProvider = \"copy\",\n-            expectedExceptions = IllegalStateException.class)\n-    public void testCopyUnusableAfterOriginalClosedScope(Function<Consumer<VaList.Builder>, VaList> vaListFactory,\n-                                                         ValueLayout intLayout) {\n-        VaList list = vaListFactory.apply(b -> b.vargFromInt(intLayout, 4)\n-                .vargFromInt(intLayout, 8));\n-        try (NativeScope scope = NativeScope.unboundedScope()) {\n-            VaList copy = list.copy(scope);\n-            list.close();\n-\n-            copy.vargAsInt(intLayout); \/\/ should throw\n-        }\n+        copy.vargAsInt(intLayout); \/\/ should throw\n@@ -652,1 +630,1 @@\n-        GroupLayout BigPoint_LAYOUT = MemoryLayout.ofStruct(\n+        GroupLayout BigPoint_LAYOUT = MemoryLayout.structLayout(\n@@ -658,1 +636,1 @@\n-        GroupLayout Point_LAYOUT = MemoryLayout.ofStruct(\n+        GroupLayout Point_LAYOUT = MemoryLayout.structLayout(\n@@ -664,1 +642,1 @@\n-        GroupLayout FloatPoint_LAYOUT = MemoryLayout.ofStruct(\n+        GroupLayout FloatPoint_LAYOUT = MemoryLayout.structLayout(\n@@ -670,1 +648,1 @@\n-        GroupLayout HugePoint_LAYOUT = MemoryLayout.ofStruct(\n+        GroupLayout HugePoint_LAYOUT = MemoryLayout.structLayout(\n@@ -681,4 +659,3 @@\n-                    try (MemorySegment struct = vaList.vargAsSegment(BigPoint_LAYOUT)) {\n-                        assertEquals((long) VH_BigPoint_x.get(struct), 8);\n-                        assertEquals((long) VH_BigPoint_y.get(struct), 16);\n-                    }\n+                    MemorySegment struct = vaList.vargAsSegment(BigPoint_LAYOUT, ResourceScope.newImplicitScope());\n+                    assertEquals((long) VH_BigPoint_x.get(struct), 8);\n+                    assertEquals((long) VH_BigPoint_y.get(struct), 16);\n@@ -688,3 +665,3 @@\n-                    try (MemorySegment struct = vaList.vargAsSegment(BigPoint_LAYOUT)) {\n-                        assertEquals((long) VH_BigPoint_x.get(struct), 8);\n-                        assertEquals((long) VH_BigPoint_y.get(struct), 16);\n+                    MemorySegment struct = vaList.vargAsSegment(BigPoint_LAYOUT, ResourceScope.newImplicitScope());\n+                    assertEquals((long) VH_BigPoint_x.get(struct), 8);\n+                    assertEquals((long) VH_BigPoint_y.get(struct), 16);\n@@ -692,3 +669,2 @@\n-                        VH_BigPoint_x.set(struct, 0);\n-                        VH_BigPoint_y.set(struct, 0);\n-                    }\n+                    VH_BigPoint_x.set(struct, 0);\n+                    VH_BigPoint_y.set(struct, 0);\n@@ -697,4 +673,3 @@\n-                    try (MemorySegment struct = copy.vargAsSegment(BigPoint_LAYOUT)) {\n-                        assertEquals((long) VH_BigPoint_x.get(struct), 8);\n-                        assertEquals((long) VH_BigPoint_y.get(struct), 16);\n-                    }\n+                    struct = copy.vargAsSegment(BigPoint_LAYOUT, ResourceScope.newImplicitScope());\n+                    assertEquals((long) VH_BigPoint_x.get(struct), 8);\n+                    assertEquals((long) VH_BigPoint_y.get(struct), 16);\n@@ -703,4 +678,3 @@\n-                    try (MemorySegment struct = vaList.vargAsSegment(Point_LAYOUT)) {\n-                        assertEquals((int) VH_Point_x.get(struct), 5);\n-                        assertEquals((int) VH_Point_y.get(struct), 10);\n-                    }\n+                    MemorySegment struct = vaList.vargAsSegment(Point_LAYOUT, ResourceScope.newImplicitScope());\n+                    assertEquals((int) VH_Point_x.get(struct), 5);\n+                    assertEquals((int) VH_Point_y.get(struct), 10);\n@@ -709,5 +683,4 @@\n-                    try (MemorySegment struct = vaList.vargAsSegment(HugePoint_LAYOUT)) {\n-                        assertEquals((long) VH_HugePoint_x.get(struct), 1);\n-                        assertEquals((long) VH_HugePoint_y.get(struct), 2);\n-                        assertEquals((long) VH_HugePoint_z.get(struct), 3);\n-                    }\n+                    MemorySegment struct = vaList.vargAsSegment(HugePoint_LAYOUT, ResourceScope.newImplicitScope());\n+                    assertEquals((long) VH_HugePoint_x.get(struct), 1);\n+                    assertEquals((long) VH_HugePoint_y.get(struct), 2);\n+                    assertEquals((long) VH_HugePoint_z.get(struct), 3);\n@@ -716,4 +689,3 @@\n-                    try (MemorySegment struct = vaList.vargAsSegment(FloatPoint_LAYOUT)) {\n-                        assertEquals((float) VH_FloatPoint_x.get(struct), 1.0f);\n-                        assertEquals((float) VH_FloatPoint_y.get(struct), 2.0f);\n-                    }\n+                    MemorySegment struct = vaList.vargAsSegment(FloatPoint_LAYOUT, ResourceScope.newImplicitScope());\n+                    assertEquals((float) VH_FloatPoint_x.get(struct), 1.0f);\n+                    assertEquals((float) VH_FloatPoint_y.get(struct), 2.0f);\n@@ -723,1 +695,1 @@\n-                    MemorySegment ms = intPtr.asSegmentRestricted(C_INT.byteSize());\n+                    MemorySegment ms = intPtr.asSegment(C_INT.byteSize(), ResourceScope.globalScope());\n@@ -762,4 +734,3 @@\n-                    try (MemorySegment point = vaList.vargAsSegment(Point_LAYOUT)) {\n-                        assertEquals((int) VH_Point_x.get(point), 5);\n-                        assertEquals((int) VH_Point_y.get(point), 10);\n-                    }\n+                    MemorySegment point = vaList.vargAsSegment(Point_LAYOUT, ResourceScope.newImplicitScope());\n+                    assertEquals((int) VH_Point_x.get(point), 5);\n+                    assertEquals((int) VH_Point_y.get(point), 10);\n@@ -768,3 +739,3 @@\n-                    try (MemorySegment bigPoint = vaList.vargAsSegment(BigPoint_LAYOUT)) {\n-                        assertEquals((long) VH_BigPoint_x.get(bigPoint), 15);\n-                        assertEquals((long) VH_BigPoint_y.get(bigPoint), 20);\n+                    MemorySegment bigPoint = vaList.vargAsSegment(BigPoint_LAYOUT, ResourceScope.newImplicitScope());\n+                    assertEquals((long) VH_BigPoint_x.get(bigPoint), 15);\n+                    assertEquals((long) VH_BigPoint_y.get(bigPoint), 20);\n@@ -772,3 +743,2 @@\n-                        VH_BigPoint_x.set(bigPoint, 0);\n-                        VH_BigPoint_y.set(bigPoint, 0);\n-                    }\n+                    VH_BigPoint_x.set(bigPoint, 0);\n+                    VH_BigPoint_y.set(bigPoint, 0);\n@@ -777,4 +747,3 @@\n-                    try (MemorySegment struct = copy.vargAsSegment(BigPoint_LAYOUT)) {\n-                        assertEquals((long) VH_BigPoint_x.get(struct), 15);\n-                        assertEquals((long) VH_BigPoint_y.get(struct), 20);\n-                    }\n+                    MemorySegment struct = copy.vargAsSegment(BigPoint_LAYOUT, ResourceScope.newImplicitScope());\n+                    assertEquals((long) VH_BigPoint_x.get(struct), 15);\n+                    assertEquals((long) VH_BigPoint_y.get(struct), 20);\n","filename":"test\/jdk\/java\/foreign\/valist\/VaListTest.java","additions":142,"deletions":173,"binary":false,"changes":315,"status":"modified"},{"patch":"@@ -0,0 +1,73 @@\n+\/*\n+ *  Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @requires os.arch==\"amd64\" | os.arch==\"x86_64\" | os.arch==\"aarch64\"\n+ * @run testng\/othervm\n+ *   --enable-native-access=ALL-UNNAMED\n+ *   TestVirtualCalls\n+ *\/\n+\n+import jdk.incubator.foreign.Addressable;\n+import jdk.incubator.foreign.CLinker;\n+import jdk.incubator.foreign.FunctionDescriptor;\n+import jdk.incubator.foreign.LibraryLookup;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodType;\n+\n+import jdk.incubator.foreign.MemoryAddress;\n+import org.testng.annotations.*;\n+\n+import static jdk.incubator.foreign.CLinker.*;\n+import static org.testng.Assert.assertEquals;\n+\n+public class TestVirtualCalls {\n+\n+    static final CLinker abi = CLinker.getInstance();\n+    static final LibraryLookup lookup = LibraryLookup.ofLibrary(\"Virtual\");\n+\n+    static final MethodHandle func;\n+    static final MemoryAddress funcA;\n+    static final MemoryAddress funcB;\n+    static final MemoryAddress funcC;\n+\n+    static {\n+        func = abi.downcallHandle(\n+            MethodType.methodType(int.class),\n+            FunctionDescriptor.of(C_INT));\n+\n+        funcA = lookup.lookup(\"funcA\").orElseThrow();\n+        funcB = lookup.lookup(\"funcB\").orElseThrow();\n+        funcC = lookup.lookup(\"funcC\").orElseThrow();\n+    }\n+\n+    @Test\n+    public void testVirtualCalls() throws Throwable {\n+        assertEquals((int) func.invokeExact((Addressable) funcA), 1);\n+        assertEquals((int) func.invokeExact((Addressable) funcB), 2);\n+        assertEquals((int) func.invokeExact((Addressable) funcC), 3);\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/foreign\/virtual\/TestVirtualCalls.java","additions":73,"deletions":0,"binary":false,"changes":73,"status":"added"},{"patch":"@@ -0,0 +1,41 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+#ifdef _WIN64\n+#define EXPORT __declspec(dllexport)\n+#else\n+#define EXPORT\n+#endif\n+\n+EXPORT int funcA() {\n+    return 1;\n+}\n+\n+EXPORT int funcB() {\n+    return 2;\n+}\n+\n+EXPORT int funcC() {\n+    return 3;\n+}\n","filename":"test\/jdk\/java\/foreign\/virtual\/libVirtual.c","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"},{"patch":"@@ -51,0 +51,1 @@\n+import jdk.incubator.foreign.ResourceScope;\n@@ -173,2 +174,2 @@\n-        try (MemorySegment seg = MemorySegment.allocateNative(8)) {\n-\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            MemorySegment seg = MemorySegment.allocateNative(8, scope);\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/VarHandleTestExact.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -135,7 +135,7 @@\n-            { \"bytes\", MemoryLayout.ofSequence(1024, MemoryLayouts.JAVA_BYTE), (SpliteratorTestHelper.ContentAsserter<MemorySegment>)SegmentTestDataProvider::compareSegmentsByte },\n-            { \"chars\", MemoryLayout.ofSequence(1024, MemoryLayouts.JAVA_CHAR), (SpliteratorTestHelper.ContentAsserter<MemorySegment>)SegmentTestDataProvider::compareSegmentsChar },\n-            { \"shorts\", MemoryLayout.ofSequence(1024, MemoryLayouts.JAVA_SHORT), (SpliteratorTestHelper.ContentAsserter<MemorySegment>)SegmentTestDataProvider::compareSegmentsShort },\n-            { \"ints\", MemoryLayout.ofSequence(1024, MemoryLayouts.JAVA_INT), (SpliteratorTestHelper.ContentAsserter<MemorySegment>)SegmentTestDataProvider::compareSegmentsInt },\n-            { \"longs\", MemoryLayout.ofSequence(1024, MemoryLayouts.JAVA_LONG), (SpliteratorTestHelper.ContentAsserter<MemorySegment>)SegmentTestDataProvider::compareSegmentsLong },\n-            { \"floats\", MemoryLayout.ofSequence(1024, MemoryLayouts.JAVA_FLOAT), (SpliteratorTestHelper.ContentAsserter<MemorySegment>)SegmentTestDataProvider::compareSegmentsFloat },\n-            { \"doubles\", MemoryLayout.ofSequence(1024, MemoryLayouts.JAVA_DOUBLE), (SpliteratorTestHelper.ContentAsserter<MemorySegment>)SegmentTestDataProvider::compareSegmentsDouble },\n+            { \"bytes\", MemoryLayout.sequenceLayout(1024, MemoryLayouts.JAVA_BYTE), (SpliteratorTestHelper.ContentAsserter<MemorySegment>)SegmentTestDataProvider::compareSegmentsByte },\n+            { \"chars\", MemoryLayout.sequenceLayout(1024, MemoryLayouts.JAVA_CHAR), (SpliteratorTestHelper.ContentAsserter<MemorySegment>)SegmentTestDataProvider::compareSegmentsChar },\n+            { \"shorts\", MemoryLayout.sequenceLayout(1024, MemoryLayouts.JAVA_SHORT), (SpliteratorTestHelper.ContentAsserter<MemorySegment>)SegmentTestDataProvider::compareSegmentsShort },\n+            { \"ints\", MemoryLayout.sequenceLayout(1024, MemoryLayouts.JAVA_INT), (SpliteratorTestHelper.ContentAsserter<MemorySegment>)SegmentTestDataProvider::compareSegmentsInt },\n+            { \"longs\", MemoryLayout.sequenceLayout(1024, MemoryLayouts.JAVA_LONG), (SpliteratorTestHelper.ContentAsserter<MemorySegment>)SegmentTestDataProvider::compareSegmentsLong },\n+            { \"floats\", MemoryLayout.sequenceLayout(1024, MemoryLayouts.JAVA_FLOAT), (SpliteratorTestHelper.ContentAsserter<MemorySegment>)SegmentTestDataProvider::compareSegmentsFloat },\n+            { \"doubles\", MemoryLayout.sequenceLayout(1024, MemoryLayouts.JAVA_DOUBLE), (SpliteratorTestHelper.ContentAsserter<MemorySegment>)SegmentTestDataProvider::compareSegmentsDouble },\n","filename":"test\/jdk\/java\/util\/stream\/test\/org\/openjdk\/tests\/java\/util\/stream\/SegmentTestDataProvider.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+import jdk.incubator.foreign.ResourceScope;\n@@ -67,1 +68,2 @@\n-        try (MemorySegment segment = MemorySegment.allocateNative(layout)) {\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            MemorySegment segment = MemorySegment.allocateNative(layout, scope);\n","filename":"test\/jdk\/java\/util\/stream\/test\/org\/openjdk\/tests\/java\/util\/stream\/SpliteratorTest.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -33,0 +33,2 @@\n+import java.util.ArrayList;\n+import java.util.List;\n","filename":"test\/jdk\/jdk\/nio\/zipfs\/LargeEntriesTest.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -173,0 +173,2 @@\n+                    } else if (line.contains(\"WARNING: JNI access from module not specified in --enable-native-access:\")) {\n+                        continue;\n","filename":"test\/jdk\/tools\/jar\/modularJar\/Basic.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -637,1 +637,1 @@\n-  public native void verifyFrames(boolean log);\n+  public native void verifyFrames(boolean log, boolean updateRegisterMap);\n","filename":"test\/lib\/sun\/hotspot\/WhiteBox.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,173 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.foreign;\n+\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.SegmentAllocator;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.TearDown;\n+import org.openjdk.jmh.annotations.Warmup;\n+import sun.misc.Unsafe;\n+\n+import jdk.incubator.foreign.MemorySegment;\n+import java.nio.ByteBuffer;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Supplier;\n+\n+import static jdk.incubator.foreign.MemoryLayouts.JAVA_INT;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@State(org.openjdk.jmh.annotations.Scope.Thread)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@Fork(value = 3, jvmArgsAppend = { \"--add-modules=jdk.incubator.foreign\" })\n+public class BulkMismatchAcquire {\n+\n+    public enum ScopeKind {\n+        CONFINED(ResourceScope::newConfinedScope),\n+        SHARED(ResourceScope::newSharedScope),\n+        IMPLICIT(ResourceScope::newImplicitScope);\n+\n+        final Supplier<ResourceScope> scopeFactory;\n+\n+        ScopeKind(Supplier<ResourceScope> scopeFactory) {\n+            this.scopeFactory = scopeFactory;\n+        }\n+\n+        ResourceScope makeScope() {\n+            return scopeFactory.get();\n+        }\n+    }\n+\n+    @Param({\"CONFINED\", \"SHARED\", \"IMPLICIT\"})\n+    public ScopeKind scopeKind;\n+\n+    \/\/ large(ish) segments\/buffers with same content, 0, for mismatch, non-multiple-of-8 sized\n+    static final int SIZE_WITH_TAIL = (1024 * 1024) + 7;\n+\n+    ResourceScope scope;\n+    MemorySegment mismatchSegmentLarge1;\n+    MemorySegment mismatchSegmentLarge2;\n+    ByteBuffer mismatchBufferLarge1;\n+    ByteBuffer mismatchBufferLarge2;\n+    MemorySegment mismatchSegmentSmall1;\n+    MemorySegment mismatchSegmentSmall2;\n+    ByteBuffer mismatchBufferSmall1;\n+    ByteBuffer mismatchBufferSmall2;\n+\n+    @Setup\n+    public void setup() {\n+        scope = scopeKind.makeScope();\n+        mismatchSegmentLarge1 = MemorySegment.allocateNative(SIZE_WITH_TAIL, scope);\n+        mismatchSegmentLarge2 = MemorySegment.allocateNative(SIZE_WITH_TAIL, scope);\n+        mismatchBufferLarge1 = ByteBuffer.allocateDirect(SIZE_WITH_TAIL);\n+        mismatchBufferLarge2 = ByteBuffer.allocateDirect(SIZE_WITH_TAIL);\n+\n+        \/\/ mismatch at first byte\n+        mismatchSegmentSmall1 = MemorySegment.allocateNative(7, scope);\n+        mismatchSegmentSmall2 = MemorySegment.allocateNative(7, scope);\n+        mismatchBufferSmall1 = ByteBuffer.allocateDirect(7);\n+        mismatchBufferSmall2 = ByteBuffer.allocateDirect(7);\n+        {\n+            mismatchSegmentSmall1.fill((byte) 0xFF);\n+            mismatchBufferSmall1.put((byte) 0xFF).clear();\n+            \/\/ verify expected mismatch indices\n+            long si = mismatchSegmentLarge1.mismatch(mismatchSegmentLarge2);\n+            if (si != -1)\n+                throw new AssertionError(\"Unexpected mismatch index:\" + si);\n+            int bi = mismatchBufferLarge1.mismatch(mismatchBufferLarge2);\n+            if (bi != -1)\n+                throw new AssertionError(\"Unexpected mismatch index:\" + bi);\n+            si = mismatchSegmentSmall1.mismatch(mismatchSegmentSmall2);\n+            if (si != 0)\n+                throw new AssertionError(\"Unexpected mismatch index:\" + si);\n+            bi = mismatchBufferSmall1.mismatch(mismatchBufferSmall2);\n+            if (bi != 0)\n+                throw new AssertionError(\"Unexpected mismatch index:\" + bi);\n+        }\n+    }\n+\n+    @TearDown\n+    public void tearDown() {\n+        if (!scope.isImplicit())\n+            scope.close();\n+    }\n+\n+    @Benchmark\n+    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+    public long mismatch_large_segment() {\n+        return mismatchSegmentLarge1.mismatch(mismatchSegmentLarge2);\n+    }\n+\n+    @Benchmark\n+    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+    public long mismatch_large_segment_acquire() {\n+        var handle = mismatchSegmentLarge1.scope().acquire();\n+        try {\n+            return mismatchSegmentLarge1.mismatch(mismatchSegmentLarge2);\n+        } finally {\n+            mismatchSegmentLarge1.scope().release(handle);\n+        }\n+    }\n+\n+    @Benchmark\n+    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+    public int mismatch_large_bytebuffer() {\n+        return mismatchBufferLarge1.mismatch(mismatchBufferLarge2);\n+    }\n+\n+    @Benchmark\n+    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+    public long mismatch_small_segment() {\n+        return mismatchSegmentSmall1.mismatch(mismatchSegmentSmall2);\n+    }\n+\n+    @Benchmark\n+    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+    public long mismatch_small_segment_acquire() {\n+        var handle = mismatchSegmentLarge1.scope().acquire();\n+        try {\n+            return mismatchSegmentSmall1.mismatch(mismatchSegmentSmall2);\n+        } finally {\n+            mismatchSegmentLarge1.scope().release(handle);\n+        }\n+    }\n+\n+    @Benchmark\n+    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+    public int mismatch_small_bytebuffer() {\n+        return mismatchBufferSmall1.mismatch(mismatchBufferSmall2);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/BulkMismatchAcquire.java","additions":173,"deletions":0,"binary":false,"changes":173,"status":"added"},{"patch":"@@ -27,0 +27,1 @@\n+import jdk.incubator.foreign.ResourceScope;\n@@ -58,1 +59,1 @@\n-    static final MemorySegment segment = MemorySegment.allocateNative(ALLOC_SIZE);\n+    static final MemorySegment segment = MemorySegment.allocateNative(ALLOC_SIZE, ResourceScope.newConfinedScope());\n@@ -66,2 +67,2 @@\n-    static final MemorySegment mismatchSegmentLarge1 = MemorySegment.allocateNative(SIZE_WITH_TAIL);\n-    static final MemorySegment mismatchSegmentLarge2 = MemorySegment.allocateNative(SIZE_WITH_TAIL);\n+    static final MemorySegment mismatchSegmentLarge1 = MemorySegment.allocateNative(SIZE_WITH_TAIL, ResourceScope.newConfinedScope());\n+    static final MemorySegment mismatchSegmentLarge2 = MemorySegment.allocateNative(SIZE_WITH_TAIL, ResourceScope.newConfinedScope());\n@@ -72,2 +73,2 @@\n-    static final MemorySegment mismatchSegmentSmall1 = MemorySegment.allocateNative(7);\n-    static final MemorySegment mismatchSegmentSmall2 = MemorySegment.allocateNative(7);\n+    static final MemorySegment mismatchSegmentSmall1 = MemorySegment.allocateNative(7, ResourceScope.newConfinedScope());\n+    static final MemorySegment mismatchSegmentSmall2 = MemorySegment.allocateNative(7, ResourceScope.newConfinedScope());\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/BulkOps.java","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -1,161 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.jdk.incubator.foreign;\n-\n-import jdk.incubator.foreign.FunctionDescriptor;\n-import jdk.incubator.foreign.LibraryLookup;\n-import jdk.incubator.foreign.MemoryAddress;\n-import jdk.incubator.foreign.MemoryLayout;\n-import jdk.incubator.foreign.MemorySegment;\n-import jdk.incubator.foreign.CLinker;\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.BenchmarkMode;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Measurement;\n-import org.openjdk.jmh.annotations.Mode;\n-import org.openjdk.jmh.annotations.OutputTimeUnit;\n-import org.openjdk.jmh.annotations.State;\n-import org.openjdk.jmh.annotations.Warmup;\n-\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.MethodType;\n-import java.util.concurrent.TimeUnit;\n-\n-import static jdk.incubator.foreign.CLinker.C_DOUBLE;\n-import static jdk.incubator.foreign.CLinker.C_INT;\n-import static jdk.incubator.foreign.CLinker.C_LONG_LONG;\n-import static jdk.incubator.foreign.CLinker.C_POINTER;\n-\n-@BenchmarkMode(Mode.AverageTime)\n-@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n-@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n-@State(org.openjdk.jmh.annotations.Scope.Thread)\n-@OutputTimeUnit(TimeUnit.NANOSECONDS)\n-@Fork(value = 3, jvmArgsAppend = { \"--add-modules=jdk.incubator.foreign\", \"-Dforeign.restricted=permit\" })\n-public class CallOverhead {\n-\n-    static final CLinker abi = CLinker.getInstance();\n-\n-    static final MethodHandle func;\n-    static final MethodHandle identity;\n-    static final MethodHandle identity_struct;\n-    static final MethodHandle identity_memory_address;\n-    static final MethodHandle args5;\n-    static final MethodHandle args10;\n-    static final MethodHandle func_trivial;\n-    static final MethodHandle identity_trivial;\n-\n-    static final MemoryLayout POINT_LAYOUT = MemoryLayout.ofStruct(\n-            C_LONG_LONG, C_LONG_LONG\n-    );\n-\n-    static final MemorySegment point = MemorySegment.allocateNative(POINT_LAYOUT);\n-\n-    static {\n-        System.loadLibrary(\"CallOverheadJNI\");\n-\n-        LibraryLookup ll = LibraryLookup.ofLibrary(\"CallOverhead\");\n-        {\n-            LibraryLookup.Symbol addr = ll.lookup(\"func\").get();\n-            MethodType mt = MethodType.methodType(void.class);\n-            FunctionDescriptor fd = FunctionDescriptor.ofVoid();\n-            func = abi.downcallHandle(addr, mt, fd);\n-            func_trivial = abi.downcallHandle(addr, mt, fd.withAttribute(FunctionDescriptor.TRIVIAL_ATTRIBUTE_NAME, true));\n-        }\n-        {\n-            LibraryLookup.Symbol addr = ll.lookup(\"identity\").get();\n-            MethodType mt = MethodType.methodType(int.class, int.class);\n-            FunctionDescriptor fd = FunctionDescriptor.of(C_INT, C_INT);\n-            identity = abi.downcallHandle(addr, mt, fd);\n-            identity_trivial = abi.downcallHandle(addr, mt, fd.withAttribute(FunctionDescriptor.TRIVIAL_ATTRIBUTE_NAME, true));\n-        }\n-        identity_struct = abi.downcallHandle(ll.lookup(\"identity_struct\").get(),\n-                MethodType.methodType(MemorySegment.class, MemorySegment.class),\n-                FunctionDescriptor.of(POINT_LAYOUT, POINT_LAYOUT));\n-        identity_memory_address = abi.downcallHandle(ll.lookup(\"identity_memory_address\").get(),\n-                MethodType.methodType(MemoryAddress.class, MemoryAddress.class),\n-                FunctionDescriptor.of(C_POINTER, C_POINTER));\n-        args5 = abi.downcallHandle(ll.lookup(\"args5\").get(),\n-                MethodType.methodType(void.class, long.class, double.class, long.class, double.class, long.class),\n-                FunctionDescriptor.ofVoid(C_LONG_LONG, C_DOUBLE, C_LONG_LONG, C_DOUBLE, C_LONG_LONG));\n-        args10 = abi.downcallHandle(ll.lookup(\"args10\").get(),\n-                MethodType.methodType(void.class, long.class, double.class, long.class, double.class, long.class,\n-                                                  double.class, long.class, double.class, long.class, double.class),\n-                FunctionDescriptor.ofVoid(C_LONG_LONG, C_DOUBLE, C_LONG_LONG, C_DOUBLE, C_LONG_LONG,\n-                                          C_DOUBLE, C_LONG_LONG, C_DOUBLE, C_LONG_LONG, C_DOUBLE));\n-    }\n-\n-    static native void blank();\n-    static native int identity(int x);\n-\n-    @Benchmark\n-    public void jni_blank() throws Throwable {\n-        blank();\n-    }\n-\n-    @Benchmark\n-    public void panama_blank() throws Throwable {\n-        func.invokeExact();\n-    }\n-\n-    @Benchmark\n-    public void panama_blank_trivial() throws Throwable {\n-        func_trivial.invokeExact();\n-    }\n-\n-    @Benchmark\n-    public int jni_identity() throws Throwable {\n-        return identity(10);\n-    }\n-\n-    @Benchmark\n-    public int panama_identity() throws Throwable {\n-        return (int) identity.invokeExact(10);\n-    }\n-\n-    @Benchmark\n-    public int panama_identity_trivial() throws Throwable {\n-        return (int) identity_trivial.invokeExact(10);\n-    }\n-\n-    @Benchmark\n-    public MemorySegment panama_identity_struct() throws Throwable {\n-        return (MemorySegment) identity_struct.invokeExact(point);\n-    }\n-\n-    @Benchmark\n-    public MemoryAddress panama_identity_memory_address() throws Throwable {\n-        return (MemoryAddress) identity_memory_address.invokeExact(MemoryAddress.NULL);\n-    }\n-\n-    @Benchmark\n-    public void panama_args5() throws Throwable {\n-        args5.invokeExact(10L, 11D, 12L, 13D, 14L);\n-    }\n-\n-    @Benchmark\n-    public void panama_args10() throws Throwable {\n-        args10.invokeExact(10L, 11D, 12L, 13D, 14L,\n-                           15D, 16L, 17D, 18L, 19D);\n-    }\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/CallOverhead.java","additions":0,"deletions":161,"binary":false,"changes":161,"status":"deleted"},{"patch":"@@ -0,0 +1,118 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.jdk.incubator.foreign;\n+\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.MemorySegment;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import static org.openjdk.bench.jdk.incubator.foreign.CallOverheadHelper.*;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@State(org.openjdk.jmh.annotations.Scope.Thread)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Fork(value = 3, jvmArgsAppend = { \"--add-modules=jdk.incubator.foreign\", \"--enable-native-access=ALL-UNNAMED\" })\n+public class CallOverheadConstant {\n+\n+    @Benchmark\n+    public void jni_blank() throws Throwable {\n+        blank();\n+    }\n+\n+    @Benchmark\n+    public void panama_blank() throws Throwable {\n+        func.invokeExact();\n+    }\n+\n+    @Benchmark\n+    public void panama_blank_trivial() throws Throwable {\n+        func_trivial.invokeExact();\n+    }\n+\n+    @Benchmark\n+    public int jni_identity() throws Throwable {\n+        return identity(10);\n+    }\n+\n+    @Benchmark\n+    public int panama_identity() throws Throwable {\n+        return (int) identity.invokeExact(10);\n+    }\n+\n+    @Benchmark\n+    public int panama_identity_trivial() throws Throwable {\n+        return (int) identity_trivial.invokeExact(10);\n+    }\n+\n+    @Benchmark\n+    public MemorySegment panama_identity_struct() throws Throwable {\n+        return (MemorySegment) identity_struct.invokeExact(recycling_allocator, point);\n+    }\n+\n+    @Benchmark\n+    public MemoryAddress panama_identity_memory_address() throws Throwable {\n+        return (MemoryAddress) identity_memory_address.invokeExact(MemoryAddress.NULL);\n+    }\n+\n+    @Benchmark\n+    public void panama_args_01() throws Throwable {\n+        args1.invokeExact(10L);\n+    }\n+\n+    @Benchmark\n+    public void panama_args_02() throws Throwable {\n+        args2.invokeExact(10L, 11D);\n+    }\n+\n+    @Benchmark\n+    public void panama_args_03() throws Throwable {\n+        args3.invokeExact(10L, 11D, 12L);\n+    }\n+\n+    @Benchmark\n+    public void panama_args_04() throws Throwable {\n+        args4.invokeExact(10L, 11D, 12L, 13D);\n+    }\n+\n+    @Benchmark\n+    public void panama_args_05() throws Throwable {\n+        args5.invokeExact(10L, 11D, 12L, 13D, 14L);\n+    }\n+\n+    @Benchmark\n+    public void panama_args_10() throws Throwable {\n+        args10.invokeExact(10L, 11D, 12L, 13D, 14L,\n+                           15D, 16L, 17D, 18L, 19D);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/CallOverheadConstant.java","additions":118,"deletions":0,"binary":false,"changes":118,"status":"added"},{"patch":"@@ -0,0 +1,166 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.jdk.incubator.foreign;\n+\n+import jdk.incubator.foreign.Addressable;\n+import jdk.incubator.foreign.CLinker;\n+import jdk.incubator.foreign.FunctionDescriptor;\n+import jdk.incubator.foreign.LibraryLookup;\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.MemoryLayout;\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.SegmentAllocator;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodType;\n+\n+import static java.lang.invoke.MethodHandles.insertArguments;\n+import static jdk.incubator.foreign.CLinker.C_DOUBLE;\n+import static jdk.incubator.foreign.CLinker.C_INT;\n+import static jdk.incubator.foreign.CLinker.C_LONG_LONG;\n+import static jdk.incubator.foreign.CLinker.C_POINTER;\n+\n+public class CallOverheadHelper {\n+\n+    static final CLinker abi = CLinker.getInstance();\n+\n+    static final MethodHandle func;\n+    static final MethodHandle func_v;\n+    static Addressable func_addr;\n+    static final MethodHandle identity;\n+    static final MethodHandle identity_v;\n+    static Addressable identity_addr;\n+    static final MethodHandle identity_struct;\n+    static final MethodHandle identity_struct_v;\n+    static Addressable identity_struct_addr;\n+    static final MethodHandle identity_memory_address;\n+    static final MethodHandle identity_memory_address_v;\n+    static Addressable identity_memory_address_addr;\n+    static final MethodHandle args1;\n+    static final MethodHandle args1_v;\n+    static Addressable args1_addr;\n+    static final MethodHandle args2;\n+    static final MethodHandle args2_v;\n+    static Addressable args2_addr;\n+    static final MethodHandle args3;\n+    static final MethodHandle args3_v;\n+    static Addressable args3_addr;\n+    static final MethodHandle args4;\n+    static final MethodHandle args4_v;\n+    static Addressable args4_addr;\n+    static final MethodHandle args5;\n+    static final MethodHandle args5_v;\n+    static Addressable args5_addr;\n+    static final MethodHandle args10;\n+    static final MethodHandle args10_v;\n+    static Addressable args10_addr;\n+    static final MethodHandle func_trivial;\n+    static final MethodHandle func_trivial_v;\n+    static final MethodHandle identity_trivial;\n+    static final MethodHandle identity_trivial_v;\n+\n+    static final MemoryLayout POINT_LAYOUT = MemoryLayout.structLayout(\n+            C_LONG_LONG, C_LONG_LONG\n+    );\n+\n+    static final MemorySegment point = MemorySegment.allocateNative(POINT_LAYOUT, ResourceScope.newImplicitScope());\n+\n+    static final SegmentAllocator recycling_allocator = SegmentAllocator.ofSegment(MemorySegment.allocateNative(POINT_LAYOUT, ResourceScope.newImplicitScope()));\n+\n+    static {\n+        System.loadLibrary(\"CallOverheadJNI\");\n+\n+        LibraryLookup ll = LibraryLookup.ofLibrary(\"CallOverhead\");\n+        {\n+            func_addr = ll.lookup(\"func\").orElseThrow();\n+            MethodType mt = MethodType.methodType(void.class);\n+            FunctionDescriptor fd = FunctionDescriptor.ofVoid();\n+            func_v = abi.downcallHandle(mt, fd);\n+            func = insertArguments(func_v, 0, func_addr);\n+            func_trivial_v = abi.downcallHandle(mt, fd.withAttribute(FunctionDescriptor.TRIVIAL_ATTRIBUTE_NAME, true));\n+            func_trivial = insertArguments(func_trivial_v, 0, func_addr);\n+        }\n+        {\n+            identity_addr = ll.lookup(\"identity\").orElseThrow();\n+            MethodType mt = MethodType.methodType(int.class, int.class);\n+            FunctionDescriptor fd = FunctionDescriptor.of(C_INT, C_INT);\n+            identity_v = abi.downcallHandle(mt, fd);\n+            identity = insertArguments(identity_v, 0, identity_addr);\n+            identity_trivial_v = abi.downcallHandle(mt, fd.withAttribute(FunctionDescriptor.TRIVIAL_ATTRIBUTE_NAME, true));\n+            identity_trivial = insertArguments(identity_trivial_v, 0, identity_addr);\n+        }\n+        identity_struct_addr = ll.lookup(\"identity_struct\").orElseThrow();\n+        identity_struct_v = abi.downcallHandle(\n+                MethodType.methodType(MemorySegment.class, MemorySegment.class),\n+                FunctionDescriptor.of(POINT_LAYOUT, POINT_LAYOUT));\n+        identity_struct = insertArguments(identity_struct_v, 0, identity_struct_addr);\n+\n+        identity_memory_address_addr = ll.lookup(\"identity_memory_address\").orElseThrow();\n+        identity_memory_address_v = abi.downcallHandle(\n+                MethodType.methodType(MemoryAddress.class, MemoryAddress.class),\n+                FunctionDescriptor.of(C_POINTER, C_POINTER));\n+        identity_memory_address = insertArguments(identity_memory_address_v, 0, identity_memory_address_addr);\n+\n+        args1_addr = ll.lookup(\"args1\").orElseThrow();\n+        args1_v = abi.downcallHandle(\n+                MethodType.methodType(void.class, long.class),\n+                FunctionDescriptor.ofVoid(C_LONG_LONG));\n+        args1 = insertArguments(args1_v, 0, args1_addr);\n+\n+        args2_addr = ll.lookup(\"args2\").orElseThrow();\n+        args2_v = abi.downcallHandle(\n+                MethodType.methodType(void.class, long.class, double.class),\n+                FunctionDescriptor.ofVoid(C_LONG_LONG, C_DOUBLE));\n+        args2 = insertArguments(args2_v, 0, args2_addr);\n+\n+        args3_addr = ll.lookup(\"args3\").orElseThrow();\n+        args3_v = abi.downcallHandle(\n+                MethodType.methodType(void.class, long.class, double.class, long.class),\n+                FunctionDescriptor.ofVoid(C_LONG_LONG, C_DOUBLE, C_LONG_LONG));\n+        args3 = insertArguments(args3_v, 0, args3_addr);\n+\n+        args4_addr = ll.lookup(\"args4\").orElseThrow();\n+        args4_v = abi.downcallHandle(\n+                MethodType.methodType(void.class, long.class, double.class, long.class, double.class),\n+                FunctionDescriptor.ofVoid(C_LONG_LONG, C_DOUBLE, C_LONG_LONG, C_DOUBLE));\n+        args4 = insertArguments(args4_v, 0, args4_addr);\n+\n+        args5_addr = ll.lookup(\"args5\").orElseThrow();\n+        args5_v = abi.downcallHandle(\n+                MethodType.methodType(void.class, long.class, double.class, long.class, double.class, long.class),\n+                FunctionDescriptor.ofVoid(C_LONG_LONG, C_DOUBLE, C_LONG_LONG, C_DOUBLE, C_LONG_LONG));\n+        args5 = insertArguments(args5_v, 0, args5_addr);\n+\n+        args10_addr = ll.lookup(\"args10\").orElseThrow();\n+        args10_v = abi.downcallHandle(\n+                MethodType.methodType(void.class, long.class, double.class, long.class, double.class, long.class,\n+                                                  double.class, long.class, double.class, long.class, double.class),\n+                FunctionDescriptor.ofVoid(C_LONG_LONG, C_DOUBLE, C_LONG_LONG, C_DOUBLE, C_LONG_LONG,\n+                                          C_DOUBLE, C_LONG_LONG, C_DOUBLE, C_LONG_LONG, C_DOUBLE));\n+        args10 = insertArguments(args10_v, 0, args10_addr);\n+    }\n+\n+    static native void blank();\n+    static native int identity(int x);\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/CallOverheadHelper.java","additions":166,"deletions":0,"binary":false,"changes":166,"status":"added"},{"patch":"@@ -0,0 +1,119 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.jdk.incubator.foreign;\n+\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.MemorySegment;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import static org.openjdk.bench.jdk.incubator.foreign.CallOverheadHelper.*;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@State(org.openjdk.jmh.annotations.Scope.Thread)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Fork(value = 3, jvmArgsAppend = { \"--add-modules=jdk.incubator.foreign\", \"--enable-native-access=ALL-UNNAMED\" })\n+public class CallOverheadVirtual {\n+\n+    @Benchmark\n+    public void jni_blank() throws Throwable {\n+        blank();\n+    }\n+\n+    @Benchmark\n+    public void panama_blank() throws Throwable {\n+        func_v.invokeExact(func_addr);\n+    }\n+\n+    @Benchmark\n+    public void panama_blank_trivial() throws Throwable {\n+        func_trivial_v.invokeExact(func_addr);\n+    }\n+\n+    @Benchmark\n+    public int jni_identity() throws Throwable {\n+        return identity(10);\n+    }\n+\n+    @Benchmark\n+    public int panama_identity() throws Throwable {\n+        return (int) identity_v.invokeExact(identity_addr, 10);\n+    }\n+\n+    @Benchmark\n+    public int panama_identity_trivial() throws Throwable {\n+        return (int) identity_trivial_v.invokeExact(identity_addr, 10);\n+    }\n+\n+    @Benchmark\n+    public MemorySegment panama_identity_struct() throws Throwable {\n+        return (MemorySegment) identity_struct_v.invokeExact(identity_struct_addr, recycling_allocator, point);\n+    }\n+\n+    @Benchmark\n+    public MemoryAddress panama_identity_memory_address() throws Throwable {\n+        return (MemoryAddress) identity_memory_address_v.invokeExact(identity_memory_address_addr, MemoryAddress.NULL);\n+    }\n+\n+    @Benchmark\n+    public void panama_args_01() throws Throwable {\n+        args1_v.invokeExact(args1_addr, 10L);\n+    }\n+\n+    @Benchmark\n+    public void panama_args_02() throws Throwable {\n+        args2_v.invokeExact(args2_addr, 10L, 11D);\n+    }\n+\n+    @Benchmark\n+    public void panama_args_03() throws Throwable {\n+        args3_v.invokeExact(args3_addr, 10L, 11D, 12L);\n+    }\n+\n+    @Benchmark\n+    public void panama_args_04() throws Throwable {\n+        args4_v.invokeExact(args4_addr, 10L, 11D, 12L, 13D);\n+    }\n+\n+    @Benchmark\n+    public void panama_args_05() throws Throwable {\n+        args5_v.invokeExact(args5_addr, 10L, 11D, 12L, 13D, 14L);\n+    }\n+\n+    @Benchmark\n+    public void panama_args_10() throws Throwable {\n+        args10_v.invokeExact(args10_addr,\n+                           10L, 11D, 12L, 13D, 14L,\n+                           15D, 16L, 17D, 18L, 19D);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/CallOverheadVirtual.java","additions":119,"deletions":0,"binary":false,"changes":119,"status":"added"},{"patch":"@@ -26,0 +26,1 @@\n+import jdk.incubator.foreign.ResourceScope;\n@@ -39,1 +40,0 @@\n-import jdk.incubator.foreign.MemoryAddress;\n@@ -75,2 +75,2 @@\n-    static final MemorySegment segment = MemorySegment.allocateNative(ALLOC_SIZE);\n-    static final VarHandle VH_int = MemoryLayout.ofSequence(JAVA_INT).varHandle(int.class, sequenceElement());\n+    static final MemorySegment segment = MemorySegment.allocateNative(ALLOC_SIZE, ResourceScope.newImplicitScope());\n+    static final VarHandle VH_int = MemoryLayout.sequenceLayout(JAVA_INT).varHandle(int.class, sequenceElement());\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/LoopOverConstant.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+import jdk.incubator.foreign.SegmentAllocator;\n+import jdk.incubator.foreign.ResourceScope;\n@@ -60,0 +62,1 @@\n+    static final MemoryLayout ALLOC_LAYOUT = MemoryLayout.sequenceLayout(ELEM_SIZE, JAVA_INT);\n@@ -61,1 +64,9 @@\n-    static final VarHandle VH_int = MemoryLayout.ofSequence(JAVA_INT).varHandle(int.class, sequenceElement());\n+    static final VarHandle VH_int = MemoryLayout.sequenceLayout(JAVA_INT).varHandle(int.class, sequenceElement());\n+\n+    final ResourceScope scope = ResourceScope.newConfinedScope();\n+    final SegmentAllocator recyclingAlloc = SegmentAllocator.ofSegment(MemorySegment.allocateNative(ALLOC_LAYOUT, scope));\n+\n+    @TearDown\n+    public void tearDown() throws Throwable {\n+        scope.close();\n+    }\n@@ -73,4 +84,6 @@\n-    public void segment_loop() {\n-        MemorySegment segment = MemorySegment.allocateNative(ALLOC_SIZE);\n-        for (int i = 0; i < ELEM_SIZE; i++) {\n-            VH_int.set(segment, (long) i, i);\n+    public void segment_loop_confined() {\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            MemorySegment segment = MemorySegment.allocateNative(ALLOC_SIZE, 4, scope);\n+            for (int i = 0; i < ELEM_SIZE; i++) {\n+                VH_int.set(segment, (long) i, i);\n+            }\n@@ -78,1 +91,0 @@\n-        segment.close();\n@@ -83,1 +95,11 @@\n-        MemorySegment segment = MemorySegment.allocateNative(ALLOC_SIZE).share();\n+        try (ResourceScope scope = ResourceScope.newSharedScope()) {\n+            MemorySegment segment = MemorySegment.allocateNative(ALLOC_SIZE, 4, scope);\n+            for (int i = 0; i < ELEM_SIZE; i++) {\n+                VH_int.set(segment, (long) i, i);\n+            }\n+        }\n+    }\n+\n+    @Benchmark\n+    public void segment_loop_recycle() {\n+        MemorySegment segment = recyclingAlloc.allocate(ALLOC_SIZE, 4);\n@@ -87,1 +109,0 @@\n-        segment.close();\n@@ -98,0 +119,27 @@\n+\n+    \/\/ hack to even out calls to System::gc, which allows us to compare how the implicit segment deallocation\n+    \/\/ fares compared with ByteBuffer; if there's no call to System.gc() we end up comparing how well the two\n+    \/\/ act under significant native memory pressure, and here the ByteBuffer API has more juice, since it features\n+    \/\/ a complex exponential back off with multiple GC retries (see ByteBuffer::allocateDirect). Of course, we\n+    \/\/ don't care about those cases with segments, as if clients need to allocate\/free very frequently\n+    \/\/ they should just use deterministic deallocation (with confined scope) instead, which delivers much\n+    \/\/ better performances anyway.\n+    static byte gcCount = 0;\n+\n+    @Benchmark\n+    public void buffer_loop_implicit() {\n+        if (gcCount++ == 0) System.gc(); \/\/ GC when we overflow\n+        ByteBuffer byteBuffer = ByteBuffer.allocateDirect(ALLOC_SIZE).order(ByteOrder.nativeOrder());\n+        for (int i = 0; i < ELEM_SIZE; i++) {\n+            byteBuffer.putInt(i * CARRIER_SIZE , i);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void segment_loop_implicit() {\n+        if (gcCount++ == 0) System.gc(); \/\/ GC when we overflow\n+        MemorySegment segment = MemorySegment.allocateNative(ALLOC_SIZE, 4, ResourceScope.newImplicitScope());\n+        for (int i = 0; i < ELEM_SIZE; i++) {\n+            VH_int.set(segment, (long) i, i);\n+        }\n+    }\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/LoopOverNew.java","additions":56,"deletions":8,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-import jdk.incubator.foreign.MemoryAddress;\n@@ -29,0 +28,1 @@\n+import jdk.incubator.foreign.ResourceScope;\n@@ -63,1 +63,1 @@\n-    static final VarHandle VH_int = MemoryLayout.ofSequence(JAVA_INT).varHandle(int.class, sequenceElement());\n+    static final VarHandle VH_int = MemoryLayout.sequenceLayout(JAVA_INT).varHandle(int.class, sequenceElement());\n@@ -75,1 +75,1 @@\n-        segment = MemorySegment.allocateNative(ALLOC_SIZE);\n+        segment = MemorySegment.allocateNative(ALLOC_SIZE, ResourceScope.newConfinedScope());\n@@ -87,1 +87,1 @@\n-        segment.close();\n+        segment.scope().close();\n@@ -150,1 +150,1 @@\n-        MemorySegment base = segment.withAccessModes(MemorySegment.READ);\n+        MemorySegment base = segment.asReadOnly();\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/LoopOverNonConstant.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -26,2 +26,0 @@\n-import jdk.incubator.foreign.MemoryAddress;\n-import jdk.incubator.foreign.MemoryLayout;\n@@ -29,0 +27,1 @@\n+import jdk.incubator.foreign.ResourceScope;\n@@ -41,1 +40,0 @@\n-import java.lang.invoke.VarHandle;\n@@ -77,2 +75,2 @@\n-        segmentIn = MemorySegment.allocateNative(ALLOC_SIZE);\n-        segmentOut = MemorySegment.allocateNative(ALLOC_SIZE);\n+        segmentIn = MemorySegment.allocateNative(ALLOC_SIZE, ResourceScope.newConfinedScope());\n+        segmentOut = MemorySegment.allocateNative(ALLOC_SIZE, ResourceScope.newConfinedScope());\n@@ -97,2 +95,2 @@\n-        segmentIn.close();\n-        segmentOut.close();\n+        segmentIn.scope().close();\n+        segmentOut.scope().close();\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/LoopOverNonConstantFP.java","additions":5,"deletions":7,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-import jdk.incubator.foreign.MemoryAddress;\n@@ -29,0 +28,1 @@\n+import jdk.incubator.foreign.ResourceScope;\n@@ -43,0 +43,1 @@\n+import java.lang.ref.Cleaner;\n@@ -65,1 +66,1 @@\n-    static final VarHandle VH_int = MemoryLayout.ofSequence(JAVA_INT).varHandle(int.class, sequenceElement());\n+    static final VarHandle VH_int = MemoryLayout.sequenceLayout(JAVA_INT).varHandle(int.class, sequenceElement());\n@@ -81,8 +82,7 @@\n-            try (MemorySegment s = MemorySegment.allocateNative(ALLOC_SIZE)) {\n-                for (int i = 0; i < ALLOC_SIZE; i++) {\n-                    MemoryAccess.setByteAtOffset(intB, i, (byte)i);\n-                    MemoryAccess.setIntAtIndex(intI, i, i);\n-                    MemoryAccess.setDoubleAtIndex(intD, i, i);\n-                    MemoryAccess.setFloatAtIndex(intF, i, i);\n-                    MemoryAccess.setByteAtOffset(s, i, (byte) i);\n-                }\n+            MemorySegment s = MemorySegment.allocateNative(ALLOC_SIZE, 1, ResourceScope.newConfinedScope(Cleaner.create()));\n+            for (int i = 0; i < ALLOC_SIZE; i++) {\n+                MemoryAccess.setByteAtOffset(intB, i, (byte)i);\n+                MemoryAccess.setIntAtIndex(intI, i, i);\n+                MemoryAccess.setDoubleAtIndex(intD, i, i);\n+                MemoryAccess.setFloatAtIndex(intF, i, i);\n+                MemoryAccess.setByteAtOffset(s, i, (byte) i);\n@@ -100,5 +100,0 @@\n-    @TearDown\n-    public void tearDown() {\n-        segment.close();\n-    }\n-\n@@ -163,1 +158,1 @@\n-        MemorySegment base = segment.withAccessModes(MemorySegment.READ);\n+        MemorySegment base = segment.asReadOnly();\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/LoopOverNonConstantHeap.java","additions":11,"deletions":16,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.incubator.foreign.ResourceScope;\n@@ -83,1 +84,1 @@\n-    static final VarHandle VH_int = MemoryLayout.ofSequence(JAVA_INT).varHandle(int.class, sequenceElement());\n+    static final VarHandle VH_int = MemoryLayout.sequenceLayout(JAVA_INT).varHandle(int.class, sequenceElement());\n@@ -98,1 +99,1 @@\n-        segment = MemorySegment.mapFile(tempPath, 0L, ALLOC_SIZE, FileChannel.MapMode.READ_WRITE);\n+        segment = MemorySegment.mapFile(tempPath, 0L, ALLOC_SIZE, FileChannel.MapMode.READ_WRITE, ResourceScope.newConfinedScope());\n@@ -104,1 +105,1 @@\n-        segment.close();\n+        segment.scope().close();\n@@ -166,1 +167,1 @@\n-        MemorySegment base = segment.withAccessModes(MemorySegment.READ);\n+        MemorySegment base = segment.asReadOnly();\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/LoopOverNonConstantMapped.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.incubator.foreign.ResourceScope;\n@@ -62,1 +63,1 @@\n-    static final VarHandle VH_int = MemoryLayout.ofSequence(JAVA_INT).varHandle(int.class, sequenceElement());\n+    static final VarHandle VH_int = MemoryLayout.sequenceLayout(JAVA_INT).varHandle(int.class, sequenceElement());\n@@ -74,1 +75,1 @@\n-        segment = MemorySegment.allocateNative(ALLOC_SIZE).share();\n+        segment = MemorySegment.allocateNative(ALLOC_SIZE, CARRIER_SIZE, ResourceScope.newSharedScope());\n@@ -86,1 +87,1 @@\n-        segment.close();\n+        segment.scope().close();\n@@ -149,1 +150,1 @@\n-        MemorySegment base = segment.withAccessModes(MemorySegment.READ);\n+        MemorySegment base = segment.asReadOnly();\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/LoopOverNonConstantShared.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.incubator.foreign.ResourceScope;\n@@ -64,1 +65,1 @@\n-    static final VarHandle intHandle = MemoryLayout.ofSequence(JAVA_INT).varHandle(int.class, MemoryLayout.PathElement.sequenceElement());\n+    static final VarHandle intHandle = MemoryLayout.sequenceLayout(JAVA_INT).varHandle(int.class, MemoryLayout.PathElement.sequenceElement());\n@@ -74,1 +75,1 @@\n-        nativeSegment = MemorySegment.allocateNative(ALLOC_SIZE, 4);\n+        nativeSegment = MemorySegment.allocateNative(ALLOC_SIZE, 4, ResourceScope.newConfinedScope());\n@@ -96,1 +97,1 @@\n-        nativeSegment.close();\n+        nativeSegment.scope().close();\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/LoopOverPollutedSegments.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.incubator.foreign.ResourceScope;\n@@ -41,1 +42,0 @@\n-import jdk.incubator.foreign.MemoryAddress;\n@@ -47,1 +47,0 @@\n-import java.util.OptionalInt;\n@@ -52,1 +51,0 @@\n-import java.util.function.IntFunction;\n@@ -55,1 +53,0 @@\n-import java.util.stream.StreamSupport;\n@@ -71,1 +68,1 @@\n-    static final VarHandle VH_int = MemoryLayout.ofSequence(JAVA_INT).varHandle(int.class, sequenceElement());\n+    static final VarHandle VH_int = MemoryLayout.sequenceLayout(JAVA_INT).varHandle(int.class, sequenceElement());\n@@ -73,1 +70,1 @@\n-    final static SequenceLayout SEQUENCE_LAYOUT = MemoryLayout.ofSequence(ELEM_SIZE, MemoryLayouts.JAVA_INT);\n+    final static MemoryLayout ELEM_LAYOUT = MemoryLayouts.JAVA_INT;\n@@ -75,1 +72,1 @@\n-    final static SequenceLayout SEQUENCE_LAYOUT_BULK = SEQUENCE_LAYOUT.reshape(-1, BULK_FACTOR);\n+    final static SequenceLayout ELEM_LAYOUT_BULK = MemoryLayout.sequenceLayout(BULK_FACTOR, ELEM_LAYOUT);\n@@ -88,1 +85,1 @@\n-        segment = MemorySegment.allocateNative(ALLOC_SIZE).share();\n+        segment = MemorySegment.allocateNative(ALLOC_SIZE, CARRIER_SIZE, ResourceScope.newSharedScope());\n@@ -97,1 +94,1 @@\n-        segment.close();\n+        segment.scope().close();\n@@ -120,1 +117,1 @@\n-        return new SumSegment(segment.spliterator(SEQUENCE_LAYOUT), SEGMENT_TO_INT).invoke();\n+        return new SumSegment(segment.spliterator(ELEM_LAYOUT), SEGMENT_TO_INT).invoke();\n@@ -125,1 +122,1 @@\n-        return new SumSegment(segment.spliterator(SEQUENCE_LAYOUT_BULK), SEGMENT_TO_INT_BULK).invoke();\n+        return new SumSegment(segment.spliterator(ELEM_LAYOUT_BULK), SEGMENT_TO_INT_BULK).invoke();\n@@ -130,2 +127,1 @@\n-        return StreamSupport.stream(segment.spliterator(SEQUENCE_LAYOUT), true)\n-                .mapToInt(SEGMENT_TO_INT).sum();\n+        return segment.elements(ELEM_LAYOUT).parallel().mapToInt(SEGMENT_TO_INT).sum();\n@@ -136,2 +132,1 @@\n-        return StreamSupport.stream(segment.spliterator(SEQUENCE_LAYOUT_BULK), true)\n-                .mapToInt(SEGMENT_TO_INT_BULK).sum();\n+        return segment.elements(ELEM_LAYOUT_BULK).parallel().mapToInt(SEGMENT_TO_INT_BULK).sum();\n@@ -153,1 +148,1 @@\n-        return StreamSupport.stream(segment.spliterator(SEQUENCE_LAYOUT), false)\n+        return segment.elements(ELEM_LAYOUT)\n@@ -160,1 +155,1 @@\n-        return StreamSupport.stream(segment.spliterator(SEQUENCE_LAYOUT), true)\n+        return segment.elements(ELEM_LAYOUT).parallel()\n@@ -167,1 +162,1 @@\n-        return StreamSupport.stream(segment.spliterator(SEQUENCE_LAYOUT_BULK), false)\n+        return segment.elements(ELEM_LAYOUT_BULK)\n@@ -174,1 +169,1 @@\n-        return StreamSupport.stream(segment.spliterator(SEQUENCE_LAYOUT_BULK), true)\n+        return segment.elements(ELEM_LAYOUT_BULK).parallel()\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/ParallelSum.java","additions":14,"deletions":19,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -0,0 +1,132 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.jdk.incubator.foreign;\n+\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ResourceScope;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.TearDown;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@State(org.openjdk.jmh.annotations.Scope.Thread)\n+@OutputTimeUnit(TimeUnit.MICROSECONDS)\n+@Fork(value = 3, jvmArgsAppend = { \"--add-modules=jdk.incubator.foreign\" })\n+public class ResourceScopeClose {\n+\n+    static final int ALLOC_SIZE = 1024;\n+\n+    public enum StressMode {\n+        NONE,\n+        MEMORY,\n+        THREADS\n+    }\n+\n+    @Param({\"NONE\", \"MEMORY\", \"THREADS\"})\n+    StressMode mode;\n+\n+    List<byte[]> arrays;\n+    volatile boolean stop = false;\n+    List<Thread> threads;\n+\n+    @Setup\n+    public void setup() throws Throwable {\n+        if (mode == StressMode.MEMORY) {\n+            arrays = new ArrayList<>();\n+            for (int i = 0; i < 100_000_000; i++) {\n+                arrays.add(new byte[2]);\n+            }\n+        } else if (mode == StressMode.THREADS) {\n+            threads = new ArrayList<>();\n+            for (int i = 0 ; i < 4 ; i++) {\n+                threads.add(new Thread(() -> {\n+                    while (true) {\n+                        if (stop) break;\n+                        \/\/ busy wait\n+                    }\n+                }));\n+            }\n+            threads.forEach(Thread::start);\n+        }\n+\n+    }\n+\n+    @TearDown\n+    public void tearDown() throws Throwable {\n+        arrays = null;\n+        if (threads != null) {\n+            stop = true;\n+            threads.forEach(t -> {\n+                try {\n+                    t.join();\n+                } catch (InterruptedException ex) {\n+                    throw new IllegalStateException(ex);\n+                }\n+            });\n+        }\n+    }\n+\n+    @Benchmark\n+    public MemorySegment confined_close() {\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            return MemorySegment.allocateNative(ALLOC_SIZE, 4, scope);\n+        }\n+    }\n+\n+    @Benchmark\n+    public MemorySegment shared_close() {\n+        try (ResourceScope scope = ResourceScope.newSharedScope()) {\n+            return MemorySegment.allocateNative(ALLOC_SIZE, 4, scope);\n+        }\n+    }\n+\n+    @Benchmark\n+    public MemorySegment implicit_close() {\n+        return MemorySegment.allocateNative(ALLOC_SIZE, 4, ResourceScope.newImplicitScope());\n+    }\n+\n+    @Benchmark\n+    public MemorySegment implicit_close_systemgc() {\n+        if (gcCount++ == 0) System.gc(); \/\/ GC when we overflow\n+        return MemorySegment.allocateNative(ALLOC_SIZE, 4, ResourceScope.newImplicitScope());\n+    }\n+\n+    \/\/ keep\n+    static byte gcCount = 0;\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/ResourceScopeClose.java","additions":132,"deletions":0,"binary":false,"changes":132,"status":"added"},{"patch":"@@ -0,0 +1,180 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.foreign;\n+\n+import jdk.incubator.foreign.CLinker;\n+import jdk.incubator.foreign.FunctionDescriptor;\n+import jdk.incubator.foreign.LibraryLookup;\n+import jdk.incubator.foreign.MemoryAccess;\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.SegmentAllocator;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.TearDown;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodType;\n+import java.util.concurrent.TimeUnit;\n+\n+import static jdk.incubator.foreign.CLinker.*;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@State(org.openjdk.jmh.annotations.Scope.Thread)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Fork(value = 3, jvmArgsAppend = { \"--add-modules=jdk.incubator.foreign\", \"--enable-native-access=ALL-UNNAMED\" })\n+public class StrLenTest {\n+\n+    ResourceScope scope = ResourceScope.newConfinedScope();\n+\n+    SegmentAllocator segmentAllocator;\n+    SegmentAllocator arenaAllocator = SegmentAllocator.arenaAllocator(scope);\n+\n+    @Param({\"5\", \"20\", \"100\"})\n+    public int size;\n+    public String str;\n+\n+    static {\n+        System.loadLibrary(\"StrLen\");\n+    }\n+\n+    static final MethodHandle STRLEN;\n+    static final MethodHandle STRLEN_TRIVIAL;\n+    static final MethodHandle MALLOC_TRIVIAL;\n+    static final MethodHandle FREE_TRIVIAL;\n+\n+    static {\n+        LibraryLookup lookup = LibraryLookup.ofDefault();\n+        CLinker abi = CLinker.getInstance();\n+        STRLEN = abi.downcallHandle(lookup.lookup(\"strlen\").get(),\n+                MethodType.methodType(int.class, MemoryAddress.class),\n+                FunctionDescriptor.of(C_INT, C_POINTER));\n+        STRLEN_TRIVIAL = abi.downcallHandle(lookup.lookup(\"strlen\").get(),\n+                MethodType.methodType(int.class, MemoryAddress.class),\n+                FunctionDescriptor.of(C_INT, C_POINTER).withAttribute(FunctionDescriptor.TRIVIAL_ATTRIBUTE_NAME, true));\n+        MALLOC_TRIVIAL = abi.downcallHandle(lookup.lookup(\"malloc\").get(),\n+                MethodType.methodType(MemoryAddress.class, long.class),\n+                FunctionDescriptor.of(C_POINTER, C_LONG_LONG).withAttribute(FunctionDescriptor.TRIVIAL_ATTRIBUTE_NAME, true));\n+\n+        FREE_TRIVIAL = abi.downcallHandle(lookup.lookup(\"free\").get(),\n+                MethodType.methodType(void.class, MemoryAddress.class),\n+                FunctionDescriptor.ofVoid(C_POINTER).withAttribute(FunctionDescriptor.TRIVIAL_ATTRIBUTE_NAME, true));\n+    }\n+\n+    @Setup\n+    public void setup() {\n+        str = makeString(size);\n+        segmentAllocator = SegmentAllocator.ofSegment(MemorySegment.allocateNative(size + 1, ResourceScope.newImplicitScope()));\n+    }\n+\n+    @TearDown\n+    public void tearDown() {\n+        scope.close();\n+    }\n+\n+    @Benchmark\n+    public int jni_strlen() throws Throwable {\n+        return strlen(str);\n+    }\n+\n+    @Benchmark\n+    public int panama_strlen() throws Throwable {\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            MemorySegment segment = CLinker.toCString(str, scope);\n+            return (int)STRLEN.invokeExact(segment.address());\n+        }\n+    }\n+\n+    @Benchmark\n+    public int panama_strlen_arena() throws Throwable {\n+        return (int)STRLEN.invokeExact(CLinker.toCString(str, arenaAllocator).address());\n+    }\n+\n+    @Benchmark\n+    public int panama_strlen_prefix() throws Throwable {\n+        return (int)STRLEN.invokeExact(CLinker.toCString(str, segmentAllocator).address());\n+    }\n+\n+    @Benchmark\n+    public int panama_strlen_unsafe() throws Throwable {\n+        MemoryAddress address = makeStringUnsafe(str);\n+        int res = (int) STRLEN.invokeExact(address);\n+        CLinker.freeMemory(address);\n+        return res;\n+    }\n+\n+    @Benchmark\n+    public int panama_strlen_unsafe_trivial() throws Throwable {\n+        MemoryAddress address = makeStringUnsafeTrivial(str);\n+        int res = (int) STRLEN_TRIVIAL.invokeExact(address);\n+        FREE_TRIVIAL.invokeExact(address);\n+        return res;\n+    }\n+\n+    static MemoryAddress makeStringUnsafe(String s) {\n+        byte[] bytes = s.getBytes();\n+        int len = bytes.length;\n+        MemoryAddress address = CLinker.allocateMemory(len + 1);\n+        MemorySegment str = address.asSegment(len + 1, ResourceScope.globalScope());\n+        str.copyFrom(MemorySegment.ofArray(bytes));\n+        MemoryAccess.setByteAtOffset(str, len, (byte)0);\n+        return address;\n+    }\n+\n+    static MemoryAddress makeStringUnsafeTrivial(String s) throws Throwable {\n+        byte[] bytes = s.getBytes();\n+        int len = bytes.length;\n+        MemoryAddress address = (MemoryAddress)MALLOC_TRIVIAL.invokeExact((long)len + 1);\n+        MemorySegment str = address.asSegment(len + 1, ResourceScope.globalScope());\n+        str.copyFrom(MemorySegment.ofArray(bytes));\n+        MemoryAccess.setByteAtOffset(str, len, (byte)0);\n+        return address;\n+    }\n+\n+    static native int strlen(String str);\n+\n+    static String makeString(int size) {\n+        String lorem = \"\"\"\n+                Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et\n+                 dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip\n+                 ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu\n+                 fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt\n+                 mollit anim id est laborum.\n+                \"\"\";\n+        return lorem.substring(0, size);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/StrLenTest.java","additions":180,"deletions":0,"binary":false,"changes":180,"status":"added"},{"patch":"@@ -27,1 +27,0 @@\n-import jdk.incubator.foreign.MemoryAddress;\n@@ -89,1 +88,1 @@\n-    static final VarHandle VH_addr_int = MemoryLayout.ofSequence(MemoryLayouts.JAVA_INT)\n+    static final VarHandle VH_addr_int = MemoryLayout.sequenceLayout(MemoryLayouts.JAVA_INT)\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/TestAdaptVarHandles.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -35,1 +35,0 @@\n-import java.lang.invoke.MethodHandles;\n@@ -37,1 +36,0 @@\n-import java.lang.reflect.Field;\n@@ -51,1 +49,1 @@\n-    static final VarHandle LONG_HANDLE = MemoryLayout.ofSequence(SIZE, MemoryLayouts.JAVA_LONG)\n+    static final VarHandle LONG_HANDLE = MemoryLayout.sequenceLayout(SIZE, MemoryLayouts.JAVA_LONG)\n@@ -70,2 +68,2 @@\n-            this.inputSegment = MemoryAddress.ofLong(inputAddress).asSegmentRestricted(8*SIZE);\n-            this.outputSegment = MemoryAddress.ofLong(outputAddress).asSegmentRestricted(8*SIZE);\n+            this.inputSegment = MemoryAddress.ofLong(inputAddress).asSegment(8*SIZE, ResourceScope.globalScope());\n+            this.outputSegment = MemoryAddress.ofLong(outputAddress).asSegment(8*SIZE, ResourceScope.globalScope());\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/UnrolledAccess.java","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import jdk.incubator.foreign.ResourceScope;\n@@ -43,0 +44,1 @@\n+import static jdk.incubator.foreign.CLinker.C_DOUBLE;\n@@ -44,0 +46,1 @@\n+import static jdk.incubator.foreign.CLinker.C_LONG_LONG;\n@@ -51,1 +54,1 @@\n-@Fork(value = 3, jvmArgsAppend = { \"--add-modules=jdk.incubator.foreign\", \"-Dforeign.restricted=permit\" })\n+@Fork(value = 3, jvmArgsAppend = { \"--add-modules=jdk.incubator.foreign\", \"--enable-native-access=ALL-UNNAMED\" })\n@@ -57,0 +60,2 @@\n+    static final MethodHandle args5;\n+    static final MethodHandle args10;\n@@ -60,0 +65,2 @@\n+    static final MemoryAddress cb_args5;\n+    static final MemoryAddress cb_args10;\n@@ -63,0 +70,2 @@\n+    static final long cb_args5_jni;\n+    static final long cb_args10_jni;\n@@ -70,0 +79,2 @@\n+        cb_args5_jni = makeCB(className, \"args5\", \"(JDJDJ)V\");\n+        cb_args10_jni = makeCB(className, \"args10\", \"(JDJDJDJDJD)V\");\n@@ -74,9 +85,24 @@\n-                LibraryLookup.Symbol addr = ll.lookup(\"blank\").get();\n-                MethodType mt = MethodType.methodType(void.class, MemoryAddress.class);\n-                FunctionDescriptor fd = FunctionDescriptor.ofVoid(C_POINTER);\n-                blank = abi.downcallHandle(addr, mt, fd);\n-\n-                cb_blank = abi.upcallStub(\n-                    lookup().findStatic(Upcalls.class, \"blank\", MethodType.methodType(void.class)),\n-                    FunctionDescriptor.ofVoid()\n-                ).address();\n+                String name = \"blank\";\n+                MethodType mt = MethodType.methodType(void.class);\n+                FunctionDescriptor fd = FunctionDescriptor.ofVoid();\n+\n+                blank = linkFunc(ll, name, mt, fd);\n+                cb_blank = makeCB(name, mt, fd);\n+            }\n+            {\n+                String name = \"identity\";\n+                MethodType mt = MethodType.methodType(int.class, int.class);\n+                FunctionDescriptor fd = FunctionDescriptor.of(C_INT, C_INT);\n+\n+                identity = linkFunc(ll, name, mt, fd);\n+                cb_identity = makeCB(name, mt, fd);\n+            }\n+            {\n+                String name = \"args5\";\n+                MethodType mt = MethodType.methodType(void.class,\n+                        long.class, double.class, long.class, double.class, long.class);\n+                FunctionDescriptor fd = FunctionDescriptor.ofVoid(\n+                        C_LONG_LONG, C_DOUBLE, C_LONG_LONG, C_DOUBLE, C_LONG_LONG);\n+\n+                args5 = linkFunc(ll, name, mt, fd);\n+                cb_args5 = makeCB(name, mt, fd);\n@@ -85,9 +111,10 @@\n-                LibraryLookup.Symbol addr = ll.lookup(\"identity\").get();\n-                MethodType mt = MethodType.methodType(int.class, int.class, MemoryAddress.class);\n-                FunctionDescriptor fd = FunctionDescriptor.of(C_INT, C_INT, C_POINTER);\n-                identity = abi.downcallHandle(addr, mt, fd);\n-\n-                cb_identity = abi.upcallStub(\n-                    lookup().findStatic(Upcalls.class, \"identity\", MethodType.methodType(int.class, int.class)),\n-                    FunctionDescriptor.of(C_INT, C_INT)\n-                ).address();\n+                String name = \"args10\";\n+                MethodType mt = MethodType.methodType(void.class,\n+                        long.class, double.class, long.class, double.class, long.class,\n+                        double.class, long.class, double.class, long.class, double.class);\n+                FunctionDescriptor fd = FunctionDescriptor.ofVoid(\n+                        C_LONG_LONG, C_DOUBLE, C_LONG_LONG, C_DOUBLE, C_LONG_LONG,\n+                        C_DOUBLE, C_LONG_LONG, C_DOUBLE, C_LONG_LONG, C_DOUBLE);\n+\n+                args10 = linkFunc(ll, name, mt, fd);\n+                cb_args10 = makeCB(name, mt, fd);\n@@ -100,0 +127,15 @@\n+    static MethodHandle linkFunc(LibraryLookup ll, String name, MethodType baseType, FunctionDescriptor baseDesc) {\n+        return abi.downcallHandle(\n+            ll.lookup(name).orElseThrow(),\n+            baseType.insertParameterTypes(baseType.parameterCount(), MemoryAddress.class),\n+            baseDesc.withAppendedArgumentLayouts(C_POINTER)\n+        );\n+    }\n+\n+    static MemoryAddress makeCB(String name, MethodType mt, FunctionDescriptor fd) throws ReflectiveOperationException {\n+        return abi.upcallStub(\n+            lookup().findStatic(Upcalls.class, name, mt),\n+            fd, ResourceScope.globalScope()\n+        ).address();\n+    }\n+\n@@ -102,0 +144,3 @@\n+    static native void args5(long a0, double a1, long a2, double a3, long a4, long cb);\n+    static native void args10(long a0, double a1, long a2, double a3, long a4,\n+                              double a5, long a6, double a7, long a8, double a9, long cb);\n@@ -119,0 +164,10 @@\n+    @Benchmark\n+    public void jni_args5() throws Throwable {\n+        args5(1L, 2D, 3L, 4D, 5L, cb_args5_jni);\n+    }\n+\n+    @Benchmark\n+    public void jni_args10() throws Throwable {\n+        args10(1L, 2D, 3L, 4D, 5L, 6D, 7L, 8D, 9L, 10D, cb_args10_jni);\n+    }\n+\n@@ -124,0 +179,10 @@\n+    @Benchmark\n+    public void panama_args5() throws Throwable {\n+        args5.invokeExact(1L, 2D, 3L, 4D, 5L, cb_args5);\n+    }\n+\n+    @Benchmark\n+    public void panama_args10() throws Throwable {\n+        args10.invokeExact(1L, 2D, 3L, 4D, 5L, 6D, 7L, 8D, 9L, 10D, cb_args10);\n+    }\n+\n@@ -126,0 +191,3 @@\n+    static void args5(long a0, double a1, long a2, double a3, long a4) { }\n+    static void args10(long a0, double a1, long a2, double a3, long a4,\n+                       double a5, long a6, double a7, long a8, double a9) { }\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/Upcalls.java","additions":87,"deletions":19,"binary":false,"changes":106,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.incubator.foreign.ResourceScope;\n@@ -52,1 +53,1 @@\n-@Fork(value = 3, jvmArgsAppend = { \"--add-modules=jdk.incubator.foreign\", \"-Dforeign.restricted=permit\" })\n+@Fork(value = 3, jvmArgsAppend = { \"--add-modules=jdk.incubator.foreign\", \"--enable-native-access=ALL-UNNAMED\" })\n@@ -66,1 +67,1 @@\n-                MethodType.methodType(void.class, int.class, VaList.class),\n+                MethodType.methodType(void.class, int.class, CLinker.VaList.class),\n@@ -78,5 +79,5 @@\n-        try (CLinker.VaList vaList = CLinker.VaList.make(b ->\n-            b.vargFromInt(C_INT, 1)\n-             .vargFromDouble(C_DOUBLE, 2D)\n-             .vargFromLong(C_LONG_LONG, 3L)\n-        )) {\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            CLinker.VaList vaList = CLinker.VaList.make(b ->\n+                    b.vargFromInt(C_INT, 1)\n+                            .vargFromDouble(C_DOUBLE, 2D)\n+                            .vargFromLong(C_LONG_LONG, 3L), scope);\n@@ -84,1 +85,1 @@\n-                                  vaList);\n+                    vaList);\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/VaList.java","additions":9,"deletions":8,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import jdk.incubator.foreign.ResourceScope;\n@@ -64,1 +65,1 @@\n-        data = MemorySegment.allocateNative(JAVA_INT);\n+        data = MemorySegment.allocateNative(JAVA_INT, ResourceScope.newConfinedScope());\n@@ -69,1 +70,1 @@\n-        data.close();\n+        data.scope().close();\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/VarHandleExact.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,0 +49,4 @@\n+EXPORT void args1(long long a0) {}\n+EXPORT void args2(long long a0, double a1) {}\n+EXPORT void args3(long long a0, double a1, long long a2) {}\n+EXPORT void args4(long long a0, double a1, long long a2, double a3) {}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/libCallOverhead.c","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,0 +24,2 @@\n+#include <stdlib.h>\n+#include \"libCallOverhead.c\"\n@@ -25,7 +27,1 @@\n-void func() {}\n-\n-int identity(int x) {\n-  return x;\n-}\n-\n-JNIEXPORT void JNICALL Java_org_openjdk_bench_jdk_incubator_foreign_CallOverhead_blank\n+JNIEXPORT void JNICALL Java_org_openjdk_bench_jdk_incubator_foreign_CallOverheadHelper_blank\n@@ -36,1 +32,1 @@\n-JNIEXPORT jint JNICALL Java_org_openjdk_bench_jdk_incubator_foreign_CallOverhead_identity\n+JNIEXPORT jint JNICALL Java_org_openjdk_bench_jdk_incubator_foreign_CallOverheadHelper_identity\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/libCallOverheadJNI.c","additions":5,"deletions":9,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -0,0 +1,35 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <jni.h>\n+#include <stdlib.h>\n+#include <string.h>\n+\n+JNIEXPORT jint JNICALL Java_org_openjdk_bench_jdk_incubator_foreign_StrLenTest_strlen(JNIEnv *const env, const jclass cls, const jstring text) {\n+    const char *str = (*env)->GetStringUTFChars(env, text, NULL);\n+    int len = (int)strlen(str);\n+    (*env)->ReleaseStringUTFChars(env, text, str);\n+    return len;\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/libStrLen.c","additions":35,"deletions":0,"binary":false,"changes":35,"status":"added"},{"patch":"@@ -37,0 +37,12 @@\n+\n+EXPORT void args5(long long a0, double a1, long long a2, double a3, long long a4,\n+                  void (*cb)(long long, double, long long, double, long long)) {\n+    cb(a0, a1, a2, a3, a4);\n+}\n+\n+EXPORT void args10(long long a0, double a1, long long a2, double a3, long long a4,\n+                   double a5, long long a6, double a7, long long a8, double a9,\n+                   void (*cb)(long long, double, long long, double, long long,\n+                              double, long long, double, long long, double)) {\n+    cb(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9);\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/libUpcalls.c","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -27,8 +27,0 @@\n-void blank(void (*cb)(void)) {\n-    cb();\n-}\n-\n-int identity(int x, int (*cb)(int)) {\n-    return cb(x);\n-}\n-\n@@ -85,0 +77,17 @@\n+\n+JNIEXPORT jint JNICALL Java_org_openjdk_bench_jdk_incubator_foreign_Upcalls_args5\n+  (JNIEnv *env, jclass cls,\n+      jlong a0, jdouble a1, jlong a2, jdouble a3, jlong a4,\n+      jlong cb) {\n+    JNICB jniCb = jlong_to_ptr(cb);\n+    return (*env)->CallStaticIntMethod(env, jniCb->holder, jniCb->mid, a0, a1, a2, a3, a4);\n+}\n+\n+JNIEXPORT jint JNICALL Java_org_openjdk_bench_jdk_incubator_foreign_Upcalls_args10\n+  (JNIEnv *env, jclass cls,\n+      jlong a0, jdouble a1, jlong a2, jdouble a3, jlong a4,\n+      jdouble a5, jlong a6, jdouble a7, jlong a8, jdouble a9,\n+      jlong cb) {\n+    JNICB jniCb = jlong_to_ptr(cb);\n+    return (*env)->CallStaticIntMethod(env, jniCb->holder, jniCb->mid, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9);\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/libUpcallsJNI.c","additions":17,"deletions":8,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-@Fork(value = 3, jvmArgsAppend = { \"--add-modules=jdk.incubator.foreign\", \"-Dforeign.restricted=permit\" })\n+@Fork(value = 3, jvmArgsAppend = { \"--add-modules=jdk.incubator.foreign\", \"--enable-native-access=ALL-UNNAMED\" })\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/points\/PointsAccess.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-@Fork(value = 3, jvmArgsAppend = { \"--add-modules=jdk.incubator.foreign\", \"-Dforeign.restricted=permit\" })\n+@Fork(value = 3, jvmArgsAppend = { \"--add-modules=jdk.incubator.foreign\", \"--enable-native-access=ALL-UNNAMED\" })\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/points\/PointsAlloc.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-@Fork(value = 3, jvmArgsAppend = { \"--add-modules=jdk.incubator.foreign\", \"-Dforeign.restricted=permit\" })\n+@Fork(value = 3, jvmArgsAppend = { \"--add-modules=jdk.incubator.foreign\", \"--enable-native-access=ALL-UNNAMED\" })\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/points\/PointsDistance.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-@Fork(value = 3, jvmArgsAppend = { \"--add-modules=jdk.incubator.foreign\", \"-Dforeign.restricted=permit\" })\n+@Fork(value = 3, jvmArgsAppend = { \"--add-modules=jdk.incubator.foreign\", \"--enable-native-access=ALL-UNNAMED\" })\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/points\/PointsFree.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import jdk.incubator.foreign.ResourceScope;\n@@ -41,1 +42,1 @@\n-    public static final MemoryLayout LAYOUT = MemoryLayout.ofStruct(\n+    public static final MemoryLayout LAYOUT = MemoryLayout.structLayout(\n@@ -69,1 +70,1 @@\n-        this(MemorySegment.allocateNative(LAYOUT), x, y);\n+        this(MemorySegment.allocateNative(LAYOUT, ResourceScope.newConfinedScope()), x, y);\n@@ -116,1 +117,1 @@\n-        segment.close();\n+        segment.scope().close();\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/points\/support\/PanamaPoint.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"}]}