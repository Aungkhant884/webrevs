{"files":[{"patch":"@@ -384,1 +384,3 @@\n-        if (isSmall()) {\n+        if (isSmall() &&\n+                offset < Integer.MAX_VALUE && length < Integer.MAX_VALUE &&\n+                offset > Integer.MIN_VALUE && length > Integer.MIN_VALUE) {\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/AbstractMemorySegmentImpl.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.incubator.foreign.MemoryAccess;\n@@ -105,0 +106,14 @@\n+    @Test(expectedExceptions = IndexOutOfBoundsException.class)\n+    public void testSmallSegmentMax() {\n+        long offset = (long)Integer.MAX_VALUE + (long)Integer.MAX_VALUE + 2L + 6L; \/\/ overflows to 6 when casted to int\n+        MemorySegment memorySegment = MemorySegment.allocateNative(10, ResourceScope.newImplicitScope());\n+        MemoryAccess.getIntAtOffset(memorySegment, offset);\n+    }\n+\n+    @Test(expectedExceptions = IndexOutOfBoundsException.class)\n+    public void testSmallSegmentMin() {\n+        long offset = ((long)Integer.MIN_VALUE * 2L) + 6L; \/\/ underflows to 6 when casted to int\n+        MemorySegment memorySegment = MemorySegment.allocateNative(10, ResourceScope.newImplicitScope());\n+        MemoryAccess.getIntAtOffset(memorySegment, offset);\n+    }\n+\n","filename":"test\/jdk\/java\/foreign\/TestSegments.java","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -100,5 +100,0 @@\n-    @TearDown\n-    public void tearDown() {\n-        segment.scope().close();\n-    }\n-\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/LoopOverNonConstantHeap.java","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"}]}