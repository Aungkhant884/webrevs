{"files":[{"patch":"@@ -2933,1 +2933,1 @@\n-G1CollectedHeap::G1HeapPrinterMark::G1HeapPrinterMark(G1CollectedHeap* g1h) : _g1h(g1h), _heap_transition(g1h) {\n+G1HeapPrinterMark::G1HeapPrinterMark(G1CollectedHeap* g1h) : _g1h(g1h), _heap_transition(g1h) {\n@@ -2940,1 +2940,1 @@\n-G1CollectedHeap::G1HeapPrinterMark::~G1HeapPrinterMark() {\n+G1HeapPrinterMark::~G1HeapPrinterMark() {\n@@ -2953,0 +2953,38 @@\n+G1JFRTracerMark::G1JFRTracerMark(STWGCTimer* timer, GCTracer* tracer) :\n+  _timer(timer), _tracer(tracer) {\n+\n+  _timer->register_gc_start();\n+  _tracer->report_gc_start(G1CollectedHeap::heap()->gc_cause(), _timer->gc_start());\n+  G1CollectedHeap::heap()->trace_heap_before_gc(_tracer);\n+}\n+\n+G1JFRTracerMark::~G1JFRTracerMark() {\n+  G1CollectedHeap::heap()->trace_heap_after_gc(_tracer);\n+  _timer->register_gc_end();\n+  _tracer->report_gc_end(_timer->gc_end(), _timer->time_partitions());\n+}\n+\n+class G1YoungGCJFRTracerMark : public G1JFRTracerMark {\n+  G1EvacuationInfo _evacuation_info;\n+\n+  G1NewTracer* tracer() const { return (G1NewTracer*)_tracer; }\n+\n+public:\n+\n+  G1EvacuationInfo* evacuation_info() { return &_evacuation_info; }\n+\n+  G1YoungGCJFRTracerMark(STWGCTimer* gc_timer_stw, G1NewTracer* gc_tracer_stw, GCCause::Cause cause) :\n+    G1JFRTracerMark(gc_timer_stw, gc_tracer_stw), _evacuation_info() { }\n+\n+  void report_pause_type(G1GCPauseType type) {\n+    tracer()->report_young_gc_pause(type);\n+  }\n+\n+  ~G1YoungGCJFRTracerMark() {\n+    G1CollectedHeap* g1h = G1CollectedHeap::heap();\n+\n+    tracer()->report_evacuation_info(&_evacuation_info);\n+    tracer()->report_tenuring_threshold(g1h->policy()->tenuring_threshold());\n+  }\n+};\n+\n@@ -2961,2 +2999,0 @@\n-  gc_tracer_report_gc_start();\n-\n@@ -2965,2 +3001,0 @@\n-  trace_heap_before_gc(_gc_tracer_stw);\n-\n@@ -2989,2 +3023,0 @@\n-    G1EvacuationInfo evacuation_info;\n-\n@@ -3001,0 +3033,2 @@\n+    \/\/ JFR\n+    G1YoungGCJFRTracerMark jtm(_gc_timer_stw, _gc_tracer_stw, gc_cause());\n@@ -3036,1 +3070,1 @@\n-        calculate_collection_set(evacuation_info, target_pause_time_ms);\n+        calculate_collection_set(*jtm.evacuation_info(), target_pause_time_ms);\n@@ -3044,1 +3078,1 @@\n-        pre_evacuate_collection_set(evacuation_info, &per_thread_states);\n+        pre_evacuate_collection_set(*jtm.evacuation_info(), &per_thread_states);\n@@ -3053,1 +3087,1 @@\n-        post_evacuate_collection_set(evacuation_info, &rdcqs, &per_thread_states);\n+        post_evacuate_collection_set(*jtm.evacuation_info(), &rdcqs, &per_thread_states);\n@@ -3088,4 +3122,0 @@\n-\n-    trace_heap_after_gc(_gc_tracer_stw);\n-\n-    gc_tracer_report_gc_end(concurrent_operation_is_full_mark, evacuation_info);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":45,"deletions":15,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -156,0 +156,1 @@\n+  friend class G1HeapPrinterMark;\n@@ -1475,1 +1476,0 @@\n-  class G1HeapPrinterMark;\n@@ -1494,1 +1494,2 @@\n-class G1CollectedHeap::G1HeapPrinterMark : public StackObj {\n+\/\/ Scoped object that performs common pre- and post-gc heap printing operations.\n+class G1HeapPrinterMark : public StackObj {\n@@ -1503,0 +1504,12 @@\n+\/\/ Scoped object that performs common pre- and post-gc operations related to\n+\/\/ JFR events.\n+class G1JFRTracerMark : public StackObj {\n+protected:\n+  STWGCTimer* _timer;\n+  GCTracer* _tracer;\n+\n+public:\n+  G1JFRTracerMark(STWGCTimer* timer, GCTracer* tracer);\n+  ~G1JFRTracerMark();\n+};\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":15,"deletions":2,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -28,0 +28,10 @@\n+G1FullGCJFRTracerMark::G1FullGCJFRTracerMark(STWGCTimer* timer, GCTracer* tracer)\n+  : G1JFRTracerMark(timer, tracer) {\n+\n+  G1CollectedHeap::heap()->pre_full_gc_dump(_timer);\n+}\n+\n+G1FullGCJFRTracerMark::~G1FullGCJFRTracerMark() {\n+  G1CollectedHeap::heap()->post_full_gc_dump(_timer);\n+}\n+\n@@ -41,0 +51,1 @@\n+    _tracer_mark(&_timer, &_tracer),\n@@ -46,13 +57,1 @@\n-                                 (1 - MarkSweepDeadRatio \/ 100.0) * HeapRegion::GrainWords) {\n-  _timer.register_gc_start();\n-  _tracer.report_gc_start(_g1h->gc_cause(), _timer.gc_start());\n-  _g1h->pre_full_gc_dump(&_timer);\n-  _g1h->trace_heap_before_gc(&_tracer);\n-}\n-\n-G1FullGCScope::~G1FullGCScope() {\n-  _g1h->trace_heap_after_gc(&_tracer);\n-  _g1h->post_full_gc_dump(&_timer);\n-  _timer.register_gc_end();\n-  _tracer.report_gc_end(_timer.gc_end(), _timer.time_partitions());\n-}\n+                                 (1 - MarkSweepDeadRatio \/ 100.0) * HeapRegion::GrainWords) { }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCScope.cpp","additions":12,"deletions":13,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -42,0 +42,7 @@\n+class G1FullGCJFRTracerMark : public G1JFRTracerMark {\n+public:\n+\n+  G1FullGCJFRTracerMark(STWGCTimer* timer, GCTracer* tracer);\n+  ~G1FullGCJFRTracerMark();\n+};\n+\n@@ -53,0 +60,1 @@\n+  G1FullGCJFRTracerMark   _tracer_mark;\n@@ -55,1 +63,1 @@\n-  G1CollectedHeap::G1HeapPrinterMark _heap_printer;\n+  G1HeapPrinterMark       _heap_printer;\n@@ -63,1 +71,1 @@\n-  ~G1FullGCScope();\n+  ~G1FullGCScope() { }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCScope.hpp","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1,1 +0,0 @@\n-<<<<<<< HEAD\n@@ -84,85 +83,0 @@\n-||||||| parent of ab8613e8780 (Initial implementation)\n-=======\n-\/*\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package gc.g1;\n-\n-\/*\n- * @test TestEvacuationFailure\n- * @summary Ensure the output for a minor GC with G1 that has evacuation failure contains the correct strings.\n- * @requires vm.gc.G1\n- * @requires vm.debug\n- * @library \/test\/lib\n- * @modules java.base\/jdk.internal.misc\n- *          java.management\n- * @build sun.hotspot.WhiteBox\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n- *                   gc.g1.TestEvacuationFailure\n- *\/\n-\n-import jdk.test.lib.process.OutputAnalyzer;\n-import jdk.test.lib.Platform;\n-import jdk.test.lib.process.ProcessTools;\n-\n-public class TestEvacuationFailure {\n-\n-    public static void main(String[] args) throws Exception {\n-        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(\"-XX:+UseG1GC\",\n-                                                                  \"-Xmx32M\",\n-                                                                  \"-Xmn16M\",\n-                                                                  \"-XX:+G1EvacuationFailureALot\",\n-                                                                  \"-XX:G1EvacuationFailureALotCount=100\",\n-                                                                  \"-XX:G1EvacuationFailureALotInterval=1\",\n-                                                                  \"-XX:+UnlockDiagnosticVMOptions\",\n-                                                                  \"-XX:-G1UsePreventiveGC\",\n-                                                                  \"-Xlog:gc\",\n-                                                                  GCTestWithEvacuationFailure.class.getName());\n-\n-        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n-        System.out.println(output.getStdout());\n-        output.shouldContain(\"(Evacuation Failure)\");\n-        output.shouldHaveExitValue(0);\n-    }\n-\n-    static class GCTestWithEvacuationFailure {\n-        private static byte[] garbage;\n-        private static byte[] largeObject;\n-        private static Object[] holder = new Object[200]; \/\/ Must be larger than G1EvacuationFailureALotCount\n-\n-        public static void main(String [] args) {\n-            largeObject = new byte[16 * 1024 * 1024];\n-            System.out.println(\"Creating garbage\");\n-            \/\/ Create 16 MB of garbage. This should result in at least one GC,\n-            \/\/ (Heap size is 32M, we use 17MB for the large object above)\n-            \/\/ which is larger than G1EvacuationFailureALotInterval.\n-            for (int i = 0; i < 16 * 1024; i++) {\n-                holder[i % holder.length] = new byte[1024];\n-            }\n-            System.out.println(\"Done\");\n-        }\n-    }\n-}\n-\n->>>>>>> ab8613e8780 (Initial implementation)\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestEvacuationFailure.java","additions":0,"deletions":86,"binary":false,"changes":86,"status":"modified"}]}