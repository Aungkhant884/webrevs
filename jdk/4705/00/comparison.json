{"files":[{"patch":"@@ -983,1 +983,5 @@\n-void G1CollectedHeap::print_hrm_post_compaction() {\n+void G1CollectedHeap::print_heap_after_full_collection() {\n+  \/\/ Post collection region logging.\n+  \/\/ We should do this after we potentially resize the heap so\n+  \/\/ that all the COMMIT \/ UNCOMMIT events are generated before\n+  \/\/ the compaction events.\n@@ -1095,11 +1099,0 @@\n-void G1CollectedHeap::print_heap_after_full_collection(G1HeapTransition* heap_transition) {\n-  \/\/ Post collection logging.\n-  \/\/ We should do this after we potentially resize the heap so\n-  \/\/ that all the COMMIT \/ UNCOMMIT events are generated before\n-  \/\/ the compaction events.\n-  print_hrm_post_compaction();\n-  heap_transition->print();\n-  print_heap_after_gc();\n-  print_heap_regions();\n-}\n-\n@@ -2575,3 +2568,0 @@\n-  \/\/ This summary needs to be printed before incrementing total collections.\n-  rem_set()->print_periodic_summary_info(\"Before GC RS summary\", total_collections());\n-\n@@ -2610,3 +2600,0 @@\n-  \/\/ We are at the end of the GC. Total collections has already been increased.\n-  rem_set()->print_periodic_summary_info(\"After GC RS summary\", total_collections() - 1);\n-\n@@ -2625,3 +2612,0 @@\n-  \/\/ Print NUMA statistics.\n-  _numa->print_statistics();\n-\n@@ -2949,0 +2933,20 @@\n+G1CollectedHeap::G1HeapPrinterMark::G1HeapPrinterMark(G1CollectedHeap* g1h) : _g1h(g1h), _heap_transition(g1h) {\n+  \/\/ This summary needs to be printed before incrementing total collections.\n+  _g1h->rem_set()->print_periodic_summary_info(\"Before GC RS summary\", _g1h->total_collections());\n+  _g1h->print_heap_before_gc();\n+  _g1h->print_heap_regions();\n+}\n+\n+G1CollectedHeap::G1HeapPrinterMark::~G1HeapPrinterMark() {\n+  _g1h->policy()->print_age_table();\n+  _g1h->rem_set()->print_coarsen_stats();\n+\n+  _heap_transition.print();\n+  _g1h->print_heap_regions();\n+  _g1h->print_heap_after_gc();\n+  \/\/ We are at the end of the GC. Total collections has already been increased.\n+  _g1h->rem_set()->print_periodic_summary_info(\"After GC RS summary\", _g1h->total_collections() - 1);\n+  \/\/ Print NUMA statistics.\n+  _g1h->numa()->print_statistics();\n+}\n+\n@@ -2961,2 +2965,0 @@\n-  print_heap_before_gc();\n-  print_heap_regions();\n@@ -3004,1 +3006,1 @@\n-    G1HeapTransition heap_transition(this);\n+    G1HeapPrinterMark hpm(this);\n@@ -3083,1 +3085,0 @@\n-    heap_transition.print();\n@@ -3088,2 +3089,0 @@\n-    print_heap_after_gc();\n-    print_heap_regions();\n@@ -3822,3 +3821,0 @@\n-\n-  policy()->print_age_table();\n-  rem_set()->print_coarsen_stats();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":26,"deletions":30,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -320,4 +320,0 @@\n-  \/\/ If the HR printer is active, dump the state of the regions in the\n-  \/\/ heap after a compaction.\n-  void print_hrm_post_compaction();\n-\n@@ -540,1 +536,1 @@\n-  void print_heap_after_full_collection(G1HeapTransition* heap_transition);\n+  void print_heap_after_full_collection();\n@@ -1479,0 +1475,2 @@\n+  class G1HeapPrinterMark;\n+\n@@ -1496,0 +1494,9 @@\n+class G1CollectedHeap::G1HeapPrinterMark : public StackObj {\n+  G1CollectedHeap* _g1h;\n+  G1HeapTransition _heap_transition;\n+\n+public:\n+  G1HeapPrinterMark(G1CollectedHeap* g1h);\n+  ~G1HeapPrinterMark();\n+};\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":12,"deletions":5,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -173,3 +173,0 @@\n-  _heap->print_heap_before_gc();\n-  _heap->print_heap_regions();\n-\n@@ -224,1 +221,1 @@\n-  _heap->print_heap_after_full_collection(scope()->heap_transition());\n+  _heap->print_heap_after_full_collection();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullCollector.cpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-    _heap_transition(_g1h),\n+    _heap_printer(_g1h),\n@@ -76,4 +76,0 @@\n-G1HeapTransition* G1FullGCScope::heap_transition() {\n-  return &_heap_transition;\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCScope.cpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n-  G1HeapTransition        _heap_transition;\n+  G1CollectedHeap::G1HeapPrinterMark _heap_printer;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCScope.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,1 @@\n+<<<<<<< HEAD\n@@ -83,0 +84,85 @@\n+||||||| parent of ab8613e8780 (Initial implementation)\n+=======\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package gc.g1;\n+\n+\/*\n+ * @test TestEvacuationFailure\n+ * @summary Ensure the output for a minor GC with G1 that has evacuation failure contains the correct strings.\n+ * @requires vm.gc.G1\n+ * @requires vm.debug\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.management\n+ * @build sun.hotspot.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   gc.g1.TestEvacuationFailure\n+ *\/\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.Platform;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class TestEvacuationFailure {\n+\n+    public static void main(String[] args) throws Exception {\n+        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(\"-XX:+UseG1GC\",\n+                                                                  \"-Xmx32M\",\n+                                                                  \"-Xmn16M\",\n+                                                                  \"-XX:+G1EvacuationFailureALot\",\n+                                                                  \"-XX:G1EvacuationFailureALotCount=100\",\n+                                                                  \"-XX:G1EvacuationFailureALotInterval=1\",\n+                                                                  \"-XX:+UnlockDiagnosticVMOptions\",\n+                                                                  \"-XX:-G1UsePreventiveGC\",\n+                                                                  \"-Xlog:gc\",\n+                                                                  GCTestWithEvacuationFailure.class.getName());\n+\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        System.out.println(output.getStdout());\n+        output.shouldContain(\"(Evacuation Failure)\");\n+        output.shouldHaveExitValue(0);\n+    }\n+\n+    static class GCTestWithEvacuationFailure {\n+        private static byte[] garbage;\n+        private static byte[] largeObject;\n+        private static Object[] holder = new Object[200]; \/\/ Must be larger than G1EvacuationFailureALotCount\n+\n+        public static void main(String [] args) {\n+            largeObject = new byte[16 * 1024 * 1024];\n+            System.out.println(\"Creating garbage\");\n+            \/\/ Create 16 MB of garbage. This should result in at least one GC,\n+            \/\/ (Heap size is 32M, we use 17MB for the large object above)\n+            \/\/ which is larger than G1EvacuationFailureALotInterval.\n+            for (int i = 0; i < 16 * 1024; i++) {\n+                holder[i % holder.length] = new byte[1024];\n+            }\n+            System.out.println(\"Done\");\n+        }\n+    }\n+}\n+\n+>>>>>>> ab8613e8780 (Initial implementation)\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestEvacuationFailure.java","additions":86,"deletions":0,"binary":false,"changes":86,"status":"modified"}]}