{"files":[{"patch":"@@ -191,1 +191,1 @@\n-        out.format(\"    \\\"processId\\\": %d,%n\", processId());\n+        out.format(\"    \\\"processId\\\": \\\"%d\\\",%n\", processId());\n@@ -229,1 +229,1 @@\n-            out.format(\"        \\\"owner\\\": %d,%n\", owner.threadId());\n+            out.format(\"        \\\"owner\\\": \\\"%d\\\",%n\", owner.threadId());\n@@ -244,1 +244,1 @@\n-        out.format(\"        \\\"threadCount\\\": %d%n\", threadCount);\n+        out.format(\"        \\\"threadCount\\\": \\\"%d\\\"%n\", threadCount);\n@@ -258,1 +258,1 @@\n-        out.format(\"           \\\"tid\\\": %d,%n\", thread.threadId());\n+        out.format(\"           \\\"tid\\\": \\\"%d\\\",%n\", thread.threadId());\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/ThreadDumper.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * @bug 8284161 8287008\n@@ -37,0 +38,2 @@\n+import jdk.test.lib.threaddump.ThreadDump;\n+\n@@ -68,2 +71,6 @@\n-        \/\/ test that the threadDump object is present\n-        assertTrue(find(file, \"threadDump\"), \"`threadDump` not found in \" + file);\n+        \/\/ parse the JSON text\n+        String jsonText = Files.readString(file);\n+        ThreadDump threadDump = ThreadDump.parse(jsonText);\n+\n+        \/\/ test that the process id is this process\n+        assertTrue(threadDump.processId() == ProcessHandle.current().pid());\n@@ -71,4 +78,4 @@\n-        \/\/ test that thread dump contains the id of the current thread\n-        long tid = Thread.currentThread().threadId();\n-        String expected = \"\\\"tid\\\": \" + tid;\n-        assertTrue(find(file, expected), expected + \" not found in \" + file);\n+        \/\/ test that the current thread is in the root thread container\n+        var rootContainer = threadDump.rootThreadContainer();\n+        var tid = Thread.currentThread().threadId();\n+        rootContainer.findThread(tid).orElseThrow();\n","filename":"test\/hotspot\/jtreg\/serviceability\/dcmd\/thread\/ThreadDumpToFileTest.java","additions":13,"deletions":6,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * @bug 8284161 8287008\n@@ -27,5 +28,6 @@\n- * @compile --enable-preview -source ${jdk.version} DumpThreads.java\n- * @run testng\/othervm --enable-preview DumpThreads\n- * @run testng\/othervm --enable-preview -Djdk.trackAllThreads DumpThreads\n- * @run testng\/othervm --enable-preview -Djdk.trackAllThreads=true DumpThreads\n- * @run testng\/othervm --enable-preview -Djdk.trackAllThreadds=false DumpThreads\n+ * @enablePreview\n+ * @library \/test\/lib\n+ * @run testng\/othervm DumpThreads\n+ * @run testng\/othervm -Djdk.trackAllThreads DumpThreads\n+ * @run testng\/othervm -Djdk.trackAllThreads=true DumpThreads\n+ * @run testng\/othervm -Djdk.trackAllThreadds=false DumpThreads\n@@ -38,0 +40,1 @@\n+import java.time.ZonedDateTime;\n@@ -45,0 +48,1 @@\n+import jdk.test.lib.threaddump.ThreadDump;\n@@ -106,5 +110,3 @@\n-                assertTrue(count(file, \"threadDump\") >= 1L);\n-                assertTrue(count(file, \"time\") >= 1L);\n-                assertTrue(count(file, \"runtimeVersion\") >= 1L);\n-                assertTrue(count(file, \"threadContainers\") >= 1L);\n-                assertTrue(count(file, \"threads\") >= 1L);\n+                \/\/ parse the JSON text\n+                String jsonText = Files.readString(file);\n+                ThreadDump threadDump = ThreadDump.parse(jsonText);\n@@ -112,2 +114,2 @@\n-                \/\/ virtual thread should be found\n-                assertTrue(isJsonPresent(file, vthread));\n+                \/\/ test threadDump\/processId\n+                assertTrue(threadDump.processId() == ProcessHandle.current().pid());\n@@ -115,1 +117,12 @@\n-                \/\/ if the current thread is a platform thread then it should be included\n+                \/\/ test threadDump\/time can be parsed\n+                ZonedDateTime.parse(threadDump.time());\n+\n+                \/\/ test threadDump\/runtimeVersion\n+                assertEquals(threadDump.runtimeVersion(), Runtime.version().toString());\n+\n+                \/\/ test root container\n+                var rootContainer = threadDump.rootThreadContainer();\n+                assertFalse(rootContainer.owner().isPresent());\n+                assertFalse(rootContainer.parent().isPresent());\n+\n+                \/\/ if the current thread is a platform thread then it will be in root container\n@@ -118,1 +131,1 @@\n-                    assertTrue(isJsonPresent(file, currentThread));\n+                    rootContainer.findThread(currentThread.threadId()).orElseThrow();\n@@ -121,0 +134,6 @@\n+                \/\/ find the thread container for the executor\n+                String name = executor.toString();\n+                var container = threadDump.findThreadContainer(name).orElseThrow();\n+                assertFalse(container.owner().isPresent());\n+                assertTrue(container.parent().get() == rootContainer);\n+                container.findThread(vthread.threadId()).orElseThrow();\n@@ -191,8 +210,0 @@\n-    \/**\n-     * Returns true if the file contains \"tid\": <tid>\n-     *\/\n-    private static boolean isJsonPresent(Path file, Thread thread) throws Exception {\n-        String expect = \"\\\"tid\\\": \" + thread.threadId();\n-        return count(file, expect) > 0;\n-    }\n-\n","filename":"test\/jdk\/com\/sun\/management\/HotSpotDiagnosticMXBean\/DumpThreads.java","additions":33,"deletions":22,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -0,0 +1,370 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.test.lib.threaddump;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.OptionalLong;\n+import java.util.Set;\n+import java.util.stream.Stream;\n+import jdk.test.lib.json.JSONValue;\n+\n+\/**\n+ * Represents a thread dump that is obtained by parsing JSON text. A thread dump in JSON\n+ * format is generated with the {@code com.sun.management.HotSpotDiagnosticMXBean} API or\n+ * using {@code jcmd <pid> Thread.dump_to_file -format=json <file>}.\n+ *\n+ * <p> The following is an example thread dump that is parsed by this class. Many of the\n+ * objects are collapsed to reduce the size.\n+ *\n+ * <pre>{@code\n+ * {\n+ *   \"threadDump\": {\n+ *     \"processId\": \"63406\",\n+ *     \"time\": \"2022-05-20T07:37:16.308017Z\",\n+ *     \"runtimeVersion\": \"19\",\n+ *     \"threadContainers\": [\n+ *       {\n+ *         \"container\": \"<root>\",\n+ *         \"parent\": null,\n+ *         \"owner\": null,\n+ *         \"threads\": [\n+ *          {\n+ *            \"tid\": \"1\",\n+ *            \"name\": \"main\",\n+ *            \"stack\": [...]\n+ *          },\n+ *          {\n+ *            \"tid\": \"8\",\n+ *            \"name\": \"Reference Handler\",\n+ *            \"stack\": [\n+ *               \"java.base\\\/java.lang.ref.Reference.waitForReferencePendingList(Native Method)\",\n+ *               \"java.base\\\/java.lang.ref.Reference.processPendingReferences(Reference.java:245)\",\n+ *               \"java.base\\\/java.lang.ref.Reference$ReferenceHandler.run(Reference.java:207)\"\n+ *            ]\n+ *          },\n+ *          {\"name\": \"Finalizer\"...},\n+ *          {\"name\": \"Signal Dispatcher\"...},\n+ *          {\"name\": \"Common-Cleaner\"...},\n+ *          {\"name\": \"Monitor Ctrl-Break\"...},\n+ *          {\"name\": \"Notification Thread\"...}\n+ *         ],\n+ *         \"threadCount\": \"7\"\n+ *       },\n+ *       {\n+ *         \"container\": \"ForkJoinPool.commonPool\\\/jdk.internal.vm.SharedThreadContainer@56aac163\",\n+ *         \"parent\": \"<root>\",\n+ *         \"owner\": null,\n+ *         \"threads\": [...],\n+ *         \"threadCount\": \"1\"\n+ *       }\n+ *       {\n+ *         \"container\": \"java.util.concurrent.ThreadPoolExecutor@20322d26\\\/jdk.internal.vm.SharedThreadContainer@184f6be2\",\n+ *         \"parent\": \"<root>\",\n+ *         \"owner\": null,\n+ *         \"threads\": [...],\n+ *         \"threadCount\": \"1\"\n+ *       }\n+ *     ]\n+ *   }\n+ * }\n+ * }<\/pre>\n+ *\n+ * <p> The following is an example using this class to print the tree of thread containers\n+ * (grouping of threads) and the threads in each container:\n+ *\n+ * <pre>{@code\n+ *    void printThreadDump(Path file) throws IOException {\n+ *         String json = Files.readString(file);\n+ *         ThreadDump dump = ThreadDump.parse(json);\n+ *         printThreadContainer(dump.rootThreadContainer(), 0);\n+ *     }\n+ *\n+ *     void printThreadContainer(ThreadDump.ThreadContainer container, int indent) {\n+ *         out.printf(\"%s%s%n\", \" \".repeat(indent), container);\n+ *         container.threads().forEach(t -> out.printf(\"%s%s%n\", \" \".repeat(indent), t.name()));\n+ *         container.children().forEach(c -> printThreadContainer(c, indent + 2));\n+ *     }\n+ * }<\/pre>\n+ *\/\n+public final class ThreadDump {\n+    private final long processId;\n+    private final String time;\n+    private final String runtimeVersion;\n+    private ThreadContainer rootThreadContainer;\n+\n+    \/**\n+     * Represents an element in the threadDump\/threadContainers array.\n+     *\/\n+    public static class ThreadContainer {\n+        private final String name;\n+        private long owner;\n+        private ThreadContainer parent;\n+        private Set<ThreadInfo> threads;\n+        private final Set<ThreadContainer> children = new HashSet<>();\n+\n+        ThreadContainer(String name) {\n+            this.name = name;\n+        }\n+\n+        \/**\n+         * Returns the thread container name.\n+         *\/\n+        public String name() {\n+            return name;\n+        }\n+\n+        \/**\n+         * Return the thread identifier of the owner or empty OptionalLong if not owned.\n+         *\/\n+        public OptionalLong owner() {\n+           return (owner != 0) ? OptionalLong.of(owner) : OptionalLong.empty();\n+        }\n+\n+        \/**\n+         * Returns the parent thread container or empty Optional if this is the root.\n+         *\/\n+        public Optional<ThreadContainer> parent() {\n+            return Optional.ofNullable(parent);\n+        }\n+\n+        \/**\n+         * Returns a stream of the children thread containers.\n+         *\/\n+        public Stream<ThreadContainer> children() {\n+            return children.stream();\n+        }\n+\n+        \/**\n+         * Returns a stream of {@code ThreadInfo} objects for the threads in this container.\n+         *\/\n+        public Stream<ThreadInfo> threads() {\n+            return threads.stream();\n+        }\n+\n+        \/**\n+         * Finds the thread in this container with the given thread identifier.\n+         *\/\n+        public Optional<ThreadInfo> findThread(long tid) {\n+            return threads()\n+                    .filter(ti -> ti.tid() == tid)\n+                    .findAny();\n+        }\n+\n+\n+        \/**\n+         * Helper method to recursively find a container with the given name.\n+         *\/\n+        ThreadContainer findThreadContainer(String name) {\n+            if (name().equals(name))\n+                return this;\n+            if (name().startsWith(name + \"\/\"))\n+                return this;\n+            return children()\n+                    .map(c -> c.findThreadContainer(name))\n+                    .filter(c -> c != null)\n+                    .findAny()\n+                    .orElse(null);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return name.hashCode();\n+        }\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            if (obj instanceof ThreadContainer other) {\n+                return name.equals(other.name);\n+            } else {\n+                return false;\n+            }\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return name;\n+        }\n+    }\n+\n+    \/**\n+     * Represents an element in the threadDump\/threadContainers\/threads array.\n+     *\/\n+    public static final class ThreadInfo {\n+        private final long tid;\n+        private final String name;\n+        private final List<String> stack;\n+\n+        ThreadInfo(long tid, String name, List<String> stack) {\n+            this.tid = tid;\n+            this.name = name;\n+            this.stack = stack;\n+        }\n+\n+        \/**\n+         * Returns the thread identifier.\n+         *\/\n+        public long tid() {\n+            return tid;\n+        }\n+\n+        \/**\n+         * Returns the thread name.\n+         *\/\n+        public String name() {\n+            return name;\n+        }\n+\n+        \/**\n+         * Returns the thread stack.\n+         *\/\n+        public Stream<String> stack() {\n+            return stack.stream();\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Long.hashCode(tid);\n+        }\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            if (obj instanceof ThreadInfo other) {\n+                return this.tid == other.tid;\n+            } else {\n+                return false;\n+            }\n+        }\n+\n+        @Override\n+        public String toString() {\n+            StringBuilder sb = new StringBuilder(\"#\");\n+            sb.append(tid);\n+            if (name.length() > 0) {\n+                sb.append(\",\");\n+                sb.append(name);\n+            }\n+            return sb.toString();\n+        }\n+    }\n+\n+    \/**\n+     * Parses the given JSON text as a thread dump.\n+     *\/\n+    private ThreadDump(String json) {\n+        JSONValue threadDumpObj = JSONValue.parse(json).get(\"threadDump\");\n+\n+        \/\/ maps container name to ThreadContainer\n+        Map<String, ThreadContainer> map = new HashMap<>();\n+\n+        \/\/ threadContainers array\n+        JSONValue threadContainersObj = threadDumpObj.get(\"threadContainers\");\n+        for (JSONValue containerObj : threadContainersObj.asArray()) {\n+            String name = containerObj.get(\"container\").asString();\n+            String parentName = containerObj.get(\"parent\").asString();\n+            String owner = containerObj.get(\"owner\").asString();\n+            JSONValue.JSONArray threadsObj = containerObj.get(\"threads\").asArray();\n+\n+            \/\/ threads array\n+            Set<ThreadInfo> threadInfos = new HashSet<>();\n+            for (JSONValue threadObj : threadsObj) {\n+                long tid = Long.parseLong(threadObj.get(\"tid\").asString());\n+                String threadName = threadObj.get(\"name\").asString();\n+                JSONValue.JSONArray stackObj = threadObj.get(\"stack\").asArray();\n+                List<String> stack = new ArrayList<>();\n+                for (JSONValue steObject : stackObj) {\n+                    stack.add(steObject.asString());\n+                }\n+                threadInfos.add(new ThreadInfo(tid, threadName, stack));\n+            }\n+\n+            \/\/ add to map if not already encountered\n+            var container = map.computeIfAbsent(name, k -> new ThreadContainer(name));\n+            if (owner != null)\n+                container.owner = Long.parseLong(owner);\n+            container.threads = threadInfos;\n+\n+            if (parentName == null) {\n+                rootThreadContainer = container;\n+            } else {\n+                \/\/ add parent to map if not already encountered and add to its set of children\n+                var parent = map.computeIfAbsent(parentName, k -> new ThreadContainer(parentName));\n+                container.parent = parent;\n+                parent.children.add(container);\n+            }\n+        }\n+\n+        this.processId = Long.parseLong(threadDumpObj.get(\"processId\").asString());\n+        this.time = threadDumpObj.get(\"time\").asString();\n+        this.runtimeVersion = threadDumpObj.get(\"runtimeVersion\").asString();\n+    }\n+\n+    \/**\n+     * Returns the value of threadDump\/processId.\n+     *\/\n+    public long processId() {\n+        return processId;\n+    }\n+\n+    \/**\n+     * Returns the value of threadDump\/time.\n+     *\/\n+    public String time() {\n+        return time;\n+    }\n+\n+    \/**\n+     * Returns the value of threadDump\/runtimeVersion.\n+     *\/\n+    public String runtimeVersion() {\n+        return runtimeVersion;\n+    }\n+\n+    \/**\n+     * Returns the root container in the threadDump\/threadContainers array.\n+     *\/\n+    public ThreadContainer rootThreadContainer() {\n+        return rootThreadContainer;\n+    }\n+\n+    \/**\n+     * Finds a container in the threadDump\/threadContainers array with the given name.\n+     *\/\n+    public Optional<ThreadContainer> findThreadContainer(String name) {\n+        ThreadContainer container = rootThreadContainer.findThreadContainer(name);\n+        return Optional.ofNullable(container);\n+    }\n+\n+    \/**\n+     * Parses JSON text as a thread dump.\n+     * @throws RuntimeException if an error occurs\n+     *\/\n+    public static ThreadDump parse(String json) {\n+        return new ThreadDump(json);\n+    }\n+}\n","filename":"test\/lib\/jdk\/test\/lib\/threaddump\/ThreadDump.java","additions":370,"deletions":0,"binary":false,"changes":370,"status":"added"}]}