{"files":[{"patch":"@@ -33,1 +33,1 @@\n-template <class E> class AllocationSite {\n+class AllocationSite {\n@@ -35,3 +35,2 @@\n-  NativeCallStack  _call_stack;\n-  E                e;\n-  MEMFLAGS         _flag;\n+  const NativeCallStack  _call_stack;\n+  const MEMFLAGS         _flag;\n@@ -41,1 +40,2 @@\n-  bool equals(const NativeCallStack& stack) const {\n+\n+  bool equals(const NativeCallStack& stack, MEMFLAGS flag) const {\n@@ -45,2 +45,2 @@\n-  bool equals(const AllocationSite<E>& other) const {\n-    return other.equals(_call_stack);\n+  bool equals(const AllocationSite& other) const {\n+    return equals(other._call_stack, other._flag);\n@@ -53,4 +53,0 @@\n-  \/\/ Information regarding this allocation\n-  E* data()             { return &e; }\n-  const E* peek() const { return &e; }\n-\n","filename":"src\/hotspot\/share\/services\/allocationSite.hpp","additions":7,"deletions":11,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -141,1 +141,1 @@\n-    if (site->flag() == flags && site->equals(key)) {\n+    if (site->flag() == flags && site->equals(key, flags)) {\n@@ -245,0 +245,76 @@\n+void MallocSiteTable::print_tuning_statistics(outputStream* st) {\n+\n+  AccessLock locker(&_access_count);\n+  if (locker.sharedLock()) {\n+      \/\/ Total number of allocation sites, include empty sites\n+    int total_entries = 0;\n+    \/\/ Number of allocation sites that have all memory freed\n+    int empty_entries = 0;\n+    \/\/ Number of captured call stack distribution\n+    int stack_depth_distribution[NMT_TrackingStackDepth + 1] = { 0 };\n+    \/\/ Chain lengths\n+    int lengths[table_size] = { 0 };\n+\n+    for (int i = 0; i < table_size; i ++) {\n+      int this_chain_length = 0;\n+      const MallocSiteHashtableEntry* head = _table[i];\n+      while (head != NULL) {\n+        total_entries ++;\n+        this_chain_length ++;\n+        if (head->size() == 0) {\n+          empty_entries ++;\n+        }\n+        const int callstack_depth = head->peek()->call_stack()->frames();\n+        assert(callstack_depth >= 0 && callstack_depth <= NMT_TrackingStackDepth,\n+               \"Sanity (%d)\", callstack_depth);\n+        stack_depth_distribution[callstack_depth] ++;\n+        head = head->next();\n+      }\n+      lengths[i] = this_chain_length;\n+    }\n+\n+    st->print_cr(\"Malloc allocation site table:\");\n+    st->print_cr(\"\\tTotal entries: %d\", total_entries);\n+    st->print_cr(\"\\tEmpty entries: %d (%2.2f%%)\", empty_entries, ((float)empty_entries * 100) \/ total_entries);\n+    st->cr();\n+\n+    \/\/ We report the hash distribution (chain length distribution) of the n shortest chains\n+    \/\/  - under the assumption that this usually contains all lengths. Reporting threshold\n+    \/\/  is 20, and the expected avg chain length is 5..6 (see table size).\n+    static const int chain_length_threshold = 20;\n+    int chain_length_distribution[chain_length_threshold] = { 0 };\n+    int over_threshold = 0;\n+    int longest_chain_length = 0;\n+    for (int i = 0; i < table_size; i ++) {\n+      if (lengths[i] >= chain_length_threshold) {\n+        over_threshold ++;\n+      } else {\n+        chain_length_distribution[lengths[i]] ++;\n+      }\n+      longest_chain_length = MAX2(longest_chain_length, lengths[i]);\n+    }\n+\n+    st->print_cr(\"Hash distribution:\");\n+    if (chain_length_distribution[0] == 0) {\n+      st->print_cr(\"no empty buckets.\");\n+    } else {\n+      st->print_cr(\"%d buckets are empty.\", chain_length_distribution[0]);\n+    }\n+    for (int len = 1; len < MIN2(longest_chain_length + 1, chain_length_threshold); len ++) {\n+      st->print_cr(\"%2d %s: %d.\", len, (len == 1 ? \"  entry\" : \"entries\"), chain_length_distribution[len]);\n+    }\n+    if (longest_chain_length >= chain_length_threshold) {\n+      st->print_cr(\">=%2d entries: %d.\", chain_length_threshold, over_threshold);\n+    }\n+    st->print_cr(\"most entries: %d.\", longest_chain_length);\n+    st->cr();\n+\n+    st->print_cr(\"Call stack depth distribution:\");\n+    for (int i = 0; i <= NMT_TrackingStackDepth; i ++) {\n+      st->print_cr(\"\\t%d: %d\", i, stack_depth_distribution[i]);\n+    }\n+    st->cr();\n+  } \/\/ lock\n+}\n+\n+\n","filename":"src\/hotspot\/share\/services\/mallocSiteTable.cpp","additions":77,"deletions":1,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -41,1 +41,2 @@\n-class MallocSite : public AllocationSite<MemoryCounter> {\n+class MallocSite : public AllocationSite {\n+  MemoryCounter _c;\n@@ -43,3 +44,0 @@\n-  MallocSite() :\n-    AllocationSite<MemoryCounter>(NativeCallStack::empty_stack(), mtNone) {}\n-\n@@ -47,2 +45,1 @@\n-    AllocationSite<MemoryCounter>(stack, flags) {}\n-\n+    AllocationSite(stack, flags) {}\n@@ -50,2 +47,2 @@\n-  void allocate(size_t size)      { data()->allocate(size);   }\n-  void deallocate(size_t size)    { data()->deallocate(size); }\n+  void allocate(size_t size)      { _c.allocate(size);   }\n+  void deallocate(size_t size)    { _c.deallocate(size); }\n@@ -54,1 +51,1 @@\n-  size_t size()  const { return peek()->size(); }\n+  size_t size()  const { return _c.size(); }\n@@ -56,1 +53,1 @@\n-  size_t count() const { return peek()->count(); }\n+  size_t count() const { return _c.count(); }\n@@ -66,1 +63,0 @@\n-  MallocSiteHashtableEntry() : _next(NULL) { }\n@@ -82,4 +78,0 @@\n-  void set_callsite(const MallocSite& site) {\n-    _malloc_site = site;\n-  }\n-\n@@ -89,4 +81,0 @@\n-  inline long hash() const { return _malloc_site.hash(); }\n-  inline bool equals(const NativeCallStack& stack) const {\n-    return _malloc_site.equals(stack);\n-  }\n@@ -232,0 +220,2 @@\n+  static void print_tuning_statistics(outputStream* st);\n+\n","filename":"src\/hotspot\/share\/services\/mallocSiteTable.hpp","additions":9,"deletions":19,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -214,122 +214,0 @@\n-\/\/ This is a walker to gather malloc site hashtable statistics,\n-\/\/ the result is used for tuning.\n-class StatisticsWalker : public MallocSiteWalker {\n- private:\n-  enum Threshold {\n-    \/\/ aggregates statistics over this threshold into one\n-    \/\/ line item.\n-    report_threshold = 20\n-  };\n-\n- private:\n-  \/\/ Number of allocation sites that have all memory freed\n-  int   _empty_entries;\n-  \/\/ Total number of allocation sites, include empty sites\n-  int   _total_entries;\n-  \/\/ Number of captured call stack distribution\n-  int   _stack_depth_distribution[NMT_TrackingStackDepth];\n-  \/\/ Hash distribution\n-  int   _hash_distribution[report_threshold];\n-  \/\/ Number of hash buckets that have entries over the threshold\n-  int   _bucket_over_threshold;\n-\n-  \/\/ The hash bucket that walker is currently walking\n-  int   _current_hash_bucket;\n-  \/\/ The length of current hash bucket\n-  int   _current_bucket_length;\n-  \/\/ Number of hash buckets that are not empty\n-  int   _used_buckets;\n-  \/\/ Longest hash bucket length\n-  int   _longest_bucket_length;\n-\n- public:\n-  StatisticsWalker() : _empty_entries(0), _total_entries(0) {\n-    int index = 0;\n-    for (index = 0; index < NMT_TrackingStackDepth; index ++) {\n-      _stack_depth_distribution[index] = 0;\n-    }\n-    for (index = 0; index < report_threshold; index ++) {\n-      _hash_distribution[index] = 0;\n-    }\n-    _bucket_over_threshold = 0;\n-    _longest_bucket_length = 0;\n-    _current_hash_bucket = -1;\n-    _current_bucket_length = 0;\n-    _used_buckets = 0;\n-  }\n-\n-  virtual bool do_malloc_site(const MallocSite* e) {\n-    if (e->size() == 0) _empty_entries ++;\n-    _total_entries ++;\n-\n-    \/\/ stack depth distrubution\n-    int frames = e->call_stack()->frames();\n-    _stack_depth_distribution[frames - 1] ++;\n-\n-    \/\/ hash distribution\n-    int hash_bucket = ((unsigned)e->hash()) % MallocSiteTable::hash_buckets();\n-    if (_current_hash_bucket == -1) {\n-      _current_hash_bucket = hash_bucket;\n-      _current_bucket_length = 1;\n-    } else if (_current_hash_bucket == hash_bucket) {\n-      _current_bucket_length ++;\n-    } else {\n-      record_bucket_length(_current_bucket_length);\n-      _current_hash_bucket = hash_bucket;\n-      _current_bucket_length = 1;\n-    }\n-    return true;\n-  }\n-\n-  \/\/ walk completed\n-  void completed() {\n-    record_bucket_length(_current_bucket_length);\n-  }\n-\n-  void report_statistics(outputStream* out) {\n-    int index;\n-    out->print_cr(\"Malloc allocation site table:\");\n-    out->print_cr(\"\\tTotal entries: %d\", _total_entries);\n-    out->print_cr(\"\\tEmpty entries: %d (%2.2f%%)\", _empty_entries, ((float)_empty_entries * 100) \/ _total_entries);\n-    out->print_cr(\" \");\n-    out->print_cr(\"Hash distribution:\");\n-    if (_used_buckets < MallocSiteTable::hash_buckets()) {\n-      out->print_cr(\"empty bucket: %d\", (MallocSiteTable::hash_buckets() - _used_buckets));\n-    }\n-    for (index = 0; index < report_threshold; index ++) {\n-      if (_hash_distribution[index] != 0) {\n-        if (index == 0) {\n-          out->print_cr(\"  %d    entry: %d\", 1, _hash_distribution[0]);\n-        } else if (index < 9) { \/\/ single digit\n-          out->print_cr(\"  %d  entries: %d\", (index + 1), _hash_distribution[index]);\n-        } else {\n-          out->print_cr(\" %d entries: %d\", (index + 1), _hash_distribution[index]);\n-        }\n-      }\n-    }\n-    if (_bucket_over_threshold > 0) {\n-      out->print_cr(\" >%d entries: %d\", report_threshold,  _bucket_over_threshold);\n-    }\n-    out->print_cr(\"most entries: %d\", _longest_bucket_length);\n-    out->print_cr(\" \");\n-    out->print_cr(\"Call stack depth distribution:\");\n-    for (index = 0; index < NMT_TrackingStackDepth; index ++) {\n-      if (_stack_depth_distribution[index] > 0) {\n-        out->print_cr(\"\\t%d: %d\", index + 1, _stack_depth_distribution[index]);\n-      }\n-    }\n-  }\n-\n- private:\n-  void record_bucket_length(int length) {\n-    _used_buckets ++;\n-    if (length <= report_threshold) {\n-      _hash_distribution[length - 1] ++;\n-    } else {\n-      _bucket_over_threshold ++;\n-    }\n-    _longest_bucket_length = MAX2(_longest_bucket_length, length);\n-  }\n-};\n-\n-\n@@ -338,4 +216,0 @@\n-  StatisticsWalker walker;\n-  MallocSiteTable::walk_malloc_site(&walker);\n-  walker.completed();\n-\n@@ -346,2 +220,2 @@\n-  out->print_cr(\" \");\n-  walker.report_statistics(out);\n+  out->cr();\n+  MallocSiteTable::print_tuning_statistics(out);\n","filename":"src\/hotspot\/share\/services\/memTracker.cpp","additions":2,"deletions":128,"binary":false,"changes":130,"status":"modified"},{"patch":"@@ -90,1 +90,1 @@\n-                    NativeCallStack(0, true) : NativeCallStack::empty_stack())\n+                    NativeCallStack(0) : NativeCallStack::empty_stack())\n@@ -92,1 +92,1 @@\n-                    NativeCallStack(1, true) : NativeCallStack::empty_stack())\n+                    NativeCallStack(1) : NativeCallStack::empty_stack())\n","filename":"src\/hotspot\/share\/services\/memTracker.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -94,1 +94,1 @@\n-      SimpleThreadStackSite site((address)base, size);\n+      SimpleThreadStackSite site((address)base, size, NativeCallStack::empty_stack()); \/\/ Fake object just to serve as compare target for delete\n","filename":"src\/hotspot\/share\/services\/threadStackTracker.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,21 +36,3 @@\n-class SimpleThreadStackSite;\n-\n-class SimpleThreadStack {\n-  friend class SimpleThreadStackSite;\n-private:\n-  address _base;\n-  size_t  _size;\n-public:\n-  SimpleThreadStack() : _base(NULL), _size(0) { }\n-  bool equals(const SimpleThreadStack& s) const {\n-    return base() == s.base();\n-  }\n-\n-  size_t  size() const { return _size; }\n-  address base() const { return _base; }\n-private:\n-  void set_size(size_t size)  { _size = size; }\n-  void set_base(address base) { _base = base; }\n-};\n-\n-class SimpleThreadStackSite : public AllocationSite<SimpleThreadStack> {\n+class SimpleThreadStackSite : public AllocationSite {\n+  const address _base;\n+  const size_t  _size;\n@@ -59,10 +41,4 @@\n-    AllocationSite<SimpleThreadStack>(stack, mtThreadStack) {\n-    data()->set_size(size);\n-    data()->set_base(base);\n-  }\n-\n-  SimpleThreadStackSite(address base, size_t size) :\n-    AllocationSite<SimpleThreadStack>(NativeCallStack::empty_stack(), mtThreadStack) {\n-    data()->set_base(base);\n-    data()->set_size(size);\n-  }\n+    AllocationSite(stack, mtThreadStack),\n+    _base(base),\n+    _size(size)\n+  {}\n@@ -76,2 +52,2 @@\n-  size_t  size() const { return peek()->size(); }\n-  address base() const { return peek()->base(); }\n+  size_t  size() const { return _size; }\n+  address base() const { return _base; }\n","filename":"src\/hotspot\/share\/services\/threadStackTracker.hpp","additions":9,"deletions":33,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -71,1 +71,2 @@\n-class VirtualMemoryAllocationSite : public AllocationSite<VirtualMemory> {\n+class VirtualMemoryAllocationSite : public AllocationSite {\n+  VirtualMemory _c;\n@@ -74,1 +75,1 @@\n-    AllocationSite<VirtualMemory>(stack, flag) { }\n+    AllocationSite(stack, flag) { }\n@@ -76,6 +77,6 @@\n-  inline void reserve_memory(size_t sz)  { data()->reserve_memory(sz);  }\n-  inline void commit_memory (size_t sz)  { data()->commit_memory(sz);   }\n-  inline void uncommit_memory(size_t sz) { data()->uncommit_memory(sz); }\n-  inline void release_memory(size_t sz)  { data()->release_memory(sz);  }\n-  inline size_t reserved() const  { return peek()->reserved(); }\n-  inline size_t committed() const { return peek()->committed(); }\n+  inline void reserve_memory(size_t sz)  { _c.reserve_memory(sz);  }\n+  inline void commit_memory (size_t sz)  { _c.commit_memory(sz);   }\n+  inline void uncommit_memory(size_t sz) { _c.uncommit_memory(sz); }\n+  inline void release_memory(size_t sz)  { _c.release_memory(sz);  }\n+  inline size_t reserved() const  { return _c.reserved(); }\n+  inline size_t committed() const { return _c.committed(); }\n","filename":"src\/hotspot\/share\/services\/virtualMemoryTracker.hpp","additions":9,"deletions":8,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -31,0 +31,2 @@\n+const NativeCallStack NativeCallStack::_empty_stack; \/\/ Uses default ctor\n+\n@@ -39,1 +41,1 @@\n-NativeCallStack::NativeCallStack(int toSkip, bool fillStack) :\n+NativeCallStack::NativeCallStack(int toSkip) :\n@@ -42,5 +44,4 @@\n-  if (fillStack) {\n-    \/\/ We need to skip the NativeCallStack::NativeCallStack frame if a tail call is NOT used\n-    \/\/ to call os::get_native_stack. A tail call is used if _NMT_NOINLINE_ is not defined\n-    \/\/ (which means this is not a slowdebug build), and we are on 64-bit (except Windows).\n-    \/\/ This is not necessarily a rule, but what has been obvserved to date.\n+  \/\/ We need to skip the NativeCallStack::NativeCallStack frame if a tail call is NOT used\n+  \/\/ to call os::get_native_stack. A tail call is used if _NMT_NOINLINE_ is not defined\n+  \/\/ (which means this is not a slowdebug build), and we are on 64-bit (except Windows).\n+  \/\/ This is not necessarily a rule, but what has been obvserved to date.\n@@ -48,2 +49,2 @@\n-    \/\/ Not a tail call.\n-    toSkip++;\n+  \/\/ Not a tail call.\n+  toSkip++;\n@@ -51,3 +52,3 @@\n-    \/\/ Mac OS X slowdebug builds have this odd behavior where NativeCallStack::NativeCallStack\n-    \/\/ appears as two frames, so we need to skip an extra frame.\n-    toSkip++;\n+  \/\/ Mac OS X slowdebug builds have this odd behavior where NativeCallStack::NativeCallStack\n+  \/\/ appears as two frames, so we need to skip an extra frame.\n+  toSkip++;\n@@ -56,6 +57,1 @@\n-    os::get_native_stack(_stack, NMT_TrackingStackDepth, toSkip);\n-  } else {\n-    for (int index = 0; index < NMT_TrackingStackDepth; index ++) {\n-      _stack[index] = NULL;\n-    }\n-  }\n+  os::get_native_stack(_stack, NMT_TrackingStackDepth, toSkip);\n","filename":"src\/hotspot\/share\/utilities\/nativeCallStack.cpp","additions":13,"deletions":17,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -60,1 +60,1 @@\n-\n+  static const NativeCallStack _empty_stack;\n@@ -62,1 +62,7 @@\n-  NativeCallStack(int toSkip = 0, bool fillStack = false);\n+  \/\/ Default ctor creates an empty stack.\n+  \/\/ (it may make sense to remove this altogether but its used in a few places).\n+  NativeCallStack() : _hash_value(0) {\n+    memset(_stack, 0, sizeof(_stack));\n+  }\n+\n+  NativeCallStack(int toSkip);\n@@ -65,4 +71,1 @@\n-  static inline const NativeCallStack& empty_stack() {\n-    static const NativeCallStack EMPTY_STACK(0, false);\n-    return EMPTY_STACK;\n-  }\n+  static inline const NativeCallStack& empty_stack() { return _empty_stack; }\n","filename":"src\/hotspot\/share\/utilities\/nativeCallStack.hpp","additions":9,"deletions":6,"binary":false,"changes":15,"status":"modified"}]}