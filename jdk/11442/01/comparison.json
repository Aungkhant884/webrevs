{"files":[{"patch":"@@ -62,0 +62,3 @@\n+#include \"asm\/macroAssembler.hpp\"\n+#include \"gc\/shared\/barrierSetAssembler.hpp\"\n+\n@@ -289,0 +292,12 @@\n+\n+  if (C->stub_function() == NULL && BarrierSet::barrier_set()->barrier_set_nmethod() != NULL) {\n+    st->print(\"ldr  t0, [guard]\\n\\t\");\n+    st->print(\"membar LoadLoad\\n\\t\");\n+    st->print(\"ldr t1, [Rthread, #thread_disarmed_offset]\\n\\t\");\n+    st->print(\"cmp t0, t1\\n\\t\");\n+    st->print(\"beq skip\\n\\t\");\n+    st->print(\"blr #nmethod_entry_barrier_stub\\n\\t\");\n+    st->print(\"b skip\\n\\t\");\n+    st->print(\"guard: int\\n\\t\");\n+    st->print(\"skip:\\n\\t\");\n+  }\n@@ -321,0 +336,5 @@\n+  if (C->stub_function() == NULL) {\n+    BarrierSetAssembler* bs = BarrierSet::barrier_set()->barrier_set_assembler();\n+    bs->nmethod_entry_barrier(&_masm);\n+  }\n+\n","filename":"src\/hotspot\/cpu\/arm\/arm.ad","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+#include \"gc\/shared\/barrierSet.hpp\"\n+#include \"gc\/shared\/barrierSetAssembler.hpp\"\n@@ -65,0 +67,4 @@\n+\n+  \/\/ Insert nmethod entry barrier into frame.\n+  BarrierSetAssembler* bs = BarrierSet::barrier_set()->barrier_set_assembler();\n+  bs->nmethod_entry_barrier(this);\n","filename":"src\/hotspot\/cpu\/arm\/c1_MacroAssembler_arm.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"gc\/shared\/barrierSet.hpp\"\n@@ -27,0 +28,1 @@\n+#include \"gc\/shared\/barrierSetNMethod.hpp\"\n@@ -30,0 +32,1 @@\n+#include \"runtime\/stubRoutines.hpp\"\n@@ -198,0 +201,40 @@\n+\n+void BarrierSetAssembler::nmethod_entry_barrier(MacroAssembler* masm) {\n+\n+  BarrierSetNMethod* bs_nm = BarrierSet::barrier_set()->barrier_set_nmethod();\n+\n+  Register tmp0 = Rtemp;\n+  Register tmp1 = R5; \/\/ wrong register here will lead to crash\n+\n+  if (bs_nm == NULL) {\n+    return;\n+  }\n+\n+  Label skip, guard;\n+  Address thread_disarmed_addr(Rthread, in_bytes(bs_nm->thread_disarmed_offset()));\n+\n+  __ block_comment(\"nmethod_barrier begin\");\n+  __ ldr_label(tmp0, guard);\n+\n+  \/\/ Subsequent loads of oops must occur after load of guard value.\n+  \/\/ BarrierSetNMethod::disarm sets guard with release semantics.\n+  __ membar(MacroAssembler::LoadLoad, tmp1);\n+  __ ldr(tmp1, thread_disarmed_addr);\n+  __ cmp(tmp0, tmp1);\n+  __ b(skip, eq);\n+\n+  __ mov_address(tmp0, StubRoutines::Arm::method_entry_barrier());\n+  __ call(tmp0);\n+  __ b(skip);\n+\n+  __ bind(guard);\n+\n+  \/\/ nmethod guard value. Skipped over in common case.\n+  \/\/\n+  \/\/ Put a debug value to make any offsets skew\n+  \/\/ clearly visible in coredump\n+  __ emit_int32(0xDEADBEAF);\n+\n+  __ bind(skip);\n+  __ block_comment(\"nmethod_barrier end\");\n+}\n","filename":"src\/hotspot\/cpu\/arm\/gc\/shared\/barrierSetAssembler_arm.cpp","additions":43,"deletions":0,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -59,0 +59,1 @@\n+  virtual void nmethod_entry_barrier(MacroAssembler* masm);\n","filename":"src\/hotspot\/cpu\/arm\/gc\/shared\/barrierSetAssembler_arm.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,0 +26,2 @@\n+#include \"code\/nativeInst.hpp\"\n+#include \"gc\/shared\/barrierSetAssembler.hpp\"\n@@ -27,0 +29,7 @@\n+#include \"logging\/log.hpp\"\n+#include \"memory\/resourceArea.hpp\"\n+#include \"runtime\/frame.inline.hpp\"\n+#include \"runtime\/javaThread.hpp\"\n+#include \"runtime\/sharedRuntime.hpp\"\n+#include \"runtime\/registerMap.hpp\"\n+#include \"utilities\/align.hpp\"\n@@ -29,0 +38,48 @@\n+\/\/ The constant below reflects the size of the barrier\n+\/\/ in barrierSetAssembler_arm.cpp\n+static const int entry_barrier_bytes = 36;\n+\n+class NativeNMethodBarrier: public NativeInstruction {\n+  address instruction_address() const { return addr_at(0); }\n+\n+  int *guard_addr() const {\n+    \/\/ Last instruction in a barrier\n+    return reinterpret_cast<int*>(instruction_address() + entry_barrier_bytes - wordSize);\n+  }\n+\n+public:\n+  int get_value() {\n+    return Atomic::load_acquire(guard_addr());\n+  }\n+\n+  void set_value(int value) {\n+    Atomic::release_store(guard_addr(), value);\n+  }\n+\n+  void verify() const;\n+};\n+\n+\/\/ Check the first instruction of the nmethod entry barrier\n+\/\/ to make sure that the offsets are not skewed.\n+void NativeNMethodBarrier::verify() const {\n+  uint32_t* addr = (uint32_t*) instruction_address();\n+  uint32_t inst = *addr;\n+\n+  if (inst != 0xf57ff05f) {\n+    tty->print_cr(\"Addr: \" INTPTR_FORMAT \" Code: 0x%x\", (intptr_t)(addr), inst);\n+    fatal(\"not an ldr instruction.\");\n+  }\n+}\n+\n+static NativeNMethodBarrier* native_nmethod_barrier(nmethod* nm) {\n+  address barrier_address = nm->code_begin() + nm->frame_complete_offset() - entry_barrier_bytes;\n+  NativeNMethodBarrier* barrier = reinterpret_cast<NativeNMethodBarrier*>(barrier_address);\n+  debug_only(barrier->verify());\n+  return barrier;\n+}\n+\n+\/* We're called from an nmethod when we need to deoptimize it. We do\n+   this by throwing away the nmethod's frame and jumping to the\n+   ic_miss stub. This looks like there has been an IC miss at the\n+   entry of the nmethod, so we resolve the call, which will fall back\n+   to the interpreter if the nmethod has been unloaded. *\/\n@@ -30,1 +87,31 @@\n-  ShouldNotReachHere();\n+\n+  typedef struct {\n+    intptr_t *sp; intptr_t *fp; address lr; address pc;\n+  } frame_pointers_t;\n+\n+  frame_pointers_t *new_frame = (frame_pointers_t *)(return_address_ptr - 5);\n+\n+  JavaThread *thread = JavaThread::current();\n+  RegisterMap reg_map(thread,\n+                      RegisterMap::UpdateMap::skip,\n+                      RegisterMap::ProcessFrames::include,\n+                      RegisterMap::WalkContinuation::skip);\n+  frame frame = thread->last_frame();\n+\n+  assert(frame.is_compiled_frame() || frame.is_native_frame(), \"must be\");\n+  assert(frame.cb() == nm, \"must be\");\n+  frame = frame.sender(&reg_map);\n+\n+  LogTarget(Trace, nmethod, barrier) out;\n+  if (out.is_enabled()) {\n+    ResourceMark mark;\n+    log_trace(nmethod, barrier)(\"deoptimize(nmethod: %s(%p), return_addr: %p, osr: %d, thread: %p(%s), making rsp: %p) -> %p\",\n+                                nm->method()->name_and_sig_as_C_string(),\n+                                nm, *(address *) return_address_ptr, nm->is_osr_method(), thread,\n+                                thread->name(), frame.sp(), nm->verified_entry_point());\n+  }\n+\n+  new_frame->sp = frame.sp();\n+  new_frame->fp = frame.fp();\n+  new_frame->lr = frame.pc();\n+  new_frame->pc = SharedRuntime::get_handle_wrong_method_stub();\n@@ -34,1 +121,17 @@\n-  ShouldNotReachHere();\n+  if (!supports_entry_barrier(nm)) {\n+    return;\n+  }\n+\n+  \/\/ Disarms the nmethod guard emitted by BarrierSetAssembler::nmethod_entry_barrier.\n+  \/\/ Symmetric \"LDR; DMB ISHLD\" is in the nmethod barrier.\n+  NativeNMethodBarrier* barrier = native_nmethod_barrier(nm);\n+  barrier->set_value(disarmed_value());\n+}\n+\n+void BarrierSetNMethod::arm(nmethod* nm, int arm_value) {\n+  if (!supports_entry_barrier(nm)) {\n+    return;\n+  }\n+\n+  NativeNMethodBarrier* barrier = native_nmethod_barrier(nm);\n+  barrier->set_value(arm_value);\n@@ -38,2 +141,6 @@\n-  ShouldNotReachHere();\n-  return false;\n+  if (!supports_entry_barrier(nm)) {\n+    return false;\n+  }\n+\n+  NativeNMethodBarrier* barrier = native_nmethod_barrier(nm);\n+  return barrier->get_value() != disarmed_value();\n","filename":"src\/hotspot\/cpu\/arm\/gc\/shared\/barrierSetNMethod_arm.cpp","additions":111,"deletions":4,"binary":false,"changes":115,"status":"modified"},{"patch":"@@ -590,0 +590,4 @@\n+  void ldr_label(Register rd, Label& L) {\n+    ldr(rd, Address(PC, target(L) - pc() - 8));\n+  }\n+\n@@ -593,0 +597,10 @@\n+  void enter() {\n+    raw_push(FP, LR);\n+    mov(FP, SP);\n+  }\n+\n+  void leave() {\n+    mov(SP, FP);\n+    raw_pop(FP, LR);\n+  }\n+\n","filename":"src\/hotspot\/cpu\/arm\/macroAssembler_arm.hpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"gc\/shared\/barrierSetAssembler.hpp\"\n@@ -876,0 +877,4 @@\n+  BarrierSetAssembler* bs = BarrierSet::barrier_set()->barrier_set_assembler();\n+  assert(bs != NULL, \"Sanity\");\n+  bs->nmethod_entry_barrier(masm);\n+\n","filename":"src\/hotspot\/cpu\/arm\/sharedRuntime_arm.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"gc\/shared\/barrierSetNMethod.hpp\"\n@@ -2908,0 +2909,47 @@\n+  address generate_method_entry_barrier() {\n+    __ align(CodeEntryAlignment);\n+    StubCodeMark mark(this, \"StubRoutines\", \"nmethod_entry_barrier\");\n+\n+    Label deoptimize_label;\n+\n+    address start = __ pc();\n+\n+    \/\/ No need to save PC on Arm\n+    __ set_last_Java_frame(SP, FP, false, Rtemp);\n+\n+    __ enter();\n+\n+    __ add(Rtemp, SP, wordSize);  \/\/ Rtemp points to the saved lr\n+    __ sub(SP, SP, 4 * wordSize); \/\/ four words for the returned {sp, fp, lr, pc}\n+\n+    const RegisterSet saved_regs = RegisterSet(R0, R10);\n+    __ push(saved_regs);\n+    __ fpush(FloatRegisterSet(D0, 16));\n+\n+    __ mov(c_rarg0, Rtemp);\n+    __ call_VM_leaf(CAST_FROM_FN_PTR(address, BarrierSetNMethod::nmethod_stub_entry_barrier), c_rarg0);\n+\n+    __ reset_last_Java_frame(Rtemp);\n+\n+    __ mov(Rtemp, R0);\n+\n+    __ fpop(FloatRegisterSet(D0, 16));\n+    __ pop(saved_regs);\n+\n+    __ cbnz(Rtemp, deoptimize_label);\n+\n+    __ leave();\n+    __ bx(LR);\n+\n+    __ BIND(deoptimize_label);\n+\n+    __ ldr(Rtemp, Address(SP, 0));\n+    __ ldr(FP, Address(SP, wordSize));\n+    __ ldr(LR, Address(SP, wordSize * 2));\n+    __ ldr(R5, Address(SP, wordSize * 3));\n+    __ mov(SP, Rtemp);\n+    __ bx(R5);\n+\n+    return start;\n+  }\n+\n@@ -3100,0 +3148,5 @@\n+    BarrierSetNMethod* bs_nm = BarrierSet::barrier_set()->barrier_set_nmethod();\n+    if (bs_nm != NULL) {\n+      StubRoutines::Arm::_method_entry_barrier = generate_method_entry_barrier();\n+    }\n+\n","filename":"src\/hotspot\/cpu\/arm\/stubGenerator_arm.cpp","additions":53,"deletions":0,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -36,0 +36,2 @@\n+\n+address StubRoutines::Arm::_method_entry_barrier = NULL;\n","filename":"src\/hotspot\/cpu\/arm\/stubRoutines_arm.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+  static address _method_entry_barrier;\n@@ -50,0 +51,1 @@\n+  static address method_entry_barrier() { return _method_entry_barrier; }\n","filename":"src\/hotspot\/cpu\/arm\/stubRoutines_arm.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -62,1 +62,1 @@\n-    return NOT_ARM32(new BarrierSetNMethod()) ARM32_ONLY(nullptr);\n+    return new BarrierSetNMethod();\n","filename":"src\/hotspot\/share\/gc\/shared\/barrierSet.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}