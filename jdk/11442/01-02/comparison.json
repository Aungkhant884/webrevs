{"files":[{"patch":"@@ -295,1 +295,0 @@\n-    st->print(\"membar LoadLoad\\n\\t\");\n","filename":"src\/hotspot\/cpu\/arm\/arm.ad","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -213,0 +213,6 @@\n+  \/\/ The are no GCs that require memory barrier on arm32 now\n+#ifndef PRODUCT\n+  NMethodPatchingType patching_type = nmethod_patching_type();\n+  assert(patching_type == NMethodPatchingType::stw_instruction_and_data_patch, \"Unsupported patching type\");\n+#endif\n+\n@@ -219,3 +225,1 @@\n-  \/\/ Subsequent loads of oops must occur after load of guard value.\n-  \/\/ BarrierSetNMethod::disarm sets guard with release semantics.\n-  __ membar(MacroAssembler::LoadLoad, tmp1);\n+  \/\/ No memory barrier here\n","filename":"src\/hotspot\/cpu\/arm\/gc\/shared\/barrierSetAssembler_arm.cpp","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -32,0 +32,4 @@\n+enum class NMethodPatchingType {\n+  stw_instruction_and_data_patch,\n+};\n+\n@@ -59,0 +63,1 @@\n+  virtual NMethodPatchingType nmethod_patching_type() { return NMethodPatchingType::stw_instruction_and_data_patch; }\n","filename":"src\/hotspot\/cpu\/arm\/gc\/shared\/barrierSetAssembler_arm.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -65,5 +65,4 @@\n-  uint32_t* addr = (uint32_t*) instruction_address();\n-  uint32_t inst = *addr;\n-\n-  if (inst != 0xf57ff05f) {\n-    tty->print_cr(\"Addr: \" INTPTR_FORMAT \" Code: 0x%x\", (intptr_t)(addr), inst);\n+  NativeInstruction *ni = (NativeInstruction *) instruction_address();\n+  if (!ni->is_ldr()) {\n+    uint32_t *addr = (uint32_t *) ni;\n+    tty->print_cr(\"Addr: \" INTPTR_FORMAT \" Code: 0x%x\", (intptr_t) addr, (uint32_t) *addr);\n","filename":"src\/hotspot\/cpu\/arm\/gc\/shared\/barrierSetNMethod_arm.cpp","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"}]}