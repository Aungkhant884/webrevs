{"files":[{"patch":"@@ -2309,4 +2309,4 @@\n-        Node* adj_max = _igvn.intcon((stride_con > 0) ? min_jint : max_jint);\n-        set_ctrl(adj_max, C->root());\n-        Node* old_limit = NULL;\n-        Node* adj_limit = NULL;\n+        Node* underflow_clamp = _igvn.intcon((stride_con > 0) ? min_jint : max_jint);\n+        set_ctrl(underflow_clamp, C->root());\n+        Node* limit_before_underflow = NULL;\n+        Node* prev_limit = NULL;\n@@ -2316,1 +2316,1 @@\n-            limit->in(CMoveNode::IfTrue) == adj_max &&\n+            limit->in(CMoveNode::IfTrue) == underflow_clamp &&\n@@ -2320,7 +2320,4 @@\n-          \/\/ Loop was unrolled before.\n-          \/\/ Optimize the limit to avoid nested CMove:\n-          \/\/ use original limit as old limit.\n-          old_limit = bol->in(1)->in(1);\n-          \/\/ Adjust previous adjusted limit.\n-          adj_limit = limit->in(CMoveNode::IfFalse);\n-          adj_limit = new SubINode(adj_limit, stride);\n+          \/\/ Loop was unrolled before, and had an unrolling protection CMoveI.\n+          \/\/ Use inputs to previous CMoveI for the new one:\n+          prev_limit = limit->in(CMoveNode::IfFalse); \/\/ unpack previous limit with overflow\n+          limit_before_underflow = bol->in(1)->in(1); \/\/ CMoveI -> Bool -> CmpI -> limit_before_underflow\n@@ -2328,2 +2325,3 @@\n-          old_limit = limit;\n-          adj_limit = new SubINode(limit, stride);\n+          \/\/ Loop was not unrolled before, or the limit did not underflow in a previous unrolling.\n+          prev_limit = limit;\n+          limit_before_underflow = limit;\n@@ -2331,6 +2329,22 @@\n-        assert(old_limit != NULL && adj_limit != NULL, \"\");\n-        register_new_node(adj_limit, ctrl); \/\/ adjust amount\n-        Node* adj_cmp = new CmpINode(old_limit, adj_limit);\n-        register_new_node(adj_cmp, ctrl);\n-        Node* adj_bool = new BoolNode(adj_cmp, bt);\n-        register_new_node(adj_bool, ctrl);\n+        \/\/                           prev_limit   stride\n+        \/\/                                |         |\n+        \/\/ limit_before_underflow  new_limit_with_underflow (SubI)\n+        \/\/                   |        |           |\n+        \/\/                 underflow_cmp          |\n+        \/\/                   |                    |\n+        \/\/                 underflow_bool [lt\/gt] |\n+        \/\/                   |                    |\n+        \/\/                   +----+  +------------+\n+        \/\/                        |  |\n+        \/\/                        |  | underflow_clamp (min_jint\/max_jint)\n+        \/\/                        |  |  |\n+        \/\/                       CMoveINode ([min_jint..hi] \/ [lo..max_jing])\n+        \/\/\n+        assert(limit_before_underflow != NULL && prev_limit != NULL, \"must find them\");\n+        Node* new_limit_with_underflow = new SubINode(prev_limit, stride);\n+        register_new_node(new_limit_with_underflow, ctrl);\n+        \/\/ We must compare with limit_before_underflow, prev_limit may already have underflowed.\n+        Node* underflow_cmp = new CmpINode(limit_before_underflow, new_limit_with_underflow);\n+        register_new_node(underflow_cmp, ctrl);\n+        Node* underflow_bool = new BoolNode(underflow_cmp, bt);\n+        register_new_node(underflow_bool, ctrl);\n@@ -2338,4 +2352,4 @@\n-        \/\/ may be arbitrarily decreased by unrolling, but we know it is in [min_int, hi].\n-        const TypeInt* old_limit_t = _igvn.type(old_limit)->is_int();\n-        const TypeInt* no_underflow_t = TypeInt::make(stride_con > 0 ? min_jint : old_limit_t->_lo,\n-                                                      stride_con > 0 ? old_limit_t->_hi : max_jint,\n+        \/\/ may be arbitrarily decreased by unrolling, but still in [min_jint..hi] \/ [lo..max_jint]\n+        const TypeInt* limit_before_underflow_t = _igvn.type(limit_before_underflow)->is_int();\n+        const TypeInt* no_underflow_t = TypeInt::make(stride_con > 0 ? min_jint : limit_before_underflow_t->_lo,\n+                                                      stride_con > 0 ? limit_before_underflow_t->_hi : max_jint,\n@@ -2343,1 +2357,1 @@\n-        new_limit = new CMoveINode(adj_bool, adj_limit, adj_max, no_underflow_t);\n+        new_limit = new CMoveINode(underflow_bool, new_limit_with_underflow, underflow_clamp, no_underflow_t);\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":39,"deletions":25,"binary":false,"changes":64,"status":"modified"}]}