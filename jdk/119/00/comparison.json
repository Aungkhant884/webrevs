{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -247,1 +247,5 @@\n-    recorder->describe_scope(pc_offset, methodHandle(), scope()->method(), bci(), reexecute, rethrow_exception, is_method_handle_invoke, return_oop, locvals, expvals, monvals);\n+    bool has_ea_local_in_scope = false;\n+    bool arg_escape = false;\n+    recorder->describe_scope(pc_offset, methodHandle(), scope()->method(), bci(),\n+                             reexecute, rethrow_exception, is_method_handle_invoke, return_oop,\n+                             has_ea_local_in_scope, arg_escape, locvals, expvals, monvals);\n","filename":"src\/hotspot\/share\/c1\/c1_IR.hpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -244,0 +244,1 @@\n+  _jvmti_can_walk_any_space             = JvmtiExport::can_walk_any_space();\n@@ -273,0 +274,4 @@\n+  if (!_jvmti_can_walk_any_space &&\n+      JvmtiExport::can_walk_any_space()) {\n+    return true;\n+  }\n","filename":"src\/hotspot\/share\/ci\/ciEnv.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -76,0 +76,1 @@\n+  bool  _jvmti_can_walk_any_space;\n@@ -351,0 +352,1 @@\n+  bool  jvmti_can_walk_any_space()             const { return _jvmti_can_walk_any_space; }\n","filename":"src\/hotspot\/share\/ci\/ciEnv.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -289,3 +289,1 @@\n-  return new ScopeDesc(this, pd->scope_decode_offset(),\n-                       pd->obj_decode_offset(), pd->should_reexecute(), pd->rethrow_exception(),\n-                       pd->return_oop());\n+  return new ScopeDesc(this, pd);\n@@ -297,3 +295,1 @@\n-  return new ScopeDesc(this, pd->scope_decode_offset(),\n-                       pd->obj_decode_offset(), pd->should_reexecute(), pd->rethrow_exception(),\n-                       pd->return_oop());\n+  return new ScopeDesc(this, pd);\n","filename":"src\/hotspot\/share\/code\/compiledMethod.cpp","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -290,0 +290,2 @@\n+                                              bool        has_ea_local_in_scope,\n+                                              bool        arg_escape,\n@@ -306,0 +308,2 @@\n+  last_pd->set_has_ea_local_in_scope(has_ea_local_in_scope);\n+  last_pd->set_arg_escape(arg_escape);\n","filename":"src\/hotspot\/share\/code\/debugInfoRec.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -108,0 +108,2 @@\n+                      bool        has_ea_local_in_scope = false,\n+                      bool        arg_escape = false,\n","filename":"src\/hotspot\/share\/code\/debugInfoRec.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2421,3 +2421,1 @@\n-  for (ScopeDesc* sd = new ScopeDesc(this, pd->scope_decode_offset(),\n-                                     pd->obj_decode_offset(), pd->should_reexecute(), pd->rethrow_exception(),\n-                                     pd->return_oop());\n+  for (ScopeDesc* sd = new ScopeDesc(this, pd);\n@@ -3058,3 +3056,1 @@\n-    return new ScopeDesc(this, p->scope_decode_offset(),\n-                         p->obj_decode_offset(), p->should_reexecute(), p->rethrow_exception(),\n-                         p->return_oop());\n+    return new ScopeDesc(this, p);\n","filename":"src\/hotspot\/share\/code\/nmethod.cpp","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,1 +45,3 @@\n-    PCDESC_rethrow_exception       = 1 << 3\n+    PCDESC_rethrow_exception       = 1 << 3,\n+    PCDESC_has_ea_local_in_scope   = 1 << 4,\n+    PCDESC_arg_escape              = 1 << 5\n@@ -92,0 +94,10 @@\n+  \/\/ Indicates if there are objects in scope that, based on escape analysis, are local to the\n+  \/\/ compiled method or local to the current thread, i.e. NoEscape or ArgEscape\n+  bool     has_ea_local_in_scope()         const { return (_flags & PCDESC_has_ea_local_in_scope) != 0; }\n+  void set_has_ea_local_in_scope(bool z)         { set_flag(PCDESC_has_ea_local_in_scope, z); }\n+\n+  \/\/ Indicates if this pc descriptor is at a call site where objects that do not escape the\n+  \/\/ current thread are passed as arguments.\n+  bool     arg_escape()                    const { return (_flags & PCDESC_arg_escape) != 0; }\n+  void set_arg_escape(bool z)                    { set_flag(PCDESC_arg_escape, z); }\n+\n","filename":"src\/hotspot\/share\/code\/pcDesc.hpp","additions":14,"deletions":2,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -34,1 +34,2 @@\n-ScopeDesc::ScopeDesc(const CompiledMethod* code, int decode_offset, int obj_decode_offset, bool reexecute, bool rethrow_exception, bool return_oop) {\n+ScopeDesc::ScopeDesc(const CompiledMethod* code, PcDesc* pd, bool ignore_objects) {\n+  int obj_decode_offset = ignore_objects ? DebugInformationRecorder::serialized_null : pd->obj_decode_offset();\n@@ -36,1 +37,1 @@\n-  _decode_offset = decode_offset;\n+  _decode_offset = pd->scope_decode_offset();\n@@ -38,13 +39,5 @@\n-  _reexecute     = reexecute;\n-  _rethrow_exception = rethrow_exception;\n-  _return_oop    = return_oop;\n-  decode_body();\n-}\n-\n-ScopeDesc::ScopeDesc(const CompiledMethod* code, int decode_offset, bool reexecute, bool rethrow_exception, bool return_oop) {\n-  _code          = code;\n-  _decode_offset = decode_offset;\n-  _objects       = decode_object_values(DebugInformationRecorder::serialized_null);\n-  _reexecute     = reexecute;\n-  _rethrow_exception = rethrow_exception;\n-  _return_oop    = return_oop;\n+  _reexecute     = pd->should_reexecute();\n+  _rethrow_exception = pd->rethrow_exception();\n+  _return_oop    = pd->return_oop();\n+  _has_ea_local_in_scope = ignore_objects ? false : pd->has_ea_local_in_scope();\n+  _arg_escape    = ignore_objects ? false : pd->arg_escape();\n@@ -62,0 +55,2 @@\n+  _has_ea_local_in_scope = parent->has_ea_local_in_scope();\n+  _arg_escape    = false;\n","filename":"src\/hotspot\/share\/code\/scopeDesc.cpp","additions":10,"deletions":15,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -63,6 +63,1 @@\n-  ScopeDesc(const CompiledMethod* code, int decode_offset, int obj_decode_offset, bool reexecute, bool rethrow_exception, bool return_oop);\n-\n-  \/\/ Calls above, giving default value of \"serialized_null\" to the\n-  \/\/ \"obj_decode_offset\" argument.  (We don't use a default argument to\n-  \/\/ avoid a .hpp-.hpp dependency.)\n-  ScopeDesc(const CompiledMethod* code, int decode_offset, bool reexecute, bool rethrow_exception, bool return_oop);\n+  ScopeDesc(const CompiledMethod* code, PcDesc* pd, bool ignore_objects = false);\n@@ -79,0 +74,4 @@\n+  \/\/ Returns true if one or more NoEscape or ArgEscape objects exist in\n+  \/\/ any of the scopes at compiled pc.\n+  bool has_ea_local_in_scope() const { return _has_ea_local_in_scope; }\n+  bool arg_escape()       const { return _arg_escape; }\n@@ -108,0 +107,3 @@\n+  bool          _has_ea_local_in_scope;       \/\/ One or more NoEscape or ArgEscape objects exist in\n+                                              \/\/ any of the scopes at compiled pc.\n+  bool          _arg_escape;                  \/\/ Compiled Java call in youngest scope passes ArgEscape\n","filename":"src\/hotspot\/share\/code\/scopeDesc.hpp","additions":9,"deletions":7,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -808,0 +808,4 @@\n+#if defined(ASSERT) && COMPILER2_OR_JVMCI\n+\/\/ Stress testing. Dedicated threads revert optimizations based on escape analysis concurrently to\n+\/\/ the running java application.  Configured with vm options DeoptimizeObjectsALot*.\n+class DeoptimizeObjectsALotThread : public JavaThread {\n@@ -809,1 +813,64 @@\n-JavaThread* CompileBroker::make_thread(jobject thread_handle, CompileQueue* queue, AbstractCompiler* comp, Thread* THREAD) {\n+  static void deopt_objs_alot_thread_entry(JavaThread* thread, TRAPS);\n+  void deoptimize_objects_alot_loop_single();\n+  void deoptimize_objects_alot_loop_all();\n+\n+public:\n+  DeoptimizeObjectsALotThread() : JavaThread(&deopt_objs_alot_thread_entry) { }\n+\n+  bool is_hidden_from_external_view() const      { return true; }\n+};\n+\n+\/\/ Entry for DeoptimizeObjectsALotThread. The threads are started in\n+\/\/ CompileBroker::init_compiler_sweeper_threads() iff DeoptimizeObjectsALot is enabled\n+void DeoptimizeObjectsALotThread::deopt_objs_alot_thread_entry(JavaThread* thread, TRAPS) {\n+    DeoptimizeObjectsALotThread* dt = ((DeoptimizeObjectsALotThread*) thread);\n+    bool enter_single_loop;\n+    {\n+      MonitorLocker ml(dt, EscapeBarrier_lock, Mutex::_no_safepoint_check_flag);\n+      static int single_thread_count = 0;\n+      enter_single_loop = single_thread_count++ < DeoptimizeObjectsALotThreadCountSingle;\n+    }\n+    if (enter_single_loop) {\n+      dt->deoptimize_objects_alot_loop_single();\n+    } else {\n+      dt->deoptimize_objects_alot_loop_all();\n+    }\n+  }\n+\n+\/\/ Execute EscapeBarriers in an endless loop to revert optimizations based on escape analysis. Each\n+\/\/ barrier targets a single thread which is selected round robin.\n+void DeoptimizeObjectsALotThread::deoptimize_objects_alot_loop_single() {\n+  HandleMark hm(this);\n+  while (!this->is_terminated()) {\n+    for (JavaThreadIteratorWithHandle jtiwh; JavaThread *deoptee_thread = jtiwh.next(); ) {\n+      { \/\/ Begin new scope for escape barrier\n+        HandleMarkCleaner hmc(this);\n+        ResourceMark rm(this);\n+        EscapeBarrier eb(this, deoptee_thread, true);\n+        eb.deoptimize_objects(100);\n+      }\n+      \/\/ Now sleep after the escape barriers destructor resumed deoptee_thread.\n+      sleep(DeoptimizeObjectsALotInterval);\n+    }\n+  }\n+}\n+\n+\/\/ Execute EscapeBarriers in an endless loop to revert optimizations based on escape analysis. Each\n+\/\/ barrier targets all java threads in the vm at once.\n+void DeoptimizeObjectsALotThread::deoptimize_objects_alot_loop_all() {\n+  HandleMark hm(this);\n+  while (!is_terminated()) {\n+    { \/\/ Begin new scope for escape barrier\n+      HandleMarkCleaner hmc(this);\n+      ResourceMark rm(this);\n+      EscapeBarrier eb(this, true);\n+      eb.deoptimize_objects_all_threads();\n+    }\n+    \/\/ Now sleep after the escape barriers destructor resumed the java threads.\n+    sleep(DeoptimizeObjectsALotInterval);\n+  }\n+}\n+#endif \/\/ defined(ASSERT) && COMPILER2_OR_JVMCI\n+\n+\n+JavaThread* CompileBroker::make_thread(ThreadType type, jobject thread_handle, CompileQueue* queue, AbstractCompiler* comp, Thread* THREAD) {\n@@ -813,7 +880,18 @@\n-    if (comp != NULL) {\n-      if (!InjectCompilerCreationFailure || comp->num_compiler_threads() == 0) {\n-        CompilerCounters* counters = new CompilerCounters();\n-        new_thread = new CompilerThread(queue, counters);\n-      }\n-    } else {\n-      new_thread = new CodeCacheSweeperThread();\n+    switch (type) {\n+      case compiler_t:\n+        assert(comp != NULL, \"Compiler instance missing.\");\n+        if (!InjectCompilerCreationFailure || comp->num_compiler_threads() == 0) {\n+          CompilerCounters* counters = new CompilerCounters();\n+          new_thread = new CompilerThread(queue, counters);\n+        }\n+        break;\n+      case sweeper_t:\n+        new_thread = new CodeCacheSweeperThread();\n+        break;\n+#if defined(ASSERT) && COMPILER2_OR_JVMCI\n+      case deoptimizer_t:\n+        new_thread = new DeoptimizeObjectsALotThread();\n+        break;\n+#endif \/\/ ASSERT\n+      default:\n+        ShouldNotReachHere();\n@@ -821,0 +899,1 @@\n+\n@@ -862,1 +941,1 @@\n-      if (comp != NULL) {\n+      if (type == compiler_t) {\n@@ -872,1 +951,1 @@\n-    if (UseDynamicNumberOfCompilerThreads && comp != NULL && comp->num_compiler_threads() > 0) {\n+    if (UseDynamicNumberOfCompilerThreads && type == compiler_t && comp->num_compiler_threads() > 0) {\n@@ -927,1 +1006,1 @@\n-      JavaThread *ct = make_thread(thread_handle, _c2_compile_queue, _compilers[1], THREAD);\n+      JavaThread *ct = make_thread(compiler_t, thread_handle, _c2_compile_queue, _compilers[1], THREAD);\n@@ -947,1 +1026,1 @@\n-      JavaThread *ct = make_thread(thread_handle, _c1_compile_queue, _compilers[0], THREAD);\n+      JavaThread *ct = make_thread(compiler_t, thread_handle, _c1_compile_queue, _compilers[0], THREAD);\n@@ -966,1 +1045,12 @@\n-    make_thread(thread_handle, NULL, NULL, THREAD);\n+    make_thread(sweeper_t, thread_handle, NULL, NULL, THREAD);\n+  }\n+\n+#if defined(ASSERT) && COMPILER2_OR_JVMCI\n+  if (DeoptimizeObjectsALot) {\n+    \/\/ Initialize and start the object deoptimizer threads\n+    const int total_count = DeoptimizeObjectsALotThreadCountSingle + DeoptimizeObjectsALotThreadCountAll;\n+    for (int count = 0; count < total_count; count++) {\n+      Handle thread_oop = create_thread_oop(\"Deoptimize objects a lot single mode\", CHECK);\n+      jobject thread_handle = JNIHandles::make_local(THREAD, thread_oop());\n+      make_thread(deoptimizer_t, thread_handle, NULL, NULL, THREAD);\n+    }\n@@ -968,0 +1058,1 @@\n+#endif \/\/ defined(ASSERT) && COMPILER2_OR_JVMCI\n@@ -1021,1 +1112,1 @@\n-      JavaThread *ct = make_thread(compiler2_object(i), _c2_compile_queue, _compilers[1], THREAD);\n+      JavaThread *ct = make_thread(compiler_t, compiler2_object(i), _c2_compile_queue, _compilers[1], THREAD);\n@@ -1041,1 +1132,1 @@\n-      JavaThread *ct = make_thread(compiler1_object(i), _c1_compile_queue, _compilers[0], THREAD);\n+      JavaThread *ct = make_thread(compiler_t, compiler1_object(i), _c1_compile_queue, _compilers[0], THREAD);\n","filename":"src\/hotspot\/share\/compiler\/compileBroker.cpp","additions":106,"deletions":15,"binary":false,"changes":121,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -231,0 +231,6 @@\n+  enum ThreadType {\n+    compiler_t,\n+    sweeper_t,\n+    deoptimizer_t\n+  };\n+\n@@ -232,1 +238,1 @@\n-  static JavaThread* make_thread(jobject thread_oop, CompileQueue* queue, AbstractCompiler* comp, Thread* THREAD);\n+  static JavaThread* make_thread(ThreadType type, jobject thread_oop, CompileQueue* queue, AbstractCompiler* comp, Thread* THREAD);\n","filename":"src\/hotspot\/share\/compiler\/compileBroker.hpp","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -298,1 +298,1 @@\n-  GrowableArray<jvmtiDeferredLocalVariableSet*>* const list = jt->deferred_locals();\n+  GrowableArray<jvmtiDeferredLocalVariableSet*>* const list = JvmtiDeferredUpdates::deferred_locals(jt);\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/checkpoint\/rootResolver.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1184,0 +1184,3 @@\n+  \/\/ has_ea_local_in_scope and arg_escape should be added to JVMCI\n+  const bool has_ea_local_in_scope = false;\n+  const bool arg_escape            = false;\n@@ -1185,0 +1188,1 @@\n+                                  has_ea_local_in_scope, arg_escape,\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCodeInstaller.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -96,2 +96,1 @@\n-  bool do_escape_analysis = DoEscapeAnalysis && !env->should_retain_local_variables()\n-                                             && !env->jvmti_can_get_owned_monitor_info();\n+  bool do_escape_analysis = DoEscapeAnalysis;\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -334,1 +334,2 @@\n-      _adr_type(adr_type)\n+      _adr_type(adr_type),\n+      _has_ea_local_in_scope(false)\n@@ -343,0 +344,1 @@\n+  bool            _has_ea_local_in_scope; \/\/ NoEscape or ArgEscape objects in JVM States\n@@ -464,0 +466,6 @@\n+  void set_has_ea_local_in_scope(bool b) {\n+    _has_ea_local_in_scope = b;\n+  }\n+  bool has_ea_local_in_scope() const {\n+    return _has_ea_local_in_scope;\n+  }\n@@ -664,0 +672,1 @@\n+  bool    _arg_escape;             \/\/ ArgEscape in parameter list\n@@ -671,1 +680,2 @@\n-      _method(method), _bci(bci)\n+      _method(method),\n+      _arg_escape(false), _bci(bci)\n@@ -685,0 +695,2 @@\n+  void  set_arg_escape(bool f)             { _arg_escape = f; }\n+  bool  arg_escape() const                 { return _arg_escape; }\n","filename":"src\/hotspot\/share\/opto\/callnode.hpp","additions":15,"deletions":3,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -126,0 +126,1 @@\n+  GrowableArray<SafePointNode*>  sfn_worklist;\n@@ -191,0 +192,3 @@\n+    if (n-> is_SafePoint()) {\n+      sfn_worklist.append(n->as_SafePoint());\n+    }\n@@ -320,0 +324,19 @@\n+\n+  \/\/ Annotate at safepoints if they have <= ArgEscape objects in their scope and at\n+  \/\/ java calls if they pass ArgEscape objects as parameters.\n+  if (has_non_escaping_obj &&\n+      (C->env()->should_retain_local_variables() ||\n+       C->env()->jvmti_can_get_owned_monitor_info() ||\n+       C->env()->jvmti_can_walk_any_space() ||\n+       DeoptimizeObjectsALot)) {\n+    int sfn_length = sfn_worklist.length();\n+    for (int next = 0; next < sfn_length; next++) {\n+      SafePointNode* sfn = sfn_worklist.at(next);\n+      sfn->set_has_ea_local_in_scope(has_ea_local_in_scope(sfn));\n+      if (sfn->is_CallJava()) {\n+        CallJavaNode* call = sfn->as_CallJava();\n+        call->set_arg_escape(has_arg_escape(call));\n+      }\n+    }\n+  }\n+\n@@ -323,0 +346,61 @@\n+\/\/ Returns true if there is an object in the scope of sfn that does not escape globally.\n+bool ConnectionGraph::has_ea_local_in_scope(SafePointNode* sfn) {\n+  Compile* C = _compile;\n+  for (JVMState* jvms = sfn->jvms(); jvms != NULL; jvms = jvms->caller()) {\n+    if (C->env()->should_retain_local_variables() || C->env()->jvmti_can_walk_any_space() ||\n+        DeoptimizeObjectsALot) {\n+      \/\/ Jvmti agents can access locals. Must provide info about local objects at runtime.\n+      int num_locs = jvms->loc_size();\n+      for (int idx = 0; idx < num_locs; idx++) {\n+        Node* l = sfn->local(jvms, idx);\n+        if (not_global_escape(l)) {\n+          return true;\n+        }\n+      }\n+    }\n+    if (C->env()->jvmti_can_get_owned_monitor_info() ||\n+        C->env()->jvmti_can_walk_any_space() || DeoptimizeObjectsALot) {\n+      \/\/ Jvmti agents can read monitors. Must provide info about locked objects at runtime.\n+      int num_mon = jvms->nof_monitors();\n+      for (int idx = 0; idx < num_mon; idx++) {\n+        Node* m = sfn->monitor_obj(jvms, idx);\n+        if (m != NULL && not_global_escape(m)) {\n+          return true;\n+        }\n+      }\n+    }\n+  }\n+  return false;\n+}\n+\n+\/\/ Returns true if at least one of the arguments to the call is an object\n+\/\/ that does not escape globally.\n+bool ConnectionGraph::has_arg_escape(CallJavaNode* call) {\n+  if (call->method() != NULL) {\n+    uint max_idx = TypeFunc::Parms + call->method()->arg_size();\n+    for (uint idx = TypeFunc::Parms; idx < max_idx; idx++) {\n+      Node* p = call->in(idx);\n+      if (not_global_escape(p)) {\n+        return true;\n+      }\n+    }\n+  } else {\n+    const char* name = call->as_CallStaticJava()->_name;\n+    assert(name != NULL, \"no name\");\n+    \/\/ no arg escapes through uncommon traps\n+    if (strcmp(name, \"uncommon_trap\") != 0) {\n+      \/\/ process_call_arguments() assumes that all arguments escape globally\n+      const TypeTuple* d = call->tf()->domain();\n+      for (uint i = TypeFunc::Parms; i < d->cnt(); i++) {\n+        const Type* at = d->field_at(i);\n+        if (at->isa_oopptr() != NULL) {\n+          return true;\n+        }\n+      }\n+    }\n+  }\n+  return false;\n+}\n+\n+\n+\n","filename":"src\/hotspot\/share\/opto\/escape.cpp","additions":84,"deletions":0,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -556,0 +556,5 @@\n+  \/\/ Returns true if there is an object in the scope of sfn that does not escape globally.\n+  bool has_ea_local_in_scope(SafePointNode* sfn);\n+\n+  bool has_arg_escape(CallJavaNode* call);\n+\n","filename":"src\/hotspot\/share\/opto\/escape.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -823,0 +823,1 @@\n+  bool            _has_ea_local_in_scope; \/\/ NoEscape or ArgEscape objects in JVM States\n@@ -826,1 +827,1 @@\n-  MachSafePointNode() : MachReturnNode(), _oop_map(NULL), _jvms(NULL), _jvmadj(0) {\n+  MachSafePointNode() : MachReturnNode(), _oop_map(NULL), _jvms(NULL), _jvmadj(0), _has_ea_local_in_scope(false) {\n@@ -928,0 +929,1 @@\n+  bool      _arg_escape;             \/\/ ArgEscape in parameter list\n","filename":"src\/hotspot\/share\/opto\/machnode.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -1096,1 +1096,1 @@\n-  if (!EliminateAllocations || JvmtiExport::can_pop_frame() || !alloc->_is_non_escaping) {\n+  if (!EliminateAllocations || !alloc->_is_non_escaping) {\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1198,0 +1198,1 @@\n+      mcall_java->_arg_escape = call_java->arg_escape();\n@@ -1222,0 +1223,1 @@\n+  msfpt->_has_ea_local_in_scope = sfpt->has_ea_local_in_scope();\n","filename":"src\/hotspot\/share\/opto\/matcher.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -936,0 +936,2 @@\n+  bool has_ea_local_in_scope = sfn->_has_ea_local_in_scope;\n+  bool arg_escape = false;\n@@ -950,0 +952,1 @@\n+      arg_escape = mcall->as_MachCallJava()->_arg_escape;\n@@ -1070,1 +1073,4 @@\n-    C->debug_info()->describe_scope(safepoint_pc_offset, null_mh, scope_method, jvms->bci(), jvms->should_reexecute(), rethrow_exception, is_method_handle_invoke, return_oop, locvals, expvals, monvals);\n+    C->debug_info()->describe_scope(safepoint_pc_offset, null_mh, scope_method, jvms->bci(),\n+                                    jvms->should_reexecute(), rethrow_exception, is_method_handle_invoke,\n+                                    return_oop, has_ea_local_in_scope, arg_escape,\n+                                    locvals, expvals, monvals);\n","filename":"src\/hotspot\/share\/opto\/output.cpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -278,1 +278,1 @@\n-      ScopeDesc sc0(nm, pcd->scope_decode_offset(), pcd->should_reexecute(), pcd->rethrow_exception(), pcd->return_oop());\n+      ScopeDesc sc0(nm, pcd, true);\n","filename":"src\/hotspot\/share\/prims\/jvmtiCodeBlobEvents.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1209,0 +1209,5 @@\n+  EscapeBarrier eb(calling_thread, java_thread, true);\n+  if (!eb.deoptimize_objects(MaxJavaStackTraceDepth)) {\n+    return JVMTI_ERROR_OUT_OF_MEMORY;\n+  }\n+\n@@ -1254,0 +1259,5 @@\n+  EscapeBarrier eb(calling_thread, java_thread, true);\n+  if (!eb.deoptimize_objects(MaxJavaStackTraceDepth)) {\n+    return JVMTI_ERROR_OUT_OF_MEMORY;\n+  }\n+\n@@ -1669,0 +1679,7 @@\n+  if (java_thread->frames_to_pop_failed_realloc() > 0) {\n+    \/\/ VM is in the process of popping the top frame because it has scalar replaced objects which\n+    \/\/ could not be reallocated on the heap.\n+    \/\/ Return JVMTI_ERROR_OUT_OF_MEMORY to avoid interfering with the VM.\n+    return JVMTI_ERROR_OUT_OF_MEMORY;\n+  }\n+\n@@ -1700,0 +1717,1 @@\n+    EscapeBarrier eb(current_thread, java_thread, !is_interpreted[0] || !is_interpreted[1]);\n@@ -1703,0 +1721,5 @@\n+        \/\/ Eagerly reallocate scalar replaced objects.\n+        if (!eb.deoptimize_objects(frame_sp[i])) {\n+          \/\/ Reallocation of scalar replaced objects failed -> return with error\n+          return JVMTI_ERROR_OUT_OF_MEMORY;\n+        }\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnv.cpp","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -1313,0 +1313,7 @@\n+  if (java_thread->frames_to_pop_failed_realloc() > 0) {\n+    \/\/ VM is in the process of popping the top frame because it has scalar replaced objects\n+    \/\/ which could not be reallocated on the heap.\n+    \/\/ Return JVMTI_ERROR_OUT_OF_MEMORY to avoid interfering with the VM.\n+    return JVMTI_ERROR_OUT_OF_MEMORY;\n+  }\n+\n@@ -1327,0 +1334,6 @@\n+    \/\/ Eagerly reallocate scalar replaced objects.\n+    EscapeBarrier eb(current_thread, java_thread, true);\n+    if (!eb.deoptimize_objects(jvf->fr().id())) {\n+      \/\/ Reallocation of scalar replaced objects failed -> return with error\n+      return JVMTI_ERROR_OUT_OF_MEMORY;\n+    }\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnvBase.cpp","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -430,0 +430,1 @@\n+  , _eb(NULL, NULL, type == T_OBJECT)\n@@ -444,0 +445,1 @@\n+  , _eb(JavaThread::current(), thread, type == T_OBJECT)\n@@ -457,0 +459,1 @@\n+  , _eb(calling_thread, thread, true)\n@@ -629,0 +632,56 @@\n+\/\/ Revert optimizations based on escape analysis if this is an access to a local object\n+bool VM_GetOrSetLocal::deoptimize_objects(javaVFrame* jvf) {\n+#if COMPILER2_OR_JVMCI\n+  assert(_type == T_OBJECT, \"EscapeBarrier should not be active if _type != T_OBJECT\");\n+  if (_depth < _thread->frames_to_pop_failed_realloc()) {\n+    \/\/ cannot access frame with failed reallocations\n+    _result = JVMTI_ERROR_OUT_OF_MEMORY;\n+    return false;\n+  }\n+  if (can_be_deoptimized(jvf)) {\n+    compiledVFrame* cf = compiledVFrame::cast(jvf);\n+    if (cf->has_ea_local_in_scope() && !_eb.deoptimize_objects(cf->fr().id())) {\n+      \/\/ reallocation of scalar replaced objects failed because heap is exhausted\n+      _result = JVMTI_ERROR_OUT_OF_MEMORY;\n+      return false;\n+    }\n+  }\n+\n+  \/\/ With this access the object could escape the thread changing its escape state from ArgEscape,\n+  \/\/ to GlobalEscape so we must deoptimize callers which could have optimized on the escape state.\n+  vframe* vf = jvf;\n+  do {\n+    \/\/ move to next physical frame\n+    while(!vf->is_top()) {\n+      vf = vf->sender();\n+    }\n+    vf = vf->sender();\n+\n+    if (vf != NULL && vf->is_compiled_frame()) {\n+      compiledVFrame* cvf = compiledVFrame::cast(vf);\n+      \/\/ Deoptimize objects if arg escape is being passed down the stack.\n+      \/\/ Note that deoptimizing the frame is not enough because objects need to be relocked\n+      if (cvf->arg_escape() && !_eb.deoptimize_objects(cvf->fr().id())) {\n+        \/\/ reallocation of scalar replaced objects failed because heap is exhausted\n+        _result = JVMTI_ERROR_OUT_OF_MEMORY;\n+        return false;\n+      }\n+    }\n+  } while(vf != NULL && !vf->is_entry_frame());\n+#endif \/\/ COMPILER2_OR_JVMCI\n+  return true;\n+}\n+\n+bool VM_GetOrSetLocal::doit_prologue() {\n+  if (_eb.barrier_active()) {\n+    _jvf = get_java_vframe();\n+    NULL_CHECK(_jvf, false);\n+\n+    if (!deoptimize_objects(_jvf)) {\n+      return false;\n+    }\n+  }\n+\n+  return true;\n+}\n+\n@@ -630,1 +689,1 @@\n-  _jvf = get_java_vframe();\n+  _jvf = _jvf == NULL ? get_java_vframe() : _jvf;\n","filename":"src\/hotspot\/share\/prims\/jvmtiImpl.cpp","additions":60,"deletions":1,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"runtime\/deoptimization.hpp\"\n@@ -324,0 +325,2 @@\n+  EscapeBarrier _eb;\n+\n@@ -334,0 +337,1 @@\n+  bool deoptimize_objects(javaVFrame* vf);\n@@ -350,0 +354,1 @@\n+  bool doit_prologue();\n","filename":"src\/hotspot\/share\/prims\/jvmtiImpl.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+#include \"runtime\/deoptimization.hpp\"\n@@ -1489,0 +1490,4 @@\n+  \/\/ EA based optimizations on tagged objects are already reverted.\n+  EscapeBarrier eb(JavaThread::current(),\n+      object_filter == JVMTI_HEAP_OBJECT_UNTAGGED || object_filter == JVMTI_HEAP_OBJECT_EITHER);\n+  eb.deoptimize_objects_all_threads();\n@@ -1506,0 +1511,3 @@\n+  \/\/ EA based optimizations on tagged objects are already reverted.\n+  EscapeBarrier eb(JavaThread::current(), !(heap_filter & JVMTI_HEAP_FILTER_UNTAGGED));\n+  eb.deoptimize_objects_all_threads();\n@@ -3261,0 +3269,3 @@\n+  JavaThread* jt = JavaThread::current();\n+  EscapeBarrier eb(jt, true);\n+  eb.deoptimize_objects_all_threads();\n@@ -3288,2 +3299,6 @@\n-  Handle initial_object(Thread::current(), obj);\n-\n+  JavaThread* jt = JavaThread::current();\n+  Handle initial_object(jt, obj);\n+  \/\/ EA based optimizations that are tagged or reachable from initial_object are already reverted.\n+  EscapeBarrier eb(jt,\n+      initial_object.is_null() && !(heap_filter & JVMTI_HEAP_FILTER_UNTAGGED));\n+  eb.deoptimize_objects_all_threads();\n","filename":"src\/hotspot\/share\/prims\/jvmtiTagMap.cpp","additions":17,"deletions":2,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -80,0 +80,1 @@\n+#include \"runtime\/vframe.hpp\"\n@@ -882,0 +883,14 @@\n+WB_ENTRY(jboolean, WB_IsFrameDeoptimized(JNIEnv* env, jobject o, jint depth))\n+  JavaThread* t = JavaThread::current();\n+  bool result = false;\n+  if (t->has_last_Java_frame()) {\n+    RegisterMap reg_map(t);\n+    javaVFrame *jvf = t->last_java_vframe(&reg_map);\n+    for (jint d = 0; d < depth && jvf != NULL; d++) {\n+      jvf = jvf->java_sender();\n+    }\n+    result = jvf != NULL && jvf->fr().is_deoptimized_frame();\n+  }\n+  return result;\n+WB_END\n+\n@@ -2339,0 +2354,1 @@\n+  {CC\"isFrameDeoptimized\", CC\"(I)Z\",                  (void*)&WB_IsFrameDeoptimized},\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -61,0 +61,1 @@\n+#include \"runtime\/objectMonitor.inline.hpp\"\n@@ -168,1 +169,2 @@\n-                                  frame& deoptee, RegisterMap& map, GrowableArray<compiledVFrame*>* chunk) {\n+                                  frame& deoptee, RegisterMap& map, GrowableArray<compiledVFrame*>* chunk,\n+                                  bool& deoptimized_objects) {\n@@ -172,0 +174,4 @@\n+  JavaThread* deoptee_thread = chunk->at(0)->thread();\n+  assert(exec_mode == Deoptimization::Unpack_none || (deoptee_thread == thread),\n+         \"a frame can only be deoptimized by the owner thread\");\n+\n@@ -198,1 +204,8 @@\n-    JRT_BLOCK\n+    if (exec_mode == Deoptimization::Unpack_none) {\n+      assert(thread->thread_state() == _thread_in_vm, \"assumption\");\n+      Thread* THREAD = thread;\n+      \/\/ Clear pending OOM if reallocation fails and return true indicating allocation failure\n+      realloc_failures = Deoptimization::realloc_objects(thread, &deoptee, &map, objects, CHECK_AND_CLEAR_(true));\n+      deoptimized_objects = true;\n+    } else {\n+      JRT_BLOCK\n@@ -200,1 +213,2 @@\n-    JRT_END\n+      JRT_END\n+    }\n@@ -206,1 +220,1 @@\n-      tty->print_cr(\"REALLOC OBJECTS in thread \" INTPTR_FORMAT, p2i(thread));\n+      tty->print_cr(\"REALLOC OBJECTS in thread \" INTPTR_FORMAT, p2i(deoptee_thread));\n@@ -218,1 +232,4 @@\n-static void eliminate_locks(JavaThread* thread, GrowableArray<compiledVFrame*>* chunk, bool realloc_failures) {\n+static void eliminate_locks(JavaThread* thread, GrowableArray<compiledVFrame*>* chunk, bool realloc_failures,\n+                            frame& deoptee, int exec_mode, bool& deoptimized_objects) {\n+  JavaThread* deoptee_thread = chunk->at(0)->thread();\n+  assert(!EscapeBarrier::objs_are_deoptimized(deoptee_thread, deoptee.id()), \"must relock just once\");\n@@ -229,1 +246,3 @@\n-      Deoptimization::relock_objects(monitors, thread, realloc_failures);\n+      bool relocked = Deoptimization::relock_objects(thread, monitors, deoptee_thread, deoptee,\n+                                                     exec_mode, realloc_failures);\n+      deoptimized_objects = deoptimized_objects || relocked;\n@@ -240,0 +259,7 @@\n+            if (exec_mode == Deoptimization::Unpack_none) {\n+              ObjectMonitor* monitor = deoptee_thread->current_waiting_monitor();\n+              if (monitor != NULL && (oop)monitor->object() == mi->owner()) {\n+                tty->print_cr(\"     object <\" INTPTR_FORMAT \"> DEFERRED relocking after wait\", p2i(mi->owner()));\n+                continue;\n+              }\n+            }\n@@ -253,0 +279,30 @@\n+\n+\/\/ Deoptimize objects, that is reallocate and relock them, just before they escape through JVMTI.\n+\/\/ The given vframes cover one physical frame.\n+bool Deoptimization::deoptimize_objects_internal(JavaThread* thread, GrowableArray<compiledVFrame*>* chunk,\n+                                                 bool& realloc_failures) {\n+  frame deoptee = chunk->at(0)->fr();\n+  JavaThread* deoptee_thread = chunk->at(0)->thread();\n+  CompiledMethod* cm = deoptee.cb()->as_compiled_method_or_null();\n+  RegisterMap map(chunk->at(0)->register_map());\n+  bool deoptimized_objects = false;\n+\n+  bool const jvmci_enabled = JVMCI_ONLY(UseJVMCICompiler) NOT_JVMCI(false);\n+\n+  \/\/ Reallocate the non-escaping objects and restore their fields.\n+  if (jvmci_enabled COMPILER2_PRESENT(|| (DoEscapeAnalysis && EliminateAllocations))) {\n+    realloc_failures = eliminate_allocations(thread, Unpack_none, cm, deoptee, map, chunk, deoptimized_objects);\n+  }\n+\n+  \/\/ Revoke biases of objects with eliminated locks in the given frame.\n+  Deoptimization::revoke_for_object_deoptimization(deoptee_thread, deoptee, &map, thread);\n+\n+  \/\/ MonitorInfo structures used in eliminate_locks are not GC safe.\n+  NoSafepointVerifier no_safepoint;\n+\n+  \/\/ Now relock objects if synchronization on them was eliminated.\n+  if (jvmci_enabled COMPILER2_PRESENT(|| ((DoEscapeAnalysis || EliminateNestedLocks) && EliminateLocks))) {\n+    eliminate_locks(thread, chunk, realloc_failures, deoptee, Unpack_none, deoptimized_objects);\n+  }\n+  return deoptimized_objects;\n+}\n@@ -307,1 +363,2 @@\n-    realloc_failures = eliminate_allocations(thread, exec_mode, cm, deoptee, map, chunk);\n+    bool unused;\n+    realloc_failures = eliminate_allocations(thread, exec_mode, cm, deoptee, map, chunk, unused);\n@@ -322,2 +379,4 @@\n-  if (jvmci_enabled COMPILER2_PRESENT( || ((DoEscapeAnalysis || EliminateNestedLocks) && EliminateLocks) )) {\n-    eliminate_locks(thread, chunk, realloc_failures);\n+  if ((jvmci_enabled COMPILER2_PRESENT( || ((DoEscapeAnalysis || EliminateNestedLocks) && EliminateLocks) ))\n+      && !EscapeBarrier::objs_are_deoptimized(thread, deoptee.id())) {\n+    bool unused;\n+    eliminate_locks(thread, chunk, realloc_failures, deoptee, exec_mode, unused);\n@@ -354,2 +413,2 @@\n-  if (thread->deferred_locals() != NULL) {\n-    GrowableArray<jvmtiDeferredLocalVariableSet*>* list = thread->deferred_locals();\n+  if (JvmtiDeferredUpdates::deferred_locals(thread) != NULL) {\n+    GrowableArray<jvmtiDeferredLocalVariableSet*>* list = JvmtiDeferredUpdates::deferred_locals(thread);\n@@ -370,3 +429,4 @@\n-      thread->set_deferred_locals(NULL);\n-      \/\/ free the list and elements back to C heap.\n-      delete list;\n+      JvmtiDeferredUpdates* updates = thread->deferred_updates();\n+      thread->set_deferred_updates(NULL);\n+      \/\/ free deferred updates.\n+      delete updates;\n@@ -1356,1 +1416,3 @@\n-void Deoptimization::relock_objects(GrowableArray<MonitorInfo*>* monitors, JavaThread* thread, bool realloc_failures) {\n+bool Deoptimization::relock_objects(JavaThread* thread, GrowableArray<MonitorInfo*>* monitors,\n+                                    JavaThread* deoptee_thread, frame& fr, int exec_mode, bool realloc_failures) {\n+  bool relocked_objects = false;\n@@ -1361,0 +1423,1 @@\n+      relocked_objects = true;\n@@ -1369,1 +1432,1 @@\n-                 mark.biased_locker() == thread, \"should be locked to current thread\");\n+                 mark.biased_locker() == deoptee_thread, \"should be locked to current thread\");\n@@ -1373,0 +1436,19 @@\n+        } else if (exec_mode == Unpack_none) {\n+          if (mark.has_locker() && fr.sp() > (intptr_t*)mark.locker()) {\n+            \/\/ With exec_mode == Unpack_none obj may be thread local and locked in\n+            \/\/ a callee frame. In this case the bias was revoked before in revoke_for_object_deoptimization().\n+            \/\/ Make the lock in the callee a recursive lock and restore the displaced header.\n+            markWord dmw = mark.displaced_mark_helper();\n+            mark.locker()->set_displaced_header(markWord::encode((BasicLock*) NULL));\n+            obj->set_mark(dmw);\n+          }\n+          if (mark.has_monitor()) {\n+            \/\/ defer relocking if the deoptee thread is currently waiting for obj\n+            ObjectMonitor* waiting_monitor = deoptee_thread->current_waiting_monitor();\n+            if (waiting_monitor != NULL && (oop)waiting_monitor->object() == obj()) {\n+              assert(fr.is_deoptimized_frame(), \"frame must be scheduled for deoptimization\");\n+              mon_info->lock()->set_displaced_header(markWord::unused_mark());\n+              JvmtiDeferredUpdates::inc_relock_count_after_wait(deoptee_thread);\n+              continue;\n+            }\n+          }\n@@ -1375,1 +1457,1 @@\n-        ObjectSynchronizer::enter(obj, lock, thread);\n+        ObjectSynchronizer::enter(obj, lock, deoptee_thread);\n@@ -1380,0 +1462,1 @@\n+  return relocked_objects;\n@@ -1497,1 +1580,2 @@\n-static void collect_monitors(compiledVFrame* cvf, GrowableArray<Handle>* objects_to_revoke) {\n+static void collect_monitors(compiledVFrame* cvf, GrowableArray<Handle>* objects_to_revoke,\n+                             bool only_eliminated) {\n@@ -1502,1 +1586,3 @@\n-    if (!mon_info->eliminated() && mon_info->owner() != NULL) {\n+    if (mon_info->eliminated() == only_eliminated &&\n+        !mon_info->owner_is_scalar_replaced() &&\n+        mon_info->owner() != NULL) {\n@@ -1508,1 +1594,2 @@\n-static void get_monitors_from_stack(GrowableArray<Handle>* objects_to_revoke, JavaThread* thread, frame fr, RegisterMap* map) {\n+static void get_monitors_from_stack(GrowableArray<Handle>* objects_to_revoke, JavaThread* thread,\n+                                    frame fr, RegisterMap* map, bool only_eliminated) {\n@@ -1528,1 +1615,1 @@\n-    collect_monitors(cvf, objects_to_revoke);\n+    collect_monitors(cvf, objects_to_revoke, only_eliminated);\n@@ -1531,1 +1618,1 @@\n-  collect_monitors(cvf, objects_to_revoke);\n+  collect_monitors(cvf, objects_to_revoke, only_eliminated);\n@@ -1542,1 +1629,1 @@\n-  get_monitors_from_stack(objects_to_revoke, thread, fr, map);\n+  get_monitors_from_stack(objects_to_revoke, thread, fr, map, false);\n@@ -1552,0 +1639,31 @@\n+\/\/ Revoke the bias of objects with eliminated locking to prepare subsequent relocking.\n+void Deoptimization::revoke_for_object_deoptimization(JavaThread* deoptee_thread, frame fr,\n+                                                      RegisterMap* map, JavaThread* thread) {\n+  if (!UseBiasedLocking) {\n+    return;\n+  }\n+  GrowableArray<Handle>* objects_to_revoke = new GrowableArray<Handle>();\n+  \/\/ Collect monitors but only those with eliminated locking.\n+  get_monitors_from_stack(objects_to_revoke, deoptee_thread, fr, map, true);\n+\n+  int len = objects_to_revoke->length();\n+  for (int i = 0; i < len; i++) {\n+    oop obj = (objects_to_revoke->at(i))();\n+    markWord mark = obj->mark();\n+    if (!mark.has_bias_pattern() ||\n+        mark.is_biased_anonymously() || \/\/ eliminated locking does not bias an object if it wasn't before\n+        !obj->klass()->prototype_header().has_bias_pattern() || \/\/ bulk revoke ignores eliminated monitors\n+        (obj->klass()->prototype_header().bias_epoch() != mark.bias_epoch())) { \/\/ bulk rebias ignores eliminated monitors\n+      \/\/ We reach here regularly if there's just eliminated locking on obj.\n+      \/\/ We must not call BiasedLocking::revoke_own_lock() in this case, as we\n+      \/\/ would hit assertions because it is a prerequisite that there has to be\n+      \/\/ non-eliminated locking on obj by deoptee_thread.\n+      \/\/ Luckily we don't have to revoke here because obj has to be a\n+      \/\/ non-escaping obj and can be relocked without revoking the bias. See\n+      \/\/ Deoptimization::relock_objects().\n+      continue;\n+    }\n+    BiasedLocking::revoke(objects_to_revoke->at(i), thread);\n+    assert(!objects_to_revoke->at(i)->mark().has_bias_pattern(), \"biases should be revoked by now\");\n+  }\n+}\n@@ -2604,0 +2722,335 @@\n+\n+\/\/ Returns true iff objects were reallocated and relocked because of access through JVMTI\n+bool EscapeBarrier::objs_are_deoptimized(JavaThread* thread, intptr_t* fr_id) {\n+  \/\/ first\/oldest update holds the flag\n+  GrowableArray<jvmtiDeferredLocalVariableSet*>* list = JvmtiDeferredUpdates::deferred_locals(thread);\n+  bool result = false;\n+  if (list != NULL) {\n+    for (int i = 0; i < list->length(); i++) {\n+      if (list->at(i)->matches(fr_id)) {\n+        result = list->at(i)->objects_are_deoptimized();\n+        break;\n+      }\n+    }\n+  }\n+  return result;\n+}\n+\n+\/\/ Object references of frames up to the given depth are about to be\n+\/\/ accessed. Frames with optimizations based on escape state that is potentially\n+\/\/ changed by the accesses need to be deoptimized and the referenced objects\n+\/\/ need to be reallocated and relocked.  Up to depth this is done for frames\n+\/\/ with not escaping objects in scope. For deeper frames it is done only if\n+\/\/ they pass not escaping objects as arguments because they potentially escape\n+\/\/ from callee frames within the given depth.\n+\/\/ The search for deeper frames is ended if an entry frame is found because\n+\/\/ arguments to native methods are considered to escape globally.\n+bool EscapeBarrier::deoptimize_objects(int depth) {\n+  if (barrier_active() && deoptee_thread()->has_last_Java_frame()) {\n+    assert(calling_thread() == Thread::current(), \"should be\");\n+    ResourceMark rm(calling_thread());\n+    HandleMark   hm(calling_thread());\n+    RegisterMap  reg_map(deoptee_thread());\n+    vframe* vf = deoptee_thread()->last_java_vframe(&reg_map);\n+    int cur_depth = 0;\n+    while (vf != NULL && ((cur_depth <= depth) || !vf->is_entry_frame())) {\n+      if (vf->is_compiled_frame()) {\n+        compiledVFrame* cvf = compiledVFrame::cast(vf);\n+        \/\/ Deoptimize frame and local objects if any exist.\n+        \/\/ If cvf is deeper than depth, then we deoptimize iff local objects are passed as args.\n+        bool should_deopt = cur_depth <= depth ? cvf->has_ea_local_in_scope() : cvf->arg_escape();\n+        if (should_deopt && !deoptimize_objects(cvf->fr().id())) {\n+          \/\/ reallocation of scalar replaced objects failed because heap is exhausted\n+          return false;\n+        }\n+\n+        \/\/ move to top frame\n+        while(!vf->is_top()) {\n+          cur_depth++;\n+          vf = vf->sender();\n+        }\n+      }\n+\n+      \/\/ move to next physical frame\n+      cur_depth++;\n+      vf = vf->sender();\n+    }\n+  }\n+  return true;\n+}\n+\n+bool EscapeBarrier::deoptimize_objects_all_threads() {\n+  if (!barrier_active()) return true;\n+  ResourceMark rm(calling_thread());\n+  for (JavaThreadIteratorWithHandle jtiwh; JavaThread *jt = jtiwh.next(); ) {\n+    if (jt->has_last_Java_frame()) {\n+      RegisterMap reg_map(jt);\n+      vframe* vf = jt->last_java_vframe(&reg_map);\n+      assert(jt->frame_anchor()->walkable(),\n+             \"The stack of JavaThread \" PTR_FORMAT \" is not walkable. Thread state is %d\",\n+             p2i(jt), jt->thread_state());\n+      while (vf != NULL) {\n+        if (vf->is_compiled_frame()) {\n+          compiledVFrame* cvf = compiledVFrame::cast(vf);\n+          if ((cvf->has_ea_local_in_scope() || cvf->arg_escape()) &&\n+              !deoptimize_objects_internal(jt, cvf->fr().id())) {\n+            return false; \/\/ reallocation failure\n+          }\n+          \/\/ move to top frame\n+          while(!vf->is_top()) {\n+            vf = vf->sender();\n+          }\n+        }\n+        \/\/ move to next physical frame\n+        vf = vf->sender();\n+      }\n+    }\n+  }\n+  return true; \/\/ success\n+}\n+\n+bool EscapeBarrier::_deoptimizing_objects_for_all_threads = false;\n+bool EscapeBarrier::_self_deoptimization_in_progress      = false;\n+\n+class EscapeBarrierSuspendHandshake : public HandshakeClosure {\n+  JavaThread* _excluded_thread;\n+ public:\n+  EscapeBarrierSuspendHandshake(JavaThread* excluded_thread, const char* name) :\n+    HandshakeClosure(name),\n+    _excluded_thread(excluded_thread) {}\n+  void do_thread(Thread* th) {\n+    if (th->is_Java_thread() && !th->is_hidden_from_external_view() && (th != _excluded_thread)) {\n+      th->set_obj_deopt_flag();\n+    }\n+  }\n+};\n+\n+void EscapeBarrier::sync_and_suspend_one() {\n+  assert(_calling_thread != NULL, \"calling thread must not be NULL\");\n+  assert(_deoptee_thread != NULL, \"deoptee thread must not be NULL\");\n+  assert(barrier_active(), \"should not call\");\n+\n+  \/\/ Sync with other threads that might be doing deoptimizations\n+  {\n+    \/\/ Need to switch to _thread_blocked for the wait() call\n+    ThreadBlockInVM tbivm(_calling_thread);\n+    MonitorLocker ml(_calling_thread, EscapeBarrier_lock, Mutex::_no_safepoint_check_flag);\n+    while (_self_deoptimization_in_progress || _deoptee_thread->is_obj_deopt_suspend()) {\n+      ml.wait();\n+    }\n+\n+    if (self_deopt()) {\n+      _self_deoptimization_in_progress = true;\n+      return;\n+    }\n+\n+    \/\/ set suspend flag for target thread\n+    _deoptee_thread->set_obj_deopt_flag();\n+  }\n+\n+  \/\/ suspend target thread\n+  EscapeBarrierSuspendHandshake sh(NULL, \"EscapeBarrierSuspendOne\");\n+  Handshake::execute_direct(&sh, _deoptee_thread);\n+  assert(!_deoptee_thread->has_last_Java_frame() || _deoptee_thread->frame_anchor()->walkable(),\n+         \"stack should be walkable now\");\n+}\n+\n+void EscapeBarrier::sync_and_suspend_all() {\n+  assert(barrier_active(), \"should not call\");\n+  assert(_calling_thread != NULL, \"calling thread must not be NULL\");\n+  assert(all_threads(), \"sanity\");\n+\n+  \/\/ Sync with other threads that might be doing deoptimizations\n+  {\n+    \/\/ Need to switch to _thread_blocked for the wait() call\n+    ThreadBlockInVM tbivm(_calling_thread);\n+    MonitorLocker ml(_calling_thread, EscapeBarrier_lock, Mutex::_no_safepoint_check_flag);\n+\n+    bool deopt_in_progress;\n+    do {\n+      deopt_in_progress = _self_deoptimization_in_progress;\n+      for (JavaThreadIteratorWithHandle jtiwh; JavaThread *jt = jtiwh.next(); ) {\n+        deopt_in_progress = (deopt_in_progress || jt->is_obj_deopt_suspend());\n+        if (deopt_in_progress) {\n+          break;\n+        }\n+      }\n+      if (deopt_in_progress) {\n+        ml.wait(); \/\/ then check again\n+      }\n+    } while(deopt_in_progress);\n+\n+    _self_deoptimization_in_progress = true;\n+    _deoptimizing_objects_for_all_threads = true;\n+  }\n+\n+  EscapeBarrierSuspendHandshake sh(_calling_thread, \"EscapeBarrierSuspendAll\");\n+  Handshake::execute(&sh);\n+#ifdef ASSERT\n+  for (JavaThreadIteratorWithHandle jtiwh; JavaThread *jt = jtiwh.next(); ) {\n+    if (jt->is_hidden_from_external_view()) continue;\n+    assert(!jt->has_last_Java_frame() || jt->frame_anchor()->walkable(),\n+           \"The stack of JavaThread \" PTR_FORMAT \" is not walkable. Thread state is %d\",\n+           p2i(jt), jt->thread_state());\n+  }\n+#endif \/\/ ASSERT\n+}\n+\n+void EscapeBarrier::resume_one() {\n+  assert(barrier_active(), \"should not call\");\n+  assert(!all_threads(), \"use resume_all()\");\n+  MonitorLocker ml(_calling_thread, EscapeBarrier_lock, Mutex::_no_safepoint_check_flag);\n+  if (self_deopt()) {\n+    assert(_self_deoptimization_in_progress, \"incorrect synchronization\");\n+    _self_deoptimization_in_progress = false;\n+  } else {\n+    _deoptee_thread->clear_obj_deopt_flag();\n+  }\n+  ml.notify_all();\n+}\n+\n+void EscapeBarrier::resume_all() {\n+  assert(barrier_active(), \"should not call\");\n+  assert(all_threads(), \"use resume_one()\");\n+  MonitorLocker ml(_calling_thread, EscapeBarrier_lock, Mutex::_no_safepoint_check_flag);\n+  assert(_self_deoptimization_in_progress, \"incorrect synchronization\");\n+  _deoptimizing_objects_for_all_threads = false;\n+  _self_deoptimization_in_progress = false;\n+  for (JavaThreadIteratorWithHandle jtiwh; JavaThread *jt = jtiwh.next(); ) {\n+    jt->clear_obj_deopt_flag();\n+  }\n+  ml.notify_all();\n+}\n+\n+void EscapeBarrier::thread_added(JavaThread* jt) {\n+  if (!jt->is_hidden_from_external_view()) {\n+    MutexLocker ml(EscapeBarrier_lock, Mutex::_no_safepoint_check_flag);\n+    if (_deoptimizing_objects_for_all_threads) {\n+      jt->set_obj_deopt_flag();\n+    }\n+  }\n+}\n+\n+void EscapeBarrier::thread_removed(JavaThread* jt) {\n+  MonitorLocker ml(EscapeBarrier_lock, Mutex::_no_safepoint_check_flag);\n+  if (jt->is_obj_deopt_suspend()) {\n+    \/\/ jt terminated before it self suspended.\n+    \/\/ Other threads might be waiting to perform deoptimizations for it.\n+    jt->clear_obj_deopt_flag();\n+    ml.notify_all();\n+  }\n+}\n+\n+\/\/ Remember that objects were reallocated and relocked for the compiled frame with the given id\n+static void set_objs_are_deoptimized(JavaThread* thread, intptr_t* fr_id) {\n+  \/\/ set in first\/oldest update\n+  GrowableArray<jvmtiDeferredLocalVariableSet*>* list =\n+    JvmtiDeferredUpdates::deferred_locals(thread);\n+  DEBUG_ONLY(bool found = false);\n+  if (list != NULL) {\n+    for (int i = 0; i < list->length(); i++) {\n+      if (list->at(i)->matches(fr_id)) {\n+        DEBUG_ONLY(found = true);\n+        list->at(i)->set_objs_are_deoptimized();\n+        break;\n+      }\n+    }\n+  }\n+  assert(found, \"variable set should exist at least for one vframe\");\n+}\n+\n+\/\/ Deoptimize the given frame and deoptimize objects with optimizations based on\n+\/\/ escape analysis, i.e. reallocate scalar replaced objects on the heap and\n+\/\/ relock objects if locking has been eliminated.\n+\/\/ Deoptimized objects are kept as JVMTI deferred updates until the compiled\n+\/\/ frame is replaced with interpreter frames.  Returns false iff at least one\n+\/\/ reallocation failed.\n+bool EscapeBarrier::deoptimize_objects_internal(JavaThread* deoptee, intptr_t* fr_id) {\n+  if (!barrier_active()) return true;\n+\n+  JavaThread* ct = calling_thread();\n+  bool realloc_failures = false;\n+\n+  if (!objs_are_deoptimized(deoptee, fr_id)) {\n+    \/\/ Make sure the frame identified by fr_id is deoptimized and fetch its last vframe\n+    compiledVFrame* last_cvf;\n+    bool fr_is_deoptimized;\n+    do {\n+      StackFrameStream fst(deoptee);\n+      while (fst.current()->id() != fr_id && !fst.is_done()) {\n+        fst.next();\n+      }\n+      assert(fst.current()->id() == fr_id, \"frame not found\");\n+      assert(fst.current()->is_compiled_frame(),\n+             \"only compiled frames can contain stack allocated objects\");\n+      fr_is_deoptimized = fst.current()->is_deoptimized_frame();\n+      if (!fr_is_deoptimized) {\n+        \/\/ Execution must not continue in the compiled method, so we deoptimize the frame.\n+        Deoptimization::deoptimize_frame(deoptee, fr_id);\n+      } else {\n+        last_cvf = compiledVFrame::cast(vframe::new_vframe(fst.current(), fst.register_map(), deoptee));\n+      }\n+    } while(!fr_is_deoptimized);\n+\n+    \/\/ collect inlined frames\n+    compiledVFrame* cvf = last_cvf;\n+    GrowableArray<compiledVFrame*>* vfs = new GrowableArray<compiledVFrame*>(10);\n+    while (!cvf->is_top()) {\n+      vfs->push(cvf);\n+      cvf = compiledVFrame::cast(cvf->sender());\n+    }\n+    vfs->push(cvf);\n+\n+    \/\/ reallocate and relock optimized objects\n+    bool deoptimized_objects = Deoptimization::deoptimize_objects_internal(ct, vfs, realloc_failures);\n+    if (!realloc_failures && deoptimized_objects) {\n+      \/\/ now do the updates\n+      for (int frame_index = 0; frame_index < vfs->length(); frame_index++) {\n+        cvf = vfs->at(frame_index);\n+\n+        \/\/ locals\n+        GrowableArray<ScopeValue*>* scopeLocals = cvf->scope()->locals();\n+        StackValueCollection* locals = cvf->locals();\n+        if (locals != NULL) {\n+          for (int i2 = 0; i2 < locals->size(); i2++) {\n+            StackValue* var = locals->at(i2);\n+            if (var->type() == T_OBJECT && scopeLocals->at(i2)->is_object()) {\n+              jvalue val;\n+              val.l = cast_from_oop<jobject>(locals->at(i2)->get_obj()());\n+              cvf->update_local(T_OBJECT, i2, val);\n+            }\n+          }\n+        }\n+\n+        \/\/ expressions\n+        GrowableArray<ScopeValue*>* scopeExpressions = cvf->scope()->expressions();\n+        StackValueCollection* expressions = cvf->expressions();\n+        if (expressions != NULL) {\n+          for (int i2 = 0; i2 < expressions->size(); i2++) {\n+            StackValue* var = expressions->at(i2);\n+            if (var->type() == T_OBJECT && scopeExpressions->at(i2)->is_object()) {\n+              jvalue val;\n+              val.l = cast_from_oop<jobject>(expressions->at(i2)->get_obj()());\n+              cvf->update_stack(T_OBJECT, i2, val);\n+            }\n+          }\n+        }\n+\n+        \/\/ monitors\n+        GrowableArray<MonitorInfo*>* monitors = cvf->monitors();\n+        if (monitors != NULL) {\n+          for (int i2 = 0; i2 < monitors->length(); i2++) {\n+            if (monitors->at(i2)->eliminated()) {\n+              assert(!monitors->at(i2)->owner_is_scalar_replaced(),\n+                     \"reallocation failure, should not update\");\n+              cvf->update_monitor(i2, monitors->at(i2));\n+            }\n+          }\n+        }\n+      }\n+      set_objs_are_deoptimized(deoptee, fr_id);\n+    }\n+  }\n+  return !realloc_failures;\n+}\n+\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":476,"deletions":23,"binary":false,"changes":499,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,0 +39,1 @@\n+class EscapeBarrier;\n@@ -44,0 +45,1 @@\n+  friend class EscapeBarrier;\n@@ -137,1 +139,2 @@\n-    Unpack_LIMIT                = 4\n+    Unpack_none                 = 4, \/\/ not deoptimizing the frame, just reallocating\/relocking for JVMTI\n+    Unpack_LIMIT                = 5\n@@ -155,0 +158,3 @@\n+  static void revoke_for_object_deoptimization(JavaThread* deoptee_thread, frame fr,\n+                                               RegisterMap* map, JavaThread* thread);\n+\n@@ -169,0 +175,5 @@\n+  \/\/ Deoptimize objects, that is reallocate and relock them, just before they\n+  \/\/ escape through JVMTI.  The given vframes cover one physical frame.\n+  static bool deoptimize_objects_internal(JavaThread* thread, GrowableArray<compiledVFrame*>* chunk,\n+                                          bool& realloc_failures);\n+\n@@ -176,1 +187,2 @@\n-  static void relock_objects(GrowableArray<MonitorInfo*>* monitors, JavaThread* thread, bool realloc_failures);\n+  static bool relock_objects(JavaThread* thread, GrowableArray<MonitorInfo*>* monitors,\n+                             JavaThread* deoptee_thread, frame& fr, int exec_mode, bool realloc_failures);\n@@ -469,0 +481,87 @@\n+\/\/ EscapeBarriers should be put on execution paths where JVMTI agents can access object\n+\/\/ references held by java threads.\n+\/\/ They provide means to revert optimizations based on escape analysis in a well synchronized manner\n+\/\/ just before local references escape through JVMTI.\n+class EscapeBarrier : StackObj {\n+#if COMPILER2_OR_JVMCI\n+  JavaThread* const _calling_thread;\n+  JavaThread* const _deoptee_thread;\n+  bool        const _barrier_active;\n+\n+  static bool _deoptimizing_objects_for_all_threads;\n+  static bool _self_deoptimization_in_progress;\n+\n+  void sync_and_suspend_one();\n+  void sync_and_suspend_all();\n+  void resume_one();\n+  void resume_all();\n+\n+  \/\/ Deoptimize the given frame and deoptimize objects with optimizations based on escape analysis.\n+  bool deoptimize_objects_internal(JavaThread* deoptee, intptr_t* fr_id);\n+\n+public:\n+  \/\/ Revert ea based optimizations for given deoptee thread\n+  EscapeBarrier(JavaThread* calling_thread, JavaThread* deoptee_thread, bool barrier_active)\n+    : _calling_thread(calling_thread), _deoptee_thread(deoptee_thread),\n+      _barrier_active(barrier_active && (JVMCI_ONLY(UseJVMCICompiler) NOT_JVMCI(false)\n+                      COMPILER2_PRESENT(|| DoEscapeAnalysis)))\n+  {\n+    if (_barrier_active) sync_and_suspend_one();\n+  }\n+\n+  \/\/ Revert ea based optimizations for all java threads\n+  EscapeBarrier(JavaThread* calling_thread, bool barrier_active)\n+    : _calling_thread(calling_thread), _deoptee_thread(NULL),\n+      _barrier_active(barrier_active && (JVMCI_ONLY(UseJVMCICompiler) NOT_JVMCI(false)\n+                      COMPILER2_PRESENT(|| DoEscapeAnalysis)))\n+  {\n+    if (_barrier_active) sync_and_suspend_all();\n+  }\n+#else\n+public:\n+  EscapeBarrier(JavaThread* calling_thread, JavaThread* deoptee_thread, bool barrier_active) { }\n+  EscapeBarrier(JavaThread* calling_thread, bool barrier_active) { }\n+  static bool deoptimizing_objects_for_all_threads() { return false; }\n+  bool barrier_active() const                        { return false; }\n+#endif \/\/ COMPILER2_OR_JVMCI\n+\n+  \/\/ Deoptimize objects, i.e. reallocate and relock them. The target frames are deoptimized.\n+  \/\/ The methods return false iff at least one reallocation failed.\n+  bool deoptimize_objects(intptr_t* fr_id) {\n+    return true COMPILER2_OR_JVMCI_PRESENT(&& deoptimize_objects_internal(deoptee_thread(), fr_id));\n+  }\n+  bool deoptimize_objects(int depth)                           NOT_COMPILER2_OR_JVMCI_RETURN_(true);\n+  \/\/ Find and deoptimize non escaping objects and the holding frames on all stacks.\n+  bool deoptimize_objects_all_threads()                        NOT_COMPILER2_OR_JVMCI_RETURN_(true);\n+\n+  \/\/ A java thread was added to the list of threads\n+  static void thread_added(JavaThread* jt)                     NOT_COMPILER2_OR_JVMCI_RETURN;\n+  \/\/ A java thread was removed from the list of threads\n+  static void thread_removed(JavaThread* jt)                   NOT_COMPILER2_OR_JVMCI_RETURN;\n+\n+#if COMPILER2_OR_JVMCI\n+  \/\/ Returns true iff objects were reallocated and relocked because of access through JVMTI\n+  static bool objs_are_deoptimized(JavaThread* thread, intptr_t* fr_id);\n+\n+  static bool deoptimizing_objects_for_all_threads() { return _deoptimizing_objects_for_all_threads; }\n+\n+  ~EscapeBarrier() {\n+    if (!barrier_active()) return;\n+    if (all_threads()) {\n+      resume_all();\n+    } else {\n+      resume_one();\n+    }\n+  }\n+\n+\n+  bool all_threads()    const { return _deoptee_thread == NULL; }            \/\/ Should revert optimizations for all threads.\n+  bool self_deopt()     const { return _calling_thread == _deoptee_thread; } \/\/ Current thread deoptimizes its own objects.\n+  bool barrier_active() const { return _barrier_active; }                    \/\/ Inactive barriers are created if no local objects can escape.\n+\n+  \/\/ accessors\n+  JavaThread* calling_thread() const     { return _calling_thread; }\n+  JavaThread* deoptee_thread() const     { return _deoptee_thread; }\n+#endif \/\/ COMPILER2_OR_JVMCI\n+};\n+\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.hpp","additions":102,"deletions":3,"binary":false,"changes":105,"status":"modified"},{"patch":"@@ -381,0 +381,23 @@\n+  develop(bool, DeoptimizeObjectsALot, false,                               \\\n+          \"For testing purposes concurrent threads revert optimizations \"   \\\n+          \"based on escape analysis at intervals given with \"               \\\n+          \"DeoptimizeObjectsALotInterval=n. The thread count is given \"     \\\n+          \"with DeoptimizeObjectsALotThreadCountSingle and \"                \\\n+          \"DeoptimizeObjectsALotThreadCountAll.\")                           \\\n+                                                                            \\\n+  develop(uint64_t, DeoptimizeObjectsALotInterval, 5,                       \\\n+          \"Interval for DeoptimizeObjectsALot.\")                            \\\n+          range(0, max_jlong)                                               \\\n+                                                                            \\\n+  develop(int, DeoptimizeObjectsALotThreadCountSingle, 1,                   \\\n+          \"The number of threads that revert optimizations based on \"       \\\n+          \"escape analysis for a single thread if DeoptimizeObjectsALot \"   \\\n+          \"is enabled. The target thread is selected round robin.\" )        \\\n+          range(0, max_jint)                                                \\\n+                                                                            \\\n+  develop(int, DeoptimizeObjectsALotThreadCountAll, 1,                      \\\n+          \"The number of threads that revert optimizations based on \"       \\\n+          \"escape analysis for all threads if DeoptimizeObjectsALot \"       \\\n+          \"is enabled.\" )                                                   \\\n+          range(0, max_jint)                                                \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -55,0 +55,1 @@\n+Monitor* EscapeBarrier_lock           = NULL;\n@@ -302,0 +303,1 @@\n+  def(EscapeBarrier_lock           , PaddedMonitor, leaf,        false, _safepoint_check_never);  \/\/ Used to synchronize object reallocation\/relocking triggered by JVMTI\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -48,0 +48,1 @@\n+extern Monitor* EscapeBarrier_lock;              \/\/ a lock to sync reallocating and relocking objects because of JVMTI access\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+#include \"runtime\/vframe_hp.hpp\"\n@@ -1520,1 +1521,2 @@\n-  _recursions = save;     \/\/ restore the old recursion count\n+  _recursions = save      \/\/ restore the old recursion count\n+                + JvmtiDeferredUpdates::get_and_reset_relock_count_after_wait(jt); \/\/  increased by the deferred relock count\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1687,1 +1687,1 @@\n-  set_deferred_locals(NULL);\n+  set_deferred_updates(NULL);\n@@ -1916,1 +1916,1 @@\n-  GrowableArray<jvmtiDeferredLocalVariableSet*>* deferred = deferred_locals();\n+  GrowableArray<jvmtiDeferredLocalVariableSet*>* deferred = JvmtiDeferredUpdates::deferred_locals(this);\n@@ -1926,1 +1926,1 @@\n-    delete deferred;\n+    delete deferred_updates();\n@@ -2435,0 +2435,5 @@\n+  if (is_obj_deopt_suspend()) {\n+    frame_anchor()->make_walkable(this);\n+    wait_for_object_deoptimization();\n+  }\n+\n@@ -2635,0 +2640,53 @@\n+void JavaThread::wait_for_object_deoptimization() {\n+  assert(!has_last_Java_frame() || frame_anchor()->walkable(), \"should have walkable stack\");\n+  assert(this == Thread::current(), \"invariant\");\n+  JavaThreadState state = thread_state();\n+\n+  bool should_spin_wait = true;\n+  do {\n+    set_thread_state(_thread_blocked);\n+    set_suspend_equivalent();\n+    {\n+      MonitorLocker ml(this, EscapeBarrier_lock, Monitor::_no_safepoint_check_flag);\n+      if (EscapeBarrier::deoptimizing_objects_for_all_threads() ||\n+          (is_obj_deopt_suspend() && !should_spin_wait)) {\n+        ml.wait();\n+      }\n+      should_spin_wait = should_spin_wait && is_obj_deopt_suspend();\n+    }\n+    \/\/ A single deoptimization is typically very short. Microbenchmarks\n+    \/\/ showed 5% better performance when spinning.\n+    if (should_spin_wait) {\n+      \/\/ Inspired by HandshakeSpinYield\n+      const jlong max_spin_time_ns = 100 \/* us *\/ * (NANOUNITS \/ MICROUNITS);\n+      const int free_cpus = os::active_processor_count() - 1;\n+      jlong spin_time_ns = (5 \/* us *\/ * (NANOUNITS \/ MICROUNITS)) * free_cpus; \/\/ zero on UP\n+      spin_time_ns = spin_time_ns > max_spin_time_ns ? max_spin_time_ns : spin_time_ns;\n+      jlong spin_start = os::javaTimeNanos();\n+      while (is_obj_deopt_suspend()) {\n+        os::naked_yield();\n+        if ((os::javaTimeNanos() - spin_start) > spin_time_ns) {\n+          should_spin_wait = false;\n+          break;\n+        }\n+      }\n+    }\n+    set_thread_state_fence(state);\n+\n+    if (handle_special_suspend_equivalent_condition()) {\n+      java_suspend_self_with_safepoint_check();\n+    }\n+\n+    \/\/ Since we are not using a regular thread-state transition helper here,\n+    \/\/ we must manually emit the instruction barrier after leaving a safe state.\n+    OrderAccess::cross_modify_fence();\n+    if (state != _thread_in_native) {\n+      SafepointMechanism::process_if_requested(this);\n+    }\n+\n+    \/\/ Check for another deopt suspend _after_ checking for safepoint\/handshake,\n+    \/\/ or otherwise a stale value can be seen if the flag was changed with a\n+    \/\/ handshake while the current thread was _thread_blocked above.\n+  } while (is_obj_deopt_suspend());\n+}\n+\n@@ -2664,0 +2722,4 @@\n+  if (thread->is_obj_deopt_suspend()) {\n+    thread->wait_for_object_deoptimization();\n+  }\n+\n@@ -3034,1 +3096,1 @@\n-  GrowableArray<jvmtiDeferredLocalVariableSet*>* list = deferred_locals();\n+  GrowableArray<jvmtiDeferredLocalVariableSet*>* list = JvmtiDeferredUpdates::deferred_locals(this);\n@@ -4594,0 +4656,3 @@\n+\n+  \/\/ Make new thread known to active EscapeBarrier\n+  EscapeBarrier::thread_added(p);\n@@ -4627,0 +4692,3 @@\n+\n+    \/\/ Notify threads waiting in EscapeBarriers\n+    EscapeBarrier::thread_removed(p);\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":72,"deletions":4,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -83,1 +83,1 @@\n-class jvmtiDeferredLocalVariableSet;\n+class JvmtiDeferredUpdates;\n@@ -295,1 +295,2 @@\n-    _trace_flag             = 0x00000004U  \/\/ call tracing backend\n+    _trace_flag             = 0x00000004U, \/\/ call tracing backend\n+    _obj_deopt              = 0x00000008U  \/\/ suspend for object reallocation and relocking for JVMTI agent\n@@ -546,0 +547,3 @@\n+  inline void set_obj_deopt_flag();\n+  inline void clear_obj_deopt_flag();\n+\n@@ -620,0 +624,2 @@\n+  bool is_obj_deopt_suspend()           { return (_suspend_flags & _obj_deopt) != 0; }\n+\n@@ -1058,5 +1064,4 @@\n-  \/\/ Because deoptimization is lazy we must save jvmti requests to set locals\n-  \/\/ in compiled frames until we deoptimize and we have an interpreter frame.\n-  \/\/ This holds the pointer to array (yeah like there might be more than one) of\n-  \/\/ description of compiled vframes that have locals that need to be updated.\n-  GrowableArray<jvmtiDeferredLocalVariableSet*>* _deferred_locals_updates;\n+  \/\/ Holds updates by JVMTI agents for compiled frames that cannot be performed immediately. They\n+  \/\/ will be carried out as soon as possible which, in most cases, is just before deoptimization of\n+  \/\/ the frame, when control returns to it.\n+  JvmtiDeferredUpdates* _jvmti_deferred_updates;\n@@ -1377,0 +1382,4 @@\n+  \/\/ Synchronize with another thread (most likely a JVMTI agent) that is deoptimizing objects of the\n+  \/\/ current thread, i.e. reverts optimizations based on escape analysis.\n+  void wait_for_object_deoptimization();\n+\n@@ -1441,1 +1450,1 @@\n-    return (_suspend_flags & (_external_suspend JFR_ONLY(| _trace_flag))) != 0;\n+    return (_suspend_flags & (_external_suspend | _obj_deopt JFR_ONLY(| _trace_flag))) != 0;\n@@ -1514,1 +1523,1 @@\n-            is_external_suspend() || is_trace_suspend();\n+            is_external_suspend() || is_trace_suspend() || is_obj_deopt_suspend();\n@@ -1531,2 +1540,2 @@\n-  GrowableArray<jvmtiDeferredLocalVariableSet*>* deferred_locals() const { return _deferred_locals_updates; }\n-  void set_deferred_locals(GrowableArray<jvmtiDeferredLocalVariableSet *>* vf) { _deferred_locals_updates = vf; }\n+  JvmtiDeferredUpdates* deferred_updates() const      { return _jvmti_deferred_updates; }\n+  void set_deferred_updates(JvmtiDeferredUpdates* du) { _jvmti_deferred_updates = du; }\n","filename":"src\/hotspot\/share\/runtime\/thread.hpp","additions":20,"deletions":11,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -68,0 +68,6 @@\n+inline void Thread::set_obj_deopt_flag() {\n+  set_suspend_flag(_obj_deopt);\n+}\n+inline void Thread::clear_obj_deopt_flag() {\n+  clear_suspend_flag(_obj_deopt);\n+}\n","filename":"src\/hotspot\/share\/runtime\/thread.inline.hpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -85,0 +85,5 @@\n+  \/\/ Entry frame\n+  if (f->is_entry_frame()) {\n+    return new entryVFrame(f, reg_map, thread);\n+  }\n+\n","filename":"src\/hotspot\/share\/runtime\/vframe.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -67,1 +67,1 @@\n-  GrowableArray<jvmtiDeferredLocalVariableSet*>* list = thread()->deferred_locals();\n+  GrowableArray<jvmtiDeferredLocalVariableSet*>* list = JvmtiDeferredUpdates::deferred_locals(thread());\n@@ -106,1 +106,1 @@\n-  GrowableArray<jvmtiDeferredLocalVariableSet*>* deferred = thread()->deferred_locals();\n+  GrowableArray<jvmtiDeferredLocalVariableSet*>* deferred = JvmtiDeferredUpdates::deferred_locals(thread());\n@@ -120,2 +120,2 @@\n-    deferred =  new(ResourceObj::C_HEAP, mtCompiler) GrowableArray<jvmtiDeferredLocalVariableSet*> (1, mtCompiler);\n-    thread()->set_deferred_locals(deferred);\n+    JvmtiDeferredUpdates::create_for(thread());\n+    deferred = JvmtiDeferredUpdates::deferred_locals(thread());\n@@ -147,1 +147,1 @@\n-  GrowableArray<jvmtiDeferredLocalVariableSet*>* list = thread()->deferred_locals();\n+  GrowableArray<jvmtiDeferredLocalVariableSet*>* list = JvmtiDeferredUpdates::deferred_locals(thread());\n@@ -221,1 +221,1 @@\n-  GrowableArray<jvmtiDeferredLocalVariableSet*>* list = thread()->deferred_locals();\n+  GrowableArray<jvmtiDeferredLocalVariableSet*>* list = JvmtiDeferredUpdates::deferred_locals(thread());\n@@ -312,0 +312,18 @@\n+bool compiledVFrame::has_ea_local_in_scope() const {\n+  if (scope() == NULL) {\n+    \/\/ native nmethod, all objs escape\n+    assert(code()->as_nmethod()->is_native_method(), \"must be native\");\n+    return false;\n+  }\n+  return (scope()->objects() != NULL) || scope()->has_ea_local_in_scope();\n+}\n+\n+bool compiledVFrame::arg_escape() const {\n+  if (scope() == NULL) {\n+    \/\/ native nmethod, all objs escape\n+    assert(code()->as_nmethod()->is_native_method(), \"must be native\");\n+    return false;\n+  }\n+  return scope()->arg_escape();\n+}\n+\n@@ -326,0 +344,12 @@\n+void JvmtiDeferredUpdates::create_for(JavaThread* thread) {\n+  assert(thread->deferred_updates() == NULL, \"already allocated\");\n+  thread->set_deferred_updates(new JvmtiDeferredUpdates());\n+}\n+\n+void JvmtiDeferredUpdates::inc_relock_count_after_wait(JavaThread* thread) {\n+  if (thread->deferred_updates() == NULL) {\n+    create_for(thread);\n+  }\n+  thread->deferred_updates()->inc_relock_count_after_wait();\n+}\n+\n@@ -333,0 +363,1 @@\n+  _objects_are_deoptimized = false;\n@@ -427,1 +458,5 @@\n-      MonitorInfo* new_info = new MonitorInfo((oopDesc*)val->value().l, info->lock(), info->eliminated(), info->owner_is_scalar_replaced());\n+      \/\/ Originally the owner may have been scalar replaced but as an update\n+      \/\/ exists it must have been deoptimized, i.e. reallocated to the heap, and\n+      \/\/ now it is considered not to be scalar replaced.\n+      MonitorInfo* new_info = new MonitorInfo((oopDesc*)val->value().l, info->lock(),\n+                                              info->eliminated(), false);\n","filename":"src\/hotspot\/share\/runtime\/vframe_hp.cpp","additions":43,"deletions":8,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,0 +40,2 @@\n+  bool                         has_ea_local_in_scope() const;\n+  bool                         arg_escape()         const; \/\/ at call with arg escape in parameter list\n@@ -98,0 +100,42 @@\n+\/\/ Holds updates for compiled frames by JVMTI agents that cannot be performed immediately.\n+class jvmtiDeferredLocalVariableSet;\n+class JvmtiDeferredUpdates : public CHeapObj<mtCompiler> {\n+\n+  \/\/ Relocking has to be deferred if the lock owning thread is currently waiting on the monitor.\n+  int _relock_count_after_wait;\n+\n+  \/\/ Deferred updates of locals, expressions, and monitors\n+  GrowableArray<jvmtiDeferredLocalVariableSet*> _deferred_locals_updates;\n+\n+  void inc_relock_count_after_wait() {\n+    _relock_count_after_wait++;\n+  }\n+\n+  int get_and_reset_relock_count_after_wait() {\n+    int result = _relock_count_after_wait;\n+    _relock_count_after_wait = 0;\n+    return result;\n+  }\n+\n+  GrowableArray<jvmtiDeferredLocalVariableSet*>* deferred_locals() { return &_deferred_locals_updates; }\n+\n+  JvmtiDeferredUpdates() :\n+    _relock_count_after_wait(0),\n+    _deferred_locals_updates((ResourceObj::set_allocation_type((address) &_deferred_locals_updates,\n+                              ResourceObj::C_HEAP), 1), mtCompiler) { }\n+\n+public:\n+  static void create_for(JavaThread* thread);\n+\n+  static GrowableArray<jvmtiDeferredLocalVariableSet*>* deferred_locals(JavaThread* jt) {\n+    return jt->deferred_updates() == NULL ? NULL : jt->deferred_updates()->deferred_locals();\n+  }\n+\n+  \/\/ Relocking has to be deferred if the lock owning thread is currently waiting on the monitor.\n+  static int get_and_reset_relock_count_after_wait(JavaThread* jt) {\n+    return jt->deferred_updates() == NULL ? 0 : jt->deferred_updates()->get_and_reset_relock_count_after_wait();\n+  }\n+  static void inc_relock_count_after_wait(JavaThread* thread);\n+};\n+\n+\n@@ -114,0 +158,1 @@\n+  bool _objects_are_deoptimized;\n@@ -125,0 +170,1 @@\n+  bool                              objects_are_deoptimized() const { return _objects_are_deoptimized; }\n@@ -129,0 +175,1 @@\n+  void                              set_objs_are_deoptimized() { _objects_are_deoptimized = true; }\n@@ -132,0 +179,2 @@\n+  \/\/ Does the underlying physical frame match this jvmtiDeferredLocalVariableSet\n+  bool                              matches(intptr_t* fr_id) { return id() == fr_id; }\n","filename":"src\/hotspot\/share\/runtime\/vframe_hp.hpp","additions":50,"deletions":1,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -330,0 +330,2 @@\n+#define NOT_COMPILER2_OR_JVMCI_RETURN        \/* next token must be ; *\/\n+#define NOT_COMPILER2_OR_JVMCI_RETURN_(code) \/* next token must be ; *\/\n@@ -334,0 +336,2 @@\n+#define NOT_COMPILER2_OR_JVMCI_RETURN {}\n+#define NOT_COMPILER2_OR_JVMCI_RETURN_(code) { return code; }\n","filename":"src\/hotspot\/share\/utilities\/macros.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,610 @@\n+\/*\n+ * Copyright (c) 2020 SAP SE. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8230956\n+ * @summary JVMTI agents can obtain references to not escaping objects using JVMTI Heap functions.\n+ *          Therefore optimizations based on escape analysis have to be reverted,\n+ *          i.e. scalar replaced objects need to be reallocated on the heap and objects with eliminated locking\n+ *          need to be relocked.\n+ * @requires ((vm.compMode == \"Xmixed\") & vm.compiler2.enabled & vm.jvmti)\n+ * @library \/test\/lib \/test\/hotspot\/jtreg\n+ * @build sun.hotspot.WhiteBox\n+ * @run driver ClassFileInstaller sun.hotspot.WhiteBox\n+ * @compile IterateHeapWithEscapeAnalysisEnabled.java\n+ *\n+ * @comment BLOCK BEGIN EXCLUSIVE TESTCASES {\n+ *\n+ *          The following test cases are executed in fresh VMs because they require that the\n+ *          capability can_tag_objects is not taken until dontinline_testMethod is jit compiled and\n+ *          an activation of the compiled version is on stack of the target thread.\n+ *\n+ *          Without JDK-8227745 these test cases require that escape analysis is disabled at\n+ *          start-up because can_tag_objects can be taken lazily, potentially after loading an\n+ *          agent dynamically by means of the attach API. Disabling escape analysis and invalidating\n+ *          compiled methods does not help then because there may be compiled frames with ea-based\n+ *          optimizations on stack. Just like in this collection of test cases.\n+ *\n+ * @run main\/othervm\/native\n+ *                  -agentlib:IterateHeapWithEscapeAnalysisEnabled\n+ *                  -XX:+UnlockDiagnosticVMOptions\n+ *                  -Xms256m -Xmx256m\n+ *                  -XX:+PrintCompilation -XX:+PrintInlining\n+ *                  -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n+ *                  -Xbatch\n+ *                  -XX:CompileCommand=dontinline,*::dontinline_*\n+ *                  -XX:+DoEscapeAnalysis\n+ *                  IterateHeapWithEscapeAnalysisEnabled IterateOverReachableObjects\n+ * @run main\/othervm\/native\n+ *                  -agentlib:IterateHeapWithEscapeAnalysisEnabled\n+ *                  -XX:+UnlockDiagnosticVMOptions\n+ *                  -Xms256m -Xmx256m\n+ *                  -XX:+PrintCompilation -XX:+PrintInlining\n+ *                  -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n+ *                  -Xbatch\n+ *                  -XX:CompileCommand=dontinline,*::dontinline_*\n+ *                  -XX:+DoEscapeAnalysis\n+ *                  IterateHeapWithEscapeAnalysisEnabled IterateOverHeap\n+ * @run main\/othervm\/native\n+ *                  -agentlib:IterateHeapWithEscapeAnalysisEnabled\n+ *                  -XX:+UnlockDiagnosticVMOptions\n+ *                  -Xms256m -Xmx256m\n+ *                  -XX:+PrintCompilation -XX:+PrintInlining\n+ *                  -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n+ *                  -Xbatch\n+ *                  -XX:CompileCommand=dontinline,*::dontinline_*\n+ *                  -XX:+DoEscapeAnalysis\n+ *                  IterateHeapWithEscapeAnalysisEnabled IterateOverInstancesOfClass\n+ * @run main\/othervm\/native\n+ *                  -agentlib:IterateHeapWithEscapeAnalysisEnabled\n+ *                  -XX:+UnlockDiagnosticVMOptions\n+ *                  -Xms256m -Xmx256m\n+ *                  -XX:+PrintCompilation -XX:+PrintInlining\n+ *                  -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n+ *                  -Xbatch\n+ *                  -XX:CompileCommand=dontinline,*::dontinline_*\n+ *                  -XX:+DoEscapeAnalysis\n+ *                  IterateHeapWithEscapeAnalysisEnabled FollowReferences\n+ * @run main\/othervm\/native\n+ *                  -agentlib:IterateHeapWithEscapeAnalysisEnabled\n+ *                  -XX:+UnlockDiagnosticVMOptions\n+ *                  -Xms256m -Xmx256m\n+ *                  -XX:+PrintCompilation -XX:+PrintInlining\n+ *                  -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n+ *                  -Xbatch\n+ *                  -XX:CompileCommand=dontinline,*::dontinline_*\n+ *                  -XX:+DoEscapeAnalysis\n+ *                  IterateHeapWithEscapeAnalysisEnabled IterateThroughHeap\n+ *\n+ * @comment } BLOCK END EXCLUSIVE TESTCASES\n+ *\n+ * @comment BLOCK BEGIN NON EXCLUSIVE TESTCASES {\n+ *\n+ * @run main\/othervm\/native\n+ *                  -agentlib:IterateHeapWithEscapeAnalysisEnabled\n+ *                  -XX:+UnlockDiagnosticVMOptions\n+ *                  -Xms256m -Xmx256m\n+ *                  -XX:CompileCommand=dontinline,*::dontinline_*\n+ *                  -XX:+PrintCompilation\n+ *                  -XX:+PrintInlining\n+ *                  -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n+ *                  -Xbatch\n+ *                  -XX:+DoEscapeAnalysis -XX:+EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks -XX:+UseBiasedLocking\n+ *                  IterateHeapWithEscapeAnalysisEnabled\n+ * @run main\/othervm\/native\n+ *                  -agentlib:IterateHeapWithEscapeAnalysisEnabled\n+ *                  -XX:+UnlockDiagnosticVMOptions\n+ *                  -Xms256m -Xmx256m\n+ *                  -XX:CompileCommand=dontinline,*::dontinline_*\n+ *                  -XX:+PrintCompilation\n+ *                  -XX:+PrintInlining\n+ *                  -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n+ *                  -Xbatch\n+ *                  -XX:+DoEscapeAnalysis -XX:-EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks -XX:+UseBiasedLocking\n+ *                  IterateHeapWithEscapeAnalysisEnabled\n+ * @run main\/othervm\/native\n+ *                  -agentlib:IterateHeapWithEscapeAnalysisEnabled\n+ *                  -XX:+UnlockDiagnosticVMOptions\n+ *                  -Xms256m -Xmx256m\n+ *                  -XX:CompileCommand=dontinline,*::dontinline_*\n+ *                  -XX:+PrintCompilation\n+ *                  -XX:+PrintInlining\n+ *                  -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n+ *                  -Xbatch\n+ *                  -XX:-DoEscapeAnalysis -XX:-EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks -XX:+UseBiasedLocking\n+ *                  IterateHeapWithEscapeAnalysisEnabled\n+ *\n+ * @comment } BLOCK END NON EXCLUSIVE TESTCASES\n+ *\/\n+\n+import compiler.whitebox.CompilerWhiteBoxTest;\n+import jdk.test.lib.Asserts;\n+import sun.hotspot.WhiteBox;\n+\n+public class IterateHeapWithEscapeAnalysisEnabled {\n+\n+    public static final WhiteBox WB = WhiteBox.getWhiteBox();\n+\n+    public static final int COMPILE_THRESHOLD = CompilerWhiteBoxTest.THRESHOLD;\n+\n+    public static native int jvmtiTagClass(Class<?> cls, long tag);\n+\n+    \/\/ Methods to tag or count instances of a given class available in JVMTI\n+    public static enum TaggingAndCountingMethods {\n+        IterateOverReachableObjects,\n+        IterateOverHeap,\n+        IterateOverInstancesOfClass,\n+        FollowReferences,\n+        IterateThroughHeap\n+    }\n+\n+    public static native int acquireCanTagObjectsCapability();\n+    public static native int registerMethod(TaggingAndCountingMethods m, String name);\n+    public static native void agentTearDown();\n+\n+    \/**\n+     * Count and tag instances of a given class.\n+     * @param cls Used by the method {@link TaggingAndCountingMethods#IterateOverInstancesOfClass} as class to count and tag instances of.\n+     *        Ignored by other counting methods.\n+     * @param clsTag Tag of the class to count and tag instances of. Used by all methods except\n+     *        {@link TaggingAndCountingMethods#IterateOverInstancesOfClass}\n+     * @param instanceTag The tag to be set for selected instances.\n+     * @param method JVMTI counting and tagging method to be used.\n+     * @return The number of instances or -1 if the call fails.\n+     *\/\n+    public static native int countAndTagInstancesOfClass(Class<?> cls, long clsTag, long instanceTag, TaggingAndCountingMethods method);\n+\n+    \/**\n+     * Get all objects tagged with the given tag.\n+     * @param tag The tag used to select objects.\n+     * @param result Selected objects are copied into this array.\n+     * @return -1 to indicated failure and 0 for success.\n+     *\/\n+    public static native int getObjectsWithTag(long tag, Object[] result);\n+\n+    public static void main(String[] args) throws Exception {\n+        try {\n+            new IterateHeapWithEscapeAnalysisEnabled().runTestCases(args);\n+        } finally {\n+            agentTearDown();\n+        }\n+    }\n+\n+    public void runTestCases(String[] args) throws Exception {\n+        \/\/ register various instance tagging and counting methods with agent\n+        for (TaggingAndCountingMethods m : TaggingAndCountingMethods.values()) {\n+            msg(\"register instance count method \" + m.name());\n+            int rc = registerMethod(m, m.name());\n+            Asserts.assertGreaterThanOrEqual(rc, 0, \"method \" + m.name() + \" is unknown to agent\");\n+        }\n+\n+        if (args.length > 0) {\n+            \/\/ EXCLUSIVE TEST CASES\n+            \/\/ cant_tag_objects is acquired after warmup. Use given tagging\/counting method.\n+            new TestCase01(true, 100, TaggingAndCountingMethods.valueOf(args[0])).run();\n+        } else {\n+            \/\/ NON-EXCLUSIVE TEST CASES\n+            \/\/ cant_tag_objects is acquired before test cases are run but still during live phase.\n+            msgHL(\"Acquire capability can_tag_objects before first test case.\");\n+            int err = acquireCanTagObjectsCapability();\n+            Asserts.assertEQ(0, err, \"acquireCanTagObjectsCapability FAILED\");\n+\n+            \/\/ run test cases\n+            for (TaggingAndCountingMethods m : TaggingAndCountingMethods.values()) {\n+                new TestCase01(false, 200, m).run();\n+            }\n+            new TestCase02a(200).run();\n+            new TestCase02b(300).run();\n+        }\n+    }\n+\n+    static class ABBox {\n+        public int aVal;\n+        public int bVal;\n+        public TestCaseBase testCase;\n+\n+        public ABBox() { \/* empty *\/ }\n+\n+        public ABBox(TestCaseBase testCase) {\n+            this.testCase = testCase;\n+        }\n+\n+        \/**\n+         * Increment {@link #aVal} and {@link #bVal} under lock. The method is supposed to\n+         * be inlined into the test method and locking is supposed to be eliminated. After\n+         * this object escaped to the JVMTI agent, the code with eliminated locking must\n+         * not be used anymore.\n+         *\/\n+        public synchronized void synchronizedSlowInc() {\n+            aVal++;\n+            testCase.waitingForCheck = true;\n+            dontinline_waitForCheck(testCase);\n+            testCase.waitingForCheck = false;\n+            bVal++;\n+        }\n+\n+        public static void dontinline_waitForCheck(TestCaseBase testCase) {\n+            if (testCase.warmUpDone) {\n+                while(!testCase.checkingNow) {\n+                    try {\n+                        Thread.sleep(50);\n+                    } catch (InterruptedException e) { \/*ign*\/ }\n+                }\n+            }\n+        }\n+\n+        \/**\n+         * This method and incrementing {@link #aVal} and {@link #bVal} are synchronized.\n+         * So {@link #aVal} and {@link #bVal} should always be equal. Unless the optimized version\n+         * of {@link #synchronizedSlowInc()} without locking is still used after this object\n+         * escaped to the JVMTI agent.\n+         * @return\n+         *\/\n+        public synchronized boolean check() {\n+            return aVal == bVal;\n+        }\n+    }\n+\n+    public static abstract class TestCaseBase implements Runnable {\n+        public final long classTag;\n+        public long instanceTag;\n+\n+        public final Class<?> taggedClass;\n+\n+        public long checkSum;\n+        public long loopCount;\n+        public volatile boolean doLoop;\n+        public volatile boolean targetIsInLoop;\n+\n+        public volatile boolean waitingForCheck;\n+        public volatile boolean checkingNow;\n+\n+        public boolean warmUpDone;\n+\n+        public TestCaseBase(long classTag, Class<?> taggedClass) {\n+            this.classTag = classTag;\n+            this.taggedClass = taggedClass;\n+        }\n+\n+        public void setUp() {\n+            \/\/ Tag the class of instances to be scalar replaced\n+            msg(\"tagging \" + taggedClass.getName() + \" with tag \" +  classTag);\n+            int err = jvmtiTagClass(taggedClass, classTag);\n+            Asserts.assertEQ(0, err, \"jvmtiTagClass FAILED\");\n+        }\n+\n+        \/\/ to be overridden by test cases\n+        abstract public void dontinline_testMethod();\n+\n+        public void warmUp() {\n+            msg(\"WarmUp: START\");\n+            int callCount = COMPILE_THRESHOLD + 1000;\n+            doLoop = true;\n+            while (callCount-- > 0) {\n+                dontinline_testMethod();\n+            }\n+            warmUpDone = true;\n+            msg(\"WarmUp: DONE\");\n+        }\n+\n+        public Object dontinline_endlessLoop(Object argEscape) {\n+            long cs = checkSum;\n+            while (loopCount-- > 0 && doLoop) {\n+                targetIsInLoop = true;\n+                checkSum += checkSum % ++cs;\n+            }\n+            loopCount = 3;\n+            targetIsInLoop = false;\n+            return argEscape;\n+        }\n+\n+        public void waitUntilTargetThreadHasEnteredEndlessLoop() {\n+            while(!targetIsInLoop) {\n+                msg(\"Target has not yet entered the loop. Sleep 100ms.\");\n+                try { Thread.sleep(100); } catch (InterruptedException e) { \/*ignore *\/ }\n+            }\n+            msg(\"Target has entered the loop.\");\n+        }\n+\n+        public void terminateEndlessLoop() throws Exception {\n+            msg(\"Terminate endless loop\");\n+            doLoop = false;\n+        }\n+    }\n+\n+    \/**\n+     * Use JVMTI heap functions associated with the elements of {@link TaggingAndCountingMethods} to\n+     * get a reference to an object allocated in {@link TestCase01#dontinline_testMethod()}. The\n+     * allocation can be eliminated \/ scalar replaced.  The test case can be run in two modes: (1)\n+     * the capability can_tag_objects which is required to use the JVMTI heap functions is taken\n+     * before the test case (2) the capability is taken after {@link TestCase01#dontinline_testMethod()}\n+     * is compiled and the target thread has an activation of it on stack.\n+     *\/\n+    public static class TestCase01 extends TestCaseBase {\n+\n+        public volatile int testMethod_result;\n+        public boolean acquireCanTagObjectsCapabilityAfterWarmup;\n+        public TaggingAndCountingMethods taggingMethod;\n+\n+        public TestCase01(boolean acquireCanTagObjectsCapabilityAfterWarmup, long classTag, TaggingAndCountingMethods taggingMethod) {\n+            super(classTag, ABBox.class);\n+            instanceTag = classTag + 1;\n+            this.acquireCanTagObjectsCapabilityAfterWarmup = acquireCanTagObjectsCapabilityAfterWarmup;\n+            this.taggingMethod = taggingMethod;\n+        }\n+\n+        @Override\n+        public void setUp() {\n+            if (!acquireCanTagObjectsCapabilityAfterWarmup) {\n+                super.setUp();\n+            }\n+        }\n+\n+        public void setUpAfterWarmUp() {\n+            if (acquireCanTagObjectsCapabilityAfterWarmup) {\n+                msg(\"Acquire capability can_tag_objects \" + (warmUpDone ? \"after\" : \"before\") + \" warmup.\");\n+                int err = acquireCanTagObjectsCapability();\n+                Asserts.assertEQ(0, err, \"acquireCanTagObjectsCapability FAILED\");\n+                super.setUp();\n+            }\n+        }\n+\n+        public void run() {\n+            try {\n+                msgHL(getClass().getName() + \": test if object that may be scalar replaced is found using \" + taggingMethod);\n+                msg(\"The capability can_tag_object is acquired \" + (acquireCanTagObjectsCapabilityAfterWarmup ? \"AFTER\" : \"BEFORE\")\n+                        + \" warmup.\");\n+                setUp();\n+                warmUp();\n+                WB.deflateIdleMonitors();\n+                WB.fullGC(); \/\/ get rid of dead instances from previous test cases\n+                runTest(taggingMethod);\n+            } catch (Exception e) {\n+                Asserts.fail(\"Unexpected Exception\", e);\n+            }\n+        }\n+\n+        public void runTest(TaggingAndCountingMethods m) throws Exception {\n+            loopCount = 1L << 62; \/\/ endless loop\n+            doLoop = true;\n+            testMethod_result = 0;\n+            Thread t1 = new Thread(() -> dontinline_testMethod(), \"Target Thread (\" + getClass().getName() + \")\");\n+            try {\n+                t1.start();\n+                try {\n+                    waitUntilTargetThreadHasEnteredEndlessLoop();\n+                    setUpAfterWarmUp();\n+                    msg(\"count and tag instances of \" + taggedClass.getName() + \" with tag \" + instanceTag + \" using JVMTI \" + m.name());\n+                    int count = countAndTagInstancesOfClass(taggedClass, classTag, instanceTag, m);\n+                    msg(\"Done. Count is \" + count);\n+                    Asserts.assertGreaterThanOrEqual(count, 0, \"countAndTagInstancesOfClass FAILED\");\n+                    Asserts.assertEQ(count, 1, \"unexpected number of instances\");\n+\n+                    ABBox[] result = new ABBox[1];\n+                    msg(\"get instances tagged with \" + instanceTag + \". The instances escape thereby.\");\n+                    int err = getObjectsWithTag(instanceTag, result);\n+                    msg(\"Done.\");\n+                    Asserts.assertEQ(0, err, \"getObjectsWithTag FAILED\");\n+\n+                    msg(\"change the now escaped instance' bVal\");\n+                    ABBox abBox = result[0];\n+                    abBox.bVal = 3;\n+                    terminateEndlessLoop();\n+\n+                    msg(\"wait until target thread has set testMethod_result\");\n+                    while (testMethod_result == 0) {\n+                        Thread.sleep(50);\n+                    }\n+                    msg(\"check if the modification of bVal is reflected in testMethod_result.\");\n+                    Asserts.assertEQ(7, testMethod_result, \" testMethod_result has wrong value\");\n+                    msg(\"ok.\");\n+                } finally {\n+                    terminateEndlessLoop();\n+                }\n+            } finally {\n+                t1.join();\n+            }\n+        }\n+\n+        @Override\n+        public void dontinline_testMethod() {\n+            ABBox ab = new ABBox();     \/\/ can be scalar replaced\n+            ab.aVal = 4;\n+            ab.bVal = 2;\n+            dontinline_endlessLoop(null);   \/\/ JVMTI agent acquires reference to ab and changes bVal\n+            testMethod_result = ab.aVal + ab.bVal;\n+        }\n+    }\n+\n+    \/**\n+     * {@link #dontinline_testMethod()} creates an ArgEscape instance of {@link TestCaseBase#taggedClass} on stack.\n+     * The jvmti agent tags all instances of this class using one of the {@link TaggingAndCountingMethods}. Then it gets the tagged\n+     * instances using <code>GetObjectsWithTags()<\/code>. This is where the ArgEscape globally escapes.\n+     * It happens at a location without eliminated locking but there is\n+     * eliminated locking following, so the compiled frame must be deoptimized. This is checked by letting the agent call the\n+     * synchronized method {@link ABBox#check()} on the escaped instance.\n+     *\/\n+    public static class TestCase02a extends TestCaseBase {\n+\n+        public long instanceTag;\n+\n+        public TestCase02a(long classTag) {\n+            super(classTag, ABBox.class);\n+            instanceTag = classTag + 1;\n+        }\n+\n+        public void run() {\n+            try {\n+                msgHL(getClass().getName() + \": test if owning frame is deoptimized if ArgEscape escapes globally\");\n+                setUp();\n+                warmUp();\n+                for (TaggingAndCountingMethods m : TaggingAndCountingMethods.values()) {\n+                    msgHL(getClass().getName() + \": Tag and Get of ArgEscapes using \" + m.name());\n+                    waitingForCheck = false;\n+                    checkingNow = false;\n+                    WB.deflateIdleMonitors();\n+                    WB.fullGC(); \/\/ get rid of dead instances from previous test cases\n+                    runTest(m);\n+                }\n+            } catch (Exception e) {\n+                Asserts.fail(\"Unexpected Exception\", e);\n+            }\n+        }\n+\n+        public void runTest(TaggingAndCountingMethods m) throws Exception {\n+            loopCount = 1L << 62; \/\/ endless loop\n+            doLoop = true;\n+            Thread t1 = new Thread(() -> dontinline_testMethod(), \"Target Thread (\" + getClass().getName() + \")\");\n+            try {\n+                t1.start();\n+                try {\n+                    waitUntilTargetThreadHasEnteredEndlessLoop();\n+                    msg(\"count and tag instances of \" + taggedClass.getName() + \" with tag \" + instanceTag + \" using JVMTI \" + m.name());\n+                    int count = countAndTagInstancesOfClass(taggedClass, classTag, instanceTag, m);\n+                    msg(\"Done. Count is \" + count);\n+                    Asserts.assertGreaterThanOrEqual(count, 0, \"countAndTagInstancesOfClass FAILED\");\n+                    Asserts.assertEQ(count, 1, \"unexpected number of instances\");\n+                } finally {\n+                    terminateEndlessLoop();\n+                }\n+\n+                ABBox[] result = new ABBox[1];\n+                msg(\"get instances tagged with \" + instanceTag);\n+                int err = getObjectsWithTag(instanceTag, result);\n+                msg(\"Done.\");\n+                Asserts.assertEQ(0, err, \"getObjectsWithTag FAILED\");\n+\n+                ABBox abBoxArgEscape = result[0];\n+                while (!waitingForCheck) {\n+                    Thread.yield();\n+                }\n+                msg(\"Check abBoxArgEscape's state is consistent\");\n+                checkingNow = true;\n+                Asserts.assertTrue(abBoxArgEscape.check(), \"Detected inconsistent state. abBoxArgEscape.aVal != abBoxArgEscape.bVal\");\n+                msg(\"Ok.\");\n+            } finally {\n+                checkingNow = true;\n+                t1.join();\n+            }\n+        }\n+\n+        @Override\n+        public void dontinline_testMethod() {\n+            ABBox ab = new ABBox(this);\n+            dontinline_endlessLoop(ab);\n+            ab.synchronizedSlowInc();\n+        }\n+    }\n+\n+    \/**\n+     * Like {@link TestCase02a}, with the exception that at the location in {@link #dontinline_testMethod()} where the\n+     * ArgEscape escapes it is not referenced by a local variable.\n+     *\/\n+    public static class TestCase02b extends TestCaseBase {\n+\n+        public long instanceTag;\n+\n+        public TestCase02b(long classTag) {\n+            super(classTag, ABBox.class);\n+            instanceTag = classTag + 1;\n+        }\n+\n+        public void run() {\n+            try {\n+                msgHL(getClass().getName() + \": test if owning frame is deoptimized if ArgEscape escapes globally\");\n+                setUp();\n+                warmUp();\n+                for (TaggingAndCountingMethods m : TaggingAndCountingMethods.values()) {\n+                    msgHL(getClass().getName() + \": Tag and Get of ArgEscapes using \" + m.name());\n+                    waitingForCheck = false;\n+                    checkingNow = false;\n+                    WB.deflateIdleMonitors();\n+                    WB.fullGC(); \/\/ get rid of dead instances from previous test cases\n+                    runTest(m);\n+                }\n+            } catch (Exception e) {\n+                Asserts.fail(\"Unexpected Exception\", e);\n+            }\n+        }\n+\n+        public void runTest(TaggingAndCountingMethods m) throws Exception {\n+            loopCount = 1L << 62; \/\/ endless loop\n+            doLoop = true;\n+            Thread t1 = new Thread(() -> dontinline_testMethod(), \"Target Thread (\" + getClass().getName() + \")\");\n+            try {\n+                t1.start();\n+                try {\n+                    waitUntilTargetThreadHasEnteredEndlessLoop();\n+                    msg(\"count and tag instances of \" + taggedClass.getName() + \" with tag \" + instanceTag + \" using JVMTI \" + m.name());\n+                    int count = countAndTagInstancesOfClass(taggedClass, classTag, instanceTag, m);\n+                    msg(\"Done. Count is \" + count);\n+                    Asserts.assertGreaterThanOrEqual(count, 0, \"countAndTagInstancesOfClass FAILED\");\n+                    Asserts.assertEQ(count, 1, \"unexpected number of instances\");\n+                } finally {\n+                    terminateEndlessLoop();\n+                }\n+\n+                ABBox[] result = new ABBox[1];\n+                msg(\"get instances tagged with \" + instanceTag);\n+                int err = getObjectsWithTag(instanceTag, result);\n+                msg(\"Done.\");\n+                Asserts.assertEQ(0, err, \"getObjectsWithTag FAILED\");\n+\n+                ABBox abBoxArgEscape = result[0];\n+                while (!waitingForCheck) {\n+                    Thread.yield();\n+                }\n+                msg(\"Check abBoxArgEscape's state is consistent\");\n+                checkingNow = true;\n+                Asserts.assertTrue(abBoxArgEscape.check(), \"Detected inconsistent state. abBoxArgEscape.aVal != abBoxArgEscape.bVal\");\n+                msg(\"Ok.\");\n+            } finally {\n+                checkingNow = true;\n+                t1.join();\n+            }\n+        }\n+\n+        @Override\n+        public void dontinline_testMethod() {\n+            \/\/ The new instance is an ArgEscape instance and escapes to the JVMTI agent\n+            \/\/ while the target thread is in the call to dontinline_endlessLoop(). At this\n+            \/\/ location there is no local variable that references the ArgEscape.\n+            ((ABBox) dontinline_endlessLoop(new ABBox(this))).synchronizedSlowInc();;\n+        }\n+    }\n+\n+    public static void msg(String m) {\n+        System.out.println();\n+        System.out.println(\"### \" + m);\n+        System.out.println();\n+    }\n+\n+    public static void msgHL(String m) {\n+        System.out.println(); System.out.println(); System.out.println();\n+        System.out.println(\"#####################################################\");\n+        System.out.println(\"### \" + m);\n+        System.out.println(\"###\");\n+        System.out.println();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/Heap\/IterateHeapWithEscapeAnalysisEnabled.java","additions":610,"deletions":0,"binary":false,"changes":610,"status":"added"},{"patch":"@@ -0,0 +1,370 @@\n+\/*\n+ * Copyright (c) 2020 SAP SE. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <stdio.h>\n+#include <string.h>\n+#include \"jvmti.h\"\n+#include \"jni.h\"\n+\n+extern \"C\" {\n+\n+#define FAILED -1\n+#define OK      0\n+\n+static jvmtiEnv *jvmti;\n+\n+static jint Agent_Initialize(JavaVM *jvm, char *options, void *reserved);\n+\n+static void ShowErrorMessage(jvmtiEnv *jvmti, jvmtiError errCode, const char *message) {\n+  char *errMsg;\n+  jvmtiError result;\n+\n+  result = jvmti->GetErrorName(errCode, &errMsg);\n+  if (result == JVMTI_ERROR_NONE) {\n+    fprintf(stderr, \"%s: %s (%d)\\n\", message, errMsg, errCode);\n+    jvmti->Deallocate((unsigned char *)errMsg);\n+  } else {\n+    fprintf(stderr, \"%s (%d)\\n\", message, errCode);\n+  }\n+}\n+\n+JNIEXPORT jint JNICALL\n+Agent_OnLoad(JavaVM *jvm, char *options, void *reserved) {\n+  return Agent_Initialize(jvm, options, reserved);\n+}\n+\n+JNIEXPORT jint JNICALL\n+Agent_OnAttach(JavaVM *jvm, char *options, void *reserved) {\n+  return Agent_Initialize(jvm, options, reserved);\n+}\n+\n+JNIEXPORT jint JNICALL\n+JNI_OnLoad(JavaVM *jvm, void *reserved) {\n+  jint res;\n+  JNIEnv *env;\n+\n+  res = jvm->GetEnv((void **) &env, JNI_VERSION_9);\n+  if (res != JNI_OK || env == NULL) {\n+    fprintf(stderr, \"Error: GetEnv call failed(%d)!\\n\", res);\n+    return JNI_ERR;\n+  }\n+\n+  return JNI_VERSION_9;\n+}\n+\n+static jint\n+Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {\n+  jint res;\n+\n+  printf(\"Agent_OnLoad started\\n\");\n+\n+  res = jvm->GetEnv((void **) &jvmti, JVMTI_VERSION_9);\n+  if (res != JNI_OK || jvmti == NULL) {\n+    fprintf(stderr, \"Error: wrong result of a valid call to GetEnv!\\n\");\n+    return JNI_ERR;\n+  }\n+\n+  printf(\"Agent_OnLoad finished\\n\");\n+  return JNI_OK;\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_IterateHeapWithEscapeAnalysisEnabled_acquireCanTagObjectsCapability(JNIEnv *env, jclass cls) {\n+  jvmtiError err;\n+  jvmtiCapabilities caps;\n+\n+  memset(&caps, 0, sizeof(caps));\n+\n+  caps.can_tag_objects = 1;\n+\n+  err = jvmti->AddCapabilities(&caps);\n+  if (err != JVMTI_ERROR_NONE) {\n+    ShowErrorMessage(jvmti, err,\n+                     \"acquireCanTagObjectsCapability: error in JVMTI AddCapabilities\");\n+    return JNI_ERR;\n+  }\n+\n+  err = jvmti->GetCapabilities(&caps);\n+  if (err != JVMTI_ERROR_NONE) {\n+    ShowErrorMessage(jvmti, err,\n+                     \"acquireCanTagObjectsCapability: error in JVMTI GetCapabilities\");\n+    return JNI_ERR;\n+  }\n+\n+  if (!caps.can_tag_objects) {\n+    fprintf(stderr, \"Warning: didn't get the capability can_tag_objects\\n\");\n+    return JNI_ERR;\n+  }\n+\n+  return JNI_OK;\n+}\n+\n+static jobject method_IterateOverReachableObjects;\n+static jobject method_IterateOverHeap;\n+static jobject method_IterateOverInstancesOfClass;\n+static jobject method_FollowReferences;\n+static jobject method_IterateThroughHeap;\n+\n+JNIEXPORT jint JNICALL\n+Java_IterateHeapWithEscapeAnalysisEnabled_registerMethod(JNIEnv *env, jclass cls, jobject method, jstring name) {\n+  const char *name_chars = env->GetStringUTFChars(name, 0);\n+  int rc = FAILED;\n+  if (rc != OK && strcmp(name_chars, \"IterateOverReachableObjects\") == 0) {\n+    method_IterateOverReachableObjects = env->NewGlobalRef(method);\n+    rc = OK;\n+  }\n+  if (rc != OK && strcmp(name_chars, \"IterateOverHeap\") == 0) {\n+    method_IterateOverHeap = env->NewGlobalRef(method);\n+    rc = OK;\n+  }\n+  if (rc != OK && strcmp(name_chars, \"IterateOverInstancesOfClass\") == 0) {\n+    method_IterateOverInstancesOfClass = env->NewGlobalRef(method);\n+    rc = OK;\n+  }\n+  if (rc != OK && strcmp(name_chars, \"IterateThroughHeap\") == 0) {\n+    method_IterateThroughHeap = env->NewGlobalRef(method);\n+    rc = OK;\n+  }\n+  if (rc != OK && strcmp(name_chars, \"FollowReferences\") == 0) {\n+    method_FollowReferences = env->NewGlobalRef(method);\n+    rc = OK;\n+  }\n+  env->ReleaseStringUTFChars(name, name_chars);\n+  return rc;\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_IterateHeapWithEscapeAnalysisEnabled_agentTearDown(JNIEnv *env, jclass cls) {\n+  env->DeleteGlobalRef(method_IterateOverReachableObjects);\n+  env->DeleteGlobalRef(method_IterateOverHeap);\n+  env->DeleteGlobalRef(method_IterateOverInstancesOfClass);\n+  env->DeleteGlobalRef(method_FollowReferences);\n+  env->DeleteGlobalRef(method_IterateThroughHeap);\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_IterateHeapWithEscapeAnalysisEnabled_jvmtiTagClass(JNIEnv *env, jclass cls, jclass clsToTag, jlong tag) {\n+  jvmtiError err;\n+  err = jvmti->SetTag(clsToTag, tag);\n+  if (err != JVMTI_ERROR_NONE) {\n+    ShowErrorMessage(jvmti, err,\n+                     \"jvmtiTagClass: error in JVMTI SetTag\");\n+    return FAILED;\n+  }\n+  return OK;\n+}\n+\n+typedef struct Tag_And_Counter {\n+  jlong instance_counter;\n+  jlong class_tag;\n+  jlong instance_tag;\n+} Tag_And_Counter;\n+\n+static jvmtiIterationControl JNICALL\n+__stackReferenceCallback(jvmtiHeapRootKind root_kind,\n+                       jlong class_tag,\n+                       jlong size,\n+                       jlong* tag_ptr,\n+                       jlong thread_tag,\n+                       jint depth,\n+                       jmethodID method,\n+                       jint slot,\n+                         void* d) {\n+  Tag_And_Counter* data = (Tag_And_Counter*) d;\n+  if (class_tag == data->class_tag && *tag_ptr == 0) {\n+    data->instance_counter++;\n+    *tag_ptr = data->instance_tag;\n+  }\n+  return JVMTI_ITERATION_CONTINUE;\n+}\n+\n+static jvmtiIterationControl JNICALL\n+__jvmtiHeapObjectCallback(jlong class_tag, jlong size, jlong* tag_ptr, void* d) {\n+  Tag_And_Counter* data = (Tag_And_Counter*) d;\n+  if (class_tag == data->class_tag && *tag_ptr == 0) {\n+    data->instance_counter++;\n+    *tag_ptr = data->instance_tag;\n+  }\n+  return JVMTI_ITERATION_CONTINUE;\n+}\n+\n+static jint JNICALL\n+__jvmtiHeapReferenceCallback(jvmtiHeapReferenceKind reference_kind,\n+                             const jvmtiHeapReferenceInfo* reference_info,\n+                             jlong class_tag,\n+                             jlong referrer_class_tag,\n+                             jlong size,\n+                             jlong* tag_ptr,\n+                             jlong* referrer_tag_ptr,\n+                             jint length,\n+                             void* d) {\n+  Tag_And_Counter* data = (Tag_And_Counter*) d;\n+  if (class_tag == data->class_tag && *tag_ptr == 0) {\n+    data->instance_counter++;\n+    *tag_ptr = data->instance_tag;\n+  }\n+  return JVMTI_VISIT_OBJECTS;\n+}\n+\n+static jint JNICALL\n+__jvmtiHeapIterationCallback(jlong class_tag,\n+                             jlong size,\n+                             jlong* tag_ptr,\n+                             jint length,\n+                             void* d) {\n+  Tag_And_Counter* data = (Tag_And_Counter*) d;\n+  if (class_tag == data->class_tag && *tag_ptr == 0) {\n+    data->instance_counter++;\n+    *tag_ptr = data->instance_tag;\n+  }\n+  return JVMTI_VISIT_OBJECTS;\n+}\n+\n+\n+JNIEXPORT jlong JNICALL\n+Java_IterateHeapWithEscapeAnalysisEnabled_countAndTagInstancesOfClass(JNIEnv *env,\n+                                                                      jclass cls,\n+                                                                      jclass tagged_class,\n+                                                                      jlong cls_tag,\n+                                                                      jlong instance_tag,\n+                                                                      jobject method) {\n+  jvmtiError err;\n+  jvmtiHeapCallbacks callbacks = {};\n+  Tag_And_Counter data = {0, cls_tag, instance_tag};\n+  jboolean method_found = JNI_FALSE;\n+\n+  jint idx = 0;\n+\n+  if (env->IsSameObject(method, method_IterateOverReachableObjects)) {\n+    method_found = JNI_TRUE;\n+    err = jvmti->IterateOverReachableObjects(NULL \/*jvmtiHeapRootCallback*\/,\n+                                             __stackReferenceCallback,\n+                                             NULL \/* jvmtiObjectReferenceCallback *\/,\n+                                             &data);\n+    if (err != JVMTI_ERROR_NONE) {\n+      ShowErrorMessage(jvmti, err,\n+                       \"countAndTagInstancesOfClass: error in JVMTI IterateOverReachableObjects\");\n+      return FAILED;\n+    }\n+  }\n+  if (env->IsSameObject(method, method_IterateOverHeap)) {\n+    method_found = JNI_TRUE;\n+    err = jvmti->IterateOverHeap(JVMTI_HEAP_OBJECT_EITHER,\n+                                 __jvmtiHeapObjectCallback,\n+                                 &data);\n+    if (err != JVMTI_ERROR_NONE) {\n+      ShowErrorMessage(jvmti, err,\n+                       \"countAndTagInstancesOfClass: error in JVMTI IterateOverHeap\");\n+      return FAILED;\n+    }\n+  }\n+  if (env->IsSameObject(method, method_IterateOverInstancesOfClass)) {\n+    method_found = JNI_TRUE;\n+    err = jvmti->IterateOverInstancesOfClass(tagged_class,\n+                                             JVMTI_HEAP_OBJECT_EITHER,\n+                                             __jvmtiHeapObjectCallback,\n+                                             &data);\n+    if (err != JVMTI_ERROR_NONE) {\n+      ShowErrorMessage(jvmti, err,\n+                       \"countAndTagInstancesOfClass: error in JVMTI IterateOverHeap\");\n+      return FAILED;\n+    }\n+  }\n+  if (env->IsSameObject(method, method_FollowReferences)) {\n+    method_found = JNI_TRUE;\n+    callbacks.heap_reference_callback = __jvmtiHeapReferenceCallback;\n+    err = jvmti->FollowReferences(0 \/* filter nothing *\/,\n+                                  NULL \/* no class filter *\/,\n+                                  NULL \/* no initial object, follow roots *\/,\n+                                  &callbacks,\n+                                  &data);\n+    if (err != JVMTI_ERROR_NONE) {\n+      ShowErrorMessage(jvmti, err,\n+                       \"countAndTagInstancesOfClass: error in JVMTI FollowReferences\");\n+      return FAILED;\n+    }\n+  }\n+  if (env->IsSameObject(method, method_IterateThroughHeap)) {\n+    method_found = JNI_TRUE;\n+    callbacks.heap_iteration_callback = __jvmtiHeapIterationCallback;\n+    err = jvmti->IterateThroughHeap(0 \/* filter nothing *\/,\n+                                    NULL \/* no class filter *\/,\n+                                    &callbacks,\n+                                    &data);\n+    if (err != JVMTI_ERROR_NONE) {\n+      ShowErrorMessage(jvmti, err,\n+                       \"countAndTagInstancesOfClass: error in JVMTI IterateThroughHeap\");\n+      return FAILED;\n+    }\n+  }\n+\n+  if (!method_found) {\n+    fprintf(stderr, \"countAndTagInstancesOfClass: unknown method\\n\");\n+    return FAILED;\n+  }\n+\n+  return data.instance_counter;\n+}\n+\n+JNIEXPORT jlong JNICALL\n+Java_IterateHeapWithEscapeAnalysisEnabled_getObjectsWithTag(JNIEnv *env,\n+                                                            jclass cls,\n+                                                            jlong tag,\n+                                                            jobjectArray res_instances) {\n+  jvmtiError  err;\n+  const jlong tags[1] = {tag};\n+  jint        res_count = -1;\n+  jobject*    res_instances_raw;\n+  jlong*      res_tags;\n+  jint        res_instances_length;\n+  jint        idx;\n+\n+  err = jvmti->GetObjectsWithTags(1,\n+                                  tags,\n+                                  &res_count,\n+                                  &res_instances_raw,\n+                                  &res_tags);\n+  if (err != JVMTI_ERROR_NONE) {\n+    ShowErrorMessage(jvmti, err,\n+                     \"getObjectsWithTags: error in JVMTI GetObjectsWithTags\");\n+    return FAILED;\n+  }\n+\n+  res_instances_length = env->GetArrayLength(res_instances);\n+  if (res_count != res_instances_length) {\n+    fprintf(stderr, \"getObjectsWithTags: result array lenght (%d) does not match instance count returned by GetObjectsWithTags (%d) \\n\",\n+            res_instances_length, res_count);\n+    return FAILED;\n+  }\n+\n+  for (idx = 0; idx < res_count; idx++) {\n+    env->SetObjectArrayElement(res_instances, idx, res_instances_raw[idx]);\n+  }\n+\n+  jvmti->Deallocate((unsigned char *)res_instances_raw);\n+  jvmti->Deallocate((unsigned char *)res_tags);\n+\n+  return OK;\n+}\n+\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/Heap\/libIterateHeapWithEscapeAnalysisEnabled.cpp","additions":370,"deletions":0,"binary":false,"changes":370,"status":"added"},{"patch":"@@ -58,0 +58,1 @@\n+    vm.jvmci \\\n","filename":"test\/jdk\/TEST.ROOT","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,3145 @@\n+\/*\n+ * Copyright (c) 2020 SAP SE. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8227745\n+ * @summary Collection of test cases that check if optimizations based on escape analysis are reverted just before non-escaping objects escape through JVMTI.\n+ * @author Richard Reingruber richard DOT reingruber AT sap DOT com\n+ *\n+ * @requires ((vm.compMode == \"Xmixed\") & vm.compiler2.enabled)\n+ * @library \/test\/lib \/test\/hotspot\/jtreg\n+ *\n+ * @run build TestScaffold VMConnection TargetListener TargetAdapter sun.hotspot.WhiteBox\n+ * @run driver ClassFileInstaller sun.hotspot.WhiteBox\n+ * @run compile -g EATests.java\n+ * @run driver EATests\n+ *                 -XX:+UnlockDiagnosticVMOptions\n+ *                 -Xms256m -Xmx256m\n+ *                 -Xbootclasspath\/a:.\n+ *                 -XX:CompileCommand=dontinline,*::dontinline_*\n+ *                 -XX:+WhiteBoxAPI\n+ *                 -Xbatch\n+ *                 -XX:+DoEscapeAnalysis -XX:+EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks -XX:+UseBiasedLocking\n+ * @run driver EATests\n+ *                 -XX:+UnlockDiagnosticVMOptions\n+ *                 -Xms256m -Xmx256m\n+ *                 -Xbootclasspath\/a:.\n+ *                 -XX:CompileCommand=dontinline,*::dontinline_*\n+ *                 -XX:+WhiteBoxAPI\n+ *                 -Xbatch\n+ *                 -XX:+DoEscapeAnalysis -XX:+EliminateAllocations -XX:-EliminateLocks -XX:+EliminateNestedLocks -XX:+UseBiasedLocking -XX:-UseOptoBiasInlining\n+ * @run driver EATests\n+ *                 -XX:+UnlockDiagnosticVMOptions\n+ *                 -Xms256m -Xmx256m\n+ *                 -Xbootclasspath\/a:.\n+ *                 -XX:CompileCommand=dontinline,*::dontinline_*\n+ *                 -XX:+WhiteBoxAPI\n+ *                 -Xbatch\n+ *                 -XX:+DoEscapeAnalysis -XX:-EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks -XX:+UseBiasedLocking\n+ * @run driver EATests\n+ *                 -XX:+UnlockDiagnosticVMOptions\n+ *                 -Xms256m -Xmx256m\n+ *                 -Xbootclasspath\/a:.\n+ *                 -XX:CompileCommand=dontinline,*::dontinline_*\n+ *                 -XX:+WhiteBoxAPI\n+ *                 -Xbatch\n+ *                 -XX:-DoEscapeAnalysis -XX:-EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks -XX:+UseBiasedLocking\n+ * @run driver EATests\n+ *                 -XX:+UnlockDiagnosticVMOptions\n+ *                 -Xms256m -Xmx256m\n+ *                 -Xbootclasspath\/a:.\n+ *                 -XX:CompileCommand=dontinline,*::dontinline_*\n+ *                 -XX:+WhiteBoxAPI\n+ *                 -Xbatch\n+ *                 -XX:+DoEscapeAnalysis -XX:+EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks -XX:-UseBiasedLocking\n+ * @run driver EATests\n+ *                 -XX:+UnlockDiagnosticVMOptions\n+ *                 -Xms256m -Xmx256m\n+ *                 -Xbootclasspath\/a:.\n+ *                 -XX:CompileCommand=dontinline,*::dontinline_*\n+ *                 -XX:+WhiteBoxAPI\n+ *                 -Xbatch\n+ *                 -XX:+DoEscapeAnalysis -XX:-EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks -XX:-UseBiasedLocking\n+ * @run driver EATests\n+ *                 -XX:+UnlockDiagnosticVMOptions\n+ *                 -Xms256m -Xmx256m\n+ *                 -Xbootclasspath\/a:.\n+ *                 -XX:CompileCommand=dontinline,*::dontinline_*\n+ *                 -XX:+WhiteBoxAPI\n+ *                 -Xbatch\n+ *                 -XX:-DoEscapeAnalysis -XX:-EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks -XX:-UseBiasedLocking\n+ *\n+ * @comment Excercise -XX:+DeoptimizeObjectsALot. Mostly to prevent bit-rot because the option is meant to stress object deoptimization\n+ *          with non-synthetic workloads.\n+ * @run driver EATests\n+ *                 -XX:+UnlockDiagnosticVMOptions\n+ *                 -Xms256m -Xmx256m\n+ *                 -Xbootclasspath\/a:.\n+ *                 -XX:CompileCommand=dontinline,*::dontinline_*\n+ *                 -XX:+WhiteBoxAPI\n+ *                 -Xbatch\n+ *                 -XX:-DoEscapeAnalysis -XX:-EliminateAllocations -XX:+EliminateLocks -XX:+EliminateNestedLocks -XX:-UseBiasedLocking\n+ *                 -XX:+IgnoreUnrecognizedVMOptions -XX:+DeoptimizeObjectsALot\n+ *\n+ *\/\n+\/**\n+ * @test\n+ * @bug 8227745\n+ *\n+ * @summary This is another configuration of EATests.java to test Graal. Some testcases are expected\n+ *          to fail because Graal does not provide all information about non-escaping objects in\n+ *          scope. These are skipped.\n+ *\n+ * @author Richard Reingruber richard DOT reingruber AT sap DOT com\n+ *\n+ * @requires ((vm.compMode == \"Xmixed\") & vm.jvmci)\n+ *\n+ * @library \/test\/lib \/test\/hotspot\/jtreg\n+ *\n+ * @run build TestScaffold VMConnection TargetListener TargetAdapter sun.hotspot.WhiteBox\n+ * @run driver ClassFileInstaller sun.hotspot.WhiteBox\n+ * @run compile -g EATests.java\n+ *\n+ * @comment Test with Graal. Some testcases are expected to fail because Graal does not provide all information about non-escaping\n+ *          objects in scope. These are skipped.\n+ * @run driver EATests\n+ *                 -XX:+UnlockDiagnosticVMOptions\n+ *                 -Xms256m -Xmx256m\n+ *                 -Xbootclasspath\/a:.\n+ *                 -XX:CompileCommand=dontinline,*::dontinline_*\n+ *                 -XX:+WhiteBoxAPI\n+ *                 -Xbatch\n+ *                 -XX:+UnlockExperimentalVMOptions -XX:+UseJVMCICompiler\n+ *\/\n+\n+import com.sun.jdi.*;\n+import com.sun.jdi.event.*;\n+import compiler.testlibrary.CompilerUtils;\n+import compiler.whitebox.CompilerWhiteBoxTest;\n+\n+import java.lang.reflect.Array;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Function;\n+\n+import jdk.test.lib.Asserts;\n+import sun.hotspot.WhiteBox;\n+\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\/\/\n+\/\/ Shared base class for test cases for both, debugger and debuggee.\n+\/\/\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+class EATestCaseBaseShared {\n+    \/\/ In interactive mode we wait for a keypress before every test case.\n+    public static final boolean INTERACTIVE =\n+            System.getProperty(\"EATests.interactive\") != null &&\n+            System.getProperty(\"EATests.interactive\").equals(\"true\");\n+\n+    \/\/ If the property is given, then just the test case it refers to is executed.\n+    \/\/ Use it to diagnose test failures.\n+    public static final String RUN_ONLY_TEST_CASE_PROPERTY = \"EATests.onlytestcase\";\n+    public static final String RUN_ONLY_TEST_CASE = System.getProperty(RUN_ONLY_TEST_CASE_PROPERTY);\n+\n+    public final String testCaseName;\n+\n+    public EATestCaseBaseShared() {\n+        String clName = getClass().getName();\n+        int tidx = clName.lastIndexOf(\"Target\");\n+        testCaseName = tidx > 0 ? clName.substring(0, tidx) : clName;\n+    }\n+\n+    public boolean shouldSkip() {\n+        return EATestCaseBaseShared.RUN_ONLY_TEST_CASE != null &&\n+               EATestCaseBaseShared.RUN_ONLY_TEST_CASE.length() > 0 &&\n+               !testCaseName.equals(EATestCaseBaseShared.RUN_ONLY_TEST_CASE);\n+    }\n+}\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\/\/\n+\/\/ Target main class, i.e. the program to be debugged.\n+\/\/\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+class EATestsTarget {\n+\n+    public static void main(String[] args) {\n+        EATestCaseBaseTarget.staticSetUp();\n+        EATestCaseBaseTarget.staticSetUpDone();\n+\n+        \/\/ Materializing test cases, i.e. reallocating objects on the heap\n+        new EAMaterializeLocalVariableUponGetTarget()                                       .run();\n+        new EAGetWithoutMaterializeTarget()                                                 .run();\n+        new EAMaterializeLocalAtObjectReturnTarget()                                        .run();\n+        new EAMaterializeLocalAtObjectPollReturnReturnTarget()                              .run();\n+        new EAMaterializeIntArrayTarget()                                                   .run();\n+        new EAMaterializeLongArrayTarget()                                                  .run();\n+        new EAMaterializeFloatArrayTarget()                                                 .run();\n+        new EAMaterializeDoubleArrayTarget()                                                .run();\n+        new EAMaterializeObjectArrayTarget()                                                .run();\n+        new EAMaterializeObjectWithConstantAndNotConstantValuesTarget()                     .run();\n+        new EAMaterializeObjReferencedBy2LocalsTarget()                                     .run();\n+        new EAMaterializeObjReferencedBy2LocalsAndModifyTarget()                            .run();\n+        new EAMaterializeObjReferencedBy2LocalsInDifferentVirtFramesTarget()                .run();\n+        new EAMaterializeObjReferencedBy2LocalsInDifferentVirtFramesAndModifyTarget()       .run();\n+        new EAMaterializeObjReferencedFromOperandStackTarget()                              .run();\n+        new EAMaterializeLocalVariableUponGetAfterSetIntegerTarget()                        .run();\n+\n+        \/\/ Relocking test cases\n+        new EARelockingSimpleTarget()                                                       .run();\n+        new EARelockingSimple_2Target()                                                     .run();\n+        new EARelockingRecursiveTarget()                                                    .run();\n+        new EARelockingNestedInflatedTarget()                                               .run();\n+        new EARelockingNestedInflated_02Target()                                            .run();\n+        new EARelockingArgEscapeLWLockedInCalleeFrameTarget()                               .run();\n+        new EARelockingArgEscapeLWLockedInCalleeFrame_2Target()                             .run();\n+        new EARelockingArgEscapeLWLockedInCalleeFrame_3Target()                             .run();\n+        new EARelockingArgEscapeLWLockedInCalleeFrame_4Target()                             .run();\n+        new EAGetOwnedMonitorsTarget()                                                      .run();\n+        new EAEntryCountTarget()                                                            .run();\n+        new EARelockingObjectCurrentlyWaitingOnTarget()                                     .run();\n+\n+        \/\/ Test cases that require deoptimization even though neither\n+        \/\/ locks nor allocations are eliminated at the point where\n+        \/\/ escape state is changed.\n+        new EADeoptFrameAfterReadLocalObject_01Target()                                     .run();\n+        new EADeoptFrameAfterReadLocalObject_01BTarget()                                    .run();\n+        new EADeoptFrameAfterReadLocalObject_02Target()                                     .run();\n+        new EADeoptFrameAfterReadLocalObject_02BTarget()                                    .run();\n+        new EADeoptFrameAfterReadLocalObject_02CTarget()                                    .run();\n+        new EADeoptFrameAfterReadLocalObject_03Target()                                     .run();\n+\n+        \/\/ PopFrame test cases\n+        new EAPopFrameNotInlinedTarget()                                                    .run();\n+        new EAPopFrameNotInlinedReallocFailureTarget()                                      .run();\n+        new EAPopInlinedMethodWithScalarReplacedObjectsReallocFailureTarget()               .run();\n+\n+        \/\/ ForceEarlyReturn test cases\n+        new EAForceEarlyReturnNotInlinedTarget()                                            .run();\n+        new EAForceEarlyReturnOfInlinedMethodWithScalarReplacedObjectsTarget()              .run();\n+        new EAForceEarlyReturnOfInlinedMethodWithScalarReplacedObjectsReallocFailureTarget().run();\n+\n+        \/\/ Instances of ReferenceType\n+        new EAGetInstancesOfReferenceTypeTarget()                                           .run();\n+    }\n+}\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\/\/\n+\/\/ Debugger main class\n+\/\/\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+public class EATests extends TestScaffold {\n+\n+    public TargetVMOptions targetVMOptions;\n+    public ThreadReference targetMainThread;\n+\n+    EATests(String args[]) {\n+        super(args);\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        if (EATestCaseBaseShared.RUN_ONLY_TEST_CASE != null) {\n+            args = Arrays.copyOf(args, args.length + 1);\n+            args[args.length - 1] = \"-D\" + EATestCaseBaseShared.RUN_ONLY_TEST_CASE_PROPERTY + \"=\" + EATestCaseBaseShared.RUN_ONLY_TEST_CASE;\n+        }\n+        new EATests(args).startTests();\n+    }\n+\n+    public static class TargetVMOptions {\n+\n+        public final boolean UseJVMCICompiler;\n+        public final boolean EliminateAllocations;\n+        public final boolean DeoptimizeObjectsALot;\n+\n+        public TargetVMOptions(EATests env, ClassType testCaseBaseTargetClass) {\n+            Value val = testCaseBaseTargetClass.getValue(testCaseBaseTargetClass.fieldByName(\"EliminateAllocations\"));\n+            EliminateAllocations = ((PrimitiveValue) val).booleanValue();\n+            val = testCaseBaseTargetClass.getValue(testCaseBaseTargetClass.fieldByName(\"DeoptimizeObjectsALot\"));\n+            DeoptimizeObjectsALot = ((PrimitiveValue) val).booleanValue();\n+            val = testCaseBaseTargetClass.getValue(testCaseBaseTargetClass.fieldByName(\"UseJVMCICompiler\"));\n+            UseJVMCICompiler = ((PrimitiveValue) val).booleanValue();\n+        }\n+\n+    }\n+\n+    \/\/ Execute known test cases\n+    protected void runTests() throws Exception {\n+        String targetProgName = EATestsTarget.class.getName();\n+        msg(\"starting to main method in class \" +  targetProgName);\n+        startToMain(targetProgName);\n+        msg(\"resuming to EATestCaseBaseTarget.staticSetUpDone()V\");\n+        targetMainThread = resumeTo(\"EATestCaseBaseTarget\", \"staticSetUpDone\", \"()V\").thread();\n+        Location loc = targetMainThread.frame(0).location();\n+        Asserts.assertEQ(\"staticSetUpDone\", loc.method().name());\n+\n+        targetVMOptions = new TargetVMOptions(this, (ClassType) loc.declaringType());\n+\n+        \/\/ Materializing test cases, i.e. reallocating objects on the heap\n+        new EAMaterializeLocalVariableUponGet()                                       .run(this);\n+        new EAGetWithoutMaterialize()                                                 .run(this);\n+        new EAMaterializeLocalAtObjectReturn()                                        .run(this);\n+        new EAMaterializeLocalAtObjectPollReturnReturn()                              .run(this);\n+        new EAMaterializeIntArray()                                                   .run(this);\n+        new EAMaterializeLongArray()                                                  .run(this);\n+        new EAMaterializeFloatArray()                                                 .run(this);\n+        new EAMaterializeDoubleArray()                                                .run(this);\n+        new EAMaterializeObjectArray()                                                .run(this);\n+        new EAMaterializeObjectWithConstantAndNotConstantValues()                     .run(this);\n+        new EAMaterializeObjReferencedBy2Locals()                                     .run(this);\n+        new EAMaterializeObjReferencedBy2LocalsAndModify()                            .run(this);\n+        new EAMaterializeObjReferencedBy2LocalsInDifferentVirtFrames()                .run(this);\n+        new EAMaterializeObjReferencedBy2LocalsInDifferentVirtFramesAndModify()       .run(this);\n+        new EAMaterializeObjReferencedFromOperandStack()                              .run(this);\n+        new EAMaterializeLocalVariableUponGetAfterSetInteger()                        .run(this);\n+\n+        \/\/ Relocking test cases\n+        new EARelockingSimple()                                                       .run(this);\n+        new EARelockingSimple_2()                                                     .run(this);\n+        new EARelockingRecursive()                                                    .run(this);\n+        new EARelockingNestedInflated()                                               .run(this);\n+        new EARelockingNestedInflated_02()                                            .run(this);\n+        new EARelockingArgEscapeLWLockedInCalleeFrame()                               .run(this);\n+        new EARelockingArgEscapeLWLockedInCalleeFrame_2()                             .run(this);\n+        new EARelockingArgEscapeLWLockedInCalleeFrame_3()                             .run(this);\n+        new EARelockingArgEscapeLWLockedInCalleeFrame_4()                             .run(this);\n+        new EAGetOwnedMonitors()                                                      .run(this);\n+        new EAEntryCount()                                                            .run(this);\n+        new EARelockingObjectCurrentlyWaitingOn()                                     .run(this);\n+\n+        \/\/ Test cases that require deoptimization even though neither\n+        \/\/ locks nor allocations are eliminated at the point where\n+        \/\/ escape state is changed.\n+        new EADeoptFrameAfterReadLocalObject_01()                                     .run(this);\n+        new EADeoptFrameAfterReadLocalObject_01B()                                    .run(this);\n+        new EADeoptFrameAfterReadLocalObject_02()                                     .run(this);\n+        new EADeoptFrameAfterReadLocalObject_02B()                                    .run(this);\n+        new EADeoptFrameAfterReadLocalObject_02C()                                    .run(this);\n+        new EADeoptFrameAfterReadLocalObject_03()                                     .run(this);\n+\n+        \/\/ PopFrame test cases\n+        new EAPopFrameNotInlined()                                                    .run(this);\n+        new EAPopFrameNotInlinedReallocFailure()                                      .run(this);\n+        new EAPopInlinedMethodWithScalarReplacedObjectsReallocFailure()               .run(this);\n+\n+        \/\/ ForceEarlyReturn test cases\n+        new EAForceEarlyReturnNotInlined()                                            .run(this);\n+        new EAForceEarlyReturnOfInlinedMethodWithScalarReplacedObjects()              .run(this);\n+        new EAForceEarlyReturnOfInlinedMethodWithScalarReplacedObjectsReallocFailure().run(this);\n+\n+        \/\/ Instances of ReferenceType\n+        new EAGetInstancesOfReferenceType()                                           .run(this);\n+\n+        \/\/ resume the target listening for events\n+        listenUntilVMDisconnect();\n+    }\n+\n+    \/\/ Print a Message\n+    public void msg(String m) {\n+        System.out.println();\n+        System.out.println(\"###(Debugger) \" + m);\n+        System.out.println();\n+    }\n+\n+    \/\/ Highlighted message.\n+    public void msgHL(String m) {\n+        System.out.println();\n+        System.out.println();\n+        System.out.println(\"##########################################################\");\n+        System.out.println(\"### \" + m);\n+        System.out.println(\"### \");\n+        System.out.println();\n+        System.out.println();\n+    }\n+}\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\/\/\n+\/\/ Base class for debugger side of test cases.\n+\/\/\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+abstract class EATestCaseBaseDebugger  extends EATestCaseBaseShared {\n+\n+    protected EATests env;\n+\n+    public ObjectReference testCase;\n+\n+    public static final String TARGET_TESTCASE_BASE_NAME = EATestCaseBaseTarget.class.getName();\n+\n+    public static final String XYVAL_NAME = XYVal.class.getName();\n+\n+    public abstract void runTestCase() throws Exception;\n+\n+    public void run(EATests env) {\n+        this.env = env;\n+        if (shouldSkip()) {\n+            msg(\"skipping \" + testCaseName);\n+            return;\n+        }\n+        try {\n+            msgHL(\"Executing test case \" + getClass().getName());\n+            env.testFailed = false;\n+\n+            if (INTERACTIVE)\n+                env.waitForInput();\n+\n+            resumeToWarmupDone();\n+            runTestCase();\n+            Asserts.assertTrue(env.targetMainThread.isSuspended(), \"must be suspended after the testcase\");\n+            resumeToTestCaseDone();\n+            checkPostConditions();\n+        } catch (Exception e) {\n+            Asserts.fail(\"Unexpected exception in test case \" + getClass().getName(), e);\n+        }\n+    }\n+\n+    public void resumeToWarmupDone() throws Exception {\n+        msg(\"resuming to \" + TARGET_TESTCASE_BASE_NAME + \".warmupDone()V\");\n+        env.resumeTo(TARGET_TESTCASE_BASE_NAME, \"warmupDone\", \"()V\");\n+        testCase = env.targetMainThread.frame(0).thisObject();\n+    }\n+\n+    public void resumeToTestCaseDone() {\n+        msg(\"resuming to \" + TARGET_TESTCASE_BASE_NAME + \".testCaseDone()V\");\n+        env.resumeTo(TARGET_TESTCASE_BASE_NAME, \"testCaseDone\", \"()V\");\n+    }\n+\n+    public void checkPostConditions() throws Exception {\n+        Asserts.assertFalse(env.getExceptionCaught(), \"Uncaught exception in Debuggee\");\n+\n+        String testName = getClass().getName();\n+        if (!env.testFailed) {\n+            env.println(testName  + \": passed\");\n+        } else {\n+            throw new Exception(testName + \": failed\");\n+        }\n+    }\n+\n+    public void printStack(ThreadReference thread) throws Exception {\n+        msg(\"Debuggee Stack:\");\n+        List<StackFrame> stack_frames = thread.frames();\n+        int i = 0;\n+        for (StackFrame ff : stack_frames) {\n+            System.out.println(\"frame[\" + i++ +\"]: \" + ff.location().method() + \" (bci:\" + ff.location().codeIndex() + \")\");\n+        }\n+    }\n+\n+    public void msg(String m) {\n+        env.msg(m);\n+    }\n+\n+    public void msgHL(String m) {\n+        env.msgHL(m);\n+    }\n+\n+    \/\/ See Field Descriptors in The Java Virtual Machine Specification\n+    \/\/ (https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se11\/html\/jvms-4.html#jvms-4.3.2)\n+    enum FD {\n+        I, \/\/ int\n+        J, \/\/ long\n+        F, \/\/ float\n+        D, \/\/ double\n+    }\n+\n+    \/\/ Map field descriptor to jdi type string\n+    public static final Map<FD, String> FD2JDIArrType = Map.of(FD.I, \"int[]\", FD.J, \"long[]\", FD.F, \"float[]\", FD.D, \"double[]\");\n+\n+    \/\/ Map field descriptor to PrimitiveValue getter\n+    public static final Function<PrimitiveValue, Integer> v2I = PrimitiveValue::intValue;\n+    public static final Function<PrimitiveValue, Long>    v2J = PrimitiveValue::longValue;\n+    public static final Function<PrimitiveValue, Float>   v2F = PrimitiveValue::floatValue;\n+    public static final Function<PrimitiveValue, Double>  v2D = PrimitiveValue::doubleValue;\n+    Map<FD, Function<PrimitiveValue, ?>> FD2getter = Map.of(FD.I, v2I, FD.J, v2J, FD.F, v2F, FD.D, v2D);\n+\n+    \/**\n+     * Retrieve array of primitive values referenced by a local variable in target and compare with\n+     * an array of expected values.\n+     * @param frame Frame in the target holding the local variable\n+     * @param lName Name of the local variable referencing the array to be retrieved\n+     * @param desc Array element type given as field descriptor.\n+     * @param expVals Array of expected values.\n+     * @throws Exception\n+     *\/\n+    protected void checkLocalPrimitiveArray(StackFrame frame, String lName, FD desc, Object expVals) throws Exception {\n+        String lType = FD2JDIArrType.get(desc);\n+        Asserts.assertNotNull(lType, \"jdi type not found\");\n+        Asserts.assertEQ(EATestCaseBaseTarget.TESTMETHOD_DEFAULT_NAME, frame .location().method().name());\n+        List<LocalVariable> localVars = frame.visibleVariables();\n+        msg(\"Check if the local array variable '\" + lName  + \"' in \" + EATestCaseBaseTarget.TESTMETHOD_DEFAULT_NAME + \" has the expected elements: \");\n+        boolean found = false;\n+        for (LocalVariable lv : localVars) {\n+            if (lv.name().equals(lName)) {\n+                found  = true;\n+                Value lVal = frame.getValue(lv);\n+                Asserts.assertNotNull(lVal);\n+                Asserts.assertEQ(lVal.type().name(), lType);\n+                ArrayReference aRef = (ArrayReference) lVal;\n+                Asserts.assertEQ(3, aRef.length());\n+                \/\/ now check the elements\n+                for (int i = 0; i < aRef.length(); i++) {\n+                    Object actVal = FD2getter.get(desc).apply((PrimitiveValue)aRef.getValue(i));\n+                    Object expVal = Array.get(expVals, i);\n+                    Asserts.assertEQ(expVal, actVal, \"checking element at index \" + i);\n+                }\n+            }\n+        }\n+        Asserts.assertTrue(found);\n+        msg(\"OK.\");\n+    }\n+\n+    \/**\n+     * Retrieve array of objects referenced by a local variable in target and compare with an array\n+     * of expected values.\n+     * @param frame Frame in the target holding the local variable\n+     * @param lName Name of the local variable referencing the array to be retrieved\n+     * @param lType Local type, e.g. java.lang.Long[]\n+     * @param expVals Array of expected values.\n+     * @throws Exception\n+     *\/\n+    protected void checkLocalObjectArray(StackFrame frame, String lName, String lType, ObjectReference[] expVals) throws Exception {\n+        Asserts.assertEQ(EATestCaseBaseTarget.TESTMETHOD_DEFAULT_NAME, frame .location().method().name());\n+        List<LocalVariable> localVars = frame.visibleVariables();\n+        msg(\"Check if the local array variable '\" + lName  + \"' in \" + EATestCaseBaseTarget.TESTMETHOD_DEFAULT_NAME + \" has the expected elements: \");\n+        boolean found = false;\n+        for (LocalVariable lv : localVars) {\n+            if (lv.name().equals(lName)) {\n+                found  = true;\n+                Value lVal = frame.getValue(lv);\n+                Asserts.assertNotNull(lVal);\n+                Asserts.assertEQ(lType, lVal.type().name());\n+                ArrayReference aRef = (ArrayReference) lVal;\n+                Asserts.assertEQ(3, aRef.length());\n+                \/\/ now check the elements\n+                for (int i = 0; i < aRef.length(); i++) {\n+                    ObjectReference actVal = (ObjectReference)aRef.getValue(i);\n+                    Asserts.assertSame(expVals[i], actVal, \"checking element at index \" + i);\n+                }\n+            }\n+        }\n+        Asserts.assertTrue(found);\n+        msg(\"OK.\");\n+    }\n+\n+    \/**\n+     * Retrieve a reference held by a local variable in the given frame. Check if the frame's method\n+     * is the expected method if the retrieved local value has the expected type and is not null.\n+     * @param frame The frame to retrieve the local variable value from.\n+     * @param expectedMethodName The name of the frames method should match the expectedMethodName.\n+     * @param lName The name of the local variable which is read.\n+     * @param expectedType Is the expected type of the object referenced by the local variable.\n+     * @return\n+     * @throws Exception\n+     *\/\n+    protected ObjectReference getLocalRef(StackFrame frame, String expectedMethodName, String lName, String expectedType) throws Exception {\n+        Asserts.assertEQ(expectedMethodName, frame.location().method().name());\n+        List<LocalVariable> localVars = frame.visibleVariables();\n+        msg(\"Get and check local variable '\" + lName + \"' in \" + expectedMethodName);\n+        ObjectReference lRef = null;\n+        for (LocalVariable lv : localVars) {\n+            if (lv.name().equals(lName)) {\n+                Value lVal = frame.getValue(lv);\n+                Asserts.assertNotNull(lVal);\n+                Asserts.assertEQ(expectedType, lVal.type().name());\n+                lRef = (ObjectReference) lVal;\n+                break;\n+            }\n+        }\n+        Asserts.assertNotNull(lRef, \"Local variable '\" + lName + \"' not found\");\n+        msg(\"OK.\");\n+        return lRef;\n+    }\n+\n+    \/**\n+     * Retrieve a reference held by a local variable in the given frame. Check if the frame's method\n+     * matches {@link EATestCaseBaseTarget#TESTMETHOD_DEFAULT_NAME} if the retrieved local value has\n+     * the expected type and is not null.\n+     * @param frame The frame to retrieve the local variable value from.\n+     * @param expectedMethodName The name of the frames method should match the expectedMethodName.\n+     * @param lName The name of the local variable which is read.\n+     * @param expectedType Is the expected type of the object referenced by the local variable.\n+     * @return\n+     * @throws Exception\n+     *\/\n+    protected ObjectReference getLocalRef(StackFrame frame, String lType, String lName) throws Exception {\n+        return getLocalRef(frame, EATestCaseBaseTarget.TESTMETHOD_DEFAULT_NAME, lName, lType);\n+    }\n+\n+    \/**\n+     * Set the value of a local variable in the given frame. Check if the frame's method is the expected method.\n+     * @param frame The frame holding the local variable.\n+     * @param expectedMethodName The expected name of the frame's method.\n+     * @param lName The name of the local variable to change.\n+     * @param val The new value of the local variable.\n+     * @throws Exception\n+     *\/\n+    public void setLocal(StackFrame frame, String expectedMethodName, String lName, Value val) throws Exception {\n+        Asserts.assertEQ(expectedMethodName, frame.location().method().name());\n+        List<LocalVariable> localVars = frame.visibleVariables();\n+        msg(\"Set local variable '\" + lName + \"' = \" + val + \" in \" + expectedMethodName);\n+        for (LocalVariable lv : localVars) {\n+            if (lv.name().equals(lName)) {\n+                frame.setValue(lv, val);\n+                break;\n+            }\n+        }\n+        msg(\"OK.\");\n+    }\n+\n+    \/**\n+     * Set the value of a local variable in the given frame. Check if the frame's method matches\n+     * {@link EATestCaseBaseTarget#TESTMETHOD_DEFAULT_NAME}.\n+     * @param frame The frame holding the local variable.\n+     * @param expectedMethodName The expected name of the frame's method.\n+     * @param lName The name of the local variable to change.\n+     * @param val The new value of the local variable.\n+     * @throws Exception\n+     *\/\n+    public void setLocal(StackFrame frame, String lName, Value val) throws Exception {\n+        setLocal(frame, EATestCaseBaseTarget.TESTMETHOD_DEFAULT_NAME, lName, val);\n+    }\n+\n+    \/**\n+     * Check if a field has the expected primitive value.\n+     * @param o Object holding the field.\n+     * @param desc Field descriptor.\n+     * @param fName Field name\n+     * @param expVal Expected primitive value\n+     * @throws Exception\n+     *\/\n+    protected void checkPrimitiveField(ObjectReference o, FD desc, String fName, Object expVal) throws Exception {\n+        msg(\"check field \" + fName);\n+        ReferenceType rt = o.referenceType();\n+        Field fld = rt.fieldByName(fName);\n+        Value val = o.getValue(fld);\n+        Object actVal = FD2getter.get(desc).apply((PrimitiveValue) val);\n+        Asserts.assertEQ(expVal, actVal, \"field '\" + fName + \"' has unexpected value.\");\n+        msg(\"ok\");\n+    }\n+\n+    \/**\n+     * Check if a field references the expected object.\n+     * @param obj Object holding the field.\n+     * @param fName Field name\n+     * @param expVal Object expected to be referenced by the field\n+     * @throws Exception\n+     *\/\n+    protected void checkObjField(ObjectReference obj, String fName, ObjectReference expVal) throws Exception {\n+        msg(\"check field \" + fName);\n+        ReferenceType rt = obj.referenceType();\n+        Field fld = rt.fieldByName(fName);\n+        Value actVal = obj.getValue(fld);\n+        Asserts.assertEQ(expVal, actVal, \"field '\" + fName + \"' has unexpected value.\");\n+        msg(\"ok\");\n+    }\n+\n+    protected void setField(ObjectReference obj, String fName, Value val) throws Exception {\n+        msg(\"set field \" + fName + \" = \" + val);\n+        ReferenceType rt = obj.referenceType();\n+        Field fld = rt.fieldByName(fName);\n+        obj.setValue(fld, val);\n+        msg(\"ok\");\n+    }\n+\n+    protected Value getField(ObjectReference obj, String fName) throws Exception {\n+        msg(\"get field \" + fName);\n+        ReferenceType rt = obj.referenceType();\n+        Field fld = rt.fieldByName(fName);\n+        Value val = obj.getValue(fld);\n+        msg(\"result : \" + val);\n+        return val;\n+    }\n+\n+    \/**\n+     * Free the memory consumed in the target by {@link EATestCaseBaseTarget#consumedMemory}\n+     * @throws Exception\n+     *\/\n+    public void freeAllMemory() throws Exception {\n+        msg(\"free consumed memory\");\n+        setField(testCase, \"consumedMemory\", null);\n+    }\n+\n+    \/**\n+     * @return The value of {@link EATestCaseBaseTarget#targetIsInLoop}. The target must set that field to true as soon as it\n+     *         enters the endless loop.\n+     * @throws Exception\n+     *\/\n+    public boolean targetHasEnteredEndlessLoop() throws Exception {\n+        Value v = getField(testCase, \"targetIsInLoop\");\n+        return ((PrimitiveValue) v).booleanValue();\n+    }\n+\n+    \/**\n+     * Poll {@link EATestCaseBaseTarget#targetIsInLoop} and return if it is found to be true.\n+     * @throws Exception\n+     *\/\n+    public void waitUntilTargetHasEnteredEndlessLoop() throws Exception {\n+        while(!targetHasEnteredEndlessLoop()) {\n+            msg(\"Target has not yet entered the loop. Sleep 200ms.\");\n+            try { Thread.sleep(200); } catch (InterruptedException e) { \/*ignore *\/ }\n+        }\n+    }\n+\n+    \/**\n+     * Set {@link EATestCaseBaseTarget#doLoop} to <code>false<\/code>. This will allow the target to\n+     * leave the endless loop.\n+     * @throws Exception\n+     *\/\n+    public void terminateEndlessLoop() throws Exception {\n+        msg(\"terminate loop\");\n+        setField(testCase, \"doLoop\", env.vm().mirrorOf(false));\n+    }\n+}\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\/\/\n+\/\/ Base class for debuggee side of test cases.\n+\/\/\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+abstract class EATestCaseBaseTarget extends EATestCaseBaseShared implements Runnable {\n+\n+    \/**\n+     * The target must set that field to true as soon as it enters the endless loop.\n+     *\/\n+    public volatile boolean targetIsInLoop;\n+\n+    \/**\n+     * Used for busy loops. See {@link #dontinline_endlessLoop()}.\n+     *\/\n+    public volatile long loopCount;\n+\n+    \/**\n+     * Used in {@link EATestCaseBaseDebugger#terminateEndlessLoop()} to signal target to leave the endless loop.\n+     *\/\n+    public volatile boolean doLoop;\n+\n+    public long checkSum;\n+\n+    public static final String TESTMETHOD_DEFAULT_NAME = \"dontinline_testMethod\";\n+\n+    public static final WhiteBox WB = WhiteBox.getWhiteBox();\n+\n+    public static boolean unbox(Boolean value, boolean dflt) {\n+        return value == null ? dflt : value;\n+    }\n+\n+    public static final boolean UseJVMCICompiler     = unbox(WB.getBooleanVMFlag(\"UseJVMCICompiler\"), false); \/\/ read by debugger\n+    public static final boolean DoEscapeAnalysis     = unbox(WB.getBooleanVMFlag(\"DoEscapeAnalysis\"), UseJVMCICompiler);\n+    public static final boolean EliminateAllocations = unbox(WB.getBooleanVMFlag(\"EliminateAllocations\"), UseJVMCICompiler); \/\/ read by debugger\n+    public static final boolean DeoptimizeObjectsALot   = WB.getBooleanVMFlag(\"DeoptimizeObjectsALot\");                      \/\/ read by debugger\n+    public static final long BiasedLockingBulkRebiasThreshold = WB.getIntxVMFlag(\"BiasedLockingBulkRebiasThreshold\");\n+    public static final long BiasedLockingBulkRevokeThreshold = WB.getIntxVMFlag(\"BiasedLockingBulkRevokeThreshold\");\n+\n+    public String testMethodName;\n+    public int testMethodDepth;\n+\n+    \/\/ Results produced by dontinline_testMethod()\n+    public int  iResult;\n+    public long lResult;\n+    public float  fResult;\n+    public double dResult;\n+\n+\n+    public boolean warmupDone;\n+    \/\/ With UseJVMCICompiler it is possible that a compilation is made a\n+    \/\/ background compilation even though -Xbatch is given (e.g. if JVMCI is not\n+    \/\/ yet fully initialized). Therefore it is possible that the test method has\n+    \/\/ not reached the highest compilation level after warm-up.\n+    public boolean testMethodReachedHighestCompLevel;\n+\n+    public volatile Object biasToBeRevoked;\n+\n+    \/\/ an object with an inflated monitor\n+    public static XYVal inflatedLock;\n+    public static Thread  inflatorThread;\n+    public static boolean inflatedLockIsPermanentlyInflated;\n+\n+    public static int    NOT_CONST_1I = 1;\n+    public static long   NOT_CONST_1L = 1L;\n+    public static float  NOT_CONST_1F = 1.1F;\n+    public static double NOT_CONST_1D = 1.1D;\n+\n+    public static          Long NOT_CONST_1_OBJ = Long.valueOf(1);\n+\n+\n+    public static final    Long CONST_2_OBJ     = Long.valueOf(2);\n+    public static final    Long CONST_3_OBJ     = Long.valueOf(3);\n+\n+    \/**\n+     * Main driver of a test case.\n+     * <ul>\n+     * <li> Skips test case if not selected (see {@link EATestCaseBaseShared#RUN_ONLY_TEST_CASE}\n+     * <li> Call {@link #setUp()}\n+     * <li> warm-up and compile {@link #dontinline_testMethod()} (see {@link #compileTestMethod()}\n+     * <li> calling {@link #dontinline_testMethod()}\n+     * <li> checking the result (see {@link #checkResult()}\n+     * <ul>\n+     *\/\n+    public void run() {\n+        try {\n+            if (shouldSkip()) {\n+                msg(\"skipping \" + testCaseName);\n+                return;\n+            }\n+            setUp();\n+            msg(testCaseName + \" is up and running.\");\n+            compileTestMethod();\n+            msg(testCaseName + \" warmup done.\");\n+            warmupDone();\n+            checkCompLevel();\n+            dontinline_testMethod();\n+            checkResult();\n+            msg(testCaseName + \" done.\");\n+            testCaseDone();\n+        } catch (Exception e) {\n+            Asserts.fail(\"Caught unexpected exception\", e);\n+        }\n+    }\n+\n+    public static void staticSetUp() {\n+        inflatedLock = new XYVal(1, 1);\n+        synchronized (inflatedLock) {\n+            inflatorThread = new Thread(\"Lock Inflator (test thread)\") {\n+                @Override\n+                public void run() {\n+                    synchronized (inflatedLock) {\n+                        inflatedLockIsPermanentlyInflated = true;\n+                        inflatedLock.notify(); \/\/ main thread\n+                        while (true) {\n+                            try {\n+                                \/\/ calling wait() on a monitor will cause inflation into a heavy monitor\n+                                inflatedLock.wait();\n+                            } catch (InterruptedException e) { \/* ignored *\/ }\n+                        }\n+                    }\n+                }\n+            };\n+            inflatorThread.setDaemon(true);\n+            inflatorThread.start();\n+\n+            \/\/ wait until the lock is permanently inflated by the inflatorThread\n+            while(!inflatedLockIsPermanentlyInflated) {\n+                try {\n+                    inflatedLock.wait(); \/\/ until inflated\n+                } catch (InterruptedException e1) { \/* ignored *\/ }\n+            }\n+        }\n+    }\n+\n+    \/\/ Debugger will set breakpoint here to sync with target.\n+    public static void staticSetUpDone() {\n+    }\n+\n+    public void setUp() {\n+        testMethodDepth = 1;\n+        testMethodName = TESTMETHOD_DEFAULT_NAME;\n+    }\n+\n+    public abstract void dontinline_testMethod() throws Exception;\n+\n+    public int dontinline_brkpt_iret() {\n+        dontinline_brkpt();\n+        return 42;\n+    }\n+\n+    \/**\n+     * It is a common protocol to have the debugger set a breakpoint in this method and have {@link\n+     * #dontinline_testMethod()} call it and then perform some test actions on debugger side.\n+     * After that it is checked if a frame of {@link #dontinline_testMethod()} is found at the\n+     * expected depth on stack and if it is (not) marked for deoptimization as expected.\n+     *\/\n+    public void dontinline_brkpt() {\n+        \/\/ will set breakpoint here after warmup\n+        if (warmupDone) {\n+            \/\/ check if test method is at expected depth\n+            StackTraceElement[] frames = Thread.currentThread().getStackTrace();\n+            int stackTraceDepth = testMethodDepth + 1; \/\/ ignore java.lang.Thread.getStackTrace()\n+            Asserts.assertEQ(testMethodName, frames[stackTraceDepth].getMethodName(),\n+                    testCaseName + \": test method not found at depth \" + testMethodDepth);\n+            \/\/ check if the frame is (not) deoptimized as expected\n+            if (!DeoptimizeObjectsALot) {\n+                if (testFrameShouldBeDeoptimized() && testMethodReachedHighestCompLevel) {\n+                    Asserts.assertTrue(WB.isFrameDeoptimized(testMethodDepth+1),\n+                            testCaseName + \": expected test method frame at depth \" + testMethodDepth + \" to be deoptimized\");\n+                } else {\n+                    Asserts.assertFalse(WB.isFrameDeoptimized(testMethodDepth+1),\n+                            testCaseName + \": expected test method frame at depth \" + testMethodDepth + \" not to be deoptimized\");\n+                }\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Some test cases run busy endless loops by initializing {@link #loopCount}\n+     * to {@link Long#MAX_VALUE} after warm-up and then counting down to 0 in their main test method.\n+     * During warm-up {@link #loopCount} is initialized to a small value.\n+     *\/\n+    public long dontinline_endlessLoop() {\n+        long cs = checkSum;\n+        doLoop = true;\n+        while (loopCount-- > 0 && doLoop) {\n+            targetIsInLoop = true;\n+            checkSum += checkSum % ++cs;\n+        }\n+        loopCount = 3;\n+        targetIsInLoop = false;\n+        return checkSum;\n+    }\n+\n+    public boolean testFrameShouldBeDeoptimized() {\n+        return DoEscapeAnalysis;\n+    }\n+\n+    public void warmupDone() {\n+        warmupDone = true;\n+    }\n+\n+    \/\/ Debugger will set breakpoint here to sync with target.\n+    public void testCaseDone() {\n+    }\n+\n+    public void compileTestMethod() throws Exception {\n+        int callCount = CompilerWhiteBoxTest.THRESHOLD;\n+        while (callCount-- > 0) {\n+            dontinline_testMethod();\n+        }\n+    }\n+\n+    public void checkCompLevel() {\n+        java.lang.reflect.Method m = null;\n+        try {\n+            m = getClass().getMethod(TESTMETHOD_DEFAULT_NAME);\n+        } catch (NoSuchMethodException | SecurityException e) {\n+            Asserts.fail(\"could not check compilation level of\", e);\n+        }\n+        \/\/ Background compilation (-Xbatch) cannot always be disabled with JVMCI\n+        \/\/ compiler (e.g. if JVMCI is not yet fully initialized), therefore it\n+        \/\/ is possible that due to background compilation we reach here before\n+        \/\/ the test method is compiled on the highest level.\n+        int highestLevel = CompilerUtils.getMaxCompilationLevel();\n+        int compLevel = WB.getMethodCompilationLevel(m);\n+        testMethodReachedHighestCompLevel = highestLevel == compLevel;\n+        if (!UseJVMCICompiler) {\n+            Asserts.assertEQ(highestLevel, compLevel,\n+                             m + \" not on expected compilation level\");\n+        }\n+    }\n+\n+    \/\/ to be overridden as appropriate\n+    public int getExpectedIResult() {\n+        return 0;\n+    }\n+\n+    \/\/ to be overridden as appropriate\n+    public long getExpectedLResult() {\n+        return 0;\n+    }\n+\n+    \/\/ to be overridden as appropriate\n+    public float getExpectedFResult() {\n+        return 0f;\n+    }\n+\n+    \/\/ to be overridden as appropriate\n+    public double getExpectedDResult() {\n+        return 0d;\n+    }\n+\n+    private void checkResult() {\n+        Asserts.assertEQ(getExpectedIResult(), iResult, \"checking iResult\");\n+        Asserts.assertEQ(getExpectedLResult(), lResult, \"checking lResult\");\n+        Asserts.assertEQ(getExpectedFResult(), fResult, \"checking fResult\");\n+        Asserts.assertEQ(getExpectedDResult(), dResult, \"checking dResult\");\n+    }\n+\n+    public void msg(String m) {\n+        System.out.println();\n+        System.out.println(\"###(Target) \" + m);\n+        System.out.println();\n+    }\n+\n+    \/\/ The object passed will be ArgEscape if it was NoEscape before.\n+    public final void dontinline_make_arg_escape(XYVal xy) {\n+    }\n+\n+    \/**\n+     * Call a method indirectly using reflection. The indirection is a limit for escape\n+     * analysis in the sense that the VM need not search beyond for frames that might have\n+     * an object being read by an JVMTI agent as ArgEscape.\n+     * @param receiver The receiver object of the call.\n+     * @param methodName The name of the method to be called.\n+     *\/\n+    public final void dontinline_call_with_entry_frame(Object receiver, String methodName) {\n+        Asserts.assertTrue(warmupDone, \"We want to take the slow path through jni, so don't call in warmup\");\n+\n+        Class<?> cls = receiver.getClass();\n+        Class<?>[] none = {};\n+\n+        java.lang.reflect.Method m;\n+        try {\n+            m = cls.getDeclaredMethod(methodName, none);\n+            m.invoke(receiver);\n+        } catch (Exception e) {\n+            Asserts.fail(\"Call through reflection failed\", e);\n+        }\n+    }\n+\n+    \/**\n+     * Trigger bulk rebiasing for the given class by creating new instances and calling <code> hashCode() <\/code> on them.\n+     * @param cls The class to bulk rebias\n+     *\/\n+    public void dontinline_bulkRebiasAfterWarmup(Class<?> cls) {\n+        if (warmupDone) {\n+            try {\n+                for (int i=0; i < BiasedLockingBulkRebiasThreshold+2; i++) {\n+                    biasToBeRevoked = cls.getDeclaredConstructor(int.class, int.class).newInstance(1, 1);\n+                    synchronized (biasToBeRevoked) { \/\/ bias towards current thread\n+                        checkSum++;\n+                    }\n+                    biasToBeRevoked.hashCode(); \/\/ calling hashCode triggers revocation\n+                }\n+            } catch (Throwable e) {\n+                Asserts.fail(\"failed to create new instance of \" + cls.getName(), e);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Trigger bulk revoke of biases for the given class by creating new instances and calling <code> hashCode() <\/code> on them.\n+     * @param cls The class to bulk rebias\n+     *\/\n+    public void dontinline_bulkRevokeAfterWarmup(Class<?> cls) {\n+        if (warmupDone) {\n+            try {\n+                for (int i=0; i < BiasedLockingBulkRevokeThreshold+2; i++) {\n+                    biasToBeRevoked = cls.getDeclaredConstructor(int.class, int.class).newInstance(1, 1);\n+                    synchronized (biasToBeRevoked) { \/\/ bias towards current thread\n+                        checkSum++;\n+                    }\n+                    biasToBeRevoked.hashCode(); \/\/ calling hashCode triggers revocation\n+                }\n+            } catch (Throwable e) {\n+                Asserts.fail(\"failed to create new instance of \" + cls.getName(), e);\n+            }\n+        }\n+    }\n+\n+    static class LinkedList {\n+        LinkedList l;\n+        public long[] array;\n+        public LinkedList(LinkedList l, int size) {\n+            this.array = new long[size];\n+            this.l = l;\n+        }\n+    }\n+\n+    public LinkedList consumedMemory;\n+\n+    public void consumeAllMemory() {\n+        msg(\"consume all memory\");\n+        int size = 128 * 1024 * 1024;\n+        while(size > 0) {\n+            try {\n+                while(true) {\n+                    consumedMemory = new LinkedList(consumedMemory, size);\n+                }\n+            } catch(OutOfMemoryError oom) {\n+            }\n+            size = size \/ 2;\n+        }\n+    }\n+}\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\/\/\n+\/\/ Test Cases\n+\/\/\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+\/\/ make sure a compiled frame is not deoptimized if an escaping local is accessed\n+class EAGetWithoutMaterializeTarget extends EATestCaseBaseTarget {\n+\n+    public XYVal getAway;\n+\n+    public void dontinline_testMethod() {\n+        XYVal xy = new XYVal(4, 2);\n+        getAway = xy;  \/\/ allocated object escapes\n+        dontinline_brkpt();\n+        iResult = xy.x + xy.y;\n+    }\n+\n+    @Override\n+    public int getExpectedIResult() {\n+        return 4 + 2;\n+    }\n+\n+    @Override\n+    public boolean testFrameShouldBeDeoptimized() {\n+        return false;\n+    }\n+}\n+\n+class EAGetWithoutMaterialize extends EATestCaseBaseDebugger {\n+\n+    public void runTestCase() throws Exception {\n+        BreakpointEvent bpe = env.resumeTo(TARGET_TESTCASE_BASE_NAME, \"dontinline_brkpt\", \"()V\");\n+        printStack(bpe.thread());\n+        ObjectReference o = getLocalRef(bpe.thread().frame(1), XYVAL_NAME, \"xy\");\n+        checkPrimitiveField(o, FD.I, \"x\", 4);\n+        checkPrimitiveField(o, FD.I, \"y\", 2);\n+    }\n+}\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+\/\/\n+\/\/ Tests the following:\n+\/\/\n+\/\/ 1. Debugger can obtain a reference to a scalar replaced object R from java thread J.\n+\/\/    See runTestCase.\n+\/\/\n+\/\/ 2. Subsequent modifications of R by J are noticed by the debugger.\n+\/\/    See checkPostConditions.\n+\/\/\n+class EAMaterializeLocalVariableUponGet extends EATestCaseBaseDebugger {\n+\n+    private ObjectReference o;\n+\n+    public void runTestCase() throws Exception {\n+        BreakpointEvent bpe = env.resumeTo(TARGET_TESTCASE_BASE_NAME, \"dontinline_brkpt\", \"()V\");\n+        printStack(bpe.thread());\n+        \/\/ check 1.\n+        o = getLocalRef(bpe.thread().frame(1), XYVAL_NAME, \"xy\");\n+        checkPrimitiveField(o, FD.I, \"x\", 4);\n+        checkPrimitiveField(o, FD.I, \"y\", 2);\n+    }\n+\n+    @Override\n+    public void checkPostConditions() throws Exception {\n+        super.checkPostConditions();\n+        \/\/ check 2.\n+        checkPrimitiveField(o, FD.I, \"x\", 5);\n+    }\n+}\n+\n+class EAMaterializeLocalVariableUponGetTarget extends EATestCaseBaseTarget {\n+\n+    public void dontinline_testMethod() {\n+        XYVal xy = new XYVal(4, 2);\n+        dontinline_brkpt();       \/\/ Debugger obtains scalar replaced object at this point.\n+        xy.x += 1;                \/\/ Change scalar replaced object after debugger obtained a reference to it.\n+        iResult = xy.x + xy.y;\n+    }\n+\n+    @Override\n+    public int getExpectedIResult() {\n+        return 4 + 2 + 1;\n+    }\n+}\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+\/\/ Test if an eliminated object can be reallocated in a frame with an active\n+\/\/ call that will return another object\n+class EAMaterializeLocalAtObjectReturn extends EATestCaseBaseDebugger {\n+    public void runTestCase() throws Exception {\n+        BreakpointEvent bpe = env.resumeTo(TARGET_TESTCASE_BASE_NAME, \"dontinline_brkpt\", \"()V\");\n+        printStack(bpe.thread());\n+        ObjectReference o = getLocalRef(bpe.thread().frame(2), XYVAL_NAME, \"xy\");\n+        checkPrimitiveField(o, FD.I, \"x\", 4);\n+        checkPrimitiveField(o, FD.I, \"y\", 2);\n+    }\n+}\n+\n+class EAMaterializeLocalAtObjectReturnTarget extends EATestCaseBaseTarget {\n+    @Override\n+    public void setUp() {\n+        super.setUp();\n+        testMethodDepth = 2;\n+    }\n+\n+    public void dontinline_testMethod() {\n+        XYVal xy = new XYVal(4, 2);\n+        Integer io =                 \/\/ Read xy here triggers reallocation\n+                dontinline_brkpt_return_Integer();\n+        iResult = xy.x + xy.y + io;\n+    }\n+\n+    public Integer dontinline_brkpt_return_Integer() {\n+        \/\/ We can't break directly in this method, as this results in making\n+        \/\/ the test method not entrant caused by an existing dependency\n+        dontinline_brkpt();\n+        return Integer.valueOf(23);\n+    }\n+\n+    @Override\n+    public int getExpectedIResult() {\n+        return 4 + 2 + 23;\n+    }\n+}\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+\/\/ Test if an eliminated object can be reallocated *just* before a call returns an object.\n+\/\/ (See CompiledMethod::is_at_poll_return())\n+\/\/ Details: the callee method has just one safepoint poll at the return. The other safepoint\n+\/\/ is at the end of an iteration of the endless loop. We can detect if we suspended the target\n+\/\/ there because the local xy is out of scope there.\n+class EAMaterializeLocalAtObjectPollReturnReturn extends EATestCaseBaseDebugger {\n+    public void runTestCase() throws Exception {\n+        msg(\"Resume \" + env.targetMainThread);\n+        env.targetMainThread.resume();\n+        waitUntilTargetHasEnteredEndlessLoop();\n+        ObjectReference o = null;\n+        do {\n+            env.targetMainThread.suspend();\n+            printStack(env.targetMainThread);\n+            try {\n+                o = getLocalRef(env.targetMainThread.frame(0), XYVAL_NAME, \"xy\");\n+            } catch (Exception e) {\n+                msg(\"The local variable xy is out of scope because we suspended at the wrong bci. Resume and try again!\");\n+                env.targetMainThread.resume();\n+            }\n+        } while (o == null);\n+        checkPrimitiveField(o, FD.I, \"x\", 4);\n+        checkPrimitiveField(o, FD.I, \"y\", 2);\n+        terminateEndlessLoop();\n+    }\n+}\n+\n+class EAMaterializeLocalAtObjectPollReturnReturnTarget extends EATestCaseBaseTarget {\n+    @Override\n+    public void setUp() {\n+        super.setUp();\n+        loopCount = 3;\n+        doLoop = true;\n+    }\n+\n+    public void warmupDone() {\n+        super.warmupDone();\n+        msg(\"enter 'endless' loop by setting loopCount = Long.MAX_VALUE\");\n+        loopCount = Long.MAX_VALUE; \/\/ endless loop\n+    }\n+\n+    public void dontinline_testMethod() {\n+        long result = 0;\n+        while (doLoop && loopCount-- > 0) {\n+            targetIsInLoop = true;\n+            XYVal xy = new XYVal(4, 2);\n+            Integer io =           \/\/ Read xy here triggers reallocation just before the call returns\n+                    dontinline_brkpt_return_Integer();\n+            result += xy.x + xy.y + io;\n+        }  \/\/ Here is a second safepoint. We were suspended here if xy is not in scope.\n+        targetIsInLoop = false;\n+        lResult = result;\n+    }\n+\n+    public Integer dontinline_brkpt_return_Integer() {\n+        return Integer.valueOf(23);\n+    }\n+\n+    @Override\n+    public long getExpectedLResult() {\n+        return (Long.MAX_VALUE - loopCount) * (4+2+23);\n+    }\n+}\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\/\/ Test case collection that tests rematerialization of different\n+\/\/ array types where the first element is always not constant and the\n+\/\/ other elements are constants. Not constant values are stored in\n+\/\/ the stack frame for rematerialization whereas constants are kept\n+\/\/ in the debug info of the nmethod.\n+\n+class EAMaterializeIntArrayTarget extends EATestCaseBaseTarget {\n+\n+    public void dontinline_testMethod() {\n+        int nums[] = {NOT_CONST_1I , 2, 3};\n+        dontinline_brkpt();\n+        iResult = nums[0] + nums[1] + nums[2];\n+    }\n+\n+    @Override\n+    public int getExpectedIResult() {\n+        return NOT_CONST_1I + 2 + 3;\n+    }\n+}\n+\n+class EAMaterializeIntArray extends EATestCaseBaseDebugger {\n+    public void runTestCase() throws Exception {\n+        BreakpointEvent bpe = env.resumeTo(TARGET_TESTCASE_BASE_NAME, \"dontinline_brkpt\", \"()V\");\n+        printStack(bpe.thread());\n+        int[] expectedVals = {1, 2, 3};\n+        checkLocalPrimitiveArray(bpe.thread().frame(1), \"nums\", FD.I, expectedVals);\n+    }\n+}\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+class EAMaterializeLongArrayTarget extends EATestCaseBaseTarget {\n+\n+    public void dontinline_testMethod() {\n+        long nums[] = {NOT_CONST_1L , 2, 3};\n+        dontinline_brkpt();\n+        lResult = nums[0] + nums[1] + nums[2];\n+    }\n+\n+    @Override\n+    public long getExpectedLResult() {\n+        return NOT_CONST_1L + 2 + 3;\n+    }\n+}\n+\n+class EAMaterializeLongArray extends EATestCaseBaseDebugger {\n+    public void runTestCase() throws Exception {\n+        BreakpointEvent bpe = env.resumeTo(TARGET_TESTCASE_BASE_NAME, \"dontinline_brkpt\", \"()V\");\n+        printStack(bpe.thread());\n+        long[] expectedVals = {1, 2, 3};\n+        checkLocalPrimitiveArray(bpe.thread().frame(1), \"nums\", FD.J, expectedVals);\n+    }\n+}\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+class EAMaterializeFloatArrayTarget extends EATestCaseBaseTarget {\n+\n+    public void dontinline_testMethod() {\n+        float nums[] = {NOT_CONST_1F , 2.2f, 3.3f};\n+        dontinline_brkpt();\n+        fResult = nums[0] + nums[1] + nums[2];\n+    }\n+\n+    @Override\n+    public float getExpectedFResult() {\n+        return NOT_CONST_1F + 2.2f + 3.3f;\n+    }\n+}\n+\n+class EAMaterializeFloatArray extends EATestCaseBaseDebugger {\n+    public void runTestCase() throws Exception {\n+        BreakpointEvent bpe = env.resumeTo(TARGET_TESTCASE_BASE_NAME, \"dontinline_brkpt\", \"()V\");\n+        printStack(bpe.thread());\n+        float[] expectedVals = {1.1f, 2.2f, 3.3f};\n+        checkLocalPrimitiveArray(bpe.thread().frame(1), \"nums\", FD.F, expectedVals);\n+    }\n+}\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+class EAMaterializeDoubleArrayTarget extends EATestCaseBaseTarget {\n+\n+    public void dontinline_testMethod() {\n+        double nums[] = {NOT_CONST_1D , 2.2d, 3.3d};\n+        dontinline_brkpt();\n+        dResult = nums[0] + nums[1] + nums[2];\n+    }\n+\n+    @Override\n+    public double getExpectedDResult() {\n+        return NOT_CONST_1D + 2.2d + 3.3d;\n+    }\n+}\n+\n+class EAMaterializeDoubleArray extends EATestCaseBaseDebugger {\n+    public void runTestCase() throws Exception {\n+        BreakpointEvent bpe = env.resumeTo(TARGET_TESTCASE_BASE_NAME, \"dontinline_brkpt\", \"()V\");\n+        printStack(bpe.thread());\n+        double[] expectedVals = {1.1d, 2.2d, 3.3d};\n+        checkLocalPrimitiveArray(bpe.thread().frame(1), \"nums\", FD.D, expectedVals);\n+    }\n+}\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+class EAMaterializeObjectArrayTarget extends EATestCaseBaseTarget {\n+\n+    public void dontinline_testMethod() {\n+        Long nums[] = {NOT_CONST_1_OBJ , CONST_2_OBJ, CONST_3_OBJ};\n+        dontinline_brkpt();\n+        lResult = nums[0] + nums[1] + nums[2];\n+    }\n+\n+    @Override\n+    public long getExpectedLResult() {\n+        return 1 + 2 + 3;\n+    }\n+}\n+\n+class EAMaterializeObjectArray extends EATestCaseBaseDebugger {\n+    public void runTestCase() throws Exception {\n+        BreakpointEvent bpe = env.resumeTo(TARGET_TESTCASE_BASE_NAME, \"dontinline_brkpt\", \"()V\");\n+        printStack(bpe.thread());\n+        ReferenceType clazz = bpe.thread().frame(0).location().declaringType();\n+        ObjectReference[] expectedVals = {\n+                (ObjectReference) clazz.getValue(clazz.fieldByName(\"NOT_CONST_1_OBJ\")),\n+                (ObjectReference) clazz.getValue(clazz.fieldByName(\"CONST_2_OBJ\")),\n+                (ObjectReference) clazz.getValue(clazz.fieldByName(\"CONST_3_OBJ\"))\n+        };\n+        checkLocalObjectArray(bpe.thread().frame(1), \"nums\", \"java.lang.Long[]\", expectedVals);\n+    }\n+}\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+\/\/ Materialize an object whose fields have constant and not constant values at\n+\/\/ the point where the object is materialized.\n+class EAMaterializeObjectWithConstantAndNotConstantValuesTarget extends EATestCaseBaseTarget {\n+\n+    public void dontinline_testMethod() {\n+        ILFDO o = new ILFDO(NOT_CONST_1I, 2,\n+                            NOT_CONST_1L, 2L,\n+                            NOT_CONST_1F, 2.1F,\n+                            NOT_CONST_1D, 2.1D,\n+                            NOT_CONST_1_OBJ, CONST_2_OBJ\n+                            );\n+        dontinline_brkpt();\n+        dResult =\n+            o.i + o.i2 + o.l + o.l2 + o.f + o.f2 + o.d + o.d2 + o.o + o.o2;\n+    }\n+\n+    @Override\n+    public double getExpectedDResult() {\n+        return NOT_CONST_1I + 2 + NOT_CONST_1L + 2L + NOT_CONST_1F + 2.1F + NOT_CONST_1D + 2.1D + NOT_CONST_1_OBJ + CONST_2_OBJ;\n+    }\n+}\n+\n+class EAMaterializeObjectWithConstantAndNotConstantValues extends EATestCaseBaseDebugger {\n+    public void runTestCase() throws Exception {\n+        BreakpointEvent bpe = env.resumeTo(TARGET_TESTCASE_BASE_NAME, \"dontinline_brkpt\", \"()V\");\n+        printStack(bpe.thread());\n+        ObjectReference o = getLocalRef(bpe.thread().frame(1), \"ILFDO\", \"o\");\n+        checkPrimitiveField(o, FD.I, \"i\", 1);\n+        checkPrimitiveField(o, FD.I, \"i2\", 2);\n+        checkPrimitiveField(o, FD.J, \"l\", 1L);\n+        checkPrimitiveField(o, FD.J, \"l2\", 2L);\n+        checkPrimitiveField(o, FD.F, \"f\", 1.1f);\n+        checkPrimitiveField(o, FD.F, \"f2\", 2.1f);\n+        checkPrimitiveField(o, FD.D, \"d\", 1.1d);\n+        checkPrimitiveField(o, FD.D, \"d2\", 2.1d);\n+        ReferenceType clazz = bpe.thread().frame(1).location().declaringType();\n+        ObjectReference[] expVals = {\n+                (ObjectReference) clazz.getValue(clazz.fieldByName(\"NOT_CONST_1_OBJ\")),\n+                (ObjectReference) clazz.getValue(clazz.fieldByName(\"CONST_2_OBJ\")),\n+        };\n+        checkObjField(o, \"o\", expVals[0]);\n+        checkObjField(o, \"o2\", expVals[1]);\n+    }\n+}\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+\/\/ Two local variables reference the same object.\n+\/\/ Check if the debugger obtains the same object when reading the two variables\n+class EAMaterializeObjReferencedBy2LocalsTarget extends EATestCaseBaseTarget {\n+\n+    public void dontinline_testMethod() {\n+        XYVal xy = new XYVal(2, 3);\n+        XYVal alias = xy;\n+        dontinline_brkpt();\n+        iResult = xy.x + alias.x;\n+    }\n+\n+    @Override\n+    public int getExpectedIResult() {\n+        return 2 + 2;\n+    }\n+}\n+\n+class EAMaterializeObjReferencedBy2Locals extends EATestCaseBaseDebugger {\n+\n+    public void runTestCase() throws Exception {\n+        BreakpointEvent bpe = env.resumeTo(TARGET_TESTCASE_BASE_NAME, \"dontinline_brkpt\", \"()V\");\n+        printStack(bpe.thread());\n+        ObjectReference xy = getLocalRef(bpe.thread().frame(1), XYVAL_NAME, \"xy\");\n+        ObjectReference alias = getLocalRef(bpe.thread().frame(1), XYVAL_NAME, \"alias\");\n+        Asserts.assertSame(xy, alias, \"xy and alias are expected to reference the same object\");\n+    }\n+\n+}\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+\/\/ Two local variables reference the same object.\n+\/\/ Check if it has the expected effect in the target if the debugger modifies the object.\n+class EAMaterializeObjReferencedBy2LocalsAndModifyTarget extends EATestCaseBaseTarget {\n+\n+    public void dontinline_testMethod() {\n+        XYVal xy = new XYVal(2, 3);\n+        XYVal alias = xy;\n+        dontinline_brkpt(); \/\/ debugger: alias.x = 42\n+        iResult = xy.x + alias.x;\n+    }\n+\n+    @Override\n+    public int getExpectedIResult() {\n+        return 42 + 42;\n+    }\n+}\n+\n+class EAMaterializeObjReferencedBy2LocalsAndModify extends EATestCaseBaseDebugger {\n+\n+    public void runTestCase() throws Exception {\n+        BreakpointEvent bpe = env.resumeTo(TARGET_TESTCASE_BASE_NAME, \"dontinline_brkpt\", \"()V\");\n+        printStack(bpe.thread());\n+        ObjectReference alias = getLocalRef(bpe.thread().frame(1), XYVAL_NAME, \"alias\");\n+        setField(alias, \"x\", env.vm().mirrorOf(42));\n+    }\n+}\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+\/\/ Two local variables of the same compiled frame but in different virtual frames reference the same\n+\/\/ object.\n+\/\/ Check if the debugger obtains the same object when reading the two variables\n+class EAMaterializeObjReferencedBy2LocalsInDifferentVirtFramesTarget extends EATestCaseBaseTarget {\n+\n+    @Override\n+    public void setUp() {\n+        super.setUp();\n+        testMethodDepth = 2;\n+    }\n+\n+    public void dontinline_testMethod() {\n+        XYVal xy = new XYVal(2, 3);\n+        testMethod_inlined(xy);\n+        iResult += xy.x;\n+    }\n+\n+    public void testMethod_inlined(XYVal xy) {\n+        XYVal alias = xy;\n+        dontinline_brkpt();\n+        iResult = alias.x;\n+    }\n+\n+    @Override\n+    public int getExpectedIResult() {\n+        return 2 + 2;\n+    }\n+}\n+\n+class EAMaterializeObjReferencedBy2LocalsInDifferentVirtFrames extends EATestCaseBaseDebugger {\n+\n+    public void runTestCase() throws Exception {\n+        BreakpointEvent bpe = env.resumeTo(TARGET_TESTCASE_BASE_NAME, \"dontinline_brkpt\", \"()V\");\n+        printStack(bpe.thread());\n+        ObjectReference xy = getLocalRef(bpe.thread().frame(2), XYVAL_NAME, \"xy\");\n+        ObjectReference alias = getLocalRef(bpe.thread().frame(1), \"testMethod_inlined\", \"alias\", XYVAL_NAME);\n+        Asserts.assertSame(xy, alias, \"xy and alias are expected to reference the same object\");\n+    }\n+\n+}\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+\/\/ Two local variables of the same compiled frame but in different virtual frames reference the same\n+\/\/ object.\n+\/\/ Check if it has the expected effect in the target if the debugger modifies the object.\n+class EAMaterializeObjReferencedBy2LocalsInDifferentVirtFramesAndModifyTarget extends EATestCaseBaseTarget {\n+\n+    @Override\n+    public void setUp() {\n+        super.setUp();\n+        testMethodDepth = 2;\n+    }\n+\n+    public void dontinline_testMethod() {\n+        XYVal xy = new XYVal(2, 3);\n+        testMethod_inlined(xy);   \/\/ debugger: xy.x = 42\n+        iResult += xy.x;\n+    }\n+\n+    public void testMethod_inlined(XYVal xy) {\n+        XYVal alias = xy;\n+        dontinline_brkpt();\n+        iResult = alias.x;\n+    }\n+\n+    @Override\n+    public int getExpectedIResult() {\n+        return 42 + 42;\n+    }\n+}\n+\n+class EAMaterializeObjReferencedBy2LocalsInDifferentVirtFramesAndModify extends EATestCaseBaseDebugger {\n+\n+    public void runTestCase() throws Exception {\n+        BreakpointEvent bpe = env.resumeTo(TARGET_TESTCASE_BASE_NAME, \"dontinline_brkpt\", \"()V\");\n+        printStack(bpe.thread());\n+        ObjectReference alias = getLocalRef(bpe.thread().frame(1), \"testMethod_inlined\", \"alias\", XYVAL_NAME);\n+        setField(alias, \"x\", env.vm().mirrorOf(42));\n+    }\n+\n+}\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+\/\/ Test materialization of an object referenced only from expression stack\n+class EAMaterializeObjReferencedFromOperandStackTarget extends EATestCaseBaseTarget {\n+\n+    @Override\n+    public void setUp() {\n+        super.setUp();\n+        testMethodDepth = 2;\n+    }\n+\n+    public void dontinline_testMethod() {\n+        @SuppressWarnings(\"unused\")\n+        XYVal xy1 = new XYVal(2, 3);\n+        \/\/ Debugger breaks in call to dontinline_brkpt_ret_100() and reads\n+        \/\/ the value of the local 'xy1'. This triggers materialization\n+        \/\/ of the object on the operand stack\n+        iResult = testMethodInlined(new XYVal(4, 2), dontinline_brkpt_ret_100());\n+    }\n+\n+    public int testMethodInlined(XYVal xy2, int dontinline_brkpt_ret_100) {\n+        return xy2.x + dontinline_brkpt_ret_100;\n+    }\n+\n+    public int dontinline_brkpt_ret_100() {\n+        dontinline_brkpt();\n+        return 100;\n+    }\n+\n+    @Override\n+    public int getExpectedIResult() {\n+        return 4 + 100;\n+    }\n+}\n+\n+class EAMaterializeObjReferencedFromOperandStack extends EATestCaseBaseDebugger {\n+\n+    public void runTestCase() throws Exception {\n+        BreakpointEvent bpe = env.resumeTo(TARGET_TESTCASE_BASE_NAME, \"dontinline_brkpt\", \"()V\");\n+        printStack(bpe.thread());\n+        ObjectReference xy1 = getLocalRef(bpe.thread().frame(2), XYVAL_NAME, \"xy1\");\n+        checkPrimitiveField(xy1, FD.I, \"x\", 2);\n+        checkPrimitiveField(xy1, FD.I, \"y\", 3);\n+    }\n+\n+}\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+\/**\n+ * Tests a regression in the implementation by setting the value of a local int which triggers the\n+ * creation of a deferred update and then getting the reference to a scalar replaced object.  The\n+ * issue was that the scalar replaced object was not reallocated. Because of the deferred update it\n+ * was assumed that the reallocation already happened.\n+ *\/\n+class EAMaterializeLocalVariableUponGetAfterSetInteger extends EATestCaseBaseDebugger {\n+\n+    public void runTestCase() throws Exception {\n+        BreakpointEvent bpe = env.resumeTo(TARGET_TESTCASE_BASE_NAME, \"dontinline_brkpt\", \"()V\");\n+        printStack(bpe.thread());\n+        setLocal(bpe.thread().frame(1), \"i\", env.vm().mirrorOf(43));\n+        ObjectReference o = getLocalRef(bpe.thread().frame(1), XYVAL_NAME, \"xy\");\n+        checkPrimitiveField(o, FD.I, \"x\", 4);\n+        checkPrimitiveField(o, FD.I, \"y\", 2);\n+    }\n+}\n+\n+class EAMaterializeLocalVariableUponGetAfterSetIntegerTarget extends EATestCaseBaseTarget {\n+\n+    public void dontinline_testMethod() {\n+        XYVal xy = new XYVal(4, 2);\n+        int i = 42;\n+        dontinline_brkpt();\n+        iResult = xy.x + xy.y + i;\n+    }\n+\n+    @Override\n+    public int getExpectedIResult() {\n+        return 4 + 2 + 43;\n+    }\n+\n+    @Override\n+    public boolean testFrameShouldBeDeoptimized() {\n+        return true; \/\/ setting local variable i always triggers deoptimization\n+    }\n+}\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\/\/\n+\/\/ Locking Tests\n+\/\/\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+class EARelockingSimple extends EATestCaseBaseDebugger {\n+\n+    public void runTestCase() throws Exception {\n+        BreakpointEvent bpe = env.resumeTo(TARGET_TESTCASE_BASE_NAME, \"dontinline_brkpt\", \"()V\");\n+        printStack(bpe.thread());\n+        @SuppressWarnings(\"unused\")\n+        ObjectReference o = getLocalRef(bpe.thread().frame(1), XYVAL_NAME, \"l1\");\n+    }\n+}\n+\n+class EARelockingSimpleTarget extends EATestCaseBaseTarget {\n+\n+    public void dontinline_testMethod() {\n+        XYVal l1 = new XYVal(4, 2);\n+        synchronized (l1) {\n+            dontinline_brkpt();\n+        }\n+    }\n+}\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+\/**\n+ * Test if the bias of an object O that escapes globally is revoked correctly if local objects\n+ * escape through JVMTI. O is referenced by field l0.\n+ * This tests a regression of a previous version of the implementation.\n+ *\/\n+class EARelockingSimple_2 extends EATestCaseBaseDebugger {\n+\n+    public void runTestCase() throws Exception {\n+        BreakpointEvent bpe = env.resumeTo(TARGET_TESTCASE_BASE_NAME, \"dontinline_brkpt\", \"()V\");\n+        printStack(bpe.thread());\n+        @SuppressWarnings(\"unused\")\n+        ObjectReference o = getLocalRef(bpe.thread().frame(1), XYVAL_NAME, \"l1\");\n+    }\n+}\n+\n+class EARelockingSimple_2Target extends EATestCaseBaseTarget {\n+\n+    public XYVal l0;\n+\n+    public void dontinline_testMethod() {\n+        l0 = new XYVal(4, 2);         \/\/ GobalEscape\n+        XYVal l1 = new XYVal(4, 2);\n+        synchronized (l0) {\n+            synchronized (l1) {\n+                dontinline_brkpt();\n+            }\n+        }\n+    }\n+}\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+\/\/ Test recursive locking\n+class EARelockingRecursiveTarget extends EATestCaseBaseTarget {\n+\n+    @Override\n+    public void setUp() {\n+        super.setUp();\n+        testMethodDepth = 2;\n+    }\n+\n+    public void dontinline_testMethod() {\n+        XYVal l1 = new XYVal(4, 2);\n+        synchronized (l1) {\n+            testMethod_inlined(l1);\n+        }\n+    }\n+\n+    public void testMethod_inlined(XYVal l2) {\n+        synchronized (l2) {\n+            dontinline_brkpt();\n+        }\n+    }\n+}\n+\n+class EARelockingRecursive extends EATestCaseBaseDebugger {\n+\n+    public void runTestCase() throws Exception {\n+        BreakpointEvent bpe = env.resumeTo(TARGET_TESTCASE_BASE_NAME, \"dontinline_brkpt\", \"()V\");\n+        printStack(bpe.thread());\n+        @SuppressWarnings(\"unused\")\n+        ObjectReference o = getLocalRef(bpe.thread().frame(2), XYVAL_NAME, \"l1\");\n+    }\n+}\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+\/\/ Object ref l1 is retrieved by the debugger at a location where nested locks are omitted. The\n+\/\/ accessed object is globally reachable already before the access, therefore no relocking is done.\n+class EARelockingNestedInflatedTarget extends EATestCaseBaseTarget {\n+\n+    @Override\n+    public void setUp() {\n+        super.setUp();\n+        testMethodDepth = 2;\n+    }\n+\n+    @Override\n+    public boolean testFrameShouldBeDeoptimized() {\n+        \/\/ Access does not trigger deopt., as escape state is already global escape.\n+        return false;\n+    }\n+\n+    public void dontinline_testMethod() {\n+        XYVal l1 = inflatedLock;\n+        synchronized (l1) {\n+            testMethod_inlined(l1);\n+        }\n+    }\n+\n+    public void testMethod_inlined(XYVal l2) {\n+        synchronized (l2) {                 \/\/ eliminated nested locking\n+            dontinline_brkpt();\n+        }\n+    }\n+}\n+\n+class EARelockingNestedInflated extends EATestCaseBaseDebugger {\n+\n+    public void runTestCase() throws Exception {\n+        BreakpointEvent bpe = env.resumeTo(TARGET_TESTCASE_BASE_NAME, \"dontinline_brkpt\", \"()V\");\n+        printStack(bpe.thread());\n+        @SuppressWarnings(\"unused\")\n+        ObjectReference o = getLocalRef(bpe.thread().frame(2), XYVAL_NAME, \"l1\");\n+    }\n+}\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+\/**\n+ * Like {@link EARelockingNestedInflated} with the difference that there is\n+ * a scalar replaced object in the scope from which the object with eliminated nested locking\n+ * is read. This triggers materialization and relocking.\n+ *\/\n+class EARelockingNestedInflated_02 extends EATestCaseBaseDebugger {\n+\n+    public void runTestCase() throws Exception {\n+        BreakpointEvent bpe = env.resumeTo(TARGET_TESTCASE_BASE_NAME, \"dontinline_brkpt\", \"()V\");\n+        printStack(bpe.thread());\n+        @SuppressWarnings(\"unused\")\n+        ObjectReference o = getLocalRef(bpe.thread().frame(2), XYVAL_NAME, \"l1\");\n+    }\n+}\n+\n+class EARelockingNestedInflated_02Target extends EATestCaseBaseTarget {\n+\n+    @Override\n+    public void setUp() {\n+        super.setUp();\n+        testMethodDepth = 2;\n+    }\n+\n+    public void dontinline_testMethod() {\n+        @SuppressWarnings(\"unused\")\n+        XYVal xy = new XYVal(1, 1);     \/\/ scalar replaced\n+        XYVal l1 = inflatedLock;          \/\/ read by debugger\n+        synchronized (l1) {\n+            testMethod_inlined(l1);\n+        }\n+    }\n+\n+    public void testMethod_inlined(XYVal l2) {\n+        synchronized (l2) {                 \/\/ eliminated nested locking\n+            dontinline_brkpt();\n+        }\n+    }\n+}\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+\/**\n+ * Checks if an eliminated lock of an ArgEscape object l1 can be relocked if\n+ * l1 is locked in a callee frame.\n+ *\/\n+class EARelockingArgEscapeLWLockedInCalleeFrame extends EATestCaseBaseDebugger {\n+\n+    public void runTestCase() throws Exception {\n+        BreakpointEvent bpe = env.resumeTo(TARGET_TESTCASE_BASE_NAME, \"dontinline_brkpt\", \"()V\");\n+        printStack(bpe.thread());\n+        @SuppressWarnings(\"unused\")\n+        ObjectReference o = getLocalRef(bpe.thread().frame(2), XYVAL_NAME, \"l1\");\n+    }\n+}\n+\n+class EARelockingArgEscapeLWLockedInCalleeFrameTarget extends EATestCaseBaseTarget {\n+\n+    @Override\n+    public void setUp() {\n+        super.setUp();\n+        testMethodDepth = 2;\n+    }\n+\n+    public void dontinline_testMethod() {\n+        XYVal l1 = new XYVal(1, 1);       \/\/ ArgEscape\n+        synchronized (l1) {                   \/\/ eliminated\n+            l1.dontinline_sync_method(this);  \/\/ l1 escapes\n+        }\n+    }\n+\n+    @Override\n+    public boolean testFrameShouldBeDeoptimized() {\n+        \/\/ Graal does not provide debug info about arg escape objects, therefore the frame is not deoptimized\n+        return !UseJVMCICompiler && super.testFrameShouldBeDeoptimized();\n+    }\n+}\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+\/**\n+ * Similar to {@link EARelockingArgEscapeLWLockedInCalleeFrame}. In addition\n+ * the test method has got a scalar replaced object with eliminated locking.\n+ * This pattern matches a regression in the implementation.\n+ *\/\n+class EARelockingArgEscapeLWLockedInCalleeFrame_2 extends EATestCaseBaseDebugger {\n+\n+    public void runTestCase() throws Exception {\n+        BreakpointEvent bpe = env.resumeTo(TARGET_TESTCASE_BASE_NAME, \"dontinline_brkpt\", \"()V\");\n+        printStack(bpe.thread());\n+        @SuppressWarnings(\"unused\")\n+        ObjectReference o = getLocalRef(bpe.thread().frame(2), XYVAL_NAME, \"l1\");\n+    }\n+}\n+\n+class EARelockingArgEscapeLWLockedInCalleeFrame_2Target extends EATestCaseBaseTarget {\n+\n+    @Override\n+    public void setUp() {\n+        super.setUp();\n+        testMethodDepth = 2;\n+    }\n+\n+    public void dontinline_testMethod() {\n+        XYVal l1 = new XYVal(1, 1);       \/\/ ArgEscape\n+        XYVal l2 = new XYVal(4, 2);       \/\/ NoEscape, scalar replaced\n+        synchronized (l1) {                   \/\/ eliminated\n+            synchronized (l2) {               \/\/ eliminated\n+                l1.dontinline_sync_method(this);  \/\/ l1 escapes\n+            }\n+        }\n+        iResult = l2.x + l2.y;\n+    }\n+\n+    @Override\n+    public int getExpectedIResult() {\n+        return 6;\n+    }\n+}\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+\/**\n+ * Similar to {@link EARelockingArgEscapeLWLockedInCalleeFrame}.\n+ * A bulk rebias operation is triggered at a position where all locks on the local object referenced\n+ * by l1 are eliminated. This leaves the object with an outdated biased locking epoch which has to be\n+ * considered when relocking.\n+ * This tests a regression in a previous version.\n+ *\/\n+class EARelockingArgEscapeLWLockedInCalleeFrame_3 extends EATestCaseBaseDebugger {\n+\n+    public static final String XYVAL_LOCAL_NAME = EARelockingArgEscapeLWLockedInCalleeFrame_3Target.XYValLocal.class.getName();\n+\n+    public void runTestCase() throws Exception {\n+        BreakpointEvent bpe = env.resumeTo(TARGET_TESTCASE_BASE_NAME, \"dontinline_brkpt\", \"()V\");\n+        printStack(bpe.thread());\n+        @SuppressWarnings(\"unused\")\n+        ObjectReference o = getLocalRef(bpe.thread().frame(1), XYVAL_LOCAL_NAME, \"l1\");\n+    }\n+}\n+\n+class EARelockingArgEscapeLWLockedInCalleeFrame_3Target extends EATestCaseBaseTarget {\n+\n+    \/\/ Using local type to avoid side effects on biased locking heuristics\n+    public static class XYValLocal extends XYVal {\n+        public XYValLocal(int x, int y) {\n+            super(x,y);\n+        }\n+    }\n+\n+    public void dontinline_testMethod() {\n+        XYVal l1 = new XYValLocal(1, 1);       \/\/ ArgEscape\n+        synchronized (l1) {                    \/\/ eliminated\n+            l1.dontinline_sync_method_no_brkpt(this);  \/\/ l1 escapes\n+            \/\/ trigger bulk rebias\n+            dontinline_bulkRebiasAfterWarmup(l1.getClass());\n+            \/\/ Now the epoch of l1 does not match the epoch of its class.\n+            \/\/ This has to be considered when relocking because of JVMTI access\n+            dontinline_brkpt();\n+        }\n+    }\n+\n+    @Override\n+    public boolean testFrameShouldBeDeoptimized() {\n+        \/\/ Graal does not provide debug info about arg escape objects, therefore the frame is not deoptimized\n+        return !UseJVMCICompiler && super.testFrameShouldBeDeoptimized();\n+    }\n+}\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+\/**\n+ * Similar to {@link EARelockingArgEscapeLWLockedInCalleeFrame_3}.\n+ * But instead of a bulk rebias a bulk revoke operation is triggered.\n+ * This leaves the object with a stale bias as the prototype header of its calls lost its bias\n+ * pattern in the bulk revoke which has to be considered during relocking.\n+ * This tests a regression in a previous version.\n+ *\/\n+class EARelockingArgEscapeLWLockedInCalleeFrame_4 extends EATestCaseBaseDebugger {\n+\n+    public static final String XYVAL_LOCAL_NAME = EARelockingArgEscapeLWLockedInCalleeFrame_4Target.XYValLocal.class.getName();\n+\n+    public void runTestCase() throws Exception {\n+        BreakpointEvent bpe = env.resumeTo(TARGET_TESTCASE_BASE_NAME, \"dontinline_brkpt\", \"()V\");\n+        printStack(bpe.thread());\n+        @SuppressWarnings(\"unused\")\n+        ObjectReference o = getLocalRef(bpe.thread().frame(1), XYVAL_LOCAL_NAME, \"l1\");\n+    }\n+}\n+\n+class EARelockingArgEscapeLWLockedInCalleeFrame_4Target extends EATestCaseBaseTarget {\n+\n+    \/\/ Using local type to avoid side effects on biased locking heuristics\n+    public static class XYValLocal extends XYVal {\n+        public XYValLocal(int x, int y) {\n+            super(x,y);\n+        }\n+    }\n+\n+    public void dontinline_testMethod() {\n+        XYVal l1 = new XYValLocal(1, 1);       \/\/ ArgEscape\n+        synchronized (l1) {                    \/\/ eliminated\n+            l1.dontinline_sync_method_no_brkpt(this);  \/\/ l1 escapes\n+            \/\/ trigger bulk rebias\n+            dontinline_bulkRevokeAfterWarmup(l1.getClass());\n+            \/\/ Now the epoch of l1 does not match the epoch of its class.\n+            \/\/ This has to be considered when relocking because of JVMTI access\n+            dontinline_brkpt();\n+        }\n+    }\n+\n+\n+    @Override\n+    public boolean testFrameShouldBeDeoptimized() {\n+        \/\/ Graal does not provide debug info about arg escape objects, therefore the frame is not deoptimized\n+        return !UseJVMCICompiler && super.testFrameShouldBeDeoptimized();\n+    }\n+}\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+\/**\n+ * Test relocking eliminated (nested) locks of an object on which the\n+ * target thread currently waits.\n+ *\/\n+class EARelockingObjectCurrentlyWaitingOn extends EATestCaseBaseDebugger {\n+\n+    public void runTestCase() throws Exception {\n+        env.targetMainThread.resume();\n+        boolean inWait = false;\n+        do {\n+            Thread.sleep(100);\n+            env.targetMainThread.suspend();\n+            printStack(env.targetMainThread);\n+            inWait = env.targetMainThread.frame(0).location().method().name().equals(\"wait\");\n+            if (!inWait) {\n+                msg(\"Target not yet in java.lang.Object.wait(long).\");\n+                env.targetMainThread.resume();\n+            }\n+        } while(!inWait);\n+        StackFrame testMethodFrame = env.targetMainThread.frame(4);\n+        \/\/ Access triggers relocking of all eliminated locks, including nested locks of l1 which references\n+        \/\/ the object on which the target main thread is currently waiting.\n+        ObjectReference l0 = getLocalRef(testMethodFrame, EARelockingObjectCurrentlyWaitingOnTarget.ForLocking.class.getName(), \"l0\");\n+        Asserts.assertEQ(l0.entryCount(), 1, \"wrong entry count\");\n+        ObjectReference l1 = getLocalRef(testMethodFrame, EARelockingObjectCurrentlyWaitingOnTarget.ForLocking.class.getName(), \"l1\");\n+        Asserts.assertEQ(l1.entryCount(), 0, \"wrong entry count\");\n+        setField(testCase, \"objToNotifyOn\", l1);\n+    }\n+}\n+\n+class EARelockingObjectCurrentlyWaitingOnTarget extends EATestCaseBaseTarget {\n+\n+    public static class ForLocking {\n+    }\n+\n+    public volatile Object objToNotifyOn; \/\/ debugger assigns value when notify thread should call objToNotifyOn.notifyAll()\n+\n+    @Override\n+    public void setUp() {\n+        super.setUp();\n+        testMethodDepth = 2;\n+    }\n+\n+    @Override\n+    public void warmupDone() {\n+        super.warmupDone();\n+        Thread t = new Thread(() -> doNotify());\n+        t.start();\n+    }\n+\n+    public void doNotify() {\n+        while (objToNotifyOn == null) {\n+            try {\n+                msg(\"objToNotifyOn is still null\");\n+                Thread.sleep(100);\n+            } catch (InterruptedException e) { \/* ignored *\/ }\n+        }\n+        synchronized (objToNotifyOn) {\n+            \/\/ will be received by the target main thread waiting in dontinline_waitWhenWarmupDone\n+            msg(\"calling objToNotifyOn.notifyAll()\");\n+            objToNotifyOn.notifyAll();\n+        }\n+    }\n+\n+    @Override\n+    public boolean testFrameShouldBeDeoptimized() {\n+        return false;\n+    }\n+\n+    @Override\n+    public void dontinline_testMethod() throws Exception {\n+        ForLocking l0 = new ForLocking(); \/\/ will be scalar replaced; access triggers realloc\/relock\n+        ForLocking l1 = new ForLocking();\n+        synchronized (l0) {\n+            synchronized (l1) {\n+                testMethod_inlined(l1);\n+            }\n+        }\n+    }\n+\n+    public void testMethod_inlined(ForLocking l2) throws Exception {\n+        synchronized (l2) {                 \/\/ eliminated nested locking\n+            dontinline_waitWhenWarmupDone(l2);\n+        }\n+    }\n+\n+    public void dontinline_waitWhenWarmupDone(ForLocking l2) throws Exception {\n+        if (warmupDone) {\n+            l2.wait();\n+        }\n+    }\n+}\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\/\/\n+\/\/ Test cases that require deoptimization even though neither locks\n+\/\/ nor allocations are eliminated at the point where escape state is changed.\n+\/\/\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+\/**\n+ * Let xy be NoEscape whose allocation cannot be eliminated (simulated by\n+ * -XX:-EliminateAllocations). The holding compiled frame has to be deoptimized when debugger\n+ * accesses xy because afterwards locking on xy is omitted.\n+ * Note: there are no EA based optimizations at the escape point.\n+ *\/\n+class EADeoptFrameAfterReadLocalObject_01 extends EATestCaseBaseDebugger {\n+\n+    public void runTestCase() throws Exception {\n+        BreakpointEvent bpe = env.resumeTo(TARGET_TESTCASE_BASE_NAME, \"dontinline_brkpt\", \"()V\");\n+        printStack(bpe.thread());\n+        @SuppressWarnings(\"unused\")\n+        ObjectReference xy = getLocalRef(bpe.thread().frame(1), XYVAL_NAME, \"xy\");\n+    }\n+}\n+\n+class EADeoptFrameAfterReadLocalObject_01Target extends EATestCaseBaseTarget {\n+\n+    public void dontinline_testMethod() {\n+        XYVal xy = new XYVal(1, 1);\n+        dontinline_brkpt();              \/\/ Debugger reads xy, when there are no virtual objects or eliminated locks in scope\n+        synchronized (xy) {              \/\/ Locking is eliminated.\n+            xy.x++;\n+            xy.y++;\n+        }\n+    }\n+}\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+\/**\n+ * Similar to {@link EADeoptFrameAfterReadLocalObject_01} with the difference that the debugger\n+ * reads xy from an inlined callee. So xy is NoEscape instead of ArgEscape.\n+ *\/\n+class EADeoptFrameAfterReadLocalObject_01BTarget extends EATestCaseBaseTarget {\n+\n+    @Override\n+    public void setUp() {\n+        super.setUp();\n+        testMethodDepth = 2;\n+    }\n+\n+    public void dontinline_testMethod() {\n+        XYVal xy  = new XYVal(1, 1);\n+        callee(xy);                 \/\/ Debugger acquires ref to xy from inlined callee\n+                                    \/\/ xy is NoEscape, nevertheless the object is not replaced\n+                                    \/\/ by scalars if running with -XX:-EliminateAllocations.\n+                                    \/\/ In that case there are no EA based optimizations were\n+                                    \/\/ the debugger reads the NoEscape object.\n+        synchronized (xy) {         \/\/ Locking is eliminated.\n+            xy.x++;\n+            xy.y++;\n+        }\n+    }\n+\n+    public void callee(XYVal xy) {\n+        dontinline_brkpt();              \/\/ Debugger reads xy.\n+                                         \/\/ There are no virtual objects or eliminated locks.\n+    }\n+}\n+\n+class EADeoptFrameAfterReadLocalObject_01B extends EATestCaseBaseDebugger {\n+\n+    public void runTestCase() throws Exception {\n+        BreakpointEvent bpe = env.resumeTo(TARGET_TESTCASE_BASE_NAME, \"dontinline_brkpt\", \"()V\");\n+        printStack(bpe.thread());\n+        @SuppressWarnings(\"unused\")\n+        ObjectReference xy = getLocalRef(bpe.thread().frame(1), \"callee\", \"xy\", XYVAL_NAME);\n+    }\n+}\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+\/**\n+ * Let xy be ArgEscape. The frame dontinline_testMethod() has to be deoptimized when debugger\n+ * acquires xy from dontinline_callee() because afterwards locking on xy is omitted.\n+ * Note: there are no EA based optimizations at the escape point.\n+ *\/\n+class EADeoptFrameAfterReadLocalObject_02 extends EATestCaseBaseDebugger {\n+\n+    public void runTestCase() throws Exception {\n+        BreakpointEvent bpe = env.resumeTo(TARGET_TESTCASE_BASE_NAME, \"dontinline_brkpt\", \"()V\");\n+        printStack(bpe.thread());\n+        @SuppressWarnings(\"unused\")\n+        ObjectReference xy = getLocalRef(bpe.thread().frame(1), \"dontinline_callee\", \"xy\", XYVAL_NAME);\n+    }\n+}\n+\n+class EADeoptFrameAfterReadLocalObject_02Target extends EATestCaseBaseTarget {\n+\n+    public void dontinline_testMethod() {\n+        XYVal xy  = new XYVal(1, 1);\n+        dontinline_callee(xy);      \/\/ xy is ArgEscape, debugger acquires ref to xy from callee\n+        synchronized (xy) {         \/\/ Locking is eliminated.\n+            xy.x++;\n+            xy.y++;\n+        }\n+    }\n+\n+    public void dontinline_callee(XYVal xy) {\n+        dontinline_brkpt();              \/\/ Debugger reads xy.\n+                                         \/\/ There are no virtual objects or eliminated locks.\n+    }\n+\n+    @Override\n+    public void setUp() {\n+        super.setUp();\n+        testMethodDepth = 2;\n+    }\n+\n+    @Override\n+    public boolean testFrameShouldBeDeoptimized() {\n+        \/\/ Graal does not provide debug info about arg escape objects, therefore the frame is not deoptimized\n+        return !UseJVMCICompiler && super.testFrameShouldBeDeoptimized();\n+    }\n+}\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+\/**\n+ * Similar to {@link EADeoptFrameAfterReadLocalObject_02} there is an ArgEscape object xy, but in\n+ * contrast it is not in the parameter list of a call when the debugger reads an object.\n+ * Therefore the frame of the test method should not be deoptimized\n+ *\/\n+class EADeoptFrameAfterReadLocalObject_02B extends EATestCaseBaseDebugger {\n+\n+    public void runTestCase() throws Exception {\n+        BreakpointEvent bpe = env.resumeTo(TARGET_TESTCASE_BASE_NAME, \"dontinline_brkpt\", \"()V\");\n+        printStack(bpe.thread());\n+        @SuppressWarnings(\"unused\")\n+        ObjectReference xy = getLocalRef(bpe.thread().frame(1), \"dontinline_callee\", \"xy\", XYVAL_NAME);\n+    }\n+}\n+\n+class EADeoptFrameAfterReadLocalObject_02BTarget extends EATestCaseBaseTarget {\n+\n+    public void dontinline_testMethod() {\n+        XYVal xy  = new XYVal(1, 1);\n+        dontinline_make_arg_escape(xy);  \/\/ because of this call xy is ArgEscape\n+        dontinline_callee();             \/\/ xy is ArgEscape, but not a parameter of this call\n+        synchronized (xy) {              \/\/ Locking is eliminated.\n+            xy.x++;\n+            xy.y++;\n+        }\n+    }\n+\n+    public void dontinline_callee() {\n+        @SuppressWarnings(\"unused\")\n+        XYVal xy  = new XYVal(2, 2);\n+        dontinline_brkpt();              \/\/ Debugger reads xy.\n+                                         \/\/ No need to deoptimize the caller frame\n+    }\n+\n+    @Override\n+    public void setUp() {\n+        super.setUp();\n+        testMethodDepth = 2;\n+    }\n+\n+    @Override\n+    public boolean testFrameShouldBeDeoptimized() {\n+        return false;\n+    }\n+}\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+\/**\n+ * Similar to {@link EADeoptFrameAfterReadLocalObject_02} there is an ArgEscape object xy in\n+ * dontinline_testMethod() which is being passed as parameter when the debugger accesses a local object.\n+ * Nevertheless dontinline_testMethod must not be deoptimized because there is an entry frame\n+ * between it and the frame accessed by the debugger.\n+ *\/\n+class EADeoptFrameAfterReadLocalObject_02C extends EATestCaseBaseDebugger {\n+\n+    public void runTestCase() throws Exception {\n+        BreakpointEvent bpe = env.resumeTo(TARGET_TESTCASE_BASE_NAME, \"dontinline_brkpt\", \"()V\");\n+        printStack(bpe.thread());\n+        @SuppressWarnings(\"unused\")\n+        ObjectReference xy = getLocalRef(bpe.thread().frame(1), \"dontinline_callee_accessed_by_debugger\", \"xy\", XYVAL_NAME);\n+    }\n+}\n+\n+class EADeoptFrameAfterReadLocalObject_02CTarget extends EATestCaseBaseTarget {\n+\n+    public void dontinline_testMethod() {\n+        XYVal xy  = new XYVal(1, 1);\n+        dontinline_callee(xy);           \/\/ xy is ArgEscape and being passed as parameter\n+        synchronized (xy) {              \/\/ Locking is eliminated.\n+            xy.x++;\n+            xy.y++;\n+        }\n+    }\n+\n+    public void dontinline_callee(XYVal xy) {\n+        if (warmupDone) {\n+            dontinline_call_with_entry_frame(this, \"dontinline_callee_accessed_by_debugger\");\n+        }\n+    }\n+\n+    public void dontinline_callee_accessed_by_debugger() {\n+        @SuppressWarnings(\"unused\")\n+        XYVal xy  = new XYVal(2, 2);\n+        dontinline_brkpt();              \/\/ Debugger reads xy.\n+                                         \/\/ No need to deoptimize the caller frame\n+    }\n+\n+    @Override\n+    public void setUp() {\n+        super.setUp();\n+        testMethodDepth = 8;\n+    }\n+\n+    @Override\n+    public boolean testFrameShouldBeDeoptimized() {\n+        return false;\n+    }\n+}\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+\/**\n+ * Let xy be NoEscape whose allocation cannot be eliminated (e.g. because of\n+ * -XX:-EliminateAllocations).  The holding compiled frame has to be deoptimized when debugger\n+ * accesses xy because the following field accesses get eliminated.  Note: there are no EA based\n+ * optimizations at the escape point.\n+ *\/\n+class EADeoptFrameAfterReadLocalObject_03 extends EATestCaseBaseDebugger {\n+\n+    public void runTestCase() throws Exception {\n+        BreakpointEvent bpe = env.resumeTo(TARGET_TESTCASE_BASE_NAME, \"dontinline_brkpt\", \"()V\");\n+        printStack(bpe.thread());\n+        ObjectReference xy = getLocalRef(bpe.thread().frame(1), XYVAL_NAME, \"xy\");\n+        setField(xy, \"x\", env.vm().mirrorOf(1));\n+    }\n+}\n+\n+class EADeoptFrameAfterReadLocalObject_03Target extends EATestCaseBaseTarget {\n+\n+    public void dontinline_testMethod() {\n+        XYVal xy = new XYVal(0, 1);\n+        dontinline_brkpt();              \/\/ Debugger reads xy, when there are no virtual objects or\n+                                         \/\/ eliminated locks in scope and modifies xy.x\n+        iResult = xy.x + xy.y;           \/\/ Loads are replaced by constants 0 and 1.\n+    }\n+\n+    @Override\n+    public int getExpectedIResult() {\n+        return 1 + 1;\n+    }\n+}\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\/\/\n+\/\/ Monitor info tests\n+\/\/\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+class EAGetOwnedMonitorsTarget extends EATestCaseBaseTarget {\n+\n+    public long checkSum;\n+\n+    public void dontinline_testMethod() {\n+        XYVal l1 = new XYVal(4, 2);\n+        synchronized (l1) {\n+            dontinline_endlessLoop();\n+        }\n+    }\n+\n+    @Override\n+    public void setUp() {\n+        super.setUp();\n+        testMethodDepth = 2;\n+        loopCount = 3;\n+    }\n+\n+    public void warmupDone() {\n+        super.warmupDone();\n+        msg(\"enter 'endless' loop by setting loopCount = Long.MAX_VALUE\");\n+        loopCount = Long.MAX_VALUE; \/\/ endless loop\n+    }\n+}\n+\n+class EAGetOwnedMonitors extends EATestCaseBaseDebugger {\n+\n+    public void runTestCase() throws Exception {\n+        msg(\"resume\");\n+        env.targetMainThread.resume();\n+        waitUntilTargetHasEnteredEndlessLoop();\n+        \/\/ In contrast to JVMTI, JDWP requires a target thread to be suspended, before the owned monitors can be queried\n+        msg(\"suspend target\");\n+        env.targetMainThread.suspend();\n+        msg(\"Get owned monitors\");\n+        List<ObjectReference> monitors = env.targetMainThread.ownedMonitors();\n+        Asserts.assertEQ(monitors.size(), 1, \"unexpected number of owned monitors\");\n+        terminateEndlessLoop();\n+    }\n+}\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+class EAEntryCountTarget extends EATestCaseBaseTarget {\n+\n+    public long checkSum;\n+\n+    public void dontinline_testMethod() {\n+        XYVal l1 = new XYVal(4, 2);\n+        synchronized (l1) {\n+            inline_testMethod2(l1);\n+        }\n+    }\n+\n+    public void inline_testMethod2(XYVal l1) {\n+        synchronized (l1) {\n+            dontinline_endlessLoop();\n+        }\n+    }\n+\n+    @Override\n+    public void setUp() {\n+        super.setUp();\n+        testMethodDepth = 2;\n+        loopCount = 3;\n+    }\n+\n+    public void warmupDone() {\n+        super.warmupDone();\n+        msg(\"enter 'endless' loop by setting loopCount = Long.MAX_VALUE\");\n+        loopCount = Long.MAX_VALUE; \/\/ endless loop\n+    }\n+}\n+\n+class EAEntryCount extends EATestCaseBaseDebugger {\n+\n+    public void runTestCase() throws Exception {\n+        msg(\"resume\");\n+        env.targetMainThread.resume();\n+        waitUntilTargetHasEnteredEndlessLoop();\n+        \/\/ In contrast to JVMTI, JDWP requires a target thread to be suspended, before the owned monitors can be queried\n+        msg(\"suspend target\");\n+        env.targetMainThread.suspend();\n+        msg(\"Get owned monitors\");\n+        List<ObjectReference> monitors = env.targetMainThread.ownedMonitors();\n+        Asserts.assertEQ(monitors.size(), 1, \"unexpected number of owned monitors\");\n+        msg(\"Get entry count\");\n+        int entryCount = monitors.get(0).entryCount();\n+        Asserts.assertEQ(entryCount, 2, \"wrong entry count\");\n+        terminateEndlessLoop();\n+    }\n+}\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\/\/\n+\/\/ PopFrame tests\n+\/\/\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+\/**\n+ * PopFrame into caller frame with scalar replaced objects.\n+ *\/\n+class EAPopFrameNotInlined extends EATestCaseBaseDebugger {\n+\n+    public void runTestCase() throws Exception {\n+        BreakpointEvent bpe = env.resumeTo(TARGET_TESTCASE_BASE_NAME, \"dontinline_brkpt\", \"()V\");\n+        printStack(bpe.thread());\n+        msg(\"PopFrame\");\n+        bpe.thread().popFrames(bpe.thread().frame(0));\n+        msg(\"PopFrame DONE\");\n+    }\n+\n+    @Override\n+    public boolean shouldSkip() {\n+        \/\/ And Graal currently doesn't support PopFrame\n+        return super.shouldSkip() || env.targetVMOptions.UseJVMCICompiler;\n+    }\n+}\n+\n+class EAPopFrameNotInlinedTarget extends EATestCaseBaseTarget {\n+\n+    public void dontinline_testMethod() {\n+        XYVal xy = new XYVal(4, 2);\n+        dontinline_brkpt();\n+        iResult = xy.x + xy.y;\n+    }\n+\n+    @Override\n+    public boolean testFrameShouldBeDeoptimized() {\n+        \/\/ Test is only performed after the frame pop.\n+        \/\/ Then dontinline_testMethod is interpreted.\n+        return false;\n+    }\n+\n+    @Override\n+    public int getExpectedIResult() {\n+        return 4 + 2;\n+    }\n+\n+    @Override\n+    public boolean shouldSkip() {\n+        \/\/ And Graal currently doesn't support PopFrame\n+        return super.shouldSkip() || UseJVMCICompiler;\n+    }\n+}\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+\/**\n+ * Pop frames into {@link EAPopFrameNotInlinedReallocFailureTarget#dontinline_testMethod()} which\n+ * holds scalar replaced objects. In preparation of the pop frame operations the vm eagerly\n+ * reallocates scalar replaced objects to avoid failures when actually popping the frames. We provoke\n+ * a reallocation failures and expect {@link VMOutOfMemoryException}.\n+ *\/\n+class EAPopFrameNotInlinedReallocFailure extends EATestCaseBaseDebugger {\n+\n+    public void runTestCase() throws Exception {\n+        BreakpointEvent bpe = env.resumeTo(TARGET_TESTCASE_BASE_NAME, \"dontinline_brkpt\", \"()V\");\n+        ThreadReference thread = bpe.thread();\n+        printStack(thread);\n+        \/\/ frame[0]: EATestCaseBaseTarget.dontinline_brkpt()\n+        \/\/ frame[1]: EAPopFrameNotInlinedReallocFailureTarget.dontinline_consume_all_memory_brkpt()\n+        \/\/ frame[2]: EAPopFrameNotInlinedReallocFailureTarget.dontinline_testMethod()\n+        \/\/ frame[3]: EATestCaseBaseTarget.run()\n+        \/\/ frame[4]: EATestsTarget.main(java.lang.String[])\n+        msg(\"PopFrame\");\n+        boolean coughtOom = false;\n+        try {\n+            \/\/ try to pop dontinline_consume_all_memory_brkpt\n+            thread.popFrames(thread.frame(1));\n+        } catch (VMOutOfMemoryException oom) {\n+            \/\/ as expected\n+            msg(\"cought OOM\");\n+            coughtOom  = true;\n+        }\n+        freeAllMemory();\n+        \/\/ We succeeded to pop just one frame. When we continue, we will call dontinline_brkpt() again.\n+        Asserts.assertTrue(coughtOom || !env.targetVMOptions.EliminateAllocations, \"PopFrame should have triggered an OOM exception in target\");\n+        String expectedTopFrame =\n+                env.targetVMOptions.EliminateAllocations ? \"dontinline_consume_all_memory_brkpt\" : \"dontinline_testMethod\";\n+        Asserts.assertEQ(expectedTopFrame, thread.frame(0).location().method().name());\n+        printStack(thread);\n+    }\n+\n+    @Override\n+    public boolean shouldSkip() {\n+        \/\/ OOMEs because of realloc failures with DeoptimizeObjectsALot are too random.\n+        \/\/ And Graal currently doesn't provide all information about non-escaping objects in debug info\n+        return super.shouldSkip() || env.targetVMOptions.DeoptimizeObjectsALot || env.targetVMOptions.UseJVMCICompiler;\n+    }\n+}\n+\n+class EAPopFrameNotInlinedReallocFailureTarget extends EATestCaseBaseTarget {\n+\n+    public boolean doneAlready;\n+\n+    public void dontinline_testMethod() {\n+        long a[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};                \/\/ scalar replaced\n+        Vector10 v = new Vector10(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);  \/\/ scalar replaced\n+        dontinline_consume_all_memory_brkpt();\n+        lResult = a[0] + a[1] + a[2] + a[3] + a[4] + a[5] + a[6] + a[7] + a[8] + a[9]\n+               + v.i0 + v.i1 + v.i2 + v.i3 + v.i4 + v.i5 + v.i6 + v.i7 + v.i8 + v.i9;\n+    }\n+\n+    public void dontinline_consume_all_memory_brkpt() {\n+        if (warmupDone && !doneAlready) {\n+            doneAlready = true;\n+            consumeAllMemory(); \/\/ provoke reallocation failure\n+            dontinline_brkpt();\n+        }\n+    }\n+\n+    @Override\n+    public void setUp() {\n+        super.setUp();\n+        testMethodDepth = 2;\n+    }\n+\n+    @Override\n+    public long getExpectedLResult() {\n+        long n = 10;\n+        return 2*n*(n+1)\/2;\n+    }\n+\n+    @Override\n+    public boolean shouldSkip() {\n+        \/\/ OOMEs because of realloc failures with DeoptimizeObjectsALot are too random.\n+        \/\/ And Graal currently doesn't provide all information about non-escaping objects in debug info\n+        return super.shouldSkip() || DeoptimizeObjectsALot || UseJVMCICompiler;\n+    }\n+}\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+\/**\n+ * Pop inlined top frame dropping into method with scalar replaced opjects.\n+ *\/\n+class EAPopInlinedMethodWithScalarReplacedObjectsReallocFailure extends EATestCaseBaseDebugger {\n+\n+    public void runTestCase() throws Exception {\n+        ThreadReference thread = env.targetMainThread;\n+        thread.resume();\n+        waitUntilTargetHasEnteredEndlessLoop();\n+\n+        thread.suspend();\n+        printStack(thread);\n+        \/\/ frame[0]: EAPopInlinedMethodWithScalarReplacedObjectsReallocFailureTarget.inlinedCallForcedToReturn()\n+        \/\/ frame[1]: EAPopInlinedMethodWithScalarReplacedObjectsReallocFailureTarget.dontinline_testMethod()\n+        \/\/ frame[2]: EATestCaseBaseTarget.run()\n+\n+        msg(\"Pop Frames\");\n+        boolean coughtOom = false;\n+        try {\n+            thread.popFrames(thread.frame(0));    \/\/ Request pop frame of inlinedCallForcedToReturn()\n+                                                  \/\/ reallocation is triggered here\n+        } catch (VMOutOfMemoryException oom) {\n+            \/\/ as expected\n+            msg(\"cought OOM\");\n+            coughtOom = true;\n+        }\n+        printStack(thread);\n+        \/\/ frame[0]: EAPopInlinedMethodWithScalarReplacedObjectsReallocFailureTarget.inlinedCallForcedToReturn()\n+        \/\/ frame[1]: EAPopInlinedMethodWithScalarReplacedObjectsReallocFailureTarget.dontinline_testMethod()\n+        \/\/ frame[2]: EATestCaseBaseTarget.run()\n+\n+        freeAllMemory();\n+        setField(testCase, \"loopCount\", env.vm().mirrorOf(0)); \/\/ terminate loop\n+        Asserts.assertTrue(coughtOom || !env.targetVMOptions.EliminateAllocations, \"PopFrame should have triggered an OOM exception in target\");\n+        String expectedTopFrame =\n+                env.targetVMOptions.EliminateAllocations ? \"inlinedCallForcedToReturn\" : \"dontinline_testMethod\";\n+        Asserts.assertEQ(expectedTopFrame, thread.frame(0).location().method().name());\n+    }\n+\n+    @Override\n+    public boolean shouldSkip() {\n+        \/\/ OOMEs because of realloc failures with DeoptimizeObjectsALot are too random.\n+        \/\/ And Graal currently doesn't provide all information about non-escaping objects in debug info\n+        return super.shouldSkip() || env.targetVMOptions.DeoptimizeObjectsALot || env.targetVMOptions.UseJVMCICompiler;\n+    }\n+}\n+\n+class EAPopInlinedMethodWithScalarReplacedObjectsReallocFailureTarget extends EATestCaseBaseTarget {\n+\n+    public long checkSum;\n+\n+    public void dontinline_testMethod() {\n+        long a[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};                \/\/ scalar replaced\n+        Vector10 v = new Vector10(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);  \/\/ scalar replaced\n+        long l = inlinedCallForcedToReturn();\n+        lResult = a[0] + a[1] + a[2] + a[3] + a[4] + a[5] + a[6] + a[7] + a[8] + a[9]\n+               + v.i0 + v.i1 + v.i2 + v.i3 + v.i4 + v.i5 + v.i6 + v.i7 + v.i8 + v.i9;\n+    }\n+\n+    public long inlinedCallForcedToReturn() {\n+        long cs = checkSum;\n+        dontinline_consumeAllMemory();\n+        while (loopCount-- > 0) {\n+            targetIsInLoop = true;\n+            checkSum += checkSum % ++cs;\n+        }\n+        loopCount = 3;\n+        targetIsInLoop = false;\n+        return checkSum;\n+    }\n+\n+    public void dontinline_consumeAllMemory() {\n+        if (warmupDone && (loopCount > 3)) {\n+            consumeAllMemory();\n+        }\n+    }\n+\n+    @Override\n+    public long getExpectedLResult() {\n+        long n = 10;\n+        return 2*n*(n+1)\/2;\n+    }\n+\n+    @Override\n+    public void setUp() {\n+        super.setUp();\n+        loopCount = 3;\n+    }\n+\n+    public void warmupDone() {\n+        super.warmupDone();\n+        msg(\"enter 'endless' loop by setting loopCount = Long.MAX_VALUE\");\n+        loopCount = Long.MAX_VALUE; \/\/ endless loop\n+    }\n+\n+    @Override\n+    public boolean shouldSkip() {\n+        \/\/ OOMEs because of realloc failures with DeoptimizeObjectsALot are too random.\n+        \/\/ And Graal currently doesn't provide all information about non-escaping objects in debug info\n+        return super.shouldSkip() || DeoptimizeObjectsALot || UseJVMCICompiler;\n+    }\n+}\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\/\/\n+\/\/ ForceEarlyReturn tests\n+\/\/\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+\/**\n+ * ForceEarlyReturn into caller frame with scalar replaced objects.\n+ *\/\n+class EAForceEarlyReturnNotInlined extends EATestCaseBaseDebugger {\n+\n+    public void runTestCase() throws Exception {\n+        BreakpointEvent bpe = env.resumeTo(TARGET_TESTCASE_BASE_NAME, \"dontinline_brkpt\", \"()V\");\n+        ThreadReference thread = bpe.thread();\n+        printStack(thread);\n+        \/\/ frame[0]: EATestCaseBaseTarget.dontinline_brkpt()\n+        \/\/ frame[1]: EATestCaseBaseTarget.dontinline_brkpt_iret()\n+        \/\/ frame[2]: EAForceEarlyReturnNotInlinedTarget.dontinline_testMethod()\n+        \/\/ frame[3]: EATestCaseBaseTarget.run()\n+        \/\/ frame[4]: EATestsTarget.main(java.lang.String[])\n+\n+        msg(\"Step out\");\n+        env.stepOut(thread);                               \/\/ return from dontinline_brkpt\n+        printStack(thread);\n+        msg(\"ForceEarlyReturn\");\n+        thread.forceEarlyReturn(env.vm().mirrorOf(43));    \/\/ return from dontinline_brkpt_iret,\n+                                                           \/\/ does not trigger reallocation in contrast to PopFrame\n+        msg(\"Step over line\");\n+        env.stepOverLine(thread);                          \/\/ reallocation is triggered here\n+        printStack(thread);\n+        msg(\"ForceEarlyReturn DONE\");\n+    }\n+\n+    @Override\n+    public boolean shouldSkip() {\n+        \/\/ Graal currently doesn't support Force Early Return\n+        return super.shouldSkip() || env.targetVMOptions.UseJVMCICompiler;\n+    }\n+}\n+\n+class EAForceEarlyReturnNotInlinedTarget extends EATestCaseBaseTarget {\n+\n+    public void dontinline_testMethod() {\n+        XYVal xy = new XYVal(4, 2);\n+        int i = dontinline_brkpt_iret();\n+        iResult = xy.x + xy.y + i;\n+    }\n+\n+    @Override\n+    public int getExpectedIResult() {\n+        return 4 + 2 + 43;\n+    }\n+\n+    @Override\n+    public void setUp() {\n+        super.setUp();\n+        testMethodDepth = 2;\n+    }\n+\n+    public boolean testFrameShouldBeDeoptimized() {\n+        return true; \/\/ because of stepping\n+    }\n+\n+    @Override\n+    public boolean shouldSkip() {\n+        \/\/ Graal currently doesn't support Force Early Return\n+        return super.shouldSkip() || UseJVMCICompiler;\n+    }\n+}\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+\/**\n+ * ForceEarlyReturn at safepoint in frame with scalar replaced objects.\n+ *\/\n+class EAForceEarlyReturnOfInlinedMethodWithScalarReplacedObjects extends EATestCaseBaseDebugger {\n+\n+    public void runTestCase() throws Exception {\n+        ThreadReference thread = env.targetMainThread;\n+        thread.resume();\n+        waitUntilTargetHasEnteredEndlessLoop();\n+\n+        thread.suspend();\n+        printStack(thread);\n+        \/\/ frame[0]: EAForceEarlyReturnOfInlinedMethodWithScalarReplacedObjectsTarget.inlinedCallForcedToReturn()\n+        \/\/ frame[1]: EAForceEarlyReturnOfInlinedMethodWithScalarReplacedObjectsTarget.dontinline_testMethod()\n+        \/\/ frame[2]: EATestCaseBaseTarget.run()\n+\n+        msg(\"ForceEarlyReturn\");\n+        thread.forceEarlyReturn(env.vm().mirrorOf(43));    \/\/ Request force return 43 from inlinedCallForcedToReturn()\n+                                                           \/\/ reallocation is triggered here\n+        msg(\"Step over instruction to do the forced return\");\n+        env.stepOverInstruction(thread);\n+        printStack(thread);\n+        msg(\"ForceEarlyReturn DONE\");\n+    }\n+\n+    @Override\n+    public boolean shouldSkip() {\n+        \/\/ Graal currently doesn't support Force Early Return\n+        return super.shouldSkip() || env.targetVMOptions.UseJVMCICompiler;\n+    }\n+}\n+\n+class EAForceEarlyReturnOfInlinedMethodWithScalarReplacedObjectsTarget extends EATestCaseBaseTarget {\n+\n+    public int checkSum;\n+\n+    public void dontinline_testMethod() {\n+        XYVal xy = new XYVal(4, 2);\n+        int i = inlinedCallForcedToReturn();\n+        iResult = xy.x + xy.y + i;\n+    }\n+\n+    public int inlinedCallForcedToReturn() {               \/\/ forced to return 43\n+        int i = checkSum;\n+        while (loopCount-- > 0) {\n+            targetIsInLoop = true;\n+            checkSum += checkSum % ++i;\n+        }\n+        loopCount = 3;\n+        targetIsInLoop = false;\n+        return checkSum;\n+    }\n+\n+    @Override\n+    public int getExpectedIResult() {\n+        return 4 + 2 + 43;\n+    }\n+\n+    @Override\n+    public void setUp() {\n+        super.setUp();\n+        testMethodDepth = 2;\n+        loopCount = 3;\n+    }\n+\n+    public void warmupDone() {\n+        super.warmupDone();\n+        msg(\"enter 'endless' loop by setting loopCount = Long.MAX_VALUE\");\n+        loopCount = Long.MAX_VALUE; \/\/ endless loop\n+    }\n+\n+    public boolean testFrameShouldBeDeoptimized() {\n+        return true; \/\/ because of stepping\n+    }\n+\n+    @Override\n+    public boolean shouldSkip() {\n+        \/\/ Graal currently doesn't support Force Early Return\n+        return super.shouldSkip() || UseJVMCICompiler;\n+    }\n+}\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+\/**\n+ * ForceEarlyReturn with reallocation failure.\n+ *\/\n+class EAForceEarlyReturnOfInlinedMethodWithScalarReplacedObjectsReallocFailure extends EATestCaseBaseDebugger {\n+\n+    public void runTestCase() throws Exception {\n+        ThreadReference thread = env.targetMainThread;\n+        thread.resume();\n+        waitUntilTargetHasEnteredEndlessLoop();\n+\n+        thread.suspend();\n+        printStack(thread);\n+        \/\/ frame[0]: EAForceEarlyReturnOfInlinedMethodWithScalarReplacedObjectsReallocFailureTarget.inlinedCallForcedToReturn()\n+        \/\/ frame[1]: EAForceEarlyReturnOfInlinedMethodWithScalarReplacedObjectsReallocFailureTarget.dontinline_testMethod()\n+        \/\/ frame[2]: EATestCaseBaseTarget.run()\n+\n+        msg(\"ForceEarlyReturn\");\n+        boolean coughtOom = false;\n+        try {\n+            thread.forceEarlyReturn(env.vm().mirrorOf(43));    \/\/ Request force return 43 from inlinedCallForcedToReturn()\n+                                                               \/\/ reallocation is triggered here\n+        } catch (VMOutOfMemoryException oom) {\n+            \/\/ as expected\n+            msg(\"cought OOM\");\n+            coughtOom   = true;\n+        }\n+        freeAllMemory();\n+        if (env.targetVMOptions.EliminateAllocations) {\n+            Asserts.assertTrue(coughtOom, \"PopFrame should have triggered an OOM exception in target\");\n+            thread.forceEarlyReturn(env.vm().mirrorOf(43));\n+        }\n+        msg(\"Step over instruction to do the forced return\");\n+        env.stepOverInstruction(thread);\n+        printStack(thread);\n+        msg(\"ForceEarlyReturn DONE\");\n+    }\n+\n+    @Override\n+    public boolean shouldSkip() {\n+        \/\/ OOMEs because of realloc failures with DeoptimizeObjectsALot are too random.\n+        \/\/ And Graal currently doesn't support Force Early Return\n+        return super.shouldSkip() || env.targetVMOptions.DeoptimizeObjectsALot || env.targetVMOptions.UseJVMCICompiler;\n+    }\n+}\n+\n+class EAForceEarlyReturnOfInlinedMethodWithScalarReplacedObjectsReallocFailureTarget extends EATestCaseBaseTarget {\n+\n+    public int checkSum;\n+\n+    public void dontinline_testMethod() {\n+        long a[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};                \/\/ scalar replaced\n+        Vector10 v = new Vector10(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);  \/\/ scalar replaced\n+        long l = inlinedCallForcedToReturn();\n+        lResult = a[0] + a[1] + a[2] + a[3] + a[4] + a[5] + a[6] + a[7] + a[8] + a[9]\n+               + v.i0 + v.i1 + v.i2 + v.i3 + v.i4 + v.i5 + v.i6 + v.i7 + v.i8 + v.i9 + l;\n+    }\n+\n+    public long inlinedCallForcedToReturn() {                      \/\/ forced to return 43\n+        long cs = checkSum;\n+        dontinline_consumeAllMemory();\n+        while (loopCount-- > 0) {\n+            targetIsInLoop = true;\n+            checkSum += checkSum % ++cs;\n+        }\n+        loopCount = 3;\n+        targetIsInLoop = false;\n+        return checkSum;\n+    }\n+\n+    public void dontinline_consumeAllMemory() {\n+        if (warmupDone) {\n+            consumeAllMemory();\n+        }\n+    }\n+\n+    @Override\n+    public long getExpectedLResult() {\n+        long n = 10;\n+        return 2*n*(n+1)\/2 + 43;\n+    }\n+\n+    @Override\n+    public void setUp() {\n+        super.setUp();\n+        testMethodDepth = 2;\n+        loopCount = 3;\n+    }\n+\n+    public void warmupDone() {\n+        super.warmupDone();\n+        msg(\"enter 'endless' loop by setting loopCount = Long.MAX_VALUE\");\n+        loopCount = Long.MAX_VALUE; \/\/ endless loop\n+    }\n+\n+    @Override\n+    public boolean shouldSkip() {\n+        \/\/ OOMEs because of realloc failures with DeoptimizeObjectsALot are too random.\n+        \/\/ And Graal currently doesn't support Force Early Return\n+        return super.shouldSkip() || DeoptimizeObjectsALot || UseJVMCICompiler;\n+    }\n+}\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\/\/\n+\/\/ Get Instances of ReferenceType\n+\/\/\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+\/**\n+ * Check if instances of a type are found even if they are scalar replaced.  To stress the\n+ * implementation a little more, the instances should be retrieved while the target is running.\n+ *\/\n+class EAGetInstancesOfReferenceType extends EATestCaseBaseDebugger {\n+\n+    public void runTestCase() throws Exception {\n+        printStack(env.targetMainThread);\n+        ReferenceType cls = ((ClassObjectReference)getField(testCase, \"cls\")).reflectedType();\n+        msg(\"reflected type is \" + cls);\n+        msg(\"resume\");\n+        env.targetMainThread.resume();\n+        waitUntilTargetHasEnteredEndlessLoop();\n+        \/\/ do this while thread is running!\n+        msg(\"Retrieve instances of \" + cls.name());\n+        List<ObjectReference> instances = cls.instances(10);\n+        Asserts.assertEQ(instances.size(), 3, \"unexpected number of instances of \" + cls.name());\n+        \/\/ invariant: main thread is suspended at the end of the test case\n+        msg(\"suspend\");\n+        env.targetMainThread.suspend();\n+        terminateEndlessLoop();\n+    }\n+}\n+\n+class EAGetInstancesOfReferenceTypeTarget extends EATestCaseBaseTarget {\n+\n+    public long checkSum;\n+\n+    public static Class<LocalXYVal> cls = LocalXYVal.class;\n+\n+    public static class LocalXYVal {\n+        public int x, y;\n+\n+        public LocalXYVal(int x, int y) {\n+            this.x = x; this.y = y;\n+        }\n+    }\n+\n+    @Override\n+    public void dontinline_testMethod() {\n+        LocalXYVal p1 = new LocalXYVal(4, 2);\n+        LocalXYVal p2 = new LocalXYVal(5, 3);\n+        LocalXYVal p3 = new LocalXYVal(6, 4);\n+        dontinline_endlessLoop();\n+        iResult = p1.x+p1.y + p2.x+p2.y + p3.x+p3.y;\n+    }\n+\n+    @Override\n+    public int getExpectedIResult() {\n+        return 6+8+10;\n+    }\n+\n+    @Override\n+    public void setUp() {\n+        super.setUp();\n+        testMethodDepth = 2;\n+        loopCount = 3;\n+    }\n+\n+    public void warmupDone() {\n+        super.warmupDone();\n+        msg(\"enter 'endless' loop by setting loopCount = Long.MAX_VALUE\");\n+        loopCount = Long.MAX_VALUE; \/\/ endless loop\n+    }\n+}\n+\n+\n+\/\/ End of test case collection\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\/\/ Helper classes\n+class XYVal {\n+\n+    public int x, y;\n+\n+    public XYVal(int x, int y) {\n+        this.x = x;\n+        this.y = y;\n+    }\n+\n+    \/**\n+     * Note that we don't use a sync block here because javac would generate an synthetic exception\n+     * handler for the synchronized block that catches Throwable E, unlocks and throws E\n+     * again. The throw bytecode causes the BCEscapeAnalyzer to set the escape state to GlobalEscape\n+     * (see comment on exception handlers in BCEscapeAnalyzer::iterate_blocks())\n+     *\/\n+    public synchronized void dontinline_sync_method(EATestCaseBaseTarget target) {\n+        target.dontinline_brkpt();\n+    }\n+\n+    \/**\n+     * Just like {@link #dontinline_sync_method(EATestCaseBaseTarget)} but without the call to\n+     * {@link EATestCaseBaseTarget#dontinline_brkpt()}.\n+     *\/\n+    public synchronized void dontinline_sync_method_no_brkpt(EATestCaseBaseTarget target) {\n+    }\n+}\n+\n+class Vector10 {\n+    int i0, i1, i2, i3, i4, i5, i6, i7, i8, i9;\n+    public Vector10(int j0, int j1, int j2, int j3, int j4, int j5, int j6, int j7, int j8, int j9) {\n+        i0=j0; i1=j1; i2=j2; i3=j3; i4=j4; i5=j5; i6=j6; i7=j7; i8=j8; i9=j9;\n+    }\n+}\n+\n+class ILFDO {\n+\n+    public int i;\n+    public int i2;\n+    public long l;\n+    public long l2;\n+    public float f;\n+    public float f2;\n+    public double d;\n+    public double d2;\n+    public Long o;\n+    public Long o2;\n+\n+    public ILFDO(int i,\n+                 int i2,\n+                 long l,\n+                 long l2,\n+                 float f,\n+                 float f2,\n+                 double d,\n+                 double d2,\n+                 Long o,\n+                 Long o2) {\n+        this.i = i;\n+        this.i2 = i2;\n+        this.l = l;\n+        this.l2 = l2;\n+        this.f = f;\n+        this.f2 = f2;\n+        this.d = d;\n+        this.d2 = d2;\n+        this.o = o;\n+        this.o2 = o2;\n+    }\n+\n+}\n","filename":"test\/jdk\/com\/sun\/jdi\/EATests.java","additions":3145,"deletions":0,"binary":false,"changes":3145,"status":"added"},{"patch":"@@ -243,0 +243,1 @@\n+  public native boolean isFrameDeoptimized(int depth);\n","filename":"test\/lib\/sun\/hotspot\/WhiteBox.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}