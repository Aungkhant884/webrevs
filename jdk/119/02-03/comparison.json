{"files":[{"patch":"@@ -53,0 +53,1 @@\n+#include \"runtime\/escapeBarrier.hpp\"\n@@ -842,1 +843,1 @@\n-        EscapeBarrier eb(this, deoptee_thread, true);\n+        EscapeBarrier eb(true, this, deoptee_thread);\n@@ -859,1 +860,1 @@\n-      EscapeBarrier eb(this, true);\n+      EscapeBarrier eb(true, this);\n","filename":"src\/hotspot\/share\/compiler\/compileBroker.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+#include \"prims\/jvmtiDeferredUpdates.hpp\"\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/checkpoint\/rootResolver.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,87 @@\n+\/*\n+ * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020 SAP SE. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"prims\/jvmtiDeferredUpdates.hpp\"\n+\n+void JvmtiDeferredUpdates::create_for(JavaThread* thread) {\n+  assert(thread->deferred_updates() == NULL, \"already allocated\");\n+  thread->set_deferred_updates(new JvmtiDeferredUpdates());\n+}\n+\n+JvmtiDeferredUpdates::~JvmtiDeferredUpdates() {\n+  while (_deferred_locals_updates.length() != 0) {\n+    jvmtiDeferredLocalVariableSet* dlv = _deferred_locals_updates.pop();\n+    \/\/ individual jvmtiDeferredLocalVariableSet are CHeapObj's\n+    delete dlv;\n+  }\n+}\n+\n+void JvmtiDeferredUpdates::inc_relock_count_after_wait(JavaThread* thread) {\n+  if (thread->deferred_updates() == NULL) {\n+    create_for(thread);\n+  }\n+  thread->deferred_updates()->inc_relock_count_after_wait();\n+}\n+\n+int JvmtiDeferredUpdates::get_and_reset_relock_count_after_wait(JavaThread* jt) {\n+  JvmtiDeferredUpdates* updates = jt->deferred_updates();\n+  int result = 0;\n+  if (updates != NULL) {\n+    result = updates->get_and_reset_relock_count_after_wait();\n+    if (updates->count() == 0) {\n+      delete updates;\n+      jt->set_deferred_updates(NULL);\n+    }\n+  }\n+  return result;\n+}\n+\n+void JvmtiDeferredUpdates::delete_updates_for_frame(JavaThread* jt, intptr_t* frame_id) {\n+  JvmtiDeferredUpdates* updates = jt->deferred_updates();\n+  if (updates != NULL) {\n+    GrowableArray<jvmtiDeferredLocalVariableSet*>* list = updates->deferred_locals();\n+    assert(list->length() > 0, \"Updates holder not deleted\");\n+    int i = 0;\n+    do {\n+      \/\/ Because of inlining we could have multiple vframes for a single frame\n+      \/\/ and several of the vframes could have deferred writes. Find them all.\n+      jvmtiDeferredLocalVariableSet* dlv = list->at(i);\n+      if (dlv->id() == frame_id) {\n+        list->remove_at(i);\n+        \/\/ individual jvmtiDeferredLocalVariableSet are CHeapObj's\n+        delete dlv;\n+      } else {\n+        i++;\n+      }\n+    } while ( i < list->length() );\n+    if (updates->count() == 0) {\n+      jt->set_deferred_updates(NULL);\n+      \/\/ Free deferred updates.\n+      \/\/ (Note the 'list' of local variable updates is embedded in 'updates')\n+      delete updates;\n+    }\n+  }\n+}\n","filename":"src\/hotspot\/share\/prims\/jvmtiDeferredUpdates.cpp","additions":87,"deletions":0,"binary":false,"changes":87,"status":"added"},{"patch":"@@ -0,0 +1,158 @@\n+\/*\n+ * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020 SAP SE. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_PRIMS_JVMTIDEFERREDUPDATES_HPP\n+#define SHARE_PRIMS_JVMTIDEFERREDUPDATES_HPP\n+\n+#include \"runtime\/thread.inline.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/growableArray.hpp\"\n+\n+\/\/ In order to implement set_locals for compiled vframes we must\n+\/\/ store updated locals in a data structure that contains enough\n+\/\/ information to recognize equality with a vframe and to store\n+\/\/ any updated locals.\n+\n+class jvmtiDeferredLocalVariable;\n+class StackValueCollection;\n+class jvmtiDeferredLocalVariableSet : public CHeapObj<mtCompiler> {\n+  friend class compiledVFrame;\n+\n+private:\n+\n+  Method* _method;\n+  int       _bci;\n+  intptr_t* _id;\n+  int _vframe_id;\n+  GrowableArray<jvmtiDeferredLocalVariable*>* _locals;\n+  bool _objects_are_deoptimized;\n+\n+  void                              update_value(StackValueCollection* locals, BasicType type, int index, jvalue value);\n+\n+  void                              set_value_at(int idx, BasicType typ, jvalue val);\n+\n+ public:\n+  \/\/ JVM state\n+  Method*                           method()         const  { return _method; }\n+  int                               bci()            const  { return _bci; }\n+  intptr_t*                         id()             const  { return _id; }\n+  int                               vframe_id()      const  { return _vframe_id; }\n+  bool                              objects_are_deoptimized() const { return _objects_are_deoptimized; }\n+\n+  void                              update_locals(StackValueCollection* locals);\n+  void                              update_stack(StackValueCollection* locals);\n+  void                              update_monitors(GrowableArray<MonitorInfo*>* monitors);\n+  void                              set_objs_are_deoptimized() { _objects_are_deoptimized = true; }\n+\n+  \/\/ Does the vframe match this jvmtiDeferredLocalVariableSet\n+  bool                              matches(const vframe* vf);\n+  \/\/ Does the underlying physical frame match this jvmtiDeferredLocalVariableSet\n+  bool                              matches(intptr_t* fr_id) { return id() == fr_id; }\n+  \/\/ GC\n+  void                              oops_do(OopClosure* f);\n+\n+  \/\/ constructor\n+  jvmtiDeferredLocalVariableSet(Method* method, int bci, intptr_t* id, int vframe_id);\n+\n+  \/\/ destructor\n+  ~jvmtiDeferredLocalVariableSet();\n+\n+\n+};\n+\n+class jvmtiDeferredLocalVariable : public CHeapObj<mtCompiler> {\n+  public:\n+\n+    jvmtiDeferredLocalVariable(int index, BasicType type, jvalue value);\n+\n+    BasicType type(void)                   { return _type; }\n+    int index(void)                        { return _index; }\n+    jvalue value(void)                     { return _value; }\n+    \/\/ Only mutator is for value as only it can change\n+    void set_value(jvalue value)           { _value = value; }\n+    \/\/ For gc\n+    oop* oop_addr(void)                    { return (oop*) &_value.l; }\n+\n+  private:\n+\n+    BasicType         _type;\n+    jvalue            _value;\n+    int               _index;\n+\n+};\n+\n+\n+\/\/ Holds updates for compiled frames by JVMTI agents that cannot be performed immediately.\n+class jvmtiDeferredLocalVariableSet;\n+class JvmtiDeferredUpdates : public CHeapObj<mtCompiler> {\n+\n+  \/\/ Relocking has to be deferred if the lock owning thread is currently waiting on the monitor.\n+  int _relock_count_after_wait;\n+\n+  \/\/ Deferred updates of locals, expressions, and monitors\n+  GrowableArray<jvmtiDeferredLocalVariableSet*> _deferred_locals_updates;\n+\n+  void inc_relock_count_after_wait() {\n+    _relock_count_after_wait++;\n+  }\n+\n+  int get_and_reset_relock_count_after_wait() {\n+    int result = _relock_count_after_wait;\n+    _relock_count_after_wait = 0;\n+    return result;\n+  }\n+\n+  GrowableArray<jvmtiDeferredLocalVariableSet*>* deferred_locals() { return &_deferred_locals_updates; }\n+\n+  JvmtiDeferredUpdates() :\n+    _relock_count_after_wait(0),\n+    _deferred_locals_updates((ResourceObj::set_allocation_type((address) &_deferred_locals_updates,\n+                              ResourceObj::C_HEAP), 1), mtCompiler) { }\n+\n+public:\n+  ~JvmtiDeferredUpdates();\n+\n+  static void create_for(JavaThread* thread);\n+\n+  static GrowableArray<jvmtiDeferredLocalVariableSet*>* deferred_locals(JavaThread* jt) {\n+    return jt->deferred_updates() == NULL ? NULL : jt->deferred_updates()->deferred_locals();\n+  }\n+\n+  \/\/ Relocking has to be deferred if the lock owning thread is currently waiting on the monitor.\n+  static int  get_and_reset_relock_count_after_wait(JavaThread* jt);\n+  static void inc_relock_count_after_wait(JavaThread* thread);\n+\n+  \/\/ Delete deferred updates for the compiled frame with id 'frame_id' on the\n+  \/\/ given thread's stack. The thread's JvmtiDeferredUpdates instance will be\n+  \/\/ deleted too if no updates remain.\n+  static void delete_updates_for_frame(JavaThread* jt, intptr_t* frame_id);\n+\n+  \/\/ Number of deferred updates\n+  int count() const {\n+    return _deferred_locals_updates.length() + (_relock_count_after_wait > 0 ? 1 : 0);\n+  }\n+};\n+\n+#endif \/\/ SHARE_PRIMS_JVMTIDEFERREDUPDATES_HPP\n","filename":"src\/hotspot\/share\/prims\/jvmtiDeferredUpdates.hpp","additions":158,"deletions":0,"binary":false,"changes":158,"status":"added"},{"patch":"@@ -1209,1 +1209,1 @@\n-  EscapeBarrier eb(calling_thread, java_thread, true);\n+  EscapeBarrier eb(true, calling_thread, java_thread);\n@@ -1259,1 +1259,1 @@\n-  EscapeBarrier eb(calling_thread, java_thread, true);\n+  EscapeBarrier eb(true, calling_thread, java_thread);\n@@ -1717,1 +1717,1 @@\n-    EscapeBarrier eb(current_thread, java_thread, !is_interpreted[0] || !is_interpreted[1]);\n+    EscapeBarrier eb(!is_interpreted[0] || !is_interpreted[1], current_thread, java_thread);\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnv.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1334,1 +1334,1 @@\n-    EscapeBarrier eb(current_thread, java_thread, true);\n+    EscapeBarrier eb(true, current_thread, java_thread);\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnvBase.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -429,1 +429,1 @@\n-  , _eb(NULL, NULL, type == T_OBJECT)\n+  , _eb(type == T_OBJECT, NULL, NULL)\n@@ -444,1 +444,1 @@\n-  , _eb(JavaThread::current(), thread, type == T_OBJECT)\n+  , _eb(type == T_OBJECT, JavaThread::current(), thread)\n@@ -458,1 +458,1 @@\n-  , _eb(calling_thread, thread, true)\n+  , _eb(true, calling_thread, thread)\n","filename":"src\/hotspot\/share\/prims\/jvmtiImpl.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-#include \"runtime\/deoptimization.hpp\"\n+#include \"runtime\/escapeBarrier.hpp\"\n","filename":"src\/hotspot\/share\/prims\/jvmtiImpl.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1491,2 +1491,3 @@\n-  EscapeBarrier eb(JavaThread::current(),\n-      object_filter == JVMTI_HEAP_OBJECT_UNTAGGED || object_filter == JVMTI_HEAP_OBJECT_EITHER);\n+  EscapeBarrier eb(object_filter == JVMTI_HEAP_OBJECT_UNTAGGED ||\n+                   object_filter == JVMTI_HEAP_OBJECT_EITHER,\n+                   JavaThread::current());\n@@ -1512,1 +1513,1 @@\n-  EscapeBarrier eb(JavaThread::current(), !(heap_filter & JVMTI_HEAP_FILTER_UNTAGGED));\n+  EscapeBarrier eb(!(heap_filter & JVMTI_HEAP_FILTER_UNTAGGED), JavaThread::current());\n@@ -3262,1 +3263,1 @@\n-  EscapeBarrier eb(jt, true);\n+  EscapeBarrier eb(true, jt);\n@@ -3294,2 +3295,3 @@\n-  EscapeBarrier eb(jt,\n-      initial_object.is_null() && !(heap_filter & JVMTI_HEAP_FILTER_UNTAGGED));\n+  EscapeBarrier eb(initial_object.is_null() &&\n+                   !(heap_filter & JVMTI_HEAP_FILTER_UNTAGGED),\n+                   jt);\n","filename":"src\/hotspot\/share\/prims\/jvmtiTagMap.cpp","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -51,0 +51,1 @@\n+#include \"prims\/jvmtiDeferredUpdates.hpp\"\n@@ -55,0 +56,1 @@\n+#include \"runtime\/escapeBarrier.hpp\"\n@@ -413,23 +415,1 @@\n-  if (JvmtiDeferredUpdates::deferred_locals(thread) != NULL) {\n-    GrowableArray<jvmtiDeferredLocalVariableSet*>* list = JvmtiDeferredUpdates::deferred_locals(thread);\n-    int i = 0;\n-    do {\n-      \/\/ Because of inlining we could have multiple vframes for a single frame\n-      \/\/ and several of the vframes could have deferred writes. Find them all.\n-      if (list->at(i)->id() == array->original().id()) {\n-        jvmtiDeferredLocalVariableSet* dlv = list->at(i);\n-        list->remove_at(i);\n-        \/\/ individual jvmtiDeferredLocalVariableSet are CHeapObj's\n-        delete dlv;\n-      } else {\n-        i++;\n-      }\n-    } while ( i < list->length() );\n-    if (list->length() == 0) {\n-      JvmtiDeferredUpdates* updates = thread->deferred_updates();\n-      thread->set_deferred_updates(NULL);\n-      \/\/ free deferred updates.\n-      delete updates;\n-    }\n-\n-  }\n+  JvmtiDeferredUpdates::delete_updates_for_frame(thread, array->original().id());\n@@ -2718,339 +2698,0 @@\n-\/\/ Returns true iff objects were reallocated and relocked because of access through JVMTI\n-bool EscapeBarrier::objs_are_deoptimized(JavaThread* thread, intptr_t* fr_id) {\n-  \/\/ first\/oldest update holds the flag\n-  GrowableArray<jvmtiDeferredLocalVariableSet*>* list = JvmtiDeferredUpdates::deferred_locals(thread);\n-  bool result = false;\n-  if (list != NULL) {\n-    for (int i = 0; i < list->length(); i++) {\n-      if (list->at(i)->matches(fr_id)) {\n-        result = list->at(i)->objects_are_deoptimized();\n-        break;\n-      }\n-    }\n-  }\n-  return result;\n-}\n-\n-\/\/ Object references of frames up to the given depth are about to be\n-\/\/ accessed. Frames with optimizations based on escape state that is potentially\n-\/\/ changed by the accesses need to be deoptimized and the referenced objects\n-\/\/ need to be reallocated and relocked.  Up to depth this is done for frames\n-\/\/ with not escaping objects in scope. For deeper frames it is done only if\n-\/\/ they pass not escaping objects as arguments because they potentially escape\n-\/\/ from callee frames within the given depth.\n-\/\/ The search for deeper frames is ended if an entry frame is found because\n-\/\/ arguments to native methods are considered to escape globally.\n-bool EscapeBarrier::deoptimize_objects(int depth) {\n-  if (barrier_active() && deoptee_thread()->has_last_Java_frame()) {\n-    assert(calling_thread() == Thread::current(), \"should be\");\n-    ResourceMark rm(calling_thread());\n-    HandleMark   hm(calling_thread());\n-    RegisterMap  reg_map(deoptee_thread());\n-    vframe* vf = deoptee_thread()->last_java_vframe(&reg_map);\n-    int cur_depth = 0;\n-    while (vf != NULL && ((cur_depth <= depth) || !vf->is_entry_frame())) {\n-      if (vf->is_compiled_frame()) {\n-        compiledVFrame* cvf = compiledVFrame::cast(vf);\n-        \/\/ Deoptimize frame and local objects if any exist.\n-        \/\/ If cvf is deeper than depth, then we deoptimize iff local objects are passed as args.\n-        bool should_deopt = cur_depth <= depth ? cvf->has_ea_local_in_scope() : cvf->arg_escape();\n-        if (should_deopt && !deoptimize_objects(cvf->fr().id())) {\n-          \/\/ reallocation of scalar replaced objects failed because heap is exhausted\n-          return false;\n-        }\n-\n-        \/\/ move to top frame\n-        while(!vf->is_top()) {\n-          cur_depth++;\n-          vf = vf->sender();\n-        }\n-      }\n-\n-      \/\/ move to next physical frame\n-      cur_depth++;\n-      vf = vf->sender();\n-    }\n-  }\n-  return true;\n-}\n-\n-bool EscapeBarrier::deoptimize_objects_all_threads() {\n-  if (!barrier_active()) return true;\n-  ResourceMark rm(calling_thread());\n-  for (JavaThreadIteratorWithHandle jtiwh; JavaThread *jt = jtiwh.next(); ) {\n-    if (jt->has_last_Java_frame()) {\n-      RegisterMap reg_map(jt);\n-      vframe* vf = jt->last_java_vframe(&reg_map);\n-      assert(jt->frame_anchor()->walkable(),\n-             \"The stack of JavaThread \" PTR_FORMAT \" is not walkable. Thread state is %d\",\n-             p2i(jt), jt->thread_state());\n-      while (vf != NULL) {\n-        if (vf->is_compiled_frame()) {\n-          compiledVFrame* cvf = compiledVFrame::cast(vf);\n-          if ((cvf->has_ea_local_in_scope() || cvf->arg_escape()) &&\n-              !deoptimize_objects_internal(jt, cvf->fr().id())) {\n-            return false; \/\/ reallocation failure\n-          }\n-          \/\/ move to top frame\n-          while(!vf->is_top()) {\n-            vf = vf->sender();\n-          }\n-        }\n-        \/\/ move to next physical frame\n-        vf = vf->sender();\n-      }\n-    }\n-  }\n-  return true; \/\/ success\n-}\n-\n-bool EscapeBarrier::_deoptimizing_objects_for_all_threads = false;\n-bool EscapeBarrier::_self_deoptimization_in_progress      = false;\n-\n-class EscapeBarrierSuspendHandshake : public HandshakeClosure {\n- public:\n-  EscapeBarrierSuspendHandshake(JavaThread* excluded_thread, const char* name) :\n-    HandshakeClosure(name) { }\n-  void do_thread(Thread* th) { }\n-};\n-\n-void EscapeBarrier::sync_and_suspend_one() {\n-  assert(_calling_thread != NULL, \"calling thread must not be NULL\");\n-  assert(_deoptee_thread != NULL, \"deoptee thread must not be NULL\");\n-  assert(barrier_active(), \"should not call\");\n-\n-  \/\/ Sync with other threads that might be doing deoptimizations\n-  {\n-    \/\/ Need to switch to _thread_blocked for the wait() call\n-    ThreadBlockInVM tbivm(_calling_thread);\n-    MonitorLocker ml(_calling_thread, EscapeBarrier_lock, Mutex::_no_safepoint_check_flag);\n-    while (_self_deoptimization_in_progress || _deoptee_thread->is_obj_deopt_suspend()) {\n-      ml.wait();\n-    }\n-\n-    if (self_deopt()) {\n-      _self_deoptimization_in_progress = true;\n-      return;\n-    }\n-\n-    \/\/ set suspend flag for target thread\n-    _deoptee_thread->set_obj_deopt_flag();\n-  }\n-\n-  \/\/ Use a handshake to synchronize with the target thread.\n-  EscapeBarrierSuspendHandshake sh(NULL, \"EscapeBarrierSuspendOne\");\n-  Handshake::execute_direct(&sh, _deoptee_thread);\n-  assert(!_deoptee_thread->has_last_Java_frame() || _deoptee_thread->frame_anchor()->walkable(),\n-         \"stack should be walkable now\");\n-}\n-\n-void EscapeBarrier::sync_and_suspend_all() {\n-  assert(barrier_active(), \"should not call\");\n-  assert(_calling_thread != NULL, \"calling thread must not be NULL\");\n-  assert(all_threads(), \"sanity\");\n-\n-  \/\/ Sync with other threads that might be doing deoptimizations\n-  {\n-    \/\/ Need to switch to _thread_blocked for the wait() call\n-    ThreadBlockInVM tbivm(_calling_thread);\n-    MonitorLocker ml(_calling_thread, EscapeBarrier_lock, Mutex::_no_safepoint_check_flag);\n-\n-    bool deopt_in_progress;\n-    do {\n-      deopt_in_progress = _self_deoptimization_in_progress;\n-      for (JavaThreadIteratorWithHandle jtiwh; JavaThread *jt = jtiwh.next(); ) {\n-        deopt_in_progress = (deopt_in_progress || jt->is_obj_deopt_suspend());\n-        if (deopt_in_progress) {\n-          break;\n-        }\n-      }\n-      if (deopt_in_progress) {\n-        ml.wait(); \/\/ then check again\n-      }\n-    } while(deopt_in_progress);\n-\n-    _self_deoptimization_in_progress = true;\n-    _deoptimizing_objects_for_all_threads = true;\n-\n-    \/\/ We set the suspend flags before executing the handshake because then the\n-    \/\/ setting will be visible after leaving the _thread_blocked state in\n-    \/\/ JavaThread::wait_for_object_deoptimization(). If we set the flags in the\n-    \/\/ handshake then the read must happen after the safepoint\/handshake poll.\n-    for (JavaThreadIteratorWithHandle jtiwh; JavaThread *jt = jtiwh.next(); ) {\n-      if (jt->is_Java_thread() && !jt->is_hidden_from_external_view() && (jt != _calling_thread)) {\n-        jt->set_obj_deopt_flag();\n-      }\n-    }\n-  }\n-\n-  \/\/ Use a handshake to synchronize with the other threads.\n-  EscapeBarrierSuspendHandshake sh(_calling_thread, \"EscapeBarrierSuspendAll\");\n-  Handshake::execute(&sh);\n-#ifdef ASSERT\n-  for (JavaThreadIteratorWithHandle jtiwh; JavaThread *jt = jtiwh.next(); ) {\n-    if (jt->is_hidden_from_external_view()) continue;\n-    assert(!jt->has_last_Java_frame() || jt->frame_anchor()->walkable(),\n-           \"The stack of JavaThread \" PTR_FORMAT \" is not walkable. Thread state is %d\",\n-           p2i(jt), jt->thread_state());\n-  }\n-#endif \/\/ ASSERT\n-}\n-\n-void EscapeBarrier::resume_one() {\n-  assert(barrier_active(), \"should not call\");\n-  assert(!all_threads(), \"use resume_all()\");\n-  MonitorLocker ml(_calling_thread, EscapeBarrier_lock, Mutex::_no_safepoint_check_flag);\n-  if (self_deopt()) {\n-    assert(_self_deoptimization_in_progress, \"incorrect synchronization\");\n-    _self_deoptimization_in_progress = false;\n-  } else {\n-    _deoptee_thread->clear_obj_deopt_flag();\n-  }\n-  ml.notify_all();\n-}\n-\n-void EscapeBarrier::resume_all() {\n-  assert(barrier_active(), \"should not call\");\n-  assert(all_threads(), \"use resume_one()\");\n-  MonitorLocker ml(_calling_thread, EscapeBarrier_lock, Mutex::_no_safepoint_check_flag);\n-  assert(_self_deoptimization_in_progress, \"incorrect synchronization\");\n-  _deoptimizing_objects_for_all_threads = false;\n-  _self_deoptimization_in_progress = false;\n-  for (JavaThreadIteratorWithHandle jtiwh; JavaThread *jt = jtiwh.next(); ) {\n-    jt->clear_obj_deopt_flag();\n-  }\n-  ml.notify_all();\n-}\n-\n-void EscapeBarrier::thread_added(JavaThread* jt) {\n-  if (!jt->is_hidden_from_external_view()) {\n-    MutexLocker ml(EscapeBarrier_lock, Mutex::_no_safepoint_check_flag);\n-    if (_deoptimizing_objects_for_all_threads) {\n-      jt->set_obj_deopt_flag();\n-    }\n-  }\n-}\n-\n-void EscapeBarrier::thread_removed(JavaThread* jt) {\n-  MonitorLocker ml(EscapeBarrier_lock, Mutex::_no_safepoint_check_flag);\n-  if (jt->is_obj_deopt_suspend()) {\n-    \/\/ jt terminated before it self suspended.\n-    \/\/ Other threads might be waiting to perform deoptimizations for it.\n-    jt->clear_obj_deopt_flag();\n-    ml.notify_all();\n-  }\n-}\n-\n-\/\/ Remember that objects were reallocated and relocked for the compiled frame with the given id\n-static void set_objs_are_deoptimized(JavaThread* thread, intptr_t* fr_id) {\n-  \/\/ set in first\/oldest update\n-  GrowableArray<jvmtiDeferredLocalVariableSet*>* list =\n-    JvmtiDeferredUpdates::deferred_locals(thread);\n-  DEBUG_ONLY(bool found = false);\n-  if (list != NULL) {\n-    for (int i = 0; i < list->length(); i++) {\n-      if (list->at(i)->matches(fr_id)) {\n-        DEBUG_ONLY(found = true);\n-        list->at(i)->set_objs_are_deoptimized();\n-        break;\n-      }\n-    }\n-  }\n-  assert(found, \"variable set should exist at least for one vframe\");\n-}\n-\n-\/\/ Deoptimize the given frame and deoptimize objects with optimizations based on\n-\/\/ escape analysis, i.e. reallocate scalar replaced objects on the heap and\n-\/\/ relock objects if locking has been eliminated.\n-\/\/ Deoptimized objects are kept as JVMTI deferred updates until the compiled\n-\/\/ frame is replaced with interpreter frames.  Returns false iff at least one\n-\/\/ reallocation failed.\n-bool EscapeBarrier::deoptimize_objects_internal(JavaThread* deoptee, intptr_t* fr_id) {\n-  if (!barrier_active()) return true;\n-\n-  JavaThread* ct = calling_thread();\n-  bool realloc_failures = false;\n-\n-  if (!objs_are_deoptimized(deoptee, fr_id)) {\n-    \/\/ Make sure the frame identified by fr_id is deoptimized and fetch its last vframe\n-    compiledVFrame* last_cvf;\n-    bool fr_is_deoptimized;\n-    do {\n-      StackFrameStream fst(deoptee);\n-      while (fst.current()->id() != fr_id && !fst.is_done()) {\n-        fst.next();\n-      }\n-      assert(fst.current()->id() == fr_id, \"frame not found\");\n-      assert(fst.current()->is_compiled_frame(),\n-             \"only compiled frames can contain stack allocated objects\");\n-      fr_is_deoptimized = fst.current()->is_deoptimized_frame();\n-      if (!fr_is_deoptimized) {\n-        \/\/ Execution must not continue in the compiled method, so we deoptimize the frame.\n-        Deoptimization::deoptimize_frame(deoptee, fr_id);\n-      } else {\n-        last_cvf = compiledVFrame::cast(vframe::new_vframe(fst.current(), fst.register_map(), deoptee));\n-      }\n-    } while(!fr_is_deoptimized);\n-\n-    \/\/ collect inlined frames\n-    compiledVFrame* cvf = last_cvf;\n-    GrowableArray<compiledVFrame*>* vfs = new GrowableArray<compiledVFrame*>(10);\n-    while (!cvf->is_top()) {\n-      vfs->push(cvf);\n-      cvf = compiledVFrame::cast(cvf->sender());\n-    }\n-    vfs->push(cvf);\n-\n-    \/\/ reallocate and relock optimized objects\n-    bool deoptimized_objects = Deoptimization::deoptimize_objects_internal(ct, vfs, realloc_failures);\n-    if (!realloc_failures && deoptimized_objects) {\n-      \/\/ now do the updates\n-      for (int frame_index = 0; frame_index < vfs->length(); frame_index++) {\n-        cvf = vfs->at(frame_index);\n-\n-        \/\/ locals\n-        GrowableArray<ScopeValue*>* scopeLocals = cvf->scope()->locals();\n-        StackValueCollection* locals = cvf->locals();\n-        if (locals != NULL) {\n-          for (int i2 = 0; i2 < locals->size(); i2++) {\n-            StackValue* var = locals->at(i2);\n-            if (var->type() == T_OBJECT && scopeLocals->at(i2)->is_object()) {\n-              jvalue val;\n-              val.l = cast_from_oop<jobject>(locals->at(i2)->get_obj()());\n-              cvf->update_local(T_OBJECT, i2, val);\n-            }\n-          }\n-        }\n-\n-        \/\/ expressions\n-        GrowableArray<ScopeValue*>* scopeExpressions = cvf->scope()->expressions();\n-        StackValueCollection* expressions = cvf->expressions();\n-        if (expressions != NULL) {\n-          for (int i2 = 0; i2 < expressions->size(); i2++) {\n-            StackValue* var = expressions->at(i2);\n-            if (var->type() == T_OBJECT && scopeExpressions->at(i2)->is_object()) {\n-              jvalue val;\n-              val.l = cast_from_oop<jobject>(expressions->at(i2)->get_obj()());\n-              cvf->update_stack(T_OBJECT, i2, val);\n-            }\n-          }\n-        }\n-\n-        \/\/ monitors\n-        GrowableArray<MonitorInfo*>* monitors = cvf->monitors();\n-        if (monitors != NULL) {\n-          for (int i2 = 0; i2 < monitors->length(); i2++) {\n-            if (monitors->at(i2)->eliminated()) {\n-              assert(!monitors->at(i2)->owner_is_scalar_replaced(),\n-                     \"reallocation failure, should not update\");\n-              cvf->update_monitor(i2, monitors->at(i2));\n-            }\n-          }\n-        }\n-      }\n-      set_objs_are_deoptimized(deoptee, fr_id);\n-    }\n-  }\n-  return !realloc_failures;\n-}\n-\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":3,"deletions":362,"binary":false,"changes":365,"status":"modified"},{"patch":"@@ -39,1 +39,0 @@\n-class EscapeBarrier;\n@@ -480,92 +479,0 @@\n-\/\/ EscapeBarriers should be put on execution paths where JVMTI agents can access object\n-\/\/ references held by java threads.\n-\/\/ They provide means to revert optimizations based on escape analysis in a well synchronized manner\n-\/\/ just before local references escape through JVMTI.\n-class EscapeBarrier : StackObj {\n-#if COMPILER2_OR_JVMCI\n-  JavaThread* const _calling_thread;\n-  JavaThread* const _deoptee_thread;\n-  bool        const _barrier_active;\n-\n-  static bool _deoptimizing_objects_for_all_threads;\n-  static bool _self_deoptimization_in_progress;\n-\n-  \/\/ Suspending is necessary because the target thread's stack must be walked and\n-  \/\/ object reallocation is not possible in a handshake or at a safepoint.\n-  \/\/ Suspending is based on handshakes. It is sufficient if the target thread(s)\n-  \/\/ cannot return to executing bytecodes. Acquiring a lock is ok. Leaving a\n-  \/\/ safepoint\/handshake safe state is not ok.\n-  \/\/ See also JavaThread::wait_for_object_deoptimization().\n-  void sync_and_suspend_one();\n-  void sync_and_suspend_all();\n-  void resume_one();\n-  void resume_all();\n-\n-  \/\/ Deoptimize the given frame and deoptimize objects with optimizations based on escape analysis.\n-  bool deoptimize_objects_internal(JavaThread* deoptee, intptr_t* fr_id);\n-\n-public:\n-  \/\/ Revert ea based optimizations for given deoptee thread\n-  EscapeBarrier(JavaThread* calling_thread, JavaThread* deoptee_thread, bool barrier_active)\n-    : _calling_thread(calling_thread), _deoptee_thread(deoptee_thread),\n-      _barrier_active(barrier_active && (JVMCI_ONLY(UseJVMCICompiler) NOT_JVMCI(false)\n-                      COMPILER2_PRESENT(|| DoEscapeAnalysis)))\n-  {\n-    if (_barrier_active) sync_and_suspend_one();\n-  }\n-\n-  \/\/ Revert ea based optimizations for all java threads\n-  EscapeBarrier(JavaThread* calling_thread, bool barrier_active)\n-    : _calling_thread(calling_thread), _deoptee_thread(NULL),\n-      _barrier_active(barrier_active && (JVMCI_ONLY(UseJVMCICompiler) NOT_JVMCI(false)\n-                      COMPILER2_PRESENT(|| DoEscapeAnalysis)))\n-  {\n-    if (_barrier_active) sync_and_suspend_all();\n-  }\n-#else\n-public:\n-  EscapeBarrier(JavaThread* calling_thread, JavaThread* deoptee_thread, bool barrier_active) { }\n-  EscapeBarrier(JavaThread* calling_thread, bool barrier_active) { }\n-  static bool deoptimizing_objects_for_all_threads() { return false; }\n-  bool barrier_active() const                        { return false; }\n-#endif \/\/ COMPILER2_OR_JVMCI\n-\n-  \/\/ Deoptimize objects, i.e. reallocate and relock them. The target frames are deoptimized.\n-  \/\/ The methods return false iff at least one reallocation failed.\n-  bool deoptimize_objects(intptr_t* fr_id) {\n-    return true COMPILER2_OR_JVMCI_PRESENT(&& deoptimize_objects_internal(deoptee_thread(), fr_id));\n-  }\n-  bool deoptimize_objects(int depth)                           NOT_COMPILER2_OR_JVMCI_RETURN_(true);\n-  \/\/ Find and deoptimize non escaping objects and the holding frames on all stacks.\n-  bool deoptimize_objects_all_threads()                        NOT_COMPILER2_OR_JVMCI_RETURN_(true);\n-\n-  \/\/ A java thread was added to the list of threads\n-  static void thread_added(JavaThread* jt)                     NOT_COMPILER2_OR_JVMCI_RETURN;\n-  \/\/ A java thread was removed from the list of threads\n-  static void thread_removed(JavaThread* jt)                   NOT_COMPILER2_OR_JVMCI_RETURN;\n-\n-#if COMPILER2_OR_JVMCI\n-  \/\/ Returns true iff objects were reallocated and relocked because of access through JVMTI\n-  static bool objs_are_deoptimized(JavaThread* thread, intptr_t* fr_id);\n-\n-  static bool deoptimizing_objects_for_all_threads() { return _deoptimizing_objects_for_all_threads; }\n-\n-  ~EscapeBarrier() {\n-    if (!barrier_active()) return;\n-    if (all_threads()) {\n-      resume_all();\n-    } else {\n-      resume_one();\n-    }\n-  }\n-\n-\n-  bool all_threads()    const { return _deoptee_thread == NULL; }            \/\/ Should revert optimizations for all threads.\n-  bool self_deopt()     const { return _calling_thread == _deoptee_thread; } \/\/ Current thread deoptimizes its own objects.\n-  bool barrier_active() const { return _barrier_active; }                    \/\/ Inactive barriers are created if no local objects can escape.\n-\n-  \/\/ accessors\n-  JavaThread* calling_thread() const     { return _calling_thread; }\n-  JavaThread* deoptee_thread() const     { return _deoptee_thread; }\n-#endif \/\/ COMPILER2_OR_JVMCI\n-};\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.hpp","additions":0,"deletions":93,"binary":false,"changes":93,"status":"modified"},{"patch":"@@ -0,0 +1,390 @@\n+\/*\n+ * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020 SAP SE. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"code\/scopeDesc.hpp\"\n+#include \"memory\/allocation.hpp\"\n+#include \"prims\/jvmtiDeferredUpdates.hpp\"\n+#include \"runtime\/deoptimization.hpp\"\n+#include \"runtime\/escapeBarrier.hpp\"\n+#include \"runtime\/frame.inline.hpp\"\n+#include \"runtime\/handles.hpp\"\n+#include \"runtime\/handshake.hpp\"\n+#include \"runtime\/interfaceSupport.inline.hpp\"\n+#include \"runtime\/mutexLocker.hpp\"\n+#include \"runtime\/registerMap.hpp\"\n+#include \"runtime\/stackValue.hpp\"\n+#include \"runtime\/stackValueCollection.hpp\"\n+#include \"runtime\/threadSMR.hpp\"\n+#include \"runtime\/vframe.hpp\"\n+#include \"runtime\/vframe_hp.hpp\"\n+#include \"utilities\/debug.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/macros.hpp\"\n+\n+#if COMPILER2_OR_JVMCI\n+\n+class jvmtiDeferredLocalVariableSet;\n+\n+\/\/ Returns true iff objects were reallocated and relocked because of access through JVMTI\n+bool EscapeBarrier::objs_are_deoptimized(JavaThread* thread, intptr_t* fr_id) {\n+  \/\/ first\/oldest update holds the flag\n+  GrowableArray<jvmtiDeferredLocalVariableSet*>* list = JvmtiDeferredUpdates::deferred_locals(thread);\n+  bool result = false;\n+  if (list != NULL) {\n+    for (int i = 0; i < list->length(); i++) {\n+      if (list->at(i)->matches(fr_id)) {\n+        result = list->at(i)->objects_are_deoptimized();\n+        break;\n+      }\n+    }\n+  }\n+  return result;\n+}\n+\n+\/\/ Object references of frames up to the given depth are about to be\n+\/\/ accessed. Frames with optimizations based on escape state that is potentially\n+\/\/ changed by the accesses need to be deoptimized and the referenced objects\n+\/\/ need to be reallocated and relocked.  Up to depth this is done for frames\n+\/\/ with not escaping objects in scope. For deeper frames it is done only if\n+\/\/ they pass not escaping objects as arguments because they potentially escape\n+\/\/ from callee frames within the given depth.\n+\/\/ The search for deeper frames is ended if an entry frame is found because\n+\/\/ arguments to native methods are considered to escape globally.\n+bool EscapeBarrier::deoptimize_objects(int depth) {\n+  if (barrier_active() && deoptee_thread()->has_last_Java_frame()) {\n+    assert(calling_thread() == Thread::current(), \"should be\");\n+    ResourceMark rm(calling_thread());\n+    HandleMark   hm(calling_thread());\n+    RegisterMap  reg_map(deoptee_thread());\n+    vframe* vf = deoptee_thread()->last_java_vframe(&reg_map);\n+    int cur_depth = 0;\n+    while (vf != NULL && ((cur_depth <= depth) || !vf->is_entry_frame())) {\n+      if (vf->is_compiled_frame()) {\n+        compiledVFrame* cvf = compiledVFrame::cast(vf);\n+        \/\/ Deoptimize frame and local objects if any exist.\n+        \/\/ If cvf is deeper than depth, then we deoptimize iff local objects are passed as args.\n+        bool should_deopt = cur_depth <= depth ? cvf->has_ea_local_in_scope() : cvf->arg_escape();\n+        if (should_deopt && !deoptimize_objects(cvf->fr().id())) {\n+          \/\/ reallocation of scalar replaced objects failed because heap is exhausted\n+          return false;\n+        }\n+\n+        \/\/ move to top frame\n+        while(!vf->is_top()) {\n+          cur_depth++;\n+          vf = vf->sender();\n+        }\n+      }\n+\n+      \/\/ move to next physical frame\n+      cur_depth++;\n+      vf = vf->sender();\n+    }\n+  }\n+  return true;\n+}\n+\n+bool EscapeBarrier::deoptimize_objects_all_threads() {\n+  if (!barrier_active()) return true;\n+  ResourceMark rm(calling_thread());\n+  for (JavaThreadIteratorWithHandle jtiwh; JavaThread *jt = jtiwh.next(); ) {\n+    if (jt->has_last_Java_frame()) {\n+      RegisterMap reg_map(jt);\n+      vframe* vf = jt->last_java_vframe(&reg_map);\n+      assert(jt->frame_anchor()->walkable(),\n+             \"The stack of JavaThread \" PTR_FORMAT \" is not walkable. Thread state is %d\",\n+             p2i(jt), jt->thread_state());\n+      while (vf != NULL) {\n+        if (vf->is_compiled_frame()) {\n+          compiledVFrame* cvf = compiledVFrame::cast(vf);\n+          if ((cvf->has_ea_local_in_scope() || cvf->arg_escape()) &&\n+              !deoptimize_objects_internal(jt, cvf->fr().id())) {\n+            return false; \/\/ reallocation failure\n+          }\n+          \/\/ move to top frame\n+          while(!vf->is_top()) {\n+            vf = vf->sender();\n+          }\n+        }\n+        \/\/ move to next physical frame\n+        vf = vf->sender();\n+      }\n+    }\n+  }\n+  return true; \/\/ success\n+}\n+\n+bool EscapeBarrier::_deoptimizing_objects_for_all_threads = false;\n+bool EscapeBarrier::_self_deoptimization_in_progress      = false;\n+\n+class EscapeBarrierSuspendHandshake : public HandshakeClosure {\n+ public:\n+  EscapeBarrierSuspendHandshake(JavaThread* excluded_thread, const char* name) :\n+    HandshakeClosure(name) { }\n+  void do_thread(Thread* th) { }\n+};\n+\n+void EscapeBarrier::sync_and_suspend_one() {\n+  assert(_calling_thread != NULL, \"calling thread must not be NULL\");\n+  assert(_deoptee_thread != NULL, \"deoptee thread must not be NULL\");\n+  assert(barrier_active(), \"should not call\");\n+\n+  \/\/ Sync with other threads that might be doing deoptimizations\n+  {\n+    \/\/ Need to switch to _thread_blocked for the wait() call\n+    ThreadBlockInVM tbivm(_calling_thread);\n+    MonitorLocker ml(_calling_thread, EscapeBarrier_lock, Mutex::_no_safepoint_check_flag);\n+    while (_self_deoptimization_in_progress || _deoptee_thread->is_obj_deopt_suspend()) {\n+      ml.wait();\n+    }\n+\n+    if (self_deopt()) {\n+      _self_deoptimization_in_progress = true;\n+      return;\n+    }\n+\n+    \/\/ set suspend flag for target thread\n+    _deoptee_thread->set_obj_deopt_flag();\n+  }\n+\n+  \/\/ Use a handshake to synchronize with the target thread.\n+  EscapeBarrierSuspendHandshake sh(NULL, \"EscapeBarrierSuspendOne\");\n+  Handshake::execute_direct(&sh, _deoptee_thread);\n+  assert(!_deoptee_thread->has_last_Java_frame() || _deoptee_thread->frame_anchor()->walkable(),\n+         \"stack should be walkable now\");\n+}\n+\n+void EscapeBarrier::sync_and_suspend_all() {\n+  assert(barrier_active(), \"should not call\");\n+  assert(_calling_thread != NULL, \"calling thread must not be NULL\");\n+  assert(all_threads(), \"sanity\");\n+\n+  \/\/ Sync with other threads that might be doing deoptimizations\n+  {\n+    \/\/ Need to switch to _thread_blocked for the wait() call\n+    ThreadBlockInVM tbivm(_calling_thread);\n+    MonitorLocker ml(_calling_thread, EscapeBarrier_lock, Mutex::_no_safepoint_check_flag);\n+\n+    bool deopt_in_progress;\n+    do {\n+      deopt_in_progress = _self_deoptimization_in_progress;\n+      for (JavaThreadIteratorWithHandle jtiwh; JavaThread *jt = jtiwh.next(); ) {\n+        deopt_in_progress = (deopt_in_progress || jt->is_obj_deopt_suspend());\n+        if (deopt_in_progress) {\n+          break;\n+        }\n+      }\n+      if (deopt_in_progress) {\n+        ml.wait(); \/\/ then check again\n+      }\n+    } while(deopt_in_progress);\n+\n+    _self_deoptimization_in_progress = true;\n+    _deoptimizing_objects_for_all_threads = true;\n+\n+    \/\/ We set the suspend flags before executing the handshake because then the\n+    \/\/ setting will be visible after leaving the _thread_blocked state in\n+    \/\/ JavaThread::wait_for_object_deoptimization(). If we set the flags in the\n+    \/\/ handshake then the read must happen after the safepoint\/handshake poll.\n+    for (JavaThreadIteratorWithHandle jtiwh; JavaThread *jt = jtiwh.next(); ) {\n+      if (jt->is_Java_thread() && !jt->is_hidden_from_external_view() && (jt != _calling_thread)) {\n+        jt->set_obj_deopt_flag();\n+      }\n+    }\n+  }\n+\n+  \/\/ Use a handshake to synchronize with the other threads.\n+  EscapeBarrierSuspendHandshake sh(_calling_thread, \"EscapeBarrierSuspendAll\");\n+  Handshake::execute(&sh);\n+#ifdef ASSERT\n+  for (JavaThreadIteratorWithHandle jtiwh; JavaThread *jt = jtiwh.next(); ) {\n+    if (jt->is_hidden_from_external_view()) continue;\n+    assert(!jt->has_last_Java_frame() || jt->frame_anchor()->walkable(),\n+           \"The stack of JavaThread \" PTR_FORMAT \" is not walkable. Thread state is %d\",\n+           p2i(jt), jt->thread_state());\n+  }\n+#endif \/\/ ASSERT\n+}\n+\n+void EscapeBarrier::resume_one() {\n+  assert(barrier_active(), \"should not call\");\n+  assert(!all_threads(), \"use resume_all()\");\n+  MonitorLocker ml(_calling_thread, EscapeBarrier_lock, Mutex::_no_safepoint_check_flag);\n+  if (self_deopt()) {\n+    assert(_self_deoptimization_in_progress, \"incorrect synchronization\");\n+    _self_deoptimization_in_progress = false;\n+  } else {\n+    _deoptee_thread->clear_obj_deopt_flag();\n+  }\n+  ml.notify_all();\n+}\n+\n+void EscapeBarrier::resume_all() {\n+  assert(barrier_active(), \"should not call\");\n+  assert(all_threads(), \"use resume_one()\");\n+  MonitorLocker ml(_calling_thread, EscapeBarrier_lock, Mutex::_no_safepoint_check_flag);\n+  assert(_self_deoptimization_in_progress, \"incorrect synchronization\");\n+  _deoptimizing_objects_for_all_threads = false;\n+  _self_deoptimization_in_progress = false;\n+  for (JavaThreadIteratorWithHandle jtiwh; JavaThread *jt = jtiwh.next(); ) {\n+    jt->clear_obj_deopt_flag();\n+  }\n+  ml.notify_all();\n+}\n+\n+void EscapeBarrier::thread_added(JavaThread* jt) {\n+  if (!jt->is_hidden_from_external_view()) {\n+    MutexLocker ml(EscapeBarrier_lock, Mutex::_no_safepoint_check_flag);\n+    if (_deoptimizing_objects_for_all_threads) {\n+      jt->set_obj_deopt_flag();\n+    }\n+  }\n+}\n+\n+void EscapeBarrier::thread_removed(JavaThread* jt) {\n+  MonitorLocker ml(EscapeBarrier_lock, Mutex::_no_safepoint_check_flag);\n+  if (jt->is_obj_deopt_suspend()) {\n+    \/\/ jt terminated before it self suspended.\n+    \/\/ Other threads might be waiting to perform deoptimizations for it.\n+    jt->clear_obj_deopt_flag();\n+    ml.notify_all();\n+  }\n+}\n+\n+\/\/ Remember that objects were reallocated and relocked for the compiled frame with the given id\n+static void set_objs_are_deoptimized(JavaThread* thread, intptr_t* fr_id) {\n+  \/\/ set in first\/oldest update\n+  GrowableArray<jvmtiDeferredLocalVariableSet*>* list =\n+    JvmtiDeferredUpdates::deferred_locals(thread);\n+  DEBUG_ONLY(bool found = false);\n+  if (list != NULL) {\n+    for (int i = 0; i < list->length(); i++) {\n+      if (list->at(i)->matches(fr_id)) {\n+        DEBUG_ONLY(found = true);\n+        list->at(i)->set_objs_are_deoptimized();\n+        break;\n+      }\n+    }\n+  }\n+  assert(found, \"variable set should exist at least for one vframe\");\n+}\n+\n+\/\/ Deoptimize the given frame and deoptimize objects with optimizations based on\n+\/\/ escape analysis, i.e. reallocate scalar replaced objects on the heap and\n+\/\/ relock objects if locking has been eliminated.\n+\/\/ Deoptimized objects are kept as JVMTI deferred updates until the compiled\n+\/\/ frame is replaced with interpreter frames.  Returns false iff at least one\n+\/\/ reallocation failed.\n+bool EscapeBarrier::deoptimize_objects_internal(JavaThread* deoptee, intptr_t* fr_id) {\n+  if (!barrier_active()) return true;\n+\n+  JavaThread* ct = calling_thread();\n+  bool realloc_failures = false;\n+\n+  if (!objs_are_deoptimized(deoptee, fr_id)) {\n+    \/\/ Make sure the frame identified by fr_id is deoptimized and fetch its last vframe\n+    compiledVFrame* last_cvf;\n+    bool fr_is_deoptimized;\n+    do {\n+      StackFrameStream fst(deoptee);\n+      while (fst.current()->id() != fr_id && !fst.is_done()) {\n+        fst.next();\n+      }\n+      assert(fst.current()->id() == fr_id, \"frame not found\");\n+      assert(fst.current()->is_compiled_frame(),\n+             \"only compiled frames can contain stack allocated objects\");\n+      fr_is_deoptimized = fst.current()->is_deoptimized_frame();\n+      if (!fr_is_deoptimized) {\n+        \/\/ Execution must not continue in the compiled method, so we deoptimize the frame.\n+        Deoptimization::deoptimize_frame(deoptee, fr_id);\n+      } else {\n+        last_cvf = compiledVFrame::cast(vframe::new_vframe(fst.current(), fst.register_map(), deoptee));\n+      }\n+    } while(!fr_is_deoptimized);\n+\n+    \/\/ collect inlined frames\n+    compiledVFrame* cvf = last_cvf;\n+    GrowableArray<compiledVFrame*>* vfs = new GrowableArray<compiledVFrame*>(10);\n+    while (!cvf->is_top()) {\n+      vfs->push(cvf);\n+      cvf = compiledVFrame::cast(cvf->sender());\n+    }\n+    vfs->push(cvf);\n+\n+    \/\/ reallocate and relock optimized objects\n+    bool deoptimized_objects = Deoptimization::deoptimize_objects_internal(ct, vfs, realloc_failures);\n+    if (!realloc_failures && deoptimized_objects) {\n+      \/\/ now do the updates\n+      for (int frame_index = 0; frame_index < vfs->length(); frame_index++) {\n+        cvf = vfs->at(frame_index);\n+\n+        \/\/ locals\n+        GrowableArray<ScopeValue*>* scopeLocals = cvf->scope()->locals();\n+        StackValueCollection* locals = cvf->locals();\n+        if (locals != NULL) {\n+          for (int i2 = 0; i2 < locals->size(); i2++) {\n+            StackValue* var = locals->at(i2);\n+            if (var->type() == T_OBJECT && scopeLocals->at(i2)->is_object()) {\n+              jvalue val;\n+              val.l = cast_from_oop<jobject>(locals->at(i2)->get_obj()());\n+              cvf->update_local(T_OBJECT, i2, val);\n+            }\n+          }\n+        }\n+\n+        \/\/ expressions\n+        GrowableArray<ScopeValue*>* scopeExpressions = cvf->scope()->expressions();\n+        StackValueCollection* expressions = cvf->expressions();\n+        if (expressions != NULL) {\n+          for (int i2 = 0; i2 < expressions->size(); i2++) {\n+            StackValue* var = expressions->at(i2);\n+            if (var->type() == T_OBJECT && scopeExpressions->at(i2)->is_object()) {\n+              jvalue val;\n+              val.l = cast_from_oop<jobject>(expressions->at(i2)->get_obj()());\n+              cvf->update_stack(T_OBJECT, i2, val);\n+            }\n+          }\n+        }\n+\n+        \/\/ monitors\n+        GrowableArray<MonitorInfo*>* monitors = cvf->monitors();\n+        if (monitors != NULL) {\n+          for (int i2 = 0; i2 < monitors->length(); i2++) {\n+            if (monitors->at(i2)->eliminated()) {\n+              assert(!monitors->at(i2)->owner_is_scalar_replaced(),\n+                     \"reallocation failure, should not update\");\n+              cvf->update_monitor(i2, monitors->at(i2));\n+            }\n+          }\n+        }\n+      }\n+      set_objs_are_deoptimized(deoptee, fr_id);\n+    }\n+  }\n+  return !realloc_failures;\n+}\n+\n+#endif \/\/ COMPILER2_OR_JVMCI\n","filename":"src\/hotspot\/share\/runtime\/escapeBarrier.cpp","additions":390,"deletions":0,"binary":false,"changes":390,"status":"added"},{"patch":"@@ -0,0 +1,130 @@\n+\/*\n+ * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020 SAP SE. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_RUNTIME_ESCAPEBARRIER_HPP\n+#define SHARE_RUNTIME_ESCAPEBARRIER_HPP\n+\n+#include \"memory\/allocation.hpp\"\n+#include \"runtime\/globals.hpp\"\n+#include \"utilities\/macros.hpp\"\n+\n+class JavaThread;\n+\n+\/\/ EscapeBarriers should be put on execution paths where JVMTI agents can access object\n+\/\/ references held by java threads.\n+\/\/ They provide means to revert optimizations based on escape analysis in a well synchronized manner\n+\/\/ just before local references escape through JVMTI.\n+class EscapeBarrier : StackObj {\n+#if COMPILER2_OR_JVMCI\n+  JavaThread* const _calling_thread;\n+  JavaThread* const _deoptee_thread;\n+  bool        const _barrier_active;\n+\n+  static bool _deoptimizing_objects_for_all_threads;\n+  static bool _self_deoptimization_in_progress;\n+\n+  \/\/ Suspending is necessary because the target thread's stack must be walked and\n+  \/\/ object reallocation is not possible in a handshake or at a safepoint.\n+  \/\/ Suspending is based on handshakes. It is sufficient if the target thread(s)\n+  \/\/ cannot return to executing bytecodes. Acquiring a lock is ok. Leaving a\n+  \/\/ safepoint\/handshake safe state is not ok.\n+  \/\/ See also JavaThread::wait_for_object_deoptimization().\n+  void sync_and_suspend_one();\n+  void sync_and_suspend_all();\n+  void resume_one();\n+  void resume_all();\n+\n+  \/\/ Deoptimize the given frame and deoptimize objects with optimizations based on escape analysis.\n+  bool deoptimize_objects_internal(JavaThread* deoptee, intptr_t* fr_id);\n+\n+public:\n+  \/\/ Revert ea based optimizations for given deoptee thread\n+  EscapeBarrier(bool barrier_active, JavaThread* calling_thread, JavaThread* deoptee_thread)\n+    : _calling_thread(calling_thread), _deoptee_thread(deoptee_thread),\n+      _barrier_active(barrier_active && (JVMCI_ONLY(UseJVMCICompiler) NOT_JVMCI(false)\n+                      COMPILER2_PRESENT(|| DoEscapeAnalysis)))\n+  {\n+    if (_barrier_active) sync_and_suspend_one();\n+  }\n+\n+  \/\/ Revert ea based optimizations for all java threads\n+  EscapeBarrier(bool barrier_active, JavaThread* calling_thread)\n+    : _calling_thread(calling_thread), _deoptee_thread(NULL),\n+      _barrier_active(barrier_active && (JVMCI_ONLY(UseJVMCICompiler) NOT_JVMCI(false)\n+                      COMPILER2_PRESENT(|| DoEscapeAnalysis)))\n+  {\n+    if (_barrier_active) sync_and_suspend_all();\n+  }\n+#else\n+public:\n+  EscapeBarrier(bool barrier_active, JavaThread* calling_thread, JavaThread* deoptee_thread) { }\n+  EscapeBarrier(bool barrier_active, JavaThread* calling_thread) { }\n+  static bool deoptimizing_objects_for_all_threads() { return false; }\n+  bool barrier_active() const                        { return false; }\n+#endif \/\/ COMPILER2_OR_JVMCI\n+\n+  \/\/ Deoptimize objects, i.e. reallocate and relock them. The target frames are deoptimized.\n+  \/\/ The methods return false iff at least one reallocation failed.\n+  bool deoptimize_objects(intptr_t* fr_id) {\n+    return true COMPILER2_OR_JVMCI_PRESENT(&& deoptimize_objects_internal(deoptee_thread(), fr_id));\n+  }\n+  bool deoptimize_objects(int depth)                           NOT_COMPILER2_OR_JVMCI_RETURN_(true);\n+  \/\/ Find and deoptimize non escaping objects and the holding frames on all stacks.\n+  bool deoptimize_objects_all_threads()                        NOT_COMPILER2_OR_JVMCI_RETURN_(true);\n+\n+  \/\/ A java thread was added to the list of threads\n+  static void thread_added(JavaThread* jt)                     NOT_COMPILER2_OR_JVMCI_RETURN;\n+  \/\/ A java thread was removed from the list of threads\n+  static void thread_removed(JavaThread* jt)                   NOT_COMPILER2_OR_JVMCI_RETURN;\n+\n+#if COMPILER2_OR_JVMCI\n+  \/\/ Returns true iff objects were reallocated and relocked because of access through JVMTI\n+  static bool objs_are_deoptimized(JavaThread* thread, intptr_t* fr_id);\n+\n+  static bool deoptimizing_objects_for_all_threads() { return _deoptimizing_objects_for_all_threads; }\n+\n+  ~EscapeBarrier() {\n+    if (!barrier_active()) return;\n+    if (all_threads()) {\n+      resume_all();\n+    } else {\n+      resume_one();\n+    }\n+  }\n+\n+  \/\/ Should revert optimizations for all threads.\n+  bool all_threads()    const { return _deoptee_thread == NULL; }\n+  \/\/ Current thread deoptimizes its own objects.\n+  bool self_deopt()     const { return _calling_thread == _deoptee_thread; }\n+  \/\/ Inactive barriers are created if no local objects can escape.\n+  bool barrier_active() const { return _barrier_active; }\n+\n+  \/\/ accessors\n+  JavaThread* calling_thread() const     { return _calling_thread; }\n+  JavaThread* deoptee_thread() const     { return _deoptee_thread; }\n+#endif \/\/ COMPILER2_OR_JVMCI\n+};\n+\n+#endif \/\/ SHARE_RUNTIME_ESCAPEBARRIER_HPP\n","filename":"src\/hotspot\/share\/runtime\/escapeBarrier.hpp","additions":130,"deletions":0,"binary":false,"changes":130,"status":"added"},{"patch":"@@ -37,0 +37,1 @@\n+#include \"prims\/jvmtiDeferredUpdates.hpp\"\n@@ -49,1 +50,0 @@\n-#include \"runtime\/vframe_hp.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -65,0 +65,1 @@\n+#include \"prims\/jvmtiDeferredUpdates.hpp\"\n@@ -1897,2 +1898,2 @@\n-  GrowableArray<jvmtiDeferredLocalVariableSet*>* deferred = JvmtiDeferredUpdates::deferred_locals(this);\n-  if (deferred != NULL) {\n+  JvmtiDeferredUpdates* updates = deferred_updates();\n+  if (updates != NULL) {\n@@ -1900,8 +1901,3 @@\n-    assert(deferred->length() != 0, \"empty array!\");\n-    do {\n-      jvmtiDeferredLocalVariableSet* dlv = deferred->at(0);\n-      deferred->remove_at(0);\n-      \/\/ individual jvmtiDeferredLocalVariableSet are CHeapObj's\n-      delete dlv;\n-    } while (deferred->length() != 0);\n-    delete deferred_updates();\n+    assert(updates->count() > 0, \"Updates holder not deleted\");\n+    \/\/ free deferred updates.\n+    delete updates;\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":6,"deletions":10,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+#include \"prims\/jvmtiDeferredUpdates.hpp\"\n@@ -344,12 +345,0 @@\n-void JvmtiDeferredUpdates::create_for(JavaThread* thread) {\n-  assert(thread->deferred_updates() == NULL, \"already allocated\");\n-  thread->set_deferred_updates(new JvmtiDeferredUpdates());\n-}\n-\n-void JvmtiDeferredUpdates::inc_relock_count_after_wait(JavaThread* thread) {\n-  if (thread->deferred_updates() == NULL) {\n-    create_for(thread);\n-  }\n-  thread->deferred_updates()->inc_relock_count_after_wait();\n-}\n-\n","filename":"src\/hotspot\/share\/runtime\/vframe_hp.cpp","additions":1,"deletions":12,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -100,114 +100,0 @@\n-\/\/ Holds updates for compiled frames by JVMTI agents that cannot be performed immediately.\n-class jvmtiDeferredLocalVariableSet;\n-class JvmtiDeferredUpdates : public CHeapObj<mtCompiler> {\n-\n-  \/\/ Relocking has to be deferred if the lock owning thread is currently waiting on the monitor.\n-  int _relock_count_after_wait;\n-\n-  \/\/ Deferred updates of locals, expressions, and monitors\n-  GrowableArray<jvmtiDeferredLocalVariableSet*> _deferred_locals_updates;\n-\n-  void inc_relock_count_after_wait() {\n-    _relock_count_after_wait++;\n-  }\n-\n-  int get_and_reset_relock_count_after_wait() {\n-    int result = _relock_count_after_wait;\n-    _relock_count_after_wait = 0;\n-    return result;\n-  }\n-\n-  GrowableArray<jvmtiDeferredLocalVariableSet*>* deferred_locals() { return &_deferred_locals_updates; }\n-\n-  JvmtiDeferredUpdates() :\n-    _relock_count_after_wait(0),\n-    _deferred_locals_updates((ResourceObj::set_allocation_type((address) &_deferred_locals_updates,\n-                              ResourceObj::C_HEAP), 1), mtCompiler) { }\n-\n-public:\n-  static void create_for(JavaThread* thread);\n-\n-  static GrowableArray<jvmtiDeferredLocalVariableSet*>* deferred_locals(JavaThread* jt) {\n-    return jt->deferred_updates() == NULL ? NULL : jt->deferred_updates()->deferred_locals();\n-  }\n-\n-  \/\/ Relocking has to be deferred if the lock owning thread is currently waiting on the monitor.\n-  static int get_and_reset_relock_count_after_wait(JavaThread* jt) {\n-    return jt->deferred_updates() == NULL ? 0 : jt->deferred_updates()->get_and_reset_relock_count_after_wait();\n-  }\n-  static void inc_relock_count_after_wait(JavaThread* thread);\n-};\n-\n-\n-\/\/ In order to implement set_locals for compiled vframes we must\n-\/\/ store updated locals in a data structure that contains enough\n-\/\/ information to recognize equality with a vframe and to store\n-\/\/ any updated locals.\n-\n-class jvmtiDeferredLocalVariable;\n-class jvmtiDeferredLocalVariableSet : public CHeapObj<mtCompiler> {\n-  friend class compiledVFrame;\n-\n-private:\n-\n-  Method* _method;\n-  int       _bci;\n-  intptr_t* _id;\n-  int _vframe_id;\n-  GrowableArray<jvmtiDeferredLocalVariable*>* _locals;\n-  bool _objects_are_deoptimized;\n-\n-  void                              update_value(StackValueCollection* locals, BasicType type, int index, jvalue value);\n-\n-  void                              set_value_at(int idx, BasicType typ, jvalue val);\n-\n- public:\n-  \/\/ JVM state\n-  Method*                           method()         const  { return _method; }\n-  int                               bci()            const  { return _bci; }\n-  intptr_t*                         id()             const  { return _id; }\n-  int                               vframe_id()      const  { return _vframe_id; }\n-  bool                              objects_are_deoptimized() const { return _objects_are_deoptimized; }\n-\n-  void                              update_locals(StackValueCollection* locals);\n-  void                              update_stack(StackValueCollection* locals);\n-  void                              update_monitors(GrowableArray<MonitorInfo*>* monitors);\n-  void                              set_objs_are_deoptimized() { _objects_are_deoptimized = true; }\n-\n-  \/\/ Does the vframe match this jvmtiDeferredLocalVariableSet\n-  bool                              matches(const vframe* vf);\n-  \/\/ Does the underlying physical frame match this jvmtiDeferredLocalVariableSet\n-  bool                              matches(intptr_t* fr_id) { return id() == fr_id; }\n-  \/\/ GC\n-  void                              oops_do(OopClosure* f);\n-\n-  \/\/ constructor\n-  jvmtiDeferredLocalVariableSet(Method* method, int bci, intptr_t* id, int vframe_id);\n-\n-  \/\/ destructor\n-  ~jvmtiDeferredLocalVariableSet();\n-\n-\n-};\n-\n-class jvmtiDeferredLocalVariable : public CHeapObj<mtCompiler> {\n-  public:\n-\n-    jvmtiDeferredLocalVariable(int index, BasicType type, jvalue value);\n-\n-    BasicType type(void)                   { return _type; }\n-    int index(void)                        { return _index; }\n-    jvalue value(void)                     { return _value; }\n-    \/\/ Only mutator is for value as only it can change\n-    void set_value(jvalue value)           { _value = value; }\n-    \/\/ For gc\n-    oop* oop_addr(void)                    { return (oop*) &_value.l; }\n-\n-  private:\n-\n-    BasicType         _type;\n-    jvalue            _value;\n-    int               _index;\n-\n-};\n-\n","filename":"src\/hotspot\/share\/runtime\/vframe_hp.hpp","additions":0,"deletions":114,"binary":false,"changes":114,"status":"modified"},{"patch":"@@ -22,0 +22,1 @@\n+ *\n@@ -1140,0 +1141,2 @@\n+        \/\/ o is referenced in checkPostConditions() and must not be gc'ed.\n+        o.disableCollection();\n","filename":"test\/jdk\/com\/sun\/jdi\/EATests.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"}]}