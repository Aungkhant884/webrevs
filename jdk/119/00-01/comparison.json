{"files":[{"patch":"@@ -844,1 +844,1 @@\n-  while (!this->is_terminated()) {\n+  while (true) {\n@@ -862,1 +862,1 @@\n-  while (!is_terminated()) {\n+  while (true) {\n","filename":"src\/hotspot\/share\/compiler\/compileBroker.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1092,2 +1092,1 @@\n-  \/\/ Don't do scalar replacement if the frame can be popped by JVMTI:\n-  \/\/ if reallocation fails during deoptimization we'll pop all\n+  \/\/ If reallocation fails during deoptimization we'll pop all\n@@ -1096,0 +1095,2 @@\n+  \/\/ We avoid this issue by eager reallocation when the popframe request\n+  \/\/ is received.\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -884,1 +884,0 @@\n-  JavaThread* t = JavaThread::current();\n@@ -886,3 +885,3 @@\n-  if (t->has_last_Java_frame()) {\n-    RegisterMap reg_map(t);\n-    javaVFrame *jvf = t->last_java_vframe(&reg_map);\n+  if (thread->has_last_Java_frame()) {\n+    RegisterMap reg_map(thread);\n+    javaVFrame *jvf = thread->last_java_vframe(&reg_map);\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2816,1 +2816,0 @@\n-  JavaThread* _excluded_thread;\n@@ -2819,7 +2818,2 @@\n-    HandshakeClosure(name),\n-    _excluded_thread(excluded_thread) {}\n-  void do_thread(Thread* th) {\n-    if (th->is_Java_thread() && !th->is_hidden_from_external_view() && (th != _excluded_thread)) {\n-      th->set_obj_deopt_flag();\n-    }\n-  }\n+    HandshakeClosure(name) { }\n+  void do_thread(Thread* th) { }\n@@ -2851,1 +2845,1 @@\n-  \/\/ suspend target thread\n+  \/\/ Use a handshake to synchronize with the target thread.\n@@ -2885,0 +2879,10 @@\n+\n+    \/\/ We set the suspend flags before executing the handshake because then the\n+    \/\/ setting will be visible after leaving the _thread_blocked state in\n+    \/\/ JavaThread::wait_for_object_deoptimization(). If we set the flags in the\n+    \/\/ handshake then the read must happen after the safepoint\/handshake poll.\n+    for (JavaThreadIteratorWithHandle jtiwh; JavaThread *jt = jtiwh.next(); ) {\n+      if (jt->is_Java_thread() && !jt->is_hidden_from_external_view() && (jt != _calling_thread)) {\n+        jt->set_obj_deopt_flag();\n+      }\n+    }\n@@ -2887,0 +2891,1 @@\n+  \/\/ Use a handshake to synchronize with the other threads.\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":14,"deletions":9,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -494,0 +494,6 @@\n+  \/\/ Suspending is necessary because the target thread's stack must be walked and\n+  \/\/ object reallocation is not possible in a handshake or at a safepoint.\n+  \/\/ Suspending is based on handshakes. It is sufficient if the target thread(s)\n+  \/\/ cannot return to executing bytecodes. Acquiring a lock is ok. Leaving a\n+  \/\/ safepoint\/handshake safe state is not ok.\n+  \/\/ See also JavaThread::wait_for_object_deoptimization().\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -122,0 +122,1 @@\n+#include \"utilities\/spinYield.hpp\"\n@@ -1927,0 +1928,1 @@\n+    set_deferred_updates(NULL);\n@@ -2640,0 +2642,15 @@\n+\/\/ Wait for another thread to perform object reallocation and relocking on behalf of\n+\/\/ this thread.\n+\/\/ This method is very similar to JavaThread::java_suspend_self_with_safepoint_check()\n+\/\/ and has the same callers. It also performs a raw thread state transition to\n+\/\/ _thread_blocked and back again to the original state before returning. The current\n+\/\/ thread is required to change to _thread_blocked in order to be seen to be\n+\/\/ safepoint\/handshake safe whilst suspended and only after becoming handshake safe,\n+\/\/ the other thread can complete the handshake used to synchronize with this thread\n+\/\/ and then perform the reallocation and relocking. We cannot use the thread state\n+\/\/ transition helpers because we arrive here in various states and also because the\n+\/\/ helpers indirectly call this method.  After leaving _thread_blocked we have to\n+\/\/ check for safepoint\/handshake, except if _thread_in_native. The thread is safe\n+\/\/ without blocking then. Allowed states are enumerated in\n+\/\/ SafepointSynchronize::block(). See also EscapeBarrier::sync_and_suspend_*()\n+\n@@ -2645,1 +2662,1 @@\n-  bool should_spin_wait = true;\n+  bool spin_wait = os::is_MP();\n@@ -2648,2 +2665,16 @@\n-    set_suspend_equivalent();\n-    {\n+    \/\/ Check if _external_suspend was set in the previous loop iteration.\n+    if (is_external_suspend()) {\n+      java_suspend_self();\n+    }\n+    \/\/ Wait for object deoptimization if requested.\n+    if (spin_wait) {\n+      \/\/ A single deoptimization is typically very short. Microbenchmarks\n+      \/\/ showed 5% better performance when spinning.\n+      const uint spin_limit = 10 * SpinYield::default_spin_limit;\n+      SpinYield spin(spin_limit);\n+      for (uint i = 0; is_obj_deopt_suspend() && i < spin_limit; i++) {\n+        spin.wait();\n+      }\n+      \/\/ Spin just once\n+      spin_wait = false;\n+    } else {\n@@ -2651,2 +2682,1 @@\n-      if (EscapeBarrier::deoptimizing_objects_for_all_threads() ||\n-          (is_obj_deopt_suspend() && !should_spin_wait)) {\n+      if (is_obj_deopt_suspend()) {\n@@ -2655,18 +2685,0 @@\n-      should_spin_wait = should_spin_wait && is_obj_deopt_suspend();\n-    }\n-    \/\/ A single deoptimization is typically very short. Microbenchmarks\n-    \/\/ showed 5% better performance when spinning.\n-    if (should_spin_wait) {\n-      \/\/ Inspired by HandshakeSpinYield\n-      const jlong max_spin_time_ns = 100 \/* us *\/ * (NANOUNITS \/ MICROUNITS);\n-      const int free_cpus = os::active_processor_count() - 1;\n-      jlong spin_time_ns = (5 \/* us *\/ * (NANOUNITS \/ MICROUNITS)) * free_cpus; \/\/ zero on UP\n-      spin_time_ns = spin_time_ns > max_spin_time_ns ? max_spin_time_ns : spin_time_ns;\n-      jlong spin_start = os::javaTimeNanos();\n-      while (is_obj_deopt_suspend()) {\n-        os::naked_yield();\n-        if ((os::javaTimeNanos() - spin_start) > spin_time_ns) {\n-          should_spin_wait = false;\n-          break;\n-        }\n-      }\n@@ -2674,0 +2686,3 @@\n+    \/\/ The current thread could have been suspended again. We have to check for\n+    \/\/ suspend after restoring the saved state. Without this the current thread\n+    \/\/ might return to _thread_in_Java and execute bytecode.\n@@ -2675,0 +2690,1 @@\n+  } while (is_obj_deopt_suspend() || is_external_suspend());\n@@ -2676,15 +2692,6 @@\n-    if (handle_special_suspend_equivalent_condition()) {\n-      java_suspend_self_with_safepoint_check();\n-    }\n-\n-    \/\/ Since we are not using a regular thread-state transition helper here,\n-    \/\/ we must manually emit the instruction barrier after leaving a safe state.\n-    OrderAccess::cross_modify_fence();\n-    if (state != _thread_in_native) {\n-      SafepointMechanism::process_if_requested(this);\n-    }\n-\n-    \/\/ Check for another deopt suspend _after_ checking for safepoint\/handshake,\n-    \/\/ or otherwise a stale value can be seen if the flag was changed with a\n-    \/\/ handshake while the current thread was _thread_blocked above.\n-  } while (is_obj_deopt_suspend());\n+  \/\/ Since we are not using a regular thread-state transition helper here,\n+  \/\/ we must manually emit the instruction barrier after leaving a safe state.\n+  OrderAccess::cross_modify_fence();\n+  if (state != _thread_in_native) {\n+    SafepointMechanism::process_if_requested(this);\n+  }\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":45,"deletions":38,"binary":false,"changes":83,"status":"modified"}]}