{"files":[{"patch":"@@ -79,2 +79,3 @@\n-        int[] alive = new int[3];\n-        int[] enqued = new int[3];\n+        ReferenceQueue refq = null; \/\/ Reinitialized each time through loop\n+        int[] alive = null;         \/\/ Reinitialized each time through loop\n+        int[] wrong = null;         \/\/ Reinitialized each time through loop\n@@ -85,1 +86,0 @@\n-        ReferenceQueue refq = new ReferenceQueue();\n@@ -96,1 +96,1 @@\n-                int totalQ = 0;\n+                int totalLive = 0;\n@@ -100,1 +100,1 @@\n-                    enqued = new int[3];\n+                    wrong = new int[3];\n@@ -115,2 +115,2 @@\n-                    if (wr[i].isEnqueued()) {\n-                        ++totalQ;\n+                    if (wr[i].refersTo(holder[i])) {\n+                        ++totalLive;\n@@ -118,2 +118,2 @@\n-                    if (sr[i].isEnqueued()) {\n-                        ++totalQ;\n+                    if (sr[i].refersTo(holder[i])) {\n+                        ++totalLive;\n@@ -121,2 +121,2 @@\n-                    if (phr[i].isEnqueued()) {\n-                        ++totalQ;\n+                    if (phr[i].refersTo(holder[i])) {\n+                        ++totalLive;\n@@ -125,2 +125,2 @@\n-                if (totalQ != 0) {\n-                    throw new TestFailure(\"There are \" + totalQ + \" references in the queue instead 0 before null-assigment.\");\n+                if (totalLive != 3 * RANGE) {\n+                    throw new TestFailure(\"There are \" + (3 * RANGE - totalLive) + \" references cleared before null-assigment.\");\n@@ -129,1 +129,3 @@\n-                for (int i = 0; i < (int) (RANGE * RATIO); i++) {\n+                int REMOVE = (int) (RANGE * RATIO);\n+                int RETAIN = RANGE - REMOVE;\n+                for (int i = 0; i < REMOVE; i++) {\n@@ -140,20 +142,0 @@\n-                alive = new int[3];\n-                enqued = new int[3];\n-                for (int i = 0; i < RANGE; i++) {\n-                    if (wr[i].get() != null) {\n-                        ++alive[WEAK];\n-                    }\n-                    if (wr[i].isEnqueued()) {\n-                        ++enqued[WEAK];\n-                    }\n-                    if (sr[i].get() != null) {\n-                        ++alive[SOFT];\n-                    }\n-                    if (sr[i].isEnqueued()) {\n-                        ++enqued[SOFT];\n-                    }\n-                    if (phr[i].isEnqueued()) {\n-                        ++enqued[PHANTOM];\n-                    }\n-                }\n-\n@@ -161,3 +143,4 @@\n-                while (totalQ < (RANGE * RATIO * 3 * 0.9) && (System.currentTimeMillis() < waitTime)) {\n-                    alive = new int[3];\n-                    enqued = new int[3];\n+                int totalQ = 0;\n+                while ((totalQ < (3 * REMOVE)) && (System.currentTimeMillis() < waitTime)) {\n+                    alive[WEAK] = alive[SOFT] = alive[PHANTOM] = 0;\n+                    wrong[WEAK] = wrong[SOFT] = wrong[PHANTOM] = 0;\n@@ -165,1 +148,3 @@\n-                        if (wr[i].get() != null) {\n+                        if (!wr[i].refersTo(holder[i])) {\n+                            ++wrong[WEAK];\n+                        } else if (holder[i] != null) {\n@@ -168,4 +153,4 @@\n-                        if (wr[i].isEnqueued()) {\n-                            ++enqued[WEAK];\n-                        }\n-                        if (sr[i].get() != null) {\n+\n+                        if (!sr[i].refersTo(holder[i])) {\n+                            ++wrong[SOFT];\n+                        } else if (holder[i] != null) {\n@@ -174,2 +159,5 @@\n-                        if (sr[i].isEnqueued()) {\n-                            ++enqued[SOFT];\n+\n+                        if (!phr[i].refersTo(holder[i])) {\n+                            ++wrong[PHANTOM];\n+                        } else if (holder[i] != null) {\n+                            ++alive[PHANTOM];\n@@ -177,2 +165,5 @@\n-                        if (phr[i].isEnqueued()) {\n-                            ++enqued[PHANTOM];\n+                    }\n+\n+                    try {\n+                        while (refq.remove(100) != null) {\n+                            ++totalQ;\n@@ -180,0 +171,1 @@\n+                    } catch (InterruptedException ie) {\n@@ -181,12 +173,4 @@\n-                    totalQ = (enqued[WEAK] + enqued[SOFT] + enqued[PHANTOM]);\n-                    if (totalQ < (int) (3 * RANGE * RATIO * 0.9)) {\n-                        log.debug(\"After null-assignment to \" + (int) (RANGE * RATIO) +\n-                                \/\/\" elements from \" + lower + \" to \" + (upper - 1) +\n-                                \" and provoking gc found:\\n\\t\" +\n-                                enqued[WEAK] + \" weak\\n\\t\" +\n-                                enqued[SOFT] + \" soft\\n\\t\" +\n-                                enqued[PHANTOM] + \" phantom \" +\n-                                \" queuened refs and \\n\\t\" +\n-                                alive[WEAK] + \" weak\\n\\t\" +\n-                                alive[SOFT] + \" soft\\n\\t\" +\n-                                \"alive refs.\");\n+                    if (totalQ < (3 * REMOVE)) {\n+                        log.debug(\"After null-assignment to \" + REMOVE +\n+                                  \" referent values and provoking gc found:\\n\\t\" +\n+                                  totalQ + \" queued refs.\");\n@@ -194,1 +178,1 @@\n-                            log.debug(\"sleeping to give gc one more chance ......\");\n+                            log.debug(\"sleeping to give reference processing more time ...\");\n@@ -201,2 +185,8 @@\n-                if (totalQ < (int) (3 * RANGE * RATIO * 0.9) || totalQ > (int) (3 * RANGE * RATIO)) {\n-                    throw new TestFailure(\"Test failed\");\n+                if (wrong[WEAK] != 0) {\n+                    throw new TestFailure(\"Expected \" + RETAIN + \" weak references still alive: \" + alive[WEAK]);\n+                } else if (wrong[SOFT] != 0) {\n+                    throw new TestFailure(\"Expected \" + RETAIN + \" soft references still alive: \" + alive[SOFT]);\n+                } else if (wrong[PHANTOM] != 0) {\n+                    throw new TestFailure(\"Expected \" + RETAIN + \" phantom references still alive: \" + alive[PHANTOM]);\n+                } else if (totalQ != (3 * REMOVE)) {\n+                    throw new TestFailure(\"Expected \" + (3 * REMOVE) + \" references enqueued: \" + totalQ);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/gctests\/ReferencesGC\/ReferencesGC.java","additions":51,"deletions":61,"binary":false,"changes":112,"status":"modified"},{"patch":"@@ -204,3 +204,3 @@\n-                        numEnqueued = 0; \/\/ We set counter to zero to avoid counting references twice\n-                        for (int i = 0; i < numLists; i++) {\n-                                if (wholder[i].isEnqueued()) {\n+                        try {\n+                                while ((numEnqueued < numLists) &&\n+                                       (refQueue.remove(1000) != null)) {\n@@ -209,0 +209,1 @@\n+                        } catch (InterruptedException ie) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/gctests\/WeakReferenceGC\/WeakReferenceGC.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -54,0 +54,1 @@\n+            boolean enqueued = false;\n@@ -57,5 +58,2 @@\n-                if (ref.isEnqueued()) {\n-                    break;\n-                }\n-\n-                Thread.sleep(100);\n+                enqueued = (queue.remove(100) == ref);\n+                if (enqueued) break;\n@@ -64,1 +62,1 @@\n-            if (ref.isEnqueued() == false) {\n+            if (!enqueued) {\n@@ -66,2 +64,1 @@\n-                System.out.println(\"Reference not enqueued yet\");\n-                return;\n+                throw new RuntimeException(\"Error: reference not enqueued\");\n@@ -76,6 +73,0 @@\n-\n-            if (queue.poll() == null) {\n-                \/\/ poll() should return ref enqueued by the GC\n-                throw new RuntimeException(\"Error: poll() returned null;\"\n-                        + \" expected ref object\");\n-            }\n@@ -93,1 +84,1 @@\n-            \/\/ Can't test PhantomReference because get() always returns null.\n+            this.refs.add(new PhantomReference<>(new Object(), queue));\n@@ -101,1 +92,1 @@\n-                if (ref.get() != null) {\n+                if (!ref.refersTo(null)) {\n","filename":"test\/jdk\/java\/lang\/ref\/ReferenceEnqueue.java","additions":8,"deletions":17,"binary":false,"changes":25,"status":"modified"}]}