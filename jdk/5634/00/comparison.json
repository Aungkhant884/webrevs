{"files":[{"patch":"@@ -45,2 +45,1 @@\n- * @run main\/othervm -Xint  -XX:+UseInterpreter -Dinterpreted=true  jdk.jfr.api.consumer.TestRecordedFrame\n- * @run main\/othervm\/timeout=180 -Xcomp -XX:-UseInterpreter -Dinterpreted=false jdk.jfr.api.consumer.TestRecordedFrame\n+ * @run main\/othervm jdk.jfr.api.consumer.TestRecordedFrame\n@@ -89,4 +88,0 @@\n-                    \/\/ Interpreted\n-                    boolean isInterpreted = \"Interpreted\".equals(type);\n-                    boolean expectedInterpreted = \"true\".equals(System.getProperty(\"interpreted\"));\n-                    Asserts.assertEquals(isInterpreted, expectedInterpreted);\n","filename":"test\/jdk\/jdk\/jfr\/api\/consumer\/TestRecordedFrame.java","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,116 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.api.consumer;\n+\n+import java.lang.reflect.Method;\n+import java.util.List;\n+import java.util.Set;\n+\n+import jdk.jfr.Event;\n+import jdk.jfr.Recording;\n+import jdk.jfr.consumer.RecordedEvent;\n+import jdk.jfr.consumer.RecordedFrame;\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.Utils;\n+import jdk.test.lib.jfr.Events;\n+import jdk.test.lib.jfr.SimpleEvent;\n+import sun.hotspot.WhiteBox;\n+\n+\/**\n+ * @test\n+ * @summary Test jdk.jfr.consumer.RecordedFrame::getType()\n+ * @key jfr\n+ * @requires vm.hasJFR\n+ * @library \/test\/lib\n+ * @build sun.hotspot.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions\n+ *      -XX:+WhiteBoxAPI jdk.jfr.api.consumer.TestRecordedFrameType\n+ *\/\n+public final class TestRecordedFrameType {\n+\n+    public static void main(String[] args) throws Exception {\n+        WhiteBox WB = WhiteBox.getWhiteBox();\n+\n+        try (Recording recording = new Recording()) {\n+            recording.start();\n+\n+            String directive =\n+                \"\"\"\n+                [\n+                  {\n+                    match: \"jdk\/jfr\/api\/consumer\/TestRecordedFrameType.interpreted()\",\n+                    Exclude: true,\n+                  },\n+                  {\n+                    match: \"jdk\/jfr\/api\/consumer\/TestRecordedFrameType.compiled()\",\n+                    BackgroundCompilation: false,\n+                  },\n+                ]\n+                \"\"\";\n+            WB.addCompilerDirective(directive);\n+            Method mtd = TestRecordedFrameType.class.getMethod(\"compiled\", new Class[0]);\n+            WB.enqueueMethodForCompilation(mtd, 1);\n+            Utils.waitForCondition(() -> WB.isMethodCompiled(mtd));\n+\n+            interpreted();\n+            compiled();\n+\n+            List<RecordedEvent> events = Events.fromRecording(recording);\n+\n+            RecordedFrame interpreted = findFrame(events, \"interpreted\");\n+            System.out.println(interpreted);\n+            String iType = interpreted.getType();\n+            Asserts.assertEquals(iType, \"Interpreted\");\n+\n+            RecordedFrame compiled = findFrame(events, \"compiled\");\n+            System.out.println(compiled);\n+            String cType = compiled.getType();\n+            Asserts.assertNotEquals(cType, \"Interpreted\"); \/\/ \"JIT compiled\" or \"Inlined\"\n+        }\n+    }\n+\n+    private static RecordedFrame findFrame(List<RecordedEvent> events, String methodName) throws Exception {\n+        for (RecordedEvent event : events) {\n+            for (RecordedFrame frame : event.getStackTrace().getFrames()) {\n+                if (frame.getMethod().getName().equals(methodName)) {\n+                    System.out.println(\"Found frame with method named: \" + methodName);\n+                    return frame;\n+                }\n+            }\n+        }\n+        throw new Exception(\"Could not find frame with method named \" + methodName);\n+    }\n+\n+    public static void interpreted() {\n+        SimpleEvent event = new SimpleEvent();\n+        event.id = 1;\n+        event.commit();\n+    }\n+\n+    public static void compiled() {\n+        SimpleEvent event = new SimpleEvent();\n+        event.id = 2;\n+        event.commit();\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/api\/consumer\/TestRecordedFrameType.java","additions":116,"deletions":0,"binary":false,"changes":116,"status":"added"}]}