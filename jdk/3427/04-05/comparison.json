{"files":[{"patch":"@@ -469,2 +469,8 @@\n-        long size = StreamOpFlag.SIZED.isKnown(getStreamAndOpFlags()) ? spliterator.getExactSizeIfKnown() : -1;\n-        return size == -1 ? size : exactOutputSize(size);\n+        int flags = getStreamAndOpFlags();\n+        long size = StreamOpFlag.SIZED.isKnown(flags) ? spliterator.getExactSizeIfKnown() : -1;\n+        if (size != -1 && StreamOpFlag.SIZE_ADJUSTING.isKnown(flags) && !isParallel()) {\n+            for (AbstractPipeline<?, ?, ?> stage = sourceStage.nextStage; stage != null; stage = stage.nextStage) {\n+                size = stage.exactOutputSize(size);\n+            }\n+        }\n+        return size;\n@@ -474,1 +480,1 @@\n-     * Returns the exact output size of the pipeline given the exact size reported by the source spliterator.\n+     * Returns the exact output size of the pipeline given the exact size reported by the previous stage.\n@@ -476,2 +482,2 @@\n-     * @param sourceSize the exact size reported by the source spliterator\n-     * @return the exact output size\n+     * @param previousSize the exact size reported by the previous stage\n+     * @return the output size of this stage\n@@ -479,2 +485,2 @@\n-    long exactOutputSize(long sourceSize) {\n-        return previousStage == null ? sourceSize : previousStage.exactOutputSize(sourceSize);\n+    long exactOutputSize(long previousSize) {\n+        return previousSize;\n","filename":"src\/java.base\/share\/classes\/java\/util\/stream\/AbstractPipeline.java","additions":13,"deletions":7,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -113,8 +113,2 @@\n-            long exactOutputSize(long sourceSize) {\n-                \/\/ For parallel streams, the exact output size is that reported by the slice op's spliterator,\n-                \/\/ since a slice op is a stateful op whose spliterator is the source spliterator\n-                \/\/ (see AbstractPipeline.sourceSpliterator).\n-                \/\/ Otherwise, for sequential streams the extact output size that of the prior pipeline stage reduced\n-                \/\/ by the skip and limit\n-                return isParallel() ? sourceSize\n-                    : calcSize(super.exactOutputSize(sourceSize), skip, normalizedLimit);\n+            long exactOutputSize(long previousSize) {\n+                return calcSize(previousSize, skip, normalizedLimit);\n@@ -122,0 +116,1 @@\n+\n@@ -240,8 +235,2 @@\n-            long exactOutputSize(long sourceSize) {\n-                \/\/ For parallel streams, the exact output size is that reported by the slice op's spliterator,\n-                \/\/ since a slice op is a stateful op whose spliterator is the source spliterator\n-                \/\/ (see AbstractPipeline.sourceSpliterator).\n-                \/\/ Otherwise, for sequential streams the extact output size that of the prior pipeline stage reduced\n-                \/\/ by the skip and limit\n-                return isParallel() ? sourceSize\n-                    : calcSize(super.exactOutputSize(sourceSize), skip, normalizedLimit);\n+            long exactOutputSize(long previousSize) {\n+                return calcSize(previousSize, skip, normalizedLimit);\n@@ -361,8 +350,2 @@\n-            long exactOutputSize(long sourceSize) {\n-                \/\/ For parallel streams, the exact output size is that reported by the slice op's spliterator,\n-                \/\/ since a slice op is a stateful op whose spliterator is the source spliterator\n-                \/\/ (see AbstractPipeline.sourceSpliterator).\n-                \/\/ Otherwise, for sequential streams the extact output size that of the prior pipeline stage reduced\n-                \/\/ by the skip and limit\n-                return isParallel() ? sourceSize\n-                    : calcSize(super.exactOutputSize(sourceSize), skip, normalizedLimit);\n+            long exactOutputSize(long previousSize) {\n+                return calcSize(previousSize, skip, normalizedLimit);\n@@ -482,8 +465,2 @@\n-            long exactOutputSize(long sourceSize) {\n-                \/\/ For parallel streams, the exact output size is that reported by the slice op's spliterator,\n-                \/\/ since a slice op is a stateful op whose spliterator is the source spliterator\n-                \/\/ (see AbstractPipeline.sourceSpliterator).\n-                \/\/ Otherwise, for sequential streams the extact output size that of the prior pipeline stage reduced\n-                \/\/ by the skip and limit\n-                return isParallel() ? sourceSize\n-                    : calcSize(super.exactOutputSize(sourceSize), skip, normalizedLimit);\n+            long exactOutputSize(long previousSize) {\n+                return calcSize(previousSize, skip, normalizedLimit);\n@@ -586,1 +563,1 @@\n-        return (limit != -1) ? StreamOpFlag.IS_SHORT_CIRCUIT : 0;\n+        return StreamOpFlag.IS_SIZE_ADJUSTING | ((limit != -1) ? StreamOpFlag.IS_SHORT_CIRCUIT : 0);\n","filename":"src\/java.base\/share\/classes\/java\/util\/stream\/SliceOps.java","additions":10,"deletions":33,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -328,1 +328,1 @@\n-                  set(Type.OP).set(Type.TERMINAL_OP));\n+                  set(Type.OP).set(Type.TERMINAL_OP)),\n@@ -330,0 +330,10 @@\n+    \/**\n+     * Characteristic value signifying that an operation may adjust the\n+     * total size of the stream.\n+     * <p>\n+     * An intermediate operation can preserve or inject this value.\n+     *\/\n+    \/\/ 13, 0x04000000\n+    SIZE_ADJUSTING(13,\n+                   set(Type.OP));\n+    \n@@ -333,1 +343,0 @@\n-    \/\/ 13, 0x04000000\n@@ -632,0 +641,5 @@\n+    \/**\n+     * The bit value to inject {@link #SIZE_ADJUSTING}.\n+     *\/\n+    static final int IS_SIZE_ADJUSTING = SIZE_ADJUSTING.set;\n+\n","filename":"src\/java.base\/share\/classes\/java\/util\/stream\/StreamOpFlag.java","additions":16,"deletions":2,"binary":false,"changes":18,"status":"modified"}]}