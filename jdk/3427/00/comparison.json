{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -469,1 +469,12 @@\n-        return StreamOpFlag.SIZED.isKnown(getStreamAndOpFlags()) ? spliterator.getExactSizeIfKnown() : -1;\n+        long size = StreamOpFlag.SIZED.isKnown(getStreamAndOpFlags()) ? spliterator.getExactSizeIfKnown() : -1;\n+        return size == -1 ? size : adjustSize(size);\n+    }\n+\n+    \/**\n+     * Adjusts the exact size of the resulting stream using source spliterator size.\n+     *\n+     * @param size exact size of the output reported by source spliterator\n+     * @return adjusted size\n+     *\/\n+    long adjustSize(long size) {\n+        return previousStage == null ? size : previousStage.adjustSize(size);\n","filename":"src\/java.base\/share\/classes\/java\/util\/stream\/AbstractPipeline.java","additions":13,"deletions":2,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -85,1 +85,2 @@\n-     * flags.\n+     * flags. The exact output size may differ from spliterator size,\n+     * if pipeline contains a slice operation.\n","filename":"src\/java.base\/share\/classes\/java\/util\/stream\/PipelineHelper.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -255,2 +255,3 @@\n-                if (StreamOpFlag.SIZED.isKnown(helper.getStreamAndOpFlags()))\n-                    return spliterator.getExactSizeIfKnown();\n+                long size = helper.exactOutputSizeIfKnown(spliterator);\n+                if (size != -1)\n+                    return size;\n@@ -263,2 +264,3 @@\n-                if (StreamOpFlag.SIZED.isKnown(helper.getStreamAndOpFlags()))\n-                    return spliterator.getExactSizeIfKnown();\n+                long size = helper.exactOutputSizeIfKnown(spliterator);\n+                if (size != -1)\n+                    return size;\n@@ -429,2 +431,3 @@\n-                if (StreamOpFlag.SIZED.isKnown(helper.getStreamAndOpFlags()))\n-                    return spliterator.getExactSizeIfKnown();\n+                long size = helper.exactOutputSizeIfKnown(spliterator);\n+                if (size != -1)\n+                    return size;\n@@ -437,2 +440,3 @@\n-                if (StreamOpFlag.SIZED.isKnown(helper.getStreamAndOpFlags()))\n-                    return spliterator.getExactSizeIfKnown();\n+                long size = helper.exactOutputSizeIfKnown(spliterator);\n+                if (size != -1)\n+                    return size;\n@@ -603,2 +607,3 @@\n-                if (StreamOpFlag.SIZED.isKnown(helper.getStreamAndOpFlags()))\n-                    return spliterator.getExactSizeIfKnown();\n+                long size = helper.exactOutputSizeIfKnown(spliterator);\n+                if (size != -1)\n+                    return size;\n@@ -611,2 +616,3 @@\n-                if (StreamOpFlag.SIZED.isKnown(helper.getStreamAndOpFlags()))\n-                    return spliterator.getExactSizeIfKnown();\n+                long size = helper.exactOutputSizeIfKnown(spliterator);\n+                if (size != -1)\n+                    return size;\n@@ -777,2 +783,3 @@\n-                if (StreamOpFlag.SIZED.isKnown(helper.getStreamAndOpFlags()))\n-                    return spliterator.getExactSizeIfKnown();\n+                long size = helper.exactOutputSizeIfKnown(spliterator);\n+                if (size != -1)\n+                    return size;\n@@ -785,2 +792,3 @@\n-                if (StreamOpFlag.SIZED.isKnown(helper.getStreamAndOpFlags()))\n-                    return spliterator.getExactSizeIfKnown();\n+                long size = helper.exactOutputSizeIfKnown(spliterator);\n+                if (size != -1)\n+                    return size;\n","filename":"src\/java.base\/share\/classes\/java\/util\/stream\/ReduceOps.java","additions":25,"deletions":17,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,1 +53,1 @@\n-        return size >= 0 ? Math.max(-1, Math.min(size - skip, limit)) : -1;\n+        return size >= 0 ? Math.max(0, Math.min(size - skip, limit)) : -1;\n@@ -75,1 +75,0 @@\n-    @SuppressWarnings(\"unchecked\")\n@@ -81,16 +80,12 @@\n-        switch (shape) {\n-            case REFERENCE:\n-                return new StreamSpliterators\n-                        .SliceSpliterator.OfRef<>(s, skip, sliceFence);\n-            case INT_VALUE:\n-                return (Spliterator<P_IN>) new StreamSpliterators\n-                        .SliceSpliterator.OfInt((Spliterator.OfInt) s, skip, sliceFence);\n-            case LONG_VALUE:\n-                return (Spliterator<P_IN>) new StreamSpliterators\n-                        .SliceSpliterator.OfLong((Spliterator.OfLong) s, skip, sliceFence);\n-            case DOUBLE_VALUE:\n-                return (Spliterator<P_IN>) new StreamSpliterators\n-                        .SliceSpliterator.OfDouble((Spliterator.OfDouble) s, skip, sliceFence);\n-            default:\n-                throw new IllegalStateException(\"Unknown shape \" + shape);\n-        }\n+        @SuppressWarnings(\"unchecked\")\n+        Spliterator<P_IN> sliceSpliterator = (Spliterator<P_IN>) switch (shape) {\n+            case REFERENCE\n+                -> new StreamSpliterators.SliceSpliterator.OfRef<>(s, skip, sliceFence);\n+            case INT_VALUE\n+                -> new StreamSpliterators.SliceSpliterator.OfInt((Spliterator.OfInt) s, skip, sliceFence);\n+            case LONG_VALUE\n+                -> new StreamSpliterators.SliceSpliterator.OfLong((Spliterator.OfLong) s, skip, sliceFence);\n+            case DOUBLE_VALUE\n+                -> new StreamSpliterators.SliceSpliterator.OfDouble((Spliterator.OfDouble) s, skip, sliceFence);\n+        };\n+        return sliceSpliterator;\n@@ -113,0 +108,1 @@\n+        long adjustedLimit = limit >= 0 ? limit : Long.MAX_VALUE;\n@@ -116,0 +112,6 @@\n+            @Override\n+            long adjustSize(long size) {\n+                return isParallel() ? super.adjustSize(size)\n+                    : calcSize(super.adjustSize(size), skip, adjustedLimit);\n+            }\n+\n@@ -185,1 +187,1 @@\n-                return new Sink.ChainedReference<T, T>(sink) {\n+                return new Sink.ChainedReference<>(sink) {\n@@ -187,1 +189,1 @@\n-                    long m = limit >= 0 ? limit : Long.MAX_VALUE;\n+                    long m = adjustedLimit;\n@@ -229,0 +231,1 @@\n+        long adjustedLimit = limit >= 0 ? limit : Long.MAX_VALUE;\n@@ -232,0 +235,6 @@\n+            @Override\n+            long adjustSize(long size) {\n+                return isParallel() ? super.adjustSize(size)\n+                    : calcSize(super.adjustSize(size), skip, adjustedLimit);\n+            }\n+\n@@ -294,1 +303,1 @@\n-                return new Sink.ChainedInt<Integer>(sink) {\n+                return new Sink.ChainedInt<>(sink) {\n@@ -296,1 +305,1 @@\n-                    long m = limit >= 0 ? limit : Long.MAX_VALUE;\n+                    long m = adjustedLimit;\n@@ -338,0 +347,1 @@\n+        long adjustedLimit = limit >= 0 ? limit : Long.MAX_VALUE;\n@@ -341,0 +351,6 @@\n+            @Override\n+            long adjustSize(long size) {\n+                return isParallel() ? super.adjustSize(size)\n+                    : calcSize(super.adjustSize(size), skip, adjustedLimit);\n+            }\n+\n@@ -403,1 +419,1 @@\n-                return new Sink.ChainedLong<Long>(sink) {\n+                return new Sink.ChainedLong<>(sink) {\n@@ -405,1 +421,1 @@\n-                    long m = limit >= 0 ? limit : Long.MAX_VALUE;\n+                    long m = adjustedLimit;\n@@ -447,0 +463,1 @@\n+        long adjustedLimit = limit >= 0 ? limit : Long.MAX_VALUE;\n@@ -450,0 +467,6 @@\n+            @Override\n+            long adjustSize(long size) {\n+                return isParallel() ? super.adjustSize(size)\n+                    : calcSize(super.adjustSize(size), skip, adjustedLimit);\n+            }\n+\n@@ -512,1 +535,1 @@\n-                return new Sink.ChainedDouble<Double>(sink) {\n+                return new Sink.ChainedDouble<>(sink) {\n@@ -514,1 +537,1 @@\n-                    long m = limit >= 0 ? limit : Long.MAX_VALUE;\n+                    long m = adjustedLimit;\n@@ -544,1 +567,1 @@\n-        return StreamOpFlag.NOT_SIZED | ((limit != -1) ? StreamOpFlag.IS_SHORT_CIRCUIT : 0);\n+        return (limit != -1) ? StreamOpFlag.IS_SHORT_CIRCUIT : 0;\n","filename":"src\/java.base\/share\/classes\/java\/util\/stream\/SliceOps.java","additions":51,"deletions":28,"binary":false,"changes":79,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -220,1 +220,1 @@\n-            init();\n+            long exactSizeIfKnown = getExactSizeIfKnown();\n@@ -224,1 +224,1 @@\n-            return spliterator.estimateSize();\n+            return exactSizeIfKnown == -1 ? spliterator.estimateSize() : exactSizeIfKnown;\n@@ -230,3 +230,1 @@\n-            return StreamOpFlag.SIZED.isKnown(ph.getStreamAndOpFlags())\n-                   ? spliterator.getExactSizeIfKnown()\n-                   : -1;\n+            return ph.exactOutputSizeIfKnown(spliterator);\n","filename":"src\/java.base\/share\/classes\/java\/util\/stream\/StreamSpliterators.java","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n- * @bug 8031187 8067969 8075307\n+ * @bug 8031187 8067969 8075307 8265029\n@@ -59,0 +59,5 @@\n+        withData(data).\n+                terminal(s -> s.skip(1), Stream::count).\n+                expectedResult(Math.max(0, expectedCount - 1)).\n+                exercise();\n+\n@@ -94,0 +99,5 @@\n+        withData(data).\n+            terminal(s -> s.skip(1), IntStream::count).\n+            expectedResult(Math.max(0, expectedCount - 1)).\n+            exercise();\n+\n@@ -119,0 +129,5 @@\n+        withData(data).\n+            terminal(s -> s.skip(1), LongStream::count).\n+            expectedResult(Math.max(0, expectedCount - 1)).\n+            exercise();\n+\n@@ -144,0 +159,5 @@\n+        withData(data).\n+            terminal(s -> s.skip(1), DoubleStream::count).\n+            expectedResult(Math.max(0, expectedCount - 1)).\n+            exercise();\n+\n@@ -163,1 +183,8 @@\n-            Stream.of(1, 2, 3, 4).peek(e -> ai.getAndIncrement()).count();\n+            assertEquals(Stream.of(1, 2, 3, 4).peek(e -> ai.getAndIncrement()).count(), 4);\n+            assertEquals(ai.get(), 0);\n+\n+            assertEquals(Stream.of(1, 2, 3, 4).peek(e -> ai.getAndIncrement()).parallel().count(), 4);\n+            assertEquals(ai.get(), 0);\n+\n+            assertEquals(Stream.of(1, 2, 3, 4).peek(e -> ai.getAndIncrement())\n+                .skip(1).limit(2).skip(1).count(), 1);\n@@ -166,1 +193,2 @@\n-            Stream.of(1, 2, 3, 4).peek(e -> ai.getAndIncrement()).parallel().count();\n+            assertEquals(Stream.of(1, 2, 3, 4).peek(e -> ai.getAndIncrement())\n+                .parallel().skip(1).limit(2).skip(1).count(), 1);\n@@ -172,1 +200,1 @@\n-            IntStream.of(1, 2, 3, 4).peek(e -> ai.getAndIncrement()).count();\n+            assertEquals(IntStream.of(1, 2, 3, 4).peek(e -> ai.getAndIncrement()).count(), 4);\n@@ -175,1 +203,9 @@\n-            IntStream.of(1, 2, 3, 4).peek(e -> ai.getAndIncrement()).parallel().count();\n+            assertEquals(IntStream.of(1, 2, 3, 4).peek(e -> ai.getAndIncrement()).parallel().count(), 4);\n+            assertEquals(ai.get(), 0);\n+\n+            assertEquals(IntStream.of(1, 2, 3, 4).peek(e -> ai.getAndIncrement())\n+                .skip(1).limit(2).skip(1).count(), 1);\n+            assertEquals(ai.get(), 0);\n+\n+            assertEquals(IntStream.of(1, 2, 3, 4).peek(e -> ai.getAndIncrement())\n+                .parallel().skip(1).limit(2).skip(1).count(), 1);\n@@ -181,1 +217,4 @@\n-            LongStream.of(1, 2, 3, 4).peek(e -> ai.getAndIncrement()).count();\n+            assertEquals(LongStream.of(1, 2, 3, 4).peek(e -> ai.getAndIncrement()).count(), 4);\n+            assertEquals(ai.get(), 0);\n+\n+            assertEquals(LongStream.of(1, 2, 3, 4).peek(e -> ai.getAndIncrement()).parallel().count(), 4);\n@@ -184,1 +223,6 @@\n-            LongStream.of(1, 2, 3, 4).peek(e -> ai.getAndIncrement()).parallel().count();\n+            assertEquals(LongStream.of(1, 2, 3, 4).peek(e -> ai.getAndIncrement())\n+                .skip(1).limit(2).skip(1).count(), 1);\n+            assertEquals(ai.get(), 0);\n+\n+            assertEquals(LongStream.of(1, 2, 3, 4).peek(e -> ai.getAndIncrement())\n+                .parallel().skip(1).limit(2).skip(1).count(), 1);\n@@ -195,0 +239,8 @@\n+\n+            assertEquals(DoubleStream.of(1, 2, 3, 4).peek(e -> ai.getAndIncrement())\n+                .skip(1).limit(2).skip(1).count(), 1);\n+            assertEquals(ai.get(), 0);\n+\n+            assertEquals(DoubleStream.of(1, 2, 3, 4).peek(e -> ai.getAndIncrement())\n+                .parallel().skip(1).limit(2).skip(1).count(), 1);\n+            assertEquals(ai.get(), 0);\n","filename":"test\/jdk\/java\/util\/stream\/test\/org\/openjdk\/tests\/java\/util\/stream\/CountTest.java","additions":60,"deletions":8,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8148250\n+ * @bug 8148250 8265029\n@@ -359,0 +359,22 @@\n+\n+    public void testSliceOpsSpliteratorPreservesSized() {\n+        var parSpliterator = IntStream.range(0, 1000).parallel().skip(50).limit(800).spliterator();\n+        assertTrue(parSpliterator.hasCharacteristics(Spliterator.SIZED));\n+        assertTrue(parSpliterator.hasCharacteristics(Spliterator.SUBSIZED));\n+        assertEquals(parSpliterator.getExactSizeIfKnown(), 800);\n+        \/\/ Original spliterator is split to [0..499] and [500..999] parts\n+        \/\/ due to skip+limit, we have [50..499] and [500..849]\n+        var prefix = parSpliterator.trySplit();\n+        assertNotNull(prefix);\n+        assertTrue(parSpliterator.hasCharacteristics(Spliterator.SIZED));\n+        assertTrue(parSpliterator.hasCharacteristics(Spliterator.SUBSIZED));\n+        assertEquals(parSpliterator.getExactSizeIfKnown(), 350);\n+        assertTrue(prefix.hasCharacteristics(Spliterator.SIZED));\n+        assertTrue(prefix.hasCharacteristics(Spliterator.SUBSIZED));\n+        assertEquals(prefix.getExactSizeIfKnown(), 450);\n+\n+        var seqSpliterator = IntStream.range(0, 1000).skip(50).limit(800).spliterator();\n+        assertTrue(seqSpliterator.hasCharacteristics(Spliterator.SIZED));\n+        assertTrue(seqSpliterator.hasCharacteristics(Spliterator.SUBSIZED));\n+        assertEquals(seqSpliterator.getExactSizeIfKnown(), 800);\n+    }\n","filename":"test\/jdk\/java\/util\/stream\/test\/org\/openjdk\/tests\/java\/util\/stream\/SliceOpTest.java","additions":24,"deletions":2,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -0,0 +1,98 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.util.stream.ops.ref;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.State;\n+\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.IntStream;\n+\n+\/**\n+ * Benchmark for limit()\/skip() operation in sized streams.\n+ *\/\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.SECONDS)\n+@State(Scope.Thread)\n+public class SliceToList {\n+\n+    @Param(\"10000\")\n+    private int size;\n+\n+    @Benchmark\n+    public List<String> seq_baseline() {\n+        return IntStream.range(0, size)\n+                .mapToObj(x -> \"x\")\n+                .toList();\n+    }\n+\n+    @Benchmark\n+    public List<String> seq_limit() {\n+        return IntStream.range(0, size * 2)\n+                .mapToObj(x -> \"x\")\n+                .limit(size)\n+                .toList();\n+    }\n+\n+    @Benchmark\n+    public List<String> seq_skipLimit() {\n+        return IntStream.range(0, size * 2)\n+                .mapToObj(x -> \"x\")\n+                .skip(1)\n+                .limit(size)\n+                .toList();\n+    }\n+\n+    @Benchmark\n+    public List<String> par_baseline() {\n+        return IntStream.range(0, size)\n+                .parallel()\n+                .mapToObj(x -> \"x\")\n+                .toList();\n+    }\n+\n+    @Benchmark\n+    public List<String> par_limit() {\n+        return IntStream.range(0, size * 2)\n+                .parallel()\n+                .mapToObj(x -> \"x\")\n+                .limit(size)\n+                .toList();\n+    }\n+\n+    @Benchmark\n+    public List<String> par_skipLimit() {\n+        return IntStream.range(0, size * 2)\n+                .parallel()\n+                .mapToObj(x -> \"x\")\n+                .skip(1)\n+                .limit(size)\n+                .toList();\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/stream\/ops\/ref\/SliceToList.java","additions":98,"deletions":0,"binary":false,"changes":98,"status":"added"},{"patch":"@@ -0,0 +1,92 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.util.stream.ops.value;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.State;\n+\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.IntStream;\n+\n+\/**\n+ * Benchmark for limit()\/skip() operation in sized streams.\n+ *\/\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.SECONDS)\n+@State(Scope.Thread)\n+public class SliceToArray {\n+\n+    @Param(\"10000\")\n+    private int size;\n+\n+    @Benchmark\n+    public int[] seq_baseline() {\n+        return IntStream.range(0, size)\n+                .toArray();\n+    }\n+\n+    @Benchmark\n+    public int[] seq_limit() {\n+        return IntStream.range(0, size * 2)\n+                .limit(size)\n+                .toArray();\n+    }\n+\n+    @Benchmark\n+    public int[] seq_skipLimit() {\n+        return IntStream.range(0, size * 2)\n+                .skip(1)\n+                .limit(size)\n+                .toArray();\n+    }\n+\n+    @Benchmark\n+    public int[] par_baseline() {\n+        return IntStream.range(0, size)\n+                .parallel()\n+                .toArray();\n+    }\n+\n+    @Benchmark\n+    public int[] par_limit() {\n+        return IntStream.range(0, size * 2)\n+                .parallel()\n+                .limit(size)\n+                .toArray();\n+    }\n+\n+    @Benchmark\n+    public int[] par_skipLimit() {\n+        return IntStream.range(0, size * 2)\n+                .parallel()\n+                .skip(1)\n+                .limit(size)\n+                .toArray();\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/stream\/ops\/value\/SliceToArray.java","additions":92,"deletions":0,"binary":false,"changes":92,"status":"added"}]}