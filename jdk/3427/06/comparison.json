{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -469,1 +469,18 @@\n-        return StreamOpFlag.SIZED.isKnown(getStreamAndOpFlags()) ? spliterator.getExactSizeIfKnown() : -1;\n+        int flags = getStreamAndOpFlags();\n+        long size = StreamOpFlag.SIZED.isKnown(flags) ? spliterator.getExactSizeIfKnown() : -1;\n+        if (size != -1 && StreamOpFlag.SIZE_ADJUSTING.isKnown(flags) && !isParallel()) {\n+            for (AbstractPipeline<?, ?, ?> stage = sourceStage.nextStage; stage != null; stage = stage.nextStage) {\n+                size = stage.exactOutputSize(size);\n+            }\n+        }\n+        return size;\n+    }\n+\n+    \/**\n+     * Returns the exact output size of the pipeline given the exact size reported by the previous stage.\n+     *\n+     * @param previousSize the exact size reported by the previous stage\n+     * @return the output size of this stage\n+     *\/\n+    long exactOutputSize(long previousSize) {\n+        return previousSize;\n","filename":"src\/java.base\/share\/classes\/java\/util\/stream\/AbstractPipeline.java","additions":19,"deletions":2,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -85,1 +85,2 @@\n-     * flags.\n+     * flags. The exact output size may differ from spliterator size,\n+     * if pipeline contains a slice operation.\n","filename":"src\/java.base\/share\/classes\/java\/util\/stream\/PipelineHelper.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -255,2 +255,3 @@\n-                if (StreamOpFlag.SIZED.isKnown(helper.getStreamAndOpFlags()))\n-                    return spliterator.getExactSizeIfKnown();\n+                long size = helper.exactOutputSizeIfKnown(spliterator);\n+                if (size != -1)\n+                    return size;\n@@ -263,2 +264,3 @@\n-                if (StreamOpFlag.SIZED.isKnown(helper.getStreamAndOpFlags()))\n-                    return spliterator.getExactSizeIfKnown();\n+                long size = helper.exactOutputSizeIfKnown(spliterator);\n+                if (size != -1)\n+                    return size;\n@@ -429,2 +431,3 @@\n-                if (StreamOpFlag.SIZED.isKnown(helper.getStreamAndOpFlags()))\n-                    return spliterator.getExactSizeIfKnown();\n+                long size = helper.exactOutputSizeIfKnown(spliterator);\n+                if (size != -1)\n+                    return size;\n@@ -437,2 +440,3 @@\n-                if (StreamOpFlag.SIZED.isKnown(helper.getStreamAndOpFlags()))\n-                    return spliterator.getExactSizeIfKnown();\n+                long size = helper.exactOutputSizeIfKnown(spliterator);\n+                if (size != -1)\n+                    return size;\n@@ -603,2 +607,3 @@\n-                if (StreamOpFlag.SIZED.isKnown(helper.getStreamAndOpFlags()))\n-                    return spliterator.getExactSizeIfKnown();\n+                long size = helper.exactOutputSizeIfKnown(spliterator);\n+                if (size != -1)\n+                    return size;\n@@ -611,2 +616,3 @@\n-                if (StreamOpFlag.SIZED.isKnown(helper.getStreamAndOpFlags()))\n-                    return spliterator.getExactSizeIfKnown();\n+                long size = helper.exactOutputSizeIfKnown(spliterator);\n+                if (size != -1)\n+                    return size;\n@@ -777,2 +783,3 @@\n-                if (StreamOpFlag.SIZED.isKnown(helper.getStreamAndOpFlags()))\n-                    return spliterator.getExactSizeIfKnown();\n+                long size = helper.exactOutputSizeIfKnown(spliterator);\n+                if (size != -1)\n+                    return size;\n@@ -785,2 +792,3 @@\n-                if (StreamOpFlag.SIZED.isKnown(helper.getStreamAndOpFlags()))\n-                    return spliterator.getExactSizeIfKnown();\n+                long size = helper.exactOutputSizeIfKnown(spliterator);\n+                if (size != -1)\n+                    return size;\n","filename":"src\/java.base\/share\/classes\/java\/util\/stream\/ReduceOps.java","additions":25,"deletions":17,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,1 +53,1 @@\n-        return size >= 0 ? Math.max(-1, Math.min(size - skip, limit)) : -1;\n+        return size >= 0 ? Math.max(0, Math.min(size - skip, limit)) : -1;\n@@ -75,1 +75,0 @@\n-    @SuppressWarnings(\"unchecked\")\n@@ -81,16 +80,12 @@\n-        switch (shape) {\n-            case REFERENCE:\n-                return new StreamSpliterators\n-                        .SliceSpliterator.OfRef<>(s, skip, sliceFence);\n-            case INT_VALUE:\n-                return (Spliterator<P_IN>) new StreamSpliterators\n-                        .SliceSpliterator.OfInt((Spliterator.OfInt) s, skip, sliceFence);\n-            case LONG_VALUE:\n-                return (Spliterator<P_IN>) new StreamSpliterators\n-                        .SliceSpliterator.OfLong((Spliterator.OfLong) s, skip, sliceFence);\n-            case DOUBLE_VALUE:\n-                return (Spliterator<P_IN>) new StreamSpliterators\n-                        .SliceSpliterator.OfDouble((Spliterator.OfDouble) s, skip, sliceFence);\n-            default:\n-                throw new IllegalStateException(\"Unknown shape \" + shape);\n-        }\n+        @SuppressWarnings(\"unchecked\")\n+        Spliterator<P_IN> sliceSpliterator = (Spliterator<P_IN>) switch (shape) {\n+            case REFERENCE\n+                -> new StreamSpliterators.SliceSpliterator.OfRef<>(s, skip, sliceFence);\n+            case INT_VALUE\n+                -> new StreamSpliterators.SliceSpliterator.OfInt((Spliterator.OfInt) s, skip, sliceFence);\n+            case LONG_VALUE\n+                -> new StreamSpliterators.SliceSpliterator.OfLong((Spliterator.OfLong) s, skip, sliceFence);\n+            case DOUBLE_VALUE\n+                -> new StreamSpliterators.SliceSpliterator.OfDouble((Spliterator.OfDouble) s, skip, sliceFence);\n+        };\n+        return sliceSpliterator;\n@@ -113,0 +108,1 @@\n+        long normalizedLimit = limit >= 0 ? limit : Long.MAX_VALUE;\n@@ -116,0 +112,5 @@\n+            @Override\n+            long exactOutputSize(long previousSize) {\n+                return calcSize(previousSize, skip, normalizedLimit);\n+            }\n+\n@@ -185,1 +186,1 @@\n-                return new Sink.ChainedReference<T, T>(sink) {\n+                return new Sink.ChainedReference<>(sink) {\n@@ -187,1 +188,1 @@\n-                    long m = limit >= 0 ? limit : Long.MAX_VALUE;\n+                    long m = normalizedLimit;\n@@ -229,0 +230,1 @@\n+        long normalizedLimit = limit >= 0 ? limit : Long.MAX_VALUE;\n@@ -232,0 +234,5 @@\n+            @Override\n+            long exactOutputSize(long previousSize) {\n+                return calcSize(previousSize, skip, normalizedLimit);\n+            }\n+\n@@ -294,1 +301,1 @@\n-                return new Sink.ChainedInt<Integer>(sink) {\n+                return new Sink.ChainedInt<>(sink) {\n@@ -296,1 +303,1 @@\n-                    long m = limit >= 0 ? limit : Long.MAX_VALUE;\n+                    long m = normalizedLimit;\n@@ -338,0 +345,1 @@\n+        long normalizedLimit = limit >= 0 ? limit : Long.MAX_VALUE;\n@@ -341,0 +349,5 @@\n+            @Override\n+            long exactOutputSize(long previousSize) {\n+                return calcSize(previousSize, skip, normalizedLimit);\n+            }\n+\n@@ -403,1 +416,1 @@\n-                return new Sink.ChainedLong<Long>(sink) {\n+                return new Sink.ChainedLong<>(sink) {\n@@ -405,1 +418,1 @@\n-                    long m = limit >= 0 ? limit : Long.MAX_VALUE;\n+                    long m = normalizedLimit;\n@@ -447,0 +460,1 @@\n+        long normalizedLimit = limit >= 0 ? limit : Long.MAX_VALUE;\n@@ -450,0 +464,5 @@\n+            @Override\n+            long exactOutputSize(long previousSize) {\n+                return calcSize(previousSize, skip, normalizedLimit);\n+            }\n+\n@@ -512,1 +531,1 @@\n-                return new Sink.ChainedDouble<Double>(sink) {\n+                return new Sink.ChainedDouble<>(sink) {\n@@ -514,1 +533,1 @@\n-                    long m = limit >= 0 ? limit : Long.MAX_VALUE;\n+                    long m = normalizedLimit;\n@@ -544,1 +563,1 @@\n-        return StreamOpFlag.NOT_SIZED | ((limit != -1) ? StreamOpFlag.IS_SHORT_CIRCUIT : 0);\n+        return StreamOpFlag.IS_SIZE_ADJUSTING | ((limit != -1) ? StreamOpFlag.IS_SHORT_CIRCUIT : 0);\n","filename":"src\/java.base\/share\/classes\/java\/util\/stream\/SliceOps.java","additions":47,"deletions":28,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -328,1 +328,11 @@\n-                  set(Type.OP).set(Type.TERMINAL_OP));\n+                  set(Type.OP).set(Type.TERMINAL_OP)),\n+\n+    \/**\n+     * Characteristic value signifying that an operation may adjust the\n+     * total size of the stream.\n+     * <p>\n+     * An intermediate operation can preserve or inject this value.\n+     *\/\n+    \/\/ 13, 0x04000000\n+    SIZE_ADJUSTING(13,\n+                   set(Type.OP));\n@@ -333,1 +343,0 @@\n-    \/\/ 13, 0x04000000\n@@ -632,0 +641,5 @@\n+    \/**\n+     * The bit value to inject {@link #SIZE_ADJUSTING}.\n+     *\/\n+    static final int IS_SIZE_ADJUSTING = SIZE_ADJUSTING.set;\n+\n","filename":"src\/java.base\/share\/classes\/java\/util\/stream\/StreamOpFlag.java","additions":16,"deletions":2,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -220,1 +220,1 @@\n-            init();\n+            long exactSizeIfKnown = getExactSizeIfKnown();\n@@ -224,1 +224,1 @@\n-            return spliterator.estimateSize();\n+            return exactSizeIfKnown == -1 ? spliterator.estimateSize() : exactSizeIfKnown;\n@@ -230,3 +230,1 @@\n-            return StreamOpFlag.SIZED.isKnown(ph.getStreamAndOpFlags())\n-                   ? spliterator.getExactSizeIfKnown()\n-                   : -1;\n+            return ph.exactOutputSizeIfKnown(spliterator);\n","filename":"src\/java.base\/share\/classes\/java\/util\/stream\/StreamSpliterators.java","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n- * @bug 8031187 8067969 8075307\n+ * @bug 8031187 8067969 8075307 8265029\n@@ -34,0 +34,1 @@\n+import java.util.function.Supplier;\n@@ -59,0 +60,5 @@\n+        withData(data).\n+                terminal(s -> s.skip(1), Stream::count).\n+                expectedResult(Math.max(0, expectedCount - 1)).\n+                exercise();\n+\n@@ -94,0 +100,5 @@\n+        withData(data).\n+            terminal(s -> s.skip(1), IntStream::count).\n+            expectedResult(Math.max(0, expectedCount - 1)).\n+            exercise();\n+\n@@ -119,0 +130,5 @@\n+        withData(data).\n+            terminal(s -> s.skip(1), LongStream::count).\n+            expectedResult(Math.max(0, expectedCount - 1)).\n+            exercise();\n+\n@@ -144,0 +160,5 @@\n+        withData(data).\n+            terminal(s -> s.skip(1), DoubleStream::count).\n+            expectedResult(Math.max(0, expectedCount - 1)).\n+            exercise();\n+\n@@ -160,0 +181,1 @@\n+    @Test\n@@ -161,35 +183,44 @@\n-        {\n-            AtomicInteger ai = new AtomicInteger();\n-            Stream.of(1, 2, 3, 4).peek(e -> ai.getAndIncrement()).count();\n-            assertEquals(ai.get(), 0);\n-\n-            Stream.of(1, 2, 3, 4).peek(e -> ai.getAndIncrement()).parallel().count();\n-            assertEquals(ai.get(), 0);\n-        }\n-\n-        {\n-            AtomicInteger ai = new AtomicInteger();\n-            IntStream.of(1, 2, 3, 4).peek(e -> ai.getAndIncrement()).count();\n-            assertEquals(ai.get(), 0);\n-\n-            IntStream.of(1, 2, 3, 4).peek(e -> ai.getAndIncrement()).parallel().count();\n-            assertEquals(ai.get(), 0);\n-        }\n-\n-        {\n-            AtomicInteger ai = new AtomicInteger();\n-            LongStream.of(1, 2, 3, 4).peek(e -> ai.getAndIncrement()).count();\n-            assertEquals(ai.get(), 0);\n-\n-            LongStream.of(1, 2, 3, 4).peek(e -> ai.getAndIncrement()).parallel().count();\n-            assertEquals(ai.get(), 0);\n-        }\n-\n-        {\n-            AtomicInteger ai = new AtomicInteger();\n-            DoubleStream.of(1, 2, 3, 4).peek(e -> ai.getAndIncrement()).count();\n-            assertEquals(ai.get(), 0);\n-\n-            DoubleStream.of(1, 2, 3, 4).peek(e -> ai.getAndIncrement()).parallel().count();\n-            assertEquals(ai.get(), 0);\n-        }\n+        checkStreamDoesNotConsumeElements(() -> Stream.of(1, 2, 3, 4), 4);\n+        checkStreamDoesNotConsumeElements(() -> Stream.of(1, 2, 3, 4).skip(1).limit(2).skip(1), 1);\n+        checkIntStreamDoesNotConsumeElements(() -> IntStream.of(1, 2, 3, 4), 4);\n+        checkIntStreamDoesNotConsumeElements(() -> IntStream.of(1, 2, 3, 4).skip(1).limit(2).skip(1), 1);\n+        checkLongStreamDoesNotConsumeElements(() -> LongStream.of(1, 2, 3, 4), 4);\n+        checkLongStreamDoesNotConsumeElements(() -> LongStream.of(1, 2, 3, 4).skip(1).limit(2).skip(1), 1);\n+        checkDoubleStreamDoesNotConsumeElements(() -> DoubleStream.of(1, 2, 3, 4), 4);\n+        checkDoubleStreamDoesNotConsumeElements(() -> DoubleStream.of(1, 2, 3, 4).skip(1).limit(2).skip(1), 1);\n+    }\n+\n+    private void checkStreamDoesNotConsumeElements(Supplier<Stream<?>> supplier, long expectedCount) {\n+        AtomicInteger ai = new AtomicInteger();\n+        assertEquals(supplier.get().peek(e -> ai.getAndIncrement()).count(), expectedCount);\n+        assertEquals(ai.get(), 0);\n+\n+        assertEquals(supplier.get().peek(e -> ai.getAndIncrement()).parallel().count(), expectedCount);\n+        assertEquals(ai.get(), 0);\n+    }\n+\n+    private void checkIntStreamDoesNotConsumeElements(Supplier<IntStream> supplier, long expectedCount) {\n+        AtomicInteger ai = new AtomicInteger();\n+        assertEquals(supplier.get().peek(e -> ai.getAndIncrement()).count(), expectedCount);\n+        assertEquals(ai.get(), 0);\n+\n+        assertEquals(supplier.get().peek(e -> ai.getAndIncrement()).parallel().count(), expectedCount);\n+        assertEquals(ai.get(), 0);\n+    }\n+\n+    private void checkLongStreamDoesNotConsumeElements(Supplier<LongStream> supplier, long expectedCount) {\n+        AtomicInteger ai = new AtomicInteger();\n+        assertEquals(supplier.get().peek(e -> ai.getAndIncrement()).count(), expectedCount);\n+        assertEquals(ai.get(), 0);\n+\n+        assertEquals(supplier.get().peek(e -> ai.getAndIncrement()).parallel().count(), expectedCount);\n+        assertEquals(ai.get(), 0);\n+    }\n+\n+    private void checkDoubleStreamDoesNotConsumeElements(Supplier<DoubleStream> supplier, long expectedCount) {\n+        AtomicInteger ai = new AtomicInteger();\n+        assertEquals(supplier.get().peek(e -> ai.getAndIncrement()).count(), expectedCount);\n+        assertEquals(ai.get(), 0);\n+\n+        assertEquals(supplier.get().peek(e -> ai.getAndIncrement()).parallel().count(), expectedCount);\n+        assertEquals(ai.get(), 0);\n","filename":"test\/jdk\/java\/util\/stream\/test\/org\/openjdk\/tests\/java\/util\/stream\/CountTest.java","additions":68,"deletions":37,"binary":false,"changes":105,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8148250\n+ * @bug 8148250 8265029\n@@ -359,0 +359,22 @@\n+\n+    public void testSliceOpsSpliteratorPreservesSized() {\n+        var parSpliterator = IntStream.range(0, 1000).parallel().skip(50).limit(800).spliterator();\n+        assertTrue(parSpliterator.hasCharacteristics(Spliterator.SIZED));\n+        assertTrue(parSpliterator.hasCharacteristics(Spliterator.SUBSIZED));\n+        assertEquals(parSpliterator.getExactSizeIfKnown(), 800);\n+        \/\/ Original spliterator is split to [0..499] and [500..999] parts\n+        \/\/ due to skip+limit, we have [50..499] and [500..849]\n+        var prefix = parSpliterator.trySplit();\n+        assertNotNull(prefix);\n+        assertTrue(parSpliterator.hasCharacteristics(Spliterator.SIZED));\n+        assertTrue(parSpliterator.hasCharacteristics(Spliterator.SUBSIZED));\n+        assertEquals(parSpliterator.getExactSizeIfKnown(), 350);\n+        assertTrue(prefix.hasCharacteristics(Spliterator.SIZED));\n+        assertTrue(prefix.hasCharacteristics(Spliterator.SUBSIZED));\n+        assertEquals(prefix.getExactSizeIfKnown(), 450);\n+\n+        var seqSpliterator = IntStream.range(0, 1000).skip(50).limit(800).spliterator();\n+        assertTrue(seqSpliterator.hasCharacteristics(Spliterator.SIZED));\n+        assertTrue(seqSpliterator.hasCharacteristics(Spliterator.SUBSIZED));\n+        assertEquals(seqSpliterator.getExactSizeIfKnown(), 800);\n+    }\n","filename":"test\/jdk\/java\/util\/stream\/test\/org\/openjdk\/tests\/java\/util\/stream\/SliceOpTest.java","additions":24,"deletions":2,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -0,0 +1,98 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.util.stream.ops.ref;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.State;\n+\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.IntStream;\n+\n+\/**\n+ * Benchmark for limit()\/skip() operation in sized streams.\n+ *\/\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.SECONDS)\n+@State(Scope.Thread)\n+public class SliceToList {\n+\n+    @Param(\"10000\")\n+    private int size;\n+\n+    @Benchmark\n+    public List<String> seq_baseline() {\n+        return IntStream.range(0, size)\n+                .mapToObj(x -> \"x\")\n+                .toList();\n+    }\n+\n+    @Benchmark\n+    public List<String> seq_limit() {\n+        return IntStream.range(0, size * 2)\n+                .mapToObj(x -> \"x\")\n+                .limit(size)\n+                .toList();\n+    }\n+\n+    @Benchmark\n+    public List<String> seq_skipLimit() {\n+        return IntStream.range(0, size * 2)\n+                .mapToObj(x -> \"x\")\n+                .skip(1)\n+                .limit(size)\n+                .toList();\n+    }\n+\n+    @Benchmark\n+    public List<String> par_baseline() {\n+        return IntStream.range(0, size)\n+                .parallel()\n+                .mapToObj(x -> \"x\")\n+                .toList();\n+    }\n+\n+    @Benchmark\n+    public List<String> par_limit() {\n+        return IntStream.range(0, size * 2)\n+                .parallel()\n+                .mapToObj(x -> \"x\")\n+                .limit(size)\n+                .toList();\n+    }\n+\n+    @Benchmark\n+    public List<String> par_skipLimit() {\n+        return IntStream.range(0, size * 2)\n+                .parallel()\n+                .mapToObj(x -> \"x\")\n+                .skip(1)\n+                .limit(size)\n+                .toList();\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/stream\/ops\/ref\/SliceToList.java","additions":98,"deletions":0,"binary":false,"changes":98,"status":"added"},{"patch":"@@ -0,0 +1,152 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.util.stream.ops.value;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.DoubleStream;\n+import java.util.stream.IntStream;\n+import java.util.stream.LongStream;\n+import java.util.stream.Stream;\n+\n+\/**\n+ * Benchmark for count operation in sized streams.\n+ *\/\n+@Fork(5)\n+@Warmup(iterations = 10, time = 1000, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 20, time = 1000, timeUnit = TimeUnit.MILLISECONDS)\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Thread)\n+public class SizedCount {\n+    @Param(\"10000\")\n+    private int size;\n+\n+    @Param({\"true\", \"false\"})\n+    private boolean polluteTypeProfile;\n+\n+    @Setup\n+    public void setup() {\n+        if (!polluteTypeProfile) return;\n+        for(int i=0; i<10000; i++) {\n+            IntStream.empty().skip(1).count();\n+            LongStream.empty().skip(1).count();\n+            DoubleStream.empty().skip(1).count();\n+            Stream.empty().skip(1).count();\n+        }\n+    }\n+\n+    @Benchmark\n+    public long count0() {\n+        return IntStream.range(0, size)\n+            .count();\n+    }\n+\n+    @Benchmark\n+    public long count2() {\n+        return IntStream.range(0, size)\n+            .map(x -> x)\n+            .map(x -> x)\n+            .count();\n+    }\n+\n+    @Benchmark\n+    public long count4() {\n+        return IntStream.range(0, size)\n+            .map(x -> x)\n+            .map(x -> x)\n+            .map(x -> x)\n+            .map(x -> x)\n+            .count();\n+    }\n+\n+    @Benchmark\n+    public long count6() {\n+        return IntStream.range(0, size)\n+            .map(x -> x)\n+            .map(x -> x)\n+            .map(x -> x)\n+            .map(x -> x)\n+            .map(x -> x)\n+            .map(x -> x)\n+            .count();\n+    }\n+\n+    @Benchmark\n+    public long count8() {\n+        return IntStream.range(0, size)\n+            .map(x -> x)\n+            .map(x -> x)\n+            .map(x -> x)\n+            .map(x -> x)\n+            .map(x -> x)\n+            .map(x -> x)\n+            .map(x -> x)\n+            .map(x -> x)\n+            .count();\n+    }\n+\n+    @Benchmark\n+    public long count10() {\n+        return IntStream.range(0, size)\n+            .map(x -> x)\n+            .map(x -> x)\n+            .map(x -> x)\n+            .map(x -> x)\n+            .map(x -> x)\n+            .map(x -> x)\n+            .map(x -> x)\n+            .map(x -> x)\n+            .map(x -> x)\n+            .map(x -> x)\n+            .count();\n+    }\n+\n+    @Benchmark\n+    public long count10Skip() {\n+        return IntStream.range(0, size)\n+            .skip(1)\n+            .map(x -> x)\n+            .map(x -> x)\n+            .map(x -> x)\n+            .map(x -> x)\n+            .map(x -> x)\n+            .map(x -> x)\n+            .map(x -> x)\n+            .map(x -> x)\n+            .map(x -> x)\n+            .map(x -> x)\n+            .count();\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/stream\/ops\/value\/SizedCount.java","additions":152,"deletions":0,"binary":false,"changes":152,"status":"added"},{"patch":"@@ -0,0 +1,152 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.util.stream.ops.value;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.DoubleStream;\n+import java.util.stream.IntStream;\n+import java.util.stream.LongStream;\n+import java.util.stream.Stream;\n+\n+\/**\n+ * Benchmark for sum operation in sized streams.\n+ *\/\n+@Fork(5)\n+@Warmup(iterations = 10, time = 1000, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 20, time = 1000, timeUnit = TimeUnit.MILLISECONDS)\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Thread)\n+public class SizedSum {\n+    @Param({\"5\", \"10\"})\n+    private int size;\n+\n+    @Param({\"true\", \"false\"})\n+    private boolean polluteTypeProfile;\n+\n+    @Setup\n+    public void setup() {\n+        if (!polluteTypeProfile) return;\n+        for(int i=0; i<10000; i++) {\n+            IntStream.empty().skip(1).count();\n+            LongStream.empty().skip(1).count();\n+            DoubleStream.empty().skip(1).count();\n+            Stream.empty().skip(1).count();\n+        }\n+    }\n+\n+    @Benchmark\n+    public long sum0() {\n+        return IntStream.range(0, size)\n+            .sum();\n+    }\n+\n+    @Benchmark\n+    public long sum2() {\n+        return IntStream.range(0, size)\n+            .map(x -> x)\n+            .map(x -> x)\n+            .sum();\n+    }\n+\n+    @Benchmark\n+    public long sum4() {\n+        return IntStream.range(0, size)\n+            .map(x -> x)\n+            .map(x -> x)\n+            .map(x -> x)\n+            .map(x -> x)\n+            .sum();\n+    }\n+\n+    @Benchmark\n+    public long sum6() {\n+        return IntStream.range(0, size)\n+            .map(x -> x)\n+            .map(x -> x)\n+            .map(x -> x)\n+            .map(x -> x)\n+            .map(x -> x)\n+            .map(x -> x)\n+            .sum();\n+    }\n+\n+    @Benchmark\n+    public long sum8() {\n+        return IntStream.range(0, size)\n+            .map(x -> x)\n+            .map(x -> x)\n+            .map(x -> x)\n+            .map(x -> x)\n+            .map(x -> x)\n+            .map(x -> x)\n+            .map(x -> x)\n+            .map(x -> x)\n+            .sum();\n+    }\n+\n+    @Benchmark\n+    public long sum10() {\n+        return IntStream.range(0, size)\n+            .map(x -> x)\n+            .map(x -> x)\n+            .map(x -> x)\n+            .map(x -> x)\n+            .map(x -> x)\n+            .map(x -> x)\n+            .map(x -> x)\n+            .map(x -> x)\n+            .map(x -> x)\n+            .map(x -> x)\n+            .sum();\n+    }\n+\n+    @Benchmark\n+    public long sum10Skip() {\n+        return IntStream.range(0, size)\n+            .skip(1)\n+            .map(x -> x)\n+            .map(x -> x)\n+            .map(x -> x)\n+            .map(x -> x)\n+            .map(x -> x)\n+            .map(x -> x)\n+            .map(x -> x)\n+            .map(x -> x)\n+            .map(x -> x)\n+            .map(x -> x)\n+            .sum();\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/stream\/ops\/value\/SizedSum.java","additions":152,"deletions":0,"binary":false,"changes":152,"status":"added"},{"patch":"@@ -0,0 +1,92 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.util.stream.ops.value;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.State;\n+\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.IntStream;\n+\n+\/**\n+ * Benchmark for limit()\/skip() operation in sized streams.\n+ *\/\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.SECONDS)\n+@State(Scope.Thread)\n+public class SliceToArray {\n+\n+    @Param(\"10000\")\n+    private int size;\n+\n+    @Benchmark\n+    public int[] seq_baseline() {\n+        return IntStream.range(0, size)\n+                .toArray();\n+    }\n+\n+    @Benchmark\n+    public int[] seq_limit() {\n+        return IntStream.range(0, size * 2)\n+                .limit(size)\n+                .toArray();\n+    }\n+\n+    @Benchmark\n+    public int[] seq_skipLimit() {\n+        return IntStream.range(0, size * 2)\n+                .skip(1)\n+                .limit(size)\n+                .toArray();\n+    }\n+\n+    @Benchmark\n+    public int[] par_baseline() {\n+        return IntStream.range(0, size)\n+                .parallel()\n+                .toArray();\n+    }\n+\n+    @Benchmark\n+    public int[] par_limit() {\n+        return IntStream.range(0, size * 2)\n+                .parallel()\n+                .limit(size)\n+                .toArray();\n+    }\n+\n+    @Benchmark\n+    public int[] par_skipLimit() {\n+        return IntStream.range(0, size * 2)\n+                .parallel()\n+                .skip(1)\n+                .limit(size)\n+                .toArray();\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/stream\/ops\/value\/SliceToArray.java","additions":92,"deletions":0,"binary":false,"changes":92,"status":"added"}]}