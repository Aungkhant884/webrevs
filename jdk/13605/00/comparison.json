{"files":[{"patch":"@@ -2082,2 +2082,1 @@\n-         is_intel_skylake() &&\n-         _stepping >= 5;\n+         is_intel_cascade_lake();\n@@ -2087,0 +2086,4 @@\n+bool VM_Version::is_intel_cascade_lake() {\n+  return is_intel_skylake() && _stepping >= 5;\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.cpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -719,0 +719,2 @@\n+  static bool is_intel_cascade_lake();\n+\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -13745,0 +13745,7 @@\n+\/\/ These peephole rules replace mov + I pairs (where I is one of {add, inc, dec,\n+\/\/ sal}) with lea instructions. The {add, sal} rules are beneficial in\n+\/\/ processors with at least partial ALU support for lea\n+\/\/ (supports_fast_2op_lea()), whereas the {inc, dec} rules are only generally\n+\/\/ beneficial for processors with full ALU support\n+\/\/ (VM_Version::supports_fast_3op_lea()) and Intel Cascade Lake.\n+\n@@ -13763,1 +13770,2 @@\n-  peeppredicate(VM_Version::supports_fast_2op_lea());\n+  peeppredicate(VM_Version::supports_fast_3op_lea() ||\n+                VM_Version::is_intel_cascade_lake());\n@@ -13771,1 +13779,2 @@\n-  peeppredicate(VM_Version::supports_fast_2op_lea());\n+  peeppredicate(VM_Version::supports_fast_3op_lea() ||\n+                VM_Version::is_intel_cascade_lake());\n@@ -13803,1 +13812,2 @@\n-  peeppredicate(VM_Version::supports_fast_2op_lea());\n+  peeppredicate(VM_Version::supports_fast_3op_lea() ||\n+                VM_Version::is_intel_cascade_lake());\n@@ -13811,1 +13821,2 @@\n-  peeppredicate(VM_Version::supports_fast_2op_lea());\n+  peeppredicate(VM_Version::supports_fast_3op_lea() ||\n+                VM_Version::is_intel_cascade_lake());\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":15,"deletions":4,"binary":false,"changes":19,"status":"modified"}]}