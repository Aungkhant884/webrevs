{"files":[{"patch":"@@ -68,1 +68,1 @@\n-template <class T> inline void MarkSweep::KeepAliveClosure::do_oop_work(T* p) {\n+template <class T> void MarkSweep::KeepAliveClosure::do_oop_work(T* p) {\n@@ -78,1 +78,1 @@\n-inline void MarkSweep::follow_array(objArrayOop array) {\n+void MarkSweep::follow_array(objArrayOop array) {\n@@ -86,1 +86,1 @@\n-inline void MarkSweep::follow_object(oop obj) {\n+void MarkSweep::follow_object(oop obj) {\n@@ -131,1 +131,1 @@\n-template <class T> inline void MarkSweep::follow_root(T* p) {\n+template <class T> void MarkSweep::follow_root(T* p) {\n@@ -176,0 +176,40 @@\n+void MarkSweep::mark_object(oop obj) {\n+  if (StringDedup::is_enabled() &&\n+      java_lang_String::is_instance(obj) &&\n+      SerialStringDedup::is_candidate_from_mark(obj)) {\n+    _string_dedup_requests->add(obj);\n+  }\n+\n+  \/\/ some marks may contain information we need to preserve so we store them away\n+  \/\/ and overwrite the mark.  We'll restore it at the end of markSweep.\n+  markWord mark = obj->mark();\n+  obj->set_mark(markWord::prototype().set_marked());\n+\n+  ContinuationGCSupport::transform_stack_chunk(obj);\n+\n+  if (obj->mark_must_be_preserved(mark)) {\n+    preserve_mark(obj, mark);\n+  }\n+}\n+\n+template <class T> void MarkSweep::mark_and_push(T* p) {\n+  T heap_oop = RawAccess<>::oop_load(p);\n+  if (!CompressedOops::is_null(heap_oop)) {\n+    oop obj = CompressedOops::decode_not_null(heap_oop);\n+    if (!obj->mark().is_marked()) {\n+      mark_object(obj);\n+      _marking_stack.push(obj);\n+    }\n+  }\n+}\n+\n+void MarkSweep::follow_klass(Klass* klass) {\n+  oop op = klass->class_loader_data()->holder_no_keepalive();\n+  MarkSweep::mark_and_push(&op);\n+}\n+\n+template <typename T>\n+void MarkAndPushClosure::do_oop_work(T* p)            { MarkSweep::mark_and_push(p); }\n+void MarkAndPushClosure::do_oop(      oop* p)         { do_oop_work(p); }\n+void MarkAndPushClosure::do_oop(narrowOop* p)         { do_oop_work(p); }\n+\n","filename":"src\/hotspot\/share\/gc\/serial\/markSweep.cpp","additions":44,"deletions":4,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -42,40 +42,0 @@\n-inline void MarkSweep::mark_object(oop obj) {\n-  if (StringDedup::is_enabled() &&\n-      java_lang_String::is_instance(obj) &&\n-      SerialStringDedup::is_candidate_from_mark(obj)) {\n-    _string_dedup_requests->add(obj);\n-  }\n-\n-  \/\/ some marks may contain information we need to preserve so we store them away\n-  \/\/ and overwrite the mark.  We'll restore it at the end of markSweep.\n-  markWord mark = obj->mark();\n-  obj->set_mark(markWord::prototype().set_marked());\n-\n-  ContinuationGCSupport::transform_stack_chunk(obj);\n-\n-  if (obj->mark_must_be_preserved(mark)) {\n-    preserve_mark(obj, mark);\n-  }\n-}\n-\n-template <class T> inline void MarkSweep::mark_and_push(T* p) {\n-  T heap_oop = RawAccess<>::oop_load(p);\n-  if (!CompressedOops::is_null(heap_oop)) {\n-    oop obj = CompressedOops::decode_not_null(heap_oop);\n-    if (!obj->mark().is_marked()) {\n-      mark_object(obj);\n-      _marking_stack.push(obj);\n-    }\n-  }\n-}\n-\n-inline void MarkSweep::follow_klass(Klass* klass) {\n-  oop op = klass->class_loader_data()->holder_no_keepalive();\n-  MarkSweep::mark_and_push(&op);\n-}\n-\n-template <typename T>\n-inline void MarkAndPushClosure::do_oop_work(T* p)            { MarkSweep::mark_and_push(p); }\n-inline void MarkAndPushClosure::do_oop(      oop* p)         { do_oop_work(p); }\n-inline void MarkAndPushClosure::do_oop(narrowOop* p)         { do_oop_work(p); }\n-\n@@ -101,1 +61,0 @@\n-\n","filename":"src\/hotspot\/share\/gc\/serial\/markSweep.inline.hpp","additions":0,"deletions":41,"binary":false,"changes":41,"status":"modified"}]}