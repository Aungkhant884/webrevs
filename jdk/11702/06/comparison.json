{"files":[{"patch":"@@ -429,1 +429,1 @@\n-        ASAN_CFLAGS=\"-fsanitize=address -Wno-stringop-truncation -fno-omit-frame-pointer\"\n+        ASAN_CFLAGS=\"-fsanitize=address -Wno-stringop-truncation -fno-omit-frame-pointer -fno-common -DADDRESS_SANITIZER\"\n","filename":"make\/autoconf\/jdk-options.m4","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+#include \"sanitizers\/address.h\"\n@@ -110,0 +111,17 @@\n+Metachunk* ChunkManager::get_chunk(chunklevel_t preferred_level, chunklevel_t max_level, size_t min_committed_words) {\n+  assert(preferred_level <= max_level, \"Sanity\");\n+  assert(chunklevel::level_fitting_word_size(min_committed_words) >= max_level, \"Sanity\");\n+\n+  Metachunk* c;\n+  {\n+    MutexLocker fcl(Metaspace_lock, Mutex::_no_safepoint_check_flag);\n+    c = get_chunk_locked(preferred_level, max_level, min_committed_words);\n+  }\n+\n+  if (c != nullptr) {\n+    ASAN_UNPOISON_MEMORY_REGION(c->base(), c->word_size() * BytesPerWord);\n+  }\n+\n+  return c;\n+}\n+\n@@ -119,6 +137,2 @@\n-Metachunk* ChunkManager::get_chunk(chunklevel_t preferred_level, chunklevel_t max_level, size_t min_committed_words) {\n-  assert(preferred_level <= max_level, \"Sanity\");\n-  assert(chunklevel::level_fitting_word_size(min_committed_words) >= max_level, \"Sanity\");\n-\n-  MutexLocker fcl(Metaspace_lock, Mutex::_no_safepoint_check_flag);\n-\n+Metachunk* ChunkManager::get_chunk_locked(chunklevel_t preferred_level, chunklevel_t max_level, size_t min_committed_words) {\n+  assert_lock_strong(Metaspace_lock);\n@@ -234,0 +248,3 @@\n+  \/\/ It is valid to poison the chunk payload area at this point since its physically separated from\n+  \/\/ the chunk meta info.\n+  ASAN_POISON_MEMORY_REGION(c->base(), c->word_size() * BytesPerWord);\n@@ -282,2 +299,16 @@\n-  MutexLocker fcl(Metaspace_lock, Mutex::_no_safepoint_check_flag);\n-  return c->vsnode()->attempt_enlarge_chunk(c, &_chunks);\n+  bool enlarged;\n+  chunklevel_t old_level;\n+\n+  {\n+    MutexLocker fcl(Metaspace_lock, Mutex::_no_safepoint_check_flag);\n+    old_level = c->level();\n+    enlarged = c->vsnode()->attempt_enlarge_chunk(c, &_chunks);\n+  }\n+\n+  if (enlarged) {\n+    ASAN_UNPOISON_MEMORY_REGION(c->base() + chunklevel::word_size_for_level(old_level),\n+                                (c->word_size() - chunklevel::word_size_for_level(old_level)) *\n+                                BytesPerWord);\n+  }\n+\n+  return enlarged;\n","filename":"src\/hotspot\/share\/memory\/metaspace\/chunkManager.cpp","additions":39,"deletions":8,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -98,0 +98,2 @@\n+  Metachunk* get_chunk_locked(chunklevel_t preferred_level, chunklevel_t max_level, size_t min_committed_words);\n+\n","filename":"src\/hotspot\/share\/memory\/metaspace\/chunkManager.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+#include \"sanitizers\/address.h\"\n@@ -237,0 +238,4 @@\n+\n+  \/\/ Poison the memory region. It will be unpoisoned later on a per-chunk base for chunks that are\n+  \/\/ handed to arenas.\n+  ASAN_POISON_MEMORY_REGION(rs.base(), rs.size());\n@@ -268,0 +273,4 @@\n+  \/\/ Undo the poisoning before potentially unmapping memory. This ensures that future mappings at\n+  \/\/ the same address do not unexpectedly fail with use-after-poison.\n+  ASAN_UNPOISON_MEMORY_REGION(_rs.base(), _rs.size());\n+\n","filename":"src\/hotspot\/share\/memory\/metaspace\/virtualSpaceNode.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,85 @@\n+\/*\n+ * Copyright (c) 2023, Google and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_SANITIZERS_ADDRESS_HPP\n+#define SHARE_SANITIZERS_ADDRESS_HPP\n+\n+#ifdef ADDRESS_SANITIZER\n+#include <sanitizer\/asan_interface.h>\n+#endif\n+\n+\/\/ NO_SANITIZE_ADDRESS\n+\/\/\n+\/\/ Function attribute that can be applied to disable ASan instrumentation for the function.\n+#ifdef ADDRESS_SANITIZER\n+\/\/ We currently only support ASan with GCC and Clang, but technically MSVC also has ASan so we could\n+\/\/ support it in the future. Thus we pre-emptively support the MSVC-specific attribute.\n+#ifdef _MSC_VER\n+#define NO_SANITIZE_ADDRESS __declspec(no_sanitize_address)\n+#else\n+#define NO_SANITIZE_ADDRESS __attribute__((no_sanitize_address))\n+#endif\n+#else\n+#define NO_SANITIZE_ADDRESS\n+#endif\n+\n+\/\/ ASAN_POISON_MEMORY_REGION()\n+\/\/\n+\/\/ Poisons the specified memory region. Subsequent reads and writes to the memory region will result\n+\/\/ in a fatal error.\n+#ifdef ADDRESS_SANITIZER\n+#undef ASAN_POISON_MEMORY_REGION\n+#define ASAN_POISON_MEMORY_REGION(addr, size) __asan_poison_memory_region((addr), (size))\n+#else\n+\/\/ NOOP implementation which preserves the arguments, ensuring they still compile, but ensures they\n+\/\/ are stripped due to being unreachable.\n+#define ASAN_POISON_MEMORY_REGION(addr, size) \\\n+  do {                                        \\\n+    if (false) {                              \\\n+      ((void) (addr));                        \\\n+      ((void) (size));                        \\\n+    }                                         \\\n+  } while (false)\n+#endif\n+\n+\/\/ ASAN_UNPOISON_MEMORY_REGION()\n+\/\/\n+\/\/ Unpoisons the specified memory region. Subsequent reads and writes to the memory region are\n+\/\/ valid.\n+#ifdef ADDRESS_SANITIZER\n+#undef ASAN_UNPOISON_MEMORY_REGION\n+#define ASAN_UNPOISON_MEMORY_REGION(addr, size) __asan_unpoison_memory_region((addr), (size))\n+#else\n+\/\/ NOOP implementation which preserves the arguments, ensuring they still compile, but ensures they\n+\/\/ are stripped due to being unreachable.\n+#define ASAN_UNPOISON_MEMORY_REGION(addr, size) \\\n+  do {                                          \\\n+    if (false) {                                \\\n+      ((void) (addr));                          \\\n+      ((void) (size));                          \\\n+    }                                           \\\n+  } while (false)\n+#endif\n+\n+#endif  \/\/ SHARE_SANITIZERS_ADDRESS_HPP\n","filename":"src\/hotspot\/share\/sanitizers\/address.h","additions":85,"deletions":0,"binary":false,"changes":85,"status":"added"}]}