{"files":[{"patch":"@@ -429,1 +429,1 @@\n-        ASAN_CFLAGS=\"-fsanitize=address -Wno-stringop-truncation -fno-omit-frame-pointer\"\n+        ASAN_CFLAGS=\"-fsanitize=address -Wno-stringop-truncation -fno-omit-frame-pointer -DADDRESS_SANITIZER\"\n","filename":"make\/autoconf\/jdk-options.m4","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"sanitizers\/address.h\"\n@@ -82,4 +83,6 @@\n-    Block(Block* next, size_t word_size) :\n-      _next(next),\n-      _word_size(word_size)\n-    {}\n+\n+    Block(Block* next, size_t word_size) : _next(next), _word_size(word_size) {\n+      \/\/ Poison the remaining memory region.\n+      ASAN_POISON_MEMORY_REGION(reinterpret_cast<char*>(this) + sizeof(Block),\n+                                (_word_size * BytesPerWord) - sizeof(Block));\n+    }\n@@ -143,0 +146,2 @@\n+    \/\/ Ensure the memory region for the block is unpoisoned.\n+    ASAN_UNPOISON_MEMORY_REGION(p, sizeof(Block));\n","filename":"src\/hotspot\/share\/memory\/metaspace\/binList.hpp","additions":9,"deletions":4,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"sanitizers\/address.h\"\n@@ -111,1 +112,5 @@\n-    {}\n+    {\n+      \/\/ Poison the remaining memory region.\n+      ASAN_POISON_MEMORY_REGION(reinterpret_cast<char*>(this) + sizeof(Node),\n+                                (_word_size * BytesPerWord) - sizeof(Node));\n+    }\n@@ -350,0 +355,1 @@\n+#ifndef ADDRESS_SANITIZER\n@@ -351,0 +357,1 @@\n+#endif\n@@ -352,0 +359,2 @@\n+    \/\/ Ensure the memory region for the node is unpoisoned.\n+    ASAN_UNPOISON_MEMORY_REGION(p, sizeof(Node));\n@@ -388,0 +397,1 @@\n+#ifndef ADDRESS_SANITIZER\n@@ -389,0 +399,1 @@\n+#endif\n","filename":"src\/hotspot\/share\/memory\/metaspace\/blockTree.hpp","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+#include \"sanitizers\/address.h\"\n@@ -236,0 +237,2 @@\n+      \/\/ Unpoison memory region for requested size. The extra size should remain poisoned.\n+      ASAN_UNPOISON_MEMORY_REGION(p, requested_word_size * BytesPerWord);\n@@ -246,0 +249,3 @@\n+  if (p != nullptr) {\n+    \/\/ Unpoison memory region for requested size. The extra size should remain poisoned.\n+    ASAN_UNPOISON_MEMORY_REGION(p, requested_word_size * BytesPerWord);\n@@ -247,12 +253,15 @@\n-  \/\/ Fence allocation\n-  if (p != NULL && Settings::use_allocation_guard()) {\n-    STATIC_ASSERT(is_aligned(sizeof(Fence), BytesPerWord));\n-    MetaWord* guard = allocate_inner(sizeof(Fence) \/ BytesPerWord);\n-    if (guard != NULL) {\n-      \/\/ Ignore allocation errors for the fence to keep coding simple. If this\n-      \/\/ happens (e.g. because right at this time we hit the Metaspace GC threshold)\n-      \/\/ we miss adding this one fence. Not a big deal. Note that his would\n-      \/\/ be pretty rare. Chances are much higher the primary allocation above\n-      \/\/ would have already failed).\n-      Fence* f = new(guard) Fence(_first_fence);\n-      _first_fence = f;\n+    \/\/ Fence allocation\n+    if (Settings::use_allocation_guard()) {\n+      STATIC_ASSERT(is_aligned(sizeof(Fence), BytesPerWord));\n+      MetaWord* guard = allocate_inner(sizeof(Fence) \/ BytesPerWord);\n+      if (guard != NULL) {\n+        \/\/ Unpoison the memory region for the fence.\n+        ASAN_UNPOISON_MEMORY_REGION(guard, sizeof(Fence));\n+        \/\/ Ignore allocation errors for the fence to keep coding simple. If this\n+        \/\/ happens (e.g. because right at this time we hit the Metaspace GC threshold)\n+        \/\/ we miss adding this one fence. Not a big deal. Note that his would\n+        \/\/ be pretty rare. Chances are much higher the primary allocation above\n+        \/\/ would have already failed).\n+        Fence* f = new(guard) Fence(_first_fence);\n+        _first_fence = f;\n+      }\n@@ -260,1 +269,0 @@\n-  }\n@@ -262,0 +270,1 @@\n+  }\n","filename":"src\/hotspot\/share\/memory\/metaspace\/metaspaceArena.cpp","additions":22,"deletions":13,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+#include \"sanitizers\/address.h\"\n@@ -237,0 +238,3 @@\n+\n+  \/\/ Poison the memory region. It will be unpoisoned later by MetaspaceArena.\n+  ASAN_POISON_MEMORY_REGION(rs.base(), rs.size());\n@@ -271,0 +275,4 @@\n+  } else {\n+    \/\/ We do not own the memory region, so we need to unpoison it to undo the previous poisoning in\n+    \/\/ the constructor.\n+    ASAN_UNPOISON_MEMORY_REGION(_rs.base(), _rs.size());\n","filename":"src\/hotspot\/share\/memory\/metaspace\/virtualSpaceNode.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -63,0 +63,1 @@\n+#include \"sanitizers\/address.h\"\n@@ -945,2 +946,6 @@\n-void os::print_hex_dump(outputStream* st, address start, address end, int unitsize,\n-                        int bytes_per_line, address logical_start) {\n+\/\/ os::print_hex_dump is used from the crash handler and may attempt to do scary things like read\n+\/\/ parent stack frames, read outside of initialized memory, and etc. So we tell ASan to not\n+\/\/ instrument this function.\n+NO_SANITIZE_ADDRESS void os::print_hex_dump(outputStream* st, address start, address end,\n+                                            int unitsize, int bytes_per_line,\n+                                            address logical_start) {\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,85 @@\n+\/*\n+ * Copyright (c) 2023, Google and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_SANITIZERS_ADDRESS_HPP\n+#define SHARE_SANITIZERS_ADDRESS_HPP\n+\n+#ifdef ADDRESS_SANITIZER\n+#include <sanitizer\/asan_interface.h>\n+#endif\n+\n+\/\/ NO_SANITIZE_ADDRESS\n+\/\/\n+\/\/ Function attribute that can be applied to disable ASan instrumentation for the function.\n+#ifdef ADDRESS_SANITIZER\n+\/\/ We currently only support ASan with GCC and Clang, but technically MSVC also has ASan so we could\n+\/\/ support it in the future. Thus we pre-emptively support the MSVC-specific attribute.\n+#ifdef _MSC_VER\n+#define NO_SANITIZE_ADDRESS __declspec(no_sanitize_address)\n+#else\n+#define NO_SANITIZE_ADDRESS __attribute__((no_sanitize_address))\n+#endif\n+#else\n+#define NO_SANITIZE_ADDRESS\n+#endif\n+\n+\/\/ ASAN_POISON_MEMORY_REGION()\n+\/\/\n+\/\/ Poisons the specified memory region. Subsequent reads and writes to the memory region will result\n+\/\/ in a fatal error.\n+#ifdef ADDRESS_SANITIZER\n+#undef ASAN_POISON_MEMORY_REGION\n+#define ASAN_POISON_MEMORY_REGION(addr, size) __asan_poison_memory_region((addr), (size))\n+#else\n+\/\/ NOOP implementation which preserves the arguments, ensuring they still compile, but ensures they\n+\/\/ are stripped due to being unreachable.\n+#define ASAN_POISON_MEMORY_REGION(addr, size) \\\n+  do {                                        \\\n+    if (false) {                              \\\n+      ((void) (addr));                        \\\n+      ((void) (size));                        \\\n+    }                                         \\\n+  } while (false)\n+#endif\n+\n+\/\/ ASAN_UNPOISON_MEMORY_REGION()\n+\/\/\n+\/\/ Unpoisons the specified memory region. Subsequent reads and writes to the memory region are\n+\/\/ valid.\n+#ifdef ADDRESS_SANITIZER\n+#undef ASAN_UNPOISON_MEMORY_REGION\n+#define ASAN_UNPOISON_MEMORY_REGION(addr, size) __asan_unpoison_memory_region((addr), (size))\n+#else\n+\/\/ NOOP implementation which preserves the arguments, ensuring they still compile, but ensures they\n+\/\/ are stripped due to being unreachable.\n+#define ASAN_UNPOISON_MEMORY_REGION(addr, size) \\\n+  do {                                          \\\n+    if (false) {                                \\\n+      ((void) (addr));                          \\\n+      ((void) (size));                          \\\n+    }                                           \\\n+  } while (false)\n+#endif\n+\n+#endif  \/\/ SHARE_SANITIZERS_ADDRESS_HPP\n","filename":"src\/hotspot\/share\/sanitizers\/address.h","additions":85,"deletions":0,"binary":false,"changes":85,"status":"added"}]}