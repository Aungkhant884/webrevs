{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,0 @@\n-import vm.runtime.defmeth.shared.annotation.KnownFailure;\n@@ -67,3 +66,0 @@\n-    @KnownFailure(modes = {\n-        REFLECTION,                           \/\/ throws IAE\n-        INVOKE_GENERIC, INVOKE_WITH_ARGS})    \/\/ throws ClassCastException\n@@ -93,1 +89,1 @@\n-        \/\/ be inappropriate since no classes are changed.\n+            \/\/ be inappropriate since no classes are changed.\n@@ -112,3 +108,0 @@\n-    @KnownFailure(modes = {\n-        DIRECT, REFLECTION, INVOKE_WITH_ARGS, \/\/ NSME, instead of AME\n-        INVOKE_EXACT, INVOKE_GENERIC, INDY})        \/\/ IncompatibleClassChangeError, instead of AME\n@@ -199,1 +192,1 @@\n-     *   static { throw new RE()}\n+     *   static { throw new RE(); }\n@@ -205,1 +198,1 @@\n-     * TEST: C c = new C(); ==> LinkageError\n+     * TEST: C c = new C(); ==> ExceptionInInitializerError\n@@ -224,1 +217,5 @@\n-        b.test().callSite(I, C, \"m\", \"()V\").throws_(LinkageError.class).done()\n+        boolean isReflectionMode = factory.getExecutionMode().equals(\"REFLECTION\");\n+        Class expectedError = isReflectionMode ? RuntimeException.class\n+                                               : ExceptionInInitializerError.class;\n+\n+        b.test().new_(C).throws_(expectedError).done()\n@@ -231,1 +228,1 @@\n-     *   static { throw new RE()}\n+     *   static { throw new RE(); }\n@@ -237,1 +234,1 @@\n-     * TEST: C c = new C(); ==> LinkageError\n+     * TEST: C c = new C(); ==> ExceptionInInitializerError\n@@ -257,7 +254,5 @@\n-        Class expectedClass;\n-        if (factory.getExecutionMode().equals(\"REFLECTION\")) {\n-            expectedClass = NoSuchMethodException.class;\n-        } else {\n-            expectedClass = LinkageError.class;\n-        }\n-        b.test().callSite(I, C, \"m\", \"()V\").throws_(expectedClass).done()\n+        boolean isReflectionMode = factory.getExecutionMode().equals(\"REFLECTION\");\n+        Class expectedError = isReflectionMode ? RuntimeException.class\n+                                               : ExceptionInInitializerError.class;\n+\n+        b.test().new_(C).throws_(expectedError).done()\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/runtime\/defmeth\/BasicTest.java","additions":16,"deletions":21,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-import vm.runtime.defmeth.shared.annotation.KnownFailure;\n@@ -489,1 +488,0 @@\n-    @KnownFailure(modes = { INVOKE_EXACT, INVOKE_GENERIC, INDY }) \/\/ IncompatibleClassChangeError instead of NoSuchMethodError\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/runtime\/defmeth\/ConflictingDefaultsTest.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-import vm.runtime.defmeth.shared.annotation.KnownFailure;\n@@ -90,2 +89,0 @@\n-    @KnownFailure(modes = {INVOKE_EXACT, INVOKE_GENERIC, INVOKE_WITH_ARGS, INDY }) \/\/ Test1_I_D_m: NPE instead of AME\n-                                                                                   \/\/ Test3_D_D_m: AME => IAE => ICCE instead of AME\n@@ -133,2 +130,0 @@\n-    @KnownFailure(modes = { INVOKE_EXACT, INVOKE_GENERIC, INVOKE_WITH_ARGS, INDY }) \/\/ Test1_I_D_m: NPE instead of AME\n-                                                                                    \/\/ Test3_D_D_m: AME => IAE => ICCE instead of AME\n@@ -221,5 +216,0 @@\n-    @KnownFailure(modes = {\n-        INVOKE_EXACT, INVOKE_GENERIC, INVOKE_WITH_ARGS, INDY \/\/ Test1_I_C_m: NPE instead of AME\n-                                                             \/\/ Test3_D_C_m: AME => IAE => ICCE instead of AME\n-                                                             \/\/ Test4_C_C_m: AME => IAE => ICCE instead of AME\n-    })\n@@ -448,4 +438,1 @@\n-     * TEST: A o = new B(); o.m()I\n-     *                ICCE for DIRECT mode\n-     *                AME for REFLECTION and INVOKE_WITH_ARGS modes\n-     *                IAE for other modes\n+     * TEST: A o = new B(); o.m()I throws ICCE\n@@ -468,3 +455,0 @@\n-        String exeMode = factory.getExecutionMode();\n-\n-        \/\/ ICCE in direct mode due to\n@@ -474,2 +458,0 @@\n-        Class expectedError = IncompatibleClassChangeError.class;;\n-\n@@ -477,1 +459,1 @@\n-         .throws_(expectedError).done()\n+         .throws_(IncompatibleClassChangeError.class).done()\n@@ -495,2 +477,1 @@\n-     * TEST: A o = new B(); o.m()I\n-     *                ICCE for all modes\n+     * TEST: A o = new B(); o.m()I throws ICCE\n@@ -513,3 +494,0 @@\n-        String exeMode = factory.getExecutionMode();\n-\n-        \/\/ ICCE in direct mode due to\n@@ -519,2 +497,0 @@\n-        Class expectedError = IncompatibleClassChangeError.class;\n-\n@@ -522,1 +498,1 @@\n-         .throws_(expectedError).done()\n+         .throws_(IncompatibleClassChangeError.class).done()\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/runtime\/defmeth\/DefaultVsAbstractTest.java","additions":5,"deletions":29,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,0 @@\n-import vm.runtime.defmeth.shared.annotation.KnownFailure;\n@@ -151,1 +150,0 @@\n-    @KnownFailure(modes = { INVOKE_EXACT, INVOKE_GENERIC, INVOKE_WITH_ARGS, INDY }) \/\/ Test2_J_C_m, Test3_K_C_m: AME => IAE => ICCE instead of successful call\n@@ -196,1 +194,0 @@\n-    @KnownFailure(modes = { INVOKE_EXACT, INVOKE_GENERIC, INVOKE_WITH_ARGS, INDY }) \/\/ Test3_K_C_m: AME => IAE => ICCE instead of successful call\n@@ -519,1 +516,0 @@\n-    @KnownFailure(modes = { INVOKE_EXACT, INVOKE_GENERIC, INVOKE_WITH_ARGS, INDY }) \/\/ Test2_J_C_m, Test3_K_C_m: AME => IAE => ICCE instead of successful call\n@@ -565,2 +561,0 @@\n-    @KnownFailure(modes = { INVOKE_EXACT, INVOKE_GENERIC, INVOKE_WITH_ARGS, INDY }) \/\/ Test2_J_C_m, Test3_K_C_m, Test4_L_C_m, Test5_M_C_m:\n-                                                                                    \/\/ AME => IAE => ICCE instead of successful call\n@@ -711,1 +705,0 @@\n-    @KnownFailure(modes = { INVOKE_EXACT, INVOKE_GENERIC, INDY }) \/\/Test2_I_C_m, Test3_J_C_m: NSMError => NSMException => ICCE instead of NSME\n@@ -766,2 +759,0 @@\n-    @KnownFailure(modes = { INVOKE_EXACT, INVOKE_GENERIC, INDY })\n-    \/\/Test2_I_C_m, Test3_J_C_m: NSMError => NSMException => ICCE instead of NSME\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/runtime\/defmeth\/MethodResolutionTest.java","additions":1,"deletions":10,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,2 +28,0 @@\n-import vm.runtime.defmeth.shared.annotation.Crash;\n-import vm.runtime.defmeth.shared.annotation.KnownFailure;\n@@ -63,4 +61,0 @@\n-    \/\/   In private cases reflection triggers a NoSuchMethodException instead of the\n-    \/\/   expected IllegalAccessError. This indicates it is getDeclaredMethod() that is\n-    \/\/   failing rather than the actual invoke(). Which in turn suggests the wrong class\n-    \/\/   is being used, or that getMethod() is being used instead of getDeclaredMethod().\n@@ -339,1 +333,0 @@\n-     *                 -mode reflect throws NoSuchMethodException\n@@ -352,9 +345,2 @@\n-        Class expectedClass;\n-        if (factory.getExecutionMode().equals(\"REFLECTION\")) {\n-            expectedClass = NoSuchMethodException.class;\n-        } else {\n-            expectedClass = IllegalAccessError.class;\n-        }\n-\n-        b.test().callSite(I, C, \"m\", \"()I\").throws_(expectedClass).done()\n-         .test().callSite(C, C, \"m\", \"()I\").throws_(NoSuchMethodError.class).done()\n+        b.test().privateCallSite(I, C, \"m\", \"()I\").throws_(IllegalAccessError.class).done()\n+         .test().       callSite(C, C, \"m\", \"()I\").throws_(NoSuchMethodError.class).done()\n@@ -376,1 +362,0 @@\n-     *                 -mode reflect throws NoSuchMethodException\n@@ -391,9 +376,2 @@\n-        Class expectedClass;\n-        if (factory.getExecutionMode().equals(\"REFLECTION\")) {\n-            expectedClass = NoSuchMethodException.class;\n-        } else {\n-            expectedClass = IllegalAccessError.class;\n-        }\n-\n-        b.test().callSite(I, C, \"m\", \"()I\").throws_(expectedClass).done()\n-         .test().callSite(C, C, \"m\", \"()I\").returns(2).done()\n+        b.test().privateCallSite(I, C, \"m\", \"()I\").throws_(IllegalAccessError.class).done()\n+         .test().       callSite(C, C, \"m\", \"()I\").returns(2).done()\n@@ -416,1 +394,0 @@\n-     *                 -mode reflect throws NoSuchMethodException\n@@ -435,10 +412,3 @@\n-        Class expectedClass;\n-        if (factory.getExecutionMode().equals(\"REFLECTION\")) {\n-            expectedClass = NoSuchMethodException.class;\n-        } else {\n-            expectedClass = IllegalAccessError.class;\n-        }\n-\n-        b.test().callSite(I, C, \"m\", \"()I\").throws_(expectedClass).done()\n-         .test().callSite(J, C, \"m\", \"()I\").returns(2).done()\n-         .test().callSite(C, C, \"m\", \"()I\").returns(2).done()\n+        b.test().privateCallSite(I, C, \"m\", \"()I\").throws_(IllegalAccessError.class).done()\n+         .test().       callSite(J, C, \"m\", \"()I\").returns(2).done()\n+         .test().       callSite(C, C, \"m\", \"()I\").returns(2).done()\n@@ -498,1 +468,0 @@\n-     *                 -mode reflect throws NoSuchMethodException\n@@ -516,10 +485,3 @@\n-        Class expectedClass;\n-        if (factory.getExecutionMode().equals(\"REFLECTION\")) {\n-            expectedClass = NoSuchMethodException.class;\n-        } else {\n-            expectedClass = IllegalAccessError.class;\n-        }\n-\n-        b.test().callSite(I, C, \"m\", \"()I\").throws_(expectedClass).done()\n-         .test().callSite(J, C, \"m\", \"()I\").throws_(AbstractMethodError.class).done()\n-         .test().callSite(C, C, \"m\", \"()I\").throws_(AbstractMethodError.class).done()\n+        b.test().privateCallSite(I, C, \"m\", \"()I\").throws_(IllegalAccessError.class).done()\n+         .test().       callSite(J, C, \"m\", \"()I\").throws_(AbstractMethodError.class).done()\n+         .test().       callSite(C, C, \"m\", \"()I\").throws_(AbstractMethodError.class).done()\n@@ -575,1 +537,0 @@\n-     *                 -mode reflect throws NoSuchMethodException\n@@ -590,10 +551,3 @@\n-        Class expectedClass;\n-        if (factory.getExecutionMode().equals(\"REFLECTION\")) {\n-            expectedClass = NoSuchMethodException.class;\n-        } else {\n-            expectedClass = IllegalAccessError.class;\n-        }\n-\n-        b.test().callSite(I, C, \"m\",\"()I\").throws_(expectedClass).done()\n-         .test().callSite(B, C, \"m\",\"()I\").throws_(NoSuchMethodError.class).done()\n-         .test().callSite(C, C, \"m\",\"()I\").throws_(NoSuchMethodError.class).done()\n+        b.test().privateCallSite(I, C, \"m\",\"()I\").throws_(IllegalAccessError.class).done()\n+         .test().       callSite(B, C, \"m\",\"()I\").throws_(NoSuchMethodError.class).done()\n+         .test().       callSite(C, C, \"m\",\"()I\").throws_(NoSuchMethodError.class).done()\n@@ -617,1 +571,0 @@\n-     *                     -mode reflect throws NoSuchMethodException\n@@ -635,10 +588,3 @@\n-        Class expectedClass;\n-        if (factory.getExecutionMode().equals(\"REFLECTION\")) {\n-            expectedClass = NoSuchMethodException.class;\n-        } else {\n-            expectedClass = IllegalAccessError.class;\n-        }\n-\n-        b.test().callSite(I, C, \"m\",\"()I\").throws_(expectedClass).done()\n-         .test().callSite(B, C, \"m\",\"()I\").returns(2).done()\n-         .test().callSite(C, C, \"m\",\"()I\").returns(2).done()\n+        b.test().privateCallSite(I, C, \"m\",\"()I\").throws_(IllegalAccessError.class).done()\n+         .test().       callSite(B, C, \"m\",\"()I\").returns(2).done()\n+         .test().       callSite(C, C, \"m\",\"()I\").returns(2).done()\n@@ -663,1 +609,0 @@\n-     *                 -mode reflect throws NoSuchMethodException\n@@ -680,10 +625,3 @@\n-        Class expectedClass;\n-        if (factory.getExecutionMode().equals(\"REFLECTION\")) {\n-            expectedClass = NoSuchMethodException.class;\n-        } else {\n-            expectedClass = IllegalAccessError.class;\n-        }\n-\n-        b.test().callSite(I, C, \"m\", \"()I\").throws_(expectedClass).done()\n-         .test().callSite(J, C, \"m\", \"()I\").returns(2).done()\n-         .test().callSite(C, C, \"m\", \"()I\").returns(2).done()\n+        b.test().privateCallSite(I, C, \"m\", \"()I\").throws_(IllegalAccessError.class).done()\n+         .test().       callSite(J, C, \"m\", \"()I\").returns(2).done()\n+         .test().       callSite(C, C, \"m\", \"()I\").returns(2).done()\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/runtime\/defmeth\/PrivateMethodsTest.java","additions":20,"deletions":82,"binary":false,"changes":102,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -58,1 +58,1 @@\n-        if ( \"REFLECTION\".equals(mode) || \"INVOKE_WITH_ARGS\".equals(mode)) {\n+        if (\"REFLECTION\".equals(mode) || \"INVOKE_WITH_ARGS\".equals(mode)) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/runtime\/defmeth\/RedefineTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n-import vm.runtime.defmeth.shared.annotation.Crash;\n+import vm.runtime.defmeth.shared.builder.TesterBuilder;\n@@ -32,0 +32,3 @@\n+\n+import static jdk.internal.org.objectweb.asm.Opcodes.ACC_PRIVATE;\n+import static jdk.internal.org.objectweb.asm.Opcodes.ACC_STATIC;\n@@ -229,7 +232,0 @@\n-        Class expectedClass;\n-        if (factory.getExecutionMode().equals(\"REFLECTION\")) {\n-            expectedClass = NoSuchMethodException.class;\n-        } else {\n-            expectedClass = IllegalAccessError.class;\n-        }\n-\n@@ -238,1 +234,2 @@\n-         .test().staticCallSite(I, \"staticPrivateM\", \"()I\").throws_(expectedClass).done()\n+\n+         .test().callSite(I, \"staticPrivateM\", \"()I\", ACC_STATIC | ACC_PRIVATE).throws_(IllegalAccessError.class).done()\n@@ -290,6 +287,3 @@\n-        Class expectedError1;\n-        if (factory.getExecutionMode().equals(\"REFLECTION\")) {\n-            expectedError1 = NoSuchMethodException.class;\n-        } else {\n-            expectedError1 = IllegalAccessError.class;\n-        }\n+        \/\/ call static method from another class\n+        b.test().staticCallSite(I, \"staticPublicM\", \"()I\").returns(1).done()\n+         .test().callSite(I, \"staticPrivateM\", \"()I\", ACC_STATIC | ACC_PRIVATE).throws_(IllegalAccessError.class).done();\n@@ -297,1 +291,1 @@\n-        \/\/ Adjust for -ver < 52\n+        \/\/ call static method from implementing subclass\n@@ -299,9 +293,2 @@\n-            \/\/ call static method from another class\n-            b.test().staticCallSite(I, \"staticPublicM\", \"()I\").returns(1).done()\n-             .test().staticCallSite(I, \"staticPrivateM\", \"()I\").throws_(expectedError1).done()\n-\n-            \/\/ call static method from implementing subclass\n-             .test().callSite(C, C, \"invokePublic\", \"()I\").returns(1).done()\n-             .test().callSite(C, C, \"invokePrivate\", \"()I\").throws_(IllegalAccessError.class).done()\n-\n-            .run();\n+            b.test().callSite(C, C, \"invokePublic\", \"()I\").returns(1).done()\n+             .test().callSite(C, C, \"invokePrivate\", \"()I\").throws_(IllegalAccessError.class).done();\n@@ -309,5 +296,0 @@\n-            \/\/ call static method from another class\n-            b.test().staticCallSite(I, \"staticPublicM\", \"()I\").returns(1).done()\n-             .test().staticCallSite(I, \"staticPrivateM\", \"()I\").throws_(expectedError1).done()\n-\n-            \/\/ call static method from implementing subclass\n@@ -315,4 +297,2 @@\n-             .test().callSite(C, C, \"invokePublic\",  \"()I\").throws_(VerifyError.class).done()\n-             .test().callSite(C, C, \"invokePrivate\", \"()I\").throws_(VerifyError.class).done()\n-\n-            .run();\n+            b.test().callSite(C, C, \"invokePublic\",  \"()I\").throws_(VerifyError.class).done()\n+             .test().callSite(C, C, \"invokePrivate\", \"()I\").throws_(VerifyError.class).done();\n@@ -320,0 +300,1 @@\n+        b.run();\n@@ -343,6 +324,6 @@\n-        if (!factory.getExecutionMode().equals(\"REFLECTION\")) {\n-            b.test().staticCallSite(I, \"m\", \"()I\").returns(1).done()\n-              \/\/ invokeinterface to static method ==> ICCE\n-              .test().callSite(I, C, \"m\", \"()I\").throws_(IncompatibleClassChangeError.class).done()\n-             .test().callSite(C, C, \"m\", \"()I\").throws_(NoSuchMethodError.class).done()\n-            .run();\n+        b.test().staticCallSite(I, \"m\", \"()I\").returns(1).done();\n+\n+        b.test().callSite(C, C, \"m\", \"()I\").throws_(NoSuchMethodError.class).done();\n+\n+        if (factory.getExecutionMode().equals(\"REFLECTION\")) {\n+            b.test().callSite(I, C, \"m\", \"()I\").returns(1).done();\n@@ -350,4 +331,2 @@\n-            b.test().staticCallSite(I, \"m\", \"()I\").returns(1).done()\n-             .test().callSite(I, C, \"m\", \"()I\").returns(1).done()\n-             .test().callSite(C, C, \"m\", \"()I\").throws_(NoSuchMethodError.class).done()\n-            .run();\n+            \/\/ invokeinterface to static method ==> ICCE\n+            b.test().callSite(I, C, \"m\", \"()I\").throws_(IncompatibleClassChangeError.class).done();\n@@ -355,0 +334,1 @@\n+        b.run();\n@@ -382,4 +362,2 @@\n-        if (!factory.getExecutionMode().equals(\"REFLECTION\")) {\n-            \/\/ invokeinterface to static method ==> ICCE\n-            b.test().callSite(I, C, \"m\", \"()I\").throws_(IncompatibleClassChangeError.class).done()\n-             .test().callSite(C, C, \"m\", \"()I\").returns(2).done().run();\n+        if (factory.getExecutionMode().equals(\"REFLECTION\")) {\n+            b.test().callSite(I, C, \"m\", \"()I\").returns(1).done();\n@@ -387,2 +365,2 @@\n-            b.test().callSite(I, C, \"m\", \"()I\").returns(1).done()\n-             .test().callSite(C, C, \"m\", \"()I\").returns(2).done().run();\n+            \/\/ invokeinterface to static method ==> ICCE\n+            b.test().callSite(I, C, \"m\", \"()I\").throws_(IncompatibleClassChangeError.class).done();\n@@ -391,0 +369,3 @@\n+        b.test().callSite(C, C, \"m\", \"()I\").returns(2).done();\n+\n+        b.run();\n@@ -422,6 +403,7 @@\n-        if (!factory.getExecutionMode().equals(\"REFLECTION\")) {\n-            b.test().staticCallSite(I, \"m\", \"()I\").returns(1).done()\n-             .test().callSite(I, C, \"m\", \"()I\").throws_(IncompatibleClassChangeError.class).done()\n-             .test().callSite(J, C, \"m\", \"()I\").returns(2).done()\n-             .test().callSite(C, C, \"m\", \"()I\").returns(2).done()\n-            .run();\n+        b.test().staticCallSite(I, \"m\", \"()I\").returns(1).done()\n+\n+         .test().callSite(J, C, \"m\", \"()I\").returns(2).done()\n+         .test().callSite(C, C, \"m\", \"()I\").returns(2).done();\n+\n+        if (factory.getExecutionMode().equals(\"REFLECTION\")) {\n+            b.test().callSite(I, C, \"m\", \"()I\").returns(1).done();\n@@ -429,5 +411,1 @@\n-            b.test().staticCallSite(I, \"m\", \"()I\").returns(1).done()\n-             .test().callSite(I, C, \"m\", \"()I\").returns(1).done()\n-             .test().callSite(J, C, \"m\", \"()I\").returns(2).done()\n-             .test().callSite(C, C, \"m\", \"()I\").returns(2).done()\n-            .run();\n+            b.test().callSite(I, C, \"m\", \"()I\").throws_(IncompatibleClassChangeError.class).done();\n@@ -436,0 +414,1 @@\n+        b.run();\n@@ -470,4 +449,2 @@\n-        if (!factory.getExecutionMode().equals(\"REFLECTION\")) {\n-            b.test().callSite(I, C, \"m\", \"()I\").returns(1).done()\n-             .test().callSite(J, C, \"m\", \"()I\").throws_(IncompatibleClassChangeError.class).done()\n-             .test().callSite(C, C, \"m\", \"()I\").returns(1).done()\n+        b.test().callSite(I, C, \"m\", \"()I\").returns(1).done()\n+         .test().callSite(C, C, \"m\", \"()I\").returns(1).done();\n@@ -475,3 +452,1 @@\n-            .run();\n-\n-        } else {\n+        if (factory.getExecutionMode().equals(\"REFLECTION\")) {\n@@ -480,6 +455,3 @@\n-\n-            b.test().callSite(I, C, \"m\", \"()I\").returns(1).done()\n-             .test().callSite(J, C, \"m\", \"()I\").returns(2).done()\n-             .test().callSite(C, C, \"m\", \"()I\").returns(1).done()\n-\n-            .run();\n+            b.test().callSite(J, C, \"m\", \"()I\").returns(2).done();\n+        } else {\n+            b.test().callSite(J, C, \"m\", \"()I\").throws_(IncompatibleClassChangeError.class).done();\n@@ -487,0 +459,2 @@\n+\n+        b.run();\n@@ -521,5 +495,2 @@\n-        if (!factory.getExecutionMode().equals(\"REFLECTION\")) {\n-            b.test().callSite(I, C, \"m\", \"()I\").throws_(IncompatibleClassChangeError.class).done()\n-             .test().callSite(J, C, \"m\", \"()I\").throws_(AbstractMethodError.class).done()\n-             .test().callSite(C, C, \"m\", \"()I\").throws_(AbstractMethodError.class).done()\n-            .run();\n+        if (factory.getExecutionMode().equals(\"REFLECTION\")) {\n+            b.test().callSite(I, C, \"m\", \"()I\").returns(1).done();\n@@ -527,4 +498,1 @@\n-            b.test().callSite(I, C, \"m\", \"()I\").returns(1).done()\n-             .test().callSite(J, C, \"m\", \"()I\").throws_(AbstractMethodError.class).done()\n-             .test().callSite(C, C, \"m\", \"()I\").throws_(AbstractMethodError.class).done()\n-            .run();\n+            b.test().callSite(I, C, \"m\", \"()I\").throws_(IncompatibleClassChangeError.class).done();\n@@ -532,0 +500,5 @@\n+\n+        b.test().callSite(J, C, \"m\", \"()I\").throws_(AbstractMethodError.class).done()\n+         .test().callSite(C, C, \"m\", \"()I\").throws_(AbstractMethodError.class).done();\n+\n+        b.run();\n@@ -566,4 +539,2 @@\n-        if (!factory.getExecutionMode().equals(\"REFLECTION\")) {\n-            b.test().callSite(I, C, \"m\", \"()I\").throws_(AbstractMethodError.class).done()\n-             .test().callSite(J, C, \"m\", \"()I\").throws_(IncompatibleClassChangeError.class).done()\n-             .test().callSite(C, C, \"m\", \"()I\").throws_(AbstractMethodError.class).done()\n+        b.test().callSite(I, C, \"m\", \"()I\").throws_(AbstractMethodError.class).done()\n+         .test().callSite(C, C, \"m\", \"()I\").throws_(AbstractMethodError.class).done();\n@@ -571,1 +542,2 @@\n-            .run();\n+        if (factory.getExecutionMode().equals(\"REFLECTION\")) {\n+            b.test().callSite(J, C, \"m\", \"()I\").returns(1).done();\n@@ -573,5 +545,1 @@\n-            b.test().callSite(I, C, \"m\", \"()I\").throws_(AbstractMethodError.class).done()\n-             .test().callSite(J, C, \"m\", \"()I\").returns(1).done()\n-             .test().callSite(C, C, \"m\", \"()I\").throws_(AbstractMethodError.class).done()\n-\n-            .run();\n+            b.test().callSite(J, C, \"m\", \"()I\").throws_(IncompatibleClassChangeError.class).done();\n@@ -579,0 +547,2 @@\n+\n+        b.run();\n@@ -608,5 +578,5 @@\n-        if (!factory.getExecutionMode().equals(\"REFLECTION\")) {\n-            b.test().callSite(I, C, \"m\",\"()I\").throws_(IncompatibleClassChangeError.class).done()\n-             .test().callSite(B, C, \"m\",\"()I\").throws_(NoSuchMethodError.class).done()\n-             .test().callSite(C, C, \"m\",\"()I\").throws_(NoSuchMethodError.class).done()\n-            .run();\n+        b.test().callSite(B, C, \"m\",\"()I\").throws_(NoSuchMethodError.class).done()\n+         .test().callSite(C, C, \"m\",\"()I\").throws_(NoSuchMethodError.class).done();\n+\n+        if (factory.getExecutionMode().equals(\"REFLECTION\")) {\n+            b.test().callSite(I, C, \"m\",\"()I\").returns(1).done();\n@@ -614,4 +584,1 @@\n-            b.test().callSite(I, C, \"m\",\"()I\").returns(1).done()\n-             .test().callSite(B, C, \"m\",\"()I\").throws_(NoSuchMethodError.class).done()\n-             .test().callSite(C, C, \"m\",\"()I\").throws_(NoSuchMethodError.class).done()\n-            .run();\n+            b.test().callSite(I, C, \"m\",\"()I\").throws_(IncompatibleClassChangeError.class).done();\n@@ -620,0 +587,1 @@\n+        b.run();\n@@ -650,6 +618,7 @@\n-        if (!factory.getExecutionMode().equals(\"REFLECTION\")) {\n-            b.test().staticCallSite(I, \"m\",\"()I\").returns(1).done()\n-             .test().callSite(I, C, \"m\",\"()I\").throws_(IncompatibleClassChangeError.class).done()\n-             .test().callSite(B, C, \"m\",\"()I\").returns(2).done()\n-             .test().callSite(C, C, \"m\",\"()I\").returns(2).done()\n-            .run();\n+        b.test().staticCallSite(I, \"m\",\"()I\").returns(1).done()\n+\n+         .test().callSite(B, C, \"m\",\"()I\").returns(2).done()\n+         .test().callSite(C, C, \"m\",\"()I\").returns(2).done();\n+\n+        if (factory.getExecutionMode().equals(\"REFLECTION\")) {\n+            b.test().callSite(I, C, \"m\",\"()I\").returns(1).done();\n@@ -657,5 +626,1 @@\n-            b.test().staticCallSite(I, \"m\",\"()I\").returns(1).done()\n-             .test().callSite(I, C, \"m\",\"()I\").returns(1).done()\n-             .test().callSite(B, C, \"m\",\"()I\").returns(2).done()\n-             .test().callSite(C, C, \"m\",\"()I\").returns(2).done()\n-            .run();\n+            b.test().callSite(I, C, \"m\",\"()I\").throws_(IncompatibleClassChangeError.class).done();\n@@ -664,0 +629,1 @@\n+        b.run();\n@@ -698,5 +664,5 @@\n-        if (!factory.getExecutionMode().equals(\"REFLECTION\")) {\n-            b.test().callSite(I, C, \"m\", \"()I\").throws_(IncompatibleClassChangeError.class).done()\n-             .test().callSite(J, C, \"m\", \"()I\").returns(2).done()\n-             .test().callSite(C, C, \"m\", \"()I\").returns(2).done()\n-            .run();\n+        b.test().callSite(J, C, \"m\", \"()I\").returns(2).done()\n+         .test().callSite(C, C, \"m\", \"()I\").returns(2).done();\n+\n+        if (factory.getExecutionMode().equals(\"REFLECTION\")) {\n+            b.test().callSite(I, C, \"m\", \"()I\").returns(1).done();\n@@ -704,4 +670,1 @@\n-            b.test().callSite(I, C, \"m\", \"()I\").returns(1).done()\n-             .test().callSite(J, C, \"m\", \"()I\").returns(2).done()\n-             .test().callSite(C, C, \"m\", \"()I\").returns(2).done()\n-            .run();\n+            b.test().callSite(I, C, \"m\", \"()I\").throws_(IncompatibleClassChangeError.class).done();\n@@ -710,0 +673,1 @@\n+        b.run();\n@@ -711,0 +675,1 @@\n+\n@@ -743,4 +708,4 @@\n-        if (!factory.getExecutionMode().equals(\"REFLECTION\")) {\n-            b.test().callSite(C, C, \"m\", \"()I\").throws_(IncompatibleClassChangeError.class).done()\n-             .test().callSite(I, C, \"m\", \"()I\").returns(1).done()\n-            .run();\n+        b.test().callSite(I, C, \"m\", \"()I\").returns(1).done();\n+\n+        if (factory.getExecutionMode().equals(\"REFLECTION\")) {\n+            b.test().callSite(C, C, \"m\", \"()I\").returns(2).done();\n@@ -748,3 +713,1 @@\n-            b.test().callSite(C, C, \"m\", \"()I\").returns(2).done()\n-             .test().callSite(I, C, \"m\", \"()I\").returns(1).done()\n-            .run();\n+            b.test().callSite(C, C, \"m\", \"()I\").throws_(IncompatibleClassChangeError.class).done();\n@@ -752,0 +715,2 @@\n+\n+        b.run();\n@@ -785,4 +750,6 @@\n-        if (!factory.getExecutionMode().equals(\"REFLECTION\")) {\n-            b.test().callSite(A, A, \"m\", \"()I\").throws_(IncompatibleClassChangeError.class).done()\n-             .test().callSite(I, A, \"m\", \"()I\").returns(1).done()\n-            .run();\n+        b.test().callSite(I, A, \"m\", \"()I\").returns(1).done();\n+        b.test().callSite(I, C, \"m\", \"()I\").returns(1).done();\n+\n+        if (factory.getExecutionMode().equals(\"REFLECTION\")) {\n+            b.test().callSite(A, A, \"m\", \"()I\").returns(2).done();\n+            b.test().callSite(C, C, \"m\", \"()I\").returns(2).done();\n@@ -790,3 +757,2 @@\n-            b.test().callSite(A, A, \"m\", \"()I\").returns(2).done()\n-             .test().callSite(I, A, \"m\", \"()I\").returns(1).done()\n-            .run();\n+            b.test().callSite(C, C, \"m\", \"()I\").throws_(IncompatibleClassChangeError.class).done();\n+            b.test().callSite(A, A, \"m\", \"()I\").throws_(IncompatibleClassChangeError.class).done();\n@@ -794,0 +760,2 @@\n+\n+        b.run();\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/runtime\/defmeth\/StaticMethodsTest.java","additions":105,"deletions":137,"binary":false,"changes":242,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -198,2 +198,0 @@\n-                                        \"-ignoreCrashes\",\n-                                        \"-ignoreKnownFailures\",\n@@ -225,14 +223,0 @@\n-        \/\/Workaround for the deadlock caused by\n-        \/\/ JDK-7122142: \"(ann) Race condition between isAnnotationPresent and getAnnotations\"\n-        try {\n-            \/\/ Do a warm-up cycle\n-            for (Class<? extends DefMethTest> testClass : DefMethTest.getTests()) {\n-                DefMethTest test = testClass.newInstance();\n-\n-                OptionSupport.setupAndRun(test,\n-                        new String[] { \"-silent\", \"-ignoreKnownFailures\"});\n-            }\n-        } catch(InstantiationException | IllegalAccessException e) {\n-            throw new RuntimeException(e);\n-        }\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/runtime\/defmeth\/StressTest.java","additions":1,"deletions":17,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-import vm.runtime.defmeth.shared.annotation.KnownFailure;\n@@ -355,1 +354,0 @@\n-    @KnownFailure(modes = { INVOKE_EXACT, INVOKE_GENERIC, INVOKE_WITH_ARGS, INDY }) \/\/ Test2_J_C_m: AME => IAE => ICCE instead of successful call\n@@ -397,1 +395,0 @@\n-    @KnownFailure(modes = { INVOKE_EXACT, INVOKE_GENERIC, INVOKE_WITH_ARGS, INDY }) \/\/ Test2_J_C_m: AME => IAE => ICCE instead of successful call\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/runtime\/defmeth\/SuperCallTest.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -33,0 +33,2 @@\n+\n+import static java.lang.invoke.MethodHandleInfo.REF_newInvokeSpecial;\n@@ -293,2 +295,1 @@\n-    private void prepareParams(CallMethod callSite) {\n-        \/\/ Prepare receiver\n+    private void prepareReceiver(CallMethod callSite) {\n@@ -297,1 +298,3 @@\n-                mv.visitVarInsn(ALOAD,0);\n+                if (!callSite.isConstructorCall()) {\n+                    mv.visitVarInsn(ALOAD, 0);\n+                }\n@@ -307,1 +310,1 @@\n-                                       \"<init>\", \"()V\", false);\n+                            \"<init>\", \"()V\", false);\n@@ -317,0 +320,1 @@\n+    }\n@@ -318,0 +322,2 @@\n+    private void prepareParams(CallMethod callSite) {\n+        prepareReceiver(callSite);\n@@ -326,6 +332,15 @@\n-        return new Handle(\n-                \/* tag *\/ callSite.invokeInsn().tag(),\n-                \/* owner *\/ callSite.staticClass().intlName(),\n-                \/* name *\/ callSite.methodName(),\n-                \/* desc *\/ callSite.methodDesc(),\n-                \/* interface *\/ callSite.isInterface());\n+        if (callSite.isConstructorCall()) {\n+            return new Handle(\n+                    \/* tag *\/   REF_newInvokeSpecial,\n+                    \/* owner *\/ callSite.staticClass().intlName(),\n+                    \/* name *\/  callSite.methodName(),\n+                    \/* desc *\/  callSite.methodDesc(),\n+                    \/* interface *\/ false);\n+        } else {\n+            return new Handle(\n+                    \/* tag *\/ callSite.invokeInsn().tag(),\n+                    \/* owner *\/ callSite.staticClass().intlName(),\n+                    \/* name *\/ callSite.methodName(),\n+                    \/* desc *\/ callSite.methodDesc(),\n+                    \/* interface *\/ callSite.isInterface());\n+        }\n@@ -359,3 +374,7 @@\n-        return (callSite.invokeInsn() != CallMethod.Invoke.STATIC) ?\n-                prependType(callSite.methodDesc(), callSite.staticClass().intlName()) :\n-                callSite.methodDesc(); \/\/ ignore receiver for static call\n+        if (callSite.isConstructorCall()) {\n+            return String.format(\"()L%s;\", callSite.staticClass().intlName());\n+        }\n+        if (callSite.invokeInsn() == CallMethod.Invoke.STATIC) {\n+            return callSite.methodDesc(); \/\/ ignore receiver\n+        }\n+        return prependType(callSite.methodDesc(), callSite.staticClass().intlName());\n@@ -371,1 +390,2 @@\n-        mv.visitInvokeDynamicInsn(callSite.methodName(), callSiteDesc, bootstrap);\n+        String name = callSite.isConstructorCall() ? \"init\" : callSite.methodName();\n+        mv.visitInvokeDynamicInsn(name, callSiteDesc, bootstrap);\n@@ -405,12 +425,20 @@\n-        prepareParams(callSite);\n-\n-        \/\/ Call method\n-        mv.visitMethodInsn(\n-                callSite.invokeInsn().opcode(),\n-                callSite.staticClass().intlName(),\n-                callSite.methodName(), callSite.methodDesc(),\n-                callSite.isInterface());\n-\n-        \/\/ Pop method result, if necessary\n-        if (callSite.popReturnValue()) {\n-            mv.visitInsn(POP);\n+        if (callSite.isConstructorCall()) {\n+            String receiver = callSite.receiverClass().intlName();\n+            \/\/ Construct new instance\n+            mv.visitTypeInsn(NEW, receiver);\n+            mv.visitMethodInsn(INVOKESPECIAL, receiver,\n+                    \"<init>\", \"()V\", false);\n+        } else {\n+            prepareParams(callSite);\n+\n+            \/\/ Call method\n+            mv.visitMethodInsn(\n+                    callSite.invokeInsn().opcode(),\n+                    callSite.staticClass().intlName(),\n+                    callSite.methodName(), callSite.methodDesc(),\n+                    callSite.isInterface());\n+\n+            \/\/ Pop method result, if necessary\n+            if (callSite.popReturnValue()) {\n+                mv.visitInsn(POP);\n+            }\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/runtime\/defmeth\/shared\/ClassFileGenerator.java","additions":54,"deletions":26,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,2 +45,0 @@\n-import vm.runtime.defmeth.shared.annotation.Crash;\n-import vm.runtime.defmeth.shared.annotation.KnownFailure;\n@@ -55,1 +53,0 @@\n-import vm.runtime.defmeth.shared.annotation.NotTest;\n@@ -101,9 +98,0 @@\n-    @Option(name=\"ignoreKnownFailures\", default_value=\"false\", description=\"ignore tests with known failures\")\n-    boolean ignoreKnownFailures;\n-\n-    @Option(name=\"runOnlyFailingTests\", default_value=\"false\", description=\"run only failing tests\")\n-    boolean runOnlyFailingTests;\n-\n-    @Option(name=\"ignoreCrashes\", default_value=\"false\", description=\"don't run tests with crash VM\")\n-    boolean ignoreCrashes;\n-\n@@ -120,1 +108,1 @@\n-    private String mode;\n+    String mode;\n@@ -207,6 +195,1 @@\n-        if (m.isAnnotationPresent(NotTest.class)\n-                || (ignoreCrashes && m.isAnnotationPresent(Crash.class))\n-                || !Modifier.isPublic(acc) || Modifier.isStatic(acc)\n-                \/\/|| m.getReturnType() != Void.class\n-                || m.getParameterTypes().length != 0)\n-        {\n+        if (!Modifier.isPublic(acc) || Modifier.isStatic(acc) || m.getParameterTypes().length != 0) {\n@@ -233,13 +216,0 @@\n-          if (ignoreKnownFailures &&\n-            m.isAnnotationPresent(KnownFailure.class)) {\n-            ExecutionMode[] modes = m.getAnnotation(KnownFailure.class).modes();\n-\n-            if (modes.length == 0)  return false; \/\/ by default, matches all modes\n-\n-            for (ExecutionMode knownFailingMode : modes) {\n-                if (mode == knownFailingMode) {\n-                    return false; \/\/ known failure in current mode\n-                }\n-            }\n-        }\n-\n@@ -277,3 +247,0 @@\n-     *   - ignore tests marked as @KnownFailure\n-     *   - ignore tests marked as @Crash\n-     *   - only run tests marked as @KnownFailure\n@@ -284,4 +251,0 @@\n-        if (ignoreKnownFailures && runOnlyFailingTests) {\n-            throw new IllegalArgumentException(\"conflicting parameters\");\n-        }\n-\n@@ -292,1 +255,0 @@\n-            int passedTests = 0;\n@@ -343,1 +305,1 @@\n-            passedTests = totalTests - numFailures;\n+            int passedTests = totalTests - numFailures;\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/runtime\/defmeth\/shared\/DefMethTest.java","additions":4,"deletions":42,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,2 @@\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Executable;\n@@ -47,0 +49,5 @@\n+    public static Object invoke(Constructor m, Object... args)\n+            throws InvocationTargetException, IllegalAccessException, InstantiationException {\n+        return m.newInstance(args);\n+    }\n+\n@@ -59,1 +66,5 @@\n-            mh = LOOKUP.findSpecial(declaringClass, methodName, type, declaringClass);\n+            if (methodName.equals(\"<init>\") && type.returnType() == void.class) {\n+                mh = LOOKUP.findConstructor(declaringClass, type);\n+            } else {\n+                mh = LOOKUP.findSpecial(declaringClass, methodName, type, declaringClass);\n+            }\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/runtime\/defmeth\/shared\/TestContext.java","additions":13,"deletions":2,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -1,38 +0,0 @@\n-\/*\n- * Copyright (c) 2013, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package vm.runtime.defmeth.shared.annotation;\n-\n-import java.lang.annotation.ElementType;\n-import java.lang.annotation.Retention;\n-import java.lang.annotation.RetentionPolicy;\n-import java.lang.annotation.Target;\n-\n-\/**\n- * Mark a test that it may crash VM.\n- * Allows to exclude all such tests when crashes are undesirable\n- * (e.g. same VM execution mode).\n- *\/\n-@Retention(RetentionPolicy.RUNTIME)\n-@Target(ElementType.METHOD)\n-public @interface Crash {}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/runtime\/defmeth\/shared\/annotation\/Crash.java","additions":0,"deletions":38,"binary":false,"changes":38,"status":"deleted"},{"patch":"@@ -1,41 +0,0 @@\n-\/*\n- * Copyright (c) 2013, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package vm.runtime.defmeth.shared.annotation;\n-\n-import vm.runtime.defmeth.shared.ExecutionMode;\n-\n-import java.lang.annotation.ElementType;\n-import java.lang.annotation.Retention;\n-import java.lang.annotation.RetentionPolicy;\n-import java.lang.annotation.Target;\n-\n-\/**\n- * Mark a test that it may fail (due to a test or product bug).\n- * Allows to exclude all failing tests when failures are undesirable.\n- *\/\n-@Retention(RetentionPolicy.RUNTIME)\n-@Target(ElementType.METHOD)\n-public @interface KnownFailure {\n-    ExecutionMode[] modes() default {};\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/runtime\/defmeth\/shared\/annotation\/KnownFailure.java","additions":0,"deletions":41,"binary":false,"changes":41,"status":"deleted"},{"patch":"@@ -1,39 +0,0 @@\n-\/*\n- * Copyright (c) 2013, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package vm.runtime.defmeth.shared.annotation;\n-\n-import java.lang.annotation.ElementType;\n-import java.lang.annotation.Retention;\n-import java.lang.annotation.RetentionPolicy;\n-import java.lang.annotation.Target;\n-\n-\/*\n- * Explicitly marks a method as not a test, thus ensuring that it won't be\n- * executed as part of a test run.\n- *\/\n-@Retention(RetentionPolicy.RUNTIME)\n-@Target(ElementType.METHOD)\n-public @interface NotTest {\n-\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/runtime\/defmeth\/shared\/annotation\/NotTest.java","additions":0,"deletions":39,"binary":false,"changes":39,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -140,0 +140,7 @@\n+    public TesterBuilder callSite(Clazz I, String methodName, String methodDesc, int acc) {\n+        if ((acc & ACC_PRIVATE) != 0) {\n+            testPrivateMethod = true;\n+        }\n+        return static_(I).callee(methodName, methodDesc, acc);\n+    }\n+\n@@ -142,1 +149,1 @@\n-        this.testPrivateMethod = true;\n+        testPrivateMethod = true;\n@@ -156,0 +163,4 @@\n+    public TesterBuilder new_(ConcreteClass receiver) {\n+        return callSite(receiver, receiver,\"<init>\", \"()V\");\n+    }\n+\n@@ -220,9 +231,7 @@\n-        } else {\n-            if (staticReceiver instanceof Interface) {\n-                return Invoke.INTERFACE;\n-            } else if (staticReceiver instanceof ConcreteClass) {\n-                if ((m.acc() & Opcodes.ACC_INTERFACE) == 0) {\n-                    return Invoke.VIRTUAL;\n-                } else {\n-                    return Invoke.INTERFACE;\n-                }\n+        } else if (staticReceiver instanceof Interface) {\n+            return Invoke.INTERFACE;\n+        } else if (staticReceiver instanceof ConcreteClass) {\n+            if (m.isConstructor()) {\n+                return Invoke.SPECIAL;\n+            } else if ((m.acc() & Opcodes.ACC_INTERFACE) == 0) {\n+                return Invoke.VIRTUAL;\n@@ -230,1 +239,1 @@\n-                throw new UnsupportedOperationException(\"Can't detect invoke instruction\");\n+                return Invoke.INTERFACE;\n@@ -232,0 +241,2 @@\n+        } else {\n+            throw new UnsupportedOperationException(\"Can't detect invoke instruction\");\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/runtime\/defmeth\/shared\/builder\/TesterBuilder.java","additions":23,"deletions":12,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -69,0 +69,4 @@\n+    public boolean isConstructor() {\n+        return name.equals(\"<init>\") &&\n+               desc.equals(\"()V\");\n+    }\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/runtime\/defmeth\/shared\/data\/method\/Method.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -174,0 +174,6 @@\n+    public boolean isConstructorCall() {\n+        return invokeInsn() == Invoke.SPECIAL &&\n+               methodName().equals(\"<init>\") &&\n+               methodDesc().equals(\"()V\");\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/runtime\/defmeth\/shared\/data\/method\/body\/CallMethod.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -111,1 +111,1 @@\n-            if (call.invokeInsn() != CallMethod.Invoke.STATIC) {\n+            if (!call.isConstructorCall() && call.invokeInsn() != CallMethod.Invoke.STATIC) {\n@@ -118,2 +118,1 @@\n-                \/\/ No need for a receiver for static call\n-                args = values;\n+                args = values; \/\/ no receiver\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/runtime\/defmeth\/shared\/executor\/MHInvokeWithArgsTest.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,3 +48,1 @@\n-import java.lang.reflect.InvocationTargetException;\n-import java.lang.reflect.Method;\n-import java.lang.reflect.Modifier;\n+import java.lang.reflect.*;\n@@ -78,1 +76,1 @@\n-        private Method targetMethod;\n+        private Executable targetMethod;\n@@ -109,5 +107,2 @@\n-            String methodName = call.methodName();\n-            Class[] paramTypes = paramType(call.methodDesc());\n-\n-            if (tester.getTestPrivateMethod() != true) {\n-                targetMethod = staticClass.getMethod(methodName, paramTypes);\n+            if (call.isConstructorCall()) {\n+                targetMethod = staticClass.getDeclaredConstructor();\n@@ -115,3 +110,2 @@\n-                try {\n-                    targetMethod = staticClass.getDeclaredMethod(methodName, paramTypes);\n-                } catch (NoSuchMethodException nsme) {}\n+                String methodName = call.methodName();\n+                Class[] paramTypes = paramType(call.methodDesc());\n@@ -119,2 +113,3 @@\n-                Class clazz = staticClass.getSuperclass();\n-                while ((targetMethod == null) && (clazz != null)) {\n+                if (tester.getTestPrivateMethod() != true) {\n+                    targetMethod = staticClass.getMethod(methodName, paramTypes);\n+                } else {\n@@ -122,1 +117,1 @@\n-                        targetMethod = clazz.getDeclaredMethod(methodName, paramTypes);\n+                        targetMethod = staticClass.getDeclaredMethod(methodName, paramTypes);\n@@ -124,1 +119,8 @@\n-                    clazz = clazz.getSuperclass();\n+\n+                    Class clazz = staticClass.getSuperclass();\n+                    while ((targetMethod == null) && (clazz != null)) {\n+                        try {\n+                            targetMethod = clazz.getDeclaredMethod(methodName, paramTypes);\n+                        } catch (NoSuchMethodException nsme) {}\n+                        clazz = clazz.getSuperclass();\n+                    }\n@@ -126,1 +128,0 @@\n-            }\n@@ -128,2 +129,2 @@\n-            \/\/ Check reflection info for Class.getMethod(...)\n-            checkReflectionInfo(targetMethod);\n+                \/\/ Check reflection info for Class.getMethod(...)\n+                checkReflectionInfo((Method)targetMethod);\n@@ -131,7 +132,7 @@\n-            \/\/ Prepare receiver after resolving target method, because it can throw instantiation exception\n-            if (call.invokeInsn() != CallMethod.Invoke.STATIC) {\n-                Class<?> receiverClass = resolve(call.receiverClass());\n-                receiver = receiverClass.newInstance();\n-            } else {\n-                \/\/ receiver == null; Method.invoke ignores first argument when static method is called\n-            }\n+                \/\/ Prepare receiver after resolving target method, because it can throw instantiation exception\n+                if (call.invokeInsn() != CallMethod.Invoke.STATIC) {\n+                    Class<?> receiverClass = resolve(call.receiverClass());\n+                    receiver = receiverClass.newInstance();\n+                } else {\n+                    \/\/ receiver == null; Method.invoke ignores first argument when static method is called\n+                }\n@@ -139,5 +140,7 @@\n-            \/\/ Check reflection info for Class.getDeclaredMethod(...)\n-            try {\n-                Method m = staticClass.getDeclaredMethod(methodName, paramTypes);\n-                checkReflectionInfo(m);\n-            } catch (NoSuchMethodException e) {}\n+                \/\/ Check reflection info for Class.getDeclaredMethod(...)\n+                try {\n+                    Method m = staticClass.getDeclaredMethod(methodName, paramTypes);\n+                    checkReflectionInfo(m);\n+                } catch (NoSuchMethodException e) {\n+                }\n+            }\n@@ -240,0 +243,12 @@\n+        private Object invokeInTestContext(Constructor m, Object... args)\n+                throws InvocationTargetException {\n+            Class<?> context = cl.getTestContext();\n+            try {\n+                \/\/ Invoke target method from TestContext using TestContext.invoke(Constructor, Object...)\n+                Method invoker = context.getDeclaredMethod(\"invoke\", Constructor.class, Object[].class);\n+                return invoker.invoke(null, m, args);\n+            } catch (NoSuchMethodException | IllegalAccessException e) {\n+                throw new TestFailure(\"Exception during reflection invocation\", e.getCause());\n+            }\n+        }\n+\n@@ -244,1 +259,1 @@\n-                int result = (int) invokeInTestContext(targetMethod, receiver, values);\n+                int result = (int) invokeInTestContext((Method)targetMethod, receiver, values);\n@@ -296,2 +311,7 @@\n-                invokeInTestContext(targetMethod, receiver, values);\n-\n+                if (targetMethod instanceof Method) {\n+                    invokeInTestContext((Method)targetMethod, receiver, values);\n+                } else if (targetMethod instanceof Constructor) {\n+                    invokeInTestContext((Constructor)targetMethod, receiver, values);\n+                } else {\n+                    throw new InternalError(\"Unknown target: \" + targetMethod);\n+                }\n@@ -312,1 +332,7 @@\n-                invokeInTestContext(targetMethod, receiver, values);\n+                if (targetMethod instanceof Method) {\n+                    invokeInTestContext((Method)targetMethod, receiver, values);\n+                } else if (targetMethod instanceof Constructor) {\n+                    invokeInTestContext((Constructor)targetMethod, receiver, values);\n+                } else {\n+                    throw new InternalError(\"Unknown target: \" + targetMethod);\n+                }\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/runtime\/defmeth\/shared\/executor\/ReflectionTest.java","additions":62,"deletions":36,"binary":false,"changes":98,"status":"modified"}]}