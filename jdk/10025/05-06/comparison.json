{"files":[{"patch":"@@ -129,0 +129,3 @@\n+  if (_bit_pos == 0) {\n+    return _buffer[_position++];\n+  }\n@@ -168,1 +171,1 @@\n-int CompressedSparseDataWriteStream::position() {\n+void CompressedSparseDataWriteStream::write_zero() {\n@@ -170,1 +173,1 @@\n-    return _position;\n+    _buffer[_position] = 0;\n@@ -172,12 +175,7 @@\n-  \/\/ flush current data and start a new byte\n-  write(_curr_byte << (8 - _bit_pos));\n-  _curr_byte = 0;\n-  _bit_pos = 0;\n-  return _position;\n-}\n-\n-void CompressedSparseDataWriteStream::write_zero() {\n-  _curr_byte <<= 1; \/\/ zero bit represents a zero word\n-  if (++_bit_pos == 8) {\n-    write(_curr_byte);\n-    _curr_byte = 0;\n+  _bit_pos++;\n+  if (_bit_pos == 8) {\n+    _position++;\n+    if (_position >= _size) {\n+      grow();\n+    }\n+    _buffer[_position] = 0;\n@@ -189,2 +187,12 @@\n-  write((_curr_byte << (8 - _bit_pos)) | (b >> _bit_pos));\n-  _curr_byte = (0xff >> (8 - _bit_pos)) & b;\n+  if (_bit_pos == 0) {\n+    _buffer[_position] = b;\n+  } else {\n+    _buffer[_position] |= (b >> _bit_pos);\n+  }\n+  _position++;\n+  if (_position >= _size) {\n+    grow();\n+  }\n+  if (_bit_pos > 0) {\n+    _buffer[_position] = (b << (8 - _bit_pos));\n+  }\n@@ -212,0 +220,1 @@\n+  assert(nsize > 0, \"debug data size must not exceed MAX_INT\");\n","filename":"src\/hotspot\/share\/code\/compressedStream.cpp","additions":25,"deletions":16,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -166,0 +166,1 @@\n+    _buffer[0] = 0;\n@@ -183,1 +184,11 @@\n-  int position(); \/\/ method have a side effect: the current byte becomes aligned\n+  void flush() {\n+    if (_bit_pos > 0) {\n+      \/\/ start a new byte\n+      _position++;\n+      _bit_pos = 0;\n+    }\n+  }\n+  int position() {\n+    flush(); \/\/ method have a side effect: the current byte becomes aligned\n+    return _position;\n+  }\n@@ -185,1 +196,1 @@\n-    position();\n+    flush();\n@@ -187,0 +198,1 @@\n+    _bit_pos = 0;\n@@ -188,0 +200,1 @@\n+\n@@ -190,2 +203,0 @@\n-  u_char _curr_byte {0};\n-\n@@ -193,6 +204,0 @@\n-  void write(u_char b) {\n-    if (_position >= _size) {\n-      grow();\n-    }\n-    _buffer[_position++] = b;\n-  }\n","filename":"src\/hotspot\/share\/code\/compressedStream.hpp","additions":15,"deletions":10,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-    curr_byte_ = (byte) read();\n@@ -35,2 +34,1 @@\n-  byte curr_byte_ = 0;\n-  int  byte_pos_  = 0;\n+  int bit_pos = 0;\n@@ -38,7 +36,2 @@\n-  public byte readByteImpl() {\n-    byte b = (byte) (curr_byte_ << byte_pos_);\n-    curr_byte_ = (byte) read();\n-    if (byte_pos_ > 0) {\n-      b |= (byte) ((0xFF & curr_byte_) >> (8 - byte_pos_));\n-    }\n-    return b;\n+  protected short buffer(int position) {\n+    return (short)buffer.getCIntegerAt(position, 1, true);\n@@ -47,7 +40,3 @@\n-  boolean readZero() {\n-    if (0 != (curr_byte_ & (1 << (7 - byte_pos_)))) {\n-      return false;\n-    }\n-    if (++byte_pos_ == 8) {\n-      byte_pos_ = 0;\n-      curr_byte_ = (byte) read();\n+  public byte readByteImpl() {\n+    if (bit_pos == 0) {\n+      return (byte)buffer(position++);\n@@ -55,1 +44,3 @@\n-    return true;\n+    byte b1 = (byte)(buffer(position) << bit_pos);\n+    byte b2 = (byte)(buffer(++position) >> (8 - bit_pos));\n+    return (byte)(b1 | b2);\n@@ -64,3 +55,3 @@\n-    for (int i = 0; 0 != ((i == 0) ? (b & 0x40) : (b & 0x80)); i++) {\n-        b = readByteImpl();\n-        result |= ((b & 0x7f) << (6 + 7 * i));\n+    for (int i = 0; (0 != ((i == 0) ? (b & 0x40) : (b & 0x80))); i++) {\n+      b = readByteImpl();\n+      result |= ((b & 0x7f) << (6 + 7 * i));\n@@ -71,0 +62,11 @@\n+  boolean readZero() {\n+    if (0 != (buffer(position) & (1 << (7 - bit_pos)))) {\n+      return false; \/\/ not a zero data\n+    }\n+    if (++bit_pos == 8) {\n+      position++;\n+      bit_pos = 0;\n+    }\n+    return true;\n+  }\n+\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/code\/CompressedSparseDataReadStream.java","additions":23,"deletions":21,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -0,0 +1,93 @@\n+\/*\n+ * Copyright (c) 2022, BELLSOFT. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"memory\/resourceArea.hpp\"\n+#include \"code\/debugInfo.hpp\"\n+#include \"unittest.hpp\"\n+\n+void check_int_encoding() {\n+  ResourceMark rm;\n+  DebugInfoWriteStream out(NULL, 100);\n+  u_char* buf = out.buffer();\n+\n+  out.set_position(0);\n+  out.write_int(0);\n+  out.write_int(0);\n+  out.write_int(0);\n+  out.write_int(0);\n+  out.write_int(0);\n+  out.write_int(0);\n+  out.write_int(0);\n+  out.write_int(0);\n+  ASSERT_TRUE(out.position() == 1 && buf[0] == 0);\n+\n+  out.set_position(0);\n+  out.write_int(1);\n+  ASSERT_TRUE(out.position() == 1 && buf[0] == 0x81);\n+\n+  out.set_position(0);\n+  out.write_int(0xff);\n+  ASSERT_TRUE(out.position() == 2 && buf[0] == 0xff && buf[1] == 0x3);\n+\n+  out.set_position(0);\n+  out.write_int(0xffff);\n+  ASSERT_TRUE(out.position() == 3 && buf[0] == 0xff && buf[1] == 0xff && buf[2] == 0x7);\n+\n+  out.set_position(0);\n+  out.write_int(0xffffffff);\n+  ASSERT_TRUE(out.position() == 5 && ((buf[0] & buf[1] & buf[2] & buf[3]) == 0xff) && buf[4] == 0x1f);\n+}\n+\n+void check_read_write() {\n+  ResourceMark rm;\n+  DebugInfoWriteStream out(NULL, 100);\n+\n+  for (int i = 0; i < 1000*1000; i++) {\n+    out.write_int(i);\n+    out.write_bool((bool)i);\n+    out.write_byte((jbyte)i);\n+    out.write_signed_int((jint)i);\n+    out.write_double((jdouble)i);\n+    out.write_long((jlong)i);\n+  }\n+  out.flush();\n+\n+  u_char* buf = out.buffer();\n+  CompressedSparseDataReadStream in(buf, 0);\n+\n+  for (int i = 0; i < 1000*1000; i++) {\n+    ASSERT_TRUE(in.read_int() == i);\n+    ASSERT_TRUE(in.read_bool() == (bool)i);\n+    ASSERT_TRUE(in.read_byte() == (jbyte)i);\n+    ASSERT_TRUE(in.read_signed_int() == (jint)i);\n+    ASSERT_TRUE(in.read_double() == (jdouble)i);\n+    ASSERT_TRUE(in.read_long() == (jlong)i);\n+  }\n+}\n+\n+TEST_VM(DebugInfo, basic_test)\n+{\n+  check_int_encoding();\n+  check_read_write();\n+}\n","filename":"test\/hotspot\/gtest\/code\/test_debugInfoCompression.cpp","additions":93,"deletions":0,"binary":false,"changes":93,"status":"added"},{"patch":"@@ -0,0 +1,107 @@\n+\/*\n+ * Copyright (c) 2022, BELLSOFT. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import sun.jvm.hotspot.code.*;\n+import sun.jvm.hotspot.debugger.*;\n+\n+\/**\n+ * @test\n+ * @library \/test\/lib\n+ * @requires vm.hasSA\n+ * @modules jdk.hotspot.agent\/sun.jvm.hotspot.debugger\n+ *          jdk.hotspot.agent\/sun.jvm.hotspot.code\n+ * @run main\/othervm -Xbootclasspath\/a:. TestCompressedSparseDataReadStream\n+ *\/\n+public class TestCompressedSparseDataReadStream {\n+\n+    public static void main(String[] args) throws Exception {\n+        byte data[] = { (byte)0x08, (byte)0x1f, (byte)0xf0, (byte)0x00 };\n+        CompressedSparseDataReadStream in = new CompressedSparseDataReadStream(new Addr(data), 0);\n+        assertEquals(in.readInt(), 0);  \/\/ zero bit -> 0\n+        assertEquals(in.readInt(), 0);  \/\/ zero bit -> 0\n+        assertEquals(in.readInt(), 0);  \/\/ zero bit -> 0\n+        assertEquals(in.readInt(), 0);  \/\/ zero bit -> 0\n+        assertEquals(in.readInt(), 1);  \/\/ 0x81     -> 1\n+        assertEquals(in.readInt(), 63); \/\/ 0xff00   -> 63\n+        assertEquals(in.readInt(), 0);  \/\/ zero bit -> 0\n+        assertEquals(in.readInt(), 0);  \/\/ zero bit -> 0\n+        assertEquals(in.readInt(), 0);  \/\/ zero bit -> 0\n+        assertEquals(in.readInt(), 0);  \/\/ zero bit -> 0\n+        in.setPosition(2);\n+        assertEquals(in.readInt(), 48); \/\/ 0xf000   -> 48\n+    }\n+    private static void assertEquals(int a, int b) {\n+        if (a != b) throw new RuntimeException(\"assert failed: \" + a + \" != \" + b);\n+    }\n+}\n+\n+class DummyAddr implements sun.jvm.hotspot.debugger.Address {\n+    public boolean    equals(Object arg)                { return false; }\n+    public int        hashCode()                        { return 0; }\n+    public long       getCIntegerAt      (long offset, long numBytes, boolean isUnsigned) { return 0; }\n+    public Address    getAddressAt       (long offset)  { return null; }\n+    public Address    getCompOopAddressAt (long offset) { return null; }\n+    public Address    getCompKlassAddressAt (long offset) { return null; }\n+    public boolean    getJBooleanAt      (long offset)  { return false; }\n+    public byte       getJByteAt         (long offset)  { return 0; }\n+    public char       getJCharAt         (long offset)  { return 0; }\n+    public double     getJDoubleAt       (long offset)  { return 0; }\n+    public float      getJFloatAt        (long offset)  { return 0; }\n+    public int        getJIntAt          (long offset)  { return 0; }\n+    public long       getJLongAt         (long offset)  { return 0; }\n+    public short      getJShortAt        (long offset)  { return 0; }\n+    public OopHandle  getOopHandleAt     (long offset)  { return null; }\n+    public OopHandle  getCompOopHandleAt (long offset)  { return null; }\n+    public void       setCIntegerAt      (long offset, long numBytes, long value) {}\n+    public void       setAddressAt       (long offset, Address value) {}\n+    public void       setJBooleanAt      (long offset, boolean value) {}\n+    public void       setJByteAt         (long offset, byte value)    {}\n+    public void       setJCharAt         (long offset, char value)    {}\n+    public void       setJDoubleAt       (long offset, double value)  {}\n+    public void       setJFloatAt        (long offset, float value)   {}\n+    public void       setJIntAt          (long offset, int value)     {}\n+    public void       setJLongAt         (long offset, long value)    {}\n+    public void       setJShortAt        (long offset, short value)   {}\n+    public void       setOopHandleAt     (long offset, OopHandle value) {}\n+    public Address    addOffsetTo        (long offset)  { return null; }\n+    public OopHandle  addOffsetToAsOopHandle(long offset)  { return null; }\n+    public long       minus              (Address arg)  { return 0; }\n+    public boolean    lessThan           (Address arg)  { return false; }\n+    public boolean    lessThanOrEqual    (Address arg)  { return false; }\n+    public boolean    greaterThan        (Address arg)  { return false; }\n+    public boolean    greaterThanOrEqual (Address arg)  { return false; }\n+    public Address    andWithMask        (long mask)    { return null; }\n+    public Address    orWithMask         (long mask)    { return null; }\n+    public Address    xorWithMask        (long mask)    { return null; }\n+    public long       asLongValue        ()             { return 0; }\n+}\n+\n+class Addr extends DummyAddr {\n+    byte data[];\n+    public Addr(byte data[]) {\n+        this.data = data;\n+    }\n+    public long getCIntegerAt(long offset, long numBytes, boolean isUnsigned) {\n+        return data[(int)offset];\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/sa\/TestCompressedSparseDataReadStream.java","additions":107,"deletions":0,"binary":false,"changes":107,"status":"added"}]}