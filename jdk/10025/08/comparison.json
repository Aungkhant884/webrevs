{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -115,0 +115,118 @@\n+\n+\n+bool CompressedSparseDataReadStream::read_zero() {\n+  if (_buffer[_position] & (1 << (7 - _bit_pos))) {\n+    return 0; \/\/ not a zero data\n+  }\n+  if (++_bit_pos == 8) {\n+    _position++;\n+    _bit_pos = 0;\n+  }\n+  return 1;\n+}\n+\n+uint8_t CompressedSparseDataReadStream::read_byte_impl() {\n+  if (_bit_pos == 0) {\n+    return _buffer[_position++];\n+  }\n+  uint8_t b1 = _buffer[_position] << _bit_pos;\n+  uint8_t b2 = _buffer[++_position] >> (8 - _bit_pos);\n+  return b1 | b2;\n+}\n+\n+jint CompressedSparseDataReadStream::read_int() {\n+  if (read_zero()) {\n+    return 0;\n+  }\n+  \/\/ integer value encoded as a sequence of 1 to 5 bytes\n+  \/\/ - the most frequent case (0 < x < 64) is encoded in one byte\n+  \/\/ - the payload of the first byte is 6 bits, the payload of the following bytes is 7 bits\n+  \/\/ - the most significant bit in the first byte is occupied by a zero flag\n+  \/\/ - each byte has a bit indicating whether it is the last byte in the sequence\n+  \/\/\n+  \/\/       value | byte0    | byte1    | byte2    | byte3    | byte4\n+  \/\/  -----------+----------+----------+----------+----------+----------\n+  \/\/           0 | 0        |          |          |          |\n+  \/\/           1 | 10000001 |          |          |          |\n+  \/\/           2 | 10000010 |          |          |          |\n+  \/\/          63 | 10111111 |          |          |          |\n+  \/\/          64 | 11000000 | 00000001 |          |          |\n+  \/\/          65 | 11000001 | 00000001 |          |          |\n+  \/\/        8191 | 11111111 | 01111111 |          |          |\n+  \/\/        8192 | 11000000 | 10000000 | 00000001 |          |\n+  \/\/        8193 | 11000001 | 10000000 | 00000001 |          |\n+  \/\/     1048575 | 11111111 | 11111111 | 01111111 |          |\n+  \/\/     1048576 | 11000000 | 10000000 | 10000000 | 00000001 |\n+  \/\/  0xFFFFFFFF | 11111111 | 11111111 | 11111111 | 11111111 | 00011111\n+  \/\/\n+  uint8_t b = read_byte_impl();\n+  juint result = b & 0x3f;\n+  for (int i = 0; (i == 0) ? (b & 0x40) : (b & 0x80); i++) {\n+    b = read_byte_impl();\n+    result |= ((b & 0x7f) << (6 + 7 * i));\n+  }\n+  return (jint)result;\n+}\n+\n+void CompressedSparseDataWriteStream::write_zero() {\n+  if (_position >= _size) {\n+    grow();\n+  }\n+  if (_bit_pos == 0) {\n+    _buffer[_position] = 0;\n+  }\n+  _bit_pos++;\n+  if (_bit_pos == 8) {\n+    _position++;\n+    if (_position >= _size) {\n+      grow();\n+    }\n+    _buffer[_position] = 0;\n+    _bit_pos = 0;\n+  }\n+}\n+\n+void CompressedSparseDataWriteStream::write_byte_impl(uint8_t b) {\n+  if (_position >= _size) {\n+    grow();\n+  }\n+  if (_bit_pos == 0) {\n+    _buffer[_position] = b;\n+  } else {\n+    _buffer[_position] |= (b >> _bit_pos);\n+  }\n+  _position++;\n+  if (_bit_pos > 0) {\n+    if (_position >= _size) {\n+      grow();\n+    }\n+    _buffer[_position] = (b << (8 - _bit_pos));\n+  }\n+}\n+\n+\/\/ see CompressedSparseDataReadStream::read_int for a description of the encoding scheme\n+void CompressedSparseDataWriteStream::write_int(juint val) {\n+  if (val == 0) {\n+    write_zero();\n+    return;\n+  }\n+  int bit7 = 0x80; \/\/ first byte upper bit is set to indicate a value is not zero\n+  juint next = val >> 6;\n+  int bit6 = (next != 0) ? 0x40 : 0; \/\/ bit indicating a last byte\n+  write_byte_impl(bit7 | bit6 | (val & 0x3f));\n+  while (next != 0) {\n+    bit7 = (next >> 7) ? 0x80 : 0; \/\/ bit indicating a last byte\n+    write_byte_impl(bit7 | (next & 0x7f));\n+    next >>= 7;\n+  }\n+}\n+\n+void CompressedSparseDataWriteStream::grow() {\n+  int nsize = _size * 2;\n+  assert(nsize > 0, \"debug data size must not exceed MAX_INT\");\n+  assert(nsize > _position, \"sanity\");\n+  u_char* _new_buffer = NEW_RESOURCE_ARRAY(u_char, nsize);\n+  memcpy(_new_buffer, _buffer, _position);\n+  _buffer = _new_buffer;\n+  _size   = nsize;\n+}\n","filename":"src\/hotspot\/share\/code\/compressedStream.cpp","additions":119,"deletions":1,"binary":false,"changes":120,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+#include \"utilities\/moveBits.hpp\"\n@@ -76,1 +77,1 @@\n-\n+\/\/ Pack200 compression algorithm\n@@ -114,0 +115,94 @@\n+class CompressedBitStream : public ResourceObj {\n+protected:\n+  u_char* _buffer;\n+  int     _position; \/\/ current byte offset\n+  size_t  _bit_pos {0}; \/\/ current bit offset\n+\n+public:\n+  CompressedBitStream(u_char* buffer = NULL, int position = 0) {\n+    _buffer   = buffer;\n+    _position = position;\n+  }\n+\n+  u_char* buffer() const { return _buffer; }\n+};\n+\n+\/\/ Modified compression algorithm for a data set in which a significant part of the data is null\n+class CompressedSparseDataReadStream : public CompressedBitStream {\n+public:\n+  CompressedSparseDataReadStream(u_char* buffer, int position) : CompressedBitStream(buffer, position) {}\n+\n+  void set_position(int pos) {\n+    _bit_pos = 0;\n+    _position = pos;\n+  }\n+\n+  jboolean read_bool()       { return read_int(); }\n+  jbyte    read_byte()       { return read_int(); }\n+  jint     read_signed_int() { return UNSIGNED5::decode_sign(read_int()); }\n+  jint     read_int();\n+  jdouble  read_double() {\n+    jint h = reverse_bits(read_int());\n+    jint l = reverse_bits(read_int());\n+    return jdouble_cast(jlong_from(h, l));\n+  }\n+  jlong    read_long() {\n+    jint low  = read_signed_int();\n+    jint high = read_signed_int();\n+    return jlong_from(high, low);\n+  }\n+\n+protected:\n+  bool read_zero();\n+  uint8_t read_byte_impl();\n+  inline u_char read()       { return _buffer[_position++]; }\n+};\n+\n+class CompressedSparseDataWriteStream : public CompressedBitStream {\n+public:\n+  CompressedSparseDataWriteStream(int initial_size) : CompressedBitStream() {\n+    _buffer   = NEW_RESOURCE_ARRAY(u_char, initial_size);\n+    _size     = initial_size;\n+    _buffer[0] = 0;\n+  }\n+\n+  void write_bool(jboolean value)   { write_int(value ? 1 : 0); }\n+  void write_byte(jbyte value)      { write_int(value); }\n+  void write_signed_int(jint value) { write_int(UNSIGNED5::encode_sign(value)); }\n+  void write_int(juint value);\n+  void write_double(jdouble value)  {\n+    juint rh = reverse_bits(high(jlong_cast(value)));\n+    juint rl = reverse_bits(low( jlong_cast(value)));\n+    write_int(rh);\n+    write_int(rl);\n+  }\n+  void write_long(jlong value)      {\n+    write_signed_int(low(value));\n+    write_signed_int(high(value));\n+  }\n+\n+  void flush() {\n+    if (_bit_pos > 0) {\n+      \/\/ start a new byte\n+      _position++;\n+      _bit_pos = 0;\n+    }\n+  }\n+  int position() {\n+    flush(); \/\/ method have a side effect: the current byte becomes aligned\n+    return _position;\n+  }\n+  void set_position(int pos) {\n+    flush();\n+    _position = pos;\n+    _bit_pos = 0;\n+  }\n+\n+protected:\n+  int    _size;\n+  void grow();\n+\n+  void write_zero();  \/\/ The zero word is encoded with a single zero bit\n+  void write_byte_impl(uint8_t b);\n+};\n+\n","filename":"src\/hotspot\/share\/code\/compressedStream.hpp","additions":97,"deletions":2,"binary":false,"changes":99,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,1 +40,1 @@\n-: CompressedWriteStream(initial_size) {\n+: CompressedSparseDataWriteStream(initial_size) {\n","filename":"src\/hotspot\/share\/code\/debugInfo.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -298,1 +298,1 @@\n-class DebugInfoReadStream : public CompressedReadStream {\n+class DebugInfoReadStream : public CompressedSparseDataReadStream {\n@@ -305,1 +305,1 @@\n-    CompressedReadStream(code->scopes_data_begin(), offset) {\n+    CompressedSparseDataReadStream(code->scopes_data_begin(), offset) {\n@@ -324,1 +324,1 @@\n-\/\/ DebugInfoWriteStream specializes CompressedWriteStream for\n+\/\/ DebugInfoWriteStream specializes CompressedSparseDataWriteStream for\n@@ -327,1 +327,1 @@\n-class DebugInfoWriteStream : public CompressedWriteStream {\n+class DebugInfoWriteStream : public CompressedSparseDataWriteStream {\n","filename":"src\/hotspot\/share\/code\/debugInfo.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -95,1 +95,1 @@\n-  private short read() {\n+  protected short read() {\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/code\/CompressedReadStream.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,75 @@\n+\/*\n+ * Copyright (c) 2022, BELLSOFT. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.jvm.hotspot.code;\n+\n+import sun.jvm.hotspot.debugger.*;\n+\n+public class CompressedSparseDataReadStream extends CompressedReadStream {\n+\n+  public CompressedSparseDataReadStream(Address buffer, int position) {\n+    super(buffer, position);\n+  }\n+\n+  int bit_pos = 0;\n+\n+  protected short buffer(int position) {\n+    return (short)buffer.getCIntegerAt(position, 1, true);\n+  }\n+\n+  public byte readByteImpl() {\n+    if (bit_pos == 0) {\n+      return (byte)buffer(position++);\n+    }\n+    byte b1 = (byte)(buffer(position) << bit_pos);\n+    byte b2 = (byte)(buffer(++position) >> (8 - bit_pos));\n+    return (byte)(b1 | b2);\n+  }\n+\n+  public int readInt() {\n+    if (readZero()) {\n+      return 0;\n+    }\n+    byte b = readByteImpl();\n+    int result = b & 0x3f;\n+    for (int i = 0; (0 != ((i == 0) ? (b & 0x40) : (b & 0x80))); i++) {\n+      b = readByteImpl();\n+      result |= ((b & 0x7f) << (6 + 7 * i));\n+    }\n+    return result;\n+  }\n+\n+  boolean readZero() {\n+    if (0 != (buffer(position) & (1 << (7 - bit_pos)))) {\n+      return false; \/\/ not a zero data\n+    }\n+    if (++bit_pos == 8) {\n+      position++;\n+      bit_pos = 0;\n+    }\n+    return true;\n+  }\n+\n+  public boolean readBoolean() { return readInt() != 0; }\n+  public byte    readByte()    { return (byte) readInt(); }\n+}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/code\/CompressedSparseDataReadStream.java","additions":75,"deletions":0,"binary":false,"changes":75,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,1 @@\n-public class DebugInfoReadStream extends CompressedReadStream {\n+public class DebugInfoReadStream extends CompressedSparseDataReadStream {\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/code\/DebugInfoReadStream.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,106 @@\n+\/*\n+ * Copyright (c) 2022, BELLSOFT. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"memory\/resourceArea.hpp\"\n+#include \"code\/debugInfo.hpp\"\n+#include \"unittest.hpp\"\n+\n+void check_int_encoding() {\n+  ResourceMark rm;\n+  DebugInfoWriteStream out(NULL, 100);\n+  u_char* buf = out.buffer();\n+\n+  out.set_position(0);\n+  out.write_int(0);\n+  out.write_int(0);\n+  out.write_int(0);\n+  out.write_int(0);\n+  out.write_int(0);\n+  out.write_int(0);\n+  out.write_int(0);\n+  out.write_int(0);\n+  ASSERT_TRUE(out.position() == 1 && buf[0] == 0);\n+\n+  out.set_position(0);\n+  out.write_int(1);\n+  ASSERT_TRUE(out.position() == 1 && buf[0] == 0x81);\n+\n+  out.set_position(0);\n+  out.write_int(0xff);\n+  ASSERT_TRUE(out.position() == 2 && buf[0] == 0xff && buf[1] == 0x3);\n+\n+  out.set_position(0);\n+  out.write_int(0xffff);\n+  ASSERT_TRUE(out.position() == 3 && buf[0] == 0xff && buf[1] == 0xff && buf[2] == 0x7);\n+\n+  out.set_position(0);\n+  out.write_int(0xffffffff);\n+  ASSERT_TRUE(out.position() == 5 && ((buf[0] & buf[1] & buf[2] & buf[3]) == 0xff) && buf[4] == 0x1f);\n+}\n+\n+void check_read_write() {\n+  ResourceMark rm;\n+  DebugInfoWriteStream out(NULL, 100);\n+\n+  for (int i = 0; i < 1000*1000; i++) {\n+    out.write_int(i);\n+    out.write_bool((bool)i);\n+    out.write_byte((jbyte)i);\n+    out.write_signed_int((jint)i);\n+    out.write_double((jdouble)i);\n+    out.write_long((jlong)i);\n+  }\n+  out.flush();\n+\n+  u_char* buf = out.buffer();\n+  CompressedSparseDataReadStream in(buf, 0);\n+\n+  for (int i = 0; i < 1000*1000; i++) {\n+    ASSERT_TRUE(in.read_int() == i);\n+    ASSERT_TRUE(in.read_bool() == (jboolean)(bool)i);\n+    ASSERT_TRUE(in.read_byte() == (jbyte)i);\n+    ASSERT_TRUE(in.read_signed_int() == (jint)i);\n+    ASSERT_TRUE(in.read_double() == (jdouble)i);\n+    ASSERT_TRUE(in.read_long() == (jlong)i);\n+  }\n+}\n+\n+void check_buffer_grow() {\n+  ResourceMark rm;\n+  DebugInfoWriteStream out(NULL, 100);\n+  out.set_position(99);\n+  out.write_int(0);\n+  out.flush();\n+  out.write_int(1);\n+  out.write_int(2);\n+  u_char* buf = out.buffer();\n+  ASSERT_TRUE(out.position() == 102 && buf[99] == 0 && buf[100] == 0x81 && buf[101] == 0x82);\n+}\n+\n+TEST_VM(DebugInfo, basic_test)\n+{\n+  check_int_encoding();\n+  check_read_write();\n+  check_buffer_grow();\n+}\n","filename":"test\/hotspot\/gtest\/code\/test_debugInfoCompression.cpp","additions":106,"deletions":0,"binary":false,"changes":106,"status":"added"},{"patch":"@@ -0,0 +1,107 @@\n+\/*\n+ * Copyright (c) 2022, BELLSOFT. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import sun.jvm.hotspot.code.*;\n+import sun.jvm.hotspot.debugger.*;\n+\n+\/**\n+ * @test\n+ * @library \/test\/lib\n+ * @requires vm.hasSA\n+ * @modules jdk.hotspot.agent\/sun.jvm.hotspot.debugger\n+ *          jdk.hotspot.agent\/sun.jvm.hotspot.code\n+ * @run main\/othervm -Xbootclasspath\/a:. TestCompressedSparseDataReadStream\n+ *\/\n+public class TestCompressedSparseDataReadStream {\n+\n+    public static void main(String[] args) throws Exception {\n+        byte data[] = { (byte)0x08, (byte)0x1f, (byte)0xf0, (byte)0x00 };\n+        CompressedSparseDataReadStream in = new CompressedSparseDataReadStream(new Addr(data), 0);\n+        assertEquals(in.readInt(), 0);  \/\/ zero bit -> 0\n+        assertEquals(in.readInt(), 0);  \/\/ zero bit -> 0\n+        assertEquals(in.readInt(), 0);  \/\/ zero bit -> 0\n+        assertEquals(in.readInt(), 0);  \/\/ zero bit -> 0\n+        assertEquals(in.readInt(), 1);  \/\/ 0x81     -> 1\n+        assertEquals(in.readInt(), 63); \/\/ 0xff00   -> 63\n+        assertEquals(in.readInt(), 0);  \/\/ zero bit -> 0\n+        assertEquals(in.readInt(), 0);  \/\/ zero bit -> 0\n+        assertEquals(in.readInt(), 0);  \/\/ zero bit -> 0\n+        assertEquals(in.readInt(), 0);  \/\/ zero bit -> 0\n+        in.setPosition(2);\n+        assertEquals(in.readInt(), 48); \/\/ 0xf000   -> 48\n+    }\n+    private static void assertEquals(int a, int b) {\n+        if (a != b) throw new RuntimeException(\"assert failed: \" + a + \" != \" + b);\n+    }\n+}\n+\n+class DummyAddr implements sun.jvm.hotspot.debugger.Address {\n+    public boolean    equals(Object arg)                { return false; }\n+    public int        hashCode()                        { return 0; }\n+    public long       getCIntegerAt      (long offset, long numBytes, boolean isUnsigned) { return 0; }\n+    public Address    getAddressAt       (long offset)  { return null; }\n+    public Address    getCompOopAddressAt (long offset) { return null; }\n+    public Address    getCompKlassAddressAt (long offset) { return null; }\n+    public boolean    getJBooleanAt      (long offset)  { return false; }\n+    public byte       getJByteAt         (long offset)  { return 0; }\n+    public char       getJCharAt         (long offset)  { return 0; }\n+    public double     getJDoubleAt       (long offset)  { return 0; }\n+    public float      getJFloatAt        (long offset)  { return 0; }\n+    public int        getJIntAt          (long offset)  { return 0; }\n+    public long       getJLongAt         (long offset)  { return 0; }\n+    public short      getJShortAt        (long offset)  { return 0; }\n+    public OopHandle  getOopHandleAt     (long offset)  { return null; }\n+    public OopHandle  getCompOopHandleAt (long offset)  { return null; }\n+    public void       setCIntegerAt      (long offset, long numBytes, long value) {}\n+    public void       setAddressAt       (long offset, Address value) {}\n+    public void       setJBooleanAt      (long offset, boolean value) {}\n+    public void       setJByteAt         (long offset, byte value)    {}\n+    public void       setJCharAt         (long offset, char value)    {}\n+    public void       setJDoubleAt       (long offset, double value)  {}\n+    public void       setJFloatAt        (long offset, float value)   {}\n+    public void       setJIntAt          (long offset, int value)     {}\n+    public void       setJLongAt         (long offset, long value)    {}\n+    public void       setJShortAt        (long offset, short value)   {}\n+    public void       setOopHandleAt     (long offset, OopHandle value) {}\n+    public Address    addOffsetTo        (long offset)  { return null; }\n+    public OopHandle  addOffsetToAsOopHandle(long offset)  { return null; }\n+    public long       minus              (Address arg)  { return 0; }\n+    public boolean    lessThan           (Address arg)  { return false; }\n+    public boolean    lessThanOrEqual    (Address arg)  { return false; }\n+    public boolean    greaterThan        (Address arg)  { return false; }\n+    public boolean    greaterThanOrEqual (Address arg)  { return false; }\n+    public Address    andWithMask        (long mask)    { return null; }\n+    public Address    orWithMask         (long mask)    { return null; }\n+    public Address    xorWithMask        (long mask)    { return null; }\n+    public long       asLongValue        ()             { return 0; }\n+}\n+\n+class Addr extends DummyAddr {\n+    byte data[];\n+    public Addr(byte data[]) {\n+        this.data = data;\n+    }\n+    public long getCIntegerAt(long offset, long numBytes, boolean isUnsigned) {\n+        return data[(int)offset];\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/sa\/TestCompressedSparseDataReadStream.java","additions":107,"deletions":0,"binary":false,"changes":107,"status":"added"}]}