{"files":[{"patch":"@@ -758,0 +758,8 @@\n+        Symbol baseMethod = refSym.baseSymbol();\n+        Symbol origMethod = baseMethod.baseSymbol();\n+        if (baseMethod != origMethod && origMethod.owner == syms.objectType.tsym) {\n+            \/\/the implementation method is a java.lang.Object method transferred to an\n+            \/\/interface that does not declare it. Runtime will refer to this method as to\n+            \/\/a java.lang.Object method, so do the same:\n+            refSym = ((MethodSymbol) origMethod).asHandle();\n+        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/LambdaToMethod.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,72 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8282080\n+ * @summary Check that serializable lambdas referring to j.l.Object methods work.\n+ * @compile SerializableObjectMethods.java\n+ * @run main SerializableObjectMethods\n+ *\/\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+\n+public class SerializableObjectMethods {\n+\n+    interface I1 extends Serializable {}\n+\n+    interface I2 extends I1 {\n+\n+        @Override\n+        public int hashCode();\n+\n+    }\n+\n+    interface F<T, R> extends Serializable {\n+\n+        R apply(T t);\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        new SerializableObjectMethods().run();\n+    }\n+\n+    void run() throws IOException, ClassNotFoundException {\n+        saveLoad((F<I1, Integer>) I1::hashCode).apply(new I1() {});\n+        saveLoad((F<I2, Integer>) I2::hashCode).apply(new I2() {});\n+    }\n+\n+    <T, R> F<T, R> saveLoad(F<T, R> value) throws IOException, ClassNotFoundException {\n+        ByteArrayOutputStream out = new ByteArrayOutputStream();\n+        try ( ObjectOutputStream oos = new ObjectOutputStream(out)) {\n+            oos.writeObject(value);\n+        }\n+        try (ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(out.toByteArray()))) {\n+            return (F<T, R>) ois.readObject();\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/lambda\/SerializableObjectMethods.java","additions":72,"deletions":0,"binary":false,"changes":72,"status":"added"}]}