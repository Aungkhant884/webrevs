{"files":[{"patch":"@@ -454,18 +454,3 @@\n-#if defined(AIX)\n-\n-\/\/ Set thread signal mask (for some reason on AIX sigthreadmask() seems\n-\/\/ to be the thing to call; documentation is not terribly clear about whether\n-\/\/ pthread_sigmask also works, and if it does, whether it does the same.\n-bool set_thread_signal_mask(int how, const sigset_t* set, sigset_t* oset) {\n-  const int rc = ::pthread_sigmask(how, set, oset);\n-  \/\/ return value semantics differ slightly for error case:\n-  \/\/ pthread_sigmask returns error number, sigthreadmask -1 and sets global errno\n-  \/\/ (so, pthread_sigmask is more theadsafe for error handling)\n-  \/\/ But success is always 0.\n-  return rc == 0 ? true : false;\n-}\n-\n-\/\/ Function to unblock all signals which are, according\n-\/\/ to POSIX, typical program error signals. If they happen while being blocked,\n-\/\/ they typically will bring down the process immediately.\n-bool unblock_program_error_signals() {\n+\/\/ Unblock all signals whose delivery cannot be deferred and which, if they happen\n+\/\/  while delivery is blocked, would cause crashes or hangs (JDK-8252533).\n+void PosixSignals::unblock_error_signals() {\n@@ -478,3 +463,10 @@\n-  return set_thread_signal_mask(SIG_UNBLOCK, &set, NULL);\n-}\n-\n+  \/\/ We also unblock SIGTRAP, which is not in the list of POSIX lists of signals\n+  \/\/  which would cause undefined behavior when blocked\n+  \/\/  (https:\/\/pubs.opengroup.org\/onlinepubs\/009695399\/functions\/sigprocmask.html)\n+  \/\/  but in our experience cause the same problems when occurring when blocked.\n+  sigaddset(&set, SIGTRAP);\n+  int rc = ::pthread_sigmask(SIG_UNBLOCK, &set, NULL);\n+#ifdef ASSERT\n+  if (rc != 0) {\n+    log_warning(os)(\"pthread_sigmask failed (%d)\", errno);\n+  }\n@@ -482,0 +474,1 @@\n+}\n@@ -487,7 +480,1 @@\n-\/\/ TODO: reconcile the differences between Linux\/BSD vs AIX here!\n-#if defined(AIX)\n-  \/\/ Never leave program error signals blocked;\n-  \/\/ on all our platforms they would bring down the process immediately when\n-  \/\/ getting raised while being blocked.\n-  unblock_program_error_signals();\n-#endif\n+  PosixSignals::unblock_error_signals();\n@@ -705,18 +692,0 @@\n-\n-#if defined(AIX)\n-  \/\/ Do not block out synchronous signals in the signal handler.\n-  \/\/ Blocking synchronous signals only makes sense if you can really\n-  \/\/ be sure that those signals won't happen during signal handling,\n-  \/\/ when the blocking applies. Normal signal handlers are lean and\n-  \/\/ do not cause signals. But our signal handlers tend to be \"risky\"\n-  \/\/ - secondary SIGSEGV, SIGILL, SIGBUS' may and do happen.\n-  \/\/ On AIX, PASE there was a case where a SIGSEGV happened, followed\n-  \/\/ by a SIGILL, which was blocked due to the signal mask. The process\n-  \/\/ just hung forever. Better to crash from a secondary signal than to hang.\n-  sigdelset(&(sigAct.sa_mask), SIGSEGV);\n-  sigdelset(&(sigAct.sa_mask), SIGBUS);\n-  sigdelset(&(sigAct.sa_mask), SIGILL);\n-  sigdelset(&(sigAct.sa_mask), SIGFPE);\n-  sigdelset(&(sigAct.sa_mask), SIGTRAP);\n-#endif\n-\n@@ -1306,4 +1275,0 @@\n-int PosixSignals::unblock_thread_signal_mask(const sigset_t *set) {\n-  return pthread_sigmask(SIG_UNBLOCK, set, NULL);\n-}\n-\n","filename":"src\/hotspot\/os\/posix\/signals_posix.cpp","additions":15,"deletions":50,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -47,2 +47,0 @@\n-  \/\/ unblocks the signal masks for current thread\n-  static int unblock_thread_signal_mask(const sigset_t *set);\n@@ -67,0 +65,5 @@\n+\n+  \/\/ Unblock all signals whose delivery cannot be deferred and which, if they happen\n+  \/\/  while delivery is blocked, would cause crashes or hangs (see JDK-8252533).\n+  static void unblock_error_signals();\n+\n","filename":"src\/hotspot\/os\/posix\/signals_posix.hpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -104,9 +104,2 @@\n-  \/\/ unmask current signal\n-  sigset_t newset;\n-  sigemptyset(&newset);\n-  sigaddset(&newset, sig);\n-  \/\/ also unmask other synchronous signals\n-  for (int i = 0; i < NUM_SIGNALS; i++) {\n-    sigaddset(&newset, SIGNALS[i]);\n-  }\n-  PosixSignals::unblock_thread_signal_mask(&newset);\n+\n+  PosixSignals::unblock_error_signals();\n@@ -151,1 +144,0 @@\n-  PosixSignals::unblock_thread_signal_mask(&newset);\n","filename":"src\/hotspot\/os\/posix\/vmError_posix.cpp","additions":2,"deletions":10,"binary":false,"changes":12,"status":"modified"}]}