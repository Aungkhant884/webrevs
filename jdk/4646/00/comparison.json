{"files":[{"patch":"@@ -193,0 +193,3 @@\n+  if (_shared_rs.is_reserved()) {\n+    _shared_rs.release();\n+  }\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -74,0 +74,5 @@\n+\n+  static void reset_map_and_vs() {\n+    _ptrmap = nullptr;\n+    _vs = nullptr;\n+  }\n","filename":"src\/hotspot\/share\/cds\/archiveUtils.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -33,0 +33,34 @@\n+DumpTimeClassInfo DumpTimeClassInfo::clone() {\n+  DumpTimeClassInfo clone;\n+  clone._klass = _klass;\n+  clone._nest_host = _nest_host;\n+  clone._failed_verification = _failed_verification;\n+  clone._is_archived_lambda_proxy = _is_archived_lambda_proxy;\n+  clone._has_checked_exclusion = _has_checked_exclusion;\n+  clone._id = _id;\n+  clone._clsfile_size = _clsfile_size;\n+  clone._clsfile_crc32 = _clsfile_crc32;\n+  clone._excluded = _excluded;\n+  clone._is_early_klass = _is_early_klass;\n+  clone._verifier_constraints = NULL;\n+  clone._verifier_constraint_flags = NULL;\n+  clone._loader_constraints = NULL;\n+  int clone_num_verifier_constraints = num_verifier_constraints();\n+  if (clone_num_verifier_constraints > 0) {\n+    clone._verifier_constraints = new (ResourceObj::C_HEAP, mtClass) GrowableArray<DTVerifierConstraint>(clone_num_verifier_constraints, mtClass);\n+    clone._verifier_constraint_flags = new (ResourceObj::C_HEAP, mtClass) GrowableArray<char>(clone_num_verifier_constraints, mtClass);\n+    for (int i = 0; i < clone_num_verifier_constraints; i++) {\n+      clone._verifier_constraints->append(_verifier_constraints->at(i));\n+      clone._verifier_constraint_flags->append(_verifier_constraint_flags->at(i));\n+    }\n+  }\n+  int clone_num_loader_constraints = num_loader_constraints();\n+  if (clone_num_loader_constraints > 0) {\n+    clone._loader_constraints = new (ResourceObj::C_HEAP, mtClass) GrowableArray<DTLoaderConstraint>(clone_num_loader_constraints, mtClass);\n+    for (int i = 0; i < clone_num_loader_constraints; i++) {\n+      clone._loader_constraints->append(_loader_constraints->at(i));\n+    }\n+  }\n+  return clone;\n+}\n+\n@@ -36,1 +70,1 @@\n-    _verifier_constraints = new(ResourceObj::C_HEAP, mtClass) GrowableArray<DTVerifierConstraint>(4, mtClass);\n+    _verifier_constraints = new (ResourceObj::C_HEAP, mtClass) GrowableArray<DTVerifierConstraint>(4, mtClass);\n@@ -39,1 +73,1 @@\n-    _verifier_constraint_flags = new(ResourceObj::C_HEAP, mtClass) GrowableArray<char>(4, mtClass);\n+    _verifier_constraint_flags = new (ResourceObj::C_HEAP, mtClass) GrowableArray<char>(4, mtClass);\n","filename":"src\/hotspot\/share\/cds\/dumpTimeClassInfo.cpp","additions":36,"deletions":2,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -155,0 +155,1 @@\n+  DumpTimeClassInfo clone();\n@@ -181,0 +182,7 @@\n+  \/\/ GCC will memset for default ctor. With user defined ctor, data members need manually initialized.\n+  \/\/ We could not use default ctor, it will destroy allocation_type in debug version and fail to delete.\n+  \/\/ see bug 8269537\n+  DumpTimeSharedClassTable() {\n+    _builtin_count = 0;\n+    _unregistered_count = 0;\n+  }\n","filename":"src\/hotspot\/share\/cds\/dumpTimeClassInfo.hpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -86,0 +86,1 @@\n+  void post_dump();\n@@ -115,0 +116,3 @@\n+    \/\/ save dumptime tables\n+    SystemDictionaryShared::clone_dumptime_tables();\n+\n@@ -161,0 +165,5 @@\n+    post_dump();\n+\n+    \/\/ Restore dumptime talbes\n+    SystemDictionaryShared::restore_dumptime_tables();\n+\n@@ -197,0 +206,4 @@\n+void DynamicArchiveBuilder::post_dump() {\n+  ArchivePtrMarker::reset_map_and_vs();\n+}\n+\n@@ -350,2 +363,0 @@\n-bool DynamicArchive::_has_been_dumped_once = false;\n-\n@@ -355,5 +366,3 @@\n-  \/\/ During dynamic archive dumping, some of the data structures are overwritten so\n-  \/\/ we cannot dump the dynamic archive again. TODO: this should be fixed.\n-  if (has_been_dumped_once()) {\n-    THROW_MSG(vmSymbols::java_lang_RuntimeException(),\n-        \"Dynamic dump has been done, and should only be done once\");\n+  ArchiveClassesAtExit = archive_name;\n+  if (Arguments::init_shared_archive_paths()) {\n+    dump(CHECK);\n@@ -361,11 +370,0 @@\n-    \/\/ prevent multiple dumps.\n-    set_has_been_dumped_once();\n-    ArchiveClassesAtExit = archive_name;\n-    if (Arguments::init_shared_archive_paths()) {\n-      dump();\n-    } else {\n-      ArchiveClassesAtExit = nullptr;\n-      THROW_MSG(vmSymbols::java_lang_RuntimeException(),\n-              \"Could not setup SharedDynamicArchivePath\");\n-    }\n-    \/\/ prevent do dynamic dump at exit.\n@@ -373,4 +371,8 @@\n-    if (!Arguments::init_shared_archive_paths()) {\n-      THROW_MSG(vmSymbols::java_lang_RuntimeException(),\n-             \"Could not restore SharedDynamicArchivePath\");\n-    }\n+    THROW_MSG(vmSymbols::java_lang_RuntimeException(),\n+              \"Could not setup SharedDynamicArchivePath\");\n+  }\n+  \/\/ prevent do dynamic dump at exit.\n+  ArchiveClassesAtExit = nullptr;\n+  if (!Arguments::init_shared_archive_paths()) {\n+    THROW_MSG(vmSymbols::java_lang_RuntimeException(),\n+              \"Could not restore SharedDynamicArchivePath\");\n@@ -380,1 +382,1 @@\n-void DynamicArchive::dump() {\n+void DynamicArchive::dump(TRAPS) {\n@@ -386,0 +388,3 @@\n+  \/\/ copy shared path table to saved.\n+  FileMapInfo::clone_shared_path_table(CHECK);\n+\n","filename":"src\/hotspot\/share\/cds\/dynamicArchive.cpp","additions":28,"deletions":23,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -61,1 +61,0 @@\n-  static bool _has_been_dumped_once;\n@@ -65,3 +64,1 @@\n-  static void dump();\n-  static bool has_been_dumped_once() { return _has_been_dumped_once; }\n-  static void set_has_been_dumped_once() { _has_been_dumped_once = true; }\n+  static void dump(TRAPS);\n","filename":"src\/hotspot\/share\/cds\/dynamicArchive.hpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -483,0 +483,19 @@\n+void FileMapInfo::clone_shared_path_table(TRAPS) {\n+  Arguments::assert_is_dumping_archive();\n+\n+  ClassLoaderData* loader_data = ClassLoaderData::the_null_class_loader_data();\n+  ClassPathEntry* jrt = ClassLoader::get_jrt_entry();\n+\n+  assert(jrt != NULL,\n+         \"No modular java runtime image present when allocating the CDS classpath entry table\");\n+\n+  \/\/ After dynamic dump, _saved_shared_path_table is corrupt, can not be used again.\n+  \/\/ could not free the corrupt table. May have memory leak but it should be OK since\n+  \/\/ it is not a big leak. This will fail:\n+  \/\/ if (_saved_shared_path_table.size() > 0) {\n+  \/\/   MetadataFactory::free_array<u8>(loader_data, _saved_shared_path_table->_table);\n+  \/\/ }\n+\n+  copy_shared_path_table(loader_data, CHECK);\n+}\n+\n@@ -506,2 +525,1 @@\n-\n-  copy_shared_path_table(loader_data, CHECK);\n+  clone_shared_path_table(CHECK);\n","filename":"src\/hotspot\/share\/cds\/filemap.cpp","additions":20,"deletions":2,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -371,0 +371,1 @@\n+    assert(_saved_shared_path_table.size() >= 0, \"Sanity check\");\n@@ -500,0 +501,1 @@\n+  static void clone_shared_path_table(TRAPS);\n","filename":"src\/hotspot\/share\/cds\/filemap.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,0 +30,13 @@\n+DumpTimeLambdaProxyClassInfo DumpTimeLambdaProxyClassInfo::clone() {\n+  DumpTimeLambdaProxyClassInfo res;\n+  res._proxy_klasses = NULL;\n+  if (_proxy_klasses != NULL && _proxy_klasses->length() > 0) {\n+    int num_proxy_klasses = _proxy_klasses->length();\n+    res._proxy_klasses = new (ResourceObj::C_HEAP, mtClassShared) GrowableArray<InstanceKlass*>(num_proxy_klasses, mtClassShared);\n+    for (int i = 0; i < num_proxy_klasses; i++) {\n+      res._proxy_klasses->append(_proxy_klasses->at(i));\n+    }\n+  }\n+  return res;\n+}\n+\n","filename":"src\/hotspot\/share\/cds\/lambdaProxyClassDictionary.cpp","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -113,1 +113,1 @@\n-      _proxy_klasses = new (ResourceObj::C_HEAP, mtClassShared)GrowableArray<InstanceKlass*>(5, mtClassShared);\n+      _proxy_klasses = new (ResourceObj::C_HEAP, mtClassShared) GrowableArray<InstanceKlass*>(5, mtClassShared);\n@@ -124,0 +124,1 @@\n+  DumpTimeLambdaProxyClassInfo clone(); \/\/ copy ctor will cause implicitly-declared\n@@ -163,0 +164,4 @@\n+  \/\/ GCC will memset for default ctor. With user defined ctor, data members need manually initialized.\n+  \/\/ We could not use default ctor, it will destroy allocation_type in debug version and fail to delete.\n+  \/\/ see bug 8269537\n+  DumpTimeLambdaProxyClassDictionary() : _count(0)  {}\n","filename":"src\/hotspot\/share\/cds\/lambdaProxyClassDictionary.hpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"cds\/dumpTimeClassInfo.hpp\"\n@@ -34,0 +35,1 @@\n+#include \"cds\/runTimeClassInfo.hpp\"\n@@ -74,0 +76,1 @@\n+DumpTimeSharedClassTable* SystemDictionaryShared::_cloned_dumptime_table = NULL;\n@@ -75,0 +78,1 @@\n+DumpTimeLambdaProxyClassDictionary* SystemDictionaryShared::_cloned_dumptime_lambda_proxy_class_dictionary = NULL;\n@@ -193,1 +197,1 @@\n-    _dumptime_table = new (ResourceObj::C_HEAP, mtClass)DumpTimeSharedClassTable();\n+    _dumptime_table = new (ResourceObj::C_HEAP, mtClass) DumpTimeSharedClassTable;\n@@ -795,1 +799,1 @@\n-      new (ResourceObj::C_HEAP, mtClass)DumpTimeLambdaProxyClassDictionary();\n+      new (ResourceObj::C_HEAP, mtClass) DumpTimeLambdaProxyClassDictionary;\n@@ -1540,0 +1544,70 @@\n+class CloneDumpTimeClassTable: public StackObj {\n+  DumpTimeSharedClassTable* _table;\n+  DumpTimeSharedClassTable* _cloned_table;\n+ public:\n+  CloneDumpTimeClassTable(DumpTimeSharedClassTable* table, DumpTimeSharedClassTable* clone) :\n+                      _table(table), _cloned_table(clone) {\n+    assert(_table != NULL, \"_dumptime_table is NULL\");\n+    assert(_cloned_table != NULL, \"_cloned_table is NULL\");\n+  }\n+  bool do_entry(InstanceKlass* k, DumpTimeClassInfo& info) {\n+    if (!info.is_excluded()) {\n+      bool created;\n+      _cloned_table->put_if_absent(k, info.clone(), &created);\n+    }\n+    return true; \/\/ keep on iterating\n+  }\n+};\n+\n+class CloneDumpTimeLambdaProxyClassTable: StackObj {\n+  DumpTimeLambdaProxyClassDictionary* _table;\n+  DumpTimeLambdaProxyClassDictionary* _cloned_table;\n+ public:\n+  CloneDumpTimeLambdaProxyClassTable(DumpTimeLambdaProxyClassDictionary* table,\n+                                     DumpTimeLambdaProxyClassDictionary* clone) :\n+                      _table(table), _cloned_table(clone) {\n+    assert(_table != NULL, \"_dumptime_table is NULL\");\n+    assert(_cloned_table != NULL, \"_cloned_table is NULL\");\n+  }\n+\n+  bool do_entry(LambdaProxyClassKey& key, DumpTimeLambdaProxyClassInfo& info) {\n+    assert_lock_strong(DumpTimeTable_lock);\n+    bool created;\n+    \/\/ make copies then store in _clone_table\n+    LambdaProxyClassKey keyCopy = key;\n+    _cloned_table->put_if_absent(keyCopy, info.clone(), &created);\n+    ++ _cloned_table->_count;\n+    return true; \/\/ keep on iterating\n+  }\n+};\n+\n+void SystemDictionaryShared::clone_dumptime_tables() {\n+  Arguments::assert_is_dumping_archive();\n+  if (_dumptime_table != NULL) {\n+    assert(_cloned_dumptime_table == NULL, \"_cloned_dumptime_table must be cleaned\");\n+    _cloned_dumptime_table = new (ResourceObj::C_HEAP, mtClass) DumpTimeSharedClassTable;\n+    CloneDumpTimeClassTable copy_classes(_dumptime_table, _cloned_dumptime_table);\n+    _dumptime_table->iterate(&copy_classes);\n+    _cloned_dumptime_table->update_counts();\n+  }\n+  if (_dumptime_lambda_proxy_class_dictionary != NULL) {\n+    assert(_cloned_dumptime_lambda_proxy_class_dictionary == NULL,\n+           \"_cloned_dumptime_lambda_proxy_class_dictionary must be cleaned\");\n+    _cloned_dumptime_lambda_proxy_class_dictionary =\n+                                          new (ResourceObj::C_HEAP, mtClass) DumpTimeLambdaProxyClassDictionary;\n+    CloneDumpTimeLambdaProxyClassTable copy_proxy_classes(_dumptime_lambda_proxy_class_dictionary,\n+                                                          _cloned_dumptime_lambda_proxy_class_dictionary);\n+    _dumptime_lambda_proxy_class_dictionary->iterate(&copy_proxy_classes);\n+  }\n+}\n+\n+void SystemDictionaryShared::restore_dumptime_tables() {\n+  \/\/ FileMapInfo::clean_cloned_shared_path_table();\n+  delete _dumptime_table;\n+  _dumptime_table = _cloned_dumptime_table;\n+  _cloned_dumptime_table = NULL;\n+  delete _dumptime_lambda_proxy_class_dictionary;\n+  _dumptime_lambda_proxy_class_dictionary = _cloned_dumptime_lambda_proxy_class_dictionary;\n+  _cloned_dumptime_lambda_proxy_class_dictionary = NULL;\n+}\n+\n","filename":"src\/hotspot\/share\/classfile\/systemDictionaryShared.cpp","additions":76,"deletions":2,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -149,0 +149,1 @@\n+  static DumpTimeSharedClassTable* _cloned_dumptime_table;\n@@ -150,0 +151,1 @@\n+  static DumpTimeLambdaProxyClassDictionary* _cloned_dumptime_lambda_proxy_class_dictionary;\n@@ -270,0 +272,10 @@\n+\n+  \/\/ For repeatable dumping, we\n+  \/\/   1. clone DumpTimeSharedClassTable, same for DumpTimeLambdaProxyClassDictionary\n+  \/\/      clone SharedClassPathTable\n+  \/\/   2. do dumping\n+  \/\/   3. restore DumpTimeSharedClassTable, DumpTimeLambdaProxyClassDictionary and SharedClassPathTable\n+  \/\/      from cloned versions.\n+  static void clone_dumptime_tables();\n+  static void restore_dumptime_tables();\n+\n","filename":"src\/hotspot\/share\/classfile\/systemDictionaryShared.hpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -505,1 +505,1 @@\n-    DynamicArchive::dump();\n+    DynamicArchive::dump(thread);\n","filename":"src\/hotspot\/share\/runtime\/java.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -66,1 +66,1 @@\n-        test(\"02.jsa\", pid, noBoot,  EXPECT_FAIL);\n+        test(\"02.jsa\", pid, noBoot,  EXPECT_PASS);\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/jcmd\/JCmdTestDynamicDump.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}