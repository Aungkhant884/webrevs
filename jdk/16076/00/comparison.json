{"files":[{"patch":"@@ -36,0 +36,1 @@\n+#include \"compiler\/compilationMemoryStatistic.hpp\"\n@@ -445,0 +446,2 @@\n+  CompilationMemoryStatisticMark cmsm;\n+\n","filename":"src\/hotspot\/share\/c1\/c1_Compilation.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -222,1 +222,1 @@\n-    _arena = new (mtSymbol) Arena(mtSymbol, symbol_alloc_arena_size);\n+    _arena = new (mtSymbol) Arena(mtSymbol, Arena::Tag::tag_other, symbol_alloc_arena_size);\n","filename":"src\/hotspot\/share\/classfile\/symbolTable.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,422 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, Red Hat, Inc. and\/or its affiliates.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"logging\/log.hpp\"\n+#include \"logging\/logStream.hpp\"\n+#include \"compiler\/abstractCompiler.hpp\"\n+#include \"compiler\/compiler_globals.hpp\"\n+#include \"compiler\/compilationMemoryStatistic.hpp\"\n+#include \"compiler\/compileTask.hpp\"\n+#include \"compiler\/compilerDefinitions.hpp\"\n+#include \"compiler\/compilerThread.hpp\"\n+#include \"memory\/arena.hpp\"\n+#include \"memory\/resourceArea.hpp\"\n+#include \"oops\/symbol.hpp\"\n+#ifdef COMPILER2\n+#include \"opto\/node.hpp\" \/\/ compile.hpp is not self-contained\n+#include \"opto\/compile.hpp\"\n+#endif\n+#include \"services\/nmtCommon.hpp\"\n+#include \"runtime\/mutexLocker.hpp\"\n+#include \"runtime\/os.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/ostream.hpp\"\n+#include \"utilities\/quickSort.hpp\"\n+#include \"utilities\/resourceHash.hpp\"\n+\n+\n+ArenaStatCounter::ArenaStatCounter() :\n+  _current(0), _start(0), _peak(0),\n+  _na(0), _ra(0),\n+  _na_at_peak(0), _ra_at_peak(0), _live_nodes_at_peak(0)\n+{}\n+\n+size_t ArenaStatCounter::peak_since_start() const {\n+  return _peak > _start ? _peak - _start : 0;\n+}\n+\n+void ArenaStatCounter::start() {\n+  _peak = _start = _current;\n+}\n+\n+void ArenaStatCounter::update_c2_node_count() {\n+#ifdef COMPILER2\n+  CompilerThread* const th = Thread::current()->as_Compiler_thread();\n+  const CompileTask* const task = th->task();\n+  if (task != nullptr &&\n+      th->task()->compiler() != nullptr &&\n+      th->task()->compiler()->type() == compiler_c2) {\n+    const Compile* const comp = Compile::current();\n+    if (comp != nullptr) {\n+      _live_nodes_at_peak = comp->live_nodes();\n+    }\n+  }\n+#endif\n+}\n+\n+\/\/ Account an arena allocation or de-allocation.\n+bool ArenaStatCounter::account(ssize_t delta, int tag) {\n+  bool rc = false;\n+#ifdef ASSERT\n+  assert(delta >= 0 || ((ssize_t)_current + delta) >= 0,\n+         \"Negative overflow (d=%zd %zu %zu %zu)\", delta, _current, _start, _peak);\n+#endif\n+  \/\/ Update totals\n+  _current += delta;\n+  \/\/ Update detail counter\n+  switch ((Arena::Tag)tag) {\n+    case Arena::Tag::tag_ra: _ra += delta; break;\n+    case Arena::Tag::tag_node: _na += delta; break;\n+    default: \/\/ ignore\n+      break;\n+  };\n+  \/\/ Did we reach a peak?\n+  if (_current > _peak) {\n+    _peak = _current;\n+    assert(delta > 0, \"Sanity (%zu %zu %zu)\", _current, _start, _peak);\n+    _na_at_peak = _na;\n+    _ra_at_peak = _ra;\n+    update_c2_node_count();\n+    rc = true;\n+  }\n+  return rc;\n+}\n+\n+void ArenaStatCounter::print_on(outputStream* st) const {\n+  st->print(\"%zu [na %zu ra %zu]\", peak_since_start(), _na_at_peak, _ra_at_peak);\n+#ifdef ASSERT\n+  st->print(\" (%zu->%zu->%zu)\", _start, _peak, _current);\n+#endif\n+}\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\/\/ Backend\n+\n+class FullMethodName {\n+  Symbol* const _k;\n+  Symbol* const _m;\n+  Symbol* const _s;\n+\n+public:\n+\n+  FullMethodName(Symbol* k, Symbol* m, Symbol* s) : _k(k), _m(m), _s(s) {}\n+  FullMethodName(const FullMethodName& o) : _k(o._k), _m(o._m), _s(o._s) {}\n+\n+  void make_permanent() {\n+    _k->make_permanent();\n+    _m->make_permanent();\n+    _s->make_permanent();\n+  }\n+\n+  static unsigned compute_hash(const FullMethodName& n) {\n+    return Symbol::compute_hash(n._k) ^\n+        Symbol::compute_hash(n._m) ^\n+        Symbol::compute_hash(n._s);\n+  }\n+\n+  char* as_C_string(char* buf, size_t len) const {\n+    stringStream ss(buf, len);\n+    ResourceMark rm;\n+    ss.print_raw(_k->as_C_string());\n+    ss.put('.');\n+    ss.print_raw(_m->as_C_string());\n+    ss.put('(');\n+    ss.print_raw(_s->as_C_string());\n+    ss.put(')');\n+    return buf;\n+  }\n+\n+  bool equals(const FullMethodName& b) const {\n+    return _k == b._k && _m == b._m && _s == b._s;\n+  }\n+\n+  bool operator== (const FullMethodName& other) const { return equals(other); }\n+};\n+\n+\/\/ Note: not mtCompiler since we don't want to change what we measure\n+class MemStatEntry : public CHeapObj<mtInternal> {\n+  const FullMethodName _method;\n+  CompilerType _comptype;\n+  double _time;\n+  \/\/ How often this has been recompiled.\n+  int _num_recomp;\n+  \/\/ Compiling thread. Only for diagnostic purposes. Thread may not be alive anymore.\n+  const Thread* _thread;\n+\n+  size_t _total;\n+  size_t _na_at_peak;\n+  size_t _ra_at_peak;\n+  unsigned _live_nodes_at_peak;\n+\n+public:\n+\n+  MemStatEntry(FullMethodName method)\n+    : _method(method), _comptype(compiler_c1),\n+      _time(0), _num_recomp(0), _thread(nullptr),\n+      _total(0), _na_at_peak(0), _ra_at_peak(0), _live_nodes_at_peak(0) {\n+  }\n+\n+  void set_comptype(CompilerType comptype) { _comptype = comptype; }\n+  void set_current_time() { _time = os::elapsedTime(); }\n+  void set_current_thread() { _thread = Thread::current(); }\n+  void inc_recompilation() { _num_recomp++; }\n+\n+  void set_total(size_t n) { _total = n; }\n+  void set_na_at_peak(size_t n) { _na_at_peak = n; }\n+  void set_ra_at_peak(size_t n) { _ra_at_peak = n; }\n+  void set_live_nodes_at_peak(unsigned n) { _live_nodes_at_peak = n; }\n+\n+  size_t total() const { return _total; }\n+\n+  static void print_legend(outputStream* st) {\n+    st->print_cr(\"Legend:\");\n+    st->print_cr(\"  total  : memory allocated via arenas while compiling\");\n+    st->print_cr(\"  NA     : ...how much in node arenas (if c2)\");\n+    st->print_cr(\"  RA     : ...how much in resource areas\");\n+    st->print_cr(\"  #nodes : ...how many nodes (if c2)\");\n+    st->print_cr(\"  time   : time of last compilation (sec)\");\n+    st->print_cr(\"  type   : compiler type\");\n+    st->print_cr(\"  #rc    : how often recompiled\");\n+    st->print_cr(\"  thread : compiler thread\");\n+  }\n+\n+  static void print_header(outputStream* st) {\n+    st->print_cr(\"total     NA        RA        #nodes  time    type  #rc thread              method\");\n+  }\n+\n+  void print_on(outputStream* st, bool human_readable) const {\n+    int col = 0;\n+\n+    \/\/ Total\n+    if (human_readable) {\n+      st->print(PROPERFMT \" \", PROPERFMTARGS(_total));\n+    } else {\n+      st->print(\"%zu \", _total);\n+    }\n+    col += 10; st->fill_to(col);\n+\n+    \/\/ NA\n+    if (human_readable) {\n+      st->print(PROPERFMT \" \", PROPERFMTARGS(_na_at_peak));\n+    } else {\n+      st->print(\"%zu \", _na_at_peak);\n+    }\n+    col += 10; st->fill_to(col);\n+\n+    \/\/ RA\n+    if (human_readable) {\n+      st->print(PROPERFMT \" \", PROPERFMTARGS(_ra_at_peak));\n+    } else {\n+      st->print(\"%zu \", _ra_at_peak);\n+    }\n+    col += 10; st->fill_to(col);\n+\n+    \/\/ Number of Nodes when memory peaked\n+    st->print(\"%u \", _live_nodes_at_peak);\n+    col += 8; st->fill_to(col);\n+\n+    \/\/ TimeStamp\n+    st->print(\"%.3f \", _time);\n+    col += 8; st->fill_to(col);\n+\n+    \/\/ Type\n+    st->print(\"%s \", compilertype2name(_comptype));\n+    col += 6; st->fill_to(col);\n+\n+    \/\/ Recomp\n+    st->print(\"%u \", _num_recomp);\n+    col += 4; st->fill_to(col);\n+\n+    \/\/ Thread\n+    st->print(PTR_FORMAT \"  \", p2i(_thread));\n+\n+    \/\/ MethodName\n+    char buf[1024];\n+    st->print(\"%s \", _method.as_C_string(buf, sizeof(buf)));\n+    st->cr();\n+  }\n+\n+  int compare_by_size(const MemStatEntry* b) const {\n+    const size_t x1 = b->_total;\n+    const size_t x2 = _total;\n+    return x1 < x2 ? -1 : x1 == x2 ? 0 : 1;\n+  }\n+\n+  bool equals(const FullMethodName& b) const {\n+    return _method.equals(b);\n+  }\n+};\n+\n+class MemStatTable :\n+    public ResourceHashtable<FullMethodName, MemStatEntry*, 7919, AnyObj::C_HEAP,\n+                             mtInternal, FullMethodName::compute_hash>\n+{\n+public:\n+\n+  void add(Method* m, CompilerType comptype,\n+           size_t total, size_t na_at_peak, size_t ra_at_peak,\n+           unsigned live_nodes_at_peak) {\n+    assert_lock_strong(NMTCompilationCostHistory_lock);\n+\n+    FullMethodName fmn(m->klass_name(), m->name(), m->signature());\n+    fmn.make_permanent();\n+\n+    MemStatEntry** pe = get(fmn);\n+    MemStatEntry* e = nullptr;\n+    if (pe == nullptr) {\n+      e = new MemStatEntry(fmn);\n+      put(fmn, e);\n+    } else {\n+      \/\/ Update existing entry\n+      e = *pe;\n+      assert(e != nullptr, \"Sanity\");\n+    }\n+    e->set_current_time();\n+    e->set_current_thread();\n+    e->set_comptype(comptype);\n+    e->inc_recompilation();\n+    e->set_total(total);\n+    e->set_na_at_peak(na_at_peak);\n+    e->set_ra_at_peak(ra_at_peak);\n+    e->set_live_nodes_at_peak(live_nodes_at_peak);\n+  }\n+\n+  \/\/ Returns a C-heap-allocated SortMe array containing all entries from the table,\n+  \/\/ optionally filtered by entry size\n+  MemStatEntry** calc_flat_array(int& num, size_t min_size) {\n+    assert_lock_strong(NMTCompilationCostHistory_lock);\n+\n+    const int num_all = number_of_entries();\n+    MemStatEntry** flat = NEW_C_HEAP_ARRAY(MemStatEntry*, num_all, mtInternal);\n+    int i = 0;\n+    auto do_f = [&] (const FullMethodName& ignored, MemStatEntry* e) {\n+      if (e->total() >= min_size) {\n+        flat[i] = e;\n+        assert(i < num_all, \"Sanity\");\n+        i ++;\n+      }\n+    };\n+    iterate_all(do_f);\n+    if (min_size == 0) {\n+      assert(i == num_all, \"Sanity\");\n+    } else {\n+      assert(i <= num_all, \"Sanity\");\n+    }\n+    num = i;\n+    return flat;\n+  }\n+};\n+\n+static MemStatTable* _the_table = nullptr;\n+\n+void CompilationMemoryStatistic::initialize() {\n+  assert(_the_table == nullptr, \"Only once\");\n+  _the_table = new (mtCompiler) MemStatTable;\n+  log_info(compilation, alloc)(\"Compilation memory statistic enabled\");\n+}\n+\n+void CompilationMemoryStatistic::on_start_compilation() {\n+  if (CompilationMemStat) {\n+    Thread::current()->as_Compiler_thread()->arena_stat()->start();\n+  }\n+}\n+\n+void CompilationMemoryStatistic::on_end_compilation() {\n+  if (CompilationMemStat) {\n+    ResourceMark rm;\n+    CompilerThread* const th = Thread::current()->as_Compiler_thread();\n+    const ArenaStatCounter* const arena_stat = th->arena_stat();\n+    Method* const m = th->task()->method();\n+    const CompilerType ct = th->task()->compiler()->type();\n+    LogTarget(Info, compilation, alloc) lt;\n+    if (lt.is_enabled()) {\n+      LogStream ls(lt);\n+      ls.print(\"%s Arena usage %s: \", compilertype2name(ct), m->external_name());\n+     arena_stat->print_on(&ls);\n+      ls.cr();\n+    }\n+    {\n+      MutexLocker ml(NMTCompilationCostHistory_lock, Mutex::_no_safepoint_check_flag);\n+      assert(_the_table != nullptr, \"not initialized\");\n+      _the_table->add(m, ct,\n+                      arena_stat->peak_since_start(), \/\/ total\n+                      arena_stat->na_at_peak(),\n+                      arena_stat->ra_at_peak(),\n+                      arena_stat->live_nodes_at_peak());\n+    }\n+  }\n+}\n+\n+void CompilationMemoryStatistic::on_arena_change(ssize_t diff, const Arena* arena) {\n+  if (CompilationMemStat) {\n+    CompilerThread* const th = Thread::current()->as_Compiler_thread();\n+    th->arena_stat()->account(diff, (int)arena->get_tag());\n+  }\n+}\n+\n+static inline ssize_t diff_entries_by_size(const MemStatEntry* e1, const MemStatEntry* e2) {\n+  return e1->compare_by_size(e2);\n+}\n+\n+void CompilationMemoryStatistic::print_all_by_size(outputStream* st, bool human_readable, size_t min_size) {\n+  st->print(\"Compilation memory statistics\");\n+  if (min_size > 0) {\n+    st->print(\" (cutoff: %zu bytes)\", min_size);\n+  }\n+  st->cr();\n+  st->cr();\n+\n+  MemStatEntry::print_legend(st);\n+  st->cr();\n+  MemStatEntry::print_header(st);\n+\n+  MemStatEntry** filtered = nullptr;\n+  {\n+    MutexLocker ml(NMTCompilationCostHistory_lock, Mutex::_no_safepoint_check_flag);\n+\n+    if (_the_table != nullptr) {\n+      \/\/ We sort with quicksort\n+      int num = 0;\n+      filtered = _the_table->calc_flat_array(num, min_size);\n+      if (min_size > 0) {\n+        st->print_cr(\"(%d\/%d)\", num, _the_table->number_of_entries());\n+      }\n+      if (num > 0) {\n+        QuickSort::sort(filtered, num, diff_entries_by_size, false);\n+        \/\/ Now print. Has to happen under lock protection too, since entries may be changed.\n+        for (int i = 0; i < num; i ++) {\n+          filtered[i]->print_on(st, human_readable);\n+        }\n+      } else {\n+        st->print_cr(\"No entries.\");\n+      }\n+    } else {\n+      st->print_cr(\"No initialized.\");\n+    }\n+  } \/\/ locked\n+\n+  FREE_C_HEAP_ARRAY(Entry, filtered);\n+}\n","filename":"src\/hotspot\/share\/compiler\/compilationMemoryStatistic.cpp","additions":422,"deletions":0,"binary":false,"changes":422,"status":"added"},{"patch":"@@ -0,0 +1,99 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, Red Hat, Inc. and\/or its affiliates.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_COMPILER_COMPILATIONMEMORYSTATISTIC_HPP\n+#define SHARE_COMPILER_COMPILATIONMEMORYSTATISTIC_HPP\n+\n+#include \"compiler\/compilerDefinitions.hpp\"\n+#include \"memory\/allocation.hpp\"\n+#include \"memory\/allStatic.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+class outputStream;\n+class Symbol;\n+\n+\/\/ Counters for allocations from one arena\n+class ArenaStatCounter : public CHeapObj<mtCompiler> {\n+  \/\/ Current bytes, total\n+  size_t _current;\n+  \/\/ bytes when compilation started\n+  size_t _start;\n+  \/\/ bytes at least peak, total\n+  size_t _peak;\n+  \/\/ Current bytes used for node arenas, total\n+  size_t _na;\n+  \/\/ Current bytes used for resource areas\n+  size_t _ra;\n+\n+  \/\/ Peak composition:\n+  \/\/ Size of node arena when total peaked (c2 only)\n+  size_t _na_at_peak;\n+  \/\/ Size of resource area when total peaked\n+  size_t _ra_at_peak;\n+  \/\/ Number of live nodes when total peaked (c2 only)\n+  unsigned _live_nodes_at_peak;\n+\n+  void update_c2_node_count();\n+\n+public:\n+  ArenaStatCounter();\n+\n+  \/\/ Size of peak since last compilation\n+  size_t peak_since_start() const;\n+\n+  \/\/ Peak details\n+  size_t na_at_peak() const { return _na_at_peak; }\n+  size_t ra_at_peak() const { return _ra_at_peak; }\n+  unsigned live_nodes_at_peak() const { return _live_nodes_at_peak; }\n+\n+  \/\/ Mark the start of a compilation.\n+  void start();\n+\n+  \/\/ Account an arena allocation or de-allocation.\n+  \/\/ Returns true if new peak reached\n+  bool account(ssize_t delta, int tag);\n+\n+  void set_live_nodes_at_peak(unsigned i) { _live_nodes_at_peak = i; }\n+  void print_on(outputStream* st) const;\n+};\n+\n+class CompilationMemoryStatistic : public AllStatic {\n+public:\n+  static void initialize();\n+  static void on_start_compilation();\n+  static void on_end_compilation();\n+  static void on_arena_change(ssize_t diff, const Arena* arena);\n+  static void print_all_by_size(outputStream* st, bool human_readable, size_t minsize);\n+};\n+\n+\/\/ RAII object to wrap one compilation\n+class CompilationMemoryStatisticMark {\n+public:\n+  CompilationMemoryStatisticMark()  { CompilationMemoryStatistic::on_start_compilation(); }\n+  ~CompilationMemoryStatisticMark() { CompilationMemoryStatistic::on_end_compilation(); }\n+};\n+\n+\n+#endif \/\/ SHARE_COMPILER_COMPILATIONMEMORYSTATISTIC_HPP\n","filename":"src\/hotspot\/share\/compiler\/compilationMemoryStatistic.hpp","additions":99,"deletions":0,"binary":false,"changes":99,"status":"added"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"compiler\/compilationMemoryStatistic.hpp\"\n@@ -37,0 +38,1 @@\n+#include \"compiler\/compiler_globals.hpp\"\n@@ -754,0 +756,4 @@\n+  if (CompilationMemStat) {\n+    CompilationMemoryStatistic::initialize();\n+  }\n+\n","filename":"src\/hotspot\/share\/compiler\/compileBroker.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-inline const char* compilertype2name(CompilerType t) { return (uint)t < compiler_number_of_types ? compilertype2name_tab[t] : nullptr; }\n+inline const char* compilertype2name(CompilerType t) { return (uint)t < compiler_number_of_types ? compilertype2name_tab[t] : \"invalid\"; }\n","filename":"src\/hotspot\/share\/compiler\/compilerDefinitions.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,0 +26,2 @@\n+#include \"compiler\/compilationMemoryStatistic.hpp\"\n+#include \"compiler\/compiler_globals.hpp\"\n@@ -42,0 +44,1 @@\n+  _arena_stat = CompilationMemStat ? new ArenaStatCounter : nullptr;\n@@ -54,0 +57,1 @@\n+  delete _arena_stat;\n","filename":"src\/hotspot\/share\/compiler\/compilerThread.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-class BufferBlob;\n@@ -32,0 +31,2 @@\n+class ArenaStatCounter;\n+class BufferBlob;\n@@ -41,0 +42,1 @@\n+class outputStream;\n@@ -57,0 +59,2 @@\n+  ArenaStatCounter*     _arena_stat;\n+\n@@ -84,0 +88,1 @@\n+  ArenaStatCounter* arena_stat() const           { return _arena_stat; }\n","filename":"src\/hotspot\/share\/compiler\/compilerThread.hpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -382,0 +382,6 @@\n+  product(bool, CompilationMemStat, false, DIAGNOSTIC,                      \\\n+          \"Collect memory statistics per compilation\")                      \\\n+                                                                            \\\n+  product(bool, PrintCompilationMemStatAtExit, false, DIAGNOSTIC,           \\\n+          \"Print compilation memory statistics at VM exit\")                 \\\n+\n","filename":"src\/hotspot\/share\/compiler\/compiler_globals.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+#include \"compiler\/compilationMemoryStatistic.hpp\"\n+#include \"compiler\/compiler_globals.hpp\"\n@@ -212,1 +214,1 @@\n-Arena::Arena(MEMFLAGS flag, size_t init_size) : _flags(flag), _size_in_bytes(0)  {\n+Arena::Arena(MEMFLAGS flag, Tag tag, size_t init_size) : _flags(flag), _tag(tag), _size_in_bytes(0)  {\n@@ -222,1 +224,1 @@\n-Arena::Arena(MEMFLAGS flag) : _flags(flag), _size_in_bytes(0) {\n+Arena::Arena(MEMFLAGS flag, Tag tag) : _flags(flag), _tag(tag), _size_in_bytes(0) {\n@@ -254,0 +256,6 @@\n+    if (CompilationMemStat && _flags == mtCompiler) {\n+      Thread* const t = Thread::current();\n+      if (t->is_Compiler_thread()) {\n+        CompilationMemoryStatistic::on_arena_change(delta, this);\n+      }\n+    }\n","filename":"src\/hotspot\/share\/memory\/arena.cpp","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -89,0 +89,9 @@\n+public:\n+\n+  enum class Tag {\n+    tag_other = 0,\n+    tag_ra,   \/\/ resource area\n+    tag_ha,   \/\/ handle area\n+    tag_node  \/\/ C2 Node arena\n+  };\n+\n@@ -95,1 +104,1 @@\n-\n+  const Tag _tag;\n@@ -118,3 +127,2 @@\n-\n-  Arena(MEMFLAGS memflag);\n-  Arena(MEMFLAGS memflag, size_t init_size);\n+  Arena(MEMFLAGS memflag, Tag tag = Tag::tag_other);\n+  Arena(MEMFLAGS memflag, Tag tag, size_t init_size);\n@@ -174,0 +182,2 @@\n+  Tag get_tag() const { return _tag; }\n+\n","filename":"src\/hotspot\/share\/memory\/arena.hpp","additions":14,"deletions":4,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"memory\/arena.hpp\"\n@@ -54,1 +55,1 @@\n-    Arena(flags) DEBUG_ONLY(COMMA _nesting(0)) {}\n+    Arena(flags, Arena::Tag::tag_ra) DEBUG_ONLY(COMMA _nesting(0)) {}\n@@ -57,1 +58,2 @@\n-    Arena(flags, init_size) DEBUG_ONLY(COMMA _nesting(0)) {}\n+    Arena(flags, Arena::Tag::tag_ra, init_size) DEBUG_ONLY(COMMA _nesting(0)) {\n+  }\n","filename":"src\/hotspot\/share\/memory\/resourceArea.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"compiler\/compilationMemoryStatistic.hpp\"\n@@ -112,0 +113,2 @@\n+  CompilationMemoryStatisticMark cmsm;\n+\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -649,2 +649,2 @@\n-                  _node_arena_one(mtCompiler),\n-                  _node_arena_two(mtCompiler),\n+                  _node_arena_one(mtCompiler, Arena::Tag::tag_node),\n+                  _node_arena_two(mtCompiler, Arena::Tag::tag_node),\n@@ -677,0 +677,1 @@\n+\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -731,1 +731,1 @@\n-  Arena* arena =  new (mtTest) Arena(mtTest, size_t(init_size));\n+  Arena* arena =  new (mtTest) Arena(mtTest, Arena::Tag::tag_other, size_t(init_size));\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -190,1 +190,1 @@\n-  HandleArea(HandleArea* prev) : Arena(mtThread, Chunk::tiny_size) {\n+  HandleArea(HandleArea* prev) : Arena(mtThread, Tag::tag_ha, Chunk::tiny_size) {\n","filename":"src\/hotspot\/share\/runtime\/handles.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"compiler\/compilationMemoryStatistic.hpp\"\n@@ -337,0 +338,4 @@\n+  if (PrintCompilationMemStatAtExit) {\n+    CompilationMemoryStatistic::print_all_by_size(tty, false, 0);\n+  }\n+\n","filename":"src\/hotspot\/share\/runtime\/java.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -142,0 +142,1 @@\n+Mutex*   NMTCompilationCostHistory_lock = nullptr;\n@@ -312,0 +313,1 @@\n+  MUTEX_DEFN(NMTCompilationCostHistory_lock  , PaddedMutex  , nosafepoint);\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -120,0 +120,1 @@\n+extern Mutex*   NMTCompilationCostHistory_lock;  \/\/ guards NMT compilation cost history\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+class CompilerThread;\n@@ -327,0 +328,6 @@\n+  \/\/ Convenience cast functions\n+  CompilerThread* as_Compiler_thread() const {\n+    assert(is_Compiler_thread(), \"Must be compiler thread\");\n+    return (CompilerThread*)this;\n+  }\n+\n","filename":"src\/hotspot\/share\/runtime\/thread.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -34,0 +34,2 @@\n+#include \"compiler\/compilationMemoryStatistic.hpp\"\n+#include \"compiler\/compiler_globals.hpp\"\n@@ -141,0 +143,1 @@\n+  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<CompilationMemoryStatisticDCmd>(full_export, true, false));\n@@ -1137,0 +1140,18 @@\n+\n+CompilationMemoryStatisticDCmd::CompilationMemoryStatisticDCmd(outputStream* output, bool heap) :\n+    DCmdWithParser(output, heap),\n+  _human_readable(\"-H\", \"Human readable format\", \"BOOLEAN\", false, \"false\"),\n+  _minsize(\"-s\", \"Minimum memory size\", \"MEMORY SIZE\", false, \"0\") {\n+  _dcmdparser.add_dcmd_option(&_human_readable);\n+  _dcmdparser.add_dcmd_option(&_minsize);\n+}\n+\n+void CompilationMemoryStatisticDCmd::execute(DCmdSource source, TRAPS) {\n+  if (!CompilationMemStat) {\n+    output()->print_cr(\"Compilation memory statistic unavailable\");\n+    return;\n+  }\n+  const bool human_readable = _human_readable.value();\n+  const size_t minsize = _minsize.has_value() ? _minsize.value()._size : 0;\n+  CompilationMemoryStatistic::print_all_by_size(output(), human_readable, minsize);\n+}\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.cpp","additions":21,"deletions":0,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -957,0 +957,24 @@\n+class CompilationMemoryStatisticDCmd: public DCmdWithParser {\n+protected:\n+  DCmdArgument<bool> _human_readable;\n+  DCmdArgument<MemorySizeArgument> _minsize;\n+public:\n+  static int num_arguments() { return 2; }\n+  CompilationMemoryStatisticDCmd(outputStream* output, bool heap);\n+  static const char* name() {\n+    return \"Compiler.memory\";\n+  }\n+  static const char* description() {\n+    return \"Print compilation footprint\";\n+  }\n+  static const char* impact() {\n+    return \"Medium: Pause time depends on number of compiled methods\";\n+  }\n+  static const JavaPermission permission() {\n+    JavaPermission p = {\"java.lang.management.ManagementPermission\",\n+                        \"monitor\", nullptr};\n+    return p;\n+  }\n+  virtual void execute(DCmdSource source, TRAPS);\n+};\n+\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.hpp","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -332,1 +332,1 @@\n-  Arena ar(mtTest, 4097);\n+  Arena ar(mtTest, Arena::Tag::tag_other, 4097);\n@@ -345,1 +345,1 @@\n-  Arena ar(mtTest, 100); \/\/ first chunk is small\n+  Arena ar(mtTest, Arena::Tag::tag_other, 100); \/\/ first chunk is small\n@@ -375,8 +375,8 @@\n-    Arena ar0(mtTest, random_arena_chunk_size());\n-    Arena ar1(mtTest, random_arena_chunk_size());\n-    Arena ar2(mtTest, random_arena_chunk_size());\n-    Arena ar3(mtTest, random_arena_chunk_size());\n-    Arena ar4(mtTest, random_arena_chunk_size());\n-    Arena ar5(mtTest, random_arena_chunk_size());\n-    Arena ar6(mtTest, random_arena_chunk_size());\n-    Arena ar7(mtTest, random_arena_chunk_size());\n+    Arena ar0(mtTest, Arena::Tag::tag_other, random_arena_chunk_size());\n+    Arena ar1(mtTest, Arena::Tag::tag_other, random_arena_chunk_size());\n+    Arena ar2(mtTest, Arena::Tag::tag_other, random_arena_chunk_size());\n+    Arena ar3(mtTest, Arena::Tag::tag_other, random_arena_chunk_size());\n+    Arena ar4(mtTest, Arena::Tag::tag_other, random_arena_chunk_size());\n+    Arena ar5(mtTest, Arena::Tag::tag_other, random_arena_chunk_size());\n+    Arena ar6(mtTest, Arena::Tag::tag_other, random_arena_chunk_size());\n+    Arena ar7(mtTest, Arena::Tag::tag_other, random_arena_chunk_size());\n","filename":"test\/hotspot\/gtest\/memory\/test_arena.cpp","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -0,0 +1,53 @@\n+package runtime.NMT;\/*\n+ * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Verify PrintCompilerMemStatAtExit\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @run driver PrintNMTStatistics\n+ *\/\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class PrintCompilerMemoryStatisticsAtExitTest {\n+\n+    public static void main(String args[]) throws Exception {\n+       ProcessBuilder pb = ProcessTools.createTestJvm(\n+                \"-XX:+UnlockDiagnosticVMOptions\",\n+                \"-XX:+CompilerMemStat\",\n+                \"-XX:+PrintCompilerMemStatAtExit\",\n+                \"-version\");\n+\n+       OutputAnalyzer out = new OutputAnalyzer(pb.start());\n+       out.shouldHaveExitValue(0);\n+\n+       \/\/ Looks like this:\n+       \/\/ total     NA        RA        #nodes  time    type  #rc thread              method\n+       \/\/ 621832    0         589104    0       0,025   c1    1   0x00007f5ccc1951a0  java\/util\/zip\/ZipFile$Source.checkAndAddEntry((II)I)\n+       out.shouldMatch(\"total.*method\");\n+       out.shouldMatch(\"\\\\d+ +\\\\d+ +\\\\d+ +\\\\d+.*java.*\");\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/NMT\/PrintCompilerMemoryStatisticsAtExitTest.java","additions":53,"deletions":0,"binary":false,"changes":53,"status":"added"},{"patch":"@@ -0,0 +1,55 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, Red Hat, Inc. and\/or its affiliates.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.test.lib.dcmd.PidJcmdExecutor;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+import java.util.Iterator;\n+\n+\/*\n+ * @test CompilerMemoryStatisticTest\n+ * @summary Test Compiler.memory\n+ * @requires vm.compiler1.enabled\n+ * @requires vm.compiler2.enabled\n+ *\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.management\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+CompilationMemStat CompilerMemoryStatisticTest\n+ *\/\n+\n+public class CompilerMemoryStatisticTest {\n+\n+    public static void main(String args[]) throws Exception {\n+        PidJcmdExecutor executor = new PidJcmdExecutor();\n+        OutputAnalyzer out = executor.execute(\"Compiler.memory\");\n+        out.shouldHaveExitValue(0);\n+\n+        \/\/ Looks like this:\n+        \/\/ total     NA        RA        #nodes  time    type  #rc thread              method\n+        \/\/ 621832    0         589104    0       0,025   c1    1   0x00007f5ccc1951a0  java\/util\/zip\/ZipFile$Source.checkAndAddEntry((II)I)\n+        out.shouldMatch(\"total.*method\");\n+        out.shouldMatch(\"\\\\d+ +\\\\d+ +\\\\d+ +\\\\d+.*java.*\");\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/dcmd\/compiler\/CompilerMemoryStatisticTest.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"added"}]}