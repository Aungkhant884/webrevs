{"files":[{"patch":"@@ -53,0 +53,7 @@\n+    \/\/ Check for OOM.\n+    \/\/ If offender has OOM_MARKER_MASK, then loop until no more threads in evac\n+    if ((threads_in_evac & OOM_MARKER_MASK) != 0) {\n+      wait_for_no_evac_threads();\n+      return;\n+    }\n+\n@@ -58,7 +65,0 @@\n-      \/\/ Failure:\n-      \/\/  - if offender has OOM_MARKER_MASK, then loop until no more threads in evac\n-      \/\/  - otherwise re-try CAS\n-      if ((other & OOM_MARKER_MASK) != 0) {\n-        wait_for_no_evac_threads();\n-        return;\n-      }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahEvacOOMHandler.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -37,11 +37,12 @@\n-  if ((threads_in_evac & OOM_MARKER_MASK) != 0) {\n-    wait_for_no_evac_threads();\n-    return;\n-  }\n-\n-  \/\/ Nesting case, this thread already registered\n-  if (level != 0) {\n-     return;\n-  }\n-  \/\/ Entering top level scope, register this thread.\n-  register_thread(thr);\n+ if (level == 0) {\n+   \/\/ Entering top level scope, register this thread.\n+   register_thread(thr);\n+ } else if (!ShenandoahThreadLocalData::is_oom_during_evac(thr)) {\n+   jint threads_in_evac = Atomic::load_acquire(&_threads_in_evac);\n+   \/\/ If OOM is in progress, handle it.\n+   if ((threads_in_evac & OOM_MARKER_MASK) != 0) {\n+     assert((threads_in_evac & ~OOM_MARKER_MASK) > 0, \"sanity\");\n+     Atomic::dec(&_threads_in_evac);\n+     wait_for_no_evac_threads();\n+   }\n+ }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahEvacOOMHandler.inline.hpp","additions":12,"deletions":11,"binary":false,"changes":23,"status":"modified"}]}