{"files":[{"patch":"@@ -94,1 +94,1 @@\n-  * round-trip with the corresponding formatting. For example, a two element String list\n+ * round-trip with the corresponding formatting. For example, a two element String list\n@@ -191,1 +191,1 @@\n-     * {@return the available locales that support list formatting}\n+     * {@return the available locales that support ListFormat}\n@@ -199,1 +199,1 @@\n-     * {@return the list format object for the default\n+     * {@return the ListFormat object for the default\n@@ -208,1 +208,1 @@\n-     * {@return the list format object for the specified {@link Locale}, {@link Type Type},\n+     * {@return the ListFormat object for the specified {@link Locale}, {@link Type Type},\n@@ -211,1 +211,1 @@\n-     * @param type type of the list format. One of {@code STANDARD}, {@code OR},\n+     * @param type type of the ListFormat. One of {@code STANDARD}, {@code OR},\n@@ -213,1 +213,1 @@\n-     * @param style style of the list format. One of {@code FULL}, {@code SHORT},\n+     * @param style style of the ListFormat. One of {@code FULL}, {@code SHORT},\n@@ -227,1 +227,1 @@\n-     * {@return the list format for the specified patterns}\n+     * {@return the ListFormat object for the specified patterns}\n@@ -240,1 +240,2 @@\n-     * Each pattern string is first parsed as follows. Patterns in parentheses are optional:\n+     * Each pattern string is first parsed as follows. Literals in parentheses, such as,\n+     * \"start_before\", are optional:\n@@ -246,1 +247,1 @@\n-     * three := (three_before){0}three_between{1}three_between{2}(three_after)\n+     * three := (three_before){0}three_between1{1}three_between2{2}(three_after)\n@@ -248,3 +249,1 @@\n-     * If parsing of the pattern string for start\/middle\/end fails, it throws an\n-     * {@code IllegalArgumentException}. If two\/three pattern string is empty, or\n-     * fails on parsing, it falls back to\n+     * If two or three pattern string is empty, it falls back to\n@@ -253,0 +252,2 @@\n+     * If parsing of any pattern string for start, middle, end, two, or three fails,\n+     * it throws an {@code IllegalArgumentException}.\n@@ -277,1 +278,1 @@\n-     * <tr><th scope=\"row\" style=\"text-align:left\">2<\/th>\n+     * <tr><th scope=\"row\" style=\"text-align:left\">two<\/th>\n@@ -279,1 +280,1 @@\n-     * <tr><th scope=\"row\" style=\"text-align:left\">3<\/th>\n+     * <tr><th scope=\"row\" style=\"text-align:left\">three<\/th>\n@@ -304,1 +305,2 @@\n-     *          any of {@code start}, {@code middle}, {@code end} patterns cannot be parsed.\n+     *          any of {@code start}, {@code middle}, {@code end}, {@code two}, or\n+     *          {@code three} patterns cannot be parsed.\n@@ -326,0 +328,1 @@\n+\n@@ -340,1 +343,1 @@\n-     * @throws    NullPointerException if {@code toAppendTo} is null\n+     * @throws    NullPointerException if {@code obj} or {@code toAppendTo} is null\n@@ -346,0 +349,1 @@\n+        Objects.requireNonNull(obj);\n@@ -347,0 +351,1 @@\n+\n@@ -353,1 +358,1 @@\n-            throw new IllegalArgumentException(\"The object to format should be an Object list\");\n+            throw new IllegalArgumentException(\"The object to format should be a List<Object> or an Object[]\");\n@@ -429,1 +434,1 @@\n-            if (parsed == null && !patterns[THREE].isEmpty()) {\n+            if (parsed == null) {\n@@ -451,0 +456,2 @@\n+        Objects.requireNonNull(arguments);\n+\n@@ -454,0 +461,2 @@\n+        } else if (arguments instanceof Object[] objs) {\n+            return generateMessageFormat(objs).formatToCharacterIterator(objs);\n@@ -455,1 +464,1 @@\n-            throw new IllegalArgumentException(\"The arguments should be an Object list\");\n+            throw new IllegalArgumentException(\"The arguments should be a List<Object> or an Object[]\");\n@@ -504,8 +513,1 @@\n-            case 2, 3 -> {\n-                var pattern = patterns[len + 1];\n-                if (pattern != null && !pattern.isEmpty()) {\n-                    yield new MessageFormat(pattern, locale);\n-                } else {\n-                    yield new MessageFormat(createMessageFormatString(len), locale);\n-                }\n-            }\n+            case 2, 3 -> new MessageFormat(patterns[len + 1], locale);\n@@ -535,1 +537,1 @@\n-     * A list format type - {@link #STANDARD STANDARD}, {@link #OR OR}, and\n+     * A ListFormat type - {@link #STANDARD STANDARD}, {@link #OR OR}, and\n@@ -544,1 +546,1 @@\n-         * The {@code STANDARD} list format style. This is the default\n+         * The {@code STANDARD} ListFormat style. This is the default\n@@ -550,1 +552,1 @@\n-         * The {@code OR} list format style. This style concatenates\n+         * The {@code OR} ListFormat style. This style concatenates\n@@ -556,1 +558,1 @@\n-         * The {@code UNIT} list format style. This style concatenates\n+         * The {@code UNIT} ListFormat style. This style concatenates\n@@ -563,1 +565,1 @@\n-     * A list format style - {@link #FULL FULL}, {@link #SHORT SHORT},\n+     * A ListFormat style - {@link #FULL FULL}, {@link #SHORT SHORT},\n@@ -572,1 +574,1 @@\n-         * The {@code FULL} list format style. This is the default style, which typically is the \n+         * The {@code FULL} ListFormat style. This is the default style, which typically is the\n@@ -574,1 +576,1 @@\n-         * Suitable for elements, such as, \"Monday\", \"Tuesday\",  \"Wednesday\", etc.\n+         * Suitable for elements, such as, \"Monday\", \"Tuesday\", \"Wednesday\", etc.\n@@ -579,1 +581,1 @@\n-         * The {@code SHORT} list format style. This style is typically an abbreviation \n+         * The {@code SHORT} ListFormat style. This style is typically an abbreviation\n@@ -586,1 +588,1 @@\n-         * The {@code NARROW} list format style. This style is typically the shortest description \n+         * The {@code NARROW} ListFormat style. This style is typically the shortest description\n","filename":"src\/java.base\/share\/classes\/java\/text\/ListFormat.java","additions":38,"deletions":36,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import java.text.FieldPosition;\n@@ -223,0 +224,28 @@\n+\n+        \/\/ Tests NPE\n+        assertThrows(NullPointerException.class,\n+                () -> f.format(null, new StringBuffer(), new FieldPosition(0)));\n+        assertThrows(NullPointerException.class,\n+                () -> f.format(new Object(), null, new FieldPosition(0)));\n+\n+        \/\/ Tests IAE\n+        var ex = assertThrows(IllegalArgumentException.class,\n+                () -> f.format(new Object(), new StringBuffer(), null));\n+        assertEquals(\"The object to format should be a List<Object> or an Object[]\", ex.getMessage());\n+    }\n+\n+    @Test\n+    void formatToCharacterIterator() {\n+        var f = ListFormat.getInstance();\n+        \/\/ Ensures it accepts both List and []\n+        assertEquals(f.formatToCharacterIterator(SAMPLE4).toString(),\n+                f.formatToCharacterIterator(SAMPLE4.toArray()).toString());\n+\n+        \/\/ Tests NPE\n+        assertThrows(NullPointerException.class,\n+                () -> f.formatToCharacterIterator(null));\n+\n+        \/\/ Tests IAE\n+        var ex = assertThrows(IllegalArgumentException.class,\n+                () -> f.formatToCharacterIterator(new Object()));\n+        assertEquals(\"The arguments should be a List<Object> or an Object[]\", ex.getMessage());\n","filename":"test\/jdk\/java\/text\/Format\/ListFormat\/TestListFormat.java","additions":29,"deletions":0,"binary":false,"changes":29,"status":"modified"}]}