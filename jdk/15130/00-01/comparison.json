{"files":[{"patch":"@@ -0,0 +1,207 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8041488\n+ * @summary Tests for ListFormat class\n+ * @run junit TestListFormat\n+ *\/\n+\n+import java.text.DateFormat;\n+import java.text.ListFormat;\n+import java.text.ParseException;\n+import java.util.List;\n+import java.util.Locale;\n+\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import static org.junit.jupiter.api.Assertions.assertArrayEquals;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.params.provider.Arguments.arguments;\n+\n+public class TestListFormat {\n+    private static final List<String> SAMPLE1 = List.of(\"foo\");\n+    private static final List<String> SAMPLE2 = List.of(\"foo\", \"bar\");\n+    private static final List<String> SAMPLE3 = List.of(\"foo\", \"bar\", \"baz\");\n+    private static final List<String> SAMPLE4 = List.of(\"foo\", \"bar\", \"baz\", \"qux\");\n+    private static final String[] CUSTOM_PATTERNS_FULL = {\n+            \"sbef {0} sbet {1}\",\n+            \"{0} mid {1}\",\n+            \"{0} ebet {1} eaft\",\n+            \"twobef {0} two {1} twoaft\",\n+            \"threebef {0} three {1} three {2} threeaft\",\n+    };\n+    private static final String[] CUSTOM_PATTERNS_MINIMAL = {\n+            \"sbef {0} sbet {1}\",\n+            \"{0} mid {1}\",\n+            \"{0} ebet {1} eaft\",\n+            \"\",\n+            \"\",\n+    };\n+    private static final String[] CUSTOM_PATTERNS_IAE_START = {\n+            \"{0}\",\n+            \"{0} mid {1}\",\n+            \"{0} ebet {1} eaft\",\n+            \"\",\n+            \"\",\n+    };\n+    private static final String[] CUSTOM_PATTERNS_IAE_MIDDLE = {\n+            \"{0} sbet {1}\",\n+            \"{0} {1} {2}\",\n+            \"{0} ebet {1} eaft\",\n+            \"\",\n+            \"\",\n+    };\n+    private static final String[] CUSTOM_PATTERNS_IAE_END = {\n+            \"{0} sbet {1}\",\n+            \"{0} mid {1}\",\n+            \"error {0} ebet {1}\",\n+            \"\",\n+            \"\",\n+    };\n+\n+    @Test\n+    void getAvailableLocales() {\n+        assertArrayEquals(DateFormat.getAvailableLocales(), ListFormat.getAvailableLocales());\n+    }\n+\n+    @Test\n+    void getInstance_noArg() {\n+        assertEquals(ListFormat.getInstance(), ListFormat.getInstance(Locale.getDefault(Locale.Category.FORMAT), ListFormat.Type.STANDARD, ListFormat.Style.FULL));\n+    }\n+\n+    static Arguments[] getInstance_1Arg() {\n+        return new Arguments[] {\n+                arguments(CUSTOM_PATTERNS_FULL, SAMPLE1, \"foo\"),\n+                arguments(CUSTOM_PATTERNS_FULL, SAMPLE2, \"twobef foo two bar twoaft\"),\n+                arguments(CUSTOM_PATTERNS_FULL, SAMPLE3, \"threebef foo three bar three baz threeaft\"),\n+                arguments(CUSTOM_PATTERNS_FULL, SAMPLE4, \"sbef foo sbet bar mid baz ebet qux eaft\"),\n+                arguments(CUSTOM_PATTERNS_MINIMAL, SAMPLE1, \"foo\"),\n+                arguments(CUSTOM_PATTERNS_MINIMAL, SAMPLE2, \"sbef foo ebet bar eaft\"),\n+                arguments(CUSTOM_PATTERNS_MINIMAL, SAMPLE3, \"sbef foo sbet bar ebet baz eaft\"),\n+                arguments(CUSTOM_PATTERNS_MINIMAL, SAMPLE4, \"sbef foo sbet bar mid baz ebet qux eaft\"),\n+        };\n+    }\n+\n+    static Arguments[] getInstance_1Arg_IAE() {\n+        return new Arguments[] {\n+                arguments(new String[1], \"Pattern array length should be 5\"),\n+                arguments(new String[6], \"Pattern array length should be 5\"),\n+                arguments(CUSTOM_PATTERNS_IAE_START, \"start pattern is incorrect: {0}\"),\n+                arguments(CUSTOM_PATTERNS_IAE_MIDDLE, \"middle pattern is incorrect: {0} {1} {2}\"),\n+                arguments(CUSTOM_PATTERNS_IAE_END, \"end pattern is incorrect: error {0} ebet {1}\"),\n+        };\n+    }\n+\n+    static Arguments[] getInstance_3Arg() {\n+        return new Arguments[] {\n+                arguments(Locale.US, ListFormat.Type.STANDARD, ListFormat.Style.FULL,\n+                        \"foo, bar, and baz\", true),\n+                arguments(Locale.US, ListFormat.Type.OR, ListFormat.Style.FULL,\n+                        \"foo, bar, or baz\", true),\n+                arguments(Locale.US, ListFormat.Type.UNIT, ListFormat.Style.FULL,\n+                        \"foo, bar, baz\", true),\n+                arguments(Locale.US, ListFormat.Type.STANDARD, ListFormat.Style.SHORT,\n+                        \"foo, bar, & baz\", true),\n+                arguments(Locale.US, ListFormat.Type.OR, ListFormat.Style.SHORT,\n+                        \"foo, bar, or baz\", true),\n+                arguments(Locale.US, ListFormat.Type.UNIT, ListFormat.Style.SHORT,\n+                        \"foo, bar, baz\", true),\n+                arguments(Locale.US, ListFormat.Type.STANDARD, ListFormat.Style.NARROW,\n+                        \"foo, bar, baz\", true),\n+                arguments(Locale.US, ListFormat.Type.OR, ListFormat.Style.NARROW,\n+                        \"foo, bar, or baz\", true),\n+                arguments(Locale.US, ListFormat.Type.UNIT, ListFormat.Style.NARROW,\n+                        \"foo bar baz\", true),\n+\n+                arguments(Locale.JAPAN, ListFormat.Type.STANDARD, ListFormat.Style.FULL,\n+                        \"foo\\u3001bar\\u3001baz\", true),\n+                arguments(Locale.JAPAN, ListFormat.Type.OR, ListFormat.Style.FULL,\n+                        \"foo\\u3001bar\\u3001\\u307e\\u305f\\u306fbaz\", true),\n+                arguments(Locale.JAPAN, ListFormat.Type.UNIT, ListFormat.Style.FULL,\n+                        \"foo bar baz\", true),\n+                arguments(Locale.JAPAN, ListFormat.Type.STANDARD, ListFormat.Style.SHORT,\n+                        \"foo\\u3001bar\\u3001baz\", true),\n+                arguments(Locale.JAPAN, ListFormat.Type.OR, ListFormat.Style.SHORT,\n+                        \"foo\\u3001bar\\u3001\\u307e\\u305f\\u306fbaz\", true),\n+                arguments(Locale.JAPAN, ListFormat.Type.UNIT, ListFormat.Style.SHORT,\n+                        \"foo bar baz\", true),\n+                arguments(Locale.JAPAN, ListFormat.Type.STANDARD, ListFormat.Style.NARROW,\n+                        \"foo\\u3001bar\\u3001baz\", true),\n+                arguments(Locale.JAPAN, ListFormat.Type.OR, ListFormat.Style.NARROW,\n+                        \"foo\\u3001bar\\u3001\\u307e\\u305f\\u306fbaz\", true),\n+                arguments(Locale.JAPAN, ListFormat.Type.UNIT, ListFormat.Style.NARROW,\n+                        \"foobarbaz\", false), \/\/ no delimiter, impossible to parse\/roundtrip\n+        };\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource\n+    void getInstance_1Arg(String[] patterns, List<String> input, String expected) throws ParseException {\n+        var f = ListFormat.getInstance(patterns);\n+        compareResult(f, input, expected, true);\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource\n+    void getInstance_1Arg_IAE(String[] invalidPatterns, String errorMsg) {\n+        var ex = assertThrows(IllegalArgumentException.class,\n+                () -> ListFormat.getInstance(invalidPatterns));\n+        assertEquals(errorMsg, ex.getMessage());\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource\n+    void getInstance_3Arg(Locale l, ListFormat.Type type, ListFormat.Style style, String expected, boolean roundTrip) throws ParseException {\n+        var f = ListFormat.getInstance(l, type, style);\n+        compareResult(f, SAMPLE3, expected, roundTrip);\n+    }\n+\n+    @Test\n+    void format_3Arg() {\n+        var f = ListFormat.getInstance();\n+        \/\/ Ensures it accepts both List and []\n+        assertEquals(f.format(SAMPLE4, new StringBuffer(), null).toString(),\n+                f.format(SAMPLE4.toArray(), new StringBuffer(), null).toString());\n+    }\n+\n+    @Test\n+    void format_emptyInput() {\n+        var ex = assertThrows(IllegalArgumentException.class,\n+                () -> ListFormat.getInstance().format(List.of()));\n+        assertEquals(\"There should at least be one input string\", ex.getMessage());\n+    }\n+\n+    private static void compareResult(ListFormat f, List<String> input, String expected, boolean roundTrip) throws ParseException {\n+        var result = f.format(input);\n+        assertEquals(expected, result);\n+        if (roundTrip) {\n+            assertEquals(input, f.parse(result));\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/text\/Format\/ListFormat\/TestListFormat.java","additions":207,"deletions":0,"binary":false,"changes":207,"status":"added"}]}