{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -111,0 +111,6 @@\n+    static final String[] LIST_PATTERN_KEYS = {\n+            \"ListPatterns_standard\",\n+            \"ListPatterns_or\",\n+            \"ListPatterns_unit\",\n+    };\n+\n","filename":"make\/jdk\/src\/classes\/build\/tools\/cldrconverter\/Bundle.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -624,1 +624,8 @@\n-            var source = bundleMap.get(aliases.get(key));\n+            var sourceKey = aliases.get(key);\n+            if (key.startsWith(\"ListPatterns_\")) {\n+                String k;\n+                while ((k = aliases.get(sourceKey)) != null) {\n+                    sourceKey = k;\n+                }\n+            }\n+            var source = bundleMap.get(sourceKey);\n@@ -874,0 +881,1 @@\n+        \"ListPatterns\",\n@@ -938,0 +946,8 @@\n+\n+        \/\/ ListPatterns\n+        for (var lpKey : Bundle.LIST_PATTERN_KEYS) {\n+            copyIfPresent(map, lpKey, formatData);\n+            copyIfPresent(map, lpKey + \"-short\", formatData);\n+            copyIfPresent(map, lpKey + \"-narrow\", formatData);\n+        }\n+\n","filename":"make\/jdk\/src\/classes\/build\/tools\/cldrconverter\/CLDRConverter.java","additions":17,"deletions":1,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,0 +38,1 @@\n+import java.util.Optional;\n@@ -815,0 +816,1 @@\n+                        || (currentContainer.getqName().equals(\"listPattern\"))\n@@ -823,0 +825,22 @@\n+        \/\/ ListPatterns\n+        case \"listPattern\":\n+            currentStyle = Optional.ofNullable(attributes.getValue(\"type\")).orElse(\"standard\");\n+            pushStringArrayEntry(qName, attributes, \"ListPatterns_\" + currentStyle, 5);\n+            break;\n+        case \"listPatternPart\":\n+            type = attributes.getValue(\"type\");\n+            pushStringArrayElement(qName, attributes,\n+                switch (type) {\n+                    case \"start\" -> 0;\n+                    case \"middle\" -> 1;\n+                    case \"end\" -> 2;\n+                    case \"2\" -> 3;\n+                    case \"3\" -> 4;\n+                    default -> throw new IllegalArgumentException(\n+                        \"\"\"\n+                        The \"type\" attribute value for \"listPatternPart\" element is not recognized: %s\n+                        \"\"\".formatted(type)\n+                    );\n+                });\n+            break;\n+\n@@ -976,0 +1000,3 @@\n+        case \"listPattern\":\n+            keyName = type;\n+            break;\n@@ -1038,0 +1065,13 @@\n+        \/\/ listPattern\n+        if (path.indexOf(\"..\/listPattern\") != -1) {\n+            typeKey = \"[@type='\";\n+            start = path.indexOf(typeKey);\n+            String style;\n+            if (start != -1) {\n+                style = \"ListPatterns_\" + path.substring(start + typeKey.length(), path.indexOf(\"']\", start));\n+            } else {\n+                style = \"ListPatterns_standard\";\n+            }\n+            return toJDKKey(qName, \"\", style);\n+        }\n+\n@@ -1110,0 +1150,4 @@\n+        case \"listPattern\":\n+            currentStyle = \"\";\n+            putIfEntry();\n+            break;\n@@ -1131,0 +1175,6 @@\n+            } else if (containerqName.equals(\"listPattern\")) {\n+                var sae = (StringArrayEntry)entry.getParent();\n+                CLDRConverter.aliases.put(\n+                        toJDKKey(containerqName, \"\", sae.getKey()),\n+                        getTarget(entry.getKey(), \"\", \"\", \"\")\n+                );\n","filename":"make\/jdk\/src\/classes\/build\/tools\/cldrconverter\/LDMLParseHandler.java","additions":51,"deletions":1,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,1 +45,1 @@\n- * information such as dates, messages, and numbers.\n+ * information such as dates, messages, numbers, and lists.\n@@ -64,3 +64,3 @@\n- * The Java Platform provides three specialized subclasses of {@code Format}--\n- * {@code DateFormat}, {@code MessageFormat}, and\n- * {@code NumberFormat}--for formatting dates, messages, and numbers,\n+ * The Java Platform provides specialized subclasses of {@code Format}--\n+ * {@code DateFormat}, {@code MessageFormat}, {@code NumberFormat}, and\n+ * {@code ListFormat}--for formatting dates, messages, numbers, and lists\n@@ -131,0 +131,1 @@\n+ * @see          java.text.ListFormat\n","filename":"src\/java.base\/share\/classes\/java\/text\/Format.java","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -0,0 +1,611 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.text;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.Serial;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Objects;\n+import java.util.regex.Pattern;\n+import java.util.stream.IntStream;\n+import sun.util.locale.provider.LocaleProviderAdapter;\n+\n+\/**\n+ * {@code ListFormat} formats or parses a list of strings in a locale-sensitive way.\n+ * Use {@code ListFormat} to construct a list of strings displayed for end users.\n+ * For example, displaying a list of 3 weekdays, e.g. \"Monday\", \"Wednesday\", \"Friday\"\n+ * as \"Monday, Wednesday, and Friday\" in an inclusive list type. This class provides\n+ * the functionality defined in Unicode Consortium's LDML specification for\n+ * <a href=\"https:\/\/www.unicode.org\/reports\/tr35\/tr35-general.html#ListPatterns\">\n+ * List Patterns<\/a>.\n+ * <p>\n+ * Three formatting types are provided: {@link Type#STANDARD STANDARD}, {@link Type#OR OR},\n+ * and {@link Type#UNIT UNIT}, which determines the punctuation\n+ * between the strings and the connecting words if any. Also, three formatting styles for each\n+ * type are provided: {@link Style#FULL FULL}, {@link Style#SHORT SHORT}, and\n+ * {@link Style#NARROW NARROW}, suitable for how the strings are abbreviated (or not).\n+ * The following snippet is an example of formatting\n+ * the list of Strings {@code \"Foo\", \"Bar\", \"Baz\"} in US English with\n+ * {@code STANDARD} type and {@code FULL} style:\n+ * {@snippet lang=java :\n+ * ListFormat.getInstance(Locale.US, ListFormat.Type.STANDARD, ListFormat.Style.FULL)\n+ *     .format(List.of(\"Foo\", \"Bar\", \"Baz\"))\n+ * }\n+ * This will produce the concatenated list string, \"Foo, Bar, and Baz\" as seen in\n+ * the following:\n+ * <table class=\"striped\">\n+ * <caption style=\"display:none\">Formatting examples<\/caption>\n+ * <thead>\n+ * <tr><th scope=\"col\"><\/th>\n+ *     <th scope=\"col\">FULL<\/th>\n+ *     <th scope=\"col\">SHORT<\/th>\n+ *     <th scope=\"col\">NARROW<\/th><\/tr>\n+ * <\/thead>\n+ * <tbody>\n+ * <tr><th scope=\"row\" style=\"text-align:left\">STANDARD<\/th>\n+ *     <td>Foo, Bar, and Baz<\/td>\n+ *     <td>Foo, Bar, &amp; Baz<\/td>\n+ *     <td>Foo, Bar, Baz<\/td>\n+ * <tr><th scope=\"row\" style=\"text-align:left\">OR<\/th>\n+ *     <td>Foo, Bar, or Baz<\/td>\n+ *     <td>Foo, Bar, or Baz<\/td>\n+ *     <td>Foo, Bar, or Baz<\/td>\n+ * <tr><th scope=\"row\" style=\"text-align:left\">UNIT<\/th>\n+ *     <td>Foo, Bar, Baz<\/td>\n+ *     <td>Foo, Bar, Baz<\/td>\n+ *     <td>Foo Bar Baz<\/td>\n+ * <\/tbody>\n+ * <\/table>\n+ * Note: these examples are from CLDR, there could be different results from other locale providers.\n+ * <p>\n+ * Alternatively, Locale, Type, and\/or Style independent instances\n+ * can be created with {@link #getInstance(String[])}. The String array to the\n+ * method specifies the delimiting patterns for the start\/middle\/end portion of\n+ * the formatted string, as well as optional specialized patterns for two or three\n+ * elements. Refer to the method description for more detail.\n+ * <p>\n+ * On parsing, if some ambiguity is found in the input string, such as delimiting\n+ * sequences in the input string, the result, when formatted with the same formatting, does not\n+ * re-produce the input string. For example, a two element String list\n+ * \"a, b,\", \"c\" will be formatted as \"a, b, and c\", but may be parsed as three elements\n+ * \"a\", \"b\", \"c\".\n+ *\n+ * @implSpec This class is immutable and thread-safe\n+ *\n+ * @spec https:\/\/www.unicode.org\/reports\/tr35 Unicode Locale Data Markup Language (LDML)\n+ * @since 22\n+ *\/\n+public final class ListFormat extends Format {\n+\n+    @Serial\n+    private static final long serialVersionUID = 5272525550078071946L;\n+\n+    private static final int START = 0;\n+    private static final int MIDDLE = 1;\n+    private static final int END = 2;\n+    private static final int TWO = 3;\n+    private static final int THREE = 4;\n+    private static final int PATTERN_ARRAY_LENGTH = THREE + 1;\n+\n+    \/**\n+     * The locale to use for formatting list patterns.\n+     * @serial\n+     *\/\n+    private final Locale locale;\n+\n+    \/**\n+     * The array of five pattern Strings. Each element corresponds to the Unicode LDML's\n+     * `listPatternsPart` type, i.e, start\/middle\/end\/two\/three.\n+     * @serial\n+     *\/\n+    private final String[] patterns;\n+\n+    private static final Pattern PARSE_START = Pattern.compile(\"(.*?)\\\\{0}(.*?)\\\\{1}\");\n+    private static final Pattern PARSE_MIDDLE = Pattern.compile(\"\\\\{0}(.*?)\\\\{1}\");\n+    private static final Pattern PARSE_END = Pattern.compile(\"\\\\{0}(.*?)\\\\{1}(.*?)\");\n+    private static final Pattern PARSE_TWO = Pattern.compile(\"(.*?)\\\\{0}(.*?)\\\\{1}(.*?)\");\n+    private static final Pattern PARSE_THREE = Pattern.compile(\"(.*?)\\\\{0}(.*?)\\\\{1}(.*?)\\\\{2}(.*?)\");\n+    private transient Pattern startPattern;\n+    private transient String middleBetween;\n+    private transient Pattern endPattern;\n+\n+    private ListFormat(Locale l, String[] patterns) {\n+        locale = l;\n+        this.patterns = patterns;\n+        init();\n+    }\n+\n+    private void init() {\n+        \/\/ check for null pattern elements\n+        for (String elem : patterns) {\n+            if (elem == null) {\n+                throw new IllegalArgumentException(\"patterns array contains one or more null elements\");\n+            }\n+        }\n+\n+        \/\/ get pattern strings\n+        var m = PARSE_START.matcher(patterns[START]);\n+        String startBefore;\n+        String startBetween;\n+        if (m.matches()) {\n+            startBefore = m.group(1);\n+            startBetween = m.group(2);\n+        } else {\n+            throw new IllegalArgumentException(\"start pattern is incorrect: \" + patterns[START]);\n+        }\n+        m = PARSE_MIDDLE.matcher(patterns[MIDDLE]);\n+        if (m.matches()) {\n+            middleBetween = m.group(1);\n+        } else {\n+            throw new IllegalArgumentException(\"middle pattern is incorrect: \" + patterns[MIDDLE]);\n+        }\n+        m = PARSE_END.matcher(patterns[END]);\n+        String endBetween;\n+        String endAfter;\n+        if (m.matches()) {\n+            endBetween = m.group(1);\n+            endAfter = m.group(2);\n+        } else {\n+            throw new IllegalArgumentException(\"end pattern is incorrect: \" + patterns[END]);\n+        }\n+\n+        \/\/ Validate two\/three patterns, if given. Otherwise, generate them\n+        if (!patterns[TWO].isEmpty()) {\n+            if (!PARSE_TWO.matcher(patterns[TWO]).matches()) {\n+                throw new IllegalArgumentException(\"pattern for two is incorrect: \" + patterns[TWO]);\n+            }\n+        } else {\n+            patterns[TWO] = startBefore + \"{0}\" + endBetween + \"{1}\" + endAfter;\n+        }\n+        if (!patterns[THREE].isEmpty()) {\n+            if (!PARSE_THREE.matcher(patterns[THREE]).matches()) {\n+                throw new IllegalArgumentException(\"pattern for three is incorrect: \" + patterns[THREE]);\n+            }\n+        } else {\n+            patterns[THREE] = startBefore + \"{0}\" + startBetween + \"{1}\" + endBetween + \"{2}\" + endAfter;\n+        }\n+\n+        startPattern = Pattern.compile(startBefore + \"(.+?)\" + startBetween);\n+        endPattern = Pattern.compile(endBetween + \"(.+?)\" + endAfter);\n+    }\n+\n+    \/**\n+     * {@return the available locales that support ListFormat}\n+     *\/\n+    public static Locale[] getAvailableLocales() {\n+        \/\/ Same as a typical format class\n+        return DateFormat.getAvailableLocales();\n+    }\n+\n+    \/**\n+     * {@return the ListFormat object for the default\n+     * {@link Locale.Category#FORMAT FORMAT Locale}, {@link Type#STANDARD STANDARD} type,\n+     * and {@link Style#FULL FULL} style}\n+     *\/\n+    public static ListFormat getInstance() {\n+        return getInstance(Locale.getDefault(Locale.Category.FORMAT), Type.STANDARD, Style.FULL);\n+    }\n+\n+    \/**\n+     * {@return the ListFormat object for the specified {@link Locale}, {@link Type Type},\n+     * and {@link Style Style}}\n+     * @param locale {@code Locale} to be used, not null\n+     * @param type type of the ListFormat. One of {@code STANDARD}, {@code OR},\n+     *             or {@code UNIT}, not null\n+     * @param style style of the ListFormat. One of {@code FULL}, {@code SHORT},\n+     *              or {@code NARROW}, not null\n+     * @throws NullPointerException if any of the arguments are null\n+     *\/\n+    public static ListFormat getInstance(Locale locale, Type type, Style style) {\n+        Objects.requireNonNull(locale);\n+        Objects.requireNonNull(type);\n+        Objects.requireNonNull(style);\n+        return new ListFormat(locale, LocaleProviderAdapter.forType(LocaleProviderAdapter.Type.CLDR)\n+                .getLocaleResources(locale)\n+                .getListPatterns(type, style));\n+    }\n+\n+    \/**\n+     * {@return the ListFormat object for the specified patterns}\n+     * <p>\n+     * This factory returns an instance based on the customized patterns array,\n+     * instead of letting the runtime provide appropriate patterns for the {@code Locale},\n+     * {@code Type}, or {@code Style}.\n+     * <p>\n+     * The patterns array should contain five String patterns, each corresponding to the Unicode LDML's\n+     * {@code listPatternPart}, i.e., \"start\", \"middle\", \"end\", two element, and three element patterns\n+     * in this order. Each pattern contains \"{0}\" and \"{1}\" (and \"{2}\" for the three element pattern)\n+     * placeholders that are substituted with the passed input strings on formatting.\n+     * If the length of the patterns array is not 5, an {@code IllegalArgumentException}\n+     * is thrown.\n+     * <p>\n+     * Each pattern string is first parsed as follows. Literals in parentheses, such as\n+     * \"start_before\", are optional:\n+     * <blockquote><pre>\n+     * start := (start_before){0}start_between{1}\n+     * middle := {0}middle_between{1}\n+     * end := {0}end_between{1}(end_after)\n+     * two := (two_before){0}two_between{1}(two_after)\n+     * three := (three_before){0}three_between1{1}three_between2{2}(three_after)\n+     * <\/pre><\/blockquote>\n+     * If two or three pattern string is empty, it falls back to\n+     * {@code \"(start_before){0}end_between{1}(end_after)\"},\n+     * {@code \"(start_before){0}start_between{1}end_between{2}(end_after)\"} respectively.\n+     * If parsing of any pattern string for start, middle, end, two, or three fails,\n+     * it throws an {@code IllegalArgumentException}.\n+     * <p>\n+     * On formatting, the input string list with {@code n} elements substitutes above\n+     * placeholders based on the number of elements:\n+     * <blockquote><pre>\n+     * n = 1: {0}\n+     * n = 2: parsed pattern for \"two\"\n+     * n = 3: parsed pattern for \"three\"\n+     * n > 3: (start_before){0}start_between{1}middle_between{2} ... middle_between{m}end_between{n}(end_after)\n+     * <\/pre><\/blockquote>\n+     * As an example, the following table shows a pattern array which is equivalent to\n+     * {@code STANDARD} type, {@code FULL} style in US English:\n+     * <table class=\"striped\">\n+     * <caption style=\"display:none\">Standard\/Full Patterns in US English<\/caption>\n+     * <thead>\n+     * <tr><th scope=\"col\">Pattern Kind<\/th>\n+     *     <th scope=\"col\">Pattern String<\/th><\/tr>\n+     * <\/thead>\n+     * <tbody>\n+     * <tr><th scope=\"row\" style=\"text-align:left\">start<\/th>\n+     *     <td>\"{0}, {1}\"<\/td>\n+     * <tr><th scope=\"row\" style=\"text-align:left\">middle<\/th>\n+     *     <td>\"{0}, {1}\"<\/td>\n+     * <tr><th scope=\"row\" style=\"text-align:left\">end<\/th>\n+     *     <td>\"{0}, and {1}\"<\/td>\n+     * <tr><th scope=\"row\" style=\"text-align:left\">two<\/th>\n+     *     <td>\"{0} and {1}\"<\/td>\n+     * <tr><th scope=\"row\" style=\"text-align:left\">three<\/th>\n+     *     <td>\"\"<\/td>\n+     * <\/tbody>\n+     * <\/table>\n+     * Here are the resulting formatted strings with the above pattern array.\n+     * <table class=\"striped\">\n+     * <caption style=\"display:none\">Formatting examples<\/caption>\n+     * <thead>\n+     * <tr><th scope=\"col\">Input String List<\/th>\n+     *     <th scope=\"col\">Formatted String<\/th><\/tr>\n+     * <\/thead>\n+     * <tbody>\n+     * <tr><th scope=\"row\" style=\"text-align:left\">\"Foo\", \"Bar\", \"Baz\", \"Qux\"<\/th>\n+     *     <td>\"Foo, Bar, Baz, and Qux\"<\/td>\n+     * <tr><th scope=\"row\" style=\"text-align:left\">\"Foo\", \"Bar\", \"Baz\"<\/th>\n+     *     <td>\"Foo, Bar, and Baz\"<\/td>\n+     * <tr><th scope=\"row\" style=\"text-align:left\">\"Foo\", \"Bar\"<\/th>\n+     *     <td>\"Foo and Bar\"<\/td>\n+     * <tr><th scope=\"row\" style=\"text-align:left\">\"Foo\"<\/th>\n+     *     <td>\"Foo\"<\/td>\n+     * <\/tbody>\n+     * <\/table>\n+     *\n+     * @param patterns array of patterns, not null\n+     * @throws IllegalArgumentException if the length {@code patterns} array is not 5, or\n+     *          any of {@code start}, {@code middle}, {@code end}, {@code two}, or\n+     *          {@code three} patterns cannot be parsed.\n+     * @throws NullPointerException if {@code patterns} is null.\n+     *\/\n+    public static ListFormat getInstance(String[] patterns) {\n+        Objects.requireNonNull(patterns);\n+        if (patterns.length != PATTERN_ARRAY_LENGTH) {\n+            throw new IllegalArgumentException(\"Pattern array length should be \" + PATTERN_ARRAY_LENGTH);\n+        }\n+        return new ListFormat(Locale.ROOT, Arrays.copyOf(patterns, PATTERN_ARRAY_LENGTH));\n+    }\n+\n+    \/**\n+     * {@return the string that consists of the input strings, concatenated with the\n+     * patterns of this {@code ListFormat}}\n+     * @apiNote Formatting the string from an excessively long list may exceed memory\n+     *          or string sizes.\n+     * @param input The list of input strings to format. There should at least\n+     *              one String element in this list, otherwise an {@code IllegalArgumentException}\n+     *              is thrown.\n+     * @throws IllegalArgumentException if the length of {@code input} is zero.\n+     * @throws NullPointerException if {@code input} is null.\n+     *\/\n+    public String format(List<String> input) {\n+        Objects.requireNonNull(input);\n+\n+        return format(input, new StringBuffer(),\n+                DontCareFieldPosition.INSTANCE).toString();\n+    }\n+\n+    \/**\n+     * Formats an object and appends the resulting text to a given string\n+     * buffer. The object should either be a List or an array of Objects.\n+     *\n+     * @apiNote Formatting the string from an excessively long list or array\n+     *          may exceed memory or string sizes.\n+     * @param obj    The object to format. Must be a List or an array\n+     *               of Object.\n+     * @param toAppendTo    where the text is to be appended\n+     * @param pos    Ignored. Not used in ListFormat. May be null\n+     * @return       the string buffer passed in as {@code toAppendTo},\n+     *               with formatted text appended\n+     * @throws    NullPointerException if {@code obj} or {@code toAppendTo} is null\n+     * @throws    IllegalArgumentException if the given object cannot\n+     *               be formatted\n+     *\/\n+    @Override\n+    public StringBuffer format(Object obj, StringBuffer toAppendTo, FieldPosition pos) {\n+        Objects.requireNonNull(obj);\n+        Objects.requireNonNull(toAppendTo);\n+\n+        if (obj instanceof Object[] objs) {\n+            return generateMessageFormat(objs).format(objs, toAppendTo, DontCareFieldPosition.INSTANCE);\n+        } else if (obj instanceof List<?> objs) {\n+            var a = objs.toArray(new Object[0]);\n+            return generateMessageFormat(a).format(a, toAppendTo, DontCareFieldPosition.INSTANCE);\n+        } else {\n+            throw new IllegalArgumentException(\"The object to format should be a List<Object> or an Object[]\");\n+        }\n+    }\n+\n+    \/**\n+     * {@return the parsed list of strings from the {@code source} string}\n+     *\n+     * Note that {@link #format(List)} and this method\n+     * may not guarantee a round-trip, if the input strings contain ambiguous\n+     * delimiters. For example, a two element String list {@code \"a, b,\", \"c\"} will be\n+     * formatted as {@code \"a, b, and c\"}, but may be parsed as three elements\n+     * {@code \"a\", \"b\", \"c\"}.\n+     *\n+     * @param source the string to parse, not null.\n+     * @throws ParseException if parse failed\n+     * @throws NullPointerException if source is null\n+     *\/\n+    public List<String> parse(String source) throws ParseException {\n+        var pp = new ParsePosition(0);\n+        if (parseObject(source, pp) instanceof List<?> orig) {\n+            \/\/ parseObject() should've returned List<String>\n+            return orig.stream().map(o -> (String)o).toList();\n+        } else {\n+            throw new ParseException(\"Parse failed\", pp.getErrorIndex());\n+        }\n+    }\n+\n+    \/**\n+     * Parses text from a string to produce a list of strings.\n+     * <p>\n+     * The method attempts to parse text starting at the index given by\n+     * {@code parsePos}.\n+     * If parsing succeeds, then the index of {@code parsePos} is updated\n+     * to the index after the last character used (parsing does not necessarily\n+     * use all characters up to the end of the string), and the parsed\n+     * object is returned. The updated {@code parsePos} can be used to\n+     * indicate the starting point for the next call to parse additional text.\n+     * If an error occurs, then the index of {@code parsePos} is not\n+     * changed, the error index of {@code parsePos} is set to the index of\n+     * the character where the error occurred, and null is returned.\n+     * See the {@link #parse(String)} method for more information\n+     * on list parsing.\n+     *\n+     * @param source A string, part of which should be parsed.\n+     * @param parsePos A {@code ParsePosition} object with index and error\n+     *            index information as described above.\n+     * @return A list of string parsed from the {@code source}.\n+     *            In case of error, returns null.\n+     * @throws NullPointerException if {@code source} or {@code parsePos} is null.\n+     *\/\n+    @Override\n+    public Object parseObject(String source, ParsePosition parsePos) {\n+        Objects.requireNonNull(source);\n+        Objects.requireNonNull(parsePos);\n+        var sm = startPattern.matcher(source);\n+        var em = endPattern.matcher(source);\n+        Object parsed = null;\n+        if (sm.find(parsePos.getIndex()) && em.find(parsePos.getIndex())) {\n+            \/\/ get em to the last\n+            var c = em.start();\n+            while (em.find()) {\n+                c = em.start();\n+            }\n+            em.find(c);\n+            var startEnd = sm.end();\n+            var endStart = em.start();\n+            if (startEnd <= endStart) {\n+                var mid = source.substring(startEnd, endStart);\n+                var count = mid.split(middleBetween).length + 2;\n+                parsed = new MessageFormat(createMessageFormatString(count), locale).parseObject(source, parsePos);\n+            }\n+        }\n+\n+        if (parsed == null) {\n+            \/\/ now try exact number patterns\n+            parsed = new MessageFormat(patterns[TWO], locale).parseObject(source, parsePos);\n+            if (parsed == null) {\n+                parsed = new MessageFormat(patterns[THREE], locale).parseObject(source, parsePos);\n+            }\n+        }\n+\n+        \/\/ return the entire source from parsePos if still no match\n+        if (parsed == null) {\n+            parsed = new String[]{source.substring(parsePos.getIndex())};\n+            parsePos.setIndex(source.length());\n+        }\n+\n+        if (parsed instanceof Object[] objs) {\n+            parsePos.setErrorIndex(-1);\n+            return Arrays.asList(objs);\n+        } else {\n+            \/\/ MessageFormat.parseObject() failed\n+            return null;\n+        }\n+    }\n+\n+    @Override\n+    public AttributedCharacterIterator formatToCharacterIterator(Object arguments) {\n+        Objects.requireNonNull(arguments);\n+\n+        if (arguments instanceof List<?> objs) {\n+            var a = objs.toArray(new Object[0]);\n+            return generateMessageFormat(a).formatToCharacterIterator(a);\n+        } else if (arguments instanceof Object[] objs) {\n+            return generateMessageFormat(objs).formatToCharacterIterator(objs);\n+        } else {\n+            throw new IllegalArgumentException(\"The arguments should be a List<Object> or an Object[]\");\n+        }\n+    }\n+\n+    \/**\n+     * Checks if this {@code ListFormat} is equal to another {@code ListFormat}.\n+     * The comparison is based on the {@code Locale} and formatting patterns, given or\n+     * generated with {@code Locale}, {@code Type}, and {@code Style}.\n+     * @param obj the object to check, {@code null} returns {@code false}\n+     * @return {@code true} if this is equals to the other {@code ListFormat}\n+     *\/\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (this == obj) {\n+            return true;\n+        }\n+\n+        if (obj instanceof ListFormat other) {\n+            return locale.equals(other.locale) &&\n+                Arrays.equals(patterns, other.patterns);\n+        }\n+\n+        return false;\n+    }\n+\n+    \/**\n+     * {@inheritDoc}\n+     *\/\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(locale, Arrays.hashCode(patterns));\n+    }\n+\n+    \/**\n+     * {@inheritDoc}\n+     *\/\n+    @Override\n+    public String toString() {\n+        return\n+            \"\"\"\n+            ListFormat [locale: \"%s\", start: \"%s\", middle: \"%s\",  end: \"%s\", two: \"%s\", three: \"%s\"]\n+            \"\"\".formatted(locale.getDisplayName(), patterns[START], patterns[MIDDLE], patterns[END], patterns[TWO], patterns[THREE]);\n+    }\n+\n+    private MessageFormat generateMessageFormat(Object[] input) {\n+        var len = input.length;\n+        return switch (len) {\n+            case 0 -> throw new IllegalArgumentException(\"There should at least be one input string\");\n+            case 1 -> new MessageFormat(\"{0}\", locale);\n+            case 2, 3 -> new MessageFormat(patterns[len + 1], locale);\n+            default -> new MessageFormat(createMessageFormatString(len), locale);\n+        };\n+    }\n+\n+    private String createMessageFormatString(int count) {\n+        var sb = new StringBuilder(256).append(patterns[START]);\n+        IntStream.range(2, count - 1).forEach(i -> sb.append(middleBetween).append(\"{\").append(i).append(\"}\"));\n+        sb.append(patterns[END].replaceFirst(\"\\\\{0}\", \"\").replaceFirst(\"\\\\{1}\", \"\\\\{\" + (count - 1) + \"\\\\}\"));\n+        return sb.toString();\n+    }\n+\n+    @java.io.Serial\n+    private void readObject(ObjectInputStream stream)\n+            throws IOException, ClassNotFoundException {\n+        stream.defaultReadObject();\n+        try {\n+            init();\n+        } catch (IllegalArgumentException iae) {\n+            throw new IOException(\"Deserialization failed.\", iae);\n+        }\n+    }\n+\n+    \/**\n+     * A ListFormat type - {@link #STANDARD STANDARD}, {@link #OR OR}, and\n+     * {@link #UNIT UNIT}.\n+     * <p>\n+     * {@code Type} is an enum which represents the type for formatting\n+     * a list within a given {@code ListFormat} instance. It determines\n+     * the punctuation and the connecting words in the formatted text.\n+     *\n+     * @since 22\n+     *\/\n+    public enum Type {\n+\n+        \/**\n+         * The {@code STANDARD} ListFormat type. This is the default\n+         * type, which concatenates elements in \"and\" enumeration.\n+         *\/\n+        STANDARD,\n+\n+        \/**\n+         * The {@code OR} ListFormat type. This type concatenates\n+         * elements in \"or\" enumeration.\n+         *\/\n+        OR,\n+\n+        \/**\n+         * The {@code UNIT} ListFormat type. This type concatenates\n+         * elements, useful for enumerating units.\n+         *\/\n+        UNIT\n+    }\n+\n+    \/**\n+     * A ListFormat style - {@link #FULL FULL}, {@link #SHORT SHORT},\n+     * and {@link #NARROW NARROW}.\n+     * <p>\n+     * {@code Style} is an enum which represents the style for formatting\n+     * a list within a given {@code ListFormat} instance.\n+     *\n+     * @since 22\n+     *\/\n+    public enum Style {\n+\n+        \/**\n+         * The {@code FULL} ListFormat style. This is the default style, which typically is the\n+         * full description of the text and punctuation that appear between the list elements.\n+         * Suitable for elements, such as \"Monday\", \"Tuesday\", \"Wednesday\", etc.\n+         *\/\n+        FULL,\n+\n+        \/**\n+         * The {@code SHORT} ListFormat style. This style is typically an abbreviation\n+         * of the text and punctuation that appear between the list elements.\n+         * Suitable for elements, such as \"Mon\", \"Tue\", \"Wed\", etc.\n+         *\/\n+        SHORT,\n+\n+        \/**\n+         * The {@code NARROW} ListFormat style. This style is typically the shortest description\n+         * of the text and punctuation that appear between the list elements.\n+         * Suitable for elements, such as \"M\", \"T\", \"W\", etc.\n+         *\/\n+        NARROW\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/text\/ListFormat.java","additions":611,"deletions":0,"binary":false,"changes":611,"status":"added"},{"patch":"@@ -45,0 +45,1 @@\n+import java.text.ListFormat;\n@@ -101,0 +102,1 @@\n+    private static final String LIST_PATTERN = \"LP.\";\n@@ -834,0 +836,26 @@\n+    \/**\n+     * {@return the list patterns for the locale}\n+     *\n+     * @param type a {@link ListFormat.Type}\n+     * @param style a {@link ListFormat.Style}\n+     *\/\n+    public String[] getListPatterns(ListFormat.Type type, ListFormat.Style style) {\n+        String typeStr = type.toString().toLowerCase(Locale.ROOT);\n+        String styleStr = style.toString().toLowerCase(Locale.ROOT);\n+        String[] lpArray;\n+        String cacheKey = LIST_PATTERN + typeStr;\n+\n+        removeEmptyReferences();\n+        ResourceReference data = cache.get(cacheKey);\n+\n+        if (data == null || ((lpArray = (String[]) data.get()) == null)) {\n+            ResourceBundle rb = localeData.getDateFormatData(locale);\n+            lpArray = rb.getStringArray(\"ListPatterns_\" + typeStr + (style == ListFormat.Style.FULL ? \"\" : \"-\" + styleStr));\n+            if (lpArray == null) {\n+                cache.put(cacheKey, new ResourceReference(cacheKey, new String[5], referenceQueue));\n+            }\n+        }\n+\n+        return lpArray;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/util\/locale\/provider\/LocaleResources.java","additions":28,"deletions":0,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -0,0 +1,299 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8041488\n+ * @summary Tests for ListFormat class\n+ * @run junit TestListFormat\n+ *\/\n+\n+import java.text.DateFormat;\n+import java.text.FieldPosition;\n+import java.text.ListFormat;\n+import java.text.ParseException;\n+import java.text.ParsePosition;\n+import java.util.List;\n+import java.util.Locale;\n+\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import static org.junit.jupiter.api.Assertions.assertArrayEquals;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.params.provider.Arguments.arguments;\n+\n+public class TestListFormat {\n+    private static final List<String> SAMPLE1 = List.of(\"foo\");\n+    private static final List<String> SAMPLE2 = List.of(\"foo\", \"bar\");\n+    private static final List<String> SAMPLE3 = List.of(\"foo\", \"bar\", \"baz\");\n+    private static final List<String> SAMPLE4 = List.of(\"foo\", \"bar\", \"baz\", \"qux\");\n+    private static final String[] CUSTOM_PATTERNS_FULL = {\n+            \"sbef {0} sbet {1}\",\n+            \"{0} mid {1}\",\n+            \"{0} ebet {1} eaft\",\n+            \"twobef {0} two {1} twoaft\",\n+            \"threebef {0} three {1} three {2} threeaft\",\n+    };\n+    private static final String[] CUSTOM_PATTERNS_MINIMAL = {\n+            \"sbef {0} sbet {1}\",\n+            \"{0} mid {1}\",\n+            \"{0} ebet {1} eaft\",\n+            \"\",\n+            \"\",\n+    };\n+    private static final String[] CUSTOM_PATTERNS_IAE_START = {\n+            \"{0}\",\n+            \"{0} mid {1}\",\n+            \"{0} ebet {1} eaft\",\n+            \"\",\n+            \"\",\n+    };\n+    private static final String[] CUSTOM_PATTERNS_IAE_MIDDLE = {\n+            \"{0} sbet {1}\",\n+            \"{0} {1} {2}\",\n+            \"{0} ebet {1} eaft\",\n+            \"\",\n+            \"\",\n+    };\n+    private static final String[] CUSTOM_PATTERNS_IAE_END = {\n+            \"{0} sbet {1}\",\n+            \"{0} mid {1}\",\n+            \"error {0} ebet {1}\",\n+            \"\",\n+            \"\",\n+    };\n+    private static final String[] CUSTOM_PATTERNS_IAE_TWO = {\n+            \"sbef {0} sbet {1}\",\n+            \"{0} mid {1}\",\n+            \"{0} ebet {1} eaft\",\n+            \"{1}error{0}\",\n+            \"\",\n+    };\n+    private static final String[] CUSTOM_PATTERNS_IAE_THREE = {\n+            \"sbef {0} sbet {1}\",\n+            \"{0} mid {1}\",\n+            \"{0} ebet {1} eaft\",\n+            \"\",\n+            \"{0}error{1}\",\n+    };\n+    private static final String[] CUSTOM_PATTERNS_IAE_NULL = {\n+            null,\n+            null,\n+            null,\n+            null,\n+            null,\n+    };\n+\n+\n+    @Test\n+    void getAvailableLocales() {\n+        assertArrayEquals(DateFormat.getAvailableLocales(), ListFormat.getAvailableLocales());\n+    }\n+\n+    @Test\n+    void getInstance_noArg() {\n+        assertEquals(ListFormat.getInstance(), ListFormat.getInstance(Locale.getDefault(Locale.Category.FORMAT), ListFormat.Type.STANDARD, ListFormat.Style.FULL));\n+    }\n+\n+    static Arguments[] getInstance_1Arg() {\n+        return new Arguments[] {\n+                arguments(CUSTOM_PATTERNS_FULL, SAMPLE1, \"foo\"),\n+                arguments(CUSTOM_PATTERNS_FULL, SAMPLE2, \"twobef foo two bar twoaft\"),\n+                arguments(CUSTOM_PATTERNS_FULL, SAMPLE3, \"threebef foo three bar three baz threeaft\"),\n+                arguments(CUSTOM_PATTERNS_FULL, SAMPLE4, \"sbef foo sbet bar mid baz ebet qux eaft\"),\n+                arguments(CUSTOM_PATTERNS_MINIMAL, SAMPLE1, \"foo\"),\n+                arguments(CUSTOM_PATTERNS_MINIMAL, SAMPLE2, \"sbef foo ebet bar eaft\"),\n+                arguments(CUSTOM_PATTERNS_MINIMAL, SAMPLE3, \"sbef foo sbet bar ebet baz eaft\"),\n+                arguments(CUSTOM_PATTERNS_MINIMAL, SAMPLE4, \"sbef foo sbet bar mid baz ebet qux eaft\"),\n+        };\n+    }\n+\n+    static Arguments[] getInstance_1Arg_IAE() {\n+        return new Arguments[] {\n+                arguments(new String[1], \"Pattern array length should be 5\"),\n+                arguments(new String[6], \"Pattern array length should be 5\"),\n+                arguments(CUSTOM_PATTERNS_IAE_START, \"start pattern is incorrect: {0}\"),\n+                arguments(CUSTOM_PATTERNS_IAE_MIDDLE, \"middle pattern is incorrect: {0} {1} {2}\"),\n+                arguments(CUSTOM_PATTERNS_IAE_END, \"end pattern is incorrect: error {0} ebet {1}\"),\n+                arguments(CUSTOM_PATTERNS_IAE_TWO, \"pattern for two is incorrect: {1}error{0}\"),\n+                arguments(CUSTOM_PATTERNS_IAE_THREE, \"pattern for three is incorrect: {0}error{1}\"),\n+                arguments(CUSTOM_PATTERNS_IAE_NULL, \"patterns array contains one or more null elements\"),\n+        };\n+    }\n+\n+    static Arguments[] getInstance_3Arg() {\n+        return new Arguments[] {\n+                arguments(Locale.US, ListFormat.Type.STANDARD, ListFormat.Style.FULL,\n+                        \"foo, bar, and baz\", true),\n+                arguments(Locale.US, ListFormat.Type.OR, ListFormat.Style.FULL,\n+                        \"foo, bar, or baz\", true),\n+                arguments(Locale.US, ListFormat.Type.UNIT, ListFormat.Style.FULL,\n+                        \"foo, bar, baz\", true),\n+                arguments(Locale.US, ListFormat.Type.STANDARD, ListFormat.Style.SHORT,\n+                        \"foo, bar, & baz\", true),\n+                arguments(Locale.US, ListFormat.Type.OR, ListFormat.Style.SHORT,\n+                        \"foo, bar, or baz\", true),\n+                arguments(Locale.US, ListFormat.Type.UNIT, ListFormat.Style.SHORT,\n+                        \"foo, bar, baz\", true),\n+                arguments(Locale.US, ListFormat.Type.STANDARD, ListFormat.Style.NARROW,\n+                        \"foo, bar, baz\", true),\n+                arguments(Locale.US, ListFormat.Type.OR, ListFormat.Style.NARROW,\n+                        \"foo, bar, or baz\", true),\n+                arguments(Locale.US, ListFormat.Type.UNIT, ListFormat.Style.NARROW,\n+                        \"foo bar baz\", true),\n+\n+                arguments(Locale.JAPAN, ListFormat.Type.STANDARD, ListFormat.Style.FULL,\n+                        \"foo\\u3001bar\\u3001baz\", true),\n+                arguments(Locale.JAPAN, ListFormat.Type.OR, ListFormat.Style.FULL,\n+                        \"foo\\u3001bar\\u3001\\u307e\\u305f\\u306fbaz\", true),\n+                arguments(Locale.JAPAN, ListFormat.Type.UNIT, ListFormat.Style.FULL,\n+                        \"foo bar baz\", true),\n+                arguments(Locale.JAPAN, ListFormat.Type.STANDARD, ListFormat.Style.SHORT,\n+                        \"foo\\u3001bar\\u3001baz\", true),\n+                arguments(Locale.JAPAN, ListFormat.Type.OR, ListFormat.Style.SHORT,\n+                        \"foo\\u3001bar\\u3001\\u307e\\u305f\\u306fbaz\", true),\n+                arguments(Locale.JAPAN, ListFormat.Type.UNIT, ListFormat.Style.SHORT,\n+                        \"foo bar baz\", true),\n+                arguments(Locale.JAPAN, ListFormat.Type.STANDARD, ListFormat.Style.NARROW,\n+                        \"foo\\u3001bar\\u3001baz\", true),\n+                arguments(Locale.JAPAN, ListFormat.Type.OR, ListFormat.Style.NARROW,\n+                        \"foo\\u3001bar\\u3001\\u307e\\u305f\\u306fbaz\", true),\n+                arguments(Locale.JAPAN, ListFormat.Type.UNIT, ListFormat.Style.NARROW,\n+                        \"foobarbaz\", false), \/\/ no delimiter, impossible to parse\/roundtrip\n+        };\n+    }\n+\n+    static Arguments[] parseObject_parsePos() {\n+        return new Arguments[] {\n+                arguments(CUSTOM_PATTERNS_FULL, SAMPLE1),\n+                arguments(CUSTOM_PATTERNS_FULL, SAMPLE2),\n+                arguments(CUSTOM_PATTERNS_FULL, SAMPLE3),\n+                arguments(CUSTOM_PATTERNS_FULL, SAMPLE4),\n+                arguments(CUSTOM_PATTERNS_MINIMAL, SAMPLE1),\n+                arguments(CUSTOM_PATTERNS_MINIMAL, SAMPLE2),\n+                arguments(CUSTOM_PATTERNS_MINIMAL, SAMPLE3),\n+                arguments(CUSTOM_PATTERNS_MINIMAL, SAMPLE4),\n+        };\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource\n+    void getInstance_1Arg(String[] patterns, List<String> input, String expected) throws ParseException {\n+        var f = ListFormat.getInstance(patterns);\n+        compareResult(f, input, expected, true);\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource\n+    void getInstance_1Arg_IAE(String[] invalidPatterns, String errorMsg) {\n+        var ex = assertThrows(IllegalArgumentException.class,\n+                () -> ListFormat.getInstance(invalidPatterns));\n+        assertEquals(errorMsg, ex.getMessage());\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource\n+    void getInstance_3Arg(Locale l, ListFormat.Type type, ListFormat.Style style, String expected, boolean roundTrip) throws ParseException {\n+        var f = ListFormat.getInstance(l, type, style);\n+        compareResult(f, SAMPLE3, expected, roundTrip);\n+    }\n+\n+    @Test\n+    void format_3Arg() {\n+        var f = ListFormat.getInstance();\n+        \/\/ Ensures it accepts both List and []\n+        assertEquals(f.format(SAMPLE4, new StringBuffer(), null).toString(),\n+                f.format(SAMPLE4.toArray(), new StringBuffer(), null).toString());\n+\n+        \/\/ Tests NPE\n+        assertThrows(NullPointerException.class,\n+                () -> f.format(null, new StringBuffer(), new FieldPosition(0)));\n+        assertThrows(NullPointerException.class,\n+                () -> f.format(new Object(), null, new FieldPosition(0)));\n+\n+        \/\/ Tests IAE\n+        var ex = assertThrows(IllegalArgumentException.class,\n+                () -> f.format(new Object(), new StringBuffer(), null));\n+        assertEquals(\"The object to format should be a List<Object> or an Object[]\", ex.getMessage());\n+    }\n+\n+    @Test\n+    void formatToCharacterIterator() {\n+        var f = ListFormat.getInstance();\n+        \/\/ Ensures it accepts both List and []\n+        assertEquals(f.formatToCharacterIterator(SAMPLE4).toString(),\n+                f.formatToCharacterIterator(SAMPLE4.toArray()).toString());\n+\n+        \/\/ Tests NPE\n+        assertThrows(NullPointerException.class,\n+                () -> f.formatToCharacterIterator(null));\n+\n+        \/\/ Tests IAE\n+        var ex = assertThrows(IllegalArgumentException.class,\n+                () -> f.formatToCharacterIterator(new Object()));\n+        assertEquals(\"The arguments should be a List<Object> or an Object[]\", ex.getMessage());\n+    }\n+\n+    @Test\n+    void format_emptyInput() {\n+        var ex = assertThrows(IllegalArgumentException.class,\n+                () -> ListFormat.getInstance().format(List.of()));\n+        assertEquals(\"There should at least be one input string\", ex.getMessage());\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource\n+    void parseObject_parsePos(String[] patterns, List<String> input) {\n+        var prefix = \"prefix\";\n+        var f = ListFormat.getInstance(patterns);\n+        var testStr = prefix + f.format(input);\n+\n+        var pp = new ParsePosition(prefix.length());\n+        var parsed = f.parseObject(testStr, pp);\n+        assertEquals(input, parsed, pp.toString());\n+        assertEquals(new ParsePosition(testStr.length()), pp);\n+\n+        pp.setIndex(0);\n+        parsed = f.parseObject(testStr, pp);\n+        assertNotEquals(input, parsed);\n+        assertEquals(-1, pp.getErrorIndex());\n+\n+        pp.setIndex(prefix.length() + 1);\n+        parsed = f.parseObject(testStr, pp);\n+        assertNotEquals(input, parsed);\n+        assertEquals(-1, pp.getErrorIndex());\n+    }\n+\n+    private static void compareResult(ListFormat f, List<String> input, String expected, boolean roundTrip) throws ParseException {\n+        var result = f.format(input);\n+        assertEquals(expected, result);\n+        if (roundTrip) {\n+            assertEquals(input, f.parse(result));\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/text\/Format\/ListFormat\/TestListFormat.java","additions":299,"deletions":0,"binary":false,"changes":299,"status":"added"}]}