{"files":[{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2016, 2021 SAP SE. All rights reserved.\n+ * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2019 SAP SE. All rights reserved.\n@@ -36,1 +36,0 @@\n-#include \"memory\/metaspace.hpp\"\n@@ -3607,0 +3606,1 @@\n+  bool     need_zero_extend = false;\n@@ -3623,20 +3623,8 @@\n-  \/\/ Do Klass pointers always fit into 32bit?\n-  const MetaWord* ccs_end = Metaspace::class_space_end();\n-  assert(ccs_end != NULL, \"Sanity\");\n-  const bool klass_pointers_are_32_bit = ((uintptr_t)ccs_end <= 0xFFFFFFFF);\n-\n-#ifdef ASSERT\n-  if (klass_pointers_are_32_bit) {\n-    \/\/ Assert that Klass pointers are < 32bit\n-    Label ok2;\n-    z_tmhl(current, 0xFFFF);\n-    z_brc(Assembler::bcondAllZero, ok2);\n-    z_illtrap(0xee);\n-    z_illtrap(0xee);\n-    bind(ok2);\n-    Label ok3;\n-    z_tmhh(current, 0xFFFF);\n-    z_brc(Assembler::bcondAllZero, ok3);\n-    z_illtrap(0xee);\n-    z_illtrap(0xee);\n-    bind(ok3);\n+  \/\/ Scale down the incoming klass pointer first.\n+  \/\/ We then can be sure we calculate an offset that fits into 32 bit.\n+  \/\/ More generally speaking: all subsequent calculations are purely 32-bit.\n+  if (shift != 0) {\n+    assert (LogKlassAlignmentInBytes == shift, \"decode alg wrong\");\n+    z_srlg(dst, current, shift);\n+    need_zero_extend = true;\n+    current = dst;\n@@ -3644,1 +3632,0 @@\n-#endif\n@@ -3647,8 +3634,25 @@\n-    unsigned int base_h = ((unsigned long)base)>>32;\n-    unsigned int base_l = (unsigned int)((unsigned long)base);\n-    if ((base_h != 0) && (base_l == 0) && VM_Version::has_HighWordInstr()) {\n-      lgr_if_needed(dst, current);\n-      z_aih(dst, -((int)base_h));     \/\/ Base has no set bits in lower half.\n-    } else if ((base_h == 0) && (base_l != 0) && klass_pointers_are_32_bit) {\n-      lgr_if_needed(dst, current);\n-      z_afi(dst, -(int)base_l); \/\/ Note: 32bit add\n+    \/\/ Use scaled-down base address parts to match scaled-down klass pointer.\n+    unsigned int base_h = ((unsigned long)base)>>(32+shift);\n+    unsigned int base_l = (unsigned int)(((unsigned long)base)>>shift);\n+\n+    \/\/ General considerations:\n+    \/\/  - when calculating (current_h - base_h), all digits must cancel (become 0).\n+    \/\/    Otherwise, we would end up with a compressed klass pointer which doesn't\n+    \/\/    fit into 32-bit.\n+    \/\/  - Only bit#33 of the difference could potentially be non-zero. For that\n+    \/\/    to happen, (current_l < base_l) must hold. In this case, the subtraction\n+    \/\/    will create a borrow out of bit#32, nicely killing bit#33.\n+    \/\/  - With the above, we only need to consider current_l and base_l to\n+    \/\/    calculate the result.\n+    \/\/  - Both values are treated as unsigned. The unsigned subtraction is\n+    \/\/    replaced by adding (unsigned) the 2's complement of the subtrahend.\n+\n+    if (base_l == 0) {\n+      \/\/  - By theory, the calculation to be performed here (current_h - base_h) MUST\n+      \/\/    cancel all high-word bits. Otherwise, we would end up with an offset\n+      \/\/    (i.e. compressed klass pointer) that does not fit into 32 bit.\n+      \/\/  - current_l remains unchanged.\n+      \/\/  - Therefore, we can replace all calculation with just a\n+      \/\/    zero-extending load 32 to 64 bit.\n+      \/\/  - Even that can be replaced with a conditional load if dst != current.\n+      \/\/    (this is a local view. The shift step may have requested zero-extension).\n@@ -3656,3 +3660,11 @@\n-      load_const(Z_R0, base);\n-      lgr_if_needed(dst, current);\n-      z_sgr(dst, Z_R0);\n+      \/\/ To begin with, we may need to copy and\/or zero-extend the register operand.\n+      \/\/ We have to calculate (current_l - base_l). Because there is no unsigend\n+      \/\/ subtract instruction with immediate operand, we add the 2's complement of base_l.\n+      if (need_zero_extend) {\n+        z_llgfr(dst, current);\n+        need_zero_extend = false;\n+      } else {\n+        llgfr_if_needed(dst, current); \/\/ zero-extension while copying comes at no extra cost.\n+      }\n+      current = dst;\n+      z_alfi(dst, -(int)base_l);\n@@ -3660,6 +3672,8 @@\n-    current = dst;\n-  }\n-  if (shift != 0) {\n-    assert (LogKlassAlignmentInBytes == shift, \"decode alg wrong\");\n-    z_srlg(dst, current, shift);\n-    current = dst;\n+  } \/\/ base nonzero\n+\n+  if (need_zero_extend) {\n+    \/\/ We must zero-extend the calculated result. It may have some leftover bits in\n+    \/\/ the hi-word because we only did optimized calculations.\n+    z_llgfr(dst, current);\n+  } else {\n+    llgfr_if_needed(dst, current); \/\/ zero-extension while copying comes at no extra cost.\n@@ -3667,1 +3681,0 @@\n-  lgr_if_needed(dst, current); \/\/ Move may be required (if neither base nor shift != 0).\n","filename":"src\/hotspot\/cpu\/s390\/macroAssembler_s390.cpp","additions":55,"deletions":42,"binary":false,"changes":97,"status":"modified"},{"patch":"@@ -3,1 +3,0 @@\n- * Copyright (c) 2017, 2021 SAP SE. All rights reserved.\n@@ -503,9 +502,0 @@\n-\/\/ Returns one-past the highest possible class space location, NULL if no class space exists.\n-const MetaWord* Metaspace::class_space_end() {\n-  if (VirtualSpaceList::vslist_class() != NULL) {\n-    return VirtualSpaceList::vslist_class()->base_of_first_node() +\n-           VirtualSpaceList::vslist_class()->word_size_of_first_node();\n-  }\n-  return NULL;\n-}\n-\n","filename":"src\/hotspot\/share\/memory\/metaspace.cpp","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,2 +2,1 @@\n- * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2017, 2021 SAP SE. All rights reserved.\n+ * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -142,2 +141,0 @@\n-  \/\/ Returns one-past the highest possible class space location, NULL if no class space exists.\n-  static const MetaWord* class_space_end();\n","filename":"src\/hotspot\/share\/memory\/metaspace.hpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"}]}