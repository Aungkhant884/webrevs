{"files":[{"patch":"@@ -3606,0 +3606,1 @@\n+  bool     need_zero_extend = false;\n@@ -3622,16 +3623,3 @@\n-  if (base != NULL) {\n-    unsigned int base_h = ((unsigned long)base)>>32;\n-    unsigned int base_l = (unsigned int)((unsigned long)base);\n-    if ((base_h != 0) && (base_l == 0) && VM_Version::has_HighWordInstr()) {\n-      lgr_if_needed(dst, current);\n-      z_aih(dst, -((int)base_h));     \/\/ Base has no set bits in lower half.\n-    } else if ((base_h == 0) && (base_l != 0)) {\n-      lgr_if_needed(dst, current);\n-      z_agfi(dst, -(int)base_l);\n-    } else {\n-      load_const(Z_R0, base);\n-      lgr_if_needed(dst, current);\n-      z_sgr(dst, Z_R0);\n-    }\n-    current = dst;\n-  }\n+  \/\/ Scale down the incoming klass pointer first.\n+  \/\/ We then can be sure we calculate an offset that fits into 32 bit.\n+  \/\/ More generally speaking: all subsequent calculations are purely 32-bit.\n@@ -3641,0 +3629,1 @@\n+    need_zero_extend = true;\n@@ -3643,1 +3632,49 @@\n-  lgr_if_needed(dst, current); \/\/ Move may be required (if neither base nor shift != 0).\n+\n+  if (base != NULL) {\n+    \/\/ Use scaled-down base address parts to match scaled-down klass pointer.\n+    unsigned int base_h = ((unsigned long)base)>>(32+shift);\n+    unsigned int base_l = (unsigned int)(((unsigned long)base)>>shift);\n+\n+    \/\/ General considerations:\n+    \/\/  - when calculating (current_h - base_h), all digits must cancel (become 0).\n+    \/\/    Otherwise, we would end up with a compressed klass pointer which doesn't\n+    \/\/    fit into 32-bit.\n+    \/\/  - Only bit#33 of the difference could potentially be non-zero. For that\n+    \/\/    to happen, (current_l < base_l) must hold. In this case, the subtraction\n+    \/\/    will create a borrow out of bit#32, nicely killing bit#33.\n+    \/\/  - With the above, we only need to consider current_l and base_l to\n+    \/\/    calculate the result.\n+    \/\/  - Both values are treated as unsigned. The unsigned subtraction is\n+    \/\/    replaced by adding (unsigned) the 2's complement of the subtrahend.\n+\n+    if (base_l == 0) {\n+      \/\/  - By theory, the calculation to be performed here (current_h - base_h) MUST\n+      \/\/    cancel all high-word bits. Otherwise, we would end up with an offset\n+      \/\/    (i.e. compressed klass pointer) that does not fit into 32 bit.\n+      \/\/  - current_l remains unchanged.\n+      \/\/  - Therefore, we can replace all calculation with just a\n+      \/\/    zero-extending load 32 to 64 bit.\n+      \/\/  - Even that can be replaced with a conditional load if dst != current.\n+      \/\/    (this is a local view. The shift step may have requested zero-extension).\n+    } else {\n+      \/\/ To begin with, we may need to copy and\/or zero-extend the register operand.\n+      \/\/ We have to calculate (current_l - base_l). Because there is no unsigend\n+      \/\/ subtract instruction with immediate operand, we add the 2's complement of base_l.\n+      if (need_zero_extend) {\n+        z_llgfr(dst, current);\n+        need_zero_extend = false;\n+      } else {\n+        llgfr_if_needed(dst, current); \/\/ zero-extension while copying comes at no extra cost.\n+      }\n+      current = dst;\n+      z_alfi(dst, -(int)base_l);\n+    }\n+  } \/\/ base nonzero\n+\n+  if (need_zero_extend) {\n+    \/\/ We must zero-extend the calculated result. It may have some leftover bits in\n+    \/\/ the hi-word because we only did optimized calculations.\n+    z_llgfr(dst, current);\n+  } else {\n+    llgfr_if_needed(dst, current); \/\/ zero-extension while copying comes at no extra cost.\n+  }\n","filename":"src\/hotspot\/cpu\/s390\/macroAssembler_s390.cpp","additions":54,"deletions":17,"binary":false,"changes":71,"status":"modified"}]}