{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1995, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1995, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+import jdk.internal.util.StaticProperty;\n+\n@@ -30,0 +32,2 @@\n+import java.nio.charset.Charset;\n+import java.nio.charset.UnsupportedCharsetException;\n@@ -60,0 +64,4 @@\n+ * The I\/O streams of characters and lines can be written and read using the methods\n+ * {@link #outputWriter(boolean)}, {@link #outputWriter(boolean, Charset)}},\n+ * {@link #inputReader()}, {@link #inputReader(Charset)},\n+ * {@link #errorReader()}, and {@link #errorReader(Charset)}.\n@@ -164,0 +172,154 @@\n+    \/**\n+     * Returns a {@link BufferedReader BufferedReader} connected to the standard output of the process.\n+     * The {@code BufferedReader} can be used to read characters, lines, or stream lines of the standard output.\n+     * The reader decodes the standard output of this process using the\n+     * {@link Charset} named by the {@systemProperty native.encoding} system property.\n+     * If the {@code Charset} is not supported, the {@link Charset#defaultCharset()} is used.\n+     *\n+     * @return a {@link BufferedReader BufferedReader} using the {@code native.encoding} if supported,\n+     *          otherwise, the {@link Charset#defaultCharset()}\n+     *\/\n+    public BufferedReader inputReader() {\n+        return new BufferedReader(new InputStreamReader(getInputStream(), CharsetHolder.nativeCharset()));\n+    }\n+\n+    \/**\n+     * Returns a {@link BufferedReader BufferedReader} connected to the standard output\n+     * of the process using a Charset.\n+     * The {@code BufferedReader} can be used to read characters, lines, or stream lines of the standard output.\n+     * The reader decodes the standard output of this process using the {@code charset}.\n+     *\n+     * <p>If the standard output of the process has been redirected using\n+     * {@link ProcessBuilder#redirectOutput(Redirect) ProcessBuilder.redirectOutput}\n+     * then this method will return a\n+     * <a href=\"ProcessBuilder.html#redirect-output\">null input reader<\/a>.\n+     *\n+     * <p>Otherwise, if the standard error of the process has been redirected using\n+     * {@link ProcessBuilder#redirectErrorStream(boolean) ProcessBuilder.redirectErrorStream}\n+     * then the input stream returned by this method will receive the\n+     * merged standard output and the standard error of the process.\n+     *\n+     * @apiNote\n+     * Using both {@link #getInputStream} and {@link #inputReader} has unpredictable behavior\n+     * since the buffered reader reads ahead from the input stream.\n+     *\n+     * @implNote\n+     * This is equivalent to:\n+     * {@code\n+     *     return new BufferedReader(new InputStreamReader(getInputStream(), charset));\n+     * }\n+     *\n+     * @param charset the {@code Charset} used to convert bytes to characters, not null\n+     * @return a BufferedReader for the standard output of the process using the {@code charset}\n+     *\/\n+    public BufferedReader inputReader(Charset charset) {\n+        return new BufferedReader(new InputStreamReader(getInputStream(), charset));\n+    }\n+\n+    \/**\n+     * Returns a {@link BufferedReader BufferedReader} connected to the standard error of the process.\n+     * The {@code BufferedReader} can be used to read characters, lines, or stream lines of the error output.\n+     * The reader decodes the standard error of this process using the\n+     * {@link Charset} named by the {@systemProperty native.encoding} system property.\n+     * If the {@code Charset} is not supported, the {@link Charset#defaultCharset()} is used.\n+     *\n+     * @return a {@link BufferedReader BufferedReader} using the {@code native.encoding} if supported,\n+     *          otherwise, the {@link Charset#defaultCharset()}\n+     *\/\n+    public BufferedReader errorReader() {\n+        return new BufferedReader(new InputStreamReader(getErrorStream(), CharsetHolder.nativeCharset()));\n+    }\n+\n+    \/**\n+     * Returns a {@link BufferedReader BufferedReader} connected to the standard error of the process using a Charset.\n+     * The {@code BufferedReader} can be used to read characters, lines, or stream lines of the error output.\n+     * The reader decodes the standard error of this process using the {@code charset}.\n+     *\n+     * <p>If the standard error of the process has been redirected using\n+     * {@link ProcessBuilder#redirectError(Redirect) ProcessBuilder.redirectError} or\n+     * {@link ProcessBuilder#redirectErrorStream(boolean) ProcessBuilder.redirectErrorStream}\n+     * then this method will return a\n+     * <a href=\"ProcessBuilder.html#redirect-output\">null input reader<\/a>.\n+     *\n+     * @apiNote\n+     * Using both {@link #getErrorStream} and {@link #errorReader} has unpredictable behavior\n+     * since the buffered reader reads ahead from the input stream.\n+     *\n+     * @implNote\n+     * This is equivalent to:\n+     * {@code\n+     *     return new BufferedReader(new InputStreamReader(getErrorStream(), charset));\n+     * }\n+     *\n+     * @param charset the {@code Charset} used to convert bytes to characters, not null\n+     * @return a BufferedReader for the standard error of the process using the {@code charset}\n+     *\/\n+    public BufferedReader errorReader(Charset charset) {\n+        return new BufferedReader(new InputStreamReader(getErrorStream(), charset));\n+    }\n+\n+    \/**\n+     * Returns a {@code BufferedWriter} connected to the normal input of the process the native encoding.\n+     * Writes text to a character-output stream, buffering characters so as to provide\n+     * for the efficient writing of single characters, arrays, and strings.\n+     *\n+     * <p>Characters written encoded to bytes using {@link OutputStreamWriter}\n+     * and the {@link Charset} named by the {@systemProperty native.encoding} system property\n+     * piped into the standard input of the process represented by this {@code Process} object.\n+     * If the {@code Charset} is not supported, the {@link Charset#defaultCharset()} is used.\n+     * Call the {@link BufferedWriter#flush()} method to flush buffered output to the process.\n+     *\n+     * <p>If the standard input of the process has been redirected using\n+     * {@link ProcessBuilder#redirectInput(Redirect)\n+     * ProcessBuilder.redirectInput} then this method will return a\n+     * <a href=\"ProcessBuilder.html#redirect-input\">null output writer<\/a>.\n+     *\n+     * @apiNote\n+     * A {@linkplain BufferedWriter} writes characters, arrays of characters, and strings.\n+     * Wrapping the {@link BufferedWriter} with a {@link PrintWriter} provides\n+     * efficient buffering and formatting of primitives and objects as well as support\n+     * for auto-flush on line endings.\n+     * <p>\n+     * Use {@link #getOutputStream} and {@link #outputWriter} with extreme care.\n+     * Output to the BufferedWriter may be held in the buffer until\n+     * {@linkplain BufferedWriter#flush flush} is called.\n+     *\n+     * @return a BufferedWriter to the standard input of the process using the charset\n+     *          for the {@code native.encoding} system property\n+     *\/\n+    public BufferedWriter outputWriter() {\n+        return outputWriter(CharsetHolder.nativeCharset());\n+    }\n+\n+    \/**\n+     * Returns a {@code BufferedWriter} connected to the normal input of the process using a Charset.\n+     * Writes text to a character-output stream, buffering characters so as to provide\n+     * for the efficient writing of single characters, arrays, and strings.\n+     *\n+     * <p>Characters written by the writer are encoded to bytes using {@link OutputStreamWriter}\n+     * and the {@link Charset}\n+     * piped into the standard input of the process represented by this {@code Process} object.\n+     * Call the {@link BufferedWriter#flush()} method to flush buffered output to the process.\n+     *\n+     * <p>If the standard input of the process has been redirected using\n+     * {@link ProcessBuilder#redirectInput(Redirect)\n+     * ProcessBuilder.redirectInput} then this method will return a\n+     * <a href=\"ProcessBuilder.html#redirect-input\">null output writer<\/a>.\n+     *\n+     * @apiNote\n+     * A {@linkplain BufferedWriter} writes characters, arrays of characters, and strings.\n+     * Wrapping the {@link BufferedWriter} with a {@link PrintWriter} provides\n+     * efficient buffering and formatting of primitives and objects as well as support\n+     * for auto-flush on line endings.\n+     * <p>\n+     * Use {@link #getOutputStream} and {@link #outputWriter} with extreme care.\n+     * Output to the BufferedWriter may be held in the buffer until\n+     * {@linkplain BufferedWriter#flush flush} is called.\n+     *\n+     * @param charset the {@code Charset} to encode characters to bytes\n+     * @return a BufferedWriter to the standard input of the process using the {@code charset}\n+     *\/\n+    public BufferedWriter outputWriter(Charset charset) {\n+        return new BufferedWriter(new OutputStreamWriter(getOutputStream(), charset));\n+    }\n+\n@@ -264,1 +426,1 @@\n-     * {@link ProcessBuilder#start} and {@link Runtime#exec} forcibly terminate\n+     * {@link ProcessBuilder#start()} and {@link Runtime#exec} forcibly terminate\n@@ -295,1 +457,1 @@\n-     * {@link ProcessBuilder#start} and {@link Runtime#exec} return\n+     * {@link ProcessBuilder#start()} and {@link Runtime#exec} return\n@@ -374,1 +536,1 @@\n-     * Processes returned from {@link ProcessBuilder#start} override the\n+     * Processes returned from {@link ProcessBuilder#start()} override the\n@@ -466,1 +628,1 @@\n-     * {@code Process} objects returned by {@link ProcessBuilder#start} and\n+     * {@code Process} objects returned by {@link ProcessBuilder#start()} and\n@@ -592,0 +754,23 @@\n+\n+    \/**\n+     * A nested class to delay looking up the Charset for the native encoding.\n+     *\/\n+    private static class CharsetHolder {\n+        private final static Charset nativeCharset;\n+        static {\n+            Charset cs;\n+            try {\n+                cs = Charset.forName(StaticProperty.nativeEncoding());\n+            } catch (UnsupportedCharsetException uce) {\n+                cs = Charset.defaultCharset();\n+            }\n+            nativeCharset = cs;\n+        }\n+\n+        \/**\n+         * {@return Charset for the native encoding or {@link Charset#defaultCharset()}\n+         *\/\n+        static Charset nativeCharset() {\n+            return nativeCharset;\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Process.java","additions":190,"deletions":5,"binary":false,"changes":195,"status":"modified"},{"patch":"@@ -55,2 +55,2 @@\n- * @run testng\/othervm  SerialFilterTest\n- * @run testng\/othervm  -Djdk.serialSetFilterAfterRead=true SerialFilterTest\n+ * @run testng\/othervm  -Djdk.serialFilterTrace SerialFilterTest\n+ * @run testng\/othervm  -Djdk.serialSetFilterAfterRead=true -Djdk.serialFilterTrace SerialFilterTest\n","filename":"test\/jdk\/java\/io\/Serializable\/serialFilter\/SerialFilterTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,232 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import static org.testng.Assert.*;\n+\n+import org.testng.Assert;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import jdk.test.lib.process.ProcessTools;\n+\n+import jdk.test.lib.hexdump.HexPrinter;\n+import jdk.test.lib.hexdump.HexPrinter.Formatters;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.Writer;\n+import java.nio.ByteBuffer;\n+import java.nio.charset.Charset;\n+import java.nio.charset.UnsupportedCharsetException;\n+import java.util.List;\n+import java.util.Locale;\n+\n+import jtreg.SkippedException;\n+\n+\/*\n+ * @test\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.process.ProcessTools jdk.test.lib.hexdump.HexPrinter\n+ * @run testng ReaderWriterTest\n+ *\/\n+\n+@Test\n+public class ReaderWriterTest {\n+\n+    static final String ASCII = \"ASCII: \\u0000_A-Z_a-Z_\\u007C_\\u007D_\\u007E_\\u007F_;\";\n+    static final String ISO_8859_1 = \" Symbols: \\u00AB_\\u00BB_\\u00fc_\\u00fd_\\u00fe_\\u00ff;\";\n+    static final String FRACTIONS = \" Fractions: \\u00bc_\\u00bd_\\u00be_\\u00bf;\";\n+\n+    public static final String TESTCHARS = \"OneWay: \" + ASCII + ISO_8859_1 + FRACTIONS;\n+    public static final String ROUND_TRIP_TESTCHARS = \"RoundTrip: \" + ASCII + ISO_8859_1 + FRACTIONS;\n+\n+    @DataProvider(name=\"CharsetCases\")\n+    static Object[][] charsetCases() {\n+        return new Object[][] {\n+                {\"UTF-8\"},\n+                {\"ISO8859-1\"},\n+                {\"US-ASCII\"},\n+        };\n+    }\n+\n+    \/**\n+     * Test the defaults case of native.encoding.  No extra command line flags or switches.\n+     *\/\n+    @Test\n+    void testCaseNativeEncoding() throws IOException {\n+        String nativeEncoding = System.getProperty(\"native.encoding\");\n+        Charset cs = Charset.forName(nativeEncoding);\n+        System.out.println(\"Native.encoding Charset: \" + cs);\n+\n+        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(\"ReaderWriterTest$ChildWithCharset\");\n+        Process p = pb.start();\n+        writeTestChars(p.outputWriter());\n+        checkReader(p.inputReader(), cs, \"Out\");\n+        checkReader(p.errorReader(), cs, \"Err\");\n+        try {\n+            int exitValue = p.waitFor();\n+            if (exitValue != 0)\n+                System.out.println(\"exitValue: \" + exitValue);\n+        } catch (InterruptedException ie) {\n+            Assert.fail(\"waitFor interrupted\");\n+        }\n+    }\n+\n+    \/**\n+     * Write the test characters to the child using the Process.outputWriter.\n+     * @param writer the Writer\n+     * @throws IOException if an I\/O error occurs\n+     *\/\n+    private static void writeTestChars(Writer writer) throws IOException {\n+        \/\/ Write the test data to the child\n+        try (writer) {\n+            writer.append(ROUND_TRIP_TESTCHARS);\n+            writer.append(System.lineSeparator());\n+        }\n+    }\n+\n+    \/**\n+     * Test a child with a character set.\n+     * A Process is spawned; characters are written to and read from the child\n+     * using the character set and compared.\n+     *\n+     * @param nativeEncoding a charset name\n+     *\/\n+    @Test(dataProvider = \"CharsetCases\", enabled = true)\n+    void testCase(String nativeEncoding) throws IOException {\n+        Charset cs = null;\n+        try {\n+            cs = Charset.forName(nativeEncoding);\n+            System.out.println(\"Charset: \" + cs);\n+        } catch (UnsupportedCharsetException use) {\n+            throw new SkippedException(\"Charset not supported: \" + nativeEncoding);\n+        }\n+        String cleanCSName = cleanCharsetName(cs);\n+\n+        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(\n+                \"-Dsun.stdout.encoding=\" + cleanCSName,     \/\/ Encode in the child using the charset\n+                \"-Dsun.stderr.encoding=\" + cleanCSName,\n+                \"ReaderWriterTest$ChildWithCharset\");\n+\n+        Process p = pb.start();\n+        \/\/ Write the test data to the child\n+        writeTestChars(p.outputWriter(cs));\n+        checkReader(p.inputReader(cs), cs, \"Out\");\n+        checkReader(p.errorReader(cs), cs, \"Err\");\n+        try {\n+            int exitValue = p.waitFor();\n+            if (exitValue != 0)\n+                System.out.println(\"exitValue: \" + exitValue);\n+        } catch (InterruptedException ie) {\n+\n+        }\n+    }\n+\n+    private static void checkReader(BufferedReader reader, Charset cs, String label) throws IOException {\n+        try (BufferedReader in = reader) {\n+            String prefix = \"    \" + label + \": \";\n+            String firstline = in.readLine();\n+            System.out.append(prefix).println(firstline);\n+            String secondline = in.readLine();\n+            System.out.append(prefix).println(secondline);\n+            for (String line = in.readLine(); line != null; line = in.readLine()) {\n+                System.out.append(prefix).append(line);\n+                System.out.println();\n+            }\n+            ByteBuffer bb = cs.encode(TESTCHARS);\n+            String reencoded = cs.decode(bb).toString();\n+            if (!firstline.equals(reencoded))\n+                diffStrings(firstline, reencoded);\n+            assertEquals(firstline, reencoded, label + \" Test Chars\");\n+\n+            bb = cs.encode(ROUND_TRIP_TESTCHARS);\n+            reencoded = cs.decode(bb).toString();\n+            if (!secondline.equals(reencoded))\n+                diffStrings(secondline, reencoded);\n+            assertEquals(secondline, reencoded, label + \" Round Trip Test Chars\");\n+        }\n+    }\n+\n+    \/**\n+     * A cleaned up Charset name that is suitable for Linux LANG environment variable.\n+     * If there are two '-'s the first one is removed.\n+     * @param cs a Charset\n+     * @return the cleanedup Charset name\n+     *\/\n+    private static String cleanCharsetName(Charset cs) {\n+        String name = cs.name();\n+        int ndx = name.indexOf('-');\n+        if (ndx >= 0 && name.indexOf('-', ndx + 1) >= 0) {\n+            name = name.substring(0, ndx) + name.substring(ndx + 1);\n+        }\n+        return name;\n+    }\n+\n+    private static void diffStrings(String actual, String expected) {\n+        if (actual.equals(expected))\n+            return;\n+        int lenDiff = expected.length() - actual.length();\n+        if (lenDiff != 0)\n+            System.out.println(\"String lengths:  \" + actual.length() + \" != \" + expected.length());\n+        int first;  \/\/ find first mismatched character\n+        for (first = 0; first < Math.min(actual.length(), expected.length()); first++) {\n+            if (actual.charAt(first) != expected.charAt(first))\n+                break;\n+        }\n+        int last;\n+        for (last = actual.length() - 1; last >= 0 && (last + lenDiff) >= 0; last--) {\n+            if (actual.charAt(last) != expected.charAt(last + lenDiff))\n+                break;      \/\/ last mismatched character\n+        }\n+        System.out.printf(\"actual vs expected[%3d]: 0x%04x != 0x%04x%n\", first, (int)actual.charAt(first), (int)expected.charAt(first));\n+        System.out.printf(\"actual vs expected[%3d]: 0x%04x != 0x%04x%n\", last, (int)actual.charAt(last), (int)expected.charAt(last));\n+        System.out.printf(\"actual  [%3d-%3d]: %s%n\", first, last, actual.substring(first, last+1));\n+        System.out.printf(\"expected[%3d-%3d]: %s%n\", first, last, expected.substring(first, last + lenDiff + 1));\n+    }\n+\n+    static class ChildWithCharset {\n+        public static void main(String[] args) {\n+            String nativeEncoding = System.getProperty(\"native.encoding\");\n+            System.out.println(TESTCHARS);\n+            byte[] bytes = null;\n+            try {\n+                bytes = System.in.readAllBytes();\n+                System.out.write(bytes);    \/\/ echo bytes back to parent on stdout\n+            } catch (IOException ioe) {\n+                ioe.printStackTrace();      \/\/ Seen by the parent\n+            }\n+            System.out.println(\"native.encoding: \" + nativeEncoding);\n+            System.out.println(\"sun.stdout.encoding: \" + System.getProperty(\"sun.stdout.encoding\"));\n+            System.out.println(\"LANG: \" + System.getenv().get(\"LANG\"));\n+\n+            System.err.println(TESTCHARS);\n+            try {\n+                System.err.write(bytes);    \/\/ echo bytes back to parent on stderr\n+            } catch (IOException ioe) {\n+                ioe.printStackTrace();      \/\/ Seen by the parent\n+            }\n+            System.err.println(\"native.encoding: \" + nativeEncoding);\n+            System.err.println(\"sun.stderr.encoding: \" + System.getProperty(\"sun.stderr.encoding\"));\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/ProcessBuilder\/ReaderWriterTest.java","additions":232,"deletions":0,"binary":false,"changes":232,"status":"added"}]}