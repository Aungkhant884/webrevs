{"files":[{"patch":"@@ -65,1 +65,1 @@\n- * {@link #outputWriter(boolean)}, {@link #outputWriter(boolean, Charset)}},\n+ * {@link #outputWriter()}, {@link #outputWriter(Charset)}},\n@@ -173,5 +173,8 @@\n-     * Returns a {@link BufferedReader BufferedReader} connected to the standard output of the process.\n-     * The {@code BufferedReader} can be used to read characters, lines, or stream lines of the standard output.\n-     * The reader decodes the standard output of this process using the\n-     * {@link Charset} named by the {@systemProperty native.encoding} system property.\n-     * If the {@code Charset} is not supported, the {@link Charset#defaultCharset()} is used.\n+     * Returns a {@link BufferedReader BufferedReader} connected to the standard\n+     * output of the process. The {@link Charset} for the native encoding is used\n+     * to read characters, lines, or stream lines from standard output.\n+     *\n+     * <p>This method delegates to {@link #inputReader(Charset)} using the\n+     * {@link Charset} named by the {@systemProperty native.encoding}\n+     * system property or the {@link Charset#defaultCharset()} if the\n+     * {@code native.encoding} is not supported.\n@@ -179,2 +182,4 @@\n-     * @return a {@link BufferedReader BufferedReader} using the {@code native.encoding} if supported,\n-     *          otherwise, the {@link Charset#defaultCharset()}\n+     * @return a {@link BufferedReader BufferedReader} using the\n+     *          {@code native.encoding} if supported, otherwise, the\n+     *          {@link Charset#defaultCharset()}\n+     * @since 17\n@@ -183,1 +188,1 @@\n-        return new BufferedReader(new InputStreamReader(getInputStream(), CharsetHolder.nativeCharset()));\n+        return inputReader(CharsetHolder.nativeCharset());\n@@ -187,4 +192,10 @@\n-     * Returns a {@link BufferedReader BufferedReader} connected to the standard output\n-     * of the process using a Charset.\n-     * The {@code BufferedReader} can be used to read characters, lines, or stream lines of the standard output.\n-     * The reader decodes the standard output of this process using the {@code charset}.\n+     * Returns a {@link BufferedReader BufferedReader} connected to the\n+     * standard output of this process using a Charset.\n+     * The {@code BufferedReader} can be used to read characters, lines,\n+     * or stream lines of the standard output.\n+     *\n+     * <p>Characters are read by an InputStreamReader that reads and decodes bytes\n+     * from this process {@link #getInputStream()}. Bytes are decoded to characters\n+     * using the {@code charset}; malformed-input and unmappable-character\n+     * sequences are replaced with the charset's default replacement.\n+     * The BufferedReader reads and buffers characters from the InputStreamReader.\n@@ -194,2 +205,2 @@\n-     * then this method will return a\n-     * <a href=\"ProcessBuilder.html#redirect-output\">null input reader<\/a>.\n+     * then the {@code InputStreamReader} will be reading from a\n+     * <a href=\"ProcessBuilder.html#redirect-output\">null input stream<\/a>.\n@@ -198,3 +209,4 @@\n-     * {@link ProcessBuilder#redirectErrorStream(boolean) ProcessBuilder.redirectErrorStream}\n-     * then the input stream returned by this method will receive the\n-     * merged standard output and the standard error of the process.\n+     * {@link ProcessBuilder#redirectErrorStream(boolean)\n+     * ProcessBuilder.redirectErrorStream} then the input reader returned by\n+     * this method will receive the merged standard output and the standard error\n+     * of the process.\n@@ -203,2 +215,3 @@\n-     * Using both {@link #getInputStream} and {@link #inputReader} has unpredictable behavior\n-     * since the buffered reader reads ahead from the input stream.\n+     * Using both {@link #getInputStream} and {@link #inputReader} has\n+     * unpredictable behavior since the buffered reader reads ahead from the\n+     * input stream.\n@@ -212,1 +225,1 @@\n-     * @param charset the {@code Charset} used to convert bytes to characters, not null\n+     * @param charset the {@code Charset} used to decode bytes to characters, not null\n@@ -214,0 +227,2 @@\n+     * @throws NullPointerException if the {@code charset} is {@code null}\n+     * @since 17\n@@ -220,5 +235,8 @@\n-     * Returns a {@link BufferedReader BufferedReader} connected to the standard error of the process.\n-     * The {@code BufferedReader} can be used to read characters, lines, or stream lines of the error output.\n-     * The reader decodes the standard error of this process using the\n-     * {@link Charset} named by the {@systemProperty native.encoding} system property.\n-     * If the {@code Charset} is not supported, the {@link Charset#defaultCharset()} is used.\n+     * Returns a {@link BufferedReader BufferedReader} connected to the standard\n+     * error of the process. The {@link Charset} for the native encoding is used\n+     * to read characters, lines, or stream lines from standard error.\n+     *\n+     * <p>This method delegates to {@link #errorReader(Charset)} using the\n+     * {@link Charset} named by the {@systemProperty native.encoding}\n+     * system property or the {@link Charset#defaultCharset()} if the\n+     * {@code native.encoding} is not supported.\n@@ -226,2 +244,4 @@\n-     * @return a {@link BufferedReader BufferedReader} using the {@code native.encoding} if supported,\n-     *          otherwise, the {@link Charset#defaultCharset()}\n+     * @return a {@link BufferedReader BufferedReader} using the\n+     *          {@code native.encoding} if supported, otherwise, the\n+     *          {@link Charset#defaultCharset()}\n+     * @since 17\n@@ -230,1 +250,1 @@\n-        return new BufferedReader(new InputStreamReader(getErrorStream(), CharsetHolder.nativeCharset()));\n+        return errorReader(CharsetHolder.nativeCharset());\n@@ -234,3 +254,10 @@\n-     * Returns a {@link BufferedReader BufferedReader} connected to the standard error of the process using a Charset.\n-     * The {@code BufferedReader} can be used to read characters, lines, or stream lines of the error output.\n-     * The reader decodes the standard error of this process using the {@code charset}.\n+     * Returns a {@link BufferedReader BufferedReader} connected to the\n+     * standard error of this process using a Charset.\n+     * The {@code BufferedReader} can be used to read characters, lines,\n+     * or stream lines of the standard error.\n+     *\n+     * <p>Characters are read by an InputStreamReader that reads and decodes bytes\n+     * from this process {@link #getErrorStream()}. Bytes are decoded to characters\n+     * using the {@code charset}; malformed-input and unmappable-character\n+     * sequences are replaced with the charset's default replacement.\n+     * The BufferedReader reads and buffers characters from the InputStreamReader.\n@@ -241,2 +268,2 @@\n-     * then this method will return a\n-     * <a href=\"ProcessBuilder.html#redirect-output\">null input reader<\/a>.\n+     * then the {@code InputStreamReader} will be reading from a\n+     * <a href=\"ProcessBuilder.html#redirect-output\">null input stream<\/a>.\n@@ -245,2 +272,3 @@\n-     * Using both {@link #getErrorStream} and {@link #errorReader} has unpredictable behavior\n-     * since the buffered reader reads ahead from the input stream.\n+     * Using both {@link #getErrorStream} and {@link #errorReader} has\n+     * unpredictable behavior since the buffered reader reads ahead from the\n+     * error stream.\n@@ -254,1 +282,1 @@\n-     * @param charset the {@code Charset} used to convert bytes to characters, not null\n+     * @param charset the {@code Charset} used to decode bytes to characters, not null\n@@ -256,0 +284,2 @@\n+     * @throws NullPointerException if the {@code charset} is {@code null}\n+     * @since 17\n@@ -289,0 +319,1 @@\n+     * @since 17\n@@ -319,1 +350,1 @@\n-     * @param charset the {@code Charset} to encode characters to bytes\n+     * @param charset the {@code Charset} to encode characters to bytes, not null\n@@ -321,0 +352,2 @@\n+     * @throws NullPointerException if the {@code charset} is {@code null}\n+     * @since 17\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Process.java","additions":71,"deletions":38,"binary":false,"changes":109,"status":"modified"},{"patch":"@@ -55,2 +55,2 @@\n- * @run testng\/othervm  -Djdk.serialFilterTrace SerialFilterTest\n- * @run testng\/othervm  -Djdk.serialSetFilterAfterRead=true -Djdk.serialFilterTrace SerialFilterTest\n+ * @run testng\/othervm  SerialFilterTest\n+ * @run testng\/othervm  -Djdk.serialSetFilterAfterRead=true SerialFilterTest\n","filename":"test\/jdk\/java\/io\/Serializable\/serialFilter\/SerialFilterTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import java.io.BufferedWriter;\n@@ -39,0 +40,2 @@\n+import java.nio.file.Path;\n+import java.nio.file.Files;\n@@ -95,0 +98,64 @@\n+    \/**\n+     * Test that redirects of input and error streams result in Readers that are empty.\n+     * Test that when the output to a process is redirected, the writer acts as\n+     * a null stream and throws an exception as expected for a null output stream\n+     * as specified by ProcessBuilder.\n+     *\/\n+    @Test\n+    void testRedirects() throws IOException {\n+        String nativeEncoding = System.getProperty(\"native.encoding\");\n+        Charset cs = Charset.forName(nativeEncoding);\n+        System.out.println(\"Native.encoding Charset: \" + cs);\n+\n+        Path inPath = Path.of(\"InFile.tmp\");\n+        BufferedWriter inWriter = Files.newBufferedWriter(inPath);\n+        inWriter.close();\n+\n+        Path outPath = Path.of(\"OutFile.tmp\");\n+        Path errorPath = Path.of(\"ErrFile.tmp\");\n+\n+        for (int errType = 1; errType < 4; errType++) {\n+            \/\/ Three cases to test for which the error stream is empty\n+            \/\/ 1: redirectErrorStream(false); redirect of errorOutput to a file\n+            \/\/ 2: redirectErrorStream(true); no redirect of errorOutput\n+            \/\/ 3: redirectErrorStream(true); redirect of errorOutput to a file\n+\n+            ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(\"ReaderWriterTest$ChildWithCharset\");\n+            pb.redirectInput(inPath.toFile());\n+            pb.redirectOutput(outPath.toFile());\n+            if (errType == 1 || errType == 3) {\n+                pb.redirectError(errorPath.toFile());\n+            }\n+            if (errType == 2 || errType == 3) {\n+                pb.redirectErrorStream(true);\n+            }\n+            Process p = pb.start();\n+            \/\/ Output has been redirected to a null stream; success is IOException on the write\n+            try {\n+                BufferedWriter wr = p.outputWriter();\n+                wr.write(\"X\");\n+                wr.flush();\n+                Assert.fail(\"writing to null stream should throw IOException\");\n+            } catch (IOException ioe) {\n+                \/\/ Normal, A Null output stream is closed when created.\n+            }\n+\n+            \/\/ InputReader should be empty; and at EOF\n+            BufferedReader inputReader = p.inputReader();\n+            int ch = inputReader.read();\n+            Assert.assertEquals(ch, -1, \"inputReader not at EOF: ch: \" + (char)ch);\n+\n+            \/\/ InputReader should be empty; and at EOF\n+            BufferedReader errorReader = p.errorReader();\n+            ch = errorReader.read();\n+            Assert.assertEquals(ch, -1, \"errorReader not at EOF: ch: \" + (char)ch);\n+\n+            try {\n+                int exitValue = p.waitFor();\n+                if (exitValue != 0) System.out.println(\"exitValue: \" + exitValue);\n+            } catch (InterruptedException ie) {\n+                Assert.fail(\"waitFor interrupted\");\n+            }\n+        }\n+    }\n+\n@@ -113,1 +180,1 @@\n-     * @param nativeEncoding a charset name\n+     * @param encoding a charset name\n@@ -116,1 +183,1 @@\n-    void testCase(String nativeEncoding) throws IOException {\n+    void testCase(String encoding) throws IOException {\n@@ -119,1 +186,1 @@\n-            cs = Charset.forName(nativeEncoding);\n+            cs = Charset.forName(encoding);\n@@ -122,1 +189,1 @@\n-            throw new SkippedException(\"Charset not supported: \" + nativeEncoding);\n+            throw new SkippedException(\"Charset not supported: \" + encoding);\n@@ -145,0 +212,36 @@\n+\n+    @Test\n+    void testNullCharsets()  throws IOException {\n+        \/\/ Launch a child; its behavior is not interesting and is ignored\n+        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(\n+                \"ReaderWriterTest$ChildWithCharset\");\n+\n+        Process p = pb.start();\n+        try {\n+            writeTestChars(p.outputWriter(null));\n+            Assert.fail(\"Process.outputWriter(null) did not throw NPE\");\n+        } catch (NullPointerException npe) {\n+            \/\/ expected, ignore\n+        }\n+        try {\n+            checkReader(p.inputReader(null), null, \"Out\");\n+            Assert.fail(\"Process.inputReader(null) did not throw NPE\");\n+        } catch (NullPointerException npe) {\n+            \/\/ expected, ignore\n+        }\n+        try {\n+            checkReader(p.errorReader(null), null, \"Err\");\n+            Assert.fail(\"Process.errorReader(null) did not throw NPE\");\n+        } catch (NullPointerException npe) {\n+            \/\/ expected, ignore\n+        }\n+\n+        p.destroyForcibly();\n+        try {\n+            \/\/ Collect the exit status to cleanup after the process; but ignore it\n+            p.waitFor();\n+        } catch (InterruptedException ie) {\n+            \/\/ Ignored\n+        }\n+    }\n+\n","filename":"test\/jdk\/java\/lang\/ProcessBuilder\/ReaderWriterTest.java","additions":107,"deletions":4,"binary":false,"changes":111,"status":"modified"}]}