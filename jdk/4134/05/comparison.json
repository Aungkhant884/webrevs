{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1995, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1995, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+import jdk.internal.util.StaticProperty;\n+\n@@ -30,0 +32,3 @@\n+import java.nio.charset.Charset;\n+import java.nio.charset.UnsupportedCharsetException;\n+import java.util.Objects;\n@@ -60,0 +65,4 @@\n+ * The I\/O streams of characters and lines can be written and read using the methods\n+ * {@link #outputWriter()}, {@link #outputWriter(Charset)}},\n+ * {@link #inputReader()}, {@link #inputReader(Charset)},\n+ * {@link #errorReader()}, and {@link #errorReader(Charset)}.\n@@ -93,0 +102,10 @@\n+\n+    \/\/ Readers and Writers created for this process; so repeated calls return the same object\n+    \/\/ All updates must be done while synchronized on this Process.\n+    private BufferedWriter outputWriter;\n+    private Charset outputCharset;\n+    private BufferedReader inputReader;\n+    private Charset inputCharset;\n+    private BufferedReader errorReader;\n+    private Charset errorCharset;\n+\n@@ -109,1 +128,7 @@\n-     * <p>Implementation note: It is a good idea for the returned\n+     * @apiNote\n+     * When writing to both {@link #getOutputStream()} and either {@link #outputWriter()}\n+     * or {@link #outputWriter(Charset)}, {@link BufferedWriter#flush BufferedWriter.flush}\n+     * should be called before writes to the {@code OutputStream}.\n+     *\n+     * @implNote\n+     * Implementation note: It is a good idea for the returned\n@@ -135,1 +160,6 @@\n-     * <p>Implementation note: It is a good idea for the returned\n+     * @apiNote\n+     * Use {@link #getInputStream} and {@link #inputReader} with extreme care.\n+     * The {@code BufferedReader} may have buffered input from the input stream.\n+     *\n+     * @implNote\n+     * Implementation note: It is a good idea for the returned\n@@ -156,1 +186,6 @@\n-     * <p>Implementation note: It is a good idea for the returned\n+     * @apiNote\n+     * Use {@link #getInputStream} and {@link #inputReader} with extreme care.\n+     * The {@code BufferedReader} may have buffered input from the input stream.\n+     *\n+     * @implNote\n+     * Implementation note: It is a good idea for the returned\n@@ -164,0 +199,216 @@\n+    \/**\n+     * Returns a {@link BufferedReader BufferedReader} connected to the standard\n+     * output of the process. The {@link Charset} for the native encoding is used\n+     * to read characters, lines, or stream lines from standard output.\n+     *\n+     * <p>This method delegates to {@link #inputReader(Charset)} using the\n+     * {@link Charset} named by the {@code native.encoding} system property.\n+     * If the {@code native.encoding} is not a valid charset name or not supported\n+     * the {@link Charset#defaultCharset()} is used.\n+     *\n+     * @return a {@link BufferedReader BufferedReader} using the\n+     *          {@code native.encoding} if supported, otherwise, the\n+     *          {@link Charset#defaultCharset()}\n+     * @since 17\n+     *\/\n+    public final BufferedReader inputReader() {\n+        return inputReader(CharsetHolder.nativeCharset());\n+    }\n+\n+    \/**\n+     * Returns a {@link BufferedReader BufferedReader} connected to the\n+     * standard output of this process using a Charset.\n+     * The {@code BufferedReader} can be used to read characters, lines,\n+     * or stream lines of the standard output.\n+     *\n+     * <p>Characters are read by an InputStreamReader that reads and decodes bytes\n+     * from this process {@link #getInputStream()}. Bytes are decoded to characters\n+     * using the {@code charset}; malformed-input and unmappable-character\n+     * sequences are replaced with the charset's default replacement.\n+     * The {@code BufferedReader} reads and buffers characters from the InputStreamReader.\n+     *\n+     * <p>If the standard output of the process has been redirected using\n+     * {@link ProcessBuilder#redirectOutput(Redirect) ProcessBuilder.redirectOutput}\n+     * then the {@code InputStreamReader} will be reading from a\n+     * <a href=\"ProcessBuilder.html#redirect-output\">null input stream<\/a>.\n+     *\n+     * <p>The first call to this method creates the {@link BufferedReader BufferedReader},\n+     * if called again with the same {@code charset} the same {@code BufferedReader} is returned.\n+     * It is an error to call this method again with a different {@code charset}.\n+     *\n+     * <p>Otherwise, if the standard error of the process has been redirected using\n+     * {@link ProcessBuilder#redirectErrorStream(boolean)\n+     * ProcessBuilder.redirectErrorStream} then the input reader returned by\n+     * this method will receive the merged standard output and the standard error\n+     * of the process.\n+     *\n+     * @apiNote\n+     * Using both {@link #getInputStream} and {@link #inputReader(Charset)} has\n+     * unpredictable behavior since the buffered reader reads ahead from the\n+     * input stream.\n+     *\n+     * <p>When the process has terminated, and the standard input has not been redirected,\n+     * reading of the bytes available from the underlying stream is on a best effort basis and\n+     * may be unpredictable.\n+     *\n+     * @param charset the {@code Charset} used to decode bytes to characters\n+     * @return a {@code BufferedReader} for the standard output of the process using the {@code charset}\n+     * @throws NullPointerException if the {@code charset} is {@code null}\n+     * @throws IllegalStateException if called more than once with different charset arguments\n+     * @since 17\n+     *\/\n+    public final BufferedReader inputReader(Charset charset) {\n+        Objects.requireNonNull(charset, \"charset\");\n+        synchronized (this) {\n+            if (inputReader == null) {\n+                inputCharset = charset;\n+                inputReader = new BufferedReader(new InputStreamReader(getInputStream(), charset));\n+            } else {\n+                if (!inputCharset.equals(charset))\n+                    throw new IllegalStateException(\"BufferedReader was created with charset: \" + inputCharset);\n+            }\n+            return inputReader;\n+        }\n+    }\n+\n+    \/**\n+     * Returns a {@link BufferedReader BufferedReader} connected to the standard\n+     * error of the process. The {@link Charset} for the native encoding is used\n+     * to read characters, lines, or stream lines from standard error.\n+     *\n+     * <p>This method delegates to {@link #errorReader(Charset)} using the\n+     * {@link Charset} named by the {@code native.encoding} system property.\n+     * If the {@code native.encoding} is not a valid charset name or not supported\n+     * the {@link Charset#defaultCharset()} is used.\n+     *\n+     * @return a {@link BufferedReader BufferedReader} using the\n+     *          {@code native.encoding} if supported, otherwise, the\n+     *          {@link Charset#defaultCharset()}\n+     * @since 17\n+     *\/\n+    public final BufferedReader errorReader() {\n+        return errorReader(CharsetHolder.nativeCharset());\n+    }\n+\n+    \/**\n+     * Returns a {@link BufferedReader BufferedReader} connected to the\n+     * standard error of this process using a Charset.\n+     * The {@code BufferedReader} can be used to read characters, lines,\n+     * or stream lines of the standard error.\n+     *\n+     * <p>Characters are read by an InputStreamReader that reads and decodes bytes\n+     * from this process {@link #getErrorStream()}. Bytes are decoded to characters\n+     * using the {@code charset}; malformed-input and unmappable-character\n+     * sequences are replaced with the charset's default replacement.\n+     * The {@code BufferedReader} reads and buffers characters from the InputStreamReader.\n+     *\n+     * <p>The first call to this method creates the {@link BufferedReader BufferedReader},\n+     * if called again with the same {@code charset} the same {@code BufferedReader} is returned.\n+     * It is an error to call this method again with a different {@code charset}.\n+     *\n+     * <p>If the standard error of the process has been redirected using\n+     * {@link ProcessBuilder#redirectError(Redirect) ProcessBuilder.redirectError} or\n+     * {@link ProcessBuilder#redirectErrorStream(boolean) ProcessBuilder.redirectErrorStream}\n+     * then the {@code InputStreamReader} will be reading from a\n+     * <a href=\"ProcessBuilder.html#redirect-output\">null input stream<\/a>.\n+     *\n+     * @apiNote\n+     * Using both {@link #getErrorStream} and {@link #errorReader(Charset)} has\n+     * unpredictable behavior since the buffered reader reads ahead from the\n+     * error stream.\n+     *\n+     * <p>When the process has terminated, and the standard error has not been redirected,\n+     * reading of the bytes available from the underlying stream is on a best effort basis and\n+     * may be unpredictable.\n+     *\n+     * @param charset the {@code Charset} used to decode bytes to characters\n+     * @return a {@code BufferedReader} for the standard error of the process using the {@code charset}\n+     * @throws NullPointerException if the {@code charset} is {@code null}\n+     * @throws IllegalStateException if called more than once with different charset arguments\n+     * @since 17\n+     *\/\n+    public final BufferedReader errorReader(Charset charset) {\n+        Objects.requireNonNull(charset, \"charset\");\n+        synchronized (this) {\n+            if (errorReader == null) {\n+                errorCharset = charset;\n+                errorReader = new BufferedReader(new InputStreamReader(getErrorStream(), charset));\n+            } else {\n+                if (!errorCharset.equals(charset))\n+                    throw new IllegalStateException(\"BufferedReader was created with charset: \" + errorCharset);\n+            }\n+            return errorReader;\n+        }\n+    }\n+\n+    \/**\n+     * Returns a {@code BufferedWriter} connected to the normal input of the process\n+     * using the native encoding.\n+     * Writes text to a character-output stream, buffering characters so as to provide\n+     * for the efficient writing of single characters, arrays, and strings.\n+     *\n+     * <p>This method delegates to {@link #outputWriter(Charset)} using the\n+     * {@link Charset} named by the {@code native.encoding} system property.\n+     * If the {@code native.encoding} is not a valid charset name or not supported\n+     * the {@link Charset#defaultCharset()} is used.\n+     *\n+     * @return a {@code BufferedWriter} to the standard input of the process using the charset\n+     *          for the {@code native.encoding} system property\n+     * @since 17\n+     *\/\n+    public final BufferedWriter outputWriter() {\n+        return outputWriter(CharsetHolder.nativeCharset());\n+    }\n+\n+    \/**\n+     * Returns a {@code BufferedWriter} connected to the normal input of the process\n+     * using a Charset.\n+     * Writes text to a character-output stream, buffering characters so as to provide\n+     * for the efficient writing of single characters, arrays, and strings.\n+     *\n+     * <p>Characters written by the writer are encoded to bytes using {@link OutputStreamWriter}\n+     * and the {@link Charset} are written to the standard input of the process represented\n+     * by this {@code Process}.\n+     * Malformed-input and unmappable-character sequences are replaced with the charset's\n+     * default replacement.\n+     *\n+     * <p>The first call to this method creates the {@link BufferedWriter BufferedWriter},\n+     * if called again with the same {@code charset} the same {@code BufferedWriter} is returned.\n+     * It is an error to call this method again with a different {@code charset}.\n+     *\n+     * <p>If the standard input of the process has been redirected using\n+     * {@link ProcessBuilder#redirectInput(Redirect)\n+     * ProcessBuilder.redirectInput} then this method will return a\n+     * <a href=\"ProcessBuilder.html#redirect-input\">null output stream<\/a>.\n+     *\n+     * @apiNote\n+     * A {@linkplain BufferedWriter} writes characters, arrays of characters, and strings.\n+     * Wrapping the {@link BufferedWriter} with a {@link PrintWriter} provides\n+     * efficient buffering and formatting of primitives and objects as well as support\n+     * for auto-flush on line endings.\n+     * Call the {@link BufferedWriter#flush()} method to flush buffered output to the process.\n+     * <p>\n+     * When writing to both {@link #getOutputStream()} and either {@link #outputWriter()}\n+     * or {@link #outputWriter(Charset)}, {@linkplain BufferedWriter#flush BufferedWriter.flush}\n+     * should be called before writes to the {@code OutputStream}.\n+     *\n+     * @param charset the {@code Charset} to encode characters to bytes\n+     * @return a {@code BufferedWriter} to the standard input of the process using the {@code charset}\n+     * @throws NullPointerException if the {@code charset} is {@code null}\n+     * @throws IllegalStateException if called more than once with different charset arguments\n+     * @since 17\n+     *\/\n+    public final BufferedWriter outputWriter(Charset charset) {\n+        Objects.requireNonNull(charset, \"charset\");\n+        synchronized (this) {\n+            if (outputWriter == null) {\n+                outputCharset = charset;\n+                outputWriter = new BufferedWriter(new OutputStreamWriter(getOutputStream(), charset));\n+            } else {\n+                if (!outputCharset.equals(charset))\n+                    throw new IllegalStateException(\"BufferedWriter was created with charset: \" + outputCharset);\n+            }\n+            return outputWriter;\n+        }\n+    }\n+\n@@ -264,1 +515,1 @@\n-     * {@link ProcessBuilder#start} and {@link Runtime#exec} forcibly terminate\n+     * {@link ProcessBuilder#start()} and {@link Runtime#exec} forcibly terminate\n@@ -295,1 +546,1 @@\n-     * {@link ProcessBuilder#start} and {@link Runtime#exec} return\n+     * {@link ProcessBuilder#start()} and {@link Runtime#exec} return\n@@ -374,1 +625,1 @@\n-     * Processes returned from {@link ProcessBuilder#start} override the\n+     * Processes returned from {@link ProcessBuilder#start()} override the\n@@ -466,1 +717,1 @@\n-     * {@code Process} objects returned by {@link ProcessBuilder#start} and\n+     * {@code Process} objects returned by {@link ProcessBuilder#start()} and\n@@ -592,0 +843,23 @@\n+\n+    \/**\n+     * A nested class to delay looking up the Charset for the native encoding.\n+     *\/\n+    private static class CharsetHolder {\n+        private final static Charset nativeCharset;\n+        static {\n+            Charset cs;\n+            try {\n+                cs = Charset.forName(StaticProperty.nativeEncoding());\n+            } catch (UnsupportedCharsetException uce) {\n+                cs = Charset.defaultCharset();\n+            }\n+            nativeCharset = cs;\n+        }\n+\n+        \/**\n+         * Charset for the native encoding or {@link Charset#defaultCharset().\n+         *\/\n+        static Charset nativeCharset() {\n+            return nativeCharset;\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Process.java","additions":282,"deletions":8,"binary":false,"changes":290,"status":"modified"},{"patch":"@@ -0,0 +1,394 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import static org.testng.Assert.*;\n+\n+import org.testng.Assert;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import jdk.test.lib.process.ProcessTools;\n+\n+import jdk.test.lib.hexdump.HexPrinter;\n+import jdk.test.lib.hexdump.HexPrinter.Formatters;\n+\n+import java.io.BufferedReader;\n+import java.io.BufferedWriter;\n+import java.io.IOException;\n+import java.io.Writer;\n+import java.nio.ByteBuffer;\n+import java.nio.file.Path;\n+import java.nio.file.Files;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.charset.UnsupportedCharsetException;\n+import java.util.List;\n+import java.util.Locale;\n+\n+import jtreg.SkippedException;\n+\n+\/*\n+ * @test\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.process.ProcessTools jdk.test.lib.hexdump.HexPrinter\n+ * @run testng ReaderWriterTest\n+ *\/\n+\n+@Test\n+public class ReaderWriterTest {\n+\n+    static final String ASCII = \"ASCII: \\u0000_A-Z_a-Z_\\u007C_\\u007D_\\u007E_\\u007F_;\";\n+    static final String ISO_8859_1 = \" Symbols: \\u00AB_\\u00BB_\\u00fc_\\u00fd_\\u00fe_\\u00ff;\";\n+    static final String FRACTIONS = \" Fractions: \\u00bc_\\u00bd_\\u00be_\\u00bf;\";\n+\n+    public static final String TESTCHARS = \"OneWay: \" + ASCII + ISO_8859_1 + FRACTIONS;\n+    public static final String ROUND_TRIP_TESTCHARS = \"RoundTrip: \" + ASCII + ISO_8859_1 + FRACTIONS;\n+\n+    @DataProvider(name=\"CharsetCases\")\n+    static Object[][] charsetCases() {\n+        return new Object[][] {\n+                {\"UTF-8\"},\n+                {\"ISO8859-1\"},\n+                {\"US-ASCII\"},\n+        };\n+    }\n+\n+    \/**\n+     * Test the defaults case of native.encoding.  No extra command line flags or switches.\n+     *\/\n+    @Test\n+    void testCaseNativeEncoding() throws IOException {\n+        String nativeEncoding = System.getProperty(\"native.encoding\");\n+        Charset cs = Charset.forName(nativeEncoding);\n+        System.out.println(\"Native.encoding Charset: \" + cs);\n+\n+        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(\"ReaderWriterTest$ChildWithCharset\");\n+        Process p = pb.start();\n+        writeTestChars(p.outputWriter());\n+        checkReader(p.inputReader(), cs, \"Out\");\n+        checkReader(p.errorReader(), cs, \"Err\");\n+        try {\n+            int exitValue = p.waitFor();\n+            if (exitValue != 0)\n+                System.out.println(\"exitValue: \" + exitValue);\n+        } catch (InterruptedException ie) {\n+            Assert.fail(\"waitFor interrupted\");\n+        }\n+    }\n+\n+    \/**\n+     * Test that redirects of input and error streams result in Readers that are empty.\n+     * Test that when the output to a process is redirected, the writer acts as\n+     * a null stream and throws an exception as expected for a null output stream\n+     * as specified by ProcessBuilder.\n+     *\/\n+    @Test\n+    void testRedirects() throws IOException {\n+        String nativeEncoding = System.getProperty(\"native.encoding\");\n+        Charset cs = Charset.forName(nativeEncoding);\n+        System.out.println(\"Native.encoding Charset: \" + cs);\n+\n+        Path inPath = Path.of(\"InFile.tmp\");\n+        BufferedWriter inWriter = Files.newBufferedWriter(inPath);\n+        inWriter.close();\n+\n+        Path outPath = Path.of(\"OutFile.tmp\");\n+        Path errorPath = Path.of(\"ErrFile.tmp\");\n+\n+        for (int errType = 1; errType < 4; errType++) {\n+            \/\/ Three cases to test for which the error stream is empty\n+            \/\/ 1: redirectErrorStream(false); redirect of errorOutput to a file\n+            \/\/ 2: redirectErrorStream(true); no redirect of errorOutput\n+            \/\/ 3: redirectErrorStream(true); redirect of errorOutput to a file\n+\n+            ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(\"ReaderWriterTest$ChildWithCharset\");\n+            pb.redirectInput(inPath.toFile());\n+            pb.redirectOutput(outPath.toFile());\n+            if (errType == 1 || errType == 3) {\n+                pb.redirectError(errorPath.toFile());\n+            }\n+            if (errType == 2 || errType == 3) {\n+                pb.redirectErrorStream(true);\n+            }\n+            Process p = pb.start();\n+            \/\/ Output has been redirected to a null stream; success is IOException on the write\n+            try {\n+                BufferedWriter wr = p.outputWriter();\n+                wr.write(\"X\");\n+                wr.flush();\n+                Assert.fail(\"writing to null stream should throw IOException\");\n+            } catch (IOException ioe) {\n+                \/\/ Normal, A Null output stream is closed when created.\n+            }\n+\n+            \/\/ InputReader should be empty; and at EOF\n+            BufferedReader inputReader = p.inputReader();\n+            int ch = inputReader.read();\n+            Assert.assertEquals(ch, -1, \"inputReader not at EOF: ch: \" + (char)ch);\n+\n+            \/\/ InputReader should be empty; and at EOF\n+            BufferedReader errorReader = p.errorReader();\n+            ch = errorReader.read();\n+            Assert.assertEquals(ch, -1, \"errorReader not at EOF: ch: \" + (char)ch);\n+\n+            try {\n+                int exitValue = p.waitFor();\n+                if (exitValue != 0) System.out.println(\"exitValue: \" + exitValue);\n+            } catch (InterruptedException ie) {\n+                Assert.fail(\"waitFor interrupted\");\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Write the test characters to the child using the Process.outputWriter.\n+     * @param writer the Writer\n+     * @throws IOException if an I\/O error occurs\n+     *\/\n+    private static void writeTestChars(Writer writer) throws IOException {\n+        \/\/ Write the test data to the child\n+        try (writer) {\n+            writer.append(ROUND_TRIP_TESTCHARS);\n+            writer.append(System.lineSeparator());\n+        }\n+    }\n+\n+    \/**\n+     * Test a child with a character set.\n+     * A Process is spawned; characters are written to and read from the child\n+     * using the character set and compared.\n+     *\n+     * @param encoding a charset name\n+     *\/\n+    @Test(dataProvider = \"CharsetCases\", enabled = true)\n+    void testCase(String encoding) throws IOException {\n+        Charset cs = null;\n+        try {\n+            cs = Charset.forName(encoding);\n+            System.out.println(\"Charset: \" + cs);\n+        } catch (UnsupportedCharsetException use) {\n+            throw new SkippedException(\"Charset not supported: \" + encoding);\n+        }\n+        String cleanCSName = cleanCharsetName(cs);\n+\n+        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(\n+                \"-Dsun.stdout.encoding=\" + cleanCSName,     \/\/ Encode in the child using the charset\n+                \"-Dsun.stderr.encoding=\" + cleanCSName,\n+                \"ReaderWriterTest$ChildWithCharset\");\n+\n+        Process p = pb.start();\n+        \/\/ Write the test data to the child\n+        writeTestChars(p.outputWriter(cs));\n+        checkReader(p.inputReader(cs), cs, \"Out\");\n+        checkReader(p.errorReader(cs), cs, \"Err\");\n+        try {\n+            int exitValue = p.waitFor();\n+            if (exitValue != 0)\n+                System.out.println(\"exitValue: \" + exitValue);\n+        } catch (InterruptedException ie) {\n+\n+        }\n+    }\n+\n+    \/**\n+     * Test passing null when a charset is expected\n+     * @throws IOException if an I\/O error occurs; not expected\n+     *\/\n+    @Test\n+    void testNullCharsets()  throws IOException {\n+        \/\/ Launch a child; its behavior is not interesting and is ignored\n+        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(\n+                \"ReaderWriterTest$ChildWithCharset\");\n+\n+        Process p = pb.start();\n+        try {\n+            writeTestChars(p.outputWriter(null));\n+            Assert.fail(\"Process.outputWriter(null) did not throw NPE\");\n+        } catch (NullPointerException npe) {\n+            \/\/ expected, ignore\n+        }\n+        try {\n+            checkReader(p.inputReader(null), null, \"Out\");\n+            Assert.fail(\"Process.inputReader(null) did not throw NPE\");\n+        } catch (NullPointerException npe) {\n+            \/\/ expected, ignore\n+        }\n+        try {\n+            checkReader(p.errorReader(null), null, \"Err\");\n+            Assert.fail(\"Process.errorReader(null) did not throw NPE\");\n+        } catch (NullPointerException npe) {\n+            \/\/ expected, ignore\n+        }\n+\n+        p.destroyForcibly();\n+        try {\n+            \/\/ Collect the exit status to cleanup after the process; but ignore it\n+            p.waitFor();\n+        } catch (InterruptedException ie) {\n+            \/\/ Ignored\n+        }\n+    }\n+\n+    \/**\n+     * Test passing different charset on multiple calls when the same charset is expected.\n+     * @throws IOException if an I\/O error occurs; not expected\n+     *\/\n+    @Test\n+    void testIllegalArgCharsets()  throws IOException {\n+        String nativeEncoding = System.getProperty(\"native.encoding\");\n+        Charset cs = Charset.forName(nativeEncoding);\n+        System.out.println(\"Native.encoding Charset: \" + cs);\n+        Charset otherCharset = cs.equals(StandardCharsets.UTF_8)\n+                ? StandardCharsets.ISO_8859_1\n+                : StandardCharsets.UTF_8;\n+\n+        \/\/ Launch a child; its behavior is not interesting and is ignored\n+        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(\n+                \"ReaderWriterTest$ChildWithCharset\");\n+\n+        Process p = pb.start();\n+        try {\n+            var writer = p.outputWriter(cs);\n+            writer = p.outputWriter(cs);        \/\/ try again with same\n+            writer = p.outputWriter(otherCharset);  \/\/ this should throw\n+            Assert.fail(\"Process.outputWriter(otherCharset) did not throw IllegalStateException\");\n+        } catch (IllegalStateException ile) {\n+            \/\/ expected, ignore\n+            System.out.println(ile);\n+        }\n+        try {\n+            var reader = p.inputReader(cs);\n+            reader = p.inputReader(cs);             \/\/ try again with same\n+            reader = p.inputReader(otherCharset);   \/\/ this should throw\n+            Assert.fail(\"Process.inputReader(otherCharset) did not throw IllegalStateException\");\n+        } catch (IllegalStateException ile) {\n+            \/\/ expected, ignore\n+            System.out.println(ile);\n+        }\n+        try {\n+            var reader = p.errorReader(cs);\n+            reader = p.errorReader(cs);             \/\/ try again with same\n+            reader = p.errorReader(otherCharset);   \/\/ this should throw\n+            Assert.fail(\"Process.errorReader(otherCharset) did not throw IllegalStateException\");\n+        } catch (IllegalStateException ile) {\n+            \/\/ expected, ignore\n+            System.out.println(ile);\n+        }\n+\n+        p.destroyForcibly();\n+        try {\n+            \/\/ Collect the exit status to cleanup after the process; but ignore it\n+            p.waitFor();\n+        } catch (InterruptedException ie) {\n+            \/\/ Ignored\n+        }\n+    }\n+\n+    private static void checkReader(BufferedReader reader, Charset cs, String label) throws IOException {\n+        try (BufferedReader in = reader) {\n+            String prefix = \"    \" + label + \": \";\n+            String firstline = in.readLine();\n+            System.out.append(prefix).println(firstline);\n+            String secondline = in.readLine();\n+            System.out.append(prefix).println(secondline);\n+            for (String line = in.readLine(); line != null; line = in.readLine()) {\n+                System.out.append(prefix).append(line);\n+                System.out.println();\n+            }\n+            ByteBuffer bb = cs.encode(TESTCHARS);\n+            String reencoded = cs.decode(bb).toString();\n+            if (!firstline.equals(reencoded))\n+                diffStrings(firstline, reencoded);\n+            assertEquals(firstline, reencoded, label + \" Test Chars\");\n+\n+            bb = cs.encode(ROUND_TRIP_TESTCHARS);\n+            reencoded = cs.decode(bb).toString();\n+            if (!secondline.equals(reencoded))\n+                diffStrings(secondline, reencoded);\n+            assertEquals(secondline, reencoded, label + \" Round Trip Test Chars\");\n+        }\n+    }\n+\n+    \/**\n+     * A cleaned up Charset name that is suitable for Linux LANG environment variable.\n+     * If there are two '-'s the first one is removed.\n+     * @param cs a Charset\n+     * @return the cleanedup Charset name\n+     *\/\n+    private static String cleanCharsetName(Charset cs) {\n+        String name = cs.name();\n+        int ndx = name.indexOf('-');\n+        if (ndx >= 0 && name.indexOf('-', ndx + 1) >= 0) {\n+            name = name.substring(0, ndx) + name.substring(ndx + 1);\n+        }\n+        return name;\n+    }\n+\n+    private static void diffStrings(String actual, String expected) {\n+        if (actual.equals(expected))\n+            return;\n+        int lenDiff = expected.length() - actual.length();\n+        if (lenDiff != 0)\n+            System.out.println(\"String lengths:  \" + actual.length() + \" != \" + expected.length());\n+        int first;  \/\/ find first mismatched character\n+        for (first = 0; first < Math.min(actual.length(), expected.length()); first++) {\n+            if (actual.charAt(first) != expected.charAt(first))\n+                break;\n+        }\n+        int last;\n+        for (last = actual.length() - 1; last >= 0 && (last + lenDiff) >= 0; last--) {\n+            if (actual.charAt(last) != expected.charAt(last + lenDiff))\n+                break;      \/\/ last mismatched character\n+        }\n+        System.out.printf(\"actual vs expected[%3d]: 0x%04x != 0x%04x%n\", first, (int)actual.charAt(first), (int)expected.charAt(first));\n+        System.out.printf(\"actual vs expected[%3d]: 0x%04x != 0x%04x%n\", last, (int)actual.charAt(last), (int)expected.charAt(last));\n+        System.out.printf(\"actual  [%3d-%3d]: %s%n\", first, last, actual.substring(first, last+1));\n+        System.out.printf(\"expected[%3d-%3d]: %s%n\", first, last, expected.substring(first, last + lenDiff + 1));\n+    }\n+\n+    static class ChildWithCharset {\n+        public static void main(String[] args) {\n+            String nativeEncoding = System.getProperty(\"native.encoding\");\n+            System.out.println(TESTCHARS);\n+            byte[] bytes = null;\n+            try {\n+                bytes = System.in.readAllBytes();\n+                System.out.write(bytes);    \/\/ echo bytes back to parent on stdout\n+            } catch (IOException ioe) {\n+                ioe.printStackTrace();      \/\/ Seen by the parent\n+            }\n+            System.out.println(\"native.encoding: \" + nativeEncoding);\n+            System.out.println(\"sun.stdout.encoding: \" + System.getProperty(\"sun.stdout.encoding\"));\n+            System.out.println(\"LANG: \" + System.getenv().get(\"LANG\"));\n+\n+            System.err.println(TESTCHARS);\n+            try {\n+                System.err.write(bytes);    \/\/ echo bytes back to parent on stderr\n+            } catch (IOException ioe) {\n+                ioe.printStackTrace();      \/\/ Seen by the parent\n+            }\n+            System.err.println(\"native.encoding: \" + nativeEncoding);\n+            System.err.println(\"sun.stderr.encoding: \" + System.getProperty(\"sun.stderr.encoding\"));\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/ProcessBuilder\/ReaderWriterTest.java","additions":394,"deletions":0,"binary":false,"changes":394,"status":"added"}]}