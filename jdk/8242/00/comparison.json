{"files":[{"patch":"@@ -97,1 +97,1 @@\n-    JAVAC_FLAGS := --add-exports java.base\/sun.security.util=ALL-UNNAMED, \\\n+    JAVAC_FLAGS := --add-exports java.base\/sun.security.util=ALL-UNNAMED --add-exports java.base\/sun.invoke.util=ALL-UNNAMED, \\\n","filename":"make\/test\/BuildMicrobenchmark.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import jdk.internal.vm.annotation.DontInline;\n+\n@@ -232,22 +234,11 @@\n-        switch (this) {\n-            case BOOLEAN:\n-                return Boolean.FALSE;\n-            case INT:\n-                return (Integer)0;\n-            case BYTE:\n-                return (Byte)(byte)0;\n-            case CHAR:\n-                return (Character)(char)0;\n-            case SHORT:\n-                return (Short)(short)0;\n-            case LONG:\n-                return (Long)(long)0;\n-            case FLOAT:\n-                return FLOAT_ZERO;\n-            case DOUBLE:\n-                return DOUBLE_ZERO;\n-            case VOID:\n-            case OBJECT:\n-            default:\n-                return null;\n-        }\n+        return switch (this) {\n+            case BOOLEAN -> Boolean.FALSE;\n+            case INT -> (Integer)0;\n+            case BYTE -> (Byte)(byte)0;\n+            case CHAR -> (Character)(char)0;\n+            case SHORT -> (Short)(short)0;\n+            case LONG -> (Long)(long)0;\n+            case FLOAT -> FLOAT_ZERO;\n+            case DOUBLE -> DOUBLE_ZERO;\n+            default -> null;\n+        };\n@@ -271,5 +262,10 @@\n-        Wrapper w = findPrimitiveType(type);\n-        if (w != null)  return w;\n-        if (type.isPrimitive())\n-            throw new InternalError(); \/\/ redo hash function\n-        throw newIllegalArgumentException(\"not primitive: \"+type);\n+        if (type == int.class)     return INT;\n+        if (type == long.class)    return LONG;\n+        if (type == boolean.class) return BOOLEAN;\n+        if (type == short.class)   return SHORT;\n+        if (type == byte.class)    return BYTE;\n+        if (type == char.class)    return CHAR;\n+        if (type == float.class)   return FLOAT;\n+        if (type == double.class)  return DOUBLE;\n+        if (type == void.class)    return VOID;\n+        throw newIllegalArgumentException(\"not primitive: \" + type);\n@@ -283,11 +279,3 @@\n-        switch (basicTypeChar) {\n-            case 'I': return INT;\n-            case 'J': return LONG;\n-            case 'S': return SHORT;\n-            case 'B': return BYTE;\n-            case 'C': return CHAR;\n-            case 'F': return FLOAT;\n-            case 'D': return DOUBLE;\n-            case 'Z': return BOOLEAN;\n-            case 'V': return VOID;\n-            default: throw newIllegalArgumentException(\"not primitive: \" + basicTypeChar);\n+        Wrapper w = FROM_CHAR[(basicTypeChar + (basicTypeChar >> 1)) & 0xf];\n+        if (w == null || w.basicTypeChar != basicTypeChar) {\n+            throw basicTypeError(basicTypeChar);\n@@ -295,6 +283,2 @@\n-    }\n-\n-    static Wrapper findPrimitiveType(Class<?> type) {\n-        Wrapper w = FROM_PRIM[hashPrim(type)];\n-        if (w != null && w.primitiveType == type) {\n-            return w;\n+        if (w == OBJECT) {\n+            throw newIllegalArgumentException(\"not primitive: \" + basicTypeChar);\n@@ -302,1 +286,1 @@\n-        return null;\n+        return w;\n@@ -313,5 +297,4 @@\n-        if (w != null)  return w;\n-        for (Wrapper x : values())\n-            if (x.wrapperType == type)\n-                throw new InternalError(); \/\/ redo hash function\n-        throw newIllegalArgumentException(\"not wrapper: \"+type);\n+        if (w != null) {\n+            return w;\n+        }\n+        throw wrapperTypeError(type);\n@@ -321,4 +304,10 @@\n-        Wrapper w = FROM_WRAP[hashWrap(type)];\n-        if (w != null && w.wrapperType == type) {\n-            return w;\n-        }\n+        if (type == Object.class)    return OBJECT;\n+        if (type == Integer.class)   return INT;\n+        if (type == Long.class)      return LONG;\n+        if (type == Boolean.class)   return BOOLEAN;\n+        if (type == Short.class)     return SHORT;\n+        if (type == Byte.class)      return BYTE;\n+        if (type == Character.class) return CHAR;\n+        if (type == Float.class)     return FLOAT;\n+        if (type == Double.class)    return DOUBLE;\n+        if (type == Void.class)      return VOID;\n@@ -328,0 +317,8 @@\n+    @DontInline\n+    private static RuntimeException wrapperTypeError(Class<?> type) {\n+        for (Wrapper x : values())\n+            if (x.wrapperType == type)\n+                throw new InternalError(); \/\/ missing wrapper type\n+        return newIllegalArgumentException(\"not wrapper: \" + type);\n+    }\n+\n@@ -333,1 +330,1 @@\n-        Wrapper w = FROM_CHAR[hashChar(type)];\n+        Wrapper w = FROM_CHAR[(type + (type >> 1)) & 0xf];\n@@ -337,2 +334,7 @@\n-        for (Wrapper x : values())\n-            if (w.basicTypeChar == type)\n+        throw basicTypeError(type);\n+    }\n+\n+    @DontInline\n+    private static RuntimeException basicTypeError(char type) {\n+        for (Wrapper x : values()) {\n+            if (x.basicTypeChar == type) {\n@@ -340,1 +342,3 @@\n-        throw newIllegalArgumentException(\"not basic type char: \"+type);\n+            }\n+        }\n+        return newIllegalArgumentException(\"not basic type char: \" + type);\n@@ -347,2 +351,9 @@\n-        if (type.isPrimitive())\n-            return forPrimitiveType(type);\n+        if (type == int.class)      return INT;\n+        if (type == long.class)     return LONG;\n+        if (type == boolean.class)  return BOOLEAN;\n+        if (type == void.class)     return VOID;\n+        if (type == byte.class)     return BYTE;\n+        if (type == char.class)     return CHAR;\n+        if (type == float.class)    return FLOAT;\n+        if (type == double.class)   return DOUBLE;\n+        if (type == short.class)    return SHORT;\n@@ -353,7 +364,1 @@\n-    \/\/   for signature chars c, do (c + (c >> 1)) % 16\n-    \/\/   for primitive type names n, do (n[0] + n[2]) % 16\n-    \/\/ The type name hash works for both primitive and wrapper names.\n-    \/\/ You can add \"java\/lang\/Object\" to the primitive names.\n-    \/\/ But you add the wrapper name Object, use (n[2] + (3*n[1])) % 16.\n-    private static final Wrapper[] FROM_PRIM = new Wrapper[16];\n-    private static final Wrapper[] FROM_WRAP = new Wrapper[16];\n+    \/\/   for signature chars c, do (c + (c >> 1)) & 0xf\n@@ -361,14 +366,1 @@\n-    private static int hashPrim(Class<?> x) {\n-        String xn = x.getName();\n-        if (xn.length() < 3)  return 0;\n-        return (xn.charAt(0) + xn.charAt(2)) % 16;\n-    }\n-    private static int hashWrap(Class<?> x) {\n-        String xn = x.getName();\n-        final int offset = 10; assert(offset == \"java.lang.\".length());\n-        if (xn.length() < offset+3)  return 0;\n-        return (3*xn.charAt(offset+1) + xn.charAt(offset+2)) % 16;\n-    }\n-    private static int hashChar(char x) {\n-        return (x + (x >> 1)) % 16;\n-    }\n+\n@@ -377,9 +369,1 @@\n-            int pi = hashPrim(w.primitiveType);\n-            int wi = hashWrap(w.wrapperType);\n-            int ci = hashChar(w.basicTypeChar);\n-            assert(FROM_PRIM[pi] == null);\n-            assert(FROM_WRAP[wi] == null);\n-            assert(FROM_CHAR[ci] == null);\n-            FROM_PRIM[pi] = w;\n-            FROM_WRAP[wi] = w;\n-            FROM_CHAR[ci] = w;\n+            FROM_CHAR[(w.basicTypeChar + (w.basicTypeChar >> 1)) & 0xf] = w;\n@@ -387,1 +371,0 @@\n-        \/\/assert(jdk.sun.invoke.util.WrapperTest.test(false));\n@@ -477,7 +460,0 @@\n-\/\/    \/** Wrap a value in the given type, which may be either a primitive or wrapper type.\n-\/\/     *  Performs standard primitive conversions, including truncation and float conversions.\n-\/\/     *\/\n-\/\/    public static <T> T wrap(Object x, Class<T> type) {\n-\/\/        return Wrapper.valueOf(type).cast(x, type);\n-\/\/    }\n-\n","filename":"src\/java.base\/share\/classes\/sun\/invoke\/util\/Wrapper.java","additions":74,"deletions":98,"binary":false,"changes":172,"status":"modified"},{"patch":"@@ -0,0 +1,122 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang.invoke;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+import java.util.concurrent.TimeUnit;\n+import sun.invoke.util.Wrapper;\n+\n+\/**\n+ * Test sun.invoke.util.Wrapper accessors\n+ *\/\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Thread)\n+@Fork(value = 3, jvmArgsAppend = \"--add-exports=java.base\/sun.invoke.util=ALL-UNNAMED\")\n+public class Wrappers {\n+\n+    public static Class<?>[] PRIM_CLASSES = {\n+        int.class,\n+        float.class,\n+        short.class,\n+        double.class,\n+        void.class,\n+        boolean.class,\n+        byte.class,\n+        char.class,\n+        long.class };\n+\n+    public static Class<?>[] WRAP_CLASSES = {\n+        Integer.class,\n+        Float.class,\n+        Short.class,\n+        Double.class,\n+        Void.class,\n+        Boolean.class,\n+        Byte.class,\n+        Character.class,\n+        Long.class,\n+        Object.class };\n+    public static char[] BASIC_TYPES = {\n+        'I',\n+        'J',\n+        'S',\n+        'B',\n+        'C',\n+        'F',\n+        'D',\n+        'Z',\n+        'V',\n+        'L' };\n+    public static char[] PRIM_TYPES = {\n+        'I',\n+        'J',\n+        'S',\n+        'B',\n+        'C',\n+        'F',\n+        'D',\n+        'Z',\n+        'V' };\n+\n+    @Benchmark\n+    public void forPrimitive(Blackhole bh) throws Throwable {\n+        for (Class<?> c : PRIM_CLASSES) {\n+            bh.consume(Wrapper.forPrimitiveType(c));\n+        }\n+    }\n+\n+    @Benchmark\n+    public void forWrapper(Blackhole bh) throws Throwable {\n+        for (Class<?> c : WRAP_CLASSES) {\n+            bh.consume(Wrapper.forWrapperType(c));\n+        }\n+    }\n+\n+    @Benchmark\n+    public void forBasicType(Blackhole bh) throws Throwable {\n+        for (char c : BASIC_TYPES) {\n+            bh.consume(Wrapper.forBasicType(c));\n+        }\n+    }\n+\n+    @Benchmark\n+    public void forPrimitiveType(Blackhole bh) throws Throwable {\n+        for (char c : PRIM_TYPES) {\n+            bh.consume(Wrapper.forPrimitiveType(c));\n+        }\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/invoke\/Wrappers.java","additions":122,"deletions":0,"binary":false,"changes":122,"status":"added"}]}