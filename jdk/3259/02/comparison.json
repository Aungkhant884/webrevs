{"files":[{"patch":"@@ -28,0 +28,1 @@\n+#include \"runtime\/os.inline.hpp\"\n@@ -171,1 +172,1 @@\n-void VM_Version::get_compatible_board(char *buf, int buflen) {\n+static bool read_fully(const char *fname, char *buf, size_t buflen) {\n@@ -174,2 +175,1 @@\n-  *buf = '\\0';\n-  int fd = open(\"\/proc\/device-tree\/compatible\", O_RDONLY);\n+  int fd = os::open(fname, O_RDONLY, 0);\n@@ -177,3 +177,7 @@\n-    ssize_t read_sz = read(fd, buf, buflen - 1);\n-    if (read_sz > 0) {\n-      buf[read_sz] = '\\0';\n+    ssize_t read_sz = os::read(fd, buf, buflen);\n+    os::close(fd);\n+\n+    \/\/ Skip if the contents starts with '\\n' because some machine only sets\n+    \/\/ '\\n' to the board name.\n+    \/\/ (e.g. \/sys\/devices\/virtual\/dmi\/id\/board_name)\n+    if ((read_sz > 0) && (*buf != '\\n')) {\n@@ -181,1 +185,1 @@\n-      for (char *ch = buf; ch < buf + read_sz; ch++) {\n+      for (char *ch = buf; ch < buf + read_sz - 1; ch++) {\n@@ -186,2 +190,19 @@\n-    } else {\n-      *buf = '\\0';\n+      buf[read_sz - 1] = '\\0';\n+      return true;\n+    }\n+  }\n+  *buf = '\\0';\n+  return false;\n+}\n+\n+void VM_Version::get_compatible_board(char *buf, int buflen) {\n+  const char *board_name_file_list[] = {\n+    \"\/proc\/device-tree\/compatible\",\n+    \"\/sys\/devices\/virtual\/dmi\/id\/board_name\",\n+    \"\/sys\/devices\/virtual\/dmi\/id\/product_name\",\n+    NULL\n+  };\n+\n+  for (const char **fname = board_name_file_list; *fname != NULL; fname++) {\n+    if (read_fully(*fname, buf, buflen)) {\n+      return;\n@@ -189,1 +210,0 @@\n-    close(fd);\n","filename":"src\/hotspot\/os_cpu\/linux_aarch64\/vm_version_linux_aarch64.cpp","additions":30,"deletions":10,"binary":false,"changes":40,"status":"modified"}]}