{"files":[{"patch":"@@ -5070,0 +5070,42 @@\n+instruct vmaskcast_extend_neon(vReg dst, vReg src) %{\n+  predicate(UseSVE == 0 &&\n+            Matcher::vector_length_in_bytes(n) > Matcher::vector_length_in_bytes(n->in(1)));\n+  match(Set dst (VectorMaskCast src));\n+  format %{ \"vmaskcast_extend_neon $dst, $src\" %}\n+  ins_encode %{\n+    BasicType dst_bt = Matcher::vector_element_basic_type(this);\n+    if (is_floating_point_type(dst_bt)) {\n+      dst_bt = (dst_bt == T_FLOAT) ? T_INT : T_LONG;\n+    }\n+    uint length_in_bytes_dst = Matcher::vector_length_in_bytes(this);\n+    BasicType src_bt = Matcher::vector_element_basic_type(this, $src);\n+    if (is_floating_point_type(src_bt)) {\n+      src_bt = (src_bt == T_FLOAT) ? T_INT : T_LONG;\n+    }\n+    __ neon_vector_extend($dst$$FloatRegister, dst_bt, length_in_bytes_dst,\n+                          $src$$FloatRegister, src_bt);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmaskcast_narrow_neon(vReg dst, vReg src) %{\n+  predicate(UseSVE == 0 &&\n+            Matcher::vector_length_in_bytes(n) < Matcher::vector_length_in_bytes(n->in(1)));\n+  match(Set dst (VectorMaskCast src));\n+  format %{ \"vmaskcast_narrow_neon $dst, $src\" %}\n+  ins_encode %{\n+    BasicType dst_bt = Matcher::vector_element_basic_type(this);\n+    if (is_floating_point_type(dst_bt)) {\n+      dst_bt = (dst_bt == T_FLOAT) ? T_INT : T_LONG;\n+    }\n+    BasicType src_bt = Matcher::vector_element_basic_type(this, $src);\n+    if (is_floating_point_type(src_bt)) {\n+      src_bt = (src_bt == T_FLOAT) ? T_INT : T_LONG;\n+    }\n+    uint length_in_bytes_src = Matcher::vector_length_in_bytes(this, $src);\n+    __ neon_vector_narrow($dst$$FloatRegister, dst_bt,\n+                          $src$$FloatRegister, src_bt, length_in_bytes_src);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -5080,1 +5122,1 @@\n-instruct vmaskcast_extend(pRegGov dst, pReg src) %{\n+instruct vmaskcast_extend_sve(pRegGov dst, pReg src) %{\n@@ -5084,1 +5126,1 @@\n-  format %{ \"vmaskcast_extend $dst, $src\" %}\n+  format %{ \"vmaskcast_extend_sve $dst, $src\" %}\n@@ -5097,1 +5139,1 @@\n-instruct vmaskcast_narrow(pRegGov dst, pReg src) %{\n+instruct vmaskcast_narrow_sve(pRegGov dst, pReg src) %{\n@@ -5101,1 +5143,1 @@\n-  format %{ \"vmaskcast_narrow $dst, $src\" %}\n+  format %{ \"vmaskcast_narrow_sve $dst, $src\" %}\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector.ad","additions":46,"deletions":4,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -3476,0 +3476,42 @@\n+instruct vmaskcast_extend_neon(vReg dst, vReg src) %{\n+  predicate(UseSVE == 0 &&\n+            Matcher::vector_length_in_bytes(n) > Matcher::vector_length_in_bytes(n->in(1)));\n+  match(Set dst (VectorMaskCast src));\n+  format %{ \"vmaskcast_extend_neon $dst, $src\" %}\n+  ins_encode %{\n+    BasicType dst_bt = Matcher::vector_element_basic_type(this);\n+    if (is_floating_point_type(dst_bt)) {\n+      dst_bt = (dst_bt == T_FLOAT) ? T_INT : T_LONG;\n+    }\n+    uint length_in_bytes_dst = Matcher::vector_length_in_bytes(this);\n+    BasicType src_bt = Matcher::vector_element_basic_type(this, $src);\n+    if (is_floating_point_type(src_bt)) {\n+      src_bt = (src_bt == T_FLOAT) ? T_INT : T_LONG;\n+    }\n+    __ neon_vector_extend($dst$$FloatRegister, dst_bt, length_in_bytes_dst,\n+                          $src$$FloatRegister, src_bt);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmaskcast_narrow_neon(vReg dst, vReg src) %{\n+  predicate(UseSVE == 0 &&\n+            Matcher::vector_length_in_bytes(n) < Matcher::vector_length_in_bytes(n->in(1)));\n+  match(Set dst (VectorMaskCast src));\n+  format %{ \"vmaskcast_narrow_neon $dst, $src\" %}\n+  ins_encode %{\n+    BasicType dst_bt = Matcher::vector_element_basic_type(this);\n+    if (is_floating_point_type(dst_bt)) {\n+      dst_bt = (dst_bt == T_FLOAT) ? T_INT : T_LONG;\n+    }\n+    BasicType src_bt = Matcher::vector_element_basic_type(this, $src);\n+    if (is_floating_point_type(src_bt)) {\n+      src_bt = (src_bt == T_FLOAT) ? T_INT : T_LONG;\n+    }\n+    uint length_in_bytes_src = Matcher::vector_length_in_bytes(this, $src);\n+    __ neon_vector_narrow($dst$$FloatRegister, dst_bt,\n+                          $src$$FloatRegister, src_bt, length_in_bytes_src);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -3486,1 +3528,1 @@\n-instruct vmaskcast_extend(pRegGov dst, pReg src) %{\n+instruct vmaskcast_extend_sve(pRegGov dst, pReg src) %{\n@@ -3490,1 +3532,1 @@\n-  format %{ \"vmaskcast_extend $dst, $src\" %}\n+  format %{ \"vmaskcast_extend_sve $dst, $src\" %}\n@@ -3503,1 +3545,1 @@\n-instruct vmaskcast_narrow(pRegGov dst, pReg src) %{\n+instruct vmaskcast_narrow_sve(pRegGov dst, pReg src) %{\n@@ -3507,1 +3549,1 @@\n-  format %{ \"vmaskcast_narrow $dst, $src\" %}\n+  format %{ \"vmaskcast_narrow_sve $dst, $src\" %}\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector_ad.m4","additions":46,"deletions":4,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -4600,0 +4600,133 @@\n+void C2_MacroAssembler::vector_mask_cast(XMMRegister dst, XMMRegister src,\n+                                         BasicType dst_bt, BasicType src_bt, int vlen) {\n+  int vlen_enc = vector_length_encoding(MAX2(type2aelembytes(src_bt), type2aelembytes(dst_bt)) * vlen);\n+  int dst_bt_size = type2aelembytes(dst_bt);\n+  int src_bt_size = type2aelembytes(src_bt);\n+  if (dst_bt_size > src_bt_size) {\n+    switch (dst_bt_size \/ src_bt_size) {\n+      case 2: {\n+        if (vlen_enc == AVX_512bit && !VM_Version::supports_avx512bw()) {\n+          vpmovsxdq(dst, src, vlen_enc);\n+        } else {\n+          vpmovsxbw(dst, src, vlen_enc);\n+        }\n+        break;\n+      }\n+      case 4: vpmovsxbd(dst, src, vlen_enc); break;\n+      case 8: vpmovsxbq(dst, src, vlen_enc); break;\n+      default: ShouldNotReachHere();\n+    }\n+  } else {\n+    assert(dst_bt_size < src_bt_size, \"\");\n+    switch (src_bt_size \/ dst_bt_size) {\n+      case 2: {\n+        if (vlen_enc == AVX_512bit) {\n+          if (VM_Version::supports_avx512bw()) {\n+            evpmovwb(dst, src, vlen_enc);\n+          } else {\n+            evpmovqd(dst, src, vlen_enc);\n+          }\n+        } else if (VM_Version::supports_avx512vl()) {\n+          if (VM_Version::supports_avx512bw()) {\n+            evpmovwb(dst, src, vlen_enc);\n+          } else if (dst_bt != T_BYTE) {\n+            evpmovdw(dst, src, vlen_enc);\n+          } else if (vlen_enc == AVX_128bit) {\n+            vpacksswb(dst, src, src, vlen_enc);\n+          } else {\n+            vpacksswb(dst, src, src, vlen_enc);\n+            vpermq(dst, dst, 0x08, vlen_enc);\n+          }\n+        } else {\n+          if (vlen_enc == AVX_128bit) {\n+            vpacksswb(dst, src, src, vlen_enc);\n+          } else {\n+            vpacksswb(dst, src, src, vlen_enc);\n+            vpermq(dst, dst, 0x08, vlen_enc);\n+          }\n+        }\n+        break;\n+      }\n+      case 4: {\n+        if (vlen_enc == AVX_512bit || VM_Version::supports_avx512vl()) {\n+          evpmovdb(dst, src, vlen_enc);\n+        } else if (vlen_enc == AVX_128bit) {\n+          vpackssdw(dst, src, src, vlen_enc);\n+          vpacksswb(dst, dst, dst, vlen_enc);\n+        } else {\n+          vpackssdw(dst, src, src, vlen_enc);\n+          vpermq(dst, dst, 0x08, vlen_enc);\n+          vpacksswb(dst, dst, dst, AVX_128bit);\n+        }\n+        break;\n+      }\n+      case 8: {\n+        if (vlen_enc == AVX_512bit || VM_Version::supports_avx512vl()) {\n+          evpmovqb(dst, src, vlen_enc);\n+        } else if (vlen_enc == AVX_128bit) {\n+          vpshufd(dst, src, 0x08, vlen_enc);\n+          vpackssdw(dst, dst, dst, vlen_enc);\n+          vpacksswb(dst, dst, dst, vlen_enc);\n+        } else {\n+          vpshufd(dst, src, 0x08, vlen_enc);\n+          vpermq(dst, dst, 0x08, vlen_enc);\n+          vpackssdw(dst, dst, dst, AVX_128bit);\n+          vpacksswb(dst, dst, dst, AVX_128bit);\n+        }\n+        break;\n+      }\n+      default: ShouldNotReachHere();\n+    }\n+  }\n+}\n+\n+void C2_MacroAssembler::vector_mask_cast_with_tmp(XMMRegister dst, XMMRegister src, XMMRegister xtmp1,\n+                                                  XMMRegister xtmp2, BasicType dst_bt, BasicType src_bt, int vlen) {\n+  int dst_bt_size = type2aelembytes(dst_bt);\n+  int src_bt_size = type2aelembytes(src_bt);\n+  if (dst_bt_size > src_bt_size) {\n+    switch (dst_bt_size \/ src_bt_size) {\n+      case 2:\n+        vpmovsxbw(xtmp1, src, AVX_128bit);\n+        vpshufd(xtmp2, src, 0x0E, AVX_128bit);\n+        vpmovsxbw(xtmp2, xtmp2, AVX_128bit);\n+        vinsertf128(dst, xtmp1, xtmp2, 0x01);\n+        break;\n+      case 4:\n+        vpmovsxbd(xtmp1, src, AVX_128bit);\n+        vpshufd(xtmp2, src, 0x01, AVX_128bit);\n+        vpmovsxbd(xtmp2, xtmp2, AVX_128bit);\n+        vinsertf128(dst, xtmp1, xtmp2, 0x01);\n+        break;\n+      case 8:\n+        vpmovsxbq(xtmp1, src, AVX_128bit);\n+        pshuflw(xtmp2, src, 0x01);\n+        vpmovsxbq(xtmp2, xtmp2, AVX_128bit);\n+        vinsertf128(dst, xtmp1, xtmp2, 0x01);\n+        break;\n+      default: ShouldNotReachHere();\n+    }\n+  } else {\n+    assert(dst_bt_size < src_bt_size, \"\");\n+    assert(xtmp2 == xnoreg, \"\");\n+    switch (src_bt_size \/ dst_bt_size) {\n+      case 2:\n+        vextractf128(xtmp1, src, 0x01);\n+        vpacksswb(dst, src, xtmp1, AVX_128bit);\n+        break;\n+      case 4:\n+        vextractf128(xtmp1, src, 0x01);\n+        vpackssdw(dst, src, xtmp1, AVX_128bit);\n+        vpacksswb(dst, dst, dst, AVX_128bit);\n+        break;\n+      case 8:\n+        vpermilps(dst, src, 0x08, AVX_256bit);\n+        vpermpd(dst, dst, 0x08, AVX_256bit);\n+        vpackssdw(dst, dst, dst, AVX_128bit);\n+        vpacksswb(dst, dst, dst, AVX_128bit);\n+        break;\n+      default: ShouldNotReachHere();\n+    }\n+  }\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":133,"deletions":0,"binary":false,"changes":133,"status":"modified"},{"patch":"@@ -335,0 +335,5 @@\n+  void vector_mask_cast(XMMRegister dst, XMMRegister src, BasicType dst_bt, BasicType src_bt, int vlen);\n+\n+  void vector_mask_cast_with_tmp(XMMRegister dst, XMMRegister src, XMMRegister xtmp1,\n+                                 XMMRegister xtmp2, BasicType dst_bt, BasicType src_bt, int vlen);\n+\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1483,0 +1483,1 @@\n+    case Op_VectorMaskCast:\n@@ -8431,0 +8432,53 @@\n+instruct vmaskcast_avx(vec dst, vec src) %{\n+  predicate(Matcher::vector_length(n) == Matcher::vector_length(n->in(1)) &&\n+            Matcher::vector_length_in_bytes(n) != Matcher::vector_length_in_bytes(n->in(1)) &&\n+            (UseAVX >= 2 ||\n+             (Matcher::vector_length_in_bytes(n) != 32 &&\n+              Matcher::vector_length_in_bytes(n->in(1)) != 32)));\n+  match(Set dst (VectorMaskCast src));\n+  format %{ \"vector_mask_cast $dst, $src\" %}\n+  ins_encode %{\n+    int vlen = Matcher::vector_length(this);\n+    BasicType src_bt = Matcher::vector_element_basic_type(this, $src);\n+    BasicType dst_bt = Matcher::vector_element_basic_type(this);\n+    __ vector_mask_cast($dst$$XMMRegister, $src$$XMMRegister, dst_bt, src_bt, vlen);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmaskcast_avx1_32B_expand(vec dst, vec src, vec xtmp1, vec xtmp2) %{\n+  predicate(Matcher::vector_length(n) == Matcher::vector_length(n->in(1)) &&\n+            Matcher::vector_length_in_bytes(n) > Matcher::vector_length_in_bytes(n->in(1)) &&\n+            UseAVX == 1 &&\n+            Matcher::vector_length_in_bytes(n) == 32);\n+  match(Set dst (VectorMaskCast src));\n+  effect(TEMP xtmp1, TEMP xtmp2);\n+  format %{ \"vector_mask_cast $dst, $src\\t! using $xtmp1, $xtmp2 as TEMP\" %}\n+  ins_encode %{\n+    int vlen = Matcher::vector_length(this);\n+    BasicType src_bt = Matcher::vector_element_basic_type(this, $src);\n+    BasicType dst_bt = Matcher::vector_element_basic_type(this);\n+    __ vector_mask_cast_with_tmp($dst$$XMMRegister, $src$$XMMRegister, $xtmp1$$XMMRegister,\n+                                 $xtmp2$$XMMRegister, dst_bt, src_bt, vlen);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmaskcast_avx1_32B_shrink(vec dst, vec src, vec xtmp) %{\n+  predicate(Matcher::vector_length(n) == Matcher::vector_length(n->in(1)) &&\n+            Matcher::vector_length_in_bytes(n) < Matcher::vector_length_in_bytes(n->in(1)) &&\n+            UseAVX == 1 &&\n+            Matcher::vector_length_in_bytes(n->in(1)) == 32);\n+  match(Set dst (VectorMaskCast src));\n+  effect(TEMP xtmp);\n+  format %{ \"vector_mask_cast $dst, $src\\t! using $xtmp as TEMP\" %}\n+  ins_encode %{\n+    int vlen = Matcher::vector_length(this);\n+    BasicType src_bt = Matcher::vector_element_basic_type(this, $src);\n+    BasicType dst_bt = Matcher::vector_element_basic_type(this);\n+    __ vector_mask_cast_with_tmp($dst$$XMMRegister, $src$$XMMRegister, $xtmp$$XMMRegister,\n+                                 xnoreg, dst_bt, src_bt, vlen);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":54,"deletions":0,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -364,1 +364,0 @@\n-  bool arch_supports_vectormask_cast(const TypeVect* src_type, const TypeVect* dst_type, VectorMaskUseType mask_use_type);\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -145,40 +145,0 @@\n-bool LibraryCallKit::arch_supports_vectormask_cast(const TypeVect* src_type, const TypeVect* dst_type, VectorMaskUseType mask_use_type) {\n-  BasicType elem_bt_from = src_type->element_basic_type();\n-  BasicType elem_bt_to = dst_type->element_basic_type();\n-  int num_elem = dst_type->length();\n-\n-  \/\/ We need the VectorMaskCast op if:\n-  \/\/ 1) the current platform supports predicated feature, or\n-  \/\/ 2) the element size (in bytes) of the src and dst type is equal to each other\n-  if ((src_type->isa_vectmask() && dst_type->isa_vectmask()) ||\n-      type2aelembytes(elem_bt_from) == type2aelembytes(elem_bt_to)) {\n-    return arch_supports_vector(Op_VectorMaskCast, num_elem, elem_bt_to, mask_use_type);\n-  }\n-\n-  BasicType new_elem_bt_from = elem_bt_from;\n-  BasicType new_elem_bt_to = elem_bt_to;\n-  if (is_floating_point_type(elem_bt_from)) {\n-    new_elem_bt_from = elem_bt_from == T_FLOAT ? T_INT : T_LONG;\n-  }\n-  if (is_floating_point_type(elem_bt_to)) {\n-    new_elem_bt_to = elem_bt_to == T_FLOAT ? T_INT : T_LONG;\n-  }\n-\n-  \/\/ For other cases, we need the VectorCast op instead. Besides, if the casting operation\n-  \/\/ involves floating point types, we also need the VectorMaskCast op to do conversions\n-  \/\/ between the floating point type and the integral type that has the same type size.\n-  \/\/\n-  \/\/ The casting operation patterns involving floating point type F and integral type X are:\n-  \/\/ Case A) F -> X :=  VectorMaskCast (F->I\/L) + VectorCast[I\/L]2X\n-  \/\/ Case B) X -> F :=  VectorCastX2[I\/L] + VectorMaskCast ([I\/L]->F)\n-  \/\/ Case C) F -> F :=  VectorMaskCast (F->I\/L) + VectorCast[I\/L]2[L\/I] + VectorMaskCast (L\/I->F)\n-  if ((new_elem_bt_from != elem_bt_from &&\n-       !arch_supports_vector(Op_VectorMaskCast, num_elem, new_elem_bt_from, mask_use_type)) ||\n-      !arch_supports_vector(VectorCastNode::opcode(new_elem_bt_from), num_elem, new_elem_bt_to, mask_use_type) ||\n-      (new_elem_bt_to != elem_bt_to &&\n-       !arch_supports_vector(Op_VectorMaskCast, num_elem, elem_bt_to, mask_use_type))) {\n-    return false;\n-  }\n-  return true;\n-}\n-\n@@ -2587,1 +2547,1 @@\n-        if (!arch_supports_vectormask_cast(src_type, dst_type, VecMaskNotUsed)) {\n+        if (!arch_supports_vector(Op_VectorMaskCast, num_elem_to, elem_bt_to, VecMaskNotUsed)) {\n@@ -2594,1 +2554,1 @@\n-        op = gvn().transform(VectorMaskCastNode::make(&gvn(), op, dst_type));\n+        op = gvn().transform(new VectorMaskCastNode(op, dst_type));\n","filename":"src\/hotspot\/share\/opto\/vectorIntrinsics.cpp","additions":2,"deletions":42,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -1622,0 +1622,1 @@\n+          \/\/ VectorUnbox (VectorBox vmask) ==> VectorMaskCast vmask\n@@ -1623,10 +1624,1 @@\n-          if (in_vt->length_in_bytes() == out_vt->length_in_bytes() &&\n-              Matcher::match_rule_supported_vector(Op_VectorMaskCast, out_vt->length(), out_vt->element_basic_type())) {\n-            \/\/ Apply \"VectorUnbox (VectorBox vmask) ==> VectorMaskCast (vmask)\"\n-            \/\/ directly. This could avoid the transformation ordering issue from\n-            \/\/ \"VectorStoreMask (VectorLoadMask vmask) => vmask\".\n-            return new VectorMaskCastNode(value, vmask_type);\n-          }\n-          \/\/ VectorUnbox (VectorBox vmask) ==> VectorLoadMask (VectorStoreMask vmask)\n-          value = phase->transform(VectorStoreMaskNode::make(*phase, value, in_vt->element_basic_type(), in_vt->length()));\n-          return new VectorLoadMaskNode(value, vmask_type);\n+          return new VectorMaskCastNode(value, vmask_type);\n@@ -1723,41 +1715,0 @@\n-Node* VectorMaskCastNode::make(PhaseGVN* phase, Node* src, const TypeVect* dst_type) {\n-  const TypeVect* src_type = src->bottom_type()->is_vect();\n-  assert(src_type->length() == dst_type->length(), \"\");\n-\n-  BasicType elem_bt_from = src_type->element_basic_type();\n-  BasicType elem_bt_to = dst_type->element_basic_type();\n-  if (dst_type->isa_vectmask() == NULL && src_type->isa_vectmask() == NULL &&\n-      type2aelembytes(elem_bt_from) != type2aelembytes(elem_bt_to)) {\n-    int num_elem = src_type->length();\n-    Node* op = src;\n-    BasicType new_elem_bt_from = elem_bt_from;\n-    BasicType new_elem_bt_to = elem_bt_to;\n-    if (is_floating_point_type(elem_bt_from)) {\n-      new_elem_bt_from = elem_bt_from == T_FLOAT ? T_INT : T_LONG;\n-    }\n-    if (is_floating_point_type(elem_bt_to)) {\n-      new_elem_bt_to = elem_bt_to == T_FLOAT ? T_INT : T_LONG;\n-    }\n-\n-    \/\/ Special handling for casting operation involving floating point types,\n-    \/\/ floating point type F and integral type X:\n-    \/\/ Case A) F -> X :=  F -> VectorMaskCast (F->I\/L [NOP]) -> VectorCast[I\/L]2X\n-    \/\/ Case B) X -> F :=  X -> VectorCastX2[I\/L] -> VectorMaskCast ([I\/L]->F [NOP])\n-    \/\/ Case C) F -> F :=  VectorMaskCast (F->I\/L [NOP]) -> VectorCast[I\/L]2[L\/I] -> VectorMaskCast (L\/I->F [NOP])\n-\n-    if (new_elem_bt_from != elem_bt_from) {\n-      const TypeVect* new_src_type = TypeVect::makemask(new_elem_bt_from, num_elem);\n-      op = phase->transform(new VectorMaskCastNode(op, new_src_type));\n-    }\n-\n-    op = VectorCastNode::make(VectorCastNode::opcode(new_elem_bt_from), op, new_elem_bt_to, num_elem);\n-\n-    if (new_elem_bt_to != elem_bt_to) {\n-      op = new VectorMaskCastNode(phase->transform(op), dst_type);\n-    }\n-    return op;\n-  } else {\n-    return new VectorMaskCastNode(src, dst_type);\n-  }\n-}\n-\n@@ -1784,1 +1735,1 @@\n-       return VectorMaskCastNode::make(phase, src, dst_type);\n+       return new VectorMaskCastNode(src, dst_type);\n","filename":"src\/hotspot\/share\/opto\/vectornode.cpp","additions":3,"deletions":52,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -1508,1 +1508,0 @@\n-  static Node* make(PhaseGVN* phase, Node* in1, const TypeVect * vt);\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"}]}