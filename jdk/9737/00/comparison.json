{"files":[{"patch":"@@ -364,0 +364,1 @@\n+  bool arch_supports_vectormask_cast(const TypeVect* src_type, const TypeVect* dst_type, VectorMaskUseType mask_use_type);\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -145,0 +145,40 @@\n+bool LibraryCallKit::arch_supports_vectormask_cast(const TypeVect* src_type, const TypeVect* dst_type, VectorMaskUseType mask_use_type) {\n+  BasicType elem_bt_from = src_type->element_basic_type();\n+  BasicType elem_bt_to = dst_type->element_basic_type();\n+  int num_elem = dst_type->length();\n+\n+  \/\/ We need the VectorMaskCast op if:\n+  \/\/ 1) the current platform supports predicated feature, or\n+  \/\/ 2) the element size (in bytes) of the src and dst type is equal to each other\n+  if ((src_type->isa_vectmask() && dst_type->isa_vectmask()) ||\n+      type2aelembytes(elem_bt_from) == type2aelembytes(elem_bt_to)) {\n+    return arch_supports_vector(Op_VectorMaskCast, num_elem, elem_bt_to, mask_use_type);\n+  }\n+\n+  BasicType new_elem_bt_from = elem_bt_from;\n+  BasicType new_elem_bt_to = elem_bt_to;\n+  if (is_floating_point_type(elem_bt_from)) {\n+    new_elem_bt_from = elem_bt_from == T_FLOAT ? T_INT : T_LONG;\n+  }\n+  if (is_floating_point_type(elem_bt_to)) {\n+    new_elem_bt_to = elem_bt_to == T_FLOAT ? T_INT : T_LONG;\n+  }\n+\n+  \/\/ For other cases, we need the VectorCast op instead. Besides, if the casting operation\n+  \/\/ involves floating point types, we also need the VectorMaskCast op to do conversions\n+  \/\/ between the floating point type and the integral type that has the same type size.\n+  \/\/\n+  \/\/ The casting operation patterns involving floating point type F and integral type X are:\n+  \/\/ Case A) F -> X :=  VectorMaskCast (F->I\/L) + VectorCast[I\/L]2X\n+  \/\/ Case B) X -> F :=  VectorCastX2[I\/L] + VectorMaskCast ([I\/L]->F)\n+  \/\/ Case C) F -> F :=  VectorMaskCast (F->I\/L) + VectorCast[I\/L]2[L\/I] + VectorMaskCast (L\/I->F)\n+  if ((new_elem_bt_from != elem_bt_from &&\n+       !arch_supports_vector(Op_VectorMaskCast, num_elem, new_elem_bt_from, mask_use_type)) ||\n+      !arch_supports_vector(VectorCastNode::opcode(new_elem_bt_from), num_elem, new_elem_bt_to, mask_use_type) ||\n+      (new_elem_bt_to != elem_bt_to &&\n+       !arch_supports_vector(Op_VectorMaskCast, num_elem, elem_bt_to, mask_use_type))) {\n+    return false;\n+  }\n+  return true;\n+}\n+\n@@ -2485,1 +2525,2 @@\n-       (dst_type->isa_vectmask() == NULL && src_type->isa_vectmask()))) {\n+       (dst_type->isa_vectmask() == NULL && src_type->isa_vectmask()) ||\n+       num_elem_from != num_elem_to)) {\n@@ -2491,8 +2532,5 @@\n-    BasicType new_elem_bt_to = elem_bt_to;\n-    BasicType new_elem_bt_from = elem_bt_from;\n-    if (is_mask && is_floating_point_type(elem_bt_from)) {\n-      new_elem_bt_from = elem_bt_from == T_FLOAT ? T_INT : T_LONG;\n-    }\n-    int cast_vopc = VectorCastNode::opcode(new_elem_bt_from, !is_ucast);\n-    \/\/ Make sure that cast is implemented to particular type\/size combination.\n-    if (!arch_supports_vector(cast_vopc, num_elem_to, elem_bt_to, VecMaskNotUsed)) {\n+    int cast_vopc = VectorCastNode::opcode(elem_bt_from, !is_ucast);\n+\n+    \/\/ Make sure that vector cast is implemented to particular type\/size combination if it is not\n+    \/\/ a mask casting.\n+    if (!is_mask && !arch_supports_vector(cast_vopc, num_elem_to, elem_bt_to, VecMaskNotUsed)) {\n@@ -2501,2 +2539,1 @@\n-                      cast_vopc,\n-                      num_elem_to, type2name(elem_bt_to), is_mask);\n+                      cast_vopc, num_elem_to, type2name(elem_bt_to), is_mask);\n@@ -2527,2 +2564,2 @@\n-      \/\/ Since number elements from input is larger than output, simply reduce size of input (we are supposed to\n-      \/\/ drop top elements anyway).\n+      \/\/ Since number of elements from input is larger than output, simply reduce size of input\n+      \/\/ (we are supposed to drop top elements anyway).\n@@ -2544,4 +2581,2 @@\n-      op = gvn().transform(new VectorReinterpretNode(op,\n-                                                     src_type,\n-                                                     TypeVect::make(elem_bt_from,\n-                                                                    num_elem_for_resize)));\n+      const TypeVect* resize_type = TypeVect::make(elem_bt_from, num_elem_for_resize);\n+      op = gvn().transform(new VectorReinterpretNode(op, src_type, resize_type));\n@@ -2549,1 +2584,1 @@\n-    } else {\n+    } else { \/\/ num_elem_from == num_elem_to\n@@ -2551,5 +2586,7 @@\n-        if ((dst_type->isa_vectmask() && src_type->isa_vectmask()) ||\n-            (type2aelembytes(elem_bt_from) == type2aelembytes(elem_bt_to))) {\n-          op = gvn().transform(new VectorMaskCastNode(op, dst_type));\n-        } else {\n-          op = VectorMaskCastNode::makeCastNode(&gvn(), op, dst_type);\n+        \/\/ Make sure that cast for vector mask is implemented to particular type\/size combination.\n+        if (!arch_supports_vectormask_cast(src_type, dst_type, VecMaskNotUsed)) {\n+          if (C->print_intrinsics()) {\n+            tty->print_cr(\"  ** not supported: arity=1 op=maskcast vlen2=%d etype2=%s ismask=%d\",\n+                          num_elem_to, type2name(elem_bt_to), is_mask);\n+          }\n+          return false;\n@@ -2557,0 +2594,1 @@\n+        op = gvn().transform(VectorMaskCastNode::make(&gvn(), op, dst_type));\n","filename":"src\/hotspot\/share\/opto\/vectorIntrinsics.cpp","additions":61,"deletions":23,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -1723,1 +1723,1 @@\n-Node* VectorMaskCastNode::makeCastNode(PhaseGVN* phase, Node* src, const TypeVect* dst_type) {\n+Node* VectorMaskCastNode::make(PhaseGVN* phase, Node* src, const TypeVect* dst_type) {\n@@ -1727,1 +1727,0 @@\n-  int num_elem = src_type->length();\n@@ -1730,1 +1729,0 @@\n-\n@@ -1733,1 +1731,1 @@\n-\n+    int num_elem = src_type->length();\n@@ -1738,1 +1736,1 @@\n-      new_elem_bt_from =  elem_bt_from == T_FLOAT ? T_INT : T_LONG;\n+      new_elem_bt_from = elem_bt_from == T_FLOAT ? T_INT : T_LONG;\n@@ -1744,1 +1742,2 @@\n-    \/\/ Special handling for casting operation involving floating point types.\n+    \/\/ Special handling for casting operation involving floating point types,\n+    \/\/ floating point type F and integral type X:\n@@ -1747,1 +1746,1 @@\n-    \/\/ Case C) F -> F :=  VectorMaskCast (F->I\/L [NOP]) -> VectorCast[I\/L]2[L\/I] -> VectotMaskCast (L\/I->F [NOP])\n+    \/\/ Case C) F -> F :=  VectorMaskCast (F->I\/L [NOP]) -> VectorCast[I\/L]2[L\/I] -> VectorMaskCast (L\/I->F [NOP])\n@@ -1754,1 +1753,1 @@\n-    op = phase->transform(VectorCastNode::make(VectorCastNode::opcode(new_elem_bt_from), op, new_elem_bt_to, num_elem));\n+    op = VectorCastNode::make(VectorCastNode::opcode(new_elem_bt_from), op, new_elem_bt_to, num_elem);\n@@ -1757,1 +1756,1 @@\n-      op = phase->transform(new VectorMaskCastNode(op, dst_type));\n+      op = new VectorMaskCastNode(phase->transform(op), dst_type);\n@@ -1785,1 +1784,1 @@\n-       return VectorMaskCastNode::makeCastNode(phase, src, dst_type);\n+       return VectorMaskCastNode::make(phase, src, dst_type);\n","filename":"src\/hotspot\/share\/opto\/vectornode.cpp","additions":9,"deletions":10,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -1508,1 +1508,1 @@\n-  static Node* makeCastNode(PhaseGVN* phase, Node* in1, const TypeVect * vt);\n+  static Node* make(PhaseGVN* phase, Node* in1, const TypeVect * vt);\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}