{"files":[{"patch":"@@ -1756,1 +1756,5 @@\n-\/\/------------------------------analyze----------------------------------------\n+\/\/ In this analysis, all types are initially set to TOP. We iteratively call Value() on all nodes of the graph until\n+\/\/ we reach a fix-point (i.e. no types change anymore). We start with a list that only contains the root node. Each time\n+\/\/ a new type is set, we push all uses of that node back to the worklist (in some cases, we also push grandchildren\n+\/\/ or nodes even further down back to the worklist because their type could change as a result of the current type\n+\/\/ change).\n@@ -1759,2 +1763,2 @@\n-  for (int i = C->unique() - 1; i >= 0; i--)  {\n-    _types.map(i,Type::TOP);\n+  for (uint i = 0; i < C->unique(); i++)  {\n+    _types.map(i, Type::TOP);\n@@ -1769,6 +1773,8 @@\n-  while( worklist.size() ) {\n-    Node* n; \/\/ Node to be examined in this iteration\n-    if (StressCCP) {\n-      n = worklist.remove(C->random() % worklist.size());\n-    } else {\n-      n = worklist.pop();\n+  while (worklist.size() != 0) {\n+    Node* n = fetch_next_node(worklist);\n+    const Type* new_type = n->Value(this);\n+    if (new_type != type(n)) {\n+      assert(ccp_type_widens(new_type, type(n)), \"ccp type must widen\");\n+      dump_type_and_node(n, new_type);\n+      set_type(n, new_type);\n+      push_child_nodes_to_worklist(worklist, n);\n@@ -1776,3 +1782,12 @@\n-    const Type *t = n->Value(this);\n-    if (t != type(n)) {\n-      assert(ccp_type_widens(t, type(n)), \"ccp type must widen\");\n+  }\n+}\n+\n+\/\/ Fetch next node from worklist to be examined in this iteration.\n+Node* PhaseCCP::fetch_next_node(Unique_Node_List& worklist) {\n+  if (StressCCP) {\n+    return worklist.remove(C->random() % worklist.size());\n+  } else {\n+    return worklist.pop();\n+  }\n+}\n+\n@@ -1780,5 +1795,9 @@\n-      if( TracePhaseCCP ) {\n-        t->dump();\n-        do { tty->print(\"\\t\"); } while (tty->position() < 16);\n-        n->dump();\n-      }\n+void PhaseCCP::dump_type_and_node(const Node* n, const Type* t) {\n+  if (TracePhaseCCP) {\n+    t->dump();\n+    do {\n+      tty->print(\"\\t\");\n+    } while (tty->position() < 16);\n+    n->dump();\n+  }\n+}\n@@ -1786,29 +1805,0 @@\n-      set_type(n, t);\n-      for (DUIterator_Fast imax, i = n->fast_outs(imax); i < imax; i++) {\n-        Node* m = n->fast_out(i);   \/\/ Get user\n-        if (m->is_Region()) {  \/\/ New path to Region?  Must recheck Phis too\n-          for (DUIterator_Fast i2max, i2 = m->fast_outs(i2max); i2 < i2max; i2++) {\n-            Node* p = m->fast_out(i2); \/\/ Propagate changes to uses\n-            if (p->bottom_type() != type(p)) { \/\/ If not already bottomed out\n-              worklist.push(p); \/\/ Propagate change to user\n-            }\n-          }\n-        }\n-        \/\/ If we changed the receiver type to a call, we need to revisit\n-        \/\/ the Catch following the call.  It's looking for a non-NULL\n-        \/\/ receiver to know when to enable the regular fall-through path\n-        \/\/ in addition to the NullPtrException path\n-        if (m->is_Call()) {\n-          for (DUIterator_Fast i2max, i2 = m->fast_outs(i2max); i2 < i2max; i2++) {\n-            Node* p = m->fast_out(i2);  \/\/ Propagate changes to uses\n-            if (p->is_Proj() && p->as_Proj()->_con == TypeFunc::Control) {\n-              Node* catch_node = p->find_out_with(Op_Catch);\n-              if (catch_node != NULL) {\n-                worklist.push(catch_node);\n-              }\n-            }\n-          }\n-        }\n-        if (m->bottom_type() != type(m)) { \/\/ If not already bottomed out\n-          worklist.push(m);     \/\/ Propagate change to user\n-        }\n@@ -1816,24 +1806,48 @@\n-        \/\/ CmpU nodes can get their type information from two nodes up in the\n-        \/\/ graph (instead of from the nodes immediately above). Make sure they\n-        \/\/ are added to the worklist if nodes they depend on are updated, since\n-        \/\/ they could be missed and get wrong types otherwise.\n-        uint m_op = m->Opcode();\n-        if (m_op == Op_AddI || m_op == Op_SubI) {\n-          for (DUIterator_Fast i2max, i2 = m->fast_outs(i2max); i2 < i2max; i2++) {\n-            Node* p = m->fast_out(i2); \/\/ Propagate changes to uses\n-            if (p->Opcode() == Op_CmpU) {\n-              \/\/ Got a CmpU which might need the new type information from node n.\n-              if(p->bottom_type() != type(p)) { \/\/ If not already bottomed out\n-                worklist.push(p); \/\/ Propagate change to user\n-              }\n-            }\n-          }\n-        }\n-        \/\/ If n is used in a counted loop exit condition then the type\n-        \/\/ of the counted loop's Phi depends on the type of n. See\n-        \/\/ PhiNode::Value().\n-        if (m_op == Op_CmpI || m_op == Op_CmpL) {\n-          PhiNode* phi = countedloop_phi_from_cmp(m->as_Cmp(), n);\n-          if (phi != NULL) {\n-            worklist.push(phi);\n-          }\n+\/\/ We need to propagate the type change of 'n' to all its uses. Depending on the kind of node, additional nodes\n+\/\/ (grandchildren or even further down) need to be revisited as their types could also be improved as a result\n+\/\/ of the new type of 'n'. Push these nodes to the worklist.\n+void PhaseCCP::push_child_nodes_to_worklist(Unique_Node_List& worklist, Node* n) const {\n+  for (DUIterator_Fast imax, i = n->fast_outs(imax); i < imax; i++) {\n+    Node* use = n->fast_out(i);\n+    push_if_not_bottom_type(worklist, use);\n+    push_more_uses(worklist, n, use);\n+  }\n+}\n+\n+void PhaseCCP::push_if_not_bottom_type(Unique_Node_List& worklist, Node* n) const {\n+  if (n->bottom_type() != type(n)) {\n+    worklist.push(n);\n+  }\n+}\n+\n+\/\/ For some nodes, we need to propagate the type change to grandchildren or even further down.\n+\/\/ Add them back to the worklist.\n+void PhaseCCP::push_more_uses(Unique_Node_List& worklist, Node* parent, const Node* use) const {\n+  push_phis(worklist, use);\n+  push_catch(worklist, use);\n+  push_cmpu(worklist, use);\n+  push_counted_loop_phi(worklist, parent, use);\n+  push_loadp(worklist, use);\n+  push_and(worklist, parent, use);\n+}\n+\n+\n+\/\/ We must recheck Phis too if use is a Region.\n+void PhaseCCP::push_phis(Unique_Node_List& worklist, const Node* use) const {\n+  if (use->is_Region()) {\n+    for (DUIterator_Fast imax, i = use->fast_outs(imax); i < imax; i++) {\n+      push_if_not_bottom_type(worklist, use->fast_out(i));\n+    }\n+  }\n+}\n+\n+\/\/ If we changed the receiver type to a call, we need to revisit the Catch node following the call. It's looking for a\n+\/\/ non-NULL receiver to know when to enable the regular fall-through path in addition to the NullPtrException path.\n+void PhaseCCP::push_catch(Unique_Node_List& worklist, const Node* use) {\n+  if (use->is_Call()) {\n+    for (DUIterator_Fast imax, i = use->fast_outs(imax); i < imax; i++) {\n+      Node* proj = use->fast_out(i);\n+      if (proj->is_Proj() && proj->as_Proj()->_con == TypeFunc::Control) {\n+        Node* catch_node = proj->find_out_with(Op_Catch);\n+        if (catch_node != NULL) {\n+          worklist.push(catch_node);\n@@ -1841,22 +1855,47 @@\n-        \/\/ Loading the java mirror from a Klass requires two loads and the type\n-        \/\/ of the mirror load depends on the type of 'n'. See LoadNode::Value().\n-        BarrierSetC2* bs = BarrierSet::barrier_set()->barrier_set_c2();\n-        bool has_load_barrier_nodes = bs->has_load_barrier_nodes();\n-\n-        if (m_op == Op_LoadP && m->bottom_type()->isa_rawptr()) {\n-          for (DUIterator_Fast i2max, i2 = m->fast_outs(i2max); i2 < i2max; i2++) {\n-            Node* u = m->fast_out(i2);\n-            const Type* ut = u->bottom_type();\n-            if (u->Opcode() == Op_LoadP && ut->isa_instptr() && ut != type(u)) {\n-              if (has_load_barrier_nodes) {\n-                \/\/ Search for load barriers behind the load\n-                for (DUIterator_Fast i3max, i3 = u->fast_outs(i3max); i3 < i3max; i3++) {\n-                  Node* b = u->fast_out(i3);\n-                  if (bs->is_gc_barrier_node(b)) {\n-                    worklist.push(b);\n-                  }\n-                }\n-              }\n-              worklist.push(u);\n-            }\n-          }\n+      }\n+    }\n+  }\n+}\n+\n+\/\/ CmpU nodes can get their type information from two nodes up in the graph (instead of from the nodes immediately\n+\/\/ above). Make sure they are added to the worklist if nodes they depend on are updated since they could be missed\n+\/\/ and get wrong types otherwise.\n+void PhaseCCP::push_cmpu(Unique_Node_List& worklist, const Node* use) const {\n+  uint use_op = use->Opcode();\n+  if (use_op == Op_AddI || use_op == Op_SubI) {\n+    for (DUIterator_Fast imax, i = use->fast_outs(imax); i < imax; i++) {\n+      Node* cmpu = use->fast_out(i);\n+      if (cmpu->Opcode() == Op_CmpU) {\n+        \/\/ Got a CmpU which might need the new type information from node n.\n+        push_if_not_bottom_type(worklist, cmpu);\n+      }\n+    }\n+  }\n+}\n+\n+\/\/ If n is used in a counted loop exit condition, then the type of the counted loop's Phi depends on the type of 'n'.\n+\/\/ Seem PhiNode::Value().\n+void PhaseCCP::push_counted_loop_phi(Unique_Node_List& worklist, Node* parent, const Node* use) {\n+  uint use_op = use->Opcode();\n+  if (use_op == Op_CmpI || use_op == Op_CmpL) {\n+    PhiNode* phi = countedloop_phi_from_cmp(use->as_Cmp(), parent);\n+    if (phi != NULL) {\n+      worklist.push(phi);\n+    }\n+  }\n+}\n+\n+\/\/ Loading the java mirror from a Klass requires two loads and the type of the mirror load depends on the type of 'n'.\n+\/\/ See LoadNode::Value().\n+void PhaseCCP::push_loadp(Unique_Node_List& worklist, const Node* use) const {\n+  BarrierSetC2* barrier_set = BarrierSet::barrier_set()->barrier_set_c2();\n+  bool has_load_barrier_nodes = barrier_set->has_load_barrier_nodes();\n+\n+  if (use->Opcode() == Op_LoadP && use->bottom_type()->isa_rawptr()) {\n+    for (DUIterator_Fast imax, i = use->fast_outs(imax); i < imax; i++) {\n+      Node* loadp = use->fast_out(i);\n+      const Type* ut = loadp->bottom_type();\n+      if (loadp->Opcode() == Op_LoadP && ut->isa_instptr() && ut != type(loadp)) {\n+        if (has_load_barrier_nodes) {\n+          \/\/ Search for load barriers behind the load\n+          push_load_barrier(worklist, barrier_set, loadp);\n@@ -1864,1 +1903,1 @@\n-        push_and(worklist, n, m);\n+        worklist.push(loadp);\n@@ -1870,0 +1909,9 @@\n+void PhaseCCP::push_load_barrier(Unique_Node_List& worklist, const BarrierSetC2* barrier_set, const Node* use) {\n+  for (DUIterator_Fast imax, i = use->fast_outs(imax); i < imax; i++) {\n+    Node* barrier_node = use->fast_out(i);\n+    if (barrier_set->is_gc_barrier_node(barrier_node)) {\n+      worklist.push(barrier_node);\n+    }\n+  }\n+}\n+\n@@ -1879,3 +1927,2 @@\n-      if ((and_node_op == Op_AndI || and_node_op == Op_AndL)\n-          && and_node->bottom_type() != type(and_node)) {\n-        worklist.push(and_node);\n+      if (and_node_op == Op_AndI || and_node_op == Op_AndL) {\n+        push_if_not_bottom_type(worklist, and_node);\n@@ -1887,0 +1934,1 @@\n+\n","filename":"src\/hotspot\/share\/opto\/phaseX.cpp","additions":144,"deletions":96,"binary":false,"changes":240,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+class BarrierSetC2;\n@@ -569,2 +570,14 @@\n-  virtual Node *transform_once( Node *n );\n-\n+  virtual Node* transform_once(Node* n);\n+\n+  Node* fetch_next_node(Unique_Node_List& worklist);\n+  static void dump_type_and_node(const Node* n, const Type* t) PRODUCT_RETURN;\n+\n+  void push_child_nodes_to_worklist(Unique_Node_List& worklist, Node* n) const;\n+  void push_if_not_bottom_type(Unique_Node_List& worklist, Node* n) const;\n+  void push_more_uses(Unique_Node_List& worklist, Node* parent, const Node* use) const;\n+  void push_phis(Unique_Node_List& worklist, const Node* use) const;\n+  static void push_catch(Unique_Node_List& worklist, const Node* use);\n+  void push_cmpu(Unique_Node_List& worklist, const Node* use) const;\n+  static void push_counted_loop_phi(Unique_Node_List& worklist, Node* parent, const Node* use);\n+  void push_loadp(Unique_Node_List& worklist, const Node* use) const;\n+  static void push_load_barrier(Unique_Node_List& worklist, const BarrierSetC2* barrier_set, const Node* use);\n@@ -573,1 +586,1 @@\n-public:\n+ public:\n","filename":"src\/hotspot\/share\/opto\/phaseX.hpp","additions":16,"deletions":3,"binary":false,"changes":19,"status":"modified"}]}