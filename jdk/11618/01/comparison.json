{"files":[{"patch":"@@ -2498,1 +2498,1 @@\n-  emit_data(disp, rspec.reloc(), call32_operand);\n+  emit_data(disp, rspec, call32_operand);\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -39,0 +39,3 @@\n+#include <new>\n+#include <type_traits>\n+\n@@ -238,1 +241,2 @@\n-  return new(_rh) Relocation(t);\n+  _rh = RelocationHolder::none;\n+  return _rh.reloc();\n@@ -241,0 +245,4 @@\n+\/\/ Verify all the destructors are trivial, so we don't need to worry about\n+\/\/ destroying old contents of a RelocationHolder being assigned.\n+#define VERIFY_TRIVIALLY_DESTRUCTIBLE_AUX(Reloc) \\\n+  static_assert(std::is_trivially_destructible<Reloc>::value, \"must be\");\n@@ -242,1 +250,14 @@\n-\/\/\/\/\/\/\/\/ Methods for flyweight Relocation types\n+#define VERIFY_TRIVIALLY_DESTRUCTIBLE(name) \\\n+  VERIFY_TRIVIALLY_DESTRUCTIBLE_AUX(PASTE_TOKENS(name, _Relocation));\n+\n+APPLY_TO_RELOCATIONS(VERIFY_TRIVIALLY_DESTRUCTIBLE)\n+VERIFY_TRIVIALLY_DESTRUCTIBLE_AUX(Relocation)\n+\n+#undef VERIFY_TRIVIALLY_DESTRUCTIBLE_AUX\n+#undef VERIFY_TRIVIALLY_DESTRUCTIBLE\n+\n+\/\/ Define all the copy_into functions.\n+#define DEFINE_COPY_INTO_AUX(Reloc)                             \\\n+  void Reloc::copy_into(RelocationHolder& holder) const {       \\\n+    copy_into_helper(*this, holder);                            \\\n+  }\n@@ -244,0 +265,10 @@\n+#define DEFINE_COPY_INTO(name) \\\n+  DEFINE_COPY_INTO_AUX(PASTE_TOKENS(name, _Relocation))\n+\n+APPLY_TO_RELOCATIONS(DEFINE_COPY_INTO)\n+DEFINE_COPY_INTO_AUX(Relocation)\n+\n+#undef DEFINE_COPY_INTO_AUX\n+#undef DEFINE_COPY_INTO\n+\n+\/\/\/\/\/\/\/\/ Methods for RelocationHolder\n@@ -267,0 +298,2 @@\n+\/\/\/\/\/\/\/\/ Methods for flyweight Relocation types\n+\n","filename":"src\/hotspot\/share\/code\/relocInfo.cpp","additions":35,"deletions":2,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-#include \"utilities\/macros.hpp\"\n@@ -33,0 +32,3 @@\n+#include \"utilities\/macros.hpp\"\n+\n+#include <new>\n@@ -474,1 +476,0 @@\n-  friend class CodeSection;\n@@ -477,4 +478,51 @@\n-  \/\/ this preallocated memory must accommodate all subclasses of Relocation\n-  \/\/ (this number is assertion-checked in Relocation::operator new)\n-  enum { _relocbuf_size = 5 };\n-  void* _relocbuf[ _relocbuf_size ];\n+  \/\/ A Relocation is \"held\" by placement constructing a Relocation into\n+  \/\/ _relocbuf. Hence, _relocbuf must accomodate all subclasses of\n+  \/\/ Relocation. We also need the Relocation base class to be at the same\n+  \/\/ address as the start of the object, e.g. at the address of _relocbuf.\n+  \/\/ Both of these requirements are checked in the constructors (see\n+  \/\/ check_reloc_type and check_reloc_placement).  The placement of the base\n+  \/\/ class subobject isn't guaranteed by C++, since these aren't standard\n+  \/\/ layout classes, but all supported implementations provide that behavior.\n+  \/\/ If that changes, we can instead add a Relocation* _reloc member to\n+  \/\/ capture the result of the placement new, and use that to access the base\n+  \/\/ subobject.\n+  static const size_t _relocbuf_size = 5 * sizeof(void*);\n+  union {\n+    char _relocbuf[_relocbuf_size];\n+    void* alignment_dummy;\n+  };\n+\n+  template<typename Reloc>\n+  void check_reloc_type() {\n+    static_assert(std::is_base_of<Relocation, Reloc>::value, \"not Relocation\");\n+    static_assert(sizeof(Reloc) <= sizeof(_relocbuf), \"_relocbuf too small\");\n+  }\n+\n+  \/\/ Used to verify that the base class subobject of the object constructed\n+  \/\/ into _relocbuf is at the same address as the derived object.\n+  void check_reloc_placement(const Relocation* reloc) const {\n+    assert(static_cast<const void*>(reloc) == _relocbuf, \"invariant\");\n+  }\n+\n+  \/\/ Support for Relocation::copy_into.\n+  \/\/ reloc should be a most derived object.\n+  template<typename Reloc>\n+  void copy_into_impl(const Reloc& reloc) {\n+    check_reloc_type<Reloc>();\n+    Relocation* copy = ::new (_relocbuf) Reloc(reloc);\n+    check_reloc_placement(copy);\n+  }\n+\n+  \/\/ Support for construct().\n+  \/\/ ctor is a function object of one argument, the _relocbuf.  It should\n+  \/\/ construct a relocation object in the given buffer and return a pointer to\n+  \/\/ that new relocation object.\n+  struct Construct {};          \/\/ Tag for selecting this constructor.\n+  template<typename C> RelocationHolder(Construct, C ctor) {\n+    using RelocPtr = decltype(ctor(_relocbuf));\n+    static_assert(std::is_pointer<RelocPtr>::value, \"expected relocation pointer\");\n+    using Reloc = std::remove_pointer_t<RelocPtr>;\n+    check_reloc_type<Reloc>();\n+    Relocation* reloc = ctor(_relocbuf);\n+    check_reloc_placement(reloc);\n+  }\n@@ -483,1 +531,1 @@\n-  Relocation* reloc() const { return (Relocation*) &_relocbuf[0]; }\n+  Relocation* reloc() const { return (Relocation*)_relocbuf; }\n@@ -489,1 +537,11 @@\n-  inline RelocationHolder();                \/\/ initializes type to none\n+  \/\/ Return a holder containing a relocation of type T, constructed using args.\n+  template<typename T, typename... Args>\n+  static RelocationHolder construct(const Args&... args) {\n+    return RelocationHolder(Construct(),\n+                            [&] (void* p) {\n+                              return ::new (p) T(args...);\n+                            });\n+  }\n+\n+  RelocationHolder();           \/\/ Initializes type to none.\n+  ~RelocationHolder() = default;\n@@ -491,1 +549,2 @@\n-  inline RelocationHolder(Relocation* r);   \/\/ make a copy\n+  RelocationHolder(const RelocationHolder& from);\n+  RelocationHolder& operator=(const RelocationHolder& from);\n@@ -639,1 +698,0 @@\n-  friend class RelocationHolder;\n@@ -661,1 +719,1 @@\n-  Relocation(relocInfo::relocType rtype) : _binding(NULL), _rtype(rtype) { }\n+  explicit Relocation(relocInfo::relocType rtype) : _binding(NULL), _rtype(rtype) { }\n@@ -663,2 +721,7 @@\n-  static RelocationHolder newHolder() {\n-    return RelocationHolder();\n+  \/\/ Helper for copy_into functions for derived classes.\n+  \/\/ Forwards operation to RelocationHolder::copy_into_impl so that\n+  \/\/ RelocationHolder only needs to befriend this class, rather than all\n+  \/\/ derived classes that implement copy_into.\n+  template<typename Reloc>\n+  static void copy_into_helper(const Reloc& reloc, RelocationHolder& holder) {\n+    holder.copy_into_impl(reloc);\n@@ -668,6 +731,0 @@\n-  void* operator new(size_t size, const RelocationHolder& holder) throw() {\n-    assert(size <= sizeof(holder._relocbuf), \"Make _relocbuf bigger!\");\n-    assert((void* const *)holder.reloc() == &holder._relocbuf[0], \"ptrs must agree\");\n-    return holder.reloc();\n-  }\n-\n@@ -796,0 +853,9 @@\n+  \/\/ Make a filler relocation.\n+  Relocation() : Relocation(relocInfo::none) {}\n+\n+  \/\/ Intentionally public non-virtual destructor, even though polymorphic.\n+  \/\/ We never heap allocate a Relocation, so never delete through a base pointer.\n+  \/\/ RelocationHolder depends on (and verifies) the destructor for all relocation\n+  \/\/ types is trivial, so can't be virtual.\n+  ~Relocation() = default;\n+\n@@ -798,0 +864,3 @@\n+  \/\/ Copy this relocation into holder.\n+  virtual void copy_into(RelocationHolder& holder) const;\n+\n@@ -821,4 +890,3 @@\n-inline RelocationHolder::RelocationHolder() {\n-  \/\/ initialize the vtbl, just to keep things type-safe\n-  new(*this) Relocation(relocInfo::none);\n-}\n+inline RelocationHolder::RelocationHolder() :\n+  RelocationHolder(Construct(), [&] (void* p) { return ::new (p) Relocation(); })\n+{}\n@@ -826,0 +894,3 @@\n+inline RelocationHolder::RelocationHolder(const RelocationHolder& from) {\n+  from.reloc()->copy_into(*this);\n+}\n@@ -827,5 +898,5 @@\n-inline RelocationHolder::RelocationHolder(Relocation* r) {\n-  \/\/ wordwise copy from r (ok if it copies garbage after r)\n-  for (int i = 0; i < _relocbuf_size; i++) {\n-    _relocbuf[i] = ((void**)r)[i];\n-  }\n+inline RelocationHolder& RelocationHolder::operator=(const RelocationHolder& from) {\n+  \/\/ All Relocation types are trivially destructible (verified in .cpp file),\n+  \/\/ so we don't need to destruct our old value before copying over it.\n+  from.reloc()->copy_into(*this);\n+  return *this;\n@@ -879,1 +950,1 @@\n-  friend class RelocIterator;\n+  friend class RelocationHolder;\n@@ -885,3 +956,1 @@\n-    RelocationHolder rh = newHolder();\n-    new(rh) post_call_nop_Relocation();\n-    return rh;\n+    return RelocationHolder::construct<post_call_nop_Relocation>();\n@@ -889,0 +958,2 @@\n+\n+  void copy_into(RelocationHolder& holder) const;\n@@ -892,1 +963,1 @@\n-  friend class RelocIterator;\n+  friend class RelocationHolder;\n@@ -898,3 +969,1 @@\n-    RelocationHolder rh = newHolder();\n-    new(rh) entry_guard_Relocation();\n-    return rh;\n+    return RelocationHolder::construct<entry_guard_Relocation>();\n@@ -902,0 +971,2 @@\n+\n+  void copy_into(RelocationHolder& holder) const;\n@@ -926,3 +997,1 @@\n-    RelocationHolder rh = newHolder();\n-    new(rh) oop_Relocation(oop_index, offset);\n-    return rh;\n+    return RelocationHolder::construct<oop_Relocation>(oop_index, offset);\n@@ -936,5 +1005,1 @@\n-    const int oop_index = 0;\n-    const int offset    = 0;    \/\/ if you want an offset, use the oop pool\n-    RelocationHolder rh = newHolder();\n-    new(rh) oop_Relocation(oop_index, offset);\n-    return rh;\n+    return RelocationHolder::construct<oop_Relocation>(0, 0);\n@@ -943,0 +1008,2 @@\n+  void copy_into(RelocationHolder& holder) const;\n+\n@@ -950,1 +1017,1 @@\n-  friend class RelocIterator;\n+  friend class RelocationHolder;\n@@ -983,3 +1050,1 @@\n-    RelocationHolder rh = newHolder();\n-    new(rh) metadata_Relocation(metadata_index, offset);\n-    return rh;\n+    return RelocationHolder::construct<metadata_Relocation>(metadata_index, offset);\n@@ -989,5 +1054,1 @@\n-    const int metadata_index = 0;\n-    const int offset    = 0;    \/\/ if you want an offset, use the metadata pool\n-    RelocationHolder rh = newHolder();\n-    new(rh) metadata_Relocation(metadata_index, offset);\n-    return rh;\n+    return RelocationHolder::construct<metadata_Relocation>(0, 0);\n@@ -996,0 +1057,2 @@\n+  void copy_into(RelocationHolder& holder) const;\n+\n@@ -1003,1 +1066,1 @@\n-  friend class RelocIterator;\n+  friend class RelocationHolder;\n@@ -1038,3 +1101,1 @@\n-    RelocationHolder rh = newHolder();\n-    new(rh) virtual_call_Relocation(cached_value, method_index);\n-    return rh;\n+    return RelocationHolder::construct<virtual_call_Relocation>(cached_value, method_index);\n@@ -1043,0 +1104,2 @@\n+  void copy_into(RelocationHolder& holder) const;\n+\n@@ -1054,1 +1117,1 @@\n-  friend class RelocIterator;\n+  friend class RelocationHolder;\n@@ -1077,3 +1140,1 @@\n-    RelocationHolder rh = newHolder();\n-    new(rh) opt_virtual_call_Relocation(method_index);\n-    return rh;\n+    return RelocationHolder::construct<opt_virtual_call_Relocation>(method_index);\n@@ -1082,0 +1143,2 @@\n+  void copy_into(RelocationHolder& holder) const;\n+\n@@ -1089,1 +1152,1 @@\n-  friend class RelocIterator;\n+  friend class RelocationHolder;\n@@ -1109,3 +1172,1 @@\n-    RelocationHolder rh = newHolder();\n-    new(rh) static_call_Relocation(method_index);\n-    return rh;\n+    return RelocationHolder::construct<static_call_Relocation>(method_index);\n@@ -1114,0 +1175,2 @@\n+  void copy_into(RelocationHolder& holder) const;\n+\n@@ -1121,1 +1184,1 @@\n-  friend class RelocIterator;\n+  friend class RelocationHolder;\n@@ -1140,3 +1203,1 @@\n-    RelocationHolder rh = newHolder();\n-    new(rh) static_stub_Relocation(static_call);\n-    return rh;\n+    return RelocationHolder::construct<static_stub_Relocation>(static_call);\n@@ -1145,0 +1206,2 @@\n+  void copy_into(RelocationHolder& holder) const;\n+\n@@ -1152,1 +1215,1 @@\n-  friend class RelocIterator;\n+  friend class RelocationHolder;\n@@ -1169,3 +1232,1 @@\n-    RelocationHolder rh = newHolder();\n-    new(rh) runtime_call_Relocation();\n-    return rh;\n+    return RelocationHolder::construct<runtime_call_Relocation>();\n@@ -1174,0 +1235,2 @@\n+  void copy_into(RelocationHolder& holder) const;\n+\n@@ -1175,1 +1238,1 @@\n-  friend class RelocIterator;\n+  friend class RelocationHolder;\n@@ -1177,2 +1240,0 @@\n-\n- public:\n@@ -1185,3 +1246,1 @@\n-    RelocationHolder rh = newHolder();\n-    new(rh) runtime_call_w_cp_Relocation();\n-    return rh;\n+    return RelocationHolder::construct<runtime_call_w_cp_Relocation>();\n@@ -1190,0 +1249,2 @@\n+  void copy_into(RelocationHolder& holder) const;\n+\n@@ -1191,1 +1252,1 @@\n-  friend class RelocIterator;\n+  friend class RelocationHolder;\n@@ -1221,2 +1282,1 @@\n-    RelocationHolder rh = newHolder();\n-    return (new (rh) trampoline_stub_Relocation(static_call));\n+    return RelocationHolder::construct<trampoline_stub_Relocation>(static_call);\n@@ -1225,0 +1285,2 @@\n+  void copy_into(RelocationHolder& holder) const;\n+\n@@ -1232,1 +1294,1 @@\n-  friend class RelocIterator;\n+  friend class RelocationHolder;\n@@ -1251,3 +1313,1 @@\n-    RelocationHolder rh = newHolder();\n-    new(rh) external_word_Relocation(target);\n-    return rh;\n+    return RelocationHolder::construct<external_word_Relocation>(target);\n@@ -1259,3 +1319,1 @@\n-    RelocationHolder rh = newHolder();\n-    new(rh) external_word_Relocation(NULL);\n-    return rh;\n+    return RelocationHolder::construct<external_word_Relocation>(nullptr);\n@@ -1264,0 +1322,2 @@\n+  void copy_into(RelocationHolder& holder) const;\n+\n@@ -1277,1 +1337,1 @@\n-  friend class RelocIterator;\n+  friend class RelocationHolder;\n@@ -1299,3 +1359,1 @@\n-    RelocationHolder rh = newHolder();\n-    new(rh) internal_word_Relocation(target);\n-    return rh;\n+    return RelocationHolder::construct<internal_word_Relocation>(target);\n@@ -1306,3 +1364,1 @@\n-    RelocationHolder rh = newHolder();\n-    new(rh) internal_word_Relocation(NULL);\n-    return rh;\n+    return RelocationHolder::construct<internal_word_Relocation>(nullptr);\n@@ -1311,0 +1367,2 @@\n+  void copy_into(RelocationHolder& holder) const;\n+\n@@ -1320,1 +1378,1 @@\n-  friend class RelocIterator;\n+  friend class RelocationHolder;\n@@ -1344,3 +1402,1 @@\n-    RelocationHolder rh = newHolder();\n-    new(rh) section_word_Relocation(target, section);\n-    return rh;\n+    return RelocationHolder::construct<section_word_Relocation>(target, section);\n@@ -1349,0 +1405,2 @@\n+  void copy_into(RelocationHolder& holder) const;\n+\n@@ -1359,1 +1417,1 @@\n-  friend class RelocIterator;\n+  friend class RelocationHolder;\n@@ -1369,0 +1427,2 @@\n+\n+  void copy_into(RelocationHolder& holder) const;\n@@ -1374,0 +1434,2 @@\n+\n+  void copy_into(RelocationHolder& holder) const;\n@@ -1377,9 +1439,9 @@\n-#define EACH_CASE(name)                                         \\\n-inline name##_Relocation* RelocIterator::name##_reloc() {       \\\n-  assert(type() == relocInfo::name##_type, \"type must agree\");  \\\n-  \/* The purpose of the placed \"new\" is to re-use the same *\/   \\\n-  \/* stack storage for each new iteration. *\/                   \\\n-  name##_Relocation* r = new(_rh) name##_Relocation();          \\\n-  r->set_binding(this);                                         \\\n-  r->name##_Relocation::unpack_data();                          \\\n-  return r;                                                     \\\n+#define EACH_CASE_AUX(Accessor, Reloc)                                  \\\n+inline Reloc* RelocIterator::Accessor() {                               \\\n+  static const RelocationHolder proto = RelocationHolder::construct<Reloc>(); \\\n+  assert(type() == proto.type(), \"type must agree\");                    \\\n+  _rh = proto;                                                          \\\n+  Reloc* r = static_cast<Reloc*>(_rh.reloc());                          \\\n+  r->set_binding(this);                                                 \\\n+  r->Reloc::unpack_data();                                              \\\n+  return r;                                                             \\\n@@ -1387,0 +1449,2 @@\n+#define EACH_CASE(name) \\\n+  EACH_CASE_AUX(PASTE_TOKENS(name, _reloc), PASTE_TOKENS(name, _Relocation))\n@@ -1388,0 +1452,1 @@\n+#undef EACH_CASE_AUX\n","filename":"src\/hotspot\/share\/code\/relocInfo.hpp","additions":175,"deletions":110,"binary":false,"changes":285,"status":"modified"}]}