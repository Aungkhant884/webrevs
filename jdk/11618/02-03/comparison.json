{"files":[{"patch":"@@ -259,1 +259,5 @@\n-\/\/ Define all the copy_into functions.\n+\/\/ Define all the copy_into functions.  These rely on all Relocation types\n+\/\/ being trivially destructible (verified above).  So it doesn't matter\n+\/\/ whether the target holder has been previously initialized or not.  There's\n+\/\/ no need to consider that distinction and destruct the relocation in an\n+\/\/ already initialized holder.\n","filename":"src\/hotspot\/share\/code\/relocInfo.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -846,1 +846,1 @@\n-  \/\/ types is trivial, so can't be virtual.\n+  \/\/ types is trivial, so this must not be virtual (and hence non-trivial).\n@@ -888,0 +888,1 @@\n+  \/\/ If not for that we would need to decide what to do about self-assignment.\n@@ -992,1 +993,3 @@\n-    return RelocationHolder::construct<oop_Relocation>(0, 0);\n+    const int oop_index = 0;\n+    const int offset    = 0;    \/\/ if you want an offset, use the oop pool\n+    return RelocationHolder::construct<oop_Relocation>(oop_index, offset);\n@@ -1041,1 +1044,3 @@\n-    return RelocationHolder::construct<metadata_Relocation>(0, 0);\n+    const int metadata_index = 0;\n+    const int offset    = 0;    \/\/ if you want an offset, use the metadata pool\n+    return RelocationHolder::construct<metadata_Relocation>(metadata_index, offset);\n","filename":"src\/hotspot\/share\/code\/relocInfo.hpp","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"}]}