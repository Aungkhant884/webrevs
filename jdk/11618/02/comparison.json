{"files":[{"patch":"@@ -2498,1 +2498,1 @@\n-  emit_data(disp, rspec.reloc(), call32_operand);\n+  emit_data(disp, rspec, call32_operand);\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -39,0 +39,3 @@\n+#include <new>\n+#include <type_traits>\n+\n@@ -238,1 +241,2 @@\n-  return new(_rh) Relocation(t);\n+  _rh = RelocationHolder::none;\n+  return _rh.reloc();\n@@ -241,0 +245,4 @@\n+\/\/ Verify all the destructors are trivial, so we don't need to worry about\n+\/\/ destroying old contents of a RelocationHolder being assigned.\n+#define VERIFY_TRIVIALLY_DESTRUCTIBLE_AUX(Reloc) \\\n+  static_assert(std::is_trivially_destructible<Reloc>::value, \"must be\");\n@@ -242,1 +250,14 @@\n-\/\/\/\/\/\/\/\/ Methods for flyweight Relocation types\n+#define VERIFY_TRIVIALLY_DESTRUCTIBLE(name) \\\n+  VERIFY_TRIVIALLY_DESTRUCTIBLE_AUX(PASTE_TOKENS(name, _Relocation));\n+\n+APPLY_TO_RELOCATIONS(VERIFY_TRIVIALLY_DESTRUCTIBLE)\n+VERIFY_TRIVIALLY_DESTRUCTIBLE_AUX(Relocation)\n+\n+#undef VERIFY_TRIVIALLY_DESTRUCTIBLE_AUX\n+#undef VERIFY_TRIVIALLY_DESTRUCTIBLE\n+\n+\/\/ Define all the copy_into functions.\n+#define DEFINE_COPY_INTO_AUX(Reloc)                             \\\n+  void Reloc::copy_into(RelocationHolder& holder) const {       \\\n+    copy_into_helper(*this, holder);                            \\\n+  }\n@@ -244,0 +265,10 @@\n+#define DEFINE_COPY_INTO(name) \\\n+  DEFINE_COPY_INTO_AUX(PASTE_TOKENS(name, _Relocation))\n+\n+APPLY_TO_RELOCATIONS(DEFINE_COPY_INTO)\n+DEFINE_COPY_INTO_AUX(Relocation)\n+\n+#undef DEFINE_COPY_INTO_AUX\n+#undef DEFINE_COPY_INTO\n+\n+\/\/\/\/\/\/\/\/ Methods for RelocationHolder\n@@ -267,0 +298,2 @@\n+\/\/\/\/\/\/\/\/ Methods for flyweight Relocation types\n+\n","filename":"src\/hotspot\/share\/code\/relocInfo.cpp","additions":35,"deletions":2,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-#include \"utilities\/macros.hpp\"\n@@ -33,0 +32,3 @@\n+#include \"utilities\/macros.hpp\"\n+\n+#include <new>\n@@ -474,1 +476,0 @@\n-  friend class CodeSection;\n@@ -477,4 +478,41 @@\n-  \/\/ this preallocated memory must accommodate all subclasses of Relocation\n-  \/\/ (this number is assertion-checked in Relocation::operator new)\n-  enum { _relocbuf_size = 5 };\n-  void* _relocbuf[ _relocbuf_size ];\n+  \/\/ A Relocation is \"held\" by placement constructing a Relocation into\n+  \/\/ _relocbuf. Hence, _relocbuf must accomodate all subclasses of\n+  \/\/ Relocation. We also need the Relocation base class to be at the same\n+  \/\/ address as the start of the object, e.g. at the address of _relocbuf.\n+  \/\/ Both of these requirements are checked in the constructors (see\n+  \/\/ check_reloc_type and check_reloc_placement).  The placement of the base\n+  \/\/ class subobject isn't guaranteed by C++, since these aren't standard\n+  \/\/ layout classes, but all supported implementations provide that behavior.\n+  \/\/ If that changes, we can instead add a Relocation* _reloc member to\n+  \/\/ capture the result of the placement new, and use that to access the base\n+  \/\/ subobject.\n+  static const size_t _relocbuf_size = 5 * sizeof(void*);\n+  alignas(void*) char _relocbuf[_relocbuf_size];\n+\n+  template<typename Reloc, typename... Args>\n+  void emplace_relocation(const Args&... args) {\n+    static_assert(std::is_base_of<Relocation, Reloc>::value, \"not Relocation\");\n+    static_assert(sizeof(Reloc) <= sizeof(_relocbuf), \"_relocbuf too small\");\n+    Relocation* reloc = ::new (_relocbuf) Reloc(args...);\n+    \/\/ Verify the base class subobject of the object constructed into\n+    \/\/ _relocbuf is at the same address as the derived object.\n+    assert(static_cast<const void*>(reloc) == _relocbuf, \"invariant\");\n+  }\n+\n+  \/\/ Support for Relocation::copy_into.\n+  \/\/ reloc should be a most derived object.\n+  template<typename Reloc>\n+  void copy_into_impl(const Reloc& reloc) {\n+    emplace_relocation<Reloc>(reloc);\n+  }\n+\n+  \/\/ Tag for selecting the constructor below and carrying the type of the\n+  \/\/ relocation object the new holder will (initially) contain.\n+  template<typename Reloc> struct Construct {};\n+\n+  \/\/ Constructor used by construct().  Constructs a new holder containing a\n+  \/\/ relocation of type Reloc that is constructed using the provided args.\n+  template<typename Reloc, typename... Args>\n+  RelocationHolder(Construct<Reloc>, const Args&... args) {\n+    emplace_relocation<Reloc>(args...);\n+  }\n@@ -483,1 +521,1 @@\n-  Relocation* reloc() const { return (Relocation*) &_relocbuf[0]; }\n+  Relocation* reloc() const { return (Relocation*)_relocbuf; }\n@@ -489,1 +527,8 @@\n-  inline RelocationHolder();                \/\/ initializes type to none\n+  \/\/ Return a holder containing a relocation of type Reloc, constructed using args.\n+  template<typename Reloc, typename... Args>\n+  static RelocationHolder construct(const Args&... args) {\n+    return RelocationHolder(Construct<Reloc>(), args...);\n+  }\n+\n+  RelocationHolder();           \/\/ Initializes type to none.\n+  ~RelocationHolder() = default;\n@@ -491,1 +536,2 @@\n-  inline RelocationHolder(Relocation* r);   \/\/ make a copy\n+  RelocationHolder(const RelocationHolder& from);\n+  RelocationHolder& operator=(const RelocationHolder& from);\n@@ -639,1 +685,0 @@\n-  friend class RelocationHolder;\n@@ -661,1 +706,1 @@\n-  Relocation(relocInfo::relocType rtype) : _binding(NULL), _rtype(rtype) { }\n+  explicit Relocation(relocInfo::relocType rtype) : _binding(NULL), _rtype(rtype) { }\n@@ -663,2 +708,7 @@\n-  static RelocationHolder newHolder() {\n-    return RelocationHolder();\n+  \/\/ Helper for copy_into functions for derived classes.\n+  \/\/ Forwards operation to RelocationHolder::copy_into_impl so that\n+  \/\/ RelocationHolder only needs to befriend this class, rather than all\n+  \/\/ derived classes that implement copy_into.\n+  template<typename Reloc>\n+  static void copy_into_helper(const Reloc& reloc, RelocationHolder& holder) {\n+    holder.copy_into_impl(reloc);\n@@ -668,6 +718,0 @@\n-  void* operator new(size_t size, const RelocationHolder& holder) throw() {\n-    assert(size <= sizeof(holder._relocbuf), \"Make _relocbuf bigger!\");\n-    assert((void* const *)holder.reloc() == &holder._relocbuf[0], \"ptrs must agree\");\n-    return holder.reloc();\n-  }\n-\n@@ -796,0 +840,9 @@\n+  \/\/ Make a filler relocation.\n+  Relocation() : Relocation(relocInfo::none) {}\n+\n+  \/\/ Intentionally public non-virtual destructor, even though polymorphic.\n+  \/\/ We never heap allocate a Relocation, so never delete through a base pointer.\n+  \/\/ RelocationHolder depends on (and verifies) the destructor for all relocation\n+  \/\/ types is trivial, so can't be virtual.\n+  ~Relocation() = default;\n+\n@@ -798,0 +851,3 @@\n+  \/\/ Copy this relocation into holder.\n+  virtual void copy_into(RelocationHolder& holder) const;\n+\n@@ -821,4 +877,3 @@\n-inline RelocationHolder::RelocationHolder() {\n-  \/\/ initialize the vtbl, just to keep things type-safe\n-  new(*this) Relocation(relocInfo::none);\n-}\n+inline RelocationHolder::RelocationHolder() :\n+  RelocationHolder(Construct<Relocation>())\n+{}\n@@ -826,0 +881,3 @@\n+inline RelocationHolder::RelocationHolder(const RelocationHolder& from) {\n+  from.reloc()->copy_into(*this);\n+}\n@@ -827,5 +885,5 @@\n-inline RelocationHolder::RelocationHolder(Relocation* r) {\n-  \/\/ wordwise copy from r (ok if it copies garbage after r)\n-  for (int i = 0; i < _relocbuf_size; i++) {\n-    _relocbuf[i] = ((void**)r)[i];\n-  }\n+inline RelocationHolder& RelocationHolder::operator=(const RelocationHolder& from) {\n+  \/\/ All Relocation types are trivially destructible (verified in .cpp file),\n+  \/\/ so we don't need to destruct our old value before copying over it.\n+  from.reloc()->copy_into(*this);\n+  return *this;\n@@ -879,1 +937,1 @@\n-  friend class RelocIterator;\n+  friend class RelocationHolder;\n@@ -885,3 +943,1 @@\n-    RelocationHolder rh = newHolder();\n-    new(rh) post_call_nop_Relocation();\n-    return rh;\n+    return RelocationHolder::construct<post_call_nop_Relocation>();\n@@ -889,0 +945,2 @@\n+\n+  void copy_into(RelocationHolder& holder) const;\n@@ -892,1 +950,1 @@\n-  friend class RelocIterator;\n+  friend class RelocationHolder;\n@@ -898,3 +956,1 @@\n-    RelocationHolder rh = newHolder();\n-    new(rh) entry_guard_Relocation();\n-    return rh;\n+    return RelocationHolder::construct<entry_guard_Relocation>();\n@@ -902,0 +958,2 @@\n+\n+  void copy_into(RelocationHolder& holder) const;\n@@ -926,3 +984,1 @@\n-    RelocationHolder rh = newHolder();\n-    new(rh) oop_Relocation(oop_index, offset);\n-    return rh;\n+    return RelocationHolder::construct<oop_Relocation>(oop_index, offset);\n@@ -936,5 +992,1 @@\n-    const int oop_index = 0;\n-    const int offset    = 0;    \/\/ if you want an offset, use the oop pool\n-    RelocationHolder rh = newHolder();\n-    new(rh) oop_Relocation(oop_index, offset);\n-    return rh;\n+    return RelocationHolder::construct<oop_Relocation>(0, 0);\n@@ -943,0 +995,2 @@\n+  void copy_into(RelocationHolder& holder) const;\n+\n@@ -950,1 +1004,1 @@\n-  friend class RelocIterator;\n+  friend class RelocationHolder;\n@@ -983,3 +1037,1 @@\n-    RelocationHolder rh = newHolder();\n-    new(rh) metadata_Relocation(metadata_index, offset);\n-    return rh;\n+    return RelocationHolder::construct<metadata_Relocation>(metadata_index, offset);\n@@ -989,5 +1041,1 @@\n-    const int metadata_index = 0;\n-    const int offset    = 0;    \/\/ if you want an offset, use the metadata pool\n-    RelocationHolder rh = newHolder();\n-    new(rh) metadata_Relocation(metadata_index, offset);\n-    return rh;\n+    return RelocationHolder::construct<metadata_Relocation>(0, 0);\n@@ -996,0 +1044,2 @@\n+  void copy_into(RelocationHolder& holder) const;\n+\n@@ -1003,1 +1053,1 @@\n-  friend class RelocIterator;\n+  friend class RelocationHolder;\n@@ -1038,3 +1088,1 @@\n-    RelocationHolder rh = newHolder();\n-    new(rh) virtual_call_Relocation(cached_value, method_index);\n-    return rh;\n+    return RelocationHolder::construct<virtual_call_Relocation>(cached_value, method_index);\n@@ -1043,0 +1091,2 @@\n+  void copy_into(RelocationHolder& holder) const;\n+\n@@ -1054,1 +1104,1 @@\n-  friend class RelocIterator;\n+  friend class RelocationHolder;\n@@ -1077,3 +1127,1 @@\n-    RelocationHolder rh = newHolder();\n-    new(rh) opt_virtual_call_Relocation(method_index);\n-    return rh;\n+    return RelocationHolder::construct<opt_virtual_call_Relocation>(method_index);\n@@ -1082,0 +1130,2 @@\n+  void copy_into(RelocationHolder& holder) const;\n+\n@@ -1089,1 +1139,1 @@\n-  friend class RelocIterator;\n+  friend class RelocationHolder;\n@@ -1109,3 +1159,1 @@\n-    RelocationHolder rh = newHolder();\n-    new(rh) static_call_Relocation(method_index);\n-    return rh;\n+    return RelocationHolder::construct<static_call_Relocation>(method_index);\n@@ -1114,0 +1162,2 @@\n+  void copy_into(RelocationHolder& holder) const;\n+\n@@ -1121,1 +1171,1 @@\n-  friend class RelocIterator;\n+  friend class RelocationHolder;\n@@ -1140,3 +1190,1 @@\n-    RelocationHolder rh = newHolder();\n-    new(rh) static_stub_Relocation(static_call);\n-    return rh;\n+    return RelocationHolder::construct<static_stub_Relocation>(static_call);\n@@ -1145,0 +1193,2 @@\n+  void copy_into(RelocationHolder& holder) const;\n+\n@@ -1152,1 +1202,1 @@\n-  friend class RelocIterator;\n+  friend class RelocationHolder;\n@@ -1169,3 +1219,1 @@\n-    RelocationHolder rh = newHolder();\n-    new(rh) runtime_call_Relocation();\n-    return rh;\n+    return RelocationHolder::construct<runtime_call_Relocation>();\n@@ -1174,0 +1222,2 @@\n+  void copy_into(RelocationHolder& holder) const;\n+\n@@ -1175,1 +1225,1 @@\n-  friend class RelocIterator;\n+  friend class RelocationHolder;\n@@ -1177,2 +1227,0 @@\n-\n- public:\n@@ -1185,3 +1233,1 @@\n-    RelocationHolder rh = newHolder();\n-    new(rh) runtime_call_w_cp_Relocation();\n-    return rh;\n+    return RelocationHolder::construct<runtime_call_w_cp_Relocation>();\n@@ -1190,0 +1236,2 @@\n+  void copy_into(RelocationHolder& holder) const;\n+\n@@ -1191,1 +1239,1 @@\n-  friend class RelocIterator;\n+  friend class RelocationHolder;\n@@ -1221,2 +1269,1 @@\n-    RelocationHolder rh = newHolder();\n-    return (new (rh) trampoline_stub_Relocation(static_call));\n+    return RelocationHolder::construct<trampoline_stub_Relocation>(static_call);\n@@ -1225,0 +1272,2 @@\n+  void copy_into(RelocationHolder& holder) const;\n+\n@@ -1232,1 +1281,1 @@\n-  friend class RelocIterator;\n+  friend class RelocationHolder;\n@@ -1251,3 +1300,1 @@\n-    RelocationHolder rh = newHolder();\n-    new(rh) external_word_Relocation(target);\n-    return rh;\n+    return RelocationHolder::construct<external_word_Relocation>(target);\n@@ -1259,3 +1306,1 @@\n-    RelocationHolder rh = newHolder();\n-    new(rh) external_word_Relocation(NULL);\n-    return rh;\n+    return RelocationHolder::construct<external_word_Relocation>(nullptr);\n@@ -1264,0 +1309,2 @@\n+  void copy_into(RelocationHolder& holder) const;\n+\n@@ -1277,1 +1324,1 @@\n-  friend class RelocIterator;\n+  friend class RelocationHolder;\n@@ -1299,3 +1346,1 @@\n-    RelocationHolder rh = newHolder();\n-    new(rh) internal_word_Relocation(target);\n-    return rh;\n+    return RelocationHolder::construct<internal_word_Relocation>(target);\n@@ -1306,3 +1351,1 @@\n-    RelocationHolder rh = newHolder();\n-    new(rh) internal_word_Relocation(NULL);\n-    return rh;\n+    return RelocationHolder::construct<internal_word_Relocation>(nullptr);\n@@ -1311,0 +1354,2 @@\n+  void copy_into(RelocationHolder& holder) const;\n+\n@@ -1320,1 +1365,1 @@\n-  friend class RelocIterator;\n+  friend class RelocationHolder;\n@@ -1344,3 +1389,1 @@\n-    RelocationHolder rh = newHolder();\n-    new(rh) section_word_Relocation(target, section);\n-    return rh;\n+    return RelocationHolder::construct<section_word_Relocation>(target, section);\n@@ -1349,0 +1392,2 @@\n+  void copy_into(RelocationHolder& holder) const;\n+\n@@ -1359,1 +1404,1 @@\n-  friend class RelocIterator;\n+  friend class RelocationHolder;\n@@ -1369,0 +1414,2 @@\n+\n+  void copy_into(RelocationHolder& holder) const;\n@@ -1374,0 +1421,2 @@\n+\n+  void copy_into(RelocationHolder& holder) const;\n@@ -1377,9 +1426,9 @@\n-#define EACH_CASE(name)                                         \\\n-inline name##_Relocation* RelocIterator::name##_reloc() {       \\\n-  assert(type() == relocInfo::name##_type, \"type must agree\");  \\\n-  \/* The purpose of the placed \"new\" is to re-use the same *\/   \\\n-  \/* stack storage for each new iteration. *\/                   \\\n-  name##_Relocation* r = new(_rh) name##_Relocation();          \\\n-  r->set_binding(this);                                         \\\n-  r->name##_Relocation::unpack_data();                          \\\n-  return r;                                                     \\\n+#define EACH_CASE_AUX(Accessor, Reloc)                                  \\\n+inline Reloc* RelocIterator::Accessor() {                               \\\n+  static const RelocationHolder proto = RelocationHolder::construct<Reloc>(); \\\n+  assert(type() == proto.type(), \"type must agree\");                    \\\n+  _rh = proto;                                                          \\\n+  Reloc* r = static_cast<Reloc*>(_rh.reloc());                          \\\n+  r->set_binding(this);                                                 \\\n+  r->Reloc::unpack_data();                                              \\\n+  return r;                                                             \\\n@@ -1387,0 +1436,2 @@\n+#define EACH_CASE(name) \\\n+  EACH_CASE_AUX(PASTE_TOKENS(name, _reloc), PASTE_TOKENS(name, _Relocation))\n@@ -1388,0 +1439,1 @@\n+#undef EACH_CASE_AUX\n","filename":"src\/hotspot\/share\/code\/relocInfo.hpp","additions":162,"deletions":110,"binary":false,"changes":272,"status":"modified"}]}