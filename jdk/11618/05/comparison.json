{"files":[{"patch":"@@ -2498,1 +2498,1 @@\n-  emit_data(disp, rspec.reloc(), call32_operand);\n+  emit_data(disp, rspec, call32_operand);\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -39,0 +39,3 @@\n+#include <new>\n+#include <type_traits>\n+\n@@ -238,1 +241,2 @@\n-  return new(_rh) Relocation(t);\n+  _rh = RelocationHolder::none;\n+  return _rh.reloc();\n@@ -241,0 +245,4 @@\n+\/\/ Verify all the destructors are trivial, so we don't need to worry about\n+\/\/ destroying old contents of a RelocationHolder being assigned or destroyed.\n+#define VERIFY_TRIVIALLY_DESTRUCTIBLE_AUX(Reloc) \\\n+  static_assert(std::is_trivially_destructible<Reloc>::value, \"must be\");\n@@ -242,1 +250,18 @@\n-\/\/\/\/\/\/\/\/ Methods for flyweight Relocation types\n+#define VERIFY_TRIVIALLY_DESTRUCTIBLE(name) \\\n+  VERIFY_TRIVIALLY_DESTRUCTIBLE_AUX(PASTE_TOKENS(name, _Relocation));\n+\n+APPLY_TO_RELOCATIONS(VERIFY_TRIVIALLY_DESTRUCTIBLE)\n+VERIFY_TRIVIALLY_DESTRUCTIBLE_AUX(Relocation)\n+\n+#undef VERIFY_TRIVIALLY_DESTRUCTIBLE_AUX\n+#undef VERIFY_TRIVIALLY_DESTRUCTIBLE\n+\n+\/\/ Define all the copy_into functions.  These rely on all Relocation types\n+\/\/ being trivially destructible (verified above).  So it doesn't matter\n+\/\/ whether the target holder has been previously initialized or not.  There's\n+\/\/ no need to consider that distinction and destruct the relocation in an\n+\/\/ already initialized holder.\n+#define DEFINE_COPY_INTO_AUX(Reloc)                             \\\n+  void Reloc::copy_into(RelocationHolder& holder) const {       \\\n+    copy_into_helper(*this, holder);                            \\\n+  }\n@@ -244,0 +269,10 @@\n+#define DEFINE_COPY_INTO(name) \\\n+  DEFINE_COPY_INTO_AUX(PASTE_TOKENS(name, _Relocation))\n+\n+APPLY_TO_RELOCATIONS(DEFINE_COPY_INTO)\n+DEFINE_COPY_INTO_AUX(Relocation)\n+\n+#undef DEFINE_COPY_INTO_AUX\n+#undef DEFINE_COPY_INTO\n+\n+\/\/\/\/\/\/\/\/ Methods for RelocationHolder\n@@ -267,0 +302,2 @@\n+\/\/\/\/\/\/\/\/ Methods for flyweight Relocation types\n+\n","filename":"src\/hotspot\/share\/code\/relocInfo.cpp","additions":39,"deletions":2,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-#include \"utilities\/macros.hpp\"\n@@ -33,0 +32,3 @@\n+#include \"utilities\/macros.hpp\"\n+\n+#include <new>\n@@ -474,1 +476,0 @@\n-  friend class CodeSection;\n@@ -477,4 +478,40 @@\n-  \/\/ this preallocated memory must accommodate all subclasses of Relocation\n-  \/\/ (this number is assertion-checked in Relocation::operator new)\n-  enum { _relocbuf_size = 5 };\n-  void* _relocbuf[ _relocbuf_size ];\n+  \/\/ A Relocation is \"held\" by placement constructing a Relocation into\n+  \/\/ _relocbuf. Hence, _relocbuf must accomodate all subclasses of\n+  \/\/ Relocation. We also need the Relocation base class to be at the same\n+  \/\/ address as the start of the object, e.g. at the address of _relocbuf.\n+  \/\/ Both of these requirements are checked (see emplace_relocation).\n+  \/\/ The placement of the base class subobject isn't guaranteed by C++, since\n+  \/\/ these aren't standard layout classes, but all supported implementations\n+  \/\/ provide that behavior.  If that changes, we can instead add a Relocation*\n+  \/\/ _reloc member to capture the result of the placement new, and use that to\n+  \/\/ access the base subobject.\n+  static const size_t _relocbuf_size = 5 * sizeof(void*);\n+  alignas(void*) char _relocbuf[_relocbuf_size];\n+\n+  template<typename Reloc, typename... Args>\n+  void emplace_relocation(const Args&... args) {\n+    static_assert(std::is_base_of<Relocation, Reloc>::value, \"not Relocation\");\n+    static_assert(sizeof(Reloc) <= sizeof(_relocbuf), \"_relocbuf too small\");\n+    Relocation* reloc = ::new (_relocbuf) Reloc(args...);\n+    \/\/ Verify the base class subobject of the object constructed into\n+    \/\/ _relocbuf is at the same address as the derived object.\n+    assert(static_cast<const void*>(reloc) == _relocbuf, \"invariant\");\n+  }\n+\n+  \/\/ Support for Relocation::copy_into.\n+  \/\/ reloc should be a most derived object.\n+  template<typename Reloc>\n+  void copy_into_impl(const Reloc& reloc) {\n+    emplace_relocation<Reloc>(reloc);\n+  }\n+\n+  \/\/ Tag for selecting the constructor below and carrying the type of the\n+  \/\/ relocation object the new holder will (initially) contain.\n+  template<typename Reloc> struct Construct {};\n+\n+  \/\/ Constructor used by construct().  Constructs a new holder containing a\n+  \/\/ relocation of type Reloc that is constructed using the provided args.\n+  template<typename Reloc, typename... Args>\n+  RelocationHolder(Construct<Reloc>, const Args&... args) {\n+    emplace_relocation<Reloc>(args...);\n+  }\n@@ -483,1 +520,1 @@\n-  Relocation* reloc() const { return (Relocation*) &_relocbuf[0]; }\n+  Relocation* reloc() const { return (Relocation*)_relocbuf; }\n@@ -489,1 +526,7 @@\n-  inline RelocationHolder();                \/\/ initializes type to none\n+  \/\/ Return a holder containing a relocation of type Reloc, constructed using args.\n+  template<typename Reloc, typename... Args>\n+  static RelocationHolder construct(const Args&... args) {\n+    return RelocationHolder(Construct<Reloc>(), args...);\n+  }\n+\n+  RelocationHolder();           \/\/ Initializes type to none.\n@@ -491,1 +534,6 @@\n-  inline RelocationHolder(Relocation* r);   \/\/ make a copy\n+  \/\/ Depends on the destructor for all relocation types being trivial\n+  \/\/ (verified in .cpp file).\n+  ~RelocationHolder() = default;\n+\n+  RelocationHolder(const RelocationHolder& from);\n+  RelocationHolder& operator=(const RelocationHolder& from);\n@@ -639,1 +687,0 @@\n-  friend class RelocationHolder;\n@@ -661,1 +708,1 @@\n-  Relocation(relocInfo::relocType rtype) : _binding(NULL), _rtype(rtype) { }\n+  explicit Relocation(relocInfo::relocType rtype) : _binding(NULL), _rtype(rtype) { }\n@@ -663,2 +710,7 @@\n-  static RelocationHolder newHolder() {\n-    return RelocationHolder();\n+  \/\/ Helper for copy_into functions for derived classes.\n+  \/\/ Forwards operation to RelocationHolder::copy_into_impl so that\n+  \/\/ RelocationHolder only needs to befriend this class, rather than all\n+  \/\/ derived classes that implement copy_into.\n+  template<typename Reloc>\n+  static void copy_into_helper(const Reloc& reloc, RelocationHolder& holder) {\n+    holder.copy_into_impl(reloc);\n@@ -668,6 +720,0 @@\n-  void* operator new(size_t size, const RelocationHolder& holder) throw() {\n-    assert(size <= sizeof(holder._relocbuf), \"Make _relocbuf bigger!\");\n-    assert((void* const *)holder.reloc() == &holder._relocbuf[0], \"ptrs must agree\");\n-    return holder.reloc();\n-  }\n-\n@@ -796,0 +842,9 @@\n+  \/\/ Make a filler relocation.\n+  Relocation() : Relocation(relocInfo::none) {}\n+\n+  \/\/ Intentionally public non-virtual destructor, even though polymorphic.  We\n+  \/\/ never heap allocate a Relocation, so never delete through a base pointer.\n+  \/\/ RelocationHolder depends on the destructor for all relocation types being\n+  \/\/ trivial, so this must not be virtual (and hence non-trivial).\n+  ~Relocation() = default;\n+\n@@ -798,0 +853,3 @@\n+  \/\/ Copy this relocation into holder.\n+  virtual void copy_into(RelocationHolder& holder) const;\n+\n@@ -821,4 +879,3 @@\n-inline RelocationHolder::RelocationHolder() {\n-  \/\/ initialize the vtbl, just to keep things type-safe\n-  new(*this) Relocation(relocInfo::none);\n-}\n+inline RelocationHolder::RelocationHolder() :\n+  RelocationHolder(Construct<Relocation>())\n+{}\n@@ -826,0 +883,3 @@\n+inline RelocationHolder::RelocationHolder(const RelocationHolder& from) {\n+  from.reloc()->copy_into(*this);\n+}\n@@ -827,5 +887,6 @@\n-inline RelocationHolder::RelocationHolder(Relocation* r) {\n-  \/\/ wordwise copy from r (ok if it copies garbage after r)\n-  for (int i = 0; i < _relocbuf_size; i++) {\n-    _relocbuf[i] = ((void**)r)[i];\n-  }\n+inline RelocationHolder& RelocationHolder::operator=(const RelocationHolder& from) {\n+  \/\/ All Relocation types are trivially destructible (verified in .cpp file),\n+  \/\/ so we don't need to destruct our old value before copying over it.\n+  \/\/ If not for that we would need to decide what to do about self-assignment.\n+  from.reloc()->copy_into(*this);\n+  return *this;\n@@ -879,1 +940,1 @@\n-  friend class RelocIterator;\n+  friend class RelocationHolder;\n@@ -885,3 +946,1 @@\n-    RelocationHolder rh = newHolder();\n-    new(rh) post_call_nop_Relocation();\n-    return rh;\n+    return RelocationHolder::construct<post_call_nop_Relocation>();\n@@ -889,0 +948,2 @@\n+\n+  void copy_into(RelocationHolder& holder) const;\n@@ -892,1 +953,1 @@\n-  friend class RelocIterator;\n+  friend class RelocationHolder;\n@@ -898,3 +959,1 @@\n-    RelocationHolder rh = newHolder();\n-    new(rh) entry_guard_Relocation();\n-    return rh;\n+    return RelocationHolder::construct<entry_guard_Relocation>();\n@@ -902,0 +961,2 @@\n+\n+  void copy_into(RelocationHolder& holder) const;\n@@ -926,3 +987,1 @@\n-    RelocationHolder rh = newHolder();\n-    new(rh) oop_Relocation(oop_index, offset);\n-    return rh;\n+    return RelocationHolder::construct<oop_Relocation>(oop_index, offset);\n@@ -938,3 +997,1 @@\n-    RelocationHolder rh = newHolder();\n-    new(rh) oop_Relocation(oop_index, offset);\n-    return rh;\n+    return RelocationHolder::construct<oop_Relocation>(oop_index, offset);\n@@ -943,0 +1000,2 @@\n+  void copy_into(RelocationHolder& holder) const;\n+\n@@ -950,1 +1009,1 @@\n-  friend class RelocIterator;\n+  friend class RelocationHolder;\n@@ -983,3 +1042,1 @@\n-    RelocationHolder rh = newHolder();\n-    new(rh) metadata_Relocation(metadata_index, offset);\n-    return rh;\n+    return RelocationHolder::construct<metadata_Relocation>(metadata_index, offset);\n@@ -991,3 +1048,1 @@\n-    RelocationHolder rh = newHolder();\n-    new(rh) metadata_Relocation(metadata_index, offset);\n-    return rh;\n+    return RelocationHolder::construct<metadata_Relocation>(metadata_index, offset);\n@@ -996,0 +1051,2 @@\n+  void copy_into(RelocationHolder& holder) const;\n+\n@@ -1003,1 +1060,1 @@\n-  friend class RelocIterator;\n+  friend class RelocationHolder;\n@@ -1038,3 +1095,1 @@\n-    RelocationHolder rh = newHolder();\n-    new(rh) virtual_call_Relocation(cached_value, method_index);\n-    return rh;\n+    return RelocationHolder::construct<virtual_call_Relocation>(cached_value, method_index);\n@@ -1043,0 +1098,2 @@\n+  void copy_into(RelocationHolder& holder) const;\n+\n@@ -1054,1 +1111,1 @@\n-  friend class RelocIterator;\n+  friend class RelocationHolder;\n@@ -1077,3 +1134,1 @@\n-    RelocationHolder rh = newHolder();\n-    new(rh) opt_virtual_call_Relocation(method_index);\n-    return rh;\n+    return RelocationHolder::construct<opt_virtual_call_Relocation>(method_index);\n@@ -1082,0 +1137,2 @@\n+  void copy_into(RelocationHolder& holder) const;\n+\n@@ -1089,1 +1146,1 @@\n-  friend class RelocIterator;\n+  friend class RelocationHolder;\n@@ -1109,3 +1166,1 @@\n-    RelocationHolder rh = newHolder();\n-    new(rh) static_call_Relocation(method_index);\n-    return rh;\n+    return RelocationHolder::construct<static_call_Relocation>(method_index);\n@@ -1114,0 +1169,2 @@\n+  void copy_into(RelocationHolder& holder) const;\n+\n@@ -1121,1 +1178,1 @@\n-  friend class RelocIterator;\n+  friend class RelocationHolder;\n@@ -1140,3 +1197,1 @@\n-    RelocationHolder rh = newHolder();\n-    new(rh) static_stub_Relocation(static_call);\n-    return rh;\n+    return RelocationHolder::construct<static_stub_Relocation>(static_call);\n@@ -1145,0 +1200,2 @@\n+  void copy_into(RelocationHolder& holder) const;\n+\n@@ -1152,1 +1209,1 @@\n-  friend class RelocIterator;\n+  friend class RelocationHolder;\n@@ -1169,3 +1226,1 @@\n-    RelocationHolder rh = newHolder();\n-    new(rh) runtime_call_Relocation();\n-    return rh;\n+    return RelocationHolder::construct<runtime_call_Relocation>();\n@@ -1174,0 +1229,2 @@\n+  void copy_into(RelocationHolder& holder) const;\n+\n@@ -1175,1 +1232,1 @@\n-  friend class RelocIterator;\n+  friend class RelocationHolder;\n@@ -1177,2 +1234,0 @@\n-\n- public:\n@@ -1185,3 +1240,1 @@\n-    RelocationHolder rh = newHolder();\n-    new(rh) runtime_call_w_cp_Relocation();\n-    return rh;\n+    return RelocationHolder::construct<runtime_call_w_cp_Relocation>();\n@@ -1190,0 +1243,2 @@\n+  void copy_into(RelocationHolder& holder) const;\n+\n@@ -1191,1 +1246,1 @@\n-  friend class RelocIterator;\n+  friend class RelocationHolder;\n@@ -1221,2 +1276,1 @@\n-    RelocationHolder rh = newHolder();\n-    return (new (rh) trampoline_stub_Relocation(static_call));\n+    return RelocationHolder::construct<trampoline_stub_Relocation>(static_call);\n@@ -1225,0 +1279,2 @@\n+  void copy_into(RelocationHolder& holder) const;\n+\n@@ -1232,1 +1288,1 @@\n-  friend class RelocIterator;\n+  friend class RelocationHolder;\n@@ -1251,3 +1307,1 @@\n-    RelocationHolder rh = newHolder();\n-    new(rh) external_word_Relocation(target);\n-    return rh;\n+    return RelocationHolder::construct<external_word_Relocation>(target);\n@@ -1259,3 +1313,1 @@\n-    RelocationHolder rh = newHolder();\n-    new(rh) external_word_Relocation(NULL);\n-    return rh;\n+    return RelocationHolder::construct<external_word_Relocation>(nullptr);\n@@ -1264,0 +1316,2 @@\n+  void copy_into(RelocationHolder& holder) const;\n+\n@@ -1277,1 +1331,1 @@\n-  friend class RelocIterator;\n+  friend class RelocationHolder;\n@@ -1299,3 +1353,1 @@\n-    RelocationHolder rh = newHolder();\n-    new(rh) internal_word_Relocation(target);\n-    return rh;\n+    return RelocationHolder::construct<internal_word_Relocation>(target);\n@@ -1306,3 +1358,1 @@\n-    RelocationHolder rh = newHolder();\n-    new(rh) internal_word_Relocation(NULL);\n-    return rh;\n+    return RelocationHolder::construct<internal_word_Relocation>(nullptr);\n@@ -1311,0 +1361,2 @@\n+  void copy_into(RelocationHolder& holder) const;\n+\n@@ -1320,1 +1372,1 @@\n-  friend class RelocIterator;\n+  friend class RelocationHolder;\n@@ -1344,3 +1396,1 @@\n-    RelocationHolder rh = newHolder();\n-    new(rh) section_word_Relocation(target, section);\n-    return rh;\n+    return RelocationHolder::construct<section_word_Relocation>(target, section);\n@@ -1349,0 +1399,2 @@\n+  void copy_into(RelocationHolder& holder) const;\n+\n@@ -1359,1 +1411,1 @@\n-  friend class RelocIterator;\n+  friend class RelocationHolder;\n@@ -1369,0 +1421,2 @@\n+\n+  void copy_into(RelocationHolder& holder) const;\n@@ -1374,0 +1428,2 @@\n+\n+  void copy_into(RelocationHolder& holder) const;\n@@ -1377,9 +1433,9 @@\n-#define EACH_CASE(name)                                         \\\n-inline name##_Relocation* RelocIterator::name##_reloc() {       \\\n-  assert(type() == relocInfo::name##_type, \"type must agree\");  \\\n-  \/* The purpose of the placed \"new\" is to re-use the same *\/   \\\n-  \/* stack storage for each new iteration. *\/                   \\\n-  name##_Relocation* r = new(_rh) name##_Relocation();          \\\n-  r->set_binding(this);                                         \\\n-  r->name##_Relocation::unpack_data();                          \\\n-  return r;                                                     \\\n+#define EACH_CASE_AUX(Accessor, Reloc)                                  \\\n+inline Reloc* RelocIterator::Accessor() {                               \\\n+  static const RelocationHolder proto = RelocationHolder::construct<Reloc>(); \\\n+  assert(type() == proto.type(), \"type must agree\");                    \\\n+  _rh = proto;                                                          \\\n+  Reloc* r = static_cast<Reloc*>(_rh.reloc());                          \\\n+  r->set_binding(this);                                                 \\\n+  r->Reloc::unpack_data();                                              \\\n+  return r;                                                             \\\n@@ -1387,0 +1443,2 @@\n+#define EACH_CASE(name) \\\n+  EACH_CASE_AUX(PASTE_TOKENS(name, _reloc), PASTE_TOKENS(name, _Relocation))\n@@ -1388,0 +1446,1 @@\n+#undef EACH_CASE_AUX\n","filename":"src\/hotspot\/share\/code\/relocInfo.hpp","additions":165,"deletions":106,"binary":false,"changes":271,"status":"modified"}]}