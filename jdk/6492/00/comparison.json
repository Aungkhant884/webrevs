{"files":[{"patch":"@@ -637,6 +637,7 @@\n-    \/\/ Exclude last input arg stack slots to avoid spilling vector register there,\n-    \/\/ otherwise RegVectMask spills could stomp over stack slots in caller frame.\n-    for (; (in >= init_in) && (k < scalable_predicate_reg_slots()); k++) {\n-      scalable_stack_mask.Remove(in);\n-      in = OptoReg::add(in, -1);\n-    }\n+    if (Matcher::has_predicated_vectors()) {\n+      \/\/ Exclude last input arg stack slots to avoid spilling vector register there,\n+      \/\/ otherwise RegVectMask spills could stomp over stack slots in caller frame.\n+      for (; (in >= init_in) && (k < scalable_predicate_reg_slots()); k++) {\n+        scalable_stack_mask.Remove(in);\n+        in = OptoReg::add(in, -1);\n+      }\n@@ -644,5 +645,6 @@\n-    \/\/ For RegVectMask\n-    scalable_stack_mask.clear_to_sets(scalable_predicate_reg_slots());\n-    assert(scalable_stack_mask.is_AllStack(), \"should be infinite stack\");\n-    *idealreg2spillmask[Op_RegVectMask] = *idealreg2regmask[Op_RegVectMask];\n-    idealreg2spillmask[Op_RegVectMask]->OR(scalable_stack_mask);\n+      \/\/ For RegVectMask\n+      scalable_stack_mask.clear_to_sets(scalable_predicate_reg_slots());\n+      assert(scalable_stack_mask.is_AllStack(), \"should be infinite stack\");\n+      *idealreg2spillmask[Op_RegVectMask] = *idealreg2regmask[Op_RegVectMask];\n+      idealreg2spillmask[Op_RegVectMask]->OR(scalable_stack_mask);\n+    }\n","filename":"src\/hotspot\/share\/opto\/matcher.cpp","additions":13,"deletions":11,"binary":false,"changes":24,"status":"modified"}]}