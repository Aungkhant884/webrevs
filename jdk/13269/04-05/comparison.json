{"files":[{"patch":"@@ -1282,0 +1282,77 @@\n+\/\/ Collapse the \"addition with overflow-protection\" pattern, and the symetrical\n+\/\/ \"subtraction with underflow-protection\" pattern. These are created during the\n+\/\/ unrolling, when we have to adjust the limit by subtracting the stride, but want\n+\/\/ to protect agains underflow: MaxL(SubL(limit, stride), min_jint).\n+\/\/ If we have more than one of those in a sequence:\n+\/\/\n+\/\/   x  con2\n+\/\/   |  |\n+\/\/   AddL  clamp2\n+\/\/     |    |\n+\/\/    Max\/MinL con1\n+\/\/          |  |\n+\/\/          AddL  clamp1\n+\/\/            |    |\n+\/\/           Max\/MinL (n)\n+\/\/\n+\/\/ We want to collapse it to:\n+\/\/\n+\/\/   x  con1  con2\n+\/\/   |    |    |\n+\/\/   |   AddLNode (new_con)\n+\/\/   |    |\n+\/\/  AddLNode  clamp1\n+\/\/        |    |\n+\/\/       Max\/MinL (n)\n+\/\/\n+Node* fold_subI_no_underflow_pattern(Node* n, PhaseGVN* phase) {\n+  assert(n->Opcode() == Op_MaxL || n->Opcode() == Op_MinL, \"sanity\");\n+  \/\/ Check that the two clamps have the correct values.\n+  jlong clamp = (n->Opcode() == Op_MaxL) ? min_jint : max_jint;\n+  auto is_clamp = [&](Node* c) {\n+    const TypeLong* t = phase->type(c)->is_long();\n+    return t != nullptr && t->is_con() &&\n+           t->get_con() == clamp;\n+  };\n+  \/\/ Check that the constants are negative if MaxL, and positive if MinL.\n+  auto is_sub_con = [&](Node* c) {\n+    const TypeLong* t = phase->type(c)->is_long();\n+    return t != nullptr && t->is_con() &&\n+           t->get_con() < max_jint && t->get_con() > min_jint &&\n+           (t->get_con() < 0) == (n->Opcode() == Op_MaxL);\n+  };\n+  \/\/ Verify the graph level by level:\n+  Node* add1   = n->in(1);\n+  Node* clamp1 = n->in(2);\n+  if (add1->Opcode() == Op_AddL && is_clamp(clamp1)) {\n+    Node* max2 = add1->in(1);\n+    Node* con1 = add1->in(2);\n+    if (max2->Opcode() == n->Opcode() && is_sub_con(con1)) {\n+      Node* add2   = max2->in(1);\n+      Node* clamp2 = max2->in(2);\n+      if (add2->Opcode() == Op_AddL && is_clamp(clamp2)) {\n+        Node* x    = add2->in(1);\n+        Node* con2 = add2->in(2);\n+        if (is_sub_con(con2)) {\n+          Node* new_con = phase->transform(new AddLNode(con1, con2));\n+          Node* new_sub = phase->transform(new AddLNode(x, new_con));\n+          n->set_req_X(1, new_sub, phase);\n+          return n;\n+        }\n+      }\n+    }\n+  }\n+  return nullptr;\n+}\n+\n+Node* MaxLNode::Ideal(PhaseGVN* phase, bool can_reshape) {\n+  Node* n = AddNode::Ideal(phase, can_reshape);\n+  if (n != nullptr) {\n+    return n;\n+  }\n+  if (can_reshape) {\n+    return fold_subI_no_underflow_pattern(this, phase);\n+  }\n+  return nullptr;\n+}\n+\n@@ -1303,0 +1380,11 @@\n+Node* MinLNode::Ideal(PhaseGVN* phase, bool can_reshape) {\n+  Node* n = AddNode::Ideal(phase, can_reshape);\n+  if (n != nullptr) {\n+    return n;\n+  }\n+  if (can_reshape) {\n+    return fold_subI_no_underflow_pattern(this, phase);\n+  }\n+  return nullptr;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/addnode.cpp","additions":88,"deletions":0,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -337,0 +337,1 @@\n+  virtual Node* Ideal(PhaseGVN *phase, bool can_reshape);\n@@ -355,0 +356,1 @@\n+  virtual Node* Ideal(PhaseGVN *phase, bool can_reshape);\n","filename":"src\/hotspot\/share\/opto\/addnode.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -657,0 +657,5 @@\n+    public static final String MAX_L = PREFIX + \"MAX_L\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(MAX_L, \"MaxL\");\n+    }\n+\n@@ -681,0 +686,5 @@\n+\n+    public static final String MIN_L = PREFIX + \"MIN_L\" + POSTFIX;\n+    static {\n+        beforeMatchingNameRegex(MIN_L, \"MinL\");\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,69 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8303466\n+ * @summary Verify that AddL->MaxL->AddL->MaxL chains of unroll limit adjustments collapse.\n+ *          If it did not collapse, we would have about 10 MaxL\/MinL. With the collapse, it\n+ *          is now one or two.\n+ * @library \/test\/lib \/\n+ * @requires vm.compiler2.enabled\n+ * @run driver compiler.loopopts.TestLoopLimitSubtractionsCollapse\n+ *\/\n+\n+package compiler.loopopts;\n+import compiler.lib.ir_framework.*;\n+\n+public class TestLoopLimitSubtractionsCollapse {\n+    static int START = 0;\n+    static int FINISH = 512;\n+    static int RANGE = 512;\n+\n+    static byte[] data1 = new byte[RANGE];\n+    static byte[] data2 = new byte[RANGE];\n+\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    @Test\n+    @Warmup(0)\n+    @IR(counts = {IRNode.MAX_L, \"> 0\", IRNode.MAX_L, \"<= 2\"},\n+        phase = CompilePhase.PHASEIDEALLOOP_ITERATIONS)\n+    public static void test1() {\n+        for (int j = START; j < FINISH; j++) {\n+            data1[j] = (byte)(data1[j] * 11);\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(0)\n+    @IR(counts = {IRNode.MIN_L, \"> 0\", IRNode.MIN_L, \"<= 2\"},\n+        phase = CompilePhase.PHASEIDEALLOOP_ITERATIONS)\n+    public static void test2() {\n+        for (int j = FINISH-1; j >= START; j--) {\n+            data2[j] = (byte)(data2[j] * 11);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/TestLoopLimitSubtractionsCollapse.java","additions":69,"deletions":0,"binary":false,"changes":69,"status":"added"}]}