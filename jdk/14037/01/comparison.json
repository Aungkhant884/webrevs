{"files":[{"patch":"@@ -34,1 +34,0 @@\n-import jdk.internal.reflect.Reflection;\n@@ -38,0 +37,1 @@\n+import java.util.Map;\n@@ -39,1 +39,0 @@\n-import java.util.Optional;\n@@ -62,0 +61,5 @@\n+ * A linker provides a way to lookup up the <em>canonical layouts<\/em> associated with the data types used by the ABI.\n+ * For example, the canonical layout for the C {@code size_t} type is equal to {@link ValueLayout#JAVA_LONG}. The canonical\n+ * layouts supported by a linker are exposed via the {@link #canonicalLayouts()} method, which returns a map from\n+ * ABI type names to canonical layouts.\n+ * <p>\n@@ -106,5 +110,6 @@\n- * of a suitable carrier. The mapping between a scalar type and its corresponding layout is dependent on the ABI\n- * implemented by the native linker. For instance, the C type {@code long} maps to the layout constant\n- * {@link ValueLayout#JAVA_LONG} on Linux\/x64, but maps to the layout constant {@link ValueLayout#JAVA_INT} on\n- * Windows\/x64. Similarly, the C type {@code size_t} maps to the layout constant {@link ValueLayout#JAVA_LONG}\n- * on 64-bit platforms, but maps to the layout constant {@link ValueLayout#JAVA_INT} on 32-bit platforms.\n+ * of a suitable carrier. The {@linkplain #canonicalLayouts() mapping} between a scalar type and its corresponding\n+ * canonical layout is dependent on the ABI implemented by the native linker. For instance, the C type {@code long}\n+ * maps to the layout constant {@link ValueLayout#JAVA_LONG} on Linux\/x64, but maps to the layout constant\n+ * {@link ValueLayout#JAVA_INT} on Windows\/x64. Similarly, the C type {@code size_t} maps to the layout constant\n+ * {@link ValueLayout#JAVA_LONG} on 64-bit platforms, but maps to the layout constant {@link ValueLayout#JAVA_INT} on\n+ * 32-bit platforms.\n@@ -200,2 +205,12 @@\n- * All the native linker implementations limit the function descriptors that they support to those that contain\n- * only so-called <em>canonical<\/em> layouts. A canonical layout has the following characteristics:\n+ * More formally, all native linker implementations can only operate on a subset of memory layouts, called <em>supported layouts<\/em>.\n+ * A layout {@code L} is supported iff:\n+ * <ul>\n+ * <li>{@code L} is a value layout {@code V} and {@code V.withoutName()} is a canonical layout<\/li>\n+ * <li>{@code L} is an address layout {@code A} and {@code A.withoutTargetLayout().withoutName()} is a canonical layout<\/li>\n+ * <li>{@code L} is a sequence layout {@code S} and all the following conditions hold:\n+ * <ol>\n+ * <li>the alignment constraint of {@code S} is set to its <a href=\"MemoryLayout.html#layout-align\">natural alignment<\/a>, and<\/li>\n+ * <li>{@code S.elementLayout()} is a supported layout.<\/li>\n+ * <\/ol>\n+ * <\/li>\n+ * <li>{@code L} is a group layout {@code G} and all the following conditions hold:\n@@ -203,6 +218,4 @@\n- * <li>Its alignment constraint is set to its <a href=\"MemoryLayout.html#layout-align\">natural alignment<\/a><\/li>\n- * <li>If it is a {@linkplain ValueLayout value layout}, its {@linkplain ValueLayout#order() byte order} is\n- * the {@linkplain ByteOrder#nativeOrder() native byte order}.\n- * <li>If it is a {@linkplain GroupLayout group layout}, its size is a multiple of its alignment constraint, and<\/li>\n- * <li>It does not contain padding other than what is strictly required to align its non-padding layout elements,\n- * or to satisfy constraint 3<\/li>\n+ * <li>the alignment constraint of {@code G} is set to its <a href=\"MemoryLayout.html#layout-align\">natural alignment<\/a>;<\/li>\n+ * <li>the size of {@code G} is a multiple of its alignment constraint;<\/li>\n+ * <li>each member layout in {@code G.memberLayouts()} is either a padding layout or a supported layout, and<\/li>\n+ * <li>{@code G} does not contain padding other than what is strictly required to align its non-padding layout elements, or to satisfy (2).<\/li>\n@@ -210,0 +223,5 @@\n+ * <\/li>\n+ * <\/ul>\n+ *\n+ * Native linkers only support function descriptors whose argument\/return layouts are supported layouts and\n+ * are not sequence layouts.\n@@ -576,0 +594,16 @@\n+    \/**\n+     * {@return a mapping between the names of data types used by the ABI implemented by this linker and their\n+     * <em>canonical layouts<\/em>}\n+     * <p>\n+     * Each {@link Linker} is responsible for choosing the data types that are widely recognized as useful on the OS\n+     * and processor combination supported by the {@link Linker}. Accordingly, the precise set of data type names\n+     * and canonical layouts exposed by the linker is unspecified; it varies from one {@link Linker} to another.\n+     * @implNote It is strongly recommended that the result of {@link #canonicalLayouts()} exposes a set of symbols that is stable over time.\n+     * Clients of {@link #canonicalLayouts()} are likely to fail if a data type that was previously exposed by the linker\n+     * is no longer exposed, or if its canonical layout is updated.\n+     * <p>If an implementer provides {@link Linker} implementations for multiple OS and processor combinations, then it is strongly\n+     * recommended that the result of {@link #canonicalLayouts()} exposes, as much as possible, a consistent set of symbols\n+     * across all the OS and processor combinations.\n+     *\/\n+    Map<String, MemoryLayout> canonicalLayouts();\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/Linker.java","additions":49,"deletions":15,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import jdk.internal.foreign.CABI;\n@@ -54,0 +55,1 @@\n+import java.util.HashSet;\n@@ -56,0 +58,1 @@\n+import java.util.Map;\n@@ -57,0 +60,1 @@\n+import java.util.Set;\n@@ -133,0 +137,5 @@\n+    @Override\n+    public Map<String, MemoryLayout> canonicalLayouts() {\n+        return CANONICAL_LAYOUTS_MAP;\n+    }\n+\n@@ -151,1 +160,0 @@\n-        checkHasNaturalAlignment(layout);\n@@ -153,1 +161,1 @@\n-            checkByteOrder(vl);\n+            checkCanonical(vl);\n@@ -155,0 +163,1 @@\n+            checkHasNaturalAlignment(layout);\n@@ -170,0 +179,1 @@\n+            checkHasNaturalAlignment(layout);\n@@ -179,0 +189,1 @@\n+            checkHasNaturalAlignment(layout);\n@@ -203,0 +214,10 @@\n+    private static void checkCanonical(ValueLayout valueLayout) {\n+        valueLayout = valueLayout.withoutName();\n+        if (valueLayout instanceof AddressLayout addressLayout) {\n+            valueLayout = addressLayout.withoutTargetLayout();\n+        }\n+        if (!CANONICAL_LAYOUTS.contains(valueLayout.withoutName())) {\n+            throw new IllegalArgumentException(\"Value layout is not a canonical layout: \" + valueLayout);\n+        }\n+    }\n+\n@@ -235,5 +256,19 @@\n-    private void checkByteOrder(ValueLayout vl) {\n-        if (vl.order() != linkerByteOrder()) {\n-            throw new IllegalArgumentException(\"Layout does not have the right byte order: \" + vl);\n-        }\n-    }\n+    private static final Map<String, MemoryLayout> CANONICAL_LAYOUTS_MAP = Map.ofEntries(\n+            Map.entry(\"bool\", ValueLayout.JAVA_BOOLEAN),\n+            Map.entry(\"char\", ValueLayout.JAVA_BYTE),\n+            Map.entry(\"short\", ValueLayout.JAVA_SHORT),\n+            Map.entry(\"int\", ValueLayout.JAVA_INT),\n+            Map.entry(\"float\", ValueLayout.JAVA_FLOAT),\n+            Map.entry(\"long\", CABI.current() == CABI.WIN_64 ? ValueLayout.JAVA_INT : ValueLayout.JAVA_LONG),\n+            Map.entry(\"long long\", ValueLayout.JAVA_LONG),\n+            Map.entry(\"double\", ValueLayout.JAVA_DOUBLE),\n+            Map.entry(\"void*\", ValueLayout.ADDRESS),\n+            Map.entry(\"int8_t\", ValueLayout.JAVA_BYTE),\n+            Map.entry(\"int16_t\", ValueLayout.JAVA_SHORT),\n+            Map.entry(\"int32_t\", ValueLayout.JAVA_INT),\n+            Map.entry(\"int64_t\", ValueLayout.JAVA_LONG),\n+            Map.entry(\"char16_t\", ValueLayout.JAVA_CHAR),\n+            Map.entry(\"size_t\", ValueLayout.ADDRESS.bitSize() == Integer.SIZE ? ValueLayout.JAVA_INT : ValueLayout.JAVA_LONG)\n+    );\n+\n+    private static final Set<MemoryLayout> CANONICAL_LAYOUTS = new HashSet<>(CANONICAL_LAYOUTS_MAP.values());\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/AbstractLinker.java","additions":42,"deletions":7,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -122,1 +122,1 @@\n-                    \"Layout bit alignment must be natural alignment\"\n+                    \"Value layout is not a canonical layout: 16%i32\"\n@@ -126,1 +126,1 @@\n-                    \"Layout bit alignment must be natural alignment\"\n+                    \"Value layout is not a canonical layout: 16%a64\"\n@@ -130,1 +130,1 @@\n-                    \"Layout bit alignment must be natural alignment\"\n+                    \"Value layout is not a canonical layout: 32%c16\"\n@@ -138,1 +138,1 @@\n-                    \"Layout bit alignment must be natural alignment\"\n+                    \"Value layout is not a canonical layout: 8%s16\"\n@@ -147,1 +147,1 @@\n-                    \"Layout bit alignment must be natural alignment\"\n+                    \"Value layout is not a canonical layout: 8%s16\"\n@@ -154,1 +154,1 @@\n-                    \"Layout bit alignment must be natural alignment\"\n+                    \"Value layout is not a canonical layout: 8%i32\"\n@@ -165,1 +165,1 @@\n-                    \"Layout does not have the right byte order\"\n+                    \"Value layout is not a canonical layout: I32\"\n@@ -169,1 +169,1 @@\n-                    \"Layout does not have the right byte order\"\n+                    \"Value layout is not a canonical layout: I32\"\n@@ -173,1 +173,1 @@\n-                    \"Layout does not have the right byte order\"\n+                    \"Value layout is not a canonical layout: I32\"\n","filename":"test\/jdk\/java\/foreign\/TestIllegalLink.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"}]}