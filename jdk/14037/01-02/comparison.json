{"files":[{"patch":"@@ -111,5 +111,1 @@\n- * canonical layout is dependent on the ABI implemented by the native linker. For instance, the C type {@code long}\n- * maps to the layout constant {@link ValueLayout#JAVA_LONG} on Linux\/x64, but maps to the layout constant\n- * {@link ValueLayout#JAVA_INT} on Windows\/x64. Similarly, the C type {@code size_t} maps to the layout constant\n- * {@link ValueLayout#JAVA_LONG} on 64-bit platforms, but maps to the layout constant {@link ValueLayout#JAVA_INT} on\n- * 32-bit platforms.\n+ * canonical layout is dependent on the ABI implemented by the native linker (see below).\n@@ -130,0 +126,20 @@\n+ * All native linker implementations are guaranteed to provide canonical layouts for the following set of types:\n+ * <ul>\n+ *     <li>{@code bool}<\/li>\n+ *     <li>{@code char}<\/li>\n+ *     <li>{@code short}<\/li>\n+ *     <li>{@code unsigned short}<\/li>\n+ *     <li>{@code int}<\/li>\n+ *     <li>{@code long}<\/li>\n+ *     <li>{@code long long}<\/li>\n+ *     <li>{@code float}<\/li>\n+ *     <li>{@code double}<\/li>\n+ *     <li>{@code size_t}<\/li>\n+ *     <li>{@code void*}<\/li>\n+ * <\/ul>\n+ * As noted above, the specific canonical layout associated with each type can vary, depending on the data model\n+ * supported by a given ABI. For instance, the C type {@code long} maps to the layout constant {@link ValueLayout#JAVA_LONG}\n+ * on Linux\/x64, but maps to the layout constant {@link ValueLayout#JAVA_INT} on Windows\/x64. Similarly, the C type\n+ * {@code size_t} maps to the layout constant {@link ValueLayout#JAVA_LONG} on 64-bit platforms, but maps to the layout\n+ * constant {@link ValueLayout#JAVA_INT} on 32-bit platforms.\n+ * <p>\n@@ -151,0 +167,3 @@\n+ * <tr><th scope=\"row\" style=\"font-weight:normal\">{@code unsigned short}<\/th>\n+ *     <td style=\"text-align:center;\">{@link ValueLayout#JAVA_CHAR}<\/td>\n+ *     <td style=\"text-align:center;\">{@code char}<\/td>\n@@ -205,1 +224,1 @@\n- * More formally, all native linker implementations can only operate on a subset of memory layouts, called <em>supported layouts<\/em>.\n+ * More formally, all native linker implementations operate on a subset of memory layouts, called <em>supported layouts<\/em>.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/Linker.java","additions":25,"deletions":6,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -260,0 +260,1 @@\n+            Map.entry(\"unsigned short\", ValueLayout.JAVA_CHAR),\n@@ -266,5 +267,0 @@\n-            Map.entry(\"int8_t\", ValueLayout.JAVA_BYTE),\n-            Map.entry(\"int16_t\", ValueLayout.JAVA_SHORT),\n-            Map.entry(\"int32_t\", ValueLayout.JAVA_INT),\n-            Map.entry(\"int64_t\", ValueLayout.JAVA_LONG),\n-            Map.entry(\"char16_t\", ValueLayout.JAVA_CHAR),\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/AbstractLinker.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -38,0 +38,2 @@\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.ValueLayout;\n@@ -46,2 +48,1 @@\n-import static org.testng.Assert.assertSame;\n-import static org.testng.Assert.assertNotSame;\n+import static org.testng.Assert.*;\n@@ -141,0 +142,23 @@\n+    @Test\n+    public void testBasicTypes() {\n+        for (String basicType : BASIC_TYPES) {\n+            MemoryLayout layout = LINKER.canonicalLayouts().get(basicType);\n+            assertNotNull(layout);\n+            assertTrue(layout instanceof ValueLayout);\n+        }\n+    }\n+\n+    static String[] BASIC_TYPES = {\n+            \"bool\",\n+            \"char\",\n+            \"short\",\n+            \"unsigned short\",\n+            \"int\",\n+            \"long\",\n+            \"long long\",\n+            \"float\",\n+            \"double\",\n+            \"void*\",\n+            \"size_t\"\n+    };\n+\n","filename":"test\/jdk\/java\/foreign\/TestLinker.java","additions":26,"deletions":2,"binary":false,"changes":28,"status":"modified"}]}