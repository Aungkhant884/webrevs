{"files":[{"patch":"@@ -34,1 +34,0 @@\n-import jdk.internal.reflect.Reflection;\n@@ -38,0 +37,1 @@\n+import java.util.Map;\n@@ -39,1 +39,0 @@\n-import java.util.Optional;\n@@ -62,0 +61,6 @@\n+ * A linker provides a way to lookup up the <em>canonical layouts<\/em> associated with the data types used by the ABI.\n+ * For example, a linker implementing the C ABI might choose to provide a canonical layout for the C {@code size_t}\n+ * type. On 64-bit platforms, this canonical layout might be equal to {@link ValueLayout#JAVA_LONG}. The canonical\n+ * layouts supported by a linker are exposed via the {@link #canonicalLayouts()} method, which returns a map from\n+ * ABI type names to canonical layouts.\n+ * <p>\n@@ -106,5 +111,2 @@\n- * of a suitable carrier. The mapping between a scalar type and its corresponding layout is dependent on the ABI\n- * implemented by the native linker. For instance, the C type {@code long} maps to the layout constant\n- * {@link ValueLayout#JAVA_LONG} on Linux\/x64, but maps to the layout constant {@link ValueLayout#JAVA_INT} on\n- * Windows\/x64. Similarly, the C type {@code size_t} maps to the layout constant {@link ValueLayout#JAVA_LONG}\n- * on 64-bit platforms, but maps to the layout constant {@link ValueLayout#JAVA_INT} on 32-bit platforms.\n+ * of a suitable carrier. The {@linkplain #canonicalLayouts() mapping} between a scalar type and its corresponding\n+ * canonical layout is dependent on the ABI implemented by the native linker (see below).\n@@ -125,1 +127,26 @@\n- * The following table shows some examples of how C types are modelled in Linux\/x64:\n+ * All native linker implementations are guaranteed to provide canonical layouts for the following set of types:\n+ * <ul>\n+ *     <li>{@code bool}<\/li>\n+ *     <li>{@code char}<\/li>\n+ *     <li>{@code short}<\/li>\n+ *     <li>{@code int}<\/li>\n+ *     <li>{@code long}<\/li>\n+ *     <li>{@code long long}<\/li>\n+ *     <li>{@code float}<\/li>\n+ *     <li>{@code double}<\/li>\n+ *     <li>{@code size_t}<\/li>\n+ *     <li>{@code void*}<\/li>\n+ * <\/ul>\n+ * As noted above, the specific canonical layout associated with each type can vary, depending on the data model\n+ * supported by a given ABI. For instance, the C type {@code long} maps to the layout constant {@link ValueLayout#JAVA_LONG}\n+ * on Linux\/x64, but maps to the layout constant {@link ValueLayout#JAVA_INT} on Windows\/x64. Similarly, the C type\n+ * {@code size_t} maps to the layout constant {@link ValueLayout#JAVA_LONG} on 64-bit platforms, but maps to the layout\n+ * constant {@link ValueLayout#JAVA_INT} on 32-bit platforms.\n+ * <p>\n+ * A native linker typically does not provide canonical layouts for C's unsigned integral types. Instead, they are\n+ * modelled using the canonical layouts associated with their corresponding signed integral types. For instance,\n+ * the C type {@code unsigned long} maps to the layout constant {@link ValueLayout#JAVA_LONG} on Linux\/x64, but maps to\n+ * the layout constant {@link ValueLayout#JAVA_INT} on Windows\/x64.\n+ * <p>\n+ * The following table shows some examples of how C types are modelled in Linux\/x64 (all the examples provided\n+ * here will assume these platform-dependent mappings):\n@@ -140,1 +167,1 @@\n- * <tr><th scope=\"row\" style=\"font-weight:normal\">{@code char}<\/th>\n+ * <tr><th scope=\"row\" style=\"font-weight:normal\">{@code char} <br> {@code unsigned char}<\/th>\n@@ -143,1 +170,1 @@\n- * <tr><th scope=\"row\" style=\"font-weight:normal\">{@code short}<\/th>\n+ * <tr><th scope=\"row\" style=\"font-weight:normal\">{@code short} <br> {@code unsigned short}<\/th>\n@@ -146,1 +173,1 @@\n- * <tr><th scope=\"row\" style=\"font-weight:normal\">{@code int}<\/th>\n+ * <tr><th scope=\"row\" style=\"font-weight:normal\">{@code int} <br> {@code unsigned int}<\/th>\n@@ -149,1 +176,1 @@\n- * <tr><th scope=\"row\" style=\"font-weight:normal\">{@code long}<\/th>\n+ * <tr><th scope=\"row\" style=\"font-weight:normal\">{@code long} <br> {@code unsigned long}<\/th>\n@@ -152,1 +179,1 @@\n- * <tr><th scope=\"row\" style=\"font-weight:normal\">{@code long long}<\/th>\n+ * <tr><th scope=\"row\" style=\"font-weight:normal\">{@code long long} <br> {@code unsigned long long}<\/th>\n@@ -200,2 +227,12 @@\n- * All the native linker implementations limit the function descriptors that they support to those that contain\n- * only so-called <em>canonical<\/em> layouts. A canonical layout has the following characteristics:\n+ * All native linker implementations operate on a subset of memory layouts. More formally, a layout {@code L}\n+ * is supported by a native linker {@code NL} iff:\n+ * <ul>\n+ * <li>{@code L} is a value layout {@code V} and {@code V.withoutName()} is a canonical layout<\/li>\n+ * <li>{@code L} is an address layout {@code A} and {@code A.withoutTargetLayout().withoutName()} is a canonical layout<\/li>\n+ * <li>{@code L} is a sequence layout {@code S} and all the following conditions hold:\n+ * <ol>\n+ * <li>the alignment constraint of {@code S} is set to its <a href=\"MemoryLayout.html#layout-align\">natural alignment<\/a>, and<\/li>\n+ * <li>{@code S.elementLayout()} is a layout supported by {@code NL}.<\/li>\n+ * <\/ol>\n+ * <\/li>\n+ * <li>{@code L} is a group layout {@code G} and all the following conditions hold:\n@@ -203,6 +240,4 @@\n- * <li>Its alignment constraint is set to its <a href=\"MemoryLayout.html#layout-align\">natural alignment<\/a><\/li>\n- * <li>If it is a {@linkplain ValueLayout value layout}, its {@linkplain ValueLayout#order() byte order} is\n- * the {@linkplain ByteOrder#nativeOrder() native byte order}.\n- * <li>If it is a {@linkplain GroupLayout group layout}, its size is a multiple of its alignment constraint, and<\/li>\n- * <li>It does not contain padding other than what is strictly required to align its non-padding layout elements,\n- * or to satisfy constraint 3<\/li>\n+ * <li>the alignment constraint of {@code G} is set to its <a href=\"MemoryLayout.html#layout-align\">natural alignment<\/a>;<\/li>\n+ * <li>the size of {@code G} is a multiple of its alignment constraint;<\/li>\n+ * <li>each member layout in {@code G.memberLayouts()} is either a padding layout or a layout supported by {@code NL}, and<\/li>\n+ * <li>{@code G} does not contain padding other than what is strictly required to align its non-padding layout elements, or to satisfy (2).<\/li>\n@@ -210,0 +245,5 @@\n+ * <\/li>\n+ * <\/ul>\n+ *\n+ * A native linker only supports function descriptors whose argument\/return layouts are layouts supported by that linker\n+ * and are not sequence layouts.\n@@ -441,0 +481,2 @@\n+     * @implSpec A native linker implementation is guaranteed to provide canonical layouts for\n+     * <a href=\"#describing-c-sigs\">basic C types<\/a>.\n@@ -582,0 +624,16 @@\n+    \/**\n+     * {@return an unmodifiable mapping between the names of data types used by the ABI implemented by this linker and their\n+     * <em>canonical layouts<\/em>}\n+     * <p>\n+     * Each {@link Linker} is responsible for choosing the data types that are widely recognized as useful on the OS\n+     * and processor combination supported by the {@link Linker}. Accordingly, the precise set of data type names\n+     * and canonical layouts exposed by the linker is unspecified; it varies from one {@link Linker} to another.\n+     * @implNote It is strongly recommended that the result of {@link #canonicalLayouts()} exposes a set of symbols that is stable over time.\n+     * Clients of {@link #canonicalLayouts()} are likely to fail if a data type that was previously exposed by the linker\n+     * is no longer exposed, or if its canonical layout is updated.\n+     * <p>If an implementer provides {@link Linker} implementations for multiple OS and processor combinations, then it is strongly\n+     * recommended that the result of {@link #canonicalLayouts()} exposes, as much as possible, a consistent set of symbols\n+     * across all the OS and processor combinations.\n+     *\/\n+    Map<String, MemoryLayout> canonicalLayouts();\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/Linker.java","additions":79,"deletions":21,"binary":false,"changes":100,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import jdk.internal.foreign.CABI;\n@@ -54,0 +55,1 @@\n+import java.util.HashSet;\n@@ -56,0 +58,1 @@\n+import java.util.Map;\n@@ -57,0 +60,1 @@\n+import java.util.Set;\n@@ -133,0 +137,5 @@\n+    @Override\n+    public Map<String, MemoryLayout> canonicalLayouts() {\n+        return CANONICAL_LAYOUTS_MAP;\n+    }\n+\n@@ -151,1 +160,0 @@\n-        checkHasNaturalAlignment(layout);\n@@ -153,1 +161,1 @@\n-            checkByteOrder(vl);\n+            checkCanonical(vl);\n@@ -155,0 +163,1 @@\n+            checkHasNaturalAlignment(layout);\n@@ -170,0 +179,1 @@\n+            checkHasNaturalAlignment(layout);\n@@ -179,0 +189,1 @@\n+            checkHasNaturalAlignment(layout);\n@@ -203,0 +214,10 @@\n+    private static void checkCanonical(ValueLayout valueLayout) {\n+        valueLayout = valueLayout.withoutName();\n+        if (valueLayout instanceof AddressLayout addressLayout) {\n+            valueLayout = addressLayout.withoutTargetLayout();\n+        }\n+        if (!CANONICAL_LAYOUTS.contains(valueLayout.withoutName())) {\n+            throw new IllegalArgumentException(\"Value layout is not a canonical layout: \" + valueLayout);\n+        }\n+    }\n+\n@@ -235,5 +256,15 @@\n-    private void checkByteOrder(ValueLayout vl) {\n-        if (vl.order() != linkerByteOrder()) {\n-            throw new IllegalArgumentException(\"Layout does not have the right byte order: \" + vl);\n-        }\n-    }\n+    private static final Map<String, MemoryLayout> CANONICAL_LAYOUTS_MAP = Map.ofEntries(\n+            Map.entry(\"bool\", ValueLayout.JAVA_BOOLEAN),\n+            Map.entry(\"char\", ValueLayout.JAVA_BYTE),\n+            Map.entry(\"short\", ValueLayout.JAVA_SHORT),\n+            Map.entry(\"int\", ValueLayout.JAVA_INT),\n+            Map.entry(\"float\", ValueLayout.JAVA_FLOAT),\n+            Map.entry(\"long\", CABI.current() == CABI.WIN_64 ? ValueLayout.JAVA_INT : ValueLayout.JAVA_LONG),\n+            Map.entry(\"long long\", ValueLayout.JAVA_LONG),\n+            Map.entry(\"double\", ValueLayout.JAVA_DOUBLE),\n+            Map.entry(\"void*\", ValueLayout.ADDRESS),\n+            Map.entry(\"size_t\", ValueLayout.ADDRESS.byteSize() == ValueLayout.JAVA_INT.byteSize() ?\n+                    ValueLayout.JAVA_INT : ValueLayout.JAVA_LONG)\n+    );\n+\n+    private static final Set<MemoryLayout> CANONICAL_LAYOUTS = new HashSet<>(CANONICAL_LAYOUTS_MAP.values());\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/AbstractLinker.java","additions":38,"deletions":7,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -122,1 +122,1 @@\n-                    \"Layout alignment must be natural alignment\"\n+                    \"Value layout is not a canonical layout: 2%i4\"\n@@ -126,1 +126,1 @@\n-                    \"Layout alignment must be natural alignment\"\n+                    \"Value layout is not a canonical layout: 2%a8\"\n@@ -129,2 +129,2 @@\n-                    FunctionDescriptor.ofVoid(ValueLayout.JAVA_CHAR.withByteAlignment(4)),\n-                    \"Layout alignment must be natural alignment\"\n+                    FunctionDescriptor.ofVoid(C_SHORT.withByteAlignment(4)),\n+                    \"Value layout is not a canonical layout: 4%s2\"\n@@ -138,1 +138,1 @@\n-                    \"Layout alignment must be natural alignment\"\n+                    \"Value layout is not a canonical layout: 1%s2\"\n@@ -147,1 +147,1 @@\n-                    \"Layout alignment must be natural alignment\"\n+                    \"Value layout is not a canonical layout: 1%s2\"\n@@ -154,1 +154,1 @@\n-                    \"Layout alignment must be natural alignment\"\n+                    \"Value layout is not a canonical layout: 1%i4\"\n@@ -158,1 +158,1 @@\n-                            ValueLayout.JAVA_INT,\n+                            C_INT,\n@@ -160,1 +160,1 @@\n-                            ValueLayout.JAVA_INT)),\n+                            C_INT)),\n@@ -165,1 +165,1 @@\n-                    \"Layout does not have the right byte order\"\n+                    \"Value layout is not a canonical layout: I4\"\n@@ -169,1 +169,1 @@\n-                    \"Layout does not have the right byte order\"\n+                    \"Value layout is not a canonical layout: I4\"\n@@ -173,1 +173,1 @@\n-                    \"Layout does not have the right byte order\"\n+                    \"Value layout is not a canonical layout: I4\"\n@@ -177,2 +177,2 @@\n-                            ValueLayout.JAVA_LONG,\n-                            ValueLayout.JAVA_INT)), \/\/ missing trailing padding\n+                            C_LONG_LONG,\n+                            C_INT)), \/\/ missing trailing padding\n@@ -183,1 +183,1 @@\n-                            ValueLayout.JAVA_INT,\n+                            C_INT,\n","filename":"test\/jdk\/java\/foreign\/TestIllegalLink.java","additions":15,"deletions":15,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -47,2 +47,0 @@\n-import static java.lang.invoke.MethodType.methodType;\n-import static java.lang.foreign.ValueLayout.JAVA_CHAR;\n@@ -117,2 +115,2 @@\n-                    C_SHORT, JAVA_CHAR);\n-            Object[] args = {1, 10D, 2L, 3F, (byte) 0, (short) 13, 'a'};\n+                    C_SHORT, C_SHORT);\n+            Object[] args = {1, 10D, 2L, 3F, (byte) 0, (short) 13, (short) 14 };\n","filename":"test\/jdk\/java\/foreign\/TestIntrinsics.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -38,0 +38,2 @@\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.ValueLayout;\n@@ -44,4 +46,1 @@\n-import static java.lang.foreign.ValueLayout.JAVA_CHAR;\n-import static java.lang.foreign.ValueLayout.JAVA_SHORT;\n-import static org.testng.Assert.assertSame;\n-import static org.testng.Assert.assertNotSame;\n+import static org.testng.Assert.*;\n@@ -68,3 +67,1 @@\n-            {new LinkRequest(fd_II_V), new LinkRequest(fd_II_V, Linker.Option.firstVariadicArg(1))},\n-            {new LinkRequest(FunctionDescriptor.ofVoid(JAVA_SHORT)), new LinkRequest(FunctionDescriptor.ofVoid(JAVA_CHAR))},\n-            {new LinkRequest(FunctionDescriptor.ofVoid(JAVA_SHORT)), new LinkRequest(FunctionDescriptor.ofVoid(JAVA_CHAR))},\n+            {new LinkRequest(fd_II_V), new LinkRequest(fd_II_V, Linker.Option.firstVariadicArg(1))}\n@@ -141,0 +138,22 @@\n+    @Test\n+    public void testBasicTypes() {\n+        for (String basicType : BASIC_TYPES) {\n+            MemoryLayout layout = LINKER.canonicalLayouts().get(basicType);\n+            assertNotNull(layout);\n+            assertTrue(layout instanceof ValueLayout);\n+        }\n+    }\n+\n+    static String[] BASIC_TYPES = {\n+            \"bool\",\n+            \"char\",\n+            \"short\",\n+            \"int\",\n+            \"long\",\n+            \"long long\",\n+            \"float\",\n+            \"double\",\n+            \"void*\",\n+            \"size_t\"\n+    };\n+\n","filename":"test\/jdk\/java\/foreign\/TestLinker.java","additions":26,"deletions":7,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -169,2 +169,1 @@\n-            { JAVA_SHORT,   shortToInt((short) 42), SHORT_HOB_MASK,   SHORT_TO_INT,   SAVE_SHORT_AS_INT   },\n-            { JAVA_CHAR,    charToInt('a'),         CHAR_HOB_MASK,    CHAR_TO_INT,    SAVE_CHAR_AS_INT    }\n+            { JAVA_SHORT,   shortToInt((short) 42), SHORT_HOB_MASK,   SHORT_TO_INT,   SAVE_SHORT_AS_INT   }\n","filename":"test\/jdk\/java\/foreign\/normalize\/TestNormalize.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"}]}