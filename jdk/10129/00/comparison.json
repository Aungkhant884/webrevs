{"files":[{"patch":"@@ -331,1 +331,0 @@\n-  const size_t _renew_size;\n@@ -408,2 +407,1 @@\n-  _min_size(JfrOptionSet::stackdepth() * sizeof(intptr_t)),\n-  _renew_size(_min_size * 2),\n+  _min_size(max_frames * 2 * wordSize), \/\/ each frame tags at most 2 words, min size is a full stacktrace\n@@ -556,2 +554,2 @@\n-  const JfrBuffer* buffer = JfrTraceIdLoadBarrier::get_enqueue_buffer(this);\n-  return buffer != nullptr ? renew_if_full(buffer) : JfrTraceIdLoadBarrier::renew_enqueue_buffer(_renew_size, this);\n+  const JfrBuffer* buffer = JfrTraceIdLoadBarrier::get_sampler_enqueue_buffer(this);\n+  return buffer != nullptr ? renew_if_full(buffer) : JfrTraceIdLoadBarrier::renew_sampler_enqueue_buffer(this);\n@@ -562,1 +560,1 @@\n-  return enqueue_buffer->free_size() < _min_size ? JfrTraceIdLoadBarrier::renew_enqueue_buffer(_renew_size, this) : enqueue_buffer;\n+  return enqueue_buffer->free_size() < _min_size ? JfrTraceIdLoadBarrier::renew_sampler_enqueue_buffer(this) : enqueue_buffer;\n","filename":"src\/hotspot\/share\/jfr\/periodic\/sampling\/jfrThreadSampler.cpp","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022 Oracle and\/or its affiliates. All rights reserved.\n@@ -254,1 +254,1 @@\n-JfrBuffer* JfrTraceIdKlassQueue::renew_enqueue_buffer(size_t size, Thread* thread) {\n+JfrBuffer* JfrTraceIdKlassQueue::renew_enqueue_buffer(Thread* thread, size_t size \/* 0 *\/) {\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/traceid\/jfrTraceIdKlassQueue.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -72,1 +72,1 @@\n-  JfrBuffer* renew_enqueue_buffer(size_t size, Thread* thread);\n+  JfrBuffer* renew_enqueue_buffer(Thread* thread, size_t size = 0);\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/traceid\/jfrTraceIdKlassQueue.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+#include \"jfr\/recorder\/service\/jfrOptionSet.hpp\"\n@@ -32,0 +33,1 @@\n+#include \"utilities\/powerOfTwo.hpp\"\n@@ -33,2 +35,3 @@\n-\/\/ The queue instance used by the load barrier to enqueue tagged Klass'es.\n-static JfrTraceIdKlassQueue* _klass_queue = NULL;\n+\/\/ The queue instances are used by the load barrier to enqueue tagged Klass'es.\n+static JfrTraceIdKlassQueue* _klass_queue = nullptr; \/\/ Generic for all Java threads.\n+static JfrTraceIdKlassQueue* _sampler_klass_queue = nullptr; \/\/ Specialized for the Jfr Thread Sampler using use a larger buffer size.\n@@ -37,1 +40,1 @@\n-  assert(_klass_queue != NULL, \"invariant\");\n+  assert(_klass_queue != nullptr, \"invariant\");\n@@ -41,2 +44,18 @@\n-const size_t buffer_size_bytes = 1 * K; \/\/ min_elem_size of storage unit\n-const size_t prealloc_count = 32;\n+static JfrTraceIdKlassQueue& sampler_klass_queue() {\n+  assert(_sampler_klass_queue != nullptr, \"invariant\");\n+  return *_sampler_klass_queue;\n+}\n+\n+const constexpr size_t buffer_size_bytes = 1 * K; \/\/ min_elem_size of storage unit\n+const constexpr size_t prealloc_count = 32;\n+const constexpr size_t sampler_prealloc_count = 2;\n+\n+\/\/ The sampler thread cannot renew a buffer in-flight because it cannot acquire the malloc lock.\n+\/\/ It must therefore pre-allocate at least a full stack trace of buffer space before it can suspend a thread.\n+\/\/ This pre-allocation implies the need for a larger buffer size compared to other threads, a size that is a function\n+\/\/ of the stack depth parameter. For proper accommodation, there is a specialized queue only for the Jfr Sampler Thread.\n+static size_t derive_sampler_buffer_size() {\n+  size_t stackdepth_bytes = JfrOptionSet::stackdepth() * 2 * wordSize; \/\/ each frame tags at most 2 words\n+  stackdepth_bytes = round_up_power_of_2(stackdepth_bytes * 2); \/\/ accommodate at least two full stacktraces\n+  return MAX2(stackdepth_bytes, buffer_size_bytes);\n+}\n@@ -45,1 +64,1 @@\n-  assert(_klass_queue == NULL, \"invariant\");\n+  assert(_klass_queue == nullptr, \"invariant\");\n@@ -47,1 +66,8 @@\n-  return _klass_queue != NULL && _klass_queue->initialize(buffer_size_bytes, JFR_MSPACE_UNLIMITED_CACHE_SIZE, prealloc_count);\n+  if (_klass_queue == nullptr || !_klass_queue->initialize(buffer_size_bytes, JFR_MSPACE_UNLIMITED_CACHE_SIZE, prealloc_count)) {\n+    return false;\n+  }\n+  assert(_sampler_klass_queue == nullptr, \"invariant\");\n+  const size_t sampler_buffer_size_bytes = derive_sampler_buffer_size();\n+  assert(is_power_of_2(sampler_buffer_size_bytes), \"invariant\");\n+  _sampler_klass_queue = new JfrTraceIdKlassQueue();\n+  return _sampler_klass_queue != nullptr && _sampler_klass_queue->initialize(sampler_buffer_size_bytes, JFR_MSPACE_UNLIMITED_CACHE_SIZE, sampler_prealloc_count);\n@@ -51,1 +77,1 @@\n-  if (_klass_queue != NULL) {\n+  if (_klass_queue != nullptr) {\n@@ -54,0 +80,3 @@\n+  if (_sampler_klass_queue != nullptr) {\n+    _sampler_klass_queue->clear();\n+  }\n@@ -58,1 +87,3 @@\n-  _klass_queue = NULL;\n+  _klass_queue = nullptr;\n+  delete _sampler_klass_queue;\n+  _sampler_klass_queue = nullptr;\n@@ -62,1 +93,1 @@\n-  assert(klass != NULL, \"invariant\");\n+  assert(klass != nullptr, \"invariant\");\n@@ -67,3 +98,2 @@\n-void JfrTraceIdLoadBarrier::do_klasses(klass_callback callback, bool previous_epoch) {\n-  assert_locked_or_safepoint(ClassLoaderDataGraph_lock);\n-  klass_queue().iterate(callback, previous_epoch);\n+JfrBuffer* JfrTraceIdLoadBarrier::get_sampler_enqueue_buffer(Thread* thread) {\n+  return sampler_klass_queue().get_enqueue_buffer(thread);\n@@ -72,2 +102,2 @@\n-JfrBuffer* JfrTraceIdLoadBarrier::get_enqueue_buffer(Thread* thread) {\n-  return klass_queue().get_enqueue_buffer(thread);\n+JfrBuffer* JfrTraceIdLoadBarrier::renew_sampler_enqueue_buffer(Thread* thread) {\n+  return sampler_klass_queue().renew_enqueue_buffer(thread);\n@@ -76,2 +106,4 @@\n-JfrBuffer* JfrTraceIdLoadBarrier::renew_enqueue_buffer(size_t size, Thread* thread) {\n-  return klass_queue().renew_enqueue_buffer(size, thread);\n+void JfrTraceIdLoadBarrier::do_klasses(klass_callback callback, bool previous_epoch) {\n+  assert_locked_or_safepoint(ClassLoaderDataGraph_lock);\n+  klass_queue().iterate(callback, previous_epoch);\n+  sampler_klass_queue().iterate(callback, previous_epoch);\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/traceid\/jfrTraceIdLoadBarrier.cpp","additions":50,"deletions":18,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -81,2 +81,2 @@\n-  static JfrBuffer* get_enqueue_buffer(Thread* thread);\n-  static JfrBuffer* renew_enqueue_buffer(size_t size, Thread* thread);\n+  static JfrBuffer* get_sampler_enqueue_buffer(Thread* thread);\n+  static JfrBuffer* renew_sampler_enqueue_buffer(Thread* thread);\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/traceid\/jfrTraceIdLoadBarrier.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -229,1 +229,1 @@\n-  const JfrBuffer* const enqueue_buffer = JfrTraceIdLoadBarrier::get_enqueue_buffer(current_thread);\n+  const JfrBuffer* const enqueue_buffer = JfrTraceIdLoadBarrier::get_sampler_enqueue_buffer(current_thread);\n","filename":"src\/hotspot\/share\/jfr\/recorder\/stacktrace\/jfrStackTrace.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}