{"files":[{"patch":"@@ -307,4 +307,4 @@\n-size_t ReferenceProcessor::process_soft_weak_final_refs_work(DiscoveredList&    refs_list,\n-                                                             BoolObjectClosure* is_alive,\n-                                                             OopClosure*        keep_alive,\n-                                                             bool               do_enqueue_and_clear) {\n+size_t ReferenceProcessor::process_discovered_list_work(DiscoveredList&    refs_list,\n+                                                        BoolObjectClosure* is_alive,\n+                                                        OopClosure*        keep_alive,\n+                                                        bool               do_enqueue_and_clear) {\n@@ -353,2 +353,1 @@\n-                                                         OopClosure*     keep_alive,\n-                                                         VoidClosure*    complete_gc) {\n+                                                         OopClosure*     keep_alive) {\n@@ -370,2 +369,0 @@\n-  \/\/ Close the reachable set\n-  complete_gc->do_void();\n@@ -378,30 +375,0 @@\n-size_t ReferenceProcessor::process_phantom_refs_work(DiscoveredList&    refs_list,\n-                                                     BoolObjectClosure* is_alive,\n-                                                     OopClosure*        keep_alive,\n-                                                     VoidClosure*       complete_gc) {\n-  DiscoveredListIterator iter(refs_list, keep_alive, is_alive);\n-  while (iter.has_next()) {\n-    iter.load_ptrs(DEBUG_ONLY(!discovery_is_atomic() \/* allow_null_referent *\/));\n-\n-    oop const referent = iter.referent();\n-\n-    if (referent == NULL || iter.is_referent_alive()) {\n-      iter.make_referent_alive();\n-      iter.remove();\n-      iter.move_to_next();\n-    } else {\n-      iter.clear_referent();\n-      iter.enqueue();\n-      log_enqueued_ref(iter, \"cleared Phantom\");\n-      iter.next();\n-    }\n-  }\n-  iter.complete_enqueue();\n-  \/\/ Close the reachable set; needed for collectors which keep_alive_closure do\n-  \/\/ not immediately complete their work.\n-  complete_gc->do_void();\n-  refs_list.clear();\n-\n-  return iter.removed();\n-}\n-\n@@ -454,0 +421,33 @@\n+void RefProcTask::process_discovered_list(uint worker_id,\n+                                          ReferenceType ref_type,\n+                                          BoolObjectClosure* is_alive,\n+                                          OopClosure* keep_alive) {\n+  ReferenceProcessor::RefProcSubPhases subphase;\n+  DiscoveredList* dl;\n+  bool do_enqueue_and_clear;\n+  switch(ref_type) {\n+    case ReferenceType::REF_SOFT:\n+      subphase = ReferenceProcessor::ProcessSoftRefSubPhase;\n+      dl = _ref_processor._discoveredSoftRefs;\n+      do_enqueue_and_clear = true;\n+      break;\n+    case ReferenceType::REF_WEAK:\n+      subphase = ReferenceProcessor::ProcessWeakRefSubPhase;\n+      dl = _ref_processor._discoveredWeakRefs;\n+      do_enqueue_and_clear = true;\n+      break;\n+    case ReferenceType::REF_FINAL:\n+      subphase = ReferenceProcessor::ProcessFinalRefSubPhase;\n+      dl = _ref_processor._discoveredFinalRefs;\n+      do_enqueue_and_clear = false;\n+      break;\n+    case ReferenceType::REF_PHANTOM:\n+      subphase = ReferenceProcessor::ProcessPhantomRefsSubPhase;\n+      dl = _ref_processor._discoveredPhantomRefs;\n+      do_enqueue_and_clear = true;\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+  }\n+\n+  assert(do_enqueue_and_clear != (ref_type == REF_FINAL), \"Only Final refs are not enqueued\");\n@@ -455,11 +455,6 @@\n-class RefProcSoftWeakFinalPhaseTask: public RefProcTask {\n-  void run_phase(uint worker_id,\n-                  DiscoveredList list[],\n-                  BoolObjectClosure* is_alive,\n-                  OopClosure* keep_alive,\n-                  bool do_enqueue_and_clear,\n-                  ReferenceType ref_type) {\n-    size_t const removed = _ref_processor.process_soft_weak_final_refs_work(list[worker_id],\n-                                                                            is_alive,\n-                                                                            keep_alive,\n-                                                                            do_enqueue_and_clear);\n+  {\n+    RefProcSubPhasesWorkerTimeTracker tt(subphase, _phase_times, tracker_id(worker_id));\n+    size_t const removed = _ref_processor.process_discovered_list_work(dl[worker_id],\n+                                                                       is_alive,\n+                                                                       keep_alive,\n+                                                                       do_enqueue_and_clear);\n@@ -468,0 +463,1 @@\n+}\n@@ -469,0 +465,1 @@\n+class RefProcSoftWeakFinalPhaseTask: public RefProcTask {\n@@ -481,12 +478,7 @@\n-    {\n-      RefProcSubPhasesWorkerTimeTracker tt(ReferenceProcessor::ProcessSoftRefSubPhase, _phase_times, tracker_id(worker_id));\n-      run_phase(worker_id, _ref_processor._discoveredSoftRefs, is_alive, keep_alive, true \/* do_enqueue_and_clear *\/, REF_SOFT);\n-    }\n-    {\n-      RefProcSubPhasesWorkerTimeTracker tt(ReferenceProcessor::ProcessWeakRefSubPhase, _phase_times, tracker_id(worker_id));\n-      run_phase(worker_id, _ref_processor._discoveredWeakRefs, is_alive, keep_alive, true \/* do_enqueue_and_clear *\/, REF_WEAK);\n-    }\n-    {\n-      RefProcSubPhasesWorkerTimeTracker tt(ReferenceProcessor::ProcessFinalRefSubPhase, _phase_times, tracker_id(worker_id));\n-      run_phase(worker_id, _ref_processor._discoveredFinalRefs, is_alive, keep_alive, false \/* do_enqueue_and_clear *\/, REF_FINAL);\n-    }\n+\n+    process_discovered_list(worker_id, REF_SOFT, is_alive, keep_alive);\n+\n+    process_discovered_list(worker_id, REF_WEAK, is_alive, keep_alive);\n+\n+    process_discovered_list(worker_id, REF_FINAL, is_alive, keep_alive);\n+\n@@ -512,1 +504,3 @@\n-    _ref_processor.process_final_keep_alive_work(_ref_processor._discoveredFinalRefs[worker_id], keep_alive, complete_gc);\n+    _ref_processor.process_final_keep_alive_work(_ref_processor._discoveredFinalRefs[worker_id], keep_alive);\n+    \/\/ Close the reachable set\n+    complete_gc->do_void();\n@@ -528,6 +522,5 @@\n-    RefProcSubPhasesWorkerTimeTracker tt(ReferenceProcessor::ProcessPhantomRefsSubPhase, _phase_times, tracker_id(worker_id));\n-    size_t const removed = _ref_processor.process_phantom_refs_work(_ref_processor._discoveredPhantomRefs[worker_id],\n-                                                                    is_alive,\n-                                                                    keep_alive,\n-                                                                    complete_gc);\n-    _phase_times->add_ref_cleared(REF_PHANTOM, removed);\n+    process_discovered_list(worker_id, REF_PHANTOM, is_alive, keep_alive);\n+\n+    \/\/ Close the reachable set; needed for collectors which keep_alive_closure do\n+    \/\/ not immediately complete their work.\n+    complete_gc->do_void();\n","filename":"src\/hotspot\/share\/gc\/shared\/referenceProcessor.cpp","additions":61,"deletions":68,"binary":false,"changes":129,"status":"modified"},{"patch":"@@ -163,1 +163,1 @@\n-  friend class RefProcSoftWeakFinalPhaseTask;\n+  friend class RefProcTask;\n@@ -165,1 +165,0 @@\n-  friend class RefProcPhantomPhaseTask;\n@@ -256,4 +255,4 @@\n-  size_t process_soft_weak_final_refs_work(DiscoveredList&    refs_list,\n-                                           BoolObjectClosure* is_alive,\n-                                           OopClosure*        keep_alive,\n-                                           bool               do_enqueue_and_clear);\n+  size_t process_discovered_list_work(DiscoveredList&    refs_list,\n+                                      BoolObjectClosure* is_alive,\n+                                      OopClosure*        keep_alive,\n+                                      bool               do_enqueue_and_clear);\n@@ -263,8 +262,2 @@\n-  size_t process_final_keep_alive_work(DiscoveredList&    refs_list,\n-                                       OopClosure*        keep_alive,\n-                                       VoidClosure*       complete_gc);\n-\n-  size_t process_phantom_refs_work(DiscoveredList&    refs_list,\n-                                   BoolObjectClosure* is_alive,\n-                                   OopClosure*        keep_alive,\n-                                   VoidClosure*       complete_gc);\n+  size_t process_final_keep_alive_work(DiscoveredList& refs_list,\n+                                       OopClosure* keep_alive);\n@@ -542,0 +535,5 @@\n+\n+  void process_discovered_list(uint worker_id,\n+                               ReferenceType ref_type,\n+                               BoolObjectClosure* is_alive,\n+                               OopClosure* keep_alive);\n","filename":"src\/hotspot\/share\/gc\/shared\/referenceProcessor.hpp","additions":12,"deletions":14,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -243,1 +243,1 @@\n-  Atomic::add(&_ref_cleared[ref_type_2_index(ref_type)], count);\n+  Atomic::add(&_ref_cleared[ref_type_2_index(ref_type)], count, memory_order_relaxed);\n","filename":"src\/hotspot\/share\/gc\/shared\/referenceProcessorPhaseTimes.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}