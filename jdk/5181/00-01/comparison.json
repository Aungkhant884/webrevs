{"files":[{"patch":"@@ -27,0 +27,3 @@\n+#include \"gc\/g1\/g1CollectedHeap.hpp\"\n+#include \"gc\/g1\/heapRegion.hpp\"\n+#include \"gc\/g1\/heapRegion.inline.hpp\"\n@@ -30,3 +33,0 @@\n-static intptr_t order_oop(oop a, oop b) {\n-  return static_cast<intptr_t>(a-b);\n-}\n@@ -34,11 +34,5 @@\n-void G1EvacuationFailureObjsInHR::compact() {\n-  assert(_oop_array == NULL, \"Must be\");\n-  _oop_array = NEW_C_HEAP_ARRAY(oop, _objs_num, mtGC);\n-  Node* cur = _head._next;\n-  uint i = 0;\n-  while (cur != NULL) {\n-    assert(cur->_obj != NULL, \"Must be\");\n-    _oop_array[i++] = cur->_obj;\n-    cur = cur->_next;\n-  }\n-  clear_list();\n+\/\/ === G1EvacuationFailureObjsInHR ===\n+\n+void G1EvacuationFailureObjsInHR::visit(Elem elem) {\n+  uint32_t offset = elem;\n+  _offset_array[_objs_num++] = offset;\n@@ -47,2 +41,3 @@\n-void G1EvacuationFailureObjsInHR::sort() {\n-  QuickSort::sort(_oop_array, _objs_num, order_oop, true);\n+void G1EvacuationFailureObjsInHR::visit(Array<NODE_LENGTH, Elem>::NODE_XXX* node, uint32_t limit) {\n+  ::memcpy(&_offset_array[_objs_num], node->_oop_offsets, limit * sizeof(Elem));\n+  _objs_num += limit;\n@@ -51,7 +46,8 @@\n-void G1EvacuationFailureObjsInHR::iterate_internal(ObjectClosure* closure) {\n-  oop prev = NULL;\n-  for (uint i = 0; i < _objs_num; i++) {\n-    assert(prev < _oop_array[i], \"sanity\");\n-    closure->do_object(prev = _oop_array[i]);\n-  }\n-  clear_array();\n+void G1EvacuationFailureObjsInHR::compact() {\n+  assert(_offset_array == NULL, \"must be\");\n+  _offset_array = NEW_C_HEAP_ARRAY(Elem, _nodes_array.objs_num(), mtGC);\n+  \/\/ _nodes_array.iterate_elements(this);\n+  _nodes_array.iterate_nodes(this);\n+  uint expected = _nodes_array.objs_num();\n+  assert(_objs_num == expected, \"must be %u, %u\", _objs_num, expected);\n+  _nodes_array.reset();\n@@ -60,4 +56,6 @@\n-void G1EvacuationFailureObjsInHR::clear_list() {\n-  DEBUG_ONLY(uint i = _objs_num);\n-  Node* cur = _head._next;\n-  _head._next = NULL;\n+static int32_t order_oop(G1EvacuationFailureObjsInHR::Elem a,\n+                         G1EvacuationFailureObjsInHR::Elem b) {\n+  \/\/ assert(a != b, \"must be\");\n+  int r = a-b;\n+  return r;\n+}\n@@ -65,8 +63,2 @@\n-  while (cur != NULL) {\n-    Node* next = cur->_next;\n-    cur->_next = NULL;\n-    delete cur;\n-    cur = next;\n-    DEBUG_ONLY(i--);\n-  }\n-  assert(i == 0, \"Must be, %u\", i);\n+void G1EvacuationFailureObjsInHR::sort() {\n+  QuickSort::sort(_offset_array, _objs_num, order_oop, true);\n@@ -76,2 +68,2 @@\n-  FREE_C_HEAP_ARRAY(oop, _oop_array);\n-  _oop_array = NULL;\n+  FREE_C_HEAP_ARRAY(oop, _offset_array);\n+  _offset_array = NULL;\n@@ -81,2 +73,7 @@\n-void G1EvacuationFailureObjsInHR::reset() {\n-  Atomic::store(&_tail, &_head);\n+void G1EvacuationFailureObjsInHR::iterate_internal(ObjectClosure* closure) {\n+  Elem prev = 0;\n+  for (uint i = 0; i < _objs_num; i++) {\n+    assert(prev < _offset_array[i], \"must be\");\n+    closure->do_object(cast_from_offset(prev = _offset_array[i]));\n+  }\n+  clear_array();\n@@ -85,1 +82,2 @@\n-G1EvacuationFailureObjsInHR::G1EvacuationFailureObjsInHR(uint region_idx) :\n+G1EvacuationFailureObjsInHR::G1EvacuationFailureObjsInHR(uint region_idx, HeapWord* bottom) :\n+  offset_mask((1l << HeapRegion::LogOfHRGrainBytes) - 1),\n@@ -87,3 +85,4 @@\n-  _objs_num(0),\n-  _oop_array(NULL) {\n-  reset();\n+  _bottom(bottom),\n+  _nodes_array(HeapRegion::GrainWords \/ NODE_LENGTH + 1),\n+  _offset_array(NULL),\n+  _objs_num(0) {\n@@ -93,1 +92,0 @@\n-  clear_list();\n@@ -98,16 +96,6 @@\n-  assert(obj != NULL, \"Must be\");\n-  Node* new_one = new Node(obj);\n-  while (true) {\n-    Node* t = Atomic::load(&_tail);\n-    Node* next = Atomic::load(&t->_next);\n-    while (next != NULL) {\n-      t = next;\n-      next = Atomic::load(&next->_next);\n-    }\n-    Node* old_one = Atomic::cmpxchg(&t->_next, (Node*)NULL, new_one);\n-    if (old_one == NULL) {\n-      Atomic::store(&_tail, new_one);\n-      Atomic::inc(&_objs_num);\n-      break;\n-    }\n-  }\n+  assert(obj != NULL, \"must be\");\n+  assert(G1CollectedHeap::heap()->heap_region_containing(obj)->hrm_index() == _region_idx, \"must be\");\n+  Elem offset = cast_from_oop_addr(obj);\n+  assert(obj == cast_from_offset(offset), \"must be\");\n+  assert(offset < (1<<25), \"must be\");\n+  _nodes_array.add(offset);\n@@ -120,1 +108,0 @@\n-  reset();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1EvacuationFailureObjsInHR.cpp","additions":48,"deletions":61,"binary":false,"changes":109,"status":"modified"},{"patch":"@@ -36,0 +36,4 @@\n+  template<uint32_t LEN, typename Elem>\n+  class Array;\n+\n+  template<uint32_t LEN, typename Elem>\n@@ -38,0 +42,2 @@\n+    friend Array<LEN, Elem>;\n+\n@@ -39,2 +45,65 @@\n-    Node* volatile _next;\n-    oop _obj;\n+    static const uint32_t LENGTH = LEN;\n+    static const size_t SIZE = LENGTH * sizeof(Elem);\n+    Elem* _oop_offsets;\n+\n+  public:\n+    Node() {\n+      _oop_offsets = (Elem*)AllocateHeap(SIZE, mtGC);\n+    }\n+    Elem& operator[] (size_t idx) {\n+      return _oop_offsets[idx];\n+    }\n+    static Node<LEN, Elem>* create_node() {\n+      return new Node<LEN, Elem>();\n+    }\n+    static void free_node(Node<LEN, Elem>* node) {\n+      FreeHeap(node->_oop_offsets);\n+      delete(node);\n+    }\n+  };\n+\n+  template<uint32_t NODE_SIZE, typename Elem>\n+  class Array : public CHeapObj<mtGC> {\n+  public:\n+    typedef Node<NODE_SIZE, Elem> NODE_XXX;\n+\n+  private:\n+    static const uint64_t TMP = 1l << 32;\n+    static const uint64_t LOW_MASK = TMP - 1;\n+    static const uint64_t HIGH_MASK = LOW_MASK << 32;\n+    const uint32_t _max_nodes_length;\n+\n+    volatile uint64_t _cur_pos;\n+    NODE_XXX* volatile * _nodes;\n+    volatile uint _elements_num;\n+\n+  private:\n+    uint64_t low(uint64_t n) {\n+      return (n & LOW_MASK);\n+    }\n+    uint64_t high(uint64_t n) {\n+      return (n & HIGH_MASK);\n+    }\n+    uint32_t elem_index(uint64_t n) {\n+      assert(low(n) < NODE_XXX::LENGTH, \"must be\");\n+      return low(n);\n+    }\n+    uint32_t node_index(uint64_t n) {\n+      return high(n) >> 32;\n+    }\n+\n+    uint64_t next(uint64_t n) {\n+      uint64_t lo = low(n);\n+      uint64_t hi = high(n);\n+      assert((lo < NODE_XXX::LENGTH) && (NODE_XXX::LENGTH <= LOW_MASK), \"must be\");\n+      assert(hi < HIGH_MASK, \"must be\");\n+      if ((lo+1) == NODE_XXX::LENGTH) {\n+        lo = 0;\n+        hi += (1l << 32);\n+      } else {\n+        lo++;\n+      }\n+      assert(hi <= HIGH_MASK, \"must be\");\n+      return hi | lo;\n+    }\n+\n@@ -42,1 +111,78 @@\n-    Node(oop obj = NULL) : _next(NULL), _obj(obj) {}\n+    Array(uint32_t max_nodes_length) : _max_nodes_length(max_nodes_length) {\n+      _nodes = (NODE_XXX**)AllocateHeap(_max_nodes_length * sizeof(NODE_XXX*), mtGC);\n+      for (uint32_t i = 0; i < _max_nodes_length; i++) {\n+        Atomic::store(&_nodes[i], (NODE_XXX *)NULL);\n+      }\n+\n+      Atomic::store(&_elements_num, 0u);\n+      Atomic::store(&_cur_pos, (uint64_t)0);\n+    }\n+\n+    ~Array() {\n+      reset();\n+      FreeHeap((NODE_XXX**)_nodes);\n+    }\n+\n+    uint objs_num() {\n+      return Atomic::load(&_elements_num);\n+    }\n+\n+    void add(Elem elem) {\n+      while (true) {\n+        uint64_t pos = Atomic::load(&_cur_pos);\n+        uint64_t next_pos = next(pos);\n+        uint64_t res = Atomic::cmpxchg(&_cur_pos, pos, next_pos);\n+        if (res == pos) {\n+          uint32_t hi = node_index(pos);\n+          uint32_t lo = elem_index(pos);\n+          if (lo == 0) {\n+            Atomic::store(&_nodes[hi], NODE_XXX::create_node());\n+          }\n+          NODE_XXX* node = NULL;\n+          while ((node = Atomic::load(&_nodes[hi])) == NULL);\n+\n+          node->operator[](lo) = elem;\n+          Atomic::inc(&_elements_num);\n+          break;\n+        }\n+      }\n+    }\n+\n+    template<typename VISITOR>\n+    void iterate_elements(VISITOR v) {\n+      int64_t pos = Atomic::load(&_cur_pos);\n+      DEBUG_ONLY(uint total = 0);\n+      uint32_t hi = node_index(pos);\n+      uint32_t lo = elem_index(pos);\n+      for (uint32_t i = 0; i <= hi; i++) {\n+        uint32_t limit = (i == hi) ? lo : NODE_XXX::LENGTH;\n+        NODE_XXX* node = Atomic::load(&_nodes[i]);\n+        for (uint32_t j = 0; j < limit; j++) {\n+          v->visit(node->operator[](j));\n+          DEBUG_ONLY(total++);\n+        }\n+      }\n+      assert(total == Atomic::load(&_elements_num), \"must be\");\n+    }\n+\n+    template<typename VISITOR>\n+    void iterate_nodes(VISITOR v) {\n+      int64_t pos = Atomic::load(&_cur_pos);\n+      uint32_t hi = node_index(pos);\n+      uint32_t lo = elem_index(pos);\n+      for (uint32_t i = 0; i <= hi; i++) {\n+        NODE_XXX* node = Atomic::load(&_nodes[i]);\n+        uint32_t limit = (i == hi) ? lo : NODE_XXX::LENGTH;\n+        v->visit(node, limit);\n+      }\n+    }\n+\n+    void reset() {\n+      int64_t pos = Atomic::load(&_cur_pos);\n+      for (uint32_t hi = 0; hi <= node_index(pos); hi++) {\n+        NODE_XXX::free_node(_nodes[hi]);\n+        Atomic::store(&_nodes[hi], (NODE_XXX *)NULL);\n+      }\n+      Atomic::store(&_elements_num, 0u);\n+      Atomic::store(&_cur_pos, (uint64_t)0);\n+    }\n@@ -45,0 +191,3 @@\n+public:\n+  typedef uint32_t Elem;\n+\n@@ -46,0 +195,2 @@\n+  static const uint32_t NODE_LENGTH = 256;\n+  const uint64_t offset_mask;\n@@ -47,2 +198,3 @@\n-  Node  _head;\n-  Node* volatile _tail;\n+  const HeapWord* _bottom;\n+  Array<NODE_LENGTH, Elem> _nodes_array;\n+  Elem* _offset_array;\n@@ -50,1 +202,0 @@\n-  oop* _oop_array;\n@@ -53,0 +204,11 @@\n+  oop cast_from_offset(Elem offset) {\n+    return oop(_bottom + offset);\n+  }\n+  Elem cast_from_oop_addr(oop obj) {\n+    const HeapWord* o = cast_from_oop<const HeapWord*>(obj);\n+    size_t offset = pointer_delta(o, _bottom);\n+    assert(offset_mask >= offset, \"must be\");\n+    return offset & offset_mask;\n+  }\n+  void visit(Elem);\n+  void visit(Array<NODE_LENGTH, Elem>::NODE_XXX* node, uint32_t limit);\n@@ -55,2 +217,0 @@\n-  void iterate_internal(ObjectClosure* closure);\n-  void clear_list();\n@@ -58,1 +218,1 @@\n-  void reset();\n+  void iterate_internal(ObjectClosure* closure);\n@@ -61,1 +221,1 @@\n-  G1EvacuationFailureObjsInHR(uint region_idx);\n+  G1EvacuationFailureObjsInHR(uint region_idx, HeapWord* bottom);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1EvacuationFailureObjsInHR.hpp","additions":170,"deletions":10,"binary":false,"changes":180,"status":"modified"},{"patch":"@@ -260,1 +260,1 @@\n-  _evac_failure_objs(hrm_index)\n+  _evac_failure_objs(hrm_index, _bottom)\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}