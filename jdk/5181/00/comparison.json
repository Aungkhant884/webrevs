{"files":[{"patch":"@@ -117,40 +117,9 @@\n-    if (obj->is_forwarded() && obj->forwardee() == obj) {\n-      \/\/ The object failed to move.\n-\n-      zap_dead_objects(_last_forwarded_object_end, obj_addr);\n-      \/\/ We consider all objects that we find self-forwarded to be\n-      \/\/ live. What we'll do is that we'll update the prev marking\n-      \/\/ info so that they are all under PTAMS and explicitly marked.\n-      if (!_cm->is_marked_in_prev_bitmap(obj)) {\n-        _cm->mark_in_prev_bitmap(obj);\n-      }\n-      if (_during_concurrent_start) {\n-        \/\/ For the next marking info we'll only mark the\n-        \/\/ self-forwarded objects explicitly if we are during\n-        \/\/ concurrent start (since, normally, we only mark objects pointed\n-        \/\/ to by roots if we succeed in copying them). By marking all\n-        \/\/ self-forwarded objects we ensure that we mark any that are\n-        \/\/ still pointed to be roots. During concurrent marking, and\n-        \/\/ after concurrent start, we don't need to mark any objects\n-        \/\/ explicitly and all objects in the CSet are considered\n-        \/\/ (implicitly) live. So, we won't mark them explicitly and\n-        \/\/ we'll leave them over NTAMS.\n-        _cm->mark_in_next_bitmap(_worker_id, _hr, obj);\n-      }\n-      size_t obj_size = obj->size();\n-\n-      _marked_bytes += (obj_size * HeapWordSize);\n-      PreservedMarks::init_forwarded_mark(obj);\n-\n-      \/\/ During evacuation failure we do not record inter-region\n-      \/\/ references referencing regions that need a remembered set\n-      \/\/ update originating from young regions (including eden) that\n-      \/\/ failed evacuation. Make up for that omission now by rescanning\n-      \/\/ these failed objects.\n-      if (_is_young) {\n-        obj->oop_iterate(_log_buffer_cl);\n-      }\n-\n-      HeapWord* obj_end = obj_addr + obj_size;\n-      _last_forwarded_object_end = obj_end;\n-      _hr->cross_threshold(obj_addr, obj_end);\n+    \/\/ The object failed to move.\n+    assert(obj->is_forwarded() && obj->forwardee() == obj, \"sanity\");\n+\n+    zap_dead_objects(_last_forwarded_object_end, obj_addr);\n+    \/\/ We consider all objects that we find self-forwarded to be\n+    \/\/ live. What we'll do is that we'll update the prev marking\n+    \/\/ info so that they are all under PTAMS and explicitly marked.\n+    if (!_cm->is_marked_in_prev_bitmap(obj)) {\n+      _cm->mark_in_prev_bitmap(obj);\n@@ -158,0 +127,30 @@\n+    if (_during_concurrent_start) {\n+      \/\/ For the next marking info we'll only mark the\n+      \/\/ self-forwarded objects explicitly if we are during\n+      \/\/ concurrent start (since, normally, we only mark objects pointed\n+      \/\/ to by roots if we succeed in copying them). By marking all\n+      \/\/ self-forwarded objects we ensure that we mark any that are\n+      \/\/ still pointed to be roots. During concurrent marking, and\n+      \/\/ after concurrent start, we don't need to mark any objects\n+      \/\/ explicitly and all objects in the CSet are considered\n+      \/\/ (implicitly) live. So, we won't mark them explicitly and\n+      \/\/ we'll leave them over NTAMS.\n+      _cm->mark_in_next_bitmap(_worker_id, _hr, obj);\n+    }\n+    size_t obj_size = obj->size();\n+\n+    _marked_bytes += (obj_size * HeapWordSize);\n+    PreservedMarks::init_forwarded_mark(obj);\n+\n+    \/\/ During evacuation failure we do not record inter-region\n+    \/\/ references referencing regions that need a remembered set\n+    \/\/ update originating from young regions (including eden) that\n+    \/\/ failed evacuation. Make up for that omission now by rescanning\n+    \/\/ these failed objects.\n+    if (_is_young) {\n+      obj->oop_iterate(_log_buffer_cl);\n+    }\n+\n+    HeapWord* obj_end = obj_addr + obj_size;\n+    _last_forwarded_object_end = obj_end;\n+    _hr->cross_threshold(obj_addr, obj_end);\n@@ -226,1 +225,2 @@\n-    hr->object_iterate(&rspc);\n+    \/\/ Iterates evac failure objs which are recorded during evacuation.\n+    hr->iterate_evac_failure_objs(&rspc);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1EvacFailure.cpp","additions":41,"deletions":41,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -0,0 +1,121 @@\n+\/*\n+ * Copyright (c) 2021, Huawei and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"g1EvacuationFailureObjsInHR.hpp\"\n+#include \"utilities\/quickSort.hpp\"\n+\n+\n+static intptr_t order_oop(oop a, oop b) {\n+  return static_cast<intptr_t>(a-b);\n+}\n+\n+void G1EvacuationFailureObjsInHR::compact() {\n+  assert(_oop_array == NULL, \"Must be\");\n+  _oop_array = NEW_C_HEAP_ARRAY(oop, _objs_num, mtGC);\n+  Node* cur = _head._next;\n+  uint i = 0;\n+  while (cur != NULL) {\n+    assert(cur->_obj != NULL, \"Must be\");\n+    _oop_array[i++] = cur->_obj;\n+    cur = cur->_next;\n+  }\n+  clear_list();\n+}\n+\n+void G1EvacuationFailureObjsInHR::sort() {\n+  QuickSort::sort(_oop_array, _objs_num, order_oop, true);\n+}\n+\n+void G1EvacuationFailureObjsInHR::iterate_internal(ObjectClosure* closure) {\n+  oop prev = NULL;\n+  for (uint i = 0; i < _objs_num; i++) {\n+    assert(prev < _oop_array[i], \"sanity\");\n+    closure->do_object(prev = _oop_array[i]);\n+  }\n+  clear_array();\n+}\n+\n+void G1EvacuationFailureObjsInHR::clear_list() {\n+  DEBUG_ONLY(uint i = _objs_num);\n+  Node* cur = _head._next;\n+  _head._next = NULL;\n+\n+  while (cur != NULL) {\n+    Node* next = cur->_next;\n+    cur->_next = NULL;\n+    delete cur;\n+    cur = next;\n+    DEBUG_ONLY(i--);\n+  }\n+  assert(i == 0, \"Must be, %u\", i);\n+}\n+\n+void G1EvacuationFailureObjsInHR::clear_array() {\n+  FREE_C_HEAP_ARRAY(oop, _oop_array);\n+  _oop_array = NULL;\n+  _objs_num = 0;\n+}\n+\n+void G1EvacuationFailureObjsInHR::reset() {\n+  Atomic::store(&_tail, &_head);\n+}\n+\n+G1EvacuationFailureObjsInHR::G1EvacuationFailureObjsInHR(uint region_idx) :\n+  _region_idx(region_idx),\n+  _objs_num(0),\n+  _oop_array(NULL) {\n+  reset();\n+}\n+\n+G1EvacuationFailureObjsInHR::~G1EvacuationFailureObjsInHR() {\n+  clear_list();\n+  clear_array();\n+}\n+\n+void G1EvacuationFailureObjsInHR::record(oop obj) {\n+  assert(obj != NULL, \"Must be\");\n+  Node* new_one = new Node(obj);\n+  while (true) {\n+    Node* t = Atomic::load(&_tail);\n+    Node* next = Atomic::load(&t->_next);\n+    while (next != NULL) {\n+      t = next;\n+      next = Atomic::load(&next->_next);\n+    }\n+    Node* old_one = Atomic::cmpxchg(&t->_next, (Node*)NULL, new_one);\n+    if (old_one == NULL) {\n+      Atomic::store(&_tail, new_one);\n+      Atomic::inc(&_objs_num);\n+      break;\n+    }\n+  }\n+}\n+\n+void G1EvacuationFailureObjsInHR::iterate(ObjectClosure* closure) {\n+  compact();\n+  sort();\n+  iterate_internal(closure);\n+  reset();\n+}\n","filename":"src\/hotspot\/share\/gc\/g1\/g1EvacuationFailureObjsInHR.cpp","additions":121,"deletions":0,"binary":false,"changes":121,"status":"added"},{"patch":"@@ -0,0 +1,69 @@\n+\/*\n+ * Copyright (c) 2021, Huawei and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_G1_G1EVACUATIONFAILUREOBJSINHR_HPP\n+#define SHARE_GC_G1_G1EVACUATIONFAILUREOBJSINHR_HPP\n+\n+#include \"memory\/iterator.hpp\"\n+#include \"oops\/oop.hpp\"\n+\n+\/\/ This class\n+\/\/   1. records the objects per region which have failed to evacuate.\n+\/\/   2. speeds up removing self forwarded ptrs in post evacuation phase.\n+\/\/\n+class G1EvacuationFailureObjsInHR {\n+  class Node : public CHeapObj<mtGC>{\n+    friend G1EvacuationFailureObjsInHR;\n+  private:\n+    Node* volatile _next;\n+    oop _obj;\n+  public:\n+    Node(oop obj = NULL) : _next(NULL), _obj(obj) {}\n+  };\n+\n+private:\n+  const uint _region_idx;\n+  Node  _head;\n+  Node* volatile _tail;\n+  uint _objs_num;\n+  oop* _oop_array;\n+\n+private:\n+  void compact();\n+  void sort();\n+  void iterate_internal(ObjectClosure* closure);\n+  void clear_list();\n+  void clear_array();\n+  void reset();\n+\n+public:\n+  G1EvacuationFailureObjsInHR(uint region_idx);\n+  ~G1EvacuationFailureObjsInHR();\n+\n+  void record(oop obj);\n+  void iterate(ObjectClosure* closure);\n+};\n+\n+\n+#endif \/\/SHARE_GC_G1_G1EVACUATIONFAILUREOBJSINHR_HPP\n","filename":"src\/hotspot\/share\/gc\/g1\/g1EvacuationFailureObjsInHR.hpp","additions":69,"deletions":0,"binary":false,"changes":69,"status":"added"},{"patch":"@@ -605,0 +605,3 @@\n+    \/\/ Records evac failure objs, this will help speed up iteration\n+    \/\/ of these objs later in *remove self forward* phase of post evacuation.\n+    r->record_evac_failure_obj(old);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -111,0 +111,8 @@\n+void HeapRegion::record_evac_failure_obj(oop obj) {\n+  _evac_failure_objs.record(obj);\n+}\n+\n+void HeapRegion::iterate_evac_failure_objs(ObjectClosure* closure) {\n+  _evac_failure_objs.iterate(closure);\n+}\n+\n@@ -251,1 +259,2 @@\n-  _node_index(G1NUMA::UnknownNodeIndex)\n+  _node_index(G1NUMA::UnknownNodeIndex),\n+  _evac_failure_objs(hrm_index)\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.cpp","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"gc\/g1\/g1EvacuationFailureObjsInHR.hpp\"\n@@ -261,0 +262,2 @@\n+  G1EvacuationFailureObjsInHR _evac_failure_objs;\n+\n@@ -557,0 +560,5 @@\n+  \/\/ Records evac failure objs during evaucation, this will help speed up iteration\n+  \/\/ of these objs later in *remove self forward* phase of post evacuation.\n+  void record_evac_failure_obj(oop obj);\n+  \/\/ Iterates evac failure objs which are recorded during evcauation.\n+  void iterate_evac_failure_objs(ObjectClosure* closure);\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.hpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"}]}