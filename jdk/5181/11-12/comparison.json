{"files":[{"patch":"@@ -71,0 +71,1 @@\n+    assert(_last_forwarded_object_end <= obj_addr, \"should iterate in ascending address order\");\n","filename":"src\/hotspot\/share\/gc\/g1\/g1EvacFailure.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,149 @@\n+\/*\n+ * Copyright (c) 2021, Huawei and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"gc\/g1\/g1EvacFailureObjectsSet.hpp\"\n+#include \"gc\/g1\/g1CollectedHeap.hpp\"\n+#include \"gc\/g1\/g1SegmentedArray.inline.hpp\"\n+#include \"gc\/g1\/heapRegion.hpp\"\n+#include \"gc\/g1\/heapRegion.inline.hpp\"\n+#include \"utilities\/quickSort.hpp\"\n+\n+\n+const G1SegmentedArrayAllocOptions G1EvacFailureObjectsSet::_alloc_options =\n+  G1SegmentedArrayAllocOptions((uint)sizeof(OffsetInRegion), BufferLength, UINT_MAX, Alignment);\n+\n+G1SegmentedArrayBufferList<mtGC> G1EvacFailureObjectsSet::_free_buffer_list;\n+\n+#ifdef ASSERT\n+void G1EvacFailureObjectsSet::assert_is_valid_offset(size_t offset) const {\n+  const uint max_offset = 1u << (HeapRegion::LogOfHRGrainBytes - LogHeapWordSize);\n+  assert(offset < max_offset, \"must be, but is \" SIZE_FORMAT, offset);\n+}\n+#endif\n+\n+oop G1EvacFailureObjectsSet::from_offset(OffsetInRegion offset) const {\n+  assert_is_valid_offset(offset);\n+  return cast_to_oop(_bottom + offset);\n+}\n+\n+G1EvacFailureObjectsSet::OffsetInRegion G1EvacFailureObjectsSet::cast_to_offset(oop obj) const {\n+  const HeapWord* o = cast_from_oop<const HeapWord*>(obj);\n+  size_t offset = pointer_delta(o, _bottom);\n+  assert_is_valid_offset(offset);\n+  assert(obj == from_offset(offset), \"must be\");\n+  return static_cast<OffsetInRegion>(offset);\n+}\n+\n+G1EvacFailureObjectsSet::G1EvacFailureObjectsSet(uint region_idx, HeapWord* bottom) :\n+  DEBUG_ONLY(_region_idx(region_idx) COMMA)\n+  _bottom(bottom),\n+  _offsets(\"\", &_alloc_options, &_free_buffer_list)  {\n+  assert(HeapRegion::LogOfHRGrainBytes < 32, \"must be\");\n+}\n+\n+void G1EvacFailureObjectsSet::record(oop obj) {\n+  assert(obj != NULL, \"must be\");\n+  assert(_region_idx == G1CollectedHeap::heap()->heap_region_containing(obj)->hrm_index(), \"must be\");\n+  OffsetInRegion* e = _offsets.allocate();\n+  *e = cast_to_offset(obj);\n+}\n+\n+\/\/ Helper class to join, sort and iterate over the previously collected segmented\n+\/\/ array of objects that failed evacuation.\n+class G1EvacFailureObjectsIterator {\n+  typedef G1EvacFailureObjectsSet::OffsetInRegion OffsetInRegion;\n+  friend class G1SegmentedArray<OffsetInRegion, mtGC>;\n+  friend class G1SegmentedArrayBuffer<mtGC>;\n+\n+  G1EvacFailureObjectsSet* _collector;\n+  const G1SegmentedArray<OffsetInRegion, mtGC>* _segments;\n+  OffsetInRegion* _offset_array;\n+  uint _array_length;\n+\n+  static int order_oop(OffsetInRegion a, OffsetInRegion b) {\n+    return static_cast<int>(a-b);\n+  }\n+\n+  void join_and_sort() {\n+    uint num = _segments->num_allocated_nodes();\n+    _offset_array = NEW_C_HEAP_ARRAY(OffsetInRegion, num, mtGC);\n+\n+    _segments->iterate_nodes(*this);\n+    assert(_array_length == num, \"must be %u, %u\", _array_length, num);\n+\n+    QuickSort::sort(_offset_array, _array_length, order_oop, true);\n+  }\n+\n+  void iterate_internal(ObjectClosure* closure) {\n+    for (uint i = 0; i < _array_length; i++) {\n+      _collector->assert_is_valid_offset(_offset_array[i]);\n+      oop cur = _collector->from_offset(_offset_array[i]);\n+      closure->do_object(cur);\n+    }\n+\n+    FREE_C_HEAP_ARRAY(OffsetInRegion, _offset_array);\n+  }\n+\n+  \/\/ Callback of G1SegmentedArray::iterate_nodes\n+  void visit_buffer(G1SegmentedArrayBuffer<mtGC>* node, uint length) {\n+    node->copy_to(&_offset_array[_array_length]);\n+    _array_length += length;\n+\n+    \/\/ Verify elements in the node\n+    DEBUG_ONLY(node->iterate_elems(*this));\n+  }\n+\n+#ifdef ASSERT\n+  \/\/ Callback of G1SegmentedArrayBuffer::iterate_elems\n+  \/\/ Verify a single element in a segment node\n+  void visit_elem(void* elem) {\n+    uint* ptr = (uint*)elem;\n+    _collector->assert_is_valid_offset(*ptr);\n+  }\n+#endif\n+\n+public:\n+  G1EvacFailureObjectsIterator(G1EvacFailureObjectsSet* collector) :\n+    _collector(collector),\n+    _segments(&_collector->_offsets),\n+    _offset_array(nullptr),\n+    _array_length(0) { }\n+\n+  ~G1EvacFailureObjectsIterator() { }\n+\n+  void iterate(ObjectClosure* closure) {\n+    join_and_sort();\n+    iterate_internal(closure);\n+  }\n+};\n+\n+void G1EvacFailureObjectsSet::iterate(ObjectClosure* closure) {\n+  assert_at_safepoint();\n+\n+  G1EvacFailureObjectsIterator iterator(this);\n+  iterator.iterate(closure);\n+\n+  _offsets.drop_all();\n+}\n","filename":"src\/hotspot\/share\/gc\/g1\/g1EvacFailureObjectsSet.cpp","additions":149,"deletions":0,"binary":false,"changes":149,"status":"added"},{"patch":"@@ -0,0 +1,82 @@\n+\/*\n+ * Copyright (c) 2021, Huawei and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_G1_G1EVACUATIONFAILUREOBJSINHR_HPP\n+#define SHARE_GC_G1_G1EVACUATIONFAILUREOBJSINHR_HPP\n+\n+#include \"gc\/g1\/g1SegmentedArray.hpp\"\n+#include \"memory\/iterator.hpp\"\n+#include \"oops\/oop.hpp\"\n+\n+class G1EvacFailureObjectsIterator;\n+\n+\/\/ This class collects addresses of objects that failed evacuation in a specific\n+\/\/ heap region.\n+\/\/ Provides sorted iteration of these elements for processing during the remove\n+\/\/ self forwards phase.\n+class G1EvacFailureObjectsSet {\n+  friend class G1EvacFailureObjectsIterator;\n+\n+public:\n+  \/\/ Storage type of an object that failed evacuation within a region. Given\n+  \/\/ heap region size and possible object locations within a region, it is\n+  \/\/ sufficient to use an uint here to save some space instead of full pointers.\n+  typedef uint OffsetInRegion;\n+\n+private:\n+  static const uint BufferLength = 256;\n+  static const uint Alignment = 4;\n+\n+  static const G1SegmentedArrayAllocOptions _alloc_options;\n+\n+  \/\/ This free list is shared among evacuation failure process in all regions.\n+  static G1SegmentedArrayBufferList<mtGC> _free_buffer_list;\n+\n+  DEBUG_ONLY(const uint _region_idx;)\n+\n+  \/\/ Region bottom\n+  const HeapWord* _bottom;\n+\n+  \/\/ Offsets within region containing objects that failed evacuation.\n+  G1SegmentedArray<OffsetInRegion, mtGC> _offsets;\n+\n+  void assert_is_valid_offset(size_t offset) const NOT_DEBUG_RETURN;\n+  \/\/ Converts between an offset within a region and an oop address.\n+  oop from_offset(OffsetInRegion offset) const;\n+  OffsetInRegion cast_to_offset(oop obj) const;\n+\n+public:\n+  G1EvacFailureObjectsSet(uint region_idx, HeapWord* bottom);\n+  ~G1EvacFailureObjectsSet() { }\n+\n+  \/\/ Record an object that failed evacuation.\n+  void record(oop obj);\n+\n+  \/\/ Apply the given ObjectClosure to all objects that failed evacuation. Objects\n+  \/\/ are passed in increasing address order.\n+  void iterate(ObjectClosure* closure);\n+};\n+\n+\n+#endif \/\/SHARE_GC_G1_G1EVACUATIONFAILUREOBJSINHR_HPP\n","filename":"src\/hotspot\/share\/gc\/g1\/g1EvacFailureObjectsSet.hpp","additions":82,"deletions":0,"binary":false,"changes":82,"status":"added"},{"patch":"@@ -1,119 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Huawei and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"precompiled.hpp\"\n-#include \"gc\/g1\/g1EvacFailureObjsInHR.hpp\"\n-#include \"gc\/g1\/g1CollectedHeap.hpp\"\n-#include \"gc\/g1\/g1SegmentedArray.inline.hpp\"\n-#include \"gc\/g1\/heapRegion.hpp\"\n-#include \"gc\/g1\/heapRegion.inline.hpp\"\n-#include \"utilities\/quickSort.hpp\"\n-\n-\n-const uint G1EvacFailureObjsInHR::MaxBufferLength =\n-  static_cast<uint>(1u << (HeapRegion::LogOfHRGrainBytes-LogHeapWordSize));\n-\n-const G1SegmentedArrayAllocOptions G1EvacFailureObjsInHR::_alloc_options =\n-  G1SegmentedArrayAllocOptions(uint(sizeof (Elem)), BufferLength, UINT_MAX, Alignment);\n-G1SegmentedArrayBufferList<mtGC> G1EvacFailureObjsInHR::_free_buffer_list;\n-\n-void G1EvacFailureObjsInHR::visit_buffer(G1SegmentedArrayBuffer<mtGC>* node, uint limit) {\n-  node->copy_to(&_offset_array[_objs_num]);\n-  _objs_num += limit;\n-  \/\/ Verify elements in the buffer\n-  DEBUG_ONLY(node->iterate_elems(*this));\n-}\n-\n-void G1EvacFailureObjsInHR::visit_elem(void* elem) {\n-  uint* ptr = (uint*)elem;\n-  assert(*ptr < _max_offset, \"must be, %u\", *ptr);\n-}\n-\n-void G1EvacFailureObjsInHR::compact() {\n-  assert_at_safepoint();\n-  assert(_offset_array == NULL, \"must be\");\n-  uint num = _nodes_array.num_allocated_nodes();\n-  _offset_array = NEW_C_HEAP_ARRAY(Elem, num, mtGC);\n-  \/\/ Copy buffers' data to local array\n-  _nodes_array.iterate_nodes(*this);\n-  assert(_objs_num == num, \"must be %u, %u\", _objs_num, num);\n-  \/\/ We're at safepoint, no need to sync by GlobalCounter\n-  _nodes_array.drop_all();\n-}\n-\n-static int order_oop(G1EvacFailureObjsInHR::Elem a,\n-                     G1EvacFailureObjsInHR::Elem b) {\n-  return static_cast<int>(a-b);\n-}\n-\n-void G1EvacFailureObjsInHR::sort() {\n-  QuickSort::sort(_offset_array, _objs_num, order_oop, true);\n-}\n-\n-void G1EvacFailureObjsInHR::clear_array() {\n-  FREE_C_HEAP_ARRAY(Elem, _offset_array);\n-  _offset_array = NULL;\n-  _objs_num = 0;\n-}\n-\n-void G1EvacFailureObjsInHR::iterate_internal(ObjectClosure* closure) {\n-  Elem prev = 0;\n-  for (uint i = 0; i < _objs_num; i++) {\n-    assert(i == 0 ? (prev <= _offset_array[i]) : (prev < _offset_array[i]),\n-           \"must be, %u, %u, %u\", i, prev, _offset_array[i]);\n-    assert(prev < _max_offset, \"must be, %u\", prev);\n-    closure->do_object(cast_from_offset(prev = _offset_array[i]));\n-  }\n-  clear_array();\n-}\n-\n-G1EvacFailureObjsInHR::G1EvacFailureObjsInHR(uint region_idx, HeapWord* bottom) :\n-  _max_offset(static_cast<Elem>(1u << (HeapRegion::LogOfHRGrainBytes-LogHeapWordSize))),\n-  _region_idx(region_idx),\n-  _bottom(bottom),\n-  _nodes_array(\"\", &_alloc_options, &_free_buffer_list),\n-  _offset_array(NULL),\n-  _objs_num(0) {\n-  assert(HeapRegion::LogOfHRGrainBytes < 32, \"must be\");\n-}\n-\n-G1EvacFailureObjsInHR::~G1EvacFailureObjsInHR() {\n-  assert(_offset_array == NULL, \"must be\");\n-}\n-\n-void G1EvacFailureObjsInHR::record(oop obj) {\n-  assert(obj != NULL, \"must be\");\n-  assert(_region_idx == G1CollectedHeap::heap()->heap_region_containing(obj)->hrm_index(), \"must be\");\n-  Elem offset = cast_from_oop_addr(obj);\n-  assert(obj == cast_from_offset(offset), \"must be\");\n-  assert(offset < _max_offset, \"must be, %u\", offset);\n-  Elem* e = _nodes_array.allocate();\n-  *e = offset;\n-}\n-\n-void G1EvacFailureObjsInHR::iterate(ObjectClosure* closure) {\n-  compact();\n-  sort();\n-  iterate_internal(closure);\n-}\n","filename":"src\/hotspot\/share\/gc\/g1\/g1EvacFailureObjsInHR.cpp","additions":0,"deletions":119,"binary":false,"changes":119,"status":"deleted"},{"patch":"@@ -1,94 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Huawei and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_GC_G1_G1EVACUATIONFAILUREOBJSINHR_HPP\n-#define SHARE_GC_G1_G1EVACUATIONFAILUREOBJSINHR_HPP\n-\n-#include \"gc\/g1\/g1SegmentedArray.hpp\"\n-#include \"memory\/iterator.hpp\"\n-#include \"oops\/oop.hpp\"\n-\n-\/\/ This class\n-\/\/   1. records the objects per region which have failed to evacuate.\n-\/\/   2. speeds up removing self forwarded ptrs in post evacuation phase.\n-\/\/\n-class G1EvacFailureObjsInHR {\n-\n-public:\n-  typedef uint Elem;\n-\n-private:\n-  static const uint BufferLength = 256;\n-  static const uint MaxBufferLength;\n-  static const uint Alignment = 4;\n-\n-  static const G1SegmentedArrayAllocOptions _alloc_options;\n-  \/\/ This free list is shared among evacuation failure process in all regions.\n-  static G1SegmentedArrayBufferList<mtGC> _free_buffer_list;\n-\n-  const Elem _max_offset;\n-  const uint _region_idx;\n-  const HeapWord* _bottom;\n-\n-  \/\/ To improve space efficiency, elements are offset rather than raw addr\n-  G1SegmentedArray<Elem, mtGC> _nodes_array;\n-  \/\/ Local array contains the _nodes_array data in flat layout\n-  Elem* _offset_array;\n-  uint _objs_num;\n-\n-private:\n-  oop cast_from_offset(Elem offset) {\n-    return cast_to_oop(_bottom + offset);\n-  }\n-  Elem cast_from_oop_addr(oop obj) {\n-    const HeapWord* o = cast_from_oop<const HeapWord*>(obj);\n-    size_t offset = pointer_delta(o, _bottom);\n-    return static_cast<Elem>(offset);\n-  }\n-\n-  \/\/ Copy buffers' data to local array, must be called at safepoint\n-  void compact();\n-  void sort();\n-  void clear_array();\n-  \/\/ Iterate through evac failure objects in local array\n-  void iterate_internal(ObjectClosure* closure);\n-\n-public:\n-  G1EvacFailureObjsInHR(uint region_idx, HeapWord* bottom);\n-  ~G1EvacFailureObjsInHR();\n-\n-  \/\/ Record an evac failure object\n-  void record(oop obj);\n-  \/\/ Iterate through evac failure objects\n-  void iterate(ObjectClosure* closure);\n-\n-  \/\/ Copy a buffer data to local array\n-  void visit_buffer(G1SegmentedArrayBuffer<mtGC>* node, uint limit);\n-\n-  \/\/ Verify elements in the buffer\n-  void visit_elem(void* elem);\n-};\n-\n-\n-#endif \/\/SHARE_GC_G1_G1EVACUATIONFAILUREOBJSINHR_HPP\n","filename":"src\/hotspot\/share\/gc\/g1\/g1EvacFailureObjsInHR.hpp","additions":0,"deletions":94,"binary":false,"changes":94,"status":"deleted"},{"patch":"@@ -77,3 +77,3 @@\n-    \/\/ _next_allocate might grow greater than _num_elems in multi-thread env,\n-    \/\/ so, here we need to return the adjusted real length value.\n-    return _next_allocate > _num_elems ? _num_elems : _next_allocate;\n+    \/\/ _next_allocate might grow larger than _num_elems in multi-thread environments\n+    \/\/ due to races.\n+    return MIN2(_next_allocate, _num_elems);\n@@ -82,0 +82,1 @@\n+  \/\/ Copies the (valid) contents of this buffer into the destination.\n","filename":"src\/hotspot\/share\/gc\/g1\/g1SegmentedArray.hpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -272,2 +272,2 @@\n-  if (cur != nullptr) {\n-    assert(_last != nullptr, \"If there is at least one element, there must be a last one.\");\n+  assert((cur != nullptr) == (_last != nullptr),\n+         \"If there is at least one element, there must be a last one\");\n@@ -275,6 +275,3 @@\n-    while (cur != nullptr) {\n-      uint limit = cur->length();\n-      v.visit_buffer(cur, limit);\n-\n-      cur = cur->next();\n-    }\n+  while (cur != nullptr) {\n+    v.visit_buffer(cur, cur->length());\n+    cur = cur->next();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1SegmentedArray.inline.hpp","additions":5,"deletions":8,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-#include \"gc\/g1\/g1EvacFailureObjsInHR.hpp\"\n+#include \"gc\/g1\/g1EvacFailureObjectsSet.hpp\"\n@@ -262,1 +262,1 @@\n-  G1EvacFailureObjsInHR _evac_failure_objs;\n+  G1EvacFailureObjectsSet _evac_failure_objs;\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}