{"files":[{"patch":"@@ -0,0 +1,119 @@\n+\/*\n+ * Copyright (c) 2021, Huawei and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"gc\/g1\/g1EvacFailureObjsInHR.hpp\"\n+#include \"gc\/g1\/g1CollectedHeap.hpp\"\n+#include \"gc\/g1\/g1SegmentedArray.inline.hpp\"\n+#include \"gc\/g1\/heapRegion.hpp\"\n+#include \"gc\/g1\/heapRegion.inline.hpp\"\n+#include \"utilities\/quickSort.hpp\"\n+\n+\n+const uint G1EvacFailureObjsInHR::MaxBufferLength =\n+  static_cast<uint>(1u << (HeapRegion::LogOfHRGrainBytes-LogHeapWordSize));\n+\n+const G1SegmentedArrayAllocOptions G1EvacFailureObjsInHR::_alloc_options =\n+  G1SegmentedArrayAllocOptions(uint(sizeof (Elem)), BufferLength, UINT_MAX, Alignment);\n+G1SegmentedArrayBufferList<mtGC> G1EvacFailureObjsInHR::_free_buffer_list;\n+\n+void G1EvacFailureObjsInHR::visit_buffer(G1SegmentedArrayBuffer<mtGC>* node, uint limit) {\n+  node->copy_to(&_offset_array[_objs_num]);\n+  _objs_num += limit;\n+  \/\/ Verify elements in the buffer\n+  DEBUG_ONLY(node->iterate_elems(*this));\n+}\n+\n+void G1EvacFailureObjsInHR::visit_elem(void* elem) {\n+  uint* ptr = (uint*)elem;\n+  assert(*ptr < _max_offset, \"must be, %u\", *ptr);\n+}\n+\n+void G1EvacFailureObjsInHR::compact() {\n+  assert_at_safepoint();\n+  assert(_offset_array == NULL, \"must be\");\n+  uint num = _nodes_array.num_allocated_nodes();\n+  _offset_array = NEW_C_HEAP_ARRAY(Elem, num, mtGC);\n+  \/\/ Copy buffers' data to local array\n+  _nodes_array.iterate_nodes(*this);\n+  assert(_objs_num == num, \"must be %u, %u\", _objs_num, num);\n+  \/\/ We're at safepoint, no need to sync by GlobalCounter\n+  _nodes_array.drop_all();\n+}\n+\n+static int order_oop(G1EvacFailureObjsInHR::Elem a,\n+                     G1EvacFailureObjsInHR::Elem b) {\n+  return static_cast<int>(a-b);\n+}\n+\n+void G1EvacFailureObjsInHR::sort() {\n+  QuickSort::sort(_offset_array, _objs_num, order_oop, true);\n+}\n+\n+void G1EvacFailureObjsInHR::clear_array() {\n+  FREE_C_HEAP_ARRAY(Elem, _offset_array);\n+  _offset_array = NULL;\n+  _objs_num = 0;\n+}\n+\n+void G1EvacFailureObjsInHR::iterate_internal(ObjectClosure* closure) {\n+  Elem prev = 0;\n+  for (uint i = 0; i < _objs_num; i++) {\n+    assert(i == 0 ? (prev <= _offset_array[i]) : (prev < _offset_array[i]),\n+           \"must be, %u, %u, %u\", i, prev, _offset_array[i]);\n+    assert(prev < _max_offset, \"must be, %u\", prev);\n+    closure->do_object(cast_from_offset(prev = _offset_array[i]));\n+  }\n+  clear_array();\n+}\n+\n+G1EvacFailureObjsInHR::G1EvacFailureObjsInHR(uint region_idx, HeapWord* bottom) :\n+  _max_offset(static_cast<Elem>(1u << (HeapRegion::LogOfHRGrainBytes-LogHeapWordSize))),\n+  _region_idx(region_idx),\n+  _bottom(bottom),\n+  _nodes_array(\"\", &_alloc_options, &_free_buffer_list),\n+  _offset_array(NULL),\n+  _objs_num(0) {\n+  assert(HeapRegion::LogOfHRGrainBytes < 32, \"must be\");\n+}\n+\n+G1EvacFailureObjsInHR::~G1EvacFailureObjsInHR() {\n+  assert(_offset_array == NULL, \"must be\");\n+}\n+\n+void G1EvacFailureObjsInHR::record(oop obj) {\n+  assert(obj != NULL, \"must be\");\n+  assert(_region_idx == G1CollectedHeap::heap()->heap_region_containing(obj)->hrm_index(), \"must be\");\n+  Elem offset = cast_from_oop_addr(obj);\n+  assert(obj == cast_from_offset(offset), \"must be\");\n+  assert(offset < _max_offset, \"must be, %u\", offset);\n+  Elem* e = _nodes_array.allocate();\n+  *e = offset;\n+}\n+\n+void G1EvacFailureObjsInHR::iterate(ObjectClosure* closure) {\n+  compact();\n+  sort();\n+  iterate_internal(closure);\n+}\n","filename":"src\/hotspot\/share\/gc\/g1\/g1EvacFailureObjsInHR.cpp","additions":119,"deletions":0,"binary":false,"changes":119,"status":"added"},{"patch":"@@ -36,1 +36,1 @@\n-class G1EvacuationFailureObjsInHR {\n+class G1EvacFailureObjsInHR {\n@@ -78,2 +78,2 @@\n-  G1EvacuationFailureObjsInHR(uint region_idx, HeapWord* bottom);\n-  ~G1EvacuationFailureObjsInHR();\n+  G1EvacFailureObjsInHR(uint region_idx, HeapWord* bottom);\n+  ~G1EvacFailureObjsInHR();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1EvacFailureObjsInHR.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"previous_filename":"src\/hotspot\/share\/gc\/g1\/g1EvacuationFailureObjsInHR.hpp","status":"renamed"},{"patch":"@@ -1,119 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Huawei and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"precompiled.hpp\"\n-#include \"gc\/g1\/g1EvacuationFailureObjsInHR.hpp\"\n-#include \"gc\/g1\/g1CollectedHeap.hpp\"\n-#include \"gc\/g1\/g1SegmentedArray.inline.hpp\"\n-#include \"gc\/g1\/heapRegion.hpp\"\n-#include \"gc\/g1\/heapRegion.inline.hpp\"\n-#include \"utilities\/quickSort.hpp\"\n-\n-\n-const uint G1EvacuationFailureObjsInHR::MaxBufferLength =\n-  static_cast<uint>(1u << (HeapRegion::LogOfHRGrainBytes-LogHeapWordSize));\n-\n-const G1SegmentedArrayAllocOptions G1EvacuationFailureObjsInHR::_alloc_options =\n-  G1SegmentedArrayAllocOptions(uint(sizeof (Elem)), BufferLength, UINT_MAX, Alignment);\n-G1SegmentedArrayBufferList<mtGC> G1EvacuationFailureObjsInHR::_free_buffer_list;\n-\n-void G1EvacuationFailureObjsInHR::visit_buffer(G1SegmentedArrayBuffer<mtGC>* node, uint limit) {\n-  node->copy_to(&_offset_array[_objs_num]);\n-  _objs_num += limit;\n-  \/\/ Verify elements in the buffer\n-  DEBUG_ONLY(node->iterate_elems(*this));\n-}\n-\n-void G1EvacuationFailureObjsInHR::visit_elem(void* elem) {\n-  uint* ptr = (uint*)elem;\n-  assert(*ptr < _max_offset, \"must be, %u\", *ptr);\n-}\n-\n-void G1EvacuationFailureObjsInHR::compact() {\n-  assert_at_safepoint();\n-  assert(_offset_array == NULL, \"must be\");\n-  uint num = _nodes_array.num_allocated_nodes();\n-  _offset_array = NEW_C_HEAP_ARRAY(Elem, num, mtGC);\n-  \/\/ Copy buffers' data to local array\n-  _nodes_array.iterate_nodes(*this);\n-  assert(_objs_num == num, \"must be %u, %u\", _objs_num, num);\n-  \/\/ We're at safepoint, no need to sync by GlobalCounter\n-  _nodes_array.drop_all();\n-}\n-\n-static int order_oop(G1EvacuationFailureObjsInHR::Elem a,\n-                     G1EvacuationFailureObjsInHR::Elem b) {\n-  return static_cast<int>(a-b);\n-}\n-\n-void G1EvacuationFailureObjsInHR::sort() {\n-  QuickSort::sort(_offset_array, _objs_num, order_oop, true);\n-}\n-\n-void G1EvacuationFailureObjsInHR::clear_array() {\n-  FREE_C_HEAP_ARRAY(Elem, _offset_array);\n-  _offset_array = NULL;\n-  _objs_num = 0;\n-}\n-\n-void G1EvacuationFailureObjsInHR::iterate_internal(ObjectClosure* closure) {\n-  Elem prev = 0;\n-  for (uint i = 0; i < _objs_num; i++) {\n-    assert(i == 0 ? (prev <= _offset_array[i]) : (prev < _offset_array[i]),\n-           \"must be, %u, %u, %u\", i, prev, _offset_array[i]);\n-    assert(prev < _max_offset, \"must be, %u\", prev);\n-    closure->do_object(cast_from_offset(prev = _offset_array[i]));\n-  }\n-  clear_array();\n-}\n-\n-G1EvacuationFailureObjsInHR::G1EvacuationFailureObjsInHR(uint region_idx, HeapWord* bottom) :\n-  _max_offset(static_cast<Elem>(1u << (HeapRegion::LogOfHRGrainBytes-LogHeapWordSize))),\n-  _region_idx(region_idx),\n-  _bottom(bottom),\n-  _nodes_array(\"\", &_alloc_options, &_free_buffer_list),\n-  _offset_array(NULL),\n-  _objs_num(0) {\n-  assert(HeapRegion::LogOfHRGrainBytes < 32, \"must be\");\n-}\n-\n-G1EvacuationFailureObjsInHR::~G1EvacuationFailureObjsInHR() {\n-  assert(_offset_array == NULL, \"must be\");\n-}\n-\n-void G1EvacuationFailureObjsInHR::record(oop obj) {\n-  assert(obj != NULL, \"must be\");\n-  assert(_region_idx == G1CollectedHeap::heap()->heap_region_containing(obj)->hrm_index(), \"must be\");\n-  Elem offset = cast_from_oop_addr(obj);\n-  assert(obj == cast_from_offset(offset), \"must be\");\n-  assert(offset < _max_offset, \"must be, %u\", offset);\n-  Elem* e = _nodes_array.allocate();\n-  *e = offset;\n-}\n-\n-void G1EvacuationFailureObjsInHR::iterate(ObjectClosure* closure) {\n-  compact();\n-  sort();\n-  iterate_internal(closure);\n-}\n","filename":"src\/hotspot\/share\/gc\/g1\/g1EvacuationFailureObjsInHR.cpp","additions":0,"deletions":119,"binary":false,"changes":119,"status":"deleted"},{"patch":"@@ -29,1 +29,1 @@\n-#include \"gc\/g1\/g1EvacuationFailureObjsInHR.hpp\"\n+#include \"gc\/g1\/g1EvacFailureObjsInHR.hpp\"\n@@ -262,1 +262,1 @@\n-  G1EvacuationFailureObjsInHR _evac_failure_objs;\n+  G1EvacFailureObjsInHR _evac_failure_objs;\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}