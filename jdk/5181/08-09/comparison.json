{"files":[{"patch":"@@ -26,1 +26,1 @@\n-#include \"g1EvacuationFailureObjsInHR.hpp\"\n+#include \"gc\/g1\/g1EvacuationFailureObjsInHR.hpp\"\n@@ -28,0 +28,1 @@\n+#include \"gc\/g1\/g1SegmentedArray.inline.hpp\"\n@@ -33,0 +34,2 @@\n+const uint G1EvacuationFailureObjsInHR::MaxBufferLength =\n+  static_cast<uint>(1u << (HeapRegion::LogOfHRGrainBytes-LogHeapWordSize));\n@@ -34,1 +37,3 @@\n-\/\/ === G1EvacuationFailureObjsInHR ===\n+const G1SegmentedArrayAllocOptions G1EvacuationFailureObjsInHR::_alloc_options =\n+  G1SegmentedArrayAllocOptions(uint(sizeof (Elem)), BufferLength, UINT_MAX, Alignment);\n+G1SegmentedArrayBufferList<mtGC> G1EvacuationFailureObjsInHR::_free_buffer_list;\n@@ -36,3 +41,5 @@\n-void G1EvacuationFailureObjsInHR::visit(Elem elem) {\n-  uint32_t offset = elem;\n-  _offset_array[_objs_num++] = offset;\n+void G1EvacuationFailureObjsInHR::visit_buffer(G1SegmentedArrayBuffer<mtGC>* node, uint limit) {\n+  node->copy_to(&_offset_array[_objs_num]);\n+  _objs_num += limit;\n+  \/\/ Verify elements in the buffer\n+  DEBUG_ONLY(node->iterate_elems(*this));\n@@ -41,3 +48,3 @@\n-void G1EvacuationFailureObjsInHR::visit(Array<NODE_LENGTH, Elem>::NODE_XXX* node, uint32_t limit) {\n-  ::memcpy(&_offset_array[_objs_num], node->_oop_offsets, limit * sizeof(Elem));\n-  _objs_num += limit;\n+void G1EvacuationFailureObjsInHR::visit_elem(void* elem) {\n+  uint* ptr = (uint*)elem;\n+  assert(*ptr < _max_offset, \"must be, %u\", *ptr);\n@@ -48,6 +55,6 @@\n-  _offset_array = NEW_C_HEAP_ARRAY(Elem, _nodes_array.objs_num(), mtGC);\n-  \/\/ _nodes_array.iterate_elements(this);\n-  _nodes_array.iterate_nodes(this);\n-  uint expected = _nodes_array.objs_num();\n-  assert(_objs_num == expected, \"must be %u, %u\", _objs_num, expected);\n-  _nodes_array.reset();\n+  uint num = _nodes_array.num_allocated_nodes();\n+  _offset_array = NEW_C_HEAP_ARRAY(Elem, num, mtGC);\n+  \/\/ Copy buffers' data to local array\n+  _nodes_array.iterate_nodes(*this);\n+  assert(_objs_num == num, \"must be %u, %u\", _objs_num, num);\n+  _nodes_array.drop_all();\n@@ -86,1 +93,1 @@\n-  _nodes_array(static_cast<uint32_t>(HeapRegion::GrainWords) \/ NODE_LENGTH + 2u),\n+  _nodes_array(\"\", &_alloc_options, &_free_buffer_list),\n@@ -102,1 +109,2 @@\n-  _nodes_array.add(offset);\n+  Elem* e = _nodes_array.allocate();\n+  *e = offset;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1EvacuationFailureObjsInHR.cpp","additions":24,"deletions":16,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"gc\/g1\/g1SegmentedArray.hpp\"\n@@ -36,180 +37,0 @@\n-  template<uint32_t LEN, typename Elem>\n-  class Array;\n-\n-\n-  \/\/ === Node ===\n-\n-  template<uint32_t LEN, typename Elem>\n-  class Node : public CHeapObj<mtGC>{\n-    friend G1EvacuationFailureObjsInHR;\n-    friend Array<LEN, Elem>;\n-\n-  private:\n-    static const uint32_t LENGTH = LEN;\n-    static const size_t SIZE = LENGTH * sizeof(Elem);\n-    Elem* _oop_offsets;\n-\n-  public:\n-    Node() {\n-      _oop_offsets = (Elem*)AllocateHeap(SIZE, mtGC);\n-    }\n-    Elem& operator[] (size_t idx) {\n-      return _oop_offsets[idx];\n-    }\n-    static Node<LEN, Elem>* create_node() {\n-      return new Node<LEN, Elem>();\n-    }\n-    static void free_node(Node<LEN, Elem>* node) {\n-      assert(node != NULL, \"must be\");\n-      FreeHeap(node->_oop_offsets);\n-      delete node;\n-    }\n-  };\n-\n-\n-  \/\/ === Array ===\n-\n-  template<uint32_t NODE_SIZE, typename Elem>\n-  class Array : public CHeapObj<mtGC> {\n-  public:\n-    typedef Node<NODE_SIZE, Elem> NODE_XXX;\n-\n-  private:\n-    const uint64_t low_mask;\n-    const uint64_t high_mask;\n-    const uint32_t _max_nodes_length;\n-\n-    volatile uint64_t _cur_pos;\n-    NODE_XXX* volatile * _nodes;\n-    volatile uint _elements_num;\n-\n-  private:\n-    uint64_t low(uint64_t n) {\n-      return (n & low_mask);\n-    }\n-    uint64_t high(uint64_t n) {\n-      return (n & high_mask);\n-    }\n-    uint32_t elem_index(uint64_t n) {\n-      assert(low(n) < NODE_XXX::LENGTH, \"must be\");\n-      return low(n);\n-    }\n-    uint32_t node_index(uint64_t n) {\n-      uint32_t hi = high(n) >> 32;\n-      assert(hi < _max_nodes_length, \"must be\");\n-      return hi;\n-    }\n-\n-    uint64_t next(uint64_t n) {\n-      uint64_t lo = low(n);\n-      uint64_t hi = high(n);\n-      assert((lo < NODE_XXX::LENGTH) && (NODE_XXX::LENGTH <= low_mask), \"must be\");\n-      assert(hi < high_mask, \"must be\");\n-      if ((lo+1) == NODE_XXX::LENGTH) {\n-        lo = 0;\n-        hi += ((uint64_t)1 << 32);\n-      } else {\n-        lo++;\n-      }\n-      assert(hi <= high_mask, \"must be\");\n-      return hi | lo;\n-    }\n-\n-  public:\n-    Array(uint32_t max_nodes_length) :\n-      low_mask(((uint64_t)1 << 32) - 1),\n-      high_mask(low_mask << 32),\n-      _max_nodes_length(max_nodes_length) {\n-\n-      _nodes = (NODE_XXX**)AllocateHeap(_max_nodes_length * sizeof(NODE_XXX*), mtGC);\n-      for (uint32_t i = 0; i < _max_nodes_length; i++) {\n-        Atomic::store(&_nodes[i], (NODE_XXX *)NULL);\n-      }\n-\n-      Atomic::store(&_elements_num, 0u);\n-      Atomic::store(&_cur_pos, (uint64_t)0);\n-    }\n-\n-    ~Array() {\n-      assert(_nodes != NULL, \"must be\");\n-      reset();\n-      FreeHeap((NODE_XXX**)_nodes);\n-    }\n-\n-    uint objs_num() {\n-      return Atomic::load(&_elements_num);\n-    }\n-\n-    void add(Elem elem) {\n-      while (true) {\n-        uint64_t pos = Atomic::load(&_cur_pos);\n-        uint64_t next_pos = next(pos);\n-        uint64_t res = Atomic::cmpxchg(&_cur_pos, pos, next_pos);\n-        if (res == pos) {\n-          uint32_t hi = node_index(pos);\n-          uint32_t lo = elem_index(pos);\n-          if (lo == 0) {\n-            Atomic::store(&_nodes[hi], NODE_XXX::create_node());\n-          }\n-          NODE_XXX* node = NULL;\n-          while ((node = Atomic::load(&_nodes[hi])) == NULL);\n-\n-          node->operator[](lo) = elem;\n-          Atomic::inc(&_elements_num);\n-          break;\n-        }\n-      }\n-    }\n-\n-    template<typename VISITOR>\n-    void iterate_elements(VISITOR v) {\n-      int64_t pos = Atomic::load(&_cur_pos);\n-      DEBUG_ONLY(uint total = 0);\n-      uint32_t hi = node_index(pos);\n-      uint32_t lo = elem_index(pos);\n-      for (uint32_t i = 0; i <= hi; i++) {\n-        uint32_t limit = (i == hi) ? lo : NODE_XXX::LENGTH;\n-        NODE_XXX* node = Atomic::load(&_nodes[i]);\n-        for (uint32_t j = 0; j < limit; j++) {\n-          v->visit(node->operator[](j));\n-          DEBUG_ONLY(total++);\n-        }\n-      }\n-      assert(total == Atomic::load(&_elements_num), \"must be\");\n-    }\n-\n-    template<typename VISITOR>\n-    void iterate_nodes(VISITOR v) {\n-      int64_t pos = Atomic::load(&_cur_pos);\n-      uint32_t hi = node_index(pos);\n-      uint32_t lo = elem_index(pos);\n-      for (uint32_t i = 0; i <= hi; i++) {\n-        NODE_XXX* node = Atomic::load(&_nodes[i]);\n-        uint32_t limit = (i == hi) ? lo : NODE_XXX::LENGTH;\n-        if (limit == 0) {\n-          break;\n-        }\n-        v->visit(node, limit);\n-      }\n-    }\n-\n-    void reset() {\n-      int64_t pos = Atomic::load(&_cur_pos);\n-      uint32_t hi = node_index(pos);\n-      uint32_t lo = elem_index(pos);\n-      for (uint32_t i = 0; i <= hi; i++) {\n-        NODE_XXX* node = Atomic::load(&_nodes[i]);\n-        assert(node != NULL || ((i == hi) && (lo == 0)), \"must be\");\n-        if (node == NULL) {\n-          break;\n-        }\n-        NODE_XXX::free_node(node);\n-        Atomic::store(&_nodes[i], (NODE_XXX *)NULL);\n-      }\n-      Atomic::store(&_elements_num, 0u);\n-      Atomic::store(&_cur_pos, (uint64_t)0);\n-    }\n-  };\n-\n-\n-  \/\/ === G1EvacuationFailureObjsInHR ===\n@@ -218,1 +39,1 @@\n-  typedef uint32_t Elem;\n+  typedef uint Elem;\n@@ -221,1 +42,8 @@\n-  static const uint32_t NODE_LENGTH = 256;\n+  static const uint BufferLength = 256;\n+  static const uint MaxBufferLength;\n+  static const uint Alignment = 4;\n+\n+  static const G1SegmentedArrayAllocOptions _alloc_options;\n+  \/\/ This free list is shared among evacuation failure process in all regions.\n+  static G1SegmentedArrayBufferList<mtGC> _free_buffer_list;\n+\n@@ -225,1 +53,4 @@\n-  Array<NODE_LENGTH, Elem> _nodes_array;\n+\n+  \/\/ To improve space efficiency, elements are offset rather than raw addr\n+  G1SegmentedArray<Elem, mtGC> _nodes_array;\n+  \/\/ Local array contains the _nodes_array data in flat layout\n@@ -238,2 +69,2 @@\n-  void visit(Elem);\n-  void visit(Array<NODE_LENGTH, Elem>::NODE_XXX* node, uint32_t limit);\n+\n+  \/\/ Copy buffers' data to local array\n@@ -243,0 +74,1 @@\n+  \/\/ Iterate through evac failure objects in local array\n@@ -249,0 +81,1 @@\n+  \/\/ Record an evac failure object\n@@ -250,0 +83,1 @@\n+  \/\/ Iterate through evac failure objects\n@@ -251,0 +85,7 @@\n+\n+  \/\/\n+  \/\/ Copy a buffer data to local array\n+  void visit_buffer(G1SegmentedArrayBuffer<mtGC>* node, uint limit);\n+\n+  \/\/ Verify elements in the buffer\n+  void visit_elem(void* elem);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1EvacuationFailureObjsInHR.hpp","additions":26,"deletions":185,"binary":false,"changes":211,"status":"modified"},{"patch":"@@ -76,0 +76,13 @@\n+  uint length() const {\n+    \/\/ _next_allocate might grow greater than _num_elems in multi-thread env,\n+    \/\/ so, here we need to return the adjusted real length value.\n+    return _next_allocate > _num_elems ? _num_elems : _next_allocate;\n+  }\n+\n+  void copy_to(void* dest) const {\n+    ::memcpy(dest, _buffer, length() * _elem_size);\n+  }\n+\n+  template<typename Visitor>\n+  void iterate_elems(Visitor& v) const;\n+\n@@ -193,0 +206,2 @@\n+  DEBUG_ONLY(uint length() const;)\n+\n@@ -197,1 +212,5 @@\n-  uint num_allocated_nodes() const { return Atomic::load(&_num_allocated_nodes); }\n+  uint num_allocated_nodes() const {\n+    uint allocated = Atomic::load(&_num_allocated_nodes);\n+    assert(length() == allocated, \"Must be\");\n+    return allocated;\n+  }\n@@ -215,0 +234,3 @@\n+\n+  template<typename Visitor>\n+  void iterate_nodes(Visitor& v) const;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1SegmentedArray.hpp","additions":23,"deletions":1,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -58,0 +58,9 @@\n+template<MEMFLAGS flag>\n+template<typename Visitor>\n+void G1SegmentedArrayBuffer<flag>::iterate_elems(Visitor& v) const {\n+  for (uint i = 0; i < length(); i++) {\n+    void* ptr = _buffer + i * _elem_size;\n+    v.visit_elem(ptr);\n+  }\n+}\n+\n@@ -236,0 +245,39 @@\n+#ifdef ASSERT\n+template <MEMFLAGS flag>\n+class LengthVisitor {\n+  uint _total;\n+public:\n+  LengthVisitor() : _total(0) {}\n+  void visit_buffer(G1SegmentedArrayBuffer<flag>* node, uint limit) {\n+    _total += limit;\n+  }\n+  uint length() const {\n+    return _total;\n+  }\n+};\n+\n+template <class Elem, MEMFLAGS flag>\n+uint G1SegmentedArray<Elem, flag>::length() const {\n+  LengthVisitor<flag> v;\n+  iterate_nodes(v);\n+  return v.length();\n+}\n+#endif\n+\n+template <class Elem, MEMFLAGS flag>\n+template <typename Visitor>\n+void G1SegmentedArray<Elem, flag>::iterate_nodes(Visitor& v) const {\n+  G1SegmentedArrayBuffer<flag>* cur = Atomic::load_acquire(&_first);\n+\n+  if (cur != nullptr) {\n+    assert(_last != nullptr, \"If there is at least one element, there must be a last one.\");\n+\n+    while (cur != nullptr) {\n+      uint limit = cur->length();\n+      v.visit_buffer(cur, limit);\n+\n+      cur = cur->next();\n+    }\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1SegmentedArray.inline.hpp","additions":48,"deletions":0,"binary":false,"changes":48,"status":"modified"}]}