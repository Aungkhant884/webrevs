{"files":[{"patch":"@@ -54,1 +54,1 @@\n-    return thread->as_Java_thread()->thread_state() == _thread_in_vm;\n+    return JavaThread::cast(thread)->thread_state() == _thread_in_vm;\n","filename":"src\/hotspot\/share\/code\/dependencies.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -65,0 +65,1 @@\n+#include \"runtime\/vframe.inline.hpp\"\n@@ -151,1 +152,1 @@\n-  return thread->as_Java_thread();\n+  return JavaThread::cast(thread);\n@@ -1146,1 +1147,4 @@\n-bool matches(jobjectArray methods, Method* method, JVMCIEnv* JVMCIENV) {\n+\/*\n+ * Used by matches() to convert a ResolvedJavaMethod[] to an array of Method*.\n+ *\/\n+GrowableArray<Method*>* init_resolved_methods(jobjectArray methods, JVMCIEnv* JVMCIENV) {\n@@ -1148,1 +1152,1 @@\n-\n+  GrowableArray<Method*>* resolved_methods = new GrowableArray<Method*>(methods_oop->length());\n@@ -1151,1 +1155,26 @@\n-    if ((resolved->klass() == HotSpotJVMCI::HotSpotResolvedJavaMethodImpl::klass()) && HotSpotJVMCI::asMethod(JVMCIENV, resolved) == method) {\n+    Method* resolved_method = NULL;\n+    if (resolved->klass() == HotSpotJVMCI::HotSpotResolvedJavaMethodImpl::klass()) {\n+      resolved_method = HotSpotJVMCI::asMethod(JVMCIENV, resolved);\n+    }\n+    resolved_methods->append(resolved_method);\n+  }\n+  return resolved_methods;\n+}\n+\n+\/*\n+ * Used by c2v_iterateFrames to check if `method` matches one of the ResolvedJavaMethods in the `methods` array.\n+ * The ResolvedJavaMethod[] array is converted to a Method* array that is then cached in the resolved_methods_ref in\/out parameter.\n+ * In case of a match, the matching ResolvedJavaMethod is returned in matched_jvmci_method_ref.\n+ *\/\n+bool matches(jobjectArray methods, Method* method, GrowableArray<Method*>** resolved_methods_ref, Handle* matched_jvmci_method_ref, Thread* THREAD, JVMCIEnv* JVMCIENV) {\n+  GrowableArray<Method*>* resolved_methods = *resolved_methods_ref;\n+  if (resolved_methods == NULL) {\n+    resolved_methods = init_resolved_methods(methods, JVMCIENV);\n+    *resolved_methods_ref = resolved_methods;\n+  }\n+  assert(method != NULL, \"method should not be NULL\");\n+  assert(resolved_methods->length() == ((objArrayOop) JNIHandles::resolve(methods))->length(), \"arrays must have the same length\");\n+  for (int i = 0; i < resolved_methods->length(); i++) {\n+    Method* m = resolved_methods->at(i);\n+    if (m == method) {\n+      *matched_jvmci_method_ref = Handle(THREAD, ((objArrayOop) JNIHandles::resolve(methods))->obj_at(i));\n@@ -1158,1 +1187,4 @@\n-void call_interface(JavaValue* result, Klass* spec_klass, Symbol* name, Symbol* signature, JavaCallArguments* args, TRAPS) {\n+\/*\n+ * Resolves an interface call to a concrete method handle.\n+ *\/\n+methodHandle resolve_interface_call(Klass* spec_klass, Symbol* name, Symbol* signature, JavaCallArguments* args, TRAPS) {\n@@ -1164,1 +1196,1 @@\n-          callinfo, receiver, recvrKlass, link_info, true, CHECK);\n+          callinfo, receiver, recvrKlass, link_info, true, CHECK_(methodHandle()));\n@@ -1167,0 +1199,25 @@\n+  return method;\n+}\n+\n+\/*\n+ * Used by c2v_iterateFrames to make a new vframeStream at the given compiled frame id (stack pointer) and vframe id.\n+ *\/\n+void resync_vframestream_to_compiled_frame(vframeStream& vfst, intptr_t* stack_pointer, int vframe_id, JavaThread* thread, TRAPS) {\n+  vfst = vframeStream(thread);\n+  while (vfst.frame_id() != stack_pointer && !vfst.at_end()) {\n+    vfst.next();\n+  }\n+  if (vfst.frame_id() != stack_pointer) {\n+    THROW_MSG(vmSymbols::java_lang_IllegalStateException(), \"stack frame not found after deopt\")\n+  }\n+  if (vfst.is_interpreted_frame()) {\n+    THROW_MSG(vmSymbols::java_lang_IllegalStateException(), \"compiled stack frame expected\")\n+  }\n+  while (vfst.vframe_id() != vframe_id) {\n+    if (vfst.at_end()) {\n+      THROW_MSG(vmSymbols::java_lang_IllegalStateException(), \"vframe not found after deopt\")\n+    }\n+    vfst.next();\n+    assert(!vfst.is_interpreted_frame(), \"Wrong frame type\");\n+  }\n+}\n@@ -1168,2 +1225,15 @@\n-  \/\/ Invoke the method\n-  JavaCalls::call(result, method, args, CHECK);\n+\/*\n+ * Used by c2v_iterateFrames. Returns an array of any unallocated scope objects or NULL if none.\n+ *\/\n+GrowableArray<ScopeValue*>* get_unallocated_objects_or_null(GrowableArray<ScopeValue*>* scope_objects) {\n+  GrowableArray<ScopeValue*>* unallocated = NULL;\n+  for (int i = 0; i < scope_objects->length(); i++) {\n+    ObjectValue* sv = (ObjectValue*) scope_objects->at(i);\n+    if (sv->value().is_null()) {\n+      if (unallocated == NULL) {\n+        unallocated = new GrowableArray<ScopeValue*>(scope_objects->length());\n+      }\n+      unallocated->append(sv);\n+    }\n+  }\n+  return unallocated;\n@@ -1182,2 +1252,1 @@\n-  Handle frame_reference = HotSpotJVMCI::HotSpotStackFrameReference::klass()->allocate_instance_handle(CHECK_NULL);\n-  StackFrameStream fst(thread, true \/* update *\/, true \/* process_frames *\/);\n+  vframeStream vfst(thread);\n@@ -1186,0 +1255,2 @@\n+  methodHandle visitor_method;\n+  GrowableArray<Method*>* resolved_methods = NULL;\n@@ -1187,5 +1258,1 @@\n-  int frame_number = 0;\n-  vframe* vf = vframe::new_vframe(fst, thread);\n-\n-  while (true) {\n-    \/\/ look for the given method\n+  while (!vfst.at_end()) { \/\/ frame loop\n@@ -1193,27 +1260,47 @@\n-    while (true) {\n-      StackValueCollection* locals = NULL;\n-      if (vf->is_compiled_frame()) {\n-        \/\/ compiled method frame\n-        compiledVFrame* cvf = compiledVFrame::cast(vf);\n-        if (methods == NULL || matches(methods, cvf->method(), JVMCIENV)) {\n-          if (initialSkip > 0) {\n-            initialSkip--;\n-          } else {\n-            ScopeDesc* scope = cvf->scope();\n-            \/\/ native wrappers do not have a scope\n-            if (scope != NULL && scope->objects() != NULL) {\n-              GrowableArray<ScopeValue*>* objects;\n-              if (!realloc_called) {\n-                objects = scope->objects();\n-              } else {\n-                \/\/ some object might already have been re-allocated, only reallocate the non-allocated ones\n-                objects = new GrowableArray<ScopeValue*>(scope->objects()->length());\n-                for (int i = 0; i < scope->objects()->length(); i++) {\n-                  ObjectValue* sv = (ObjectValue*) scope->objects()->at(i);\n-                  if (sv->value().is_null()) {\n-                    objects->append(sv);\n-                  }\n-                }\n-              }\n-              bool realloc_failures = Deoptimization::realloc_objects(thread, fst.current(), fst.register_map(), objects, CHECK_NULL);\n-              Deoptimization::reassign_fields(fst.current(), fst.register_map(), objects, realloc_failures, false);\n+    intptr_t* frame_id = vfst.frame_id();\n+\n+    \/\/ Previous compiledVFrame of this frame; use with at_scope() to reuse scope object pool.\n+    compiledVFrame* prev_cvf = NULL;\n+\n+    for (; !vfst.at_end() && vfst.frame_id() == frame_id; vfst.next()) { \/\/ vframe loop\n+      int frame_number = 0;\n+      Method *method = vfst.method();\n+      int bci = vfst.bci();\n+\n+      Handle matched_jvmci_method;\n+      if (methods == NULL || matches(methods, method, &resolved_methods, &matched_jvmci_method, THREAD, JVMCIENV)) {\n+        if (initialSkip > 0) {\n+          initialSkip--;\n+          continue;\n+        }\n+        javaVFrame* vf;\n+        if (prev_cvf != NULL && prev_cvf->frame_pointer()->id() == frame_id) {\n+          assert(prev_cvf->is_compiled_frame(), \"expected compiled Java frame\");\n+          vf = prev_cvf->at_scope(vfst.decode_offset(), vfst.vframe_id());\n+        } else {\n+          vf = vfst.asJavaVFrame();\n+        }\n+\n+        StackValueCollection* locals = NULL;\n+        typeArrayHandle localIsVirtual_h;\n+        if (vf->is_compiled_frame()) {\n+          \/\/ compiled method frame\n+          compiledVFrame* cvf = compiledVFrame::cast(vf);\n+\n+          ScopeDesc* scope = cvf->scope();\n+          \/\/ native wrappers do not have a scope\n+          if (scope != NULL && scope->objects() != NULL) {\n+            prev_cvf = cvf;\n+\n+            GrowableArray<ScopeValue*>* objects = NULL;\n+            if (!realloc_called) {\n+              objects = scope->objects();\n+            } else {\n+              \/\/ some object might already have been re-allocated, only reallocate the non-allocated ones\n+              objects = get_unallocated_objects_or_null(scope->objects());\n+            }\n+\n+            if (objects != NULL) {\n+              RegisterMap reg_map(vf->register_map());\n+              bool realloc_failures = Deoptimization::realloc_objects(thread, vf->frame_pointer(), &reg_map, objects, CHECK_NULL);\n+              Deoptimization::reassign_fields(vf->frame_pointer(), &reg_map, objects, realloc_failures, false);\n@@ -1221,0 +1308,1 @@\n+            }\n@@ -1222,8 +1310,7 @@\n-              GrowableArray<ScopeValue*>* local_values = scope->locals();\n-              assert(local_values != NULL, \"NULL locals\");\n-              typeArrayOop array_oop = oopFactory::new_boolArray(local_values->length(), CHECK_NULL);\n-              typeArrayHandle array(THREAD, array_oop);\n-              for (int i = 0; i < local_values->length(); i++) {\n-                ScopeValue* value = local_values->at(i);\n-                if (value->is_object()) {\n-                  array->bool_at_put(i, true);\n+            GrowableArray<ScopeValue*>* local_values = scope->locals();\n+            for (int i = 0; i < local_values->length(); i++) {\n+              ScopeValue* value = local_values->at(i);\n+              if (value->is_object()) {\n+                if (localIsVirtual_h.is_null()) {\n+                  typeArrayOop array_oop = oopFactory::new_boolArray(local_values->length(), CHECK_NULL);\n+                  localIsVirtual_h = typeArrayHandle(THREAD, array_oop);\n@@ -1231,0 +1318,1 @@\n+                localIsVirtual_h->bool_at_put(i, true);\n@@ -1232,9 +1320,8 @@\n-              HotSpotJVMCI::HotSpotStackFrameReference::set_localIsVirtual(JVMCIENV, frame_reference(), array());\n-            } else {\n-              HotSpotJVMCI::HotSpotStackFrameReference::set_localIsVirtual(JVMCIENV, frame_reference(), NULL);\n-\n-            locals = cvf->locals();\n-            HotSpotJVMCI::HotSpotStackFrameReference::set_bci(JVMCIENV, frame_reference(), cvf->bci());\n-            methodHandle mh(THREAD, cvf->method());\n-            JVMCIObject method = JVMCIENV->get_jvmci_method(mh, JVMCI_CHECK_NULL);\n-            HotSpotJVMCI::HotSpotStackFrameReference::set_method(JVMCIENV, frame_reference(), JNIHandles::resolve(method.as_jobject()));\n+\n+          locals = cvf->locals();\n+          frame_number = cvf->vframe_id();\n+        } else {\n+          \/\/ interpreted method frame\n+          interpretedVFrame* ivf = interpretedVFrame::cast(vf);\n+\n+          locals = ivf->locals();\n@@ -1244,14 +1331,9 @@\n-      } else if (vf->is_interpreted_frame()) {\n-        \/\/ interpreted method frame\n-        interpretedVFrame* ivf = interpretedVFrame::cast(vf);\n-        if (methods == NULL || matches(methods, ivf->method(), JVMCIENV)) {\n-          if (initialSkip > 0) {\n-            initialSkip--;\n-          } else {\n-            locals = ivf->locals();\n-            HotSpotJVMCI::HotSpotStackFrameReference::set_bci(JVMCIENV, frame_reference(), ivf->bci());\n-            methodHandle mh(THREAD, ivf->method());\n-            JVMCIObject method = JVMCIENV->get_jvmci_method(mh, JVMCI_CHECK_NULL);\n-            HotSpotJVMCI::HotSpotStackFrameReference::set_method(JVMCIENV, frame_reference(), JNIHandles::resolve(method.as_jobject()));\n-            HotSpotJVMCI::HotSpotStackFrameReference::set_localIsVirtual(JVMCIENV, frame_reference(), NULL);\n-          }\n+        assert(bci == vf->bci(), \"wrong bci\");\n+        assert(method == vf->method(), \"wrong method\");\n+\n+        Handle frame_reference = HotSpotJVMCI::HotSpotStackFrameReference::klass()->allocate_instance_handle(CHECK_NULL);\n+        HotSpotJVMCI::HotSpotStackFrameReference::set_bci(JVMCIENV, frame_reference(), bci);\n+        if (matched_jvmci_method.is_null()) {\n+          methodHandle mh(THREAD, method);\n+          JVMCIObject jvmci_method = JVMCIENV->get_jvmci_method(mh, JVMCI_CHECK_NULL);\n+          matched_jvmci_method = Handle(THREAD, JNIHandles::resolve(jvmci_method.as_jobject()));\n@@ -1259,1 +1341,2 @@\n-      }\n+        HotSpotJVMCI::HotSpotStackFrameReference::set_method(JVMCIENV, frame_reference(), matched_jvmci_method());\n+        HotSpotJVMCI::HotSpotStackFrameReference::set_localIsVirtual(JVMCIENV, frame_reference(), localIsVirtual_h());\n@@ -1261,4 +1344,1 @@\n-      \/\/ locals != NULL means that we found a matching frame and result is already partially initialized\n-      if (locals != NULL) {\n-        methods = match_methods;\n-        HotSpotJVMCI::HotSpotStackFrameReference::set_stackPointer(JVMCIENV, frame_reference(), (jlong) fst.current()->sp());\n+        HotSpotJVMCI::HotSpotStackFrameReference::set_stackPointer(JVMCIENV, frame_reference(), (jlong) frame_id);\n@@ -1282,0 +1362,4 @@\n+        if (visitor_method.is_null()) {\n+          visitor_method = resolve_interface_call(HotSpotJVMCI::InspectedFrameVisitor::klass(), vmSymbols::visitFrame_name(), vmSymbols::visitFrame_signature(), &args, CHECK_NULL);\n+        }\n+\n@@ -1283,1 +1367,1 @@\n-        call_interface(&result, HotSpotJVMCI::InspectedFrameVisitor::klass(), vmSymbols::visitFrame_name(), vmSymbols::visitFrame_signature(), &args, CHECK_NULL);\n+        JavaCalls::call(&result, visitor_method, &args, CHECK_NULL);\n@@ -1287,0 +1371,6 @@\n+        if (methods == initial_methods) {\n+          methods = match_methods;\n+          if (resolved_methods != NULL && JNIHandles::resolve(match_methods) != JNIHandles::resolve(initial_methods)) {\n+            resolved_methods = NULL;\n+          }\n+        }\n@@ -1290,0 +1380,1 @@\n+          prev_cvf = NULL;\n@@ -1291,18 +1382,1 @@\n-          fst = StackFrameStream(thread, true \/* update *\/, true \/* process_frames *\/);\n-          while (fst.current()->sp() != stack_pointer && !fst.is_done()) {\n-            fst.next();\n-          }\n-          if (fst.current()->sp() != stack_pointer) {\n-            THROW_MSG_NULL(vmSymbols::java_lang_IllegalStateException(), \"stack frame not found after deopt\")\n-          }\n-          vf = vframe::new_vframe(fst, thread);\n-          if (!vf->is_compiled_frame()) {\n-            THROW_MSG_NULL(vmSymbols::java_lang_IllegalStateException(), \"compiled stack frame expected\")\n-          }\n-          for (int i = 0; i < frame_number; i++) {\n-            if (vf->is_top()) {\n-              THROW_MSG_NULL(vmSymbols::java_lang_IllegalStateException(), \"vframe not found after deopt\")\n-            }\n-            vf = vf->sender();\n-            assert(vf->is_compiled_frame(), \"Wrong frame type\");\n-          }\n+          resync_vframestream_to_compiled_frame(vfst, stack_pointer, frame_number, thread, CHECK_NULL);\n@@ -1310,15 +1384,0 @@\n-        frame_reference = HotSpotJVMCI::HotSpotStackFrameReference::klass()->allocate_instance_handle(CHECK_NULL);\n-        HotSpotJVMCI::HotSpotStackFrameReference::klass()->initialize(CHECK_NULL);\n-      }\n-\n-      if (vf->is_top()) {\n-        break;\n-      frame_number++;\n-      vf = vf->sender();\n-\n-    if (fst.is_done()) {\n-      break;\n-    }\n-    fst.next();\n-    vf = vframe::new_vframe(fst, thread);\n-    frame_number = 0;\n@@ -1425,1 +1484,1 @@\n-  while (fst.current()->sp() != stack_pointer && !fst.is_done()) {\n+  while (fst.current()->id() != stack_pointer && !fst.is_done()) {\n@@ -1428,1 +1487,1 @@\n-  if (fst.current()->sp() != stack_pointer) {\n+  if (fst.current()->id() != stack_pointer) {\n@@ -1442,1 +1501,1 @@\n-  while (fstAfterDeopt.current()->sp() != stack_pointer && !fstAfterDeopt.is_done()) {\n+  while (fstAfterDeopt.current()->id() != stack_pointer && !fstAfterDeopt.is_done()) {\n@@ -1445,1 +1504,1 @@\n-  if (fstAfterDeopt.current()->sp() != stack_pointer) {\n+  if (fstAfterDeopt.current()->id() != stack_pointer) {\n@@ -2278,1 +2337,1 @@\n-    attach_args.name = thread->name();\n+    attach_args.name = const_cast<char*>(thread->name());\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":176,"deletions":117,"binary":false,"changes":293,"status":"modified"},{"patch":"@@ -225,1 +225,1 @@\n-        if (checkClassVersion && readShort(classFileOffset + 6) > Opcodes.V17) {\n+        if (checkClassVersion && readShort(classFileOffset + 6) > Opcodes.V18) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/ClassReader.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -557,0 +557,1 @@\n+java\/lang\/invoke\/RicochetTest.java                              8251969 generic-all\n@@ -748,1 +749,0 @@\n-javax\/swing\/JFileChooser\/FileSystemView\/SystemIconTest.java 8268280 windows-x64\n@@ -829,1 +829,1 @@\n-jdk\/jfr\/event\/gc\/detailed\/TestEvacuationFailedEvent.java        8263461 linux-x64\n+jdk\/jfr\/event\/oldobject\/TestObjectSize.java                     8269418 macosx-x64\n","filename":"test\/jdk\/ProblemList.txt","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}