{"files":[{"patch":"@@ -1240,0 +1240,1 @@\n+ public:\n@@ -1242,1 +1243,0 @@\n- public:\n@@ -1755,0 +1755,34 @@\n+\/\/ Try to determine whether root method in some context is concrete or not based on the information about the unique method\n+\/\/ in that context. It exploits the fact that concrete root method is always inherited into the context when there's a unique method.\n+\/\/ Hence, unique method holder is always a supertype of the context class when root method is concrete.\n+\/\/ Examples for concrete_root_method\n+\/\/      C (C.m uniqm)\n+\/\/      |\n+\/\/      CX (ctxk) uniqm is inherited into context.\n+\/\/\n+\/\/      CX (ctxk) (CX.m uniqm) here uniqm is defined in ctxk.\n+\/\/ Examples for !concrete_root_method\n+\/\/      CX (ctxk)\n+\/\/      |\n+\/\/      C (C.m uniqm) uniqm is in subtype of ctxk.\n+bool Dependencies::is_concrete_root_method(Method* uniqm, InstanceKlass* ctxk) {\n+  if (uniqm == NULL) {\n+    return false; \/\/ match Dependencies::is_concrete_method() behavior\n+  }\n+  \/\/ Theoretically, the \"direction\" of subtype check matters here.\n+  \/\/ On one hand, in case of interface context with a single implementor, uniqm can be in a superclass of the implementor which\n+  \/\/ is not related to context class.\n+  \/\/ On another hand, uniqm could come from an interface unrelated to the context class, but right now it is not possible:\n+  \/\/ it is required that uniqm->method_holder() is the participant (uniqm->method_holder() <: ctxk), hence a default method\n+  \/\/ can't be used as unique.\n+  if (ctxk->is_interface()) {\n+    InstanceKlass* implementor = ctxk->implementor();\n+    assert(implementor != ctxk, \"single implementor only\"); \/\/ should have been invalidated earlier\n+    ctxk = implementor;\n+  }\n+  InstanceKlass* holder = uniqm->method_holder();\n+  assert(!holder->is_interface(), \"no default methods allowed\");\n+  assert(ctxk->is_subclass_of(holder) || holder->is_subclass_of(ctxk), \"not related\");\n+  return ctxk->is_subclass_of(holder);\n+}\n+\n@@ -1760,4 +1794,0 @@\n-  \/\/ Here is a missing optimization:  If uniqm->is_final(),\n-  \/\/ we don't really need to search beneath it for overrides.\n-  \/\/ This is probably not important, since we don't use dependencies\n-  \/\/ to track final methods.  (They can't be \"definalized\".)\n@@ -1766,1 +1796,11 @@\n-  return k;\n+  if (k != NULL) {\n+    return k;\n+  }\n+  if (!Dependencies::is_concrete_root_method(uniqm, ctxk) || changes != NULL) {\n+    Klass* conck = find_witness_AME(ctxk, uniqm, changes);\n+    if (conck != NULL) {\n+      \/\/ Found a concrete subtype 'conck' which does not override abstract root method.\n+      return conck;\n+    }\n+  }\n+  return NULL;\n@@ -1769,0 +1809,30 @@\n+\/\/ Search for AME.\n+\/\/ There are two version of checks.\n+\/\/   1) Spot checking version(Classload time). Newly added class is checked for AME.\n+\/\/      Checks whether abstract\/overpass method is inherited into\/declared in newly added concrete class.\n+\/\/   2) Compile time analysis for abstract\/overpass(abstract klass) root_m. The non uniqm subtrees are checked for concrete classes.\n+Klass* Dependencies::find_witness_AME(InstanceKlass* ctxk, Method* m, KlassDepChange* changes) {\n+  if (m != NULL) {\n+    if (changes != NULL) {\n+      \/\/ Spot checking version.\n+      ConcreteMethodFinder wf(m);\n+      Klass* new_type = changes->as_new_klass_change()->new_type();\n+      if (wf.witnessed_reabstraction_in_supers(new_type)) {\n+        return new_type;\n+      }\n+    } else {\n+      \/\/ Note: It is required that uniqm->method_holder() is the participant (see ClassHierarchyWalker::found_method()).\n+      ConcreteSubtypeFinder wf(m->method_holder());\n+      Klass* conck = wf.find_witness(ctxk);\n+      if (conck != NULL) {\n+        Method* cm = InstanceKlass::cast(conck)->find_instance_method(m->name(), m->signature(), Klass::PrivateLookupMode::skip);\n+        if (!Dependencies::is_concrete_method(cm, conck)) {\n+          return conck;\n+        }\n+      }\n+    }\n+  }\n+  return NULL;\n+}\n+\n+\n@@ -1790,0 +1860,3 @@\n+  if (!Dependencies::is_concrete_method(fm, NULL)) {\n+    fm = NULL; \/\/ ignore abstract methods\n+  }\n@@ -1799,0 +1872,3 @@\n+  } else if (Dependencies::find_witness_AME(ctxk, fm) != NULL) {\n+    \/\/ Found a concrete subtype which does not override abstract root method.\n+    return NULL;\n@@ -1800,0 +1876,1 @@\n+  assert(Dependencies::is_concrete_root_method(fm, ctxk) == Dependencies::is_concrete_method(m, ctxk), \"mismatch\");\n","filename":"src\/hotspot\/share\/code\/dependencies.cpp","additions":83,"deletions":6,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -461,4 +461,0 @@\n-  if (method->is_abstract()) {\n-    return NULL;\n-  }\n-\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -541,0 +541,3 @@\n+                if (attributeLength > classFileBuffer.length - currentAttributeOffset) {\n+                    throw new IllegalArgumentException();\n+                }\n@@ -1551,0 +1554,3 @@\n+        if (codeLength > classFileBuffer.length - currentOffset) {\n+            throw new IllegalArgumentException();\n+        }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/ClassReader.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -229,1 +229,0 @@\n-java\/awt\/Window\/MultiWindowApp\/MultiWindowAppTest.java 8159904 linux-all\n@@ -246,1 +245,1 @@\n-java\/awt\/image\/multiresolution\/MultiresolutionIconTest.java 8169187 macosx-all,windows-all\n+java\/awt\/image\/multiresolution\/MultiresolutionIconTest.java 8169187,8252812 macosx-all,windows-all,linux-x64\n@@ -532,0 +531,2 @@\n+java\/awt\/Window\/GetScreenLocation\/GetScreenLocationTest.java 8225787 linux-x64\n+\n@@ -748,0 +749,2 @@\n+javax\/swing\/plaf\/basic\/BasicHTML\/4251579\/bug4251579.java 8137101 linux-x64\n+\n","filename":"test\/jdk\/ProblemList.txt","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"}]}