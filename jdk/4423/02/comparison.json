{"files":[{"patch":"@@ -16676,1 +16676,1 @@\n-    \/\/ Count is in 8-bit bytes; non-Compact chars are 16 bits.\n+    \/\/ Count is in 8-bit bytes.\n@@ -16692,1 +16692,1 @@\n-    \/\/ Count is in 8-bit bytes; non-Compact chars are 16 bits.\n+    \/\/ Count is in 8-bit bytes.\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -96,0 +96,2 @@\n+  product(bool, UseSimpleStringEquals, true,                            \\\n+          \"Use simpliest and shortest implementation for string equals\")\\\n","filename":"src\/hotspot\/cpu\/aarch64\/globals_aarch64.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -4758,5 +4758,0 @@\n-\/\/ There are two implementations.  For arrays >= 8 bytes, all\n-\/\/ comparisons (including the final one, which may overlap) are\n-\/\/ performed 8 bytes at a time.  For strings < 8 bytes, we compare a\n-\/\/ halfword, then a short, and then a byte.\n-\n@@ -4766,1 +4761,1 @@\n-  Label SAME, DONE, SHORT, NEXT_WORD;\n+  Label SAME, DONE, SHORT;\n@@ -4769,1 +4764,1 @@\n-  Register cnt2 = tmp2;  \/\/ cnt2 only used in array length compare\n+  int stubBytesThreshold = 64 - wordSize;\n@@ -4787,5 +4782,5 @@\n-  br(Assembler::LT, SHORT);\n-  \/\/ Main 8 byte comparison loop.\n-  bind(NEXT_WORD); {\n-    ldr(tmp1, Address(post(a1, wordSize)));\n-    ldr(tmp2, Address(post(a2, wordSize)));\n+  br(LT, SHORT);\n+\n+  if (!UseSimpleStringEquals) {\n+    Label STUB, B16, B24;\n+\n@@ -4793,13 +4788,61 @@\n-    eor(tmp1, tmp1, tmp2);\n-    cbnz(tmp1, DONE);\n-  } br(GT, NEXT_WORD);\n-  \/\/ Last longword.  In the case where length == 4 we compare the\n-  \/\/ same longword twice, but that's still faster than another\n-  \/\/ conditional branch.\n-  \/\/ cnt1 could be 0, -1, -2, -3, -4 for chars; -4 only happens when\n-  \/\/ length == 4.\n-  ldr(tmp1, Address(a1, cnt1));\n-  ldr(tmp2, Address(a2, cnt1));\n-  eor(tmp2, tmp1, tmp2);\n-  cbnz(tmp2, DONE);\n-  b(SAME);\n+    br(LE, B16);\n+    subs(cnt1, cnt1, wordSize);\n+    br(LE, B24);\n+    subs(cnt1, cnt1, wordSize);\n+    br(GT, STUB);\n+\n+    ldr(rscratch1, Address(post(a1, wordSize)));\n+    ldr(rscratch2, Address(post(a2, wordSize)));\n+    eor(rscratch1, rscratch1, rscratch2);\n+    cbnz(rscratch1, DONE);\n+\n+    bind(B24);\n+    ldr(rscratch1, Address(post(a1, wordSize)));\n+    ldr(rscratch2, Address(post(a2, wordSize)));\n+    eor(rscratch2, rscratch1, rscratch2);\n+    cbnz(rscratch2, DONE);\n+\n+    bind(B16);\n+    ldr(rscratch1, Address(post(a1, wordSize)));\n+    ldr(rscratch2, Address(post(a2, wordSize)));\n+    eor(rscratch1, rscratch1, rscratch2);\n+    cbnz(rscratch1, DONE);\n+\n+    ldr(rscratch1, Address(a1, cnt1));\n+    ldr(rscratch2, Address(a2, cnt1));\n+    eor(rscratch2, rscratch1, rscratch2);\n+    cbnz(rscratch2, DONE);\n+    b(SAME);\n+\n+    bind(STUB);\n+    RuntimeAddress stub = RuntimeAddress(StubRoutines::aarch64::long_string_equals());\n+    assert(stub.target() != NULL, \"string_equals_long stub has not been generated\");\n+    address tpc = trampoline_call(stub);\n+    if (tpc == NULL) {\n+      DEBUG_ONLY(reset_labels(SHORT, SAME, DONE));\n+      postcond(pc() == badAddress);\n+      return;\n+    }\n+    b(DONE);\n+  } else {\n+    Label NEXT_WORD;\n+\n+    \/\/ Main 8 byte comparison loop.\n+    bind(NEXT_WORD); {\n+      ldr(tmp1, Address(post(a1, wordSize)));\n+      ldr(tmp2, Address(post(a2, wordSize)));\n+      subs(cnt1, cnt1, wordSize);\n+      eor(tmp1, tmp1, tmp2);\n+      cbnz(tmp1, DONE);\n+    } br(GT, NEXT_WORD);\n+    \/\/ Last longword.  In the case where length == 4 we compare the\n+    \/\/ same longword twice, but that's still faster than another\n+    \/\/ conditional branch.\n+    \/\/ cnt1 could be 0, -1, -2, -3, -4 for chars; -4 only happens when\n+    \/\/ length == 4.\n+    ldr(tmp1, Address(a1, cnt1));\n+    ldr(tmp2, Address(a2, cnt1));\n+    eor(tmp2, tmp1, tmp2);\n+    cbnz(tmp2, DONE);\n+    b(SAME);\n+  }\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":68,"deletions":25,"binary":false,"changes":93,"status":"modified"},{"patch":"@@ -4635,0 +4635,63 @@\n+  \/\/ a1 = r1 - string1 address\n+  \/\/ a2 = r3 - string2 address\n+  \/\/ result = r0 - return value. Already contains \"false\"\n+  \/\/ cnt1 = r4 - amount of elements left to check\n+  address generate_long_string_equals() {\n+    Register a1 = r1, a2 = r3, result = r0, cnt1 = r4;\n+    Label NOT_EQUAL, EQUAL, LOOP, SMALL_LOOP, POST_LOOP;\n+    int loopThreshold = 4 * wordSize;\n+\n+    assert_different_registers(a1, a2, result, cnt1);\n+\n+    __ align(CodeEntryAlignment);\n+\n+    StubCodeMark mark(this, \"StubRoutines\", \"long_string_equals\");\n+\n+    address entry = __ pc();\n+    __ enter();\n+\n+    \/\/ reset cnt1\n+    __ add(cnt1, cnt1, loopThreshold);\n+\n+    \/\/ Main 32 byte comparison loop.\n+    __ bind(LOOP);\n+      __ ld1(v0, v1, __ T2D, Address(__ post(a1, loopThreshold)));\n+      __ sub(cnt1, cnt1, loopThreshold);\n+      __ ld1(v2, v3, __ T2D, Address(__ post(a2, loopThreshold)));\n+      __ subs(zr, cnt1, loopThreshold);\n+      __ eor(v0, __ T16B, v0, v2);\n+      __ eor(v1, __ T16B, v1, v3);\n+      __ orr(v0, __ T16B, v0, v1);\n+      __ umov(rscratch1, v0, __ D, 0);\n+      __ umov(rscratch2, v0, __ D, 1);\n+      __ orr(rscratch1, rscratch1, rscratch2);\n+      __ cbnz(rscratch1, NOT_EQUAL);\n+      __ br(__ GE, LOOP);\n+\n+    __ cbz(cnt1, EQUAL);\n+    __ subs(cnt1, cnt1, wordSize);\n+    __ br(__ LE, POST_LOOP);\n+\n+    __ bind(SMALL_LOOP);\n+      __ ldr(rscratch1, Address(__ post(a1, wordSize)));\n+      __ ldr(rscratch2, Address(__ post(a2, wordSize)));\n+      __ subs(cnt1, cnt1, wordSize);\n+      __ eor(rscratch1, rscratch1, rscratch2);\n+      __ cbnz(rscratch1, NOT_EQUAL);\n+      __ br(__ GT, SMALL_LOOP);\n+    __ bind(POST_LOOP);\n+      __ ldr(rscratch1, Address(a1, cnt1));\n+      __ ldr(rscratch2, Address(a2, cnt1));\n+      __ eor(rscratch1, rscratch1, rscratch2);\n+      __ cbnz(rscratch1, NOT_EQUAL);\n+\n+    __ bind(EQUAL);\n+      __ mov(result, true);\n+\n+    __ bind(NOT_EQUAL);\n+      __ leave();\n+      __ ret(lr);\n+\n+    return entry;\n+  }\n+\n@@ -7066,0 +7129,5 @@\n+    }\n+\n+    \/\/ string equals stub for long strings.\n+    if (!UseSimpleStringEquals) {\n+      StubRoutines::aarch64::_long_string_equals = generate_long_string_equals();\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":68,"deletions":0,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -51,0 +51,1 @@\n+address StubRoutines::aarch64::_long_string_equals = NULL;\n","filename":"src\/hotspot\/cpu\/aarch64\/stubRoutines_aarch64.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -64,0 +64,1 @@\n+  static address _long_string_equals;\n@@ -144,0 +145,4 @@\n+  static address long_string_equals() {\n+      return _long_string_equals;\n+  }\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/stubRoutines_aarch64.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -159,0 +159,3 @@\n+    if (FLAG_IS_DEFAULT(UseSimpleStringEquals)) {\n+      FLAG_SET_DEFAULT(UseSimpleStringEquals, false);\n+    }\n","filename":"src\/hotspot\/cpu\/aarch64\/vm_version_aarch64.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,2 @@\n+\n+import java.util.*;\n@@ -32,1 +34,3 @@\n-@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@OutputTimeUnit(TimeUnit.MICROSECONDS)\n+@Warmup(iterations=3, time=1)\n+@Measurement(iterations=5, time=1)\n@@ -34,0 +38,1 @@\n+@Fork(value=1)\n@@ -35,0 +40,2 @@\n+    @Param({\"8\", \"11\", \"16\", \"22\", \"32\", \"45\", \"64\", \"91\", \"121\", \"181\", \"256\", \"512\", \"1024\"})\n+    int size;\n@@ -44,3 +51,11 @@\n-    @Benchmark\n-    public boolean different() {\n-        return test.equals(test2);\n+    public String str;\n+    public String strh;\n+    public String strt;\n+    public String strDup;\n+\n+    @Setup()\n+    public void init() {\n+        str = newString(size, 'c', -1, 'a');\n+        strh = newString(size, 'c', size \/ 3, 'a');\n+        strt = newString(size, 'c', size - 1 - size \/ 3, 'a');\n+        strDup = new String (str.toCharArray());\n@@ -49,3 +64,18 @@\n-    @Benchmark\n-    public boolean equal() {\n-        return test.equals(test3);\n+    public String newString(int size, char charToFill, int pos, char charDiff) {\n+        if (size > 0) {\n+            char[] array = new char[size];\n+            Arrays.fill(array, charToFill);\n+            if (pos >= 0) {\n+                array[pos] = charDiff;\n+            }\n+            return new String(array);\n+        }\n+        return \"\";\n+    }\n+\n+    public boolean different() {\n+        boolean result = false;\n+        for (int i = 0; i < 1000; i++) {\n+            result ^= test.equals(test2);\n+        }\n+        return result;\n@@ -54,1 +84,0 @@\n-    @Benchmark\n@@ -56,1 +85,5 @@\n-        return test.equals(test6);\n+        boolean result = false;\n+        for (int i = 0; i < 1000; i++) {\n+            result ^= test.equals(test6);\n+        }\n+        return result;\n@@ -59,1 +92,0 @@\n-    @Benchmark\n@@ -61,1 +93,5 @@\n-        return test4.equals(test7);\n+        boolean result = false;\n+        for (int i = 0; i < 1000; i++) {\n+            result ^= test4.equals(test7);\n+        }\n+        return result;\n@@ -64,1 +100,0 @@\n-    @Benchmark\n@@ -66,1 +101,29 @@\n-        return test.equals(test4);\n+        boolean result = false;\n+        for (int i = 0; i < 1000; i++) {\n+            result ^= test.equals(test4);\n+        }\n+        return result;\n+    }\n+\n+    public boolean equalUTF16() {\n+        boolean result = false;\n+        for (int i = 0; i < 1000; i++) {\n+            result ^= test5.equals(test4);\n+        }\n+        return result;\n+    }\n+\n+    public boolean equalDiffAtHead() {\n+        boolean result = false;\n+        for (int i = 0; i < 1000; i++) {\n+            result ^= str.equals(strh);\n+        }\n+        return result;\n+    }\n+\n+    public boolean equalDiffAtTail() {\n+        boolean result = false;\n+        for (int i = 0; i < 1000; i++) {\n+            result ^= str.equals(strt);\n+        }\n+        return result;\n@@ -70,2 +133,7 @@\n-    public boolean equalsUTF16() {\n-        return test5.equals(test4);\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public boolean equal() {\n+        boolean result = false;\n+        for (int i = 0; i < 1000; i++) {\n+            result ^= str.equals(strDup);\n+        }\n+        return result;\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/StringEquals.java","additions":84,"deletions":16,"binary":false,"changes":100,"status":"modified"}]}