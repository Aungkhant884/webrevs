{"files":[{"patch":"@@ -16676,1 +16676,1 @@\n-    \/\/ Count is in 8-bit bytes; non-Compact chars are 16 bits.\n+    \/\/ Count is in 8-bit bytes.\n@@ -16692,1 +16692,1 @@\n-    \/\/ Count is in 8-bit bytes; non-Compact chars are 16 bits.\n+    \/\/ Count is in 8-bit bytes.\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -96,0 +96,2 @@\n+  product(bool, UseSimpleStringEquals, true,                            \\\n+          \"Use simpliest and shortest implementation for string equals\")\\\n","filename":"src\/hotspot\/cpu\/aarch64\/globals_aarch64.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -4758,5 +4758,0 @@\n-\/\/ There are two implementations.  For arrays >= 8 bytes, all\n-\/\/ comparisons (including the final one, which may overlap) are\n-\/\/ performed 8 bytes at a time.  For strings < 8 bytes, we compare a\n-\/\/ halfword, then a short, and then a byte.\n-\n@@ -4766,1 +4761,1 @@\n-  Label SAME, DONE, SHORT, NEXT_WORD;\n+  Label SAME, DONE, SHORT;\n@@ -4769,1 +4764,1 @@\n-  Register cnt2 = tmp2;  \/\/ cnt2 only used in array length compare\n+  int stubBytesThreshold = 64 - wordSize;\n@@ -4787,19 +4782,55 @@\n-  br(Assembler::LT, SHORT);\n-  \/\/ Main 8 byte comparison loop.\n-  bind(NEXT_WORD); {\n-    ldr(tmp1, Address(post(a1, wordSize)));\n-    ldr(tmp2, Address(post(a2, wordSize)));\n-    subs(cnt1, cnt1, wordSize);\n-    eor(tmp1, tmp1, tmp2);\n-    cbnz(tmp1, DONE);\n-  } br(GT, NEXT_WORD);\n-  \/\/ Last longword.  In the case where length == 4 we compare the\n-  \/\/ same longword twice, but that's still faster than another\n-  \/\/ conditional branch.\n-  \/\/ cnt1 could be 0, -1, -2, -3, -4 for chars; -4 only happens when\n-  \/\/ length == 4.\n-  ldr(tmp1, Address(a1, cnt1));\n-  ldr(tmp2, Address(a2, cnt1));\n-  eor(tmp2, tmp1, tmp2);\n-  cbnz(tmp2, DONE);\n-  b(SAME);\n+  br(LT, SHORT);\n+\n+  if (!UseSimpleStringEquals) {\n+    Label STUB, LOOP;\n+    subs(zr, cnt1, stubBytesThreshold);\n+    br(GE, STUB);\n+\n+    bind(LOOP); {\n+      ldr(tmp1, Address(post(a1, wordSize)));\n+      ldr(tmp2, Address(post(a2, wordSize)));\n+      subs(cnt1, cnt1, wordSize);\n+      eor(tmp1, tmp1, tmp2);\n+      cbnz(tmp1, DONE);\n+      br(LT, SHORT);\n+\n+      ldr(tmp1, Address(post(a1, wordSize)));\n+      ldr(tmp2, Address(post(a2, wordSize)));\n+      subs(cnt1, cnt1, wordSize);\n+      eor(tmp1, tmp1, tmp2);\n+      cbnz(tmp1, DONE);\n+    } br(GE, LOOP);\n+    b(SHORT);\n+\n+    bind(STUB);\n+    RuntimeAddress stub = RuntimeAddress(StubRoutines::aarch64::long_string_equals());\n+    assert(stub.target() != NULL, \"string_equals_long stub has not been generated\");\n+    address tpc = trampoline_call(stub);\n+    if (tpc == NULL) {\n+      DEBUG_ONLY(reset_labels(SHORT, SAME, DONE));\n+      postcond(pc() == badAddress);\n+      return;\n+    }\n+    b(DONE);\n+  } else {\n+    Label NEXT_WORD;\n+\n+    \/\/ Main 8 byte comparison loop.\n+    bind(NEXT_WORD); {\n+      ldr(tmp1, Address(post(a1, wordSize)));\n+      ldr(tmp2, Address(post(a2, wordSize)));\n+      subs(cnt1, cnt1, wordSize);\n+      eor(tmp1, tmp1, tmp2);\n+      cbnz(tmp1, DONE);\n+    } br(GT, NEXT_WORD);\n+    \/\/ Last longword.  In the case where length == 4 we compare the\n+    \/\/ same longword twice, but that's still faster than another\n+    \/\/ conditional branch.\n+    \/\/ cnt1 could be 0, -1, -2, -3, -4 for chars; -4 only happens when\n+    \/\/ length == 4.\n+    ldr(tmp1, Address(a1, cnt1));\n+    ldr(tmp2, Address(a2, cnt1));\n+    eor(tmp2, tmp1, tmp2);\n+    cbnz(tmp2, DONE);\n+    b(SAME);\n+  }\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":57,"deletions":26,"binary":false,"changes":83,"status":"modified"},{"patch":"@@ -4635,0 +4635,85 @@\n+  \/\/ a1 = r1 - string1 address\n+  \/\/ a2 = r3 - string2 address\n+  \/\/ result = r0 - return value. Already contains \"false\"\n+  \/\/ cnt1 = r4 - amount of elements left to check\n+  address generate_long_string_equals() {\n+    Register a1 = r1, a2 = r3, result = r0, cnt1 = r4, tmp1 = rscratch1,\n+        tmp2 = rscratch2;\n+    Label TAIL, NOT_EQUAL, EQUAL, LOOP, SMALL_LOOP, POST_LOOP;\n+    int loopThreshold = 4 * 2 * wordSize;\n+\n+    assert_different_registers(a1, a2, result, cnt1, tmp1, tmp2);\n+\n+    __ align(CodeEntryAlignment);\n+\n+    StubCodeMark mark(this, \"StubRoutines\", \"long_string_equals\");\n+\n+    address entry = __ pc();\n+    __ enter();\n+\n+    \/\/ cnt1 minus wordSize outside of stub\n+    __ add(cnt1, cnt1, wordSize);\n+\n+    __ bind(LOOP);\n+      __ ldr(v0, __ Q, Address(__ post(a1, wordSize * 2)));\n+      __ ldr(v1, __ Q, Address(__ post(a2, wordSize * 2)));\n+      __ eor(v0, __ T16B, v0, v1);\n+      __ umov(tmp1, v0, __ D, 0);\n+      __ umov(tmp2, v0, __ D, 1);\n+      __ orr(tmp1, tmp1, tmp2);\n+      __ cbnz(tmp1, NOT_EQUAL);\n+\n+      __ ldr(v2, __ Q, Address(__ post(a1, wordSize * 2)));\n+      __ ldr(v3, __ Q, Address(__ post(a2, wordSize * 2)));\n+      __ eor(v2, __ T16B, v2, v3);\n+      __ umov(tmp1, v2, __ D, 0);\n+      __ umov(tmp2, v2, __ D, 1);\n+      __ orr(tmp1, tmp1, tmp2);\n+      __ cbnz(tmp1, NOT_EQUAL);\n+\n+      __ ldr(v4, __ Q, Address(__ post(a1, wordSize * 2)));\n+      __ ldr(v5, __ Q, Address(__ post(a2, wordSize * 2)));\n+      __ eor(v4, __ T16B, v4, v5);\n+      __ umov(tmp1, v4, __ D, 0);\n+      __ umov(tmp2, v4, __ D, 1);\n+      __ orr(tmp1, tmp1, tmp2);\n+      __ cbnz(tmp1, NOT_EQUAL);\n+\n+      __ ldr(v6, __ Q, Address(__ post(a1, wordSize * 2)));\n+      __ sub(cnt1, cnt1, loopThreshold);\n+      __ ldr(v7, __ Q, Address(__ post(a2, wordSize * 2)));\n+      __ subs(tmp1, cnt1, loopThreshold);\n+      __ eor(v6, __ T16B, v6, v7);\n+      __ umov(tmp1, v6, __ D, 0);\n+      __ umov(tmp2, v6, __ D, 1);\n+      __ orr(tmp1, tmp1, tmp2);\n+      __ cbnz(tmp1, NOT_EQUAL);\n+      __ br(__ GE, LOOP);\n+\n+    __ bind(TAIL);\n+      __ cbz(cnt1, EQUAL);\n+      __ subs(cnt1, cnt1, wordSize);\n+      __ br(__ LE, POST_LOOP);\n+    __ bind(SMALL_LOOP);\n+      __ ldr(tmp1, Address(__ post(a1, wordSize)));\n+      __ ldr(tmp2, Address(__ post(a2, wordSize)));\n+      __ subs(cnt1, cnt1, wordSize);\n+      __ eor(tmp1, tmp1, tmp2);\n+      __ cbnz(tmp1, NOT_EQUAL);\n+      __ br(__ GT, SMALL_LOOP);\n+    __ bind(POST_LOOP);\n+      __ ldr(tmp1, Address(a1, cnt1));\n+      __ ldr(tmp2, Address(a2, cnt1));\n+      __ eor(tmp1, tmp1, tmp2);\n+      __ cbnz(tmp1, NOT_EQUAL);\n+\n+    __ bind(EQUAL);\n+      __ mov(result, true);\n+\n+    __ bind(NOT_EQUAL);\n+      __ leave();\n+      __ ret(lr);\n+\n+    return entry;\n+  }\n+\n@@ -7066,0 +7151,5 @@\n+    }\n+\n+    \/\/ string equals stub for long strings.\n+    if (!UseSimpleStringEquals) {\n+      StubRoutines::aarch64::_long_string_equals = generate_long_string_equals();\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":90,"deletions":0,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -51,0 +51,1 @@\n+address StubRoutines::aarch64::_long_string_equals = NULL;\n","filename":"src\/hotspot\/cpu\/aarch64\/stubRoutines_aarch64.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -64,0 +64,1 @@\n+  static address _long_string_equals;\n@@ -144,0 +145,4 @@\n+  static address long_string_equals() {\n+      return _long_string_equals;\n+  }\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/stubRoutines_aarch64.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -159,0 +159,3 @@\n+    if (FLAG_IS_DEFAULT(UseSimpleStringEquals)) {\n+      FLAG_SET_DEFAULT(UseSimpleStringEquals, false);\n+    }\n","filename":"src\/hotspot\/cpu\/aarch64\/vm_version_aarch64.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,2 @@\n+\n+import java.util.*;\n@@ -35,0 +37,2 @@\n+    @Param({\"8\", \"16\", \"32\", \"64\", \"128\"})\n+    int size;\n@@ -44,1 +48,28 @@\n-    @Benchmark\n+    public String str;\n+    public String strh;\n+    public String strt;\n+\n+    @Setup()\n+    public void init() {\n+        str = newString(size, 'c', -1, 'a');\n+        strh = newString(size, 'c', size \/ 3, 'a');\n+        strt = newString(size, 'c', size - 1 - size \/ 3, 'a');\n+    }\n+\n+    public String newString(int size, char charToFill, int pos, char charDiff) {\n+        if (size > 0) {\n+            char[] array = new char[size];\n+            Arrays.fill(array, charToFill);\n+            if (pos >= 0) {\n+                array[pos] = charDiff;\n+            }\n+            return new String(array);\n+        }\n+        return \"\";\n+    }\n+\n+    @Fork(jvmArgsAppend = {\"-XX:+UseSimpleStringEquals\"})\n+    public boolean different_simple() {\n+        return test.equals(test2);\n+    }\n+\n@@ -49,1 +80,5 @@\n-    @Benchmark\n+    @Fork(jvmArgsAppend = {\"-XX:+UseSimpleStringEquals\"})\n+    public boolean equal_simple() {\n+        return test.equals(test3);\n+    }\n+\n@@ -54,1 +89,5 @@\n-    @Benchmark\n+    @Fork(jvmArgsAppend = {\"-XX:+UseSimpleStringEquals\"})\n+    public boolean almostEqual_simple() {\n+        return test.equals(test6);\n+    }\n+\n@@ -59,1 +98,5 @@\n-    @Benchmark\n+    @Fork(jvmArgsAppend = {\"-XX:+UseSimpleStringEquals\"})\n+    public boolean almostEqualUTF16_simple() {\n+        return test4.equals(test7);\n+    }\n+\n@@ -64,1 +107,5 @@\n-    @Benchmark\n+    @Fork(jvmArgsAppend = {\"-XX:+UseSimpleStringEquals\"})\n+    public boolean differentCoders_simple() {\n+        return test.equals(test4);\n+    }\n+\n@@ -69,1 +116,5 @@\n-    @Benchmark\n+    @Fork(jvmArgsAppend = {\"-XX:+UseSimpleStringEquals\"})\n+    public boolean equalsUTF16_simple() {\n+        return test5.equals(test4);\n+    }\n+\n@@ -73,1 +124,0 @@\n-}\n@@ -75,0 +125,22 @@\n+    @Benchmark\n+    @Fork(jvmArgsAppend = {\"-XX:+UseSimpleStringEquals\"})\n+    public boolean equalsLenH_simple() {\n+        return str.equals(strh);\n+    }\n+\n+    @Benchmark\n+    public boolean equalsLenH() {\n+        return str.equals(strh);\n+    }\n+\n+    @Benchmark\n+    @Fork(jvmArgsAppend = {\"-XX:+UseSimpleStringEquals\"})\n+    public boolean equalsLenT_simple() {\n+        return str.equals(strt);\n+    }\n+\n+    @Benchmark\n+    public boolean equalsLenT() {\n+        return str.equals(strt);\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/StringEquals.java","additions":80,"deletions":8,"binary":false,"changes":88,"status":"modified"}]}