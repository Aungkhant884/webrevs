{"files":[{"patch":"@@ -2961,0 +2961,4 @@\n+              The <functionlink id=\"PopFrame\"><\/functionlink> function may be used to\n+              pop the current frame of a virtual thread when it is suspended at an event.\n+              An implementation may support popping the current frame of a suspended\n+              virtual thread in other cases.\n@@ -2970,2 +2974,2 @@\n-          The thread is a virtual thread and the implementation is unable\n-          to pop this frame.\n+          The thread is a suspended virtual thread and the implementation\n+          was unable to pop the current frame.\n","filename":"src\/hotspot\/share\/prims\/jvmti.xml","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1886,4 +1886,0 @@\n-  if (thread_obj != nullptr && thread_obj->is_a(vmClasses::BaseVirtualThread_klass())) {\n-    \/\/ No support for virtual threads (yet).\n-    return JVMTI_ERROR_OPAQUE_FRAME;\n-  }\n@@ -1893,0 +1889,17 @@\n+  bool is_virtual = thread_obj != nullptr && thread_obj->is_a(vmClasses::BaseVirtualThread_klass());\n+\n+  if (is_virtual) {\n+    if (!is_JavaThread_current(java_thread, thread_obj)) {\n+      if (!is_vthread_suspended(thread_obj, java_thread)) {\n+        return JVMTI_ERROR_THREAD_NOT_SUSPENDED;\n+      }\n+      if (java_thread == nullptr) { \/\/ unmounted virtual thread\n+        return JVMTI_ERROR_OPAQUE_FRAME;\n+      }\n+    }\n+  } else { \/\/ platform thread\n+    if (java_thread != current_thread && !java_thread->is_suspended() &&\n+        !java_thread->is_carrier_thread_suspended()) {\n+      return JVMTI_ERROR_THREAD_NOT_SUSPENDED;\n+    }\n+  }\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnv.cpp","additions":17,"deletions":4,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2214,5 +2214,0 @@\n-  if (!self && !java_thread->is_suspended() && !java_thread->is_carrier_thread_suspended()) {\n-    _result = JVMTI_ERROR_THREAD_NOT_SUSPENDED;\n-    return;\n-  }\n-\n@@ -2220,1 +2215,1 @@\n-  if (java_thread->popframe_condition() != JavaThread::popframe_inactive) {\n+  if (!self && java_thread->popframe_condition() != JavaThread::popframe_inactive) {\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnvBase.cpp","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -118,4 +118,0 @@\n-  LOG(\"Testing PopFrame\\n\");\n-  err = jvmti->PopFrame(vthread);\n-  check_jvmti_error_opaque_frame(jni, \"PopFrame\", err);\n-\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/vthread\/BoundVThreadTest\/libBoundVThreadTest.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,253 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test id=default\n+ * @summary Verifies JVMTI PopFrame support for virtual threads.\n+ * @requires vm.continuations\n+ * @run main\/othervm\/native -agentlib:PopFrameTest PopFrameTest\n+ *\/\n+\n+\/*\n+ * @test id=no-vmcontinuations\n+ * @summary Verifies JVMTI PopFrame support for bound virtual threads.\n+ * @run main\/othervm\/native -agentlib:PopFrameTest -XX:+UnlockExperimentalVMOptions -XX:-VMContinuations PopFrameTest\n+ *\/\n+\n+\/*\n+ * @test id=platform\n+ * @summary Verifies JVMTI PopFrame support for platform threads.\n+ * @run main\/othervm\/native -agentlib:PopFrameTest PopFrameTest platform\n+ *\/\n+\n+import java.lang.AssertionError;\n+\n+\/*\n+ *     The test exercises the JVMTI function PopFrame.\n+ *     The test creates a new virtual or platform thread.\n+ *     Its method run() invokes the following methods:\n+ *      - method A() that is blocked on a monitor\n+ *      - method B() that is stopped at a breakpoint\n+ *      - method C() that forces agent to call PopFrame on its own thread\n+ *     JVMTI PopFrame is called in all cases.\n+ *\/\n+public class PopFrameTest {\n+    private static final String agentLib = \"PopFrameTest\";\n+    static final int JVMTI_ERROR_NONE = 0;\n+    static final int THREAD_NOT_SUSPENDED = 13;\n+    static final int OPAQUE_FRAME = 32;\n+    static final int PASSED = 0;\n+    static final int FAILED = 2;\n+\n+    static void log(String str) { System.out.println(str); }\n+\n+    static native void prepareAgent(Class taskClass);\n+    static native void suspendThread(Thread thread);\n+    static native void resumeThread(Thread thread);\n+    static native void ensureAtBreakpoint();\n+    static native void notifyAtBreakpoint();\n+    static native int  popFrame(Thread thread);\n+\n+    static int status = PASSED;\n+    static boolean is_virtual = true;\n+\n+    static void setFailed(String msg) {\n+        log(\"\\nFAILED: \" + msg);\n+        status = FAILED;\n+    }\n+\n+    static void throwFailed(String msg) {\n+        log(\"\\nFAILED: \" + msg);\n+        throw new RuntimeException(\"PopFrameTest failed!\");\n+    }\n+\n+    public static void main(String args[]) {\n+        is_virtual = !(args.length > 0 && args[0].equals(\"platform\"));\n+        run();\n+        if (status == FAILED) {\n+            throwFailed(\"PopFrameTest!\");\n+        }\n+        log(\"\\nPopFrameTest passed\");\n+    }\n+\n+    public static void run() {\n+        TestTask testTask = new TestTask();\n+        Thread testTaskThread = null;\n+        int errCode;\n+\n+        prepareAgent(TestTask.class);\n+\n+        log(\"\\nMain #A: method A() must be blocked on entering a synchronized statement\");\n+        if (is_virtual) {\n+            testTaskThread = Thread.ofVirtual().name(\"TestTaskThread\").start(testTask);\n+        } else {\n+            testTaskThread = Thread.ofPlatform().name(\"TestTaskThread\").start(testTask);\n+        }\n+\n+        {\n+            TestTask.ensureAtPointA();\n+\n+            log(\"\\nMain #A.1: unsuspended\");\n+            errCode = popFrame(testTaskThread);\n+            if (errCode != THREAD_NOT_SUSPENDED) {\n+                throwFailed(\"Main #A.1: expected THREAD_NOT_SUSPENDED instead of: \" + errCode);\n+            } else {\n+                log(\"Main #A.1: got expected THREAD_NOT_SUSPENDED\");\n+            }\n+\n+            log(\"\\nMain #A.2: suspended\");\n+            suspendThread(testTaskThread);\n+            errCode = popFrame(testTaskThread);\n+            if (errCode != JVMTI_ERROR_NONE) {\n+                throwFailed(\"Main #A.2: expected JVMTI_ERROR_NONE instead of: \" + errCode);\n+            } else {\n+                log(\"Main #A.2: got expected JVMTI_ERROR_NONE\");\n+            }\n+            resumeThread(testTaskThread);\n+            TestTask.clearDoLoop();\n+            TestTask.sleep(5);\n+        }\n+\n+        log(\"\\nMain #B: method B() must be blocked in a breakpoint event handler\");\n+        {\n+            ensureAtBreakpoint();\n+\n+            log(\"\\nMain #B.1: unsuspended\");\n+            errCode = popFrame(testTaskThread);\n+            if (errCode != THREAD_NOT_SUSPENDED) {\n+                throwFailed(\"Main #B.1: expected THREAD_NOT_SUSPENDED instead of: \" + errCode);\n+            }\n+            log(\"Main #B.1: got expected THREAD_NOT_SUSPENDED\");\n+\n+            log(\"\\nMain #B.2: suspended\");\n+            suspendThread(testTaskThread);\n+            errCode = popFrame(testTaskThread);\n+            if (errCode != JVMTI_ERROR_NONE) {\n+                throwFailed(\"Main #B.2: expected JVMTI_ERROR_NONE\");\n+            }\n+            log(\"Main #B.2: got expected JVMTI_ERROR_NONE\");\n+            resumeThread(testTaskThread);\n+            notifyAtBreakpoint();\n+\n+            log(\"\\nMain #B.3: unsuspended, call PopFrame on own thread\");\n+            ensureAtBreakpoint();\n+            notifyAtBreakpoint();\n+            TestTask.sleep(5);\n+        }\n+\n+        log(\"\\nMain #C: method C() calls PopFrame on its own thread\");\n+        {\n+            \/\/ PopFrame is called from the test task (own thread) and expected to succeed.\n+            \/\/ No suspension of the test task thread is required or can be done in this case.\n+            TestTask.ensureFinished();\n+        }\n+\n+        try {\n+            testTaskThread.join();\n+        } catch (InterruptedException ex) {\n+            throwFailed(\"Unexpected \" + ex);\n+        }\n+    }\n+\n+\n+    static class TestTask implements Runnable {\n+        static void log(String str) { System.out.println(str); }\n+\n+        static volatile boolean doLoop = true;\n+        static volatile boolean atPointA = false;\n+        static volatile boolean finished = false;\n+\n+        static void sleep(long millis) {\n+            try {\n+                Thread.sleep(millis);\n+            } catch (InterruptedException e) {\n+                throw new RuntimeException(\"Interruption in TestTask.sleep: \\n\\t\" + e);\n+            }\n+        }\n+\n+        \/\/ Ensure thread is ready.\n+        static void ensureAtPointA() {\n+            while (!atPointA) {\n+                sleep(1);\n+            }\n+        }\n+\n+        \/\/ Ensure thread is finished.\n+        static void ensureFinished() {\n+            while (!finished) {\n+                sleep(1);\n+            }\n+        }\n+\n+        static void clearDoLoop() {\n+            doLoop = false;\n+        }\n+\n+        public void run() {\n+            log(\"TestTask.run: started\");\n+\n+            A();\n+            sleep(1); \/\/ to cause yield\n+\n+            B();\n+            sleep(1); \/\/ to cause yield\n+\n+            B();\n+            sleep(1); \/\/ to cause yield\n+\n+            C();\n+            finished = true;\n+        }\n+\n+        \/\/ Method is busy in a while loop.\n+        \/\/ PopFrame is used two times:\n+        \/\/  - when not suspended: THREAD_NOT_SUSPENDED is expected\n+        \/\/  - when suspended: JVMTI_ERROR_NONE is expected\n+        static void A() {\n+            log(\"TestTask.A: started\");\n+            atPointA = true;\n+            while (doLoop) {\n+            }\n+            log(\"TestTask.A: finished\");\n+        }\n+\n+        \/\/ A breakpoint is set at start of this method.\n+        \/\/ PopFrame is used two times:\n+        \/\/  - when not suspended: THREAD_NOT_SUSPENDED is expected\n+        \/\/  - when suspended: expected to succeed\n+        static void B() {\n+            log(\"TestTask.B: started\");\n+        }\n+\n+        \/\/ This method uses PopFrame on its own thread. It is expected to return OPAQUE_FRAME.\n+        static void C() {\n+            log(\"TestTask.C: started\");\n+            int errCode = PopFrameTest.popFrame(Thread.currentThread());\n+            if (errCode == OPAQUE_FRAME) {\n+                log(\"TestTask.C: got expected OPAQUE_FRAME\");\n+            } else {\n+                setFailed(\"TestTask.C: expected OPAQUE_FRAME from PopFrame instead of: \" + errCode);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/vthread\/PopFrameTest\/PopFrameTest.java","additions":253,"deletions":0,"binary":false,"changes":253,"status":"added"},{"patch":"@@ -0,0 +1,166 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <stdio.h>\n+#include <string.h>\n+#include \"jvmti.h\"\n+#include \"jvmti_common.h\"\n+\n+extern \"C\" {\n+\n+static jvmtiEnv *jvmti = NULL;\n+static jmethodID mid_B = NULL;\n+static jrawMonitorID monitor = NULL;\n+static volatile bool bp_sync_reached = false;\n+\n+static void JNICALL\n+Breakpoint(jvmtiEnv *jvmti, JNIEnv *jni, jthread thread,\n+           jmethodID method, jlocation location) {\n+  jvmtiError err;\n+\n+  if (method != mid_B) {\n+    fatal(jni, \"Breakpoint: Failed with wrong location: expected in method TestTask.B()\");\n+  }\n+  err = jvmti->ClearBreakpoint(mid_B, 0);\n+  check_jvmti_status(jni, err, \"Breakpoint: Failed in JVMTI ClearBreakpoint\");\n+\n+  LOG(\"Breakpoint: In method TestTask.B(): before sync section enter\\n\");\n+  {\n+    RawMonitorLocker rml(jvmti, jni, monitor);\n+    bp_sync_reached = true;\n+    rml.wait(0);\n+  }\n+  err = jvmti->PopFrame(thread);\n+  LOG(\"Main: popFrame: PopFrame returned code: %s (%d)\\n\", TranslateError(err), err);\n+  check_jvmti_status(jni, err, \"Breakpoint: Failed in PopFrame\");\n+\n+  LOG(\"Breakpoint: In method TestTask.B(): after sync section exit\\n\");\n+}\n+\n+jint Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {\n+  static jvmtiCapabilities caps;\n+  static jvmtiEventCallbacks callbacks;\n+  jvmtiError err;\n+  jint res;\n+\n+  LOG(\"Agent init\\n\");\n+  res = jvm->GetEnv((void **) &jvmti, JVMTI_VERSION_1_1);\n+  if (res != JNI_OK || jvmti == NULL) {\n+    LOG(\"Agent init: Failed in GetEnv!\\n\");\n+    return JNI_ERR;\n+  }\n+  err = jvmti->GetPotentialCapabilities(&caps);\n+  if (err != JVMTI_ERROR_NONE) {\n+    LOG(\"Agent init: Failed in GetPotentialCapabilities: %s (%d)\\n\", TranslateError(err), err);\n+    return JNI_ERR;\n+  }\n+  err = jvmti->AddCapabilities(&caps);\n+  if (err != JVMTI_ERROR_NONE) {\n+    LOG(\"Agent init: Failed in AddCapabilities: %s (%d)\\n\", TranslateError(err), err);\n+    return JNI_ERR;\n+  }\n+  err = jvmti->GetCapabilities(&caps);\n+  if (err != JVMTI_ERROR_NONE) {\n+    LOG(\"Agent init: Failed in GetCapabilities: %s (%d)\\n\", TranslateError(err), err);\n+    return JNI_ERR;\n+  }\n+  if (!caps.can_generate_breakpoint_events) {\n+    LOG(\"Agent init: Failed: Breakpoint event is not implemented\\n\");\n+    return JNI_ERR;\n+  }\n+  callbacks.Breakpoint = &Breakpoint;\n+  err = jvmti->SetEventCallbacks(&callbacks, sizeof(callbacks));\n+  if (err != JVMTI_ERROR_NONE) {\n+    LOG(\"Agent init: Failed in SetEventCallbacks: %s (%d)\\n\", TranslateError(err), err);\n+    return JNI_ERR;\n+  }\n+\n+  monitor = create_raw_monitor(jvmti, \"Raw monitor to test\");\n+  return JNI_OK;\n+}\n+\n+extern JNIEXPORT jint JNICALL\n+Agent_OnLoad(JavaVM *jvm, char *options, void *reserved) {\n+  return Agent_Initialize(jvm, options, reserved);\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_PopFrameTest_prepareAgent(JNIEnv *jni, jclass cls, jclass task_clazz) {\n+  jvmtiError err;\n+\n+  LOG(\"Main: prepareAgent started\\n\");\n+\n+  if (jvmti == NULL) {\n+    fatal(jni, \"prepareAgent: Failed as JVMTI client was not properly loaded!\\n\");\n+  }\n+  mid_B = jni->GetStaticMethodID(task_clazz, \"B\", \"()V\");\n+  if (mid_B == NULL) {\n+    fatal(jni, \"prepareAgent: Failed to find Method ID for method: TestTask.B()\\n\");\n+  }\n+  err = jvmti->SetBreakpoint(mid_B, 0);\n+  check_jvmti_status(jni, err, \"prepareAgent: Failed in JVMTI SetBreakpoint\");\n+\n+  set_event_notification_mode(jvmti, JVMTI_ENABLE, JVMTI_EVENT_BREAKPOINT, NULL);\n+\n+  LOG(\"Main: prepareAgent finished\\n\");\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_PopFrameTest_suspendThread(JNIEnv *jni, jclass cls, jthread thread) {\n+  LOG(\"Main: suspendThread\\n\");\n+  suspend_thread(jvmti, jni, thread);\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_PopFrameTest_resumeThread(JNIEnv *jni, jclass cls, jthread thread) {\n+  LOG(\"Main: resumeThread\\n\");\n+  resume_thread(jvmti, jni, thread);\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_PopFrameTest_popFrame(JNIEnv *jni, jclass cls, jthread thread) {\n+  jvmtiError err = jvmti->PopFrame(thread);\n+  LOG(\"Main: popFrame: PopFrame returned code: %s (%d)\\n\", TranslateError(err), err);\n+  return (jint)err;\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_PopFrameTest_ensureAtBreakpoint(JNIEnv *jni, jclass cls) {\n+  bool need_stop = false;\n+\n+  LOG(\"Main: ensureAtBreakpoint\\n\");\n+  while (!need_stop) {\n+    RawMonitorLocker rml(jvmti, jni, monitor);\n+    need_stop = bp_sync_reached;\n+    sleep_ms(1); \/\/ 1 millisecond\n+  }\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_PopFrameTest_notifyAtBreakpoint(JNIEnv *jni, jclass cls) {\n+  LOG(\"Main: notifyAtBreakpoint\\n\");\n+  RawMonitorLocker rml(jvmti, jni, monitor);\n+  rml.notify_all();\n+}\n+\n+} \/\/ extern \"C\"\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/vthread\/PopFrameTest\/libPopFrameTest.cpp","additions":166,"deletions":0,"binary":false,"changes":166,"status":"added"},{"patch":"@@ -90,4 +90,0 @@\n-  LOG(\"Testing PopFrame\\n\");\n-  err = jvmti->PopFrame(vthread);\n-  check_jvmti_error_opaque_frame(jni, \"PopFrame\", err);\n-\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/vthread\/VThreadUnsupportedTest\/libVThreadUnsupportedTest.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"}]}