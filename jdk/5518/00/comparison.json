{"files":[{"patch":"@@ -870,2 +870,1 @@\n-  const size_t max_overhead_words = metaspace::get_raw_word_size_for_requested_word_size(1);\n-  return metaspace::chunklevel::MAX_CHUNK_WORD_SIZE - max_overhead_words;\n+  return metaspace::chunklevel::MAX_CHUNK_WORD_SIZE;\n","filename":"src\/hotspot\/share\/memory\/metaspace.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1,116 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2020 SAP SE. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_MEMORY_METASPACE_ALLOCATIONGUARD_HPP\n-#define SHARE_MEMORY_METASPACE_ALLOCATIONGUARD_HPP\n-\n-#include \"memory\/allocation.hpp\"\n-#include \"memory\/metaspace\/chunklevel.hpp\"\n-#include \"utilities\/globalDefinitions.hpp\"\n-\n-\/\/ In Debug builds, Metadata in Metaspace can be optionally guarded - enclosed in canaries -\n-\/\/ to detect memory overwriters.\n-\/\/\n-\/\/ These canaries are periodically checked, e.g. when the Metaspace is purged in a context\n-\/\/ of a GC.\n-\n-\/\/ The canaries precede any allocated block...\n-\/\/\n-\/\/ +---------------+\n-\/\/ |  'METAMETA'   |\n-\/\/ +---------------+\n-\/\/ |  block size   |\n-\/\/ +---------------+\n-\/\/ |  block...     |\n-\/\/ .               .\n-\/\/ .               .\n-\/\/ .               .\n-\/\/ |               |\n-\/\/ +---------------+\n-\/\/ . <padding>     .\n-\/\/ +---------------+\n-\/\/ |  'METAMETA'   |\n-\/\/ +---------------+\n-\/\/ |  block size   |\n-\/\/ +---------------+\n-\/\/ |  block...     |\n-\n-\/\/ ... and since the blocks are allocated via pointer bump and closely follow each other,\n-\/\/ one block's prefix is its predecessor's suffix, so apart from the last block all\n-\/\/ blocks have an overwriter canary on both ends.\n-\/\/\n-\n-\/\/ Note: this feature is only available in debug, and is activated using\n-\/\/  -XX:+MetaspaceGuardAllocations. When active, it disables deallocation handling - since\n-\/\/  freeblock handling in the freeblock lists would get too complex - so one may run leaks\n-\/\/  in deallocation-heavy scenarios (e.g. lots of class redefinitions).\n-\/\/\n-\n-namespace metaspace {\n-\n-#ifdef ASSERT\n-\n-struct Prefix {\n-  static const uintx EyeCatcher =\n-      NOT_LP64(0x77698465) LP64_ONLY(0x7769846577698465ULL); \/\/ \"META\" resp \"METAMETA\"\n-\n-  const uintx _mark;\n-  const size_t _word_size;   \/\/ raw word size including prefix\n-  \/\/ MetaWord payload [0];   \/\/ varsized (but unfortunately not all our compilers understand that)\n-\n-  Prefix(size_t word_size) :\n-    _mark(EyeCatcher),\n-    _word_size(word_size)\n-  {}\n-\n-  MetaWord* payload() const {\n-    return (MetaWord*)(this + 1);\n-  }\n-\n-  bool is_valid() const {\n-    return _mark == EyeCatcher && _word_size > 0 && _word_size < chunklevel::MAX_CHUNK_WORD_SIZE;\n-  }\n-\n-};\n-\n-\/\/ The prefix structure must be aligned to MetaWord size.\n-STATIC_ASSERT((sizeof(Prefix) & WordAlignmentMask) == 0);\n-\n-inline size_t prefix_size() {\n-  return sizeof(Prefix);\n-}\n-\n-\/\/ Given a pointer to a memory area, establish the prefix at the start of that area and\n-\/\/ return the starting pointer to the payload.\n-inline MetaWord* establish_prefix(MetaWord* p_raw, size_t raw_word_size) {\n-  const Prefix* pp = new(p_raw)Prefix(raw_word_size);\n-  return pp->payload();\n-}\n-\n-#endif\n-\n-} \/\/ namespace metaspace\n-\n-#endif \/\/ SHARE_MEMORY_METASPACE_ALLOCATIONGUARD_HPP\n","filename":"src\/hotspot\/share\/memory\/metaspace\/allocationGuard.hpp","additions":0,"deletions":116,"binary":false,"changes":116,"status":"deleted"},{"patch":"@@ -29,1 +29,0 @@\n-#include \"memory\/metaspace\/allocationGuard.hpp\"\n@@ -126,0 +125,3 @@\n+#ifdef ASSERT\n+  , _first_fence(NULL)\n+#endif\n@@ -229,6 +231,1 @@\n-  MetaWord* p = NULL;\n-  const size_t raw_word_size = get_raw_word_size_for_requested_word_size(requested_word_size);\n-\n-  \/\/ 1) Attempt to allocate from the free blocks list\n-  \/\/    (Note: to reduce complexity, deallocation handling is disabled if allocation guards\n-  \/\/     are enabled, see Settings::ergo_initialize())\n+  \/\/ Before bothering the arena proper, attempt to re-use a block from the free blocks list\n@@ -236,1 +233,2 @@\n-    p = _fbl->remove_block(raw_word_size);\n+    size_t raw_word_size = get_raw_word_size_for_requested_word_size(requested_word_size);\n+    MetaWord* p = _fbl->remove_block(raw_word_size);\n@@ -248,0 +246,29 @@\n+  \/\/ Primary allocation\n+  MetaWord* p = allocate_inner(requested_word_size);\n+\n+#ifdef ASSERT\n+  \/\/ Fence allocation\n+  if (p != NULL && Settings::use_allocation_guard()) {\n+    STATIC_ASSERT(is_aligned(sizeof(Fence), BytesPerWord));\n+    MetaWord* guard = allocate_inner(sizeof(Fence) \/ BytesPerWord);\n+    if (guard != NULL) {\n+      \/\/ For now, we just ignore allocation errors for the fence to keep things simple.\n+      \/\/ We may miss adding a fence, but that is not such a big deal, esp. since this\n+      \/\/ should be rare (chances are much higher we would have failed the primary\n+      \/\/ allocation too).\n+      Fence* f = new(guard) Fence(_first_fence);\n+      _first_fence = f;\n+    }\n+  }\n+#endif \/\/ ASSERT\n+\n+  return p;\n+}\n+\n+\/\/ Allocate from the arena proper, once dictionary allocations and fencing are sorted out.\n+MetaWord* MetaspaceArena::allocate_inner(size_t requested_word_size) {\n+\n+  assert_lock_strong(lock());\n+\n+  const size_t raw_word_size = get_raw_word_size_for_requested_word_size(requested_word_size);\n+  MetaWord* p = NULL;\n@@ -253,1 +280,1 @@\n-    \/\/ 2) Attempt to satisfy the allocation from the current chunk.\n+    \/\/ Attempt to satisfy the allocation from the current chunk.\n@@ -314,7 +341,0 @@\n-#ifdef ASSERT\n-  \/\/ When using allocation guards, establish a prefix.\n-  if (p != NULL && Settings::use_allocation_guard()) {\n-    p = establish_prefix(p, raw_word_size);\n-  }\n-#endif\n-\n@@ -428,0 +448,5 @@\n+void MetaspaceArena::Fence::verify() const {\n+  assert(_eye1 == EyeCatcher && _eye2 == EyeCatcher,\n+         \"Metaspace corruption: fence block at \" PTR_FORMAT \" broken.\", p2i(this));\n+}\n+\n@@ -430,28 +455,2 @@\n-\n-  \/\/ Verify canaries of all allocations.\n-  \/\/ (We can walk all allocations since at the start of a chunk an allocation\n-  \/\/  must be present, and the allocation header contains its size, so we can\n-  \/\/  find the next one).\n-  for (const Metachunk* c = _chunks.first(); c != NULL; c = c->next()) {\n-    const Prefix* first_broken_block = NULL;\n-    int num_broken_blocks = 0;\n-    const MetaWord* p = c->base();\n-    while (p < c->top()) {\n-      const Prefix* pp = (const Prefix*)p;\n-      if (!pp->is_valid()) {\n-        UL2(error, \"Corrupt block at \" PTR_FORMAT \" (chunk: \" METACHUNK_FORMAT \").\",\n-            p2i(pp), METACHUNK_FORMAT_ARGS(c));\n-        if (first_broken_block == NULL) {\n-          first_broken_block = pp;\n-        }\n-        num_broken_blocks ++;\n-      }\n-      p += pp->_word_size;\n-    }\n-    \/\/ After examining all blocks in a chunk, assert if any of those blocks\n-    \/\/ was found to be corrupted.\n-    if (first_broken_block != NULL) {\n-      assert(false, \"Corrupt block: found at least %d corrupt metaspace block(s) - \"\n-             \"first corrupted block at \" PTR_FORMAT \".\",\n-             num_broken_blocks, p2i(first_broken_block));\n-    }\n+  for (const Fence* f = _first_fence; f != NULL; f = f->next()) {\n+    f->verify();\n","filename":"src\/hotspot\/share\/memory\/metaspace\/metaspaceArena.cpp","additions":43,"deletions":44,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -110,0 +110,18 @@\n+#ifdef ASSERT\n+  \/\/ Allocation guards: When active, arena allocations are interleaved with\n+  \/\/  fence allocations. An overwritten fence indicates a buffer overrun in either\n+  \/\/  the preceding or the following block.\n+  class Fence {\n+    static const uintx EyeCatcher =\n+      NOT_LP64(0x77698465) LP64_ONLY(0x7769846577698465ULL); \/\/ \"META\" resp \"METAMETA\"\n+    const uintx _eye1;\n+    const Fence* const _next;\n+    const uintx _eye2;\n+  public:\n+    Fence(const Fence* next) : _eye1(EyeCatcher), _next(next), _eye2(EyeCatcher) {}\n+    const Fence* next() const { return _next; }\n+    void verify() const;\n+  };\n+  const Fence* _first_fence;\n+#endif \/\/ ASSERT\n+\n@@ -141,0 +159,3 @@\n+  \/\/ Allocate from the arena proper, once dictionary allocations and fencing are sorted out.\n+  MetaWord* allocate_inner(size_t word_size);\n+\n","filename":"src\/hotspot\/share\/memory\/metaspace\/metaspaceArena.hpp","additions":21,"deletions":0,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-#include \"memory\/metaspace\/allocationGuard.hpp\"\n@@ -185,6 +184,0 @@\n-  \/\/ If we guard allocations, we need additional space for a prefix.\n-#ifdef ASSERT\n-  if (Settings::use_allocation_guard()) {\n-    byte_size += align_up(prefix_size(), AllocationAlignmentByteSize);\n-  }\n-#endif\n","filename":"src\/hotspot\/share\/memory\/metaspace\/metaspaceCommon.cpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -87,5 +87,0 @@\n-\n-  \/\/ We also switch it off automatically if we use allocation guards. This is to keep prefix handling in MetaspaceArena simple.\n-  if (_use_allocation_guard) {\n-    _handle_deallocations = false;\n-  }\n","filename":"src\/hotspot\/share\/memory\/metaspace\/metaspaceSettings.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-TEST_VM_ASSERT_MSG(metaspace, test_overwriter, \".*failed: Corrupt block\") {\n+TEST_VM_ASSERT_MSG(metaspace, test_overwriter, \".*Metaspace corruption.*\") {\n@@ -53,1 +53,1 @@\n-    \/\/  should corrupt the eyecatcher at the start of the second block.\n+    \/\/  should corrupt the fence between the two blocks.\n@@ -62,1 +62,0 @@\n-    tty->print_cr(\"Death test, please ignore the following \\\"Corrupt block\\\" printout.\");\n@@ -65,1 +64,1 @@\n-    assert(false, \"Corrupt block fake message to satisfy tests\");\n+    assert(false, \"Metaspace corruption - please ignore this, fake message to satisfy tests\");\n","filename":"test\/hotspot\/gtest\/metaspace\/test_allocationGuard.cpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-  \/\/ Make sure we can allocate what we promise to allocate\n+  \/\/ Make sure we can allocate what we promise to allocate...\n@@ -63,0 +63,1 @@\n+  \/\/ And also, successfully deallocate it.\n","filename":"test\/hotspot\/gtest\/metaspace\/test_metaspace_misc.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"memory\/metaspace\/metaspaceSettings.hpp\"\n@@ -114,0 +115,1 @@\n+    \/\/ - if +MetaspaceGuardAllocations, guard costs\n@@ -120,1 +122,2 @@\n-    const size_t max_word_overhead_per_alloc = 4;\n+    const size_t max_word_overhead_per_alloc =\n+        4 + (metaspace::Settings::use_allocation_guard() ? 4 : 0);\n","filename":"test\/hotspot\/gtest\/metaspace\/test_metaspacearena_stress.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"}]}