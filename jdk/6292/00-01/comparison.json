{"files":[{"patch":"@@ -34,0 +34,2 @@\n+import java.util.ArrayList;\n+import java.util.List;\n@@ -1383,1 +1385,1 @@\n-            System.err.println(Thread.currentThread().name + \" Stack trace\");\n+            List<StackTraceElement> stes = new ArrayList<>();\n@@ -1387,1 +1389,1 @@\n-                    System.err.println(\"\\tat \" + stackFrame.toStackTraceElement());\n+                    stes.add(stackFrame.toStackTraceElement());\n@@ -1390,0 +1392,6 @@\n+            synchronized (System.err) {\n+                System.err.println(Thread.currentThread().name + \" Stack trace\");\n+                for (StackTraceElement ste : stes) {\n+                    System.err.println(\"\\tat \" + ste);\n+                }\n+            }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Thread.java","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -25,2 +25,2 @@\n-import org.testng.annotations.AfterTest;\n-import org.testng.annotations.BeforeTest;\n+import org.testng.annotations.AfterMethod;\n+import org.testng.annotations.BeforeMethod;\n@@ -32,0 +32,9 @@\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.atomic.AtomicInteger;\n@@ -46,2 +55,2 @@\n-    @BeforeTest\n-    public void beforeTest() {\n+    @BeforeMethod\n+    public void beforeEachTest() {\n@@ -53,2 +62,2 @@\n-    @AfterTest\n-    public void afterTest() {\n+    @AfterMethod\n+    public void afterEachTest() {\n@@ -74,1 +83,1 @@\n-            \/\/ we don't do additional line by line checks of the stacktrace, because the System.err\n+            \/\/ we don't do additional line by line checks of the stacktrace because the System.err\n@@ -82,1 +91,91 @@\n-        \/\/ We only verify the stacktrace starting with this current test method's stackframe. We\n+        assertStackTrace(lines, 1);\n+    }\n+\n+    \/**\n+     * Launches multiple threads, each of which initiate a call tree which finally\n+     * ends up calling Thread.dumpStack(). The stacktrace generated in each thread is then verified\n+     * to match the expected call stack.\n+     *\/\n+    @Test\n+    public void testMultiThreadDumpStack() throws Exception {\n+        int numThreads = 5;\n+        String threadNamePrefix = \"test-dump-stack-\";\n+        ExecutorService execService = Executors.newFixedThreadPool(numThreads, new ThreadFactory() {\n+            private final AtomicInteger id = new AtomicInteger();\n+\n+            @Override\n+            public Thread newThread(final Runnable r) {\n+                Thread t = new Thread(r);\n+                t.setName(threadNamePrefix + id.incrementAndGet());\n+                return t;\n+            }\n+        });\n+        try {\n+            CountDownLatch taskTriggerLatch = new CountDownLatch(numThreads);\n+            List<Future<Void>> results = new ArrayList<>();\n+            for (int i = 0; i < numThreads; i++) {\n+                results.add(execService.submit(new Callable<Void>() {\n+                    @Override\n+                    public Void call() throws Exception {\n+                        \/\/ let the other tasks know we are ready to trigger our work\n+                        taskTriggerLatch.countDown();\n+                        \/\/ wait for the other task to let us know they are ready to trigger their work too\n+                        taskTriggerLatch.await();\n+                        triggerDumpStackCall();\n+                        return null;\n+                    }\n+                }));\n+            }\n+            \/\/ wait for completion of each task\n+            for (int i = 0; i < numThreads; i++) {\n+                results.get(i).get();\n+            }\n+        } finally {\n+            execService.shutdown();\n+        }\n+        \/\/ capture the generated stacktrace in System.err\n+        String dumpStackOutput = switchedSysErrOS.toString(Charset.defaultCharset());\n+        System.out.println(\"Thread.dumpStack() across multiple threads generated following output:\\n\" + dumpStackOutput);\n+        Assert.assertFalse(dumpStackOutput.isEmpty(), \"System.err content is empty\");\n+        if (System.getProperty(\"java.security.debug\") != null\n+                && System.getProperty(\"java.security.debug\").contains(\"stack\")) {\n+            \/\/ in the case where java.security.debug system property contains \"stack\" as a value,\n+            \/\/ we don't do additional line by line checks of the stacktrace because the System.err\n+            \/\/ will be polluted with a lot of other stacktraces from within the security layer.\n+            \/\/ As long as the Thread.dumpStack() call from within this test method succeeds without\n+            \/\/ any exceptions, we consider this test as passed.\n+            return;\n+        }\n+        \/\/ split by lines\n+        String[] lines = dumpStackOutput.split(System.lineSeparator());\n+        for (int i = 0; i < numThreads; i++) {\n+            String threadDumpFirstLine = threadNamePrefix + (i + 1) + \" Stack trace\";\n+            \/\/ find the first line of each thread's stack\n+            int lineIndex = findMatchingLine(lines, threadDumpFirstLine);\n+            Assert.assertNotEquals(lineIndex, -1, \"\\\"\" + threadDumpFirstLine\n+                    + \"\\\" missing in System.err content\");\n+            \/\/ starting the next line we expect the stacktrace\n+            assertStackTrace(lines, lineIndex + 1);\n+        }\n+    }\n+\n+    \/**\n+     * Returns the index from the \"lines\" array if that line equals the expectedContent.\n+     * Else returns -1.\n+     *\/\n+    private static int findMatchingLine(String[] lines, String expectedContent) {\n+        for (int i = 0; i < lines.length; i++) {\n+            if (lines[i].equals(expectedContent)) {\n+                return i;\n+            }\n+        }\n+        return -1;\n+    }\n+\n+    \/**\n+     * Verifies that the {@code lines} contains the expected stacktrace element lines.\n+     * The {@code firstLineIndex} represents the index in the lines array from where the\n+     * verification should be started\n+     *\/\n+    private void assertStackTrace(String[] lines, int firstLineIndex) {\n+        \/\/ We only verify the stacktrace starting with this current test's stackframe. We\n@@ -86,7 +185,14 @@\n-        Assert.assertTrue(lines[1].startsWith(\"\\tat java.base\/java.lang.Thread.dumpStack(Thread.java:\"));\n-        Assert.assertTrue(lines[2].startsWith(\"\\tat DumpStackTest$Parent.doSomething(DumpStackTest.java:\"));\n-        Assert.assertTrue(lines[3].startsWith(\"\\tat DumpStackTest.c(DumpStackTest.java:\"));\n-        Assert.assertTrue(lines[4].startsWith(\"\\tat DumpStackTest.b(DumpStackTest.java:\"));\n-        Assert.assertTrue(lines[5].startsWith(\"\\tat DumpStackTest.a(DumpStackTest.java:\"));\n-        Assert.assertTrue(lines[6].startsWith(\"\\tat DumpStackTest.triggerDumpStackCall(DumpStackTest.java:\"));\n-        Assert.assertTrue(lines[7].startsWith(\"\\tat DumpStackTest.testDumpStack(DumpStackTest.java:\"));\n+        \/\/ Each thread stack trace will be of the form:\n+        \/\/ <thread-name> Stack trace\n+        \/\/\tat java.base\/java.lang.Thread.dumpStack(Thread.java:xxx)\n+        \/\/\tat DumpStackTest$Parent.doSomething(DumpStackTest.java:xxx)\n+        \/\/\tat DumpStackTest.c(DumpStackTest.java:xxx)\n+        \/\/\tat DumpStackTest.b(DumpStackTest.java:xxx)\n+        \/\/\tat DumpStackTest.a(DumpStackTest.java:xxx)\n+        \/\/\tat DumpStackTest.triggerDumpStackCall(DumpStackTest.java:xxx)\n+        Assert.assertTrue(lines[firstLineIndex].startsWith(\"\\tat java.base\/java.lang.Thread.dumpStack(Thread.java:\"));\n+        Assert.assertTrue(lines[firstLineIndex + 1].startsWith(\"\\tat DumpStackTest$Parent.doSomething(DumpStackTest.java:\"));\n+        Assert.assertTrue(lines[firstLineIndex + 2].startsWith(\"\\tat DumpStackTest.c(DumpStackTest.java:\"));\n+        Assert.assertTrue(lines[firstLineIndex + 3].startsWith(\"\\tat DumpStackTest.b(DumpStackTest.java:\"));\n+        Assert.assertTrue(lines[firstLineIndex + 4].startsWith(\"\\tat DumpStackTest.a(DumpStackTest.java:\"));\n+        Assert.assertTrue(lines[firstLineIndex + 5].startsWith(\"\\tat DumpStackTest.triggerDumpStackCall(DumpStackTest.java:\"));\n","filename":"test\/jdk\/java\/lang\/Thread\/DumpStackTest.java","additions":121,"deletions":15,"binary":false,"changes":136,"status":"modified"},{"patch":"@@ -32,0 +32,2 @@\n+    \/\/ test calls ExecutorService.shutdown()\n+    permission java.lang.RuntimePermission \"modifyThread\";\n","filename":"test\/jdk\/java\/lang\/Thread\/dump-stack-test.policy","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"}]}