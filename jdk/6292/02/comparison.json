{"files":[{"patch":"@@ -34,0 +34,2 @@\n+import java.util.ArrayList;\n+import java.util.List;\n@@ -40,0 +42,1 @@\n+import java.util.function.Consumer;\n@@ -1380,1 +1383,22 @@\n-        new Exception(\"Stack trace\").printStackTrace();\n+        var walker = StackWalker.getInstance();\n+        if (walker != null) {\n+            List<StackTraceElement> stes = new ArrayList<>();\n+            walker.forEach(new Consumer<StackWalker.StackFrame>() {\n+                @Override\n+                public void accept(final StackWalker.StackFrame stackFrame) {\n+                    stes.add(stackFrame.toStackTraceElement());\n+                }\n+            });\n+            synchronized (System.err) {\n+                System.err.println(Thread.currentThread().name + \" Stack trace\");\n+                for (StackTraceElement ste : stes) {\n+                    System.err.println(\"\\tat \" + ste);\n+                }\n+            }\n+            return;\n+        }\n+        \/\/ Thread.dumpStack() could be called during the static initialization of\n+        \/\/ the StackWalker itself, which means that the StackWalker isn't usable\n+        \/\/ at this point in time. So we fallback to creating a Exception instance\n+        \/\/ and printing its stacktrace\n+        new Exception(Thread.currentThread().name + \" Stack trace\").printStackTrace();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Thread.java","additions":25,"deletions":1,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -0,0 +1,226 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.Assert;\n+import org.testng.annotations.AfterMethod;\n+import org.testng.annotations.BeforeMethod;\n+import org.testng.annotations.Test;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.PrintStream;\n+import java.nio.charset.Charset;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+\/**\n+ * @test\n+ * @bug 8153133\n+ * @summary Test Thread.dumpStack()\n+ * @run testng\/othervm DumpStackTest\n+ * @run testng\/othervm -Djava.security.manager -Djava.security.policy=${test.src}\/dump-stack-test.policy DumpStackTest\n+ * @run testng\/othervm -Djava.security.debug=access,stack -Djava.security.manager -Djava.security.policy=${test.src}\/dump-stack-test.policy DumpStackTest\n+ *\/\n+public class DumpStackTest {\n+\n+    private PrintStream originalSysErr;\n+    private ByteArrayOutputStream switchedSysErrOS;\n+\n+    @BeforeMethod\n+    public void beforeEachTest() {\n+        originalSysErr = System.err;\n+        switchedSysErrOS = new ByteArrayOutputStream();\n+        System.setErr(new PrintStream(switchedSysErrOS));\n+    }\n+\n+    @AfterMethod\n+    public void afterEachTest() {\n+        if (originalSysErr != null) {\n+            System.setErr(originalSysErr);\n+        }\n+    }\n+\n+    \/**\n+     * Initiates a call tree which finally ends up calling Thread.dumpStack(). The stacktrace is then\n+     * verified to match the expected call stack.\n+     *\/\n+    @Test\n+    public void testDumpStack() {\n+        triggerDumpStackCall();\n+        \/\/ capture the generated stacktrace in System.err\n+        String dumpStackOutput = switchedSysErrOS.toString(Charset.defaultCharset());\n+        System.out.println(\"Thread.dumpStack() generated following output:\\n\" + dumpStackOutput);\n+        Assert.assertFalse(dumpStackOutput.isEmpty(), \"System.err content is empty\");\n+        if (System.getProperty(\"java.security.debug\") != null\n+                && System.getProperty(\"java.security.debug\").contains(\"stack\")) {\n+            \/\/ in the case where java.security.debug system property contains \"stack\" as a value,\n+            \/\/ we don't do additional line by line checks of the stacktrace because the System.err\n+            \/\/ will be polluted with a lot of other stacktraces from within the security layer.\n+            \/\/ As long as the Thread.dumpStack() call from within this test method succeeds without\n+            \/\/ any exceptions, we consider this test as passed.\n+            return;\n+        }\n+        \/\/ split by lines\n+        String[] lines = dumpStackOutput.split(System.lineSeparator());\n+        assertStackTrace(lines, 1);\n+    }\n+\n+    \/**\n+     * Launches multiple threads, each of which initiate a call tree which finally\n+     * ends up calling Thread.dumpStack(). The stacktrace generated in each thread is then verified\n+     * to match the expected call stack.\n+     *\/\n+    @Test\n+    public void testMultiThreadDumpStack() throws Exception {\n+        int numThreads = 5;\n+        String threadNamePrefix = \"test-dump-stack-\";\n+        ExecutorService execService = Executors.newFixedThreadPool(numThreads, new ThreadFactory() {\n+            private final AtomicInteger id = new AtomicInteger();\n+\n+            @Override\n+            public Thread newThread(final Runnable r) {\n+                Thread t = new Thread(r);\n+                t.setName(threadNamePrefix + id.incrementAndGet());\n+                return t;\n+            }\n+        });\n+        try {\n+            CountDownLatch taskTriggerLatch = new CountDownLatch(numThreads);\n+            List<Future<Void>> results = new ArrayList<>();\n+            for (int i = 0; i < numThreads; i++) {\n+                results.add(execService.submit(new Callable<Void>() {\n+                    @Override\n+                    public Void call() throws Exception {\n+                        \/\/ let the other tasks know we are ready to trigger our work\n+                        taskTriggerLatch.countDown();\n+                        \/\/ wait for the other task to let us know they are ready to trigger their work too\n+                        taskTriggerLatch.await();\n+                        triggerDumpStackCall();\n+                        return null;\n+                    }\n+                }));\n+            }\n+            \/\/ wait for completion of each task\n+            for (int i = 0; i < numThreads; i++) {\n+                results.get(i).get();\n+            }\n+        } finally {\n+            execService.shutdown();\n+        }\n+        \/\/ capture the generated stacktrace in System.err\n+        String dumpStackOutput = switchedSysErrOS.toString(Charset.defaultCharset());\n+        System.out.println(\"Thread.dumpStack() across multiple threads generated following output:\\n\" + dumpStackOutput);\n+        Assert.assertFalse(dumpStackOutput.isEmpty(), \"System.err content is empty\");\n+        if (System.getProperty(\"java.security.debug\") != null\n+                && System.getProperty(\"java.security.debug\").contains(\"stack\")) {\n+            \/\/ in the case where java.security.debug system property contains \"stack\" as a value,\n+            \/\/ we don't do additional line by line checks of the stacktrace because the System.err\n+            \/\/ will be polluted with a lot of other stacktraces from within the security layer.\n+            \/\/ As long as the Thread.dumpStack() call from within this test method succeeds without\n+            \/\/ any exceptions, we consider this test as passed.\n+            return;\n+        }\n+        \/\/ split by lines\n+        String[] lines = dumpStackOutput.split(System.lineSeparator());\n+        for (int i = 0; i < numThreads; i++) {\n+            String threadDumpFirstLine = threadNamePrefix + (i + 1) + \" Stack trace\";\n+            \/\/ find the first line of each thread's stack\n+            int lineIndex = findMatchingLine(lines, threadDumpFirstLine);\n+            Assert.assertNotEquals(lineIndex, -1, \"\\\"\" + threadDumpFirstLine\n+                    + \"\\\" missing in System.err content\");\n+            \/\/ starting the next line we expect the stacktrace\n+            assertStackTrace(lines, lineIndex + 1);\n+        }\n+    }\n+\n+    \/**\n+     * Returns the index from the \"lines\" array if that line equals the expectedContent.\n+     * Else returns -1.\n+     *\/\n+    private static int findMatchingLine(String[] lines, String expectedContent) {\n+        for (int i = 0; i < lines.length; i++) {\n+            if (lines[i].equals(expectedContent)) {\n+                return i;\n+            }\n+        }\n+        return -1;\n+    }\n+\n+    \/**\n+     * Verifies that the {@code lines} contains the expected stacktrace element lines.\n+     * The {@code firstLineIndex} represents the index in the lines array from where the\n+     * verification should be started\n+     *\/\n+    private void assertStackTrace(String[] lines, int firstLineIndex) {\n+        \/\/ We only verify the stacktrace starting with this current test's stackframe. We\n+        \/\/ aren't interested in anything before this stackframe since those frames belong to the\n+        \/\/ test infrastructure framework and can potentially change.\n+        \/\/ In these verifications we ignore the line numbers in the stacktrace.\n+        \/\/ Each thread stack trace will be of the form:\n+        \/\/ <thread-name> Stack trace\n+        \/\/  at java.base\/java.lang.Thread.dumpStack(Thread.java:xxx)\n+        \/\/  at DumpStackTest$Parent.doSomething(DumpStackTest.java:xxx)\n+        \/\/  at DumpStackTest.c(DumpStackTest.java:xxx)\n+        \/\/  at DumpStackTest.b(DumpStackTest.java:xxx)\n+        \/\/  at DumpStackTest.a(DumpStackTest.java:xxx)\n+        \/\/  at DumpStackTest.triggerDumpStackCall(DumpStackTest.java:xxx)\n+        Assert.assertTrue(lines[firstLineIndex].startsWith(\"\\tat java.base\/java.lang.Thread.dumpStack(Thread.java:\"));\n+        Assert.assertTrue(lines[firstLineIndex + 1].startsWith(\"\\tat DumpStackTest$Parent.doSomething(DumpStackTest.java:\"));\n+        Assert.assertTrue(lines[firstLineIndex + 2].startsWith(\"\\tat DumpStackTest.c(DumpStackTest.java:\"));\n+        Assert.assertTrue(lines[firstLineIndex + 3].startsWith(\"\\tat DumpStackTest.b(DumpStackTest.java:\"));\n+        Assert.assertTrue(lines[firstLineIndex + 4].startsWith(\"\\tat DumpStackTest.a(DumpStackTest.java:\"));\n+        Assert.assertTrue(lines[firstLineIndex + 5].startsWith(\"\\tat DumpStackTest.triggerDumpStackCall(DumpStackTest.java:\"));\n+    }\n+\n+    private void triggerDumpStackCall() {\n+        a();\n+    }\n+\n+    private void a() {\n+        b();\n+    }\n+\n+    private void b() {\n+        c();\n+    }\n+\n+    private void c() {\n+        new Child().doSomething();\n+    }\n+\n+    private static class Parent {\n+\n+        protected void doSomething() {\n+            Thread.dumpStack();\n+        }\n+    }\n+\n+    private static class Child extends Parent {\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/Thread\/DumpStackTest.java","additions":226,"deletions":0,"binary":false,"changes":226,"status":"added"},{"patch":"@@ -0,0 +1,36 @@\n+\/\/\n+\/\/ Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+\/\/ DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+\/\/\n+\/\/ This code is free software; you can redistribute it and\/or modify it\n+\/\/ under the terms of the GNU General Public License version 2 only, as\n+\/\/ published by the Free Software Foundation.\n+\/\/\n+\/\/ This code is distributed in the hope that it will be useful, but WITHOUT\n+\/\/ ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+\/\/ FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+\/\/ version 2 for more details (a copy is included in the LICENSE file that\n+\/\/ accompanied this code).\n+\/\/\n+\/\/ You should have received a copy of the GNU General Public License version\n+\/\/ 2 along with this work; if not, write to the Free Software Foundation,\n+\/\/ Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+\/\/\n+\/\/ Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+\/\/ or visit www.oracle.com if you need additional information or have any\n+\/\/ questions.\n+\/\/\n+\n+grant {\n+    \/\/ common permission necessary for test infrastructure\n+    permission java.io.FilePermission \"<<ALL FILES>>\", \"read,write\";\n+    permission java.util.PropertyPermission \"*\", \"read\";\n+    permission java.lang.RuntimePermission \"accessDeclaredMembers\";\n+    permission java.lang.reflect.ReflectPermission \"suppressAccessChecks\";\n+    \/\/ the test switches the System.err stream\n+    permission java.lang.RuntimePermission \"setIO\";\n+    \/\/ test calls ExecutorService.shutdown()\n+    permission java.lang.RuntimePermission \"modifyThread\";\n+};\n+\n+\n","filename":"test\/jdk\/java\/lang\/Thread\/dump-stack-test.policy","additions":36,"deletions":0,"binary":false,"changes":36,"status":"added"}]}