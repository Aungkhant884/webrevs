{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,1 +51,0 @@\n-import sun.util.logging.PlatformLogger;\n@@ -293,16 +292,16 @@\n-        FileReader fr = null;\n-        try {\n-            if (fontsDotDir.canRead()) {\n-                fr = new FileReader(fontsDotDir);\n-                BufferedReader br = new BufferedReader(fr, 8192);\n-                StreamTokenizer st = new StreamTokenizer(br);\n-                st.eolIsSignificant(true);\n-                int ttype = st.nextToken();\n-                if (ttype == StreamTokenizer.TT_NUMBER) {\n-                    int numEntries = (int)st.nval;\n-                    ttype = st.nextToken();\n-                    if (ttype == StreamTokenizer.TT_EOL) {\n-                        st.resetSyntax();\n-                        st.wordChars(32, 127);\n-                        st.wordChars(128 + 32, 255);\n-                        st.whitespaceChars(0, 31);\n+        if (!fontsDotDir.canRead()) {\n+            return;\n+        }\n+        try (FileReader fr = new FileReader(fontsDotDir)) {\n+            BufferedReader br = new BufferedReader(fr, 8192);\n+            StreamTokenizer st = new StreamTokenizer(br);\n+            st.eolIsSignificant(true);\n+            int ttype = st.nextToken();\n+            if (ttype == StreamTokenizer.TT_NUMBER) {\n+                int numEntries = (int)st.nval;\n+                ttype = st.nextToken();\n+                if (ttype == StreamTokenizer.TT_EOL) {\n+                    st.resetSyntax();\n+                    st.wordChars(32, 127);\n+                    st.wordChars(128 + 32, 255);\n+                    st.whitespaceChars(0, 31);\n@@ -310,1 +309,21 @@\n-                        for (int i=0; i < numEntries; i++) {\n+                    for (int i=0; i < numEntries; i++) {\n+                        ttype = st.nextToken();\n+                        if (ttype == StreamTokenizer.TT_EOF) {\n+                            break;\n+                        }\n+                        if (ttype != StreamTokenizer.TT_WORD) {\n+                            break;\n+                        }\n+                        int breakPos = st.sval.indexOf(' ');\n+                        if (breakPos <= 0) {\n+                            \/* On TurboLinux 8.0 a fonts.dir file had\n+                             * a line with integer value \"24\" which\n+                             * appeared to be the number of remaining\n+                             * entries in the file. This didn't add to\n+                             * the value on the first line of the file.\n+                             * Seemed like XFree86 didn't like this line\n+                             * much either. It failed to parse the file.\n+                             * Ignore lines like this completely, and\n+                             * don't let them count as an entry.\n+                             *\/\n+                            numEntries++;\n@@ -312,4 +331,1 @@\n-                            if (ttype == StreamTokenizer.TT_EOF) {\n-                                break;\n-                            }\n-                            if (ttype != StreamTokenizer.TT_WORD) {\n+                            if (ttype != StreamTokenizer.TT_EOL) {\n@@ -318,17 +334,0 @@\n-                            int breakPos = st.sval.indexOf(' ');\n-                            if (breakPos <= 0) {\n-                                \/* On TurboLinux 8.0 a fonts.dir file had\n-                                 * a line with integer value \"24\" which\n-                                 * appeared to be the number of remaining\n-                                 * entries in the file. This didn't add to\n-                                 * the value on the first line of the file.\n-                                 * Seemed like XFree86 didn't like this line\n-                                 * much either. It failed to parse the file.\n-                                 * Ignore lines like this completely, and\n-                                 * don't let them count as an entry.\n-                                 *\/\n-                                numEntries++;\n-                                ttype = st.nextToken();\n-                                if (ttype != StreamTokenizer.TT_EOL) {\n-                                    break;\n-                                }\n@@ -336,1 +335,12 @@\n-                                continue;\n+                            continue;\n+                        }\n+                        if (st.sval.charAt(0) == '!') {\n+                            \/* TurboLinux 8.0 comment line: ignore.\n+                             * can't use st.commentChar('!') to just\n+                             * skip because this line mustn't count\n+                             * against numEntries.\n+                             *\/\n+                            numEntries++;\n+                            ttype = st.nextToken();\n+                            if (ttype != StreamTokenizer.TT_EOL) {\n+                                break;\n@@ -338,11 +348,11 @@\n-                            if (st.sval.charAt(0) == '!') {\n-                                \/* TurboLinux 8.0 comment line: ignore.\n-                                 * can't use st.commentChar('!') to just\n-                                 * skip because this line mustn't count\n-                                 * against numEntries.\n-                                 *\/\n-                                numEntries++;\n-                                ttype = st.nextToken();\n-                                if (ttype != StreamTokenizer.TT_EOL) {\n-                                    break;\n-                                }\n+                            continue;\n+                        }\n+                        String fileName = st.sval.substring(0, breakPos);\n+                        \/* TurboLinux 8.0 uses some additional syntax to\n+                         * indicate algorithmic styling values.\n+                         * Ignore ':' separated files at the beginning\n+                         * of the fileName\n+                         *\/\n+                        int lastColon = fileName.lastIndexOf(':');\n+                        if (lastColon > 0) {\n+                            if (lastColon+1 >= fileName.length()) {\n@@ -351,16 +361,5 @@\n-                            String fileName = st.sval.substring(0, breakPos);\n-                            \/* TurboLinux 8.0 uses some additional syntax to\n-                             * indicate algorithmic styling values.\n-                             * Ignore ':' separated files at the beginning\n-                             * of the fileName\n-                             *\/\n-                            int lastColon = fileName.lastIndexOf(':');\n-                            if (lastColon > 0) {\n-                                if (lastColon+1 >= fileName.length()) {\n-                                    continue;\n-                                }\n-                                fileName = fileName.substring(lastColon+1);\n-                            }\n-                            String fontPart = st.sval.substring(breakPos+1);\n-                            String fontID = specificFontIDForName(fontPart);\n-                            String sVal = fontNameMap.get(fontID);\n+                            fileName = fileName.substring(lastColon+1);\n+                        }\n+                        String fontPart = st.sval.substring(breakPos+1);\n+                        String fontID = specificFontIDForName(fontPart);\n+                        String sVal = fontNameMap.get(fontID);\n@@ -368,23 +367,18 @@\n-                            if (FontUtilities.debugFonts()) {\n-                                FontUtilities.logInfo(\"file=\" + fileName +\n-                                            \" xlfd=\" + fontPart);\n-                                FontUtilities.logInfo(\"fontID=\" + fontID +\n-                                            \" sVal=\" + sVal);\n-                            }\n-                            String fullPath = null;\n-                            try {\n-                                File file = new File(path,fileName);\n-                                \/* we may have a resolved symbolic link\n-                                 * this becomes important for an xlfd we\n-                                 * still need to know the location it was\n-                                 * found to update the X server font path\n-                                 * for use by AWT heavyweights - and when 2D\n-                                 * wants to use the native rasteriser.\n-                                 *\/\n-                                if (xFontDirsMap == null) {\n-                                    xFontDirsMap = new HashMap<>();\n-                                }\n-                                xFontDirsMap.put(fontID, path);\n-                                fullPath = file.getCanonicalPath();\n-                            } catch (IOException e) {\n-                                fullPath = path + File.separator + fileName;\n+                        if (FontUtilities.debugFonts()) {\n+                            FontUtilities.logInfo(\"file=\" + fileName +\n+                                        \" xlfd=\" + fontPart);\n+                            FontUtilities.logInfo(\"fontID=\" + fontID +\n+                                        \" sVal=\" + sVal);\n+                        }\n+                        String fullPath;\n+                        try {\n+                            File file = new File(path,fileName);\n+                            \/* we may have a resolved symbolic link\n+                             * this becomes important for an xlfd we\n+                             * still need to know the location it was\n+                             * found to update the X server font path\n+                             * for use by AWT heavyweights - and when 2D\n+                             * wants to use the native rasteriser.\n+                             *\/\n+                            if (xFontDirsMap == null) {\n+                                xFontDirsMap = new HashMap<>();\n@@ -392,1 +386,12 @@\n-                            Vector<String> xVal = xlfdMap.get(fullPath);\n+                            xFontDirsMap.put(fontID, path);\n+                            fullPath = file.getCanonicalPath();\n+                        } catch (IOException e) {\n+                            fullPath = path + File.separator + fileName;\n+                        }\n+                        Vector<String> xVal = xlfdMap.get(fullPath);\n+                        if (FontUtilities.debugFonts()) {\n+                            FontUtilities.logInfo(\"fullPath=\" + fullPath +\n+                                                  \" xVal=\" + xVal);\n+                        }\n+                        if ((xVal == null || !xVal.contains(fontPart)) &&\n+                            (sVal == null) || !sVal.startsWith(\"\/\")) {\n@@ -394,2 +399,2 @@\n-                                FontUtilities.logInfo(\"fullPath=\" + fullPath +\n-                                                      \" xVal=\" + xVal);\n+                                FontUtilities.logInfo(\"Map fontID:\"+fontID +\n+                                                      \"to file:\" + fullPath);\n@@ -397,12 +402,4 @@\n-                            if ((xVal == null || !xVal.contains(fontPart)) &&\n-                                (sVal == null) || !sVal.startsWith(\"\/\")) {\n-                                if (FontUtilities.debugFonts()) {\n-                                    FontUtilities.logInfo(\"Map fontID:\"+fontID +\n-                                                          \"to file:\" + fullPath);\n-                                }\n-                                fontNameMap.put(fontID, fullPath);\n-                                if (xVal == null) {\n-                                    xVal = new Vector<>();\n-                                    xlfdMap.put (fullPath, xVal);\n-                                }\n-                                xVal.add(fontPart);\n+                            fontNameMap.put(fontID, fullPath);\n+                            if (xVal == null) {\n+                                xVal = new Vector<>();\n+                                xlfdMap.put (fullPath, xVal);\n@@ -410,0 +407,2 @@\n+                            xVal.add(fontPart);\n+                        }\n@@ -411,4 +410,3 @@\n-                            ttype = st.nextToken();\n-                            if (ttype != StreamTokenizer.TT_EOL) {\n-                                break;\n-                            }\n+                        ttype = st.nextToken();\n+                        if (ttype != StreamTokenizer.TT_EOL) {\n+                            break;\n@@ -418,9 +416,0 @@\n-                fr.close();\n-            }\n-        } catch (IOException ioe1) {\n-        } finally {\n-            if (fr != null) {\n-                try {\n-                    fr.close();\n-                }  catch (IOException ioe2) {\n-                }\n@@ -428,0 +417,1 @@\n+        } catch (IOException ioe) {\n","filename":"src\/java.desktop\/unix\/classes\/sun\/awt\/X11FontManager.java","additions":109,"deletions":119,"binary":false,"changes":228,"status":"modified"}]}