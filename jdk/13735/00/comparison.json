{"files":[{"patch":"@@ -844,0 +844,3 @@\n+                case ARRAY_CONSTRUCTOR:\n+                    emitArrayConstructor(name);\n+                    continue;\n@@ -895,0 +898,11 @@\n+    void emitArrayConstructor(Name name) {\n+        var componentType = name.function.methodType().returnType().componentType();\n+        var wrapper = Wrapper.forBasicType(componentType);\n+        if (wrapper != Wrapper.OBJECT) {\n+            mv.visitIntInsn(Opcodes.NEWARRAY, arrayTypeCode(wrapper));\n+        } else {\n+            assert isStaticallyNameable(componentType);\n+            mv.visitTypeInsn(Opcodes.ANEWARRAY, getInternalName(componentType));\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/InvokerBytecodeGenerator.java","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -87,1 +87,2 @@\n-            assert(mh.type().parameterType(0) == Object[].class);\n+            assert !arrayClass.componentType().isPrimitive() : arrayClass.getName();\n+            \/* if access != CONSTRUCT *\/ assert(access == ArrayAccess.CONSTRUCT || mh.type().parameterType(0) == Object[].class);\n@@ -92,0 +93,2 @@\n+            \/* if access == CONSTRUCT *\/ assert access != ArrayAccess.CONSTRUCT || mh.type().returnType() == Object.class;\n+\n@@ -95,1 +98,4 @@\n-        mh = makeIntrinsic(mh, ArrayAccess.intrinsic(access));\n+\n+        var intrinsic = ArrayAccess.intrinsic(arrayClass, access);\n+        if (intrinsic != Intrinsic.NONE)\n+            mh = makeIntrinsic(mh, intrinsic);\n@@ -109,1 +115,1 @@\n-        GET, SET, LENGTH;\n+        GET, SET, LENGTH, CONSTRUCT;\n@@ -119,0 +125,1 @@\n+                case CONSTRUCT -> \"createArray\";\n@@ -128,0 +135,1 @@\n+                case CONSTRUCT -> ArrayAccessor.OBJECT_ARRAY_CONSTRUCTOR;\n@@ -137,0 +145,1 @@\n+                case CONSTRUCT -> ArrayAccessor.CONSTRUCTOR_INDEX;\n@@ -141,1 +150,1 @@\n-        static Intrinsic intrinsic(ArrayAccess a) {\n+        static Intrinsic intrinsic(Class<?> arrayClass, ArrayAccess a) {\n@@ -146,0 +155,2 @@\n+                case CONSTRUCT -> InvokerBytecodeGenerator.isStaticallyNameable(arrayClass)\n+                        ? Intrinsic.ARRAY_CONSTRUCTOR : Intrinsic.NONE;\n@@ -157,1 +168,1 @@\n-        static final int GETTER_INDEX = 0, SETTER_INDEX = 1, LENGTH_INDEX = 2, INDEX_LIMIT = 3;\n+        static final int GETTER_INDEX = 0, SETTER_INDEX = 1, LENGTH_INDEX = 2, CONSTRUCTOR_INDEX = 3, INDEX_LIMIT = 4;\n@@ -165,1 +176,1 @@\n-        static final MethodHandle OBJECT_ARRAY_GETTER, OBJECT_ARRAY_SETTER, OBJECT_ARRAY_LENGTH;\n+        static final MethodHandle OBJECT_ARRAY_GETTER, OBJECT_ARRAY_SETTER, OBJECT_ARRAY_LENGTH, OBJECT_ARRAY_CONSTRUCTOR;\n@@ -171,0 +182,1 @@\n+            cache[CONSTRUCTOR_INDEX] = OBJECT_ARRAY_CONSTRUCTOR = makeIntrinsic(getAccessor(Object[].class, ArrayAccess.CONSTRUCT), Intrinsic.ARRAY_CONSTRUCTOR);\n@@ -175,0 +187,1 @@\n+            assert(InvokerBytecodeGenerator.isStaticallyInvocable(ArrayAccessor.OBJECT_ARRAY_CONSTRUCTOR.internalMemberName()));\n@@ -207,3 +220,12 @@\n-        static String name(Class<?> arrayClass, ArrayAccess access) {\n-            Class<?> elemClass = arrayClass.getComponentType();\n-            if (elemClass == null)  throw newIllegalArgumentException(\"not an array\", arrayClass);\n+        static int[]     createArrayI(int len)                    { return new int[len]; }\n+        static long[]    createArrayJ(int len)                    { return new long[len]; }\n+        static float[]   createArrayF(int len)                    { return new float[len]; }\n+        static double[]  createArrayD(int len)                    { return new double[len]; }\n+        static boolean[] createArrayZ(int len)                    { return new boolean[len]; }\n+        static byte[]    createArrayB(int len)                    { return new byte[len]; }\n+        static short[]   createArrayS(int len)                    { return new short[len]; }\n+        static char[]    createArrayC(int len)                    { return new char[len]; }\n+        static Object[]  createArrayL(int len)                    { return new Object[len]; }\n+\n+        private static String name(Class<?> elemClass, ArrayAccess access) {\n+            assert access != ArrayAccess.CONSTRUCT || elemClass.isPrimitive() || elemClass == Object.class;\n@@ -212,2 +234,2 @@\n-        static MethodType type(Class<?> arrayClass, ArrayAccess access) {\n-            Class<?> elemClass = arrayClass.getComponentType();\n+\n+        private static MethodType type(Class<?> elemClass, Class<?> arrayClass, ArrayAccess access) {\n@@ -216,0 +238,1 @@\n+                assert access != ArrayAccess.CONSTRUCT || arrayArgClass == Object[].class;\n@@ -223,0 +246,1 @@\n+                case CONSTRUCT -> MethodType.methodType(arrayArgClass, int.class);\n@@ -232,0 +256,1 @@\n+                case CONSTRUCT -> MethodType.methodType(arrayClass, int.class);\n@@ -236,2 +261,10 @@\n-            String     name = name(arrayClass, access);\n-            MethodType type = type(arrayClass, access);\n+            var componentType = arrayClass.componentType();\n+            if (componentType == null)\n+                throw newIllegalArgumentException(\"not an array\", arrayClass);\n+\n+            if (access == ArrayAccess.CONSTRUCT && !componentType.isPrimitive() && componentType != Object.class) {\n+                return getReferenceArrayConstructor(componentType);\n+            }\n+\n+            String     name = name(componentType, access);\n+            MethodType type = type(componentType, arrayClass, access);\n@@ -244,0 +277,7 @@\n+\n+        static MethodHandle getReferenceArrayConstructor(Class<?> componentType) {\n+            \/\/ Better alternative to spinning methods with componentType as constants\n+            \/\/ and avoids hidden class issue\n+            return MethodHandleImpl.getConstantHandle(MethodHandleImpl.MH_Array_newInstance).\n+                    bindTo(componentType);\n+        }\n@@ -1360,0 +1400,1 @@\n+        ARRAY_CONSTRUCTOR, \/\/ requires component type to be in boot class loader\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleImpl.java","additions":54,"deletions":13,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -4329,6 +4329,1 @@\n-        if (!arrayClass.isArray()) {\n-            throw newIllegalArgumentException(\"not an array class: \" + arrayClass.getName());\n-        }\n-        MethodHandle ani = MethodHandleImpl.getConstantHandle(MethodHandleImpl.MH_Array_newInstance).\n-                bindTo(arrayClass.getComponentType());\n-        return ani.asType(ani.type().changeReturnType(arrayClass));\n+        return MethodHandleImpl.makeArrayElementAccessor(arrayClass, MethodHandleImpl.ArrayAccess.CONSTRUCT);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandles.java","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -63,1 +63,1 @@\n-                {String.class, IllegalArgumentException.class, \"not an array class: java.lang.String\"},\n+                {String.class, IllegalArgumentException.class, \"not an array: class java.lang.String\"},\n","filename":"test\/jdk\/java\/lang\/invoke\/ArrayConstructorTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,100 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang.invoke;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.util.concurrent.TimeUnit;\n+\n+\/**\n+ * Benchmark assessing the performance of {@link MethodHandles#arrayConstructor}\n+ * return value's invocation.\n+ *\/\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Thread)\n+@Warmup(iterations = 5, time = 1, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 5, time = 1, timeUnit = TimeUnit.SECONDS)\n+@Fork(1)\n+public class MethodHandlesArrayConstructorCall {\n+\n+    \/*\n+     * Implementation notes:\n+     *   - tests\n+     *   - create arrays of different sizes, to emulate collector scenarios\n+     *   - there are 4 kinds of code paths: primitive arrays, Object[], statically\n+     *     invocable, non-statically invocable, and they may present different\n+     *\/\n+\n+    private static final MethodHandle MH_STRING;\n+    private static final MethodHandle MH_NON_INVOCABLE;\n+    private MethodHandle mh;\n+    private MethodHandle mhNonInvocable;\n+\n+    static {\n+        MH_STRING = MethodHandles.arrayConstructor(String[].class);\n+        MH_NON_INVOCABLE = MethodHandles.arrayConstructor(MethodHandlesArrayConstructorCall[].class);\n+    }\n+\n+    @Setup\n+    public void setup() {\n+        mh = MethodHandles.arrayConstructor(String[].class);\n+        mhNonInvocable = MethodHandles.arrayConstructor(MethodHandlesArrayConstructorCall[].class);\n+    }\n+\n+    @Benchmark\n+    public Object baselineConstruct() {\n+        return new String[8];\n+    }\n+\n+    @Benchmark\n+    public Object constantFoldConstruct() throws Throwable {\n+        return (String[]) MH_STRING.invoke(8);\n+    }\n+\n+    @Benchmark\n+    public Object instanceConstruct() throws Throwable {\n+        return (String[]) mh.invoke(8);\n+    }\n+\n+    @Benchmark\n+    public Object constantFoldNonInvocableConstruct() throws Throwable {\n+        return (MethodHandlesArrayConstructorCall[]) MH_NON_INVOCABLE.invoke(8);\n+    }\n+\n+    @Benchmark\n+    public Object instanceNonInvocableConstruct() throws Throwable {\n+        return (MethodHandlesArrayConstructorCall[]) mhNonInvocable.invoke(8);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/invoke\/MethodHandlesArrayConstructorCall.java","additions":100,"deletions":0,"binary":false,"changes":100,"status":"added"},{"patch":"@@ -0,0 +1,66 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang.invoke;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.State;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.util.concurrent.TimeUnit;\n+\n+\/**\n+ * Benchmark assessing the creation performance of {@link MethodHandles#arrayConstructor}\n+ * on first invocation.\n+ *\/\n+@BenchmarkMode(Mode.SingleShotTime)\n+@OutputTimeUnit(TimeUnit.MICROSECONDS)\n+@State(Scope.Benchmark)\n+@Fork(value = 10, warmups = 0)\n+public class MethodHandlesArrayConstructorColdStart {\n+\n+    @Benchmark\n+    public MethodHandle testCreatePrimitive() {\n+        return MethodHandles.arrayConstructor(int[].class);\n+    }\n+\n+    @Benchmark\n+    public MethodHandle testCreateObject() {\n+        return MethodHandles.arrayConstructor(Object[].class);\n+    }\n+\n+    @Benchmark\n+    public MethodHandle testCreateInvocable() {\n+        return MethodHandles.arrayConstructor(String[].class);\n+    }\n+\n+    @Benchmark\n+    public MethodHandle testCreateNonInvocable() {\n+        return MethodHandles.arrayConstructor(MethodHandlesArrayConstructorColdStart[].class);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/invoke\/MethodHandlesArrayConstructorColdStart.java","additions":66,"deletions":0,"binary":false,"changes":66,"status":"added"}]}