{"files":[{"patch":"@@ -48,0 +48,1 @@\n+import jdk.internal.javac.Restricted;\n@@ -328,0 +329,1 @@\n+        @Restricted\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ModuleLayer.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.internal.javac.Restricted;\n@@ -111,0 +112,1 @@\n+    @Restricted\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/AddressLayout.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import jdk.internal.javac.Restricted;\n@@ -531,0 +532,1 @@\n+    @Restricted\n@@ -577,0 +579,1 @@\n+    @Restricted\n@@ -621,0 +624,1 @@\n+    @Restricted\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/Linker.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -53,0 +53,1 @@\n+import jdk.internal.javac.Restricted;\n@@ -610,0 +611,1 @@\n+    @Restricted\n@@ -649,0 +651,1 @@\n+    @Restricted\n@@ -691,0 +694,1 @@\n+    @Restricted\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemorySegment.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import jdk.internal.javac.Restricted;\n@@ -235,0 +236,1 @@\n+    @Restricted\n@@ -267,0 +269,1 @@\n+    @Restricted\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/SymbolLookup.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,39 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.javac;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+\/**\n+ * This annotation is used to mark <em>restricted<\/em> methods in the Java SE API\n+ * (e.g. {@link java.lang.foreign.MemorySegment#reinterpret(long)}).\n+ *\/\n+@Target({ElementType.METHOD})\n+@Retention(RetentionPolicy.RUNTIME)\n+public @interface Restricted {\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/javac\/Restricted.java","additions":39,"deletions":0,"binary":false,"changes":39,"status":"added"},{"patch":"@@ -0,0 +1,168 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @enablePreview\n+ * @requires jdk.foreign.linker != \"UNSUPPORTED\"\n+ * @modules java.base\/jdk.internal.javac\n+ * @modules java.base\/jdk.internal.reflect\n+ * @run testng TestRestricted\n+ *\/\n+\n+import jdk.internal.javac.Restricted;\n+import jdk.internal.reflect.CallerSensitive;\n+import org.testng.annotations.Test;\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.lang.foreign.AddressLayout;\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.Linker;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.SymbolLookup;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodType;\n+import java.lang.module.ModuleReader;\n+import java.lang.module.ModuleReference;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.StringJoiner;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import static org.testng.Assert.assertTrue;\n+import static org.testng.Assert.fail;\n+\n+\/**\n+ * This test checks all methods in java.base to make sure that methods annotated with {@link Restricted} are\n+ * expected restricted methods. Conversely, the test also checks that there is no expected restricted method\n+ * that is not marked with the annotation. For each restricted method, we also check that they are\n+ * marked with the {@link CallerSensitive} annotation.\n+ *\/\n+public class TestRestricted {\n+\n+    record RestrictedMethod(Class<?> owner, String name, MethodType type) {\n+        static RestrictedMethod from(Method method) {\n+            return of(method.getDeclaringClass(), method.getName(), method.getReturnType(), method.getParameterTypes());\n+        }\n+\n+        static RestrictedMethod of(Class<?> owner, String name, Class<?> returnType, Class<?>... paramTypes) {\n+            return new RestrictedMethod(owner, name, MethodType.methodType(returnType, paramTypes));\n+        }\n+    };\n+\n+    static final Set<RestrictedMethod> RESTRICTED_METHODS = Set.of(\n+            RestrictedMethod.of(SymbolLookup.class, \"libraryLookup\", SymbolLookup.class, String.class, Arena.class),\n+            RestrictedMethod.of(SymbolLookup.class, \"libraryLookup\", SymbolLookup.class, Path.class, Arena.class),\n+            RestrictedMethod.of(Linker.class, \"downcallHandle\", MethodHandle.class, FunctionDescriptor.class, Linker.Option[].class),\n+            RestrictedMethod.of(Linker.class, \"downcallHandle\", MethodHandle.class, MemorySegment.class, FunctionDescriptor.class, Linker.Option[].class),\n+            RestrictedMethod.of(Linker.class, \"upcallStub\", MemorySegment.class, MethodHandle.class, FunctionDescriptor.class, Arena.class, Linker.Option[].class),\n+            RestrictedMethod.of(MemorySegment.class, \"reinterpret\", MemorySegment.class, long.class),\n+            RestrictedMethod.of(MemorySegment.class, \"reinterpret\", MemorySegment.class, Arena.class, Consumer.class),\n+            RestrictedMethod.of(MemorySegment.class, \"reinterpret\", MemorySegment.class, long.class, Arena.class, Consumer.class),\n+            RestrictedMethod.of(AddressLayout.class, \"withTargetLayout\", AddressLayout.class, MemoryLayout.class),\n+            RestrictedMethod.of(ModuleLayer.Controller.class, \"enableNativeAccess\", ModuleLayer.Controller.class, Module.class)\n+    );\n+\n+    @Test\n+    public void testRestricted() {\n+        Set<RestrictedMethod> restrictedMethods = new HashSet<>(RESTRICTED_METHODS);\n+        restrictedMethods(Object.class.getModule()).forEach(m -> checkRestrictedMethod(m, restrictedMethods));\n+        if (!restrictedMethods.isEmpty()) {\n+            fail(\"@Restricted annotation not found for methods: \" + restrictedMethods);\n+        }\n+    }\n+\n+    void checkRestrictedMethod(Method meth, Set<RestrictedMethod> restrictedMethods) {\n+        String sig = meth.getDeclaringClass().getName() + \"::\" + shortSig(meth);\n+        boolean expectRestricted = restrictedMethods.remove(RestrictedMethod.from(meth));\n+        assertTrue(expectRestricted, \"unexpected @Restricted annotation found on method \" + sig);\n+        assertTrue(meth.isAnnotationPresent(CallerSensitive.class), \"@CallerSensitive annotation not found on restricted method \" + sig);\n+    }\n+\n+    \/**\n+     * Returns a stream of all restricted methods on public classes in packages\n+     * exported by a named module. This logic is borrowed from CallerSensitiveTest.\n+     *\/\n+    static Stream<Method> restrictedMethods(Module module) {\n+        assert module.isNamed();\n+        ModuleReference mref = module.getLayer().configuration()\n+                .findModule(module.getName())\n+                .orElseThrow(() -> new RuntimeException())\n+                .reference();\n+        \/\/ find all \".class\" resources in the module\n+        \/\/ transform the resource name to a class name\n+        \/\/ load every class in the exported packages\n+        \/\/ return the restricted methods of the public classes\n+        try (ModuleReader reader = mref.open()) {\n+            return reader.list()\n+                    .filter(rn -> rn.endsWith(\".class\"))\n+                    .map(rn -> rn.substring(0, rn.length() - 6)\n+                            .replace('\/', '.'))\n+                    .filter(cn -> module.isExported(packageName(cn)))\n+                    .map(cn -> Class.forName(module, cn))\n+                    .filter(refc -> refc != null\n+                            && Modifier.isPublic(refc.getModifiers()))\n+                    .map(refc -> restrictedMethods(refc))\n+                    .flatMap(List::stream);\n+        } catch (IOException ioe) {\n+            throw new UncheckedIOException(ioe);\n+        }\n+    }\n+\n+    static String packageName(String cn) {\n+        int last = cn.lastIndexOf('.');\n+        if (last > 0) {\n+            return cn.substring(0, last);\n+        } else {\n+            return \"\";\n+        }\n+    }\n+\n+    static String shortSig(Method m) {\n+        StringJoiner sj = new StringJoiner(\",\", m.getName() + \"(\", \")\");\n+        for (Class<?> parameterType : m.getParameterTypes()) {\n+            sj.add(parameterType.getTypeName());\n+        }\n+        return sj.toString();\n+    }\n+\n+    \/**\n+     * Returns a list of restricted methods directly declared by the given\n+     * class.\n+     *\/\n+    static List<Method> restrictedMethods(Class<?> refc) {\n+        return Arrays.stream(refc.getDeclaredMethods())\n+                .filter(m -> m.isAnnotationPresent(Restricted.class))\n+                .collect(Collectors.toList());\n+    }\n+}\n","filename":"test\/jdk\/java\/foreign\/TestRestricted.java","additions":168,"deletions":0,"binary":false,"changes":168,"status":"added"}]}