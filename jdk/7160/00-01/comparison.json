{"files":[{"patch":"@@ -118,1 +118,1 @@\n-  check_block_integrity();\n+  assert_block_integrity();\n@@ -156,0 +156,10 @@\n+void MallocHeader::assert_block_integrity() const {\n+  char msg[256];\n+  address corruption = NULL;\n+  if (!check_block_integrity(msg, sizeof(msg), &corruption)) {\n+    if (corruption != NULL) {\n+      print_block_on_error(tty, (address)this);\n+    }\n+    fatal(\"NMT corruption: Block at \" PTR_FORMAT \": %s\", p2i(this), msg);\n+  }\n+}\n@@ -157,7 +167,1 @@\n-\/\/ Check block integrity.\n-\/\/ If fatal_error is true and block is broken, print out a report\n-\/\/ to tty (optionally with hex dump surrounding the broken block),\n-\/\/ then trigger a fatal error\n-bool MallocHeader::check_block_integrity(bool fatal_error) const {\n-\n-#define PREFIX \"NMT corruption: \"\n+bool MallocHeader::check_block_integrity(char* msg, size_t msglen, address* p_corruption) const {\n@@ -171,2 +175,2 @@\n-    if (!fatal_error) return false;\n-    fatal(PREFIX \"Block at \" PTR_FORMAT \": invalid block address\", p2i(this));\n+    jio_snprintf(msg, msglen, \"invalid block address\");\n+    return false;\n@@ -191,3 +195,3 @@\n-    if (!fatal_error) return false;\n-    print_block_on_error(tty, (address)this);\n-    fatal(PREFIX \"Block at \" PTR_FORMAT \": block address is unaligned\", p2i(this));\n+    *p_corruption = (address)this;\n+    jio_snprintf(msg, msglen, \"block address is unaligned\");\n+    return false;\n@@ -198,3 +202,3 @@\n-    if (!fatal_error) return false;\n-    print_block_on_error(tty, (address)this);\n-    fatal(PREFIX \"Block at \" PTR_FORMAT \": header canary broken.\", p2i(this));\n+    *p_corruption = (address)this;\n+    jio_snprintf(msg, msglen, \"header canary broken\");\n+    return false;\n@@ -206,3 +210,3 @@\n-    if (!fatal_error) return false;\n-    print_block_on_error(tty, (address)this);\n-    fatal(PREFIX \"Block at \" PTR_FORMAT \": header alternate canary broken.\", p2i(this));\n+    *p_corruption = (address)this;\n+    jio_snprintf(msg, msglen, \"header canary broken\");\n+    return false;\n@@ -214,3 +218,3 @@\n-    if (!fatal_error) return false;\n-    print_block_on_error(tty, (address)this);\n-    fatal(PREFIX \"Block at \" PTR_FORMAT \": header looks invalid (weirdly large block size)\", p2i(this));\n+    *p_corruption = (address)this;\n+    jio_snprintf(msg, msglen, \"header looks invalid (weirdly large block size)\");\n+    return false;\n@@ -221,4 +225,4 @@\n-    if (!fatal_error) return false;\n-    print_block_on_error(tty, footer_address());\n-    fatal(PREFIX \"Block at \" PTR_FORMAT \": footer canary broken at \" PTR_FORMAT \" (buffer overflow?)\",\n-          p2i(this), p2i(footer_address()));\n+    *p_corruption = footer_address();\n+    jio_snprintf(msg, msglen, \"footer canary broken at \" PTR_FORMAT \" (buffer overflow?)\",\n+                p2i(footer_address()));\n+    return false;\n@@ -226,1 +230,0 @@\n-#undef PREFIX\n","filename":"src\/hotspot\/share\/services\/mallocTracker.cpp","additions":30,"deletions":27,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -317,0 +317,3 @@\n+  \/\/ If block is broken, print out a report to tty (optionally with\n+  \/\/ hex dump surrounding the broken block), then trigger a fatal error\n+  void assert_block_integrity() const;\n@@ -362,5 +365,4 @@\n-  \/\/ Check block integrity.\n-  \/\/ If fatal_error is true and block is broken, print out a report\n-  \/\/ to tty (optionally with hex dump surrounding the broken block),\n-  \/\/ then trigger a fatal error\n-  bool check_block_integrity(bool fatal_error = true) const;\n+  \/\/ If block is broken, fill in a short descriptive text in out,\n+  \/\/ an option pointer to the corruption in p_corruption, and return false.\n+  \/\/ Return true if block is fine.\n+  bool check_block_integrity(char* msg, size_t msglen, address* p_corruption) const;\n","filename":"src\/hotspot\/share\/services\/mallocTracker.hpp","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -504,1 +504,3 @@\n-        if (SafeFetchN((intptr_t*)mhdr, 0) != 0 && mhdr->check_block_integrity(false \/*fatal_error*\/)) {\n+        char msg[256];\n+        address p_corrupted;\n+        if (SafeFetchN((intptr_t*)mhdr, 0) != 0 && mhdr->check_block_integrity(msg, sizeof(msg), &p_corrupted)) {\n","filename":"src\/hotspot\/share\/utilities\/debug.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"}]}