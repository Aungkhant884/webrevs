{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,2 @@\n+#include \"jvm_io.h\"\n+\n@@ -118,1 +120,1 @@\n-  check_block_integrity();\n+  assert_block_integrity();\n@@ -156,0 +158,10 @@\n+void MallocHeader::assert_block_integrity() const {\n+  char msg[256];\n+  address corruption = NULL;\n+  if (!check_block_integrity(msg, sizeof(msg), &corruption)) {\n+    if (corruption != NULL) {\n+      print_block_on_error(tty, (address)this);\n+    }\n+    fatal(\"NMT corruption: Block at \" PTR_FORMAT \": %s\", p2i(this), msg);\n+  }\n+}\n@@ -157,6 +169,1 @@\n-\/\/ Check block integrity. If block is broken, print out a report\n-\/\/ to tty (optionally with hex dump surrounding the broken block),\n-\/\/ then trigger a fatal error.\n-void MallocHeader::check_block_integrity() const {\n-\n-#define PREFIX \"NMT corruption: \"\n+bool MallocHeader::check_block_integrity(char* msg, size_t msglen, address* p_corruption) const {\n@@ -170,1 +177,2 @@\n-    fatal(PREFIX \"Block at \" PTR_FORMAT \": invalid block address\", p2i(this));\n+    jio_snprintf(msg, msglen, \"invalid block address\");\n+    return false;\n@@ -189,2 +197,3 @@\n-    print_block_on_error(tty, (address)this);\n-    fatal(PREFIX \"Block at \" PTR_FORMAT \": block address is unaligned\", p2i(this));\n+    *p_corruption = (address)this;\n+    jio_snprintf(msg, msglen, \"block address is unaligned\");\n+    return false;\n@@ -195,2 +204,3 @@\n-    print_block_on_error(tty, (address)this);\n-    fatal(PREFIX \"Block at \" PTR_FORMAT \": header canary broken.\", p2i(this));\n+    *p_corruption = (address)this;\n+    jio_snprintf(msg, msglen, \"header canary broken\");\n+    return false;\n@@ -202,2 +212,3 @@\n-    print_block_on_error(tty, (address)this);\n-    fatal(PREFIX \"Block at \" PTR_FORMAT \": header alternate canary broken.\", p2i(this));\n+    *p_corruption = (address)this;\n+    jio_snprintf(msg, msglen, \"header canary broken\");\n+    return false;\n@@ -209,2 +220,3 @@\n-    print_block_on_error(tty, (address)this);\n-    fatal(PREFIX \"Block at \" PTR_FORMAT \": header looks invalid (weirdly large block size)\", p2i(this));\n+    *p_corruption = (address)this;\n+    jio_snprintf(msg, msglen, \"header looks invalid (weirdly large block size)\");\n+    return false;\n@@ -215,3 +227,4 @@\n-    print_block_on_error(tty, footer_address());\n-    fatal(PREFIX \"Block at \" PTR_FORMAT \": footer canary broken at \" PTR_FORMAT \" (buffer overflow?)\",\n-          p2i(this), p2i(footer_address()));\n+    *p_corruption = footer_address();\n+    jio_snprintf(msg, msglen, \"footer canary broken at \" PTR_FORMAT \" (buffer overflow?)\",\n+                p2i(footer_address()));\n+    return false;\n@@ -219,1 +232,1 @@\n-#undef PREFIX\n+  return true;\n","filename":"src\/hotspot\/share\/services\/mallocTracker.cpp","additions":34,"deletions":21,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -317,4 +317,3 @@\n-  \/\/ Check block integrity. If block is broken, print out a report\n-  \/\/ to tty (optionally with hex dump surrounding the broken block),\n-  \/\/ then trigger a fatal error.\n-  void check_block_integrity() const;\n+  \/\/ If block is broken, print out a report to tty (optionally with\n+  \/\/ hex dump surrounding the broken block), then trigger a fatal error\n+  void assert_block_integrity() const;\n@@ -366,0 +365,5 @@\n+  \/\/ If block is broken, fill in a short descriptive text in out,\n+  \/\/ an option pointer to the corruption in p_corruption, and return false.\n+  \/\/ Return true if block is fine.\n+  bool check_block_integrity(char* msg, size_t msglen, address* p_corruption) const;\n+\n","filename":"src\/hotspot\/share\/services\/mallocTracker.hpp","additions":9,"deletions":5,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -674,0 +674,24 @@\n+\n+class FindInRegionWalker : public VirtualMemoryWalker {\n+private:\n+  const address               _p;\n+  const ReservedMemoryRegion* _region;\n+public:\n+  FindInRegionWalker(void* p) : _p((address)p), _region(nullptr) { }\n+\n+  bool do_allocation_site(const ReservedMemoryRegion* rgn) {\n+    if (_p >= rgn->base() && _p < rgn->base() + rgn->size()) {\n+      _region = rgn;\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  const ReservedMemoryRegion* region() const { return _region; }\n+};\n+\n+const ReservedMemoryRegion* VirtualMemoryTracker::find_region(void* p) {\n+  FindInRegionWalker walker(p);\n+  walk_virtual_memory(&walker);\n+  return walker.region();\n+}\n","filename":"src\/hotspot\/share\/services\/virtualMemoryTracker.cpp","additions":25,"deletions":1,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -344,1 +344,1 @@\n-  const char* flag_name() { return NMTUtil::flag_to_name(_flag); }\n+  const char* flag_name() const { return NMTUtil::flag_to_name(_flag); }\n@@ -390,0 +390,2 @@\n+  static const ReservedMemoryRegion* find_region(void* p);\n+\n","filename":"src\/hotspot\/share\/services\/virtualMemoryTracker.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,0 +47,1 @@\n+#include \"runtime\/safefetch.inline.hpp\"\n@@ -54,0 +55,1 @@\n+#include \"services\/mallocTracker.hpp\"\n@@ -55,0 +57,1 @@\n+#include \"services\/virtualMemoryTracker.hpp\"\n@@ -483,0 +486,35 @@\n+#if INCLUDE_NMT\n+    \/\/ With NMT\n+    if (MemTracker::enabled()) {\n+      const NMT_TrackingLevel tracking_level = MemTracker::tracking_level();\n+      \/\/ Check if it is in a known mmap'd memory region\n+      const ReservedMemoryRegion* rgn = VirtualMemoryTracker::find_region(p);\n+      if (rgn != nullptr) {\n+        tty->print_cr(PTR_FORMAT \" in mmap'd memory region [\" PTR_FORMAT \" - \" PTR_FORMAT \"] by %s\",\n+          p2i(p), p2i(rgn->base()), p2i(rgn->base() + rgn->size()), rgn->flag_name());\n+        if (tracking_level == NMT_detail) {\n+          rgn->call_stack()->print_on(tty);\n+          tty->cr();\n+        }\n+        return;\n+      }\n+      \/\/ Check if it is a malloc'd memory block\n+      if (CanUseSafeFetchN() && SafeFetchN((intptr_t*)p, 0) != 0) {\n+        const MallocHeader* mhdr = (const MallocHeader*)MallocTracker::get_base(p, tracking_level);\n+        char msg[256];\n+        address p_corrupted;\n+        if (SafeFetchN((intptr_t*)mhdr, 0) != 0 && mhdr->check_block_integrity(msg, sizeof(msg), &p_corrupted)) {\n+          tty->print_cr(PTR_FORMAT \" malloc'd \" SIZE_FORMAT \" bytes by %s\",\n+            p2i(p), mhdr->size(), NMTUtil::flag_to_name(mhdr->flags()));\n+          if (tracking_level == NMT_detail) {\n+            NativeCallStack ncs;\n+            if (mhdr->get_stack(ncs)) {\n+              ncs.print_on(tty);\n+              tty->cr();\n+            }\n+          }\n+          return;\n+        }\n+      }\n+    }\n+#endif \/\/ INCLUDE_NMT\n","filename":"src\/hotspot\/share\/utilities\/debug.cpp","additions":39,"deletions":1,"binary":false,"changes":40,"status":"modified"}]}