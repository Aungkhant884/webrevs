{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -157,1 +157,2 @@\n-\/\/ Check block integrity. If block is broken, print out a report\n+\/\/ Check block integrity.\n+\/\/ If fatal_error is true and block is broken, print out a report\n@@ -159,2 +160,2 @@\n-\/\/ then trigger a fatal error.\n-void MallocHeader::check_block_integrity() const {\n+\/\/ then trigger a fatal error\n+bool MallocHeader::check_block_integrity(bool fatal_error) const {\n@@ -170,0 +171,1 @@\n+    if (!fatal_error) return false;\n@@ -189,0 +191,1 @@\n+    if (!fatal_error) return false;\n@@ -195,0 +198,1 @@\n+    if (!fatal_error) return false;\n@@ -202,0 +206,1 @@\n+    if (!fatal_error) return false;\n@@ -209,0 +214,1 @@\n+    if (!fatal_error) return false;\n@@ -215,0 +221,1 @@\n+    if (!fatal_error) return false;\n@@ -220,0 +227,1 @@\n+  return true;\n","filename":"src\/hotspot\/share\/services\/mallocTracker.cpp","additions":12,"deletions":4,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -317,4 +317,0 @@\n-  \/\/ Check block integrity. If block is broken, print out a report\n-  \/\/ to tty (optionally with hex dump surrounding the broken block),\n-  \/\/ then trigger a fatal error.\n-  void check_block_integrity() const;\n@@ -366,0 +362,6 @@\n+  \/\/ Check block integrity.\n+  \/\/ If fatal_error is true and block is broken, print out a report\n+  \/\/ to tty (optionally with hex dump surrounding the broken block),\n+  \/\/ then trigger a fatal error\n+  bool check_block_integrity(bool fatal_error = true) const;\n+\n","filename":"src\/hotspot\/share\/services\/mallocTracker.hpp","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -674,0 +674,24 @@\n+\n+class FindInRegionWalker : public VirtualMemoryWalker {\n+private:\n+  const address               _p;\n+  const ReservedMemoryRegion* _region;\n+public:\n+  FindInRegionWalker(void* p) : _p((address)p), _region(nullptr) { }\n+\n+  bool do_allocation_site(const ReservedMemoryRegion* rgn) {\n+    if (_p >= rgn->base() && _p < rgn->base() + rgn->size()) {\n+      _region = rgn;\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  const ReservedMemoryRegion* region() const { return _region; }\n+};\n+\n+const ReservedMemoryRegion* VirtualMemoryTracker::find_region(void* p) {\n+  FindInRegionWalker walker(p);\n+  walk_virtual_memory(&walker);\n+  return walker.region();\n+}\n","filename":"src\/hotspot\/share\/services\/virtualMemoryTracker.cpp","additions":25,"deletions":1,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -344,1 +344,1 @@\n-  const char* flag_name() { return NMTUtil::flag_to_name(_flag); }\n+  const char* flag_name() const { return NMTUtil::flag_to_name(_flag); }\n@@ -390,0 +390,2 @@\n+  static const ReservedMemoryRegion* find_region(void* p);\n+\n","filename":"src\/hotspot\/share\/services\/virtualMemoryTracker.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,0 +47,1 @@\n+#include \"runtime\/safefetch.inline.hpp\"\n@@ -54,0 +55,1 @@\n+#include \"services\/mallocTracker.hpp\"\n@@ -55,0 +57,1 @@\n+#include \"services\/virtualMemoryTracker.hpp\"\n@@ -483,0 +486,33 @@\n+#if INCLUDE_NMT\n+    \/\/ With NMT\n+    if (MemTracker::enabled()) {\n+      const NMT_TrackingLevel tracking_level = MemTracker::tracking_level();\n+      \/\/ Check if it is in a known mmap'd memory region\n+      const ReservedMemoryRegion* rgn = VirtualMemoryTracker::find_region(p);\n+      if (rgn != nullptr) {\n+        tty->print_cr(PTR_FORMAT \" in mmap'd memory region [\" PTR_FORMAT \" - \" PTR_FORMAT \"] by %s\",\n+          p2i(p), p2i(rgn->base()), p2i(rgn->base() + rgn->size()), rgn->flag_name());\n+        if (tracking_level == NMT_detail) {\n+          rgn->call_stack()->print_on(tty);\n+          tty->cr();\n+        }\n+        return;\n+      }\n+      \/\/ Check if it is a malloc'd memory block\n+      if (CanUseSafeFetchN() && SafeFetchN((intptr_t*)p, 0) != 0) {\n+        const MallocHeader* mhdr = (const MallocHeader*)MallocTracker::get_base(p, tracking_level);\n+        if (SafeFetchN((intptr_t*)mhdr, 0) != 0 && mhdr->check_block_integrity(false \/*fatal_error*\/)) {\n+          tty->print_cr(PTR_FORMAT \" malloc'd \" SIZE_FORMAT \" bytes by %s\",\n+            p2i(p), mhdr->size(), NMTUtil::flag_to_name(mhdr->flags()));\n+          if (tracking_level == NMT_detail) {\n+            NativeCallStack ncs;\n+            if (mhdr->get_stack(ncs)) {\n+              ncs.print_on(tty);\n+              tty->cr();\n+            }\n+          }\n+          return;\n+        }\n+      }\n+    }\n+#endif \/\/ INCLUDE_NMT\n","filename":"src\/hotspot\/share\/utilities\/debug.cpp","additions":37,"deletions":1,"binary":false,"changes":38,"status":"modified"}]}