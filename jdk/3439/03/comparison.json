{"files":[{"patch":"@@ -57,1 +57,3 @@\n-            INV_LIMIT          =  3;\n+            VH_INV_EXACT       =  3,  \/\/ MethodHandles.varHandleExactInvoker\n+            VH_INV_GENERIC     =  VH_INV_EXACT   + VarHandle.AccessMode.values().length,  \/\/ MethodHandles.varHandleInvoker\n+            INV_LIMIT          =  VH_INV_GENERIC + VarHandle.AccessMode.values().length;\n@@ -104,2 +106,5 @@\n-        \/\/ TODO cache invoker\n-        return makeVarHandleMethodInvoker(ak, false);\n+        boolean isExact = false;\n+        MethodHandle invoker = cachedVHInvoker(isExact, ak);\n+        if (invoker != null)  return invoker;\n+        invoker = makeVarHandleMethodInvoker(ak, isExact);\n+        return setCachedVHInvoker(isExact, ak, invoker);\n@@ -110,2 +115,5 @@\n-        \/\/ TODO cache invoker\n-        return makeVarHandleMethodInvoker(ak, true);\n+        boolean isExact = true;\n+        MethodHandle invoker = cachedVHInvoker(isExact, ak);\n+        if (invoker != null)  return invoker;\n+        invoker = makeVarHandleMethodInvoker(ak, isExact);\n+        return setCachedVHInvoker(isExact, ak, invoker);\n@@ -125,0 +133,10 @@\n+    private MethodHandle cachedVHInvoker(boolean isExact, VarHandle.AccessMode ak) {\n+        int baseIndex = (isExact ? VH_INV_EXACT : VH_INV_GENERIC);\n+        return cachedInvoker(baseIndex + ak.ordinal());\n+    }\n+\n+    private MethodHandle setCachedVHInvoker(boolean isExact, VarHandle.AccessMode ak, final MethodHandle invoker) {\n+        int baseIndex = (isExact ? VH_INV_EXACT : VH_INV_GENERIC);\n+        return setCachedInvoker(baseIndex + ak.ordinal(), invoker);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/Invokers.java","additions":23,"deletions":5,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -0,0 +1,88 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @bug 8265079\n+ * @run testng\/othervm -Xverify:all TestVHInvokerCaching\n+ *\/\n+\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.VarHandle;\n+import java.lang.reflect.Field;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static java.lang.invoke.MethodHandles.lookup;\n+import static org.testng.Assert.assertSame;\n+\n+public class TestVHInvokerCaching {\n+\n+    @Test(dataProvider = \"testHandles\")\n+    public static void testVHIInvokerCaching(VarHandle testHandle) throws Throwable {\n+        for (VarHandle.AccessMode mode : VarHandle.AccessMode.values()) {\n+            MethodHandle handle1 = MethodHandles.varHandleInvoker(mode, testHandle.accessModeType(mode));\n+            MethodHandle handle2 = MethodHandles.varHandleInvoker(mode, testHandle.accessModeType(mode));\n+            assertSame(handle1, handle2);\n+        }\n+\n+        for (VarHandle.AccessMode mode : VarHandle.AccessMode.values()) {\n+            MethodHandle handle1 = MethodHandles.varHandleExactInvoker(mode, testHandle.accessModeType(mode));\n+            MethodHandle handle2 = MethodHandles.varHandleExactInvoker(mode, testHandle.accessModeType(mode));\n+            assertSame(handle1, handle2);\n+        }\n+    }\n+\n+    @DataProvider\n+    public static Object[][] testHandles() throws NoSuchFieldException, IllegalAccessException {\n+        List<VarHandle> testHandles = new ArrayList<>();\n+\n+        class Holder {\n+            byte f_byte;\n+            short f_short;\n+            char f_char;\n+            int f_int;\n+            long f_long;\n+            float f_float;\n+            double f_double;\n+            Object f_Object;\n+            String f_String;\n+        }\n+\n+        MethodHandles.Lookup lookup = lookup();\n+\n+        for (Field field : Holder.class.getFields()) {\n+            String fieldName = field.getName();\n+            Class<?> fieldType = field.getType();\n+\n+            testHandles.add(MethodHandles.arrayElementVarHandle(fieldType.arrayType()));\n+            testHandles.add(lookup.findVarHandle(Holder.class, fieldName, fieldType));\n+        }\n+\n+        return testHandles.stream().map(vh -> new Object[]{ vh }).toArray(Object[][]::new);\n+    }\n+}\n+\n","filename":"test\/jdk\/java\/lang\/invoke\/TestVHInvokerCaching.java","additions":88,"deletions":0,"binary":false,"changes":88,"status":"added"}]}