{"files":[{"patch":"@@ -36,1 +36,1 @@\n-#include \"oops\/arrayKlass.hpp\"\n+#include \"oops\/arrayKlass.inline.hpp\"\n@@ -119,0 +119,57 @@\n+ArrayKlass* ArrayKlass::array_klass(int n, TRAPS) {\n+\n+  assert(dimension() <= n, \"check order of chain\");\n+  int dim = dimension();\n+  if (dim == n) return this;\n+\n+  \/\/ lock-free read needs acquire semantics\n+  if (higher_dimension_acquire() == nullptr) {\n+\n+    ResourceMark rm(THREAD);\n+    {\n+      \/\/ Ensure atomic creation of higher dimensions\n+      MutexLocker mu(THREAD, MultiArray_lock);\n+\n+      \/\/ Check if another thread beat us\n+      if (higher_dimension() == nullptr) {\n+\n+        \/\/ Create multi-dim klass object and link them together\n+        ObjArrayKlass* ak =\n+          ObjArrayKlass::allocate_objArray_klass(class_loader_data(), dim + 1, this, CHECK_NULL);\n+        ak->set_lower_dimension(this);\n+        \/\/ use 'release' to pair with lock-free load\n+        release_set_higher_dimension(ak);\n+        assert(ak->is_objArray_klass(), \"incorrect initialization of ObjArrayKlass\");\n+      }\n+    }\n+  }\n+\n+  ObjArrayKlass *ak = higher_dimension();\n+  THREAD->check_possible_safepoint();\n+  return ak->array_klass(n, THREAD);\n+}\n+\n+ArrayKlass* ArrayKlass::array_klass_or_null(int n) {\n+\n+  assert(dimension() <= n, \"check order of chain\");\n+  int dim = dimension();\n+  if (dim == n) return this;\n+\n+  \/\/ lock-free read needs acquire semantics\n+  if (higher_dimension_acquire() == nullptr) {\n+    return nullptr;\n+  }\n+\n+  ObjArrayKlass *ak = higher_dimension();\n+  return ak->array_klass_or_null(n);\n+}\n+\n+ArrayKlass* ArrayKlass::array_klass(TRAPS) {\n+  return array_klass(dimension() +  1, THREAD);\n+}\n+\n+ArrayKlass* ArrayKlass::array_klass_or_null() {\n+  return array_klass_or_null(dimension() +  1);\n+}\n+\n+\n","filename":"src\/hotspot\/share\/oops\/arrayKlass.cpp","additions":58,"deletions":1,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -56,0 +56,8 @@\n+  \/\/ Returns the ObjArrayKlass for n'th dimension.\n+  ArrayKlass* array_klass(int n, TRAPS);\n+  ArrayKlass* array_klass_or_null(int n);\n+\n+  \/\/ Returns the array class with this class as element type.\n+  ArrayKlass* array_klass(TRAPS);\n+  ArrayKlass* array_klass_or_null();\n+\n","filename":"src\/hotspot\/share\/oops\/arrayKlass.hpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-#include \"oops\/arrayKlass.inline.hpp\"\n+#include \"oops\/arrayKlass.hpp\"\n@@ -307,57 +307,0 @@\n-\n-ArrayKlass* ObjArrayKlass::array_klass(int n, TRAPS) {\n-\n-  assert(dimension() <= n, \"check order of chain\");\n-  int dim = dimension();\n-  if (dim == n) return this;\n-\n-  \/\/ lock-free read needs acquire semantics\n-  if (higher_dimension_acquire() == nullptr) {\n-\n-    ResourceMark rm(THREAD);\n-    {\n-      \/\/ Ensure atomic creation of higher dimensions\n-      MutexLocker mu(THREAD, MultiArray_lock);\n-\n-      \/\/ Check if another thread beat us\n-      if (higher_dimension() == nullptr) {\n-\n-        \/\/ Create multi-dim klass object and link them together\n-        ObjArrayKlass* ak =\n-          ObjArrayKlass::allocate_objArray_klass(class_loader_data(), dim + 1, this, CHECK_NULL);\n-        ak->set_lower_dimension(this);\n-        \/\/ use 'release' to pair with lock-free load\n-        release_set_higher_dimension(ak);\n-        assert(ak->is_objArray_klass(), \"incorrect initialization of ObjArrayKlass\");\n-      }\n-    }\n-  }\n-\n-  ObjArrayKlass *ak = higher_dimension();\n-  THREAD->check_possible_safepoint();\n-  return ak->array_klass(n, THREAD);\n-}\n-\n-ArrayKlass* ObjArrayKlass::array_klass_or_null(int n) {\n-\n-  assert(dimension() <= n, \"check order of chain\");\n-  int dim = dimension();\n-  if (dim == n) return this;\n-\n-  \/\/ lock-free read needs acquire semantics\n-  if (higher_dimension_acquire() == nullptr) {\n-    return nullptr;\n-  }\n-\n-  ObjArrayKlass *ak = higher_dimension();\n-  return ak->array_klass_or_null(n);\n-}\n-\n-ArrayKlass* ObjArrayKlass::array_klass(TRAPS) {\n-  return array_klass(dimension() +  1, THREAD);\n-}\n-\n-ArrayKlass* ObjArrayKlass::array_klass_or_null() {\n-  return array_klass_or_null(dimension() +  1);\n-}\n-\n","filename":"src\/hotspot\/share\/oops\/objArrayKlass.cpp","additions":1,"deletions":58,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -99,8 +99,0 @@\n-  \/\/ Returns the ObjArrayKlass for n'th dimension.\n-  virtual ArrayKlass* array_klass(int n, TRAPS);\n-  virtual ArrayKlass* array_klass_or_null(int n);\n-\n-  \/\/ Returns the array class with this class as element type.\n-  virtual ArrayKlass* array_klass(TRAPS);\n-  virtual ArrayKlass* array_klass_or_null();\n-\n","filename":"src\/hotspot\/share\/oops\/objArrayKlass.hpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-#include \"oops\/arrayKlass.inline.hpp\"\n+#include \"oops\/arrayKlass.hpp\"\n@@ -173,57 +173,0 @@\n-\/\/ create a klass of array holding typeArrays\n-ArrayKlass* TypeArrayKlass::array_klass(int n, TRAPS) {\n-  int dim = dimension();\n-  assert(dim <= n, \"check order of chain\");\n-    if (dim == n)\n-      return this;\n-\n-  \/\/ lock-free read needs acquire semantics\n-  if (higher_dimension_acquire() == nullptr) {\n-\n-    ResourceMark rm;\n-    JavaThread *jt = THREAD;\n-    {\n-      \/\/ Atomic create higher dimension and link into list\n-      MutexLocker mu(THREAD, MultiArray_lock);\n-\n-      if (higher_dimension() == nullptr) {\n-        Klass* oak = ObjArrayKlass::allocate_objArray_klass(\n-              class_loader_data(), dim + 1, this, CHECK_NULL);\n-        ObjArrayKlass* h_ak = ObjArrayKlass::cast(oak);\n-        h_ak->set_lower_dimension(this);\n-        \/\/ use 'release' to pair with lock-free load\n-        release_set_higher_dimension(h_ak);\n-        assert(h_ak->is_objArray_klass(), \"incorrect initialization of ObjArrayKlass\");\n-      }\n-    }\n-  }\n-\n-  ObjArrayKlass* h_ak = higher_dimension();\n-  THREAD->check_possible_safepoint();\n-  return h_ak->array_klass(n, THREAD);\n-}\n-\n-\/\/ return existing klass of array holding typeArrays\n-ArrayKlass* TypeArrayKlass::array_klass_or_null(int n) {\n-  int dim = dimension();\n-  assert(dim <= n, \"check order of chain\");\n-    if (dim == n)\n-      return this;\n-\n-  \/\/ lock-free read needs acquire semantics\n-  if (higher_dimension_acquire() == nullptr) {\n-    return nullptr;\n-  }\n-\n-  ObjArrayKlass* h_ak = higher_dimension();\n-  return h_ak->array_klass_or_null(n);\n-}\n-\n-ArrayKlass* TypeArrayKlass::array_klass(TRAPS) {\n-  return array_klass(dimension() +  1, THREAD);\n-}\n-\n-ArrayKlass* TypeArrayKlass::array_klass_or_null() {\n-  return array_klass_or_null(dimension() +  1);\n-}\n-\n","filename":"src\/hotspot\/share\/oops\/typeArrayKlass.cpp","additions":1,"deletions":58,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -97,8 +97,0 @@\n-  \/\/ Find n'th dimensional array\n-  virtual ArrayKlass* array_klass(int n, TRAPS);\n-  virtual ArrayKlass* array_klass_or_null(int n);\n-\n-  \/\/ Returns the array class with this class as element type\n-  virtual ArrayKlass* array_klass(TRAPS);\n-  virtual ArrayKlass* array_klass_or_null();\n-\n","filename":"src\/hotspot\/share\/oops\/typeArrayKlass.hpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"}]}