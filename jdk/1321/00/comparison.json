{"files":[{"patch":"@@ -36,1 +36,0 @@\n-address StubRoutines::aarch64::_get_previous_fp_entry = NULL;\n","filename":"src\/hotspot\/cpu\/aarch64\/stubRoutines_aarch64.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -46,1 +46,0 @@\n-  static address _get_previous_fp_entry;\n@@ -80,5 +79,0 @@\n-  static address get_previous_fp_entry()\n-  {\n-    return _get_previous_fp_entry;\n-  }\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/stubRoutines_aarch64.hpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -531,0 +531,6 @@\n+    \/\/ Note: We want to allow trace_method_handle from any call site.\n+    \/\/ While trace_method_handle creates a frame, it may be entered\n+    \/\/ without a PC on the stack top (e.g. not just after a call).\n+    \/\/ Walking that frame could lead to failures due to that invalid PC.\n+    \/\/ => carefully detect that frame when doing the stack walking\n+\n@@ -539,6 +545,0 @@\n-      \/\/ Note: We want to allow trace_method_handle from any call site.\n-      \/\/ While trace_method_handle creates a frame, it may be entered\n-      \/\/ without a PC on the stack top (e.g. not just after a call).\n-      \/\/ Walking that frame could lead to failures due to that invalid PC.\n-      \/\/ => carefully detect that frame when doing the stack walking\n-\n@@ -548,7 +548,1 @@\n-      \/\/ Robust search of trace_calling_frame (independant of inlining).\n-      \/\/ Assumes saved_regs comes from a pusha in the trace_calling_frame.\n-      assert(cur_frame.sp() < saved_regs, \"registers not saved on stack ?\");\n-      frame trace_calling_frame = os::get_sender_for_C_frame(&cur_frame);\n-      while (trace_calling_frame.fp() < saved_regs) {\n-        trace_calling_frame = os::get_sender_for_C_frame(&trace_calling_frame);\n-      }\n+      bool walkable = has_mh && cur_frame.fp() != 0; \/\/ whether the traced frame should be walkable\n@@ -556,3 +550,1 @@\n-      \/\/ safely create a frame and call frame::describe\n-      intptr_t *dump_sp = trace_calling_frame.sender_sp();\n-      intptr_t *dump_fp = trace_calling_frame.link();\n+      if (walkable) {\n@@ -560,1 +552,11 @@\n-      bool walkable = has_mh; \/\/ whether the traced frame shoud be walkable\n+        \/\/ Robust search of trace_calling_frame (independant of inlining).\n+        \/\/ Assumes saved_regs comes from a pusha in the trace_calling_frame.\n+        assert(cur_frame.sp() < saved_regs, \"registers not saved on stack ?\");\n+        frame trace_calling_frame = os::get_sender_for_C_frame(&cur_frame);\n+        while (trace_calling_frame.fp() < saved_regs) {\n+          trace_calling_frame = os::get_sender_for_C_frame(&trace_calling_frame);\n+        }\n+\n+        \/\/ safely create a frame and call frame::describe\n+        intptr_t *dump_sp = trace_calling_frame.sender_sp();\n+        intptr_t *dump_fp = trace_calling_frame.link();\n@@ -562,1 +564,0 @@\n-      if (walkable) {\n@@ -571,5 +572,0 @@\n-      } else {\n-        \/\/ Stack may not be walkable (invalid PC above FP):\n-        \/\/ Add descriptions without building a Java frame to avoid issues\n-        values.describe(-1, dump_fp, \"fp for #1 <not parsed, cannot trust pc>\");\n-        values.describe(-1, dump_sp, \"sp for #1\");\n","filename":"src\/hotspot\/cpu\/x86\/methodHandles_x86.cpp","additions":19,"deletions":23,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -6720,1 +6720,0 @@\n-    StubRoutines::x86::_get_previous_fp_entry = generate_get_previous_fp();\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,1 +45,0 @@\n-  static address _get_previous_fp_entry;\n@@ -60,4 +59,0 @@\n-  static address get_previous_fp_entry() {\n-    return _get_previous_fp_entry;\n-  }\n-\n","filename":"src\/hotspot\/cpu\/x86\/stubRoutines_x86.hpp","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,0 @@\n-address StubRoutines::x86::_get_previous_fp_entry = NULL;\n","filename":"src\/hotspot\/cpu\/x86\/stubRoutines_x86_64.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -145,2 +145,0 @@\n-\/\/ By default, gcc always saves frame pointer rfp on this stack. This\n-\/\/ may get turned off by -fomit-frame-pointer.\n@@ -148,1 +146,2 @@\n-  return frame(fr->link(), fr->link(), fr->sender_pc());\n+  ShouldNotReachHere();\n+  return frame();\n@@ -152,19 +151,2 @@\n-  typedef intptr_t*      get_fp_func           ();\n-  get_fp_func* func = CAST_TO_FN_PTR(get_fp_func*,\n-                                     StubRoutines::aarch64::get_previous_fp_entry());\n-  if (func == NULL) return frame();\n-  intptr_t* fp = (*func)();\n-  if (fp == NULL) {\n-    return frame();\n-  }\n-\n-  frame myframe((intptr_t*)os::current_stack_pointer(),\n-                (intptr_t*)fp,\n-                CAST_FROM_FN_PTR(address, os::current_frame));\n-  if (os::is_first_C_frame(&myframe)) {\n-\n-    \/\/ stack is not walkable\n-    return frame();\n-  } else {\n-    return os::get_sender_for_C_frame(&myframe);\n-  }\n+  return frame();  \/\/ cannot walk Windows frames this way.  See os::get_native_stack\n+                   \/\/ and os::platform_print_native_stack\n","filename":"src\/hotspot\/os_cpu\/windows_aarch64\/os_windows_aarch64.cpp","additions":4,"deletions":22,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -326,7 +326,0 @@\n-\/\/ VC++ does not save frame pointer on stack in optimized build. It\n-\/\/ can be turned off by \/Oy-. If we really want to walk C frames,\n-\/\/ we can use the StackWalk() API.\n-frame os::get_sender_for_C_frame(frame* fr) {\n-  return frame(fr->sender_sp(), fr->link(), fr->sender_pc());\n-}\n-\n@@ -393,15 +386,7 @@\n-#ifndef AMD64\n-intptr_t* _get_previous_fp() {\n-  intptr_t **frameptr;\n-  __asm {\n-    mov frameptr, ebp\n-  };\n-  \/\/ ebp (frameptr) is for this frame (_get_previous_fp). We want the ebp for the\n-  \/\/ caller of os::current_frame*(), so go up two frames. However, for\n-  \/\/ optimized builds, _get_previous_fp() will be inlined, so only go\n-  \/\/ up 1 frame in that case.\n-#ifdef _NMT_NOINLINE_\n-  return **(intptr_t***)frameptr;\n-#else\n-  return *frameptr;\n-#endif\n+\n+\/\/ VC++ does not save frame pointer on stack in optimized build. It\n+\/\/ can be turned off by \/Oy-. If we really want to walk C frames,\n+\/\/ we can use the StackWalk() API.\n+frame os::get_sender_for_C_frame(frame* fr) {\n+  ShouldNotReachHere();\n+  return frame();\n@@ -409,1 +394,0 @@\n-#endif \/\/ !AMD64\n@@ -412,24 +396,2 @@\n-\n-#ifdef AMD64\n-  \/\/ apparently _asm not supported on windows amd64\n-  typedef intptr_t*      get_fp_func           ();\n-  get_fp_func* func = CAST_TO_FN_PTR(get_fp_func*,\n-                                     StubRoutines::x86::get_previous_fp_entry());\n-  if (func == NULL) return frame();\n-  intptr_t* fp = (*func)();\n-  if (fp == NULL) {\n-    return frame();\n-  }\n-#else\n-  intptr_t* fp = _get_previous_fp();\n-#endif \/\/ AMD64\n-\n-  frame myframe((intptr_t*)os::current_stack_pointer(),\n-                (intptr_t*)fp,\n-                CAST_FROM_FN_PTR(address, os::current_frame));\n-  if (os::is_first_C_frame(&myframe)) {\n-    \/\/ stack is not walkable\n-    return frame();\n-  } else {\n-    return os::get_sender_for_C_frame(&myframe);\n-  }\n+  return frame();  \/\/ cannot walk Windows frames this way.  See os::get_native_stack\n+                   \/\/ and os::platform_print_native_stack\n","filename":"src\/hotspot\/os_cpu\/windows_x86\/os_windows_x86.cpp","additions":9,"deletions":47,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -1173,2 +1173,1 @@\n-\/\/ stack is walkable beyond current frame. The check for fp() is not\n-\/\/ necessary on Sparc, but it's harmless.\n+\/\/ stack is walkable beyond current frame.\n@@ -1176,0 +1175,5 @@\n+\n+#ifdef _WINDOWS\n+  return true; \/\/ native stack isn't walkable on windows this way.\n+#endif\n+\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,1 @@\n- * @run main\/othervm -Xmx256m -XX:MaxMetaspaceSize=64m -javaagent:redefineagent.jar -Xlog:all=trace:file=all.log RedefineClasses\n+ * @run main\/othervm -Xmx256m -XX:MaxMetaspaceSize=64m -javaagent:redefineagent.jar -XX:+Verbose -Xlog:all=trace:file=all.log RedefineClasses\n","filename":"test\/hotspot\/jtreg\/runtime\/logging\/RedefineClasses.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n- * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:+Verbose -Xlog:methodhandles TestMethodHandlesVerbose\n+ * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:+Verbose -Xlog:methodhandles TestMethodHandlesVerbose a b\n@@ -34,0 +34,1 @@\n+        System.out.println(args[0] + args[1]);\n","filename":"test\/hotspot\/jtreg\/runtime\/logging\/TestMethodHandlesVerbose.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"}]}