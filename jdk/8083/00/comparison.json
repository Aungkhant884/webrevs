{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,0 @@\n-#include \"classfile\/systemDictionary.hpp\"\n@@ -284,25 +283,0 @@\n-static bool is_klass_initialized(Symbol* klass_name) {\n-  VM_ENTRY_MARK;\n-  InstanceKlass* ik = SystemDictionary::find_instance_klass(klass_name, Handle(), Handle());\n-  return ik != nullptr && ik->is_initialized();\n-}\n-\n-bool ciInstanceKlass::is_box_cache_valid() const {\n-  BasicType box_type = box_klass_type();\n-\n-  if (box_type != T_OBJECT) {\n-    switch(box_type) {\n-      case T_INT:     return is_klass_initialized(java_lang_Integer_IntegerCache::symbol());\n-      case T_CHAR:    return is_klass_initialized(java_lang_Character_CharacterCache::symbol());\n-      case T_SHORT:   return is_klass_initialized(java_lang_Short_ShortCache::symbol());\n-      case T_BYTE:    return is_klass_initialized(java_lang_Byte_ByteCache::symbol());\n-      case T_LONG:    return is_klass_initialized(java_lang_Long_LongCache::symbol());\n-      case T_BOOLEAN:\n-      case T_FLOAT:\n-      case T_DOUBLE:  return true;\n-      default:;\n-    }\n-  }\n-  return false;\n-}\n-\n","filename":"src\/hotspot\/share\/ci\/ciInstanceKlass.cpp","additions":1,"deletions":27,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -268,1 +268,0 @@\n-  bool is_box_cache_valid() const;\n","filename":"src\/hotspot\/share\/ci\/ciInstanceKlass.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -585,56 +585,0 @@\n-static bool has_non_debug_usages(Node* n) {\n-  for (DUIterator_Fast imax, i = n->fast_outs(imax); i < imax; i++) {\n-    Node* m = n->fast_out(i);\n-    if (!m->is_SafePoint()\n-        || (m->is_Call() && m->as_Call()->has_non_debug_use(n))) {\n-      return true;\n-    }\n-  }\n-  return false;\n-}\n-\n-static bool is_box_cache_valid(CallNode* call) {\n-  ciInstanceKlass* klass = call->as_CallStaticJava()->method()->holder();\n-  return klass->is_box_cache_valid();\n-}\n-\n-\/\/ delay box in runtime, treat box as a scalarized object\n-static void scalarize_debug_usages(CallNode* call, Node* resproj) {\n-  GraphKit kit(call->jvms());\n-  PhaseGVN& gvn = kit.gvn();\n-\n-  ProjNode* res = resproj->as_Proj();\n-  ciInstanceKlass* klass = call->as_CallStaticJava()->method()->holder();\n-  int n_fields = klass->nof_nonstatic_fields();\n-  assert(n_fields == 1, \"the klass must be an auto-boxing klass\");\n-\n-  for (DUIterator_Last imin, i = res->last_outs(imin); i >= imin;) {\n-    SafePointNode* sfpt = res->last_out(i)->as_SafePoint();\n-    uint first_ind = sfpt->req() - sfpt->jvms()->scloff();\n-    Node* sobj = new SafePointScalarObjectNode(gvn.type(res)->isa_oopptr(),\n-#ifdef ASSERT\n-                                                call,\n-#endif \/\/ ASSERT\n-                                                first_ind, n_fields, true);\n-    sobj->init_req(0, kit.root());\n-    sfpt->add_req(call->in(TypeFunc::Parms));\n-    sobj = gvn.transform(sobj);\n-    JVMState* jvms = sfpt->jvms();\n-    jvms->set_endoff(sfpt->req());\n-    int start = jvms->debug_start();\n-    int end   = jvms->debug_end();\n-    int num_edges = sfpt->replace_edges_in_range(res, sobj, start, end, &gvn);\n-    i -= num_edges;\n-  }\n-\n-  assert(res->outcnt() == 0, \"the box must have no use after replace\");\n-\n-#ifndef PRODUCT\n-  if (PrintEliminateAllocations) {\n-    tty->print(\"++++ Eliminated: %d \", call->_idx);\n-    call->as_CallStaticJava()->method()->print_short_name(tty);\n-    tty->cr();\n-  }\n-#endif\n-}\n-\n@@ -690,16 +634,3 @@\n-  bool result_not_used = false;\n-\n-  if (is_pure_call()) {\n-    \/\/ Disabled due to JDK-8276112\n-    if (false && is_boxing_late_inline() && callprojs.resproj != nullptr) {\n-      \/\/ replace box node to scalar node only in case it is directly referenced by debug info\n-      assert(call->as_CallStaticJava()->is_boxing_method(), \"sanity\");\n-      if (!has_non_debug_usages(callprojs.resproj) && is_box_cache_valid(call)) {\n-        scalarize_debug_usages(call, callprojs.resproj);\n-      }\n-    }\n-\n-    \/\/ The call is marked as pure (no important side effects), but result isn't used.\n-    \/\/ It's safe to remove the call.\n-    result_not_used = (callprojs.resproj == NULL || callprojs.resproj->outcnt() == 0);\n-  }\n+  \/\/ The call is marked as pure (no important side effects), but result isn't used.\n+  \/\/ It's safe to remove the call.\n+  bool result_not_used = (callprojs.resproj == NULL || callprojs.resproj->outcnt() == 0);\n@@ -707,1 +638,1 @@\n-  if (result_not_used) {\n+  if (is_pure_call() && result_not_used) {\n@@ -835,2 +766,0 @@\n-  virtual bool is_boxing_late_inline() const { return true; }\n-\n","filename":"src\/hotspot\/share\/opto\/callGenerator.cpp","additions":5,"deletions":76,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -77,1 +77,0 @@\n-  virtual bool      is_boxing_late_inline() const  { return false; }\n","filename":"src\/hotspot\/share\/opto\/callGenerator.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1570,2 +1570,1 @@\n-                                                     uint n_fields,\n-                                                     bool is_auto_box) :\n+                                                     uint n_fields) :\n@@ -1574,2 +1573,1 @@\n-  _n_fields(n_fields),\n-  _is_auto_box(is_auto_box)\n+  _n_fields(n_fields)\n@@ -1582,2 +1580,1 @@\n-      && !(alloc->Opcode() == Op_VectorBox)\n-      && (!alloc->is_CallStaticJava() || !alloc->as_CallStaticJava()->is_boxing_method())) {\n+      && !(alloc->Opcode() == Op_VectorBox)) {\n","filename":"src\/hotspot\/share\/opto\/callnode.cpp","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -515,1 +515,0 @@\n-  bool _is_auto_box; \/\/ True if the scalarized object is an auto box.\n@@ -528,1 +527,1 @@\n-                            uint first_index, uint n_fields, bool is_auto_box = false);\n+                            uint first_index, uint n_fields);\n@@ -541,1 +540,0 @@\n-  bool is_auto_box() const { return _is_auto_box; }\n","filename":"src\/hotspot\/share\/opto\/callnode.hpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -822,3 +822,2 @@\n-      ScopeValue* klass_sv = new ConstantOopWriteValue(cik->java_mirror()->constant_encoding());\n-      sv = spobj->is_auto_box() ? new AutoBoxObjectValue(spobj->_idx, klass_sv)\n-                                    : new ObjectValue(spobj->_idx, klass_sv);\n+      sv = new ObjectValue(spobj->_idx,\n+                           new ConstantOopWriteValue(cik->java_mirror()->constant_encoding()));\n@@ -1096,3 +1095,2 @@\n-          ScopeValue* klass_sv = new ConstantOopWriteValue(cik->java_mirror()->constant_encoding());\n-          ObjectValue* sv = spobj->is_auto_box() ? new AutoBoxObjectValue(spobj->_idx, klass_sv)\n-                                        : new ObjectValue(spobj->_idx, klass_sv);\n+          ObjectValue* sv = new ObjectValue(spobj->_idx,\n+                                            new ConstantOopWriteValue(cik->java_mirror()->constant_encoding()));\n","filename":"src\/hotspot\/share\/opto\/output.cpp","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"}]}