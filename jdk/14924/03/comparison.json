{"files":[{"patch":"@@ -108,68 +108,0 @@\n-    \/**\n-     * Get the current cache lifetime setting\n-     *\n-     * @return the current cache lifetime value\n-     *\/\n-    int getCacheLifetime() {\n-        return cacheLifetime;\n-    }\n-\n-    \/**\n-     * Get the current maximum cache size.\n-     *\n-     * @return the current maximum cache size\n-     *\/\n-    int getCacheCapacity() {\n-        return cacheCapacity;\n-    }\n-\n-    \/**\n-     * Get the default OCSP responder URI, if previously set.\n-     *\n-     * @return the current default OCSP responder URI, or {@code null} if\n-     *      it has not been set.\n-     *\/\n-    URI getDefaultResponder() {\n-        return defaultResponder;\n-    }\n-\n-    \/**\n-     * Get the URI override setting\n-     *\n-     * @return {@code true} if URI override has been set, {@code false}\n-     * otherwise.\n-     *\/\n-    boolean getURIOverride() {\n-        return respOverride;\n-    }\n-\n-    \/**\n-     * Get the ignore extensions setting.\n-     *\n-     * @return {@code true} if the {@code StatusResponseManager} will not\n-     * pass OCSP Extensions in the TLS {@code status_request[_v2]}\n-     * extensions, {@code false} if extensions will be passed (the default).\n-     *\/\n-    boolean getIgnoreExtensions() {\n-        return ignoreExtensions;\n-    }\n-\n-    \/**\n-     * Clear the status response cache\n-     *\/\n-    void clear() {\n-        if (SSLLogger.isOn && SSLLogger.isOn(\"respmgr\")) {\n-            SSLLogger.fine(\"Clearing response cache\");\n-        }\n-        responseCache.clear();\n-    }\n-\n-    \/**\n-     * Returns the number of currently valid objects in the response cache.\n-     *\n-     * @return the number of valid objects in the response cache.\n-     *\/\n-    int size() {\n-        return responseCache.size();\n-    }\n-\n@@ -214,11 +146,0 @@\n-    \/**\n-     * Shutdown the thread pool\n-     *\/\n-    void shutdown() {\n-        if (SSLLogger.isOn && SSLLogger.isOn(\"respmgr\")) {\n-            SSLLogger.fine(\"Shutting down \" + threadMgr.getActiveCount() +\n-                    \" active threads\");\n-        }\n-        threadMgr.shutdown();\n-    }\n-\n@@ -450,14 +371,0 @@\n-        \/**\n-         * Create a StatusInfo object from certificate data.\n-         *\n-         * @param subjectCert the certificate to be checked for revocation\n-         * @param issuerCert the issuer of the {@code subjectCert}\n-         *\n-         * @throws IOException if CertId creation from the certificate fails\n-         *\/\n-        StatusInfo(X509Certificate subjectCert, X509Certificate issuerCert)\n-                throws IOException {\n-            this(subjectCert, new CertId(issuerCert,\n-                    new SerialNumber(subjectCert.getSerialNumber())));\n-        }\n-\n@@ -478,15 +385,0 @@\n-        \/**\n-         * Copy constructor (used primarily for rescheduling).\n-         * This will do a member-wise copy except for the\n-         * responseData and extensions fields, which should not persist\n-         * in a rescheduled fetch.\n-         *\n-         * @param orig the original {@code StatusInfo}\n-         *\/\n-        StatusInfo(StatusInfo orig) {\n-            this.cert = orig.cert;\n-            this.cid = orig.cid;\n-            this.responder = orig.responder;\n-            this.responseData = null;\n-        }\n-\n@@ -690,32 +582,0 @@\n-        \/**\n-         * Determine the delay to use when scheduling the task that will\n-         * update the OCSP response.  This is the shorter time between the\n-         * cache lifetime and the nextUpdate.  If no nextUpdate is present\n-         * in the response, then only the cache lifetime is used.\n-         * If cache timeouts are disabled (a zero value) and there's no\n-         * nextUpdate, then the entry is not cached and no rescheduling\n-         * will take place.\n-         *\n-         * @param nextUpdate a {@code Date} object corresponding to the\n-         *      next update time from a SingleResponse.\n-         *\n-         * @return the number of seconds of delay before the next fetch\n-         *      should be executed.  A zero value means that the fetch\n-         *      should happen immediately, while a value less than zero\n-         *      indicates no rescheduling should be done.\n-         *\/\n-        private long getNextTaskDelay(Date nextUpdate) {\n-            long delaySec;\n-            int lifetime = getCacheLifetime();\n-\n-            if (nextUpdate != null) {\n-                long nuDiffSec = (nextUpdate.getTime() -\n-                        System.currentTimeMillis()) \/ 1000;\n-                delaySec = lifetime > 0 ? Long.min(nuDiffSec, lifetime) :\n-                        nuDiffSec;\n-            } else {\n-                delaySec = lifetime > 0 ? lifetime : -1;\n-            }\n-\n-            return delaySec;\n-        }\n@@ -887,1 +747,1 @@\n-                    if (respDER == null || respDER.length <= 0) {\n+                    if (respDER == null || respDER.length == 0) {\n@@ -912,1 +772,0 @@\n-            params = null;\n@@ -937,1 +796,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/StatusResponseManager.java","additions":1,"deletions":143,"binary":false,"changes":144,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import java.lang.reflect.Field;\n@@ -52,0 +53,2 @@\n+    private static Field responseCacheField;\n+\n@@ -72,0 +75,4 @@\n+        responseCacheField =\n+                StatusResponseManager.class.getDeclaredField(\"responseCache\");\n+        responseCacheField.setAccessible(true);\n+\n@@ -121,1 +128,1 @@\n-                } else if (srm.size() != 1) {\n+                } else if (responseCacheSize(srm) != 1) {\n@@ -123,1 +130,1 @@\n-                            \"expected 1, got \" + srm.size();\n+                            \"expected 1, got \" + responseCacheSize(srm);\n@@ -152,1 +159,1 @@\n-                if (srm.size() != 2) {\n+                if (responseCacheSize(srm) != 2) {\n@@ -154,1 +161,1 @@\n-                            + srm.size();\n+                            + responseCacheSize(srm);\n@@ -157,2 +164,2 @@\n-                    srm.clear();\n-                    if (srm.size() != 0) {\n+                    clearResponseCache(srm);\n+                    if (responseCacheSize(srm) != 0) {\n@@ -160,1 +167,1 @@\n-                                \" got \" + srm.size();\n+                                \" got \" + responseCacheSize(srm);\n@@ -200,1 +207,1 @@\n-                } else if (srm.size() != 2) {\n+                } else if (responseCacheSize(srm) != 2) {\n@@ -202,1 +209,1 @@\n-                            \"expected 2, got \" + srm.size();\n+                            \"expected 2, got \" + responseCacheSize(srm);\n@@ -233,1 +240,1 @@\n-                if (srm.size() != 2) {\n+                if (responseCacheSize(srm) != 2) {\n@@ -235,1 +242,1 @@\n-                            + srm.size();\n+                            + responseCacheSize(srm);\n@@ -240,1 +247,1 @@\n-                    if (srm.size() != 0) {\n+                    if (responseCacheSize(srm) != 0) {\n@@ -242,1 +249,1 @@\n-                                \" got \" + srm.size();\n+                                \" got \" + responseCacheSize(srm);\n@@ -429,0 +436,10 @@\n+    private static int responseCacheSize(\n+            StatusResponseManager srm) throws IllegalAccessException {\n+        return ((sun.security.util.Cache)responseCacheField.get(srm)).size();\n+    }\n+\n+    private static void clearResponseCache(\n+            StatusResponseManager srm) throws IllegalAccessException {\n+        ((sun.security.util.Cache)responseCacheField.get(srm)).clear();\n+    }\n+\n","filename":"test\/jdk\/sun\/security\/ssl\/Stapling\/java.base\/sun\/security\/ssl\/StatusResponseManagerTests.java","additions":30,"deletions":13,"binary":false,"changes":43,"status":"modified"}]}