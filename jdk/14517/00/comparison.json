{"files":[{"patch":"@@ -1450,6 +1450,1 @@\n-        if (!breaksOutOf(tree, tree.body)) {\n-            \/\/include condition's body when false after the while, if cannot get out of the loop\n-            MatchBindings condBindings = matchBindings;\n-            condBindings.bindingsWhenFalse.forEach(env.info.scope::enter);\n-            condBindings.bindingsWhenFalse.forEach(BindingSymbol::preserveBinding);\n-        }\n+        handleLoopConditionBindings(matchBindings, tree, tree.body);\n@@ -1469,5 +1464,1 @@\n-        if (!breaksOutOf(tree, tree.body)) {\n-            \/\/include condition's bindings when false after the while, if cannot get out of the loop\n-            condBindings.bindingsWhenFalse.forEach(env.info.scope::enter);\n-            condBindings.bindingsWhenFalse.forEach(BindingSymbol::preserveBinding);\n-        }\n+        handleLoopConditionBindings(condBindings, tree, tree.body);\n@@ -1477,5 +1468,0 @@\n-    private boolean breaksOutOf(JCTree loop, JCTree body) {\n-        preFlow(body);\n-        return flow.breaksOutOf(env, loop, body, make);\n-    }\n-\n@@ -1506,4 +1492,12 @@\n-        if (!breaksOutOf(tree, tree.body)) {\n-            \/\/include condition's body when false after the while, if cannot get out of the loop\n-            condBindings.bindingsWhenFalse.forEach(env.info.scope::enter);\n-            condBindings.bindingsWhenFalse.forEach(BindingSymbol::preserveBinding);\n+        handleLoopConditionBindings(condBindings, tree, tree.body);\n+    }\n+\n+    \/**\n+     * Include condition's bindings when false after the loop, if cannot get out of the loop\n+     *\/\n+    private void handleLoopConditionBindings(MatchBindings condBindings,\n+                                             JCStatement loop,\n+                                             JCStatement loopBody) {\n+        if (condBindings.bindingsWhenFalse.nonEmpty() &&\n+            !breaksTo(env, loop, loopBody)) {\n+            addBindings2Scope(loop, condBindings.bindingsWhenFalse);\n@@ -1513,0 +1507,31 @@\n+    private boolean breaksTo(Env<AttrContext> env, JCTree loop, JCTree body) {\n+        preFlow(body);\n+        return flow.breaksToTree(env, loop, body, make);\n+    }\n+\n+    \/**\n+     * Add given bindings to the current scope, unless there's a break to\n+     * an immediately enclosing labeled statement.\n+     *\/\n+    private void addBindings2Scope(JCStatement introducingStatement,\n+                                   List<BindingSymbol> bindings) {\n+        if (bindings.isEmpty()) {\n+            return ;\n+        }\n+\n+        var searchEnv = env;\n+        while (searchEnv.tree instanceof JCLabeledStatement labeled &&\n+               labeled.body == introducingStatement) {\n+            if (breaksTo(env, labeled, labeled.body)) {\n+                \/\/breaking to an immediately enclosing labeled statement\n+                return ;\n+            }\n+            searchEnv = searchEnv.next;\n+            introducingStatement = labeled;\n+        }\n+\n+        \/\/include condition's body when false after the while, if cannot get out of the loop\n+        bindings.forEach(env.info.scope::enter);\n+        bindings.forEach(BindingSymbol::preserveBinding);\n+    }\n+\n@@ -2245,2 +2270,1 @@\n-        afterIfBindings.forEach(env.info.scope::enter);\n-        afterIfBindings.forEach(BindingSymbol::preserveBinding);\n+        addBindings2Scope(tree, afterIfBindings);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":46,"deletions":22,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -290,1 +290,1 @@\n-    public boolean breaksOutOf(Env<AttrContext> env, JCTree loop, JCTree body, TreeMaker make) {\n+    public boolean breaksToTree(Env<AttrContext> env, JCTree breakTo, JCTree body, TreeMaker make) {\n@@ -298,1 +298,1 @@\n-            SnippetBreakAnalyzer analyzer = new SnippetBreakAnalyzer();\n+            SnippetBreakToAnalyzer analyzer = new SnippetBreakToAnalyzer(breakTo);\n@@ -301,1 +301,1 @@\n-            return analyzer.breaksOut();\n+            return analyzer.breaksTo();\n@@ -1912,3 +1912,3 @@\n-    class SnippetBreakAnalyzer extends AliveAnalyzer {\n-        private final Set<JCTree> seenTrees = new HashSet<>();\n-        private boolean breaksOut;\n+    class SnippetBreakToAnalyzer extends AliveAnalyzer {\n+        private final JCTree breakTo;\n+        private boolean breaksTo;\n@@ -1916,31 +1916,2 @@\n-        public SnippetBreakAnalyzer() {\n-        }\n-\n-        @Override\n-        public void visitLabelled(JCTree.JCLabeledStatement tree) {\n-            seenTrees.add(tree);\n-            super.visitLabelled(tree);\n-        }\n-\n-        @Override\n-        public void visitWhileLoop(JCTree.JCWhileLoop tree) {\n-            seenTrees.add(tree);\n-            super.visitWhileLoop(tree);\n-        }\n-\n-        @Override\n-        public void visitForLoop(JCTree.JCForLoop tree) {\n-            seenTrees.add(tree);\n-            super.visitForLoop(tree);\n-        }\n-\n-        @Override\n-        public void visitForeachLoop(JCTree.JCEnhancedForLoop tree) {\n-            seenTrees.add(tree);\n-            super.visitForeachLoop(tree);\n-        }\n-\n-        @Override\n-        public void visitDoLoop(JCTree.JCDoWhileLoop tree) {\n-            seenTrees.add(tree);\n-            super.visitDoLoop(tree);\n+        public SnippetBreakToAnalyzer(JCTree breakTo) {\n+            this.breakTo = breakTo;\n@@ -1951,3 +1922,1 @@\n-            breaksOut |= (super.alive == Liveness.ALIVE &&\n-                          !seenTrees.contains(tree.target));\n-            super.visitBreak(tree);\n+            breaksTo |= breakTo == tree.target && super.alive == Liveness.ALIVE;\n@@ -1956,2 +1925,2 @@\n-        public boolean breaksOut() {\n-            return breaksOut;\n+        public boolean breaksTo() {\n+            return breaksTo;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Flow.java","additions":11,"deletions":42,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -234,0 +234,61 @@\n+        {\n+            L: {\n+                while (!(o1 instanceof String s)) {\n+                    break L;\n+                }\n+\n+                s.length();\n+            }\n+        }\n+\n+        {\n+            L: {\n+                for (; !(o1 instanceof String s); ) {\n+                    break L;\n+                }\n+\n+                s.length();\n+            }\n+        }\n+\n+        {\n+            int j = 0;\n+            L: while (j++ < 2)\n+                   if (!(o1 instanceof String s)) {\n+                       break L;\n+                   }\n+        }\n+\n+        {\n+            int j = 0;\n+            L: for (; j++ < 2; )\n+                   if (!(o1 instanceof String s)) {\n+                       break L;\n+                   }\n+        }\n+\n+        {\n+            \/\/\"s\" in the outter scope does not flow out of the if, but\n+            \/\/variables inside a lambda or anonymous or local class may:\n+            L: if (!(o1 instanceof String s)) {\n+                Runnable r = () -> {\n+                    NESTED: {\n+                        if (!(o1 instanceof String n)) {\n+                            break NESTED;\n+                        }\n+\n+                        n.length();\n+                    }\n+                };\n+                break L;\n+            }\n+        }\n+\n+        switch (0) {\n+            case 0:\n+                if (!(o1 instanceof String s)) {\n+                    break;\n+                }\n+                s.length();\n+        }\n+\n","filename":"test\/langtools\/tools\/javac\/patterns\/BindingsTest1.java","additions":61,"deletions":0,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -250,0 +250,57 @@\n+        {\n+            LBL1: LBL2: if (!(o1 instanceof String s)) {\n+                break LBL1;\n+            }\n+\n+            System.err.println(s);\n+        }\n+        {\n+            LBL1: LBL2: if (!(o1 instanceof String s)) {\n+                break LBL2;\n+            }\n+\n+            System.err.println(s);\n+        }\n+        {\n+            LBL1: LBL2: if (o1 instanceof String s) {\n+            } else {\n+                break LBL1;\n+            }\n+\n+            System.err.println(s);\n+        }\n+        {\n+            LBL1: LBL2: if (o1 instanceof String s) {\n+            } else {\n+                break LBL2;\n+            }\n+\n+            System.err.println(s);\n+        }\n+        {\n+            switch (0) {\n+                case 0:\n+                    if (!(o1 instanceof String s)) {\n+                        break;\n+                    }\n+            }\n+            s.length();\n+        }\n+\n+        {\n+            int j = 0;\n+            L: while (j++ < 2)\n+                   if (!(o1 instanceof String s)) {\n+                       break L;\n+                   }\n+            s.length();\n+        }\n+\n+        {\n+            int j = 0;\n+            L: for (; j++ < 2; )\n+                   if (!(o1 instanceof String s)) {\n+                       break L;\n+                   }\n+            s.length();\n+        }\n","filename":"test\/langtools\/tools\/javac\/patterns\/BindingsTest2.java","additions":57,"deletions":0,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -46,3 +46,0 @@\n-BindingsTest2.java:221:17: compiler.err.cant.resolve.location: kindname.variable, s, , , (compiler.misc.location: kindname.class, BindingsTest2, null)\n-BindingsTest2.java:231:17: compiler.err.cant.resolve.location: kindname.variable, s, , , (compiler.misc.location: kindname.class, BindingsTest2, null)\n-BindingsTest2.java:241:17: compiler.err.cant.resolve.location: kindname.variable, s, , , (compiler.misc.location: kindname.class, BindingsTest2, null)\n@@ -50,0 +47,7 @@\n+BindingsTest2.java:255:32: compiler.err.cant.resolve.location: kindname.variable, s, , , (compiler.misc.location: kindname.class, BindingsTest2, null)\n+BindingsTest2.java:262:32: compiler.err.cant.resolve.location: kindname.variable, s, , , (compiler.misc.location: kindname.class, BindingsTest2, null)\n+BindingsTest2.java:270:32: compiler.err.cant.resolve.location: kindname.variable, s, , , (compiler.misc.location: kindname.class, BindingsTest2, null)\n+BindingsTest2.java:278:32: compiler.err.cant.resolve.location: kindname.variable, s, , , (compiler.misc.location: kindname.class, BindingsTest2, null)\n+BindingsTest2.java:287:13: compiler.err.cant.resolve.location: kindname.variable, s, , , (compiler.misc.location: kindname.class, BindingsTest2, null)\n+BindingsTest2.java:296:13: compiler.err.cant.resolve.location: kindname.variable, s, , , (compiler.misc.location: kindname.class, BindingsTest2, null)\n+BindingsTest2.java:305:13: compiler.err.cant.resolve.location: kindname.variable, s, , , (compiler.misc.location: kindname.class, BindingsTest2, null)\n@@ -53,1 +57,2 @@\n-52 errors\n+BindingsTest2.java:241:17: compiler.err.unreachable.stmt\n+57 errors\n\\ No newline at end of file\n","filename":"test\/langtools\/tools\/javac\/patterns\/BindingsTest2.out","additions":9,"deletions":4,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -107,0 +107,11 @@\n+             } else if (outterLabel == OutterLabel.LABEL && brk == Break.BREAK_LABEL && outterLoop != OutterLoop.NONE) {\n+                 shouldPass = switch(mainLoop) {\n+                     case WHILE, FOR -> true;\n+                     case DO_WHILE -> switch (innerLoop) {\n+                         case WHILE, FOR, FOR_EACH -> true;\n+                         \/\/the statement following the do-while is unreachable:\n+                         case BLOCK, DO_WHILE, NONE -> {\n+                             yield false;\n+                         }\n+                     };\n+                 };\n","filename":"test\/langtools\/tools\/javac\/patterns\/BreakAndLoops.java","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"}]}