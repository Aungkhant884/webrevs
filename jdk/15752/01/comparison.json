{"files":[{"patch":"@@ -30,1 +30,0 @@\n-#include \"classfile\/placeholders.hpp\"\n@@ -34,1 +33,0 @@\n-#include \"oops\/oop.inline.hpp\"\n@@ -36,1 +34,0 @@\n-#include \"runtime\/handles.inline.hpp\"\n@@ -38,1 +35,0 @@\n-#include \"runtime\/safepoint.hpp\"\n@@ -450,0 +446,16 @@\n+\/\/ Removes a class that was added to the table then class loading subsequently failed for this class.\n+void LoaderConstraintTable::remove_failed_loaded_klass(InstanceKlass* klass,\n+                                                       ClassLoaderData* loader) {\n+\n+  Symbol* name = klass->name();\n+  LoaderConstraint *p = find_loader_constraint(name, loader);\n+  if (p != nullptr && p->klass() != nullptr && p->klass() == klass) {\n+    \/\/ If this is the klass in the constraint, the error was OOM from the ClassLoader.addClass() call.\n+    \/\/ other errors during loading will not have added this klass.\n+    log_info(class, loader, constraints)(\"removing klass %s: failed to load\", name->as_C_string());\n+    \/\/ We only null out the class, since the constraint for the class name for this loader is still valid as\n+    \/\/ it was added when checking signature loaders for a method or field resolution.\n+    p->set_klass(nullptr);\n+  }\n+}\n+\n@@ -514,9 +526,2 @@\n-        } else {\n-          \/\/ If we don't find the class in the dictionary, it\n-          \/\/ has to be in the placeholders table.\n-          PlaceholderEntry* entry = PlaceholderTable::get_entry(name, loader_data);\n-\n-          \/\/ The InstanceKlass might not be on the entry, so the only\n-          \/\/ thing we can check here is whether we were successful in\n-          \/\/ finding the class in the placeholders table.\n-          guarantee(entry != nullptr, \"klass should be in the placeholders\");\n+          \/\/ If we don't find the class in the dictionary, it is\n+          \/\/ in the process of loading and may or may not be in the placeholder table.\n","filename":"src\/hotspot\/share\/classfile\/loaderConstraints.cpp","additions":18,"deletions":13,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -62,0 +62,1 @@\n+  static void remove_failed_loaded_klass(InstanceKlass* k, ClassLoaderData* loader);\n","filename":"src\/hotspot\/share\/classfile\/loaderConstraints.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1529,0 +1529,4 @@\n+\n+    \/\/ Also remove this InstanceKlass from the LoaderConstraintTable if added.\n+    MutexLocker ml(SystemDictionary_lock);\n+    LoaderConstraintTable::remove_failed_loaded_klass(k, class_loader_data(class_loader));\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"}]}