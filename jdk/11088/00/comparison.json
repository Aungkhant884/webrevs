{"files":[{"patch":"@@ -172,2 +172,31 @@\n-os::Linux::mallinfo_func_t os::Linux::_mallinfo = NULL;\n-os::Linux::mallinfo2_func_t os::Linux::_mallinfo2 = NULL;\n+\/\/ We want to be buildable and runnable on older and newer glibcs, so resolve both\n+\/\/ mallinfo and mallinfo2 dynamically.\n+struct old_mallinfo {\n+  int arena;\n+  int ordblks;\n+  int smblks;\n+  int hblks;\n+  int hblkhd;\n+  int usmblks;\n+  int fsmblks;\n+  int uordblks;\n+  int fordblks;\n+  int keepcost;\n+};\n+typedef struct old_mallinfo (*mallinfo_func_t)(void);\n+static mallinfo_func_t g_mallinfo = NULL;\n+\n+struct new_mallinfo {\n+  size_t arena;\n+  size_t ordblks;\n+  size_t smblks;\n+  size_t hblks;\n+  size_t hblkhd;\n+  size_t usmblks;\n+  size_t fsmblks;\n+  size_t uordblks;\n+  size_t fordblks;\n+  size_t keepcost;\n+};\n+typedef struct new_mallinfo (*mallinfo2_func_t)(void);\n+static mallinfo2_func_t g_mallinfo2 = NULL;\n@@ -2105,20 +2134,11 @@\n-  if (_mallinfo2 != NULL) {\n-    struct glibc_mallinfo2 mi = _mallinfo2();\n-    total_allocated = mi.uordblks + mi.hblkhd;\n-    free_retained = mi.fordblks;\n-  } else if (_mallinfo != NULL) {\n-    \/\/ mallinfo is an old API. Member names mean next to nothing and, beyond that, are 32-bit signed.\n-    \/\/ So for larger footprints the values may have wrapped around. We try to detect this here: if the\n-    \/\/ process whole resident set size is smaller than 4G, malloc footprint has to be less than that\n-    \/\/ and the numbers are reliable.\n-    struct glibc_mallinfo mi = _mallinfo();\n-    total_allocated = (size_t)(unsigned)mi.uordblks + (size_t)(unsigned)mi.hblkhd;\n-    free_retained = (size_t)(unsigned)mi.fordblks;\n-    \/\/ Since mallinfo members are int, glibc values may have wrapped. Warn about this.\n-    might_have_wrapped = (info.vmrss * K) > UINT_MAX && (info.vmrss * K) > (total_allocated + UINT_MAX);\n-  }\n-  if (_mallinfo2 != NULL || _mallinfo != NULL) {\n-    st->print_cr(\"C-Heap outstanding allocations: \" SIZE_FORMAT \"K, retained: \" SIZE_FORMAT \"K%s\",\n-                 total_allocated \/ K, free_retained \/ K,\n-                 might_have_wrapped ? \" (may have wrapped)\" : \"\");\n-  }\n+  glibc_mallinfo mi;\n+  os::Linux::get_mallinfo(&mi, &might_have_wrapped);\n+  total_allocated = mi.uordblks + mi.hblkhd;\n+  free_retained = mi.fordblks;\n+#ifdef _LP64\n+  \/\/ If legacy mallinfo(), we can still print the values if we are sure they cannot have wrapped.\n+  might_have_wrapped = might_have_wrapped && (info.vmsize * K) > UINT_MAX;\n+#endif\n+  st->print_cr(\"C-Heap outstanding allocations: \" SIZE_FORMAT \"K, retained: \" SIZE_FORMAT \"K%s\",\n+               total_allocated \/ K, free_retained \/ K,\n+               might_have_wrapped ? \" (may have wrapped)\" : \"\");\n@@ -4276,2 +4296,2 @@\n-  Linux::_mallinfo = CAST_TO_FN_PTR(Linux::mallinfo_func_t, dlsym(RTLD_DEFAULT, \"mallinfo\"));\n-  Linux::_mallinfo2 = CAST_TO_FN_PTR(Linux::mallinfo2_func_t, dlsym(RTLD_DEFAULT, \"mallinfo2\"));\n+  g_mallinfo = CAST_TO_FN_PTR(mallinfo_func_t, dlsym(RTLD_DEFAULT, \"mallinfo\"));\n+  g_mallinfo2 = CAST_TO_FN_PTR(mallinfo2_func_t, dlsym(RTLD_DEFAULT, \"mallinfo2\"));\n@@ -5334,0 +5354,36 @@\n+\n+#ifdef __GLIBC__\n+void os::Linux::get_mallinfo(glibc_mallinfo* out, bool* might_have_wrapped) {\n+  if (g_mallinfo2) {\n+    new_mallinfo mi = g_mallinfo2();\n+    out->arena = mi.arena;\n+    out->ordblks = mi.ordblks;\n+    out->smblks = mi.smblks;\n+    out->hblks = mi.hblks;\n+    out->hblkhd = mi.hblkhd;\n+    out->usmblks = mi.usmblks;\n+    out->fsmblks = mi.fsmblks;\n+    out->uordblks = mi.uordblks;\n+    out->fordblks = mi.fordblks;\n+    out->keepcost =  mi.keepcost;\n+    *might_have_wrapped = false;\n+  } else if (g_mallinfo) {\n+    old_mallinfo mi = g_mallinfo();\n+    \/\/ glibc reports unsigned 32-bit sizes in int form. First make unsigned, then extend.\n+    out->arena = (size_t)(unsigned)mi.arena;\n+    out->ordblks = (size_t)(unsigned)mi.ordblks;\n+    out->smblks = (size_t)(unsigned)mi.smblks;\n+    out->hblks = (size_t)(unsigned)mi.hblks;\n+    out->hblkhd = (size_t)(unsigned)mi.hblkhd;\n+    out->usmblks = (size_t)(unsigned)mi.usmblks;\n+    out->fsmblks = (size_t)(unsigned)mi.fsmblks;\n+    out->uordblks = (size_t)(unsigned)mi.uordblks;\n+    out->fordblks = (size_t)(unsigned)mi.fordblks;\n+    out->keepcost = (size_t)(unsigned)mi.keepcost;\n+    *might_have_wrapped = NOT_LP64(false) LP64_ONLY(true);\n+  } else {\n+    \/\/ We should have either mallinfo or mallinfo2\n+    ShouldNotReachHere();\n+  }\n+}\n+#endif \/\/ __GLIBC__\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":80,"deletions":24,"binary":false,"changes":104,"status":"modified"},{"patch":"@@ -175,1 +175,1 @@\n-  \/\/ Output structure for query_process_memory_info()\n+  \/\/ Output structure for query_process_memory_info() (all values in KB)\n@@ -268,34 +268,0 @@\n-#ifdef __GLIBC__\n-  struct glibc_mallinfo {\n-    int arena;\n-    int ordblks;\n-    int smblks;\n-    int hblks;\n-    int hblkhd;\n-    int usmblks;\n-    int fsmblks;\n-    int uordblks;\n-    int fordblks;\n-    int keepcost;\n-  };\n-\n-  struct glibc_mallinfo2 {\n-    size_t arena;\n-    size_t ordblks;\n-    size_t smblks;\n-    size_t hblks;\n-    size_t hblkhd;\n-    size_t usmblks;\n-    size_t fsmblks;\n-    size_t uordblks;\n-    size_t fordblks;\n-    size_t keepcost;\n-  };\n-\n-  typedef struct glibc_mallinfo (*mallinfo_func_t)(void);\n-  typedef struct glibc_mallinfo2 (*mallinfo2_func_t)(void);\n-\n-  static mallinfo_func_t _mallinfo;\n-  static mallinfo2_func_t _mallinfo2;\n-#endif\n-\n@@ -429,0 +395,33 @@\n+\n+#ifdef __GLIBC__\n+  \/\/ os::Linux::get_mallinfo() hides the complexity of dealing with mallinfo() or\n+  \/\/ mallinfo2() from the user. Use this function instead of raw mallinfo\/mallinfo2()\n+  \/\/ to keep the JVM runtime-compatible with different glibc versions.\n+  \/\/\n+  \/\/ mallinfo2() was added with glibc (>2.32). Legacy mallinfo() was deprecated with\n+  \/\/ 2.33 and may vanish in future glibcs. So we may have both or either one of\n+  \/\/ them.\n+  \/\/\n+  \/\/ mallinfo2() is functionally equivalent to legacy mallinfo but returns sizes as\n+  \/\/ 64-bit on 64-bit platforms. Legacy mallinfo uses 32-bit fields. However, legacy\n+  \/\/ mallinfo is still perfectly fine to use if we know the sizes cannot have wrapped.\n+  \/\/ For example, if the process virtual size does not exceed 4G, we cannot hav\n+  \/\/ e malloc'ed more than 4G, so the results from legacy mallinfo() can still be used.\n+  \/\/\n+  \/\/ os::Linux::get_mallinfo() will always prefer mallinfo2() if found, but will fall back\n+  \/\/ to legacy mallinfo() if only that is available. In that case, it will return true\n+  \/\/ in *might_have_wrapped.\n+  struct glibc_mallinfo {\n+    size_t arena;\n+    size_t ordblks;\n+    size_t smblks;\n+    size_t hblks;\n+    size_t hblkhd;\n+    size_t usmblks;\n+    size_t fsmblks;\n+    size_t uordblks;\n+    size_t fordblks;\n+    size_t keepcost;\n+  };\n+  static void get_mallinfo(glibc_mallinfo* out, bool* might_have_wrapped);\n+#endif \/\/ GLIBC\n","filename":"src\/hotspot\/os\/linux\/os_linux.hpp","additions":34,"deletions":35,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -38,0 +38,3 @@\n+#include \"testutils.hpp\"\n+#include \"unittest.hpp\"\n+\n@@ -479,0 +482,25 @@\n+\n+#ifdef __GLIBC__\n+TEST_VM(os_linux, glibc_mallinfo_wrapper) {\n+  \/\/ Very basic test. Call it. That proves that resolution and invocation works.\n+  os::Linux::glibc_mallinfo mi;\n+  bool did_wrap = false;\n+\n+  os::Linux::get_mallinfo(&mi, &did_wrap);\n+\n+  void* p = os::malloc(2 * K, mtTest);\n+  ASSERT_NOT_NULL(p);\n+\n+  \/\/ We should see total allocation values > 0\n+  ASSERT_GE((mi.uordblks + mi.hblkhd), 2 * K);\n+\n+  \/\/ These values also should not beyond reasonable size, otherwise this indicates bad type\n+  \/\/ conversion\n+  ASSERT_LT(mi.fordblks, 2 * G);\n+  ASSERT_LT(mi.uordblks, 2 * G);\n+  ASSERT_LT(mi.hblkhd, 2 * G);\n+\n+  os::free(p);\n+}\n+#endif \/\/ __GLIBC__\n+\n","filename":"test\/hotspot\/gtest\/runtime\/test_os_linux.cpp","additions":28,"deletions":0,"binary":false,"changes":28,"status":"modified"}]}