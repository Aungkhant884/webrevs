{"files":[{"patch":"@@ -45,3 +45,0 @@\n-    \/\/ we can only have one ImageConsumer at a time because addConsumer is synchronized\n-    private DisposableImageConsumer activeConsumer;\n-\n@@ -64,0 +61,3 @@\n+    \/\/ We can only have one consumer since we immediately return the data...\n+    private ImageConsumer theConsumer;\n+\n@@ -65,4 +65,2 @@\n-        if (ic == null)\n-            return;\n-        activeConsumer = new DisposableImageConsumer(ic);\n-        produce(activeConsumer);\n+        theConsumer = ic;\n+        produce();\n@@ -72,1 +70,1 @@\n-        return activeConsumer != null && activeConsumer.delegate == ic;\n+        return (ic == theConsumer);\n@@ -76,3 +74,2 @@\n-        if (activeConsumer != null && activeConsumer.delegate == ic) {\n-            activeConsumer.isDisposed = true;\n-            activeConsumer = null;\n+        if (theConsumer == ic) {\n+            theConsumer = null;\n@@ -89,1 +86,1 @@\n-    private void sendPixels(DisposableImageConsumer theConsumer) {\n+    private void sendPixels() {\n@@ -103,1 +100,1 @@\n-                for (int y=0; y < height && !theConsumer.isDisposed; y++) {\n+                for (int y=0; y < height; y++) {\n@@ -112,1 +109,1 @@\n-                for (int y=0; y < height && !theConsumer.isDisposed; y++) {\n+                for (int y=0; y < height; y++) {\n@@ -126,1 +123,1 @@\n-                for (int y=0; y < height && !theConsumer.isDisposed; y++) {\n+                for (int y=0; y < height; y++) {\n@@ -138,1 +135,1 @@\n-                for (int y=0; y < height && !theConsumer.isDisposed; y++) {\n+                for (int y=0; y < height; y++) {\n@@ -146,1 +143,1 @@\n-                for (int y=0; y < height && !theConsumer.isDisposed; y++) {\n+                for (int y=0; y < height; y++) {\n@@ -157,1 +154,1 @@\n-                for (int y=0; y < height && !theConsumer.isDisposed; y++) {\n+                for (int y=0; y < height; y++) {\n@@ -176,1 +173,1 @@\n-            for (int y=0; y < height && !theConsumer.isDisposed; y++) {\n+            for (int y=0; y < height; y++) {\n@@ -186,1 +183,1 @@\n-    private void produce(DisposableImageConsumer theConsumer) {\n+    private void produce() {\n@@ -190,1 +187,1 @@\n-            sendPixels(theConsumer);\n+            sendPixels();\n@@ -207,1 +204,3 @@\n-            e.printStackTrace();\n+            \/\/ If theConsumer is null and we throw a NPE when interacting with it:\n+            \/\/ That's OK. That is an expected use case that can happen when an\n+            \/\/ ImageConsumer detaches itself from this ImageProducer mid-production.\n@@ -210,0 +209,1 @@\n+                e.printStackTrace();\n@@ -215,62 +215,0 @@\n-\n-\/**\n- * This ImageConsumer passes every notification to an inner delegate ImageConsumer\n- * as long as {@link #isDisposed} remains false.\n- * <p>\n- * This effectively lets us \"turn off\" notifications to the inner ImageConsumer without\n- * having to constantly confirm that that ImageConsumer remains attached to the\n- * OffScreenImageSource. Some ImageConsumers may detach mid-production, so letting us\n- * disable notifications mid-production is an important feature.\n- * <\/p>\n- *\/\n-class DisposableImageConsumer implements ImageConsumer {\n-\n-    public final ImageConsumer delegate;\n-    public boolean isDisposed = false;\n-\n-    public DisposableImageConsumer(ImageConsumer consumer) {\n-        delegate = consumer;\n-    }\n-\n-    @Override\n-    public void setDimensions(int width, int height) {\n-        if (!isDisposed)\n-            delegate.setDimensions(width, height);\n-    }\n-\n-    @Override\n-    public void setProperties(Hashtable<?, ?> props) {\n-        if (!isDisposed)\n-            delegate.setProperties(props);\n-    }\n-\n-    @Override\n-    public void setColorModel(ColorModel model) {\n-        if (!isDisposed)\n-            delegate.setColorModel(model);\n-    }\n-\n-    @Override\n-    public void setHints(int hintflags) {\n-        if (!isDisposed)\n-            delegate.setHints(hintflags);\n-    }\n-\n-    @Override\n-    public void setPixels(int x, int y, int w, int h, ColorModel model, byte[] pixels, int off, int scansize) {\n-        if (!isDisposed)\n-            delegate.setPixels(x, y, w, h, model, pixels, off, scansize);\n-    }\n-\n-    @Override\n-    public void setPixels(int x, int y, int w, int h, ColorModel model, int[] pixels, int off, int scansize) {\n-        if (!isDisposed)\n-            delegate.setPixels(x, y, w, h, model, pixels, off, scansize);\n-    }\n-\n-    @Override\n-    public void imageComplete(int status) {\n-        if (!isDisposed)\n-            delegate.imageComplete(status);\n-    }\n-}\n\\ No newline at end of file\n","filename":"src\/java.desktop\/share\/classes\/sun\/awt\/image\/OffScreenImageSource.java","additions":22,"deletions":84,"binary":false,"changes":106,"status":"modified"}]}