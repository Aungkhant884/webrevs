{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1995, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1995, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,2 @@\n+import java.util.List;\n+import java.util.concurrent.CopyOnWriteArrayList;\n@@ -45,0 +47,2 @@\n+    private List<ImageConsumer> imageConsumers = new CopyOnWriteArrayList<>();\n+\n@@ -61,3 +65,0 @@\n-    \/\/ We can only have one consumer since we immediately return the data...\n-    private ImageConsumer theConsumer;\n-\n@@ -65,2 +66,4 @@\n-        theConsumer = ic;\n-        produce();\n+        if (ic == null)\n+            return;\n+        imageConsumers.add(ic);\n+        produce(ic);\n@@ -70,1 +73,1 @@\n-        return (ic == theConsumer);\n+        return imageConsumers.contains(ic);\n@@ -74,3 +77,1 @@\n-        if (theConsumer == ic) {\n-            theConsumer = null;\n-        }\n+        imageConsumers.remove(ic);\n@@ -86,1 +87,1 @@\n-    private void sendPixels() {\n+    private void sendPixels(ImageConsumer theConsumer) {\n@@ -96,1 +97,2 @@\n-            theConsumer.setColorModel(cm);\n+            if (isConsumer(theConsumer))\n+                theConsumer.setColorModel(cm);\n@@ -101,0 +103,2 @@\n+                    if (!isConsumer(theConsumer))\n+                        return;\n@@ -103,1 +107,1 @@\n-                                          width);\n+                            width);\n@@ -110,0 +114,2 @@\n+                    if (!isConsumer(theConsumer))\n+                        return;\n@@ -124,0 +130,2 @@\n+                    if (!isConsumer(theConsumer))\n+                        return;\n@@ -131,1 +139,2 @@\n-            theConsumer.setColorModel(cm);\n+            if (isConsumer(theConsumer))\n+                theConsumer.setColorModel(cm);\n@@ -136,0 +145,2 @@\n+                    if (!isConsumer(theConsumer))\n+                        return;\n@@ -144,0 +155,2 @@\n+                    if (!isConsumer(theConsumer))\n+                        return;\n@@ -155,0 +168,2 @@\n+                    if (!isConsumer(theConsumer))\n+                        return;\n@@ -171,1 +186,2 @@\n-            theConsumer.setColorModel(newcm);\n+            if (isConsumer(theConsumer))\n+                theConsumer.setColorModel(newcm);\n@@ -174,0 +190,2 @@\n+                if (!isConsumer(theConsumer))\n+                    return;\n@@ -183,1 +201,1 @@\n-    private void produce() {\n+    private void produce(ImageConsumer theConsumer) {\n@@ -185,0 +203,1 @@\n+            \/\/ isConsumer(theConsumer) MUST be true at this point:\n@@ -186,3 +205,5 @@\n-            theConsumer.setProperties(properties);\n-            sendPixels();\n-            theConsumer.imageComplete(ImageConsumer.SINGLEFRAMEDONE);\n+            if (isConsumer(theConsumer))\n+                theConsumer.setProperties(properties);\n+            sendPixels(theConsumer);\n+            if (isConsumer(theConsumer))\n+                theConsumer.imageComplete(ImageConsumer.SINGLEFRAMEDONE);\n@@ -190,2 +211,1 @@\n-            \/\/ If 'theconsumer' has not unregistered itself after previous call\n-            if (theConsumer != null) {\n+            if (isConsumer(theConsumer)) {\n@@ -206,1 +226,1 @@\n-            if (theConsumer != null) {\n+            if (isConsumer(theConsumer))\n@@ -208,1 +228,0 @@\n-            }\n@@ -211,1 +230,1 @@\n-}\n+}\n\\ No newline at end of file\n","filename":"src\/java.desktop\/share\/classes\/sun\/awt\/image\/OffScreenImageSource.java","additions":43,"deletions":24,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -0,0 +1,192 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.Image;\n+import java.awt.image.BufferedImage;\n+import java.awt.image.ColorModel;\n+import java.awt.image.ImageConsumer;\n+import java.awt.image.ImageObserver;\n+import java.io.PrintStream;\n+import java.util.Hashtable;\n+\n+\/**\n+ * @test\n+ * @bug 4200096\n+ * @summary OffScreenImageSource.removeConsumer can cause NullPointerException\n+ * @author Jeremy Wood\n+ *\/\n+\n+public class bug4200096 {\n+    public static void main(String[] args) {\n+        \/\/ OffScreenImageSourceTest wraps image production in a try\/catch.\n+        \/\/ It catches NullPointerExceptions and prints them to System.err.\n+        \/\/ So here we override System.err to intercept them and fail this test:\n+        System.setErr(new PrintStream(System.err) {\n+            @Override\n+            public void println(Object x) {\n+                super.println(x);\n+                if (x instanceof NullPointerException e)\n+                    throw new RuntimeException(e);\n+            }\n+        });\n+\n+        runImageDimensionTest();\n+        runImageConsumerTest();\n+        runNullTest();\n+    }\n+\n+    \/**\n+     * This adds an ImageObserver that is only interested in identifying the dimensions of an ImageProducer.\n+     * <p>\n+     * Once it has the dimensions: {@link java.awt.image.ImageObserver#imageUpdate(Image, int, int, int, int, int)}\n+     * returns false. This triggers the caller to remove the ImageObserver for us. And removing an ImageObserver\n+     * while an OffScreenImageSource is mid-production triggers the NPE that is JDK-4200096.\n+     * <p>\n+     * The expected behavior is for this method to complete without OffScreenImageSource throwing\/catching a NPE.\n+     * <p>\n+     * What's interesting about this test is: we never even explicitly call {@link java.awt.image.ImageProducer#addConsumer(ImageConsumer)}\n+     * or {@link java.awt.image.ImageProducer#removeConsumer(ImageConsumer)} (ImageConsumer)}.\n+     * <\/p>\n+     *\/\n+    private static void runImageDimensionTest() {\n+        Image img = createAbstractImage();\n+        ImageObserver observer = new ImageObserver() {\n+            Integer imageWidth, imageHeight;\n+            @Override\n+            public boolean imageUpdate(Image img, int infoflags, int x, int y, int width, int height) {\n+                if ( (infoflags | ImageObserver.WIDTH) > 0) {\n+                    imageWidth = width;\n+                }\n+                if ( (infoflags | ImageObserver.HEIGHT) > 0) {\n+                    imageHeight = height;\n+                }\n+\n+                if (imageWidth != null || imageHeight != null)\n+                    return false;\n+                return true;\n+\n+            }\n+        };\n+        img.getWidth(observer);\n+    }\n+\n+    \/**\n+     * This creates an Image that is not a BufferedImage.\n+     * <p>\n+     * This specific implementation happens to rely on scaling an existing\n+     * BufferedImage, because that seemed like an easy way to avoid bundling a\n+     * JPG\/PNG with this unit test. But this return value still happens to be\n+     * a ToolkitImage, which is what a JPG\/PNG would also be (when loaded\n+     * via the Toolkit class and not ImageIO).\n+     * <\/p>\n+     *\/\n+    private static Image createAbstractImage() {\n+        BufferedImage bufferedImage = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB);\n+        Image img = bufferedImage.getScaledInstance(2, 2, Image.SCALE_SMOOTH);\n+        return img;\n+    }\n+\n+    \/**\n+     * This test removes an ImageConsumer from an OffScreenImageSource at different notifications.\n+     *\n+     * The expected behavior is for the OffScreenImageSource to never throw\/catch a NPE.\n+     *\/\n+    private static void runImageConsumerTest() {\n+        enum TestCase {\n+            SET_DIMENSIONS, SET_PROPERTIES, SET_COLOR_MODEL, SET_PIXELS, IMAGE_COMPLETE\n+        }\n+\n+        for (TestCase testCase : TestCase.values()) {\n+            BufferedImage bufferedImage = new BufferedImage(10, 10, BufferedImage.TYPE_INT_ARGB);\n+            if (!\"sun.awt.image.OffScreenImageSource\".equals(\n+                    bufferedImage.getSource().getClass().getName())) {\n+                throw new IllegalStateException(\"This isn't necessarily a problem, but it invalidates the usefulness of this test.\");\n+            }\n+\n+            ImageConsumer consumer = new ImageConsumer() {\n+\n+                private void run(TestCase methodInvocation) {\n+                    if (!bufferedImage.getSource().isConsumer(this))\n+                        throw new IllegalStateException();\n+                    if (testCase == methodInvocation)\n+                        bufferedImage.getSource().removeConsumer(this);\n+                }\n+\n+                @Override\n+                public void setDimensions(int width, int height) {\n+                    run(TestCase.SET_DIMENSIONS);\n+                }\n+\n+                @Override\n+                public void setProperties(Hashtable<?, ?> props) {\n+                    run(TestCase.SET_PROPERTIES);\n+                }\n+\n+                @Override\n+                public void setColorModel(ColorModel model) {\n+                    run(TestCase.SET_COLOR_MODEL);\n+                }\n+\n+                @Override\n+                public void setHints(int hintflags) {\n+                    \/\/ intentionally empty.\n+                    \/\/ OffScreenImageSource does not use this method, which is probably a separate (unrelated) bug\n+                }\n+\n+                @Override\n+                public void setPixels(int x, int y, int w, int h, ColorModel model, byte[] pixels, int off, int scansize) {\n+                    throw new UnsupportedOperationException(\"this test should use int[] pixels\");\n+                }\n+\n+                @Override\n+                public void setPixels(int x, int y, int w, int h, ColorModel model, int[] pixels, int off, int scansize) {\n+                    if (y == 5) {\n+                        run(TestCase.SET_PIXELS);\n+                    }\n+                }\n+\n+                @Override\n+                public void imageComplete(int status) {\n+                    run(TestCase.IMAGE_COMPLETE);\n+                }\n+            };\n+\n+            bufferedImage.getSource().startProduction(consumer);\n+\n+            if (bufferedImage.getSource().isConsumer(consumer)) {\n+                \/\/ this confirms our calls to .removeConsumer above were being invoked as expected\n+                throw new IllegalStateException(\"This test is not executing as expected.\");\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * This makes sure if OffScreenImageSource#addConsumer(null) is called: we\n+     * treat that as a no-op and return immediately without printing anything\n+     * to System.err.\n+     *\/\n+    public static void runNullTest() {\n+        BufferedImage bufferedImage = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB);\n+        bufferedImage.getSource().addConsumer(null);\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/sun\/awt\/image\/OffScreenImageSource\/bug4200096.java","additions":192,"deletions":0,"binary":false,"changes":192,"status":"added"}]}