{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1995, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1995, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -103,1 +103,1 @@\n-                                          width);\n+                            width);\n@@ -115,1 +115,1 @@\n-                                          width);\n+                            width);\n@@ -119,1 +119,1 @@\n-                     dataType == DataBuffer.TYPE_INT)\n+                    dataType == DataBuffer.TYPE_INT)\n@@ -126,1 +126,1 @@\n-                                          width);\n+                            width);\n@@ -138,1 +138,1 @@\n-                                          width);\n+                            width);\n@@ -149,1 +149,1 @@\n-                                          width);\n+                            width);\n@@ -160,1 +160,1 @@\n-                                          width);\n+                            width);\n@@ -178,1 +178,1 @@\n-                                      width);\n+                        width);\n@@ -204,1 +204,3 @@\n-            e.printStackTrace();\n+            \/\/ If theConsumer is null and we throw a NPE when interacting with it:\n+            \/\/ That's OK. That is an expected use case that can happen when an\n+            \/\/ ImageConsumer detaches itself from this ImageProducer mid-production.\n@@ -207,0 +209,1 @@\n+                e.printStackTrace();\n","filename":"src\/java.desktop\/share\/classes\/sun\/awt\/image\/OffScreenImageSource.java","additions":13,"deletions":10,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -0,0 +1,52 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.image.BufferedImage;\n+\n+\/**\n+ * @test\n+ * @bug 4200096\n+ * @summary OffScreenImageSource.addConsumer(null) shouldn't throw (or print) a NullPointerException\n+ * @author Jeremy Wood\n+ *\/\n+\n+\/**\n+ * This makes sure if OffScreenImageSource#addConsumer(null) is called: we\n+ * treat that as a no-op and return immediately.\n+ * <p>\n+ * This test exists primarily to make sure the resolution to 4200096 does not\n+ * significantly change legacy behavior. Whether or not a NPE is printed to\n+ * System.err is not a hotly contested question, but at one point one of the\n+ * proposed (and rejected) resolutions to 4200096 had the potential to\n+ * throw a NPE when addConsumer(null) was called. That would be a\n+ * significant change that we want to avoid.\n+ * <\/p>\n+ *\/\n+ public class AddNullConsumerTest {\n+    public static void main(String[] args) throws Exception {\n+        try (AutoCloseable setup = bug4200096.setupTest(false)) {\n+            BufferedImage bufferedImage = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB);\n+            bufferedImage.getSource().addConsumer(null);\n+        }\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/sun\/awt\/image\/OffScreenImageSource\/bug4200096\/AddNullConsumerTest.java","additions":52,"deletions":0,"binary":false,"changes":52,"status":"added"},{"patch":"@@ -0,0 +1,88 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.Image;\n+import java.awt.image.BufferedImage;\n+import java.awt.image.ImageObserver;\n+\n+\/**\n+ * @test\n+ * @bug 4200096\n+ * @summary this real-world example detaches an ImageConsumer from an OSIS immediately after it learns the dimensions.\n+ * @author Jeremy Wood\n+ *\/\n+\n+\/**\n+ * This adds an ImageObserver that is only interested in identifying the dimensions of an ImageProducer.\n+ * <p>\n+ * Once it has the dimensions: {@link java.awt.image.ImageObserver#imageUpdate(Image, int, int, int, int, int)}\n+ * returns false. This triggers the caller to remove the ImageObserver for us. And removing an ImageObserver\n+ * while an OffScreenImageSource is mid-production triggers the NPE that is JDK-4200096.\n+ * <p>\n+ * The expected behavior is for this method to complete without OffScreenImageSource throwing\/catching a NPE.\n+ * <p>\n+ * What's interesting about this test is: we never even explicitly call {@link java.awt.image.ImageProducer#addConsumer(ImageConsumer)}\n+ * or {@link java.awt.image.ImageProducer#removeConsumer(ImageConsumer)} (ImageConsumer)}.\n+ * <\/p>\n+ *\/\n+public class ImageSizeTest {\n+    public static void main(String[] args) throws Exception {\n+        try (AutoCloseable setup = bug4200096.setupTest(false)) {\n+            Image img = createAbstractImage();\n+            ImageObserver observer = new ImageObserver() {\n+                Integer imageWidth, imageHeight;\n+                @Override\n+                public boolean imageUpdate(Image img, int infoflags, int x, int y, int width, int height) {\n+                    if ( (infoflags | ImageObserver.WIDTH) > 0) {\n+                        imageWidth = width;\n+                    }\n+                    if ( (infoflags | ImageObserver.HEIGHT) > 0) {\n+                        imageHeight = height;\n+                    }\n+\n+                    if (imageWidth != null || imageHeight != null)\n+                        return false;\n+                    return true;\n+\n+                }\n+            };\n+            img.getWidth(observer);\n+        }\n+    }\n+\n+    \/**\n+     * This creates a ToolkitImage, so it is not a BufferedImage.\n+     * <p>\n+     * This specific implementation happens to rely on scaling an existing\n+     * BufferedImage, because that seemed like an easy way to avoid bundling a\n+     * JPG\/PNG with this unit test. But this return value still happens to be\n+     * a ToolkitImage, which is what a JPG\/PNG would also be (when loaded\n+     * via the Toolkit class and not ImageIO).\n+     * <\/p>\n+     *\/\n+    private static Image createAbstractImage() {\n+        BufferedImage bufferedImage = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB);\n+        Image img = bufferedImage.getScaledInstance(2, 2, Image.SCALE_SMOOTH);\n+        return img;\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/sun\/awt\/image\/OffScreenImageSource\/bug4200096\/ImageSizeTest.java","additions":88,"deletions":0,"binary":false,"changes":88,"status":"added"},{"patch":"@@ -0,0 +1,91 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.image.BufferedImage;\n+import java.awt.image.ColorModel;\n+import java.awt.image.ImageConsumer;\n+import java.util.Hashtable;\n+\n+\/**\n+ * @test\n+ * @bug 4200096\n+ * @summary This makes sure NPE's that come from the ImageConsumer are still printed to System.err\n+ * @author Jeremy Wood\n+ *\/\n+\n+\/**\n+ * This test makes sure that if an ImageConsumer throws a NullPointerException: that NPE\n+ * should be printed to System.err.\n+ * <p>\n+ * Most of the discussion around JDK-4200096 focuses on how we handle NPE's that come from\n+ * OffScreenImageSource itself, but this test checks how we handle NPE's that come from\n+ * the ImageConsumer that's listening to an OffScreenImageSource.\n+ * <\/p>\n+ * <p>\n+ * This test is enforcing a legacy behavior.\n+ * <\/p>\n+ *\/\n+ public class LegitimateNullPointerTest {\n+    public static void main(String[] args) throws Exception {\n+        try (AutoCloseable setup = bug4200096.setupTest(true)) {\n+            BufferedImage bufferedImage = new BufferedImage(10, 10, BufferedImage.TYPE_INT_ARGB);\n+            bufferedImage.getSource().addConsumer(new ImageConsumer() {\n+\n+                @Override\n+                public void setDimensions(int width, int height) {\n+                    throw new NullPointerException();\n+                }\n+\n+                @Override\n+                public void setProperties(Hashtable<?, ?> props) {\n+                    \/\/ intentionally empty\n+                }\n+\n+                @Override\n+                public void setColorModel(ColorModel model) {\n+                    \/\/ intentionally empty\n+                }\n+\n+                @Override\n+                public void setHints(int hintflags) {\n+                    \/\/ intentionally empty\n+                }\n+\n+                @Override\n+                public void setPixels(int x, int y, int w, int h, ColorModel model, byte[] pixels, int off, int scansize) {\n+                    \/\/ intentionally empty\n+                }\n+\n+                @Override\n+                public void setPixels(int x, int y, int w, int h, ColorModel model, int[] pixels, int off, int scansize) {\n+                    \/\/ intentionally empty\n+                }\n+\n+                @Override\n+                public void imageComplete(int status) {\n+                    \/\/ intentionally empty\n+                }\n+            });\n+        }\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/sun\/awt\/image\/OffScreenImageSource\/bug4200096\/LegitimateNullPointerTest.java","additions":91,"deletions":0,"binary":false,"changes":91,"status":"added"},{"patch":"@@ -0,0 +1,158 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.Image;\n+import java.awt.image.BufferedImage;\n+import java.awt.image.ColorModel;\n+import java.awt.image.ImageConsumer;\n+import java.io.PrintStream;\n+import java.lang.AutoCloseable;\n+import java.lang.AutoCloseable;\n+import java.util.Hashtable;\n+\n+\/**\n+ * @test\n+ * @bug 4200096\n+ * @summary if an ImageConsumer detaches from OffScreenImageSource mid-production: we shouldn't print a NPE to System.err\n+ * @author Jeremy Wood\n+ *\/\n+\n+\/**\n+ * This detaches an ImageConsumer at different points and checks to see if a\n+ * NullPointerException is thrown by the OffScreenImageSource as a result.\n+ *\/\n+public class bug4200096 {\n+\n+    \/**\n+     * This hijacks System.err so we can detect if a NullPointerException is printed to it.\n+     * <p>\n+     * When this AutoCloseable is closed: we throw an exception based on whether we observed\n+     * a NPE vs whether a NPE is expected or not.\n+     * <\/p>\n+     *\n+     * @param expectPrintedNPE this is consulted when {@link java.lang.AutoCloseable#close()} is called,\n+     *                         and if the expectation doesn't match what happened then a RuntimeException is thrown.\n+     * @return an AutoCloseable that restores System.err and tests whether a NPE was observed or not.\n+     *\/\n+    public static AutoCloseable setupTest(boolean expectPrintedNPE) {\n+        NullPointerException[] wrapper = new NullPointerException[] { null };\n+        PrintStream origErr = System.err;\n+        System.setErr(new PrintStream(origErr) {\n+            @Override\n+            public void println(Object x) {\n+                super.println(x);\n+                if (x instanceof NullPointerException e)\n+                    wrapper[0] = e;\n+            }\n+        });\n+        return new AutoCloseable() {\n+            @Override\n+            public void close() {\n+                System.setErr(origErr);\n+                if (expectPrintedNPE) {\n+                    if (wrapper[0] == null)\n+                        throw new RuntimeException(\"This test expected a NullPointerException to be printed to System.err, but that didn't happen.\");\n+                } else {\n+                    if (wrapper[0] != null)\n+                        throw new RuntimeException(\"This test expected no NullPointerExceptions to be printed to System.err, but (at least) one was.)\");\n+                }\n+            }\n+        };\n+    }\n+\n+    \/**\n+     * This enumerates the different notifications that OffScreenImageSource issues.\n+     * <p>\n+     * There is no SET_HINTS because (as of this writing) OSIS doesn't call setHints(int).\n+     * <\/p>\n+     *\/\n+    public enum TestCase {\n+        SET_DIMENSIONS, SET_PROPERTIES, SET_COLOR_MODEL, SET_PIXELS, IMAGE_COMPLETE\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        try (AutoCloseable setup = setupTest(false)) {\n+            for (TestCase testCase : TestCase.values()) {\n+                BufferedImage bufferedImage = new BufferedImage(10, 10, BufferedImage.TYPE_INT_ARGB);\n+                if (!\"sun.awt.image.OffScreenImageSource\".equals(\n+                        bufferedImage.getSource().getClass().getName())) {\n+                    throw new IllegalStateException(\"If BufferedImage#getSource() is not an OffScreenImageSource: that isn't necessarily a problem, but it invalidates the usefulness of this test.\");\n+                }\n+\n+                ImageConsumer consumer = new ImageConsumer() {\n+\n+                    private void run(TestCase methodInvocation) {\n+                        if (!bufferedImage.getSource().isConsumer(this))\n+                            throw new IllegalStateException();\n+                        if (testCase == methodInvocation)\n+                            bufferedImage.getSource().removeConsumer(this);\n+                    }\n+\n+                    @Override\n+                    public void setDimensions(int width, int height) {\n+                        run(TestCase.SET_DIMENSIONS);\n+                    }\n+\n+                    @Override\n+                    public void setProperties(Hashtable<?, ?> props) {\n+                        run(TestCase.SET_PROPERTIES);\n+                    }\n+\n+                    @Override\n+                    public void setColorModel(ColorModel model) {\n+                        run(TestCase.SET_COLOR_MODEL);\n+                    }\n+\n+                    @Override\n+                    public void setHints(int hintflags) {\n+                        \/\/ intentionally empty.\n+                    }\n+\n+                    @Override\n+                    public void setPixels(int x, int y, int w, int h, ColorModel model, byte[] pixels, int off, int scansize) {\n+                        throw new UnsupportedOperationException(\"this test should use int[] pixels\");\n+                    }\n+\n+                    @Override\n+                    public void setPixels(int x, int y, int w, int h, ColorModel model, int[] pixels, int off, int scansize) {\n+                        if (y == 5) {\n+                            run(TestCase.SET_PIXELS);\n+                        }\n+                    }\n+\n+                    @Override\n+                    public void imageComplete(int status) {\n+                        run(TestCase.IMAGE_COMPLETE);\n+                    }\n+                };\n+\n+                bufferedImage.getSource().startProduction(consumer);\n+\n+                if (bufferedImage.getSource().isConsumer(consumer)) {\n+                    \/\/ this confirms our calls to .removeConsumer above were being invoked as expected\n+                    throw new IllegalStateException(\"This test is not executing as expected.\");\n+                }\n+            }\n+        }\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/sun\/awt\/image\/OffScreenImageSource\/bug4200096\/bug4200096.java","additions":158,"deletions":0,"binary":false,"changes":158,"status":"added"}]}