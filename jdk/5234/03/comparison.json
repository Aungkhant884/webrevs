{"files":[{"patch":"@@ -0,0 +1,189 @@\n+\/*\n+ *  Copyright (c) 2021, Intel Corporation. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector;\n+\n+import jdk.incubator.vector.FloatVector;\n+import jdk.incubator.vector.VectorOperators;\n+import jdk.incubator.vector.VectorSpecies;\n+import org.openjdk.jmh.annotations.*;\n+\n+import java.util.Objects;\n+import java.util.Random;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.IntUnaryOperator;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.SECONDS)\n+@State(Scope.Thread)\n+@Warmup(iterations = 3, time = 5)\n+@Measurement(iterations = 3, time = 5)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class BlackScholes {\n+\n+    @Param(\"1024\")\n+    int size;\n+\n+\n+    float[] s0; \/\/ Stock Price\n+    float[] x;  \/\/ Strike Price\n+    float[] t;  \/\/ Maturity\n+    float[] call;\n+    float[] put;\n+    float r;    \/\/ risk-neutrality\n+    float sig;  \/\/ volatility\n+    Random rand;\n+\n+\n+    float randFloat(float low, float high) {\n+       float val = rand.nextFloat();\n+       return (1.0f - val) * low + val * high;\n+    }\n+\n+    float[] fillRandom(float low, float high) {\n+        float[] array = new float[size];\n+        for (int i = 0; i < array.length; i++) {\n+            array[i] = randFloat(low, high);\n+        }\n+        return array;\n+    }\n+\n+    @Setup\n+    public void init() {\n+        rand = new Random();\n+        s0 = fillRandom(5.0f, 30.0f);\n+        x  = fillRandom(1.0f, 100.0f);\n+        t  = fillRandom(0.25f, 10.0f);\n+        r = 0.02f;\n+        sig = 0.30f;\n+        call = new float[size];\n+        put = new float[size];\n+    }\n+\n+    static final float Y = 0.2316419f;\n+    static final float A1 = 0.31938153f;\n+    static final float A2 = -0.356563782f;\n+    static final float A3 = 1.781477937f;\n+    static final float A4 = -1.821255978f;\n+    static final float A5 = 1.330274429f;\n+    static final float PI = (float)Math.PI;\n+\n+    float cdf(float inp) {\n+        float x = inp;\n+        if (inp < 0f) {\n+            x = -inp;\n+        }\n+\n+        float term = 1f \/ (1f + (Y * x));\n+        float term_pow2 = term * term;\n+        float term_pow3 = term_pow2 * term;\n+        float term_pow4 = term_pow2 * term_pow2;\n+        float term_pow5 = term_pow2 * term_pow3;\n+\n+        float part1 = (1f \/ (float)Math.sqrt(2f * PI)) * (float)Math.exp((-x * x) * 0.5f);\n+\n+        float part2 = (A1 * term) +\n+                      (A2 * term_pow2) +\n+                      (A3 * term_pow3) +\n+                      (A4 * term_pow4) +\n+                      (A5 * term_pow5);\n+\n+        if (inp >= 0f)\n+            return 1f - part1 * part2;\n+        else\n+            return part1 * part2;\n+\n+    }\n+\n+    public void scalar_black_scholes_kernel(int off) {\n+        float sig_sq_by2 = 0.5f * sig * sig;\n+        for (int i = off; i < size; i++ ) {\n+            float log_s0byx = (float)Math.log(s0[i] \/ x[i]);\n+            float sig_sqrt_t = sig * (float)Math.sqrt(t[i]);\n+            float exp_neg_rt = (float)Math.exp(-r * t[i]);\n+            float d1 = (log_s0byx + (r + sig_sq_by2) * t[i])\/(sig_sqrt_t);\n+            float d2 = d1 - sig_sqrt_t;\n+            call[i] = s0[i] * cdf(d1) - exp_neg_rt * x[i] * cdf(d2);\n+            put[i]  = call[i] + exp_neg_rt - s0[i];\n+       }\n+    }\n+\n+    @Benchmark\n+    public void scalar_black_scholes() {\n+        scalar_black_scholes_kernel(0);\n+    }\n+\n+    static final VectorSpecies<Float> fsp = FloatVector.SPECIES_PREFERRED;\n+\n+    FloatVector vcdf(FloatVector vinp) {\n+        var vx = vinp.abs();\n+        var vone = FloatVector.broadcast(fsp, 1.0f);\n+        var vtwo = FloatVector.broadcast(fsp, 2.0f);\n+        var vterm = vone.div(vone.add(vx.mul(Y)));\n+        var vterm_pow2 = vterm.mul(vterm);\n+        var vterm_pow3 = vterm_pow2.mul(vterm);\n+        var vterm_pow4 = vterm_pow2.mul(vterm_pow2);\n+        var vterm_pow5 = vterm_pow2.mul(vterm_pow3);\n+        var vpart1 = vone.div(vtwo.mul(PI).lanewise(VectorOperators.SQRT)).mul(vx.mul(vx).neg().lanewise(VectorOperators.EXP).mul(0.5f));\n+        var vpart2 = vterm.mul(A1).add(vterm_pow2.mul(A2)).add(vterm_pow3.mul(A3)).add(vterm_pow4.mul(A4)).add(vterm_pow5.mul(A5));\n+        var vmask = vinp.compare(VectorOperators.GT, 0f);\n+        var vresult1 = vpart1.mul(vpart2);\n+        var vresult2 = vresult1.neg().add(vone);\n+        var vresult = vresult1.blend(vresult2, vmask);\n+\n+        return vresult;\n+    }\n+\n+    public int vector_black_scholes_kernel() {\n+        int i = 0;\n+        var vsig = FloatVector.broadcast(fsp, sig);\n+        var vsig_sq_by2 = vsig.mul(vsig).mul(0.5f);\n+        var vr = FloatVector.broadcast(fsp, r);\n+        var vnegr = FloatVector.broadcast(fsp, -r);\n+        for (; i <= x.length - fsp.length(); i += fsp.length()) {\n+            var vx = FloatVector.fromArray(fsp, x, i);\n+            var vs0 = FloatVector.fromArray(fsp, s0, i);\n+            var vt = FloatVector.fromArray(fsp, t, i);\n+            var vlog_s0byx = vs0.div(vx).lanewise(VectorOperators.LOG);\n+            var vsig_sqrt_t = vt.lanewise(VectorOperators.SQRT).mul(vsig);\n+            var vexp_neg_rt = vt.mul(vnegr).lanewise(VectorOperators.EXP);\n+            var vd1 = vsig_sq_by2.add(vr).mul(vt).add(vlog_s0byx).div(vsig_sqrt_t);\n+            var vd2 = vd1.sub(vsig_sqrt_t);\n+            var vcall = vs0.mul(vcdf(vd1)).sub(vx.mul(vexp_neg_rt).mul(vcdf(vd2)));\n+            var vput = vcall.add(vexp_neg_rt).sub(vs0);\n+            vcall.intoArray(call, i);\n+            vput.intoArray(put, i);\n+        }\n+        return i;\n+    }\n+\n+    @Benchmark\n+    public void vector_black_scholes() {\n+        int processed = vector_black_scholes_kernel();\n+        if (processed < size) {\n+            scalar_black_scholes_kernel(processed);\n+        }\n+    }\n+}\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/BlackScholes.java","additions":189,"deletions":0,"binary":false,"changes":189,"status":"added"}]}