{"files":[{"patch":"@@ -12103,0 +12103,106 @@\n+\/\/----------Intrinsics for Compare function------------------------------------\n+\n+instruct compareSignedI_rReg(rRegI dst, rRegI op1, rRegI op2, rRegI tmp, rFlagsReg cr)\n+%{\n+  match(Set dst (CompareSignedI op1 op2));\n+  effect(KILL cr, TEMP tmp);\n+\n+  format %{ \"cmpsignedl    $op1, $op2 # CompareSignedI\" %}\n+  ins_encode %{\n+    Register op1 = $op1$$Register;\n+    Register op2 = $op2$$Register;\n+    Register dest = $dst$$Register;\n+    Register tmp = $tmp$$Register;\n+\n+    Label done;\n+    __ movl(tmp, -1);\n+    __ cmpl(op1, op2);\n+    __ jccb(Assembler::less, done);\n+\t  __ movl(tmp, 1);\n+    __ jccb(Assembler::greater, done);\n+\t  __ movl(tmp, 0);\n+    __ bind(done);\n+    __ movl(dest, tmp);\n+\n+  %}\n+  ins_pipe(ialu_cr_reg_reg);\n+%}\n+\n+instruct compareSignedL_rReg(rRegI dst, rRegL op1, rRegL op2, rRegI tmp, rFlagsReg cr)\n+%{\n+  match(Set dst (CompareSignedL op1 op2));\n+  effect(KILL cr, TEMP tmp);\n+\n+  format %{ \"cmpsignedq    $op1, $op2 # CompareSignedL\" %}\n+  ins_encode %{\n+    Register op1 = $op1$$Register;\n+    Register op2 = $op2$$Register;\n+    Register dest = $dst$$Register;\n+    Register tmp = $tmp$$Register;\n+\n+    Label done;\n+    __ movl(tmp, -1);\n+    __ cmpq(op1, op2);\n+    __ jccb(Assembler::less, done);\n+\t  __ movl(tmp, 1);\n+    __ jccb(Assembler::greater, done);\n+\t  __ movl(tmp, 0);\n+    __ bind(done);\n+    __ movl(dest, tmp);\n+\n+  %}\n+  ins_pipe(ialu_cr_reg_reg);\n+%}\n+\n+\n+instruct compareUnsignedI_rReg(rRegI dst, rRegI op1, rRegI op2, rRegI tmp, rFlagsReg cr)\n+%{\n+  match(Set dst (CompareUnsignedI op1 op2));\n+  effect(KILL cr, TEMP tmp);\n+\n+  format %{ \"cmpunsignedl    $op1, $op2 # CompareUnsignedI\" %}\n+  ins_encode %{\n+    Register op1 = $op1$$Register;\n+    Register op2 = $op2$$Register;\n+    Register dest = $dst$$Register;\n+    Register tmp = $tmp$$Register;\n+\n+    Label done;\n+    __ movl(tmp, -1);\n+    __ cmpl(op1, op2);\n+    __ jccb(Assembler::below, done);\n+\t  __ movl(tmp, 1);\n+    __ jccb(Assembler::above, done);\n+\t  __ movl(tmp, 0);\n+    __ bind(done);\n+    __ movl(dest, tmp);\n+\n+  %}\n+  ins_pipe(ialu_cr_reg_reg);\n+%}\n+\n+instruct compareUnsignedL_rReg(rRegI dst, rRegL op1, rRegL op2, rRegI tmp, rFlagsReg cr)\n+%{\n+  match(Set dst (CompareUnsignedL op1 op2));\n+  effect(KILL cr, TEMP tmp);\n+\n+  format %{ \"cmpunsignedq    $op1, $op2 # CompareUnsignedL\" %}\n+  ins_encode %{\n+    Register op1 = $op1$$Register;\n+    Register op2 = $op2$$Register;\n+    Register dest = $dst$$Register;\n+    Register tmp = $tmp$$Register;\n+\n+    Label done;\n+    __ movl(tmp, -1);\n+    __ cmpq(op1, op2);\n+    __ jccb(Assembler::below, done);\n+\t  __ movl(tmp, 1);\n+    __ jccb(Assembler::above, done);\n+\t  __ movl(tmp, 0);\n+    __ bind(done);\n+    __ movl(dest, tmp);\n+\n+  %}\n+  ins_pipe(ialu_cr_reg_reg);\n+%}\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":106,"deletions":0,"binary":false,"changes":106,"status":"modified"},{"patch":"@@ -130,0 +130,1 @@\n+  do_signature(long2_int_signature,       \"(JJ)I\")                                                                      \\\n@@ -234,0 +235,5 @@\n+  do_intrinsic(_compare_i,                java_lang_Integer,      compare_name,            int2_int_signature,   F_S)   \\\n+  do_intrinsic(_compare_l,                java_lang_Long,         compare_name,            long2_int_signature,   F_S)  \\\n+  do_intrinsic(_compareUnsigned_i,        java_lang_Integer,      compare_unsigned_name,   int2_int_signature,   F_S)   \\\n+   do_name(     compare_unsigned_name,                             \"compareUnsigned\")                                   \\\n+  do_intrinsic(_compareUnsigned_l,        java_lang_Long,         compare_unsigned_name,   long2_int_signature,   F_S)  \\\n@@ -989,1 +995,1 @@\n-  do_intrinsic(_VectorCompare, jdk_internal_vm_vector_VectorSupport, vector_compare_name, vector_compare_sig, F_S)                             \\\n+  do_intrinsic(_VectorCompare, jdk_internal_vm_vector_VectorSupport, compare_name, vector_compare_sig, F_S)                             \\\n@@ -999,1 +1005,1 @@\n-   do_name(vector_compare_name, \"compare\")                                                                                                     \\\n+   do_name(compare_name, \"compare\")                                                                                                     \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -219,0 +219,12 @@\n+  case vmIntrinsics::_compare_i:\n+  if (!Matcher::match_rule_supported(Op_CompareSignedI)) return false;\n+    break;\n+  case vmIntrinsics::_compare_l:\n+    if (!Matcher::match_rule_supported(Op_CompareSignedL)) return false;\n+    break;\n+  case vmIntrinsics::_compareUnsigned_i:\n+   if (!Matcher::match_rule_supported(Op_CompareUnsignedI)) return false;\n+    break;\n+  case vmIntrinsics::_compareUnsigned_l:\n+    if (!Matcher::match_rule_supported(Op_CompareUnsignedL)) return false;\n+    break;\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"opto\/comparenode.hpp\"\n","filename":"src\/hotspot\/share\/opto\/classes.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -99,0 +99,4 @@\n+macro(CompareSignedI)\n+macro(CompareSignedL)\n+macro(CompareUnsignedI)\n+macro(CompareUnsignedL)\n","filename":"src\/hotspot\/share\/opto\/classes.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,70 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_OPTO_COMPARENODE_HPP\n+#define SHARE_OPTO_COMPARENODE_HPP\n+\n+#include \"opto\/node.hpp\"\n+#include \"opto\/opcodes.hpp\"\n+\n+class PhaseTransform;\n+\n+\/\/---------- CompareNode -----------------------------------------------------\n+class CompareNode : public Node {\n+  public:\n+  CompareNode(Node* in1, Node* in2) : Node(NULL, in1, in2) {}\n+  const Type* bottom_type() const { return TypeInt::INT; }\n+  virtual uint ideal_reg() const { return Op_RegI; }\n+};\n+\n+\/\/---------- CompareSignedINode -----------------------------------------------------\n+class CompareSignedINode : public CompareNode {\n+    public:\n+    CompareSignedINode(Node* in1, Node* in2) : CompareNode(in1, in2) {}\n+    virtual int Opcode() const;\n+};\n+\n+\/\/---------- CompareSignedLNode -----------------------------------------------------\n+class CompareSignedLNode : public CompareNode {\n+    public:\n+    CompareSignedLNode(Node* in1, Node* in2) : CompareNode(in1, in2) {}\n+    virtual int Opcode() const;\n+};\n+\n+\/\/---------- CompareUnsignedINode -----------------------------------------------------\n+class CompareUnsignedINode : public CompareNode {\n+    public:\n+    CompareUnsignedINode(Node* in1, Node* in2) : CompareNode(in1, in2) {}\n+    virtual int Opcode() const;\n+};\n+\n+\/\/---------- CompareUnsignedLNode -----------------------------------------------------\n+class CompareUnsignedLNode : public CompareNode {\n+    public:\n+    CompareUnsignedLNode(Node* in1, Node* in2) : CompareNode(in1, in2) {}\n+    virtual int Opcode() const;\n+};\n+\n+\n+#endif \/\/ SHARE_OPTO_COMPARENODE_HPP\n","filename":"src\/hotspot\/share\/opto\/comparenode.hpp","additions":70,"deletions":0,"binary":false,"changes":70,"status":"added"},{"patch":"@@ -43,0 +43,1 @@\n+#include \"opto\/comparenode.hpp\"\n@@ -633,0 +634,6 @@\n+  case vmIntrinsics::_compare_i:\n+  case vmIntrinsics::_compare_l:\n+  case vmIntrinsics::_compareUnsigned_i:\n+  case vmIntrinsics::_compareUnsigned_l:\n+    return inline_number_compare(intrinsic_id());\n+\n@@ -2149,0 +2156,16 @@\n+\/\/--------------------------inline_number_compare-----------------------------\n+\/\/ inline int Integer.compare(int, int)\n+bool LibraryCallKit::inline_number_compare(vmIntrinsics::ID id) {\n+  Node* n = NULL;\n+  switch (id) {\n+  case vmIntrinsics::_compare_i:           n = new CompareSignedINode(argument(0), argument(1));  break;\n+  case vmIntrinsics::_compare_l:           n = new CompareSignedLNode(argument(0), argument(2));  break;\n+  case vmIntrinsics::_compareUnsigned_i:   n = new CompareUnsignedINode(argument(0), argument(1));  break;\n+  case vmIntrinsics::_compareUnsigned_l:   n = new CompareUnsignedLNode(argument(0), argument(2));  break;\n+  default:  fatal_unexpected_iid(id);  break;\n+  }\n+  set_result(_gvn.transform(n));\n+  return true;\n+}\n+\n+\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -308,0 +308,1 @@\n+  bool inline_number_compare(vmIntrinsics::ID id);\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -143,0 +143,1 @@\n+#include \"opto\/comparenode.hpp\"\n@@ -1711,0 +1712,4 @@\n+  declare_c2_type(CompareSignedINode, CompareNode)                        \\\n+  declare_c2_type(CompareSignedLNode, CompareNode)                        \\\n+  declare_c2_type(CompareUnsignedINode, CompareNode)                      \\\n+  declare_c2_type(CompareUnsignedLNode, CompareNode)                      \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1486,0 +1486,1 @@\n+    @IntrinsicCandidate\n@@ -1502,0 +1503,1 @@\n+    @IntrinsicCandidate\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Integer.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1627,0 +1627,1 @@\n+    @IntrinsicCandidate\n@@ -1643,0 +1644,1 @@\n+    @IntrinsicCandidate\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Long.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,98 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Param;\n+import java.util.random.RandomGenerator;\n+import java.util.random.RandomGeneratorFactory;\n+import java.util.concurrent.TimeUnit;\n+\n+\/**\n+ * Tests for compare() and compareUnsigned() methods in java.lang.Integer\n+ *\/\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Thread)\n+public class CompareInteger {\n+\n+    RandomGenerator rng;\n+\n+    @Param({\"mixed\", \"lessThanEqual\", \"greaterThanEqual\", \"equal\"})\n+    String mode;\n+\n+    @Param({\"1024\"})\n+    int BUFFER_SIZE;\n+\n+    int[] input1, input2, outputs;\n+\n+    @Setup\n+    public void setup() {\n+        input1 = new int[BUFFER_SIZE];\n+        input2 = new int[BUFFER_SIZE];\n+        outputs =  new int[BUFFER_SIZE];\n+        RandomGenerator rng = RandomGeneratorFactory.getDefault().create(0);\n+\n+        for (int i = 0; i < BUFFER_SIZE; i++) {\n+            input1[i] = rng.nextInt();\n+            if (mode.equals(\"equal\")) {\n+                input2[i] = input1[i];\n+                continue;\n+            }\n+            else input2[i] = rng.nextInt();\n+\n+            if (!mode.equals(\"mixed\")) {\n+                boolean doSwap = (mode.equals(\"lessThanEqual\") && input1[i] > input2[i]) ||\n+                                (mode.equals(\"greaterThanEqual\") && input1[i] < input2[i]);\n+                if (doSwap) {\n+                    int tmp = input1[i];\n+                    input1[i] = input2[i];\n+                    input2[i] = tmp;\n+                }\n+            }\n+        }\n+    }\n+\n+    @Benchmark\n+    public void testCompare() {\n+        for (int i = 0; i < BUFFER_SIZE; i++) {\n+            outputs[i] = Integer.compare(input1[i], input2[i]);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void testCompareUnsigned() {\n+        for (int i = 0; i < BUFFER_SIZE; i++) {\n+            outputs[i] = Integer.compareUnsigned(input1[i], input2[i]);\n+        }\n+    }\n+\n+}\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/CompareInteger.java","additions":98,"deletions":0,"binary":false,"changes":98,"status":"added"},{"patch":"@@ -0,0 +1,98 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Param;\n+import java.util.random.RandomGenerator;\n+import java.util.random.RandomGeneratorFactory;\n+import java.util.concurrent.TimeUnit;\n+\n+\/**\n+ * Tests for compare() and compareUnsigned() methods in java.lang.Long\n+ *\/\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Thread)\n+public class CompareLong {\n+\n+    RandomGenerator rng;\n+\n+    @Param({\"mixed\", \"lessThanEqual\", \"greaterThanEqual\", \"equal\"})\n+    String mode;\n+\n+    @Param({\"1024\"})\n+    int BUFFER_SIZE;\n+\n+    long[] input1, input2, outputs;\n+\n+    @Setup\n+    public void setup() {\n+        input1 = new long[BUFFER_SIZE];\n+        input2 = new long[BUFFER_SIZE];\n+        outputs =  new long[BUFFER_SIZE];\n+        RandomGenerator rng = RandomGeneratorFactory.getDefault().create(0);\n+\n+        for (int i = 0; i < BUFFER_SIZE; i++) {\n+            input1[i] = rng.nextLong();\n+            if (mode.equals(\"equal\")) {\n+                input2[i] = input1[i];\n+                continue;\n+            }\n+            else input2[i] = rng.nextLong();\n+\n+            if (!mode.equals(\"mixed\")) {\n+                boolean doSwap = (mode.equals(\"lessThanEqual\") && input1[i] > input2[i]) ||\n+                                (mode.equals(\"greaterThanEqual\") && input1[i] < input2[i]);\n+                if (doSwap) {\n+                    long tmp = input1[i];\n+                    input1[i] = input2[i];\n+                    input2[i] = tmp;\n+                }\n+            }\n+        }\n+    }\n+\n+    @Benchmark\n+    public void testCompare() {\n+        for (int i = 0; i < BUFFER_SIZE; i++) {\n+            outputs[i] = Long.compare(input1[i], input2[i]);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void testCompareUnsigned() {\n+        for (int i = 0; i < BUFFER_SIZE; i++) {\n+            outputs[i] = Long.compareUnsigned(input1[i], input2[i]);\n+        }\n+    }\n+\n+}\n+\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/CompareLong.java","additions":98,"deletions":0,"binary":false,"changes":98,"status":"added"}]}