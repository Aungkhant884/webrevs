{"files":[{"patch":"@@ -1,388 +0,0 @@\n-\/*\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package sun.security.provider;\n-\n-import java.net.URL;\n-import java.util.*;\n-import java.security.CodeSource;\n-import java.security.Principal;\n-import java.security.cert.Certificate;\n-import java.lang.reflect.Constructor;\n-\n-import javax.security.auth.Subject;\n-import sun.security.provider.PolicyParser.PrincipalEntry;\n-import sun.security.util.ResourcesMgr;\n-\n-\/**\n- * <p> This <code>SubjectCodeSource<\/code> class contains\n- * a <code>URL<\/code>, signer certificates, and either a <code>Subject<\/code>\n- * (that represents the <code>Subject<\/code> in the current\n- * <code>AccessControlContext<\/code>), or a linked list of Principals\n- * (that represent a \"subject\" in a <code>Policy<\/code>).\n- *\n- *\/\n-class SubjectCodeSource extends CodeSource implements java.io.Serializable {\n-\n-    @java.io.Serial\n-    private static final long serialVersionUID = 6039418085604715275L;\n-\n-    private final Subject subject;\n-    private final LinkedList<PrincipalEntry> principals;\n-    private static final Class<?>[] PARAMS = { String.class };\n-    private static final sun.security.util.Debug debug =\n-        sun.security.util.Debug.getInstance(\"auth\", \"\\t[Auth Access]\");\n-    @SuppressWarnings(\"serial\") \/\/ Not statically typed as Serializable\n-    private final ClassLoader sysClassLoader;\n-\n-    \/**\n-     * Creates a new <code>SubjectCodeSource<\/code>\n-     * with the given <code>Subject<\/code>, principals, <code>URL<\/code>,\n-     * and signers (Certificates).  The <code>Subject<\/code>\n-     * represents the <code>Subject<\/code> associated with the current\n-     * <code>AccessControlContext<\/code>.\n-     * The Principals are given as a <code>LinkedList<\/code>\n-     * of <code>PolicyParser.PrincipalEntry<\/code> objects.\n-     * Typically either a <code>Subject<\/code> will be provided,\n-     * or a list of <code>principals<\/code> will be provided\n-     * (not both).\n-     *\n-     * <p>\n-     *\n-     * @param subject the <code>Subject<\/code> associated with this\n-     *                  <code>SubjectCodeSource<\/code> <p>\n-     *\n-     * @param url the <code>URL<\/code> associated with this\n-     *                  <code>SubjectCodeSource<\/code> <p>\n-     *\n-     * @param certs the signers associated with this\n-     *                  <code>SubjectCodeSource<\/code> <p>\n-     *\/\n-    @SuppressWarnings(\"removal\")\n-    SubjectCodeSource(Subject subject,\n-        LinkedList<PrincipalEntry> principals,\n-        URL url, Certificate[] certs) {\n-\n-        super(url, certs);\n-        this.subject = subject;\n-        this.principals = (principals == null ?\n-                new LinkedList<PrincipalEntry>() :\n-                new LinkedList<PrincipalEntry>(principals));\n-        sysClassLoader = java.security.AccessController.doPrivileged\n-        (new java.security.PrivilegedAction<ClassLoader>() {\n-            public ClassLoader run() {\n-                    return ClassLoader.getSystemClassLoader();\n-            }\n-        });\n-    }\n-\n-    \/**\n-     * Get the Principals associated with this <code>SubjectCodeSource<\/code>.\n-     * The Principals are retrieved as a <code>LinkedList<\/code>\n-     * of <code>PolicyParser.PrincipalEntry<\/code> objects.\n-     *\n-     * <p>\n-     *\n-     * @return the Principals associated with this\n-     *          <code>SubjectCodeSource<\/code> as a <code>LinkedList<\/code>\n-     *          of <code>PolicyParser.PrincipalEntry<\/code> objects.\n-     *\/\n-    LinkedList<PrincipalEntry> getPrincipals() {\n-        return principals;\n-    }\n-\n-    \/**\n-     * Get the <code>Subject<\/code> associated with this\n-     * <code>SubjectCodeSource<\/code>.  The <code>Subject<\/code>\n-     * represents the <code>Subject<\/code> associated with the\n-     * current <code>AccessControlContext<\/code>.\n-     *\n-     * <p>\n-     *\n-     * @return the <code>Subject<\/code> associated with this\n-     *          <code>SubjectCodeSource<\/code>.\n-     *\/\n-    Subject getSubject() {\n-        return subject;\n-    }\n-\n-    \/**\n-     * Returns true if this <code>SubjectCodeSource<\/code> object \"implies\"\n-     * the specified <code>CodeSource<\/code>.\n-     * More specifically, this method makes the following checks.\n-     * If any fail, it returns false.  If they all succeed, it returns true.\n-     *\n-     * <p>\n-     * <ol>\n-     * <li> The provided codesource must not be <code>null<\/code>.\n-     * <li> codesource must be an instance of <code>SubjectCodeSource<\/code>.\n-     * <li> super.implies(codesource) must return true.\n-     * <li> for each principal in this codesource's principal list:\n-     * <ol>\n-     * <li>     if the principal is an instanceof\n-     *          <code>Principal<\/code>, then the principal must\n-     *          imply the provided codesource's <code>Subject<\/code>.\n-     * <li>     if the principal is not an instanceof\n-     *          <code>Principal<\/code>, then the provided\n-     *          codesource's <code>Subject<\/code> must have an\n-     *          associated <code>Principal<\/code>, <i>P<\/i>, where\n-     *          P.getClass().getName equals principal.principalClass,\n-     *          and P.getName() equals principal.principalName.\n-     * <\/ol>\n-     * <\/ol>\n-     *\n-     * <p>\n-     *\n-     * @param codesource the <code>CodeSource<\/code> to compare against.\n-     *\n-     * @return true if this <code>SubjectCodeSource<\/code> implies\n-     *          the specified <code>CodeSource<\/code>.\n-     *\/\n-    public boolean implies(CodeSource codesource) {\n-\n-        LinkedList<PrincipalEntry> subjectList = null;\n-\n-        if (!(codesource instanceof SubjectCodeSource that) ||\n-                !super.implies(codesource)) {\n-\n-            if (debug != null)\n-                debug.println(\"\\tSubjectCodeSource.implies: FAILURE 1\");\n-            return false;\n-        }\n-\n-        \/\/ if the principal list in the policy \"implies\"\n-        \/\/ the Subject associated with the current AccessControlContext,\n-        \/\/ then return true\n-\n-        if (this.principals == null) {\n-            if (debug != null)\n-                debug.println(\"\\tSubjectCodeSource.implies: PASS 1\");\n-            return true;\n-        }\n-\n-        if (that.getSubject() == null ||\n-            that.getSubject().getPrincipals().size() == 0) {\n-            if (debug != null)\n-                debug.println(\"\\tSubjectCodeSource.implies: FAILURE 2\");\n-            return false;\n-        }\n-\n-        ListIterator<PrincipalEntry> li = this.principals.listIterator(0);\n-        while (li.hasNext()) {\n-            PrincipalEntry pppe = li.next();\n-            try {\n-\n-                \/\/ use new Principal.implies method\n-\n-                Class<?> pClass = Class.forName(pppe.principalClass,\n-                                                true, sysClassLoader);\n-                if (!Principal.class.isAssignableFrom(pClass)) {\n-                    \/\/ not the right subtype\n-                    throw new ClassCastException(pppe.principalClass +\n-                                                 \" is not a Principal\");\n-                }\n-                Constructor<?> c = pClass.getConstructor(PARAMS);\n-                Principal p = (Principal)c.newInstance(new Object[] {\n-                                                       pppe.principalName });\n-\n-                if (!p.implies(that.getSubject())) {\n-                    if (debug != null)\n-                        debug.println(\"\\tSubjectCodeSource.implies: FAILURE 3\");\n-                    return false;\n-                } else {\n-                    if (debug != null)\n-                        debug.println(\"\\tSubjectCodeSource.implies: PASS 2\");\n-                    return true;\n-                }\n-            } catch (Exception e) {\n-\n-                \/\/ simply compare Principals\n-\n-                if (subjectList == null) {\n-\n-                    if (that.getSubject() == null) {\n-                        if (debug != null)\n-                            debug.println(\"\\tSubjectCodeSource.implies: \" +\n-                                        \"FAILURE 4\");\n-                        return false;\n-                    }\n-                    Iterator<Principal> i =\n-                                that.getSubject().getPrincipals().iterator();\n-\n-                    subjectList = new LinkedList<>();\n-                    while (i.hasNext()) {\n-                        Principal p = i.next();\n-                        PrincipalEntry spppe = new PrincipalEntry\n-                                (p.getClass().getName(), p.getName());\n-                        subjectList.add(spppe);\n-                    }\n-                }\n-\n-                if (!subjectListImpliesPrincipalEntry(subjectList, pppe)) {\n-                    if (debug != null)\n-                        debug.println(\"\\tSubjectCodeSource.implies: FAILURE 5\");\n-                    return false;\n-                }\n-            }\n-        }\n-\n-        if (debug != null)\n-            debug.println(\"\\tSubjectCodeSource.implies: PASS 3\");\n-        return true;\n-    }\n-\n-    \/**\n-     * This method returns, true, if the provided <i>subjectList<\/i>\n-     * \"contains\" the <code>Principal<\/code> specified\n-     * in the provided <i>pppe<\/i> argument.\n-     *\n-     * Note that the provided <i>pppe<\/i> argument may have\n-     * wildcards (*) for the <code>Principal<\/code> class and name,\n-     * which need to be considered.\n-     *\n-     * <p>\n-     *\n-     * @param subjectList a list of PolicyParser.PrincipalEntry objects\n-     *          that correspond to all the Principals in the Subject currently\n-     *          on this thread's AccessControlContext. <p>\n-     *\n-     * @param pppe the Principals specified in a grant entry.\n-     *\n-     * @return true if the provided <i>subjectList<\/i> \"contains\"\n-     *          the <code>Principal<\/code> specified in the provided\n-     *          <i>pppe<\/i> argument.\n-     *\/\n-    private boolean subjectListImpliesPrincipalEntry(\n-                LinkedList<PrincipalEntry> subjectList, PrincipalEntry pppe) {\n-\n-        ListIterator<PrincipalEntry> li = subjectList.listIterator(0);\n-        while (li.hasNext()) {\n-            PrincipalEntry listPppe = li.next();\n-\n-            if (pppe.getPrincipalClass().equals\n-                        (PrincipalEntry.WILDCARD_CLASS) ||\n-                pppe.getPrincipalClass().equals(listPppe.getPrincipalClass()))\n-            {\n-                if (pppe.getPrincipalName().equals\n-                        (PrincipalEntry.WILDCARD_NAME) ||\n-                    pppe.getPrincipalName().equals(listPppe.getPrincipalName()))\n-                    return true;\n-            }\n-        }\n-        return false;\n-    }\n-\n-    \/**\n-     * Tests for equality between the specified object and this\n-     * object. Two <code>SubjectCodeSource<\/code> objects are considered equal\n-     * if their locations are of identical value, if the two sets of\n-     * Certificates are of identical values, and if the\n-     * Subjects are equal, and if the PolicyParser.PrincipalEntry values\n-     * are of identical values.  It is not required that\n-     * the Certificates or PolicyParser.PrincipalEntry values\n-     * be in the same order.\n-     *\n-     * <p>\n-     *\n-     * @param obj the object to test for equality with this object.\n-     *\n-     * @return true if the objects are considered equal, false otherwise.\n-     *\/\n-    public boolean equals(Object obj) {\n-\n-        if (obj == this)\n-            return true;\n-\n-        if (!super.equals(obj))\n-            return false;\n-\n-        if (!(obj instanceof SubjectCodeSource that))\n-            return false;\n-\n-        \/\/ the principal lists must match\n-        try {\n-            if (this.getSubject() != that.getSubject())\n-                return false;\n-        } catch (SecurityException se) {\n-            return false;\n-        }\n-\n-        if ((this.principals == null && that.principals != null) ||\n-            (this.principals != null && that.principals == null))\n-            return false;\n-\n-        if (this.principals != null) {\n-            return this.principals.containsAll(that.principals) &&\n-                    that.principals.containsAll(this.principals);\n-        }\n-\n-        return true;\n-    }\n-\n-    \/**\n-     * Return a hashcode for this <code>SubjectCodeSource<\/code>.\n-     *\n-     * <p>\n-     *\n-     * @return a hashcode for this <code>SubjectCodeSource<\/code>.\n-     *\/\n-    public int hashCode() {\n-        return super.hashCode();\n-    }\n-\n-    \/**\n-     * Return a String representation of this <code>SubjectCodeSource<\/code>.\n-     *\n-     * <p>\n-     *\n-     * @return a String representation of this <code>SubjectCodeSource<\/code>.\n-     *\/\n-    @SuppressWarnings(\"removal\")\n-    public String toString() {\n-        String returnMe = super.toString();\n-        if (getSubject() != null) {\n-            if (debug != null) {\n-                final Subject finalSubject = getSubject();\n-                returnMe = returnMe + \"\\n\" +\n-                        java.security.AccessController.doPrivileged\n-                                (new java.security.PrivilegedAction<String>() {\n-                                public String run() {\n-                                    return finalSubject.toString();\n-                                }\n-                        });\n-            } else {\n-                returnMe = returnMe + \"\\n\" + getSubject().toString();\n-            }\n-        }\n-        if (principals != null) {\n-            for (PrincipalEntry pppe : principals) {\n-                returnMe = returnMe + ResourcesMgr.getAuthResourceString(\"NEWLINE\") +\n-                        pppe.getPrincipalClass() + \" \" +\n-                        pppe.getPrincipalName();\n-            }\n-        }\n-        return returnMe;\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/SubjectCodeSource.java","additions":0,"deletions":388,"binary":false,"changes":388,"status":"deleted"},{"patch":"@@ -34,0 +34,3 @@\n+ *\n+ * Note: SubjectCodeSource removed, but PolicyFile might have the same problem. Keep the test as-is\n+ *\n","filename":"test\/jdk\/sun\/security\/provider\/PolicyFile\/Comparator.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"}]}