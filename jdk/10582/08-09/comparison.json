{"files":[{"patch":"@@ -1220,0 +1220,11 @@\n+void MacroAssembler::andq(Register dst, AddressLiteral src, Register rscratch) {\n+  assert(rscratch != noreg || always_reachable(src), \"missing\");\n+\n+  if (reachable(src)) {\n+    andq(dst, as_Address(src));\n+  } else {\n+    lea(rscratch, src);\n+    andq(dst, Address(rscratch, 0));\n+  }\n+}\n+\n@@ -9108,0 +9119,34 @@\n+\n+void MacroAssembler::evpandq(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register rscratch) {\n+  assert(rscratch != noreg || always_reachable(src), \"missing\");\n+\n+  if (reachable(src)) {\n+    evpandq(dst, nds, as_Address(src), vector_len);\n+  } else {\n+    lea(rscratch, src);\n+    evpandq(dst, nds, Address(rscratch, 0), vector_len);\n+  }\n+}\n+\n+void MacroAssembler::evporq(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register rscratch) {\n+  assert(rscratch != noreg || always_reachable(src), \"missing\");\n+\n+  if (reachable(src)) {\n+    evporq(dst, nds, as_Address(src), vector_len);\n+  } else {\n+    lea(rscratch, src);\n+    evporq(dst, nds, Address(rscratch, 0), vector_len);\n+  }\n+}\n+\n+void MacroAssembler::vpternlogq(XMMRegister dst, int imm8, XMMRegister src2, AddressLiteral src3, int vector_len, Register rscratch) {\n+  assert(rscratch != noreg || always_reachable(src3), \"missing\");\n+\n+  if (reachable(src3)) {\n+    vpternlogq(dst, imm8, src2, as_Address(src3), vector_len);\n+  } else {\n+    lea(rscratch, src3);\n+    vpternlogq(dst, imm8, src2, Address(rscratch, 0), vector_len);\n+  }\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":45,"deletions":0,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -733,0 +733,3 @@\n+  using Assembler::andq;\n+  void andq(Register dst, AddressLiteral src, Register rscratch = noreg);\n+\n@@ -970,1 +973,0 @@\n-\n@@ -980,1 +982,0 @@\n-\n@@ -1759,0 +1760,9 @@\n+  using Assembler::evpandq;\n+  void evpandq(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register rscratch = noreg);\n+\n+  using Assembler::evporq;\n+  void evporq(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register rscratch = noreg);\n+\n+  using Assembler::vpternlogq;\n+  void vpternlogq(XMMRegister dst, int imm8, XMMRegister src2, AddressLiteral src3, int vector_len, Register rscratch = noreg);\n+\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":12,"deletions":2,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -398,1 +398,1 @@\n-                                 const XMMRegister R0, const XMMRegister R1, const XMMRegister R2, const XMMRegister R1P, const XMMRegister R2P, const Register polyCP);\n+                                 const XMMRegister R0, const XMMRegister R1, const XMMRegister R2, const XMMRegister R1P, const XMMRegister R2P);\n@@ -402,1 +402,1 @@\n-                             const XMMRegister L0, const XMMRegister L1, const XMMRegister L2, bool padMSG, const Register polyCP);\n+                             const XMMRegister L0, const XMMRegister L1, const XMMRegister L2, bool padMSG);\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -81,8 +81,2 @@\n-\/\/ Constant Pool Offsets:\n-enum polyCPOffset {\n-  high_bit = 0,\n-  mask_44 = 64,\n-  mask_42 = 128,\n-};\n-ATTRIBUTE_ALIGNED(64) uint64_t POLY1305_CP[] = {\n-  \/\/ OFFSET 0: high_bit\n+\/\/ Constant Pool:\n+ATTRIBUTE_ALIGNED(64) uint64_t POLY1305_PAD_MSG[] = {\n@@ -93,0 +87,4 @@\n+};\n+static address poly1305_pad_msg() {\n+  return (address)POLY1305_PAD_MSG;\n+}\n@@ -94,0 +92,11 @@\n+ATTRIBUTE_ALIGNED(64) uint64_t POLY1305_MASK42[] = {\n+  0x000003ffffffffff, 0x000003ffffffffff,\n+  0x000003ffffffffff, 0x000003ffffffffff,\n+  0x000003ffffffffff, 0x000003ffffffffff,\n+  0x000003ffffffffff, 0x000003ffffffffff\n+};\n+static address poly1305_mask42() {\n+  return (address)POLY1305_MASK42;\n+}\n+\n+ATTRIBUTE_ALIGNED(64) uint64_t POLY1305_MASK44[] = {\n@@ -95,10 +104,4 @@\n-  0xfffffffffff, 0xfffffffffff,\n-  0xfffffffffff, 0xfffffffffff,\n-  0xfffffffffff, 0xfffffffffff,\n-  0xfffffffffff, 0xfffffffffff,\n-\n-  \/\/ OFFSET 128: mask_42\n-  0x3ffffffffff, 0x3ffffffffff,\n-  0x3ffffffffff, 0x3ffffffffff,\n-  0x3ffffffffff, 0x3ffffffffff,\n-  0x3ffffffffff, 0x3ffffffffff\n+  0x00000fffffffffff, 0x00000fffffffffff,\n+  0x00000fffffffffff, 0x00000fffffffffff,\n+  0x00000fffffffffff, 0x00000fffffffffff,\n+  0x00000fffffffffff, 0x00000fffffffffff,\n@@ -106,2 +109,2 @@\n-static address poly1305_mask_addr() {\n-  return (address)POLY1305_CP;\n+static address poly1305_mask44() {\n+  return (address)POLY1305_MASK44;\n@@ -149,1 +152,1 @@\n-  const XMMRegister R0, const XMMRegister R1, const XMMRegister R2, const XMMRegister R1P, const XMMRegister R2P, const Register polyCP)\n+  const XMMRegister R0, const XMMRegister R1, const XMMRegister R2, const XMMRegister R1P, const XMMRegister R2P)\n@@ -158,0 +161,1 @@\n+  const Register polyCP = r13;\n@@ -197,1 +201,1 @@\n-  __ evpandq(A0, P0_L, Address(polyCP, mask_44), Assembler::AVX_512bit); \/\/ Clear top 20 bits\n+  __ evpandq(A0, P0_L, ExternalAddress(poly1305_mask44()), Assembler::AVX_512bit, polyCP); \/\/ Clear top 20 bits\n@@ -202,1 +206,1 @@\n-  __ evpandq(A1, P1_L, Address(polyCP, mask_44), Assembler::AVX_512bit); \/\/ Clear top 20 bits\n+  __ evpandq(A1, P1_L, ExternalAddress(poly1305_mask44()), Assembler::AVX_512bit, polyCP); \/\/ Clear top 20 bits\n@@ -208,1 +212,1 @@\n-  __ evpandq(A2, P2_L, Address(polyCP, mask_42), Assembler::AVX_512bit); \/\/ Clear top 22 bits\n+  __ evpandq(A2, P2_L, ExternalAddress(poly1305_mask42()), Assembler::AVX_512bit, polyCP); \/\/ Clear top 22 bits\n@@ -220,1 +224,1 @@\n-  __ evpandq(A0, A0, Address(polyCP, mask_44), Assembler::AVX_512bit);\n+  __ evpandq(A0, A0, ExternalAddress(poly1305_mask44()), Assembler::AVX_512bit, polyCP);\n@@ -348,1 +352,1 @@\n-    const XMMRegister L0, const XMMRegister L1, const XMMRegister L2, bool padMSG, const Register polyCP)\n+    const XMMRegister L0, const XMMRegister L1, const XMMRegister L2, bool padMSG)\n@@ -352,0 +356,2 @@\n+  const Register polyCP = r13;\n+\n@@ -359,1 +365,1 @@\n-    __ evporq(L2, L2, Address(polyCP, high_bit), Assembler::AVX_512bit); \/\/ Add 2^128 to all 8 final qwords of the message\n+    __ evporq(L2, L2, ExternalAddress(poly1305_pad_msg()), Assembler::AVX_512bit, polyCP); \/\/ Add 2^128 to all 8 final qwords of the message\n@@ -365,1 +371,1 @@\n-  __ vpternlogq(L1, 0xA8, TMP2, Address(polyCP, mask_44), Assembler::AVX_512bit); \/\/ (A OR B AND C)\n+  __ vpternlogq(L1, 0xA8, TMP2, ExternalAddress(poly1305_mask44()), Assembler::AVX_512bit, polyCP); \/\/ (A OR B AND C)\n@@ -368,1 +374,1 @@\n-  __ evpandq(L0, L0, Address(polyCP, mask_44), Assembler::AVX_512bit);\n+  __ evpandq(L0, L0, ExternalAddress(poly1305_mask44()), Assembler::AVX_512bit, polyCP);\n@@ -594,1 +600,0 @@\n-  __ lea(polyCP, ExternalAddress(poly1305_mask_addr()));\n@@ -598,1 +603,1 @@\n-  __ andq(t0, Address(polyCP, mask_44)); \/\/ First limb (Acc[43:0])\n+  __ andq(t0, ExternalAddress(poly1305_mask44()), polyCP); \/\/ First limb (Acc[43:0])\n@@ -603,1 +608,1 @@\n-  __ andq(a0, Address(polyCP, mask_44)); \/\/ Second limb (Acc[77:52])\n+  __ andq(a0, ExternalAddress(poly1305_mask44()), polyCP); \/\/ Second limb (Acc[77:52])\n@@ -607,1 +612,1 @@\n-  __ andq(a1, Address(polyCP, mask_42)); \/\/ Third limb (Acc[129:88])\n+  __ andq(a1, ExternalAddress(poly1305_mask42()), polyCP); \/\/ Third limb (Acc[129:88])\n@@ -618,1 +623,1 @@\n-  poly1305_limbs_avx512(T0, T1, A0, A1, A2, true, polyCP);\n+  poly1305_limbs_avx512(T0, T1, A0, A1, A2, true);\n@@ -631,1 +636,1 @@\n-  poly1305_limbs_avx512(T0, T1, A3, A4, A5, true, polyCP);\n+  poly1305_limbs_avx512(T0, T1, A3, A4, A5, true);\n@@ -678,1 +683,0 @@\n-  __ lea(polyCP, ExternalAddress(poly1305_mask_addr()));\n@@ -680,1 +684,1 @@\n-  poly1305_limbs_avx512(T0, T2, B0, B1, B2, false, polyCP);\n+  poly1305_limbs_avx512(T0, T2, B0, B1, B2, false);\n@@ -688,1 +692,1 @@\n-  __ andq(t0, Address(polyCP, mask_44)); \/\/ First limb (R^4[43:0])\n+  __ andq(t0, ExternalAddress(poly1305_mask44()), polyCP); \/\/ First limb (R^4[43:0])\n@@ -693,1 +697,1 @@\n-  __ andq(a0, Address(polyCP, mask_44)); \/\/ Second limb (R^4[87:44])\n+  __ andq(a0, ExternalAddress(poly1305_mask44()), polyCP); \/\/ Second limb (R^4[87:44])\n@@ -697,1 +701,1 @@\n-  __ andq(a1, Address(polyCP, mask_42)); \/\/ Third limb (R^4[129:88])\n+  __ andq(a1, ExternalAddress(poly1305_mask42()), polyCP); \/\/ Third limb (R^4[129:88])\n@@ -717,2 +721,1 @@\n-                            R0, R1, R2, R1P, R2P,   \/\/ R^4..R^4, 4*5*R^4\n-                            polyCP);\n+                            R0, R1, R2, R1P, R2P);  \/\/ R^4..R^4, 4*5*R^4\n@@ -744,3 +747,2 @@\n-  poly1305_multiply8_avx512(B0, B1, B2,           \/\/ ACC=R^8..R^1\n-                            R0, R1, R2, R1P, R2P, \/\/ R^8..R^8, 4*5*R^8\n-                            polyCP);\n+  poly1305_multiply8_avx512(B0, B1, B2,            \/\/ ACC=R^8..R^1\n+                            R0, R1, R2, R1P, R2P); \/\/ R^8..R^8, 4*5*R^8\n@@ -774,1 +776,1 @@\n-  poly1305_limbs_avx512(T0, T1, B0, B1, B2, true, polyCP);\n+  poly1305_limbs_avx512(T0, T1, B0, B1, B2, true);\n@@ -779,1 +781,1 @@\n-  poly1305_limbs_avx512(T0, T1, B3, B4, B5, true, polyCP);\n+  poly1305_limbs_avx512(T0, T1, B3, B4, B5, true);\n@@ -782,2 +784,1 @@\n-                            R0, R1, R2, R1P, R2P,  \/\/R^16..R^16, 4*5*R^16\n-                            polyCP);\n+                            R0, R1, R2, R1P, R2P); \/\/R^16..R^16, 4*5*R^16\n@@ -785,2 +786,1 @@\n-                            R0, R1, R2, R1P, R2P,  \/\/R^16..R^16, 4*5*R^16\n-                            polyCP);\n+                            R0, R1, R2, R1P, R2P); \/\/R^16..R^16, 4*5*R^16\n@@ -828,2 +828,1 @@\n-                              B0, B1, B2, B3, B4,  \/\/ R^16-R^9, R1P, R2P\n-                              polyCP);\n+                              B0, B1, B2, B3, B4); \/\/ R^16-R^9, R1P, R2P\n@@ -831,2 +830,1 @@\n-                              R0, R1, R2, R1P, R2P,  \/\/ R^8-R, R1P, R2P\n-                              polyCP);\n+                              R0, R1, R2, R1P, R2P); \/\/ R^8-R, R1P, R2P\n@@ -870,1 +868,1 @@\n-  __ evpandq(A0, A0, Address(polyCP, mask_44), Assembler::AVX_512bit); \/\/ Clear top 20 bits\n+  __ evpandq(A0, A0, ExternalAddress(poly1305_mask44()), Assembler::AVX_512bit, polyCP); \/\/ Clear top 20 bits\n@@ -873,1 +871,1 @@\n-  __ evpandq(A1, A1, Address(polyCP, mask_44), Assembler::AVX_512bit); \/\/ Clear top 20 bits\n+  __ evpandq(A1, A1, ExternalAddress(poly1305_mask44()), Assembler::AVX_512bit, polyCP); \/\/ Clear top 20 bits\n@@ -876,1 +874,1 @@\n-  __ evpandq(A2, A2, Address(polyCP, mask_42), Assembler::AVX_512bit); \/\/ Clear top 22 bits\n+  __ evpandq(A2, A2, ExternalAddress(poly1305_mask42()), Assembler::AVX_512bit, polyCP); \/\/ Clear top 22 bits\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64_poly.cpp","additions":56,"deletions":58,"binary":false,"changes":114,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2021, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/cpu\/x86\/stubRoutines_x86.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1179,12 +1179,0 @@\n-#ifdef _LP64\n-  if (supports_avx512ifma() & supports_avx512vlbw()) {\n-    if (FLAG_IS_DEFAULT(UsePolyIntrinsics)) {\n-      FLAG_SET_DEFAULT(UsePolyIntrinsics, true);\n-    }\n-  } else\n-#endif\n-  if (UsePolyIntrinsics) {\n-    warning(\"Intrinsics for Poly1305 crypto hash functions not available on this CPU.\");\n-    FLAG_SET_DEFAULT(UsePolyIntrinsics, false);\n-  }\n-\n@@ -1350,0 +1338,12 @@\n+#ifdef _LP64\n+  if (supports_avx512ifma() & supports_avx512vlbw() & MaxVectorSize >= 64) {\n+    if (FLAG_IS_DEFAULT(UsePolyIntrinsics)) {\n+      FLAG_SET_DEFAULT(UsePolyIntrinsics, true);\n+    }\n+  } else\n+#endif\n+  if (UsePolyIntrinsics) {\n+    warning(\"Intrinsics for Poly1305 crypto hash functions not available on this CPU.\");\n+    FLAG_SET_DEFAULT(UsePolyIntrinsics, false);\n+  }\n+\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.cpp","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -524,5 +524,0 @@\n-  \/* support for com.sun.crypto.provider.Poly1305 *\/                                                                    \\\n-  do_class(com_sun_crypto_provider_Poly1305, \"com\/sun\/crypto\/provider\/Poly1305\")                                        \\\n-  do_intrinsic(_poly1305_processBlocks, com_sun_crypto_provider_Poly1305, processMultipleBlocks_name, putCharStringU_signature, F_R) \\\n-   do_name(processMultipleBlocks_name, \"processMultipleBlocks\")                                                         \\\n-                                                                                                                        \\\n@@ -534,0 +529,5 @@\n+                                                                                                                        \\\n+  \/* support for com.sun.crypto.provider.Poly1305 *\/                                                                    \\\n+  do_class(com_sun_crypto_provider_Poly1305, \"com\/sun\/crypto\/provider\/Poly1305\")                                        \\\n+  do_intrinsic(_poly1305_processBlocks, com_sun_crypto_provider_Poly1305, processMultipleBlocks_name, ghash_processBlocks_signature, F_R) \\\n+   do_name(processMultipleBlocks_name, \"processMultipleBlocks\")                                                         \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -6976,1 +6976,1 @@\n-  assert(callee()->signature()->size() == 3, \"poly1305_processBlocks has %d parameters\", callee()->signature()->size());\n+  assert(callee()->signature()->size() == 5, \"poly1305_processBlocks has %d parameters\", callee()->signature()->size());\n@@ -6985,32 +6985,2 @@\n-\n-  Node* accFace = load_field_from_object(polyObj, \"a\", \"Lsun\/security\/util\/math\/MutableIntegerModuloP;\");\n-  assert(accFace != NULL, \"Accumulator field is null\");\n-  const TypeInstPtr* ainst = _gvn.type(accFace)->isa_instptr();\n-  assert(ainst != NULL, \"Accumulator obj is null\");\n-  assert(ainst->is_loaded(), \"MutableIntegerModuloP obj is not loaded\");\n-  ciKlass* klass_MutableElement = ainst->instance_klass()->find_klass(ciSymbol::make(\"sun\/security\/util\/math\/intpoly\/IntegerPolynomial$MutableElement\"));\n-  assert(klass_MutableElement != NULL, \"IntegerPolynomial$MutableElement class is null\");\n-  assert(klass_MutableElement->is_loaded(), \"IntegerPolynomial$MutableElement class is not loaded\");\n-  ciInstanceKlass* instklass_MutableElement = klass_MutableElement->as_instance_klass();\n-\n-  const TypeKlassPtr* aklass = TypeKlassPtr::make(instklass_MutableElement);\n-  const TypeOopPtr* atype = aklass->as_instance_type()->cast_to_ptr_type(TypePtr::NotNull);\n-  Node* accObj = new CheckCastPPNode(control(), accFace, atype);\n-  accObj = _gvn.transform(accObj);\n-  Node* alimbs = load_field_from_object(accObj, \"limbs\", \"[J\");\n-\n-  Node* rFace = load_field_from_object(polyObj, \"r\", \"Lsun\/security\/util\/math\/IntegerModuloP;\"); \/\/this.r.limbs\n-  assert(rFace != NULL, \"R field is null\");\n-  const TypeInstPtr* rinst = _gvn.type(rFace)->isa_instptr();\n-  assert(rinst != NULL, \"R obj is null\");\n-  assert(rinst->is_loaded(), \"IntegerModuloP obj is not loaded\");\n-  ciKlass* klass_ImmutableElement = rinst->instance_klass()->find_klass(ciSymbol::make(\"sun\/security\/util\/math\/intpoly\/IntegerPolynomial$ImmutableElement\"));\n-  assert(klass_ImmutableElement != NULL, \"IntegerPolynomial$ImmutableElement class is null\");\n-  assert(klass_ImmutableElement->is_loaded(), \"IntegerPolynomial$ImmutableElement class is not loaded\");\n-  ciInstanceKlass* instklass_ImmutableElement = klass_ImmutableElement->as_instance_klass();\n-\n-  const TypeKlassPtr* rklass = TypeKlassPtr::make(instklass_ImmutableElement);\n-  const TypeOopPtr* rtype = rklass->as_instance_type()->cast_to_ptr_type(TypePtr::NotNull);\n-  Node* rObj = new CheckCastPPNode(control(), rFace, rtype);\n-  rObj = _gvn.transform(rObj);\n-  Node* rlimbs = load_field_from_object(rObj, \"limbs\", \"[J\");\n+  Node* alimbs = argument(4);\n+  Node* rlimbs = argument(5);\n@@ -7022,7 +6992,0 @@\n-  \/\/ Intrinsic assumes there are exactly 5 limbs! Currently enforced by IntegerModuloP.checkLimbsForIntrinsic\n-  \/\/ FIXME: where to branch to if limbs array length != 5? Could be an 'assert'\/RuntimeException\n-  \/\/ FIXME: repeat for rlimbs\n-  \/\/ Node* cmp = _gvn.transform(new CmpINode(load_array_length(alimbs), intcon(5)));\n-  \/\/ Node* bol = _gvn.transform(new BoolNode(cmp, BoolTest::eq));\n-  \/\/ Node* if_eq = generate_slow_guard(bol, slow_region);\n-\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":3,"deletions":40,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -175,4 +175,4 @@\n-        Objects.checkFromIndexSize(offset, blockMultipleLength, input.length);\n-        a.checkLimbsForIntrinsic();\n-        r.checkLimbsForIntrinsic();\n-        processMultipleBlocks(input, offset, blockMultipleLength);\n+        long[] aLimbs = a.getLimbs();\n+        long[] rLimbs = r.getLimbs();\n+        processMultipleBlocksCheck(input, offset, blockMultipleLength, aLimbs, rLimbs);\n+        processMultipleBlocks(input, offset, blockMultipleLength, aLimbs, rLimbs);\n@@ -249,1 +249,1 @@\n-    private void processMultipleBlocks(byte[] input, int offset, int length) {\n+    private void processMultipleBlocks(byte[] input, int offset, int length, long[] aLimbs, long[] rLimbs) {\n@@ -259,0 +259,11 @@\n+    private static void processMultipleBlocksCheck(byte[] input, int offset, int length, long[] aLimbs, long[] rLimbs) {\n+        Objects.checkFromIndexSize(offset, length, input.length);\n+        final int numLimbs = 5; \/\/ Intrinsic expects exactly 5 limbs\n+        if (aLimbs.length != numLimbs) {\n+            throw new RuntimeException(\"invalid accumulator length: \" + aLimbs.length);\n+        }\n+        if (rLimbs.length != numLimbs) {\n+            throw new RuntimeException(\"invalid R length: \" + rLimbs.length);\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/Poly1305.java","additions":16,"deletions":5,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -212,2 +212,1 @@\n-     * Enforce java to IntrinsicCandidate 'contract'\n-     * @throws IndexOutOfBoundsException if the check fails\n+     * Break encapsulation, used for IntrinsicCandidate functions\n@@ -215,1 +214,1 @@\n-    void checkLimbsForIntrinsic();\n+    long[] getLimbs();\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/math\/IntegerModuloP.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -35,2 +35,0 @@\n-import jdk.internal.util.Preconditions;\n-\n@@ -632,2 +630,2 @@\n-        public void checkLimbsForIntrinsic() {\n-            Preconditions.checkFromIndexSize(0, numLimbs, limbs.length, null);\n+        public long[] getLimbs() {\n+            return limbs;\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/math\/intpoly\/IntegerPolynomial.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"}]}