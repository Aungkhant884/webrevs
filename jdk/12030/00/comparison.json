{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n-  assert(_class_name != NULL, \"invariant\");\n+  assert(_class_name != nullptr, \"invariant\");\n@@ -47,1 +47,1 @@\n-  assert(_class_name != NULL, \"invariant\");\n+  assert(_class_name != nullptr, \"invariant\");\n@@ -56,1 +56,1 @@\n-  assert(_class_name != NULL, \"invariant\");\n+  assert(_class_name != nullptr, \"invariant\");\n@@ -66,1 +66,1 @@\n-  assert(_class_name != NULL, \"invariant\");\n+  assert(_class_name != nullptr, \"invariant\");\n@@ -76,1 +76,1 @@\n-  assert(_class_name != NULL, \"invariant\");\n+  assert(_class_name != nullptr, \"invariant\");\n@@ -85,1 +85,1 @@\n-  assert(_class_name != NULL, \"invariant\");\n+  assert(_class_name != nullptr, \"invariant\");\n","filename":"src\/hotspot\/share\/classfile\/classFileError.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -158,2 +158,2 @@\n-  assert(stream != NULL, \"invariant\");\n-  assert(cp != NULL, \"invariant\");\n+  assert(stream != nullptr, \"invariant\");\n+  assert(cp != nullptr, \"invariant\");\n@@ -321,1 +321,1 @@\n-        assert(utf8_buffer != NULL, \"null utf8 buffer\");\n+        assert(utf8_buffer != nullptr, \"null utf8 buffer\");\n@@ -335,1 +335,1 @@\n-        if (result == NULL) {\n+        if (result == nullptr) {\n@@ -398,1 +398,1 @@\n-  assert(cp != NULL, \"invariant\");\n+  assert(cp != nullptr, \"invariant\");\n@@ -402,1 +402,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -426,2 +426,2 @@\n-  assert(cp != NULL, \"invariant\");\n-  assert(stream != NULL, \"invariant\");\n+  assert(cp != nullptr, \"invariant\");\n+  assert(stream != nullptr, \"invariant\");\n@@ -796,1 +796,1 @@\n-  assert(name != NULL, \"name in constant pool is NULL\");\n+  assert(name != nullptr, \"name in constant pool is nullptr\");\n@@ -801,1 +801,1 @@\n-  while (entry != NULL) {\n+  while (entry != nullptr) {\n@@ -826,3 +826,3 @@\n-  assert(stream != NULL, \"invariant\");\n-  assert(cp != NULL, \"invariant\");\n-  assert(has_nonstatic_concrete_methods != NULL, \"invariant\");\n+  assert(stream != nullptr, \"invariant\");\n+  assert(cp != nullptr, \"invariant\");\n+  assert(has_nonstatic_concrete_methods != nullptr, \"invariant\");\n@@ -834,1 +834,1 @@\n-    _local_interfaces = MetadataFactory::new_array<InstanceKlass*>(_loader_data, itfs_len, NULL, CHECK);\n+    _local_interfaces = MetadataFactory::new_array<InstanceKlass*>(_loader_data, itfs_len, nullptr, CHECK);\n@@ -889,1 +889,1 @@\n-    const Symbol* name = NULL;\n+    const Symbol* name = nullptr;\n@@ -895,2 +895,2 @@\n-        \/\/ If no duplicates, add (name, NULL) in hashtable interface_names.\n-        if (!put_after_lookup(name, NULL, interface_names)) {\n+        \/\/ If no duplicates, add (name, null) in hashtable interface_names.\n+        if (!put_after_lookup(name, nullptr, interface_names)) {\n@@ -1031,2 +1031,2 @@\n-    _field_annotations(NULL),\n-    _field_type_annotations(NULL) {}\n+    _field_annotations(nullptr),\n+    _field_type_annotations(nullptr) {}\n@@ -1064,1 +1064,1 @@\n-  assert(buffer != NULL, \"invariant\");\n+  assert(buffer != nullptr, \"invariant\");\n@@ -1078,1 +1078,1 @@\n-  assert(buffer != NULL, \"invariant\");\n+  assert(buffer != nullptr, \"invariant\");\n@@ -1131,4 +1131,4 @@\n-  assert(cp != NULL, \"invariant\");\n-  assert(buffer != NULL, \"invariant\");\n-  assert(coll != NULL, \"invariant\");\n-  assert(loader_data != NULL, \"invariant\");\n+  assert(cp != nullptr, \"invariant\");\n+  assert(buffer != nullptr, \"invariant\");\n+  assert(coll != nullptr, \"invariant\");\n+  assert(loader_data != nullptr, \"invariant\");\n@@ -1165,2 +1165,2 @@\n-    if (aname == NULL)  break;  \/\/ invalid annotation name\n-    const Symbol* member = NULL;\n+    if (aname == nullptr)  break;  \/\/ invalid annotation name\n+    const Symbol* member = nullptr;\n@@ -1170,1 +1170,1 @@\n-      if (member == NULL)  break;  \/\/ invalid member name\n+      if (member == nullptr)  break;  \/\/ invalid member name\n@@ -1215,5 +1215,5 @@\n-  assert(cfs != NULL, \"invariant\");\n-  assert(constantvalue_index_addr != NULL, \"invariant\");\n-  assert(is_synthetic_addr != NULL, \"invariant\");\n-  assert(generic_signature_index_addr != NULL, \"invariant\");\n-  assert(parsed_annotations != NULL, \"invariant\");\n+  assert(cfs != nullptr, \"invariant\");\n+  assert(constantvalue_index_addr != nullptr, \"invariant\");\n+  assert(is_synthetic_addr != nullptr, \"invariant\");\n+  assert(generic_signature_index_addr != nullptr, \"invariant\");\n+  assert(parsed_annotations != nullptr, \"invariant\");\n@@ -1225,1 +1225,1 @@\n-  const u1* runtime_visible_annotations = NULL;\n+  const u1* runtime_visible_annotations = nullptr;\n@@ -1227,1 +1227,1 @@\n-  const u1* runtime_invisible_annotations = NULL;\n+  const u1* runtime_invisible_annotations = nullptr;\n@@ -1229,1 +1229,1 @@\n-  const u1* runtime_visible_type_annotations = NULL;\n+  const u1* runtime_visible_type_annotations = nullptr;\n@@ -1231,1 +1231,1 @@\n-  const u1* runtime_invisible_type_annotations = NULL;\n+  const u1* runtime_invisible_type_annotations = nullptr;\n@@ -1292,1 +1292,1 @@\n-        if (runtime_visible_annotations != NULL) {\n+        if (runtime_visible_annotations != nullptr) {\n@@ -1299,1 +1299,1 @@\n-        assert(runtime_visible_annotations != NULL, \"null visible annotations\");\n+        assert(runtime_visible_annotations != nullptr, \"null visible annotations\");\n@@ -1318,1 +1318,1 @@\n-          assert(runtime_invisible_annotations != NULL, \"null invisible annotations\");\n+          assert(runtime_invisible_annotations != nullptr, \"null invisible annotations\");\n@@ -1322,1 +1322,1 @@\n-        if (runtime_visible_type_annotations != NULL) {\n+        if (runtime_visible_type_annotations != nullptr) {\n@@ -1329,1 +1329,1 @@\n-        assert(runtime_visible_type_annotations != NULL, \"null visible type annotations\");\n+        assert(runtime_visible_type_annotations != nullptr, \"null visible type annotations\");\n@@ -1342,1 +1342,1 @@\n-          assert(runtime_invisible_type_annotations != NULL, \"null invisible type annotations\");\n+          assert(runtime_invisible_type_annotations != nullptr, \"null invisible type annotations\");\n@@ -1469,4 +1469,4 @@\n-  assert(cfs != NULL, \"invariant\");\n-  assert(fac != NULL, \"invariant\");\n-  assert(cp != NULL, \"invariant\");\n-  assert(java_fields_count_ptr != NULL, \"invariant\");\n+  assert(cfs != nullptr, \"invariant\");\n+  assert(fac != nullptr, \"invariant\");\n+  assert(cp != nullptr, \"invariant\");\n+  assert(java_fields_count_ptr != nullptr, \"invariant\");\n@@ -1474,3 +1474,3 @@\n-  assert(NULL == _fields, \"invariant\");\n-  assert(NULL == _fields_annotations, \"invariant\");\n-  assert(NULL == _fields_type_annotations, \"invariant\");\n+  assert(nullptr == _fields, \"invariant\");\n+  assert(nullptr == _fields_annotations, \"invariant\");\n+  assert(nullptr == _fields_type_annotations, \"invariant\");\n@@ -1556,2 +1556,2 @@\n-      if (parsed_annotations.field_annotations() != NULL) {\n-        if (_fields_annotations == NULL) {\n+      if (parsed_annotations.field_annotations() != nullptr) {\n+        if (_fields_annotations == nullptr) {\n@@ -1559,1 +1559,1 @@\n-                                             _loader_data, length, NULL,\n+                                             _loader_data, length, nullptr,\n@@ -1563,1 +1563,1 @@\n-        parsed_annotations.set_field_annotations(NULL);\n+        parsed_annotations.set_field_annotations(nullptr);\n@@ -1565,2 +1565,2 @@\n-      if (parsed_annotations.field_type_annotations() != NULL) {\n-        if (_fields_type_annotations == NULL) {\n+      if (parsed_annotations.field_type_annotations() != nullptr) {\n+        if (_fields_type_annotations == nullptr) {\n@@ -1570,1 +1570,1 @@\n-                                                         NULL,\n+                                                         nullptr,\n@@ -1574,1 +1574,1 @@\n-        parsed_annotations.set_field_type_annotations(NULL);\n+        parsed_annotations.set_field_type_annotations(nullptr);\n@@ -1645,1 +1645,1 @@\n-  assert(NULL == _fields, \"invariant\");\n+  assert(nullptr == _fields, \"invariant\");\n@@ -1674,2 +1674,2 @@\n-    const Symbol* name = NULL;\n-    const Symbol* sig = NULL;\n+    const Symbol* name = nullptr;\n+    const Symbol* sig = nullptr;\n@@ -1700,1 +1700,1 @@\n-  assert(cfs != NULL, \"invariant\");\n+  assert(cfs != nullptr, \"invariant\");\n@@ -1703,1 +1703,1 @@\n-  assert(exception_table_start != NULL, \"null exception table\");\n+  assert(exception_table_start != nullptr, \"null exception table\");\n@@ -1752,1 +1752,1 @@\n-  if ((*write_stream) == NULL) {\n+  if ((*write_stream) == nullptr) {\n@@ -1841,1 +1841,1 @@\n-  assert(localvariable_table_start != NULL, \"null local variable table\");\n+  assert(localvariable_table_start != nullptr, \"null local variable table\");\n@@ -1859,1 +1859,1 @@\n-        return NULL;\n+        return nullptr;\n@@ -1865,1 +1865,1 @@\n-        return NULL;\n+        return nullptr;\n@@ -1900,1 +1900,1 @@\n-  assert(cfs != NULL, \"invariant\");\n+  assert(cfs != nullptr, \"invariant\");\n@@ -1903,1 +1903,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1907,1 +1907,1 @@\n-  assert(stackmap_table_start != NULL, \"null stackmap table\");\n+  assert(stackmap_table_start != nullptr, \"null stackmap table\");\n@@ -1913,1 +1913,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1922,2 +1922,2 @@\n-  assert(cfs != NULL, \"invariant\");\n-  assert(checked_exceptions_length != NULL, \"invariant\");\n+  assert(cfs != nullptr, \"invariant\");\n+  assert(checked_exceptions_length != nullptr, \"invariant\");\n@@ -1930,1 +1930,1 @@\n-  assert(checked_exceptions_start != NULL, \"null checked exceptions\");\n+  assert(checked_exceptions_start != nullptr, \"null checked exceptions\");\n@@ -1959,2 +1959,2 @@\n-  assert(name != NULL, \"invariant\");\n-  assert(sig != NULL, \"invariant\");\n+  assert(name != nullptr, \"invariant\");\n+  assert(sig != nullptr, \"invariant\");\n@@ -2099,1 +2099,1 @@\n-  assert(ik != NULL, \"invariant\");\n+  assert(ik != nullptr, \"invariant\");\n@@ -2175,1 +2175,1 @@\n-      if (entry == NULL) {\n+      if (entry == nullptr) {\n@@ -2240,1 +2240,1 @@\n-                             NULL,\n+                             nullptr,\n@@ -2270,3 +2270,3 @@\n-  assert(cfs != NULL, \"invariant\");\n-  assert(cp != NULL, \"invariant\");\n-  assert(has_localvariable_table != NULL, \"invariant\");\n+  assert(cfs != nullptr, \"invariant\");\n+  assert(cp != nullptr, \"invariant\");\n+  assert(has_localvariable_table != nullptr, \"invariant\");\n@@ -2305,1 +2305,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -2313,1 +2313,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -2323,1 +2323,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -2335,1 +2335,1 @@\n-  const unsafe_u2* exception_table_start = NULL; \/\/ (potentially unaligned) pointer to array of u2 elements\n+  const unsafe_u2* exception_table_start = nullptr; \/\/ (potentially unaligned) pointer to array of u2 elements\n@@ -2338,2 +2338,2 @@\n-  const unsafe_u2* checked_exceptions_start = NULL; \/\/ (potentially unaligned) pointer to array of u2 elements\n-  CompressedLineNumberWriteStream* linenumber_table = NULL;\n+  const unsafe_u2* checked_exceptions_start = nullptr; \/\/ (potentially unaligned) pointer to array of u2 elements\n+  CompressedLineNumberWriteStream* linenumber_table = nullptr;\n@@ -2347,4 +2347,4 @@\n-  u2* localvariable_table_length = NULL;\n-  const unsafe_u2** localvariable_table_start = NULL; \/\/ (potentially unaligned) pointer to array of LVT attributes\n-  u2* localvariable_type_table_length = NULL;\n-  const unsafe_u2** localvariable_type_table_start = NULL; \/\/ (potentially unaligned) pointer to LVTT attributes\n+  u2* localvariable_table_length = nullptr;\n+  const unsafe_u2** localvariable_table_start = nullptr; \/\/ (potentially unaligned) pointer to array of LVT attributes\n+  u2* localvariable_type_table_length = nullptr;\n+  const unsafe_u2** localvariable_type_table_start = nullptr; \/\/ (potentially unaligned) pointer to LVTT attributes\n@@ -2352,1 +2352,1 @@\n-  const u1* method_parameters_data = NULL;\n+  const u1* method_parameters_data = nullptr;\n@@ -2358,1 +2358,1 @@\n-  const u1* stackmap_data = NULL;\n+  const u1* stackmap_data = nullptr;\n@@ -2362,1 +2362,1 @@\n-  const u1* runtime_visible_annotations = NULL;\n+  const u1* runtime_visible_annotations = nullptr;\n@@ -2364,1 +2364,1 @@\n-  const u1* runtime_invisible_annotations = NULL;\n+  const u1* runtime_invisible_annotations = nullptr;\n@@ -2366,1 +2366,1 @@\n-  const u1* runtime_visible_parameter_annotations = NULL;\n+  const u1* runtime_visible_parameter_annotations = nullptr;\n@@ -2368,1 +2368,1 @@\n-  const u1* runtime_invisible_parameter_annotations = NULL;\n+  const u1* runtime_invisible_parameter_annotations = nullptr;\n@@ -2370,1 +2370,1 @@\n-  const u1* runtime_visible_type_annotations = NULL;\n+  const u1* runtime_visible_type_annotations = nullptr;\n@@ -2372,1 +2372,1 @@\n-  const u1* runtime_invisible_type_annotations = NULL;\n+  const u1* runtime_invisible_type_annotations = nullptr;\n@@ -2377,1 +2377,1 @@\n-  const u1* annotation_default = NULL;\n+  const u1* annotation_default = nullptr;\n@@ -2403,1 +2403,1 @@\n-        return NULL;\n+        return nullptr;\n@@ -2422,1 +2422,1 @@\n-      assert(code_start != NULL, \"null code start\");\n+      assert(code_start != nullptr, \"null code start\");\n@@ -2536,1 +2536,1 @@\n-            return NULL;\n+            return nullptr;\n@@ -2557,1 +2557,1 @@\n-        return NULL;\n+        return nullptr;\n@@ -2570,1 +2570,1 @@\n-        return NULL;\n+        return nullptr;\n@@ -2579,1 +2579,1 @@\n-        return NULL;\n+        return nullptr;\n@@ -2592,1 +2592,1 @@\n-        return NULL;\n+        return nullptr;\n@@ -2601,1 +2601,1 @@\n-        return NULL;\n+        return nullptr;\n@@ -2609,1 +2609,1 @@\n-          return NULL;\n+          return nullptr;\n@@ -2615,1 +2615,1 @@\n-          return NULL;\n+          return nullptr;\n@@ -2619,1 +2619,1 @@\n-        if (runtime_visible_annotations != NULL) {\n+        if (runtime_visible_annotations != nullptr) {\n@@ -2623,1 +2623,1 @@\n-          return NULL;\n+          return nullptr;\n@@ -2627,1 +2627,1 @@\n-        assert(runtime_visible_annotations != NULL, \"null visible annotations\");\n+        assert(runtime_visible_annotations != nullptr, \"null visible annotations\");\n@@ -2641,1 +2641,1 @@\n-          return NULL;\n+          return nullptr;\n@@ -2647,1 +2647,1 @@\n-          assert(runtime_invisible_annotations != NULL, \"null invisible annotations\");\n+          assert(runtime_invisible_annotations != nullptr, \"null invisible annotations\");\n@@ -2651,1 +2651,1 @@\n-        if (runtime_visible_parameter_annotations != NULL) {\n+        if (runtime_visible_parameter_annotations != nullptr) {\n@@ -2655,1 +2655,1 @@\n-          return NULL;\n+          return nullptr;\n@@ -2659,1 +2659,1 @@\n-        assert(runtime_visible_parameter_annotations != NULL, \"null visible parameter annotations\");\n+        assert(runtime_visible_parameter_annotations != nullptr, \"null visible parameter annotations\");\n@@ -2666,1 +2666,1 @@\n-          return NULL;\n+          return nullptr;\n@@ -2672,1 +2672,1 @@\n-          assert(runtime_invisible_parameter_annotations != NULL,\n+          assert(runtime_invisible_parameter_annotations != nullptr,\n@@ -2677,1 +2677,1 @@\n-        if (annotation_default != NULL) {\n+        if (annotation_default != nullptr) {\n@@ -2681,1 +2681,1 @@\n-          return NULL;\n+          return nullptr;\n@@ -2685,1 +2685,1 @@\n-        assert(annotation_default != NULL, \"null annotation default\");\n+        assert(annotation_default != nullptr, \"null annotation default\");\n@@ -2688,1 +2688,1 @@\n-        if (runtime_visible_type_annotations != NULL) {\n+        if (runtime_visible_type_annotations != nullptr) {\n@@ -2692,1 +2692,1 @@\n-          return NULL;\n+          return nullptr;\n@@ -2696,1 +2696,1 @@\n-        assert(runtime_visible_type_annotations != NULL, \"null visible type annotations\");\n+        assert(runtime_visible_type_annotations != nullptr, \"null visible type annotations\");\n@@ -2704,1 +2704,1 @@\n-          return NULL;\n+          return nullptr;\n@@ -2711,1 +2711,1 @@\n-          assert(runtime_invisible_type_annotations != NULL, \"null invisible type annotations\");\n+          assert(runtime_invisible_type_annotations != nullptr, \"null invisible type annotations\");\n@@ -2724,1 +2724,1 @@\n-  if (linenumber_table != NULL) {\n+  if (linenumber_table != nullptr) {\n@@ -2775,1 +2775,1 @@\n-  if (stackmap_data != NULL) {\n+  if (stackmap_data != nullptr) {\n@@ -2786,1 +2786,1 @@\n-  if (linenumber_table != NULL) {\n+  if (linenumber_table != nullptr) {\n@@ -2884,4 +2884,4 @@\n-  assert(cfs != NULL, \"invariant\");\n-  assert(has_localvariable_table != NULL, \"invariant\");\n-  assert(has_final_method != NULL, \"invariant\");\n-  assert(declares_nonstatic_concrete_methods != NULL, \"invariant\");\n+  assert(cfs != nullptr, \"invariant\");\n+  assert(has_localvariable_table != nullptr, \"invariant\");\n+  assert(has_final_method != nullptr, \"invariant\");\n+  assert(declares_nonstatic_concrete_methods != nullptr, \"invariant\");\n@@ -2889,1 +2889,1 @@\n-  assert(NULL == _methods, \"invariant\");\n+  assert(nullptr == _methods, \"invariant\");\n@@ -2898,1 +2898,1 @@\n-                                                   NULL,\n+                                                   nullptr,\n@@ -2927,2 +2927,2 @@\n-      const Symbol* name = NULL;\n-      const Symbol* sig = NULL;\n+      const Symbol* name = nullptr;\n+      const Symbol* sig = nullptr;\n@@ -2968,1 +2968,1 @@\n-  intArray* method_ordering = NULL;\n+  intArray* method_ordering = nullptr;\n@@ -2987,1 +2987,1 @@\n-  assert(cfs != NULL, \"invariant\");\n+  assert(cfs != nullptr, \"invariant\");\n@@ -3001,1 +3001,1 @@\n-  assert(cfs != NULL, \"invariant\");\n+  assert(cfs != nullptr, \"invariant\");\n@@ -3015,1 +3015,1 @@\n-  assert(cfs != NULL, \"invariant\");\n+  assert(cfs != nullptr, \"invariant\");\n@@ -3018,1 +3018,1 @@\n-  assert(sde_buffer != NULL, \"null sde buffer\");\n+  assert(sde_buffer != nullptr, \"null sde buffer\");\n@@ -3128,1 +3128,1 @@\n-  if (inner_classes_attribute_start != NULL) {\n+  if (inner_classes_attribute_start != nullptr) {\n@@ -3235,1 +3235,1 @@\n-  if (nest_members_attribute_start != NULL) {\n+  if (nest_members_attribute_start != nullptr) {\n@@ -3267,1 +3267,1 @@\n-  if (permitted_subclasses_attribute_start != NULL) {\n+  if (permitted_subclasses_attribute_start != nullptr) {\n@@ -3315,1 +3315,1 @@\n-  if (record_attribute_start != NULL) {\n+  if (record_attribute_start != nullptr) {\n@@ -3323,1 +3323,1 @@\n-    MetadataFactory::new_array<RecordComponent*>(_loader_data, components_count, NULL, CHECK_0);\n+    MetadataFactory::new_array<RecordComponent*>(_loader_data, components_count, nullptr, CHECK_0);\n@@ -3346,1 +3346,1 @@\n-    const u1* runtime_visible_annotations = NULL;\n+    const u1* runtime_visible_annotations = nullptr;\n@@ -3348,1 +3348,1 @@\n-    const u1* runtime_invisible_annotations = NULL;\n+    const u1* runtime_invisible_annotations = nullptr;\n@@ -3351,1 +3351,1 @@\n-    const u1* runtime_visible_type_annotations = NULL;\n+    const u1* runtime_visible_type_annotations = nullptr;\n@@ -3353,1 +3353,1 @@\n-    const u1* runtime_invisible_type_annotations = NULL;\n+    const u1* runtime_invisible_type_annotations = nullptr;\n@@ -3386,1 +3386,1 @@\n-        if (runtime_visible_annotations != NULL) {\n+        if (runtime_visible_annotations != nullptr) {\n@@ -3394,1 +3394,1 @@\n-        assert(runtime_visible_annotations != NULL, \"null record component visible annotation\");\n+        assert(runtime_visible_annotations != nullptr, \"null record component visible annotation\");\n@@ -3408,1 +3408,1 @@\n-          assert(runtime_invisible_annotations != NULL, \"null record component invisible annotation\");\n+          assert(runtime_invisible_annotations != nullptr, \"null record component invisible annotation\");\n@@ -3413,1 +3413,1 @@\n-        if (runtime_visible_type_annotations != NULL) {\n+        if (runtime_visible_type_annotations != nullptr) {\n@@ -3421,1 +3421,1 @@\n-        assert(runtime_visible_type_annotations != NULL, \"null record component visible type annotation\");\n+        assert(runtime_visible_type_annotations != nullptr, \"null record component visible type annotation\");\n@@ -3435,1 +3435,1 @@\n-          assert(runtime_invisible_type_annotations != NULL, \"null record component invisible type annotation\");\n+          assert(runtime_invisible_type_annotations != nullptr, \"null record component invisible type annotation\");\n@@ -3474,1 +3474,1 @@\n-  assert(cfs != NULL, \"invariant\");\n+  assert(cfs != nullptr, \"invariant\");\n@@ -3488,2 +3488,2 @@\n-  assert(cfs != NULL, \"invariant\");\n-  assert(cp != NULL, \"invariant\");\n+  assert(cfs != nullptr, \"invariant\");\n+  assert(cp != nullptr, \"invariant\");\n@@ -3570,3 +3570,3 @@\n-  assert(cfs != NULL, \"invariant\");\n-  assert(cp != NULL, \"invariant\");\n-  assert(parsed_annotations != NULL, \"invariant\");\n+  assert(cfs != nullptr, \"invariant\");\n+  assert(cp != nullptr, \"invariant\");\n+  assert(parsed_annotations != nullptr, \"invariant\");\n@@ -3590,1 +3590,1 @@\n-  const u1* runtime_visible_annotations = NULL;\n+  const u1* runtime_visible_annotations = nullptr;\n@@ -3592,1 +3592,1 @@\n-  const u1* runtime_invisible_annotations = NULL;\n+  const u1* runtime_invisible_annotations = nullptr;\n@@ -3594,1 +3594,1 @@\n-  const u1* runtime_visible_type_annotations = NULL;\n+  const u1* runtime_visible_type_annotations = nullptr;\n@@ -3596,1 +3596,1 @@\n-  const u1* runtime_invisible_type_annotations = NULL;\n+  const u1* runtime_invisible_type_annotations = nullptr;\n@@ -3601,1 +3601,1 @@\n-  const u1* inner_classes_attribute_start = NULL;\n+  const u1* inner_classes_attribute_start = nullptr;\n@@ -3605,1 +3605,1 @@\n-  const u1* nest_members_attribute_start = NULL;\n+  const u1* nest_members_attribute_start = nullptr;\n@@ -3607,1 +3607,1 @@\n-  const u1* record_attribute_start = NULL;\n+  const u1* record_attribute_start = nullptr;\n@@ -3609,1 +3609,1 @@\n-  const u1* permitted_subclasses_attribute_start = NULL;\n+  const u1* permitted_subclasses_attribute_start = nullptr;\n@@ -3687,1 +3687,1 @@\n-        if (runtime_visible_annotations != NULL) {\n+        if (runtime_visible_annotations != nullptr) {\n@@ -3694,1 +3694,1 @@\n-        assert(runtime_visible_annotations != NULL, \"null visible annotations\");\n+        assert(runtime_visible_annotations != nullptr, \"null visible annotations\");\n@@ -3713,1 +3713,1 @@\n-          assert(runtime_invisible_annotations != NULL, \"null invisible annotations\");\n+          assert(runtime_invisible_annotations != nullptr, \"null invisible annotations\");\n@@ -3751,1 +3751,1 @@\n-        if (runtime_visible_type_annotations != NULL) {\n+        if (runtime_visible_type_annotations != nullptr) {\n@@ -3758,1 +3758,1 @@\n-        assert(runtime_visible_type_annotations != NULL, \"null visible type annotations\");\n+        assert(runtime_visible_type_annotations != nullptr, \"null visible type annotations\");\n@@ -3772,1 +3772,1 @@\n-          assert(runtime_invisible_type_annotations != NULL, \"null invisible type annotations\");\n+          assert(runtime_invisible_type_annotations != nullptr, \"null invisible type annotations\");\n@@ -3924,1 +3924,1 @@\n-  assert(k != NULL, \"invariant\");\n+  assert(k != nullptr, \"invariant\");\n@@ -3934,1 +3934,1 @@\n-  if (_sde_buffer != NULL) {\n+  if (_sde_buffer != nullptr) {\n@@ -3942,4 +3942,4 @@\n-    if (_class_annotations == NULL &&\n-        _class_type_annotations == NULL &&\n-        _fields_annotations == NULL &&\n-        _fields_type_annotations == NULL) {\n+    if (_class_annotations == nullptr &&\n+        _class_type_annotations == nullptr &&\n+        _fields_annotations == nullptr &&\n+        _fields_type_annotations == nullptr) {\n@@ -3962,4 +3962,4 @@\n-    _class_annotations       = NULL;\n-    _class_type_annotations  = NULL;\n-    _fields_annotations      = NULL;\n-    _fields_type_annotations = NULL;\n+    _class_annotations       = nullptr;\n+    _class_type_annotations  = nullptr;\n+    _fields_annotations      = nullptr;\n+    _fields_type_annotations = nullptr;\n@@ -3972,1 +3972,1 @@\n-  assert(this_klass != NULL, \"invariant\");\n+  assert(this_klass != nullptr, \"invariant\");\n@@ -4001,3 +4001,3 @@\n-  AnnotationArray* annotations = NULL;\n-  if (runtime_visible_annotations != NULL ||\n-      runtime_invisible_annotations != NULL) {\n+  AnnotationArray* annotations = nullptr;\n+  if (runtime_visible_annotations != nullptr ||\n+      runtime_invisible_annotations != nullptr) {\n@@ -4008,1 +4008,1 @@\n-    if (runtime_visible_annotations != NULL) {\n+    if (runtime_visible_annotations != nullptr) {\n@@ -4013,1 +4013,1 @@\n-    if (runtime_invisible_annotations != NULL) {\n+    if (runtime_invisible_annotations != nullptr) {\n@@ -4027,2 +4027,2 @@\n-  assert(cp != NULL, \"invariant\");\n-  const InstanceKlass* super_klass = NULL;\n+  assert(cp != nullptr, \"invariant\");\n+  const InstanceKlass* super_klass = nullptr;\n@@ -4062,1 +4062,1 @@\n-    _nonstatic_oop_maps = NULL;\n+    _nonstatic_oop_maps = nullptr;\n@@ -4175,1 +4175,1 @@\n-  assert(ik != NULL, \"invariant\");\n+  assert(ik != nullptr, \"invariant\");\n@@ -4183,1 +4183,1 @@\n-        (super != NULL && super->has_finalizer())) {\n+        (super != nullptr && super->has_finalizer())) {\n@@ -4193,1 +4193,1 @@\n-      (m != NULL) && !m->is_empty_method()) {\n+      (m != nullptr) && !m->is_empty_method()) {\n@@ -4213,1 +4213,1 @@\n-  if (super == NULL) {\n+  if (super == nullptr) {\n@@ -4227,1 +4227,1 @@\n-      if (constructor != NULL && constructor->is_vanilla_constructor()) {\n+      if (constructor != nullptr && constructor->is_vanilla_constructor()) {\n@@ -4240,1 +4240,1 @@\n-      || (ik->name() == vmSymbols::java_lang_Class() && ik->class_loader() == NULL)\n+      || (ik->name() == vmSymbols::java_lang_Class() && ik->class_loader() == nullptr)\n@@ -4265,2 +4265,2 @@\n-  assert(local_ifs != NULL, \"invariant\");\n-  assert(loader_data != NULL, \"invariant\");\n+  assert(local_ifs != nullptr, \"invariant\");\n+  assert(loader_data != nullptr, \"invariant\");\n@@ -4272,1 +4272,1 @@\n-  if (super != NULL) {\n+  if (super != nullptr) {\n@@ -4299,1 +4299,1 @@\n-    if (super != NULL) {\n+    if (super != nullptr) {\n@@ -4318,1 +4318,1 @@\n-      assert(e != NULL, \"just checking\");\n+      assert(e != nullptr, \"just checking\");\n@@ -4326,1 +4326,1 @@\n-  assert(this_klass != NULL, \"invariant\");\n+  assert(this_klass != nullptr, \"invariant\");\n@@ -4329,1 +4329,1 @@\n-  if (super != NULL) {\n+  if (super != nullptr) {\n@@ -4347,1 +4347,1 @@\n-      if (super_package != NULL &&\n+      if (super_package != nullptr &&\n@@ -4369,1 +4369,1 @@\n-      if (msg == NULL) {\n+      if (msg == nullptr) {\n@@ -4395,1 +4395,1 @@\n-  assert(this_klass != NULL, \"invariant\");\n+  assert(this_klass != nullptr, \"invariant\");\n@@ -4400,1 +4400,1 @@\n-    assert (k != NULL && k->is_interface(), \"invalid interface\");\n+    assert (k != nullptr && k->is_interface(), \"invalid interface\");\n@@ -4417,1 +4417,1 @@\n-      if (msg == NULL) {\n+      if (msg == nullptr) {\n@@ -4442,1 +4442,1 @@\n-  assert(this_klass != NULL, \"invariant\");\n+  assert(this_klass != nullptr, \"invariant\");\n@@ -4457,2 +4457,2 @@\n-      const Method* super_m = NULL;\n-      while (k != NULL) {\n+      const Method* super_m = nullptr;\n+      while (k != nullptr) {\n@@ -4463,1 +4463,1 @@\n-          if (super_m == NULL) {\n+          if (super_m == nullptr) {\n@@ -4501,1 +4501,1 @@\n-  assert(this_klass != NULL, \"invariant\");\n+  assert(this_klass != nullptr, \"invariant\");\n@@ -4804,1 +4804,1 @@\n-\/\/ Return NULL if no fieldname at all was found, or in the case of slash_ok\n+\/\/ Return null if no fieldname at all was found, or in the case of slash_ok\n@@ -4829,1 +4829,1 @@\n-          return NULL;  \/\/ Don't permit consecutive slashes\n+          return nullptr;  \/\/ Don't permit consecutive slashes\n@@ -4868,1 +4868,1 @@\n-        return NULL;\n+        return nullptr;\n@@ -4874,1 +4874,1 @@\n-    return (not_first_ch) ? old_p : NULL;\n+    return (not_first_ch) ? old_p : nullptr;\n@@ -4876,1 +4876,1 @@\n-  return (not_first_ch && !last_is_slash) ? p : NULL;\n+  return (not_first_ch && !last_is_slash) ? p : nullptr;\n@@ -4883,1 +4883,1 @@\n-\/\/ Return NULL if no legal signature is found.\n+\/\/ Return null if no legal signature is found.\n@@ -4891,1 +4891,1 @@\n-    case JVM_SIGNATURE_VOID: if (!void_ok) { return NULL; }\n+    case JVM_SIGNATURE_VOID: if (!void_ok) { return nullptr; }\n@@ -4916,1 +4916,1 @@\n-        if (c != NULL) {\n+        if (c != nullptr) {\n@@ -4923,1 +4923,1 @@\n-            return NULL;\n+            return nullptr;\n@@ -4928,1 +4928,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -4935,1 +4935,1 @@\n-        return NULL;\n+        return nullptr;\n@@ -4943,1 +4943,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -4946,1 +4946,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -4962,1 +4962,1 @@\n-      legal = (p != NULL) && ((p - bytes) == (int)length);\n+      legal = (p != nullptr) && ((p - bytes) == (int)length);\n@@ -4966,1 +4966,1 @@\n-        legal = (p != NULL) && ((p - bytes) == (int)length);\n+        legal = (p != nullptr) && ((p - bytes) == (int)length);\n@@ -4978,1 +4978,1 @@\n-    assert(_class_name != NULL, \"invariant\");\n+    assert(_class_name != nullptr, \"invariant\");\n@@ -5001,1 +5001,1 @@\n-        legal = (p != NULL) && ((p - bytes) == (int)length);\n+        legal = (p != nullptr) && ((p - bytes) == (int)length);\n@@ -5011,1 +5011,1 @@\n-    assert(_class_name != NULL, \"invariant\");\n+    assert(_class_name != nullptr, \"invariant\");\n@@ -5026,1 +5026,1 @@\n-  assert(name != NULL, \"method name is null\");\n+  assert(name != nullptr, \"method name is null\");\n@@ -5039,1 +5039,1 @@\n-      legal = (p != NULL) && ((p - bytes) == (int)length);\n+      legal = (p != nullptr) && ((p - bytes) == (int)length);\n@@ -5048,1 +5048,1 @@\n-    assert(_class_name != NULL, \"invariant\");\n+    assert(_class_name != nullptr, \"invariant\");\n@@ -5070,1 +5070,1 @@\n-  if (p == NULL || (p - bytes) != (int)length) {\n+  if (p == nullptr || (p - bytes) != (int)length) {\n@@ -5122,1 +5122,1 @@\n-    while ((length > 0) && (nextp != NULL)) {\n+    while ((length > 0) && (nextp != nullptr)) {\n@@ -5147,1 +5147,1 @@\n-  assert(_field_info != NULL, \"invariant\");\n+  assert(_field_info != nullptr, \"invariant\");\n@@ -5152,1 +5152,1 @@\n-  assert(_field_info != NULL, \"invariant\");\n+  assert(_field_info != nullptr, \"invariant\");\n@@ -5157,1 +5157,1 @@\n-  assert(_field_info != NULL, \"invariant\");\n+  assert(_field_info != nullptr, \"invariant\");\n@@ -5163,2 +5163,2 @@\n-  assert(ik != NULL, \"invariant\");\n-  assert(methods != NULL, \"invariant\");\n+  assert(ik != nullptr, \"invariant\");\n+  assert(methods != nullptr, \"invariant\");\n@@ -5259,1 +5259,1 @@\n-  if (_klass != NULL) {\n+  if (_klass != nullptr) {\n@@ -5281,1 +5281,1 @@\n-  assert(ik != NULL, \"invariant\");\n+  assert(ik != nullptr, \"invariant\");\n@@ -5288,1 +5288,1 @@\n-  \/\/ including classes in the bootstrap (NULL) class loader.\n+  \/\/ including classes in the bootstrap (null) class loader.\n@@ -5295,1 +5295,1 @@\n-  assert(_field_info != NULL, \"invariant\");\n+  assert(_field_info != nullptr, \"invariant\");\n@@ -5309,1 +5309,1 @@\n-  assert(_fac != NULL, \"invariant\");\n+  assert(_fac != nullptr, \"invariant\");\n@@ -5317,1 +5317,1 @@\n-  if (cl_inst_info.dynamic_nest_host() != NULL) {\n+  if (cl_inst_info.dynamic_nest_host() != nullptr) {\n@@ -5322,8 +5322,8 @@\n-  assert(NULL == _cp, \"invariant\");\n-  assert(NULL == _fields, \"invariant\");\n-  assert(NULL == _methods, \"invariant\");\n-  assert(NULL == _inner_classes, \"invariant\");\n-  assert(NULL == _nest_members, \"invariant\");\n-  assert(NULL == _combined_annotations, \"invariant\");\n-  assert(NULL == _record_components, \"invariant\");\n-  assert(NULL == _permitted_subclasses, \"invariant\");\n+  assert(nullptr == _cp, \"invariant\");\n+  assert(nullptr == _fields, \"invariant\");\n+  assert(nullptr == _methods, \"invariant\");\n+  assert(nullptr == _inner_classes, \"invariant\");\n+  assert(nullptr == _nest_members, \"invariant\");\n+  assert(nullptr == _combined_annotations, \"invariant\");\n+  assert(nullptr == _record_components, \"invariant\");\n+  assert(nullptr == _permitted_subclasses, \"invariant\");\n@@ -5373,1 +5373,1 @@\n-  ik->set_package(cld, NULL, CHECK);\n+  ik->set_package(cld, nullptr, CHECK);\n@@ -5376,1 +5376,1 @@\n-  assert(methods != NULL, \"invariant\");\n+  assert(methods != nullptr, \"invariant\");\n@@ -5391,1 +5391,1 @@\n-      (_super_klass != NULL && _super_klass->has_miranda_methods())\n+      (_super_klass != nullptr && _super_klass->has_miranda_methods())\n@@ -5401,2 +5401,2 @@\n-  _transitive_interfaces = NULL;\n-  _local_interfaces = NULL;\n+  _transitive_interfaces = nullptr;\n+  _local_interfaces = nullptr;\n@@ -5415,1 +5415,1 @@\n-      ( _super_klass != NULL && _super_klass->has_contended_annotations())) {\n+      ( _super_klass != nullptr && _super_klass->has_contended_annotations())) {\n@@ -5438,1 +5438,1 @@\n-  assert(module_entry != NULL, \"module_entry should always be set\");\n+  assert(module_entry != nullptr, \"module_entry should always be set\");\n@@ -5452,1 +5452,1 @@\n-  assert(_all_mirandas != NULL, \"invariant\");\n+  assert(_all_mirandas != nullptr, \"invariant\");\n@@ -5488,1 +5488,1 @@\n-      if (ik->java_super() != NULL) {\n+      if (ik->java_super() != nullptr) {\n@@ -5495,1 +5495,1 @@\n-      if (local_interfaces != NULL) {\n+      if (local_interfaces != nullptr) {\n@@ -5511,1 +5511,1 @@\n-  set_klass_to_deallocate(NULL);\n+  set_klass_to_deallocate(nullptr);\n@@ -5548,1 +5548,1 @@\n-  _class_name(NULL),\n+  _class_name(nullptr),\n@@ -5554,5 +5554,5 @@\n-  _cp(NULL),\n-  _fields(NULL),\n-  _methods(NULL),\n-  _inner_classes(NULL),\n-  _nest_members(NULL),\n+  _cp(nullptr),\n+  _fields(nullptr),\n+  _methods(nullptr),\n+  _inner_classes(nullptr),\n+  _nest_members(nullptr),\n@@ -5560,16 +5560,16 @@\n-  _permitted_subclasses(NULL),\n-  _record_components(NULL),\n-  _local_interfaces(NULL),\n-  _transitive_interfaces(NULL),\n-  _combined_annotations(NULL),\n-  _class_annotations(NULL),\n-  _class_type_annotations(NULL),\n-  _fields_annotations(NULL),\n-  _fields_type_annotations(NULL),\n-  _klass(NULL),\n-  _klass_to_deallocate(NULL),\n-  _parsed_annotations(NULL),\n-  _fac(NULL),\n-  _field_info(NULL),\n-  _method_ordering(NULL),\n-  _all_mirandas(NULL),\n+  _permitted_subclasses(nullptr),\n+  _record_components(nullptr),\n+  _local_interfaces(nullptr),\n+  _transitive_interfaces(nullptr),\n+  _combined_annotations(nullptr),\n+  _class_annotations(nullptr),\n+  _class_type_annotations(nullptr),\n+  _fields_annotations(nullptr),\n+  _fields_type_annotations(nullptr),\n+  _klass(nullptr),\n+  _klass_to_deallocate(nullptr),\n+  _parsed_annotations(nullptr),\n+  _fac(nullptr),\n+  _field_info(nullptr),\n+  _method_ordering(nullptr),\n+  _all_mirandas(nullptr),\n@@ -5585,1 +5585,1 @@\n-  _sde_buffer(NULL),\n+  _sde_buffer(nullptr),\n@@ -5606,1 +5606,1 @@\n-  _class_name = name != NULL ? name : vmSymbols::unknown_class_name();\n+  _class_name = name != nullptr ? name : vmSymbols::unknown_class_name();\n@@ -5609,3 +5609,3 @@\n-  assert(_loader_data != NULL, \"invariant\");\n-  assert(stream != NULL, \"invariant\");\n-  assert(_stream != NULL, \"invariant\");\n+  assert(_loader_data != nullptr, \"invariant\");\n+  assert(stream != nullptr, \"invariant\");\n+  assert(_stream != nullptr, \"invariant\");\n@@ -5613,1 +5613,1 @@\n-  assert(_class_name != NULL, \"invariant\");\n+  assert(_class_name != nullptr, \"invariant\");\n@@ -5644,10 +5644,10 @@\n-  _cp = NULL;\n-  _fields = NULL;\n-  _methods = NULL;\n-  _inner_classes = NULL;\n-  _nest_members = NULL;\n-  _permitted_subclasses = NULL;\n-  _combined_annotations = NULL;\n-  _class_annotations = _class_type_annotations = NULL;\n-  _fields_annotations = _fields_type_annotations = NULL;\n-  _record_components = NULL;\n+  _cp = nullptr;\n+  _fields = nullptr;\n+  _methods = nullptr;\n+  _inner_classes = nullptr;\n+  _nest_members = nullptr;\n+  _permitted_subclasses = nullptr;\n+  _combined_annotations = nullptr;\n+  _class_annotations = _class_type_annotations = nullptr;\n+  _fields_annotations = _fields_type_annotations = nullptr;\n+  _record_components = nullptr;\n@@ -5660,1 +5660,1 @@\n-  if (_cp != NULL) {\n+  if (_cp != nullptr) {\n@@ -5663,1 +5663,1 @@\n-  if (_fields != NULL) {\n+  if (_fields != nullptr) {\n@@ -5667,1 +5667,1 @@\n-  if (_methods != NULL) {\n+  if (_methods != nullptr) {\n@@ -5673,1 +5673,1 @@\n-  if (_inner_classes != NULL && _inner_classes != Universe::the_empty_short_array()) {\n+  if (_inner_classes != nullptr && _inner_classes != Universe::the_empty_short_array()) {\n@@ -5677,1 +5677,1 @@\n-  if (_nest_members != NULL && _nest_members != Universe::the_empty_short_array()) {\n+  if (_nest_members != nullptr && _nest_members != Universe::the_empty_short_array()) {\n@@ -5681,1 +5681,1 @@\n-  if (_record_components != NULL) {\n+  if (_record_components != nullptr) {\n@@ -5685,1 +5685,1 @@\n-  if (_permitted_subclasses != NULL && _permitted_subclasses != Universe::the_empty_short_array()) {\n+  if (_permitted_subclasses != nullptr && _permitted_subclasses != Universe::the_empty_short_array()) {\n@@ -5693,1 +5693,1 @@\n-  if (_combined_annotations != NULL) {\n+  if (_combined_annotations != nullptr) {\n@@ -5700,1 +5700,1 @@\n-    \/\/ If the _combined_annotations pointer is non-NULL,\n+    \/\/ If the _combined_annotations pointer is non-null,\n@@ -5702,4 +5702,4 @@\n-    assert(_class_annotations       == NULL, \"Should have been cleared\");\n-    assert(_class_type_annotations  == NULL, \"Should have been cleared\");\n-    assert(_fields_annotations      == NULL, \"Should have been cleared\");\n-    assert(_fields_type_annotations == NULL, \"Should have been cleared\");\n+    assert(_class_annotations       == nullptr, \"Should have been cleared\");\n+    assert(_class_type_annotations  == nullptr, \"Should have been cleared\");\n+    assert(_fields_annotations      == nullptr, \"Should have been cleared\");\n+    assert(_fields_type_annotations == nullptr, \"Should have been cleared\");\n@@ -5716,2 +5716,2 @@\n-  _transitive_interfaces = NULL;\n-  _local_interfaces = NULL;\n+  _transitive_interfaces = nullptr;\n+  _local_interfaces = nullptr;\n@@ -5722,1 +5722,1 @@\n-  if (_klass_to_deallocate != NULL) {\n+  if (_klass_to_deallocate != nullptr) {\n@@ -5730,2 +5730,2 @@\n-  assert(stream != NULL, \"invariant\");\n-  assert(_class_name != NULL, \"invariant\");\n+  assert(stream != nullptr, \"invariant\");\n+  assert(_class_name != nullptr, \"invariant\");\n@@ -5808,1 +5808,1 @@\n-  assert(class_name_in_cp != NULL, \"class_name can't be null\");\n+  assert(class_name_in_cp != nullptr, \"class_name can't be null\");\n@@ -5829,1 +5829,1 @@\n-    assert(_class_name != NULL, \"Unexpected null _class_name\");\n+    assert(_class_name != nullptr, \"Unexpected null _class_name\");\n@@ -5867,1 +5867,1 @@\n-      if (stream->source() != NULL) {\n+      if (stream->source() != nullptr) {\n@@ -5889,1 +5889,1 @@\n-  assert(_local_interfaces != NULL, \"invariant\");\n+  assert(_local_interfaces != nullptr, \"invariant\");\n@@ -5901,1 +5901,1 @@\n-  assert(_fields != NULL, \"invariant\");\n+  assert(_fields != nullptr, \"invariant\");\n@@ -5911,1 +5911,1 @@\n-  assert(_methods != NULL, \"invariant\");\n+  assert(_methods != nullptr, \"invariant\");\n@@ -5921,1 +5921,1 @@\n-  assert(_inner_classes != NULL, \"invariant\");\n+  assert(_inner_classes != nullptr, \"invariant\");\n@@ -5961,1 +5961,1 @@\n-  assert(_class_name != NULL, \"Unexpected null _class_name\");\n+  assert(_class_name != nullptr, \"Unexpected null _class_name\");\n@@ -5978,1 +5978,1 @@\n-  assert(stream != NULL, \"invariant\");\n+  assert(stream != nullptr, \"invariant\");\n@@ -5980,2 +5980,2 @@\n-  assert(cp != NULL, \"invariant\");\n-  assert(_loader_data != NULL, \"invariant\");\n+  assert(cp != nullptr, \"invariant\");\n+  assert(_loader_data != nullptr, \"invariant\");\n@@ -5989,1 +5989,1 @@\n-  if (_super_class_index > 0 && NULL == _super_klass) {\n+  if (_super_class_index > 0 && nullptr == _super_klass) {\n@@ -6012,1 +6012,1 @@\n-  if (_super_klass != NULL) {\n+  if (_super_klass != nullptr) {\n@@ -6030,1 +6030,1 @@\n-  assert(_transitive_interfaces != NULL, \"invariant\");\n+  assert(_transitive_interfaces != nullptr, \"invariant\");\n@@ -6053,2 +6053,2 @@\n-  assert(_fac != NULL, \"invariant\");\n-  assert(_parsed_annotations != NULL, \"invariant\");\n+  assert(_fac != nullptr, \"invariant\");\n+  assert(_parsed_annotations != nullptr, \"invariant\");\n@@ -6065,2 +6065,2 @@\n-  if (klass != NULL) {\n-    assert(NULL == _klass, \"leaking?\");\n+  if (klass != nullptr) {\n+    assert(nullptr == _klass, \"leaking?\");\n@@ -6076,2 +6076,2 @@\n-  if (klass != NULL) {\n-    assert(NULL == _klass_to_deallocate, \"leaking?\");\n+  if (klass != nullptr) {\n+    assert(nullptr == _klass_to_deallocate, \"leaking?\");\n@@ -6087,1 +6087,1 @@\n-  assert(_stream != NULL, \"invariant\");\n+  assert(_stream != nullptr, \"invariant\");\n@@ -6093,1 +6093,1 @@\n-  return _super_klass == NULL ? REF_NONE : _super_klass->reference_type();\n+  return _super_klass == nullptr ? REF_NONE : _super_klass->reference_type();\n@@ -6106,1 +6106,1 @@\n-  if (_super_klass == NULL) {\n+  if (_super_klass == nullptr) {\n@@ -6125,1 +6125,1 @@\n-  if (class_name != NULL) {\n+  if (class_name != nullptr) {\n@@ -6128,1 +6128,1 @@\n-    return strchr(name, JVM_SIGNATURE_DOT) == NULL;\n+    return strchr(name, JVM_SIGNATURE_DOT) == nullptr;\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":357,"deletions":357,"binary":false,"changes":714,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -121,1 +121,1 @@\n-  \/\/ in which case these pointers have been set to NULL.\n+  \/\/ in which case these pointers have been set to null.\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,1 +48,1 @@\n-    assert(buffer != NULL, \"caller should throw NPE\");\n+    assert(buffer != nullptr, \"caller should throw NPE\");\n@@ -59,2 +59,2 @@\n-  char* source_copy = NULL;\n-  if (src != NULL) {\n+  char* source_copy = nullptr;\n+  if (src != nullptr) {\n","filename":"src\/hotspot\/share\/classfile\/classFileStream.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,1 +41,1 @@\n-    _dynamic_nest_host = NULL;\n+    _dynamic_nest_host = nullptr;\n@@ -65,1 +65,1 @@\n-    _class_hidden_info._dynamic_nest_host = NULL;\n+    _class_hidden_info._dynamic_nest_host = nullptr;\n","filename":"src\/hotspot\/share\/classfile\/classLoadInfo.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -85,1 +85,1 @@\n-static canonicalize_fn_t CanonicalizeEntry  = NULL;\n+static canonicalize_fn_t CanonicalizeEntry  = nullptr;\n@@ -95,5 +95,5 @@\n-static ZipOpen_t         ZipOpen            = NULL;\n-static ZipClose_t        ZipClose           = NULL;\n-static FindEntry_t       FindEntry          = NULL;\n-static ReadEntry_t       ReadEntry          = NULL;\n-static Crc32_t           Crc32              = NULL;\n+static ZipOpen_t         ZipOpen            = nullptr;\n+static ZipClose_t        ZipClose           = nullptr;\n+static FindEntry_t       FindEntry          = nullptr;\n+static ReadEntry_t       ReadEntry          = nullptr;\n+static Crc32_t           Crc32              = nullptr;\n@@ -101,1 +101,1 @@\n-void*  ClassLoader::_zip_handle             = NULL;\n+void*  ClassLoader::_zip_handle             = nullptr;\n@@ -105,4 +105,4 @@\n-static JImageOpen_t                    JImageOpen             = NULL;\n-static JImageClose_t                   JImageClose            = NULL;\n-static JImageFindResource_t            JImageFindResource     = NULL;\n-static JImageGetResource_t             JImageGetResource      = NULL;\n+static JImageOpen_t                    JImageOpen             = nullptr;\n+static JImageClose_t                   JImageClose            = nullptr;\n+static JImageFindResource_t            JImageFindResource     = nullptr;\n+static JImageGetResource_t             JImageGetResource      = nullptr;\n@@ -111,1 +111,1 @@\n-static JImageFile*                     JImage_file            = NULL;\n+static JImageFile*                     JImage_file            = nullptr;\n@@ -115,29 +115,29 @@\n-PerfCounter*    ClassLoader::_perf_accumulated_time = NULL;\n-PerfCounter*    ClassLoader::_perf_classes_inited = NULL;\n-PerfCounter*    ClassLoader::_perf_class_init_time = NULL;\n-PerfCounter*    ClassLoader::_perf_class_init_selftime = NULL;\n-PerfCounter*    ClassLoader::_perf_classes_verified = NULL;\n-PerfCounter*    ClassLoader::_perf_class_verify_time = NULL;\n-PerfCounter*    ClassLoader::_perf_class_verify_selftime = NULL;\n-PerfCounter*    ClassLoader::_perf_classes_linked = NULL;\n-PerfCounter*    ClassLoader::_perf_class_link_time = NULL;\n-PerfCounter*    ClassLoader::_perf_class_link_selftime = NULL;\n-PerfCounter*    ClassLoader::_perf_sys_class_lookup_time = NULL;\n-PerfCounter*    ClassLoader::_perf_shared_classload_time = NULL;\n-PerfCounter*    ClassLoader::_perf_sys_classload_time = NULL;\n-PerfCounter*    ClassLoader::_perf_app_classload_time = NULL;\n-PerfCounter*    ClassLoader::_perf_app_classload_selftime = NULL;\n-PerfCounter*    ClassLoader::_perf_app_classload_count = NULL;\n-PerfCounter*    ClassLoader::_perf_define_appclasses = NULL;\n-PerfCounter*    ClassLoader::_perf_define_appclass_time = NULL;\n-PerfCounter*    ClassLoader::_perf_define_appclass_selftime = NULL;\n-PerfCounter*    ClassLoader::_perf_app_classfile_bytes_read = NULL;\n-PerfCounter*    ClassLoader::_perf_sys_classfile_bytes_read = NULL;\n-PerfCounter*    ClassLoader::_unsafe_defineClassCallCounter = NULL;\n-\n-GrowableArray<ModuleClassPathList*>* ClassLoader::_patch_mod_entries = NULL;\n-GrowableArray<ModuleClassPathList*>* ClassLoader::_exploded_entries = NULL;\n-ClassPathEntry* ClassLoader::_jrt_entry = NULL;\n-\n-ClassPathEntry* volatile ClassLoader::_first_append_entry_list = NULL;\n-ClassPathEntry* volatile ClassLoader::_last_append_entry  = NULL;\n+PerfCounter*    ClassLoader::_perf_accumulated_time = nullptr;\n+PerfCounter*    ClassLoader::_perf_classes_inited = nullptr;\n+PerfCounter*    ClassLoader::_perf_class_init_time = nullptr;\n+PerfCounter*    ClassLoader::_perf_class_init_selftime = nullptr;\n+PerfCounter*    ClassLoader::_perf_classes_verified = nullptr;\n+PerfCounter*    ClassLoader::_perf_class_verify_time = nullptr;\n+PerfCounter*    ClassLoader::_perf_class_verify_selftime = nullptr;\n+PerfCounter*    ClassLoader::_perf_classes_linked = nullptr;\n+PerfCounter*    ClassLoader::_perf_class_link_time = nullptr;\n+PerfCounter*    ClassLoader::_perf_class_link_selftime = nullptr;\n+PerfCounter*    ClassLoader::_perf_sys_class_lookup_time = nullptr;\n+PerfCounter*    ClassLoader::_perf_shared_classload_time = nullptr;\n+PerfCounter*    ClassLoader::_perf_sys_classload_time = nullptr;\n+PerfCounter*    ClassLoader::_perf_app_classload_time = nullptr;\n+PerfCounter*    ClassLoader::_perf_app_classload_selftime = nullptr;\n+PerfCounter*    ClassLoader::_perf_app_classload_count = nullptr;\n+PerfCounter*    ClassLoader::_perf_define_appclasses = nullptr;\n+PerfCounter*    ClassLoader::_perf_define_appclass_time = nullptr;\n+PerfCounter*    ClassLoader::_perf_define_appclass_selftime = nullptr;\n+PerfCounter*    ClassLoader::_perf_app_classfile_bytes_read = nullptr;\n+PerfCounter*    ClassLoader::_perf_sys_classfile_bytes_read = nullptr;\n+PerfCounter*    ClassLoader::_unsafe_defineClassCallCounter = nullptr;\n+\n+GrowableArray<ModuleClassPathList*>* ClassLoader::_patch_mod_entries = nullptr;\n+GrowableArray<ModuleClassPathList*>* ClassLoader::_exploded_entries = nullptr;\n+ClassPathEntry* ClassLoader::_jrt_entry = nullptr;\n+\n+ClassPathEntry* volatile ClassLoader::_first_append_entry_list = nullptr;\n+ClassPathEntry* volatile ClassLoader::_last_append_entry  = nullptr;\n@@ -145,4 +145,4 @@\n-ClassPathEntry* ClassLoader::_app_classpath_entries = NULL;\n-ClassPathEntry* ClassLoader::_last_app_classpath_entry = NULL;\n-ClassPathEntry* ClassLoader::_module_path_entries = NULL;\n-ClassPathEntry* ClassLoader::_last_module_path_entry = NULL;\n+ClassPathEntry* ClassLoader::_app_classpath_entries = nullptr;\n+ClassPathEntry* ClassLoader::_last_app_classpath_entry = nullptr;\n+ClassPathEntry* ClassLoader::_module_path_entries = nullptr;\n+ClassPathEntry* ClassLoader::_last_module_path_entry = nullptr;\n@@ -181,2 +181,2 @@\n-  if (name == NULL) {\n-    if (bad_class_name != NULL) {\n+  if (name == nullptr) {\n+    if (bad_class_name != nullptr) {\n@@ -185,1 +185,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -192,2 +192,2 @@\n-  if (end == NULL) {\n-    return NULL;\n+  if (end == nullptr) {\n+    return nullptr;\n@@ -206,1 +206,1 @@\n-      if (bad_class_name != NULL) {\n+      if (bad_class_name != nullptr) {\n@@ -209,1 +209,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -216,1 +216,1 @@\n-    if (bad_class_name != NULL) {\n+    if (bad_class_name != nullptr) {\n@@ -219,1 +219,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -227,2 +227,2 @@\n-  if (pkg_name == NULL) {\n-    return NULL;\n+  if (pkg_name == nullptr) {\n+    return nullptr;\n@@ -246,1 +246,1 @@\n-  assert((_dir != NULL) && (name != NULL), \"sanity\");\n+  assert((_dir != nullptr) && (name != nullptr), \"sanity\");\n@@ -281,1 +281,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -302,1 +302,1 @@\n-  if (entry == NULL) return NULL;\n+  if (entry == nullptr) return nullptr;\n@@ -316,1 +316,1 @@\n-      return NULL; \/\/ 32-bit integer overflow will occur.\n+      return nullptr; \/\/ 32-bit integer overflow will occur.\n@@ -321,1 +321,1 @@\n-  if (!(*ReadEntry)(_zip, entry, buffer, filename)) return NULL;\n+  if (!(*ReadEntry)(_zip, entry, buffer, filename)) return nullptr;\n@@ -333,2 +333,2 @@\n-  if (buffer == NULL) {\n-    return NULL;\n+  if (buffer == nullptr) {\n+    return nullptr;\n@@ -346,1 +346,1 @@\n-DEBUG_ONLY(ClassPathImageEntry* ClassPathImageEntry::_singleton = NULL;)\n+DEBUG_ONLY(ClassPathImageEntry* ClassPathImageEntry::_singleton = nullptr;)\n@@ -354,1 +354,1 @@\n-  assert(jimage() != NULL, \"should have been opened by ClassLoader::lookup_vm_options \"\n+  assert(jimage() != nullptr, \"should have been opened by ClassLoader::lookup_vm_options \"\n@@ -360,1 +360,1 @@\n-  if (jimage() != NULL) {\n+  if (jimage() != nullptr) {\n@@ -362,1 +362,1 @@\n-    JImage_file = NULL;\n+    JImage_file = nullptr;\n@@ -368,3 +368,3 @@\n-  guarantee(jimage != NULL, \"jimage file is null\");\n-  guarantee(name != NULL, \"jimage file name is null\");\n-  assert(_singleton == NULL, \"VM supports only one jimage\");\n+  guarantee(jimage != nullptr, \"jimage file is null\");\n+  guarantee(name != nullptr, \"jimage file name is null\");\n+  assert(_singleton == nullptr, \"VM supports only one jimage\");\n@@ -395,1 +395,1 @@\n-    if (pkg_name != NULL) {\n+    if (pkg_name != nullptr) {\n@@ -400,1 +400,1 @@\n-        if (package_entry != NULL) {\n+        if (package_entry != nullptr) {\n@@ -404,1 +404,1 @@\n-          assert(module != NULL, \"Boot classLoader package missing module\");\n+          assert(module != nullptr, \"Boot classLoader package missing module\");\n@@ -407,1 +407,1 @@\n-          if (module_name != NULL) {\n+          if (module_name != nullptr) {\n@@ -429,1 +429,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -455,2 +455,2 @@\n-  _module_first_entry = NULL;\n-  _module_last_entry = NULL;\n+  _module_first_entry = nullptr;\n+  _module_last_entry = nullptr;\n@@ -462,1 +462,1 @@\n-  while (e != NULL) {\n+  while (e != nullptr) {\n@@ -470,2 +470,2 @@\n-  if (new_entry != NULL) {\n-    if (_module_last_entry == NULL) {\n+  if (new_entry != nullptr) {\n+    if (_module_last_entry == nullptr) {\n@@ -505,1 +505,1 @@\n-  assert(bootcp != NULL, \"Boot class path must not be NULL\");\n+  assert(bootcp != nullptr, \"Boot class path must not be nullptr\");\n@@ -530,1 +530,1 @@\n-  assert(entry != NULL, \"ClassPathEntry should not be NULL\");\n+  assert(entry != nullptr, \"ClassPathEntry should not be nullptr\");\n@@ -534,2 +534,2 @@\n-  if (_module_path_entries == NULL) {\n-    assert(_last_module_path_entry == NULL, \"Sanity\");\n+  if (_module_path_entries == nullptr) {\n+    assert(_last_module_path_entry == nullptr, \"Sanity\");\n@@ -553,1 +553,1 @@\n-  ClassPathEntry* new_entry = NULL;\n+  ClassPathEntry* new_entry = nullptr;\n@@ -556,1 +556,1 @@\n-  if (new_entry != NULL) {\n+  if (new_entry != nullptr) {\n@@ -583,1 +583,1 @@\n-    assert(module_sym != NULL, \"Failed to obtain Symbol for module name\");\n+    assert(module_sym != nullptr, \"Failed to obtain Symbol for module name\");\n@@ -597,1 +597,1 @@\n-        if (new_entry != NULL) {\n+        if (new_entry != nullptr) {\n@@ -605,1 +605,1 @@\n-    if (module_cpl->module_first_entry() != NULL) {\n+    if (module_cpl->module_first_entry() != nullptr) {\n@@ -614,1 +614,1 @@\n-  if (_patch_mod_entries != NULL && _patch_mod_entries->is_nonempty()) {\n+  if (_patch_mod_entries != nullptr && _patch_mod_entries->is_nonempty()) {\n@@ -635,1 +635,1 @@\n-      vm_exit_during_initialization(\"CDS is not supported in exploded JDK build\", NULL);\n+      vm_exit_during_initialization(\"CDS is not supported in exploded JDK build\", nullptr);\n@@ -652,1 +652,1 @@\n-        if (JImage_file != NULL) {\n+        if (JImage_file != nullptr) {\n@@ -655,1 +655,1 @@\n-          assert(canonical_path != NULL, \"canonical_path issue\");\n+          assert(canonical_path != nullptr, \"canonical_path issue\");\n@@ -658,2 +658,2 @@\n-          assert(_jrt_entry != NULL && _jrt_entry->is_modules_image(), \"No java runtime image present\");\n-          assert(_jrt_entry->jimage() != NULL, \"No java runtime image\");\n+          assert(_jrt_entry != nullptr && _jrt_entry->is_modules_image(), \"No java runtime image present\");\n+          assert(_jrt_entry->jimage() != nullptr, \"No java runtime image\");\n@@ -690,1 +690,1 @@\n-  assert(_exploded_entries != NULL, \"_exploded_entries was not initialized\");\n+  assert(_exploded_entries != nullptr, \"_exploded_entries was not initialized\");\n@@ -706,1 +706,1 @@\n-    if (new_entry != NULL) {\n+    if (new_entry != nullptr) {\n@@ -730,1 +730,1 @@\n-  ClassPathEntry* new_entry = NULL;\n+  ClassPathEntry* new_entry = nullptr;\n@@ -736,2 +736,2 @@\n-    if (canonical_path == NULL) {\n-      return NULL;\n+    if (canonical_path == nullptr) {\n+      return nullptr;\n@@ -739,1 +739,1 @@\n-    char* error_msg = NULL;\n+    char* error_msg = nullptr;\n@@ -741,1 +741,1 @@\n-    if (zip != NULL && error_msg == NULL) {\n+    if (zip != nullptr && error_msg == nullptr) {\n@@ -747,1 +747,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -760,1 +760,1 @@\n-\/\/ Create a class path zip entry for a given path (return NULL if not found\n+\/\/ Create a class path zip entry for a given path (return null if not found\n@@ -770,2 +770,2 @@\n-      if (canonical_path != NULL) {\n-        char* error_msg = NULL;\n+      if (canonical_path != nullptr) {\n+        char* error_msg = nullptr;\n@@ -773,1 +773,1 @@\n-        if (zip != NULL && error_msg == NULL) {\n+        if (zip != nullptr && error_msg == nullptr) {\n@@ -780,1 +780,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -785,1 +785,1 @@\n-  if (new_entry != NULL) {\n+  if (new_entry != nullptr) {\n@@ -787,1 +787,1 @@\n-    if (_last_append_entry == NULL) {\n+    if (_last_append_entry == nullptr) {\n@@ -789,1 +789,1 @@\n-      assert(first_append_entry() == NULL, \"boot loader's append class path entry list not empty\");\n+      assert(first_append_entry() == nullptr, \"boot loader's append class path entry list not empty\");\n@@ -809,1 +809,1 @@\n-  assert(entry != NULL, \"ClassPathEntry should not be NULL\");\n+  assert(entry != nullptr, \"ClassPathEntry should not be nullptr\");\n@@ -812,1 +812,1 @@\n-    while (e != NULL) {\n+    while (e != nullptr) {\n@@ -822,2 +822,2 @@\n-  if (_app_classpath_entries == NULL) {\n-    assert(_last_app_classpath_entry == NULL, \"Sanity\");\n+  if (_app_classpath_entries == nullptr) {\n+    assert(_last_app_classpath_entry == nullptr, \"Sanity\");\n@@ -845,1 +845,1 @@\n-    ClassPathEntry* new_entry = NULL;\n+    ClassPathEntry* new_entry = nullptr;\n@@ -847,1 +847,1 @@\n-    if (new_entry == NULL) {\n+    if (new_entry == nullptr) {\n@@ -872,1 +872,1 @@\n-    while (e != NULL) {\n+    while (e != nullptr) {\n@@ -875,1 +875,1 @@\n-      if (e != NULL) {\n+      if (e != nullptr) {\n@@ -888,1 +888,1 @@\n-  if (_patch_mod_entries != NULL) {\n+  if (_patch_mod_entries != nullptr) {\n@@ -898,1 +898,1 @@\n-    if (_exploded_entries != NULL) {\n+    if (_exploded_entries != nullptr) {\n@@ -905,1 +905,1 @@\n-  while (e != NULL) {\n+  while (e != nullptr) {\n@@ -914,1 +914,1 @@\n-  if (func == NULL) {\n+  if (func == nullptr) {\n@@ -923,1 +923,1 @@\n-  assert(CanonicalizeEntry == NULL, \"should not load java library twice\");\n+  assert(CanonicalizeEntry == nullptr, \"should not load java library twice\");\n@@ -925,2 +925,2 @@\n-  if (javalib_handle == NULL) {\n-    vm_exit_during_initialization(\"Unable to load java library\", NULL);\n+  if (javalib_handle == nullptr) {\n+    vm_exit_during_initialization(\"Unable to load java library\", nullptr);\n@@ -929,1 +929,1 @@\n-  CanonicalizeEntry = CAST_TO_FN_PTR(canonicalize_fn_t, dll_lookup(javalib_handle, \"JDK_Canonicalize\", NULL));\n+  CanonicalizeEntry = CAST_TO_FN_PTR(canonicalize_fn_t, dll_lookup(javalib_handle, \"JDK_Canonicalize\", nullptr));\n@@ -941,1 +941,1 @@\n-  assert(ZipOpen == NULL, \"should not load zip library twice\");\n+  assert(ZipOpen == nullptr, \"should not load zip library twice\");\n@@ -947,1 +947,1 @@\n-  if (_zip_handle == NULL) {\n+  if (_zip_handle == nullptr) {\n@@ -959,1 +959,1 @@\n-  assert(JImageOpen == NULL, \"should not load jimage library twice\");\n+  assert(JImageOpen == nullptr, \"should not load jimage library twice\");\n@@ -962,1 +962,1 @@\n-  void* handle = NULL;\n+  void* handle = nullptr;\n@@ -966,1 +966,1 @@\n-  if (handle == NULL) {\n+  if (handle == nullptr) {\n@@ -983,1 +983,1 @@\n-  if (name != NULL) {\n+  if (name != nullptr) {\n@@ -989,1 +989,1 @@\n-    \/\/ Return NULL if package does not exist or if no classes in that package\n+    \/\/ Return null if package does not exist or if no classes in that package\n@@ -991,1 +991,1 @@\n-    if (package != NULL && package->has_loaded_class()) {\n+    if (package != nullptr && package->has_loaded_class()) {\n@@ -993,1 +993,1 @@\n-      if (module->location() != NULL) {\n+      if (module->location() != nullptr) {\n@@ -1005,1 +1005,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1030,1 +1030,1 @@\n-  assert(class_name != NULL, \"invariant\");\n+  assert(class_name != nullptr, \"invariant\");\n@@ -1038,1 +1038,1 @@\n-                                             class_suffix_len); \/\/ includes term NULL\n+                                             class_suffix_len); \/\/ includes term null\n@@ -1061,1 +1061,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1070,1 +1070,1 @@\n-  ClassFileStream* stream = NULL;\n+  ClassFileStream* stream = nullptr;\n@@ -1076,1 +1076,1 @@\n-  ModuleEntry* mod_entry = (pkg_entry != NULL) ? pkg_entry->module() : NULL;\n+  ModuleEntry* mod_entry = (pkg_entry != nullptr) ? pkg_entry->module() : nullptr;\n@@ -1085,1 +1085,1 @@\n-      mod_entry == NULL) {\n+      mod_entry == nullptr) {\n@@ -1090,2 +1090,2 @@\n-  ClassPathEntry* e = NULL;\n-  if (mod_entry != NULL && mod_entry->is_named()) {\n+  ClassPathEntry* e = nullptr;\n+  if (mod_entry != nullptr && mod_entry->is_named()) {\n@@ -1104,1 +1104,1 @@\n-  while (e != NULL) {\n+  while (e != nullptr) {\n@@ -1108,1 +1108,1 @@\n-    if (NULL != stream) {\n+    if (nullptr != stream) {\n@@ -1116,1 +1116,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1121,1 +1121,1 @@\n-  assert(name != NULL, \"invariant\");\n+  assert(name != nullptr, \"invariant\");\n@@ -1132,1 +1132,1 @@\n-  assert(file_name != NULL, \"invariant\");\n+  assert(file_name != nullptr, \"invariant\");\n@@ -1135,1 +1135,1 @@\n-  ClassFileStream* stream = NULL;\n+  ClassFileStream* stream = nullptr;\n@@ -1137,1 +1137,1 @@\n-  ClassPathEntry* e = NULL;\n+  ClassPathEntry* e = nullptr;\n@@ -1156,1 +1156,1 @@\n-  if (_patch_mod_entries != NULL && !search_append_only) {\n+  if (_patch_mod_entries != nullptr && !search_append_only) {\n@@ -1172,1 +1172,1 @@\n-  if (!search_append_only && (NULL == stream)) {\n+  if (!search_append_only && (nullptr == stream)) {\n@@ -1178,1 +1178,1 @@\n-      assert(_exploded_entries != NULL, \"No exploded build entries present\");\n+      assert(_exploded_entries != nullptr, \"No exploded build entries present\");\n@@ -1184,1 +1184,1 @@\n-  if (search_append_only && (NULL == stream)) {\n+  if (search_append_only && (nullptr == stream)) {\n@@ -1192,1 +1192,1 @@\n-    while (e != NULL) {\n+    while (e != nullptr) {\n@@ -1194,1 +1194,1 @@\n-      if (NULL != stream) {\n+      if (nullptr != stream) {\n@@ -1202,2 +1202,2 @@\n-  if (NULL == stream) {\n-    return NULL;\n+  if (nullptr == stream) {\n+    return nullptr;\n@@ -1246,1 +1246,1 @@\n-  assert(stream != NULL, \"sanity\");\n+  assert(stream != nullptr, \"sanity\");\n@@ -1255,2 +1255,2 @@\n-  if (src == NULL) {\n-    if (loader == NULL) {\n+  if (src == nullptr) {\n+    if (loader == nullptr) {\n@@ -1275,1 +1275,1 @@\n-    assert(path != NULL, \"sanity\");\n+    assert(path != nullptr, \"sanity\");\n@@ -1280,1 +1280,1 @@\n-      assert(ent->name() != NULL, \"sanity\");\n+      assert(ent->name() != nullptr, \"sanity\");\n@@ -1287,1 +1287,1 @@\n-        \/\/ NULL pkg_entry and pkg_entry in an unnamed module implies the class\n+        \/\/ null pkg_entry and pkg_entry in an unnamed module implies the class\n@@ -1290,1 +1290,1 @@\n-        if ((pkg_entry == NULL) || (pkg_entry->in_unnamed_module())) {\n+        if ((pkg_entry == nullptr) || (pkg_entry->in_unnamed_module())) {\n@@ -1303,1 +1303,1 @@\n-              assert(loader == NULL, \"sanity\");\n+              assert(loader == nullptr, \"sanity\");\n@@ -1311,1 +1311,1 @@\n-          if ((pkg_entry != NULL) && !(pkg_entry->in_unnamed_module()) && (i > 0)) {\n+          if ((pkg_entry != nullptr) && !(pkg_entry->in_unnamed_module()) && (i > 0)) {\n@@ -1348,1 +1348,1 @@\n-  assert(file_name != NULL, \"invariant\");\n+  assert(file_name != nullptr, \"invariant\");\n@@ -1398,1 +1398,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1416,2 +1416,2 @@\n-  if (JImage_file == NULL) {\n-    return NULL;\n+  if (JImage_file == nullptr) {\n+    return nullptr;\n@@ -1426,2 +1426,2 @@\n-  assert(JImageOpen != NULL, \"jimage library should have been opened\");\n-  if (JImage_file == NULL) {\n+  assert(JImageOpen != nullptr, \"jimage library should have been opened\");\n+  if (JImage_file == nullptr) {\n@@ -1459,1 +1459,1 @@\n-  while (e != NULL) {\n+  while (e != nullptr) {\n@@ -1517,1 +1517,1 @@\n-  if (Arguments::get_patch_mod_prefix() != NULL) {\n+  if (Arguments::get_patch_mod_prefix() != nullptr) {\n@@ -1535,1 +1535,1 @@\n-    assert(_exploded_entries == NULL, \"Should only get initialized once\");\n+    assert(_exploded_entries == nullptr, \"Should only get initialized once\");\n@@ -1543,1 +1543,1 @@\n-  assert(orig != NULL, \"bad arguments\");\n+  assert(orig != nullptr, \"bad arguments\");\n@@ -1551,1 +1551,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1565,1 +1565,1 @@\n-  if (null_cld_modules == NULL) {\n+  if (null_cld_modules == nullptr) {\n@@ -1571,1 +1571,1 @@\n-    if (ModuleEntryTable::javabase_moduleEntry() == NULL) {  \/\/ may have been inited by CDS.\n+    if (ModuleEntryTable::javabase_moduleEntry() == nullptr) {  \/\/ may have been inited by CDS.\n@@ -1573,2 +1573,2 @@\n-                               false, vmSymbols::java_base(), NULL, NULL, null_cld);\n-      if (jb_module == NULL) {\n+                               false, vmSymbols::java_base(), nullptr, nullptr, null_cld);\n+      if (jb_module == nullptr) {\n@@ -1587,1 +1587,1 @@\n-  if (_eventp != NULL) {\n+  if (_eventp != nullptr) {\n@@ -1602,1 +1602,1 @@\n-  if (_recursion_counters == NULL || (_recursion_counters[_event_type])++ == 0) {\n+  if (_recursion_counters == nullptr || (_recursion_counters[_event_type])++ == 0) {\n@@ -1625,1 +1625,1 @@\n-  if (_recursion_counters != NULL && --(_recursion_counters[_event_type]) > 0) return;\n+  if (_recursion_counters != nullptr && --(_recursion_counters[_event_type]) > 0) return;\n@@ -1630,1 +1630,1 @@\n-  if (_selftimep != NULL) {\n+  if (_selftimep != nullptr) {\n","filename":"src\/hotspot\/share\/classfile\/classLoader.cpp","additions":189,"deletions":189,"binary":false,"changes":378,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -62,1 +62,1 @@\n-  virtual JImageFile* jimage() const { return NULL; }\n+  virtual JImageFile* jimage() const { return nullptr; }\n@@ -65,1 +65,1 @@\n-  ClassPathEntry() : _next(NULL) {}\n+  ClassPathEntry() : _next(nullptr) {}\n@@ -123,1 +123,1 @@\n-  const char* name() const { return _name == NULL ? \"\" : _name; }\n+  const char* name() const { return _name == nullptr ? \"\" : _name; }\n@@ -238,1 +238,1 @@\n-  static bool has_bootclasspath_append() { return first_append_entry() != NULL; }\n+  static bool has_bootclasspath_append() { return first_append_entry() != nullptr; }\n@@ -311,1 +311,1 @@\n-  static bool has_jrt_entry() { return (_jrt_entry != NULL); }\n+  static bool has_jrt_entry() { return (_jrt_entry != nullptr); }\n@@ -384,1 +384,1 @@\n-  static void  trace_class_path(const char* msg, const char* name = NULL);\n+  static void  trace_class_path(const char* msg, const char* name = nullptr);\n@@ -398,1 +398,1 @@\n-  \/\/ creates a class path zip entry (returns NULL if JAR file cannot be opened)\n+  \/\/ creates a class path zip entry (returns null if JAR file cannot be opened)\n@@ -405,2 +405,2 @@\n-  \/\/ distinguish from a class_name with no package name, as both cases have a NULL return value\n-  static Symbol* package_from_class_name(const Symbol* class_name, bool* bad_class_name = NULL);\n+  \/\/ distinguish from a class_name with no package name, as both cases have a null return value\n+  static Symbol* package_from_class_name(const Symbol* class_name, bool* bad_class_name = nullptr);\n@@ -461,1 +461,1 @@\n-      _timep(timep), _selftimep(NULL), _eventp(NULL), _recursion_counters(NULL), _timers(timers), _event_type(type) {\n+      _timep(timep), _selftimep(nullptr), _eventp(nullptr), _recursion_counters(nullptr), _timers(timers), _event_type(type) {\n","filename":"src\/hotspot\/share\/classfile\/classLoader.hpp","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -54,1 +54,1 @@\n-      assert(e != NULL, \"Not that many classpath entries.\");\n+      assert(e != nullptr, \"Not that many classpath entries.\");\n@@ -77,1 +77,1 @@\n-  while (e != NULL) {\n+  while (e != nullptr) {\n@@ -98,1 +98,1 @@\n-  while (e != NULL) {\n+  while (e != nullptr) {\n","filename":"src\/hotspot\/share\/classfile\/classLoader.inline.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-\/\/ The bootstrap loader (represented by NULL) also has a ClassLoaderData,\n+\/\/ The bootstrap loader (represented by null) also has a ClassLoaderData,\n@@ -83,1 +83,1 @@\n-ClassLoaderData * ClassLoaderData::_the_null_class_loader_data = NULL;\n+ClassLoaderData * ClassLoaderData::_the_null_class_loader_data = nullptr;\n@@ -86,2 +86,2 @@\n-  assert(_the_null_class_loader_data == NULL, \"cannot initialize twice\");\n-  assert(ClassLoaderDataGraph::_head == NULL, \"cannot initialize twice\");\n+  assert(_the_null_class_loader_data == nullptr, \"cannot initialize twice\");\n+  assert(ClassLoaderDataGraph::_head == nullptr, \"cannot initialize twice\");\n@@ -113,1 +113,1 @@\n-  if (cl_name != NULL) {\n+  if (cl_name != nullptr) {\n@@ -116,1 +116,1 @@\n-    if (cl_instance_name != NULL && cl_instance_name[0] != '\\0') {\n+    if (cl_instance_name != nullptr && cl_instance_name[0] != '\\0') {\n@@ -130,1 +130,1 @@\n-                  (cl_name_and_id == NULL) ? _class_loader_klass->external_name() :\n+                  (cl_name_and_id == nullptr) ? _class_loader_klass->external_name() :\n@@ -132,1 +132,1 @@\n-  assert(cl_instance_name_and_id != NULL && cl_instance_name_and_id[0] != '\\0', \"class loader has no name and id\");\n+  assert(cl_instance_name_and_id != nullptr && cl_instance_name_and_id[0] != '\\0', \"class loader has no name and id\");\n@@ -137,1 +137,1 @@\n-  _metaspace(NULL),\n+  _metaspace(nullptr),\n@@ -147,5 +147,5 @@\n-  _klasses(NULL), _packages(NULL), _modules(NULL), _unnamed_module(NULL), _dictionary(NULL),\n-  _jmethod_ids(NULL),\n-  _deallocate_list(NULL),\n-  _next(NULL),\n-  _class_loader_klass(NULL), _name(NULL), _name_and_id(NULL) {\n+  _klasses(nullptr), _packages(nullptr), _modules(nullptr), _unnamed_module(nullptr), _dictionary(nullptr),\n+  _jmethod_ids(nullptr),\n+  _deallocate_list(nullptr),\n+  _next(nullptr),\n+  _class_loader_klass(nullptr), _name(nullptr), _name_and_id(nullptr) {\n@@ -184,1 +184,1 @@\n-  while (c != NULL) {\n+  while (c != nullptr) {\n@@ -192,1 +192,1 @@\n-  if (_head == NULL || _head->_size == Chunk::CAPACITY) {\n+  if (_head == nullptr || _head->_size == Chunk::CAPACITY) {\n@@ -205,1 +205,1 @@\n-  while (chunk != NULL) {\n+  while (chunk != nullptr) {\n@@ -214,1 +214,1 @@\n-    if (c->_data[i] != NULL) {\n+    if (c->_data[i] != nullptr) {\n@@ -222,1 +222,1 @@\n-  if (head != NULL) {\n+  if (head != nullptr) {\n@@ -225,1 +225,1 @@\n-    for (Chunk* c = head->_next; c != NULL; c = c->_next) {\n+    for (Chunk* c = head->_next; c != nullptr; c = c->_next) {\n@@ -239,1 +239,1 @@\n-    if (p != NULL && NativeAccess<AS_NO_KEEPALIVE>::oop_load(p) == _target) {\n+    if (p != nullptr && NativeAccess<AS_NO_KEEPALIVE>::oop_load(p) == _target) {\n@@ -263,1 +263,1 @@\n-  while (chunk != NULL) {\n+  while (chunk != nullptr) {\n@@ -339,1 +339,1 @@\n-  for (Klass* k = Atomic::load_acquire(&_klasses); k != NULL; k = k->next_link()) {\n+  for (Klass* k = Atomic::load_acquire(&_klasses); k != nullptr; k = k->next_link()) {\n@@ -347,1 +347,1 @@\n-  for (Klass* k = Atomic::load_acquire(&_klasses); k != NULL; k = k->next_link()) {\n+  for (Klass* k = Atomic::load_acquire(&_klasses); k != nullptr; k = k->next_link()) {\n@@ -355,1 +355,1 @@\n-  for (Klass* k = Atomic::load_acquire(&_klasses); k != NULL; k = k->next_link()) {\n+  for (Klass* k = Atomic::load_acquire(&_klasses); k != nullptr; k = k->next_link()) {\n@@ -367,1 +367,1 @@\n-  for (Klass* k = Atomic::load_acquire(&_klasses); k != NULL; k = k->next_link()) {\n+  for (Klass* k = Atomic::load_acquire(&_klasses); k != nullptr; k = k->next_link()) {\n@@ -386,1 +386,1 @@\n-    assert(m != NULL, \"NULL mirror\");\n+    assert(m != nullptr, \"nullptr mirror\");\n@@ -395,1 +395,1 @@\n-  for (Klass* k = Atomic::load_acquire(&_klasses); k != NULL; k = k->next_link()) {\n+  for (Klass* k = Atomic::load_acquire(&_klasses); k != nullptr; k = k->next_link()) {\n@@ -405,1 +405,1 @@\n-  if (_unnamed_module != NULL) {\n+  if (_unnamed_module != nullptr) {\n@@ -408,1 +408,1 @@\n-  if (_modules != NULL) {\n+  if (_modules != nullptr) {\n@@ -415,1 +415,1 @@\n-  if (_packages != NULL) {\n+  if (_packages != nullptr) {\n@@ -421,1 +421,1 @@\n-  assert(k != NULL, \"invariant\");\n+  assert(k != nullptr, \"invariant\");\n@@ -503,1 +503,1 @@\n-  if (loader_or_mirror() != NULL) {\n+  if (loader_or_mirror() != nullptr) {\n@@ -517,2 +517,2 @@\n-  Klass* prev = NULL;\n-  for (Klass* k = _klasses; k != NULL; k = k->next_link()) {\n+  Klass* prev = nullptr;\n+  for (Klass* k = _klasses; k != nullptr; k = k->next_link()) {\n@@ -520,1 +520,1 @@\n-      if (prev == NULL) {\n+      if (prev == nullptr) {\n@@ -562,1 +562,1 @@\n-  \/\/ Method::clear_jmethod_ids only sets the jmethod_ids to NULL without\n+  \/\/ Method::clear_jmethod_ids only sets the jmethod_ids to null without\n@@ -570,1 +570,1 @@\n-  \/\/ being NULL after class unloading. Hence, it is unsafe to free the memory\n+  \/\/ being null after class unloading. Hence, it is unsafe to free the memory\n@@ -573,1 +573,1 @@\n-  if (_jmethod_ids != NULL) {\n+  if (_jmethod_ids != nullptr) {\n@@ -585,1 +585,1 @@\n-  if (modules == NULL) {\n+  if (modules == nullptr) {\n@@ -588,1 +588,1 @@\n-    if ((modules = _modules) == NULL) {\n+    if ((modules = _modules) == nullptr) {\n@@ -607,1 +607,1 @@\n-  if (_the_null_class_loader_data == NULL) {\n+  if (_the_null_class_loader_data == nullptr) {\n@@ -627,1 +627,1 @@\n-  if (!_holder.is_null()) {  \/\/ NULL class_loader\n+  if (!_holder.is_null()) {  \/\/ null class_loader\n@@ -630,1 +630,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -636,1 +636,1 @@\n-  if (!_holder.is_null()) {  \/\/ NULL class_loader\n+  if (!_holder.is_null()) {  \/\/ null class_loader\n@@ -639,1 +639,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -646,1 +646,1 @@\n-      || (_holder.peek() != NULL);  \/\/ and not cleaned by the GC weak handle processing.\n+      || (_holder.peek() != nullptr);  \/\/ and not cleaned by the GC weak handle processing.\n@@ -684,1 +684,1 @@\n-  if (_packages != NULL) {\n+  if (_packages != nullptr) {\n@@ -687,1 +687,1 @@\n-    _packages = NULL;\n+    _packages = nullptr;\n@@ -691,1 +691,1 @@\n-  if (_modules != NULL) {\n+  if (_modules != nullptr) {\n@@ -694,1 +694,1 @@\n-    _modules = NULL;\n+    _modules = nullptr;\n@@ -698,1 +698,1 @@\n-  if (_dictionary != NULL) {\n+  if (_dictionary != nullptr) {\n@@ -701,1 +701,1 @@\n-    _dictionary = NULL;\n+    _dictionary = nullptr;\n@@ -704,1 +704,1 @@\n-  if (_unnamed_module != NULL) {\n+  if (_unnamed_module != nullptr) {\n@@ -706,1 +706,1 @@\n-    _unnamed_module = NULL;\n+    _unnamed_module = nullptr;\n@@ -711,2 +711,2 @@\n-  if (m != NULL) {\n-    _metaspace = NULL;\n+  if (m != nullptr) {\n+    _metaspace = nullptr;\n@@ -720,1 +720,1 @@\n-  if (_deallocate_list != NULL) {\n+  if (_deallocate_list != nullptr) {\n@@ -725,1 +725,1 @@\n-  if (_name != NULL) {\n+  if (_name != nullptr) {\n@@ -728,1 +728,1 @@\n-  if (_name_and_id != NULL) {\n+  if (_name_and_id != nullptr) {\n@@ -771,1 +771,1 @@\n-  if (metaspace == NULL) {\n+  if (metaspace == nullptr) {\n@@ -774,1 +774,1 @@\n-    if ((metaspace = _metaspace) == NULL) {\n+    if ((metaspace = _metaspace) == nullptr) {\n@@ -776,1 +776,1 @@\n-        assert (class_loader() == NULL, \"Must be\");\n+        assert (class_loader() == nullptr, \"Must be\");\n@@ -801,1 +801,1 @@\n-  if (ptr != NULL) {\n+  if (ptr != nullptr) {\n@@ -803,1 +803,1 @@\n-    NativeAccess<>::oop_store(ptr, oop(NULL));\n+    NativeAccess<>::oop_store(ptr, oop(nullptr));\n@@ -809,1 +809,1 @@\n-  if (dest.resolve() != NULL) {\n+  if (dest.resolve() != nullptr) {\n@@ -823,1 +823,1 @@\n-    if (_deallocate_list == NULL) {\n+    if (_deallocate_list == nullptr) {\n@@ -839,1 +839,1 @@\n-  if (_deallocate_list == NULL) {\n+  if (_deallocate_list == nullptr) {\n@@ -878,1 +878,1 @@\n-  if (_deallocate_list == NULL) {\n+  if (_deallocate_list == nullptr) {\n@@ -904,1 +904,1 @@\n-   if (_class_loader_klass == NULL) {\n+   if (_class_loader_klass == nullptr) {\n@@ -906,1 +906,1 @@\n-   } else if (_name != NULL) {\n+   } else if (_name != nullptr) {\n@@ -919,1 +919,1 @@\n-  if (_class_loader_klass == NULL) {\n+  if (_class_loader_klass == nullptr) {\n@@ -921,1 +921,1 @@\n-  } else if (_name_and_id != NULL) {\n+  } else if (_name_and_id != nullptr) {\n@@ -930,1 +930,1 @@\n-  if (!is_unloading() && class_loader() != NULL) {\n+  if (!is_unloading() && class_loader() != nullptr) {\n@@ -1002,1 +1002,1 @@\n-  if (_jmethod_ids != NULL) {\n+  if (_jmethod_ids != nullptr) {\n@@ -1036,1 +1036,1 @@\n-  guarantee(cl != NULL || this == ClassLoaderData::the_null_class_loader_data() || has_class_mirror_holder(), \"must be\");\n+  guarantee(cl != nullptr || this == ClassLoaderData::the_null_class_loader_data() || has_class_mirror_holder(), \"must be\");\n@@ -1040,1 +1040,1 @@\n-  if (metaspace_or_null() != NULL) {\n+  if (metaspace_or_null() != nullptr) {\n@@ -1045,1 +1045,1 @@\n-  for (Klass* k = _klasses; k != NULL; k = k->next_link()) {\n+  for (Klass* k = _klasses; k != nullptr; k = k->next_link()) {\n@@ -1051,1 +1051,1 @@\n-  if (_modules != NULL) {\n+  if (_modules != nullptr) {\n@@ -1071,1 +1071,1 @@\n-  for (Klass* k = Atomic::load_acquire(&_klasses); k != NULL; k = k->next_link()) {\n+  for (Klass* k = Atomic::load_acquire(&_klasses); k != nullptr; k = k->next_link()) {\n","filename":"src\/hotspot\/share\/classfile\/classLoaderData.cpp","additions":80,"deletions":80,"binary":false,"changes":160,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -87,1 +87,1 @@\n-    ChunkedHandleList() : _head(NULL) {}\n+    ChunkedHandleList() : _head(nullptr) {}\n@@ -146,1 +146,1 @@\n-  \/\/ These method IDs are created for the class loader and set to NULL when the\n+  \/\/ These method IDs are created for the class loader and set to null when the\n@@ -257,1 +257,1 @@\n-  \/\/ The Metaspace is created lazily so may be NULL.  This\n+  \/\/ The Metaspace is created lazily so may be null.  This\n@@ -303,1 +303,1 @@\n-  bool modules_defined() { return (_modules != NULL); }\n+  bool modules_defined() { return (_modules != nullptr); }\n@@ -317,1 +317,1 @@\n-  \/\/ Returns Klass* of associated class loader, or NULL if associated loader is 'bootstrap'.\n+  \/\/ Returns Klass* of associated class loader, or null if associated loader is 'bootstrap'.\n@@ -325,1 +325,1 @@\n-  \/\/ Returns the explicitly specified class loader name or NULL.\n+  \/\/ Returns the explicitly specified class loader name or null.\n","filename":"src\/hotspot\/share\/classfile\/classLoaderData.hpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n-  assert(_holder.is_null() || holder_no_keepalive() != NULL , \"This class loader data holder must be alive\");\n+  assert(_holder.is_null() || holder_no_keepalive() != nullptr , \"This class loader data holder must be alive\");\n@@ -44,1 +44,1 @@\n-  assert(_holder.is_null() || holder_no_keepalive() != NULL , \"This class loader data holder must be alive\");\n+  assert(_holder.is_null() || holder_no_keepalive() != nullptr , \"This class loader data holder must be alive\");\n@@ -49,1 +49,1 @@\n-  return this == _the_null_class_loader_data || class_loader() == NULL;\n+  return this == _the_null_class_loader_data || class_loader() == nullptr;\n@@ -53,1 +53,1 @@\n-  if (loader == NULL) {\n+  if (loader == nullptr) {\n@@ -61,1 +61,1 @@\n-  assert(loader_data != NULL, \"Must be\");\n+  assert(loader_data != nullptr, \"Must be\");\n","filename":"src\/hotspot\/share\/classfile\/classLoaderData.inline.hpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -64,1 +64,1 @@\n-  for (ClassLoaderData* cld = Atomic::load_acquire(&_head); cld != NULL; cld = cld->next()) {\n+  for (ClassLoaderData* cld = Atomic::load_acquire(&_head); cld != nullptr; cld = cld->next()) {\n@@ -70,1 +70,1 @@\n- for (ClassLoaderData* cld = Atomic::load_acquire(&_head); cld != NULL; cld = cld->next()) {\n+ for (ClassLoaderData* cld = Atomic::load_acquire(&_head); cld != nullptr; cld = cld->next()) {\n@@ -77,1 +77,1 @@\n- for (ClassLoaderData* cld = Atomic::load_acquire(&_head); cld != NULL; cld = cld->next()) {\n+ for (ClassLoaderData* cld = Atomic::load_acquire(&_head); cld != nullptr; cld = cld->next()) {\n@@ -90,1 +90,1 @@\n-  ClassLoaderDataGraphKlassIteratorStatic() : _current_loader_data(NULL), _current_class_entry(NULL) {}\n+  ClassLoaderDataGraphKlassIteratorStatic() : _current_loader_data(nullptr), _current_class_entry(nullptr) {}\n@@ -98,1 +98,1 @@\n-      if (_current_class_entry != NULL) {\n+      if (_current_class_entry != nullptr) {\n@@ -113,1 +113,1 @@\n-        if (_current_loader_data != NULL) {\n+        if (_current_loader_data != nullptr) {\n@@ -117,1 +117,1 @@\n-        if (_current_loader_data == NULL) {\n+        if (_current_loader_data == nullptr) {\n@@ -125,2 +125,2 @@\n-    \/\/ Caller handles NULL.\n-    return NULL;\n+    \/\/ Caller handles null.\n+    return nullptr;\n@@ -134,1 +134,1 @@\n-      if (_current_loader_data != NULL) {\n+      if (_current_loader_data != nullptr) {\n@@ -165,1 +165,1 @@\n-  for (ClassLoaderData* cld = _head; cld != NULL; cld = cld->next()) {\n+  for (ClassLoaderData* cld = _head; cld != nullptr; cld = cld->next()) {\n@@ -205,2 +205,2 @@\n-ClassLoaderData* volatile ClassLoaderDataGraph::_head = NULL;\n-ClassLoaderData* ClassLoaderDataGraph::_unloading = NULL;\n+ClassLoaderData* volatile ClassLoaderDataGraph::_head = nullptr;\n+ClassLoaderData* ClassLoaderDataGraph::_unloading = nullptr;\n@@ -224,1 +224,1 @@\n-    if (cld != NULL) {\n+    if (cld != nullptr) {\n@@ -267,1 +267,1 @@\n-  for (ClassLoaderData* cld = _unloading; cld != NULL; cld = cld->next()) {\n+  for (ClassLoaderData* cld = _unloading; cld != nullptr; cld = cld->next()) {\n@@ -277,1 +277,1 @@\n-  for (ClassLoaderData* cld = _head;  cld != NULL; cld = cld->_next) {\n+  for (ClassLoaderData* cld = _head;  cld != nullptr; cld = cld->_next) {\n@@ -284,1 +284,1 @@\n-  for (ClassLoaderData* cld = _head;  cld != NULL; cld = cld->_next) {\n+  for (ClassLoaderData* cld = _head;  cld != nullptr; cld = cld->_next) {\n@@ -286,1 +286,1 @@\n-    if (closure != NULL) {\n+    if (closure != nullptr) {\n@@ -295,1 +295,1 @@\n-    roots_cld_do(cl, NULL);\n+    roots_cld_do(cl, nullptr);\n@@ -309,1 +309,1 @@\n-LockedClassesDo::LockedClassesDo() : _function(NULL),\n+LockedClassesDo::LockedClassesDo() : _function(nullptr),\n@@ -346,1 +346,1 @@\n-    while (cld != NULL && !cld->is_alive()) {\n+    while (cld != nullptr && !cld->is_alive()) {\n@@ -349,1 +349,1 @@\n-    if (cld != NULL) {\n+    if (cld != nullptr) {\n@@ -356,1 +356,1 @@\n-      _next = NULL;\n+      _next = nullptr;\n@@ -427,1 +427,1 @@\n-  for (ClassLoaderData* cld = _unloading; cld != NULL; cld = cld->next()) {\n+  for (ClassLoaderData* cld = _unloading; cld != nullptr; cld = cld->next()) {\n@@ -444,1 +444,1 @@\n-                                  if (X->dictionary() != NULL)\n+                                  if (X->dictionary() != nullptr)\n@@ -468,1 +468,1 @@\n-  for (ClassLoaderData* data = _head; data != NULL; data = data->next()) {\n+  for (ClassLoaderData* data = _head; data != nullptr; data = data->next()) {\n@@ -480,1 +480,1 @@\n-  if (loader_data != NULL) {\n+  if (loader_data != nullptr) {\n@@ -484,1 +484,1 @@\n-    for (ClassLoaderData* data = _head; data != NULL; data = data->next()) {\n+    for (ClassLoaderData* data = _head; data != nullptr; data = data->next()) {\n@@ -499,1 +499,1 @@\n-  ClassLoaderData* prev = NULL;\n+  ClassLoaderData* prev = nullptr;\n@@ -505,1 +505,1 @@\n-  while (data != NULL) {\n+  while (data != nullptr) {\n@@ -520,1 +520,1 @@\n-    if (prev != NULL) {\n+    if (prev != nullptr) {\n@@ -541,1 +541,1 @@\n-  while (data != NULL) {\n+  while (data != nullptr) {\n@@ -548,1 +548,1 @@\n-    if (data->packages() != NULL) {\n+    if (data->packages() != nullptr) {\n@@ -560,1 +560,1 @@\n-  _unloading = NULL;\n+  _unloading = nullptr;\n@@ -563,1 +563,1 @@\n-  while (next != NULL) {\n+  while (next != nullptr) {\n@@ -594,1 +594,1 @@\n-    : _next_klass(NULL) {\n+    : _next_klass(nullptr) {\n@@ -597,1 +597,1 @@\n-  Klass* klass = NULL;\n+  Klass* klass = nullptr;\n@@ -600,1 +600,1 @@\n-  while (cld != NULL) {\n+  while (cld != nullptr) {\n@@ -603,1 +603,1 @@\n-    if (klass != NULL) {\n+    if (klass != nullptr) {\n@@ -613,1 +613,1 @@\n-  if (next != NULL) {\n+  if (next != nullptr) {\n@@ -620,1 +620,1 @@\n-  while (next == NULL) {\n+  while (next == nullptr) {\n@@ -622,1 +622,1 @@\n-    if (cld == NULL) {\n+    if (cld == nullptr) {\n@@ -634,1 +634,1 @@\n-  while (head != NULL) {\n+  while (head != nullptr) {\n@@ -647,2 +647,2 @@\n-  assert(head == NULL, \"head is \" PTR_FORMAT \", expected not null:\", p2i(head));\n-  return NULL;\n+  assert(head == nullptr, \"head is \" PTR_FORMAT \", expected not null:\", p2i(head));\n+  return nullptr;\n","filename":"src\/hotspot\/share\/classfile\/classLoaderDataGraph.cpp","additions":46,"deletions":46,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-  guarantee(loader() != NULL && oopDesc::is_oop(loader()), \"Loader must be oop\");\n+  guarantee(loader() != nullptr && oopDesc::is_oop(loader()), \"Loader must be oop\");\n","filename":"src\/hotspot\/share\/classfile\/classLoaderDataGraph.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,1 +44,1 @@\n-    \/\/ loader_data may be NULL if the boot layer has loaded no modules for the platform or\n+    \/\/ loader_data may be null if the boot layer has loaded no modules for the platform or\n@@ -46,1 +46,1 @@\n-    if (loader_data != NULL) {\n+    if (loader_data != nullptr) {\n@@ -52,1 +52,1 @@\n-  ArchivedClassLoaderData() : _packages(NULL), _modules(NULL) {}\n+  ArchivedClassLoaderData() : _packages(nullptr), _modules(nullptr) {}\n@@ -70,1 +70,1 @@\n-static ModuleEntry* _archived_javabase_moduleEntry = NULL;\n+static ModuleEntry* _archived_javabase_moduleEntry = nullptr;\n@@ -75,1 +75,1 @@\n-  if (loader_data != NULL) {\n+  if (loader_data != nullptr) {\n@@ -84,1 +84,1 @@\n-  if (loader_data != NULL) {\n+  if (loader_data != nullptr) {\n@@ -97,1 +97,1 @@\n-  if (loader_data != NULL) {\n+  if (loader_data != nullptr) {\n@@ -106,1 +106,1 @@\n-  if (_modules != NULL) { \/\/ Could be NULL if we have archived no modules for platform\/system loaders\n+  if (_modules != nullptr) { \/\/ Could be null if we have archived no modules for platform\/system loaders\n@@ -123,1 +123,1 @@\n-  if (_modules != NULL) {\n+  if (_modules != nullptr) {\n@@ -134,1 +134,1 @@\n-  assert(loader_data != NULL, \"must be\");\n+  assert(loader_data != nullptr, \"must be\");\n","filename":"src\/hotspot\/share\/classfile\/classLoaderDataShared.cpp","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -133,1 +133,1 @@\n-  if (manifest == NULL) { \/\/ No Manifest\n+  if (manifest == nullptr) { \/\/ No Manifest\n@@ -135,1 +135,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -155,1 +155,1 @@\n-  char* found = NULL;\n+  char* found = nullptr;\n@@ -163,1 +163,1 @@\n-    if (line_end == NULL) {\n+    if (line_end == nullptr) {\n@@ -168,1 +168,1 @@\n-      if (found != NULL) {\n+      if (found != nullptr) {\n@@ -190,1 +190,1 @@\n-  if (manifest == NULL) {\n+  if (manifest == nullptr) {\n@@ -194,1 +194,1 @@\n-  if (strstr(manifest, \"Extension-List:\") != NULL) {\n+  if (strstr(manifest, \"Extension-List:\") != nullptr) {\n@@ -200,1 +200,1 @@\n-  if (cp_attr != NULL && strlen(cp_attr) > 0) {\n+  if (cp_attr != nullptr && strlen(cp_attr) > 0) {\n@@ -207,1 +207,1 @@\n-    if (dir_tail == NULL) {\n+    if (dir_tail == nullptr) {\n@@ -219,1 +219,1 @@\n-      if (file_end != NULL) {\n+      if (file_end != nullptr) {\n","filename":"src\/hotspot\/share\/classfile\/classLoaderExt.cpp","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,2 +51,2 @@\n-  ClassLoaderHierarchyDCmd* dcmd = new ClassLoaderHierarchyDCmd(NULL, false);\n-  if (dcmd != NULL) {\n+  ClassLoaderHierarchyDCmd* dcmd = new ClassLoaderHierarchyDCmd(nullptr, false);\n+  if (dcmd != nullptr) {\n@@ -125,1 +125,1 @@\n-    : _next(NULL), _klass(klass), _cld(cld) {}\n+    : _next(nullptr), _klass(klass), _cld(cld) {}\n@@ -140,1 +140,1 @@\n-  const ClassLoaderData* _cld; \/\/ May be NULL if loader never loaded anything\n+  const ClassLoaderData* _cld; \/\/ May be null if loader never loaded anything\n@@ -157,1 +157,1 @@\n-  \/\/ Returns Klass of loader; NULL for bootstrap loader\n+  \/\/ Returns Klass of loader; null for bootstrap loader\n@@ -159,1 +159,1 @@\n-    return (_loader_oop != NULL) ? _loader_oop->klass() : NULL;\n+    return (_loader_oop != nullptr) ? _loader_oop->klass() : nullptr;\n@@ -165,1 +165,1 @@\n-    return klass != NULL ? klass->external_name() : \"\";\n+    return klass != nullptr ? klass->external_name() : \"\";\n@@ -168,1 +168,1 @@\n-  \/\/ Returns oop of loader name; NULL for bootstrap; NULL if no name was set\n+  \/\/ Returns oop of loader name; null for bootstrap; null if no name was set\n@@ -170,1 +170,1 @@\n-    return (_loader_oop != NULL) ? java_lang_ClassLoader::name(_loader_oop) : NULL;\n+    return (_loader_oop != nullptr) ? java_lang_ClassLoader::name(_loader_oop) : nullptr;\n@@ -176,1 +176,1 @@\n-    return name_oop != NULL ? java_lang_String::as_utf8_string(name_oop) : \"\";\n+    return name_oop != nullptr ? java_lang_String::as_utf8_string(name_oop) : \"\";\n@@ -180,2 +180,2 @@\n-    if (_loader_oop == NULL) {\n-      assert(_cld != NULL && _cld->is_boot_class_loader_data(), \"bootstrap loader must have CLD\");\n+    if (_loader_oop == nullptr) {\n+      assert(_cld != nullptr && _cld->is_boot_class_loader_data(), \"bootstrap loader must have CLD\");\n@@ -218,1 +218,1 @@\n-    const bool have_sibling = _next != NULL;\n+    const bool have_sibling = _next != nullptr;\n@@ -224,1 +224,1 @@\n-      const bool have_child = _child != NULL;\n+      const bool have_child = _child != nullptr;\n@@ -247,2 +247,2 @@\n-        if (_classes != NULL) {\n-          assert(_cld != NULL, \"we have classes, we should have a CLD\");\n+        if (_classes != nullptr) {\n+          assert(_cld != nullptr, \"we have classes, we should have a CLD\");\n@@ -272,2 +272,2 @@\n-        if (_hidden_classes != NULL) {\n-          assert(_cld != NULL, \"we have classes, we should have a CLD\");\n+        if (_hidden_classes != nullptr) {\n+          assert(_cld != nullptr, \"we have classes, we should have a CLD\");\n@@ -306,1 +306,1 @@\n-    while (c != NULL) {\n+    while (c != nullptr) {\n@@ -321,1 +321,1 @@\n-    if (k == NULL || k != target_node->loader_klass()) {\n+    if (k == nullptr || k != target_node->loader_klass()) {\n@@ -336,2 +336,2 @@\n-    : _loader_oop(loader_oop), _cld(NULL), _child(NULL), _next(NULL),\n-      _classes(NULL), _num_classes(0), _hidden_classes(NULL),\n+    : _loader_oop(loader_oop), _cld(nullptr), _child(nullptr), _next(nullptr),\n+      _classes(nullptr), _num_classes(0), _hidden_classes(nullptr),\n@@ -342,1 +342,1 @@\n-    assert(_cld == NULL, \"there should be only one primary CLD per loader\");\n+    assert(_cld == nullptr, \"there should be only one primary CLD per loader\");\n@@ -352,1 +352,1 @@\n-    assert(info->_next == NULL, \"must be\");\n+    assert(info->_next == nullptr, \"must be\");\n@@ -366,1 +366,1 @@\n-    while ((*p_list_to_add_to) != NULL) {\n+    while ((*p_list_to_add_to) != nullptr) {\n@@ -378,1 +378,1 @@\n-    LoaderTreeNode* result = NULL;\n+    LoaderTreeNode* result = nullptr;\n@@ -383,1 +383,1 @@\n-      while (c != NULL && result == NULL) {\n+      while (c != nullptr && result == nullptr) {\n@@ -391,1 +391,1 @@\n-  bool is_leaf() const { return _child == NULL; }\n+  bool is_leaf() const { return _child == nullptr; }\n@@ -398,1 +398,1 @@\n-    LoaderTreeNode* prev = NULL;\n+    LoaderTreeNode* prev = nullptr;\n@@ -400,2 +400,2 @@\n-    while (node != NULL) {\n-      LoaderTreeNode* matching_node = NULL;\n+    while (node != nullptr) {\n+      LoaderTreeNode* matching_node = nullptr;\n@@ -404,1 +404,1 @@\n-        for (LoaderTreeNode* node2 = _child; node2 != node && matching_node == NULL;\n+        for (LoaderTreeNode* node2 = _child; node2 != node && matching_node == nullptr;\n@@ -413,1 +413,1 @@\n-      if (matching_node != NULL) {\n+      if (matching_node != nullptr) {\n@@ -416,1 +416,1 @@\n-        assert(prev != NULL, \"Sanity\"); \/\/ can never happen since we do not fold the first node.\n+        assert(prev != nullptr, \"Sanity\"); \/\/ can never happen since we do not fold the first node.\n@@ -438,1 +438,1 @@\n-    : _list(NULL), _cld(cld), _num_classes(0) {}\n+    : _list(nullptr), _cld(cld), _num_classes(0) {}\n@@ -454,1 +454,1 @@\n-    assert(info != NULL && cld != NULL, \"must be\");\n+    assert(info != nullptr && cld != nullptr, \"must be\");\n@@ -464,1 +464,1 @@\n-    assert(_root != NULL, \"root node must exist\");\n+    assert(_root != nullptr, \"root node must exist\");\n@@ -466,1 +466,1 @@\n-    if (loader_oop == NULL) {\n+    if (loader_oop == nullptr) {\n@@ -473,1 +473,1 @@\n-    if (info == NULL) {\n+    if (info == nullptr) {\n@@ -478,1 +478,1 @@\n-      LoaderTreeNode* parent_info = NULL;\n+      LoaderTreeNode* parent_info = nullptr;\n@@ -482,1 +482,1 @@\n-      if (parent_oop == NULL) {\n+      if (parent_oop == nullptr) {\n@@ -487,1 +487,1 @@\n-      assert(parent_info != NULL, \"must be\");\n+      assert(parent_info != nullptr, \"must be\");\n@@ -497,2 +497,2 @@\n-    : _print_classes(print_classes), _verbose(verbose), _root(NULL) {\n-    _root = new LoaderTreeNode(NULL);\n+    : _print_classes(print_classes), _verbose(verbose), _root(nullptr) {\n+    _root = new LoaderTreeNode(nullptr);\n@@ -515,1 +515,1 @@\n-    assert(info != NULL, \"must be\");\n+    assert(info != nullptr, \"must be\");\n","filename":"src\/hotspot\/share\/classfile\/classLoaderHierarchyDCmd.cpp","additions":46,"deletions":46,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,1 +51,1 @@\n-                        \"monitor\", NULL};\n+                        \"monitor\", nullptr};\n","filename":"src\/hotspot\/share\/classfile\/classLoaderHierarchyDCmd.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -68,1 +68,1 @@\n-  if (cl != NULL) {\n+  if (cl != nullptr) {\n@@ -86,1 +86,1 @@\n-  if (ms != NULL) {\n+  if (ms != nullptr) {\n@@ -111,2 +111,2 @@\n-  Klass* class_loader_klass = (cls._class_loader == NULL ? NULL : cls._class_loader->klass());\n-  Klass* parent_klass = (cls._parent == NULL ? NULL : cls._parent->klass());\n+  Klass* class_loader_klass = (cls._class_loader == nullptr ? nullptr : cls._class_loader->klass());\n+  Klass* parent_klass = (cls._parent == nullptr ? nullptr : cls._parent->klass());\n@@ -118,1 +118,1 @@\n-  if (class_loader_klass != NULL) {\n+  if (class_loader_klass != nullptr) {\n@@ -149,1 +149,1 @@\n-  while (cl != NULL && java_lang_ClassLoader::loader_data_acquire(cl) == NULL) {\n+  while (cl != nullptr && java_lang_ClassLoader::loader_data_acquire(cl) == nullptr) {\n","filename":"src\/hotspot\/share\/classfile\/classLoaderStats.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -64,1 +64,1 @@\n-                        \"monitor\", NULL};\n+                        \"monitor\", nullptr};\n","filename":"src\/hotspot\/share\/classfile\/classLoaderStats.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -80,1 +80,1 @@\n-    return (pattern == NULL || sym->is_star_match(pattern));\n+    return (pattern == nullptr || sym->is_star_match(pattern));\n@@ -150,1 +150,1 @@\n-  KlassPrintClosure closure(class_name_pattern, NULL, NULL, true, flags, os);\n+  KlassPrintClosure closure(class_name_pattern, nullptr, nullptr, true, flags, os);\n@@ -161,1 +161,1 @@\n-  if (colon == NULL) {\n+  if (colon == nullptr) {\n@@ -163,1 +163,1 @@\n-    method_signature_pattern = NULL;\n+    method_signature_pattern = nullptr;\n","filename":"src\/hotspot\/share\/classfile\/classPrinter.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -59,2 +59,2 @@\n-  _compact_buckets = NULL;\n-  _compact_entries = NULL;\n+  _compact_buckets = nullptr;\n+  _compact_entries = nullptr;\n@@ -242,2 +242,2 @@\n-  _base = os::map_memory(_fd, filename, 0, NULL, _size, true, false);\n-  if (_base == NULL) {\n+  _base = os::map_memory(_fd, filename, 0, nullptr, _size, true, false);\n+  if (_base == nullptr) {\n","filename":"src\/hotspot\/share\/classfile\/compactHashtable.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -282,1 +282,1 @@\n-    return NULL;\n+    return nullptr;\n","filename":"src\/hotspot\/share\/classfile\/compactHashtable.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -87,1 +87,1 @@\n- *   void* new_node_data() { return NULL; }\n+ *   void* new_node_data() { return nullptr; }\n@@ -141,1 +141,1 @@\n-    assert(cls != NULL, \"Requires a valid instance class\");\n+    assert(cls != nullptr, \"Requires a valid instance class\");\n@@ -166,1 +166,1 @@\n-    return cls->super() != NULL && (!_visited_Object || !cls->is_interface());\n+    return cls->super() != nullptr && (!_visited_Object || !cls->is_interface());\n@@ -170,1 +170,1 @@\n-    return (i >= _path.length()) ? NULL : _path.at(_path.length() - i - 1);\n+    return (i >= _path.length()) ? nullptr : _path.at(_path.length() - i - 1);\n@@ -185,1 +185,1 @@\n-    return n == NULL ? NULL : n->_class;\n+    return n == nullptr ? nullptr : n->_class;\n@@ -191,1 +191,1 @@\n-    return n == NULL ? NULL : n->_algorithm_data;\n+    return n == nullptr ? nullptr : n->_algorithm_data;\n@@ -219,1 +219,1 @@\n-        InstanceKlass* next = NULL;\n+        InstanceKlass* next = nullptr;\n@@ -227,1 +227,1 @@\n-        assert(next != NULL, \"Otherwise we shouldn't be here\");\n+        assert(next != nullptr, \"Otherwise we shouldn't be here\");\n@@ -246,1 +246,1 @@\n-  void* new_node_data() { return NULL; }\n+  void* new_node_data() { return nullptr; }\n@@ -294,1 +294,1 @@\n-  void* new_node_data() { return NULL; }\n+  void* new_node_data() { return nullptr; }\n@@ -316,1 +316,1 @@\n-  MethodState() : _method(NULL), _state(DISQUALIFIED) {}\n+  MethodState() : _method(nullptr), _state(DISQUALIFIED) {}\n@@ -335,1 +335,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -350,1 +350,1 @@\n-      : _selected_target(NULL), _exception_message(NULL), _exception_name(NULL) {}\n+      : _selected_target(nullptr), _exception_message(nullptr), _exception_name(nullptr) {}\n@@ -353,1 +353,1 @@\n-    if (_selected_target == NULL && !m->is_overpass()) {\n+    if (_selected_target == nullptr && !m->is_overpass()) {\n@@ -363,1 +363,1 @@\n-    if (method_state == NULL) {\n+    if (method_state == nullptr) {\n@@ -370,2 +370,2 @@\n-  bool has_target() const { return _selected_target != NULL; }\n-  bool throws_exception() { return _exception_message != NULL; }\n+  bool has_target() const { return _selected_target != nullptr; }\n+  bool throws_exception() { return _exception_message != nullptr; }\n@@ -422,1 +422,1 @@\n-        assert(root != NULL, \"Null root class\");\n+        assert(root != nullptr, \"Null root class\");\n@@ -452,1 +452,1 @@\n-    assert(_exception_name != NULL, \"exception_name should be set\");\n+    assert(_exception_name != nullptr, \"exception_name should be set\");\n@@ -533,1 +533,1 @@\n-  StateRestorer() : _method(NULL), _state_to_restore(DISQUALIFIED) {}\n+  StateRestorer() : _method(nullptr), _state_to_restore(DISQUALIFIED) {}\n@@ -598,1 +598,1 @@\n-        _size_of_parameters(method->size_of_parameters()), _binding(NULL) {}\n+        _size_of_parameters(method->size_of_parameters()), _binding(nullptr) {}\n@@ -605,1 +605,1 @@\n-  bool is_bound() { return _binding != NULL; }\n+  bool is_bound() { return _binding != nullptr; }\n@@ -628,1 +628,1 @@\n-  assert(klass != NULL, \"Must be valid class\");\n+  assert(klass != nullptr, \"Must be valid class\");\n@@ -641,1 +641,1 @@\n-  while (super != NULL) {\n+  while (super != nullptr) {\n@@ -651,1 +651,1 @@\n-          if (impl == NULL || impl->is_overpass() || impl->is_static()) {\n+          if (impl == nullptr || impl->is_overpass() || impl->is_static()) {\n@@ -659,1 +659,1 @@\n-    if (super->default_methods() != NULL) {\n+    if (super->default_methods() != nullptr) {\n@@ -668,1 +668,1 @@\n-          if (impl == NULL || impl->is_overpass() || impl->is_static()) {\n+          if (impl == nullptr || impl->is_overpass() || impl->is_static()) {\n@@ -710,1 +710,1 @@\n-    _family = NULL;\n+    _family = nullptr;\n@@ -715,1 +715,1 @@\n-      if (_family != NULL) {\n+      if (_family != nullptr) {\n@@ -718,1 +718,1 @@\n-        *family = NULL;\n+        *family = nullptr;\n@@ -753,1 +753,1 @@\n-    if (m != NULL && !m->is_static() && !m->is_overpass() && !m->is_private() &&\n+    if (m != nullptr && !m->is_static() && !m->is_overpass() && !m->is_private() &&\n@@ -755,1 +755,1 @@\n-      if (_family == NULL) {\n+      if (_family == nullptr) {\n@@ -793,1 +793,1 @@\n-  if (family != NULL) {\n+  if (family != nullptr) {\n@@ -818,1 +818,1 @@\n-  assert(klass != NULL, \"invariant\");\n+  assert(klass != nullptr, \"invariant\");\n@@ -894,1 +894,1 @@\n-  if (bytecodes != NULL && bytecodes->length() > 0) {\n+  if (bytecodes != nullptr && bytecodes->length() > 0) {\n@@ -903,1 +903,1 @@\n-  m->set_constants(NULL); \/\/ This will get filled in later\n+  m->set_constants(nullptr); \/\/ This will get filled in later\n@@ -910,1 +910,1 @@\n-  m->constMethod()->set_stackmap_data(NULL);\n+  m->constMethod()->set_stackmap_data(nullptr);\n@@ -959,1 +959,1 @@\n-  BytecodeBuffer* buffer = NULL; \/\/ Lazily create a reusable buffer\n+  BytecodeBuffer* buffer = nullptr; \/\/ Lazily create a reusable buffer\n@@ -987,1 +987,1 @@\n-        if (buffer == NULL) {\n+        if (buffer == nullptr) {\n@@ -1001,1 +1001,1 @@\n-        if (m != NULL) {\n+        if (m != nullptr) {\n@@ -1026,1 +1026,1 @@\n-      klass->class_loader_data(), new_size, NULL, CHECK);\n+      klass->class_loader_data(), new_size, nullptr, CHECK);\n@@ -1079,1 +1079,1 @@\n-      klass->class_loader_data(), new_size, NULL, CHECK);\n+      klass->class_loader_data(), new_size, nullptr, CHECK);\n@@ -1095,2 +1095,2 @@\n-    Method* orig_method = NULL;\n-    Method* new_method = NULL;\n+    Method* orig_method = nullptr;\n+    Method* new_method = nullptr;\n@@ -1104,2 +1104,2 @@\n-    if (orig_method != NULL &&\n-        (new_method == NULL || orig_method->name() < new_method->name())) {\n+    if (orig_method != nullptr &&\n+        (new_method == nullptr || orig_method->name() < new_method->name())) {\n@@ -1107,1 +1107,1 @@\n-      original_methods->at_put(orig_idx, NULL);\n+      original_methods->at_put(orig_idx, nullptr);\n@@ -1109,1 +1109,1 @@\n-        assert(original_ordering != NULL && original_ordering->length() > 0,\n+        assert(original_ordering != nullptr && original_ordering->length() > 0,\n@@ -1147,1 +1147,1 @@\n-  if (original_ordering != NULL && original_ordering->length() > 0) {\n+  if (original_ordering != nullptr && original_ordering->length() > 0) {\n","filename":"src\/hotspot\/share\/classfile\/defaultMethods.cpp","additions":50,"deletions":50,"binary":false,"changes":100,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -93,1 +93,1 @@\n-  while (pd_set_acquire() != NULL) {\n+  while (pd_set_acquire() != nullptr) {\n@@ -113,1 +113,1 @@\n-  return protection_domain() == NULL || !java_lang_System::allow_security_manager()\n+  return protection_domain() == nullptr || !java_lang_System::allow_security_manager()\n@@ -136,1 +136,1 @@\n-                                current != NULL;\n+                                current != nullptr;\n@@ -156,1 +156,1 @@\n-                              current != NULL;\n+                              current != nullptr;\n@@ -243,1 +243,1 @@\n-  assert(obj != NULL, \"adding NULL obj\");\n+  assert(obj != nullptr, \"adding nullptr obj\");\n@@ -299,1 +299,1 @@\n-  if (entry != NULL && entry->is_valid_protection_domain(protection_domain)) {\n+  if (entry != nullptr && entry->is_valid_protection_domain(protection_domain)) {\n@@ -302,1 +302,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -310,1 +310,1 @@\n-  return (entry != NULL) ? entry->instance_klass() : NULL;\n+  return (entry != nullptr) ? entry->instance_klass() : nullptr;\n@@ -320,2 +320,2 @@\n-  assert(entry != NULL,\"entry must be present, we just created it\");\n-  assert(protection_domain() != NULL,\n+  assert(entry != nullptr,\"entry must be present, we just created it\");\n+  assert(protection_domain() != nullptr,\n@@ -347,2 +347,2 @@\n-  assert(class_loader() != NULL, \"Should not call this\");\n-  assert(protection_domain() != NULL, \"Should not call this\");\n+  assert(class_loader() != nullptr, \"Should not call this\");\n+  assert(protection_domain() != nullptr, \"Should not call this\");\n@@ -425,3 +425,3 @@\n-      ProtectionDomainEntry* prev = NULL;\n-      while (current != NULL) {\n-        if (current->object_no_keepalive() == NULL) {\n+      ProtectionDomainEntry* prev = nullptr;\n+      while (current != nullptr) {\n+        if (current->object_no_keepalive() == nullptr) {\n@@ -441,1 +441,1 @@\n-            assert(prev != NULL, \"should be set by alive entry\");\n+            assert(prev != nullptr, \"should be set by alive entry\");\n@@ -462,1 +462,1 @@\n-                              current != NULL;\n+                              current != nullptr;\n@@ -472,1 +472,1 @@\n-                              current != NULL;\n+                              current != nullptr;\n@@ -489,1 +489,1 @@\n-  assert(loader_data() != NULL, \"loader data should not be null\");\n+  assert(loader_data() != nullptr, \"loader data should not be null\");\n@@ -535,1 +535,1 @@\n-  guarantee(cld != NULL &&\n+  guarantee(cld != nullptr &&\n","filename":"src\/hotspot\/share\/classfile\/dictionary.cpp","additions":21,"deletions":21,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,2 +39,2 @@\n-  _next_block(NULL),\n-  _prev_block(NULL),\n+  _next_block(nullptr),\n+  _prev_block(nullptr),\n@@ -54,2 +54,2 @@\n- _next_block(NULL),\n- _prev_block(NULL),\n+ _next_block(nullptr),\n+ _prev_block(nullptr),\n@@ -77,3 +77,3 @@\n-  _next(NULL),\n-  _primitive_fields(NULL),\n-  _oop_fields(NULL),\n+  _next(nullptr),\n+  _primitive_fields(nullptr),\n+  _oop_fields(nullptr),\n@@ -86,1 +86,1 @@\n-  if (_primitive_fields == NULL) {\n+  if (_primitive_fields == nullptr) {\n@@ -95,1 +95,1 @@\n-  if (_oop_fields == NULL) {\n+  if (_oop_fields == nullptr) {\n@@ -103,1 +103,1 @@\n-  if (_primitive_fields != NULL) {\n+  if (_primitive_fields != nullptr) {\n@@ -111,1 +111,1 @@\n-  _blocks(NULL),\n+  _blocks(nullptr),\n@@ -131,1 +131,1 @@\n-  if (super_klass == NULL) {\n+  if (super_klass == nullptr) {\n@@ -164,2 +164,2 @@\n-  if (list == NULL) return;\n-  if (start == NULL) start = this->_start;\n+  if (list == nullptr) return;\n+  if (start == nullptr) start = this->_start;\n@@ -171,2 +171,2 @@\n-    LayoutRawBlock* cursor = NULL;\n-    LayoutRawBlock* candidate = NULL;\n+    LayoutRawBlock* cursor = nullptr;\n+    LayoutRawBlock* candidate = nullptr;\n@@ -189,1 +189,1 @@\n-      assert(cursor != NULL, \"Sanity check\");\n+      assert(cursor != nullptr, \"Sanity check\");\n@@ -193,1 +193,1 @@\n-          if (candidate == NULL || cursor->size() < candidate->size()) {\n+          if (candidate == nullptr || cursor->size() < candidate->size()) {\n@@ -199,1 +199,1 @@\n-      if (candidate == NULL) {\n+      if (candidate == nullptr) {\n@@ -203,1 +203,1 @@\n-      assert(candidate != NULL, \"Candidate must not be null\");\n+      assert(candidate != nullptr, \"Candidate must not be null\");\n@@ -214,1 +214,1 @@\n-  assert(block != NULL, \"Sanity check\");\n+  assert(block != nullptr, \"Sanity check\");\n@@ -216,1 +216,1 @@\n-  if (start == NULL) {\n+  if (start == nullptr) {\n@@ -220,1 +220,1 @@\n-  while (slot != NULL) {\n+  while (slot != nullptr) {\n@@ -246,2 +246,2 @@\n-  if (list == NULL) return;\n-  if (start == NULL) {\n+  if (list == nullptr) return;\n+  if (start == nullptr) {\n@@ -257,1 +257,1 @@\n-  LayoutRawBlock* candidate = NULL;\n+  LayoutRawBlock* candidate = nullptr;\n@@ -270,1 +270,1 @@\n-    assert(candidate != NULL, \"Candidate must not be null\");\n+    assert(candidate != nullptr, \"Candidate must not be null\");\n@@ -300,1 +300,1 @@\n-  while (ik != NULL) {\n+  while (ik != nullptr) {\n@@ -312,1 +312,1 @@\n-    ik = ik->super() == NULL ? NULL : InstanceKlass::cast(ik->super());\n+    ik = ik->super() == nullptr ? nullptr : InstanceKlass::cast(ik->super());\n@@ -337,1 +337,1 @@\n-  assert(_blocks != NULL, \"Sanity check\");\n+  assert(_blocks != nullptr, \"Sanity check\");\n@@ -341,1 +341,1 @@\n-  while (b->next_block() != NULL) {\n+  while (b->next_block() != nullptr) {\n@@ -353,1 +353,1 @@\n-  assert(b->next_block() == NULL, \"Invariant at this point\");\n+  assert(b->next_block() == nullptr, \"Invariant at this point\");\n@@ -400,1 +400,1 @@\n-  if (block->prev_block() != NULL) {\n+  if (block->prev_block() != nullptr) {\n@@ -410,1 +410,1 @@\n-  assert(block != NULL, \"Sanity check\");\n+  assert(block != nullptr, \"Sanity check\");\n@@ -414,2 +414,2 @@\n-    if (_blocks != NULL) {\n-      _blocks->set_prev_block(NULL);\n+    if (_blocks != nullptr) {\n+      _blocks->set_prev_block(nullptr);\n@@ -418,1 +418,1 @@\n-    assert(block->prev_block() != NULL, \"_prev should be set for non-head blocks\");\n+    assert(block->prev_block() != nullptr, \"_prev should be set for non-head blocks\");\n@@ -463,1 +463,1 @@\n-        assert(super != NULL, \"super klass must be provided to retrieve inherited fields info\");\n+        assert(super != nullptr, \"super klass must be provided to retrieve inherited fields info\");\n@@ -466,1 +466,1 @@\n-        while (!found && ik != NULL) {\n+        while (!found && ik != nullptr) {\n@@ -508,1 +508,1 @@\n-  _root_group(NULL),\n+  _root_group(nullptr),\n@@ -510,3 +510,3 @@\n-  _static_fields(NULL),\n-  _layout(NULL),\n-  _static_layout(NULL),\n+  _static_fields(nullptr),\n+  _layout(nullptr),\n+  _static_layout(nullptr),\n@@ -521,1 +521,1 @@\n-  FieldGroup* fg = NULL;\n+  FieldGroup* fg = nullptr;\n@@ -535,1 +535,1 @@\n-  if (super_klass != NULL) {\n+  if (super_klass != nullptr) {\n@@ -551,1 +551,1 @@\n-    FieldGroup* group = NULL;\n+    FieldGroup* group = nullptr;\n@@ -568,1 +568,1 @@\n-    assert(group != NULL, \"invariant\");\n+    assert(group != nullptr, \"invariant\");\n@@ -649,1 +649,1 @@\n-  int super_oop_map_count = (_super_klass == NULL) ? 0 :_super_klass->nonstatic_oop_map_count();\n+  int super_oop_map_count = (_super_klass == nullptr) ? 0 :_super_klass->nonstatic_oop_map_count();\n@@ -659,1 +659,1 @@\n-  if (_root_group->oop_fields() != NULL) {\n+  if (_root_group->oop_fields() != nullptr) {\n@@ -670,1 +670,1 @@\n-        assert(cg->oop_fields() != NULL && cg->oop_fields()->at(0) != NULL, \"oop_count > 0 but no oop fields found\");\n+        assert(cg->oop_fields() != nullptr && cg->oop_fields()->at(0) != nullptr, \"oop_count > 0 but no oop fields found\");\n@@ -698,1 +698,1 @@\n-    _static_layout->print(tty, true, NULL);\n+    _static_layout->print(tty, true, nullptr);\n","filename":"src\/hotspot\/share\/classfile\/fieldLayoutBuilder.cpp","additions":52,"deletions":52,"binary":false,"changes":104,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -191,3 +191,3 @@\n-  void add(GrowableArray<LayoutRawBlock*>* list, LayoutRawBlock* start = NULL);\n-  void add_field_at_offset(LayoutRawBlock* blocks, int offset, LayoutRawBlock* start = NULL);\n-  void add_contiguously(GrowableArray<LayoutRawBlock*>* list, LayoutRawBlock* start = NULL);\n+  void add(GrowableArray<LayoutRawBlock*>* list, LayoutRawBlock* start = nullptr);\n+  void add_field_at_offset(LayoutRawBlock* blocks, int offset, LayoutRawBlock* start = nullptr);\n+  void add_contiguously(GrowableArray<LayoutRawBlock*>* list, LayoutRawBlock* start = nullptr);\n","filename":"src\/hotspot\/share\/classfile\/fieldLayoutBuilder.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -127,1 +127,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -147,1 +147,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -158,1 +158,1 @@\n-  if (ik == NULL) {\n+  if (ik == nullptr) {\n@@ -184,1 +184,1 @@\n-  if (name == NULL) {\n+  if (name == nullptr) {\n@@ -252,1 +252,1 @@\n-      assert(mirror != NULL, \"String must have mirror already\");\n+      assert(mirror != nullptr, \"String must have mirror already\");\n@@ -321,1 +321,1 @@\n-  if (utf8_str == NULL) {\n+  if (utf8_str == nullptr) {\n@@ -403,1 +403,1 @@\n-  assert(str != NULL, \"bad arguments\");\n+  assert(str != nullptr, \"bad arguments\");\n@@ -406,1 +406,1 @@\n-  static to_java_string_fn_t _to_java_string_fn = NULL;\n+  static to_java_string_fn_t _to_java_string_fn = nullptr;\n@@ -408,1 +408,1 @@\n-  if (_to_java_string_fn == NULL) {\n+  if (_to_java_string_fn == nullptr) {\n@@ -412,1 +412,1 @@\n-    if (_to_java_string_fn == NULL) {\n+    if (_to_java_string_fn == nullptr) {\n@@ -417,1 +417,1 @@\n-    if (_to_java_string_fn == NULL) {\n+    if (_to_java_string_fn == nullptr) {\n@@ -422,1 +422,1 @@\n-  jstring js = NULL;\n+  jstring js = nullptr;\n@@ -439,1 +439,1 @@\n-  static to_platform_string_fn_t _to_platform_string_fn = NULL;\n+  static to_platform_string_fn_t _to_platform_string_fn = nullptr;\n@@ -441,1 +441,1 @@\n-  if (_to_platform_string_fn == NULL) {\n+  if (_to_platform_string_fn == nullptr) {\n@@ -444,1 +444,1 @@\n-    if (_to_platform_string_fn == NULL) {\n+    if (_to_platform_string_fn == nullptr) {\n@@ -474,1 +474,1 @@\n-  if (result == NULL) {\n+  if (result == nullptr) {\n@@ -486,1 +486,1 @@\n-  if (result != NULL) {\n+  if (result != nullptr) {\n@@ -551,1 +551,1 @@\n-  if (length == 0) return NULL;\n+  if (length == 0) return nullptr;\n@@ -576,1 +576,1 @@\n-    jchar* base = (length == 0) ? NULL : value->char_at_addr(0);\n+    jchar* base = (length == 0) ? nullptr : value->char_at_addr(0);\n@@ -581,1 +581,1 @@\n-    jbyte* position = (length == 0) ? NULL : value->byte_at_addr(0);\n+    jbyte* position = (length == 0) ? nullptr : value->byte_at_addr(0);\n@@ -593,1 +593,1 @@\n-    jchar* base = (length == 0) ? NULL : value->char_at_addr(0);\n+    jchar* base = (length == 0) ? nullptr : value->char_at_addr(0);\n@@ -597,1 +597,1 @@\n-    jbyte* position = (length == 0) ? NULL : value->byte_at_addr(0);\n+    jbyte* position = (length == 0) ? nullptr : value->byte_at_addr(0);\n@@ -632,1 +632,1 @@\n-    jchar* position = (length == 0) ? NULL : value->char_at_addr(0);\n+    jchar* position = (length == 0) ? nullptr : value->char_at_addr(0);\n@@ -635,1 +635,1 @@\n-    jbyte* position = (length == 0) ? NULL : value->byte_at_addr(0);\n+    jbyte* position = (length == 0) ? nullptr : value->byte_at_addr(0);\n@@ -647,1 +647,1 @@\n-    jchar *position = (len == 0) ? NULL : value->char_at_addr(0);\n+    jchar *position = (len == 0) ? nullptr : value->char_at_addr(0);\n@@ -654,1 +654,1 @@\n-    jbyte *position = (len == 0) ? NULL : value->byte_at_addr(0);\n+    jbyte *position = (len == 0) ? nullptr : value->byte_at_addr(0);\n@@ -669,1 +669,1 @@\n-    jchar* position = (length == 0) ? NULL : value->char_at_addr(0);\n+    jchar* position = (length == 0) ? nullptr : value->char_at_addr(0);\n@@ -672,1 +672,1 @@\n-    jbyte* position = (length == 0) ? NULL : value->byte_at_addr(0);\n+    jbyte* position = (length == 0) ? nullptr : value->byte_at_addr(0);\n@@ -755,1 +755,1 @@\n-  if (value == NULL) {\n+  if (value == nullptr) {\n@@ -758,1 +758,1 @@\n-    st->print(\"NULL\");\n+    st->print(\"nullptr\");\n@@ -790,2 +790,2 @@\n-GrowableArray<Klass*>* java_lang_Class::_fixup_mirror_list = NULL;\n-GrowableArray<Klass*>* java_lang_Class::_fixup_module_field_list = NULL;\n+GrowableArray<Klass*>* java_lang_Class::_fixup_mirror_list = nullptr;\n+GrowableArray<Klass*>* java_lang_Class::_fixup_module_field_list = nullptr;\n@@ -904,1 +904,1 @@\n-    \/\/ During startup, the module may be NULL only if java.base has not been defined yet.\n+    \/\/ During startup, the module may be null only if java.base has not been defined yet.\n@@ -906,1 +906,1 @@\n-    \/\/ for java.base is known. But note that since we captured the NULL module another\n+    \/\/ for java.base is known. But note that since we captured the null module another\n@@ -914,1 +914,1 @@\n-        assert(k->java_mirror() != NULL, \"Class's mirror is null\");\n+        assert(k->java_mirror() != nullptr, \"Class's mirror is null\");\n@@ -916,1 +916,1 @@\n-        assert(fixup_module_field_list() != NULL, \"fixup_module_field_list not initialized\");\n+        assert(fixup_module_field_list() != nullptr, \"fixup_module_field_list not initialized\");\n@@ -926,1 +926,1 @@\n-      assert(javabase_entry != NULL && javabase_entry->module() != NULL,\n+      assert(javabase_entry != nullptr && javabase_entry->module() != nullptr,\n@@ -977,1 +977,1 @@\n-      assert(element_klass != NULL, \"Must have an element klass\");\n+      assert(element_klass != nullptr, \"Must have an element klass\");\n@@ -984,1 +984,1 @@\n-    assert(comp_mirror() != NULL, \"must have a mirror\");\n+    assert(comp_mirror() != nullptr, \"must have a mirror\");\n@@ -1000,1 +1000,1 @@\n-      set_klass(mirror(), NULL);\n+      set_klass(mirror(), nullptr);\n@@ -1009,2 +1009,2 @@\n-  assert(k != NULL, \"Use create_basic_type_mirror for primitive types\");\n-  assert(k->java_mirror() == NULL, \"should only assign mirror once\");\n+  assert(k != nullptr, \"Use create_basic_type_mirror for primitive types\");\n+  assert(k->java_mirror() == nullptr, \"should only assign mirror once\");\n@@ -1038,1 +1038,1 @@\n-    if (comp_mirror() != NULL) {\n+    if (comp_mirror() != nullptr) {\n@@ -1047,1 +1047,1 @@\n-    assert(fixup_mirror_list() != NULL, \"fixup_mirror_list not initialized\");\n+    assert(fixup_mirror_list() != nullptr, \"fixup_mirror_list not initialized\");\n@@ -1065,1 +1065,1 @@\n-  if (k->class_loader() != NULL &&\n+  if (k->class_loader() != nullptr &&\n@@ -1072,1 +1072,1 @@\n-  Handle protection_domain, classData; \/\/ set to NULL. Will be reinitialized at runtime\n+  Handle protection_domain, classData; \/\/ set to null. Will be reinitialized at runtime\n@@ -1077,1 +1077,1 @@\n-  if (comp_mirror() != NULL) {\n+  if (comp_mirror() != nullptr) {\n@@ -1093,1 +1093,1 @@\n-    assert(fixup_mirror_list() != NULL, \"fixup_mirror_list not initialized\");\n+    assert(fixup_mirror_list() != nullptr, \"fixup_mirror_list not initialized\");\n@@ -1099,1 +1099,1 @@\n-  assert(m != NULL, \"must have stored non-null archived mirror\");\n+  assert(m != nullptr, \"must have stored non-null archived mirror\");\n@@ -1220,1 +1220,1 @@\n-  if (o == NULL) {\n+  if (o == nullptr) {\n@@ -1240,1 +1240,1 @@\n-  oop java_class = InstanceMirrorKlass::cast(vmClasses::Class_klass())->allocate_instance(NULL, CHECK_NULL);\n+  oop java_class = InstanceMirrorKlass::cast(vmClasses::Class_klass())->allocate_instance(nullptr, CHECK_NULL);\n@@ -1243,1 +1243,1 @@\n-    assert(aklass != NULL, \"correct bootstrap\");\n+    assert(aklass != nullptr, \"correct bootstrap\");\n@@ -1261,1 +1261,1 @@\n-  Symbol* name = NULL;\n+  Symbol* name = nullptr;\n@@ -1270,1 +1270,1 @@\n-  if (name == NULL) {\n+  if (name == nullptr) {\n@@ -1312,1 +1312,1 @@\n-  const char* name = NULL;\n+  const char* name = nullptr;\n@@ -1318,1 +1318,1 @@\n-  if (name == NULL) {\n+  if (name == nullptr) {\n@@ -1326,1 +1326,1 @@\n-  assert(k == NULL || k->is_klass() && k->is_array_klass(), \"should be array klass\");\n+  assert(k == nullptr || k->is_klass() && k->is_array_klass(), \"should be array klass\");\n@@ -1341,1 +1341,1 @@\n-  if (ak != NULL) {\n+  if (ak != nullptr) {\n@@ -1354,2 +1354,2 @@\n-    if (reference_klass != NULL)\n-      (*reference_klass) = NULL;\n+    if (reference_klass != nullptr)\n+      (*reference_klass) = nullptr;\n@@ -1358,1 +1358,1 @@\n-    if (reference_klass != NULL)\n+    if (reference_klass != nullptr)\n@@ -1367,1 +1367,1 @@\n-  assert(mirror != NULL && mirror->is_a(vmClasses::Class_klass()), \"must be a Class\");\n+  assert(mirror != nullptr && mirror->is_a(vmClasses::Class_klass()), \"must be a Class\");\n@@ -1570,2 +1570,2 @@\n-  assert(java_thread != NULL, \"need a java_lang_Thread pointer here\");\n-  java_thread->obj_field_put(_scopedValueBindings_offset, NULL);\n+  assert(java_thread != nullptr, \"need a java_lang_Thread pointer here\");\n+  java_thread->obj_field_put(_scopedValueBindings_offset, nullptr);\n@@ -1609,1 +1609,1 @@\n-  assert(holder != NULL, \"Java Thread not initialized\");\n+  assert(holder != nullptr, \"Java Thread not initialized\");\n@@ -1616,1 +1616,1 @@\n-  assert(holder != NULL, \"Java Thread not initialized\");\n+  assert(holder != nullptr, \"Java Thread not initialized\");\n@@ -1623,1 +1623,1 @@\n-  assert(holder != NULL, \"Java Thread not initialized\");\n+  assert(holder != nullptr, \"Java Thread not initialized\");\n@@ -1630,1 +1630,1 @@\n-  return (thr != NULL);\n+  return (thr != nullptr);\n@@ -1636,1 +1636,1 @@\n-  assert(holder != NULL, \"Java Thread not initialized\");\n+  assert(holder != nullptr, \"Java Thread not initialized\");\n@@ -1643,1 +1643,1 @@\n-  assert(holder != NULL, \"Java Thread not initialized\");\n+  assert(holder != nullptr, \"Java Thread not initialized\");\n@@ -1658,1 +1658,1 @@\n-  assert(holder != NULL, \"Java Thread not initialized\");\n+  assert(holder != nullptr, \"Java Thread not initialized\");\n@@ -1665,1 +1665,1 @@\n-  assert(holder != NULL, \"Java Thread not initialized\");\n+  assert(holder != nullptr, \"Java Thread not initialized\");\n@@ -1677,1 +1677,1 @@\n-  if (holder == NULL) {\n+  if (holder == nullptr) {\n@@ -1698,2 +1698,2 @@\n-    if (carrier_thread == NULL) {\n-      return NULL;\n+    if (carrier_thread == nullptr) {\n+      return nullptr;\n@@ -1705,2 +1705,2 @@\n-  if (thread == NULL) {\n-    return NULL;\n+  if (thread == nullptr) {\n+    return nullptr;\n@@ -1754,1 +1754,1 @@\n-        carrier = (thread->vthread_continuation() != NULL);\n+        carrier = (thread->vthread_continuation() != nullptr);\n@@ -1794,1 +1794,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1799,1 +1799,1 @@\n-  assert(k != NULL, \"must be loaded in 1.4+\");\n+  assert(k != nullptr, \"must be loaded in 1.4+\");\n@@ -1818,1 +1818,1 @@\n-  assert(holder != NULL, \"Java Thread not initialized\");\n+  assert(holder != nullptr, \"Java Thread not initialized\");\n@@ -1848,1 +1848,1 @@\n-  if (name != NULL) {\n+  if (name != nullptr) {\n@@ -1851,1 +1851,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1915,1 +1915,1 @@\n-  return obj != NULL && is_subclass(obj->klass());\n+  return obj != nullptr && is_subclass(obj->klass());\n@@ -2034,1 +2034,1 @@\n-\/\/ Return Symbol for detailed_message or NULL\n+\/\/ Return Symbol for detailed_message or null\n@@ -2038,1 +2038,1 @@\n-  if (detailed_message != NULL) {\n+  if (detailed_message != nullptr) {\n@@ -2041,1 +2041,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -2054,1 +2054,1 @@\n-  set_stacktrace(throwable, NULL);\n+  set_stacktrace(throwable, nullptr);\n@@ -2061,1 +2061,1 @@\n-  assert(k != NULL, \"just checking\");\n+  assert(k != nullptr, \"just checking\");\n@@ -2064,1 +2064,1 @@\n-  if (msg != NULL) {\n+  if (msg != nullptr) {\n@@ -2074,1 +2074,1 @@\n-  return method != NULL && (method->constants()->version() == version);\n+  return method != nullptr && (method->constants()->version() == version);\n@@ -2111,1 +2111,1 @@\n-    assert(methods != NULL, \"method array should be initialized in backtrace\");\n+    assert(methods != nullptr, \"method array should be initialized in backtrace\");\n@@ -2116,1 +2116,1 @@\n-    assert(bcis != NULL, \"bci array should be initialized in backtrace\");\n+    assert(bcis != nullptr, \"bci array should be initialized in backtrace\");\n@@ -2121,1 +2121,1 @@\n-    assert(mirrors != NULL, \"mirror array should be initialized in backtrace\");\n+    assert(mirrors != nullptr, \"mirror array should be initialized in backtrace\");\n@@ -2126,1 +2126,1 @@\n-    assert(names != NULL, \"names array should be initialized in backtrace\");\n+    assert(names != nullptr, \"names array should be initialized in backtrace\");\n@@ -2131,1 +2131,1 @@\n-    return hidden != NULL;\n+    return hidden != nullptr;\n@@ -2137,1 +2137,1 @@\n-  BacktraceBuilder(TRAPS): _head(NULL), _methods(NULL), _bcis(NULL), _mirrors(NULL), _names(NULL), _has_hidden_top_frame(false) {\n+  BacktraceBuilder(TRAPS): _head(nullptr), _methods(nullptr), _bcis(nullptr), _mirrors(nullptr), _names(nullptr), _has_hidden_top_frame(false) {\n@@ -2186,1 +2186,1 @@\n-    new_head->obj_at_put(trace_hidden_offset, NULL);\n+    new_head->obj_at_put(trace_hidden_offset, nullptr);\n@@ -2222,1 +2222,1 @@\n-    assert(method->method_holder()->java_mirror() != NULL, \"never push null for mirror\");\n+    assert(method->method_holder()->java_mirror() != nullptr, \"never push null for mirror\");\n@@ -2235,1 +2235,1 @@\n-      assert(_methods != NULL, \"we need a legal oop\");\n+      assert(_methods != nullptr, \"we need a legal oop\");\n@@ -2295,1 +2295,1 @@\n-    return _result.not_null() && _mirrors->obj_at(_index) != NULL;\n+    return _result.not_null() && _mirrors->obj_at(_index) != nullptr;\n@@ -2313,1 +2313,1 @@\n-  char* source_file_name = NULL;\n+  char* source_file_name = nullptr;\n@@ -2315,1 +2315,1 @@\n-  if (source != NULL) {\n+  if (source != nullptr) {\n@@ -2320,1 +2320,1 @@\n-  char *module_name = NULL, *module_version = NULL;\n+  char *module_name = nullptr, *module_version = nullptr;\n@@ -2325,1 +2325,1 @@\n-    if (module->version() != NULL) {\n+    if (module->version() != nullptr) {\n@@ -2339,2 +2339,2 @@\n-  if (module_name != NULL) {\n-    if (module_version != NULL) {\n+  if (module_name != nullptr) {\n+    if (module_version != nullptr) {\n@@ -2347,1 +2347,1 @@\n-  \/\/ The method can be NULL if the requested class version is gone\n+  \/\/ The method can be null if the requested class version is gone\n@@ -2356,1 +2356,1 @@\n-      if (source_file_name != NULL && (line_number != -1)) {\n+      if (source_file_name != nullptr && (line_number != -1)) {\n@@ -2359,1 +2359,1 @@\n-      } else if (source_file_name != NULL) {\n+      } else if (source_file_name != nullptr) {\n@@ -2367,1 +2367,1 @@\n-      if (WizardMode && nm != NULL) {\n+      if (WizardMode && nm != nullptr) {\n@@ -2452,1 +2452,1 @@\n-  set_backtrace(throwable(), NULL);\n+  set_backtrace(throwable(), nullptr);\n@@ -2465,1 +2465,1 @@\n-    if (max_depth >= 1 && method() != NULL) {\n+    if (max_depth >= 1 && method() != nullptr) {\n@@ -2489,1 +2489,1 @@\n-  CompiledMethod* nm = NULL;\n+  CompiledMethod* nm = nullptr;\n@@ -2496,1 +2496,1 @@\n-    Method* method = NULL;\n+    Method* method = nullptr;\n@@ -2530,1 +2530,1 @@\n-        \/\/ HMMM QQQ might be nice to have frame return nm as NULL if cb is non-NULL\n+        \/\/ HMMM QQQ might be nice to have frame return nm as null if cb is non-null\n@@ -2533,1 +2533,1 @@\n-        if (cb == NULL || !cb->is_compiled()) {\n+        if (cb == nullptr || !cb->is_compiled()) {\n@@ -2537,1 +2537,1 @@\n-        assert(nm->method() != NULL, \"must be\");\n+        assert(nm->method() != nullptr, \"must be\");\n@@ -2670,1 +2670,1 @@\n-  assert(java_lang_Throwable::unassigned_stacktrace() != NULL, \"not initialized\");\n+  assert(java_lang_Throwable::unassigned_stacktrace() != nullptr, \"not initialized\");\n@@ -2735,1 +2735,1 @@\n-  if (message == NULL) {\n+  if (message == nullptr) {\n@@ -2752,1 +2752,1 @@\n-  set_backtrace(h_cause(), NULL);\n+  set_backtrace(h_cause(), nullptr);\n@@ -2766,1 +2766,1 @@\n-  if (hidden != NULL) {\n+  if (hidden != nullptr) {\n@@ -2774,1 +2774,1 @@\n-  assert(holder != NULL, \"first element should be non-null\");\n+  assert(holder != nullptr, \"first element should be non-null\");\n@@ -2778,1 +2778,1 @@\n-  if (m == NULL || !version_matches(m, bte._version)) {\n+  if (m == nullptr || !version_matches(m, bte._version)) {\n@@ -2790,1 +2790,1 @@\n-  assert(k != NULL, \"must be loaded in 1.4+\");\n+  assert(k != nullptr, \"must be loaded in 1.4+\");\n@@ -2817,1 +2817,1 @@\n-  if (loader != NULL) {\n+  if (loader != nullptr) {\n@@ -2819,1 +2819,1 @@\n-    if (loader_name != NULL)\n+    if (loader_name != nullptr)\n@@ -2833,1 +2833,1 @@\n-    if (module->version() != NULL) {\n+    if (module->version() != nullptr) {\n@@ -2836,1 +2836,1 @@\n-      module_version = NULL;\n+      module_version = nullptr;\n@@ -2841,1 +2841,1 @@\n-  if (method() == NULL || !version_matches(method(), version)) {\n+  if (method() == nullptr || !version_matches(method(), version)) {\n@@ -2843,1 +2843,1 @@\n-    java_lang_StackTraceElement::set_fileName(element(), NULL);\n+    java_lang_StackTraceElement::set_fileName(element(), nullptr);\n@@ -2867,1 +2867,1 @@\n-  if (source != NULL) {\n+  if (source != nullptr) {\n@@ -2870,1 +2870,1 @@\n-    if (source_file == NULL) {\n+    if (source_file == nullptr) {\n@@ -2876,2 +2876,2 @@\n-    if (source_file != NULL) {\n-      source_file = NULL;\n+    if (source_file != nullptr) {\n+      source_file = nullptr;\n@@ -2890,1 +2890,1 @@\n-  filename = NULL;\n+  filename = nullptr;\n@@ -2950,1 +2950,1 @@\n-  oop contScope = cont_h() != NULL ? jdk_internal_vm_Continuation::scope(cont_h()) : (oop)NULL;\n+  oop contScope = cont_h() != nullptr ? jdk_internal_vm_Continuation::scope(cont_h()) : (oop)nullptr;\n@@ -3333,1 +3333,1 @@\n-  assert(ik != NULL, \"must be loaded\");\n+  assert(ik != nullptr, \"must be loaded\");\n@@ -3350,1 +3350,1 @@\n-  Method* accessor_method = NULL;\n+  Method* accessor_method = nullptr;\n@@ -3361,1 +3361,1 @@\n-  if (accessor_method != NULL) {\n+  if (accessor_method != nullptr) {\n@@ -3366,1 +3366,1 @@\n-    java_lang_reflect_RecordComponent::set_accessor(element(), NULL);\n+    java_lang_reflect_RecordComponent::set_accessor(element(), nullptr);\n@@ -3375,1 +3375,1 @@\n-    java_lang_reflect_RecordComponent::set_signature(element(), NULL);\n+    java_lang_reflect_RecordComponent::set_signature(element(), nullptr);\n@@ -3516,1 +3516,1 @@\n-  assert(module != NULL, \"module can't be null\");\n+  assert(module != nullptr, \"module can't be null\");\n@@ -3525,1 +3525,1 @@\n-  if (module_entry == NULL) {\n+  if (module_entry == nullptr) {\n@@ -3538,1 +3538,1 @@\n-  assert(module != NULL, \"module can't be null\");\n+  assert(module != nullptr, \"module can't be null\");\n@@ -3620,1 +3620,1 @@\n-  assert(obj != NULL, \"sanity\");\n+  assert(obj != nullptr, \"sanity\");\n@@ -3657,1 +3657,1 @@\n-  if (k == NULL)  return NULL;\n+  if (k == nullptr)  return nullptr;\n@@ -3668,1 +3668,1 @@\n-  if (box == NULL)  return NULL;\n+  if (box == nullptr)  return nullptr;\n@@ -3695,1 +3695,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -3702,1 +3702,1 @@\n-  if (box == NULL)  return T_ILLEGAL;\n+  if (box == nullptr)  return T_ILLEGAL;\n@@ -3835,1 +3835,1 @@\n-  oop member_name = NULL;\n+  oop member_name = nullptr;\n@@ -3909,1 +3909,1 @@\n-  assert(k != NULL, \"jdk mismatch\");\n+  assert(k != nullptr, \"jdk mismatch\");\n@@ -3924,1 +3924,1 @@\n-  assert (k != NULL, \"jdk mismatch\");\n+  assert (k != nullptr, \"jdk mismatch\");\n@@ -3935,1 +3935,1 @@\n-  return obj != NULL && is_subclass(obj->klass());\n+  return obj != nullptr && is_subclass(obj->klass());\n@@ -3946,1 +3946,1 @@\n-  return obj != NULL && is_subclass(obj->klass());\n+  return obj != nullptr && is_subclass(obj->klass());\n@@ -3986,1 +3986,1 @@\n-  return obj != NULL && is_subclass(obj->klass());\n+  return obj != nullptr && is_subclass(obj->klass());\n@@ -4040,1 +4040,1 @@\n-  return obj != NULL && is_subclass(obj->klass());\n+  return obj != nullptr && is_subclass(obj->klass());\n@@ -4078,1 +4078,1 @@\n-  return obj != NULL && is_subclass(obj->klass());\n+  return obj != nullptr && is_subclass(obj->klass());\n@@ -4165,1 +4165,1 @@\n-  return method == NULL ? NULL : java_lang_invoke_ResolvedMethodName::vmtarget(method);\n+  return method == nullptr ? nullptr : java_lang_invoke_ResolvedMethodName::vmtarget(method);\n@@ -4212,1 +4212,1 @@\n-  if (resolved_method != NULL) {\n+  if (resolved_method != nullptr) {\n@@ -4275,1 +4275,1 @@\n-  if (pts != NULL) {\n+  if (pts != nullptr) {\n@@ -4280,1 +4280,1 @@\n-    st->print(\"NULL\");\n+    st->print(\"nullptr\");\n@@ -4284,1 +4284,1 @@\n-  if (rt != NULL) {\n+  if (rt != nullptr) {\n@@ -4287,1 +4287,1 @@\n-    st->print(\"NULL\");\n+    st->print(\"nullptr\");\n@@ -4475,1 +4475,1 @@\n-  assert(loader != NULL, \"loader must not be NULL\");\n+  assert(loader != nullptr, \"loader must not be nullptr\");\n@@ -4481,1 +4481,1 @@\n-  assert(loader != NULL, \"loader must not be NULL\");\n+  assert(loader != nullptr, \"loader must not be nullptr\");\n@@ -4487,1 +4487,1 @@\n-  assert(loader != NULL, \"loader must not be NULL\");\n+  assert(loader != nullptr, \"loader must not be nullptr\");\n@@ -4543,1 +4543,1 @@\n-  assert(cl == NULL || is_instance(cl), \"cl argument must be oop\");\n+  assert(cl == nullptr || is_instance(cl), \"cl argument must be oop\");\n@@ -4553,1 +4553,1 @@\n-  } while (acl != NULL);\n+  } while (acl != nullptr);\n@@ -4558,1 +4558,1 @@\n-  return obj != NULL && is_subclass(obj->klass());\n+  return obj != nullptr && is_subclass(obj->klass());\n@@ -4567,1 +4567,1 @@\n-  return (class_loader->obj_field(_parallelCapable_offset) != NULL);\n+  return (class_loader->obj_field(_parallelCapable_offset) != nullptr);\n@@ -4575,1 +4575,1 @@\n-  while(cl != NULL) {\n+  while(cl != nullptr) {\n@@ -4585,1 +4585,1 @@\n-  if (loader != NULL) {\n+  if (loader != nullptr) {\n@@ -4588,1 +4588,1 @@\n-    return (delegating_cl_class != NULL && loader->is_a(delegating_cl_class));\n+    return (delegating_cl_class != nullptr && loader->is_a(delegating_cl_class));\n@@ -4649,1 +4649,1 @@\n-  return base->obj_field(_static_security_offset) != NULL;\n+  return base->obj_field(_static_security_offset) != nullptr;\n@@ -4679,1 +4679,1 @@\n-    assert(mirror != NULL, \"UnsafeConstants must have mirror already\");\n+    assert(mirror != nullptr, \"UnsafeConstants must have mirror already\");\n@@ -4860,1 +4860,1 @@\n-  return obj != NULL && is_subclass(obj->klass());\n+  return obj != nullptr && is_subclass(obj->klass());\n@@ -4873,1 +4873,1 @@\n-  guarantee(k != NULL && k->is_initialized(), \"must be loaded and initialized\");\n+  guarantee(k != nullptr && k->is_initialized(), \"must be loaded and initialized\");\n@@ -4903,1 +4903,1 @@\n-  guarantee(k != NULL && k->is_initialized(), \"must be loaded and initialized\");\n+  guarantee(k != nullptr && k->is_initialized(), \"must be loaded and initialized\");\n@@ -4933,1 +4933,1 @@\n-  guarantee(k != NULL && k->is_initialized(), \"must be loaded and initialized\");\n+  guarantee(k != nullptr && k->is_initialized(), \"must be loaded and initialized\");\n@@ -4963,1 +4963,1 @@\n-  guarantee(k != NULL && k->is_initialized(), \"must be loaded and initialized\");\n+  guarantee(k != nullptr && k->is_initialized(), \"must be loaded and initialized\");\n@@ -4993,1 +4993,1 @@\n-  guarantee(k != NULL && k->is_initialized(), \"must be loaded and initialized\");\n+  guarantee(k != nullptr && k->is_initialized(), \"must be loaded and initialized\");\n@@ -5028,1 +5028,1 @@\n-  guarantee(k != NULL && k->is_initialized(), \"must be loaded and initialized\");\n+  guarantee(k != nullptr && k->is_initialized(), \"must be loaded and initialized\");\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":183,"deletions":183,"binary":false,"changes":366,"status":"modified"},{"patch":"@@ -271,1 +271,1 @@\n-  static BasicType as_BasicType(oop java_class, Klass** reference_klass = NULL);\n+  static BasicType as_BasicType(oop java_class, Klass** reference_klass = nullptr);\n@@ -914,1 +914,1 @@\n-  \/\/ Allocation. Returns a boxed value, or NULL for invalid type.\n+  \/\/ Allocation. Returns a boxed value, or null for invalid type.\n@@ -1075,1 +1075,1 @@\n-    return vmClasses::LambdaForm_klass() != NULL &&\n+    return vmClasses::LambdaForm_klass() != nullptr &&\n@@ -1105,1 +1105,1 @@\n-    return vmClasses::NativeEntryPoint_klass() != NULL &&\n+    return vmClasses::NativeEntryPoint_klass() != nullptr &&\n@@ -1143,1 +1143,1 @@\n-    return vmClasses::ABIDescriptor_klass() != NULL &&\n+    return vmClasses::ABIDescriptor_klass() != nullptr &&\n@@ -1171,1 +1171,1 @@\n-    return vmClasses::VMStorage_klass() != NULL &&\n+    return vmClasses::VMStorage_klass() != nullptr &&\n@@ -1195,1 +1195,1 @@\n-    return vmClasses::CallConv_klass() != NULL &&\n+    return vmClasses::CallConv_klass() != nullptr &&\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -111,1 +111,1 @@\n-  if (value == NULL) {\n+  if (value == nullptr) {\n@@ -130,1 +130,1 @@\n-  return obj != NULL && obj->klass() == vmClasses::String_klass();\n+  return obj != nullptr && obj->klass() == vmClasses::String_klass();\n@@ -251,1 +251,1 @@\n-  return obj != NULL && is_subclass(obj->klass());\n+  return obj != nullptr && is_subclass(obj->klass());\n@@ -259,1 +259,1 @@\n-  return obj != NULL && is_subclass(obj->klass());\n+  return obj != nullptr && is_subclass(obj->klass());\n@@ -263,1 +263,1 @@\n-  return obj != NULL && is_subclass(obj->klass());\n+  return obj != nullptr && is_subclass(obj->klass());\n@@ -267,1 +267,1 @@\n-  return obj != NULL && obj->klass() == vmClasses::MemberName_klass();\n+  return obj != nullptr && obj->klass() == vmClasses::MemberName_klass();\n@@ -271,1 +271,1 @@\n-  return obj != NULL && obj->klass() == vmClasses::ResolvedMethodName_klass();\n+  return obj != nullptr && obj->klass() == vmClasses::ResolvedMethodName_klass();\n@@ -275,1 +275,1 @@\n-  return obj != NULL && obj->klass() == vmClasses::MethodType_klass();\n+  return obj != nullptr && obj->klass() == vmClasses::MethodType_klass();\n@@ -279,1 +279,1 @@\n-  return obj != NULL && is_subclass(obj->klass());\n+  return obj != nullptr && is_subclass(obj->klass());\n@@ -283,1 +283,1 @@\n-  return obj != NULL && obj->klass() == vmClasses::Class_klass();\n+  return obj != nullptr && obj->klass() == vmClasses::Class_klass();\n@@ -290,1 +290,1 @@\n-  assert(k == NULL || k->is_klass(), \"type check\");\n+  assert(k == nullptr || k->is_klass(), \"type check\");\n@@ -297,1 +297,1 @@\n-  bool is_primitive = (java_class->metadata_field(_klass_offset) == NULL);\n+  bool is_primitive = (java_class->metadata_field(_klass_offset) == nullptr);\n@@ -302,1 +302,1 @@\n-    assert(k == NULL || is_java_primitive(ArrayKlass::cast(k)->element_type()),\n+    assert(k == nullptr || is_java_primitive(ArrayKlass::cast(k)->element_type()),\n@@ -318,1 +318,1 @@\n-  return obj != NULL && is_subclass(obj->klass());\n+  return obj != nullptr && is_subclass(obj->klass());\n@@ -322,1 +322,1 @@\n-  return obj != NULL && obj->klass() == vmClasses::Module_klass();\n+  return obj != nullptr && obj->klass() == vmClasses::Module_klass();\n@@ -376,1 +376,1 @@\n-    return NULL;\n+    return nullptr;\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.inline.hpp","additions":17,"deletions":17,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n-  assert(ik != NULL, \"sanity\");\n+  assert(ik != nullptr, \"sanity\");\n@@ -59,2 +59,2 @@\n-    JvmtiCachedClassFileData* cached_class_file = NULL;\n-    if (cfs == NULL) {\n+    JvmtiCachedClassFileData* cached_class_file = nullptr;\n+    if (cfs == nullptr) {\n@@ -94,1 +94,1 @@\n-      if (cached_class_file != NULL) {\n+      if (cached_class_file != nullptr) {\n@@ -107,1 +107,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -118,1 +118,1 @@\n-  assert(stream != NULL, \"invariant\");\n+  assert(stream != nullptr, \"invariant\");\n@@ -136,1 +136,1 @@\n-    if (state != NULL) {\n+    if (state != nullptr) {\n@@ -138,1 +138,1 @@\n-      if (k != NULL && state->get_class_load_kind() == jvmti_class_load_kind_retransform) {\n+      if (k != nullptr && state->get_class_load_kind() == jvmti_class_load_kind_retransform) {\n@@ -173,2 +173,2 @@\n-  assert(stream != NULL, \"invariant\");\n-  assert(loader_data != NULL, \"invariant\");\n+  assert(stream != nullptr, \"invariant\");\n+  assert(loader_data != nullptr, \"invariant\");\n@@ -179,1 +179,1 @@\n-  JvmtiCachedClassFileData* cached_class_file = NULL;\n+  JvmtiCachedClassFileData* cached_class_file = nullptr;\n@@ -205,1 +205,1 @@\n-  assert(result != NULL, \"result cannot be null with no pending exception\");\n+  assert(result != nullptr, \"result cannot be null with no pending exception\");\n@@ -207,1 +207,1 @@\n-  if (cached_class_file != NULL) {\n+  if (cached_class_file != nullptr) {\n","filename":"src\/hotspot\/share\/classfile\/klassFactory.cpp","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -46,3 +46,3 @@\n- *   a non-NULL ClassFileStream* \/\/ the classfile bytestream\n- *   a non-NULL Symbol*          \/\/ the name of the class\n- *   a non-NULL ClassLoaderData* \/\/ the metaspace allocator\n+ *   a non-nullptr ClassFileStream* \/\/ the classfile bytestream\n+ *   a non-nullptr Symbol*          \/\/ the name of the class\n+ *   a non-nullptr ClassLoaderData* \/\/ the metaspace allocator\n@@ -52,1 +52,1 @@\n- *   if the returned value is non-NULL, that value is an indirection (pointer\/handle)\n+ *   if the returned value is non-nullptr, that value is an indirection (pointer\/handle)\n@@ -56,1 +56,1 @@\n- *   NULL (or a NULL handle) and the caller *might* now have a pending exception.\n+ *   nullptr (or a nullptr handle) and the caller *might* now have a pending exception.\n","filename":"src\/hotspot\/share\/classfile\/klassFactory.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -121,1 +121,1 @@\n-               _klass == NULL ? \" and setting class object\" : \"\");\n+               _klass == nullptr ? \" and setting class object\" : \"\");\n@@ -123,1 +123,1 @@\n-  if (_klass == NULL) {\n+  if (_klass == nullptr) {\n@@ -126,1 +126,1 @@\n-    assert(klass == NULL || _klass == klass, \"constraints corrupted\");\n+    assert(klass == nullptr || _klass == klass, \"constraints corrupted\");\n@@ -184,1 +184,1 @@\n-      if (klass != NULL &&\n+      if (klass != nullptr &&\n@@ -186,1 +186,1 @@\n-        probe->set_klass(NULL);\n+        probe->set_klass(nullptr);\n@@ -231,1 +231,1 @@\n-        if (probe->klass() != NULL) {\n+        if (probe->klass() != nullptr) {\n@@ -271,1 +271,1 @@\n-  if (klass1 != NULL && klass2 != NULL) {\n+  if (klass1 != nullptr && klass2 != nullptr) {\n@@ -284,1 +284,1 @@\n-  InstanceKlass* klass = klass1 != NULL ? klass1 : klass2;\n+  InstanceKlass* klass = klass1 != nullptr ? klass1 : klass2;\n@@ -286,2 +286,2 @@\n-  if (pp1 != NULL && pp1->klass() != NULL) {\n-    if (klass != NULL) {\n+  if (pp1 != nullptr && pp1->klass() != nullptr) {\n+    if (klass != nullptr) {\n@@ -301,2 +301,2 @@\n-  if (pp2 != NULL && pp2->klass() != NULL) {\n-    if (klass != NULL) {\n+  if (pp2 != nullptr && pp2->klass() != nullptr) {\n+    if (klass != nullptr) {\n@@ -315,1 +315,1 @@\n-  if (pp1 == NULL && pp2 == NULL) {\n+  if (pp1 == nullptr && pp2 == nullptr) {\n@@ -328,1 +328,1 @@\n-    if (pp1->klass() == NULL) {\n+    if (pp1->klass() == nullptr) {\n@@ -340,1 +340,1 @@\n-  } else if (pp1 == NULL) {\n+  } else if (pp1 == nullptr) {\n@@ -342,1 +342,1 @@\n-  } else if (pp2 == NULL) {\n+  } else if (pp2 == nullptr) {\n@@ -358,1 +358,1 @@\n-  if (p && p->klass() != NULL && p->klass() != k) {\n+  if (p && p->klass() != nullptr && p->klass() != k) {\n@@ -368,1 +368,1 @@\n-    if (p && p->klass() == NULL) {\n+    if (p && p->klass() == nullptr) {\n@@ -385,1 +385,1 @@\n-  if (p != NULL && p->klass() != NULL) {\n+  if (p != nullptr && p->klass() != nullptr) {\n@@ -390,1 +390,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -396,1 +396,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -421,1 +421,1 @@\n-    if (dest->klass() == NULL) {\n+    if (dest->klass() == nullptr) {\n@@ -426,3 +426,3 @@\n-  \/\/ dest->klass() will hold NULL if klass, src->klass(), and old\n-  \/\/ dest->klass() are all NULL.  In addition, all three must have\n-  \/\/ matching non-NULL values, otherwise either the constraints would\n+  \/\/ dest->klass() will hold null if klass, src->klass(), and old\n+  \/\/ dest->klass() are all null.  In addition, all three must have\n+  \/\/ matching non-null values, otherwise either the constraints would\n@@ -431,1 +431,1 @@\n-  if (src->klass() != NULL) {\n+  if (src->klass() != nullptr) {\n@@ -434,1 +434,1 @@\n-  if (dest->klass() == NULL) {\n+  if (dest->klass() == nullptr) {\n@@ -452,1 +452,1 @@\n-      if (probe->klass() != NULL) {\n+      if (probe->klass() != nullptr) {\n@@ -459,1 +459,1 @@\n-        if (k != NULL) {\n+        if (k != nullptr) {\n@@ -471,1 +471,1 @@\n-          guarantee(entry != NULL, \"klass should be in the placeholders\");\n+          guarantee(entry != nullptr, \"klass should be in the placeholders\");\n","filename":"src\/hotspot\/share\/classfile\/loaderConstraints.cpp","additions":31,"deletions":31,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,2 +39,2 @@\n-MetadataOnStackBuffer* MetadataOnStackMark::_used_buffers = NULL;\n-MetadataOnStackBuffer* MetadataOnStackMark::_free_buffers = NULL;\n+MetadataOnStackBuffer* MetadataOnStackMark::_used_buffers = nullptr;\n+MetadataOnStackBuffer* MetadataOnStackMark::_free_buffers = nullptr;\n@@ -42,1 +42,1 @@\n-MetadataOnStackBuffer* MetadataOnStackMark::_current_buffer = NULL;\n+MetadataOnStackBuffer* MetadataOnStackMark::_current_buffer = nullptr;\n@@ -55,1 +55,1 @@\n-  assert(_used_buffers == NULL, \"sanity check\");\n+  assert(_used_buffers == nullptr, \"sanity check\");\n@@ -88,1 +88,1 @@\n-  while (buffer != NULL) {\n+  while (buffer != nullptr) {\n@@ -100,1 +100,1 @@\n-    buffer->set_next_used(NULL);\n+    buffer->set_next_used(nullptr);\n@@ -108,1 +108,1 @@\n-  _used_buffers = NULL;\n+  _used_buffers = nullptr;\n@@ -114,1 +114,1 @@\n-  if (buffer == NULL) {\n+  if (buffer == nullptr) {\n@@ -124,1 +124,1 @@\n-  _current_buffer = NULL;\n+  _current_buffer = nullptr;\n@@ -131,1 +131,1 @@\n-  if (allocated != NULL) {\n+  if (allocated != nullptr) {\n@@ -135,1 +135,1 @@\n-  if (allocated == NULL) {\n+  if (allocated == nullptr) {\n@@ -150,1 +150,1 @@\n-  if (buffer != NULL && buffer->is_full()) {\n+  if (buffer != nullptr && buffer->is_full()) {\n@@ -152,1 +152,1 @@\n-    buffer = NULL;\n+    buffer = nullptr;\n@@ -155,1 +155,1 @@\n-  if (buffer == NULL) {\n+  if (buffer == nullptr) {\n","filename":"src\/hotspot\/share\/classfile\/metadataOnStackMark.cpp","additions":15,"deletions":15,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,1 +50,1 @@\n-ModuleEntry* ModuleEntryTable::_javabase_module = NULL;\n+ModuleEntry* ModuleEntryTable::_javabase_module = nullptr;\n@@ -61,1 +61,1 @@\n-  if (location != NULL) {\n+  if (location != nullptr) {\n@@ -79,1 +79,1 @@\n-  if (version() == NULL || !is_named()) return false;\n+  if (version() == nullptr || !is_named()) return false;\n@@ -81,1 +81,1 @@\n-  if (location() != NULL) {\n+  if (location() != nullptr) {\n@@ -124,1 +124,1 @@\n-  assert(m != NULL, \"No module to lookup in this module's reads list\");\n+  assert(m != nullptr, \"No module to lookup in this module's reads list\");\n@@ -163,1 +163,1 @@\n-  if (m == NULL) {\n+  if (m == nullptr) {\n@@ -166,1 +166,1 @@\n-    if (_reads == NULL) {\n+    if (_reads == nullptr) {\n@@ -195,1 +195,1 @@\n-                        (name() != NULL) ? name()->as_C_string() : UNNAMED_MODULE);\n+                        (name() != nullptr) ? name()->as_C_string() : UNNAMED_MODULE);\n@@ -210,1 +210,1 @@\n-  return ((_reads != NULL) && !_reads->is_empty());\n+  return ((_reads != nullptr) && !_reads->is_empty());\n@@ -225,1 +225,1 @@\n-                        (name() != NULL) ? name()->as_C_string() : UNNAMED_MODULE);\n+                        (name() != nullptr) ? name()->as_C_string() : UNNAMED_MODULE);\n@@ -245,1 +245,1 @@\n-  assert(f != NULL, \"invariant\");\n+  assert(f != nullptr, \"invariant\");\n@@ -257,1 +257,1 @@\n-  _reads = NULL;\n+  _reads = nullptr;\n@@ -298,1 +298,1 @@\n-                               name != NULL ? name->as_C_string() : UNNAMED_MODULE);\n+                               name != nullptr ? name->as_C_string() : UNNAMED_MODULE);\n@@ -338,1 +338,1 @@\n-  assert(unnamed_module != NULL, \"boot loader unnamed module should not be null\");\n+  assert(unnamed_module != nullptr, \"boot loader unnamed module should not be null\");\n@@ -389,1 +389,1 @@\n-static ArchivedModuleEntries* _archive_modules_entries = NULL;\n+static ArchivedModuleEntries* _archive_modules_entries = nullptr;\n@@ -402,1 +402,1 @@\n-  if (_archive_modules_entries == NULL) {\n+  if (_archive_modules_entries == nullptr) {\n@@ -405,1 +405,1 @@\n-  assert(_archive_modules_entries->get(this) == NULL, \"Each ModuleEntry must not be shared across ModuleEntryTables\");\n+  assert(_archive_modules_entries->get(this) == nullptr, \"Each ModuleEntry must not be shared across ModuleEntryTables\");\n@@ -425,1 +425,1 @@\n-  assert(ptr != NULL && *ptr != NULL, \"must have been allocated\");\n+  assert(ptr != nullptr && *ptr != nullptr, \"must have been allocated\");\n@@ -433,2 +433,2 @@\n-  Array<ModuleEntry*>* archived_array = NULL;\n-  int length = (array == NULL) ? 0 : array->length();\n+  Array<ModuleEntry*>* archived_array = nullptr;\n+  int length = (array == nullptr) ? 0 : array->length();\n@@ -448,2 +448,2 @@\n-  GrowableArray<ModuleEntry*>* array = NULL;\n-  int length = (archived_array == NULL) ? 0 : archived_array->length();\n+  GrowableArray<ModuleEntry*>* array = nullptr;\n+  int length = (archived_array == nullptr) ? 0 : archived_array->length();\n@@ -470,1 +470,1 @@\n-  _loader_data = NULL;  \/\/ re-init at runtime\n+  _loader_data = nullptr;  \/\/ re-init at runtime\n@@ -472,1 +472,1 @@\n-  if (name() != NULL) {\n+  if (name() != nullptr) {\n@@ -477,1 +477,1 @@\n-  if (_version != NULL) {\n+  if (_version != nullptr) {\n@@ -480,1 +480,1 @@\n-  if (_location != NULL) {\n+  if (_location != nullptr) {\n@@ -497,1 +497,1 @@\n-  assert(shared_protection_domain() == NULL, \"never set during -Xshare:dump\");\n+  assert(shared_protection_domain() == nullptr, \"never set during -Xshare:dump\");\n@@ -615,1 +615,1 @@\n-  assert(module_name != NULL, \"ModuleEntryTable locked_create_entry should never be called for unnamed module.\");\n+  assert(module_name != nullptr, \"ModuleEntryTable locked_create_entry should never be called for unnamed module.\");\n@@ -617,1 +617,1 @@\n-  assert(lookup_only(module_name) == NULL, \"Module already exists\");\n+  assert(lookup_only(module_name) == nullptr, \"Module already exists\");\n@@ -628,1 +628,1 @@\n-  assert(name != NULL, \"name cannot be NULL\");\n+  assert(name != nullptr, \"name cannot be nullptr\");\n@@ -648,1 +648,1 @@\n-  assert(module_table != NULL, \"boot loader's ModuleEntryTable not defined\");\n+  assert(module_table != nullptr, \"boot loader's ModuleEntryTable not defined\");\n@@ -656,1 +656,1 @@\n-  assert(jb_module != NULL, JAVA_BASE_NAME \" ModuleEntry not defined\");\n+  assert(jb_module != nullptr, JAVA_BASE_NAME \" ModuleEntry not defined\");\n@@ -710,1 +710,1 @@\n-  java_lang_Class::set_fixup_module_field_list(NULL);\n+  java_lang_Class::set_fixup_module_field_list(nullptr);\n@@ -743,1 +743,1 @@\n-               name() == NULL ? UNNAMED_MODULE : name()->as_C_string(),\n+               name() == nullptr ? UNNAMED_MODULE : name()->as_C_string(),\n@@ -746,2 +746,2 @@\n-               version() != NULL ? version()->as_C_string() : \"NULL\",\n-               location() != NULL ? location()->as_C_string() : \"NULL\",\n+               version() != nullptr ? version()->as_C_string() : \"nullptr\",\n+               location() != nullptr ? location()->as_C_string() : \"nullptr\",\n@@ -760,1 +760,1 @@\n-  guarantee(loader_data() != NULL, \"A module entry must be associated with a loader.\");\n+  guarantee(loader_data() != nullptr, \"A module entry must be associated with a loader.\");\n","filename":"src\/hotspot\/share\/classfile\/moduleEntry.cpp","additions":38,"deletions":38,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -124,1 +124,1 @@\n-  bool             is_named() const                    { return (_name != NULL); }\n+  bool             is_named() const                    { return (_name != nullptr); }\n@@ -236,1 +236,1 @@\n-    assert(_javabase_module == NULL, \"_javabase_module is already defined\");\n+    assert(_javabase_module == nullptr, \"_javabase_module is already defined\");\n@@ -240,2 +240,2 @@\n-  static bool javabase_defined() { return ((_javabase_module != NULL) &&\n-                                           (_javabase_module->module() != NULL)); }\n+  static bool javabase_defined() { return ((_javabase_module != nullptr) &&\n+                                           (_javabase_module->module() != nullptr)); }\n","filename":"src\/hotspot\/share\/classfile\/moduleEntry.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-  assert(module_name != NULL, \"invariant\");\n+  assert(module_name != nullptr, \"invariant\");\n@@ -62,1 +62,1 @@\n-  assert(package_name != NULL, \"Package name derived from non-null jstring can't be NULL\");\n+  assert(package_name != nullptr, \"Package name derived from non-null jstring can't be nullptr\");\n@@ -70,1 +70,1 @@\n-  if (name_oop == NULL) {\n+  if (name_oop == nullptr) {\n@@ -82,2 +82,2 @@\n-  if (str_object == NULL) {\n-    return NULL;\n+  if (str_object == nullptr) {\n+    return nullptr;\n@@ -115,1 +115,1 @@\n-  assert(package_name != NULL, \"Precondition\");\n+  assert(package_name != nullptr, \"Precondition\");\n@@ -118,1 +118,1 @@\n-  assert(package_entry_table != NULL, \"Unexpected null package entry table\");\n+  assert(package_entry_table != nullptr, \"Unexpected null package entry table\");\n@@ -120,1 +120,1 @@\n-  assert(package_entry == NULL || package_entry->module() == module_entry, \"Unexpectedly found a package linked to another module\");\n+  assert(package_entry == nullptr || package_entry->module() == module_entry, \"Unexpectedly found a package linked to another module\");\n@@ -125,1 +125,1 @@\n-  if (package != NULL) {\n+  if (package != nullptr) {\n@@ -128,1 +128,1 @@\n-    assert(package_entry_table != NULL, \"Unexpected null package entry table\");\n+    assert(package_entry_table != nullptr, \"Unexpected null package entry table\");\n@@ -131,1 +131,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -136,1 +136,1 @@\n-  return res != NULL;\n+  return res != nullptr;\n@@ -171,1 +171,1 @@\n-    if (pkg_str == NULL || pkg_str->klass() != vmClasses::String_klass()) {\n+    if (pkg_str == nullptr || pkg_str->klass() != vmClasses::String_klass()) {\n@@ -188,1 +188,1 @@\n-  if (loader != NULL) {\n+  if (loader != nullptr) {\n@@ -196,1 +196,1 @@\n-  assert(pkg_list->length() == 0 || package_table != NULL, \"Bad package_table\");\n+  assert(pkg_list->length() == 0 || package_table != nullptr, \"Bad package_table\");\n@@ -199,1 +199,1 @@\n-  assert(ModuleEntryTable::javabase_moduleEntry() != NULL, \"No ModuleEntry for \" JAVA_BASE_NAME);\n+  assert(ModuleEntryTable::javabase_moduleEntry() != nullptr, \"No ModuleEntry for \" JAVA_BASE_NAME);\n@@ -219,1 +219,1 @@\n-        assert(package_table->locked_lookup_only(pkg_list->at(x)) != NULL,\n+        assert(package_table->locked_lookup_only(pkg_list->at(x)) != nullptr,\n@@ -243,1 +243,1 @@\n-                         location_symbol != NULL ? location_symbol->as_C_string() : \"NULL\");\n+                         location_symbol != nullptr ? location_symbol->as_C_string() : \"nullptr\");\n@@ -246,2 +246,2 @@\n-                    version_symbol != NULL ? version_symbol->as_C_string() : \"NULL\",\n-                    location_symbol != NULL ? location_symbol->as_C_string() : \"NULL\",\n+                    version_symbol != nullptr ? version_symbol->as_C_string() : \"nullptr\",\n+                    location_symbol != nullptr ? location_symbol->as_C_string() : \"nullptr\",\n@@ -289,1 +289,1 @@\n-  if (module_name == NULL) {\n+  if (module_name == nullptr) {\n@@ -315,1 +315,1 @@\n-  assert(loader_data != NULL, \"class loader data shouldn't be null\");\n+  assert(loader_data != nullptr, \"class loader data shouldn't be null\");\n@@ -327,1 +327,1 @@\n-    if (pkg_str == NULL || pkg_str->klass() != vmClasses::String_klass()) {\n+    if (pkg_str == nullptr || pkg_str->klass() != vmClasses::String_klass()) {\n@@ -362,1 +362,1 @@\n-  assert(module_table != NULL, \"module entry table shouldn't be null\");\n+  assert(module_table != nullptr, \"module entry table shouldn't be null\");\n@@ -375,2 +375,2 @@\n-  PackageEntryTable* package_table = NULL;\n-  PackageEntry* existing_pkg = NULL;\n+  PackageEntryTable* package_table = nullptr;\n+  PackageEntry* existing_pkg = nullptr;\n@@ -382,1 +382,1 @@\n-      assert(package_table != NULL, \"Missing package_table\");\n+      assert(package_table != nullptr, \"Missing package_table\");\n@@ -387,1 +387,1 @@\n-        if (existing_pkg != NULL) {\n+        if (existing_pkg != nullptr) {\n@@ -390,1 +390,1 @@\n-          if (module_table->lookup_only(module_symbol) != NULL) {\n+          if (module_table->lookup_only(module_symbol) != nullptr) {\n@@ -399,2 +399,2 @@\n-    if (!dupl_modules && existing_pkg == NULL) {\n-      if (module_table->lookup_only(module_symbol) == NULL) {\n+    if (!dupl_modules && existing_pkg == nullptr) {\n+      if (module_table->lookup_only(module_symbol) == nullptr) {\n@@ -405,1 +405,1 @@\n-        assert(module_entry != NULL, \"module_entry creation failed\");\n+        assert(module_entry != nullptr, \"module_entry creation failed\");\n@@ -408,1 +408,1 @@\n-        assert(pkg_list->length() == 0 || package_table != NULL, \"Bad package table\");\n+        assert(pkg_list->length() == 0 || package_table != nullptr, \"Bad package table\");\n@@ -430,1 +430,1 @@\n-  } else if (existing_pkg != NULL) {\n+  } else if (existing_pkg != nullptr) {\n@@ -435,1 +435,1 @@\n-                         location_symbol != NULL ? location_symbol->as_C_string() : \"NULL\");\n+                         location_symbol != nullptr ? location_symbol->as_C_string() : \"nullptr\");\n@@ -440,2 +440,2 @@\n-                 module_name, version_symbol != NULL ? version_symbol->as_C_string() : \"NULL\",\n-                 location_symbol != NULL ? location_symbol->as_C_string() : \"NULL\");\n+                 module_name, version_symbol != nullptr ? version_symbol->as_C_string() : \"nullptr\",\n+                 location_symbol != nullptr ? location_symbol->as_C_string() : \"nullptr\");\n@@ -593,1 +593,1 @@\n-  assert(Arguments::get_property(\"java.system.class.loader\") == NULL,\n+  assert(Arguments::get_property(\"java.system.class.loader\") == nullptr,\n@@ -619,1 +619,1 @@\n-  if (name != NULL) {\n+  if (name != nullptr) {\n@@ -626,1 +626,1 @@\n-  if (loader != NULL) {\n+  if (loader != nullptr) {\n@@ -636,1 +636,1 @@\n-  assert(unnamed_module != NULL, \"boot loader's unnamed ModuleEntry not defined\");\n+  assert(unnamed_module != nullptr, \"boot loader's unnamed ModuleEntry not defined\");\n@@ -645,1 +645,1 @@\n-  if (package_name == NULL) {\n+  if (package_name == nullptr) {\n@@ -654,1 +654,1 @@\n-  if (from_module_entry == NULL) {\n+  if (from_module_entry == nullptr) {\n@@ -664,1 +664,1 @@\n-    to_module_entry = NULL;  \/\/ It's an unqualified export.\n+    to_module_entry = nullptr;  \/\/ It's an unqualified export.\n@@ -667,1 +667,1 @@\n-    if (to_module_entry == NULL) {\n+    if (to_module_entry == nullptr) {\n@@ -673,1 +673,1 @@\n-  PackageEntry* package_entry = NULL;\n+  PackageEntry* package_entry = nullptr;\n@@ -685,1 +685,1 @@\n-        package_entry != NULL) {\n+        package_entry != nullptr) {\n@@ -691,1 +691,1 @@\n-  if (package_entry == NULL) {\n+  if (package_entry == nullptr) {\n@@ -694,1 +694,1 @@\n-                      pkg != NULL ? pkg : \"\",\n+                      pkg != nullptr ? pkg : \"\",\n@@ -702,1 +702,1 @@\n-                      to_module_entry == NULL ? \"NULL\" :\n+                      to_module_entry == nullptr ? \"nullptr\" :\n@@ -727,1 +727,1 @@\n-  if (from_module_entry == NULL) {\n+  if (from_module_entry == nullptr) {\n@@ -735,1 +735,1 @@\n-    if (to_module_entry == NULL) {\n+    if (to_module_entry == nullptr) {\n@@ -740,1 +740,1 @@\n-    to_module_entry = NULL;\n+    to_module_entry = nullptr;\n@@ -747,1 +747,1 @@\n-                    to_module_entry == NULL ? \"all unnamed\" :\n+                    to_module_entry == nullptr ? \"all unnamed\" :\n@@ -762,1 +762,1 @@\n-  if (clazz == NULL) {\n+  if (clazz == nullptr) {\n@@ -767,3 +767,3 @@\n-  if (mirror == NULL) {\n-    log_debug(module)(\"get_module(): no mirror, returning NULL\");\n-    return NULL;\n+  if (mirror == nullptr) {\n+    log_debug(module)(\"get_module(): no mirror, returning nullptr\");\n+    return nullptr;\n@@ -778,1 +778,1 @@\n-  assert(module != NULL, \"java.lang.Class module field not set\");\n+  assert(module != nullptr, \"java.lang.Class module field not set\");\n@@ -787,1 +787,1 @@\n-    if (module_name != NULL) {\n+    if (module_name != nullptr) {\n@@ -793,1 +793,1 @@\n-    if (klass != NULL) {\n+    if (klass != nullptr) {\n@@ -808,1 +808,1 @@\n-  assert(package_name != NULL, \"the package_name should not be NULL\");\n+  assert(package_name != nullptr, \"the package_name should not be nullptr\");\n@@ -811,1 +811,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -816,1 +816,1 @@\n-  const ModuleEntry* const module_entry = (pkg_entry != NULL ? pkg_entry->module() : NULL);\n+  const ModuleEntry* const module_entry = (pkg_entry != nullptr ? pkg_entry->module() : nullptr);\n@@ -818,1 +818,1 @@\n-  if (module_entry != NULL && module_entry->module() != NULL && module_entry->is_named()) {\n+  if (module_entry != nullptr && module_entry->module() != nullptr && module_entry->is_named()) {\n@@ -821,1 +821,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -831,1 +831,1 @@\n-  if (package_name == NULL) {\n+  if (package_name == nullptr) {\n@@ -836,1 +836,1 @@\n-  if (module_entry == NULL) {\n+  if (module_entry == nullptr) {\n@@ -849,1 +849,1 @@\n-  PackageEntry* package_entry = NULL;\n+  PackageEntry* package_entry = nullptr;\n@@ -855,1 +855,1 @@\n-    if (package_entry != NULL) {\n+    if (package_entry != nullptr) {\n@@ -861,1 +861,1 @@\n-  if (package_entry == NULL) {\n+  if (package_entry == nullptr) {\n@@ -864,1 +864,1 @@\n-                      pkg != NULL ? pkg : \"\",\n+                      pkg != nullptr ? pkg : \"\",\n","filename":"src\/hotspot\/share\/classfile\/modules.cpp","additions":72,"deletions":72,"binary":false,"changes":144,"status":"modified"},{"patch":"@@ -108,2 +108,2 @@\n-  \/\/ Returns NULL if the package name is empty, if the resulting package\n-  \/\/ entry is NULL, if the module is not found or is unnamed.\n+  \/\/ Returns null if the package name is empty, if the resulting package\n+  \/\/ entry is null, if the module is not found or is unnamed.\n","filename":"src\/hotspot\/share\/classfile\/modules.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,1 +50,1 @@\n-  _qualified_exports(NULL),\n+  _qualified_exports(nullptr),\n@@ -67,1 +67,1 @@\n-  assert(m != NULL, \"No module to lookup in this package's qualified exports list\");\n+  assert(m != nullptr, \"No module to lookup in this package's qualified exports list\");\n@@ -103,1 +103,1 @@\n-      (this_pkg_mod == NULL || this_pkg_mod->loader_data() != m_loader_data) &&\n+      (this_pkg_mod == nullptr || this_pkg_mod->loader_data() != m_loader_data) &&\n@@ -108,1 +108,1 @@\n-      assert(name() != NULL, \"PackageEntry without a valid name\");\n+      assert(name() != nullptr, \"PackageEntry without a valid name\");\n@@ -111,1 +111,1 @@\n-                        (this_pkg_mod == NULL || this_pkg_mod->name() == NULL) ?\n+                        (this_pkg_mod == nullptr || this_pkg_mod->name() == nullptr) ?\n@@ -126,2 +126,2 @@\n-  if (m == NULL) {\n-    \/\/ NULL indicates the package is being unqualifiedly exported.  Clean up\n+  if (m == nullptr) {\n+    \/\/ null indicates the package is being unqualifiedly exported.  Clean up\n@@ -153,1 +153,1 @@\n-      _qualified_exports != NULL &&\n+      _qualified_exports != nullptr &&\n@@ -162,1 +162,1 @@\n-      assert(name() != NULL, \"PackageEntry without a valid name\");\n+      assert(name() != nullptr, \"PackageEntry without a valid name\");\n@@ -166,1 +166,1 @@\n-                        (pkg_mod == NULL || pkg_mod->name() == NULL) ? UNNAMED_MODULE : pkg_mod->name()->as_C_string());\n+                        (pkg_mod == nullptr || pkg_mod->name() == nullptr) ? UNNAMED_MODULE : pkg_mod->name()->as_C_string());\n@@ -185,1 +185,1 @@\n-  if (_qualified_exports != NULL) {\n+  if (_qualified_exports != nullptr) {\n@@ -188,1 +188,1 @@\n-  _qualified_exports = NULL;\n+  _qualified_exports = nullptr;\n@@ -219,1 +219,1 @@\n-static ArchivedPackageEntries* _archived_packages_entries = NULL;\n+static ArchivedPackageEntries* _archived_packages_entries = nullptr;\n@@ -226,1 +226,1 @@\n-  if (_archived_packages_entries == NULL) {\n+  if (_archived_packages_entries == nullptr) {\n@@ -229,1 +229,1 @@\n-  assert(_archived_packages_entries->get(this) == NULL, \"Each PackageEntry must not be shared across PackageEntryTables\");\n+  assert(_archived_packages_entries->get(this) == nullptr, \"Each PackageEntry must not be shared across PackageEntryTables\");\n@@ -237,1 +237,1 @@\n-  if (ptr != NULL) {\n+  if (ptr != nullptr) {\n@@ -240,1 +240,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -334,1 +334,1 @@\n-  assert(locked_lookup_only(name) == NULL, \"Package entry already exists\");\n+  assert(locked_lookup_only(name) == nullptr, \"Package entry already exists\");\n@@ -379,2 +379,2 @@\n-    Symbol* module_name = (m == NULL ? NULL : m->name());\n-    if (module_name != NULL &&\n+    Symbol* module_name = (m == nullptr ? nullptr : m->name());\n+    if (module_name != nullptr &&\n@@ -394,1 +394,1 @@\n-  assert(f != NULL, \"invariant\");\n+  assert(f != nullptr, \"invariant\");\n@@ -407,1 +407,1 @@\n-  return (is_unqual_exported() && _qualified_exports != NULL);\n+  return (is_unqual_exported() && _qualified_exports != nullptr);\n","filename":"src\/hotspot\/share\/classfile\/packageEntry.cpp","additions":23,"deletions":23,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -154,1 +154,1 @@\n-    return (!is_unqual_exported() && _qualified_exports != NULL);\n+    return (!is_unqual_exported() && _qualified_exports != nullptr);\n","filename":"src\/hotspot\/share\/classfile\/packageEntry.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -72,2 +72,2 @@\n-       _stnext = NULL;\n-       _stprev = NULL;\n+       _stnext = nullptr;\n+       _stprev = nullptr;\n@@ -84,1 +84,1 @@\n-    while (seen != NULL) {\n+    while (seen != nullptr) {\n@@ -93,1 +93,1 @@\n-  SeenThread* queuehead = NULL;\n+  SeenThread* queuehead = nullptr;\n@@ -135,1 +135,1 @@\n-  assert(action != PlaceholderTable::LOAD_INSTANCE || !EnableWaitForParallelLoad || seen == NULL,\n+  assert(action != PlaceholderTable::LOAD_INSTANCE || !EnableWaitForParallelLoad || seen == nullptr,\n@@ -138,1 +138,1 @@\n-  if (seen == NULL) {\n+  if (seen == nullptr) {\n@@ -143,1 +143,1 @@\n-  while ((next = seen->next()) != NULL) {\n+  while ((next = seen->next()) != nullptr) {\n@@ -173,1 +173,1 @@\n-  SeenThread* prev = NULL;\n+  SeenThread* prev = nullptr;\n@@ -190,1 +190,1 @@\n-  return (actionToQueue(action) == NULL);\n+  return (actionToQueue(action) == nullptr);\n@@ -203,1 +203,1 @@\n-  assert(class_name != NULL, \"adding NULL obj\");\n+  assert(class_name != nullptr, \"adding nullptr obj\");\n@@ -258,1 +258,1 @@\n-  assert(action != LOAD_SUPER || supername != NULL, \"must have a super class name\");\n+  assert(action != LOAD_SUPER || supername != nullptr, \"must have a super class name\");\n@@ -260,1 +260,1 @@\n-  if (probe == NULL) {\n+  if (probe == nullptr) {\n@@ -292,1 +292,1 @@\n-  if (probe != NULL) {\n+  if (probe != nullptr) {\n@@ -296,2 +296,2 @@\n-    if ((probe->superThreadQ() == NULL) && (probe->loadInstanceThreadQ() == NULL)\n-        && (probe->defineThreadQ() == NULL) && (probe->definer() == NULL)) {\n+    if ((probe->superThreadQ() == nullptr) && (probe->loadInstanceThreadQ() == nullptr)\n+        && (probe->defineThreadQ() == nullptr) && (probe->definer() == nullptr)) {\n@@ -311,1 +311,1 @@\n-  if (supername() != NULL) {\n+  if (supername() != nullptr) {\n@@ -315,1 +315,1 @@\n-  if (definer() != NULL) {\n+  if (definer() != nullptr) {\n@@ -319,1 +319,1 @@\n-  if (instance_klass() != NULL) {\n+  if (instance_klass() != nullptr) {\n","filename":"src\/hotspot\/share\/classfile\/placeholders.cpp","additions":19,"deletions":19,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -135,1 +135,1 @@\n-     return (_superThreadQ != NULL);\n+     return (_superThreadQ != nullptr);\n@@ -139,1 +139,1 @@\n-    return (_loadInstanceThreadQ != NULL);\n+    return (_loadInstanceThreadQ != nullptr);\n@@ -143,1 +143,1 @@\n-    return (_defineThreadQ != NULL);\n+    return (_defineThreadQ != nullptr);\n","filename":"src\/hotspot\/share\/classfile\/placeholders.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -75,1 +75,1 @@\n-    if (dictionary != NULL) {\n+    if (dictionary != nullptr) {\n@@ -81,1 +81,1 @@\n-static GrowableArray<ProtectionDomainEntry*>* _delete_list = NULL;\n+static GrowableArray<ProtectionDomainEntry*>* _delete_list = nullptr;\n@@ -118,1 +118,1 @@\n-  if (_delete_list == NULL) {\n+  if (_delete_list == nullptr) {\n","filename":"src\/hotspot\/share\/classfile\/protectionDomainCache.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -67,1 +67,1 @@\n-  assert(!pool.is_null() && error != NULL, \"adding NULL obj\");\n+  assert(!pool.is_null() && error != nullptr, \"adding nullptr obj\");\n@@ -79,1 +79,1 @@\n-  assert(!pool.is_null() && message != NULL, \"adding NULL obj\");\n+  assert(!pool.is_null() && message != nullptr, \"adding nullptr obj\");\n@@ -115,1 +115,1 @@\n-  if (nest_host_error() != NULL) {\n+  if (nest_host_error() != nullptr) {\n","filename":"src\/hotspot\/share\/classfile\/resolutionErrors.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -88,1 +88,1 @@\n-    _verifier = NULL;\n+    _verifier = nullptr;\n","filename":"src\/hotspot\/share\/classfile\/stackMapFrame.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -163,1 +163,1 @@\n-  if (locals == NULL) return -1;\n+  if (locals == nullptr) return -1;\n@@ -195,1 +195,1 @@\n-    if (flags != NULL) {\n+    if (flags != nullptr) {\n@@ -218,1 +218,1 @@\n-  VerificationType* locals = NULL;\n+  VerificationType* locals = nullptr;\n@@ -235,2 +235,2 @@\n-      max_locals, max_stack, locals, NULL, _verifier);\n-    if (first && locals != NULL) {\n+      max_locals, max_stack, locals, nullptr, _verifier);\n+    if (first && locals != nullptr) {\n@@ -257,1 +257,1 @@\n-    stack[0] = parse_verification_type(NULL, CHECK_VERIFY_(_verifier, NULL));\n+    stack[0] = parse_verification_type(nullptr, CHECK_VERIFY_(_verifier, nullptr));\n@@ -263,1 +263,1 @@\n-      stack_size, max_stack, CHECK_VERIFY_(_verifier, NULL));\n+      stack_size, max_stack, CHECK_VERIFY_(_verifier, nullptr));\n@@ -267,1 +267,1 @@\n-    if (first && locals != NULL) {\n+    if (first && locals != nullptr) {\n@@ -278,1 +278,1 @@\n-      \"reserved frame type\", CHECK_VERIFY_(_verifier, NULL));\n+      \"reserved frame type\", CHECK_VERIFY_(_verifier, nullptr));\n@@ -297,1 +297,1 @@\n-    stack[0] = parse_verification_type(NULL, CHECK_VERIFY_(_verifier, NULL));\n+    stack[0] = parse_verification_type(nullptr, CHECK_VERIFY_(_verifier, nullptr));\n@@ -303,1 +303,1 @@\n-      stack_size, max_stack, CHECK_VERIFY_(_verifier, NULL));\n+      stack_size, max_stack, CHECK_VERIFY_(_verifier, nullptr));\n@@ -307,1 +307,1 @@\n-    if (first && locals != NULL) {\n+    if (first && locals != nullptr) {\n@@ -323,1 +323,1 @@\n-        new_length, max_locals, CHECK_VERIFY_(_verifier, NULL));\n+        new_length, max_locals, CHECK_VERIFY_(_verifier, nullptr));\n@@ -340,1 +340,1 @@\n-        locals = NULL;\n+        locals = nullptr;\n@@ -347,2 +347,2 @@\n-      locals, NULL, _verifier);\n-    if (first && locals != NULL) {\n+      locals, nullptr, _verifier);\n+    if (first && locals != nullptr) {\n@@ -373,1 +373,1 @@\n-      real_length, max_locals, CHECK_VERIFY_(_verifier, NULL));\n+      real_length, max_locals, CHECK_VERIFY_(_verifier, nullptr));\n@@ -381,1 +381,1 @@\n-      max_stack, locals, NULL, _verifier);\n+      max_stack, locals, nullptr, _verifier);\n@@ -404,1 +404,1 @@\n-      real_locals_size, max_locals, CHECK_VERIFY_(_verifier, NULL));\n+      real_locals_size, max_locals, CHECK_VERIFY_(_verifier, nullptr));\n@@ -407,1 +407,1 @@\n-    VerificationType* stack = NULL;\n+    VerificationType* stack = nullptr;\n@@ -413,1 +413,1 @@\n-      stack[real_stack_size] = parse_verification_type(NULL, CHECK_NULL);\n+      stack[real_stack_size] = parse_verification_type(nullptr, CHECK_NULL);\n@@ -421,1 +421,1 @@\n-      real_stack_size, max_stack, CHECK_VERIFY_(_verifier, NULL));\n+      real_stack_size, max_stack, CHECK_VERIFY_(_verifier, nullptr));\n@@ -434,2 +434,2 @@\n-    \"reserved frame type\", CHECK_VERIFY_(pre_frame->verifier(), NULL));\n-  return NULL;\n+    \"reserved frame type\", CHECK_VERIFY_(pre_frame->verifier(), nullptr));\n+  return nullptr;\n","filename":"src\/hotspot\/share\/classfile\/stackMapTable.cpp","additions":25,"deletions":25,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -91,1 +91,1 @@\n-    if (_data == NULL || _index >= _data->length()) {\n+    if (_data == nullptr || _index >= _data->length()) {\n@@ -97,1 +97,1 @@\n-    if (_data == NULL || _index >= _data->length() - 1) {\n+    if (_data == nullptr || _index >= _data->length() - 1) {\n@@ -105,1 +105,1 @@\n-    return (_data == NULL) || (_index == _data->length());\n+    return (_data == nullptr) || (_index == _data->length());\n","filename":"src\/hotspot\/share\/classfile\/stackMapTable.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -213,1 +213,1 @@\n-    return as_##stackmap_frame_type() != NULL; \\\n+    return as_##stackmap_frame_type() != nullptr; \\\n@@ -255,1 +255,1 @@\n-  verification_type_info* types() const { return NULL; }\n+  verification_type_info* types() const { return nullptr; }\n@@ -308,1 +308,1 @@\n-  verification_type_info* types() const { return NULL; }\n+  verification_type_info* types() const { return nullptr; }\n@@ -347,1 +347,1 @@\n-    if (vti != NULL) {\n+    if (vti != nullptr) {\n@@ -424,1 +424,1 @@\n-    if (vti != NULL) {\n+    if (vti != nullptr) {\n@@ -524,1 +524,1 @@\n-  verification_type_info* types() const { return NULL; }\n+  verification_type_info* types() const { return nullptr; }\n@@ -571,1 +571,1 @@\n-    if (types != NULL) {\n+    if (types != nullptr) {\n@@ -683,1 +683,1 @@\n-    if (locals != NULL) {\n+    if (locals != nullptr) {\n@@ -825,1 +825,1 @@\n-  if (item_##stack_frame_type != NULL) { \\\n+  if (item_##stack_frame_type != nullptr) { \\\n@@ -831,1 +831,1 @@\n-  if (item_##stack_frame_type != NULL) { \\\n+  if (item_##stack_frame_type != nullptr) { \\\n@@ -858,1 +858,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -890,1 +890,1 @@\n-    return NULL; \\\n+    return nullptr; \\\n","filename":"src\/hotspot\/share\/classfile\/stackMapTableFormat.hpp","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -102,1 +102,1 @@\n-static StringTableHash* _local_table = NULL;\n+static StringTableHash* _local_table = nullptr;\n@@ -127,1 +127,1 @@\n-    if (val_oop == NULL) {\n+    if (val_oop == nullptr) {\n@@ -136,1 +136,1 @@\n-    if (chars != NULL) {\n+    if (chars != nullptr) {\n@@ -171,1 +171,1 @@\n-    if (val_oop == NULL) {\n+    if (val_oop == nullptr) {\n@@ -203,1 +203,1 @@\n-    if (val_oop == NULL) {\n+    if (val_oop == nullptr) {\n@@ -265,1 +265,1 @@\n-  if (string != NULL) {\n+  if (string != nullptr) {\n@@ -281,1 +281,1 @@\n-    assert(result != NULL, \"Result should be reachable\");\n+    assert(result != nullptr, \"Result should be reachable\");\n@@ -301,1 +301,1 @@\n-  if (symbol == NULL) return NULL;\n+  if (symbol == nullptr) return nullptr;\n@@ -311,1 +311,1 @@\n-  if (string == NULL) return NULL;\n+  if (string == nullptr) return nullptr;\n@@ -322,1 +322,1 @@\n-  if (utf8_string == NULL) return NULL;\n+  if (utf8_string == nullptr) return nullptr;\n@@ -336,1 +336,1 @@\n-  if (found_string != NULL) {\n+  if (found_string != nullptr) {\n@@ -343,1 +343,1 @@\n-  if (found_string != NULL) {\n+  if (found_string != nullptr) {\n@@ -427,1 +427,1 @@\n-    if (tmp == NULL) {\n+    if (tmp == nullptr) {\n@@ -552,1 +552,1 @@\n-  if (obj == NULL) {\n+  if (obj == nullptr) {\n@@ -569,1 +569,1 @@\n-    if (s == NULL) {\n+    if (s == nullptr) {\n@@ -599,1 +599,1 @@\n-    if (s != NULL) {\n+    if (s != nullptr) {\n@@ -629,1 +629,1 @@\n-    if (s == NULL) {\n+    if (s == nullptr) {\n@@ -683,1 +683,1 @@\n-    if (s == NULL) {\n+    if (s == nullptr) {\n@@ -697,1 +697,1 @@\n-    if (s == NULL) {\n+    if (s == nullptr) {\n@@ -762,1 +762,1 @@\n-  oop new_s = NULL;\n+  oop new_s = nullptr;\n@@ -765,2 +765,2 @@\n-  if (new_v == NULL) {\n-    return NULL;\n+  if (new_v == nullptr) {\n+    return nullptr;\n@@ -769,2 +769,2 @@\n-  if (new_s == NULL) {\n-    return NULL;\n+  if (new_s == nullptr) {\n+    return nullptr;\n@@ -797,1 +797,1 @@\n-    assert(s != NULL, \"sanity\");\n+    assert(s != nullptr, \"sanity\");\n@@ -800,1 +800,1 @@\n-    if (new_s == NULL) {\n+    if (new_s == nullptr) {\n","filename":"src\/hotspot\/share\/classfile\/stringTable.cpp","additions":27,"deletions":27,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -108,1 +108,1 @@\n-  static oop lookup_shared(const jchar* name, int len, unsigned int hash) NOT_CDS_JAVA_HEAP_RETURN_(NULL);\n+  static oop lookup_shared(const jchar* name, int len, unsigned int hash) NOT_CDS_JAVA_HEAP_RETURN_(nullptr);\n@@ -110,1 +110,1 @@\n-  static oop lookup_shared(const jchar* name, int len) NOT_CDS_JAVA_HEAP_RETURN_(NULL);\n+  static oop lookup_shared(const jchar* name, int len) NOT_CDS_JAVA_HEAP_RETURN_(nullptr);\n@@ -112,1 +112,1 @@\n-  static oop create_archived_string(oop s) NOT_CDS_JAVA_HEAP_RETURN_(NULL);\n+  static oop create_archived_string(oop s) NOT_CDS_JAVA_HEAP_RETURN_(nullptr);\n","filename":"src\/hotspot\/share\/classfile\/stringTable.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -79,1 +79,1 @@\n-static SymbolTableHash* _local_table = NULL;\n+static SymbolTableHash* _local_table = nullptr;\n@@ -104,1 +104,1 @@\n-Arena* SymbolTable::_arena = NULL;\n+Arena* SymbolTable::_arena = nullptr;\n@@ -232,1 +232,1 @@\n-    assert(sym != NULL, \"new should call vm_exit_out_of_memory if C_HEAP is exhausted\");\n+    assert(sym != nullptr, \"new should call vm_exit_out_of_memory if C_HEAP is exhausted\");\n@@ -236,1 +236,1 @@\n-    assert(sym != NULL, \"new should call vm_exit_out_of_memory if failed to allocate symbol during DumpSharedSpaces\");\n+    assert(sym != nullptr, \"new should call vm_exit_out_of_memory if failed to allocate symbol during DumpSharedSpaces\");\n@@ -250,2 +250,2 @@\n-    assert(value != NULL, \"expected valid value\");\n-    assert(*value != NULL, \"value should point to a symbol\");\n+    assert(value != nullptr, \"expected valid value\");\n+    assert(*value != nullptr, \"value should point to a symbol\");\n@@ -289,1 +289,1 @@\n-  assert((sym == NULL) || sym->refcount() != 0, \"refcount must not be zero\");\n+  assert((sym == nullptr) || sym->refcount() != 0, \"refcount must not be zero\");\n@@ -296,1 +296,1 @@\n-  Symbol* sym = NULL;\n+  Symbol* sym = nullptr;\n@@ -304,1 +304,1 @@\n-    if (sym == NULL && DynamicArchive::is_mapped()) {\n+    if (sym == nullptr && DynamicArchive::is_mapped()) {\n@@ -317,1 +317,1 @@\n-    if (sym == NULL) {\n+    if (sym == nullptr) {\n@@ -323,1 +323,1 @@\n-    if (sym == NULL) {\n+    if (sym == nullptr) {\n@@ -325,1 +325,1 @@\n-      if (sym != NULL) {\n+      if (sym != nullptr) {\n@@ -336,1 +336,1 @@\n-  if (sym == NULL) {\n+  if (sym == nullptr) {\n@@ -351,1 +351,1 @@\n-  if (found == NULL) {\n+  if (found == nullptr) {\n@@ -369,2 +369,2 @@\n-    assert(value != NULL, \"expected valid value\");\n-    assert(*value != NULL, \"value should point to a symbol\");\n+    assert(value != nullptr, \"expected valid value\");\n+    assert(*value != nullptr, \"value should point to a symbol\");\n@@ -391,1 +391,1 @@\n-  SymbolTableGet() : _return(NULL) {}\n+  SymbolTableGet() : _return(nullptr) {}\n@@ -393,2 +393,2 @@\n-    assert(value != NULL, \"expected valid value\");\n-    assert(*value != NULL, \"value should point to a symbol\");\n+    assert(value != nullptr, \"expected valid value\");\n+    assert(*value != nullptr, \"value should point to a symbol\");\n@@ -410,1 +410,1 @@\n-  assert((sym == NULL) || sym->refcount() != 0, \"found dead symbol\");\n+  assert((sym == nullptr) || sym->refcount() != 0, \"found dead symbol\");\n@@ -463,1 +463,1 @@\n-    assert(lookup_shared(name, len, hash) == NULL, \"must have checked already\");\n+    assert(lookup_shared(name, len, hash) == nullptr, \"must have checked already\");\n@@ -475,1 +475,1 @@\n-  Symbol* sym = NULL;\n+  Symbol* sym = nullptr;\n@@ -499,1 +499,1 @@\n-  assert((sym == NULL) || sym->refcount() != 0, \"found dead symbol\");\n+  assert((sym == nullptr) || sym->refcount() != 0, \"found dead symbol\");\n@@ -507,1 +507,1 @@\n-  if (sym == NULL) {\n+  if (sym == nullptr) {\n@@ -519,2 +519,2 @@\n-    assert(value != NULL, \"expected valid value\");\n-    assert(*value != NULL, \"value should point to a symbol\");\n+    assert(value != nullptr, \"expected valid value\");\n+    assert(*value != nullptr, \"value should point to a symbol\");\n@@ -549,2 +549,2 @@\n-    guarantee(value != NULL, \"expected valid value\");\n-    guarantee(*value != NULL, \"value should point to a symbol\");\n+    guarantee(value != nullptr, \"expected valid value\");\n+    guarantee(*value != nullptr, \"value should point to a symbol\");\n@@ -581,2 +581,2 @@\n-    assert(value != NULL, \"expected valid value\");\n-    assert(*value != NULL, \"value should point to a symbol\");\n+    assert(value != nullptr, \"expected valid value\");\n+    assert(*value != nullptr, \"value should point to a symbol\");\n@@ -593,1 +593,1 @@\n-    assert(value != NULL, \"value should point to a symbol\");\n+    assert(value != nullptr, \"value should point to a symbol\");\n@@ -699,2 +699,2 @@\n-    assert(value != NULL, \"expected valid value\");\n-    assert(*value != NULL, \"value should point to a symbol\");\n+    assert(value != nullptr, \"expected valid value\");\n+    assert(*value != nullptr, \"value should point to a symbol\");\n@@ -711,2 +711,2 @@\n-    assert(value != NULL, \"expected valid value\");\n-    assert(*value != NULL, \"value should point to a symbol\");\n+    assert(value != nullptr, \"expected valid value\");\n+    assert(*value != nullptr, \"value should point to a symbol\");\n@@ -853,2 +853,2 @@\n-    assert(value != NULL, \"expected valid value\");\n-    assert(*value != NULL, \"value should point to a symbol\");\n+    assert(value != nullptr, \"expected valid value\");\n+    assert(*value != nullptr, \"value should point to a symbol\");\n","filename":"src\/hotspot\/share\/classfile\/symbolTable.cpp","additions":38,"deletions":38,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -92,1 +92,1 @@\n-  static Symbol* lookup_shared(const char* name, int len, unsigned int hash) NOT_CDS_RETURN_(NULL);\n+  static Symbol* lookup_shared(const char* name, int len, unsigned int hash) NOT_CDS_RETURN_(nullptr);\n@@ -125,1 +125,1 @@\n-  \/\/ NULL.  NO ALLOCATION IS GUARANTEED!\n+  \/\/ null.  NO ALLOCATION IS GUARANTEED!\n","filename":"src\/hotspot\/share\/classfile\/symbolTable.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -193,1 +193,1 @@\n-    return (class_loader() == NULL) ? ClassLoaderData::the_null_class_loader_data() :\n+    return (class_loader() == nullptr) ? ClassLoaderData::the_null_class_loader_data() :\n@@ -230,1 +230,1 @@\n-  if (class_loader == NULL) {\n+  if (class_loader == nullptr) {\n@@ -239,1 +239,1 @@\n-  if (class_loader == NULL) {\n+  if (class_loader == nullptr) {\n@@ -246,1 +246,1 @@\n-  \/\/ If class_loader is NULL or parallelCapable, the JVM doesn't acquire a lock while loading.\n+  \/\/ If class_loader is null or parallelCapable, the JVM doesn't acquire a lock while loading.\n@@ -258,1 +258,1 @@\n-  if (name == NULL) {\n+  if (name == nullptr) {\n@@ -268,1 +268,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -304,1 +304,1 @@\n-  \/\/ If the class is not found, ie, caller has checked that klass is NULL, throw the appropriate\n+  \/\/ If the class is not found, ie, caller has checked that klass is null, throw the appropriate\n@@ -320,1 +320,1 @@\n-  if (HAS_PENDING_EXCEPTION || klass == NULL) {\n+  if (HAS_PENDING_EXCEPTION || klass == nullptr) {\n@@ -332,1 +332,1 @@\n-    assert(class_name != NULL && !Signature::is_array(class_name), \"must be\");\n+    assert(class_name != nullptr && !Signature::is_array(class_name), \"must be\");\n@@ -355,1 +355,1 @@\n-  Klass* k = NULL;\n+  Klass* k = nullptr;\n@@ -363,1 +363,1 @@\n-    if (k != NULL) {\n+    if (k != nullptr) {\n@@ -411,1 +411,1 @@\n-  assert(super_name != NULL, \"null superclass for resolving\");\n+  assert(super_name != nullptr, \"null superclass for resolving\");\n@@ -441,2 +441,2 @@\n-    if (klassk != NULL && is_superclass &&\n-        ((quicksuperk = klassk->java_super()) != NULL) &&\n+    if (klassk != nullptr && is_superclass &&\n+        ((quicksuperk = klassk->java_super()) != nullptr) &&\n@@ -484,1 +484,1 @@\n-  if (HAS_PENDING_EXCEPTION || superk == NULL) {\n+  if (HAS_PENDING_EXCEPTION || superk == nullptr) {\n@@ -521,1 +521,1 @@\n-  assert(lockObject() != NULL, \"lockObject must be non-NULL\");\n+  assert(lockObject() != nullptr, \"lockObject must be non-nullptr\");\n@@ -571,1 +571,1 @@\n-  if (oldprobe != NULL) {\n+  if (oldprobe != nullptr) {\n@@ -577,1 +577,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -581,1 +581,1 @@\n-      while (oldprobe != NULL &&\n+      while (oldprobe != nullptr &&\n@@ -602,1 +602,1 @@\n-          return NULL;\n+          return nullptr;\n@@ -607,1 +607,1 @@\n-        if (check != NULL) {\n+        if (check != nullptr) {\n@@ -616,1 +616,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -620,2 +620,2 @@\n-  assert(event != NULL, \"invariant\");\n-  assert(k != NULL, \"invariant\");\n+  assert(event != nullptr, \"invariant\");\n+  assert(k != nullptr, \"invariant\");\n@@ -632,1 +632,1 @@\n-\/\/ This can return NULL, an exception or an InstanceKlass.\n+\/\/ This can return null, an exception or an InstanceKlass.\n@@ -638,1 +638,1 @@\n-  assert(name != NULL && !Signature::is_array(name) &&\n+  assert(name != nullptr && !Signature::is_array(name) &&\n@@ -656,1 +656,1 @@\n-  if (probe != NULL) return probe;\n+  if (probe != nullptr) return probe;\n@@ -671,2 +671,2 @@\n-  InstanceKlass* loaded_class = NULL;\n-  Symbol* superclassname = NULL;\n+  InstanceKlass* loaded_class = nullptr;\n+  Symbol* superclassname = nullptr;\n@@ -683,1 +683,1 @@\n-    if (check != NULL) {\n+    if (check != nullptr) {\n@@ -688,1 +688,1 @@\n-      if (placeholder != NULL && placeholder->super_load_in_progress()) {\n+      if (placeholder != nullptr && placeholder->super_load_in_progress()) {\n@@ -691,1 +691,1 @@\n-         assert(superclassname != NULL, \"superclass has to have a name\");\n+         assert(superclassname != nullptr, \"superclass has to have a name\");\n@@ -706,1 +706,1 @@\n-  if (loaded_class == NULL) {\n+  if (loaded_class == nullptr) {\n@@ -738,1 +738,1 @@\n-      if (!throw_circularity_error && loaded_class == NULL) {\n+      if (!throw_circularity_error && loaded_class == nullptr) {\n@@ -740,1 +740,1 @@\n-        if (check != NULL) {\n+        if (check != nullptr) {\n@@ -747,1 +747,1 @@\n-                                                                      NULL,\n+                                                                      nullptr,\n@@ -766,1 +766,1 @@\n-    if (loaded_class == NULL) {\n+    if (loaded_class == nullptr) {\n@@ -781,2 +781,2 @@\n-  if (HAS_PENDING_EXCEPTION || loaded_class == NULL) {\n-    return NULL;\n+  if (HAS_PENDING_EXCEPTION || loaded_class == nullptr) {\n+    return nullptr;\n@@ -793,1 +793,1 @@\n-  if (protection_domain() != NULL) {\n+  if (protection_domain() != nullptr) {\n@@ -824,1 +824,1 @@\n-  if (loader_data == NULL) {\n+  if (loader_data == nullptr) {\n@@ -827,1 +827,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -835,1 +835,1 @@\n-\/\/ return NULL in case of error.\n+\/\/ return null in case of error.\n@@ -840,2 +840,2 @@\n-  Klass* k = NULL;\n-  assert(class_name != NULL, \"class name must be non NULL\");\n+  Klass* k = nullptr;\n+  assert(class_name != nullptr, \"class name must be non nullptr\");\n@@ -855,1 +855,1 @@\n-    if (k != NULL) {\n+    if (k != nullptr) {\n@@ -884,1 +884,1 @@\n-  assert(st != NULL, \"invariant\");\n+  assert(st != nullptr, \"invariant\");\n@@ -893,1 +893,1 @@\n-  assert(k != NULL, \"no klass created\");\n+  assert(k != nullptr, \"no klass created\");\n@@ -923,1 +923,1 @@\n-\/\/ Note: class_name can be NULL. In that case we do not know the name of\n+\/\/ Note: class_name can be null. In that case we do not know the name of\n@@ -926,1 +926,1 @@\n-\/\/ not return NULL without a pending exception.\n+\/\/ not return null without a pending exception.\n@@ -947,1 +947,1 @@\n- InstanceKlass* k = NULL;\n+ InstanceKlass* k = nullptr;\n@@ -959,1 +959,1 @@\n-  if (k == NULL) {\n+  if (k == nullptr) {\n@@ -963,1 +963,1 @@\n-  assert(k != NULL, \"no klass created\");\n+  assert(k != nullptr, \"no klass created\");\n@@ -965,1 +965,1 @@\n-  assert(class_name == NULL || class_name == h_name, \"name mismatch\");\n+  assert(class_name == nullptr || class_name == h_name, \"name mismatch\");\n@@ -978,1 +978,1 @@\n-      assert(k != NULL, \"Must have an instance klass here!\");\n+      assert(k != nullptr, \"Must have an instance klass here!\");\n@@ -980,1 +980,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -1015,1 +1015,1 @@\n-    if (class_loader() != NULL) {\n+    if (class_loader() != nullptr) {\n@@ -1056,1 +1056,1 @@\n-    assert(scp_entry != NULL, \"must be\");\n+    assert(scp_entry != nullptr, \"must be\");\n@@ -1067,1 +1067,1 @@\n-  if (pkg_entry == NULL) {\n+  if (pkg_entry == nullptr) {\n@@ -1071,1 +1071,1 @@\n-    if (pkg_name != NULL) {\n+    if (pkg_name != nullptr) {\n@@ -1076,2 +1076,2 @@\n-  ModuleEntry* mod_entry = (pkg_entry == NULL) ? NULL : pkg_entry->module();\n-  bool should_be_in_named_module = (mod_entry != NULL && mod_entry->is_named());\n+  ModuleEntry* mod_entry = (pkg_entry == nullptr) ? nullptr : pkg_entry->module();\n+  bool should_be_in_named_module = (mod_entry != nullptr && mod_entry->is_named());\n@@ -1114,2 +1114,2 @@\n-  \/\/ + Don't check if loader data is NULL, ie. the super_type isn't fully loaded.\n-  if (!super_type->is_shared_unregistered_class() && super_type->class_loader_data() != NULL) {\n+  \/\/ + Don't check if loader data is null, ie. the super_type isn't fully loaded.\n+  if (!super_type->is_shared_unregistered_class() && super_type->class_loader_data() != nullptr) {\n@@ -1144,1 +1144,1 @@\n-  if (ik->super() != NULL &&\n+  if (ik->super() != nullptr &&\n@@ -1173,1 +1173,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1178,1 +1178,1 @@\n-  InstanceKlass* loaded_ik = load_shared_class(ik, class_loader, protection_domain, NULL, pkg_entry, CHECK_NULL);\n+  InstanceKlass* loaded_ik = load_shared_class(ik, class_loader, protection_domain, nullptr, pkg_entry, CHECK_NULL);\n@@ -1180,1 +1180,1 @@\n-  if (loaded_ik != NULL) {\n+  if (loaded_ik != nullptr) {\n@@ -1200,1 +1200,1 @@\n-  assert(ik != NULL, \"sanity\");\n+  assert(ik != nullptr, \"sanity\");\n@@ -1205,1 +1205,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1209,1 +1209,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1212,1 +1212,1 @@\n-  InstanceKlass* new_ik = NULL;\n+  InstanceKlass* new_ik = nullptr;\n@@ -1219,1 +1219,1 @@\n-  if (new_ik != NULL) {\n+  if (new_ik != nullptr) {\n@@ -1251,1 +1251,1 @@\n-  ik->print_class_load_logging(loader_data, NULL, NULL);\n+  ik->print_class_load_logging(loader_data, nullptr, nullptr);\n@@ -1270,1 +1270,1 @@\n-    PackageEntry* pkg_entry = NULL;\n+    PackageEntry* pkg_entry = nullptr;\n@@ -1275,1 +1275,1 @@\n-    if (pkg_name != NULL) {\n+    if (pkg_name != nullptr) {\n@@ -1287,1 +1287,1 @@\n-      if (pkg_entry == NULL || pkg_entry->in_unnamed_module()) {\n+      if (pkg_entry == nullptr || pkg_entry->in_unnamed_module()) {\n@@ -1296,1 +1296,1 @@\n-          return NULL;\n+          return nullptr;\n@@ -1303,1 +1303,1 @@\n-          return NULL;\n+          return nullptr;\n@@ -1309,1 +1309,1 @@\n-      if (pkg_name == NULL || pkg_entry == NULL || pkg_entry->in_unnamed_module()) {\n+      if (pkg_name == nullptr || pkg_entry == nullptr || pkg_entry->in_unnamed_module()) {\n@@ -1318,1 +1318,1 @@\n-           return NULL;\n+           return nullptr;\n@@ -1331,1 +1331,1 @@\n-    InstanceKlass* k = NULL;\n+    InstanceKlass* k = nullptr;\n@@ -1338,1 +1338,1 @@\n-      if (ik != NULL && ik->is_shared_boot_class() && !ik->shared_loading_failed()) {\n+      if (ik != nullptr && ik->is_shared_boot_class() && !ik->shared_loading_failed()) {\n@@ -1340,1 +1340,1 @@\n-        k = load_shared_class(ik, class_loader, Handle(), NULL,  pkg_entry, CHECK_NULL);\n+        k = load_shared_class(ik, class_loader, Handle(), nullptr,  pkg_entry, CHECK_NULL);\n@@ -1345,1 +1345,1 @@\n-    if (k == NULL) {\n+    if (k == nullptr) {\n@@ -1352,1 +1352,1 @@\n-    if (k != NULL) {\n+    if (k != nullptr) {\n@@ -1394,1 +1394,1 @@\n-    if ((obj != NULL) && !(java_lang_Class::is_primitive(obj))) {\n+    if ((obj != nullptr) && !(java_lang_Class::is_primitive(obj))) {\n@@ -1403,2 +1403,2 @@\n-    \/\/ Class is not found or has the wrong name, return NULL\n-    return NULL;\n+    \/\/ Class is not found or has the wrong name, return null\n+    return nullptr;\n@@ -1416,1 +1416,1 @@\n-  if (loaded_class != NULL &&\n+  if (loaded_class != nullptr &&\n@@ -1483,1 +1483,1 @@\n-  if (k->class_loader() != NULL) {\n+  if (k->class_loader() != nullptr) {\n@@ -1543,1 +1543,1 @@\n-      if (check != NULL) {\n+      if (check != nullptr) {\n@@ -1550,1 +1550,1 @@\n-                                                             PlaceholderTable::DEFINE_CLASS, NULL, THREAD);\n+                                                             PlaceholderTable::DEFINE_CLASS, nullptr, THREAD);\n@@ -1555,1 +1555,1 @@\n-    while (probe->definer() != NULL) {\n+    while (probe->definer() != nullptr) {\n@@ -1561,1 +1561,1 @@\n-    if (is_parallelDefine(class_loader) && (probe->instance_klass() != NULL)) {\n+    if (is_parallelDefine(class_loader) && (probe->instance_klass() != nullptr)) {\n@@ -1567,1 +1567,1 @@\n-      assert(check != NULL, \"definer missed recording success\");\n+      assert(check != nullptr, \"definer missed recording success\");\n@@ -1582,1 +1582,1 @@\n-    assert(probe != NULL, \"DEFINE_CLASS placeholder lost?\");\n+    assert(probe != nullptr, \"DEFINE_CLASS placeholder lost?\");\n@@ -1586,1 +1586,1 @@\n-    probe->set_definer(NULL);\n+    probe->set_definer(nullptr);\n@@ -1591,1 +1591,1 @@\n-  return HAS_PENDING_EXCEPTION ? NULL : k;\n+  return HAS_PENDING_EXCEPTION ? nullptr : k;\n@@ -1602,1 +1602,1 @@\n-    assert(defined_k != NULL, \"Should have a klass if there's no exception\");\n+    assert(defined_k != nullptr, \"Should have a klass if there's no exception\");\n@@ -1605,1 +1605,1 @@\n-    assert(defined_k == NULL, \"Should not have a klass if there's an exception\");\n+    assert(defined_k == nullptr, \"Should not have a klass if there's an exception\");\n@@ -1618,1 +1618,1 @@\n-  assert(k != NULL, \"just checking\");\n+  assert(k != nullptr, \"just checking\");\n@@ -1653,1 +1653,1 @@\n-      MutexLocker ml2(is_concurrent ? Module_lock : NULL);\n+      MutexLocker ml2(is_concurrent ? Module_lock : nullptr);\n@@ -1656,1 +1656,1 @@\n-      MutexLocker ml1(is_concurrent ? SystemDictionary_lock : NULL);\n+      MutexLocker ml1(is_concurrent ? SystemDictionary_lock : nullptr);\n@@ -1679,1 +1679,1 @@\n-    MutexLocker ml(is_concurrent ? ClassInitError_lock : NULL);\n+    MutexLocker ml(is_concurrent ? ClassInitError_lock : nullptr);\n@@ -1743,1 +1743,1 @@\n-    if (check != NULL) {\n+    if (check != nullptr) {\n@@ -1765,1 +1765,1 @@\n-        if (existing_klass != NULL && existing_klass->class_loader_data() != loader_data) {\n+        if (existing_klass != nullptr && existing_klass->class_loader_data() != loader_data) {\n@@ -1798,1 +1798,1 @@\n-  if (sd_check == NULL) {\n+  if (sd_check == nullptr) {\n@@ -1816,1 +1816,1 @@\n-  if (klass != NULL)\n+  if (klass != nullptr)\n@@ -1835,1 +1835,1 @@\n-    if (klass != NULL) {\n+    if (klass != nullptr) {\n@@ -1854,1 +1854,1 @@\n-  Symbol* constraint_name = NULL;\n+  Symbol* constraint_name = nullptr;\n@@ -1884,1 +1884,1 @@\n-    if (Arguments::is_dumping_archive() && klass_being_linked != NULL &&\n+    if (Arguments::is_dumping_archive() && klass_being_linked != nullptr &&\n@@ -1906,1 +1906,1 @@\n-    if (entry == NULL) {\n+    if (entry == nullptr) {\n@@ -1917,1 +1917,1 @@\n-\/\/ Lookup resolution error table. Returns error if found, otherwise NULL.\n+\/\/ Lookup resolution error table. Returns error if found, otherwise null.\n@@ -1924,1 +1924,1 @@\n-    if (entry != NULL) {\n+    if (entry != nullptr) {\n@@ -1930,1 +1930,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -1946,1 +1946,1 @@\n-    if (entry != NULL && entry->nest_host_error() == NULL) {\n+    if (entry != nullptr && entry->nest_host_error() == nullptr) {\n@@ -1963,1 +1963,1 @@\n-    if (entry != NULL) {\n+    if (entry != nullptr) {\n@@ -1966,1 +1966,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -2019,1 +2019,1 @@\n-\/\/ NULL if no constraint failed.  No exception except OOME is thrown.\n+\/\/ null if no constraint failed.  No exception except OOME is thrown.\n@@ -2027,1 +2027,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -2041,1 +2041,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -2098,1 +2098,1 @@\n-    if (m != NULL) {\n+    if (m != nullptr) {\n@@ -2106,1 +2106,1 @@\n-        if (appendix != NULL) { ls.print(\"appendix = \"); appendix->print_on(&ls); }\n+        if (appendix != nullptr) { ls.print(\"appendix = \"); appendix->print_on(&ls); }\n@@ -2137,1 +2137,1 @@\n-  assert(appendix_box->obj_at(0) == NULL, \"\");\n+  assert(appendix_box->obj_at(0) == nullptr, \"\");\n@@ -2140,1 +2140,1 @@\n-  if (accessing_klass == NULL || method_type.is_null()) {\n+  if (accessing_klass == nullptr || method_type.is_null()) {\n@@ -2192,1 +2192,1 @@\n-  assert(accessing_klass == NULL || (class_loader.is_null() && protection_domain.is_null()),\n+  assert(accessing_klass == nullptr || (class_loader.is_null() && protection_domain.is_null()),\n@@ -2198,1 +2198,1 @@\n-  if (accessing_klass != NULL) {\n+  if (accessing_klass != nullptr) {\n@@ -2204,1 +2204,1 @@\n-  if (mirror_oop == NULL) {\n+  if (mirror_oop == nullptr) {\n@@ -2209,1 +2209,1 @@\n-  if (accessing_klass != NULL) {\n+  if (accessing_klass != nullptr) {\n@@ -2212,1 +2212,1 @@\n-    if (sel_klass != NULL) {\n+    if (sel_klass != nullptr) {\n@@ -2244,1 +2244,1 @@\n-  if (accessing_klass != NULL) {\n+  if (accessing_klass != nullptr) {\n@@ -2255,1 +2255,1 @@\n-    oop mirror = NULL;\n+    oop mirror = nullptr;\n@@ -2260,1 +2260,1 @@\n-      if (mirror == NULL || (ss.is_reference() && !is_always_visible_class(mirror))) {\n+      if (mirror == nullptr || (ss.is_reference() && !is_always_visible_class(mirror))) {\n@@ -2270,1 +2270,1 @@\n-    assert(mirror != NULL, \"%s\", ss.as_symbol()->as_C_string());\n+    assert(mirror != nullptr, \"%s\", ss.as_symbol()->as_C_string());\n@@ -2277,1 +2277,1 @@\n-    if (!java_lang_Class::is_primitive(mirror) && accessing_klass != NULL) {\n+    if (!java_lang_Class::is_primitive(mirror) && accessing_klass != nullptr) {\n@@ -2279,1 +2279,1 @@\n-      mirror = NULL;  \/\/ safety\n+      mirror = nullptr;  \/\/ safety\n@@ -2301,1 +2301,1 @@\n-    assert(method_type != NULL, \"unexpected null\");\n+    assert(method_type != nullptr, \"unexpected null\");\n@@ -2322,1 +2322,1 @@\n-    if (accessing_klass != NULL) {\n+    if (accessing_klass != nullptr) {\n@@ -2343,1 +2343,1 @@\n-  if (caller == NULL) {\n+  if (caller == nullptr) {\n@@ -2394,1 +2394,1 @@\n-  if (bootstrap_specifier.caller() == NULL || bootstrap_specifier.type_arg().is_null()) {\n+  if (bootstrap_specifier.caller() == nullptr || bootstrap_specifier.type_arg().is_null()) {\n@@ -2403,1 +2403,1 @@\n-    assert(appendix_box->obj_at(0) == NULL, \"\");\n+    assert(appendix_box->obj_at(0) == nullptr, \"\");\n@@ -2445,1 +2445,1 @@\n-  assert(m != NULL, \"Unexpected NULL Method*\");\n+  assert(m != nullptr, \"Unexpected nullptr Method*\");\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":144,"deletions":144,"binary":false,"changes":288,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,1 @@\n-\/\/ represented as NULL.\n+\/\/ represented as null.\n@@ -98,1 +98,1 @@\n-  \/\/ Loads the class if needed. If not found NULL is returned.\n+  \/\/ Loads the class if needed. If not found null is returned.\n@@ -142,1 +142,1 @@\n-  \/\/ Lookup an already loaded class. If not found NULL is returned.\n+  \/\/ Lookup an already loaded class. If not found null is returned.\n@@ -148,1 +148,1 @@\n-  \/\/ If not found NULL is returned.\n+  \/\/ If not found null is returned.\n@@ -158,1 +158,1 @@\n-  \/\/ Return NULL if the class is not found.\n+  \/\/ Return null if the class is not found.\n@@ -276,1 +276,1 @@\n-                                   Symbol* message, Symbol* cause = NULL, Symbol* cause_msg = NULL);\n+                                   Symbol* message, Symbol* cause = nullptr, Symbol* cause_msg = nullptr);\n@@ -357,1 +357,1 @@\n-  static bool is_boot_class_loader(oop class_loader) { return class_loader == NULL; }\n+  static bool is_boot_class_loader(oop class_loader) { return class_loader == nullptr; }\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.hpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -79,4 +79,4 @@\n-DumpTimeSharedClassTable* SystemDictionaryShared::_dumptime_table = NULL;\n-DumpTimeSharedClassTable* SystemDictionaryShared::_cloned_dumptime_table = NULL;\n-DumpTimeLambdaProxyClassDictionary* SystemDictionaryShared::_dumptime_lambda_proxy_class_dictionary = NULL;\n-DumpTimeLambdaProxyClassDictionary* SystemDictionaryShared::_cloned_dumptime_lambda_proxy_class_dictionary = NULL;\n+DumpTimeSharedClassTable* SystemDictionaryShared::_dumptime_table = nullptr;\n+DumpTimeSharedClassTable* SystemDictionaryShared::_cloned_dumptime_table = nullptr;\n+DumpTimeLambdaProxyClassDictionary* SystemDictionaryShared::_dumptime_lambda_proxy_class_dictionary = nullptr;\n+DumpTimeLambdaProxyClassDictionary* SystemDictionaryShared::_cloned_dumptime_lambda_proxy_class_dictionary = nullptr;\n@@ -92,1 +92,1 @@\n-  if (ik != NULL && !ik->shared_loading_failed()) {\n+  if (ik != nullptr && !ik->shared_loading_failed()) {\n@@ -99,1 +99,1 @@\n-      return load_shared_class(ik, class_loader, protection_domain, NULL, pkg_entry, THREAD);\n+      return load_shared_class(ik, class_loader, protection_domain, nullptr, pkg_entry, THREAD);\n@@ -102,1 +102,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -112,1 +112,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -114,2 +114,2 @@\n-  if (class_name == NULL) {  \/\/ don't do this for hidden classes\n-    return NULL;\n+  if (class_name == nullptr) {  \/\/ don't do this for hidden classes\n+    return nullptr;\n@@ -121,1 +121,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -127,2 +127,2 @@\n-  if (record == NULL) {\n-    return NULL;\n+  if (record == nullptr) {\n+    return nullptr;\n@@ -135,1 +135,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -153,1 +153,1 @@\n-    if (ik->class_loader_data() != NULL) {\n+    if (ik->class_loader_data() != nullptr) {\n@@ -156,1 +156,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -173,1 +173,1 @@\n-  if (shared_klass == NULL || HAS_PENDING_EXCEPTION) {\n+  if (shared_klass == nullptr || HAS_PENDING_EXCEPTION) {\n@@ -175,1 +175,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -181,1 +181,1 @@\n-\/\/ Guaranteed to return non-NULL value for non-shared classes.\n+\/\/ Guaranteed to return non-null value for non-shared classes.\n@@ -193,1 +193,1 @@\n-  assert(info != NULL, \"must be\");\n+  assert(info != nullptr, \"must be\");\n@@ -205,1 +205,1 @@\n-  if (info == NULL) {\n+  if (info == nullptr) {\n@@ -207,1 +207,1 @@\n-    assert(info != NULL, \"supertypes of any classes in _dumptime_table must either be shared, or must also be in _dumptime_table\");\n+    assert(info != nullptr, \"supertypes of any classes in _dumptime_table must either be shared, or must also be in _dumptime_table\");\n@@ -239,1 +239,1 @@\n-  return (info != NULL) ? info->_is_archived_lambda_proxy : false;\n+  return (info != nullptr) ? info->_is_archived_lambda_proxy : false;\n@@ -244,1 +244,1 @@\n-  if (info != NULL) {\n+  if (info != nullptr) {\n@@ -252,1 +252,1 @@\n-  return (info != NULL) ? info->is_early_klass() : false;\n+  return (info != nullptr) ? info->is_early_klass() : false;\n@@ -282,1 +282,1 @@\n-  if (k->signers() != NULL) {\n+  if (k->signers() != nullptr) {\n@@ -319,1 +319,1 @@\n-  if (super != NULL && check_for_exclusion(super, NULL)) {\n+  if (super != nullptr && check_for_exclusion(super, nullptr)) {\n@@ -329,1 +329,1 @@\n-    if (check_for_exclusion(intf, NULL)) {\n+    if (check_for_exclusion(intf, nullptr)) {\n@@ -341,1 +341,1 @@\n-  return (class_loader == NULL ||\n+  return (class_loader == nullptr ||\n@@ -392,1 +392,1 @@\n-  InstanceKlass* k = NULL;\n+  InstanceKlass* k = nullptr;\n@@ -395,1 +395,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -409,1 +409,1 @@\n-      assert(get_loader_lock_or_null(class_loader) == NULL, \"ObjectLocker not required\");\n+      assert(get_loader_lock_or_null(class_loader) == nullptr, \"ObjectLocker not required\");\n@@ -413,1 +413,1 @@\n-        if (check != NULL) {\n+        if (check != nullptr) {\n@@ -419,1 +419,1 @@\n-      if (k != NULL) {\n+      if (k != nullptr) {\n@@ -433,1 +433,1 @@\n-static UnregisteredClassesTable* _unregistered_classes_table = NULL;\n+static UnregisteredClassesTable* _unregistered_classes_table = nullptr;\n@@ -443,1 +443,1 @@\n-  if (_unregistered_classes_table == NULL) {\n+  if (_unregistered_classes_table == nullptr) {\n@@ -469,1 +469,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -473,1 +473,1 @@\n-  if (parser == NULL) {\n+  if (parser == nullptr) {\n@@ -475,1 +475,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -489,1 +489,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -525,1 +525,1 @@\n-  if (_unregistered_classes_table != NULL) {\n+  if (_unregistered_classes_table != nullptr) {\n@@ -527,1 +527,1 @@\n-    \/\/ set it to NULL. This ensure no classes with the same name can be\n+    \/\/ set it to null. This ensure no classes with the same name can be\n@@ -531,2 +531,2 @@\n-    if (v != NULL) {\n-      *v = NULL;\n+    if (v != nullptr) {\n+      *v = nullptr;\n@@ -547,1 +547,1 @@\n-  if (k->java_super() != NULL && has_been_redefined(k->java_super())) {\n+  if (k->java_super() != nullptr && has_been_redefined(k->java_super())) {\n@@ -566,1 +566,1 @@\n-  guarantee(info != NULL, \"Class %s must be entered into _dumptime_table\", name);\n+  guarantee(info != nullptr, \"Class %s must be entered into _dumptime_table\", name);\n@@ -674,1 +674,1 @@\n-  return (p == NULL) ? false : p->failed_verification();\n+  return (p == nullptr) ? false : p->failed_verification();\n@@ -751,1 +751,1 @@\n-  assert(java_lang_Class::class_data(lambda_ik->java_mirror()) == NULL, \"must not have class data\");\n+  assert(java_lang_Class::class_data(lambda_ik->java_mirror()) == nullptr, \"must not have class data\");\n@@ -758,1 +758,1 @@\n-  assert(nest_host != NULL, \"unexpected NULL nest_host\");\n+  assert(nest_host != nullptr, \"unexpected nullptr nest_host\");\n@@ -761,1 +761,1 @@\n-  if (info != NULL && !lambda_ik->is_non_strong_hidden() && is_builtin(lambda_ik) && is_builtin(caller_ik)\n+  if (info != nullptr && !lambda_ik->is_non_strong_hidden() && is_builtin(lambda_ik) && is_builtin(caller_ik)\n@@ -789,1 +789,1 @@\n-  if (info == NULL) {\n+  if (info == nullptr) {\n@@ -792,2 +792,2 @@\n-  InstanceKlass* proxy_klass = NULL;\n-  if (info != NULL) {\n+  InstanceKlass* proxy_klass = nullptr;\n+  if (info != nullptr) {\n@@ -797,1 +797,1 @@\n-      while (curr_klass->next_link() != NULL) {\n+      while (curr_klass->next_link() != nullptr) {\n@@ -804,1 +804,1 @@\n-      prev_klass->set_next_link(NULL);\n+      prev_klass->set_next_link(nullptr);\n@@ -833,1 +833,1 @@\n-  if (caller_ik->class_loader() != NULL) {\n+  if (caller_ik->class_loader() != nullptr) {\n@@ -838,1 +838,1 @@\n-  assert(shared_nest_host != NULL, \"unexpected NULL _nest_host\");\n+  assert(shared_nest_host != nullptr, \"unexpected nullptr _nest_host\");\n@@ -843,2 +843,2 @@\n-  if (loaded_lambda == NULL) {\n-    return NULL;\n+  if (loaded_lambda == nullptr) {\n+    return nullptr;\n@@ -917,1 +917,1 @@\n-    return (oop)NULL;\n+    return (oop)nullptr;\n@@ -967,1 +967,1 @@\n-  assert(klass_loader != NULL, \"should not be called for boot loader\");\n+  assert(klass_loader != nullptr, \"should not be called for boot loader\");\n@@ -994,1 +994,1 @@\n-    assert(info != NULL, \"Sanity\");\n+    assert(info != nullptr, \"Sanity\");\n@@ -1034,1 +1034,1 @@\n-  if (bsi->arg_values() == NULL || !bsi->arg_values()->is_objArray()) {\n+  if (bsi->arg_values() == nullptr || !bsi->arg_values()->is_objArray()) {\n@@ -1277,1 +1277,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1281,1 +1281,1 @@\n-  const RunTimeClassInfo* record = NULL;\n+  const RunTimeClassInfo* record = nullptr;\n@@ -1302,1 +1302,1 @@\n-  if (record == NULL && DynamicArchive::is_mapped()) {\n+  if (record == nullptr && DynamicArchive::is_mapped()) {\n@@ -1313,1 +1313,1 @@\n-  if (record != NULL) {\n+  if (record != nullptr) {\n@@ -1319,1 +1319,1 @@\n-       return NULL;\n+       return nullptr;\n@@ -1323,1 +1323,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1448,2 +1448,2 @@\n-    assert(_table != NULL, \"_dumptime_table is NULL\");\n-    assert(_cloned_table != NULL, \"_cloned_table is NULL\");\n+    assert(_table != nullptr, \"_dumptime_table is nullptr\");\n+    assert(_cloned_table != nullptr, \"_cloned_table is nullptr\");\n@@ -1467,2 +1467,2 @@\n-    assert(_table != NULL, \"_dumptime_table is NULL\");\n-    assert(_cloned_table != NULL, \"_cloned_table is NULL\");\n+    assert(_table != nullptr, \"_dumptime_table is nullptr\");\n+    assert(_cloned_table != nullptr, \"_cloned_table is nullptr\");\n@@ -1499,1 +1499,1 @@\n-  assert(_cloned_dumptime_table == NULL, \"_cloned_dumptime_table must be cleaned\");\n+  assert(_cloned_dumptime_table == nullptr, \"_cloned_dumptime_table must be cleaned\");\n@@ -1505,1 +1505,1 @@\n-  assert(_cloned_dumptime_lambda_proxy_class_dictionary == NULL,\n+  assert(_cloned_dumptime_lambda_proxy_class_dictionary == nullptr,\n@@ -1518,1 +1518,1 @@\n-  _cloned_dumptime_table = NULL;\n+  _cloned_dumptime_table = nullptr;\n@@ -1522,1 +1522,1 @@\n-  _cloned_dumptime_lambda_proxy_class_dictionary = NULL;\n+  _cloned_dumptime_lambda_proxy_class_dictionary = nullptr;\n@@ -1534,2 +1534,2 @@\n-    bool always_exclude = SystemDictionaryShared::check_for_exclusion(caller_ik, NULL) ||\n-                          SystemDictionaryShared::check_for_exclusion(nest_host, NULL);\n+    bool always_exclude = SystemDictionaryShared::check_for_exclusion(caller_ik, nullptr) ||\n+                          SystemDictionaryShared::check_for_exclusion(nest_host, nullptr);\n@@ -1539,1 +1539,1 @@\n-      if (always_exclude || SystemDictionaryShared::check_for_exclusion(ik, NULL)) {\n+      if (always_exclude || SystemDictionaryShared::check_for_exclusion(ik, nullptr)) {\n","filename":"src\/hotspot\/share\/classfile\/systemDictionaryShared.cpp","additions":81,"deletions":81,"binary":false,"changes":162,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -130,2 +130,2 @@\n-    assert(THREAD != NULL, \"Current thread is NULL\");\n-    assert(_klass != NULL, \"InstanceKlass is NULL\");\n+    assert(THREAD != nullptr, \"Current thread is nullptr\");\n+    assert(_klass != nullptr, \"InstanceKlass is nullptr\");\n@@ -189,1 +189,1 @@\n-  \/\/ Guaranteed to return non-NULL value for non-shared classes.\n+  \/\/ Guaranteed to return non-null value for non-shared classes.\n@@ -281,2 +281,2 @@\n-                                                      Symbol* instantiated_method_type) NOT_CDS_RETURN_(NULL);\n-  static InstanceKlass* get_shared_nest_host(InstanceKlass* lambda_ik) NOT_CDS_RETURN_(NULL);\n+                                                      Symbol* instantiated_method_type) NOT_CDS_RETURN_(nullptr);\n+  static InstanceKlass* get_shared_nest_host(InstanceKlass* lambda_ik) NOT_CDS_RETURN_(nullptr);\n@@ -284,1 +284,1 @@\n-                                                          InstanceKlass* caller_ik, TRAPS) NOT_CDS_RETURN_(NULL);\n+                                                          InstanceKlass* caller_ik, TRAPS) NOT_CDS_RETURN_(nullptr);\n","filename":"src\/hotspot\/share\/classfile\/systemDictionaryShared.hpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -190,1 +190,1 @@\n-        if (name() != NULL) {\n+        if (name() != nullptr) {\n@@ -193,1 +193,1 @@\n-          st->print_cr(\"NULL\");\n+          st->print_cr(\"nullptr\");\n","filename":"src\/hotspot\/share\/classfile\/verificationType.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -74,1 +74,1 @@\n-static verify_byte_codes_fn_t volatile _verify_byte_codes_fn = NULL;\n+static verify_byte_codes_fn_t volatile _verify_byte_codes_fn = nullptr;\n@@ -78,1 +78,1 @@\n-  if (_verify_byte_codes_fn != NULL)\n+  if (_verify_byte_codes_fn != nullptr)\n@@ -83,1 +83,1 @@\n-  if (_verify_byte_codes_fn != NULL)\n+  if (_verify_byte_codes_fn != nullptr)\n@@ -90,1 +90,1 @@\n-    return NULL; \/\/ Caller will throw VerifyError\n+    return nullptr; \/\/ Caller will throw VerifyError\n@@ -93,2 +93,2 @@\n-  if (lib_handle == NULL)\n-    return NULL; \/\/ Caller will throw VerifyError\n+  if (lib_handle == nullptr)\n+    return nullptr; \/\/ Caller will throw VerifyError\n@@ -97,2 +97,2 @@\n-  if (fn == NULL)\n-    return NULL; \/\/ Caller will throw VerifyError\n+  if (fn == nullptr)\n+    return nullptr; \/\/ Caller will throw VerifyError\n@@ -107,1 +107,1 @@\n-  return (class_loader == NULL || !should_verify_class) ?\n+  return (class_loader == nullptr || !should_verify_class) ?\n@@ -122,1 +122,1 @@\n-  assert(verify_class != NULL, \"Unexpected null verify_class\");\n+  assert(verify_class != nullptr, \"Unexpected null verify_class\");\n@@ -125,1 +125,1 @@\n-  const char* source_file = (s != NULL ? s->as_C_string() : NULL);\n+  const char* source_file = (s != nullptr ? s->as_C_string() : nullptr);\n@@ -129,1 +129,1 @@\n-  if (source_file != NULL) {\n+  if (source_file != nullptr) {\n@@ -138,1 +138,1 @@\n-  if (pending_exception != NULL) {\n+  if (pending_exception != nullptr) {\n@@ -141,1 +141,1 @@\n-    if (message != NULL) {\n+    if (message != nullptr) {\n@@ -149,1 +149,1 @@\n-  } else if (exception_name != NULL) {\n+  } else if (exception_name != nullptr) {\n@@ -168,1 +168,1 @@\n-  if (klass->java_mirror() != NULL) {\n+  if (klass->java_mirror() != nullptr) {\n@@ -189,1 +189,1 @@\n-  Symbol* exception_name = NULL;\n+  Symbol* exception_name = nullptr;\n@@ -191,2 +191,2 @@\n-  char* message_buffer = NULL;\n-  char* exception_message = NULL;\n+  char* message_buffer = nullptr;\n+  char* exception_message = nullptr;\n@@ -219,1 +219,1 @@\n-    if (exception_name != NULL) {\n+    if (exception_name != nullptr) {\n@@ -242,1 +242,1 @@\n-  } else if (exception_name == NULL) {\n+  } else if (exception_name == nullptr) {\n@@ -251,1 +251,1 @@\n-    while (kls != NULL) {\n+    while (kls != nullptr) {\n@@ -261,1 +261,1 @@\n-    if (message_buffer != NULL) {\n+    if (message_buffer != nullptr) {\n@@ -264,1 +264,1 @@\n-    assert(exception_message != NULL, \"\");\n+    assert(exception_message != nullptr, \"\");\n@@ -273,1 +273,1 @@\n-  bool is_reflect = refl_magic_klass != NULL && klass->is_subtype_of(refl_magic_klass);\n+  bool is_reflect = refl_magic_klass != nullptr && klass->is_subtype_of(refl_magic_klass);\n@@ -308,1 +308,1 @@\n-  if (verify_func == NULL) {\n+  if (verify_func == nullptr) {\n@@ -336,1 +336,1 @@\n-    return NULL; \/\/ verified.\n+    return nullptr; \/\/ verified.\n@@ -338,1 +338,1 @@\n-    THROW_MSG_(vmSymbols::java_lang_OutOfMemoryError(), message, NULL);\n+    THROW_MSG_(vmSymbols::java_lang_OutOfMemoryError(), message, nullptr);\n@@ -343,1 +343,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -351,1 +351,1 @@\n-  assert(frame != NULL, \"Must have a frame\");\n+  assert(frame != nullptr, \"Must have a frame\");\n@@ -356,1 +356,1 @@\n-  assert(frame != NULL, \"Must have a frame\");\n+  assert(frame != nullptr, \"Must have a frame\");\n@@ -361,1 +361,1 @@\n-  assert(frame != NULL, \"Must have a frame\");\n+  assert(frame != nullptr, \"Must have a frame\");\n@@ -366,1 +366,1 @@\n-  assert(frame != NULL, \"Must have a frame\");\n+  assert(frame != nullptr, \"Must have a frame\");\n@@ -371,1 +371,1 @@\n-  return TypeOrigin(BAD_INDEX, index, NULL, VerificationType::bogus_type());\n+  return TypeOrigin(BAD_INDEX, index, nullptr, VerificationType::bogus_type());\n@@ -374,1 +374,1 @@\n-  return TypeOrigin(CONST_POOL, index, NULL, vt);\n+  return TypeOrigin(CONST_POOL, index, nullptr, vt);\n@@ -377,1 +377,1 @@\n-  return TypeOrigin(SIG, 0, NULL, vt);\n+  return TypeOrigin(SIG, 0, nullptr, vt);\n@@ -380,1 +380,1 @@\n-  return TypeOrigin(IMPLICIT, 0, NULL, t);\n+  return TypeOrigin(IMPLICIT, 0, nullptr, t);\n@@ -388,1 +388,1 @@\n-  if (_frame != NULL) {\n+  if (_frame != nullptr) {\n@@ -425,1 +425,1 @@\n-  if (_frame != NULL) {\n+  if (_frame != nullptr) {\n@@ -510,1 +510,1 @@\n-  if (_bci != -1 && method != NULL) {\n+  if (_bci != -1 && method != nullptr) {\n@@ -532,1 +532,1 @@\n-  if (_type.is_valid() && _type.frame() != NULL) {\n+  if (_type.is_valid() && _type.frame() != nullptr) {\n@@ -537,1 +537,1 @@\n-  if (_expected.is_valid() && _expected.frame() != NULL) {\n+  if (_expected.is_valid() && _expected.frame() != nullptr) {\n@@ -545,1 +545,1 @@\n-  if (method != NULL) {\n+  if (method != nullptr) {\n@@ -554,1 +554,1 @@\n-  if (method != NULL) {\n+  if (method != nullptr) {\n@@ -569,1 +569,1 @@\n-  if (method != NULL && method->has_stackmap_table()) {\n+  if (method != nullptr && method->has_stackmap_table()) {\n@@ -596,2 +596,2 @@\n-    : _thread(current), _previous_symbol(NULL), _symbols(NULL), _exception_type(NULL),\n-      _message(NULL), _klass(klass) {\n+    : _thread(current), _previous_symbol(nullptr), _symbols(nullptr), _exception_type(nullptr),\n+      _message(nullptr), _klass(klass) {\n@@ -603,1 +603,1 @@\n-  if (_symbols != NULL) {\n+  if (_symbols != nullptr) {\n@@ -1850,1 +1850,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -2032,1 +2032,1 @@\n-  guarantee(cp->cache() == NULL, \"not rewritten yet\");\n+  guarantee(cp->cache() == nullptr, \"not rewritten yet\");\n@@ -2070,1 +2070,1 @@\n-  Exceptions::debug_check_abort(exception_name, NULL);\n+  Exceptions::debug_check_abort(exception_name, nullptr);\n@@ -2101,1 +2101,1 @@\n-  if (kls != NULL) {\n+  if (kls != nullptr) {\n@@ -2125,1 +2125,1 @@\n-    if (m != NULL && m->is_protected()) {\n+    if (m != nullptr && m->is_protected()) {\n@@ -2132,1 +2132,1 @@\n-    if (member_klass != NULL && fd.is_protected()) {\n+    if (member_klass != nullptr && fd.is_protected()) {\n@@ -2288,1 +2288,1 @@\n-  NOT_PRODUCT(aligned_bcp = NULL);  \/\/ no longer valid at this point\n+  NOT_PRODUCT(aligned_bcp = nullptr);  \/\/ no longer valid at this point\n@@ -2294,1 +2294,1 @@\n-  while (super != NULL) {\n+  while (super != nullptr) {\n@@ -2731,1 +2731,1 @@\n-      if (m != NULL) {\n+      if (m != nullptr) {\n@@ -2768,1 +2768,1 @@\n-  if (local_interfaces != NULL) {\n+  if (local_interfaces != nullptr) {\n@@ -2771,1 +2771,1 @@\n-      assert (k != NULL && k->is_interface(), \"invalid interface\");\n+      assert (k != nullptr && k->is_interface(), \"invalid interface\");\n@@ -2836,1 +2836,1 @@\n-  if (mth_sig_verif_types_ptr != NULL) {\n+  if (mth_sig_verif_types_ptr != nullptr) {\n@@ -2839,1 +2839,1 @@\n-    assert(mth_sig_verif_types != NULL, \"Unexpected NULL sig_as_verification_types value\");\n+    assert(mth_sig_verif_types != nullptr, \"Unexpected nullptr sig_as_verification_types value\");\n@@ -2911,1 +2911,1 @@\n-  assert(sig_verif_types != NULL, \"Missing signature's array of verification types\");\n+  assert(sig_verif_types != nullptr, \"Missing signature's array of verification types\");\n@@ -2935,1 +2935,1 @@\n-          assert(cp->cache() == NULL, \"not rewritten yet\");\n+          assert(cp->cache() == nullptr, \"not rewritten yet\");\n@@ -2996,1 +2996,1 @@\n-    NULL, NULL, NULL, NULL, \"[Z\", \"[C\", \"[F\", \"[D\", \"[B\", \"[S\", \"[I\", \"[J\",\n+    nullptr, nullptr, nullptr, nullptr, \"[Z\", \"[C\", \"[F\", \"[D\", \"[B\", \"[S\", \"[I\", \"[J\",\n@@ -3153,1 +3153,1 @@\n-  if (_previous_symbol != NULL && _previous_symbol->equals(name, length)) {\n+  if (_previous_symbol != nullptr && _previous_symbol->equals(name, length)) {\n@@ -3158,2 +3158,2 @@\n-    if (_symbols == NULL) {\n-      _symbols = new GrowableArray<Symbol*>(50, 0, NULL);\n+    if (_symbols == nullptr) {\n+      _symbols = new GrowableArray<Symbol*>(50, 0, nullptr);\n","filename":"src\/hotspot\/share\/classfile\/verifier.cpp","additions":68,"deletions":68,"binary":false,"changes":136,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -119,1 +119,1 @@\n-  TypeOrigin() : _origin(NONE), _index(0), _frame(NULL) {}\n+  TypeOrigin() : _origin(NONE), _index(0), _frame(nullptr) {}\n@@ -425,1 +425,1 @@\n-  bool has_error() const { return result() != NULL; }\n+  bool has_error() const { return result() != nullptr; }\n@@ -462,2 +462,2 @@\n-      if (_symbols == NULL) {\n-        _symbols = new GrowableArray<Symbol*>(50, 0, NULL);\n+      if (_symbols == nullptr) {\n+        _symbols = new GrowableArray<Symbol*>(50, 0, nullptr);\n","filename":"src\/hotspot\/share\/classfile\/verifier.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,2 +44,2 @@\n-                                                 =  { NULL \/*, NULL...*\/ };\n-InstanceKlass* vmClasses::_box_klasses[T_VOID+1] =  { NULL \/*, NULL...*\/ };\n+                                                 =  { nullptr \/*, nullptr...*\/ };\n+InstanceKlass* vmClasses::_box_klasses[T_VOID+1] =  { nullptr \/*, nullptr...*\/ };\n@@ -56,1 +56,1 @@\n-  return klass != NULL && klass->is_loaded();\n+  return klass != nullptr && klass->is_loaded();\n@@ -105,1 +105,1 @@\n-  return ((*klassp) != NULL);\n+  return ((*klassp) != nullptr);\n@@ -157,1 +157,1 @@\n-  assert(vmClasses::Object_klass() != NULL, \"well-known classes should now be initialized\");\n+  assert(vmClasses::Object_klass() != nullptr, \"well-known classes should now be initialized\");\n@@ -229,1 +229,1 @@\n-  if (klass->class_loader_data() != NULL) {\n+  if (klass->class_loader_data() != nullptr) {\n@@ -235,1 +235,1 @@\n-  if (super != NULL && super->class_loader_data() == NULL) {\n+  if (super != nullptr && super->class_loader_data() == nullptr) {\n@@ -243,1 +243,1 @@\n-    if (ik->class_loader_data()  == NULL) {\n+    if (ik->class_loader_data()  == nullptr) {\n@@ -248,1 +248,1 @@\n-  klass->restore_unshareable_info(loader_data, domain, NULL, THREAD);\n+  klass->restore_unshareable_info(loader_data, domain, nullptr, THREAD);\n@@ -261,1 +261,1 @@\n-  assert(k != NULL, \"\");\n+  assert(k != nullptr, \"\");\n","filename":"src\/hotspot\/share\/classfile\/vmClasses.cpp","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,1 +55,1 @@\n-    assert(k != NULL, \"klass not loaded\");\n+    assert(k != nullptr, \"klass not loaded\");\n","filename":"src\/hotspot\/share\/classfile\/vmClasses.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -623,1 +623,1 @@\n-  if (nt[as_int(_none)] == NULL) {\n+  if (nt[as_int(_none)] == nullptr) {\n@@ -635,1 +635,1 @@\n-  if (nt[as_int(_none)] == NULL) {\n+  if (nt[as_int(_none)] == nullptr) {\n@@ -658,1 +658,1 @@\n-    for (ControlIntrinsicIter iter(ControlIntrinsic); *iter != NULL; ++iter) {\n+    for (ControlIntrinsicIter iter(ControlIntrinsic); *iter != nullptr; ++iter) {\n@@ -667,1 +667,1 @@\n-    for (ControlIntrinsicIter iter(DisableIntrinsic, true\/*disable_all*\/); *iter != NULL; ++iter) {\n+    for (ControlIntrinsicIter iter(DisableIntrinsic, true\/*disable_all*\/); *iter != nullptr; ++iter) {\n@@ -771,1 +771,1 @@\n-  if (kptr != NULL)  kname = kptr + 1;\n+  if (kptr != nullptr)  kname = kptr + 1;\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,1 +40,1 @@\n-Symbol* vmSymbols::_type_signatures[T_VOID+1] = { NULL \/*, NULL...*\/ };\n+Symbol* vmSymbols::_type_signatures[T_VOID+1] = { nullptr \/*, nullptr...*\/ };\n@@ -105,1 +105,1 @@\n-      if (s == NULL)  continue;\n+      if (s == nullptr)  continue;\n@@ -143,1 +143,1 @@\n-    assert(Symbol::_vm_symbols[NO_SID] == NULL, \"must be\");\n+    assert(Symbol::_vm_symbols[NO_SID] == nullptr, \"must be\");\n@@ -296,1 +296,1 @@\n-  if (symbol == NULL)  return vmSymbolID::NO_SID;\n+  if (symbol == nullptr)  return vmSymbolID::NO_SID;\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -872,1 +872,1 @@\n-    assert(_type_signatures[t] != NULL, \"domain check\");\n+    assert(_type_signatures[t] != nullptr, \"domain check\");\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}