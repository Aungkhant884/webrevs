{"files":[{"patch":"@@ -1066,1 +1066,1 @@\n-  G1BarrierSet::dirty_card_queue_set().abandon_logs();\n+  G1BarrierSet::dirty_card_queue_set().abandon_logs_and_stats();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -533,1 +533,1 @@\n-void G1DirtyCardQueueSet::abandon_logs() {\n+void G1DirtyCardQueueSet::abandon_logs_and_stats() {\n@@ -535,2 +535,0 @@\n-  abandon_completed_buffers();\n-  _detached_refinement_stats.reset();\n@@ -541,2 +539,1 @@\n-  \/\/ Since abandon is done only at safepoints, we can safely manipulate\n-  \/\/ these queues.\n+  \/\/ Iterate over all the threads, resetting per-thread queues and stats.\n@@ -553,0 +550,7 @@\n+\n+  enqueue_all_paused_buffers();\n+  abandon_completed_buffers();\n+\n+  \/\/ Reset stats from detached threads.\n+  MutexLocker ml(G1DetachedRefinementStats_lock, Mutex::_no_safepoint_check_flag);\n+  _detached_refinement_stats.reset();\n@@ -555,1 +559,1 @@\n-void G1DirtyCardQueueSet::concatenate_logs() {\n+void G1DirtyCardQueueSet::concatenate_logs_and_stats() {\n@@ -565,1 +569,5 @@\n-    ConcatenateThreadLogClosure(G1DirtyCardQueueSet& qset) : _qset(qset) {}\n+    G1ConcurrentRefineStats _total_stats;\n+\n+    ConcatenateThreadLogClosure(G1DirtyCardQueueSet& qset) :\n+      _qset{qset}, _total_stats{} {}\n+\n@@ -568,0 +576,2 @@\n+      \/\/ Flush the buffer if non-empty.  Flush before accumulating and\n+      \/\/ resetting stats, since flushing may modify the stats.\n@@ -572,0 +582,3 @@\n+      G1ConcurrentRefineStats& qstats = *queue.refinement_stats();\n+      _total_stats += qstats;\n+      qstats.reset();\n@@ -575,0 +588,1 @@\n+  _concatenated_refinement_stats = closure._total_stats;\n@@ -578,21 +592,0 @@\n-}\n-\n-G1ConcurrentRefineStats G1DirtyCardQueueSet::get_and_reset_refinement_stats() {\n-  assert_at_safepoint();\n-\n-  \/\/ Since we're at a safepoint, there aren't any races with recording of\n-  \/\/ detached refinement stats.  In particular, there's no risk of double\n-  \/\/ counting a thread that detaches after we've examined it but before\n-  \/\/ we've processed the detached stats.\n-\n-  \/\/ Collect and reset stats for attached threads.\n-  struct CollectStats : public ThreadClosure {\n-    G1ConcurrentRefineStats _total_stats;\n-    virtual void do_thread(Thread* t) {\n-      G1DirtyCardQueue& dcq = G1ThreadLocalData::dirty_card_queue(t);\n-      G1ConcurrentRefineStats& stats = *dcq.refinement_stats();\n-      _total_stats += stats;\n-      stats.reset();\n-    }\n-  } closure;\n-  Threads::threads_do(&closure);\n@@ -602,1 +595,1 @@\n-  closure._total_stats += _detached_refinement_stats;\n+  _concatenated_refinement_stats += _detached_refinement_stats;\n@@ -604,0 +597,1 @@\n+}\n@@ -605,1 +599,3 @@\n-  return closure._total_stats;\n+G1ConcurrentRefineStats G1DirtyCardQueueSet::concatenated_refinement_stats() const {\n+  assert_at_safepoint();\n+  return _concatenated_refinement_stats;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1DirtyCardQueue.cpp","additions":26,"deletions":30,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -98,4 +98,4 @@\n-  \/\/ (such as concatenate_logs) also need to deal with any paused buffers.  In\n-  \/\/ general, if a safepoint performs a GC then the paused buffers will be\n-  \/\/ processed as part of it, and there won't be any paused buffers after a\n-  \/\/ GC safepoint.\n+  \/\/ (such as concatenating or abandoning logs) also need to deal with any\n+  \/\/ paused buffers.  In general, if a safepoint performs a GC then the paused\n+  \/\/ buffers will be processed as part of it, and there won't be any paused\n+  \/\/ buffers after a GC safepoint.\n@@ -178,0 +178,1 @@\n+  G1ConcurrentRefineStats _concatenated_refinement_stats;\n@@ -270,3 +271,5 @@\n-  \/\/ If a full collection is happening, reset partial logs, and release\n-  \/\/ completed ones: the full collection will make them all irrelevant.\n-  void abandon_logs();\n+  \/\/ If a full collection is happening, reset per-thread refinement stats and\n+  \/\/ partial logs, and release completed logs. The full collection will make\n+  \/\/ them all irrelevant.\n+  \/\/ precondition: at safepoint.\n+  void abandon_logs_and_stats();\n@@ -274,2 +277,4 @@\n-  \/\/ If any threads have partial logs, add them to the global list of logs.\n-  void concatenate_logs();\n+  \/\/ Collect and reset all the per-thread refinement stats.  If any threads\n+  \/\/ have partial logs then add them to the global list.\n+  \/\/ precondition: at safepoint.\n+  void concatenate_logs_and_stats();\n@@ -278,1 +283,0 @@\n-  \/\/ Also resets the stats for the threads.\n@@ -280,1 +284,2 @@\n-  G1ConcurrentRefineStats get_and_reset_refinement_stats();\n+  \/\/ precondition: only call after concatenate_logs_and_stats.\n+  G1ConcurrentRefineStats concatenated_refinement_stats() const;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1DirtyCardQueue.hpp","additions":16,"deletions":11,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -569,1 +569,1 @@\n-                               _preserved_marks_set->get(worker_id),\n+                               _preserved_marks_set.get(worker_id),\n@@ -690,2 +690,0 @@\n-                                                 G1RedirtyCardsQueueSet* rdcqs,\n-                                                 PreservedMarksSet* preserved_marks_set,\n@@ -697,2 +695,2 @@\n-    _rdcqs(rdcqs),\n-    _preserved_marks_set(preserved_marks_set),\n+    _rdcqs(G1BarrierSet::dirty_card_queue_set().allocator()),\n+    _preserved_marks_set(true \/* in_c_heap *\/),\n@@ -706,0 +704,1 @@\n+  _preserved_marks_set.init(n_workers);\n@@ -716,0 +715,2 @@\n+  _preserved_marks_set.assert_empty();\n+  _preserved_marks_set.reclaim();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.cpp","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+#include \"gc\/shared\/preservedMarks.hpp\"\n@@ -232,2 +233,2 @@\n-  G1RedirtyCardsQueueSet* _rdcqs;\n-  PreservedMarksSet* _preserved_marks_set;\n+  G1RedirtyCardsQueueSet _rdcqs;\n+  PreservedMarksSet _preserved_marks_set;\n@@ -244,2 +245,0 @@\n-                          G1RedirtyCardsQueueSet* rdcqs,\n-                          PreservedMarksSet* preserved_marks_set,\n@@ -252,2 +251,2 @@\n-  G1RedirtyCardsQueueSet* rdcqs() { return _rdcqs; }\n-  PreservedMarksSet* preserved_marks_set() { return _preserved_marks_set; }\n+  G1RedirtyCardsQueueSet* rdcqs() { return &_rdcqs; }\n+  PreservedMarksSet* preserved_marks_set() { return &_preserved_marks_set; }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.hpp","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -589,3 +589,4 @@\n-void G1Policy::record_concurrent_refinement_stats() {\n-  G1DirtyCardQueueSet& dcqs = G1BarrierSet::dirty_card_queue_set();\n-  _pending_cards_at_gc_start = dcqs.num_cards();\n+void G1Policy::record_concurrent_refinement_stats(size_t pending_cards,\n+                                                  size_t thread_buffer_cards) {\n+  _pending_cards_at_gc_start = pending_cards;\n+  _analytics->report_dirtied_cards_in_thread_buffers(thread_buffer_cards);\n@@ -594,1 +595,2 @@\n-  G1ConcurrentRefineStats mut_stats = dcqs.get_and_reset_refinement_stats();\n+  G1DirtyCardQueueSet& dcqs = G1BarrierSet::dirty_card_queue_set();\n+  G1ConcurrentRefineStats mut_stats = dcqs.concatenated_refinement_stats();\n@@ -631,5 +633,0 @@\n-void G1Policy::record_concatenate_dirty_card_logs(Tickspan concat_time, size_t num_cards) {\n-  _analytics->report_dirtied_cards_in_thread_buffers(num_cards);\n-  phase_times()->record_concatenate_dirty_card_logs_time_ms(concat_time.seconds() * MILLIUNITS);\n-}\n-\n@@ -650,2 +647,0 @@\n-  record_concurrent_refinement_stats();\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Policy.cpp","additions":6,"deletions":11,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -294,3 +294,0 @@\n-  \/\/ Record and log stats before not-full collection.\n-  void record_concurrent_refinement_stats();\n-\n@@ -315,2 +312,0 @@\n-  void record_concatenate_dirty_card_logs(Tickspan concat_time, size_t num_cards);\n-\n@@ -414,0 +409,6 @@\n+  \/\/ Record and log stats and pending cards before not-full collection.\n+  \/\/ thread_buffer_cards is the number of cards that were in per-thread\n+  \/\/ buffers.  pending_cards includes thread_buffer_cards.\n+  void record_concurrent_refinement_stats(size_t pending_cards,\n+                                          size_t thread_buffer_cards);\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Policy.hpp","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -470,1 +470,8 @@\n-void G1YoungCollector::flush_dirty_card_queues() {\n+void G1YoungCollector::retire_tlabs() {\n+  Ticks start = Ticks::now();\n+  _g1h->retire_tlabs();\n+  double retire_time = (Ticks::now() - start).seconds() * MILLIUNITS;\n+  phase_times()->record_prepare_tlab_time_ms(retire_time);\n+}\n+\n+void G1YoungCollector::concatenate_dirty_card_logs_and_stats() {\n@@ -474,4 +481,20 @@\n-  qset.concatenate_logs();\n-  size_t added_cards = qset.num_cards() - old_cards;\n-  Tickspan concat_time = Ticks::now() - start;\n-  policy()->record_concatenate_dirty_card_logs(concat_time, added_cards);\n+  qset.concatenate_logs_and_stats();\n+  size_t pending_cards = qset.num_cards();\n+  size_t thread_buffer_cards = pending_cards - old_cards;\n+  policy()->record_concurrent_refinement_stats(pending_cards, thread_buffer_cards);\n+  double concat_time = (Ticks::now() - start).seconds() * MILLIUNITS;\n+  phase_times()->record_concatenate_dirty_card_logs_time_ms(concat_time);\n+}\n+\n+#ifdef ASSERT\n+void G1YoungCollector::verify_empty_dirty_card_logs() const {\n+  struct Verifier : public ThreadClosure {\n+    size_t _buffer_size;\n+    Verifier() : _buffer_size(G1BarrierSet::dirty_card_queue_set().buffer_size()) {}\n+    void do_thread(Thread* t) override {\n+      G1DirtyCardQueue& queue = G1ThreadLocalData::dirty_card_queue(t);\n+      assert((queue.buffer() == nullptr) || (queue.index() == _buffer_size),\n+             \"non-empty dirty card queue for thread\");\n+    }\n+  } verifier;\n+  Threads::threads_do(&verifier);\n@@ -479,0 +502,11 @@\n+#endif \/\/ ASSERT\n+\n+void G1YoungCollector::pre_evacuate_collection_set(G1EvacInfo* evacuation_info) {\n+  \/\/ Flush early, so later phases don't need to account for per-thread stuff.\n+  \/\/ Flushes deferred card marks, so must precede concatenting logs.\n+  retire_tlabs();\n+\n+  \/\/ Flush early, so later phases don't need to account for per-thread stuff.\n+  concatenate_dirty_card_logs_and_stats();\n+\n+  calculate_collection_set(evacuation_info, policy()->max_pause_time_ms());\n@@ -480,1 +514,0 @@\n-void G1YoungCollector::pre_evacuate_collection_set(G1EvacInfo* evacuation_info, G1ParScanThreadStateSet* per_thread_states) {\n@@ -486,1 +519,1 @@\n-   _evac_failure_regions.pre_collection(_g1h->max_reserved_regions());\n+  _evac_failure_regions.pre_collection(_g1h->max_reserved_regions());\n@@ -490,10 +523,0 @@\n-  {\n-    Ticks start = Ticks::now();\n-    _g1h->retire_tlabs();\n-    phase_times()->record_prepare_tlab_time_ms((Ticks::now() - start).seconds() * 1000.0);\n-  }\n-\n-  \/\/ Flush dirty card queues to qset, so later phases don't need to account\n-  \/\/ for partially filled per-thread queues and such.\n-  flush_dirty_card_queues();\n-\n@@ -522,1 +545,1 @@\n-  per_thread_states->preserved_marks_set()->assert_empty();\n+  verify_empty_dirty_card_logs();\n@@ -1016,13 +1039,0 @@\n-class G1PreservedMarksSet : public PreservedMarksSet {\n-public:\n-\n-  G1PreservedMarksSet(uint num_workers) : PreservedMarksSet(true \/* in_c_heap *\/) {\n-    init(num_workers);\n-  }\n-\n-  virtual ~G1PreservedMarksSet() {\n-    assert_empty();\n-    reclaim();\n-  }\n-};\n-\n@@ -1076,1 +1086,1 @@\n-    calculate_collection_set(jtm.evacuation_info(), policy()->max_pause_time_ms());\n+    pre_evacuate_collection_set(jtm.evacuation_info());\n@@ -1078,2 +1088,0 @@\n-    G1RedirtyCardsQueueSet rdcqs(G1BarrierSet::dirty_card_queue_set().allocator());\n-    G1PreservedMarksSet preserved_marks_set(workers()->active_workers());\n@@ -1081,2 +1089,0 @@\n-                                              &rdcqs,\n-                                              &preserved_marks_set,\n@@ -1088,2 +1094,0 @@\n-    pre_evacuate_collection_set(jtm.evacuation_info(), &per_thread_states);\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungCollector.cpp","additions":42,"deletions":38,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -101,1 +101,3 @@\n-  void flush_dirty_card_queues();\n+  void retire_tlabs();\n+  void concatenate_dirty_card_logs_and_stats();\n+  void verify_empty_dirty_card_logs() const NOT_DEBUG_RETURN;\n@@ -103,1 +105,1 @@\n-  void pre_evacuate_collection_set(G1EvacInfo* evacuation_info, G1ParScanThreadStateSet* pss);\n+  void pre_evacuate_collection_set(G1EvacInfo* evacuation_info);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungCollector.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"}]}