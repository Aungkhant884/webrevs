{"files":[{"patch":"@@ -1586,1 +1586,3 @@\n-    f(method);\n+    if (method != nullptr) {\n+      f(method);\n+    }\n@@ -1590,1 +1592,1 @@\n-    MutexLocker ml(InvokeMethodTable_lock);\n+    MutexLocker ml(InvokeMethodIntrinsicTable_lock);\n@@ -1942,0 +1944,7 @@\n+  InvokeMethodKey key(signature, iid_as_int);\n+  Method** met = nullptr;\n+\n+  \/\/ We only want one entry in the table for this (signature\/id, method) pair but the code\n+  \/\/ to create the intrinsic method needs to be outside the lock.\n+  \/\/ The first thread claims the entry by adding the key and the other threads wait, until the\n+  \/\/ Method has been added as the value.\n@@ -1943,5 +1952,14 @@\n-    MutexLocker ml(THREAD, InvokeMethodTable_lock);\n-    InvokeMethodKey key(signature, iid_as_int);\n-    Method** met = _invoke_method_intrinsic_table.get(key);\n-    if (met != nullptr) {\n-      return *met;\n+    MonitorLocker ml(THREAD, InvokeMethodIntrinsicTable_lock);\n+    bool created = false;\n+    \/\/ Loop until the current thread won the race and will try to create the full entry.\n+    while (!created) {\n+      met = _invoke_method_intrinsic_table.put_if_absent(key, &created);\n+      if (*met != nullptr) {\n+        return *met;\n+      } else if (!created) {\n+        \/\/ Another thread beat us to it, so wait for them to complete\n+        \/\/ and return *met; or if they hit an error we get another try.\n+        ml.wait();\n+        \/\/ Note it is not safe to read *met here as that entry could have\n+        \/\/ been deleted, so we must loop and try put_if_absent again.\n+      }\n@@ -1949,0 +1967,1 @@\n+  }\n@@ -1950,11 +1969,9 @@\n-    bool throw_error = false;\n-    \/\/ This function could get an OOM but it is safe to call inside of a lock because\n-    \/\/ throwing OutOfMemoryError doesn't call Java code.\n-    methodHandle m = Method::make_method_handle_intrinsic(iid, signature, CHECK_NULL);\n-    if (!Arguments::is_interpreter_only() || iid == vmIntrinsics::_linkToNative) {\n-        \/\/ Generate a compiled form of the MH intrinsic\n-        \/\/ linkToNative doesn't have interpreter-specific implementation, so always has to go through compiled version.\n-        AdapterHandlerLibrary::create_native_wrapper(m);\n-        \/\/ Check if have the compiled code.\n-        throw_error = (!m->has_compiled_code());\n-    }\n+  methodHandle m = Method::make_method_handle_intrinsic(iid, signature, THREAD);\n+  bool throw_error = HAS_PENDING_EXCEPTION;\n+  if (!throw_error && (!Arguments::is_interpreter_only() || iid == vmIntrinsics::_linkToNative)) {\n+    \/\/ Generate a compiled form of the MH intrinsic\n+    \/\/ linkToNative doesn't have interpreter-specific implementation, so always has to go through compiled version.\n+    AdapterHandlerLibrary::create_native_wrapper(m);\n+    \/\/ Check if have the compiled code.\n+    throw_error = (!m->has_compiled_code());\n+  }\n@@ -1962,1 +1979,8 @@\n-    if (!throw_error) {\n+  {\n+    MonitorLocker ml(THREAD, InvokeMethodIntrinsicTable_lock);\n+    if (throw_error) {\n+      \/\/ Remove the entry and let another thread try, or get the same exception.\n+      bool removed = _invoke_method_intrinsic_table.remove(key);\n+      assert(removed, \"must be the owner\");\n+      ml.notify_all();\n+    } else {\n@@ -1964,2 +1988,0 @@\n-      bool created = _invoke_method_intrinsic_table.put(key, m());\n-      assert(created, \"must be since we still hold the lock\");\n@@ -1969,0 +1991,2 @@\n+      *met = m(); \/\/ insert the element\n+      ml.notify_all();\n@@ -1973,3 +1997,6 @@\n-  \/\/ Throw error outside of the lock.\n-  THROW_MSG_NULL(vmSymbols::java_lang_VirtualMachineError(),\n-                 \"Out of space in CodeCache for method handle intrinsic\");\n+  \/\/ Throw VirtualMachineError or the pending exception in the JavaThread\n+  if (throw_error && !HAS_PENDING_EXCEPTION) {\n+    THROW_MSG_NULL(vmSymbols::java_lang_VirtualMachineError(),\n+                   \"Out of space in CodeCache for method handle intrinsic\");\n+  }\n+  return nullptr;\n@@ -2118,1 +2145,1 @@\n-    MutexLocker ml(THREAD, InvokeMethodTable_lock);\n+    MutexLocker ml(THREAD, InvokeMethodTypeTable_lock);\n@@ -2187,1 +2214,1 @@\n-    MutexLocker ml(THREAD, InvokeMethodTable_lock);\n+    MutexLocker ml(THREAD, InvokeMethodTypeTable_lock);\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":53,"deletions":26,"binary":false,"changes":79,"status":"modified"},{"patch":"@@ -42,1 +42,2 @@\n-Mutex*   InvokeMethodTable_lock       = nullptr;\n+Mutex*   InvokeMethodTypeTable_lock   = nullptr;\n+Monitor* InvokeMethodIntrinsicTable_lock = nullptr;\n@@ -257,1 +258,3 @@\n-  MUTEX_DEFN(InvokeMethodTable_lock          , PaddedMutex  , safepoint);\n+  MUTEX_DEFN(InvokeMethodTypeTable_lock      , PaddedMutex  , safepoint);\n+  MUTEX_DEFN(InvokeMethodIntrinsicTable_lock , PaddedMonitor, safepoint);\n+  MUTEX_DEFN(AdapterHandlerLibrary_lock      , PaddedMutex  , safepoint);\n@@ -347,1 +350,0 @@\n-  MUTEX_DEFL(AdapterHandlerLibrary_lock     , PaddedMutex  , InvokeMethodTable_lock);\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.cpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -37,1 +37,2 @@\n-extern Mutex*   InvokeMethodTable_lock;\n+extern Mutex*   InvokeMethodTypeTable_lock;\n+extern Monitor* InvokeMethodIntrinsicTable_lock;\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"}]}