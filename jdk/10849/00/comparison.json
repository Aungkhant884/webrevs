{"files":[{"patch":"@@ -1393,7 +1393,4 @@\n-  {\n-    address owner = NULL;\n-    {\n-      markWord mark = hobj()->mark();\n-\n-      if (!mark.has_monitor()) {\n-        \/\/ this object has a lightweight monitor\n+  owning_thread = ObjectSynchronizer::get_lock_owner(tlh.list(), hobj);\n+  if (owning_thread != NULL) {\n+    Handle th(current_thread, get_vthread_or_thread_oop(owning_thread));\n+    ret.owner = (jthread)jni_reference(calling_thread, th);\n@@ -1401,34 +1398,5 @@\n-        if (mark.has_locker()) {\n-          owner = (address)mark.locker(); \/\/ save the address of the Lock word\n-        }\n-        \/\/ implied else: no owner\n-      } else {\n-        \/\/ this object has a heavyweight monitor\n-        mon = mark.monitor();\n-\n-        \/\/ The owner field of a heavyweight monitor may be NULL for no\n-        \/\/ owner, a JavaThread * or it may still be the address of the\n-        \/\/ Lock word in a JavaThread's stack. A monitor can be inflated\n-        \/\/ by a non-owning JavaThread, but only the owning JavaThread\n-        \/\/ can change the owner field from the Lock word to the\n-        \/\/ JavaThread * and it may not have done that yet.\n-        owner = (address)mon->owner();\n-      }\n-    }\n-\n-    if (owner != NULL) {\n-      \/\/ This monitor is owned so we have to find the owning JavaThread.\n-      owning_thread = Threads::owning_thread_from_monitor_owner(tlh.list(), owner);\n-      assert(owning_thread != NULL, \"owning JavaThread must not be NULL\");\n-      Handle th(current_thread, get_vthread_or_thread_oop(owning_thread));\n-      ret.owner = (jthread)jni_reference(calling_thread, th);\n-    }\n-\n-    if (owning_thread != NULL) {  \/\/ monitor is owned\n-      \/\/ The recursions field of a monitor does not reflect recursions\n-      \/\/ as lightweight locks before inflating the monitor are not included.\n-      \/\/ We have to count the number of recursive monitor entries the hard way.\n-      \/\/ We pass a handle to survive any GCs along the way.\n-      ret.entry_count = count_locked_objects(owning_thread, hobj);\n-    }\n-    \/\/ implied else: entry_count == 0\n+    \/\/ The recursions field of a monitor does not reflect recursions\n+    \/\/ as lightweight locks before inflating the monitor are not included.\n+    \/\/ We have to count the number of recursive monitor entries the hard way.\n+    \/\/ We pass a handle to survive any GCs along the way.\n+    ret.entry_count = count_locked_objects(owning_thread, hobj);\n@@ -1436,0 +1404,1 @@\n+  \/\/ implied else: entry_count == 0\n@@ -1438,1 +1407,4 @@\n-  if (mon != NULL) {\n+  markWord mark = hobj->mark();\n+  if (mark.has_monitor()) {\n+    mon = mark.monitor();\n+    assert(mon != NULL, \"must have monitor\");\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnvBase.cpp","additions":14,"deletions":42,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -249,0 +249,2 @@\n+  \/\/ Returns true if this OM has an owner, false otherwise.\n+  bool      has_owner() const;\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -59,0 +59,5 @@\n+inline bool ObjectMonitor::has_owner() const {\n+  void* owner = owner_raw();\n+  return owner != NULL || owner == DEFLATER_MARKER;\n+}\n+\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.inline.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1011,1 +1011,0 @@\n-\/\/ FIXME: jvmti should call this\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -74,1 +74,1 @@\n-#include \"runtime\/objectMonitor.hpp\"\n+#include \"runtime\/objectMonitor.inline.hpp\"\n@@ -1411,0 +1411,5 @@\n+JavaThread* Threads::owning_thread_from_monitor(ThreadsList* t_list, ObjectMonitor* monitor) {\n+  address owner = (address)monitor->owner();\n+  return owning_thread_from_monitor_owner(t_list, owner);\n+}\n+\n","filename":"src\/hotspot\/share\/runtime\/threads.cpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -139,0 +139,2 @@\n+  static JavaThread* owning_thread_from_monitor(ThreadsList* t_list, ObjectMonitor* owner);\n+\n","filename":"src\/hotspot\/share\/runtime\/threads.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -458,4 +458,2 @@\n-        address currentOwner = (address)waitingToLockMonitor->owner();\n-        if (currentOwner != NULL) {\n-          currentThread = Threads::owning_thread_from_monitor_owner(t_list,\n-                                                                    currentOwner);\n+        if (waitingToLockMonitor->has_owner()) {\n+          currentThread = Threads::owning_thread_from_monitor(t_list, waitingToLockMonitor);\n@@ -1055,2 +1053,1 @@\n-      currentThread = Threads::owning_thread_from_monitor_owner(t_list,\n-                                                                (address)waitingToLockMonitor->owner());\n+      currentThread = Threads::owning_thread_from_monitor(t_list, waitingToLockMonitor);\n","filename":"src\/hotspot\/share\/services\/threadService.cpp","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"}]}