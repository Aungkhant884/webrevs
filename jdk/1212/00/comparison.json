{"files":[{"patch":"@@ -723,18 +723,0 @@\n-\/\/\n-\/\/ Performance concern:\n-\/\/ OrderAccess::storestore() calls release() which at one time stored 0\n-\/\/ into the global volatile OrderAccess::dummy variable. This store was\n-\/\/ unnecessary for correctness. Many threads storing into a common location\n-\/\/ causes considerable cache migration or \"sloshing\" on large SMP systems.\n-\/\/ As such, I avoided using OrderAccess::storestore(). In some cases\n-\/\/ OrderAccess::fence() -- which incurs local latency on the executing\n-\/\/ processor -- is a better choice as it scales on SMP systems.\n-\/\/\n-\/\/ See http:\/\/blogs.oracle.com\/dave\/entry\/biased_locking_in_hotspot for\n-\/\/ a discussion of coherency costs. Note that all our current reference\n-\/\/ platforms provide strong ST-ST order, so the issue is moot on IA32,\n-\/\/ x64, and SPARC.\n-\/\/\n-\/\/ As a general policy we use \"volatile\" to control compiler-based reordering\n-\/\/ and explicit fences (barriers) to control for architectural reordering\n-\/\/ performed by the CPU(s) or platform.\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":0,"deletions":18,"binary":false,"changes":18,"status":"modified"}]}