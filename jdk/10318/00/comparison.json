{"files":[{"patch":"@@ -1,307 +0,0 @@\n-\/*\n- * Copyright (c) 2007, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-#include <stdio.h>\n-#include <jvmti.h>\n-#include \"agent_common.h\"\n-#include <jni.h>\n-#include <string.h>\n-\n-#include \"jni_tools.h\"\n-#include \"jvmti_tools.h\"\n-\n-\n-extern \"C\" {\n-static JNIEnv* jni = NULL;\n-static jvmtiEnv *jvmti = NULL;\n-static jlong timeout = 0;\n-static jint testStep;\n-static jint redefineNumber;\n-static unsigned char* newClassBytes;\n-static unsigned char* path;\n-static jthread testedThread;\n-static jclass testClass;\n-static jclass myTestClass;\n-\n-#define NAME \"nsk\/jvmti\/scenarios\/hotswap\/HS204\/hs204t001\/hs204t001R\"\n-#define CLASS_NAME \"Lnsk\/jvmti\/scenarios\/hotswap\/HS204\/hs204t001\/hs204t001R;\"\n-#define PATH_TO_NEW_BYTECODE \"pathToNewByteCode\"\n-#define FILE_NAME \"nsk\/jvmti\/scenarios\/hotswap\/HS204\/hs204t001\/hs204t001R\"\n-static jint newClassSize;\n-\n-char *getClassName(jvmtiEnv *jvmti, jclass  klass) {\n-    char * className;\n-    char * generic;\n-    if (!NSK_JVMTI_VERIFY(jvmti->GetClassSignature(klass, &className, &generic))) {\n-        nsk_jvmti_setFailStatus();\n-    }\n-    return className;\n-}\n-\n-JNIEXPORT void JNICALL\n-callbackClassLoad(jvmtiEnv *jvmti_env,\n-        JNIEnv* jni_env,\n-        jthread thread,\n-        jclass klass) {\n-    char * name;\n-    name = getClassName(jvmti_env,klass);\n-    if ((strcmp(name,CLASS_NAME) == 0) && (redefineNumber == 1)) {\n-       char fileName[512];\n-        nsk_jvmti_getFileName(redefineNumber, FILE_NAME, fileName,\n-                        sizeof(fileName)\/sizeof(char));\n-        NSK_DISPLAY1(\">>>>>>CallbackClassLoad ... Name=%s...  >>\\n\",name);\n-        if (nsk_jvmti_redefineClass(jvmti, klass, fileName)) {\n-            NSK_DISPLAY0(\"\\nMyClass :: Successfully redefined..\\n\");\n-            redefineNumber++;\n-        } else {\n-            NSK_COMPLAIN0(\"\\nMyClass :: Failed to redefine ..\\n\");\n-        }\n-        \/* if ((myTestClass = jni_env->NewGlobalRef(klass)) == NULL) {\n-           NSK_COMPLAIN0(\"Failed to create global ref...\");\n-           }\n-         *\/\n-    }\n-}\n-\n-JNIEXPORT void JNICALL\n-callbackClassPrepare(jvmtiEnv *jvmti_env,\n-        JNIEnv* jni_env,\n-        jthread thread,\n-        jclass klass) {\n-    char *  name;\n-    name = getClassName(jvmti_env, klass);\n-    if ((strcmp(name, CLASS_NAME) == 0) && (redefineNumber == 0)) {\n-        char fileName[512];\n-        nsk_jvmti_getFileName(redefineNumber, FILE_NAME, fileName,\n-                        sizeof(fileName)\/sizeof(char));\n-        NSK_DISPLAY1(\">>>>>>callbackClassPrepare ... Name=%s...  >>\\n\",name);\n-        if (nsk_jvmti_redefineClass(jvmti, klass, fileName)) {\n-            NSK_DISPLAY0(\"\\nMyClass :: Successfully redefined..\\n\");\n-            redefineNumber++;\n-        } else {\n-            NSK_COMPLAIN0(\"\\nMyClass :: Failed to redefine ..\\n\");\n-        }\n-        myTestClass = (jclass) jni_env->NewGlobalRef(klass);\n-        if (myTestClass == NULL) {\n-            NSK_COMPLAIN0(\"Failed to create global ref...\");\n-        }\n-    }\n-}\n-\n-JNIEXPORT void JNICALL\n-callbackClassFileLoadHock(jvmtiEnv *jvmti_env,\n-        JNIEnv* jni_env,\n-        jclass class_being_redefined,\n-        jobject loader,\n-        const char* name,\n-        jobject protection_domain,\n-        jint class_data_len,\n-        const unsigned char* class_data,\n-        jint* new_class_data_len,\n-        unsigned char** new_class_data) {\n-    if (name != NULL && strcmp(name, NAME) == 0 && (redefineNumber == 1)) {\n-        NSK_DISPLAY1(\">>>>>>callbackClassFileLoadHock ... Name=%s...  >>\\n\",name);\n-        \/*redefineClass(jvmti_env, myTestClass);*\/\n-    }\n-}\n-\n-JNIEXPORT void JNICALL\n-#ifdef STATIC_BUILD\n-Agent_OnUnload_hs204t001(JavaVM *jvm)\n-#else\n-Agent_OnUnload(JavaVM *jvm)\n-#endif\n-{\n-    NSK_DISPLAY0(\" VM ... Going Down.. (C\/C++) \\n\");\n-    return;\n-}\n-\n-static void JNICALL agentProc(jvmtiEnv* jvmti, JNIEnv* agentJNI, void* arg) {\n-    redefineNumber = 0;\n-    jni = agentJNI;\n-    testStep=1;\n-    NSK_DISPLAY0(\"\\n\\n>>>> Debugge started, waiting for class loading \\n\");\n-    jni->DeleteGlobalRef(testClass);\n-    jni->DeleteGlobalRef(testedThread);\n-    NSK_DISPLAY0(\"Waiting for debuggee to become ready\\n\");\n-    if (!nsk_jvmti_waitForSync(timeout)) {\n-        return;\n-    }\n-    testStep = 1;\n-    NSK_DISPLAY0(\"\\n\\n>>>> Debugge started, waiting for class loading \\n\");\n-    if (!nsk_jvmti_resumeSync())\n-        return;\n-    NSK_DISPLAY0(\"Waiting for debuggee's threads to finish\\n\");\n-    if (!nsk_jvmti_waitForSync(timeout))\n-        return;\n-    jni->DeleteGlobalRef(testClass);\n-    jni->DeleteGlobalRef(testedThread);\n-    NSK_DISPLAY0(\"Let debuggee to finish\\n\");\n-    if (!nsk_jvmti_resumeSync())\n-        return;\n-}\n-\n-#ifdef STATIC_BUILD\n-JNIEXPORT jint JNICALL Agent_OnLoad_hs204t001(JavaVM *jvm, char *options, void *reserved) {\n-    return Agent_Initialize(jvm, options, reserved);\n-}\n-JNIEXPORT jint JNICALL Agent_OnAttach_hs204t001(JavaVM *jvm, char *options, void *reserved) {\n-    return Agent_Initialize(jvm, options, reserved);\n-}\n-JNIEXPORT jint JNI_OnLoad_hs204t001(JavaVM *jvm, char *options, void *reserved) {\n-    return JNI_VERSION_1_8;\n-}\n-#endif\n-jint  Agent_Initialize(JavaVM *vm, char *options, void *reserved) {\n-    jint rc ;\n-    NSK_DISPLAY0(\" VM.. Started..\\n\");\n-    rc=vm->GetEnv((void **)&jvmti, JVMTI_VERSION_1_1);\n-    if (rc != JNI_OK) {\n-        NSK_COMPLAIN0(\" Could not load JVMTI interface \\n\");\n-    } else {\n-        \/* Open simple block for better memor usage. *\/\n-        jvmtiCapabilities caps;\n-        memset(&caps, 0, sizeof(caps));\n-\n-        \/*\n-           set capabilities of\n-           1.ClassFileLoadHock,\n-           2.ClassLoad(doesn;t require any capabilities to set).\n-           3.ClassPrepare (doesn;t require any capabilitiesto set).\n-           4.Redefine (default).\n-           5.PopFrame.\n-         *\/\n-        caps.can_generate_all_class_hook_events=1;\n-        caps.can_access_local_variables = 1;\n-        caps.can_generate_single_step_events=1;\n-        caps.can_redefine_classes = 1;\n-        caps.can_suspend = 1;\n-        caps.can_pop_frame=1;\n-        caps.can_generate_all_class_hook_events=1;\n-        jvmti->AddCapabilities(&caps);\n-        \/*\n-           set the method and other functions..\n-         *\/\n-        {\n-            jvmtiEventCallbacks eventCallbacks;\n-            memset(&eventCallbacks, 0, sizeof(eventCallbacks));\n-            eventCallbacks.ClassLoad = callbackClassLoad;\n-            eventCallbacks.ClassPrepare=callbackClassPrepare;\n-            eventCallbacks.ClassFileLoadHook=callbackClassFileLoadHock;\n-            rc=jvmti->SetEventCallbacks(&eventCallbacks, sizeof(eventCallbacks));\n-            if (rc != JVMTI_ERROR_NONE) {\n-                NSK_COMPLAIN0(\"Error setting event callbacks\");\n-                return JNI_ERR;\n-            }\n-        }\n-        {\n-            nsk_jvmti_enableNotification(jvmti, JVMTI_EVENT_SINGLE_STEP, testedThread);\n-            nsk_jvmti_enableNotification(jvmti, JVMTI_EVENT_CLASS_LOAD, testedThread);\n-            nsk_jvmti_enableNotification(jvmti, JVMTI_EVENT_CLASS_FILE_LOAD_HOOK, testedThread);\n-            nsk_jvmti_enableNotification(jvmti, JVMTI_EVENT_CLASS_PREPARE, testedThread);\n-            nsk_jvmti_enableNotification(jvmti, JVMTI_EVENT_CLASS_FILE_LOAD_HOOK,testedThread);\n-        }\n-\n-        if (!nsk_jvmti_setAgentProc(agentProc, NULL)) {\n-            NSK_COMPLAIN0(\"setAgentProc failed\");\n-        }\n-        if (!nsk_jvmti_parseOptions(options)) {\n-            NSK_COMPLAIN0(\"Cannot parse options\");\n-        }\n-        NSK_DISPLAY1(\"Wait time: %d\\n\",nsk_jvmti_getWaitTime());\n-        timeout=nsk_jvmti_getWaitTime();\n-        NSK_DISPLAY1(\" returning back.. enter timeout-->%d  \\n\",timeout);\n-        return JNI_OK;\n-    }\n-    \/\/ TODO: shouldn't we return JNI_ERR if GetEnv failed?\n-    return JNI_OK;\n-}\n-\n-JNIEXPORT void JNICALL\n-Java_nsk_jvmti_scenarios_hotswap_HS204_hs204t001_hs204t001_setThread(JNIEnv * env,\n-                         jclass klass,\n-             jobject thread) {\n-    NSK_DISPLAY0(\" Inside the setThread Method\");\n-    if (!NSK_JNI_VERIFY(env, (testClass = (jclass) env->NewGlobalRef(klass)) != NULL))\n-        nsk_jvmti_setFailStatus();\n-    if (!NSK_JNI_VERIFY(env, (testedThread = env->NewGlobalRef(thread)) != NULL))\n-        nsk_jvmti_setFailStatus();\n-}\n-\n-JNIEXPORT jboolean JNICALL\n-Java_nsk_jvmti_scenarios_hotswap_HS204_hs204t001_hs204t001_suspendThread(JNIEnv * env,\n-        jclass klass,\n-        jobject thread) {\n-    jint state;\n-    NSK_DISPLAY0(\"---suspend thread .. \\n\");\n-    if (jvmti->GetThreadState(thread, &state) == JVMTI_ERROR_NONE) {\n-        NSK_DISPLAY0(\" No Errors in finding state of the thread.\\n\");\n-        if (state & JVMTI_THREAD_STATE_ALIVE) {\n-            NSK_DISPLAY0(\" Thread state is alive .. So can be suspend should be possible ..\\n\");\n-            nsk_jvmti_disableNotification(jvmti, JVMTI_EVENT_SINGLE_STEP, thread);\n-            if (!NSK_JVMTI_VERIFY(jvmti->SuspendThread(thread))) {\n-                NSK_COMPLAIN0(\"TEST FAILED: unable to suspend the thread \\n\");\n-                nsk_jvmti_setFailStatus();\n-                return NSK_FALSE;\n-            } else {\n-                NSK_DISPLAY0(\" Sucessfully suspended Thread..\\n\");\n-            }\n-        } else {\n-            NSK_COMPLAIN0(\"Was not able to suspend a thread..\\n\");\n-            return NSK_FALSE;\n-        }\n-    }\n-    return NSK_TRUE;\n-}\n-\n-JNIEXPORT jboolean JNICALL\n-Java_nsk_jvmti_scenarios_hotswap_HS204_hs204t001_hs204t001_popFrame(JNIEnv * env,\n-        jclass klass,\n-        jthread thread) {\n-    jint state;\n-    NSK_DISPLAY0(\"Inside pop_Frame method.....\\n\");\n-    if (jvmti->GetThreadState(thread, &state) == JVMTI_ERROR_NONE) {\n-        NSK_DISPLAY0(\" Got the state of thread \\n\");\n-        if (state & JVMTI_THREAD_STATE_SUSPENDED) {\n-            NSK_DISPLAY0(\" Thread is already in suspended mode..\\n\");\n-            if (!NSK_JVMTI_VERIFY(jvmti->PopFrame(thread))) {\n-                NSK_COMPLAIN0(\" TEST FAILED: UNABLE TO POP FRAME \\n\");\n-                nsk_jvmti_setFailStatus();\n-                return NSK_FALSE;\n-            } else {\n-                NSK_DISPLAY0(\" Poped frame safely..\");\n-            }\n-            \/* We should resume that thread for next execution.. *\/\n-            if (!NSK_JVMTI_VERIFY(jvmti->ResumeThread(thread))) {\n-                NSK_COMPLAIN0(\" TEST FAILED: UNABLE TO Resume thread \\n\");\n-                nsk_jvmti_setFailStatus();\n-                return NSK_FALSE;\n-            } else {\n-                NSK_DISPLAY0(\" Resumed.. thread for next set of executions...\");\n-            }\n-        } else {\n-            NSK_DISPLAY0(\" Thread is not in Suspened State for poping its status..\");\n-        }\n-    }\n-    return NSK_TRUE;\n-}\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/hotswap\/HS204\/hs204t001\/hs204t001.cpp","additions":0,"deletions":307,"binary":false,"changes":307,"status":"deleted"},{"patch":"@@ -1,115 +0,0 @@\n-\/*\n- * Copyright (c) 2007, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- *\n- * @summary converted from VM Testbase nsk\/jvmti\/scenarios\/hotswap\/HS204\/hs204t001.\n- * VM Testbase keywords: [jpda, jvmti, onload_only_caps, noras, redefine, feature_hotswap, quarantine]\n- * VM Testbase comments: 6813266\n- * VM Testbase readme:\n- * DESCRIPTION\n- *     This test is for HS204 T001 scenario of \"HotSwap class and pop frame\".\n- *     There are several java classes. First - hs204t001 - main class - is for redefinitions, running test thread and control\n- *     results.\n- *     All others - hs204t001R - are classes which are redefined and one of them is used to test popFrame feature.\n- *     We enable events ClassFileLoadHook, ClassLoad, and ClassPrepare and popFrame feature.\n- *     Then main class begins list of redefenitions in the following order:\n- *     1. After receiving ClassLoad event, native agent redefines the class being loaded (hs204t001R).\n- *     2. Waits for ClassFileLoadHook event from step 1 and redefines the class again\n- *     3. Catches ClassPrepare event from step 2 and redefines the class again\n- *     4. Receives ClassFileLoadHook event and makes another redefinition\n- *     When all redefinitions have been done, we suspend the thread test class from Java code, invoke popFrame() and resume the test thread.\n- *     This should result in doInThisThread() method executed for the second time.\n- * COMMENTS\n- *\n- * @library \/vmTestbase\n- *          \/test\/lib\n- * @build nsk.jvmti.scenarios.hotswap.HS204.hs204t001.hs204t001\n- *\n- * @comment compile newclassXX to bin\/newclassXX\n- * @run driver nsk.share.ExtraClassesBuilder\n- *      newclass02 newclass03 newclass01 newclass00\n- *\n- * @run main\/othervm\/native\n- *      -agentlib:hs204t001=pathToNewByteCode=.\/bin,-waittime=5,package=nsk,samples=100,mode=compiled\n- *      nsk.jvmti.scenarios.hotswap.HS204.hs204t001.hs204t001\n- *\/\n-\n-package nsk.jvmti.scenarios.hotswap.HS204.hs204t001;\n-import java.io.PrintStream;\n-import nsk.share.Log;\n-import nsk.share.Consts;\n-import nsk.share.jvmti.ArgumentHandler;\n-import nsk.share.jvmti.DebugeeClass;\n-import java.util.concurrent.atomic.AtomicBoolean;\n-\n-public class hs204t001 extends DebugeeClass {\n-    static int status = Consts.TEST_PASSED;\n-    static Log log = null;\n-    static native void setThread(Thread thread);\n-    static native boolean suspendThread(Thread thread);\n-    static native boolean popFrame(Thread thread);\n-\n-    public static void main(String[] args) {\n-        args = nsk.share.jvmti.JVMTITest.commonInit(args);\n-        System.exit(Consts.JCK_STATUS_BASE + run(args, System.out));\n-    }\n-\n-    \/\/ redirecting for some of the testing models.\n-    public static int run(String[] args , PrintStream out) {\n-        return new hs204t001().runIt(args, out);\n-    }\n-\n-    private int runIt(String[] args, PrintStream out) {\n-        int iter;\n-        ArgumentHandler argHandler = new ArgumentHandler(args);\n-        int timeout = argHandler.findOptionIntValue(\"-waittime\",10);\n-        out.println(\"... timeout.. \"+timeout);\n-        out.println(\".. Path \"+argHandler.findOptionValue(\"pathToNewByteCode\"));\n-        \/\/ Logger was initialized.\n-        log = new Log(out, argHandler);\n-        out.println(\" Testing started..\");\n-        hs204t001R  t1;\n-        t1= new hs204t001R() ;\n-        setThread(t1);\n-        t1.start();\n-        int afterSuspend=0;\n-        try {\n-            while(!hs204t001R.suspend.get());\n-            out.println(\" State..\"+t1.getIndex());\n-            suspendThread(t1);\n-            afterSuspend=t1.getIndex();\n-            \/\/System.out.println(\"after suspending the read contents of index =\"+t1.data);\n-            hs204t001R.run.set(false);\n-            popFrame(t1);\n-            \/\/ resume this thread.\n-            t1.join();\n-        } catch(InterruptedException ie) {\n-            ie.printStackTrace();\n-        }\n-        log.display(\" index == \"+t1.getIndex());\n-        out.println(\" index =\"+t1.getIndex());\n-        return (t1.getIndex() == afterSuspend  ? 0 : 1);\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/hotswap\/HS204\/hs204t001\/hs204t001.java","additions":0,"deletions":115,"binary":false,"changes":115,"status":"deleted"},{"patch":"@@ -1,56 +0,0 @@\n-\/*\n- * Copyright (c) 2007, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package nsk.jvmti.scenarios.hotswap.HS204.hs204t001;\n-\n-import java.util.concurrent.atomic.AtomicBoolean;\n-public class hs204t001R extends Thread {\n-      static public AtomicBoolean suspend = new AtomicBoolean(false);\n-      static public AtomicBoolean run = new AtomicBoolean(true);\n-\n-        private  int index=0;\n-\n-        public hs204t001R() {\n-                setName(\"hs204t001R\");\n-                System.out.println(\"hs204t001R--NewOne\");\n-        }\n-\n-        public void run() {\n-                System.out.println(\"Thread started\");\n-                doInThisThread();\n-                System.out.println(\"Thread exiting\");\n-        }\n-\n-        private void doInThisThread() {\n-                while(hs204t001R.run.get()) {\n-                                index+=10;\n-                        if (index == 1500) {\n-                                hs204t001R.suspend.set(true);\n-                        }\n-                }\n-        }\n-\n-        public int getIndex() {\n-                return index;\n-        }\n-\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/hotswap\/HS204\/hs204t001\/hs204t001R.java","additions":0,"deletions":56,"binary":false,"changes":56,"status":"deleted"},{"patch":"@@ -1,33 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include \"native_thread.cpp\"\n-#include \"nsk_tools.cpp\"\n-#include \"jni_tools.cpp\"\n-#include \"jvmti_tools.cpp\"\n-#include \"agent_tools.cpp\"\n-#include \"jvmti_FollowRefObjects.cpp\"\n-#include \"Injector.cpp\"\n-#include \"JVMTITools.cpp\"\n-#include \"agent_common.cpp\"\n-#include \"hs204t001.cpp\"\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/hotswap\/HS204\/hs204t001\/libhs204t001.cpp","additions":0,"deletions":33,"binary":false,"changes":33,"status":"deleted"},{"patch":"@@ -1,56 +0,0 @@\n-\/*\n- * Copyright (c) 2007, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package nsk.jvmti.scenarios.hotswap.HS204.hs204t001;\n-import java.util.concurrent.atomic.AtomicBoolean;\n-public class hs204t001R extends Thread {\n-      static public AtomicBoolean suspend = new AtomicBoolean(false);\n-      static public AtomicBoolean run = new AtomicBoolean(true);\n-\n-        private  int index=0;\n-\n-        public hs204t001R() {\n-                setName(\"hs204t001R\");\n-                System.out.println(\"hs204t001R\");\n-        }\n-\n-        public void run() {\n-                System.out.println(\" started running thread..\");\n-                doInThisThread();\n-                System.out.println(\" comming out ..\");\n-        }\n-\n-        private void doInThisThread() {\n-                System.out.println(\"... Inside doThisThread..\");\n-                while(hs204t001R.run.get()) {\n-                                index+=10;\n-                        if (index == 1500) {\n-                                hs204t001R.suspend.set(true);\n-                        }\n-                }\n-        }\n-\n-        public int getIndex() {\n-                return index;\n-        }\n-\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/hotswap\/HS204\/hs204t001\/newclass00\/hs204t001R.java","additions":0,"deletions":56,"binary":false,"changes":56,"status":"deleted"},{"patch":"@@ -1,57 +0,0 @@\n-\/*\n- * Copyright (c) 2007, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package nsk.jvmti.scenarios.hotswap.HS204.hs204t001;\n-\n-import java.util.concurrent.atomic.AtomicBoolean;\n-public class hs204t001R extends Thread{\n-      static public AtomicBoolean suspend = new AtomicBoolean(false);\n-      static public AtomicBoolean run = new AtomicBoolean(true);\n-\n-        private int index=0;\n-\n-        public hs204t001R() {\n-                super();\n-                setName(\"hs204t001R\");\n-                System.out.println(\"NEWCLASS01\") ;\n-        }\n-\n-        public void run() {\n-                System.out.println(\" started running thread..\");\n-                doInThisThread();\n-                System.out.println(\" comming out ..\");\n-        }\n-\n-        private void doInThisThread() {\n-                System.out.println(\"... Inside doThisThread..\");\n-                while(hs204t001R.run.get()) {\n-                                index+=1;\n-                        if (index == 1500) {\n-                                hs204t001R.suspend.set(true);\n-                        }\n-                }\n-        }\n-        public int getIndex() {\n-                return index;\n-        }\n-\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/hotswap\/HS204\/hs204t001\/newclass01\/hs204t001R.java","additions":0,"deletions":57,"binary":false,"changes":57,"status":"deleted"},{"patch":"@@ -1,55 +0,0 @@\n-\/*\n- * Copyright (c) 2007, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package nsk.jvmti.scenarios.hotswap.HS204.hs204t001;\n-import java.util.concurrent.atomic.AtomicBoolean;\n-public class hs204t001R extends Thread{\n-      static public AtomicBoolean suspend = new AtomicBoolean(false);\n-      static public AtomicBoolean run = new AtomicBoolean(true);\n-        private int index=0;\n-\n-        public hs204t001R() {\n-                super();\n-                setName(\"hs204t001R\");\n-                System.out.println(\"NEWCLASS02\");\n-        }\n-\n-        public void run() {\n-                System.out.println(\" started running thread..\");\n-                doInThisThread();\n-                System.out.println(\" comming out ..\");\n-        }\n-\n-        private void doInThisThread() {\n-                System.out.println(\"... Inside doThisThread..\");\n-                while(hs204t001R.run.get()) {\n-                                index+=1;\n-                        if (index == 1500) {\n-                                hs204t001R.suspend.set(true);\n-                        }\n-                }\n-        }\n-        public int getIndex() {\n-                return index;\n-        }\n-\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/hotswap\/HS204\/hs204t001\/newclass02\/hs204t001R.java","additions":0,"deletions":55,"binary":false,"changes":55,"status":"deleted"},{"patch":"@@ -1,56 +0,0 @@\n-\/*\n- * Copyright (c) 2007, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package nsk.jvmti.scenarios.hotswap.HS204.hs204t001;\n-import java.util.concurrent.atomic.AtomicBoolean;\n-public class hs204t001R extends Thread{\n-      static public AtomicBoolean suspend = new AtomicBoolean(false);\n-      static public AtomicBoolean run = new AtomicBoolean(true);\n-\n-        private int index=0;\n-\n-        public hs204t001R() {\n-                super();\n-                setName(\"hs204t001R\");\n-                System.out.println(\"NEWCLASS04\");\n-        }\n-\n-        public void run() {\n-                System.out.println(\" started running thread..\");\n-                doInThisThread();\n-                System.out.println(\" comming out ..\");\n-        }\n-\n-        private void doInThisThread() {\n-                System.out.println(\"... Inside doThisThread..\");\n-                while(hs204t001R.run.get()) {\n-                                index+=1;\n-                        if (index == 1500) {\n-                                hs204t001R.suspend.set(true);\n-                        }\n-                }\n-        }\n-        public int getIndex() {\n-                return index;\n-        }\n-\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/hotswap\/HS204\/hs204t001\/newclass03\/hs204t001R.java","additions":0,"deletions":56,"binary":false,"changes":56,"status":"deleted"}]}