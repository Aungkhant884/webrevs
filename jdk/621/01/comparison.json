{"files":[{"patch":"@@ -1,274 +0,0 @@\n-\/*\n- * Copyright (c) 1998, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.formats.html;\n-\n-import java.util.List;\n-import java.util.SortedSet;\n-\n-import javax.lang.model.element.Element;\n-import javax.lang.model.element.ElementKind;\n-import javax.lang.model.element.ModuleElement;\n-import javax.lang.model.element.PackageElement;\n-import javax.lang.model.element.TypeElement;\n-\n-import com.sun.source.doctree.DocTree;\n-\n-import jdk.javadoc.internal.doclets.formats.html.markup.Entity;\n-import jdk.javadoc.internal.doclets.formats.html.markup.HtmlStyle;\n-import jdk.javadoc.internal.doclets.formats.html.markup.TagName;\n-import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTree;\n-import jdk.javadoc.internal.doclets.formats.html.Navigation.PageMode;\n-import jdk.javadoc.internal.doclets.formats.html.markup.StringContent;\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n-import jdk.javadoc.internal.doclets.toolkit.util.DocPath;\n-import jdk.javadoc.internal.doclets.toolkit.util.IndexBuilder;\n-import jdk.javadoc.internal.doclets.toolkit.util.IndexItem;\n-\n-\/**\n- * Generate Index for all the Member Names with Indexing in\n- * Unicode Order. This class is a base class for {@link SingleIndexWriter} and\n- * {@link SplitIndexWriter}. It uses the functionality from\n- * {@link HtmlDocletWriter} to generate the Index Contents.\n- *\n- *  <p><b>This is NOT part of any supported API.\n- *  If you write code that depends on this, you do so at your own risk.\n- *  This code and its internal interfaces are subject to change or\n- *  deletion without notice.<\/b>\n- *\n- * @see IndexBuilder\n- *\/\n-public class AbstractIndexWriter extends HtmlDocletWriter {\n-\n-    protected final IndexBuilder mainIndex;\n-\n-    protected final Navigation navBar;\n-\n-    \/**\n-     * Initializes the common data for writers that can generate index files\n-     * based on the information in {@code configuration.mainIndex}.\n-     *\n-     * @param configuration  the current configuration\n-     * @param path           path to the file which is getting generated.\n-     *\/\n-    protected AbstractIndexWriter(HtmlConfiguration configuration,\n-                                  DocPath path) {\n-        super(configuration, path);\n-        this.mainIndex = configuration.mainIndex;\n-        this.navBar = new Navigation(null, configuration, PageMode.INDEX, path);\n-    }\n-\n-    protected void addContents(Character uc, SortedSet<IndexItem> memberlist,\n-            Content contentTree) {\n-        addHeading(uc, contentTree);\n-\n-        HtmlTree dl = HtmlTree.DL(HtmlStyle.index);\n-        for (IndexItem item : memberlist) {\n-            addDescription(item, dl);\n-        }\n-        contentTree.add(dl);\n-    }\n-\n-    protected void addHeading(Character uc, Content contentTree) {\n-        String unicode = uc.toString();\n-        Content headContent = new StringContent(unicode);\n-        HtmlTree heading = HtmlTree.HEADING(Headings.CONTENT_HEADING,\n-                HtmlStyle.title, headContent);\n-        heading.setId(getNameForIndex(unicode));\n-        contentTree.add(heading);\n-    }\n-\n-    protected void addDescription(IndexItem indexItem, Content dl) {\n-        if (indexItem.isTagItem()) {\n-            addTagDescription(indexItem, dl);\n-        } else if (indexItem.isElementItem()) {\n-            addElementDescription(indexItem, dl);\n-        }\n-    }\n-\n-    \/**\n-     * Add one line summary comment for the element.\n-     *\n-     * @param item the element to be documented\n-     * @param dlTree the content tree to which the description will be added\n-     *\/\n-    protected void addElementDescription(IndexItem item, Content dlTree) {\n-        Content dt;\n-        Element element = item.getElement();\n-        String label = item.getLabel();\n-        switch (element.getKind()) {\n-            case MODULE:\n-                dt = HtmlTree.DT(getModuleLink((ModuleElement) element, new StringContent(label)));\n-                dt.add(\" - \").add(contents.module_).add(\" \" + label);\n-                break;\n-\n-            case PACKAGE:\n-                dt = HtmlTree.DT(getPackageLink((PackageElement) element, new StringContent(label)));\n-                if (configuration.showModules) {\n-                    item.setContainingModule(utils.getFullyQualifiedName(utils.containingModule(element)));\n-                }\n-                dt.add(\" - \").add(contents.package_).add(\" \" + label);\n-                break;\n-\n-            case CLASS:\n-            case ENUM:\n-            case RECORD:\n-            case ANNOTATION_TYPE:\n-            case INTERFACE:\n-                dt = HtmlTree.DT(getLink(new LinkInfoImpl(configuration,\n-                        LinkInfoImpl.Kind.INDEX, (TypeElement) element).strong(true)));\n-                dt.add(\" - \");\n-                addClassInfo((TypeElement) element, dt);\n-                break;\n-\n-            case CONSTRUCTOR:\n-            case METHOD:\n-            case FIELD:\n-            case ENUM_CONSTANT:\n-                TypeElement containingType = item.getContainingTypeElement();\n-                dt = HtmlTree.DT(HtmlTree.SPAN(HtmlStyle.memberNameLink,\n-                        getDocLink(LinkInfoImpl.Kind.INDEX, containingType, element, new StringContent(label))));\n-                dt.add(\" - \");\n-                addMemberDesc(element, containingType, dt);\n-                break;\n-\n-            default:\n-                throw new Error();\n-        }\n-        dlTree.add(dt);\n-        Content dd = new HtmlTree(TagName.DD);\n-        if (element.getKind() == ElementKind.MODULE || element.getKind() == ElementKind.PACKAGE) {\n-            addSummaryComment(element, dd);\n-        } else {\n-            addComment(element, dd);\n-        }\n-        dlTree.add(dd);\n-    }\n-\n-    \/**\n-     * Add the classkind (class, interface, exception), error of the class\n-     * passed.\n-     *\n-     * @param te the class being documented\n-     * @param contentTree the content tree to which the class info will be added\n-     *\/\n-    protected void addClassInfo(TypeElement te, Content contentTree) {\n-        contentTree.add(contents.getContent(\"doclet.in\",\n-                utils.getTypeElementName(te, false),\n-                getPackageLink(utils.containingPackage(te),\n-                    utils.getPackageName(utils.containingPackage(te)))\n-                ));\n-    }\n-\n-    protected void addTagDescription(IndexItem item, Content dlTree) {\n-        String itemPath = pathToRoot.isEmpty() ? \"\" : pathToRoot.getPath() + \"\/\";\n-        itemPath += item.getUrl();\n-        HtmlTree labelLink = HtmlTree.A(itemPath, new StringContent(item.getLabel()));\n-        Content dt = HtmlTree.DT(HtmlTree.SPAN(HtmlStyle.searchTagLink, labelLink));\n-        dt.add(\" - \");\n-        dt.add(contents.getContent(\"doclet.Search_tag_in\", item.getHolder()));\n-        dlTree.add(dt);\n-        Content dd = new HtmlTree(TagName.DD);\n-        if (item.getDescription().isEmpty()) {\n-            dd.add(Entity.NO_BREAK_SPACE);\n-        } else {\n-            dd.add(item.getDescription());\n-        }\n-        dlTree.add(dd);\n-    }\n-\n-    \/**\n-     * Add comment for each element in the index. If the element is deprecated\n-     * and it has a @deprecated tag, use that comment. Else if the containing\n-     * class for this element is deprecated, then add the word \"Deprecated.\" at\n-     * the start and then print the normal comment.\n-     *\n-     * @param element Index element\n-     * @param contentTree the content tree to which the comment will be added\n-     *\/\n-    protected void addComment(Element element, Content contentTree) {\n-        List<? extends DocTree> tags;\n-        Content span = HtmlTree.SPAN(HtmlStyle.deprecatedLabel, getDeprecatedPhrase(element));\n-        HtmlTree div = new HtmlTree(TagName.DIV);\n-        div.setStyle(HtmlStyle.deprecationBlock);\n-        if (utils.isDeprecated(element)) {\n-            div.add(span);\n-            tags = utils.getBlockTags(element, DocTree.Kind.DEPRECATED);\n-            if (!tags.isEmpty())\n-                addInlineDeprecatedComment(element, tags.get(0), div);\n-            contentTree.add(div);\n-        } else {\n-            TypeElement encl = utils.getEnclosingTypeElement(element);\n-            while (encl != null) {\n-                if (utils.isDeprecated(encl)) {\n-                    div.add(span);\n-                    contentTree.add(div);\n-                    break;\n-                }\n-                encl = utils.getEnclosingTypeElement(encl);\n-            }\n-            addSummaryComment(element, contentTree);\n-        }\n-    }\n-\n-    \/**\n-     * Add description about the Static Variable\/Method\/Constructor for a\n-     * member.\n-     *\n-     * @param member element for the member\n-     * @param enclosing the enclosing type element\n-     * @param contentTree the content tree to which the member description will be added\n-     *\/\n-    protected void addMemberDesc(Element member, TypeElement enclosing, Content contentTree) {\n-        String classdesc = utils.getTypeElementName(enclosing, true) + \" \";\n-        if (utils.isField(member)) {\n-            Content resource = contents.getContent(utils.isStatic(member)\n-                    ? \"doclet.Static_variable_in\"\n-                    : \"doclet.Variable_in\", classdesc);\n-            contentTree.add(resource);\n-        } else if (utils.isConstructor(member)) {\n-            contentTree.add(\n-                    contents.getContent(\"doclet.Constructor_for\", classdesc));\n-        } else if (utils.isMethod(member)) {\n-            Content resource = contents.getContent(utils.isStatic(member)\n-                    ? \"doclet.Static_method_in\"\n-                    : \"doclet.Method_in\", classdesc);\n-            contentTree.add(resource);\n-        }\n-        addPreQualifiedClassLink(LinkInfoImpl.Kind.INDEX, enclosing,\n-                false, contentTree);\n-    }\n-\n-    \/**\n-     * Generate a valid HTML name for member index page.\n-     *\n-     * @param unicode the string that needs to be converted to valid HTML name.\n-     * @return a valid HTML name string.\n-     *\/\n-    public String getNameForIndex(String unicode) {\n-        return \"I:\" + links.getName(unicode);\n-    }\n-\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/AbstractIndexWriter.java","additions":0,"deletions":274,"binary":false,"changes":274,"status":"deleted"},{"patch":"@@ -174,5 +174,1 @@\n-            if (options.splitIndex()) {\n-                SplitIndexWriter.generate(configuration);\n-            } else {\n-                SingleIndexWriter.generate(configuration);\n-            }\n+            IndexWriter.generate(configuration);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/HtmlDoclet.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,400 @@\n+\/*\n+ * Copyright (c) 1998, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.javadoc.internal.doclets.formats.html;\n+\n+import java.util.List;\n+import java.util.ListIterator;\n+import java.util.SortedSet;\n+\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ElementKind;\n+import javax.lang.model.element.ModuleElement;\n+import javax.lang.model.element.PackageElement;\n+import javax.lang.model.element.TypeElement;\n+\n+import com.sun.source.doctree.DocTree;\n+\n+import jdk.javadoc.internal.doclets.formats.html.markup.BodyContents;\n+import jdk.javadoc.internal.doclets.formats.html.markup.ContentBuilder;\n+import jdk.javadoc.internal.doclets.formats.html.markup.Entity;\n+import jdk.javadoc.internal.doclets.formats.html.markup.HtmlStyle;\n+import jdk.javadoc.internal.doclets.formats.html.markup.TagName;\n+import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTree;\n+import jdk.javadoc.internal.doclets.formats.html.Navigation.PageMode;\n+import jdk.javadoc.internal.doclets.formats.html.markup.StringContent;\n+import jdk.javadoc.internal.doclets.toolkit.Content;\n+import jdk.javadoc.internal.doclets.toolkit.util.DocFileIOException;\n+import jdk.javadoc.internal.doclets.toolkit.util.DocPath;\n+import jdk.javadoc.internal.doclets.toolkit.util.DocPaths;\n+import jdk.javadoc.internal.doclets.toolkit.util.IndexBuilder;\n+import jdk.javadoc.internal.doclets.toolkit.util.IndexItem;\n+\n+\/**\n+ * Generator for either a single index or split index for all\n+ * documented elements, terms defined in some documentation comments,\n+ * and summary pages.\n+ *\n+ *  <p><b>This is NOT part of any supported API.\n+ *  If you write code that depends on this, you do so at your own risk.\n+ *  This code and its internal interfaces are subject to change or\n+ *  deletion without notice.<\/b>\n+ *\n+ * @see IndexBuilder\n+ *\/\n+public class IndexWriter extends HtmlDocletWriter {\n+\n+    protected final IndexBuilder mainIndex;\n+    protected final boolean splitIndex;\n+\n+    \/**\n+     * Generates the main index of all documented elements, terms defined in some documentation\n+     * comments, and summary pages.\n+     *\n+     * If {@link HtmlOptions#splitIndex()} is true, a separate page is generated for each\n+     * initial letter; otherwise, a single page is generated for all items in the index.\n+     *\n+     * @param configuration the configuration\n+     * @throws DocFileIOException if an error occurs while writing the files\n+     *\/\n+    public static void generate(HtmlConfiguration configuration) throws DocFileIOException {\n+        IndexBuilder mainIndex = configuration.mainIndex;\n+        List<Character> firstCharacters = mainIndex.getFirstCharacters();\n+        if (configuration.getOptions().splitIndex()) {\n+            ListIterator<Character> iter = firstCharacters.listIterator();\n+            while (iter.hasNext()) {\n+                Character ch = iter.next();\n+                DocPath file = DocPaths.INDEX_FILES.resolve(DocPaths.indexN(iter.nextIndex()));\n+                IndexWriter writer = new IndexWriter(configuration, file);\n+                writer.generateIndexFile(firstCharacters, List.of(ch));\n+            }\n+        } else {\n+            IndexWriter writer = new IndexWriter(configuration, DocPaths.INDEX_ALL);\n+            writer.generateIndexFile(firstCharacters, firstCharacters);\n+        }\n+    }\n+\n+    \/**\n+     * Creates a writer that can write a page containing some or all of the overall index.\n+     *\n+     * @param configuration  the current configuration\n+     * @param path           the file to be generated\n+     *\/\n+    protected IndexWriter(HtmlConfiguration configuration, DocPath path) {\n+        super(configuration, path);\n+        this.mainIndex = configuration.mainIndex;\n+        this.splitIndex = configuration.getOptions().splitIndex();\n+    }\n+\n+    \/**\n+     * Generates a page containing some or all of the overall index.\n+     *\n+     * @param allFirstCharacters     the initial characters of all index items\n+     * @param displayFirstCharacters the initial characters of the index items to appear on this page\n+     * @throws DocFileIOException if an error occurs while writing the page\n+     *\/\n+    protected void generateIndexFile(List<Character> allFirstCharacters,\n+                                     List<Character> displayFirstCharacters) throws DocFileIOException {\n+        String title = splitIndex\n+                ? resources.getText(\"doclet.Window_Split_Index\", displayFirstCharacters.get(0))\n+                : resources.getText(\"doclet.Window_Single_Index\");\n+        HtmlTree body = getBody(getWindowTitle(title));\n+        Content headerContent = new ContentBuilder();\n+        addTop(headerContent);\n+        Navigation navBar = new Navigation(null, configuration, PageMode.INDEX, path);\n+        navBar.setUserHeader(getUserHeaderFooter(true));\n+        headerContent.add(navBar.getContent(Navigation.Position.TOP));\n+        Content mainContent = new ContentBuilder();\n+        addLinksForIndexes(allFirstCharacters, mainContent);\n+        for (Character ch : displayFirstCharacters) {\n+            addContents(ch, mainIndex.getItems(ch), mainContent);\n+        }\n+        addLinksForIndexes(allFirstCharacters, mainContent);\n+        HtmlTree footer = HtmlTree.FOOTER();\n+        navBar.setUserFooter(getUserHeaderFooter(false));\n+        footer.add(navBar.getContent(Navigation.Position.BOTTOM));\n+        addBottom(footer);\n+        body.add(new BodyContents()\n+                .setHeader(headerContent)\n+                .addMainContent(HtmlTree.DIV(HtmlStyle.header,\n+                        HtmlTree.HEADING(Headings.PAGE_TITLE_HEADING,\n+                                contents.getContent(\"doclet.Index\"))))\n+                .addMainContent(mainContent)\n+                .setFooter(footer));\n+\n+        String description = splitIndex ? \"index: \" + displayFirstCharacters.get(0) : \"index\";\n+        printHtmlDocument(null, description, body);\n+    }\n+\n+    \/**\n+     * Adds a set of items to the page.\n+     *\n+     * @param ch          the first character of the names of the items\n+     * @param items       the items\n+     * @param contentTree the tree to which to add the items\n+     *\/\n+    protected void addContents(char ch, SortedSet<IndexItem> items, Content contentTree) {\n+        addHeading(ch, contentTree);\n+\n+        HtmlTree dl = HtmlTree.DL(HtmlStyle.index);\n+        for (IndexItem item : items) {\n+            addDescription(item, dl);\n+        }\n+        contentTree.add(dl);\n+    }\n+\n+    \/**\n+     * Adds a heading containing the first character for a set of items.\n+     *\n+     * @param ch          the first character of the names of the items\n+     * @param contentTree the tree to which to add the items\n+     *\/\n+    protected void addHeading(char ch, Content contentTree) {\n+        Content headContent = new StringContent(String.valueOf(ch));\n+        HtmlTree heading = HtmlTree.HEADING(Headings.CONTENT_HEADING, HtmlStyle.title, headContent)\n+                .setId(getNameForIndex(ch));\n+        contentTree.add(heading);\n+    }\n+\n+    \/**\n+     * Adds the description for an index item into a list.\n+     *\n+     * @param indexItem the item\n+     * @param dl        the list\n+     *\/\n+    protected void addDescription(IndexItem indexItem, Content dl) {\n+        if (indexItem.isTagItem()) {\n+            addTagDescription(indexItem, dl);\n+        } else if (indexItem.isElementItem()) {\n+            addElementDescription(indexItem, dl);\n+        }\n+    }\n+\n+    \/**\n+     * Add one line summary comment for the item.\n+     *\n+     * @param item the item to be documented\n+     * @param dlTree the content tree to which the description will be added\n+     *\/\n+    protected void addElementDescription(IndexItem item, Content dlTree) {\n+        Content dt;\n+        Element element = item.getElement();\n+        String label = item.getLabel();\n+        switch (element.getKind()) {\n+            case MODULE:\n+                dt = HtmlTree.DT(getModuleLink((ModuleElement) element, new StringContent(label)));\n+                dt.add(\" - \").add(contents.module_).add(\" \" + label);\n+                break;\n+\n+            case PACKAGE:\n+                dt = HtmlTree.DT(getPackageLink((PackageElement) element, new StringContent(label)));\n+                if (configuration.showModules) {\n+                    item.setContainingModule(utils.getFullyQualifiedName(utils.containingModule(element)));\n+                }\n+                dt.add(\" - \").add(contents.package_).add(\" \" + label);\n+                break;\n+\n+            case CLASS:\n+            case ENUM:\n+            case RECORD:\n+            case ANNOTATION_TYPE:\n+            case INTERFACE:\n+                dt = HtmlTree.DT(getLink(new LinkInfoImpl(configuration,\n+                        LinkInfoImpl.Kind.INDEX, (TypeElement) element).strong(true)));\n+                dt.add(\" - \");\n+                addClassInfo((TypeElement) element, dt);\n+                break;\n+\n+            case CONSTRUCTOR:\n+            case METHOD:\n+            case FIELD:\n+            case ENUM_CONSTANT:\n+                TypeElement containingType = item.getContainingTypeElement();\n+                dt = HtmlTree.DT(HtmlTree.SPAN(HtmlStyle.memberNameLink,\n+                        getDocLink(LinkInfoImpl.Kind.INDEX, containingType, element, new StringContent(label))));\n+                dt.add(\" - \");\n+                addMemberDesc(element, containingType, dt);\n+                break;\n+\n+            default:\n+                throw new Error();\n+        }\n+        dlTree.add(dt);\n+        Content dd = new HtmlTree(TagName.DD);\n+        if (element.getKind() == ElementKind.MODULE || element.getKind() == ElementKind.PACKAGE) {\n+            addSummaryComment(element, dd);\n+        } else {\n+            addComment(element, dd);\n+        }\n+        dlTree.add(dd);\n+    }\n+\n+    \/**\n+     * Adds information for the given type element.\n+     *\n+     * @param te          the element\n+     * @param contentTree the content tree to which the class info will be added\n+     *\/\n+    protected void addClassInfo(TypeElement te, Content contentTree) {\n+        contentTree.add(contents.getContent(\"doclet.in\",\n+                utils.getTypeElementKindName(te, false),\n+                getPackageLink(utils.containingPackage(te),\n+                    utils.getPackageName(utils.containingPackage(te)))\n+                ));\n+    }\n+\n+    \/**\n+     * Adds a description for an item found in a documentation comment.\n+     *\n+     * @param item   the item\n+     * @param dlTree the list to which to add the description\n+     *\/\n+    protected void addTagDescription(IndexItem item, Content dlTree) {\n+        String itemPath = pathToRoot.isEmpty() ? \"\" : pathToRoot.getPath() + \"\/\";\n+        itemPath += item.getUrl();\n+        HtmlTree labelLink = HtmlTree.A(itemPath, new StringContent(item.getLabel()));\n+        Content dt = HtmlTree.DT(HtmlTree.SPAN(HtmlStyle.searchTagLink, labelLink));\n+        dt.add(\" - \");\n+        dt.add(contents.getContent(\"doclet.Search_tag_in\", item.getHolder()));\n+        dlTree.add(dt);\n+        Content dd = new HtmlTree(TagName.DD);\n+        if (item.getDescription().isEmpty()) {\n+            dd.add(Entity.NO_BREAK_SPACE);\n+        } else {\n+            dd.add(item.getDescription());\n+        }\n+        dlTree.add(dd);\n+    }\n+\n+    \/**\n+     * Adds a comment for an element in the index. If the element is deprecated\n+     * and it has a @deprecated tag, use that comment; otherwise,  if the containing\n+     * class for this element is deprecated, then add the word \"Deprecated.\" at\n+     * the start and then print the normal comment.\n+     *\n+     * @param element     the element\n+     * @param contentTree the content tree to which the comment will be added\n+     *\/\n+    protected void addComment(Element element, Content contentTree) {\n+        List<? extends DocTree> tags;\n+        Content span = HtmlTree.SPAN(HtmlStyle.deprecatedLabel, getDeprecatedPhrase(element));\n+        HtmlTree div = new HtmlTree(TagName.DIV);\n+        div.setStyle(HtmlStyle.deprecationBlock);\n+        if (utils.isDeprecated(element)) {\n+            div.add(span);\n+            tags = utils.getBlockTags(element, DocTree.Kind.DEPRECATED);\n+            if (!tags.isEmpty())\n+                addInlineDeprecatedComment(element, tags.get(0), div);\n+            contentTree.add(div);\n+        } else {\n+            TypeElement encl = utils.getEnclosingTypeElement(element);\n+            while (encl != null) {\n+                if (utils.isDeprecated(encl)) {\n+                    div.add(span);\n+                    contentTree.add(div);\n+                    break;\n+                }\n+                encl = utils.getEnclosingTypeElement(encl);\n+            }\n+            addSummaryComment(element, contentTree);\n+        }\n+    }\n+\n+    \/**\n+     * Adds a description for a member element.\n+     *\n+     * @param member      the element\n+     * @param enclosing   the enclosing type element\n+     * @param contentTree the content tree to which the member description will be added\n+     *\/\n+    protected void addMemberDesc(Element member, TypeElement enclosing, Content contentTree) {\n+        String kindName = utils.getTypeElementKindName(enclosing, true);\n+        String resource = switch (member.getKind()) {\n+            case ENUM_CONSTANT ->\n+                    \"doclet.Enum_constant_in\";\n+            case FIELD ->\n+                    utils.isStatic(member) ? \"doclet.Static_variable_in\" : \"doclet.Variable_in\";\n+            case CONSTRUCTOR ->\n+                    \"doclet.Constructor_for\";\n+            case METHOD ->\n+                    utils.isAnnotationType(enclosing) ? \"doclet.Element_in\"\n+                            : utils.isStatic(member) ? \"doclet.Static_method_in\" : \"doclet.Method_in\";\n+            case RECORD_COMPONENT ->\n+                    \"doclet.Record_component_in\";\n+            default -> throw new IllegalArgumentException(member.getKind().toString());\n+        };\n+        contentTree.add(contents.getContent(resource, kindName)).add(\" \");\n+        addPreQualifiedClassLink(LinkInfoImpl.Kind.INDEX, enclosing,\n+                false, contentTree);\n+    }\n+\n+    \/**\n+     * Add links for all the index files, based on the first character of the names of the items.\n+     *\n+     * @param allFirstCharacters the list of all first characters to be linked\n+     * @param contentTree        the content tree to which the links for indexes will be added\n+     *\/\n+    protected void addLinksForIndexes(List<Character> allFirstCharacters, Content contentTree) {\n+        ListIterator<Character> iter = allFirstCharacters.listIterator();\n+        while (iter.hasNext()) {\n+            char ch = iter.next();\n+            Content label = new StringContent(Character.toString(ch));\n+            Content link = splitIndex\n+                    ? links.createLink(DocPaths.indexN(iter.nextIndex()), label)\n+                    : links.createLink(getNameForIndex(ch), label);\n+            contentTree.add(link);\n+            contentTree.add(Entity.NO_BREAK_SPACE);\n+        }\n+\n+        contentTree.add(new HtmlTree(TagName.BR));\n+\n+        contentTree.add(links.createLink(pathToRoot.resolve(DocPaths.ALLCLASSES_INDEX),\n+                contents.allClassesLabel));\n+\n+        if (!configuration.packages.isEmpty()) {\n+            contentTree.add(getVerticalSeparator());\n+            contentTree.add(links.createLink(pathToRoot.resolve(DocPaths.ALLPACKAGES_INDEX),\n+                    contents.allPackagesLabel));\n+        }\n+\n+        boolean anySystemProperties = !mainIndex.getItems(DocTree.Kind.SYSTEM_PROPERTY).isEmpty();\n+        if (anySystemProperties) {\n+            contentTree.add(getVerticalSeparator());\n+            contentTree.add(links.createLink(pathToRoot.resolve(DocPaths.SYSTEM_PROPERTIES),\n+                    contents.systemPropertiesLabel));\n+        }\n+    }\n+\n+    \/**\n+     * Returns the anchor name for a first character of names in the index.\n+     *\n+     * @param firstCharacter the character\n+     * @return               a name\n+     *\/\n+    protected String getNameForIndex(char firstCharacter) {\n+        return \"I:\" + links.getName(Character.toString(firstCharacter));\n+    }\n+\n+}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/IndexWriter.java","additions":400,"deletions":0,"binary":false,"changes":400,"status":"added"},{"patch":"@@ -1,143 +0,0 @@\n-\/*\n- * Copyright (c) 1998, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.formats.html;\n-\n-import java.util.Set;\n-import java.util.TreeSet;\n-\n-import com.sun.source.doctree.DocTree;\n-import jdk.javadoc.internal.doclets.formats.html.markup.BodyContents;\n-import jdk.javadoc.internal.doclets.formats.html.markup.ContentBuilder;\n-import jdk.javadoc.internal.doclets.formats.html.markup.Entity;\n-import jdk.javadoc.internal.doclets.formats.html.markup.HtmlStyle;\n-import jdk.javadoc.internal.doclets.formats.html.markup.TagName;\n-import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTree;\n-import jdk.javadoc.internal.doclets.formats.html.markup.StringContent;\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n-import jdk.javadoc.internal.doclets.toolkit.util.DocFileIOException;\n-import jdk.javadoc.internal.doclets.toolkit.util.DocPaths;\n-import jdk.javadoc.internal.doclets.toolkit.util.IndexBuilder;\n-import jdk.javadoc.internal.doclets.toolkit.util.IndexItem.Category;\n-\n-\n-\/**\n- * Generate only one index file for all the Member Names with Indexing in\n- * Unicode Order. The name of the generated file is \"index-all.html\" and it is\n- * generated in current or the destination directory.\n- *\n- *  <p><b>This is NOT part of any supported API.\n- *  If you write code that depends on this, you do so at your own risk.\n- *  This code and its internal interfaces are subject to change or\n- *  deletion without notice.<\/b>\n- *\n- * @see java.lang.Character\n- *\/\n-public class SingleIndexWriter extends AbstractIndexWriter {\n-\n-    private Set<Character> firstCharacters;\n-\n-    \/**\n-     * Construct the SingleIndexWriter with filename \"index-all.html\" and the\n-     * {@link IndexBuilder}\n-     *\n-     * @param configuration the configuration for this doclet\n-     *\/\n-    public SingleIndexWriter(HtmlConfiguration configuration) {\n-        super(configuration, DocPaths.INDEX_ALL);\n-    }\n-\n-    \/**\n-     * Generate single index file, for all Unicode characters.\n-     *\n-     * @param configuration the configuration for this doclet\n-     * @throws DocFileIOException if there is a problem generating the index\n-     *\/\n-    public static void generate(HtmlConfiguration configuration) throws DocFileIOException {\n-        SingleIndexWriter indexgen = new SingleIndexWriter(configuration);\n-        indexgen.generateIndexFile();\n-    }\n-\n-    \/**\n-     * Generate the contents of each index file, with Header, Footer,\n-     * Member Field, Method and Constructor Description.\n-     * @throws DocFileIOException if there is a problem generating the index\n-     *\/\n-    protected void generateIndexFile() throws DocFileIOException {\n-        String title = resources.getText(\"doclet.Window_Single_Index\");\n-        HtmlTree body = getBody(getWindowTitle(title));\n-        Content headerContent = new ContentBuilder();\n-        addTop(headerContent);\n-        navBar.setUserHeader(getUserHeaderFooter(true));\n-        headerContent.add(navBar.getContent(Navigation.Position.TOP));\n-        Content mainContent = new ContentBuilder();\n-        firstCharacters = new TreeSet<>(mainIndex.getFirstCharacters());\n-        addLinksForIndexes(mainContent);\n-        for (Character ch : firstCharacters) {\n-            addContents(ch, mainIndex.getItems(ch), mainContent);\n-        }\n-        addLinksForIndexes(mainContent);\n-        HtmlTree footer = HtmlTree.FOOTER();\n-        navBar.setUserFooter(getUserHeaderFooter(false));\n-        footer.add(navBar.getContent(Navigation.Position.BOTTOM));\n-        addBottom(footer);\n-        body.add(new BodyContents()\n-                .setHeader(headerContent)\n-                .addMainContent(HtmlTree.DIV(HtmlStyle.header,\n-                        HtmlTree.HEADING(Headings.PAGE_TITLE_HEADING,\n-                                contents.getContent(\"doclet.Index\"))))\n-                .addMainContent(mainContent)\n-                .setFooter(footer));\n-        printHtmlDocument(null, \"index\", body);\n-    }\n-\n-    \/**\n-     * Add links for all the Index Files per unicode character.\n-     *\n-     * @param contentTree the content tree to which the links for indexes will be added\n-     *\/\n-    protected void addLinksForIndexes(Content contentTree) {\n-        for (Character ch : firstCharacters) {\n-            String unicode = ch.toString();\n-            contentTree.add(\n-                    links.createLink(getNameForIndex(unicode),\n-                                     new StringContent(unicode)));\n-            contentTree.add(Entity.NO_BREAK_SPACE);\n-        }\n-        contentTree.add(new HtmlTree(TagName.BR));\n-        contentTree.add(links.createLink(DocPaths.ALLCLASSES_INDEX,\n-                                         contents.allClassesLabel));\n-        if (!configuration.packages.isEmpty()) {\n-            contentTree.add(getVerticalSeparator());\n-            contentTree.add(links.createLink(DocPaths.ALLPACKAGES_INDEX,\n-                                             contents.allPackagesLabel));\n-        }\n-        boolean anySystemProperties = !mainIndex.getItems(DocTree.Kind.SYSTEM_PROPERTY).isEmpty();\n-        if (anySystemProperties) {\n-            contentTree.add(getVerticalSeparator());\n-            contentTree.add(links.createLink(DocPaths.SYSTEM_PROPERTIES, contents.systemPropertiesLabel));\n-        }\n-    }\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/SingleIndexWriter.java","additions":0,"deletions":143,"binary":false,"changes":143,"status":"deleted"},{"patch":"@@ -1,166 +0,0 @@\n-\/*\n- * Copyright (c) 1998, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.formats.html;\n-\n-import java.util.ArrayList;\n-import java.util.Collection;\n-import java.util.List;\n-import java.util.ListIterator;\n-import java.util.SortedSet;\n-import java.util.TreeSet;\n-\n-import com.sun.source.doctree.DocTree;\n-import jdk.javadoc.internal.doclets.formats.html.markup.BodyContents;\n-import jdk.javadoc.internal.doclets.formats.html.markup.ContentBuilder;\n-import jdk.javadoc.internal.doclets.formats.html.markup.Entity;\n-import jdk.javadoc.internal.doclets.formats.html.markup.HtmlStyle;\n-import jdk.javadoc.internal.doclets.formats.html.markup.TagName;\n-import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTree;\n-import jdk.javadoc.internal.doclets.formats.html.markup.StringContent;\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n-import jdk.javadoc.internal.doclets.toolkit.util.DocFileIOException;\n-import jdk.javadoc.internal.doclets.toolkit.util.DocPath;\n-import jdk.javadoc.internal.doclets.toolkit.util.DocPaths;\n-import jdk.javadoc.internal.doclets.toolkit.util.IndexBuilder;\n-import jdk.javadoc.internal.doclets.toolkit.util.IndexItem.Category;\n-\n-\/**\n- * Generate Separate Index Files for all the member names with Indexing in\n- * Unicode Order. This will create \"index-files\" directory in the current or\n- * destination directory and will generate separate file for each unicode index.\n- *\n- *  <p><b>This is NOT part of any supported API.\n- *  If you write code that depends on this, you do so at your own risk.\n- *  This code and its internal interfaces are subject to change or\n- *  deletion without notice.<\/b>\n- *\n- * @see java.lang.Character\n- *\/\n-public class SplitIndexWriter extends AbstractIndexWriter {\n-\n-    private final List<Character> indexElements;\n-\n-    \/**\n-     * Construct the SplitIndexWriter. Uses path to this file and relative path\n-     * from this file.\n-     *\n-     * @param configuration the configuration for this doclet\n-     * @param path       Path to the file which is getting generated.\n-     * @param elements the collection of characters for which to generate index files\n-     *\/\n-    public SplitIndexWriter(HtmlConfiguration configuration,\n-                            DocPath path,\n-                            Collection<Character> elements) {\n-        super(configuration, path);\n-        this.indexElements = new ArrayList<>(elements);\n-    }\n-\n-    \/**\n-     * Generate separate index files, for each Unicode character, listing all\n-     * the members starting with the particular unicode character.\n-     *\n-     * @param configuration the configuration for this doclet\n-     * @throws DocFileIOException if there is a problem generating the index files\n-     *\/\n-    public static void generate(HtmlConfiguration configuration) throws DocFileIOException {\n-        DocPath path = DocPaths.INDEX_FILES;\n-        IndexBuilder mainIndex = configuration.mainIndex;\n-        SortedSet<Character> keys = new TreeSet<>(mainIndex.getFirstCharacters());\n-        ListIterator<Character> li = new ArrayList<>(keys).listIterator();\n-        while (li.hasNext()) {\n-            Character ch = li.next();\n-            DocPath filename = DocPaths.indexN(li.nextIndex());\n-            SplitIndexWriter indexgen = new SplitIndexWriter(configuration,\n-                                                             path.resolve(filename), keys);\n-            indexgen.generateIndexFile(ch);\n-        }\n-    }\n-\n-    \/**\n-     * Generate the contents of each index file, with Header, Footer,\n-     * Member Field, Method and Constructor Description.\n-     *\n-     * @param unicode Unicode character referring to the character for the\n-     * index.\n-     * @throws DocFileIOException if there is a problem generating an index file\n-     *\/\n-    protected void generateIndexFile(Character unicode) throws DocFileIOException {\n-        String title = resources.getText(\"doclet.Window_Split_Index\",\n-                unicode.toString());\n-        HtmlTree body = getBody(getWindowTitle(title));\n-        Content headerContent = new ContentBuilder();\n-        addTop(headerContent);\n-        navBar.setUserHeader(getUserHeaderFooter(true));\n-        headerContent.add(navBar.getContent(Navigation.Position.TOP));\n-        Content main = new ContentBuilder();\n-        main.add(HtmlTree.DIV(HtmlStyle.header,\n-                HtmlTree.HEADING(Headings.PAGE_TITLE_HEADING,\n-                        contents.getContent(\"doclet.Index\"))));\n-        Content mainContent = new ContentBuilder();\n-        addLinksForIndexes(mainContent);\n-        addContents(unicode, mainIndex.getItems(unicode), mainContent);\n-        addLinksForIndexes(mainContent);\n-        main.add(mainContent);\n-        HtmlTree footer = HtmlTree.FOOTER();\n-        navBar.setUserFooter(getUserHeaderFooter(false));\n-        footer.add(navBar.getContent(Navigation.Position.BOTTOM));\n-        addBottom(footer);\n-        body.add(new BodyContents()\n-                .setHeader(headerContent)\n-                .addMainContent(main)\n-                .setFooter(footer));\n-        String description = \"index: \" + unicode;\n-        printHtmlDocument(null, description, body);\n-    }\n-\n-    \/**\n-     * Add links for all the Index Files per unicode character.\n-     *\n-     * @param contentTree the content tree to which the links for indexes will be added\n-     *\/\n-    protected void addLinksForIndexes(Content contentTree) {\n-        for (int i = 0; i < indexElements.size(); i++) {\n-            int j = i + 1;\n-            contentTree.add(links.createLink(DocPaths.indexN(j),\n-                    new StringContent(indexElements.get(i).toString())));\n-            contentTree.add(Entity.NO_BREAK_SPACE);\n-        }\n-        contentTree.add(new HtmlTree(TagName.BR));\n-        contentTree.add(links.createLink(pathToRoot.resolve(DocPaths.ALLCLASSES_INDEX),\n-                                         contents.allClassesLabel));\n-        if (!configuration.packages.isEmpty()) {\n-            contentTree.add(getVerticalSeparator());\n-            contentTree.add(links.createLink(pathToRoot.resolve(DocPaths.ALLPACKAGES_INDEX),\n-                                             contents.allPackagesLabel));\n-        }\n-        boolean anySystemProperties = !mainIndex.getItems(DocTree.Kind.SYSTEM_PROPERTY).isEmpty();\n-        if (anySystemProperties) {\n-            contentTree.add(getVerticalSeparator());\n-            contentTree.add(links.createLink(pathToRoot.resolve(DocPaths.SYSTEM_PROPERTIES),\n-                                             contents.systemPropertiesLabel));\n-        }\n-    }\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/SplitIndexWriter.java","additions":0,"deletions":166,"binary":false,"changes":166,"status":"deleted"},{"patch":"@@ -398,1 +398,1 @@\n-                        return utils.getTypeElementName(e, true)\n+                        return utils.getTypeElementKindName(e, true)\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/TagletWriterImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -487,1 +487,0 @@\n-     * The content of the block tags will be in a sibling element with class {@link #moduleTags}.\n@@ -633,0 +632,5 @@\n+    \/**\n+     * The class of the {@code body} element for a page in either the \"single\" or \"split index\".\n+     *\/\n+    indexPage,\n+\n@@ -673,5 +677,0 @@\n-    \/**\n-     * The class of the {@code body} element for the full single index page.\n-     *\/\n-    singleIndexPage,\n-\n@@ -683,5 +682,0 @@\n-    \/**\n-     * The class of the {@code body} element for a page in a \"split index\".\n-     *\/\n-    splitIndexPage,\n-\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/markup\/HtmlStyle.java","additions":5,"deletions":11,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -77,0 +77,2 @@\n+doclet.Element_in=Element in {0}\n+doclet.Enum_constant_in=Enum constant in {0}\n@@ -80,0 +82,1 @@\n+doclet.Record_component_in=Record component of {0}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/resources\/standard.properties","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -166,0 +166,1 @@\n+doclet.record=record\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/resources\/doclets.properties","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -64,1 +64,1 @@\n-    \/** The name of the fie for deprecated elements. *\/\n+    \/** The name of the file for deprecated elements. *\/\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/DocPaths.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -187,1 +187,1 @@\n-     * Returns a list of index keys.\n+     * Returns a sorted list of the first characters of the labels of index items.\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/IndexBuilder.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1340,1 +1340,1 @@\n-     * Given a TypeElement, return the name of its type (Class, Interface, etc.).\n+     * Returns the name of the kind of a type element (Class, Interface, etc.).\n@@ -1342,4 +1342,4 @@\n-     * @param te the TypeElement to check.\n-     * @param lowerCaseOnly true if you want the name returned in lower case.\n-     *                      If false, the first letter of the name is capitalized.\n-     * @return\n+     * @param te the type element\n+     * @param lowerCaseOnly true if you want the name returned in lower case;\n+     *                      if false, the first letter of the name is capitalized\n+     * @return the name\n@@ -1347,20 +1347,22 @@\n-    public String getTypeElementName(TypeElement te, boolean lowerCaseOnly) {\n-        String typeName = \"\";\n-        if (isInterface(te)) {\n-            typeName = \"doclet.Interface\";\n-        } else if (isException(te)) {\n-            typeName = \"doclet.Exception\";\n-        } else if (isError(te)) {\n-            typeName = \"doclet.Error\";\n-        } else if (isAnnotationType(te)) {\n-            typeName = \"doclet.AnnotationType\";\n-        } else if (isEnum(te)) {\n-            typeName = \"doclet.Enum\";\n-        } else if (isOrdinaryClass(te)) {\n-            typeName = \"doclet.Class\";\n-        }\n-        typeName = lowerCaseOnly ? toLowerCase(typeName) : typeName;\n-        return typeNameMap.computeIfAbsent(typeName, resources::getText);\n-    }\n-\n-    private final Map<String, String> typeNameMap = new HashMap<>();\n+    public String getTypeElementKindName(TypeElement te, boolean lowerCaseOnly) {\n+        String kindName = switch (te.getKind()) {\n+            case ANNOTATION_TYPE ->\n+                    \"doclet.AnnotationType\";\n+            case ENUM ->\n+                    \"doclet.Enum\";\n+            case INTERFACE ->\n+                    \"doclet.Interface\";\n+            case RECORD ->\n+                    \"doclet.Record\";\n+            case CLASS ->\n+                    isException(te) ? \"doclet.Exception\"\n+                    : isError(te) ? \"doclet.Error\"\n+                    : \"doclet.Class\";\n+            default ->\n+                    throw new IllegalArgumentException(te.getKind().toString());\n+        };\n+        kindName = lowerCaseOnly ? toLowerCase(kindName) : kindName;\n+        return kindNameMap.computeIfAbsent(kindName, resources::getText);\n+    }\n+\n+    private final Map<String, String> kindNameMap = new HashMap<>();\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/Utils.java","additions":27,"deletions":25,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8218998 8219946 8219060 8241190 8242056\n+ * @bug 8218998 8219946 8219060 8241190 8242056 8254627\n@@ -153,0 +153,1 @@\n+        \"index-page\",\n@@ -161,1 +162,0 @@\n-        \"single-index-page\",\n@@ -163,1 +163,0 @@\n-        \"split-index-page\",\n@@ -221,0 +220,1 @@\n+            \"IndexWriter\",\n@@ -228,1 +228,0 @@\n-            \"SingleIndexWriter\",\n@@ -230,1 +229,0 @@\n-            \"SplitIndexWriter\",\n@@ -356,0 +354,4 @@\n+            case \"IndexWriter\":\n+                check(generator, content, content.startsWith(\"index\"));\n+                break;\n+\n@@ -365,5 +367,0 @@\n-            case \"SingleIndexWriter\":\n-            case \"SplitIndexWriter\":\n-                check(generator, content, content.startsWith(\"index\"));\n-                break;\n-\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testMetadata\/TestMetadata.java","additions":7,"deletions":10,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n- *      8184205 8214468 8222548 8223378 8234746 8241219\n+ *      8184205 8214468 8222548 8223378 8234746 8241219 8254627\n@@ -490,1 +490,1 @@\n-                    n> - pkg2.<a href=\"pkg2\/TestEnum.html\" title=\"enum in pkg2\">TestEnum<\/a><\/dt>\"\"\",\n+                    n> - Enum constant in enum pkg2.<a href=\"pkg2\/TestEnum.html\" title=\"enum in pkg2\">TestEnum<\/a><\/dt>\"\"\",\n@@ -493,1 +493,1 @@\n-                    \/span> - pkg2.<a href=\"pkg2\/TestEnum.html\" title=\"enum in pkg2\">TestEnum<\/a><\/dt\\\n+                    \/span> - Enum constant in enum pkg2.<a href=\"pkg2\/TestEnum.html\" title=\"enum in pkg2\">TestEnum<\/a><\/dt\\\n@@ -497,1 +497,1 @@\n-                    n> - pkg2.<a href=\"pkg2\/TestEnum.html\" title=\"enum in pkg2\">TestEnum<\/a><\/dt>\"\"\");\n+                    n> - Enum constant in enum pkg2.<a href=\"pkg2\/TestEnum.html\" title=\"enum in pkg2\">TestEnum<\/a><\/dt>\"\"\");\n@@ -578,1 +578,1 @@\n-                    span> - pkg2.<a href=\"..\/pkg2\/TestEnum.html\" title=\"enum in pkg2\">TestEnum<\/a><\/\\\n+                    span> - Enum constant in enum pkg2.<a href=\"..\/pkg2\/TestEnum.html\" title=\"enum in pkg2\">TestEnum<\/a><\/\\\n@@ -583,1 +583,1 @@\n-                    a><\/span> - pkg2.<a href=\"..\/pkg2\/TestEnum.html\" title=\"enum in pkg2\">TestEnum<\/\\\n+                    a><\/span> - Enum constant in enum pkg2.<a href=\"..\/pkg2\/TestEnum.html\" title=\"enum in pkg2\">TestEnum<\/\\\n@@ -587,1 +587,1 @@\n-                    span> - pkg2.<a href=\"..\/pkg2\/TestEnum.html\" title=\"enum in pkg2\">TestEnum<\/a><\/\\\n+                    span> - Enum constant in enum pkg2.<a href=\"..\/pkg2\/TestEnum.html\" title=\"enum in pkg2\">TestEnum<\/a><\/\\\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testSearch\/TestSearch.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8000612\n+ * @bug 8000612 8254627\n@@ -204,1 +204,1 @@\n-            \/\/ com.sun.tools.doclets.internal.toolkit.util.Util.getTypeName\n+            \/\/ jdk.javadoc.internal.doclets.toolkit.util.Utils.getTypeName\n@@ -206,1 +206,1 @@\n-                \"AnnotationType\", \"Class\", \"Enum\", \"Error\", \"Exception\", \"Interface\"\n+                \"AnnotationType\", \"Class\", \"Enum\", \"Error\", \"Exception\", \"Interface\", \"Record\"\n","filename":"test\/langtools\/jdk\/javadoc\/tool\/CheckResourceKeys.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"}]}