{"files":[{"patch":"@@ -32,0 +32,1 @@\n+#include \"cds\/unregisteredClasses.hpp\"\n@@ -123,0 +124,7 @@\n+      ResourceMark rm(THREAD);\n+      char* ex_msg = (char*)\"\";\n+      oop message = java_lang_Throwable::message(PENDING_EXCEPTION);\n+      if (message != NULL) {\n+        ex_msg = java_lang_String::as_utf8_string(message);\n+      }\n+      log_warning(cds)(\"%s: %s\", PENDING_EXCEPTION->klass()->external_name(), ex_msg);\n@@ -461,1 +469,1 @@\n-  InstanceKlass* k = ClassLoaderExt::load_class(class_name, _source, CHECK_NULL);\n+  InstanceKlass* k = UnregisteredClasses::load_class(class_name, _source, CHECK_NULL);\n@@ -469,1 +477,3 @@\n-  bool added = SystemDictionaryShared::add_unregistered_class_for_static_archive(THREAD, k);\n+  assert(k->is_shared_unregistered_class(), \"must be\");\n+\n+  bool added = SystemDictionaryShared::add_unregistered_class(THREAD, k);\n@@ -475,4 +485,0 @@\n-  \/\/ This tells JVM_FindLoadedClass to not find this class.\n-  k->set_shared_classpath_index(UNREGISTERED_INDEX);\n-  k->clear_shared_class_loader_type();\n-\n","filename":"src\/hotspot\/share\/cds\/classListParser.cpp","additions":12,"deletions":6,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -0,0 +1,115 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"cds\/unregisteredClasses.hpp\"\n+#include \"classfile\/classFileStream.hpp\"\n+#include \"classfile\/classLoader.inline.hpp\"\n+#include \"classfile\/classLoaderExt.hpp\"\n+#include \"classfile\/javaClasses.inline.hpp\"\n+#include \"classfile\/symbolTable.hpp\"\n+#include \"classfile\/systemDictionaryShared.hpp\"\n+#include \"classfile\/vmSymbols.hpp\"\n+#include \"memory\/oopFactory.hpp\"\n+#include \"memory\/resourceArea.hpp\"\n+#include \"oops\/instanceKlass.hpp\"\n+#include \"runtime\/handles.hpp\"\n+#include \"runtime\/javaCalls.hpp\"\n+#include \"services\/threadService.hpp\"\n+\n+\/\/ Load the class of the given name from the location given by path. The path is specified by\n+\/\/ the \"source:\" in the class list file (see classListParser.cpp), and can be a directory or\n+\/\/ a JAR file.\n+InstanceKlass* UnregisteredClasses::load_class(Symbol* name, const char* path, TRAPS) {\n+  assert(name != NULL, \"invariant\");\n+  assert(DumpSharedSpaces, \"this function is only used with -Xshare:dump\");\n+\n+  {\n+    PerfClassTraceTime vmtimer(ClassLoader::perf_sys_class_lookup_time(),\n+                               THREAD->get_thread_stat()->perf_timers_addr(),\n+                               PerfClassTraceTime::CLASS_LOAD);\n+  }\n+\n+  Symbol* path_symbol = SymbolTable::new_symbol(path);\n+  Handle url_classloader = get_url_classloader(path_symbol, CHECK_NULL);\n+  Handle ext_class_name = java_lang_String::externalize_classname(name, CHECK_NULL);\n+\n+  JavaValue result(T_OBJECT);\n+  JavaCallArguments args(2);\n+  args.set_receiver(url_classloader);\n+  args.push_oop(ext_class_name);\n+  args.push_int(JNI_FALSE);\n+  JavaCalls::call_virtual(&result,\n+                          vmClasses::URLClassLoader_klass(),\n+                          vmSymbols::loadClass_name(),\n+                          vmSymbols::string_boolean_class_signature(),\n+                          &args,\n+                          CHECK_NULL);\n+  assert(result.get_type() == T_OBJECT, \"just checking\");\n+  oop obj = result.get_oop();\n+  return InstanceKlass::cast(java_lang_Class::as_Klass(obj));\n+}\n+\n+class URLClassLoaderTable : public ResourceHashtable<\n+  Symbol*, Handle,\n+  137, \/\/ prime number\n+  ResourceObj::C_HEAP> {};\n+\n+static URLClassLoaderTable* _url_classloader_table = NULL;\n+\n+Handle UnregisteredClasses::create_url_classloader(Symbol* path, TRAPS) {\n+  ResourceMark rm(THREAD);\n+  JavaValue result(T_OBJECT);\n+  Handle path_string = java_lang_String::create_from_str(path->as_C_string(), CHECK_NH);\n+  JavaCalls::call_static(&result,\n+                         vmClasses::jdk_internal_loader_ClassLoaders_klass(),\n+                         vmSymbols::toFileURL_name(),\n+                         vmSymbols::toFileURL_signature(),\n+                         path_string, CHECK_NH);\n+  assert(result.get_type() == T_OBJECT, \"just checking\");\n+  oop url_h = result.get_oop();\n+  objArrayHandle urls = oopFactory::new_objArray_handle(vmClasses::URL_klass(), 1, CHECK_NH);\n+  urls->obj_at_put(0, url_h);\n+\n+  Handle url_classloader = JavaCalls::construct_new_instance(\n+                             vmClasses::URLClassLoader_klass(),\n+                             vmSymbols::url_array_classloader_void_signature(),\n+                             urls, Handle(), CHECK_NH);\n+  return url_classloader;\n+}\n+\n+Handle UnregisteredClasses::get_url_classloader(Symbol* path, TRAPS) {\n+  if (_url_classloader_table == NULL) {\n+    _url_classloader_table = new (ResourceObj::C_HEAP, mtClass)URLClassLoaderTable();\n+  }\n+  Handle* url_classloader_ptr = _url_classloader_table->get(path);\n+  if (url_classloader_ptr != NULL) {\n+    return *url_classloader_ptr;\n+  } else {\n+    Handle url_classloader = create_url_classloader(path, CHECK_NH);\n+    _url_classloader_table->put(path, url_classloader);\n+    path->increment_refcount();\n+    return url_classloader;\n+  }\n+}\n","filename":"src\/hotspot\/share\/cds\/unregisteredClasses.cpp","additions":115,"deletions":0,"binary":false,"changes":115,"status":"added"},{"patch":"@@ -0,0 +1,39 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_CDS_UNREGISTEREDCLASSES_HPP\n+#define SHARE_CDS_UNREGISTEREDCLASSES_HPP\n+\n+#include \"runtime\/handles.hpp\"\n+\n+class UnregisteredClasses: AllStatic {\n+public:\n+  static InstanceKlass* load_class(Symbol* h_name, const char* path, TRAPS);\n+\n+private:\n+  static Handle create_url_classloader(Symbol* path, TRAPS);\n+  static Handle get_url_classloader(Symbol* path, TRAPS);\n+};\n+\n+#endif \/\/ SHARE_CDS_UNREGISTEREDCLASSES_HPP\n","filename":"src\/hotspot\/share\/cds\/unregisteredClasses.hpp","additions":39,"deletions":0,"binary":false,"changes":39,"status":"added"},{"patch":"@@ -28,1 +28,0 @@\n-#include \"classfile\/classFileStream.hpp\"\n@@ -36,1 +35,0 @@\n-#include \"classfile\/systemDictionaryShared.hpp\"\n@@ -49,1 +47,0 @@\n-#include \"runtime\/javaCalls.hpp\"\n@@ -51,1 +48,0 @@\n-#include \"services\/threadService.hpp\"\n@@ -253,87 +249,0 @@\n-\n-\/\/ Load the class of the given name from the location given by path. The path is specified by\n-\/\/ the \"source:\" in the class list file (see classListParser.cpp), and can be a directory or\n-\/\/ a JAR file.\n-InstanceKlass* ClassLoaderExt::load_class(Symbol* name, const char* path, TRAPS) {\n-  assert(name != NULL, \"invariant\");\n-  assert(DumpSharedSpaces, \"this function is only used with -Xshare:dump\");\n-  ResourceMark rm(THREAD);\n-  const char* class_name = name->as_C_string();\n-  const char* file_name = file_name_for_class_name(class_name,\n-                                                   name->utf8_length());\n-  assert(file_name != NULL, \"invariant\");\n-\n-  \/\/ Lookup stream for parsing .class file\n-  ClassFileStream* stream = NULL;\n-  ClassPathEntry* e = find_classpath_entry_from_cache(THREAD, path);\n-  if (e == NULL) {\n-    THROW_NULL(vmSymbols::java_lang_ClassNotFoundException());\n-  }\n-\n-  {\n-    PerfClassTraceTime vmtimer(perf_sys_class_lookup_time(),\n-                               THREAD->get_thread_stat()->perf_timers_addr(),\n-                               PerfClassTraceTime::CLASS_LOAD);\n-    stream = e->open_stream(THREAD, file_name);\n-  }\n-\n-  if (stream == NULL) {\n-    \/\/ open_stream could return NULL even when no exception has be thrown (JDK-8263632).\n-    THROW_NULL(vmSymbols::java_lang_ClassNotFoundException());\n-    return NULL;\n-  }\n-  stream->set_verify(true);\n-\n-  ClassLoaderData* loader_data = ClassLoaderData::the_null_class_loader_data();\n-  Handle protection_domain;\n-  ClassLoadInfo cl_info(protection_domain);\n-  InstanceKlass* k = KlassFactory::create_from_stream(stream,\n-                                                      name,\n-                                                      loader_data,\n-                                                      cl_info,\n-                                                      CHECK_NULL);\n-  return k;\n-}\n-\n-struct CachedClassPathEntry {\n-  const char* _path;\n-  ClassPathEntry* _entry;\n-};\n-\n-static GrowableArray<CachedClassPathEntry>* cached_path_entries = NULL;\n-\n-ClassPathEntry* ClassLoaderExt::find_classpath_entry_from_cache(JavaThread* current, const char* path) {\n-  \/\/ This is called from dump time so it's single threaded and there's no need for a lock.\n-  assert(DumpSharedSpaces, \"this function is only used with -Xshare:dump\");\n-  if (cached_path_entries == NULL) {\n-    cached_path_entries = new (ResourceObj::C_HEAP, mtClass) GrowableArray<CachedClassPathEntry>(20, mtClass);\n-  }\n-  CachedClassPathEntry ccpe;\n-  for (int i=0; i<cached_path_entries->length(); i++) {\n-    ccpe = cached_path_entries->at(i);\n-    if (strcmp(ccpe._path, path) == 0) {\n-      if (i != 0) {\n-        \/\/ Put recent entries at the beginning to speed up searches.\n-        cached_path_entries->remove_at(i);\n-        cached_path_entries->insert_before(0, ccpe);\n-      }\n-      return ccpe._entry;\n-    }\n-  }\n-\n-  struct stat st;\n-  if (os::stat(path, &st) != 0) {\n-    \/\/ File or directory not found\n-    return NULL;\n-  }\n-  ClassPathEntry* new_entry = NULL;\n-\n-  new_entry = create_class_path_entry(current, path, &st, false, false);\n-  if (new_entry == NULL) {\n-    return NULL;\n-  }\n-  ccpe._path = strdup(path);\n-  ccpe._entry = new_entry;\n-  cached_path_entries->insert_before(0, ccpe);\n-  return new_entry;\n-}\n","filename":"src\/hotspot\/share\/classfile\/classLoaderExt.cpp","additions":0,"deletions":91,"binary":false,"changes":91,"status":"modified"},{"patch":"@@ -62,1 +62,0 @@\n-  static ClassPathEntry* find_classpath_entry_from_cache(JavaThread* current, const char* path);\n@@ -116,1 +115,0 @@\n-  static InstanceKlass* load_class(Symbol* h_name, const char* path, TRAPS);\n","filename":"src\/hotspot\/share\/classfile\/classLoaderExt.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -433,0 +433,1 @@\n+\/\/ true == class was successfully added; false == a duplicated class (with the same name) already exists.\n@@ -451,12 +452,0 @@\n-\/\/ true == class was successfully added; false == a duplicated class (with the same name) already exists.\n-bool SystemDictionaryShared::add_unregistered_class_for_static_archive(Thread* current, InstanceKlass* k) {\n-  assert(DumpSharedSpaces, \"only when dumping\");\n-  if (add_unregistered_class(current, k)) {\n-    MutexLocker mu_r(current, Compile_lock); \/\/ add_to_hierarchy asserts this.\n-    SystemDictionary::add_to_hierarchy(k);\n-    return true;\n-  } else {\n-    return false;\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/classfile\/systemDictionaryShared.cpp","additions":1,"deletions":12,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -211,1 +211,0 @@\n-  static bool add_unregistered_class_for_static_archive(Thread* current, InstanceKlass* k);\n","filename":"src\/hotspot\/share\/classfile\/systemDictionaryShared.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -138,0 +138,1 @@\n+  do_klass(URLClassLoader_klass,                        java_net_URLClassLoader                               ) \\\n","filename":"src\/hotspot\/share\/classfile\/vmClassMacros.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -119,0 +119,1 @@\n+  template(java_net_URLClassLoader,                   \"java\/net\/URLClassLoader\")                  \\\n@@ -554,0 +555,1 @@\n+  template(string_boolean_class_signature,            \"(Ljava\/lang\/String;Z)Ljava\/lang\/Class;\")                   \\\n@@ -712,0 +714,1 @@\n+  template(url_array_classloader_void_signature,            \"([Ljava\/net\/URL;Ljava\/lang\/ClassLoader;)V\")          \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -352,4 +352,0 @@\n-  void clear_shared_class_loader_type() {\n-    _misc_flags &= ~shared_loader_type_bits();\n-  }\n-\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1033,1 +1033,0 @@\n-\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"}]}