{"files":[{"patch":"@@ -32,0 +32,1 @@\n+#include \"cds\/unregisteredClasses.hpp\"\n@@ -468,1 +469,1 @@\n-  InstanceKlass* k = ClassLoaderExt::load_class(class_name, _source, CHECK_NULL);\n+  InstanceKlass* k = UnregisteredClasses::load_class(class_name, _source, CHECK_NULL);\n@@ -476,1 +477,0 @@\n-  \/\/ This tells JVM_FindLoadedClass to not find this class.\n","filename":"src\/hotspot\/share\/cds\/classListParser.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,128 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"cds\/unregisteredClasses.hpp\"\n+#include \"classfile\/classFileStream.hpp\"\n+#include \"classfile\/classLoader.inline.hpp\"\n+#include \"classfile\/classLoaderExt.hpp\"\n+#include \"classfile\/javaClasses.inline.hpp\"\n+#include \"classfile\/symbolTable.hpp\"\n+#include \"classfile\/systemDictionaryShared.hpp\"\n+#include \"classfile\/vmSymbols.hpp\"\n+#include \"memory\/oopFactory.hpp\"\n+#include \"memory\/resourceArea.hpp\"\n+#include \"oops\/instanceKlass.hpp\"\n+#include \"runtime\/handles.hpp\"\n+#include \"runtime\/javaCalls.hpp\"\n+#include \"services\/threadService.hpp\"\n+\n+\/\/ Load the class of the given name from the location given by path. The path is specified by\n+\/\/ the \"source:\" in the class list file (see classListParser.cpp), and can be a directory or\n+\/\/ a JAR file.\n+InstanceKlass* UnregisteredClasses::load_class(Symbol* name, const char* path, TRAPS) {\n+  assert(name != NULL, \"invariant\");\n+  assert(DumpSharedSpaces, \"this function is only used with -Xshare:dump\");\n+\n+  {\n+    PerfClassTraceTime vmtimer(ClassLoader::perf_sys_class_lookup_time(),\n+                               THREAD->get_thread_stat()->perf_timers_addr(),\n+                               PerfClassTraceTime::CLASS_LOAD);\n+  }\n+\n+  Symbol* path_symbol = SymbolTable::new_symbol(path);\n+  Handle url_classloader = get_url_classloader(path_symbol, CHECK_NULL);\n+  Handle ext_class_name = java_lang_String::externalize_classname(name, CHECK_NULL);\n+\n+  JavaValue result(T_OBJECT);\n+  JavaCallArguments args(2);\n+  args.set_receiver(url_classloader);\n+  args.push_oop(ext_class_name);\n+  args.push_int(JNI_FALSE);\n+  JavaCalls::call_virtual(&result,\n+                          vmClasses::URLClassLoader_klass(),\n+                          vmSymbols::loadClass_name(),\n+                          vmSymbols::string_boolean_class_signature(),\n+                          &args,\n+                          CHECK_NULL);\n+  assert(result.get_type() == T_OBJECT, \"just checking\");\n+  oop obj = result.get_oop();\n+  return InstanceKlass::cast(java_lang_Class::as_Klass(obj));\n+}\n+\n+class URLClassLoaderTable : public ResourceHashtable<\n+  Symbol*, Handle,\n+  137, \/\/ prime number\n+  ResourceObj::C_HEAP> {};\n+\n+static URLClassLoaderTable* _url_classloader_table = NULL;\n+\n+\n+bool UnregisteredClasses::seen_classloader(const char* path, Handle loader) {\n+  if (_url_classloader_table == NULL) {\n+    return false;\n+  }\n+  TempNewSymbol path_symbol = SymbolTable::new_symbol(path);\n+  Handle* url_classloader_ptr = _url_classloader_table->get(path_symbol);\n+  if (url_classloader_ptr == NULL) {\n+    return false;\n+  }\n+  return(*url_classloader_ptr == loader);\n+}\n+\n+Handle UnregisteredClasses::create_url_classloader(Symbol* path, TRAPS) {\n+  ResourceMark rm(THREAD);\n+  JavaValue result(T_OBJECT);\n+  Handle path_string = java_lang_String::create_from_str(path->as_C_string(), CHECK_NH);\n+  JavaCalls::call_static(&result,\n+                         vmClasses::jdk_internal_loader_ClassLoaders_klass(),\n+                         vmSymbols::toFileURL_name(),\n+                         vmSymbols::toFileURL_signature(),\n+                         path_string, CHECK_NH);\n+  assert(result.get_type() == T_OBJECT, \"just checking\");\n+  oop url_h = result.get_oop();\n+  objArrayHandle urls = oopFactory::new_objArray_handle(vmClasses::URL_klass(), 1, CHECK_NH);\n+  urls->obj_at_put(0, url_h);\n+\n+  Handle url_classloader = JavaCalls::construct_new_instance(\n+                             vmClasses::URLClassLoader_klass(),\n+                             vmSymbols::url_array_classloader_void_signature(),\n+                             urls, Handle(), CHECK_NH);\n+  return url_classloader;\n+}\n+\n+Handle UnregisteredClasses::get_url_classloader(Symbol* path, TRAPS) {\n+  if (_url_classloader_table == NULL) {\n+    _url_classloader_table = new (ResourceObj::C_HEAP, mtClass)URLClassLoaderTable();\n+  }\n+  Handle* url_classloader_ptr = _url_classloader_table->get(path);\n+  if (url_classloader_ptr != NULL) {\n+    return *url_classloader_ptr;\n+  } else {\n+    Handle url_classloader = create_url_classloader(path, CHECK_NH);\n+    _url_classloader_table->put(path, url_classloader);\n+    path->increment_refcount();\n+    return url_classloader;\n+  }\n+}\n","filename":"src\/hotspot\/share\/cds\/unregisteredClasses.cpp","additions":128,"deletions":0,"binary":false,"changes":128,"status":"added"},{"patch":"@@ -0,0 +1,40 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_CDS_UNREGISTEREDCLASSES_HPP\n+#define SHARE_CDS_UNREGISTEREDCLASSES_HPP\n+\n+#include \"runtime\/handles.hpp\"\n+\n+class UnregisteredClasses: AllStatic {\n+public:\n+  static InstanceKlass* load_class(Symbol* h_name, const char* path, TRAPS);\n+  static bool seen_classloader(const char* path, Handle loader);\n+\n+private:\n+  static Handle create_url_classloader(Symbol* path, TRAPS);\n+  static Handle get_url_classloader(Symbol* path, TRAPS);\n+};\n+\n+#endif \/\/ SHARE_CDS_UNREGISTEREDCLASSES_HPP\n","filename":"src\/hotspot\/share\/cds\/unregisteredClasses.hpp","additions":40,"deletions":0,"binary":false,"changes":40,"status":"added"},{"patch":"@@ -28,1 +28,0 @@\n-#include \"classfile\/classFileStream.hpp\"\n@@ -33,1 +32,0 @@\n-#include \"classfile\/javaClasses.inline.hpp\"\n@@ -36,1 +34,0 @@\n-#include \"classfile\/symbolTable.hpp\"\n@@ -38,1 +35,0 @@\n-#include \"classfile\/systemDictionaryShared.hpp\"\n@@ -44,1 +40,0 @@\n-#include \"memory\/oopFactory.hpp\"\n@@ -52,1 +47,0 @@\n-#include \"runtime\/javaCalls.hpp\"\n@@ -54,1 +48,0 @@\n-#include \"services\/threadService.hpp\"\n@@ -256,159 +249,0 @@\n-\n-\/\/ Load the class of the given name from the location given by path. The path is specified by\n-\/\/ the \"source:\" in the class list file (see classListParser.cpp), and can be a directory or\n-\/\/ a JAR file.\n-InstanceKlass* ClassLoaderExt::load_class(Symbol* name, const char* path, TRAPS) {\n-  assert(name != NULL, \"invariant\");\n-  assert(DumpSharedSpaces, \"this function is only used with -Xshare:dump\");\n-  ResourceMark rm(THREAD);\n-  const char* class_name = name->as_C_string();\n-  const char* file_name = file_name_for_class_name(class_name,\n-                                                   name->utf8_length());\n-  assert(file_name != NULL, \"invariant\");\n-\n-  \/\/ Lookup stream for parsing .class file\n-  ClassFileStream* stream = NULL;\n-  ClassPathEntry* e = find_classpath_entry_from_cache(THREAD, path);\n-  if (e == NULL) {\n-    THROW_NULL(vmSymbols::java_lang_ClassNotFoundException());\n-  }\n-\n-  {\n-    PerfClassTraceTime vmtimer(perf_sys_class_lookup_time(),\n-                               THREAD->get_thread_stat()->perf_timers_addr(),\n-                               PerfClassTraceTime::CLASS_LOAD);\n-    stream = e->open_stream(THREAD, file_name);\n-  }\n-\n-  if (stream == NULL) {\n-    \/\/ open_stream could return NULL even when no exception has be thrown (JDK-8263632).\n-    THROW_NULL(vmSymbols::java_lang_ClassNotFoundException());\n-    return NULL;\n-  }\n-  stream->set_verify(true);\n-\n-  InstanceKlass* k = load_class_impl(name, path, CHECK_NULL);\n-\n-  SystemDictionaryShared::set_shared_class_misc_info(k, (ClassFileStream*)stream);\n-\n-  return k;\n-}\n-\n-class URLClassLoaderTable : public ResourceHashtable<\n-  Symbol*, Handle,\n-  7, \/\/ prime number\n-  ResourceObj::C_HEAP> {};\n-\n-static URLClassLoaderTable* _url_classloader_table = NULL;\n-\n-Handle ClassLoaderExt::create_url_classloader(Symbol* path, TRAPS) {\n-  ResourceMark rm(THREAD);\n-  JavaValue result(T_OBJECT);\n-  Handle path_string = java_lang_String::create_from_str(path->as_C_string(), CHECK_NH);\n-  JavaCalls::call_static(&result,\n-                         vmClasses::jdk_internal_loader_ClassLoaders_klass(),\n-                         vmSymbols::toFileURL_name(),\n-                         vmSymbols::toFileURL_signature(),\n-                         path_string, CHECK_NH);\n-  assert(result.get_type() == T_OBJECT, \"just checking\");\n-  oop url_h = result.get_oop();\n-  objArrayHandle urls = oopFactory::new_objArray_handle(vmClasses::URL_klass(), 1, CHECK_NH);\n-  urls->obj_at_put(0, url_h);\n-\n-  Handle url_classloader = JavaCalls::construct_new_instance(\n-                             vmClasses::URLClassLoader_klass(),\n-                             vmSymbols::url_array_classloader_void_signature(),\n-                             urls, Handle(), CHECK_NH);\n-  return url_classloader;\n-}\n-\n-Handle ClassLoaderExt::create_and_add_url_classloader(Symbol* path, TRAPS) {\n-  Handle url_classloader = create_url_classloader(path, CHECK_NH);\n-  bool added = _url_classloader_table->put(path, url_classloader);\n-  path->increment_refcount();\n-  return url_classloader;\n-}\n-\n-Handle ClassLoaderExt::get_url_classloader(Symbol* path, TRAPS) {\n-  if (_url_classloader_table == NULL) {\n-    _url_classloader_table = new (ResourceObj::C_HEAP, mtClass)URLClassLoaderTable();\n-    Handle url_classloader = create_and_add_url_classloader(path, CHECK_NH);\n-    return url_classloader;\n-  }\n-  Handle* url_classloader_ptr = _url_classloader_table->get(path);\n-  if (url_classloader_ptr != NULL) {\n-    return *url_classloader_ptr;\n-  } else {\n-    Handle url_classloader = create_and_add_url_classloader(path, CHECK_NH);\n-    return url_classloader;\n-  }\n-}\n-\n-InstanceKlass* ClassLoaderExt::load_class_impl(Symbol* name, const char* path, TRAPS) {\n-  assert(name != NULL, \"invariant\");\n-  assert(DumpSharedSpaces, \"this function is only used with -Xshare:dump\");\n-\n-  Symbol* path_symbol = SymbolTable::new_symbol(path);\n-  Handle url_classloader = get_url_classloader(path_symbol, CHECK_NULL);\n-  Handle ext_class_name = java_lang_String::externalize_classname(name, CHECK_NULL);\n-\n-  JavaValue result(T_OBJECT);\n-  JavaCallArguments args(2);\n-  args.set_receiver(url_classloader);\n-  args.push_oop(ext_class_name);\n-  args.push_int(JNI_FALSE);\n-  JavaCalls::call_virtual(&result,\n-                          vmClasses::URLClassLoader_klass(),\n-                          vmSymbols::loadClass_name(),\n-                          vmSymbols::string_boolean_class_signature(),\n-                          &args,\n-                          CHECK_NULL);\n-  assert(result.get_type() == T_OBJECT, \"just checking\");\n-  oop obj = result.get_oop();\n-  InstanceKlass* k = InstanceKlass::cast(java_lang_Class::as_Klass(obj));\n-\n-  return k;\n-}\n-\n-struct CachedClassPathEntry {\n-  const char* _path;\n-  ClassPathEntry* _entry;\n-};\n-\n-static GrowableArray<CachedClassPathEntry>* cached_path_entries = NULL;\n-\n-ClassPathEntry* ClassLoaderExt::find_classpath_entry_from_cache(JavaThread* current, const char* path) {\n-  \/\/ This is called from dump time so it's single threaded and there's no need for a lock.\n-  assert(DumpSharedSpaces, \"this function is only used with -Xshare:dump\");\n-  if (cached_path_entries == NULL) {\n-    cached_path_entries = new (ResourceObj::C_HEAP, mtClass) GrowableArray<CachedClassPathEntry>(20, mtClass);\n-  }\n-  CachedClassPathEntry ccpe;\n-  for (int i=0; i<cached_path_entries->length(); i++) {\n-    ccpe = cached_path_entries->at(i);\n-    if (strcmp(ccpe._path, path) == 0) {\n-      if (i != 0) {\n-        \/\/ Put recent entries at the beginning to speed up searches.\n-        cached_path_entries->remove_at(i);\n-        cached_path_entries->insert_before(0, ccpe);\n-      }\n-      return ccpe._entry;\n-    }\n-  }\n-\n-  struct stat st;\n-  if (os::stat(path, &st) != 0) {\n-    \/\/ File or directory not found\n-    return NULL;\n-  }\n-  ClassPathEntry* new_entry = NULL;\n-\n-  new_entry = create_class_path_entry(current, path, &st, false, false);\n-  if (new_entry == NULL) {\n-    return NULL;\n-  }\n-  ccpe._path = strdup(path);\n-  ccpe._entry = new_entry;\n-  cached_path_entries->insert_before(0, ccpe);\n-  return new_entry;\n-}\n","filename":"src\/hotspot\/share\/classfile\/classLoaderExt.cpp","additions":0,"deletions":166,"binary":false,"changes":166,"status":"modified"},{"patch":"@@ -62,1 +62,0 @@\n-  static ClassPathEntry* find_classpath_entry_from_cache(JavaThread* current, const char* path);\n@@ -116,5 +115,0 @@\n-  static InstanceKlass* load_class(Symbol* h_name, const char* path, TRAPS);\n-  static InstanceKlass* load_class_impl(Symbol* h_name, const char* path, TRAPS);\n-  static Handle create_url_classloader(Symbol* path, TRAPS);\n-  static Handle create_and_add_url_classloader(Symbol* path, TRAPS);\n-  static Handle get_url_classloader(Symbol* path, TRAPS);\n","filename":"src\/hotspot\/share\/classfile\/classLoaderExt.hpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -3915,2 +3915,2 @@\n-  bool good_state = (is_shared() || shared_classpath_index() == UNREGISTERED_INDEX) ?\n-                      (_init_state <= state) : (_init_state < state);\n+  bool good_state = is_shared() ? (_init_state <= state)\n+                                               : (_init_state < state);\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"cds\/unregisteredClasses.hpp\"\n@@ -845,1 +846,1 @@\n-  if (source == NULL)  source = \"__JVM_DefineClass__\";\n+  const char* final_source = (source != NULL) ? source : \"__JVM_DefineClass__\";\n@@ -866,1 +867,1 @@\n-  ClassFileStream st((u1*)buf, len, source, ClassFileStream::verify);\n+  ClassFileStream st((u1*)buf, len, final_source, ClassFileStream::verify);\n@@ -879,0 +880,12 @@\n+#if INCLUDE_CDS\n+  if (DumpSharedSpaces) {\n+    \/\/ Calculate size and crc of the ClassFileStream if the loader is one of the\n+    \/\/ URL class loaders used for unregistered classes.\n+    if (source != NULL &&\n+        UnregisteredClasses::seen_classloader(source, class_loader)) {\n+      st.set_verify(true);\n+      SystemDictionaryShared::set_shared_class_misc_info(InstanceKlass::cast(k), &st);\n+    }\n+  }\n+#endif \/\/ INCLUDE_CDS\n+\n@@ -1033,1 +1046,0 @@\n-\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":15,"deletions":3,"binary":false,"changes":18,"status":"modified"}]}