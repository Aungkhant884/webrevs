{"files":[{"patch":"@@ -60,0 +60,1 @@\n+JVM_ExpandStackFrameInfo\n","filename":"make\/data\/hotspot-symbols\/symbols-unix","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2959,0 +2959,57 @@\n+\/\/ java_lang_ClassFrameInfo\n+\n+int java_lang_ClassFrameInfo::_classOrMemberName_offset;\n+int java_lang_ClassFrameInfo::_flags_offset;\n+\n+#define CLASSFRAMEINFO_FIELDS_DO(macro) \\\n+  macro(_classOrMemberName_offset, k, \"classOrMemberName\", object_signature,  false); \\\n+  macro(_flags_offset,             k, vmSymbols::flags_name(), int_signature, false)\n+\n+void java_lang_ClassFrameInfo::compute_offsets() {\n+  InstanceKlass* k = vmClasses::ClassFrameInfo_klass();\n+  CLASSFRAMEINFO_FIELDS_DO(FIELD_COMPUTE_OFFSET);\n+}\n+\n+#if INCLUDE_CDS\n+void java_lang_ClassFrameInfo::serialize_offsets(SerializeClosure* f) {\n+  CLASSFRAMEINFO_FIELDS_DO(FIELD_SERIALIZE_OFFSET);\n+}\n+#endif\n+\n+static int get_flags(const methodHandle& m) {\n+  int flags = (jushort)( m->access_flags().as_short() & JVM_RECOGNIZED_METHOD_MODIFIERS );\n+  if (m->is_static()) {\n+    flags |= java_lang_invoke_MemberName::MN_IS_METHOD;\n+  } else if (m->is_initializer()) {\n+    flags |= java_lang_invoke_MemberName::MN_IS_CONSTRUCTOR;\n+  } else {\n+    \/\/ \"special\" reflects that this is a direct call, not that it\n+    \/\/ necessarily originates from an invokespecial. We can also do\n+    \/\/ direct calls for private and\/or final non-static methods.\n+    flags |= java_lang_invoke_MemberName::MN_IS_METHOD;\n+  }\n+  if (m->caller_sensitive()) {\n+    flags |= java_lang_invoke_MemberName::MN_CALLER_SENSITIVE;\n+  }\n+  if (m->is_hidden()) {\n+    flags |= java_lang_invoke_MemberName::MN_HIDDEN_MEMBER;\n+  }\n+  return flags;\n+}\n+\n+oop java_lang_ClassFrameInfo::classOrMemberName(oop obj) {\n+  return obj->obj_field(_classOrMemberName_offset);\n+}\n+\n+void java_lang_ClassFrameInfo::init_class(Handle stackFrame, const methodHandle& m) {\n+  stackFrame->obj_field_put(_classOrMemberName_offset, m->method_holder()->java_mirror());\n+  stackFrame->int_field_put(_flags_offset, get_flags(m));\n+}\n+\n+void java_lang_ClassFrameInfo::init_method(Handle stackFrame, const methodHandle& m, TRAPS) {\n+  oop rmethod_name = java_lang_invoke_ResolvedMethodName::find_resolved_method(m, CHECK);\n+  stackFrame->obj_field_put(_classOrMemberName_offset, rmethod_name);\n+  stackFrame->int_field_put(_flags_offset, get_flags(m));\n+}\n+\n+\n@@ -2961,1 +3018,2 @@\n-int java_lang_StackFrameInfo::_memberName_offset;\n+int java_lang_StackFrameInfo::_type_offset;\n+int java_lang_StackFrameInfo::_name_offset;\n@@ -2967,1 +3025,2 @@\n-  macro(_memberName_offset, k, \"memberName\", object_signature,            false); \\\n+  macro(_type_offset,       k, \"type\",       object_signature,            false); \\\n+  macro(_name_offset,       k, \"name\",       string_signature,            false); \\\n@@ -2984,6 +3043,3 @@\n-Method* java_lang_StackFrameInfo::get_method(Handle stackFrame, InstanceKlass* holder, TRAPS) {\n-  HandleMark hm(THREAD);\n-  Handle mname(THREAD, stackFrame->obj_field(_memberName_offset));\n-  Method* method = (Method*)java_lang_invoke_MemberName::vmtarget(mname());\n-  \/\/ we should expand MemberName::name when Throwable uses StackTrace\n-  \/\/ MethodHandles::expand_MemberName(mname, MethodHandles::_suppress_defc|MethodHandles::_suppress_type, CHECK_NULL);\n+Method* java_lang_StackFrameInfo::get_method(oop obj) {\n+  oop m = java_lang_ClassFrameInfo::classOrMemberName(obj);\n+  Method* method = java_lang_invoke_ResolvedMethodName::vmtarget(m);\n@@ -2996,5 +3052,3 @@\n-  Handle mname(THREAD, stackFrame->obj_field(_memberName_offset));\n-  Handle cont_h (THREAD, cont);\n-  InstanceKlass* ik = method->method_holder();\n-  CallInfo info(method(), ik, CHECK);\n-  MethodHandles::init_method_MemberName(mname, info);\n+  Handle cont_h(THREAD, cont);\n+  java_lang_ClassFrameInfo::init_method(stackFrame, method, CHECK);\n+\n@@ -3015,4 +3069,0 @@\n-  Handle mname(THREAD, stackFrame->obj_field(java_lang_StackFrameInfo::_memberName_offset));\n-  Klass* clazz = java_lang_Class::as_Klass(java_lang_invoke_MemberName::clazz(mname()));\n-  InstanceKlass* holder = InstanceKlass::cast(clazz);\n-  Method* method = java_lang_StackFrameInfo::get_method(stackFrame, holder, CHECK);\n@@ -3020,0 +3070,2 @@\n+  Method* method = java_lang_StackFrameInfo::get_method(stackFrame());\n+  InstanceKlass* holder = method->method_holder();\n@@ -3026,2 +3078,2 @@\n-void java_lang_StackFrameInfo::set_version(oop element, short value) {\n-  element->short_field_put(_version_offset, value);\n+oop java_lang_StackFrameInfo::type(oop obj) {\n+  return obj->obj_field(_type_offset);\n@@ -3030,1 +3082,17 @@\n-void java_lang_StackFrameInfo::set_bci(oop element, int value) {\n+void java_lang_StackFrameInfo::set_type(oop obj, oop value) {\n+  obj->obj_field_put(_type_offset, value);\n+}\n+\n+oop java_lang_StackFrameInfo::name(oop obj) {\n+  return obj->obj_field(_name_offset);\n+}\n+\n+void java_lang_StackFrameInfo::set_name(oop obj, oop value) {\n+  obj->obj_field_put(_name_offset, value);\n+}\n+\n+void java_lang_StackFrameInfo::set_version(oop obj, short value) {\n+  obj->short_field_put(_version_offset, value);\n+}\n+\n+void java_lang_StackFrameInfo::set_bci(oop obj, int value) {\n@@ -3032,1 +3100,1 @@\n-  element->int_field_put(_bci_offset, value);\n+  obj->int_field_put(_bci_offset, value);\n@@ -3035,2 +3103,2 @@\n-void java_lang_StackFrameInfo::set_contScope(oop element, oop value) {\n-  element->obj_field_put(_contScope_offset, value);\n+void java_lang_StackFrameInfo::set_contScope(oop obj, oop value) {\n+  obj->obj_field_put(_contScope_offset, value);\n@@ -3061,2 +3129,2 @@\n-void java_lang_LiveStackFrameInfo::set_monitors(oop element, oop value) {\n-  element->obj_field_put(_monitors_offset, value);\n+void java_lang_LiveStackFrameInfo::set_monitors(oop obj, oop value) {\n+  obj->obj_field_put(_monitors_offset, value);\n@@ -3065,2 +3133,2 @@\n-void java_lang_LiveStackFrameInfo::set_locals(oop element, oop value) {\n-  element->obj_field_put(_locals_offset, value);\n+void java_lang_LiveStackFrameInfo::set_locals(oop obj, oop value) {\n+  obj->obj_field_put(_locals_offset, value);\n@@ -3069,2 +3137,2 @@\n-void java_lang_LiveStackFrameInfo::set_operands(oop element, oop value) {\n-  element->obj_field_put(_operands_offset, value);\n+void java_lang_LiveStackFrameInfo::set_operands(oop obj, oop value) {\n+  obj->obj_field_put(_operands_offset, value);\n@@ -3073,2 +3141,2 @@\n-void java_lang_LiveStackFrameInfo::set_mode(oop element, int value) {\n-  element->int_field_put(_mode_offset, value);\n+void java_lang_LiveStackFrameInfo::set_mode(oop obj, int value) {\n+  obj->int_field_put(_mode_offset, value);\n@@ -3950,0 +4018,3 @@\n+#define RESOLVEDMETHOD_FIELDS_DO(macro) \\\n+  macro(_vmholder_offset, k, \"vmholder\", class_signature, false)\n+\n@@ -3953,0 +4024,1 @@\n+  RESOLVEDMETHOD_FIELDS_DO(FIELD_COMPUTE_OFFSET);\n@@ -3958,0 +4030,1 @@\n+  RESOLVEDMETHOD_FIELDS_DO(FIELD_SERIALIZE_OFFSET);\n@@ -5220,0 +5293,1 @@\n+  f(java_lang_ClassFrameInfo) \\\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":105,"deletions":31,"binary":false,"changes":136,"status":"modified"},{"patch":"@@ -1202,1 +1202,0 @@\n-  macro(java_lang_invoke_ResolvedMethodName, vmholder, object_signature, false) \\\n@@ -1291,0 +1290,1 @@\n+    MN_HIDDEN_MEMBER         = 0x00400000, \/\/ @Hidden annotation detected\n@@ -1594,0 +1594,19 @@\n+class java_lang_ClassFrameInfo: AllStatic {\n+private:\n+  static int _classOrMemberName_offset;\n+  static int _flags_offset;\n+\n+public:\n+  static oop  classOrMemberName(oop info);\n+\n+  \/\/ Setters\n+  static void init_class(Handle stackFrame, const methodHandle& m);\n+  static void init_method(Handle stackFrame, const methodHandle& m, TRAPS);\n+\n+  static void compute_offsets();\n+  static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;\n+\n+  \/\/ Debugging\n+  friend class JavaClasses;\n+};\n+\n@@ -1601,1 +1620,2 @@\n-  static int _memberName_offset;\n+  static int _type_offset;\n+  static int _name_offset;\n@@ -1606,2 +1626,0 @@\n-  static Method* get_method(Handle stackFrame, InstanceKlass* holder, TRAPS);\n-\n@@ -1609,0 +1627,5 @@\n+  \/\/ Getters\n+  static oop name(oop info);\n+  static oop type(oop info);\n+  static Method* get_method(oop info);\n+\n@@ -1611,0 +1634,2 @@\n+  static void set_name(oop info, oop value);\n+  static void set_type(oop info, oop value);\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":29,"deletions":4,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -163,0 +163,1 @@\n+  do_klass(ClassFrameInfo_klass,                        java_lang_ClassFrameInfo                              ) \\\n","filename":"src\/hotspot\/share\/classfile\/vmClassMacros.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -381,0 +381,1 @@\n+  template(java_lang_ClassFrameInfo,                  \"java\/lang\/ClassFrameInfo\")                 \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -248,1 +248,0 @@\n-  JVM_STACKWALK_GET_CALLER_CLASS           = 0x04,\n@@ -253,0 +252,3 @@\n+JNIEXPORT void JNICALL\n+JVM_ExpandStackFrameInfo(JNIEnv *env, jobject obj);\n+\n","filename":"src\/hotspot\/share\/include\/jvm.h","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -544,1 +544,1 @@\n-  java_lang_StackFrameInfo::to_stack_trace_element(stack_frame_info, stack_trace_element, THREAD);\n+  java_lang_StackFrameInfo::to_stack_trace_element(stack_frame_info, stack_trace_element, CHECK);\n@@ -549,1 +549,15 @@\n-\n+JVM_ENTRY(void, JVM_ExpandStackFrameInfo(JNIEnv *env, jobject obj))\n+  Handle stack_frame_info(THREAD, JNIHandles::resolve_non_null(obj));\n+\n+  bool have_name = (java_lang_StackFrameInfo::name(stack_frame_info()) != nullptr);\n+  bool have_type = (java_lang_StackFrameInfo::type(stack_frame_info()) != nullptr);\n+  Method* method = java_lang_StackFrameInfo::get_method(stack_frame_info());\n+  if (!have_name) {\n+    oop name = StringTable::intern(method->name(), CHECK);\n+    java_lang_StackFrameInfo::set_name(stack_frame_info(), name);\n+  }\n+  if (!have_type) {\n+    Handle type = java_lang_String::create_from_symbol(method->signature(), CHECK);\n+    java_lang_StackFrameInfo::set_type(stack_frame_info(), type());\n+  }\n+JVM_END\n@@ -561,1 +575,1 @@\n-  \/\/ frames array is a Class<?>[] array when only getting caller reference,\n+  \/\/ frames array is a ClassFrameInfo[] array when only getting caller reference,\n@@ -581,1 +595,1 @@\n-  \/\/ frames array is a Class<?>[] array when only getting caller reference,\n+  \/\/ frames array is a ClassFrameInfo[] array when only getting caller reference,\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":18,"deletions":4,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -140,0 +140,1 @@\n+  HIDDEN_MEMBER        = java_lang_invoke_MemberName::MN_HIDDEN_MEMBER,\n@@ -1006,0 +1007,1 @@\n+    template(java_lang_invoke_MemberName,MN_HIDDEN_MEMBER) \\\n","filename":"src\/hotspot\/share\/prims\/methodHandles.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -157,2 +157,2 @@\n-\/\/   frames_array     Buffer to store Class or StackFrame in, starting at start_index.\n-\/\/                    frames array is a Class<?>[] array when only getting caller\n+\/\/   frames_array     Buffer to store stack frame information in, starting at start_index.\n+\/\/                    frames array is a ClassFrameInfo[] array when only getting caller\n@@ -189,1 +189,2 @@\n-    if (!ShowHiddenFrames && (skip_hidden_frames(mode) || get_caller_class(mode))) {\n+    LogTarget(Debug, stackwalk) lt;\n+    if (!ShowHiddenFrames && skip_hidden_frames(mode)) {\n@@ -191,1 +192,0 @@\n-        LogTarget(Debug, stackwalk) lt;\n@@ -195,1 +195,1 @@\n-          ls.print(\"  hidden method: \");\n+          ls.print(\"  skip hidden method: \");\n@@ -199,0 +199,1 @@\n+\n@@ -206,1 +207,0 @@\n-    LogTarget(Debug, stackwalk) lt;\n@@ -215,7 +215,0 @@\n-    if (!need_method_info(mode) && get_caller_class(mode) &&\n-          index == start_index && method->caller_sensitive()) {\n-      ResourceMark rm(THREAD);\n-      THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(),\n-        err_msg(\"StackWalker::getCallerClass called from @CallerSensitive '%s' method\",\n-                method->external_name()));\n-    }\n@@ -259,1 +252,3 @@\n-    frames_array->obj_at_put(index, method->method_holder()->java_mirror());\n+    HandleMark hm(THREAD);\n+    Handle stackFrame(THREAD, frames_array->obj_at(index));\n+    java_lang_ClassFrameInfo::init_class(stackFrame, method);\n@@ -359,1 +354,1 @@\n-\/\/ Fill StackFrameInfo with bci and initialize memberName\n+\/\/ Fill StackFrameInfo with bci and initialize ResolvedMethodName\n@@ -408,2 +403,2 @@\n-\/\/   frames_array   Buffer to store StackFrame in, starting at start_index.\n-\/\/                  frames array is a Class<?>[] array when only getting caller\n+\/\/   frames_array   Buffer to store stack frame info in, starting at start_index.\n+\/\/                  frames array is a ClassFrameInfo[] array when only getting caller\n","filename":"src\/hotspot\/share\/prims\/stackwalk.cpp","additions":12,"deletions":17,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -150,3 +150,0 @@\n-  static inline bool get_caller_class(jlong mode) {\n-    return (mode & JVM_STACKWALK_GET_CALLER_CLASS) != 0;\n-  }\n","filename":"src\/hotspot\/share\/prims\/stackwalk.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,98 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package java.lang;\n+\n+import jdk.internal.access.SharedSecrets;\n+\n+import java.lang.StackWalker.StackFrame;\n+\n+class ClassFrameInfo implements StackFrame {\n+    protected Object classOrMemberName;    \/\/ Class or ResolvedMemberName initialized by VM\n+    protected int flags;\n+\n+    \/\/ package-private called by StackStreamFactory to skip\n+    \/\/ the capability check\n+    Class<?> declaringClass() {\n+        return (Class<?>) classOrMemberName;\n+    }\n+\n+    boolean isCallerSensitive() {\n+        return SharedSecrets.getJavaLangInvokeAccess().isCallerSensitive(flags);\n+    }\n+    boolean isHidden() {\n+        return SharedSecrets.getJavaLangInvokeAccess().isHiddenMember(flags);\n+    }\n+\n+    \/\/ ----- implementation of StackFrame methods\n+\n+    @Override\n+    public String getClassName() {\n+        return declaringClass().getName();\n+    }\n+\n+    @Override\n+    public String getMethodName() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public Class<?> getDeclaringClass() {\n+        return declaringClass();\n+    }\n+\n+    @Override\n+    public int getByteCodeIndex() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public String getFileName() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public int getLineNumber() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public boolean isNativeMethod() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public StackTraceElement toStackTraceElement() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public String toString() {\n+        String tags = isHidden() ? \" hidden\" : \"\";\n+        if (isCallerSensitive()) {\n+            tags += \" caller sensitive\";\n+        }\n+        return declaringClass().getName() + tags;\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ClassFrameInfo.java","additions":98,"deletions":0,"binary":false,"changes":98,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,0 @@\n-import java.lang.StackWalker.StackFrame;\n@@ -33,0 +32,1 @@\n+import java.lang.reflect.Modifier;\n@@ -34,1 +34,1 @@\n-class StackFrameInfo implements StackFrame {\n+class StackFrameInfo extends ClassFrameInfo {\n@@ -39,2 +39,3 @@\n-    private Object memberName;    \/\/ MemberName initialized by VM\n-    private int bci;              \/\/ initialized by VM to >= 0\n+    private String name;\n+    private Object type;          \/\/ String or MethodType\n+    private int bci;              \/\/ set by VM to >= 0\n@@ -53,1 +54,0 @@\n-        this.memberName = JLIA.newMemberName();\n@@ -59,1 +59,1 @@\n-        return JLIA.getDeclaringClass(memberName);\n+        return JLIA.getDeclaringClass(classOrMemberName);\n@@ -77,1 +77,5 @@\n-        return JLIA.getName(memberName);\n+        if (name == null) {\n+            expandStackFrameInfo();\n+            assert name != null;\n+        }\n+        return name;\n@@ -83,1 +87,22 @@\n-        return JLIA.getMethodType(memberName);\n+\n+        if (type == null) {\n+            expandStackFrameInfo();\n+            assert type != null;\n+        }\n+\n+        {\n+            \/\/ Get a snapshot of type which doesn't get changed by racing threads.\n+            final Object type = this.type;\n+            if (type instanceof MethodType mt) {\n+                return mt;\n+            }\n+        }\n+\n+        \/\/ type is not a MethodType yet.  Convert it thread-safely.\n+        synchronized (this) {\n+            if (type instanceof String sig) {\n+                type = JLIA.getMethodType(sig, declaringClass().getClassLoader());\n+            }\n+            assert type instanceof MethodType : \"bad method type \" + type;\n+        }\n+        return (MethodType)type;\n@@ -86,0 +111,3 @@\n+    \/\/ expand the name and type field of StackFrameInfo\n+    private native void expandStackFrameInfo();\n+\n@@ -88,1 +116,1 @@\n-        return JLIA.getMethodDescriptor(memberName);\n+        return getMethodType().descriptorString();\n@@ -117,1 +145,1 @@\n-        return JLIA.isNative(memberName);\n+        return Modifier.isNative(flags);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StackFrameInfo.java","additions":39,"deletions":11,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,1 @@\n+import java.util.Arrays;\n@@ -78,1 +79,0 @@\n-    @Native private static final int GET_CALLER_CLASS          = 0x4;\n@@ -92,1 +92,1 @@\n-        if (walker.hasLocalsOperandsOption())\n+        if (walker.hasLocalsOperandsOption()) {\n@@ -94,1 +94,1 @@\n-        else\n+        } else {\n@@ -96,0 +96,1 @@\n+        }\n@@ -111,0 +112,11 @@\n+    private static int toStackWalkMode(StackWalker walker, int mode) {\n+        int newMode = mode;\n+        if (walker.hasOption(Option.SHOW_HIDDEN_FRAMES))\n+            newMode |= SHOW_HIDDEN_FRAMES;\n+        if (walker.hasOption(Option.NO_METHOD_INFO))\n+            newMode |= FILL_CLASS_REFS_ONLY;\n+        if (walker.hasLocalsOperandsOption())\n+            newMode |= FILL_LIVE_STACK_FRAMES;\n+        return newMode;\n+    }\n+\n@@ -127,1 +139,1 @@\n-        protected final long mode;\n+        protected final int mode;\n@@ -140,1 +152,1 @@\n-            this.mode = toStackWalkMode(walker, mode);\n+            this.mode = mode;\n@@ -154,10 +166,0 @@\n-        private int toStackWalkMode(StackWalker walker, int mode) {\n-            int newMode = mode;\n-            if (walker.hasOption(Option.SHOW_HIDDEN_FRAMES) &&\n-                    (mode & FILL_CLASS_REFS_ONLY) != FILL_CLASS_REFS_ONLY)\n-                newMode |= SHOW_HIDDEN_FRAMES;\n-            if (walker.hasLocalsOperandsOption())\n-                newMode |= FILL_LIVE_STACK_FRAMES;\n-            return newMode;\n-        }\n-\n@@ -486,1 +488,1 @@\n-    static class StackFrameTraverser<T> extends AbstractStackWalker<T, StackFrameInfo>\n+    static class StackFrameTraverser<T> extends AbstractStackWalker<T, StackFrame>\n@@ -494,60 +496,0 @@\n-        final class StackFrameBuffer extends FrameBuffer<StackFrameInfo> {\n-            private StackFrameInfo[] stackFrames;\n-            StackFrameBuffer(int initialBatchSize) {\n-                super(initialBatchSize);\n-\n-                this.stackFrames = new StackFrameInfo[initialBatchSize];\n-                for (int i = START_POS; i < initialBatchSize; i++) {\n-                    stackFrames[i] = new StackFrameInfo(walker);\n-                }\n-            }\n-\n-            @Override\n-            StackFrameInfo[] frames() {\n-                return stackFrames;\n-            }\n-\n-            @Override\n-            void resize(int startIndex, int elements) {\n-                if (!isActive())\n-                    throw new IllegalStateException(\"inactive frame buffer can't be resized\");\n-\n-                assert startIndex == START_POS :\n-                       \"bad start index \" + startIndex + \" expected \" + START_POS;\n-\n-                int size = startIndex+elements;\n-                if (stackFrames.length < size) {\n-                    StackFrameInfo[] newFrames = new StackFrameInfo[size];\n-                    \/\/ copy initial magic...\n-                    System.arraycopy(stackFrames, 0, newFrames, 0, startIndex);\n-                    stackFrames = newFrames;\n-                }\n-                for (int i = startIndex; i < size; i++) {\n-                    stackFrames[i] = new StackFrameInfo(walker);\n-                }\n-                currentBatchSize = size;\n-            }\n-\n-            @Override\n-            StackFrameInfo nextStackFrame() {\n-                if (isEmpty()) {\n-                    throw new NoSuchElementException(\"origin=\" + origin + \" fence=\" + fence);\n-                }\n-\n-                StackFrameInfo frame = stackFrames[origin];\n-                origin++;\n-                return frame;\n-            }\n-\n-            @Override\n-            final Class<?> at(int index) {\n-                return stackFrames[index].declaringClass();\n-            }\n-\n-            @Override\n-            final boolean filter(int index) {\n-                return stackFrames[index].declaringClass() == Continuation.class\n-                        && \"yield0\".equals(stackFrames[index].getMethodName());\n-            }\n-        }\n-\n@@ -558,6 +500,1 @@\n-            this(walker, function, DEFAULT_MODE);\n-        }\n-        StackFrameTraverser(StackWalker walker,\n-                            Function<? super Stream<StackFrame>, ? extends T> function,\n-                            int mode) {\n-            super(walker, mode);\n+            super(walker, toStackWalkMode(walker, DEFAULT_MODE));\n@@ -576,1 +513,1 @@\n-            StackFrameInfo frame = frameBuffer.nextStackFrame();\n+            StackFrame frame = frameBuffer.nextStackFrame();\n@@ -593,1 +530,3 @@\n-            this.frameBuffer = new StackFrameBuffer(getNextBatchSize());\n+            this.frameBuffer = walker.hasOption(Option.NO_METHOD_INFO)\n+                                    ? new ClassBuffer(getNextBatchSize())\n+                                    : new StackFrameBuffer(walker, getNextBatchSize());\n@@ -660,7 +599,10 @@\n-    \/*\n-     * CallerClassFinder is specialized to return Class<?> for each stack frame.\n-     * StackFrame is not requested.\n-     *\/\n-    static final class CallerClassFinder extends AbstractStackWalker<Integer, Class<?>> {\n-        static {\n-            stackWalkImplClasses.add(CallerClassFinder.class);\n+    static class StackFrameBuffer extends FrameBuffer<StackFrameInfo> {\n+        private final StackWalker walker;\n+        private StackFrameInfo[] stackFrames;\n+        StackFrameBuffer(StackWalker walker, int initialBatchSize) {\n+            super(initialBatchSize);\n+            this.walker = walker;\n+            this.stackFrames = new StackFrameInfo[initialBatchSize];\n+            for (int i = START_POS; i < initialBatchSize; i++) {\n+                stackFrames[i] = new StackFrameInfo(walker);\n+            }\n@@ -669,1 +611,4 @@\n-        private Class<?> caller;\n+        @Override\n+        StackFrameInfo[] frames() {\n+            return stackFrames;\n+        }\n@@ -671,2 +616,19 @@\n-        CallerClassFinder(StackWalker walker) {\n-            super(walker, FILL_CLASS_REFS_ONLY|GET_CALLER_CLASS);\n+        @Override\n+        void resize(int startIndex, int elements) {\n+            if (!isActive())\n+                throw new IllegalStateException(\"inactive frame buffer can't be resized\");\n+\n+            assert startIndex == START_POS :\n+                    \"bad start index \" + startIndex + \" expected \" + START_POS;\n+\n+            int size = startIndex+elements;\n+            if (stackFrames.length < size) {\n+                StackFrameInfo[] newFrames = new StackFrameInfo[size];\n+                \/\/ copy initial magic...\n+                System.arraycopy(stackFrames, 0, newFrames, 0, startIndex);\n+                stackFrames = newFrames;\n+            }\n+            for (int i = startIndex; i < size; i++) {\n+                stackFrames[i] = new StackFrameInfo(walker);\n+            }\n+            currentBatchSize = size;\n@@ -675,5 +637,4 @@\n-        static final class ClassBuffer extends FrameBuffer<Class<?>> {\n-            Class<?>[] classes;      \/\/ caller class for fast path\n-            ClassBuffer(int batchSize) {\n-                super(batchSize);\n-                classes = new Class<?>[batchSize];\n+        @Override\n+        StackFrameInfo nextStackFrame() {\n+            if (isEmpty()) {\n+                throw new NoSuchElementException(\"origin=\" + origin + \" fence=\" + fence);\n@@ -682,2 +643,4 @@\n-            @Override\n-            Class<?>[] frames() { return classes;}\n+            StackFrameInfo frame = stackFrames[origin];\n+            origin++;\n+            return frame;\n+        }\n@@ -685,2 +648,4 @@\n-            @Override\n-            final Class<?> at(int index) { return classes[index];}\n+        @Override\n+        final Class<?> at(int index) {\n+            return stackFrames[index].declaringClass();\n+        }\n@@ -688,20 +653,6 @@\n-            @Override\n-            final boolean filter(int index) { return false; }\n-\n-\n-            \/\/ ------ subclass may override the following methods -------\n-            \/**\n-             * Resizes the buffers for VM to fill in the next batch of stack frames.\n-             * The next batch will start at the given startIndex with the maximum number\n-             * of elements.\n-             *\n-             * <p> Subclass may override this method to manage the allocated buffers.\n-             *\n-             * @param startIndex the start index for the first frame of the next batch to fill in.\n-             * @param elements the number of elements for the next batch to fill in.\n-             *\n-             *\/\n-            @Override\n-            void resize(int startIndex, int elements) {\n-                if (!isActive())\n-                    throw new IllegalStateException(\"inactive frame buffer can't be resized\");\n+        @Override\n+        final boolean filter(int index) {\n+            return stackFrames[index].declaringClass() == Continuation.class\n+                    && \"yield0\".equals(stackFrames[index].getMethodName());\n+        }\n+    }\n@@ -709,2 +660,18 @@\n-                assert startIndex == START_POS :\n-                       \"bad start index \" + startIndex + \" expected \" + START_POS;\n+    static final class ClassBuffer extends FrameBuffer<ClassFrameInfo> {\n+        ClassFrameInfo[] classFrames;      \/\/ caller class for fast path\n+        ClassBuffer(int batchSize) {\n+            super(batchSize);\n+            classFrames = new ClassFrameInfo[batchSize];\n+            for (int i = START_POS; i < batchSize; i++) {\n+                classFrames[i] = new ClassFrameInfo();\n+            }\n+        }\n+\n+        @Override\n+        ClassFrameInfo[] frames() { return classFrames;}\n+\n+        @Override\n+        ClassFrameInfo nextStackFrame() {\n+            if (isEmpty()) {\n+                throw new NoSuchElementException(\"origin=\" + origin + \" fence=\" + fence);\n+            }\n@@ -712,7 +679,42 @@\n-                int size = startIndex+elements;\n-                if (classes.length < size) {\n-                    \/\/ copy the elements in classes array to the newly allocated one.\n-                    \/\/ classes[0] is a Thread object\n-                    Class<?>[] prev = classes;\n-                    classes = new Class<?>[size];\n-                    System.arraycopy(prev, 0, classes, 0, startIndex);\n+            ClassFrameInfo frame = classFrames[origin];\n+            origin++;\n+            return frame;\n+        }\n+\n+        @Override\n+        final Class<?> at(int index) { return classFrames[index].declaringClass();}\n+\n+        @Override\n+        final boolean filter(int index) {\n+            \/\/ no method information is available; should just filter\n+            \/\/ \"Continuation::yield0\".\n+            return classFrames[index].declaringClass() == Continuation.class;\n+        }\n+\n+        \/\/ ------ subclass may override the following methods -------\n+        \/**\n+         * Resizes the buffers for VM to fill in the next batch of stack frames.\n+         * The next batch will start at the given startIndex with the maximum number\n+         * of elements.\n+         *\n+         * <p> Subclass may override this method to manage the allocated buffers.\n+         *\n+         * @param startIndex the start index for the first frame of the next batch to fill in.\n+         * @param elements the number of elements for the next batch to fill in.\n+         *\n+         *\/\n+        @Override\n+        void resize(int startIndex, int elements) {\n+            if (!isActive())\n+                throw new IllegalStateException(\"inactive frame buffer can't be resized\");\n+\n+            assert startIndex == START_POS :\n+                    \"bad start index \" + startIndex + \" expected \" + START_POS;\n+\n+            int size = startIndex+elements;\n+            if (classFrames.length < size) {\n+                ClassFrameInfo[] newFrames = new ClassFrameInfo[size];\n+                \/\/ copy initial magic...\n+                System.arraycopy(classFrames, 0, newFrames, 0, startIndex);\n+                for (int i = startIndex; i < size; i++) {\n+                    newFrames[i] = new ClassFrameInfo();\n@@ -720,1 +722,1 @@\n-                currentBatchSize = size;\n+                classFrames = newFrames;\n@@ -722,0 +724,17 @@\n+            currentBatchSize = size;\n+        }\n+    }\n+\n+    \/*\n+     * CallerClassFinder is specialized to return Class<?> for each stack frame.\n+     * StackFrame is not requested.\n+     *\/\n+    static final class CallerClassFinder extends AbstractStackWalker<Integer, ClassFrameInfo> {\n+        static {\n+            stackWalkImplClasses.add(CallerClassFinder.class);\n+        }\n+\n+        private Class<?> caller;\n+\n+        CallerClassFinder(StackWalker walker) {\n+            super(walker, toStackWalkMode(walker, FILL_CLASS_REFS_ONLY));\n@@ -733,9 +752,17 @@\n-            Class<?>[] frames = new Class<?>[2];\n-            \/\/ skip the API calling this getCallerClass method\n-            \/\/ 0: StackWalker::getCallerClass\n-            \/\/ 1: caller-sensitive method\n-            \/\/ 2: caller class\n-            while (n < 2 && (caller = nextFrame()) != null) {\n-                if (isMethodHandleFrame(caller)) { continue; }\n-                if (isReflectionFrame(caller)) { continue; }\n-                frames[n++] = caller;\n+            ClassFrameInfo curFrame = null;\n+            \/\/ StackWalker::getCallerClass method\n+            \/\/ 0: caller-sensitive method\n+            \/\/ 1: caller class\n+            ClassFrameInfo[] frames = new ClassFrameInfo[2];\n+            while (n < 2 && hasNext() && (curFrame = frameBuffer.nextStackFrame()) != null) {\n+                caller = curFrame.declaringClass();\n+                if (curFrame.isHidden() || isReflectionFrame(caller) || isMethodHandleFrame(caller)) {\n+                    if (isDebug)\n+                        System.err.println(\"  skip: frame \" + frameBuffer.getIndex() + \" \" + caller.getName());\n+                    continue;\n+                }\n+                frames[n++] = curFrame;\n+            }\n+            if (isDebug) {\n+                System.err.println(\"0: \" + frames[0]);\n+                System.err.println(\"1: \" + frames[1]);\n@@ -746,0 +773,4 @@\n+            if (frames[0].isCallerSensitive()) {\n+                throw new UnsupportedOperationException(\"StackWalker::getCallerClass called from @CallerSensitive \"\n+                        + Arrays.toString(frames));\n+            }\n@@ -833,1 +864,1 @@\n-            super(walker, function, DEFAULT_MODE);\n+            super(walker, function);\n@@ -1048,1 +1079,1 @@\n-                c.getName().startsWith(\"java.util.stream.\");\n+                c.getPackageName().equals(\"java.util.stream\");\n@@ -1054,1 +1085,1 @@\n-        return c.getName().startsWith(\"java.lang.invoke.\");\n+        return c.getPackageName().equals(\"java.lang.invoke\");\n@@ -1058,1 +1089,0 @@\n-        \/\/ ## should filter all @Hidden frames?\n@@ -1062,2 +1092,1 @@\n-               ConstructorAccessor.class.isAssignableFrom(c) ||\n-               c.getName().startsWith(\"java.lang.invoke.LambdaForm\");\n+               ConstructorAccessor.class.isAssignableFrom(c);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StackStreamFactory.java","additions":178,"deletions":149,"binary":false,"changes":327,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -70,2 +70,2 @@\n- * <pre>{@code\n- *     StackWalker walker = StackWalker.getInstance(Option.RETAIN_CLASS_REFERENCE);\n+ * {@snippet lang=\"java\" :\n+ *     StackWalker walker = StackWalker.getInstance(Option.RETAIN_CLASS_REFERENCE, Option.NO_METHOD_INFO);\n@@ -73,4 +73,4 @@\n- *         s.map(StackFrame::getDeclaringClass)\n- *          .filter(interestingClasses::contains)\n- *          .findFirst());\n- * }<\/pre>\n+ *             s.map(StackFrame::getDeclaringClass)\n+ *              .filter(interestingClasses::contains)\n+ *              .findFirst());\n+ * }\n@@ -79,1 +79,1 @@\n- * <pre>{@code\n+ * {@snippet lang=\"java\" :\n@@ -81,2 +81,2 @@\n- *         s.limit(10).collect(Collectors.toList()));\n- * }<\/pre>\n+ *             s.limit(10).collect(Collectors.toList()));\n+ * }\n@@ -96,3 +96,11 @@\n-     * <p> The {@link #getDeclaringClass()} method may be unsupported as determined\n-     * by the {@linkplain Option stack walking options} of a {@linkplain\n-     * StackWalker stack walker}.\n+     * <p> The information of a {@code StackFrame} is determined by\n+     * {@linkplain Option the stack walking options}.\n+     * By default, the class and method information is available but not\n+     * the {@link #getDeclaringClass() Class} object.\n+     * To access the {@code Class} object, {@link Option#RETAIN_CLASS_REFERENCE\n+     * Option.RETAIN_CLASS_REFERENCE} can be used.\n+     *\n+     * <p> If the method information is not needed, {@link Option#NO_METHOD_INFO\n+     * Option.NO_METHOD_INFO} can be used such that the {@code StackWalker}\n+     * can save the overhead in extracting the method information from the\n+     * stack frames.\n@@ -101,1 +109,1 @@\n-     * @jvms 2.6\n+     * @jvms 2.6 Frames\n@@ -105,5 +113,2 @@\n-         * Gets the <a href=\"ClassLoader.html#binary-name\">binary name<\/a>\n-         * of the declaring class of the method represented by this stack frame.\n-         *\n-         * @return the binary name of the declaring class of the method\n-         *         represented by this stack frame\n+         * {@return the <a href=\"ClassLoader.html#binary-name\">binary name<\/a>\n+         * of the declaring class of the method represented by this stack frame}\n@@ -116,2 +121,5 @@\n-         * Gets the name of the method represented by this stack frame.\n-         * @return the name of the method represented by this stack frame\n+         * {@return the name of the method represented by this stack frame}\n+         *\n+         * @throws UnsupportedOperationException if this {@code StackFrame}\n+         *         is produced by a {@code StackWalker} configured with\n+         *         {@link Option#NO_METHOD_INFO Option.NO_METHOD_INFO}\n@@ -122,2 +130,2 @@\n-         * Gets the declaring {@code Class} for the method represented by\n-         * this stack frame.\n+         * {@return the declaring {@code Class} for the method represented by\n+         * this stack frame}\n@@ -125,6 +133,3 @@\n-         * @return the declaring {@code Class} of the method represented by\n-         * this stack frame\n-         *\n-         * @throws UnsupportedOperationException if this {@code StackWalker}\n-         *         is not configured with {@link Option#RETAIN_CLASS_REFERENCE\n-         *         Option.RETAIN_CLASS_REFERENCE}.\n+         * @throws UnsupportedOperationException if this {@code StackFrame}\n+         *         is produced by a {@code StackWalker} configured without\n+         *         {@link Option#RETAIN_CLASS_REFERENCE Option.RETAIN_CLASS_REFERENCE}\n@@ -143,3 +148,4 @@\n-         * @throws UnsupportedOperationException if this {@code StackWalker}\n-         *         is not configured with {@link Option#RETAIN_CLASS_REFERENCE\n-         *         Option.RETAIN_CLASS_REFERENCE}.\n+         * @throws UnsupportedOperationException if this {@code StackFrame}\n+         *         is produced by a {@code StackWalker} configured without\n+         *         {@link Option#RETAIN_CLASS_REFERENCE Option.RETAIN_CLASS_REFERENCE}\n+         *         or with {@link Option#NO_METHOD_INFO Option.NO_METHOD_INFO}\n@@ -164,0 +170,4 @@\n+         * @throws UnsupportedOperationException if this {@code StackFrame}\n+         *         is produced by a {@code StackWalker} configured with\n+         *         {@link Option#NO_METHOD_INFO Option.NO_METHOD_INFO}\n+         *\n@@ -185,0 +195,4 @@\n+         * @throws UnsupportedOperationException if this {@code StackFrame}\n+         *         is produced by a {@code StackWalker} configured with\n+         *         {@link Option#NO_METHOD_INFO Option.NO_METHOD_INFO}\n+         *\n@@ -201,0 +215,4 @@\n+         * @throws UnsupportedOperationException if this {@code StackFrame}\n+         *         is produced by a {@code StackWalker} configured with\n+         *         {@link Option#NO_METHOD_INFO Option.NO_METHOD_INFO}\n+         *\n@@ -216,0 +234,4 @@\n+         * @throws UnsupportedOperationException if this {@code StackFrame}\n+         *         is produced by a {@code StackWalker} configured with\n+         *         {@link Option#NO_METHOD_INFO Option.NO_METHOD_INFO}\n+         *\n@@ -221,2 +243,2 @@\n-         * Returns {@code true} if the method containing the execution point\n-         * represented by this stack frame is a native method.\n+         * {@return {@code true} if the method containing the execution point\n+         * represented by this stack frame is a native method}\n@@ -224,2 +246,3 @@\n-         * @return {@code true} if the method containing the execution point\n-         *         represented by this stack frame is a native method.\n+         * @throws UnsupportedOperationException if this {@code StackFrame}\n+         *         is produced by a {@code StackWalker} configured with\n+         *         {@link Option#NO_METHOD_INFO Option.NO_METHOD_INFO}\n@@ -230,1 +253,1 @@\n-         * Gets a {@code StackTraceElement} for this stack frame.\n+         * {@return {@code StackTraceElement} for this stack frame}\n@@ -232,1 +255,3 @@\n-         * @return {@code StackTraceElement} for this stack frame.\n+         * @throws UnsupportedOperationException if this {@code StackFrame}\n+         *         is produced by a {@code StackWalker} configured with\n+         *         {@link Option#NO_METHOD_INFO Option.NO_METHOD_INFO}\n@@ -283,1 +308,22 @@\n-        SHOW_HIDDEN_FRAMES;\n+        SHOW_HIDDEN_FRAMES,\n+\n+        \/**\n+         * No method information.\n+         *\n+         * <p> By default, method information is available in {@code StackFrame}s\n+         * walked by a stack walker.   This option allows a {@code StackWalker}\n+         * to collect only the class information of the stack frames such as\n+         * {@link StackFrame#getClassName() class name} and the\n+         * {@link StackFrame#getDeclaringClass() Class} object\n+         * if {@link #RETAIN_CLASS_REFERENCE RETAIN_CLASS_REFERENCE} is set.\n+         * Method information such as {@linkplain StackFrame#getMethodName() method name},\n+         * {@linkplain StackFrame#getMethodType() method type},\n+         * {@linkplain StackFrame#getLineNumber() line number} and\n+         * {@linkplain StackFrame#getByteCodeIndex() bytecode index} is not collected\n+         * by a {@code StackWalker} with this option.\n+         *\n+         * @apiNote\n+         * This option allows the implementation to skip the\n+         * @since 22\n+         *\/\n+        NO_METHOD_INFO;\n@@ -361,0 +407,23 @@\n+    \/**\n+     * Returns a {@code StackWalker} instance with the given options specifying\n+     * the stack frame information it can access.\n+     *\n+     * <p>\n+     * If a security manager is present and the given {@code options} contains\n+     * {@link Option#RETAIN_CLASS_REFERENCE Option.RETAIN_CLASS_REFERENCE},\n+     * it calls its {@link SecurityManager#checkPermission checkPermission}\n+     * method for {@code RuntimePermission(\"getStackWalkerWithClassReference\")}.\n+     *\n+     * @param options {@link Option stack walking options}\n+     *\n+     * @return a {@code StackWalker} configured with the given options\n+     *\n+     * @throws SecurityException if a security manager exists and its\n+     *         {@code checkPermission} method denies access.\n+     *\n+     * @since 22\n+     *\/\n+    public static StackWalker getInstance(Option... options) {\n+        return getInstance(Set.of(Objects.requireNonNull(options)));\n+    }\n+\n@@ -396,1 +465,1 @@\n-     * @param options {@link Option stack walking option}\n+     * @param options {@link Option stack walking options}\n@@ -420,1 +489,1 @@\n-     * @param options {@link Option stack walking option}\n+     * @param options {@link Option stack walking options}\n@@ -544,2 +613,1 @@\n-     * <blockquote>\n-     * <pre>{@code\n+     * {@snippet lang=\"java\" :\n@@ -547,4 +615,4 @@\n-     *     s.dropWhile(f -> f.getClassName().startsWith(\"com.foo.\"))\n-     *      .limit(10)\n-     *      .collect(Collectors.toList()));\n-     * }<\/pre><\/blockquote>\n+     *         s.dropWhile(f -> f.getClassName().startsWith(\"com.foo.\"))\n+     *          .limit(10)\n+     *          .collect(Collectors.toList()));\n+     * }\n@@ -641,1 +709,1 @@\n-     * <pre>{@code\n+     * {@snippet lang=\"java\" :\n@@ -643,1 +711,1 @@\n-     *     private final StackWalker walker = StackWalker.getInstance(Option.RETAIN_CLASS_REFERENCE);\n+     *     private final StackWalker walker = StackWalker.getInstance(Option.RETAIN_CLASS_REFERENCE, Option.NO_METHOD_INFO);\n@@ -656,1 +724,1 @@\n-     * }<\/pre>\n+     * }\n@@ -662,1 +730,1 @@\n-     * <pre>{@code\n+     * {@snippet lang=\"java\" :\n@@ -667,1 +735,1 @@\n-     * }<\/pre>\n+     * }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StackWalker.java","additions":120,"deletions":52,"binary":false,"changes":172,"status":"modified"},{"patch":"@@ -68,5 +68,0 @@\n-\/*non-public*\/\n-final class ResolvedMethodName {\n-    \/\/@Injected JVM_Method* vmtarget;\n-    \/\/@Injected Class<?>    vmholder;\n-}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MemberName.java","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -60,0 +60,2 @@\n+import static java.lang.invoke.MethodHandleNatives.Constants.MN_CALLER_SENSITIVE;\n+import static java.lang.invoke.MethodHandleNatives.Constants.MN_HIDDEN_MEMBER;\n@@ -1546,2 +1548,3 @@\n-            public Object newMemberName() {\n-                return new MemberName();\n+            public Class<?> getDeclaringClass(Object rmname) {\n+                ResolvedMethodName method = (ResolvedMethodName)rmname;\n+                return method.declaringClass();\n@@ -1551,8 +1554,2 @@\n-            public String getName(Object mname) {\n-                MemberName memberName = (MemberName)mname;\n-                return memberName.getName();\n-            }\n-            @Override\n-            public Class<?> getDeclaringClass(Object mname) {\n-                MemberName memberName = (MemberName)mname;\n-                return memberName.getDeclaringClass();\n+            public MethodType getMethodType(String descriptor, ClassLoader loader) {\n+                return MethodType.fromDescriptor(descriptor, loader);\n@@ -1561,4 +1558,2 @@\n-            @Override\n-            public MethodType getMethodType(Object mname) {\n-                MemberName memberName = (MemberName)mname;\n-                return memberName.getMethodType();\n+            public boolean isCallerSensitive(int flags) {\n+                return (flags & MN_CALLER_SENSITIVE) == MN_CALLER_SENSITIVE;\n@@ -1567,10 +1562,2 @@\n-            @Override\n-            public String getMethodDescriptor(Object mname) {\n-                MemberName memberName = (MemberName)mname;\n-                return memberName.getMethodDescriptor();\n-            }\n-\n-            @Override\n-            public boolean isNative(Object mname) {\n-                MemberName memberName = (MemberName)mname;\n-                return memberName.isNative();\n+            public boolean isHiddenMember(int flags) {\n+                return (flags & MN_HIDDEN_MEMBER) == MN_HIDDEN_MEMBER;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleImpl.java","additions":11,"deletions":24,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -119,0 +119,1 @@\n+            MN_HIDDEN_MEMBER       = 0x00400000, \/\/ members defined in a hidden class or with @Hidden\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleNatives.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,35 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.invoke;\n+\n+final class ResolvedMethodName {\n+    \/\/@Injected JVM_Method* vmtarget;\n+    private Class<?> vmholder;\n+\n+    Class<?> declaringClass() {\n+        return vmholder;\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/ResolvedMethodName.java","additions":35,"deletions":0,"binary":false,"changes":35,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -75,1 +75,1 @@\n-                () -> StackWalker.getInstance(Option.RETAIN_CLASS_REFERENCE);\n+                () -> StackWalker.getInstance(Set.of(Option.RETAIN_CLASS_REFERENCE, Option.NO_METHOD_INFO));\n","filename":"src\/java.base\/share\/classes\/javax\/crypto\/JceSecurityManager.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -43,11 +43,1 @@\n-     * Create a new MemberName instance. Used by {@code StackFrameInfo}.\n-     *\/\n-    Object newMemberName();\n-\n-    \/**\n-     * Returns the name for the given MemberName. Used by {@code StackFrameInfo}.\n-     *\/\n-    String getName(Object mname);\n-\n-    \/**\n-     * Returns the {@code MethodType} for the given MemberName.\n+     * Returns the declaring class for the given ResolvedMethodName.\n@@ -56,1 +46,1 @@\n-    MethodType getMethodType(Object mname);\n+    Class<?> getDeclaringClass(Object rmname);\n@@ -59,1 +49,2 @@\n-     * Returns the descriptor for the given MemberName.\n+     * Returns the {@code MethodType} for the given method descriptor\n+     * and class loader.\n@@ -62,1 +53,1 @@\n-    String getMethodDescriptor(Object mname);\n+    MethodType getMethodType(String descriptor, ClassLoader loader);\n@@ -65,2 +56,1 @@\n-     * Returns {@code true} if the given MemberName is a native method.\n-     * Used by {@code StackFrameInfo}.\n+     * Returns true if the given flags has MN_CALLER_SENSITIVE flag set.\n@@ -68,1 +58,1 @@\n-    boolean isNative(Object mname);\n+    boolean isCallerSensitive(int flags);\n@@ -71,2 +61,1 @@\n-     * Returns the declaring class for the given MemberName.\n-     * Used by {@code StackFrameInfo}.\n+     * Returns true if the given flags has MN_HIDDEN_MEMBER flag set.\n@@ -74,1 +63,1 @@\n-    Class<?> getDeclaringClass(Object mname);\n+    boolean isHiddenMember(int flags);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangInvokeAccess.java","additions":9,"deletions":20,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -0,0 +1,37 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <stdio.h>\n+#include <signal.h>\n+\n+#include \"jni.h\"\n+#include \"jvm.h\"\n+\n+#include \"java_lang_StackFrameInfo.h\"\n+\n+JNIEXPORT void JNICALL Java_java_lang_StackFrameInfo_expandStackFrameInfo\n+  (JNIEnv *env, jobject obj) {\n+     JVM_ExpandStackFrameInfo(env, obj);\n+}\n","filename":"src\/java.base\/share\/native\/libjava\/StackFrameInfo.c","additions":37,"deletions":0,"binary":false,"changes":37,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n-    static Field memberName;\n+    static Field classOrMemberName;\n@@ -70,0 +70,3 @@\n+        Class<?> classFrameInfoClass = Class.forName(\"java.lang.ClassFrameInfo\");\n+        classOrMemberName = classFrameInfoClass.getDeclaredField(\"classOrMemberName\");\n+        classOrMemberName.setAccessible(true);\n@@ -71,2 +74,0 @@\n-        memberName = stackFrameInfoClass.getDeclaredField(\"memberName\");\n-        memberName.setAccessible(true);\n","filename":"test\/hotspot\/jtreg\/runtime\/LocalLong\/LocalLongHelper.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -61,1 +61,1 @@\n-            throw new RuntimeException(\"Exception not thrown by StackWalker::getCallerClass\");\n+            throw new RuntimeException(\"Exception not thrown by StackWalker::getCallerClass. Returned \" + c2.getName());\n","filename":"test\/jdk\/java\/lang\/StackWalker\/CallerSensitiveMethod\/src\/java.base\/java\/util\/CSM.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+ShowHiddenFrames GetCallerClassTest\n","filename":"test\/jdk\/java\/lang\/StackWalker\/GetCallerClassTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n- * @run testng SanityTest\n+ * @run junit SanityTest\n@@ -31,1 +31,0 @@\n-\n@@ -34,0 +33,2 @@\n+import java.util.stream.Stream;\n+import static java.lang.StackWalker.Option.*;\n@@ -35,1 +36,4 @@\n-import org.testng.annotations.Test;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import static org.junit.jupiter.api.Assertions.*;\n@@ -39,10 +43,9 @@\n-    public static void testNPE() {\n-        try {\n-            StackWalker sw = StackWalker.getInstance((Set<StackWalker.Option>) null);\n-            throw new RuntimeException(\"NPE expected\");\n-        } catch (NullPointerException e) {}\n-\n-        try {\n-            StackWalker sw = StackWalker.getInstance((StackWalker.Option) null);\n-            throw new RuntimeException(\"NPE expected\");\n-        } catch (NullPointerException e) {}\n+    public void testNPE() {\n+        assertThrows(NullPointerException.class, () ->\n+                StackWalker.getInstance((Set<StackWalker.Option>) null));\n+        assertThrows(NullPointerException.class, () ->\n+                StackWalker.getInstance((StackWalker.Option) null));\n+        assertThrows(NullPointerException.class, () ->\n+                StackWalker.getInstance((StackWalker.Option[]) null));\n+        assertThrows(NullPointerException.class, () ->\n+                StackWalker.getInstance(new StackWalker.Option[] { null }));\n@@ -52,5 +55,3 @@\n-    public static void testUOE() {\n-        try {\n-            StackWalker.getInstance().getCallerClass();\n-            throw new RuntimeException(\"UOE expected\");\n-        } catch (UnsupportedOperationException expected) {}\n+    public void testUOE() {\n+        assertThrows(UnsupportedOperationException.class, () ->\n+                StackWalker.getInstance().getCallerClass());\n@@ -60,5 +61,3 @@\n-    public static void testInvalidEstimateDepth() {\n-        try {\n-            StackWalker sw = StackWalker.getInstance(Collections.emptySet(), 0);\n-            throw new RuntimeException(\"Illegal estimateDepth should throw IAE\");\n-        } catch (IllegalArgumentException e) {}\n+    public void testInvalidEstimateDepth() {\n+        assertThrows(IllegalArgumentException.class, () ->\n+                StackWalker.getInstance(Collections.emptySet(), 0));\n@@ -68,5 +67,3 @@\n-    public static void testNullFuncation() {\n-        try {\n-            StackWalker.getInstance().walk(null);\n-            throw new RuntimeException(\"NPE expected\");\n-        } catch (NullPointerException e) {}\n+    public void testNullFuncation() {\n+        assertThrows(NullPointerException.class, () ->\n+                StackWalker.getInstance().walk(null));\n@@ -76,5 +73,3 @@\n-    public static void testNullConsumer() {\n-        try {\n-            StackWalker.getInstance().forEach(null);\n-            throw new RuntimeException(\"NPE expected\");\n-        } catch (NullPointerException e) {}\n+    public void testNullConsumer() {\n+        assertThrows(NullPointerException.class, () ->\n+                StackWalker.getInstance().forEach(null));\n@@ -85,7 +80,3 @@\n-    public static void testUOEFromGetDeclaringClass() {\n-        try {\n-            StackWalker sw = StackWalker.getInstance();\n-            sw.forEach(StackWalker.StackFrame::getDeclaringClass);\n-            throw new RuntimeException(\"UOE expected\");\n-        } catch (UnsupportedOperationException expected) {\n-        }\n+    public void testUOEFromGetDeclaringClass() {\n+        assertThrows(UnsupportedOperationException.class, () ->\n+                StackWalker.getInstance().forEach(StackWalker.StackFrame::getDeclaringClass));\n@@ -94,7 +85,27 @@\n-    @Test\n-    public static void testUOEFromGetMethodType() {\n-        try {\n-            StackWalker sw = StackWalker.getInstance();\n-            sw.forEach(StackWalker.StackFrame::getMethodType);\n-            throw new RuntimeException(\"UOE expected\");\n-        } catch (UnsupportedOperationException expected) {}\n+    private static Stream<StackWalker> noMethodTypeAccess() {\n+        return Stream.of(StackWalker.getInstance(), StackWalker.getInstance(RETAIN_CLASS_REFERENCE, NO_METHOD_INFO));\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"noMethodTypeAccess\")\n+    public void testUOEFromGetMethodType() {\n+        assertThrows(UnsupportedOperationException.class, () ->\n+                StackWalker.getInstance().forEach(StackWalker.StackFrame::getMethodType));\n+    }\n+\n+    public void testNoMethodInfo() {\n+        StackWalker sw = StackWalker.getInstance(RETAIN_CLASS_REFERENCE, NO_METHOD_INFO);\n+        assertThrows(UnsupportedOperationException.class, () ->\n+                sw.forEach(StackWalker.StackFrame::getMethodName));\n+        assertThrows(UnsupportedOperationException.class, () ->\n+                sw.forEach(StackWalker.StackFrame::getMethodType));\n+        assertThrows(UnsupportedOperationException.class, () ->\n+                sw.forEach(StackWalker.StackFrame::getDescriptor));\n+        assertThrows(UnsupportedOperationException.class, () ->\n+                sw.forEach(StackWalker.StackFrame::getByteCodeIndex));\n+        assertThrows(UnsupportedOperationException.class, () ->\n+                sw.forEach(StackWalker.StackFrame::getFileName));\n+        assertThrows(UnsupportedOperationException.class, () ->\n+                sw.forEach(StackWalker.StackFrame::isNativeMethod));\n+        assertThrows(UnsupportedOperationException.class, () ->\n+                sw.forEach(StackWalker.StackFrame::toStackTraceElement));\n","filename":"test\/jdk\/java\/lang\/StackWalker\/SanityTest.java","additions":59,"deletions":48,"binary":false,"changes":107,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -69,1 +69,1 @@\n-                  sf.getDeclaringClass().toString());\n+                  sf.getDeclaringClass().toString() + \", index: \" + index);\n@@ -87,1 +87,1 @@\n-                    \", but got: \" + sf.getClassName());\n+                    \", but got: \" + sf.getClassName() + \", index: \" + index);\n@@ -91,1 +91,1 @@\n-                    \", but got: \" + sf.getMethodName());\n+                    \", but got: \" + sf.getMethodName()  + \", index: \" + index);\n","filename":"test\/jdk\/java\/lang\/StackWalker\/StackRecorderUtil.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import java.util.Set;\n@@ -160,0 +161,13 @@\n+\n+            System.out.println(\"Collect classes\");\n+            List<Class<?>> classes = StackWalker.getInstance(Set.of(RETAIN_CLASS_REFERENCE, NO_METHOD_INFO))\n+                    .walk(s -> {\n+                        return s.map(StackFrame::getDeclaringClass).collect(Collectors.toList());\n+                    });\n+            for (i=0; i < GOLDEN_CLASS_NAMES.size(); i++) {\n+                Class<?> c = classes.get(i);\n+                if (!GOLDEN_CLASS_NAMES.get(i).equals(c.getName())) {\n+                    throw new RuntimeException(\"unexpected class at \" + i + \" \" + c.getName() +\n+                            \" expected \" + GOLDEN_CLASS_NAMES.get(i));\n+                }\n+            }\n","filename":"test\/jdk\/java\/lang\/StackWalker\/StackStreamTest.java","additions":15,"deletions":1,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -58,0 +58,1 @@\n+            \"jdk.internal.reflect.DirectMethodHandleAccessor\",\n","filename":"test\/jdk\/java\/lang\/StackWalker\/StackWalkTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -156,1 +156,1 @@\n-                EnumSet.allOf(StackWalker.Option.class));\n+                EnumSet.of(RETAIN_CLASS_REFERENCE, SHOW_HIDDEN_FRAMES, SHOW_REFLECT_FRAMES));\n","filename":"test\/jdk\/java\/lang\/StackWalker\/VerifyStackTrace.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,2 @@\n+import java.util.Set;\n+\n@@ -39,0 +41,2 @@\n+import static java.lang.StackWalker.Option.*;\n+\n@@ -49,2 +53,0 @@\n-    private static final StackWalker WALKER_DEFAULT = StackWalker.getInstance();\n-\n@@ -52,1 +54,11 @@\n-        StackWalker.getInstance(StackWalker.Option.RETAIN_CLASS_REFERENCE);\n+            StackWalker.getInstance(RETAIN_CLASS_REFERENCE);\n+    private static final StackWalker WALKER_CLASS_NO_METHOD =\n+            StackWalker.getInstance(Set.of(RETAIN_CLASS_REFERENCE, NO_METHOD_INFO));\n+\n+    static StackWalker walker(String name) {\n+        return switch (name) {\n+            case \"default\" -> WALKER_CLASS;\n+            case \"no_method\" -> WALKER_CLASS_NO_METHOD;\n+            default -> throw new IllegalArgumentException(name);\n+        };\n+    }\n@@ -66,0 +78,3 @@\n+    @Param({\"default\", \"no_method\"})\n+    public String walker;\n+\n@@ -178,1 +193,1 @@\n-                WALKER_DEFAULT.forEach(localBH::consume);\n+                walker(walker).forEach(localBH::consume);\n@@ -196,1 +211,1 @@\n-                WALKER_DEFAULT.walk(s -> {\n+                walker(walker).walk(s -> {\n@@ -215,0 +230,2 @@\n+        final StackWalker sw = walker(walker);\n+        if (sw != WALKER_CLASS) return;\n@@ -217,1 +234,1 @@\n-                WALKER_DEFAULT.walk( s -> {\n+                sw.walk( s -> {\n@@ -236,0 +253,1 @@\n+        final StackWalker sw = walker(walker);\n@@ -238,1 +256,1 @@\n-                WALKER_CLASS.walk(s -> {\n+                sw.walk(s -> {\n@@ -250,0 +268,21 @@\n+    \/**\n+     * Use Stackwalker.walk() to fetch all instances\n+     *\/\n+    @Benchmark\n+    public void walk_StackFrame(Blackhole bh) {\n+        final Blackhole localBH = bh;\n+        final boolean[] done = {false};\n+        new TestStack(depth, new Runnable() {\n+            public void run() {\n+                walker(walker).walk(s -> {\n+                    s.forEach(localBH::consume);\n+                    return null;\n+                });\n+                done[0] = true;\n+            }\n+        }).start();\n+        if (!done[0]) {\n+            throw new RuntimeException();\n+        }\n+    }\n+\n@@ -257,0 +296,3 @@\n+        final StackWalker sw = walker(walker);\n+        if (sw != WALKER_CLASS) return;\n+\n@@ -259,1 +301,1 @@\n-                WALKER_DEFAULT.walk(s -> {\n+                sw.walk(s -> {\n@@ -278,0 +320,1 @@\n+        final StackWalker sw = walker(walker);\n@@ -280,1 +323,1 @@\n-                localBH.consume(WALKER_CLASS.getCallerClass());\n+                localBH.consume(sw.getCallerClass());\n@@ -298,1 +341,1 @@\n-\n+        final StackWalker sw = walker(walker);\n@@ -302,1 +345,1 @@\n-                WALKER_CLASS.walk(s -> {\n+                sw.walk(s -> {\n@@ -324,1 +367,1 @@\n-\n+        final StackWalker sw = walker(walker);\n@@ -328,1 +371,1 @@\n-                WALKER_CLASS.walk(s -> {\n+                sw.walk(s -> {\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/StackWalkBench.java","additions":57,"deletions":14,"binary":false,"changes":71,"status":"modified"}]}