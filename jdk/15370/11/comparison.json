{"files":[{"patch":"@@ -60,0 +60,1 @@\n+JVM_ExpandStackFrameInfo\n","filename":"make\/data\/hotspot-symbols\/symbols-unix","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2959,0 +2959,61 @@\n+\/\/ java_lang_ClassFrameInfo\n+\n+int java_lang_ClassFrameInfo::_classOrMemberName_offset;\n+int java_lang_ClassFrameInfo::_flags_offset;\n+\n+#define CLASSFRAMEINFO_FIELDS_DO(macro) \\\n+  macro(_classOrMemberName_offset, k, \"classOrMemberName\", object_signature,  false); \\\n+  macro(_flags_offset,             k, vmSymbols::flags_name(), int_signature, false)\n+\n+void java_lang_ClassFrameInfo::compute_offsets() {\n+  InstanceKlass* k = vmClasses::ClassFrameInfo_klass();\n+  CLASSFRAMEINFO_FIELDS_DO(FIELD_COMPUTE_OFFSET);\n+}\n+\n+#if INCLUDE_CDS\n+void java_lang_ClassFrameInfo::serialize_offsets(SerializeClosure* f) {\n+  CLASSFRAMEINFO_FIELDS_DO(FIELD_SERIALIZE_OFFSET);\n+}\n+#endif\n+\n+static int get_flags(const methodHandle& m) {\n+  int flags = (jushort)( m->access_flags().as_short() & JVM_RECOGNIZED_METHOD_MODIFIERS );\n+  if (m->is_initializer()) {\n+    flags |= java_lang_invoke_MemberName::MN_IS_CONSTRUCTOR;\n+  } else {\n+    flags |= java_lang_invoke_MemberName::MN_IS_METHOD;\n+  }\n+  if (m->caller_sensitive()) {\n+    flags |= java_lang_invoke_MemberName::MN_CALLER_SENSITIVE;\n+  }\n+  if (m->is_hidden()) {\n+    flags |= java_lang_invoke_MemberName::MN_HIDDEN_MEMBER;\n+  }\n+  assert((flags & 0xFF000000) == 0, \"unexpected flags\");\n+  return flags;\n+}\n+\n+oop java_lang_ClassFrameInfo::classOrMemberName(oop obj) {\n+  return obj->obj_field(_classOrMemberName_offset);\n+}\n+\n+int java_lang_ClassFrameInfo::flags(oop obj) {\n+  return obj->int_field(_flags_offset);\n+}\n+\n+void java_lang_ClassFrameInfo::init_class(Handle stackFrame, const methodHandle& m) {\n+  stackFrame->obj_field_put(_classOrMemberName_offset, m->method_holder()->java_mirror());\n+  \/\/ flags is initialized when ClassFrameInfo object is constructed and retain the value\n+  int flags = java_lang_ClassFrameInfo::flags(stackFrame()) | get_flags(m);\n+  stackFrame->int_field_put(_flags_offset, flags);\n+}\n+\n+void java_lang_ClassFrameInfo::init_method(Handle stackFrame, const methodHandle& m, TRAPS) {\n+  oop rmethod_name = java_lang_invoke_ResolvedMethodName::find_resolved_method(m, CHECK);\n+  stackFrame->obj_field_put(_classOrMemberName_offset, rmethod_name);\n+  \/\/ flags is initialized when ClassFrameInfo object is constructed and retain the value\n+  int flags = java_lang_ClassFrameInfo::flags(stackFrame()) | get_flags(m);\n+  stackFrame->int_field_put(_flags_offset, flags);\n+}\n+\n+\n@@ -2961,1 +3022,2 @@\n-int java_lang_StackFrameInfo::_memberName_offset;\n+int java_lang_StackFrameInfo::_type_offset;\n+int java_lang_StackFrameInfo::_name_offset;\n@@ -2967,1 +3029,2 @@\n-  macro(_memberName_offset, k, \"memberName\", object_signature,            false); \\\n+  macro(_type_offset,       k, \"type\",       object_signature,            false); \\\n+  macro(_name_offset,       k, \"name\",       string_signature,            false); \\\n@@ -2984,6 +3047,3 @@\n-Method* java_lang_StackFrameInfo::get_method(Handle stackFrame, InstanceKlass* holder, TRAPS) {\n-  HandleMark hm(THREAD);\n-  Handle mname(THREAD, stackFrame->obj_field(_memberName_offset));\n-  Method* method = (Method*)java_lang_invoke_MemberName::vmtarget(mname());\n-  \/\/ we should expand MemberName::name when Throwable uses StackTrace\n-  \/\/ MethodHandles::expand_MemberName(mname, MethodHandles::_suppress_defc|MethodHandles::_suppress_type, CHECK_NULL);\n+Method* java_lang_StackFrameInfo::get_method(oop obj) {\n+  oop m = java_lang_ClassFrameInfo::classOrMemberName(obj);\n+  Method* method = java_lang_invoke_ResolvedMethodName::vmtarget(m);\n@@ -2996,5 +3056,3 @@\n-  Handle mname(THREAD, stackFrame->obj_field(_memberName_offset));\n-  Handle cont_h (THREAD, cont);\n-  InstanceKlass* ik = method->method_holder();\n-  CallInfo info(method(), ik, CHECK);\n-  MethodHandles::init_method_MemberName(mname, info);\n+  Handle cont_h(THREAD, cont);\n+  java_lang_ClassFrameInfo::init_method(stackFrame, method, CHECK);\n+\n@@ -3015,4 +3073,0 @@\n-  Handle mname(THREAD, stackFrame->obj_field(java_lang_StackFrameInfo::_memberName_offset));\n-  Klass* clazz = java_lang_Class::as_Klass(java_lang_invoke_MemberName::clazz(mname()));\n-  InstanceKlass* holder = InstanceKlass::cast(clazz);\n-  Method* method = java_lang_StackFrameInfo::get_method(stackFrame, holder, CHECK);\n@@ -3020,0 +3074,2 @@\n+  Method* method = java_lang_StackFrameInfo::get_method(stackFrame());\n+  InstanceKlass* holder = method->method_holder();\n@@ -3026,2 +3082,2 @@\n-void java_lang_StackFrameInfo::set_version(oop element, short value) {\n-  element->short_field_put(_version_offset, value);\n+oop java_lang_StackFrameInfo::type(oop obj) {\n+  return obj->obj_field(_type_offset);\n@@ -3030,1 +3086,17 @@\n-void java_lang_StackFrameInfo::set_bci(oop element, int value) {\n+void java_lang_StackFrameInfo::set_type(oop obj, oop value) {\n+  obj->obj_field_put(_type_offset, value);\n+}\n+\n+oop java_lang_StackFrameInfo::name(oop obj) {\n+  return obj->obj_field(_name_offset);\n+}\n+\n+void java_lang_StackFrameInfo::set_name(oop obj, oop value) {\n+  obj->obj_field_put(_name_offset, value);\n+}\n+\n+void java_lang_StackFrameInfo::set_version(oop obj, short value) {\n+  obj->short_field_put(_version_offset, value);\n+}\n+\n+void java_lang_StackFrameInfo::set_bci(oop obj, int value) {\n@@ -3032,1 +3104,1 @@\n-  element->int_field_put(_bci_offset, value);\n+  obj->int_field_put(_bci_offset, value);\n@@ -3035,2 +3107,2 @@\n-void java_lang_StackFrameInfo::set_contScope(oop element, oop value) {\n-  element->obj_field_put(_contScope_offset, value);\n+void java_lang_StackFrameInfo::set_contScope(oop obj, oop value) {\n+  obj->obj_field_put(_contScope_offset, value);\n@@ -3061,2 +3133,2 @@\n-void java_lang_LiveStackFrameInfo::set_monitors(oop element, oop value) {\n-  element->obj_field_put(_monitors_offset, value);\n+void java_lang_LiveStackFrameInfo::set_monitors(oop obj, oop value) {\n+  obj->obj_field_put(_monitors_offset, value);\n@@ -3065,2 +3137,2 @@\n-void java_lang_LiveStackFrameInfo::set_locals(oop element, oop value) {\n-  element->obj_field_put(_locals_offset, value);\n+void java_lang_LiveStackFrameInfo::set_locals(oop obj, oop value) {\n+  obj->obj_field_put(_locals_offset, value);\n@@ -3069,2 +3141,2 @@\n-void java_lang_LiveStackFrameInfo::set_operands(oop element, oop value) {\n-  element->obj_field_put(_operands_offset, value);\n+void java_lang_LiveStackFrameInfo::set_operands(oop obj, oop value) {\n+  obj->obj_field_put(_operands_offset, value);\n@@ -3073,2 +3145,2 @@\n-void java_lang_LiveStackFrameInfo::set_mode(oop element, int value) {\n-  element->int_field_put(_mode_offset, value);\n+void java_lang_LiveStackFrameInfo::set_mode(oop obj, int value) {\n+  obj->int_field_put(_mode_offset, value);\n@@ -3950,0 +4022,3 @@\n+#define RESOLVEDMETHOD_FIELDS_DO(macro) \\\n+  macro(_vmholder_offset, k, \"vmholder\", class_signature, false)\n+\n@@ -3953,0 +4028,1 @@\n+  RESOLVEDMETHOD_FIELDS_DO(FIELD_COMPUTE_OFFSET);\n@@ -3958,0 +4034,1 @@\n+  RESOLVEDMETHOD_FIELDS_DO(FIELD_SERIALIZE_OFFSET);\n@@ -5220,0 +5297,1 @@\n+  f(java_lang_ClassFrameInfo) \\\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":109,"deletions":31,"binary":false,"changes":140,"status":"modified"},{"patch":"@@ -1202,1 +1202,0 @@\n-  macro(java_lang_invoke_ResolvedMethodName, vmholder, object_signature, false) \\\n@@ -1291,0 +1290,1 @@\n+    MN_HIDDEN_MEMBER         = 0x00400000, \/\/ @Hidden annotation detected\n@@ -1594,0 +1594,20 @@\n+class java_lang_ClassFrameInfo: AllStatic {\n+private:\n+  static int _classOrMemberName_offset;\n+  static int _flags_offset;\n+\n+public:\n+  static oop  classOrMemberName(oop info);\n+  static int  flags(oop info);\n+\n+  \/\/ Setters\n+  static void init_class(Handle stackFrame, const methodHandle& m);\n+  static void init_method(Handle stackFrame, const methodHandle& m, TRAPS);\n+\n+  static void compute_offsets();\n+  static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;\n+\n+  \/\/ Debugging\n+  friend class JavaClasses;\n+};\n+\n@@ -1601,1 +1621,2 @@\n-  static int _memberName_offset;\n+  static int _type_offset;\n+  static int _name_offset;\n@@ -1606,2 +1627,0 @@\n-  static Method* get_method(Handle stackFrame, InstanceKlass* holder, TRAPS);\n-\n@@ -1609,0 +1628,5 @@\n+  \/\/ Getters\n+  static oop name(oop info);\n+  static oop type(oop info);\n+  static Method* get_method(oop info);\n+\n@@ -1611,0 +1635,2 @@\n+  static void set_name(oop info, oop value);\n+  static void set_type(oop info, oop value);\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":30,"deletions":4,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -163,0 +163,1 @@\n+  do_klass(ClassFrameInfo_klass,                        java_lang_ClassFrameInfo                              ) \\\n","filename":"src\/hotspot\/share\/classfile\/vmClassMacros.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -381,0 +381,1 @@\n+  template(java_lang_ClassFrameInfo,                  \"java\/lang\/ClassFrameInfo\")                 \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -247,2 +247,1 @@\n-  JVM_STACKWALK_FILL_CLASS_REFS_ONLY       = 0x2,\n-  JVM_STACKWALK_GET_CALLER_CLASS           = 0x04,\n+  JVM_STACKWALK_CLASS_INFO_ONLY            = 0x2,\n@@ -253,0 +252,3 @@\n+JNIEXPORT void JNICALL\n+JVM_ExpandStackFrameInfo(JNIEnv *env, jobject obj);\n+\n@@ -254,1 +256,1 @@\n-JVM_CallStackWalk(JNIEnv *env, jobject stackStream, jlong mode,\n+JVM_CallStackWalk(JNIEnv *env, jobject stackStream, jint mode,\n@@ -259,1 +261,1 @@\n-JVM_MoreStackWalk(JNIEnv *env, jobject stackStream, jlong mode, jlong anchor,\n+JVM_MoreStackWalk(JNIEnv *env, jobject stackStream, jint mode, jlong anchor,\n","filename":"src\/hotspot\/share\/include\/jvm.h","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -545,1 +545,1 @@\n-  java_lang_StackFrameInfo::to_stack_trace_element(stack_frame_info, stack_trace_element, THREAD);\n+  java_lang_StackFrameInfo::to_stack_trace_element(stack_frame_info, stack_trace_element, CHECK);\n@@ -550,0 +550,15 @@\n+JVM_ENTRY(void, JVM_ExpandStackFrameInfo(JNIEnv *env, jobject obj))\n+  Handle stack_frame_info(THREAD, JNIHandles::resolve_non_null(obj));\n+\n+  bool have_name = (java_lang_StackFrameInfo::name(stack_frame_info()) != nullptr);\n+  bool have_type = (java_lang_StackFrameInfo::type(stack_frame_info()) != nullptr);\n+  Method* method = java_lang_StackFrameInfo::get_method(stack_frame_info());\n+  if (!have_name) {\n+    oop name = StringTable::intern(method->name(), CHECK);\n+    java_lang_StackFrameInfo::set_name(stack_frame_info(), name);\n+  }\n+  if (!have_type) {\n+    Handle type = java_lang_String::create_from_symbol(method->signature(), CHECK);\n+    java_lang_StackFrameInfo::set_type(stack_frame_info(), type());\n+  }\n+JVM_END\n@@ -551,2 +566,1 @@\n-\n-JVM_ENTRY(jobject, JVM_CallStackWalk(JNIEnv *env, jobject stackStream, jlong mode,\n+JVM_ENTRY(jobject, JVM_CallStackWalk(JNIEnv *env, jobject stackStream, jint mode,\n@@ -562,1 +576,1 @@\n-  \/\/ frames array is a Class<?>[] array when only getting caller reference,\n+  \/\/ frames array is a ClassFrameInfo[] array when only getting caller reference,\n@@ -579,1 +593,1 @@\n-JVM_ENTRY(jint, JVM_MoreStackWalk(JNIEnv *env, jobject stackStream, jlong mode, jlong anchor,\n+JVM_ENTRY(jint, JVM_MoreStackWalk(JNIEnv *env, jobject stackStream, jint mode, jlong anchor,\n@@ -582,1 +596,1 @@\n-  \/\/ frames array is a Class<?>[] array when only getting caller reference,\n+  \/\/ frames array is a ClassFrameInfo[] array when only getting caller reference,\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":20,"deletions":6,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -140,0 +140,1 @@\n+  HIDDEN_MEMBER        = java_lang_invoke_MemberName::MN_HIDDEN_MEMBER,\n@@ -1006,0 +1007,1 @@\n+    template(java_lang_invoke_MemberName,MN_HIDDEN_MEMBER) \\\n","filename":"src\/hotspot\/share\/prims\/methodHandles.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -83,1 +83,1 @@\n-JavaFrameStream::JavaFrameStream(JavaThread* thread, jlong mode, Handle cont_scope, Handle cont)\n+JavaFrameStream::JavaFrameStream(JavaThread* thread, jint mode, Handle cont_scope, Handle cont)\n@@ -157,2 +157,2 @@\n-\/\/   frames_array     Buffer to store Class or StackFrame in, starting at start_index.\n-\/\/                    frames array is a Class<?>[] array when only getting caller\n+\/\/   frames_array     Buffer to store stack frame information in, starting at start_index.\n+\/\/                    frames array is a ClassFrameInfo[] array when only getting caller\n@@ -165,1 +165,1 @@\n-int StackWalk::fill_in_frames(jlong mode, BaseFrameStream& stream,\n+int StackWalk::fill_in_frames(jint mode, BaseFrameStream& stream,\n@@ -189,1 +189,2 @@\n-    if (!ShowHiddenFrames && (skip_hidden_frames(mode) || get_caller_class(mode))) {\n+    LogTarget(Debug, stackwalk) lt;\n+    if (!ShowHiddenFrames && skip_hidden_frames(mode)) {\n@@ -191,1 +192,0 @@\n-        LogTarget(Debug, stackwalk) lt;\n@@ -195,1 +195,1 @@\n-          ls.print(\"  hidden method: \");\n+          ls.print(\"  skip hidden method: \");\n@@ -199,0 +199,1 @@\n+\n@@ -206,1 +207,0 @@\n-    LogTarget(Debug, stackwalk) lt;\n@@ -215,7 +215,0 @@\n-    if (!need_method_info(mode) && get_caller_class(mode) &&\n-          index == start_index && method->caller_sensitive()) {\n-      ResourceMark rm(THREAD);\n-      THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(),\n-        err_msg(\"StackWalker::getCallerClass called from @CallerSensitive '%s' method\",\n-                method->external_name()));\n-    }\n@@ -259,1 +252,3 @@\n-    frames_array->obj_at_put(index, method->method_holder()->java_mirror());\n+    HandleMark hm(THREAD);\n+    Handle stackFrame(THREAD, frames_array->obj_at(index));\n+    java_lang_ClassFrameInfo::init_class(stackFrame, method);\n@@ -359,1 +354,1 @@\n-\/\/ Fill StackFrameInfo with bci and initialize memberName\n+\/\/ Fill StackFrameInfo with bci and initialize ResolvedMethodName\n@@ -408,2 +403,2 @@\n-\/\/   frames_array   Buffer to store StackFrame in, starting at start_index.\n-\/\/                  frames array is a Class<?>[] array when only getting caller\n+\/\/   frames_array   Buffer to store stack frame info in, starting at start_index.\n+\/\/                  frames array is a ClassFrameInfo[] array when only getting caller\n@@ -415,1 +410,1 @@\n-oop StackWalk::walk(Handle stackStream, jlong mode, int skip_frames, Handle cont_scope, Handle cont,\n+oop StackWalk::walk(Handle stackStream, jint mode, int skip_frames, Handle cont_scope, Handle cont,\n@@ -422,1 +417,1 @@\n-  log_debug(stackwalk)(\"Start walking: mode \" JLONG_FORMAT \" skip %d frames batch size %d\", mode, skip_frames, frame_count);\n+  log_debug(stackwalk)(\"Start walking: mode \" INT32_FORMAT_X \" skip %d frames batch size %d\", mode, skip_frames, frame_count);\n@@ -440,1 +435,0 @@\n-    assert(use_frames_array(mode), \"Bad mode for get live frame\");\n@@ -457,1 +451,1 @@\n-                               jlong mode, int skip_frames, int frame_count,\n+                               jint mode, int skip_frames, int frame_count,\n@@ -550,1 +544,1 @@\n-jint StackWalk::fetchNextBatch(Handle stackStream, jlong mode, jlong magic,\n+jint StackWalk::fetchNextBatch(Handle stackStream, jint mode, jlong magic,\n","filename":"src\/hotspot\/share\/prims\/stackwalk.cpp","additions":18,"deletions":24,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -93,1 +93,1 @@\n-  JavaFrameStream(JavaThread* thread, jlong mode, Handle cont_scope, Handle cont);\n+  JavaFrameStream(JavaThread* thread, jint mode, Handle cont_scope, Handle cont);\n@@ -145,1 +145,1 @@\n-  static int fill_in_frames(jlong mode, BaseFrameStream& stream,\n+  static int fill_in_frames(jint mode, BaseFrameStream& stream,\n@@ -150,4 +150,1 @@\n-  static inline bool get_caller_class(jlong mode) {\n-    return (mode & JVM_STACKWALK_GET_CALLER_CLASS) != 0;\n-  }\n-  static inline bool skip_hidden_frames(jlong mode) {\n+  static inline bool skip_hidden_frames(jint mode) {\n@@ -156,1 +153,1 @@\n-  static inline bool live_frame_info(jlong mode) {\n+  static inline bool live_frame_info(jint mode) {\n@@ -161,5 +158,2 @@\n-  static inline bool need_method_info(jlong mode) {\n-    return (mode & JVM_STACKWALK_FILL_CLASS_REFS_ONLY) == 0;\n-  }\n-  static inline bool use_frames_array(jlong mode) {\n-    return (mode & JVM_STACKWALK_FILL_CLASS_REFS_ONLY) == 0;\n+  static inline bool need_method_info(jint mode) {\n+    return (mode & JVM_STACKWALK_CLASS_INFO_ONLY) == 0;\n@@ -167,1 +161,2 @@\n-  static oop walk(Handle stackStream, jlong mode, int skip_frames, Handle cont_scope, Handle cont,\n+\n+  static oop walk(Handle stackStream, jint mode, int skip_frames, Handle cont_scope, Handle cont,\n@@ -172,1 +167,1 @@\n-                             jlong mode, int skip_frames, int frame_count,\n+                             jint mode, int skip_frames, int frame_count,\n@@ -175,1 +170,1 @@\n-  static jint fetchNextBatch(Handle stackStream, jlong mode, jlong magic,\n+  static jint fetchNextBatch(Handle stackStream, jint mode, jlong magic,\n","filename":"src\/hotspot\/share\/prims\/stackwalk.hpp","additions":10,"deletions":15,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -0,0 +1,135 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package java.lang;\n+\n+import jdk.internal.access.JavaLangInvokeAccess;\n+import jdk.internal.access.SharedSecrets;\n+import java.lang.StackWalker.StackFrame;\n+\n+\/**\n+ * ClassFrameInfo is an implementation of StackFrame that contains only\n+ * the class name and declaring class.\n+ *\n+ * Methods that access the method information such as method name,\n+ * will throw UnsupportedOperationException.\n+ *\n+ * @see StackWalker.Option#DROP_METHOD_INFO\n+ *\/\n+class ClassFrameInfo implements StackFrame {\n+    static final JavaLangInvokeAccess JLIA = SharedSecrets.getJavaLangInvokeAccess();\n+\n+    Object classOrMemberName;    \/\/ Class or ResolvedMemberName initialized by VM\n+    int flags;                   \/\/ updated by VM to set hidden and caller-sensitive bits\n+\n+    \/*\n+     * Construct an empty ClassFrameInfo object that will be filled by the VM\n+     * during stack walking.\n+     *\n+     * @see StackStreamFactory.AbstractStackWalker#callStackWalk\n+     * @see StackStreamFactory.AbstractStackWalker#fetchStackFrames\n+     *\/\n+    ClassFrameInfo(StackWalker walker) {\n+        this.flags = walker.retainClassRef ? RETAIN_CLASS_REF_BIT : 0;\n+    }\n+\n+    \/\/ package-private called by StackStreamFactory to skip\n+    \/\/ the capability check\n+    Class<?> declaringClass() {\n+        return (Class<?>) classOrMemberName;\n+    }\n+\n+    boolean isCallerSensitive() {\n+        return JLIA.isCallerSensitive(flags & MEMBER_INFO_FLAGS);\n+    }\n+\n+    boolean isHidden() {\n+        return JLIA.isHiddenMember(flags & MEMBER_INFO_FLAGS);\n+    }\n+\n+    \/\/ ----- implementation of StackFrame methods\n+\n+    @Override\n+    public String getClassName() {\n+        return declaringClass().getName();\n+    }\n+\n+    @Override\n+    public Class<?> getDeclaringClass() {\n+        ensureRetainClassRefEnabled();\n+        return declaringClass();\n+    }\n+\n+    @Override\n+    public String getMethodName() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public int getByteCodeIndex() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public String getFileName() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public int getLineNumber() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public boolean isNativeMethod() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public StackTraceElement toStackTraceElement() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public String toString() {\n+        String tags = isHidden() ? \" hidden\" : \"\";\n+        if (isCallerSensitive()) {\n+            tags += \" caller sensitive\";\n+        }\n+        return declaringClass().getName() + \" \" + tags;\n+    }\n+\n+    private static final int MEMBER_INFO_FLAGS = 0x00FFFFFF;\n+    private static final int RETAIN_CLASS_REF_BIT = 0x08000000; \/\/ retainClassRef\n+\n+    boolean retainClassRef() {\n+        return (flags & RETAIN_CLASS_REF_BIT) == RETAIN_CLASS_REF_BIT;\n+    }\n+\n+    void ensureRetainClassRefEnabled() {\n+        if (!retainClassRef()) {\n+            throw new UnsupportedOperationException(\"No access to RETAIN_CLASS_REFERENCE\");\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ClassFrameInfo.java","additions":135,"deletions":0,"binary":false,"changes":135,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,2 +27,0 @@\n-import jdk.internal.access.JavaLangInvokeAccess;\n-import jdk.internal.access.SharedSecrets;\n@@ -31,1 +29,0 @@\n-import java.lang.StackWalker.StackFrame;\n@@ -33,0 +30,1 @@\n+import java.lang.reflect.Modifier;\n@@ -34,7 +32,9 @@\n-class StackFrameInfo implements StackFrame {\n-    private static final JavaLangInvokeAccess JLIA =\n-        SharedSecrets.getJavaLangInvokeAccess();\n-\n-    private final boolean retainClassRef;\n-    private Object memberName;    \/\/ MemberName initialized by VM\n-    private int bci;              \/\/ initialized by VM to >= 0\n+\/**\n+ * StackFrameInfo is an implementation of StackFrame that contains the\n+ * class and method information.  This is used by stack walker configured\n+ * without StackWalker.Option#DROP_METHOD_INFO.\n+ *\/\n+class StackFrameInfo extends ClassFrameInfo {\n+    private String name;\n+    private Object type;          \/\/ String or MethodType\n+    private int bci;              \/\/ set by VM to >= 0\n@@ -52,2 +52,1 @@\n-        this.retainClassRef = walker.retainClassRef;\n-        this.memberName = JLIA.newMemberName();\n+        super(walker);\n@@ -59,1 +58,1 @@\n-        return JLIA.getDeclaringClass(memberName);\n+        return JLIA.getDeclaringClass(classOrMemberName);\n@@ -69,6 +68,0 @@\n-    @Override\n-    public Class<?> getDeclaringClass() {\n-        ensureRetainClassRefEnabled();\n-        return declaringClass();\n-    }\n-\n@@ -77,1 +70,5 @@\n-        return JLIA.getName(memberName);\n+        if (name == null) {\n+            expandStackFrameInfo();\n+            assert name != null;\n+        }\n+        return name;\n@@ -83,1 +80,17 @@\n-        return JLIA.getMethodType(memberName);\n+\n+        if (type == null) {\n+            expandStackFrameInfo();\n+            assert type != null;\n+        }\n+\n+        if (type instanceof MethodType mt) {\n+            return mt;\n+        }\n+\n+        \/\/ type is not a MethodType yet.  Convert it thread-safely.\n+        synchronized (this) {\n+            if (type instanceof String sig) {\n+                type = JLIA.getMethodType(sig, declaringClass().getClassLoader());\n+            }\n+        }\n+        return (MethodType)type;\n@@ -86,0 +99,3 @@\n+    \/\/ expand the name and type field of StackFrameInfo\n+    private native void expandStackFrameInfo();\n+\n@@ -88,1 +104,1 @@\n-        return JLIA.getMethodDescriptor(memberName);\n+        return getMethodType().descriptorString();\n@@ -117,1 +133,1 @@\n-        return JLIA.isNative(memberName);\n+        return Modifier.isNative(flags);\n@@ -142,6 +158,0 @@\n-\n-    private void ensureRetainClassRefEnabled() {\n-        if (!retainClassRef) {\n-            throw new UnsupportedOperationException(\"No access to RETAIN_CLASS_REFERENCE\");\n-        }\n-    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StackFrameInfo.java","additions":40,"deletions":30,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,1 @@\n+import java.lang.reflect.Array;\n@@ -35,0 +36,1 @@\n+import java.util.Arrays;\n@@ -77,2 +79,1 @@\n-    @Native private static final int FILL_CLASS_REFS_ONLY      = 0x2;\n-    @Native private static final int GET_CALLER_CLASS          = 0x4;\n+    @Native private static final int CLASS_INFO_ONLY           = 0x2;\n@@ -81,0 +82,1 @@\n+\n@@ -92,1 +94,1 @@\n-        if (walker.hasLocalsOperandsOption())\n+        if (walker.hasLocalsOperandsOption()) {\n@@ -94,1 +96,1 @@\n-        else\n+        } else {\n@@ -96,0 +98,1 @@\n+        }\n@@ -111,0 +114,11 @@\n+    private static int toStackWalkMode(StackWalker walker, int mode) {\n+        int newMode = mode;\n+        if (walker.hasOption(Option.DROP_METHOD_INFO))\n+            newMode |= CLASS_INFO_ONLY;\n+        if (walker.hasOption(Option.SHOW_HIDDEN_FRAMES))\n+            newMode |= SHOW_HIDDEN_FRAMES;\n+        if (walker.hasLocalsOperandsOption())\n+            newMode |= FILL_LIVE_STACK_FRAMES;\n+        return newMode;\n+    }\n+\n@@ -127,1 +141,1 @@\n-        protected final long mode;\n+        protected final int mode;\n@@ -140,1 +154,1 @@\n-            this.mode = toStackWalkMode(walker, mode);\n+            this.mode = mode;\n@@ -154,10 +168,0 @@\n-        private int toStackWalkMode(StackWalker walker, int mode) {\n-            int newMode = mode;\n-            if (walker.hasOption(Option.SHOW_HIDDEN_FRAMES) &&\n-                    (mode & FILL_CLASS_REFS_ONLY) != FILL_CLASS_REFS_ONLY)\n-                newMode |= SHOW_HIDDEN_FRAMES;\n-            if (walker.hasLocalsOperandsOption())\n-                newMode |= FILL_LIVE_STACK_FRAMES;\n-            return newMode;\n-        }\n-\n@@ -453,1 +457,1 @@\n-         * @param frames      Either a Class<?> array, if mode is {@link #FILL_CLASS_REFS_ONLY}\n+         * @param frames      Either a {@link ClassFrameInfo} array, if mode is {@link #CLASS_INFO_ONLY}\n@@ -457,1 +461,1 @@\n-        private native R callStackWalk(long mode, int skipframes,\n+        private native R callStackWalk(int mode, int skipframes,\n@@ -469,1 +473,1 @@\n-         * @param frames      Either a Class<?> array, if mode is {@link #FILL_CLASS_REFS_ONLY}\n+         * @param frames      Either a {@link ClassFrameInfo} array, if mode is {@link #CLASS_INFO_ONLY}\n@@ -474,1 +478,1 @@\n-        private native int fetchStackFrames(long mode, long anchor,\n+        private native int fetchStackFrames(int mode, long anchor,\n@@ -486,1 +490,1 @@\n-    static class StackFrameTraverser<T> extends AbstractStackWalker<T, StackFrameInfo>\n+    static class StackFrameTraverser<T> extends AbstractStackWalker<T, StackFrame>\n@@ -494,54 +498,0 @@\n-        final class StackFrameBuffer extends FrameBuffer<StackFrameInfo> {\n-            private StackFrameInfo[] stackFrames;\n-            StackFrameBuffer(int initialBatchSize) {\n-                super(initialBatchSize);\n-\n-                this.stackFrames = new StackFrameInfo[initialBatchSize];\n-                for (int i = START_POS; i < initialBatchSize; i++) {\n-                    stackFrames[i] = new StackFrameInfo(walker);\n-                }\n-            }\n-\n-            @Override\n-            StackFrameInfo[] frames() {\n-                return stackFrames;\n-            }\n-\n-            @Override\n-            void resize(int startIndex, int elements) {\n-                if (!isActive())\n-                    throw new IllegalStateException(\"inactive frame buffer can't be resized\");\n-\n-                assert startIndex == START_POS :\n-                       \"bad start index \" + startIndex + \" expected \" + START_POS;\n-\n-                int size = startIndex+elements;\n-                if (stackFrames.length < size) {\n-                    StackFrameInfo[] newFrames = new StackFrameInfo[size];\n-                    \/\/ copy initial magic...\n-                    System.arraycopy(stackFrames, 0, newFrames, 0, startIndex);\n-                    stackFrames = newFrames;\n-                }\n-                for (int i = startIndex; i < size; i++) {\n-                    stackFrames[i] = new StackFrameInfo(walker);\n-                }\n-                currentBatchSize = size;\n-            }\n-\n-            @Override\n-            StackFrameInfo nextStackFrame() {\n-                if (isEmpty()) {\n-                    throw new NoSuchElementException(\"origin=\" + origin + \" fence=\" + fence);\n-                }\n-\n-                StackFrameInfo frame = stackFrames[origin];\n-                origin++;\n-                return frame;\n-            }\n-\n-            @Override\n-            final Class<?> at(int index) {\n-                return stackFrames[index].declaringClass();\n-            }\n-        }\n-\n@@ -552,6 +502,1 @@\n-            this(walker, function, DEFAULT_MODE);\n-        }\n-        StackFrameTraverser(StackWalker walker,\n-                            Function<? super Stream<StackFrame>, ? extends T> function,\n-                            int mode) {\n-            super(walker, mode);\n+            super(walker, toStackWalkMode(walker, DEFAULT_MODE));\n@@ -570,1 +515,1 @@\n-            StackFrameInfo frame = frameBuffer.nextStackFrame();\n+            StackFrame frame = frameBuffer.nextStackFrame();\n@@ -587,1 +532,3 @@\n-            this.frameBuffer = new StackFrameBuffer(getNextBatchSize());\n+            this.frameBuffer = walker.hasOption(Option.DROP_METHOD_INFO)\n+                                    ? new ClassFrameBuffer(walker, getNextBatchSize())\n+                                    : new StackFrameBuffer<>(StackFrameInfo.class, walker, getNextBatchSize());\n@@ -654,0 +601,97 @@\n+    static class StackFrameBuffer<T extends ClassFrameInfo> extends FrameBuffer<T> {\n+        final StackWalker walker;\n+        private final Class<T> type;\n+        private final Constructor<T> ctor;\n+        private T[] stackFrames;\n+        StackFrameBuffer(Class<T> type, StackWalker walker, int initialBatchSize) {\n+            super(initialBatchSize);\n+            this.walker = walker;\n+            this.type = type;\n+            try {\n+                this.ctor = type.getDeclaredConstructor(StackWalker.class);\n+            } catch (NoSuchMethodException e) {\n+                throw new InternalError(e);\n+            }\n+            this.stackFrames = fill(allocateArray(initialBatchSize), START_POS, initialBatchSize);\n+        }\n+\n+        @Override\n+        T[] frames() {\n+            return stackFrames;\n+        }\n+\n+        @SuppressWarnings(\"unchecked\")\n+        T[] allocateArray(int size) {\n+            return (T[])Array.newInstance(type, size);\n+        }\n+\n+        T[] fill(T[] array, int startIndex, int size) {\n+            try {\n+                for (int i = startIndex; i < size; i++) {\n+                    array[i] = ctor.newInstance(walker);\n+                }\n+            } catch (ReflectiveOperationException e) {\n+                throw new InternalError(e);\n+            }\n+            return array;\n+        }\n+\n+        @Override\n+        void resize(int startIndex, int elements) {\n+            if (!isActive())\n+                throw new IllegalStateException(\"inactive frame buffer can't be resized\");\n+\n+            assert startIndex == START_POS :\n+                    \"bad start index \" + startIndex + \" expected \" + START_POS;\n+\n+            int size = startIndex+elements;\n+            if (stackFrames.length < size) {\n+                T[] newFrames = allocateArray(size);\n+                \/\/ copy initial magic...\n+                System.arraycopy(stackFrames, 0, newFrames, 0, startIndex);\n+                stackFrames = newFrames;\n+            }\n+            fill(stackFrames, startIndex, size);\n+            currentBatchSize = size;\n+        }\n+\n+        @Override\n+        T nextStackFrame() {\n+            if (isEmpty()) {\n+                throw new NoSuchElementException(\"origin=\" + origin + \" fence=\" + fence);\n+            }\n+\n+            T frame = stackFrames[origin];\n+            origin++;\n+            return frame;\n+        }\n+\n+        @Override\n+        final Class<?> at(int index) {\n+            return stackFrames[index].declaringClass();\n+        }\n+    }\n+\n+    \/*\n+     * Buffer for ClassFrameInfo.  It allocates ClassFrameInfo via bytecode\n+     * invocation instead of via core reflection to minimize the overhead.\n+     *\/\n+    static class ClassFrameBuffer extends StackFrameBuffer<ClassFrameInfo> {\n+        ClassFrameBuffer(StackWalker walker, int initialBatchSize) {\n+            super(ClassFrameInfo.class, walker, initialBatchSize);\n+        }\n+\n+        @Override\n+        ClassFrameInfo[] allocateArray(int size) {\n+            return new ClassFrameInfo[size];\n+        }\n+\n+        @Override\n+        ClassFrameInfo[] fill(ClassFrameInfo[] array, int startIndex, int size) {\n+            for (int i = startIndex; i < size; i++) {\n+                array[i] = new ClassFrameInfo(walker);\n+            }\n+            return array;\n+        }\n+    }\n+\n@@ -658,1 +702,1 @@\n-    static final class CallerClassFinder extends AbstractStackWalker<Integer, Class<?>> {\n+    static final class CallerClassFinder extends AbstractStackWalker<Integer, ClassFrameInfo> {\n@@ -666,46 +710,1 @@\n-            super(walker, FILL_CLASS_REFS_ONLY|GET_CALLER_CLASS);\n-        }\n-\n-        static final class ClassBuffer extends FrameBuffer<Class<?>> {\n-            Class<?>[] classes;      \/\/ caller class for fast path\n-            ClassBuffer(int batchSize) {\n-                super(batchSize);\n-                classes = new Class<?>[batchSize];\n-            }\n-\n-            @Override\n-            Class<?>[] frames() { return classes;}\n-\n-            @Override\n-            final Class<?> at(int index) { return classes[index];}\n-\n-            \/\/ ------ subclass may override the following methods -------\n-            \/**\n-             * Resizes the buffers for VM to fill in the next batch of stack frames.\n-             * The next batch will start at the given startIndex with the maximum number\n-             * of elements.\n-             *\n-             * <p> Subclass may override this method to manage the allocated buffers.\n-             *\n-             * @param startIndex the start index for the first frame of the next batch to fill in.\n-             * @param elements the number of elements for the next batch to fill in.\n-             *\n-             *\/\n-            @Override\n-            void resize(int startIndex, int elements) {\n-                if (!isActive())\n-                    throw new IllegalStateException(\"inactive frame buffer can't be resized\");\n-\n-                assert startIndex == START_POS :\n-                       \"bad start index \" + startIndex + \" expected \" + START_POS;\n-\n-                int size = startIndex+elements;\n-                if (classes.length < size) {\n-                    \/\/ copy the elements in classes array to the newly allocated one.\n-                    \/\/ classes[0] is a Thread object\n-                    Class<?>[] prev = classes;\n-                    classes = new Class<?>[size];\n-                    System.arraycopy(prev, 0, classes, 0, startIndex);\n-                }\n-                currentBatchSize = size;\n-            }\n+            super(walker, toStackWalkMode(walker, CLASS_INFO_ONLY));\n@@ -723,9 +722,17 @@\n-            Class<?>[] frames = new Class<?>[2];\n-            \/\/ skip the API calling this getCallerClass method\n-            \/\/ 0: StackWalker::getCallerClass\n-            \/\/ 1: caller-sensitive method\n-            \/\/ 2: caller class\n-            while (n < 2 && (caller = nextFrame()) != null) {\n-                if (isMethodHandleFrame(caller)) { continue; }\n-                if (isReflectionFrame(caller)) { continue; }\n-                frames[n++] = caller;\n+            ClassFrameInfo curFrame = null;\n+            \/\/ StackWalker::getCallerClass method\n+            \/\/ 0: caller-sensitive method\n+            \/\/ 1: caller class\n+            ClassFrameInfo[] frames = new ClassFrameInfo[2];\n+            while (n < 2 && hasNext() && (curFrame = frameBuffer.nextStackFrame()) != null) {\n+                caller = curFrame.declaringClass();\n+                if (curFrame.isHidden() || isReflectionFrame(caller) || isMethodHandleFrame(caller)) {\n+                    if (isDebug)\n+                        System.err.println(\"  skip: frame \" + frameBuffer.getIndex() + \" \" + curFrame);\n+                    continue;\n+                }\n+                frames[n++] = curFrame;\n+            }\n+            if (isDebug) {\n+                System.err.println(\"0: \" + frames[0]);\n+                System.err.println(\"1: \" + frames[1]);\n@@ -734,1 +741,5 @@\n-                throw new IllegalCallerException(\"no caller frame\");\n+                throw new IllegalCallerException(\"no caller frame: \" + Arrays.toString(frames));\n+            }\n+            if (frames[0].isCallerSensitive()) {\n+                throw new UnsupportedOperationException(\"StackWalker::getCallerClass called from @CallerSensitive \"\n+                        + Arrays.toString(frames));\n@@ -741,1 +752,1 @@\n-            this.frameBuffer = new ClassBuffer(getNextBatchSize());\n+            this.frameBuffer = new ClassFrameBuffer(walker, getNextBatchSize());\n@@ -759,55 +770,0 @@\n-        \/\/ VM will fill in all method info and live stack info directly in StackFrameInfo\n-        final class LiveStackFrameBuffer extends FrameBuffer<LiveStackFrameInfo> {\n-            private LiveStackFrameInfo[] stackFrames;\n-            LiveStackFrameBuffer(int initialBatchSize) {\n-                super(initialBatchSize);\n-                this.stackFrames = new LiveStackFrameInfo[initialBatchSize];\n-                for (int i = START_POS; i < initialBatchSize; i++) {\n-                    stackFrames[i] = new LiveStackFrameInfo(walker);\n-                }\n-            }\n-\n-            @Override\n-            LiveStackFrameInfo[] frames() {\n-                return stackFrames;\n-            }\n-\n-            @Override\n-            void resize(int startIndex, int elements) {\n-                if (!isActive()) {\n-                    throw new IllegalStateException(\"inactive frame buffer can't be resized\");\n-                }\n-                assert startIndex == START_POS :\n-                       \"bad start index \" + startIndex + \" expected \" + START_POS;\n-\n-                int size = startIndex + elements;\n-                if (stackFrames.length < size) {\n-                    LiveStackFrameInfo[] newFrames = new LiveStackFrameInfo[size];\n-                    \/\/ copy initial magic...\n-                    System.arraycopy(stackFrames, 0, newFrames, 0, startIndex);\n-                    stackFrames = newFrames;\n-                }\n-\n-                for (int i = startIndex(); i < size; i++) {\n-                    stackFrames[i] = new LiveStackFrameInfo(walker);\n-                }\n-\n-                currentBatchSize = size;\n-            }\n-\n-            @Override\n-            LiveStackFrameInfo nextStackFrame() {\n-                if (isEmpty()) {\n-                    throw new NoSuchElementException(\"origin=\" + origin + \" fence=\" + fence);\n-                }\n-\n-                LiveStackFrameInfo frame = stackFrames[origin];\n-                origin++;\n-                return frame;\n-            }\n-\n-            @Override\n-            final Class<?> at(int index) {\n-                return stackFrames[index].declaringClass();\n-            }\n-        }\n@@ -817,1 +773,1 @@\n-            super(walker, function, DEFAULT_MODE);\n+            super(walker, function);\n@@ -822,1 +778,1 @@\n-            this.frameBuffer = new LiveStackFrameBuffer(getNextBatchSize());\n+            this.frameBuffer = new StackFrameBuffer<>(LiveStackFrameInfo.class, walker, getNextBatchSize());\n@@ -854,1 +810,1 @@\n-         * mode is {@link #FILL_CLASS_REFS_ONLY}, or an array of\n+         * mode is {@link #CLASS_INFO_ONLY}, or an array of\n@@ -1024,1 +980,1 @@\n-                c.getName().startsWith(\"java.util.stream.\");\n+                c.getPackageName().equals(\"java.util.stream\");\n@@ -1030,1 +986,1 @@\n-        return c.getName().startsWith(\"java.lang.invoke.\");\n+        return c.getPackageName().equals(\"java.lang.invoke\");\n@@ -1034,1 +990,0 @@\n-        \/\/ ## should filter all @Hidden frames?\n@@ -1038,2 +993,1 @@\n-               ConstructorAccessor.class.isAssignableFrom(c) ||\n-               c.getName().startsWith(\"java.lang.invoke.LambdaForm\");\n+               ConstructorAccessor.class.isAssignableFrom(c);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StackStreamFactory.java","additions":159,"deletions":205,"binary":false,"changes":364,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,7 +52,9 @@\n- * <p> The {@linkplain Option <em>stack walking options<\/em>} of a\n- * {@code StackWalker} determines the information of\n- * {@link StackFrame StackFrame} objects to be returned.\n- * By default, stack frames of the reflection API and implementation\n- * classes are {@linkplain Option#SHOW_HIDDEN_FRAMES hidden}\n- * and {@code StackFrame}s have the class name and method name\n- * available but not the {@link StackFrame#getDeclaringClass() Class reference}.\n+ * <p> {@linkplain Option <em>Stack walker options<\/em>} configure the stack frame\n+ * information obtained by a {@code StackWalker}.\n+ * By default, the class name and method information are collected but\n+ * not the {@link StackFrame#getDeclaringClass() Class reference}.\n+ * The method information can be dropped via the {@link Option#DROP_METHOD_INFO\n+ * DROP_METHOD_INFO} option. The {@code Class} object can be retained for\n+ * access via the {@link Option#RETAIN_CLASS_REFERENCE RETAIN_CLASS_REFERENCE} option.\n+ * Stack frames of the reflection API and implementation classes are\n+ * {@linkplain Option#SHOW_HIDDEN_FRAMES hidden} by default.\n@@ -69,3 +71,3 @@\n- * <p>1. To find the first caller filtering a known list of implementation class:\n- * <pre>{@code\n- *     StackWalker walker = StackWalker.getInstance(Option.RETAIN_CLASS_REFERENCE);\n+ * <p>1. To find the first caller filtering out a known list of implementation class:\n+ * {@snippet lang=\"java\" :\n+ *     StackWalker walker = StackWalker.getInstance(Set.of(Option.DROP_METHOD_INFO, Option.RETAIN_CLASS_REFERENCE));\n@@ -73,4 +75,4 @@\n- *         s.map(StackFrame::getDeclaringClass)\n- *          .filter(interestingClasses::contains)\n- *          .findFirst());\n- * }<\/pre>\n+ *             s.map(StackFrame::getDeclaringClass)\n+ *              .filter(Predicate.not(implClasses::contains))\n+ *              .findFirst());\n+ * }\n@@ -79,4 +81,3 @@\n- * <pre>{@code\n- *     List<StackFrame> stack = StackWalker.getInstance().walk(s ->\n- *         s.limit(10).collect(Collectors.toList()));\n- * }<\/pre>\n+ * {@snippet lang=\"java\" :\n+ *     List<StackFrame> stack = StackWalker.getInstance().walk(s -> s.limit(10).toList());\n+ * }\n@@ -96,3 +97,11 @@\n-     * <p> The {@link #getDeclaringClass()} method may be unsupported as determined\n-     * by the {@linkplain Option stack walking options} of a {@linkplain\n-     * StackWalker stack walker}.\n+     * <p> {@linkplain Option <em>Stack walker options<\/em>} configure the stack\n+     * frame information obtained by a {@code StackWalker}.\n+     * If the stack walker is configured with {@link Option#DROP_METHOD_INFO\n+     * DROP_METHOD_INFO} option, method information such as\n+     * the {@linkplain StackFrame#getMethodName() method name},\n+     * the {@linkplain StackFrame#getLineNumber() line number},\n+     * the {@linkplain StackFrame#getByteCodeIndex() bytecode index}, etc\n+     * will be dropped.\n+     * If the stack walker is configured with {@link Option#RETAIN_CLASS_REFERENCE\n+     * RETAIN_CLASS_REFERENCE} option, the {@link #getDeclaringClass() Class} object\n+     * will be retained for access.\n@@ -101,1 +110,1 @@\n-     * @jvms 2.6\n+     * @jvms 2.6 Frames\n@@ -105,5 +114,2 @@\n-         * Gets the <a href=\"ClassLoader.html#binary-name\">binary name<\/a>\n-         * of the declaring class of the method represented by this stack frame.\n-         *\n-         * @return the binary name of the declaring class of the method\n-         *         represented by this stack frame\n+         * {@return the {@linkplain ClassLoader##binary-name binary name}\n+         * of the declaring class of the method represented by this stack frame}\n@@ -116,2 +122,4 @@\n-         * Gets the name of the method represented by this stack frame.\n-         * @return the name of the method represented by this stack frame\n+         * {@return the name of the method represented by this stack frame}\n+         *\n+         * @throws UnsupportedOperationException if the {@code StackWalker} is configured\n+         *         with {@link Option#DROP_METHOD_INFO DROP_METHOD_INFO} option\n@@ -122,5 +130,2 @@\n-         * Gets the declaring {@code Class} for the method represented by\n-         * this stack frame.\n-         *\n-         * @return the declaring {@code Class} of the method represented by\n-         * this stack frame\n+         * {@return the declaring {@code Class} for the method represented by\n+         * this stack frame}\n@@ -128,3 +133,2 @@\n-         * @throws UnsupportedOperationException if this {@code StackWalker}\n-         *         is not configured with {@link Option#RETAIN_CLASS_REFERENCE\n-         *         Option.RETAIN_CLASS_REFERENCE}.\n+         * @throws UnsupportedOperationException if the {@code StackWalker} is configured\n+         *         without {@link Option#RETAIN_CLASS_REFERENCE RETAIN_CLASS_REFERENCE} option\n@@ -141,1 +145,1 @@\n-         * @return the {@code MethodType} for this stack frame\n+         * @return the {@code MethodType} of the method represented by this stack frame\n@@ -143,3 +147,3 @@\n-         * @throws UnsupportedOperationException if this {@code StackWalker}\n-         *         is not configured with {@link Option#RETAIN_CLASS_REFERENCE\n-         *         Option.RETAIN_CLASS_REFERENCE}.\n+         * @throws UnsupportedOperationException if the {@code StackWalker} is configured\n+         *         with {@link Option#DROP_METHOD_INFO DROP_METHOD_INFO} option or\n+         *         without {@link Option#RETAIN_CLASS_REFERENCE RETAIN_CLASS_REFERENCE} option\n@@ -164,0 +168,3 @@\n+         * @throws UnsupportedOperationException if the {@code StackWalker} is configured\n+         *         with {@link Option#DROP_METHOD_INFO DROP_METHOD_INFO} option\n+         *\n@@ -185,0 +192,3 @@\n+         * @throws UnsupportedOperationException if the {@code StackWalker} is configured\n+         *         with {@link Option#DROP_METHOD_INFO DROP_METHOD_INFO} option\n+         *\n@@ -201,0 +211,3 @@\n+         * @throws UnsupportedOperationException if the {@code StackWalker} is configured\n+         *         with {@link Option#DROP_METHOD_INFO DROP_METHOD_INFO} option\n+         *\n@@ -216,0 +229,3 @@\n+         * @throws UnsupportedOperationException if the {@code StackWalker} is configured\n+         *         with {@link Option#DROP_METHOD_INFO DROP_METHOD_INFO} option\n+         *\n@@ -221,2 +237,2 @@\n-         * Returns {@code true} if the method containing the execution point\n-         * represented by this stack frame is a native method.\n+         * {@return {@code true} if the method containing the execution point\n+         * represented by this stack frame is a native method}\n@@ -224,2 +240,2 @@\n-         * @return {@code true} if the method containing the execution point\n-         *         represented by this stack frame is a native method.\n+         * @throws UnsupportedOperationException if the {@code StackWalker} is configured\n+         *         with {@link Option#DROP_METHOD_INFO DROP_METHOD_INFO} option\n@@ -230,1 +246,1 @@\n-         * Gets a {@code StackTraceElement} for this stack frame.\n+         * {@return {@code StackTraceElement} for this stack frame}\n@@ -232,1 +248,2 @@\n-         * @return {@code StackTraceElement} for this stack frame.\n+         * @throws UnsupportedOperationException if the {@code StackWalker} is configured\n+         *         with {@link Option#DROP_METHOD_INFO DROP_METHOD_INFO} option\n@@ -253,0 +270,15 @@\n+        \/**\n+         * Drops the method information from {@code StackFrame}s\n+         * walked by this {@code StackWalker}.\n+         *\n+         * <p> A {@code StackWalker} configured with this option will drop\n+         * the {@linkplain StackFrame#getMethodName() method name},\n+         * the {@linkplain StackFrame#getMethodType() method type},\n+         * the {@linkplain StackFrame#getLineNumber() line number},\n+         * the {@linkplain StackFrame#getByteCodeIndex() bytecode index},\n+         * the {@linkplain StackFrame#getFileName() source file name} and\n+         * {@linkplain StackFrame#isNativeMethod() native method or not}.\n+         *\n+         * @since 22\n+         *\/\n+        DROP_METHOD_INFO,\n@@ -322,18 +354,0 @@\n-    \/**\n-     * Returns a {@code StackWalker} instance.\n-     *\n-     * <p> This {@code StackWalker} is configured to skip all\n-     * {@linkplain Option#SHOW_HIDDEN_FRAMES hidden frames} and\n-     * no {@linkplain Option#RETAIN_CLASS_REFERENCE class reference} is retained.\n-     *\n-     * @param contScope the continuation scope up to which (inclusive) to walk the stack\n-     *\n-     * @return a {@code StackWalker} configured to skip all\n-     * {@linkplain Option#SHOW_HIDDEN_FRAMES hidden frames} and\n-     * no {@linkplain Option#RETAIN_CLASS_REFERENCE class reference} is retained.\n-     *\n-     *\/\n-    static StackWalker getInstance(ContinuationScope contScope) {\n-        return getInstance(EnumSet.noneOf(Option.class), contScope);\n-    }\n-\n@@ -343,1 +357,0 @@\n-     *\n@@ -362,1 +375,1 @@\n-     * Returns a {@code StackWalker} instance with the given option specifying\n+     * Returns a {@code StackWalker} instance with the given {@code options} specifying\n@@ -366,23 +379,3 @@\n-     * If a security manager is present and the given {@code option} is\n-     * {@link Option#RETAIN_CLASS_REFERENCE Option.RETAIN_CLASS_REFERENCE},\n-     * it calls its {@link SecurityManager#checkPermission checkPermission}\n-     * method for {@code RuntimePermission(\"getStackWalkerWithClassReference\")}.\n-     *\n-     * @param option {@link Option stack walking option}\n-     * @param contScope the continuation scope up to which (inclusive) to walk the stack\n-     *\n-     * @return a {@code StackWalker} configured with the given option\n-     *\n-     * @throws SecurityException if a security manager exists and its\n-     *         {@code checkPermission} method denies access.\n-     *\/\n-    static StackWalker getInstance(Option option, ContinuationScope contScope) {\n-        return getInstance(EnumSet.of(Objects.requireNonNull(option)), contScope);\n-    }\n-\n-    \/**\n-     * Returns a {@code StackWalker} instance with the given {@code options} specifying\n-     * the stack frame information it can access.  If the given {@code options}\n-     * is empty, this {@code StackWalker} is configured to skip all\n-     * {@linkplain Option#SHOW_HIDDEN_FRAMES hidden frames} and no\n-     * {@linkplain Option#RETAIN_CLASS_REFERENCE class reference} is retained.\n+     * If the given {@code options} is empty, this {@code StackWalker} is\n+     * configured to skip all {@linkplain Option#SHOW_HIDDEN_FRAMES hidden frames}\n+     * and no {@linkplain Option#RETAIN_CLASS_REFERENCE class reference} is retained.\n@@ -396,1 +389,1 @@\n-     * @param options {@link Option stack walking option}\n+     * @param options {@link Option stack walking options}\n@@ -404,26 +397,1 @@\n-        return getInstance(options, null);\n-    }\n-\n-    \/**\n-     * Returns a {@code StackWalker} instance with the given {@code options} specifying\n-     * the stack frame information it can access.  If the given {@code options}\n-     * is empty, this {@code StackWalker} is configured to skip all\n-     * {@linkplain Option#SHOW_HIDDEN_FRAMES hidden frames} and no\n-     * {@linkplain Option#RETAIN_CLASS_REFERENCE class reference} is retained.\n-     *\n-     * <p>\n-     * If a security manager is present and the given {@code options} contains\n-     * {@link Option#RETAIN_CLASS_REFERENCE Option.RETAIN_CLASS_REFERENCE},\n-     * it calls its {@link SecurityManager#checkPermission checkPermission}\n-     * method for {@code RuntimePermission(\"getStackWalkerWithClassReference\")}.\n-     *\n-     * @param options {@link Option stack walking option}\n-     * @param contScope the continuation scope up to which (inclusive) to walk the stack\n-     *\n-     * @return a {@code StackWalker} configured with the given options\n-     *\n-     * @throws SecurityException if a security manager exists and its\n-     *         {@code checkPermission} method denies access.\n-     *\/\n-    static StackWalker getInstance(Set<Option> options, ContinuationScope contScope) {\n-        if (options.isEmpty() && contScope == null) {\n+        if (options.isEmpty()) {\n@@ -435,1 +403,1 @@\n-        return new StackWalker(optionSet, contScope);\n+        return new StackWalker(optionSet);\n@@ -440,4 +408,6 @@\n-     * the stack frame information it can access. If the given {@code options}\n-     * is empty, this {@code StackWalker} is configured to skip all\n-     * {@linkplain Option#SHOW_HIDDEN_FRAMES hidden frames} and no\n-     * {@linkplain Option#RETAIN_CLASS_REFERENCE class reference} is retained.\n+     * the stack frame information it can access.\n+     *\n+     * <p>\n+     * If the given {@code options} is empty, this {@code StackWalker} is\n+     * configured to skip all {@linkplain Option#SHOW_HIDDEN_FRAMES hidden frames}\n+     * and no {@linkplain Option#RETAIN_CLASS_REFERENCE class reference} is retained.\n@@ -478,6 +448,0 @@\n-    private StackWalker(EnumSet<Option> options, ContinuationScope contScope) {\n-        this(options, 0, null, contScope, null);\n-    }\n-    private StackWalker(EnumSet<Option> options, ContinuationScope contScope, Continuation continuation) {\n-        this(options, 0, null, contScope, continuation);\n-    }\n@@ -487,9 +451,0 @@\n-    private StackWalker(EnumSet<Option> options, int estimateDepth, ContinuationScope contScope) {\n-        this(options, estimateDepth, null, contScope, null);\n-    }\n-    private StackWalker(EnumSet<Option> options,\n-                        int estimateDepth,\n-                        ContinuationScope contScope,\n-                        Continuation continuation) {\n-        this(options, estimateDepth, null, contScope, continuation);\n-    }\n@@ -544,2 +499,1 @@\n-     * <blockquote>\n-     * <pre>{@code\n+     * {@snippet lang=\"java\" :\n@@ -547,4 +501,4 @@\n-     *     s.dropWhile(f -> f.getClassName().startsWith(\"com.foo.\"))\n-     *      .limit(10)\n-     *      .collect(Collectors.toList()));\n-     * }<\/pre><\/blockquote>\n+     *         s.dropWhile(f -> f.getClassName().startsWith(\"com.foo.\"))\n+     *          .limit(10)\n+     *          .toList());\n+     * }\n@@ -641,1 +595,1 @@\n-     * <pre>{@code\n+     * {@snippet lang=\"java\" :\n@@ -643,1 +597,2 @@\n-     *     private final StackWalker walker = StackWalker.getInstance(Option.RETAIN_CLASS_REFERENCE);\n+     *     private final StackWalker walker =\n+     *         StackWalker.getInstance(Set.of(Option.DROP_METHOD_INFO, Option.RETAIN_CLASS_REFERENCE));\n@@ -656,1 +611,1 @@\n-     * }<\/pre>\n+     * }\n@@ -662,1 +617,1 @@\n-     * <pre>{@code\n+     * {@snippet lang=\"java\" :\n@@ -667,1 +622,1 @@\n-     * }<\/pre>\n+     * }\n@@ -703,0 +658,4 @@\n+    static StackWalker newInstance(Set<Option> options, ContinuationScope contScope) {\n+        return newInstance(options, null, contScope);\n+    }\n+\n@@ -704,3 +663,1 @@\n-        EnumSet<Option> optionSet = toEnumSet(options);\n-        checkPermission(optionSet);\n-        return new StackWalker(optionSet, 0, extendedOption, contScope, null);\n+        return newInstance(options, extendedOption, contScope, null);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StackWalker.java","additions":109,"deletions":152,"binary":false,"changes":261,"status":"modified"},{"patch":"@@ -68,5 +68,0 @@\n-\/*non-public*\/\n-final class ResolvedMethodName {\n-    \/\/@Injected JVM_Method* vmtarget;\n-    \/\/@Injected Class<?>    vmholder;\n-}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MemberName.java","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -60,0 +60,2 @@\n+import static java.lang.invoke.MethodHandleNatives.Constants.MN_CALLER_SENSITIVE;\n+import static java.lang.invoke.MethodHandleNatives.Constants.MN_HIDDEN_MEMBER;\n@@ -1546,2 +1548,3 @@\n-            public Object newMemberName() {\n-                return new MemberName();\n+            public Class<?> getDeclaringClass(Object rmname) {\n+                ResolvedMethodName method = (ResolvedMethodName)rmname;\n+                return method.declaringClass();\n@@ -1551,8 +1554,2 @@\n-            public String getName(Object mname) {\n-                MemberName memberName = (MemberName)mname;\n-                return memberName.getName();\n-            }\n-            @Override\n-            public Class<?> getDeclaringClass(Object mname) {\n-                MemberName memberName = (MemberName)mname;\n-                return memberName.getDeclaringClass();\n+            public MethodType getMethodType(String descriptor, ClassLoader loader) {\n+                return MethodType.fromDescriptor(descriptor, loader);\n@@ -1561,4 +1558,2 @@\n-            @Override\n-            public MethodType getMethodType(Object mname) {\n-                MemberName memberName = (MemberName)mname;\n-                return memberName.getMethodType();\n+            public boolean isCallerSensitive(int flags) {\n+                return (flags & MN_CALLER_SENSITIVE) == MN_CALLER_SENSITIVE;\n@@ -1567,10 +1562,2 @@\n-            @Override\n-            public String getMethodDescriptor(Object mname) {\n-                MemberName memberName = (MemberName)mname;\n-                return memberName.getMethodDescriptor();\n-            }\n-\n-            @Override\n-            public boolean isNative(Object mname) {\n-                MemberName memberName = (MemberName)mname;\n-                return memberName.isNative();\n+            public boolean isHiddenMember(int flags) {\n+                return (flags & MN_HIDDEN_MEMBER) == MN_HIDDEN_MEMBER;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleImpl.java","additions":11,"deletions":24,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -119,0 +119,1 @@\n+            MN_HIDDEN_MEMBER       = 0x00400000, \/\/ members defined in a hidden class or with @Hidden\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleNatives.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,35 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.invoke;\n+\n+final class ResolvedMethodName {\n+    \/\/@Injected JVM_Method* vmtarget;\n+    private Class<?> vmholder;\n+\n+    Class<?> declaringClass() {\n+        return vmholder;\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/ResolvedMethodName.java","additions":35,"deletions":0,"binary":false,"changes":35,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -75,1 +75,1 @@\n-                () -> StackWalker.getInstance(Option.RETAIN_CLASS_REFERENCE);\n+                () -> StackWalker.getInstance(Set.of(Option.DROP_METHOD_INFO, Option.RETAIN_CLASS_REFERENCE));\n","filename":"src\/java.base\/share\/classes\/javax\/crypto\/JceSecurityManager.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -43,11 +43,1 @@\n-     * Create a new MemberName instance. Used by {@code StackFrameInfo}.\n-     *\/\n-    Object newMemberName();\n-\n-    \/**\n-     * Returns the name for the given MemberName. Used by {@code StackFrameInfo}.\n-     *\/\n-    String getName(Object mname);\n-\n-    \/**\n-     * Returns the {@code MethodType} for the given MemberName.\n+     * Returns the declaring class for the given ResolvedMethodName.\n@@ -56,1 +46,1 @@\n-    MethodType getMethodType(Object mname);\n+    Class<?> getDeclaringClass(Object rmname);\n@@ -59,1 +49,2 @@\n-     * Returns the descriptor for the given MemberName.\n+     * Returns the {@code MethodType} for the given method descriptor\n+     * and class loader.\n@@ -62,1 +53,1 @@\n-    String getMethodDescriptor(Object mname);\n+    MethodType getMethodType(String descriptor, ClassLoader loader);\n@@ -65,2 +56,1 @@\n-     * Returns {@code true} if the given MemberName is a native method.\n-     * Used by {@code StackFrameInfo}.\n+     * Returns true if the given flags has MN_CALLER_SENSITIVE flag set.\n@@ -68,1 +58,1 @@\n-    boolean isNative(Object mname);\n+    boolean isCallerSensitive(int flags);\n@@ -71,2 +61,1 @@\n-     * Returns the declaring class for the given MemberName.\n-     * Used by {@code StackFrameInfo}.\n+     * Returns true if the given flags has MN_HIDDEN_MEMBER flag set.\n@@ -74,1 +63,1 @@\n-    Class<?> getDeclaringClass(Object mname);\n+    boolean isHiddenMember(int flags);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangInvokeAccess.java","additions":9,"deletions":20,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -0,0 +1,37 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <stdio.h>\n+#include <signal.h>\n+\n+#include \"jni.h\"\n+#include \"jvm.h\"\n+\n+#include \"java_lang_StackFrameInfo.h\"\n+\n+JNIEXPORT void JNICALL Java_java_lang_StackFrameInfo_expandStackFrameInfo\n+  (JNIEnv *env, jobject obj) {\n+     JVM_ExpandStackFrameInfo(env, obj);\n+}\n","filename":"src\/java.base\/share\/native\/libjava\/StackFrameInfo.c","additions":37,"deletions":0,"binary":false,"changes":37,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,1 +47,1 @@\n-   return JVM_STACKWALK_FILL_CLASS_REFS_ONLY == java_lang_StackStreamFactory_FILL_CLASS_REFS_ONLY &&\n+   return JVM_STACKWALK_CLASS_INFO_ONLY == java_lang_StackStreamFactory_CLASS_INFO_ONLY &&\n@@ -55,1 +55,1 @@\n- * Signature: (JILjdk\/internal\/vm\/ContinuationScope;Ljdk\/internal\/vm\/Continuation;II[Ljava\/lang\/Object;)Ljava\/lang\/Object;\n+ * Signature: (IILjdk\/internal\/vm\/ContinuationScope;Ljdk\/internal\/vm\/Continuation;II[Ljava\/lang\/Object;)Ljava\/lang\/Object;\n@@ -58,1 +58,1 @@\n-  (JNIEnv *env, jobject stackstream, jlong mode, jint skipFrames, jobject contScope, jobject cont,\n+  (JNIEnv *env, jobject stackstream, jint mode, jint skipFrames, jobject contScope, jobject cont,\n@@ -68,1 +68,1 @@\n- * Signature: (JJII[Ljava\/lang\/Object;)I\n+ * Signature: (IJII[Ljava\/lang\/Object;)I\n@@ -71,1 +71,1 @@\n-  (JNIEnv *env, jobject stackstream, jlong mode, jlong anchor,\n+  (JNIEnv *env, jobject stackstream, jint mode, jlong anchor,\n","filename":"src\/java.base\/share\/native\/libjava\/StackStreamFactory.c","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n-    static Field memberName;\n+    static Field classOrMemberName;\n@@ -70,0 +70,3 @@\n+        Class<?> classFrameInfoClass = Class.forName(\"java.lang.ClassFrameInfo\");\n+        classOrMemberName = classFrameInfoClass.getDeclaredField(\"classOrMemberName\");\n+        classOrMemberName.setAccessible(true);\n@@ -71,2 +74,0 @@\n-        memberName = stackFrameInfoClass.getDeclaredField(\"memberName\");\n-        memberName.setAccessible(true);\n@@ -79,1 +80,1 @@\n-        Method ewsNI = StackWalker.class.getDeclaredMethod(\"newInstance\", Set.class, extendedOptionClass, jdk.internal.vm.ContinuationScope.class);\n+        Method ewsNI = StackWalker.class.getDeclaredMethod(\"newInstance\", Set.class, extendedOptionClass);\n@@ -87,1 +88,1 @@\n-        sw = (StackWalker) ewsNI.invoke(null, java.util.Collections.emptySet(), localsAndOperandsOption, null);\n+        sw = (StackWalker) ewsNI.invoke(null, java.util.Collections.emptySet(), localsAndOperandsOption);\n","filename":"test\/hotspot\/jtreg\/runtime\/LocalLong\/LocalLongHelper.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8157464\n+ * @bug 8157464 8210375\n@@ -32,0 +32,1 @@\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+ShowHiddenFrames csm\/jdk.test.CallerSensitiveTest\n","filename":"test\/jdk\/java\/lang\/StackWalker\/CallerSensitiveMethod\/Main.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,0 +47,1 @@\n+    private static final String REFLECTIVE_GET_CALLER_METHOD = \"getCallerClassReflectively\";\n@@ -71,0 +72,2 @@\n+        \/\/ test reflective call to StackWalker::getCallerClass\n+        cstest.invokeMethod();\n@@ -98,1 +101,10 @@\n-        Result result = (Result) method2.invoke(null);\n+        Result result2 = (Result) method2.invoke(null);\n+        checkNonCSMCaller(CallerSensitiveTest.class, result2);\n+\n+        Method method3 = java.util.CSM.class.getMethod(REFLECTIVE_GET_CALLER_METHOD);\n+        Result result3 = (Result) method3.invoke(null);\n+        checkNonCSMCaller(CallerSensitiveTest.class, result3);\n+    }\n+\n+    void invokeMethod() throws Throwable {\n+        Result result = java.util.CSM.getCallerClassReflectively();\n@@ -104,1 +116,1 @@\n-            MethodType.methodType(Class.class));\n+                                             MethodType.methodType(Class.class));\n@@ -108,3 +120,8 @@\n-            MethodType.methodType(Result.class));\n-        Result result = (Result)mh2.invokeExact();\n-        checkNonCSMCaller(CallerSensitiveTest.class, result);\n+                                             MethodType.methodType(Result.class));\n+        Result result2 = (Result)mh2.invokeExact();\n+        checkNonCSMCaller(CallerSensitiveTest.class, result2);\n+\n+        MethodHandle mh3 = lookup.findStatic(java.util.CSM.class, REFLECTIVE_GET_CALLER_METHOD,\n+                                             MethodType.methodType(Result.class));\n+        Result result3 = (Result)mh3.invokeExact();\n+        checkNonCSMCaller(CallerSensitiveTest.class, result3);\n","filename":"test\/jdk\/java\/lang\/StackWalker\/CallerSensitiveMethod\/csm\/jdk\/test\/CallerSensitiveTest.java","additions":23,"deletions":6,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import java.lang.reflect.Method;\n@@ -36,0 +37,1 @@\n+                                           DROP_METHOD_INFO,\n@@ -61,1 +63,1 @@\n-            throw new RuntimeException(\"Exception not thrown by StackWalker::getCallerClass\");\n+            throw new RuntimeException(\"Exception not thrown by StackWalker::getCallerClass. Returned \" + c2.getName());\n@@ -67,1 +69,2 @@\n-     * Returns the caller of this non-caller-sensitive method.\n+     * Returns the caller of this non-caller-sensitive method returned\n+     * by StackWalker::getCallerClass\n@@ -74,0 +77,20 @@\n+    private static final Method GET_CALLER_CLASS;\n+    static {\n+        Method m = null;\n+        try {\n+            m = StackWalker.class.getMethod(\"getCallerClass\");\n+        } catch (ReflectiveOperationException e) {\n+            throw new RuntimeException(e);\n+        }\n+        GET_CALLER_CLASS = m;\n+    }\n+\n+    \/**\n+     * Returns the caller of this non-caller-sensitive method returned\n+     * by StackWalker::getCallerClass invoked via core reflection\n+     *\/\n+    public static Result getCallerClassReflectively() throws ReflectiveOperationException {\n+        Class<?> caller = (Class<?>)GET_CALLER_CLASS.invoke(walker);\n+        return new Result(List.of(caller), dump());\n+    }\n+\n","filename":"test\/jdk\/java\/lang\/StackWalker\/CallerSensitiveMethod\/src\/java.base\/java\/util\/CSM.java","additions":26,"deletions":3,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8140450 8152893 8189291\n+ * @bug 8140450 8152893 8189291 8210375\n@@ -29,0 +29,1 @@\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+ShowHiddenFrames GetCallerClassTest\n@@ -121,0 +122,1 @@\n+            \/\/ Use reflection to call Method::invoke that invokes StackWalker::getCallerClass\n@@ -122,1 +124,2 @@\n-            Class<?> c = (Class<?>) m.invoke(stackWalker);\n+            Method invoke = Method.class.getMethod(\"invoke\", Object.class, Object[].class);\n+            Class<?> c = (Class<?>) invoke.invoke(m, new Object[] { stackWalker, null });\n","filename":"test\/jdk\/java\/lang\/StackWalker\/GetCallerClassTest.java","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8140450\n+ * @bug 8140450 8268829\n@@ -28,1 +28,1 @@\n- * @run testng SanityTest\n+ * @run junit SanityTest\n@@ -31,1 +31,0 @@\n-\n@@ -34,0 +33,2 @@\n+import java.util.stream.Stream;\n+import static java.lang.StackWalker.Option.*;\n@@ -35,1 +36,4 @@\n-import org.testng.annotations.Test;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import static org.junit.jupiter.api.Assertions.*;\n@@ -39,5 +43,6 @@\n-    public static void testNPE() {\n-        try {\n-            StackWalker sw = StackWalker.getInstance((Set<StackWalker.Option>) null);\n-            throw new RuntimeException(\"NPE expected\");\n-        } catch (NullPointerException e) {}\n+    public void testNPE() {\n+        assertThrows(NullPointerException.class, () ->\n+                StackWalker.getInstance((Set<StackWalker.Option>) null));\n+        assertThrows(NullPointerException.class, () ->\n+                StackWalker.getInstance((StackWalker.Option) null));\n+    }\n@@ -45,4 +50,2 @@\n-        try {\n-            StackWalker sw = StackWalker.getInstance((StackWalker.Option) null);\n-            throw new RuntimeException(\"NPE expected\");\n-        } catch (NullPointerException e) {}\n+    private static Stream<StackWalker> noRetainClassRef() {\n+        return Stream.of(StackWalker.getInstance(), StackWalker.getInstance(DROP_METHOD_INFO));\n@@ -51,6 +54,4 @@\n-    @Test\n-    public static void testUOE() {\n-        try {\n-            StackWalker.getInstance().getCallerClass();\n-            throw new RuntimeException(\"UOE expected\");\n-        } catch (UnsupportedOperationException expected) {}\n+    @ParameterizedTest\n+    @MethodSource(\"noRetainClassRef\")\n+    public void testUOE(StackWalker sw) {\n+        assertThrows(UnsupportedOperationException.class, () -> sw.getCallerClass());\n@@ -60,5 +61,3 @@\n-    public static void testInvalidEstimateDepth() {\n-        try {\n-            StackWalker sw = StackWalker.getInstance(Collections.emptySet(), 0);\n-            throw new RuntimeException(\"Illegal estimateDepth should throw IAE\");\n-        } catch (IllegalArgumentException e) {}\n+    public void testInvalidEstimateDepth() {\n+        assertThrows(IllegalArgumentException.class, () ->\n+                StackWalker.getInstance(Collections.emptySet(), 0));\n@@ -68,5 +67,3 @@\n-    public static void testNullFuncation() {\n-        try {\n-            StackWalker.getInstance().walk(null);\n-            throw new RuntimeException(\"NPE expected\");\n-        } catch (NullPointerException e) {}\n+    public void testNullFunction() {\n+        assertThrows(NullPointerException.class, () ->\n+                StackWalker.getInstance().walk(null));\n@@ -76,5 +73,10 @@\n-    public static void testNullConsumer() {\n-        try {\n-            StackWalker.getInstance().forEach(null);\n-            throw new RuntimeException(\"NPE expected\");\n-        } catch (NullPointerException e) {}\n+    public void testNullConsumer() {\n+        assertThrows(NullPointerException.class, () ->\n+                StackWalker.getInstance().forEach(null));\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"noRetainClassRef\")\n+    public void testUOEFromGetDeclaringClass(StackWalker sw) {\n+        assertThrows(UnsupportedOperationException.class, () ->\n+                sw.forEach(StackWalker.StackFrame::getDeclaringClass));\n@@ -83,0 +85,6 @@\n+    @ParameterizedTest\n+    @MethodSource(\"noRetainClassRef\")\n+    public void testUOEFromGetMethodType(StackWalker sw) {\n+        assertThrows(UnsupportedOperationException.class, () ->\n+                sw.forEach(StackWalker.StackFrame::getMethodType));\n+    }\n@@ -84,8 +92,3 @@\n-    @Test\n-    public static void testUOEFromGetDeclaringClass() {\n-        try {\n-            StackWalker sw = StackWalker.getInstance();\n-            sw.forEach(StackWalker.StackFrame::getDeclaringClass);\n-            throw new RuntimeException(\"UOE expected\");\n-        } catch (UnsupportedOperationException expected) {\n-        }\n+    private static Stream<StackWalker> noMethodInfo() {\n+        return Stream.of(StackWalker.getInstance(DROP_METHOD_INFO),\n+                         StackWalker.getInstance(Set.of(DROP_METHOD_INFO, RETAIN_CLASS_REFERENCE)));\n@@ -94,7 +97,17 @@\n-    @Test\n-    public static void testUOEFromGetMethodType() {\n-        try {\n-            StackWalker sw = StackWalker.getInstance();\n-            sw.forEach(StackWalker.StackFrame::getMethodType);\n-            throw new RuntimeException(\"UOE expected\");\n-        } catch (UnsupportedOperationException expected) {}\n+    @ParameterizedTest\n+    @MethodSource(\"noMethodInfo\")\n+    public void testNoMethodInfo(StackWalker sw) {\n+        assertThrows(UnsupportedOperationException.class, () ->\n+                sw.forEach(StackWalker.StackFrame::getMethodName));\n+        assertThrows(UnsupportedOperationException.class, () ->\n+                sw.forEach(StackWalker.StackFrame::getMethodType));\n+        assertThrows(UnsupportedOperationException.class, () ->\n+                sw.forEach(StackWalker.StackFrame::getDescriptor));\n+        assertThrows(UnsupportedOperationException.class, () ->\n+                sw.forEach(StackWalker.StackFrame::getByteCodeIndex));\n+        assertThrows(UnsupportedOperationException.class, () ->\n+                sw.forEach(StackWalker.StackFrame::getFileName));\n+        assertThrows(UnsupportedOperationException.class, () ->\n+                sw.forEach(StackWalker.StackFrame::isNativeMethod));\n+        assertThrows(UnsupportedOperationException.class, () ->\n+                sw.forEach(StackWalker.StackFrame::toStackTraceElement));\n","filename":"test\/jdk\/java\/lang\/StackWalker\/SanityTest.java","additions":63,"deletions":50,"binary":false,"changes":113,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -69,1 +69,1 @@\n-                  sf.getDeclaringClass().toString());\n+                  sf.getDeclaringClass().toString() + \", index: \" + index);\n@@ -87,1 +87,1 @@\n-                    \", but got: \" + sf.getClassName());\n+                    \", but got: \" + sf.getClassName() + \", index: \" + index);\n@@ -91,1 +91,1 @@\n-                    \", but got: \" + sf.getMethodName());\n+                    \", but got: \" + sf.getMethodName()  + \", index: \" + index);\n","filename":"test\/jdk\/java\/lang\/StackWalker\/StackRecorderUtil.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,1 +24,0 @@\n-import static java.lang.StackWalker.Option.*;\n@@ -29,0 +28,1 @@\n+import java.util.Set;\n@@ -32,0 +32,2 @@\n+import static java.lang.StackWalker.Option.*;\n+\n@@ -34,1 +36,1 @@\n- * @bug 8140450\n+ * @bug 8140450 8210375\n@@ -160,0 +162,13 @@\n+\n+            System.out.println(\"Collect classes\");\n+            List<Class<?>> classes = StackWalker.getInstance(Set.of(DROP_METHOD_INFO, RETAIN_CLASS_REFERENCE))\n+                    .walk(s -> {\n+                        return s.map(StackFrame::getDeclaringClass).collect(Collectors.toList());\n+                    });\n+            for (i=0; i < GOLDEN_CLASS_NAMES.size(); i++) {\n+                Class<?> c = classes.get(i);\n+                if (!GOLDEN_CLASS_NAMES.get(i).equals(c.getName())) {\n+                    throw new RuntimeException(\"unexpected class at \" + i + \" \" + c.getName() +\n+                            \" expected \" + GOLDEN_CLASS_NAMES.get(i));\n+                }\n+            }\n","filename":"test\/jdk\/java\/lang\/StackWalker\/StackStreamTest.java","additions":18,"deletions":3,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -58,0 +58,1 @@\n+            \"jdk.internal.reflect.DirectMethodHandleAccessor\",\n","filename":"test\/jdk\/java\/lang\/StackWalker\/StackWalkTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -156,1 +156,1 @@\n-                EnumSet.allOf(StackWalker.Option.class));\n+                EnumSet.of(RETAIN_CLASS_REFERENCE, SHOW_HIDDEN_FRAMES, SHOW_REFLECT_FRAMES));\n","filename":"test\/jdk\/java\/lang\/StackWalker\/VerifyStackTrace.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-        return StackWalker.getInstance(scope);\n+        return StackWalker.newInstance(Set.of(), scope);\n@@ -47,1 +47,1 @@\n-    public static StackFrame[] getStackFrames(ContinuationScope scope)     { return getStackFrames(StackWalker.getInstance(OPTS, scope)); }\n+    public static StackFrame[] getStackFrames(ContinuationScope scope)     { return getStackFrames(StackWalker.newInstance(OPTS, scope)); }\n","filename":"test\/jdk\/jdk\/internal\/vm\/Continuation\/java.base\/java\/lang\/StackWalkerHelper.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,2 @@\n+import java.util.Set;\n+\n@@ -39,0 +41,2 @@\n+import static java.lang.StackWalker.Option.*;\n+\n@@ -49,1 +53,4 @@\n-    private static final StackWalker WALKER_DEFAULT = StackWalker.getInstance();\n+    private static final StackWalker WALKER =\n+            StackWalker.getInstance(RETAIN_CLASS_REFERENCE);\n+    private static final StackWalker WALKER_CLASS_ONLY =\n+            StackWalker.getInstance(Set.of(DROP_METHOD_INFO, RETAIN_CLASS_REFERENCE));\n@@ -51,2 +58,7 @@\n-    private static final StackWalker WALKER_CLASS =\n-        StackWalker.getInstance(StackWalker.Option.RETAIN_CLASS_REFERENCE);\n+    static StackWalker walker(String name) {\n+        return switch (name) {\n+            case \"class+method\" -> WALKER;\n+            case \"class_only\" -> WALKER_CLASS_ONLY;\n+            default -> throw new IllegalArgumentException(name);\n+        };\n+    }\n@@ -66,0 +78,3 @@\n+    @Param({\"class+method\", \"class_only\"})\n+    public String walker;\n+\n@@ -178,1 +193,1 @@\n-                WALKER_DEFAULT.forEach(localBH::consume);\n+                walker(walker).forEach(localBH::consume);\n@@ -196,1 +211,1 @@\n-                WALKER_DEFAULT.walk(s -> {\n+                walker(walker).walk(s -> {\n@@ -215,0 +230,2 @@\n+        final StackWalker sw = walker(walker);\n+        if (sw == WALKER_CLASS_ONLY) return;\n@@ -217,1 +234,1 @@\n-                WALKER_DEFAULT.walk( s -> {\n+                sw.walk( s -> {\n@@ -236,0 +253,1 @@\n+        final StackWalker sw = walker(walker);\n@@ -238,1 +256,1 @@\n-                WALKER_CLASS.walk(s -> {\n+                sw.walk(s -> {\n@@ -250,0 +268,21 @@\n+    \/**\n+     * Use Stackwalker.walk() to fetch all instances\n+     *\/\n+    @Benchmark\n+    public void walk_StackFrame(Blackhole bh) {\n+        final Blackhole localBH = bh;\n+        final boolean[] done = {false};\n+        new TestStack(depth, new Runnable() {\n+            public void run() {\n+                walker(walker).walk(s -> {\n+                    s.forEach(localBH::consume);\n+                    return null;\n+                });\n+                done[0] = true;\n+            }\n+        }).start();\n+        if (!done[0]) {\n+            throw new RuntimeException();\n+        }\n+    }\n+\n@@ -257,0 +296,3 @@\n+        final StackWalker sw = walker(walker);\n+        if (sw == WALKER_CLASS_ONLY) return;\n+\n@@ -259,1 +301,1 @@\n-                WALKER_DEFAULT.walk(s -> {\n+                sw.walk(s -> {\n@@ -276,0 +318,11 @@\n+        final StackWalker sw = walker(walker);\n+        Class<?> c = sw.getCallerClass();\n+        bh.consume(c);\n+    }\n+\n+    \/**\n+     * StackWalker.getCallerClass() with generated call stack of\n+     * the given depth.\n+     *\/\n+    @Benchmark\n+    public void getCallerClass_withTestStack(Blackhole bh) {\n@@ -278,0 +331,1 @@\n+        final StackWalker sw = walker(walker);\n@@ -280,1 +334,1 @@\n-                localBH.consume(WALKER_CLASS.getCallerClass());\n+                localBH.consume(sw.getCallerClass());\n@@ -289,0 +343,18 @@\n+    \/**\n+     * Baseline for generating a call stack of the given depth.\n+     * (No StackWalk operations are executed)\n+     *\/\n+     @Benchmark\n+     public void makeCallStack(Blackhole bh) {\n+         final Blackhole localBH = bh;\n+         final boolean[] done = {false};\n+         new TestStack(depth, new Runnable() {\n+             public void run() {\n+                 done[0] = true;\n+             }\n+         }).start();\n+         if (!done[0]) {\n+             throw new RuntimeException();\n+         }\n+     }\n+\n@@ -298,1 +370,1 @@\n-\n+        final StackWalker sw = walker(walker);\n@@ -302,1 +374,1 @@\n-                WALKER_CLASS.walk(s -> {\n+                sw.walk(s -> {\n@@ -324,1 +396,1 @@\n-\n+        final StackWalker sw = walker(walker);\n@@ -328,1 +400,1 @@\n-                WALKER_CLASS.walk(s -> {\n+                sw.walk(s -> {\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/StackWalkBench.java","additions":86,"deletions":14,"binary":false,"changes":100,"status":"modified"}]}