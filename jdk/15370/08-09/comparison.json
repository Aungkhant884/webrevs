{"files":[{"patch":"@@ -33,0 +33,1 @@\n+import java.lang.reflect.Array;\n@@ -533,1 +534,1 @@\n-                                    : new StackFrameBuffer(walker, getNextBatchSize());\n+                                    : new StackFrameBuffer<>(StackFrameInfo.class, walker, getNextBatchSize());\n@@ -600,4 +601,6 @@\n-    static class StackFrameBuffer extends FrameBuffer<StackFrameInfo> {\n-        private final StackWalker walker;\n-        private StackFrameInfo[] stackFrames;\n-        StackFrameBuffer(StackWalker walker, int initialBatchSize) {\n+    static class StackFrameBuffer<T extends ClassFrameInfo> extends FrameBuffer<T> {\n+        final StackWalker walker;\n+        private final Class<T> type;\n+        private final Constructor<T> ctor;\n+        private T[] stackFrames;\n+        StackFrameBuffer(Class<T> type, StackWalker walker, int initialBatchSize) {\n@@ -606,3 +609,5 @@\n-            this.stackFrames = new StackFrameInfo[initialBatchSize];\n-            for (int i = START_POS; i < initialBatchSize; i++) {\n-                stackFrames[i] = new StackFrameInfo(walker);\n+            this.type = type;\n+            try {\n+                this.ctor = type.getDeclaredConstructor(StackWalker.class);\n+            } catch (NoSuchMethodException e) {\n+                throw new InternalError(e);\n@@ -610,0 +615,1 @@\n+            this.stackFrames = fill(allocateArray(initialBatchSize), START_POS, initialBatchSize);\n@@ -613,1 +619,1 @@\n-        StackFrameInfo[] frames() {\n+        T[] frames() {\n@@ -617,0 +623,16 @@\n+        @SuppressWarnings(\"unchecked\")\n+        T[] allocateArray(int size) {\n+            return (T[])Array.newInstance(type, size);\n+        }\n+\n+        T[] fill(T[] array, int startIndex, int size) {\n+            try {\n+                for (int i = startIndex; i < size; i++) {\n+                    array[i] = ctor.newInstance(walker);\n+                }\n+            } catch (ReflectiveOperationException e) {\n+                throw new InternalError(e);\n+            }\n+            return array;\n+        }\n+\n@@ -627,1 +649,1 @@\n-                StackFrameInfo[] newFrames = new StackFrameInfo[size];\n+                T[] newFrames = allocateArray(size);\n@@ -632,3 +654,1 @@\n-            for (int i = startIndex; i < size; i++) {\n-                stackFrames[i] = new StackFrameInfo(walker);\n-            }\n+            fill(stackFrames, startIndex, size);\n@@ -639,1 +659,1 @@\n-        StackFrameInfo nextStackFrame() {\n+        T nextStackFrame() {\n@@ -644,1 +664,1 @@\n-            StackFrameInfo frame = stackFrames[origin];\n+            T frame = stackFrames[origin];\n@@ -655,10 +675,7 @@\n-    static final class ClassFrameBuffer extends FrameBuffer<ClassFrameInfo> {\n-        final StackWalker walker;\n-        ClassFrameInfo[] classFrames;      \/\/ caller class for fast path\n-        ClassFrameBuffer(StackWalker walker, int batchSize) {\n-            super(batchSize);\n-            this.walker = walker;\n-            this.classFrames = new ClassFrameInfo[batchSize];\n-            for (int i = START_POS; i < batchSize; i++) {\n-                classFrames[i] = new ClassFrameInfo(walker);\n-            }\n+    \/*\n+     * Buffer for ClassFrameInfo.  It allocates ClassFrameInfo via bytecode\n+     * invocation instead of via core reflection to minimize the overhead.\n+     *\/\n+    static class ClassFrameBuffer extends StackFrameBuffer<ClassFrameInfo> {\n+        ClassFrameBuffer(StackWalker walker, int initialBatchSize) {\n+            super(ClassFrameInfo.class, walker, initialBatchSize);\n@@ -668,11 +685,2 @@\n-        ClassFrameInfo[] frames() { return classFrames;}\n-\n-        @Override\n-        ClassFrameInfo nextStackFrame() {\n-            if (isEmpty()) {\n-                throw new NoSuchElementException(\"origin=\" + origin + \" fence=\" + fence);\n-            }\n-\n-            ClassFrameInfo frame = classFrames[origin];\n-            origin++;\n-            return frame;\n+        ClassFrameInfo[] allocateArray(int size) {\n+            return new ClassFrameInfo[size];\n@@ -682,29 +690,1 @@\n-        final Class<?> at(int index) { return classFrames[index].declaringClass();}\n-\n-        \/\/ ------ subclass may override the following methods -------\n-        \/**\n-         * Resizes the buffers for VM to fill in the next batch of stack frames.\n-         * The next batch will start at the given startIndex with the maximum number\n-         * of elements.\n-         *\n-         * <p> Subclass may override this method to manage the allocated buffers.\n-         *\n-         * @param startIndex the start index for the first frame of the next batch to fill in.\n-         * @param elements the number of elements for the next batch to fill in.\n-         *\n-         *\/\n-        @Override\n-        void resize(int startIndex, int elements) {\n-            if (!isActive())\n-                throw new IllegalStateException(\"inactive frame buffer can't be resized\");\n-\n-            assert startIndex == START_POS :\n-                    \"bad start index \" + startIndex + \" expected \" + START_POS;\n-\n-            int size = startIndex+elements;\n-            if (classFrames.length < size) {\n-                ClassFrameInfo[] newFrames = new ClassFrameInfo[size];\n-                \/\/ copy initial magic...\n-                System.arraycopy(classFrames, 0, newFrames, 0, startIndex);\n-                classFrames = newFrames;\n-            }\n+        ClassFrameInfo[] fill(ClassFrameInfo[] array, int startIndex, int size) {\n@@ -712,1 +692,1 @@\n-                classFrames[i] = new ClassFrameInfo(walker);\n+                array[i] = new ClassFrameInfo(walker);\n@@ -714,1 +694,1 @@\n-            currentBatchSize = size;\n+            return array;\n@@ -790,55 +770,0 @@\n-        \/\/ VM will fill in all method info and live stack info directly in StackFrameInfo\n-        final class LiveStackFrameBuffer extends FrameBuffer<LiveStackFrameInfo> {\n-            private LiveStackFrameInfo[] stackFrames;\n-            LiveStackFrameBuffer(int initialBatchSize) {\n-                super(initialBatchSize);\n-                this.stackFrames = new LiveStackFrameInfo[initialBatchSize];\n-                for (int i = START_POS; i < initialBatchSize; i++) {\n-                    stackFrames[i] = new LiveStackFrameInfo(walker);\n-                }\n-            }\n-\n-            @Override\n-            LiveStackFrameInfo[] frames() {\n-                return stackFrames;\n-            }\n-\n-            @Override\n-            void resize(int startIndex, int elements) {\n-                if (!isActive()) {\n-                    throw new IllegalStateException(\"inactive frame buffer can't be resized\");\n-                }\n-                assert startIndex == START_POS :\n-                       \"bad start index \" + startIndex + \" expected \" + START_POS;\n-\n-                int size = startIndex + elements;\n-                if (stackFrames.length < size) {\n-                    LiveStackFrameInfo[] newFrames = new LiveStackFrameInfo[size];\n-                    \/\/ copy initial magic...\n-                    System.arraycopy(stackFrames, 0, newFrames, 0, startIndex);\n-                    stackFrames = newFrames;\n-                }\n-\n-                for (int i = startIndex(); i < size; i++) {\n-                    stackFrames[i] = new LiveStackFrameInfo(walker);\n-                }\n-\n-                currentBatchSize = size;\n-            }\n-\n-            @Override\n-            LiveStackFrameInfo nextStackFrame() {\n-                if (isEmpty()) {\n-                    throw new NoSuchElementException(\"origin=\" + origin + \" fence=\" + fence);\n-                }\n-\n-                LiveStackFrameInfo frame = stackFrames[origin];\n-                origin++;\n-                return frame;\n-            }\n-\n-            @Override\n-            final Class<?> at(int index) {\n-                return stackFrames[index].declaringClass();\n-            }\n-        }\n@@ -853,1 +778,1 @@\n-            this.frameBuffer = new LiveStackFrameBuffer(getNextBatchSize());\n+            this.frameBuffer = new StackFrameBuffer<>(LiveStackFrameInfo.class, walker, getNextBatchSize());\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StackStreamFactory.java","additions":48,"deletions":123,"binary":false,"changes":171,"status":"modified"},{"patch":"@@ -114,1 +114,1 @@\n-         * {@return the <a href=\"ClassLoader.html#binary-name\">binary name<\/a>\n+         * {@return the {@linkplain ClassLoader##binary-name binary name}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StackWalker.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}