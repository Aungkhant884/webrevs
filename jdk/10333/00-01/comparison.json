{"files":[{"patch":"@@ -27,1 +27,1 @@\n- * @library \/test\/lib\n+ * @requires (os.arch != \"x86\" & os.arch != \"i386\") | vm.opt.UseSSE == \"null\" | vm.opt.UseSSE > 0\n@@ -31,2 +31,11 @@\n-import jdk.test.lib.Platform;\n-\n+\/*\n+ * The behavior tested below is an implementation property not\n+ * required by the specification. It would be acceptable for this\n+ * information to not be preserved (as long as a NaN is returned) if,\n+ * say, a intrinsified version using native hardware instructions\n+ * behaved differently.\n+ *\n+ * If that is the case, this test should be modified to disable\n+ * intrinsics or to otherwise not run on platforms with an differently\n+ * behaving intrinsic.\n+ *\/\n@@ -34,14 +43,0 @@\n-\n-    \/*\n-     * The behavior tested below is an implementation property not\n-     * required by the specification. It would be acceptable for this\n-     * information to not be preserved (as long as a NaN is returned) if,\n-     * say, a intrinsified version using native hardware instructions\n-     * behaved differently.\n-     *\n-     * All platforms current platforms are bit exac, except:\n-     *   - x86_32 FPU that silently convert NaNs\n-     *\/\n-    private static final boolean BITEXACT_SIGNIFICAND = !Platform.isX86();\n-    private static final boolean BITEXACT_SIGN = true;\n-\n@@ -69,2 +64,2 @@\n-            errors += testNaNRoundTrip(                   binary16NaN);\n-            errors += testNaNRoundTrip((short)(SIGN_BIT | binary16NaN));\n+            errors += testRoundTrip(                   binary16NaN);\n+            errors += testRoundTrip((short)(SIGN_BIT | binary16NaN));\n@@ -80,5 +75,1 @@\n-    private static int sign(short binary16) {\n-        return (binary16 & 0xf000);\n-    }\n-\n-    private static int testNaNRoundTrip(int i) {\n+    private static int testRoundTrip(int i) {\n@@ -90,11 +81,1 @@\n-        boolean pass;\n-        if (BITEXACT_SIGNIFICAND && BITEXACT_SIGN) {\n-            pass = (s == s2);               \/\/ Bit exact\n-        } else if (BITEXACT_SIGN) {\n-            pass = (isNaN(s) == isNaN(s2))  \/\/ Still NaN\n-                && (sign(s)  == sign(s2));  \/\/ Sign is intact\n-        } else {\n-            pass = (isNaN(s) == isNaN(s2)); \/\/ Still NaN\n-        }\n-\n-        if (!pass) {\n+        if (s != s2) {\n","filename":"test\/jdk\/java\/lang\/Float\/Binary16ConversionNaN.java","additions":16,"deletions":35,"binary":false,"changes":51,"status":"modified"}]}