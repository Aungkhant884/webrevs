{"files":[{"patch":"@@ -27,0 +27,1 @@\n+ * @library \/test\/lib\n@@ -30,11 +31,2 @@\n-\/*\n- * The behavior tested below is an implementation property not\n- * required by the specification. It would be acceptable for this\n- * information to not be preserved (as long as a NaN is returned) if,\n- * say, a intrinsified version using native hardware instructions\n- * behaved differently.\n- *\n- * If that is the case, this test should be modified to disable\n- * intrinsics or to otherwise not run on platforms with an differently\n- * behaving intrinsic.\n- *\/\n+import jdk.test.lib.Platform;\n+\n@@ -42,0 +34,14 @@\n+\n+    \/*\n+     * The behavior tested below is an implementation property not\n+     * required by the specification. It would be acceptable for this\n+     * information to not be preserved (as long as a NaN is returned) if,\n+     * say, a intrinsified version using native hardware instructions\n+     * behaved differently.\n+     *\n+     * All platforms current platforms are bit exac, except:\n+     *   - x86_32 FPU that silently convert NaNs\n+     *\/\n+    private static final boolean BITEXACT_SIGNIFICAND = !Platform.isX86();\n+    private static final boolean BITEXACT_SIGN = true;\n+\n@@ -63,2 +69,2 @@\n-            errors += testRoundTrip(                   binary16NaN);\n-            errors += testRoundTrip((short)(SIGN_BIT | binary16NaN));\n+            errors += testNaNRoundTrip(                   binary16NaN);\n+            errors += testNaNRoundTrip((short)(SIGN_BIT | binary16NaN));\n@@ -74,1 +80,5 @@\n-    private static int testRoundTrip(int i) {\n+    private static int sign(short binary16) {\n+        return (binary16 & 0xf000);\n+    }\n+\n+    private static int testNaNRoundTrip(int i) {\n@@ -80,1 +90,11 @@\n-        if (s != s2) {\n+        boolean pass;\n+        if (BITEXACT_SIGNIFICAND && BITEXACT_SIGN) {\n+            pass = (s == s2);               \/\/ Bit exact\n+        } else if (BITEXACT_SIGN) {\n+            pass = (isNaN(s) == isNaN(s2))  \/\/ Still NaN\n+                && (sign(s)  == sign(s2));  \/\/ Sign is intact\n+        } else {\n+            pass = (isNaN(s) == isNaN(s2)); \/\/ Still NaN\n+        }\n+\n+        if (!pass) {\n","filename":"test\/jdk\/java\/lang\/Float\/Binary16ConversionNaN.java","additions":35,"deletions":15,"binary":false,"changes":50,"status":"modified"}]}