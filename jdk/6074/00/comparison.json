{"files":[{"patch":"@@ -34,1 +34,0 @@\n-#include \"runtime\/threadCritical.hpp\"\n@@ -271,28 +270,0 @@\n-\/\/ Array used to print owned locks on error.\n-static Mutex* _mutex_array = NULL;\n-\n-void Mutex::add_to_global_list() {\n-  \/\/ Add mutex to print_owned_locks_on_error array\n-  ThreadCritical tc;\n-  Mutex* next = _mutex_array;\n-  _next_mutex = next;\n-  _prev_mutex = nullptr;\n-  _mutex_array = this;\n-  if (next != nullptr) {\n-    next->_prev_mutex = this;\n-  }\n-}\n-\n-void Mutex::remove_from_global_list() {\n-  \/\/ Remove mutex from print_owned_locks_on_error array\n-  ThreadCritical tc;\n-  Mutex* old_next = _next_mutex;\n-  assert(old_next != nullptr, \"this list can never be empty\");\n-  old_next->_prev_mutex = _prev_mutex;\n-  if (_prev_mutex == nullptr) {\n-    _mutex_array = old_next;\n-  } else {\n-    _prev_mutex->_next_mutex = old_next;\n-  }\n-}\n-\n@@ -300,1 +271,0 @@\n-  remove_from_global_list();\n@@ -313,2 +283,0 @@\n-  _next            = nullptr;\n-  _last_owner      = nullptr;\n@@ -323,1 +291,0 @@\n-  add_to_global_list();\n@@ -330,1 +297,1 @@\n-void Mutex::print_on(outputStream* st) const {\n+void Mutex::print_on_error(outputStream* st) const {\n@@ -334,34 +301,0 @@\n-#ifdef ASSERT\n-  if (_allow_vm_block) {\n-    st->print_raw(\" allow_vm_block\");\n-  }\n-  st->print(\" %s\", rank_name());\n-#endif\n-  st->cr();\n-}\n-\n-\/\/ Print all mutexes\/monitors that are currently owned by a thread; called\n-\/\/ by fatal error handler.\n-\/\/ This function doesn't take the ThreadCritical lock to avoid potential\n-\/\/ deadlock during error reporting.\n-void Mutex::print_owned_locks_on_error(outputStream* st) {\n-  assert(VMError::is_error_reported(), \"should only be called during error reporting\");\n-  ResourceMark rm;\n-  st->print(\"VM Mutexes\/Monitors currently owned by a thread: \");\n-  bool none = true;\n-  Mutex *m = _mutex_array;\n-  int array_count = 0;\n-  while (m != nullptr) {\n-     array_count++;\n-     \/\/ see if it has an owner\n-     if (m->owner() != NULL) {\n-       if (none) {\n-          st->cr();\n-          none = false;\n-       }\n-       m->print_on(st);\n-     }\n-     m = m->_next_mutex;\n-  }\n-  if (none) st->print_cr(\"None\");\n-  st->print_cr(\"Total Mutex count %d\", array_count);\n@@ -413,0 +346,13 @@\n+#endif \/\/ ASSERT\n+\n+#ifndef PRODUCT\n+void Mutex::print_on(outputStream* st) const {\n+  st->print(\"Mutex: [\" PTR_FORMAT \"] %s - owner: \" PTR_FORMAT,\n+            p2i(this), _name, p2i(owner()));\n+  if (_allow_vm_block) {\n+    st->print(\"%s\", \" allow_vm_block\");\n+  }\n+  DEBUG_ONLY(st->print(\" %s\", rank_name()));\n+  st->cr();\n+}\n+#endif \/\/ PRODUCT\n@@ -414,0 +360,1 @@\n+#ifdef ASSERT\n","filename":"src\/hotspot\/share\/runtime\/mutex.cpp","additions":15,"deletions":68,"binary":false,"changes":83,"status":"modified"},{"patch":"@@ -91,7 +91,0 @@\n-  \/\/ Embed pointers for mutex array for error reporting.\n-  Mutex* _next_mutex;\n-  Mutex* _prev_mutex;\n-\n-  void add_to_global_list();\n-  void remove_from_global_list();\n-\n@@ -102,1 +95,4 @@\n-  \/\/ Debugging fields for naming, deadlock detection, etc.\n+  \/\/ Debugging fields for naming, deadlock detection, etc. (some only used in debug mode)\n+#ifndef PRODUCT\n+  bool    _allow_vm_block;\n+#endif\n@@ -107,2 +103,1 @@\n-  bool    _skip_rank_check;      \/\/ read only by owner when doing rank checks\n-  bool    _allow_vm_block;\n+  bool _skip_rank_check;         \/\/ read only by owner when doing rank checks\n@@ -197,5 +192,5 @@\n-  \/\/ Print all mutexes\/monitors that are currently owned by a thread; called\n-  \/\/ by fatal error handler.\n-  static void print_owned_locks_on_error(outputStream* st);\n-  void print_on(outputStream* st) const;\n-  void print() const { print_on(::tty); }\n+  void print_on_error(outputStream* st) const;\n+  #ifndef PRODUCT\n+    void print_on(outputStream* st) const;\n+    void print() const                      { print_on(::tty); }\n+  #endif\n","filename":"src\/hotspot\/share\/runtime\/mutex.hpp","additions":10,"deletions":15,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -160,0 +160,5 @@\n+\n+#define MAX_NUM_MUTEX 128\n+static Mutex* _mutex_array[MAX_NUM_MUTEX];\n+static int _num_mutex;\n+\n@@ -192,0 +197,5 @@\n+static void add_mutex(Mutex* var) {\n+  assert(_num_mutex < MAX_NUM_MUTEX, \"increase MAX_NUM_MUTEX\");\n+  _mutex_array[_num_mutex++] = var;\n+}\n+\n@@ -194,0 +204,1 @@\n+  add_mutex(var);                             \\\n@@ -200,0 +211,1 @@\n+  add_mutex(var);                                      \\\n@@ -204,0 +216,1 @@\n+  add_mutex(var);                                      \\\n@@ -367,0 +380,20 @@\n+\n+\/\/ Print all mutexes\/monitors that are currently owned by a thread; called\n+\/\/ by fatal error handler.\n+void print_owned_locks_on_error(outputStream* st) {\n+  st->print(\"VM Mutex\/Monitor currently owned by a thread: \");\n+  bool none = true;\n+  for (int i = 0; i < _num_mutex; i++) {\n+     \/\/ see if it has an owner\n+     if (_mutex_array[i]->owner() != NULL) {\n+       if (none) {\n+          \/\/ print format used by Mutex::print_on_error()\n+          st->print_cr(\" ([mutex\/lock_event])\");\n+          none = false;\n+       }\n+       _mutex_array[i]->print_on_error(st);\n+       st->cr();\n+     }\n+  }\n+  if (none) st->print_cr(\"None\");\n+}\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.cpp","additions":33,"deletions":0,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -172,0 +172,6 @@\n+\/\/ Print all mutexes\/monitors that are currently owned by a thread; called\n+\/\/ by fatal error handler.\n+void print_owned_locks_on_error(outputStream* st);\n+\n+char *lock_name(Mutex *mutex);\n+\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1018,1 +1018,1 @@\n-       Mutex::print_owned_locks_on_error(st);\n+       print_owned_locks_on_error(st);\n@@ -1916,6 +1916,0 @@\n-    case 3: {\n-      Mutex* ErrorTest_lock = new Mutex(Mutex::nosafepoint, \"ErrorTest_lock\");\n-      MutexLocker ml(ErrorTest_lock, Mutex::_no_safepoint_check_flag);\n-      assert(how == 0, \"test assert with lock\");\n-      break;\n-    }\n","filename":"src\/hotspot\/share\/utilities\/vmError.cpp","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,0 +45,40 @@\n+  private static File findHsErrorFileInOutput(OutputAnalyzer output) {\n+\n+    String hs_err_file = output.firstMatch(\"# *(\\\\S*hs_err_pid.*\\\\.log)\", 1);\n+    if(hs_err_file ==null) {\n+      throw new RuntimeException(\"Did not find hs-err file in output.\\n\");\n+    }\n+\n+    File f = new File(hs_err_file);\n+    if (!f.exists()) {\n+      throw new RuntimeException(\"hs-err file missing at \"\n+              + f.getAbsolutePath() + \".\\n\");\n+    }\n+\n+    return f;\n+\n+  }\n+\n+  private static void scanHsErrorFileForContent(File f, Pattern[] pattern) throws IOException {\n+    FileInputStream fis = new FileInputStream(f);\n+    BufferedReader br = new BufferedReader(new InputStreamReader(fis));\n+    String line = null;\n+\n+    int currentPattern = 0;\n+\n+    String lastLine = null;\n+    while ((line = br.readLine()) != null && currentPattern < pattern.length) {\n+      if (pattern[currentPattern].matcher(line).matches()) {\n+        System.out.println(\"Found: \" + line + \".\");\n+        currentPattern++;\n+      }\n+      lastLine = line;\n+    }\n+    br.close();\n+\n+    if (currentPattern < pattern.length) {\n+      throw new RuntimeException(\"hs-err file incomplete (first missing pattern: \" +  pattern[currentPattern] + \")\");\n+    }\n+\n+  }\n+\n@@ -73,1 +113,1 @@\n-    File f = ErrorFileScanner.findHsErrorFileInOutput(output_detail);\n+    File f = findHsErrorFileInOutput(output_detail);\n@@ -76,1 +116,1 @@\n-    ErrorFileScanner.scanHsErrorFileForContent(f, new Pattern[] {\n+    scanHsErrorFileForContent(f, new Pattern[] {\n@@ -99,1 +139,1 @@\n-    File f2 = ErrorFileScanner.findHsErrorFileInOutput(output_detail);\n+    File f2 = findHsErrorFileInOutput(output_detail);\n@@ -108,1 +148,1 @@\n-    ErrorFileScanner.scanHsErrorFileForContent(f2, new Pattern[] {\n+    scanHsErrorFileForContent(f2, new Pattern[] {\n","filename":"test\/hotspot\/jtreg\/runtime\/ErrorHandling\/ErrorFileOverwriteTest.java","additions":45,"deletions":5,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -1,75 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.io.BufferedReader;\n-import java.io.File;\n-import java.io.FileInputStream;\n-import java.io.InputStreamReader;\n-import java.io.IOException;\n-\n-import java.util.regex.Pattern;\n-\n-import jdk.test.lib.process.OutputAnalyzer;\n-\n-public class ErrorFileScanner {\n-\n-  public static File findHsErrorFileInOutput(OutputAnalyzer output) {\n-\n-    String hs_err_file = output.firstMatch(\"# *(\\\\S*hs_err_pid.*\\\\.log)\", 1);\n-    if(hs_err_file ==null) {\n-      throw new RuntimeException(\"Did not find hs-err file in output.\\n\");\n-    }\n-\n-    File f = new File(hs_err_file);\n-    if (!f.exists()) {\n-      throw new RuntimeException(\"hs-err file missing at \"\n-              + f.getAbsolutePath() + \".\\n\");\n-    }\n-\n-    return f;\n-\n-  }\n-\n-  public static void scanHsErrorFileForContent(File f, Pattern[] pattern) throws IOException {\n-    FileInputStream fis = new FileInputStream(f);\n-    BufferedReader br = new BufferedReader(new InputStreamReader(fis));\n-    String line = null;\n-\n-    int currentPattern = 0;\n-\n-    String lastLine = null;\n-    while ((line = br.readLine()) != null && currentPattern < pattern.length) {\n-      if (pattern[currentPattern].matcher(line).matches()) {\n-        System.out.println(\"Found: \" + line + \".\");\n-        currentPattern++;\n-      }\n-      lastLine = line;\n-    }\n-    br.close();\n-\n-    if (currentPattern < pattern.length) {\n-      throw new RuntimeException(\"hs-err file incomplete (first missing pattern: \" +  pattern[currentPattern] + \")\");\n-    }\n-\n-  }\n-}\n","filename":"test\/hotspot\/jtreg\/runtime\/ErrorHandling\/ErrorFileScanner.java","additions":0,"deletions":75,"binary":false,"changes":75,"status":"deleted"},{"patch":"@@ -1,72 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/*\n- * @test\n- * @bug 8274794\n- * @summary Test that locks are printed in the Error file.\n- * @library \/test\/lib\n- * @modules java.base\/jdk.internal.misc\n- * @requires (vm.debug == true)\n- * @run driver TestErrorFileMutex\n- *\/\n-\n-import jdk.test.lib.process.OutputAnalyzer;\n-import jdk.test.lib.process.ProcessTools;\n-\n-import java.io.*;\n-import java.util.regex.Pattern;\n-\n-public class TestErrorFileMutex {\n-\n-  public static void do_test() throws Exception {\n-\n-    ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(\n-            \"-Xmx64M\",\n-            \"-XX:-CreateCoredumpOnCrash\",\n-            \"-XX:ErrorHandlerTest=3\",\n-            \"-version\");\n-\n-    OutputAnalyzer output_detail = new OutputAnalyzer(pb.start());\n-    output_detail.shouldMatch(\"# A fatal error has been detected by the Java Runtime Environment:.*\");\n-\n-    File f = ErrorFileScanner.findHsErrorFileInOutput(output_detail);\n-    System.out.println(\"Found hs error file at \" + f.getAbsolutePath());\n-\n-    ErrorFileScanner.scanHsErrorFileForContent(f, new Pattern[] {\n-            Pattern.compile(\"# *Internal Error.*\"),\n-            Pattern.compile(\".*VM Mutexes\/Monitors currently owned by a thread:.*\"),\n-            Pattern.compile(\".*ErrorTest_lock - owner thread:.*\"),\n-            Pattern.compile(\".*Threads_lock - owner thread:.*\")\n-    });\n-  }\n-\n-  public static void main(String[] args) throws Exception {\n-    do_test();\n-  }\n-\n-}\n-\n-\n-\n","filename":"test\/hotspot\/jtreg\/runtime\/ErrorHandling\/TestErrorFileMutex.java","additions":0,"deletions":72,"binary":false,"changes":72,"status":"deleted"}]}