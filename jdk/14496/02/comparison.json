{"files":[{"patch":"@@ -8191,13 +8191,12 @@\n-     * If {@code R} is the return type of the filter (which cannot be void), the target var handle must accept a value of\n-     * type {@code R} as its coordinate in position {@code pos}, preceded and\/or followed by\n-     * any coordinate not passed to the filter.\n-     * No coordinates are reordered, and the result returned from the filter\n-     * replaces (in order) the whole subsequence of coordinates originally\n-     * passed to the adapter.\n-     * <p>\n-     * The argument types (if any) of the filter\n-     * replace zero or one coordinate types of the target var handle, at position {@code pos},\n-     * in the resulting adapted var handle.\n-     * The return type of the filter must be identical to the\n-     * coordinate type of the target var handle at position {@code pos}, and that target var handle\n-     * coordinate is supplied by the return value of the filter.\n+     * If {@code R} is the return type of the filter, then:\n+     * <ul>\n+     * <li>if {@code R} <em>is not<\/em> {@code void}, the target var handle must have a coordinate of type {@code R} in\n+     * position {@code pos}. The parameter types of the filter will replace the coordinate type at position {@code pos}\n+     * of the target var handle. When the returned var handle is invoked, it will be as if the filter is invoked first,\n+     * and its result is passed in place of the coordinate at position {@code pos} in a downstream invocation of the\n+     * target var handle.<\/li>\n+     * <li> if {@code R} <em>is<\/em> {@code void}, the parameter types (if any) of the filter will be inserted in the\n+     * coordinate type list of the target var handle at position {@code pos}. In this case, when the returned var handle\n+     * is invoked, the filter essentially acts as a side effect, consuming some of the coordinate values, before a\n+     * downstream invocation of the target var handle.<\/li>\n+     * <\/ul>\n@@ -8212,1 +8211,1 @@\n-     * @param pos the position of the coordinate to be filtered\n+     * @param pos the position in the coordinate list of the target var handle where the filter is to be inserted\n@@ -8217,1 +8216,1 @@\n-     * is void, or it is not the same as the {@code pos} coordinate of the target var handle,\n+     * is not void, and it is not the same as the {@code pos} coordinate of the target var handle,\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandles.java","additions":14,"deletions":15,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -566,3 +566,1 @@\n-        } else if (filter.type().returnType() == void.class) {\n-            throw newIllegalArgumentException(\"Invalid filter type \" + filter.type() + \" ; filter cannot be void\");\n-        } else if (filter.type().returnType() != targetCoordinates.get(pos)) {\n+        } else if (filter.type().returnType() != void.class && filter.type().returnType() != targetCoordinates.get(pos)) {\n@@ -573,1 +571,3 @@\n-        newCoordinates.remove(pos);\n+        if (filter.type().returnType() != void.class) {\n+            newCoordinates.remove(pos);\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/VarHandles.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -354,0 +354,6 @@\n+    @Test\n+    public void testCollectCoordinatesVoidFilterType() {\n+        VarHandle handle = MethodHandles.collectCoordinates(intHandle, 0, VOID_FILTER);\n+        assertEquals(handle.coordinateTypes(), List.of(String.class, MemorySegment.class));\n+    }\n+\n@@ -369,5 +375,0 @@\n-    @Test(expectedExceptions = IllegalArgumentException.class)\n-    public void testBadCollectCoordinatesWrongVoidFilterType() {\n-        MethodHandles.collectCoordinates(intHandle, 0, VOID_FILTER);\n-    }\n-\n","filename":"test\/jdk\/java\/foreign\/TestAdaptVarHandles.java","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"}]}