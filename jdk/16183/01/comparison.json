{"files":[{"patch":"@@ -46,3 +46,4 @@\n- * features an <em>unbounded lifetime<\/em>. As such, native segments allocated with the global arena are always\n- * accessible and their backing regions of memory are never deallocated. Moreover, memory segments allocated with the\n- * global arena can be {@linkplain MemorySegment#isAccessibleBy(Thread) accessed} from any thread.\n+ * features an <em>unbounded lifetime<\/em>. The scope of the global arena is the global scope.\n+ * As such, native segments allocated with the global arena are associated are always accessible and their backing regions\n+ * of memory are never deallocated.\n+ * Moreover, memory segments allocated with the global arena can be {@linkplain MemorySegment#isAccessibleBy(Thread) accessed} from any thread.\n@@ -56,1 +57,2 @@\n- * which features a <em>bounded lifetime<\/em> that is managed, automatically, by the garbage collector. As such, the regions\n+ * which features a <em>bounded lifetime<\/em> that is managed, automatically, by the garbage collector. The scope\n+ * of an automatic arena is an automatic scope. As such, the regions\n@@ -70,5 +72,3 @@\n- * bounded lifetimes that are managed manually. For instance, the lifetime of a confined arena starts when the confined\n- * arena is created, and ends when the confined arena is {@linkplain #close() closed}. As a result, the regions of memory\n- * backing memory segments allocated with a confined arena are deallocated when the confined arena is closed.\n- * When this happens, all the segments allocated with the confined arena are invalidated, and subsequent access\n- * operations on these segments will fail {@link IllegalStateException}:\n+ * bounded lifetimes that are managed manually. For instance, when a confined arena is {@linkplain #close() closed}\n+ * successfully, its scope is {@linkplain Scope#isAlive() invalidated}. As a result, all the memory segments allocated\n+ * by the arena can no longer be accessed, and their regions of memory are deallocated:\n@@ -222,1 +222,1 @@\n-            static final Arena GLOBAL = MemorySessionImpl.GLOBAL.asArena();\n+            static final Arena GLOBAL = MemorySessionImpl.GLOBAL_SESSION.asArena();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/Arena.java","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -368,1 +368,1 @@\n- * returned segment is a fresh scope that is always alive. To provide safe access to the segment, we must,\n+ * returned segment is the global scope. To provide safe access to the segment, we must,\n@@ -566,1 +566,1 @@\n-     * a fresh scope that is always alive. Under normal conditions, the size of the returned segment is {@code 0}.\n+     * the global scope. Under normal conditions, the size of the returned segment is {@code 0}.\n@@ -605,1 +605,1 @@\n-     * is a native segment associated with a fresh scope that is always alive.\n+     * is a native segment associated with the global scope.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/Linker.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -463,1 +463,1 @@\n-     * on the returned var handle will return a new memory segment. The segment is associated with a fresh scope that is\n+     * on the returned var handle will return a new memory segment. The segment is associated with a scope that is\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemoryLayout.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -386,1 +386,1 @@\n- *     <li>The segment is associated with a fresh scope that is always alive. Thus, while zero-length\n+ *     <li>The segment is associated with the global scope. Thus, while zero-length\n@@ -638,1 +638,1 @@\n-     * That is, the cleanup action receives a segment that is associated with a fresh scope that is always alive,\n+     * That is, the cleanup action receives a segment that is associated with the global scope,\n@@ -677,1 +677,1 @@\n-     * That is, the cleanup action receives a segment that is associated with a fresh scope that is always alive,\n+     * That is, the cleanup action receives a segment that is associated with the global scope,\n@@ -1186,5 +1186,3 @@\n-     * same scope {@code S}. Otherwise, the scope of the returned segment is a fresh scope that is always alive.\n-     * <p>\n-     * The scope associated with the returned segment keeps the provided buffer reachable. As such, if\n-     * the provided buffer is a direct buffer, its backing memory region will not be deallocated as long as the\n-     * returned segment (or any of its slices) are kept reachable.\n+     * same scope {@code S}. Otherwise, the scope of the returned segment is an automatic scope that keeps the provided\n+     * buffer reachable. As such, if the provided buffer is a direct buffer, its backing memory region will not be\n+     * deallocated as long as the returned segment (or any of its slices) are kept reachable.\n@@ -1205,1 +1203,1 @@\n-     * The scope of the returned segment is a fresh scope that is always alive, and keeps the given array reachable.\n+     * The scope of the returned segment is an automatic scope that keeps the given array reachable.\n@@ -1217,1 +1215,1 @@\n-     * The scope of the returned segment is a fresh scope that is always alive, and keeps the given array reachable.\n+     * The scope of the returned segment is an automatic scope that keeps the given array reachable.\n@@ -1229,1 +1227,1 @@\n-     * The scope of the returned segment is a fresh scope that is always alive, and keeps the given array reachable.\n+     * The scope of the returned segment is an automatic scope that keeps the given array reachable.\n@@ -1241,1 +1239,1 @@\n-     * The scope of the returned segment is a fresh scope that is always alive, and keeps the given array reachable.\n+     * The scope of the returned segment is an automatic scope that keeps the given array reachable.\n@@ -1253,1 +1251,1 @@\n-     * The scope of the returned segment is a fresh scope that is always alive, and keeps the given array reachable.\n+     * The scope of the returned segment is an automatic scope that keeps the given array reachable.\n@@ -1265,1 +1263,1 @@\n-     * The scope of the returned segment is a fresh scope that is always alive, and keeps the given array reachable.\n+     * The scope of the returned segment is an automatic scope that keeps the given array reachable.\n@@ -1277,1 +1275,1 @@\n-     * The scope of the returned segment is a fresh scope that is always alive, and keeps the given array reachable.\n+     * The scope of the returned segment is an automatic scope that keeps the given array reachable.\n@@ -1288,1 +1286,1 @@\n-     * A zero-length native segment modelling the {@code NULL} address.\n+     * A zero-length native segment modelling the {@code NULL} address. Equivalent to {@code MemorySegment.ofAddress(0L)}.\n@@ -1294,1 +1292,1 @@\n-     * The returned segment is associated with a scope that is always alive, and is accessible from any thread.\n+     * The returned segment is associated with the global scope, and is accessible from any thread.\n@@ -1721,1 +1719,1 @@\n-     * a native segment, associated with a fresh scope that is always alive. Under normal conditions,\n+     * a native segment, associated with the global scope. Under normal conditions,\n@@ -2160,1 +2158,1 @@\n-     * a native segment, associated with a fresh scope that is always alive. Under normal conditions,\n+     * a native segment, associated with the global scope. Under normal conditions,\n@@ -2368,2 +2366,12 @@\n-     * cannot be accessed if its associated scope is not {@linkplain #isAlive() alive}. A new scope is typically\n-     * obtained indirectly, by creating a new {@linkplain Arena arena}.\n+     * cannot be accessed if its associated scope is not {@linkplain #isAlive() alive}. Scope instances can be compared\n+     * for equality. That is, two scopes are considered {@linkplain #equals(Object)} if they denote the same lifetime.\n+     * <p>\n+     * The lifetime of a memory segment can be either <em>unbounded<\/em> or <em>bounded<\/em>. An unbounded lifetime\n+     * is modelled with the <em>global scope<\/em>. The global scope is always {@link #isAlive() alive}. As such, a segment\n+     * associated with the global scope features trivial temporal bounds, and is always accessible.\n+     * Segments associated with the global scope are:\n+     * <ul>\n+     *     <li>Segments obtained from the {@linkplain Arena#global() global arena};<\/li>\n+     *     <li>Segments obtained from a raw address, using the {@link MemorySegment#ofAddress(long)} factory; and<\/li>\n+     *     <li><a href=\"#wrapping-addresses\">Zero-length memory segments.<\/a><\/li>\n+     * <\/ul>\n@@ -2371,2 +2379,19 @@\n-     * Scope instances can be compared for equality. That is, two scopes\n-     * are considered {@linkplain #equals(Object)} if they denote the same lifetime.\n+     * Conversely, a bounded lifetime is modelled with a segment scope that can be invalidated, either {@link Arena#close() explicitly},\n+     * or automatically, by the garbage collector. A segment scope that is invalidated automatically is an <em>automatic scope<\/em>.\n+     * An automatic scope is always {@link #isAlive() alive} as long as it is <a href=\"..\/..\/..\/java\/lang\/ref\/package.html#reachability\">reachable<\/a>.\n+     * Segments associated with an automatic scope are:\n+     * <ul>\n+     *     <li>Segments obtained from an {@linkplain Arena#ofAuto() automatic arena};<\/li>\n+     *     <li>Segments obtained from a Java array, e.g. using the {@link MemorySegment#ofArray(int[])} factory;<\/li>\n+     *     <li>Segments obtained from a buffer, using the {@link MemorySegment#ofBuffer(Buffer)} factory; and<\/li>\n+     *     <li>Segments obtained from {@linkplain SymbolLookup#loaderLookup() loader lookup}.<\/li>\n+     * <\/ul>\n+     * If two memory segments are obtained from the same {@linkplain #ofBuffer(Buffer) buffer}\n+     * or {@linkplain #ofArray(int[]) array}, the automatic scopes associated with said segments are considered\n+     * {@linkplain #equals(Object) equal}, as the two segments have the same lifetime:\n+     * {@snippet lang=java :\n+     * byte[] arr = new byte[10];\n+     * MemorySegment segment1 = MemorySegment.ofArray(arr);\n+     * MemorySegment segment2 = MemorySegment.ofArray(arr);\n+     * assert segment1.scope().equals(segment2.scope());\n+     * }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemorySegment.java","additions":48,"deletions":23,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -168,1 +168,1 @@\n-     * returned by this method is associated with a fresh {@linkplain MemorySegment.Scope scope} which keeps the caller's\n+     * returned by this method is associated with an automatic {@linkplain MemorySegment.Scope scope} which keeps the caller's\n@@ -192,1 +192,1 @@\n-            MemorySessionImpl session = MemorySessionImpl.heapSession(loader);\n+            MemorySessionImpl session = MemorySessionImpl.createHeap(loader);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/SymbolLookup.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -57,0 +57,1 @@\n+import sun.nio.ch.DirectBuffer;\n@@ -540,1 +541,1 @@\n-            bufferScope = MemorySessionImpl.heapSession(bb);\n+            bufferScope = MemorySessionImpl.createHeap(bufferRef(bb));\n@@ -568,0 +569,11 @@\n+    private static Object bufferRef(Buffer buffer) {\n+        if (buffer instanceof DirectBuffer directBuffer) {\n+            \/\/ direct buffer, return either the buffer attachment (for slices and views), or the buffer itself\n+            return directBuffer.attachment() != null ?\n+                    directBuffer.attachment() : directBuffer;\n+        } else {\n+            \/\/ heap buffer, return the underlying array\n+            return NIO_ACCESS.getBufferBase(buffer);\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/AbstractMemorySegmentImpl.java","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import jdk.internal.access.JavaNioAccess;\n+import jdk.internal.access.SharedSecrets;\n@@ -29,0 +31,4 @@\n+import sun.nio.ch.DirectBuffer;\n+\n+import java.nio.Buffer;\n+import java.util.Objects;\n@@ -35,3 +41,1 @@\n-final class GlobalSession extends MemorySessionImpl {\n-\n-    final Object ref;\n+non-sealed class GlobalSession extends MemorySessionImpl {\n@@ -39,1 +43,1 @@\n-    public GlobalSession(Object ref) {\n+    public GlobalSession() {\n@@ -41,1 +45,0 @@\n-        this.ref = ref;\n@@ -70,0 +73,28 @@\n+\n+    \/**\n+     * This is a global session that wraps a heap object. Possible objects are: Java arrays, buffers and\n+     * class loaders. Objects of two heap sessions are compared by identity. That is, if the wrapped object is the same,\n+     * then the resulting heap sessions are also considered equals. We do not compare the objects using\n+     * {@link Object#equals(Object)}, as that would be problematic when comparing buffers, whose equality and\n+     * hash codes are content-dependent.\n+     *\/\n+    static class HeapSession extends GlobalSession {\n+\n+        final Object ref;\n+\n+        public HeapSession(Object ref) {\n+            super();\n+            this.ref = Objects.requireNonNull(ref);\n+        }\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            return obj instanceof HeapSession session &&\n+                    ref == session.ref;\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return System.identityHashCode(ref);\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/GlobalSession.java","additions":36,"deletions":5,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -117,1 +117,1 @@\n-                    MemorySessionImpl.heapSession(arr));\n+                    MemorySessionImpl.createHeap(arr));\n@@ -151,1 +151,1 @@\n-                    MemorySessionImpl.heapSession(arr));\n+                    MemorySessionImpl.createHeap(arr));\n@@ -185,1 +185,1 @@\n-                    MemorySessionImpl.heapSession(arr));\n+                    MemorySessionImpl.createHeap(arr));\n@@ -219,1 +219,1 @@\n-                    MemorySessionImpl.heapSession(arr));\n+                    MemorySessionImpl.createHeap(arr));\n@@ -253,1 +253,1 @@\n-                    MemorySessionImpl.heapSession(arr));\n+                    MemorySessionImpl.createHeap(arr));\n@@ -287,1 +287,1 @@\n-                    MemorySessionImpl.heapSession(arr));\n+                    MemorySessionImpl.createHeap(arr));\n@@ -321,1 +321,1 @@\n-                    MemorySessionImpl.heapSession(arr));\n+                    MemorySessionImpl.createHeap(arr));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/HeapMemorySegmentImpl.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -51,2 +51,1 @@\n-        return NIO_ACCESS.newMappedByteBuffer(unmapper, min, (int)length, null,\n-                scope == MemorySessionImpl.GLOBAL ? null : this);\n+        return NIO_ACCESS.newMappedByteBuffer(unmapper, min, (int)length, null, this);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/MappedMemorySegmentImpl.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -36,0 +36,2 @@\n+\n+import jdk.internal.foreign.GlobalSession.HeapSession;\n@@ -62,2 +64,0 @@\n-    public static final MemorySessionImpl GLOBAL = new GlobalSession(null);\n-\n@@ -66,0 +66,2 @@\n+    \/\/ This is the session of all zero-length memory segments\n+    public static final MemorySessionImpl GLOBAL_SESSION = new GlobalSession();\n@@ -146,0 +148,4 @@\n+    public static MemorySessionImpl createHeap(Object ref) {\n+        return new HeapSession(ref);\n+    }\n+\n@@ -233,4 +239,0 @@\n-    public static MemorySessionImpl heapSession(Object ref) {\n-        return new GlobalSession(ref);\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/MemorySessionImpl.java","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -68,1 +68,1 @@\n-        super(0L, false, new GlobalSession(null));\n+        super(0L, false, MemorySessionImpl.GLOBAL_SESSION);\n@@ -90,2 +90,1 @@\n-        return NIO_ACCESS.newDirectByteBuffer(min, (int) this.length, null,\n-                scope == MemorySessionImpl.GLOBAL ? null : this);\n+        return NIO_ACCESS.newDirectByteBuffer(min, (int) this.length, null, this);\n@@ -179,1 +178,1 @@\n-        return new NativeMemorySegmentImpl(min, byteSize, false, new GlobalSession(null));\n+        return new NativeMemorySegmentImpl(min, byteSize, false, MemorySessionImpl.GLOBAL_SESSION);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/NativeMemorySegmentImpl.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,122 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED TestScope\n+ *\/\n+\n+import org.testng.annotations.*;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.SymbolLookup;\n+import java.nio.ByteBuffer;\n+import java.nio.IntBuffer;\n+\n+import static org.testng.Assert.*;\n+\n+public class TestScope {\n+\n+    static {\n+        System.loadLibrary(\"LookupTest\");\n+    }\n+\n+    @Test\n+    public void testDifferentArrayScope() {\n+        MemorySegment.Scope scope1 = MemorySegment.ofArray(new byte[10]).scope();\n+        MemorySegment.Scope scope2 = MemorySegment.ofArray(new byte[10]).scope();\n+        assertNotEquals(scope1, scope2);\n+    }\n+\n+    @Test\n+    public void testDifferentBufferScope() {\n+        MemorySegment.Scope scope1 = MemorySegment.ofBuffer(ByteBuffer.allocateDirect(10)).scope();\n+        MemorySegment.Scope scope2 = MemorySegment.ofBuffer(ByteBuffer.allocateDirect(10)).scope();\n+        assertNotEquals(scope1, scope2);\n+    }\n+\n+    @Test\n+    public void testDifferentArenaScope() {\n+        MemorySegment.Scope scope1 = Arena.ofAuto().allocate(10).scope();\n+        MemorySegment.Scope scope2 = Arena.ofAuto().allocate(10).scope();\n+        assertNotEquals(scope1, scope2);\n+    }\n+\n+    @Test\n+    public void testSameArrayScope() {\n+        byte[] arr = new byte[10];\n+        assertEquals(MemorySegment.ofArray(arr).scope(), MemorySegment.ofArray(arr).scope());\n+        ByteBuffer buf = ByteBuffer.wrap(arr);\n+        assertEquals(MemorySegment.ofArray(arr).scope(), MemorySegment.ofBuffer(buf).scope());\n+        testDerivedBufferScope(MemorySegment.ofArray(arr));\n+    }\n+\n+    @Test\n+    public void testSameBufferScope() {\n+        ByteBuffer buf = ByteBuffer.allocateDirect(10);\n+        assertEquals(MemorySegment.ofBuffer(buf).scope(), MemorySegment.ofBuffer(buf).scope());\n+        testDerivedBufferScope(MemorySegment.ofBuffer(buf));\n+    }\n+\n+    @Test\n+    public void testSameArenaScope() {\n+        try (Arena arena = Arena.ofConfined()) {\n+            MemorySegment segment1 = arena.allocate(10);\n+            MemorySegment segment2 = arena.allocate(10);\n+            assertEquals(segment1.scope(), segment2.scope());\n+            testDerivedBufferScope(segment1);\n+        }\n+    }\n+\n+    @Test\n+    public void testSameNativeScope() {\n+        MemorySegment segment1 = MemorySegment.ofAddress(42);\n+        MemorySegment segment2 = MemorySegment.ofAddress(43);\n+        assertEquals(segment1.scope(), segment2.scope());\n+        assertEquals(segment1.scope(), segment2.reinterpret(10).scope());\n+        assertEquals(segment1.scope(), Arena.global().scope());\n+        testDerivedBufferScope(segment1.reinterpret(10));\n+    }\n+\n+    @Test\n+    public void testSameLookupScope() {\n+        SymbolLookup loaderLookup = SymbolLookup.loaderLookup();\n+        MemorySegment segment1 = loaderLookup.find(\"f\").get();\n+        MemorySegment segment2 = loaderLookup.find(\"c\").get();\n+        assertEquals(segment1.scope(), segment2.scope());\n+        testDerivedBufferScope(segment1.reinterpret(10));\n+    }\n+\n+    void testDerivedBufferScope(MemorySegment segment) {\n+        ByteBuffer buffer = segment.asByteBuffer();\n+        MemorySegment.Scope expectedScope = segment.scope();\n+        assertEquals(MemorySegment.ofBuffer(buffer).scope(), expectedScope);\n+        \/\/ buffer slices should have same scope\n+        ByteBuffer slice = buffer.slice(0, 2);\n+        assertEquals(expectedScope, MemorySegment.ofBuffer(slice).scope());\n+        \/\/ buffer views should have same scope\n+        IntBuffer view = buffer.asIntBuffer();\n+        assertEquals(expectedScope, MemorySegment.ofBuffer(view).scope());\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/java\/foreign\/TestScope.java","additions":122,"deletions":0,"binary":false,"changes":122,"status":"added"}]}