{"files":[{"patch":"@@ -32,2 +32,2 @@\n- * Benchmarks of Patterns that exhibit exponentially degraded performance due\n- * to backtracking, when implemented naively.\n+ * Benchmarks of Patterns that exhibit O(2^N) performance due to catastrophic\n+ * backtracking, **when implemented naively**.\n@@ -42,1 +42,1 @@\n- * (cd $(git rev-parse --show-toplevel) && for size in 8 16 32 64 128; do make test TEST='micro:java.util.regex.Exponential' MICRO=\"FORK=2;WARMUP_ITER=1;ITER=4;OPTIONS=-opi $size -p size=$size\" |& perl -ne 'print if \/^Benchmark\/ .. \/^Finished running test\/'; done)\n+ * (cd $(git rev-parse --show-toplevel) && for size in 16 128 1024; do make test TEST='micro:java.util.regex.Exponential' MICRO=\"FORK=2;WARMUP_ITER=1;ITER=4;OPTIONS=-opi $size -p size=$size\" |& perl -ne 'print if \/^Benchmark\/ .. \/^Finished running test\/'; done)\n@@ -50,1 +50,2 @@\n-    @Param({\"8\", \"16\", \"32\", \"64\", \"128\"})\n+    @Param({\"16\", \"128\", \"1024\"})\n+    \/\/ 2048+ runs into StackOverflowError; see JDK-8260866\n@@ -62,0 +63,10 @@\n+    Pattern compile(String regex) {\n+        Pattern pat = Pattern.compile(regex);\n+        \/\/ ad hoc correctness checking\n+        if (!  pat.matcher(justXs).matches()\n+            || pat.matcher(notJustXs).matches()) {\n+            throw new AssertionError(\"unexpected matching: \" + regex);\n+        }\n+        return pat;\n+    }\n+\n@@ -68,1 +79,1 @@\n-        pat1 = Pattern.compile(\"(?:X|X)*\");\n+        pat1 = compile(\"(?:X|X)*\");\n@@ -71,3 +82,1 @@\n-        pat2 = Pattern.compile(\"(?:[XY]|[XZ])*\");\n-\n-        pat3 = Pattern.compile(\"(X+)+\");\n+        pat2 = compile(\"(?:[XY]|[XZ])*\");\n@@ -75,1 +84,1 @@\n-        pat4 = Pattern.compile(\"^(X+)+$\");\n+        pat3 = compile(\"(X+)+\");\n@@ -77,11 +86,1 @@\n-        \/\/ ad-hoc correctness checking, enabled manually via\n-        \/\/ make test ...TEST=... MICRO=VM_OPTIONS=-ea;...\n-        \/\/ TODO: there must be a better way!\n-        assert pat1_justXs();\n-        assert ! pat1_notJustXs();\n-        assert pat2_justXs();\n-        assert ! pat2_notJustXs();\n-        assert pat3_justXs();\n-        assert ! pat3_notJustXs();\n-        assert pat4_justXs();\n-        assert ! pat4_notJustXs();\n+        pat4 = compile(\"^(X+)+$\");\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/regex\/Exponential.java","additions":19,"deletions":20,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -50,1 +50,2 @@\n-    @Param({\"16\", \"17\", \"64\", \"67\", \"256\", \"257\", \"1024\", \"1031\", \"4096\", \"4099\"})\/\/, \"16384\", \"16411\"})\n+    @Param({\"16\", \"17\", \"256\", \"257\", \"4096\", \"4099\"})\n+    \/\/  \"64\", \"67\", \"1024\", \"1031\", \"16384\", \"16411\"})\n@@ -53,1 +54,1 @@\n-    \/** Unary representation of n *\/\n+    \/** Unary numeral representation of int n *\/\n@@ -56,4 +57,16 @@\n-    public Pattern reluctant1 = Pattern.compile(\"^(11+?)\\\\1+$\");\n-    public Pattern reluctant2 = Pattern.compile(\"^(1{2,}?)\\\\1+$\");\n-    public Pattern greedy1 = Pattern.compile(\"^(11+)\\\\1+$\");\n-    public Pattern greedy2 = Pattern.compile(\"^(1{2,})\\\\1+$\");\n+    \/\/ Patterns that match composite numbers represented as unary numerals.\n+    public Pattern reluctant1;\n+    public Pattern reluctant2;\n+    public Pattern greedy1;\n+    public Pattern greedy2;\n+\n+    Pattern compile(String regex) {\n+        Pattern pat = Pattern.compile(regex);\n+        \/\/ ad hoc correctness checking\n+        boolean isPrime1 = ! pat.matcher(unary).matches();\n+        boolean isPrime2 = java.math.BigInteger.valueOf(n).isProbablePrime(100);\n+        if (isPrime1 != isPrime2) {\n+            throw new AssertionError(\"regex=\" + regex + \", n=\" + n);\n+        }\n+        return pat;\n+    }\n@@ -64,0 +77,5 @@\n+\n+        reluctant1 = compile(\"^(11+?)\\\\1+$\");\n+        reluctant2 = compile(\"^(1{2,}?)\\\\1+$\");\n+        greedy1 = compile(\"^(11+)\\\\1+$\");\n+        greedy2 = compile(\"^(1{2,})\\\\1+$\");\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/regex\/Primality.java","additions":24,"deletions":6,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n- * (cd $(git rev-parse --show-toplevel) && for size in 16 64 256 1024; do make test TEST='micro:java.util.regex.Trim' MICRO=\"FORK=2;WARMUP_ITER=1;ITER=4;OPTIONS=-opi $size -p size=$size\" |& perl -ne 'print if \/^Benchmark\/ .. \/^Finished running test\/'; done)\n+ * (cd $(git rev-parse --show-toplevel) && for size in 16 256 4096; do make test TEST='micro:java.util.regex.Trim' MICRO=\"FORK=2;WARMUP_ITER=1;ITER=4;OPTIONS=-opi $size -p size=$size\" |& perl -ne 'print if \/^Benchmark\/ .. \/^Finished running test\/'; done)\n@@ -81,1 +81,1 @@\n-    @Param({\"16\", \"64\", \"256\", \"1024\"})\n+    @Param({\"16\", \"256\", \"4096\"})\n@@ -96,0 +96,9 @@\n+    Pattern compile(String regex) {\n+        Pattern pat = Pattern.compile(regex);\n+        \/\/ ad hoc correctness checking\n+        if (pat.matcher(noMatch).find()) {\n+            throw new AssertionError(\"unexpected matching: \" + regex);\n+        }\n+        return pat;\n+    }\n+\n@@ -100,0 +109,6 @@\n+        simplePattern = compile(\"[ \\t]+$\");\n+        possessivePattern = compile(\"[ \\t]++$\");\n+        possessivePattern2 = compile(\"(.*+[^ \\t]|^)([ \\t]++)$\");\n+        possessivePattern3 = compile(\"(?:[^ \\t]|^)([ \\t]++)$\");\n+        lookBehindPattern = compile(\"(?<![ \\t])[ \\t]++$\");\n+\n@@ -103,17 +118,4 @@\n-        simplePattern = Pattern.compile(\"[ \\t]+$\");\n-        possessivePattern = Pattern.compile(\"[ \\t]++$\");\n-        possessivePattern2 = Pattern.compile(\"(.*+[^ \\t]|^)([ \\t]++)$\");\n-        possessivePattern3 = Pattern.compile(\"(?:[^ \\t]|^)([ \\t]++)$\");\n-        lookBehindPattern = Pattern.compile(\"(?<![ \\t])[ \\t]++$\");\n-\n-        \/\/ ad-hoc correctness checking, enabled manually via\n-        \/\/ make test ...TEST=... MICRO=VM_OPTIONS=-ea;...\n-        \/\/ TODO: there must be a better way!\n-        assert ! simple_find();\n-        assert ! possessive_find();\n-        assert ! possessive2_find();\n-        assert ! possessive2_matches();\n-        assert ! possessive3_find();\n-        assert ! lookBehind_find();\n-        assert ! find_loop_two_matchers();\n-        assert ! find_loop_usePattern();\n+        \/\/ more ad hoc correctness checking\n+        if (possessive2_matches()) throw new AssertionError();\n+        if (find_loop_two_matchers()) throw new AssertionError();\n+        if (find_loop_usePattern()) throw new AssertionError();\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/regex\/Trim.java","additions":21,"deletions":19,"binary":false,"changes":40,"status":"modified"}]}