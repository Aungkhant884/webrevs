{"files":[{"patch":"@@ -28,1 +28,1 @@\n-\/\/ The third line is a concatentation of the match, the number of groups,\n+\/\/ The third line is a concatenation of the match, the number of groups,\n@@ -1234,0 +1234,42 @@\n+\n+\/\/----------------------------------------------------------------\n+\/\/ Unary numeral primality testing\n+\/\/----------------------------------------------------------------\n+\n+\/\/ Input is 7 (a prime), in unary; reluctant quantifier\n+^(11+?)\\1+$\n+1111111\n+false 1\n+\n+^(1{2,}?)\\1+$\n+1111111\n+false 1\n+\n+\/\/ Input is 8 (a power of two), in unary; reluctant quantifier\n+\/\/ group is shortest possible (2)\n+^(11+?)\\1+$\n+11111111\n+true 11111111 1 11\n+\n+^(1{2,}?)\\1+$\n+11111111\n+true 11111111 1 11\n+\n+\/\/ Input is 7 (a prime), in unary; greedy quantifier\n+^(11+)\\1+$\n+1111111\n+false 1\n+\n+^(1{2,})\\1+$\n+1111111\n+false 1\n+\n+\/\/ Input is 8 (a power of two), in unary; greedy quantifier\n+\/\/ group is longest possible (4)\n+^(11+)\\1+$\n+11111111\n+true 11111111 1 1111\n+\n+^(1{2,})\\1+$\n+11111111\n+true 11111111 1 1111\n","filename":"test\/jdk\/java\/util\/regex\/TestCases.txt","additions":43,"deletions":1,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -25,8 +25,1 @@\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.BenchmarkMode;\n-import org.openjdk.jmh.annotations.Mode;\n-import org.openjdk.jmh.annotations.OutputTimeUnit;\n-import org.openjdk.jmh.annotations.Param;\n-import org.openjdk.jmh.annotations.Scope;\n-import org.openjdk.jmh.annotations.Setup;\n-import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.*;\n@@ -63,1 +56,1 @@\n- * (cd $(hg root) && for size in 3 16 999 999999; do make test TEST=\"micro:java.lang.ArrayFiddle\" MICRO=\"FORK=2;WARMUP_ITER=4;ITER=4;OPTIONS=-opi $size -p size=$size\" |& perl -ne 'print if \/^Benchmark\/ .. \/^Finished running test\/'; done)\n+ * (cd $(git rev-parse --show-toplevel) && for size in 3 16 999 999999; do make test TEST='micro:java.lang.ArrayFiddle' MICRO=\"FORK=2;WARMUP_ITER=4;ITER=4;OPTIONS=-opi $size -p size=$size\" |& perl -ne 'print if \/^Benchmark\/ .. \/^Finished running test\/'; done)\n@@ -66,0 +59,3 @@\n+@Fork(2)\n+@Warmup(iterations = 1)\n+@Measurement(iterations = 4)\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/ArrayFiddle.java","additions":5,"deletions":9,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -0,0 +1,140 @@\n+\/*\n+ * Copyright 2020 Google Inc.  All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.util.regex;\n+\n+import org.openjdk.jmh.annotations.*;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+\/**\n+ * Benchmarks of Patterns that exhibit O(2^N) performance due to catastrophic\n+ * backtracking, **when implemented naively**.\n+ *\n+ * See: jdk\/test\/java\/util\/regex\/RegExTest.java#expoBacktracking\n+ * commit b45ea8903ec290ab194d9ebe040bc43edd5dd0a3\n+ * Author: Xueming Shen <sherman@openjdk.org>\n+ * Date:   Tue May 10 21:19:25 2016 -0700\n+ *\n+ * Here's a way to compare the per-char cost:\n+ *\n+ * (cd $(git rev-parse --show-toplevel) && for size in 16 128 1024; do make test TEST='micro:java.util.regex.Exponential' MICRO=\"FORK=1;WARMUP_ITER=1;ITER=4;OPTIONS=-opi $size -p size=$size\" |& perl -ne 'print if \/^Benchmark\/ .. \/^Finished running test\/'; done)\n+ *\n+ *\/\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Fork(1)\n+@Warmup(iterations = 1)\n+@Measurement(iterations = 4)\n+@State(Scope.Benchmark)\n+public class Exponential {\n+    \/** Run length of non-matching consecutive whitespace chars. *\/\n+    @Param({\"16\", \"128\", \"1024\"})\n+    \/\/ 2048+ runs into StackOverflowError; see JDK-8260866\n+    int size;\n+\n+    public String justXs;\n+    public String notJustXs;\n+\n+    \/\/ Patterns that match justXs but not notJustXs\n+    public Pattern pat1;\n+    public Pattern pat2;\n+    public Pattern pat3;\n+    public Pattern pat4;\n+\n+    Pattern compile(String regex) {\n+        Pattern pat = Pattern.compile(regex);\n+        \/\/ ad hoc correctness checking\n+        if (!  pat.matcher(justXs).matches()\n+            || pat.matcher(notJustXs).matches()) {\n+            throw new AssertionError(\"unexpected matching: \" + regex);\n+        }\n+        return pat;\n+    }\n+\n+    @Setup(Level.Trial)\n+    public void setup() {\n+        justXs = \"X\".repeat(size);\n+        notJustXs = justXs + \"!\";\n+\n+        \/\/ Will (or should) the engine optimize (?:X|X) to X ?\n+        pat1 = compile(\"(?:X|X)*\");\n+\n+        \/\/ Tougher to optimize than pat1\n+        pat2 = compile(\"(?:[XY]|[XZ])*\");\n+\n+        pat3 = compile(\"(X+)+\");\n+\n+        pat4 = compile(\"^(X+)+$\");\n+     }\n+\n+    \/** O(N) *\/\n+    @Benchmark\n+    public boolean pat1_justXs() {\n+        return pat1.matcher(justXs).matches();\n+    }\n+\n+    \/** O(N) *\/\n+    @Benchmark\n+    public boolean pat1_notJustXs() {\n+        return pat1.matcher(notJustXs).matches();\n+    }\n+\n+    \/** O(N) *\/\n+    @Benchmark\n+    public boolean pat2_justXs() {\n+        return pat2.matcher(justXs).matches();\n+    }\n+\n+    \/** O(N) *\/\n+    @Benchmark\n+    public boolean pat2_notJustXs() {\n+        return pat2.matcher(notJustXs).matches();\n+    }\n+\n+    \/** O(1) - very surprising! *\/\n+    @Benchmark\n+    public boolean pat3_justXs() {\n+        return pat3.matcher(justXs).matches();\n+    }\n+\n+    \/** O(N^2) - surprising!  O(N) seems very achievable. *\/\n+    @Benchmark\n+    public boolean pat3_notJustXs() {\n+        return pat3.matcher(notJustXs).matches();\n+    }\n+\n+    \/** O(1) - very surprising! *\/\n+    @Benchmark\n+    public boolean pat4_justXs() {\n+        return pat4.matcher(justXs).matches();\n+    }\n+\n+    \/** O(N^2) - surprising!  O(N) seems very achievable. *\/\n+    @Benchmark\n+    public boolean pat4_notJustXs() {\n+        return pat4.matcher(notJustXs).matches();\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/regex\/Exponential.java","additions":140,"deletions":0,"binary":false,"changes":140,"status":"added"},{"patch":"@@ -0,0 +1,106 @@\n+\/*\n+ * Copyright 2020 Google Inc.  All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.util.regex;\n+\n+import org.openjdk.jmh.annotations.*;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Pattern;\n+\n+\/**\n+ * Abusing regexes for fun primality testing.\n+ * Famous among regex enthusiasts.\n+ * https:\/\/stackoverflow.com\/q\/3296050\/625403\n+ *\n+ * Prime numbers exhibit O(N^2) performance with all variants, due to exhaustive\n+ * backtracking.\n+ *\n+ * Powers of two exhibit O(N) performance with all variants, with reluctant\n+ * quantifiers doing somewhat better.\n+ *\n+ * Here's a way to compare the per-input-char cost:\n+ *\n+ * (cd $(git rev-parse --show-toplevel) && for n in 16 17 256 257 4096 4099; do make test TEST='micro:java.util.regex.Primality' MICRO=\"FORK=1;WARMUP_ITER=1;ITER=4;OPTIONS=-opi $n -p n=$n\" |& perl -ne 'print if \/^Benchmark\/ .. \/^Finished running test\/'; done)\n+ *\/\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Fork(1)\n+@Warmup(iterations = 1)\n+@Measurement(iterations = 4)\n+@State(Scope.Benchmark)\n+public class Primality {\n+    \/** Number to be primality tested. *\/\n+    @Param({\"16\", \"17\", \"256\", \"257\", \"4096\", \"4099\"})\n+    \/\/  \"64\", \"67\", \"1024\", \"1031\", \"16384\", \"16411\"})\n+    int n;\n+\n+    \/** Unary numeral representation of int n *\/\n+    public String unary;\n+\n+    \/\/ Patterns that match composite numbers represented as unary numerals.\n+    public Pattern reluctant1;\n+    public Pattern reluctant2;\n+    public Pattern greedy1;\n+    public Pattern greedy2;\n+\n+    Pattern compile(String regex) {\n+        Pattern pat = Pattern.compile(regex);\n+        \/\/ ad hoc correctness checking\n+        boolean isPrime1 = ! pat.matcher(unary).matches();\n+        boolean isPrime2 = java.math.BigInteger.valueOf(n).isProbablePrime(100);\n+        if (isPrime1 != isPrime2) {\n+            throw new AssertionError(\"regex=\" + regex + \", n=\" + n);\n+        }\n+        return pat;\n+    }\n+\n+    @Setup(Level.Trial)\n+    public void setup() {\n+        unary = \"1\".repeat(n);\n+\n+        reluctant1 = compile(\"^(11+?)\\\\1+$\");\n+        reluctant2 = compile(\"^(1{2,}?)\\\\1+$\");\n+        greedy1 = compile(\"^(11+)\\\\1+$\");\n+        greedy2 = compile(\"^(1{2,})\\\\1+$\");\n+    }\n+\n+    @Benchmark\n+    public boolean reluctant1() {\n+        return reluctant1.matcher(unary).matches();\n+    }\n+\n+    @Benchmark\n+    public boolean reluctant2() {\n+        return reluctant2.matcher(unary).matches();\n+    }\n+\n+    @Benchmark\n+    public boolean greedy1() {\n+        return greedy1.matcher(unary).matches();\n+    }\n+\n+    @Benchmark\n+    public boolean greedy2() {\n+        return greedy2.matcher(unary).matches();\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/regex\/Primality.java","additions":106,"deletions":0,"binary":false,"changes":106,"status":"added"},{"patch":"@@ -0,0 +1,182 @@\n+\/*\n+ * Copyright 2020 Google Inc.  All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.util.regex;\n+\n+import org.openjdk.jmh.annotations.*;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+\/**\n+ * Detecting trailing whitespace is a very common problem that many programmers\n+ * have solved, but it's surprisingly difficult to avoid O(N^2) performance\n+ * when the input contains a long run of consecutive whitespace.  For\n+ * example, attempts to trim such whitespace caused a Stack Exchange outage.\n+ * https:\/\/stackstatus.net\/post\/147710624694\/outage-postmortem-july-20-2016\n+ *\n+ * We use \"[ \\t]\" as our definition of whitespace (easy, but not too easy!).\n+ *\n+ * The use of Matcher#find (instead of Matcher#matches) is very convenient, but\n+ * introduces an implicit O(N) loop over the input, or alternatively, a\n+ * non-possessive \"^.*?\" prefix in the regex.  In order for the entire search\n+ * operation to not be O(N^2), most of the regex match operations while\n+ * scanning the input need to be O(1), which may require the use of less-obvious\n+ * constructs like lookbehind.  The use of possessive quantifiers in the regex\n+ * itself is sadly **insufficient**.\n+ *\n+ * When the subpattern following a possessive quantifier is as cheap as the\n+ * subpattern governed by the quantifier (e.g. \\s++$), the possessive quantifier\n+ * gives you at most 2x speedup, reducing two linear scans to one.\n+ *\n+ * An explicit loop with find() using two matchers and possessive quantifiers is\n+ * the most efficient, since there is no backtracking.  But that cannot work with\n+ * simple APIs that take a regex as an argument, like grep(1) does.\n+ *\n+ * Here's a way to compare the per-char cost:\n+ *\n+ * (cd $(git rev-parse --show-toplevel) && for size in 16 256 4096; do make test TEST='micro:java.util.regex.Trim' MICRO=\"FORK=1;WARMUP_ITER=1;ITER=4;OPTIONS=-opi $size -p size=$size\" |& perl -ne 'print if \/^Benchmark\/ .. \/^Finished running test\/'; done)\n+ *\n+ * some jdk17 numbers:\n+ *\n+ * Benchmark                    (size)  Mode  Cnt     Score    Error  Units\n+ * Trim.find_loop_two_matchers    1024  avgt    8     2.252 ?  0.013  ns\/op\n+ * Trim.find_loop_usePattern      1024  avgt    8     2.328 ?  0.116  ns\/op\n+ * Trim.lookBehind_find           1024  avgt    8    21.740 ?  0.040  ns\/op\n+ * Trim.possessive2_find          1024  avgt    8  7151.592 ? 17.860  ns\/op\n+ * Trim.possessive2_matches       1024  avgt    8     2.625 ?  0.008  ns\/op\n+ * Trim.possessive3_find          1024  avgt    8    28.532 ?  1.889  ns\/op\n+ * Trim.possessive_find           1024  avgt    8  3113.776 ?  9.996  ns\/op\n+ * Trim.simple_find               1024  avgt    8  4199.480 ? 13.410  ns\/op\n+ *\n+ * TODO: why is simple_find faster than possessive_find, for size below 512 ?\n+ *\n+ * (cd $(git rev-parse --show-toplevel) && for size in 128 256 512 1024 2048; do make test TEST='micro:java.util.regex.Trim.\\\\\\(simple_find\\\\\\|possessive_find\\\\\\)' MICRO=\"FORK=2;WARMUP_ITER=1;ITER=4;OPTIONS=-opi $size -p size=$size\" |& perl -ne 'print if \/^Benchmark\/ .. \/^Finished running test\/'; done)\n+ *\/\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Fork(1)\n+@Warmup(iterations = 1)\n+@Measurement(iterations = 4)\n+@State(Scope.Benchmark)\n+public class Trim {\n+    \/** Run length of non-matching consecutive whitespace chars. *\/\n+    @Param({\"16\", \"256\", \"4096\"})\n+    int size;\n+\n+    \/** String containing long interior run of whitespace *\/\n+    public String noMatch;\n+\n+    public Pattern whitespaceRunPattern;\n+    public Pattern eolPattern;\n+\n+    public Pattern simplePattern;\n+    public Pattern possessivePattern;\n+    public Pattern possessivePattern2;\n+    public Pattern possessivePattern3;\n+    public Pattern lookBehindPattern;\n+\n+    Pattern compile(String regex) {\n+        Pattern pat = Pattern.compile(regex);\n+        \/\/ ad hoc correctness checking\n+        if (pat.matcher(noMatch).find()) {\n+            throw new AssertionError(\"unexpected matching: \" + regex);\n+        }\n+        return pat;\n+    }\n+\n+    @Setup(Level.Trial)\n+    public void setup() {\n+        noMatch = \"xx\" + \" \\t\".repeat(size) + \"yy\";\n+\n+        simplePattern = compile(\"[ \\t]+$\");\n+        possessivePattern = compile(\"[ \\t]++$\");\n+        possessivePattern2 = compile(\"(.*+[^ \\t]|^)([ \\t]++)$\");\n+        possessivePattern3 = compile(\"(?:[^ \\t]|^)([ \\t]++)$\");\n+        lookBehindPattern = compile(\"(?<![ \\t])[ \\t]++$\");\n+\n+        whitespaceRunPattern = Pattern.compile(\"[ \\t]++\");\n+        eolPattern = Pattern.compile(\"$\", Pattern.MULTILINE);\n+\n+        \/\/ more ad hoc correctness checking\n+        if (possessive2_matches()) throw new AssertionError();\n+        if (find_loop_two_matchers()) throw new AssertionError();\n+        if (find_loop_usePattern()) throw new AssertionError();\n+    }\n+\n+    @Benchmark\n+    public boolean simple_find() {\n+        return simplePattern.matcher(noMatch).find();\n+    }\n+\n+    @Benchmark\n+    public boolean possessive_find() {\n+        return possessivePattern.matcher(noMatch).find();\n+    }\n+\n+    @Benchmark\n+    public boolean possessive2_find() {\n+        return possessivePattern2.matcher(noMatch).find();\n+    }\n+\n+    @Benchmark\n+    public boolean possessive2_matches() {\n+        return possessivePattern2.matcher(noMatch).matches();\n+    }\n+\n+    @Benchmark\n+    public boolean possessive3_find() {\n+        return possessivePattern3.matcher(noMatch).find();\n+    }\n+\n+    @Benchmark\n+    public boolean lookBehind_find() {\n+        return lookBehindPattern.matcher(noMatch).find();\n+    }\n+\n+    @Benchmark\n+    public boolean find_loop_two_matchers() {\n+        Matcher m = whitespaceRunPattern.matcher(noMatch);\n+        int endOfString = m.regionEnd();\n+        while (m.find()) {\n+            if (eolPattern.matcher(noMatch).region(m.end(), endOfString).lookingAt())\n+                return true;\n+        }\n+        return false;\n+    }\n+\n+    @Benchmark\n+    public boolean find_loop_usePattern() {\n+        Matcher m = whitespaceRunPattern.matcher(noMatch);\n+        int endOfString = m.regionEnd();\n+        while (m.find()) {\n+            m.region(m.end(), endOfString);\n+            m.usePattern(eolPattern);\n+            if (m.lookingAt())\n+                return true;\n+            m.usePattern(whitespaceRunPattern);\n+        }\n+        return false;\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/regex\/Trim.java","additions":182,"deletions":0,"binary":false,"changes":182,"status":"added"}]}