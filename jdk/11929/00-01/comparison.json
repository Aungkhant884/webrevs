{"files":[{"patch":"@@ -241,2 +241,0 @@\n-            } else {\n-                return v >= MIN_TLS_SUPPORTED.id && v <= MAX_TLS_SUPPORTED.id;\n@@ -244,0 +242,1 @@\n+            return true;\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/ProtocolVersion.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,257 @@\n+\/*\n+ * Copyright (c) 2014, 2023 Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8042449 8299870\n+ * @summary Verify successful handshake ignores invalid record version\n+ *\n+ * @run main\/timeout=300 HandshakeWithInvalidRecordVersion\n+ *\/\n+\n+import javax.net.ssl.*;\n+import javax.net.ssl.SSLEngineResult.*;\n+import java.io.*;\n+import java.security.*;\n+import java.nio.*;\n+import java.util.Arrays;\n+\n+public class HandshakeWithInvalidRecordVersion {\n+    private static final boolean DEBUG = Boolean.getBoolean(\"test.debug\");\n+\n+    private static final String PATH_TO_STORES = \"..\/etc\";\n+    private static final String KEYSTORE_FILE = \"keystore\";\n+    private static final String TRUSTSTORE_FILE = \"truststore\";\n+\n+    private static final String KEYSTORE_PATH =\n+            System.getProperty(\"test.src\", \".\/\") + \"\/\" + PATH_TO_STORES +\n+                    \"\/\" + KEYSTORE_FILE;\n+    private static final String TRUSTSTORE_PATH =\n+            System.getProperty(\"test.src\", \".\/\") + \"\/\" + PATH_TO_STORES +\n+                    \"\/\" + TRUSTSTORE_FILE;\n+\n+    private static SSLContext getSSLContext() throws Exception {\n+        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n+        KeyStore ts = KeyStore.getInstance(KeyStore.getDefaultType());\n+        char[] passphrase = \"passphrase\".toCharArray();\n+\n+        ks.load(new FileInputStream(KEYSTORE_PATH), passphrase);\n+        ts.load(new FileInputStream(TRUSTSTORE_PATH), passphrase);\n+\n+        KeyManagerFactory kmf = KeyManagerFactory.getInstance(\"SunX509\");\n+        kmf.init(ks, passphrase);\n+\n+        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n+        tmf.init(ts);\n+\n+        SSLContext sslCtx = SSLContext.getInstance(\"TLS\");\n+\n+        sslCtx.init(kmf.getKeyManagers(), tmf.getTrustManagers(), null);\n+\n+        return sslCtx;\n+    }\n+\n+    public static void main(String [] args) throws Exception {\n+        executeTest(\"TLSv1.2\",\n+                new String[]{\"TLSv1.2\"}, new String[]{\"TLSv1.3\", \"TLSv1.2\"});\n+\n+        executeTest(\"TLSv1.2\",\n+                new String[]{\"TLSv1.3\", \"TLSv1.2\"}, new String[]{\"TLSv1.2\"});\n+\n+        executeTest(\"TLSv1.3\",\n+                new String[]{\"TLSv1.2\", \"TLSv1.3\"}, new String[]{\"TLSv1.3\"});\n+\n+        executeTest(\"TLSv1.3\",\n+                new String[]{\"TLSv1.3\"}, new String[]{\"TLSv1.2\", \"TLSv1.3\"});\n+    }\n+\n+\n+    private static void executeTest(String expectedProtocol, String[] clientProtocols,\n+                                    String[] serverProtocols) throws Exception {\n+        System.out.printf(\"Executing test%n\"\n+                + \"Client protocols: %s%nServer protocols: %s%nExpected negotiated: %s%n\",\n+                Arrays.toString(clientProtocols), Arrays.toString(serverProtocols),\n+                expectedProtocol);\n+\n+        SSLContext context = getSSLContext();\n+\n+        SSLEngine cliEngine = context.createSSLEngine();\n+        cliEngine.setUseClientMode(true);\n+        cliEngine.setEnabledProtocols(clientProtocols);\n+        SSLEngine srvEngine = context.createSSLEngine();\n+        srvEngine.setUseClientMode(false);\n+        srvEngine.setEnabledProtocols(serverProtocols);\n+\n+        SSLSession session = cliEngine.getSession();\n+        int netBufferMax = session.getPacketBufferSize();\n+        int appBufferMax = session.getApplicationBufferSize();\n+\n+        ByteBuffer cliToSrv = ByteBuffer.allocateDirect(netBufferMax);\n+        ByteBuffer srvIBuff = ByteBuffer.allocateDirect(appBufferMax + 50);\n+        ByteBuffer cliOBuff = ByteBuffer.wrap(\"I'm client\".getBytes());\n+\n+\n+        System.out.println(\"Generating ClientHello\");\n+        SSLEngineResult cliRes = cliEngine.wrap(cliOBuff, cliToSrv);\n+        checkResult(cliRes, HandshakeStatus.NEED_UNWRAP);\n+        log(\"Client wrap result: \" + cliRes);\n+        cliToSrv.flip();\n+        if (cliToSrv.limit() > 5) {\n+            System.out.println(\"Setting record version to (0xa9, 0xa2)\");\n+            cliToSrv.put(1, (byte)0xa9);\n+            cliToSrv.put(2, (byte)0xa2);\n+        } else {\n+            throw new RuntimeException(\"ClientHello message is only \"\n+                    + cliToSrv.limit() + \"bytes. Expecting at least 6 bytes. \");\n+        }\n+\n+        System.out.println(\"Processing ClientHello\");\n+        SSLEngineResult srv = srvEngine.unwrap(cliToSrv, srvIBuff);\n+        checkResult(srv, HandshakeStatus.NEED_TASK);\n+        runDelegatedTasks(srvEngine);\n+\n+        finishHandshake(cliEngine, srvEngine);\n+\n+        if (!cliEngine.getSession().getProtocol()\n+                .equals(srvEngine.getSession().getProtocol())\n+            || !cliEngine.getSession().getProtocol().equals(expectedProtocol)) {\n+            throw new RuntimeException(\"Client and server did not negotiate protocol. \"\n+                    + \"Expected: \" + expectedProtocol + \". Negotiated: \"\n+                    + cliEngine.getSession().getProtocol());\n+        }\n+    }\n+    private static boolean isHandshaking(SSLEngine e) {\n+        return (e.getHandshakeStatus() != HandshakeStatus.NOT_HANDSHAKING);\n+    }\n+\n+    private static void finishHandshake(SSLEngine client, SSLEngine server) throws Exception {\n+        boolean clientDone = false;\n+        boolean serverDone = false;\n+        SSLEngineResult serverResult;\n+        SSLEngineResult clientResult;\n+        int capacity = client.getSession().getPacketBufferSize();\n+        ByteBuffer emptyBuffer = ByteBuffer.allocate(capacity);\n+        ByteBuffer serverToClient = ByteBuffer.allocate(capacity);\n+        ByteBuffer clientToServer = ByteBuffer.allocate(capacity);\n+\n+        System.out.println(\"Finishing handshake...\");\n+        while (isHandshaking(client) ||\n+                isHandshaking(server)) {\n+\n+            log(\"================\");\n+\n+            clientResult = client.wrap(emptyBuffer, clientToServer);\n+            serverResult = server.wrap(emptyBuffer, serverToClient);\n+\n+            if (clientResult.getHandshakeStatus() == HandshakeStatus.FINISHED) {\n+                clientDone = true;\n+            }\n+\n+            if (serverResult.getHandshakeStatus() == HandshakeStatus.FINISHED) {\n+                serverDone = true;\n+            }\n+\n+            log(\"wrap1 = \" + clientResult);\n+            log(\"wrap2 = \" + serverResult);\n+\n+            if (clientResult.getHandshakeStatus() == HandshakeStatus.NEED_TASK) {\n+                Runnable runnable;\n+                while ((runnable = client.getDelegatedTask()) != null) {\n+                    runnable.run();\n+                }\n+            }\n+\n+            if (serverResult.getHandshakeStatus() == HandshakeStatus.NEED_TASK) {\n+                Runnable runnable;\n+                while ((runnable = server.getDelegatedTask()) != null) {\n+                    runnable.run();\n+                }\n+            }\n+\n+            clientToServer.flip();\n+            serverToClient.flip();\n+\n+            log(\"----\");\n+\n+            clientResult = client.unwrap(serverToClient, emptyBuffer);\n+            serverResult = server.unwrap(clientToServer, emptyBuffer);\n+\n+            if (clientResult.getHandshakeStatus() == HandshakeStatus.FINISHED) {\n+                clientDone = true;\n+            }\n+\n+            if (serverResult.getHandshakeStatus() == HandshakeStatus.FINISHED) {\n+                serverDone = true;\n+            }\n+\n+            log(\"unwrap1 = \" + clientResult);\n+            log(\"unwrap2 = \" + serverResult);\n+\n+            if (clientResult.getHandshakeStatus() == HandshakeStatus.NEED_TASK) {\n+                Runnable runnable;\n+                while ((runnable = client.getDelegatedTask()) != null) {\n+                    runnable.run();\n+                }\n+            }\n+\n+            if (serverResult.getHandshakeStatus() == HandshakeStatus.NEED_TASK) {\n+                Runnable runnable;\n+                while ((runnable = server.getDelegatedTask()) != null) {\n+                    runnable.run();\n+                }\n+            }\n+\n+            clientToServer.clear();\n+            serverToClient.clear();\n+        }\n+\n+        System.out.println(\"Handshake complete\");\n+\n+        if (!clientDone || !serverDone) {\n+            throw new RuntimeException(\"Both should be true:\\n\" +\n+                    \" clientDone = \" + clientDone + \" serverDone = \" + serverDone);\n+        }\n+    }\n+\n+    private static void runDelegatedTasks(SSLEngine engine) {\n+        Runnable runnable;\n+        while ((runnable = engine.getDelegatedTask()) != null) {\n+            log(\"\\trunning delegated task...\");\n+            runnable.run();\n+        }\n+    }\n+\n+    private static void checkResult(SSLEngineResult result, HandshakeStatus expectedStatus) {\n+        if(result.getHandshakeStatus() != expectedStatus) {\n+            throw new RuntimeException(String.format(\n+                    \"Handshake status %s does not match expected status of %s\",\n+                    result.getHandshakeStatus(), expectedStatus));\n+        }\n+    }\n+\n+    private static void log(Object msg) {\n+        if (DEBUG) {\n+            System.out.println(msg);\n+        }\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/javax\/net\/ssl\/SSLEngine\/HandshakeWithInvalidRecordVersion.java","additions":257,"deletions":0,"binary":false,"changes":257,"status":"added"},{"patch":"@@ -1,77 +0,0 @@\n-\/*\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/\/ This test case relies on updated static security property, no way to re-use\n-\/\/ security property in samevm\/agentvm mode.\n-\n-\/*\n- * @test\n- * @bug 8042449\n- * @summary Issue for negative byte major record version\n- *\n- * @run main\/othervm IllegalRecordVersion\n- *\/\n-\n-import javax.net.ssl.*;\n-import javax.net.ssl.SSLEngineResult.*;\n-import java.io.*;\n-import java.security.*;\n-import java.nio.*;\n-\n-public class IllegalRecordVersion {\n-\n-    public static void main(String args[]) throws Exception {\n-        SSLContext context = SSLContext.getDefault();\n-\n-        SSLEngine cliEngine = context.createSSLEngine();\n-        cliEngine.setUseClientMode(true);\n-        SSLEngine srvEngine = context.createSSLEngine();\n-        srvEngine.setUseClientMode(false);\n-\n-        SSLSession session = cliEngine.getSession();\n-        int netBufferMax = session.getPacketBufferSize();\n-        int appBufferMax = session.getApplicationBufferSize();\n-\n-        ByteBuffer cliToSrv = ByteBuffer.allocateDirect(netBufferMax);\n-        ByteBuffer srvIBuff = ByteBuffer.allocateDirect(appBufferMax + 50);\n-        ByteBuffer cliOBuff = ByteBuffer.wrap(\"I'm client\".getBytes());\n-\n-\n-        System.out.println(\"client hello (record version(0xa9, 0xa2))\");\n-        SSLEngineResult cliRes = cliEngine.wrap(cliOBuff, cliToSrv);\n-        System.out.println(\"Client wrap result: \" + cliRes);\n-        cliToSrv.flip();\n-        if (cliToSrv.limit() > 5) {\n-            cliToSrv.put(1, (byte)0xa9);\n-            cliToSrv.put(2, (byte)0xa2);\n-        }\n-\n-        try {\n-            srvEngine.unwrap(cliToSrv, srvIBuff);\n-            throw new Exception(\n-                \"Cannot catch the unsupported record version issue\");\n-        } catch (SSLException e) {\n-            \/\/ get the expected exception\n-        }\n-    }\n-}\n","filename":"test\/jdk\/javax\/net\/ssl\/SSLEngine\/IllegalRecordVersion.java","additions":0,"deletions":77,"binary":false,"changes":77,"status":"deleted"}]}