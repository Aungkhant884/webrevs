{"files":[{"patch":"@@ -63,0 +63,1 @@\n+size_t CollectedHeap::_lab_alignment_reserve = ~(size_t)0;\n@@ -245,0 +246,8 @@\n+  \/\/ If the minimum object size is greater than MinObjAlignment, we can\n+  \/\/ end up with a shard at the end of the buffer that's smaller than\n+  \/\/ the smallest object.  We can't allow that because the buffer must\n+  \/\/ look like it's full of objects when we retire it, so we make\n+  \/\/ sure we have enough space for a filler int array object.\n+  size_t min_size = min_dummy_object_size();\n+  _lab_alignment_reserve = min_size > (size_t)MinObjAlignment ? align_object_size(min_size) : 0;\n+\n@@ -509,5 +518,0 @@\n-size_t CollectedHeap::tlab_alloc_reserve() const {\n-  size_t min_size = min_dummy_object_size();\n-  return min_size > (size_t)MinObjAlignment ? align_object_size(min_size) : 0;\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.cpp","additions":9,"deletions":5,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -117,0 +117,2 @@\n+  \/\/ (Minimum) Alignment reserve for TLABs and PLABs.\n+  static size_t _lab_alignment_reserve;\n@@ -315,1 +317,4 @@\n-  size_t tlab_alloc_reserve() const;\n+  static size_t lab_alignment_reserve() {\n+    assert(_lab_alignment_reserve != ~(size_t)0, \"uninitialized\");\n+    return _lab_alignment_reserve;\n+  }\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.hpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-  return align_object_size(MAX2(MinTLABSize \/ HeapWordSize, (size_t)oopDesc::header_size())) + AlignmentReserve;\n+  return align_object_size(MAX2(MinTLABSize \/ HeapWordSize, (size_t)oopDesc::header_size())) + CollectedHeap::lab_alignment_reserve();\n@@ -48,2 +48,1 @@\n-  AlignmentReserve = Universe::heap()->tlab_alloc_reserve();\n-  assert(min_size() > AlignmentReserve,\n+  assert(min_size() > CollectedHeap::lab_alignment_reserve(),\n@@ -51,1 +50,1 @@\n-         \"to be able to contain objects\", min_size(), AlignmentReserve);\n+         \"to be able to contain objects\", min_size(), CollectedHeap::lab_alignment_reserve());\n@@ -54,7 +53,0 @@\n-\/\/ If the minimum object size is greater than MinObjAlignment, we can\n-\/\/ end up with a shard at the end of the buffer that's smaller than\n-\/\/ the smallest object.  We can't allow that because the buffer must\n-\/\/ look like it's full of objects when we retire it, so we make\n-\/\/ sure we have enough space for a filler int array object.\n-size_t PLAB::AlignmentReserve;\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/plab.cpp","additions":3,"deletions":11,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"gc\/shared\/collectedHeap.hpp\"\n@@ -49,1 +50,0 @@\n-  static size_t AlignmentReserve;\n@@ -76,1 +76,1 @@\n-  static size_t size_required_for_allocation(size_t word_size) { return word_size + AlignmentReserve; }\n+  static size_t size_required_for_allocation(size_t word_size) { return word_size + CollectedHeap::lab_alignment_reserve(); }\n@@ -120,1 +120,1 @@\n-    assert(new_word_sz > AlignmentReserve, \"Too small\");\n+    assert(new_word_sz > CollectedHeap::lab_alignment_reserve(), \"Too small\");\n@@ -126,1 +126,1 @@\n-    _end      = _hard_end - AlignmentReserve;\n+    _end      = _hard_end - CollectedHeap::lab_alignment_reserve();\n","filename":"src\/hotspot\/share\/gc\/shared\/plab.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -474,1 +474,1 @@\n-  size_t reserve_size = Universe::heap()->tlab_alloc_reserve();\n+  size_t reserve_size = CollectedHeap::lab_alignment_reserve();\n","filename":"src\/hotspot\/share\/gc\/shared\/threadLocalAllocBuffer.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}