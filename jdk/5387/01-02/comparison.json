{"files":[{"patch":"@@ -369,1 +369,1 @@\n-class CodeBuffer: public StackObj DEBUG_ONLY(COMMA private Scrubber) {\n+class CodeBuffer: public ResourceObj DEBUG_ONLY(COMMA private Scrubber) {\n@@ -377,2 +377,0 @@\n-  void* operator new(size_t size) throw() { return ResourceObj::operator new(size); }\n-  void  operator delete(void* p)          { ShouldNotCallThis(); }\n","filename":"src\/hotspot\/share\/asm\/codeBuffer.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -66,1 +66,1 @@\n-      ResourceObj(cp),\n+      ResourceObj(),\n","filename":"src\/hotspot\/share\/classfile\/stackMapFrame.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -109,1 +109,1 @@\n-  DEBUG_ONLY(set_type(ARENA);)\n+  DEBUG_ONLY(_recent_allocations.set_type(res, size, ARENA);)\n@@ -118,1 +118,0 @@\n-    DEBUG_ONLY(set_type(C_HEAP);)\n@@ -121,2 +120,1 @@\n-    \/\/ new(size) sets allocation type RESOURCE_AREA.\n-    res = (address)operator new(size);\n+    res = (address)resource_allocate_bytes(size);\n@@ -127,0 +125,1 @@\n+  DEBUG_ONLY(_recent_allocations.set_type(res, size, type);)\n@@ -137,1 +136,0 @@\n-    DEBUG_ONLY(if (res!= NULL) set_type(C_HEAP);)\n@@ -140,2 +138,1 @@\n-    \/\/ new(size) sets allocation type RESOURCE_AREA.\n-    res = (address)operator new(size, std::nothrow);\n+    res = (address)resource_allocate_bytes(size, AllocFailStrategy::RETURN_NULL);\n@@ -146,0 +143,1 @@\n+  DEBUG_ONLY(if (res!= NULL) _recent_allocations.set_type(res, size, type);)\n@@ -156,1 +154,1 @@\n-THREAD_LOCAL ResourceObj::allocation_type ResourceObj::_thread_last_allocated = STACK_OR_EMBEDDED;\n+thread_local ResourceObj::RecentAllocations ResourceObj::_recent_allocations;\n@@ -158,3 +156,1 @@\n-ResourceObj::ResourceObj() : _type(_thread_last_allocated) { \/\/ _thread_last_allocated will be updated iff an operator new was called, and will default to STACK_OR_EMBEDDED\n-  set_type(STACK_OR_EMBEDDED); \/\/ reset _thread_last_allocated as the default STACK_OR_EMBEDDED can not be set by an operator new\n-}\n+ResourceObj::ResourceObj() : _type(_recent_allocations.remove_type(this)) {}\n@@ -162,3 +158,1 @@\n-ResourceObj::ResourceObj(const ResourceObj&) : _type(_thread_last_allocated) { \/\/ _thread_last_allocated will be updated iff an operator new was called, and will default to STACK_OR_EMBEDDED\n-  set_type(STACK_OR_EMBEDDED); \/\/ reset _thread_last_allocated as the default STACK_OR_EMBEDDED can not be set by an operator new\n-}\n+ResourceObj::ResourceObj(const ResourceObj&) : _type(_recent_allocations.remove_type(this)) {}\n","filename":"src\/hotspot\/share\/memory\/allocation.cpp","additions":8,"deletions":14,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -398,1 +398,1 @@\n-  enum allocation_type : u8 { STACK_OR_EMBEDDED, RESOURCE_AREA, C_HEAP, ARENA };\n+  enum allocation_type : uint8_t { STACK_OR_EMBEDDED, RESOURCE_AREA, C_HEAP, ARENA };\n@@ -401,5 +401,0 @@\n-  \/\/ When this object is allocated on stack (or embedded) the new() operator is not\n-  \/\/ called, use _thread_last_allocated (defaults to STACK_OR_EMBEDDED)\n-  \/\/ to signal allocation type. _thread_last_allocated will be reset by the constructor\n-  \/\/ so that STACK_OR_EMBEDDED will always be the value unless we are between a new and\n-  \/\/ the corresponding constructor invocation.\n@@ -407,5 +402,32 @@\n-  static THREAD_LOCAL allocation_type _thread_last_allocated;\n-\n-  static void set_type(allocation_type t) {\n-    if (t != STACK_OR_EMBEDDED) {\n-      assert(_thread_last_allocated == STACK_OR_EMBEDDED, \"_thread_last_allocated should always be reset to STACK_OR_EMBEDDED by ResourceOBJ() before being set again\");\n+  \/\/ This debug class is used to record allocation_type when operator new is called.\n+  \/\/ A few entries are needed (depending on compiler and complexity of expressions).\n+  \/\/ When the code was written 2 entries was needed on clang.\n+  \/\/\n+  \/\/ With this information we can, given a pointer, know how that pointer was\n+  \/\/ allocated iff we remove this information directly in the constructor. One\n+  \/\/ additional unfortunate restriction is that (in general) multiple inheritance\n+  \/\/ can not be used. This is unfortunate, but this limitation also existed in the\n+  \/\/ previous solution that failed because it also relied on writing to an\n+  \/\/ un-initalized object before it was constructed. The code will also fail if the\n+  \/\/ allocation is done in a recursive step. In that case an assert will trigger.\n+  class RecentAllocations {\n+    static const unsigned BufferSize = 5;\n+    uintptr_t _begin[BufferSize];\n+    uintptr_t _past_end[BufferSize];\n+    allocation_type _types[BufferSize];\n+  public:\n+    RecentAllocations() : _begin{},  _past_end{}, _types{} { }\n+\n+    void set_type(void* begin_ptr, size_t size, allocation_type type) {\n+      uintptr_t begin = reinterpret_cast<uintptr_t>(begin_ptr);\n+      for (unsigned i = 0; i < BufferSize; ++i) {\n+        if (_begin[i] == 0) {\n+          assert(_past_end[i] == 0, \"should have been reset\");\n+          assert(_types[i] == STACK_OR_EMBEDDED, \"should have been reset\");\n+          _begin[i] = begin;\n+          _past_end[i] = begin + size;\n+          _types[i] = type;\n+          return;\n+        }\n+      }\n+      assert(false, \"too small buffer, please adjust BufferSize\");\n@@ -413,2 +435,0 @@\n-    _thread_last_allocated = t;\n-  }\n@@ -416,0 +436,16 @@\n+    allocation_type remove_type(void* p) {\n+      uintptr_t ptr = reinterpret_cast<uintptr_t>(p);\n+      for (unsigned i = 0; i < BufferSize; ++i) {\n+        if (_begin[i] <= ptr && ptr < _past_end[i]) {\n+          allocation_type type = _types[i];\n+          _begin[i] = 0;\n+          _past_end[i] = 0;\n+          _types[i] = STACK_OR_EMBEDDED;\n+          return type;\n+        }\n+      }\n+\n+      \/\/ type not found, that is, operator new was not called, and the object is STACK_OR_EMBEDDED\n+      return STACK_OR_EMBEDDED;\n+   }\n+  };\n@@ -417,0 +453,1 @@\n+  static thread_local RecentAllocations _recent_allocations;\n@@ -440,1 +477,1 @@\n-      DEBUG_ONLY(set_type(RESOURCE_AREA);)\n+      DEBUG_ONLY(_recent_allocations.set_type(res, size, RESOURCE_AREA);)\n@@ -446,1 +483,1 @@\n-      DEBUG_ONLY(if (res != NULL) set_type(RESOURCE_AREA);)\n+      DEBUG_ONLY(if (res != NULL) _recent_allocations.set_type(res, size, RESOURCE_AREA);)\n","filename":"src\/hotspot\/share\/memory\/allocation.hpp","additions":52,"deletions":15,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -110,1 +110,1 @@\n-class MemRegionClosureRO: public MemRegionClosure {\n+class MemRegionClosureRO: public ResourceObj {\n@@ -112,11 +112,1 @@\n-  void* operator new(size_t size, ResourceObj::allocation_type type, MEMFLAGS flags) throw() {\n-        return ResourceObj::operator new(size, type, flags);\n-  }\n-  void* operator new(size_t size, Arena *arena) throw() {\n-        return ResourceObj::operator new(size, arena);\n-  }\n-  void* operator new(size_t size) throw() {\n-        return ResourceObj::operator new(size);\n-  }\n-\n-  void  operator delete(void* p) {} \/\/ nothing to do\n+  virtual void do_MemRegion(MemRegion mr) = 0;\n","filename":"src\/hotspot\/share\/memory\/memRegion.hpp","additions":2,"deletions":12,"binary":false,"changes":14,"status":"modified"}]}