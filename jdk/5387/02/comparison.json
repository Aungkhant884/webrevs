{"files":[{"patch":"@@ -143,1 +143,1 @@\n-  assert(_default_oop_recorder.allocated_on_stack(), \"should be embedded object\");\n+  assert(_default_oop_recorder.allocated_on_stack_or_embedded(), \"should be embedded object\");\n","filename":"src\/hotspot\/share\/asm\/codeBuffer.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -369,1 +369,1 @@\n-class CodeBuffer: public StackObj DEBUG_ONLY(COMMA private Scrubber) {\n+class CodeBuffer: public ResourceObj DEBUG_ONLY(COMMA private Scrubber) {\n@@ -377,2 +377,0 @@\n-  void* operator new(size_t size) throw() { return ResourceObj::operator new(size); }\n-  void  operator delete(void* p)          { ShouldNotCallThis(); }\n","filename":"src\/hotspot\/share\/asm\/codeBuffer.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -164,1 +164,1 @@\n-  assert(cfs->allocated_on_stack(), \"should be local\");\n+  assert(cfs->allocated_on_stack_or_embedded(), \"should be local\");\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -66,1 +66,1 @@\n-      ResourceObj(cp),\n+      ResourceObj(),\n","filename":"src\/hotspot\/share\/classfile\/stackMapFrame.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -243,3 +243,1 @@\n-    _allocated_regions((ResourceObj::set_allocation_type((address) &_allocated_regions,\n-                                                         ResourceObj::C_HEAP),\n-                        2), mtGC),\n+    _allocated_regions(2, mtGC),\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Allocator.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -109,1 +109,1 @@\n-  DEBUG_ONLY(set_allocation_type(res, ARENA);)\n+  DEBUG_ONLY(_recent_allocations.set_type(res, size, ARENA);)\n@@ -118,1 +118,0 @@\n-    DEBUG_ONLY(set_allocation_type(res, C_HEAP);)\n@@ -121,2 +120,1 @@\n-    \/\/ new(size) sets allocation type RESOURCE_AREA.\n-    res = (address)operator new(size);\n+    res = (address)resource_allocate_bytes(size);\n@@ -127,0 +125,1 @@\n+  DEBUG_ONLY(_recent_allocations.set_type(res, size, type);)\n@@ -137,1 +136,0 @@\n-    DEBUG_ONLY(if (res!= NULL) set_allocation_type(res, C_HEAP);)\n@@ -140,2 +138,1 @@\n-    \/\/ new(size) sets allocation type RESOURCE_AREA.\n-    res = (address)operator new(size, std::nothrow);\n+    res = (address)resource_allocate_bytes(size, AllocFailStrategy::RETURN_NULL);\n@@ -146,0 +143,1 @@\n+  DEBUG_ONLY(if (res!= NULL) _recent_allocations.set_type(res, size, type);)\n@@ -152,1 +150,0 @@\n-  DEBUG_ONLY(((ResourceObj *)p)->_allocation_t[0] = (uintptr_t)badHeapOopVal;)\n@@ -157,17 +154,1 @@\n-void ResourceObj::set_allocation_type(address res, allocation_type type) {\n-  \/\/ Set allocation type in the resource object\n-  uintptr_t allocation = (uintptr_t)res;\n-  assert((allocation & allocation_mask) == 0, \"address should be aligned to 4 bytes at least: \" INTPTR_FORMAT, p2i(res));\n-  assert(type <= allocation_mask, \"incorrect allocation type\");\n-  ResourceObj* resobj = (ResourceObj *)res;\n-  resobj->_allocation_t[0] = ~(allocation + type);\n-  if (type != STACK_OR_EMBEDDED) {\n-    \/\/ Called from operator new(), set verification value.\n-    resobj->_allocation_t[1] = (uintptr_t)&(resobj->_allocation_t[1]) + type;\n-  }\n-}\n-\n-ResourceObj::allocation_type ResourceObj::get_allocation_type() const {\n-  assert(~(_allocation_t[0] | allocation_mask) == (uintptr_t)this, \"lost resource object\");\n-  return (allocation_type)((~_allocation_t[0]) & allocation_mask);\n-}\n+thread_local ResourceObj::RecentAllocations ResourceObj::_recent_allocations;\n@@ -175,5 +156,1 @@\n-bool ResourceObj::is_type_set() const {\n-  allocation_type type = (allocation_type)(_allocation_t[1] & allocation_mask);\n-  return get_allocation_type()  == type &&\n-         (_allocation_t[1] - type) == (uintptr_t)(&_allocation_t[1]);\n-}\n+ResourceObj::ResourceObj() : _type(_recent_allocations.remove_type(this)) {}\n@@ -181,37 +158,1 @@\n-\/\/ This whole business of passing information from ResourceObj::operator new\n-\/\/ to the ResourceObj constructor via fields in the \"object\" is technically UB.\n-\/\/ But it seems to work within the limitations of HotSpot usage (such as no\n-\/\/ multiple inheritance) with the compilers and compiler options we're using.\n-\/\/ And it gives some possibly useful checking for misuse of ResourceObj.\n-void ResourceObj::initialize_allocation_info() {\n-  if (~(_allocation_t[0] | allocation_mask) != (uintptr_t)this) {\n-    \/\/ Operator new() is not called for allocations\n-    \/\/ on stack and for embedded objects.\n-    set_allocation_type((address)this, STACK_OR_EMBEDDED);\n-  } else if (allocated_on_stack()) { \/\/ STACK_OR_EMBEDDED\n-    \/\/ For some reason we got a value which resembles\n-    \/\/ an embedded or stack object (operator new() does not\n-    \/\/ set such type). Keep it since it is valid value\n-    \/\/ (even if it was garbage).\n-    \/\/ Ignore garbage in other fields.\n-  } else if (is_type_set()) {\n-    \/\/ Operator new() was called and type was set.\n-    assert(!allocated_on_stack(),\n-           \"not embedded or stack, this(\" PTR_FORMAT \") type %d a[0]=(\" PTR_FORMAT \") a[1]=(\" PTR_FORMAT \")\",\n-           p2i(this), get_allocation_type(), _allocation_t[0], _allocation_t[1]);\n-  } else {\n-    \/\/ Operator new() was not called.\n-    \/\/ Assume that it is embedded or stack object.\n-    set_allocation_type((address)this, STACK_OR_EMBEDDED);\n-  }\n-  _allocation_t[1] = 0; \/\/ Zap verification value\n-}\n-\n-ResourceObj::ResourceObj() {\n-  initialize_allocation_info();\n-}\n-\n-ResourceObj::ResourceObj(const ResourceObj&) {\n-  \/\/ Initialize _allocation_t as a new object, ignoring object being copied.\n-  initialize_allocation_info();\n-}\n+ResourceObj::ResourceObj(const ResourceObj&) : _type(_recent_allocations.remove_type(this)) {}\n@@ -220,5 +161,1 @@\n-  assert(allocated_on_stack(),\n-         \"copy only into local, this(\" PTR_FORMAT \") type %d a[0]=(\" PTR_FORMAT \") a[1]=(\" PTR_FORMAT \")\",\n-         p2i(this), get_allocation_type(), _allocation_t[0], _allocation_t[1]);\n-  \/\/ Keep current _allocation_t value;\n-  return *this;\n+  return *this; \/\/ allocation type should *not* be updated on assignment, only on allocation\n@@ -227,5 +164,2 @@\n-ResourceObj::~ResourceObj() {\n-  \/\/ allocated_on_C_heap() also checks that encoded (in _allocation) address == this.\n-  if (!allocated_on_C_heap()) { \/\/ ResourceObj::delete() will zap _allocation for C_heap.\n-    _allocation_t[0] = (uintptr_t)badHeapOopVal; \/\/ zap type\n-  }\n+ResourceObj::allocation_type ResourceObj::get_allocation_type() const {\n+  return _type;\n@@ -233,2 +167,1 @@\n-#endif \/\/ ASSERT\n-\n+#endif \/\/ASSERT\n","filename":"src\/hotspot\/share\/memory\/allocation.cpp","additions":12,"deletions":79,"binary":false,"changes":91,"status":"modified"},{"patch":"@@ -394,2 +394,2 @@\n-\/\/ new or delete (allocation_type is unknown).  If new is used to allocate,\n-\/\/ use delete to deallocate.\n+\/\/ new or delete (allocation_type is unknown).  Only use delete on C_HEAP\n+\/\/ allocated objects\n@@ -398,2 +398,1 @@\n-  enum allocation_type { STACK_OR_EMBEDDED = 0, RESOURCE_AREA, C_HEAP, ARENA, allocation_mask = 0x3 };\n-  static void set_allocation_type(address res, allocation_type type) NOT_DEBUG_RETURN;\n+  enum allocation_type : uint8_t { STACK_OR_EMBEDDED, RESOURCE_AREA, C_HEAP, ARENA };\n@@ -402,7 +401,51 @@\n-  \/\/ When this object is allocated on stack the new() operator is not\n-  \/\/ called but garbage on stack may look like a valid allocation_type.\n-  \/\/ Store negated 'this' pointer when new() is called to distinguish cases.\n-  \/\/ Use second array's element for verification value to distinguish garbage.\n-  uintptr_t _allocation_t[2];\n-  bool is_type_set() const;\n-  void initialize_allocation_info();\n+  allocation_type _type;\n+  \/\/ This debug class is used to record allocation_type when operator new is called.\n+  \/\/ A few entries are needed (depending on compiler and complexity of expressions).\n+  \/\/ When the code was written 2 entries was needed on clang.\n+  \/\/\n+  \/\/ With this information we can, given a pointer, know how that pointer was\n+  \/\/ allocated iff we remove this information directly in the constructor. One\n+  \/\/ additional unfortunate restriction is that (in general) multiple inheritance\n+  \/\/ can not be used. This is unfortunate, but this limitation also existed in the\n+  \/\/ previous solution that failed because it also relied on writing to an\n+  \/\/ un-initalized object before it was constructed. The code will also fail if the\n+  \/\/ allocation is done in a recursive step. In that case an assert will trigger.\n+  class RecentAllocations {\n+    static const unsigned BufferSize = 5;\n+    uintptr_t _begin[BufferSize];\n+    uintptr_t _past_end[BufferSize];\n+    allocation_type _types[BufferSize];\n+  public:\n+    RecentAllocations() : _begin{},  _past_end{}, _types{} { }\n+\n+    void set_type(void* begin_ptr, size_t size, allocation_type type) {\n+      uintptr_t begin = reinterpret_cast<uintptr_t>(begin_ptr);\n+      for (unsigned i = 0; i < BufferSize; ++i) {\n+        if (_begin[i] == 0) {\n+          assert(_past_end[i] == 0, \"should have been reset\");\n+          assert(_types[i] == STACK_OR_EMBEDDED, \"should have been reset\");\n+          _begin[i] = begin;\n+          _past_end[i] = begin + size;\n+          _types[i] = type;\n+          return;\n+        }\n+      }\n+      assert(false, \"too small buffer, please adjust BufferSize\");\n+    }\n+\n+    allocation_type remove_type(void* p) {\n+      uintptr_t ptr = reinterpret_cast<uintptr_t>(p);\n+      for (unsigned i = 0; i < BufferSize; ++i) {\n+        if (_begin[i] <= ptr && ptr < _past_end[i]) {\n+          allocation_type type = _types[i];\n+          _begin[i] = 0;\n+          _past_end[i] = 0;\n+          _types[i] = STACK_OR_EMBEDDED;\n+          return type;\n+        }\n+      }\n+\n+      \/\/ type not found, that is, operator new was not called, and the object is STACK_OR_EMBEDDED\n+      return STACK_OR_EMBEDDED;\n+   }\n+  };\n@@ -410,0 +453,1 @@\n+  static thread_local RecentAllocations _recent_allocations;\n@@ -411,4 +455,4 @@\n-  bool allocated_on_stack()    const { return get_allocation_type() == STACK_OR_EMBEDDED; }\n-  bool allocated_on_res_area() const { return get_allocation_type() == RESOURCE_AREA; }\n-  bool allocated_on_C_heap()   const { return get_allocation_type() == C_HEAP; }\n-  bool allocated_on_arena()    const { return get_allocation_type() == ARENA; }\n+  bool allocated_on_stack_or_embedded() const { return get_allocation_type() == STACK_OR_EMBEDDED; }\n+  bool allocated_on_res_area()          const { return get_allocation_type() == RESOURCE_AREA; }\n+  bool allocated_on_C_heap()            const { return get_allocation_type() == C_HEAP; }\n+  bool allocated_on_arena()             const { return get_allocation_type() == ARENA; }\n@@ -416,4 +460,3 @@\n-  ResourceObj(); \/\/ default constructor\n-  ResourceObj(const ResourceObj& r); \/\/ default copy constructor\n-  ResourceObj& operator=(const ResourceObj& r); \/\/ default copy assignment\n-  ~ResourceObj();\n+  ResourceObj();\n+  ResourceObj(const ResourceObj&);\n+  ResourceObj& operator=(const ResourceObj& r);\n@@ -434,1 +477,1 @@\n-      DEBUG_ONLY(set_allocation_type(res, RESOURCE_AREA);)\n+      DEBUG_ONLY(_recent_allocations.set_type(res, size, RESOURCE_AREA);)\n@@ -440,1 +483,1 @@\n-      DEBUG_ONLY(if (res != NULL) set_allocation_type(res, RESOURCE_AREA);)\n+      DEBUG_ONLY(if (res != NULL) _recent_allocations.set_type(res, size, RESOURCE_AREA);)\n","filename":"src\/hotspot\/share\/memory\/allocation.hpp","additions":64,"deletions":21,"binary":false,"changes":85,"status":"modified"},{"patch":"@@ -110,1 +110,1 @@\n-class MemRegionClosureRO: public MemRegionClosure {\n+class MemRegionClosureRO: public ResourceObj {\n@@ -112,11 +112,1 @@\n-  void* operator new(size_t size, ResourceObj::allocation_type type, MEMFLAGS flags) throw() {\n-        return ResourceObj::operator new(size, type, flags);\n-  }\n-  void* operator new(size_t size, Arena *arena) throw() {\n-        return ResourceObj::operator new(size, arena);\n-  }\n-  void* operator new(size_t size) throw() {\n-        return ResourceObj::operator new(size);\n-  }\n-\n-  void  operator delete(void* p) {} \/\/ nothing to do\n+  virtual void do_MemRegion(MemRegion mr) = 0;\n","filename":"src\/hotspot\/share\/memory\/memRegion.hpp","additions":2,"deletions":12,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -132,2 +132,1 @@\n-    _deferred_locals_updates((ResourceObj::set_allocation_type((address) &_deferred_locals_updates,\n-                              ResourceObj::C_HEAP), 1), mtCompiler) { }\n+    _deferred_locals_updates(1, mtCompiler) { }\n","filename":"src\/hotspot\/share\/prims\/jvmtiDeferredUpdates.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -75,1 +75,1 @@\n-  if (array->allocated_on_stack()) {\n+  if (array->allocated_on_stack_or_embedded()) {\n","filename":"src\/hotspot\/share\/utilities\/growableArray.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -455,1 +455,1 @@\n-    ASSERT_TRUE(a.allocated_on_stack());\n+    ASSERT_TRUE(a.allocated_on_stack_or_embedded());\n@@ -462,1 +462,1 @@\n-    ASSERT_TRUE(a.allocated_on_stack());\n+    ASSERT_TRUE(a.allocated_on_stack_or_embedded());\n@@ -470,1 +470,1 @@\n-    ASSERT_TRUE(a.allocated_on_stack());\n+    ASSERT_TRUE(a.allocated_on_stack_or_embedded());\n@@ -478,1 +478,1 @@\n-    ASSERT_TRUE(w._a.allocated_on_stack());\n+    ASSERT_TRUE(w._a.allocated_on_stack_or_embedded());\n@@ -485,1 +485,1 @@\n-    ASSERT_TRUE(w._a.allocated_on_stack());\n+    ASSERT_TRUE(w._a.allocated_on_stack_or_embedded());\n@@ -493,1 +493,1 @@\n-    ASSERT_TRUE(w._a.allocated_on_stack());\n+    ASSERT_TRUE(w._a.allocated_on_stack_or_embedded());\n@@ -521,1 +521,1 @@\n-    ASSERT_TRUE(a.allocated_on_stack());\n+    ASSERT_TRUE(a.allocated_on_stack_or_embedded());\n","filename":"test\/hotspot\/gtest\/utilities\/test_growableArray.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"}]}