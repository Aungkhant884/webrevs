{"files":[{"patch":"@@ -26,0 +26,2 @@\n+import jdk.test.lib.Utils;\n+\n@@ -41,1 +43,1 @@\n-    private static final Random random = new Random();\n+    private static final Random random = Utils.getRandomInstance();\n","filename":"test\/lib\/jdk\/test\/lib\/hotspot\/ir_framework\/AbstractInfo.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -26,0 +26,2 @@\n+import jdk.test.lib.Utils;\n+\n@@ -35,1 +37,1 @@\n-    private static final Random random = new Random();\n+    private static final Random random = Utils.getRandomInstance();\n","filename":"test\/lib\/jdk\/test\/lib\/hotspot\/ir_framework\/ArgumentValue.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -212,2 +212,1 @@\n-    private boolean checkBooleanFlag(String flag, String value, Boolean actualFlagValue) {\n-        boolean actualBooleanFlagValue = actualFlagValue;\n+    private boolean checkBooleanFlag(String flag, String value, boolean actualFlagValue) {\n@@ -221,1 +220,1 @@\n-        return booleanValue == actualBooleanFlagValue;\n+        return booleanValue == actualFlagValue;\n@@ -224,2 +223,1 @@\n-    private boolean checkLongFlag(String flag, String value, Long actualFlagValue) {\n-        long actualLongFlagValue = actualFlagValue;\n+    private boolean checkLongFlag(String flag, String value, long actualFlagValue) {\n@@ -248,1 +246,1 @@\n-        return parsedComparator.getPredicate().test(actualLongFlagValue, longValue);\n+        return parsedComparator.getPredicate().test(actualFlagValue, longValue);\n@@ -251,2 +249,1 @@\n-    private boolean checkDoubleFlag(String flag, String value, Double actualFlagValue) {\n-        double actualDoubleFlagValue = actualFlagValue;\n+    private boolean checkDoubleFlag(String flag, String value, double actualFlagValue) {\n@@ -275,1 +272,1 @@\n-        return parsedComparator.getPredicate().test(actualDoubleFlagValue, doubleValue);\n+        return parsedComparator.getPredicate().test(actualFlagValue, doubleValue);\n","filename":"test\/lib\/jdk\/test\/lib\/hotspot\/ir_framework\/IREncodingPrinter.java","additions":6,"deletions":9,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n@@ -37,0 +39,4 @@\n+    private static final Pattern irEncodingPattern =\n+            Pattern.compile(\"(?<=\" + IREncodingPrinter.START + \"\\\\R)[\\\\s\\\\S]*(?=\" + IREncodingPrinter.END + \")\");\n+    private static final Pattern compileIdPattern = Pattern.compile(\"compile_id='(\\\\d+)'\");\n+\n@@ -40,0 +46,1 @@\n+    private final Pattern compileIdPatternForTestClass;\n@@ -47,1 +54,1 @@\n-        this.compilations =  new LinkedHashMap<>();\n+        this.compilations =  new HashMap<>();\n@@ -50,0 +57,2 @@\n+        this.compileIdPatternForTestClass = Pattern.compile(\"compile_id='(\\\\d+)'.*\" + Pattern.quote(testClass.getCanonicalName())\n+                                                            + \" (\\\\S+)\");\n@@ -64,1 +73,1 @@\n-        Map<String, Integer[]> irRulesMap = parseIREncoding(irEncoding);\n+        Map<String, int[]> irRulesMap = parseIREncoding(irEncoding);\n@@ -70,1 +79,1 @@\n-                Integer[] ids = irRulesMap.get(m.getName());\n+                int[] ids = irRulesMap.get(m.getName());\n@@ -85,5 +94,3 @@\n-    private Map<String, Integer[]>  parseIREncoding(String irEncoding) {\n-        Map<String, Integer[]> irRulesMap = new HashMap<>();\n-        String patternString = \"(?<=\" + IREncodingPrinter.START + \"\\\\R)[\\\\s\\\\S]*(?=\" + IREncodingPrinter.END + \")\";\n-        Pattern pattern = Pattern.compile(patternString);\n-        Matcher matcher = pattern.matcher(irEncoding);\n+    private Map<String, int[]>  parseIREncoding(String irEncoding) {\n+        Map<String, int[]> irRulesMap = new HashMap<>();\n+        Matcher matcher = irEncodingPattern.matcher(irEncoding);\n@@ -98,1 +105,1 @@\n-                throw new TestFrameworkException(\"Invalid IR match rule encoding\");\n+                TestFramework.fail(\"Invalid IR match rule encoding. No comma found: \" + splitComma[0]);\n@@ -101,1 +108,1 @@\n-            Integer[] irRulesIdx = new Integer[splitComma.length - 1];\n+            int[] irRulesIdx = new int[splitComma.length - 1];\n@@ -103,1 +110,5 @@\n-                irRulesIdx[j - 1] = Integer.valueOf(splitComma[j]);\n+                try {\n+                    irRulesIdx[j - 1] = Integer.parseInt(splitComma[j]);\n+                } catch (NumberFormatException e) {\n+                    TestFramework.fail(\"Invalid IR match rule encoding. No number found: \" + splitComma[j]);\n+                }\n@@ -116,1 +127,1 @@\n-        try (BufferedReader br = new BufferedReader(new FileReader(new File(System.getProperty(\"user.dir\") + File.separator + hotspotPidFileName)))) {\n+        try (BufferedReader br = Files.newBufferedReader(Paths.get(\"\", hotspotPidFileName))) {\n@@ -206,2 +217,1 @@\n-        Pattern pattern = Pattern.compile(\"compile_id='(\\\\d+)'.*\" + Pattern.quote(testClass.getCanonicalName()) + \" (\\\\S+)\");\n-        Matcher matcher = pattern.matcher(line);\n+        Matcher matcher = compileIdPatternForTestClass.matcher(line);\n@@ -242,2 +252,1 @@\n-        Pattern pattern = Pattern.compile(\"compile_id='(\\\\d+)'\");\n-        Matcher matcher = pattern.matcher(line);\n+        Matcher matcher = compileIdPattern.matcher(line);\n@@ -273,3 +282,1 @@\n-        for (Integer id : irMethod.getRuleIds()) {\n-            applyIRRule(id);\n-        }\n+        Arrays.stream(irMethod.getRuleIds()).forEach(this::applyIRRule);\n@@ -281,1 +288,1 @@\n-    private void applyIRRule(Integer id) {\n+    private void applyIRRule(int id) {\n@@ -474,89 +481,0 @@\n-\n-\/**\n- * Helper class to store information about a method that needs to be IR matched.\n- *\/\n-class IRMethod {\n-    final private Method method;\n-    final private Integer[] ruleIds;\n-    final private IR[] irAnnos;\n-    final private StringBuilder outputBuilder;\n-    private String output;\n-    private String idealOutput;\n-    private String optoAssemblyOutput;\n-    private boolean needsIdeal;\n-    private boolean needsOptoAssembly;\n-\n-    public IRMethod(Method method, Integer[] ruleIds, IR[] irAnnos) {\n-        this.method = method;\n-        this.ruleIds = ruleIds;\n-        this.irAnnos = irAnnos;\n-        this.outputBuilder = new StringBuilder();\n-        this.output = \"\";\n-        this.idealOutput = \"\";\n-        this.optoAssemblyOutput = \"\";\n-    }\n-\n-    public Method getMethod() {\n-        return method;\n-    }\n-\n-    public Integer[] getRuleIds() {\n-        return ruleIds;\n-    }\n-\n-    public IR getIrAnno(int idx) {\n-        return irAnnos[idx];\n-    }\n-\n-    \/**\n-     * The Ideal output comes always before the Opto Assembly output. We might parse multiple C2 compilations of this method.\n-     * Only keep the very last one by overriding 'output'.\n-     *\/\n-    public void appendIdealOutput(String idealOutput) {\n-        outputBuilder.setLength(0);\n-        this.idealOutput = \"PrintIdeal:\\n\" + idealOutput;\n-        outputBuilder.append(this.idealOutput);\n-    }\n-\n-    \/**\n-     * The Opto Assembly output comes after the Ideal output. Simply append to 'output'.\n-     *\/\n-    public void appendOptoAssemblyOutput(String optoAssemblyOutput) {\n-        this.optoAssemblyOutput = \"PrintOptoAssembly:\\n\" + optoAssemblyOutput;\n-        outputBuilder.append(\"\\n\\n\").append(this.optoAssemblyOutput);\n-        output = outputBuilder.toString();\n-    }\n-\n-    public String getOutput() {\n-        return output;\n-    }\n-\n-    public String getIdealOutput() {\n-        return idealOutput;\n-    }\n-\n-    public String getOptoAssemblyOutput() {\n-        return optoAssemblyOutput;\n-    }\n-\n-    public void needsAllOutput() {\n-        needsIdeal();\n-        needsOptoAssembly();\n-    }\n-\n-    public void needsIdeal() {\n-        needsIdeal = true;\n-    }\n-\n-    public boolean usesIdeal() {\n-        return needsIdeal;\n-    }\n-\n-    public void needsOptoAssembly() {\n-        needsOptoAssembly = true;\n-    }\n-\n-    public boolean usesOptoAssembly() {\n-        return needsOptoAssembly;\n-    }\n-}\n","filename":"test\/lib\/jdk\/test\/lib\/hotspot\/ir_framework\/IRMatcher.java","additions":27,"deletions":109,"binary":false,"changes":136,"status":"modified"},{"patch":"@@ -0,0 +1,115 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.test.lib.hotspot.ir_framework;\n+\n+import java.lang.reflect.Method;\n+\n+\/**\n+ * Helper class to store information about a method that needs to be IR matched.\n+ *\/\n+class IRMethod {\n+    final private Method method;\n+    final private int[] ruleIds;\n+    final private IR[] irAnnos;\n+    final private StringBuilder outputBuilder;\n+    private String output;\n+    private String idealOutput;\n+    private String optoAssemblyOutput;\n+    private boolean needsIdeal;\n+    private boolean needsOptoAssembly;\n+\n+    public IRMethod(Method method, int[] ruleIds, IR[] irAnnos) {\n+        this.method = method;\n+        this.ruleIds = ruleIds;\n+        this.irAnnos = irAnnos;\n+        this.outputBuilder = new StringBuilder();\n+        this.output = \"\";\n+        this.idealOutput = \"\";\n+        this.optoAssemblyOutput = \"\";\n+    }\n+\n+    public Method getMethod() {\n+        return method;\n+    }\n+\n+    public int[] getRuleIds() {\n+        return ruleIds;\n+    }\n+\n+    public IR getIrAnno(int idx) {\n+        return irAnnos[idx];\n+    }\n+\n+    \/**\n+     * The Ideal output comes always before the Opto Assembly output. We might parse multiple C2 compilations of this method.\n+     * Only keep the very last one by overriding 'output'.\n+     *\/\n+    public void appendIdealOutput(String idealOutput) {\n+        outputBuilder.setLength(0);\n+        this.idealOutput = \"PrintIdeal:\\n\" + idealOutput;\n+        outputBuilder.append(this.idealOutput);\n+    }\n+\n+    \/**\n+     * The Opto Assembly output comes after the Ideal output. Simply append to 'output'.\n+     *\/\n+    public void appendOptoAssemblyOutput(String optoAssemblyOutput) {\n+        this.optoAssemblyOutput = \"PrintOptoAssembly:\\n\" + optoAssemblyOutput;\n+        outputBuilder.append(\"\\n\\n\").append(this.optoAssemblyOutput);\n+        output = outputBuilder.toString();\n+    }\n+\n+    public String getOutput() {\n+        return output;\n+    }\n+\n+    public String getIdealOutput() {\n+        return idealOutput;\n+    }\n+\n+    public String getOptoAssemblyOutput() {\n+        return optoAssemblyOutput;\n+    }\n+\n+    public void needsAllOutput() {\n+        needsIdeal();\n+        needsOptoAssembly();\n+    }\n+\n+    public void needsIdeal() {\n+        needsIdeal = true;\n+    }\n+\n+    public boolean usesIdeal() {\n+        return needsIdeal;\n+    }\n+\n+    public void needsOptoAssembly() {\n+        needsOptoAssembly = true;\n+    }\n+\n+    public boolean usesOptoAssembly() {\n+        return needsOptoAssembly;\n+    }\n+}\n","filename":"test\/lib\/jdk\/test\/lib\/hotspot\/ir_framework\/IRMethod.java","additions":115,"deletions":0,"binary":false,"changes":115,"status":"added"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.test.lib.helpers.ClassFileInstaller;\n@@ -30,1 +31,0 @@\n-import jdk.test.lib.helpers.ClassFileInstaller;\n@@ -33,1 +33,2 @@\n-import java.io.*;\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n@@ -35,2 +36,0 @@\n-import java.net.ServerSocket;\n-import java.net.Socket;\n@@ -38,1 +37,0 @@\n-import java.util.concurrent.*;\n@@ -133,0 +131,9 @@\n+    static final String RERUN_HINT = \"\"\"\n+                                       #############################################################\n+                                        - To only run the failed tests use -DTest, -DExclude,\n+                                          and\/or -DScenarios.\n+                                        - To also get the standard output of the test VM run with\\s\n+                                          -DReportStdout=true or for even more fine-grained logging\n+                                          use -DVerbose=true.\n+                                       #############################################################\n+                                     \"\"\" + \"\\n\";\n@@ -144,1 +151,1 @@\n-    private List<Class<?>> helperClasses = null;\n+    private Set<Class<?>> helperClasses = null;\n@@ -146,1 +153,2 @@\n-    private final List<String> flags = new ArrayList<>();\n+    private Set<Integer> scenarioIndices = null;\n+    private List<String> flags = null;\n@@ -162,5 +170,1 @@\n-        StackWalker walker = StackWalker.getInstance(StackWalker.Option.RETAIN_CLASS_REFERENCE);\n-        this.testClass = walker.getCallerClass();\n-        if (VERBOSE) {\n-            System.out.println(\"Test class: \" + testClass);\n-        }\n+        this(StackWalker.getInstance(StackWalker.Option.RETAIN_CLASS_REFERENCE).getCallerClass());\n@@ -267,7 +271,5 @@\n-     * <ul>\n-     *     <li><p>If a helper class is not in the same file as the test class, make sure that JTreg compiles it by using\n-     *     {@literal @}compile in the JTreg header comment block.<\/li>\n-     *     <li><p>If a class is used by the test class that does not specify any compile command annotations, you do not\n-     *     need to include it in {@code helperClasses}. If no helper class specifies any compile commands, consider\n-     *     using {@link #run()} or {@link #run(Class)}.<\/li>\n-     * <\/ul>\n+     *\n+     * <p>\n+     * If a class is used by the test class that does not specify any compile command annotations, you do not\n+     * need to include it in {@code helperClasses}. If no helper class specifies any compile commands, consider\n+     * using {@link #run()} or {@link #run(Class)}.\n@@ -336,0 +338,3 @@\n+        if (this.flags == null) {\n+            this.flags = new ArrayList<>();\n+        }\n@@ -344,7 +349,0 @@\n-     * <ul>\n-     *     <li><p>If a helper class is not in the same file as the test class, make sure that JTreg compiles it by using\n-     *            {@code @compile} in the JTreg header comment block.<\/li>\n-     *     <li><p>If a class is used by the test class that does not specify any compile command annotations, you do not\n-     *            need to include it with this method. If no helper class specifies any compile commands, you do\n-     *            not need to call this method at all.<\/li>\n-     * <\/ul>\n@@ -353,1 +351,6 @@\n-     * The testing can be started by invoking {@link #start()}\n+     * If a class is used by the test class that does not specify any compile command annotations, you do not need\n+     * to include it with this method. If no helper class specifies any compile commands, you do not need to call\n+     * this method at all.\n+     *\n+     * <p>\n+     * The testing can be started by invoking {@link #start()}.\n@@ -361,1 +364,2 @@\n-        TestRun.check(helperClasses != null && Arrays.stream(helperClasses).noneMatch(Objects::isNull), \"A Helper class cannot be null\");\n+        TestRun.check(helperClasses != null && Arrays.stream(helperClasses).noneMatch(Objects::isNull),\n+                      \"A Helper class cannot be null\");\n@@ -363,1 +367,1 @@\n-            this.helperClasses = new ArrayList<>();\n+            this.helperClasses = new HashSet<>();\n@@ -366,2 +370,3 @@\n-        for (Class<?> helperClass : helperClasses) {\n-            TestRun.check(!this.helperClasses.contains(helperClass), \"Cannot add the same class twice: \" + helperClass);\n+        for (var helperClass : helperClasses) {\n+            TestRun.check(!this.helperClasses.contains(helperClass),\n+                          \"Cannot add the same class twice: \" + helperClass);\n@@ -386,1 +391,2 @@\n-        TestRun.check(scenarios != null && Arrays.stream(scenarios).noneMatch(Objects::isNull), \"A scenario cannot be null\");\n+        TestFormat.check(scenarios != null && Arrays.stream(scenarios).noneMatch(Objects::isNull),\n+                         \"A scenario cannot be null\");\n@@ -388,3 +394,9 @@\n-            this.scenarios = new ArrayList<>(Arrays.asList(scenarios));\n-        } else {\n-            this.scenarios.addAll(Arrays.asList(scenarios));\n+            this.scenarios = new ArrayList<>();\n+            this.scenarioIndices = new HashSet<>();\n+        }\n+\n+        for (Scenario scenario : scenarios) {\n+            int scenarioIndex = scenario.getIndex();\n+            TestFormat.check(scenarioIndices.add(scenarioIndex),\n+                             \"Cannot define two scenarios with the same index \" + scenarioIndex);\n+            this.scenarios.add(scenario);\n@@ -401,1 +413,1 @@\n-        maybeDisableIRVerificationCompletely();\n+        disableIRVerificationIfNotFeasible();\n@@ -604,1 +616,1 @@\n-    private void maybeDisableIRVerificationCompletely() {\n+    private void disableIRVerificationIfNotFeasible() {\n@@ -606,1 +618,1 @@\n-            VERIFY_IR = hasIRAnnotations();\n+            VERIFY_IR = Platform.isDebugBuild() && !Platform.isInt() && !Platform.isComp();\n@@ -608,1 +620,2 @@\n-                System.out.println(\"IR verification disabled due to test \" + testClass + \" not specifying any @IR annotations\");\n+                System.out.println(\"IR verification disabled due to not running a debug build (required for PrintIdeal\" +\n+                                   \"and PrintOptoAssembly), running with -Xint, or -Xcomp (use warm-up of 0 instead)\");\n@@ -612,1 +625,1 @@\n-            VERIFY_IR = Platform.isDebugBuild() && !Platform.isInt() && !Platform.isComp();\n+            VERIFY_IR = hasIRAnnotations();\n@@ -614,2 +627,1 @@\n-                System.out.println(\"IR verification disabled due to not running a debug build (required for PrintIdeal\" +\n-                                   \"and PrintOptoAssembly), running with -Xint, or -Xcomp (use warm-up of 0 instead)\");\n+                System.out.println(\"IR verification disabled due to test \" + testClass + \" not specifying any @IR annotations\");\n@@ -634,1 +646,0 @@\n-        Set<Integer> scenarioIndices = new HashSet<>();\n@@ -637,3 +648,0 @@\n-            TestFormat.check(!scenarioIndices.contains(scenarioIndex),\n-                             \"Cannot define two scenarios with the same index \" + scenarioIndex);\n-            scenarioIndices.add(scenarioIndex);\n@@ -668,2 +676,1 @@\n-            if (e instanceof IRViolationException) {\n-                IRViolationException irException = (IRViolationException) e;\n+            if (e instanceof IRViolationException irException) {\n@@ -688,1 +695,1 @@\n-            System.err.println(JVMOutput.getRerunHint());\n+            System.err.println(RERUN_HINT);\n@@ -717,1 +724,4 @@\n-            List<String> additionalFlags = new ArrayList<>(flags);\n+            List<String> additionalFlags = new ArrayList<>();\n+            if (flags != null) {\n+                additionalFlags.addAll(flags);\n+            }\n@@ -795,1 +805,1 @@\n-        final int exitCode = oa.getExitValue();\n+        int exitCode = oa.getExitValue();\n@@ -804,1 +814,1 @@\n-            throw new RuntimeException(\"\\nTestFramework flag VM exited with \" + exitCode);\n+            throw new RuntimeException(\"TestFramework flag VM exited with \" + exitCode);\n@@ -1016,1 +1026,1 @@\n-            rerunHint = getRerunHint();\n+            rerunHint = TestFramework.RERUN_HINT;\n@@ -1026,200 +1036,0 @@\n-\n-    public static String getRerunHint() {\n-        return \"\"\"\n-                 #############################################################\n-                  - To only run the failed tests use -DTest, -DExclude,\n-                    and\/or -DScenarios.\n-                  - To also get the standard output of the test VM run with\\s\n-                    -DReportStdout=true or for even more fine-grained logging\n-                    use -DVerbose=true.\n-                 #############################################################\n-               \"\"\" + \"\\n\";\n-    }\n-}\n-\n-\/**\n- * Dedicated socket to send data from the flag and test VM back to the driver VM.\n- *\/\n-class TestFrameworkSocket {\n-    static final String SERVER_PORT_PROPERTY = \"ir.framework.server.port\";\n-\n-    \/\/ Static fields used by flag and test VM only.\n-    private static final int SERVER_PORT = Integer.getInteger(SERVER_PORT_PROPERTY, -1);\n-\n-    private static final boolean REPRODUCE = Boolean.getBoolean(\"Reproduce\");\n-    private static final String HOSTNAME = null;\n-    private static final String STDOUT_PREFIX = \"[STDOUT]\";\n-    private static Socket clientSocket = null;\n-    private static PrintWriter clientWriter = null;\n-\n-    private final String serverPortPropertyFlag;\n-    private FutureTask<String> socketTask;\n-    private ServerSocket serverSocket;\n-\n-    private static TestFrameworkSocket singleton = null;\n-\n-    private TestFrameworkSocket() {\n-        try {\n-            serverSocket = new ServerSocket(0);\n-        } catch (IOException e) {\n-            TestFramework.fail(\"Failed to create TestFramework server socket\", e);\n-        }\n-        int port = serverSocket.getLocalPort();\n-        if (TestFramework.VERBOSE) {\n-            System.out.println(\"TestFramework server socket uses port \" + port);\n-        }\n-        serverPortPropertyFlag = \"-D\" + SERVER_PORT_PROPERTY + \"=\" + port;\n-    }\n-\n-    public static TestFrameworkSocket getSocket() {\n-        if (singleton == null || singleton.serverSocket.isClosed()) {\n-            singleton = new TestFrameworkSocket();\n-            return singleton;\n-        }\n-        return singleton;\n-    }\n-\n-    public String getPortPropertyFlag() {\n-        return serverPortPropertyFlag;\n-    }\n-\n-    public void start() {\n-        socketTask = initSocketTask();\n-        Thread socketThread = new Thread(socketTask);\n-        socketThread.start();\n-    }\n-\n-    \/**\n-     * Waits for client sockets (created by flag or test VM) to connect. Return the messages received by the clients.\n-     *\/\n-    private FutureTask<String> initSocketTask() {\n-        return new FutureTask<>(() -> {\n-            try (Socket clientSocket = serverSocket.accept();\n-                 BufferedReader in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()))\n-            ) {\n-                StringBuilder builder = new StringBuilder();\n-                String next;\n-                while ((next = in.readLine()) != null) {\n-                    builder.append(next).append(\"\\n\");\n-                }\n-                return builder.toString();\n-            } catch (IOException e) {\n-                TestFramework.fail(\"Server socket error\", e);\n-                return null;\n-            }\n-        });\n-    }\n-\n-    public void close() {\n-        try {\n-            serverSocket.close();\n-        } catch (IOException e) {\n-            TestFramework.fail(\"Could not close socket\", e);\n-        }\n-    }\n-\n-    \/**\n-     * Only called by flag and test VM to write to server socket.\n-     *\/\n-    public static void write(String msg, String type) {\n-        write(msg, type, false);\n-    }\n-\n-    \/**\n-     * Only called by flag and test VM to write to server socket.\n-     *\/\n-    public static void write(String msg, String type, boolean stdout) {\n-        if (REPRODUCE) {\n-            System.out.println(\"Debugging Test VM: Skip writing due to -DReproduce\");\n-            return;\n-        }\n-        TestFramework.check(SERVER_PORT != -1, \"Server port was not set correctly for flag and\/or test VM \"\n-                                              + \"or method not called from flag or test VM\");\n-        try {\n-            \/\/ Keep the client socket open until the flag or test VM terminates (calls closeClientSocket before exiting\n-            \/\/ main()).\n-            if (clientSocket == null) {\n-                clientSocket = new Socket(HOSTNAME, SERVER_PORT);\n-                clientWriter = new PrintWriter(clientSocket.getOutputStream(), true);\n-            }\n-            if (stdout) {\n-                msg = STDOUT_PREFIX + msg;\n-            }\n-            clientWriter.println(msg);\n-        } catch (Exception e) {\n-            \/\/ When the test VM is directly run, we should ignore all messages that would normally be sent to the\n-            \/\/ driver VM.\n-            String failMsg = \"\\n\\n\" + \"\"\"\n-                             ###########################################################\n-                              Did you directly run the test VM (TestFrameworkExecution)\n-                              to reproduce a bug?\n-                              => Append the flag -DReproduce=true and try again!\n-                             ###########################################################\n-                             \"\"\";\n-            TestRun.fail(failMsg, e);\n-        }\n-        if (TestFramework.VERBOSE) {\n-            System.out.println(\"Written \" + type + \" to socket:\");\n-            System.out.println(msg);\n-        }\n-    }\n-\n-    \/**\n-     * Closes (and flushes) the printer to the socket and the socket itself. Is called as last thing before exiting\n-     * the main() method of the flag and the test VM.\n-     *\/\n-    public static void closeClientSocket() {\n-        if (clientSocket != null) {\n-            try {\n-                clientWriter.close();\n-                clientSocket.close();\n-            } catch (IOException e) {\n-                throw new RuntimeException(\"Could not close TestFrameworkExecution socket\", e);\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Get the socket output of the flag VM.\n-     *\/\n-    public String getOutput() {\n-        try {\n-            return socketTask.get();\n-\n-        } catch (Exception e) {\n-            TestFramework.fail(\"Could not read from socket task\", e);\n-            return null;\n-        }\n-    }\n-\n-    \/**\n-     * Get the socket output from the test VM by stripping all lines starting with a [STDOUT] output and printing them\n-     * to the standard output.\n-     *\/\n-    public String getOutputPrintStdout() {\n-        try {\n-            String output = socketTask.get();\n-            if (TestFramework.TESTLIST || TestFramework.EXCLUDELIST) {\n-                StringBuilder builder = new StringBuilder();\n-                Scanner scanner = new Scanner(output);\n-                System.out.println(\"\\nRun flag defined test list\");\n-                System.out.println(\"--------------------------\");\n-                while (scanner.hasNextLine()) {\n-                    String line = scanner.nextLine();\n-                    if (line.startsWith(STDOUT_PREFIX)) {\n-                        line = \"> \" + line.substring(STDOUT_PREFIX.length());\n-                        System.out.println(line);\n-                    } else {\n-                        builder.append(line).append(\"\\n\");\n-                    }\n-                }\n-                System.out.println();\n-                return builder.toString();\n-            }\n-            return output;\n-\n-        } catch (Exception e) {\n-            TestFramework.fail(\"Could not read from socket task\", e);\n-            return null;\n-        }\n-    }\n","filename":"test\/lib\/jdk\/test\/lib\/hotspot\/ir_framework\/TestFramework.java","additions":63,"deletions":253,"binary":false,"changes":316,"status":"modified"},{"patch":"@@ -0,0 +1,222 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.test.lib.hotspot.ir_framework;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.PrintWriter;\n+import java.net.ServerSocket;\n+import java.net.Socket;\n+import java.util.Scanner;\n+import java.util.concurrent.FutureTask;\n+\n+\/**\n+ * Dedicated socket to send data from the flag and test VM back to the driver VM.\n+ *\/\n+class TestFrameworkSocket implements AutoCloseable {\n+    static final String SERVER_PORT_PROPERTY = \"ir.framework.server.port\";\n+\n+    \/\/ Static fields used by flag and test VM only.\n+    private static final int SERVER_PORT = Integer.getInteger(SERVER_PORT_PROPERTY, -1);\n+\n+    private static final boolean REPRODUCE = Boolean.getBoolean(\"Reproduce\");\n+    private static final String HOSTNAME = null;\n+    private static final String STDOUT_PREFIX = \"[STDOUT]\";\n+    private static Socket clientSocket = null;\n+    private static PrintWriter clientWriter = null;\n+\n+    private final String serverPortPropertyFlag;\n+    private FutureTask<String> socketTask;\n+    private ServerSocket serverSocket;\n+\n+    private static TestFrameworkSocket singleton = null;\n+\n+    private TestFrameworkSocket() {\n+        try {\n+            serverSocket = new ServerSocket(0);\n+        } catch (IOException e) {\n+            TestFramework.fail(\"Failed to create TestFramework server socket\", e);\n+        }\n+        int port = serverSocket.getLocalPort();\n+        if (TestFramework.VERBOSE) {\n+            System.out.println(\"TestFramework server socket uses port \" + port);\n+        }\n+        serverPortPropertyFlag = \"-D\" + SERVER_PORT_PROPERTY + \"=\" + port;\n+    }\n+\n+    public static TestFrameworkSocket getSocket() {\n+        if (singleton == null || singleton.serverSocket.isClosed()) {\n+            singleton = new TestFrameworkSocket();\n+            return singleton;\n+        }\n+        return singleton;\n+    }\n+\n+    public String getPortPropertyFlag() {\n+        return serverPortPropertyFlag;\n+    }\n+\n+    public void start() {\n+        socketTask = initSocketTask();\n+        Thread socketThread = new Thread(socketTask);\n+        socketThread.start();\n+    }\n+\n+    \/**\n+     * Waits for client sockets (created by flag or test VM) to connect. Return the messages received by the clients.\n+     *\/\n+    private FutureTask<String> initSocketTask() {\n+        return new FutureTask<>(() -> {\n+            try (Socket clientSocket = serverSocket.accept();\n+                 BufferedReader in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()))\n+            ) {\n+                StringBuilder builder = new StringBuilder();\n+                String next;\n+                while ((next = in.readLine()) != null) {\n+                    builder.append(next).append(\"\\n\");\n+                }\n+                return builder.toString();\n+            } catch (IOException e) {\n+                TestFramework.fail(\"Server socket error\", e);\n+                return null;\n+            }\n+        });\n+    }\n+\n+    @Override\n+    public void close() {\n+        try {\n+            serverSocket.close();\n+        } catch (IOException e) {\n+            TestFramework.fail(\"Could not close socket\", e);\n+        }\n+    }\n+\n+    \/**\n+     * Only called by flag and test VM to write to server socket.\n+     *\/\n+    public static void write(String msg, String type) {\n+        write(msg, type, false);\n+    }\n+\n+    \/**\n+     * Only called by flag and test VM to write to server socket.\n+     *\/\n+    public static void write(String msg, String type, boolean stdout) {\n+        if (REPRODUCE) {\n+            System.out.println(\"Debugging Test VM: Skip writing due to -DReproduce\");\n+            return;\n+        }\n+        TestFramework.check(SERVER_PORT != -1, \"Server port was not set correctly for flag and\/or test VM \"\n+                                               + \"or method not called from flag or test VM\");\n+        try {\n+            \/\/ Keep the client socket open until the flag or test VM terminates (calls closeClientSocket before exiting\n+            \/\/ main()).\n+            if (clientSocket == null) {\n+                clientSocket = new Socket(HOSTNAME, SERVER_PORT);\n+                clientWriter = new PrintWriter(clientSocket.getOutputStream(), true);\n+            }\n+            if (stdout) {\n+                msg = STDOUT_PREFIX + msg;\n+            }\n+            clientWriter.println(msg);\n+        } catch (Exception e) {\n+            \/\/ When the test VM is directly run, we should ignore all messages that would normally be sent to the\n+            \/\/ driver VM.\n+            String failMsg = \"\\n\\n\" + \"\"\"\n+                             ###########################################################\n+                              Did you directly run the test VM (TestFrameworkExecution)\n+                              to reproduce a bug?\n+                              => Append the flag -DReproduce=true and try again!\n+                             ###########################################################\n+                             \"\"\";\n+            TestRun.fail(failMsg, e);\n+        }\n+        if (TestFramework.VERBOSE) {\n+            System.out.println(\"Written \" + type + \" to socket:\");\n+            System.out.println(msg);\n+        }\n+    }\n+\n+    \/**\n+     * Closes (and flushes) the printer to the socket and the socket itself. Is called as last thing before exiting\n+     * the main() method of the flag and the test VM.\n+     *\/\n+    public static void closeClientSocket() {\n+        if (clientSocket != null) {\n+            try {\n+                clientWriter.close();\n+                clientSocket.close();\n+            } catch (IOException e) {\n+                throw new RuntimeException(\"Could not close TestFrameworkExecution socket\", e);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Get the socket output of the flag VM.\n+     *\/\n+    public String getOutput() {\n+        try {\n+            return socketTask.get();\n+\n+        } catch (Exception e) {\n+            TestFramework.fail(\"Could not read from socket task\", e);\n+            return null;\n+        }\n+    }\n+\n+    \/**\n+     * Get the socket output from the test VM by stripping all lines starting with a [STDOUT] output and printing them\n+     * to the standard output.\n+     *\/\n+    public String getOutputPrintStdout() {\n+        try {\n+            String output = socketTask.get();\n+            if (TestFramework.TESTLIST || TestFramework.EXCLUDELIST) {\n+                StringBuilder builder = new StringBuilder();\n+                Scanner scanner = new Scanner(output);\n+                System.out.println(\"\\nRun flag defined test list\");\n+                System.out.println(\"--------------------------\");\n+                while (scanner.hasNextLine()) {\n+                    String line = scanner.nextLine();\n+                    if (line.startsWith(STDOUT_PREFIX)) {\n+                        line = \"> \" + line.substring(STDOUT_PREFIX.length());\n+                        System.out.println(line);\n+                    } else {\n+                        builder.append(line).append(\"\\n\");\n+                    }\n+                }\n+                System.out.println();\n+                return builder.toString();\n+            }\n+            return output;\n+\n+        } catch (Exception e) {\n+            TestFramework.fail(\"Could not read from socket task\", e);\n+            return null;\n+        }\n+    }\n+}\n","filename":"test\/lib\/jdk\/test\/lib\/hotspot\/ir_framework\/TestFrameworkSocket.java","additions":222,"deletions":0,"binary":false,"changes":222,"status":"added"},{"patch":"@@ -0,0 +1,23 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+\n","filename":"test\/lib\/jdk\/test\/lib\/hotspot\/ir_framework\/examples\/TEST.ROOT","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -6,1 +6,1 @@\n-Additional testing should be performed with the converted Valhalla tests (see [JDK-8263024](https:\/\/bugs.openjdk.java.net\/browse\/JDK-8263024)) to make sure a changeset is correct (these are part of the Valhalla CI).\n+Additional testing should be performed with the converted Valhalla tests to make sure a changeset is correct (these are part of the Valhalla CI).\n","filename":"test\/lib\/jdk\/test\/lib\/hotspot\/ir_framework\/tests\/README.md","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,23 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+\n","filename":"test\/lib\/jdk\/test\/lib\/hotspot\/ir_framework\/tests\/TEST.ROOT","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"}]}