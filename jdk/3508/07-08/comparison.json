{"files":[{"patch":"@@ -24,1 +24,1 @@\n-package jdk.test.lib.hotspot.ir_framework;\n+package compiler.lib.ir_framework;\n@@ -26,0 +26,2 @@\n+import compiler.lib.ir_framework.shared.TestRunException;\n+import compiler.lib.ir_framework.test.TestVM;\n@@ -114,1 +116,1 @@\n-     * Called by framework when the warm-up is finished. Not exposed to users.\n+     * Called by {@link TestFramework} when the warm-up is finished. Should not be called by user code.\n@@ -116,1 +118,1 @@\n-    void setWarmUpFinished() {\n+    public void setWarmUpFinished() {\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/AbstractInfo.java","additions":5,"deletions":3,"binary":false,"changes":8,"previous_filename":"test\/lib\/jdk\/test\/lib\/hotspot\/ir_framework\/AbstractInfo.java","status":"renamed"},{"patch":"@@ -24,1 +24,1 @@\n-package jdk.test.lib.hotspot.ir_framework;\n+package compiler.lib.ir_framework;\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/Argument.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"test\/lib\/jdk\/test\/lib\/hotspot\/ir_framework\/Argument.java","status":"renamed"},{"patch":"@@ -24,1 +24,1 @@\n-package jdk.test.lib.hotspot.ir_framework;\n+package compiler.lib.ir_framework;\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/Arguments.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"test\/lib\/jdk\/test\/lib\/hotspot\/ir_framework\/Arguments.java","status":"renamed"},{"patch":"@@ -24,1 +24,3 @@\n-package jdk.test.lib.hotspot.ir_framework;\n+package compiler.lib.ir_framework;\n+\n+import compiler.lib.ir_framework.shared.TestFormatException;\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/Check.java","additions":3,"deletions":1,"binary":false,"changes":4,"previous_filename":"test\/lib\/jdk\/test\/lib\/hotspot\/ir_framework\/Check.java","status":"renamed"},{"patch":"@@ -24,1 +24,1 @@\n-package jdk.test.lib.hotspot.ir_framework;\n+package compiler.lib.ir_framework;\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/CheckAt.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"test\/lib\/jdk\/test\/lib\/hotspot\/ir_framework\/CheckAt.java","status":"renamed"},{"patch":"@@ -0,0 +1,171 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework;\n+\n+import compiler.lib.ir_framework.shared.TestFrameworkException;\n+import compiler.lib.ir_framework.shared.TestRun;\n+import compiler.lib.ir_framework.shared.TestRunException;\n+import compiler.lib.ir_framework.test.TestVM;\n+import jdk.test.lib.Utils;\n+\n+import java.lang.reflect.Executable;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+\/**\n+ * Compilation levels used by the framework to initiate a compilation of a method. The compilation levels map to the used\n+ * levels in HotSpot (apart from the framework specific values {@link #SKIP} and {@link #WAIT_FOR_COMPILATION} that cannot\n+ * be found in HotSpot). The HotSpot specific levels must be in sync with hotspot\/share\/compiler\/compilerDefinitions.hpp.\n+ *\n+ * <p>\n+ * The compilation levels can be specified in the {@link Test}, {@link ForceCompile}, and\n+ * {@link ForceCompileClassInitializer} annotation.\n+ *\n+ * @see Test\n+ * @see ForceCompile\n+ * @see ForceCompileClassInitializer\n+ *\/\n+public enum CompLevel {\n+    \/**\n+     * Can only be used at {@link Test#compLevel()}. After the warm-up, the framework keeps invoking the test over a span\n+     * of 10s (configurable by setting the property flag {@code -DWaitForCompilationTimeout}) until HotSpot compiles the\n+     * {@link Test} method. If the method was not compiled after 10s, an exception is thrown. The framework does not wait\n+     * for the compilation if the test VM is run with {@code -Xcomp}, {@code -XX:-UseCompiler}, or\n+     * {@code -DExcludeRandom=true}.\n+     *\/\n+    WAIT_FOR_COMPILATION(-4),\n+    \/**\n+     * Can only be used at {@link Test#compLevel()}. Skip a compilation of the {@link Test @Test} method completely.\n+     *\/\n+    SKIP(-3),\n+    \/**\n+     *  Use any compilation level depending on the usage:\n+     *  <ul>\n+     *      <li><p>{@link Test @Test}, {@link ForceCompile @ForceCompile}: Use the highest available compilation level\n+     *      which is usually C2.<\/li>\n+     *      <li><p>{@link DontCompile @DontCompile}: Prevents any compilation of the associated helper method.<\/li>\n+     *  <\/ul>\n+     *\/\n+    ANY(-2),\n+    \/**\n+     *  Compilation level 1: C1 compilation without any profile information.\n+     *\/\n+    C1_SIMPLE(1),\n+    \/**\n+     *  Compilation level 2: C1 compilation with limited profile information: Includes Invocation and backedge counters.\n+     *\/\n+    C1_LIMITED_PROFILE(2),\n+    \/**\n+     *  Compilation level 3: C1 compilation with full profile information: Includes Invocation and backedge counters with MDO.\n+     *\/\n+    C1_FULL_PROFILE(3),\n+    \/**\n+     * Compilation level 4: C2 compilation with full optimizations.\n+     *\/\n+    C2(4),\n+\n+    ;\n+\n+    private static final Map<Integer, CompLevel> TYPES_BY_VALUE = new HashMap<>();\n+    private final int value;\n+\n+    static {\n+        for (CompLevel level : CompLevel.values()) {\n+            TYPES_BY_VALUE.put(level.value, level);\n+        }\n+    }\n+\n+    CompLevel(int level) {\n+        this.value = level;\n+    }\n+\n+    \/**\n+     * Get the compilation level as integer value. These will match the levels specified in HotSpot (if available).\n+     *\n+     * @return the compilation level as integer.\n+     *\/\n+    public int getValue() {\n+        return value;\n+    }\n+\n+    \/**\n+     * Get the compilation level enum from the specified integer.\n+     *\n+     * @param value the compilation level as integer.\n+     * @throws TestRunException if {@code value} does not specify a valid compilation level.\n+     * @return the compilation level enum for {@code value}.\n+     *\/\n+    public static CompLevel forValue(int value) {\n+        CompLevel level = TYPES_BY_VALUE.get(value);\n+        TestRun.check(level != null, \"Invalid compilation level \" + value);\n+        return level;\n+    }\n+\n+    \/**\n+     * Called by {@link TestFramework} to check if this compilation level is not part of the compiler.\n+     *\/\n+    public boolean isNotCompilationLevelOfCompiler(Compiler c) {\n+        return switch (c) {\n+            case C1 -> !isC1();\n+            case C2 -> this != C2;\n+            default -> throw new TestFrameworkException(\"Should not be called with compiler \" + c);\n+        };\n+    }\n+\n+    \/**\n+     * Called by {@link TestFramework} to flip compilation levels.\n+     *\/\n+    public CompLevel flipCompLevel() {\n+        switch (this) {\n+            case C1_SIMPLE, C1_LIMITED_PROFILE, C1_FULL_PROFILE -> {\n+                return CompLevel.C2;\n+            }\n+            case C2 -> {\n+                return CompLevel.C1_SIMPLE;\n+            }\n+        }\n+        return this;\n+    }\n+\n+    \/**\n+     * Called by {@link TestFramework}. Return the compilation level when only allowing a compilation with the specified\n+     * compiler.\n+     *\/\n+    public CompLevel excludeCompilationRandomly(Executable ex) {\n+        if (Utils.getRandomInstance().nextBoolean()) {\n+            \/\/ No exclusion\n+            return this;\n+        }\n+        Compiler compiler = TestVM.excludeRandomly(ex);\n+        return switch (compiler) {\n+            case ANY -> SKIP;\n+            case C1 -> isC1() ? SKIP : this;\n+            case C2 -> this == C2 ? SKIP : this;\n+        };\n+    }\n+\n+    private boolean isC1() {\n+        return this == C1_SIMPLE || this == C1_LIMITED_PROFILE || this == C1_FULL_PROFILE;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/CompLevel.java","additions":171,"deletions":0,"binary":false,"changes":171,"status":"added"},{"patch":"@@ -24,1 +24,1 @@\n-package jdk.test.lib.hotspot.ir_framework;\n+package compiler.lib.ir_framework;\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/Compiler.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"test\/lib\/jdk\/test\/lib\/hotspot\/ir_framework\/Compiler.java","status":"renamed"},{"patch":"@@ -24,1 +24,3 @@\n-package jdk.test.lib.hotspot.ir_framework;\n+package compiler.lib.ir_framework;\n+\n+import compiler.lib.ir_framework.shared.TestFormatException;\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/DontCompile.java","additions":3,"deletions":1,"binary":false,"changes":4,"previous_filename":"test\/lib\/jdk\/test\/lib\/hotspot\/ir_framework\/DontCompile.java","status":"renamed"},{"patch":"@@ -24,1 +24,3 @@\n-package jdk.test.lib.hotspot.ir_framework;\n+package compiler.lib.ir_framework;\n+\n+import compiler.lib.ir_framework.shared.TestFormatException;\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/DontInline.java","additions":3,"deletions":1,"binary":false,"changes":4,"previous_filename":"test\/lib\/jdk\/test\/lib\/hotspot\/ir_framework\/DontInline.java","status":"renamed"},{"patch":"@@ -24,1 +24,3 @@\n-package jdk.test.lib.hotspot.ir_framework;\n+package compiler.lib.ir_framework;\n+\n+import compiler.lib.ir_framework.shared.TestFormatException;\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/ForceCompile.java","additions":3,"deletions":1,"binary":false,"changes":4,"previous_filename":"test\/lib\/jdk\/test\/lib\/hotspot\/ir_framework\/ForceCompile.java","status":"renamed"},{"patch":"@@ -24,1 +24,3 @@\n-package jdk.test.lib.hotspot.ir_framework;\n+package compiler.lib.ir_framework;\n+\n+import compiler.lib.ir_framework.shared.TestFormatException;\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/ForceCompileClassInitializer.java","additions":3,"deletions":1,"binary":false,"changes":4,"previous_filename":"test\/lib\/jdk\/test\/lib\/hotspot\/ir_framework\/ForceCompileClassInitializer.java","status":"renamed"},{"patch":"@@ -24,1 +24,3 @@\n-package jdk.test.lib.hotspot.ir_framework;\n+package compiler.lib.ir_framework;\n+\n+import compiler.lib.ir_framework.shared.TestFormatException;\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/ForceInline.java","additions":3,"deletions":1,"binary":false,"changes":4,"previous_filename":"test\/lib\/jdk\/test\/lib\/hotspot\/ir_framework\/ForceInline.java","status":"renamed"},{"patch":"@@ -24,1 +24,3 @@\n-package jdk.test.lib.hotspot.ir_framework;\n+package compiler.lib.ir_framework;\n+\n+import compiler.lib.ir_framework.driver.IRViolationException;\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IR.java","additions":3,"deletions":1,"binary":false,"changes":4,"previous_filename":"test\/lib\/jdk\/test\/lib\/hotspot\/ir_framework\/IR.java","status":"renamed"},{"patch":"@@ -24,1 +24,5 @@\n-package jdk.test.lib.hotspot.ir_framework;\n+package compiler.lib.ir_framework;\n+\n+import compiler.lib.ir_framework.driver.IRMatcher;\n+import compiler.lib.ir_framework.shared.TestFormat;\n+import compiler.lib.ir_framework.shared.TestFormatException;\n@@ -131,1 +135,4 @@\n-    static List<String> mergeNodes(String[] nodes) {\n+    \/**\n+     * Called by {@link IRMatcher} to merge special composite nodes together with additional user-defined input.\n+     *\/\n+    public static List<String> mergeNodes(String[] nodes) {\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":9,"deletions":2,"binary":false,"changes":11,"previous_filename":"test\/lib\/jdk\/test\/lib\/hotspot\/ir_framework\/IRNode.java","status":"renamed"},{"patch":"@@ -24,1 +24,1 @@\n-package jdk.test.lib.hotspot.ir_framework;\n+package compiler.lib.ir_framework;\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRs.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"test\/lib\/jdk\/test\/lib\/hotspot\/ir_framework\/IRs.java","status":"renamed"},{"patch":"@@ -0,0 +1,134 @@\n+# IR Test Framework\n+This folder contains a test framework whose main purpose is to perform regex-based checks on the C2 IR shape of test methods emitted by the VM flags _-XX:+PrintIdeal_ and _-XX:+PrintOptoAssembly_. The framework can also be used for other non-IR matching (and non-compiler) tests by providing easy to use annotations for commonly used testing patterns and compiler control flags.\n+\n+## 1. How to Use the Framework\n+The framework is intended to be used in JTreg tests. The JTreg header of the test must contain `@library \/test\/lib \/` (2 paths) and should be run as a driver with `@run driver`. Annotate the test code with the supported framework annotations and call the framework from within the test's `main()` method. A simple example is shown below:\n+\n+    \/*\n+     * @test\n+     * @summary A simple test using the test framework.\n+     * @library \/test\/lib \/\n+     * @run driver my.package.MySimpleTest\n+     *\/\n+    \n+    package my.package;\n+    \n+    import compiler.lib.ir_framework.*;\n+\n+    public class MySimpleTest {\n+        \n+        public static void main(String[] args) {\n+            TestFramework.run(); \/\/ The framework runs all tests of this class.\n+        }\n+    \n+        @Test\n+        @IR(failOn = IRNode.STORE) \/\/ Fail if the IR of myTest() contains any stores.\n+        public void myTest() {\n+            \/* ... *\/\n+        }\n+    }\n+\n+There are various ways how to set up and run a test within the `main()` method of a JTreg test. These are described and can be found in the [TestFramework](.\/TestFramework.java) class.\n+   \n+## 2. Features\n+ The framework offers various annotations and flags to control how your test code should be invoked and being checked. This section gives an overview over all these features.\n+\n+### 2.1 Different Tests\n+There are three kinds of tests depending on how much control is needed over the test invocation.\n+#### Base Tests\n+The simplest form of testing provides a single `@Test` annotated method which the framework will invoke as part of the testing. The test method has no or well-defined arguments that the framework can automatically provide. \n+\n+More information on base tests with a precise definition can be found in the Javadocs of [Test](.\/Test.java). Concrete examples on how to specify a base test can be found in [BaseTestsExample](..\/..\/..\/testlibrary_tests\/compiler\/lib\/ir_framework\/examples\/BaseTestExample.java).\n+\n+#### Checked Tests\n+The base tests do not provide any way of verification by user code. A checked test enables this by allowing the user to define an additional `@Check` annotated method which is invoked directly after the `@Test` annotated method. This allows the user to perform various checks about the test method including return value verification.\n+\n+More information on checked tests with a precise definition can be found in the Javadocs of [Check](.\/Check.java). Concrete examples on how to specify a checked test can be found in [CheckedTestsExample](..\/..\/..\/testlibrary_tests\/compiler\/lib\/ir_framework\/examples\/CheckedTestExample.java).\n+\n+#### Custom Run Tests\n+Neither the base nor the checked tests provide any control over how a `@Test` annotated method is invoked in terms of customized argument values and\/or conditions for the invocation itself. A custom run test gives full control over the invocation of the `@Test` annotated method to the user. The framework calls a dedicated `@Run` annotated method from which the user can invoke the `@Test` method according to his\/her needs.\n+\n+More information on checked tests with a precise definition can be found in the Javadocs of [Run](.\/Run.java). Concrete examples on how to specify a custom run test can be found in [CustomRunTestsExample](..\/..\/..\/testlibrary_tests\/compiler\/lib\/ir_framework\/examples\/CustomRunTestExample.java).\n+\n+### 2.2 IR Verification\n+The main feature of this framework is to perform a simple but yet powerful regex-based C2 IR matching on the output of _-XX:+PrintIdeal_ and _-XX:+PrintOptoAssembly_. For simplicity, we will refer to the \"IR\" or \"IR matching\" when actually meaning the combined output of _-XX:+PrintIdeal_ and _-XX:+PrintOptoAssembly_ for a C2 compilation.\n+\n+The user has the possibility to add an additional `@IR` annotation to any `@Test` annotated method (regardless of the kind of test mentioned in section 2.1) to specify a constraint\/rule on the compiled IR shape. The `@IR` annotation provides two kinds of regex checks:\n+\n+ - A `failOn` check that verifies that the provided regex is not matched in the C2 IR.\n+ - A `counts` check that verifies that the provided regex is matched a user defined number of times in the C2 IR.\n+ \n+A regex can either be a custom string or any of the default regexes provided by the framework in [IRNode](.\/IRNode.java) for some commonly used IR nodes (also provides the possibility of composite regexes).\n+\n+An IR verification cannot always be performed. For example, a JTreg test could be run with _-Xint_ or not a debug build (_-XX:+PrintIdeal_ and _-XX:+PrintOptoAssembly_ are debug build flags). But also CI tier testing could add additional JTreg VM and Javaoptions flags which could make an IR rule unstable. \n+\n+In general, the framework will only perform IR verification if the used VM flags allow a C2 compilation and if non-critical additional JTreg VM and Javaoptions are provided (see whiteflag list in [TestFramework](.\/TestFramework.java)). The user test code, however, can specify any flags which still allow an IR verification to be performed if a C2 compilation is done (expected flags by user defined `@IR` annotations). \n+\n+An `@IR` annotation allows additional preconditions\/restrictions on the currently present VM flags to enable or disable rules when certain flags are present or have a specific value (see `applyIfXX` properties of an `@IR` annotation).\n+\n+More information about IR matching can be found in the Javadocs of [IR](.\/IR.java). Concrete examples on how to specify IR constraint\/rules can be found in [IRExample](..\/..\/..\/testlibrary_tests\/compiler\/lib\/ir_framework\/examples\/IRExample.java) and [TestIRMatching](..\/..\/..\/testlibrary_tests\/compiler\/lib\/ir_framework\/TestIRMatching.java) (an internal framework test).\n+\n+### 2.3 Test VM Flags and Scenarios\n+The recommended way to use the framework is by defining a single `@run driver` statement in the JTreg header which, however, does not allow the specification of additional test VM flags. Instead, the user has the possibility to provide VM flags by calling `TestFramework.runWithFlags()` or by creating a `TestFramework` builder object on which `addFlags()` can be called.\n+\n+If a user wants to provide multiple flag combinations for a single test, he or she has the option to provide different scenarios. A scenario based flag will always have precedence over other user defined flags. More information about scenarios can be found in the Javadocs of [Scenario](.\/Scenario.java).\n+\n+### 2.4 Compiler Controls\n+The framework allows the use of additional compiler control annotations for helper method and classes in the same fashion as JMH does. The following annotations are supported and described in the referenced Javadocs for the annotation class:\n+\n+- [@DontInline](.\/DontInline.java)\n+- [@ForceInline](.\/ForceInline.java)\n+- [@DontCompile](.\/DontCompile.java)\n+- [@ForceCompile](.\/DontCompile.java)\n+- [@ForceCompileClassInitializer](.\/ForceCompileClassInitializer.java)\n+\n+### 2.5 Framework Debug and Stress Flags\n+The framework provides various stress and debug flags. They should mainly be used as JTreg VM and\/or Javaoptions (apart from `VerifyIR`). The following (property) flags are supported:\n+\n+- `-DVerifyIR=false`: Explicitly disable IR verification. This is useful, for example, if some scenarios use VM flags that let `@IR` annotation rules fail and the user does not want to provide separate IR rules or add flag preconditions to the already existing IR rules.\n+- `-DTest=test1,test2`: Provide a list of `@Test` method names which should be executed.\n+- `-DExclude=test3`: Provide a list of `@Test` method names which should be excluded from execution.\n+- `-DScenarios=1,2`: Provide a list of scenario indexes to specify which scenarios should be executed.\n+- `-DWarmup=200`: Provide a new default value of the number of warm-up iterations (framework default is 2000). This might have an influence on the resulting IR and could lead to matching failures (the user can also set a fixed default warm-up value in a test with `testFrameworkObject.setDefaultWarmup(200)`).\n+- `-DVerbose=true`: Enable more fain-grained logging (slows the execution down).\n+- `-DReproduce=true`: Flag to use when directly running a test VM to bypass dependencies to the driver VM state (for example, when reproducing an issue).\n+- `-DPrintTimes=true`: Print the execution time measurements of each executed test.\n+- `-DVerifyVM=true`: The framework runs the test VM with additional verification flags (slows the execution down).\n+- `-DExcluceRandom=true`: The framework randomly excludes some methods from compilation. IR verification is disabled completely with this flag.\n+- `-DFlipC1C2=true`: The framework compiles all `@Test` annotated method with C1 if a C2 compilation would have been applied and vice versa. IR verification is disabled completely with this flag.\n+- `-DShuffleTests=false`: Disables the random execution order of all tests (such a shuffling is always done by default).\n+- `-DDumpReplay=true`: Add the `DumpReplay` directive to the test VM.\n+- `-DGCAfter=true`: Perform `System.gc()` after each test (slows the execution down).\n+- `-DWaitForCompilationTimeout=20`: Change the default waiting time (default: 10s) for a compilation of a `@Test` annotated method with compilation level [WAIT\\_FOR\\_COMPILATION](.\/CompLevel.java).\n+- `-DIgnoreCompilerControls=false`: Ignore all compiler controls applied in the framework. This includes any compiler control annotations (`@DontCompile`, `@DontInline`, `@ForceCompile`, `@ForceInline`, `@ForceCompileStaticInitializer`), the exclusion of `@Run` and `@Check` methods from compilation, and the directive to not inline `@Test` annotated methods.\n+\n+\n+## 3. Test Framework Execution\n+This section gives an overview of how the framework is executing a JTreg test that calls the framework from within its `main()` method.\n+\n+The framework will spawn a new \"test VM\" to execute the user defined tests. The test VM collects all tests of the test class specified by the user code in `main()` and ensures that there is no violation of the required format by the framework. In a next step, the framework does the following for each test in general:\n+1. Warm the test up for a predefined number of times (default 2000). This can also be adapted for all tests by using `testFrameworkobject.setDefaultWarmup(100)` or for individual tests with an additional [@Warmup](.\/Warmup.java) annotation. \n+2. After the warm-up is finished, the framework compiles the associated `@Test` annotated method at the specified compilation level (default: C2).\n+3. After the compilation, the test is invoked one more time.\n+\n+Once the test VM terminates, IR verification (if possible) is performed on the output of the test VM. If any test throws an exception during its execution or if IR matching fails, the failures are collected and reported in a pretty format. Check the standard error and output for more information and how to reproduce these failures.\n+\n+Some of the steps above can be different due to the kind of the test or due to using non-default annotation properties. These details and differences are described in the Javadocs for the three tests (see section 2.1 Different Tests).\n+\n+More information about the internals and the workflow of the framework can be found in the Javadocs of [TestFramework](.\/TestFramework.java).  \n+ \n+## 4. Internal Framework Tests\n+There are various tests to verify the correctness of the test framework. These tests can be found in [ir_framework](..\/..\/..\/testlibrary_tests\/compiler\/lib\/ir_framework) and can directly be run with JTreg. The tests are part of the normal JTreg tests of HotSpot and should be run upon changing the framework code as a minimal form of testing.\n+\n+Additional testing was performed by converting all compiler Inline Types tests that used the currently present IR test framework in Valhalla (see [JDK-8263024](https:\/\/bugs.openjdk.java.net\/browse\/JDK-8263024)). It is strongly advised to make sure a change to the framework still lets these converted tests in Valhalla pass as part of an additional testing step.\n+\n+## 5. Framework Package Structure\n+A user only needs to import classes from the package `compiler.lib.ir_framework` (e.g. `import compiler.lib.ir_framework.*;`) which represents the interface classes to the framework. The remaining framework internal classes are kept in separate subpackages and should not directly be imported:\n+\n+- `compiler.lib.ir_framework.driver`: These classes are used while running the driver VM (same VM as the one running the user code's `main()` method of a JTreg test).\n+- `compiler.lib.ir_framework.flag`: These classes are used while running the flag VM to determine additional flags for the test VM which are required for IR verification.\n+- `compiler.lib.ir_framework.test`: These classes are used while running the test VM (i.e. the actual execution of the user tests as described in section 3).\n+- `compiler.lib.ir_framework.shared`: These classes can be called from either the driver, flag, or test VM.\n+\n+## 6. Summary\n+ The initial design and feature set was kept simple and straight forward and serves well for small to medium sized tests. There are a lot of possibilities to further enhance the framework and make it more powerful. This can be tackled in additional RFEs. A few ideas can be found as subtasks of the [initial RFE](https:\/\/bugs.openjdk.java.net\/browse\/JDK-8254129) for this framework.\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/README.md","additions":134,"deletions":0,"binary":false,"changes":134,"status":"added"},{"patch":"@@ -24,1 +24,3 @@\n-package jdk.test.lib.hotspot.ir_framework;\n+package compiler.lib.ir_framework;\n+\n+import compiler.lib.ir_framework.shared.TestFormatException;\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/Run.java","additions":3,"deletions":1,"binary":false,"changes":4,"previous_filename":"test\/lib\/jdk\/test\/lib\/hotspot\/ir_framework\/Run.java","status":"renamed"},{"patch":"@@ -24,1 +24,5 @@\n-package jdk.test.lib.hotspot.ir_framework;\n+package compiler.lib.ir_framework;\n+\n+import compiler.lib.ir_framework.test.DeclaredTest;\n+import compiler.lib.ir_framework.shared.TestRunException;\n+import compiler.lib.ir_framework.test.TestVM;\n@@ -42,1 +46,1 @@\n-    RunInfo(List<DeclaredTest> tests) {\n+    public RunInfo(List<DeclaredTest> tests) {\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/RunInfo.java","additions":6,"deletions":2,"binary":false,"changes":8,"previous_filename":"test\/lib\/jdk\/test\/lib\/hotspot\/ir_framework\/RunInfo.java","status":"renamed"},{"patch":"@@ -24,1 +24,1 @@\n-package jdk.test.lib.hotspot.ir_framework;\n+package compiler.lib.ir_framework;\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/RunMode.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"test\/lib\/jdk\/test\/lib\/hotspot\/ir_framework\/RunMode.java","status":"renamed"},{"patch":"@@ -24,1 +24,3 @@\n-package jdk.test.lib.hotspot.ir_framework;\n+package compiler.lib.ir_framework;\n+\n+import compiler.lib.ir_framework.shared.TestRunException;\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/Scenario.java","additions":3,"deletions":1,"binary":false,"changes":4,"previous_filename":"test\/lib\/jdk\/test\/lib\/hotspot\/ir_framework\/Scenario.java","status":"renamed"},{"patch":"@@ -24,1 +24,1 @@\n-package jdk.test.lib.hotspot.ir_framework;\n+package compiler.lib.ir_framework;\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/Test.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"test\/lib\/jdk\/test\/lib\/hotspot\/ir_framework\/Test.java","status":"renamed"},{"patch":"@@ -24,1 +24,1 @@\n-package jdk.test.lib.hotspot.ir_framework;\n+package compiler.lib.ir_framework;\n@@ -26,0 +26,3 @@\n+import compiler.lib.ir_framework.driver.*;\n+import compiler.lib.ir_framework.shared.*;\n+import compiler.lib.ir_framework.test.*;\n@@ -121,3 +124,3 @@\n-    static final boolean VERBOSE = Boolean.getBoolean(\"Verbose\");\n-    static final boolean TESTLIST = !System.getProperty(\"Test\", \"\").isEmpty();\n-    static final boolean EXCLUDELIST = !System.getProperty(\"Exclude\", \"\").isEmpty();\n+    public static final boolean VERBOSE = Boolean.getBoolean(\"Verbose\");\n+    public static final boolean TESTLIST = !System.getProperty(\"Test\", \"\").isEmpty();\n+    public static final boolean EXCLUDELIST = !System.getProperty(\"Exclude\", \"\").isEmpty();\n@@ -126,9 +129,9 @@\n-    static final String RERUN_HINT = \"\"\"\n-                                       #############################################################\n-                                        - To only run the failed tests use -DTest, -DExclude,\n-                                          and\/or -DScenarios.\n-                                        - To also get the standard output of the test VM run with\n-                                          -DReportStdout=true or for even more fine-grained logging\n-                                          use -DVerbose=true.\n-                                       #############################################################\n-                                     \"\"\" + System.lineSeparator();\n+    private static final String RERUN_HINT = \"\"\"\n+                                               #############################################################\n+                                                - To only run the failed tests use -DTest, -DExclude,\n+                                                  and\/or -DScenarios.\n+                                                - To also get the standard output of the test VM run with\n+                                                  -DReportStdout=true or for even more fine-grained logging\n+                                                  use -DVerbose=true.\n+                                               #############################################################\n+                                             \"\"\" + System.lineSeparator();\n@@ -698,1 +701,1 @@\n-    static void check(boolean test, String failureMessage) {\n+    public static void check(boolean test, String failureMessage) {\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/TestFramework.java","additions":17,"deletions":14,"binary":false,"changes":31,"previous_filename":"test\/lib\/jdk\/test\/lib\/hotspot\/ir_framework\/TestFramework.java","status":"renamed"},{"patch":"@@ -0,0 +1,97 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework;\n+\n+import compiler.lib.ir_framework.test.DeclaredTest;\n+import compiler.lib.ir_framework.test.TestVM;\n+\n+import java.lang.reflect.Method;\n+\n+\/**\n+ * Test info class which provides some useful utility methods and information about a <b>checked test<\/b>.\n+ *\n+ * @see Test\n+ * @see Check\n+ *\/\n+public class TestInfo extends AbstractInfo {\n+    private final Method testMethod;\n+    private final boolean compilationSkipped;\n+\n+    public TestInfo(Method testMethod, CompLevel testCmpLevel) {\n+        super(testMethod.getDeclaringClass());\n+        this.testMethod = testMethod;\n+        this.compilationSkipped = testCmpLevel == CompLevel.SKIP;\n+    }\n+\n+    \/**\n+     * Get the associated test method object.\n+     *\n+     * @return the associated test method object.\n+     *\/\n+    public Method getTest() {\n+        return testMethod;\n+    }\n+\n+    \/**\n+     * Return a boolean indicating if the framework skipped a compilation after the warm-up due to VM flags not\n+     * allowing a compilation on the requested level in {@link Test#compLevel()}.\n+     *\n+     * @return {@code true} if the framework skipped compilation of the test;\n+     *         {@code false} otherwise.\n+     *\/\n+    public boolean isCompilationSkipped() {\n+        return compilationSkipped;\n+    }\n+\n+    \/**\n+     * Returns a boolean indicating if the associated test method is C1 compiled.\n+     *\n+     * @return {@code true} if the test method is C1 compiled;\n+     *         {@code false} otherwise.\n+     *\/\n+    public boolean isC1Compiled() {\n+        return TestVM.isC1Compiled(testMethod);\n+    }\n+\n+    \/**\n+     * Returns a boolean indicating if the associated test method is C2 compiled.\n+     *\n+     * @return {@code true} if the test method is C2 compiled;\n+     *         {@code false} otherwise.\n+     *\/\n+    public boolean isC2Compiled() {\n+        return TestVM.isC2Compiled(testMethod);\n+    }\n+\n+    \/**\n+     * Returns a boolean indicating if the associated test method is compiled at {@code compLevel}.\n+     *\n+     * @param compLevel the compilation level.\n+     * @return {@code true} if the test method is compiled at {@code compLevel};\n+     *         {@code false} otherwise.\n+     *\/\n+    public boolean isCompiledAtLevel(CompLevel compLevel) {\n+        return TestVM.isCompiledAtLevel(testMethod, compLevel);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/TestInfo.java","additions":97,"deletions":0,"binary":false,"changes":97,"status":"added"},{"patch":"@@ -24,1 +24,1 @@\n-package jdk.test.lib.hotspot.ir_framework;\n+package compiler.lib.ir_framework;\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/Warmup.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"test\/lib\/jdk\/test\/lib\/hotspot\/ir_framework\/Warmup.java","status":"renamed"},{"patch":"@@ -24,1 +24,1 @@\n-package jdk.test.lib.hotspot.ir_framework;\n+package compiler.lib.ir_framework.driver;\n@@ -26,0 +26,4 @@\n+import compiler.lib.ir_framework.TestFramework;\n+import compiler.lib.ir_framework.shared.TestFrameworkException;\n+import compiler.lib.ir_framework.flag.FlagVM;\n+import compiler.lib.ir_framework.shared.TestRunException;\n@@ -46,1 +50,1 @@\n-class FlagVMProcess {\n+public class FlagVMProcess {\n@@ -55,1 +59,1 @@\n-    FlagVMProcess(Class<?> testClass, List<String> additionalFlags) {\n+    public FlagVMProcess(Class<?> testClass, List<String> additionalFlags) {\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/FlagVMProcess.java","additions":7,"deletions":3,"binary":false,"changes":10,"previous_filename":"test\/lib\/jdk\/test\/lib\/hotspot\/ir_framework\/FlagVMProcess.java","status":"renamed"},{"patch":"@@ -24,1 +24,5 @@\n-package jdk.test.lib.hotspot.ir_framework;\n+package compiler.lib.ir_framework.driver;\n+\n+import compiler.lib.ir_framework.*;\n+import compiler.lib.ir_framework.shared.*;\n+import compiler.lib.ir_framework.test.*;\n@@ -37,1 +41,1 @@\n-class IRMatcher {\n+public class IRMatcher {\n@@ -40,1 +44,1 @@\n-            Pattern.compile(\"(?<=\" + IREncodingPrinter.START + \"\\\\R)[\\\\s\\\\S]*(?=\" + IREncodingPrinter.END + \")\");\n+            Pattern.compile(\"(?<=\" + IREncodingPrinter.START + \"\\r?\\n)[\\\\s\\\\S]*(?=\" + IREncodingPrinter.END + \")\");\n@@ -78,1 +82,1 @@\n-            IR[] irAnnos =  m.getAnnotationsByType(IR.class);\n+            IR[] irAnnos = m.getAnnotationsByType(IR.class);\n@@ -96,1 +100,1 @@\n-    private Map<String, int[]>  parseIREncoding(String irEncoding) {\n+    private Map<String, int[]> parseIREncoding(String irEncoding) {\n@@ -378,1 +382,1 @@\n-                TestFormat.check(i + 1 < nodesWithCount.size(), \"Missing count\"  + getPostfixErrorMsg(node));\n+                TestFormat.check(i + 1 < nodesWithCount.size(), \"Missing count\" + getPostfixErrorMsg(node));\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/IRMatcher.java","additions":10,"deletions":6,"binary":false,"changes":16,"previous_filename":"test\/lib\/jdk\/test\/lib\/hotspot\/ir_framework\/IRMatcher.java","status":"renamed"},{"patch":"@@ -24,1 +24,3 @@\n-package jdk.test.lib.hotspot.ir_framework;\n+package compiler.lib.ir_framework.driver;\n+\n+import compiler.lib.ir_framework.IR;\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/IRMethod.java","additions":3,"deletions":1,"binary":false,"changes":4,"previous_filename":"test\/lib\/jdk\/test\/lib\/hotspot\/ir_framework\/IRMethod.java","status":"renamed"},{"patch":"@@ -24,1 +24,4 @@\n-package jdk.test.lib.hotspot.ir_framework;\n+package compiler.lib.ir_framework.driver;\n+\n+import compiler.lib.ir_framework.IR;\n+import compiler.lib.ir_framework.Test;\n@@ -53,1 +56,1 @@\n-    String getCompilations() {\n+    public String getCompilations() {\n@@ -57,1 +60,1 @@\n-    void addCommandLine(String commandLine) {\n+    public void addCommandLine(String commandLine) {\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/IRViolationException.java","additions":6,"deletions":3,"binary":false,"changes":9,"previous_filename":"test\/lib\/jdk\/test\/lib\/hotspot\/ir_framework\/IRViolationException.java","status":"renamed"},{"patch":"@@ -24,1 +24,3 @@\n-package jdk.test.lib.hotspot.ir_framework;\n+package compiler.lib.ir_framework.driver;\n+\n+import compiler.lib.ir_framework.shared.TestFormatException;\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/TestVMException.java","additions":3,"deletions":1,"binary":false,"changes":4,"previous_filename":"test\/lib\/jdk\/test\/lib\/hotspot\/ir_framework\/TestVMException.java","status":"renamed"},{"patch":"@@ -24,1 +24,1 @@\n-package jdk.test.lib.hotspot.ir_framework;\n+package compiler.lib.ir_framework.driver;\n@@ -26,0 +26,6 @@\n+import compiler.lib.ir_framework.TestFramework;\n+import compiler.lib.ir_framework.shared.TestFrameworkException;\n+import compiler.lib.ir_framework.shared.TestFrameworkSocket;\n+import compiler.lib.ir_framework.shared.NoTestsRunException;\n+import compiler.lib.ir_framework.shared.TestFormatException;\n+import compiler.lib.ir_framework.test.TestVM;\n@@ -43,1 +49,1 @@\n-class TestVMProcess {\n+public class TestVMProcess {\n@@ -59,1 +65,1 @@\n-    TestVMProcess(List<String> additionalFlags, Class<?> testClass, Set<Class<?>> helperClasses, int defaultWarmup) {\n+    public TestVMProcess(List<String> additionalFlags, Class<?> testClass, Set<Class<?>> helperClasses, int defaultWarmup) {\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/TestVMProcess.java","additions":9,"deletions":3,"binary":false,"changes":12,"previous_filename":"test\/lib\/jdk\/test\/lib\/hotspot\/ir_framework\/TestVMProcess.java","status":"renamed"},{"patch":"@@ -24,1 +24,1 @@\n-package jdk.test.lib.hotspot.ir_framework;\n+package compiler.lib.ir_framework.flag;\n@@ -26,0 +26,4 @@\n+import compiler.lib.ir_framework.CompLevel;\n+import compiler.lib.ir_framework.TestFramework;\n+import compiler.lib.ir_framework.shared.TestFrameworkException;\n+import compiler.lib.ir_framework.shared.TestRunException;\n@@ -40,1 +44,6 @@\n-class FlagVM {\n+public class FlagVM {\n+    public static final String TEST_VM_FLAGS_FILE_PREFIX = \"test-vm-flags-pid-\";\n+    public static final String TEST_VM_FLAGS_FILE_POSTFIX = \".log\";\n+    public static final String TEST_VM_FLAGS_DELIMITER = \" \";\n+\n+    private static final String TEST_VM_FLAGS_FILE;\n@@ -42,2 +51,0 @@\n-    static final String TEST_VM_FLAGS_FILE_PREFIX = \"test-vm-flags-pid-\";\n-    static final String TEST_VM_FLAGS_FILE_POSTFIX = \".log\";\n@@ -56,3 +63,0 @@\n-    private static final String TEST_VM_FLAGS_FILE;\n-\n-    static final String TEST_VM_FLAGS_DELIMITER = \" \";\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/flag\/FlagVM.java","additions":11,"deletions":7,"binary":false,"changes":18,"previous_filename":"test\/lib\/jdk\/test\/lib\/hotspot\/ir_framework\/FlagVM.java","status":"renamed"},{"patch":"@@ -0,0 +1,33 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.shared;\n+\n+\/**\n+ * Checked internal exceptions in the framework to propagate error handling.\n+ *\/\n+public class CheckedTestFrameworkException extends Exception {\n+    public CheckedTestFrameworkException(String msg) {\n+        super(msg);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/shared\/CheckedTestFrameworkException.java","additions":33,"deletions":0,"binary":false,"changes":33,"status":"added"},{"patch":"@@ -24,1 +24,1 @@\n-package jdk.test.lib.hotspot.ir_framework;\n+package compiler.lib.ir_framework.shared;\n@@ -34,1 +34,1 @@\n-    NoTestsRunException() {}\n+    public NoTestsRunException() {}\n@@ -39,1 +39,1 @@\n-    NoTestsRunException(String message) {\n+    public NoTestsRunException(String message) {\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/shared\/NoTestsRunException.java","additions":3,"deletions":3,"binary":false,"changes":6,"previous_filename":"test\/lib\/jdk\/test\/lib\/hotspot\/ir_framework\/NoTestsRunException.java","status":"renamed"},{"patch":"@@ -24,1 +24,1 @@\n-package jdk.test.lib.hotspot.ir_framework;\n+package compiler.lib.ir_framework.shared;\n@@ -31,1 +31,1 @@\n-class ParsedComparator<T extends Comparable<T>> {\n+public class ParsedComparator<T extends Comparable<T>> {\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/shared\/ParsedComparator.java","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"test\/lib\/jdk\/test\/lib\/hotspot\/ir_framework\/ParsedComparator.java","status":"renamed"},{"patch":"@@ -24,1 +24,1 @@\n-package jdk.test.lib.hotspot.ir_framework;\n+package compiler.lib.ir_framework.shared;\n@@ -32,1 +32,1 @@\n-class TestFormat {\n+public class TestFormat {\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/shared\/TestFormat.java","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"test\/lib\/jdk\/test\/lib\/hotspot\/ir_framework\/TestFormat.java","status":"renamed"},{"patch":"@@ -24,1 +24,1 @@\n-package jdk.test.lib.hotspot.ir_framework;\n+package compiler.lib.ir_framework.shared;\n@@ -30,1 +30,1 @@\n-    TestFormatException(String message) {\n+    public TestFormatException(String message) {\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/shared\/TestFormatException.java","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"test\/lib\/jdk\/test\/lib\/hotspot\/ir_framework\/TestFormatException.java","status":"renamed"},{"patch":"@@ -24,1 +24,1 @@\n-package jdk.test.lib.hotspot.ir_framework;\n+package compiler.lib.ir_framework.shared;\n@@ -31,1 +31,1 @@\n-    TestFrameworkException(String message) {\n+    public TestFrameworkException(String message) {\n@@ -35,1 +35,1 @@\n-    TestFrameworkException(String message, Throwable e) {\n+    public TestFrameworkException(String message, Throwable e) {\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/shared\/TestFrameworkException.java","additions":3,"deletions":3,"binary":false,"changes":6,"previous_filename":"test\/lib\/jdk\/test\/lib\/hotspot\/ir_framework\/TestFrameworkException.java","status":"renamed"},{"patch":"@@ -24,1 +24,3 @@\n-package jdk.test.lib.hotspot.ir_framework;\n+package compiler.lib.ir_framework.shared;\n+\n+import compiler.lib.ir_framework.TestFramework;\n@@ -38,2 +40,3 @@\n-class TestFrameworkSocket implements AutoCloseable {\n-    \/\/ Static fields used by flag and test VM only.\n+public class TestFrameworkSocket implements AutoCloseable {\n+    public static final String STDOUT_PREFIX = \"[STDOUT]\";\n+    \/\/ Static fields used for test VM only.\n@@ -43,1 +46,0 @@\n-    static final String STDOUT_PREFIX = \"[STDOUT]\";\n@@ -53,1 +55,1 @@\n-    TestFrameworkSocket() {\n+    public TestFrameworkSocket() {\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/shared\/TestFrameworkSocket.java","additions":7,"deletions":5,"binary":false,"changes":12,"previous_filename":"test\/lib\/jdk\/test\/lib\/hotspot\/ir_framework\/TestFrameworkSocket.java","status":"renamed"},{"patch":"@@ -24,1 +24,1 @@\n-package jdk.test.lib.hotspot.ir_framework;\n+package compiler.lib.ir_framework.shared;\n@@ -29,1 +29,1 @@\n-class TestRun {\n+public class TestRun {\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/shared\/TestRun.java","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"test\/lib\/jdk\/test\/lib\/hotspot\/ir_framework\/TestRun.java","status":"renamed"},{"patch":"@@ -0,0 +1,38 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.shared;\n+\n+\/**\n+ * Exception that is thrown if the JTreg test throws an exception during the execution of individual tests of the\n+ * test class.\n+ *\/\n+public class TestRunException extends RuntimeException {\n+    public TestRunException(String message) {\n+        super(message);\n+    }\n+\n+    public TestRunException(String message, Exception e) {\n+        super(message, e);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/shared\/TestRunException.java","additions":38,"deletions":0,"binary":false,"changes":38,"status":"added"},{"patch":"@@ -24,1 +24,1 @@\n-package jdk.test.lib.hotspot.ir_framework;\n+package compiler.lib.ir_framework.test;\n@@ -26,0 +26,3 @@\n+import compiler.lib.ir_framework.*;\n+import compiler.lib.ir_framework.shared.TestRun;\n+import compiler.lib.ir_framework.shared.TestRunException;\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/test\/AbstractTest.java","additions":4,"deletions":1,"binary":false,"changes":5,"previous_filename":"test\/lib\/jdk\/test\/lib\/hotspot\/ir_framework\/AbstractTest.java","status":"renamed"},{"patch":"@@ -24,1 +24,1 @@\n-package jdk.test.lib.hotspot.ir_framework;\n+package compiler.lib.ir_framework.test;\n@@ -26,0 +26,5 @@\n+import compiler.lib.ir_framework.Argument;\n+import compiler.lib.ir_framework.Arguments;\n+import compiler.lib.ir_framework.shared.TestFrameworkException;\n+import compiler.lib.ir_framework.shared.TestFormat;\n+import compiler.lib.ir_framework.shared.TestFormatException;\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/test\/ArgumentValue.java","additions":6,"deletions":1,"binary":false,"changes":7,"previous_filename":"test\/lib\/jdk\/test\/lib\/hotspot\/ir_framework\/ArgumentValue.java","status":"renamed"},{"patch":"@@ -24,1 +24,4 @@\n-package jdk.test.lib.hotspot.ir_framework;\n+package compiler.lib.ir_framework.test;\n+\n+import compiler.lib.ir_framework.*;\n+import compiler.lib.ir_framework.shared.TestRunException;\n@@ -43,1 +46,1 @@\n-        this.testInfo = new TestInfo(test);\n+        this.testInfo = new TestInfo(testMethod, test.getCompLevel());\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/test\/BaseTest.java","additions":5,"deletions":2,"binary":false,"changes":7,"previous_filename":"test\/lib\/jdk\/test\/lib\/hotspot\/ir_framework\/BaseTest.java","status":"renamed"},{"patch":"@@ -24,1 +24,5 @@\n-package jdk.test.lib.hotspot.ir_framework;\n+package compiler.lib.ir_framework.test;\n+\n+import compiler.lib.ir_framework.Check;\n+import compiler.lib.ir_framework.CheckAt;\n+import compiler.lib.ir_framework.shared.TestRunException;\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/test\/CheckedTest.java","additions":5,"deletions":1,"binary":false,"changes":6,"previous_filename":"test\/lib\/jdk\/test\/lib\/hotspot\/ir_framework\/CheckedTest.java","status":"renamed"},{"patch":"@@ -24,1 +24,1 @@\n-package jdk.test.lib.hotspot.ir_framework;\n+package compiler.lib.ir_framework.test;\n@@ -26,0 +26,4 @@\n+import compiler.lib.ir_framework.*;\n+import compiler.lib.ir_framework.shared.TestFormat;\n+import compiler.lib.ir_framework.shared.TestFrameworkException;\n+import compiler.lib.ir_framework.shared.TestRunException;\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/test\/CustomRunTest.java","additions":5,"deletions":1,"binary":false,"changes":6,"previous_filename":"test\/lib\/jdk\/test\/lib\/hotspot\/ir_framework\/CustomRunTest.java","status":"renamed"},{"patch":"@@ -24,1 +24,4 @@\n-package jdk.test.lib.hotspot.ir_framework;\n+package compiler.lib.ir_framework.test;\n+\n+import compiler.lib.ir_framework.CompLevel;\n+import compiler.lib.ir_framework.shared.TestRunException;\n@@ -32,1 +35,1 @@\n-class DeclaredTest {\n+public class DeclaredTest {\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/test\/DeclaredTest.java","additions":5,"deletions":2,"binary":false,"changes":7,"previous_filename":"test\/lib\/jdk\/test\/lib\/hotspot\/ir_framework\/DeclaredTest.java","status":"renamed"},{"patch":"@@ -24,1 +24,1 @@\n-package jdk.test.lib.hotspot.ir_framework;\n+package compiler.lib.ir_framework.test;\n@@ -26,0 +26,2 @@\n+import compiler.lib.ir_framework.*;\n+import compiler.lib.ir_framework.shared.*;\n@@ -40,1 +42,1 @@\n-class IREncodingPrinter {\n+public class IREncodingPrinter {\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/test\/IREncodingPrinter.java","additions":4,"deletions":2,"binary":false,"changes":6,"previous_filename":"test\/lib\/jdk\/test\/lib\/hotspot\/ir_framework\/IREncodingPrinter.java","status":"renamed"},{"patch":"@@ -24,1 +24,1 @@\n-package jdk.test.lib.hotspot.ir_framework;\n+package compiler.lib.ir_framework.test;\n@@ -26,0 +26,3 @@\n+import compiler.lib.ir_framework.*;\n+import compiler.lib.ir_framework.Compiler;\n+import compiler.lib.ir_framework.shared.*;\n@@ -75,1 +78,1 @@\n-    static final boolean TEST_C1 = TIERED_COMPILATION && TIERED_COMPILATION_STOP_AT_LEVEL.getValue() < CompLevel.C2.getValue();\n+    public static final boolean TEST_C1 = TIERED_COMPILATION && TIERED_COMPILATION_STOP_AT_LEVEL.getValue() < CompLevel.C2.getValue();\n@@ -80,1 +83,1 @@\n-    static final boolean USE_COMPILER = WHITE_BOX.getBooleanVMFlag(\"UseCompiler\");\n+    public static final boolean USE_COMPILER = WHITE_BOX.getBooleanVMFlag(\"UseCompiler\");\n@@ -366,1 +369,1 @@\n-    static Compiler excludeRandomly(Executable ex) {\n+    public static Compiler excludeRandomly(Executable ex) {\n@@ -846,1 +849,1 @@\n-    static void compile(Method m, CompLevel compLevel) {\n+    public static void compile(Method m, CompLevel compLevel) {\n@@ -852,1 +855,1 @@\n-    static void deoptimize(Method m) {\n+    public static void deoptimize(Method m) {\n@@ -856,1 +859,1 @@\n-    static boolean isCompiled(Method m) {\n+    public static boolean isCompiled(Method m) {\n@@ -860,1 +863,1 @@\n-    static boolean isC1Compiled(Method m) {\n+    public static boolean isC1Compiled(Method m) {\n@@ -864,1 +867,1 @@\n-    static boolean isC2Compiled(Method m) {\n+    public static boolean isC2Compiled(Method m) {\n@@ -868,1 +871,1 @@\n-    static boolean isCompiledAtLevel(Method m, CompLevel compLevel) {\n+    public static boolean isCompiledAtLevel(Method m, CompLevel compLevel) {\n@@ -872,1 +875,1 @@\n-    static void assertDeoptimizedByC1(Method m) {\n+    public static void assertDeoptimizedByC1(Method m) {\n@@ -879,1 +882,1 @@\n-    static void assertDeoptimizedByC2(Method m) {\n+    public static void assertDeoptimizedByC2(Method m) {\n@@ -894,1 +897,1 @@\n-    static void assertCompiledByC1(Method m) {\n+    public static void assertCompiledByC1(Method m) {\n@@ -898,1 +901,1 @@\n-    static void assertCompiledByC2(Method m) {\n+    public static void assertCompiledByC2(Method m) {\n@@ -902,1 +905,1 @@\n-    static void assertCompiledAtLevel(Method m, CompLevel level) {\n+    public static void assertCompiledAtLevel(Method m, CompLevel level) {\n@@ -906,1 +909,1 @@\n-    static void assertNotCompiled(Method m) {\n+    public static void assertNotCompiled(Method m) {\n@@ -911,1 +914,1 @@\n-    static void assertCompiled(Method m) {\n+    public static void assertCompiled(Method m) {\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/test\/TestVM.java","additions":20,"deletions":17,"binary":false,"changes":37,"previous_filename":"test\/lib\/jdk\/test\/lib\/hotspot\/ir_framework\/TestVM.java","status":"renamed"},{"patch":"","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/compiler\/lib\/ir_framework\/README.md","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/lib\/jdk\/test\/lib\/hotspot\/ir_framework\/tests\/README.md","status":"renamed"},{"patch":"@@ -24,3 +24,1 @@\n-package jdk.test.lib.hotspot.ir_framework.tests;\n-\n-import jdk.test.lib.hotspot.ir_framework.*;\n+package compiler.lib.ir_framework;\n@@ -30,0 +28,1 @@\n+ * @requires vm.flagless\n@@ -31,2 +30,2 @@\n- * @library \/test\/lib\n- * @run driver jdk.test.lib.hotspot.ir_framework.tests.TestAccessModifiers\n+ * @library \/test\/lib \/\n+ * @run driver compiler.lib.ir_framework.TestAccessModifiers\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/compiler\/lib\/ir_framework\/TestAccessModifiers.java","additions":4,"deletions":5,"binary":false,"changes":9,"previous_filename":"test\/lib\/jdk\/test\/lib\/hotspot\/ir_framework\/tests\/TestAccessModifiers.java","status":"renamed"},{"patch":"@@ -24,1 +24,1 @@\n-package jdk.test.lib.hotspot.ir_framework.tests;\n+package compiler.lib.ir_framework;\n@@ -26,1 +26,1 @@\n-import jdk.test.lib.hotspot.ir_framework.*;\n+import compiler.lib.ir_framework.shared.TestFormatException;\n@@ -28,1 +28,0 @@\n-import jdk.test.lib.hotspot.ir_framework.Compiler;\n@@ -41,1 +40,1 @@\n- * @requires vm.compiler2.enabled\n+ * @requires vm.compiler2.enabled & vm.flagless\n@@ -43,2 +42,2 @@\n- * @library \/test\/lib\n- * @run driver jdk.test.lib.hotspot.ir_framework.tests.TestBadFormat\n+ * @library \/test\/lib \/\n+ * @run driver compiler.lib.ir_framework.TestBadFormat\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/compiler\/lib\/ir_framework\/TestBadFormat.java","additions":5,"deletions":6,"binary":false,"changes":11,"previous_filename":"test\/lib\/jdk\/test\/lib\/hotspot\/ir_framework\/tests\/TestBadFormat.java","status":"renamed"},{"patch":"@@ -24,1 +24,1 @@\n-package jdk.test.lib.hotspot.ir_framework.tests;\n+package compiler.lib.ir_framework;\n@@ -26,1 +26,1 @@\n-import jdk.test.lib.hotspot.ir_framework.*;\n+import compiler.lib.ir_framework.test.TestVM;\n@@ -34,1 +34,1 @@\n- * @requires vm.compiler2.enabled\n+ * @requires vm.compiler2.enabled & vm.flagless\n@@ -36,1 +36,1 @@\n- * @library \/test\/lib\n+ * @library \/test\/lib \/\n@@ -40,1 +40,1 @@\n- *                   jdk.test.lib.hotspot.ir_framework.tests.TestBasics\n+ *                   compiler.lib.ir_framework.TestBasics\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/compiler\/lib\/ir_framework\/TestBasics.java","additions":5,"deletions":5,"binary":false,"changes":10,"previous_filename":"test\/lib\/jdk\/test\/lib\/hotspot\/ir_framework\/tests\/TestBasics.java","status":"renamed"},{"patch":"@@ -24,1 +24,1 @@\n-package jdk.test.lib.hotspot.ir_framework.tests;\n+package compiler.lib.ir_framework;\n@@ -26,1 +26,1 @@\n-import jdk.test.lib.hotspot.ir_framework.*;\n+import compiler.lib.ir_framework.test.TestVM;\n@@ -32,0 +32,1 @@\n+ * @requires vm.flagless\n@@ -34,1 +35,1 @@\n- * @library \/test\/lib\n+ * @library \/test\/lib \/\n@@ -38,1 +39,1 @@\n- *                   jdk.test.lib.hotspot.ir_framework.tests.TestCompLevels\n+ *                   compiler.lib.ir_framework.TestCompLevels\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/compiler\/lib\/ir_framework\/TestCompLevels.java","additions":5,"deletions":4,"binary":false,"changes":9,"previous_filename":"test\/lib\/jdk\/test\/lib\/hotspot\/ir_framework\/tests\/TestCompLevels.java","status":"renamed"},{"patch":"@@ -24,1 +24,1 @@\n-package jdk.test.lib.hotspot.ir_framework.tests;\n+package compiler.lib.ir_framework;\n@@ -26,1 +26,1 @@\n-import jdk.test.lib.hotspot.ir_framework.*;\n+import compiler.lib.ir_framework.test.TestVM;\n@@ -28,1 +28,0 @@\n-import jdk.test.lib.hotspot.ir_framework.Compiler;\n@@ -37,1 +36,1 @@\n- * @requires vm.debug == true & vm.compMode != \"Xint\" & vm.compiler2.enabled\n+ * @requires vm.debug == true & vm.compMode != \"Xint\" & vm.compiler2.enabled & vm.flagless\n@@ -40,1 +39,1 @@\n- * @library \/test\/lib\n+ * @library \/test\/lib \/\n@@ -44,1 +43,1 @@\n- *                   jdk.test.lib.hotspot.ir_framework.tests.TestControls\n+ *                   compiler.lib.ir_framework.TestControls\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/compiler\/lib\/ir_framework\/TestControls.java","additions":5,"deletions":6,"binary":false,"changes":11,"previous_filename":"test\/lib\/jdk\/test\/lib\/hotspot\/ir_framework\/tests\/TestControls.java","status":"renamed"},{"patch":"@@ -0,0 +1,73 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework;\n+\n+\/*\n+ * @test\n+ * @requires vm.debug == true & vm.compMode != \"Xint\" & vm.compiler2.enabled & vm.flagless\n+ * @summary Sanity test remaining framework property flags.\n+ * @library \/test\/lib \/\n+ * @run main\/othervm -DFlipC1C2=true compiler.lib.ir_framework.TestDFlags\n+ * @run main\/othervm -DExcludeRandom=true compiler.lib.ir_framework.TestDFlags\n+ * @run main\/othervm -DVerifyVM=true compiler.lib.ir_framework.TestDFlags\n+ * @run main\/othervm -DDumpReplay=true compiler.lib.ir_framework.TestDFlags\n+ * @run main\/othervm -DVerbose=true compiler.lib.ir_framework.TestDFlags\n+ * @run main\/othervm -DShuffleTests=false compiler.lib.ir_framework.TestDFlags\n+ * @run main\/othervm -DReproduce=true compiler.lib.ir_framework.TestDFlags\n+ * @run main\/othervm -DReportStdout=true compiler.lib.ir_framework.TestDFlags\n+ * @run main\/othervm -DGCAfter=true compiler.lib.ir_framework.TestDFlags\n+ * @run main\/othervm -DPrintTimes=true compiler.lib.ir_framework.TestDFlags\n+ * @run main\/othervm -DVerifyIR=false compiler.lib.ir_framework.TestDFlags\n+ *\/\n+\n+public class TestDFlags {\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    @Test\n+    public int c1() {\n+        return 34;\n+    }\n+\n+\n+    @Test\n+    public void c2() {\n+        for (int i = 0; i < 100; i++) {\n+        }\n+    }\n+\n+    @Test\n+    public void c2_2() {\n+        for (int i = 0; i < 100; i++) {\n+        }\n+    }\n+\n+    @Test\n+    public void c2_3() {\n+        for (int i = 0; i < 100; i++) {\n+        }\n+    }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/compiler\/lib\/ir_framework\/TestDFlags.java","additions":73,"deletions":0,"binary":false,"changes":73,"status":"added"},{"patch":"@@ -24,1 +24,1 @@\n-package jdk.test.lib.hotspot.ir_framework.tests;\n+package compiler.lib.ir_framework;\n@@ -26,2 +26,0 @@\n-import jdk.test.lib.Utils;\n-import jdk.test.lib.hotspot.ir_framework.*;\n@@ -29,0 +27,1 @@\n+import jdk.test.lib.Utils;\n@@ -35,1 +34,1 @@\n- * @requires vm.debug == true\n+ * @requires vm.debug == true & vm.flagless\n@@ -37,2 +36,2 @@\n- * @library \/test\/lib\n- * @run driver jdk.test.lib.hotspot.ir_framework.tests.TestDIgnoreCompilerControls\n+ * @library \/test\/lib \/\n+ * @run driver compiler.lib.ir_framework.TestDIgnoreCompilerControls\n@@ -60,1 +59,1 @@\n-                \"jdk.test.lib.hotspot.ir_framework.tests.TestDIgnoreCompilerControls\", flagValue);\n+                \"compiler.lib.ir_framework.TestDIgnoreCompilerControls\", flagValue);\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/compiler\/lib\/ir_framework\/TestDIgnoreCompilerControls.java","additions":6,"deletions":7,"binary":false,"changes":13,"previous_filename":"test\/lib\/jdk\/test\/lib\/hotspot\/ir_framework\/tests\/TestDIgnoreCompilerControls.java","status":"renamed"},{"patch":"@@ -0,0 +1,93 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework;\n+\n+import compiler.lib.ir_framework.driver.TestVMException;\n+import jdk.test.lib.Utils;\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+\/*\n+ * @test\n+ * @requires vm.debug == true & vm.flagless\n+ * @summary Test -DScenarios property flag. Run with othervm which should not be done when writing tests using the framework.\n+ * @library \/test\/lib \/\n+ * @run main\/othervm -DScenarios=1,5,10 compiler.lib.ir_framework.TestDScenarios test\n+ * @run main\/othervm -DScenarios=1,4 compiler.lib.ir_framework.TestDScenarios test\n+ * @run main\/othervm -DScenarios=3,4,9 compiler.lib.ir_framework.TestDScenarios test\n+ * @run driver compiler.lib.ir_framework.TestDScenarios test2\n+ * @run driver compiler.lib.ir_framework.TestDScenarios\n+ *\/\n+\n+public class TestDScenarios {\n+    public static void main(String[] args) throws Exception {\n+        if (args.length > 0) {\n+            switch (args[0]) {\n+                case \"test\" -> {\n+                    Scenario s1 = new Scenario(1);\n+                    Scenario s2 = new Scenario(5);\n+                    Scenario s3 = new Scenario(10);\n+                    Scenario bad = new Scenario(0, \"-Flagdoesnotexist\"); \/\/ not executed\n+                    new TestFramework().addScenarios(bad, s1, s2, s3).start();\n+                }\n+                case \"test2\" -> {\n+                    try {\n+                        TestFramework.run(DScenariosBad.class);\n+                        throw new RuntimeException(\"should not reach\");\n+                    } catch (TestVMException e) {\n+                        System.out.println(e.getExceptionInfo());\n+                        Asserts.assertTrue(e.getExceptionInfo().contains(\"Expected DScenariosBad exception\"));\n+                    }\n+                }\n+                default -> {\n+                    \/\/ Invalid -DScenarios set and thus exception thrown when Scenario class is statically initialized.\n+                    Scenario s = new Scenario(3);\n+                    throw new RuntimeException(\"should not reach\");\n+                }\n+            }\n+        } else {\n+            \/\/ Test invalid -DScenario flag.\n+            OutputAnalyzer oa;\n+            ProcessBuilder process = ProcessTools.createJavaProcessBuilder(\n+                    \"-Dtest.jdk=\" + Utils.TEST_JDK, \"-DScenarios=a,1,b,10\",\n+                    \"compiler.lib.ir_framework.TestDScenarios\", \" test3\");\n+            oa = ProcessTools.executeProcess(process);\n+            oa.shouldNotHaveExitValue(0);\n+            System.out.println(oa.getOutput());\n+            Asserts.assertTrue(oa.getOutput().contains(\"TestRunException: Provided a scenario index\"));\n+        }\n+    }\n+\n+    @Test\n+    public void test() {\n+    }\n+}\n+\n+class DScenariosBad {\n+    @Test\n+    public void test() {\n+        throw new RuntimeException(\"Expected DScenariosBad exception\");\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/compiler\/lib\/ir_framework\/TestDScenarios.java","additions":93,"deletions":0,"binary":false,"changes":93,"status":"added"},{"patch":"@@ -24,1 +24,1 @@\n-package jdk.test.lib.hotspot.ir_framework.tests;\n+package compiler.lib.ir_framework;\n@@ -26,0 +26,2 @@\n+import compiler.lib.ir_framework.driver.TestVMException;\n+import compiler.lib.ir_framework.shared.NoTestsRunException;\n@@ -27,1 +29,0 @@\n-import jdk.test.lib.hotspot.ir_framework.*;\n@@ -34,0 +35,1 @@\n+ * @requires vm.flagless\n@@ -35,2 +37,2 @@\n- * @library \/test\/lib\n- * @run driver jdk.test.lib.hotspot.ir_framework.tests.TestDTestAndExclude\n+ * @library \/test\/lib \/\n+ * @run driver compiler.lib.ir_framework.TestDTestAndExclude\n@@ -97,1 +99,1 @@\n-                \"jdk.test.lib.hotspot.ir_framework.tests.TestDTestAndExclude\", arg);\n+                \"compiler.lib.ir_framework.TestDTestAndExclude\", arg);\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/compiler\/lib\/ir_framework\/TestDTestAndExclude.java","additions":7,"deletions":5,"binary":false,"changes":12,"previous_filename":"test\/lib\/jdk\/test\/lib\/hotspot\/ir_framework\/tests\/TestDTestAndExclude.java","status":"renamed"},{"patch":"@@ -24,1 +24,1 @@\n-package jdk.test.lib.hotspot.ir_framework.tests;\n+package compiler.lib.ir_framework;\n@@ -26,1 +26,1 @@\n-import jdk.test.lib.hotspot.ir_framework.*;\n+import compiler.lib.ir_framework.driver.IRViolationException;\n@@ -39,1 +39,1 @@\n- * @requires vm.debug == true & vm.compMode != \"Xint\" & vm.compiler2.enabled\n+ * @requires vm.debug == true & vm.compMode != \"Xint\" & vm.compiler2.enabled & vm.flagless\n@@ -42,2 +42,2 @@\n- * @library \/test\/lib\n- * @run main\/othervm -DPrintIREncoding=true jdk.test.lib.hotspot.ir_framework.tests.TestIRMatching\n+ * @library \/test\/lib \/\n+ * @run main\/othervm -DPrintIREncoding=true compiler.lib.ir_framework.TestIRMatching\n@@ -188,1 +188,1 @@\n-                 BadFailOnConstraint.create(CheckCastArray.class, \"array()\", 2, 2,\"cmp\", \"precise klass\", \"tests\/MyClass\"),\n+                 BadFailOnConstraint.create(CheckCastArray.class, \"array()\", 2, 2,\"cmp\", \"precise klass\", \"ir_framework\/MyClass\"),\n@@ -416,1 +416,1 @@\n-    @IR(failOn = {IRNode.STORE_OF_CLASS, \"jdk\/test\/lib\/hotspot\/ir_framework\/tests\/MultipleFailOnBad\", IRNode.CALL, IRNode.ALLOC})\n+    @IR(failOn = {IRNode.STORE_OF_CLASS, \"compiler\/lib\/ir_framework\/MultipleFailOnBad\", IRNode.CALL, IRNode.ALLOC})\n@@ -440,1 +440,1 @@\n-    @IR(failOn = {IRNode.STORE_OF_CLASS, \"UnknownClass\", IRNode.ALLOC_OF, \"jdk\/test\/lib\/hotspot\/ir_framework\/tests\/MyClassSub\"})\n+    @IR(failOn = {IRNode.STORE_OF_CLASS, \"UnknownClass\", IRNode.ALLOC_OF, \"compiler\/lib\/ir_framework\/MyClassSub\"})\n@@ -638,4 +638,4 @@\n-                  IRNode.STORE_OF_CLASS, \"jdk\/test\/lib\/hotspot\/ir_framework\/tests\/MyClass\", \"1\",\n-                  IRNode.STORE_I_OF_CLASS, \"jdk\/test\/lib\/hotspot\/ir_framework\/tests\/MyClass\", \"1\",\n-                  IRNode.STORE_OF_CLASS, \"jdk\/test\/lib\/hotspot\/ir_framework\/tests\/GoodCount\", \"1\",\n-                  IRNode.STORE_L_OF_CLASS, \"jdk\/test\/lib\/hotspot\/ir_framework\/tests\/GoodCount\", \"1\",\n+                  IRNode.STORE_OF_CLASS, \"compiler\/lib\/ir_framework\/MyClass\", \"1\",\n+                  IRNode.STORE_I_OF_CLASS, \"compiler\/lib\/ir_framework\/MyClass\", \"1\",\n+                  IRNode.STORE_OF_CLASS, \"compiler\/lib\/ir_framework\/GoodCount\", \"1\",\n+                  IRNode.STORE_L_OF_CLASS, \"compiler\/lib\/ir_framework\/GoodCount\", \"1\",\n@@ -806,2 +806,2 @@\n-    @IR(failOn = {IRNode.ALLOC_ARRAY_OF, \"jdk\/test\/lib\/hotspot\/ir_framework\/tests\/MySubClass\"}) \/\/ Does not fail\n-    @IR(failOn = {IRNode.ALLOC_ARRAY_OF, \"jdk\/test\/lib\/hotspot\/ir_framework\/tests\/MyClass\"})\n+    @IR(failOn = {IRNode.ALLOC_ARRAY_OF, \"compiler\/lib\/ir_framework\/MySubClass\"}) \/\/ Does not fail\n+    @IR(failOn = {IRNode.ALLOC_ARRAY_OF, \"compiler\/lib\/ir_framework\/MyClass\"})\n@@ -823,1 +823,1 @@\n-    @IR(failOn = {IRNode.LOAD_OF_CLASS, \"jdk\/test\/lib\/hotspot\/ir_framework\/tests\/Loads\"})\n+    @IR(failOn = {IRNode.LOAD_OF_CLASS, \"compiler\/lib\/ir_framework\/Loads\"})\n@@ -1108,1 +1108,1 @@\n-                  IRNode.CHECKCAST_ARRAY_OF, \"tests\/MyClass\"}) \/\/ fails\n+                  IRNode.CHECKCAST_ARRAY_OF, \"ir_framework\/MyClass\"}) \/\/ fails\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/compiler\/lib\/ir_framework\/TestIRMatching.java","additions":16,"deletions":16,"binary":false,"changes":32,"previous_filename":"test\/lib\/jdk\/test\/lib\/hotspot\/ir_framework\/tests\/TestIRMatching.java","status":"renamed"},{"patch":"@@ -24,1 +24,1 @@\n-package jdk.test.lib.hotspot.ir_framework.tests;\n+package compiler.lib.ir_framework;\n@@ -26,0 +26,2 @@\n+import compiler.lib.ir_framework.driver.IRViolationException;\n+import compiler.lib.ir_framework.shared.TestRunException;\n@@ -27,1 +29,0 @@\n-import jdk.test.lib.hotspot.ir_framework.*;\n@@ -33,1 +34,1 @@\n- * @requires vm.compMode != \"Xint\" & vm.compiler2.enabled\n+ * @requires vm.compMode != \"Xint\" & vm.compiler2.enabled & vm.flagless\n@@ -35,2 +36,2 @@\n- * @library \/test\/lib\n- * @run driver jdk.test.lib.hotspot.ir_framework.tests.TestRunTests\n+ * @library \/test\/lib \/\n+ * @run driver compiler.lib.ir_framework.TestRunTests\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/compiler\/lib\/ir_framework\/TestRunTests.java","additions":6,"deletions":5,"binary":false,"changes":11,"previous_filename":"test\/lib\/jdk\/test\/lib\/hotspot\/ir_framework\/tests\/TestRunTests.java","status":"renamed"},{"patch":"@@ -24,5 +24,1 @@\n-package jdk.test.lib.hotspot.ir_framework.tests;\n-\n-import jdk.test.lib.hotspot.ir_framework.Scenario;\n-import jdk.test.lib.hotspot.ir_framework.Test;\n-import jdk.test.lib.hotspot.ir_framework.TestFramework;\n+package compiler.lib.ir_framework;\n@@ -32,0 +28,1 @@\n+ * @requires vm.flagless\n@@ -33,2 +30,2 @@\n- * @library \/test\/lib\n- * @run driver jdk.test.lib.hotspot.ir_framework.tests.TestSanity\n+ * @library \/test\/lib \/\n+ * @run driver compiler.lib.ir_framework.TestSanity\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/compiler\/lib\/ir_framework\/TestSanity.java","additions":4,"deletions":7,"binary":false,"changes":11,"previous_filename":"test\/lib\/jdk\/test\/lib\/hotspot\/ir_framework\/tests\/TestSanity.java","status":"renamed"},{"patch":"@@ -0,0 +1,105 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework;\n+\n+import compiler.lib.ir_framework.shared.TestRunException;\n+import jdk.test.lib.Asserts;\n+\n+\/*\n+ * @test\n+ * @requires vm.compMode != \"Xint\" & vm.compiler2.enabled & vm.flagless\n+ * @summary Test scenarios with the framework.\n+ * @library \/test\/lib \/\n+ * @run driver compiler.lib.ir_framework.TestScenarios\n+ *\/\n+\n+public class TestScenarios {\n+    public static void main(String[] args) {\n+        Scenario sDefault = new Scenario(0);\n+        Scenario s1 = new Scenario(1, \"-XX:SuspendRetryCount=51\");\n+        Scenario s2 = new Scenario(2, \"-XX:SuspendRetryCount=52\");\n+        Scenario s3 = new Scenario(3, \"-XX:SuspendRetryCount=53\");\n+        Scenario s3dup = new Scenario(3, \"-XX:SuspendRetryCount=53\");\n+        try {\n+            new TestFramework().addScenarios(sDefault, s1, s2, s3).start();\n+            Asserts.fail(\"Should not reach\");\n+        } catch (TestRunException e) {\n+            Asserts.assertTrue(e.getMessage().contains(\"The following scenarios have failed: #0, #1, #3\"), e.getMessage());\n+        }\n+        try {\n+            new TestFramework().addScenarios(s1, s2, s3).start();\n+            Asserts.fail(\"Should not reach\");\n+        } catch (TestRunException e) {\n+            Asserts.assertTrue(e.getMessage().contains(\"The following scenarios have failed: #1, #3\"), e.getMessage());\n+        }\n+        new TestFramework(ScenarioTest.class).addScenarios(s1, s2, s3).start();\n+        try {\n+            new TestFramework().addScenarios(s1, s3dup, s2, s3).start();\n+            Asserts.fail(\"Should not reach\");\n+        } catch (RuntimeException e) {\n+            Asserts.assertTrue(e.getMessage().contains(\"Cannot define two scenarios with the same index 3\"), e.getMessage());\n+        }\n+        try {\n+            new TestFramework(MyExceptionTest.class).addScenarios(s1, s2, s3).start();\n+            Asserts.fail(\"Should not reach\");\n+        } catch (TestRunException e) {\n+            Asserts.assertTrue(s1.getTestVMOutput().contains(\"Caused by: compiler.lib.ir_framework.MyScenarioException\"));\n+            Asserts.assertTrue(s2.getTestVMOutput().contains(\"Caused by: compiler.lib.ir_framework.MyScenarioException\"));\n+            Asserts.assertTrue(s3.getTestVMOutput().contains(\"Caused by: compiler.lib.ir_framework.MyScenarioException\"));\n+        } catch (Exception e) {\n+            Asserts.fail(\"Should not catch other exceptions\");\n+        }\n+\n+    }\n+\n+    @Test\n+    @IR(applyIf = {\"SuspendRetryCount\", \"50\"}, counts = {IRNode.CALL, \"1\"})\n+    public void failDefault() {\n+    }\n+\n+    @Test\n+    @IR(applyIf = {\"SuspendRetryCount\", \"51\"}, counts = {IRNode.CALL, \"1\"})\n+    @IR(applyIf = {\"SuspendRetryCount\", \"53\"}, counts = {IRNode.CALL, \"1\"})\n+    public void failS3() {\n+    }\n+}\n+\n+class ScenarioTest {\n+    @Test\n+    @IR(applyIf = {\"SuspendRetryCount\", \"54\"}, counts = {IRNode.CALL, \"1\"})\n+    public void doesNotFail() {\n+    }\n+}\n+\n+class MyExceptionTest {\n+    int iFld;\n+    @Test\n+    @IR(failOn = IRNode.STORE) \/\/ Not evaluated due to MyScenarioException\n+    public void test() {\n+        iFld = 42;\n+        throw new MyScenarioException();\n+    }\n+}\n+\n+class MyScenarioException extends RuntimeException {}\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/compiler\/lib\/ir_framework\/TestScenarios.java","additions":105,"deletions":0,"binary":false,"changes":105,"status":"added"},{"patch":"@@ -0,0 +1,156 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework;\n+\n+import compiler.lib.ir_framework.driver.TestVMException;\n+import compiler.lib.ir_framework.shared.TestFormatException;\n+import jdk.test.lib.Asserts;\n+\n+\/*\n+ * @test\n+ * @requires vm.flagless\n+ * @summary Test the framework with helper classes.\n+ * @library \/test\/lib \/\n+ * @run driver compiler.lib.ir_framework.TestWithHelperClasses\n+ *\/\n+\n+public class TestWithHelperClasses {\n+\n+    public static void main(String[] args) {\n+        new TestFramework().addHelperClasses(Helper1.class, Helper2.class).start();\n+        try {\n+            new TestFramework().addHelperClasses(Helper1.class).start();\n+            shouldNotReach();\n+        } catch (TestVMException e) {\n+            Asserts.assertFalse(e.getExceptionInfo().contains(\"public static void compiler.lib.ir_framework.Helper1.foo() should have been C2 compiled\"));\n+            Asserts.assertFalse(TestFramework.getLastTestVMOutput().contains(\"public static void compiler.lib.ir_framework.Helper1.foo() should have been C2 compiled\"));\n+            Asserts.assertTrue(TestFramework.getLastTestVMOutput().contains(\"public static void compiler.lib.ir_framework.Helper2.foo() should have been C2 compiled\"));\n+            Asserts.assertTrue(e.getExceptionInfo().contains(\"public static void compiler.lib.ir_framework.Helper2.foo() should have been C2 compiled\"));\n+            Asserts.assertFalse(TestFramework.getLastTestVMOutput().contains(\"Should not be executed\"));\n+            Asserts.assertFalse(e.getExceptionInfo().contains(\"Should not be executed\"));\n+        }\n+\n+        try {\n+            new TestFramework(BadHelperClass.class).addHelperClasses(BadHelper.class).start();\n+            shouldNotReach();\n+        } catch (TestFormatException e) {\n+            Asserts.assertTrue(e.getMessage().contains(\"Cannot use @Test annotation in helper class\"));\n+            Asserts.assertTrue(e.getMessage().contains(\"Cannot use @Check annotation in helper class\"));\n+            Asserts.assertTrue(e.getMessage().contains(\"Cannot use @Run annotation in helper class\"));\n+            Asserts.assertTrue(e.getMessage().contains(\"noTestInHelper\"));\n+            Asserts.assertTrue(e.getMessage().contains(\"test2\"));\n+            Asserts.assertTrue(e.getMessage().contains(\"check2\"));\n+            Asserts.assertTrue(e.getMessage().contains(\"test3\"));\n+            Asserts.assertTrue(e.getMessage().contains(\"run3\"));\n+        }\n+\n+        try {\n+            new TestFramework(TestAsHelper.class).addHelperClasses(TestAsHelper.class).start();\n+            shouldNotReach();\n+        } catch (TestFormatException e) {\n+            Asserts.assertTrue(e.getMessage().contains(\"Cannot specify test class compiler.lib.ir_framework.\" +\n+                                                       \"TestAsHelper as helper class, too\"));\n+        }\n+\n+        try {\n+            new TestFramework().addHelperClasses(NestedHelper.class).start();\n+            shouldNotReach();\n+        } catch (TestFormatException e) {\n+            Asserts.assertTrue(e.getMessage().contains(\"Nested class\"));\n+            Asserts.assertTrue(e.getMessage().contains(\"TestWithHelperClasses$NestedHelper inside test class\"));\n+        }\n+    }\n+\n+    public static void shouldNotReach() {\n+        throw new RuntimeException(\"should not reach\");\n+    }\n+\n+    @Test\n+    public void test() throws NoSuchMethodException {\n+        TestFramework.assertCompiledByC2(Helper1.class.getMethod(\"foo\"));\n+        TestFramework.assertCompiledByC2(Helper2.class.getMethod(\"foo\"));\n+        TestFramework.assertCompiledByC2(NestedHelper.class.getMethod(\"foo\"));\n+        TestFramework.assertCompiledByC2(StaticNestedHelper.class.getMethod(\"foo\"));\n+    }\n+\n+    class NestedHelper {\n+        @ForceCompile(CompLevel.C2)\n+        public void foo() {\n+            throw new RuntimeException(\"Should not be executed\");\n+        }\n+    }\n+\n+\n+    static class StaticNestedHelper {\n+        @ForceCompile(CompLevel.C2)\n+        public void foo() {\n+            throw new RuntimeException(\"Should not be executed\");\n+        }\n+    }\n+}\n+\n+class TestAsHelper {\n+\n+    @Test\n+    public void foo() {}\n+}\n+\n+class Helper1 {\n+\n+    @ForceCompile(CompLevel.C2)\n+    public static void foo() {\n+        throw new RuntimeException(\"Should not be executed\");\n+    }\n+}\n+\n+class Helper2 {\n+\n+    @ForceCompile(CompLevel.C2)\n+    public static void foo() {\n+        throw new RuntimeException(\"Should not be executed\");\n+    }\n+}\n+\n+class BadHelperClass {\n+    @Test\n+    public void test1() {}\n+ }\n+\n+\n+class BadHelper {\n+    @Test\n+    public void noTestInHelper() {}\n+\n+    @Test\n+    public void test2() {}\n+\n+    @Check(test = \"test2\")\n+    public void check2() {}\n+\n+    @Test\n+    public void test3() {}\n+\n+    @Run(test = \"test3\")\n+    public void run3() {}\n+}\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/compiler\/lib\/ir_framework\/TestWithHelperClasses.java","additions":156,"deletions":0,"binary":false,"changes":156,"status":"added"},{"patch":"@@ -24,3 +24,1 @@\n-package jdk.test.lib.hotspot.ir_framework.examples;\n-\n-import jdk.test.lib.hotspot.ir_framework.*;\n+package compiler.lib.ir_framework.examples;\n@@ -28,0 +26,2 @@\n+import compiler.lib.ir_framework.*;\n+import compiler.lib.ir_framework.test.TestVM;\n@@ -31,2 +31,2 @@\n- * @library \/test\/lib\n- * @run driver jdk.test.lib.hotspot.ir_framework.examples.BaseTestExample\n+ * @library \/test\/lib \/\n+ * @run driver compiler.lib.ir_framework.examples.BaseTestExample\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/compiler\/lib\/ir_framework\/examples\/BaseTestExample.java","additions":5,"deletions":5,"binary":false,"changes":10,"previous_filename":"test\/lib\/jdk\/test\/lib\/hotspot\/ir_framework\/examples\/BaseTestExample.java","status":"renamed"},{"patch":"@@ -24,1 +24,1 @@\n-package jdk.test.lib.hotspot.ir_framework.examples;\n+package compiler.lib.ir_framework.examples;\n@@ -26,1 +26,2 @@\n-import jdk.test.lib.hotspot.ir_framework.*;\n+import compiler.lib.ir_framework.*;\n+import compiler.lib.ir_framework.test.TestVM;\n@@ -31,2 +32,2 @@\n- * @library \/test\/lib\n- * @run driver jdk.test.lib.hotspot.ir_framework.examples.CheckedTestExample\n+ * @library \/test\/lib \/\n+ * @run driver compiler.lib.ir_framework.examples.CheckedTestExample\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/compiler\/lib\/ir_framework\/examples\/CheckedTestExample.java","additions":5,"deletions":4,"binary":false,"changes":9,"previous_filename":"test\/lib\/jdk\/test\/lib\/hotspot\/ir_framework\/examples\/CheckedTestExample.java","status":"renamed"},{"patch":"@@ -24,1 +24,1 @@\n-package jdk.test.lib.hotspot.ir_framework.examples;\n+package compiler.lib.ir_framework.examples;\n@@ -26,1 +26,2 @@\n-import jdk.test.lib.hotspot.ir_framework.*;\n+import compiler.lib.ir_framework.*;\n+import compiler.lib.ir_framework.test.TestVM;\n@@ -31,2 +32,2 @@\n- * @library \/test\/lib\n- * @run driver jdk.test.lib.hotspot.ir_framework.examples.CustomRunTestExample\n+ * @library \/test\/lib \/\n+ * @run driver compiler.lib.ir_framework.examples.CustomRunTestExample\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/compiler\/lib\/ir_framework\/examples\/CustomRunTestExample.java","additions":5,"deletions":4,"binary":false,"changes":9,"previous_filename":"test\/lib\/jdk\/test\/lib\/hotspot\/ir_framework\/examples\/CustomRunTestExample.java","status":"renamed"},{"patch":"@@ -24,1 +24,1 @@\n-package jdk.test.lib.hotspot.ir_framework.examples;\n+package compiler.lib.ir_framework.examples;\n@@ -26,1 +26,2 @@\n-import jdk.test.lib.hotspot.ir_framework.*;\n+import compiler.lib.ir_framework.*;\n+import compiler.lib.ir_framework.driver.IRViolationException;\n@@ -31,2 +32,2 @@\n- * @library \/test\/lib\n- * @run driver jdk.test.lib.hotspot.ir_framework.examples.IRExample\n+ * @library \/test\/lib \/\n+ * @run driver compiler.lib.ir_framework.examples.IRExample\n@@ -35,1 +36,0 @@\n-\n@@ -76,1 +76,0 @@\n-\n@@ -82,2 +81,3 @@\n-            \/\/ Expected. Check output to see how IR failures are reported.\n-            throw e;\n+            \/\/ Expected. Check stderr\/stdout to see how IR failures are reported (always printed, regardless if\n+            \/\/ exception is thrown or not). Uncomment the \"throw\" statement below to get a completely failing test.\n+            \/\/throw e;\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/compiler\/lib\/ir_framework\/examples\/IRExample.java","additions":8,"deletions":8,"binary":false,"changes":16,"previous_filename":"test\/lib\/jdk\/test\/lib\/hotspot\/ir_framework\/examples\/IRExample.java","status":"renamed"},{"patch":"@@ -1,33 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.test.lib.hotspot.ir_framework;\n-\n-\/**\n- * Checked internal exceptions in the framework to propagate error handling.\n- *\/\n-class CheckedTestFrameworkException extends Exception {\n-    CheckedTestFrameworkException(String msg) {\n-        super(msg);\n-    }\n-}\n","filename":"test\/lib\/jdk\/test\/lib\/hotspot\/ir_framework\/CheckedTestFrameworkException.java","additions":0,"deletions":33,"binary":false,"changes":33,"status":"deleted"},{"patch":"@@ -1,166 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.test.lib.hotspot.ir_framework;\n-\n-import jdk.test.lib.Utils;\n-\n-import java.lang.reflect.Executable;\n-import java.util.HashMap;\n-import java.util.Map;\n-\n-\/**\n- * Compilation levels used by the framework to initiate a compilation of a method. The compilation levels map to the used\n- * levels in HotSpot (apart from the framework specific values {@link #SKIP} and {@link #WAIT_FOR_COMPILATION} that cannot\n- * be found in HotSpot). The HotSpot specific levels must be in sync with hotspot\/share\/compiler\/compilerDefinitions.hpp.\n- *\n- * <p>\n- * The compilation levels can be specified in the {@link Test}, {@link ForceCompile}, and\n- * {@link ForceCompileClassInitializer} annotation.\n- *\n- * @see Test\n- * @see ForceCompile\n- * @see ForceCompileClassInitializer\n- *\/\n-public enum CompLevel {\n-    \/**\n-     * Can only be used at {@link Test#compLevel()}. After the warm-up, the framework keeps invoking the test over a span\n-     * of 10s (configurable by setting the property flag {@code -DWaitForCompilationTimeout}) until HotSpot compiles the\n-     * {@link Test} method. If the method was not compiled after 10s, an exception is thrown. The framework does not wait\n-     * for the compilation if the test VM is run with {@code -Xcomp}, {@code -XX:-UseCompiler}, or\n-     * {@code -DExcludeRandom=true}.\n-     *\/\n-    WAIT_FOR_COMPILATION(-4),\n-    \/**\n-     * Can only be used at {@link Test#compLevel()}. Skip a compilation of the {@link Test @Test} method completely.\n-     *\/\n-    SKIP(-3),\n-    \/**\n-     *  Use any compilation level depending on the usage:\n-     *  <ul>\n-     *      <li><p>{@link Test @Test}, {@link ForceCompile @ForceCompile}: Use the highest available compilation level\n-     *      which is usually C2.<\/li>\n-     *      <li><p>{@link DontCompile @DontCompile}: Prevents any compilation of the associated helper method.<\/li>\n-     *  <\/ul>\n-     *\/\n-    ANY(-2),\n-    \/**\n-     *  Compilation level 1: C1 compilation without any profile information.\n-     *\/\n-    C1_SIMPLE(1),\n-    \/**\n-     *  Compilation level 2: C1 compilation with limited profile information: Includes Invocation and backedge counters.\n-     *\/\n-    C1_LIMITED_PROFILE(2),\n-    \/**\n-     *  Compilation level 3: C1 compilation with full profile information: Includes Invocation and backedge counters with MDO.\n-     *\/\n-    C1_FULL_PROFILE(3),\n-    \/**\n-     * Compilation level 4: C2 compilation with full optimizations.\n-     *\/\n-    C2(4),\n-\n-    ;\n-\n-    private static final Map<Integer, CompLevel> TYPES_BY_VALUE = new HashMap<>();\n-    private final int value;\n-\n-    static {\n-        for (CompLevel level : CompLevel.values()) {\n-            TYPES_BY_VALUE.put(level.value, level);\n-        }\n-    }\n-\n-    CompLevel(int level) {\n-        this.value = level;\n-    }\n-\n-    \/**\n-     * Get the compilation level as integer value. These will match the levels specified in HotSpot (if available).\n-     *\n-     * @return the compilation level as integer.\n-     *\/\n-    public int getValue() {\n-        return value;\n-    }\n-\n-    \/**\n-     * Get the compilation level enum from the specified integer.\n-     *\n-     * @param value the compilation level as integer.\n-     * @throws TestRunException if {@code value} does not specify a valid compilation level.\n-     * @return the compilation level enum for {@code value}.\n-     *\/\n-    public static CompLevel forValue(int value) {\n-        CompLevel level = TYPES_BY_VALUE.get(value);\n-        TestRun.check(level != null, \"Invalid compilation level \" + value);\n-        return level;\n-    }\n-\n-    \/**\n-     * Checks if this compilation level is not part of the compiler.\n-     *\/\n-    boolean isNotCompilationLevelOfCompiler(Compiler c) {\n-        return switch (c) {\n-            case C1 -> !isC1();\n-            case C2 -> this != C2;\n-            default -> throw new TestFrameworkException(\"Should not be called with compiler \" + c);\n-        };\n-    }\n-\n-    \/**\n-     * Flip the compilation levels.\n-     *\/\n-    CompLevel flipCompLevel() {\n-        switch (this) {\n-            case C1_SIMPLE, C1_LIMITED_PROFILE, C1_FULL_PROFILE -> {\n-                return CompLevel.C2;\n-            }\n-            case C2 -> {\n-                return CompLevel.C1_SIMPLE;\n-            }\n-        }\n-        return this;\n-    }\n-\n-    \/**\n-     * Return the compilation level when only allowing a compilation with the specified compiler.\n-     *\/\n-    CompLevel excludeCompilationRandomly(Executable ex) {\n-        if (Utils.getRandomInstance().nextBoolean()) {\n-            \/\/ No exclusion\n-            return this;\n-        }\n-        Compiler compiler = TestVM.excludeRandomly(ex);\n-        return switch (compiler) {\n-            case ANY -> SKIP;\n-            case C1 -> isC1() ? SKIP : this;\n-            case C2 -> this == C2 ? SKIP : this;\n-        };\n-    }\n-\n-    private boolean isC1() {\n-        return this == C1_SIMPLE || this == C1_LIMITED_PROFILE || this == C1_FULL_PROFILE;\n-    }\n-}\n","filename":"test\/lib\/jdk\/test\/lib\/hotspot\/ir_framework\/CompLevel.java","additions":0,"deletions":166,"binary":false,"changes":166,"status":"deleted"},{"patch":"@@ -1,126 +0,0 @@\n-# IR Test Framework\n-This folder contains a test framework whose main purpose is to perform regex-based checks on the C2 IR shape of test methods emitted by the VM flags _-XX:+PrintIdeal_ and _-XX:+PrintOptoAssembly_. The framework can also be used for other non-IR matching (and non-compiler) tests by providing easy to use annotations for commonly used testing patterns and compiler control flags.\n-\n-## 1. How to Use the Framework\n-The framework is intended to be used in JTreg tests. The JTreg header of the test must contain `@library \/test\/lib` and should be run as a driver with `@run driver`. Annotate the test code with the supported framework annotations and call the framework from within the test's `main()` method. A simple example is shown below:\n-\n-    \/*\n-     * @test\n-     * @summary A simple test using the test framework.\n-     * @library \/test\/lib\n-     * @run driver my.package.MySimpleTest\n-     *\/\n-    \n-    package my.package;\n-    \n-    import jdk.test.lib.hotspot.ir_framework.*;\n-\n-    public class MySimpleTest {\n-        \n-        public static void main(String[] args) {\n-            TestFramework.run(); \/\/ The framework runs all tests of this class.\n-        }\n-    \n-        @Test\n-        @IR(failOn = IRNode.STORE) \/\/ Fail if the IR of myTest() contains any stores.\n-        public void myTest() {\n-            \/* ... *\/\n-        }\n-    }\n-\n-There are various ways how to set up and run a test within the `main()` method of a JTreg test. These are described and can be found in the [TestFramework](.\/TestFramework.java) class.\n-   \n-## 2. Features\n- The framework offers various annotations and flags to control how your test code should be invoked and being checked. This section gives an overview over all these features.\n-\n-### 2.1 Different Tests\n-There are three kinds of tests depending on how much control is needed over the test invocation.\n-#### Base Tests\n-The simplest form of testing provides a single `@Test` annotated method which the framework will invoke as part of the testing. The test method has no or well-defined arguments that the framework can automatically provide. \n-\n-More information on base tests with a precise definition can be found in the Javadocs of [Test](.\/Test.java). Concrete examples on how to specify a base test can be found in [BaseTestsExample](.\/examples\/BaseTestExample.java).\n-\n-#### Checked Tests\n-The base tests do not provide any way of verification by user code. A checked test enables this by allowing the user to define an additional `@Check` annotated method which is invoked directly after the `@Test` annotated method. This allows the user to perform various checks about the test method including return value verification.\n-\n-More information on checked tests with a precise definition can be found in the Javadocs of [Check](.\/Check.java). Concrete examples on how to specify a checked test can be found in [CheckedTestsExample](.\/examples\/CheckedTestExample.java).\n-\n-#### Custom Run Tests\n-Neither the base nor the checked tests provide any control over how a `@Test` annotated method is invoked in terms of customized argument values and\/or conditions for the invocation itself. A custom run test gives full control over the invocation of the `@Test` annotated method to the user. The framework calls a dedicated `@Run` annotated method from which the user can invoke the `@Test` method according to his\/her needs.\n-\n-More information on checked tests with a precise definition can be found in the Javadocs of [Run](.\/Run.java). Concrete examples on how to specify a custom run test can be found in [CustomRunTestsExample](.\/examples\/CustomRunTestExample.java).\n-\n-### 2.2 IR Verification\n-The main feature of this framework is to perform a simple but yet powerful regex-based C2 IR matching on the output of _-XX:+PrintIdeal_ and _-XX:+PrintOptoAssembly_. For simplicity, we will refer to the \"IR\" or \"IR matching\" when actually meaning the combined output of _-XX:+PrintIdeal_ and _-XX:+PrintOptoAssembly_ for a C2 compilation.\n-\n-The user has the possibility to add an additional `@IR` annotation to any `@Test` annotated method (regardless of the kind of test mentioned in section 2.1) to specify a constraint\/rule on the compiled IR shape. The `@IR` annotation provides two kinds of regex checks:\n-\n- - A `failOn` check that verifies that the provided regex is not matched in the C2 IR.\n- - A `counts` check that verifies that the provided regex is matched a user defined number of times in the C2 IR.\n- \n-A regex can either be a custom string or any of the default regexes provided by the framework in [IRNode](IRNode.java) for some commonly used IR nodes (also provides the possibility of composite regexes).\n-\n-An IR verification cannot always be performed. For example, a JTreg test could be run with _-Xint_ or not a debug build (_-XX:+PrintIdeal_ and _-XX:+PrintOptoAssembly_ are debug build flags). But also CI tier testing could add additional JTreg VM and Javaoptions flags which could make an IR rule unstable. \n-\n-In general, the framework will only perform IR verification if the used VM flags allow a C2 compilation and if non-critical additional JTreg VM and Javaoptions are provided (see whiteflag list in [TestFramework](.\/TestFramework.java)). The user test code, however, can specify any flags which still allow an IR verification to be performed if a C2 compilation is done (expected flags by user defined `@IR` annotations). \n-\n-An `@IR` annotation allows additional preconditions\/restrictions on the currently present VM flags to enable or disable rules when certain flags are present or have a specific value (see `applyIfXX` properties of an `@IR` annotation).\n-\n-More information about IR matching can be found in the Javadocs of [IR](.\/IR.java). Concrete examples on how to specify IR constraint\/rules can be found in [IRExample](.\/examples\/IRExample.java) and [TestIRMatching](.\/tests\/TestIRMatching.java) (an internal framework test).\n-\n-### 2.3 Test VM Flags and Scenarios\n-The recommended way to use the framework is by defining a single `@run driver` statement in the JTreg header which, however, does not allow the specification of additional test VM flags. Instead, the user has the possibility to provide VM flags by calling `TestFramework.runWithFlags()` or by creating a `TestFramework` builder object on which `addFlags()` can be called.\n-\n-If a user wants to provide multiple flag combinations for a single test, he or she has the option to provide different scenarios. A scenario based flag will always have precedence over other user defined flags. More information about scenarios can be found in the Javadocs of [Scenario](.\/Scenario.java).\n-\n-### 2.4 Compiler Controls\n-The framework allows the use of additional compiler control annotations for helper method and classes in the same fashion as JMH does. The following annotations are supported and described in the referenced Javadocs for the annotation class:\n-\n-- [@DontInline](.\/DontInline.java)\n-- [@ForceInline](.\/ForceInline.java)\n-- [@DontCompile](.\/DontCompile.java)\n-- [@ForceCompile](.\/DontCompile.java)\n-- [@ForceCompileClassInitializer](.\/ForceCompileClassInitializer.java)\n-\n-### 2.5 Framework Debug and Stress Flags\n-The framework provides various stress and debug flags. They should mainly be used as JTreg VM and\/or Javaoptions (apart from `VerifyIR`). The following (property) flags are supported:\n-\n-- `-DVerifyIR=false`: Explicitly disable IR verification. This is useful, for example, if some scenarios use VM flags that let `@IR` annotation rules fail and the user does not want to provide separate IR rules or add flag preconditions to the already existing IR rules.\n-- `-DTest=test1,test2`: Provide a list of `@Test` method names which should be executed.\n-- `-DExclude=test3`: Provide a list of `@Test` method names which should be excluded from execution.\n-- `-DScenarios=1,2`: Provide a list of scenario indexes to specify which scenarios should be executed.\n-- `-DWarmup=200`: Provide a new default value of the number of warm-up iterations (framework default is 2000). This might have an influence on the resulting IR and could lead to matching failures (the user can also set a fixed default warm-up value in a test with `testFrameworkObject.setDefaultWarmup(200)`).\n-- `-DVerbose=true`: Enable more fain-grained logging (slows the execution down).\n-- `-DReproduce=true`: Flag to use when directly running a test VM to bypass dependencies to the driver VM state (for example, when reproducing an issue).\n-- `-DPrintTimes=true`: Print the execution time measurements of each executed test.\n-- `-DVerifyVM=true`: The framework runs the test VM with additional verification flags (slows the execution down).\n-- `-DExcluceRandom=true`: The framework randomly excludes some methods from compilation. IR verification is disabled completely with this flag.\n-- `-DFlipC1C2=true`: The framework compiles all `@Test` annotated method with C1 if a C2 compilation would have been applied and vice versa. IR verification is disabled completely with this flag.\n-- `-DShuffleTests=false`: Disables the random execution order of all tests (such a shuffling is always done by default).\n-- `-DDumpReplay=true`: Add the `DumpReplay` directive to the test VM.\n-- `-DGCAfter=true`: Perform `System.gc()` after each test (slows the execution down).\n-- `-DWaitForCompilationTimeout=20`: Change the default waiting time (default: 10s) for a compilation of a `@Test` annotated method with compilation level [WAIT_FOR_COMPILATION](.\/CompLevel.java).\n-- `-DIgnoreCompilerControls=false`: Ignore all compiler controls applied in the framework. This includes any compiler control annotations (`@DontCompile`, `@DontInline`, `@ForceCompile`, `@ForceInline`, `@ForceCompileStaticInitializer`), the exclusion of `@Run` and `@Check` methods from compilation, and the directive to not inline `@Test` annotated methods.\n-\n-\n-## 3. Test Framework Execution\n-This section gives an overview of how the framework is executing a JTreg test that calls the framework from within its `main()` method.\n-\n-The framework will spawn a new \"test VM\" to execute the user defined tests. The test VM collects all tests of the test class specified by the user code in `main()` and ensures that there is no violation of the required format by the framework. In a next step, the framework does the following for each test in general:\n-1. Warm the test up for a predefined number of times (default 2000). This can also be adapted for all tests by using `testFrameworkobject.setDefaultWarmup(100)` or for individual tests with an additional [@Warmup](.\/Warmup.java) annotation. \n-2. After the warm-up is finished, the framework compiles the associated `@Test` annotated method at the specified compilation level (default: C2).\n-3. After the compilation, the test is invoked one more time.\n-\n-Once the test VM terminates, IR verification (if possible) is performed on the output of the test VM. If any test throws an exception during its execution or if IR matching fails, the failures are collected and reported in a pretty format. Check the standard error and output for more information and how to reproduce these failures.\n-\n-Some of the steps above can be different due to the kind of the test or due to using non-default annotation properties. These details and differences are described in the Javadocs for the three tests (see section 2.1 Different Tests).\n-\n-More information about the internals and the workflow of the framework can be found in the Javadocs of [TestFramework](.\/TestFramework.java).  \n- \n-## 4. Internal Framework Tests\n-There are various tests to verify the correctness of the test framework. These tests can be found in [tests](tests) and can directly be run with JTreg. The tests are not part of the normal JTreg tests of HotSpot and should only be run upon changing the framework code as a minimal form of testing.\n-\n-Additional testing was performed by converting all compiler Inline Types tests that used the currently present IR test framework in Valhalla (see [JDK-8263024](https:\/\/bugs.openjdk.java.net\/browse\/JDK-8263024)). It is strongly advised to make sure a change to the framework still lets these converted tests in Valhalla pass as part of an additional testing step.\n-\n-## 5. Summary\n- The initial design and feature set was kept simple and straight forward and serves well for small to medium sized tests. There are a lot of possibilities to further enhance the framework and make it more powerful. This can be tackled in additional RFEs. A few ideas can be found as subtasks of the [initial RFE](https:\/\/bugs.openjdk.java.net\/browse\/JDK-8254129) for this framework.\n","filename":"test\/lib\/jdk\/test\/lib\/hotspot\/ir_framework\/README.md","additions":0,"deletions":126,"binary":false,"changes":126,"status":"deleted"},{"patch":"@@ -1,94 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.test.lib.hotspot.ir_framework;\n-\n-import java.lang.reflect.Method;\n-\n-\/**\n- * Test info class which provides some useful utility methods and information about a <b>checked test<\/b>.\n- *\n- * @see Test\n- * @see Check\n- *\/\n-public class TestInfo extends AbstractInfo {\n-    private final Method testMethod;\n-    private final boolean compilationSkipped;\n-\n-    TestInfo(DeclaredTest test) {\n-        super(test.getTestMethod().getDeclaringClass());\n-        this.testMethod = test.getTestMethod();\n-        this.compilationSkipped = test.getCompLevel() == CompLevel.SKIP;\n-    }\n-\n-    \/**\n-     * Get the associated test method object.\n-     *\n-     * @return the associated test method object.\n-     *\/\n-    public Method getTest() {\n-        return testMethod;\n-    }\n-\n-    \/**\n-     * Return a boolean indicating if the framework skipped a compilation after the warm-up due to VM flags not\n-     * allowing a compilation on the requested level in {@link Test#compLevel()}.\n-     *\n-     * @return {@code true} if the framework skipped compilation of the test;\n-     *         {@code false} otherwise.\n-     *\/\n-    public boolean isCompilationSkipped() {\n-        return compilationSkipped;\n-    }\n-\n-    \/**\n-     * Returns a boolean indicating if the associated test method is C1 compiled.\n-     *\n-     * @return {@code true} if the test method is C1 compiled;\n-     *         {@code false} otherwise.\n-     *\/\n-    public boolean isC1Compiled() {\n-        return TestVM.isC1Compiled(testMethod);\n-    }\n-\n-    \/**\n-     * Returns a boolean indicating if the associated test method is C2 compiled.\n-     *\n-     * @return {@code true} if the test method is C2 compiled;\n-     *         {@code false} otherwise.\n-     *\/\n-    public boolean isC2Compiled() {\n-        return TestVM.isC2Compiled(testMethod);\n-    }\n-\n-    \/**\n-     * Returns a boolean indicating if the associated test method is compiled at {@code compLevel}.\n-     *\n-     * @param compLevel the compilation level.\n-     * @return {@code true} if the test method is compiled at {@code compLevel};\n-     *         {@code false} otherwise.\n-     *\/\n-    public boolean isCompiledAtLevel(CompLevel compLevel) {\n-        return TestVM.isCompiledAtLevel(testMethod, compLevel);\n-    }\n-}\n","filename":"test\/lib\/jdk\/test\/lib\/hotspot\/ir_framework\/TestInfo.java","additions":0,"deletions":94,"binary":false,"changes":94,"status":"deleted"},{"patch":"@@ -1,38 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.test.lib.hotspot.ir_framework;\n-\n-\/**\n- * Exception that is thrown if the JTreg test throws an exception during the execution of individual tests of the\n- * test class.\n- *\/\n-public class TestRunException extends RuntimeException {\n-    TestRunException(String message) {\n-        super(message);\n-    }\n-\n-    TestRunException(String message, Exception e) {\n-        super(message, e);\n-    }\n-}\n","filename":"test\/lib\/jdk\/test\/lib\/hotspot\/ir_framework\/TestRunException.java","additions":0,"deletions":38,"binary":false,"changes":38,"status":"deleted"},{"patch":"@@ -1,26 +0,0 @@\n-#\n-# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-\n-# Minimal TEST.ROOT file to run the examples tests as if the examples would have been placed inside\n-# \/test\/hotspot\/jtreg\n-external.lib.roots = ..\/..\/..\/..\/..\/..\/..\/..\n","filename":"test\/lib\/jdk\/test\/lib\/hotspot\/ir_framework\/examples\/TEST.ROOT","additions":0,"deletions":26,"binary":false,"changes":26,"status":"deleted"},{"patch":"@@ -1,35 +0,0 @@\n-#\n-# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-\n-# Minimal TEST.ROOT file to run the internal framework tests as if they would have been placed inside\n-# \/test\/hotspot\/jtreg\n-external.lib.roots = ..\/..\/..\/..\/..\/..\/..\/..\n-requires.extraPropDefns = ..\/..\/..\/..\/..\/..\/..\/jtreg-ext\/requires\/VMProps.java\n-requires.extraPropDefns.bootlibs = ..\/..\/..\/..\/..\/..\/..\/lib\/sun\n-requires.extraPropDefns.libs = \\\n-    ..\/..\/..\/..\/..\/..\/..\/lib\/jdk\/test\/lib\/Platform.java \\\n-    ..\/..\/..\/..\/..\/..\/..\/lib\/jdk\/test\/lib\/Container.java\n-requires.extraPropDefns.vmOpts = -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n-requires.properties= \\\n-    vm.debug \\\n-    vm.compiler2.enabled \\\n","filename":"test\/lib\/jdk\/test\/lib\/hotspot\/ir_framework\/tests\/TEST.ROOT","additions":0,"deletions":35,"binary":false,"changes":35,"status":"deleted"},{"patch":"@@ -1,76 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.test.lib.hotspot.ir_framework.tests;\n-\n-import jdk.test.lib.hotspot.ir_framework.Test;\n-import jdk.test.lib.hotspot.ir_framework.TestFramework;\n-\n-\/*\n- * @test\n- * @requires vm.debug == true & vm.compMode != \"Xint\" & vm.compiler2.enabled\n- * @summary Sanity test remaining framework property flags.\n- * @library \/test\/lib\n- * @run main\/othervm -DFlipC1C2=true jdk.test.lib.hotspot.ir_framework.tests.TestDFlags\n- * @run main\/othervm -DExcludeRandom=true jdk.test.lib.hotspot.ir_framework.tests.TestDFlags\n- * @run main\/othervm -DVerifyVM=true jdk.test.lib.hotspot.ir_framework.tests.TestDFlags\n- * @run main\/othervm -DDumpReplay=true jdk.test.lib.hotspot.ir_framework.tests.TestDFlags\n- * @run main\/othervm -DVerbose=true jdk.test.lib.hotspot.ir_framework.tests.TestDFlags\n- * @run main\/othervm -DShuffleTests=false jdk.test.lib.hotspot.ir_framework.tests.TestDFlags\n- * @run main\/othervm -DReproduce=true jdk.test.lib.hotspot.ir_framework.tests.TestDFlags\n- * @run main\/othervm -DReportStdout=true jdk.test.lib.hotspot.ir_framework.tests.TestDFlags\n- * @run main\/othervm -DGCAfter=true jdk.test.lib.hotspot.ir_framework.tests.TestDFlags\n- * @run main\/othervm -DPrintTimes=true jdk.test.lib.hotspot.ir_framework.tests.TestDFlags\n- * @run main\/othervm -DVerifyIR=false jdk.test.lib.hotspot.ir_framework.tests.TestDFlags\n- *\/\n-\n-public class TestDFlags {\n-    public static void main(String[] args) {\n-        TestFramework.run();\n-    }\n-\n-    @Test\n-    public int c1() {\n-        return 34;\n-    }\n-\n-\n-    @Test\n-    public void c2() {\n-        for (int i = 0; i < 100; i++) {\n-        }\n-    }\n-\n-    @Test\n-    public void c2_2() {\n-        for (int i = 0; i < 100; i++) {\n-        }\n-    }\n-\n-    @Test\n-    public void c2_3() {\n-        for (int i = 0; i < 100; i++) {\n-        }\n-    }\n-}\n-\n","filename":"test\/lib\/jdk\/test\/lib\/hotspot\/ir_framework\/tests\/TestDFlags.java","additions":0,"deletions":76,"binary":false,"changes":76,"status":"deleted"},{"patch":"@@ -1,93 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.test.lib.hotspot.ir_framework.tests;\n-\n-import jdk.test.lib.Utils;\n-import jdk.test.lib.hotspot.ir_framework.*;\n-import jdk.test.lib.Asserts;\n-import jdk.test.lib.process.OutputAnalyzer;\n-import jdk.test.lib.process.ProcessTools;\n-\n-\/*\n- * @test\n- *  @requires vm.debug == true\n- * @summary Test -DScenarios property flag. Run with othervm which should not be done when writing tests using the framework.\n- * @library \/test\/lib\n- * @run main\/othervm -DScenarios=1,5,10 jdk.test.lib.hotspot.ir_framework.tests.TestDScenarios test\n- * @run main\/othervm -DScenarios=1,4 jdk.test.lib.hotspot.ir_framework.tests.TestDScenarios test\n- * @run main\/othervm -DScenarios=3,4,9 jdk.test.lib.hotspot.ir_framework.tests.TestDScenarios test\n- * @run driver jdk.test.lib.hotspot.ir_framework.tests.TestDScenarios test2\n- * @run driver jdk.test.lib.hotspot.ir_framework.tests.TestDScenarios\n- *\/\n-\n-public class TestDScenarios {\n-    public static void main(String[] args) throws Exception {\n-        if (args.length > 0) {\n-            switch (args[0]) {\n-                case \"test\" -> {\n-                    Scenario s1 = new Scenario(1);\n-                    Scenario s2 = new Scenario(5);\n-                    Scenario s3 = new Scenario(10);\n-                    Scenario bad = new Scenario(0, \"-Flagdoesnotexist\"); \/\/ not executed\n-                    new TestFramework().addScenarios(bad, s1, s2, s3).start();\n-                }\n-                case \"test2\" -> {\n-                    try {\n-                        TestFramework.run(DScenariosBad.class);\n-                        throw new RuntimeException(\"should not reach\");\n-                    } catch (TestVMException e) {\n-                        System.out.println(e.getExceptionInfo());\n-                        Asserts.assertTrue(e.getExceptionInfo().contains(\"Expected DScenariosBad exception\"));\n-                    }\n-                }\n-                default -> {\n-                    \/\/ Invalid -DScenarios set and thus exception thrown when Scenario class is statically initialized.\n-                    Scenario s = new Scenario(3);\n-                    throw new RuntimeException(\"should not reach\");\n-                }\n-            }\n-        } else {\n-            \/\/ Test invalid -DScenario flag.\n-            OutputAnalyzer oa;\n-            ProcessBuilder process = ProcessTools.createJavaProcessBuilder(\n-                    \"-Dtest.jdk=\" + Utils.TEST_JDK, \"-DScenarios=a,1,b,10\",\n-                    \"jdk.test.lib.hotspot.ir_framework.tests.TestDScenarios\", \" test3\");\n-            oa = ProcessTools.executeProcess(process);\n-            oa.shouldNotHaveExitValue(0);\n-            System.out.println(oa.getOutput());\n-            Asserts.assertTrue(oa.getOutput().contains(\"TestRunException: Provided a scenario index\"));\n-        }\n-    }\n-\n-    @Test\n-    public void test() {\n-    }\n-}\n-\n-class DScenariosBad {\n-    @Test\n-    public void test() {\n-        throw new RuntimeException(\"Expected DScenariosBad exception\");\n-    }\n-}\n","filename":"test\/lib\/jdk\/test\/lib\/hotspot\/ir_framework\/tests\/TestDScenarios.java","additions":0,"deletions":93,"binary":false,"changes":93,"status":"deleted"},{"patch":"@@ -1,105 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.test.lib.hotspot.ir_framework.tests;\n-\n-import jdk.test.lib.hotspot.ir_framework.*;\n-import jdk.test.lib.Asserts;\n-\n-\/*\n- * @test\n- * @requires vm.compMode != \"Xint\" & vm.compiler2.enabled\n- * @summary Test scenarios with the framework.\n- * @library \/test\/lib\n- * @run driver jdk.test.lib.hotspot.ir_framework.tests.TestScenarios\n- *\/\n-\n-public class TestScenarios {\n-    public static void main(String[] args) {\n-        Scenario sDefault = new Scenario(0);\n-        Scenario s1 = new Scenario(1, \"-XX:SuspendRetryCount=51\");\n-        Scenario s2 = new Scenario(2, \"-XX:SuspendRetryCount=52\");\n-        Scenario s3 = new Scenario(3, \"-XX:SuspendRetryCount=53\");\n-        Scenario s3dup = new Scenario(3, \"-XX:SuspendRetryCount=53\");\n-        try {\n-            new TestFramework().addScenarios(sDefault, s1, s2, s3).start();\n-            Asserts.fail(\"Should not reach\");\n-        } catch (TestRunException e) {\n-            Asserts.assertTrue(e.getMessage().contains(\"The following scenarios have failed: #0, #1, #3\"), e.getMessage());\n-        }\n-        try {\n-            new TestFramework().addScenarios(s1, s2, s3).start();\n-            Asserts.fail(\"Should not reach\");\n-        } catch (TestRunException e) {\n-            Asserts.assertTrue(e.getMessage().contains(\"The following scenarios have failed: #1, #3\"), e.getMessage());\n-        }\n-        new TestFramework(ScenarioTest.class).addScenarios(s1, s2, s3).start();\n-        try {\n-            new TestFramework().addScenarios(s1, s3dup, s2, s3).start();\n-            Asserts.fail(\"Should not reach\");\n-        } catch (RuntimeException e) {\n-            Asserts.assertTrue(e.getMessage().contains(\"Cannot define two scenarios with the same index 3\"), e.getMessage());\n-        }\n-        try {\n-            new TestFramework(MyExceptionTest.class).addScenarios(s1, s2, s3).start();\n-            Asserts.fail(\"Should not reach\");\n-        } catch (TestRunException e) {\n-            Asserts.assertTrue(s1.getTestVMOutput().contains(\"Caused by: jdk.test.lib.hotspot.ir_framework.tests.MyScenarioException\"));\n-            Asserts.assertTrue(s2.getTestVMOutput().contains(\"Caused by: jdk.test.lib.hotspot.ir_framework.tests.MyScenarioException\"));\n-            Asserts.assertTrue(s3.getTestVMOutput().contains(\"Caused by: jdk.test.lib.hotspot.ir_framework.tests.MyScenarioException\"));\n-        } catch (Exception e) {\n-            Asserts.fail(\"Should not catch other exceptions\");\n-        }\n-\n-    }\n-\n-    @Test\n-    @IR(applyIf = {\"SuspendRetryCount\", \"50\"}, counts = {IRNode.CALL, \"1\"})\n-    public void failDefault() {\n-    }\n-\n-    @Test\n-    @IR(applyIf = {\"SuspendRetryCount\", \"51\"}, counts = {IRNode.CALL, \"1\"})\n-    @IR(applyIf = {\"SuspendRetryCount\", \"53\"}, counts = {IRNode.CALL, \"1\"})\n-    public void failS3() {\n-    }\n-}\n-\n-class ScenarioTest {\n-    @Test\n-    @IR(applyIf = {\"SuspendRetryCount\", \"54\"}, counts = {IRNode.CALL, \"1\"})\n-    public void doesNotFail() {\n-    }\n-}\n-\n-class MyExceptionTest {\n-    int iFld;\n-    @Test\n-    @IR(failOn = IRNode.STORE) \/\/ Not evaluated due to MyScenarioException\n-    public void test() {\n-        iFld = 42;\n-        throw new MyScenarioException();\n-    }\n-}\n-\n-class MyScenarioException extends RuntimeException {}\n","filename":"test\/lib\/jdk\/test\/lib\/hotspot\/ir_framework\/tests\/TestScenarios.java","additions":0,"deletions":105,"binary":false,"changes":105,"status":"deleted"},{"patch":"@@ -1,154 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.test.lib.hotspot.ir_framework.tests;\n-\n-import jdk.test.lib.hotspot.ir_framework.*;\n-import jdk.test.lib.Asserts;\n-\n-\/*\n- * @test\n- * @summary Test the framework with helper classes.\n- * @library \/test\/lib\n- * @run driver jdk.test.lib.hotspot.ir_framework.tests.TestWithHelperClasses\n- *\/\n-\n-public class TestWithHelperClasses {\n-\n-    public static void main(String[] args) {\n-        new TestFramework().addHelperClasses(Helper1.class, Helper2.class).start();\n-        try {\n-            new TestFramework().addHelperClasses(Helper1.class).start();\n-            shouldNotReach();\n-        } catch (TestVMException e) {\n-            Asserts.assertFalse(e.getExceptionInfo().contains(\"public static void jdk.test.lib.hotspot.ir_framework.tests.Helper1.foo() should have been C2 compiled\"));\n-            Asserts.assertFalse(TestFramework.getLastTestVMOutput().contains(\"public static void jdk.test.lib.hotspot.ir_framework.tests.Helper1.foo() should have been C2 compiled\"));\n-            Asserts.assertTrue(TestFramework.getLastTestVMOutput().contains(\"public static void jdk.test.lib.hotspot.ir_framework.tests.Helper2.foo() should have been C2 compiled\"));\n-            Asserts.assertTrue(e.getExceptionInfo().contains(\"public static void jdk.test.lib.hotspot.ir_framework.tests.Helper2.foo() should have been C2 compiled\"));\n-            Asserts.assertFalse(TestFramework.getLastTestVMOutput().contains(\"Should not be executed\"));\n-            Asserts.assertFalse(e.getExceptionInfo().contains(\"Should not be executed\"));\n-        }\n-\n-        try {\n-            new TestFramework(BadHelperClass.class).addHelperClasses(BadHelper.class).start();\n-            shouldNotReach();\n-        } catch (TestFormatException e) {\n-            Asserts.assertTrue(e.getMessage().contains(\"Cannot use @Test annotation in helper class\"));\n-            Asserts.assertTrue(e.getMessage().contains(\"Cannot use @Check annotation in helper class\"));\n-            Asserts.assertTrue(e.getMessage().contains(\"Cannot use @Run annotation in helper class\"));\n-            Asserts.assertTrue(e.getMessage().contains(\"noTestInHelper\"));\n-            Asserts.assertTrue(e.getMessage().contains(\"test2\"));\n-            Asserts.assertTrue(e.getMessage().contains(\"check2\"));\n-            Asserts.assertTrue(e.getMessage().contains(\"test3\"));\n-            Asserts.assertTrue(e.getMessage().contains(\"run3\"));\n-        }\n-\n-        try {\n-            new TestFramework(TestAsHelper.class).addHelperClasses(TestAsHelper.class).start();\n-            shouldNotReach();\n-        } catch (TestFormatException e) {\n-            Asserts.assertTrue(e.getMessage().contains(\"Cannot specify test class jdk.test.lib.hotspot.ir_framework.\" +\n-                                                       \"tests.TestAsHelper as helper class, too\"));\n-        }\n-\n-        try {\n-            new TestFramework().addHelperClasses(NestedHelper.class).start();\n-            shouldNotReach();\n-        } catch (TestFormatException e) {\n-            Asserts.assertTrue(e.getMessage().contains(\"Nested class\"));\n-            Asserts.assertTrue(e.getMessage().contains(\"TestWithHelperClasses$NestedHelper inside test class\"));\n-        }\n-    }\n-\n-    public static void shouldNotReach() {\n-        throw new RuntimeException(\"should not reach\");\n-    }\n-\n-    @Test\n-    public void test() throws NoSuchMethodException {\n-        TestFramework.assertCompiledByC2(Helper1.class.getMethod(\"foo\"));\n-        TestFramework.assertCompiledByC2(Helper2.class.getMethod(\"foo\"));\n-        TestFramework.assertCompiledByC2(NestedHelper.class.getMethod(\"foo\"));\n-        TestFramework.assertCompiledByC2(StaticNestedHelper.class.getMethod(\"foo\"));\n-    }\n-\n-    class NestedHelper {\n-        @ForceCompile(CompLevel.C2)\n-        public void foo() {\n-            throw new RuntimeException(\"Should not be executed\");\n-        }\n-    }\n-\n-\n-    static class StaticNestedHelper {\n-        @ForceCompile(CompLevel.C2)\n-        public void foo() {\n-            throw new RuntimeException(\"Should not be executed\");\n-        }\n-    }\n-}\n-\n-class TestAsHelper {\n-\n-    @Test\n-    public void foo() {}\n-}\n-\n-class Helper1 {\n-\n-    @ForceCompile(CompLevel.C2)\n-    public static void foo() {\n-        throw new RuntimeException(\"Should not be executed\");\n-    }\n-}\n-\n-class Helper2 {\n-\n-    @ForceCompile(CompLevel.C2)\n-    public static void foo() {\n-        throw new RuntimeException(\"Should not be executed\");\n-    }\n-}\n-\n-class BadHelperClass {\n-    @Test\n-    public void test1() {}\n- }\n-\n-\n-class BadHelper {\n-    @Test\n-    public void noTestInHelper() {}\n-\n-    @Test\n-    public void test2() {}\n-\n-    @Check(test = \"test2\")\n-    public void check2() {}\n-\n-    @Test\n-    public void test3() {}\n-\n-    @Run(test = \"test3\")\n-    public void run3() {}\n-}\n","filename":"test\/lib\/jdk\/test\/lib\/hotspot\/ir_framework\/tests\/TestWithHelperClasses.java","additions":0,"deletions":154,"binary":false,"changes":154,"status":"deleted"}]}